[
  {
    "function_name": "appshare_main",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/appshare.c",
    "lines": "1889-2123",
    "snippet": "int appshare_main(int argc, char *argv[]) {\n\tint i;\n\tchar *app_str = NULL;\n\tchar *dpy_str = NULL;\n\tlong xselectinput = 0;\n#if NO_X11\n\texiter(\"not compiled with X11\\n\", 1);\n#else\n\tfor (i=0; i < WMAX; i++) {\n\t\twatch[i] = None;\n\t\tstate[i] = 0;\n\t}\n\tfor (i=0; i < AMAX; i++) {\n\t\tapps[i]  = None;\n\t}\n\tfor (i=0; i < CMAX; i++) {\n\t\tclients[i] = NULL;\n\t}\n\n\tx11vnc = strdup(argv[0]);\n\n\tfor (i=1; i < argc; i++) {\n\t\tint end = (i == argc-1) ? 1 : 0;\n\t\tchar *s = argv[i];\n\t\tif (strstr(s, \"--\") == s) {\n\t\t\ts++;\n\t\t}\n\n\t\tif (!strcmp(s, \"-h\") || !strcmp(s, \"-help\")) {\n\t\t\tfprintf(stdout, \"%s\", usage);\n\t\t\texit(0);\n\t\t} else if (!strcmp(s, \"-id\")) {\n\t\t\tid_opt = \"-id\";\n\t\t\tif (end) exiter(\"no -id value supplied\\n\", 1);\n\t\t\tapp_str = strdup(argv[++i]);\n\t\t} else if (!strcmp(s, \"-sid\")) {\n\t\t\tid_opt = \"-sid\";\n\t\t\tif (end) exiter(\"no -sid value supplied\\n\", 1);\n\t\t\tapp_str = strdup(argv[++i]);\n\t\t} else if (!strcmp(s, \"-connect\") || !strcmp(s, \"-connect_or_exit\") || !strcmp(s, \"-coe\")) {\n\t\t\tif (end) exiter(\"no -connect value supplied\\n\", 1);\n\t\t\tconnect_to = strdup(argv[++i]);\n\t\t} else if (!strcmp(s, \"-control\")) {\n\t\t\tif (end) exiter(\"no -control value supplied\\n\", 1);\n\t\t\tcontrol = strdup(argv[++i]);\n\t\t\tif (!strcmp(control, \"shell\")) {\n\t\t\t\tfree(control);\n\t\t\t\tcontrol = strdup(\"internal\");\n\t\t\t\tshell = 1;\n\t\t\t}\n\t\t} else if (!strcmp(s, \"-trackdir\")) {\n\t\t\tif (end) exiter(\"no -trackdir value supplied\\n\", 1);\n\t\t\ttrackdir = strdup(argv[++i]);\n\t\t} else if (!strcmp(s, \"-display\")) {\n\t\t\tif (end) exiter(\"no -display value supplied\\n\", 1);\n\t\t\tdpy_str = strdup(argv[++i]);\n\t\t\tset_env(\"DISPLAY\", dpy_str);\n\t\t} else if (!strcmp(s, \"-delay\")) {\n\t\t\tif (end) exiter(\"no -delay value supplied\\n\", 1);\n\t\t\thelper_delay = atof(argv[++i]);\n\t\t} else if (!strcmp(s, \"-args\")) {\n\t\t\tif (end) exiter(\"no -args value supplied\\n\", 1);\n\t\t\tx11vnc_args = strdup(argv[++i]);\n\t\t} else if (!strcmp(s, \"-env\")) {\n\t\t\tif (end) exiter(\"no -env value supplied\\n\", 1);\n\t\t\tputenv(argv[++i]);\n\t\t} else if (!strcmp(s, \"-debug\")) {\n\t\t\tappshare_debug++;\n\t\t} else if (!strcmp(s, \"-showmenus\")) {\n\t\t\tskip_menus = 0;\n\t\t} else if (!strcmp(s, \"-noexit\")) {\n\t\t\texit_no_app_win = 0;\n\t\t} else if (!strcmp(s, \"-shell\")) {\n\t\t\tshell = 1;\n\t\t} else if (!strcmp(s, \"-nocmds\") || !strcmp(s, \"-safer\")) {\n\t\t\tfprintf(stderr, \"ignoring %s in -appshare mode.\\n\", s);\n\t\t} else if (!strcmp(s, \"-appshare\")) {\n\t\t\t;\n\t\t} else {\n\t\t\tfprintf(stderr, \"unrecognized 'x11vnc -appshare' option: %s\\n\", s);\n\t\t\texiter(\"\", 1);\n\t\t}\n\t}\n\n\tif (getenv(\"X11VNC_APPSHARE_DEBUG\")) {\n\t\tappshare_debug = atoi(getenv(\"X11VNC_APPSHARE_DEBUG\"));\n\t}\n\n\t/* let user override name for multiple instances: */\n\tif (getenv(\"X11VNC_APPSHARE_COMMAND_PROPNAME\")) {\n\t\tcmd_atom_str = strdup(getenv(\"X11VNC_APPSHARE_COMMAND_PROPNAME\"));\n\t}\n\tif (getenv(\"X11VNC_APPSHARE_TICKER_PROPNAME\")) {\n\t\tticker_atom_str = strdup(getenv(\"X11VNC_APPSHARE_TICKER_PROPNAME\"));\n\t}\n\n\tif (shell) {\n\t\tif (!control || strcmp(control, \"internal\")) {\n\t\t\texiter(\"mode -shell requires '-control internal'\\n\", 1);\n\t\t}\n\t}\n\n\tif (connect_to == NULL && control != NULL) {\n\t\tstruct stat sb;\n\t\tif (stat(control, &sb) == 0) {\n\t\t\tint len = 100 + sb.st_size;\n\t\t\tFILE *f = fopen(control, \"r\");\n\n\t\t\tif (f) {\n\t\t\t\tchar *line = (char *) malloc(len);\n\t\t\t\tconnect_to = (char *) calloc(2 * len, 1);\n\t\t\t\twhile (fgets(line, len, f) != NULL) {\n\t\t\t\t\tchar *q = strchr(line, '\\n');\n\t\t\t\t\tif (q) *q = '\\0';\n\t\t\t\t\tq = lblanks(line);\n\t\t\t\t\tif (q[0] == '#') {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tif (connect_to[0] != '\\0') {\n\t\t\t\t\t\tstrcat(connect_to, \",\");\n\t\t\t\t\t}\n\t\t\t\t\tstrcat(connect_to, q);\n\t\t\t\t}\n\t\t\t\tfclose(f);\n\t\t\t}\n\t\t\tfprintf(stderr, \"set -connect to: %s\\n\", connect_to);\n\t\t}\n\t}\n\tif (0 && connect_to == NULL && control == NULL) {\n\t\texiter(\"no -connect host or -control file specified.\\n\", 1);\n\t}\n\n\tif (control) {\n\t\tpid_t pid;\n\t\tparent_pid = getpid();\n\t\tpid = fork();\n\t\tif (pid == (pid_t) -1) {\n\t\t\t;\n\t\t} else if (pid == 0) {\n\t\t\tbe_helper_pid(dpy_str);\n\t\t\texit(0);\n\t\t} else {\n\t\t\thelper_pid = pid;\n\t\t}\n\t}\n\n\tdpy = XOpenDisplay(dpy_str);\n\tif (!dpy) {\n\t\texiter(\"cannot open display\\n\", 1);\n\t}\n\n\troot = DefaultRootWindow(dpy);\n\n\txselectinput = SubstructureNotifyMask;\n\tif (helper_pid > 0) {\n\t\tticker_atom = XInternAtom(dpy, ticker_atom_str, False);\n\t\txselectinput |= PropertyChangeMask;\n\t}\n\tXSelectInput(dpy, root, xselectinput);\n\n\tcmd_atom = XInternAtom(dpy, cmd_atom_str, False);\n\n\tinit_cmask();\n\n\tsprintf(unique_tag, \"X11VNC_APPSHARE_TAG=%d-tag\", getpid());\n\n\tstart_time = dnow();\n\n\tif (app_str == NULL) {\n\t\texiter(\"no -id/-sid window specified.\\n\", 1);\n\t} else {\n\t\tchar *p, *str = strdup(app_str);\n\t\tchar *alist[AMAX];\n\t\tint i, n = 0;\n\n\t\tp = strtok(str, \",\");\n\t\twhile (p) {\n\t\t\tif (n >= AMAX) {\n\t\t\t\tfprintf(stderr, \"ran out of app slots: %s\\n\", app_str);\n\t\t\t\texiter(\"\", 1);\n\t\t\t}\n\t\t\talist[n++] = strdup(p);\n\t\t\tp = strtok(NULL, \",\");\n\t\t}\n\t\tfree(str);\n\n\t\tfor (i=0; i < n; i++) {\n\t\t\tWindow app = None;\n\t\t\tp = alist[i];\n\t\t\tapp = parse_win(p);\n\t\t\tfree(p);\n\n\t\t\tif (app != None) {\n\t\t\t\tif (!ours(app)) {\n\t\t\t\t\tadd_app(app);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tset_trackdir();\n\n\tsignal(SIGINT,  appshare_cleanup);\n\tsignal(SIGTERM, appshare_cleanup);\n\n\trfbLogEnable(0);\n\n\tif (connect_to) {\n\t\tchar *p, *str = strdup(connect_to);\n\t\tint n = 0;\n\t\tp = strtok(str, \",\");\n\t\twhile (p) {\n\t\t\tclients[n++] = strdup(p);\n\t\t\tp = strtok(NULL, \",\");\n\t\t}\n\t\tfree(str);\n\t} else {\n\t\tconnect_to = strdup(\"\");\n\t}\n\n\tfor (i=0; i < AMAX; i++) {\n\t\tif (apps[i] == None) {\n\t\t\tcontinue;\n\t\t}\n\t\tfprintf(stdout, \"Using app win: 0x%08lx  root: 0x%08lx\\n\", apps[i], root);\n\t}\n\tfprintf(stdout, \"\\n\");\n\n\tmonitor();\n\n\tappshare_cleanup(0);\n\n#endif\n\treturn 0;\n}",
    "includes": [
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [
      "#define AMAX 32",
      "#define CMAX 128",
      "#define WMAX 192"
    ],
    "globals_used": [
      "extern char *get_xprop(char *prop, Window win);",
      "extern int set_xprop(char *prop, Window win, char *value);",
      "extern void set_env(char *name, char *value);",
      "extern double dnow(void);",
      "static char *usage =\n\"\\n\"\n\"  x11vnc -appshare: an experiment in application sharing via x11vnc.\\n\"\n\"\\n\""
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "appshare_cleanup",
          "args": [
            "0"
          ],
          "line": 2119
        },
        "resolved": true,
        "details": {
          "function_name": "appshare_cleanup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/appshare.c",
          "lines": "630-688",
          "snippet": "static void appshare_cleanup(int s) {\n\tint i;\n\tif (s) {}\n\n\tif (use_forever) {\n\t\t/* launch this backup in case they kill -9 us before we terminate everything */\n\t\tchar cmd[1000];\n\t\tsprintf(cmd, \"(sleep 3; pkill -TERM -f '%s') &\", unique_tag);\n\t\tif (appshare_debug) fprintf(stderr, \"%s\\n\", cmd);\n\t\tsystem(cmd);\n\t}\n\n\tfor (i=0; i < WMAX; i++) {\n\t\tif (watch[i] != None) {\n\t\t\tstop(watch[i]);\n\t\t}\n\t}\n\n\tif (trackdir) {\n\t\tDIR *dir = opendir(trackdir);\n\t\tif (dir) {\n\t\t\tstruct dirent *dp;\n\t\t\twhile ( (dp = readdir(dir)) != NULL) {\n\t\t\t\tchar *name = dp->d_name;\n\t\t\t\tif (!strcmp(name, \".\") || !strcmp(name, \"..\")) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (strstr(name, \"0x\") != name) {\n\t\t\t\t\tfprintf(stderr, \"skipping: %s\\n\", name);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (!appshare_debug) {\n\t\t\t\t\tfprintf(stderr, \"removing: %s\\n\", name);\n\t\t\t\t\tsprintf(tracktmp, \"%s/%s\", trackdir, name);\n\t\t\t\t\tunlink(tracktmp);\n\t\t\t\t} else {\n\t\t\t\t\tif (appshare_debug) fprintf(stderr, \"keeping:  %s\\n\", name);\n\t\t\t\t}\n\t\t\t}\n\t\t\tclosedir(dir);\n\t\t}\n\t\tif (!appshare_debug) {\n\t\t\tif (strstr(trackdir, trackpre) == trackdir) {\n\t\t\t\tif (appshare_debug) fprintf(stderr, \"removing: %s\\n\", trackdir);\n\t\t\t\trmdir(trackdir);\n\t\t\t}\n\t\t}\n\t\tff();\n\t}\n\n\tkill_helper_pid();\n\t\t\t\n#if !NO_X11\n\tXCloseDisplay(dpy);\n#endif\n\tfprintf(stdout, \"done.\\n\");\n\tff();\n\texit(0);\n}",
          "includes": [
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [
            "#define WMAX 192"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"x11vnc.h\"\n\n#define WMAX 192\n\nstatic void appshare_cleanup(int s) {\n\tint i;\n\tif (s) {}\n\n\tif (use_forever) {\n\t\t/* launch this backup in case they kill -9 us before we terminate everything */\n\t\tchar cmd[1000];\n\t\tsprintf(cmd, \"(sleep 3; pkill -TERM -f '%s') &\", unique_tag);\n\t\tif (appshare_debug) fprintf(stderr, \"%s\\n\", cmd);\n\t\tsystem(cmd);\n\t}\n\n\tfor (i=0; i < WMAX; i++) {\n\t\tif (watch[i] != None) {\n\t\t\tstop(watch[i]);\n\t\t}\n\t}\n\n\tif (trackdir) {\n\t\tDIR *dir = opendir(trackdir);\n\t\tif (dir) {\n\t\t\tstruct dirent *dp;\n\t\t\twhile ( (dp = readdir(dir)) != NULL) {\n\t\t\t\tchar *name = dp->d_name;\n\t\t\t\tif (!strcmp(name, \".\") || !strcmp(name, \"..\")) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (strstr(name, \"0x\") != name) {\n\t\t\t\t\tfprintf(stderr, \"skipping: %s\\n\", name);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (!appshare_debug) {\n\t\t\t\t\tfprintf(stderr, \"removing: %s\\n\", name);\n\t\t\t\t\tsprintf(tracktmp, \"%s/%s\", trackdir, name);\n\t\t\t\t\tunlink(tracktmp);\n\t\t\t\t} else {\n\t\t\t\t\tif (appshare_debug) fprintf(stderr, \"keeping:  %s\\n\", name);\n\t\t\t\t}\n\t\t\t}\n\t\t\tclosedir(dir);\n\t\t}\n\t\tif (!appshare_debug) {\n\t\t\tif (strstr(trackdir, trackpre) == trackdir) {\n\t\t\t\tif (appshare_debug) fprintf(stderr, \"removing: %s\\n\", trackdir);\n\t\t\t\trmdir(trackdir);\n\t\t\t}\n\t\t}\n\t\tff();\n\t}\n\n\tkill_helper_pid();\n\t\t\t\n#if !NO_X11\n\tXCloseDisplay(dpy);\n#endif\n\tfprintf(stdout, \"done.\\n\");\n\tff();\n\texit(0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "monitor",
          "args": [],
          "line": 2117
        },
        "resolved": true,
        "details": {
          "function_name": "monitor",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/appshare.c",
          "lines": "1757-1887",
          "snippet": "static void monitor(void) {\n#if !NO_X11\n\tXEvent ev;\n\tdouble start = dnow();\n\tint got_prop_cmd = 0;\n\n\tif (shell) {\n\t\tupdate();\n\t\tfprintf(stderr, \"\\n\\n\");\n\t\tprocess_string(\"cmd=help\");\n\t\tfprintf(stderr, \"\\n%s\", prompt); ff();\n\t}\n\n\twhile (1) {\n\t\tint t;\n\n\t\tif (XEventsQueued(dpy, QueuedAlready) == 0) {\n\t\t\tupdate();\n\t\t\tif (got_prop_cmd) {\n\t\t\t\thandle_prop_cmd();\n\t\t\t}\n\t\t\tgot_prop_cmd = 0;\n\t\t\tif (shell) {\n\t\t\t\thandle_shell();\n\t\t\t}\n\t\t}\n\n\t\tXNextEvent(dpy, &ev);\n\n\t\tlast_event_type = ev.type;\n\n\t\tswitch (ev.type) {\n\t\tcase Expose:\n\t\t\tPREFIX\n\t\t\tif(appshare_debug) fprintf(stderr, \"Expose %04dx%04d+%04d+%04d\\n\", ev.xexpose.width, ev.xexpose.height, ev.xexpose.x, ev.xexpose.y);\n\t\t\tbreak;\n\t\tcase ConfigureNotify:\n#if 0\n\t\t\tPREFIX\n\t\t\tif(appshare_debug) fprintf(stderr, \"ConfigureNotify %04dx%04d+%04d+%04d  above: 0x%lx\\n\", ev.xconfigure.width, ev.xconfigure.height, ev.xconfigure.x, ev.xconfigure.y, ev.xconfigure.above);\n#endif\n\t\t\tbreak;\n\t\tcase VisibilityNotify:\n\t\t\tPREFIX\n\t\t\tif (appshare_debug) {\n\t\t\tfprintf(stderr, \"VisibilityNotify: \");\n\t\t\tt = ev.xvisibility.state;\n\t\t\tif (t == VisibilityFullyObscured)     fprintf(stderr, \"VisibilityFullyObscured\\n\");\n\t\t\tif (t == VisibilityPartiallyObscured) fprintf(stderr, \"VisibilityPartiallyObscured\\n\");\n\t\t\tif (t == VisibilityUnobscured)        fprintf(stderr, \"VisibilityUnobscured\\n\");\n\t\t\t}\n\t\t\tbreak;\n\t\tcase MapNotify:\n\t\t\tPREFIX\n\t\t\tif(appshare_debug) fprintf(stderr, \"MapNotify      win: 0x%lx\\n\", ev.xmap.window);\n\t\t\tif (ours(ev.xmap.window)) {\n\t\t\t\tmapped(ev.xmap.window);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase UnmapNotify:\n\t\t\tPREFIX\n\t\t\tif(appshare_debug) fprintf(stderr, \"UnmapNotify    win: 0x%lx\\n\", ev.xmap.window);\n\t\t\tif (ours(ev.xmap.window)) {\n\t\t\t\tunmapped(ev.xmap.window);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase MapRequest:\n\t\t\tPREFIX\n\t\t\tif(appshare_debug) fprintf(stderr, \"MapRequest\\n\");\n\t\t\tbreak;\n\t\tcase CreateNotify:\n\t\t\tPREFIX\n\t\t\tif(appshare_debug) fprintf(stderr, \"CreateNotify parent: 0x%lx  win: 0x%lx\\n\", ev.xcreatewindow.parent, ev.xcreatewindow.window);\n\t\t\tif (ev.xcreatewindow.parent == root && ours(ev.xcreatewindow.window)) {\n\t\t\t\tif (find_win(ev.xcreatewindow.window) >= 0) {\n\t\t\t\t\tdestroy_win(ev.xcreatewindow.window);\n\t\t\t\t}\n\t\t\t\tadd_win(ev.xcreatewindow.window);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase DestroyNotify:\n\t\t\tPREFIX\n\t\t\tif(appshare_debug) fprintf(stderr, \"DestroyNotify  win: 0x%lx\\n\", ev.xdestroywindow.window);\n\t\t\tif (ours(ev.xdestroywindow.window)) {\n\t\t\t\tdestroy_win(ev.xdestroywindow.window);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase ConfigureRequest:\n\t\t\tPREFIX\n\t\t\tif(appshare_debug) fprintf(stderr, \"ConfigureRequest\\n\");\n\t\t\tbreak;\n\t\tcase CirculateRequest:\n#if 0\n\t\t\tPREFIX\n\t\t\tif(appshare_debug) fprintf(stderr, \"CirculateRequest parent: 0x%lx  win: 0x%lx\\n\", ev.xcirculaterequest.parent, ev.xcirculaterequest.window);\n#endif\n\t\t\tbreak;\n\t\tcase CirculateNotify:\n#if 0\n\t\t\tPREFIX\n\t\t\tif(appshare_debug) fprintf(stderr, \"CirculateNotify\\n\");\n#endif\n\t\t\tbreak;\n\t\tcase PropertyNotify:\n#if 0\n\t\t\tPREFIX\n\t\t\tif(appshare_debug) fprintf(stderr, \"PropertyNotify\\n\");\n#endif\n\t\t\tif (cmd_atom != None && ev.xproperty.atom == cmd_atom) {\n\t\t\t\tgot_prop_cmd++;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase ReparentNotify:\n\t\t\tPREFIX\n\t\t\tif(appshare_debug) fprintf(stderr, \"ReparentNotify parent: 0x%lx  win: 0x%lx\\n\", ev.xreparent.parent, ev.xreparent.window);\n\t\t\tif (ours(ev.xreparent.window)) {\n\t\t\t\tif (ours(ev.xreparent.parent)) {\n\t\t\t\t\tdestroy_win(ev.xreparent.window);\n\t\t\t\t} else if (ev.xreparent.parent == root) {\n\t\t\t\t\t/* ??? */\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tPREFIX\n\t\t\tif(appshare_debug) fprintf(stderr, \"Unknown: %d\\n\", ev.type);\n\t\t\tbreak;\n\t\t}\n\t}\n#endif\n}",
          "includes": [
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [
            "#define PREFIX if(appshare_debug) fprintf(stderr, \"  %8.2f  0x%08lx : \", dnow() - start, ev.xany.window);"
          ],
          "globals_used": [
            "extern char *get_xprop(char *prop, Window win);",
            "extern double dnow(void);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"x11vnc.h\"\n\n#define PREFIX if(appshare_debug) fprintf(stderr, \"  %8.2f  0x%08lx : \", dnow() - start, ev.xany.window);\n\nextern char *get_xprop(char *prop, Window win);\nextern double dnow(void);\n\nstatic void monitor(void) {\n#if !NO_X11\n\tXEvent ev;\n\tdouble start = dnow();\n\tint got_prop_cmd = 0;\n\n\tif (shell) {\n\t\tupdate();\n\t\tfprintf(stderr, \"\\n\\n\");\n\t\tprocess_string(\"cmd=help\");\n\t\tfprintf(stderr, \"\\n%s\", prompt); ff();\n\t}\n\n\twhile (1) {\n\t\tint t;\n\n\t\tif (XEventsQueued(dpy, QueuedAlready) == 0) {\n\t\t\tupdate();\n\t\t\tif (got_prop_cmd) {\n\t\t\t\thandle_prop_cmd();\n\t\t\t}\n\t\t\tgot_prop_cmd = 0;\n\t\t\tif (shell) {\n\t\t\t\thandle_shell();\n\t\t\t}\n\t\t}\n\n\t\tXNextEvent(dpy, &ev);\n\n\t\tlast_event_type = ev.type;\n\n\t\tswitch (ev.type) {\n\t\tcase Expose:\n\t\t\tPREFIX\n\t\t\tif(appshare_debug) fprintf(stderr, \"Expose %04dx%04d+%04d+%04d\\n\", ev.xexpose.width, ev.xexpose.height, ev.xexpose.x, ev.xexpose.y);\n\t\t\tbreak;\n\t\tcase ConfigureNotify:\n#if 0\n\t\t\tPREFIX\n\t\t\tif(appshare_debug) fprintf(stderr, \"ConfigureNotify %04dx%04d+%04d+%04d  above: 0x%lx\\n\", ev.xconfigure.width, ev.xconfigure.height, ev.xconfigure.x, ev.xconfigure.y, ev.xconfigure.above);\n#endif\n\t\t\tbreak;\n\t\tcase VisibilityNotify:\n\t\t\tPREFIX\n\t\t\tif (appshare_debug) {\n\t\t\tfprintf(stderr, \"VisibilityNotify: \");\n\t\t\tt = ev.xvisibility.state;\n\t\t\tif (t == VisibilityFullyObscured)     fprintf(stderr, \"VisibilityFullyObscured\\n\");\n\t\t\tif (t == VisibilityPartiallyObscured) fprintf(stderr, \"VisibilityPartiallyObscured\\n\");\n\t\t\tif (t == VisibilityUnobscured)        fprintf(stderr, \"VisibilityUnobscured\\n\");\n\t\t\t}\n\t\t\tbreak;\n\t\tcase MapNotify:\n\t\t\tPREFIX\n\t\t\tif(appshare_debug) fprintf(stderr, \"MapNotify      win: 0x%lx\\n\", ev.xmap.window);\n\t\t\tif (ours(ev.xmap.window)) {\n\t\t\t\tmapped(ev.xmap.window);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase UnmapNotify:\n\t\t\tPREFIX\n\t\t\tif(appshare_debug) fprintf(stderr, \"UnmapNotify    win: 0x%lx\\n\", ev.xmap.window);\n\t\t\tif (ours(ev.xmap.window)) {\n\t\t\t\tunmapped(ev.xmap.window);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase MapRequest:\n\t\t\tPREFIX\n\t\t\tif(appshare_debug) fprintf(stderr, \"MapRequest\\n\");\n\t\t\tbreak;\n\t\tcase CreateNotify:\n\t\t\tPREFIX\n\t\t\tif(appshare_debug) fprintf(stderr, \"CreateNotify parent: 0x%lx  win: 0x%lx\\n\", ev.xcreatewindow.parent, ev.xcreatewindow.window);\n\t\t\tif (ev.xcreatewindow.parent == root && ours(ev.xcreatewindow.window)) {\n\t\t\t\tif (find_win(ev.xcreatewindow.window) >= 0) {\n\t\t\t\t\tdestroy_win(ev.xcreatewindow.window);\n\t\t\t\t}\n\t\t\t\tadd_win(ev.xcreatewindow.window);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase DestroyNotify:\n\t\t\tPREFIX\n\t\t\tif(appshare_debug) fprintf(stderr, \"DestroyNotify  win: 0x%lx\\n\", ev.xdestroywindow.window);\n\t\t\tif (ours(ev.xdestroywindow.window)) {\n\t\t\t\tdestroy_win(ev.xdestroywindow.window);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase ConfigureRequest:\n\t\t\tPREFIX\n\t\t\tif(appshare_debug) fprintf(stderr, \"ConfigureRequest\\n\");\n\t\t\tbreak;\n\t\tcase CirculateRequest:\n#if 0\n\t\t\tPREFIX\n\t\t\tif(appshare_debug) fprintf(stderr, \"CirculateRequest parent: 0x%lx  win: 0x%lx\\n\", ev.xcirculaterequest.parent, ev.xcirculaterequest.window);\n#endif\n\t\t\tbreak;\n\t\tcase CirculateNotify:\n#if 0\n\t\t\tPREFIX\n\t\t\tif(appshare_debug) fprintf(stderr, \"CirculateNotify\\n\");\n#endif\n\t\t\tbreak;\n\t\tcase PropertyNotify:\n#if 0\n\t\t\tPREFIX\n\t\t\tif(appshare_debug) fprintf(stderr, \"PropertyNotify\\n\");\n#endif\n\t\t\tif (cmd_atom != None && ev.xproperty.atom == cmd_atom) {\n\t\t\t\tgot_prop_cmd++;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase ReparentNotify:\n\t\t\tPREFIX\n\t\t\tif(appshare_debug) fprintf(stderr, \"ReparentNotify parent: 0x%lx  win: 0x%lx\\n\", ev.xreparent.parent, ev.xreparent.window);\n\t\t\tif (ours(ev.xreparent.window)) {\n\t\t\t\tif (ours(ev.xreparent.parent)) {\n\t\t\t\t\tdestroy_win(ev.xreparent.window);\n\t\t\t\t} else if (ev.xreparent.parent == root) {\n\t\t\t\t\t/* ??? */\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tPREFIX\n\t\t\tif(appshare_debug) fprintf(stderr, \"Unknown: %d\\n\", ev.type);\n\t\t\tbreak;\n\t\t}\n\t}\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stdout",
            "\"\\n\""
          ],
          "line": 2115
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stdout",
            "\"Using app win: 0x%08lx  root: 0x%08lx\\n\"",
            "apps[i]",
            "root"
          ],
          "line": 2113
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "\"\""
          ],
          "line": 2106
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "str"
          ],
          "line": 2104
        },
        "resolved": true,
        "details": {
          "function_name": "free_rect",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/userinput.c",
          "lines": "6200-6247",
          "snippet": "int free_rect(int idx) {\n\tint n, ok = 0;\n\tsraRegionPtr r1, r2;\n\tint x, y, w, h;\n\n\tif (idx < 0 || idx >= cache_list_num) {\nif (0) fprintf(stderr, \"free_rect: bad index: %d\\n\", idx);\n\t\tclean_up_exit(1);\n\t}\n\n\tx = cache_list[idx].bs_x;\n\ty = cache_list[idx].bs_y;\n\tw = cache_list[idx].bs_w;\n\th = cache_list[idx].bs_h;\n\n\tif (x < 0) {\n\t\tCLEAR(idx);\nif (dnow() > last_client + 5 && ncdb) fprintf(stderr, \"free_rect: already bs_x invalidated: %d bs_x: %d\\n\", idx, x);\n\t\treturn 1;\n\t}\n\n\tr2 = sraRgnCreateRect(x, y, x+w, y+h);\n\n\tn = get_bs_n(y);\n\tif (n >= 0) {\n\t\tr1 = rect_reg[n];\n\t\tsraRgnOr(r1, r2);\n\t\tok = 1;\n\t}\n\n\tif (zero_rects) {\n\t\tsraRgnOr(zero_rects, r2);\n\t\tx = cache_list[idx].su_x;\n\t\ty = cache_list[idx].su_y;\n\t\tw = cache_list[idx].su_w;\n\t\th = cache_list[idx].su_h;\n\t\tif (x >= 0) {\n\t\t\tsraRgnDestroy(r2);\n\t\t\tr2 = sraRgnCreateRect(x, y, x+w, y+h);\n\t\t\tsraRgnOr(zero_rects, r2);\n\t\t}\n\t}\n\tsraRgnDestroy(r2);\n\n\tCLEAR(idx);\nif (! ok && ncdb) fprintf(stderr, \"**** free_rect: not-found %d\\n\", idx);\n\treturn ok;\n}",
          "includes": [
            "#include \"default8x16.h\"",
            "#include \"connections.h\"",
            "#include \"screen.h\"",
            "#include \"cursor.h\"",
            "#include \"macosxCGS.h\"",
            "#include \"macosx.h\"",
            "#include \"unixpw.h\"",
            "#include \"8to24.h\"",
            "#include \"xrandr.h\"",
            "#include \"solid.h\"",
            "#include \"keyboard.h\"",
            "#include \"rates.h\"",
            "#include \"pointer.h\"",
            "#include \"cleanup.h\"",
            "#include \"scan.h\"",
            "#include \"user.h\"",
            "#include \"xevents.h\"",
            "#include \"win_utils.h\"",
            "#include \"xinerama.h\"",
            "#include \"xrecord.h\"",
            "#include \"xdamage.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void mark_for_xdamage(int x, int y, int w, int h);",
            "void set_xdamage_mark(int x, int y, int w, int h);",
            "int find_rect(int idx, int x, int y, int w, int h);",
            "winattr_t *cache_list;",
            "int clipped(int idx);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"default8x16.h\"\n#include \"connections.h\"\n#include \"screen.h\"\n#include \"cursor.h\"\n#include \"macosxCGS.h\"\n#include \"macosx.h\"\n#include \"unixpw.h\"\n#include \"8to24.h\"\n#include \"xrandr.h\"\n#include \"solid.h\"\n#include \"keyboard.h\"\n#include \"rates.h\"\n#include \"pointer.h\"\n#include \"cleanup.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"xevents.h\"\n#include \"win_utils.h\"\n#include \"xinerama.h\"\n#include \"xrecord.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nvoid mark_for_xdamage(int x, int y, int w, int h);\nvoid set_xdamage_mark(int x, int y, int w, int h);\nint find_rect(int idx, int x, int y, int w, int h);\nwinattr_t *cache_list;\nint clipped(int idx);\n\nint free_rect(int idx) {\n\tint n, ok = 0;\n\tsraRegionPtr r1, r2;\n\tint x, y, w, h;\n\n\tif (idx < 0 || idx >= cache_list_num) {\nif (0) fprintf(stderr, \"free_rect: bad index: %d\\n\", idx);\n\t\tclean_up_exit(1);\n\t}\n\n\tx = cache_list[idx].bs_x;\n\ty = cache_list[idx].bs_y;\n\tw = cache_list[idx].bs_w;\n\th = cache_list[idx].bs_h;\n\n\tif (x < 0) {\n\t\tCLEAR(idx);\nif (dnow() > last_client + 5 && ncdb) fprintf(stderr, \"free_rect: already bs_x invalidated: %d bs_x: %d\\n\", idx, x);\n\t\treturn 1;\n\t}\n\n\tr2 = sraRgnCreateRect(x, y, x+w, y+h);\n\n\tn = get_bs_n(y);\n\tif (n >= 0) {\n\t\tr1 = rect_reg[n];\n\t\tsraRgnOr(r1, r2);\n\t\tok = 1;\n\t}\n\n\tif (zero_rects) {\n\t\tsraRgnOr(zero_rects, r2);\n\t\tx = cache_list[idx].su_x;\n\t\ty = cache_list[idx].su_y;\n\t\tw = cache_list[idx].su_w;\n\t\th = cache_list[idx].su_h;\n\t\tif (x >= 0) {\n\t\t\tsraRgnDestroy(r2);\n\t\t\tr2 = sraRgnCreateRect(x, y, x+w, y+h);\n\t\t\tsraRgnOr(zero_rects, r2);\n\t\t}\n\t}\n\tsraRgnDestroy(r2);\n\n\tCLEAR(idx);\nif (! ok && ncdb) fprintf(stderr, \"**** free_rect: not-found %d\\n\", idx);\n\treturn ok;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strtok",
          "args": [
            "NULL",
            "\",\""
          ],
          "line": 2102
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "p"
          ],
          "line": 2101
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strtok",
          "args": [
            "str",
            "\",\""
          ],
          "line": 2099
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "connect_to"
          ],
          "line": 2097
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLogEnable",
          "args": [
            "0"
          ],
          "line": 2094
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "signal",
          "args": [
            "SIGTERM",
            "appshare_cleanup"
          ],
          "line": 2092
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "signal",
          "args": [
            "SIGINT",
            "appshare_cleanup"
          ],
          "line": 2091
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_trackdir",
          "args": [],
          "line": 2089
        },
        "resolved": true,
        "details": {
          "function_name": "set_trackdir",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/appshare.c",
          "lines": "1622-1654",
          "snippet": "static void set_trackdir(void) {\n\tchar tmp[256];\n\tstruct stat sb;\n\tif (!strcmp(trackdir, \"none\")) {\n\t\ttrackdir = NULL;\n\t\treturn;\n\t}\n\tif (!strcmp(trackdir, \"unset\")) {\n\t\tint fd;\n\t\tsprintf(tmp, \"%s.XXXXXX\", trackpre);\n\t\tfd = mkstemp(tmp);\n\t\tif (fd < 0) {\n\t\t\tstrcat(tmp, \": failed to create file.\\n\");\n\t\t\texiter(tmp, 1);\n\t\t}\n\t\t/* XXX race */\n\t\tclose(fd);\n\t\tunlink(tmp);\n\t\tif (mkdir(tmp, 0700) != 0) {\n\t\t\tstrcat(tmp, \": failed to create dir.\\n\");\n\t\t\texiter(tmp, 1);\n\t\t}\n\t\ttrackdir = strdup(tmp);\n\t}\n\tif (stat(trackdir, &sb) != 0) {\n\t\tif (mkdir(trackdir, 0700) != 0) {\n\t\t\texiter(\"could not make trackdir.\\n\", 1);\n\t\t}\n\t} else if (! S_ISDIR(sb.st_mode)) {\n\t\texiter(\"trackdir not a directory.\\n\", 1);\n\t}\n\ttracktmp = (char *) calloc(1000 + strlen(trackdir), 1);\n}",
          "includes": [
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"x11vnc.h\"\n\nstatic void set_trackdir(void) {\n\tchar tmp[256];\n\tstruct stat sb;\n\tif (!strcmp(trackdir, \"none\")) {\n\t\ttrackdir = NULL;\n\t\treturn;\n\t}\n\tif (!strcmp(trackdir, \"unset\")) {\n\t\tint fd;\n\t\tsprintf(tmp, \"%s.XXXXXX\", trackpre);\n\t\tfd = mkstemp(tmp);\n\t\tif (fd < 0) {\n\t\t\tstrcat(tmp, \": failed to create file.\\n\");\n\t\t\texiter(tmp, 1);\n\t\t}\n\t\t/* XXX race */\n\t\tclose(fd);\n\t\tunlink(tmp);\n\t\tif (mkdir(tmp, 0700) != 0) {\n\t\t\tstrcat(tmp, \": failed to create dir.\\n\");\n\t\t\texiter(tmp, 1);\n\t\t}\n\t\ttrackdir = strdup(tmp);\n\t}\n\tif (stat(trackdir, &sb) != 0) {\n\t\tif (mkdir(trackdir, 0700) != 0) {\n\t\t\texiter(\"could not make trackdir.\\n\", 1);\n\t\t}\n\t} else if (! S_ISDIR(sb.st_mode)) {\n\t\texiter(\"trackdir not a directory.\\n\", 1);\n\t}\n\ttracktmp = (char *) calloc(1000 + strlen(trackdir), 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "add_app",
          "args": [
            "app"
          ],
          "line": 2083
        },
        "resolved": true,
        "details": {
          "function_name": "add_app",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/appshare.c",
          "lines": "943-973",
          "snippet": "static void add_app(Window app) {\n\tint i, nw = 0, free = -1;\n        XErrorHandler old_handler;\n\n#if !NO_X11\n\ti = find_app(app);\n\tif (i >= 0) {\n\t\tfprintf(stderr, \"already tracking app: 0x%lx\\n\", app);\n\t\treturn;\n\t}\n\tfor (i=0; i < AMAX; i++) {\n\t\tif (same_app(apps[i], app)) {\n\t\t\tfprintf(stderr, \"already tracking app: 0x%lx via 0x%lx\\n\", app, apps[i]);\n\t\t\treturn;\n\t\t}\n\t}\n\tfree = find_app(None);\n\tif (free < 0) {\n\t\tfprintf(stderr, \"ran out of app slots.\\n\");\n\t\treturn;\n\t}\n\tapps[free] = app;\n\n\tadd_win(app);\n\n        old_handler = XSetErrorHandler(trap_xerror);\n\trecurse_search(0, tree_depth, root, app, &nw);\n       \tXSetErrorHandler(old_handler);\n#endif\n\tfprintf(stderr, \"tracking %d windows related to app window 0x%lx\\n\", nw, app);\n}",
          "includes": [
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [
            "#define AMAX 32"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"x11vnc.h\"\n\n#define AMAX 32\n\nstatic void add_app(Window app) {\n\tint i, nw = 0, free = -1;\n        XErrorHandler old_handler;\n\n#if !NO_X11\n\ti = find_app(app);\n\tif (i >= 0) {\n\t\tfprintf(stderr, \"already tracking app: 0x%lx\\n\", app);\n\t\treturn;\n\t}\n\tfor (i=0; i < AMAX; i++) {\n\t\tif (same_app(apps[i], app)) {\n\t\t\tfprintf(stderr, \"already tracking app: 0x%lx via 0x%lx\\n\", app, apps[i]);\n\t\t\treturn;\n\t\t}\n\t}\n\tfree = find_app(None);\n\tif (free < 0) {\n\t\tfprintf(stderr, \"ran out of app slots.\\n\");\n\t\treturn;\n\t}\n\tapps[free] = app;\n\n\tadd_win(app);\n\n        old_handler = XSetErrorHandler(trap_xerror);\n\trecurse_search(0, tree_depth, root, app, &nw);\n       \tXSetErrorHandler(old_handler);\n#endif\n\tfprintf(stderr, \"tracking %d windows related to app window 0x%lx\\n\", nw, app);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ours",
          "args": [
            "app"
          ],
          "line": 2082
        },
        "resolved": true,
        "details": {
          "function_name": "ours",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/appshare.c",
          "lines": "1301-1311",
          "snippet": "static int ours(Window win) {\n\tint i;\n\tfor (i=0; i < AMAX; i++) {\n\t\tif (apps[i] != None) {\n\t\t\tif (same_app(win, apps[i])) {\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [
            "#define AMAX 32"
          ],
          "globals_used": [
            "extern char *get_xprop(char *prop, Window win);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"x11vnc.h\"\n\n#define AMAX 32\n\nextern char *get_xprop(char *prop, Window win);\n\nstatic int ours(Window win) {\n\tint i;\n\tfor (i=0; i < AMAX; i++) {\n\t\tif (apps[i] != None) {\n\t\t\tif (same_app(win, apps[i])) {\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "parse_win",
          "args": [
            "p"
          ],
          "line": 2078
        },
        "resolved": true,
        "details": {
          "function_name": "parse_win",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/appshare.c",
          "lines": "1108-1135",
          "snippet": "static Window parse_win(char *str) {\n\tWindow win = None;\n\tif (!str) {\n\t\treturn None;\n\t}\n\tif (!strcmp(str, \"pick\") || !strcmp(str, \"p\")) {\n\t\tstatic double last_pick = 0.0;\n\t\tif (dnow() < start_time + 15) {\n\t\t\t;\n\t\t} else if (dnow() < last_pick + 2) {\n\t\t\treturn None;\n\t\t} else {\n\t\t\tlast_pick = dnow();\n\t\t}\n\t\tif (!pick_windowid(&win)) {\n\t\t\tfprintf(stderr, \"parse_win: bad window pick.\\n\");\n\t\t\twin = None;\n\t\t}\n\t\tif (win == root) {\n\t\t\tfprintf(stderr, \"parse_win: ignoring pick of rootwin 0x%lx.\\n\", win);\n\t\t\twin = None;\n\t\t}\n\t\tff();\n\t} else if (!scan_hexdec(str, &win)) {\n\t\twin = None;\n\t}\n\treturn win;\n}",
          "includes": [
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "extern char *get_xprop(char *prop, Window win);",
            "extern double dnow(void);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"x11vnc.h\"\n\nextern char *get_xprop(char *prop, Window win);\nextern double dnow(void);\n\nstatic Window parse_win(char *str) {\n\tWindow win = None;\n\tif (!str) {\n\t\treturn None;\n\t}\n\tif (!strcmp(str, \"pick\") || !strcmp(str, \"p\")) {\n\t\tstatic double last_pick = 0.0;\n\t\tif (dnow() < start_time + 15) {\n\t\t\t;\n\t\t} else if (dnow() < last_pick + 2) {\n\t\t\treturn None;\n\t\t} else {\n\t\t\tlast_pick = dnow();\n\t\t}\n\t\tif (!pick_windowid(&win)) {\n\t\t\tfprintf(stderr, \"parse_win: bad window pick.\\n\");\n\t\t\twin = None;\n\t\t}\n\t\tif (win == root) {\n\t\t\tfprintf(stderr, \"parse_win: ignoring pick of rootwin 0x%lx.\\n\", win);\n\t\t\twin = None;\n\t\t}\n\t\tff();\n\t} else if (!scan_hexdec(str, &win)) {\n\t\twin = None;\n\t}\n\treturn win;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strtok",
          "args": [
            "NULL",
            "\",\""
          ],
          "line": 2071
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "p"
          ],
          "line": 2070
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "exiter",
          "args": [
            "\"\"",
            "1"
          ],
          "line": 2068
        },
        "resolved": true,
        "details": {
          "function_name": "exiter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/appshare.c",
          "lines": "1615-1620",
          "snippet": "static void exiter(char *msg, int rc) {\n\tfprintf(stderr, \"%s\", msg);\n\tff();\n\tkill_helper_pid();\n\texit(rc);\n}",
          "includes": [
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"x11vnc.h\"\n\nstatic void exiter(char *msg, int rc) {\n\tfprintf(stderr, \"%s\", msg);\n\tff();\n\tkill_helper_pid();\n\texit(rc);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"ran out of app slots: %s\\n\"",
            "app_str"
          ],
          "line": 2067
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strtok",
          "args": [
            "str",
            "\",\""
          ],
          "line": 2064
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "app_str"
          ],
          "line": 2060
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dnow",
          "args": [],
          "line": 2055
        },
        "resolved": true,
        "details": {
          "function_name": "dnowx",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/util.c",
          "lines": "439-441",
          "snippet": "double dnowx(void) {\n\treturn dnow() - x11vnc_start;\n}",
          "includes": [
            "#include \"connections.h\"",
            "#include \"unixpw.h\"",
            "#include \"win_utils.h\"",
            "#include \"cleanup.h\"",
            "#include \"x11vnc.h\"",
            "#include <stdlib.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "double dnow(void);",
            "double dnowx(void);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"connections.h\"\n#include \"unixpw.h\"\n#include \"win_utils.h\"\n#include \"cleanup.h\"\n#include \"x11vnc.h\"\n#include <stdlib.h>\n\ndouble dnow(void);\ndouble dnowx(void);\n\ndouble dnowx(void) {\n\treturn dnow() - x11vnc_start;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "unique_tag",
            "\"X11VNC_APPSHARE_TAG=%d-tag\"",
            "getpid()"
          ],
          "line": 2053
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getpid",
          "args": [],
          "line": 2053
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "init_cmask",
          "args": [],
          "line": 2051
        },
        "resolved": true,
        "details": {
          "function_name": "init_cmask",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/appshare.c",
          "lines": "1270-1291",
          "snippet": "static void init_cmask(void) {\n\t/* dependent on the X server implementation; XmuClientWindow better? */\n\t/* xc/programs/Xserver/include/resource.h */\n\tint didit = 0, res_cnt = 29, client_bits = 8;\n\n\tif (getenv(\"X11VNC_APPSHARE_CLIENT_MASK\")) {\n\t\tunsigned long cr;\n\t\tif (sscanf(getenv(\"X11VNC_APPSHARE_CLIENT_MASK\"), \"0x%lx\", &cr) == 1) {\n\t\t\tcmask = cr;\n\t\t\tdidit = 1;\n\t\t}\n\t} else if (getenv(\"X11VNC_APPSHARE_CLIENT_BITS\")) {\n\t\tint cr = atoi(getenv(\"X11VNC_APPSHARE_CLIENT_BITS\"));\n\t\tif (cr > 0) {\n\t\t\tclient_bits = cr;\n\t\t}\n\t}\n\tif (!didit) {\n\t\tcmask = (((1 << client_bits) - 1) << (res_cnt-client_bits));\n\t}\n\tfprintf(stderr, \"client_mask: 0x%08lx\\n\", cmask);\n}",
          "includes": [
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"x11vnc.h\"\n\nstatic void init_cmask(void) {\n\t/* dependent on the X server implementation; XmuClientWindow better? */\n\t/* xc/programs/Xserver/include/resource.h */\n\tint didit = 0, res_cnt = 29, client_bits = 8;\n\n\tif (getenv(\"X11VNC_APPSHARE_CLIENT_MASK\")) {\n\t\tunsigned long cr;\n\t\tif (sscanf(getenv(\"X11VNC_APPSHARE_CLIENT_MASK\"), \"0x%lx\", &cr) == 1) {\n\t\t\tcmask = cr;\n\t\t\tdidit = 1;\n\t\t}\n\t} else if (getenv(\"X11VNC_APPSHARE_CLIENT_BITS\")) {\n\t\tint cr = atoi(getenv(\"X11VNC_APPSHARE_CLIENT_BITS\"));\n\t\tif (cr > 0) {\n\t\t\tclient_bits = cr;\n\t\t}\n\t}\n\tif (!didit) {\n\t\tcmask = (((1 << client_bits) - 1) << (res_cnt-client_bits));\n\t}\n\tfprintf(stderr, \"client_mask: 0x%08lx\\n\", cmask);\n}"
        }
      },
      {
        "call_info": {
          "callee": "XInternAtom",
          "args": [
            "dpy",
            "cmd_atom_str",
            "False"
          ],
          "line": 2049
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XSelectInput",
          "args": [
            "dpy",
            "root",
            "xselectinput"
          ],
          "line": 2047
        },
        "resolved": true,
        "details": {
          "function_name": "XSelectInput_wr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/xwrappers.c",
          "lines": "1678-1697",
          "snippet": "int XSelectInput_wr(Display *display, Window w, long event_mask) {\n#if NO_X11\n\tif (!display || !w || !event_mask) {}\n\treturn 0;\n#else\n\tint rc;\n\tXErrorHandler old_handler;\n\tif (display == NULL || w == None) {\n\t\treturn 0;\n\t}\n\told_handler = XSetErrorHandler(trap_xerror);\n\ttrapped_xerror = 0;\n\trc = XSelectInput(display, w, event_mask);\n\tXSetErrorHandler(old_handler);\n\tif (trapped_xerror) {\n\t\trc = 0;\n\t}\n\treturn rc;\n#endif\n}",
          "includes": [
            "#include \"nox11_funcs.h\"",
            "#include \"xwrappers.h\"",
            "#include \"xi2_devices.h\"",
            "#include \"macosx.h\"",
            "#include \"cleanup.h\"",
            "#include \"connections.h\"",
            "#include \"xevents.h\"",
            "#include \"keyboard.h\"",
            "#include \"xrecord.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "Bool XTestCompareCurrentCursorWithWindow_wr(Display* dpy, Window w);",
            "int XCloseDisplay_wr(Display *display);",
            "int XSelectInput_wr(Display *display, Window w, long event_mask);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"nox11_funcs.h\"\n#include \"xwrappers.h\"\n#include \"xi2_devices.h\"\n#include \"macosx.h\"\n#include \"cleanup.h\"\n#include \"connections.h\"\n#include \"xevents.h\"\n#include \"keyboard.h\"\n#include \"xrecord.h\"\n#include \"x11vnc.h\"\n\nBool XTestCompareCurrentCursorWithWindow_wr(Display* dpy, Window w);\nint XCloseDisplay_wr(Display *display);\nint XSelectInput_wr(Display *display, Window w, long event_mask);\n\nint XSelectInput_wr(Display *display, Window w, long event_mask) {\n#if NO_X11\n\tif (!display || !w || !event_mask) {}\n\treturn 0;\n#else\n\tint rc;\n\tXErrorHandler old_handler;\n\tif (display == NULL || w == None) {\n\t\treturn 0;\n\t}\n\told_handler = XSetErrorHandler(trap_xerror);\n\ttrapped_xerror = 0;\n\trc = XSelectInput(display, w, event_mask);\n\tXSetErrorHandler(old_handler);\n\tif (trapped_xerror) {\n\t\trc = 0;\n\t}\n\treturn rc;\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "XInternAtom",
          "args": [
            "dpy",
            "ticker_atom_str",
            "False"
          ],
          "line": 2044
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DefaultRootWindow",
          "args": [
            "dpy"
          ],
          "line": 2040
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XOpenDisplay",
          "args": [
            "dpy_str"
          ],
          "line": 2035
        },
        "resolved": true,
        "details": {
          "function_name": "XOpenDisplay_wr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/xwrappers.c",
          "lines": "1461-1502",
          "snippet": "Display *XOpenDisplay_wr(char *display_name) {\n\tDisplay *d = NULL;\n\tint db = 0;\n\n\tif (! xauth_raw(1)) {\n\t\treturn NULL;\n\t}\n#if NO_X11\n\trfbLog(\"This x11vnc was built without X11 support (-rawfb only).\\n\");\n\tif (!display_name || !d || !db) {}\n\treturn NULL;\n#else\n\n\td = XOpenDisplay(display_name);\n\tif (db) fprintf(stderr, \"XOpenDisplay_wr: %s  %p\\n\", display_name, (void *)d);\n\n\tif (d == NULL && !getenv(\"NO_XAUTHLOCALHOSTNAME\")) {\n\t\tchar *xalhn = getenv(\"XAUTHLOCALHOSTNAME\");\n\t\tif (1 || !xalhn) {\n\t\t\trfbLog(\"XOpenDisplay(\\\"%s\\\") failed.\\n\",\n\t\t\t    display_name ? display_name : \"\");\n\t\t\trfbLog(\"Trying again with XAUTHLOCALHOSTNAME=localhost ...\\n\");\n\t\t\tset_env(\"XAUTHLOCALHOSTNAME\", \"localhost\");\n\t\t\td = XOpenDisplay(display_name);\n\t\t\tif (d == NULL && xalhn) {\n\t\t\t\tchar *ptr = getenv(\"XAUTHLOCALHOSTNAME\");\n\t\t\t\tif (ptr) {\n\t\t\t\t\t*(ptr-2) = '_';\t/* yow */\n\t\t\t\t\trfbLog(\"XOpenDisplay(\\\"%s\\\") failed.\\n\",\n\t\t\t\t\t    display_name ? display_name : \"\");\n\t\t\t\t\trfbLog(\"Trying again with unset XAUTHLOCALHOSTNAME ...\\n\");\n\t\t\t\t\td = XOpenDisplay(display_name);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\txauth_raw(0);\n\n\treturn d;\n#endif\t/* NO_X11 */\n}",
          "includes": [
            "#include \"nox11_funcs.h\"",
            "#include \"xwrappers.h\"",
            "#include \"xi2_devices.h\"",
            "#include \"macosx.h\"",
            "#include \"cleanup.h\"",
            "#include \"connections.h\"",
            "#include \"xevents.h\"",
            "#include \"keyboard.h\"",
            "#include \"xrecord.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "Display *XOpenDisplay_wr(char *display_name);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"nox11_funcs.h\"\n#include \"xwrappers.h\"\n#include \"xi2_devices.h\"\n#include \"macosx.h\"\n#include \"cleanup.h\"\n#include \"connections.h\"\n#include \"xevents.h\"\n#include \"keyboard.h\"\n#include \"xrecord.h\"\n#include \"x11vnc.h\"\n\nDisplay *XOpenDisplay_wr(char *display_name);\n\nDisplay *XOpenDisplay_wr(char *display_name) {\n\tDisplay *d = NULL;\n\tint db = 0;\n\n\tif (! xauth_raw(1)) {\n\t\treturn NULL;\n\t}\n#if NO_X11\n\trfbLog(\"This x11vnc was built without X11 support (-rawfb only).\\n\");\n\tif (!display_name || !d || !db) {}\n\treturn NULL;\n#else\n\n\td = XOpenDisplay(display_name);\n\tif (db) fprintf(stderr, \"XOpenDisplay_wr: %s  %p\\n\", display_name, (void *)d);\n\n\tif (d == NULL && !getenv(\"NO_XAUTHLOCALHOSTNAME\")) {\n\t\tchar *xalhn = getenv(\"XAUTHLOCALHOSTNAME\");\n\t\tif (1 || !xalhn) {\n\t\t\trfbLog(\"XOpenDisplay(\\\"%s\\\") failed.\\n\",\n\t\t\t    display_name ? display_name : \"\");\n\t\t\trfbLog(\"Trying again with XAUTHLOCALHOSTNAME=localhost ...\\n\");\n\t\t\tset_env(\"XAUTHLOCALHOSTNAME\", \"localhost\");\n\t\t\td = XOpenDisplay(display_name);\n\t\t\tif (d == NULL && xalhn) {\n\t\t\t\tchar *ptr = getenv(\"XAUTHLOCALHOSTNAME\");\n\t\t\t\tif (ptr) {\n\t\t\t\t\t*(ptr-2) = '_';\t/* yow */\n\t\t\t\t\trfbLog(\"XOpenDisplay(\\\"%s\\\") failed.\\n\",\n\t\t\t\t\t    display_name ? display_name : \"\");\n\t\t\t\t\trfbLog(\"Trying again with unset XAUTHLOCALHOSTNAME ...\\n\");\n\t\t\t\t\td = XOpenDisplay(display_name);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\txauth_raw(0);\n\n\treturn d;\n#endif\t/* NO_X11 */\n}"
        }
      },
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "0"
          ],
          "line": 2029
        },
        "resolved": true,
        "details": {
          "function_name": "clean_up_exit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/cleanup.c",
          "lines": "151-266",
          "snippet": "void clean_up_exit(int ret) {\n\tstatic int depth = 0;\n\texit_flag = 1;\n\n\tif (depth++ > 2) {\n\t\texit(ret);\n\t}\n\n\tif (icon_mode) {\n\t\tclean_icon_mode();\n\t}\n\n\t/* remove the shm areas: */\n\tclean_shm(0);\n\n\tstop_stunnel();\n\tif (use_openssl) {\n\t\tssl_helper_pid(0, 0);\t/* killall */\n\t}\n\n\tif (ssh_pid > 0) {\n\t\tkill(ssh_pid, SIGTERM);\n\t\tssh_pid = 0;\n\t}\n\n#ifdef MACOSX\n\tif (client_connect_file) {\n\t\tif (strstr(client_connect_file, \"/tmp/x11vnc-macosx-remote\")\n\t\t    == client_connect_file) {\n\t\t\tunlink(client_connect_file);\n\t\t}\n\t}\n\tif (macosx_console) {\n\t\tmacosxCG_fini();\n\t}\n#endif\n\n\tif (pipeinput_fh != NULL) {\n\t\tpclose(pipeinput_fh);\n\t\tpipeinput_fh = NULL;\n\t}\n\n\tshutdown_uinput();\n\n\tif (unix_sock) {\n\t\tif (unix_sock_fd >= 0) {\n\t\t\trfbLog(\"deleting unix sock: %s\\n\", unix_sock);\n\t\t\tclose(unix_sock_fd);\n\t\t\tunix_sock_fd = -1;\n\t\t\tunlink(unix_sock);\n\t\t}\n\t}\n\n\tif (! dpy) {\t/* raw_rb hack */\n\t\tif (rm_flagfile) {\n\t\t\tunlink(rm_flagfile);\n\t\t\trm_flagfile = NULL;\n\t\t}\n\t\texit(ret);\n\t}\n\n\t/* X keyboard cleanups */\n\tdelete_added_keycodes(0);\n\n\t/* remove all created XInput2 devices */\n\tif(use_multipointer)\n\t    removeAllMDs(dpy);\n\n\tif (clear_mods == 1) {\n\t\tclear_modifiers(0);\n\t} else if (clear_mods == 2) {\n\t\tclear_keys();\n\t} else if (clear_mods == 3) {\n\t\tclear_keys();\n\t\tclear_locks();\n\t}\n\n\tif (no_autorepeat) {\n\t\tautorepeat(1, 0);\n\t}\n\tif (use_solid_bg) {\n\t\tsolid_bg(1);\n\t}\n\tif (ncache || ncache0) {\n\t\tkde_no_animate(1);\n\t}\n\tX_LOCK;\n\tXTestDiscard_wr(dpy);\n#if HAVE_LIBXDAMAGE\n\tif (xdamage) {\n\t\tXDamageDestroy(dpy, xdamage);\n\t}\n#endif\n#if HAVE_LIBXTRAP\n\tif (trap_ctx) {\n\t\tXEFreeTC(trap_ctx);\n\t}\n#endif\n\t/* XXX rdpy_ctrl, etc. cannot close w/o blocking */\n\tXCloseDisplay_wr(dpy);\n\tX_UNLOCK;\n\n\tfflush(stderr);\n\n\tif (rm_flagfile) {\n\t\tunlink(rm_flagfile);\n\t\trm_flagfile = NULL;\n\t}\n\n\tif (avahi) {\n\t\tavahi_cleanup();\n\t\tfflush(stderr);\n\t}\n\n\texit(ret);\n}",
          "includes": [
            "#include \"xi2_devices.h\"",
            "#include \"uinput.h\"",
            "#include \"xevents.h\"",
            "#include \"xrecord.h\"",
            "#include \"screen.h\"",
            "#include \"avahi.h\"",
            "#include \"macosxCG.h\"",
            "#include \"macosx.h\"",
            "#include \"connections.h\"",
            "#include \"sslhelper.h\"",
            "#include \"sslcmds.h\"",
            "#include \"unixpw.h\"",
            "#include \"solid.h\"",
            "#include \"gui.h\"",
            "#include \"scan.h\"",
            "#include \"keyboard.h\"",
            "#include \"remote.h\"",
            "#include \"xdamage.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void clean_up_exit(int ret);",
            "int known_sigpipe_mode(char *s);",
            "static int exit_flag = 0;",
            "static void clean_icon_mode(void);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xi2_devices.h\"\n#include \"uinput.h\"\n#include \"xevents.h\"\n#include \"xrecord.h\"\n#include \"screen.h\"\n#include \"avahi.h\"\n#include \"macosxCG.h\"\n#include \"macosx.h\"\n#include \"connections.h\"\n#include \"sslhelper.h\"\n#include \"sslcmds.h\"\n#include \"unixpw.h\"\n#include \"solid.h\"\n#include \"gui.h\"\n#include \"scan.h\"\n#include \"keyboard.h\"\n#include \"remote.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nvoid clean_up_exit(int ret);\nint known_sigpipe_mode(char *s);\nstatic int exit_flag = 0;\nstatic void clean_icon_mode(void);\n\nvoid clean_up_exit(int ret) {\n\tstatic int depth = 0;\n\texit_flag = 1;\n\n\tif (depth++ > 2) {\n\t\texit(ret);\n\t}\n\n\tif (icon_mode) {\n\t\tclean_icon_mode();\n\t}\n\n\t/* remove the shm areas: */\n\tclean_shm(0);\n\n\tstop_stunnel();\n\tif (use_openssl) {\n\t\tssl_helper_pid(0, 0);\t/* killall */\n\t}\n\n\tif (ssh_pid > 0) {\n\t\tkill(ssh_pid, SIGTERM);\n\t\tssh_pid = 0;\n\t}\n\n#ifdef MACOSX\n\tif (client_connect_file) {\n\t\tif (strstr(client_connect_file, \"/tmp/x11vnc-macosx-remote\")\n\t\t    == client_connect_file) {\n\t\t\tunlink(client_connect_file);\n\t\t}\n\t}\n\tif (macosx_console) {\n\t\tmacosxCG_fini();\n\t}\n#endif\n\n\tif (pipeinput_fh != NULL) {\n\t\tpclose(pipeinput_fh);\n\t\tpipeinput_fh = NULL;\n\t}\n\n\tshutdown_uinput();\n\n\tif (unix_sock) {\n\t\tif (unix_sock_fd >= 0) {\n\t\t\trfbLog(\"deleting unix sock: %s\\n\", unix_sock);\n\t\t\tclose(unix_sock_fd);\n\t\t\tunix_sock_fd = -1;\n\t\t\tunlink(unix_sock);\n\t\t}\n\t}\n\n\tif (! dpy) {\t/* raw_rb hack */\n\t\tif (rm_flagfile) {\n\t\t\tunlink(rm_flagfile);\n\t\t\trm_flagfile = NULL;\n\t\t}\n\t\texit(ret);\n\t}\n\n\t/* X keyboard cleanups */\n\tdelete_added_keycodes(0);\n\n\t/* remove all created XInput2 devices */\n\tif(use_multipointer)\n\t    removeAllMDs(dpy);\n\n\tif (clear_mods == 1) {\n\t\tclear_modifiers(0);\n\t} else if (clear_mods == 2) {\n\t\tclear_keys();\n\t} else if (clear_mods == 3) {\n\t\tclear_keys();\n\t\tclear_locks();\n\t}\n\n\tif (no_autorepeat) {\n\t\tautorepeat(1, 0);\n\t}\n\tif (use_solid_bg) {\n\t\tsolid_bg(1);\n\t}\n\tif (ncache || ncache0) {\n\t\tkde_no_animate(1);\n\t}\n\tX_LOCK;\n\tXTestDiscard_wr(dpy);\n#if HAVE_LIBXDAMAGE\n\tif (xdamage) {\n\t\tXDamageDestroy(dpy, xdamage);\n\t}\n#endif\n#if HAVE_LIBXTRAP\n\tif (trap_ctx) {\n\t\tXEFreeTC(trap_ctx);\n\t}\n#endif\n\t/* XXX rdpy_ctrl, etc. cannot close w/o blocking */\n\tXCloseDisplay_wr(dpy);\n\tX_UNLOCK;\n\n\tfflush(stderr);\n\n\tif (rm_flagfile) {\n\t\tunlink(rm_flagfile);\n\t\trm_flagfile = NULL;\n\t}\n\n\tif (avahi) {\n\t\tavahi_cleanup();\n\t\tfflush(stderr);\n\t}\n\n\texit(ret);\n}"
        }
      },
      {
        "call_info": {
          "callee": "be_helper_pid",
          "args": [
            "dpy_str"
          ],
          "line": 2028
        },
        "resolved": true,
        "details": {
          "function_name": "be_helper_pid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/appshare.c",
          "lines": "561-593",
          "snippet": "static void be_helper_pid(char *dpy_str) {\n\tint cnt = 0;\n\tint ms = (int) (1000 * helper_delay);\n\tdouble last_check = 0.0;\n\n\tif (ms < 50) ms = 50;\n\n#if NO_X11\n\tfprintf(stderr, \"be_helper_pid: not compiled with X11.\\n\");\n#else\n\tdpy = XOpenDisplay(dpy_str);\n\tticker_atom = XInternAtom(dpy, ticker_atom_str, False);\n\n\twhile (1) {\n\t\tchar tmp[32];\n\t\tsprintf(tmp, \"HELPER_CNT_%08d\", cnt++);\n\t\tXChangeProperty(dpy, DefaultRootWindow(dpy), ticker_atom, XA_STRING, 8,\n\t\t    PropModeReplace, (unsigned char *) tmp, strlen(tmp));\n\t\tXFlush(dpy);\n\t\tusleep(ms*1000);\n\t\tif (parent_pid > 0) {\n\t\t\tif(dnow() > last_check + 1.0) {\n\t\t\t\tlast_check = dnow();\n\t\t\t\tif (kill(parent_pid, 0) != 0) {\n\t\t\t\t\tfprintf(stderr, \"be_helper_pid: parent %d is gone.\\n\", (int) parent_pid);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n#endif\n\texit(0);\n}",
          "includes": [
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "extern double dnow(void);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"x11vnc.h\"\n\nextern double dnow(void);\n\nstatic void be_helper_pid(char *dpy_str) {\n\tint cnt = 0;\n\tint ms = (int) (1000 * helper_delay);\n\tdouble last_check = 0.0;\n\n\tif (ms < 50) ms = 50;\n\n#if NO_X11\n\tfprintf(stderr, \"be_helper_pid: not compiled with X11.\\n\");\n#else\n\tdpy = XOpenDisplay(dpy_str);\n\tticker_atom = XInternAtom(dpy, ticker_atom_str, False);\n\n\twhile (1) {\n\t\tchar tmp[32];\n\t\tsprintf(tmp, \"HELPER_CNT_%08d\", cnt++);\n\t\tXChangeProperty(dpy, DefaultRootWindow(dpy), ticker_atom, XA_STRING, 8,\n\t\t    PropModeReplace, (unsigned char *) tmp, strlen(tmp));\n\t\tXFlush(dpy);\n\t\tusleep(ms*1000);\n\t\tif (parent_pid > 0) {\n\t\t\tif(dnow() > last_check + 1.0) {\n\t\t\t\tlast_check = dnow();\n\t\t\t\tif (kill(parent_pid, 0) != 0) {\n\t\t\t\t\tfprintf(stderr, \"be_helper_pid: parent %d is gone.\\n\", (int) parent_pid);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n#endif\n\texit(0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fork",
          "args": [],
          "line": 2024
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getpid",
          "args": [],
          "line": 2023
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"set -connect to: %s\\n\"",
            "connect_to"
          ],
          "line": 2014
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fclose",
          "args": [
            "f"
          ],
          "line": 2012
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcat",
          "args": [
            "connect_to",
            "q"
          ],
          "line": 2010
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcat",
          "args": [
            "connect_to",
            "\",\""
          ],
          "line": 2008
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lblanks",
          "args": [
            "line"
          ],
          "line": 2003
        },
        "resolved": true,
        "details": {
          "function_name": "lblanks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/util.c",
          "lines": "160-169",
          "snippet": "char *lblanks(char *str) {\n\tchar *p = str;\n\twhile (*p != '\\0') {\n\t\tif (! isspace((unsigned char) (*p))) {\n\t\t\tbreak;\n\t\t}\n\t\tp++;\n\t}\n\treturn p;\n}",
          "includes": [
            "#include \"connections.h\"",
            "#include \"unixpw.h\"",
            "#include \"win_utils.h\"",
            "#include \"cleanup.h\"",
            "#include \"x11vnc.h\"",
            "#include <stdlib.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void lowercase(char *str);",
            "void uppercase(char *str);",
            "char *lblanks(char *str);",
            "void strzero(char *str);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"connections.h\"\n#include \"unixpw.h\"\n#include \"win_utils.h\"\n#include \"cleanup.h\"\n#include \"x11vnc.h\"\n#include <stdlib.h>\n\nvoid lowercase(char *str);\nvoid uppercase(char *str);\nchar *lblanks(char *str);\nvoid strzero(char *str);\n\nchar *lblanks(char *str) {\n\tchar *p = str;\n\twhile (*p != '\\0') {\n\t\tif (! isspace((unsigned char) (*p))) {\n\t\t\tbreak;\n\t\t}\n\t\tp++;\n\t}\n\treturn p;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "line",
            "'\\n'"
          ],
          "line": 2001
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fgets",
          "args": [
            "line",
            "len",
            "f"
          ],
          "line": 2000
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "calloc",
          "args": [
            "2 * len",
            "1"
          ],
          "line": 1999
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "len"
          ],
          "line": 1998
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fopen",
          "args": [
            "control",
            "\"r\""
          ],
          "line": 1995
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "stat",
          "args": [
            "control",
            "&sb"
          ],
          "line": 1993
        },
        "resolved": true,
        "details": {
          "function_name": "grab_state",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/connections.c",
          "lines": "3178-3224",
          "snippet": "void grab_state(int *ptr_grabbed, int *kbd_grabbed) {\n\tint rcp, rck;\n\tdouble t0, t1;\n\tdouble ta, tb, tc;\n\t*ptr_grabbed = -1;\n\t*kbd_grabbed = -1;\n\n\tif (!dpy) {\n\t\treturn;\n\t}\n\t*ptr_grabbed = 0;\n\t*kbd_grabbed = 0;\n\n#if !NO_X11\n\tX_LOCK;\n\n\tXSync(dpy, False);\n\n\tta = t0 = dnow();\n\n\trcp = XGrabPointer(dpy, window, False, 0, GrabModeAsync, GrabModeAsync, None, None, CurrentTime);\n\tXUngrabPointer(dpy, CurrentTime);\n\n\ttb = dnow();\n\t\n\trck = XGrabKeyboard(dpy, window, False, GrabModeAsync, GrabModeAsync, CurrentTime);\n\tXUngrabKeyboard(dpy, CurrentTime);\n\n\ttc = dnow();\n\n\tXSync(dpy, False);\n\n\tt1 = dnow();\n\n\tX_UNLOCK;\n\tif (rcp == AlreadyGrabbed || rcp == GrabFrozen) {\n\t\t*ptr_grabbed = 1;\n\t}\n\tif (rck == AlreadyGrabbed || rck == GrabFrozen) {\n\t\t*kbd_grabbed = 1;\n\t}\n\tif (rc_npieces < 10) {\n\t\trfbLog(\"grab_state: checked %d,%d in %.6f sec (%.6f %.6f)\\n\",\n\t\t    *ptr_grabbed, *kbd_grabbed, t1-t0, tb-ta, tc-tb);\n\t}\n#endif\n}",
          "includes": [
            "#include \"xi2_devices.h\"",
            "#include \"xrandr.h\"",
            "#include \"pointer.h\"",
            "#include \"userinput.h\"",
            "#include \"macosxCG.h\"",
            "#include \"macosx.h\"",
            "#include \"win_utils.h\"",
            "#include \"xevents.h\"",
            "#include \"xwrappers.h\"",
            "#include \"sslhelper.h\"",
            "#include \"sslcmds.h\"",
            "#include \"scan.h\"",
            "#include \"user.h\"",
            "#include \"unixpw.h\"",
            "#include \"screen.h\"",
            "#include \"rates.h\"",
            "#include \"solid.h\"",
            "#include \"gui.h\"",
            "#include \"cleanup.h\"",
            "#include \"keyboard.h\"",
            "#include \"remote.h\"",
            "#include \"inet.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void grab_state(int *ptr_grabbed, int *kbd_grabbed);",
            "extern int rc_npieces;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xi2_devices.h\"\n#include \"xrandr.h\"\n#include \"pointer.h\"\n#include \"userinput.h\"\n#include \"macosxCG.h\"\n#include \"macosx.h\"\n#include \"win_utils.h\"\n#include \"xevents.h\"\n#include \"xwrappers.h\"\n#include \"sslhelper.h\"\n#include \"sslcmds.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"unixpw.h\"\n#include \"screen.h\"\n#include \"rates.h\"\n#include \"solid.h\"\n#include \"gui.h\"\n#include \"cleanup.h\"\n#include \"keyboard.h\"\n#include \"remote.h\"\n#include \"inet.h\"\n#include \"x11vnc.h\"\n\nvoid grab_state(int *ptr_grabbed, int *kbd_grabbed);\nextern int rc_npieces;\n\nvoid grab_state(int *ptr_grabbed, int *kbd_grabbed) {\n\tint rcp, rck;\n\tdouble t0, t1;\n\tdouble ta, tb, tc;\n\t*ptr_grabbed = -1;\n\t*kbd_grabbed = -1;\n\n\tif (!dpy) {\n\t\treturn;\n\t}\n\t*ptr_grabbed = 0;\n\t*kbd_grabbed = 0;\n\n#if !NO_X11\n\tX_LOCK;\n\n\tXSync(dpy, False);\n\n\tta = t0 = dnow();\n\n\trcp = XGrabPointer(dpy, window, False, 0, GrabModeAsync, GrabModeAsync, None, None, CurrentTime);\n\tXUngrabPointer(dpy, CurrentTime);\n\n\ttb = dnow();\n\t\n\trck = XGrabKeyboard(dpy, window, False, GrabModeAsync, GrabModeAsync, CurrentTime);\n\tXUngrabKeyboard(dpy, CurrentTime);\n\n\ttc = dnow();\n\n\tXSync(dpy, False);\n\n\tt1 = dnow();\n\n\tX_UNLOCK;\n\tif (rcp == AlreadyGrabbed || rcp == GrabFrozen) {\n\t\t*ptr_grabbed = 1;\n\t}\n\tif (rck == AlreadyGrabbed || rck == GrabFrozen) {\n\t\t*kbd_grabbed = 1;\n\t}\n\tif (rc_npieces < 10) {\n\t\trfbLog(\"grab_state: checked %d,%d in %.6f sec (%.6f %.6f)\\n\",\n\t\t    *ptr_grabbed, *kbd_grabbed, t1-t0, tb-ta, tc-tb);\n\t}\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "control",
            "\"internal\""
          ],
          "line": 1986
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "getenv(\"X11VNC_APPSHARE_TICKER_PROPNAME\")"
          ],
          "line": 1982
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getenv",
          "args": [
            "\"X11VNC_APPSHARE_TICKER_PROPNAME\""
          ],
          "line": 1982
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getenv",
          "args": [
            "\"X11VNC_APPSHARE_TICKER_PROPNAME\""
          ],
          "line": 1981
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "getenv(\"X11VNC_APPSHARE_COMMAND_PROPNAME\")"
          ],
          "line": 1979
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getenv",
          "args": [
            "\"X11VNC_APPSHARE_COMMAND_PROPNAME\""
          ],
          "line": 1979
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getenv",
          "args": [
            "\"X11VNC_APPSHARE_COMMAND_PROPNAME\""
          ],
          "line": 1978
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atoi",
          "args": [
            "getenv(\"X11VNC_APPSHARE_DEBUG\")"
          ],
          "line": 1974
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getenv",
          "args": [
            "\"X11VNC_APPSHARE_DEBUG\""
          ],
          "line": 1974
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getenv",
          "args": [
            "\"X11VNC_APPSHARE_DEBUG\""
          ],
          "line": 1973
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"unrecognized 'x11vnc -appshare' option: %s\\n\"",
            "s"
          ],
          "line": 1968
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "s",
            "\"-appshare\""
          ],
          "line": 1965
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"ignoring %s in -appshare mode.\\n\"",
            "s"
          ],
          "line": 1964
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "s",
            "\"-safer\""
          ],
          "line": 1963
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "s",
            "\"-nocmds\""
          ],
          "line": 1963
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "s",
            "\"-shell\""
          ],
          "line": 1961
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "s",
            "\"-noexit\""
          ],
          "line": 1959
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "s",
            "\"-showmenus\""
          ],
          "line": 1957
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "s",
            "\"-debug\""
          ],
          "line": 1955
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "putenv",
          "args": [
            "argv[++i]"
          ],
          "line": 1954
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "s",
            "\"-env\""
          ],
          "line": 1952
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "argv[++i]"
          ],
          "line": 1951
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "s",
            "\"-args\""
          ],
          "line": 1949
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atof",
          "args": [
            "argv[++i]"
          ],
          "line": 1948
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "s",
            "\"-delay\""
          ],
          "line": 1946
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_env",
          "args": [
            "\"DISPLAY\"",
            "dpy_str"
          ],
          "line": 1945
        },
        "resolved": true,
        "details": {
          "function_name": "set_env",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/util.c",
          "lines": "239-249",
          "snippet": "void set_env(char *name, char *value) {\n\tchar *str;\n\tif (! name) {\n\t\treturn;\n\t}\n\tif (! value) {\n\t\tvalue = \"\";\n\t}\n\n\tsetenv(name, value, 1);\n}",
          "includes": [
            "#include \"connections.h\"",
            "#include \"unixpw.h\"",
            "#include \"win_utils.h\"",
            "#include \"cleanup.h\"",
            "#include \"x11vnc.h\"",
            "#include <stdlib.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void lowercase(char *str);",
            "void uppercase(char *str);",
            "char *lblanks(char *str);",
            "void strzero(char *str);",
            "void set_env(char *name, char *value);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"connections.h\"\n#include \"unixpw.h\"\n#include \"win_utils.h\"\n#include \"cleanup.h\"\n#include \"x11vnc.h\"\n#include <stdlib.h>\n\nvoid lowercase(char *str);\nvoid uppercase(char *str);\nchar *lblanks(char *str);\nvoid strzero(char *str);\nvoid set_env(char *name, char *value);\n\nvoid set_env(char *name, char *value) {\n\tchar *str;\n\tif (! name) {\n\t\treturn;\n\t}\n\tif (! value) {\n\t\tvalue = \"\";\n\t}\n\n\tsetenv(name, value, 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "argv[++i]"
          ],
          "line": 1944
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "s",
            "\"-display\""
          ],
          "line": 1942
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "argv[++i]"
          ],
          "line": 1941
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "s",
            "\"-trackdir\""
          ],
          "line": 1939
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "\"internal\""
          ],
          "line": 1936
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "control",
            "\"shell\""
          ],
          "line": 1934
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "argv[++i]"
          ],
          "line": 1933
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "s",
            "\"-control\""
          ],
          "line": 1931
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "argv[++i]"
          ],
          "line": 1930
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "s",
            "\"-coe\""
          ],
          "line": 1928
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "s",
            "\"-connect_or_exit\""
          ],
          "line": 1928
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "s",
            "\"-connect\""
          ],
          "line": 1928
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "argv[++i]"
          ],
          "line": 1927
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "s",
            "\"-sid\""
          ],
          "line": 1924
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "argv[++i]"
          ],
          "line": 1923
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "s",
            "\"-id\""
          ],
          "line": 1920
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stdout",
            "\"%s\"",
            "usage"
          ],
          "line": 1918
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "s",
            "\"-help\""
          ],
          "line": 1917
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "s",
            "\"-h\""
          ],
          "line": 1917
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "s",
            "\"--\""
          ],
          "line": 1913
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "argv[0]"
          ],
          "line": 1908
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"x11vnc.h\"\n\n#define AMAX 32\n#define CMAX 128\n#define WMAX 192\n\nextern char *get_xprop(char *prop, Window win);\nextern int set_xprop(char *prop, Window win, char *value);\nextern void set_env(char *name, char *value);\nextern double dnow(void);\nstatic char *usage =\n\"\\n\"\n\"  x11vnc -appshare: an experiment in application sharing via x11vnc.\\n\"\n\"\\n\";\n\nint appshare_main(int argc, char *argv[]) {\n\tint i;\n\tchar *app_str = NULL;\n\tchar *dpy_str = NULL;\n\tlong xselectinput = 0;\n#if NO_X11\n\texiter(\"not compiled with X11\\n\", 1);\n#else\n\tfor (i=0; i < WMAX; i++) {\n\t\twatch[i] = None;\n\t\tstate[i] = 0;\n\t}\n\tfor (i=0; i < AMAX; i++) {\n\t\tapps[i]  = None;\n\t}\n\tfor (i=0; i < CMAX; i++) {\n\t\tclients[i] = NULL;\n\t}\n\n\tx11vnc = strdup(argv[0]);\n\n\tfor (i=1; i < argc; i++) {\n\t\tint end = (i == argc-1) ? 1 : 0;\n\t\tchar *s = argv[i];\n\t\tif (strstr(s, \"--\") == s) {\n\t\t\ts++;\n\t\t}\n\n\t\tif (!strcmp(s, \"-h\") || !strcmp(s, \"-help\")) {\n\t\t\tfprintf(stdout, \"%s\", usage);\n\t\t\texit(0);\n\t\t} else if (!strcmp(s, \"-id\")) {\n\t\t\tid_opt = \"-id\";\n\t\t\tif (end) exiter(\"no -id value supplied\\n\", 1);\n\t\t\tapp_str = strdup(argv[++i]);\n\t\t} else if (!strcmp(s, \"-sid\")) {\n\t\t\tid_opt = \"-sid\";\n\t\t\tif (end) exiter(\"no -sid value supplied\\n\", 1);\n\t\t\tapp_str = strdup(argv[++i]);\n\t\t} else if (!strcmp(s, \"-connect\") || !strcmp(s, \"-connect_or_exit\") || !strcmp(s, \"-coe\")) {\n\t\t\tif (end) exiter(\"no -connect value supplied\\n\", 1);\n\t\t\tconnect_to = strdup(argv[++i]);\n\t\t} else if (!strcmp(s, \"-control\")) {\n\t\t\tif (end) exiter(\"no -control value supplied\\n\", 1);\n\t\t\tcontrol = strdup(argv[++i]);\n\t\t\tif (!strcmp(control, \"shell\")) {\n\t\t\t\tfree(control);\n\t\t\t\tcontrol = strdup(\"internal\");\n\t\t\t\tshell = 1;\n\t\t\t}\n\t\t} else if (!strcmp(s, \"-trackdir\")) {\n\t\t\tif (end) exiter(\"no -trackdir value supplied\\n\", 1);\n\t\t\ttrackdir = strdup(argv[++i]);\n\t\t} else if (!strcmp(s, \"-display\")) {\n\t\t\tif (end) exiter(\"no -display value supplied\\n\", 1);\n\t\t\tdpy_str = strdup(argv[++i]);\n\t\t\tset_env(\"DISPLAY\", dpy_str);\n\t\t} else if (!strcmp(s, \"-delay\")) {\n\t\t\tif (end) exiter(\"no -delay value supplied\\n\", 1);\n\t\t\thelper_delay = atof(argv[++i]);\n\t\t} else if (!strcmp(s, \"-args\")) {\n\t\t\tif (end) exiter(\"no -args value supplied\\n\", 1);\n\t\t\tx11vnc_args = strdup(argv[++i]);\n\t\t} else if (!strcmp(s, \"-env\")) {\n\t\t\tif (end) exiter(\"no -env value supplied\\n\", 1);\n\t\t\tputenv(argv[++i]);\n\t\t} else if (!strcmp(s, \"-debug\")) {\n\t\t\tappshare_debug++;\n\t\t} else if (!strcmp(s, \"-showmenus\")) {\n\t\t\tskip_menus = 0;\n\t\t} else if (!strcmp(s, \"-noexit\")) {\n\t\t\texit_no_app_win = 0;\n\t\t} else if (!strcmp(s, \"-shell\")) {\n\t\t\tshell = 1;\n\t\t} else if (!strcmp(s, \"-nocmds\") || !strcmp(s, \"-safer\")) {\n\t\t\tfprintf(stderr, \"ignoring %s in -appshare mode.\\n\", s);\n\t\t} else if (!strcmp(s, \"-appshare\")) {\n\t\t\t;\n\t\t} else {\n\t\t\tfprintf(stderr, \"unrecognized 'x11vnc -appshare' option: %s\\n\", s);\n\t\t\texiter(\"\", 1);\n\t\t}\n\t}\n\n\tif (getenv(\"X11VNC_APPSHARE_DEBUG\")) {\n\t\tappshare_debug = atoi(getenv(\"X11VNC_APPSHARE_DEBUG\"));\n\t}\n\n\t/* let user override name for multiple instances: */\n\tif (getenv(\"X11VNC_APPSHARE_COMMAND_PROPNAME\")) {\n\t\tcmd_atom_str = strdup(getenv(\"X11VNC_APPSHARE_COMMAND_PROPNAME\"));\n\t}\n\tif (getenv(\"X11VNC_APPSHARE_TICKER_PROPNAME\")) {\n\t\tticker_atom_str = strdup(getenv(\"X11VNC_APPSHARE_TICKER_PROPNAME\"));\n\t}\n\n\tif (shell) {\n\t\tif (!control || strcmp(control, \"internal\")) {\n\t\t\texiter(\"mode -shell requires '-control internal'\\n\", 1);\n\t\t}\n\t}\n\n\tif (connect_to == NULL && control != NULL) {\n\t\tstruct stat sb;\n\t\tif (stat(control, &sb) == 0) {\n\t\t\tint len = 100 + sb.st_size;\n\t\t\tFILE *f = fopen(control, \"r\");\n\n\t\t\tif (f) {\n\t\t\t\tchar *line = (char *) malloc(len);\n\t\t\t\tconnect_to = (char *) calloc(2 * len, 1);\n\t\t\t\twhile (fgets(line, len, f) != NULL) {\n\t\t\t\t\tchar *q = strchr(line, '\\n');\n\t\t\t\t\tif (q) *q = '\\0';\n\t\t\t\t\tq = lblanks(line);\n\t\t\t\t\tif (q[0] == '#') {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tif (connect_to[0] != '\\0') {\n\t\t\t\t\t\tstrcat(connect_to, \",\");\n\t\t\t\t\t}\n\t\t\t\t\tstrcat(connect_to, q);\n\t\t\t\t}\n\t\t\t\tfclose(f);\n\t\t\t}\n\t\t\tfprintf(stderr, \"set -connect to: %s\\n\", connect_to);\n\t\t}\n\t}\n\tif (0 && connect_to == NULL && control == NULL) {\n\t\texiter(\"no -connect host or -control file specified.\\n\", 1);\n\t}\n\n\tif (control) {\n\t\tpid_t pid;\n\t\tparent_pid = getpid();\n\t\tpid = fork();\n\t\tif (pid == (pid_t) -1) {\n\t\t\t;\n\t\t} else if (pid == 0) {\n\t\t\tbe_helper_pid(dpy_str);\n\t\t\texit(0);\n\t\t} else {\n\t\t\thelper_pid = pid;\n\t\t}\n\t}\n\n\tdpy = XOpenDisplay(dpy_str);\n\tif (!dpy) {\n\t\texiter(\"cannot open display\\n\", 1);\n\t}\n\n\troot = DefaultRootWindow(dpy);\n\n\txselectinput = SubstructureNotifyMask;\n\tif (helper_pid > 0) {\n\t\tticker_atom = XInternAtom(dpy, ticker_atom_str, False);\n\t\txselectinput |= PropertyChangeMask;\n\t}\n\tXSelectInput(dpy, root, xselectinput);\n\n\tcmd_atom = XInternAtom(dpy, cmd_atom_str, False);\n\n\tinit_cmask();\n\n\tsprintf(unique_tag, \"X11VNC_APPSHARE_TAG=%d-tag\", getpid());\n\n\tstart_time = dnow();\n\n\tif (app_str == NULL) {\n\t\texiter(\"no -id/-sid window specified.\\n\", 1);\n\t} else {\n\t\tchar *p, *str = strdup(app_str);\n\t\tchar *alist[AMAX];\n\t\tint i, n = 0;\n\n\t\tp = strtok(str, \",\");\n\t\twhile (p) {\n\t\t\tif (n >= AMAX) {\n\t\t\t\tfprintf(stderr, \"ran out of app slots: %s\\n\", app_str);\n\t\t\t\texiter(\"\", 1);\n\t\t\t}\n\t\t\talist[n++] = strdup(p);\n\t\t\tp = strtok(NULL, \",\");\n\t\t}\n\t\tfree(str);\n\n\t\tfor (i=0; i < n; i++) {\n\t\t\tWindow app = None;\n\t\t\tp = alist[i];\n\t\t\tapp = parse_win(p);\n\t\t\tfree(p);\n\n\t\t\tif (app != None) {\n\t\t\t\tif (!ours(app)) {\n\t\t\t\t\tadd_app(app);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tset_trackdir();\n\n\tsignal(SIGINT,  appshare_cleanup);\n\tsignal(SIGTERM, appshare_cleanup);\n\n\trfbLogEnable(0);\n\n\tif (connect_to) {\n\t\tchar *p, *str = strdup(connect_to);\n\t\tint n = 0;\n\t\tp = strtok(str, \",\");\n\t\twhile (p) {\n\t\t\tclients[n++] = strdup(p);\n\t\t\tp = strtok(NULL, \",\");\n\t\t}\n\t\tfree(str);\n\t} else {\n\t\tconnect_to = strdup(\"\");\n\t}\n\n\tfor (i=0; i < AMAX; i++) {\n\t\tif (apps[i] == None) {\n\t\t\tcontinue;\n\t\t}\n\t\tfprintf(stdout, \"Using app win: 0x%08lx  root: 0x%08lx\\n\", apps[i], root);\n\t}\n\tfprintf(stdout, \"\\n\");\n\n\tmonitor();\n\n\tappshare_cleanup(0);\n\n#endif\n\treturn 0;\n}"
  },
  {
    "function_name": "monitor",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/appshare.c",
    "lines": "1757-1887",
    "snippet": "static void monitor(void) {\n#if !NO_X11\n\tXEvent ev;\n\tdouble start = dnow();\n\tint got_prop_cmd = 0;\n\n\tif (shell) {\n\t\tupdate();\n\t\tfprintf(stderr, \"\\n\\n\");\n\t\tprocess_string(\"cmd=help\");\n\t\tfprintf(stderr, \"\\n%s\", prompt); ff();\n\t}\n\n\twhile (1) {\n\t\tint t;\n\n\t\tif (XEventsQueued(dpy, QueuedAlready) == 0) {\n\t\t\tupdate();\n\t\t\tif (got_prop_cmd) {\n\t\t\t\thandle_prop_cmd();\n\t\t\t}\n\t\t\tgot_prop_cmd = 0;\n\t\t\tif (shell) {\n\t\t\t\thandle_shell();\n\t\t\t}\n\t\t}\n\n\t\tXNextEvent(dpy, &ev);\n\n\t\tlast_event_type = ev.type;\n\n\t\tswitch (ev.type) {\n\t\tcase Expose:\n\t\t\tPREFIX\n\t\t\tif(appshare_debug) fprintf(stderr, \"Expose %04dx%04d+%04d+%04d\\n\", ev.xexpose.width, ev.xexpose.height, ev.xexpose.x, ev.xexpose.y);\n\t\t\tbreak;\n\t\tcase ConfigureNotify:\n#if 0\n\t\t\tPREFIX\n\t\t\tif(appshare_debug) fprintf(stderr, \"ConfigureNotify %04dx%04d+%04d+%04d  above: 0x%lx\\n\", ev.xconfigure.width, ev.xconfigure.height, ev.xconfigure.x, ev.xconfigure.y, ev.xconfigure.above);\n#endif\n\t\t\tbreak;\n\t\tcase VisibilityNotify:\n\t\t\tPREFIX\n\t\t\tif (appshare_debug) {\n\t\t\tfprintf(stderr, \"VisibilityNotify: \");\n\t\t\tt = ev.xvisibility.state;\n\t\t\tif (t == VisibilityFullyObscured)     fprintf(stderr, \"VisibilityFullyObscured\\n\");\n\t\t\tif (t == VisibilityPartiallyObscured) fprintf(stderr, \"VisibilityPartiallyObscured\\n\");\n\t\t\tif (t == VisibilityUnobscured)        fprintf(stderr, \"VisibilityUnobscured\\n\");\n\t\t\t}\n\t\t\tbreak;\n\t\tcase MapNotify:\n\t\t\tPREFIX\n\t\t\tif(appshare_debug) fprintf(stderr, \"MapNotify      win: 0x%lx\\n\", ev.xmap.window);\n\t\t\tif (ours(ev.xmap.window)) {\n\t\t\t\tmapped(ev.xmap.window);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase UnmapNotify:\n\t\t\tPREFIX\n\t\t\tif(appshare_debug) fprintf(stderr, \"UnmapNotify    win: 0x%lx\\n\", ev.xmap.window);\n\t\t\tif (ours(ev.xmap.window)) {\n\t\t\t\tunmapped(ev.xmap.window);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase MapRequest:\n\t\t\tPREFIX\n\t\t\tif(appshare_debug) fprintf(stderr, \"MapRequest\\n\");\n\t\t\tbreak;\n\t\tcase CreateNotify:\n\t\t\tPREFIX\n\t\t\tif(appshare_debug) fprintf(stderr, \"CreateNotify parent: 0x%lx  win: 0x%lx\\n\", ev.xcreatewindow.parent, ev.xcreatewindow.window);\n\t\t\tif (ev.xcreatewindow.parent == root && ours(ev.xcreatewindow.window)) {\n\t\t\t\tif (find_win(ev.xcreatewindow.window) >= 0) {\n\t\t\t\t\tdestroy_win(ev.xcreatewindow.window);\n\t\t\t\t}\n\t\t\t\tadd_win(ev.xcreatewindow.window);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase DestroyNotify:\n\t\t\tPREFIX\n\t\t\tif(appshare_debug) fprintf(stderr, \"DestroyNotify  win: 0x%lx\\n\", ev.xdestroywindow.window);\n\t\t\tif (ours(ev.xdestroywindow.window)) {\n\t\t\t\tdestroy_win(ev.xdestroywindow.window);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase ConfigureRequest:\n\t\t\tPREFIX\n\t\t\tif(appshare_debug) fprintf(stderr, \"ConfigureRequest\\n\");\n\t\t\tbreak;\n\t\tcase CirculateRequest:\n#if 0\n\t\t\tPREFIX\n\t\t\tif(appshare_debug) fprintf(stderr, \"CirculateRequest parent: 0x%lx  win: 0x%lx\\n\", ev.xcirculaterequest.parent, ev.xcirculaterequest.window);\n#endif\n\t\t\tbreak;\n\t\tcase CirculateNotify:\n#if 0\n\t\t\tPREFIX\n\t\t\tif(appshare_debug) fprintf(stderr, \"CirculateNotify\\n\");\n#endif\n\t\t\tbreak;\n\t\tcase PropertyNotify:\n#if 0\n\t\t\tPREFIX\n\t\t\tif(appshare_debug) fprintf(stderr, \"PropertyNotify\\n\");\n#endif\n\t\t\tif (cmd_atom != None && ev.xproperty.atom == cmd_atom) {\n\t\t\t\tgot_prop_cmd++;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase ReparentNotify:\n\t\t\tPREFIX\n\t\t\tif(appshare_debug) fprintf(stderr, \"ReparentNotify parent: 0x%lx  win: 0x%lx\\n\", ev.xreparent.parent, ev.xreparent.window);\n\t\t\tif (ours(ev.xreparent.window)) {\n\t\t\t\tif (ours(ev.xreparent.parent)) {\n\t\t\t\t\tdestroy_win(ev.xreparent.window);\n\t\t\t\t} else if (ev.xreparent.parent == root) {\n\t\t\t\t\t/* ??? */\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tPREFIX\n\t\t\tif(appshare_debug) fprintf(stderr, \"Unknown: %d\\n\", ev.type);\n\t\t\tbreak;\n\t\t}\n\t}\n#endif\n}",
    "includes": [
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [
      "#define PREFIX if(appshare_debug) fprintf(stderr, \"  %8.2f  0x%08lx : \", dnow() - start, ev.xany.window);"
    ],
    "globals_used": [
      "extern char *get_xprop(char *prop, Window win);",
      "extern double dnow(void);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "destroy_win",
          "args": [
            "ev.xreparent.window"
          ],
          "line": 1874
        },
        "resolved": true,
        "details": {
          "function_name": "destroy_win",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/appshare.c",
          "lines": "1103-1106",
          "snippet": "static void destroy_win(Window win) {\n\tstop(win);\n\tdelete_win(win);\n}",
          "includes": [
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "extern char *get_xprop(char *prop, Window win);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"x11vnc.h\"\n\nextern char *get_xprop(char *prop, Window win);\n\nstatic void destroy_win(Window win) {\n\tstop(win);\n\tdelete_win(win);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ours",
          "args": [
            "ev.xreparent.parent"
          ],
          "line": 1873
        },
        "resolved": true,
        "details": {
          "function_name": "ours",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/appshare.c",
          "lines": "1301-1311",
          "snippet": "static int ours(Window win) {\n\tint i;\n\tfor (i=0; i < AMAX; i++) {\n\t\tif (apps[i] != None) {\n\t\t\tif (same_app(win, apps[i])) {\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [
            "#define AMAX 32"
          ],
          "globals_used": [
            "extern char *get_xprop(char *prop, Window win);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"x11vnc.h\"\n\n#define AMAX 32\n\nextern char *get_xprop(char *prop, Window win);\n\nstatic int ours(Window win) {\n\tint i;\n\tfor (i=0; i < AMAX; i++) {\n\t\tif (apps[i] != None) {\n\t\t\tif (same_app(win, apps[i])) {\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"PropertyNotify\\n\");\n#endif\n\t\t\tif (cmd_atom != None && ev.xproperty.atom == cmd_atom)"
          ],
          "line": 1863
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "n",
          "args": [
            "cmd_atom != None && ev.xproperty.atom == cmd_atom"
          ],
          "line": 1863
        },
        "resolved": true,
        "details": {
          "function_name": "process_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/appshare.c",
          "lines": "1656-1679",
          "snippet": "static void process_string(char *str) {\n\tFILE *f;\n\tchar *file;\n\tif (trackdir) {\n\t\tsprintf(tracktmp, \"%s/0xprop.cmd\", trackdir);\n\t\tfile = strdup(tracktmp);\n\t} else {\n\t\tchar tmp[] = \"/tmp/x11vnc-appshare.cmd.XXXXXX\";\n\t\tint fd = mkstemp(tmp);\n\t\tif (fd < 0) {\n\t\t\treturn;\n\t\t}\n\t\tfile = strdup(tmp);\n\t\tclose(fd);\n\t}\n\tf = fopen(file, \"w\");\n\tif (f) {\n\t\tfprintf(f, \"%s\", str);\n\t\tfclose(f);\n\t\tprocess_control(file, 0);\n\t}\n\tunlink(file);\n\tfree(file);\n}",
          "includes": [
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"x11vnc.h\"\n\nstatic void process_string(char *str) {\n\tFILE *f;\n\tchar *file;\n\tif (trackdir) {\n\t\tsprintf(tracktmp, \"%s/0xprop.cmd\", trackdir);\n\t\tfile = strdup(tracktmp);\n\t} else {\n\t\tchar tmp[] = \"/tmp/x11vnc-appshare.cmd.XXXXXX\";\n\t\tint fd = mkstemp(tmp);\n\t\tif (fd < 0) {\n\t\t\treturn;\n\t\t}\n\t\tfile = strdup(tmp);\n\t\tclose(fd);\n\t}\n\tf = fopen(file, \"w\");\n\tif (f) {\n\t\tfprintf(f, \"%s\", str);\n\t\tfclose(f);\n\t\tprocess_control(file, 0);\n\t}\n\tunlink(file);\n\tfree(file);\n}"
        }
      },
      {
        "call_info": {
          "callee": "if",
          "args": [
            "appshare_debug"
          ],
          "line": 1863
        },
        "resolved": true,
        "details": {
          "function_name": "get_ssl_verify_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/sslhelper.c",
          "lines": "547-664",
          "snippet": "char *get_ssl_verify_file(char *str_in) {\n\tchar *p, *str, *cdir, *tmp;\n\tchar *tfile, *tfile2;\n\tFILE *file;\n\tstruct stat sbuf;\n\tint count = 0, fd;\n\n\tif (! str_in) {\n\t\trfbLog(\"get_ssl_verify_file: no filename\\n\");\n\t\texit(1);\n\t}\n\n\tif (stat(str_in, &sbuf) == 0) {\n\t\t/* assume he knows what he is doing. */\n\t\treturn str_in;\n\t}\n\n\tcdir = get_Cert_dir(NULL, &tmp);\n\tif (! cdir || ! tmp) {\n\t\trfbLog(\"get_ssl_verify_file: invalid cert-dir.\\n\");\n\t\texit(1);\n\t}\n\n\ttfile  = (char *) malloc(strlen(tmp) + 1024);\n\ttfile2 = (char *) malloc(strlen(tmp) + 1024);\n\n\tsprintf(tfile, \"%s/sslverify-tmp-load-%d.crts.XXXXXX\", tmp, getpid());\n\n\tfd = mkstemp(tfile);\n\tif (fd < 0) {\n\t\trfbLog(\"get_ssl_verify_file: %s\\n\", tfile);\n\t\trfbLogPerror(\"mkstemp\");\n\t\texit(1);\n\t}\n\tclose(fd);\n\n\tfile = fopen(tfile, \"w\");\n\tchmod(tfile, 0600);\n\tif (file == NULL) {\n\t\trfbLog(\"get_ssl_verify_file: %s\\n\", tfile);\n\t\trfbLogPerror(\"fopen\");\n\t\texit(1);\n\t}\n\n\tstr = strdup(str_in);\n\tp = strtok(str, \",\");\n\n\twhile (p) {\n\t\tif (!strcmp(p, \"CA\")) {\n\t\t\tsprintf(tfile2, \"%s/CA/cacert.pem\", cdir);\n\t\t\tif (! appendfile(file, tfile2)) {\n\t\t\t\tunlink(tfile);\n\t\t\t\texit(1);\n\t\t\t}\n\t\t\trfbLog(\"sslverify: loaded %s\\n\", tfile2);\n\t\t\tcount++;\n\n\t\t} else if (!strcmp(p, \"clients\")) {\n\t\t\tDIR *dir;\n\t\t\tstruct dirent *dp;\n\n\t\t\tsprintf(tfile2, \"%s/clients\", cdir);\n\t\t\tdir = opendir(tfile2);\n\t\t\tif (! dir) {\n\t\t\t\trfbLog(\"get_ssl_verify_file: %s\\n\", tfile2);\n\t\t\t\trfbLogPerror(\"opendir\");\n\t\t\t\tunlink(tfile);\n\t\t\t\texit(1);\n\t\t\t}\n\t\t\twhile ( (dp = readdir(dir)) != NULL) {\n\t\t\t\tchar *n = dp->d_name;\n\t\t\t\tchar *q = strstr(n, \".crt\");\n\n\t\t\t\tif (! q || strlen(q) != strlen(\".crt\")) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (strlen(n) > 512) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tsprintf(tfile2, \"%s/clients/%s\", cdir, n);\n\t\t\t\tif (! appendfile(file, tfile2)) {\n\t\t\t\t\tunlink(tfile);\n\t\t\t\t\texit(1);\n\t\t\t\t}\n\t\t\t\trfbLog(\"sslverify: loaded %s\\n\",\n\t\t\t\t    tfile2);\n\t\t\t\tcount++;\n\t\t\t}\n\t\t\tclosedir(dir);\n\t\t\t\n\t\t} else {\n\t\t\tif (strlen(p) > 512) {\n\t\t\t\tunlink(tfile);\n\t\t\t\texit(1);\n\t\t\t}\n\t\t\tsprintf(tfile2, \"%s/clients/%s.crt\", cdir, p);\n\t\t\tif (stat(tfile2, &sbuf) != 0) {\n\t\t\t\tsprintf(tfile2, \"%s/clients/%s\", cdir, p);\n\t\t\t}\n\t\t\tif (! appendfile(file, tfile2)) {\n\t\t\t\tunlink(tfile);\n\t\t\t\texit(1);\n\t\t\t}\n\t\t\trfbLog(\"sslverify: loaded %s\\n\", tfile2);\n\t\t\tcount++;\n\t\t}\n\t\tp = strtok(NULL, \",\");\n\t}\n\tfclose(file);\n\tfree(tfile2);\n\tfree(str);\n\n\trfbLog(\"sslverify: using %d client certs in\\n\", count);\n\trfbLog(\"sslverify: %s\\n\", tfile);\n\n\treturn tfile;\n}",
          "includes": [
            "#include <openssl/rand.h>",
            "#include <openssl/err.h>",
            "#include <openssl/ssl.h>",
            "#include \"user.h\"",
            "#include \"unixpw.h\"",
            "#include \"sslcmds.h\"",
            "#include \"connections.h\"",
            "#include \"scan.h\"",
            "#include \"screen.h\"",
            "#include \"cleanup.h\"",
            "#include \"inet.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "char *get_ssl_verify_file(char *str_in);",
            "static char *get_input(char *tag, char **in);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <openssl/rand.h>\n#include <openssl/err.h>\n#include <openssl/ssl.h>\n#include \"user.h\"\n#include \"unixpw.h\"\n#include \"sslcmds.h\"\n#include \"connections.h\"\n#include \"scan.h\"\n#include \"screen.h\"\n#include \"cleanup.h\"\n#include \"inet.h\"\n#include \"x11vnc.h\"\n\nchar *get_ssl_verify_file(char *str_in);\nstatic char *get_input(char *tag, char **in);\n\nchar *get_ssl_verify_file(char *str_in) {\n\tchar *p, *str, *cdir, *tmp;\n\tchar *tfile, *tfile2;\n\tFILE *file;\n\tstruct stat sbuf;\n\tint count = 0, fd;\n\n\tif (! str_in) {\n\t\trfbLog(\"get_ssl_verify_file: no filename\\n\");\n\t\texit(1);\n\t}\n\n\tif (stat(str_in, &sbuf) == 0) {\n\t\t/* assume he knows what he is doing. */\n\t\treturn str_in;\n\t}\n\n\tcdir = get_Cert_dir(NULL, &tmp);\n\tif (! cdir || ! tmp) {\n\t\trfbLog(\"get_ssl_verify_file: invalid cert-dir.\\n\");\n\t\texit(1);\n\t}\n\n\ttfile  = (char *) malloc(strlen(tmp) + 1024);\n\ttfile2 = (char *) malloc(strlen(tmp) + 1024);\n\n\tsprintf(tfile, \"%s/sslverify-tmp-load-%d.crts.XXXXXX\", tmp, getpid());\n\n\tfd = mkstemp(tfile);\n\tif (fd < 0) {\n\t\trfbLog(\"get_ssl_verify_file: %s\\n\", tfile);\n\t\trfbLogPerror(\"mkstemp\");\n\t\texit(1);\n\t}\n\tclose(fd);\n\n\tfile = fopen(tfile, \"w\");\n\tchmod(tfile, 0600);\n\tif (file == NULL) {\n\t\trfbLog(\"get_ssl_verify_file: %s\\n\", tfile);\n\t\trfbLogPerror(\"fopen\");\n\t\texit(1);\n\t}\n\n\tstr = strdup(str_in);\n\tp = strtok(str, \",\");\n\n\twhile (p) {\n\t\tif (!strcmp(p, \"CA\")) {\n\t\t\tsprintf(tfile2, \"%s/CA/cacert.pem\", cdir);\n\t\t\tif (! appendfile(file, tfile2)) {\n\t\t\t\tunlink(tfile);\n\t\t\t\texit(1);\n\t\t\t}\n\t\t\trfbLog(\"sslverify: loaded %s\\n\", tfile2);\n\t\t\tcount++;\n\n\t\t} else if (!strcmp(p, \"clients\")) {\n\t\t\tDIR *dir;\n\t\t\tstruct dirent *dp;\n\n\t\t\tsprintf(tfile2, \"%s/clients\", cdir);\n\t\t\tdir = opendir(tfile2);\n\t\t\tif (! dir) {\n\t\t\t\trfbLog(\"get_ssl_verify_file: %s\\n\", tfile2);\n\t\t\t\trfbLogPerror(\"opendir\");\n\t\t\t\tunlink(tfile);\n\t\t\t\texit(1);\n\t\t\t}\n\t\t\twhile ( (dp = readdir(dir)) != NULL) {\n\t\t\t\tchar *n = dp->d_name;\n\t\t\t\tchar *q = strstr(n, \".crt\");\n\n\t\t\t\tif (! q || strlen(q) != strlen(\".crt\")) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (strlen(n) > 512) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tsprintf(tfile2, \"%s/clients/%s\", cdir, n);\n\t\t\t\tif (! appendfile(file, tfile2)) {\n\t\t\t\t\tunlink(tfile);\n\t\t\t\t\texit(1);\n\t\t\t\t}\n\t\t\t\trfbLog(\"sslverify: loaded %s\\n\",\n\t\t\t\t    tfile2);\n\t\t\t\tcount++;\n\t\t\t}\n\t\t\tclosedir(dir);\n\t\t\t\n\t\t} else {\n\t\t\tif (strlen(p) > 512) {\n\t\t\t\tunlink(tfile);\n\t\t\t\texit(1);\n\t\t\t}\n\t\t\tsprintf(tfile2, \"%s/clients/%s.crt\", cdir, p);\n\t\t\tif (stat(tfile2, &sbuf) != 0) {\n\t\t\t\tsprintf(tfile2, \"%s/clients/%s\", cdir, p);\n\t\t\t}\n\t\t\tif (! appendfile(file, tfile2)) {\n\t\t\t\tunlink(tfile);\n\t\t\t\texit(1);\n\t\t\t}\n\t\t\trfbLog(\"sslverify: loaded %s\\n\", tfile2);\n\t\t\tcount++;\n\t\t}\n\t\tp = strtok(NULL, \",\");\n\t}\n\tfclose(file);\n\tfree(tfile2);\n\tfree(str);\n\n\trfbLog(\"sslverify: using %d client certs in\\n\", count);\n\trfbLog(\"sslverify: %s\\n\", tfile);\n\n\treturn tfile;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"CirculateNotify\\n\");\n#endif\n\t\t\tbreak;\n\t\tcase PropertyNotify:\n#if0"
          ],
          "line": 1857
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"ConfigureRequest\\n\");\n\t\t\tbreak;\n\t\tcase CirculateRequest:\n#if0"
          ],
          "line": 1846
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "add_win",
          "args": [
            "ev.xcreatewindow.window"
          ],
          "line": 1834
        },
        "resolved": true,
        "details": {
          "function_name": "add_win",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/appshare.c",
          "lines": "870-888",
          "snippet": "static void add_win(Window win) {\n\tint idx  = find_win(win);\n\tint free = find_win(None);\n\tif (idx >= 0) {\n\t\tif (appshare_debug) {fprintf(stderr, \"already watching window: 0x%lx\\n\", win); ff();}\n\t\treturn;\n\t}\n\tif (free < 0) {\n\t\tfprintf(stderr, \"ran out of slots for window: 0x%lx\\n\", win); ff();\n\t\treturn;\n\t}\n\n\tif (appshare_debug) {fprintf(stderr, \"watching: 0x%lx at %d\\n\", win, free); ff();}\n\n\twatch[free] = win;\n\tstate[free] = 0;\n\n\twin_select(win, 0);\n}",
          "includes": [
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "extern char *get_xprop(char *prop, Window win);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"x11vnc.h\"\n\nextern char *get_xprop(char *prop, Window win);\n\nstatic void add_win(Window win) {\n\tint idx  = find_win(win);\n\tint free = find_win(None);\n\tif (idx >= 0) {\n\t\tif (appshare_debug) {fprintf(stderr, \"already watching window: 0x%lx\\n\", win); ff();}\n\t\treturn;\n\t}\n\tif (free < 0) {\n\t\tfprintf(stderr, \"ran out of slots for window: 0x%lx\\n\", win); ff();\n\t\treturn;\n\t}\n\n\tif (appshare_debug) {fprintf(stderr, \"watching: 0x%lx at %d\\n\", win, free); ff();}\n\n\twatch[free] = win;\n\tstate[free] = 0;\n\n\twin_select(win, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "find_win",
          "args": [
            "ev.xcreatewindow.window"
          ],
          "line": 1831
        },
        "resolved": true,
        "details": {
          "function_name": "find_win",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/appshare.c",
          "lines": "298-306",
          "snippet": "static int find_win(Window win) {\n\tint i;\n\tfor (i=0; i < WMAX; i++) {\n\t\tif (watch[i] == win) {\n\t\t\treturn i;\n\t\t}\n\t}\n\treturn -1;\n}",
          "includes": [
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [
            "#define WMAX 192"
          ],
          "globals_used": [
            "extern char *get_xprop(char *prop, Window win);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"x11vnc.h\"\n\n#define WMAX 192\n\nextern char *get_xprop(char *prop, Window win);\n\nstatic int find_win(Window win) {\n\tint i;\n\tfor (i=0; i < WMAX; i++) {\n\t\tif (watch[i] == win) {\n\t\t\treturn i;\n\t\t}\n\t}\n\treturn -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unmapped",
          "args": [
            "ev.xmap.window"
          ],
          "line": 1820
        },
        "resolved": true,
        "details": {
          "function_name": "unmapped",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/appshare.c",
          "lines": "1094-1101",
          "snippet": "static void unmapped(Window win) {\n\tint f = find_win(win);\n\tif (f < 0 || win == None) {\n\t\treturn;\n\t}\n\tstop(win);\t\n\tstate[f] = 0;\n}",
          "includes": [
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "extern char *get_xprop(char *prop, Window win);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"x11vnc.h\"\n\nextern char *get_xprop(char *prop, Window win);\n\nstatic void unmapped(Window win) {\n\tint f = find_win(win);\n\tif (f < 0 || win == None) {\n\t\treturn;\n\t}\n\tstop(win);\t\n\tstate[f] = 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"VisibilityUnobscured\\n\""
          ],
          "line": 1806
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"VisibilityPartiallyObscured\\n\""
          ],
          "line": 1805
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"VisibilityFullyObscured\\n\""
          ],
          "line": 1804
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"VisibilityNotify: \""
          ],
          "line": 1802
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XNextEvent",
          "args": [
            "dpy",
            "&ev"
          ],
          "line": 1784
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "handle_shell",
          "args": [],
          "line": 1780
        },
        "resolved": true,
        "details": {
          "function_name": "handle_shell",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/appshare.c",
          "lines": "1681-1725",
          "snippet": "static void handle_shell(void) {\n\tstruct timeval tv;\n\tstatic char lastline[1000];\n\tstatic int first = 1;\n\tfd_set rfds;\n\tint fd0 = fileno(stdin);\n\n\tif (first) {\n\t\tmemset(lastline, 0, sizeof(lastline));\n\t\tfirst = 0;\n\t}\n\n\tFD_ZERO(&rfds);\n\tFD_SET(fd0, &rfds);\n\ttv.tv_sec = 0; \n\ttv.tv_usec = 0; \n\tselect(fd0+1, &rfds, NULL, NULL, &tv);\n\tif (FD_ISSET(fd0, &rfds)) {\n\t\tchar line[1000], line2[1010];\n\t\tif (fgets(line, sizeof(line), stdin) != NULL) {\n\t\t\tchar *str = lblanks(line);\n\t\t\tchar *q = strrchr(str, '\\n');\n\t\t\tif (q) *q = '\\0';\n\t\t\tif (strcmp(str, \"\")) {\n\t\t\t\tif (!strcmp(str, \"!!\")) {\n\t\t\t\t\tsprintf(line, \"%s\", lastline);\n\t\t\t\t\tfprintf(stderr, \"%s\\n\", line);\n\t\t\t\t\tstr = line;\n\t\t\t\t}\n\t\t\t\tif (strstr(str, \"!\") == str) {\n\t\t\t\t\tsystem(str+1);\n\t\t\t\t} else if (!strcmp(str, \"x11vnc\") || !strcmp(str, \"ps\")) {\n\t\t\t\t\tchar *cmd = \"ps -elf | egrep 'PID|x11vnc' | grep -v egrep\";\n\t\t\t\t\tfprintf(stderr, \"%s\\n\", cmd);\n\t\t\t\t\tsystem(cmd);\n\t\t\t\t} else {\n\t\t\t\t\tsprintf(line2, \"cmd=%s\", str);\n\t\t\t\t\tprocess_string(line2);\n\t\t\t\t}\n\t\t\t\tsprintf(lastline, \"%s\", str);\n\t\t\t}\n\t\t}\n\t\tfprintf(stderr, \"\\n%s\", prompt); ff();\n\t}\n}",
          "includes": [
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"x11vnc.h\"\n\nstatic void handle_shell(void) {\n\tstruct timeval tv;\n\tstatic char lastline[1000];\n\tstatic int first = 1;\n\tfd_set rfds;\n\tint fd0 = fileno(stdin);\n\n\tif (first) {\n\t\tmemset(lastline, 0, sizeof(lastline));\n\t\tfirst = 0;\n\t}\n\n\tFD_ZERO(&rfds);\n\tFD_SET(fd0, &rfds);\n\ttv.tv_sec = 0; \n\ttv.tv_usec = 0; \n\tselect(fd0+1, &rfds, NULL, NULL, &tv);\n\tif (FD_ISSET(fd0, &rfds)) {\n\t\tchar line[1000], line2[1010];\n\t\tif (fgets(line, sizeof(line), stdin) != NULL) {\n\t\t\tchar *str = lblanks(line);\n\t\t\tchar *q = strrchr(str, '\\n');\n\t\t\tif (q) *q = '\\0';\n\t\t\tif (strcmp(str, \"\")) {\n\t\t\t\tif (!strcmp(str, \"!!\")) {\n\t\t\t\t\tsprintf(line, \"%s\", lastline);\n\t\t\t\t\tfprintf(stderr, \"%s\\n\", line);\n\t\t\t\t\tstr = line;\n\t\t\t\t}\n\t\t\t\tif (strstr(str, \"!\") == str) {\n\t\t\t\t\tsystem(str+1);\n\t\t\t\t} else if (!strcmp(str, \"x11vnc\") || !strcmp(str, \"ps\")) {\n\t\t\t\t\tchar *cmd = \"ps -elf | egrep 'PID|x11vnc' | grep -v egrep\";\n\t\t\t\t\tfprintf(stderr, \"%s\\n\", cmd);\n\t\t\t\t\tsystem(cmd);\n\t\t\t\t} else {\n\t\t\t\t\tsprintf(line2, \"cmd=%s\", str);\n\t\t\t\t\tprocess_string(line2);\n\t\t\t\t}\n\t\t\t\tsprintf(lastline, \"%s\", str);\n\t\t\t}\n\t\t}\n\t\tfprintf(stderr, \"\\n%s\", prompt); ff();\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "handle_prop_cmd",
          "args": [],
          "line": 1776
        },
        "resolved": true,
        "details": {
          "function_name": "handle_prop_cmd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/appshare.c",
          "lines": "1727-1753",
          "snippet": "static void handle_prop_cmd(void) {\n\tchar *value, *str, *done = \"DONE\";\n\n\tif (cmd_atom == None) {\n\t\treturn;\n\t}\n\n\tvalue = get_xprop(cmd_atom_str, root);\n\tif (value == NULL) {\n\t\treturn;\n\t}\n\n\tstr = lblanks(value);\n\tif (!strcmp(str, done)) {\n\t\tfree(value);\n\t\treturn;\n\t}\n\tif (strstr(str, \"cmd=quit\") == str || strstr(str, \"\\ncmd=quit\")) {\n\t\tset_xprop(cmd_atom_str, root, done);\n\t\tappshare_cleanup(0);\n\t}\n\n\tprocess_string(str);\n\n\tfree(value);\n\tset_xprop(cmd_atom_str, root, done);\n}",
          "includes": [
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "extern int set_xprop(char *prop, Window win, char *value);",
            "extern void set_env(char *name, char *value);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"x11vnc.h\"\n\nextern int set_xprop(char *prop, Window win, char *value);\nextern void set_env(char *name, char *value);\n\nstatic void handle_prop_cmd(void) {\n\tchar *value, *str, *done = \"DONE\";\n\n\tif (cmd_atom == None) {\n\t\treturn;\n\t}\n\n\tvalue = get_xprop(cmd_atom_str, root);\n\tif (value == NULL) {\n\t\treturn;\n\t}\n\n\tstr = lblanks(value);\n\tif (!strcmp(str, done)) {\n\t\tfree(value);\n\t\treturn;\n\t}\n\tif (strstr(str, \"cmd=quit\") == str || strstr(str, \"\\ncmd=quit\")) {\n\t\tset_xprop(cmd_atom_str, root, done);\n\t\tappshare_cleanup(0);\n\t}\n\n\tprocess_string(str);\n\n\tfree(value);\n\tset_xprop(cmd_atom_str, root, done);\n}"
        }
      },
      {
        "call_info": {
          "callee": "update",
          "args": [],
          "line": 1774
        },
        "resolved": true,
        "details": {
          "function_name": "update",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/appshare.c",
          "lines": "1559-1613",
          "snippet": "static void update(void) {\n\tint i, app_ok = 0;\n\tif (last_event_type != PropertyNotify) {\n\t\tif (appshare_debug) fprintf(stderr, \"\\nupdate ...\\n\");\n\t} else if (appshare_debug > 1) {\n\t\tfprintf(stderr, \"update ... propertynotify\\n\");\n\t}\n\tif (!check_control()) {\n\t\treturn;\n\t}\n\tfor (i=0; i < WMAX; i++) {\n\t\tWindow win = watch[i];\n\t\tif (win == None) {\n\t\t\tcontinue;\n\t\t}\n\t\tif (!win_attr(win)) {\n\t\t\tdestroy_win(win);\n\t\t\tcontinue;\n\t\t}\n\t\tif (find_app(win) >= 0) {\n\t\t\tapp_ok++;\n\t\t}\n\t\tif (state[i] == 0) {\n\t\t\tif (attr.map_state == IsViewable) {\n\t\t\t\tif (skip_menus) {\n\t\t\t\t\tWindow inside = check_inside(win);\n\t\t\t\t\tif (inside != None) {\n\t\t\t\t\t\tif (appshare_debug) {fprintf(stderr, \"skip_menus: window 0x%lx is inside of 0x%lx, not tracking it.\\n\", win, inside); ff();}\n\t\t\t\t\t\tdelete_win(win);\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tlaunch(win);\n\t\t\t\tstate[i] = 1;\n\t\t\t}\n\t\t} else if (state[i] == 1) {\n\t\t\tif (attr.map_state != IsViewable) {\n\t\t\t\tstop(win);\n\t\t\t\tstate[i] = 0;\n\t\t\t}\n\t\t}\n\t}\n\tif (exit_no_app_win && !app_ok) {\n\t\tfor (i=0; i < AMAX; i++) {\n\t\t\tif (apps[i] != None) {\n\t\t\t\tfprintf(stdout, \"main application window is gone: 0x%lx\\n\", apps[i]);\n\t\t\t}\n\t\t}\n\t\tff();\n\t\tappshare_cleanup(0);\n\t}\n\tif (last_event_type != PropertyNotify) {\n\t\tif (appshare_debug) {fprintf(stderr, \"update done.\\n\"); ff();}\n\t}\n}",
          "includes": [
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [
            "#define AMAX 32",
            "#define WMAX 192"
          ],
          "globals_used": [
            "extern char *get_xprop(char *prop, Window win);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"x11vnc.h\"\n\n#define AMAX 32\n#define WMAX 192\n\nextern char *get_xprop(char *prop, Window win);\n\nstatic void update(void) {\n\tint i, app_ok = 0;\n\tif (last_event_type != PropertyNotify) {\n\t\tif (appshare_debug) fprintf(stderr, \"\\nupdate ...\\n\");\n\t} else if (appshare_debug > 1) {\n\t\tfprintf(stderr, \"update ... propertynotify\\n\");\n\t}\n\tif (!check_control()) {\n\t\treturn;\n\t}\n\tfor (i=0; i < WMAX; i++) {\n\t\tWindow win = watch[i];\n\t\tif (win == None) {\n\t\t\tcontinue;\n\t\t}\n\t\tif (!win_attr(win)) {\n\t\t\tdestroy_win(win);\n\t\t\tcontinue;\n\t\t}\n\t\tif (find_app(win) >= 0) {\n\t\t\tapp_ok++;\n\t\t}\n\t\tif (state[i] == 0) {\n\t\t\tif (attr.map_state == IsViewable) {\n\t\t\t\tif (skip_menus) {\n\t\t\t\t\tWindow inside = check_inside(win);\n\t\t\t\t\tif (inside != None) {\n\t\t\t\t\t\tif (appshare_debug) {fprintf(stderr, \"skip_menus: window 0x%lx is inside of 0x%lx, not tracking it.\\n\", win, inside); ff();}\n\t\t\t\t\t\tdelete_win(win);\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tlaunch(win);\n\t\t\t\tstate[i] = 1;\n\t\t\t}\n\t\t} else if (state[i] == 1) {\n\t\t\tif (attr.map_state != IsViewable) {\n\t\t\t\tstop(win);\n\t\t\t\tstate[i] = 0;\n\t\t\t}\n\t\t}\n\t}\n\tif (exit_no_app_win && !app_ok) {\n\t\tfor (i=0; i < AMAX; i++) {\n\t\t\tif (apps[i] != None) {\n\t\t\t\tfprintf(stdout, \"main application window is gone: 0x%lx\\n\", apps[i]);\n\t\t\t}\n\t\t}\n\t\tff();\n\t\tappshare_cleanup(0);\n\t}\n\tif (last_event_type != PropertyNotify) {\n\t\tif (appshare_debug) {fprintf(stderr, \"update done.\\n\"); ff();}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "XEventsQueued",
          "args": [
            "dpy",
            "QueuedAlready"
          ],
          "line": 1773
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ff",
          "args": [],
          "line": 1767
        },
        "resolved": true,
        "details": {
          "function_name": "ff",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/appshare.c",
          "lines": "293-296",
          "snippet": "static void ff(void) {\n\tfflush(stdout);\n\tfflush(stderr);\n}",
          "includes": [
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"x11vnc.h\"\n\nstatic void ff(void) {\n\tfflush(stdout);\n\tfflush(stderr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"\\n%s\"",
            "prompt"
          ],
          "line": 1767
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"\\n\\n\""
          ],
          "line": 1765
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dnow",
          "args": [],
          "line": 1760
        },
        "resolved": true,
        "details": {
          "function_name": "dnowx",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/util.c",
          "lines": "439-441",
          "snippet": "double dnowx(void) {\n\treturn dnow() - x11vnc_start;\n}",
          "includes": [
            "#include \"connections.h\"",
            "#include \"unixpw.h\"",
            "#include \"win_utils.h\"",
            "#include \"cleanup.h\"",
            "#include \"x11vnc.h\"",
            "#include <stdlib.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "double dnow(void);",
            "double dnowx(void);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"connections.h\"\n#include \"unixpw.h\"\n#include \"win_utils.h\"\n#include \"cleanup.h\"\n#include \"x11vnc.h\"\n#include <stdlib.h>\n\ndouble dnow(void);\ndouble dnowx(void);\n\ndouble dnowx(void) {\n\treturn dnow() - x11vnc_start;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"x11vnc.h\"\n\n#define PREFIX if(appshare_debug) fprintf(stderr, \"  %8.2f  0x%08lx : \", dnow() - start, ev.xany.window);\n\nextern char *get_xprop(char *prop, Window win);\nextern double dnow(void);\n\nstatic void monitor(void) {\n#if !NO_X11\n\tXEvent ev;\n\tdouble start = dnow();\n\tint got_prop_cmd = 0;\n\n\tif (shell) {\n\t\tupdate();\n\t\tfprintf(stderr, \"\\n\\n\");\n\t\tprocess_string(\"cmd=help\");\n\t\tfprintf(stderr, \"\\n%s\", prompt); ff();\n\t}\n\n\twhile (1) {\n\t\tint t;\n\n\t\tif (XEventsQueued(dpy, QueuedAlready) == 0) {\n\t\t\tupdate();\n\t\t\tif (got_prop_cmd) {\n\t\t\t\thandle_prop_cmd();\n\t\t\t}\n\t\t\tgot_prop_cmd = 0;\n\t\t\tif (shell) {\n\t\t\t\thandle_shell();\n\t\t\t}\n\t\t}\n\n\t\tXNextEvent(dpy, &ev);\n\n\t\tlast_event_type = ev.type;\n\n\t\tswitch (ev.type) {\n\t\tcase Expose:\n\t\t\tPREFIX\n\t\t\tif(appshare_debug) fprintf(stderr, \"Expose %04dx%04d+%04d+%04d\\n\", ev.xexpose.width, ev.xexpose.height, ev.xexpose.x, ev.xexpose.y);\n\t\t\tbreak;\n\t\tcase ConfigureNotify:\n#if 0\n\t\t\tPREFIX\n\t\t\tif(appshare_debug) fprintf(stderr, \"ConfigureNotify %04dx%04d+%04d+%04d  above: 0x%lx\\n\", ev.xconfigure.width, ev.xconfigure.height, ev.xconfigure.x, ev.xconfigure.y, ev.xconfigure.above);\n#endif\n\t\t\tbreak;\n\t\tcase VisibilityNotify:\n\t\t\tPREFIX\n\t\t\tif (appshare_debug) {\n\t\t\tfprintf(stderr, \"VisibilityNotify: \");\n\t\t\tt = ev.xvisibility.state;\n\t\t\tif (t == VisibilityFullyObscured)     fprintf(stderr, \"VisibilityFullyObscured\\n\");\n\t\t\tif (t == VisibilityPartiallyObscured) fprintf(stderr, \"VisibilityPartiallyObscured\\n\");\n\t\t\tif (t == VisibilityUnobscured)        fprintf(stderr, \"VisibilityUnobscured\\n\");\n\t\t\t}\n\t\t\tbreak;\n\t\tcase MapNotify:\n\t\t\tPREFIX\n\t\t\tif(appshare_debug) fprintf(stderr, \"MapNotify      win: 0x%lx\\n\", ev.xmap.window);\n\t\t\tif (ours(ev.xmap.window)) {\n\t\t\t\tmapped(ev.xmap.window);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase UnmapNotify:\n\t\t\tPREFIX\n\t\t\tif(appshare_debug) fprintf(stderr, \"UnmapNotify    win: 0x%lx\\n\", ev.xmap.window);\n\t\t\tif (ours(ev.xmap.window)) {\n\t\t\t\tunmapped(ev.xmap.window);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase MapRequest:\n\t\t\tPREFIX\n\t\t\tif(appshare_debug) fprintf(stderr, \"MapRequest\\n\");\n\t\t\tbreak;\n\t\tcase CreateNotify:\n\t\t\tPREFIX\n\t\t\tif(appshare_debug) fprintf(stderr, \"CreateNotify parent: 0x%lx  win: 0x%lx\\n\", ev.xcreatewindow.parent, ev.xcreatewindow.window);\n\t\t\tif (ev.xcreatewindow.parent == root && ours(ev.xcreatewindow.window)) {\n\t\t\t\tif (find_win(ev.xcreatewindow.window) >= 0) {\n\t\t\t\t\tdestroy_win(ev.xcreatewindow.window);\n\t\t\t\t}\n\t\t\t\tadd_win(ev.xcreatewindow.window);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase DestroyNotify:\n\t\t\tPREFIX\n\t\t\tif(appshare_debug) fprintf(stderr, \"DestroyNotify  win: 0x%lx\\n\", ev.xdestroywindow.window);\n\t\t\tif (ours(ev.xdestroywindow.window)) {\n\t\t\t\tdestroy_win(ev.xdestroywindow.window);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase ConfigureRequest:\n\t\t\tPREFIX\n\t\t\tif(appshare_debug) fprintf(stderr, \"ConfigureRequest\\n\");\n\t\t\tbreak;\n\t\tcase CirculateRequest:\n#if 0\n\t\t\tPREFIX\n\t\t\tif(appshare_debug) fprintf(stderr, \"CirculateRequest parent: 0x%lx  win: 0x%lx\\n\", ev.xcirculaterequest.parent, ev.xcirculaterequest.window);\n#endif\n\t\t\tbreak;\n\t\tcase CirculateNotify:\n#if 0\n\t\t\tPREFIX\n\t\t\tif(appshare_debug) fprintf(stderr, \"CirculateNotify\\n\");\n#endif\n\t\t\tbreak;\n\t\tcase PropertyNotify:\n#if 0\n\t\t\tPREFIX\n\t\t\tif(appshare_debug) fprintf(stderr, \"PropertyNotify\\n\");\n#endif\n\t\t\tif (cmd_atom != None && ev.xproperty.atom == cmd_atom) {\n\t\t\t\tgot_prop_cmd++;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase ReparentNotify:\n\t\t\tPREFIX\n\t\t\tif(appshare_debug) fprintf(stderr, \"ReparentNotify parent: 0x%lx  win: 0x%lx\\n\", ev.xreparent.parent, ev.xreparent.window);\n\t\t\tif (ours(ev.xreparent.window)) {\n\t\t\t\tif (ours(ev.xreparent.parent)) {\n\t\t\t\t\tdestroy_win(ev.xreparent.window);\n\t\t\t\t} else if (ev.xreparent.parent == root) {\n\t\t\t\t\t/* ??? */\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tPREFIX\n\t\t\tif(appshare_debug) fprintf(stderr, \"Unknown: %d\\n\", ev.type);\n\t\t\tbreak;\n\t\t}\n\t}\n#endif\n}"
  },
  {
    "function_name": "handle_prop_cmd",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/appshare.c",
    "lines": "1727-1753",
    "snippet": "static void handle_prop_cmd(void) {\n\tchar *value, *str, *done = \"DONE\";\n\n\tif (cmd_atom == None) {\n\t\treturn;\n\t}\n\n\tvalue = get_xprop(cmd_atom_str, root);\n\tif (value == NULL) {\n\t\treturn;\n\t}\n\n\tstr = lblanks(value);\n\tif (!strcmp(str, done)) {\n\t\tfree(value);\n\t\treturn;\n\t}\n\tif (strstr(str, \"cmd=quit\") == str || strstr(str, \"\\ncmd=quit\")) {\n\t\tset_xprop(cmd_atom_str, root, done);\n\t\tappshare_cleanup(0);\n\t}\n\n\tprocess_string(str);\n\n\tfree(value);\n\tset_xprop(cmd_atom_str, root, done);\n}",
    "includes": [
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "extern int set_xprop(char *prop, Window win, char *value);",
      "extern void set_env(char *name, char *value);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "set_xprop",
          "args": [
            "cmd_atom_str",
            "root",
            "done"
          ],
          "line": 1752
        },
        "resolved": true,
        "details": {
          "function_name": "set_xprop",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/connections.c",
          "lines": "3524-3549",
          "snippet": "int set_xprop(char *prop, Window win, char *value) {\n\tint rc = -1;\n#if !NO_X11\n\tAtom aprop;\n\n\tRAWFB_RET(rc)\n\n\tif (!prop || !value) {\n\t\treturn rc;\n\t}\n\tif (win == None) {\n\t\twin = rootwin;\n\t}\n\taprop = XInternAtom(dpy, prop, False);\n\tif (aprop == None) {\n\t\treturn rc;\n\t}\n\trc = XChangeProperty(dpy, win, aprop, XA_STRING, 8,\n\t    PropModeReplace, (unsigned char *)value, strlen(value));\n\treturn rc;\n#else\n\tRAWFB_RET(rc)\n\tif (!prop || !win || !value) {}\n\treturn rc;\n#endif\t/* NO_X11 */\n}",
          "includes": [
            "#include \"xi2_devices.h\"",
            "#include \"xrandr.h\"",
            "#include \"pointer.h\"",
            "#include \"userinput.h\"",
            "#include \"macosxCG.h\"",
            "#include \"macosx.h\"",
            "#include \"win_utils.h\"",
            "#include \"xevents.h\"",
            "#include \"xwrappers.h\"",
            "#include \"sslhelper.h\"",
            "#include \"sslcmds.h\"",
            "#include \"scan.h\"",
            "#include \"user.h\"",
            "#include \"unixpw.h\"",
            "#include \"screen.h\"",
            "#include \"rates.h\"",
            "#include \"solid.h\"",
            "#include \"gui.h\"",
            "#include \"cleanup.h\"",
            "#include \"keyboard.h\"",
            "#include \"remote.h\"",
            "#include \"inet.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "char *get_xprop(char *prop, Window win);",
            "int set_xprop(char *prop, Window win, char *value);",
            "static int action_match(char *action, int rc);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xi2_devices.h\"\n#include \"xrandr.h\"\n#include \"pointer.h\"\n#include \"userinput.h\"\n#include \"macosxCG.h\"\n#include \"macosx.h\"\n#include \"win_utils.h\"\n#include \"xevents.h\"\n#include \"xwrappers.h\"\n#include \"sslhelper.h\"\n#include \"sslcmds.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"unixpw.h\"\n#include \"screen.h\"\n#include \"rates.h\"\n#include \"solid.h\"\n#include \"gui.h\"\n#include \"cleanup.h\"\n#include \"keyboard.h\"\n#include \"remote.h\"\n#include \"inet.h\"\n#include \"x11vnc.h\"\n\nchar *get_xprop(char *prop, Window win);\nint set_xprop(char *prop, Window win, char *value);\nstatic int action_match(char *action, int rc);\n\nint set_xprop(char *prop, Window win, char *value) {\n\tint rc = -1;\n#if !NO_X11\n\tAtom aprop;\n\n\tRAWFB_RET(rc)\n\n\tif (!prop || !value) {\n\t\treturn rc;\n\t}\n\tif (win == None) {\n\t\twin = rootwin;\n\t}\n\taprop = XInternAtom(dpy, prop, False);\n\tif (aprop == None) {\n\t\treturn rc;\n\t}\n\trc = XChangeProperty(dpy, win, aprop, XA_STRING, 8,\n\t    PropModeReplace, (unsigned char *)value, strlen(value));\n\treturn rc;\n#else\n\tRAWFB_RET(rc)\n\tif (!prop || !win || !value) {}\n\treturn rc;\n#endif\t/* NO_X11 */\n}"
        }
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "value"
          ],
          "line": 1751
        },
        "resolved": true,
        "details": {
          "function_name": "free_rect",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/userinput.c",
          "lines": "6200-6247",
          "snippet": "int free_rect(int idx) {\n\tint n, ok = 0;\n\tsraRegionPtr r1, r2;\n\tint x, y, w, h;\n\n\tif (idx < 0 || idx >= cache_list_num) {\nif (0) fprintf(stderr, \"free_rect: bad index: %d\\n\", idx);\n\t\tclean_up_exit(1);\n\t}\n\n\tx = cache_list[idx].bs_x;\n\ty = cache_list[idx].bs_y;\n\tw = cache_list[idx].bs_w;\n\th = cache_list[idx].bs_h;\n\n\tif (x < 0) {\n\t\tCLEAR(idx);\nif (dnow() > last_client + 5 && ncdb) fprintf(stderr, \"free_rect: already bs_x invalidated: %d bs_x: %d\\n\", idx, x);\n\t\treturn 1;\n\t}\n\n\tr2 = sraRgnCreateRect(x, y, x+w, y+h);\n\n\tn = get_bs_n(y);\n\tif (n >= 0) {\n\t\tr1 = rect_reg[n];\n\t\tsraRgnOr(r1, r2);\n\t\tok = 1;\n\t}\n\n\tif (zero_rects) {\n\t\tsraRgnOr(zero_rects, r2);\n\t\tx = cache_list[idx].su_x;\n\t\ty = cache_list[idx].su_y;\n\t\tw = cache_list[idx].su_w;\n\t\th = cache_list[idx].su_h;\n\t\tif (x >= 0) {\n\t\t\tsraRgnDestroy(r2);\n\t\t\tr2 = sraRgnCreateRect(x, y, x+w, y+h);\n\t\t\tsraRgnOr(zero_rects, r2);\n\t\t}\n\t}\n\tsraRgnDestroy(r2);\n\n\tCLEAR(idx);\nif (! ok && ncdb) fprintf(stderr, \"**** free_rect: not-found %d\\n\", idx);\n\treturn ok;\n}",
          "includes": [
            "#include \"default8x16.h\"",
            "#include \"connections.h\"",
            "#include \"screen.h\"",
            "#include \"cursor.h\"",
            "#include \"macosxCGS.h\"",
            "#include \"macosx.h\"",
            "#include \"unixpw.h\"",
            "#include \"8to24.h\"",
            "#include \"xrandr.h\"",
            "#include \"solid.h\"",
            "#include \"keyboard.h\"",
            "#include \"rates.h\"",
            "#include \"pointer.h\"",
            "#include \"cleanup.h\"",
            "#include \"scan.h\"",
            "#include \"user.h\"",
            "#include \"xevents.h\"",
            "#include \"win_utils.h\"",
            "#include \"xinerama.h\"",
            "#include \"xrecord.h\"",
            "#include \"xdamage.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void mark_for_xdamage(int x, int y, int w, int h);",
            "void set_xdamage_mark(int x, int y, int w, int h);",
            "int find_rect(int idx, int x, int y, int w, int h);",
            "winattr_t *cache_list;",
            "int clipped(int idx);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"default8x16.h\"\n#include \"connections.h\"\n#include \"screen.h\"\n#include \"cursor.h\"\n#include \"macosxCGS.h\"\n#include \"macosx.h\"\n#include \"unixpw.h\"\n#include \"8to24.h\"\n#include \"xrandr.h\"\n#include \"solid.h\"\n#include \"keyboard.h\"\n#include \"rates.h\"\n#include \"pointer.h\"\n#include \"cleanup.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"xevents.h\"\n#include \"win_utils.h\"\n#include \"xinerama.h\"\n#include \"xrecord.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nvoid mark_for_xdamage(int x, int y, int w, int h);\nvoid set_xdamage_mark(int x, int y, int w, int h);\nint find_rect(int idx, int x, int y, int w, int h);\nwinattr_t *cache_list;\nint clipped(int idx);\n\nint free_rect(int idx) {\n\tint n, ok = 0;\n\tsraRegionPtr r1, r2;\n\tint x, y, w, h;\n\n\tif (idx < 0 || idx >= cache_list_num) {\nif (0) fprintf(stderr, \"free_rect: bad index: %d\\n\", idx);\n\t\tclean_up_exit(1);\n\t}\n\n\tx = cache_list[idx].bs_x;\n\ty = cache_list[idx].bs_y;\n\tw = cache_list[idx].bs_w;\n\th = cache_list[idx].bs_h;\n\n\tif (x < 0) {\n\t\tCLEAR(idx);\nif (dnow() > last_client + 5 && ncdb) fprintf(stderr, \"free_rect: already bs_x invalidated: %d bs_x: %d\\n\", idx, x);\n\t\treturn 1;\n\t}\n\n\tr2 = sraRgnCreateRect(x, y, x+w, y+h);\n\n\tn = get_bs_n(y);\n\tif (n >= 0) {\n\t\tr1 = rect_reg[n];\n\t\tsraRgnOr(r1, r2);\n\t\tok = 1;\n\t}\n\n\tif (zero_rects) {\n\t\tsraRgnOr(zero_rects, r2);\n\t\tx = cache_list[idx].su_x;\n\t\ty = cache_list[idx].su_y;\n\t\tw = cache_list[idx].su_w;\n\t\th = cache_list[idx].su_h;\n\t\tif (x >= 0) {\n\t\t\tsraRgnDestroy(r2);\n\t\t\tr2 = sraRgnCreateRect(x, y, x+w, y+h);\n\t\t\tsraRgnOr(zero_rects, r2);\n\t\t}\n\t}\n\tsraRgnDestroy(r2);\n\n\tCLEAR(idx);\nif (! ok && ncdb) fprintf(stderr, \"**** free_rect: not-found %d\\n\", idx);\n\treturn ok;\n}"
        }
      },
      {
        "call_info": {
          "callee": "process_string",
          "args": [
            "str"
          ],
          "line": 1749
        },
        "resolved": true,
        "details": {
          "function_name": "process_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/appshare.c",
          "lines": "1656-1679",
          "snippet": "static void process_string(char *str) {\n\tFILE *f;\n\tchar *file;\n\tif (trackdir) {\n\t\tsprintf(tracktmp, \"%s/0xprop.cmd\", trackdir);\n\t\tfile = strdup(tracktmp);\n\t} else {\n\t\tchar tmp[] = \"/tmp/x11vnc-appshare.cmd.XXXXXX\";\n\t\tint fd = mkstemp(tmp);\n\t\tif (fd < 0) {\n\t\t\treturn;\n\t\t}\n\t\tfile = strdup(tmp);\n\t\tclose(fd);\n\t}\n\tf = fopen(file, \"w\");\n\tif (f) {\n\t\tfprintf(f, \"%s\", str);\n\t\tfclose(f);\n\t\tprocess_control(file, 0);\n\t}\n\tunlink(file);\n\tfree(file);\n}",
          "includes": [
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"x11vnc.h\"\n\nstatic void process_string(char *str) {\n\tFILE *f;\n\tchar *file;\n\tif (trackdir) {\n\t\tsprintf(tracktmp, \"%s/0xprop.cmd\", trackdir);\n\t\tfile = strdup(tracktmp);\n\t} else {\n\t\tchar tmp[] = \"/tmp/x11vnc-appshare.cmd.XXXXXX\";\n\t\tint fd = mkstemp(tmp);\n\t\tif (fd < 0) {\n\t\t\treturn;\n\t\t}\n\t\tfile = strdup(tmp);\n\t\tclose(fd);\n\t}\n\tf = fopen(file, \"w\");\n\tif (f) {\n\t\tfprintf(f, \"%s\", str);\n\t\tfclose(f);\n\t\tprocess_control(file, 0);\n\t}\n\tunlink(file);\n\tfree(file);\n}"
        }
      },
      {
        "call_info": {
          "callee": "appshare_cleanup",
          "args": [
            "0"
          ],
          "line": 1746
        },
        "resolved": true,
        "details": {
          "function_name": "appshare_cleanup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/appshare.c",
          "lines": "630-688",
          "snippet": "static void appshare_cleanup(int s) {\n\tint i;\n\tif (s) {}\n\n\tif (use_forever) {\n\t\t/* launch this backup in case they kill -9 us before we terminate everything */\n\t\tchar cmd[1000];\n\t\tsprintf(cmd, \"(sleep 3; pkill -TERM -f '%s') &\", unique_tag);\n\t\tif (appshare_debug) fprintf(stderr, \"%s\\n\", cmd);\n\t\tsystem(cmd);\n\t}\n\n\tfor (i=0; i < WMAX; i++) {\n\t\tif (watch[i] != None) {\n\t\t\tstop(watch[i]);\n\t\t}\n\t}\n\n\tif (trackdir) {\n\t\tDIR *dir = opendir(trackdir);\n\t\tif (dir) {\n\t\t\tstruct dirent *dp;\n\t\t\twhile ( (dp = readdir(dir)) != NULL) {\n\t\t\t\tchar *name = dp->d_name;\n\t\t\t\tif (!strcmp(name, \".\") || !strcmp(name, \"..\")) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (strstr(name, \"0x\") != name) {\n\t\t\t\t\tfprintf(stderr, \"skipping: %s\\n\", name);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (!appshare_debug) {\n\t\t\t\t\tfprintf(stderr, \"removing: %s\\n\", name);\n\t\t\t\t\tsprintf(tracktmp, \"%s/%s\", trackdir, name);\n\t\t\t\t\tunlink(tracktmp);\n\t\t\t\t} else {\n\t\t\t\t\tif (appshare_debug) fprintf(stderr, \"keeping:  %s\\n\", name);\n\t\t\t\t}\n\t\t\t}\n\t\t\tclosedir(dir);\n\t\t}\n\t\tif (!appshare_debug) {\n\t\t\tif (strstr(trackdir, trackpre) == trackdir) {\n\t\t\t\tif (appshare_debug) fprintf(stderr, \"removing: %s\\n\", trackdir);\n\t\t\t\trmdir(trackdir);\n\t\t\t}\n\t\t}\n\t\tff();\n\t}\n\n\tkill_helper_pid();\n\t\t\t\n#if !NO_X11\n\tXCloseDisplay(dpy);\n#endif\n\tfprintf(stdout, \"done.\\n\");\n\tff();\n\texit(0);\n}",
          "includes": [
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [
            "#define WMAX 192"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"x11vnc.h\"\n\n#define WMAX 192\n\nstatic void appshare_cleanup(int s) {\n\tint i;\n\tif (s) {}\n\n\tif (use_forever) {\n\t\t/* launch this backup in case they kill -9 us before we terminate everything */\n\t\tchar cmd[1000];\n\t\tsprintf(cmd, \"(sleep 3; pkill -TERM -f '%s') &\", unique_tag);\n\t\tif (appshare_debug) fprintf(stderr, \"%s\\n\", cmd);\n\t\tsystem(cmd);\n\t}\n\n\tfor (i=0; i < WMAX; i++) {\n\t\tif (watch[i] != None) {\n\t\t\tstop(watch[i]);\n\t\t}\n\t}\n\n\tif (trackdir) {\n\t\tDIR *dir = opendir(trackdir);\n\t\tif (dir) {\n\t\t\tstruct dirent *dp;\n\t\t\twhile ( (dp = readdir(dir)) != NULL) {\n\t\t\t\tchar *name = dp->d_name;\n\t\t\t\tif (!strcmp(name, \".\") || !strcmp(name, \"..\")) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (strstr(name, \"0x\") != name) {\n\t\t\t\t\tfprintf(stderr, \"skipping: %s\\n\", name);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (!appshare_debug) {\n\t\t\t\t\tfprintf(stderr, \"removing: %s\\n\", name);\n\t\t\t\t\tsprintf(tracktmp, \"%s/%s\", trackdir, name);\n\t\t\t\t\tunlink(tracktmp);\n\t\t\t\t} else {\n\t\t\t\t\tif (appshare_debug) fprintf(stderr, \"keeping:  %s\\n\", name);\n\t\t\t\t}\n\t\t\t}\n\t\t\tclosedir(dir);\n\t\t}\n\t\tif (!appshare_debug) {\n\t\t\tif (strstr(trackdir, trackpre) == trackdir) {\n\t\t\t\tif (appshare_debug) fprintf(stderr, \"removing: %s\\n\", trackdir);\n\t\t\t\trmdir(trackdir);\n\t\t\t}\n\t\t}\n\t\tff();\n\t}\n\n\tkill_helper_pid();\n\t\t\t\n#if !NO_X11\n\tXCloseDisplay(dpy);\n#endif\n\tfprintf(stdout, \"done.\\n\");\n\tff();\n\texit(0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "str",
            "\"\\ncmd=quit\""
          ],
          "line": 1744
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "str",
            "\"cmd=quit\""
          ],
          "line": 1744
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "str",
            "done"
          ],
          "line": 1740
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lblanks",
          "args": [
            "value"
          ],
          "line": 1739
        },
        "resolved": true,
        "details": {
          "function_name": "lblanks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/util.c",
          "lines": "160-169",
          "snippet": "char *lblanks(char *str) {\n\tchar *p = str;\n\twhile (*p != '\\0') {\n\t\tif (! isspace((unsigned char) (*p))) {\n\t\t\tbreak;\n\t\t}\n\t\tp++;\n\t}\n\treturn p;\n}",
          "includes": [
            "#include \"connections.h\"",
            "#include \"unixpw.h\"",
            "#include \"win_utils.h\"",
            "#include \"cleanup.h\"",
            "#include \"x11vnc.h\"",
            "#include <stdlib.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void lowercase(char *str);",
            "void uppercase(char *str);",
            "char *lblanks(char *str);",
            "void strzero(char *str);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"connections.h\"\n#include \"unixpw.h\"\n#include \"win_utils.h\"\n#include \"cleanup.h\"\n#include \"x11vnc.h\"\n#include <stdlib.h>\n\nvoid lowercase(char *str);\nvoid uppercase(char *str);\nchar *lblanks(char *str);\nvoid strzero(char *str);\n\nchar *lblanks(char *str) {\n\tchar *p = str;\n\twhile (*p != '\\0') {\n\t\tif (! isspace((unsigned char) (*p))) {\n\t\t\tbreak;\n\t\t}\n\t\tp++;\n\t}\n\treturn p;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_xprop",
          "args": [
            "cmd_atom_str",
            "root"
          ],
          "line": 1734
        },
        "resolved": true,
        "details": {
          "function_name": "get_xprop",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/connections.c",
          "lines": "3551-3605",
          "snippet": "char *get_xprop(char *prop, Window win) {\n#if NO_X11\n\tRAWFB_RET(NULL)\n\tif (!prop || !win) {}\n\treturn NULL;\n#else\n\tAtom type, aprop;\n\tint format, slen, dlen;\n\tunsigned long nitems = 0, bytes_after = 0;\n\tunsigned char* data = NULL;\n\tchar get_str[VNC_CONNECT_MAX+1];\n\n\tRAWFB_RET(NULL)\n\n\tif (prop == NULL || !strcmp(prop, \"\")) {\n\t\treturn NULL;\n\t}\n\tif (win == None) {\n\t\twin = rootwin;\n\t}\n\taprop = XInternAtom(dpy, prop, True);\n\tif (aprop == None) {\n\t\treturn NULL;\n\t}\n\n\tget_str[0] = '\\0';\n\tslen = 0;\n\n\t/* read the property value into get_str: */\n\tdo {\n\t\tif (XGetWindowProperty(dpy, win, aprop, nitems/4,\n\t\t    VNC_CONNECT_MAX/16, False, AnyPropertyType, &type,\n\t\t    &format, &nitems, &bytes_after, &data) == Success) {\n\n\t\t\tdlen = nitems * (format/8);\n\t\t\tif (slen + dlen > VNC_CONNECT_MAX) {\n\t\t\t\t/* too big */\n\t\t\t\trfbLog(\"get_xprop: warning: truncating large '%s'\"\n\t\t\t\t   \" string > %d bytes.\\n\", prop, VNC_CONNECT_MAX);\n\t\t\t\tXFree_wr(data);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tmemcpy(get_str+slen, data, dlen);\n\t\t\tslen += dlen;\n\t\t\tget_str[slen] = '\\0';\n\t\t\tXFree_wr(data);\n\t\t}\n\t} while (bytes_after > 0);\n\n\tget_str[VNC_CONNECT_MAX] = '\\0';\n\trfbLog(\"get_prop: read: '%s' = '%s'\\n\", prop, get_str);\n\n\treturn strdup(get_str);\n#endif\t/* NO_X11 */\n}",
          "includes": [
            "#include \"xi2_devices.h\"",
            "#include \"xrandr.h\"",
            "#include \"pointer.h\"",
            "#include \"userinput.h\"",
            "#include \"macosxCG.h\"",
            "#include \"macosx.h\"",
            "#include \"win_utils.h\"",
            "#include \"xevents.h\"",
            "#include \"xwrappers.h\"",
            "#include \"sslhelper.h\"",
            "#include \"sslcmds.h\"",
            "#include \"scan.h\"",
            "#include \"user.h\"",
            "#include \"unixpw.h\"",
            "#include \"screen.h\"",
            "#include \"rates.h\"",
            "#include \"solid.h\"",
            "#include \"gui.h\"",
            "#include \"cleanup.h\"",
            "#include \"keyboard.h\"",
            "#include \"remote.h\"",
            "#include \"inet.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int new_fb_size_clients(rfbScreenInfoPtr s);",
            "char *get_xprop(char *prop, Window win);",
            "int set_xprop(char *prop, Window win, char *value);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xi2_devices.h\"\n#include \"xrandr.h\"\n#include \"pointer.h\"\n#include \"userinput.h\"\n#include \"macosxCG.h\"\n#include \"macosx.h\"\n#include \"win_utils.h\"\n#include \"xevents.h\"\n#include \"xwrappers.h\"\n#include \"sslhelper.h\"\n#include \"sslcmds.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"unixpw.h\"\n#include \"screen.h\"\n#include \"rates.h\"\n#include \"solid.h\"\n#include \"gui.h\"\n#include \"cleanup.h\"\n#include \"keyboard.h\"\n#include \"remote.h\"\n#include \"inet.h\"\n#include \"x11vnc.h\"\n\nint new_fb_size_clients(rfbScreenInfoPtr s);\nchar *get_xprop(char *prop, Window win);\nint set_xprop(char *prop, Window win, char *value);\n\nchar *get_xprop(char *prop, Window win) {\n#if NO_X11\n\tRAWFB_RET(NULL)\n\tif (!prop || !win) {}\n\treturn NULL;\n#else\n\tAtom type, aprop;\n\tint format, slen, dlen;\n\tunsigned long nitems = 0, bytes_after = 0;\n\tunsigned char* data = NULL;\n\tchar get_str[VNC_CONNECT_MAX+1];\n\n\tRAWFB_RET(NULL)\n\n\tif (prop == NULL || !strcmp(prop, \"\")) {\n\t\treturn NULL;\n\t}\n\tif (win == None) {\n\t\twin = rootwin;\n\t}\n\taprop = XInternAtom(dpy, prop, True);\n\tif (aprop == None) {\n\t\treturn NULL;\n\t}\n\n\tget_str[0] = '\\0';\n\tslen = 0;\n\n\t/* read the property value into get_str: */\n\tdo {\n\t\tif (XGetWindowProperty(dpy, win, aprop, nitems/4,\n\t\t    VNC_CONNECT_MAX/16, False, AnyPropertyType, &type,\n\t\t    &format, &nitems, &bytes_after, &data) == Success) {\n\n\t\t\tdlen = nitems * (format/8);\n\t\t\tif (slen + dlen > VNC_CONNECT_MAX) {\n\t\t\t\t/* too big */\n\t\t\t\trfbLog(\"get_xprop: warning: truncating large '%s'\"\n\t\t\t\t   \" string > %d bytes.\\n\", prop, VNC_CONNECT_MAX);\n\t\t\t\tXFree_wr(data);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tmemcpy(get_str+slen, data, dlen);\n\t\t\tslen += dlen;\n\t\t\tget_str[slen] = '\\0';\n\t\t\tXFree_wr(data);\n\t\t}\n\t} while (bytes_after > 0);\n\n\tget_str[VNC_CONNECT_MAX] = '\\0';\n\trfbLog(\"get_prop: read: '%s' = '%s'\\n\", prop, get_str);\n\n\treturn strdup(get_str);\n#endif\t/* NO_X11 */\n}"
        }
      }
    ],
    "contextual_snippet": "#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"x11vnc.h\"\n\nextern int set_xprop(char *prop, Window win, char *value);\nextern void set_env(char *name, char *value);\n\nstatic void handle_prop_cmd(void) {\n\tchar *value, *str, *done = \"DONE\";\n\n\tif (cmd_atom == None) {\n\t\treturn;\n\t}\n\n\tvalue = get_xprop(cmd_atom_str, root);\n\tif (value == NULL) {\n\t\treturn;\n\t}\n\n\tstr = lblanks(value);\n\tif (!strcmp(str, done)) {\n\t\tfree(value);\n\t\treturn;\n\t}\n\tif (strstr(str, \"cmd=quit\") == str || strstr(str, \"\\ncmd=quit\")) {\n\t\tset_xprop(cmd_atom_str, root, done);\n\t\tappshare_cleanup(0);\n\t}\n\n\tprocess_string(str);\n\n\tfree(value);\n\tset_xprop(cmd_atom_str, root, done);\n}"
  },
  {
    "function_name": "handle_shell",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/appshare.c",
    "lines": "1681-1725",
    "snippet": "static void handle_shell(void) {\n\tstruct timeval tv;\n\tstatic char lastline[1000];\n\tstatic int first = 1;\n\tfd_set rfds;\n\tint fd0 = fileno(stdin);\n\n\tif (first) {\n\t\tmemset(lastline, 0, sizeof(lastline));\n\t\tfirst = 0;\n\t}\n\n\tFD_ZERO(&rfds);\n\tFD_SET(fd0, &rfds);\n\ttv.tv_sec = 0; \n\ttv.tv_usec = 0; \n\tselect(fd0+1, &rfds, NULL, NULL, &tv);\n\tif (FD_ISSET(fd0, &rfds)) {\n\t\tchar line[1000], line2[1010];\n\t\tif (fgets(line, sizeof(line), stdin) != NULL) {\n\t\t\tchar *str = lblanks(line);\n\t\t\tchar *q = strrchr(str, '\\n');\n\t\t\tif (q) *q = '\\0';\n\t\t\tif (strcmp(str, \"\")) {\n\t\t\t\tif (!strcmp(str, \"!!\")) {\n\t\t\t\t\tsprintf(line, \"%s\", lastline);\n\t\t\t\t\tfprintf(stderr, \"%s\\n\", line);\n\t\t\t\t\tstr = line;\n\t\t\t\t}\n\t\t\t\tif (strstr(str, \"!\") == str) {\n\t\t\t\t\tsystem(str+1);\n\t\t\t\t} else if (!strcmp(str, \"x11vnc\") || !strcmp(str, \"ps\")) {\n\t\t\t\t\tchar *cmd = \"ps -elf | egrep 'PID|x11vnc' | grep -v egrep\";\n\t\t\t\t\tfprintf(stderr, \"%s\\n\", cmd);\n\t\t\t\t\tsystem(cmd);\n\t\t\t\t} else {\n\t\t\t\t\tsprintf(line2, \"cmd=%s\", str);\n\t\t\t\t\tprocess_string(line2);\n\t\t\t\t}\n\t\t\t\tsprintf(lastline, \"%s\", str);\n\t\t\t}\n\t\t}\n\t\tfprintf(stderr, \"\\n%s\", prompt); ff();\n\t}\n}",
    "includes": [
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ff",
          "args": [],
          "line": 1723
        },
        "resolved": true,
        "details": {
          "function_name": "ff",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/appshare.c",
          "lines": "293-296",
          "snippet": "static void ff(void) {\n\tfflush(stdout);\n\tfflush(stderr);\n}",
          "includes": [
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"x11vnc.h\"\n\nstatic void ff(void) {\n\tfflush(stdout);\n\tfflush(stderr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"\\n%s\"",
            "prompt"
          ],
          "line": 1723
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "lastline",
            "\"%s\"",
            "str"
          ],
          "line": 1720
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "process_string",
          "args": [
            "line2"
          ],
          "line": 1718
        },
        "resolved": true,
        "details": {
          "function_name": "process_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/appshare.c",
          "lines": "1656-1679",
          "snippet": "static void process_string(char *str) {\n\tFILE *f;\n\tchar *file;\n\tif (trackdir) {\n\t\tsprintf(tracktmp, \"%s/0xprop.cmd\", trackdir);\n\t\tfile = strdup(tracktmp);\n\t} else {\n\t\tchar tmp[] = \"/tmp/x11vnc-appshare.cmd.XXXXXX\";\n\t\tint fd = mkstemp(tmp);\n\t\tif (fd < 0) {\n\t\t\treturn;\n\t\t}\n\t\tfile = strdup(tmp);\n\t\tclose(fd);\n\t}\n\tf = fopen(file, \"w\");\n\tif (f) {\n\t\tfprintf(f, \"%s\", str);\n\t\tfclose(f);\n\t\tprocess_control(file, 0);\n\t}\n\tunlink(file);\n\tfree(file);\n}",
          "includes": [
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"x11vnc.h\"\n\nstatic void process_string(char *str) {\n\tFILE *f;\n\tchar *file;\n\tif (trackdir) {\n\t\tsprintf(tracktmp, \"%s/0xprop.cmd\", trackdir);\n\t\tfile = strdup(tracktmp);\n\t} else {\n\t\tchar tmp[] = \"/tmp/x11vnc-appshare.cmd.XXXXXX\";\n\t\tint fd = mkstemp(tmp);\n\t\tif (fd < 0) {\n\t\t\treturn;\n\t\t}\n\t\tfile = strdup(tmp);\n\t\tclose(fd);\n\t}\n\tf = fopen(file, \"w\");\n\tif (f) {\n\t\tfprintf(f, \"%s\", str);\n\t\tfclose(f);\n\t\tprocess_control(file, 0);\n\t}\n\tunlink(file);\n\tfree(file);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "line2",
            "\"cmd=%s\"",
            "str"
          ],
          "line": 1717
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "system",
          "args": [
            "cmd"
          ],
          "line": 1715
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"%s\\n\"",
            "cmd"
          ],
          "line": 1714
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "str",
            "\"ps\""
          ],
          "line": 1712
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "str",
            "\"x11vnc\""
          ],
          "line": 1712
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "system",
          "args": [
            "str+1"
          ],
          "line": 1711
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "str",
            "\"!\""
          ],
          "line": 1710
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"%s\\n\"",
            "line"
          ],
          "line": 1707
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "line",
            "\"%s\"",
            "lastline"
          ],
          "line": 1706
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "str",
            "\"!!\""
          ],
          "line": 1705
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "str",
            "\"\""
          ],
          "line": 1704
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strrchr",
          "args": [
            "str",
            "'\\n'"
          ],
          "line": 1702
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lblanks",
          "args": [
            "line"
          ],
          "line": 1701
        },
        "resolved": true,
        "details": {
          "function_name": "lblanks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/util.c",
          "lines": "160-169",
          "snippet": "char *lblanks(char *str) {\n\tchar *p = str;\n\twhile (*p != '\\0') {\n\t\tif (! isspace((unsigned char) (*p))) {\n\t\t\tbreak;\n\t\t}\n\t\tp++;\n\t}\n\treturn p;\n}",
          "includes": [
            "#include \"connections.h\"",
            "#include \"unixpw.h\"",
            "#include \"win_utils.h\"",
            "#include \"cleanup.h\"",
            "#include \"x11vnc.h\"",
            "#include <stdlib.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void lowercase(char *str);",
            "void uppercase(char *str);",
            "char *lblanks(char *str);",
            "void strzero(char *str);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"connections.h\"\n#include \"unixpw.h\"\n#include \"win_utils.h\"\n#include \"cleanup.h\"\n#include \"x11vnc.h\"\n#include <stdlib.h>\n\nvoid lowercase(char *str);\nvoid uppercase(char *str);\nchar *lblanks(char *str);\nvoid strzero(char *str);\n\nchar *lblanks(char *str) {\n\tchar *p = str;\n\twhile (*p != '\\0') {\n\t\tif (! isspace((unsigned char) (*p))) {\n\t\t\tbreak;\n\t\t}\n\t\tp++;\n\t}\n\treturn p;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fgets",
          "args": [
            "line",
            "sizeof(line)",
            "stdin"
          ],
          "line": 1700
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FD_ISSET",
          "args": [
            "fd0",
            "&rfds"
          ],
          "line": 1698
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "select",
          "args": [
            "fd0+1",
            "&rfds",
            "NULL",
            "NULL",
            "&tv"
          ],
          "line": 1697
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FD_SET",
          "args": [
            "fd0",
            "&rfds"
          ],
          "line": 1694
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FD_ZERO",
          "args": [
            "&rfds"
          ],
          "line": 1693
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "lastline",
            "0",
            "sizeof(lastline)"
          ],
          "line": 1689
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fileno",
          "args": [
            "stdin"
          ],
          "line": 1686
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"x11vnc.h\"\n\nstatic void handle_shell(void) {\n\tstruct timeval tv;\n\tstatic char lastline[1000];\n\tstatic int first = 1;\n\tfd_set rfds;\n\tint fd0 = fileno(stdin);\n\n\tif (first) {\n\t\tmemset(lastline, 0, sizeof(lastline));\n\t\tfirst = 0;\n\t}\n\n\tFD_ZERO(&rfds);\n\tFD_SET(fd0, &rfds);\n\ttv.tv_sec = 0; \n\ttv.tv_usec = 0; \n\tselect(fd0+1, &rfds, NULL, NULL, &tv);\n\tif (FD_ISSET(fd0, &rfds)) {\n\t\tchar line[1000], line2[1010];\n\t\tif (fgets(line, sizeof(line), stdin) != NULL) {\n\t\t\tchar *str = lblanks(line);\n\t\t\tchar *q = strrchr(str, '\\n');\n\t\t\tif (q) *q = '\\0';\n\t\t\tif (strcmp(str, \"\")) {\n\t\t\t\tif (!strcmp(str, \"!!\")) {\n\t\t\t\t\tsprintf(line, \"%s\", lastline);\n\t\t\t\t\tfprintf(stderr, \"%s\\n\", line);\n\t\t\t\t\tstr = line;\n\t\t\t\t}\n\t\t\t\tif (strstr(str, \"!\") == str) {\n\t\t\t\t\tsystem(str+1);\n\t\t\t\t} else if (!strcmp(str, \"x11vnc\") || !strcmp(str, \"ps\")) {\n\t\t\t\t\tchar *cmd = \"ps -elf | egrep 'PID|x11vnc' | grep -v egrep\";\n\t\t\t\t\tfprintf(stderr, \"%s\\n\", cmd);\n\t\t\t\t\tsystem(cmd);\n\t\t\t\t} else {\n\t\t\t\t\tsprintf(line2, \"cmd=%s\", str);\n\t\t\t\t\tprocess_string(line2);\n\t\t\t\t}\n\t\t\t\tsprintf(lastline, \"%s\", str);\n\t\t\t}\n\t\t}\n\t\tfprintf(stderr, \"\\n%s\", prompt); ff();\n\t}\n}"
  },
  {
    "function_name": "process_string",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/appshare.c",
    "lines": "1656-1679",
    "snippet": "static void process_string(char *str) {\n\tFILE *f;\n\tchar *file;\n\tif (trackdir) {\n\t\tsprintf(tracktmp, \"%s/0xprop.cmd\", trackdir);\n\t\tfile = strdup(tracktmp);\n\t} else {\n\t\tchar tmp[] = \"/tmp/x11vnc-appshare.cmd.XXXXXX\";\n\t\tint fd = mkstemp(tmp);\n\t\tif (fd < 0) {\n\t\t\treturn;\n\t\t}\n\t\tfile = strdup(tmp);\n\t\tclose(fd);\n\t}\n\tf = fopen(file, \"w\");\n\tif (f) {\n\t\tfprintf(f, \"%s\", str);\n\t\tfclose(f);\n\t\tprocess_control(file, 0);\n\t}\n\tunlink(file);\n\tfree(file);\n}",
    "includes": [
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "file"
          ],
          "line": 1678
        },
        "resolved": true,
        "details": {
          "function_name": "free_rect",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/userinput.c",
          "lines": "6200-6247",
          "snippet": "int free_rect(int idx) {\n\tint n, ok = 0;\n\tsraRegionPtr r1, r2;\n\tint x, y, w, h;\n\n\tif (idx < 0 || idx >= cache_list_num) {\nif (0) fprintf(stderr, \"free_rect: bad index: %d\\n\", idx);\n\t\tclean_up_exit(1);\n\t}\n\n\tx = cache_list[idx].bs_x;\n\ty = cache_list[idx].bs_y;\n\tw = cache_list[idx].bs_w;\n\th = cache_list[idx].bs_h;\n\n\tif (x < 0) {\n\t\tCLEAR(idx);\nif (dnow() > last_client + 5 && ncdb) fprintf(stderr, \"free_rect: already bs_x invalidated: %d bs_x: %d\\n\", idx, x);\n\t\treturn 1;\n\t}\n\n\tr2 = sraRgnCreateRect(x, y, x+w, y+h);\n\n\tn = get_bs_n(y);\n\tif (n >= 0) {\n\t\tr1 = rect_reg[n];\n\t\tsraRgnOr(r1, r2);\n\t\tok = 1;\n\t}\n\n\tif (zero_rects) {\n\t\tsraRgnOr(zero_rects, r2);\n\t\tx = cache_list[idx].su_x;\n\t\ty = cache_list[idx].su_y;\n\t\tw = cache_list[idx].su_w;\n\t\th = cache_list[idx].su_h;\n\t\tif (x >= 0) {\n\t\t\tsraRgnDestroy(r2);\n\t\t\tr2 = sraRgnCreateRect(x, y, x+w, y+h);\n\t\t\tsraRgnOr(zero_rects, r2);\n\t\t}\n\t}\n\tsraRgnDestroy(r2);\n\n\tCLEAR(idx);\nif (! ok && ncdb) fprintf(stderr, \"**** free_rect: not-found %d\\n\", idx);\n\treturn ok;\n}",
          "includes": [
            "#include \"default8x16.h\"",
            "#include \"connections.h\"",
            "#include \"screen.h\"",
            "#include \"cursor.h\"",
            "#include \"macosxCGS.h\"",
            "#include \"macosx.h\"",
            "#include \"unixpw.h\"",
            "#include \"8to24.h\"",
            "#include \"xrandr.h\"",
            "#include \"solid.h\"",
            "#include \"keyboard.h\"",
            "#include \"rates.h\"",
            "#include \"pointer.h\"",
            "#include \"cleanup.h\"",
            "#include \"scan.h\"",
            "#include \"user.h\"",
            "#include \"xevents.h\"",
            "#include \"win_utils.h\"",
            "#include \"xinerama.h\"",
            "#include \"xrecord.h\"",
            "#include \"xdamage.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void mark_for_xdamage(int x, int y, int w, int h);",
            "void set_xdamage_mark(int x, int y, int w, int h);",
            "int find_rect(int idx, int x, int y, int w, int h);",
            "winattr_t *cache_list;",
            "int clipped(int idx);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"default8x16.h\"\n#include \"connections.h\"\n#include \"screen.h\"\n#include \"cursor.h\"\n#include \"macosxCGS.h\"\n#include \"macosx.h\"\n#include \"unixpw.h\"\n#include \"8to24.h\"\n#include \"xrandr.h\"\n#include \"solid.h\"\n#include \"keyboard.h\"\n#include \"rates.h\"\n#include \"pointer.h\"\n#include \"cleanup.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"xevents.h\"\n#include \"win_utils.h\"\n#include \"xinerama.h\"\n#include \"xrecord.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nvoid mark_for_xdamage(int x, int y, int w, int h);\nvoid set_xdamage_mark(int x, int y, int w, int h);\nint find_rect(int idx, int x, int y, int w, int h);\nwinattr_t *cache_list;\nint clipped(int idx);\n\nint free_rect(int idx) {\n\tint n, ok = 0;\n\tsraRegionPtr r1, r2;\n\tint x, y, w, h;\n\n\tif (idx < 0 || idx >= cache_list_num) {\nif (0) fprintf(stderr, \"free_rect: bad index: %d\\n\", idx);\n\t\tclean_up_exit(1);\n\t}\n\n\tx = cache_list[idx].bs_x;\n\ty = cache_list[idx].bs_y;\n\tw = cache_list[idx].bs_w;\n\th = cache_list[idx].bs_h;\n\n\tif (x < 0) {\n\t\tCLEAR(idx);\nif (dnow() > last_client + 5 && ncdb) fprintf(stderr, \"free_rect: already bs_x invalidated: %d bs_x: %d\\n\", idx, x);\n\t\treturn 1;\n\t}\n\n\tr2 = sraRgnCreateRect(x, y, x+w, y+h);\n\n\tn = get_bs_n(y);\n\tif (n >= 0) {\n\t\tr1 = rect_reg[n];\n\t\tsraRgnOr(r1, r2);\n\t\tok = 1;\n\t}\n\n\tif (zero_rects) {\n\t\tsraRgnOr(zero_rects, r2);\n\t\tx = cache_list[idx].su_x;\n\t\ty = cache_list[idx].su_y;\n\t\tw = cache_list[idx].su_w;\n\t\th = cache_list[idx].su_h;\n\t\tif (x >= 0) {\n\t\t\tsraRgnDestroy(r2);\n\t\t\tr2 = sraRgnCreateRect(x, y, x+w, y+h);\n\t\t\tsraRgnOr(zero_rects, r2);\n\t\t}\n\t}\n\tsraRgnDestroy(r2);\n\n\tCLEAR(idx);\nif (! ok && ncdb) fprintf(stderr, \"**** free_rect: not-found %d\\n\", idx);\n\treturn ok;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlink",
          "args": [
            "file"
          ],
          "line": 1677
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "process_control",
          "args": [
            "file",
            "0"
          ],
          "line": 1675
        },
        "resolved": true,
        "details": {
          "function_name": "process_control",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/appshare.c",
          "lines": "1359-1517",
          "snippet": "static int process_control(char *file, int check_clients) {\n\tint i, nnew = 0, seen[CMAX];\n\tchar line[1024], *newctl[CMAX];\n\tFILE *f;\n\n\tf = fopen(file, \"r\");\n\tif (!f) {\n\t\treturn 1;\n\t}\n\tif (check_clients) {\n\t\tfor (i=0; i < CMAX; i++) {\n\t\t\tseen[i] = 0;\n\t\t}\n\t}\n\twhile (fgets(line, sizeof(line), f) != NULL) {\n\t\tchar *q = strchr(line, '\\n');\n\t\tif (q) *q = '\\0';\n\n\t\tif (appshare_debug) {\n\t\t\tfprintf(stderr, \"check_control: %s\\n\", line);\n\t\t\tff();\n\t\t}\n\n\t\tq = lblanks(line);\n\t\tif (q[0] == '#') {\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strcmp(q, \"\")) {\n\t\t\tcontinue;\n\t\t}\n\t\tif (strstr(q, \"cmd=\") == q) {\n\t\t\tchar *cmd = q + strlen(\"cmd=\");\n\t\t\tif (!strcmp(cmd, \"quit\")) {\n\t\t\t\tif (strcmp(control, file) && strstr(file, \".cmd\")) {\n\t\t\t\t\tFILE *f2 = fopen(file, \"w\");\n\t\t\t\t\tif (f2) fclose(f2);\n\t\t\t\t}\n\t\t\t\tappshare_cleanup(0);\n\t\t\t} else if (!strcmp(cmd, \"wait\")) {\n\t\t\t\treturn 0;\n\t\t\t} else if (strstr(cmd, \"bcast:\") == cmd) {\n\t\t\t\t;\n\t\t\t} else if (strstr(cmd, \"del_window:\") == cmd) {\n\t\t\t\tadd_or_del_win(cmd + strlen(\"del_window:\"), 0);\n\t\t\t} else if (strstr(cmd, \"add_window:\") == cmd) {\n\t\t\t\tadd_or_del_win(cmd + strlen(\"add_window:\"), 1);\n\t\t\t} else if (strstr(cmd, \"del:\") == cmd) {\n\t\t\t\tadd_or_del_win(cmd + strlen(\"del:\"), 0);\n\t\t\t} else if (strstr(cmd, \"add:\") == cmd) {\n\t\t\t\tadd_or_del_win(cmd + strlen(\"add:\"), 1);\n\t\t\t} else if (strstr(cmd, \"del_client:\") == cmd) {\n\t\t\t\tadd_or_del_client(cmd + strlen(\"del_client:\"), 0);\n\t\t\t} else if (strstr(cmd, \"add_client:\") == cmd) {\n\t\t\t\tadd_or_del_client(cmd + strlen(\"add_client:\"), 1);\n\t\t\t} else if (strstr(cmd, \"-\") == cmd) {\n\t\t\t\tadd_or_del_client(cmd + strlen(\"-\"), 0);\n\t\t\t} else if (strstr(cmd, \"+\") == cmd) {\n\t\t\t\tadd_or_del_client(cmd + strlen(\"+\"), 1);\n\t\t\t} else if (strstr(cmd, \"del_app:\") == cmd) {\n\t\t\t\tadd_or_del_app(cmd + strlen(\"del_app:\"), 0);\n\t\t\t} else if (strstr(cmd, \"add_app:\") == cmd) {\n\t\t\t\tadd_or_del_app(cmd + strlen(\"add_app:\"), 1);\n\t\t\t} else if (strstr(cmd, \"debug:\") == cmd) {\n\t\t\t\tappshare_debug = atoi(cmd + strlen(\"debug:\"));\n\t\t\t} else if (strstr(cmd, \"showmenus:\") == cmd) {\n\t\t\t\tskip_menus = atoi(cmd + strlen(\"showmenus:\"));\n\t\t\t\tskip_menus = !(skip_menus);\n\t\t\t} else if (strstr(cmd, \"noexit:\") == cmd) {\n\t\t\t\texit_no_app_win = atoi(cmd + strlen(\"noexit:\"));\n\t\t\t\texit_no_app_win = !(exit_no_app_win);\n\t\t\t} else if (strstr(cmd, \"use_forever:\") == cmd) {\n\t\t\t\tuse_forever = atoi(cmd + strlen(\"use_forever:\"));\n\t\t\t} else if (strstr(cmd, \"tree_depth:\") == cmd) {\n\t\t\t\ttree_depth = atoi(cmd + strlen(\"tree_depth:\"));\n\t\t\t} else if (strstr(cmd, \"x11vnc_args:\") == cmd) {\n\t\t\t\tx11vnc_args = strdup(cmd + strlen(\"x11vnc_args:\"));\n\t\t\t} else if (strstr(cmd, \"env:\") == cmd) {\n\t\t\t\tputenv(cmd + strlen(\"env:\"));\n\t\t\t} else if (strstr(cmd, \"noop\") == cmd) {\n\t\t\t\t;\n\t\t\t} else if (!strcmp(cmd, \"restart\")) {\n\t\t\t\trestart_x11vnc();\n\t\t\t} else if (!strcmp(cmd, \"list_clients\") || !strcmp(cmd, \"lc\")) {\n\t\t\t\tlist_clients();\n\t\t\t} else if (!strcmp(cmd, \"list_windows\") || !strcmp(cmd, \"lw\")) {\n\t\t\t\tlist_windows();\n\t\t\t} else if (!strcmp(cmd, \"list_apps\") || !strcmp(cmd, \"la\")) {\n\t\t\t\tlist_apps();\n\t\t\t} else if (!strcmp(cmd, \"list_all\") || !strcmp(cmd, \"ls\")) {\n\t\t\t\tlist_windows();\n\t\t\t\tfprintf(stderr, \"\\n\");\n\t\t\t\tlist_apps();\n\t\t\t\tfprintf(stderr, \"\\n\");\n\t\t\t\tlist_clients();\n\t\t\t} else if (!strcmp(cmd, \"print_logs\") || !strcmp(cmd, \"pl\")) {\n\t\t\t\tprint_logs();\n\t\t\t} else if (!strcmp(cmd, \"?\") || !strcmp(cmd, \"h\") || !strcmp(cmd, \"help\")) {\n\t\t\t\tfprintf(stderr, \"available commands:\\n\");\n\t\t\t\tfprintf(stderr, \"\\n\");\n\t\t\t\tfprintf(stderr, \"   quit restart noop x11vnc help ? ! !!\\n\");\n\t\t\t\tfprintf(stderr, \"\\n\");\n\t\t\t\tfprintf(stderr, \"   add_window:win  (add:win, add:pick)\\n\");\n\t\t\t\tfprintf(stderr, \"   del_window:win  (del:win, del:pick, del:all)\\n\");\n\t\t\t\tfprintf(stderr, \"   add_app:win     (add_app:pick)\\n\");\n\t\t\t\tfprintf(stderr, \"   del_app:win     (del_app:pick, del_app:all)\\n\");\n\t\t\t\tfprintf(stderr, \"   add_client:host (+host)\\n\");\n\t\t\t\tfprintf(stderr, \"   del_client:host (-host, -all)\\n\");\n\t\t\t\tfprintf(stderr, \"\\n\");\n\t\t\t\tfprintf(stderr, \"   list_windows    (lw)\\n\");\n\t\t\t\tfprintf(stderr, \"   list_apps       (la)\\n\");\n\t\t\t\tfprintf(stderr, \"   list_clients    (lc)\\n\");\n\t\t\t\tfprintf(stderr, \"   list_all        (ls)\\n\");\n\t\t\t\tfprintf(stderr, \"   print_logs      (pl)\\n\");\n\t\t\t\tfprintf(stderr, \"\\n\");\n\t\t\t\tfprintf(stderr, \"   debug:n   showmenus:n   noexit:n\\n\");\n\t\t\t} else {\n\t\t\t\tfprintf(stderr, \"unrecognized %s\\n\", q);\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\t\tif (check_clients) {\n\t\t\tint idx = find_client(q);\n\t\t\tif (idx >= 0) {\n\t\t\t\tseen[idx] = 1;\n\t\t\t} else {\n\t\t\t\tnewctl[nnew++] = strdup(q);\n\t\t\t}\n\t\t}\n\t}\n\tfclose(f);\n\n\tif (check_clients) {\n\t\tfor (i=0; i < CMAX; i++) {\n\t\t\tif (clients[i] == NULL) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (!seen[i]) {\n\t\t\t\tclient(clients[i], 0);\n\t\t\t\tfree(clients[i]);\n\t\t\t\tclients[i] = NULL;\n\t\t\t}\n\t\t}\n\t\tfor (i=0; i < nnew; i++) {\n\t\t\tint free = find_client(NULL);\n\t\t\tif (free < 0) {\n\t\t\t\tstatic int cnt = 0;\n\t\t\t\tif (cnt++ < 10) {\n\t\t\t\t\tfprintf(stderr, \"ran out of client slots.\\n\");\n\t\t\t\t\tff();\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tclients[free] = newctl[i];\n\t\t\tclient(newctl[i], 1);\n\t\t}\n\t}\n\treturn 1;\n}",
          "includes": [
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [
            "#define CMAX 128"
          ],
          "globals_used": [
            "extern char *get_xprop(char *prop, Window win);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"x11vnc.h\"\n\n#define CMAX 128\n\nextern char *get_xprop(char *prop, Window win);\n\nstatic int process_control(char *file, int check_clients) {\n\tint i, nnew = 0, seen[CMAX];\n\tchar line[1024], *newctl[CMAX];\n\tFILE *f;\n\n\tf = fopen(file, \"r\");\n\tif (!f) {\n\t\treturn 1;\n\t}\n\tif (check_clients) {\n\t\tfor (i=0; i < CMAX; i++) {\n\t\t\tseen[i] = 0;\n\t\t}\n\t}\n\twhile (fgets(line, sizeof(line), f) != NULL) {\n\t\tchar *q = strchr(line, '\\n');\n\t\tif (q) *q = '\\0';\n\n\t\tif (appshare_debug) {\n\t\t\tfprintf(stderr, \"check_control: %s\\n\", line);\n\t\t\tff();\n\t\t}\n\n\t\tq = lblanks(line);\n\t\tif (q[0] == '#') {\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strcmp(q, \"\")) {\n\t\t\tcontinue;\n\t\t}\n\t\tif (strstr(q, \"cmd=\") == q) {\n\t\t\tchar *cmd = q + strlen(\"cmd=\");\n\t\t\tif (!strcmp(cmd, \"quit\")) {\n\t\t\t\tif (strcmp(control, file) && strstr(file, \".cmd\")) {\n\t\t\t\t\tFILE *f2 = fopen(file, \"w\");\n\t\t\t\t\tif (f2) fclose(f2);\n\t\t\t\t}\n\t\t\t\tappshare_cleanup(0);\n\t\t\t} else if (!strcmp(cmd, \"wait\")) {\n\t\t\t\treturn 0;\n\t\t\t} else if (strstr(cmd, \"bcast:\") == cmd) {\n\t\t\t\t;\n\t\t\t} else if (strstr(cmd, \"del_window:\") == cmd) {\n\t\t\t\tadd_or_del_win(cmd + strlen(\"del_window:\"), 0);\n\t\t\t} else if (strstr(cmd, \"add_window:\") == cmd) {\n\t\t\t\tadd_or_del_win(cmd + strlen(\"add_window:\"), 1);\n\t\t\t} else if (strstr(cmd, \"del:\") == cmd) {\n\t\t\t\tadd_or_del_win(cmd + strlen(\"del:\"), 0);\n\t\t\t} else if (strstr(cmd, \"add:\") == cmd) {\n\t\t\t\tadd_or_del_win(cmd + strlen(\"add:\"), 1);\n\t\t\t} else if (strstr(cmd, \"del_client:\") == cmd) {\n\t\t\t\tadd_or_del_client(cmd + strlen(\"del_client:\"), 0);\n\t\t\t} else if (strstr(cmd, \"add_client:\") == cmd) {\n\t\t\t\tadd_or_del_client(cmd + strlen(\"add_client:\"), 1);\n\t\t\t} else if (strstr(cmd, \"-\") == cmd) {\n\t\t\t\tadd_or_del_client(cmd + strlen(\"-\"), 0);\n\t\t\t} else if (strstr(cmd, \"+\") == cmd) {\n\t\t\t\tadd_or_del_client(cmd + strlen(\"+\"), 1);\n\t\t\t} else if (strstr(cmd, \"del_app:\") == cmd) {\n\t\t\t\tadd_or_del_app(cmd + strlen(\"del_app:\"), 0);\n\t\t\t} else if (strstr(cmd, \"add_app:\") == cmd) {\n\t\t\t\tadd_or_del_app(cmd + strlen(\"add_app:\"), 1);\n\t\t\t} else if (strstr(cmd, \"debug:\") == cmd) {\n\t\t\t\tappshare_debug = atoi(cmd + strlen(\"debug:\"));\n\t\t\t} else if (strstr(cmd, \"showmenus:\") == cmd) {\n\t\t\t\tskip_menus = atoi(cmd + strlen(\"showmenus:\"));\n\t\t\t\tskip_menus = !(skip_menus);\n\t\t\t} else if (strstr(cmd, \"noexit:\") == cmd) {\n\t\t\t\texit_no_app_win = atoi(cmd + strlen(\"noexit:\"));\n\t\t\t\texit_no_app_win = !(exit_no_app_win);\n\t\t\t} else if (strstr(cmd, \"use_forever:\") == cmd) {\n\t\t\t\tuse_forever = atoi(cmd + strlen(\"use_forever:\"));\n\t\t\t} else if (strstr(cmd, \"tree_depth:\") == cmd) {\n\t\t\t\ttree_depth = atoi(cmd + strlen(\"tree_depth:\"));\n\t\t\t} else if (strstr(cmd, \"x11vnc_args:\") == cmd) {\n\t\t\t\tx11vnc_args = strdup(cmd + strlen(\"x11vnc_args:\"));\n\t\t\t} else if (strstr(cmd, \"env:\") == cmd) {\n\t\t\t\tputenv(cmd + strlen(\"env:\"));\n\t\t\t} else if (strstr(cmd, \"noop\") == cmd) {\n\t\t\t\t;\n\t\t\t} else if (!strcmp(cmd, \"restart\")) {\n\t\t\t\trestart_x11vnc();\n\t\t\t} else if (!strcmp(cmd, \"list_clients\") || !strcmp(cmd, \"lc\")) {\n\t\t\t\tlist_clients();\n\t\t\t} else if (!strcmp(cmd, \"list_windows\") || !strcmp(cmd, \"lw\")) {\n\t\t\t\tlist_windows();\n\t\t\t} else if (!strcmp(cmd, \"list_apps\") || !strcmp(cmd, \"la\")) {\n\t\t\t\tlist_apps();\n\t\t\t} else if (!strcmp(cmd, \"list_all\") || !strcmp(cmd, \"ls\")) {\n\t\t\t\tlist_windows();\n\t\t\t\tfprintf(stderr, \"\\n\");\n\t\t\t\tlist_apps();\n\t\t\t\tfprintf(stderr, \"\\n\");\n\t\t\t\tlist_clients();\n\t\t\t} else if (!strcmp(cmd, \"print_logs\") || !strcmp(cmd, \"pl\")) {\n\t\t\t\tprint_logs();\n\t\t\t} else if (!strcmp(cmd, \"?\") || !strcmp(cmd, \"h\") || !strcmp(cmd, \"help\")) {\n\t\t\t\tfprintf(stderr, \"available commands:\\n\");\n\t\t\t\tfprintf(stderr, \"\\n\");\n\t\t\t\tfprintf(stderr, \"   quit restart noop x11vnc help ? ! !!\\n\");\n\t\t\t\tfprintf(stderr, \"\\n\");\n\t\t\t\tfprintf(stderr, \"   add_window:win  (add:win, add:pick)\\n\");\n\t\t\t\tfprintf(stderr, \"   del_window:win  (del:win, del:pick, del:all)\\n\");\n\t\t\t\tfprintf(stderr, \"   add_app:win     (add_app:pick)\\n\");\n\t\t\t\tfprintf(stderr, \"   del_app:win     (del_app:pick, del_app:all)\\n\");\n\t\t\t\tfprintf(stderr, \"   add_client:host (+host)\\n\");\n\t\t\t\tfprintf(stderr, \"   del_client:host (-host, -all)\\n\");\n\t\t\t\tfprintf(stderr, \"\\n\");\n\t\t\t\tfprintf(stderr, \"   list_windows    (lw)\\n\");\n\t\t\t\tfprintf(stderr, \"   list_apps       (la)\\n\");\n\t\t\t\tfprintf(stderr, \"   list_clients    (lc)\\n\");\n\t\t\t\tfprintf(stderr, \"   list_all        (ls)\\n\");\n\t\t\t\tfprintf(stderr, \"   print_logs      (pl)\\n\");\n\t\t\t\tfprintf(stderr, \"\\n\");\n\t\t\t\tfprintf(stderr, \"   debug:n   showmenus:n   noexit:n\\n\");\n\t\t\t} else {\n\t\t\t\tfprintf(stderr, \"unrecognized %s\\n\", q);\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\t\tif (check_clients) {\n\t\t\tint idx = find_client(q);\n\t\t\tif (idx >= 0) {\n\t\t\t\tseen[idx] = 1;\n\t\t\t} else {\n\t\t\t\tnewctl[nnew++] = strdup(q);\n\t\t\t}\n\t\t}\n\t}\n\tfclose(f);\n\n\tif (check_clients) {\n\t\tfor (i=0; i < CMAX; i++) {\n\t\t\tif (clients[i] == NULL) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (!seen[i]) {\n\t\t\t\tclient(clients[i], 0);\n\t\t\t\tfree(clients[i]);\n\t\t\t\tclients[i] = NULL;\n\t\t\t}\n\t\t}\n\t\tfor (i=0; i < nnew; i++) {\n\t\t\tint free = find_client(NULL);\n\t\t\tif (free < 0) {\n\t\t\t\tstatic int cnt = 0;\n\t\t\t\tif (cnt++ < 10) {\n\t\t\t\t\tfprintf(stderr, \"ran out of client slots.\\n\");\n\t\t\t\t\tff();\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tclients[free] = newctl[i];\n\t\t\tclient(newctl[i], 1);\n\t\t}\n\t}\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fclose",
          "args": [
            "f"
          ],
          "line": 1674
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "f",
            "\"%s\"",
            "str"
          ],
          "line": 1673
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fopen",
          "args": [
            "file",
            "\"w\""
          ],
          "line": 1671
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "close",
          "args": [
            "fd"
          ],
          "line": 1669
        },
        "resolved": true,
        "details": {
          "function_name": "close_alarm",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/unixpw.c",
          "lines": "666-672",
          "snippet": "static void close_alarm (int sig) {\n\tif (slave_fd >= 0) {\n\t\tclose(slave_fd);\n\t}\n\talarm_fired = 1;\n\tif (0) sig = 0;\t/* compiler warning */\n}",
          "includes": [
            "#include <sys/stropts.h>",
            "#include <termios.h>",
            "#include <sys/ioctl.h>",
            "#include <shadow.h>",
            "#include \"default8x16.h\"",
            "#include \"rates.h\"",
            "#include \"cursor.h\"",
            "#include \"sslhelper.h\"",
            "#include \"connections.h\"",
            "#include \"user.h\"",
            "#include \"connections.h\"",
            "#include \"xinerama.h\"",
            "#include \"cleanup.h\"",
            "#include \"scan.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int slave_fd = -1, alarm_fired = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/stropts.h>\n#include <termios.h>\n#include <sys/ioctl.h>\n#include <shadow.h>\n#include \"default8x16.h\"\n#include \"rates.h\"\n#include \"cursor.h\"\n#include \"sslhelper.h\"\n#include \"connections.h\"\n#include \"user.h\"\n#include \"connections.h\"\n#include \"xinerama.h\"\n#include \"cleanup.h\"\n#include \"scan.h\"\n#include \"x11vnc.h\"\n\nstatic int slave_fd = -1, alarm_fired = 0;\n\nstatic void close_alarm (int sig) {\n\tif (slave_fd >= 0) {\n\t\tclose(slave_fd);\n\t}\n\talarm_fired = 1;\n\tif (0) sig = 0;\t/* compiler warning */\n}"
        }
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "tmp"
          ],
          "line": 1668
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mkstemp",
          "args": [
            "tmp"
          ],
          "line": 1664
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "tracktmp"
          ],
          "line": 1661
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "tracktmp",
            "\"%s/0xprop.cmd\"",
            "trackdir"
          ],
          "line": 1660
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"x11vnc.h\"\n\nstatic void process_string(char *str) {\n\tFILE *f;\n\tchar *file;\n\tif (trackdir) {\n\t\tsprintf(tracktmp, \"%s/0xprop.cmd\", trackdir);\n\t\tfile = strdup(tracktmp);\n\t} else {\n\t\tchar tmp[] = \"/tmp/x11vnc-appshare.cmd.XXXXXX\";\n\t\tint fd = mkstemp(tmp);\n\t\tif (fd < 0) {\n\t\t\treturn;\n\t\t}\n\t\tfile = strdup(tmp);\n\t\tclose(fd);\n\t}\n\tf = fopen(file, \"w\");\n\tif (f) {\n\t\tfprintf(f, \"%s\", str);\n\t\tfclose(f);\n\t\tprocess_control(file, 0);\n\t}\n\tunlink(file);\n\tfree(file);\n}"
  },
  {
    "function_name": "set_trackdir",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/appshare.c",
    "lines": "1622-1654",
    "snippet": "static void set_trackdir(void) {\n\tchar tmp[256];\n\tstruct stat sb;\n\tif (!strcmp(trackdir, \"none\")) {\n\t\ttrackdir = NULL;\n\t\treturn;\n\t}\n\tif (!strcmp(trackdir, \"unset\")) {\n\t\tint fd;\n\t\tsprintf(tmp, \"%s.XXXXXX\", trackpre);\n\t\tfd = mkstemp(tmp);\n\t\tif (fd < 0) {\n\t\t\tstrcat(tmp, \": failed to create file.\\n\");\n\t\t\texiter(tmp, 1);\n\t\t}\n\t\t/* XXX race */\n\t\tclose(fd);\n\t\tunlink(tmp);\n\t\tif (mkdir(tmp, 0700) != 0) {\n\t\t\tstrcat(tmp, \": failed to create dir.\\n\");\n\t\t\texiter(tmp, 1);\n\t\t}\n\t\ttrackdir = strdup(tmp);\n\t}\n\tif (stat(trackdir, &sb) != 0) {\n\t\tif (mkdir(trackdir, 0700) != 0) {\n\t\t\texiter(\"could not make trackdir.\\n\", 1);\n\t\t}\n\t} else if (! S_ISDIR(sb.st_mode)) {\n\t\texiter(\"trackdir not a directory.\\n\", 1);\n\t}\n\ttracktmp = (char *) calloc(1000 + strlen(trackdir), 1);\n}",
    "includes": [
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "calloc",
          "args": [
            "1000 + strlen(trackdir)",
            "1"
          ],
          "line": 1653
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "trackdir"
          ],
          "line": 1653
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "exiter",
          "args": [
            "\"trackdir not a directory.\\n\"",
            "1"
          ],
          "line": 1651
        },
        "resolved": true,
        "details": {
          "function_name": "exiter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/appshare.c",
          "lines": "1615-1620",
          "snippet": "static void exiter(char *msg, int rc) {\n\tfprintf(stderr, \"%s\", msg);\n\tff();\n\tkill_helper_pid();\n\texit(rc);\n}",
          "includes": [
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"x11vnc.h\"\n\nstatic void exiter(char *msg, int rc) {\n\tfprintf(stderr, \"%s\", msg);\n\tff();\n\tkill_helper_pid();\n\texit(rc);\n}"
        }
      },
      {
        "call_info": {
          "callee": "S_ISDIR",
          "args": [
            "sb.st_mode"
          ],
          "line": 1650
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mkdir",
          "args": [
            "trackdir",
            "0700"
          ],
          "line": 1647
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "stat",
          "args": [
            "trackdir",
            "&sb"
          ],
          "line": 1646
        },
        "resolved": true,
        "details": {
          "function_name": "grab_state",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/connections.c",
          "lines": "3178-3224",
          "snippet": "void grab_state(int *ptr_grabbed, int *kbd_grabbed) {\n\tint rcp, rck;\n\tdouble t0, t1;\n\tdouble ta, tb, tc;\n\t*ptr_grabbed = -1;\n\t*kbd_grabbed = -1;\n\n\tif (!dpy) {\n\t\treturn;\n\t}\n\t*ptr_grabbed = 0;\n\t*kbd_grabbed = 0;\n\n#if !NO_X11\n\tX_LOCK;\n\n\tXSync(dpy, False);\n\n\tta = t0 = dnow();\n\n\trcp = XGrabPointer(dpy, window, False, 0, GrabModeAsync, GrabModeAsync, None, None, CurrentTime);\n\tXUngrabPointer(dpy, CurrentTime);\n\n\ttb = dnow();\n\t\n\trck = XGrabKeyboard(dpy, window, False, GrabModeAsync, GrabModeAsync, CurrentTime);\n\tXUngrabKeyboard(dpy, CurrentTime);\n\n\ttc = dnow();\n\n\tXSync(dpy, False);\n\n\tt1 = dnow();\n\n\tX_UNLOCK;\n\tif (rcp == AlreadyGrabbed || rcp == GrabFrozen) {\n\t\t*ptr_grabbed = 1;\n\t}\n\tif (rck == AlreadyGrabbed || rck == GrabFrozen) {\n\t\t*kbd_grabbed = 1;\n\t}\n\tif (rc_npieces < 10) {\n\t\trfbLog(\"grab_state: checked %d,%d in %.6f sec (%.6f %.6f)\\n\",\n\t\t    *ptr_grabbed, *kbd_grabbed, t1-t0, tb-ta, tc-tb);\n\t}\n#endif\n}",
          "includes": [
            "#include \"xi2_devices.h\"",
            "#include \"xrandr.h\"",
            "#include \"pointer.h\"",
            "#include \"userinput.h\"",
            "#include \"macosxCG.h\"",
            "#include \"macosx.h\"",
            "#include \"win_utils.h\"",
            "#include \"xevents.h\"",
            "#include \"xwrappers.h\"",
            "#include \"sslhelper.h\"",
            "#include \"sslcmds.h\"",
            "#include \"scan.h\"",
            "#include \"user.h\"",
            "#include \"unixpw.h\"",
            "#include \"screen.h\"",
            "#include \"rates.h\"",
            "#include \"solid.h\"",
            "#include \"gui.h\"",
            "#include \"cleanup.h\"",
            "#include \"keyboard.h\"",
            "#include \"remote.h\"",
            "#include \"inet.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void grab_state(int *ptr_grabbed, int *kbd_grabbed);",
            "extern int rc_npieces;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xi2_devices.h\"\n#include \"xrandr.h\"\n#include \"pointer.h\"\n#include \"userinput.h\"\n#include \"macosxCG.h\"\n#include \"macosx.h\"\n#include \"win_utils.h\"\n#include \"xevents.h\"\n#include \"xwrappers.h\"\n#include \"sslhelper.h\"\n#include \"sslcmds.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"unixpw.h\"\n#include \"screen.h\"\n#include \"rates.h\"\n#include \"solid.h\"\n#include \"gui.h\"\n#include \"cleanup.h\"\n#include \"keyboard.h\"\n#include \"remote.h\"\n#include \"inet.h\"\n#include \"x11vnc.h\"\n\nvoid grab_state(int *ptr_grabbed, int *kbd_grabbed);\nextern int rc_npieces;\n\nvoid grab_state(int *ptr_grabbed, int *kbd_grabbed) {\n\tint rcp, rck;\n\tdouble t0, t1;\n\tdouble ta, tb, tc;\n\t*ptr_grabbed = -1;\n\t*kbd_grabbed = -1;\n\n\tif (!dpy) {\n\t\treturn;\n\t}\n\t*ptr_grabbed = 0;\n\t*kbd_grabbed = 0;\n\n#if !NO_X11\n\tX_LOCK;\n\n\tXSync(dpy, False);\n\n\tta = t0 = dnow();\n\n\trcp = XGrabPointer(dpy, window, False, 0, GrabModeAsync, GrabModeAsync, None, None, CurrentTime);\n\tXUngrabPointer(dpy, CurrentTime);\n\n\ttb = dnow();\n\t\n\trck = XGrabKeyboard(dpy, window, False, GrabModeAsync, GrabModeAsync, CurrentTime);\n\tXUngrabKeyboard(dpy, CurrentTime);\n\n\ttc = dnow();\n\n\tXSync(dpy, False);\n\n\tt1 = dnow();\n\n\tX_UNLOCK;\n\tif (rcp == AlreadyGrabbed || rcp == GrabFrozen) {\n\t\t*ptr_grabbed = 1;\n\t}\n\tif (rck == AlreadyGrabbed || rck == GrabFrozen) {\n\t\t*kbd_grabbed = 1;\n\t}\n\tif (rc_npieces < 10) {\n\t\trfbLog(\"grab_state: checked %d,%d in %.6f sec (%.6f %.6f)\\n\",\n\t\t    *ptr_grabbed, *kbd_grabbed, t1-t0, tb-ta, tc-tb);\n\t}\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "tmp"
          ],
          "line": 1644
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcat",
          "args": [
            "tmp",
            "\": failed to create dir.\\n\""
          ],
          "line": 1641
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mkdir",
          "args": [
            "tmp",
            "0700"
          ],
          "line": 1640
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlink",
          "args": [
            "tmp"
          ],
          "line": 1639
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "close",
          "args": [
            "fd"
          ],
          "line": 1638
        },
        "resolved": true,
        "details": {
          "function_name": "close_alarm",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/unixpw.c",
          "lines": "666-672",
          "snippet": "static void close_alarm (int sig) {\n\tif (slave_fd >= 0) {\n\t\tclose(slave_fd);\n\t}\n\talarm_fired = 1;\n\tif (0) sig = 0;\t/* compiler warning */\n}",
          "includes": [
            "#include <sys/stropts.h>",
            "#include <termios.h>",
            "#include <sys/ioctl.h>",
            "#include <shadow.h>",
            "#include \"default8x16.h\"",
            "#include \"rates.h\"",
            "#include \"cursor.h\"",
            "#include \"sslhelper.h\"",
            "#include \"connections.h\"",
            "#include \"user.h\"",
            "#include \"connections.h\"",
            "#include \"xinerama.h\"",
            "#include \"cleanup.h\"",
            "#include \"scan.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int slave_fd = -1, alarm_fired = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/stropts.h>\n#include <termios.h>\n#include <sys/ioctl.h>\n#include <shadow.h>\n#include \"default8x16.h\"\n#include \"rates.h\"\n#include \"cursor.h\"\n#include \"sslhelper.h\"\n#include \"connections.h\"\n#include \"user.h\"\n#include \"connections.h\"\n#include \"xinerama.h\"\n#include \"cleanup.h\"\n#include \"scan.h\"\n#include \"x11vnc.h\"\n\nstatic int slave_fd = -1, alarm_fired = 0;\n\nstatic void close_alarm (int sig) {\n\tif (slave_fd >= 0) {\n\t\tclose(slave_fd);\n\t}\n\talarm_fired = 1;\n\tif (0) sig = 0;\t/* compiler warning */\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcat",
          "args": [
            "tmp",
            "\": failed to create file.\\n\""
          ],
          "line": 1634
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mkstemp",
          "args": [
            "tmp"
          ],
          "line": 1632
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "tmp",
            "\"%s.XXXXXX\"",
            "trackpre"
          ],
          "line": 1631
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "trackdir",
            "\"unset\""
          ],
          "line": 1629
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "trackdir",
            "\"none\""
          ],
          "line": 1625
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"x11vnc.h\"\n\nstatic void set_trackdir(void) {\n\tchar tmp[256];\n\tstruct stat sb;\n\tif (!strcmp(trackdir, \"none\")) {\n\t\ttrackdir = NULL;\n\t\treturn;\n\t}\n\tif (!strcmp(trackdir, \"unset\")) {\n\t\tint fd;\n\t\tsprintf(tmp, \"%s.XXXXXX\", trackpre);\n\t\tfd = mkstemp(tmp);\n\t\tif (fd < 0) {\n\t\t\tstrcat(tmp, \": failed to create file.\\n\");\n\t\t\texiter(tmp, 1);\n\t\t}\n\t\t/* XXX race */\n\t\tclose(fd);\n\t\tunlink(tmp);\n\t\tif (mkdir(tmp, 0700) != 0) {\n\t\t\tstrcat(tmp, \": failed to create dir.\\n\");\n\t\t\texiter(tmp, 1);\n\t\t}\n\t\ttrackdir = strdup(tmp);\n\t}\n\tif (stat(trackdir, &sb) != 0) {\n\t\tif (mkdir(trackdir, 0700) != 0) {\n\t\t\texiter(\"could not make trackdir.\\n\", 1);\n\t\t}\n\t} else if (! S_ISDIR(sb.st_mode)) {\n\t\texiter(\"trackdir not a directory.\\n\", 1);\n\t}\n\ttracktmp = (char *) calloc(1000 + strlen(trackdir), 1);\n}"
  },
  {
    "function_name": "exiter",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/appshare.c",
    "lines": "1615-1620",
    "snippet": "static void exiter(char *msg, int rc) {\n\tfprintf(stderr, \"%s\", msg);\n\tff();\n\tkill_helper_pid();\n\texit(rc);\n}",
    "includes": [
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "rc"
          ],
          "line": 1619
        },
        "resolved": true,
        "details": {
          "function_name": "clean_up_exit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/cleanup.c",
          "lines": "151-266",
          "snippet": "void clean_up_exit(int ret) {\n\tstatic int depth = 0;\n\texit_flag = 1;\n\n\tif (depth++ > 2) {\n\t\texit(ret);\n\t}\n\n\tif (icon_mode) {\n\t\tclean_icon_mode();\n\t}\n\n\t/* remove the shm areas: */\n\tclean_shm(0);\n\n\tstop_stunnel();\n\tif (use_openssl) {\n\t\tssl_helper_pid(0, 0);\t/* killall */\n\t}\n\n\tif (ssh_pid > 0) {\n\t\tkill(ssh_pid, SIGTERM);\n\t\tssh_pid = 0;\n\t}\n\n#ifdef MACOSX\n\tif (client_connect_file) {\n\t\tif (strstr(client_connect_file, \"/tmp/x11vnc-macosx-remote\")\n\t\t    == client_connect_file) {\n\t\t\tunlink(client_connect_file);\n\t\t}\n\t}\n\tif (macosx_console) {\n\t\tmacosxCG_fini();\n\t}\n#endif\n\n\tif (pipeinput_fh != NULL) {\n\t\tpclose(pipeinput_fh);\n\t\tpipeinput_fh = NULL;\n\t}\n\n\tshutdown_uinput();\n\n\tif (unix_sock) {\n\t\tif (unix_sock_fd >= 0) {\n\t\t\trfbLog(\"deleting unix sock: %s\\n\", unix_sock);\n\t\t\tclose(unix_sock_fd);\n\t\t\tunix_sock_fd = -1;\n\t\t\tunlink(unix_sock);\n\t\t}\n\t}\n\n\tif (! dpy) {\t/* raw_rb hack */\n\t\tif (rm_flagfile) {\n\t\t\tunlink(rm_flagfile);\n\t\t\trm_flagfile = NULL;\n\t\t}\n\t\texit(ret);\n\t}\n\n\t/* X keyboard cleanups */\n\tdelete_added_keycodes(0);\n\n\t/* remove all created XInput2 devices */\n\tif(use_multipointer)\n\t    removeAllMDs(dpy);\n\n\tif (clear_mods == 1) {\n\t\tclear_modifiers(0);\n\t} else if (clear_mods == 2) {\n\t\tclear_keys();\n\t} else if (clear_mods == 3) {\n\t\tclear_keys();\n\t\tclear_locks();\n\t}\n\n\tif (no_autorepeat) {\n\t\tautorepeat(1, 0);\n\t}\n\tif (use_solid_bg) {\n\t\tsolid_bg(1);\n\t}\n\tif (ncache || ncache0) {\n\t\tkde_no_animate(1);\n\t}\n\tX_LOCK;\n\tXTestDiscard_wr(dpy);\n#if HAVE_LIBXDAMAGE\n\tif (xdamage) {\n\t\tXDamageDestroy(dpy, xdamage);\n\t}\n#endif\n#if HAVE_LIBXTRAP\n\tif (trap_ctx) {\n\t\tXEFreeTC(trap_ctx);\n\t}\n#endif\n\t/* XXX rdpy_ctrl, etc. cannot close w/o blocking */\n\tXCloseDisplay_wr(dpy);\n\tX_UNLOCK;\n\n\tfflush(stderr);\n\n\tif (rm_flagfile) {\n\t\tunlink(rm_flagfile);\n\t\trm_flagfile = NULL;\n\t}\n\n\tif (avahi) {\n\t\tavahi_cleanup();\n\t\tfflush(stderr);\n\t}\n\n\texit(ret);\n}",
          "includes": [
            "#include \"xi2_devices.h\"",
            "#include \"uinput.h\"",
            "#include \"xevents.h\"",
            "#include \"xrecord.h\"",
            "#include \"screen.h\"",
            "#include \"avahi.h\"",
            "#include \"macosxCG.h\"",
            "#include \"macosx.h\"",
            "#include \"connections.h\"",
            "#include \"sslhelper.h\"",
            "#include \"sslcmds.h\"",
            "#include \"unixpw.h\"",
            "#include \"solid.h\"",
            "#include \"gui.h\"",
            "#include \"scan.h\"",
            "#include \"keyboard.h\"",
            "#include \"remote.h\"",
            "#include \"xdamage.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void clean_up_exit(int ret);",
            "int known_sigpipe_mode(char *s);",
            "static int exit_flag = 0;",
            "static void clean_icon_mode(void);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xi2_devices.h\"\n#include \"uinput.h\"\n#include \"xevents.h\"\n#include \"xrecord.h\"\n#include \"screen.h\"\n#include \"avahi.h\"\n#include \"macosxCG.h\"\n#include \"macosx.h\"\n#include \"connections.h\"\n#include \"sslhelper.h\"\n#include \"sslcmds.h\"\n#include \"unixpw.h\"\n#include \"solid.h\"\n#include \"gui.h\"\n#include \"scan.h\"\n#include \"keyboard.h\"\n#include \"remote.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nvoid clean_up_exit(int ret);\nint known_sigpipe_mode(char *s);\nstatic int exit_flag = 0;\nstatic void clean_icon_mode(void);\n\nvoid clean_up_exit(int ret) {\n\tstatic int depth = 0;\n\texit_flag = 1;\n\n\tif (depth++ > 2) {\n\t\texit(ret);\n\t}\n\n\tif (icon_mode) {\n\t\tclean_icon_mode();\n\t}\n\n\t/* remove the shm areas: */\n\tclean_shm(0);\n\n\tstop_stunnel();\n\tif (use_openssl) {\n\t\tssl_helper_pid(0, 0);\t/* killall */\n\t}\n\n\tif (ssh_pid > 0) {\n\t\tkill(ssh_pid, SIGTERM);\n\t\tssh_pid = 0;\n\t}\n\n#ifdef MACOSX\n\tif (client_connect_file) {\n\t\tif (strstr(client_connect_file, \"/tmp/x11vnc-macosx-remote\")\n\t\t    == client_connect_file) {\n\t\t\tunlink(client_connect_file);\n\t\t}\n\t}\n\tif (macosx_console) {\n\t\tmacosxCG_fini();\n\t}\n#endif\n\n\tif (pipeinput_fh != NULL) {\n\t\tpclose(pipeinput_fh);\n\t\tpipeinput_fh = NULL;\n\t}\n\n\tshutdown_uinput();\n\n\tif (unix_sock) {\n\t\tif (unix_sock_fd >= 0) {\n\t\t\trfbLog(\"deleting unix sock: %s\\n\", unix_sock);\n\t\t\tclose(unix_sock_fd);\n\t\t\tunix_sock_fd = -1;\n\t\t\tunlink(unix_sock);\n\t\t}\n\t}\n\n\tif (! dpy) {\t/* raw_rb hack */\n\t\tif (rm_flagfile) {\n\t\t\tunlink(rm_flagfile);\n\t\t\trm_flagfile = NULL;\n\t\t}\n\t\texit(ret);\n\t}\n\n\t/* X keyboard cleanups */\n\tdelete_added_keycodes(0);\n\n\t/* remove all created XInput2 devices */\n\tif(use_multipointer)\n\t    removeAllMDs(dpy);\n\n\tif (clear_mods == 1) {\n\t\tclear_modifiers(0);\n\t} else if (clear_mods == 2) {\n\t\tclear_keys();\n\t} else if (clear_mods == 3) {\n\t\tclear_keys();\n\t\tclear_locks();\n\t}\n\n\tif (no_autorepeat) {\n\t\tautorepeat(1, 0);\n\t}\n\tif (use_solid_bg) {\n\t\tsolid_bg(1);\n\t}\n\tif (ncache || ncache0) {\n\t\tkde_no_animate(1);\n\t}\n\tX_LOCK;\n\tXTestDiscard_wr(dpy);\n#if HAVE_LIBXDAMAGE\n\tif (xdamage) {\n\t\tXDamageDestroy(dpy, xdamage);\n\t}\n#endif\n#if HAVE_LIBXTRAP\n\tif (trap_ctx) {\n\t\tXEFreeTC(trap_ctx);\n\t}\n#endif\n\t/* XXX rdpy_ctrl, etc. cannot close w/o blocking */\n\tXCloseDisplay_wr(dpy);\n\tX_UNLOCK;\n\n\tfflush(stderr);\n\n\tif (rm_flagfile) {\n\t\tunlink(rm_flagfile);\n\t\trm_flagfile = NULL;\n\t}\n\n\tif (avahi) {\n\t\tavahi_cleanup();\n\t\tfflush(stderr);\n\t}\n\n\texit(ret);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kill_helper_pid",
          "args": [],
          "line": 1618
        },
        "resolved": true,
        "details": {
          "function_name": "kill_helper_pid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/appshare.c",
          "lines": "546-559",
          "snippet": "static void kill_helper_pid(void) {\n\tint status;\n\tif (helper_pid <= 0) {\n\t\treturn;\n\t}\n\tfprintf(stderr, \"stopping: helper_pid: %d\\n\", (int) helper_pid);\n\tkill(helper_pid, SIGTERM);\n\tusleep(50 * 1000);\n\tkill(helper_pid, SIGKILL);\n\tusleep(25 * 1000);\n#if LIBVNCSERVER_HAVE_SYS_WAIT_H && HAVE_WAITPID \n\twaitpid(helper_pid, &status, WNOHANG); \n#endif\n}",
          "includes": [
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"x11vnc.h\"\n\nstatic void kill_helper_pid(void) {\n\tint status;\n\tif (helper_pid <= 0) {\n\t\treturn;\n\t}\n\tfprintf(stderr, \"stopping: helper_pid: %d\\n\", (int) helper_pid);\n\tkill(helper_pid, SIGTERM);\n\tusleep(50 * 1000);\n\tkill(helper_pid, SIGKILL);\n\tusleep(25 * 1000);\n#if LIBVNCSERVER_HAVE_SYS_WAIT_H && HAVE_WAITPID \n\twaitpid(helper_pid, &status, WNOHANG); \n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "ff",
          "args": [],
          "line": 1617
        },
        "resolved": true,
        "details": {
          "function_name": "ff",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/appshare.c",
          "lines": "293-296",
          "snippet": "static void ff(void) {\n\tfflush(stdout);\n\tfflush(stderr);\n}",
          "includes": [
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"x11vnc.h\"\n\nstatic void ff(void) {\n\tfflush(stdout);\n\tfflush(stderr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"%s\"",
            "msg"
          ],
          "line": 1616
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"x11vnc.h\"\n\nstatic void exiter(char *msg, int rc) {\n\tfprintf(stderr, \"%s\", msg);\n\tff();\n\tkill_helper_pid();\n\texit(rc);\n}"
  },
  {
    "function_name": "update",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/appshare.c",
    "lines": "1559-1613",
    "snippet": "static void update(void) {\n\tint i, app_ok = 0;\n\tif (last_event_type != PropertyNotify) {\n\t\tif (appshare_debug) fprintf(stderr, \"\\nupdate ...\\n\");\n\t} else if (appshare_debug > 1) {\n\t\tfprintf(stderr, \"update ... propertynotify\\n\");\n\t}\n\tif (!check_control()) {\n\t\treturn;\n\t}\n\tfor (i=0; i < WMAX; i++) {\n\t\tWindow win = watch[i];\n\t\tif (win == None) {\n\t\t\tcontinue;\n\t\t}\n\t\tif (!win_attr(win)) {\n\t\t\tdestroy_win(win);\n\t\t\tcontinue;\n\t\t}\n\t\tif (find_app(win) >= 0) {\n\t\t\tapp_ok++;\n\t\t}\n\t\tif (state[i] == 0) {\n\t\t\tif (attr.map_state == IsViewable) {\n\t\t\t\tif (skip_menus) {\n\t\t\t\t\tWindow inside = check_inside(win);\n\t\t\t\t\tif (inside != None) {\n\t\t\t\t\t\tif (appshare_debug) {fprintf(stderr, \"skip_menus: window 0x%lx is inside of 0x%lx, not tracking it.\\n\", win, inside); ff();}\n\t\t\t\t\t\tdelete_win(win);\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tlaunch(win);\n\t\t\t\tstate[i] = 1;\n\t\t\t}\n\t\t} else if (state[i] == 1) {\n\t\t\tif (attr.map_state != IsViewable) {\n\t\t\t\tstop(win);\n\t\t\t\tstate[i] = 0;\n\t\t\t}\n\t\t}\n\t}\n\tif (exit_no_app_win && !app_ok) {\n\t\tfor (i=0; i < AMAX; i++) {\n\t\t\tif (apps[i] != None) {\n\t\t\t\tfprintf(stdout, \"main application window is gone: 0x%lx\\n\", apps[i]);\n\t\t\t}\n\t\t}\n\t\tff();\n\t\tappshare_cleanup(0);\n\t}\n\tif (last_event_type != PropertyNotify) {\n\t\tif (appshare_debug) {fprintf(stderr, \"update done.\\n\"); ff();}\n\t}\n}",
    "includes": [
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [
      "#define AMAX 32",
      "#define WMAX 192"
    ],
    "globals_used": [
      "extern char *get_xprop(char *prop, Window win);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ff",
          "args": [],
          "line": 1611
        },
        "resolved": true,
        "details": {
          "function_name": "ff",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/appshare.c",
          "lines": "293-296",
          "snippet": "static void ff(void) {\n\tfflush(stdout);\n\tfflush(stderr);\n}",
          "includes": [
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"x11vnc.h\"\n\nstatic void ff(void) {\n\tfflush(stdout);\n\tfflush(stderr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"update done.\\n\""
          ],
          "line": 1611
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "appshare_cleanup",
          "args": [
            "0"
          ],
          "line": 1608
        },
        "resolved": true,
        "details": {
          "function_name": "appshare_cleanup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/appshare.c",
          "lines": "630-688",
          "snippet": "static void appshare_cleanup(int s) {\n\tint i;\n\tif (s) {}\n\n\tif (use_forever) {\n\t\t/* launch this backup in case they kill -9 us before we terminate everything */\n\t\tchar cmd[1000];\n\t\tsprintf(cmd, \"(sleep 3; pkill -TERM -f '%s') &\", unique_tag);\n\t\tif (appshare_debug) fprintf(stderr, \"%s\\n\", cmd);\n\t\tsystem(cmd);\n\t}\n\n\tfor (i=0; i < WMAX; i++) {\n\t\tif (watch[i] != None) {\n\t\t\tstop(watch[i]);\n\t\t}\n\t}\n\n\tif (trackdir) {\n\t\tDIR *dir = opendir(trackdir);\n\t\tif (dir) {\n\t\t\tstruct dirent *dp;\n\t\t\twhile ( (dp = readdir(dir)) != NULL) {\n\t\t\t\tchar *name = dp->d_name;\n\t\t\t\tif (!strcmp(name, \".\") || !strcmp(name, \"..\")) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (strstr(name, \"0x\") != name) {\n\t\t\t\t\tfprintf(stderr, \"skipping: %s\\n\", name);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (!appshare_debug) {\n\t\t\t\t\tfprintf(stderr, \"removing: %s\\n\", name);\n\t\t\t\t\tsprintf(tracktmp, \"%s/%s\", trackdir, name);\n\t\t\t\t\tunlink(tracktmp);\n\t\t\t\t} else {\n\t\t\t\t\tif (appshare_debug) fprintf(stderr, \"keeping:  %s\\n\", name);\n\t\t\t\t}\n\t\t\t}\n\t\t\tclosedir(dir);\n\t\t}\n\t\tif (!appshare_debug) {\n\t\t\tif (strstr(trackdir, trackpre) == trackdir) {\n\t\t\t\tif (appshare_debug) fprintf(stderr, \"removing: %s\\n\", trackdir);\n\t\t\t\trmdir(trackdir);\n\t\t\t}\n\t\t}\n\t\tff();\n\t}\n\n\tkill_helper_pid();\n\t\t\t\n#if !NO_X11\n\tXCloseDisplay(dpy);\n#endif\n\tfprintf(stdout, \"done.\\n\");\n\tff();\n\texit(0);\n}",
          "includes": [
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [
            "#define WMAX 192"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"x11vnc.h\"\n\n#define WMAX 192\n\nstatic void appshare_cleanup(int s) {\n\tint i;\n\tif (s) {}\n\n\tif (use_forever) {\n\t\t/* launch this backup in case they kill -9 us before we terminate everything */\n\t\tchar cmd[1000];\n\t\tsprintf(cmd, \"(sleep 3; pkill -TERM -f '%s') &\", unique_tag);\n\t\tif (appshare_debug) fprintf(stderr, \"%s\\n\", cmd);\n\t\tsystem(cmd);\n\t}\n\n\tfor (i=0; i < WMAX; i++) {\n\t\tif (watch[i] != None) {\n\t\t\tstop(watch[i]);\n\t\t}\n\t}\n\n\tif (trackdir) {\n\t\tDIR *dir = opendir(trackdir);\n\t\tif (dir) {\n\t\t\tstruct dirent *dp;\n\t\t\twhile ( (dp = readdir(dir)) != NULL) {\n\t\t\t\tchar *name = dp->d_name;\n\t\t\t\tif (!strcmp(name, \".\") || !strcmp(name, \"..\")) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (strstr(name, \"0x\") != name) {\n\t\t\t\t\tfprintf(stderr, \"skipping: %s\\n\", name);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (!appshare_debug) {\n\t\t\t\t\tfprintf(stderr, \"removing: %s\\n\", name);\n\t\t\t\t\tsprintf(tracktmp, \"%s/%s\", trackdir, name);\n\t\t\t\t\tunlink(tracktmp);\n\t\t\t\t} else {\n\t\t\t\t\tif (appshare_debug) fprintf(stderr, \"keeping:  %s\\n\", name);\n\t\t\t\t}\n\t\t\t}\n\t\t\tclosedir(dir);\n\t\t}\n\t\tif (!appshare_debug) {\n\t\t\tif (strstr(trackdir, trackpre) == trackdir) {\n\t\t\t\tif (appshare_debug) fprintf(stderr, \"removing: %s\\n\", trackdir);\n\t\t\t\trmdir(trackdir);\n\t\t\t}\n\t\t}\n\t\tff();\n\t}\n\n\tkill_helper_pid();\n\t\t\t\n#if !NO_X11\n\tXCloseDisplay(dpy);\n#endif\n\tfprintf(stdout, \"done.\\n\");\n\tff();\n\texit(0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stdout",
            "\"main application window is gone: 0x%lx\\n\"",
            "apps[i]"
          ],
          "line": 1604
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "stop",
          "args": [
            "win"
          ],
          "line": 1596
        },
        "resolved": true,
        "details": {
          "function_name": "stop",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/appshare.c",
          "lines": "505-544",
          "snippet": "static void stop(Window win) {\n\tchar *cmd;\n\tint pid = -1;\n\tint f = find_win(win);\n\tif (f < 0 || win == None) {\n\t\treturn;\n\t}\n\tif (state[f] == 0) {\n\t\treturn;\n\t}\n\tif (trackdir) {\n\t\tpid = trackdir_pid(win);\n\t\tif (pid > 0) {\n\t\t\tif (appshare_debug) {fprintf(stderr,\n\t\t\t    \"sending SIGTERM to: %d\\n\", pid); ff();}\n\t\t\tkill((pid_t) pid, SIGTERM);\n\t\t}\n\t}\n\n\tcmd = (char *) malloc(1000 + strlen(x11vnc));\n\tsprintf(cmd, \"pkill -TERM -f '%s %s 0x%lx -bg'\", x11vnc, id_opt, win);\n\tif (appshare_debug) {\n\t\tfprintf(stdout, \"stopping:  0x%08lx - %s\\n\", win, cmd);\n\t} else {\n\t\tfprintf(stdout, \"stopping:  x11vnc for window 0x%08lx  \"\n\t\t    \"(pid: %d)\\n\", win, pid);\n\t}\n\tff();\n\tsystem(cmd);\n\n\tsprintf(cmd, \"(sleep 0.25 2>/dev/null || sleep 1; pkill -KILL -f '%s \"\n\t    \"%s 0x%lx -bg') &\", x11vnc, id_opt, win);\n\tsystem(cmd);\n\n\tif (trackdir) {\n\t\ttrackdir_cleanup(win);\n\t}\n\n\tfree(cmd);\n}",
          "includes": [
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "extern char *get_xprop(char *prop, Window win);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"x11vnc.h\"\n\nextern char *get_xprop(char *prop, Window win);\n\nstatic void stop(Window win) {\n\tchar *cmd;\n\tint pid = -1;\n\tint f = find_win(win);\n\tif (f < 0 || win == None) {\n\t\treturn;\n\t}\n\tif (state[f] == 0) {\n\t\treturn;\n\t}\n\tif (trackdir) {\n\t\tpid = trackdir_pid(win);\n\t\tif (pid > 0) {\n\t\t\tif (appshare_debug) {fprintf(stderr,\n\t\t\t    \"sending SIGTERM to: %d\\n\", pid); ff();}\n\t\t\tkill((pid_t) pid, SIGTERM);\n\t\t}\n\t}\n\n\tcmd = (char *) malloc(1000 + strlen(x11vnc));\n\tsprintf(cmd, \"pkill -TERM -f '%s %s 0x%lx -bg'\", x11vnc, id_opt, win);\n\tif (appshare_debug) {\n\t\tfprintf(stdout, \"stopping:  0x%08lx - %s\\n\", win, cmd);\n\t} else {\n\t\tfprintf(stdout, \"stopping:  x11vnc for window 0x%08lx  \"\n\t\t    \"(pid: %d)\\n\", win, pid);\n\t}\n\tff();\n\tsystem(cmd);\n\n\tsprintf(cmd, \"(sleep 0.25 2>/dev/null || sleep 1; pkill -KILL -f '%s \"\n\t    \"%s 0x%lx -bg') &\", x11vnc, id_opt, win);\n\tsystem(cmd);\n\n\tif (trackdir) {\n\t\ttrackdir_cleanup(win);\n\t}\n\n\tfree(cmd);\n}"
        }
      },
      {
        "call_info": {
          "callee": "launch",
          "args": [
            "win"
          ],
          "line": 1591
        },
        "resolved": true,
        "details": {
          "function_name": "launch",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/appshare.c",
          "lines": "393-503",
          "snippet": "static void launch(Window win) {\n\tchar *cmd, *tmp, *connto, *name;\n\tint len, timeo = 30, uf = use_forever;\n\tint w = 0, h = 0, x = 0, y = 0;\n\n\tif (win_attr(win)) {\n\t\t/* maybe switch to debug only. */\n\t\tw = attr.width;\n\t\th = attr.height;\n\t\tget_xy(win, &x, &y);\n\t}\n\n\tget_wm_name(win, &name);\n\n\tif (strstr(x11vnc_args, \"-once\")) {\n\t\tuf = 0;\n\t}\n\n\tif (control) {\n\t\tint i = 0;\n\t\tlen = 0;\n\t\tfor (i=0; i < CMAX; i++) {\n\t\t\tif (clients[i] != NULL) {\n\t\t\t\tlen += strlen(clients[i]) + 2;\n\t\t\t}\n\t\t}\n\t\tconnto = (char *) calloc(len, 1);\n\t\tfor (i=0; i < CMAX; i++) {\n\t\t\tif (clients[i] != NULL) {\n\t\t\t\tif (connto[0] != '\\0') {\n\t\t\t\t\tstrcat(connto, \",\");\n\t\t\t\t}\n\t\t\t\tstrcat(connto, clients[i]);\n\t\t\t}\n\t\t}\n\t} else {\n\t\tconnto = strdup(connect_to);\n\t}\n\tif (!strcmp(connto, \"\")) {\n\t\ttimeo = 0;\n\t}\n\tif (uf) {\n\t\ttimeo = 0;\n\t}\n\t\n\tlen = 1000 + strlen(x11vnc) + strlen(connto) + strlen(x11vnc_args)\n\t    + 3 * (trackdir ? strlen(trackdir) : 100);\n\n\tcmd = (char *) calloc(len, 1);\n\ttmp = (char *) calloc(len, 1);\n\n\tsprintf(cmd, \"%s %s 0x%lx -bg -quiet %s -nopw -rfbport 0 \"\n\t    \"-timeout %d -noxdamage -noxinerama -norc -repeat -speeds dsl \"\n\t    \"-env X11VNC_AVOID_WINDOWS=never -env X11VNC_APPSHARE_ACTIVE=1 \"\n\t    \"-env X11VNC_NO_CHECK_PM=1 -env %s -novncconnect -shared -nonap \"\n\t    \"-remote_prefix X11VNC_APPSHARE_CMD:\",\n\t    x11vnc, id_opt, win, use_forever ? \"-forever\" : \"-once\", timeo, unique_tag);\n\n\tif (trackdir) {\n\t\tFILE *f;\n\t\tsprintf(tracktmp, \" -noquiet -o %s/0x%lx.log\", trackdir, win);\n\t\tstrcat(cmd, tracktmp);\n\t\tsprintf(tracktmp, \"%s/0x%lx.connect\", trackdir, win);\n\t\tf = fopen(tracktmp, \"w\");\n\t\tif (f) {\n\t\t\tfprintf(f, \"%s\", connto);\n\t\t\tfclose(f);\n\t\t\tsprintf(tmp, \" -connect_or_exit '%s'\", tracktmp);\n\t\t\tstrcat(cmd, tmp);\n\t\t} else {\n\t\t\tsprintf(tmp, \" -connect_or_exit '%s'\", connto);\n\t\t\tstrcat(cmd, tmp);\n\t\t}\n\t} else {\n\t\tif (!strcmp(connto, \"\")) {\n\t\t\tsprintf(tmp, \" -connect '%s'\", connto);\n\t\t} else {\n\t\t\tsprintf(tmp, \" -connect_or_exit '%s'\", connto);\n\t\t}\n\t\tstrcat(cmd, tmp);\n\t}\n\tif (uf) {\n\t\tchar *q = strstr(cmd, \"-connect_or_exit\");\n\t\tif (q) q = strstr(q, \"_or_exit\");\n\t\tif (q) {\n\t\t\tunsigned int i;\n\t\t\tfor (i=0; i < strlen(\"_or_exit\"); i++) {\n\t\t\t\t*q = ' ';\n\t\t\t\tq++;\n\t\t\t}\n\t\t}\n\t}\n\n\tstrcat(cmd, \" \");\n\tstrcat(cmd, x11vnc_args);\n\n\tfprintf(stdout, \"launching: x11vnc for window 0x%08lx %dx%d+%d+%d \\\"%s\\\"\\n\",\n\t    win, w, h, x, y, name);\n\n\tif (appshare_debug) {\n\t\tfprintf(stderr, \"\\nrunning:   %s\\n\\n\", cmd);\n\t}\n\tff();\n\n\tsystem(cmd);\n\n\tfree(cmd);\n\tfree(tmp);\n\tfree(connto);\n\tfree(name);\n}",
          "includes": [
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [
            "#define CMAX 128"
          ],
          "globals_used": [
            "extern char *get_xprop(char *prop, Window win);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"x11vnc.h\"\n\n#define CMAX 128\n\nextern char *get_xprop(char *prop, Window win);\n\nstatic void launch(Window win) {\n\tchar *cmd, *tmp, *connto, *name;\n\tint len, timeo = 30, uf = use_forever;\n\tint w = 0, h = 0, x = 0, y = 0;\n\n\tif (win_attr(win)) {\n\t\t/* maybe switch to debug only. */\n\t\tw = attr.width;\n\t\th = attr.height;\n\t\tget_xy(win, &x, &y);\n\t}\n\n\tget_wm_name(win, &name);\n\n\tif (strstr(x11vnc_args, \"-once\")) {\n\t\tuf = 0;\n\t}\n\n\tif (control) {\n\t\tint i = 0;\n\t\tlen = 0;\n\t\tfor (i=0; i < CMAX; i++) {\n\t\t\tif (clients[i] != NULL) {\n\t\t\t\tlen += strlen(clients[i]) + 2;\n\t\t\t}\n\t\t}\n\t\tconnto = (char *) calloc(len, 1);\n\t\tfor (i=0; i < CMAX; i++) {\n\t\t\tif (clients[i] != NULL) {\n\t\t\t\tif (connto[0] != '\\0') {\n\t\t\t\t\tstrcat(connto, \",\");\n\t\t\t\t}\n\t\t\t\tstrcat(connto, clients[i]);\n\t\t\t}\n\t\t}\n\t} else {\n\t\tconnto = strdup(connect_to);\n\t}\n\tif (!strcmp(connto, \"\")) {\n\t\ttimeo = 0;\n\t}\n\tif (uf) {\n\t\ttimeo = 0;\n\t}\n\t\n\tlen = 1000 + strlen(x11vnc) + strlen(connto) + strlen(x11vnc_args)\n\t    + 3 * (trackdir ? strlen(trackdir) : 100);\n\n\tcmd = (char *) calloc(len, 1);\n\ttmp = (char *) calloc(len, 1);\n\n\tsprintf(cmd, \"%s %s 0x%lx -bg -quiet %s -nopw -rfbport 0 \"\n\t    \"-timeout %d -noxdamage -noxinerama -norc -repeat -speeds dsl \"\n\t    \"-env X11VNC_AVOID_WINDOWS=never -env X11VNC_APPSHARE_ACTIVE=1 \"\n\t    \"-env X11VNC_NO_CHECK_PM=1 -env %s -novncconnect -shared -nonap \"\n\t    \"-remote_prefix X11VNC_APPSHARE_CMD:\",\n\t    x11vnc, id_opt, win, use_forever ? \"-forever\" : \"-once\", timeo, unique_tag);\n\n\tif (trackdir) {\n\t\tFILE *f;\n\t\tsprintf(tracktmp, \" -noquiet -o %s/0x%lx.log\", trackdir, win);\n\t\tstrcat(cmd, tracktmp);\n\t\tsprintf(tracktmp, \"%s/0x%lx.connect\", trackdir, win);\n\t\tf = fopen(tracktmp, \"w\");\n\t\tif (f) {\n\t\t\tfprintf(f, \"%s\", connto);\n\t\t\tfclose(f);\n\t\t\tsprintf(tmp, \" -connect_or_exit '%s'\", tracktmp);\n\t\t\tstrcat(cmd, tmp);\n\t\t} else {\n\t\t\tsprintf(tmp, \" -connect_or_exit '%s'\", connto);\n\t\t\tstrcat(cmd, tmp);\n\t\t}\n\t} else {\n\t\tif (!strcmp(connto, \"\")) {\n\t\t\tsprintf(tmp, \" -connect '%s'\", connto);\n\t\t} else {\n\t\t\tsprintf(tmp, \" -connect_or_exit '%s'\", connto);\n\t\t}\n\t\tstrcat(cmd, tmp);\n\t}\n\tif (uf) {\n\t\tchar *q = strstr(cmd, \"-connect_or_exit\");\n\t\tif (q) q = strstr(q, \"_or_exit\");\n\t\tif (q) {\n\t\t\tunsigned int i;\n\t\t\tfor (i=0; i < strlen(\"_or_exit\"); i++) {\n\t\t\t\t*q = ' ';\n\t\t\t\tq++;\n\t\t\t}\n\t\t}\n\t}\n\n\tstrcat(cmd, \" \");\n\tstrcat(cmd, x11vnc_args);\n\n\tfprintf(stdout, \"launching: x11vnc for window 0x%08lx %dx%d+%d+%d \\\"%s\\\"\\n\",\n\t    win, w, h, x, y, name);\n\n\tif (appshare_debug) {\n\t\tfprintf(stderr, \"\\nrunning:   %s\\n\\n\", cmd);\n\t}\n\tff();\n\n\tsystem(cmd);\n\n\tfree(cmd);\n\tfree(tmp);\n\tfree(connto);\n\tfree(name);\n}"
        }
      },
      {
        "call_info": {
          "callee": "delete_win",
          "args": [
            "win"
          ],
          "line": 1587
        },
        "resolved": true,
        "details": {
          "function_name": "delete_win",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/appshare.c",
          "lines": "890-899",
          "snippet": "static void delete_win(Window win) {\n\tint i;\n\tfor (i=0; i < WMAX; i++) {\n\t\tif (watch[i] == win) {\n\t\t\twatch[i] = None;\n\t\t\tstate[i] = 0;\n\t\t\tif (appshare_debug) {fprintf(stderr, \"deleting: 0x%lx at %d\\n\", win, i); ff();}\n\t\t}\n\t}\n}",
          "includes": [
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [
            "#define WMAX 192"
          ],
          "globals_used": [
            "extern char *get_xprop(char *prop, Window win);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"x11vnc.h\"\n\n#define WMAX 192\n\nextern char *get_xprop(char *prop, Window win);\n\nstatic void delete_win(Window win) {\n\tint i;\n\tfor (i=0; i < WMAX; i++) {\n\t\tif (watch[i] == win) {\n\t\t\twatch[i] = None;\n\t\t\tstate[i] = 0;\n\t\t\tif (appshare_debug) {fprintf(stderr, \"deleting: 0x%lx at %d\\n\", win, i); ff();}\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"skip_menus: window 0x%lx is inside of 0x%lx, not tracking it.\\n\"",
            "win",
            "inside"
          ],
          "line": 1586
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "check_inside",
          "args": [
            "win"
          ],
          "line": 1584
        },
        "resolved": true,
        "details": {
          "function_name": "check_inside",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/appshare.c",
          "lines": "800-868",
          "snippet": "static Window check_inside(Window win) {\n\tint i, nwin = 0;\n\tint w, h, x, y;\n\tint Ws[WMAX], Hs[WMAX], Xs[WMAX], Ys[WMAX];\n\tWindow wins[WMAX];\n\n\tif (!win_attr(win)) {\n\t\treturn None; \n\t}\n\n\t/* store them first to give the win app more time to settle.  */\n\tfor (i=0; i < WMAX; i++) {\n\t\tint X, Y;\n\t\tWindow wchk = watch[i];\n\t\tif (wchk == None) {\n\t\t\tcontinue;\n\t\t}\n\t\tif (state[i] == 0) {\n\t\t\tcontinue;\n\t\t}\n\t\tif (!win_attr(wchk)) {\n\t\t\tcontinue;\n\t\t}\n\t\tif (!get_xy(wchk, &X, &Y)) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tXs[nwin] = X;\n\t\tYs[nwin] = Y;\n\t\tWs[nwin] = attr.width;\n\t\tHs[nwin] = attr.height;\n\t\twins[nwin] = wchk;\n\t\tnwin++;\n\t}\n\n\tif (nwin == 0) {\n\t\treturn None;\n\t}\n\n\tif (!win_attr(win)) {\n\t\treturn None; \n\t}\n\tw = attr.width;\n\th = attr.height;\n\n\tget_xy(win, &x, &y);\n\tif (!get_xy(win, &x, &y)) {\n\t\treturn None;\n\t}\n\n\tfor (i=0; i < nwin; i++) {\n\t\tint X, Y, W, H;\n\t\tWindow wchk = wins[i];\n\t\tX = Xs[i];\n\t\tY = Ys[i];\n\t\tW = Ws[i];\n\t\tH = Hs[i];\n\n\t\tif (appshare_debug) fprintf(stderr, \"check inside: 0x%lx  %dx%d+%d+%d %dx%d+%d+%d\\n\", wchk, w, h, x, y, W, H, X, Y);\n\n\t\tif (X <= x && Y <= y) {\n\t\t\tif (x + w  <= X + W && y + h < Y + H) {\n\t\t\t\treturn wchk;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn None;\n}",
          "includes": [
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [
            "#define WMAX 192"
          ],
          "globals_used": [
            "extern char *get_xprop(char *prop, Window win);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"x11vnc.h\"\n\n#define WMAX 192\n\nextern char *get_xprop(char *prop, Window win);\n\nstatic Window check_inside(Window win) {\n\tint i, nwin = 0;\n\tint w, h, x, y;\n\tint Ws[WMAX], Hs[WMAX], Xs[WMAX], Ys[WMAX];\n\tWindow wins[WMAX];\n\n\tif (!win_attr(win)) {\n\t\treturn None; \n\t}\n\n\t/* store them first to give the win app more time to settle.  */\n\tfor (i=0; i < WMAX; i++) {\n\t\tint X, Y;\n\t\tWindow wchk = watch[i];\n\t\tif (wchk == None) {\n\t\t\tcontinue;\n\t\t}\n\t\tif (state[i] == 0) {\n\t\t\tcontinue;\n\t\t}\n\t\tif (!win_attr(wchk)) {\n\t\t\tcontinue;\n\t\t}\n\t\tif (!get_xy(wchk, &X, &Y)) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tXs[nwin] = X;\n\t\tYs[nwin] = Y;\n\t\tWs[nwin] = attr.width;\n\t\tHs[nwin] = attr.height;\n\t\twins[nwin] = wchk;\n\t\tnwin++;\n\t}\n\n\tif (nwin == 0) {\n\t\treturn None;\n\t}\n\n\tif (!win_attr(win)) {\n\t\treturn None; \n\t}\n\tw = attr.width;\n\th = attr.height;\n\n\tget_xy(win, &x, &y);\n\tif (!get_xy(win, &x, &y)) {\n\t\treturn None;\n\t}\n\n\tfor (i=0; i < nwin; i++) {\n\t\tint X, Y, W, H;\n\t\tWindow wchk = wins[i];\n\t\tX = Xs[i];\n\t\tY = Ys[i];\n\t\tW = Ws[i];\n\t\tH = Hs[i];\n\n\t\tif (appshare_debug) fprintf(stderr, \"check inside: 0x%lx  %dx%d+%d+%d %dx%d+%d+%d\\n\", wchk, w, h, x, y, W, H, X, Y);\n\n\t\tif (X <= x && Y <= y) {\n\t\t\tif (x + w  <= X + W && y + h < Y + H) {\n\t\t\t\treturn wchk;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn None;\n}"
        }
      },
      {
        "call_info": {
          "callee": "find_app",
          "args": [
            "win"
          ],
          "line": 1578
        },
        "resolved": true,
        "details": {
          "function_name": "find_app",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/appshare.c",
          "lines": "308-316",
          "snippet": "static int find_app(Window app) {\n\tint i;\n\tfor (i=0; i < AMAX; i++) {\n\t\tif (apps[i] == app) {\n\t\t\treturn i;\n\t\t}\n\t}\n\treturn -1;\n}",
          "includes": [
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [
            "#define AMAX 32"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"x11vnc.h\"\n\n#define AMAX 32\n\nstatic int find_app(Window app) {\n\tint i;\n\tfor (i=0; i < AMAX; i++) {\n\t\tif (apps[i] == app) {\n\t\t\treturn i;\n\t\t}\n\t}\n\treturn -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "destroy_win",
          "args": [
            "win"
          ],
          "line": 1575
        },
        "resolved": true,
        "details": {
          "function_name": "destroy_win",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/appshare.c",
          "lines": "1103-1106",
          "snippet": "static void destroy_win(Window win) {\n\tstop(win);\n\tdelete_win(win);\n}",
          "includes": [
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "extern char *get_xprop(char *prop, Window win);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"x11vnc.h\"\n\nextern char *get_xprop(char *prop, Window win);\n\nstatic void destroy_win(Window win) {\n\tstop(win);\n\tdelete_win(win);\n}"
        }
      },
      {
        "call_info": {
          "callee": "win_attr",
          "args": [
            "win"
          ],
          "line": 1574
        },
        "resolved": true,
        "details": {
          "function_name": "win_attr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/appshare.c",
          "lines": "735-748",
          "snippet": "static int win_attr(Window win) {\n\tint ok = 0;\n#if !NO_X11\n        XErrorHandler old_handler = XSetErrorHandler(trap_xerror);\n\tok = XGetWindowAttributes(dpy, win, &attr);\n       \tXSetErrorHandler(old_handler);\n#endif\n\n\tif (ok) {\n\t\treturn 1;\n\t} else {\n\t\treturn 0;\n\t}\n}",
          "includes": [
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "extern char *get_xprop(char *prop, Window win);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"x11vnc.h\"\n\nextern char *get_xprop(char *prop, Window win);\n\nstatic int win_attr(Window win) {\n\tint ok = 0;\n#if !NO_X11\n        XErrorHandler old_handler = XSetErrorHandler(trap_xerror);\n\tok = XGetWindowAttributes(dpy, win, &attr);\n       \tXSetErrorHandler(old_handler);\n#endif\n\n\tif (ok) {\n\t\treturn 1;\n\t} else {\n\t\treturn 0;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "check_control",
          "args": [],
          "line": 1566
        },
        "resolved": true,
        "details": {
          "function_name": "check_control",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/appshare.c",
          "lines": "1519-1557",
          "snippet": "static int check_control(void) {\n\tstatic int last_size = -1;\n\tstatic time_t last_mtime = 0;\n\tstruct stat sb;\n\tchar *control_cmd;\n\n\tif (!control) {\n\t\treturn 1;\n\t}\n\n\tif (!strcmp(control, \"internal\")) {\n\t\treturn 1;\n\t}\n\t\t\n\tcontrol_cmd = (char *)malloc(strlen(control) + strlen(\".cmd\") + 1);\n\tsprintf(control_cmd, \"%s.cmd\", control);\n\tif (stat(control_cmd, &sb) == 0) {\n\t\tFILE *f;\n\t\tif (sb.st_size > 0) {\n\t\t\tprocess_control(control_cmd, 0);\n\t\t}\n\t\tf = fopen(control_cmd, \"w\");\n\t\tif (f) {\n\t\t\tfclose(f);\n\t\t}\n\t}\n\tfree(control_cmd);\n\n\tif (stat(control, &sb) != 0) {\n\t\treturn 1;\n\t}\n\tif (last_size == (int) sb.st_size && last_mtime == sb.st_mtime) {\n\t\treturn 1;\n\t}\n\tlast_size = (int) sb.st_size;\n\tlast_mtime = sb.st_mtime;\n\n\treturn process_control(control, 1);\n}",
          "includes": [
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"x11vnc.h\"\n\nstatic int check_control(void) {\n\tstatic int last_size = -1;\n\tstatic time_t last_mtime = 0;\n\tstruct stat sb;\n\tchar *control_cmd;\n\n\tif (!control) {\n\t\treturn 1;\n\t}\n\n\tif (!strcmp(control, \"internal\")) {\n\t\treturn 1;\n\t}\n\t\t\n\tcontrol_cmd = (char *)malloc(strlen(control) + strlen(\".cmd\") + 1);\n\tsprintf(control_cmd, \"%s.cmd\", control);\n\tif (stat(control_cmd, &sb) == 0) {\n\t\tFILE *f;\n\t\tif (sb.st_size > 0) {\n\t\t\tprocess_control(control_cmd, 0);\n\t\t}\n\t\tf = fopen(control_cmd, \"w\");\n\t\tif (f) {\n\t\t\tfclose(f);\n\t\t}\n\t}\n\tfree(control_cmd);\n\n\tif (stat(control, &sb) != 0) {\n\t\treturn 1;\n\t}\n\tif (last_size == (int) sb.st_size && last_mtime == sb.st_mtime) {\n\t\treturn 1;\n\t}\n\tlast_size = (int) sb.st_size;\n\tlast_mtime = sb.st_mtime;\n\n\treturn process_control(control, 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"update ... propertynotify\\n\""
          ],
          "line": 1564
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"\\nupdate ...\\n\""
          ],
          "line": 1562
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"x11vnc.h\"\n\n#define AMAX 32\n#define WMAX 192\n\nextern char *get_xprop(char *prop, Window win);\n\nstatic void update(void) {\n\tint i, app_ok = 0;\n\tif (last_event_type != PropertyNotify) {\n\t\tif (appshare_debug) fprintf(stderr, \"\\nupdate ...\\n\");\n\t} else if (appshare_debug > 1) {\n\t\tfprintf(stderr, \"update ... propertynotify\\n\");\n\t}\n\tif (!check_control()) {\n\t\treturn;\n\t}\n\tfor (i=0; i < WMAX; i++) {\n\t\tWindow win = watch[i];\n\t\tif (win == None) {\n\t\t\tcontinue;\n\t\t}\n\t\tif (!win_attr(win)) {\n\t\t\tdestroy_win(win);\n\t\t\tcontinue;\n\t\t}\n\t\tif (find_app(win) >= 0) {\n\t\t\tapp_ok++;\n\t\t}\n\t\tif (state[i] == 0) {\n\t\t\tif (attr.map_state == IsViewable) {\n\t\t\t\tif (skip_menus) {\n\t\t\t\t\tWindow inside = check_inside(win);\n\t\t\t\t\tif (inside != None) {\n\t\t\t\t\t\tif (appshare_debug) {fprintf(stderr, \"skip_menus: window 0x%lx is inside of 0x%lx, not tracking it.\\n\", win, inside); ff();}\n\t\t\t\t\t\tdelete_win(win);\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tlaunch(win);\n\t\t\t\tstate[i] = 1;\n\t\t\t}\n\t\t} else if (state[i] == 1) {\n\t\t\tif (attr.map_state != IsViewable) {\n\t\t\t\tstop(win);\n\t\t\t\tstate[i] = 0;\n\t\t\t}\n\t\t}\n\t}\n\tif (exit_no_app_win && !app_ok) {\n\t\tfor (i=0; i < AMAX; i++) {\n\t\t\tif (apps[i] != None) {\n\t\t\t\tfprintf(stdout, \"main application window is gone: 0x%lx\\n\", apps[i]);\n\t\t\t}\n\t\t}\n\t\tff();\n\t\tappshare_cleanup(0);\n\t}\n\tif (last_event_type != PropertyNotify) {\n\t\tif (appshare_debug) {fprintf(stderr, \"update done.\\n\"); ff();}\n\t}\n}"
  },
  {
    "function_name": "check_control",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/appshare.c",
    "lines": "1519-1557",
    "snippet": "static int check_control(void) {\n\tstatic int last_size = -1;\n\tstatic time_t last_mtime = 0;\n\tstruct stat sb;\n\tchar *control_cmd;\n\n\tif (!control) {\n\t\treturn 1;\n\t}\n\n\tif (!strcmp(control, \"internal\")) {\n\t\treturn 1;\n\t}\n\t\t\n\tcontrol_cmd = (char *)malloc(strlen(control) + strlen(\".cmd\") + 1);\n\tsprintf(control_cmd, \"%s.cmd\", control);\n\tif (stat(control_cmd, &sb) == 0) {\n\t\tFILE *f;\n\t\tif (sb.st_size > 0) {\n\t\t\tprocess_control(control_cmd, 0);\n\t\t}\n\t\tf = fopen(control_cmd, \"w\");\n\t\tif (f) {\n\t\t\tfclose(f);\n\t\t}\n\t}\n\tfree(control_cmd);\n\n\tif (stat(control, &sb) != 0) {\n\t\treturn 1;\n\t}\n\tif (last_size == (int) sb.st_size && last_mtime == sb.st_mtime) {\n\t\treturn 1;\n\t}\n\tlast_size = (int) sb.st_size;\n\tlast_mtime = sb.st_mtime;\n\n\treturn process_control(control, 1);\n}",
    "includes": [
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "process_control",
          "args": [
            "control",
            "1"
          ],
          "line": 1556
        },
        "resolved": true,
        "details": {
          "function_name": "process_control",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/appshare.c",
          "lines": "1359-1517",
          "snippet": "static int process_control(char *file, int check_clients) {\n\tint i, nnew = 0, seen[CMAX];\n\tchar line[1024], *newctl[CMAX];\n\tFILE *f;\n\n\tf = fopen(file, \"r\");\n\tif (!f) {\n\t\treturn 1;\n\t}\n\tif (check_clients) {\n\t\tfor (i=0; i < CMAX; i++) {\n\t\t\tseen[i] = 0;\n\t\t}\n\t}\n\twhile (fgets(line, sizeof(line), f) != NULL) {\n\t\tchar *q = strchr(line, '\\n');\n\t\tif (q) *q = '\\0';\n\n\t\tif (appshare_debug) {\n\t\t\tfprintf(stderr, \"check_control: %s\\n\", line);\n\t\t\tff();\n\t\t}\n\n\t\tq = lblanks(line);\n\t\tif (q[0] == '#') {\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strcmp(q, \"\")) {\n\t\t\tcontinue;\n\t\t}\n\t\tif (strstr(q, \"cmd=\") == q) {\n\t\t\tchar *cmd = q + strlen(\"cmd=\");\n\t\t\tif (!strcmp(cmd, \"quit\")) {\n\t\t\t\tif (strcmp(control, file) && strstr(file, \".cmd\")) {\n\t\t\t\t\tFILE *f2 = fopen(file, \"w\");\n\t\t\t\t\tif (f2) fclose(f2);\n\t\t\t\t}\n\t\t\t\tappshare_cleanup(0);\n\t\t\t} else if (!strcmp(cmd, \"wait\")) {\n\t\t\t\treturn 0;\n\t\t\t} else if (strstr(cmd, \"bcast:\") == cmd) {\n\t\t\t\t;\n\t\t\t} else if (strstr(cmd, \"del_window:\") == cmd) {\n\t\t\t\tadd_or_del_win(cmd + strlen(\"del_window:\"), 0);\n\t\t\t} else if (strstr(cmd, \"add_window:\") == cmd) {\n\t\t\t\tadd_or_del_win(cmd + strlen(\"add_window:\"), 1);\n\t\t\t} else if (strstr(cmd, \"del:\") == cmd) {\n\t\t\t\tadd_or_del_win(cmd + strlen(\"del:\"), 0);\n\t\t\t} else if (strstr(cmd, \"add:\") == cmd) {\n\t\t\t\tadd_or_del_win(cmd + strlen(\"add:\"), 1);\n\t\t\t} else if (strstr(cmd, \"del_client:\") == cmd) {\n\t\t\t\tadd_or_del_client(cmd + strlen(\"del_client:\"), 0);\n\t\t\t} else if (strstr(cmd, \"add_client:\") == cmd) {\n\t\t\t\tadd_or_del_client(cmd + strlen(\"add_client:\"), 1);\n\t\t\t} else if (strstr(cmd, \"-\") == cmd) {\n\t\t\t\tadd_or_del_client(cmd + strlen(\"-\"), 0);\n\t\t\t} else if (strstr(cmd, \"+\") == cmd) {\n\t\t\t\tadd_or_del_client(cmd + strlen(\"+\"), 1);\n\t\t\t} else if (strstr(cmd, \"del_app:\") == cmd) {\n\t\t\t\tadd_or_del_app(cmd + strlen(\"del_app:\"), 0);\n\t\t\t} else if (strstr(cmd, \"add_app:\") == cmd) {\n\t\t\t\tadd_or_del_app(cmd + strlen(\"add_app:\"), 1);\n\t\t\t} else if (strstr(cmd, \"debug:\") == cmd) {\n\t\t\t\tappshare_debug = atoi(cmd + strlen(\"debug:\"));\n\t\t\t} else if (strstr(cmd, \"showmenus:\") == cmd) {\n\t\t\t\tskip_menus = atoi(cmd + strlen(\"showmenus:\"));\n\t\t\t\tskip_menus = !(skip_menus);\n\t\t\t} else if (strstr(cmd, \"noexit:\") == cmd) {\n\t\t\t\texit_no_app_win = atoi(cmd + strlen(\"noexit:\"));\n\t\t\t\texit_no_app_win = !(exit_no_app_win);\n\t\t\t} else if (strstr(cmd, \"use_forever:\") == cmd) {\n\t\t\t\tuse_forever = atoi(cmd + strlen(\"use_forever:\"));\n\t\t\t} else if (strstr(cmd, \"tree_depth:\") == cmd) {\n\t\t\t\ttree_depth = atoi(cmd + strlen(\"tree_depth:\"));\n\t\t\t} else if (strstr(cmd, \"x11vnc_args:\") == cmd) {\n\t\t\t\tx11vnc_args = strdup(cmd + strlen(\"x11vnc_args:\"));\n\t\t\t} else if (strstr(cmd, \"env:\") == cmd) {\n\t\t\t\tputenv(cmd + strlen(\"env:\"));\n\t\t\t} else if (strstr(cmd, \"noop\") == cmd) {\n\t\t\t\t;\n\t\t\t} else if (!strcmp(cmd, \"restart\")) {\n\t\t\t\trestart_x11vnc();\n\t\t\t} else if (!strcmp(cmd, \"list_clients\") || !strcmp(cmd, \"lc\")) {\n\t\t\t\tlist_clients();\n\t\t\t} else if (!strcmp(cmd, \"list_windows\") || !strcmp(cmd, \"lw\")) {\n\t\t\t\tlist_windows();\n\t\t\t} else if (!strcmp(cmd, \"list_apps\") || !strcmp(cmd, \"la\")) {\n\t\t\t\tlist_apps();\n\t\t\t} else if (!strcmp(cmd, \"list_all\") || !strcmp(cmd, \"ls\")) {\n\t\t\t\tlist_windows();\n\t\t\t\tfprintf(stderr, \"\\n\");\n\t\t\t\tlist_apps();\n\t\t\t\tfprintf(stderr, \"\\n\");\n\t\t\t\tlist_clients();\n\t\t\t} else if (!strcmp(cmd, \"print_logs\") || !strcmp(cmd, \"pl\")) {\n\t\t\t\tprint_logs();\n\t\t\t} else if (!strcmp(cmd, \"?\") || !strcmp(cmd, \"h\") || !strcmp(cmd, \"help\")) {\n\t\t\t\tfprintf(stderr, \"available commands:\\n\");\n\t\t\t\tfprintf(stderr, \"\\n\");\n\t\t\t\tfprintf(stderr, \"   quit restart noop x11vnc help ? ! !!\\n\");\n\t\t\t\tfprintf(stderr, \"\\n\");\n\t\t\t\tfprintf(stderr, \"   add_window:win  (add:win, add:pick)\\n\");\n\t\t\t\tfprintf(stderr, \"   del_window:win  (del:win, del:pick, del:all)\\n\");\n\t\t\t\tfprintf(stderr, \"   add_app:win     (add_app:pick)\\n\");\n\t\t\t\tfprintf(stderr, \"   del_app:win     (del_app:pick, del_app:all)\\n\");\n\t\t\t\tfprintf(stderr, \"   add_client:host (+host)\\n\");\n\t\t\t\tfprintf(stderr, \"   del_client:host (-host, -all)\\n\");\n\t\t\t\tfprintf(stderr, \"\\n\");\n\t\t\t\tfprintf(stderr, \"   list_windows    (lw)\\n\");\n\t\t\t\tfprintf(stderr, \"   list_apps       (la)\\n\");\n\t\t\t\tfprintf(stderr, \"   list_clients    (lc)\\n\");\n\t\t\t\tfprintf(stderr, \"   list_all        (ls)\\n\");\n\t\t\t\tfprintf(stderr, \"   print_logs      (pl)\\n\");\n\t\t\t\tfprintf(stderr, \"\\n\");\n\t\t\t\tfprintf(stderr, \"   debug:n   showmenus:n   noexit:n\\n\");\n\t\t\t} else {\n\t\t\t\tfprintf(stderr, \"unrecognized %s\\n\", q);\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\t\tif (check_clients) {\n\t\t\tint idx = find_client(q);\n\t\t\tif (idx >= 0) {\n\t\t\t\tseen[idx] = 1;\n\t\t\t} else {\n\t\t\t\tnewctl[nnew++] = strdup(q);\n\t\t\t}\n\t\t}\n\t}\n\tfclose(f);\n\n\tif (check_clients) {\n\t\tfor (i=0; i < CMAX; i++) {\n\t\t\tif (clients[i] == NULL) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (!seen[i]) {\n\t\t\t\tclient(clients[i], 0);\n\t\t\t\tfree(clients[i]);\n\t\t\t\tclients[i] = NULL;\n\t\t\t}\n\t\t}\n\t\tfor (i=0; i < nnew; i++) {\n\t\t\tint free = find_client(NULL);\n\t\t\tif (free < 0) {\n\t\t\t\tstatic int cnt = 0;\n\t\t\t\tif (cnt++ < 10) {\n\t\t\t\t\tfprintf(stderr, \"ran out of client slots.\\n\");\n\t\t\t\t\tff();\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tclients[free] = newctl[i];\n\t\t\tclient(newctl[i], 1);\n\t\t}\n\t}\n\treturn 1;\n}",
          "includes": [
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [
            "#define CMAX 128"
          ],
          "globals_used": [
            "extern char *get_xprop(char *prop, Window win);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"x11vnc.h\"\n\n#define CMAX 128\n\nextern char *get_xprop(char *prop, Window win);\n\nstatic int process_control(char *file, int check_clients) {\n\tint i, nnew = 0, seen[CMAX];\n\tchar line[1024], *newctl[CMAX];\n\tFILE *f;\n\n\tf = fopen(file, \"r\");\n\tif (!f) {\n\t\treturn 1;\n\t}\n\tif (check_clients) {\n\t\tfor (i=0; i < CMAX; i++) {\n\t\t\tseen[i] = 0;\n\t\t}\n\t}\n\twhile (fgets(line, sizeof(line), f) != NULL) {\n\t\tchar *q = strchr(line, '\\n');\n\t\tif (q) *q = '\\0';\n\n\t\tif (appshare_debug) {\n\t\t\tfprintf(stderr, \"check_control: %s\\n\", line);\n\t\t\tff();\n\t\t}\n\n\t\tq = lblanks(line);\n\t\tif (q[0] == '#') {\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strcmp(q, \"\")) {\n\t\t\tcontinue;\n\t\t}\n\t\tif (strstr(q, \"cmd=\") == q) {\n\t\t\tchar *cmd = q + strlen(\"cmd=\");\n\t\t\tif (!strcmp(cmd, \"quit\")) {\n\t\t\t\tif (strcmp(control, file) && strstr(file, \".cmd\")) {\n\t\t\t\t\tFILE *f2 = fopen(file, \"w\");\n\t\t\t\t\tif (f2) fclose(f2);\n\t\t\t\t}\n\t\t\t\tappshare_cleanup(0);\n\t\t\t} else if (!strcmp(cmd, \"wait\")) {\n\t\t\t\treturn 0;\n\t\t\t} else if (strstr(cmd, \"bcast:\") == cmd) {\n\t\t\t\t;\n\t\t\t} else if (strstr(cmd, \"del_window:\") == cmd) {\n\t\t\t\tadd_or_del_win(cmd + strlen(\"del_window:\"), 0);\n\t\t\t} else if (strstr(cmd, \"add_window:\") == cmd) {\n\t\t\t\tadd_or_del_win(cmd + strlen(\"add_window:\"), 1);\n\t\t\t} else if (strstr(cmd, \"del:\") == cmd) {\n\t\t\t\tadd_or_del_win(cmd + strlen(\"del:\"), 0);\n\t\t\t} else if (strstr(cmd, \"add:\") == cmd) {\n\t\t\t\tadd_or_del_win(cmd + strlen(\"add:\"), 1);\n\t\t\t} else if (strstr(cmd, \"del_client:\") == cmd) {\n\t\t\t\tadd_or_del_client(cmd + strlen(\"del_client:\"), 0);\n\t\t\t} else if (strstr(cmd, \"add_client:\") == cmd) {\n\t\t\t\tadd_or_del_client(cmd + strlen(\"add_client:\"), 1);\n\t\t\t} else if (strstr(cmd, \"-\") == cmd) {\n\t\t\t\tadd_or_del_client(cmd + strlen(\"-\"), 0);\n\t\t\t} else if (strstr(cmd, \"+\") == cmd) {\n\t\t\t\tadd_or_del_client(cmd + strlen(\"+\"), 1);\n\t\t\t} else if (strstr(cmd, \"del_app:\") == cmd) {\n\t\t\t\tadd_or_del_app(cmd + strlen(\"del_app:\"), 0);\n\t\t\t} else if (strstr(cmd, \"add_app:\") == cmd) {\n\t\t\t\tadd_or_del_app(cmd + strlen(\"add_app:\"), 1);\n\t\t\t} else if (strstr(cmd, \"debug:\") == cmd) {\n\t\t\t\tappshare_debug = atoi(cmd + strlen(\"debug:\"));\n\t\t\t} else if (strstr(cmd, \"showmenus:\") == cmd) {\n\t\t\t\tskip_menus = atoi(cmd + strlen(\"showmenus:\"));\n\t\t\t\tskip_menus = !(skip_menus);\n\t\t\t} else if (strstr(cmd, \"noexit:\") == cmd) {\n\t\t\t\texit_no_app_win = atoi(cmd + strlen(\"noexit:\"));\n\t\t\t\texit_no_app_win = !(exit_no_app_win);\n\t\t\t} else if (strstr(cmd, \"use_forever:\") == cmd) {\n\t\t\t\tuse_forever = atoi(cmd + strlen(\"use_forever:\"));\n\t\t\t} else if (strstr(cmd, \"tree_depth:\") == cmd) {\n\t\t\t\ttree_depth = atoi(cmd + strlen(\"tree_depth:\"));\n\t\t\t} else if (strstr(cmd, \"x11vnc_args:\") == cmd) {\n\t\t\t\tx11vnc_args = strdup(cmd + strlen(\"x11vnc_args:\"));\n\t\t\t} else if (strstr(cmd, \"env:\") == cmd) {\n\t\t\t\tputenv(cmd + strlen(\"env:\"));\n\t\t\t} else if (strstr(cmd, \"noop\") == cmd) {\n\t\t\t\t;\n\t\t\t} else if (!strcmp(cmd, \"restart\")) {\n\t\t\t\trestart_x11vnc();\n\t\t\t} else if (!strcmp(cmd, \"list_clients\") || !strcmp(cmd, \"lc\")) {\n\t\t\t\tlist_clients();\n\t\t\t} else if (!strcmp(cmd, \"list_windows\") || !strcmp(cmd, \"lw\")) {\n\t\t\t\tlist_windows();\n\t\t\t} else if (!strcmp(cmd, \"list_apps\") || !strcmp(cmd, \"la\")) {\n\t\t\t\tlist_apps();\n\t\t\t} else if (!strcmp(cmd, \"list_all\") || !strcmp(cmd, \"ls\")) {\n\t\t\t\tlist_windows();\n\t\t\t\tfprintf(stderr, \"\\n\");\n\t\t\t\tlist_apps();\n\t\t\t\tfprintf(stderr, \"\\n\");\n\t\t\t\tlist_clients();\n\t\t\t} else if (!strcmp(cmd, \"print_logs\") || !strcmp(cmd, \"pl\")) {\n\t\t\t\tprint_logs();\n\t\t\t} else if (!strcmp(cmd, \"?\") || !strcmp(cmd, \"h\") || !strcmp(cmd, \"help\")) {\n\t\t\t\tfprintf(stderr, \"available commands:\\n\");\n\t\t\t\tfprintf(stderr, \"\\n\");\n\t\t\t\tfprintf(stderr, \"   quit restart noop x11vnc help ? ! !!\\n\");\n\t\t\t\tfprintf(stderr, \"\\n\");\n\t\t\t\tfprintf(stderr, \"   add_window:win  (add:win, add:pick)\\n\");\n\t\t\t\tfprintf(stderr, \"   del_window:win  (del:win, del:pick, del:all)\\n\");\n\t\t\t\tfprintf(stderr, \"   add_app:win     (add_app:pick)\\n\");\n\t\t\t\tfprintf(stderr, \"   del_app:win     (del_app:pick, del_app:all)\\n\");\n\t\t\t\tfprintf(stderr, \"   add_client:host (+host)\\n\");\n\t\t\t\tfprintf(stderr, \"   del_client:host (-host, -all)\\n\");\n\t\t\t\tfprintf(stderr, \"\\n\");\n\t\t\t\tfprintf(stderr, \"   list_windows    (lw)\\n\");\n\t\t\t\tfprintf(stderr, \"   list_apps       (la)\\n\");\n\t\t\t\tfprintf(stderr, \"   list_clients    (lc)\\n\");\n\t\t\t\tfprintf(stderr, \"   list_all        (ls)\\n\");\n\t\t\t\tfprintf(stderr, \"   print_logs      (pl)\\n\");\n\t\t\t\tfprintf(stderr, \"\\n\");\n\t\t\t\tfprintf(stderr, \"   debug:n   showmenus:n   noexit:n\\n\");\n\t\t\t} else {\n\t\t\t\tfprintf(stderr, \"unrecognized %s\\n\", q);\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\t\tif (check_clients) {\n\t\t\tint idx = find_client(q);\n\t\t\tif (idx >= 0) {\n\t\t\t\tseen[idx] = 1;\n\t\t\t} else {\n\t\t\t\tnewctl[nnew++] = strdup(q);\n\t\t\t}\n\t\t}\n\t}\n\tfclose(f);\n\n\tif (check_clients) {\n\t\tfor (i=0; i < CMAX; i++) {\n\t\t\tif (clients[i] == NULL) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (!seen[i]) {\n\t\t\t\tclient(clients[i], 0);\n\t\t\t\tfree(clients[i]);\n\t\t\t\tclients[i] = NULL;\n\t\t\t}\n\t\t}\n\t\tfor (i=0; i < nnew; i++) {\n\t\t\tint free = find_client(NULL);\n\t\t\tif (free < 0) {\n\t\t\t\tstatic int cnt = 0;\n\t\t\t\tif (cnt++ < 10) {\n\t\t\t\t\tfprintf(stderr, \"ran out of client slots.\\n\");\n\t\t\t\t\tff();\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tclients[free] = newctl[i];\n\t\t\tclient(newctl[i], 1);\n\t\t}\n\t}\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "stat",
          "args": [
            "control",
            "&sb"
          ],
          "line": 1547
        },
        "resolved": true,
        "details": {
          "function_name": "grab_state",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/connections.c",
          "lines": "3178-3224",
          "snippet": "void grab_state(int *ptr_grabbed, int *kbd_grabbed) {\n\tint rcp, rck;\n\tdouble t0, t1;\n\tdouble ta, tb, tc;\n\t*ptr_grabbed = -1;\n\t*kbd_grabbed = -1;\n\n\tif (!dpy) {\n\t\treturn;\n\t}\n\t*ptr_grabbed = 0;\n\t*kbd_grabbed = 0;\n\n#if !NO_X11\n\tX_LOCK;\n\n\tXSync(dpy, False);\n\n\tta = t0 = dnow();\n\n\trcp = XGrabPointer(dpy, window, False, 0, GrabModeAsync, GrabModeAsync, None, None, CurrentTime);\n\tXUngrabPointer(dpy, CurrentTime);\n\n\ttb = dnow();\n\t\n\trck = XGrabKeyboard(dpy, window, False, GrabModeAsync, GrabModeAsync, CurrentTime);\n\tXUngrabKeyboard(dpy, CurrentTime);\n\n\ttc = dnow();\n\n\tXSync(dpy, False);\n\n\tt1 = dnow();\n\n\tX_UNLOCK;\n\tif (rcp == AlreadyGrabbed || rcp == GrabFrozen) {\n\t\t*ptr_grabbed = 1;\n\t}\n\tif (rck == AlreadyGrabbed || rck == GrabFrozen) {\n\t\t*kbd_grabbed = 1;\n\t}\n\tif (rc_npieces < 10) {\n\t\trfbLog(\"grab_state: checked %d,%d in %.6f sec (%.6f %.6f)\\n\",\n\t\t    *ptr_grabbed, *kbd_grabbed, t1-t0, tb-ta, tc-tb);\n\t}\n#endif\n}",
          "includes": [
            "#include \"xi2_devices.h\"",
            "#include \"xrandr.h\"",
            "#include \"pointer.h\"",
            "#include \"userinput.h\"",
            "#include \"macosxCG.h\"",
            "#include \"macosx.h\"",
            "#include \"win_utils.h\"",
            "#include \"xevents.h\"",
            "#include \"xwrappers.h\"",
            "#include \"sslhelper.h\"",
            "#include \"sslcmds.h\"",
            "#include \"scan.h\"",
            "#include \"user.h\"",
            "#include \"unixpw.h\"",
            "#include \"screen.h\"",
            "#include \"rates.h\"",
            "#include \"solid.h\"",
            "#include \"gui.h\"",
            "#include \"cleanup.h\"",
            "#include \"keyboard.h\"",
            "#include \"remote.h\"",
            "#include \"inet.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void grab_state(int *ptr_grabbed, int *kbd_grabbed);",
            "extern int rc_npieces;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xi2_devices.h\"\n#include \"xrandr.h\"\n#include \"pointer.h\"\n#include \"userinput.h\"\n#include \"macosxCG.h\"\n#include \"macosx.h\"\n#include \"win_utils.h\"\n#include \"xevents.h\"\n#include \"xwrappers.h\"\n#include \"sslhelper.h\"\n#include \"sslcmds.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"unixpw.h\"\n#include \"screen.h\"\n#include \"rates.h\"\n#include \"solid.h\"\n#include \"gui.h\"\n#include \"cleanup.h\"\n#include \"keyboard.h\"\n#include \"remote.h\"\n#include \"inet.h\"\n#include \"x11vnc.h\"\n\nvoid grab_state(int *ptr_grabbed, int *kbd_grabbed);\nextern int rc_npieces;\n\nvoid grab_state(int *ptr_grabbed, int *kbd_grabbed) {\n\tint rcp, rck;\n\tdouble t0, t1;\n\tdouble ta, tb, tc;\n\t*ptr_grabbed = -1;\n\t*kbd_grabbed = -1;\n\n\tif (!dpy) {\n\t\treturn;\n\t}\n\t*ptr_grabbed = 0;\n\t*kbd_grabbed = 0;\n\n#if !NO_X11\n\tX_LOCK;\n\n\tXSync(dpy, False);\n\n\tta = t0 = dnow();\n\n\trcp = XGrabPointer(dpy, window, False, 0, GrabModeAsync, GrabModeAsync, None, None, CurrentTime);\n\tXUngrabPointer(dpy, CurrentTime);\n\n\ttb = dnow();\n\t\n\trck = XGrabKeyboard(dpy, window, False, GrabModeAsync, GrabModeAsync, CurrentTime);\n\tXUngrabKeyboard(dpy, CurrentTime);\n\n\ttc = dnow();\n\n\tXSync(dpy, False);\n\n\tt1 = dnow();\n\n\tX_UNLOCK;\n\tif (rcp == AlreadyGrabbed || rcp == GrabFrozen) {\n\t\t*ptr_grabbed = 1;\n\t}\n\tif (rck == AlreadyGrabbed || rck == GrabFrozen) {\n\t\t*kbd_grabbed = 1;\n\t}\n\tif (rc_npieces < 10) {\n\t\trfbLog(\"grab_state: checked %d,%d in %.6f sec (%.6f %.6f)\\n\",\n\t\t    *ptr_grabbed, *kbd_grabbed, t1-t0, tb-ta, tc-tb);\n\t}\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "control_cmd"
          ],
          "line": 1545
        },
        "resolved": true,
        "details": {
          "function_name": "free_rect",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/userinput.c",
          "lines": "6200-6247",
          "snippet": "int free_rect(int idx) {\n\tint n, ok = 0;\n\tsraRegionPtr r1, r2;\n\tint x, y, w, h;\n\n\tif (idx < 0 || idx >= cache_list_num) {\nif (0) fprintf(stderr, \"free_rect: bad index: %d\\n\", idx);\n\t\tclean_up_exit(1);\n\t}\n\n\tx = cache_list[idx].bs_x;\n\ty = cache_list[idx].bs_y;\n\tw = cache_list[idx].bs_w;\n\th = cache_list[idx].bs_h;\n\n\tif (x < 0) {\n\t\tCLEAR(idx);\nif (dnow() > last_client + 5 && ncdb) fprintf(stderr, \"free_rect: already bs_x invalidated: %d bs_x: %d\\n\", idx, x);\n\t\treturn 1;\n\t}\n\n\tr2 = sraRgnCreateRect(x, y, x+w, y+h);\n\n\tn = get_bs_n(y);\n\tif (n >= 0) {\n\t\tr1 = rect_reg[n];\n\t\tsraRgnOr(r1, r2);\n\t\tok = 1;\n\t}\n\n\tif (zero_rects) {\n\t\tsraRgnOr(zero_rects, r2);\n\t\tx = cache_list[idx].su_x;\n\t\ty = cache_list[idx].su_y;\n\t\tw = cache_list[idx].su_w;\n\t\th = cache_list[idx].su_h;\n\t\tif (x >= 0) {\n\t\t\tsraRgnDestroy(r2);\n\t\t\tr2 = sraRgnCreateRect(x, y, x+w, y+h);\n\t\t\tsraRgnOr(zero_rects, r2);\n\t\t}\n\t}\n\tsraRgnDestroy(r2);\n\n\tCLEAR(idx);\nif (! ok && ncdb) fprintf(stderr, \"**** free_rect: not-found %d\\n\", idx);\n\treturn ok;\n}",
          "includes": [
            "#include \"default8x16.h\"",
            "#include \"connections.h\"",
            "#include \"screen.h\"",
            "#include \"cursor.h\"",
            "#include \"macosxCGS.h\"",
            "#include \"macosx.h\"",
            "#include \"unixpw.h\"",
            "#include \"8to24.h\"",
            "#include \"xrandr.h\"",
            "#include \"solid.h\"",
            "#include \"keyboard.h\"",
            "#include \"rates.h\"",
            "#include \"pointer.h\"",
            "#include \"cleanup.h\"",
            "#include \"scan.h\"",
            "#include \"user.h\"",
            "#include \"xevents.h\"",
            "#include \"win_utils.h\"",
            "#include \"xinerama.h\"",
            "#include \"xrecord.h\"",
            "#include \"xdamage.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void mark_for_xdamage(int x, int y, int w, int h);",
            "void set_xdamage_mark(int x, int y, int w, int h);",
            "int find_rect(int idx, int x, int y, int w, int h);",
            "winattr_t *cache_list;",
            "int clipped(int idx);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"default8x16.h\"\n#include \"connections.h\"\n#include \"screen.h\"\n#include \"cursor.h\"\n#include \"macosxCGS.h\"\n#include \"macosx.h\"\n#include \"unixpw.h\"\n#include \"8to24.h\"\n#include \"xrandr.h\"\n#include \"solid.h\"\n#include \"keyboard.h\"\n#include \"rates.h\"\n#include \"pointer.h\"\n#include \"cleanup.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"xevents.h\"\n#include \"win_utils.h\"\n#include \"xinerama.h\"\n#include \"xrecord.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nvoid mark_for_xdamage(int x, int y, int w, int h);\nvoid set_xdamage_mark(int x, int y, int w, int h);\nint find_rect(int idx, int x, int y, int w, int h);\nwinattr_t *cache_list;\nint clipped(int idx);\n\nint free_rect(int idx) {\n\tint n, ok = 0;\n\tsraRegionPtr r1, r2;\n\tint x, y, w, h;\n\n\tif (idx < 0 || idx >= cache_list_num) {\nif (0) fprintf(stderr, \"free_rect: bad index: %d\\n\", idx);\n\t\tclean_up_exit(1);\n\t}\n\n\tx = cache_list[idx].bs_x;\n\ty = cache_list[idx].bs_y;\n\tw = cache_list[idx].bs_w;\n\th = cache_list[idx].bs_h;\n\n\tif (x < 0) {\n\t\tCLEAR(idx);\nif (dnow() > last_client + 5 && ncdb) fprintf(stderr, \"free_rect: already bs_x invalidated: %d bs_x: %d\\n\", idx, x);\n\t\treturn 1;\n\t}\n\n\tr2 = sraRgnCreateRect(x, y, x+w, y+h);\n\n\tn = get_bs_n(y);\n\tif (n >= 0) {\n\t\tr1 = rect_reg[n];\n\t\tsraRgnOr(r1, r2);\n\t\tok = 1;\n\t}\n\n\tif (zero_rects) {\n\t\tsraRgnOr(zero_rects, r2);\n\t\tx = cache_list[idx].su_x;\n\t\ty = cache_list[idx].su_y;\n\t\tw = cache_list[idx].su_w;\n\t\th = cache_list[idx].su_h;\n\t\tif (x >= 0) {\n\t\t\tsraRgnDestroy(r2);\n\t\t\tr2 = sraRgnCreateRect(x, y, x+w, y+h);\n\t\t\tsraRgnOr(zero_rects, r2);\n\t\t}\n\t}\n\tsraRgnDestroy(r2);\n\n\tCLEAR(idx);\nif (! ok && ncdb) fprintf(stderr, \"**** free_rect: not-found %d\\n\", idx);\n\treturn ok;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fclose",
          "args": [
            "f"
          ],
          "line": 1542
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fopen",
          "args": [
            "control_cmd",
            "\"w\""
          ],
          "line": 1540
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "control_cmd",
            "\"%s.cmd\"",
            "control"
          ],
          "line": 1534
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "strlen(control) + strlen(\".cmd\") + 1"
          ],
          "line": 1533
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "\".cmd\""
          ],
          "line": 1533
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "control"
          ],
          "line": 1533
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "control",
            "\"internal\""
          ],
          "line": 1529
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"x11vnc.h\"\n\nstatic int check_control(void) {\n\tstatic int last_size = -1;\n\tstatic time_t last_mtime = 0;\n\tstruct stat sb;\n\tchar *control_cmd;\n\n\tif (!control) {\n\t\treturn 1;\n\t}\n\n\tif (!strcmp(control, \"internal\")) {\n\t\treturn 1;\n\t}\n\t\t\n\tcontrol_cmd = (char *)malloc(strlen(control) + strlen(\".cmd\") + 1);\n\tsprintf(control_cmd, \"%s.cmd\", control);\n\tif (stat(control_cmd, &sb) == 0) {\n\t\tFILE *f;\n\t\tif (sb.st_size > 0) {\n\t\t\tprocess_control(control_cmd, 0);\n\t\t}\n\t\tf = fopen(control_cmd, \"w\");\n\t\tif (f) {\n\t\t\tfclose(f);\n\t\t}\n\t}\n\tfree(control_cmd);\n\n\tif (stat(control, &sb) != 0) {\n\t\treturn 1;\n\t}\n\tif (last_size == (int) sb.st_size && last_mtime == sb.st_mtime) {\n\t\treturn 1;\n\t}\n\tlast_size = (int) sb.st_size;\n\tlast_mtime = sb.st_mtime;\n\n\treturn process_control(control, 1);\n}"
  },
  {
    "function_name": "process_control",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/appshare.c",
    "lines": "1359-1517",
    "snippet": "static int process_control(char *file, int check_clients) {\n\tint i, nnew = 0, seen[CMAX];\n\tchar line[1024], *newctl[CMAX];\n\tFILE *f;\n\n\tf = fopen(file, \"r\");\n\tif (!f) {\n\t\treturn 1;\n\t}\n\tif (check_clients) {\n\t\tfor (i=0; i < CMAX; i++) {\n\t\t\tseen[i] = 0;\n\t\t}\n\t}\n\twhile (fgets(line, sizeof(line), f) != NULL) {\n\t\tchar *q = strchr(line, '\\n');\n\t\tif (q) *q = '\\0';\n\n\t\tif (appshare_debug) {\n\t\t\tfprintf(stderr, \"check_control: %s\\n\", line);\n\t\t\tff();\n\t\t}\n\n\t\tq = lblanks(line);\n\t\tif (q[0] == '#') {\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strcmp(q, \"\")) {\n\t\t\tcontinue;\n\t\t}\n\t\tif (strstr(q, \"cmd=\") == q) {\n\t\t\tchar *cmd = q + strlen(\"cmd=\");\n\t\t\tif (!strcmp(cmd, \"quit\")) {\n\t\t\t\tif (strcmp(control, file) && strstr(file, \".cmd\")) {\n\t\t\t\t\tFILE *f2 = fopen(file, \"w\");\n\t\t\t\t\tif (f2) fclose(f2);\n\t\t\t\t}\n\t\t\t\tappshare_cleanup(0);\n\t\t\t} else if (!strcmp(cmd, \"wait\")) {\n\t\t\t\treturn 0;\n\t\t\t} else if (strstr(cmd, \"bcast:\") == cmd) {\n\t\t\t\t;\n\t\t\t} else if (strstr(cmd, \"del_window:\") == cmd) {\n\t\t\t\tadd_or_del_win(cmd + strlen(\"del_window:\"), 0);\n\t\t\t} else if (strstr(cmd, \"add_window:\") == cmd) {\n\t\t\t\tadd_or_del_win(cmd + strlen(\"add_window:\"), 1);\n\t\t\t} else if (strstr(cmd, \"del:\") == cmd) {\n\t\t\t\tadd_or_del_win(cmd + strlen(\"del:\"), 0);\n\t\t\t} else if (strstr(cmd, \"add:\") == cmd) {\n\t\t\t\tadd_or_del_win(cmd + strlen(\"add:\"), 1);\n\t\t\t} else if (strstr(cmd, \"del_client:\") == cmd) {\n\t\t\t\tadd_or_del_client(cmd + strlen(\"del_client:\"), 0);\n\t\t\t} else if (strstr(cmd, \"add_client:\") == cmd) {\n\t\t\t\tadd_or_del_client(cmd + strlen(\"add_client:\"), 1);\n\t\t\t} else if (strstr(cmd, \"-\") == cmd) {\n\t\t\t\tadd_or_del_client(cmd + strlen(\"-\"), 0);\n\t\t\t} else if (strstr(cmd, \"+\") == cmd) {\n\t\t\t\tadd_or_del_client(cmd + strlen(\"+\"), 1);\n\t\t\t} else if (strstr(cmd, \"del_app:\") == cmd) {\n\t\t\t\tadd_or_del_app(cmd + strlen(\"del_app:\"), 0);\n\t\t\t} else if (strstr(cmd, \"add_app:\") == cmd) {\n\t\t\t\tadd_or_del_app(cmd + strlen(\"add_app:\"), 1);\n\t\t\t} else if (strstr(cmd, \"debug:\") == cmd) {\n\t\t\t\tappshare_debug = atoi(cmd + strlen(\"debug:\"));\n\t\t\t} else if (strstr(cmd, \"showmenus:\") == cmd) {\n\t\t\t\tskip_menus = atoi(cmd + strlen(\"showmenus:\"));\n\t\t\t\tskip_menus = !(skip_menus);\n\t\t\t} else if (strstr(cmd, \"noexit:\") == cmd) {\n\t\t\t\texit_no_app_win = atoi(cmd + strlen(\"noexit:\"));\n\t\t\t\texit_no_app_win = !(exit_no_app_win);\n\t\t\t} else if (strstr(cmd, \"use_forever:\") == cmd) {\n\t\t\t\tuse_forever = atoi(cmd + strlen(\"use_forever:\"));\n\t\t\t} else if (strstr(cmd, \"tree_depth:\") == cmd) {\n\t\t\t\ttree_depth = atoi(cmd + strlen(\"tree_depth:\"));\n\t\t\t} else if (strstr(cmd, \"x11vnc_args:\") == cmd) {\n\t\t\t\tx11vnc_args = strdup(cmd + strlen(\"x11vnc_args:\"));\n\t\t\t} else if (strstr(cmd, \"env:\") == cmd) {\n\t\t\t\tputenv(cmd + strlen(\"env:\"));\n\t\t\t} else if (strstr(cmd, \"noop\") == cmd) {\n\t\t\t\t;\n\t\t\t} else if (!strcmp(cmd, \"restart\")) {\n\t\t\t\trestart_x11vnc();\n\t\t\t} else if (!strcmp(cmd, \"list_clients\") || !strcmp(cmd, \"lc\")) {\n\t\t\t\tlist_clients();\n\t\t\t} else if (!strcmp(cmd, \"list_windows\") || !strcmp(cmd, \"lw\")) {\n\t\t\t\tlist_windows();\n\t\t\t} else if (!strcmp(cmd, \"list_apps\") || !strcmp(cmd, \"la\")) {\n\t\t\t\tlist_apps();\n\t\t\t} else if (!strcmp(cmd, \"list_all\") || !strcmp(cmd, \"ls\")) {\n\t\t\t\tlist_windows();\n\t\t\t\tfprintf(stderr, \"\\n\");\n\t\t\t\tlist_apps();\n\t\t\t\tfprintf(stderr, \"\\n\");\n\t\t\t\tlist_clients();\n\t\t\t} else if (!strcmp(cmd, \"print_logs\") || !strcmp(cmd, \"pl\")) {\n\t\t\t\tprint_logs();\n\t\t\t} else if (!strcmp(cmd, \"?\") || !strcmp(cmd, \"h\") || !strcmp(cmd, \"help\")) {\n\t\t\t\tfprintf(stderr, \"available commands:\\n\");\n\t\t\t\tfprintf(stderr, \"\\n\");\n\t\t\t\tfprintf(stderr, \"   quit restart noop x11vnc help ? ! !!\\n\");\n\t\t\t\tfprintf(stderr, \"\\n\");\n\t\t\t\tfprintf(stderr, \"   add_window:win  (add:win, add:pick)\\n\");\n\t\t\t\tfprintf(stderr, \"   del_window:win  (del:win, del:pick, del:all)\\n\");\n\t\t\t\tfprintf(stderr, \"   add_app:win     (add_app:pick)\\n\");\n\t\t\t\tfprintf(stderr, \"   del_app:win     (del_app:pick, del_app:all)\\n\");\n\t\t\t\tfprintf(stderr, \"   add_client:host (+host)\\n\");\n\t\t\t\tfprintf(stderr, \"   del_client:host (-host, -all)\\n\");\n\t\t\t\tfprintf(stderr, \"\\n\");\n\t\t\t\tfprintf(stderr, \"   list_windows    (lw)\\n\");\n\t\t\t\tfprintf(stderr, \"   list_apps       (la)\\n\");\n\t\t\t\tfprintf(stderr, \"   list_clients    (lc)\\n\");\n\t\t\t\tfprintf(stderr, \"   list_all        (ls)\\n\");\n\t\t\t\tfprintf(stderr, \"   print_logs      (pl)\\n\");\n\t\t\t\tfprintf(stderr, \"\\n\");\n\t\t\t\tfprintf(stderr, \"   debug:n   showmenus:n   noexit:n\\n\");\n\t\t\t} else {\n\t\t\t\tfprintf(stderr, \"unrecognized %s\\n\", q);\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\t\tif (check_clients) {\n\t\t\tint idx = find_client(q);\n\t\t\tif (idx >= 0) {\n\t\t\t\tseen[idx] = 1;\n\t\t\t} else {\n\t\t\t\tnewctl[nnew++] = strdup(q);\n\t\t\t}\n\t\t}\n\t}\n\tfclose(f);\n\n\tif (check_clients) {\n\t\tfor (i=0; i < CMAX; i++) {\n\t\t\tif (clients[i] == NULL) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (!seen[i]) {\n\t\t\t\tclient(clients[i], 0);\n\t\t\t\tfree(clients[i]);\n\t\t\t\tclients[i] = NULL;\n\t\t\t}\n\t\t}\n\t\tfor (i=0; i < nnew; i++) {\n\t\t\tint free = find_client(NULL);\n\t\t\tif (free < 0) {\n\t\t\t\tstatic int cnt = 0;\n\t\t\t\tif (cnt++ < 10) {\n\t\t\t\t\tfprintf(stderr, \"ran out of client slots.\\n\");\n\t\t\t\t\tff();\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tclients[free] = newctl[i];\n\t\t\tclient(newctl[i], 1);\n\t\t}\n\t}\n\treturn 1;\n}",
    "includes": [
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [
      "#define CMAX 128"
    ],
    "globals_used": [
      "extern char *get_xprop(char *prop, Window win);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "client",
          "args": [
            "newctl[i]",
            "1"
          ],
          "line": 1513
        },
        "resolved": true,
        "details": {
          "function_name": "add_or_del_client",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/appshare.c",
          "lines": "1184-1244",
          "snippet": "static void add_or_del_client(char *str, int add) {\n\tint i;\n\n\tif (!str) {\n\t\treturn;\n\t}\n\tif (strcmp(control, \"internal\")) {\n\t\treturn;\n\t}\n\tif (add) {\n\t\tint idx  = find_client(str);\n\t\tint free = find_client(NULL);\n\n\t\tif (idx >=0) {\n\t\t\tfprintf(stderr, \"already tracking client: %s in slot %d\\n\", str, idx);\n\t\t\tff();\n\t\t\treturn;\n\t\t}\n\t\tif (free < 0) {\n\t\t\tstatic int cnt = 0;\n\t\t\tif (cnt++ < 10) {\n\t\t\t\tfprintf(stderr, \"ran out of client slots.\\n\");\n\t\t\t\tff();\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t\tclients[free] = strdup(str);\n\t\tclient(str, 1);\n\t} else {\n\t\tif (str[0] == '#' || str[0] == '%') {\n\t\t\tif (sscanf(str+1, \"%d\", &i) == 1) {\n\t\t\t\ti--;\n\t\t\t\tif (0 <= i && i < CMAX) {\n\t\t\t\t\tif (clients[i] != NULL) {\n\t\t\t\t\t\tclient(clients[i], 0);\n\t\t\t\t\t\tfree(clients[i]);\n\t\t\t\t\t\tclients[i] = NULL;\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (!strcmp(str, \"all\")) {\n\t\t\tfor (i=0; i < CMAX; i++) {\n\t\t\t\tif (clients[i] == NULL) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tclient(clients[i], 0);\n\t\t\t\tfree(clients[i]);\n\t\t\t\tclients[i] = NULL;\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\n\t\ti = find_client(str);\n\t\tif (i >= 0) {\n\t\t\tfree(clients[i]);\n\t\t\tclients[i] = NULL;\n\t\t\tclient(str, 0);\n\t\t}\n\t}\n}",
          "includes": [
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [
            "#define CMAX 128"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"x11vnc.h\"\n\n#define CMAX 128\n\nstatic void add_or_del_client(char *str, int add) {\n\tint i;\n\n\tif (!str) {\n\t\treturn;\n\t}\n\tif (strcmp(control, \"internal\")) {\n\t\treturn;\n\t}\n\tif (add) {\n\t\tint idx  = find_client(str);\n\t\tint free = find_client(NULL);\n\n\t\tif (idx >=0) {\n\t\t\tfprintf(stderr, \"already tracking client: %s in slot %d\\n\", str, idx);\n\t\t\tff();\n\t\t\treturn;\n\t\t}\n\t\tif (free < 0) {\n\t\t\tstatic int cnt = 0;\n\t\t\tif (cnt++ < 10) {\n\t\t\t\tfprintf(stderr, \"ran out of client slots.\\n\");\n\t\t\t\tff();\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t\tclients[free] = strdup(str);\n\t\tclient(str, 1);\n\t} else {\n\t\tif (str[0] == '#' || str[0] == '%') {\n\t\t\tif (sscanf(str+1, \"%d\", &i) == 1) {\n\t\t\t\ti--;\n\t\t\t\tif (0 <= i && i < CMAX) {\n\t\t\t\t\tif (clients[i] != NULL) {\n\t\t\t\t\t\tclient(clients[i], 0);\n\t\t\t\t\t\tfree(clients[i]);\n\t\t\t\t\t\tclients[i] = NULL;\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (!strcmp(str, \"all\")) {\n\t\t\tfor (i=0; i < CMAX; i++) {\n\t\t\t\tif (clients[i] == NULL) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tclient(clients[i], 0);\n\t\t\t\tfree(clients[i]);\n\t\t\t\tclients[i] = NULL;\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\n\t\ti = find_client(str);\n\t\tif (i >= 0) {\n\t\t\tfree(clients[i]);\n\t\t\tclients[i] = NULL;\n\t\t\tclient(str, 0);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ff",
          "args": [],
          "line": 1507
        },
        "resolved": true,
        "details": {
          "function_name": "ff",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/appshare.c",
          "lines": "293-296",
          "snippet": "static void ff(void) {\n\tfflush(stdout);\n\tfflush(stderr);\n}",
          "includes": [
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"x11vnc.h\"\n\nstatic void ff(void) {\n\tfflush(stdout);\n\tfflush(stderr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"ran out of client slots.\\n\""
          ],
          "line": 1506
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "find_client",
          "args": [
            "NULL"
          ],
          "line": 1502
        },
        "resolved": true,
        "details": {
          "function_name": "find_client",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/appshare.c",
          "lines": "318-335",
          "snippet": "static int find_client(char *cl) {\n\tint i;\n\tfor (i=0; i < CMAX; i++) {\n\t\tif (cl == NULL) {\n\t\t\tif (clients[i] == NULL) {\n\t\t\t\treturn i;\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\t\tif (clients[i] == NULL) {\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strcmp(clients[i], cl)) {\n\t\t\treturn i;\n\t\t}\n\t}\n\treturn -1;\n}",
          "includes": [
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [
            "#define CMAX 128"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"x11vnc.h\"\n\n#define CMAX 128\n\nstatic int find_client(char *cl) {\n\tint i;\n\tfor (i=0; i < CMAX; i++) {\n\t\tif (cl == NULL) {\n\t\t\tif (clients[i] == NULL) {\n\t\t\t\treturn i;\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\t\tif (clients[i] == NULL) {\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strcmp(clients[i], cl)) {\n\t\t\treturn i;\n\t\t}\n\t}\n\treturn -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "clients[i]"
          ],
          "line": 1497
        },
        "resolved": true,
        "details": {
          "function_name": "free_rect",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/userinput.c",
          "lines": "6200-6247",
          "snippet": "int free_rect(int idx) {\n\tint n, ok = 0;\n\tsraRegionPtr r1, r2;\n\tint x, y, w, h;\n\n\tif (idx < 0 || idx >= cache_list_num) {\nif (0) fprintf(stderr, \"free_rect: bad index: %d\\n\", idx);\n\t\tclean_up_exit(1);\n\t}\n\n\tx = cache_list[idx].bs_x;\n\ty = cache_list[idx].bs_y;\n\tw = cache_list[idx].bs_w;\n\th = cache_list[idx].bs_h;\n\n\tif (x < 0) {\n\t\tCLEAR(idx);\nif (dnow() > last_client + 5 && ncdb) fprintf(stderr, \"free_rect: already bs_x invalidated: %d bs_x: %d\\n\", idx, x);\n\t\treturn 1;\n\t}\n\n\tr2 = sraRgnCreateRect(x, y, x+w, y+h);\n\n\tn = get_bs_n(y);\n\tif (n >= 0) {\n\t\tr1 = rect_reg[n];\n\t\tsraRgnOr(r1, r2);\n\t\tok = 1;\n\t}\n\n\tif (zero_rects) {\n\t\tsraRgnOr(zero_rects, r2);\n\t\tx = cache_list[idx].su_x;\n\t\ty = cache_list[idx].su_y;\n\t\tw = cache_list[idx].su_w;\n\t\th = cache_list[idx].su_h;\n\t\tif (x >= 0) {\n\t\t\tsraRgnDestroy(r2);\n\t\t\tr2 = sraRgnCreateRect(x, y, x+w, y+h);\n\t\t\tsraRgnOr(zero_rects, r2);\n\t\t}\n\t}\n\tsraRgnDestroy(r2);\n\n\tCLEAR(idx);\nif (! ok && ncdb) fprintf(stderr, \"**** free_rect: not-found %d\\n\", idx);\n\treturn ok;\n}",
          "includes": [
            "#include \"default8x16.h\"",
            "#include \"connections.h\"",
            "#include \"screen.h\"",
            "#include \"cursor.h\"",
            "#include \"macosxCGS.h\"",
            "#include \"macosx.h\"",
            "#include \"unixpw.h\"",
            "#include \"8to24.h\"",
            "#include \"xrandr.h\"",
            "#include \"solid.h\"",
            "#include \"keyboard.h\"",
            "#include \"rates.h\"",
            "#include \"pointer.h\"",
            "#include \"cleanup.h\"",
            "#include \"scan.h\"",
            "#include \"user.h\"",
            "#include \"xevents.h\"",
            "#include \"win_utils.h\"",
            "#include \"xinerama.h\"",
            "#include \"xrecord.h\"",
            "#include \"xdamage.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void mark_for_xdamage(int x, int y, int w, int h);",
            "void set_xdamage_mark(int x, int y, int w, int h);",
            "int find_rect(int idx, int x, int y, int w, int h);",
            "winattr_t *cache_list;",
            "int clipped(int idx);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"default8x16.h\"\n#include \"connections.h\"\n#include \"screen.h\"\n#include \"cursor.h\"\n#include \"macosxCGS.h\"\n#include \"macosx.h\"\n#include \"unixpw.h\"\n#include \"8to24.h\"\n#include \"xrandr.h\"\n#include \"solid.h\"\n#include \"keyboard.h\"\n#include \"rates.h\"\n#include \"pointer.h\"\n#include \"cleanup.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"xevents.h\"\n#include \"win_utils.h\"\n#include \"xinerama.h\"\n#include \"xrecord.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nvoid mark_for_xdamage(int x, int y, int w, int h);\nvoid set_xdamage_mark(int x, int y, int w, int h);\nint find_rect(int idx, int x, int y, int w, int h);\nwinattr_t *cache_list;\nint clipped(int idx);\n\nint free_rect(int idx) {\n\tint n, ok = 0;\n\tsraRegionPtr r1, r2;\n\tint x, y, w, h;\n\n\tif (idx < 0 || idx >= cache_list_num) {\nif (0) fprintf(stderr, \"free_rect: bad index: %d\\n\", idx);\n\t\tclean_up_exit(1);\n\t}\n\n\tx = cache_list[idx].bs_x;\n\ty = cache_list[idx].bs_y;\n\tw = cache_list[idx].bs_w;\n\th = cache_list[idx].bs_h;\n\n\tif (x < 0) {\n\t\tCLEAR(idx);\nif (dnow() > last_client + 5 && ncdb) fprintf(stderr, \"free_rect: already bs_x invalidated: %d bs_x: %d\\n\", idx, x);\n\t\treturn 1;\n\t}\n\n\tr2 = sraRgnCreateRect(x, y, x+w, y+h);\n\n\tn = get_bs_n(y);\n\tif (n >= 0) {\n\t\tr1 = rect_reg[n];\n\t\tsraRgnOr(r1, r2);\n\t\tok = 1;\n\t}\n\n\tif (zero_rects) {\n\t\tsraRgnOr(zero_rects, r2);\n\t\tx = cache_list[idx].su_x;\n\t\ty = cache_list[idx].su_y;\n\t\tw = cache_list[idx].su_w;\n\t\th = cache_list[idx].su_h;\n\t\tif (x >= 0) {\n\t\t\tsraRgnDestroy(r2);\n\t\t\tr2 = sraRgnCreateRect(x, y, x+w, y+h);\n\t\t\tsraRgnOr(zero_rects, r2);\n\t\t}\n\t}\n\tsraRgnDestroy(r2);\n\n\tCLEAR(idx);\nif (! ok && ncdb) fprintf(stderr, \"**** free_rect: not-found %d\\n\", idx);\n\treturn ok;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fclose",
          "args": [
            "f"
          ],
          "line": 1488
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "q"
          ],
          "line": 1484
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"unrecognized %s\\n\"",
            "q"
          ],
          "line": 1475
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"   debug:n   showmenus:n   noexit:n\\n\""
          ],
          "line": 1473
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"\\n\""
          ],
          "line": 1472
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"   print_logs      (pl)\\n\""
          ],
          "line": 1471
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"   list_all        (ls)\\n\""
          ],
          "line": 1470
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"   list_clients    (lc)\\n\""
          ],
          "line": 1469
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"   list_apps       (la)\\n\""
          ],
          "line": 1468
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"   list_windows    (lw)\\n\""
          ],
          "line": 1467
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"\\n\""
          ],
          "line": 1466
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"   del_client:host (-host, -all)\\n\""
          ],
          "line": 1465
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"   add_client:host (+host)\\n\""
          ],
          "line": 1464
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"   del_app:win     (del_app:pick, del_app:all)\\n\""
          ],
          "line": 1463
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"   add_app:win     (add_app:pick)\\n\""
          ],
          "line": 1462
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"   del_window:win  (del:win, del:pick, del:all)\\n\""
          ],
          "line": 1461
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"   add_window:win  (add:win, add:pick)\\n\""
          ],
          "line": 1460
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"\\n\""
          ],
          "line": 1459
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"   quit restart noop x11vnc help ? ! !!\\n\""
          ],
          "line": 1458
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"\\n\""
          ],
          "line": 1457
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"available commands:\\n\""
          ],
          "line": 1456
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "cmd",
            "\"help\""
          ],
          "line": 1455
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "cmd",
            "\"h\""
          ],
          "line": 1455
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "cmd",
            "\"?\""
          ],
          "line": 1455
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "print_logs",
          "args": [],
          "line": 1454
        },
        "resolved": true,
        "details": {
          "function_name": "print_logs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/appshare.c",
          "lines": "595-628",
          "snippet": "static void print_logs(void) {\n\tif (trackdir) {\n\t\tDIR *dir = opendir(trackdir);\n\t\tif (dir) {\n\t\t\tstruct dirent *dp;\n\t\t\twhile ( (dp = readdir(dir)) != NULL) {\n\t\t\t\tFILE *f;\n\t\t\t\tchar *name = dp->d_name;\n\t\t\t\tif (!strcmp(name, \".\") || !strcmp(name, \"..\")) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (strstr(name, \"0x\") != name) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (strstr(name, \".log\") == NULL) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tsprintf(tracktmp, \"%s/%s\", trackdir, name);\n\t\t\t\tf = fopen(tracktmp, \"r\");\n\t\t\t\tif (f) {\n\t\t\t\t\tchar line[1024];\n\t\t\t\t\tfprintf(stderr, \"===== x11vnc log %s =====\\n\", tracktmp);\n\t\t\t\t\twhile (fgets(line, sizeof(line), f) != NULL) {\n\t\t\t\t\t\tfprintf(stderr, \"%s\", line);\n\t\t\t\t\t}\n\t\t\t\t\tfprintf(stderr, \"\\n\");\n\t\t\t\t\tff();\n\t\t\t\t\tfclose(f);\n\t\t\t\t}\n\t\t\t}\n\t\t\tclosedir(dir);\n\t\t}\n\t}\n}",
          "includes": [
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"x11vnc.h\"\n\nstatic void print_logs(void) {\n\tif (trackdir) {\n\t\tDIR *dir = opendir(trackdir);\n\t\tif (dir) {\n\t\t\tstruct dirent *dp;\n\t\t\twhile ( (dp = readdir(dir)) != NULL) {\n\t\t\t\tFILE *f;\n\t\t\t\tchar *name = dp->d_name;\n\t\t\t\tif (!strcmp(name, \".\") || !strcmp(name, \"..\")) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (strstr(name, \"0x\") != name) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (strstr(name, \".log\") == NULL) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tsprintf(tracktmp, \"%s/%s\", trackdir, name);\n\t\t\t\tf = fopen(tracktmp, \"r\");\n\t\t\t\tif (f) {\n\t\t\t\t\tchar line[1024];\n\t\t\t\t\tfprintf(stderr, \"===== x11vnc log %s =====\\n\", tracktmp);\n\t\t\t\t\twhile (fgets(line, sizeof(line), f) != NULL) {\n\t\t\t\t\t\tfprintf(stderr, \"%s\", line);\n\t\t\t\t\t}\n\t\t\t\t\tfprintf(stderr, \"\\n\");\n\t\t\t\t\tff();\n\t\t\t\t\tfclose(f);\n\t\t\t\t}\n\t\t\t}\n\t\t\tclosedir(dir);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "cmd",
            "\"pl\""
          ],
          "line": 1453
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "cmd",
            "\"print_logs\""
          ],
          "line": 1453
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_clients",
          "args": [],
          "line": 1452
        },
        "resolved": true,
        "details": {
          "function_name": "list_clients",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/appshare.c",
          "lines": "1313-1323",
          "snippet": "static void list_clients(void) {\n\tint i, n = 0;\n\tfor (i=0; i < CMAX; i++) {\n\t\tif (clients[i] == NULL) {\n\t\t\tcontinue;\n\t\t}\n\t\tfprintf(stdout, \"client[%02d] %s\\n\", ++n, clients[i]);\n\t}\n\tfprintf(stdout, \"total clients: %d\\n\", n);\n\tff();\n}",
          "includes": [
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [
            "#define CMAX 128"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"x11vnc.h\"\n\n#define CMAX 128\n\nstatic void list_clients(void) {\n\tint i, n = 0;\n\tfor (i=0; i < CMAX; i++) {\n\t\tif (clients[i] == NULL) {\n\t\t\tcontinue;\n\t\t}\n\t\tfprintf(stdout, \"client[%02d] %s\\n\", ++n, clients[i]);\n\t}\n\tfprintf(stdout, \"total clients: %d\\n\", n);\n\tff();\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"\\n\""
          ],
          "line": 1451
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_apps",
          "args": [],
          "line": 1450
        },
        "resolved": true,
        "details": {
          "function_name": "list_apps",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/appshare.c",
          "lines": "1342-1357",
          "snippet": "static void list_apps(void) {\n\tint i, n = 0;\n\tfor (i=0; i < AMAX; i++) {\n\t\tchar *name;\n\t\tWindow win = apps[i];\n\t\tif (win == None) {\n\t\t\tcontinue;\n\t\t}\n\t\tget_wm_name(win, &name);\n\t\tfprintf(stdout, \"app[%02d] 0x%08lx state: %d slot: %03d \\\"%s\\\"\\n\",\n\t\t    ++n, win, state[i], i, name);\n\t\tfree(name);\n\t}\n\tfprintf(stdout, \"total apps: %d\\n\", n);\n\tff();\n}",
          "includes": [
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [
            "#define AMAX 32"
          ],
          "globals_used": [
            "extern char *get_xprop(char *prop, Window win);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"x11vnc.h\"\n\n#define AMAX 32\n\nextern char *get_xprop(char *prop, Window win);\n\nstatic void list_apps(void) {\n\tint i, n = 0;\n\tfor (i=0; i < AMAX; i++) {\n\t\tchar *name;\n\t\tWindow win = apps[i];\n\t\tif (win == None) {\n\t\t\tcontinue;\n\t\t}\n\t\tget_wm_name(win, &name);\n\t\tfprintf(stdout, \"app[%02d] 0x%08lx state: %d slot: %03d \\\"%s\\\"\\n\",\n\t\t    ++n, win, state[i], i, name);\n\t\tfree(name);\n\t}\n\tfprintf(stdout, \"total apps: %d\\n\", n);\n\tff();\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"\\n\""
          ],
          "line": 1449
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_windows",
          "args": [],
          "line": 1448
        },
        "resolved": true,
        "details": {
          "function_name": "list_windows",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/appshare.c",
          "lines": "1325-1340",
          "snippet": "static void list_windows(void) {\n\tint i, n = 0;\n\tfor (i=0; i < WMAX; i++) {\n\t\tchar *name;\n\t\tWindow win = watch[i];\n\t\tif (win == None) {\n\t\t\tcontinue;\n\t\t}\n\t\tget_wm_name(win, &name);\n\t\tfprintf(stdout, \"window[%02d] 0x%08lx state: %d slot: %03d \\\"%s\\\"\\n\",\n\t\t    ++n, win, state[i], i, name);\n\t\tfree(name);\n\t}\n\tfprintf(stdout, \"total windows: %d\\n\", n);\n\tff();\n}",
          "includes": [
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [
            "#define WMAX 192"
          ],
          "globals_used": [
            "extern char *get_xprop(char *prop, Window win);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"x11vnc.h\"\n\n#define WMAX 192\n\nextern char *get_xprop(char *prop, Window win);\n\nstatic void list_windows(void) {\n\tint i, n = 0;\n\tfor (i=0; i < WMAX; i++) {\n\t\tchar *name;\n\t\tWindow win = watch[i];\n\t\tif (win == None) {\n\t\t\tcontinue;\n\t\t}\n\t\tget_wm_name(win, &name);\n\t\tfprintf(stdout, \"window[%02d] 0x%08lx state: %d slot: %03d \\\"%s\\\"\\n\",\n\t\t    ++n, win, state[i], i, name);\n\t\tfree(name);\n\t}\n\tfprintf(stdout, \"total windows: %d\\n\", n);\n\tff();\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "cmd",
            "\"ls\""
          ],
          "line": 1447
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "cmd",
            "\"list_all\""
          ],
          "line": 1447
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "cmd",
            "\"la\""
          ],
          "line": 1445
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "cmd",
            "\"list_apps\""
          ],
          "line": 1445
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "cmd",
            "\"lw\""
          ],
          "line": 1443
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "cmd",
            "\"list_windows\""
          ],
          "line": 1443
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "cmd",
            "\"lc\""
          ],
          "line": 1441
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "cmd",
            "\"list_clients\""
          ],
          "line": 1441
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "restart_x11vnc",
          "args": [],
          "line": 1440
        },
        "resolved": true,
        "details": {
          "function_name": "restart_x11vnc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/appshare.c",
          "lines": "1246-1266",
          "snippet": "static void restart_x11vnc(void) {\n\tint i, n = 0;\n\tWindow win, active[WMAX];\n\tfor (i=0; i < WMAX; i++) {\n\t\twin = watch[i];\n\t\tif (win == None) {\n\t\t\tcontinue;\n\t\t}\n\t\tif (state[i]) {\n\t\t\tactive[n++] = win;\n\t\t\tstop(win);\n\t\t}\n\t}\n\tif (n) {\n\t\tusleep(1500 * 1000);\n\t}\n\tfor (i=0; i < n; i++) {\n\t\twin = active[i];\n\t\tlaunch(win);\n\t}\n}",
          "includes": [
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [
            "#define WMAX 192"
          ],
          "globals_used": [
            "extern char *get_xprop(char *prop, Window win);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"x11vnc.h\"\n\n#define WMAX 192\n\nextern char *get_xprop(char *prop, Window win);\n\nstatic void restart_x11vnc(void) {\n\tint i, n = 0;\n\tWindow win, active[WMAX];\n\tfor (i=0; i < WMAX; i++) {\n\t\twin = watch[i];\n\t\tif (win == None) {\n\t\t\tcontinue;\n\t\t}\n\t\tif (state[i]) {\n\t\t\tactive[n++] = win;\n\t\t\tstop(win);\n\t\t}\n\t}\n\tif (n) {\n\t\tusleep(1500 * 1000);\n\t}\n\tfor (i=0; i < n; i++) {\n\t\twin = active[i];\n\t\tlaunch(win);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "cmd",
            "\"restart\""
          ],
          "line": 1439
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "cmd",
            "\"noop\""
          ],
          "line": 1437
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "putenv",
          "args": [
            "cmd + strlen(\"env:\")"
          ],
          "line": 1436
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "\"env:\""
          ],
          "line": 1436
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "cmd",
            "\"env:\""
          ],
          "line": 1435
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "cmd + strlen(\"x11vnc_args:\")"
          ],
          "line": 1434
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "\"x11vnc_args:\""
          ],
          "line": 1434
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "cmd",
            "\"x11vnc_args:\""
          ],
          "line": 1433
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atoi",
          "args": [
            "cmd + strlen(\"tree_depth:\")"
          ],
          "line": 1432
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "\"tree_depth:\""
          ],
          "line": 1432
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "cmd",
            "\"tree_depth:\""
          ],
          "line": 1431
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atoi",
          "args": [
            "cmd + strlen(\"use_forever:\")"
          ],
          "line": 1430
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "\"use_forever:\""
          ],
          "line": 1430
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "cmd",
            "\"use_forever:\""
          ],
          "line": 1429
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atoi",
          "args": [
            "cmd + strlen(\"noexit:\")"
          ],
          "line": 1427
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "\"noexit:\""
          ],
          "line": 1427
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "cmd",
            "\"noexit:\""
          ],
          "line": 1426
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atoi",
          "args": [
            "cmd + strlen(\"showmenus:\")"
          ],
          "line": 1424
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "\"showmenus:\""
          ],
          "line": 1424
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "cmd",
            "\"showmenus:\""
          ],
          "line": 1423
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atoi",
          "args": [
            "cmd + strlen(\"debug:\")"
          ],
          "line": 1422
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "\"debug:\""
          ],
          "line": 1422
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "cmd",
            "\"debug:\""
          ],
          "line": 1421
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "add_or_del_app",
          "args": [
            "cmd + strlen(\"add_app:\")",
            "1"
          ],
          "line": 1420
        },
        "resolved": true,
        "details": {
          "function_name": "add_or_del_app",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/appshare.c",
          "lines": "1137-1156",
          "snippet": "static void add_or_del_app(char *str, int add) {\n\tWindow win = parse_win(str);\n\n\tif (win != None) {\n\t\tif (add) {\n\t\t\tadd_app(win);\n\t\t} else {\n\t\t\tdel_app(win);\n\t\t}\n\t} else if (!strcmp(str, \"all\")) {\n\t\tif (!add) {\n\t\t\tint i;\n\t\t\tfor (i=0; i < AMAX; i++) {\n\t\t\t\tif (apps[i] != None) {\n\t\t\t\t\tdel_app(apps[i]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}",
          "includes": [
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [
            "#define AMAX 32"
          ],
          "globals_used": [
            "extern char *get_xprop(char *prop, Window win);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"x11vnc.h\"\n\n#define AMAX 32\n\nextern char *get_xprop(char *prop, Window win);\n\nstatic void add_or_del_app(char *str, int add) {\n\tWindow win = parse_win(str);\n\n\tif (win != None) {\n\t\tif (add) {\n\t\t\tadd_app(win);\n\t\t} else {\n\t\t\tdel_app(win);\n\t\t}\n\t} else if (!strcmp(str, \"all\")) {\n\t\tif (!add) {\n\t\t\tint i;\n\t\t\tfor (i=0; i < AMAX; i++) {\n\t\t\t\tif (apps[i] != None) {\n\t\t\t\t\tdel_app(apps[i]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "\"add_app:\""
          ],
          "line": 1420
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "cmd",
            "\"add_app:\""
          ],
          "line": 1419
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "\"del_app:\""
          ],
          "line": 1418
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "cmd",
            "\"del_app:\""
          ],
          "line": 1417
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "\"+\""
          ],
          "line": 1416
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "cmd",
            "\"+\""
          ],
          "line": 1415
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "\"-\""
          ],
          "line": 1414
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "cmd",
            "\"-\""
          ],
          "line": 1413
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "\"add_client:\""
          ],
          "line": 1412
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "cmd",
            "\"add_client:\""
          ],
          "line": 1411
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "\"del_client:\""
          ],
          "line": 1410
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "cmd",
            "\"del_client:\""
          ],
          "line": 1409
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "add_or_del_win",
          "args": [
            "cmd + strlen(\"add:\")",
            "1"
          ],
          "line": 1408
        },
        "resolved": true,
        "details": {
          "function_name": "add_or_del_win",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/appshare.c",
          "lines": "1158-1182",
          "snippet": "static void add_or_del_win(char *str, int add) {\n\tWindow win = parse_win(str);\n\n\tif (win != None) {\n\t\tint f = find_win(win);\n\t\tif (add) {\n\t\t\tif (f < 0 && win_attr(win)) {\n\t\t\t\tadd_win(win);\n\t\t\t}\n\t\t} else {\n\t\t\tif (f >= 0) {\n\t\t\t\tdestroy_win(win);\n\t\t\t}\n\t\t}\n\t} else if (!strcmp(str, \"all\")) {\n\t\tif (!add) {\n\t\t\tint i;\n\t\t\tfor (i=0; i < WMAX; i++) {\n\t\t\t\tif (watch[i] != None) {\n\t\t\t\t\tdestroy_win(watch[i]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t} \n}",
          "includes": [
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [
            "#define WMAX 192"
          ],
          "globals_used": [
            "extern char *get_xprop(char *prop, Window win);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"x11vnc.h\"\n\n#define WMAX 192\n\nextern char *get_xprop(char *prop, Window win);\n\nstatic void add_or_del_win(char *str, int add) {\n\tWindow win = parse_win(str);\n\n\tif (win != None) {\n\t\tint f = find_win(win);\n\t\tif (add) {\n\t\t\tif (f < 0 && win_attr(win)) {\n\t\t\t\tadd_win(win);\n\t\t\t}\n\t\t} else {\n\t\t\tif (f >= 0) {\n\t\t\t\tdestroy_win(win);\n\t\t\t}\n\t\t}\n\t} else if (!strcmp(str, \"all\")) {\n\t\tif (!add) {\n\t\t\tint i;\n\t\t\tfor (i=0; i < WMAX; i++) {\n\t\t\t\tif (watch[i] != None) {\n\t\t\t\t\tdestroy_win(watch[i]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t} \n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "\"add:\""
          ],
          "line": 1408
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "cmd",
            "\"add:\""
          ],
          "line": 1407
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "\"del:\""
          ],
          "line": 1406
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "cmd",
            "\"del:\""
          ],
          "line": 1405
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "\"add_window:\""
          ],
          "line": 1404
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "cmd",
            "\"add_window:\""
          ],
          "line": 1403
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "\"del_window:\""
          ],
          "line": 1402
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "cmd",
            "\"del_window:\""
          ],
          "line": 1401
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "cmd",
            "\"bcast:\""
          ],
          "line": 1399
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "cmd",
            "\"wait\""
          ],
          "line": 1397
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "appshare_cleanup",
          "args": [
            "0"
          ],
          "line": 1396
        },
        "resolved": true,
        "details": {
          "function_name": "appshare_cleanup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/appshare.c",
          "lines": "630-688",
          "snippet": "static void appshare_cleanup(int s) {\n\tint i;\n\tif (s) {}\n\n\tif (use_forever) {\n\t\t/* launch this backup in case they kill -9 us before we terminate everything */\n\t\tchar cmd[1000];\n\t\tsprintf(cmd, \"(sleep 3; pkill -TERM -f '%s') &\", unique_tag);\n\t\tif (appshare_debug) fprintf(stderr, \"%s\\n\", cmd);\n\t\tsystem(cmd);\n\t}\n\n\tfor (i=0; i < WMAX; i++) {\n\t\tif (watch[i] != None) {\n\t\t\tstop(watch[i]);\n\t\t}\n\t}\n\n\tif (trackdir) {\n\t\tDIR *dir = opendir(trackdir);\n\t\tif (dir) {\n\t\t\tstruct dirent *dp;\n\t\t\twhile ( (dp = readdir(dir)) != NULL) {\n\t\t\t\tchar *name = dp->d_name;\n\t\t\t\tif (!strcmp(name, \".\") || !strcmp(name, \"..\")) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (strstr(name, \"0x\") != name) {\n\t\t\t\t\tfprintf(stderr, \"skipping: %s\\n\", name);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (!appshare_debug) {\n\t\t\t\t\tfprintf(stderr, \"removing: %s\\n\", name);\n\t\t\t\t\tsprintf(tracktmp, \"%s/%s\", trackdir, name);\n\t\t\t\t\tunlink(tracktmp);\n\t\t\t\t} else {\n\t\t\t\t\tif (appshare_debug) fprintf(stderr, \"keeping:  %s\\n\", name);\n\t\t\t\t}\n\t\t\t}\n\t\t\tclosedir(dir);\n\t\t}\n\t\tif (!appshare_debug) {\n\t\t\tif (strstr(trackdir, trackpre) == trackdir) {\n\t\t\t\tif (appshare_debug) fprintf(stderr, \"removing: %s\\n\", trackdir);\n\t\t\t\trmdir(trackdir);\n\t\t\t}\n\t\t}\n\t\tff();\n\t}\n\n\tkill_helper_pid();\n\t\t\t\n#if !NO_X11\n\tXCloseDisplay(dpy);\n#endif\n\tfprintf(stdout, \"done.\\n\");\n\tff();\n\texit(0);\n}",
          "includes": [
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [
            "#define WMAX 192"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"x11vnc.h\"\n\n#define WMAX 192\n\nstatic void appshare_cleanup(int s) {\n\tint i;\n\tif (s) {}\n\n\tif (use_forever) {\n\t\t/* launch this backup in case they kill -9 us before we terminate everything */\n\t\tchar cmd[1000];\n\t\tsprintf(cmd, \"(sleep 3; pkill -TERM -f '%s') &\", unique_tag);\n\t\tif (appshare_debug) fprintf(stderr, \"%s\\n\", cmd);\n\t\tsystem(cmd);\n\t}\n\n\tfor (i=0; i < WMAX; i++) {\n\t\tif (watch[i] != None) {\n\t\t\tstop(watch[i]);\n\t\t}\n\t}\n\n\tif (trackdir) {\n\t\tDIR *dir = opendir(trackdir);\n\t\tif (dir) {\n\t\t\tstruct dirent *dp;\n\t\t\twhile ( (dp = readdir(dir)) != NULL) {\n\t\t\t\tchar *name = dp->d_name;\n\t\t\t\tif (!strcmp(name, \".\") || !strcmp(name, \"..\")) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (strstr(name, \"0x\") != name) {\n\t\t\t\t\tfprintf(stderr, \"skipping: %s\\n\", name);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (!appshare_debug) {\n\t\t\t\t\tfprintf(stderr, \"removing: %s\\n\", name);\n\t\t\t\t\tsprintf(tracktmp, \"%s/%s\", trackdir, name);\n\t\t\t\t\tunlink(tracktmp);\n\t\t\t\t} else {\n\t\t\t\t\tif (appshare_debug) fprintf(stderr, \"keeping:  %s\\n\", name);\n\t\t\t\t}\n\t\t\t}\n\t\t\tclosedir(dir);\n\t\t}\n\t\tif (!appshare_debug) {\n\t\t\tif (strstr(trackdir, trackpre) == trackdir) {\n\t\t\t\tif (appshare_debug) fprintf(stderr, \"removing: %s\\n\", trackdir);\n\t\t\t\trmdir(trackdir);\n\t\t\t}\n\t\t}\n\t\tff();\n\t}\n\n\tkill_helper_pid();\n\t\t\t\n#if !NO_X11\n\tXCloseDisplay(dpy);\n#endif\n\tfprintf(stdout, \"done.\\n\");\n\tff();\n\texit(0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fclose",
          "args": [
            "f2"
          ],
          "line": 1394
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fopen",
          "args": [
            "file",
            "\"w\""
          ],
          "line": 1393
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "file",
            "\".cmd\""
          ],
          "line": 1392
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "control",
            "file"
          ],
          "line": 1392
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "cmd",
            "\"quit\""
          ],
          "line": 1391
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "\"cmd=\""
          ],
          "line": 1390
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "q",
            "\"cmd=\""
          ],
          "line": 1389
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "q",
            "\"\""
          ],
          "line": 1386
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lblanks",
          "args": [
            "line"
          ],
          "line": 1382
        },
        "resolved": true,
        "details": {
          "function_name": "lblanks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/util.c",
          "lines": "160-169",
          "snippet": "char *lblanks(char *str) {\n\tchar *p = str;\n\twhile (*p != '\\0') {\n\t\tif (! isspace((unsigned char) (*p))) {\n\t\t\tbreak;\n\t\t}\n\t\tp++;\n\t}\n\treturn p;\n}",
          "includes": [
            "#include \"connections.h\"",
            "#include \"unixpw.h\"",
            "#include \"win_utils.h\"",
            "#include \"cleanup.h\"",
            "#include \"x11vnc.h\"",
            "#include <stdlib.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void lowercase(char *str);",
            "void uppercase(char *str);",
            "char *lblanks(char *str);",
            "void strzero(char *str);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"connections.h\"\n#include \"unixpw.h\"\n#include \"win_utils.h\"\n#include \"cleanup.h\"\n#include \"x11vnc.h\"\n#include <stdlib.h>\n\nvoid lowercase(char *str);\nvoid uppercase(char *str);\nchar *lblanks(char *str);\nvoid strzero(char *str);\n\nchar *lblanks(char *str) {\n\tchar *p = str;\n\twhile (*p != '\\0') {\n\t\tif (! isspace((unsigned char) (*p))) {\n\t\t\tbreak;\n\t\t}\n\t\tp++;\n\t}\n\treturn p;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"check_control: %s\\n\"",
            "line"
          ],
          "line": 1378
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "line",
            "'\\n'"
          ],
          "line": 1374
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fgets",
          "args": [
            "line",
            "sizeof(line)",
            "f"
          ],
          "line": 1373
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fopen",
          "args": [
            "file",
            "\"r\""
          ],
          "line": 1364
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"x11vnc.h\"\n\n#define CMAX 128\n\nextern char *get_xprop(char *prop, Window win);\n\nstatic int process_control(char *file, int check_clients) {\n\tint i, nnew = 0, seen[CMAX];\n\tchar line[1024], *newctl[CMAX];\n\tFILE *f;\n\n\tf = fopen(file, \"r\");\n\tif (!f) {\n\t\treturn 1;\n\t}\n\tif (check_clients) {\n\t\tfor (i=0; i < CMAX; i++) {\n\t\t\tseen[i] = 0;\n\t\t}\n\t}\n\twhile (fgets(line, sizeof(line), f) != NULL) {\n\t\tchar *q = strchr(line, '\\n');\n\t\tif (q) *q = '\\0';\n\n\t\tif (appshare_debug) {\n\t\t\tfprintf(stderr, \"check_control: %s\\n\", line);\n\t\t\tff();\n\t\t}\n\n\t\tq = lblanks(line);\n\t\tif (q[0] == '#') {\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strcmp(q, \"\")) {\n\t\t\tcontinue;\n\t\t}\n\t\tif (strstr(q, \"cmd=\") == q) {\n\t\t\tchar *cmd = q + strlen(\"cmd=\");\n\t\t\tif (!strcmp(cmd, \"quit\")) {\n\t\t\t\tif (strcmp(control, file) && strstr(file, \".cmd\")) {\n\t\t\t\t\tFILE *f2 = fopen(file, \"w\");\n\t\t\t\t\tif (f2) fclose(f2);\n\t\t\t\t}\n\t\t\t\tappshare_cleanup(0);\n\t\t\t} else if (!strcmp(cmd, \"wait\")) {\n\t\t\t\treturn 0;\n\t\t\t} else if (strstr(cmd, \"bcast:\") == cmd) {\n\t\t\t\t;\n\t\t\t} else if (strstr(cmd, \"del_window:\") == cmd) {\n\t\t\t\tadd_or_del_win(cmd + strlen(\"del_window:\"), 0);\n\t\t\t} else if (strstr(cmd, \"add_window:\") == cmd) {\n\t\t\t\tadd_or_del_win(cmd + strlen(\"add_window:\"), 1);\n\t\t\t} else if (strstr(cmd, \"del:\") == cmd) {\n\t\t\t\tadd_or_del_win(cmd + strlen(\"del:\"), 0);\n\t\t\t} else if (strstr(cmd, \"add:\") == cmd) {\n\t\t\t\tadd_or_del_win(cmd + strlen(\"add:\"), 1);\n\t\t\t} else if (strstr(cmd, \"del_client:\") == cmd) {\n\t\t\t\tadd_or_del_client(cmd + strlen(\"del_client:\"), 0);\n\t\t\t} else if (strstr(cmd, \"add_client:\") == cmd) {\n\t\t\t\tadd_or_del_client(cmd + strlen(\"add_client:\"), 1);\n\t\t\t} else if (strstr(cmd, \"-\") == cmd) {\n\t\t\t\tadd_or_del_client(cmd + strlen(\"-\"), 0);\n\t\t\t} else if (strstr(cmd, \"+\") == cmd) {\n\t\t\t\tadd_or_del_client(cmd + strlen(\"+\"), 1);\n\t\t\t} else if (strstr(cmd, \"del_app:\") == cmd) {\n\t\t\t\tadd_or_del_app(cmd + strlen(\"del_app:\"), 0);\n\t\t\t} else if (strstr(cmd, \"add_app:\") == cmd) {\n\t\t\t\tadd_or_del_app(cmd + strlen(\"add_app:\"), 1);\n\t\t\t} else if (strstr(cmd, \"debug:\") == cmd) {\n\t\t\t\tappshare_debug = atoi(cmd + strlen(\"debug:\"));\n\t\t\t} else if (strstr(cmd, \"showmenus:\") == cmd) {\n\t\t\t\tskip_menus = atoi(cmd + strlen(\"showmenus:\"));\n\t\t\t\tskip_menus = !(skip_menus);\n\t\t\t} else if (strstr(cmd, \"noexit:\") == cmd) {\n\t\t\t\texit_no_app_win = atoi(cmd + strlen(\"noexit:\"));\n\t\t\t\texit_no_app_win = !(exit_no_app_win);\n\t\t\t} else if (strstr(cmd, \"use_forever:\") == cmd) {\n\t\t\t\tuse_forever = atoi(cmd + strlen(\"use_forever:\"));\n\t\t\t} else if (strstr(cmd, \"tree_depth:\") == cmd) {\n\t\t\t\ttree_depth = atoi(cmd + strlen(\"tree_depth:\"));\n\t\t\t} else if (strstr(cmd, \"x11vnc_args:\") == cmd) {\n\t\t\t\tx11vnc_args = strdup(cmd + strlen(\"x11vnc_args:\"));\n\t\t\t} else if (strstr(cmd, \"env:\") == cmd) {\n\t\t\t\tputenv(cmd + strlen(\"env:\"));\n\t\t\t} else if (strstr(cmd, \"noop\") == cmd) {\n\t\t\t\t;\n\t\t\t} else if (!strcmp(cmd, \"restart\")) {\n\t\t\t\trestart_x11vnc();\n\t\t\t} else if (!strcmp(cmd, \"list_clients\") || !strcmp(cmd, \"lc\")) {\n\t\t\t\tlist_clients();\n\t\t\t} else if (!strcmp(cmd, \"list_windows\") || !strcmp(cmd, \"lw\")) {\n\t\t\t\tlist_windows();\n\t\t\t} else if (!strcmp(cmd, \"list_apps\") || !strcmp(cmd, \"la\")) {\n\t\t\t\tlist_apps();\n\t\t\t} else if (!strcmp(cmd, \"list_all\") || !strcmp(cmd, \"ls\")) {\n\t\t\t\tlist_windows();\n\t\t\t\tfprintf(stderr, \"\\n\");\n\t\t\t\tlist_apps();\n\t\t\t\tfprintf(stderr, \"\\n\");\n\t\t\t\tlist_clients();\n\t\t\t} else if (!strcmp(cmd, \"print_logs\") || !strcmp(cmd, \"pl\")) {\n\t\t\t\tprint_logs();\n\t\t\t} else if (!strcmp(cmd, \"?\") || !strcmp(cmd, \"h\") || !strcmp(cmd, \"help\")) {\n\t\t\t\tfprintf(stderr, \"available commands:\\n\");\n\t\t\t\tfprintf(stderr, \"\\n\");\n\t\t\t\tfprintf(stderr, \"   quit restart noop x11vnc help ? ! !!\\n\");\n\t\t\t\tfprintf(stderr, \"\\n\");\n\t\t\t\tfprintf(stderr, \"   add_window:win  (add:win, add:pick)\\n\");\n\t\t\t\tfprintf(stderr, \"   del_window:win  (del:win, del:pick, del:all)\\n\");\n\t\t\t\tfprintf(stderr, \"   add_app:win     (add_app:pick)\\n\");\n\t\t\t\tfprintf(stderr, \"   del_app:win     (del_app:pick, del_app:all)\\n\");\n\t\t\t\tfprintf(stderr, \"   add_client:host (+host)\\n\");\n\t\t\t\tfprintf(stderr, \"   del_client:host (-host, -all)\\n\");\n\t\t\t\tfprintf(stderr, \"\\n\");\n\t\t\t\tfprintf(stderr, \"   list_windows    (lw)\\n\");\n\t\t\t\tfprintf(stderr, \"   list_apps       (la)\\n\");\n\t\t\t\tfprintf(stderr, \"   list_clients    (lc)\\n\");\n\t\t\t\tfprintf(stderr, \"   list_all        (ls)\\n\");\n\t\t\t\tfprintf(stderr, \"   print_logs      (pl)\\n\");\n\t\t\t\tfprintf(stderr, \"\\n\");\n\t\t\t\tfprintf(stderr, \"   debug:n   showmenus:n   noexit:n\\n\");\n\t\t\t} else {\n\t\t\t\tfprintf(stderr, \"unrecognized %s\\n\", q);\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\t\tif (check_clients) {\n\t\t\tint idx = find_client(q);\n\t\t\tif (idx >= 0) {\n\t\t\t\tseen[idx] = 1;\n\t\t\t} else {\n\t\t\t\tnewctl[nnew++] = strdup(q);\n\t\t\t}\n\t\t}\n\t}\n\tfclose(f);\n\n\tif (check_clients) {\n\t\tfor (i=0; i < CMAX; i++) {\n\t\t\tif (clients[i] == NULL) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (!seen[i]) {\n\t\t\t\tclient(clients[i], 0);\n\t\t\t\tfree(clients[i]);\n\t\t\t\tclients[i] = NULL;\n\t\t\t}\n\t\t}\n\t\tfor (i=0; i < nnew; i++) {\n\t\t\tint free = find_client(NULL);\n\t\t\tif (free < 0) {\n\t\t\t\tstatic int cnt = 0;\n\t\t\t\tif (cnt++ < 10) {\n\t\t\t\t\tfprintf(stderr, \"ran out of client slots.\\n\");\n\t\t\t\t\tff();\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tclients[free] = newctl[i];\n\t\t\tclient(newctl[i], 1);\n\t\t}\n\t}\n\treturn 1;\n}"
  },
  {
    "function_name": "list_apps",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/appshare.c",
    "lines": "1342-1357",
    "snippet": "static void list_apps(void) {\n\tint i, n = 0;\n\tfor (i=0; i < AMAX; i++) {\n\t\tchar *name;\n\t\tWindow win = apps[i];\n\t\tif (win == None) {\n\t\t\tcontinue;\n\t\t}\n\t\tget_wm_name(win, &name);\n\t\tfprintf(stdout, \"app[%02d] 0x%08lx state: %d slot: %03d \\\"%s\\\"\\n\",\n\t\t    ++n, win, state[i], i, name);\n\t\tfree(name);\n\t}\n\tfprintf(stdout, \"total apps: %d\\n\", n);\n\tff();\n}",
    "includes": [
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [
      "#define AMAX 32"
    ],
    "globals_used": [
      "extern char *get_xprop(char *prop, Window win);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ff",
          "args": [],
          "line": 1356
        },
        "resolved": true,
        "details": {
          "function_name": "ff",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/appshare.c",
          "lines": "293-296",
          "snippet": "static void ff(void) {\n\tfflush(stdout);\n\tfflush(stderr);\n}",
          "includes": [
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"x11vnc.h\"\n\nstatic void ff(void) {\n\tfflush(stdout);\n\tfflush(stderr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stdout",
            "\"total apps: %d\\n\"",
            "n"
          ],
          "line": 1355
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "name"
          ],
          "line": 1353
        },
        "resolved": true,
        "details": {
          "function_name": "free_rect",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/userinput.c",
          "lines": "6200-6247",
          "snippet": "int free_rect(int idx) {\n\tint n, ok = 0;\n\tsraRegionPtr r1, r2;\n\tint x, y, w, h;\n\n\tif (idx < 0 || idx >= cache_list_num) {\nif (0) fprintf(stderr, \"free_rect: bad index: %d\\n\", idx);\n\t\tclean_up_exit(1);\n\t}\n\n\tx = cache_list[idx].bs_x;\n\ty = cache_list[idx].bs_y;\n\tw = cache_list[idx].bs_w;\n\th = cache_list[idx].bs_h;\n\n\tif (x < 0) {\n\t\tCLEAR(idx);\nif (dnow() > last_client + 5 && ncdb) fprintf(stderr, \"free_rect: already bs_x invalidated: %d bs_x: %d\\n\", idx, x);\n\t\treturn 1;\n\t}\n\n\tr2 = sraRgnCreateRect(x, y, x+w, y+h);\n\n\tn = get_bs_n(y);\n\tif (n >= 0) {\n\t\tr1 = rect_reg[n];\n\t\tsraRgnOr(r1, r2);\n\t\tok = 1;\n\t}\n\n\tif (zero_rects) {\n\t\tsraRgnOr(zero_rects, r2);\n\t\tx = cache_list[idx].su_x;\n\t\ty = cache_list[idx].su_y;\n\t\tw = cache_list[idx].su_w;\n\t\th = cache_list[idx].su_h;\n\t\tif (x >= 0) {\n\t\t\tsraRgnDestroy(r2);\n\t\t\tr2 = sraRgnCreateRect(x, y, x+w, y+h);\n\t\t\tsraRgnOr(zero_rects, r2);\n\t\t}\n\t}\n\tsraRgnDestroy(r2);\n\n\tCLEAR(idx);\nif (! ok && ncdb) fprintf(stderr, \"**** free_rect: not-found %d\\n\", idx);\n\treturn ok;\n}",
          "includes": [
            "#include \"default8x16.h\"",
            "#include \"connections.h\"",
            "#include \"screen.h\"",
            "#include \"cursor.h\"",
            "#include \"macosxCGS.h\"",
            "#include \"macosx.h\"",
            "#include \"unixpw.h\"",
            "#include \"8to24.h\"",
            "#include \"xrandr.h\"",
            "#include \"solid.h\"",
            "#include \"keyboard.h\"",
            "#include \"rates.h\"",
            "#include \"pointer.h\"",
            "#include \"cleanup.h\"",
            "#include \"scan.h\"",
            "#include \"user.h\"",
            "#include \"xevents.h\"",
            "#include \"win_utils.h\"",
            "#include \"xinerama.h\"",
            "#include \"xrecord.h\"",
            "#include \"xdamage.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void mark_for_xdamage(int x, int y, int w, int h);",
            "void set_xdamage_mark(int x, int y, int w, int h);",
            "int find_rect(int idx, int x, int y, int w, int h);",
            "winattr_t *cache_list;",
            "int clipped(int idx);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"default8x16.h\"\n#include \"connections.h\"\n#include \"screen.h\"\n#include \"cursor.h\"\n#include \"macosxCGS.h\"\n#include \"macosx.h\"\n#include \"unixpw.h\"\n#include \"8to24.h\"\n#include \"xrandr.h\"\n#include \"solid.h\"\n#include \"keyboard.h\"\n#include \"rates.h\"\n#include \"pointer.h\"\n#include \"cleanup.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"xevents.h\"\n#include \"win_utils.h\"\n#include \"xinerama.h\"\n#include \"xrecord.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nvoid mark_for_xdamage(int x, int y, int w, int h);\nvoid set_xdamage_mark(int x, int y, int w, int h);\nint find_rect(int idx, int x, int y, int w, int h);\nwinattr_t *cache_list;\nint clipped(int idx);\n\nint free_rect(int idx) {\n\tint n, ok = 0;\n\tsraRegionPtr r1, r2;\n\tint x, y, w, h;\n\n\tif (idx < 0 || idx >= cache_list_num) {\nif (0) fprintf(stderr, \"free_rect: bad index: %d\\n\", idx);\n\t\tclean_up_exit(1);\n\t}\n\n\tx = cache_list[idx].bs_x;\n\ty = cache_list[idx].bs_y;\n\tw = cache_list[idx].bs_w;\n\th = cache_list[idx].bs_h;\n\n\tif (x < 0) {\n\t\tCLEAR(idx);\nif (dnow() > last_client + 5 && ncdb) fprintf(stderr, \"free_rect: already bs_x invalidated: %d bs_x: %d\\n\", idx, x);\n\t\treturn 1;\n\t}\n\n\tr2 = sraRgnCreateRect(x, y, x+w, y+h);\n\n\tn = get_bs_n(y);\n\tif (n >= 0) {\n\t\tr1 = rect_reg[n];\n\t\tsraRgnOr(r1, r2);\n\t\tok = 1;\n\t}\n\n\tif (zero_rects) {\n\t\tsraRgnOr(zero_rects, r2);\n\t\tx = cache_list[idx].su_x;\n\t\ty = cache_list[idx].su_y;\n\t\tw = cache_list[idx].su_w;\n\t\th = cache_list[idx].su_h;\n\t\tif (x >= 0) {\n\t\t\tsraRgnDestroy(r2);\n\t\t\tr2 = sraRgnCreateRect(x, y, x+w, y+h);\n\t\t\tsraRgnOr(zero_rects, r2);\n\t\t}\n\t}\n\tsraRgnDestroy(r2);\n\n\tCLEAR(idx);\nif (! ok && ncdb) fprintf(stderr, \"**** free_rect: not-found %d\\n\", idx);\n\treturn ok;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stdout",
            "\"app[%02d] 0x%08lx state: %d slot: %03d \\\"%s\\\"\\n\"",
            "++n",
            "win",
            "state[i]",
            "i",
            "name"
          ],
          "line": 1351
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_wm_name",
          "args": [
            "win",
            "&name"
          ],
          "line": 1350
        },
        "resolved": true,
        "details": {
          "function_name": "get_wm_name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/appshare.c",
          "lines": "721-733",
          "snippet": "static void get_wm_name(Window win, char **name) {\n\tint ok = 0;\n\n#if !NO_X11\n        XErrorHandler old_handler = XSetErrorHandler(trap_xerror);\n\tok = XFetchName(dpy, win, name);\n       \tXSetErrorHandler(old_handler);\n#endif\n\n\tif (!ok || *name == NULL) {\n\t\t*name = strdup(\"unknown\");\n\t}\n}",
          "includes": [
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "extern char *get_xprop(char *prop, Window win);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"x11vnc.h\"\n\nextern char *get_xprop(char *prop, Window win);\n\nstatic void get_wm_name(Window win, char **name) {\n\tint ok = 0;\n\n#if !NO_X11\n        XErrorHandler old_handler = XSetErrorHandler(trap_xerror);\n\tok = XFetchName(dpy, win, name);\n       \tXSetErrorHandler(old_handler);\n#endif\n\n\tif (!ok || *name == NULL) {\n\t\t*name = strdup(\"unknown\");\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"x11vnc.h\"\n\n#define AMAX 32\n\nextern char *get_xprop(char *prop, Window win);\n\nstatic void list_apps(void) {\n\tint i, n = 0;\n\tfor (i=0; i < AMAX; i++) {\n\t\tchar *name;\n\t\tWindow win = apps[i];\n\t\tif (win == None) {\n\t\t\tcontinue;\n\t\t}\n\t\tget_wm_name(win, &name);\n\t\tfprintf(stdout, \"app[%02d] 0x%08lx state: %d slot: %03d \\\"%s\\\"\\n\",\n\t\t    ++n, win, state[i], i, name);\n\t\tfree(name);\n\t}\n\tfprintf(stdout, \"total apps: %d\\n\", n);\n\tff();\n}"
  },
  {
    "function_name": "list_windows",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/appshare.c",
    "lines": "1325-1340",
    "snippet": "static void list_windows(void) {\n\tint i, n = 0;\n\tfor (i=0; i < WMAX; i++) {\n\t\tchar *name;\n\t\tWindow win = watch[i];\n\t\tif (win == None) {\n\t\t\tcontinue;\n\t\t}\n\t\tget_wm_name(win, &name);\n\t\tfprintf(stdout, \"window[%02d] 0x%08lx state: %d slot: %03d \\\"%s\\\"\\n\",\n\t\t    ++n, win, state[i], i, name);\n\t\tfree(name);\n\t}\n\tfprintf(stdout, \"total windows: %d\\n\", n);\n\tff();\n}",
    "includes": [
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [
      "#define WMAX 192"
    ],
    "globals_used": [
      "extern char *get_xprop(char *prop, Window win);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ff",
          "args": [],
          "line": 1339
        },
        "resolved": true,
        "details": {
          "function_name": "ff",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/appshare.c",
          "lines": "293-296",
          "snippet": "static void ff(void) {\n\tfflush(stdout);\n\tfflush(stderr);\n}",
          "includes": [
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"x11vnc.h\"\n\nstatic void ff(void) {\n\tfflush(stdout);\n\tfflush(stderr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stdout",
            "\"total windows: %d\\n\"",
            "n"
          ],
          "line": 1338
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "name"
          ],
          "line": 1336
        },
        "resolved": true,
        "details": {
          "function_name": "free_rect",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/userinput.c",
          "lines": "6200-6247",
          "snippet": "int free_rect(int idx) {\n\tint n, ok = 0;\n\tsraRegionPtr r1, r2;\n\tint x, y, w, h;\n\n\tif (idx < 0 || idx >= cache_list_num) {\nif (0) fprintf(stderr, \"free_rect: bad index: %d\\n\", idx);\n\t\tclean_up_exit(1);\n\t}\n\n\tx = cache_list[idx].bs_x;\n\ty = cache_list[idx].bs_y;\n\tw = cache_list[idx].bs_w;\n\th = cache_list[idx].bs_h;\n\n\tif (x < 0) {\n\t\tCLEAR(idx);\nif (dnow() > last_client + 5 && ncdb) fprintf(stderr, \"free_rect: already bs_x invalidated: %d bs_x: %d\\n\", idx, x);\n\t\treturn 1;\n\t}\n\n\tr2 = sraRgnCreateRect(x, y, x+w, y+h);\n\n\tn = get_bs_n(y);\n\tif (n >= 0) {\n\t\tr1 = rect_reg[n];\n\t\tsraRgnOr(r1, r2);\n\t\tok = 1;\n\t}\n\n\tif (zero_rects) {\n\t\tsraRgnOr(zero_rects, r2);\n\t\tx = cache_list[idx].su_x;\n\t\ty = cache_list[idx].su_y;\n\t\tw = cache_list[idx].su_w;\n\t\th = cache_list[idx].su_h;\n\t\tif (x >= 0) {\n\t\t\tsraRgnDestroy(r2);\n\t\t\tr2 = sraRgnCreateRect(x, y, x+w, y+h);\n\t\t\tsraRgnOr(zero_rects, r2);\n\t\t}\n\t}\n\tsraRgnDestroy(r2);\n\n\tCLEAR(idx);\nif (! ok && ncdb) fprintf(stderr, \"**** free_rect: not-found %d\\n\", idx);\n\treturn ok;\n}",
          "includes": [
            "#include \"default8x16.h\"",
            "#include \"connections.h\"",
            "#include \"screen.h\"",
            "#include \"cursor.h\"",
            "#include \"macosxCGS.h\"",
            "#include \"macosx.h\"",
            "#include \"unixpw.h\"",
            "#include \"8to24.h\"",
            "#include \"xrandr.h\"",
            "#include \"solid.h\"",
            "#include \"keyboard.h\"",
            "#include \"rates.h\"",
            "#include \"pointer.h\"",
            "#include \"cleanup.h\"",
            "#include \"scan.h\"",
            "#include \"user.h\"",
            "#include \"xevents.h\"",
            "#include \"win_utils.h\"",
            "#include \"xinerama.h\"",
            "#include \"xrecord.h\"",
            "#include \"xdamage.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void mark_for_xdamage(int x, int y, int w, int h);",
            "void set_xdamage_mark(int x, int y, int w, int h);",
            "int find_rect(int idx, int x, int y, int w, int h);",
            "winattr_t *cache_list;",
            "int clipped(int idx);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"default8x16.h\"\n#include \"connections.h\"\n#include \"screen.h\"\n#include \"cursor.h\"\n#include \"macosxCGS.h\"\n#include \"macosx.h\"\n#include \"unixpw.h\"\n#include \"8to24.h\"\n#include \"xrandr.h\"\n#include \"solid.h\"\n#include \"keyboard.h\"\n#include \"rates.h\"\n#include \"pointer.h\"\n#include \"cleanup.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"xevents.h\"\n#include \"win_utils.h\"\n#include \"xinerama.h\"\n#include \"xrecord.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nvoid mark_for_xdamage(int x, int y, int w, int h);\nvoid set_xdamage_mark(int x, int y, int w, int h);\nint find_rect(int idx, int x, int y, int w, int h);\nwinattr_t *cache_list;\nint clipped(int idx);\n\nint free_rect(int idx) {\n\tint n, ok = 0;\n\tsraRegionPtr r1, r2;\n\tint x, y, w, h;\n\n\tif (idx < 0 || idx >= cache_list_num) {\nif (0) fprintf(stderr, \"free_rect: bad index: %d\\n\", idx);\n\t\tclean_up_exit(1);\n\t}\n\n\tx = cache_list[idx].bs_x;\n\ty = cache_list[idx].bs_y;\n\tw = cache_list[idx].bs_w;\n\th = cache_list[idx].bs_h;\n\n\tif (x < 0) {\n\t\tCLEAR(idx);\nif (dnow() > last_client + 5 && ncdb) fprintf(stderr, \"free_rect: already bs_x invalidated: %d bs_x: %d\\n\", idx, x);\n\t\treturn 1;\n\t}\n\n\tr2 = sraRgnCreateRect(x, y, x+w, y+h);\n\n\tn = get_bs_n(y);\n\tif (n >= 0) {\n\t\tr1 = rect_reg[n];\n\t\tsraRgnOr(r1, r2);\n\t\tok = 1;\n\t}\n\n\tif (zero_rects) {\n\t\tsraRgnOr(zero_rects, r2);\n\t\tx = cache_list[idx].su_x;\n\t\ty = cache_list[idx].su_y;\n\t\tw = cache_list[idx].su_w;\n\t\th = cache_list[idx].su_h;\n\t\tif (x >= 0) {\n\t\t\tsraRgnDestroy(r2);\n\t\t\tr2 = sraRgnCreateRect(x, y, x+w, y+h);\n\t\t\tsraRgnOr(zero_rects, r2);\n\t\t}\n\t}\n\tsraRgnDestroy(r2);\n\n\tCLEAR(idx);\nif (! ok && ncdb) fprintf(stderr, \"**** free_rect: not-found %d\\n\", idx);\n\treturn ok;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stdout",
            "\"window[%02d] 0x%08lx state: %d slot: %03d \\\"%s\\\"\\n\"",
            "++n",
            "win",
            "state[i]",
            "i",
            "name"
          ],
          "line": 1334
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_wm_name",
          "args": [
            "win",
            "&name"
          ],
          "line": 1333
        },
        "resolved": true,
        "details": {
          "function_name": "get_wm_name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/appshare.c",
          "lines": "721-733",
          "snippet": "static void get_wm_name(Window win, char **name) {\n\tint ok = 0;\n\n#if !NO_X11\n        XErrorHandler old_handler = XSetErrorHandler(trap_xerror);\n\tok = XFetchName(dpy, win, name);\n       \tXSetErrorHandler(old_handler);\n#endif\n\n\tif (!ok || *name == NULL) {\n\t\t*name = strdup(\"unknown\");\n\t}\n}",
          "includes": [
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "extern char *get_xprop(char *prop, Window win);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"x11vnc.h\"\n\nextern char *get_xprop(char *prop, Window win);\n\nstatic void get_wm_name(Window win, char **name) {\n\tint ok = 0;\n\n#if !NO_X11\n        XErrorHandler old_handler = XSetErrorHandler(trap_xerror);\n\tok = XFetchName(dpy, win, name);\n       \tXSetErrorHandler(old_handler);\n#endif\n\n\tif (!ok || *name == NULL) {\n\t\t*name = strdup(\"unknown\");\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"x11vnc.h\"\n\n#define WMAX 192\n\nextern char *get_xprop(char *prop, Window win);\n\nstatic void list_windows(void) {\n\tint i, n = 0;\n\tfor (i=0; i < WMAX; i++) {\n\t\tchar *name;\n\t\tWindow win = watch[i];\n\t\tif (win == None) {\n\t\t\tcontinue;\n\t\t}\n\t\tget_wm_name(win, &name);\n\t\tfprintf(stdout, \"window[%02d] 0x%08lx state: %d slot: %03d \\\"%s\\\"\\n\",\n\t\t    ++n, win, state[i], i, name);\n\t\tfree(name);\n\t}\n\tfprintf(stdout, \"total windows: %d\\n\", n);\n\tff();\n}"
  },
  {
    "function_name": "list_clients",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/appshare.c",
    "lines": "1313-1323",
    "snippet": "static void list_clients(void) {\n\tint i, n = 0;\n\tfor (i=0; i < CMAX; i++) {\n\t\tif (clients[i] == NULL) {\n\t\t\tcontinue;\n\t\t}\n\t\tfprintf(stdout, \"client[%02d] %s\\n\", ++n, clients[i]);\n\t}\n\tfprintf(stdout, \"total clients: %d\\n\", n);\n\tff();\n}",
    "includes": [
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [
      "#define CMAX 128"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ff",
          "args": [],
          "line": 1322
        },
        "resolved": true,
        "details": {
          "function_name": "ff",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/appshare.c",
          "lines": "293-296",
          "snippet": "static void ff(void) {\n\tfflush(stdout);\n\tfflush(stderr);\n}",
          "includes": [
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"x11vnc.h\"\n\nstatic void ff(void) {\n\tfflush(stdout);\n\tfflush(stderr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stdout",
            "\"total clients: %d\\n\"",
            "n"
          ],
          "line": 1321
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stdout",
            "\"client[%02d] %s\\n\"",
            "++n",
            "clients[i]"
          ],
          "line": 1319
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"x11vnc.h\"\n\n#define CMAX 128\n\nstatic void list_clients(void) {\n\tint i, n = 0;\n\tfor (i=0; i < CMAX; i++) {\n\t\tif (clients[i] == NULL) {\n\t\t\tcontinue;\n\t\t}\n\t\tfprintf(stdout, \"client[%02d] %s\\n\", ++n, clients[i]);\n\t}\n\tfprintf(stdout, \"total clients: %d\\n\", n);\n\tff();\n}"
  },
  {
    "function_name": "ours",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/appshare.c",
    "lines": "1301-1311",
    "snippet": "static int ours(Window win) {\n\tint i;\n\tfor (i=0; i < AMAX; i++) {\n\t\tif (apps[i] != None) {\n\t\t\tif (same_app(win, apps[i])) {\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [
      "#define AMAX 32"
    ],
    "globals_used": [
      "extern char *get_xprop(char *prop, Window win);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "same_app",
          "args": [
            "win",
            "apps[i]"
          ],
          "line": 1305
        },
        "resolved": true,
        "details": {
          "function_name": "same_app",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/appshare.c",
          "lines": "1293-1299",
          "snippet": "static int same_app(Window win, Window app) {\n\tif ( (win & cmask) == (app & cmask) ) {\n\t\treturn 1;\n\t} else {\n\t\treturn 0;\n\t}\n}",
          "includes": [
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "extern char *get_xprop(char *prop, Window win);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"x11vnc.h\"\n\nextern char *get_xprop(char *prop, Window win);\n\nstatic int same_app(Window win, Window app) {\n\tif ( (win & cmask) == (app & cmask) ) {\n\t\treturn 1;\n\t} else {\n\t\treturn 0;\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"x11vnc.h\"\n\n#define AMAX 32\n\nextern char *get_xprop(char *prop, Window win);\n\nstatic int ours(Window win) {\n\tint i;\n\tfor (i=0; i < AMAX; i++) {\n\t\tif (apps[i] != None) {\n\t\t\tif (same_app(win, apps[i])) {\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "same_app",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/appshare.c",
    "lines": "1293-1299",
    "snippet": "static int same_app(Window win, Window app) {\n\tif ( (win & cmask) == (app & cmask) ) {\n\t\treturn 1;\n\t} else {\n\t\treturn 0;\n\t}\n}",
    "includes": [
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "extern char *get_xprop(char *prop, Window win);"
    ],
    "called_functions": [],
    "contextual_snippet": "#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"x11vnc.h\"\n\nextern char *get_xprop(char *prop, Window win);\n\nstatic int same_app(Window win, Window app) {\n\tif ( (win & cmask) == (app & cmask) ) {\n\t\treturn 1;\n\t} else {\n\t\treturn 0;\n\t}\n}"
  },
  {
    "function_name": "init_cmask",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/appshare.c",
    "lines": "1270-1291",
    "snippet": "static void init_cmask(void) {\n\t/* dependent on the X server implementation; XmuClientWindow better? */\n\t/* xc/programs/Xserver/include/resource.h */\n\tint didit = 0, res_cnt = 29, client_bits = 8;\n\n\tif (getenv(\"X11VNC_APPSHARE_CLIENT_MASK\")) {\n\t\tunsigned long cr;\n\t\tif (sscanf(getenv(\"X11VNC_APPSHARE_CLIENT_MASK\"), \"0x%lx\", &cr) == 1) {\n\t\t\tcmask = cr;\n\t\t\tdidit = 1;\n\t\t}\n\t} else if (getenv(\"X11VNC_APPSHARE_CLIENT_BITS\")) {\n\t\tint cr = atoi(getenv(\"X11VNC_APPSHARE_CLIENT_BITS\"));\n\t\tif (cr > 0) {\n\t\t\tclient_bits = cr;\n\t\t}\n\t}\n\tif (!didit) {\n\t\tcmask = (((1 << client_bits) - 1) << (res_cnt-client_bits));\n\t}\n\tfprintf(stderr, \"client_mask: 0x%08lx\\n\", cmask);\n}",
    "includes": [
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"client_mask: 0x%08lx\\n\"",
            "cmask"
          ],
          "line": 1290
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atoi",
          "args": [
            "getenv(\"X11VNC_APPSHARE_CLIENT_BITS\")"
          ],
          "line": 1282
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getenv",
          "args": [
            "\"X11VNC_APPSHARE_CLIENT_BITS\""
          ],
          "line": 1282
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getenv",
          "args": [
            "\"X11VNC_APPSHARE_CLIENT_BITS\""
          ],
          "line": 1281
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sscanf",
          "args": [
            "getenv(\"X11VNC_APPSHARE_CLIENT_MASK\")",
            "\"0x%lx\"",
            "&cr"
          ],
          "line": 1277
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getenv",
          "args": [
            "\"X11VNC_APPSHARE_CLIENT_MASK\""
          ],
          "line": 1277
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getenv",
          "args": [
            "\"X11VNC_APPSHARE_CLIENT_MASK\""
          ],
          "line": 1275
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"x11vnc.h\"\n\nstatic void init_cmask(void) {\n\t/* dependent on the X server implementation; XmuClientWindow better? */\n\t/* xc/programs/Xserver/include/resource.h */\n\tint didit = 0, res_cnt = 29, client_bits = 8;\n\n\tif (getenv(\"X11VNC_APPSHARE_CLIENT_MASK\")) {\n\t\tunsigned long cr;\n\t\tif (sscanf(getenv(\"X11VNC_APPSHARE_CLIENT_MASK\"), \"0x%lx\", &cr) == 1) {\n\t\t\tcmask = cr;\n\t\t\tdidit = 1;\n\t\t}\n\t} else if (getenv(\"X11VNC_APPSHARE_CLIENT_BITS\")) {\n\t\tint cr = atoi(getenv(\"X11VNC_APPSHARE_CLIENT_BITS\"));\n\t\tif (cr > 0) {\n\t\t\tclient_bits = cr;\n\t\t}\n\t}\n\tif (!didit) {\n\t\tcmask = (((1 << client_bits) - 1) << (res_cnt-client_bits));\n\t}\n\tfprintf(stderr, \"client_mask: 0x%08lx\\n\", cmask);\n}"
  },
  {
    "function_name": "restart_x11vnc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/appshare.c",
    "lines": "1246-1266",
    "snippet": "static void restart_x11vnc(void) {\n\tint i, n = 0;\n\tWindow win, active[WMAX];\n\tfor (i=0; i < WMAX; i++) {\n\t\twin = watch[i];\n\t\tif (win == None) {\n\t\t\tcontinue;\n\t\t}\n\t\tif (state[i]) {\n\t\t\tactive[n++] = win;\n\t\t\tstop(win);\n\t\t}\n\t}\n\tif (n) {\n\t\tusleep(1500 * 1000);\n\t}\n\tfor (i=0; i < n; i++) {\n\t\twin = active[i];\n\t\tlaunch(win);\n\t}\n}",
    "includes": [
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [
      "#define WMAX 192"
    ],
    "globals_used": [
      "extern char *get_xprop(char *prop, Window win);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "launch",
          "args": [
            "win"
          ],
          "line": 1264
        },
        "resolved": true,
        "details": {
          "function_name": "launch",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/appshare.c",
          "lines": "393-503",
          "snippet": "static void launch(Window win) {\n\tchar *cmd, *tmp, *connto, *name;\n\tint len, timeo = 30, uf = use_forever;\n\tint w = 0, h = 0, x = 0, y = 0;\n\n\tif (win_attr(win)) {\n\t\t/* maybe switch to debug only. */\n\t\tw = attr.width;\n\t\th = attr.height;\n\t\tget_xy(win, &x, &y);\n\t}\n\n\tget_wm_name(win, &name);\n\n\tif (strstr(x11vnc_args, \"-once\")) {\n\t\tuf = 0;\n\t}\n\n\tif (control) {\n\t\tint i = 0;\n\t\tlen = 0;\n\t\tfor (i=0; i < CMAX; i++) {\n\t\t\tif (clients[i] != NULL) {\n\t\t\t\tlen += strlen(clients[i]) + 2;\n\t\t\t}\n\t\t}\n\t\tconnto = (char *) calloc(len, 1);\n\t\tfor (i=0; i < CMAX; i++) {\n\t\t\tif (clients[i] != NULL) {\n\t\t\t\tif (connto[0] != '\\0') {\n\t\t\t\t\tstrcat(connto, \",\");\n\t\t\t\t}\n\t\t\t\tstrcat(connto, clients[i]);\n\t\t\t}\n\t\t}\n\t} else {\n\t\tconnto = strdup(connect_to);\n\t}\n\tif (!strcmp(connto, \"\")) {\n\t\ttimeo = 0;\n\t}\n\tif (uf) {\n\t\ttimeo = 0;\n\t}\n\t\n\tlen = 1000 + strlen(x11vnc) + strlen(connto) + strlen(x11vnc_args)\n\t    + 3 * (trackdir ? strlen(trackdir) : 100);\n\n\tcmd = (char *) calloc(len, 1);\n\ttmp = (char *) calloc(len, 1);\n\n\tsprintf(cmd, \"%s %s 0x%lx -bg -quiet %s -nopw -rfbport 0 \"\n\t    \"-timeout %d -noxdamage -noxinerama -norc -repeat -speeds dsl \"\n\t    \"-env X11VNC_AVOID_WINDOWS=never -env X11VNC_APPSHARE_ACTIVE=1 \"\n\t    \"-env X11VNC_NO_CHECK_PM=1 -env %s -novncconnect -shared -nonap \"\n\t    \"-remote_prefix X11VNC_APPSHARE_CMD:\",\n\t    x11vnc, id_opt, win, use_forever ? \"-forever\" : \"-once\", timeo, unique_tag);\n\n\tif (trackdir) {\n\t\tFILE *f;\n\t\tsprintf(tracktmp, \" -noquiet -o %s/0x%lx.log\", trackdir, win);\n\t\tstrcat(cmd, tracktmp);\n\t\tsprintf(tracktmp, \"%s/0x%lx.connect\", trackdir, win);\n\t\tf = fopen(tracktmp, \"w\");\n\t\tif (f) {\n\t\t\tfprintf(f, \"%s\", connto);\n\t\t\tfclose(f);\n\t\t\tsprintf(tmp, \" -connect_or_exit '%s'\", tracktmp);\n\t\t\tstrcat(cmd, tmp);\n\t\t} else {\n\t\t\tsprintf(tmp, \" -connect_or_exit '%s'\", connto);\n\t\t\tstrcat(cmd, tmp);\n\t\t}\n\t} else {\n\t\tif (!strcmp(connto, \"\")) {\n\t\t\tsprintf(tmp, \" -connect '%s'\", connto);\n\t\t} else {\n\t\t\tsprintf(tmp, \" -connect_or_exit '%s'\", connto);\n\t\t}\n\t\tstrcat(cmd, tmp);\n\t}\n\tif (uf) {\n\t\tchar *q = strstr(cmd, \"-connect_or_exit\");\n\t\tif (q) q = strstr(q, \"_or_exit\");\n\t\tif (q) {\n\t\t\tunsigned int i;\n\t\t\tfor (i=0; i < strlen(\"_or_exit\"); i++) {\n\t\t\t\t*q = ' ';\n\t\t\t\tq++;\n\t\t\t}\n\t\t}\n\t}\n\n\tstrcat(cmd, \" \");\n\tstrcat(cmd, x11vnc_args);\n\n\tfprintf(stdout, \"launching: x11vnc for window 0x%08lx %dx%d+%d+%d \\\"%s\\\"\\n\",\n\t    win, w, h, x, y, name);\n\n\tif (appshare_debug) {\n\t\tfprintf(stderr, \"\\nrunning:   %s\\n\\n\", cmd);\n\t}\n\tff();\n\n\tsystem(cmd);\n\n\tfree(cmd);\n\tfree(tmp);\n\tfree(connto);\n\tfree(name);\n}",
          "includes": [
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [
            "#define CMAX 128"
          ],
          "globals_used": [
            "extern char *get_xprop(char *prop, Window win);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"x11vnc.h\"\n\n#define CMAX 128\n\nextern char *get_xprop(char *prop, Window win);\n\nstatic void launch(Window win) {\n\tchar *cmd, *tmp, *connto, *name;\n\tint len, timeo = 30, uf = use_forever;\n\tint w = 0, h = 0, x = 0, y = 0;\n\n\tif (win_attr(win)) {\n\t\t/* maybe switch to debug only. */\n\t\tw = attr.width;\n\t\th = attr.height;\n\t\tget_xy(win, &x, &y);\n\t}\n\n\tget_wm_name(win, &name);\n\n\tif (strstr(x11vnc_args, \"-once\")) {\n\t\tuf = 0;\n\t}\n\n\tif (control) {\n\t\tint i = 0;\n\t\tlen = 0;\n\t\tfor (i=0; i < CMAX; i++) {\n\t\t\tif (clients[i] != NULL) {\n\t\t\t\tlen += strlen(clients[i]) + 2;\n\t\t\t}\n\t\t}\n\t\tconnto = (char *) calloc(len, 1);\n\t\tfor (i=0; i < CMAX; i++) {\n\t\t\tif (clients[i] != NULL) {\n\t\t\t\tif (connto[0] != '\\0') {\n\t\t\t\t\tstrcat(connto, \",\");\n\t\t\t\t}\n\t\t\t\tstrcat(connto, clients[i]);\n\t\t\t}\n\t\t}\n\t} else {\n\t\tconnto = strdup(connect_to);\n\t}\n\tif (!strcmp(connto, \"\")) {\n\t\ttimeo = 0;\n\t}\n\tif (uf) {\n\t\ttimeo = 0;\n\t}\n\t\n\tlen = 1000 + strlen(x11vnc) + strlen(connto) + strlen(x11vnc_args)\n\t    + 3 * (trackdir ? strlen(trackdir) : 100);\n\n\tcmd = (char *) calloc(len, 1);\n\ttmp = (char *) calloc(len, 1);\n\n\tsprintf(cmd, \"%s %s 0x%lx -bg -quiet %s -nopw -rfbport 0 \"\n\t    \"-timeout %d -noxdamage -noxinerama -norc -repeat -speeds dsl \"\n\t    \"-env X11VNC_AVOID_WINDOWS=never -env X11VNC_APPSHARE_ACTIVE=1 \"\n\t    \"-env X11VNC_NO_CHECK_PM=1 -env %s -novncconnect -shared -nonap \"\n\t    \"-remote_prefix X11VNC_APPSHARE_CMD:\",\n\t    x11vnc, id_opt, win, use_forever ? \"-forever\" : \"-once\", timeo, unique_tag);\n\n\tif (trackdir) {\n\t\tFILE *f;\n\t\tsprintf(tracktmp, \" -noquiet -o %s/0x%lx.log\", trackdir, win);\n\t\tstrcat(cmd, tracktmp);\n\t\tsprintf(tracktmp, \"%s/0x%lx.connect\", trackdir, win);\n\t\tf = fopen(tracktmp, \"w\");\n\t\tif (f) {\n\t\t\tfprintf(f, \"%s\", connto);\n\t\t\tfclose(f);\n\t\t\tsprintf(tmp, \" -connect_or_exit '%s'\", tracktmp);\n\t\t\tstrcat(cmd, tmp);\n\t\t} else {\n\t\t\tsprintf(tmp, \" -connect_or_exit '%s'\", connto);\n\t\t\tstrcat(cmd, tmp);\n\t\t}\n\t} else {\n\t\tif (!strcmp(connto, \"\")) {\n\t\t\tsprintf(tmp, \" -connect '%s'\", connto);\n\t\t} else {\n\t\t\tsprintf(tmp, \" -connect_or_exit '%s'\", connto);\n\t\t}\n\t\tstrcat(cmd, tmp);\n\t}\n\tif (uf) {\n\t\tchar *q = strstr(cmd, \"-connect_or_exit\");\n\t\tif (q) q = strstr(q, \"_or_exit\");\n\t\tif (q) {\n\t\t\tunsigned int i;\n\t\t\tfor (i=0; i < strlen(\"_or_exit\"); i++) {\n\t\t\t\t*q = ' ';\n\t\t\t\tq++;\n\t\t\t}\n\t\t}\n\t}\n\n\tstrcat(cmd, \" \");\n\tstrcat(cmd, x11vnc_args);\n\n\tfprintf(stdout, \"launching: x11vnc for window 0x%08lx %dx%d+%d+%d \\\"%s\\\"\\n\",\n\t    win, w, h, x, y, name);\n\n\tif (appshare_debug) {\n\t\tfprintf(stderr, \"\\nrunning:   %s\\n\\n\", cmd);\n\t}\n\tff();\n\n\tsystem(cmd);\n\n\tfree(cmd);\n\tfree(tmp);\n\tfree(connto);\n\tfree(name);\n}"
        }
      },
      {
        "call_info": {
          "callee": "usleep",
          "args": [
            "1500 * 1000"
          ],
          "line": 1260
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "stop",
          "args": [
            "win"
          ],
          "line": 1256
        },
        "resolved": true,
        "details": {
          "function_name": "stop",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/appshare.c",
          "lines": "505-544",
          "snippet": "static void stop(Window win) {\n\tchar *cmd;\n\tint pid = -1;\n\tint f = find_win(win);\n\tif (f < 0 || win == None) {\n\t\treturn;\n\t}\n\tif (state[f] == 0) {\n\t\treturn;\n\t}\n\tif (trackdir) {\n\t\tpid = trackdir_pid(win);\n\t\tif (pid > 0) {\n\t\t\tif (appshare_debug) {fprintf(stderr,\n\t\t\t    \"sending SIGTERM to: %d\\n\", pid); ff();}\n\t\t\tkill((pid_t) pid, SIGTERM);\n\t\t}\n\t}\n\n\tcmd = (char *) malloc(1000 + strlen(x11vnc));\n\tsprintf(cmd, \"pkill -TERM -f '%s %s 0x%lx -bg'\", x11vnc, id_opt, win);\n\tif (appshare_debug) {\n\t\tfprintf(stdout, \"stopping:  0x%08lx - %s\\n\", win, cmd);\n\t} else {\n\t\tfprintf(stdout, \"stopping:  x11vnc for window 0x%08lx  \"\n\t\t    \"(pid: %d)\\n\", win, pid);\n\t}\n\tff();\n\tsystem(cmd);\n\n\tsprintf(cmd, \"(sleep 0.25 2>/dev/null || sleep 1; pkill -KILL -f '%s \"\n\t    \"%s 0x%lx -bg') &\", x11vnc, id_opt, win);\n\tsystem(cmd);\n\n\tif (trackdir) {\n\t\ttrackdir_cleanup(win);\n\t}\n\n\tfree(cmd);\n}",
          "includes": [
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "extern char *get_xprop(char *prop, Window win);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"x11vnc.h\"\n\nextern char *get_xprop(char *prop, Window win);\n\nstatic void stop(Window win) {\n\tchar *cmd;\n\tint pid = -1;\n\tint f = find_win(win);\n\tif (f < 0 || win == None) {\n\t\treturn;\n\t}\n\tif (state[f] == 0) {\n\t\treturn;\n\t}\n\tif (trackdir) {\n\t\tpid = trackdir_pid(win);\n\t\tif (pid > 0) {\n\t\t\tif (appshare_debug) {fprintf(stderr,\n\t\t\t    \"sending SIGTERM to: %d\\n\", pid); ff();}\n\t\t\tkill((pid_t) pid, SIGTERM);\n\t\t}\n\t}\n\n\tcmd = (char *) malloc(1000 + strlen(x11vnc));\n\tsprintf(cmd, \"pkill -TERM -f '%s %s 0x%lx -bg'\", x11vnc, id_opt, win);\n\tif (appshare_debug) {\n\t\tfprintf(stdout, \"stopping:  0x%08lx - %s\\n\", win, cmd);\n\t} else {\n\t\tfprintf(stdout, \"stopping:  x11vnc for window 0x%08lx  \"\n\t\t    \"(pid: %d)\\n\", win, pid);\n\t}\n\tff();\n\tsystem(cmd);\n\n\tsprintf(cmd, \"(sleep 0.25 2>/dev/null || sleep 1; pkill -KILL -f '%s \"\n\t    \"%s 0x%lx -bg') &\", x11vnc, id_opt, win);\n\tsystem(cmd);\n\n\tif (trackdir) {\n\t\ttrackdir_cleanup(win);\n\t}\n\n\tfree(cmd);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"x11vnc.h\"\n\n#define WMAX 192\n\nextern char *get_xprop(char *prop, Window win);\n\nstatic void restart_x11vnc(void) {\n\tint i, n = 0;\n\tWindow win, active[WMAX];\n\tfor (i=0; i < WMAX; i++) {\n\t\twin = watch[i];\n\t\tif (win == None) {\n\t\t\tcontinue;\n\t\t}\n\t\tif (state[i]) {\n\t\t\tactive[n++] = win;\n\t\t\tstop(win);\n\t\t}\n\t}\n\tif (n) {\n\t\tusleep(1500 * 1000);\n\t}\n\tfor (i=0; i < n; i++) {\n\t\twin = active[i];\n\t\tlaunch(win);\n\t}\n}"
  },
  {
    "function_name": "add_or_del_client",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/appshare.c",
    "lines": "1184-1244",
    "snippet": "static void add_or_del_client(char *str, int add) {\n\tint i;\n\n\tif (!str) {\n\t\treturn;\n\t}\n\tif (strcmp(control, \"internal\")) {\n\t\treturn;\n\t}\n\tif (add) {\n\t\tint idx  = find_client(str);\n\t\tint free = find_client(NULL);\n\n\t\tif (idx >=0) {\n\t\t\tfprintf(stderr, \"already tracking client: %s in slot %d\\n\", str, idx);\n\t\t\tff();\n\t\t\treturn;\n\t\t}\n\t\tif (free < 0) {\n\t\t\tstatic int cnt = 0;\n\t\t\tif (cnt++ < 10) {\n\t\t\t\tfprintf(stderr, \"ran out of client slots.\\n\");\n\t\t\t\tff();\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t\tclients[free] = strdup(str);\n\t\tclient(str, 1);\n\t} else {\n\t\tif (str[0] == '#' || str[0] == '%') {\n\t\t\tif (sscanf(str+1, \"%d\", &i) == 1) {\n\t\t\t\ti--;\n\t\t\t\tif (0 <= i && i < CMAX) {\n\t\t\t\t\tif (clients[i] != NULL) {\n\t\t\t\t\t\tclient(clients[i], 0);\n\t\t\t\t\t\tfree(clients[i]);\n\t\t\t\t\t\tclients[i] = NULL;\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (!strcmp(str, \"all\")) {\n\t\t\tfor (i=0; i < CMAX; i++) {\n\t\t\t\tif (clients[i] == NULL) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tclient(clients[i], 0);\n\t\t\t\tfree(clients[i]);\n\t\t\t\tclients[i] = NULL;\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\n\t\ti = find_client(str);\n\t\tif (i >= 0) {\n\t\t\tfree(clients[i]);\n\t\t\tclients[i] = NULL;\n\t\t\tclient(str, 0);\n\t\t}\n\t}\n}",
    "includes": [
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [
      "#define CMAX 128"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "client",
          "args": [
            "str",
            "0"
          ],
          "line": 1241
        },
        "resolved": true,
        "details": {
          "function_name": "add_or_del_client",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/appshare.c",
          "lines": "1184-1244",
          "snippet": "static void add_or_del_client(char *str, int add) {\n\tint i;\n\n\tif (!str) {\n\t\treturn;\n\t}\n\tif (strcmp(control, \"internal\")) {\n\t\treturn;\n\t}\n\tif (add) {\n\t\tint idx  = find_client(str);\n\t\tint free = find_client(NULL);\n\n\t\tif (idx >=0) {\n\t\t\tfprintf(stderr, \"already tracking client: %s in slot %d\\n\", str, idx);\n\t\t\tff();\n\t\t\treturn;\n\t\t}\n\t\tif (free < 0) {\n\t\t\tstatic int cnt = 0;\n\t\t\tif (cnt++ < 10) {\n\t\t\t\tfprintf(stderr, \"ran out of client slots.\\n\");\n\t\t\t\tff();\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t\tclients[free] = strdup(str);\n\t\tclient(str, 1);\n\t} else {\n\t\tif (str[0] == '#' || str[0] == '%') {\n\t\t\tif (sscanf(str+1, \"%d\", &i) == 1) {\n\t\t\t\ti--;\n\t\t\t\tif (0 <= i && i < CMAX) {\n\t\t\t\t\tif (clients[i] != NULL) {\n\t\t\t\t\t\tclient(clients[i], 0);\n\t\t\t\t\t\tfree(clients[i]);\n\t\t\t\t\t\tclients[i] = NULL;\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (!strcmp(str, \"all\")) {\n\t\t\tfor (i=0; i < CMAX; i++) {\n\t\t\t\tif (clients[i] == NULL) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tclient(clients[i], 0);\n\t\t\t\tfree(clients[i]);\n\t\t\t\tclients[i] = NULL;\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\n\t\ti = find_client(str);\n\t\tif (i >= 0) {\n\t\t\tfree(clients[i]);\n\t\t\tclients[i] = NULL;\n\t\t\tclient(str, 0);\n\t\t}\n\t}\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "clients[i]"
          ],
          "line": 1239
        },
        "resolved": true,
        "details": {
          "function_name": "free_rect",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/userinput.c",
          "lines": "6200-6247",
          "snippet": "int free_rect(int idx) {\n\tint n, ok = 0;\n\tsraRegionPtr r1, r2;\n\tint x, y, w, h;\n\n\tif (idx < 0 || idx >= cache_list_num) {\nif (0) fprintf(stderr, \"free_rect: bad index: %d\\n\", idx);\n\t\tclean_up_exit(1);\n\t}\n\n\tx = cache_list[idx].bs_x;\n\ty = cache_list[idx].bs_y;\n\tw = cache_list[idx].bs_w;\n\th = cache_list[idx].bs_h;\n\n\tif (x < 0) {\n\t\tCLEAR(idx);\nif (dnow() > last_client + 5 && ncdb) fprintf(stderr, \"free_rect: already bs_x invalidated: %d bs_x: %d\\n\", idx, x);\n\t\treturn 1;\n\t}\n\n\tr2 = sraRgnCreateRect(x, y, x+w, y+h);\n\n\tn = get_bs_n(y);\n\tif (n >= 0) {\n\t\tr1 = rect_reg[n];\n\t\tsraRgnOr(r1, r2);\n\t\tok = 1;\n\t}\n\n\tif (zero_rects) {\n\t\tsraRgnOr(zero_rects, r2);\n\t\tx = cache_list[idx].su_x;\n\t\ty = cache_list[idx].su_y;\n\t\tw = cache_list[idx].su_w;\n\t\th = cache_list[idx].su_h;\n\t\tif (x >= 0) {\n\t\t\tsraRgnDestroy(r2);\n\t\t\tr2 = sraRgnCreateRect(x, y, x+w, y+h);\n\t\t\tsraRgnOr(zero_rects, r2);\n\t\t}\n\t}\n\tsraRgnDestroy(r2);\n\n\tCLEAR(idx);\nif (! ok && ncdb) fprintf(stderr, \"**** free_rect: not-found %d\\n\", idx);\n\treturn ok;\n}",
          "includes": [
            "#include \"default8x16.h\"",
            "#include \"connections.h\"",
            "#include \"screen.h\"",
            "#include \"cursor.h\"",
            "#include \"macosxCGS.h\"",
            "#include \"macosx.h\"",
            "#include \"unixpw.h\"",
            "#include \"8to24.h\"",
            "#include \"xrandr.h\"",
            "#include \"solid.h\"",
            "#include \"keyboard.h\"",
            "#include \"rates.h\"",
            "#include \"pointer.h\"",
            "#include \"cleanup.h\"",
            "#include \"scan.h\"",
            "#include \"user.h\"",
            "#include \"xevents.h\"",
            "#include \"win_utils.h\"",
            "#include \"xinerama.h\"",
            "#include \"xrecord.h\"",
            "#include \"xdamage.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void mark_for_xdamage(int x, int y, int w, int h);",
            "void set_xdamage_mark(int x, int y, int w, int h);",
            "int find_rect(int idx, int x, int y, int w, int h);",
            "winattr_t *cache_list;",
            "int clipped(int idx);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"default8x16.h\"\n#include \"connections.h\"\n#include \"screen.h\"\n#include \"cursor.h\"\n#include \"macosxCGS.h\"\n#include \"macosx.h\"\n#include \"unixpw.h\"\n#include \"8to24.h\"\n#include \"xrandr.h\"\n#include \"solid.h\"\n#include \"keyboard.h\"\n#include \"rates.h\"\n#include \"pointer.h\"\n#include \"cleanup.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"xevents.h\"\n#include \"win_utils.h\"\n#include \"xinerama.h\"\n#include \"xrecord.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nvoid mark_for_xdamage(int x, int y, int w, int h);\nvoid set_xdamage_mark(int x, int y, int w, int h);\nint find_rect(int idx, int x, int y, int w, int h);\nwinattr_t *cache_list;\nint clipped(int idx);\n\nint free_rect(int idx) {\n\tint n, ok = 0;\n\tsraRegionPtr r1, r2;\n\tint x, y, w, h;\n\n\tif (idx < 0 || idx >= cache_list_num) {\nif (0) fprintf(stderr, \"free_rect: bad index: %d\\n\", idx);\n\t\tclean_up_exit(1);\n\t}\n\n\tx = cache_list[idx].bs_x;\n\ty = cache_list[idx].bs_y;\n\tw = cache_list[idx].bs_w;\n\th = cache_list[idx].bs_h;\n\n\tif (x < 0) {\n\t\tCLEAR(idx);\nif (dnow() > last_client + 5 && ncdb) fprintf(stderr, \"free_rect: already bs_x invalidated: %d bs_x: %d\\n\", idx, x);\n\t\treturn 1;\n\t}\n\n\tr2 = sraRgnCreateRect(x, y, x+w, y+h);\n\n\tn = get_bs_n(y);\n\tif (n >= 0) {\n\t\tr1 = rect_reg[n];\n\t\tsraRgnOr(r1, r2);\n\t\tok = 1;\n\t}\n\n\tif (zero_rects) {\n\t\tsraRgnOr(zero_rects, r2);\n\t\tx = cache_list[idx].su_x;\n\t\ty = cache_list[idx].su_y;\n\t\tw = cache_list[idx].su_w;\n\t\th = cache_list[idx].su_h;\n\t\tif (x >= 0) {\n\t\t\tsraRgnDestroy(r2);\n\t\t\tr2 = sraRgnCreateRect(x, y, x+w, y+h);\n\t\t\tsraRgnOr(zero_rects, r2);\n\t\t}\n\t}\n\tsraRgnDestroy(r2);\n\n\tCLEAR(idx);\nif (! ok && ncdb) fprintf(stderr, \"**** free_rect: not-found %d\\n\", idx);\n\treturn ok;\n}"
        }
      },
      {
        "call_info": {
          "callee": "find_client",
          "args": [
            "str"
          ],
          "line": 1237
        },
        "resolved": true,
        "details": {
          "function_name": "find_client",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/appshare.c",
          "lines": "318-335",
          "snippet": "static int find_client(char *cl) {\n\tint i;\n\tfor (i=0; i < CMAX; i++) {\n\t\tif (cl == NULL) {\n\t\t\tif (clients[i] == NULL) {\n\t\t\t\treturn i;\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\t\tif (clients[i] == NULL) {\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strcmp(clients[i], cl)) {\n\t\t\treturn i;\n\t\t}\n\t}\n\treturn -1;\n}",
          "includes": [
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [
            "#define CMAX 128"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"x11vnc.h\"\n\n#define CMAX 128\n\nstatic int find_client(char *cl) {\n\tint i;\n\tfor (i=0; i < CMAX; i++) {\n\t\tif (cl == NULL) {\n\t\t\tif (clients[i] == NULL) {\n\t\t\t\treturn i;\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\t\tif (clients[i] == NULL) {\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strcmp(clients[i], cl)) {\n\t\t\treturn i;\n\t\t}\n\t}\n\treturn -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "str",
            "\"all\""
          ],
          "line": 1225
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sscanf",
          "args": [
            "str+1",
            "\"%d\"",
            "&i"
          ],
          "line": 1214
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "str"
          ],
          "line": 1210
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ff",
          "args": [],
          "line": 1206
        },
        "resolved": true,
        "details": {
          "function_name": "ff",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/appshare.c",
          "lines": "293-296",
          "snippet": "static void ff(void) {\n\tfflush(stdout);\n\tfflush(stderr);\n}",
          "includes": [
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"x11vnc.h\"\n\nstatic void ff(void) {\n\tfflush(stdout);\n\tfflush(stderr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"ran out of client slots.\\n\""
          ],
          "line": 1205
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"already tracking client: %s in slot %d\\n\"",
            "str",
            "idx"
          ],
          "line": 1198
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "control",
            "\"internal\""
          ],
          "line": 1190
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"x11vnc.h\"\n\n#define CMAX 128\n\nstatic void add_or_del_client(char *str, int add) {\n\tint i;\n\n\tif (!str) {\n\t\treturn;\n\t}\n\tif (strcmp(control, \"internal\")) {\n\t\treturn;\n\t}\n\tif (add) {\n\t\tint idx  = find_client(str);\n\t\tint free = find_client(NULL);\n\n\t\tif (idx >=0) {\n\t\t\tfprintf(stderr, \"already tracking client: %s in slot %d\\n\", str, idx);\n\t\t\tff();\n\t\t\treturn;\n\t\t}\n\t\tif (free < 0) {\n\t\t\tstatic int cnt = 0;\n\t\t\tif (cnt++ < 10) {\n\t\t\t\tfprintf(stderr, \"ran out of client slots.\\n\");\n\t\t\t\tff();\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t\tclients[free] = strdup(str);\n\t\tclient(str, 1);\n\t} else {\n\t\tif (str[0] == '#' || str[0] == '%') {\n\t\t\tif (sscanf(str+1, \"%d\", &i) == 1) {\n\t\t\t\ti--;\n\t\t\t\tif (0 <= i && i < CMAX) {\n\t\t\t\t\tif (clients[i] != NULL) {\n\t\t\t\t\t\tclient(clients[i], 0);\n\t\t\t\t\t\tfree(clients[i]);\n\t\t\t\t\t\tclients[i] = NULL;\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (!strcmp(str, \"all\")) {\n\t\t\tfor (i=0; i < CMAX; i++) {\n\t\t\t\tif (clients[i] == NULL) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tclient(clients[i], 0);\n\t\t\t\tfree(clients[i]);\n\t\t\t\tclients[i] = NULL;\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\n\t\ti = find_client(str);\n\t\tif (i >= 0) {\n\t\t\tfree(clients[i]);\n\t\t\tclients[i] = NULL;\n\t\t\tclient(str, 0);\n\t\t}\n\t}\n}"
  },
  {
    "function_name": "add_or_del_win",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/appshare.c",
    "lines": "1158-1182",
    "snippet": "static void add_or_del_win(char *str, int add) {\n\tWindow win = parse_win(str);\n\n\tif (win != None) {\n\t\tint f = find_win(win);\n\t\tif (add) {\n\t\t\tif (f < 0 && win_attr(win)) {\n\t\t\t\tadd_win(win);\n\t\t\t}\n\t\t} else {\n\t\t\tif (f >= 0) {\n\t\t\t\tdestroy_win(win);\n\t\t\t}\n\t\t}\n\t} else if (!strcmp(str, \"all\")) {\n\t\tif (!add) {\n\t\t\tint i;\n\t\t\tfor (i=0; i < WMAX; i++) {\n\t\t\t\tif (watch[i] != None) {\n\t\t\t\t\tdestroy_win(watch[i]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t} \n}",
    "includes": [
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [
      "#define WMAX 192"
    ],
    "globals_used": [
      "extern char *get_xprop(char *prop, Window win);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "destroy_win",
          "args": [
            "watch[i]"
          ],
          "line": 1177
        },
        "resolved": true,
        "details": {
          "function_name": "destroy_win",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/appshare.c",
          "lines": "1103-1106",
          "snippet": "static void destroy_win(Window win) {\n\tstop(win);\n\tdelete_win(win);\n}",
          "includes": [
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "extern char *get_xprop(char *prop, Window win);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"x11vnc.h\"\n\nextern char *get_xprop(char *prop, Window win);\n\nstatic void destroy_win(Window win) {\n\tstop(win);\n\tdelete_win(win);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "str",
            "\"all\""
          ],
          "line": 1172
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "add_win",
          "args": [
            "win"
          ],
          "line": 1165
        },
        "resolved": true,
        "details": {
          "function_name": "add_win",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/appshare.c",
          "lines": "870-888",
          "snippet": "static void add_win(Window win) {\n\tint idx  = find_win(win);\n\tint free = find_win(None);\n\tif (idx >= 0) {\n\t\tif (appshare_debug) {fprintf(stderr, \"already watching window: 0x%lx\\n\", win); ff();}\n\t\treturn;\n\t}\n\tif (free < 0) {\n\t\tfprintf(stderr, \"ran out of slots for window: 0x%lx\\n\", win); ff();\n\t\treturn;\n\t}\n\n\tif (appshare_debug) {fprintf(stderr, \"watching: 0x%lx at %d\\n\", win, free); ff();}\n\n\twatch[free] = win;\n\tstate[free] = 0;\n\n\twin_select(win, 0);\n}",
          "includes": [
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "extern char *get_xprop(char *prop, Window win);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"x11vnc.h\"\n\nextern char *get_xprop(char *prop, Window win);\n\nstatic void add_win(Window win) {\n\tint idx  = find_win(win);\n\tint free = find_win(None);\n\tif (idx >= 0) {\n\t\tif (appshare_debug) {fprintf(stderr, \"already watching window: 0x%lx\\n\", win); ff();}\n\t\treturn;\n\t}\n\tif (free < 0) {\n\t\tfprintf(stderr, \"ran out of slots for window: 0x%lx\\n\", win); ff();\n\t\treturn;\n\t}\n\n\tif (appshare_debug) {fprintf(stderr, \"watching: 0x%lx at %d\\n\", win, free); ff();}\n\n\twatch[free] = win;\n\tstate[free] = 0;\n\n\twin_select(win, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "win_attr",
          "args": [
            "win"
          ],
          "line": 1164
        },
        "resolved": true,
        "details": {
          "function_name": "win_attr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/appshare.c",
          "lines": "735-748",
          "snippet": "static int win_attr(Window win) {\n\tint ok = 0;\n#if !NO_X11\n        XErrorHandler old_handler = XSetErrorHandler(trap_xerror);\n\tok = XGetWindowAttributes(dpy, win, &attr);\n       \tXSetErrorHandler(old_handler);\n#endif\n\n\tif (ok) {\n\t\treturn 1;\n\t} else {\n\t\treturn 0;\n\t}\n}",
          "includes": [
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "extern char *get_xprop(char *prop, Window win);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"x11vnc.h\"\n\nextern char *get_xprop(char *prop, Window win);\n\nstatic int win_attr(Window win) {\n\tint ok = 0;\n#if !NO_X11\n        XErrorHandler old_handler = XSetErrorHandler(trap_xerror);\n\tok = XGetWindowAttributes(dpy, win, &attr);\n       \tXSetErrorHandler(old_handler);\n#endif\n\n\tif (ok) {\n\t\treturn 1;\n\t} else {\n\t\treturn 0;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "find_win",
          "args": [
            "win"
          ],
          "line": 1162
        },
        "resolved": true,
        "details": {
          "function_name": "find_win",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/appshare.c",
          "lines": "298-306",
          "snippet": "static int find_win(Window win) {\n\tint i;\n\tfor (i=0; i < WMAX; i++) {\n\t\tif (watch[i] == win) {\n\t\t\treturn i;\n\t\t}\n\t}\n\treturn -1;\n}",
          "includes": [
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [
            "#define WMAX 192"
          ],
          "globals_used": [
            "extern char *get_xprop(char *prop, Window win);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"x11vnc.h\"\n\n#define WMAX 192\n\nextern char *get_xprop(char *prop, Window win);\n\nstatic int find_win(Window win) {\n\tint i;\n\tfor (i=0; i < WMAX; i++) {\n\t\tif (watch[i] == win) {\n\t\t\treturn i;\n\t\t}\n\t}\n\treturn -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "parse_win",
          "args": [
            "str"
          ],
          "line": 1159
        },
        "resolved": true,
        "details": {
          "function_name": "parse_win",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/appshare.c",
          "lines": "1108-1135",
          "snippet": "static Window parse_win(char *str) {\n\tWindow win = None;\n\tif (!str) {\n\t\treturn None;\n\t}\n\tif (!strcmp(str, \"pick\") || !strcmp(str, \"p\")) {\n\t\tstatic double last_pick = 0.0;\n\t\tif (dnow() < start_time + 15) {\n\t\t\t;\n\t\t} else if (dnow() < last_pick + 2) {\n\t\t\treturn None;\n\t\t} else {\n\t\t\tlast_pick = dnow();\n\t\t}\n\t\tif (!pick_windowid(&win)) {\n\t\t\tfprintf(stderr, \"parse_win: bad window pick.\\n\");\n\t\t\twin = None;\n\t\t}\n\t\tif (win == root) {\n\t\t\tfprintf(stderr, \"parse_win: ignoring pick of rootwin 0x%lx.\\n\", win);\n\t\t\twin = None;\n\t\t}\n\t\tff();\n\t} else if (!scan_hexdec(str, &win)) {\n\t\twin = None;\n\t}\n\treturn win;\n}",
          "includes": [
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "extern char *get_xprop(char *prop, Window win);",
            "extern double dnow(void);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"x11vnc.h\"\n\nextern char *get_xprop(char *prop, Window win);\nextern double dnow(void);\n\nstatic Window parse_win(char *str) {\n\tWindow win = None;\n\tif (!str) {\n\t\treturn None;\n\t}\n\tif (!strcmp(str, \"pick\") || !strcmp(str, \"p\")) {\n\t\tstatic double last_pick = 0.0;\n\t\tif (dnow() < start_time + 15) {\n\t\t\t;\n\t\t} else if (dnow() < last_pick + 2) {\n\t\t\treturn None;\n\t\t} else {\n\t\t\tlast_pick = dnow();\n\t\t}\n\t\tif (!pick_windowid(&win)) {\n\t\t\tfprintf(stderr, \"parse_win: bad window pick.\\n\");\n\t\t\twin = None;\n\t\t}\n\t\tif (win == root) {\n\t\t\tfprintf(stderr, \"parse_win: ignoring pick of rootwin 0x%lx.\\n\", win);\n\t\t\twin = None;\n\t\t}\n\t\tff();\n\t} else if (!scan_hexdec(str, &win)) {\n\t\twin = None;\n\t}\n\treturn win;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"x11vnc.h\"\n\n#define WMAX 192\n\nextern char *get_xprop(char *prop, Window win);\n\nstatic void add_or_del_win(char *str, int add) {\n\tWindow win = parse_win(str);\n\n\tif (win != None) {\n\t\tint f = find_win(win);\n\t\tif (add) {\n\t\t\tif (f < 0 && win_attr(win)) {\n\t\t\t\tadd_win(win);\n\t\t\t}\n\t\t} else {\n\t\t\tif (f >= 0) {\n\t\t\t\tdestroy_win(win);\n\t\t\t}\n\t\t}\n\t} else if (!strcmp(str, \"all\")) {\n\t\tif (!add) {\n\t\t\tint i;\n\t\t\tfor (i=0; i < WMAX; i++) {\n\t\t\t\tif (watch[i] != None) {\n\t\t\t\t\tdestroy_win(watch[i]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t} \n}"
  },
  {
    "function_name": "add_or_del_app",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/appshare.c",
    "lines": "1137-1156",
    "snippet": "static void add_or_del_app(char *str, int add) {\n\tWindow win = parse_win(str);\n\n\tif (win != None) {\n\t\tif (add) {\n\t\t\tadd_app(win);\n\t\t} else {\n\t\t\tdel_app(win);\n\t\t}\n\t} else if (!strcmp(str, \"all\")) {\n\t\tif (!add) {\n\t\t\tint i;\n\t\t\tfor (i=0; i < AMAX; i++) {\n\t\t\t\tif (apps[i] != None) {\n\t\t\t\t\tdel_app(apps[i]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}",
    "includes": [
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [
      "#define AMAX 32"
    ],
    "globals_used": [
      "extern char *get_xprop(char *prop, Window win);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "del_app",
          "args": [
            "apps[i]"
          ],
          "line": 1151
        },
        "resolved": true,
        "details": {
          "function_name": "del_app",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/appshare.c",
          "lines": "975-993",
          "snippet": "static void del_app(Window app) {\n\tint i;\n\tfor (i=0; i < WMAX; i++) {\n\t\tWindow win = watch[i];\n\t\tif (win != None) {\n\t\t\tif (same_app(app, win)) {\n\t\t\t\tdestroy_win(win);\n\t\t\t}\n\t\t}\n\t}\n\tfor (i=0; i < AMAX; i++) {\n\t\tWindow app2 = apps[i];\n\t\tif (app2 != None) {\n\t\t\tif (same_app(app, app2)) {\n\t\t\t\tapps[i] = None;\n\t\t\t}\n\t\t}\n\t}\n}",
          "includes": [
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [
            "#define AMAX 32",
            "#define WMAX 192"
          ],
          "globals_used": [
            "extern char *get_xprop(char *prop, Window win);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"x11vnc.h\"\n\n#define AMAX 32\n#define WMAX 192\n\nextern char *get_xprop(char *prop, Window win);\n\nstatic void del_app(Window app) {\n\tint i;\n\tfor (i=0; i < WMAX; i++) {\n\t\tWindow win = watch[i];\n\t\tif (win != None) {\n\t\t\tif (same_app(app, win)) {\n\t\t\t\tdestroy_win(win);\n\t\t\t}\n\t\t}\n\t}\n\tfor (i=0; i < AMAX; i++) {\n\t\tWindow app2 = apps[i];\n\t\tif (app2 != None) {\n\t\t\tif (same_app(app, app2)) {\n\t\t\t\tapps[i] = None;\n\t\t\t}\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "str",
            "\"all\""
          ],
          "line": 1146
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "add_app",
          "args": [
            "win"
          ],
          "line": 1142
        },
        "resolved": true,
        "details": {
          "function_name": "add_app",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/appshare.c",
          "lines": "943-973",
          "snippet": "static void add_app(Window app) {\n\tint i, nw = 0, free = -1;\n        XErrorHandler old_handler;\n\n#if !NO_X11\n\ti = find_app(app);\n\tif (i >= 0) {\n\t\tfprintf(stderr, \"already tracking app: 0x%lx\\n\", app);\n\t\treturn;\n\t}\n\tfor (i=0; i < AMAX; i++) {\n\t\tif (same_app(apps[i], app)) {\n\t\t\tfprintf(stderr, \"already tracking app: 0x%lx via 0x%lx\\n\", app, apps[i]);\n\t\t\treturn;\n\t\t}\n\t}\n\tfree = find_app(None);\n\tif (free < 0) {\n\t\tfprintf(stderr, \"ran out of app slots.\\n\");\n\t\treturn;\n\t}\n\tapps[free] = app;\n\n\tadd_win(app);\n\n        old_handler = XSetErrorHandler(trap_xerror);\n\trecurse_search(0, tree_depth, root, app, &nw);\n       \tXSetErrorHandler(old_handler);\n#endif\n\tfprintf(stderr, \"tracking %d windows related to app window 0x%lx\\n\", nw, app);\n}",
          "includes": [
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [
            "#define AMAX 32"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"x11vnc.h\"\n\n#define AMAX 32\n\nstatic void add_app(Window app) {\n\tint i, nw = 0, free = -1;\n        XErrorHandler old_handler;\n\n#if !NO_X11\n\ti = find_app(app);\n\tif (i >= 0) {\n\t\tfprintf(stderr, \"already tracking app: 0x%lx\\n\", app);\n\t\treturn;\n\t}\n\tfor (i=0; i < AMAX; i++) {\n\t\tif (same_app(apps[i], app)) {\n\t\t\tfprintf(stderr, \"already tracking app: 0x%lx via 0x%lx\\n\", app, apps[i]);\n\t\t\treturn;\n\t\t}\n\t}\n\tfree = find_app(None);\n\tif (free < 0) {\n\t\tfprintf(stderr, \"ran out of app slots.\\n\");\n\t\treturn;\n\t}\n\tapps[free] = app;\n\n\tadd_win(app);\n\n        old_handler = XSetErrorHandler(trap_xerror);\n\trecurse_search(0, tree_depth, root, app, &nw);\n       \tXSetErrorHandler(old_handler);\n#endif\n\tfprintf(stderr, \"tracking %d windows related to app window 0x%lx\\n\", nw, app);\n}"
        }
      },
      {
        "call_info": {
          "callee": "parse_win",
          "args": [
            "str"
          ],
          "line": 1138
        },
        "resolved": true,
        "details": {
          "function_name": "parse_win",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/appshare.c",
          "lines": "1108-1135",
          "snippet": "static Window parse_win(char *str) {\n\tWindow win = None;\n\tif (!str) {\n\t\treturn None;\n\t}\n\tif (!strcmp(str, \"pick\") || !strcmp(str, \"p\")) {\n\t\tstatic double last_pick = 0.0;\n\t\tif (dnow() < start_time + 15) {\n\t\t\t;\n\t\t} else if (dnow() < last_pick + 2) {\n\t\t\treturn None;\n\t\t} else {\n\t\t\tlast_pick = dnow();\n\t\t}\n\t\tif (!pick_windowid(&win)) {\n\t\t\tfprintf(stderr, \"parse_win: bad window pick.\\n\");\n\t\t\twin = None;\n\t\t}\n\t\tif (win == root) {\n\t\t\tfprintf(stderr, \"parse_win: ignoring pick of rootwin 0x%lx.\\n\", win);\n\t\t\twin = None;\n\t\t}\n\t\tff();\n\t} else if (!scan_hexdec(str, &win)) {\n\t\twin = None;\n\t}\n\treturn win;\n}",
          "includes": [
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "extern char *get_xprop(char *prop, Window win);",
            "extern double dnow(void);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"x11vnc.h\"\n\nextern char *get_xprop(char *prop, Window win);\nextern double dnow(void);\n\nstatic Window parse_win(char *str) {\n\tWindow win = None;\n\tif (!str) {\n\t\treturn None;\n\t}\n\tif (!strcmp(str, \"pick\") || !strcmp(str, \"p\")) {\n\t\tstatic double last_pick = 0.0;\n\t\tif (dnow() < start_time + 15) {\n\t\t\t;\n\t\t} else if (dnow() < last_pick + 2) {\n\t\t\treturn None;\n\t\t} else {\n\t\t\tlast_pick = dnow();\n\t\t}\n\t\tif (!pick_windowid(&win)) {\n\t\t\tfprintf(stderr, \"parse_win: bad window pick.\\n\");\n\t\t\twin = None;\n\t\t}\n\t\tif (win == root) {\n\t\t\tfprintf(stderr, \"parse_win: ignoring pick of rootwin 0x%lx.\\n\", win);\n\t\t\twin = None;\n\t\t}\n\t\tff();\n\t} else if (!scan_hexdec(str, &win)) {\n\t\twin = None;\n\t}\n\treturn win;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"x11vnc.h\"\n\n#define AMAX 32\n\nextern char *get_xprop(char *prop, Window win);\n\nstatic void add_or_del_app(char *str, int add) {\n\tWindow win = parse_win(str);\n\n\tif (win != None) {\n\t\tif (add) {\n\t\t\tadd_app(win);\n\t\t} else {\n\t\t\tdel_app(win);\n\t\t}\n\t} else if (!strcmp(str, \"all\")) {\n\t\tif (!add) {\n\t\t\tint i;\n\t\t\tfor (i=0; i < AMAX; i++) {\n\t\t\t\tif (apps[i] != None) {\n\t\t\t\t\tdel_app(apps[i]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "function_name": "parse_win",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/appshare.c",
    "lines": "1108-1135",
    "snippet": "static Window parse_win(char *str) {\n\tWindow win = None;\n\tif (!str) {\n\t\treturn None;\n\t}\n\tif (!strcmp(str, \"pick\") || !strcmp(str, \"p\")) {\n\t\tstatic double last_pick = 0.0;\n\t\tif (dnow() < start_time + 15) {\n\t\t\t;\n\t\t} else if (dnow() < last_pick + 2) {\n\t\t\treturn None;\n\t\t} else {\n\t\t\tlast_pick = dnow();\n\t\t}\n\t\tif (!pick_windowid(&win)) {\n\t\t\tfprintf(stderr, \"parse_win: bad window pick.\\n\");\n\t\t\twin = None;\n\t\t}\n\t\tif (win == root) {\n\t\t\tfprintf(stderr, \"parse_win: ignoring pick of rootwin 0x%lx.\\n\", win);\n\t\t\twin = None;\n\t\t}\n\t\tff();\n\t} else if (!scan_hexdec(str, &win)) {\n\t\twin = None;\n\t}\n\treturn win;\n}",
    "includes": [
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "extern char *get_xprop(char *prop, Window win);",
      "extern double dnow(void);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "scan_hexdec",
          "args": [
            "str",
            "&win"
          ],
          "line": 1131
        },
        "resolved": true,
        "details": {
          "function_name": "scan_hexdec",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/util.c",
          "lines": "201-208",
          "snippet": "int scan_hexdec(char *str, unsigned long *num) {\n\tif (sscanf(str, \"0x%lx\", num) != 1) {\n\t\tif (sscanf(str, \"%lu\", num) != 1) {\n\t\t\treturn 0;\n\t\t}\n\t}\n\treturn 1;\n}",
          "includes": [
            "#include \"connections.h\"",
            "#include \"unixpw.h\"",
            "#include \"win_utils.h\"",
            "#include \"cleanup.h\"",
            "#include \"x11vnc.h\"",
            "#include <stdlib.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void lowercase(char *str);",
            "void uppercase(char *str);",
            "char *lblanks(char *str);",
            "void strzero(char *str);",
            "int scan_hexdec(char *str, unsigned long *num);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"connections.h\"\n#include \"unixpw.h\"\n#include \"win_utils.h\"\n#include \"cleanup.h\"\n#include \"x11vnc.h\"\n#include <stdlib.h>\n\nvoid lowercase(char *str);\nvoid uppercase(char *str);\nchar *lblanks(char *str);\nvoid strzero(char *str);\nint scan_hexdec(char *str, unsigned long *num);\n\nint scan_hexdec(char *str, unsigned long *num) {\n\tif (sscanf(str, \"0x%lx\", num) != 1) {\n\t\tif (sscanf(str, \"%lu\", num) != 1) {\n\t\t\treturn 0;\n\t\t}\n\t}\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ff",
          "args": [],
          "line": 1130
        },
        "resolved": true,
        "details": {
          "function_name": "ff",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/appshare.c",
          "lines": "293-296",
          "snippet": "static void ff(void) {\n\tfflush(stdout);\n\tfflush(stderr);\n}",
          "includes": [
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"x11vnc.h\"\n\nstatic void ff(void) {\n\tfflush(stdout);\n\tfflush(stderr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"parse_win: ignoring pick of rootwin 0x%lx.\\n\"",
            "win"
          ],
          "line": 1127
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"parse_win: bad window pick.\\n\""
          ],
          "line": 1123
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pick_windowid",
          "args": [
            "&win"
          ],
          "line": 1122
        },
        "resolved": true,
        "details": {
          "function_name": "pick_windowid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/win_utils.c",
          "lines": "405-478",
          "snippet": "int pick_windowid(unsigned long *num) {\n\tchar line[512];\n\tint ok = 0, n = 0, msec = 10, secmax = 15;\n\tFILE *p;\n\n\tRAWFB_RET(0)\n\n\tif (use_dpy) {\n\t\tset_env(\"DISPLAY\", use_dpy);\n\t}\n\t/* id */\n\tif (no_external_cmds || !cmd_ok(\"id\")) {\n\t\trfbLogEnable(1);\n\t\trfbLog(\"cannot run external commands in -nocmds mode:\\n\");\n\t\trfbLog(\"   \\\"%s\\\"\\n\", \"xwininfo\");\n\t\trfbLog(\"   exiting.\\n\");\n\t\tclean_up_exit(1);\n\t}\n\tclose_exec_fds();\n\tp = popen(\"xwininfo\", \"r\");\n\n\tif (! p) {\n\t\treturn 0;\n\t}\n\n\tfprintf(stderr, \"\\n\");\n\tfprintf(stderr, \"  Please select the window for x11vnc to poll\\n\");\n\tfprintf(stderr, \"  by clicking the mouse in that window.\\n\");\n\tfprintf(stderr, \"\\n\");\n\n\twhile (msec * n++ < 1000 * secmax) {\n\t\tunsigned long tmp;\n\t\tchar *q;\n\t\tfd_set set;\n\t\tstruct timeval tv;\n\n\t\tif (screen && screen->clientHead) {\n\t\t\t/* they may be doing the pointer-pick thru vnc: */\n\t\t\tint nfds;\n\t\t\ttv.tv_sec = 0;\n\t\t\ttv.tv_usec = msec * 1000;\n\t\t\tFD_ZERO(&set);\n\t\t\tFD_SET(fileno(p), &set);\n\n\t\t\tnfds = select(fileno(p)+1, &set, NULL, NULL, &tv);\n\t\t\t\n\t\t\tif (nfds == 0 || nfds < 0) {\n\t\t\t\t/* \n\t\t\t\t * select timedout or error.\n\t\t\t\t * note this rfbPE takes about 30ms too:\n\t\t\t\t */\n\t\t\t\trfbPE(-1);\n\t\t\t\tXFlush_wr(dpy);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\t\n\t\tif (fgets(line, 512, p) == NULL) {\n\t\t\tbreak;\n\t\t}\n\t\tq = strstr(line, \" id: 0x\"); \n\t\tif (q) {\n\t\t\tq += 5;\n\t\t\tif (sscanf(q, \"0x%lx \", &tmp) == 1) {\n\t\t\t\tok = 1;\n\t\t\t\t*num = tmp;\n\t\t\t\tfprintf(stderr, \"  Picked: 0x%lx\\n\\n\", tmp);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tpclose(p);\n\treturn ok;\n}",
          "includes": [
            "#include \"win_utils.h\"",
            "#include \"macosx.h\"",
            "#include \"xrandr.h\"",
            "#include \"connections.h\"",
            "#include \"xwrappers.h\"",
            "#include \"cleanup.h\"",
            "#include \"winattr_t.h\"",
            "#include \"xinerama.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"win_utils.h\"\n#include \"macosx.h\"\n#include \"xrandr.h\"\n#include \"connections.h\"\n#include \"xwrappers.h\"\n#include \"cleanup.h\"\n#include \"winattr_t.h\"\n#include \"xinerama.h\"\n#include \"x11vnc.h\"\n\nint pick_windowid(unsigned long *num) {\n\tchar line[512];\n\tint ok = 0, n = 0, msec = 10, secmax = 15;\n\tFILE *p;\n\n\tRAWFB_RET(0)\n\n\tif (use_dpy) {\n\t\tset_env(\"DISPLAY\", use_dpy);\n\t}\n\t/* id */\n\tif (no_external_cmds || !cmd_ok(\"id\")) {\n\t\trfbLogEnable(1);\n\t\trfbLog(\"cannot run external commands in -nocmds mode:\\n\");\n\t\trfbLog(\"   \\\"%s\\\"\\n\", \"xwininfo\");\n\t\trfbLog(\"   exiting.\\n\");\n\t\tclean_up_exit(1);\n\t}\n\tclose_exec_fds();\n\tp = popen(\"xwininfo\", \"r\");\n\n\tif (! p) {\n\t\treturn 0;\n\t}\n\n\tfprintf(stderr, \"\\n\");\n\tfprintf(stderr, \"  Please select the window for x11vnc to poll\\n\");\n\tfprintf(stderr, \"  by clicking the mouse in that window.\\n\");\n\tfprintf(stderr, \"\\n\");\n\n\twhile (msec * n++ < 1000 * secmax) {\n\t\tunsigned long tmp;\n\t\tchar *q;\n\t\tfd_set set;\n\t\tstruct timeval tv;\n\n\t\tif (screen && screen->clientHead) {\n\t\t\t/* they may be doing the pointer-pick thru vnc: */\n\t\t\tint nfds;\n\t\t\ttv.tv_sec = 0;\n\t\t\ttv.tv_usec = msec * 1000;\n\t\t\tFD_ZERO(&set);\n\t\t\tFD_SET(fileno(p), &set);\n\n\t\t\tnfds = select(fileno(p)+1, &set, NULL, NULL, &tv);\n\t\t\t\n\t\t\tif (nfds == 0 || nfds < 0) {\n\t\t\t\t/* \n\t\t\t\t * select timedout or error.\n\t\t\t\t * note this rfbPE takes about 30ms too:\n\t\t\t\t */\n\t\t\t\trfbPE(-1);\n\t\t\t\tXFlush_wr(dpy);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\t\n\t\tif (fgets(line, 512, p) == NULL) {\n\t\t\tbreak;\n\t\t}\n\t\tq = strstr(line, \" id: 0x\"); \n\t\tif (q) {\n\t\t\tq += 5;\n\t\t\tif (sscanf(q, \"0x%lx \", &tmp) == 1) {\n\t\t\t\tok = 1;\n\t\t\t\t*num = tmp;\n\t\t\t\tfprintf(stderr, \"  Picked: 0x%lx\\n\\n\", tmp);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tpclose(p);\n\treturn ok;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dnow",
          "args": [],
          "line": 1120
        },
        "resolved": true,
        "details": {
          "function_name": "dnowx",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/util.c",
          "lines": "439-441",
          "snippet": "double dnowx(void) {\n\treturn dnow() - x11vnc_start;\n}",
          "includes": [
            "#include \"connections.h\"",
            "#include \"unixpw.h\"",
            "#include \"win_utils.h\"",
            "#include \"cleanup.h\"",
            "#include \"x11vnc.h\"",
            "#include <stdlib.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "double dnow(void);",
            "double dnowx(void);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"connections.h\"\n#include \"unixpw.h\"\n#include \"win_utils.h\"\n#include \"cleanup.h\"\n#include \"x11vnc.h\"\n#include <stdlib.h>\n\ndouble dnow(void);\ndouble dnowx(void);\n\ndouble dnowx(void) {\n\treturn dnow() - x11vnc_start;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "str",
            "\"p\""
          ],
          "line": 1113
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "str",
            "\"pick\""
          ],
          "line": 1113
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"x11vnc.h\"\n\nextern char *get_xprop(char *prop, Window win);\nextern double dnow(void);\n\nstatic Window parse_win(char *str) {\n\tWindow win = None;\n\tif (!str) {\n\t\treturn None;\n\t}\n\tif (!strcmp(str, \"pick\") || !strcmp(str, \"p\")) {\n\t\tstatic double last_pick = 0.0;\n\t\tif (dnow() < start_time + 15) {\n\t\t\t;\n\t\t} else if (dnow() < last_pick + 2) {\n\t\t\treturn None;\n\t\t} else {\n\t\t\tlast_pick = dnow();\n\t\t}\n\t\tif (!pick_windowid(&win)) {\n\t\t\tfprintf(stderr, \"parse_win: bad window pick.\\n\");\n\t\t\twin = None;\n\t\t}\n\t\tif (win == root) {\n\t\t\tfprintf(stderr, \"parse_win: ignoring pick of rootwin 0x%lx.\\n\", win);\n\t\t\twin = None;\n\t\t}\n\t\tff();\n\t} else if (!scan_hexdec(str, &win)) {\n\t\twin = None;\n\t}\n\treturn win;\n}"
  },
  {
    "function_name": "destroy_win",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/appshare.c",
    "lines": "1103-1106",
    "snippet": "static void destroy_win(Window win) {\n\tstop(win);\n\tdelete_win(win);\n}",
    "includes": [
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "extern char *get_xprop(char *prop, Window win);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "delete_win",
          "args": [
            "win"
          ],
          "line": 1105
        },
        "resolved": true,
        "details": {
          "function_name": "delete_win",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/appshare.c",
          "lines": "890-899",
          "snippet": "static void delete_win(Window win) {\n\tint i;\n\tfor (i=0; i < WMAX; i++) {\n\t\tif (watch[i] == win) {\n\t\t\twatch[i] = None;\n\t\t\tstate[i] = 0;\n\t\t\tif (appshare_debug) {fprintf(stderr, \"deleting: 0x%lx at %d\\n\", win, i); ff();}\n\t\t}\n\t}\n}",
          "includes": [
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [
            "#define WMAX 192"
          ],
          "globals_used": [
            "extern char *get_xprop(char *prop, Window win);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"x11vnc.h\"\n\n#define WMAX 192\n\nextern char *get_xprop(char *prop, Window win);\n\nstatic void delete_win(Window win) {\n\tint i;\n\tfor (i=0; i < WMAX; i++) {\n\t\tif (watch[i] == win) {\n\t\t\twatch[i] = None;\n\t\t\tstate[i] = 0;\n\t\t\tif (appshare_debug) {fprintf(stderr, \"deleting: 0x%lx at %d\\n\", win, i); ff();}\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "stop",
          "args": [
            "win"
          ],
          "line": 1104
        },
        "resolved": true,
        "details": {
          "function_name": "stop",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/appshare.c",
          "lines": "505-544",
          "snippet": "static void stop(Window win) {\n\tchar *cmd;\n\tint pid = -1;\n\tint f = find_win(win);\n\tif (f < 0 || win == None) {\n\t\treturn;\n\t}\n\tif (state[f] == 0) {\n\t\treturn;\n\t}\n\tif (trackdir) {\n\t\tpid = trackdir_pid(win);\n\t\tif (pid > 0) {\n\t\t\tif (appshare_debug) {fprintf(stderr,\n\t\t\t    \"sending SIGTERM to: %d\\n\", pid); ff();}\n\t\t\tkill((pid_t) pid, SIGTERM);\n\t\t}\n\t}\n\n\tcmd = (char *) malloc(1000 + strlen(x11vnc));\n\tsprintf(cmd, \"pkill -TERM -f '%s %s 0x%lx -bg'\", x11vnc, id_opt, win);\n\tif (appshare_debug) {\n\t\tfprintf(stdout, \"stopping:  0x%08lx - %s\\n\", win, cmd);\n\t} else {\n\t\tfprintf(stdout, \"stopping:  x11vnc for window 0x%08lx  \"\n\t\t    \"(pid: %d)\\n\", win, pid);\n\t}\n\tff();\n\tsystem(cmd);\n\n\tsprintf(cmd, \"(sleep 0.25 2>/dev/null || sleep 1; pkill -KILL -f '%s \"\n\t    \"%s 0x%lx -bg') &\", x11vnc, id_opt, win);\n\tsystem(cmd);\n\n\tif (trackdir) {\n\t\ttrackdir_cleanup(win);\n\t}\n\n\tfree(cmd);\n}",
          "includes": [
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "extern char *get_xprop(char *prop, Window win);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"x11vnc.h\"\n\nextern char *get_xprop(char *prop, Window win);\n\nstatic void stop(Window win) {\n\tchar *cmd;\n\tint pid = -1;\n\tint f = find_win(win);\n\tif (f < 0 || win == None) {\n\t\treturn;\n\t}\n\tif (state[f] == 0) {\n\t\treturn;\n\t}\n\tif (trackdir) {\n\t\tpid = trackdir_pid(win);\n\t\tif (pid > 0) {\n\t\t\tif (appshare_debug) {fprintf(stderr,\n\t\t\t    \"sending SIGTERM to: %d\\n\", pid); ff();}\n\t\t\tkill((pid_t) pid, SIGTERM);\n\t\t}\n\t}\n\n\tcmd = (char *) malloc(1000 + strlen(x11vnc));\n\tsprintf(cmd, \"pkill -TERM -f '%s %s 0x%lx -bg'\", x11vnc, id_opt, win);\n\tif (appshare_debug) {\n\t\tfprintf(stdout, \"stopping:  0x%08lx - %s\\n\", win, cmd);\n\t} else {\n\t\tfprintf(stdout, \"stopping:  x11vnc for window 0x%08lx  \"\n\t\t    \"(pid: %d)\\n\", win, pid);\n\t}\n\tff();\n\tsystem(cmd);\n\n\tsprintf(cmd, \"(sleep 0.25 2>/dev/null || sleep 1; pkill -KILL -f '%s \"\n\t    \"%s 0x%lx -bg') &\", x11vnc, id_opt, win);\n\tsystem(cmd);\n\n\tif (trackdir) {\n\t\ttrackdir_cleanup(win);\n\t}\n\n\tfree(cmd);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"x11vnc.h\"\n\nextern char *get_xprop(char *prop, Window win);\n\nstatic void destroy_win(Window win) {\n\tstop(win);\n\tdelete_win(win);\n}"
  },
  {
    "function_name": "unmapped",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/appshare.c",
    "lines": "1094-1101",
    "snippet": "static void unmapped(Window win) {\n\tint f = find_win(win);\n\tif (f < 0 || win == None) {\n\t\treturn;\n\t}\n\tstop(win);\t\n\tstate[f] = 0;\n}",
    "includes": [
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "extern char *get_xprop(char *prop, Window win);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "stop",
          "args": [
            "win"
          ],
          "line": 1099
        },
        "resolved": true,
        "details": {
          "function_name": "stop",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/appshare.c",
          "lines": "505-544",
          "snippet": "static void stop(Window win) {\n\tchar *cmd;\n\tint pid = -1;\n\tint f = find_win(win);\n\tif (f < 0 || win == None) {\n\t\treturn;\n\t}\n\tif (state[f] == 0) {\n\t\treturn;\n\t}\n\tif (trackdir) {\n\t\tpid = trackdir_pid(win);\n\t\tif (pid > 0) {\n\t\t\tif (appshare_debug) {fprintf(stderr,\n\t\t\t    \"sending SIGTERM to: %d\\n\", pid); ff();}\n\t\t\tkill((pid_t) pid, SIGTERM);\n\t\t}\n\t}\n\n\tcmd = (char *) malloc(1000 + strlen(x11vnc));\n\tsprintf(cmd, \"pkill -TERM -f '%s %s 0x%lx -bg'\", x11vnc, id_opt, win);\n\tif (appshare_debug) {\n\t\tfprintf(stdout, \"stopping:  0x%08lx - %s\\n\", win, cmd);\n\t} else {\n\t\tfprintf(stdout, \"stopping:  x11vnc for window 0x%08lx  \"\n\t\t    \"(pid: %d)\\n\", win, pid);\n\t}\n\tff();\n\tsystem(cmd);\n\n\tsprintf(cmd, \"(sleep 0.25 2>/dev/null || sleep 1; pkill -KILL -f '%s \"\n\t    \"%s 0x%lx -bg') &\", x11vnc, id_opt, win);\n\tsystem(cmd);\n\n\tif (trackdir) {\n\t\ttrackdir_cleanup(win);\n\t}\n\n\tfree(cmd);\n}",
          "includes": [
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "extern char *get_xprop(char *prop, Window win);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"x11vnc.h\"\n\nextern char *get_xprop(char *prop, Window win);\n\nstatic void stop(Window win) {\n\tchar *cmd;\n\tint pid = -1;\n\tint f = find_win(win);\n\tif (f < 0 || win == None) {\n\t\treturn;\n\t}\n\tif (state[f] == 0) {\n\t\treturn;\n\t}\n\tif (trackdir) {\n\t\tpid = trackdir_pid(win);\n\t\tif (pid > 0) {\n\t\t\tif (appshare_debug) {fprintf(stderr,\n\t\t\t    \"sending SIGTERM to: %d\\n\", pid); ff();}\n\t\t\tkill((pid_t) pid, SIGTERM);\n\t\t}\n\t}\n\n\tcmd = (char *) malloc(1000 + strlen(x11vnc));\n\tsprintf(cmd, \"pkill -TERM -f '%s %s 0x%lx -bg'\", x11vnc, id_opt, win);\n\tif (appshare_debug) {\n\t\tfprintf(stdout, \"stopping:  0x%08lx - %s\\n\", win, cmd);\n\t} else {\n\t\tfprintf(stdout, \"stopping:  x11vnc for window 0x%08lx  \"\n\t\t    \"(pid: %d)\\n\", win, pid);\n\t}\n\tff();\n\tsystem(cmd);\n\n\tsprintf(cmd, \"(sleep 0.25 2>/dev/null || sleep 1; pkill -KILL -f '%s \"\n\t    \"%s 0x%lx -bg') &\", x11vnc, id_opt, win);\n\tsystem(cmd);\n\n\tif (trackdir) {\n\t\ttrackdir_cleanup(win);\n\t}\n\n\tfree(cmd);\n}"
        }
      },
      {
        "call_info": {
          "callee": "find_win",
          "args": [
            "win"
          ],
          "line": 1095
        },
        "resolved": true,
        "details": {
          "function_name": "find_win",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/appshare.c",
          "lines": "298-306",
          "snippet": "static int find_win(Window win) {\n\tint i;\n\tfor (i=0; i < WMAX; i++) {\n\t\tif (watch[i] == win) {\n\t\t\treturn i;\n\t\t}\n\t}\n\treturn -1;\n}",
          "includes": [
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [
            "#define WMAX 192"
          ],
          "globals_used": [
            "extern char *get_xprop(char *prop, Window win);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"x11vnc.h\"\n\n#define WMAX 192\n\nextern char *get_xprop(char *prop, Window win);\n\nstatic int find_win(Window win) {\n\tint i;\n\tfor (i=0; i < WMAX; i++) {\n\t\tif (watch[i] == win) {\n\t\t\treturn i;\n\t\t}\n\t}\n\treturn -1;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"x11vnc.h\"\n\nextern char *get_xprop(char *prop, Window win);\n\nstatic void unmapped(Window win) {\n\tint f = find_win(win);\n\tif (f < 0 || win == None) {\n\t\treturn;\n\t}\n\tstop(win);\t\n\tstate[f] = 0;\n}"
  },
  {
    "function_name": "mapped",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/appshare.c",
    "lines": "1078-1092",
    "snippet": "static void mapped(Window win) {\n\tint f;\n\tif (win == None) {\n\t\treturn;\n\t}\n\tf = find_win(win);\n\tif (f < 0) {\n\t\tif (win_attr(win)) {\n\t\t\tif (get_parent(win) == root) {\n\t\t\t\t/* XXX more cases? */\n\t\t\t\tadd_win(win);\n\t\t\t}\n\t\t}\n\t}\n}",
    "includes": [
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "extern char *get_xprop(char *prop, Window win);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "add_win",
          "args": [
            "win"
          ],
          "line": 1088
        },
        "resolved": true,
        "details": {
          "function_name": "add_win",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/appshare.c",
          "lines": "870-888",
          "snippet": "static void add_win(Window win) {\n\tint idx  = find_win(win);\n\tint free = find_win(None);\n\tif (idx >= 0) {\n\t\tif (appshare_debug) {fprintf(stderr, \"already watching window: 0x%lx\\n\", win); ff();}\n\t\treturn;\n\t}\n\tif (free < 0) {\n\t\tfprintf(stderr, \"ran out of slots for window: 0x%lx\\n\", win); ff();\n\t\treturn;\n\t}\n\n\tif (appshare_debug) {fprintf(stderr, \"watching: 0x%lx at %d\\n\", win, free); ff();}\n\n\twatch[free] = win;\n\tstate[free] = 0;\n\n\twin_select(win, 0);\n}",
          "includes": [
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "extern char *get_xprop(char *prop, Window win);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"x11vnc.h\"\n\nextern char *get_xprop(char *prop, Window win);\n\nstatic void add_win(Window win) {\n\tint idx  = find_win(win);\n\tint free = find_win(None);\n\tif (idx >= 0) {\n\t\tif (appshare_debug) {fprintf(stderr, \"already watching window: 0x%lx\\n\", win); ff();}\n\t\treturn;\n\t}\n\tif (free < 0) {\n\t\tfprintf(stderr, \"ran out of slots for window: 0x%lx\\n\", win); ff();\n\t\treturn;\n\t}\n\n\tif (appshare_debug) {fprintf(stderr, \"watching: 0x%lx at %d\\n\", win, free); ff();}\n\n\twatch[free] = win;\n\tstate[free] = 0;\n\n\twin_select(win, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_parent",
          "args": [
            "win"
          ],
          "line": 1086
        },
        "resolved": true,
        "details": {
          "function_name": "get_parent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/appshare.c",
          "lines": "763-781",
          "snippet": "static Window get_parent(Window win) {\n\tint ok;\n\tWindow r, parent = None, *list = NULL;\n\tunsigned int nchild;\n\n#if !NO_X11\n        XErrorHandler old_handler = XSetErrorHandler(trap_xerror);\n\tok = XQueryTree(dpy, win, &r, &parent, &list, &nchild);\n       \tXSetErrorHandler(old_handler);\n\n\tif (!ok) {\n\t\treturn None;\n\t}\n\tif (list) {\n\t\tXFree(list);\n\t}\n#endif\n\treturn parent;\n}",
          "includes": [
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "extern char *get_xprop(char *prop, Window win);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"x11vnc.h\"\n\nextern char *get_xprop(char *prop, Window win);\n\nstatic Window get_parent(Window win) {\n\tint ok;\n\tWindow r, parent = None, *list = NULL;\n\tunsigned int nchild;\n\n#if !NO_X11\n        XErrorHandler old_handler = XSetErrorHandler(trap_xerror);\n\tok = XQueryTree(dpy, win, &r, &parent, &list, &nchild);\n       \tXSetErrorHandler(old_handler);\n\n\tif (!ok) {\n\t\treturn None;\n\t}\n\tif (list) {\n\t\tXFree(list);\n\t}\n#endif\n\treturn parent;\n}"
        }
      },
      {
        "call_info": {
          "callee": "win_attr",
          "args": [
            "win"
          ],
          "line": 1085
        },
        "resolved": true,
        "details": {
          "function_name": "win_attr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/appshare.c",
          "lines": "735-748",
          "snippet": "static int win_attr(Window win) {\n\tint ok = 0;\n#if !NO_X11\n        XErrorHandler old_handler = XSetErrorHandler(trap_xerror);\n\tok = XGetWindowAttributes(dpy, win, &attr);\n       \tXSetErrorHandler(old_handler);\n#endif\n\n\tif (ok) {\n\t\treturn 1;\n\t} else {\n\t\treturn 0;\n\t}\n}",
          "includes": [
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "extern char *get_xprop(char *prop, Window win);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"x11vnc.h\"\n\nextern char *get_xprop(char *prop, Window win);\n\nstatic int win_attr(Window win) {\n\tint ok = 0;\n#if !NO_X11\n        XErrorHandler old_handler = XSetErrorHandler(trap_xerror);\n\tok = XGetWindowAttributes(dpy, win, &attr);\n       \tXSetErrorHandler(old_handler);\n#endif\n\n\tif (ok) {\n\t\treturn 1;\n\t} else {\n\t\treturn 0;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "find_win",
          "args": [
            "win"
          ],
          "line": 1083
        },
        "resolved": true,
        "details": {
          "function_name": "find_win",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/appshare.c",
          "lines": "298-306",
          "snippet": "static int find_win(Window win) {\n\tint i;\n\tfor (i=0; i < WMAX; i++) {\n\t\tif (watch[i] == win) {\n\t\t\treturn i;\n\t\t}\n\t}\n\treturn -1;\n}",
          "includes": [
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [
            "#define WMAX 192"
          ],
          "globals_used": [
            "extern char *get_xprop(char *prop, Window win);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"x11vnc.h\"\n\n#define WMAX 192\n\nextern char *get_xprop(char *prop, Window win);\n\nstatic int find_win(Window win) {\n\tint i;\n\tfor (i=0; i < WMAX; i++) {\n\t\tif (watch[i] == win) {\n\t\t\treturn i;\n\t\t}\n\t}\n\treturn -1;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"x11vnc.h\"\n\nextern char *get_xprop(char *prop, Window win);\n\nstatic void mapped(Window win) {\n\tint f;\n\tif (win == None) {\n\t\treturn;\n\t}\n\tf = find_win(win);\n\tif (f < 0) {\n\t\tif (win_attr(win)) {\n\t\t\tif (get_parent(win) == root) {\n\t\t\t\t/* XXX more cases? */\n\t\t\t\tadd_win(win);\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "function_name": "client",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/appshare.c",
    "lines": "1010-1076",
    "snippet": "static void client(char *client, int add) {\n\tDIR *dir;\n\tstruct dirent *dp;\n\n\tif (!client) {\n\t\treturn;\n\t}\n\tif (!trackdir) {\n\t\tfprintf(stderr, \"no trackdir, cannot %s client: %s\\n\",\n\t\t    add ? \"add\" : \"disconnect\", client);\n\t\tff();\n\t\treturn;\n\t}\n\tfprintf(stdout, \"%s client: %s\\n\", add ? \"adding  \" : \"deleting\", client);\n\n\tdir = opendir(trackdir);\n\tif (!dir) {\n\t\tfprintf(stderr, \"could not opendir trackdir: %s\\n\", trackdir);\n\t\treturn;\n\t}\n\twhile ( (dp = readdir(dir)) != NULL) {\n\t\tchar *name = dp->d_name;\n\t\tif (!strcmp(name, \".\") || !strcmp(name, \"..\")) {\n\t\t\tcontinue;\n\t\t}\n\t\tif (strstr(name, \"0x\") != name) {\n\t\t\tcontinue;\n\t\t}\n\t\tif (strstr(name, \".connect\")) {\n\t\t\tFILE *f;\n\t\t\tchar *tmp;\n\t\t\tWindow twin;\n\n\t\t\tif (scan_hexdec(name, &twin)) {\n\t\t\t\tint f = find_win(twin);\n\t\t\t\tif (appshare_debug) {\n\t\t\t\t\tfprintf(stderr, \"twin: 0x%lx name=%s f=%d\\n\", twin, name, f);\n\t\t\t\t\tff();\n\t\t\t\t}\n\t\t\t\tif (f < 0) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\ttmp = (char *) calloc(100 + strlen(client), 1);\n\t\t\tsprintf(tracktmp, \"%s/%s\", trackdir, name);\n\t\t\tif (add) {\n\t\t\t\tsprintf(tmp, \"%s\\n\", client);\n\t\t\t} else {\n\t\t\t\tsprintf(tmp, \"cmd=close:%s\\n\", client);\n\t\t\t}\n\t\t\twait_until_empty(tracktmp);\n\t\t\tf = fopen(tracktmp, \"w\");\n\t\t\tif (f) {\n\t\t\t\tif (appshare_debug) {\n\t\t\t\t\tfprintf(stderr, \"%s client: %s + %s\",\n\t\t\t\t\tadd ? \"add\" : \"disconnect\", tracktmp, tmp);\n\t\t\t\t\tff();\n\t\t\t\t}\n\t\t\t\tfprintf(f, \"%s\", tmp);\n\t\t\t\tfclose(f);\n\t\t\t}\n\t\t\tfree(tmp);\n\t\t}\n\t}\n\tclosedir(dir);\n}",
    "includes": [
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "closedir",
          "args": [
            "dir"
          ],
          "line": 1075
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "tmp"
          ],
          "line": 1072
        },
        "resolved": true,
        "details": {
          "function_name": "free_rect",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/userinput.c",
          "lines": "6200-6247",
          "snippet": "int free_rect(int idx) {\n\tint n, ok = 0;\n\tsraRegionPtr r1, r2;\n\tint x, y, w, h;\n\n\tif (idx < 0 || idx >= cache_list_num) {\nif (0) fprintf(stderr, \"free_rect: bad index: %d\\n\", idx);\n\t\tclean_up_exit(1);\n\t}\n\n\tx = cache_list[idx].bs_x;\n\ty = cache_list[idx].bs_y;\n\tw = cache_list[idx].bs_w;\n\th = cache_list[idx].bs_h;\n\n\tif (x < 0) {\n\t\tCLEAR(idx);\nif (dnow() > last_client + 5 && ncdb) fprintf(stderr, \"free_rect: already bs_x invalidated: %d bs_x: %d\\n\", idx, x);\n\t\treturn 1;\n\t}\n\n\tr2 = sraRgnCreateRect(x, y, x+w, y+h);\n\n\tn = get_bs_n(y);\n\tif (n >= 0) {\n\t\tr1 = rect_reg[n];\n\t\tsraRgnOr(r1, r2);\n\t\tok = 1;\n\t}\n\n\tif (zero_rects) {\n\t\tsraRgnOr(zero_rects, r2);\n\t\tx = cache_list[idx].su_x;\n\t\ty = cache_list[idx].su_y;\n\t\tw = cache_list[idx].su_w;\n\t\th = cache_list[idx].su_h;\n\t\tif (x >= 0) {\n\t\t\tsraRgnDestroy(r2);\n\t\t\tr2 = sraRgnCreateRect(x, y, x+w, y+h);\n\t\t\tsraRgnOr(zero_rects, r2);\n\t\t}\n\t}\n\tsraRgnDestroy(r2);\n\n\tCLEAR(idx);\nif (! ok && ncdb) fprintf(stderr, \"**** free_rect: not-found %d\\n\", idx);\n\treturn ok;\n}",
          "includes": [
            "#include \"default8x16.h\"",
            "#include \"connections.h\"",
            "#include \"screen.h\"",
            "#include \"cursor.h\"",
            "#include \"macosxCGS.h\"",
            "#include \"macosx.h\"",
            "#include \"unixpw.h\"",
            "#include \"8to24.h\"",
            "#include \"xrandr.h\"",
            "#include \"solid.h\"",
            "#include \"keyboard.h\"",
            "#include \"rates.h\"",
            "#include \"pointer.h\"",
            "#include \"cleanup.h\"",
            "#include \"scan.h\"",
            "#include \"user.h\"",
            "#include \"xevents.h\"",
            "#include \"win_utils.h\"",
            "#include \"xinerama.h\"",
            "#include \"xrecord.h\"",
            "#include \"xdamage.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void mark_for_xdamage(int x, int y, int w, int h);",
            "void set_xdamage_mark(int x, int y, int w, int h);",
            "int find_rect(int idx, int x, int y, int w, int h);",
            "winattr_t *cache_list;",
            "int clipped(int idx);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"default8x16.h\"\n#include \"connections.h\"\n#include \"screen.h\"\n#include \"cursor.h\"\n#include \"macosxCGS.h\"\n#include \"macosx.h\"\n#include \"unixpw.h\"\n#include \"8to24.h\"\n#include \"xrandr.h\"\n#include \"solid.h\"\n#include \"keyboard.h\"\n#include \"rates.h\"\n#include \"pointer.h\"\n#include \"cleanup.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"xevents.h\"\n#include \"win_utils.h\"\n#include \"xinerama.h\"\n#include \"xrecord.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nvoid mark_for_xdamage(int x, int y, int w, int h);\nvoid set_xdamage_mark(int x, int y, int w, int h);\nint find_rect(int idx, int x, int y, int w, int h);\nwinattr_t *cache_list;\nint clipped(int idx);\n\nint free_rect(int idx) {\n\tint n, ok = 0;\n\tsraRegionPtr r1, r2;\n\tint x, y, w, h;\n\n\tif (idx < 0 || idx >= cache_list_num) {\nif (0) fprintf(stderr, \"free_rect: bad index: %d\\n\", idx);\n\t\tclean_up_exit(1);\n\t}\n\n\tx = cache_list[idx].bs_x;\n\ty = cache_list[idx].bs_y;\n\tw = cache_list[idx].bs_w;\n\th = cache_list[idx].bs_h;\n\n\tif (x < 0) {\n\t\tCLEAR(idx);\nif (dnow() > last_client + 5 && ncdb) fprintf(stderr, \"free_rect: already bs_x invalidated: %d bs_x: %d\\n\", idx, x);\n\t\treturn 1;\n\t}\n\n\tr2 = sraRgnCreateRect(x, y, x+w, y+h);\n\n\tn = get_bs_n(y);\n\tif (n >= 0) {\n\t\tr1 = rect_reg[n];\n\t\tsraRgnOr(r1, r2);\n\t\tok = 1;\n\t}\n\n\tif (zero_rects) {\n\t\tsraRgnOr(zero_rects, r2);\n\t\tx = cache_list[idx].su_x;\n\t\ty = cache_list[idx].su_y;\n\t\tw = cache_list[idx].su_w;\n\t\th = cache_list[idx].su_h;\n\t\tif (x >= 0) {\n\t\t\tsraRgnDestroy(r2);\n\t\t\tr2 = sraRgnCreateRect(x, y, x+w, y+h);\n\t\t\tsraRgnOr(zero_rects, r2);\n\t\t}\n\t}\n\tsraRgnDestroy(r2);\n\n\tCLEAR(idx);\nif (! ok && ncdb) fprintf(stderr, \"**** free_rect: not-found %d\\n\", idx);\n\treturn ok;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fclose",
          "args": [
            "f"
          ],
          "line": 1070
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "f",
            "\"%s\"",
            "tmp"
          ],
          "line": 1069
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ff",
          "args": [],
          "line": 1067
        },
        "resolved": true,
        "details": {
          "function_name": "ff",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/appshare.c",
          "lines": "293-296",
          "snippet": "static void ff(void) {\n\tfflush(stdout);\n\tfflush(stderr);\n}",
          "includes": [
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"x11vnc.h\"\n\nstatic void ff(void) {\n\tfflush(stdout);\n\tfflush(stderr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"%s client: %s + %s\"",
            "add ? \"add\" : \"disconnect\"",
            "tracktmp",
            "tmp"
          ],
          "line": 1065
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fopen",
          "args": [
            "tracktmp",
            "\"w\""
          ],
          "line": 1062
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wait_until_empty",
          "args": [
            "tracktmp"
          ],
          "line": 1061
        },
        "resolved": true,
        "details": {
          "function_name": "wait_until_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/appshare.c",
          "lines": "995-1008",
          "snippet": "static void wait_until_empty(char *file) {\n\tdouble t = 0.0, dt = 0.05;\n\twhile (t < 1.0) {\n\t\tstruct stat sb;\n\t\tif (stat(file, &sb) != 0) {\n\t\t\treturn;\n\t\t}\n\t\tif (sb.st_size == 0) {\n\t\t\treturn;\n\t\t}\n\t\tt += dt;\n\t\tusleep( (int) (dt * 1000 * 1000) );\n\t}\n}",
          "includes": [
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"x11vnc.h\"\n\nstatic void wait_until_empty(char *file) {\n\tdouble t = 0.0, dt = 0.05;\n\twhile (t < 1.0) {\n\t\tstruct stat sb;\n\t\tif (stat(file, &sb) != 0) {\n\t\t\treturn;\n\t\t}\n\t\tif (sb.st_size == 0) {\n\t\t\treturn;\n\t\t}\n\t\tt += dt;\n\t\tusleep( (int) (dt * 1000 * 1000) );\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "tmp",
            "\"cmd=close:%s\\n\"",
            "client"
          ],
          "line": 1059
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "tmp",
            "\"%s\\n\"",
            "client"
          ],
          "line": 1057
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "tracktmp",
            "\"%s/%s\"",
            "trackdir",
            "name"
          ],
          "line": 1055
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "calloc",
          "args": [
            "100 + strlen(client)",
            "1"
          ],
          "line": 1054
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "client"
          ],
          "line": 1054
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"twin: 0x%lx name=%s f=%d\\n\"",
            "twin",
            "name",
            "f"
          ],
          "line": 1046
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "find_win",
          "args": [
            "twin"
          ],
          "line": 1044
        },
        "resolved": true,
        "details": {
          "function_name": "find_win",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/appshare.c",
          "lines": "298-306",
          "snippet": "static int find_win(Window win) {\n\tint i;\n\tfor (i=0; i < WMAX; i++) {\n\t\tif (watch[i] == win) {\n\t\t\treturn i;\n\t\t}\n\t}\n\treturn -1;\n}",
          "includes": [
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [
            "#define WMAX 192"
          ],
          "globals_used": [
            "extern char *get_xprop(char *prop, Window win);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"x11vnc.h\"\n\n#define WMAX 192\n\nextern char *get_xprop(char *prop, Window win);\n\nstatic int find_win(Window win) {\n\tint i;\n\tfor (i=0; i < WMAX; i++) {\n\t\tif (watch[i] == win) {\n\t\t\treturn i;\n\t\t}\n\t}\n\treturn -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "scan_hexdec",
          "args": [
            "name",
            "&twin"
          ],
          "line": 1043
        },
        "resolved": true,
        "details": {
          "function_name": "scan_hexdec",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/util.c",
          "lines": "201-208",
          "snippet": "int scan_hexdec(char *str, unsigned long *num) {\n\tif (sscanf(str, \"0x%lx\", num) != 1) {\n\t\tif (sscanf(str, \"%lu\", num) != 1) {\n\t\t\treturn 0;\n\t\t}\n\t}\n\treturn 1;\n}",
          "includes": [
            "#include \"connections.h\"",
            "#include \"unixpw.h\"",
            "#include \"win_utils.h\"",
            "#include \"cleanup.h\"",
            "#include \"x11vnc.h\"",
            "#include <stdlib.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void lowercase(char *str);",
            "void uppercase(char *str);",
            "char *lblanks(char *str);",
            "void strzero(char *str);",
            "int scan_hexdec(char *str, unsigned long *num);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"connections.h\"\n#include \"unixpw.h\"\n#include \"win_utils.h\"\n#include \"cleanup.h\"\n#include \"x11vnc.h\"\n#include <stdlib.h>\n\nvoid lowercase(char *str);\nvoid uppercase(char *str);\nchar *lblanks(char *str);\nvoid strzero(char *str);\nint scan_hexdec(char *str, unsigned long *num);\n\nint scan_hexdec(char *str, unsigned long *num) {\n\tif (sscanf(str, \"0x%lx\", num) != 1) {\n\t\tif (sscanf(str, \"%lu\", num) != 1) {\n\t\t\treturn 0;\n\t\t}\n\t}\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "name",
            "\".connect\""
          ],
          "line": 1038
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "name",
            "\"0x\""
          ],
          "line": 1035
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "name",
            "\"..\""
          ],
          "line": 1032
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "name",
            "\".\""
          ],
          "line": 1032
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "readdir",
          "args": [
            "dir"
          ],
          "line": 1030
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"could not opendir trackdir: %s\\n\"",
            "trackdir"
          ],
          "line": 1027
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "opendir",
          "args": [
            "trackdir"
          ],
          "line": 1025
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stdout",
            "\"%s client: %s\\n\"",
            "add ? \"adding  \" : \"deleting\"",
            "client"
          ],
          "line": 1023
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"no trackdir, cannot %s client: %s\\n\"",
            "add ? \"add\" : \"disconnect\"",
            "client"
          ],
          "line": 1018
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"x11vnc.h\"\n\nstatic void client(char *client, int add) {\n\tDIR *dir;\n\tstruct dirent *dp;\n\n\tif (!client) {\n\t\treturn;\n\t}\n\tif (!trackdir) {\n\t\tfprintf(stderr, \"no trackdir, cannot %s client: %s\\n\",\n\t\t    add ? \"add\" : \"disconnect\", client);\n\t\tff();\n\t\treturn;\n\t}\n\tfprintf(stdout, \"%s client: %s\\n\", add ? \"adding  \" : \"deleting\", client);\n\n\tdir = opendir(trackdir);\n\tif (!dir) {\n\t\tfprintf(stderr, \"could not opendir trackdir: %s\\n\", trackdir);\n\t\treturn;\n\t}\n\twhile ( (dp = readdir(dir)) != NULL) {\n\t\tchar *name = dp->d_name;\n\t\tif (!strcmp(name, \".\") || !strcmp(name, \"..\")) {\n\t\t\tcontinue;\n\t\t}\n\t\tif (strstr(name, \"0x\") != name) {\n\t\t\tcontinue;\n\t\t}\n\t\tif (strstr(name, \".connect\")) {\n\t\t\tFILE *f;\n\t\t\tchar *tmp;\n\t\t\tWindow twin;\n\n\t\t\tif (scan_hexdec(name, &twin)) {\n\t\t\t\tint f = find_win(twin);\n\t\t\t\tif (appshare_debug) {\n\t\t\t\t\tfprintf(stderr, \"twin: 0x%lx name=%s f=%d\\n\", twin, name, f);\n\t\t\t\t\tff();\n\t\t\t\t}\n\t\t\t\tif (f < 0) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\ttmp = (char *) calloc(100 + strlen(client), 1);\n\t\t\tsprintf(tracktmp, \"%s/%s\", trackdir, name);\n\t\t\tif (add) {\n\t\t\t\tsprintf(tmp, \"%s\\n\", client);\n\t\t\t} else {\n\t\t\t\tsprintf(tmp, \"cmd=close:%s\\n\", client);\n\t\t\t}\n\t\t\twait_until_empty(tracktmp);\n\t\t\tf = fopen(tracktmp, \"w\");\n\t\t\tif (f) {\n\t\t\t\tif (appshare_debug) {\n\t\t\t\t\tfprintf(stderr, \"%s client: %s + %s\",\n\t\t\t\t\tadd ? \"add\" : \"disconnect\", tracktmp, tmp);\n\t\t\t\t\tff();\n\t\t\t\t}\n\t\t\t\tfprintf(f, \"%s\", tmp);\n\t\t\t\tfclose(f);\n\t\t\t}\n\t\t\tfree(tmp);\n\t\t}\n\t}\n\tclosedir(dir);\n}"
  },
  {
    "function_name": "wait_until_empty",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/appshare.c",
    "lines": "995-1008",
    "snippet": "static void wait_until_empty(char *file) {\n\tdouble t = 0.0, dt = 0.05;\n\twhile (t < 1.0) {\n\t\tstruct stat sb;\n\t\tif (stat(file, &sb) != 0) {\n\t\t\treturn;\n\t\t}\n\t\tif (sb.st_size == 0) {\n\t\t\treturn;\n\t\t}\n\t\tt += dt;\n\t\tusleep( (int) (dt * 1000 * 1000) );\n\t}\n}",
    "includes": [
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "usleep",
          "args": [
            "(int) (dt * 1000 * 1000)"
          ],
          "line": 1006
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "stat",
          "args": [
            "file",
            "&sb"
          ],
          "line": 999
        },
        "resolved": true,
        "details": {
          "function_name": "grab_state",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/connections.c",
          "lines": "3178-3224",
          "snippet": "void grab_state(int *ptr_grabbed, int *kbd_grabbed) {\n\tint rcp, rck;\n\tdouble t0, t1;\n\tdouble ta, tb, tc;\n\t*ptr_grabbed = -1;\n\t*kbd_grabbed = -1;\n\n\tif (!dpy) {\n\t\treturn;\n\t}\n\t*ptr_grabbed = 0;\n\t*kbd_grabbed = 0;\n\n#if !NO_X11\n\tX_LOCK;\n\n\tXSync(dpy, False);\n\n\tta = t0 = dnow();\n\n\trcp = XGrabPointer(dpy, window, False, 0, GrabModeAsync, GrabModeAsync, None, None, CurrentTime);\n\tXUngrabPointer(dpy, CurrentTime);\n\n\ttb = dnow();\n\t\n\trck = XGrabKeyboard(dpy, window, False, GrabModeAsync, GrabModeAsync, CurrentTime);\n\tXUngrabKeyboard(dpy, CurrentTime);\n\n\ttc = dnow();\n\n\tXSync(dpy, False);\n\n\tt1 = dnow();\n\n\tX_UNLOCK;\n\tif (rcp == AlreadyGrabbed || rcp == GrabFrozen) {\n\t\t*ptr_grabbed = 1;\n\t}\n\tif (rck == AlreadyGrabbed || rck == GrabFrozen) {\n\t\t*kbd_grabbed = 1;\n\t}\n\tif (rc_npieces < 10) {\n\t\trfbLog(\"grab_state: checked %d,%d in %.6f sec (%.6f %.6f)\\n\",\n\t\t    *ptr_grabbed, *kbd_grabbed, t1-t0, tb-ta, tc-tb);\n\t}\n#endif\n}",
          "includes": [
            "#include \"xi2_devices.h\"",
            "#include \"xrandr.h\"",
            "#include \"pointer.h\"",
            "#include \"userinput.h\"",
            "#include \"macosxCG.h\"",
            "#include \"macosx.h\"",
            "#include \"win_utils.h\"",
            "#include \"xevents.h\"",
            "#include \"xwrappers.h\"",
            "#include \"sslhelper.h\"",
            "#include \"sslcmds.h\"",
            "#include \"scan.h\"",
            "#include \"user.h\"",
            "#include \"unixpw.h\"",
            "#include \"screen.h\"",
            "#include \"rates.h\"",
            "#include \"solid.h\"",
            "#include \"gui.h\"",
            "#include \"cleanup.h\"",
            "#include \"keyboard.h\"",
            "#include \"remote.h\"",
            "#include \"inet.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void grab_state(int *ptr_grabbed, int *kbd_grabbed);",
            "extern int rc_npieces;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xi2_devices.h\"\n#include \"xrandr.h\"\n#include \"pointer.h\"\n#include \"userinput.h\"\n#include \"macosxCG.h\"\n#include \"macosx.h\"\n#include \"win_utils.h\"\n#include \"xevents.h\"\n#include \"xwrappers.h\"\n#include \"sslhelper.h\"\n#include \"sslcmds.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"unixpw.h\"\n#include \"screen.h\"\n#include \"rates.h\"\n#include \"solid.h\"\n#include \"gui.h\"\n#include \"cleanup.h\"\n#include \"keyboard.h\"\n#include \"remote.h\"\n#include \"inet.h\"\n#include \"x11vnc.h\"\n\nvoid grab_state(int *ptr_grabbed, int *kbd_grabbed);\nextern int rc_npieces;\n\nvoid grab_state(int *ptr_grabbed, int *kbd_grabbed) {\n\tint rcp, rck;\n\tdouble t0, t1;\n\tdouble ta, tb, tc;\n\t*ptr_grabbed = -1;\n\t*kbd_grabbed = -1;\n\n\tif (!dpy) {\n\t\treturn;\n\t}\n\t*ptr_grabbed = 0;\n\t*kbd_grabbed = 0;\n\n#if !NO_X11\n\tX_LOCK;\n\n\tXSync(dpy, False);\n\n\tta = t0 = dnow();\n\n\trcp = XGrabPointer(dpy, window, False, 0, GrabModeAsync, GrabModeAsync, None, None, CurrentTime);\n\tXUngrabPointer(dpy, CurrentTime);\n\n\ttb = dnow();\n\t\n\trck = XGrabKeyboard(dpy, window, False, GrabModeAsync, GrabModeAsync, CurrentTime);\n\tXUngrabKeyboard(dpy, CurrentTime);\n\n\ttc = dnow();\n\n\tXSync(dpy, False);\n\n\tt1 = dnow();\n\n\tX_UNLOCK;\n\tif (rcp == AlreadyGrabbed || rcp == GrabFrozen) {\n\t\t*ptr_grabbed = 1;\n\t}\n\tif (rck == AlreadyGrabbed || rck == GrabFrozen) {\n\t\t*kbd_grabbed = 1;\n\t}\n\tif (rc_npieces < 10) {\n\t\trfbLog(\"grab_state: checked %d,%d in %.6f sec (%.6f %.6f)\\n\",\n\t\t    *ptr_grabbed, *kbd_grabbed, t1-t0, tb-ta, tc-tb);\n\t}\n#endif\n}"
        }
      }
    ],
    "contextual_snippet": "#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"x11vnc.h\"\n\nstatic void wait_until_empty(char *file) {\n\tdouble t = 0.0, dt = 0.05;\n\twhile (t < 1.0) {\n\t\tstruct stat sb;\n\t\tif (stat(file, &sb) != 0) {\n\t\t\treturn;\n\t\t}\n\t\tif (sb.st_size == 0) {\n\t\t\treturn;\n\t\t}\n\t\tt += dt;\n\t\tusleep( (int) (dt * 1000 * 1000) );\n\t}\n}"
  },
  {
    "function_name": "del_app",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/appshare.c",
    "lines": "975-993",
    "snippet": "static void del_app(Window app) {\n\tint i;\n\tfor (i=0; i < WMAX; i++) {\n\t\tWindow win = watch[i];\n\t\tif (win != None) {\n\t\t\tif (same_app(app, win)) {\n\t\t\t\tdestroy_win(win);\n\t\t\t}\n\t\t}\n\t}\n\tfor (i=0; i < AMAX; i++) {\n\t\tWindow app2 = apps[i];\n\t\tif (app2 != None) {\n\t\t\tif (same_app(app, app2)) {\n\t\t\t\tapps[i] = None;\n\t\t\t}\n\t\t}\n\t}\n}",
    "includes": [
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [
      "#define AMAX 32",
      "#define WMAX 192"
    ],
    "globals_used": [
      "extern char *get_xprop(char *prop, Window win);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "same_app",
          "args": [
            "app",
            "app2"
          ],
          "line": 988
        },
        "resolved": true,
        "details": {
          "function_name": "same_app",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/appshare.c",
          "lines": "1293-1299",
          "snippet": "static int same_app(Window win, Window app) {\n\tif ( (win & cmask) == (app & cmask) ) {\n\t\treturn 1;\n\t} else {\n\t\treturn 0;\n\t}\n}",
          "includes": [
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "extern char *get_xprop(char *prop, Window win);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"x11vnc.h\"\n\nextern char *get_xprop(char *prop, Window win);\n\nstatic int same_app(Window win, Window app) {\n\tif ( (win & cmask) == (app & cmask) ) {\n\t\treturn 1;\n\t} else {\n\t\treturn 0;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "destroy_win",
          "args": [
            "win"
          ],
          "line": 981
        },
        "resolved": true,
        "details": {
          "function_name": "destroy_win",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/appshare.c",
          "lines": "1103-1106",
          "snippet": "static void destroy_win(Window win) {\n\tstop(win);\n\tdelete_win(win);\n}",
          "includes": [
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "extern char *get_xprop(char *prop, Window win);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"x11vnc.h\"\n\nextern char *get_xprop(char *prop, Window win);\n\nstatic void destroy_win(Window win) {\n\tstop(win);\n\tdelete_win(win);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"x11vnc.h\"\n\n#define AMAX 32\n#define WMAX 192\n\nextern char *get_xprop(char *prop, Window win);\n\nstatic void del_app(Window app) {\n\tint i;\n\tfor (i=0; i < WMAX; i++) {\n\t\tWindow win = watch[i];\n\t\tif (win != None) {\n\t\t\tif (same_app(app, win)) {\n\t\t\t\tdestroy_win(win);\n\t\t\t}\n\t\t}\n\t}\n\tfor (i=0; i < AMAX; i++) {\n\t\tWindow app2 = apps[i];\n\t\tif (app2 != None) {\n\t\t\tif (same_app(app, app2)) {\n\t\t\t\tapps[i] = None;\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "function_name": "add_app",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/appshare.c",
    "lines": "943-973",
    "snippet": "static void add_app(Window app) {\n\tint i, nw = 0, free = -1;\n        XErrorHandler old_handler;\n\n#if !NO_X11\n\ti = find_app(app);\n\tif (i >= 0) {\n\t\tfprintf(stderr, \"already tracking app: 0x%lx\\n\", app);\n\t\treturn;\n\t}\n\tfor (i=0; i < AMAX; i++) {\n\t\tif (same_app(apps[i], app)) {\n\t\t\tfprintf(stderr, \"already tracking app: 0x%lx via 0x%lx\\n\", app, apps[i]);\n\t\t\treturn;\n\t\t}\n\t}\n\tfree = find_app(None);\n\tif (free < 0) {\n\t\tfprintf(stderr, \"ran out of app slots.\\n\");\n\t\treturn;\n\t}\n\tapps[free] = app;\n\n\tadd_win(app);\n\n        old_handler = XSetErrorHandler(trap_xerror);\n\trecurse_search(0, tree_depth, root, app, &nw);\n       \tXSetErrorHandler(old_handler);\n#endif\n\tfprintf(stderr, \"tracking %d windows related to app window 0x%lx\\n\", nw, app);\n}",
    "includes": [
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [
      "#define AMAX 32"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"tracking %d windows related to app window 0x%lx\\n\"",
            "nw",
            "app"
          ],
          "line": 972
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XSetErrorHandler",
          "args": [
            "old_handler"
          ],
          "line": 970
        },
        "resolved": true,
        "details": {
          "function_name": "XSetErrorHandler",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/nox11_funcs.h",
          "lines": "2819-2821",
          "snippet": "XErrorHandler XSetErrorHandler (XErrorHandler h) {\n\treturn h;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "XErrorHandler XSetErrorHandler (XErrorHandler h) {\n\treturn h;\n}"
        }
      },
      {
        "call_info": {
          "callee": "recurse_search",
          "args": [
            "0",
            "tree_depth",
            "root",
            "app",
            "&nw"
          ],
          "line": 969
        },
        "resolved": true,
        "details": {
          "function_name": "recurse_search",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/appshare.c",
          "lines": "901-941",
          "snippet": "static void recurse_search(int level, int level_max, Window top, Window app, int *nw) {\n\tWindow w, r, parent, *list = NULL;\n\tunsigned int nchild;\n\tint ok = 0;\n\n\tif (appshare_debug > 1) {\n\t\tfprintf(stderr, \"level: %d level_max: %d  top: 0x%lx  app: 0x%lx\\n\", level, level_max, top, app);\n\t}\n\tif (level >= level_max) {\n\t\treturn;\n\t}\n\t\n#if !NO_X11\n\tok = XQueryTree(dpy, top, &r, &parent, &list, &nchild);\n\tif (ok) {\n\t\tint i;\n\t\tfor (i=0; i < (int) nchild; i++) {\n\t\t\tw = list[i];\n\t\t\tif (w == None || find_win(w) >= 0) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (ours(w) && w != app) {\n\t\t\t\tif (appshare_debug) fprintf(stderr, \"add level %d 0x%lx %d/%d\\n\",\n\t\t\t\t    level, w, i, nchild);\n\t\t\t\tadd_win(w);\n\t\t\t\t(*nw)++;\n\t\t\t}\n\t\t}\n\t\tfor (i=0; i < (int) nchild; i++) {\n\t\t\tw = list[i];\n\t\t\tif (w == None || ours(w)) {\n\t\t\t\tcontinue;\n\t\t\t} \n\t\t\trecurse_search(level+1, level_max, w, app, nw);\n\t\t}\n\t}\n\tif (list) {\n\t\tXFree(list);\n\t}\n#endif\n}",
          "includes": [
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"x11vnc.h\"\n\nstatic void recurse_search(int level, int level_max, Window top, Window app, int *nw) {\n\tWindow w, r, parent, *list = NULL;\n\tunsigned int nchild;\n\tint ok = 0;\n\n\tif (appshare_debug > 1) {\n\t\tfprintf(stderr, \"level: %d level_max: %d  top: 0x%lx  app: 0x%lx\\n\", level, level_max, top, app);\n\t}\n\tif (level >= level_max) {\n\t\treturn;\n\t}\n\t\n#if !NO_X11\n\tok = XQueryTree(dpy, top, &r, &parent, &list, &nchild);\n\tif (ok) {\n\t\tint i;\n\t\tfor (i=0; i < (int) nchild; i++) {\n\t\t\tw = list[i];\n\t\t\tif (w == None || find_win(w) >= 0) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (ours(w) && w != app) {\n\t\t\t\tif (appshare_debug) fprintf(stderr, \"add level %d 0x%lx %d/%d\\n\",\n\t\t\t\t    level, w, i, nchild);\n\t\t\t\tadd_win(w);\n\t\t\t\t(*nw)++;\n\t\t\t}\n\t\t}\n\t\tfor (i=0; i < (int) nchild; i++) {\n\t\t\tw = list[i];\n\t\t\tif (w == None || ours(w)) {\n\t\t\t\tcontinue;\n\t\t\t} \n\t\t\trecurse_search(level+1, level_max, w, app, nw);\n\t\t}\n\t}\n\tif (list) {\n\t\tXFree(list);\n\t}\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "add_win",
          "args": [
            "app"
          ],
          "line": 966
        },
        "resolved": true,
        "details": {
          "function_name": "add_win",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/appshare.c",
          "lines": "870-888",
          "snippet": "static void add_win(Window win) {\n\tint idx  = find_win(win);\n\tint free = find_win(None);\n\tif (idx >= 0) {\n\t\tif (appshare_debug) {fprintf(stderr, \"already watching window: 0x%lx\\n\", win); ff();}\n\t\treturn;\n\t}\n\tif (free < 0) {\n\t\tfprintf(stderr, \"ran out of slots for window: 0x%lx\\n\", win); ff();\n\t\treturn;\n\t}\n\n\tif (appshare_debug) {fprintf(stderr, \"watching: 0x%lx at %d\\n\", win, free); ff();}\n\n\twatch[free] = win;\n\tstate[free] = 0;\n\n\twin_select(win, 0);\n}",
          "includes": [
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "extern char *get_xprop(char *prop, Window win);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"x11vnc.h\"\n\nextern char *get_xprop(char *prop, Window win);\n\nstatic void add_win(Window win) {\n\tint idx  = find_win(win);\n\tint free = find_win(None);\n\tif (idx >= 0) {\n\t\tif (appshare_debug) {fprintf(stderr, \"already watching window: 0x%lx\\n\", win); ff();}\n\t\treturn;\n\t}\n\tif (free < 0) {\n\t\tfprintf(stderr, \"ran out of slots for window: 0x%lx\\n\", win); ff();\n\t\treturn;\n\t}\n\n\tif (appshare_debug) {fprintf(stderr, \"watching: 0x%lx at %d\\n\", win, free); ff();}\n\n\twatch[free] = win;\n\tstate[free] = 0;\n\n\twin_select(win, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"ran out of app slots.\\n\""
          ],
          "line": 961
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "find_app",
          "args": [
            "None"
          ],
          "line": 959
        },
        "resolved": true,
        "details": {
          "function_name": "find_app",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/appshare.c",
          "lines": "308-316",
          "snippet": "static int find_app(Window app) {\n\tint i;\n\tfor (i=0; i < AMAX; i++) {\n\t\tif (apps[i] == app) {\n\t\t\treturn i;\n\t\t}\n\t}\n\treturn -1;\n}",
          "includes": [
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [
            "#define AMAX 32"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"x11vnc.h\"\n\n#define AMAX 32\n\nstatic int find_app(Window app) {\n\tint i;\n\tfor (i=0; i < AMAX; i++) {\n\t\tif (apps[i] == app) {\n\t\t\treturn i;\n\t\t}\n\t}\n\treturn -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"already tracking app: 0x%lx via 0x%lx\\n\"",
            "app",
            "apps[i]"
          ],
          "line": 955
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "same_app",
          "args": [
            "apps[i]",
            "app"
          ],
          "line": 954
        },
        "resolved": true,
        "details": {
          "function_name": "same_app",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/appshare.c",
          "lines": "1293-1299",
          "snippet": "static int same_app(Window win, Window app) {\n\tif ( (win & cmask) == (app & cmask) ) {\n\t\treturn 1;\n\t} else {\n\t\treturn 0;\n\t}\n}",
          "includes": [
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "extern char *get_xprop(char *prop, Window win);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"x11vnc.h\"\n\nextern char *get_xprop(char *prop, Window win);\n\nstatic int same_app(Window win, Window app) {\n\tif ( (win & cmask) == (app & cmask) ) {\n\t\treturn 1;\n\t} else {\n\t\treturn 0;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"already tracking app: 0x%lx\\n\"",
            "app"
          ],
          "line": 950
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"x11vnc.h\"\n\n#define AMAX 32\n\nstatic void add_app(Window app) {\n\tint i, nw = 0, free = -1;\n        XErrorHandler old_handler;\n\n#if !NO_X11\n\ti = find_app(app);\n\tif (i >= 0) {\n\t\tfprintf(stderr, \"already tracking app: 0x%lx\\n\", app);\n\t\treturn;\n\t}\n\tfor (i=0; i < AMAX; i++) {\n\t\tif (same_app(apps[i], app)) {\n\t\t\tfprintf(stderr, \"already tracking app: 0x%lx via 0x%lx\\n\", app, apps[i]);\n\t\t\treturn;\n\t\t}\n\t}\n\tfree = find_app(None);\n\tif (free < 0) {\n\t\tfprintf(stderr, \"ran out of app slots.\\n\");\n\t\treturn;\n\t}\n\tapps[free] = app;\n\n\tadd_win(app);\n\n        old_handler = XSetErrorHandler(trap_xerror);\n\trecurse_search(0, tree_depth, root, app, &nw);\n       \tXSetErrorHandler(old_handler);\n#endif\n\tfprintf(stderr, \"tracking %d windows related to app window 0x%lx\\n\", nw, app);\n}"
  },
  {
    "function_name": "recurse_search",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/appshare.c",
    "lines": "901-941",
    "snippet": "static void recurse_search(int level, int level_max, Window top, Window app, int *nw) {\n\tWindow w, r, parent, *list = NULL;\n\tunsigned int nchild;\n\tint ok = 0;\n\n\tif (appshare_debug > 1) {\n\t\tfprintf(stderr, \"level: %d level_max: %d  top: 0x%lx  app: 0x%lx\\n\", level, level_max, top, app);\n\t}\n\tif (level >= level_max) {\n\t\treturn;\n\t}\n\t\n#if !NO_X11\n\tok = XQueryTree(dpy, top, &r, &parent, &list, &nchild);\n\tif (ok) {\n\t\tint i;\n\t\tfor (i=0; i < (int) nchild; i++) {\n\t\t\tw = list[i];\n\t\t\tif (w == None || find_win(w) >= 0) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (ours(w) && w != app) {\n\t\t\t\tif (appshare_debug) fprintf(stderr, \"add level %d 0x%lx %d/%d\\n\",\n\t\t\t\t    level, w, i, nchild);\n\t\t\t\tadd_win(w);\n\t\t\t\t(*nw)++;\n\t\t\t}\n\t\t}\n\t\tfor (i=0; i < (int) nchild; i++) {\n\t\t\tw = list[i];\n\t\t\tif (w == None || ours(w)) {\n\t\t\t\tcontinue;\n\t\t\t} \n\t\t\trecurse_search(level+1, level_max, w, app, nw);\n\t\t}\n\t}\n\tif (list) {\n\t\tXFree(list);\n\t}\n#endif\n}",
    "includes": [
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "XFree",
          "args": [
            "list"
          ],
          "line": 938
        },
        "resolved": true,
        "details": {
          "function_name": "XFree_wr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/xwrappers.c",
          "lines": "1664-1676",
          "snippet": "int XFree_wr(void *data) {\n\tif (data == NULL) {\n\t\treturn 1;\n\t}\n\tif (! dpy) {\n\t\treturn 1;\n\t}\n#if NO_X11\n\treturn 1;\n#else\n\treturn XFree(data);\n#endif\n}",
          "includes": [
            "#include \"nox11_funcs.h\"",
            "#include \"xwrappers.h\"",
            "#include \"xi2_devices.h\"",
            "#include \"macosx.h\"",
            "#include \"cleanup.h\"",
            "#include \"connections.h\"",
            "#include \"xevents.h\"",
            "#include \"keyboard.h\"",
            "#include \"xrecord.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void XTestDiscard_wr(Display *dpy);",
            "int XFree_wr(void *data);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"nox11_funcs.h\"\n#include \"xwrappers.h\"\n#include \"xi2_devices.h\"\n#include \"macosx.h\"\n#include \"cleanup.h\"\n#include \"connections.h\"\n#include \"xevents.h\"\n#include \"keyboard.h\"\n#include \"xrecord.h\"\n#include \"x11vnc.h\"\n\nvoid XTestDiscard_wr(Display *dpy);\nint XFree_wr(void *data);\n\nint XFree_wr(void *data) {\n\tif (data == NULL) {\n\t\treturn 1;\n\t}\n\tif (! dpy) {\n\t\treturn 1;\n\t}\n#if NO_X11\n\treturn 1;\n#else\n\treturn XFree(data);\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "recurse_search",
          "args": [
            "level+1",
            "level_max",
            "w",
            "app",
            "nw"
          ],
          "line": 934
        },
        "resolved": true,
        "details": {
          "function_name": "recurse_search",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/appshare.c",
          "lines": "901-941",
          "snippet": "static void recurse_search(int level, int level_max, Window top, Window app, int *nw) {\n\tWindow w, r, parent, *list = NULL;\n\tunsigned int nchild;\n\tint ok = 0;\n\n\tif (appshare_debug > 1) {\n\t\tfprintf(stderr, \"level: %d level_max: %d  top: 0x%lx  app: 0x%lx\\n\", level, level_max, top, app);\n\t}\n\tif (level >= level_max) {\n\t\treturn;\n\t}\n\t\n#if !NO_X11\n\tok = XQueryTree(dpy, top, &r, &parent, &list, &nchild);\n\tif (ok) {\n\t\tint i;\n\t\tfor (i=0; i < (int) nchild; i++) {\n\t\t\tw = list[i];\n\t\t\tif (w == None || find_win(w) >= 0) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (ours(w) && w != app) {\n\t\t\t\tif (appshare_debug) fprintf(stderr, \"add level %d 0x%lx %d/%d\\n\",\n\t\t\t\t    level, w, i, nchild);\n\t\t\t\tadd_win(w);\n\t\t\t\t(*nw)++;\n\t\t\t}\n\t\t}\n\t\tfor (i=0; i < (int) nchild; i++) {\n\t\t\tw = list[i];\n\t\t\tif (w == None || ours(w)) {\n\t\t\t\tcontinue;\n\t\t\t} \n\t\t\trecurse_search(level+1, level_max, w, app, nw);\n\t\t}\n\t}\n\tif (list) {\n\t\tXFree(list);\n\t}\n#endif\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "ours",
          "args": [
            "w"
          ],
          "line": 931
        },
        "resolved": true,
        "details": {
          "function_name": "ours",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/appshare.c",
          "lines": "1301-1311",
          "snippet": "static int ours(Window win) {\n\tint i;\n\tfor (i=0; i < AMAX; i++) {\n\t\tif (apps[i] != None) {\n\t\t\tif (same_app(win, apps[i])) {\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [
            "#define AMAX 32"
          ],
          "globals_used": [
            "extern char *get_xprop(char *prop, Window win);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"x11vnc.h\"\n\n#define AMAX 32\n\nextern char *get_xprop(char *prop, Window win);\n\nstatic int ours(Window win) {\n\tint i;\n\tfor (i=0; i < AMAX; i++) {\n\t\tif (apps[i] != None) {\n\t\t\tif (same_app(win, apps[i])) {\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "add_win",
          "args": [
            "w"
          ],
          "line": 925
        },
        "resolved": true,
        "details": {
          "function_name": "add_win",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/appshare.c",
          "lines": "870-888",
          "snippet": "static void add_win(Window win) {\n\tint idx  = find_win(win);\n\tint free = find_win(None);\n\tif (idx >= 0) {\n\t\tif (appshare_debug) {fprintf(stderr, \"already watching window: 0x%lx\\n\", win); ff();}\n\t\treturn;\n\t}\n\tif (free < 0) {\n\t\tfprintf(stderr, \"ran out of slots for window: 0x%lx\\n\", win); ff();\n\t\treturn;\n\t}\n\n\tif (appshare_debug) {fprintf(stderr, \"watching: 0x%lx at %d\\n\", win, free); ff();}\n\n\twatch[free] = win;\n\tstate[free] = 0;\n\n\twin_select(win, 0);\n}",
          "includes": [
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "extern char *get_xprop(char *prop, Window win);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"x11vnc.h\"\n\nextern char *get_xprop(char *prop, Window win);\n\nstatic void add_win(Window win) {\n\tint idx  = find_win(win);\n\tint free = find_win(None);\n\tif (idx >= 0) {\n\t\tif (appshare_debug) {fprintf(stderr, \"already watching window: 0x%lx\\n\", win); ff();}\n\t\treturn;\n\t}\n\tif (free < 0) {\n\t\tfprintf(stderr, \"ran out of slots for window: 0x%lx\\n\", win); ff();\n\t\treturn;\n\t}\n\n\tif (appshare_debug) {fprintf(stderr, \"watching: 0x%lx at %d\\n\", win, free); ff();}\n\n\twatch[free] = win;\n\tstate[free] = 0;\n\n\twin_select(win, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"add level %d 0x%lx %d/%d\\n\"",
            "level",
            "w",
            "i",
            "nchild"
          ],
          "line": 923
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "find_win",
          "args": [
            "w"
          ],
          "line": 919
        },
        "resolved": true,
        "details": {
          "function_name": "find_win",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/appshare.c",
          "lines": "298-306",
          "snippet": "static int find_win(Window win) {\n\tint i;\n\tfor (i=0; i < WMAX; i++) {\n\t\tif (watch[i] == win) {\n\t\t\treturn i;\n\t\t}\n\t}\n\treturn -1;\n}",
          "includes": [
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [
            "#define WMAX 192"
          ],
          "globals_used": [
            "extern char *get_xprop(char *prop, Window win);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"x11vnc.h\"\n\n#define WMAX 192\n\nextern char *get_xprop(char *prop, Window win);\n\nstatic int find_win(Window win) {\n\tint i;\n\tfor (i=0; i < WMAX; i++) {\n\t\tif (watch[i] == win) {\n\t\t\treturn i;\n\t\t}\n\t}\n\treturn -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "XQueryTree",
          "args": [
            "dpy",
            "top",
            "&r",
            "&parent",
            "&list",
            "&nchild"
          ],
          "line": 914
        },
        "resolved": true,
        "details": {
          "function_name": "XQueryTree_wr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/xwrappers.c",
          "lines": "1640-1662",
          "snippet": "Status XQueryTree_wr(Display *display, Window w, Window *root_return,\n    Window *parent_return, Window **children_return,\n    unsigned int *nchildren_return) {\n\n#ifdef MACOSX\n\tif (macosx_console) {\n\t\treturn macosx_xquerytree(w, root_return, parent_return,\n\t\t    children_return, nchildren_return);\n\t}\n#endif\n#if NO_X11\n\tif (!display || !w || !root_return || !parent_return\n\t    || !children_return || !nchildren_return) {}\n\treturn (Status) 0;\n#else\n\tif (! display) {\n\t\treturn (Status) 0;\n\t}\n\treturn XQueryTree(display, w, root_return, parent_return,\n\t    children_return, nchildren_return);\n#endif\t/* NO_X11 */\n    \t\n}",
          "includes": [
            "#include \"nox11_funcs.h\"",
            "#include \"xwrappers.h\"",
            "#include \"xi2_devices.h\"",
            "#include \"macosx.h\"",
            "#include \"cleanup.h\"",
            "#include \"connections.h\"",
            "#include \"xevents.h\"",
            "#include \"keyboard.h\"",
            "#include \"xrecord.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "Bool XTestCompareCurrentCursorWithWindow_wr(Display* dpy, Window w);",
            "int XCloseDisplay_wr(Display *display);",
            "Status XQueryTree_wr(Display *display, Window w, Window *root_return,\n    Window *parent_return, Window **children_return,\n    unsigned int *nchildren_return);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"nox11_funcs.h\"\n#include \"xwrappers.h\"\n#include \"xi2_devices.h\"\n#include \"macosx.h\"\n#include \"cleanup.h\"\n#include \"connections.h\"\n#include \"xevents.h\"\n#include \"keyboard.h\"\n#include \"xrecord.h\"\n#include \"x11vnc.h\"\n\nBool XTestCompareCurrentCursorWithWindow_wr(Display* dpy, Window w);\nint XCloseDisplay_wr(Display *display);\nStatus XQueryTree_wr(Display *display, Window w, Window *root_return,\n    Window *parent_return, Window **children_return,\n    unsigned int *nchildren_return);\n\nStatus XQueryTree_wr(Display *display, Window w, Window *root_return,\n    Window *parent_return, Window **children_return,\n    unsigned int *nchildren_return) {\n\n#ifdef MACOSX\n\tif (macosx_console) {\n\t\treturn macosx_xquerytree(w, root_return, parent_return,\n\t\t    children_return, nchildren_return);\n\t}\n#endif\n#if NO_X11\n\tif (!display || !w || !root_return || !parent_return\n\t    || !children_return || !nchildren_return) {}\n\treturn (Status) 0;\n#else\n\tif (! display) {\n\t\treturn (Status) 0;\n\t}\n\treturn XQueryTree(display, w, root_return, parent_return,\n\t    children_return, nchildren_return);\n#endif\t/* NO_X11 */\n    \t\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"level: %d level_max: %d  top: 0x%lx  app: 0x%lx\\n\"",
            "level",
            "level_max",
            "top",
            "app"
          ],
          "line": 907
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"x11vnc.h\"\n\nstatic void recurse_search(int level, int level_max, Window top, Window app, int *nw) {\n\tWindow w, r, parent, *list = NULL;\n\tunsigned int nchild;\n\tint ok = 0;\n\n\tif (appshare_debug > 1) {\n\t\tfprintf(stderr, \"level: %d level_max: %d  top: 0x%lx  app: 0x%lx\\n\", level, level_max, top, app);\n\t}\n\tif (level >= level_max) {\n\t\treturn;\n\t}\n\t\n#if !NO_X11\n\tok = XQueryTree(dpy, top, &r, &parent, &list, &nchild);\n\tif (ok) {\n\t\tint i;\n\t\tfor (i=0; i < (int) nchild; i++) {\n\t\t\tw = list[i];\n\t\t\tif (w == None || find_win(w) >= 0) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (ours(w) && w != app) {\n\t\t\t\tif (appshare_debug) fprintf(stderr, \"add level %d 0x%lx %d/%d\\n\",\n\t\t\t\t    level, w, i, nchild);\n\t\t\t\tadd_win(w);\n\t\t\t\t(*nw)++;\n\t\t\t}\n\t\t}\n\t\tfor (i=0; i < (int) nchild; i++) {\n\t\t\tw = list[i];\n\t\t\tif (w == None || ours(w)) {\n\t\t\t\tcontinue;\n\t\t\t} \n\t\t\trecurse_search(level+1, level_max, w, app, nw);\n\t\t}\n\t}\n\tif (list) {\n\t\tXFree(list);\n\t}\n#endif\n}"
  },
  {
    "function_name": "delete_win",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/appshare.c",
    "lines": "890-899",
    "snippet": "static void delete_win(Window win) {\n\tint i;\n\tfor (i=0; i < WMAX; i++) {\n\t\tif (watch[i] == win) {\n\t\t\twatch[i] = None;\n\t\t\tstate[i] = 0;\n\t\t\tif (appshare_debug) {fprintf(stderr, \"deleting: 0x%lx at %d\\n\", win, i); ff();}\n\t\t}\n\t}\n}",
    "includes": [
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [
      "#define WMAX 192"
    ],
    "globals_used": [
      "extern char *get_xprop(char *prop, Window win);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ff",
          "args": [],
          "line": 896
        },
        "resolved": true,
        "details": {
          "function_name": "ff",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/appshare.c",
          "lines": "293-296",
          "snippet": "static void ff(void) {\n\tfflush(stdout);\n\tfflush(stderr);\n}",
          "includes": [
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"x11vnc.h\"\n\nstatic void ff(void) {\n\tfflush(stdout);\n\tfflush(stderr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"deleting: 0x%lx at %d\\n\"",
            "win",
            "i"
          ],
          "line": 896
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"x11vnc.h\"\n\n#define WMAX 192\n\nextern char *get_xprop(char *prop, Window win);\n\nstatic void delete_win(Window win) {\n\tint i;\n\tfor (i=0; i < WMAX; i++) {\n\t\tif (watch[i] == win) {\n\t\t\twatch[i] = None;\n\t\t\tstate[i] = 0;\n\t\t\tif (appshare_debug) {fprintf(stderr, \"deleting: 0x%lx at %d\\n\", win, i); ff();}\n\t\t}\n\t}\n}"
  },
  {
    "function_name": "add_win",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/appshare.c",
    "lines": "870-888",
    "snippet": "static void add_win(Window win) {\n\tint idx  = find_win(win);\n\tint free = find_win(None);\n\tif (idx >= 0) {\n\t\tif (appshare_debug) {fprintf(stderr, \"already watching window: 0x%lx\\n\", win); ff();}\n\t\treturn;\n\t}\n\tif (free < 0) {\n\t\tfprintf(stderr, \"ran out of slots for window: 0x%lx\\n\", win); ff();\n\t\treturn;\n\t}\n\n\tif (appshare_debug) {fprintf(stderr, \"watching: 0x%lx at %d\\n\", win, free); ff();}\n\n\twatch[free] = win;\n\tstate[free] = 0;\n\n\twin_select(win, 0);\n}",
    "includes": [
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "extern char *get_xprop(char *prop, Window win);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "win_select",
          "args": [
            "win",
            "0"
          ],
          "line": 887
        },
        "resolved": true,
        "details": {
          "function_name": "win_select",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/appshare.c",
          "lines": "750-761",
          "snippet": "static void win_select(Window win, int ignore) {\n#if !NO_X11\n        XErrorHandler old_handler = XSetErrorHandler(trap_xerror);\n\tif (ignore) {\n\t\tXSelectInput(dpy, win, 0);\n\t} else {\n\t\tXSelectInput(dpy, win, SubstructureNotifyMask);\n\t}\n\tXSync(dpy, False);\n       \tXSetErrorHandler(old_handler);\n#endif\n}",
          "includes": [
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "extern char *get_xprop(char *prop, Window win);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"x11vnc.h\"\n\nextern char *get_xprop(char *prop, Window win);\n\nstatic void win_select(Window win, int ignore) {\n#if !NO_X11\n        XErrorHandler old_handler = XSetErrorHandler(trap_xerror);\n\tif (ignore) {\n\t\tXSelectInput(dpy, win, 0);\n\t} else {\n\t\tXSelectInput(dpy, win, SubstructureNotifyMask);\n\t}\n\tXSync(dpy, False);\n       \tXSetErrorHandler(old_handler);\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "ff",
          "args": [],
          "line": 882
        },
        "resolved": true,
        "details": {
          "function_name": "ff",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/appshare.c",
          "lines": "293-296",
          "snippet": "static void ff(void) {\n\tfflush(stdout);\n\tfflush(stderr);\n}",
          "includes": [
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"x11vnc.h\"\n\nstatic void ff(void) {\n\tfflush(stdout);\n\tfflush(stderr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"watching: 0x%lx at %d\\n\"",
            "win",
            "free"
          ],
          "line": 882
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"ran out of slots for window: 0x%lx\\n\"",
            "win"
          ],
          "line": 878
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"already watching window: 0x%lx\\n\"",
            "win"
          ],
          "line": 874
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "find_win",
          "args": [
            "None"
          ],
          "line": 872
        },
        "resolved": true,
        "details": {
          "function_name": "find_win",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/appshare.c",
          "lines": "298-306",
          "snippet": "static int find_win(Window win) {\n\tint i;\n\tfor (i=0; i < WMAX; i++) {\n\t\tif (watch[i] == win) {\n\t\t\treturn i;\n\t\t}\n\t}\n\treturn -1;\n}",
          "includes": [
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [
            "#define WMAX 192"
          ],
          "globals_used": [
            "extern char *get_xprop(char *prop, Window win);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"x11vnc.h\"\n\n#define WMAX 192\n\nextern char *get_xprop(char *prop, Window win);\n\nstatic int find_win(Window win) {\n\tint i;\n\tfor (i=0; i < WMAX; i++) {\n\t\tif (watch[i] == win) {\n\t\t\treturn i;\n\t\t}\n\t}\n\treturn -1;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"x11vnc.h\"\n\nextern char *get_xprop(char *prop, Window win);\n\nstatic void add_win(Window win) {\n\tint idx  = find_win(win);\n\tint free = find_win(None);\n\tif (idx >= 0) {\n\t\tif (appshare_debug) {fprintf(stderr, \"already watching window: 0x%lx\\n\", win); ff();}\n\t\treturn;\n\t}\n\tif (free < 0) {\n\t\tfprintf(stderr, \"ran out of slots for window: 0x%lx\\n\", win); ff();\n\t\treturn;\n\t}\n\n\tif (appshare_debug) {fprintf(stderr, \"watching: 0x%lx at %d\\n\", win, free); ff();}\n\n\twatch[free] = win;\n\tstate[free] = 0;\n\n\twin_select(win, 0);\n}"
  },
  {
    "function_name": "check_inside",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/appshare.c",
    "lines": "800-868",
    "snippet": "static Window check_inside(Window win) {\n\tint i, nwin = 0;\n\tint w, h, x, y;\n\tint Ws[WMAX], Hs[WMAX], Xs[WMAX], Ys[WMAX];\n\tWindow wins[WMAX];\n\n\tif (!win_attr(win)) {\n\t\treturn None; \n\t}\n\n\t/* store them first to give the win app more time to settle.  */\n\tfor (i=0; i < WMAX; i++) {\n\t\tint X, Y;\n\t\tWindow wchk = watch[i];\n\t\tif (wchk == None) {\n\t\t\tcontinue;\n\t\t}\n\t\tif (state[i] == 0) {\n\t\t\tcontinue;\n\t\t}\n\t\tif (!win_attr(wchk)) {\n\t\t\tcontinue;\n\t\t}\n\t\tif (!get_xy(wchk, &X, &Y)) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tXs[nwin] = X;\n\t\tYs[nwin] = Y;\n\t\tWs[nwin] = attr.width;\n\t\tHs[nwin] = attr.height;\n\t\twins[nwin] = wchk;\n\t\tnwin++;\n\t}\n\n\tif (nwin == 0) {\n\t\treturn None;\n\t}\n\n\tif (!win_attr(win)) {\n\t\treturn None; \n\t}\n\tw = attr.width;\n\th = attr.height;\n\n\tget_xy(win, &x, &y);\n\tif (!get_xy(win, &x, &y)) {\n\t\treturn None;\n\t}\n\n\tfor (i=0; i < nwin; i++) {\n\t\tint X, Y, W, H;\n\t\tWindow wchk = wins[i];\n\t\tX = Xs[i];\n\t\tY = Ys[i];\n\t\tW = Ws[i];\n\t\tH = Hs[i];\n\n\t\tif (appshare_debug) fprintf(stderr, \"check inside: 0x%lx  %dx%d+%d+%d %dx%d+%d+%d\\n\", wchk, w, h, x, y, W, H, X, Y);\n\n\t\tif (X <= x && Y <= y) {\n\t\t\tif (x + w  <= X + W && y + h < Y + H) {\n\t\t\t\treturn wchk;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn None;\n}",
    "includes": [
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [
      "#define WMAX 192"
    ],
    "globals_used": [
      "extern char *get_xprop(char *prop, Window win);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"check inside: 0x%lx  %dx%d+%d+%d %dx%d+%d+%d\\n\"",
            "wchk",
            "w",
            "h",
            "x",
            "y",
            "W",
            "H",
            "X",
            "Y"
          ],
          "line": 858
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_xy",
          "args": [
            "win",
            "&x",
            "&y"
          ],
          "line": 846
        },
        "resolved": true,
        "details": {
          "function_name": "get_xy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/appshare.c",
          "lines": "783-798",
          "snippet": "static int get_xy(Window win, int *x, int *y) {\n\tWindow cr;\n\tBool rc = False; \n#if !NO_X11\n\tXErrorHandler old_handler = XSetErrorHandler(trap_xerror);\n\n\trc = XTranslateCoordinates(dpy, win, root, 0, 0, x, y, &cr);\n       \tXSetErrorHandler(old_handler);\n#endif\n\n\tif (!rc) {\n\t\treturn 0;\n\t} else {\n\t\treturn 1;\n\t}\n}",
          "includes": [
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "extern char *get_xprop(char *prop, Window win);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"x11vnc.h\"\n\nextern char *get_xprop(char *prop, Window win);\n\nstatic int get_xy(Window win, int *x, int *y) {\n\tWindow cr;\n\tBool rc = False; \n#if !NO_X11\n\tXErrorHandler old_handler = XSetErrorHandler(trap_xerror);\n\n\trc = XTranslateCoordinates(dpy, win, root, 0, 0, x, y, &cr);\n       \tXSetErrorHandler(old_handler);\n#endif\n\n\tif (!rc) {\n\t\treturn 0;\n\t} else {\n\t\treturn 1;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "win_attr",
          "args": [
            "win"
          ],
          "line": 839
        },
        "resolved": true,
        "details": {
          "function_name": "win_attr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/appshare.c",
          "lines": "735-748",
          "snippet": "static int win_attr(Window win) {\n\tint ok = 0;\n#if !NO_X11\n        XErrorHandler old_handler = XSetErrorHandler(trap_xerror);\n\tok = XGetWindowAttributes(dpy, win, &attr);\n       \tXSetErrorHandler(old_handler);\n#endif\n\n\tif (ok) {\n\t\treturn 1;\n\t} else {\n\t\treturn 0;\n\t}\n}",
          "includes": [
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "extern char *get_xprop(char *prop, Window win);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"x11vnc.h\"\n\nextern char *get_xprop(char *prop, Window win);\n\nstatic int win_attr(Window win) {\n\tint ok = 0;\n#if !NO_X11\n        XErrorHandler old_handler = XSetErrorHandler(trap_xerror);\n\tok = XGetWindowAttributes(dpy, win, &attr);\n       \tXSetErrorHandler(old_handler);\n#endif\n\n\tif (ok) {\n\t\treturn 1;\n\t} else {\n\t\treturn 0;\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"x11vnc.h\"\n\n#define WMAX 192\n\nextern char *get_xprop(char *prop, Window win);\n\nstatic Window check_inside(Window win) {\n\tint i, nwin = 0;\n\tint w, h, x, y;\n\tint Ws[WMAX], Hs[WMAX], Xs[WMAX], Ys[WMAX];\n\tWindow wins[WMAX];\n\n\tif (!win_attr(win)) {\n\t\treturn None; \n\t}\n\n\t/* store them first to give the win app more time to settle.  */\n\tfor (i=0; i < WMAX; i++) {\n\t\tint X, Y;\n\t\tWindow wchk = watch[i];\n\t\tif (wchk == None) {\n\t\t\tcontinue;\n\t\t}\n\t\tif (state[i] == 0) {\n\t\t\tcontinue;\n\t\t}\n\t\tif (!win_attr(wchk)) {\n\t\t\tcontinue;\n\t\t}\n\t\tif (!get_xy(wchk, &X, &Y)) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tXs[nwin] = X;\n\t\tYs[nwin] = Y;\n\t\tWs[nwin] = attr.width;\n\t\tHs[nwin] = attr.height;\n\t\twins[nwin] = wchk;\n\t\tnwin++;\n\t}\n\n\tif (nwin == 0) {\n\t\treturn None;\n\t}\n\n\tif (!win_attr(win)) {\n\t\treturn None; \n\t}\n\tw = attr.width;\n\th = attr.height;\n\n\tget_xy(win, &x, &y);\n\tif (!get_xy(win, &x, &y)) {\n\t\treturn None;\n\t}\n\n\tfor (i=0; i < nwin; i++) {\n\t\tint X, Y, W, H;\n\t\tWindow wchk = wins[i];\n\t\tX = Xs[i];\n\t\tY = Ys[i];\n\t\tW = Ws[i];\n\t\tH = Hs[i];\n\n\t\tif (appshare_debug) fprintf(stderr, \"check inside: 0x%lx  %dx%d+%d+%d %dx%d+%d+%d\\n\", wchk, w, h, x, y, W, H, X, Y);\n\n\t\tif (X <= x && Y <= y) {\n\t\t\tif (x + w  <= X + W && y + h < Y + H) {\n\t\t\t\treturn wchk;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn None;\n}"
  },
  {
    "function_name": "get_xy",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/appshare.c",
    "lines": "783-798",
    "snippet": "static int get_xy(Window win, int *x, int *y) {\n\tWindow cr;\n\tBool rc = False; \n#if !NO_X11\n\tXErrorHandler old_handler = XSetErrorHandler(trap_xerror);\n\n\trc = XTranslateCoordinates(dpy, win, root, 0, 0, x, y, &cr);\n       \tXSetErrorHandler(old_handler);\n#endif\n\n\tif (!rc) {\n\t\treturn 0;\n\t} else {\n\t\treturn 1;\n\t}\n}",
    "includes": [
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "extern char *get_xprop(char *prop, Window win);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "XSetErrorHandler",
          "args": [
            "old_handler"
          ],
          "line": 790
        },
        "resolved": true,
        "details": {
          "function_name": "XSetErrorHandler",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/nox11_funcs.h",
          "lines": "2819-2821",
          "snippet": "XErrorHandler XSetErrorHandler (XErrorHandler h) {\n\treturn h;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "XErrorHandler XSetErrorHandler (XErrorHandler h) {\n\treturn h;\n}"
        }
      },
      {
        "call_info": {
          "callee": "XTranslateCoordinates",
          "args": [
            "dpy",
            "win",
            "root",
            "0",
            "0",
            "x",
            "y",
            "&cr"
          ],
          "line": 789
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"x11vnc.h\"\n\nextern char *get_xprop(char *prop, Window win);\n\nstatic int get_xy(Window win, int *x, int *y) {\n\tWindow cr;\n\tBool rc = False; \n#if !NO_X11\n\tXErrorHandler old_handler = XSetErrorHandler(trap_xerror);\n\n\trc = XTranslateCoordinates(dpy, win, root, 0, 0, x, y, &cr);\n       \tXSetErrorHandler(old_handler);\n#endif\n\n\tif (!rc) {\n\t\treturn 0;\n\t} else {\n\t\treturn 1;\n\t}\n}"
  },
  {
    "function_name": "get_parent",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/appshare.c",
    "lines": "763-781",
    "snippet": "static Window get_parent(Window win) {\n\tint ok;\n\tWindow r, parent = None, *list = NULL;\n\tunsigned int nchild;\n\n#if !NO_X11\n        XErrorHandler old_handler = XSetErrorHandler(trap_xerror);\n\tok = XQueryTree(dpy, win, &r, &parent, &list, &nchild);\n       \tXSetErrorHandler(old_handler);\n\n\tif (!ok) {\n\t\treturn None;\n\t}\n\tif (list) {\n\t\tXFree(list);\n\t}\n#endif\n\treturn parent;\n}",
    "includes": [
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "extern char *get_xprop(char *prop, Window win);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "XFree",
          "args": [
            "list"
          ],
          "line": 777
        },
        "resolved": true,
        "details": {
          "function_name": "XFree_wr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/xwrappers.c",
          "lines": "1664-1676",
          "snippet": "int XFree_wr(void *data) {\n\tif (data == NULL) {\n\t\treturn 1;\n\t}\n\tif (! dpy) {\n\t\treturn 1;\n\t}\n#if NO_X11\n\treturn 1;\n#else\n\treturn XFree(data);\n#endif\n}",
          "includes": [
            "#include \"nox11_funcs.h\"",
            "#include \"xwrappers.h\"",
            "#include \"xi2_devices.h\"",
            "#include \"macosx.h\"",
            "#include \"cleanup.h\"",
            "#include \"connections.h\"",
            "#include \"xevents.h\"",
            "#include \"keyboard.h\"",
            "#include \"xrecord.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void XTestDiscard_wr(Display *dpy);",
            "int XFree_wr(void *data);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"nox11_funcs.h\"\n#include \"xwrappers.h\"\n#include \"xi2_devices.h\"\n#include \"macosx.h\"\n#include \"cleanup.h\"\n#include \"connections.h\"\n#include \"xevents.h\"\n#include \"keyboard.h\"\n#include \"xrecord.h\"\n#include \"x11vnc.h\"\n\nvoid XTestDiscard_wr(Display *dpy);\nint XFree_wr(void *data);\n\nint XFree_wr(void *data) {\n\tif (data == NULL) {\n\t\treturn 1;\n\t}\n\tif (! dpy) {\n\t\treturn 1;\n\t}\n#if NO_X11\n\treturn 1;\n#else\n\treturn XFree(data);\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "XSetErrorHandler",
          "args": [
            "old_handler"
          ],
          "line": 771
        },
        "resolved": true,
        "details": {
          "function_name": "XSetErrorHandler",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/nox11_funcs.h",
          "lines": "2819-2821",
          "snippet": "XErrorHandler XSetErrorHandler (XErrorHandler h) {\n\treturn h;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "XErrorHandler XSetErrorHandler (XErrorHandler h) {\n\treturn h;\n}"
        }
      },
      {
        "call_info": {
          "callee": "XQueryTree",
          "args": [
            "dpy",
            "win",
            "&r",
            "&parent",
            "&list",
            "&nchild"
          ],
          "line": 770
        },
        "resolved": true,
        "details": {
          "function_name": "XQueryTree_wr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/xwrappers.c",
          "lines": "1640-1662",
          "snippet": "Status XQueryTree_wr(Display *display, Window w, Window *root_return,\n    Window *parent_return, Window **children_return,\n    unsigned int *nchildren_return) {\n\n#ifdef MACOSX\n\tif (macosx_console) {\n\t\treturn macosx_xquerytree(w, root_return, parent_return,\n\t\t    children_return, nchildren_return);\n\t}\n#endif\n#if NO_X11\n\tif (!display || !w || !root_return || !parent_return\n\t    || !children_return || !nchildren_return) {}\n\treturn (Status) 0;\n#else\n\tif (! display) {\n\t\treturn (Status) 0;\n\t}\n\treturn XQueryTree(display, w, root_return, parent_return,\n\t    children_return, nchildren_return);\n#endif\t/* NO_X11 */\n    \t\n}",
          "includes": [
            "#include \"nox11_funcs.h\"",
            "#include \"xwrappers.h\"",
            "#include \"xi2_devices.h\"",
            "#include \"macosx.h\"",
            "#include \"cleanup.h\"",
            "#include \"connections.h\"",
            "#include \"xevents.h\"",
            "#include \"keyboard.h\"",
            "#include \"xrecord.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "Bool XTestCompareCurrentCursorWithWindow_wr(Display* dpy, Window w);",
            "int XCloseDisplay_wr(Display *display);",
            "Status XQueryTree_wr(Display *display, Window w, Window *root_return,\n    Window *parent_return, Window **children_return,\n    unsigned int *nchildren_return);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"nox11_funcs.h\"\n#include \"xwrappers.h\"\n#include \"xi2_devices.h\"\n#include \"macosx.h\"\n#include \"cleanup.h\"\n#include \"connections.h\"\n#include \"xevents.h\"\n#include \"keyboard.h\"\n#include \"xrecord.h\"\n#include \"x11vnc.h\"\n\nBool XTestCompareCurrentCursorWithWindow_wr(Display* dpy, Window w);\nint XCloseDisplay_wr(Display *display);\nStatus XQueryTree_wr(Display *display, Window w, Window *root_return,\n    Window *parent_return, Window **children_return,\n    unsigned int *nchildren_return);\n\nStatus XQueryTree_wr(Display *display, Window w, Window *root_return,\n    Window *parent_return, Window **children_return,\n    unsigned int *nchildren_return) {\n\n#ifdef MACOSX\n\tif (macosx_console) {\n\t\treturn macosx_xquerytree(w, root_return, parent_return,\n\t\t    children_return, nchildren_return);\n\t}\n#endif\n#if NO_X11\n\tif (!display || !w || !root_return || !parent_return\n\t    || !children_return || !nchildren_return) {}\n\treturn (Status) 0;\n#else\n\tif (! display) {\n\t\treturn (Status) 0;\n\t}\n\treturn XQueryTree(display, w, root_return, parent_return,\n\t    children_return, nchildren_return);\n#endif\t/* NO_X11 */\n    \t\n}"
        }
      }
    ],
    "contextual_snippet": "#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"x11vnc.h\"\n\nextern char *get_xprop(char *prop, Window win);\n\nstatic Window get_parent(Window win) {\n\tint ok;\n\tWindow r, parent = None, *list = NULL;\n\tunsigned int nchild;\n\n#if !NO_X11\n        XErrorHandler old_handler = XSetErrorHandler(trap_xerror);\n\tok = XQueryTree(dpy, win, &r, &parent, &list, &nchild);\n       \tXSetErrorHandler(old_handler);\n\n\tif (!ok) {\n\t\treturn None;\n\t}\n\tif (list) {\n\t\tXFree(list);\n\t}\n#endif\n\treturn parent;\n}"
  },
  {
    "function_name": "win_select",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/appshare.c",
    "lines": "750-761",
    "snippet": "static void win_select(Window win, int ignore) {\n#if !NO_X11\n        XErrorHandler old_handler = XSetErrorHandler(trap_xerror);\n\tif (ignore) {\n\t\tXSelectInput(dpy, win, 0);\n\t} else {\n\t\tXSelectInput(dpy, win, SubstructureNotifyMask);\n\t}\n\tXSync(dpy, False);\n       \tXSetErrorHandler(old_handler);\n#endif\n}",
    "includes": [
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "extern char *get_xprop(char *prop, Window win);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "XSetErrorHandler",
          "args": [
            "old_handler"
          ],
          "line": 759
        },
        "resolved": true,
        "details": {
          "function_name": "XSetErrorHandler",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/nox11_funcs.h",
          "lines": "2819-2821",
          "snippet": "XErrorHandler XSetErrorHandler (XErrorHandler h) {\n\treturn h;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "XErrorHandler XSetErrorHandler (XErrorHandler h) {\n\treturn h;\n}"
        }
      },
      {
        "call_info": {
          "callee": "XSync",
          "args": [
            "dpy",
            "False"
          ],
          "line": 758
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XSelectInput",
          "args": [
            "dpy",
            "win",
            "SubstructureNotifyMask"
          ],
          "line": 756
        },
        "resolved": true,
        "details": {
          "function_name": "XSelectInput_wr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/xwrappers.c",
          "lines": "1678-1697",
          "snippet": "int XSelectInput_wr(Display *display, Window w, long event_mask) {\n#if NO_X11\n\tif (!display || !w || !event_mask) {}\n\treturn 0;\n#else\n\tint rc;\n\tXErrorHandler old_handler;\n\tif (display == NULL || w == None) {\n\t\treturn 0;\n\t}\n\told_handler = XSetErrorHandler(trap_xerror);\n\ttrapped_xerror = 0;\n\trc = XSelectInput(display, w, event_mask);\n\tXSetErrorHandler(old_handler);\n\tif (trapped_xerror) {\n\t\trc = 0;\n\t}\n\treturn rc;\n#endif\n}",
          "includes": [
            "#include \"nox11_funcs.h\"",
            "#include \"xwrappers.h\"",
            "#include \"xi2_devices.h\"",
            "#include \"macosx.h\"",
            "#include \"cleanup.h\"",
            "#include \"connections.h\"",
            "#include \"xevents.h\"",
            "#include \"keyboard.h\"",
            "#include \"xrecord.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "Bool XTestCompareCurrentCursorWithWindow_wr(Display* dpy, Window w);",
            "int XCloseDisplay_wr(Display *display);",
            "int XSelectInput_wr(Display *display, Window w, long event_mask);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"nox11_funcs.h\"\n#include \"xwrappers.h\"\n#include \"xi2_devices.h\"\n#include \"macosx.h\"\n#include \"cleanup.h\"\n#include \"connections.h\"\n#include \"xevents.h\"\n#include \"keyboard.h\"\n#include \"xrecord.h\"\n#include \"x11vnc.h\"\n\nBool XTestCompareCurrentCursorWithWindow_wr(Display* dpy, Window w);\nint XCloseDisplay_wr(Display *display);\nint XSelectInput_wr(Display *display, Window w, long event_mask);\n\nint XSelectInput_wr(Display *display, Window w, long event_mask) {\n#if NO_X11\n\tif (!display || !w || !event_mask) {}\n\treturn 0;\n#else\n\tint rc;\n\tXErrorHandler old_handler;\n\tif (display == NULL || w == None) {\n\t\treturn 0;\n\t}\n\told_handler = XSetErrorHandler(trap_xerror);\n\ttrapped_xerror = 0;\n\trc = XSelectInput(display, w, event_mask);\n\tXSetErrorHandler(old_handler);\n\tif (trapped_xerror) {\n\t\trc = 0;\n\t}\n\treturn rc;\n#endif\n}"
        }
      }
    ],
    "contextual_snippet": "#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"x11vnc.h\"\n\nextern char *get_xprop(char *prop, Window win);\n\nstatic void win_select(Window win, int ignore) {\n#if !NO_X11\n        XErrorHandler old_handler = XSetErrorHandler(trap_xerror);\n\tif (ignore) {\n\t\tXSelectInput(dpy, win, 0);\n\t} else {\n\t\tXSelectInput(dpy, win, SubstructureNotifyMask);\n\t}\n\tXSync(dpy, False);\n       \tXSetErrorHandler(old_handler);\n#endif\n}"
  },
  {
    "function_name": "win_attr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/appshare.c",
    "lines": "735-748",
    "snippet": "static int win_attr(Window win) {\n\tint ok = 0;\n#if !NO_X11\n        XErrorHandler old_handler = XSetErrorHandler(trap_xerror);\n\tok = XGetWindowAttributes(dpy, win, &attr);\n       \tXSetErrorHandler(old_handler);\n#endif\n\n\tif (ok) {\n\t\treturn 1;\n\t} else {\n\t\treturn 0;\n\t}\n}",
    "includes": [
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "extern char *get_xprop(char *prop, Window win);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "XSetErrorHandler",
          "args": [
            "old_handler"
          ],
          "line": 740
        },
        "resolved": true,
        "details": {
          "function_name": "XSetErrorHandler",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/nox11_funcs.h",
          "lines": "2819-2821",
          "snippet": "XErrorHandler XSetErrorHandler (XErrorHandler h) {\n\treturn h;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "XErrorHandler XSetErrorHandler (XErrorHandler h) {\n\treturn h;\n}"
        }
      },
      {
        "call_info": {
          "callee": "XGetWindowAttributes",
          "args": [
            "dpy",
            "win",
            "&attr"
          ],
          "line": 739
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"x11vnc.h\"\n\nextern char *get_xprop(char *prop, Window win);\n\nstatic int win_attr(Window win) {\n\tint ok = 0;\n#if !NO_X11\n        XErrorHandler old_handler = XSetErrorHandler(trap_xerror);\n\tok = XGetWindowAttributes(dpy, win, &attr);\n       \tXSetErrorHandler(old_handler);\n#endif\n\n\tif (ok) {\n\t\treturn 1;\n\t} else {\n\t\treturn 0;\n\t}\n}"
  },
  {
    "function_name": "get_wm_name",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/appshare.c",
    "lines": "721-733",
    "snippet": "static void get_wm_name(Window win, char **name) {\n\tint ok = 0;\n\n#if !NO_X11\n        XErrorHandler old_handler = XSetErrorHandler(trap_xerror);\n\tok = XFetchName(dpy, win, name);\n       \tXSetErrorHandler(old_handler);\n#endif\n\n\tif (!ok || *name == NULL) {\n\t\t*name = strdup(\"unknown\");\n\t}\n}",
    "includes": [
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "extern char *get_xprop(char *prop, Window win);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "\"unknown\""
          ],
          "line": 731
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XSetErrorHandler",
          "args": [
            "old_handler"
          ],
          "line": 727
        },
        "resolved": true,
        "details": {
          "function_name": "XSetErrorHandler",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/nox11_funcs.h",
          "lines": "2819-2821",
          "snippet": "XErrorHandler XSetErrorHandler (XErrorHandler h) {\n\treturn h;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "XErrorHandler XSetErrorHandler (XErrorHandler h) {\n\treturn h;\n}"
        }
      },
      {
        "call_info": {
          "callee": "XFetchName",
          "args": [
            "dpy",
            "win",
            "name"
          ],
          "line": 726
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"x11vnc.h\"\n\nextern char *get_xprop(char *prop, Window win);\n\nstatic void get_wm_name(Window win, char **name) {\n\tint ok = 0;\n\n#if !NO_X11\n        XErrorHandler old_handler = XSetErrorHandler(trap_xerror);\n\tok = XFetchName(dpy, win, name);\n       \tXSetErrorHandler(old_handler);\n#endif\n\n\tif (!ok || *name == NULL) {\n\t\t*name = strdup(\"unknown\");\n\t}\n}"
  },
  {
    "function_name": "trap_xerror",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/appshare.c",
    "lines": "690-693",
    "snippet": "static int trap_xerror(Display *d, XErrorEvent *error) {\n\tif (d || error) {}\n\treturn 0;\n}",
    "includes": [
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"x11vnc.h\"\n\nstatic int trap_xerror(Display *d, XErrorEvent *error) {\n\tif (d || error) {}\n\treturn 0;\n}"
  },
  {
    "function_name": "appshare_cleanup",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/appshare.c",
    "lines": "630-688",
    "snippet": "static void appshare_cleanup(int s) {\n\tint i;\n\tif (s) {}\n\n\tif (use_forever) {\n\t\t/* launch this backup in case they kill -9 us before we terminate everything */\n\t\tchar cmd[1000];\n\t\tsprintf(cmd, \"(sleep 3; pkill -TERM -f '%s') &\", unique_tag);\n\t\tif (appshare_debug) fprintf(stderr, \"%s\\n\", cmd);\n\t\tsystem(cmd);\n\t}\n\n\tfor (i=0; i < WMAX; i++) {\n\t\tif (watch[i] != None) {\n\t\t\tstop(watch[i]);\n\t\t}\n\t}\n\n\tif (trackdir) {\n\t\tDIR *dir = opendir(trackdir);\n\t\tif (dir) {\n\t\t\tstruct dirent *dp;\n\t\t\twhile ( (dp = readdir(dir)) != NULL) {\n\t\t\t\tchar *name = dp->d_name;\n\t\t\t\tif (!strcmp(name, \".\") || !strcmp(name, \"..\")) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (strstr(name, \"0x\") != name) {\n\t\t\t\t\tfprintf(stderr, \"skipping: %s\\n\", name);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (!appshare_debug) {\n\t\t\t\t\tfprintf(stderr, \"removing: %s\\n\", name);\n\t\t\t\t\tsprintf(tracktmp, \"%s/%s\", trackdir, name);\n\t\t\t\t\tunlink(tracktmp);\n\t\t\t\t} else {\n\t\t\t\t\tif (appshare_debug) fprintf(stderr, \"keeping:  %s\\n\", name);\n\t\t\t\t}\n\t\t\t}\n\t\t\tclosedir(dir);\n\t\t}\n\t\tif (!appshare_debug) {\n\t\t\tif (strstr(trackdir, trackpre) == trackdir) {\n\t\t\t\tif (appshare_debug) fprintf(stderr, \"removing: %s\\n\", trackdir);\n\t\t\t\trmdir(trackdir);\n\t\t\t}\n\t\t}\n\t\tff();\n\t}\n\n\tkill_helper_pid();\n\t\t\t\n#if !NO_X11\n\tXCloseDisplay(dpy);\n#endif\n\tfprintf(stdout, \"done.\\n\");\n\tff();\n\texit(0);\n}",
    "includes": [
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [
      "#define WMAX 192"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "0"
          ],
          "line": 687
        },
        "resolved": true,
        "details": {
          "function_name": "clean_up_exit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/cleanup.c",
          "lines": "151-266",
          "snippet": "void clean_up_exit(int ret) {\n\tstatic int depth = 0;\n\texit_flag = 1;\n\n\tif (depth++ > 2) {\n\t\texit(ret);\n\t}\n\n\tif (icon_mode) {\n\t\tclean_icon_mode();\n\t}\n\n\t/* remove the shm areas: */\n\tclean_shm(0);\n\n\tstop_stunnel();\n\tif (use_openssl) {\n\t\tssl_helper_pid(0, 0);\t/* killall */\n\t}\n\n\tif (ssh_pid > 0) {\n\t\tkill(ssh_pid, SIGTERM);\n\t\tssh_pid = 0;\n\t}\n\n#ifdef MACOSX\n\tif (client_connect_file) {\n\t\tif (strstr(client_connect_file, \"/tmp/x11vnc-macosx-remote\")\n\t\t    == client_connect_file) {\n\t\t\tunlink(client_connect_file);\n\t\t}\n\t}\n\tif (macosx_console) {\n\t\tmacosxCG_fini();\n\t}\n#endif\n\n\tif (pipeinput_fh != NULL) {\n\t\tpclose(pipeinput_fh);\n\t\tpipeinput_fh = NULL;\n\t}\n\n\tshutdown_uinput();\n\n\tif (unix_sock) {\n\t\tif (unix_sock_fd >= 0) {\n\t\t\trfbLog(\"deleting unix sock: %s\\n\", unix_sock);\n\t\t\tclose(unix_sock_fd);\n\t\t\tunix_sock_fd = -1;\n\t\t\tunlink(unix_sock);\n\t\t}\n\t}\n\n\tif (! dpy) {\t/* raw_rb hack */\n\t\tif (rm_flagfile) {\n\t\t\tunlink(rm_flagfile);\n\t\t\trm_flagfile = NULL;\n\t\t}\n\t\texit(ret);\n\t}\n\n\t/* X keyboard cleanups */\n\tdelete_added_keycodes(0);\n\n\t/* remove all created XInput2 devices */\n\tif(use_multipointer)\n\t    removeAllMDs(dpy);\n\n\tif (clear_mods == 1) {\n\t\tclear_modifiers(0);\n\t} else if (clear_mods == 2) {\n\t\tclear_keys();\n\t} else if (clear_mods == 3) {\n\t\tclear_keys();\n\t\tclear_locks();\n\t}\n\n\tif (no_autorepeat) {\n\t\tautorepeat(1, 0);\n\t}\n\tif (use_solid_bg) {\n\t\tsolid_bg(1);\n\t}\n\tif (ncache || ncache0) {\n\t\tkde_no_animate(1);\n\t}\n\tX_LOCK;\n\tXTestDiscard_wr(dpy);\n#if HAVE_LIBXDAMAGE\n\tif (xdamage) {\n\t\tXDamageDestroy(dpy, xdamage);\n\t}\n#endif\n#if HAVE_LIBXTRAP\n\tif (trap_ctx) {\n\t\tXEFreeTC(trap_ctx);\n\t}\n#endif\n\t/* XXX rdpy_ctrl, etc. cannot close w/o blocking */\n\tXCloseDisplay_wr(dpy);\n\tX_UNLOCK;\n\n\tfflush(stderr);\n\n\tif (rm_flagfile) {\n\t\tunlink(rm_flagfile);\n\t\trm_flagfile = NULL;\n\t}\n\n\tif (avahi) {\n\t\tavahi_cleanup();\n\t\tfflush(stderr);\n\t}\n\n\texit(ret);\n}",
          "includes": [
            "#include \"xi2_devices.h\"",
            "#include \"uinput.h\"",
            "#include \"xevents.h\"",
            "#include \"xrecord.h\"",
            "#include \"screen.h\"",
            "#include \"avahi.h\"",
            "#include \"macosxCG.h\"",
            "#include \"macosx.h\"",
            "#include \"connections.h\"",
            "#include \"sslhelper.h\"",
            "#include \"sslcmds.h\"",
            "#include \"unixpw.h\"",
            "#include \"solid.h\"",
            "#include \"gui.h\"",
            "#include \"scan.h\"",
            "#include \"keyboard.h\"",
            "#include \"remote.h\"",
            "#include \"xdamage.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void clean_up_exit(int ret);",
            "int known_sigpipe_mode(char *s);",
            "static int exit_flag = 0;",
            "static void clean_icon_mode(void);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xi2_devices.h\"\n#include \"uinput.h\"\n#include \"xevents.h\"\n#include \"xrecord.h\"\n#include \"screen.h\"\n#include \"avahi.h\"\n#include \"macosxCG.h\"\n#include \"macosx.h\"\n#include \"connections.h\"\n#include \"sslhelper.h\"\n#include \"sslcmds.h\"\n#include \"unixpw.h\"\n#include \"solid.h\"\n#include \"gui.h\"\n#include \"scan.h\"\n#include \"keyboard.h\"\n#include \"remote.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nvoid clean_up_exit(int ret);\nint known_sigpipe_mode(char *s);\nstatic int exit_flag = 0;\nstatic void clean_icon_mode(void);\n\nvoid clean_up_exit(int ret) {\n\tstatic int depth = 0;\n\texit_flag = 1;\n\n\tif (depth++ > 2) {\n\t\texit(ret);\n\t}\n\n\tif (icon_mode) {\n\t\tclean_icon_mode();\n\t}\n\n\t/* remove the shm areas: */\n\tclean_shm(0);\n\n\tstop_stunnel();\n\tif (use_openssl) {\n\t\tssl_helper_pid(0, 0);\t/* killall */\n\t}\n\n\tif (ssh_pid > 0) {\n\t\tkill(ssh_pid, SIGTERM);\n\t\tssh_pid = 0;\n\t}\n\n#ifdef MACOSX\n\tif (client_connect_file) {\n\t\tif (strstr(client_connect_file, \"/tmp/x11vnc-macosx-remote\")\n\t\t    == client_connect_file) {\n\t\t\tunlink(client_connect_file);\n\t\t}\n\t}\n\tif (macosx_console) {\n\t\tmacosxCG_fini();\n\t}\n#endif\n\n\tif (pipeinput_fh != NULL) {\n\t\tpclose(pipeinput_fh);\n\t\tpipeinput_fh = NULL;\n\t}\n\n\tshutdown_uinput();\n\n\tif (unix_sock) {\n\t\tif (unix_sock_fd >= 0) {\n\t\t\trfbLog(\"deleting unix sock: %s\\n\", unix_sock);\n\t\t\tclose(unix_sock_fd);\n\t\t\tunix_sock_fd = -1;\n\t\t\tunlink(unix_sock);\n\t\t}\n\t}\n\n\tif (! dpy) {\t/* raw_rb hack */\n\t\tif (rm_flagfile) {\n\t\t\tunlink(rm_flagfile);\n\t\t\trm_flagfile = NULL;\n\t\t}\n\t\texit(ret);\n\t}\n\n\t/* X keyboard cleanups */\n\tdelete_added_keycodes(0);\n\n\t/* remove all created XInput2 devices */\n\tif(use_multipointer)\n\t    removeAllMDs(dpy);\n\n\tif (clear_mods == 1) {\n\t\tclear_modifiers(0);\n\t} else if (clear_mods == 2) {\n\t\tclear_keys();\n\t} else if (clear_mods == 3) {\n\t\tclear_keys();\n\t\tclear_locks();\n\t}\n\n\tif (no_autorepeat) {\n\t\tautorepeat(1, 0);\n\t}\n\tif (use_solid_bg) {\n\t\tsolid_bg(1);\n\t}\n\tif (ncache || ncache0) {\n\t\tkde_no_animate(1);\n\t}\n\tX_LOCK;\n\tXTestDiscard_wr(dpy);\n#if HAVE_LIBXDAMAGE\n\tif (xdamage) {\n\t\tXDamageDestroy(dpy, xdamage);\n\t}\n#endif\n#if HAVE_LIBXTRAP\n\tif (trap_ctx) {\n\t\tXEFreeTC(trap_ctx);\n\t}\n#endif\n\t/* XXX rdpy_ctrl, etc. cannot close w/o blocking */\n\tXCloseDisplay_wr(dpy);\n\tX_UNLOCK;\n\n\tfflush(stderr);\n\n\tif (rm_flagfile) {\n\t\tunlink(rm_flagfile);\n\t\trm_flagfile = NULL;\n\t}\n\n\tif (avahi) {\n\t\tavahi_cleanup();\n\t\tfflush(stderr);\n\t}\n\n\texit(ret);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ff",
          "args": [],
          "line": 686
        },
        "resolved": true,
        "details": {
          "function_name": "ff",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/appshare.c",
          "lines": "293-296",
          "snippet": "static void ff(void) {\n\tfflush(stdout);\n\tfflush(stderr);\n}",
          "includes": [
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"x11vnc.h\"\n\nstatic void ff(void) {\n\tfflush(stdout);\n\tfflush(stderr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stdout",
            "\"done.\\n\""
          ],
          "line": 685
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XCloseDisplay",
          "args": [
            "dpy"
          ],
          "line": 683
        },
        "resolved": true,
        "details": {
          "function_name": "XCloseDisplay_wr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/xwrappers.c",
          "lines": "1504-1512",
          "snippet": "int XCloseDisplay_wr(Display *display) {\n\tint db = 0;\n\tif (db) fprintf(stderr, \"XCloseDisplay_wr: %p\\n\", (void *)display);\n#if NO_X11\n\treturn 0;\n#else\n\treturn XCloseDisplay(display);\n#endif\t/* NO_X11 */\n}",
          "includes": [
            "#include \"nox11_funcs.h\"",
            "#include \"xwrappers.h\"",
            "#include \"xi2_devices.h\"",
            "#include \"macosx.h\"",
            "#include \"cleanup.h\"",
            "#include \"connections.h\"",
            "#include \"xevents.h\"",
            "#include \"keyboard.h\"",
            "#include \"xrecord.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int XCloseDisplay_wr(Display *display);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"nox11_funcs.h\"\n#include \"xwrappers.h\"\n#include \"xi2_devices.h\"\n#include \"macosx.h\"\n#include \"cleanup.h\"\n#include \"connections.h\"\n#include \"xevents.h\"\n#include \"keyboard.h\"\n#include \"xrecord.h\"\n#include \"x11vnc.h\"\n\nint XCloseDisplay_wr(Display *display);\n\nint XCloseDisplay_wr(Display *display) {\n\tint db = 0;\n\tif (db) fprintf(stderr, \"XCloseDisplay_wr: %p\\n\", (void *)display);\n#if NO_X11\n\treturn 0;\n#else\n\treturn XCloseDisplay(display);\n#endif\t/* NO_X11 */\n}"
        }
      },
      {
        "call_info": {
          "callee": "kill_helper_pid",
          "args": [],
          "line": 680
        },
        "resolved": true,
        "details": {
          "function_name": "kill_helper_pid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/appshare.c",
          "lines": "546-559",
          "snippet": "static void kill_helper_pid(void) {\n\tint status;\n\tif (helper_pid <= 0) {\n\t\treturn;\n\t}\n\tfprintf(stderr, \"stopping: helper_pid: %d\\n\", (int) helper_pid);\n\tkill(helper_pid, SIGTERM);\n\tusleep(50 * 1000);\n\tkill(helper_pid, SIGKILL);\n\tusleep(25 * 1000);\n#if LIBVNCSERVER_HAVE_SYS_WAIT_H && HAVE_WAITPID \n\twaitpid(helper_pid, &status, WNOHANG); \n#endif\n}",
          "includes": [
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"x11vnc.h\"\n\nstatic void kill_helper_pid(void) {\n\tint status;\n\tif (helper_pid <= 0) {\n\t\treturn;\n\t}\n\tfprintf(stderr, \"stopping: helper_pid: %d\\n\", (int) helper_pid);\n\tkill(helper_pid, SIGTERM);\n\tusleep(50 * 1000);\n\tkill(helper_pid, SIGKILL);\n\tusleep(25 * 1000);\n#if LIBVNCSERVER_HAVE_SYS_WAIT_H && HAVE_WAITPID \n\twaitpid(helper_pid, &status, WNOHANG); \n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "rmdir",
          "args": [
            "trackdir"
          ],
          "line": 674
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"removing: %s\\n\"",
            "trackdir"
          ],
          "line": 673
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "trackdir",
            "trackpre"
          ],
          "line": 672
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "closedir",
          "args": [
            "dir"
          ],
          "line": 669
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"keeping:  %s\\n\"",
            "name"
          ],
          "line": 666
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlink",
          "args": [
            "tracktmp"
          ],
          "line": 664
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "tracktmp",
            "\"%s/%s\"",
            "trackdir",
            "name"
          ],
          "line": 663
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"removing: %s\\n\"",
            "name"
          ],
          "line": 662
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"skipping: %s\\n\"",
            "name"
          ],
          "line": 658
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "name",
            "\"0x\""
          ],
          "line": 657
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "name",
            "\"..\""
          ],
          "line": 654
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "name",
            "\".\""
          ],
          "line": 654
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "readdir",
          "args": [
            "dir"
          ],
          "line": 652
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "opendir",
          "args": [
            "trackdir"
          ],
          "line": 649
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "stop",
          "args": [
            "watch[i]"
          ],
          "line": 644
        },
        "resolved": true,
        "details": {
          "function_name": "stop",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/appshare.c",
          "lines": "505-544",
          "snippet": "static void stop(Window win) {\n\tchar *cmd;\n\tint pid = -1;\n\tint f = find_win(win);\n\tif (f < 0 || win == None) {\n\t\treturn;\n\t}\n\tif (state[f] == 0) {\n\t\treturn;\n\t}\n\tif (trackdir) {\n\t\tpid = trackdir_pid(win);\n\t\tif (pid > 0) {\n\t\t\tif (appshare_debug) {fprintf(stderr,\n\t\t\t    \"sending SIGTERM to: %d\\n\", pid); ff();}\n\t\t\tkill((pid_t) pid, SIGTERM);\n\t\t}\n\t}\n\n\tcmd = (char *) malloc(1000 + strlen(x11vnc));\n\tsprintf(cmd, \"pkill -TERM -f '%s %s 0x%lx -bg'\", x11vnc, id_opt, win);\n\tif (appshare_debug) {\n\t\tfprintf(stdout, \"stopping:  0x%08lx - %s\\n\", win, cmd);\n\t} else {\n\t\tfprintf(stdout, \"stopping:  x11vnc for window 0x%08lx  \"\n\t\t    \"(pid: %d)\\n\", win, pid);\n\t}\n\tff();\n\tsystem(cmd);\n\n\tsprintf(cmd, \"(sleep 0.25 2>/dev/null || sleep 1; pkill -KILL -f '%s \"\n\t    \"%s 0x%lx -bg') &\", x11vnc, id_opt, win);\n\tsystem(cmd);\n\n\tif (trackdir) {\n\t\ttrackdir_cleanup(win);\n\t}\n\n\tfree(cmd);\n}",
          "includes": [
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "extern char *get_xprop(char *prop, Window win);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"x11vnc.h\"\n\nextern char *get_xprop(char *prop, Window win);\n\nstatic void stop(Window win) {\n\tchar *cmd;\n\tint pid = -1;\n\tint f = find_win(win);\n\tif (f < 0 || win == None) {\n\t\treturn;\n\t}\n\tif (state[f] == 0) {\n\t\treturn;\n\t}\n\tif (trackdir) {\n\t\tpid = trackdir_pid(win);\n\t\tif (pid > 0) {\n\t\t\tif (appshare_debug) {fprintf(stderr,\n\t\t\t    \"sending SIGTERM to: %d\\n\", pid); ff();}\n\t\t\tkill((pid_t) pid, SIGTERM);\n\t\t}\n\t}\n\n\tcmd = (char *) malloc(1000 + strlen(x11vnc));\n\tsprintf(cmd, \"pkill -TERM -f '%s %s 0x%lx -bg'\", x11vnc, id_opt, win);\n\tif (appshare_debug) {\n\t\tfprintf(stdout, \"stopping:  0x%08lx - %s\\n\", win, cmd);\n\t} else {\n\t\tfprintf(stdout, \"stopping:  x11vnc for window 0x%08lx  \"\n\t\t    \"(pid: %d)\\n\", win, pid);\n\t}\n\tff();\n\tsystem(cmd);\n\n\tsprintf(cmd, \"(sleep 0.25 2>/dev/null || sleep 1; pkill -KILL -f '%s \"\n\t    \"%s 0x%lx -bg') &\", x11vnc, id_opt, win);\n\tsystem(cmd);\n\n\tif (trackdir) {\n\t\ttrackdir_cleanup(win);\n\t}\n\n\tfree(cmd);\n}"
        }
      },
      {
        "call_info": {
          "callee": "system",
          "args": [
            "cmd"
          ],
          "line": 639
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"%s\\n\"",
            "cmd"
          ],
          "line": 638
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "cmd",
            "\"(sleep 3; pkill -TERM -f '%s') &\"",
            "unique_tag"
          ],
          "line": 637
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"x11vnc.h\"\n\n#define WMAX 192\n\nstatic void appshare_cleanup(int s) {\n\tint i;\n\tif (s) {}\n\n\tif (use_forever) {\n\t\t/* launch this backup in case they kill -9 us before we terminate everything */\n\t\tchar cmd[1000];\n\t\tsprintf(cmd, \"(sleep 3; pkill -TERM -f '%s') &\", unique_tag);\n\t\tif (appshare_debug) fprintf(stderr, \"%s\\n\", cmd);\n\t\tsystem(cmd);\n\t}\n\n\tfor (i=0; i < WMAX; i++) {\n\t\tif (watch[i] != None) {\n\t\t\tstop(watch[i]);\n\t\t}\n\t}\n\n\tif (trackdir) {\n\t\tDIR *dir = opendir(trackdir);\n\t\tif (dir) {\n\t\t\tstruct dirent *dp;\n\t\t\twhile ( (dp = readdir(dir)) != NULL) {\n\t\t\t\tchar *name = dp->d_name;\n\t\t\t\tif (!strcmp(name, \".\") || !strcmp(name, \"..\")) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (strstr(name, \"0x\") != name) {\n\t\t\t\t\tfprintf(stderr, \"skipping: %s\\n\", name);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (!appshare_debug) {\n\t\t\t\t\tfprintf(stderr, \"removing: %s\\n\", name);\n\t\t\t\t\tsprintf(tracktmp, \"%s/%s\", trackdir, name);\n\t\t\t\t\tunlink(tracktmp);\n\t\t\t\t} else {\n\t\t\t\t\tif (appshare_debug) fprintf(stderr, \"keeping:  %s\\n\", name);\n\t\t\t\t}\n\t\t\t}\n\t\t\tclosedir(dir);\n\t\t}\n\t\tif (!appshare_debug) {\n\t\t\tif (strstr(trackdir, trackpre) == trackdir) {\n\t\t\t\tif (appshare_debug) fprintf(stderr, \"removing: %s\\n\", trackdir);\n\t\t\t\trmdir(trackdir);\n\t\t\t}\n\t\t}\n\t\tff();\n\t}\n\n\tkill_helper_pid();\n\t\t\t\n#if !NO_X11\n\tXCloseDisplay(dpy);\n#endif\n\tfprintf(stdout, \"done.\\n\");\n\tff();\n\texit(0);\n}"
  },
  {
    "function_name": "print_logs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/appshare.c",
    "lines": "595-628",
    "snippet": "static void print_logs(void) {\n\tif (trackdir) {\n\t\tDIR *dir = opendir(trackdir);\n\t\tif (dir) {\n\t\t\tstruct dirent *dp;\n\t\t\twhile ( (dp = readdir(dir)) != NULL) {\n\t\t\t\tFILE *f;\n\t\t\t\tchar *name = dp->d_name;\n\t\t\t\tif (!strcmp(name, \".\") || !strcmp(name, \"..\")) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (strstr(name, \"0x\") != name) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (strstr(name, \".log\") == NULL) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tsprintf(tracktmp, \"%s/%s\", trackdir, name);\n\t\t\t\tf = fopen(tracktmp, \"r\");\n\t\t\t\tif (f) {\n\t\t\t\t\tchar line[1024];\n\t\t\t\t\tfprintf(stderr, \"===== x11vnc log %s =====\\n\", tracktmp);\n\t\t\t\t\twhile (fgets(line, sizeof(line), f) != NULL) {\n\t\t\t\t\t\tfprintf(stderr, \"%s\", line);\n\t\t\t\t\t}\n\t\t\t\t\tfprintf(stderr, \"\\n\");\n\t\t\t\t\tff();\n\t\t\t\t\tfclose(f);\n\t\t\t\t}\n\t\t\t}\n\t\t\tclosedir(dir);\n\t\t}\n\t}\n}",
    "includes": [
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "closedir",
          "args": [
            "dir"
          ],
          "line": 625
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fclose",
          "args": [
            "f"
          ],
          "line": 622
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ff",
          "args": [],
          "line": 621
        },
        "resolved": true,
        "details": {
          "function_name": "ff",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/appshare.c",
          "lines": "293-296",
          "snippet": "static void ff(void) {\n\tfflush(stdout);\n\tfflush(stderr);\n}",
          "includes": [
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"x11vnc.h\"\n\nstatic void ff(void) {\n\tfflush(stdout);\n\tfflush(stderr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"\\n\""
          ],
          "line": 620
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"%s\"",
            "line"
          ],
          "line": 618
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fgets",
          "args": [
            "line",
            "sizeof(line)",
            "f"
          ],
          "line": 617
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"===== x11vnc log %s =====\\n\"",
            "tracktmp"
          ],
          "line": 616
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fopen",
          "args": [
            "tracktmp",
            "\"r\""
          ],
          "line": 613
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "tracktmp",
            "\"%s/%s\"",
            "trackdir",
            "name"
          ],
          "line": 612
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "name",
            "\".log\""
          ],
          "line": 609
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "name",
            "\"0x\""
          ],
          "line": 606
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "name",
            "\"..\""
          ],
          "line": 603
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "name",
            "\".\""
          ],
          "line": 603
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "readdir",
          "args": [
            "dir"
          ],
          "line": 600
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "opendir",
          "args": [
            "trackdir"
          ],
          "line": 597
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"x11vnc.h\"\n\nstatic void print_logs(void) {\n\tif (trackdir) {\n\t\tDIR *dir = opendir(trackdir);\n\t\tif (dir) {\n\t\t\tstruct dirent *dp;\n\t\t\twhile ( (dp = readdir(dir)) != NULL) {\n\t\t\t\tFILE *f;\n\t\t\t\tchar *name = dp->d_name;\n\t\t\t\tif (!strcmp(name, \".\") || !strcmp(name, \"..\")) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (strstr(name, \"0x\") != name) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (strstr(name, \".log\") == NULL) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tsprintf(tracktmp, \"%s/%s\", trackdir, name);\n\t\t\t\tf = fopen(tracktmp, \"r\");\n\t\t\t\tif (f) {\n\t\t\t\t\tchar line[1024];\n\t\t\t\t\tfprintf(stderr, \"===== x11vnc log %s =====\\n\", tracktmp);\n\t\t\t\t\twhile (fgets(line, sizeof(line), f) != NULL) {\n\t\t\t\t\t\tfprintf(stderr, \"%s\", line);\n\t\t\t\t\t}\n\t\t\t\t\tfprintf(stderr, \"\\n\");\n\t\t\t\t\tff();\n\t\t\t\t\tfclose(f);\n\t\t\t\t}\n\t\t\t}\n\t\t\tclosedir(dir);\n\t\t}\n\t}\n}"
  },
  {
    "function_name": "be_helper_pid",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/appshare.c",
    "lines": "561-593",
    "snippet": "static void be_helper_pid(char *dpy_str) {\n\tint cnt = 0;\n\tint ms = (int) (1000 * helper_delay);\n\tdouble last_check = 0.0;\n\n\tif (ms < 50) ms = 50;\n\n#if NO_X11\n\tfprintf(stderr, \"be_helper_pid: not compiled with X11.\\n\");\n#else\n\tdpy = XOpenDisplay(dpy_str);\n\tticker_atom = XInternAtom(dpy, ticker_atom_str, False);\n\n\twhile (1) {\n\t\tchar tmp[32];\n\t\tsprintf(tmp, \"HELPER_CNT_%08d\", cnt++);\n\t\tXChangeProperty(dpy, DefaultRootWindow(dpy), ticker_atom, XA_STRING, 8,\n\t\t    PropModeReplace, (unsigned char *) tmp, strlen(tmp));\n\t\tXFlush(dpy);\n\t\tusleep(ms*1000);\n\t\tif (parent_pid > 0) {\n\t\t\tif(dnow() > last_check + 1.0) {\n\t\t\t\tlast_check = dnow();\n\t\t\t\tif (kill(parent_pid, 0) != 0) {\n\t\t\t\t\tfprintf(stderr, \"be_helper_pid: parent %d is gone.\\n\", (int) parent_pid);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n#endif\n\texit(0);\n}",
    "includes": [
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "extern double dnow(void);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "0"
          ],
          "line": 592
        },
        "resolved": true,
        "details": {
          "function_name": "clean_up_exit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/cleanup.c",
          "lines": "151-266",
          "snippet": "void clean_up_exit(int ret) {\n\tstatic int depth = 0;\n\texit_flag = 1;\n\n\tif (depth++ > 2) {\n\t\texit(ret);\n\t}\n\n\tif (icon_mode) {\n\t\tclean_icon_mode();\n\t}\n\n\t/* remove the shm areas: */\n\tclean_shm(0);\n\n\tstop_stunnel();\n\tif (use_openssl) {\n\t\tssl_helper_pid(0, 0);\t/* killall */\n\t}\n\n\tif (ssh_pid > 0) {\n\t\tkill(ssh_pid, SIGTERM);\n\t\tssh_pid = 0;\n\t}\n\n#ifdef MACOSX\n\tif (client_connect_file) {\n\t\tif (strstr(client_connect_file, \"/tmp/x11vnc-macosx-remote\")\n\t\t    == client_connect_file) {\n\t\t\tunlink(client_connect_file);\n\t\t}\n\t}\n\tif (macosx_console) {\n\t\tmacosxCG_fini();\n\t}\n#endif\n\n\tif (pipeinput_fh != NULL) {\n\t\tpclose(pipeinput_fh);\n\t\tpipeinput_fh = NULL;\n\t}\n\n\tshutdown_uinput();\n\n\tif (unix_sock) {\n\t\tif (unix_sock_fd >= 0) {\n\t\t\trfbLog(\"deleting unix sock: %s\\n\", unix_sock);\n\t\t\tclose(unix_sock_fd);\n\t\t\tunix_sock_fd = -1;\n\t\t\tunlink(unix_sock);\n\t\t}\n\t}\n\n\tif (! dpy) {\t/* raw_rb hack */\n\t\tif (rm_flagfile) {\n\t\t\tunlink(rm_flagfile);\n\t\t\trm_flagfile = NULL;\n\t\t}\n\t\texit(ret);\n\t}\n\n\t/* X keyboard cleanups */\n\tdelete_added_keycodes(0);\n\n\t/* remove all created XInput2 devices */\n\tif(use_multipointer)\n\t    removeAllMDs(dpy);\n\n\tif (clear_mods == 1) {\n\t\tclear_modifiers(0);\n\t} else if (clear_mods == 2) {\n\t\tclear_keys();\n\t} else if (clear_mods == 3) {\n\t\tclear_keys();\n\t\tclear_locks();\n\t}\n\n\tif (no_autorepeat) {\n\t\tautorepeat(1, 0);\n\t}\n\tif (use_solid_bg) {\n\t\tsolid_bg(1);\n\t}\n\tif (ncache || ncache0) {\n\t\tkde_no_animate(1);\n\t}\n\tX_LOCK;\n\tXTestDiscard_wr(dpy);\n#if HAVE_LIBXDAMAGE\n\tif (xdamage) {\n\t\tXDamageDestroy(dpy, xdamage);\n\t}\n#endif\n#if HAVE_LIBXTRAP\n\tif (trap_ctx) {\n\t\tXEFreeTC(trap_ctx);\n\t}\n#endif\n\t/* XXX rdpy_ctrl, etc. cannot close w/o blocking */\n\tXCloseDisplay_wr(dpy);\n\tX_UNLOCK;\n\n\tfflush(stderr);\n\n\tif (rm_flagfile) {\n\t\tunlink(rm_flagfile);\n\t\trm_flagfile = NULL;\n\t}\n\n\tif (avahi) {\n\t\tavahi_cleanup();\n\t\tfflush(stderr);\n\t}\n\n\texit(ret);\n}",
          "includes": [
            "#include \"xi2_devices.h\"",
            "#include \"uinput.h\"",
            "#include \"xevents.h\"",
            "#include \"xrecord.h\"",
            "#include \"screen.h\"",
            "#include \"avahi.h\"",
            "#include \"macosxCG.h\"",
            "#include \"macosx.h\"",
            "#include \"connections.h\"",
            "#include \"sslhelper.h\"",
            "#include \"sslcmds.h\"",
            "#include \"unixpw.h\"",
            "#include \"solid.h\"",
            "#include \"gui.h\"",
            "#include \"scan.h\"",
            "#include \"keyboard.h\"",
            "#include \"remote.h\"",
            "#include \"xdamage.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void clean_up_exit(int ret);",
            "int known_sigpipe_mode(char *s);",
            "static int exit_flag = 0;",
            "static void clean_icon_mode(void);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xi2_devices.h\"\n#include \"uinput.h\"\n#include \"xevents.h\"\n#include \"xrecord.h\"\n#include \"screen.h\"\n#include \"avahi.h\"\n#include \"macosxCG.h\"\n#include \"macosx.h\"\n#include \"connections.h\"\n#include \"sslhelper.h\"\n#include \"sslcmds.h\"\n#include \"unixpw.h\"\n#include \"solid.h\"\n#include \"gui.h\"\n#include \"scan.h\"\n#include \"keyboard.h\"\n#include \"remote.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nvoid clean_up_exit(int ret);\nint known_sigpipe_mode(char *s);\nstatic int exit_flag = 0;\nstatic void clean_icon_mode(void);\n\nvoid clean_up_exit(int ret) {\n\tstatic int depth = 0;\n\texit_flag = 1;\n\n\tif (depth++ > 2) {\n\t\texit(ret);\n\t}\n\n\tif (icon_mode) {\n\t\tclean_icon_mode();\n\t}\n\n\t/* remove the shm areas: */\n\tclean_shm(0);\n\n\tstop_stunnel();\n\tif (use_openssl) {\n\t\tssl_helper_pid(0, 0);\t/* killall */\n\t}\n\n\tif (ssh_pid > 0) {\n\t\tkill(ssh_pid, SIGTERM);\n\t\tssh_pid = 0;\n\t}\n\n#ifdef MACOSX\n\tif (client_connect_file) {\n\t\tif (strstr(client_connect_file, \"/tmp/x11vnc-macosx-remote\")\n\t\t    == client_connect_file) {\n\t\t\tunlink(client_connect_file);\n\t\t}\n\t}\n\tif (macosx_console) {\n\t\tmacosxCG_fini();\n\t}\n#endif\n\n\tif (pipeinput_fh != NULL) {\n\t\tpclose(pipeinput_fh);\n\t\tpipeinput_fh = NULL;\n\t}\n\n\tshutdown_uinput();\n\n\tif (unix_sock) {\n\t\tif (unix_sock_fd >= 0) {\n\t\t\trfbLog(\"deleting unix sock: %s\\n\", unix_sock);\n\t\t\tclose(unix_sock_fd);\n\t\t\tunix_sock_fd = -1;\n\t\t\tunlink(unix_sock);\n\t\t}\n\t}\n\n\tif (! dpy) {\t/* raw_rb hack */\n\t\tif (rm_flagfile) {\n\t\t\tunlink(rm_flagfile);\n\t\t\trm_flagfile = NULL;\n\t\t}\n\t\texit(ret);\n\t}\n\n\t/* X keyboard cleanups */\n\tdelete_added_keycodes(0);\n\n\t/* remove all created XInput2 devices */\n\tif(use_multipointer)\n\t    removeAllMDs(dpy);\n\n\tif (clear_mods == 1) {\n\t\tclear_modifiers(0);\n\t} else if (clear_mods == 2) {\n\t\tclear_keys();\n\t} else if (clear_mods == 3) {\n\t\tclear_keys();\n\t\tclear_locks();\n\t}\n\n\tif (no_autorepeat) {\n\t\tautorepeat(1, 0);\n\t}\n\tif (use_solid_bg) {\n\t\tsolid_bg(1);\n\t}\n\tif (ncache || ncache0) {\n\t\tkde_no_animate(1);\n\t}\n\tX_LOCK;\n\tXTestDiscard_wr(dpy);\n#if HAVE_LIBXDAMAGE\n\tif (xdamage) {\n\t\tXDamageDestroy(dpy, xdamage);\n\t}\n#endif\n#if HAVE_LIBXTRAP\n\tif (trap_ctx) {\n\t\tXEFreeTC(trap_ctx);\n\t}\n#endif\n\t/* XXX rdpy_ctrl, etc. cannot close w/o blocking */\n\tXCloseDisplay_wr(dpy);\n\tX_UNLOCK;\n\n\tfflush(stderr);\n\n\tif (rm_flagfile) {\n\t\tunlink(rm_flagfile);\n\t\trm_flagfile = NULL;\n\t}\n\n\tif (avahi) {\n\t\tavahi_cleanup();\n\t\tfflush(stderr);\n\t}\n\n\texit(ret);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"be_helper_pid: parent %d is gone.\\n\"",
            "(int) parent_pid"
          ],
          "line": 585
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kill",
          "args": [
            "parent_pid",
            "0"
          ],
          "line": 584
        },
        "resolved": true,
        "details": {
          "function_name": "kill_child",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/unixpw.c",
          "lines": "674-684",
          "snippet": "static void kill_child (pid_t pid, int fd) {\n\tint status;\n\n\tslave_fd = -1;\n\talarm_fired = 0;\n\tif (fd >= 0) {\n\t\tclose(fd);\n\t}\n\tkill(pid, SIGTERM);\n\twaitpid(pid, &status, WNOHANG); \n}",
          "includes": [
            "#include <sys/stropts.h>",
            "#include <termios.h>",
            "#include <sys/ioctl.h>",
            "#include <shadow.h>",
            "#include \"default8x16.h\"",
            "#include \"rates.h\"",
            "#include \"cursor.h\"",
            "#include \"sslhelper.h\"",
            "#include \"connections.h\"",
            "#include \"user.h\"",
            "#include \"connections.h\"",
            "#include \"xinerama.h\"",
            "#include \"cleanup.h\"",
            "#include \"scan.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int slave_fd = -1, alarm_fired = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/stropts.h>\n#include <termios.h>\n#include <sys/ioctl.h>\n#include <shadow.h>\n#include \"default8x16.h\"\n#include \"rates.h\"\n#include \"cursor.h\"\n#include \"sslhelper.h\"\n#include \"connections.h\"\n#include \"user.h\"\n#include \"connections.h\"\n#include \"xinerama.h\"\n#include \"cleanup.h\"\n#include \"scan.h\"\n#include \"x11vnc.h\"\n\nstatic int slave_fd = -1, alarm_fired = 0;\n\nstatic void kill_child (pid_t pid, int fd) {\n\tint status;\n\n\tslave_fd = -1;\n\talarm_fired = 0;\n\tif (fd >= 0) {\n\t\tclose(fd);\n\t}\n\tkill(pid, SIGTERM);\n\twaitpid(pid, &status, WNOHANG); \n}"
        }
      },
      {
        "call_info": {
          "callee": "dnow",
          "args": [],
          "line": 583
        },
        "resolved": true,
        "details": {
          "function_name": "dnowx",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/util.c",
          "lines": "439-441",
          "snippet": "double dnowx(void) {\n\treturn dnow() - x11vnc_start;\n}",
          "includes": [
            "#include \"connections.h\"",
            "#include \"unixpw.h\"",
            "#include \"win_utils.h\"",
            "#include \"cleanup.h\"",
            "#include \"x11vnc.h\"",
            "#include <stdlib.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "double dnow(void);",
            "double dnowx(void);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"connections.h\"\n#include \"unixpw.h\"\n#include \"win_utils.h\"\n#include \"cleanup.h\"\n#include \"x11vnc.h\"\n#include <stdlib.h>\n\ndouble dnow(void);\ndouble dnowx(void);\n\ndouble dnowx(void) {\n\treturn dnow() - x11vnc_start;\n}"
        }
      },
      {
        "call_info": {
          "callee": "usleep",
          "args": [
            "ms*1000"
          ],
          "line": 580
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFlush",
          "args": [
            "dpy"
          ],
          "line": 579
        },
        "resolved": true,
        "details": {
          "function_name": "XFlush_wr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/xwrappers.c",
          "lines": "154-165",
          "snippet": "int XFlush_wr(Display *disp) {\n#if NO_X11\n\tif (!disp) {}\n\treturn 1;\n#else\n\tif (disp) {\n\t\treturn XFlush(disp);\n\t} else {\n\t\treturn 1;\n\t}\n#endif\t/* NO_X11 */\n}",
          "includes": [
            "#include \"nox11_funcs.h\"",
            "#include \"xwrappers.h\"",
            "#include \"xi2_devices.h\"",
            "#include \"macosx.h\"",
            "#include \"cleanup.h\"",
            "#include \"connections.h\"",
            "#include \"xevents.h\"",
            "#include \"keyboard.h\"",
            "#include \"xrecord.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int XFlush_wr(Display *disp);",
            "Bool XShmQueryExtension_wr(Display *disp);",
            "int XShmGetEventBase_wr(Display *disp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"nox11_funcs.h\"\n#include \"xwrappers.h\"\n#include \"xi2_devices.h\"\n#include \"macosx.h\"\n#include \"cleanup.h\"\n#include \"connections.h\"\n#include \"xevents.h\"\n#include \"keyboard.h\"\n#include \"xrecord.h\"\n#include \"x11vnc.h\"\n\nint XFlush_wr(Display *disp);\nBool XShmQueryExtension_wr(Display *disp);\nint XShmGetEventBase_wr(Display *disp);\n\nint XFlush_wr(Display *disp) {\n#if NO_X11\n\tif (!disp) {}\n\treturn 1;\n#else\n\tif (disp) {\n\t\treturn XFlush(disp);\n\t} else {\n\t\treturn 1;\n\t}\n#endif\t/* NO_X11 */\n}"
        }
      },
      {
        "call_info": {
          "callee": "XChangeProperty",
          "args": [
            "dpy",
            "DefaultRootWindow(dpy)",
            "ticker_atom",
            "XA_STRING",
            "8",
            "PropModeReplace",
            "(unsigned char *) tmp",
            "strlen(tmp)"
          ],
          "line": 577
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "tmp"
          ],
          "line": 578
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DefaultRootWindow",
          "args": [
            "dpy"
          ],
          "line": 577
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "tmp",
            "\"HELPER_CNT_%08d\"",
            "cnt++"
          ],
          "line": 576
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XInternAtom",
          "args": [
            "dpy",
            "ticker_atom_str",
            "False"
          ],
          "line": 572
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XOpenDisplay",
          "args": [
            "dpy_str"
          ],
          "line": 571
        },
        "resolved": true,
        "details": {
          "function_name": "XOpenDisplay_wr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/xwrappers.c",
          "lines": "1461-1502",
          "snippet": "Display *XOpenDisplay_wr(char *display_name) {\n\tDisplay *d = NULL;\n\tint db = 0;\n\n\tif (! xauth_raw(1)) {\n\t\treturn NULL;\n\t}\n#if NO_X11\n\trfbLog(\"This x11vnc was built without X11 support (-rawfb only).\\n\");\n\tif (!display_name || !d || !db) {}\n\treturn NULL;\n#else\n\n\td = XOpenDisplay(display_name);\n\tif (db) fprintf(stderr, \"XOpenDisplay_wr: %s  %p\\n\", display_name, (void *)d);\n\n\tif (d == NULL && !getenv(\"NO_XAUTHLOCALHOSTNAME\")) {\n\t\tchar *xalhn = getenv(\"XAUTHLOCALHOSTNAME\");\n\t\tif (1 || !xalhn) {\n\t\t\trfbLog(\"XOpenDisplay(\\\"%s\\\") failed.\\n\",\n\t\t\t    display_name ? display_name : \"\");\n\t\t\trfbLog(\"Trying again with XAUTHLOCALHOSTNAME=localhost ...\\n\");\n\t\t\tset_env(\"XAUTHLOCALHOSTNAME\", \"localhost\");\n\t\t\td = XOpenDisplay(display_name);\n\t\t\tif (d == NULL && xalhn) {\n\t\t\t\tchar *ptr = getenv(\"XAUTHLOCALHOSTNAME\");\n\t\t\t\tif (ptr) {\n\t\t\t\t\t*(ptr-2) = '_';\t/* yow */\n\t\t\t\t\trfbLog(\"XOpenDisplay(\\\"%s\\\") failed.\\n\",\n\t\t\t\t\t    display_name ? display_name : \"\");\n\t\t\t\t\trfbLog(\"Trying again with unset XAUTHLOCALHOSTNAME ...\\n\");\n\t\t\t\t\td = XOpenDisplay(display_name);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\txauth_raw(0);\n\n\treturn d;\n#endif\t/* NO_X11 */\n}",
          "includes": [
            "#include \"nox11_funcs.h\"",
            "#include \"xwrappers.h\"",
            "#include \"xi2_devices.h\"",
            "#include \"macosx.h\"",
            "#include \"cleanup.h\"",
            "#include \"connections.h\"",
            "#include \"xevents.h\"",
            "#include \"keyboard.h\"",
            "#include \"xrecord.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "Display *XOpenDisplay_wr(char *display_name);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"nox11_funcs.h\"\n#include \"xwrappers.h\"\n#include \"xi2_devices.h\"\n#include \"macosx.h\"\n#include \"cleanup.h\"\n#include \"connections.h\"\n#include \"xevents.h\"\n#include \"keyboard.h\"\n#include \"xrecord.h\"\n#include \"x11vnc.h\"\n\nDisplay *XOpenDisplay_wr(char *display_name);\n\nDisplay *XOpenDisplay_wr(char *display_name) {\n\tDisplay *d = NULL;\n\tint db = 0;\n\n\tif (! xauth_raw(1)) {\n\t\treturn NULL;\n\t}\n#if NO_X11\n\trfbLog(\"This x11vnc was built without X11 support (-rawfb only).\\n\");\n\tif (!display_name || !d || !db) {}\n\treturn NULL;\n#else\n\n\td = XOpenDisplay(display_name);\n\tif (db) fprintf(stderr, \"XOpenDisplay_wr: %s  %p\\n\", display_name, (void *)d);\n\n\tif (d == NULL && !getenv(\"NO_XAUTHLOCALHOSTNAME\")) {\n\t\tchar *xalhn = getenv(\"XAUTHLOCALHOSTNAME\");\n\t\tif (1 || !xalhn) {\n\t\t\trfbLog(\"XOpenDisplay(\\\"%s\\\") failed.\\n\",\n\t\t\t    display_name ? display_name : \"\");\n\t\t\trfbLog(\"Trying again with XAUTHLOCALHOSTNAME=localhost ...\\n\");\n\t\t\tset_env(\"XAUTHLOCALHOSTNAME\", \"localhost\");\n\t\t\td = XOpenDisplay(display_name);\n\t\t\tif (d == NULL && xalhn) {\n\t\t\t\tchar *ptr = getenv(\"XAUTHLOCALHOSTNAME\");\n\t\t\t\tif (ptr) {\n\t\t\t\t\t*(ptr-2) = '_';\t/* yow */\n\t\t\t\t\trfbLog(\"XOpenDisplay(\\\"%s\\\") failed.\\n\",\n\t\t\t\t\t    display_name ? display_name : \"\");\n\t\t\t\t\trfbLog(\"Trying again with unset XAUTHLOCALHOSTNAME ...\\n\");\n\t\t\t\t\td = XOpenDisplay(display_name);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\txauth_raw(0);\n\n\treturn d;\n#endif\t/* NO_X11 */\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"be_helper_pid: not compiled with X11.\\n\""
          ],
          "line": 569
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"x11vnc.h\"\n\nextern double dnow(void);\n\nstatic void be_helper_pid(char *dpy_str) {\n\tint cnt = 0;\n\tint ms = (int) (1000 * helper_delay);\n\tdouble last_check = 0.0;\n\n\tif (ms < 50) ms = 50;\n\n#if NO_X11\n\tfprintf(stderr, \"be_helper_pid: not compiled with X11.\\n\");\n#else\n\tdpy = XOpenDisplay(dpy_str);\n\tticker_atom = XInternAtom(dpy, ticker_atom_str, False);\n\n\twhile (1) {\n\t\tchar tmp[32];\n\t\tsprintf(tmp, \"HELPER_CNT_%08d\", cnt++);\n\t\tXChangeProperty(dpy, DefaultRootWindow(dpy), ticker_atom, XA_STRING, 8,\n\t\t    PropModeReplace, (unsigned char *) tmp, strlen(tmp));\n\t\tXFlush(dpy);\n\t\tusleep(ms*1000);\n\t\tif (parent_pid > 0) {\n\t\t\tif(dnow() > last_check + 1.0) {\n\t\t\t\tlast_check = dnow();\n\t\t\t\tif (kill(parent_pid, 0) != 0) {\n\t\t\t\t\tfprintf(stderr, \"be_helper_pid: parent %d is gone.\\n\", (int) parent_pid);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n#endif\n\texit(0);\n}"
  },
  {
    "function_name": "kill_helper_pid",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/appshare.c",
    "lines": "546-559",
    "snippet": "static void kill_helper_pid(void) {\n\tint status;\n\tif (helper_pid <= 0) {\n\t\treturn;\n\t}\n\tfprintf(stderr, \"stopping: helper_pid: %d\\n\", (int) helper_pid);\n\tkill(helper_pid, SIGTERM);\n\tusleep(50 * 1000);\n\tkill(helper_pid, SIGKILL);\n\tusleep(25 * 1000);\n#if LIBVNCSERVER_HAVE_SYS_WAIT_H && HAVE_WAITPID \n\twaitpid(helper_pid, &status, WNOHANG); \n#endif\n}",
    "includes": [
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "waitpid",
          "args": [
            "helper_pid",
            "&status",
            "WNOHANG"
          ],
          "line": 557
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "usleep",
          "args": [
            "25 * 1000"
          ],
          "line": 555
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kill",
          "args": [
            "helper_pid",
            "SIGKILL"
          ],
          "line": 554
        },
        "resolved": true,
        "details": {
          "function_name": "kill_child",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/unixpw.c",
          "lines": "674-684",
          "snippet": "static void kill_child (pid_t pid, int fd) {\n\tint status;\n\n\tslave_fd = -1;\n\talarm_fired = 0;\n\tif (fd >= 0) {\n\t\tclose(fd);\n\t}\n\tkill(pid, SIGTERM);\n\twaitpid(pid, &status, WNOHANG); \n}",
          "includes": [
            "#include <sys/stropts.h>",
            "#include <termios.h>",
            "#include <sys/ioctl.h>",
            "#include <shadow.h>",
            "#include \"default8x16.h\"",
            "#include \"rates.h\"",
            "#include \"cursor.h\"",
            "#include \"sslhelper.h\"",
            "#include \"connections.h\"",
            "#include \"user.h\"",
            "#include \"connections.h\"",
            "#include \"xinerama.h\"",
            "#include \"cleanup.h\"",
            "#include \"scan.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int slave_fd = -1, alarm_fired = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/stropts.h>\n#include <termios.h>\n#include <sys/ioctl.h>\n#include <shadow.h>\n#include \"default8x16.h\"\n#include \"rates.h\"\n#include \"cursor.h\"\n#include \"sslhelper.h\"\n#include \"connections.h\"\n#include \"user.h\"\n#include \"connections.h\"\n#include \"xinerama.h\"\n#include \"cleanup.h\"\n#include \"scan.h\"\n#include \"x11vnc.h\"\n\nstatic int slave_fd = -1, alarm_fired = 0;\n\nstatic void kill_child (pid_t pid, int fd) {\n\tint status;\n\n\tslave_fd = -1;\n\talarm_fired = 0;\n\tif (fd >= 0) {\n\t\tclose(fd);\n\t}\n\tkill(pid, SIGTERM);\n\twaitpid(pid, &status, WNOHANG); \n}"
        }
      },
      {
        "call_info": {
          "callee": "usleep",
          "args": [
            "50 * 1000"
          ],
          "line": 553
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"stopping: helper_pid: %d\\n\"",
            "(int) helper_pid"
          ],
          "line": 551
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"x11vnc.h\"\n\nstatic void kill_helper_pid(void) {\n\tint status;\n\tif (helper_pid <= 0) {\n\t\treturn;\n\t}\n\tfprintf(stderr, \"stopping: helper_pid: %d\\n\", (int) helper_pid);\n\tkill(helper_pid, SIGTERM);\n\tusleep(50 * 1000);\n\tkill(helper_pid, SIGKILL);\n\tusleep(25 * 1000);\n#if LIBVNCSERVER_HAVE_SYS_WAIT_H && HAVE_WAITPID \n\twaitpid(helper_pid, &status, WNOHANG); \n#endif\n}"
  },
  {
    "function_name": "stop",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/appshare.c",
    "lines": "505-544",
    "snippet": "static void stop(Window win) {\n\tchar *cmd;\n\tint pid = -1;\n\tint f = find_win(win);\n\tif (f < 0 || win == None) {\n\t\treturn;\n\t}\n\tif (state[f] == 0) {\n\t\treturn;\n\t}\n\tif (trackdir) {\n\t\tpid = trackdir_pid(win);\n\t\tif (pid > 0) {\n\t\t\tif (appshare_debug) {fprintf(stderr,\n\t\t\t    \"sending SIGTERM to: %d\\n\", pid); ff();}\n\t\t\tkill((pid_t) pid, SIGTERM);\n\t\t}\n\t}\n\n\tcmd = (char *) malloc(1000 + strlen(x11vnc));\n\tsprintf(cmd, \"pkill -TERM -f '%s %s 0x%lx -bg'\", x11vnc, id_opt, win);\n\tif (appshare_debug) {\n\t\tfprintf(stdout, \"stopping:  0x%08lx - %s\\n\", win, cmd);\n\t} else {\n\t\tfprintf(stdout, \"stopping:  x11vnc for window 0x%08lx  \"\n\t\t    \"(pid: %d)\\n\", win, pid);\n\t}\n\tff();\n\tsystem(cmd);\n\n\tsprintf(cmd, \"(sleep 0.25 2>/dev/null || sleep 1; pkill -KILL -f '%s \"\n\t    \"%s 0x%lx -bg') &\", x11vnc, id_opt, win);\n\tsystem(cmd);\n\n\tif (trackdir) {\n\t\ttrackdir_cleanup(win);\n\t}\n\n\tfree(cmd);\n}",
    "includes": [
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "extern char *get_xprop(char *prop, Window win);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "cmd"
          ],
          "line": 543
        },
        "resolved": true,
        "details": {
          "function_name": "free_rect",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/userinput.c",
          "lines": "6200-6247",
          "snippet": "int free_rect(int idx) {\n\tint n, ok = 0;\n\tsraRegionPtr r1, r2;\n\tint x, y, w, h;\n\n\tif (idx < 0 || idx >= cache_list_num) {\nif (0) fprintf(stderr, \"free_rect: bad index: %d\\n\", idx);\n\t\tclean_up_exit(1);\n\t}\n\n\tx = cache_list[idx].bs_x;\n\ty = cache_list[idx].bs_y;\n\tw = cache_list[idx].bs_w;\n\th = cache_list[idx].bs_h;\n\n\tif (x < 0) {\n\t\tCLEAR(idx);\nif (dnow() > last_client + 5 && ncdb) fprintf(stderr, \"free_rect: already bs_x invalidated: %d bs_x: %d\\n\", idx, x);\n\t\treturn 1;\n\t}\n\n\tr2 = sraRgnCreateRect(x, y, x+w, y+h);\n\n\tn = get_bs_n(y);\n\tif (n >= 0) {\n\t\tr1 = rect_reg[n];\n\t\tsraRgnOr(r1, r2);\n\t\tok = 1;\n\t}\n\n\tif (zero_rects) {\n\t\tsraRgnOr(zero_rects, r2);\n\t\tx = cache_list[idx].su_x;\n\t\ty = cache_list[idx].su_y;\n\t\tw = cache_list[idx].su_w;\n\t\th = cache_list[idx].su_h;\n\t\tif (x >= 0) {\n\t\t\tsraRgnDestroy(r2);\n\t\t\tr2 = sraRgnCreateRect(x, y, x+w, y+h);\n\t\t\tsraRgnOr(zero_rects, r2);\n\t\t}\n\t}\n\tsraRgnDestroy(r2);\n\n\tCLEAR(idx);\nif (! ok && ncdb) fprintf(stderr, \"**** free_rect: not-found %d\\n\", idx);\n\treturn ok;\n}",
          "includes": [
            "#include \"default8x16.h\"",
            "#include \"connections.h\"",
            "#include \"screen.h\"",
            "#include \"cursor.h\"",
            "#include \"macosxCGS.h\"",
            "#include \"macosx.h\"",
            "#include \"unixpw.h\"",
            "#include \"8to24.h\"",
            "#include \"xrandr.h\"",
            "#include \"solid.h\"",
            "#include \"keyboard.h\"",
            "#include \"rates.h\"",
            "#include \"pointer.h\"",
            "#include \"cleanup.h\"",
            "#include \"scan.h\"",
            "#include \"user.h\"",
            "#include \"xevents.h\"",
            "#include \"win_utils.h\"",
            "#include \"xinerama.h\"",
            "#include \"xrecord.h\"",
            "#include \"xdamage.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void mark_for_xdamage(int x, int y, int w, int h);",
            "void set_xdamage_mark(int x, int y, int w, int h);",
            "int find_rect(int idx, int x, int y, int w, int h);",
            "winattr_t *cache_list;",
            "int clipped(int idx);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"default8x16.h\"\n#include \"connections.h\"\n#include \"screen.h\"\n#include \"cursor.h\"\n#include \"macosxCGS.h\"\n#include \"macosx.h\"\n#include \"unixpw.h\"\n#include \"8to24.h\"\n#include \"xrandr.h\"\n#include \"solid.h\"\n#include \"keyboard.h\"\n#include \"rates.h\"\n#include \"pointer.h\"\n#include \"cleanup.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"xevents.h\"\n#include \"win_utils.h\"\n#include \"xinerama.h\"\n#include \"xrecord.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nvoid mark_for_xdamage(int x, int y, int w, int h);\nvoid set_xdamage_mark(int x, int y, int w, int h);\nint find_rect(int idx, int x, int y, int w, int h);\nwinattr_t *cache_list;\nint clipped(int idx);\n\nint free_rect(int idx) {\n\tint n, ok = 0;\n\tsraRegionPtr r1, r2;\n\tint x, y, w, h;\n\n\tif (idx < 0 || idx >= cache_list_num) {\nif (0) fprintf(stderr, \"free_rect: bad index: %d\\n\", idx);\n\t\tclean_up_exit(1);\n\t}\n\n\tx = cache_list[idx].bs_x;\n\ty = cache_list[idx].bs_y;\n\tw = cache_list[idx].bs_w;\n\th = cache_list[idx].bs_h;\n\n\tif (x < 0) {\n\t\tCLEAR(idx);\nif (dnow() > last_client + 5 && ncdb) fprintf(stderr, \"free_rect: already bs_x invalidated: %d bs_x: %d\\n\", idx, x);\n\t\treturn 1;\n\t}\n\n\tr2 = sraRgnCreateRect(x, y, x+w, y+h);\n\n\tn = get_bs_n(y);\n\tif (n >= 0) {\n\t\tr1 = rect_reg[n];\n\t\tsraRgnOr(r1, r2);\n\t\tok = 1;\n\t}\n\n\tif (zero_rects) {\n\t\tsraRgnOr(zero_rects, r2);\n\t\tx = cache_list[idx].su_x;\n\t\ty = cache_list[idx].su_y;\n\t\tw = cache_list[idx].su_w;\n\t\th = cache_list[idx].su_h;\n\t\tif (x >= 0) {\n\t\t\tsraRgnDestroy(r2);\n\t\t\tr2 = sraRgnCreateRect(x, y, x+w, y+h);\n\t\t\tsraRgnOr(zero_rects, r2);\n\t\t}\n\t}\n\tsraRgnDestroy(r2);\n\n\tCLEAR(idx);\nif (! ok && ncdb) fprintf(stderr, \"**** free_rect: not-found %d\\n\", idx);\n\treturn ok;\n}"
        }
      },
      {
        "call_info": {
          "callee": "trackdir_cleanup",
          "args": [
            "win"
          ],
          "line": 540
        },
        "resolved": true,
        "details": {
          "function_name": "trackdir_cleanup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/appshare.c",
          "lines": "371-391",
          "snippet": "static void trackdir_cleanup(Window win) {\n\tchar *suffix[] = {\"log\", \"connect\", NULL};\n\tint i=0;\n\tif (!trackdir) {\n\t\treturn;\n\t}\n\twhile (suffix[i] != NULL) {\n\t\tsprintf(tracktmp, \"%s/0x%lx.%s\", trackdir, win, suffix[i]);\n\t\tif (appshare_debug && !strcmp(suffix[i], \"log\")) {\n\t\t\tfprintf(stderr, \"keeping:  %s\\n\", tracktmp);\n\t\t\tff();\n\t\t} else {\n\t\t\tif (appshare_debug) {\n\t\t\t\tfprintf(stderr, \"removing: %s\\n\", tracktmp);\n\t\t\t\tff();\n\t\t\t}\n\t\t\tunlink(tracktmp);\n\t\t}\n\t\ti++;\n\t}\n}",
          "includes": [
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "extern char *get_xprop(char *prop, Window win);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"x11vnc.h\"\n\nextern char *get_xprop(char *prop, Window win);\n\nstatic void trackdir_cleanup(Window win) {\n\tchar *suffix[] = {\"log\", \"connect\", NULL};\n\tint i=0;\n\tif (!trackdir) {\n\t\treturn;\n\t}\n\twhile (suffix[i] != NULL) {\n\t\tsprintf(tracktmp, \"%s/0x%lx.%s\", trackdir, win, suffix[i]);\n\t\tif (appshare_debug && !strcmp(suffix[i], \"log\")) {\n\t\t\tfprintf(stderr, \"keeping:  %s\\n\", tracktmp);\n\t\t\tff();\n\t\t} else {\n\t\t\tif (appshare_debug) {\n\t\t\t\tfprintf(stderr, \"removing: %s\\n\", tracktmp);\n\t\t\t\tff();\n\t\t\t}\n\t\t\tunlink(tracktmp);\n\t\t}\n\t\ti++;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "system",
          "args": [
            "cmd"
          ],
          "line": 537
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "cmd",
            "\"(sleep 0.25 2>/dev/null || sleep 1; pkill -KILL -f '%s \"\n\t    \"%s 0x%lx -bg') &\"",
            "x11vnc",
            "id_opt",
            "win"
          ],
          "line": 535
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "system",
          "args": [
            "cmd"
          ],
          "line": 533
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ff",
          "args": [],
          "line": 532
        },
        "resolved": true,
        "details": {
          "function_name": "ff",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/appshare.c",
          "lines": "293-296",
          "snippet": "static void ff(void) {\n\tfflush(stdout);\n\tfflush(stderr);\n}",
          "includes": [
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"x11vnc.h\"\n\nstatic void ff(void) {\n\tfflush(stdout);\n\tfflush(stderr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stdout",
            "\"stopping:  x11vnc for window 0x%08lx  \"\n\t\t    \"(pid: %d)\\n\"",
            "win",
            "pid"
          ],
          "line": 529
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stdout",
            "\"stopping:  0x%08lx - %s\\n\"",
            "win",
            "cmd"
          ],
          "line": 527
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "cmd",
            "\"pkill -TERM -f '%s %s 0x%lx -bg'\"",
            "x11vnc",
            "id_opt",
            "win"
          ],
          "line": 525
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "1000 + strlen(x11vnc)"
          ],
          "line": 524
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "x11vnc"
          ],
          "line": 524
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kill",
          "args": [
            "(pid_t) pid",
            "SIGTERM"
          ],
          "line": 520
        },
        "resolved": true,
        "details": {
          "function_name": "kill_child",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/unixpw.c",
          "lines": "674-684",
          "snippet": "static void kill_child (pid_t pid, int fd) {\n\tint status;\n\n\tslave_fd = -1;\n\talarm_fired = 0;\n\tif (fd >= 0) {\n\t\tclose(fd);\n\t}\n\tkill(pid, SIGTERM);\n\twaitpid(pid, &status, WNOHANG); \n}",
          "includes": [
            "#include <sys/stropts.h>",
            "#include <termios.h>",
            "#include <sys/ioctl.h>",
            "#include <shadow.h>",
            "#include \"default8x16.h\"",
            "#include \"rates.h\"",
            "#include \"cursor.h\"",
            "#include \"sslhelper.h\"",
            "#include \"connections.h\"",
            "#include \"user.h\"",
            "#include \"connections.h\"",
            "#include \"xinerama.h\"",
            "#include \"cleanup.h\"",
            "#include \"scan.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int slave_fd = -1, alarm_fired = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/stropts.h>\n#include <termios.h>\n#include <sys/ioctl.h>\n#include <shadow.h>\n#include \"default8x16.h\"\n#include \"rates.h\"\n#include \"cursor.h\"\n#include \"sslhelper.h\"\n#include \"connections.h\"\n#include \"user.h\"\n#include \"connections.h\"\n#include \"xinerama.h\"\n#include \"cleanup.h\"\n#include \"scan.h\"\n#include \"x11vnc.h\"\n\nstatic int slave_fd = -1, alarm_fired = 0;\n\nstatic void kill_child (pid_t pid, int fd) {\n\tint status;\n\n\tslave_fd = -1;\n\talarm_fired = 0;\n\tif (fd >= 0) {\n\t\tclose(fd);\n\t}\n\tkill(pid, SIGTERM);\n\twaitpid(pid, &status, WNOHANG); \n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"sending SIGTERM to: %d\\n\"",
            "pid"
          ],
          "line": 518
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trackdir_pid",
          "args": [
            "win"
          ],
          "line": 516
        },
        "resolved": true,
        "details": {
          "function_name": "trackdir_pid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/appshare.c",
          "lines": "337-369",
          "snippet": "static int trackdir_pid(Window win) {\n\tFILE *f;\n\tint ln = 0, pid = 0;\n\tchar line[1024];\n\n\tif (!trackdir) {\n\t\treturn 0;\n\t}\n\tsprintf(tracktmp, \"%s/0x%lx.log\", trackdir, win);\n\tf = fopen(tracktmp, \"r\");\n\tif (!f) {\n\t\treturn 0;\n\t}\n\twhile (fgets(line, sizeof(line), f) != NULL) {\n\t\tif (ln++ > 30) {\n\t\t\tbreak;\n\t\t}\n\t\tif (strstr(line, \"x11vnc version:\")) {\n\t\t\tchar *q = strstr(line, \"pid:\");\n\t\t\tif (q) {\n\t\t\t\tint p;\n\t\t\t\tif (sscanf(q, \"pid: %d\", &p) == 1) {\n\t\t\t\t\tif (p > 0) {\n\t\t\t\t\t\tpid = p;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tfclose(f);\n\treturn pid;\n}",
          "includes": [
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "extern char *get_xprop(char *prop, Window win);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"x11vnc.h\"\n\nextern char *get_xprop(char *prop, Window win);\n\nstatic int trackdir_pid(Window win) {\n\tFILE *f;\n\tint ln = 0, pid = 0;\n\tchar line[1024];\n\n\tif (!trackdir) {\n\t\treturn 0;\n\t}\n\tsprintf(tracktmp, \"%s/0x%lx.log\", trackdir, win);\n\tf = fopen(tracktmp, \"r\");\n\tif (!f) {\n\t\treturn 0;\n\t}\n\twhile (fgets(line, sizeof(line), f) != NULL) {\n\t\tif (ln++ > 30) {\n\t\t\tbreak;\n\t\t}\n\t\tif (strstr(line, \"x11vnc version:\")) {\n\t\t\tchar *q = strstr(line, \"pid:\");\n\t\t\tif (q) {\n\t\t\t\tint p;\n\t\t\t\tif (sscanf(q, \"pid: %d\", &p) == 1) {\n\t\t\t\t\tif (p > 0) {\n\t\t\t\t\t\tpid = p;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tfclose(f);\n\treturn pid;\n}"
        }
      },
      {
        "call_info": {
          "callee": "find_win",
          "args": [
            "win"
          ],
          "line": 508
        },
        "resolved": true,
        "details": {
          "function_name": "find_win",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/appshare.c",
          "lines": "298-306",
          "snippet": "static int find_win(Window win) {\n\tint i;\n\tfor (i=0; i < WMAX; i++) {\n\t\tif (watch[i] == win) {\n\t\t\treturn i;\n\t\t}\n\t}\n\treturn -1;\n}",
          "includes": [
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [
            "#define WMAX 192"
          ],
          "globals_used": [
            "extern char *get_xprop(char *prop, Window win);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"x11vnc.h\"\n\n#define WMAX 192\n\nextern char *get_xprop(char *prop, Window win);\n\nstatic int find_win(Window win) {\n\tint i;\n\tfor (i=0; i < WMAX; i++) {\n\t\tif (watch[i] == win) {\n\t\t\treturn i;\n\t\t}\n\t}\n\treturn -1;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"x11vnc.h\"\n\nextern char *get_xprop(char *prop, Window win);\n\nstatic void stop(Window win) {\n\tchar *cmd;\n\tint pid = -1;\n\tint f = find_win(win);\n\tif (f < 0 || win == None) {\n\t\treturn;\n\t}\n\tif (state[f] == 0) {\n\t\treturn;\n\t}\n\tif (trackdir) {\n\t\tpid = trackdir_pid(win);\n\t\tif (pid > 0) {\n\t\t\tif (appshare_debug) {fprintf(stderr,\n\t\t\t    \"sending SIGTERM to: %d\\n\", pid); ff();}\n\t\t\tkill((pid_t) pid, SIGTERM);\n\t\t}\n\t}\n\n\tcmd = (char *) malloc(1000 + strlen(x11vnc));\n\tsprintf(cmd, \"pkill -TERM -f '%s %s 0x%lx -bg'\", x11vnc, id_opt, win);\n\tif (appshare_debug) {\n\t\tfprintf(stdout, \"stopping:  0x%08lx - %s\\n\", win, cmd);\n\t} else {\n\t\tfprintf(stdout, \"stopping:  x11vnc for window 0x%08lx  \"\n\t\t    \"(pid: %d)\\n\", win, pid);\n\t}\n\tff();\n\tsystem(cmd);\n\n\tsprintf(cmd, \"(sleep 0.25 2>/dev/null || sleep 1; pkill -KILL -f '%s \"\n\t    \"%s 0x%lx -bg') &\", x11vnc, id_opt, win);\n\tsystem(cmd);\n\n\tif (trackdir) {\n\t\ttrackdir_cleanup(win);\n\t}\n\n\tfree(cmd);\n}"
  },
  {
    "function_name": "launch",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/appshare.c",
    "lines": "393-503",
    "snippet": "static void launch(Window win) {\n\tchar *cmd, *tmp, *connto, *name;\n\tint len, timeo = 30, uf = use_forever;\n\tint w = 0, h = 0, x = 0, y = 0;\n\n\tif (win_attr(win)) {\n\t\t/* maybe switch to debug only. */\n\t\tw = attr.width;\n\t\th = attr.height;\n\t\tget_xy(win, &x, &y);\n\t}\n\n\tget_wm_name(win, &name);\n\n\tif (strstr(x11vnc_args, \"-once\")) {\n\t\tuf = 0;\n\t}\n\n\tif (control) {\n\t\tint i = 0;\n\t\tlen = 0;\n\t\tfor (i=0; i < CMAX; i++) {\n\t\t\tif (clients[i] != NULL) {\n\t\t\t\tlen += strlen(clients[i]) + 2;\n\t\t\t}\n\t\t}\n\t\tconnto = (char *) calloc(len, 1);\n\t\tfor (i=0; i < CMAX; i++) {\n\t\t\tif (clients[i] != NULL) {\n\t\t\t\tif (connto[0] != '\\0') {\n\t\t\t\t\tstrcat(connto, \",\");\n\t\t\t\t}\n\t\t\t\tstrcat(connto, clients[i]);\n\t\t\t}\n\t\t}\n\t} else {\n\t\tconnto = strdup(connect_to);\n\t}\n\tif (!strcmp(connto, \"\")) {\n\t\ttimeo = 0;\n\t}\n\tif (uf) {\n\t\ttimeo = 0;\n\t}\n\t\n\tlen = 1000 + strlen(x11vnc) + strlen(connto) + strlen(x11vnc_args)\n\t    + 3 * (trackdir ? strlen(trackdir) : 100);\n\n\tcmd = (char *) calloc(len, 1);\n\ttmp = (char *) calloc(len, 1);\n\n\tsprintf(cmd, \"%s %s 0x%lx -bg -quiet %s -nopw -rfbport 0 \"\n\t    \"-timeout %d -noxdamage -noxinerama -norc -repeat -speeds dsl \"\n\t    \"-env X11VNC_AVOID_WINDOWS=never -env X11VNC_APPSHARE_ACTIVE=1 \"\n\t    \"-env X11VNC_NO_CHECK_PM=1 -env %s -novncconnect -shared -nonap \"\n\t    \"-remote_prefix X11VNC_APPSHARE_CMD:\",\n\t    x11vnc, id_opt, win, use_forever ? \"-forever\" : \"-once\", timeo, unique_tag);\n\n\tif (trackdir) {\n\t\tFILE *f;\n\t\tsprintf(tracktmp, \" -noquiet -o %s/0x%lx.log\", trackdir, win);\n\t\tstrcat(cmd, tracktmp);\n\t\tsprintf(tracktmp, \"%s/0x%lx.connect\", trackdir, win);\n\t\tf = fopen(tracktmp, \"w\");\n\t\tif (f) {\n\t\t\tfprintf(f, \"%s\", connto);\n\t\t\tfclose(f);\n\t\t\tsprintf(tmp, \" -connect_or_exit '%s'\", tracktmp);\n\t\t\tstrcat(cmd, tmp);\n\t\t} else {\n\t\t\tsprintf(tmp, \" -connect_or_exit '%s'\", connto);\n\t\t\tstrcat(cmd, tmp);\n\t\t}\n\t} else {\n\t\tif (!strcmp(connto, \"\")) {\n\t\t\tsprintf(tmp, \" -connect '%s'\", connto);\n\t\t} else {\n\t\t\tsprintf(tmp, \" -connect_or_exit '%s'\", connto);\n\t\t}\n\t\tstrcat(cmd, tmp);\n\t}\n\tif (uf) {\n\t\tchar *q = strstr(cmd, \"-connect_or_exit\");\n\t\tif (q) q = strstr(q, \"_or_exit\");\n\t\tif (q) {\n\t\t\tunsigned int i;\n\t\t\tfor (i=0; i < strlen(\"_or_exit\"); i++) {\n\t\t\t\t*q = ' ';\n\t\t\t\tq++;\n\t\t\t}\n\t\t}\n\t}\n\n\tstrcat(cmd, \" \");\n\tstrcat(cmd, x11vnc_args);\n\n\tfprintf(stdout, \"launching: x11vnc for window 0x%08lx %dx%d+%d+%d \\\"%s\\\"\\n\",\n\t    win, w, h, x, y, name);\n\n\tif (appshare_debug) {\n\t\tfprintf(stderr, \"\\nrunning:   %s\\n\\n\", cmd);\n\t}\n\tff();\n\n\tsystem(cmd);\n\n\tfree(cmd);\n\tfree(tmp);\n\tfree(connto);\n\tfree(name);\n}",
    "includes": [
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [
      "#define CMAX 128"
    ],
    "globals_used": [
      "extern char *get_xprop(char *prop, Window win);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "name"
          ],
          "line": 502
        },
        "resolved": true,
        "details": {
          "function_name": "free_rect",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/userinput.c",
          "lines": "6200-6247",
          "snippet": "int free_rect(int idx) {\n\tint n, ok = 0;\n\tsraRegionPtr r1, r2;\n\tint x, y, w, h;\n\n\tif (idx < 0 || idx >= cache_list_num) {\nif (0) fprintf(stderr, \"free_rect: bad index: %d\\n\", idx);\n\t\tclean_up_exit(1);\n\t}\n\n\tx = cache_list[idx].bs_x;\n\ty = cache_list[idx].bs_y;\n\tw = cache_list[idx].bs_w;\n\th = cache_list[idx].bs_h;\n\n\tif (x < 0) {\n\t\tCLEAR(idx);\nif (dnow() > last_client + 5 && ncdb) fprintf(stderr, \"free_rect: already bs_x invalidated: %d bs_x: %d\\n\", idx, x);\n\t\treturn 1;\n\t}\n\n\tr2 = sraRgnCreateRect(x, y, x+w, y+h);\n\n\tn = get_bs_n(y);\n\tif (n >= 0) {\n\t\tr1 = rect_reg[n];\n\t\tsraRgnOr(r1, r2);\n\t\tok = 1;\n\t}\n\n\tif (zero_rects) {\n\t\tsraRgnOr(zero_rects, r2);\n\t\tx = cache_list[idx].su_x;\n\t\ty = cache_list[idx].su_y;\n\t\tw = cache_list[idx].su_w;\n\t\th = cache_list[idx].su_h;\n\t\tif (x >= 0) {\n\t\t\tsraRgnDestroy(r2);\n\t\t\tr2 = sraRgnCreateRect(x, y, x+w, y+h);\n\t\t\tsraRgnOr(zero_rects, r2);\n\t\t}\n\t}\n\tsraRgnDestroy(r2);\n\n\tCLEAR(idx);\nif (! ok && ncdb) fprintf(stderr, \"**** free_rect: not-found %d\\n\", idx);\n\treturn ok;\n}",
          "includes": [
            "#include \"default8x16.h\"",
            "#include \"connections.h\"",
            "#include \"screen.h\"",
            "#include \"cursor.h\"",
            "#include \"macosxCGS.h\"",
            "#include \"macosx.h\"",
            "#include \"unixpw.h\"",
            "#include \"8to24.h\"",
            "#include \"xrandr.h\"",
            "#include \"solid.h\"",
            "#include \"keyboard.h\"",
            "#include \"rates.h\"",
            "#include \"pointer.h\"",
            "#include \"cleanup.h\"",
            "#include \"scan.h\"",
            "#include \"user.h\"",
            "#include \"xevents.h\"",
            "#include \"win_utils.h\"",
            "#include \"xinerama.h\"",
            "#include \"xrecord.h\"",
            "#include \"xdamage.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void mark_for_xdamage(int x, int y, int w, int h);",
            "void set_xdamage_mark(int x, int y, int w, int h);",
            "int find_rect(int idx, int x, int y, int w, int h);",
            "winattr_t *cache_list;",
            "int clipped(int idx);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"default8x16.h\"\n#include \"connections.h\"\n#include \"screen.h\"\n#include \"cursor.h\"\n#include \"macosxCGS.h\"\n#include \"macosx.h\"\n#include \"unixpw.h\"\n#include \"8to24.h\"\n#include \"xrandr.h\"\n#include \"solid.h\"\n#include \"keyboard.h\"\n#include \"rates.h\"\n#include \"pointer.h\"\n#include \"cleanup.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"xevents.h\"\n#include \"win_utils.h\"\n#include \"xinerama.h\"\n#include \"xrecord.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nvoid mark_for_xdamage(int x, int y, int w, int h);\nvoid set_xdamage_mark(int x, int y, int w, int h);\nint find_rect(int idx, int x, int y, int w, int h);\nwinattr_t *cache_list;\nint clipped(int idx);\n\nint free_rect(int idx) {\n\tint n, ok = 0;\n\tsraRegionPtr r1, r2;\n\tint x, y, w, h;\n\n\tif (idx < 0 || idx >= cache_list_num) {\nif (0) fprintf(stderr, \"free_rect: bad index: %d\\n\", idx);\n\t\tclean_up_exit(1);\n\t}\n\n\tx = cache_list[idx].bs_x;\n\ty = cache_list[idx].bs_y;\n\tw = cache_list[idx].bs_w;\n\th = cache_list[idx].bs_h;\n\n\tif (x < 0) {\n\t\tCLEAR(idx);\nif (dnow() > last_client + 5 && ncdb) fprintf(stderr, \"free_rect: already bs_x invalidated: %d bs_x: %d\\n\", idx, x);\n\t\treturn 1;\n\t}\n\n\tr2 = sraRgnCreateRect(x, y, x+w, y+h);\n\n\tn = get_bs_n(y);\n\tif (n >= 0) {\n\t\tr1 = rect_reg[n];\n\t\tsraRgnOr(r1, r2);\n\t\tok = 1;\n\t}\n\n\tif (zero_rects) {\n\t\tsraRgnOr(zero_rects, r2);\n\t\tx = cache_list[idx].su_x;\n\t\ty = cache_list[idx].su_y;\n\t\tw = cache_list[idx].su_w;\n\t\th = cache_list[idx].su_h;\n\t\tif (x >= 0) {\n\t\t\tsraRgnDestroy(r2);\n\t\t\tr2 = sraRgnCreateRect(x, y, x+w, y+h);\n\t\t\tsraRgnOr(zero_rects, r2);\n\t\t}\n\t}\n\tsraRgnDestroy(r2);\n\n\tCLEAR(idx);\nif (! ok && ncdb) fprintf(stderr, \"**** free_rect: not-found %d\\n\", idx);\n\treturn ok;\n}"
        }
      },
      {
        "call_info": {
          "callee": "system",
          "args": [
            "cmd"
          ],
          "line": 497
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ff",
          "args": [],
          "line": 495
        },
        "resolved": true,
        "details": {
          "function_name": "ff",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/appshare.c",
          "lines": "293-296",
          "snippet": "static void ff(void) {\n\tfflush(stdout);\n\tfflush(stderr);\n}",
          "includes": [
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"x11vnc.h\"\n\nstatic void ff(void) {\n\tfflush(stdout);\n\tfflush(stderr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"\\nrunning:   %s\\n\\n\"",
            "cmd"
          ],
          "line": 493
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stdout",
            "\"launching: x11vnc for window 0x%08lx %dx%d+%d+%d \\\"%s\\\"\\n\"",
            "win",
            "w",
            "h",
            "x",
            "y",
            "name"
          ],
          "line": 489
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcat",
          "args": [
            "cmd",
            "x11vnc_args"
          ],
          "line": 487
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcat",
          "args": [
            "cmd",
            "\" \""
          ],
          "line": 486
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "\"_or_exit\""
          ],
          "line": 479
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "q",
            "\"_or_exit\""
          ],
          "line": 476
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "cmd",
            "\"-connect_or_exit\""
          ],
          "line": 475
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcat",
          "args": [
            "cmd",
            "tmp"
          ],
          "line": 472
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "tmp",
            "\" -connect_or_exit '%s'\"",
            "connto"
          ],
          "line": 470
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "tmp",
            "\" -connect '%s'\"",
            "connto"
          ],
          "line": 468
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "connto",
            "\"\""
          ],
          "line": 467
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcat",
          "args": [
            "cmd",
            "tmp"
          ],
          "line": 464
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "tmp",
            "\" -connect_or_exit '%s'\"",
            "connto"
          ],
          "line": 463
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcat",
          "args": [
            "cmd",
            "tmp"
          ],
          "line": 461
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "tmp",
            "\" -connect_or_exit '%s'\"",
            "tracktmp"
          ],
          "line": 460
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fclose",
          "args": [
            "f"
          ],
          "line": 459
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "f",
            "\"%s\"",
            "connto"
          ],
          "line": 458
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fopen",
          "args": [
            "tracktmp",
            "\"w\""
          ],
          "line": 456
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "tracktmp",
            "\"%s/0x%lx.connect\"",
            "trackdir",
            "win"
          ],
          "line": 455
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcat",
          "args": [
            "cmd",
            "tracktmp"
          ],
          "line": 454
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "tracktmp",
            "\" -noquiet -o %s/0x%lx.log\"",
            "trackdir",
            "win"
          ],
          "line": 453
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "cmd",
            "\"%s %s 0x%lx -bg -quiet %s -nopw -rfbport 0 \"\n\t    \"-timeout %d -noxdamage -noxinerama -norc -repeat -speeds dsl \"\n\t    \"-env X11VNC_AVOID_WINDOWS=never -env X11VNC_APPSHARE_ACTIVE=1 \"\n\t    \"-env X11VNC_NO_CHECK_PM=1 -env %s -novncconnect -shared -nonap \"\n\t    \"-remote_prefix X11VNC_APPSHARE_CMD:\"",
            "x11vnc",
            "id_opt",
            "win",
            "use_forever ? \"-forever\" : \"-once\"",
            "timeo",
            "unique_tag"
          ],
          "line": 444
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "calloc",
          "args": [
            "len",
            "1"
          ],
          "line": 442
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "calloc",
          "args": [
            "len",
            "1"
          ],
          "line": 441
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "trackdir"
          ],
          "line": 439
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "x11vnc_args"
          ],
          "line": 438
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "connto"
          ],
          "line": 438
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "x11vnc"
          ],
          "line": 438
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "connto",
            "\"\""
          ],
          "line": 431
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "connect_to"
          ],
          "line": 429
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcat",
          "args": [
            "connto",
            "clients[i]"
          ],
          "line": 425
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcat",
          "args": [
            "connto",
            "\",\""
          ],
          "line": 423
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "calloc",
          "args": [
            "len",
            "1"
          ],
          "line": 419
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "clients[i]"
          ],
          "line": 416
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "x11vnc_args",
            "\"-once\""
          ],
          "line": 407
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_wm_name",
          "args": [
            "win",
            "&name"
          ],
          "line": 405
        },
        "resolved": true,
        "details": {
          "function_name": "get_wm_name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/appshare.c",
          "lines": "721-733",
          "snippet": "static void get_wm_name(Window win, char **name) {\n\tint ok = 0;\n\n#if !NO_X11\n        XErrorHandler old_handler = XSetErrorHandler(trap_xerror);\n\tok = XFetchName(dpy, win, name);\n       \tXSetErrorHandler(old_handler);\n#endif\n\n\tif (!ok || *name == NULL) {\n\t\t*name = strdup(\"unknown\");\n\t}\n}",
          "includes": [
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "extern char *get_xprop(char *prop, Window win);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"x11vnc.h\"\n\nextern char *get_xprop(char *prop, Window win);\n\nstatic void get_wm_name(Window win, char **name) {\n\tint ok = 0;\n\n#if !NO_X11\n        XErrorHandler old_handler = XSetErrorHandler(trap_xerror);\n\tok = XFetchName(dpy, win, name);\n       \tXSetErrorHandler(old_handler);\n#endif\n\n\tif (!ok || *name == NULL) {\n\t\t*name = strdup(\"unknown\");\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_xy",
          "args": [
            "win",
            "&x",
            "&y"
          ],
          "line": 402
        },
        "resolved": true,
        "details": {
          "function_name": "get_xy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/appshare.c",
          "lines": "783-798",
          "snippet": "static int get_xy(Window win, int *x, int *y) {\n\tWindow cr;\n\tBool rc = False; \n#if !NO_X11\n\tXErrorHandler old_handler = XSetErrorHandler(trap_xerror);\n\n\trc = XTranslateCoordinates(dpy, win, root, 0, 0, x, y, &cr);\n       \tXSetErrorHandler(old_handler);\n#endif\n\n\tif (!rc) {\n\t\treturn 0;\n\t} else {\n\t\treturn 1;\n\t}\n}",
          "includes": [
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "extern char *get_xprop(char *prop, Window win);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"x11vnc.h\"\n\nextern char *get_xprop(char *prop, Window win);\n\nstatic int get_xy(Window win, int *x, int *y) {\n\tWindow cr;\n\tBool rc = False; \n#if !NO_X11\n\tXErrorHandler old_handler = XSetErrorHandler(trap_xerror);\n\n\trc = XTranslateCoordinates(dpy, win, root, 0, 0, x, y, &cr);\n       \tXSetErrorHandler(old_handler);\n#endif\n\n\tif (!rc) {\n\t\treturn 0;\n\t} else {\n\t\treturn 1;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "win_attr",
          "args": [
            "win"
          ],
          "line": 398
        },
        "resolved": true,
        "details": {
          "function_name": "win_attr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/appshare.c",
          "lines": "735-748",
          "snippet": "static int win_attr(Window win) {\n\tint ok = 0;\n#if !NO_X11\n        XErrorHandler old_handler = XSetErrorHandler(trap_xerror);\n\tok = XGetWindowAttributes(dpy, win, &attr);\n       \tXSetErrorHandler(old_handler);\n#endif\n\n\tif (ok) {\n\t\treturn 1;\n\t} else {\n\t\treturn 0;\n\t}\n}",
          "includes": [
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "extern char *get_xprop(char *prop, Window win);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"x11vnc.h\"\n\nextern char *get_xprop(char *prop, Window win);\n\nstatic int win_attr(Window win) {\n\tint ok = 0;\n#if !NO_X11\n        XErrorHandler old_handler = XSetErrorHandler(trap_xerror);\n\tok = XGetWindowAttributes(dpy, win, &attr);\n       \tXSetErrorHandler(old_handler);\n#endif\n\n\tif (ok) {\n\t\treturn 1;\n\t} else {\n\t\treturn 0;\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"x11vnc.h\"\n\n#define CMAX 128\n\nextern char *get_xprop(char *prop, Window win);\n\nstatic void launch(Window win) {\n\tchar *cmd, *tmp, *connto, *name;\n\tint len, timeo = 30, uf = use_forever;\n\tint w = 0, h = 0, x = 0, y = 0;\n\n\tif (win_attr(win)) {\n\t\t/* maybe switch to debug only. */\n\t\tw = attr.width;\n\t\th = attr.height;\n\t\tget_xy(win, &x, &y);\n\t}\n\n\tget_wm_name(win, &name);\n\n\tif (strstr(x11vnc_args, \"-once\")) {\n\t\tuf = 0;\n\t}\n\n\tif (control) {\n\t\tint i = 0;\n\t\tlen = 0;\n\t\tfor (i=0; i < CMAX; i++) {\n\t\t\tif (clients[i] != NULL) {\n\t\t\t\tlen += strlen(clients[i]) + 2;\n\t\t\t}\n\t\t}\n\t\tconnto = (char *) calloc(len, 1);\n\t\tfor (i=0; i < CMAX; i++) {\n\t\t\tif (clients[i] != NULL) {\n\t\t\t\tif (connto[0] != '\\0') {\n\t\t\t\t\tstrcat(connto, \",\");\n\t\t\t\t}\n\t\t\t\tstrcat(connto, clients[i]);\n\t\t\t}\n\t\t}\n\t} else {\n\t\tconnto = strdup(connect_to);\n\t}\n\tif (!strcmp(connto, \"\")) {\n\t\ttimeo = 0;\n\t}\n\tif (uf) {\n\t\ttimeo = 0;\n\t}\n\t\n\tlen = 1000 + strlen(x11vnc) + strlen(connto) + strlen(x11vnc_args)\n\t    + 3 * (trackdir ? strlen(trackdir) : 100);\n\n\tcmd = (char *) calloc(len, 1);\n\ttmp = (char *) calloc(len, 1);\n\n\tsprintf(cmd, \"%s %s 0x%lx -bg -quiet %s -nopw -rfbport 0 \"\n\t    \"-timeout %d -noxdamage -noxinerama -norc -repeat -speeds dsl \"\n\t    \"-env X11VNC_AVOID_WINDOWS=never -env X11VNC_APPSHARE_ACTIVE=1 \"\n\t    \"-env X11VNC_NO_CHECK_PM=1 -env %s -novncconnect -shared -nonap \"\n\t    \"-remote_prefix X11VNC_APPSHARE_CMD:\",\n\t    x11vnc, id_opt, win, use_forever ? \"-forever\" : \"-once\", timeo, unique_tag);\n\n\tif (trackdir) {\n\t\tFILE *f;\n\t\tsprintf(tracktmp, \" -noquiet -o %s/0x%lx.log\", trackdir, win);\n\t\tstrcat(cmd, tracktmp);\n\t\tsprintf(tracktmp, \"%s/0x%lx.connect\", trackdir, win);\n\t\tf = fopen(tracktmp, \"w\");\n\t\tif (f) {\n\t\t\tfprintf(f, \"%s\", connto);\n\t\t\tfclose(f);\n\t\t\tsprintf(tmp, \" -connect_or_exit '%s'\", tracktmp);\n\t\t\tstrcat(cmd, tmp);\n\t\t} else {\n\t\t\tsprintf(tmp, \" -connect_or_exit '%s'\", connto);\n\t\t\tstrcat(cmd, tmp);\n\t\t}\n\t} else {\n\t\tif (!strcmp(connto, \"\")) {\n\t\t\tsprintf(tmp, \" -connect '%s'\", connto);\n\t\t} else {\n\t\t\tsprintf(tmp, \" -connect_or_exit '%s'\", connto);\n\t\t}\n\t\tstrcat(cmd, tmp);\n\t}\n\tif (uf) {\n\t\tchar *q = strstr(cmd, \"-connect_or_exit\");\n\t\tif (q) q = strstr(q, \"_or_exit\");\n\t\tif (q) {\n\t\t\tunsigned int i;\n\t\t\tfor (i=0; i < strlen(\"_or_exit\"); i++) {\n\t\t\t\t*q = ' ';\n\t\t\t\tq++;\n\t\t\t}\n\t\t}\n\t}\n\n\tstrcat(cmd, \" \");\n\tstrcat(cmd, x11vnc_args);\n\n\tfprintf(stdout, \"launching: x11vnc for window 0x%08lx %dx%d+%d+%d \\\"%s\\\"\\n\",\n\t    win, w, h, x, y, name);\n\n\tif (appshare_debug) {\n\t\tfprintf(stderr, \"\\nrunning:   %s\\n\\n\", cmd);\n\t}\n\tff();\n\n\tsystem(cmd);\n\n\tfree(cmd);\n\tfree(tmp);\n\tfree(connto);\n\tfree(name);\n}"
  },
  {
    "function_name": "trackdir_cleanup",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/appshare.c",
    "lines": "371-391",
    "snippet": "static void trackdir_cleanup(Window win) {\n\tchar *suffix[] = {\"log\", \"connect\", NULL};\n\tint i=0;\n\tif (!trackdir) {\n\t\treturn;\n\t}\n\twhile (suffix[i] != NULL) {\n\t\tsprintf(tracktmp, \"%s/0x%lx.%s\", trackdir, win, suffix[i]);\n\t\tif (appshare_debug && !strcmp(suffix[i], \"log\")) {\n\t\t\tfprintf(stderr, \"keeping:  %s\\n\", tracktmp);\n\t\t\tff();\n\t\t} else {\n\t\t\tif (appshare_debug) {\n\t\t\t\tfprintf(stderr, \"removing: %s\\n\", tracktmp);\n\t\t\t\tff();\n\t\t\t}\n\t\t\tunlink(tracktmp);\n\t\t}\n\t\ti++;\n\t}\n}",
    "includes": [
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "extern char *get_xprop(char *prop, Window win);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "unlink",
          "args": [
            "tracktmp"
          ],
          "line": 387
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ff",
          "args": [],
          "line": 385
        },
        "resolved": true,
        "details": {
          "function_name": "ff",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/appshare.c",
          "lines": "293-296",
          "snippet": "static void ff(void) {\n\tfflush(stdout);\n\tfflush(stderr);\n}",
          "includes": [
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"x11vnc.h\"\n\nstatic void ff(void) {\n\tfflush(stdout);\n\tfflush(stderr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"removing: %s\\n\"",
            "tracktmp"
          ],
          "line": 384
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"keeping:  %s\\n\"",
            "tracktmp"
          ],
          "line": 380
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "suffix[i]",
            "\"log\""
          ],
          "line": 379
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "tracktmp",
            "\"%s/0x%lx.%s\"",
            "trackdir",
            "win",
            "suffix[i]"
          ],
          "line": 378
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"x11vnc.h\"\n\nextern char *get_xprop(char *prop, Window win);\n\nstatic void trackdir_cleanup(Window win) {\n\tchar *suffix[] = {\"log\", \"connect\", NULL};\n\tint i=0;\n\tif (!trackdir) {\n\t\treturn;\n\t}\n\twhile (suffix[i] != NULL) {\n\t\tsprintf(tracktmp, \"%s/0x%lx.%s\", trackdir, win, suffix[i]);\n\t\tif (appshare_debug && !strcmp(suffix[i], \"log\")) {\n\t\t\tfprintf(stderr, \"keeping:  %s\\n\", tracktmp);\n\t\t\tff();\n\t\t} else {\n\t\t\tif (appshare_debug) {\n\t\t\t\tfprintf(stderr, \"removing: %s\\n\", tracktmp);\n\t\t\t\tff();\n\t\t\t}\n\t\t\tunlink(tracktmp);\n\t\t}\n\t\ti++;\n\t}\n}"
  },
  {
    "function_name": "trackdir_pid",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/appshare.c",
    "lines": "337-369",
    "snippet": "static int trackdir_pid(Window win) {\n\tFILE *f;\n\tint ln = 0, pid = 0;\n\tchar line[1024];\n\n\tif (!trackdir) {\n\t\treturn 0;\n\t}\n\tsprintf(tracktmp, \"%s/0x%lx.log\", trackdir, win);\n\tf = fopen(tracktmp, \"r\");\n\tif (!f) {\n\t\treturn 0;\n\t}\n\twhile (fgets(line, sizeof(line), f) != NULL) {\n\t\tif (ln++ > 30) {\n\t\t\tbreak;\n\t\t}\n\t\tif (strstr(line, \"x11vnc version:\")) {\n\t\t\tchar *q = strstr(line, \"pid:\");\n\t\t\tif (q) {\n\t\t\t\tint p;\n\t\t\t\tif (sscanf(q, \"pid: %d\", &p) == 1) {\n\t\t\t\t\tif (p > 0) {\n\t\t\t\t\t\tpid = p;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tfclose(f);\n\treturn pid;\n}",
    "includes": [
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "extern char *get_xprop(char *prop, Window win);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "fclose",
          "args": [
            "f"
          ],
          "line": 367
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sscanf",
          "args": [
            "q",
            "\"pid: %d\"",
            "&p"
          ],
          "line": 358
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "line",
            "\"pid:\""
          ],
          "line": 355
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "line",
            "\"x11vnc version:\""
          ],
          "line": 354
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fgets",
          "args": [
            "line",
            "sizeof(line)",
            "f"
          ],
          "line": 350
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fopen",
          "args": [
            "tracktmp",
            "\"r\""
          ],
          "line": 346
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "tracktmp",
            "\"%s/0x%lx.log\"",
            "trackdir",
            "win"
          ],
          "line": 345
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"x11vnc.h\"\n\nextern char *get_xprop(char *prop, Window win);\n\nstatic int trackdir_pid(Window win) {\n\tFILE *f;\n\tint ln = 0, pid = 0;\n\tchar line[1024];\n\n\tif (!trackdir) {\n\t\treturn 0;\n\t}\n\tsprintf(tracktmp, \"%s/0x%lx.log\", trackdir, win);\n\tf = fopen(tracktmp, \"r\");\n\tif (!f) {\n\t\treturn 0;\n\t}\n\twhile (fgets(line, sizeof(line), f) != NULL) {\n\t\tif (ln++ > 30) {\n\t\t\tbreak;\n\t\t}\n\t\tif (strstr(line, \"x11vnc version:\")) {\n\t\t\tchar *q = strstr(line, \"pid:\");\n\t\t\tif (q) {\n\t\t\t\tint p;\n\t\t\t\tif (sscanf(q, \"pid: %d\", &p) == 1) {\n\t\t\t\t\tif (p > 0) {\n\t\t\t\t\t\tpid = p;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tfclose(f);\n\treturn pid;\n}"
  },
  {
    "function_name": "find_client",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/appshare.c",
    "lines": "318-335",
    "snippet": "static int find_client(char *cl) {\n\tint i;\n\tfor (i=0; i < CMAX; i++) {\n\t\tif (cl == NULL) {\n\t\t\tif (clients[i] == NULL) {\n\t\t\t\treturn i;\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\t\tif (clients[i] == NULL) {\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strcmp(clients[i], cl)) {\n\t\t\treturn i;\n\t\t}\n\t}\n\treturn -1;\n}",
    "includes": [
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [
      "#define CMAX 128"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "clients[i]",
            "cl"
          ],
          "line": 330
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"x11vnc.h\"\n\n#define CMAX 128\n\nstatic int find_client(char *cl) {\n\tint i;\n\tfor (i=0; i < CMAX; i++) {\n\t\tif (cl == NULL) {\n\t\t\tif (clients[i] == NULL) {\n\t\t\t\treturn i;\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\t\tif (clients[i] == NULL) {\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strcmp(clients[i], cl)) {\n\t\t\treturn i;\n\t\t}\n\t}\n\treturn -1;\n}"
  },
  {
    "function_name": "find_app",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/appshare.c",
    "lines": "308-316",
    "snippet": "static int find_app(Window app) {\n\tint i;\n\tfor (i=0; i < AMAX; i++) {\n\t\tif (apps[i] == app) {\n\t\t\treturn i;\n\t\t}\n\t}\n\treturn -1;\n}",
    "includes": [
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [
      "#define AMAX 32"
    ],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"x11vnc.h\"\n\n#define AMAX 32\n\nstatic int find_app(Window app) {\n\tint i;\n\tfor (i=0; i < AMAX; i++) {\n\t\tif (apps[i] == app) {\n\t\t\treturn i;\n\t\t}\n\t}\n\treturn -1;\n}"
  },
  {
    "function_name": "find_win",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/appshare.c",
    "lines": "298-306",
    "snippet": "static int find_win(Window win) {\n\tint i;\n\tfor (i=0; i < WMAX; i++) {\n\t\tif (watch[i] == win) {\n\t\t\treturn i;\n\t\t}\n\t}\n\treturn -1;\n}",
    "includes": [
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [
      "#define WMAX 192"
    ],
    "globals_used": [
      "extern char *get_xprop(char *prop, Window win);"
    ],
    "called_functions": [],
    "contextual_snippet": "#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"x11vnc.h\"\n\n#define WMAX 192\n\nextern char *get_xprop(char *prop, Window win);\n\nstatic int find_win(Window win) {\n\tint i;\n\tfor (i=0; i < WMAX; i++) {\n\t\tif (watch[i] == win) {\n\t\t\treturn i;\n\t\t}\n\t}\n\treturn -1;\n}"
  },
  {
    "function_name": "ff",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/appshare.c",
    "lines": "293-296",
    "snippet": "static void ff(void) {\n\tfflush(stdout);\n\tfflush(stderr);\n}",
    "includes": [
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fflush",
          "args": [
            "stderr"
          ],
          "line": 295
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fflush",
          "args": [
            "stdout"
          ],
          "line": 294
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"x11vnc.h\"\n\nstatic void ff(void) {\n\tfflush(stdout);\n\tfflush(stderr);\n}"
  }
]