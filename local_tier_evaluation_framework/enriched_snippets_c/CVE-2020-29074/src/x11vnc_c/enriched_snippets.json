[
  {
    "function_name": "main",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/x11vnc.c",
    "lines": "2041-4168",
    "snippet": "int main(int argc, char* argv[]) {\n\n\tint i, len, tmpi;\n\tint ev, er, maj, min;\n\tchar *arg;\n\tint remote_sync = 0;\n\tchar *remote_cmd = NULL;\n\tchar *query_cmd  = NULL;\n\tint query_retries = 0;\n\tdouble query_delay = 0.5;\n\tchar *query_match  = NULL;\n\tchar *gui_str = NULL;\n\tint got_gui_pw = 0;\n\tint pw_loc = -1, got_passwd = 0, got_rfbauth = 0, nopw = NOPW;\n\tint got_viewpasswd = 0, got_localhost = 0, got_passwdfile = 0;\n\tint vpw_loc = -1;\n\tint dt = 0, bg = 0;\n\tint got_rfbwait = 0;\n\tint got_httpdir = 0, try_http = 0;\n\tint orig_use_xdamage = use_xdamage;\n\tint http_oneport_msg = 0;\n\tXImage *fb0 = NULL;\n\tint ncache_msg = 0;\n\tchar *got_rfbport_str = NULL;\n\tint got_rfbport_pos = -1;\n\tint got_tls = 0;\n\tint got_inetd = 0;\n\tint got_noxrandr = 0;\n\n\t/* used to pass args we do not know about to rfbGetScreen(): */\n\tint argc_vnc_max = 1024;\n\tint argc_vnc = 1; char *argv_vnc[2048];\n\n\t/* check for -loop mode: */\n\tcheck_loop_mode(argc, argv, 0);\n\n\t/* check for -appshare mode: */\n\tcheck_appshare_mode(argc, argv);\n\n\tdtime0(&x11vnc_start);\n\n\tfor (i=1; i < argc; i++) {\n\t\tif (!strcmp(argv[i], \"-inetd\")) {\n\t\t\tgot_inetd = 1;\n\t\t}\n\t}\n\n\tif (!getuid() || !geteuid()) {\n\t\tstarted_as_root = 1;\n\t\tif (0 && !got_inetd) {\n\t\t\trfbLog(\"getuid: %d  geteuid: %d\\n\", getuid(), geteuid());\n\t\t}\n\n\t\t/* check for '-users =bob' */\n\t\timmediate_switch_user(argc, argv);\n\t}\n\n\tfor (i=0; i < 2048; i++) {\n\t\targv_vnc[i] = NULL;\n\t}\n\n\targv_vnc[0] = strdup(argv[0]);\n\tprogram_name = strdup(argv[0]);\n\tprogram_pid = (int) getpid();\n\n\tsolid_default = strdup(solid_default);\t/* for freeing with -R */\n\n\tlen = 0;\n\tfor (i=1; i < argc; i++) {\n\t\tlen += strlen(argv[i]) + 4 + 1;\n\t}\n\tprogram_cmdline = (char *) malloc(len+1);\n\tprogram_cmdline[0] = '\\0';\n\tfor (i=1; i < argc; i++) {\n\t\tchar *s = argv[i];\n\t\tif (program_cmdline[0]) {\n\t\t\tstrcat(program_cmdline, \" \");\n\t\t}\n\t\tif (*s == '-') {\n\t\t\tstrcat(program_cmdline, s);\n\t\t} else {\n\t\t\tstrcat(program_cmdline, \"{{\");\n\t\t\tstrcat(program_cmdline, s);\n\t\t\tstrcat(program_cmdline, \"}}\");\n\t\t}\n\t}\n\n\tfor (i=0; i<ICON_MODE_SOCKS; i++) {\n\t\ticon_mode_socks[i] = -1;\n\t}\n\n\tcheck_rcfile(argc, argv);\n\t/* kludge for the new array argv2 set in check_rcfile() */\n#\tdefine argc argc2\n#\tdefine argv argv2\n\n#\tdefine CHECK_ARGC if (i >= argc-1) { \\\n\t\tfprintf(stderr, \"not enough arguments for: %s\\n\", arg); \\\n\t\texit(1); \\\n\t}\n\n\t/*\n\t * do a quick check for parameters that apply to \"utility\"\n\t * commands, i.e. ones that do not run the server.\n\t */\n\tfor (i=1; i < argc; i++) {\n\t\targ = argv[i];\n\t\tif (strstr(arg, \"--\") == arg) {\n\t\t\targ++;\n\t\t}\n\t\tif (!strcmp(arg, \"-ssldir\")) {\n\t\t\tCHECK_ARGC\n\t\t\tssl_certs_dir = strdup(argv[++i]);\n\t\t}\n\t}\n\n\t/*\n\t * do a quick check for -env parameters\n\t */\n\tfor (i=1; i < argc; i++) {\n\t\tchar *p, *q;\n\t\targ = argv[i];\n\t\tif (strstr(arg, \"--\") == arg) {\n\t\t\targ++;\n\t\t}\n\t\tif (!strcmp(arg, \"-env\")) {\n\t\t\tCHECK_ARGC\n\t\t\tp = strdup(argv[++i]);\n\t\t\tq = strchr(p, '=');\n\t\t\tif (! q) {\n\t\t\t\tfprintf(stderr, \"no -env '=' found: %s\\n\", p);\n\t\t\t\texit(1);\n\t\t\t} else {\n\t\t\t\t*q = '\\0';\n\t\t\t}\n\t\t\tset_env(p, q+1);\n\t\t\tfree(p);\n\t\t}\n\t}\n\n\tfor (i=1; i < argc; i++) {\n\t\t/* quick-n-dirty --option handling. */\n\t\targ = argv[i];\n\t\tif (strstr(arg, \"--\") == arg) {\n\t\t\targ++;\n\t\t}\n\n\t\tif (!strcmp(arg, \"-display\")) {\n\t\t\tCHECK_ARGC\n\t\t\tuse_dpy = strdup(argv[++i]);\n\t\t\tif (strstr(use_dpy, \"WAIT\")) {\n\t\t\t\textern char find_display[];\n\t\t\t\textern char create_display[];\n\t\t\t\tif (strstr(use_dpy, \"cmd=FINDDISPLAY-print\")) {\n\t\t\t\t\tfprintf(stdout, \"%s\", find_display);\n\t\t\t\t\texit(0);\n\t\t\t\t}\n\t\t\t\tif (strstr(use_dpy, \"cmd=FINDCREATEDISPLAY-print\")) {\n\t\t\t\t\tfprintf(stdout, \"%s\", create_display);\n\t\t\t\t\texit(0);\n\t\t\t\t}\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strcmp(arg, \"-reopen\")) {\n\t\t\tchar *str = getenv(\"X11VNC_REOPEN_DISPLAY\");\n\t\t\tif (str) {\n\t\t\t\tint rmax = atoi(str);\n\t\t\t\tif (rmax > 0) {\n\t\t\t\t\tset_env(\"X11VNC_REOPEN_DISPLAY\", str);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tset_env(\"X11VNC_REOPEN_DISPLAY\", \"1\");\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strcmp(arg, \"-find\")) {\n\t\t\tuse_dpy = strdup(\"WAIT:cmd=FINDDISPLAY\");\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strcmp(arg, \"-finddpy\") || strstr(arg, \"-listdpy\") == arg) {\n\t\t\tint ic = 0;\n\t\t\tuse_dpy = strdup(\"WAIT:cmd=FINDDISPLAY-run\");\n\t\t\tif (argc > i+1) {\n\t\t\t\tset_env(\"X11VNC_USER\", argv[i+1]);\n\t\t\t\tfprintf(stdout, \"X11VNC_USER=%s\\n\", getenv(\"X11VNC_USER\"));\n\t\t\t}\n\t\t\tif (strstr(arg, \"-listdpy\") == arg) {\n\t\t\t\tset_env(\"FIND_DISPLAY_ALL\", \"1\");\n\t\t\t}\n\t\t\twait_for_client(&ic, NULL, 0);\n\t\t\texit(0);\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strcmp(arg, \"-findauth\")) {\n\t\t\tgot_findauth = 1;\n\t\t\tif (argc > i+1) {\n\t\t\t\tchar *s = argv[i+1];\n\t\t\t\tif (s[0] != '-') {\n\t\t\t\t\tset_env(\"FINDAUTH_DISPLAY\", argv[i+1]);\n\t\t\t\t\ti++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strcmp(arg, \"-create\")) {\n\t\t\tuse_dpy = strdup(\"WAIT:cmd=FINDCREATEDISPLAY-Xvfb\");\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strcmp(arg, \"-create_xsrv\")) {\n\t\t\tCHECK_ARGC\n\t\t\tuse_dpy = (char *) malloc(strlen(argv[i+1])+100); \n\t\t\tsprintf(use_dpy, \"WAIT:cmd=FINDCREATEDISPLAY-%s\", argv[++i]);\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strcmp(arg, \"-xdummy\")) {\n\t\t\tuse_dpy = strdup(\"WAIT:cmd=FINDCREATEDISPLAY-Xdummy\");\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strcmp(arg, \"-xdummy_xvfb\")) {\n\t\t\tuse_dpy = strdup(\"WAIT:cmd=FINDCREATEDISPLAY-Xdummy,Xvfb\");\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strcmp(arg, \"-xvnc\")) {\n\t\t\tuse_dpy = strdup(\"WAIT:cmd=FINDCREATEDISPLAY-Xvnc\");\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strcmp(arg, \"-xvnc_redirect\")) {\n\t\t\tuse_dpy = strdup(\"WAIT:cmd=FINDCREATEDISPLAY-Xvnc.redirect\");\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strcmp(arg, \"-redirect\")) {\n\t\t\tchar *q, *t, *t0 = \"WAIT:cmd=FINDDISPLAY-vnc_redirect\";\n\t\t\tCHECK_ARGC\n\t\t\tt = (char *) malloc(strlen(t0) + strlen(argv[++i]) + 2);\n\t\t\tq = strrchr(argv[i], ':');\n\t\t\tif (q) *q = ' ';\n\t\t\tsprintf(t, \"%s=%s\", t0, argv[i]);\n\t\t\tuse_dpy = t;\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strcmp(arg, \"-auth\") || !strcmp(arg, \"-xauth\")) {\n\t\t\tCHECK_ARGC\n\t\t\tauth_file = strdup(argv[++i]);\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strcmp(arg, \"-N\")) {\n\t\t\tdisplay_N = 1;\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strcmp(arg, \"-autoport\")) {\n\t\t\tCHECK_ARGC\n\t\t\tauto_port = atoi(argv[++i]);\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strcmp(arg, \"-reflect\")) {\n\t\t\tCHECK_ARGC\n\t\t\traw_fb_str = (char *) malloc(4 + strlen(argv[i+1]) + 1);\n\t\t\tsprintf(raw_fb_str, \"vnc:%s\", argv[++i]);\n\t\t\tshared = 1;\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strcmp(arg, \"-tsd\")) {\n\t\t\tCHECK_ARGC\n\t\t\tterminal_services_daemon = strdup(argv[++i]);\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strcmp(arg, \"-id\") || !strcmp(arg, \"-sid\")) {\n\t\t\tCHECK_ARGC\n\t\t\tif (!strcmp(arg, \"-sid\")) {\n\t\t\t\trootshift = 1;\n\t\t\t} else {\n\t\t\t\trootshift = 0;\n\t\t\t}\n\t\t\ti++;\n\t\t\tif (!strcmp(\"pick\", argv[i])) {\n\t\t\t\tif (started_as_root) {\n\t\t\t\t\tfprintf(stderr, \"unsafe: %s pick\\n\",\n\t\t\t\t\t    arg);\n\t\t\t\t\texit(1);\n\t\t\t\t} else if (! pick_windowid(&subwin)) {\n\t\t\t\t\tfprintf(stderr, \"invalid %s pick\\n\",\n\t\t\t\t\t    arg);\n\t\t\t\t\texit(1);\n\t\t\t\t}\n\t\t\t} else if (! scan_hexdec(argv[i], &subwin)) {\n\t\t\t\tfprintf(stderr, \"invalid %s arg: %s\\n\", arg,\n\t\t\t\t    argv[i]);\n\t\t\t\texit(1);\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strcmp(arg, \"-waitmapped\")) {\n\t\t\tsubwin_wait_mapped = 1;\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strcmp(arg, \"-clip\")) {\n\t\t\tCHECK_ARGC\n\t\t\tclip_str = strdup(argv[++i]);\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strcmp(arg, \"-flashcmap\")) {\n\t\t\tflash_cmap = 1;\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strcmp(arg, \"-shiftcmap\")) {\n\t\t\tCHECK_ARGC\n\t\t\tshift_cmap = atoi(argv[++i]);\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strcmp(arg, \"-notruecolor\")) {\n\t\t\tforce_indexed_color = 1;\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strcmp(arg, \"-advertise_truecolor\")) {\n\t\t\tadvertise_truecolor = 1;\n\t\t\tif (i < argc-1) {\n\t\t\t\tchar *s = argv[i+1];\n\t\t\t\tif (s[0] != '-') {\n\t\t\t\t\tif (strstr(s, \"reset\")) {\n\t\t\t\t\t\tadvertise_truecolor_reset = 1;\n\t\t\t\t\t}\n\t\t\t\t\ti++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strcmp(arg, \"-overlay\")) {\n\t\t\toverlay = 1;\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strcmp(arg, \"-overlay_nocursor\")) {\n\t\t\toverlay = 1;\n\t\t\toverlay_cursor = 0;\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strcmp(arg, \"-overlay_yescursor\")) {\n\t\t\toverlay = 1;\n\t\t\toverlay_cursor = 2;\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strcmp(arg, \"-8to24\")) {\n#if !SKIP_8TO24\n\t\t\tcmap8to24 = 1;\n\t\t\tif (i < argc-1) {\n\t\t\t\tchar *s = argv[i+1];\n\t\t\t\tif (s[0] != '-') {\n\t\t\t\t\tcmap8to24_str = strdup(s);\n\t\t\t\t\ti++;\n\t\t\t\t}\n\t\t\t}\n#endif\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strcmp(arg, \"-24to32\")) {\n\t\t\txform24to32 = 1;\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strcmp(arg, \"-visual\")) {\n\t\t\tCHECK_ARGC\n\t\t\tvisual_str = strdup(argv[++i]);\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strcmp(arg, \"-scale\")) {\n\t\t\tCHECK_ARGC\n\t\t\tscale_str = strdup(argv[++i]);\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strcmp(arg, \"-geometry\")) {\n\t\t\tCHECK_ARGC\n\t\t\tscale_str = strdup(argv[++i]);\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strcmp(arg, \"-scale_cursor\")) {\n\t\t\tCHECK_ARGC\n\t\t\tscale_cursor_str = strdup(argv[++i]);\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strcmp(arg, \"-viewonly\")) {\n\t\t\tview_only = 1;\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strcmp(arg, \"-noviewonly\")) {\n\t\t\tview_only = 0;\n\t\t\tgot_noviewonly = 1;\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strcmp(arg, \"-shared\")) {\n\t\t\tshared = 1;\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strcmp(arg, \"-noshared\")) {\n\t\t\tshared = 0;\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strcmp(arg, \"-once\")) {\n\t\t\tconnect_once = 1;\n\t\t\tgot_connect_once = 1;\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strcmp(arg, \"-many\") || !strcmp(arg, \"-forever\")) {\n\t\t\tconnect_once = 0;\n\t\t\tcontinue;\n\t\t}\n\t\tif (strstr(arg, \"-loop\") == arg) {\n\t\t\t;\t/* handled above */\n\t\t\tcontinue;\n\t\t}\n\t\tif (strstr(arg, \"-appshare\") == arg) {\n\t\t\t;\t/* handled above */\n\t\t\tcontinue;\n\t\t}\n\t\tif (strstr(arg, \"-freeze_when_obscured\") == arg) {\n\t\t\tfreeze_when_obscured = 1;\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strcmp(arg, \"-timeout\")) {\n\t\t\tCHECK_ARGC\n\t\t\tfirst_conn_timeout = atoi(argv[++i]);\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strcmp(arg, \"-sleepin\")) {\n\t\t\tCHECK_ARGC\n\t\t\tdo_sleepin(argv[++i]);\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strcmp(arg, \"-users\")) {\n\t\t\tCHECK_ARGC\n\t\t\tusers_list = strdup(argv[++i]);\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strcmp(arg, \"-inetd\")) {\n\t\t\tinetd = 1;\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strcmp(arg, \"-notightfilexfer\")) {\n\t\t\ttightfilexfer = 0;\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strcmp(arg, \"-tightfilexfer\")) {\n\t\t\ttightfilexfer = 1;\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strcmp(arg, \"-http\")) {\n\t\t\ttry_http = 1;\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strcmp(arg, \"-http_ssl\")) {\n\t\t\ttry_http = 1;\n\t\t\thttp_ssl = 1;\n\t\t\tgot_tls++;\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strcmp(arg, \"-avahi\") || !strcmp(arg, \"-mdns\") || !strcmp(arg, \"-zeroconf\")) {\n\t\t\tavahi = 1;\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strcmp(arg, \"-connect\") ||\n\t\t    !strcmp(arg, \"-connect_or_exit\") ||\n\t\t    !strcmp(arg, \"-coe\")) {\n\t\t\tCHECK_ARGC\n\t\t\tif (!strcmp(arg, \"-connect_or_exit\")) {\n\t\t\t\tconnect_or_exit = 1;\n\t\t\t} else if (!strcmp(arg, \"-coe\")) {\n\t\t\t\tconnect_or_exit = 1;\n\t\t\t}\n\t\t\tif (strchr(argv[++i], '/') && !strstr(argv[i], \"repeater://\")) {\n\t\t\t\tstruct stat sb;\n\t\t\t\tclient_connect_file = strdup(argv[i]);\n\t\t\t\tif (stat(client_connect_file, &sb) != 0) {\n\t\t\t\t\tFILE* f = fopen(client_connect_file, \"w\");\n\t\t\t\t\tif (f != NULL) fclose(f);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tclient_connect = strdup(argv[i]);\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strcmp(arg, \"-proxy\")) {\n\t\t\tCHECK_ARGC\n\t\t\tconnect_proxy = strdup(argv[++i]);\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strcmp(arg, \"-vncconnect\")) {\n\t\t\tvnc_connect = 1;\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strcmp(arg, \"-novncconnect\")) {\n\t\t\tvnc_connect = 0;\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strcmp(arg, \"-allow\")) {\n\t\t\tCHECK_ARGC\n\t\t\tallow_list = strdup(argv[++i]);\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strcmp(arg, \"-localhost\")) {\n\t\t\tallow_list = strdup(\"127.0.0.1\");\n\t\t\tgot_localhost = 1;\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strcmp(arg, \"-unixsock\")) {\n\t\t\tCHECK_ARGC\n\t\t\tunix_sock = strdup(argv[++i]);\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strcmp(arg, \"-listen6\")) {\n\t\t\tCHECK_ARGC\n#if X11VNC_IPV6\n\t\t\tlisten_str6 = strdup(argv[++i]);\n#else\n\t\t\t++i;\n#endif\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strcmp(arg, \"-nolookup\")) {\n\t\t\thost_lookup = 0;\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strcmp(arg, \"-6\")) {\n#if X11VNC_IPV6\n\t\t\tipv6_listen = 1;\n\t\t\tgot_ipv6_listen = 1;\n#endif\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strcmp(arg, \"-no6\")) {\n#if X11VNC_IPV6\n\t\t\tipv6_listen = 0;\n\t\t\tgot_ipv6_listen = 0;\n#endif\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strcmp(arg, \"-noipv6\")) {\n\t\t\tnoipv6 = 1;\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strcmp(arg, \"-noipv4\")) {\n\t\t\tnoipv4 = 1;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!strcmp(arg, \"-input\")) {\n\t\t\tCHECK_ARGC\n\t\t\tallowed_input_str = strdup(argv[++i]);\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strcmp(arg, \"-grabkbd\")) {\n\t\t\tgrab_kbd = 1;\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strcmp(arg, \"-grabptr\")) {\n\t\t\tgrab_ptr = 1;\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strcmp(arg, \"-ungrabboth\")) {\n\t\t\tungrab_both = 1;\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strcmp(arg, \"-grabalways\")) {\n\t\t\tgrab_kbd = 1;\n\t\t\tgrab_ptr = 1;\n\t\t\tgrab_always = 1;\n\t\t\tcontinue;\n\t\t}\n#ifdef ENABLE_GRABLOCAL\n\t\tif (!strcmp(arg, \"-grablocal\")) {\n\t\t\tCHECK_ARGC\n\t\t\tgrab_local = atoi(argv[++i]);\n\t\t\tcontinue;\n\t\t}\n#endif\n\t\tif (!strcmp(arg, \"-viewpasswd\")) {\n\t\t\tvpw_loc = i;\n\t\t\tCHECK_ARGC\n\t\t\tviewonly_passwd = strdup(argv[++i]);\n\t\t\tgot_viewpasswd = 1;\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strcmp(arg, \"-passwdfile\")) {\n\t\t\tCHECK_ARGC\n\t\t\tpasswdfile = strdup(argv[++i]);\n\t\t\tgot_passwdfile = 1;\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strcmp(arg, \"-svc\") || !strcmp(arg, \"-service\")) {\n\t\t\tuse_dpy = strdup(\"WAIT:cmd=FINDCREATEDISPLAY-Xvfb\");\n\t\t\tunixpw = 1;\n\t\t\tusers_list = strdup(\"unixpw=\");\n\t\t\tuse_openssl = 1;\n\t\t\topenssl_pem = strdup(\"SAVE\");\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strcmp(arg, \"-svc_xdummy\")) {\n\t\t\tuse_dpy = strdup(\"WAIT:cmd=FINDCREATEDISPLAY-Xdummy\");\n\t\t\tunixpw = 1;\n\t\t\tusers_list = strdup(\"unixpw=\");\n\t\t\tuse_openssl = 1;\n\t\t\topenssl_pem = strdup(\"SAVE\");\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strcmp(arg, \"-svc_xdummy_xvfb\")) {\n\t\t\tuse_dpy = strdup(\"WAIT:cmd=FINDCREATEDISPLAY-Xdummy,Xvfb\");\n\t\t\tunixpw = 1;\n\t\t\tusers_list = strdup(\"unixpw=\");\n\t\t\tuse_openssl = 1;\n\t\t\topenssl_pem = strdup(\"SAVE\");\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strcmp(arg, \"-svc_xvnc\")) {\n\t\t\tuse_dpy = strdup(\"WAIT:cmd=FINDCREATEDISPLAY-Xvnc\");\n\t\t\tunixpw = 1;\n\t\t\tusers_list = strdup(\"unixpw=\");\n\t\t\tuse_openssl = 1;\n\t\t\topenssl_pem = strdup(\"SAVE\");\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strcmp(arg, \"-xdmsvc\") || !strcmp(arg, \"-xdm_service\")) {\n\t\t\tuse_dpy = strdup(\"WAIT:cmd=FINDCREATEDISPLAY-Xvfb.xdmcp\");\n\t\t\tunixpw = 1;\n\t\t\tusers_list = strdup(\"unixpw=\");\n\t\t\tuse_openssl = 1;\n\t\t\topenssl_pem = strdup(\"SAVE\");\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strcmp(arg, \"-sshxdmsvc\")) {\n\t\t\tuse_dpy = strdup(\"WAIT:cmd=FINDCREATEDISPLAY-Xvfb.xdmcp\");\n\t\t\tallow_list = strdup(\"127.0.0.1\");\n\t\t\tgot_localhost = 1;\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strcmp(arg, \"-unixpw_system_greeter\")) {\n\t\t\tunixpw_system_greeter = 1;\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strcmp(arg, \"-unixpw_cmd\")\n\t\t    || !strcmp(arg, \"-unixpw_cmd_unsafe\")) {\n\t\t\tCHECK_ARGC\n\t\t\tunixpw_cmd = strdup(argv[++i]);\n\t\t\tunixpw = 1;\n\t\t\tif (strstr(arg, \"_unsafe\")) {\n\t\t\t\t/* hidden option for testing. */\n\t\t\t\tset_env(\"UNIXPW_DISABLE_SSL\", \"1\");\n\t\t\t\tset_env(\"UNIXPW_DISABLE_LOCALHOST\", \"1\");\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\t\tif (strstr(arg, \"-unixpw\") == arg) {\n\t\t\tunixpw = 1;\n\t\t\tif (strstr(arg, \"-unixpw_nis\")) {\n\t\t\t\tunixpw_nis = 1;\n\t\t\t}\n\t\t\tif (i < argc-1) {\n\t\t\t\tchar *s = argv[i+1];\n\t\t\t\tif (s[0] != '-') {\n\t\t\t\t\tunixpw_list = strdup(s);\n\t\t\t\t\ti++;\n\t\t\t\t}\n\t\t\t\tif (s[0] == '%') {\n\t\t\t\t\tunixpw_list = NULL;\n\t\t\t\t\tquick_pw(s);\n\t\t\t\t\texit(2);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (strstr(arg, \"_unsafe\")) {\n\t\t\t\t/* hidden option for testing. */\n\t\t\t\tset_env(\"UNIXPW_DISABLE_SSL\", \"1\");\n\t\t\t\tset_env(\"UNIXPW_DISABLE_LOCALHOST\", \"1\");\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\t\tif (strstr(arg, \"-nounixpw\") == arg) {\n\t\t\tunixpw = 0;\n\t\t\tunixpw_nis = 0;\n\t\t\tif (unixpw_list) {\n\t\t\t\tunixpw_list = NULL;\n\t\t\t}\n\t\t\tif (unixpw_cmd) {\n\t\t\t\tunixpw_cmd = NULL;\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strcmp(arg, \"-vencrypt\")) {\n\t\t\tchar *s;\n\t\t\tCHECK_ARGC\n\t\t\ts = strdup(argv[++i]);\n\t\t\tgot_tls++;\n\t\t\tif (strstr(s, \"never\")) {\n\t\t\t\tvencrypt_mode = VENCRYPT_NONE;\n\t\t\t} else if (strstr(s, \"support\")) {\n\t\t\t\tvencrypt_mode = VENCRYPT_SUPPORT;\n\t\t\t} else if (strstr(s, \"only\")) {\n\t\t\t\tvencrypt_mode = VENCRYPT_SOLE;\n\t\t\t} else if (strstr(s, \"force\")) {\n\t\t\t\tvencrypt_mode = VENCRYPT_FORCE;\n\t\t\t} else {\n\t\t\t\tfprintf(stderr, \"invalid %s arg: %s\\n\", arg, s);\n\t\t\t\texit(1);\n\t\t\t}\n\t\t\tif (strstr(s, \"nodh\")) {\n\t\t\t\tvencrypt_kx = VENCRYPT_NODH;\n\t\t\t} else if (strstr(s, \"nox509\")) {\n\t\t\t\tvencrypt_kx = VENCRYPT_NOX509;\n\t\t\t}\n\t\t\tif (strstr(s, \"newdh\")) {\n\t\t\t\tcreate_fresh_dhparams = 1;\n\t\t\t}\n\t\t\tif (strstr(s, \"noplain\")) {\n\t\t\t\tvencrypt_enable_plain_login = 0;\n\t\t\t} else if (strstr(s, \"plain\")) {\n\t\t\t\tvencrypt_enable_plain_login = 1;\n\t\t\t}\n\t\t\tfree(s);\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strcmp(arg, \"-anontls\")) {\n\t\t\tchar *s;\n\t\t\tCHECK_ARGC\n\t\t\ts = strdup(argv[++i]);\n\t\t\tgot_tls++;\n\t\t\tif (strstr(s, \"never\")) {\n\t\t\t\tanontls_mode = ANONTLS_NONE;\n\t\t\t} else if (strstr(s, \"support\")) {\n\t\t\t\tanontls_mode = ANONTLS_SUPPORT;\n\t\t\t} else if (strstr(s, \"only\")) {\n\t\t\t\tanontls_mode = ANONTLS_SOLE;\n\t\t\t} else if (strstr(s, \"force\")) {\n\t\t\t\tanontls_mode = ANONTLS_FORCE;\n\t\t\t} else {\n\t\t\t\tfprintf(stderr, \"invalid %s arg: %s\\n\", arg, s);\n\t\t\t\texit(1);\n\t\t\t}\n\t\t\tif (strstr(s, \"newdh\")) {\n\t\t\t\tcreate_fresh_dhparams = 1;\n\t\t\t}\n\t\t\tfree(s);\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strcmp(arg, \"-sslonly\")) {\n\t\t\tvencrypt_mode = VENCRYPT_NONE;\n\t\t\tanontls_mode = ANONTLS_NONE;\n\t\t\tgot_tls++;\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strcmp(arg, \"-dhparams\")) {\n\t\t\tCHECK_ARGC\n\t\t\tdhparams_file = strdup(argv[++i]);\n\t\t\tgot_tls++;\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strcmp(arg, \"-nossl\")) {\n\t\t\tuse_openssl = 0;\n\t\t\topenssl_pem = NULL;\n\t\t\tgot_tls = -1000;\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strcmp(arg, \"-ssl\")) {\n\t\t\tuse_openssl = 1;\n\t\t\tif (i < argc-1) {\n\t\t\t\tchar *s = argv[i+1];\n\t\t\t\tif (s[0] != '-') {\n\t\t\t\t\tif (!strcmp(s, \"ADH\")) {\n\t\t\t\t\t\topenssl_pem = strdup(\"ANON\");\n\t\t\t\t\t} else if (!strcmp(s, \"ANONDH\")) {\n\t\t\t\t\t\topenssl_pem = strdup(\"ANON\");\n\t\t\t\t\t} else if (!strcmp(s, \"TMP\")) {\n\t\t\t\t\t\topenssl_pem = NULL;\n\t\t\t\t\t} else {\n\t\t\t\t\t\topenssl_pem = strdup(s);\n\t\t\t\t\t}\n\t\t\t\t\ti++;\n\t\t\t\t} else {\n\t\t\t\t\topenssl_pem = strdup(\"SAVE\");\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\topenssl_pem = strdup(\"SAVE\");\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strcmp(arg, \"-enc\")) {\n\t\t\tuse_openssl = 1;\n\t\t\tCHECK_ARGC\n\t\t\tenc_str = strdup(argv[++i]);\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strcmp(arg, \"-http_oneport\")) {\n\t\t\thttp_oneport_msg = 1;\n\t\t\tuse_openssl = 1;\n\t\t\tenc_str = strdup(\"none\");\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strcmp(arg, \"-ssltimeout\")) {\n\t\t\tCHECK_ARGC\n\t\t\tssl_timeout_secs = atoi(argv[++i]);\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strcmp(arg, \"-sslnofail\")) {\n\t\t\tssl_no_fail = 1;\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strcmp(arg, \"-ssldir\")) {\n\t\t\tCHECK_ARGC\n\t\t\tssl_certs_dir = strdup(argv[++i]);\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strcmp(arg, \"-sslverify\")) {\n\t\t\tCHECK_ARGC\n\t\t\tssl_verify = strdup(argv[++i]);\n\t\t\tgot_tls++;\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strcmp(arg, \"-sslCRL\")) {\n\t\t\tCHECK_ARGC\n\t\t\tssl_crl = strdup(argv[++i]);\n\t\t\tgot_tls++;\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strcmp(arg, \"-sslGenCA\")) {\n\t\t\tchar *cdir = NULL;\n\t\t\tif (i < argc-1) {\n\t\t\t\tchar *s = argv[i+1];\n\t\t\t\tif (s[0] != '-') {\n\t\t\t\t\tcdir = strdup(s);\n\t\t\t\t\ti++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tsslGenCA(cdir);\n\t\t\texit(0);\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strcmp(arg, \"-sslGenCert\")) {\n\t\t\tchar *ty, *nm = NULL;\n\t\t\tif (i >= argc-1) {\n\t\t\t\tfprintf(stderr, \"Must be:\\n\");\n\t\t\t\tfprintf(stderr, \"          x11vnc -sslGenCert server ...\\n\");\n\t\t\t\tfprintf(stderr, \"or        x11vnc -sslGenCert client ...\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\t\t\tty = argv[i+1];\n\t\t\tif (strcmp(ty, \"server\") && strcmp(ty, \"client\")) {\n\t\t\t\tfprintf(stderr, \"Must be:\\n\");\n\t\t\t\tfprintf(stderr, \"          x11vnc -sslGenCert server ...\\n\");\n\t\t\t\tfprintf(stderr, \"or        x11vnc -sslGenCert client ...\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\t\t\tif (i < argc-2) {\n\t\t\t\tnm = argv[i+2];\n\t\t\t}\n\t\t\tsslGenCert(ty, nm);\n\t\t\texit(0);\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strcmp(arg, \"-sslEncKey\")) {\n\t\t\tif (i < argc-1) {\n\t\t\t\tchar *s = argv[i+1];\n\t\t\t\tsslEncKey(s, 0);\n\t\t\t}\n\t\t\texit(0);\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strcmp(arg, \"-sslCertInfo\")) {\n\t\t\tif (i < argc-1) {\n\t\t\t\tchar *s = argv[i+1];\n\t\t\t\tsslEncKey(s, 1);\n\t\t\t}\n\t\t\texit(0);\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strcmp(arg, \"-sslDelCert\")) {\n\t\t\tif (i < argc-1) {\n\t\t\t\tchar *s = argv[i+1];\n\t\t\t\tsslEncKey(s, 2);\n\t\t\t}\n\t\t\texit(0);\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strcmp(arg, \"-sslScripts\")) {\n\t\t\tsslScripts();\n\t\t\texit(0);\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strcmp(arg, \"-stunnel\")) {\n\t\t\tuse_stunnel = 1;\n\t\t\tgot_tls = -1000;\n\t\t\tif (i < argc-1) {\n\t\t\t\tchar *s = argv[i+1];\n\t\t\t\tif (s[0] != '-') {\n\t\t\t\t\tif (!strcmp(s, \"TMP\")) {\n\t\t\t\t\t\tstunnel_pem = NULL;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tstunnel_pem = strdup(s);\n\t\t\t\t\t}\n\t\t\t\t\ti++;\n\t\t\t\t} else {\n\t\t\t\t\tstunnel_pem = strdup(\"SAVE\");\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tstunnel_pem = strdup(\"SAVE\");\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strcmp(arg, \"-stunnel3\")) {\n\t\t\tuse_stunnel = 3;\n\t\t\tgot_tls = -1000;\n\t\t\tif (i < argc-1) {\n\t\t\t\tchar *s = argv[i+1];\n\t\t\t\tif (s[0] != '-') {\n\t\t\t\t\tif (!strcmp(s, \"TMP\")) {\n\t\t\t\t\t\tstunnel_pem = NULL;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tstunnel_pem = strdup(s);\n\t\t\t\t\t}\n\t\t\t\t\ti++;\n\t\t\t\t} else {\n\t\t\t\t\tstunnel_pem = strdup(\"SAVE\");\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tstunnel_pem = strdup(\"SAVE\");\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strcmp(arg, \"-https\")) {\n\t\t\thttps_port_num = 0;\n\t\t\ttry_http = 1;\n\t\t\tgot_tls++;\n\t\t\tif (i < argc-1) {\n\t\t\t\tchar *s = argv[i+1];\n\t\t\t\tif (s[0] != '-') {\n\t\t\t\t\thttps_port_num = atoi(s);\n\t\t\t\t\ti++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strcmp(arg, \"-httpsredir\")) {\n\t\t\thttps_port_redir = -1;\n\t\t\tgot_tls++;\n\t\t\tif (i < argc-1) {\n\t\t\t\tchar *s = argv[i+1];\n\t\t\t\tif (s[0] != '-') {\n\t\t\t\t\thttps_port_redir = atoi(s);\n\t\t\t\t\ti++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strcmp(arg, \"-nopw\")) {\n\t\t\tnopw = 1;\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strcmp(arg, \"-ssh\")) {\n\t\t\tCHECK_ARGC\n\t\t\tssh_str = strdup(argv[++i]);\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strcmp(arg, \"-usepw\")) {\n\t\t\tusepw = 1;\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strcmp(arg, \"-storepasswd\")) {\n\t\t\tif (argc == i+1) {\n\t\t\t\tstore_homedir_passwd(NULL);\n\t\t\t\texit(0);\n\t\t\t}\n\t\t\tif (argc == i+2) {\n\t\t\t\tstore_homedir_passwd(argv[i+1]);\n\t\t\t\texit(0);\n\t\t\t}\n\t\t\tif (argc >= i+4 || rfbEncryptAndStorePasswd(argv[i+1],\n\t\t\t    argv[i+2]) != 0) {\n\t\t\t\tperror(\"storepasswd\");\n\t\t\t\tfprintf(stderr, \"-storepasswd failed for file: %s\\n\",\n\t\t\t\t    argv[i+2]);\n\t\t\t\texit(1);\n\t\t\t} else {\n\t\t\t\tfprintf(stderr, \"stored passwd in file: %s\\n\",\n\t\t\t\t    argv[i+2]);\n\t\t\t\texit(0);\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strcmp(arg, \"-showrfbauth\")) {\n\t\t\tif (argc >= i+2) {\n\t\t\t\tchar *f = argv[i+1];\n\t\t\t\tchar *s = rfbDecryptPasswdFromFile(f);\n\t\t\t\tif (!s) {\n\t\t\t\t\tperror(\"showrfbauth\");\n\t\t\t\t\tfprintf(stderr, \"rfbDecryptPasswdFromFile failed: %s\\n\", f);\n\t\t\t\t\texit(1);\n\t\t\t\t}\n\t\t\t\tfprintf(stdout, \"rfbDecryptPasswdFromFile file: %s\\n\", f);\n\t\t\t\tfprintf(stdout, \"rfbDecryptPasswdFromFile pass: %s\\n\", s);\n\t\t\t}\n\t\t\texit(0);\n\t\t}\n\t\tif (!strcmp(arg, \"-accept\")) {\n\t\t\tCHECK_ARGC\n\t\t\taccept_cmd = strdup(argv[++i]);\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strcmp(arg, \"-afteraccept\")) {\n\t\t\tCHECK_ARGC\n\t\t\tafteraccept_cmd = strdup(argv[++i]);\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strcmp(arg, \"-gone\")) {\n\t\t\tCHECK_ARGC\n\t\t\tgone_cmd = strdup(argv[++i]);\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strcmp(arg, \"-noshm\")) {\n\t\t\tusing_shm = 0;\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strcmp(arg, \"-flipbyteorder\")) {\n\t\t\tflip_byte_order = 1;\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strcmp(arg, \"-onetile\")) {\n\t\t\tsingle_copytile = 1;\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strcmp(arg, \"-solid\")) {\n\t\t\tuse_solid_bg = 1;\n\t\t\tif (i < argc-1) {\n\t\t\t\tchar *s = argv[i+1];\n\t\t\t\tif (s[0] != '-') {\n\t\t\t\t\tsolid_str = strdup(s);\n\t\t\t\t\ti++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (! solid_str) {\n\t\t\t\tsolid_str = strdup(solid_default);\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strcmp(arg, \"-blackout\")) {\n\t\t\tCHECK_ARGC\n\t\t\tblackout_str = strdup(argv[++i]);\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strcmp(arg, \"-xinerama\")) {\n\t\t\txinerama = 1;\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strcmp(arg, \"-noxinerama\")) {\n\t\t\txinerama = 0;\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strcmp(arg, \"-xtrap\")) {\n\t\t\txtrap_input = 1;\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strcmp(arg, \"-xrandr\")) {\n\t\t\txrandr = 1;\n\t\t\tif (i < argc-1) {\n\t\t\t\tchar *s = argv[i+1];\n\t\t\t\tif (known_xrandr_mode(s)) {\n\t\t\t\t\txrandr_mode = strdup(s);\n\t\t\t\t\ti++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strcmp(arg, \"-noxrandr\")) {\n\t\t\txrandr = 0;\n\t\t\txrandr_maybe = 0;\n\t\t\tgot_noxrandr = 1;\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strcmp(arg, \"-rotate\")) {\n\t\t\tCHECK_ARGC\n\t\t\trotating_str = strdup(argv[++i]);\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strcmp(arg, \"-padgeom\")\n\t\t    || !strcmp(arg, \"-padgeometry\")) {\n\t\t\tCHECK_ARGC\n\t\t\tpad_geometry = strdup(argv[++i]);\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strcmp(arg, \"-o\") || !strcmp(arg, \"-logfile\")) {\n\t\t\tCHECK_ARGC\n\t\t\tlogfile_append = 0;\n\t\t\tlogfile = strdup(argv[++i]);\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strcmp(arg, \"-oa\") || !strcmp(arg, \"-logappend\")) {\n\t\t\tCHECK_ARGC\n\t\t\tlogfile_append = 1;\n\t\t\tlogfile = strdup(argv[++i]);\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strcmp(arg, \"-flag\")) {\n\t\t\tCHECK_ARGC\n\t\t\tflagfile = strdup(argv[++i]);\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strcmp(arg, \"-rmflag\")) {\n\t\t\tCHECK_ARGC\n\t\t\trm_flagfile = strdup(argv[++i]);\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strcmp(arg, \"-rc\")) {\n\t\t\ti++;\t/* done above */\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strcmp(arg, \"-norc\")) {\n\t\t\t;\t/* done above */\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strcmp(arg, \"-env\")) {\n\t\t\ti++;\t/* done above */\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strcmp(arg, \"-prog\")) {\n\t\t\tCHECK_ARGC\n\t\t\tif (program_name) {\n\t\t\t\tfree(program_name);\n\t\t\t}\n\t\t\tprogram_name = strdup(argv[++i]);\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strcmp(arg, \"-h\") || !strcmp(arg, \"-help\")) {\n\t\t\tprint_help(0);\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strcmp(arg, \"-?\") || !strcmp(arg, \"-opts\")) {\n\t\t\tprint_help(1);\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strcmp(arg, \"-V\") || !strcmp(arg, \"-version\")) {\n\t\t\tfprintf(stdout, \"x11vnc: %s\\n\", lastmod);\n\t\t\texit(0);\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strcmp(arg, \"-license\") ||\n\t\t    !strcmp(arg, \"-copying\") || !strcmp(arg, \"-warranty\")) {\n\t\t\tprint_license();\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strcmp(arg, \"-dbg\")) {\n\t\t\tcrash_debug = 1;\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strcmp(arg, \"-nodbg\")) {\n\t\t\tcrash_debug = 0;\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strcmp(arg, \"-q\") || !strcmp(arg, \"-quiet\")) {\n\t\t\tquiet = 1;\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strcmp(arg, \"-noquiet\")) {\n\t\t\tquiet = 0;\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strcmp(arg, \"-v\") || !strcmp(arg, \"-verbose\")) {\n\t\t\tverbose = 1;\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strcmp(arg, \"-bg\") || !strcmp(arg, \"-background\")) {\n#if HAVE_SETSID\n\t\t\tbg = 1;\n\t\t\topts_bg = bg;\n#else\n\t\t\tif (!got_inetd) {\n\t\t\t\tfprintf(stderr, \"warning: -bg mode not supported.\\n\");\n\t\t\t}\n#endif\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strcmp(arg, \"-modtweak\")) {\n\t\t\tuse_modifier_tweak = 1;\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strcmp(arg, \"-nomodtweak\")) {\n\t\t\tuse_modifier_tweak = 0;\n\t\t\tgot_nomodtweak = 1;\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strcmp(arg, \"-isolevel3\")) {\n\t\t\tuse_iso_level3 = 1;\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strcmp(arg, \"-xkb\")) {\n\t\t\tuse_modifier_tweak = 1;\n\t\t\tuse_xkb_modtweak = 1;\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strcmp(arg, \"-noxkb\")) {\n\t\t\tuse_xkb_modtweak = 0;\n\t\t\tgot_noxkb = 1;\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strcmp(arg, \"-capslock\")) {\n\t\t\twatch_capslock = 1;\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strcmp(arg, \"-skip_lockkeys\")) {\n\t\t\tskip_lockkeys = 1;\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strcmp(arg, \"-noskip_lockkeys\")) {\n\t\t\tskip_lockkeys = 0;\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strcmp(arg, \"-xkbcompat\")) {\n\t\t\txkbcompat = 1;\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strcmp(arg, \"-skip_keycodes\")) {\n\t\t\tCHECK_ARGC\n\t\t\tskip_keycodes = strdup(argv[++i]);\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strcmp(arg, \"-sloppy_keys\")) {\n\t\t\tsloppy_keys++;\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strcmp(arg, \"-skip_dups\")) {\n\t\t\tskip_duplicate_key_events = 1;\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strcmp(arg, \"-noskip_dups\")) {\n\t\t\tskip_duplicate_key_events = 0;\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strcmp(arg, \"-add_keysyms\")) {\n\t\t\tadd_keysyms++;\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strcmp(arg, \"-noadd_keysyms\")) {\n\t\t\tadd_keysyms = 0;\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strcmp(arg, \"-clear_mods\")) {\n\t\t\tclear_mods = 1;\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strcmp(arg, \"-clear_keys\")) {\n\t\t\tclear_mods = 2;\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strcmp(arg, \"-clear_all\")) {\n\t\t\tclear_mods = 3;\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strcmp(arg, \"-remap\")) {\n\t\t\tCHECK_ARGC\n\t\t\tremap_file = strdup(argv[++i]);\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strcmp(arg, \"-norepeat\")) {\n\t\t\tno_autorepeat = 1;\n\t\t\tif (i < argc-1) {\n\t\t\t\tchar *s = argv[i+1];\n\t\t\t\tif (*s == '-') {\n\t\t\t\t\ts++;\n\t\t\t\t}\n\t\t\t\tif (isdigit((unsigned char) (*s))) {\n\t\t\t\t\tno_repeat_countdown = atoi(argv[++i]);\n\t\t\t\t}\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strcmp(arg, \"-repeat\")) {\n\t\t\tno_autorepeat = 0;\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strcmp(arg, \"-nofb\")) {\n\t\t\tnofb = 1;\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strcmp(arg, \"-nobell\")) {\n\t\t\twatch_bell = 0;\n\t\t\tsound_bell = 0;\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strcmp(arg, \"-nosel\")) {\n\t\t\twatch_selection = 0;\n\t\t\twatch_primary = 0;\n\t\t\twatch_clipboard = 0;\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strcmp(arg, \"-noprimary\")) {\n\t\t\twatch_primary = 0;\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strcmp(arg, \"-nosetprimary\")) {\n\t\t\tset_primary = 0;\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strcmp(arg, \"-noclipboard\")) {\n\t\t\twatch_clipboard = 0;\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strcmp(arg, \"-nosetclipboard\")) {\n\t\t\tset_clipboard = 0;\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strcmp(arg, \"-seldir\")) {\n\t\t\tCHECK_ARGC\n\t\t\tsel_direction = strdup(argv[++i]);\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strcmp(arg, \"-cursor\")) {\n\t\t\tshow_cursor = 1;\n\t\t\tif (i < argc-1) {\n\t\t\t\tchar *s = argv[i+1];\n\t\t\t\tif (known_cursors_mode(s)) {\n\t\t\t\t\tmultiple_cursors_mode = strdup(s);\n\t\t\t\t\ti++;\n\t\t\t\t\tif (!strcmp(s, \"none\")) {\n\t\t\t\t\t\tshow_cursor = 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strcmp(arg, \"-nocursor\")) { \n\t\t\tmultiple_cursors_mode = strdup(\"none\");\n\t\t\tshow_cursor = 0;\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strcmp(arg, \"-cursor_drag\")) { \n\t\t\tcursor_drag_changes = 1;\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strcmp(arg, \"-nocursor_drag\")) { \n\t\t\tcursor_drag_changes = 0;\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strcmp(arg, \"-arrow\")) {\n\t\t\tCHECK_ARGC\n\t\t\talt_arrow = atoi(argv[++i]);\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strcmp(arg, \"-xfixes\")) { \n\t\t\tuse_xfixes = 1;\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strcmp(arg, \"-noxfixes\")) { \n\t\t\tuse_xfixes = 0;\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strcmp(arg, \"-alphacut\")) {\n\t\t\tCHECK_ARGC\n\t\t\talpha_threshold = atoi(argv[++i]);\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strcmp(arg, \"-alphafrac\")) {\n\t\t\tCHECK_ARGC\n\t\t\talpha_frac = atof(argv[++i]);\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strcmp(arg, \"-alpharemove\")) {\n\t\t\talpha_remove = 1;\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strcmp(arg, \"-noalphablend\")) {\n\t\t\talpha_blend = 0;\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strcmp(arg, \"-nocursorshape\")) {\n\t\t\tcursor_shape_updates = 0;\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strcmp(arg, \"-cursorpos\")) {\n\t\t\tcursor_pos_updates = 1;\n\t\t\tgot_cursorpos = 1;\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strcmp(arg, \"-nocursorpos\")) {\n\t\t\tcursor_pos_updates = 0;\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strcmp(arg, \"-xwarppointer\")) {\n\t\t\tuse_xwarppointer = 1;\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strcmp(arg, \"-noxwarppointer\")) {\n\t\t\tuse_xwarppointer = 0;\n\t\t\tgot_noxwarppointer = 1;\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strcmp(arg, \"-always_inject\")) {\n\t\t\talways_inject = 1;\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strcmp(arg, \"-buttonmap\")) {\n\t\t\tCHECK_ARGC\n\t\t\tpointer_remap = strdup(argv[++i]);\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strcmp(arg, \"-nodragging\")) {\n\t\t\tshow_dragging = 0;\n\t\t\tcontinue;\n\t\t}\n#ifndef NO_NCACHE\n\t\tif (!strcmp(arg, \"-ncache\") || !strcmp(arg, \"-nc\")) {\n\t\t\tif (i < argc-1) {\n\t\t\t\tchar *s = argv[i+1];\n\t\t\t\tif (s[0] != '-') {\n\t\t\t\t\tncache = atoi(s);\n\t\t\t\t\ti++;\n\t\t\t\t} else {\n\t\t\t\t\tncache = ncache_default;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tncache = ncache_default;\n\t\t\t}\n\t\t\tif (ncache % 2 != 0) {\n\t\t\t\tncache++;\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strcmp(arg, \"-noncache\") || !strcmp(arg, \"-nonc\")) {\n\t\t\tncache = 0;\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strcmp(arg, \"-ncache_cr\") || !strcmp(arg, \"-nc_cr\")) {\n\t\t\tncache_copyrect = 1;\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strcmp(arg, \"-ncache_no_moveraise\") || !strcmp(arg, \"-nc_no_moveraise\")) {\n\t\t\tncache_wf_raises = 1;\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strcmp(arg, \"-ncache_no_dtchange\") || !strcmp(arg, \"-nc_no_dtchange\")) {\n\t\t\tncache_dt_change = 0;\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strcmp(arg, \"-ncache_no_rootpixmap\") || !strcmp(arg, \"-nc_no_rootpixmap\")) {\n\t\t\tncache_xrootpmap = 0;\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strcmp(arg, \"-ncache_keep_anims\") || !strcmp(arg, \"-nc_keep_anims\")) {\n\t\t\tncache_keep_anims = 1;\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strcmp(arg, \"-ncache_old_wm\") || !strcmp(arg, \"-nc_old_wm\")) {\n\t\t\tncache_old_wm = 1;\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strcmp(arg, \"-ncache_pad\") || !strcmp(arg, \"-nc_pad\")) {\n\t\t\tCHECK_ARGC\n\t\t\tncache_pad = atoi(argv[++i]);\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strcmp(arg, \"-debug_ncache\")) {\n\t\t\tncdb++;\n\t\t\tcontinue;\n\t\t}\n#endif\n\t\tif (!strcmp(arg, \"-wireframe\")\n\t\t    || !strcmp(arg, \"-wf\")) {\n\t\t\twireframe = 1;\n\t\t\tif (i < argc-1) {\n\t\t\t\tchar *s = argv[i+1];\n\t\t\t\tif (*s != '-') {\n\t\t\t\t\twireframe_str = strdup(argv[++i]);\n\t\t\t\t}\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strcmp(arg, \"-nowireframe\")\n\t\t    || !strcmp(arg, \"-nowf\")) {\n\t\t\twireframe = 0;\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strcmp(arg, \"-nowireframelocal\")\n\t\t    || !strcmp(arg, \"-nowfl\")) {\n\t\t\twireframe_local = 0;\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strcmp(arg, \"-wirecopyrect\")\n\t\t    || !strcmp(arg, \"-wcr\")) {\n\t\t\tCHECK_ARGC\n\t\t\tset_wirecopyrect_mode(argv[++i]);\n\t\t\tgot_wirecopyrect = 1;\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strcmp(arg, \"-nowirecopyrect\")\n\t\t    || !strcmp(arg, \"-nowcr\")) {\n\t\t\tset_wirecopyrect_mode(\"never\");\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strcmp(arg, \"-debug_wireframe\")\n\t\t    || !strcmp(arg, \"-dwf\")) {\n\t\t\tdebug_wireframe++;\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strcmp(arg, \"-scrollcopyrect\")\n\t\t    || !strcmp(arg, \"-scr\")) {\n\t\t\tCHECK_ARGC\n\t\t\tset_scrollcopyrect_mode(argv[++i]);\n\t\t\tgot_scrollcopyrect = 1;\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strcmp(arg, \"-noscrollcopyrect\")\n\t\t    || !strcmp(arg, \"-noscr\")) {\n\t\t\tset_scrollcopyrect_mode(\"never\");\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strcmp(arg, \"-scr_area\")) {\n\t\t\tint tn;\n\t\t\tCHECK_ARGC\n\t\t\ttn = atoi(argv[++i]);\n\t\t\tif (tn >= 0) {\n\t\t\t\tscrollcopyrect_min_area = tn;\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strcmp(arg, \"-scr_skip\")) {\n\t\t\tCHECK_ARGC\n\t\t\tscroll_skip_str = strdup(argv[++i]);\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strcmp(arg, \"-scr_inc\")) {\n\t\t\tCHECK_ARGC\n\t\t\tscroll_good_str = strdup(argv[++i]);\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strcmp(arg, \"-scr_keys\")) {\n\t\t\tCHECK_ARGC\n\t\t\tscroll_key_list_str = strdup(argv[++i]);\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strcmp(arg, \"-scr_term\")) {\n\t\t\tCHECK_ARGC\n\t\t\tscroll_term_str = strdup(argv[++i]);\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strcmp(arg, \"-scr_keyrepeat\")) {\n\t\t\tCHECK_ARGC\n\t\t\tmax_keyrepeat_str = strdup(argv[++i]);\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strcmp(arg, \"-scr_parms\")) {\n\t\t\tCHECK_ARGC\n\t\t\tscroll_copyrect_str = strdup(argv[++i]);\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strcmp(arg, \"-fixscreen\")) {\n\t\t\tCHECK_ARGC\n\t\t\tscreen_fixup_str = strdup(argv[++i]);\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strcmp(arg, \"-debug_scroll\")\n\t\t    || !strcmp(arg, \"-ds\")) {\n\t\t\tdebug_scroll++;\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strcmp(arg, \"-noxrecord\")) {\n\t\t\tnoxrecord = 1;\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strcmp(arg, \"-pointer_mode\")\n\t\t    || !strcmp(arg, \"-pm\")) {\n\t\t\tchar *p, *s;\n\t\t\tCHECK_ARGC\n\t\t\ts = argv[++i];\n\t\t\tif ((p = strchr(s, ':')) != NULL) {\n\t\t\t\tui_skip = atoi(p+1);\n\t\t\t\tif (! ui_skip) ui_skip = 1;\n\t\t\t\t*p = '\\0';\n\t\t\t}\n\t\t\tif (atoi(s) < 1 || atoi(s) > pointer_mode_max) {\n\t\t\t\tif (!got_inetd) {\n\t\t\t\t\trfbLog(\"pointer_mode out of range 1-%d: %d\\n\",\n\t\t\t\t\t    pointer_mode_max, atoi(s));\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tpointer_mode = atoi(s);\n\t\t\t\tgot_pointer_mode = pointer_mode;\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strcmp(arg, \"-input_skip\")) {\n\t\t\tCHECK_ARGC\n\t\t\tui_skip = atoi(argv[++i]);\n\t\t\tif (! ui_skip) ui_skip = 1;\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strcmp(arg, \"-allinput\")) {\n\t\t\tall_input = 1;\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strcmp(arg, \"-noallinput\")) {\n\t\t\tall_input = 0;\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strcmp(arg, \"-input_eagerly\")) {\n\t\t\thandle_events_eagerly = 1;\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strcmp(arg, \"-noinput_eagerly\")) {\n\t\t\thandle_events_eagerly = 0;\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strcmp(arg, \"-speeds\")) {\n\t\t\tCHECK_ARGC\n\t\t\tspeeds_str = strdup(argv[++i]);\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strcmp(arg, \"-wmdt\")) {\n\t\t\tCHECK_ARGC\n\t\t\twmdt_str = strdup(argv[++i]);\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strcmp(arg, \"-debug_pointer\")\n\t\t    || !strcmp(arg, \"-dp\")) {\n\t\t\tdebug_pointer++;\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strcmp(arg, \"-debug_keyboard\")\n\t\t    || !strcmp(arg, \"-dk\")) {\n\t\t\tdebug_keyboard++;\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strcmp(arg, \"-debug_xdamage\")) {\n\t\t\tdebug_xdamage++;\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strcmp(arg, \"-defer\")) {\n\t\t\tCHECK_ARGC\n\t\t\tdefer_update = atoi(argv[++i]);\n\t\t\tgot_defer = 1;\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strcmp(arg, \"-setdefer\")) {\n\t\t\tCHECK_ARGC\n\t\t\tset_defer = atoi(argv[++i]);\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strcmp(arg, \"-wait\")) {\n\t\t\tCHECK_ARGC\n\t\t\twaitms = atoi(argv[++i]);\n\t\t\tgot_waitms = 1;\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strcmp(arg, \"-extra_fbur\")) {\n\t\t\tCHECK_ARGC\n\t\t\textra_fbur = atoi(argv[++i]);\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strcmp(arg, \"-wait_ui\")) {\n\t\t\tCHECK_ARGC\n\t\t\twait_ui = atof(argv[++i]);\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strcmp(arg, \"-nowait_bog\")) {\n\t\t\twait_bog = 0;\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strcmp(arg, \"-slow_fb\")) {\n\t\t\tCHECK_ARGC\n\t\t\tslow_fb = atof(argv[++i]);\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strcmp(arg, \"-xrefresh\")) {\n\t\t\tCHECK_ARGC\n\t\t\txrefresh = atof(argv[++i]);\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strcmp(arg, \"-readtimeout\")) {\n\t\t\tCHECK_ARGC\n\t\t\trfbMaxClientWait = atoi(argv[++i]) * 1000;\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strcmp(arg, \"-ping\")) {\n\t\t\tCHECK_ARGC\n\t\t\tping_interval = atoi(argv[++i]);\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strcmp(arg, \"-nap\")) {\n\t\t\ttake_naps = 1;\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strcmp(arg, \"-nonap\")) {\n\t\t\ttake_naps = 0;\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strcmp(arg, \"-sb\")) {\n\t\t\tCHECK_ARGC\n\t\t\tscreen_blank = atoi(argv[++i]);\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strcmp(arg, \"-nofbpm\")) {\n\t\t\twatch_fbpm = 1;\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strcmp(arg, \"-fbpm\")) {\n\t\t\twatch_fbpm = 0;\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strcmp(arg, \"-nodpms\")) {\n\t\t\twatch_dpms = 1;\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strcmp(arg, \"-dpms\")) {\n\t\t\twatch_dpms = 0;\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strcmp(arg, \"-forcedpms\")) {\n\t\t\tforce_dpms = 1;\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strcmp(arg, \"-clientdpms\")) {\n\t\t\tclient_dpms = 1;\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strcmp(arg, \"-noserverdpms\")) {\n\t\t\tno_ultra_dpms = 1;\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strcmp(arg, \"-noultraext\")) {\n\t\t\tno_ultra_ext = 1;\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strcmp(arg, \"-chatwindow\")) {\n\t\t\tchat_window = 1;\n\t\t\tif (argc_vnc + 1 < argc_vnc_max) {\n\t\t\t\tif (!got_inetd) {\n\t\t\t\t\trfbLog(\"setting '-rfbversion 3.6' for -chatwindow.\\n\");\n\t\t\t\t}\n\t\t\t\targv_vnc[argc_vnc++] = strdup(\"-rfbversion\");\n\t\t\t\targv_vnc[argc_vnc++] = strdup(\"3.6\");\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strcmp(arg, \"-xdamage\")) {\n\t\t\tuse_xdamage++;\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strcmp(arg, \"-noxdamage\")) {\n\t\t\tuse_xdamage = 0;\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strcmp(arg, \"-xd_area\")) {\n\t\t\tint tn;\n\t\t\tCHECK_ARGC\n\t\t\ttn = atoi(argv[++i]);\n\t\t\tif (tn >= 0) {\n\t\t\t\txdamage_max_area = tn;\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strcmp(arg, \"-xd_mem\")) {\n\t\t\tdouble f;\n\t\t\tCHECK_ARGC\n\t\t\tf = atof(argv[++i]);\n\t\t\tif (f >= 0.0) {\n\t\t\t\txdamage_memory = f;\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strcmp(arg, \"-xcomposite\")) {\n\t\t\tuse_xcomposite++;\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strcmp(arg, \"-noxcomposite\")) {\n\t\t\tuse_xcomposite = 0;\n\t\t\tcontinue;\n\t\t}\n#ifdef HAVE_XI2\n                if (!strcmp(arg, \"-multiptr\")) {\n                        use_multipointer++;\n \t\t\tcontinue;\n \t\t}\n#endif\n\n\t\tif (!strcmp(arg, \"-sigpipe\") || !strcmp(arg, \"-sig\")) {\n\t\t\tCHECK_ARGC\n\t\t\tif (known_sigpipe_mode(argv[++i])) {\n\t\t\t\tsigpipe = strdup(argv[i]);\n\t\t\t} else {\n\t\t\t\tfprintf(stderr, \"invalid -sigpipe arg: %s, must\"\n\t\t\t\t    \" be \\\"ignore\\\" or \\\"exit\\\"\\n\", argv[i]);\n\t\t\t\texit(1);\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n#if LIBVNCSERVER_HAVE_LIBPTHREAD\n\t\tif (!strcmp(arg, \"-threads\")) {\n#if defined(X11VNC_THREADED)\n\t\t\tuse_threads = 1;\n#else\n\t\t\tif (getenv(\"X11VNC_THREADED\")) {\n\t\t\t\tuse_threads = 1;\n\t\t\t} else if (1) {\n\t\t\t\t/* we re-enable it due to threaded mode bugfixes. */\n\t\t\t\tuse_threads = 1;\n\t\t\t} else {\n\t\t\t\tif (!got_inetd) {\n\t\t\t\t\trfbLog(\"\\n\");\n\t\t\t\t\trfbLog(\"The -threads mode is unstable and not tested or maintained.\\n\");\n\t\t\t\t\trfbLog(\"It is disabled in the source code.  If you really need\\n\");\n\t\t\t\t\trfbLog(\"the feature you can reenable it at build time by setting\\n\");\n\t\t\t\t\trfbLog(\"-DX11VNC_THREADED in CPPFLAGS. Or set X11VNC_THREADED=1\\n\");\n\t\t\t\t\trfbLog(\"in your runtime environment.\\n\");\n\t\t\t\t\trfbLog(\"\\n\");\n\t\t\t\t\tusleep(500*1000);\n\t\t\t\t}\n\t\t\t}\n#endif\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strcmp(arg, \"-nothreads\")) {\n\t\t\tuse_threads = 0;\n\t\t\tcontinue;\n\t\t}\n#endif\n\t\tif (!strcmp(arg, \"-fs\")) {\n\t\t\tCHECK_ARGC\n\t\t\tfs_frac = atof(argv[++i]);\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strcmp(arg, \"-gaps\")) {\n\t\t\tCHECK_ARGC\n\t\t\tgaps_fill = atoi(argv[++i]);\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strcmp(arg, \"-grow\")) {\n\t\t\tCHECK_ARGC\n\t\t\tgrow_fill = atoi(argv[++i]);\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strcmp(arg, \"-fuzz\")) {\n\t\t\tCHECK_ARGC\n\t\t\ttile_fuzz = atoi(argv[++i]);\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strcmp(arg, \"-debug_tiles\")\n\t\t    || !strcmp(arg, \"-dbt\")) {\n\t\t\tdebug_tiles++;\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strcmp(arg, \"-debug_grabs\")) {\n\t\t\tdebug_grabs++;\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strcmp(arg, \"-debug_sel\")) {\n\t\t\tdebug_sel++;\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strcmp(arg, \"-grab_buster\")) {\n\t\t\tgrab_buster++;\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strcmp(arg, \"-nograb_buster\")) {\n\t\t\tgrab_buster = 0;\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strcmp(arg, \"-snapfb\")) {\n\t\t\tuse_snapfb = 1;\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strcmp(arg, \"-rand\")) {\n\t\t\t/* equiv. to -nopw -rawfb rand for quick tests */\n\t\t\traw_fb_str = strdup(\"rand\");\n\t\t\tnopw = 1;\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strcmp(arg, \"-rawfb\")) {\n\t\t\tCHECK_ARGC\n\t\t\traw_fb_str = strdup(argv[++i]);\n\t\t\tif (strstr(raw_fb_str, \"vnc:\") == raw_fb_str) {\n\t\t\t\tshared = 1;\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strcmp(arg, \"-freqtab\")) {\n\t\t\tCHECK_ARGC\n\t\t\tfreqtab = strdup(argv[++i]);\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strcmp(arg, \"-pipeinput\")) {\n\t\t\tCHECK_ARGC\n\t\t\tpipeinput_str = strdup(argv[++i]);\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strcmp(arg, \"-macnodim\")) {\n\t\t\tmacosx_nodimming = 1;\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strcmp(arg, \"-macnosleep\")) {\n\t\t\tmacosx_nosleep = 1;\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strcmp(arg, \"-macnosaver\")) {\n\t\t\tmacosx_noscreensaver = 1;\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strcmp(arg, \"-macnowait\")) {\n\t\t\tmacosx_wait_for_switch = 0;\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strcmp(arg, \"-macwheel\")) {\n\t\t\tCHECK_ARGC\n\t\t\tmacosx_mouse_wheel_speed = atoi(argv[++i]);\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strcmp(arg, \"-macnoswap\")) {\n\t\t\tmacosx_swap23 = 0;\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strcmp(arg, \"-macnoresize\")) {\n\t\t\tmacosx_resize = 0;\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strcmp(arg, \"-maciconanim\")) {\n\t\t\tCHECK_ARGC\n\t\t\tmacosx_icon_anim_time = atoi(argv[++i]);\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strcmp(arg, \"-macmenu\")) {\n\t\t\tmacosx_ncache_macmenu = 1;\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strcmp(arg, \"-macuskbd\")) {\n\t\t\tmacosx_us_kbd = 1;\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strcmp(arg, \"-macnoopengl\")) {\n\t\t\tmacosx_no_opengl = 1;\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strcmp(arg, \"-macnorawfb\")) {\n\t\t\tmacosx_no_rawfb = 1;\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strcmp(arg, \"-gui\")) {\n\t\t\tlaunch_gui = 1;\n\t\t\tif (i < argc-1) {\n\t\t\t\tchar *s = argv[i+1];\n\t\t\t\tif (*s != '-') {\n\t\t\t\t\tgui_str = strdup(s);\n\t\t\t\t\tif (strstr(gui_str, \"setp\")) {\n\t\t\t\t\t\tgot_gui_pw = 1;\n\t\t\t\t\t}\n\t\t\t\t\ti++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strcmp(arg, \"-remote\") || !strcmp(arg, \"-R\")\n\t\t    || !strcmp(arg, \"-r\") || !strcmp(arg, \"-remote-control\")) {\n\t\t\tchar *str;\n\t\t\tCHECK_ARGC\n\t\t\ti++;\n\t\t\tstr = argv[i];\n\t\t\tif (*str == '-') {\n\t\t\t\t/* accidental leading '-' */\n\t\t\t\tstr++;\n\t\t\t}\n\t\t\tif (!strcmp(str, \"ping\")) {\n\t\t\t\tquery_cmd = strdup(str);\n\t\t\t} else {\n\t\t\t\tremote_cmd = strdup(str);\n\t\t\t}\n\t\t\tif (remote_cmd && strchr(remote_cmd, ':') == NULL) {\n\t\t\t    /* interpret -R -scale 3/4 at least */\n\t\t \t    if (i < argc-1 && *(argv[i+1]) != '-') {\n\t\t\t\tint n;\n\n\t\t\t\t/* it must be the parameter value */\n\t\t\t\ti++;\n\t\t\t\tn = strlen(remote_cmd) + strlen(argv[i]) + 2;\n\n\t\t\t\tstr = (char *) malloc(n);\n\t\t\t\tsprintf(str, \"%s:%s\", remote_cmd, argv[i]);\n\t\t\t\tfree(remote_cmd);\n\t\t\t\tremote_cmd = str;\n\t\t\t    }\n\t\t\t}\n\t\t\tif (!getenv(\"QUERY_VERBOSE\")) {\n\t\t\t\tquiet = 1;\n\t\t\t}\n\t\t\txkbcompat = 0;\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strcmp(arg, \"-query\") || !strcmp(arg, \"-Q\")) {\n\t\t\tCHECK_ARGC\n\t\t\tquery_cmd = strdup(argv[++i]);\n\t\t\tif (!getenv(\"QUERY_VERBOSE\")) {\n\t\t\t\tquiet = 1;\n\t\t\t}\n\t\t\txkbcompat = 0;\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strcmp(arg, \"-query_retries\")) {\n\t\t\tchar *s;\n\t\t\tCHECK_ARGC\n\t\t\ts = strdup(argv[++i]);\n\t\t\t/* n[:t][/match] */\n\t\t\tif (strchr(s, '/')) {\n\t\t\t\tchar *q = strchr(s, '/');\n\t\t\t\tquery_match = strdup(q+1);\n\t\t\t\t*q = '\\0';\n\t\t\t}\n\t\t\tif (strchr(s, ':')) {\n\t\t\t\tchar *q = strchr(s, ':');\n\t\t\t\tquery_delay = atof(q+1);\n\t\t\t}\n\t\t\tquery_retries = atoi(s);\n\t\t\tfree(s);\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strcmp(arg, \"-QD\")) {\n\t\t\tCHECK_ARGC\n\t\t\tquery_cmd = strdup(argv[++i]);\n\t\t\tquery_default = 1;\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strcmp(arg, \"-sync\")) {\n\t\t\tremote_sync = 1;\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strcmp(arg, \"-nosync\")) {\n\t\t\tremote_sync = 0;\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strcmp(arg, \"-remote_prefix\")) {\n\t\t\tCHECK_ARGC\n\t\t\tremote_prefix = strdup(argv[++i]);\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strcmp(arg, \"-noremote\")) {\n\t\t\taccept_remote_cmds = 0;\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strcmp(arg, \"-yesremote\")) {\n\t\t\taccept_remote_cmds = 1;\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strcmp(arg, \"-unsafe\")) {\n\t\t\tsafe_remote_only = 0;\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strcmp(arg, \"-privremote\")) {\n\t\t\tpriv_remote = 1;\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strcmp(arg, \"-safer\")) {\n\t\t\tmore_safe = 1;\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strcmp(arg, \"-nocmds\")) {\n\t\t\tno_external_cmds = 1;\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strcmp(arg, \"-allowedcmds\")) {\n\t\t\tCHECK_ARGC\n\t\t\tallowed_external_cmds = strdup(argv[++i]);\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strcmp(arg, \"-deny_all\")) {\n\t\t\tdeny_all = 1;\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strcmp(arg, \"-httpdir\")) {\n\t\t\tCHECK_ARGC\n\t\t\thttp_dir = strdup(argv[++i]);\n\t\t\tgot_httpdir = 1;\n\t\t\tcontinue;\n\t\t}\n\t\tif (1) {\n\t\t\tif (!strcmp(arg, \"-desktop\") && i < argc-1) {\n\t\t\t\tdt = 1;\n\t\t\t\trfb_desktop_name = strdup(argv[i+1]);\n\t\t\t}\n\t\t\tif (!strcmp(arg, \"-passwd\")) {\n\t\t\t\tpw_loc = i;\n\t\t\t\tgot_passwd = 1;\n\t\t\t}\n\t\t\tif (!strcmp(arg, \"-rfbauth\")) {\n\t\t\t\tgot_rfbauth = 1;\n\t\t\t}\n\t\t\tif (!strcmp(arg, \"-rfbwait\")) {\n\t\t\t\tgot_rfbwait = 1;\n\t\t\t}\n\t\t\tif (!strcmp(arg, \"-deferupdate\")) {\n\t\t\t\tgot_deferupdate = 1;\n\t\t\t}\n\t\t\tif (!strcmp(arg, \"-rfbport\") && i < argc-1) {\n\t\t\t\tgot_rfbport = 1;\n\t\t\t\tif (!strcasecmp(argv[i+1], \"prompt\")) {\n\t\t\t\t\t;\n\t\t\t\t} else if (!is_decimal(argv[i+1])) {\n\t\t\t\t\tif (!got_inetd) {\n\t\t\t\t\t\trfbLog(\"Invalid -rfbport value: '%s'\\n\", argv[i+1]);\n\t\t\t\t\t\trfbLog(\"setting it to '-1' to induce failure.\\n\");\n\t\t\t\t\t\targv[i+1] = strdup(\"-1\");\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tgot_rfbport_str = strdup(argv[i+1]);\n\t\t\t\tgot_rfbport_pos = argc_vnc+1;\n\t\t\t\tgot_rfbport_val = atoi(argv[i+1]);\n\t\t\t}\n\t\t\tif (!strcmp(arg, \"-httpport\") && i < argc-1) {\n\t\t\t\tif (!is_decimal(argv[i+1])) {\n\t\t\t\t\trfbLog(\"Invalid -httpport value: '%s'\\n\", argv[i+1]);\n\t\t\t\t\tclean_up_exit(1);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!strcmp(arg, \"-alwaysshared \")) {\n\t\t\t\tgot_alwaysshared = 1;\n\t\t\t}\n\t\t\tif (!strcmp(arg, \"-nevershared\")) {\n\t\t\t\tgot_nevershared = 1;\n\t\t\t}\n\t\t\tif (!strcmp(arg, \"-listen\") && i < argc-1) {\n\t\t\t\tlisten_str = strdup(argv[i+1]);\n\t\t\t}\n\t\t\t/* otherwise copy it for libvncserver use below. */\n\t\t\tif (!strcmp(arg, \"-ultrafilexfer\")) {\n\t\t\t\tgot_ultrafilexfer = 1;\n\t\t\t} else if (argc_vnc < argc_vnc_max) {\n\t\t\t\targv_vnc[argc_vnc++] = strdup(arg);\n\t\t\t} else {\n\t\t\t\trfbLog(\"too many arguments.\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\t}",
    "includes": [
      "#include \"xi2_devices.h\"",
      "#include \"solid.h\"",
      "#include \"pm.h\"",
      "#include \"selection.h\"",
      "#include \"sslhelper.h\"",
      "#include \"sslcmds.h\"",
      "#include \"inet.h\"",
      "#include \"unixpw.h\"",
      "#include \"rates.h\"",
      "#include \"connections.h\"",
      "#include \"screen.h\"",
      "#include \"userinput.h\"",
      "#include \"cursor.h\"",
      "#include \"pointer.h\"",
      "#include \"keyboard.h\"",
      "#include \"cleanup.h\"",
      "#include \"user.h\"",
      "#include \"help.h\"",
      "#include \"gui.h\"",
      "#include \"scan.h\"",
      "#include \"remote.h\"",
      "#include \"win_utils.h\"",
      "#include \"xkb_bell.h\"",
      "#include \"xrandr.h\"",
      "#include \"xinerama.h\"",
      "#include \"xevents.h\"",
      "#include \"xrecord.h\"",
      "#include \"xdamage.h\"",
      "#include \"xwrappers.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void check_rcfile(int argc, char **argv);",
      "static void immediate_switch_user(int argc, char* argv[]);",
      "static void print_settings(int try_http, int bg, char *gui_str);",
      "static void check_loop_mode(int argc, char* argv[], int force);",
      "static void check_appshare_mode(int argc, char* argv[]);",
      "static int argc2 = 0;",
      "static char **argv2;",
      "extern int appshare_main(int argc, char* argv[]);",
      "extern int is_decimal(char *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "1"
          ],
          "line": 4164
        },
        "resolved": true,
        "details": {
          "function_name": "clean_up_exit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/cleanup.c",
          "lines": "151-266",
          "snippet": "void clean_up_exit(int ret) {\n\tstatic int depth = 0;\n\texit_flag = 1;\n\n\tif (depth++ > 2) {\n\t\texit(ret);\n\t}\n\n\tif (icon_mode) {\n\t\tclean_icon_mode();\n\t}\n\n\t/* remove the shm areas: */\n\tclean_shm(0);\n\n\tstop_stunnel();\n\tif (use_openssl) {\n\t\tssl_helper_pid(0, 0);\t/* killall */\n\t}\n\n\tif (ssh_pid > 0) {\n\t\tkill(ssh_pid, SIGTERM);\n\t\tssh_pid = 0;\n\t}\n\n#ifdef MACOSX\n\tif (client_connect_file) {\n\t\tif (strstr(client_connect_file, \"/tmp/x11vnc-macosx-remote\")\n\t\t    == client_connect_file) {\n\t\t\tunlink(client_connect_file);\n\t\t}\n\t}\n\tif (macosx_console) {\n\t\tmacosxCG_fini();\n\t}\n#endif\n\n\tif (pipeinput_fh != NULL) {\n\t\tpclose(pipeinput_fh);\n\t\tpipeinput_fh = NULL;\n\t}\n\n\tshutdown_uinput();\n\n\tif (unix_sock) {\n\t\tif (unix_sock_fd >= 0) {\n\t\t\trfbLog(\"deleting unix sock: %s\\n\", unix_sock);\n\t\t\tclose(unix_sock_fd);\n\t\t\tunix_sock_fd = -1;\n\t\t\tunlink(unix_sock);\n\t\t}\n\t}\n\n\tif (! dpy) {\t/* raw_rb hack */\n\t\tif (rm_flagfile) {\n\t\t\tunlink(rm_flagfile);\n\t\t\trm_flagfile = NULL;\n\t\t}\n\t\texit(ret);\n\t}\n\n\t/* X keyboard cleanups */\n\tdelete_added_keycodes(0);\n\n\t/* remove all created XInput2 devices */\n\tif(use_multipointer)\n\t    removeAllMDs(dpy);\n\n\tif (clear_mods == 1) {\n\t\tclear_modifiers(0);\n\t} else if (clear_mods == 2) {\n\t\tclear_keys();\n\t} else if (clear_mods == 3) {\n\t\tclear_keys();\n\t\tclear_locks();\n\t}\n\n\tif (no_autorepeat) {\n\t\tautorepeat(1, 0);\n\t}\n\tif (use_solid_bg) {\n\t\tsolid_bg(1);\n\t}\n\tif (ncache || ncache0) {\n\t\tkde_no_animate(1);\n\t}\n\tX_LOCK;\n\tXTestDiscard_wr(dpy);\n#if HAVE_LIBXDAMAGE\n\tif (xdamage) {\n\t\tXDamageDestroy(dpy, xdamage);\n\t}\n#endif\n#if HAVE_LIBXTRAP\n\tif (trap_ctx) {\n\t\tXEFreeTC(trap_ctx);\n\t}\n#endif\n\t/* XXX rdpy_ctrl, etc. cannot close w/o blocking */\n\tXCloseDisplay_wr(dpy);\n\tX_UNLOCK;\n\n\tfflush(stderr);\n\n\tif (rm_flagfile) {\n\t\tunlink(rm_flagfile);\n\t\trm_flagfile = NULL;\n\t}\n\n\tif (avahi) {\n\t\tavahi_cleanup();\n\t\tfflush(stderr);\n\t}\n\n\texit(ret);\n}",
          "includes": [
            "#include \"xi2_devices.h\"",
            "#include \"uinput.h\"",
            "#include \"xevents.h\"",
            "#include \"xrecord.h\"",
            "#include \"screen.h\"",
            "#include \"avahi.h\"",
            "#include \"macosxCG.h\"",
            "#include \"macosx.h\"",
            "#include \"connections.h\"",
            "#include \"sslhelper.h\"",
            "#include \"sslcmds.h\"",
            "#include \"unixpw.h\"",
            "#include \"solid.h\"",
            "#include \"gui.h\"",
            "#include \"scan.h\"",
            "#include \"keyboard.h\"",
            "#include \"remote.h\"",
            "#include \"xdamage.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void clean_up_exit(int ret);",
            "int known_sigpipe_mode(char *s);",
            "static int exit_flag = 0;",
            "static void clean_icon_mode(void);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xi2_devices.h\"\n#include \"uinput.h\"\n#include \"xevents.h\"\n#include \"xrecord.h\"\n#include \"screen.h\"\n#include \"avahi.h\"\n#include \"macosxCG.h\"\n#include \"macosx.h\"\n#include \"connections.h\"\n#include \"sslhelper.h\"\n#include \"sslcmds.h\"\n#include \"unixpw.h\"\n#include \"solid.h\"\n#include \"gui.h\"\n#include \"scan.h\"\n#include \"keyboard.h\"\n#include \"remote.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nvoid clean_up_exit(int ret);\nint known_sigpipe_mode(char *s);\nstatic int exit_flag = 0;\nstatic void clean_icon_mode(void);\n\nvoid clean_up_exit(int ret) {\n\tstatic int depth = 0;\n\texit_flag = 1;\n\n\tif (depth++ > 2) {\n\t\texit(ret);\n\t}\n\n\tif (icon_mode) {\n\t\tclean_icon_mode();\n\t}\n\n\t/* remove the shm areas: */\n\tclean_shm(0);\n\n\tstop_stunnel();\n\tif (use_openssl) {\n\t\tssl_helper_pid(0, 0);\t/* killall */\n\t}\n\n\tif (ssh_pid > 0) {\n\t\tkill(ssh_pid, SIGTERM);\n\t\tssh_pid = 0;\n\t}\n\n#ifdef MACOSX\n\tif (client_connect_file) {\n\t\tif (strstr(client_connect_file, \"/tmp/x11vnc-macosx-remote\")\n\t\t    == client_connect_file) {\n\t\t\tunlink(client_connect_file);\n\t\t}\n\t}\n\tif (macosx_console) {\n\t\tmacosxCG_fini();\n\t}\n#endif\n\n\tif (pipeinput_fh != NULL) {\n\t\tpclose(pipeinput_fh);\n\t\tpipeinput_fh = NULL;\n\t}\n\n\tshutdown_uinput();\n\n\tif (unix_sock) {\n\t\tif (unix_sock_fd >= 0) {\n\t\t\trfbLog(\"deleting unix sock: %s\\n\", unix_sock);\n\t\t\tclose(unix_sock_fd);\n\t\t\tunix_sock_fd = -1;\n\t\t\tunlink(unix_sock);\n\t\t}\n\t}\n\n\tif (! dpy) {\t/* raw_rb hack */\n\t\tif (rm_flagfile) {\n\t\t\tunlink(rm_flagfile);\n\t\t\trm_flagfile = NULL;\n\t\t}\n\t\texit(ret);\n\t}\n\n\t/* X keyboard cleanups */\n\tdelete_added_keycodes(0);\n\n\t/* remove all created XInput2 devices */\n\tif(use_multipointer)\n\t    removeAllMDs(dpy);\n\n\tif (clear_mods == 1) {\n\t\tclear_modifiers(0);\n\t} else if (clear_mods == 2) {\n\t\tclear_keys();\n\t} else if (clear_mods == 3) {\n\t\tclear_keys();\n\t\tclear_locks();\n\t}\n\n\tif (no_autorepeat) {\n\t\tautorepeat(1, 0);\n\t}\n\tif (use_solid_bg) {\n\t\tsolid_bg(1);\n\t}\n\tif (ncache || ncache0) {\n\t\tkde_no_animate(1);\n\t}\n\tX_LOCK;\n\tXTestDiscard_wr(dpy);\n#if HAVE_LIBXDAMAGE\n\tif (xdamage) {\n\t\tXDamageDestroy(dpy, xdamage);\n\t}\n#endif\n#if HAVE_LIBXTRAP\n\tif (trap_ctx) {\n\t\tXEFreeTC(trap_ctx);\n\t}\n#endif\n\t/* XXX rdpy_ctrl, etc. cannot close w/o blocking */\n\tXCloseDisplay_wr(dpy);\n\tX_UNLOCK;\n\n\tfflush(stderr);\n\n\tif (rm_flagfile) {\n\t\tunlink(rm_flagfile);\n\t\trm_flagfile = NULL;\n\t}\n\n\tif (avahi) {\n\t\tavahi_cleanup();\n\t\tfflush(stderr);\n\t}\n\n\texit(ret);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"too many arguments.\\n\""
          ],
          "line": 4163
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "arg"
          ],
          "line": 4161
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "arg",
            "\"-ultrafilexfer\""
          ],
          "line": 4158
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "argv[i+1]"
          ],
          "line": 4155
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "arg",
            "\"-listen\""
          ],
          "line": 4154
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "arg",
            "\"-nevershared\""
          ],
          "line": 4151
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "arg",
            "\"-alwaysshared \""
          ],
          "line": 4148
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"Invalid -httpport value: '%s'\\n\"",
            "argv[i+1]"
          ],
          "line": 4144
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_decimal",
          "args": [
            "argv[i+1]"
          ],
          "line": 4143
        },
        "resolved": true,
        "details": {
          "function_name": "is_decimal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/util.c",
          "lines": "181-199",
          "snippet": "int is_decimal(char *str) {\n\tchar *p = str;\n\tif (p != NULL) {\n\t\tint first = 1;\n\t\twhile (*p != '\\0') {\n\t\t\tif (first && *p == '-') {\n\t\t\t\t;\n\t\t\t} else if (isdigit((int) *p)) {\n\t\t\t\t;\n\t\t\t} else {\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tfirst = 0;\n\t\t\tp++;\n\t\t}\n\t\treturn 1;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"connections.h\"",
            "#include \"unixpw.h\"",
            "#include \"win_utils.h\"",
            "#include \"cleanup.h\"",
            "#include \"x11vnc.h\"",
            "#include <stdlib.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void lowercase(char *str);",
            "void uppercase(char *str);",
            "char *lblanks(char *str);",
            "void strzero(char *str);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"connections.h\"\n#include \"unixpw.h\"\n#include \"win_utils.h\"\n#include \"cleanup.h\"\n#include \"x11vnc.h\"\n#include <stdlib.h>\n\nvoid lowercase(char *str);\nvoid uppercase(char *str);\nchar *lblanks(char *str);\nvoid strzero(char *str);\n\nint is_decimal(char *str) {\n\tchar *p = str;\n\tif (p != NULL) {\n\t\tint first = 1;\n\t\twhile (*p != '\\0') {\n\t\t\tif (first && *p == '-') {\n\t\t\t\t;\n\t\t\t} else if (isdigit((int) *p)) {\n\t\t\t\t;\n\t\t\t} else {\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tfirst = 0;\n\t\t\tp++;\n\t\t}\n\t\treturn 1;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "arg",
            "\"-httpport\""
          ],
          "line": 4142
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atoi",
          "args": [
            "argv[i+1]"
          ],
          "line": 4140
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "argv[i+1]"
          ],
          "line": 4138
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "\"-1\""
          ],
          "line": 4135
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"setting it to '-1' to induce failure.\\n\""
          ],
          "line": 4134
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"Invalid -rfbport value: '%s'\\n\"",
            "argv[i+1]"
          ],
          "line": 4133
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcasecmp",
          "args": [
            "argv[i+1]",
            "\"prompt\""
          ],
          "line": 4129
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "arg",
            "\"-rfbport\""
          ],
          "line": 4127
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "arg",
            "\"-deferupdate\""
          ],
          "line": 4124
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "arg",
            "\"-rfbwait\""
          ],
          "line": 4121
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "arg",
            "\"-rfbauth\""
          ],
          "line": 4118
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "arg",
            "\"-passwd\""
          ],
          "line": 4114
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "argv[i+1]"
          ],
          "line": 4112
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "arg",
            "\"-desktop\""
          ],
          "line": 4110
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "argv[++i]"
          ],
          "line": 4105
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "arg",
            "\"-httpdir\""
          ],
          "line": 4103
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "arg",
            "\"-deny_all\""
          ],
          "line": 4099
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "argv[++i]"
          ],
          "line": 4096
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "arg",
            "\"-allowedcmds\""
          ],
          "line": 4094
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "arg",
            "\"-nocmds\""
          ],
          "line": 4090
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "arg",
            "\"-safer\""
          ],
          "line": 4086
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "arg",
            "\"-privremote\""
          ],
          "line": 4082
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "arg",
            "\"-unsafe\""
          ],
          "line": 4078
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "arg",
            "\"-yesremote\""
          ],
          "line": 4074
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "arg",
            "\"-noremote\""
          ],
          "line": 4070
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "argv[++i]"
          ],
          "line": 4067
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "arg",
            "\"-remote_prefix\""
          ],
          "line": 4065
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "arg",
            "\"-nosync\""
          ],
          "line": 4061
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "arg",
            "\"-sync\""
          ],
          "line": 4057
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "argv[++i]"
          ],
          "line": 4053
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "arg",
            "\"-QD\""
          ],
          "line": 4051
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "s"
          ],
          "line": 4048
        },
        "resolved": true,
        "details": {
          "function_name": "free_rect",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/userinput.c",
          "lines": "6200-6247",
          "snippet": "int free_rect(int idx) {\n\tint n, ok = 0;\n\tsraRegionPtr r1, r2;\n\tint x, y, w, h;\n\n\tif (idx < 0 || idx >= cache_list_num) {\nif (0) fprintf(stderr, \"free_rect: bad index: %d\\n\", idx);\n\t\tclean_up_exit(1);\n\t}\n\n\tx = cache_list[idx].bs_x;\n\ty = cache_list[idx].bs_y;\n\tw = cache_list[idx].bs_w;\n\th = cache_list[idx].bs_h;\n\n\tif (x < 0) {\n\t\tCLEAR(idx);\nif (dnow() > last_client + 5 && ncdb) fprintf(stderr, \"free_rect: already bs_x invalidated: %d bs_x: %d\\n\", idx, x);\n\t\treturn 1;\n\t}\n\n\tr2 = sraRgnCreateRect(x, y, x+w, y+h);\n\n\tn = get_bs_n(y);\n\tif (n >= 0) {\n\t\tr1 = rect_reg[n];\n\t\tsraRgnOr(r1, r2);\n\t\tok = 1;\n\t}\n\n\tif (zero_rects) {\n\t\tsraRgnOr(zero_rects, r2);\n\t\tx = cache_list[idx].su_x;\n\t\ty = cache_list[idx].su_y;\n\t\tw = cache_list[idx].su_w;\n\t\th = cache_list[idx].su_h;\n\t\tif (x >= 0) {\n\t\t\tsraRgnDestroy(r2);\n\t\t\tr2 = sraRgnCreateRect(x, y, x+w, y+h);\n\t\t\tsraRgnOr(zero_rects, r2);\n\t\t}\n\t}\n\tsraRgnDestroy(r2);\n\n\tCLEAR(idx);\nif (! ok && ncdb) fprintf(stderr, \"**** free_rect: not-found %d\\n\", idx);\n\treturn ok;\n}",
          "includes": [
            "#include \"default8x16.h\"",
            "#include \"connections.h\"",
            "#include \"screen.h\"",
            "#include \"cursor.h\"",
            "#include \"macosxCGS.h\"",
            "#include \"macosx.h\"",
            "#include \"unixpw.h\"",
            "#include \"8to24.h\"",
            "#include \"xrandr.h\"",
            "#include \"solid.h\"",
            "#include \"keyboard.h\"",
            "#include \"rates.h\"",
            "#include \"pointer.h\"",
            "#include \"cleanup.h\"",
            "#include \"scan.h\"",
            "#include \"user.h\"",
            "#include \"xevents.h\"",
            "#include \"win_utils.h\"",
            "#include \"xinerama.h\"",
            "#include \"xrecord.h\"",
            "#include \"xdamage.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void mark_for_xdamage(int x, int y, int w, int h);",
            "void set_xdamage_mark(int x, int y, int w, int h);",
            "int find_rect(int idx, int x, int y, int w, int h);",
            "winattr_t *cache_list;",
            "int clipped(int idx);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"default8x16.h\"\n#include \"connections.h\"\n#include \"screen.h\"\n#include \"cursor.h\"\n#include \"macosxCGS.h\"\n#include \"macosx.h\"\n#include \"unixpw.h\"\n#include \"8to24.h\"\n#include \"xrandr.h\"\n#include \"solid.h\"\n#include \"keyboard.h\"\n#include \"rates.h\"\n#include \"pointer.h\"\n#include \"cleanup.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"xevents.h\"\n#include \"win_utils.h\"\n#include \"xinerama.h\"\n#include \"xrecord.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nvoid mark_for_xdamage(int x, int y, int w, int h);\nvoid set_xdamage_mark(int x, int y, int w, int h);\nint find_rect(int idx, int x, int y, int w, int h);\nwinattr_t *cache_list;\nint clipped(int idx);\n\nint free_rect(int idx) {\n\tint n, ok = 0;\n\tsraRegionPtr r1, r2;\n\tint x, y, w, h;\n\n\tif (idx < 0 || idx >= cache_list_num) {\nif (0) fprintf(stderr, \"free_rect: bad index: %d\\n\", idx);\n\t\tclean_up_exit(1);\n\t}\n\n\tx = cache_list[idx].bs_x;\n\ty = cache_list[idx].bs_y;\n\tw = cache_list[idx].bs_w;\n\th = cache_list[idx].bs_h;\n\n\tif (x < 0) {\n\t\tCLEAR(idx);\nif (dnow() > last_client + 5 && ncdb) fprintf(stderr, \"free_rect: already bs_x invalidated: %d bs_x: %d\\n\", idx, x);\n\t\treturn 1;\n\t}\n\n\tr2 = sraRgnCreateRect(x, y, x+w, y+h);\n\n\tn = get_bs_n(y);\n\tif (n >= 0) {\n\t\tr1 = rect_reg[n];\n\t\tsraRgnOr(r1, r2);\n\t\tok = 1;\n\t}\n\n\tif (zero_rects) {\n\t\tsraRgnOr(zero_rects, r2);\n\t\tx = cache_list[idx].su_x;\n\t\ty = cache_list[idx].su_y;\n\t\tw = cache_list[idx].su_w;\n\t\th = cache_list[idx].su_h;\n\t\tif (x >= 0) {\n\t\t\tsraRgnDestroy(r2);\n\t\t\tr2 = sraRgnCreateRect(x, y, x+w, y+h);\n\t\t\tsraRgnOr(zero_rects, r2);\n\t\t}\n\t}\n\tsraRgnDestroy(r2);\n\n\tCLEAR(idx);\nif (! ok && ncdb) fprintf(stderr, \"**** free_rect: not-found %d\\n\", idx);\n\treturn ok;\n}"
        }
      },
      {
        "call_info": {
          "callee": "atoi",
          "args": [
            "s"
          ],
          "line": 4047
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atof",
          "args": [
            "q+1"
          ],
          "line": 4045
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "s",
            "':'"
          ],
          "line": 4044
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "s",
            "':'"
          ],
          "line": 4043
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "q+1"
          ],
          "line": 4040
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "s",
            "'/'"
          ],
          "line": 4039
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "s",
            "'/'"
          ],
          "line": 4038
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "argv[++i]"
          ],
          "line": 4036
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "arg",
            "\"-query_retries\""
          ],
          "line": 4033
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getenv",
          "args": [
            "\"QUERY_VERBOSE\""
          ],
          "line": 4027
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "argv[++i]"
          ],
          "line": 4026
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "arg",
            "\"-Q\""
          ],
          "line": 4024
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "arg",
            "\"-query\""
          ],
          "line": 4024
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getenv",
          "args": [
            "\"QUERY_VERBOSE\""
          ],
          "line": 4018
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "str",
            "\"%s:%s\"",
            "remote_cmd",
            "argv[i]"
          ],
          "line": 4013
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "n"
          ],
          "line": 4012
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "argv[i]"
          ],
          "line": 4010
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "remote_cmd"
          ],
          "line": 4010
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "remote_cmd",
            "':'"
          ],
          "line": 4003
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "str"
          ],
          "line": 4001
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "str"
          ],
          "line": 3999
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "str",
            "\"ping\""
          ],
          "line": 3998
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "arg",
            "\"-remote-control\""
          ],
          "line": 3989
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "arg",
            "\"-r\""
          ],
          "line": 3989
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "arg",
            "\"-R\""
          ],
          "line": 3988
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "arg",
            "\"-remote\""
          ],
          "line": 3988
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "gui_str",
            "\"setp\""
          ],
          "line": 3980
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "s"
          ],
          "line": 3979
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "arg",
            "\"-gui\""
          ],
          "line": 3974
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "arg",
            "\"-macnorawfb\""
          ],
          "line": 3970
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "arg",
            "\"-macnoopengl\""
          ],
          "line": 3966
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "arg",
            "\"-macuskbd\""
          ],
          "line": 3962
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "arg",
            "\"-macmenu\""
          ],
          "line": 3958
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atoi",
          "args": [
            "argv[++i]"
          ],
          "line": 3955
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "arg",
            "\"-maciconanim\""
          ],
          "line": 3953
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "arg",
            "\"-macnoresize\""
          ],
          "line": 3949
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "arg",
            "\"-macnoswap\""
          ],
          "line": 3945
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atoi",
          "args": [
            "argv[++i]"
          ],
          "line": 3942
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "arg",
            "\"-macwheel\""
          ],
          "line": 3940
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "arg",
            "\"-macnowait\""
          ],
          "line": 3936
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "arg",
            "\"-macnosaver\""
          ],
          "line": 3932
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "arg",
            "\"-macnosleep\""
          ],
          "line": 3928
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "arg",
            "\"-macnodim\""
          ],
          "line": 3924
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "argv[++i]"
          ],
          "line": 3921
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "arg",
            "\"-pipeinput\""
          ],
          "line": 3919
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "argv[++i]"
          ],
          "line": 3916
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "arg",
            "\"-freqtab\""
          ],
          "line": 3914
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "raw_fb_str",
            "\"vnc:\""
          ],
          "line": 3909
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "argv[++i]"
          ],
          "line": 3908
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "arg",
            "\"-rawfb\""
          ],
          "line": 3906
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "\"rand\""
          ],
          "line": 3902
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "arg",
            "\"-rand\""
          ],
          "line": 3900
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "arg",
            "\"-snapfb\""
          ],
          "line": 3896
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "arg",
            "\"-nograb_buster\""
          ],
          "line": 3892
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "arg",
            "\"-grab_buster\""
          ],
          "line": 3888
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "arg",
            "\"-debug_sel\""
          ],
          "line": 3884
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "arg",
            "\"-debug_grabs\""
          ],
          "line": 3880
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "arg",
            "\"-dbt\""
          ],
          "line": 3876
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "arg",
            "\"-debug_tiles\""
          ],
          "line": 3875
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atoi",
          "args": [
            "argv[++i]"
          ],
          "line": 3872
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "arg",
            "\"-fuzz\""
          ],
          "line": 3870
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atoi",
          "args": [
            "argv[++i]"
          ],
          "line": 3867
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "arg",
            "\"-grow\""
          ],
          "line": 3865
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atoi",
          "args": [
            "argv[++i]"
          ],
          "line": 3862
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "arg",
            "\"-gaps\""
          ],
          "line": 3860
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atof",
          "args": [
            "argv[++i]"
          ],
          "line": 3857
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "arg",
            "\"-fs\""
          ],
          "line": 3855
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "arg",
            "\"-nothreads\""
          ],
          "line": 3850
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "usleep",
          "args": [
            "500*1000"
          ],
          "line": 3844
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"\\n\""
          ],
          "line": 3843
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"in your runtime environment.\\n\""
          ],
          "line": 3842
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"-DX11VNC_THREADED in CPPFLAGS. Or set X11VNC_THREADED=1\\n\""
          ],
          "line": 3841
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"the feature you can reenable it at build time by setting\\n\""
          ],
          "line": 3840
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"It is disabled in the source code.  If you really need\\n\""
          ],
          "line": 3839
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"The -threads mode is unstable and not tested or maintained.\\n\""
          ],
          "line": 3838
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"\\n\""
          ],
          "line": 3837
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getenv",
          "args": [
            "\"X11VNC_THREADED\""
          ],
          "line": 3830
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "arg",
            "\"-threads\""
          ],
          "line": 3826
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"invalid -sigpipe arg: %s, must\"\n\t\t\t\t    \" be \\\"ignore\\\" or \\\"exit\\\"\\n\"",
            "argv[i]"
          ],
          "line": 3819
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "argv[i]"
          ],
          "line": 3817
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "arg",
            "\"-sig\""
          ],
          "line": 3814
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "arg",
            "\"-sigpipe\""
          ],
          "line": 3814
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "arg",
            "\"-multiptr\""
          ],
          "line": 3808
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "arg",
            "\"-noxcomposite\""
          ],
          "line": 3803
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "arg",
            "\"-xcomposite\""
          ],
          "line": 3799
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atof",
          "args": [
            "argv[++i]"
          ],
          "line": 3793
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "arg",
            "\"-xd_mem\""
          ],
          "line": 3790
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atoi",
          "args": [
            "argv[++i]"
          ],
          "line": 3784
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "arg",
            "\"-xd_area\""
          ],
          "line": 3781
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "arg",
            "\"-noxdamage\""
          ],
          "line": 3777
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "arg",
            "\"-xdamage\""
          ],
          "line": 3773
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "\"3.6\""
          ],
          "line": 3769
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "\"-rfbversion\""
          ],
          "line": 3768
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"setting '-rfbversion 3.6' for -chatwindow.\\n\""
          ],
          "line": 3766
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "arg",
            "\"-chatwindow\""
          ],
          "line": 3762
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "arg",
            "\"-noultraext\""
          ],
          "line": 3758
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "arg",
            "\"-noserverdpms\""
          ],
          "line": 3754
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "arg",
            "\"-clientdpms\""
          ],
          "line": 3750
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "arg",
            "\"-forcedpms\""
          ],
          "line": 3746
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "arg",
            "\"-dpms\""
          ],
          "line": 3742
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "arg",
            "\"-nodpms\""
          ],
          "line": 3738
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "arg",
            "\"-fbpm\""
          ],
          "line": 3734
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "arg",
            "\"-nofbpm\""
          ],
          "line": 3730
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atoi",
          "args": [
            "argv[++i]"
          ],
          "line": 3727
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "arg",
            "\"-sb\""
          ],
          "line": 3725
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "arg",
            "\"-nonap\""
          ],
          "line": 3721
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "arg",
            "\"-nap\""
          ],
          "line": 3717
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atoi",
          "args": [
            "argv[++i]"
          ],
          "line": 3714
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "arg",
            "\"-ping\""
          ],
          "line": 3712
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atoi",
          "args": [
            "argv[++i]"
          ],
          "line": 3709
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "arg",
            "\"-readtimeout\""
          ],
          "line": 3707
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atof",
          "args": [
            "argv[++i]"
          ],
          "line": 3704
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "arg",
            "\"-xrefresh\""
          ],
          "line": 3702
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atof",
          "args": [
            "argv[++i]"
          ],
          "line": 3699
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "arg",
            "\"-slow_fb\""
          ],
          "line": 3697
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "arg",
            "\"-nowait_bog\""
          ],
          "line": 3693
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atof",
          "args": [
            "argv[++i]"
          ],
          "line": 3690
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "arg",
            "\"-wait_ui\""
          ],
          "line": 3688
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atoi",
          "args": [
            "argv[++i]"
          ],
          "line": 3685
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "arg",
            "\"-extra_fbur\""
          ],
          "line": 3683
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atoi",
          "args": [
            "argv[++i]"
          ],
          "line": 3679
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "arg",
            "\"-wait\""
          ],
          "line": 3677
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atoi",
          "args": [
            "argv[++i]"
          ],
          "line": 3674
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "arg",
            "\"-setdefer\""
          ],
          "line": 3672
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atoi",
          "args": [
            "argv[++i]"
          ],
          "line": 3668
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "arg",
            "\"-defer\""
          ],
          "line": 3666
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "arg",
            "\"-debug_xdamage\""
          ],
          "line": 3662
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "arg",
            "\"-dk\""
          ],
          "line": 3658
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "arg",
            "\"-debug_keyboard\""
          ],
          "line": 3657
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "arg",
            "\"-dp\""
          ],
          "line": 3653
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "arg",
            "\"-debug_pointer\""
          ],
          "line": 3652
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "argv[++i]"
          ],
          "line": 3649
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "arg",
            "\"-wmdt\""
          ],
          "line": 3647
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "argv[++i]"
          ],
          "line": 3644
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "arg",
            "\"-speeds\""
          ],
          "line": 3642
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "arg",
            "\"-noinput_eagerly\""
          ],
          "line": 3638
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "arg",
            "\"-input_eagerly\""
          ],
          "line": 3634
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "arg",
            "\"-noallinput\""
          ],
          "line": 3630
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "arg",
            "\"-allinput\""
          ],
          "line": 3626
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atoi",
          "args": [
            "argv[++i]"
          ],
          "line": 3622
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "arg",
            "\"-input_skip\""
          ],
          "line": 3620
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atoi",
          "args": [
            "s"
          ],
          "line": 3615
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"pointer_mode out of range 1-%d: %d\\n\"",
            "pointer_mode_max",
            "atoi(s)"
          ],
          "line": 3611
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atoi",
          "args": [
            "s"
          ],
          "line": 3612
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atoi",
          "args": [
            "s"
          ],
          "line": 3609
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atoi",
          "args": [
            "s"
          ],
          "line": 3609
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atoi",
          "args": [
            "p+1"
          ],
          "line": 3605
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "s",
            "':'"
          ],
          "line": 3604
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "arg",
            "\"-pm\""
          ],
          "line": 3600
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "arg",
            "\"-pointer_mode\""
          ],
          "line": 3599
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "arg",
            "\"-noxrecord\""
          ],
          "line": 3595
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "arg",
            "\"-ds\""
          ],
          "line": 3591
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "arg",
            "\"-debug_scroll\""
          ],
          "line": 3590
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "argv[++i]"
          ],
          "line": 3587
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "arg",
            "\"-fixscreen\""
          ],
          "line": 3585
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "argv[++i]"
          ],
          "line": 3582
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "arg",
            "\"-scr_parms\""
          ],
          "line": 3580
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "argv[++i]"
          ],
          "line": 3577
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "arg",
            "\"-scr_keyrepeat\""
          ],
          "line": 3575
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "argv[++i]"
          ],
          "line": 3572
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "arg",
            "\"-scr_term\""
          ],
          "line": 3570
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "argv[++i]"
          ],
          "line": 3567
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "arg",
            "\"-scr_keys\""
          ],
          "line": 3565
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "argv[++i]"
          ],
          "line": 3562
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "arg",
            "\"-scr_inc\""
          ],
          "line": 3560
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "argv[++i]"
          ],
          "line": 3557
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "arg",
            "\"-scr_skip\""
          ],
          "line": 3555
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atoi",
          "args": [
            "argv[++i]"
          ],
          "line": 3549
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "arg",
            "\"-scr_area\""
          ],
          "line": 3546
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_scrollcopyrect_mode",
          "args": [
            "\"never\""
          ],
          "line": 3543
        },
        "resolved": true,
        "details": {
          "function_name": "set_scrollcopyrect_mode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/userinput.c",
          "lines": "528-553",
          "snippet": "void set_scrollcopyrect_mode(char *str) {\n\tchar *orig = scroll_copyrect;\n\tif (str == NULL || *str == '\\0') {\n\t\tscroll_copyrect = strdup(scroll_copyrect_default);\n\t} else if (!strcmp(str, \"always\") || !strcmp(str, \"all\") ||\n\t\t    !strcmp(str, \"both\")) {\n\t\tscroll_copyrect = strdup(\"always\");\n\t} else if (!strcmp(str, \"keys\") || !strcmp(str, \"keyboard\")) {\n\t\tscroll_copyrect = strdup(\"keys\");\n\t} else if (!strcmp(str, \"mouse\") || !strcmp(str, \"pointer\")) {\n\t\tscroll_copyrect = strdup(\"mouse\");\n\t} else if (!strcmp(str, \"never\") || !strcmp(str, \"none\")) {\n\t\tscroll_copyrect = strdup(\"never\");\n\t} else {\n\t\tif (! scroll_copyrect) {\n\t\t\tscroll_copyrect = strdup(scroll_copyrect_default);\n\t\t} else {\n\t\t\torig = NULL;\n\t\t}\n\t\trfbLog(\"unknown -scrollcopyrect mode: %s, using: %s\\n\", str,\n\t\t    scroll_copyrect);\n\t}\n\tif (orig) {\n\t\tfree(orig);\n\t}\n}",
          "includes": [
            "#include \"default8x16.h\"",
            "#include \"connections.h\"",
            "#include \"screen.h\"",
            "#include \"cursor.h\"",
            "#include \"macosxCGS.h\"",
            "#include \"macosx.h\"",
            "#include \"unixpw.h\"",
            "#include \"8to24.h\"",
            "#include \"xrandr.h\"",
            "#include \"solid.h\"",
            "#include \"keyboard.h\"",
            "#include \"rates.h\"",
            "#include \"pointer.h\"",
            "#include \"cleanup.h\"",
            "#include \"scan.h\"",
            "#include \"user.h\"",
            "#include \"xevents.h\"",
            "#include \"win_utils.h\"",
            "#include \"xinerama.h\"",
            "#include \"xrecord.h\"",
            "#include \"xdamage.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void set_wirecopyrect_mode(char *str);",
            "void set_scrollcopyrect_mode(char *str);",
            "void do_copyregion(sraRegionPtr region, int dx, int dy, int mode);",
            "int check_ncache(int reset, int mode);",
            "int try_to_fix_su(Window win, int idx, Window above, int *nbatch, char *mode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"default8x16.h\"\n#include \"connections.h\"\n#include \"screen.h\"\n#include \"cursor.h\"\n#include \"macosxCGS.h\"\n#include \"macosx.h\"\n#include \"unixpw.h\"\n#include \"8to24.h\"\n#include \"xrandr.h\"\n#include \"solid.h\"\n#include \"keyboard.h\"\n#include \"rates.h\"\n#include \"pointer.h\"\n#include \"cleanup.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"xevents.h\"\n#include \"win_utils.h\"\n#include \"xinerama.h\"\n#include \"xrecord.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nvoid set_wirecopyrect_mode(char *str);\nvoid set_scrollcopyrect_mode(char *str);\nvoid do_copyregion(sraRegionPtr region, int dx, int dy, int mode);\nint check_ncache(int reset, int mode);\nint try_to_fix_su(Window win, int idx, Window above, int *nbatch, char *mode);\n\nvoid set_scrollcopyrect_mode(char *str) {\n\tchar *orig = scroll_copyrect;\n\tif (str == NULL || *str == '\\0') {\n\t\tscroll_copyrect = strdup(scroll_copyrect_default);\n\t} else if (!strcmp(str, \"always\") || !strcmp(str, \"all\") ||\n\t\t    !strcmp(str, \"both\")) {\n\t\tscroll_copyrect = strdup(\"always\");\n\t} else if (!strcmp(str, \"keys\") || !strcmp(str, \"keyboard\")) {\n\t\tscroll_copyrect = strdup(\"keys\");\n\t} else if (!strcmp(str, \"mouse\") || !strcmp(str, \"pointer\")) {\n\t\tscroll_copyrect = strdup(\"mouse\");\n\t} else if (!strcmp(str, \"never\") || !strcmp(str, \"none\")) {\n\t\tscroll_copyrect = strdup(\"never\");\n\t} else {\n\t\tif (! scroll_copyrect) {\n\t\t\tscroll_copyrect = strdup(scroll_copyrect_default);\n\t\t} else {\n\t\t\torig = NULL;\n\t\t}\n\t\trfbLog(\"unknown -scrollcopyrect mode: %s, using: %s\\n\", str,\n\t\t    scroll_copyrect);\n\t}\n\tif (orig) {\n\t\tfree(orig);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "arg",
            "\"-noscr\""
          ],
          "line": 3542
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "arg",
            "\"-noscrollcopyrect\""
          ],
          "line": 3541
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "arg",
            "\"-scr\""
          ],
          "line": 3535
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "arg",
            "\"-scrollcopyrect\""
          ],
          "line": 3534
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "arg",
            "\"-dwf\""
          ],
          "line": 3530
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "arg",
            "\"-debug_wireframe\""
          ],
          "line": 3529
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_wirecopyrect_mode",
          "args": [
            "\"never\""
          ],
          "line": 3526
        },
        "resolved": true,
        "details": {
          "function_name": "set_wirecopyrect_mode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/userinput.c",
          "lines": "501-523",
          "snippet": "void set_wirecopyrect_mode(char *str) {\n\tchar *orig = wireframe_copyrect;\n\tif (str == NULL || *str == '\\0') {\n\t\twireframe_copyrect = strdup(wireframe_copyrect_default);\n\t} else if (!strcmp(str, \"always\") || !strcmp(str, \"all\")) {\n\t\twireframe_copyrect = strdup(\"always\");\n\t} else if (!strcmp(str, \"top\")) {\n\t\twireframe_copyrect = strdup(\"top\");\n\t} else if (!strcmp(str, \"never\") || !strcmp(str, \"none\")) {\n\t\twireframe_copyrect = strdup(\"never\");\n\t} else {\n\t\tif (! wireframe_copyrect) {\n\t\t\twireframe_copyrect = strdup(wireframe_copyrect_default);\n\t\t} else {\n\t\t\torig = NULL;\n\t\t}\n\t\trfbLog(\"unknown -wirecopyrect mode: %s, using: %s\\n\", str,\n\t\t    wireframe_copyrect);\n\t}\n\tif (orig) {\n\t\tfree(orig);\n\t}\n}",
          "includes": [
            "#include \"default8x16.h\"",
            "#include \"connections.h\"",
            "#include \"screen.h\"",
            "#include \"cursor.h\"",
            "#include \"macosxCGS.h\"",
            "#include \"macosx.h\"",
            "#include \"unixpw.h\"",
            "#include \"8to24.h\"",
            "#include \"xrandr.h\"",
            "#include \"solid.h\"",
            "#include \"keyboard.h\"",
            "#include \"rates.h\"",
            "#include \"pointer.h\"",
            "#include \"cleanup.h\"",
            "#include \"scan.h\"",
            "#include \"user.h\"",
            "#include \"xevents.h\"",
            "#include \"win_utils.h\"",
            "#include \"xinerama.h\"",
            "#include \"xrecord.h\"",
            "#include \"xdamage.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void set_wirecopyrect_mode(char *str);",
            "void set_scrollcopyrect_mode(char *str);",
            "void do_copyregion(sraRegionPtr region, int dx, int dy, int mode);",
            "int check_ncache(int reset, int mode);",
            "int try_to_fix_su(Window win, int idx, Window above, int *nbatch, char *mode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"default8x16.h\"\n#include \"connections.h\"\n#include \"screen.h\"\n#include \"cursor.h\"\n#include \"macosxCGS.h\"\n#include \"macosx.h\"\n#include \"unixpw.h\"\n#include \"8to24.h\"\n#include \"xrandr.h\"\n#include \"solid.h\"\n#include \"keyboard.h\"\n#include \"rates.h\"\n#include \"pointer.h\"\n#include \"cleanup.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"xevents.h\"\n#include \"win_utils.h\"\n#include \"xinerama.h\"\n#include \"xrecord.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nvoid set_wirecopyrect_mode(char *str);\nvoid set_scrollcopyrect_mode(char *str);\nvoid do_copyregion(sraRegionPtr region, int dx, int dy, int mode);\nint check_ncache(int reset, int mode);\nint try_to_fix_su(Window win, int idx, Window above, int *nbatch, char *mode);\n\nvoid set_wirecopyrect_mode(char *str) {\n\tchar *orig = wireframe_copyrect;\n\tif (str == NULL || *str == '\\0') {\n\t\twireframe_copyrect = strdup(wireframe_copyrect_default);\n\t} else if (!strcmp(str, \"always\") || !strcmp(str, \"all\")) {\n\t\twireframe_copyrect = strdup(\"always\");\n\t} else if (!strcmp(str, \"top\")) {\n\t\twireframe_copyrect = strdup(\"top\");\n\t} else if (!strcmp(str, \"never\") || !strcmp(str, \"none\")) {\n\t\twireframe_copyrect = strdup(\"never\");\n\t} else {\n\t\tif (! wireframe_copyrect) {\n\t\t\twireframe_copyrect = strdup(wireframe_copyrect_default);\n\t\t} else {\n\t\t\torig = NULL;\n\t\t}\n\t\trfbLog(\"unknown -wirecopyrect mode: %s, using: %s\\n\", str,\n\t\t    wireframe_copyrect);\n\t}\n\tif (orig) {\n\t\tfree(orig);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "arg",
            "\"-nowcr\""
          ],
          "line": 3525
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "arg",
            "\"-nowirecopyrect\""
          ],
          "line": 3524
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "arg",
            "\"-wcr\""
          ],
          "line": 3518
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "arg",
            "\"-wirecopyrect\""
          ],
          "line": 3517
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "arg",
            "\"-nowfl\""
          ],
          "line": 3513
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "arg",
            "\"-nowireframelocal\""
          ],
          "line": 3512
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "arg",
            "\"-nowf\""
          ],
          "line": 3508
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "arg",
            "\"-nowireframe\""
          ],
          "line": 3507
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "argv[++i]"
          ],
          "line": 3502
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "arg",
            "\"-wf\""
          ],
          "line": 3497
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "arg",
            "\"-wireframe\""
          ],
          "line": 3496
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "arg",
            "\"-debug_ncache\""
          ],
          "line": 3491
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atoi",
          "args": [
            "argv[++i]"
          ],
          "line": 3488
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "arg",
            "\"-nc_pad\""
          ],
          "line": 3486
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "arg",
            "\"-ncache_pad\""
          ],
          "line": 3486
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "arg",
            "\"-nc_old_wm\""
          ],
          "line": 3482
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "arg",
            "\"-ncache_old_wm\""
          ],
          "line": 3482
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "arg",
            "\"-nc_keep_anims\""
          ],
          "line": 3478
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "arg",
            "\"-ncache_keep_anims\""
          ],
          "line": 3478
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "arg",
            "\"-nc_no_rootpixmap\""
          ],
          "line": 3474
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "arg",
            "\"-ncache_no_rootpixmap\""
          ],
          "line": 3474
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "arg",
            "\"-nc_no_dtchange\""
          ],
          "line": 3470
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "arg",
            "\"-ncache_no_dtchange\""
          ],
          "line": 3470
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "arg",
            "\"-nc_no_moveraise\""
          ],
          "line": 3466
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "arg",
            "\"-ncache_no_moveraise\""
          ],
          "line": 3466
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "arg",
            "\"-nc_cr\""
          ],
          "line": 3462
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "arg",
            "\"-ncache_cr\""
          ],
          "line": 3462
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "arg",
            "\"-nonc\""
          ],
          "line": 3458
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "arg",
            "\"-noncache\""
          ],
          "line": 3458
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atoi",
          "args": [
            "s"
          ],
          "line": 3445
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "arg",
            "\"-nc\""
          ],
          "line": 3441
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "arg",
            "\"-ncache\""
          ],
          "line": 3441
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "arg",
            "\"-nodragging\""
          ],
          "line": 3436
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "argv[++i]"
          ],
          "line": 3433
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "arg",
            "\"-buttonmap\""
          ],
          "line": 3431
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "arg",
            "\"-always_inject\""
          ],
          "line": 3427
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "arg",
            "\"-noxwarppointer\""
          ],
          "line": 3422
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "arg",
            "\"-xwarppointer\""
          ],
          "line": 3418
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "arg",
            "\"-nocursorpos\""
          ],
          "line": 3414
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "arg",
            "\"-cursorpos\""
          ],
          "line": 3409
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "arg",
            "\"-nocursorshape\""
          ],
          "line": 3405
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "arg",
            "\"-noalphablend\""
          ],
          "line": 3401
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "arg",
            "\"-alpharemove\""
          ],
          "line": 3397
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atof",
          "args": [
            "argv[++i]"
          ],
          "line": 3394
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "arg",
            "\"-alphafrac\""
          ],
          "line": 3392
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atoi",
          "args": [
            "argv[++i]"
          ],
          "line": 3389
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "arg",
            "\"-alphacut\""
          ],
          "line": 3387
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "arg",
            "\"-noxfixes\""
          ],
          "line": 3383
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "arg",
            "\"-xfixes\""
          ],
          "line": 3379
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atoi",
          "args": [
            "argv[++i]"
          ],
          "line": 3376
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "arg",
            "\"-arrow\""
          ],
          "line": 3374
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "arg",
            "\"-nocursor_drag\""
          ],
          "line": 3370
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "arg",
            "\"-cursor_drag\""
          ],
          "line": 3366
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "\"none\""
          ],
          "line": 3362
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "arg",
            "\"-nocursor\""
          ],
          "line": 3361
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "s",
            "\"none\""
          ],
          "line": 3354
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "s"
          ],
          "line": 3352
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "known_cursors_mode",
          "args": [
            "s"
          ],
          "line": 3351
        },
        "resolved": true,
        "details": {
          "function_name": "known_cursors_mode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/cursor.c",
          "lines": "1452-1468",
          "snippet": "int known_cursors_mode(char *s) {\n/*\n * default:\tsee initialize_cursors_mode() for default behavior.\n * arrow:\tunchanging white arrow.\n * Xn*:\t\tshow X on root background.  Optional n sets treedepth.\n * some:\tdo the heuristics for root, wm, term detection.\n * most:\tif display have overlay or xfixes, show all cursors,\n *\t\totherwise do the same as \"some\"\n * none:\tshow no cursor.\n */\n\tif (strcmp(s, \"default\") && strcmp(s, \"arrow\") && *s != 'X' &&\n\t    strcmp(s, \"some\") && strcmp(s, \"most\") && strcmp(s, \"none\")) {\n\t\treturn 0;\n\t} else {\n\t\treturn 1;\n\t}\n}",
          "includes": [
            "#include \"xi2_devices.h\"",
            "#include \"macosx.h\"",
            "#include \"unixpw.h\"",
            "#include \"scan.h\"",
            "#include \"screen.h\"",
            "#include \"cleanup.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int known_cursors_mode(char *s);",
            "void initialize_cursors_mode(void);",
            "void restore_cursor_shape_updates(rfbScreenInfoPtr s);",
            "void disable_cursor_shape_updates(rfbScreenInfoPtr s);",
            "int cursor_shape_updates_clients(rfbScreenInfoPtr s);",
            "int cursor_pos_updates_clients(rfbScreenInfoPtr s);",
            "static void set_cursor_was_changed(rfbScreenInfoPtr s);",
            "static cursor_info_t *cursors[CURS_MAX];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xi2_devices.h\"\n#include \"macosx.h\"\n#include \"unixpw.h\"\n#include \"scan.h\"\n#include \"screen.h\"\n#include \"cleanup.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nint known_cursors_mode(char *s);\nvoid initialize_cursors_mode(void);\nvoid restore_cursor_shape_updates(rfbScreenInfoPtr s);\nvoid disable_cursor_shape_updates(rfbScreenInfoPtr s);\nint cursor_shape_updates_clients(rfbScreenInfoPtr s);\nint cursor_pos_updates_clients(rfbScreenInfoPtr s);\nstatic void set_cursor_was_changed(rfbScreenInfoPtr s);\nstatic cursor_info_t *cursors[CURS_MAX];\n\nint known_cursors_mode(char *s) {\n/*\n * default:\tsee initialize_cursors_mode() for default behavior.\n * arrow:\tunchanging white arrow.\n * Xn*:\t\tshow X on root background.  Optional n sets treedepth.\n * some:\tdo the heuristics for root, wm, term detection.\n * most:\tif display have overlay or xfixes, show all cursors,\n *\t\totherwise do the same as \"some\"\n * none:\tshow no cursor.\n */\n\tif (strcmp(s, \"default\") && strcmp(s, \"arrow\") && *s != 'X' &&\n\t    strcmp(s, \"some\") && strcmp(s, \"most\") && strcmp(s, \"none\")) {\n\t\treturn 0;\n\t} else {\n\t\treturn 1;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "arg",
            "\"-cursor\""
          ],
          "line": 3347
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "argv[++i]"
          ],
          "line": 3344
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "arg",
            "\"-seldir\""
          ],
          "line": 3342
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "arg",
            "\"-nosetclipboard\""
          ],
          "line": 3338
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "arg",
            "\"-noclipboard\""
          ],
          "line": 3334
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "arg",
            "\"-nosetprimary\""
          ],
          "line": 3330
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "arg",
            "\"-noprimary\""
          ],
          "line": 3326
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "arg",
            "\"-nosel\""
          ],
          "line": 3320
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "arg",
            "\"-nobell\""
          ],
          "line": 3315
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "arg",
            "\"-nofb\""
          ],
          "line": 3311
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "arg",
            "\"-repeat\""
          ],
          "line": 3307
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atoi",
          "args": [
            "argv[++i]"
          ],
          "line": 3302
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isdigit",
          "args": [
            "(unsigned char) (*s)"
          ],
          "line": 3301
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "arg",
            "\"-norepeat\""
          ],
          "line": 3294
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "argv[++i]"
          ],
          "line": 3291
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "arg",
            "\"-remap\""
          ],
          "line": 3289
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "arg",
            "\"-clear_all\""
          ],
          "line": 3285
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "arg",
            "\"-clear_keys\""
          ],
          "line": 3281
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "arg",
            "\"-clear_mods\""
          ],
          "line": 3277
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "arg",
            "\"-noadd_keysyms\""
          ],
          "line": 3273
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "arg",
            "\"-add_keysyms\""
          ],
          "line": 3269
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "arg",
            "\"-noskip_dups\""
          ],
          "line": 3265
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "arg",
            "\"-skip_dups\""
          ],
          "line": 3261
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "arg",
            "\"-sloppy_keys\""
          ],
          "line": 3257
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "argv[++i]"
          ],
          "line": 3254
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "arg",
            "\"-skip_keycodes\""
          ],
          "line": 3252
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "arg",
            "\"-xkbcompat\""
          ],
          "line": 3248
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "arg",
            "\"-noskip_lockkeys\""
          ],
          "line": 3244
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "arg",
            "\"-skip_lockkeys\""
          ],
          "line": 3240
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "arg",
            "\"-capslock\""
          ],
          "line": 3236
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "arg",
            "\"-noxkb\""
          ],
          "line": 3231
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "arg",
            "\"-xkb\""
          ],
          "line": 3226
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "arg",
            "\"-isolevel3\""
          ],
          "line": 3222
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "arg",
            "\"-nomodtweak\""
          ],
          "line": 3217
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "arg",
            "\"-modtweak\""
          ],
          "line": 3213
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"warning: -bg mode not supported.\\n\""
          ],
          "line": 3208
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "arg",
            "\"-background\""
          ],
          "line": 3202
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "arg",
            "\"-bg\""
          ],
          "line": 3202
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "arg",
            "\"-verbose\""
          ],
          "line": 3198
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "arg",
            "\"-v\""
          ],
          "line": 3198
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "arg",
            "\"-noquiet\""
          ],
          "line": 3194
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "arg",
            "\"-quiet\""
          ],
          "line": 3190
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "arg",
            "\"-q\""
          ],
          "line": 3190
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "arg",
            "\"-nodbg\""
          ],
          "line": 3186
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "arg",
            "\"-dbg\""
          ],
          "line": 3182
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "print_license",
          "args": [],
          "line": 3179
        },
        "resolved": true,
        "details": {
          "function_name": "print_license",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/help.c",
          "lines": "6083-6443",
          "snippet": "void print_license(void) {\n\tchar license[] = \n#if !SKIP_HELP\n\"\t\t    GNU GENERAL PUBLIC LICENSE\\n\"\n\"\t\t       Version 2, June 1991\\n\"\n\"\\n\"\n\" Copyright (C) 1989, 1991 Free Software Foundation, Inc.\\n\"\n\"                          59 Temple Place - Suite 330, Boston, MA\\n\"\n\"                          02111-1307, USA.\\n\"\n\" Everyone is permitted to copy and distribute verbatim copies\\n\"\n\" of this license document, but changing it is not allowed.\\n\"\n\"\\n\"\n\"\t\t\t    Preamble\\n\"\n\"\\n\"\n\"  The licenses for most software are designed to take away your\\n\"\n\"freedom to share and change it.  By contrast, the GNU General Public\\n\"\n\"License is intended to guarantee your freedom to share and change free\\n\"\n\"software--to make sure the software is free for all its users.  This\\n\"\n\"General Public License applies to most of the Free Software\\n\"\n\"Foundation's software and to any other program whose authors commit to\\n\"\n\"using it.  (Some other Free Software Foundation software is covered by\\n\"\n\"the GNU Library General Public License instead.)  You can apply it to\\n\"\n\"your programs, too.\\n\"\n\"\\n\"\n\"  When we speak of free software, we are referring to freedom, not\\n\"\n\"price.  Our General Public Licenses are designed to make sure that you\\n\"\n\"have the freedom to distribute copies of free software (and charge for\\n\"\n\"this service if you wish), that you receive source code or can get it\\n\"\n\"if you want it, that you can change the software or use pieces of it\\n\"\n\"in new free programs; and that you know you can do these things.\\n\"\n\"\\n\"\n\"  To protect your rights, we need to make restrictions that forbid\\n\"\n\"anyone to deny you these rights or to ask you to surrender the rights.\\n\"\n\"These restrictions translate to certain responsibilities for you if you\\n\"\n\"distribute copies of the software, or if you modify it.\\n\"\n\"\\n\"\n\"  For example, if you distribute copies of such a program, whether\\n\"\n\"gratis or for a fee, you must give the recipients all the rights that\\n\"\n\"you have.  You must make sure that they, too, receive or can get the\\n\"\n\"source code.  And you must show them these terms so they know their\\n\"\n\"rights.\\n\"\n\"\\n\"\n\"  We protect your rights with two steps: (1) copyright the software, and\\n\"\n\"(2) offer you this license which gives you legal permission to copy,\\n\"\n\"distribute and/or modify the software.\\n\"\n\"\\n\"\n\"  Also, for each author's protection and ours, we want to make certain\\n\"\n\"that everyone understands that there is no warranty for this free\\n\"\n\"software.  If the software is modified by someone else and passed on, we\\n\"\n\"want its recipients to know that what they have is not the original, so\\n\"\n\"that any problems introduced by others will not reflect on the original\\n\"\n\"authors' reputations.\\n\"\n\"\\n\"\n\"  Finally, any free program is threatened constantly by software\\n\"\n\"patents.  We wish to avoid the danger that redistributors of a free\\n\"\n\"program will individually obtain patent licenses, in effect making the\\n\"\n\"program proprietary.  To prevent this, we have made it clear that any\\n\"\n\"patent must be licensed for everyone's free use or not licensed at all.\\n\"\n\"\\n\"\n\"  The precise terms and conditions for copying, distribution and\\n\"\n\"modification follow.\\n\"\n\"\f\\n\"\n\"\t\t    GNU GENERAL PUBLIC LICENSE\\n\"\n\"   TERMS AND CONDITIONS FOR COPYING, DISTRIBUTION AND MODIFICATION\\n\"\n\"\\n\"\n\"  0. This License applies to any program or other work which contains\\n\"\n\"a notice placed by the copyright holder saying it may be distributed\\n\"\n\"under the terms of this General Public License.  The \\\"Program\\\", below,\\n\"\n\"refers to any such program or work, and a \\\"work based on the Program\\\"\\n\"\n\"means either the Program or any derivative work under copyright law:\\n\"\n\"that is to say, a work containing the Program or a portion of it,\\n\"\n\"either verbatim or with modifications and/or translated into another\\n\"\n\"language.  (Hereinafter, translation is included without limitation in\\n\"\n\"the term \\\"modification\\\".)  Each licensee is addressed as \\\"you\\\".\\n\"\n\"\\n\"\n\"Activities other than copying, distribution and modification are not\\n\"\n\"covered by this License; they are outside its scope.  The act of\\n\"\n\"running the Program is not restricted, and the output from the Program\\n\"\n\"is covered only if its contents constitute a work based on the\\n\"\n\"Program (independent of having been made by running the Program).\\n\"\n\"Whether that is true depends on what the Program does.\\n\"\n\"\\n\"\n\"  1. You may copy and distribute verbatim copies of the Program's\\n\"\n\"source code as you receive it, in any medium, provided that you\\n\"\n\"conspicuously and appropriately publish on each copy an appropriate\\n\"\n\"copyright notice and disclaimer of warranty; keep intact all the\\n\"\n\"notices that refer to this License and to the absence of any warranty;\\n\"\n\"and give any other recipients of the Program a copy of this License\\n\"\n\"along with the Program.\\n\"\n\"\\n\"\n\"You may charge a fee for the physical act of transferring a copy, and\\n\"\n\"you may at your option offer warranty protection in exchange for a fee.\\n\"\n\"\\n\"\n\"  2. You may modify your copy or copies of the Program or any portion\\n\"\n\"of it, thus forming a work based on the Program, and copy and\\n\"\n\"distribute such modifications or work under the terms of Section 1\\n\"\n\"above, provided that you also meet all of these conditions:\\n\"\n\"\\n\"\n\"    a) You must cause the modified files to carry prominent notices\\n\"\n\"    stating that you changed the files and the date of any change.\\n\"\n\"\\n\"\n\"    b) You must cause any work that you distribute or publish, that in\\n\"\n\"    whole or in part contains or is derived from the Program or any\\n\"\n\"    part thereof, to be licensed as a whole at no charge to all third\\n\"\n\"    parties under the terms of this License.\\n\"\n\"\\n\"\n\"    c) If the modified program normally reads commands interactively\\n\"\n\"    when run, you must cause it, when started running for such\\n\"\n\"    interactive use in the most ordinary way, to print or display an\\n\"\n\"    announcement including an appropriate copyright notice and a\\n\"\n\"    notice that there is no warranty (or else, saying that you provide\\n\"\n\"    a warranty) and that users may redistribute the program under\\n\"\n\"    these conditions, and telling the user how to view a copy of this\\n\"\n\"    License.  (Exception: if the Program itself is interactive but\\n\"\n\"    does not normally print such an announcement, your work based on\\n\"\n\"    the Program is not required to print an announcement.)\\n\"\n\"\f\\n\"\n\"These requirements apply to the modified work as a whole.  If\\n\"\n\"identifiable sections of that work are not derived from the Program,\\n\"\n\"and can be reasonably considered independent and separate works in\\n\"\n\"themselves, then this License, and its terms, do not apply to those\\n\"\n\"sections when you distribute them as separate works.  But when you\\n\"\n\"distribute the same sections as part of a whole which is a work based\\n\"\n\"on the Program, the distribution of the whole must be on the terms of\\n\"\n\"this License, whose permissions for other licensees extend to the\\n\"\n\"entire whole, and thus to each and every part regardless of who wrote it.\\n\"\n\"\\n\"\n\"Thus, it is not the intent of this section to claim rights or contest\\n\"\n\"your rights to work written entirely by you; rather, the intent is to\\n\"\n\"exercise the right to control the distribution of derivative or\\n\"\n\"collective works based on the Program.\\n\"\n\"\\n\"\n\"In addition, mere aggregation of another work not based on the Program\\n\"\n\"with the Program (or with a work based on the Program) on a volume of\\n\"\n\"a storage or distribution medium does not bring the other work under\\n\"\n\"the scope of this License.\\n\"\n\"\\n\"\n\"  3. You may copy and distribute the Program (or a work based on it,\\n\"\n\"under Section 2) in object code or executable form under the terms of\\n\"\n\"Sections 1 and 2 above provided that you also do one of the following:\\n\"\n\"\\n\"\n\"    a) Accompany it with the complete corresponding machine-readable\\n\"\n\"    source code, which must be distributed under the terms of Sections\\n\"\n\"    1 and 2 above on a medium customarily used for software interchange; or,\\n\"\n\"\\n\"\n\"    b) Accompany it with a written offer, valid for at least three\\n\"\n\"    years, to give any third party, for a charge no more than your\\n\"\n\"    cost of physically performing source distribution, a complete\\n\"\n\"    machine-readable copy of the corresponding source code, to be\\n\"\n\"    distributed under the terms of Sections 1 and 2 above on a medium\\n\"\n\"    customarily used for software interchange; or,\\n\"\n\"\\n\"\n\"    c) Accompany it with the information you received as to the offer\\n\"\n\"    to distribute corresponding source code.  (This alternative is\\n\"\n\"    allowed only for noncommercial distribution and only if you\\n\"\n\"    received the program in object code or executable form with such\\n\"\n\"    an offer, in accord with Subsection b above.)\\n\"\n\"\\n\"\n\"The source code for a work means the preferred form of the work for\\n\"\n\"making modifications to it.  For an executable work, complete source\\n\"\n\"code means all the source code for all modules it contains, plus any\\n\"\n\"associated interface definition files, plus the scripts used to\\n\"\n\"control compilation and installation of the executable.  However, as a\\n\"\n\"special exception, the source code distributed need not include\\n\"\n\"anything that is normally distributed (in either source or binary\\n\"\n\"form) with the major components (compiler, kernel, and so on) of the\\n\"\n\"operating system on which the executable runs, unless that component\\n\"\n\"itself accompanies the executable.\\n\"\n\"\\n\"\n\"If distribution of executable or object code is made by offering\\n\"\n\"access to copy from a designated place, then offering equivalent\\n\"\n\"access to copy the source code from the same place counts as\\n\"\n\"distribution of the source code, even though third parties are not\\n\"\n\"compelled to copy the source along with the object code.\\n\"\n\"\f\\n\"\n\"  4. You may not copy, modify, sublicense, or distribute the Program\\n\"\n\"except as expressly provided under this License.  Any attempt\\n\"\n\"otherwise to copy, modify, sublicense or distribute the Program is\\n\"\n\"void, and will automatically terminate your rights under this License.\\n\"\n\"However, parties who have received copies, or rights, from you under\\n\"\n\"this License will not have their licenses terminated so long as such\\n\"\n\"parties remain in full compliance.\\n\"\n\"\\n\"\n\"  5. You are not required to accept this License, since you have not\\n\"\n\"signed it.  However, nothing else grants you permission to modify or\\n\"\n\"distribute the Program or its derivative works.  These actions are\\n\"\n\"prohibited by law if you do not accept this License.  Therefore, by\\n\"\n\"modifying or distributing the Program (or any work based on the\\n\"\n\"Program), you indicate your acceptance of this License to do so, and\\n\"\n\"all its terms and conditions for copying, distributing or modifying\\n\"\n\"the Program or works based on it.\\n\"\n\"\\n\"\n\"  6. Each time you redistribute the Program (or any work based on the\\n\"\n\"Program), the recipient automatically receives a license from the\\n\"\n\"original licensor to copy, distribute or modify the Program subject to\\n\"\n\"these terms and conditions.  You may not impose any further\\n\"\n\"restrictions on the recipients' exercise of the rights granted herein.\\n\"\n\"You are not responsible for enforcing compliance by third parties to\\n\"\n\"this License.\\n\"\n\"\\n\"\n\"  7. If, as a consequence of a court judgment or allegation of patent\\n\"\n\"infringement or for any other reason (not limited to patent issues),\\n\"\n\"conditions are imposed on you (whether by court order, agreement or\\n\"\n\"otherwise) that contradict the conditions of this License, they do not\\n\"\n\"excuse you from the conditions of this License.  If you cannot\\n\"\n\"distribute so as to satisfy simultaneously your obligations under this\\n\"\n\"License and any other pertinent obligations, then as a consequence you\\n\"\n\"may not distribute the Program at all.  For example, if a patent\\n\"\n\"license would not permit royalty-free redistribution of the Program by\\n\"\n\"all those who receive copies directly or indirectly through you, then\\n\"\n\"the only way you could satisfy both it and this License would be to\\n\"\n\"refrain entirely from distribution of the Program.\\n\"\n\"\\n\"\n\"If any portion of this section is held invalid or unenforceable under\\n\"\n\"any particular circumstance, the balance of the section is intended to\\n\"\n\"apply and the section as a whole is intended to apply in other\\n\"\n\"circumstances.\\n\"\n\"\\n\"\n\"It is not the purpose of this section to induce you to infringe any\\n\"\n\"patents or other property right claims or to contest validity of any\\n\"\n\"such claims; this section has the sole purpose of protecting the\\n\"\n\"integrity of the free software distribution system, which is\\n\"\n\"implemented by public license practices.  Many people have made\\n\"\n\"generous contributions to the wide range of software distributed\\n\"\n\"through that system in reliance on consistent application of that\\n\"\n\"system; it is up to the author/donor to decide if he or she is willing\\n\"\n\"to distribute software through any other system and a licensee cannot\\n\"\n\"impose that choice.\\n\"\n\"\\n\"\n\"This section is intended to make thoroughly clear what is believed to\\n\"\n\"be a consequence of the rest of this License.\\n\"\n\"\f\\n\"\n\"  8. If the distribution and/or use of the Program is restricted in\\n\"\n\"certain countries either by patents or by copyrighted interfaces, the\\n\"\n\"original copyright holder who places the Program under this License\\n\"\n\"may add an explicit geographical distribution limitation excluding\\n\"\n\"those countries, so that distribution is permitted only in or among\\n\"\n\"countries not thus excluded.  In such case, this License incorporates\\n\"\n\"the limitation as if written in the body of this License.\\n\"\n\"\\n\"\n\"  9. The Free Software Foundation may publish revised and/or new versions\\n\"\n\"of the General Public License from time to time.  Such new versions will\\n\"\n\"be similar in spirit to the present version, but may differ in detail to\\n\"\n\"address new problems or concerns.\\n\"\n\"\\n\"\n\"Each version is given a distinguishing version number.  If the Program\\n\"\n\"specifies a version number of this License which applies to it and \\\"any\\n\"\n\"later version\\\", you have the option of following the terms and conditions\\n\"\n\"either of that version or of any later version published by the Free\\n\"\n\"Software Foundation.  If the Program does not specify a version number of\\n\"\n\"this License, you may choose any version ever published by the Free Software\\n\"\n\"Foundation.\\n\"\n\"\\n\"\n\"  10. If you wish to incorporate parts of the Program into other free\\n\"\n\"programs whose distribution conditions are different, write to the author\\n\"\n\"to ask for permission.  For software which is copyrighted by the Free\\n\"\n\"Software Foundation, write to the Free Software Foundation; we sometimes\\n\"\n\"make exceptions for this.  Our decision will be guided by the two goals\\n\"\n\"of preserving the free status of all derivatives of our free software and\\n\"\n\"of promoting the sharing and reuse of software generally.\\n\"\n\"\\n\"\n#endif\n\"\t\t\t    NO WARRANTY\\n\"\n\"\\n\"\n\"  11. BECAUSE THE PROGRAM IS LICENSED FREE OF CHARGE, THERE IS NO WARRANTY\\n\"\n\"FOR THE PROGRAM, TO THE EXTENT PERMITTED BY APPLICABLE LAW.  EXCEPT WHEN\\n\"\n\"OTHERWISE STATED IN WRITING THE COPYRIGHT HOLDERS AND/OR OTHER PARTIES\\n\"\n\"PROVIDE THE PROGRAM \\\"AS IS\\\" WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED\\n\"\n\"OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF\\n\"\n\"MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.  THE ENTIRE RISK AS\\n\"\n\"TO THE QUALITY AND PERFORMANCE OF THE PROGRAM IS WITH YOU.  SHOULD THE\\n\"\n\"PROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF ALL NECESSARY SERVICING,\\n\"\n\"REPAIR OR CORRECTION.\\n\"\n\"\\n\"\n\"  12. IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING\\n\"\n\"WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MAY MODIFY AND/OR\\n\"\n\"REDISTRIBUTE THE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES,\\n\"\n\"INCLUDING ANY GENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING\\n\"\n\"OUT OF THE USE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED\\n\"\n\"TO LOSS OF DATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY\\n\"\n\"YOU OR THIRD PARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER\\n\"\n\"PROGRAMS), EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE\\n\"\n\"POSSIBILITY OF SUCH DAMAGES.\\n\"\n\"\\n\"\n#if !SKIP_HELP\n\"\t\t     END OF TERMS AND CONDITIONS\\n\"\n\"\f\\n\"\n\"\tAppendix: How to Apply These Terms to Your New Programs\\n\"\n\"\\n\"\n\"  If you develop a new program, and you want it to be of the greatest\\n\"\n\"possible use to the public, the best way to achieve this is to make it\\n\"\n\"free software which everyone can redistribute and change under these terms.\\n\"\n\"\\n\"\n\"  To do so, attach the following notices to the program.  It is safest\\n\"\n\"to attach them to the start of each source file to most effectively\\n\"\n\"convey the exclusion of warranty; and each file should have at least\\n\"\n\"the \\\"copyright\\\" line and a pointer to where the full notice is found.\\n\"\n\"\\n\"\n\"    <one line to give the program's name and a brief idea of what it does.>\\n\"\n\"    Copyright (C) 19yy  <name of author>\\n\"\n\"\\n\"\n\"    This program is free software; you can redistribute it and/or modify\\n\"\n\"    it under the terms of the GNU General Public License as published by\\n\"\n\"    the Free Software Foundation; either version 2 of the License, or\\n\"\n\"    (at your option) any later version.\\n\"\n\"\\n\"\n\"    This program is distributed in the hope that it will be useful,\\n\"\n\"    but WITHOUT ANY WARRANTY; without even the implied warranty of\\n\"\n\"    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n\"\n\"    GNU General Public License for more details.\\n\"\n\"\\n\"\n\"    You should have received a copy of the GNU General Public License\\n\"\n\"    along with this program; if not, write to the Free Software\\n\"\n\"    Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.\\n\"\n\"\\n\"\n\"Also add information on how to contact you by electronic and paper mail.\\n\"\n\"\\n\"\n\"If the program is interactive, make it output a short notice like this\\n\"\n\"when it starts in an interactive mode:\\n\"\n\"\\n\"\n\"    Gnomovision version 69, Copyright (C) 19yy name of author\\n\"\n\"    Gnomovision comes with ABSOLUTELY NO WARRANTY; for details type `show w'.\\n\"\n\"    This is free software, and you are welcome to redistribute it\\n\"\n\"    under certain conditions; type `show c' for details.\\n\"\n\"\\n\"\n\"The hypothetical commands `show w' and `show c' should show the appropriate\\n\"\n\"parts of the General Public License.  Of course, the commands you use may\\n\"\n\"be called something other than `show w' and `show c'; they could even be\\n\"\n\"mouse-clicks or menu items--whatever suits your program.\\n\"\n\"\\n\"\n\"You should also get your employer (if you work as a programmer) or your\\n\"\n\"school, if any, to sign a \\\"copyright disclaimer\\\" for the program, if\\n\"\n\"necessary.  Here is a sample; alter the names:\\n\"\n\"\\n\"\n\"  Yoyodyne, Inc., hereby disclaims all copyright interest in the program\\n\"\n\"  `Gnomovision' (which makes passes at compilers) written by James Hacker.\\n\"\n\"\\n\"\n\"  <signature of Ty Coon>, 1 April 1989\\n\"\n\"  Ty Coon, President of Vice\\n\"\n\"\\n\"\n\"This General Public License does not permit incorporating your program into\\n\"\n\"proprietary programs.  If your program is a subroutine library, you may\\n\"\n\"consider it more useful to permit linking proprietary applications with the\\n\"\n\"library.  If this is what you want to do, use the GNU Library General\\n\"\n\"Public License instead of this License.\\n\"\n#endif\n;\n\n\tchar top[] =\n\"\\n\"\n\"x11vnc: a VNC server for X displays.  %s\\n\"\n\"\\n\"\n\"Copyright (C) 2002-2010 Karl J. Runge <runge@karlrunge.com>\\n\"\n\"All rights reserved.\\n\"\n\"\\n\"\n;\n\tdup2(1, 2);\n\tfprintf(stderr, top, lastmod);\n\tfprintf(stderr, \"%s\", license);\n\texit(1);\n}",
          "includes": [
            "#include \"cursor.h\"",
            "#include \"xdamage.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void print_help(int mode);",
            "void print_license(void);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cursor.h\"\n#include \"xdamage.h\"\n#include \"x11vnc.h\"\n\nvoid print_help(int mode);\nvoid print_license(void);\n\nvoid print_license(void) {\n\tchar license[] = \n#if !SKIP_HELP\n\"\t\t    GNU GENERAL PUBLIC LICENSE\\n\"\n\"\t\t       Version 2, June 1991\\n\"\n\"\\n\"\n\" Copyright (C) 1989, 1991 Free Software Foundation, Inc.\\n\"\n\"                          59 Temple Place - Suite 330, Boston, MA\\n\"\n\"                          02111-1307, USA.\\n\"\n\" Everyone is permitted to copy and distribute verbatim copies\\n\"\n\" of this license document, but changing it is not allowed.\\n\"\n\"\\n\"\n\"\t\t\t    Preamble\\n\"\n\"\\n\"\n\"  The licenses for most software are designed to take away your\\n\"\n\"freedom to share and change it.  By contrast, the GNU General Public\\n\"\n\"License is intended to guarantee your freedom to share and change free\\n\"\n\"software--to make sure the software is free for all its users.  This\\n\"\n\"General Public License applies to most of the Free Software\\n\"\n\"Foundation's software and to any other program whose authors commit to\\n\"\n\"using it.  (Some other Free Software Foundation software is covered by\\n\"\n\"the GNU Library General Public License instead.)  You can apply it to\\n\"\n\"your programs, too.\\n\"\n\"\\n\"\n\"  When we speak of free software, we are referring to freedom, not\\n\"\n\"price.  Our General Public Licenses are designed to make sure that you\\n\"\n\"have the freedom to distribute copies of free software (and charge for\\n\"\n\"this service if you wish), that you receive source code or can get it\\n\"\n\"if you want it, that you can change the software or use pieces of it\\n\"\n\"in new free programs; and that you know you can do these things.\\n\"\n\"\\n\"\n\"  To protect your rights, we need to make restrictions that forbid\\n\"\n\"anyone to deny you these rights or to ask you to surrender the rights.\\n\"\n\"These restrictions translate to certain responsibilities for you if you\\n\"\n\"distribute copies of the software, or if you modify it.\\n\"\n\"\\n\"\n\"  For example, if you distribute copies of such a program, whether\\n\"\n\"gratis or for a fee, you must give the recipients all the rights that\\n\"\n\"you have.  You must make sure that they, too, receive or can get the\\n\"\n\"source code.  And you must show them these terms so they know their\\n\"\n\"rights.\\n\"\n\"\\n\"\n\"  We protect your rights with two steps: (1) copyright the software, and\\n\"\n\"(2) offer you this license which gives you legal permission to copy,\\n\"\n\"distribute and/or modify the software.\\n\"\n\"\\n\"\n\"  Also, for each author's protection and ours, we want to make certain\\n\"\n\"that everyone understands that there is no warranty for this free\\n\"\n\"software.  If the software is modified by someone else and passed on, we\\n\"\n\"want its recipients to know that what they have is not the original, so\\n\"\n\"that any problems introduced by others will not reflect on the original\\n\"\n\"authors' reputations.\\n\"\n\"\\n\"\n\"  Finally, any free program is threatened constantly by software\\n\"\n\"patents.  We wish to avoid the danger that redistributors of a free\\n\"\n\"program will individually obtain patent licenses, in effect making the\\n\"\n\"program proprietary.  To prevent this, we have made it clear that any\\n\"\n\"patent must be licensed for everyone's free use or not licensed at all.\\n\"\n\"\\n\"\n\"  The precise terms and conditions for copying, distribution and\\n\"\n\"modification follow.\\n\"\n\"\f\\n\"\n\"\t\t    GNU GENERAL PUBLIC LICENSE\\n\"\n\"   TERMS AND CONDITIONS FOR COPYING, DISTRIBUTION AND MODIFICATION\\n\"\n\"\\n\"\n\"  0. This License applies to any program or other work which contains\\n\"\n\"a notice placed by the copyright holder saying it may be distributed\\n\"\n\"under the terms of this General Public License.  The \\\"Program\\\", below,\\n\"\n\"refers to any such program or work, and a \\\"work based on the Program\\\"\\n\"\n\"means either the Program or any derivative work under copyright law:\\n\"\n\"that is to say, a work containing the Program or a portion of it,\\n\"\n\"either verbatim or with modifications and/or translated into another\\n\"\n\"language.  (Hereinafter, translation is included without limitation in\\n\"\n\"the term \\\"modification\\\".)  Each licensee is addressed as \\\"you\\\".\\n\"\n\"\\n\"\n\"Activities other than copying, distribution and modification are not\\n\"\n\"covered by this License; they are outside its scope.  The act of\\n\"\n\"running the Program is not restricted, and the output from the Program\\n\"\n\"is covered only if its contents constitute a work based on the\\n\"\n\"Program (independent of having been made by running the Program).\\n\"\n\"Whether that is true depends on what the Program does.\\n\"\n\"\\n\"\n\"  1. You may copy and distribute verbatim copies of the Program's\\n\"\n\"source code as you receive it, in any medium, provided that you\\n\"\n\"conspicuously and appropriately publish on each copy an appropriate\\n\"\n\"copyright notice and disclaimer of warranty; keep intact all the\\n\"\n\"notices that refer to this License and to the absence of any warranty;\\n\"\n\"and give any other recipients of the Program a copy of this License\\n\"\n\"along with the Program.\\n\"\n\"\\n\"\n\"You may charge a fee for the physical act of transferring a copy, and\\n\"\n\"you may at your option offer warranty protection in exchange for a fee.\\n\"\n\"\\n\"\n\"  2. You may modify your copy or copies of the Program or any portion\\n\"\n\"of it, thus forming a work based on the Program, and copy and\\n\"\n\"distribute such modifications or work under the terms of Section 1\\n\"\n\"above, provided that you also meet all of these conditions:\\n\"\n\"\\n\"\n\"    a) You must cause the modified files to carry prominent notices\\n\"\n\"    stating that you changed the files and the date of any change.\\n\"\n\"\\n\"\n\"    b) You must cause any work that you distribute or publish, that in\\n\"\n\"    whole or in part contains or is derived from the Program or any\\n\"\n\"    part thereof, to be licensed as a whole at no charge to all third\\n\"\n\"    parties under the terms of this License.\\n\"\n\"\\n\"\n\"    c) If the modified program normally reads commands interactively\\n\"\n\"    when run, you must cause it, when started running for such\\n\"\n\"    interactive use in the most ordinary way, to print or display an\\n\"\n\"    announcement including an appropriate copyright notice and a\\n\"\n\"    notice that there is no warranty (or else, saying that you provide\\n\"\n\"    a warranty) and that users may redistribute the program under\\n\"\n\"    these conditions, and telling the user how to view a copy of this\\n\"\n\"    License.  (Exception: if the Program itself is interactive but\\n\"\n\"    does not normally print such an announcement, your work based on\\n\"\n\"    the Program is not required to print an announcement.)\\n\"\n\"\f\\n\"\n\"These requirements apply to the modified work as a whole.  If\\n\"\n\"identifiable sections of that work are not derived from the Program,\\n\"\n\"and can be reasonably considered independent and separate works in\\n\"\n\"themselves, then this License, and its terms, do not apply to those\\n\"\n\"sections when you distribute them as separate works.  But when you\\n\"\n\"distribute the same sections as part of a whole which is a work based\\n\"\n\"on the Program, the distribution of the whole must be on the terms of\\n\"\n\"this License, whose permissions for other licensees extend to the\\n\"\n\"entire whole, and thus to each and every part regardless of who wrote it.\\n\"\n\"\\n\"\n\"Thus, it is not the intent of this section to claim rights or contest\\n\"\n\"your rights to work written entirely by you; rather, the intent is to\\n\"\n\"exercise the right to control the distribution of derivative or\\n\"\n\"collective works based on the Program.\\n\"\n\"\\n\"\n\"In addition, mere aggregation of another work not based on the Program\\n\"\n\"with the Program (or with a work based on the Program) on a volume of\\n\"\n\"a storage or distribution medium does not bring the other work under\\n\"\n\"the scope of this License.\\n\"\n\"\\n\"\n\"  3. You may copy and distribute the Program (or a work based on it,\\n\"\n\"under Section 2) in object code or executable form under the terms of\\n\"\n\"Sections 1 and 2 above provided that you also do one of the following:\\n\"\n\"\\n\"\n\"    a) Accompany it with the complete corresponding machine-readable\\n\"\n\"    source code, which must be distributed under the terms of Sections\\n\"\n\"    1 and 2 above on a medium customarily used for software interchange; or,\\n\"\n\"\\n\"\n\"    b) Accompany it with a written offer, valid for at least three\\n\"\n\"    years, to give any third party, for a charge no more than your\\n\"\n\"    cost of physically performing source distribution, a complete\\n\"\n\"    machine-readable copy of the corresponding source code, to be\\n\"\n\"    distributed under the terms of Sections 1 and 2 above on a medium\\n\"\n\"    customarily used for software interchange; or,\\n\"\n\"\\n\"\n\"    c) Accompany it with the information you received as to the offer\\n\"\n\"    to distribute corresponding source code.  (This alternative is\\n\"\n\"    allowed only for noncommercial distribution and only if you\\n\"\n\"    received the program in object code or executable form with such\\n\"\n\"    an offer, in accord with Subsection b above.)\\n\"\n\"\\n\"\n\"The source code for a work means the preferred form of the work for\\n\"\n\"making modifications to it.  For an executable work, complete source\\n\"\n\"code means all the source code for all modules it contains, plus any\\n\"\n\"associated interface definition files, plus the scripts used to\\n\"\n\"control compilation and installation of the executable.  However, as a\\n\"\n\"special exception, the source code distributed need not include\\n\"\n\"anything that is normally distributed (in either source or binary\\n\"\n\"form) with the major components (compiler, kernel, and so on) of the\\n\"\n\"operating system on which the executable runs, unless that component\\n\"\n\"itself accompanies the executable.\\n\"\n\"\\n\"\n\"If distribution of executable or object code is made by offering\\n\"\n\"access to copy from a designated place, then offering equivalent\\n\"\n\"access to copy the source code from the same place counts as\\n\"\n\"distribution of the source code, even though third parties are not\\n\"\n\"compelled to copy the source along with the object code.\\n\"\n\"\f\\n\"\n\"  4. You may not copy, modify, sublicense, or distribute the Program\\n\"\n\"except as expressly provided under this License.  Any attempt\\n\"\n\"otherwise to copy, modify, sublicense or distribute the Program is\\n\"\n\"void, and will automatically terminate your rights under this License.\\n\"\n\"However, parties who have received copies, or rights, from you under\\n\"\n\"this License will not have their licenses terminated so long as such\\n\"\n\"parties remain in full compliance.\\n\"\n\"\\n\"\n\"  5. You are not required to accept this License, since you have not\\n\"\n\"signed it.  However, nothing else grants you permission to modify or\\n\"\n\"distribute the Program or its derivative works.  These actions are\\n\"\n\"prohibited by law if you do not accept this License.  Therefore, by\\n\"\n\"modifying or distributing the Program (or any work based on the\\n\"\n\"Program), you indicate your acceptance of this License to do so, and\\n\"\n\"all its terms and conditions for copying, distributing or modifying\\n\"\n\"the Program or works based on it.\\n\"\n\"\\n\"\n\"  6. Each time you redistribute the Program (or any work based on the\\n\"\n\"Program), the recipient automatically receives a license from the\\n\"\n\"original licensor to copy, distribute or modify the Program subject to\\n\"\n\"these terms and conditions.  You may not impose any further\\n\"\n\"restrictions on the recipients' exercise of the rights granted herein.\\n\"\n\"You are not responsible for enforcing compliance by third parties to\\n\"\n\"this License.\\n\"\n\"\\n\"\n\"  7. If, as a consequence of a court judgment or allegation of patent\\n\"\n\"infringement or for any other reason (not limited to patent issues),\\n\"\n\"conditions are imposed on you (whether by court order, agreement or\\n\"\n\"otherwise) that contradict the conditions of this License, they do not\\n\"\n\"excuse you from the conditions of this License.  If you cannot\\n\"\n\"distribute so as to satisfy simultaneously your obligations under this\\n\"\n\"License and any other pertinent obligations, then as a consequence you\\n\"\n\"may not distribute the Program at all.  For example, if a patent\\n\"\n\"license would not permit royalty-free redistribution of the Program by\\n\"\n\"all those who receive copies directly or indirectly through you, then\\n\"\n\"the only way you could satisfy both it and this License would be to\\n\"\n\"refrain entirely from distribution of the Program.\\n\"\n\"\\n\"\n\"If any portion of this section is held invalid or unenforceable under\\n\"\n\"any particular circumstance, the balance of the section is intended to\\n\"\n\"apply and the section as a whole is intended to apply in other\\n\"\n\"circumstances.\\n\"\n\"\\n\"\n\"It is not the purpose of this section to induce you to infringe any\\n\"\n\"patents or other property right claims or to contest validity of any\\n\"\n\"such claims; this section has the sole purpose of protecting the\\n\"\n\"integrity of the free software distribution system, which is\\n\"\n\"implemented by public license practices.  Many people have made\\n\"\n\"generous contributions to the wide range of software distributed\\n\"\n\"through that system in reliance on consistent application of that\\n\"\n\"system; it is up to the author/donor to decide if he or she is willing\\n\"\n\"to distribute software through any other system and a licensee cannot\\n\"\n\"impose that choice.\\n\"\n\"\\n\"\n\"This section is intended to make thoroughly clear what is believed to\\n\"\n\"be a consequence of the rest of this License.\\n\"\n\"\f\\n\"\n\"  8. If the distribution and/or use of the Program is restricted in\\n\"\n\"certain countries either by patents or by copyrighted interfaces, the\\n\"\n\"original copyright holder who places the Program under this License\\n\"\n\"may add an explicit geographical distribution limitation excluding\\n\"\n\"those countries, so that distribution is permitted only in or among\\n\"\n\"countries not thus excluded.  In such case, this License incorporates\\n\"\n\"the limitation as if written in the body of this License.\\n\"\n\"\\n\"\n\"  9. The Free Software Foundation may publish revised and/or new versions\\n\"\n\"of the General Public License from time to time.  Such new versions will\\n\"\n\"be similar in spirit to the present version, but may differ in detail to\\n\"\n\"address new problems or concerns.\\n\"\n\"\\n\"\n\"Each version is given a distinguishing version number.  If the Program\\n\"\n\"specifies a version number of this License which applies to it and \\\"any\\n\"\n\"later version\\\", you have the option of following the terms and conditions\\n\"\n\"either of that version or of any later version published by the Free\\n\"\n\"Software Foundation.  If the Program does not specify a version number of\\n\"\n\"this License, you may choose any version ever published by the Free Software\\n\"\n\"Foundation.\\n\"\n\"\\n\"\n\"  10. If you wish to incorporate parts of the Program into other free\\n\"\n\"programs whose distribution conditions are different, write to the author\\n\"\n\"to ask for permission.  For software which is copyrighted by the Free\\n\"\n\"Software Foundation, write to the Free Software Foundation; we sometimes\\n\"\n\"make exceptions for this.  Our decision will be guided by the two goals\\n\"\n\"of preserving the free status of all derivatives of our free software and\\n\"\n\"of promoting the sharing and reuse of software generally.\\n\"\n\"\\n\"\n#endif\n\"\t\t\t    NO WARRANTY\\n\"\n\"\\n\"\n\"  11. BECAUSE THE PROGRAM IS LICENSED FREE OF CHARGE, THERE IS NO WARRANTY\\n\"\n\"FOR THE PROGRAM, TO THE EXTENT PERMITTED BY APPLICABLE LAW.  EXCEPT WHEN\\n\"\n\"OTHERWISE STATED IN WRITING THE COPYRIGHT HOLDERS AND/OR OTHER PARTIES\\n\"\n\"PROVIDE THE PROGRAM \\\"AS IS\\\" WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED\\n\"\n\"OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF\\n\"\n\"MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.  THE ENTIRE RISK AS\\n\"\n\"TO THE QUALITY AND PERFORMANCE OF THE PROGRAM IS WITH YOU.  SHOULD THE\\n\"\n\"PROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF ALL NECESSARY SERVICING,\\n\"\n\"REPAIR OR CORRECTION.\\n\"\n\"\\n\"\n\"  12. IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING\\n\"\n\"WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MAY MODIFY AND/OR\\n\"\n\"REDISTRIBUTE THE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES,\\n\"\n\"INCLUDING ANY GENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING\\n\"\n\"OUT OF THE USE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED\\n\"\n\"TO LOSS OF DATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY\\n\"\n\"YOU OR THIRD PARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER\\n\"\n\"PROGRAMS), EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE\\n\"\n\"POSSIBILITY OF SUCH DAMAGES.\\n\"\n\"\\n\"\n#if !SKIP_HELP\n\"\t\t     END OF TERMS AND CONDITIONS\\n\"\n\"\f\\n\"\n\"\tAppendix: How to Apply These Terms to Your New Programs\\n\"\n\"\\n\"\n\"  If you develop a new program, and you want it to be of the greatest\\n\"\n\"possible use to the public, the best way to achieve this is to make it\\n\"\n\"free software which everyone can redistribute and change under these terms.\\n\"\n\"\\n\"\n\"  To do so, attach the following notices to the program.  It is safest\\n\"\n\"to attach them to the start of each source file to most effectively\\n\"\n\"convey the exclusion of warranty; and each file should have at least\\n\"\n\"the \\\"copyright\\\" line and a pointer to where the full notice is found.\\n\"\n\"\\n\"\n\"    <one line to give the program's name and a brief idea of what it does.>\\n\"\n\"    Copyright (C) 19yy  <name of author>\\n\"\n\"\\n\"\n\"    This program is free software; you can redistribute it and/or modify\\n\"\n\"    it under the terms of the GNU General Public License as published by\\n\"\n\"    the Free Software Foundation; either version 2 of the License, or\\n\"\n\"    (at your option) any later version.\\n\"\n\"\\n\"\n\"    This program is distributed in the hope that it will be useful,\\n\"\n\"    but WITHOUT ANY WARRANTY; without even the implied warranty of\\n\"\n\"    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n\"\n\"    GNU General Public License for more details.\\n\"\n\"\\n\"\n\"    You should have received a copy of the GNU General Public License\\n\"\n\"    along with this program; if not, write to the Free Software\\n\"\n\"    Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.\\n\"\n\"\\n\"\n\"Also add information on how to contact you by electronic and paper mail.\\n\"\n\"\\n\"\n\"If the program is interactive, make it output a short notice like this\\n\"\n\"when it starts in an interactive mode:\\n\"\n\"\\n\"\n\"    Gnomovision version 69, Copyright (C) 19yy name of author\\n\"\n\"    Gnomovision comes with ABSOLUTELY NO WARRANTY; for details type `show w'.\\n\"\n\"    This is free software, and you are welcome to redistribute it\\n\"\n\"    under certain conditions; type `show c' for details.\\n\"\n\"\\n\"\n\"The hypothetical commands `show w' and `show c' should show the appropriate\\n\"\n\"parts of the General Public License.  Of course, the commands you use may\\n\"\n\"be called something other than `show w' and `show c'; they could even be\\n\"\n\"mouse-clicks or menu items--whatever suits your program.\\n\"\n\"\\n\"\n\"You should also get your employer (if you work as a programmer) or your\\n\"\n\"school, if any, to sign a \\\"copyright disclaimer\\\" for the program, if\\n\"\n\"necessary.  Here is a sample; alter the names:\\n\"\n\"\\n\"\n\"  Yoyodyne, Inc., hereby disclaims all copyright interest in the program\\n\"\n\"  `Gnomovision' (which makes passes at compilers) written by James Hacker.\\n\"\n\"\\n\"\n\"  <signature of Ty Coon>, 1 April 1989\\n\"\n\"  Ty Coon, President of Vice\\n\"\n\"\\n\"\n\"This General Public License does not permit incorporating your program into\\n\"\n\"proprietary programs.  If your program is a subroutine library, you may\\n\"\n\"consider it more useful to permit linking proprietary applications with the\\n\"\n\"library.  If this is what you want to do, use the GNU Library General\\n\"\n\"Public License instead of this License.\\n\"\n#endif\n;\n\n\tchar top[] =\n\"\\n\"\n\"x11vnc: a VNC server for X displays.  %s\\n\"\n\"\\n\"\n\"Copyright (C) 2002-2010 Karl J. Runge <runge@karlrunge.com>\\n\"\n\"All rights reserved.\\n\"\n\"\\n\"\n;\n\tdup2(1, 2);\n\tfprintf(stderr, top, lastmod);\n\tfprintf(stderr, \"%s\", license);\n\texit(1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "arg",
            "\"-warranty\""
          ],
          "line": 3178
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "arg",
            "\"-copying\""
          ],
          "line": 3178
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "arg",
            "\"-license\""
          ],
          "line": 3177
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stdout",
            "\"x11vnc: %s\\n\"",
            "lastmod"
          ],
          "line": 3173
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "arg",
            "\"-version\""
          ],
          "line": 3172
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "arg",
            "\"-V\""
          ],
          "line": 3172
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "print_help",
          "args": [
            "1"
          ],
          "line": 3169
        },
        "resolved": true,
        "details": {
          "function_name": "print_help",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/help.c",
          "lines": "49-5893",
          "snippet": "void print_help(int mode) {\n#if !SKIP_HELP\n\tchar help[] = \n\"\\n\"\n\"x11vnc: allow VNC connections to real X11 displays. %s\\n\"\n\"\\n\"\n\"(type \\\"x11vnc -opts\\\" to just list the options.)\\n\"\n\"\\n\"\n\"Typical usage is:\\n\"\n\"\\n\"\n\"   Run this command in a shell on the remote machine \\\"far-host\\\"\\n\"\n\"   with X session you wish to view:\\n\"\n\"\\n\"\n\"       x11vnc -display :0\\n\"\n\"\\n\"\n\"   Then run this in another window on the machine you are sitting at:\\n\"\n\"\\n\"\n\"       vncviewer far-host:0\\n\"\n\"\\n\"\n\"Once x11vnc establishes connections with the X11 server and starts listening\\n\"\n\"as a VNC server it will print out a string: PORT=XXXX where XXXX is typically\\n\"\n\"5900 (the default VNC server port).  One would next run something like\\n\"\n\"this on the local machine: \\\"vncviewer hostname:N\\\" where \\\"hostname\\\" is\\n\"\n\"the name of the machine running x11vnc and N is XXXX - 5900, i.e. usually\\n\"\n\"\\\"vncviewer hostname:0\\\".\\n\"\n\"\\n\"\n\"By default x11vnc will not allow the screen to be shared and it will exit\\n\"\n\"as soon as the client disconnects.  See -shared and -forever below to override\\n\"\n\"these protections.  See the FAQ for details how to tunnel the VNC connection\\n\"\n\"through an encrypted channel such as ssh(1).  In brief:\\n\"\n\"\\n\"\n\"       ssh -t -L 5900:localhost:5900 far-host 'x11vnc -localhost -display :0'\\n\"\n\"\\n\"\n\"       vncviewer -encodings 'copyrect tight zrle hextile' localhost:0\\n\"\n\"\\n\"\n\"Also, use of a VNC password (-rfbauth or -passwdfile) is strongly recommended.\\n\"\n\"\\n\"\n\"For additional info see: http://www.karlrunge.com/x11vnc/\\n\"\n\"                    and  http://www.karlrunge.com/x11vnc/faq.html\\n\"\n\"\\n\"\n\"\\n\"\n\"Config file support: if the file $HOME/.x11vncrc exists then each line in\\n\"\n\"it is treated as a single command line option.  Disable with -norc.  For\\n\"\n\"each option name, the leading character \\\"-\\\" is not required.  E.g. a line\\n\"\n\"that is either \\\"forever\\\" or \\\"-forever\\\" may be used and are equivalent.\\n\"\n\"Likewise \\\"wait 100\\\" or \\\"-wait 100\\\" are acceptable and equivalent lines.\\n\"\n\"The \\\"#\\\" character comments out to the end of the line in the usual way\\n\"\n\"(backslash it for a literal).  Leading and trailing whitespace is trimmed off.\\n\"\n\"Lines may be continued with a \\\"\\\\\\\" as the last character of a line (it\\n\"\n\"becomes a space character).\\n\"\n\"\\n\"\n\"Options:\\n\"\n\"\\n\"\n\"-display disp          X11 server display to connect to, usually :0.  The X\\n\"\n\"                       server process must be running on same machine and\\n\"\n\"                       support MIT-SHM.  Equivalent to setting the DISPLAY\\n\"\n\"                       environment variable to \\\"disp\\\".\\n\"\n\"\\n\"\n\"                       See the description below of the \\\"-display WAIT:...\\\"\\n\"\n\"                       extensions, where alias \\\"-find\\\" will find the user's\\n\"\n\"                       display automatically, and \\\"-create\\\" will create a\\n\"\n\"                       Xvfb session if no session is found.\\n\"\n\"\\n\"\n\"-auth file             Set the X authority file to be \\\"file\\\", equivalent to\\n\"\n\"                       setting the XAUTHORITY environment variable to \\\"file\\\"\\n\"\n\"                       before startup.  Same as -xauth file.  See Xsecurity(7),\\n\"\n\"                       xauth(1) man pages for more info.\\n\"\n\"\\n\"\n\"                       Use '-auth guess' to have x11vnc use its -findauth\\n\"\n\"                       mechanism (described below) to try to guess the\\n\"\n\"                       XAUTHORITY filename and use it.\\n\"\n\"\\n\"\n\"                       XDM/GDM/KDM: if you are running x11vnc as root and want\\n\"\n\"                       to find the XAUTHORITY before anyone has logged into an\\n\"\n\"                       X session yet, use: x11vnc -env FD_XDM=1 -auth guess ...\\n\"\n\"                       (This will also find the XAUTHORITY if a user is already\\n\"\n\"                       logged into the X session.)  When running as root,\\n\"\n\"                       FD_XDM=1 will be tried if the initial -auth guess fails.\\n\"\n\"\\n\"\n\"-N                     If the X display is :N, try to set the VNC display to\\n\"\n\"                       also be :N This just sets the -rfbport option to 5900+N\\n\"\n\"                       The program will exit immediately if that port is not\\n\"\n\"                       available. The -N option only works with normal -display\\n\"\n\"                       usage, e.g. :0 or :8, -N is ignored in the -display\\n\"\n\"                       WAIT:..., -create, -find, -svc, -redirect, etc modes.\\n\"\n\"\\n\"\n\"-autoport n            Automatically probe for a free VNC port starting at n.\\n\"\n\"                       The default is to start probing at 5900.  Use this to\\n\"\n\"                       stay away from other VNC servers near 5900.\\n\"\n\"\\n\"\n\"-rfbport str           The VNC port to listen on (a LibVNCServer option), e.g.\\n\"\n\"                       5900, 5901, etc.  If specified as \\\"-rfbport PROMPT\\\"\\n\"\n\"                       then the x11vnc -gui is used to prompt the user to\\n\"\n\"                       enter the port number.\\n\"\n\"\\n\"\n#if X11VNC_IPV6\n\"-6                     IPv6 listening support.  In addition to IPv4, the\\n\"\n\"                       IPv6 address is listened on for incoming connections.\\n\"\n\"                       The same port number as IPv4 is used.\\n\"\n\"\\n\"\n#if X11VNC_LISTEN6\n\"                       NOTE:  This x11vnc binary was compiled to have the\\n\"\n\"                       \\\"-6\\\" IPv6 listening mode ENABLED by default (CPPFLAGS\\n\"\n\"                       -DX11VNC_LISTEN6=1).  So to disable IPv6 listening mode\\n\"\n\"                       you MUST supply the \\\"-no6\\\" option (see below.)\\n\"\n#else\n\"                       NOTE:  This x11vnc binary was compiled to have\\n\"\n\"                       the \\\"-6\\\" IPv6 listening mode DISABLED by default\\n\"\n\"                       (CPPFLAGS -DX11VNC_LISTEN6=0).\\n\"\n#endif\n\"\\n\"\n\"                       The \\\"-6\\\" mode works for both normal connections and\\n\"\n\"                       -ssl encrypted ones.  Nearly everything is supported\\n\"\n\"                       for the IPv6 case, but there are a few exceptions.\\n\"\n\"                       See -stunnel for its IPv6 support.\\n\"\n\"\\n\"\n\"                       Currently, for absolutely everything to work correctly\\n\"\n\"                       the machine may need to have some IPv4 support, at the\\n\"\n\"                       least for the loopback interface.  However, for nearly\\n\"\n\"                       all usage modes no IPv4 support is required. See -noipv4.\\n\"\n\"\\n\"\n\"                       If you have trouble compiling or running in IPv6 mode,\\n\"\n\"                       set -DX11VNC_IPV6=0 in CPPFLAGS when configuring to\\n\"\n\"                       disable IPv6 support.\\n\"\n\"\\n\"\n\"-no6                   Disable IPv6 listening support (only useful if the\\n\"\n\"                       \\\"-6\\\" mode is compiled in to be the default; see the\\n\"\n\"                       X11VNC_LISTEN6 description above under \\\"-6\\\".)\\n\"\n\"\\n\"\n\"-noipv6                Do not try to use IPv6 for any listening or connecting\\n\"\n\"                       sockets.  This includes both the listening service\\n\"\n\"                       port(s) and outgoing connections from -connect,\\n\"\n\"                       -connect_or_exit, or -proxy.  Use this if you are having\\n\"\n\"                       problems due to IPv6.\\n\"\n\"\\n\"\n\"-noipv4                Do not try to use IPv4 for any listening or connecting\\n\"\n\"                       sockets.  This is mainly for exploring the behavior of\\n\"\n\"                       x11vnc on an IPv6-only system, but may have other uses.\\n\"\n\"\\n\"\n#endif\n\"-reopen                If the X server connection is disconnected, try to\\n\"\n\"                       reopen the X display (up to one time.)  This is of use\\n\"\n\"                       for display managers like GDM (KillInitClients option)\\n\"\n\"                       that kill x11vnc just after the user logs into the\\n\"\n\"                       X session.  Note: the reopened state may be unstable.\\n\"\n\"                       Set X11VNC_REOPEN_DISPLAY=n to reopen n times and\\n\"\n\"                       set X11VNC_REOPEN_SLEEP_MAX to the number of seconds,\\n\"\n\"                       default 10, to keep trying to reopen the display (once\\n\"\n\"                       per second.)\\n\"\n\"\\n\"\n\"                       Update: as of 0.9.9, x11vnc tries to automatically avoid\\n\"\n\"                       being killed by the display manager by delaying creating\\n\"\n\"                       windows or using XFIXES.  So you shouldn't need to use\\n\"\n\"                       KillInitClients=false as long as you log in quickly\\n\"\n\"                       enough (within 45 seconds of connecting.)  You can\\n\"\n\"                       disable this by setting X11VNC_AVOID_WINDOWS=never.\\n\"\n\"                       You can also set it to the number of seconds to delay.\\n\"\n\"\\n\"\n\"-reflect host:N        Instead of connecting to and polling an X display,\\n\"\n\"                       connect to the remote VNC server host:N and be a\\n\"\n\"                       reflector/repeater for it.  This is useful for trying\\n\"\n\"                       to manage the case of many simultaneous VNC viewers\\n\"\n\"                       (e.g. classroom broadcasting) where, e.g. you put\\n\"\n\"                       a repeater on each network switch, etc, to improve\\n\"\n\"                       performance by distributing the load and network\\n\"\n\"                       traffic.  Implies -shared (use -noshared as a later\\n\"\n\"                       option to disable). See the discussion below under\\n\"\n\"                       -rawfb vnc:host:N for more details.\\n\"\n\"\\n\"\n\"-id windowid           Show the X window corresponding to \\\"windowid\\\" not\\n\"\n\"                       the entire display.  New windows like popup menus,\\n\"\n\"                       transient toplevels, etc, may not be seen or may be\\n\"\n\"                       clipped.  Disabling SaveUnders or BackingStore in the\\n\"\n\"                       X server may help show them.  x11vnc may crash if the\\n\"\n\"                       window is initially partially obscured, changes size,\\n\"\n\"                       is iconified, etc.  Some steps are taken to avoid this\\n\"\n\"                       and the -xrandr mechanism is used to track resizes.  Use\\n\"\n\"                       xwininfo(1) to get the window id, or use \\\"-id pick\\\"\\n\"\n\"                       to have x11vnc run xwininfo(1) for you and extract\\n\"\n\"                       the id.  The -id option is useful for exporting very\\n\"\n\"                       simple applications (e.g. the current view on a webcam).\\n\"\n\"-sid windowid          As -id, but instead of using the window directly it\\n\"\n\"                       shifts a root view to it: this shows SaveUnders menus,\\n\"\n\"                       etc, although they will be clipped if they extend beyond\\n\"\n\"                       the window.\\n\"\n\"\\n\"\n\"-appshare              Simple application sharing based on the -id/-sid\\n\"\n\"                       mechanism.  Every new toplevel window that the\\n\"\n\"                       application creates induces a new viewer window via\\n\"\n\"                       a reverse connection.  The -id/-sid and -connect\\n\"\n\"                       options are required.  Run 'x11vnc -appshare -help'\\n\"\n\"                       for more info.\\n\"\n\"\\n\"\n#if 0\n\"-freeze_when_obscured  Probably only of use in -appshare mode: if the -id/-sid\\n\"\n\"                       window is partially or fully obscured by other windows,\\n\"\n\"                       stop checking for framebuffer updates.  Mouse and\\n\"\n\"                       keyboard events are still processed and injected.\\n\"\n\"\\n\"\n#endif\n\"-clip WxH+X+Y          Only show the sub-region of the full display that\\n\"\n\"                       corresponds to the rectangle geometry with size WxH and\\n\"\n\"                       offset +X+Y.  The VNC display has size WxH (i.e. smaller\\n\"\n\"                       than the full display).  This also works for -id/-sid\\n\"\n\"                       mode where the offset is relative to the upper left\\n\"\n\"                       corner of the selected window.  An example use of this\\n\"\n\"                       option would be to split a large (e.g. Xinerama) display\\n\"\n\"                       into two parts to be accessed via separate viewers by\\n\"\n\"                       running a separate x11vnc on each part.\\n\"\n\"\\n\"\n\"                       Use '-clip xinerama0' to clip to the first xinerama\\n\"\n\"                       sub-screen (if xinerama is active).  xinerama1 for the\\n\"\n\"                       2nd sub-screen, etc.  This way you don't need to figure\\n\"\n\"                       out the WxH+X+Y of the desired xinerama sub-screen.\\n\"\n\"                       screens are sorted in increasing distance from the\\n\"\n\"                       (0,0) origin (I.e. not the Xserver's order).\\n\"\n\"\\n\"\n\"-flashcmap             In 8bpp indexed color, let the installed colormap flash\\n\"\n\"                       as the pointer moves from window to window (slow).\\n\"\n\"                       Also try the -8to24 option to avoid flash altogether.\\n\"\n\"-shiftcmap n           Rare problem, but some 8bpp displays use less than 256\\n\"\n\"                       colorcells (e.g. 16-color grayscale, perhaps the other\\n\"\n\"                       bits are used for double buffering) *and* also need to\\n\"\n\"                       shift the pixels values away from 0, .., ncells.  \\\"n\\\"\\n\"\n\"                       indicates the shift to be applied to the pixel values.\\n\"\n\"                       To see the pixel values set DEBUG_CMAP=1 to print out\\n\"\n\"                       a colormap histogram.  Example: -shiftcmap 240\\n\"\n\"-notruecolor           For 8bpp displays, force indexed color (i.e. a colormap)\\n\"\n\"                       even if it looks like 8bpp TrueColor (rare problem).\\n\"\n\"-advertise_truecolor   If the X11 display is indexed color, lie to clients\\n\"\n\"                       when they first connect by telling them it is truecolor.\\n\"\n\"                       To workaround RealVNC: inPF has colourMap but not 8bpp\\n\"\n\"                       Use '-advertise_truecolor reset' to reset client fb too.\\n\"\n\"\\n\"\n\"-visual n              This option probably does not do what you think.\\n\"\n\"                       It simply *forces* the visual used for the framebuffer;\\n\"\n\"                       this may be a bad thing... (e.g. messes up colors or\\n\"\n\"                       cause a crash). It is useful for testing and for some\\n\"\n\"                       workarounds.  n may be a decimal number, or 0x hex.\\n\"\n\"                       Run xdpyinfo(1) for the values.  One may also use\\n\"\n\"                       \\\"TrueColor\\\", etc. see <X11/X.h> for a list.  If the\\n\"\n\"                       string ends in \\\":m\\\" then for better or for worse\\n\"\n\"                       the visual depth is forced to be m.  You may want to\\n\"\n\"                       use -noshm when using this option (so XGetImage may\\n\"\n\"                       automatically translate the pixel data).\\n\"\n\"\\n\"\n\"-overlay               Handle multiple depth visuals on one screen, e.g. 8+24\\n\"\n\"                       and 24+8 overlay visuals (the 32 bits per pixel are\\n\"\n\"                       packed with 8 for PseudoColor and 24 for TrueColor).\\n\"\n\"\\n\"\n\"                       Currently -overlay only works on Solaris via\\n\"\n\"                       XReadScreen(3X11) and IRIX using XReadDisplay(3).\\n\"\n\"                       On Solaris there is a problem with image \\\"bleeding\\\"\\n\"\n\"                       around transient popup menus (but not for the menu\\n\"\n\"                       itself): a workaround is to disable SaveUnders\\n\"\n\"                       by passing the \\\"-su\\\" argument to Xsun (in\\n\"\n\"                       /etc/dt/config/Xservers).\\n\"\n\"\\n\"\n\"                       Use -overlay as a workaround for situations like these:\\n\"\n\"                       Some legacy applications require the default visual to\\n\"\n\"                       be 8bpp (8+24), or they will use 8bpp PseudoColor even\\n\"\n\"                       when the default visual is depth 24 TrueColor (24+8).\\n\"\n\"                       In these cases colors in some windows will be incorrect\\n\"\n\"                       in x11vnc unless -overlay is used.  Another use of\\n\"\n\"                       -overlay is to enable showing the exact mouse cursor\\n\"\n\"                       shape (details below).\\n\"\n\"\\n\"\n\"                       Under -overlay, performance will be somewhat slower\\n\"\n\"                       due to the extra image transformations required.\\n\"\n\"                       For optimal performance do not use -overlay, but rather\\n\"\n\"                       configure the X server so that the default visual is\\n\"\n\"                       depth 24 TrueColor and try to have all apps use that\\n\"\n\"                       visual (e.g. some apps have -use24 or -visual options).\\n\"\n\"-overlay_nocursor      Sets -overlay, but does not try to draw the exact mouse\\n\"\n\"                       cursor shape using the overlay mechanism.\\n\"\n\"\\n\"\n\"-8to24 [opts]          Try this option if -overlay is not supported on your\\n\"\n\"                       OS, and you have a legacy 8bpp app that you want to\\n\"\n\"                       view on a multi-depth display with default depth 24\\n\"\n\"                       (and is 32 bpp) OR have a default depth 8 display with\\n\"\n\"                       depth 24 overlay windows for some apps.  This option\\n\"\n\"                       may not work on all X servers and hardware (tested\\n\"\n\"                       on XFree86/Xorg mga driver and Xsun).  The \\\"opts\\\"\\n\"\n\"                       string is not required and is described below.\\n\"\n\"\\n\"\n\"                       This mode enables a hack where x11vnc monitors windows\\n\"\n\"                       within 3 levels from the root window.  If it finds\\n\"\n\"                       any that are 8bpp it extracts the indexed color\\n\"\n\"                       pixel values using XGetImage() and then applies a\\n\"\n\"                       transformation using the colormap(s) to create TrueColor\\n\"\n\"                       RGB values that it in turn inserts into bits 1-24 of\\n\"\n\"                       the framebuffer.  This creates a depth 24 \\\"view\\\"\\n\"\n\"                       of the display that is then exported via VNC.\\n\"\n\"\\n\"\n\"                       Conversely, for default depth 8 displays, the depth\\n\"\n\"                       24 regions are read by XGetImage() and everything is\\n\"\n\"                       transformed and inserted into a depth 24 TrueColor\\n\"\n\"                       framebuffer.\\n\"\n\"\\n\"\n\"                       Note that even if there are *no* depth 24 visuals or\\n\"\n\"                       windows (i.e. pure 8bpp), this mode is potentially\\n\"\n\"                       an improvement over -flashcmap because it avoids the\\n\"\n\"                       flashing and shows each window in the correct color.\\n\"\n\"\\n\"\n\"                       This method works OK, but may still have bugs and it\\n\"\n\"                       does hog resources.  If there are multiple 8bpp windows\\n\"\n\"                       using different colormaps, one may have to iconify all\\n\"\n\"                       but one for the colors to be correct.\\n\"\n\"\\n\"\n\"                       There may be painting errors for clipping and switching\\n\"\n\"                       between windows of depths 8 and 24.  Heuristics are\\n\"\n\"                       applied to try to minimize the painting errors.  One can\\n\"\n\"                       also press 3 Alt_L's in a row to refresh the screen\\n\"\n\"                       if the error does not repair itself.  Also the option\\n\"\n\"                       -fixscreen 8=3.0 or -fixscreen V=3.0 may be used to\\n\"\n\"                       periodically refresh the screen at the cost of bandwidth\\n\"\n\"                       (every 3 sec for this example).\\n\"\n\"\\n\"\n\"                       The [opts] string can contain the following settings.\\n\"\n\"                       Multiple settings are separated by commas.\\n\"\n\"\\n\"\n\"                       For for some X servers with default depth 24 a\\n\"\n\"                       speedup may be achieved via the option \\\"nogetimage\\\".\\n\"\n\"                       This enables a scheme were XGetImage() is not used\\n\"\n\"                       to retrieve the 8bpp data.  Instead, it assumes that\\n\"\n\"                       the 8bpp data is in bits 25-32 of the 32bit X pixels.\\n\"\n\"                       There is no requirement that the X server should put\\n\"\n\"                       the data there for our poll requests, but some do and\\n\"\n\"                       so the extra steps to retrieve it can be skipped.\\n\"\n\"                       Tested with mga driver with XFree86/Xorg.  For the\\n\"\n\"                       default depth 8 case this option is ignored.\\n\"\n\"\\n\"\n\"                       To adjust how often XGetImage() is used to poll the\\n\"\n\"                       non-default visual regions for changes, use the option\\n\"\n\"                       \\\"poll=t\\\" where \\\"t\\\" is a floating point time.\\n\"\n\"                       (default: %.2f)\\n\"\n\"\\n\"\n\"                       Setting the option \\\"level2\\\" will limit the search\\n\"\n\"                       for non-default visual windows to two levels from the\\n\"\n\"                       root window.  Do this on slow machines where you know\\n\"\n\"                       the window manager only imposes one extra window between\\n\"\n\"                       the app window and the root window.\\n\"\n\"\\n\"\n\"                       Also for very slow machines use \\\"cachewin=t\\\"\\n\"\n\"                       where t is a floating point amount of time to cache\\n\"\n\"                       XGetWindowAttributes results.  E.g. cachewin=5.0.\\n\"\n\"                       This may lead to the windows being unnoticed for this\\n\"\n\"                       amount of time when deiconifying, painting errors, etc.\\n\"\n\"\\n\"\n\"                       While testing on a very old SS20 these options gave\\n\"\n\"                       tolerable response: -8to24 poll=0.2,cachewin=5.0. For\\n\"\n\"                       this machine -overlay is supported and gives better\\n\"\n\"                       response.\\n\"\n\"\\n\"\n\"                       Debugging for this mode can be enabled by setting\\n\"\n\"                       \\\"dbg=1\\\", \\\"dbg=2\\\", or \\\"dbg=3\\\".\\n\"\n\"\\n\"\n\"-24to32                Very rare problem: if the framebuffer (X display\\n\"\n\"                       or -rawfb) is 24bpp instead of the usual 32bpp, then\\n\"\n\"                       dynamically transform the pixels to 32bpp.  This will be\\n\"\n\"                       slower, but can be used to work around problems where\\n\"\n\"                       VNC viewers cannot handle 24bpp (e.g. \\\"main: setPF:\\n\"\n\"                       not 8, 16 or 32 bpp?\\\").  See the FAQ for more info.\\n\"\n\"\\n\"\n\"                       In the case of -rawfb mode, the pixels are directly\\n\"\n\"                       modified by inserting a 0 byte to pad them out to 32bpp.\\n\"\n\"                       For X displays, a kludge is done that is equivalent to\\n\"\n\"                       \\\"-noshm -visual TrueColor:32\\\".  (If better performance\\n\"\n\"                       is needed for the latter, feel free to ask).\\n\"\n\"\\n\"\n\"-scale fraction        Scale the framebuffer by factor \\\"fraction\\\".  Values\\n\"\n\"                       less than 1 shrink the fb, larger ones expand it. Note:\\n\"\n\"                       the image may not be sharp and response may be slower.\\n\"\n\"                       If \\\"fraction\\\" contains a decimal point \\\".\\\" it\\n\"\n\"                       is taken as a floating point number, alternatively\\n\"\n\"                       the notation \\\"m/n\\\" may be used to denote fractions\\n\"\n\"                       exactly, e.g. -scale 2/3\\n\"\n\"\\n\"\n\"                       To scale asymmetrically in the horizontal and vertical\\n\"\n\"                       directions, specify a WxH geometry to stretch to:\\n\"\n\"                       e.g. '-scale 1024x768', or also '-scale 0.9x0.75'\\n\"\n\"\\n\"\n\"                       Scaling Options: can be added after \\\"fraction\\\" via\\n\"\n\"                       \\\":\\\", to supply multiple \\\":\\\" options use commas.\\n\"\n\"                       If you just want a quick, rough scaling without\\n\"\n\"                       blending, append \\\":nb\\\" to \\\"fraction\\\" (e.g. -scale\\n\"\n\"                       1/3:nb).  No blending is the default for 8bpp indexed\\n\"\n\"                       color, to force blending for this case use \\\":fb\\\".\\n\"\n\"\\n\"\n\"                       To disable -scrollcopyrect and -wirecopyrect under\\n\"\n\"                       -scale use \\\":nocr\\\".  If you need to to enable them use\\n\"\n\"                       \\\":cr\\\" or specify them explicitly on the command line.\\n\"\n\"                       If a slow link is detected, \\\":nocr\\\" may be applied\\n\"\n\"                       automatically.  Default: %s\\n\"\n\"\\n\"\n\"                       More esoteric options: for compatibility with vncviewers\\n\"\n\"                       the scaled width is adjusted to be a multiple of 4:\\n\"\n\"                       to disable this use \\\":n4\\\".  \\\":in\\\" use interpolation\\n\"\n\"                       scheme even when shrinking, \\\":pad\\\" pad scaled width\\n\"\n\"                       and height to be multiples of scaling denominator\\n\"\n\"                       (e.g. 3 for 2/3).\\n\"\n\"\\n\"\n\"-geometry WxH          Same as -scale WxH\\n\"\n\"\\n\"\n\"-scale_cursor frac     By default if -scale is supplied the cursor shape is\\n\"\n\"                       scaled by the same factor.  Depending on your usage,\\n\"\n\"                       you may want to scale the cursor independently of the\\n\"\n\"                       screen or not at all.  If you specify -scale_cursor\\n\"\n\"                       the cursor will be scaled by that factor.  When using\\n\"\n\"                       -scale mode to keep the cursor at its \\\"natural\\\" size\\n\"\n\"                       use \\\"-scale_cursor 1\\\".  Most of the \\\":\\\" scaling\\n\"\n\"                       options apply here as well.\\n\"\n\"\\n\"\n\"-viewonly              All VNC clients can only watch (default %s).\\n\"\n\"-shared                VNC display is shared, i.e. more than one viewer can\\n\"\n\"                       connect at the same time (default %s).\\n\"\n\"-once                  Exit after the first successfully connected viewer\\n\"\n\"                       disconnects, opposite of -forever. This is the Default.\\n\"\n\"-forever               Keep listening for more connections rather than exiting\\n\"\n\"                       as soon as the first client(s) disconnect. Same as -many\\n\"\n\"\\n\"\n\"                       To get the standard non-shared VNC behavior where when\\n\"\n\"                       a new VNC client connects the existing VNC client is\\n\"\n\"                       dropped use:  -nevershared -forever   This method can\\n\"\n\"                       also be used to guard against hung TCP connections that\\n\"\n\"                       do not go away.\\n\"\n\"\\n\"\n\"-loop                  Create an outer loop restarting the x11vnc process\\n\"\n\"                       whenever it terminates.  -bg and -inetd are ignored\\n\"\n\"                       in this mode (however see -loopbg below).\\n\"\n\"\\n\"\n\"                       Useful for continuing even if the X server terminates\\n\"\n\"                       and restarts (at that moment the process will need\\n\"\n\"                       permission to reconnect to the new X server of course).\\n\"\n\"\\n\"\n\"                       Use, e.g., -loop100 to sleep 100 millisecs between\\n\"\n\"                       restarts, etc.  Default is 2000ms (i.e. 2 secs) Use,\\n\"\n\"                       e.g. -loop300,5 to sleep 300 ms and only loop 5 times.\\n\"\n\"\\n\"\n\"                       If -loopbg (plus any numbers) is specified instead,\\n\"\n\"                       the \\\"-bg\\\" option is implied and the mode approximates\\n\"\n\"                       inetd(8) usage to some degree.  In this case when\\n\"\n\"                       it goes into the background any listening sockets\\n\"\n\"                       (i.e. ports 5900, 5800) are closed, so the next one\\n\"\n\"                       in the loop can use them.  This mode will only be of\\n\"\n\"                       use if a VNC client (the only client for that process)\\n\"\n\"                       is already connected before the process goes into the\\n\"\n\"                       background, for example, usage of -display WAIT:..,\\n\"\n\"                       -svc, and -connect can make use of this \\\"poor man's\\\"\\n\"\n\"                       inetd mode.  The default wait time is 500ms in this\\n\"\n\"                       mode.  This usage could use useful:  -svc -bg -loopbg\\n\"\n\"\\n\"\n\"-timeout n             Exit unless a client connects within the first n seconds\\n\"\n\"                       after startup.\\n\"\n\"\\n\"\n\"                       If there have been no connection attempts after n\\n\"\n\"                       seconds x11vnc exits immediately.  If a client is\\n\"\n\"                       trying to connect but has not progressed to the normal\\n\"\n\"                       operating state, x11vnc gives it a few more seconds\\n\"\n\"                       to finish and exits if it does not make it to the\\n\"\n\"                       normal state.\\n\"\n\"\\n\"\n\"                       For reverse connections via -connect or -connect_or_exit\\n\"\n\"                       a timeout of n seconds will be set for all reverse\\n\"\n\"                       connects.  If the connect timeout alarm goes off,\\n\"\n\"                       x11vnc will exit immediately.\\n\"\n\"\\n\"\n\"-sleepin n             At startup sleep n seconds before proceeding (e.g. to\\n\"\n\"                       allow redirs and listening clients to start up)\\n\"\n\"\\n\"\n\"                       If a range is given: '-sleepin min-max', a random value\\n\"\n\"                       between min and max is slept. E.g. '-sleepin 0-20' and\\n\"\n\"                       '-sleepin 10-30'.  Floats are allowed too.\\n\"\n\"\\n\"\n\"-inetd                 Launched by inetd(8): stdio instead of listening socket.\\n\"\n\"                       Note: if you are not redirecting stderr to a log file\\n\"\n\"                       (via shell 2> or -o option) you MUST also specify the -q\\n\"\n\"                       option, otherwise the stderr goes to the viewer which\\n\"\n\"                       will cause it to abort.  Specifying both -inetd and -q\\n\"\n\"                       and no -o will automatically close the stderr.\\n\"\n\"\\n\"\n\"-tightfilexfer         Enable the TightVNC file transfer extension. Note that\\n\"\n\"                       that when the -viewonly option is supplied all file\\n\"\n\"                       transfers are disabled.  Also clients that log in\\n\"\n\"                       viewonly cannot transfer files.  However, if the remote\\n\"\n\"                       control mechanism is used to change the global or\\n\"\n\"                       per-client viewonly state the filetransfer permissions\\n\"\n\"                       will NOT change.\\n\"\n\"\\n\"\n\"                       IMPORTANT: please understand if -tightfilexfer is\\n\"\n\"                       specified and you run x11vnc as root for, say, inetd\\n\"\n\"                       or display manager (gdm, kdm, ...) access and you do\\n\"\n\"                       not have it switch users via the -users option, then\\n\"\n\"                       VNC Viewers that connect are able to do filetransfer\\n\"\n\"                       reads and writes as *root*.\\n\"\n\"\\n\"\n\"                       Also, tightfilexfer is disabled in -unixpw mode.\\n\"\n\"\\n\"\n\"-ultrafilexfer         Note: to enable UltraVNC filetransfer and to get it to\\n\"\n\"                       work you probably need to supply these LibVNCServer\\n\"\n\"                       options: \\\"-rfbversion 3.6 -permitfiletransfer\\\"\\n\"\n\"                       \\\"-ultrafilexfer\\\" is an alias for this combination.\\n\"\n\"\\n\"\n\"                       IMPORTANT: please understand if -ultrafilexfer is\\n\"\n\"                       specified and you run x11vnc as root for, say, inetd\\n\"\n\"                       or display manager (gdm, kdm, ...) access and you do\\n\"\n\"                       not have it switch users via the -users option, then\\n\"\n\"                       VNC Viewers that connect are able to do filetransfer\\n\"\n\"                       reads and writes as *root*.\\n\"\n\"\\n\"\n\"                       Note that sadly you cannot do both -tightfilexfer and\\n\"\n\"                       -ultrafilexfer at the same time because the latter\\n\"\n\"                       requires setting the version to 3.6 and tightvnc will\\n\"\n\"                       not do filetransfer when it sees that version number.\\n\"\n\"\\n\"\n\"-http                  Instead of using -httpdir (see below) to specify\\n\"\n\"                       where the Java vncviewer applet is, have x11vnc try\\n\"\n\"                       to *guess* where the directory is by looking relative\\n\"\n\"                       to the program location and in standard locations\\n\"\n\"                       (/usr/local/share/x11vnc/classes, etc).  Under -ssl or\\n\"\n\"                       -stunnel the ssl classes subdirectory is sought.\\n\"\n\"-http_ssl              As -http, but force lookup for ssl classes subdir.\\n\"\n\"\\n\"\n\"                       Note that for HTTPS, single-port Java applet delivery\\n\"\n\"                       you can set X11VNC_HTTPS_DOWNLOAD_WAIT_TIME to the\\n\"\n\"                       max number of seconds to wait for the applet download\\n\"\n\"                       to finish.  The default is 15.\\n\"\n\"\\n\"\n\"-avahi                 Use the Avahi/mDNS ZeroConf protocol to advertise\\n\"\n\"                       this VNC server to the local network. (Related terms:\\n\"\n\"                       Rendezvous, Bonjour).  Depending on your setup, you\\n\"\n\"                       may need to start avahi-daemon and open udp port 5353\\n\"\n\"                       in your firewall.\\n\"\n\"\\n\"\n\"                       You can set X11VNC_AVAHI_NAME, X11VNC_AVAHI_HOST,\\n\"\n\"                       and/or X11VNC_AVAHI_PORT environment variables\\n\"\n\"                       to override the default values.  For example:\\n\"\n\"                       -env X11VNC_AVAHI_NAME=wally\\n\"\n\"\\n\"\n\"                       If the avahi API cannot be found at build time, a helper\\n\"\n\"                       program like avahi-publish(1) or dns-sd(1) will be tried\\n\"\n\"\\n\"\n\"-mdns                  Same as -avahi.\\n\"\n\"-zeroconf              Same as -avahi.\\n\"\n\"\\n\"\n\"-connect string        For use with \\\"vncviewer -listen\\\" reverse connections.\\n\"\n\"                       If \\\"string\\\" has the form \\\"host\\\" or \\\"host:port\\\"\\n\"\n\"                       the connection is made once at startup.\\n\"\n\"\\n\"\n\"                       Use commas for a list of host's and host:port's.\\n\"\n\"                       E.g. -connect host1,host2 or host1:0,host2:5678.\\n\"\n\"                       Note that to reverse connect to multiple hosts at the\\n\"\n\"                       same time you will likely need to also supply: -shared\\n\"\n\"\\n\"\n\"                       Note that unlike most vnc servers, x11vnc will require a\\n\"\n\"                       password for reverse as well as for forward connections.\\n\"\n\"                       (provided password auth has been enabled, -rfbauth, etc)\\n\"\n\"                       If you do not want to require a password for reverse\\n\"\n\"                       connections set X11VNC_REVERSE_CONNECTION_NO_AUTH=1 in\\n\"\n\"                       your environment before starting x11vnc.\\n\"\n\"\\n\"\n\"                       If \\\"string\\\" contains \\\"/\\\" it is instead interpreted\\n\"\n\"                       as a file to periodically check for new hosts.\\n\"\n\"                       The first line is read and then the file is truncated.\\n\"\n\"                       Be careful about the location of this file if x11vnc\\n\"\n\"                       is running as root (e.g. via gdm(1), etc).\\n\"\n\"\\n\"\n\"\\n\"\n\"                       Repeater mode: Some services provide an intermediate\\n\"\n\"                       \\\"vnc repeater\\\": http://www.uvnc.com/addons/repeater.html\\n\"\n\"                       (and also http://koti.mbnet.fi/jtko/ for linux port)\\n\"\n\"                       that acts as a proxy/gateway.  Modes like these require\\n\"\n\"                       an initial string to be sent for the reverse connection\\n\"\n\"                       before the VNC protocol is started.  Here are the ways\\n\"\n\"                       to do this:\\n\"\n\"\\n\"\n\"                         -connect pre=some_string+host:port\\n\"\n\"                         -connect pre128=some_string+host:port\\n\"\n\"                         -connect repeater=ID:1234+host:port\\n\"\n\"                         -connect repeater=23.45.67.89::5501+host:port\\n\"\n\"\\n\"\n\"                       SSVNC notation is also supported:\\n\"\n\"\\n\"\n\"                         -connect repeater://host:port+ID:1234\\n\"\n\"\\n\"\n\"                       As with normal -connect usage, if the repeater port is\\n\"\n\"                       not supplied 5500 is assumed.\\n\"\n\"\\n\"\n\"                       The basic idea is between the special tag, e.g. \\\"pre=\\\"\\n\"\n\"                       and \\\"+\\\" is the pre-string to be sent.  Note that in\\n\"\n\"                       this case host:port is the repeater server, NOT the\\n\"\n\"                       vnc viewer.  Somehow the pre-string tells the repeater\\n\"\n\"                       server how to find the vnc viewer and connect you to it.\\n\"\n\"\\n\"\n\"                       In the case pre=some_string+host:port, \\\"some_string\\\"\\n\"\n\"                       is simply sent. In the case preNNN=some_string+host:port\\n\"\n\"                       \\\"some_string\\\" is sent in a null padded buffer of\\n\"\n\"                       length NNN.  repeater= is the same as pre250=, this is\\n\"\n\"                       the ultravnc repeater buffer size.\\n\"\n\"\\n\"\n\"                       Strings like \\\"\\\\n\\\" and \\\"\\\\r\\\", etc. are expanded to\\n\"\n\"                       newline and carriage return.  \\\"\\\\c\\\" is expanded to\\n\"\n\"                       \\\",\\\" since the connect string is comma separated.\\n\"\n\"\\n\"\n\"                       See also the -proxy option below for additional ways\\n\"\n\"                       to plumb reverse connections.\\n\"\n\"\\n\"\n\"                       Reverse SSL: using -connect in -ssl mode makes x11vnc\\n\"\n\"                       act as an SSL client (initiates SSL connection) rather\\n\"\n\"                       than an SSL server.  The idea is x11vnc might be\\n\"\n\"                       connecting to stunnel on the viewer side with the\\n\"\n\"                       viewer in listening mode.  If you do not want this\\n\"\n\"                       behavior, use -env X11VNC_DISABLE_SSL_CLIENT_MODE=1.\\n\"\n\"                       With this the viewer side can act as the SSL client\\n\"\n\"                       as it normally does for forward connections.\\n\"\n\"\\n\"\n\"                       Reverse SSL Repeater mode:  This will work, but note\\n\"\n\"                       that if the VNC Client does any sort of a 'Fetch Cert'\\n\"\n\"                       action before connecting, then the Repeater will\\n\"\n\"                       likely drop the connection and both sides will need\\n\"\n\"                       to restart.  Consider the use of -connect_or_exit\\n\"\n\"                       and -loop300,2 to have x11vnc reconnect once to the\\n\"\n\"                       repeater after the fetch.  You will probably also want\\n\"\n\"                       to supply -sslonly to avoid x11vnc thinking the delay\\n\"\n\"                       in response means the connection is VeNCrypt.  The env\\n\"\n\"                       var X11VNC_DISABLE_SSL_CLIENT_MODE=1 discussed above\\n\"\n\"                       may also be useful (i.e. the viewer can do a forward\\n\"\n\"                       connection as it normally does.)\\n\"\n\"\\n\"\n\"                       IPv6: as of x11vnc 0.9.10 the -connect option should\\n\"\n\"                       connect to IPv6 hosts properly.  If there are problems\\n\"\n\"                       you can disable IPv6 by setting -DX11VNC_IPV6=0\\n\"\n\"                       in CPPFLAGS when configuring.  If there problems\\n\"\n\"                       connecting to IPv6 hosts consider a relay like the\\n\"\n\"                       included inet6to4 script or the -proxy option.\\n\"\n\"\\n\"\n\"-connect_or_exit str   As with -connect, except if none of the reverse\\n\"\n\"                       connections succeed, then x11vnc shuts down immediately\\n\"\n\"\\n\"\n\"                       An easier to type alias for this option is '-coe'\\n\"\n\"\\n\"\n\"                       By the way, if you do not want x11vnc to listen on\\n\"\n\"                       ANY interface use -rfbport 0  which is handy for the\\n\"\n\"                       -connect_or_exit mode.\\n\"\n\"\\n\"\n\"-proxy string          Use proxy in string (e.g. host:port) as a proxy for\\n\"\n\"                       making reverse connections (-connect or -connect_or_exit\\n\"\n\"                       options).\\n\"\n\"\\n\"\n\"                       Web proxies are supported, but note by default most of\\n\"\n\"                       them only support destination connections to ports 443\\n\"\n\"                       or 563, so this might not be very useful (the viewer\\n\"\n\"                       would need to listen on that port or the router would\\n\"\n\"                       have to do a port redirection).\\n\"\n\"\\n\"\n\"                       A web proxy may be specified by either \\\"host:port\\\"\\n\"\n\"                       or \\\"http://host:port\\\" (the port is required even if\\n\"\n\"                       it is the common choices 80 or 8080)\\n\"\n\"\\n\"\n\"                       SOCKS4, SOCKS4a, and SOCKS5 are also supported.\\n\"\n\"                       SOCKS proxies normally do not have restrictions on the\\n\"\n\"                       destination port number.\\n\"\n\"\\n\"\n\"                       Use a format like this: socks://host:port or\\n\"\n\"                       socks5://host:port.  Note that ssh -D does not support\\n\"\n\"                       SOCKS4a, so use socks5://.  For socks:// SOCKS4 is used\\n\"\n\"                       on a numerical IP and \\\"localhost\\\", otherwise SOCKS4a\\n\"\n\"                       is used (and so the proxy tries to do the DNS lookup).\\n\"\n\"\\n\"\n\"                       An experimental mode is \\\"-proxy http://host:port/...\\\"\\n\"\n\"                       Note the \\\"/\\\" after the port that distinguishes it from\\n\"\n\"                       a normal web proxy.  The port must be supplied even if\\n\"\n\"                       it is the default 80.  For this mode a GET is done to\\n\"\n\"                       the supplied URL with the string host=H&port=P appended.\\n\"\n\"                       H and P will be the -connect reverse connect host\\n\"\n\"                       and port.  Use the string \\\"__END__\\\" to disable the\\n\"\n\"                       appending.  The basic idea here is that maybe some cgi\\n\"\n\"                       script provides the actual viewer hookup and tunnelling.\\n\"\n\"                       How to actually achieve this within cgi, php, etc. is\\n\"\n\"                       not clear...  A custom web server or apache module\\n\"\n\"                       would be straight-forward.\\n\"\n\"\\n\"\n\"                       Another experimental mode is \\\"-proxy ssh://user@host\\\"\\n\"\n\"                       in which case a SSH tunnel is used for the proxying.\\n\"\n\"                       \\\"user@\\\" is not needed unless your unix username is\\n\"\n\"                       different on \\\"host\\\".  For a non-standard SSH port\\n\"\n\"                       use ssh://user@host:port.  If proxies are chained (see\\n\"\n\"                       next paragraph) then the ssh one must be the first one.\\n\"\n\"                       If ssh-agent is not active, then the ssh password needs\\n\"\n\"                       to be entered in the terminal where x11vnc is running.\\n\"\n\"                       Examples:\\n\"\n\"\\n\"\n\"                         -connect localhost:0 -proxy ssh://me@friends-pc:2222\\n\"\n\"\\n\"\n\"                         -connect snoopy:0 -proxy ssh://ssh.company.com\\n\"\n\"\\n\"\n\"                       Multiple proxies may be chained together in case one\\n\"\n\"                       needs to ricochet off of a number of hosts to finally\\n\"\n\"                       reach the VNC viewer.  Up to 3 may be chained, separate\\n\"\n\"                       them by commas in the order they are to be connected to.\\n\"\n\"                       E.g.:  http://host1:port1,socks5://host2:port2 or three\\n\"\n\"                       like:  first,second,third\\n\"\n\"\\n\"\n\"                       IPv6: as of x11vnc 0.9.10 the -proxy option should\\n\"\n\"                       connect to IPv6 hosts properly.  If there are problems\\n\"\n\"                       you can disable IPv6 by setting -DX11VNC_IPV6=0\\n\"\n\"                       in CPPFLAGS when configuring.  If there problems\\n\"\n\"                       connecting to IPv6 hosts consider a relay like the\\n\"\n\"                       included inet6to4 script.\\n\"\n\"\\n\"\n\"-vncconnect            Monitor the VNC_CONNECT X property set by the standard\\n\"\n\"-novncconnect          VNC program vncconnect(1).  When the property is\\n\"\n\"                       set to \\\"host\\\" or \\\"host:port\\\" establish a reverse\\n\"\n\"                       connection.  Using xprop(1) instead of vncconnect may\\n\"\n\"                       work (see the FAQ).  The -remote control mechanism uses\\n\"\n\"                       X11VNC_REMOTE channel, and this option disables/enables\\n\"\n\"                       it as well.  Default: %s\\n\"\n\"\\n\"\n\"                       To use different names for these X11 properties (e.g. to\\n\"\n\"                       have separate communication channels for multiple\\n\"\n\"                       x11vnc's on the same display) set the VNC_CONNECT or\\n\"\n\"                       X11VNC_REMOTE env. vars. to the string you want, for\\n\"\n\"                       example: -env X11VNC_REMOTE=X11VNC_REMOTE_12345\\n\"\n\"                       Both sides of the channel must use the same unique name.\\n\"\n\"                       The same can be done for the internal X11VNC_TICKER\\n\"\n\"                       property (heartbeat and timestamp) if desired.\\n\"\n\"\\n\"\n\"-allow host1[,host2..] Only allow client connections from hosts matching\\n\"\n\"                       the comma separated list of hostnames or IP addresses.\\n\"\n\"                       Can also be a numerical IP prefix, e.g. \\\"192.168.100.\\\"\\n\"\n\"                       to match a simple subnet, for more control build\\n\"\n\"                       LibVNCServer with libwrap support (See the FAQ).  If the\\n\"\n\"                       list contains a \\\"/\\\" it instead is a interpreted\\n\"\n\"                       as a file containing addresses or prefixes that is\\n\"\n\"                       re-read each time a new client connects.  Lines can be\\n\"\n\"                       commented out with the \\\"#\\\" character in the usual way.\\n\"\n\"\\n\"\n\"                       -allow applies in -ssl mode, but not in -stunnel mode.\\n\"\n\"\\n\"\n\"                       IPv6: as of x11vnc 0.9.10 a host can be specified\\n\"\n\"                       in IPv6 numerical format, e.g. 2001:4860:b009::93.\\n\"\n\"\\n\"\n\"-localhost             Basically the same as \\\"-allow 127.0.0.1\\\".\\n\"\n\"\\n\"\n\"                       Note: if you want to restrict which network interface\\n\"\n\"                       x11vnc listens on, see the -listen option below.\\n\"\n\"                       E.g. \\\"-listen localhost\\\" or \\\"-listen 192.168.3.21\\\".\\n\"\n\"                       As a special case, the option \\\"-localhost\\\" implies\\n\"\n\"                       \\\"-listen localhost\\\".\\n\"\n\"\\n\"\n\"                       A rare case, but for non-localhost -listen usage, if\\n\"\n\"                       you use the remote control mechanism (-R) to change\\n\"\n\"                       the -listen interface you may need to manually adjust\\n\"\n\"                       the -allow list (and vice versa) to avoid situations\\n\"\n\"                       where no connections (or too many) are allowed.\\n\"\n\"\\n\"\n\"                       If you do not want x11vnc to listen on ANY interface\\n\"\n\"                       (evidently you are using -connect or -connect_or_exit,\\n\"\n\"                       or plan to use remote control: -R connect:host), use\\n\"\n\"                       -rfbport 0\\n\"\n\"\\n\"\n\"                       IPv6: if IPv6 is supported, this option automatically\\n\"\n\"                       implies the IPv6 loopback address '::1' as well.\\n\"\n\"\\n\"\n\"-unixsock str          Listen on the unix socket (AF_UNIX) 'str'\\n\"\n\"                       for connections.  This mode is for either local\\n\"\n\"                       connections or a tunnel endpoint where one wants the\\n\"\n\"                       file permission of the unix socket file to determine\\n\"\n\"                       what can connect to it.  (This currently requires an\\n\"\n\"                       edit to libvnserver/rfbserver.c: comment out lines 310\\n\"\n\"                       and 311, 'close(sock)' and 'return NULL' in rfbserver.c\\n\"\n\"                       after the setsockopt() call.) Note that to disable all\\n\"\n\"                       tcp listening ports specify '-rfbport 0' and should be\\n\"\n\"                       useful with this mode.  Example:\\n\"\n\"                           mkdir ~/s; chmod 700 ~/s;\\n\"\n\"                           x11vnc -unixsock ~/s/mysock -rfbport 0 ...\\n\"\n\"                       The SSVNC unix vncviewer can connect to unix sockets.\\n\"\n\"\\n\"\n#if X11VNC_IPV6\n\"-listen6 str           When in IPv6 listen mode \\\"-6\\\", listen only on the\\n\"\n\"                       network interface with address \\\"str\\\".  It also works\\n\"\n\"                       for link scope addresses (fe80::219:dbff:fee5:3f92%%eth0)\\n\"\n\"                       and IPv6 hostname strings (e.g. ipv6.google.com.)\\n\"\n\"                       Use LibVNCServer -listen option for the IPv4 interface.\\n\"\n\"\\n\"\n#endif\n\"-nolookup              Do not use gethostbyname() or gethostbyaddr() to look up\\n\"\n\"                       host names or IP numbers.  Use this if name resolution\\n\"\n\"                       is incorrectly set up and leads to long pauses as name\\n\"\n\"                       lookups time out, etc.\\n\"\n\"\\n\"\n\"-input string          Fine tuning of allowed user input.  If \\\"string\\\" does\\n\"\n\"                       not contain a comma \\\",\\\" the tuning applies only to\\n\"\n\"                       normal clients.  Otherwise the part before \\\",\\\" is\\n\"\n\"                       for normal clients and the part after for view-only\\n\"\n\"                       clients.  \\\"K\\\" is for Keystroke input, \\\"M\\\" for\\n\"\n\"                       Mouse-motion input, \\\"B\\\" for Button-click input, \\\"C\\\"\\n\"\n\"                       is for Clipboard input, and \\\"F\\\" is for File transfer\\n\"\n\"                       (ultravnc only).  Their presence in the string enables\\n\"\n\"                       that type of input.  E.g. \\\"-input M\\\" means normal\\n\"\n\"                       users can only move the mouse and  \\\"-input KMBCF,M\\\"\\n\"\n\"                       lets normal users do anything and enables view-only\\n\"\n\"                       users to move the mouse.  This option is ignored when\\n\"\n\"                       a global -viewonly is in effect (all input is discarded\\n\"\n\"                       in that case).\\n\"\n\"\\n\"\n\"-grabkbd               When VNC viewers are connected, attempt to the grab\\n\"\n\"                       the keyboard so a (non-malicious) user sitting at the\\n\"\n\"                       physical display is not able to enter keystrokes.\\n\"\n\"                       This method uses XGrabKeyboard(3X11) and so it is\\n\"\n\"                       not secure and does not rule out the person at the\\n\"\n\"                       physical display injecting keystrokes by flooding the\\n\"\n\"                       server with them, grabbing the keyboard himself, etc.\\n\"\n\"                       Some degree of cooperation from the person at the\\n\"\n\"                       display is assumed.  This is intended for remote\\n\"\n\"                       help-desk or educational usage modes.\\n\"\n\"\\n\"\n\"                       Note: on some recent (12/2010) X servers and/or\\n\"\n\"                       desktops, -grabkbd no longer works: it prevents the\\n\"\n\"                       window manager from resizing windows and similar things.\\n\"\n\"                       Try -ungrabboth below (might not work.)\\n\"\n\"\\n\"\n\"-grabptr               As -grabkbd, but for the mouse pointer using\\n\"\n\"                       XGrabPointer(3X11).  Unfortunately due to the way the X\\n\"\n\"                       server works, the mouse can still be moved around by the\\n\"\n\"                       user at the physical display, but he will not be able to\\n\"\n\"                       change window focus with it.  Also some window managers\\n\"\n\"                       that call XGrabServer(3X11) for resizes, etc, will\\n\"\n\"                       act on the local user's input.  Again, some degree of\\n\"\n\"                       cooperation from the person at the display is assumed.\\n\"\n\"\\n\"\n\"-ungrabboth            Whenever there is any input (either keyboard or\\n\"\n\"                       pointer), ungrab *both* the keyboard and the pointer\\n\"\n\"                       while injecting the synthetic input.  This is to allow\\n\"\n\"                       window managers, etc. a chance to grab.\\n\"\n\"\\n\"\n\"-grabalways            Apply both -grabkbd and -grabptr even when no VNC\\n\"\n\"                       viewers are connected.  If you only want one of them,\\n\"\n\"                       use the -R remote control to turn the other back on,\\n\"\n\"                       e.g. -R nograbptr.\\n\"\n\"\\n\"\n#ifdef ENABLE_GRABLOCAL\n\"-grablocal n           If it appears that a user sitting at the physical\\n\"\n\"                       display has injected a keystroke or mouse event ignore\\n\"\n\"                       any VNC client inputs for the next n seconds.  The idea\\n\"\n\"                       is that during a demonstration, etc, the local user\\n\"\n\"                       will not be interrupted by viewers accidentally moving\\n\"\n\"                       the mouse, etc.  The detection of local user input is\\n\"\n\"                       approximate and so at times gives unexpected results.\\n\"\n\"\\n\"\n#endif\n\"-viewpasswd string     Supply a 2nd password for view-only logins.  The -passwd\\n\"\n\"                       (full-access) password must also be supplied.\\n\"\n\"\\n\"\n\"-passwdfile filename   Specify the LibVNCServer password via the first line\\n\"\n\"                       of the file \\\"filename\\\" (instead of via -passwd on\\n\"\n\"                       the command line where others might see it via ps(1)).\\n\"\n\"\\n\"\n\"                       See the descriptions below for how to supply multiple\\n\"\n\"                       passwords, view-only passwords, to specify external\\n\"\n\"                       programs for the authentication, and other features.\\n\"\n\"\\n\"\n\"                       If the filename is prefixed with \\\"rm:\\\" it will be\\n\"\n\"                       removed after being read.  Perhaps this is useful in\\n\"\n\"                       limiting the readability of the file.  In general, the\\n\"\n\"                       password file should not be readable by untrusted users\\n\"\n\"                       (BTW: neither should the VNC -rfbauth file: it is NOT\\n\"\n\"                       encrypted, only obscured with a fixed key).\\n\"\n\"\\n\"\n\"                       If the filename is prefixed with \\\"read:\\\" it will\\n\"\n\"                       periodically be checked for changes and reread.  It is\\n\"\n\"                       guaranteed to be reread just when a new client connects\\n\"\n\"                       so that the latest passwords will be used.\\n\"\n\"\\n\"\n\"                       If \\\"filename\\\" is prefixed with \\\"cmd:\\\" then the\\n\"\n\"                       string after the \\\":\\\" is run as an external command:\\n\"\n\"                       the output of the command will be interpreted as if it\\n\"\n\"                       were read from a password file (see below).  If the\\n\"\n\"                       command does not exit with 0, then x11vnc terminates\\n\"\n\"                       immediately.  To specify more than 1000 passwords this\\n\"\n\"                       way set X11VNC_MAX_PASSWDS before starting x11vnc.\\n\"\n\"                       The environment variables are set as in -accept.\\n\"\n\"\\n\"\n\"                       Note that due to the VNC protocol only the first 8\\n\"\n\"                       characters of a password are used (DES key).\\n\"\n\"\\n\"\n\"                       If \\\"filename\\\" is prefixed with \\\"custom:\\\" then a\\n\"\n\"                       custom password checker is supplied as an external\\n\"\n\"                       command following the \\\":\\\". The command will be run\\n\"\n\"                       when a client authenticates.  If the command exits with\\n\"\n\"                       0 the client is accepted, otherwise it is rejected.\\n\"\n\"                       The environment variables are set as in -accept.\\n\"\n\"\\n\"\n\"                       The standard input to the custom command will be a\\n\"\n\"                       decimal digit \\\"len\\\" followed by a newline. \\\"len\\\"\\n\"\n\"                       specifies the challenge size and is usually 16 (the\\n\"\n\"                       VNC spec).  Then follows len bytes which is the random\\n\"\n\"                       challenge string that was sent to the client. This is\\n\"\n\"                       then followed by len more bytes holding the client's\\n\"\n\"                       response (i.e. the challenge string encrypted via DES\\n\"\n\"                       with the user password in the standard situation).\\n\"\n\"\\n\"\n\"                       The \\\"custom:\\\" scheme can be useful to implement\\n\"\n\"                       dynamic passwords or to implement methods where longer\\n\"\n\"                       passwords and/or different encryption algorithms\\n\"\n\"                       are used.  The latter will require customizing the VNC\\n\"\n\"                       client as well.  One could create an MD5SUM based scheme\\n\"\n\"                       for example.\\n\"\n\"\\n\"\n\"                       File format for -passwdfile:\\n\"\n\"\\n\"\n\"                       If multiple non-blank lines exist in the file they are\\n\"\n\"                       all taken as valid passwords.  Blank lines are ignored.\\n\"\n\"                       Password lines may be \\\"commented out\\\" (ignored) if\\n\"\n\"                       they begin with the character \\\"#\\\" or the line contains\\n\"\n\"                       the string \\\"__SKIP__\\\".  Lines may be annotated by use\\n\"\n\"                       of the \\\"__COMM__\\\" string: from it to the end of the\\n\"\n\"                       line is ignored.  An empty password may be specified\\n\"\n\"                       via the \\\"__EMPTY__\\\" string on a line by itself (note\\n\"\n\"                       your viewer might not accept empty passwords).\\n\"\n\"\\n\"\n\"                       If the string \\\"__BEGIN_VIEWONLY__\\\" appears on a\\n\"\n\"                       line by itself, the remaining passwords are used for\\n\"\n\"                       viewonly access.  For compatibility, as a special case\\n\"\n\"                       if the file contains only two password lines the 2nd\\n\"\n\"                       one is automatically taken as the viewonly password.\\n\"\n\"                       Otherwise the \\\"__BEGIN_VIEWONLY__\\\" token must be\\n\"\n\"                       used to have viewonly passwords.  (tip: make the 3rd\\n\"\n\"                       and last line be \\\"__BEGIN_VIEWONLY__\\\" to have 2\\n\"\n\"                       full-access passwords)\\n\"\n\"\\n\"\n\"-showrfbauth filename  Print to the screen the obscured VNC password kept in\\n\"\n\"                       the rfbauth file \\\"filename\\\" and then exit.\\n\"\n\"\\n\"\n\"-unixpw [list]         Use Unix username and password authentication.  x11vnc\\n\"\n\"                       will use the su(1) program to verify the user's\\n\"\n\"                       password.  [list] is an optional comma separated list\\n\"\n\"                       of allowed Unix usernames.  If the [list] string begins\\n\"\n\"                       with the character \\\"!\\\" then the entire list is taken\\n\"\n\"                       as an exclude list.  See below for per-user options\\n\"\n\"                       that can be applied.\\n\"\n\"\\n\"\n\"                       A familiar \\\"login:\\\" and \\\"Password:\\\" dialog is\\n\"\n\"                       presented to the user on a black screen inside the\\n\"\n\"                       vncviewer.  The connection is dropped if the user fails\\n\"\n\"                       to supply the correct password in 3 tries or does not\\n\"\n\"                       send one before a 45 second timeout.  Existing clients\\n\"\n\"                       are view-only during this period.\\n\"\n\"\\n\"\n\"                       If the first character received is \\\"Escape\\\" then the\\n\"\n\"                       unix username will not be displayed after \\\"login:\\\"\\n\"\n\"                       as it is typed.  This could be of use for VNC viewers\\n\"\n\"                       that automatically type the username and password.\\n\"\n\"\\n\"\n\"                       Since the detailed behavior of su(1) can vary from\\n\"\n\"                       OS to OS and for local configurations, test the mode\\n\"\n\"                       before deployment to make sure it is working properly.\\n\"\n\"                       x11vnc will attempt to be conservative and reject a\\n\"\n\"                       login if anything abnormal occurs.\\n\"\n\"\\n\"\n\"                       One case to note: FreeBSD and the other BSD's by\\n\"\n\"                       default it is impossible for the user running x11vnc to\\n\"\n\"                       validate his *own* password via su(1) (commenting out\\n\"\n\"                       the pam_self.so entry in /etc/pam.d/su eliminates this\\n\"\n\"                       behavior).  So the x11vnc login will always *FAIL* for\\n\"\n\"                       this case (even when the correct password is supplied).\\n\"\n\"\\n\"\n\"                       A possible workaround for this on *BSD would be to\\n\"\n\"                       start x11vnc as root with the \\\"-users +nobody\\\" option\\n\"\n\"                       to immediately switch to user nobody where the su'ing\\n\"\n\"                       will proceed normally.\\n\"\n\"\\n\"\n\"                       Another source of potential problems are PAM modules\\n\"\n\"                       that prompt for extra info, e.g. password aging modules.\\n\"\n\"                       These logins will fail as well even when the correct\\n\"\n\"                       password is supplied.\\n\"\n\"\\n\"\n\"                       **IMPORTANT**: to prevent the Unix password being sent\\n\"\n\"                       in *clear text* over the network, one of two schemes\\n\"\n\"                       will be enforced: 1) the -ssl builtin SSL mode, or 2)\\n\"\n\"                       require both -localhost and -stunnel be enabled.\\n\"\n\"\\n\"\n\"                       Method 1) ensures the traffic is encrypted between\\n\"\n\"                       viewer and server.  A PEM file will be required, see the\\n\"\n\"                       discussion under -ssl below (under some circumstances\\n\"\n\"                       a temporary one can be automatically generated).\\n\"\n\"\\n\"\n\"                       Method 2) requires the viewer connection to appear\\n\"\n\"                       to come from the same machine x11vnc is running on\\n\"\n\"                       (e.g. from a ssh -L port redirection).  And that the\\n\"\n\"                       -stunnel SSL mode be used for encryption over the\\n\"\n\"                       network. (see the description of -stunnel below).\\n\"\n\"\\n\"\n\"                       Note: as a convenience, if you ssh(1) in and start\\n\"\n\"                       x11vnc it will check if the environment variable\\n\"\n\"                       SSH_CONNECTION is set and appears reasonable.  If it\\n\"\n\"                       does, then the -ssl or -stunnel requirement will be\\n\"\n\"                       dropped since it is assumed you are using ssh for the\\n\"\n\"                       encrypted tunnelling.  -localhost is still enforced.\\n\"\n\"                       Use -ssl or -stunnel to force SSL usage even if\\n\"\n\"                       SSH_CONNECTION is set.\\n\"\n\"\\n\"\n\"                       To override the above restrictions you can set\\n\"\n\"                       environment variables before starting x11vnc:\\n\"\n\"\\n\"\n\"                       Set UNIXPW_DISABLE_SSL=1 to disable requiring either\\n\"\n\"                       -ssl or -stunnel (as under SSH_CONNECTION.)  Evidently\\n\"\n\"                       you will be using a different method to encrypt the\\n\"\n\"                       data between the vncviewer and x11vnc: perhaps ssh(1)\\n\"\n\"                       or an IPSEC VPN. -localhost is still enforced (however,\\n\"\n\"                       see the next paragraph.)\\n\"\n\"\\n\"\n\"                       Set UNIXPW_DISABLE_LOCALHOST=1 to disable the -localhost\\n\"\n\"                       requirement in -unixpw modes.  One should never do this\\n\"\n\"                       (i.e. allow the Unix passwords to be sniffed on the\\n\"\n\"                       network.)  This also disables the localhost requirement\\n\"\n\"                       for reverse connections (see below.)\\n\"\n\"\\n\"\n\"                       Note that use of -localhost with ssh(1) (and no -unixpw)\\n\"\n\"                       is roughly the same as requiring a Unix user login\\n\"\n\"                       (since a Unix password or the user's public key\\n\"\n\"                       authentication is used by sshd on the machine where\\n\"\n\"                       x11vnc runs and only local connections from that machine\\n\"\n\"                       are accepted).\\n\"\n\"\\n\"\n\"                       Regarding reverse connections (e.g. -R connect:host\\n\"\n\"                       and -connect host), when the -localhost constraint is\\n\"\n\"                       in effect then reverse connections can only be used\\n\"\n\"                       to connect to the same machine x11vnc is running on\\n\"\n\"                       (default port 5500).  Please use a ssh or stunnel port\\n\"\n\"                       redirection to the viewer machine to tunnel the reverse\\n\"\n\"                       connection over an encrypted channel.\\n\"\n\"\\n\"\n\"                       In -inetd mode the Method 1) will be enforced (not\\n\"\n\"                       Method 2).  With -ssl in effect reverse connections\\n\"\n\"                       are disabled.  If you override this via env. var, be\\n\"\n\"                       sure to also use encryption from the viewer to inetd.\\n\"\n\"                       Tip: you can also have your own stunnel spawn x11vnc\\n\"\n\"                       in -inetd mode (thereby bypassing inetd).  See the FAQ\\n\"\n\"                       for details.\\n\"\n\"\\n\"\n\"                       The user names in the comma separated [list] may have\\n\"\n\"                       per-user options after a \\\":\\\", e.g. \\\"fred:opts\\\"\\n\"\n\"                       where \\\"opts\\\" is a \\\"+\\\" separated list of\\n\"\n\"                       \\\"viewonly\\\", \\\"fullaccess\\\", \\\"input=XXXX\\\", or\\n\"\n\"                       \\\"deny\\\", e.g. \\\"karl,wally:viewonly,boss:input=M\\\".\\n\"\n\"                       For \\\"input=\\\" it is the K,M,B,C described under -input.\\n\"\n\"\\n\"\n\"                       If an item in the list is \\\"*\\\" that means those\\n\"\n\"                       options apply to all users.  It ALSO implies all users\\n\"\n\"                       are allowed to log in after supplying a valid password.\\n\"\n\"                       Use \\\"deny\\\" to explicitly deny some users if you use\\n\"\n\"                       \\\"*\\\" to set a global option.  If [list] begins with the\\n\"\n\"                       \\\"!\\\" character then \\\"*\\\" is ignored for checking if\\n\"\n\"                       the user is allowed, but the option values associated\\n\"\n\"                       with it do apply as normal.\\n\"\n\"\\n\"\n\"                       There are also some utilities for checking passwords\\n\"\n\"                       if [list] starts with the \\\"%%\\\" character.  See the\\n\"\n\"                       quick_pw() function for more details.  Description:\\n\"\n\"                       \\\"%%-\\\" or \\\"%%stdin\\\" means read one line from stdin.\\n\"\n\"                       \\\"%%env\\\" means it is in $UNIXPW env var.  A leading\\n\"\n\"                       \\\"%%/\\\" or \\\"%%.\\\" means read the first line from the\\n\"\n\"                       filename that follows after the %% character. %% by\\n\"\n\"                       itself means prompt for the username and password.\\n\"\n\"                       Otherwise: %%user:pass   E.g. -unixpw %%fred:swordfish\\n\"\n\"                       For the other cases user:pass is read from the indicated\\n\"\n\"                       source.  If the password is correct 'Y user' is printed\\n\"\n\"                       and the program exit code is 0.  If the password is\\n\"\n\"                       incorrect it prints 'N user' and the exit code is 1.\\n\"\n\"                       If there is some other error the exit code is 2.\\n\"\n\"                       This feature enables x11vnc to be a general unix user\\n\"\n\"                       password checking tool; it could be used from scripts\\n\"\n\"                       or other programs.  These %% password checks also apply\\n\"\n\"                       to the -unixpw_nis and -unixpw_cmd options.\\n\"\n\"\\n\"\n\"                       For the %% password check, if the env. var. UNIXPW_CMD\\n\"\n\"                       is set to a command then it is run as the user (assuming\\n\"\n\"                       the password is correct.)  The output of the command is\\n\"\n\"                       not printed, the program or script must manage that by\\n\"\n\"                       some other means.  The exit code of x11vnc will depend\\n\"\n\"                       on the exit code of the command that is run.\\n\"\n\"\\n\"\n\"                       Use -nounixpw to disable unixpw mode if it was enabled\\n\"\n\"                       earlier in the cmd line (e.g. -svc mode)\\n\"\n\"\\n\"\n\"-unixpw_nis [list]     As -unixpw above, however do not use su(1) but rather\\n\"\n\"                       use the traditional getpwnam(3) + crypt(3) method to\\n\"\n\"                       verify passwords. All of the above -unixpw options and\\n\"\n\"                       constraints apply.\\n\"\n\"\\n\"\n\"                       This mode requires that the encrypted passwords be\\n\"\n\"                       readable.  Encrypted passwords stored in /etc/shadow\\n\"\n\"                       will be inaccessible unless x11vnc is run as root.\\n\"\n\"\\n\"\n\"                       This is called \\\"NIS\\\" mode simply because in most\\n\"\n\"                       NIS setups user encrypted passwords are accessible\\n\"\n\"                       (e.g. \\\"ypcat passwd\\\") by an ordinary user and so that\\n\"\n\"                       user can authenticate ANY user.\\n\"\n\"\\n\"\n\"                       NIS is not required for this mode to work (only that\\n\"\n\"                       getpwnam(3) return the encrypted password is required),\\n\"\n\"                       but it is unlikely it will work (as an ordinary user)\\n\"\n\"                       for most modern environments unless NIS is available.\\n\"\n\"                       On the other hand, when x11vnc is run as root it will\\n\"\n\"                       be able to to access /etc/shadow even if NIS is not\\n\"\n\"                       available (note running as root is often done when\\n\"\n\"                       running x11vnc from inetd and xdm/gdm/kdm).\\n\"\n\"\\n\"\n\"                       Looked at another way, if you do not want to use the\\n\"\n\"                       su(1) method provided by -unixpw (i.e. su_verify()), you\\n\"\n\"                       can run x11vnc as root and use -unixpw_nis.  Any users\\n\"\n\"                       with passwords in /etc/shadow can then be authenticated.\\n\"\n\"\\n\"\n\"                       In -unixpw_nis mode, under no circumstances is x11vnc's\\n\"\n\"                       user password verifying function based on su called\\n\"\n\"                       (i.e. the function su_verify() that runs /bin/su\\n\"\n\"                       in a pseudoterminal to verify passwords.)  However,\\n\"\n\"                       if -unixpw_nis is used in conjunction with the -find\\n\"\n\"                       and -create -display WAIT:... modes then, if x11vnc is\\n\"\n\"                       running as root, /bin/su may be called externally to\\n\"\n\"                       run the find or create commands.\\n\"\n\"\\n\"\n\"-unixpw_cmd cmd        As -unixpw above, however do not use su(1) but rather\\n\"\n\"                       run the externally supplied command \\\"cmd\\\".  The first\\n\"\n\"                       line of its stdin will be the username and the second\\n\"\n\"                       line the received password.  If the command exits\\n\"\n\"                       with status 0 (success) the VNC user will be accepted.\\n\"\n\"                       It will be rejected for any other return status.\\n\"\n\"\\n\"\n\"                       Dynamic passwords and non-unix passwords, e.g. LDAP,\\n\"\n\"                       can be implemented this way by providing your own custom\\n\"\n\"                       helper program.  Note that the remote viewer is given 3\\n\"\n\"                       tries to enter the correct password, and so the program\\n\"\n\"                       may be called in a row that many (or more) times.\\n\"\n\"\\n\"\n\"                       If a list of allowed users is needed to limit who can\\n\"\n\"                       log in, use -unixpw [list] in addition to this option.\\n\"\n\"\\n\"\n\"                       In FINDDISPLAY and FINDCREATEDISPLAY modes the \\\"cmd\\\"\\n\"\n\"                       will also be run with the RFB_UNIXPW_CMD_RUN env. var.\\n\"\n\"                       non-empty and set to the corresponding display\\n\"\n\"                       find/create command.  The first two lines of input are\\n\"\n\"                       the username and passwd as in the normal case described\\n\"\n\"                       above.  To support FINDDISPLAY and FINDCREATEDISPLAY,\\n\"\n\"                       \\\"cmd\\\" should run the requested command as the user\\n\"\n\"                       (and most likely refusing to run it if the password is\\n\"\n\"                       not correct.)  Here is an example script (note it has\\n\"\n\"                       a hardwired bogus password \\\"abc\\\"!)\\n\"\n\"\\n\"\n\"                         #!/bin/sh\\n\"\n\"                         # Example x11vnc -unixpw_cmd script.\\n\"\n\"                         # Read the first two lines of stdin (user and passwd)\\n\"\n\"                         read user\\n\"\n\"                         read pass\\n\"\n\"                         \\n\"\n\"                         debug=0\\n\"\n\"                         if [ $debug = 1 ]; then\\n\"\n\"                         \techo \\\"user: $user\\\" 1>&2\\n\"\n\"                         \techo \\\"pass: $pass\\\" 1>&2\\n\"\n\"                         \tenv | egrep -i 'rfb|vnc' 1>&2\\n\"\n\"                         fi\\n\"\n\"                         \\n\"\n\"                         # Check if the password is valid.\\n\"\n\"                         # (A real example would use ldap lookup, etc!)\\n\"\n\"                         if [ \\\"X$pass\\\" != \\\"Xabc\\\" ]; then\\n\"\n\"                         \texit 1\t# incorrect password\\n\"\n\"                         fi\\n\"\n\"                         \\n\"\n\"                         if [ \\\"X$RFB_UNIXPW_CMD_RUN\\\" = \\\"X\\\" ]; then\\n\"\n\"                         \texit 0\t# correct password\\n\"\n\"                         else\\n\"\n\"                         \t# Run the requested command (finddisplay)\\n\"\n\"                         \tif [ $debug = 1 ]; then\\n\"\n\"                         \t\techo \\\"run: $RFB_UNIXPW_CMD_RUN\\\" 1>&2\\n\"\n\"                         \tfi\\n\"\n\"                         \texec /bin/su - \\\"$user\\\" -c \\\"$RFB_UNIXPW_CMD_RUN\\\"\\n\"\n\"                         fi\\n\"\n\"\\n\"\n\"                       In -unixpw_cmd mode, under no circumstances is x11vnc's\\n\"\n\"                       user password verifying function based on su called\\n\"\n\"                       (i.e. the function su_verify() that runs /bin/su in a\\n\"\n\"                       pseudoterminal to verify passwords.)  It is up to the\\n\"\n\"                       supplied unixpw_cmd to do user switching if desired\\n\"\n\"                       and if it has the permissions to do so.\\n\"\n\"\\n\"\n\"-find                  Find the user's display using FINDDISPLAY. This\\n\"\n\"                       is an alias for \\\"-display WAIT:cmd=FINDDISPLAY\\\".\\n\"\n\"\\n\"\n\"                       Note: if a -display occurs later on the command line\\n\"\n\"                       it will override the -find setting.\\n\"\n\"\\n\"\n\"                       For this and the next few options see -display WAIT:...\\n\"\n\"                       below for all of the details.\\n\"\n\"\\n\"\n\"-finddpy               Run the FINDDISPLAY program, print out the found\\n\"\n\"                       display (if any) and exit.  Output is like: DISPLAY=:0.0\\n\"\n\"                       DISPLAY=:0.0,XPID=12345 or DISPLAY=:0.0,VT=7.  XPID is\\n\"\n\"                       the process ID of the found X server.  VT is the Linux\\n\"\n\"                       virtual terminal of the X server.\\n\"\n\"-listdpy               Have the FINDDISPLAY program list all of your displays\\n\"\n\"                       (i.e. all the X displays on the local machine that you\\n\"\n\"                       have access rights to).  x11vnc then exits.\\n\"\n\"\\n\"\n\"-findauth [disp]       Apply the -find/-finddpy heuristics to try to guess\\n\"\n\"                       the XAUTHORITY file for DISPLAY 'disp'.  If 'disp'\\n\"\n\"                       is not supplied, then the value in the -display on\\n\"\n\"                       the cmdline is used; failing that $DISPLAY is used;\\n\"\n\"                       and failing that \\\":0\\\" is used.  x11vnc then exits.\\n\"\n\"\\n\"\n\"                       If nothing is printed out, that means no XAUTHORITY was\\n\"\n\"                       found for 'disp'; i.e. failure.  If \\\"XAUTHORITY=\\\"\\n\"\n\"                       is printed out, that means use the default (i.e. do\\n\"\n\"                       not set XAUTHORITY).  If \\\"XAUTHORITY=/path/to/file\\\"\\n\"\n\"                       is printed out, then use that file.\\n\"\n\"\\n\"\n\"                       XDM/GDM/KDM: if you are running x11vnc as root and want\\n\"\n\"                       to find the XAUTHORITY before anyone has logged into an\\n\"\n\"                       X session yet, use: x11vnc -env FD_XDM=1 -findauth ...\\n\"\n\"                       (This will also find the XAUTHORITY if a user is already\\n\"\n\"                       logged into the X session.)  When running as root,\\n\"\n\"                       FD_XDM=1 will be tried if the initial -findauth fails.\\n\"\n\"\\n\"\n\"-create                First try to find the user's display using FINDDISPLAY,\\n\"\n\"                       if that doesn't succeed create an X session via the\\n\"\n\"                       FINDCREATEDISPLAY method.  This is an alias for\\n\"\n\"                       \\\"-display WAIT:cmd=FINDCREATEDISPLAY-Xvfb\\\".\\n\"\n\"\\n\"\n\"                       Note: if a -display occurs later on the command line\\n\"\n\"                       it will override the -create setting.\\n\"\n\"\\n\"\n\"                       SSH NOTE: for both -find and -create you can (should!)\\n\"\n\"                       add the \\\"-localhost\\\" option to force SSH tunnel access.\\n\"\n\"\\n\"\n\"-xdummy                As in -create, except Xdummy instead of Xvfb.\\n\"\n\"-xvnc                  As in -create, except Xvnc instead of Xvfb.\\n\"\n\"-xvnc_redirect         As in -create, except Xvnc.redirect instead of Xvfb.\\n\"\n\"-xdummy_xvfb           Sets WAIT:cmd=FINDCREATEDISPLAY-Xdummy,Xvfb\\n\"\n\"\\n\"\n\"-create_xsrv str       Sets WAIT:cmd=FINDCREATEDISPLAY-<str>  Can be on cmdline\\n\"\n\"                       after anything that sets WAIT:.. and other things\\n\"\n\"                       (e.g. -svc, -xdmsvc) to adjust the X server list.\\n\"\n\"                       Example: -svc ... -create_xsrv Xdummy,X\\n\"\n\"\\n\"\n\"-svc                   Terminal services mode based on SSL access.  Alias for\\n\"\n\"                       -display WAIT:cmd=FINDCREATEDISPLAY-Xvfb -unixpw -users\\n\"\n\"                       unixpw= -ssl SAVE   Also \\\"-service\\\".\\n\"\n\"\\n\"\n\"                       Note: if a -display, -unixpw, -users, or -ssl occurs\\n\"\n\"                       later on the command line it will override the -svc\\n\"\n\"                       setting.\\n\"\n\"\\n\"\n\"-svc_xdummy            As -svc except Xdummy instead of Xvfb.\\n\"\n\"-svc_xvnc              As -svc except Xvnc instead of Xvfb.\\n\"\n\"-svc_xdummy_xvfb       As -svc with Xdummy,Xvfb.\\n\"\n\"\\n\"\n\"-xdmsvc                Display manager Terminal services mode based on SSL.\\n\"\n\"                       Alias for -display WAIT:cmd=FINDCREATEDISPLAY-Xvfb.xdmcp\\n\"\n\"                       -unixpw -users unixpw= -ssl SAVE  Also \\\"-xdm_service\\\".\\n\"\n\"\\n\"\n\"                       Note: if a -display, -unixpw, -users, or -ssl occurs\\n\"\n\"                       later on the command line it will override the -xdmsvc\\n\"\n\"                       setting.\\n\"\n\"\\n\"\n\"                       To create a session a user will have to first log in\\n\"\n\"                       to the -unixpw dialog and then log in again to the\\n\"\n\"                       XDM/GDM/KDM prompt.  Subsequent re-connections will\\n\"\n\"                       only require the -unixpw password.  See the discussion\\n\"\n\"                       under -display WAIT:... for more details about XDM,\\n\"\n\"                       etc configuration.\\n\"\n\"\\n\"\n\"                       Remember to enable XDMCP in the xdm-config, gdm.conf,\\n\"\n\"                       or kdmrc configuration file.  See -display WAIT: for\\n\"\n\"                       more info.\\n\"\n\"\\n\"\n\"-sshxdmsvc             Display manager Terminal services mode based on SSH.\\n\"\n\"                       Alias for -display WAIT:cmd=FINDCREATEDISPLAY-Xvfb.xdmcp\\n\"\n\"                       -localhost.\\n\"\n\"\\n\"\n\"                       The -localhost option constrains connections to come\\n\"\n\"                       in via a SSH tunnel (which will require a login).\\n\"\n\"                       To create a session a user will also have to log into\\n\"\n\"                       the XDM GDM KDM prompt. Subsequent re-connections will\\n\"\n\"                       only only require the SSH login.  See the discussion\\n\"\n\"                       under -display WAIT:... for more details about XDM,\\n\"\n\"                       etc configuration.\\n\"\n\"\\n\"\n\"                       Remember to enable XDMCP in the xdm-config, gdm.conf,\\n\"\n\"                       or kdmrc configuration file.  See -display WAIT: for\\n\"\n\"                       more info.\\n\"\n\"\\n\"\n\"-unixpw_system_greeter Present a \\\"Press 'Escape' for System Greeter\\\" option\\n\"\n\"                       to the connecting VNC client in combined -unixpw\\n\"\n\"                       and xdmcp FINDCREATEDISPLAY modes (e.g. -xdmsvc).\\n\"\n\"\\n\"\n\"                       Normally in a -unixpw mode the VNC client must\\n\"\n\"                       supply a valid username and password to gain access.\\n\"\n\"                       However, if -unixpw_system_greeter is supplied AND\\n\"\n\"                       the FINDCREATEDISPLAY command matches 'xdmcp', then\\n\"\n\"                       the user has the option to press Escape and then get a\\n\"\n\"                       XDM/GDM/KDM login/greeter panel instead. They will then\\n\"\n\"                       supply a username and password directly to the greeter.\\n\"\n\"\\n\"\n\"                       Otherwise, in xdmcp FINDCREATEDISPLAY mode the user\\n\"\n\"                       must supply his username and password TWICE.  First to\\n\"\n\"                       the initial unixpw login dialog, and second to the\\n\"\n\"                       subsequent XDM/GDM/KDM greeter.  Note that if the user\\n\"\n\"                       re-connects and supplies his username and password in\\n\"\n\"                       the unixpw dialog the xdmcp greeter is skipped and\\n\"\n\"                       he is connected directly to his existing X session.\\n\"\n\"                       So the -unixpw_system_greeter option avoids the extra\\n\"\n\"                       password at X session creation time.\\n\"\n\"\\n\"\n\"                       Example:  x11vnc -xdmsvc -unixpw_system_greeter\\n\"\n\"                       See -unixpw and -display WAIT:... for more info.\\n\"\n\"\\n\"\n\"                       The special options after a colon at the end of the\\n\"\n\"                       username (e.g. user:solid) described under -display\\n\"\n\"                       WAIT: are also applied in this mode if they are typed\\n\"\n\"                       in before the user hits Escape.  The username is ignored\\n\"\n\"                       but the colon options are not.\\n\"\n\"\\n\"\n\"                       The default message is 2 lines in a small font, set\\n\"\n\"                       the env. var. X11VNC_SYSTEM_GREETER1=true for a 1 line\\n\"\n\"                       message in a larger font.\\n\"\n\"\\n\"\n\"                       If the user pressed Escape the FINDCREATEDISPLAY command\\n\"\n\"                       will be run with the env. var. X11VNC_XDM_ONLY=1.\\n\"\n\"\\n\"\n\"                       Remember to enable XDMCP in the xdm-config, gdm.conf,\\n\"\n\"                       or kdmrc configuration file.  See -display WAIT: for\\n\"\n\"                       more info.\\n\"\n\"\\n\"\n\"-redirect port         As in FINDCREATEDISPLAY-Xvnc.redirect mode except\\n\"\n\"                       redirect immediately (i.e. without X session finding\\n\"\n\"                       or creation) to a VNC server listening on port. You\\n\"\n\"                       can also supply host:port to redirect to a different\\n\"\n\"                       machine.\\n\"\n\"\\n\"\n\"                       If 0 <= port < 200 it is taken as a VNC display (5900 is\\n\"\n\"                       added to get the actual port), if port < 0 then -port\\n\"\n\"                       is used.\\n\"\n\"\\n\"\n\"                       Probably the only reason to use the -redirect option\\n\"\n\"                       is in conjunction with SSL support, e.g. -ssl SAVE.\\n\"\n\"                       This provides an easy way to add SSL encryption to a VNC\\n\"\n\"                       server that does not support SSL (e.g. Xvnc or vnc.so)\\n\"\n\"                       In fact, the protocol does not even need to be VNC,\\n\"\n\"                       and so \\\"-rfbport port1 -ssl SAVE -redirect host:port2\\\"\\n\"\n\"                       can act as a replacement for stunnel(1).\\n\"\n\"\\n\"\n\"                       This mode only allows one redirected connection.\\n\"\n\"                       The -forever option does not apply.  Use -inetd or\\n\"\n\"                       -loop for persistent service.\\n\"\n\"\\n\"\n\"-display WAIT:...      A special usage mode for the normal -display option.\\n\"\n\"                       Useful with -unixpw, but can be used independently\\n\"\n\"                       of it.  If the display string begins with WAIT: then\\n\"\n\"                       x11vnc waits until a VNC client connects before opening\\n\"\n\"                       the X display (or -rawfb device).\\n\"\n\"\\n\"\n\"                       This could be useful for delaying opening the display\\n\"\n\"                       for certain usage modes (say if x11vnc is started at\\n\"\n\"                       boot time and no X server is running or users logged\\n\"\n\"                       in yet).\\n\"\n\"\\n\"\n\"                       If the string is, e.g. WAIT:0.0 or WAIT:1, i.e. \\\"WAIT\\\"\\n\"\n\"                       in front of a normal X display, then that indicated\\n\"\n\"                       display is used.\\n\"\n\"\\n\"\n\"                       One can also insert a geometry between colons, e.g.\\n\"\n\"                       WAIT:1280x1024:... to set the size of the display the\\n\"\n\"                       VNC client first attaches to since some VNC viewers\\n\"\n\"                       will not automatically adjust to a new framebuffer size.\\n\"\n\"\\n\"\n\"                       A more interesting case is like this:\\n\"\n\"\\n\"\n\"                            WAIT:cmd=/usr/local/bin/find_display\\n\"\n\"\\n\"\n\"                       in which case the command after \\\"cmd=\\\" is run to\\n\"\n\"                       dynamically work out the DISPLAY and optionally the\\n\"\n\"                       XAUTHORITY data.  The first line of the command output\\n\"\n\"                       must be of the form DISPLAY=<xdisplay>.  On Linux\\n\"\n\"                       if the virtual terminal is known append \\\",VT=n\\\" to\\n\"\n\"                       this string and the chvt(1) program will also be run.\\n\"\n\"                       Any remaining output is taken as XAUTHORITY data.\\n\"\n\"                       It can be either of the form XAUTHORITY=<file> or raw\\n\"\n\"                       xauthority data for the display. For example;\\n\"\n\"\\n\"\n\"                            xauth extract - $DISPLAY\\\"\\n\"\n\"\\n\"\n\"                       NOTE: As specified in the previous paragraph, you can\\n\"\n\"                       supply your own WAIT:cmd=... program or script, BUT\\n\"\n\"                       there are two very useful *BUILT-IN* ones: FINDDISPLAY\\n\"\n\"                       (alias -find above) and FINDCREATEDISPLAY (alias -create\\n\"\n\"                       above.)  Most people use these instead of creating\\n\"\n\"                       their own script.  Read the following (especially the\\n\"\n\"                       BUILT-IN modes sections) to see how to configure these\\n\"\n\"                       two useful builtin -display WAIT: modes.\\n\"\n\"\\n\"\n\"                       In the case of -unixpw (and -unixpw_nis only if x11vnc\\n\"\n\"                       is running as root), then the cmd= command is run\\n\"\n\"                       as the user who just authenticated via the login and\\n\"\n\"                       password prompt.\\n\"\n\"\\n\"\n\"                       In the case of -unixpw_cmd, the commands will also be\\n\"\n\"                       run as the logged-in user, as long as the user-supplied\\n\"\n\"                       helper program supports RFB_UNIXPW_CMD_RUN (see the\\n\"\n\"                       -unixpw_cmd option.)\\n\"\n\"\\n\"\n\"                       Also in the case of -unixpw, the user logging in can\\n\"\n\"                       place a colon at the end of her username and supply\\n\"\n\"                       a few options: scale=, scale_cursor= (or sc=), solid\\n\"\n\"                       (or so), id=, clear_mods (or cm), clear_keys (or\\n\"\n\"                       ck), clear_all (or ca), repeat, speeds= (or sp=),\\n\"\n\"                       readtimeout= (or rd=), viewonly (or vo), nodisplay=\\n\"\n\"                       (or nd=), rotate= (or ro=), or noncache (or nc),\\n\"\n\"                       all separated by commas if there is more than one.\\n\"\n\"                       After the user logs in successfully, these options will\\n\"\n\"                       be applied to the VNC screen.  For example,\\n\"\n\"\\n\"\n\"                          login: fred:scale=3/4,sc=1,repeat\\n\"\n\"                          Password: ...\\n\"\n\"\\n\"\n\"                          login: runge:sp=modem,rd=120,solid\\n\"\n\"\\n\"\n\"                       for convenience m/n implies scale= e.g. fred:3/4  If you\\n\"\n\"                       type and enter your password incorrectly, to retrieve\\n\"\n\"                       your long \\\"login:\\\" line press the Up arrow once\\n\"\n\"                       (before typing anything else).\\n\"\n\"\\n\"\n\"                       Most of these colon options only apply to the builtin\\n\"\n\"                       FINDDISPLAY and FINDCREATEDISPLAY modes, but note\\n\"\n\"                       that they are passed to the extrenal command in the\\n\"\n\"                       environment as well and so could be used.\\n\"\n\"\\n\"\n\"                       In the login panel, press F1 to get a list of the\\n\"\n\"                       available options that you can add after the username.\\n\"\n\"\\n\"\n\"                       Another option is \\\"geom=WxH\\\" or \\\"geom=WxHxD\\\" (or\\n\"\n\"                       ge=). This only has an effect in FINDCREATEDISPLAY\\n\"\n\"                       mode when a virtual X server such as Xvfb is going\\n\"\n\"                       to be created.  It sets the width and height of\\n\"\n\"                       the new display, and optionally the color depth as\\n\"\n\"                       well.\\n\"\n\"\\n\"\n\"                       You can also supply \\\"gnome\\\", \\\"kde\\\", \\\"twm\\\",\\n\"\n\"                       \\\"fvwm\\\", \\\"mwm\\\", \\\"dtwm\\\", \\\"wmaker\\\", \\\"xfce\\\",\\n\"\n\"                       \\\"lxde\\\", \\\"enlightenment\\\", \\\"Xsession\\\", or\\n\"\n\"                       \\\"failsafe\\\" (same as \\\"xterm\\\") to have the created\\n\"\n\"                       display use that mode for the user session.\\n\"\n\"\\n\"\n\"                       Specify \\\"tag=...\\\" to set the unique FD_TAG desktop\\n\"\n\"                       session tag described below.  Note: this option will\\n\"\n\"                       be ignored if the FD_TAG env. var. is already set or\\n\"\n\"                       if the viewer-side supplied value is not completely\\n\"\n\"                       composed of alphanumeric or '_' or '-' characters.\\n\"\n\"\\n\"\n\"                       User preferences file: Instead of having the user type\\n\"\n\"                       in geom=WxH,... etc. every time he logs in to find\\n\"\n\"                       or create his X session, if you set FD_USERPREFS to\\n\"\n\"                       a string that does not contain the \\\"/\\\" character,\\n\"\n\"                       then the user's home directory is prepended to that\\n\"\n\"                       string and if the file exists its first line is read\\n\"\n\"                       and appended to any options he supplied at the login:\\n\"\n\"                       prompt.  For example -env FD_USERPREFS=.x11vnc_create\\n\"\n\"                       and the user put \\\"geom=1600x1200\\\" in his\\n\"\n\"                       ~/.x11vnc_create file.\\n\"\n\"\\n\"\n\"                       To disable the option setting set the environment\\n\"\n\"                       variable X11VNC_NO_UNIXPW_OPTS=1 before starting x11vnc.\\n\"\n\"                       To set any other options, the user can use the gui\\n\"\n\"                       (x11vnc -gui connect) or the remote control method\\n\"\n\"                       (x11vnc -R opt:val) during his VNC session.\\n\"\n\"\\n\"\n\"                       So we see the combination of -display WAIT:cmd=... and\\n\"\n\"                       -unixpw allows automatic pairing of an unix\\n\"\n\"                       authenticated VNC user with his desktop.  This could\\n\"\n\"                       be very useful on SunRays and also any system where\\n\"\n\"                       multiple users share a given machine.  The user does\\n\"\n\"                       not need to remember special ports or passwords set up\\n\"\n\"                       for his desktop and VNC.\\n\"\n\"\\n\"\n\"                       A nice way to use WAIT:cmd=... is out of inetd(8)\\n\"\n\"                       (it automatically forks a new x11vnc for each user).\\n\"\n\"                       You can have the x11vnc inetd spawned process run as,\\n\"\n\"                       say, root or nobody.  When run as root (for either inetd\\n\"\n\"                       or display manager), you can also supply the option\\n\"\n\"                       \\\"-users unixpw=\\\" to have the x11vnc process switch to\\n\"\n\"                       the user as well.  Note: there will be a 2nd SSL helper\\n\"\n\"                       process that will not switch, but it is only encoding\\n\"\n\"                       and decoding the encrypted stream at that point.\\n\"\n\"\\n\"\n\"                       BUILT-IN modes:\\n\"\n\"\\n\"\n\"                       -- Automatic Finding of User X Sessions --\\n\"\n\"\\n\"\n\"                       As a special case, WAIT:cmd=FINDDISPLAY will run a\\n\"\n\"                       script that works on most Unixes to determine a user's\\n\"\n\"                       DISPLAY variable and xauthority data (see who(1)).\\n\"\n\"\\n\"\n\"                       NOTE: The option \\\"-find\\\" is an alias for this mode.\\n\"\n\"\\n\"\n\"                       To have this default script printed to stdout (e.g. for\\n\"\n\"                       customization) run with WAIT:cmd=FINDDISPLAY-print To\\n\"\n\"                       have the script run to print what display it would find\\n\"\n\"                       use \\\"-finddpy\\\" or WAIT:cmd=FINDDISPLAY-run\\n\"\n\"\\n\"\n\"                       The standard script runs xdpyinfo(1) run on potential\\n\"\n\"                       displays.  If your X server(s) have a login greeter\\n\"\n\"                       that exclusively grabs the Xserver, then xdpyinfo\\n\"\n\"                       blocks forever and this mode will not work.  See\\n\"\n\"                       www.karlrunge.com/x11vnc/faq.html#faq-display-manager\\n\"\n\"                       for how to disable this for dtgreet on Solaris and\\n\"\n\"                       possibly for other greeters.\\n\"\n\"\\n\"\n\"                       In -find/cmd=FINDDISPLAY mode, if you set FD_XDM=1,\\n\"\n\"                       e.g. 'x11vnc -env FD_XDM=1 -find ...' and x11vnc is\\n\"\n\"                       running as root (e.g. inetd) then it will try to find\\n\"\n\"                       the XAUTHORITY file of a running XDM/GDM/KDM login\\n\"\n\"                       greeter (i.e. no user has logged into an X session yet.)\\n\"\n\"\\n\"\n\"                       As another special case, WAIT:cmd=HTTPONCE will allow\\n\"\n\"                       x11vnc to service one http request and then exit.\\n\"\n\"                       This is usually done in -inetd mode to run on, say,\\n\"\n\"                       port 5800 and allow the Java vncviewer to be downloaded\\n\"\n\"                       by client web browsers.  For example:\\n\"\n\"\\n\"\n\"                        5815 stream tcp nowait root /usr/sbin/tcpd /.../x11vnc \\\\\\n\"\n\"                          -inetd -q -http_ssl -prog /.../x11vnc \\\\\\n\"\n\"                          -display WAIT:cmd=HTTPONCE\\n\"\n\"\\n\"\n\"                       Where /.../x11vnc is the full path to x11vnc.\\n\"\n\"                       It is used in the Apache SSL-portal example (see FAQ).\\n\"\n\"\\n\"\n\"                       In this mode you can set X11VNC_SKIP_DISPLAY to a\\n\"\n\"                       comma separated list of displays (e.g. \\\":0,:1\\\") to\\n\"\n\"                       ignore in the finding process.  The \\\":\\\" is optional.\\n\"\n\"                       Ranges n-m e.g. 0-20 can also be supplied. This string\\n\"\n\"                       can also be set by the connecting user via \\\"nd=\\\"\\n\"\n\"                       using \\\"+\\\" instead of \\\",\\\"  If \\\"nd=all\\\" or you set\\n\"\n\"                       X11VNC_SKIP_DISPLAY=all then all display finding fails\\n\"\n\"                       as if you set X11VNC_FINDDISPLAY_ALWAYS_FAILS=1 (below.)\\n\"\n\"\\n\"\n\"                       On some systems lsof(1) can be very slow.  Set the\\n\"\n\"                       env. var. FIND_DISPLAY_NO_LSOF=1 to skip using lsof to\\n\"\n\"                       try to find the Linux VT the X server is running on.\\n\"\n\"                       set FIND_DISPLAY_NO_VT_FIND=1 to avoid looking at all.\\n\"\n\"\\n\"\n\"                       -- Automatic Creation of User X Sessions --\\n\"\n\"\\n\"\n\"                       An interesting option is WAIT:cmd=FINDCREATEDISPLAY\\n\"\n\"                       that is like FINDDISPLAY in that is uses the same method\\n\"\n\"                       to find an existing display.  However, if it does not\\n\"\n\"                       find one it will try to *start* up an X server session\\n\"\n\"                       for the user.  This is the only time x11vnc tries to\\n\"\n\"                       actually start up an X server.\\n\"\n\"\\n\"\n\"                       NOTE: The option \\\"-create\\\" is an alias for this mode.\\n\"\n\"\\n\"\n\"                       It will start looking for an open display number at :20\\n\"\n\"                       Override via X11VNC_CREATE_STARTING_DISPLAY_NUMBER=n\\n\"\n\"                       By default 80 X displays are allowed (i.e. going to :99)\\n\"\n\"                       Override via X11VNC_CREATE_MAX_DISPLAYS=n\\n\"\n\"\\n\"\n\"                       For its heuristics, the create display script sets\\n\"\n\"                       LC_ALL=C so that command output is uniform.  By default\\n\"\n\"                       it will try to restore LC_ALL right before starting the\\n\"\n\"                       user session.  However, if you don't mind it keeping\\n\"\n\"                       LC_ALL=C set the env. var.: X11VNC_CREATE_LC_ALL_C_OK=1\\n\"\n\"\\n\"\n\"                       By default FINDCREATEDISPLAY will try Xvfb and then\\n\"\n\"                       Xdummy:\\n\"\n\"\\n\"\n\"                       The Xdummy wrapper is part of the x11vnc source code\\n\"\n\"                       (x11vnc/misc/Xdummy)  It should be available in PATH\\n\"\n\"                       and have run \\\"Xdummy -install\\\" once to create the\\n\"\n\"                       shared library.  Xdummy only works on Linux.  As of\\n\"\n\"                       12/2009 it no longer needs to be run as root, and the\\n\"\n\"                       default is to not run as root.  In some circumstances\\n\"\n\"                       permissions may require running it as root, in these\\n\"\n\"                       cases specify FD_XDUMMY_RUN_AS_ROOT=1, this is the same\\n\"\n\"                       as supplying -root to the Xdummy cmdline.\\n\"\n\"\\n\"\n\"                       Xvfb is available on most platforms and does not\\n\"\n\"                       require root.\\n\"\n\"\\n\"\n\"                       An advantage of Xdummy over Xvfb is that Xdummy supports\\n\"\n\"                       RANDR dynamic screen resizing.\\n\"\n\"\\n\"\n\"                       When x11vnc exits (i.e. user disconnects) the X\\n\"\n\"                       server session stays running in the background.\\n\"\n\"                       The FINDDISPLAY will find it directly next time.\\n\"\n\"                       The user must exit the X session in the usual way for\\n\"\n\"                       it to terminate (or kill the X server process if all\\n\"\n\"                       else fails).\\n\"\n\"\\n\"\n\"                       To troubleshoot the FINDCREATEDISPLAY mechanism,\\n\"\n\"                       set the following env. var. to an output log file,\\n\"\n\"                       e.g -env CREATE_DISPLAY_OUTPUT=/tmp/mydebug.txt\\n\"\n\"\\n\"\n\"                       So this is a somewhat odd mode for x11vnc in that it\\n\"\n\"                       will start up and poll virtual X servers!  This can\\n\"\n\"                       be used from, say, inetd(8) to provide a means of\\n\"\n\"                       definitely getting a desktop (either real or virtual)\\n\"\n\"                       on the machine.  E.g. a desktop service:\\n\"\n\"\\n\"\n\"                         5900 stream tcp nowait root /usr/sbin/tcpd /.../x11vnc\\n\"\n\"                          -inetd -q -http -ssl SAVE -unixpw -users unixpw=\\\\\\n\"\n\"                          -passwd secret -prog /.../x11vnc \\\\\\n\"\n\"                          -display WAIT:cmd=FINDCREATEDISPLAY\\n\"\n\"\\n\"\n\"                       Where /.../x11vnc is the full path to x11vnc.\\n\"\n\"\\n\"\n\"                       See the -svc/-service option alias above.\\n\"\n\"\\n\"\n\"                       If for some reason you do not want x11vnc to ever\\n\"\n\"                       try to find an existing display set the env. var\\n\"\n\"                       X11VNC_FINDDISPLAY_ALWAYS_FAILS=1 (also -env ...)\\n\"\n\"                       This is the same as setting X11VNC_SKIP_DISPLAY=all or\\n\"\n\"                       supplying \\\"nd=all\\\" after \\\"username:\\\"\\n\"\n\"\\n\"\n\"                       Use WAIT:cmd=FINDCREATEDISPLAY-print to print out the\\n\"\n\"                       script that is used for this.\\n\"\n\"\\n\"\n\"                       You can specify the preferred X server order via e.g.,\\n\"\n\"                       WAIT:cmd=FINDCREATEDISPLAY-Xdummy,Xvfb,X  and/or leave\\n\"\n\"                       out ones you do not want.  The the case \\\"X\\\" means try\\n\"\n\"                       to start up a real, hardware X server using xinit(1)\\n\"\n\"                       or startx(1).  If there is already an X server running\\n\"\n\"                       the X case may only work on Linux (see startx(1)).\\n\"\n\"\\n\"\n\"                       \\\"Xvnc\\\" will start up a VNC X server (real-\\n\"\n\"                       or tight-vnc, e.g. use if Xvfb is not available).\\n\"\n\"                       \\\"Xsrv\\\" will start up the server program in the\\n\"\n\"                       variable \\\"FD_XSRV\\\" if it is non-empty. You can make\\n\"\n\"                       this be a wrapper script if you like (it must handle :N,\\n\"\n\"                       -geometry, and -depth and other X server options).\\n\"\n\"\\n\"\n\"                       You can set the environment variable FD_GEOM (or\\n\"\n\"                       X11VNC_CREATE_GEOM) to WxH or WxHxD to set the width\\n\"\n\"                       and height and optionally the color depth of the\\n\"\n\"                       created display.  You can also set FD_SESS to be the\\n\"\n\"                       session (short name of the windowmanager: kde, gnome,\\n\"\n\"                       twm, failsafe, etc.). FD_OPTS contains extra options\\n\"\n\"                       to pass to the X server. You can also set FD_PROG to\\n\"\n\"                       be the full path to the session/windowmanager program.\\n\"\n\"\\n\"\n\"                       More FD tricks:  FD_CUPS=port or FD_CUPS=host:port\\n\"\n\"                       will set the cups printing environment.  Similarly for\\n\"\n\"                       FD_ESD=port or FD_ESD=host:port for esddsp sound\\n\"\n\"                       redirection.  Set FD_EXTRA to a command to be run a\\n\"\n\"                       few seconds after the X server starts up.  Set FD_TAG\\n\"\n\"                       to be a unique name for the session, it is set as an\\n\"\n\"                       X property, that makes FINDDISPLAY only find sessions\\n\"\n\"                       with that tag value.\\n\"\n\"\\n\"\n\"                       Set FD_XDMCP_IF to the network interface that the\\n\"\n\"                       display manager is running on; default is 'localhost'\\n\"\n\"                       but you may need to set it to '::1' on some IPv6 only\\n\"\n\"                       systems or misconfigured display managers.\\n\"\n\"\\n\"\n\"                       If you want the FINDCREATEDISPLAY session to contact an\\n\"\n\"                       XDMCP login manager (xdm/gdm/kdm) on the same machine,\\n\"\n\"                       then use \\\"Xvfb.xdmcp\\\" instead of \\\"Xvfb\\\", etc.\\n\"\n\"                       The user will have to supply his username and password\\n\"\n\"                       one more time (but he gets to select his desktop type\\n\"\n\"                       so that can be useful).  For this to work, you will\\n\"\n\"                       need to enable localhost XDMCP (udp port 177) for the\\n\"\n\"                       display manager.  This seems to be:\\n\"\n\"\\n\"\n\"                        for gdm in gdm.conf:   Enable=true in section [xdmcp]\\n\"\n\"                        for kdm in kdmrc:      Enable=true in section [Xdmcp]\\n\"\n\"                        for xdm in xdm-config: DisplayManager.requestPort: 177\\n\"\n\"\\n\"\n\"                       See the shorthand options above \\\"-svc\\\", \\\"-xdmsvc\\\"\\n\"\n\"                       and \\\"-sshxdmsvc\\\" that specify the above options for\\n\"\n\"                       some useful cases.\\n\"\n\"\\n\"\n\"                       If you set the env. var WAITBG=1 x11vnc will go into\\n\"\n\"                       the background once listening in wait mode.\\n\"\n\"\\n\"\n\"                       Another special mode is FINDCREATEDISPLAY-Xvnc.redirect,\\n\"\n\"                       (or FINDDISPLAY-Xvnc.redirect).  In this case it will\\n\"\n\"                       start up Xvnc as above if needed, but instead of\\n\"\n\"                       polling it in its normal way, it simply does a socket\\n\"\n\"                       redirection of the connected VNC viewer to the Xvnc.\\n\"\n\"\\n\"\n\"                       So in Xvnc.redirect x11vnc does no VNC but merely\\n\"\n\"                       transfers the data back and forth.  This should be\\n\"\n\"                       faster then x11vnc's polling method, but not as fast\\n\"\n\"                       as connecting directly to the Xvnc with the VNC Viewer.\\n\"\n\"                       The idea here is to take advantage of x11vnc's display\\n\"\n\"                       finding/creating scheme, SSL, and perhaps a few others.\\n\"\n\"                       Most of x11vnc's options do not apply in this mode.\\n\"\n\"\\n\"\n\"                       Xvnc.redirect should also work for the vnc.so X server\\n\"\n\"                       module for the h/w display however it will work only\\n\"\n\"                       for finding the display and the user must already be\\n\"\n\"                       logged into the X console.\\n\"\n\"\\n\"\n\"-vencrypt mode         The VeNCrypt extension to the VNC protocol allows\\n\"\n\"                       encrypted SSL/TLS connections.  If the -ssl mode is\\n\"\n\"                       enabled, then VeNCrypt is enabled as well BY DEFAULT\\n\"\n\"                       (they both use a SSL/TLS tunnel, only the protocol\\n\"\n\"                       handshake is a little different.)\\n\"\n\"\\n\"\n\"                       To control when and how VeNCrypt is used, specify the\\n\"\n\"                       mode string.  If mode is \\\"never\\\", then VeNCrypt is\\n\"\n\"                       not used.  If mode is \\\"support\\\" (the default) then\\n\"\n\"                       VeNCrypt is supported.  If mode is \\\"only\\\", then the\\n\"\n\"                       similar and older ANONTLS protocol is not simultaneously\\n\"\n\"                       supported.  x11vnc's normal SSL mode (vncs://) will be\\n\"\n\"                       supported under -ssl unless you set mode to \\\"force\\\".\\n\"\n\"\\n\"\n\"                       If mode is prefixed with \\\"nodh:\\\", then Diffie Hellman\\n\"\n\"                       anonymous key exchange is disabled.  If mode is prefixed\\n\"\n\"                       with \\\"nox509:\\\", then X509 key exchange is disabled.\\n\"\n\"\\n\"\n\"                       To disable all Anonymous Diffie-Hellman access\\n\"\n\"                       (susceptible to Man-In-The-Middle attack) you will need\\n\"\n\"                       to supply \\\"-vencrypt nodh:support -anontls never\\\"\\n\"\n\"                       or \\\"-vencrypt nodh:only\\\"\\n\"\n\"\\n\"\n\"                       If mode is prefixed with \\\"newdh:\\\", then new Diffie\\n\"\n\"                       Hellman parameters are generated for each connection\\n\"\n\"                       (this can be time consuming: 1-60 secs; see -dhparams\\n\"\n\"                       below for a faster way) rather than using the\\n\"\n\"                       fixed values in the program.  Using fixed, publicly\\n\"\n\"                       known values is not known to be a security problem.\\n\"\n\"                       This setting applies to ANONTLS as well.\\n\"\n\"\\n\"\n\"                       Long example: -vencrypt newdh:nox509:support\\n\"\n\"\\n\"\n\"                       Also, if mode is prefixed with \\\"plain:\\\", then\\n\"\n\"                       if -unixpw mode is active the VeNCrypt \\\"*Plain\\\"\\n\"\n\"                       username+passwd method is enabled for Unix logins.\\n\"\n\"                       Otherwise in -unixpw mode the normal login panel is\\n\"\n\"                       provided.\\n\"\n\"\\n\"\n\"                       You *MUST* supply the -ssl option for VeNCrypt to\\n\"\n\"                       be active.  The -vencrypt option only fine-tunes its\\n\"\n\"                       operation.\\n\"\n\"\\n\"\n\"-anontls mode          The ANONTLS extension to the VNC protocol allows\\n\"\n\"                       encrypted SSL/TLS connections.  If the -ssl mode is\\n\"\n\"                       enabled, then ANONTLS is enabled as well BY DEFAULT\\n\"\n\"                       (they both use a SSL/TLS tunnel, only the protocol\\n\"\n\"                       handshake is a little different.)\\n\"\n\"\\n\"\n\"                       ANONTLS is an older SSL/TLS mode introduced by vino.\\n\"\n\"\\n\"\n\"                       It is referred to as 'TLS' for its registered VNC\\n\"\n\"                       security-type name, but we use the more descriptive\\n\"\n\"                       'ANONTLS' here because it provides only Anonymous\\n\"\n\"                       Diffie-Hellman encrypted connections, and hence no\\n\"\n\"                       possibility for certificate authentication.\\n\"\n\"\\n\"\n\"                       To control when and how ANONTLS is used, specify the\\n\"\n\"                       mode string.  If mode is \\\"never\\\", then ANONTLS is not\\n\"\n\"                       used.  If mode is \\\"support\\\" (the default) then ANONTLS\\n\"\n\"                       is supported.  If mode is \\\"only\\\", then the similar\\n\"\n\"                       VeNCrypt protocol is not simultaneously supported.\\n\"\n\"                       x11vnc's normal SSL mode (vncs://) will be supported\\n\"\n\"                       under -ssl unless you set mode to \\\"force\\\".\\n\"\n\"\\n\"\n\"                       If mode is prefixed with \\\"newdh:\\\", then new Diffie\\n\"\n\"                       Hellman parameters are generated for each connection\\n\"\n\"                       (this can be time consuming: 1-60 secs; see -dhparams\\n\"\n\"                       below for a faster way) rather than using the\\n\"\n\"                       fixed values in the program.  Using fixed, publicly\\n\"\n\"                       known values is not known to be a security problem.\\n\"\n\"                       This setting applies to VeNCrypt as well.  See the\\n\"\n\"                       description of \\\"plain:\\\" under -vencrypt.\\n\"\n\"\\n\"\n\"                       Long example: -anontls newdh:plain:support\\n\"\n\"\\n\"\n\"                       You *MUST* supply the -ssl option for ANONTLS to\\n\"\n\"                       be active.  The -anontls option only fine-tunes its\\n\"\n\"                       operation.\\n\"\n\"\\n\"\n\"-sslonly               Same as: \\\"-vencrypt never -anontls never\\\"  i.e. it\\n\"\n\"                       disables the VeNCrypt and ANONTLS encryption methods\\n\"\n\"                       and only allows standard SSL tunneling.  You must also\\n\"\n\"                       supply the -ssl ... option (see below.)\\n\"\n\"\\n\"\n\"\\n\"\n\"-dhparams file         For some operations a set of Diffie Hellman parameters\\n\"\n\"                       (prime and generator) is needed.  If so, use the\\n\"\n\"                       parameters in \\\"file\\\". In particular, the VeNCrypt and\\n\"\n\"                       ANONTLS anonymous DH mode need them.  By default a\\n\"\n\"                       fixed set is used. If you do not want to do that you\\n\"\n\"                       can specify \\\"newdh:\\\" to the -vencrypt and -anontls\\n\"\n\"                       options to generate a new set each session.  If that\\n\"\n\"                       is too slow for you, use -dhparams file to a set you\\n\"\n\"                       created manually via \\\"openssl dhparam -out file 1024\\\"\\n\"\n\"\\n\"\n\"-nossl                 Disable the -ssl option (see below). Since -ssl is off\\n\"\n\"                       by default -nossl would only be used on the commandline\\n\"\n\"                       to unset any *earlier* -ssl option (or -svc...)\\n\"\n\"\\n\"\n\"-ssl [pem]             Use the openssl library (www.openssl.org) to provide a\\n\"\n\"                       built-in encrypted SSL/TLS tunnel between VNC viewers\\n\"\n\"                       and x11vnc.  This requires libssl support to be\\n\"\n\"                       compiled into x11vnc at build time.  If x11vnc is not\\n\"\n\"                       built with libssl support it will exit immediately when\\n\"\n\"                       -ssl is prescribed.  See the -stunnel option below for\\n\"\n\"                       an alternative.\\n\"\n\"\\n\"\n\"                       The VNC Viewer-side needs to support SSL/TLS as well.\\n\"\n\"                       See this URL and also the discussion below for\\n\"\n\"                       ideas on how to enable SSL support for the viewer:\\n\"\n\"                       http://www.karlrunge.com/x11vnc/faq.html#faq-ssl-tun\\n\"\n\"                       nel-viewers .  x11vnc provides an SSL enabled Java\\n\"\n\"                       viewer applet in the classes/ssl directory (-http or\\n\"\n\"                       -httpdir options.)  The SSVNC viewer package supports\\n\"\n\"                       SSL tunnels too.\\n\"\n\"\\n\"\n\"                       If the VNC Viewer supports VeNCrypt or ANONTLS (vino's\\n\"\n\"                       encryption mode) they are also supported by the -ssl\\n\"\n\"                       mode (see the -vencrypt and -anontls options for more\\n\"\n\"                       info; use -sslonly to disable both of them.)\\n\"\n\"\\n\"\n\"                       Use \\\"-ssl /path/to/mycert.pem\\\" to specify an SSL\\n\"\n\"                       certificate file in PEM format to use to identify and\\n\"\n\"                       provide a key for this server.  See openssl(1) for more\\n\"\n\"                       info about PEMs and the -sslGenCert and \\\"-ssl SAVE\\\"\\n\"\n\"                       options below for how to create them.\\n\"\n\"\\n\"\n\"                       The connecting VNC viewer SSL tunnel can (at its option)\\n\"\n\"                       authenticate this server if it has the public key part\\n\"\n\"                       of the certificate (or a common certificate authority,\\n\"\n\"                       CA, is a more sophisticated way to verify this server's\\n\"\n\"                       cert, see -sslGenCA below).  This authentication is\\n\"\n\"                       done to prevent Man-In-The-Middle attacks.  Otherwise,\\n\"\n\"                       if the VNC viewer simply accepts this server's key\\n\"\n\"                       WITHOUT verification, the traffic is protected from\\n\"\n\"                       passive sniffing on the network, but *NOT* from\\n\"\n\"                       Man-In-The-Middle attacks. There are hacker tools\\n\"\n\"                       like dsniff/webmitm and cain that implement SSL\\n\"\n\"                       Man-In-The-Middle attacks.\\n\"\n\"\\n\"\n\"                       If [pem] is empty or the string \\\"SAVE\\\" then the\\n\"\n\"                       openssl(1) command must be available to generate the\\n\"\n\"                       certificate the first time.  A self-signed certificate\\n\"\n\"                       is generated (see -sslGenCA and -sslGenCert for use\\n\"\n\"                       of a Certificate Authority.)  It will be saved to the\\n\"\n\"                       file ~/.vnc/certs/server.pem.  On subsequent calls if\\n\"\n\"                       that file already exists it will be used directly.\\n\"\n\"\\n\"\n\"                       Use \\\"SAVE_NOPROMPT\\\" to avoid being prompted to\\n\"\n\"                       protect the generated key with a passphrase.  However in\\n\"\n\"                       -inetd and -bg modes there will be no prompting for a\\n\"\n\"                       passphrase in either case.\\n\"\n\"\\n\"\n\"                       If [pem] is \\\"SAVE_PROMPT\\\" the server.pem certificate\\n\"\n\"                       will be created based on your answers to its prompts for\\n\"\n\"                       all info such as OrganizationalName, CommonName, etc.\\n\"\n\"\\n\"\n\"                       Use \\\"SAVE-<string>\\\" and \\\"SAVE_PROMPT-<string>\\\"\\n\"\n\"                       to refer to the file ~/.vnc/certs/server-<string>.pem\\n\"\n\"                       instead (it will be generated if it does not already\\n\"\n\"                       exist).  E.g. \\\"SAVE-charlie\\\" will store to the file\\n\"\n\"                       ~/.vnc/certs/server-charlie.pem\\n\"\n\"\\n\"\n\"                       Examples: x11vnc -ssl SAVE -display :0 ...\\n\"\n\"                                 x11vnc -ssl SAVE-someother -display :0 ...\\n\"\n\"\\n\"\n\"                       If [pem] is \\\"TMP\\\" and the openssl(1) utility\\n\"\n\"                       command exists in PATH, then a temporary, self-signed\\n\"\n\"                       certificate will be generated for this session.  If\\n\"\n\"                       openssl(1) cannot be used to generate a temporary\\n\"\n\"                       certificate x11vnc exits immediately.  The temporary\\n\"\n\"                       cert will be discarded when x11vnc exits.\\n\"\n\"\\n\"\n\"                       If successful in using openssl(1) to generate a\\n\"\n\"                       temporary certificate in \\\"SAVE\\\" or \\\"TMP\\\" creation\\n\"\n\"                       modes, the public part of it will be displayed to stderr\\n\"\n\"                       (e.g. one could copy it to the client-side to provide\\n\"\n\"                       authentication of the server to VNC viewers.)\\n\"\n\"\\n\"\n\"                       NOTE: In \\\"TMP\\\" mode, unless you safely copy the\\n\"\n\"                       public part of the temporary Cert to the viewer for\\n\"\n\"                       authenticate *every time* (unlikely...), then only\\n\"\n\"                       passive sniffing attacks are prevented and you are\\n\"\n\"                       still open to Man-In-The-Middle attacks.  This is\\n\"\n\"                       why the default \\\"SAVE\\\" mode is preferred (and more\\n\"\n\"                       sophisticated CA mode too).  Only with saved keys AND\\n\"\n\"                       the VNC viewer authenticating them (via the public\\n\"\n\"                       certificate), are Man-In-The-Middle attacks prevented.\\n\"\n\"\\n\"\n\"                       If [pem] is \\\"ANON\\\" then the Diffie-Hellman anonymous\\n\"\n\"                       key exchange method is used.  In this mode there\\n\"\n\"                       are *no* SSL certificates and so it is not possible\\n\"\n\"                       to authenticate either the VNC server or VNC client.\\n\"\n\"                       Thus only passive network sniffing attacks are avoided:\\n\"\n\"                       the \\\"ANON\\\" method is susceptible to Man-In-The-Middle\\n\"\n\"                       attacks.  \\\"ANON\\\" is not recommended; instead use\\n\"\n\"                       a SSL PEM you created or the default \\\"SAVE\\\" method.\\n\"\n\"\\n\"\n\"                       See -ssldir below to use a directory besides the\\n\"\n\"                       default ~/.vnc/certs\\n\"\n\"\\n\"\n\"                       If your x11vnc binary was not compiled with OpenSSL\\n\"\n\"                       library support, use of the -ssl option will induce an\\n\"\n\"                       immediate failure and exit.  For such binaries, consider\\n\"\n\"                       using the -stunnel option for SSL encrypted connections.\\n\"\n\"\\n\"\n\"                       Misc Info: In temporary cert creation mode \\\"TMP\\\", set\\n\"\n\"                       the env. var. X11VNC_SHOW_TMP_PEM=1 to have x11vnc print\\n\"\n\"                       out the entire certificate, including the PRIVATE KEY\\n\"\n\"                       part, to stderr.  There are better ways to get/save this\\n\"\n\"                       info.  See \\\"SAVE\\\" above and \\\"-sslGenCert\\\" below.\\n\"\n\"\\n\"\n\"-ssltimeout n          Set SSL read timeout to n seconds.  In some situations\\n\"\n\"                       (i.e. an iconified viewer in Windows) the viewer stops\\n\"\n\"                       talking and the connection is dropped after the default\\n\"\n\"                       timeout (25s for about the first minute, 43200s later).\\n\"\n\"                       Set to zero to poll forever.  Set to a negative value\\n\"\n\"                       to use the builtin setting.\\n\"\n\"\\n\"\n\"                       Note that this value does NOT apply to the *initial* ssl\\n\"\n\"                       init connection.  The default timeout for that is 20sec.\\n\"\n\"                       Use -env SSL_INIT_TIMEOUT=n to modify it.\\n\"\n\"\\n\"\n\"-sslnofail             Exit at the first SSL connection failure. Useful when\\n\"\n\"                       scripting SSL connections (e.g. x11vnc is started via\\n\"\n\"                       ssh) and you do not want x11vnc waiting around for more\\n\"\n\"                       connections, tying up ports, etc.\\n\"\n\"\\n\"\n\"-ssldir dir            Use \\\"dir\\\" as an alternate ssl certificate and key\\n\"\n\"                       management toplevel directory.  The default is\\n\"\n\"                       ~/.vnc/certs\\n\"\n\"\\n\"\n\"                       This directory is used to store server and other\\n\"\n\"                       certificates and keys and also other materials.  E.g. in\\n\"\n\"                       the simplest case, \\\"-ssl SAVE\\\" will store the x11vnc\\n\"\n\"                       server cert in dir/server.pem\\n\"\n\"\\n\"\n\"                       Use of alternate directories via -ssldir allows you to\\n\"\n\"                       manage multiple VNC Certificate Authority (CA) keys.\\n\"\n\"                       Another use is if ~/.vnc/cert is on an NFS share you\\n\"\n\"                       might want your certificates and keys to be on a local\\n\"\n\"                       filesystem to prevent network snooping (for example\\n\"\n\"                       -ssldir /var/lib/x11vnc-certs).\\n\"\n\"\\n\"\n\"                       -ssldir affects nearly all of the other -ssl* options,\\n\"\n\"                       e.g. -ssl SAVE, -sslGenCert, etc..\\n\"\n\"\\n\"\n\"-sslverify path        For either of the -ssl or -stunnel modes, use \\\"path\\\"\\n\"\n\"                       to provide certificates to authenticate incoming VNC\\n\"\n\"                       *Client* connections (normally only the server is\\n\"\n\"                       authenticated in SSL.)  This can be used as a method\\n\"\n\"                       to replace standard password authentication of clients.\\n\"\n\"\\n\"\n\"                       If \\\"path\\\" is a directory it contains the client (or CA)\\n\"\n\"                       certificates in separate files.  If path is a file,\\n\"\n\"                       it contains one or more certificates. See special tokens\\n\"\n\"                       below.  These correspond to the \\\"CApath = dir\\\" and\\n\"\n\"                       \\\"CAfile = file\\\" stunnel options.  See the stunnel(8)\\n\"\n\"                       manpage for details.\\n\"\n\"\\n\"\n\"                       Examples:\\n\"\n\"                              x11vnc -ssl -sslverify ~/my.crt\\n\"\n\"                              x11vnc -ssl -sslverify ~/my_pem_dir/\\n\"\n\"\\n\"\n\"                       Note that if path is a directory, it must contain\\n\"\n\"                       the certs in separate files named like <HASH>.0, where\\n\"\n\"                       the value of <HASH> is found by running the command\\n\"\n\"                       \\\"openssl x509 -hash -noout -in file.crt\\\". Evidently\\n\"\n\"                       one uses <HASH>.1 if there is a collision...\\n\"\n\"\\n\"\n\"                       The the key-management utility \\\"-sslCertInfo HASHON\\\"\\n\"\n\"                       and \\\"-sslCertInfo HASHOFF\\\" will create/delete these\\n\"\n\"                       hashes for you automatically (via symlink) in the HASH\\n\"\n\"                       subdirs it manages.  Then you can point -sslverify to\\n\"\n\"                       the HASH subdir.\\n\"\n\"\\n\"\n\"                       Special tokens: in -ssl mode, if \\\"path\\\" is not a file or\\n\"\n\"                       a directory, it is taken as a comma separated list of\\n\"\n\"                       tokens that are interpreted as follows:\\n\"\n\"\\n\"\n\"                       If a token is \\\"CA\\\" that means load the CA/cacert.pem\\n\"\n\"                       file from the ssl directory.  If a token is \\\"clients\\\"\\n\"\n\"                       then all the files clients/*.crt in the ssl directory\\n\"\n\"                       are loaded.  Otherwise the file clients/token.crt\\n\"\n\"                       is attempted to be loaded.  As a kludge, use a token\\n\"\n\"                       like ../server-foo to load a server cert if you find\\n\"\n\"                       that necessary.\\n\"\n\"\\n\"\n\"                       Use -ssldir to use a directory different from the\\n\"\n\"                       ~/.vnc/certs default.\\n\"\n\"\\n\"\n\"                       Note that if the \\\"CA\\\" cert is loaded you do not need\\n\"\n\"                       to load any of the certs that have been signed by it.\\n\"\n\"                       You will need to load any additional self-signed certs\\n\"\n\"                       however.\\n\"\n\"\\n\"\n\"                       Examples:\\n\"\n\"                              x11vnc -ssl -sslverify CA\\n\"\n\"                              x11vnc -ssl -sslverify self:fred,self:jim\\n\"\n\"                              x11vnc -ssl -sslverify CA,clients\\n\"\n\"\\n\"\n\"                       Usually \\\"-sslverify CA\\\" is the most effective.\\n\"\n\"                       See the -sslGenCA and -sslGenCert options below for\\n\"\n\"                       how to set up and manage the CA framework.\\n\"\n\"\\n\"\n\"\\n\"\n\"\\n\"\n\"                       NOTE: the following utilities, -sslGenCA, -sslGenCert,\\n\"\n\"                       -sslEncKey, -sslCertInfo, and -sslCRL are provided for\\n\"\n\"                       completeness, but for casual usage they are overkill.\\n\"\n\"\\n\"\n\"                       They provide VNC Certificate Authority (CA) key creation\\n\"\n\"                       and server / client key generation and signing.  So they\\n\"\n\"                       provide a basic Public Key management framework for\\n\"\n\"                       VNC-ing with x11vnc. (note that they require openssl(1)\\n\"\n\"                       be installed on the system)\\n\"\n\"\\n\"\n\"                       However, the simplest usage mode, \\\"-ssl TMP\\\" (where\\n\"\n\"                       x11vnc automatically generates its own, self-signed,\\n\"\n\"                       temporary key and the VNC viewers always accept it,\\n\"\n\"                       e.g. accepting via a dialog box) is probably safe enough\\n\"\n\"                       for most scenarios.  CA management is not needed.\\n\"\n\"\\n\"\n\"                       To protect against Man-In-The-Middle attacks the \\\"TMP\\\"\\n\"\n\"                       mode can be improved by using \\\"-ssl SAVE\\\" (same as\\n\"\n\"                       \\\"-ssl\\\", i.e. the default) to have x11vnc create a\\n\"\n\"                       longer term self-signed certificate, and then (safely)\\n\"\n\"                       copy the corresponding public key cert to the desired\\n\"\n\"                       client machines (care must be taken the private key part\\n\"\n\"                       is not stolen; you will be prompted for a passphrase).\\n\"\n\"\\n\"\n\"                       So keep in mind no CA key creation or management\\n\"\n\"                       (-sslGenCA and -sslGenCert) is needed for either of\\n\"\n\"                       the above two common usage modes.\\n\"\n\"\\n\"\n\"                       One might want to use -sslGenCA and -sslGenCert\\n\"\n\"                       if you had a large number of VNC client and server\\n\"\n\"                       workstations.  That way the administrator could generate\\n\"\n\"                       a single CA key with -sslGenCA and distribute its\\n\"\n\"                       certificate part to all of the workstations.\\n\"\n\"\\n\"\n\"                       Next, he could create signed VNC server keys\\n\"\n\"                       (-sslGenCert server ...) for each workstation or user\\n\"\n\"                       that then x11vnc would use to authenticate itself to\\n\"\n\"                       any VNC client that has the CA cert.\\n\"\n\"\\n\"\n\"                       Optionally, the admin could also make it so the\\n\"\n\"                       VNC clients themselves are authenticated to x11vnc\\n\"\n\"                       (-sslGenCert client ...)  For this -sslverify would be\\n\"\n\"                       pointed to the CA cert (and/or self-signed certs).\\n\"\n\"\\n\"\n\"                       x11vnc will be able to use all of these cert and\\n\"\n\"                       key files.  On the VNC client side, they will need to\\n\"\n\"                       be \\\"imported\\\" somehow.  Web browsers have \\\"Manage\\n\"\n\"                       Certificates\\\" actions as does the Java applet plugin\\n\"\n\"                       Control Panel.  stunnel can also use these files (see\\n\"\n\"                       the ss_vncviewer example script in the FAQ and SSVNC.)\\n\"\n\"\\n\"\n\"-sslCRL path           Set the Certificate Revocation Lists (CRL) to \\\"path\\\".\\n\"\n\"                       This setting applies for both -ssl and -stunnel modes.\\n\"\n\"\\n\"\n\"                       If path is a file, the file contains one or more CRLs\\n\"\n\"                       in PEM format.  If path is a directory, it contains\\n\"\n\"                       hash named files of CRLs in the usual OpenSSL manner.\\n\"\n\"                       See the OpenSSL and stunnel(8) documentation for\\n\"\n\"                       more info.\\n\"\n\"\\n\"\n\"                       This option only applies if -sslverify has been\\n\"\n\"                       supplied: it checks for revocation along the\\n\"\n\"                       certificate chain used to verify the VNC client.\\n\"\n\"                       The -sslCRL setting will be ignored when -sslverify is\\n\"\n\"                       not specified.\\n\"\n\"\\n\"\n\"                       Note that if a CRL's expiration date has passed, all\\n\"\n\"                       SSL connections will fail regardless of if they are\\n\"\n\"                       related to the subject of the CRL or not.\\n\"\n\"\\n\"\n\"                       Only rarely will one's x11vnc -ssl infrastructure be so\\n\"\n\"                       large that this option would be useful (since normally\\n\"\n\"                       maintaining the contents of the -sslverify file or\\n\"\n\"                       directory should be enough.)  However, when using\\n\"\n\"                       x11vnc with a Certificate Authority (see -sslGenCA)\\n\"\n\"                       to authenticate Clients via SSL/TLS, the -sslCRL option\\n\"\n\"                       can be useful to revoke users' certs whose private SSL\\n\"\n\"                       keys were lost or stolen (e.g. laptop.)  This way a new\\n\"\n\"                       CA cert+key does not need to be created and new signed\\n\"\n\"                       client keys generated and distributed to all users.\\n\"\n\"\\n\"\n\"                       To create a CRL file with revoked certificates the\\n\"\n\"                       commands 'openssl ca -revoke ...' and 'openssl ca\\n\"\n\"                       -gencrl ...' are useful.  (Run them in ~/.vnc/certs)\\n\"\n\"\\n\"\n\"-sslGenCA [dir]        Generate your own Certificate Authority private key,\\n\"\n\"                       certificate, and other files in directory [dir].\\n\"\n\"                       x11vnc then exits.\\n\"\n\"\\n\"\n\"                       If [dir] is not supplied, a -ssldir setting is used,\\n\"\n\"                       or otherwise ~/.vnc/certs is used.\\n\"\n\"\\n\"\n\"                       This command also creates directories where server and\\n\"\n\"                       client certs and keys will be stored.  The openssl(1)\\n\"\n\"                       program must be installed on the system and available\\n\"\n\"                       in PATH.\\n\"\n\"\\n\"\n\"                       After the CA files and directories are created the\\n\"\n\"                       x11vnc command exits; the VNC server is not run.\\n\"\n\"\\n\"\n\"                       You will be prompted for information to put into the CA\\n\"\n\"                       certificate.  The info does not have to be accurate just\\n\"\n\"                       as long as clients accept the cert for VNC connections.\\n\"\n\"                       You will also need to supply a passphrase of at least\\n\"\n\"                       4 characters for the CA private key.\\n\"\n\"\\n\"\n\"                       Once you have generated the CA you can distribute\\n\"\n\"                       its certificate part, [dir]/CA/cacert.pem, to other\\n\"\n\"                       workstations where VNC viewers will be run.  One will\\n\"\n\"                       need to \\\"import\\\" this certificate in the applications,\\n\"\n\"                       e.g. Web browser, Java applet plugin, stunnel, etc.\\n\"\n\"                       Next, you can create and sign keys using the CA with\\n\"\n\"                       the -sslGenCert option below.\\n\"\n\"\\n\"\n\"                       Examples:\\n\"\n\"                                x11vnc -sslGenCA\\n\"\n\"                                x11vnc -sslGenCA  ~/myCAdir\\n\"\n\"                                x11vnc -ssldir ~/myCAdir -sslGenCA\\n\"\n\"\\n\"\n\"                       (the last two lines are equivalent)\\n\"\n\"\\n\"\n\"-sslGenCert type name  Generate a VNC server or client certificate and private\\n\"\n\"                       key pair signed by the CA created previously with\\n\"\n\"                       -sslGenCA.  The openssl(1) program must be installed\\n\"\n\"                       on the system and available in PATH.\\n\"\n\"\\n\"\n\"                       After the Certificate is generated x11vnc exits; the\\n\"\n\"                       VNC server is not run.\\n\"\n\"\\n\"\n\"                       The type of key to be generated is the string \\\"type\\\".\\n\"\n\"                       It is either \\\"server\\\" (i.e. for use by x11vnc) or\\n\"\n\"                       \\\"client\\\" (for a VNC viewer).  Note that typically\\n\"\n\"                       only \\\"server\\\" is used: the VNC clients authenticate\\n\"\n\"                       themselves by a non-public-key method (e.g. VNC or\\n\"\n\"                       unix password).  \\\"type\\\" is required.\\n\"\n\"\\n\"\n\"                       An arbitrary default name you want to associate with\\n\"\n\"                       the key is supplied by the \\\"name\\\" string.  You can\\n\"\n\"                       change it at the various prompts when creating the key.\\n\"\n\"                       \\\"name\\\" is optional.\\n\"\n\"\\n\"\n\"                       If name is left blank for clients keys then \\\"nobody\\\"\\n\"\n\"                       is used.  If left blank for server keys, then the\\n\"\n\"                       primary server key: \\\"server.pem\\\" is created (this\\n\"\n\"                       is the saved one referenced by \\\"-ssl SAVE\\\" when the\\n\"\n\"                       server is started)\\n\"\n\"\\n\"\n\"                       If \\\"name\\\" begins with the string \\\"self:\\\" then\\n\"\n\"                       a self-signed certificate is created instead of one\\n\"\n\"                       signed by your CA key.\\n\"\n\"\\n\"\n\"                       If \\\"name\\\" begins with the string \\\"req:\\\" then only a\\n\"\n\"                       key (.key) and a certificate signing *request* (.req)\\n\"\n\"                       are generated.  You can then send the .req file to\\n\"\n\"                       an external CA (even a professional one, e.g. Thawte)\\n\"\n\"                       and then combine the .key and the received cert into\\n\"\n\"                       the .pem file with the same basename.\\n\"\n\"\\n\"\n\"                       The distinction between \\\"server\\\" and \\\"client\\\" is\\n\"\n\"                       simply the choice of output filenames and sub-directory.\\n\"\n\"                       This makes it so the -ssl SAVE-name option can easily\\n\"\n\"                       pick up the x11vnc PEM file this option generates.\\n\"\n\"                       And similarly makes it easy for the -sslverify option\\n\"\n\"                       to pick up your client certs.\\n\"\n\"\\n\"\n\"                       There is nothing special about the filename or directory\\n\"\n\"                       location of either the \\\"server\\\" and \\\"client\\\" certs.\\n\"\n\"                       You can rename the files or move them to wherever\\n\"\n\"                       you like.\\n\"\n\"\\n\"\n\"                       Precede this option with -ssldir [dir] to use a\\n\"\n\"                       directory other than the default ~/.vnc/certs You will\\n\"\n\"                       need to run -sslGenCA on that directory first before\\n\"\n\"                       doing any -sslGenCert key creation.\\n\"\n\"\\n\"\n\"                       Note you cannot recreate a cert with exactly the same\\n\"\n\"                       distiguished name (DN) as an existing one.  To do so,\\n\"\n\"                       you will need to edit the [dir]/CA/index.txt file to\\n\"\n\"                       delete the line.\\n\"\n\"\\n\"\n\"                       Similar to -sslGenCA, you will be prompted to fill\\n\"\n\"                       in some information that will be recorded in the\\n\"\n\"                       certificate when it is created.\\n\"\n\"\\n\"\n\"                       Tip: if you know the fully-qualified hostname other\\n\"\n\"                       people will be connecting to, you can use that as the\\n\"\n\"                       CommonName \\\"CN\\\" to avoid some applications (e.g. web\\n\"\n\"                       browsers and java plugin) complaining that it does not\\n\"\n\"                       match the hostname.\\n\"\n\"\\n\"\n\"                       You will also need to supply the CA private key\\n\"\n\"                       passphrase to unlock the private key created from\\n\"\n\"                       -sslGenCA.  This private key is used to sign the server\\n\"\n\"                       or client certificate.\\n\"\n\"\\n\"\n\"                       The \\\"server\\\" certs can be used by x11vnc directly by\\n\"\n\"                       pointing to them via the -ssl [pem] option.  The default\\n\"\n\"                       file will be ~/.vnc/certs/server.pem.  This one would\\n\"\n\"                       be used by simply typing -ssl SAVE.  The pem file\\n\"\n\"                       contains both the certificate and the private key.\\n\"\n\"                       server.crt file contains the cert only.\\n\"\n\"\\n\"\n\"                       The \\\"client\\\" cert + private key file will need\\n\"\n\"                       to be copied and imported into the VNC viewer\\n\"\n\"                       side applications (Web browser, Java plugin,\\n\"\n\"                       stunnel, etc.)  Once that is done you can delete the\\n\"\n\"                       \\\"client\\\" private key file on this machine since\\n\"\n\"                       it is only needed on the VNC viewer side.  The,\\n\"\n\"                       e.g. ~/.vnc/certs/clients/<name>.pem contains both\\n\"\n\"                       the cert and private key.  The <name>.crt contains the\\n\"\n\"                       certificate only.\\n\"\n\"\\n\"\n\"                       NOTE: It is very important to know one should\\n\"\n\"                       generate new keys with a passphrase.  Otherwise if an\\n\"\n\"                       untrusted user steals the key file he could use it to\\n\"\n\"                       masquerade as the x11vnc server (or VNC viewer client).\\n\"\n\"                       You will be prompted whether to encrypt the key with\\n\"\n\"                       a passphrase or not.  It is recommended that you do.\\n\"\n\"                       One inconvenience to a passphrase is that it must\\n\"\n\"                       be typed in EVERY time x11vnc or the client app is\\n\"\n\"                       started up.\\n\"\n\"\\n\"\n\"                       Examples:\\n\"\n\"\\n\"\n\"                               x11vnc -sslGenCert server\\n\"\n\"                               x11vnc -ssl SAVE -display :0 ...\\n\"\n\"\\n\"\n\"                       and then on viewer using ss_vncviewer stunnel wrapper\\n\"\n\"                       (see the FAQ):\\n\"\n\n\"                               ss_vncviewer -verify ./cacert.crt hostname:0\\n\"\n\"\\n\"\n\"                       (this assumes the cacert.crt cert from -sslGenCA\\n\"\n\"                       was safely copied to the VNC viewer machine where\\n\"\n\"                       ss_vncviewer is run)\\n\"\n\"\\n\"\n\"                       Example using a name:\\n\"\n\"\\n\"\n\"                               x11vnc -sslGenCert server charlie\\n\"\n\"                               x11vnc -ssl SAVE-charlie -display :0 ...\\n\"\n\"\\n\"\n\"                       Example for a client certificate (rarely used):\\n\"\n\"\\n\"\n\"                               x11vnc -sslGenCert client roger\\n\"\n\"                               scp ~/.vnc/certs/clients/roger.pem somehost:.\\n\"\n\"                               rm  ~/.vnc/certs/clients/roger.pem\\n\"\n\"\\n\"\n\"                       x11vnc is then started with the option -sslverify\\n\"\n\"                       ~/.vnc/certs/clients/roger.crt (or simply -sslverify\\n\"\n\"                       roger), and on the viewer user on somehost could do\\n\"\n\"                       for example:\\n\"\n\"\\n\"\n\"                               ss_vncviewer -mycert ./roger.pem hostname:0\\n\"\n\"\\n\"\n\"                       If you set the env. var REQ_ARGS='...' it will be\\n\"\n\"                       passed to openssl req(1).  A common use would be\\n\"\n\"                       REQ_ARGS='-days 1095' to bump up the expiration date\\n\"\n\"                       (3 years in this case).\\n\"\n\"\\n\"\n\"-sslEncKey pem         Utility to encrypt an existing PEM file with a\\n\"\n\"                       passphrase you supply when prompted.  For that key to be\\n\"\n\"                       used (e.g. by x11vnc) the passphrase must be supplied\\n\"\n\"                       each time.\\n\"\n\"\\n\"\n\"                       The \\\"SAVE\\\" notation described under -ssl applies as\\n\"\n\"                       well. (precede this option with -ssldir [dir] to refer\\n\"\n\"                       a directory besides the default ~/.vnc/certs)\\n\"\n\"\\n\"\n\"                       The openssl(1) program must be installed on the system\\n\"\n\"                       and available in PATH.  After the Key file is encrypted\\n\"\n\"                       the x11vnc command exits; the VNC server is not run.\\n\"\n\"\\n\"\n\"                       Examples:\\n\"\n\"                               x11vnc -sslEncKey /path/to/foo.pem\\n\"\n\"                               x11vnc -sslEncKey SAVE\\n\"\n\"                               x11vnc -sslEncKey SAVE-charlie\\n\"\n\"\\n\"\n\"-sslCertInfo pem       Prints out information about an existing PEM file.\\n\"\n\"                       In addition the public certificate is also printed.\\n\"\n\"                       The openssl(1) program must be in PATH. Basically the\\n\"\n\"                       command \\\"openssl x509 -text\\\" is run on the pem.\\n\"\n\"\\n\"\n\"                       After the info is printed the x11vnc command exits;\\n\"\n\"                       the VNC server is not run.\\n\"\n\"\\n\"\n\"                       The \\\"SAVE\\\" notation described under -ssl applies\\n\"\n\"                       as well.\\n\"\n\"\\n\"\n\"                       Using  \\\"LIST\\\" will give a list of all certs being\\n\"\n\"                       managed (in the ~/.vnc/certs dir, use -ssldir to refer\\n\"\n\"                       to another dir).  \\\"ALL\\\" will print out the info for\\n\"\n\"                       every managed key (this can be very long).  Giving a\\n\"\n\"                       client or server cert shortname will also try a lookup\\n\"\n\"                       (e.g. -sslCertInfo charlie).  Use \\\"LISTL\\\" or \\\"LL\\\"\\n\"\n\"                       for a long (ls -l style) listing.\\n\"\n\"\\n\"\n\"                       Using \\\"HASHON\\\" will create subdirs [dir]/HASH and\\n\"\n\"                       [dir]/HASH with OpenSSL hash filenames (e.g. 0d5fbbf1.0)\\n\"\n\"                       symlinks pointing up to the corresponding *.crt file.\\n\"\n\"                       ([dir] is ~/.vnc/certs or one given by -ssldir.)\\n\"\n\"                       This is a useful way for other OpenSSL applications\\n\"\n\"                       (e.g. stunnel) to access all of the certs without\\n\"\n\"                       having to concatenate them.  x11vnc will not use them\\n\"\n\"                       unless you specifically reference them.  \\\"HASHOFF\\\"\\n\"\n\"                       removes these HASH subdirs.\\n\"\n\"\\n\"\n\"                       The LIST, LISTL, LL, ALL, HASHON, HASHOFF words can\\n\"\n\"                       also be lowercase, e.g. \\\"list\\\".\\n\"\n\"\\n\"\n\"-sslDelCert pem        Prompts you to delete all .crt .pem .key .req files\\n\"\n\"                       associated with [pem].  x11vnc then exits. \\\"SAVE\\\"\\n\"\n\"                       and lookups as in -sslCertInfo apply as well.\\n\"\n\"\\n\"\n\"-sslScripts            Prints out both the 'genCA' and 'genCert' x11vnc\\n\"\n\"                       openssl wrapper scripts for you to examine, modify, etc.\\n\"\n\"                       The scripts are printed to stdout and then the x11vnc\\n\"\n\"                       program exits.\\n\"\n\"\\n\"\n\"\\n\"\n\"-stunnel [pem]         Use the stunnel(8) (stunnel.mirt.net) to provide an\\n\"\n\"                       encrypted SSL tunnel between viewers and x11vnc.\\n\"\n\"\\n\"\n\"                       This external tunnel method was implemented prior to the\\n\"\n\"                       integrated -ssl encryption described above.  It still\\n\"\n\"                       works well and avoids the requirement of linking with\\n\"\n\"                       the OpenSSL libraries.  This mode requires stunnel\\n\"\n\"                       to be installed on the system and available via PATH\\n\"\n\"                       (n.b. stunnel is often installed in sbin directories).\\n\"\n\"                       Version 4.x of stunnel is assumed (but see -stunnel3\\n\"\n\"                       below.)\\n\"\n\"\\n\"\n\"                       [pem] is optional, use \\\"-stunnel /path/to/stunnel.pem\\\"\\n\"\n\"                       to specify a PEM certificate file to pass to stunnel.\\n\"\n\"                       See the -ssl option for more info on certificate files.\\n\"\n\"\\n\"\n\"                       Whether or not your stunnel has its own certificate\\n\"\n\"                       depends on your stunnel configuration; stunnel often\\n\"\n\"                       generates one at install time.  See your stunnel\\n\"\n\"                       documentation for details.  In any event, if you want to\\n\"\n\"                       use this certificate you must supply the full path to it\\n\"\n\"                       as [pem].  Note: the file may only be readable by root.\\n\"\n\"\\n\"\n\"                       [pem] may also be the special strings \\\"TMP\\\", \\\"SAVE\\\",\\n\"\n\"                       and \\\"SAVE...\\\" as described in the -ssl option.\\n\"\n\"                       If [pem] is not supplied, \\\"SAVE\\\" is assumed.\\n\"\n\"\\n\"\n\"                       Note that the VeNCrypt, ANONTLS, and \\\"ANON\\\" modes\\n\"\n\"                       are not supported in -stunnel mode.\\n\"\n\"\\n\"\n\"                       stunnel is started up as a child process of x11vnc and\\n\"\n\"                       any SSL connections stunnel receives are decrypted and\\n\"\n\"                       sent to x11vnc over a local socket.  The strings\\n\"\n\"                       \\\"The SSL VNC desktop is ...\\\" and \\\"SSLPORT=...\\\"\\n\"\n\"                       are printed out at startup to indicate this.\\n\"\n\"\\n\"\n\"                       The -localhost option is enforced by default to avoid\\n\"\n\"                       people routing around the SSL channel.  Use -env\\n\"\n\"                       STUNNEL_DISABLE_LOCALHOST=1 to disable this security\\n\"\n\"                       requirement.\\n\"\n\"\\n\"\n\"                       Set -env STUNNEL_DEBUG=1 for more debugging printout.\\n\"\n\"\\n\"\n\"                       Set -env STUNNEL_PROG=xxx to the full path of stunnel\\n\"\n\"                       program you want to be used (e.g. /usr/bin/stunnel4).\\n\"\n\"\\n\"\n\"                       Set -env STUNNEL_LISTEN=xxx to the address of the\\n\"\n\"                       network interface to listen on (the default is to listen\\n\"\n\"                       on all interfaces), e.g. STUNNEL_LISTEN=192.168.1.100.\\n\"\n\"\\n\"\n\"                       A simple way to add IPv6 support is STUNNEL_LISTEN=::\\n\"\n\"\\n\"\n\"                       Your VNC viewer will also need to be able to connect\\n\"\n\"                       via SSL.  Unfortunately not too many do this.  See the\\n\"\n\"                       information about SSL viewers under the -ssl option.\\n\"\n\"                       The x11vnc project's SSVNC is an option.\\n\"\n\"\\n\"\n\"                       Also, in the x11vnc distribution, patched TightVNC\\n\"\n\"                       and UltraVNC Java applet jar files are provided in\\n\"\n\"                       the classes/ssl directory that do SSL connections.\\n\"\n\"                       Enable serving them with the -http, -http_ssl, or\\n\"\n\"                       -httpdir (see the option descriptions for more info.)\\n\"\n\"\\n\"\n\"                       Note that for the Java viewer applet usage the\\n\"\n\"                       \\\"?PORT=xxxx\\\" in the various URLs printed at startup\\n\"\n\"                       will need to be supplied to the web browser to connect\\n\"\n\"                       properly.\\n\"\n\"\\n\"\n\"                       Currently the automatic \\\"single port\\\" HTTPS mode of\\n\"\n\"                       -ssl is not fully supported in -stunnel mode.  However,\\n\"\n\"                       it can be emulated via:\\n\"\n\"\\n\"\n\"                         %% x11vnc -stunnel -http_ssl -http_oneport ...\\n\"\n\"\\n\"\n\"                       In general, it is also not too difficult to set up\\n\"\n\"                       an stunnel or other SSL tunnel on the viewer side.\\n\"\n\"                       A simple example on Unix using stunnel 3.x is:\\n\"\n\"\\n\"\n\"                         %% stunnel -c -d localhost:5901 -r remotehost:5900\\n\"\n\"                         %% vncviewer localhost:1\\n\"\n\"\\n\"\n\"                       For Windows, stunnel has been ported to it and there\\n\"\n\"                       are probably other such tools available.  See the FAQ\\n\"\n\"                       and SSVNC for more examples.\\n\"\n\"\\n\"\n\"-stunnel3  [pem]       Use version 3.x stunnel command line syntax instead of\\n\"\n\"                       version 4.x.  The -http/-httpdir Java applet serving\\n\"\n\"                       is currently not available in this mode.\\n\"\n\"\\n\"\n\"-enc cipher:keyfile    Use symmetric encryption with cipher \\\"cipher\\\"\\n\"\n\"                       and secret key data in \\\"keyfile\\\".  If keyfile is\\n\"\n\"                       pw=<string> then \\\"string\\\" is used as the key data.\\n\"\n\"\\n\"\n\"                       NOTE: It is recommended that you use SSL via the -ssl\\n\"\n\"                       option instead of this option because SSL is well\\n\"\n\"                       understood and takes great care to establish unique\\n\"\n\"                       session keys and is more compatible with other software.\\n\"\n\"                       Use this option if you do not want to deal with SSL\\n\"\n\"                       certificates for authentication and do not want to\\n\"\n\"                       use SSH but want some encryption for your VNC session.\\n\"\n\"                       Or if you must interface with a symmetric key tunnel\\n\"\n\"                       that you do not have control over.\\n\"\n\"\\n\"\n\"                       Note that this mode will NOT work with the UltraVNC DSM\\n\"\n\"                       plugins because they alter the RFB protocol in addition\\n\"\n\"                       to tunnelling with the symmetric cipher (an unfortunate\\n\"\n\"                       choice of implementation...)\\n\"\n\"\\n\"\n\"                       cipher can be one of:  arc4, aesv2, aes-cfb, blowfish,\\n\"\n\"                       aes256, or 3des.  See the OpenSSL documentation for\\n\"\n\"                       more info.  The keysize is 128 bits (except for aes256).\\n\"\n\"                       Here is one way to make a keyfile with that many bits:\\n\"\n\"\\n\"\n\"                            dd if=/dev/random of=./my.key bs=16 count=1\\n\"\n\"\\n\"\n\"                       you will need to securely share this key with the other\\n\"\n\"                       side of the VNC connection (See SSVNC for examples).\\n\"\n\"\\n\"\n\"                       Example:  -enc blowfish:./my.key\\n\"\n\"                       Example:  -enc blowfish:pw=swordfish\\n\"\n\"\\n\"\n\"                       By default 16 bytes of random salt followed by 16 bytes\\n\"\n\"                       of random initialization vector are sent at the very\\n\"\n\"                       beginning of the stream.  The other side must read these\\n\"\n\"                       and initialize their cipher with them.  These values\\n\"\n\"                       make the session key unique (without them the security\\n\"\n\"                       is minimal).  Similarly, the other side must send us\\n\"\n\"                       its random salt and IV with those same lengths.\\n\"\n\"\\n\"\n\"                       The salt and key data are combined to create a session\\n\"\n\"                       key using an md5 hash as described in EVP_BytesToKey(3).\\n\"\n\"\\n\"\n\"                       The exact call is: EVP_BytesToKey(Cipher, EVP_md5(),\\n\"\n\"                       salt, keydata, len, 1, keystr, NULL);  where salt is\\n\"\n\"                       the random data as described above, and keydata is the\\n\"\n\"                       shared secret key data.  keystr is the resulting session\\n\"\n\"                       key.  The cipher is then seeded with keystr and uses\\n\"\n\"                       the random initialization vector as its first block.\\n\"\n\"\\n\"\n\"                       To modify the amount of random salt and initialization\\n\"\n\"                       vector use cipher@n,m where n is the salt length and\\n\"\n\"                       m the initialization vector length.  E.g.\\n\"\n\"\\n\"\n\"                                 -enc aes-cfb@8,16:./my.key\\n\"\n\"\\n\"\n\"                       It is not a good idea to set either one to zero,\\n\"\n\"                       although you may be forced to if the other side of the\\n\"\n\"                       tunnel is not under your control.\\n\"\n\"\\n\"\n\"                       To skip the salt and EVP_BytesToKey MD5 entirely (no\\n\"\n\"                       hashing is done: the keydata is directly inserted into\\n\"\n\"                       the cipher) specify \\\"-1\\\" for the salt, e.g.\\n\"\n\"\\n\"\n\"                                 -enc blowfish@-1,16:./my.key\\n\"\n\"\\n\"\n\"                       The message digest can also be changed to something\\n\"\n\"                       besides the default MD5.  Use cipher@md+n,m where \\\"md\\\"\\n\"\n\"                       can be one of sha, sha1, md5, or ripe.  For example:\\n\"\n\"\\n\"\n\"                                 -enc arc4@sha+8,16:./my.key\\n\"\n\"\\n\"\n\"                       The SSVNC vnc viewer project supplies a symmetric\\n\"\n\"                       encryption tool named \\\"ultravnc_dsm_helper\\\" that can\\n\"\n\"                       be used on the viewer side.  For example:\\n\"\n\"\\n\"\n\"                       ssvncviewer exec='ultravnc_dsm_helper arc4 my.key 0 h:p'\\n\"\n\"\\n\"\n\"                       where h:p is the hostname and port of the x11vnc server.\\n\"\n\"                       ultravnc_dsm_helper may also be used standalone to\\n\"\n\"                       provide a symmetric encryption tunnel for any viewer\\n\"\n\"                       or server (VNC or otherwise.) The cipher (1st arg)\\n\"\n\"                       is basically the same syntax as we use above.\\n\"\n\"\\n\"\n\"                       Also see the 'Non-Ultra DSM' SSVNC option for the\\n\"\n\"                       'UltraVNC DSM Encryption Plugin' advanced option.\\n\"\n\"\\n\"\n\"                       For both ways of using the viewer, you can specify the\\n\"\n\"                       salt,ivec sizes (in GUI or, e.g. arc4@8,16).\\n\"\n\"\\n\"\n\"-https [port]          Use a special, separate HTTPS port (-ssl and\\n\"\n\"                       -stunnel modes only) for HTTPS Java viewer applet\\n\"\n\"                       downloading. I.e. not 5900 and not 5800 (the defaults.)\\n\"\n\"\\n\"\n\"                       BACKGROUND: In -ssl mode, it turns out you can use the\\n\"\n\"                       single VNC port (e.g. 5900) for both VNC and HTTPS\\n\"\n\"                       connections. (HTTPS is used to retrieve a SSL-aware\\n\"\n\"                       VncViewer.jar applet that is provided with x11vnc).\\n\"\n\"                       Since both use SSL the implementation was extended to\\n\"\n\"                       detect if HTTP traffic (i.e. GET) is taking place and\\n\"\n\"                       handle it accordingly.  The URL would be, e.g.:\\n\"\n\"\\n\"\n\"                       https://mymachine.org:5900/\\n\"\n\"\\n\"\n\"                       This is convenient for firewalls, etc, because only one\\n\"\n\"                       port needs to be allowed in.  However, this heuristic\\n\"\n\"                       adds a few seconds delay to each connection and can be\\n\"\n\"                       unreliable (especially if the user takes much time to\\n\"\n\"                       ponder the Certificate dialogs in his browser, Java VM,\\n\"\n\"                       or VNC Viewer applet.  That's right 3 separate \\\"Are\\n\"\n\"                       you sure you want to connect?\\\" dialogs!)\\n\"\n\"\\n\"\n\"                       END OF BACKGROUND.\\n\"\n\"\\n\"\n\"                       USAGE: So use the -https option to provide a separate,\\n\"\n\"                       more reliable HTTPS port that x11vnc will listen on.  If\\n\"\n\"                       [port] is not provided (or is 0), one is autoselected.\\n\"\n\"                       The URL to use is printed out at startup.\\n\"\n\"\\n\"\n\"                       The SSL Java applet directory is specified via the\\n\"\n\"                       -httpdir option.  If not supplied, -https will try\\n\"\n\"                       to guess the directory as though the -http option\\n\"\n\"                       was supplied.\\n\"\n\"\\n\"\n\"-httpsredir [port]     In -ssl mode with the Java applet retrieved via HTTPS,\\n\"\n\"                       when the HTML file containing applet parameters\\n\"\n\"                       ('index.vnc' or 'proxy.vnc') is sent do NOT set the\\n\"\n\"                       applet PORT parameter to the actual VNC port but set it\\n\"\n\"                       to \\\"port\\\" instead.  If \\\"port\\\" is not supplied, then\\n\"\n\"                       the port number is guessed from the Host: HTTP header.\\n\"\n\"\\n\"\n\"                       This is useful when an incoming TCP connection\\n\"\n\"                       redirection is performed by a router/gateway/firewall\\n\"\n\"                       from one port to an internal machine where x11vnc is\\n\"\n\"                       listening on a different port. The Java applet needs to\\n\"\n\"                       connect to the firewall/router port, not the VNC port\\n\"\n\"                       on the internal workstation. For example, one could\\n\"\n\"                       redir from mygateway.com:443 to workstation:5900.\\n\"\n\"\\n\"\n\"                       This spares the user from having to type in\\n\"\n\"                       https://mygateway.com/?PORT=443 into their web\\n\"\n\"                       browser. Note that port 443 is the default https port;\\n\"\n\"                       other ports must be explicitly indicated, for example:\\n\"\n\"                       https://mygateway.com:8000/?PORT=8000.  To avoid having\\n\"\n\"                       to include the PORT= in the browser URL, simply supply\\n\"\n\"                       \\\"-httpsredir\\\" to x11vnc.\\n\"\n\"\\n\"\n\"                       This option does not work in -stunnel mode.\\n\"\n\"\\n\"\n\"                       More tricks: set the env var X11VNC_EXTRA_HTTPS_PARAMS\\n\"\n\"                       to be extra URL parameters to use.  This way you do\\n\"\n\"                       not need to specify extra PARAMS in the index.vnc file.\\n\"\n\"                       E.g. x11vnc -env X11VNC_EXTRA_HTTPS_PARAMS='?GET=1' ...\\n\"\n\"\\n\"\n\"                       If you do not want to expose the non-SSL HTTP port to\\n\"\n\"                       the network (i.e. you just want the single VNC/HTTPS\\n\"\n\"                       port, e.g. 5900, open for connections) then specify the\\n\"\n\"                       option -env X11VNC_HTTP_LISTEN_LOCALHOST=1  This way\\n\"\n\"                       the connection to the LibVNCServer httpd server will\\n\"\n\"                       only be available on localhost (note that in -ssl mode,\\n\"\n\"                       HTTPS requests are redirected from SSL to the non-SSL\\n\"\n\"                       LibVNCServer HTTP server.)\\n\"\n\"\\n\"\n\"-http_oneport          For UN-encrypted connections mode (i.e. no -ssl,\\n\"\n\"                       -stunnel, or -enc options), allow the Java VNC Viewer\\n\"\n\"                       applet to be downloaded thru the VNC port via HTTP.\\n\"\n\"\\n\"\n\"                       That is to say, you can use a single port for Java\\n\"\n\"                       applet viewer connections by using a URL in your web\\n\"\n\"                       browser like this, for example:\\n\"\n\"\\n\"\n\"                       http://hostname:5900\\n\"\n\"\\n\"\n\"                       The regular, two-port mode, URL http://hostname:5800\\n\"\n\"                       will continue to work as well.\\n\"\n\"\\n\"\n\"                       As mentioned above, this mode will NOT work with\\n\"\n\"                       the -ssl, -stunnel, or -enc encryption options.\\n\"\n\"                       Note that is it equivalent to '-enc none' (i.e. it\\n\"\n\"                       uses the same detection mechanism as for HTTPS, but\\n\"\n\"                       with no encryption.)\\n\"\n\"\\n\"\n\"                       HTTPS single-port is on by default in -ssl encrypted\\n\"\n\"                       mode (and -enc too), so you only need -http_oneport\\n\"\n\"                       when doing non-SSL encrypted connections.\\n\"\n\"\\n\"\n\"                       This mode could also be useful for SSH tunnels since\\n\"\n\"                       it means only one port needs to be redirected.\\n\"\n\"\\n\"\n\"                       The -httpsredir option may also be useful for this\\n\"\n\"                       mode when using an SSH tunnel as well as for router\\n\"\n\"                       port redirections.\\n\"\n\"\\n\"\n\"                       Note that the -env X11VNC_HTTP_LISTEN_LOCALHOST=1\\n\"\n\"                       option described above under -httpsredir applies for\\n\"\n\"                       the LibVNCServer httpd server in all cases (ssl or not.)\\n\"\n\"\\n\"\n\"-ssh user@host:disp    Create a remote listening port on machine \\\"host\\\"\\n\"\n\"                       via a SSH tunnel using the -R rport:localhost:lport\\n\"\n\"                       method. lport will be the local x11vnc listening port,\\n\"\n\"                       so a connection to rport (5900+disp) on \\\"host\\\"\\n\"\n\"                       will reach x11vnc.  E.g. fred@snoopy.com:0\\n\"\n\"\\n\"\n\"                       This could be useful if a firewall/router prevents\\n\"\n\"                       incoming connections to the x11vnc machine, but\\n\"\n\"                       the ssh machine \\\"host\\\" can be reached by the VNC\\n\"\n\"                       viewer. \\\"user@\\\" is not needed unless the remote unix\\n\"\n\"                       username differs from the current one.\\n\"\n\"\\n\"\n\"                       By default the remote sshd is usually configured to\\n\"\n\"                       listen only on localhost for rport, so the viewer may\\n\"\n\"                       need to ssh -L redir to \\\"host\\\" as well (See SSVNC to\\n\"\n\"                       automate this).  The sshd setting GatewayPorts enables\\n\"\n\"                       listening on all interfaces for rport; viewers can\\n\"\n\"                       reach it more easily.\\n\"\n\"\\n\"\n\"                       \\\"disp\\\" is the VNC display for the remote SSH side,\\n\"\n\"                       e.g. 0 corresponds to port 5900, etc.  If disp is\\n\"\n\"                       greater than 200 the value is used as the port.  Use a\\n\"\n\"                       negative value to force a low port, e.g. host:-80 will\\n\"\n\"                       use port 80.\\n\"\n\"\\n\"\n\"                       If ssh-agent is not active, then the ssh password needs\\n\"\n\"                       to be entered in the terminal where x11vnc is running.\\n\"\n\"\\n\"\n\"                       By default the remote ssh will issue a 'sleep 300' to\\n\"\n\"                       wait for the incoming connection for 5 mins.  To modify\\n\"\n\"                       this use user@host:disp+secs.\\n\"\n\"\\n\"\n\"                       If the remote SSH server is on a non-standard port\\n\"\n\"                       (i.e. not 22) use user@host:port:disp+secs.\\n\"\n\"\\n\"\n\"                       Note that the ssh process MAY NOT be killed when\\n\"\n\"                       x11vnc exits.  It tries by looking at ps(1) output.\\n\"\n\"\\n\"\n\"-usepw                 If no other password method was supplied on the command\\n\"\n\"                       line, first look for ~/.vnc/passwd and if found use it\\n\"\n\"                       with -rfbauth; next, look for ~/.vnc/passwdfile and\\n\"\n\"                       use it with -passwdfile; otherwise, prompt the user\\n\"\n\"                       for a password to create ~/.vnc/passwd and use it with\\n\"\n\"                       the -rfbauth option.  If none of these succeed x11vnc\\n\"\n\"                       exits immediately.\\n\"\n\"\\n\"\n\"-storepasswd pass file Store password \\\"pass\\\" as the VNC password in the\\n\"\n\"                       file \\\"file\\\".  Once the password is stored the\\n\"\n\"                       program exits.  Use the password via \\\"-rfbauth file\\\"\\n\"\n\"\\n\"\n\"                       If called with no arguments, \\\"x11vnc -storepasswd\\\",\\n\"\n\"                       the user is prompted for a password and it is stored\\n\"\n\"                       in the file ~/.vnc/passwd.  Called with one argument,\\n\"\n\"                       that will be the file to store the prompted password in.\\n\"\n\"\\n\"\n\"-nopw                  Disable the big warning message when you use x11vnc\\n\"\n\"                       without some sort of password.\\n\"\n\"\\n\"\n\"-accept string         Run a command (possibly to prompt the user at the\\n\"\n\"                       X11 display) to decide whether an incoming client\\n\"\n\"                       should be allowed to connect or not.  \\\"string\\\" is\\n\"\n\"                       an external command run via system(3) or some special\\n\"\n\"                       cases described below.  Be sure to quote \\\"string\\\"\\n\"\n\"                       if it contains spaces, shell characters, etc.  If the\\n\"\n\"                       external command returns 0 the client is accepted,\\n\"\n\"                       otherwise the client is rejected.  See below for an\\n\"\n\"                       extension to accept a client view-only.\\n\"\n\"\\n\"\n\"                       If x11vnc is running as root (say from inetd(8) or from\\n\"\n\"                       display managers xdm(1), gdm(1), etc), think about the\\n\"\n\"                       security implications carefully before supplying this\\n\"\n\"                       option (likewise for the -gone option).\\n\"\n\"\\n\"\n\"                       Environment: The RFB_CLIENT_IP environment variable will\\n\"\n\"                       be set to the incoming client IP number and the port\\n\"\n\"                       in RFB_CLIENT_PORT (or -1 if unavailable).  Similarly,\\n\"\n\"                       RFB_SERVER_IP and RFB_SERVER_PORT (the x11vnc side\\n\"\n\"                       of the connection), are set to allow identification\\n\"\n\"                       of the tcp virtual circuit.  The x11vnc process\\n\"\n\"                       id will be in RFB_X11VNC_PID, a client id number in\\n\"\n\"                       RFB_CLIENT_ID, and the number of other connected clients\\n\"\n\"                       in RFB_CLIENT_COUNT.  RFB_MODE will be \\\"accept\\\".\\n\"\n\"                       RFB_STATE will be PROTOCOL_VERSION, SECURITY_TYPE,\\n\"\n\"                       AUTHENTICATION, INITIALISATION, NORMAL, or UNKNOWN\\n\"\n\"                       indicating up to which state the client has achieved.\\n\"\n\"                       RFB_LOGIN_VIEWONLY will be 0, 1, or -1 (unknown).\\n\"\n\"                       RFB_USERNAME, RFB_LOGIN_TIME, and RFB_CURRENT_TIME may\\n\"\n\"                       also be set.\\n\"\n\"\\n\"\n\"                       If \\\"string\\\" is \\\"popup\\\" then a builtin popup window\\n\"\n\"                       is used.  The popup will time out after 120 seconds,\\n\"\n\"                       use \\\"popup:N\\\" to modify the timeout to N seconds\\n\"\n\"                       (use 0 for no timeout).\\n\"\n\"\\n\"\n\"                       In the case of \\\"popup\\\" and when the -unixpw option\\n\"\n\"                       is specified, then a *second* window will be popped\\n\"\n\"                       up after the user successfully logs in via his UNIX\\n\"\n\"                       password.  This time the user will be identified as\\n\"\n\"                       UNIX:username@hostname, the \\\"UNIX:\\\" prefix indicates\\n\"\n\"                       which user the viewer logged as via -unixpw.  The first\\n\"\n\"                       popup is only for whether to allow him to even *try*\\n\"\n\"                       to login via unix password.\\n\"\n\"\\n\"\n\"                       If \\\"string\\\" is \\\"xmessage\\\" then an xmessage(1)\\n\"\n\"                       invocation is used for the command.  xmessage must be\\n\"\n\"                       installed on the machine for this to work.\\n\"\n\"\\n\"\n\"                       Both \\\"popup\\\" and \\\"xmessage\\\" will present an option\\n\"\n\"                       for accepting the client \\\"View-Only\\\" (the client\\n\"\n\"                       can only watch).  This option will not be presented if\\n\"\n\"                       -viewonly has been specified, in which case the entire\\n\"\n\"                       display is view only.\\n\"\n\"\\n\"\n\"                       If the user supplied command is prefixed with something\\n\"\n\"                       like \\\"yes:0,no:*,view:3 mycommand ...\\\" then this\\n\"\n\"                       associates the numerical command return code with\\n\"\n\"                       the actions: accept, reject, and accept-view-only,\\n\"\n\"                       respectively.  Use \\\"*\\\" instead of a number to indicate\\n\"\n\"                       the default action (in case the command returns an\\n\"\n\"                       unexpected value).  E.g. \\\"no:*\\\" is a good choice.\\n\"\n\"\\n\"\n\"                       Note that x11vnc blocks while the external command\\n\"\n\"                       or popup is running (other clients may see no updates\\n\"\n\"                       during this period).  So a person sitting a the physical\\n\"\n\"                       display is needed to respond to an popup prompt. (use\\n\"\n\"                       a 2nd x11vnc if you lock yourself out).\\n\"\n\"\\n\"\n\"                       More -accept tricks: use \\\"popupmouse\\\" to only allow\\n\"\n\"                       mouse clicks in the builtin popup to be recognized.\\n\"\n\"                       Similarly use \\\"popupkey\\\" to only recognize\\n\"\n\"                       keystroke responses.  These are to help avoid the\\n\"\n\"                       user accidentally accepting a client by typing or\\n\"\n\"                       clicking. All 3 of the popup keywords can be followed\\n\"\n\"                       by +N+M to supply a position for the popup window.\\n\"\n\"                       The default is to center the popup window.\\n\"\n\"-afteraccept string    As -accept, except to run a user supplied command after\\n\"\n\"                       a client has been accepted and authenticated. RFB_MODE\\n\"\n\"                       will be set to \\\"afteraccept\\\" and the other RFB_*\\n\"\n\"                       variables are as in -accept.  Unlike -accept, the\\n\"\n\"                       command return code is not interpreted by x11vnc.\\n\"\n\"                       Example: -afteraccept 'killall xlock &'\\n\"\n\"-gone string           As -accept, except to run a user supplied command when\\n\"\n\"                       a client goes away (disconnects).  RFB_MODE will be\\n\"\n\"                       set to \\\"gone\\\" and the other RFB_* variables are as\\n\"\n\"                       in -accept.  The \\\"popup\\\" actions apply as well.\\n\"\n\"                       Unlike -accept, the command return code is not\\n\"\n\"                       interpreted by x11vnc.  Example: -gone 'xlock &'\\n\"\n\"\\n\"\n\"-users list            If x11vnc is started as root (say from inetd(8) or from\\n\"\n\"                       display managers xdm(1), gdm(1), etc), then as soon\\n\"\n\"                       as possible after connections to the X display are\\n\"\n\"                       established try to switch to one of the users in the\\n\"\n\"                       comma separated \\\"list\\\".  If x11vnc is not running as\\n\"\n\"                       root this option is ignored.\\n\"\n\"\\n\"\n\"                       Why use this option?  In general it is not needed since\\n\"\n\"                       x11vnc is already connected to the X display and can\\n\"\n\"                       perform its primary functions.  The option was added\\n\"\n\"                       to make some of the *external* utility commands x11vnc\\n\"\n\"                       occasionally runs work properly.  In particular under\\n\"\n\"                       GNOME and KDE to implement the \\\"-solid color\\\" feature\\n\"\n\"                       external commands (gconftool-2 and dcop) unfortunately\\n\"\n\"                       must be run as the user owning the desktop session.\\n\"\n\"                       Since this option switches userid it also affects the\\n\"\n\"                       userid used to run the processes for the -accept and\\n\"\n\"                       -gone options.  It also affects the ability to read\\n\"\n\"                       files for options such as -connect, -allow, and -remap\\n\"\n\"                       and also the ultra and tight filetransfer feature if\\n\"\n\"                       enabled.  Note that the -connect file is also sometimes\\n\"\n\"                       written to.\\n\"\n\"\\n\"\n\"                       So be careful with this option since in some situations\\n\"\n\"                       its use can decrease security.\\n\"\n\"\\n\"\n\"                       In general the switch to a user will only take place\\n\"\n\"                       if the display can still be successfully opened as that\\n\"\n\"                       user (this is primarily to try to guess the actual owner\\n\"\n\"                       of the session). Example: \\\"-users fred,wilma,betty\\\".\\n\"\n\"                       Note that a malicious local user \\\"barney\\\" by\\n\"\n\"                       quickly using \\\"xhost +\\\" when logging in may possibly\\n\"\n\"                       get the x11vnc process to switch to user \\\"fred\\\".\\n\"\n\"                       What happens next?\\n\"\n\"\\n\"\n\"                       Under display managers it may be a long time before\\n\"\n\"                       the switch succeeds (i.e. a user logs in).  To instead\\n\"\n\"                       make it switch immediately regardless if the display\\n\"\n\"                       can be reopened prefix the username with the \\\"+\\\"\\n\"\n\"                       character. E.g. \\\"-users +bob\\\" or \\\"-users +nobody\\\".\\n\"\n\"\\n\"\n\"                       The latter (i.e. switching immediately to user\\n\"\n\"                       \\\"nobody\\\") is the only obvious use of the -users option\\n\"\n\"                       that increases security.\\n\"\n\"\\n\"\n\"                       Use the following notation to associate a group with\\n\"\n\"                       a user: user1.group1,user2.group2,...  Note that\\n\"\n\"                       initgroups(2) will still be called first to try to\\n\"\n\"                       switch to ALL of a user's groups (primary and additional\\n\"\n\"                       groups).  Only if that fails or it is not available\\n\"\n\"                       then the single group specified as above (or the user's\\n\"\n\"                       primary group if not specified) is switched to with\\n\"\n\"                       setgid(2).  Use -env X11VNC_SINGLE_GROUP=1 to prevent\\n\"\n\"                       trying initgroups(2) and only switch to the single\\n\"\n\"                       group.  This sort of setting is only really needed to\\n\"\n\"                       make the ultra or tight filetransfer permissions work\\n\"\n\"                       properly. This format applies to any comma separated list\\n\"\n\"                       of users, even the special \\\"=\\\" modes described below.\\n\"\n\"\\n\"\n\"                       In -unixpw mode, if \\\"-users unixpw=\\\" is supplied\\n\"\n\"                       then after a user authenticates himself via the\\n\"\n\"                       -unixpw mechanism, x11vnc will try to switch to that\\n\"\n\"                       user as though \\\"-users +username\\\" had been supplied.\\n\"\n\"                       If you want to limit which users this will be done for,\\n\"\n\"                       provide them as a comma separated list after \\\"unixpw=\\\"\\n\"\n\"                       Groups can also be specified as described above.\\n\"\n\"\\n\"\n\"                       Similarly, in -ssl mode, if \\\"-users sslpeer=\\\" is\\n\"\n\"                       supplied then after an SSL client authenticates with his\\n\"\n\"                       cert (the -sslverify option is required for this) x11vnc\\n\"\n\"                       will extract a UNIX username from the \\\"emailAddress\\\"\\n\"\n\"                       field (username@hostname.com) of the \\\"Subject\\\" of the\\n\"\n\"                       x509 SSL cert and then try to switch to that user as\\n\"\n\"                       though \\\"-users +username\\\" had been supplied.  If you\\n\"\n\"                       want to limit which users this will be done for, provide\\n\"\n\"                       them as a comma separated list after \\\"sslpeer=\\\".\\n\"\n\"                       Set the env. var X11VNC_SSLPEER_CN to use the Common\\n\"\n\"                       Name (normally a hostname) instead of the Email field.\\n\"\n\"\\n\"\n\"                       NOTE: for sslpeer= mode the x11vnc administrator must\\n\"\n\"                       take care that any client certs he adds to -sslverify\\n\"\n\"                       have the intended UNIX username in the \\\"emailAddress\\\"\\n\"\n\"                       field of the cert.  Otherwise a user may be able to\\n\"\n\"                       log in as another.  This command can be of use in\\n\"\n\"                       checking: \\\"openssl x509 -text -in file.crt\\\", see the\\n\"\n\"                       \\\"Subject:\\\" line.  Also, along with the normal RFB_*\\n\"\n\"                       env. vars. (see -accept) passed to external cmd=\\n\"\n\"                       commands, RFB_SSL_CLIENT_CERT will be set to the\\n\"\n\"                       client's x509 certificate string.\\n\"\n\"\\n\"\n\"                       The sslpeer= mode can aid finding X sessions via the\\n\"\n\"                       FINDDISPLAY and FINDCREATEDISPLAY mechanisms.\\n\"\n\"\\n\"\n\"                       To immediately switch to a user *before* connections\\n\"\n\"                       to the X display are made or any files opened use the\\n\"\n\"                       \\\"=\\\" character: \\\"-users =bob\\\".  That user needs to\\n\"\n\"                       be able to open the X display and any files of course.\\n\"\n\"\\n\"\n\"                       The special user \\\"guess=\\\" means to examine the utmpx\\n\"\n\"                       database (see who(1)) looking for a user attached to\\n\"\n\"                       the display number (from DISPLAY or -display option)\\n\"\n\"                       and try him/her.  To limit the list of guesses, use:\\n\"\n\"                       \\\"-users guess=bob,betty\\\".\\n\"\n\"\\n\"\n\"                       Even more sinister is the special user \\\"lurk=\\\"\\n\"\n\"                       that means to try to guess the DISPLAY from the utmpx\\n\"\n\"                       login database as well.  So it \\\"lurks\\\" waiting for\\n\"\n\"                       anyone to log into an X session and then connects to it.\\n\"\n\"                       Specify a list of users after the = to limit which users\\n\"\n\"                       will be tried.  To enable a different searching mode, if\\n\"\n\"                       the first user in the list is something like \\\":0\\\" or\\n\"\n\"                       \\\":0-2\\\" that indicates a range of DISPLAY numbers that\\n\"\n\"                       will be tried (regardless of whether they are in the\\n\"\n\"                       utmpx database) for all users that are logged in.  Also\\n\"\n\"                       see the \\\"-display WAIT:...\\\" functionality.  Examples:\\n\"\n\"                       \\\"-users lurk=\\\" and also \\\"-users lurk=:0-1,bob,mary\\\"\\n\"\n\"\\n\"\n\"                       Be especially careful using the \\\"guess=\\\" and \\\"lurk=\\\"\\n\"\n\"                       modes.  They are not recommended for use on machines\\n\"\n\"                       with untrustworthy local users.\\n\"\n\"\\n\"\n\"-noshm                 Do not use the MIT-SHM extension for the polling.\\n\"\n\"                       Remote displays can be polled this way: be careful this\\n\"\n\"                       can use large amounts of network bandwidth.  This is\\n\"\n\"                       also of use if the local machine has a limited number\\n\"\n\"                       of shm segments and -onetile is not sufficient.\\n\"\n\"-flipbyteorder         Sometimes needed if remotely polled host has different\\n\"\n\"                       endianness.  Ignored unless -noshm is set.\\n\"\n\"-onetile               Do not use the new copy_tiles() framebuffer mechanism,\\n\"\n\"                       just use 1 shm tile for polling.  Limits shm segments\\n\"\n\"                       used to 3.\\n\"\n\"\\n\"\n\"                       To disable any automatic shm reduction set the\\n\"\n\"                       env. var. X11VNC_NO_LIMIT_SHM.\\n\"\n\"\\n\"\n\"-solid [color]         To improve performance, when VNC clients are connected\\n\"\n\"                       try to change the desktop background to a solid color.\\n\"\n\"                       The [color] is optional: the default color is \\\"cyan4\\\".\\n\"\n\"                       For a different one specify the X color (rgb.txt name,\\n\"\n\"                       e.g. \\\"darkblue\\\" or numerical \\\"#RRGGBB\\\").\\n\"\n\"\\n\"\n\"                       Currently this option only works on GNOME, KDE, CDE,\\n\"\n\"                       XFCE, and classic X (i.e. with the background image\\n\"\n\"                       on the root window).  The \\\"gconftool-2\\\", \\\"dcop\\\"\\n\"\n\"                       and \\\"xfconf-query\\\" external commands are run for\\n\"\n\"                       GNOME, KDE, and XFCE respectively.  This also works\\n\"\n\"                       on native MacOSX.  (There is no color selection for\\n\"\n\"                       MacOSX or XFCE.)  Other desktops won't work, (send\\n\"\n\"                       us the corresponding commands if you find them).\\n\"\n\"                       If x11vnc is running as root (inetd(8) or gdm(1)),\\n\"\n\"                       the -users option may be needed for GNOME, KDE, XFCE.\\n\"\n\"                       If x11vnc guesses your desktop incorrectly, you can\\n\"\n\"                       force it by prefixing color with \\\"gnome:\\\", \\\"kde:\\\",\\n\"\n\"                       \\\"cde:\\\", \\\"xfce:\\\", or \\\"root:\\\".\\n\"\n\"\\n\"\n\"                       Update: -solid no longer works on KDE4.\\n\"\n\"\\n\"\n\"                       This mode works in a limited way on the Mac OS X Console\\n\"\n\"                       with one color ('kelp') using the screensaver writing\\n\"\n\"                       to the background.  Look in \\\"~/Library/Screen Savers\\\"\\n\"\n\"                       for VncSolidColor.png to change the color.\\n\"\n\"\\n\"\n\"-blackout string       Black out rectangles on the screen. \\\"string\\\" is a\\n\"\n\"                       comma separated list of WxH+X+Y type geometries for\\n\"\n\"                       each rectangle.  If one of the items on the list is the\\n\"\n\"                       string \\\"noptr\\\" the mouse pointer will not be allowed\\n\"\n\"                       to go into a blacked out region.\\n\"\n\"-xinerama              If your screen is composed of multiple monitors\\n\"\n\"-noxinerama            glued together via XINERAMA, and that screen is\\n\"\n\"                       not a rectangle this option will try to guess the\\n\"\n\"                       areas to black out (if your system has libXinerama).\\n\"\n\"                       default: %s\\n\"\n\"\\n\"\n\"                       In general, we have noticed on XINERAMA displays you may\\n\"\n\"                       need to use the \\\"-xwarppointer\\\" option if the mouse\\n\"\n\"                       pointer misbehaves and it is enabled by default. Use\\n\"\n\"                       \\\"-noxwarppointer\\\" if you do not want this.\\n\"\n\"\\n\"\n\"-xtrap                 Use the DEC-XTRAP extension for keystroke and mouse\\n\"\n\"                       input insertion.  For use on legacy systems, e.g. X11R5,\\n\"\n\"                       running an incomplete or missing XTEST extension.\\n\"\n\"                       By default DEC-XTRAP will be used if XTEST server grab\\n\"\n\"                       control is missing, use -xtrap to do the keystroke and\\n\"\n\"                       mouse insertion via DEC-XTRAP as well.\\n\"\n\"\\n\"\n\"-xrandr [mode]         If the display supports the XRANDR (X Resize, Rotate\\n\"\n\"                       and Reflection) extension, and you expect XRANDR events\\n\"\n\"                       to occur to the display while x11vnc is running, this\\n\"\n\"                       options indicates x11vnc should try to respond to\\n\"\n\"                       them (as opposed to simply crashing by assuming the\\n\"\n\"                       old screen size).  See the xrandr(1) manpage and run\\n\"\n\"                       'xrandr -q' for more info.  [mode] is optional and\\n\"\n\"                       described below.\\n\"\n\"\\n\"\n\"                       Since watching for XRANDR events and trapping errors\\n\"\n\"                       increases polling overhead, only use this option if\\n\"\n\"                       XRANDR changes are expected.  For example on a rotatable\\n\"\n\"                       screen PDA or laptop, or using a XRANDR-aware Desktop\\n\"\n\"                       where you resize often.  It is best to be viewing with a\\n\"\n\"                       vncviewer that supports the NewFBSize encoding, since it\\n\"\n\"                       knows how to react to screen size changes.  Otherwise,\\n\"\n\"                       LibVNCServer tries to do so something reasonable for\\n\"\n\"                       viewers that cannot do this (portions of the screen\\n\"\n\"                       may be clipped, unused, etc).\\n\"\n\"\\n\"\n\"                       Note: the default now is to check for XRANDR events, but\\n\"\n\"                       do not trap every X call that may fail due to resize.\\n\"\n\"                       If a resize event is received, the full -xrandr mode\\n\"\n\"                       is enabled.  To disable even checking for events supply:\\n\"\n\"                       -noxrandr.\\n\"\n\"\\n\"\n\"                       \\\"mode\\\" defaults to \\\"resize\\\", which means create a\\n\"\n\"                       new, resized, framebuffer and hope all viewers can cope\\n\"\n\"                       with the change.  \\\"newfbsize\\\" means first disconnect\\n\"\n\"                       all viewers that do not support the NewFBSize VNC\\n\"\n\"                       encoding, and then resize the framebuffer.  \\\"exit\\\"\\n\"\n\"                       means disconnect all viewer clients, and then terminate\\n\"\n\"                       x11vnc.\\n\"\n\"\\n\"\n\"-rotate string         Rotate and/or flip the framebuffer view exported by VNC.\\n\"\n\"                       This transformation is independent of XRANDR and is\\n\"\n\"                       done in software in main memory and so may be slower.\\n\"\n\"                       This mode could be useful on a handheld with portrait or\\n\"\n\"                       landscape modes that do not correspond to the scanline\\n\"\n\"                       order of the actual framebuffer.  \\\"string\\\" can be:\\n\"\n\"\\n\"\n\"                             x     flip along x-axis\\n\"\n\"                             y     flip along y-axis\\n\"\n\"                            xy     flip along x- and y-axes\\n\"\n\"                           +90     rotate 90 degrees clockwise\\n\"\n\"                           -90     rotate 90 degrees counter-clockwise\\n\"\n\"                          +90x     rotate 90 degrees CW, then flip along x\\n\"\n\"                          +90y     rotate 90 degrees CW, then flip along y\\n\"\n\"\\n\"\n\"                       these give all possible rotations and reflections.\\n\"\n\"\\n\"\n\"                       Aliases: same as xy:  yx, +180, -180, 180\\n\"\n\"                                same as -90: +270, 270\\n\"\n\"                                same as +90: 90, (ditto for 90x, 90y)\\n\"\n\"\\n\"\n\"                       Like -scale, this transformation is applied at the very\\n\"\n\"                       end of any chain of framebuffer transformations and so\\n\"\n\"                       any options with geometries, e.g. -blackout, -clip, etc.\\n\"\n\"                       are relative to the original X (or -rawfb) framebuffer,\\n\"\n\"                       not the final one sent to VNC viewers.\\n\"\n\"\\n\"\n\"                       If you do not want the cursor shape to be rotated\\n\"\n\"                       prefix \\\"string\\\" with \\\"nc:\\\", e.g. \\\"nc:+90\\\",\\n\"\n\"                       \\\"nc:xy\\\", etc.\\n\"\n\"\\n\"\n\"-padgeom WxH           Whenever a new vncviewer connects, the framebuffer is\\n\"\n\"                       replaced with a fake, solid black one of geometry WxH.\\n\"\n\"                       Shortly afterwards the framebuffer is replaced with the\\n\"\n\"                       real one.  This is intended for use with vncviewers\\n\"\n\"                       that do not support NewFBSize and one wants to make\\n\"\n\"                       sure the initial viewer geometry will be big enough\\n\"\n\"                       to handle all subsequent resizes (e.g. under -xrandr,\\n\"\n\"                       -remote id:windowid, rescaling, etc.)\\n\"\n\"\\n\"\n\"                       In -unixpw mode this sets the size of the login screen.\\n\"\n\"                       Use \\\"once:WxH\\\" it ignore padgeom after the login\\n\"\n\"                       screen is set up.\\n\"\n\"\\n\"\n\"-o logfile             Write stderr messages to file \\\"logfile\\\" instead of to\\n\"\n\"                       the terminal.  Same as \\\"-logfile file\\\".  To append\\n\"\n\"                       to the file use \\\"-oa file\\\" or \\\"-logappend file\\\".\\n\"\n\"                       If \\\"logfile\\\" contains the string \\\"%%VNCDISPLAY\\\"\\n\"\n\"                       it is expanded to the vnc display (the name may need\\n\"\n\"                       to be guessed at.)  \\\"%%HOME\\\" works too.\\n\"\n\"\\n\"\n\"-flag file             Write the \\\"PORT=NNNN\\\" (e.g. PORT=5900) string to\\n\"\n\"                       \\\"file\\\" in addition to stdout.  This option could be\\n\"\n\"                       useful by wrapper script to detect when x11vnc is ready.\\n\"\n\"\\n\"\n\"-rmflag file           Remove \\\"file\\\" at exit to signal when x11vnc is done.\\n\"\n\"                       The file is created at startup if it does not already\\n\"\n\"                       exist or if \\\"file\\\" is prefixed with \\\"create:\\\".\\n\"\n\"                       If the file is created, the x11vnc PID is placed in\\n\"\n\"                       the file.  Otherwise the files contents is not changed.\\n\"\n\"                       Use prefix \\\"nocreate:\\\" to prevent creation.\\n\"\n\"\\n\"\n\"-rc filename           Use \\\"filename\\\" instead of $HOME/.x11vncrc for rc file.\\n\"\n\"-norc                  Do not process any .x11vncrc file for options.\\n\"\n\"\\n\"\n\"-env VAR=VALUE         Set the environment variable 'VAR' to value 'VALUE'\\n\"\n\"                       at x11vnc startup.  This is a convenience utility to\\n\"\n\"                       avoid shell script wrappers, etc. to set the env. var.\\n\"\n\"                       You may specify as many of these as needed on the\\n\"\n\"                       command line.\\n\"\n\"-prog /path/to/x11vnc  Set the full path to the x11vnc program for cases when\\n\"\n\"                       it cannot be determined from argv[0] (e.g. tcpd/inetd)\\n\"\n\"\\n\"\n\"-h, -help              Print this help text.\\n\"\n\"-?, -opts              Only list the x11vnc options.\\n\"\n\"-V, -version           Print program version and last modification date.\\n\"\n\"-license               Print out license information.  Same as -copying and\\n\"\n\"                       -warranty.\\n\"\n\"\\n\"\n\"-dbg                   Instead of exiting after cleaning up, run a simple\\n\"\n\"                       \\\"debug crash shell\\\" when fatal errors are trapped.\\n\"\n\"\\n\"\n\"-q, -quiet             Be quiet by printing less informational output to\\n\"\n\"                       stderr. (use -noquiet to undo an earlier -quiet.)\\n\"\n\"\\n\"\n\"                       The -quiet option does not eliminate all informational\\n\"\n\"                       output, it only reduces it.  It is ignored in most\\n\"\n\"                       auxiliary usage modes, e.g. -storepasswd.  To eliminate\\n\"\n\"                       all output use: 2>/dev/null 1>&2, etc.\\n\"\n\"\\n\"\n\"-v, -verbose           Print out more information to stderr.\\n\"\n\"\\n\"\n\"-bg                    Go into the background after screen setup.  Messages to\\n\"\n\"                       stderr are lost unless -o logfile is used.  Something\\n\"\n\"                       like this could be useful in a script:\\n\"\n\"                        port=`ssh -t $host \\\"x11vnc -display :0 -bg\\\" | grep PORT`\\n\"\n\"                        port=`echo \\\"$port\\\" | sed -e 's/PORT=//'`\\n\"\n\"                        port=`expr $port - 5900`\\n\"\n\"                        vncviewer $host:$port\\n\"\n\"\\n\"\n\"-modtweak              Option -modtweak automatically tries to adjust the AltGr\\n\"\n\"-nomodtweak            and Shift modifiers for differing language keyboards\\n\"\n\"                       between client and host.  Otherwise, only a single key\\n\"\n\"                       press/release of a Keycode is simulated (i.e. ignoring\\n\"\n\"                       the state of the modifiers: this usually works for\\n\"\n\"                       identical keyboards).  Also useful in resolving cases\\n\"\n\"                       where a Keysym is bound to multiple keys (e.g. \\\"<\\\" + \\\">\\\"\\n\"\n\"                       and \\\",\\\" + \\\"<\\\" keys).  Default: %s\\n\"\n\"\\n\"\n\"                       If you are having trouble with with keys and -xkb or\\n\"\n\"                       -noxkb, and similar things don't help, try -nomodtweak.\\n\"\n\"\\n\"\n\"                       On some HP-UX systems it is been noted that they have\\n\"\n\"                       an odd keymapping where a single keycode will have a\\n\"\n\"                       keysym, e.g. \\\"#\\\", up to three times.  You can check\\n\"\n\"                       via \\\"xmodmap -pk\\\" or the -dk option.  The failure\\n\"\n\"                       is when you try to type \\\"#\\\" it yields \\\"3\\\".  If you\\n\"\n\"                       see this problem try setting the environment variable\\n\"\n\"                       MODTWEAK_LOWEST=1 to see if it helps.\\n\"\n\"\\n\"\n\"-xkb                   When in modtweak mode, use the XKEYBOARD extension (if\\n\"\n\"-noxkb                 the X display supports it) to do the modifier tweaking.\\n\"\n\"                       This is powerful and should be tried if there are still\\n\"\n\"                       keymapping problems when using -modtweak by itself.\\n\"\n\"                       The default is to check whether some common keysyms,\\n\"\n\"                       e.g. !, @, [, are only accessible via -xkb mode and if\\n\"\n\"                       so then automatically enable the mode.  To disable this\\n\"\n\"                       automatic detection use -noxkb.\\n\"\n\"\\n\"\n\"                       When -xkb mode is active you can set these env. vars.\\n\"\n\"                       They apply only when there is ambiguity as to which\\n\"\n\"                       key to choose (i.e the mapping is not one-to-one).\\n\"\n\"                       NOKEYHINTS=1: for up ascii keystrokes do not use score\\n\"\n\"                       hints saved when the key was pressed down. NOANYDOWN=1:\\n\"\n\"                       for up keystrokes do not resort to searching through\\n\"\n\"                       keys that are currently pressed down.  KEYSDOWN=N:\\n\"\n\"                       remember the last N keys press down for tie-breaking\\n\"\n\"                       when an up keystroke comes in.\\n\"\n\"\\n\"\n\"-capslock              When in -modtweak (the default) or -xkb mode,\\n\"\n\"                       if a keysym in the range A-Z comes in check the X\\n\"\n\"                       server to see if the Caps_Lock is set.  If it is do\\n\"\n\"                       not artificially press Shift to generate the keysym.\\n\"\n\"                       This will enable the CapsLock key to behave correctly\\n\"\n\"                       in some circumstances: namely *both* the VNC viewer\\n\"\n\"                       machine and the x11vnc X server are in the CapsLock\\n\"\n\"                       on state.  If one side has CapsLock on and the other\\n\"\n\"                       off and the keyboard is not behaving as you think it\\n\"\n\"                       should you should correct the CapsLock states (hint:\\n\"\n\"                       pressing CapsLock inside and outside of the viewer can\\n\"\n\"                       help toggle them both to the correct state).  However,\\n\"\n\"                       for best results do not use this option, but rather\\n\"\n\"                       *only* enable CapsLock on the VNC viewer side (i.e. by\\n\"\n\"                       pressing CapsLock outside of the viewer window, also\\n\"\n\"                       -skip_lockkeys below).  Also try -nomodtweak for a\\n\"\n\"                       possible workaround.\\n\"\n\"\\n\"\n\"-skip_lockkeys         Have x11vnc ignore all Caps_Lock, Shift_Lock, Num_Lock,\\n\"\n\"-noskip_lockkeys       Scroll_Lock keysyms received from viewers.  The idea is\\n\"\n\"                       you press Caps_Lock on the VNC Viewer side but that does\\n\"\n\"                       not change the lock state in the x11vnc-side X server.\\n\"\n\"                       Nevertheless your capitalized letters come in over\\n\"\n\"                       the wire and are applied correctly to the x11vnc-side\\n\"\n\"                       X server.  Note this mode probably won't do what you\\n\"\n\"                       want in -nomodtweak mode.  Also, a kludge for KP_n\\n\"\n\"                       digits is always done in this mode: they are mapped to\\n\"\n\"                       regular digit keysyms.  See also -capslock above.\\n\"\n\"                       The default is -noskip_lockkeys.\\n\"\n\"\\n\"\n\"-skip_keycodes string  Ignore the comma separated list of decimal keycodes.\\n\"\n\"                       Perhaps these are keycodes not on your keyboard but\\n\"\n\"                       your X server thinks exist.  Currently only applies\\n\"\n\"                       to -xkb mode.  Use this option to help x11vnc in the\\n\"\n\"                       reverse problem it tries to solve: Keysym -> Keycode(s)\\n\"\n\"                       when ambiguities exist (more than one Keycode per\\n\"\n\"                       Keysym).  Run 'xmodmap -pk' to see your keymapping.\\n\"\n\"                       Example: \\\"-skip_keycodes 94,114\\\"\\n\"\n\"-sloppy_keys           Experimental option that tries to correct some\\n\"\n\"                       \\\"sloppy\\\" key behavior.  E.g. if at the viewer you\\n\"\n\"                       press Shift+Key but then release the Shift before\\n\"\n\"                       Key that could give rise to extra unwanted characters\\n\"\n\"                       (usually only between keyboards of different languages).\\n\"\n\"                       Only use this option if you observe problems with\\n\"\n\"                       some keystrokes.\\n\"\n\"-skip_dups             Some VNC viewers send impossible repeated key events,\\n\"\n\"-noskip_dups           e.g. key-down, key-down, key-up, key-up all for the same\\n\"\n\"                       key, or 20 downs in a row for the same modifier key!\\n\"\n\"                       Setting -skip_dups means to skip these duplicates and\\n\"\n\"                       just process the first event. Note: some VNC viewers\\n\"\n\"                       assume they can send down's without the corresponding\\n\"\n\"                       up's and so you should not set this option for\\n\"\n\"                       these viewers (symptom: some keys do not autorepeat)\\n\"\n\"                       Default: %s\\n\"\n\"-add_keysyms           If a Keysym is received from a VNC viewer and that\\n\"\n\"-noadd_keysyms         Keysym does not exist in the X server, then add the\\n\"\n\"                       Keysym to the X server's keyboard mapping on an unused\\n\"\n\"                       key.  Added Keysyms will be removed periodically and\\n\"\n\"                       also when x11vnc exits.  Default: %s\\n\"\n\"-clear_mods            At startup and exit clear the modifier keys by sending\\n\"\n\"                       KeyRelease for each one. The Lock modifiers are skipped.\\n\"\n\"                       Used to clear the state if the display was accidentally\\n\"\n\"                       left with any pressed down.\\n\"\n\"-clear_keys            As -clear_mods, except try to release ANY pressed key.\\n\"\n\"                       Note that this option and -clear_mods can interfere\\n\"\n\"                       with a person typing at the physical keyboard.\\n\"\n\"-clear_all             As -clear_keys, except try to release any CapsLock,\\n\"\n\"                       NumLock, etc. locks as well.\\n\"\n\"\\n\"\n\"-remap string          Read Keysym remappings from file named \\\"string\\\".\\n\"\n\"                       Format is one pair of Keysyms per line (can be name\\n\"\n\"                       or hex value) separated by a space.  If no file named\\n\"\n\"                       \\\"string\\\" exists, it is instead interpreted as this\\n\"\n\"                       form: key1-key2,key3-key4,...  See <X11/keysymdef.h>\\n\"\n\"                       header file for a list of Keysym names, or use xev(1).\\n\"\n\"\\n\"\n\"                       To map a key to a button click, use the fake Keysyms\\n\"\n\"                       \\\"Button1\\\", ..., etc. E.g: \\\"-remap Super_R-Button2\\\"\\n\"\n\"                       (useful for pasting on a laptop)\\n\"\n\"\\n\"\n\"                       I use these if the machine I am viewing from does not\\n\"\n\"                       have a scrollwheel or I don't like using the one it has:\\n\"\n\"\\n\"\n\"                              -remap Super_R-Button4,Menu-Button5\\n\"\n\"                              -remap KP_Add-Button4,KP_Enter-Button5\\n\"\n\"\\n\"\n\"                       the former would be used on a PC, the latter on a\\n\"\n\"                       MacBook.  This way those little used keys can be used\\n\"\n\"                       to generate bigger hops than the Up and Down arrows\\n\"\n\"                       provide.  One can scroll through text or web pages more\\n\"\n\"                       quickly this way (especially if x11vnc scroll detection\\n\"\n\"                       is active.)\\n\"\n\"\\n\"\n\"                       Use Button44, Button12, etc. for multiple clicks.\\n\"\n\"\\n\"\n\"                       To disable a keysym (i.e. make it so it will not be\\n\"\n\"                       injected), remap it to \\\"NoSymbol\\\" or \\\"None\\\".\\n\"\n\"\\n\"\n\"                       Dead keys: \\\"dead\\\" (or silent, mute) keys are keys that\\n\"\n\"                       do not produce a character but must be followed by a 2nd\\n\"\n\"                       keystroke.  This is often used for accenting characters,\\n\"\n\"                       e.g. to put \\\"`\\\" on top of \\\"a\\\" by pressing the dead\\n\"\n\"                       key and then \\\"a\\\".  Note that this interpretation\\n\"\n\"                       is not part of core X11, it is up to the toolkit or\\n\"\n\"                       application to decide how to react to the sequence.\\n\"\n\"                       The X11 names for these keysyms are \\\"dead_grave\\\",\\n\"\n\"                       \\\"dead_acute\\\", etc.  However some VNC viewers send the\\n\"\n\"                       keysyms \\\"grave\\\", \\\"acute\\\" instead thereby disabling\\n\"\n\"                       the accenting.  To work around this -remap can be used.\\n\"\n\"                       For example \\\"-remap grave-dead_grave,acute-dead_acute\\\"\\n\"\n\"                       As a convenience, \\\"-remap DEAD\\\" applies these remaps:\\n\"\n\"\\n\"\n\"                               g     grave-dead_grave\\n\"\n\"                               a     acute-dead_acute\\n\"\n\"                               c     asciicircum-dead_circumflex\\n\"\n\"                               t     asciitilde-dead_tilde\\n\"\n\"                               m     macron-dead_macron\\n\"\n\"                               b     breve-dead_breve\\n\"\n\"                               D     abovedot-dead_abovedot\\n\"\n\"                               d     diaeresis-dead_diaeresis\\n\"\n\"                               o     degree-dead_abovering\\n\"\n\"                               A     doubleacute-dead_doubleacute\\n\"\n\"                               r     caron-dead_caron\\n\"\n\"                               e     cedilla-dead_cedilla\\n\"\n\"\\n\"\n\"                       If you just want a subset use the first letter\\n\"\n\"                       label, e.g. \\\"-remap DEAD=ga\\\" to get the first two.\\n\"\n\"                       Additional remaps may also be supplied via commas,\\n\"\n\"                       e.g.  \\\"-remap DEAD=ga,Super_R-Button2\\\".  Finally,\\n\"\n\"                       \\\"DEAD=missing\\\" means to apply all of the above as\\n\"\n\"                       long as the left hand member is not already in the\\n\"\n\"                       X11 keymap.\\n\"\n\"\\n\"\n\"-norepeat              Option -norepeat disables X server key auto repeat when\\n\"\n\"-repeat                VNC clients are connected and VNC keyboard input is\\n\"\n\"                       not idle for more than 5 minutes.  This works around a\\n\"\n\"                       repeating keystrokes bug (triggered by long processing\\n\"\n\"                       delays between key down and key up client events:\\n\"\n\"                       either from large screen changes or high latency).\\n\"\n\"                       Default: %s\\n\"\n\"\\n\"\n\"                       You can set the env. var. X11VNC_IDLE_TIMEOUT to the\\n\"\n\"                       number of idle seconds you want (5min = 300secs).\\n\"\n\"\\n\"\n\"                       Note: your VNC viewer side will likely do autorepeating,\\n\"\n\"                       so this is no loss unless someone is simultaneously at\\n\"\n\"                       the real X display.\\n\"\n\"\\n\"\n\"                       Use \\\"-norepeat N\\\" to set how many times norepeat will\\n\"\n\"                       be reset if something else (e.g. X session manager)\\n\"\n\"                       undoes it.  The default is 2.  Use a negative value\\n\"\n\"                       for unlimited resets.\\n\"\n\"\\n\"\n\"-nofb                  Ignore video framebuffer: only process keyboard and\\n\"\n\"                       pointer.  Intended for use with Win2VNC and x2vnc\\n\"\n\"                       dual-monitor setups.\\n\"\n\"-nobell                Do not watch for XBell events. (no beeps will be heard)\\n\"\n\"                       Note: XBell monitoring requires the XKEYBOARD extension.\\n\"\n\"-nosel                 Do not manage exchange of X selection/cutbuffer between\\n\"\n\"                       VNC viewers and the X server at all.\\n\"\n\"-noprimary             Do not poll the PRIMARY selection for changes to send\\n\"\n\"                       back to clients.  (PRIMARY is still set on received\\n\"\n\"                       changes, however).\\n\"\n\"-nosetprimary          Do not set the PRIMARY selection for changes received\\n\"\n\"                       from VNC clients.\\n\"\n\"-noclipboard           Do not poll the CLIPBOARD selection for changes to send\\n\"\n\"                       back to clients.  (CLIPBOARD is still set on received\\n\"\n\"                       changes, however).\\n\"\n\"-nosetclipboard        Do not set the CLIPBOARD selection for changes\\n\"\n\"                       received from VNC clients.\\n\"\n\"-seldir string         If direction string is \\\"send\\\", only send the selection\\n\"\n\"                       to viewers, and if it is \\\"recv\\\" only receive it from\\n\"\n\"                       viewers.  To work around apps setting the selection\\n\"\n\"                       too frequently and messing up the other end.  You can\\n\"\n\"                       actually supply a comma separated list of directions,\\n\"\n\"                       including \\\"debug\\\" to turn on debugging output.\\n\"\n\"\\n\"\n\"-cursor [mode]         Sets how the pointer cursor shape (little icon at the\\n\"\n\"-nocursor              mouse pointer) should be handled.  The \\\"mode\\\" string\\n\"\n\"                       is optional and is described below.  The default\\n\"\n\"                       is to show some sort of cursor shape(s).  How this\\n\"\n\"                       is done depends on the VNC viewer and the X server.\\n\"\n\"                       Use -nocursor to disable cursor shapes completely.\\n\"\n\"\\n\"\n\"                       Some VNC viewers support the TightVNC CursorPosUpdates\\n\"\n\"                       and CursorShapeUpdates extensions (cuts down on\\n\"\n\"                       network traffic by not having to send the cursor image\\n\"\n\"                       every time the pointer is moved), in which case these\\n\"\n\"                       extensions are used (see -nocursorshape and -nocursorpos\\n\"\n\"                       below to disable).  For other viewers the cursor shape\\n\"\n\"                       is written directly to the framebuffer every time the\\n\"\n\"                       pointer is moved or changed and gets sent along with\\n\"\n\"                       the other framebuffer updates.  In this case, there\\n\"\n\"                       will be some lag between the vnc viewer pointer and\\n\"\n\"                       the remote cursor position.\\n\"\n\"\\n\"\n\"                       If the X display supports retrieving the cursor shape\\n\"\n\"                       information from the X server, then the default is\\n\"\n\"                       to use that mode.  On Solaris this can be done with\\n\"\n\"                       the SUN_OVL extension using -overlay (see also the\\n\"\n\"                       -overlay_nocursor option).  A similar overlay scheme\\n\"\n\"                       is used on IRIX.  Xorg (e.g. Linux) and recent Solaris\\n\"\n\"                       Xsun servers support the XFIXES extension to retrieve\\n\"\n\"                       the exact cursor shape from the X server.  If XFIXES\\n\"\n\"                       is present it is preferred over Overlay and is used by\\n\"\n\"                       default (see -noxfixes below).  This can be disabled\\n\"\n\"                       with -nocursor, and also some values of the \\\"mode\\\"\\n\"\n\"                       option below.\\n\"\n\"\\n\"\n\"                       Note that under XFIXES cursors with transparency (alpha\\n\"\n\"                       channel) will usually not be exactly represented and one\\n\"\n\"                       may find Overlay preferable.  See also the -alphacut\\n\"\n\"                       and -alphafrac options below as fudge factors to try\\n\"\n\"                       to improve the situation for cursors with transparency\\n\"\n\"                       for a given theme.\\n\"\n\"\\n\"\n\"                       The \\\"mode\\\" string can be used to fine-tune the\\n\"\n\"                       displaying of cursor shapes.  It can be used the\\n\"\n\"                       following ways:\\n\"\n\"\\n\"\n\"                       \\\"-cursor arrow\\\" - just show the standard arrow\\n\"\n\"                       nothing more or nothing less.\\n\"\n\"\\n\"\n\"                       \\\"-cursor none\\\" - same as \\\"-nocursor\\\"\\n\"\n\"\\n\"\n\"                       \\\"-cursor X\\\" - when the cursor appears to be on the\\n\"\n\"                       root window, draw the familiar X shape.  Some desktops\\n\"\n\"                       such as GNOME cover up the root window completely,\\n\"\n\"                       and so this will not work, try \\\"X1\\\", etc, to try to\\n\"\n\"                       shift the tree depth.  On high latency links or slow\\n\"\n\"                       machines there will be a time lag between expected and\\n\"\n\"                       the actual cursor shape.\\n\"\n\"\\n\"\n\"                       \\\"-cursor some\\\" - like \\\"X\\\" but use additional\\n\"\n\"                       heuristics to try to guess if the window should have\\n\"\n\"                       a windowmanager-like resizer cursor or a text input\\n\"\n\"                       I-beam cursor.  This is a complete hack, but may be\\n\"\n\"                       useful in some situations because it provides a little\\n\"\n\"                       more feedback about the cursor shape.\\n\"\n\"\\n\"\n\"                       \\\"-cursor most\\\" - try to show as many cursors as\\n\"\n\"                       possible.  Often this will only be the same as \\\"some\\\"\\n\"\n\"                       unless the display has overlay visuals or XFIXES\\n\"\n\"                       extensions available.  On Solaris and IRIX if XFIXES\\n\"\n\"                       is not available, -overlay mode will be attempted.\\n\"\n\"\\n\"\n\"-cursor_drag           Show cursor shape changes even when the mouse is being\\n\"\n\"                       dragged with a mouse button down.  This is useful if you\\n\"\n\"                       want to be able to see Drag-and-Drop cursor icons, etc.\\n\"\n\"\\n\"\n\"-arrow n               Choose an alternate \\\"arrow\\\" cursor from a set of\\n\"\n\"                       some common ones.  n can be 1 to %d.  Default is: %d\\n\"\n\"                       Ignored when in XFIXES cursor-grabbing mode.\\n\"\n\"\\n\"\n\"-noxfixes              Do not use the XFIXES extension to draw the exact cursor\\n\"\n\"                       shape even if it is available.\\n\"\n\"\\n\"\n\"                       Note: To work around a crash in Xorg 1.5 and later\\n\"\n\"                       some people needed to use -noxfixes.  The Xorg crash\\n\"\n\"                       occurred right after a Display Manager (e.g. GDM) login.\\n\"\n\"                       Starting with x11vnc 0.9.9 it tries to automatically\\n\"\n\"                       avoid using XFIXES until it is sure a window manager\\n\"\n\"                       is running.  See the -reopen option for more info and\\n\"\n\"                       how to use X11VNC_AVOID_WINDOWS=never to disable it.\\n\"\n\"\\n\"\n\"-alphacut n            When using the XFIXES extension for the cursor shape,\\n\"\n\"                       cursors with transparency will not usually be displayed\\n\"\n\"                       exactly (but opaque ones will).  This option sets n as\\n\"\n\"                       a cutoff for cursors that have transparency (\\\"alpha\\n\"\n\"                       channel\\\" with values ranging from 0 to 255) Any cursor\\n\"\n\"                       pixel with alpha value less than n becomes completely\\n\"\n\"                       transparent.  Otherwise the pixel is completely opaque.\\n\"\n\"                       Default %d\\n\"\n\"\\n\"\n\"-alphafrac fraction    With the threshold in -alphacut some cursors will become\\n\"\n\"                       almost completely transparent because their alpha values\\n\"\n\"                       are not high enough.  For those cursors adjust the\\n\"\n\"                       alpha threshold until fraction of the non-zero alpha\\n\"\n\"                       channel pixels become opaque.  Default %.2f\\n\"\n\"-alpharemove           By default, XFIXES cursors pixels with transparency have\\n\"\n\"                       the alpha factor multiplied into the RGB color values\\n\"\n\"                       (i.e. that corresponding to blending the cursor with a\\n\"\n\"                       black background).  Specify this option to remove the\\n\"\n\"                       alpha factor. (useful for light colored semi-transparent\\n\"\n\"                       cursors).\\n\"\n\"-noalphablend          In XFIXES mode do not send cursor alpha channel data\\n\"\n\"                       to LibVNCServer.  The default is to send it.  The\\n\"\n\"                       alphablend effect will only be visible in -nocursorshape\\n\"\n\"                       mode or for clients with cursorshapeupdates turned\\n\"\n\"                       off. (However there is a hack for 32bpp with depth 24,\\n\"\n\"                       it uses the extra 8 bits to store cursor transparency\\n\"\n\"                       for use with a hacked vncviewer that applies the\\n\"\n\"                       transparency locally.  See the FAQ for more info).\\n\"\n\"\\n\"\n\"-nocursorshape         Do not use the TightVNC CursorShapeUpdates extension\\n\"\n\"                       even if clients support it.  See -cursor above.\\n\"\n\"-cursorpos             Option -cursorpos enables sending the X cursor position\\n\"\n\"-nocursorpos           back to all vnc clients that support the TightVNC\\n\"\n\"                       CursorPosUpdates extension.  Other clients will be able\\n\"\n\"                       to see the pointer motions. Default: %s\\n\"\n\"-xwarppointer          Move the pointer with XWarpPointer(3X) instead of\\n\"\n\"-noxwarppointer        the XTEST extension.  Use this as a workaround\\n\"\n\"                       if the pointer motion behaves incorrectly, e.g.\\n\"\n\"                       on touchscreens or other non-standard setups.\\n\"\n\"\\n\"\n\"                       It is also sometimes needed on XINERAMA displays and is\\n\"\n\"                       enabled by default if XINERAMA is found to be active.\\n\"\n\"                       To prevent this, use -noxwarppointer.\\n\"\n\"\\n\"\n\"-always_inject         Even if there is no displacement (dx = dy = 0) for a\\n\"\n\"                       VNC mouse event force the pointer to the indicated x,y\\n\"\n\"                       position anyway.  Recent (2009) gui toolkits (gnome)\\n\"\n\"                       have problems with x11vnc's original mouse input\\n\"\n\"                       injection method.  So x11vnc's mouse input injection\\n\"\n\"                       method has been modified.  To regain the OLD behavior\\n\"\n\"                       use this option: -always_inject.  Then x11vnc will\\n\"\n\"                       always force positioning the mouse to the x,y position\\n\"\n\"                       even if that position has not changed since the previous\\n\"\n\"                       VNC input event.\\n\"\n\"\\n\"\n\"                       The first place this problem was noticed was in gnome\\n\"\n\"                       terminal: if you pressed and released mouse button 3, a\\n\"\n\"                       menu was posted and then its first element 'New Terminal\\n\"\n\"                       Window' was activated.  This was because x11vnc injected\\n\"\n\"                       the mouse position twice: once on ButtonPress and again\\n\"\n\"                       on ButtonRelease.  The toolkit interpreted the 2nd one\\n\"\n\"                       as mouse motion even though the mouse hadn't moved.\\n\"\n\"                       So now by default x11vnc tries to avoid injecting the\\n\"\n\"                       2nd one.\\n\"\n\"\\n\"\n\"                       Note that with the new default x11vnc will be oblivious\\n\"\n\"                       to applications moving the pointer (warping) or the\\n\"\n\"                       user at the physical display moving it.  So it might,\\n\"\n\"                       e.g., inject ButtonRelease at the wrong position.\\n\"\n\"                       If this (or similar scenarios) causes problems in your\\n\"\n\"                       environment, specify -always_inject for the old method.\\n\"\n\"\\n\"\n\"-buttonmap string      String to remap mouse buttons.  Format: IJK-LMN, this\\n\"\n\"                       maps buttons I -> L, etc., e.g.  -buttonmap 13-31\\n\"\n\"\\n\"\n\"                       Button presses can also be mapped to keystrokes: replace\\n\"\n\"                       a button digit on the right of the dash with :<sym>:\\n\"\n\"                       or :<sym1>+<sym2>: etc. for multiple keys. For example,\\n\"\n\"                       if the viewing machine has a mouse-wheel (buttons 4 5)\\n\"\n\"                       but the x11vnc side does not, these will do scrolls:\\n\"\n\"                              -buttonmap 12345-123:Prior::Next:\\n\"\n\"                              -buttonmap 12345-123:Up+Up+Up::Down+Down+Down:\\n\"\n\"\\n\"\n\"                       See <X11/keysymdef.h> header file for a list of Keysyms,\\n\"\n\"                       or use the xev(1) program.  Note: mapping of button\\n\"\n\"                       clicks to Keysyms may not work if -modtweak or -xkb is\\n\"\n\"                       needed for the Keysym.\\n\"\n\"\\n\"\n\"                       If you include a modifier like \\\"Shift_L\\\" the\\n\"\n\"                       modifier's up/down state is toggled, e.g. to send\\n\"\n\"                       \\\"The\\\" use :Shift_L+t+Shift_L+h+e: (the 1st one is\\n\"\n\"                       shift down and the 2nd one is shift up). (note: the\\n\"\n\"                       initial state of the modifier is ignored and not reset)\\n\"\n\"                       To include button events use \\\"Button1\\\", ... etc.\\n\"\n\"\\n\"\n\"                       -buttonmap currently does not work on MacOSX console\\n\"\n\"                       or in -rawfb mode.\\n\"\n\"\\n\"\n\"                       Workaround: use -buttonmap IJ...-LM...=n to limit the\\n\"\n\"                       number of mouse buttons to n, e.g. 123-123=3.  This will\\n\"\n\"                       prevent x11vnc from crashing if the X server reports\\n\"\n\"                       there are 5 buttons (4/5 scroll wheel), but there are\\n\"\n\"                       only really 3.\\n\"\n\"\\n\"\n\"-nodragging            Do not update the display during mouse dragging events\\n\"\n\"                       (mouse button held down).  Greatly improves response on\\n\"\n\"                       slow setups, but you lose all visual feedback for drags,\\n\"\n\"                       text selection, and some menu traversals.  It overrides\\n\"\n\"                       any -pointer_mode setting.\\n\"\n\"\\n\"\n#ifndef NO_NCACHE\n\"-ncache n              Client-side caching scheme.  Framebuffer memory \\\"n\\\"\\n\"\n\"                       (an integer) times that of the full display is allocated\\n\"\n\"                       below the actual framebuffer to cache screen contents\\n\"\n\"                       for rapid retrieval.  So a W x H frambuffer is expanded\\n\"\n\"                       to a W x (n+1)*H one.  Use 0 to disable.\\n\"\n\"\\n\"\n\"                       The \\\"n\\\" is actually optional, the default is 10.\\n\"\n\"\\n\"\n\"                       For this and the other -ncache* options below you can\\n\"\n\"                       abbreviate \\\"-ncache\\\" with \\\"-nc\\\".  Also, \\\"-nonc\\\"\\n\"\n\"                       is the same as \\\"-ncache 0\\\"\\n\"\n\"\\n\"\n\"                       This is an experimental option, currently implemented in\\n\"\n\"                       an awkward way in that in the VNC Viewer you can see the\\n\"\n\"                       pixel cache contents if you scroll down, etc.  So you\\n\"\n\"                       will have to set things up so you can't see that region.\\n\"\n\"                       If this method is successful, the changes required for\\n\"\n\"                       clients to do this less awkwardly will be investigated.\\n\"\n\"\\n\"\n\"                       The SSVNC viewer does a good job at automatically hiding\\n\"\n\"                       the pixel cache region.  Or use SSVNC's -ycrop option\\n\"\n\"                       to explicitly hide the region.\\n\"\n\"\\n\"\n\"                       Note that this mode consumes a huge amount of memory,\\n\"\n\"                       both on the x11vnc server side and on the VNC Viewer\\n\"\n\"                       side.  If n=2 then the amount of RAM used is roughly\\n\"\n\"                       tripled for both x11vnc and the VNC Viewer.  As a rule\\n\"\n\"                       of thumb, note that 1280x1024 at depth 24 is about 5MB\\n\"\n\"                       of pixel data.\\n\"\n\"\\n\"\n\"                       For reasonable response when cycling through 4 to 6\\n\"\n\"                       large (e.g. web browser) windows a value n of 6 to 12\\n\"\n\"                       is recommended. (that's right: ~10X more memory...)\\n\"\n\"\\n\"\n\"                       Because of the way window backingstore and saveunders\\n\"\n\"                       are implemented, n must be even.  It will be incremented\\n\"\n\"                       by 1 if it is not.\\n\"\n\"\\n\"\n\"                       This mode also works for native MacOS X, but may not\\n\"\n\"                       be as effective as the X version.  This is due to a\\n\"\n\"                       number of things, one is the drop-shadow compositing\\n\"\n\"                       that leaves extra areas that need to be repaired (see\\n\"\n\"                       -ncache_pad).  Another is the window iconification\\n\"\n\"                       animations need to be avoided (see -macicontime).\\n\"\n\"                       It appears the that the 'Scale' animation mode gives\\n\"\n\"                       better results than the 'Genie' one.  Also, window event\\n\"\n\"                       detection not as accurate as the X version.\\n\"\n\"\\n\"\n\"-ncache_cr             In -ncache mode, try to do copyrect opaque window\\n\"\n\"                       moves/drags instead of wireframes (this can induce\\n\"\n\"                       painting errors).  The wireframe will still be used when\\n\"\n\"                       moving a window whose save-unders has not yet been set\\n\"\n\"                       or has been invalidated.\\n\"\n\"\\n\"\n\"                       Some VNC Viewers provide better response than others\\n\"\n\"                       with this option.  On Unix, realvnc viewer gives\\n\"\n\"                       smoother drags than tightvnc viewer.  Response may also\\n\"\n\"                       be choppy if the server side machine is too slow.\\n\"\n\"\\n\"\n\"                       Sometimes on very slow modem connections, this actually\\n\"\n\"                       gives an improvement because no pixel data at all\\n\"\n\"                       (not even the box animation) is sent during the drag.\\n\"\n\"\\n\"\n\"-ncache_no_moveraise   In -ncache mode, do not assume that moving a window\\n\"\n\"                       will cause the window manager to raise it to the top\\n\"\n\"                       of the stack.  The default is to assume it does, and\\n\"\n\"                       so at the beginning of any wireframe, etc, window moves\\n\"\n\"                       the window will be pushed to top in the VNC viewer.\\n\"\n\"\\n\"\n\"-ncache_no_dtchange    In -ncache mode, do not try to guess when the desktop\\n\"\n\"                       (viewport) changes to another one (i.e. another\\n\"\n\"                       workarea).  The default is to try to guess and when\\n\"\n\"                       detected try to make the transition more smoothly.\\n\"\n\"\\n\"\n\"-ncache_no_rootpixmap  In -ncache mode, do not try to snapshot the desktop\\n\"\n\"                       background to use in guessing or reconstructing window\\n\"\n\"                       save-unders.\\n\"\n\"\\n\"\n\"-ncache_keep_anims     In -ncache mode, do not try to disable window\\n\"\n\"                       manager animations and other effects (that usually\\n\"\n\"                       degrade ncache performance or cause painting errors).\\n\"\n\"                       The default is to try to disable them on KDE (but not\\n\"\n\"                       GNOME) when VNC clients are connected.\\n\"\n\"\\n\"\n\"                       For other window managers or desktops that provide\\n\"\n\"                       animations, effects, compositing, translucency,\\n\"\n\"                       etc. that interfere with the -ncache method you will\\n\"\n\"                       have to disable them manually.\\n\"\n\"\\n\"\n\"-ncache_old_wm         In -ncache mode, enable some heuristics for old style\\n\"\n\"                       window managers such as fvwm and twm.\\n\"\n\"\\n\"\n\"-ncache_pad n          In -ncache mode, pad each window with n pixels for the\\n\"\n\"                       caching rectangles.  This can be used to try to improve\\n\"\n\"                       the situation with dropshadows or other compositing\\n\"\n\"                       (e.g. MacOS X window manager), although it could make\\n\"\n\"                       things worse.  The default is 0 on Unix and 24 on\\n\"\n\"                       MacOS X.\\n\"\n\"-debug_ncache          Turn on debugging and profiling output under -ncache.\\n\"\n\"\\n\"\n#endif\n\"-wireframe [str]       Try to detect window moves or resizes when a mouse\\n\"\n\"-nowireframe           button is held down and show a wireframe instead of\\n\"\n\"                       the full opaque window.  This is based completely on\\n\"\n\"                       heuristics and may not always work: it depends on your\\n\"\n\"                       window manager and even how you move things around.\\n\"\n\"                       See -pointer_mode below for discussion of the \\\"bogging\\n\"\n\"                       down\\\" problem this tries to avoid.\\n\"\n\"                       Default: %s\\n\"\n\"\\n\"\n\"                       Shorter aliases:  -wf [str]  and -nowf\\n\"\n\"\\n\"\n\"                       The value \\\"str\\\" is optional and, of course, is\\n\"\n\"                       packed with many tunable parameters for this scheme:\\n\"\n\"\\n\"\n\"                       Format: shade,linewidth,percent,T+B+L+R,mod,t1+t2+t3+t4\\n\"\n\"                       Default: %s\\n\"\n\"\\n\"\n\"                       If you leave nothing between commas: \\\",,\\\" the default\\n\"\n\"                       value is used.  If you don't specify enough commas,\\n\"\n\"                       the trailing parameters are set to their defaults.\\n\"\n\"\\n\"\n\"                       \\\"shade\\\" indicate the \\\"color\\\" for the wireframe,\\n\"\n\"                       usually a greyscale: 0-255, however for 16 and 32bpp you\\n\"\n\"                       can specify an rgb.txt X color (e.g. \\\"dodgerblue\\\") or\\n\"\n\"                       a value > 255 is treated as RGB (e.g. red is 0xff0000).\\n\"\n\"                       \\\"linewidth\\\" sets the width of the wireframe in pixels.\\n\"\n\"                       \\\"percent\\\" indicates to not apply the wireframe scheme\\n\"\n\"                       to windows with area less than this percent of the\\n\"\n\"                       full screen.\\n\"\n\"\\n\"\n\"                       \\\"T+B+L+R\\\" indicates four integers for how close in\\n\"\n\"                       pixels the pointer has to be from the Top, Bottom, Left,\\n\"\n\"                       or Right edges of the window to consider wireframing.\\n\"\n\"                       This is a speedup to quickly exclude a window from being\\n\"\n\"                       wireframed: set them all to zero to not try the speedup\\n\"\n\"                       (scrolling and selecting text will likely be slower).\\n\"\n\"\\n\"\n\"                       \\\"mod\\\" specifies if a button down event in the\\n\"\n\"                       interior of the window with a modifier key (Alt, Shift,\\n\"\n\"                       etc.) down should indicate a wireframe opportunity.\\n\"\n\"                       It can be \\\"0\\\" or \\\"none\\\" to skip it, \\\"1\\\" or \\\"all\\\"\\n\"\n\"                       to apply it to any modifier, or \\\"Shift\\\", \\\"Alt\\\",\\n\"\n\"                       \\\"Control\\\", \\\"Meta\\\", \\\"Super\\\", or \\\"Hyper\\\" to only\\n\"\n\"                       apply for that type of modifier key.\\n\"\n\"\\n\"\n\"                       \\\"t1+t2+t3+t4\\\" specify four floating point times in\\n\"\n\"                       seconds: t1 is how long to wait for the pointer to move,\\n\"\n\"                       t2 is how long to wait for the window to start moving\\n\"\n\"                       or being resized (for some window managers this can be\\n\"\n\"                       rather long), t3 is how long to keep a wireframe moving\\n\"\n\"                       before repainting the window. t4 is the minimum time\\n\"\n\"                       between sending wireframe \\\"animations\\\".  If a slow\\n\"\n\"                       link is detected, these values may be automatically\\n\"\n\"                       changed to something better for a slow link.\\n\"\n\"\\n\"\n\"-nowireframelocal      By default, mouse motion and button presses of a\\n\"\n\"                       user sitting at the LOCAL display are monitored for\\n\"\n\"                       wireframing opportunities (so that the changes will be\\n\"\n\"                       sent efficiently to the VNC clients).  Use this option\\n\"\n\"                       to disable this behavior.\\n\"\n\"\\n\"\n\"-wirecopyrect mode     Since the -wireframe mechanism evidently tracks moving\\n\"\n\"-nowirecopyrect        windows accurately, a speedup can be obtained by\\n\"\n\"                       telling the VNC viewers to locally copy the translated\\n\"\n\"                       window region.  This is the VNC CopyRect encoding:\\n\"\n\"                       the framebuffer update doesn't need to send the actual\\n\"\n\"                       new image data.\\n\"\n\"\\n\"\n\"                       Shorter aliases:  -wcr [mode]  and -nowcr\\n\"\n\"\\n\"\n\"                       \\\"mode\\\" can be \\\"never\\\" (same as -nowirecopyrect)\\n\"\n\"                       to never try the copyrect, \\\"top\\\" means only do it if\\n\"\n\"                       the window was not covered by any other windows, and\\n\"\n\"                       \\\"always\\\" means to translate the originally unobscured\\n\"\n\"                       region (this may look odd as the remaining pieces come\\n\"\n\"                       in, but helps on a slow link).  Default: \\\"%s\\\"\\n\"\n\"\\n\"\n\"                       Note: there can be painting errors or slow response\\n\"\n\"                       when using -scale so you may want to disable CopyRect\\n\"\n\"                       in this case \\\"-wirecopyrect never\\\" on the command\\n\"\n\"                       line or by remote-control.  Or you can also use the\\n\"\n\"                       \\\"-scale xxx:nocr\\\" scale option.\\n\"\n\"\\n\"\n\"-debug_wireframe       Turn on debugging info printout for the wireframe\\n\"\n\"                       heuristics.  \\\"-dwf\\\" is an alias.  Specify multiple\\n\"\n\"                       times for more output.\\n\"\n\"\\n\"\n\"-scrollcopyrect mode   Like -wirecopyrect, but use heuristics to try to guess\\n\"\n\"-noscrollcopyrect      if a window has scrolled its contents (either vertically\\n\"\n\"                       or horizontally).  This requires the RECORD X extension\\n\"\n\"                       to \\\"snoop\\\" on X applications (currently for certain\\n\"\n\"                       XCopyArea and XConfigureWindow X protocol requests).\\n\"\n\"                       Examples: Hitting <Return> in a terminal window when the\\n\"\n\"                       cursor was at the bottom, the text scrolls up one line.\\n\"\n\"                       Hitting <Down> arrow in a web browser window, the web\\n\"\n\"                       page scrolls up a small amount.  Or scrolling with a\\n\"\n\"                       scrollbar or mouse wheel.\\n\"\n\"\\n\"\n\"                       Shorter aliases:  -scr [mode]  and -noscr\\n\"\n\"\\n\"\n\"                       This scheme will not always detect scrolls, but when\\n\"\n\"                       it does there is a nice speedup from using the VNC\\n\"\n\"                       CopyRect encoding (see -wirecopyrect).  The speedup\\n\"\n\"                       is both in reduced network traffic and reduced X\\n\"\n\"                       framebuffer polling/copying.  On the other hand, it may\\n\"\n\"                       induce undesired transients (e.g. a terminal cursor\\n\"\n\"                       being scrolled up when it should not be) or other\\n\"\n\"                       painting errors (window tearing, bunching-up, etc).\\n\"\n\"                       These are automatically repaired in a short period\\n\"\n\"                       of time.  If this is unacceptable disable the feature\\n\"\n\"                       with -noscrollcopyrect.\\n\"\n\"\\n\"\n\"                       Screen clearing kludges:  for testing at least, there\\n\"\n\"                       are some \\\"magic key sequences\\\" (must be done in less\\n\"\n\"                       than 1 second) to aid repairing painting errors that\\n\"\n\"                       may be seen when using this mode:\\n\"\n\"\\n\"\n\"                       3 Alt_L's   in a row: resend whole screen,\\n\"\n\"                       4 Alt_L's   in a row: reread and resend whole screen,\\n\"\n\"                       3 Super_L's in a row: mark whole screen for polling,\\n\"\n\"                       4 Super_L's in a row: reset RECORD context,\\n\"\n\"                       5 Super_L's in a row: try to push a black screen\\n\"\n\"\\n\"\n\"                       note: Alt_L is the Left \\\"Alt\\\" key (a single key)\\n\"\n\"                       Super_L is the Left \\\"Super\\\" key (Windows flag).\\n\"\n\"                       Both of these are modifier keys, and so should not\\n\"\n\"                       generate characters when pressed by themselves.  Also,\\n\"\n\"                       your VNC viewer may have its own refresh hot-key\\n\"\n\"                       or button.\\n\"\n\"\\n\"\n\"                       \\\"mode\\\" can be \\\"never\\\" (same as -noscrollcopyrect)\\n\"\n\"                       to never try the copyrect, \\\"keys\\\" means to try it\\n\"\n\"                       in response to keystrokes only, \\\"mouse\\\" means to\\n\"\n\"                       try it in response to mouse events only, \\\"always\\\"\\n\"\n\"                       means to do both. Default: \\\"%s\\\"\\n\"\n\"\\n\"\n\"                       Note: there can be painting errors or slow response\\n\"\n\"                       when using -scale so you may want to disable CopyRect\\n\"\n\"                       in this case \\\"-scrollcopyrect never\\\" on the command\\n\"\n\"                       line or by remote-control.  Or you can also use the\\n\"\n\"                       \\\"-scale xxx:nocr\\\" scale option.\\n\"\n\"\\n\"\n\"-scr_area n            Set the minimum area in pixels for a rectangle\\n\"\n\"                       to be considered for the -scrollcopyrect detection\\n\"\n\"                       scheme.  This is to avoid wasting the effort on small\\n\"\n\"                       rectangles that would be quickly updated the normal way.\\n\"\n\"                       E.g. suppose an app updated the position of its skinny\\n\"\n\"                       scrollbar first and then shifted the large panel\\n\"\n\"                       it controlled.  We want to be sure to skip the small\\n\"\n\"                       scrollbar and get the large panel. Default: %d\\n\"\n\"\\n\"\n\"-scr_skip list         Skip scroll detection for applications matching\\n\"\n\"                       the comma separated list of strings in \\\"list\\\".\\n\"\n\"                       Some applications implement their scrolling in\\n\"\n\"                       strange ways where the XCopyArea, etc, also applies\\n\"\n\"                       to invisible portions of the window: if we CopyRect\\n\"\n\"                       those areas it looks awful during the scroll and\\n\"\n\"                       there may be painting errors left after the scroll.\\n\"\n\"                       Soffice.bin is the worst known offender.\\n\"\n\"\\n\"\n\"                       Use \\\"##\\\" to denote the start of the application class\\n\"\n\"                       (e.g. \\\"##XTerm\\\") and \\\"++\\\" to denote the start\\n\"\n\"                       of the application instance name (e.g. \\\"++xterm\\\").\\n\"\n\"                       The string your list is matched against is of the form\\n\"\n\"                       \\\"^^WM_NAME##Class++Instance<same-for-any-subwindows>\\\"\\n\"\n\"                       The \\\"xlsclients -la\\\" command will provide this info.\\n\"\n\"\\n\"\n\"                       If a pattern is prefixed with \\\"KEY:\\\" it only applies\\n\"\n\"                       to Keystroke generated scrolls (e.g. Up arrow).  If it\\n\"\n\"                       is prefixed with \\\"MOUSE:\\\" it only applies to Mouse\\n\"\n\"                       induced scrolls (e.g. dragging on a scrollbar).\\n\"\n\"                       Default: %s\\n\"\n\"\\n\"\n\"-scr_inc list          Opposite of -scr_skip: this list is consulted first\\n\"\n\"                       and if there is a match the window will be monitored\\n\"\n\"                       via RECORD for scrolls irrespective of -scr_skip.\\n\"\n\"                       Use -scr_skip '*' to skip anything that does not match\\n\"\n\"                       your -scr_inc.  Use -scr_inc '*' to include everything.\\n\"\n\"\\n\"\n\"-scr_keys list         For keystroke scroll detection, only apply the RECORD\\n\"\n\"                       heuristics to the comma separated list of keysyms in\\n\"\n\"                       \\\"list\\\".  You may find the RECORD overhead for every\\n\"\n\"                       one of your keystrokes disrupts typing too much, but you\\n\"\n\"                       don't want to turn it off completely with \\\"-scr mouse\\\"\\n\"\n\"                       and -scr_parms does not work or is too confusing.\\n\"\n\"\\n\"\n\"                       The listed keysyms can be numeric or the keysym\\n\"\n\"                       names in the <X11/keysymdef.h> header file or from the\\n\"\n\"                       xev(1) program.  Example: \\\"-scr_keys Up,Down,Return\\\".\\n\"\n\"                       One probably wants to have application specific lists\\n\"\n\"                       (e.g. for terminals, etc) but that is too icky to think\\n\"\n\"                       about for now...\\n\"\n\"\\n\"\n\"                       If \\\"list\\\" begins with the \\\"-\\\" character the list\\n\"\n\"                       is taken as an exclude list: all keysyms except those\\n\"\n\"                       list will be considered.  The special string \\\"builtin\\\"\\n\"\n\"                       expands to an internal list of keysyms that are likely\\n\"\n\"                       to cause scrolls.  BTW, by default modifier keys,\\n\"\n\"                       Shift_L, Control_R, etc, are skipped since they almost\\n\"\n\"                       never induce scrolling by themselves.\\n\"\n\"\\n\"\n\"-scr_term list         Yet another cosmetic kludge.  Apply shell/terminal\\n\"\n\"                       heuristics to applications matching comma separated\\n\"\n\"                       list (same as for -scr_skip/-scr_inc).  For example an\\n\"\n\"                       annoying transient under scroll detection is if you\\n\"\n\"                       hit Enter in a terminal shell with full text window,\\n\"\n\"                       the solid text cursor block will be scrolled up.\\n\"\n\"                       So for a short time there are two (or more) block\\n\"\n\"                       cursors on the screen.  There are similar scenarios,\\n\"\n\"                       (e.g. an output line is duplicated).\\n\"\n\"\\n\"\n\"                       These transients are induced by the approximation of\\n\"\n\"                       scroll detection (e.g. it detects the scroll, but not\\n\"\n\"                       the fact that the block cursor was cleared just before\\n\"\n\"                       the scroll).  In nearly all cases these transient errors\\n\"\n\"                       are repaired when the true X framebuffer is consulted\\n\"\n\"                       by the normal polling.  But they are distracting, so\\n\"\n\"                       what this option provides is extra \\\"padding\\\" near the\\n\"\n\"                       bottom of the terminal window: a few extra lines near\\n\"\n\"                       the bottom will not be scrolled, but rather updated\\n\"\n\"                       from the actual X framebuffer.  This usually reduces\\n\"\n\"                       the annoying artifacts.  Use \\\"none\\\" to disable.\\n\"\n\"                       Default: \\\"%s\\\"\\n\"\n\"\\n\"\n\"-scr_keyrepeat lo-hi   If a key is held down (or otherwise repeats rapidly) and\\n\"\n\"                       this induces a rapid sequence of scrolls (e.g. holding\\n\"\n\"                       down an Arrow key) the \\\"scrollcopyrect\\\" detection\\n\"\n\"                       and overhead may not be able to keep up.  A time per\\n\"\n\"                       single scroll estimate is performed and if that estimate\\n\"\n\"                       predicts a sustainable scrollrate of keys per second\\n\"\n\"                       between \\\"lo\\\" and \\\"hi\\\" then repeated keys will be\\n\"\n\"                       DISCARDED to maintain the scrollrate. For example your\\n\"\n\"                       key autorepeat may be 25 keys/sec, but for a large\\n\"\n\"                       window or slow link only 8 scrolls per second can be\\n\"\n\"                       sustained, then roughly 2 out of every 3 repeated keys\\n\"\n\"                       will be discarded during this period. Default: \\\"%s\\\"\\n\"\n\"\\n\"\n\"-scr_parms string      Set various parameters for the scrollcopyrect mode.\\n\"\n\"                       The format is similar to that for -wireframe and packed\\n\"\n\"                       with lots of parameters:\\n\"\n\"\\n\"\n\"                       Format: T+B+L+R,t1+t2+t3,s1+s2+s3+s4+s5\\n\"\n\"                       Default: %s\\n\"\n\"\\n\"\n\"                       If you leave nothing between commas: \\\",,\\\" the default\\n\"\n\"                       value is used.  If you don't specify enough commas,\\n\"\n\"                       the trailing parameters are set to their defaults.\\n\"\n\"\\n\"\n\"                       \\\"T+B+L+R\\\" indicates four integers for how close in\\n\"\n\"                       pixels the pointer has to be from the Top, Bottom, Left,\\n\"\n\"                       or Right edges of the window to consider scrollcopyrect.\\n\"\n\"                       If -wireframe overlaps it takes precedence.  This is a\\n\"\n\"                       speedup to quickly exclude a window from being watched\\n\"\n\"                       for scrollcopyrect: set them all to zero to not try\\n\"\n\"                       the speedup (things like selecting text will likely\\n\"\n\"                       be slower).\\n\"\n\"\\n\"\n\"                       \\\"t1+t2+t3\\\" specify three floating point times in\\n\"\n\"                       seconds that apply to scrollcopyrect detection with\\n\"\n\"                       *Keystroke* input: t1 is how long to wait after a key\\n\"\n\"                       is pressed for the first scroll, t2 is how long to keep\\n\"\n\"                       looking after a Keystroke scroll for more scrolls.\\n\"\n\"                       t3 is how frequently to try to update surrounding\\n\"\n\"                       scrollbars outside of the scrolling area (0.0 to\\n\"\n\"                       disable)\\n\"\n\"\\n\"\n\"                       \\\"s1+s2+s3+s4+s5\\\" specify five floating point times\\n\"\n\"                       in seconds that apply to scrollcopyrect detection with\\n\"\n\"                       *Mouse* input: s1 is how long to wait after a mouse\\n\"\n\"                       button is pressed for the first scroll, s2 is how long\\n\"\n\"                       to keep waiting for additional scrolls after the first\\n\"\n\"                       Mouse scroll was detected.  s3 is how frequently to\\n\"\n\"                       try to update surrounding scrollbars outside of the\\n\"\n\"                       scrolling area (0.0 to disable).  s4 is how long to\\n\"\n\"                       buffer pointer motion (to try to get fewer, bigger\\n\"\n\"                       mouse scrolls). s5 is the maximum time to spend just\\n\"\n\"                       updating the scroll window without updating the rest\\n\"\n\"                       of the screen.\\n\"\n\"\\n\"\n\"-fixscreen string      Periodically \\\"repair\\\" the screen based on settings\\n\"\n\"                       in \\\"string\\\".  Hopefully you won't need this option,\\n\"\n\"                       it is intended for cases when the -scrollcopyrect or\\n\"\n\"                       -wirecopyrect features leave too many painting errors,\\n\"\n\"                       but it can be used for any scenario.  This option\\n\"\n\"                       periodically performs costly operations and so\\n\"\n\"                       interactive response may be reduced when it is on.\\n\"\n\"                       You can use 3 Alt_L's (the Left \\\"Alt\\\" key) taps in\\n\"\n\"                       a row (as described under -scrollcopyrect) instead to\\n\"\n\"                       manually request a screen repaint when it is needed.\\n\"\n\"\\n\"\n\"                       \\\"string\\\" is a comma separated list of one or more of\\n\"\n\"                       the following: \\\"V=t\\\", \\\"C=t\\\", \\\"X=t\\\", and \\\"8=t\\\".\\n\"\n\"                       In these \\\"t\\\" stands for a time in seconds (it is\\n\"\n\"                       a floating point even though one should usually use\\n\"\n\"                       values > 2 to avoid wasting resources).  V sets how\\n\"\n\"                       frequently the entire screen should be sent to viewers\\n\"\n\"                       (it is like the 3 Alt_L's).  C sets how long to wait\\n\"\n\"                       after a CopyRect to repaint the full screen.  X sets\\n\"\n\"                       how frequently to reread the full X11 framebuffer from\\n\"\n\"                       the X server and push it out to connected viewers.\\n\"\n\"                       Use of X should be rare, please report a bug if you\\n\"\n\"                       find you need it. 8= applies only for -8to24 mode: it\\n\"\n\"                       sets how often the non-default visual regions of the\\n\"\n\"                       screen (e.g. 8bpp windows) are refreshed.  Examples:\\n\"\n\"                       -fixscreen V=10 -fixscreen C=10\\n\"\n\"\\n\"\n\"-debug_scroll          Turn on debugging info printout for the scroll\\n\"\n\"                       heuristics.  \\\"-ds\\\" is an alias.  Specify it multiple\\n\"\n\"                       times for more output.\\n\"\n\"\\n\"\n\"-noxrecord             Disable any use of the RECORD extension.  This is\\n\"\n\"                       currently used by the -scrollcopyrect scheme and to\\n\"\n\"                       monitor X server grabs.\\n\"\n\"\\n\"\n\"-grab_buster           Some of the use of the RECORD extension can leave a\\n\"\n\"-nograb_buster         tiny window for XGrabServer deadlock.  This is only if\\n\"\n\"                       the whole-server grabbing application expects mouse or\\n\"\n\"                       keyboard input before releasing the grab.  It is usually\\n\"\n\"                       a window manager that does this.  x11vnc takes care to\\n\"\n\"                       avoid the problem, but if caught x11vnc will freeze.\\n\"\n\"                       Without -grab_buster, the only solution is to go the\\n\"\n\"                       physical display and give it some input to satisfy the\\n\"\n\"                       grabbing app.  Or manually kill and restart the window\\n\"\n\"                       manager if that is feasible.  With -grab_buster, x11vnc\\n\"\n\"                       will fork a helper thread and if x11vnc appears to be\\n\"\n\"                       stuck in a grab after a period of time (20-30 sec) then\\n\"\n\"                       it will inject some user input: button clicks, Escape,\\n\"\n\"                       mouse motion, etc to try to break the grab.  If you\\n\"\n\"                       experience a lot of grab deadlock, please report a bug.\\n\"\n\"\\n\"\n\"-debug_grabs           Turn on debugging info printout with respect to\\n\"\n\"                       XGrabServer() deadlock for -scrollcopyrect mode.\\n\"\n\"\\n\"\n\"-debug_sel             Turn on debugging info printout with respect to\\n\"\n\"                       PRIMARY, CLIPBOARD, and CUTBUFFER0 selections.\\n\"\n\"\\n\"\n\"-pointer_mode n        Various pointer motion update schemes. \\\"-pm\\\" is\\n\"\n\"                       an alias.  The problem is pointer motion can cause\\n\"\n\"                       rapid changes on the screen: consider the rapid\\n\"\n\"                       changes when you drag a large window around opaquely.\\n\"\n\"                       Neither x11vnc's screen polling and vnc compression\\n\"\n\"                       routines nor the bandwidth to the vncviewers can keep\\n\"\n\"                       up these rapid screen changes: everything will bog down\\n\"\n\"                       when dragging or scrolling.  So a scheme has to be used\\n\"\n\"                       to \\\"eat\\\" much of that pointer input before re-polling\\n\"\n\"                       the screen and sending out framebuffer updates. The\\n\"\n\"                       mode number \\\"n\\\" can be 0 to %d and selects one of\\n\"\n\"                       the schemes described below.\\n\"\n\"\\n\"\n\"                       Note that the -wireframe and -scrollcopyrect modes\\n\"\n\"                       complement -pointer_mode by detecting (and improving)\\n\"\n\"                       certain periods of \\\"rapid screen change\\\".\\n\"\n\"\\n\"\n\"                       n=0: does the same as -nodragging. (all screen polling\\n\"\n\"                       is suspended if a mouse button is pressed.)\\n\"\n\"\\n\"\n\"                       n=1: was the original scheme used to about Jan 2004:\\n\"\n\"                       it basically just skips -input_skip keyboard or pointer\\n\"\n\"                       events before repolling the screen.\\n\"\n\"\\n\"\n\"                       n=2 is an improved scheme: by watching the current rate\\n\"\n\"                       of input events it tries to detect if it should try to\\n\"\n\"                       \\\"eat\\\" additional pointer events before continuing.\\n\"\n\"\\n\"\n\"                       n=3 is basically a dynamic -nodragging mode: it detects\\n\"\n\"                       when the mouse motion has paused and then refreshes\\n\"\n\"                       the display.\\n\"\n\"\\n\"\n\"                       n=4 attempts to measures network rates and latency,\\n\"\n\"                       the video card read rate, and how many tiles have been\\n\"\n\"                       changed on the screen.  From this, it aggressively tries\\n\"\n\"                       to push screen \\\"frames\\\" when it decides it has enough\\n\"\n\"                       resources to do so.  NOT FINISHED.\\n\"\n\"\\n\"\n\"                       The default n is %d. Note that modes 2, 3, 4 will skip\\n\"\n\"                       -input_skip keyboard events (but it will not count\\n\"\n\"                       pointer events).  Also note that these modes are not\\n\"\n\"                       available in -threads mode which has its own pointer\\n\"\n\"                       event handling mechanism.\\n\"\n\"\\n\"\n\"                       To try out the different pointer modes to see which\\n\"\n\"                       one gives the best response for your usage, it is\\n\"\n\"                       convenient to use the remote control function, for\\n\"\n\"                       example \\\"x11vnc -R pm:4\\\" or the tcl/tk gui (Tuning ->\\n\"\n\"                       pointer_mode -> n).\\n\"\n\"\\n\"\n\"-input_skip n          For the pointer handling when non-threaded: try to\\n\"\n\"                       read n user input events before scanning display. n < 0\\n\"\n\"                       means to act as though there is always user input.\\n\"\n\"                       Default: %d\\n\"\n\"\\n\"\n\"-allinput              Have x11vnc read and process all available client input\\n\"\n\"                       before proceeding.\\n\"\n\"\\n\"\n\"-input_eagerly         Similar to -allinput but use the handleEventsEagerly\\n\"\n\"                       mechanism built into LibVNCServer.\\n\"\n\"\\n\"\n\"-multiptr              Enable support for per-client input devices. Each\\n\"\n\"                       client will get its own cursor and keyboard focus.\\n\"\n\"\\n\"\n\"-speeds rd,bw,lat      x11vnc tries to estimate some speed parameters that\\n\"\n\"                       are used to optimize scheduling (e.g. -pointer_mode\\n\"\n\"                       4, -wireframe, -scrollcopyrect) and other things.\\n\"\n\"                       Use the -speeds option to set these manually.\\n\"\n\"                       The triple \\\"rd,bw,lat\\\" corresponds to video h/w\\n\"\n\"                       read rate in MB/sec, network bandwidth to clients in\\n\"\n\"                       KB/sec, and network latency to clients in milliseconds,\\n\"\n\"                       respectively.  If a value is left blank, e.g. \\\"-speeds\\n\"\n\"                       ,100,15\\\", then the internal scheme is used to estimate\\n\"\n\"                       the empty value(s).\\n\"\n\"\\n\"\n\"                       Typical PC video cards have read rates of 5-10 MB/sec.\\n\"\n\"                       If the framebuffer is in main memory instead of video\\n\"\n\"                       h/w (e.g. SunRay, shadowfb, dummy driver, Xvfb), the\\n\"\n\"                       read rate may be much faster.  \\\"x11perf -getimage500\\\"\\n\"\n\"                       can be used to get a lower bound (remember to factor\\n\"\n\"                       in the bytes per pixel).  It is up to you to estimate\\n\"\n\"                       the network bandwidth and latency to clients.  For the\\n\"\n\"                       latency the ping(1) command can be used.\\n\"\n\"\\n\"\n\"                       For convenience there are some aliases provided,\\n\"\n\"                       e.g. \\\"-speeds modem\\\".  The aliases are: \\\"modem\\\" for\\n\"\n\"                       6,4,200; \\\"dsl\\\" for 6,100,50; and \\\"lan\\\" for 6,5000,1\\n\"\n\"\\n\"\n\"-wmdt string           For some features, e.g. -wireframe and -scrollcopyrect,\\n\"\n\"                       x11vnc has to work around issues for certain window\\n\"\n\"                       managers or desktops (currently kde and xfce).\\n\"\n\"                       By default it tries to guess which one, but it can\\n\"\n\"                       guess incorrectly.  Use this option to indicate which\\n\"\n\"                       wm/dt.  \\\"string\\\" can be \\\"gnome\\\", \\\"kde\\\", \\\"cde\\\",\\n\"\n\"                       \\\"xfce\\\", or \\\"root\\\" (classic X wm).  Anything else\\n\"\n\"                       is interpreted as \\\"root\\\".\\n\"\n\"\\n\"\n\"-debug_pointer         Print debugging output for every pointer event.\\n\"\n\"-debug_keyboard        Print debugging output for every keyboard event.\\n\"\n\"                       Same as -dp and -dk, respectively.  Use multiple\\n\"\n\"                       times for more output.\\n\"\n\"\\n\"\n\"-defer time            Time in ms to delay sending updates to connected clients\\n\"\n\"                       (deferUpdateTime)  Default: %d\\n\"\n\"\\n\"\n\"-wait time             Time in ms to pause between screen polls.  Used to cut\\n\"\n\"                       down on load.  Default: %d\\n\"\n\"\\n\"\n\"-extra_fbur n          Perform extra FrameBufferUpdateRequests checks to\\n\"\n\"                       try to be in better sync with the client's requests.\\n\"\n\"                       What this does is perform extra polls of the client\\n\"\n\"                       socket at critical times (before '-defer' and '-wait'\\n\"\n\"                       calls.)  The default is n=1.  Set to a larger number to\\n\"\n\"                       insert more checks or set to n=0 to disable.  A downside\\n\"\n\"                       of these extra calls is that more mouse input may be\\n\"\n\"                       processed than desired.\\n\"\n\"\\n\"\n\"-wait_ui factor        Factor by which to cut the -wait time if there\\n\"\n\"                       has been recent user input (pointer or keyboard).\\n\"\n\"                       Improves response, but increases the load whenever you\\n\"\n\"                       are moving the mouse or typing.  Default: %.2f\\n\"\n\"-setdefer n            When the -wait_ui mechanism cuts down the wait time ms,\\n\"\n\"                       set the defer time to the same ms value. n=1 to enable,\\n\"\n\"                       0 to disable, and -1 to set defer to 0 (no delay).\\n\"\n\"                       Similarly, 2 and -2 indicate 'urgent_update' mode should\\n\"\n\"                       be used to push the updates even sooner.  Default: 1\\n\"\n\"-nowait_bog            Do not detect if the screen polling is \\\"bogging down\\\"\\n\"\n\"                       and sleep more.  Some activities with no user input can\\n\"\n\"                       slow things down a lot: consider a large terminal window\\n\"\n\"                       with a long build running in it continuously streaming\\n\"\n\"                       text output.  By default x11vnc will try to detect this\\n\"\n\"                       (3 screen polls in a row each longer than 0.25 sec with\\n\"\n\"                       no user input), and sleep up to 1.5 secs to let things\\n\"\n\"                       \\\"catch up\\\".  Use this option to disable that detection.\\n\"\n\"-slow_fb time          Floating point time in seconds to delay all screen\\n\"\n\"                       polling.  For special purpose usage where a low frame\\n\"\n\"                       rate is acceptable and desirable, but you want the\\n\"\n\"                       user input processed at the normal rate so you cannot\\n\"\n\"                       use -wait.\\n\"\n\"-xrefresh time         Floating point time in seconds to indicate how often to\\n\"\n\"                       do the equivalent of xrefresh(1) to force all windows\\n\"\n\"                       (in the viewable area if -id, -sid, or -clip is used)\\n\"\n\"                       to repaint themselves.  Use this only if applications\\n\"\n\"                       misbehave by not repainting themselves properly.\\n\"\n\"                       See also -noxdamage.\\n\"\n\"-nap                   Monitor activity and if it is low take longer naps\\n\"\n\"-nonap                 between screen polls to really cut down load when idle.\\n\"\n\"                       Default: %s\\n\"\n\"-sb time               Time in seconds after NO activity (e.g. screen blank)\\n\"\n\"                       to really throttle down the screen polls (i.e. sleep\\n\"\n\"                       for about 1.5 secs). Use 0 to disable.  Default: %d\\n\"\n\"                       Set the env. var. X11VNC_SB_FACTOR to scale it.\\n\"\n\"\\n\"\n\"-readtimeout n         Set LibVNCServer rfbMaxClientWait to n seconds. On\\n\"\n\"                       slow links that take a long time to paint the first\\n\"\n\"                       screen LibVNCServer may hit the timeout and drop the\\n\"\n\"                       connection.  Default: %d seconds.\\n\"\n\"-ping n                Send a 1x1 framebuffer update to all clients every n\\n\"\n\"                       seconds (e.g. to try to keep a network connection alive)\\n\"\n\"\\n\"\n\"-nofbpm                If the system supports the FBPM (Frame Buffer Power\\n\"\n\"-fbpm                  Management) extension (i.e. some Sun systems), then\\n\"\n\"                       prevent the video h/w from going into a reduced power\\n\"\n\"                       state when VNC clients are connected.\\n\"\n\"\\n\"\n\"                       FBPM capable video h/w save energy when the workstation\\n\"\n\"                       is idle by going into low power states (similar to DPMS\\n\"\n\"                       for monitors).  This interferes with x11vnc's polling\\n\"\n\"                       of the framebuffer data.\\n\"\n\"\\n\"\n\"                       \\\"-nofbpm\\\" means prevent FBPM low power states whenever\\n\"\n\"                       VNC clients are connected, while \\\"-fbpm\\\" means to not\\n\"\n\"                       monitor the FBPM state at all.  See the xset(1) manpage\\n\"\n\"                       for details.  -nofbpm is basically the same as running\\n\"\n\"                       \\\"xset fbpm force on\\\" periodically.  Default: %s\\n\"\n\"\\n\"\n\"-nodpms                If the system supports the DPMS (Display Power Management\\n\"\n\"-dpms                  Signaling) extension, then prevent the monitor from\\n\"\n\"                       going into a reduced power state when VNC clients\\n\"\n\"                       are connected.\\n\"\n\"\\n\"\n\"                       DPMS reduced power monitor states are a good thing\\n\"\n\"                       and you normally want the power down to take place\\n\"\n\"                       (usually x11vnc has no problem exporting the display in\\n\"\n\"                       this state).  You probably only want to use \\\"-nodpms\\\"\\n\"\n\"                       to work around problems with Screen Savers kicking\\n\"\n\"                       on in DPMS low power states.  There is known problem\\n\"\n\"                       with kdesktop_lock on KDE where the screen saver keeps\\n\"\n\"                       kicking in every time user input stops for a second\\n\"\n\"                       or two.  Specifying \\\"-nodpms\\\" works around it.\\n\"\n\"\\n\"\n\"                       \\\"-nodpms\\\" means prevent DPMS low power states whenever\\n\"\n\"                       VNC clients are connected, while \\\"-dpms\\\" means to not\\n\"\n\"                       monitor the DPMS state at all.  See the xset(1) manpage\\n\"\n\"                       for details.  -nodpms is basically the same as running\\n\"\n\"                       \\\"xset dpms force on\\\" periodically.  Default: %s\\n\"\n\"\\n\"\n\"-forcedpms             If the system supports the DPMS (Display Power\\n\"\n\"                       Management Signaling) extension, then try to keep the\\n\"\n\"                       monitor in a powered off state.  This is to prevent\\n\"\n\"                       nosey people at the physical display from viewing what\\n\"\n\"                       is on the screen.  Be sure to lock the screen before\\n\"\n\"                       disconnecting.\\n\"\n\"\\n\"\n\"                       This method is far from bullet proof, e.g. suppose\\n\"\n\"                       someone attaches a non-DPMS monitor, or loads the\\n\"\n\"                       machine so that there is a gap of time before x11vnc\\n\"\n\"                       restores the powered off state?  On many machines if\\n\"\n\"                       he floods it with keyboard and mouse input he can see\\n\"\n\"                       flashes of what is on the screen before the DPMS off\\n\"\n\"                       state is reestablished.  For this to work securely\\n\"\n\"                       there would need to be support in the X server to do\\n\"\n\"                       this exactly rather than approximately with DPMS.\\n\"\n\"\\n\"\n\"-clientdpms            As -forcedpms but only when VNC clients are connected.\\n\"\n\"\\n\"\n\"-noserverdpms          The UltraVNC ServerInput extension is supported.\\n\"\n\"                       This allows the VNC viewer to click a button that will\\n\"\n\"                       cause the server (x11vnc) to try to disable keyboard\\n\"\n\"                       and mouse input at the physical display and put the\\n\"\n\"                       monitor in dpms powered off state.  Use this option to\\n\"\n\"                       skip powering off the monitor.\\n\"\n\"\\n\"\n\"-noultraext            Disable the following UltraVNC extensions: SingleWindow\\n\"\n\"                       and ServerInput.  The others managed by LibVNCServer\\n\"\n\"                       (textchat, 1/n scaling, rfbEncodingUltra) are not.\\n\"\n\"\\n\"\n\"-chatwindow            Place a local UltraVNC chat window on the X11 display\\n\"\n\"                       that x11vnc is polling.  That way the person on the VNC\\n\"\n\"                       viewer-side can chat with the person at the physical\\n\"\n\"                       X11 console. (e.g. helpdesk w/o telephone)\\n\"\n\"\\n\"\n\"                       For this to work the SSVNC package (version 1.0.21 or\\n\"\n\"                       later) MUST BE installed on the system where x11vnc runs\\n\"\n\"                       and the 'ssvnc' command must be available in $PATH.\\n\"\n\"                       The ssvncviewer is used as a chat window helper.\\n\"\n\"                       See http://www.karlrunge.com/x11vnc/ssvnc.html\\n\"\n\"\\n\"\n\"                       This option implies '-rfbversion 3.6' so as to trick\\n\"\n\"                       UltraVNC viewers, otherwise they assume chat is not\\n\"\n\"                       available.  To specify a different rfbversion, place\\n\"\n\"                       it after the -chatwindow option on the cmdline.\\n\"\n\"\\n\"\n\"                       See also the remote control 'chaton' and 'chatoff'\\n\"\n\"                       actions.  These can also be set from the tkx11vnc GUI.\\n\"\n\"\\n\"\n\"-noxdamage             Do not use the X DAMAGE extension to detect framebuffer\\n\"\n\"                       changes even if it is available.  Use -xdamage if your\\n\"\n\"                       default is to have it off.\\n\"\n\"\\n\"\n\"                       x11vnc's use of the DAMAGE extension: 1) significantly\\n\"\n\"                       reduces the load when the screen is not changing much,\\n\"\n\"                       and 2) detects changed areas (small ones by default)\\n\"\n\"                       more quickly.\\n\"\n\"\\n\"\n\"                       Currently the DAMAGE extension is overly conservative\\n\"\n\"                       and often reports large areas (e.g. a whole terminal\\n\"\n\"                       or browser window) as damaged even though the actual\\n\"\n\"                       changed region is much smaller (sometimes just a few\\n\"\n\"                       pixels).  So heuristics were introduced to skip large\\n\"\n\"                       areas and use the damage rectangles only as \\\"hints\\\"\\n\"\n\"                       for the traditional scanline polling.  The following\\n\"\n\"                       tuning parameters are introduced to adjust this\\n\"\n\"                       behavior:\\n\"\n\"\\n\"\n\"-xd_area A             Set the largest DAMAGE rectangle area \\\"A\\\" (in\\n\"\n\"                       pixels: width * height) to trust as truly damaged:\\n\"\n\"                       the rectangle will be copied from the framebuffer\\n\"\n\"                       (slow) no matter what.  Set to zero to trust *all*\\n\"\n\"                       rectangles. Default: %d\\n\"\n\"-xd_mem f              Set how long DAMAGE rectangles should be \\\"remembered\\\",\\n\"\n\"                       \\\"f\\\" is a floating point number and is in units of the\\n\"\n\"                       scanline repeat cycle time (%d iterations).  The default\\n\"\n\"                       (%.1f) should give no painting problems. Increase it if\\n\"\n\"                       there are problems or decrease it to live on the edge\\n\"\n\"                       (perhaps useful on a slow machine).\\n\"\n\"\\n\"\n\"-sigpipe string        Broken pipe (SIGPIPE) handling.  \\\"string\\\" can be\\n\"\n\"                       \\\"ignore\\\" or \\\"exit\\\".  For \\\"ignore\\\" LibVNCServer\\n\"\n\"                       will handle the abrupt loss of a client and continue,\\n\"\n\"                       for \\\"exit\\\" x11vnc will cleanup and exit at the 1st\\n\"\n\"                       broken connection.\\n\"\n\"\\n\"\n\"                       This option is not really needed since LibVNCServer\\n\"\n\"                       is doing the correct thing now for quite some time.\\n\"\n\"                       However, for convenience you can use it to ignore other\\n\"\n\"                       signals, e.g. \\\"-sigpipe ignore:HUP,INT,TERM\\\" in case\\n\"\n\"                       that would be useful for some sort of application.\\n\"\n\"                       You can also put \\\"exit:..\\\" in the list to have x11vnc\\n\"\n\"                       cleanup on the listed signals. \\\"-sig\\\" is an alias\\n\"\n\"                       for this option if you don't like the 'pipe'. Example:\\n\"\n\"                       -sig ignore:INT,TERM,exit:USR1\\n\"\n\"\\n\"\n\"-threads               Whether or not to use the threaded LibVNCServer\\n\"\n\"-nothreads             algorithm [rfbRunEventLoop] if libpthread is available.\\n\"\n\"                       In this mode new threads (one for input and one\\n\"\n\"                       for output) are created to handle each new client.\\n\"\n\"                       Default: %s.\\n\"\n\"\\n\"\n\"                       Thread stability is much improved in version 0.9.8.\\n\"\n\"\\n\"\n\"                       Multiple clients in threaded mode should be stable\\n\"\n\"                       for the ZRLE encoding on all platforms.  The Tight and\\n\"\n\"                       Zlib encodings are currently only stable on Linux for\\n\"\n\"                       multiple clients.  Compile with -DTLS=__thread if your\\n\"\n\"                       OS and compiler and linker support it.\\n\"\n\"\\n\"\n\"                       For resizes (randr, etc.) set this env. var. to the number\\n\"\n\"                       of milliseconds to sleep: X11VNC_THREADS_NEW_FB_SLEEP\\n\"\n\"                       at various places in the do_new_fb() action.  This is to\\n\"\n\"                       let various activities settle.  Default is about 500ms.\\n\"\n\"\\n\"\n\"                       Multiple clients in threaded mode could yield better\\n\"\n\"                       performance for 'class-room' broadcasting usage; also in\\n\"\n\"                       -appshare broadcast mode.  See also the -reflect option.\\n\"\n\"\\n\"\n\"-fs f                  If the fraction of changed tiles in a poll is greater\\n\"\n\"                       than f, the whole screen is updated.  Default: %.2f\\n\"\n\"-gaps n                Heuristic to fill in gaps in rows or cols of n or\\n\"\n\"                       less tiles.  Used to improve text paging.  Default: %d\\n\"\n\"-grow n                Heuristic to grow islands of changed tiles n or wider\\n\"\n\"                       by checking the tile near the boundary.  Default: %d\\n\"\n\"-fuzz n                Tolerance in pixels to mark a tiles edges as changed.\\n\"\n\"                       Default: %d\\n\"\n\"-debug_tiles           Print debugging output for tiles, fb updates, etc.\\n\"\n\"\\n\"\n\"-snapfb                Instead of polling the X display framebuffer (fb)\\n\"\n\"                       for changes, periodically copy all of X display fb\\n\"\n\"                       into main memory and examine that copy for changes.\\n\"\n\"                       (This setting also applies for non-X -rawfb modes).\\n\"\n\"                       Under some circumstances this will improve interactive\\n\"\n\"                       response, or at least make things look smoother, but in\\n\"\n\"                       others (most!) it will make the response worse.  If the\\n\"\n\"                       video h/w fb is such that reading small tiles is very\\n\"\n\"                       slow this mode could help.  To keep the \\\"framerate\\\"\\n\"\n\"                       up the screen size x bpp cannot be too large.  Note that\\n\"\n\"                       this mode is very wasteful of memory I/O resources\\n\"\n\"                       (it makes full screen copies even if nothing changes).\\n\"\n\"                       It may be of use in video capture-like applications,\\n\"\n\"                       webcams, or where window tearing is a problem.\\n\"\n\"\\n\"\n\"-rawfb string          Instead of polling X, poll the memory object specified\\n\"\n\"                       in \\\"string\\\".\\n\"\n\"\\n\"\n\"                       For file polling, to memory map mmap(2) a file use:\\n\"\n\"                       \\\"map:/path/to/a/file@WxHxB\\\", with framebuffer Width,\\n\"\n\"                       Height, and Bits per pixel.  \\\"mmap:...\\\" is the\\n\"\n\"                       same.\\n\"\n\"\\n\"\n\"                       If there is trouble with mmap, use \\\"file:/...\\\"\\n\"\n\"                       for slower lseek(2) based reading.\\n\"\n\"\\n\"\n\"                       Use \\\"snap:...\\\" to imply -snapfb mode and the \\\"file:\\\"\\n\"\n\"                       access (this is for unseekable devices that only provide\\n\"\n\"                       the fb all at once, e.g. a video camera provides the\\n\"\n\"                       whole frame).\\n\"\n\"\\n\"\n\"                       For shared memory segments string is of the form:\\n\"\n\"                       \\\"shm:N@WxHxB\\\" which specifies a shmid N and with\\n\"\n\"                       WxHxB as above.  See shmat(1) and ipcs(1)\\n\"\n\"\\n\"\n\"                       If you do not supply a type \\\"map\\\" is assumed if\\n\"\n\"                       the file exists (see the next paragraphs for some\\n\"\n\"                       exceptions to this.)\\n\"\n\"\\n\"\n\"                       If string is \\\"setup:cmd\\\", then the command \\\"cmd\\\"\\n\"\n\"                       is run and the first line from it is read and used\\n\"\n\"                       as \\\"string\\\".  This allows initializing the device,\\n\"\n\"                       determining WxHxB, etc. These are often done as root\\n\"\n\"                       so take care.\\n\"\n\"\\n\"\n\"                       If the string begins with \\\"video\\\", see the VIDEO4LINUX\\n\"\n\"                       discussion below where the device may be queried for\\n\"\n\"                       (and possibly set) the framebuffer parameters.\\n\"\n\"\\n\"\n\"                       If the string begins with \\\"console\\\", \\\"/dev/fb\\\",\\n\"\n\"                       \\\"fb\\\", or \\\"vt\\\", see the LINUX CONSOLE discussion\\n\"\n\"                       below where the framebuffer device is opened and\\n\"\n\"                       keystrokes (and possibly mouse events) are inserted\\n\"\n\"                       into the console.\\n\"\n\"\\n\"\n\"                       If the string begins with \\\"vnc\\\", see the VNC HOST\\n\"\n\"                       discussion below where the framebuffer is taken as that\\n\"\n\"                       of another remote VNC server.\\n\"\n\"\\n\"\n\"                       Optional suffixes are \\\":R/G/B\\\" and \\\"+O\\\" to specify\\n\"\n\"                       red, green, and blue masks (in hex) and an offset into\\n\"\n\"                       the memory object.  If the masks are not provided x11vnc\\n\"\n\"                       guesses them based on the bpp (if the colors look wrong,\\n\"\n\"                       you need to provide the masks.)\\n\"\n\"\\n\"\n\"                       Another optional suffix is the Bytes Per Line which in\\n\"\n\"                       some cases is not WxB/8.  Specify it as WxHxB-BPL\\n\"\n\"                       e.g. 800x600x16-2048.  This could be a normal width\\n\"\n\"                       1024 at 16bpp fb, but only width 800 shows up.\\n\"\n\"\\n\"\n\"                       So the full format is: mode:file@WxHxB:R/G/B+O-BPL\\n\"\n\"\\n\"\n\"                       Examples:\\n\"\n\"                           -rawfb shm:210337933@800x600x32:ff/ff00/ff0000\\n\"\n\"                           -rawfb map:/dev/fb0@1024x768x32\\n\"\n\"                           -rawfb map:/tmp/Xvfb_screen0@640x480x8+3232\\n\"\n\"                           -rawfb file:/tmp/my.pnm@250x200x24+37\\n\"\n\"                           -rawfb file:/dev/urandom@128x128x8\\n\"\n\"                           -rawfb snap:/dev/video0@320x240x24 -24to32\\n\"\n\"                           -rawfb video0\\n\"\n\"                           -rawfb video -pipeinput VID\\n\"\n\"                           -rawfb console\\n\"\n\"                           -rawfb vt2\\n\"\n\"                           -rawfb vnc:somehost:0\\n\"\n\"\\n\"\n\"                       (see ipcs(1) and fbset(1) for the first two examples)\\n\"\n\"\\n\"\n\"                       In general all user input is discarded by default (see\\n\"\n\"                       the -pipeinput option for how to use a helper program\\n\"\n\"                       to insert).  Most of the X11 (screen, keyboard, mouse)\\n\"\n\"                       options do not make sense and many will cause this\\n\"\n\"                       mode to crash, so please think twice before setting or\\n\"\n\"                       changing them in a running x11vnc.\\n\"\n\"\\n\"\n\"                       If you DO NOT want x11vnc to close the X DISPLAY in\\n\"\n\"                       rawfb mode, prepend a \\\"+\\\" e.g. +file:/dev/fb0...\\n\"\n\"                       Keeping the display open enables the default\\n\"\n\"                       remote-control channel, which could be useful.\\n\"\n\"                       Alternatively, if you specify -noviewonly, then the\\n\"\n\"                       mouse and keyboard input are STILL sent to the X\\n\"\n\"                       display, this usage should be very rare, i.e. doing\\n\"\n\"                       something strange with /dev/fb0.\\n\"\n\"\\n\"\n\"                       If the device is not \\\"seekable\\\" (e.g. webcam) try\\n\"\n\"                       reading it all at once in full snaps via the \\\"snap:\\\"\\n\"\n\"                       mode (note: this is a resource hog).  If you are using\\n\"\n\"                       file: or map: AND the device needs to be reopened for\\n\"\n\"                       *every* snapfb snapshot, set the environment variable:\\n\"\n\"                       SNAPFB_RAWFB_RESET=1 as well.\\n\"\n\"\\n\"\n\"                       If you want x11vnc to dynamically transform a 24bpp\\n\"\n\"                       rawfb to 32bpp (note that this will be slower) also\\n\"\n\"                       supply the -24to32 option.  This would be useful for,\\n\"\n\"                       say, a video camera that delivers the pixel data as\\n\"\n\"                       24bpp packed RGB.  This is the default under \\\"video\\\"\\n\"\n\"                       mode if the bpp is 24.\\n\"\n\"\\n\"\n\"                       Normally the bits per pixel, B, is 8, 16, or 32 (or\\n\"\n\"                       rarely 24), however there is also some support for\\n\"\n\"                       B < 8 (e.g. old graphics displays 4 bpp or 1 bpp).\\n\"\n\"                       In this case you certainly must supply the masks as\\n\"\n\"                       well: WxHxB:R/G/B.  The pixels will be padded out to\\n\"\n\"                       8 bpp using depth 8 truecolor.  The scheme currently\\n\"\n\"                       does not work with snap fb (ask if interested.) B=1\\n\"\n\"                       monochrome example: file:/dev/urandom@128x128x1:1/1/1\\n\"\n\"                       Some other like this are 128x128x2:3/3/3 128x128x4:7/7/7\\n\"\n\"\\n\"\n\"                       For B < 8 framebuffers you can also set the env. var\\n\"\n\"                       RAWFB_CGA=1 to try a CGA mapping for B=4 (e.g. linux\\n\"\n\"                       vga16fb driver.)  Note with low bpp and/or resolution\\n\"\n\"                       VGA and VGA16 modes on the Linux console one's attempt\\n\"\n\"                       to export them via x11vnc can often be thwarted due to\\n\"\n\"                       special color palettes, pixel packings, and even video\\n\"\n\"                       painting buffering.  OTOH, often experimenting with the\\n\"\n\"                       RGB masks can yield something recognizable.\\n\"\n\"\\n\"\n\"                       VIDEO4LINUX: on Linux some attempt is made to handle\\n\"\n\"                       video devices (webcams or TV tuners) automatically.\\n\"\n\"                       The idea is the WxHxB will be extracted from the\\n\"\n\"                       device itself.  So if you do not supply \\\"@WxHxB...\\n\"\n\"                       parameters x11vnc will try to determine them.  It first\\n\"\n\"                       tries the v4l API if that support has been compiled in.\\n\"\n\"                       Otherwise it will run the v4l-info(1) external program\\n\"\n\"                       if it is available.\\n\"\n\"\\n\"\n\"                       The simplest examples are \\\"-rawfb video\\\" and \\\"-rawfb\\n\"\n\"                       video1\\\" which imply the device file /dev/video and\\n\"\n\"                       /dev/video1, respectively.  You can also supply the\\n\"\n\"                       /dev if you like, e.g. \\\"-rawfb /dev/video0\\\"\\n\"\n\"\\n\"\n\"                       Since the video capture device framebuffer usually\\n\"\n\"                       changes continuously (e.g. brightness fluctuations),\\n\"\n\"                       you may want to use the -wait, -slow_fb, or -defer\\n\"\n\"                       options to lower the \\\"framerate\\\" to cut down on\\n\"\n\"                       network VNC traffic.\\n\"\n\"\\n\"\n\"                       A more sophisticated video device scheme allows\\n\"\n\"                       initializing the device's settings using:\\n\"\n\"\\n\"\n\"                           -rawfb video:<settings>\\n\"\n\"\\n\"\n\"                       The prefix could also be, as above, e.g. \\\"video1:\\\" to\\n\"\n\"                       specify the device file.  The v4l API must be available\\n\"\n\"                       for this to work.  Otherwise, you will need to try\\n\"\n\"                       to initialize the device with an external program,\\n\"\n\"                       e.g. xawtv, spcaview, and hope they persist when x11vnc\\n\"\n\"                       re-opens the device.\\n\"\n\"\\n\"\n\"                       <settings> is a comma separated list of key=value pairs.\\n\"\n\"                       The device's brightness, color, contrast, and hue can\\n\"\n\"                       be set to percentages, e.g. br=80,co=50,cn=44,hu=60.\\n\"\n\"\\n\"\n\"                       The device filename can be set too if needed (if it\\n\"\n\"                       does not start with \\\"video\\\"), e.g. fn=/dev/qcam.\\n\"\n\"\\n\"\n\"                       The width, height and bpp of the framebuffer can be\\n\"\n\"                       set via, e.g., w=160,h=120,bpp=16.\\n\"\n\"\\n\"\n\"                       Related to the bpp above, the pixel format can be set\\n\"\n\"                       via the fmt=XXX, where XXX can be one of: GREY, HI240,\\n\"\n\"                       RGB555, RGB565, RGB24, and RGB32 (with bpp 8, 8, 16, 16,\\n\"\n\"                       24, and 32 respectively).  See http://www.linuxtv.org\\n\"\n\"                       for more info (V4L api).\\n\"\n\"\\n\"\n\"                       For TV/rf tuner cards one can set the tuning mode\\n\"\n\"                       via tun=XXX where XXX can be one of PAL, NTSC, SECAM,\\n\"\n\"                       or AUTO.\\n\"\n\"\\n\"\n\"                       One can switch the input channel by the inp=XXX setting,\\n\"\n\"                       where XXX is the name of the input channel (Television,\\n\"\n\"                       Composite1, S-Video, etc).  Use the name that is in the\\n\"\n\"                       information about the device that is printed at startup.\\n\"\n\"\\n\"\n\"                       For input channels with tuners (e.g. Television) one\\n\"\n\"                       can change which station is selected by the sta=XXX\\n\"\n\"                       setting.  XXX is the station number.  Currently only\\n\"\n\"                       the ntsc-cable-us (US cable) channels are built into\\n\"\n\"                       x11vnc.  See the -freqtab option below to supply one\\n\"\n\"                       from xawtv. If XXX is greater than 500, then it is\\n\"\n\"                       interpreted as a raw frequency in KHz.\\n\"\n\"\\n\"\n\"                       Example:\\n\"\n\"\\n\"\n\"                       -rawfb video:br=80,w=320,h=240,fmt=RGB32,tun=NTSC,sta=47\\n\"\n\"\\n\"\n\"                       one might need to add inp=Television too for the input\\n\"\n\"                       channel to be TV if the card doesn't come up by default\\n\"\n\"                       in that one.\\n\"\n\"\\n\"\n\"                       Note that not all video capture devices will support\\n\"\n\"                       all of the above settings.\\n\"\n\"\\n\"\n\"                       See the -pipeinput VID option below for a way to control\\n\"\n\"                       the settings through the VNC Viewer via keystrokes.\\n\"\n\"                       As a shortcut, if the string begins \\\"Video..\\\" instead\\n\"\n\"                       of \\\"video..\\\" then -pipeinput VID is implied.\\n\"\n\"\\n\"\n\"                       As above, if you specify a \\\"@WxHxB...\\\" after the\\n\"\n\"                       <settings> string they are used verbatim: the device\\n\"\n\"                       is not queried for the current values.  Otherwise the\\n\"\n\"                       device will be queried.\\n\"\n\"\\n\"\n\"                       LINUX CONSOLE:  The following describes some ways to\\n\"\n\"                       view and possibly interact with the Linux text/graphics\\n\"\n\"                       console (i.e. not X11 XFree86/Xorg)\\n\"\n\"\\n\"\n\"                       Note: If the LibVNCServer LinuxVNC program is on your\\n\"\n\"                       system you may want to use that instead of the following\\n\"\n\"                       method because it will be faster and more accurate\\n\"\n\"                       for the Linux text console and includes mouse support.\\n\"\n\"                       There is, however, the basic LinuxVNC functionality in\\n\"\n\"                       x11vnc if you replace \\\"console\\\" with \\\"vt\\\" in the\\n\"\n\"                       examples below.\\n\"\n\"\\n\"\n\"                       If the rawfb string begins with \\\"console\\\" the\\n\"\n\"                       framebuffer device /dev/fb0 is opened and /dev/tty0 is\\n\"\n\"                       opened too.  The latter is used to inject keystrokes\\n\"\n\"                       (not all are supported, but the basic ones are).\\n\"\n\"                       You will need to be root to inject keystrokes, but\\n\"\n\"                       not necessarily to open /dev/fb0.  /dev/tty0 refers to\\n\"\n\"                       the active VT, to indicate one explicitly, use, e.g.,\\n\"\n\"                       \\\"console2\\\" for /dev/tty2, etc. by indicating the\\n\"\n\"                       specific VT number.\\n\"\n\"\\n\"\n\"                       For the Linux framebuffer device, /dev/fb0, (fb1,\\n\"\n\"                       etc) to be enabled the appropriate kernel drivers must\\n\"\n\"                       be loaded.  E.g. vesafb or vga16fb and also by setting\\n\"\n\"                       the boot parameter vga=0x301 (or 0x314, 0x317, etc.)\\n\"\n\"                       (The vga=... method is the preferred way; set your\\n\"\n\"                       machines up that way.)  Otherwise there will be a\\n\"\n\"                       'No such device' error.  You can also load a Linux\\n\"\n\"                       framebuffer driver specific to your make of video card\\n\"\n\"                       for more functionality.  Once the machine is booted one\\n\"\n\"                       can often 'modprobe' the fb driver as root to obtain\\n\"\n\"                       a framebuffer device.\\n\"\n\"\\n\"\n\"                       If you cannot get /dev/fb0 working on Linux, try\\n\"\n\"                       using the LinuxVNC emulation mode by \\\"-rawfb vtN\\\"\\n\"\n\"                       where N = 1, ... 6 is the Linux Virtual Terminal (aka\\n\"\n\"                       virtual console) you wish to view, e.g. \\\"-rawfb vt2\\\".\\n\"\n\"                       Unlike /dev/fb mode, it need not be the active Virtual\\n\"\n\"                       Terminal.  Note that this mode can only show text and\\n\"\n\"                       not graphics.  x11vnc polls the text in /dev/vcsaN\\n\"\n\"\\n\"\n\"                       Set the env. var. RAWFB_VCSA_BW=1 to disable colors in\\n\"\n\"                       the \\\"vtN\\\" mode (i.e. black and white only.)  If you\\n\"\n\"                       do not prefer the default 16bpp set RAWFB_VCSA_BPP to\\n\"\n\"                       8 or 32.  If you need to tweak the rawfb parameters by\\n\"\n\"                       using the 'console_guess' string printed at startup,\\n\"\n\"                       be sure to indicate the snap: method.\\n\"\n\"\\n\"\n\"                       uinput: If the Linux version appears to be 2.6\\n\"\n\"                       or later and the \\\"uinput\\\" module appears to be\\n\"\n\"                       present (modprobe uinput), then the uinput method\\n\"\n\"                       will be used instead of /dev/ttyN.  uinput allows\\n\"\n\"                       insertion of BOTH keystrokes and mouse input and so it\\n\"\n\"                       preferred when accessing graphical (e.g. QT-embedded)\\n\"\n\"                       linux console apps.  It also provides more accurate\\n\"\n\"                       keystroke insertion.  See -pipeinput UINPUT below for\\n\"\n\"                       more information on this mode; you will have to use\\n\"\n\"                       -pipeinput if you want to tweak any UINPUT parameters.\\n\"\n\"                       You may also want to also use the -nodragging and\\n\"\n\"                       -cursor none options.  Use \\\"console0\\\", etc  or\\n\"\n\"                       -pipeinput CONSOLE to force the /dev/ttyN method.\\n\"\n\"\\n\"\n\"                       Note you can change the Linux VT remotely using the\\n\"\n\"                       chvt(1) command to make the one you want be the active\\n\"\n\"                       one (e.g. 'chvt 3').  Sometimes switching out and back\\n\"\n\"                       corrects the framebuffer's graphics state.  For the\\n\"\n\"                       \\\"-rawfb vtN\\\" mode there is no need to switch the VT's.\\n\"\n\"\\n\"\n\"                       To skip input injecting entirely use \\\"consolex\\\"\\n\"\n\"                       or \\\"vtx\\\".\\n\"\n\"\\n\"\n\"                       The string \\\"/dev/fb0\\\" (1, etc.) can be used instead\\n\"\n\"                       of \\\"console\\\".  This can be used to specify a different\\n\"\n\"                       framebuffer device, e.g. /dev/fb1.  As a shortcut the\\n\"\n\"                       \\\"/dev/\\\" can be dropped.  If the name is something\\n\"\n\"                       nonstandard, use \\\"console:/dev/foofb\\\"\\n\"\n\"\\n\"\n\"                       If you do not want x11vnc to guess the framebuffer's\\n\"\n\"                       WxHxB and masks automatically (sometimes the kernel\\n\"\n\"                       gives incorrect information), specify them with a @WxHxB\\n\"\n\"                       (and optional :R/G/B masks) at the end of the string.\\n\"\n\"\\n\"\n\"                       Examples:\\n\"\n\"                           -rawfb console\\n\"\n\"                           -rawfb /dev/fb0           (same)\\n\"\n\"                           -rawfb console3           (force /dev/tty3)\\n\"\n\"                           -rawfb consolex           (no keystrokes or mouse)\\n\"\n\"                           -rawfb console:/dev/nonstd\\n\"\n\"                           -rawfb console -pipeinput UINPUT:accel=4.0\\n\"\n\"                           -rawfb vt3                (/dev/tty3 w/o /dev/fb0)\\n\"\n\"\\n\"\n\"                       VNC HOST: if the -rawfb string is of the form\\n\"\n\"                       \\\"vnc:host:N\\\" then the VNC display \\\"N\\\" on the remote\\n\"\n\"                       VNC server \\\"host\\\" is connected to (i.e. x11vnc acts as\\n\"\n\"                       a VNC client itself) and that framebuffer is exported.\\n\"\n\"\\n\"\n\"                       This mode is really only of use if you are trying\\n\"\n\"                       to improve performance in the case of many (e.g. >\\n\"\n\"                       10) simultaneous VNC viewers, and you try a divide\\n\"\n\"                       and conquer scheme to reduce bandwidth and improve\\n\"\n\"                       responsiveness.  (However, another user found this mode\\n\"\n\"                       useful to export a demo display through a slow link:\\n\"\n\"                       then multiple demo viewers connected to the reflecting\\n\"\n\"                       x11vnc on the fast side of the link, and so avoided\\n\"\n\"                       all of the demo viewers going through the slow link.)\\n\"\n\"\\n\"\n\"                       For example, if there will be 64 simultaneous VNC\\n\"\n\"                       viewers this can lead to a lot of redundant VNC traffic\\n\"\n\"                       to and from the server host:N, extra CPU usage,\\n\"\n\"                       and all viewers response can be reduced by having\\n\"\n\"                       to wait for writes to the slowest client to finish.\\n\"\n\"                       However, if you set up 8 reflectors/repeaters started\\n\"\n\"                       with option -rawfb vnc:host:N, then there are only\\n\"\n\"                       8 connections to host:N.  Each repeater then handles\\n\"\n\"                       8 vnc viewer connections thereby spreading the load\\n\"\n\"                       around.  In classroom broadcast usage, try to put the\\n\"\n\"                       repeaters on different switches.  This mode is the same\\n\"\n\"                       as -reflect host:N.  Replace \\\"host:N\\\" by \\\"listen\\\"\\n\"\n\"                       or \\\"listen:port\\\" for a reverse connection.\\n\"\n\"\\n\"\n\"                       Overall performance will not be as good as a single\\n\"\n\"                       direct connection because, among other things,\\n\"\n\"                       there is an additional level of framebuffer polling\\n\"\n\"                       and pointer motion can still induce many changes per\\n\"\n\"                       second that must be propagated.  Tip: if the remote VNC\\n\"\n\"                       is x11vnc doing wireframing, or an X display that does\\n\"\n\"                       wireframing that gives much better response than opaque\\n\"\n\"                       window dragging.  Consider the -nodragging option if\\n\"\n\"                       the problem is severe.\\n\"\n\"\\n\"\n\"                       The env. var. X11VNC_REFLECT_PASSWORD can be set to\\n\"\n\"                       the password needed to log into the vnc host server, or\\n\"\n\"                       to \\\"file:path_to_file\\\" to indicate a file containing\\n\"\n\"                       the password as its first line.\\n\"\n\"\\n\"\n\"                       To set the pixel format that x11vnc requests as a VNC\\n\"\n\"                       CLIENT set the env. vars: X11VNC_REFLECT_bitsPerSample\\n\"\n\"                       X11VNC_REFLECT_samplesPerPixel, and\\n\"\n\"                       X11VNC_REFLECT_bytesPerPixel; the defaults are 8, 3, 4.\\n\"\n\"                       2, 3, 1 would give a low color mode.  See the function\\n\"\n\"                       rfbGetClient() in libvncclient for more info.\\n\"\n\"\\n\"\n\"                       The VNC HOST mode implies -shared.  Use -noshared as\\n\"\n\"                       a subsequent cmdline option to disable sharing.\\n\"\n\"\\n\"\n\"-freqtab file          For use with \\\"-rawfb video\\\" for TV tuner devices to\\n\"\n\"                       specify station frequencies.  Instead of using the built\\n\"\n\"                       in ntsc-cable-us mapping of station number to frequency,\\n\"\n\"                       use the data in file.  For stations that are not\\n\"\n\"                       numeric, e.g. SE20, they are placed above the highest\\n\"\n\"                       numbered station in the order they are found.  Example:\\n\"\n\"                       \\\"-freqtab /usr/X11R6/share/xawtv/europe-west.list\\\"\\n\"\n\"                       You can make your own freqtab by copying the xawtv\\n\"\n\"                       format.\\n\"\n\"\\n\"\n\"-pipeinput cmd         This option lets you supply an external command in\\n\"\n\"                       \\\"cmd\\\" that x11vnc will pipe all of the user input\\n\"\n\"                       events to in a simple format.  In -pipeinput mode by\\n\"\n\"                       default x11vnc will not process any of the user input\\n\"\n\"                       events.  If you prefix \\\"cmd\\\" with \\\"tee:\\\" it will\\n\"\n\"                       both send them to the pipe command and process them.\\n\"\n\"                       For a description of the format run \\\"-pipeinput\\n\"\n\"                       tee:/bin/cat\\\".  Another prefix is \\\"reopen\\\" which\\n\"\n\"                       means to reopen pipe if it exits.  Separate multiple\\n\"\n\"                       prefixes with commas.\\n\"\n\"\\n\"\n\"                       In combination with -rawfb one might be able to\\n\"\n\"                       do amusing things (e.g. control non-X devices).\\n\"\n\"                       To facilitate this, if -rawfb is in effect then the\\n\"\n\"                       value is stored in X11VNC_RAWFB_STR for the pipe command\\n\"\n\"                       to use if it wants. Do 'env | grep X11VNC' for more.\\n\"\n\"\\n\"\n\"                       Built-in pipeinput modes (no external program required):\\n\"\n\"\\n\"\n\"                       If cmd is \\\"VID\\\" and you are using the -rawfb for a\\n\"\n\"                       video capture device, then an internal list of keyboard\\n\"\n\"                       mappings is used to set parameters of the video.\\n\"\n\"                       The mappings are:\\n\"\n\"\\n\"\n\"                         \\\"B\\\" and \\\"b\\\" adjust the brightness up and down.\\n\"\n\"                         \\\"H\\\" and \\\"h\\\" adjust the hue.\\n\"\n\"                         \\\"C\\\" and \\\"c\\\" adjust the colour.\\n\"\n\"                         \\\"N\\\" and \\\"n\\\" adjust the contrast.\\n\"\n\"                         \\\"S\\\" and \\\"s\\\" adjust the size of the capture screen.\\n\"\n\"                         \\\"I\\\" and \\\"i\\\" cycle through input channels.\\n\"\n\"                         Up and Down arrows adjust the station (if a tuner)\\n\"\n\"                         F1, F2, ..., F6 will switch the video capture pixel\\n\"\n\"                         format to HI240, RGB565, RGB24, RGB32, RGB555, and\\n\"\n\"                         GREY respectively.  See -rawfb video for details.\\n\"\n\"\\n\"\n\"                       If cmd is \\\"CONSOLE\\\" or \\\"CONSOLEn\\\" where n\\n\"\n\"                       is a Linux console number, then the linux console\\n\"\n\"                       keystroke insertion to /dev/ttyN (see -rawfb console)\\n\"\n\"                       is performed.\\n\"\n\"\\n\"\n\"                       If cmd begins with \\\"UINPUT\\\" then the Linux uinput\\n\"\n\"                       module is used to insert both keystroke and mouse events\\n\"\n\"                       to the Linux console (see -rawfb above).  This usually\\n\"\n\"                       is the /dev/input/uinput device file (you may need to\\n\"\n\"                       create it with \\\"mknod /dev/input/uinput c 10 223\\\"\\n\"\n\"                       and insert the module with \\\"modprobe uinput\\\".\\n\"\n\"\\n\"\n\"                       The UINPUT mode currently only does US keyboards (a\\n\"\n\"                       scan code option may be added), and not all keysyms\\n\"\n\"                       are supported.  But it is probably more accurate than\\n\"\n\"                       the \\\"CONSOLE\\\" method.\\n\"\n\"\\n\"\n\"                       You may want to use the options -cursor none and\\n\"\n\"                       -nodragging in this mode.\\n\"\n\"\\n\"\n\"                       Additional tuning options may be supplied via:\\n\"\n\"                       UINPUT:opt1,opt2,... (a comma separated list). If an\\n\"\n\"                       option begins with \\\"/\\\" it is taken as the uinput\\n\"\n\"                       device file.\\n\"\n\"                       \\n\"\n\"                       Which uinput is injected can be controlled by an option\\n\"\n\"                       string made of the characters \\\"K\\\", \\\"M\\\", and \\\"B\\\"\\n\"\n\"                       (see the -input option), e.g. \\\"KM\\\" allows keystroke\\n\"\n\"                       and motion but not button clicks.\\n\"\n\"\\n\"\n\"                       A UINPUT option of the form: accel=f, or accel=fx+fy\\n\"\n\"                       sets the mouse motion \\\"acceleration\\\".  This is used\\n\"\n\"                       to correct raw mouse relative motion into how much the\\n\"\n\"                       application cursor moves (x11vnc has no control over,\\n\"\n\"                       or knowledge of how the windowing application interprets\\n\"\n\"                       the raw mouse motions).  Typically the acceleration\\n\"\n\"                       for an X display is 2 (see xset \\\"m\\\" option).  \\\"f\\\"\\n\"\n\"                       is a floating point number, e.g. 3.0.  Use \\\"fx+fy\\\"\\n\"\n\"                       if you need to supply different corrections for x and y.\\n\"\n\"\\n\"\n\"                       Note: the default acceleration is 2.0 since it seems\\n\"\n\"                       both X and qt-embedded often (but not always) use\\n\"\n\"                       this value.\\n\"\n\"\\n\"\n\"                       Even with a correct accel setting the mouse position\\n\"\n\"                       will get out of sync (probably due to a mouse\\n\"\n\"                       \\\"threshold\\\" setting where the acceleration doe not\\n\"\n\"                       apply, set xset(1)).  The option reset=N sets the\\n\"\n\"                       number of ms (default 150) after which the cursor is\\n\"\n\"                       attempted to be reset (by forcing the mouse to (0,\\n\"\n\"                       0) via small increments and then back out to (x, y)\\n\"\n\"                       in 1 jump), This correction seems to be needed but can\\n\"\n\"                       cause jerkiness or unexpected behavior with menus, etc.\\n\"\n\"                       Use reset=0 to disable.\\n\"\n\"\\n\"\n\"                       If you set the env. var X11VNC_UINPUT_THRESHOLDS then\\n\"\n\"                       the thresh=n mode will be enabled.  It is currently\\n\"\n\"                       not working well.  If |dx| <= thresh and |dy| < thresh\\n\"\n\"                       no acceleration is applied.  Use \\\"thresh=+n\\\" |dx| +\\n\"\n\"                       |dy| < thresh to be used instead (X11?)\\n\"\n\"\\n\"\n\"                       Example:\\n\"\n\"                           -pipeinput UINPUT:accel=4.0 -cursor none\\n\"\n\"\\n\"\n\"                       If the uinput device has an absolute pointer (as opposed\\n\"\n\"                       to a normal mouse that is a relative pointer) you can\\n\"\n\"                       specify the option \\\"abs\\\".  Note that a touchpad\\n\"\n\"                       on a laptop is an absolute device to some degree.\\n\"\n\"                       This (usually) avoids all the problems with mouse\\n\"\n\"                       acceleration.  If x11vnc has trouble deducing the\\n\"\n\"                       size of the device, use \\\"abs=WxH\\\".  Furthermore,\\n\"\n\"                       if the device is a touchscreen (assumed to have an\\n\"\n\"                       absolute pointer) use \\\"touch\\\" or \\\"touch=WxH\\\".\\n\"\n\"                       For touchscreens, when a mouse button is pressed,\\n\"\n\"                       a pressure increase is injected, and when the button\\n\"\n\"                       is released a pressure of zero is injected.\\n\"\n\"\\n\"\n\"                       If touch has been set, use \\\"touch_always=1\\\" to\\n\"\n\"                       indicate whenever the mouse moves with no button\\n\"\n\"                       pressed, a touch event of zero pressure should be\\n\"\n\"                       sent anyway.  Also use \\\"btn_touch=1\\\" to indicate a\\n\"\n\"                       BTN_TOUCH keystroke press or release should be sent\\n\"\n\"                       instead of a pressure change.  Set \\\"dragskip=n\\\" to\\n\"\n\"                       skip n dragged mouse touches (with pressure applied)\\n\"\n\"                       before injecting one.  To indicate the pressure that\\n\"\n\"                       should be sent when there is a button click for a\\n\"\n\"                       touchscreen device, specify pressure=n, e.g. n=5. The\\n\"\n\"                       default is n=1.\\n\"\n\"\\n\"\n\"                       If a touch screen is being used (\\\"touch\\\" above)\\n\"\n\"                       and it is having its input processed by tslib, you can\\n\"\n\"                       specify the tslib calibration file via tslib_cal=<file>.\\n\"\n\"                       For example, tslib_cal=/etc/pointercal.  To get accurate\\n\"\n\"                       or even usable positioning this is required when tslib\\n\"\n\"                       is in use.\\n\"\n\"\\n\"\n\"                       The Linux uinput mechanism can be bypassed and one can\\n\"\n\"                       write input events DIRECTLY to the devices instead.\\n\"\n\"                       To do this, specify one or more of the following\\n\"\n\"                       for the input classes: direct_rel=<device>\\n\"\n\"                       direct_abs=<device> direct_btn=<device> or\\n\"\n\"                       direct_key=<device>.  The <device> file is usually\\n\"\n\"                       something like /dev/input/event1 but you can specify\\n\"\n\"                       any device file or pipe.  You must specify each one\\n\"\n\"                       of the above classes even if they correspond to the\\n\"\n\"                       same device file (rel/abs and btn are often the same.)\\n\"\n\"                       Look at the file /proc/bus/input/devices to get an idea\\n\"\n\"                       what is available and the device filenames.  Note:\\n\"\n\"                       The /dev/input/mouse* devices do not seem to work,\\n\"\n\"                       use the corresponding /dev/input/event* file instead.\\n\"\n\"                       Any input class not directly specified as above will be\\n\"\n\"                       handled via the uinput mechanism.  To disable creating a\\n\"\n\"                       uinput device (and thereby discarding unhandled input),\\n\"\n\"                       specify \\\"nouinput\\\".\\n\"\n\"\\n\"\n\"                       Examples:\\n\"\n\"\\n\"\n\"                         -pipeinput UINPUT:direct_abs=/dev/input/event1\\n\"\n\"\\n\"\n\"                       this was used on a qtmoko Neo freerunner (armel):\\n\"\n\"\\n\"\n\"                         -pipeinput UINPUT:touch,tslib_cal=/etc/pointercal,\\n\"\n\"                          direct_abs=/dev/input/event1,nouinput,dragskip=4\\n\"\n\"\\n\"\n\"                       (where the long line has been split into two.)\\n\"\n\"\\n\"\n\"                       You can set the env. var X11VNC_UINPUT_DEBUG=1 or higher\\n\"\n\"                       to get debugging output for UINPUT mode.\\n\"\n\"\\n\"\n\"-macnodim              For the native MacOSX server, disable dimming. \\n\"\n\"-macnosleep            For the native MacOSX server, disable display sleep.\\n\"\n\"-macnosaver            For the native MacOSX server, disable screensaver.\\n\"\n\"-macnowait             For the native MacOSX server, do not wait for the\\n\"\n\"                       user to switch back to his display.\\n\"\n\"-macwheel n            For the native MacOSX server, set the mouse wheel\\n\"\n\"                       speed to n (default 5).\\n\"\n\"-macnoswap             For the native MacOSX server, do not swap mouse\\n\"\n\"                       buttons 2 and 3.\\n\"\n\"-macnoresize           For the native MacOSX server, do not resize or reset\\n\"\n\"                       the framebuffer even if it is detected that the screen\\n\"\n\"                       resolution or depth has changed.\\n\"\n\"-maciconanim n         For the native MacOSX server, set n to the number\\n\"\n\"                       of milliseconds that the window iconify/deiconify\\n\"\n\"                       animation takes.  In -ncache mode this value will be\\n\"\n\"                       used to skip the animation if possible. (default 400)\\n\"\n\"-macmenu               For the native MacOSX server, in -ncache client-side\\n\"\n\"                       caching mode, try to cache pull down menus (not perfect\\n\"\n\"                       because they have animated fades, etc.)\\n\"\n\"-macuskbd              For the native MacOSX server, use the original\\n\"\n\"                       keystroke insertion code based on a US keyboard.\\n\"\n\"-macnoopengl           For the native MacOSX server, do not use OpenGL for\\n\"\n\"                       screen capture, but rather use the original, deprecated\\n\"\n\"                       raw memory access method: addr = CGDisplayBaseAddress().\\n\"\n\"-macnorawfb            For the native MacOSX server, disable the raw memory\\n\"\n\"                       address screen capture method.\\n\"\n\"\\n\"\n\"                       MACOSX NOTE: There are some deprecated MacOSX interfaces\\n\"\n\"                       to inject keyboard and mouse events and the raw memory\\n\"\n\"                       access method is deprecated as well (however, OpenGL\\n\"\n\"                       will be preferred if available because it is faster.)\\n\"\n\"                       One can force not using any deprecated interfaces at\\n\"\n\"                       compile time by setting -DX11VNC_MACOSX_NO_DEPRECATED=1\\n\"\n\"                       in CPPFLAGS.  Or to turn them off one by one:\\n\"\n\"                       -DX11VNC_MACOSX_NO_DEPRECATED_LOCALEVENTS=1,\\n\"\n\"                       -DX11VNC_MACOSX_NO_DEPRECATED_POSTEVENTS=1 or\\n\"\n\"                       -DX11VNC_MACOSX_NO_DEPRECATED_FRAMEBUFFER=1\\n\"\n\"                       At run time, for testing and workarounds, one can\\n\"\n\"                       disable them by using:\\n\"\n\"                       -env X11VNC_MACOSX_NO_DEPRECATED=1\\n\"\n\"                       -env X11VNC_MACOSX_NO_DEPRECATED_LOCALEVENTS=1\\n\"\n\"                       -env X11VNC_MACOSX_NO_DEPRECATED_POSTEVENTS=1 or\\n\"\n\"                       -env X11VNC_MACOSX_NO_DEPRECATED_FRAMEBUFFER=1\\n\"\n\"                       Note: When doing either of these for the mouse input\\n\"\n\"                       not everything works currently, e.g. double clicks and\\n\"\n\"                       wireframing.  Also, screen resolution and pixel depth\\n\"\n\"                       changes will not be automatically detected unless the\\n\"\n\"                       deprecated framebuffer interfaces are allowed.\\n\"\n\"\\n\"\n\"                       Conversely, if you are compiling on an\\n\"\n\"                       older machine that does not have some of\\n\"\n\"                       the newer interfaces, you may need to specify\\n\"\n\"                       -DX11VNC_MACOSX_NO_CGEVENTCREATESCROLLWHEELEVENT\\n\"\n\"                       -DX11VNC_MACOSX_NO_CGEVENTCREATEMOUSEEVENT or\\n\"\n\"                       -DX11VNC_MACOSX_NO_CGEVENTCREATEKEYBOARDEVENT.  Use\\n\"\n\"                       -DX11VNC_MACOSX_USE_GETMAINDEVICE to regain the very\\n\"\n\"                       old QuickDraw GetMainDevice() interface (rare...)\\n\"\n\"\\n\"\n\"-gui [gui-opts]        Start up a simple tcl/tk gui based on the remote\\n\"\n\"                       control options -remote/-query described below.\\n\"\n\"                       Requires the \\\"wish\\\" program to be installed on the\\n\"\n\"                       machine.  \\\"gui-opts\\\" is not required: the default\\n\"\n\"                       is to start up both the full gui and x11vnc with the\\n\"\n\"                       gui showing up on the X display in the environment\\n\"\n\"                       variable DISPLAY.\\n\"\n\"\\n\"\n\"                       \\\"gui-opts\\\" can be a comma separated list of items.\\n\"\n\"                       Currently there are these types of items: 1) a gui\\n\"\n\"                       mode, a 2) gui \\\"simplicity\\\", 3) the X display the\\n\"\n\"                       gui should display on, 4) a \\\"tray\\\" or \\\"icon\\\" mode,\\n\"\n\"                       and 5) a gui geometry.\\n\"\n\"\\n\"\n\"                       1) The gui mode can be \\\"start\\\", \\\"conn\\\", or \\\"wait\\\"\\n\"\n\"                       \\\"start\\\" is the default mode above and is not required.\\n\"\n\"                       \\\"conn\\\" means do not automatically start up x11vnc,\\n\"\n\"                       but instead just try to connect to an existing x11vnc\\n\"\n\"                       process.  \\\"wait\\\" means just start the gui and nothing\\n\"\n\"                       else (you will later instruct the gui to start x11vnc\\n\"\n\"                       or connect to an existing one.)\\n\"\n\"\\n\"\n\"                       2) The gui simplicity is off by default (a power-user\\n\"\n\"                       gui with all options is presented) To start with\\n\"\n\"                       something less daunting supply the string \\\"simple\\\"\\n\"\n\"                       (\\\"ez\\\" is an alias for this).  Once the gui is\\n\"\n\"                       started you can toggle between the two with \\\"Misc ->\\n\"\n\"                       simple_gui\\\".\\n\"\n\"\\n\"\n\"                       3) Note the possible confusion regarding the potentially\\n\"\n\"                       two different X displays: x11vnc polls one, but you\\n\"\n\"                       may want the gui to appear on another.  For example, if\\n\"\n\"                       you ssh in and x11vnc is not running yet you may want\\n\"\n\"                       the gui to come back to you via your ssh redirected X\\n\"\n\"                       display (e.g. localhost:10).\\n\"\n\"\\n\"\n\"                       If you do not specify a gui X display in \\\"gui-opts\\\"\\n\"\n\"                       then the DISPLAY environment variable and -display\\n\"\n\"                       option are tried (in that order).  Regarding the x11vnc\\n\"\n\"                       X display the gui will try to communication with, it\\n\"\n\"                       first tries -display and then DISPLAY.  For example,\\n\"\n\"                       \\\"x11vnc -display :0 -gui otherhost:0\\\", will remote\\n\"\n\"                       control an x11vnc polling :0 and display the gui on\\n\"\n\"                       otherhost:0 The \\\"tray/icon\\\" mode below reverses this\\n\"\n\"                       preference, preferring to display on the x11vnc display.\\n\"\n\"\\n\"\n\"                       4) When \\\"tray\\\" or \\\"icon\\\" is specified, the gui\\n\"\n\"                       presents itself as a small icon with behavior typical\\n\"\n\"                       of a \\\"system tray\\\" or \\\"dock applet\\\".  The color\\n\"\n\"                       of the icon indicates status (connected clients) and\\n\"\n\"                       there is also a balloon status.  Clicking on the icon\\n\"\n\"                       gives a menu from which properties, etc, can be set and\\n\"\n\"                       the full gui is available under \\\"Advanced\\\".  To be\\n\"\n\"                       fully functional, the gui mode should be \\\"start\\\"\\n\"\n\"                       (the default).\\n\"\n\"\\n\"\n\"                       Note that tray or icon mode will imply the -forever\\n\"\n\"                       x11vnc option (if the x11vnc server is started along\\n\"\n\"                       with the gui) unless -connect or -connect_or_exit has\\n\"\n\"                       been specified.  So x11vnc (and the tray/icon gui)\\n\"\n\"                       will wait for more connections after the first client\\n\"\n\"                       disconnects.  If you want only one viewer connection\\n\"\n\"                       include the -once option.\\n\"\n\"\\n\"\n\"                       For \\\"icon\\\" the gui just a small standalone window.\\n\"\n\"                       For \\\"tray\\\" it will attempt to embed itself in the\\n\"\n\"                       \\\"system tray\\\" if possible. If \\\"=setpass\\\" is appended then\\n\"\n\"                       at startup the X11 user will be prompted to set the\\n\"\n\"                       VNC session password.  If =<hexnumber> is appended\\n\"\n\"                       that icon will attempt to embed itself in the window\\n\"\n\"                       given by hexnumber.  Use =noadvanced to disable the\\n\"\n\"                       full gui. (To supply more than one, use \\\"+\\\" sign).\\n\"\n\"                       E.g. -gui tray=setpass and -gui icon=0x3600028\\n\"\n\"\\n\"\n\"                       Other modes: \\\"full\\\", the default and need not be\\n\"\n\"                       specified.  \\\"-gui none\\\", do not show a gui, useful\\n\"\n\"                       to override a ~/.x11vncrc setting, etc.\\n\"\n\"\\n\"\n\"                       5) When \\\"geom=+X+Y\\\" is specified, that geometry\\n\"\n\"                       is passed to the gui toplevel.  This is the icon in\\n\"\n\"                       icon/tray mode, or the full gui otherwise.  You can\\n\"\n\"                       also specify width and height, i.e. WxH+X+Y, but it\\n\"\n\"                       is not recommended.  In \\\"tray\\\" mode the geometry is\\n\"\n\"                       ignored unless the system tray manager does not seem\\n\"\n\"                       to be running.  One could imagine using something like\\n\"\n\"                       \\\"-gui tray,geom=+4000+4000\\\" with a display manager\\n\"\n\"                       to keep the gui invisible until someone logs in...\\n\"\n\"\\n\"\n\"                       More icon tricks, \\\"icon=minimal\\\" gives an icon just\\n\"\n\"                       with the VNC display number.  You can also set the font\\n\"\n\"                       with \\\"iconfont=...\\\".  The following could be useful:\\n\"\n\"                       \\\"-gui icon=minimal,iconfont=5x8,geom=24x10+0-0\\\"\\n\"\n\"\\n\"\n\"                       General examples of the -gui option: \\\"x11vnc -gui\\\",\\n\"\n\"                       \\\"x11vnc -gui ez\\\" \\\"x11vnc -gui localhost:10\\\",\\n\"\n\"                       \\\"x11vnc -gui conn,host:0\\\", \\\"x11vnc -gui tray,ez\\\"\\n\"\n\"                       \\\"x11vnc -gui tray=setpass\\\"\\n\"\n\"\\n\"\n\"                       If you do not intend to start x11vnc from the gui\\n\"\n\"                       (i.e. just remote control an existing one), then the\\n\"\n\"                       gui process can run on a different machine from the\\n\"\n\"                       x11vnc server as long as X permissions, etc. permit\\n\"\n\"                       communication between the two.\\n\"\n\"\\n\"\n\"                       FONTS: On some systems the tk fonts can be too small,\\n\"\n\"                       jagged, or otherwise unreadable.  There are 4 env vars\\n\"\n\"                       you can set to be the tk font you prefer:\\n\"\n\"\\n\"\n\"                       X11VNC_FONT_BOLD   main font for menus and buttons.\\n\"\n\"                       X11VNC_FONT_FIXED  font for fixed width text.\\n\"\n\"\\n\"\n\"                       X11VNC_FONT_BOLD_SMALL  tray icon font.\\n\"\n\"                       X11VNC_FONT_REG_SMALL   tray icon menu font.\\n\"\n\"\\n\"\n\"                       The last two only apply for the tray icon mode.\\n\"\n\"\\n\"\n\"                       Here are some examples:\\n\"\n\"\\n\"\n\"                       -env X11VNC_FONT_BOLD='Helvetica -16 bold'\\n\"\n\"                       -env X11VNC_FONT_FIXED='Courier -14'\\n\"\n\"                       -env X11VNC_FONT_REG_SMALL='Helvetica -12'\\n\"\n\"\\n\"\n\"                       You can put the lines like the above (without the\\n\"\n\"                       quotes) in your ~/.x11vncrc file to avoid having to\\n\"\n\"                       specify them on the x11vnc command line.\\n\"\n\"\\n\"\n\"-remote command        Remotely control some aspects of an already running\\n\"\n\"                       x11vnc server.  \\\"-R\\\" and \\\"-r\\\" are aliases for\\n\"\n\"                       \\\"-remote\\\".  After the remote control command is\\n\"\n\"                       sent to the running server the 'x11vnc -remote ...'\\n\"\n\"                       x11vnc command exits.  You can often use the -query\\n\"\n\"                       command (see below) to see if the x11vnc server\\n\"\n\"                       processed your -remote command.\\n\"\n\"\\n\"\n\"                       The default communication channel is that of X\\n\"\n\"                       properties (specifically X11VNC_REMOTE), and so this\\n\"\n\"                       command must be run with correct settings for DISPLAY\\n\"\n\"                       and possibly XAUTHORITY to connect to the X server\\n\"\n\"                       and set the property.  Alternatively, use the -display\\n\"\n\"                       and -auth options to set them to the correct values.\\n\"\n\"                       The running server cannot use the -novncconnect option\\n\"\n\"                       because that disables the communication channel.\\n\"\n\"                       See below for alternate channels.\\n\"\n\"\\n\"\n\"                       For example: 'x11vnc -remote stop' (which is the same as\\n\"\n\"                       'x11vnc -R stop') will close down the x11vnc server.\\n\"\n\"                       'x11vnc -R shared' will enable shared connections, and\\n\"\n\"                       'x11vnc -R scale:3/4' will rescale the desktop.\\n\"\n\"\\n\"\n\"                       To use a different name for the X11 property (e.g. to\\n\"\n\"                       have separate communication channels for multiple\\n\"\n\"                       x11vnc's on the same display) set the X11VNC_REMOTE\\n\"\n\"                       environment variable to the string you want, for\\n\"\n\"                       example: -env X11VNC_REMOTE=X11VNC_REMOTE_12345\\n\"\n\"                       Both sides of the channel must use the same unique name.\\n\"\n\"\\n\"\n\"                       To run a bunch of commands in a sequence use something\\n\"\n\"                       like: x11vnc -R 'script:firstcmd;secondcmd;...'\\n\"\n\"\\n\"\n\"                       Use x11vnc -R script:file=/path/to/file to read commands\\n\"\n\"                       from a file (can be multi-line and use the comment '#'\\n\"\n\"                       character in the normal way.  The ';' separator must\\n\"\n\"                       still be used to separate each command.)\\n\"\n\"\\n\"\n\"                       To not try to contact another x11vnc process and instead\\n\"\n\"                       just run the command (or query) directly, prefix the\\n\"\n\"                       command with the string \\\"DIRECT:\\\"\\n\"\n\"\\n\"\n\"                       The following -remote/-R commands are supported:\\n\"\n\"\\n\"\n\"                       stop            terminate the server, same as \\\"quit\\\"\\n\"\n\"                                       \\\"exit\\\" or \\\"shutdown\\\".\\n\"\n\"                       ping            see if the x11vnc server responds.\\n\"\n\"                                       return is: ans=ping:<display>\\n\"\n\"                       ping:mystring   as above, but use your own unique string.\\n\"\n\"                                       return is: ans=ping:mystring:<xdisplay>\\n\"\n\"                       blacken         try to push a black fb update to all\\n\"\n\"                                       clients (due to timings a client\\n\"\n\"                                       could miss it). Same as \\\"zero\\\", also\\n\"\n\"                                       \\\"zero:x1,y1,x2,y2\\\" for a rectangle.\\n\"\n\"                       refresh         send the entire fb to all clients.\\n\"\n\"                       reset           recreate the fb, polling memory, etc.\\n\"\n/* ext. cmd. */\n\"                       id:windowid     set -id window to \\\"windowid\\\". empty\\n\"\n\"                                       or \\\"root\\\" to go back to root window\\n\"\n\"                       sid:windowid    set -sid window to \\\"windowid\\\"\\n\"\n\"                       id_cmd:cmd      cmds: raise, lower, map, unmap, iconify,\\n\"\n\"                                       move:dXdY, resize:dWdH, geom:WxH+X+Y. dX\\n\"\n\"                                       dY, dW, and dH must have a leading \\\"+\\\"\\n\"\n\"                                       or \\\"-\\\" e.g.: move:-30+10 resize:+20+35\\n\"\n\"                                       also: wm_delete, wm_name:string and\\n\"\n\"                                       icon_name:string. Also id_cmd:win=N:cmd\\n\"\n\"                       waitmapped      wait until subwin is mapped.\\n\"\n\"                       nowaitmapped    do not wait until subwin is mapped.\\n\"\n\"                       clip:WxH+X+Y    set -clip mode to \\\"WxH+X+Y\\\"\\n\"\n\"                       flashcmap       enable  -flashcmap mode.\\n\"\n\"                       noflashcmap     disable -flashcmap mode.\\n\"\n\"                       shiftcmap:n     set -shiftcmap to n.\\n\"\n\"                       notruecolor     enable  -notruecolor mode.\\n\"\n\"                       truecolor       disable -notruecolor mode.\\n\"\n\"                       overlay         enable  -overlay mode (if applicable).\\n\"\n\"                       nooverlay       disable -overlay mode.\\n\"\n\"                       overlay_cursor  in -overlay mode, enable cursor drawing.\\n\"\n\"                       overlay_nocursor disable cursor drawing. same as\\n\"\n\"                                        nooverlay_cursor.\\n\"\n\"                       8to24           enable  -8to24 mode (if applicable).\\n\"\n\"                       no8to24         disable -8to24 mode.\\n\"\n\"                       8to24_opts:str  set the -8to24 opts to \\\"str\\\".\\n\"\n\"                       24to32          enable  -24to32 mode (if applicable).\\n\"\n\"                       no24to32        disable -24to32 mode.\\n\"\n\"                       visual:vis      set -visual to \\\"vis\\\"\\n\"\n\"                       scale:frac      set -scale to \\\"frac\\\"\\n\"\n\"                       scale_cursor:f  set -scale_cursor to \\\"f\\\"\\n\"\n\"                       viewonly        enable  -viewonly mode.\\n\"\n/* access view,share,forever */\n\"                       noviewonly      disable -viewonly mode.\\n\"\n\"                       shared          enable  -shared mode.\\n\"\n\"                       noshared        disable -shared mode.\\n\"\n\"                       forever         enable  -forever mode.\\n\"\n\"                       noforever       disable -forever mode.\\n\"\n\"                       timeout:n       reset -timeout to n, if there are\\n\"\n\"                                       currently no clients, exit unless one\\n\"\n\"                                       connects in the next n secs.\\n\"\n\"                       tightfilexfer   enable  filetransfer for NEW clients.\\n\"\n\"                       notightfilexfer disable filetransfer for NEW clients.\\n\"\n\"                       ultrafilexfer   enable  filetransfer for clients.\\n\"\n\"                       noultrafilexfer disable filetransfer for clients.\\n\"\n\"                       rfbversion:n.m  set -rfbversion for new clients.\\n\"\n/* access */\n\"                       http            enable  http client connections.\\n\"\n\"                       nohttp          disable http client connections.\\n\"\n\"                       deny            deny any new connections, same as \\\"lock\\\"\\n\"\n\"                       nodeny          allow new connections, same as \\\"unlock\\\"\\n\"\n\"                       avahi           enable  avahi service advertising.\\n\"\n\"                       noavahi         disable avahi service advertising.\\n\"\n\"                       mdns            enable  avahi service advertising.\\n\"\n\"                       nomdns          disable avahi service advertising.\\n\"\n\"                       zeroconf        enable  avahi service advertising.\\n\"\n\"                       nozeroconf      disable avahi service advertising.\\n\"\n/* access, filename */\n\"                       connect:host    do reverse connection to host, \\\"host\\\"\\n\"\n\"                                       may be a comma separated list of hosts\\n\"\n\"                                       or host:ports.  See -connect.  Passwords\\n\"\n\"                                       required as with fwd connections.\\n\"\n\"                                       See X11VNC_REVERSE_CONNECTION_NO_AUTH=1\\n\"\n\"                       disconnect:host disconnect any clients from \\\"host\\\"\\n\"\n\"                                       same as \\\"close:host\\\".  Use host\\n\"\n\"                                       \\\"all\\\" to close all current clients.\\n\"\n\"                                       If you know the client internal hex ID,\\n\"\n\"                                       e.g. 0x3 (returned by \\\"-query clients\\\"\\n\"\n\"                                       and RFB_CLIENT_ID) you can use that too.\\n\"\n\"                       proxy:host:port set reverse connection proxy (empty to\\n\"\n\"                                       disable).\\n\"\n/* access */\n\"                       allowonce:host  For the next connection only, allow\\n\"\n\"                                       connection from \\\"host\\\". In -ssl mode\\n\"\n\"                                       two connections are allowed (i.e. Fetch\\n\"\n\"                                       Cert) unless X11VNC_NO_SSL_ALLOW_TWICE=1\\n\"\n/* access */\n\"                       allow:hostlist  set -allow list to (comma separated)\\n\"\n\"                                       \\\"hostlist\\\". See -allow and -localhost.\\n\"\n\"                                       Do not use with -allow /path/to/file\\n\"\n\"                                       Use \\\"+host\\\" to add a single host, and\\n\"\n\"                                       use \\\"-host\\\" to delete a single host\\n\"\n\"                       localhost       enable  -localhost mode\\n\"\n\"                       nolocalhost     disable -localhost mode\\n\"\n\"                       listen:str      set -listen to str, empty to disable.\\n\"\n\"                       noipv6          enable  -noipv6 mode.\\n\"\n\"                       ipv6            disable -noipv6 mode.\\n\"\n\"                       noipv4          enable  -noipv4 mode.\\n\"\n\"                       ipv4            disable -noipv4 mode.\\n\"\n\"                       6               enable  -6 IPv6 listening mode.\\n\"\n\"                       no6             disable -6 IPv6 listening mode.\\n\"\n\"                       lookup          disable -nolookup mode.\\n\"\n\"                       nolookup        enable  -nolookup mode.\\n\"\n\"                       lookup          disable -nolookup mode.\\n\"\n\"                       input:str       set -input to \\\"str\\\", empty to disable.\\n\"\n\"                       grabkbd         enable  -grabkbd mode.\\n\"\n\"                       nograbkbd       disable -grabkbd mode.\\n\"\n\"                       grabptr         enable  -grabptr mode.\\n\"\n\"                       nograbptr       disable -grabptr mode.\\n\"\n\"                       grabalways      enable  -grabalways mode.\\n\"\n\"                       nograbalways    disable -grabalways mode.\\n\"\n\"                       grablocal:n     set -grablocal to n.\\n\"\n\"                       client_input:str set the K, M, B -input on a per-client\\n\"\n\"                                       basis.  select which client as for\\n\"\n\"                                       disconnect, e.g. client_input:host:MB\\n\"\n\"                                       or client_input:0x2:K\\n\"\n/* ext. cmd. */\n\"                       accept:cmd      set -accept \\\"cmd\\\" (empty to disable).\\n\"\n\"                       afteraccept:cmd set -afteraccept (empty to disable).\\n\"\n\"                       gone:cmd        set -gone \\\"cmd\\\" (empty to disable).\\n\"\n\"                       noshm           enable  -noshm mode.\\n\"\n\"                       shm             disable -noshm mode (i.e. use shm).\\n\"\n\"                       flipbyteorder   enable -flipbyteorder mode, you may need\\n\"\n\"                                       to set noshm for this to do something.\\n\"\n\"                       noflipbyteorder disable -flipbyteorder mode.\\n\"\n\"                       onetile         enable  -onetile mode. (you may need to\\n\"\n\"                                       set shm for this to do something)\\n\"\n\"                       noonetile       disable -onetile mode.\\n\"\n/* ext. cmd. */\n\"                       solid           enable  -solid mode\\n\"\n\"                       nosolid         disable -solid mode.\\n\"\n\"                       solid_color:color set -solid color (and apply it).\\n\"\n\"                       blackout:str    set -blackout \\\"str\\\" (empty to disable).\\n\"\n\"                                       See -blackout for the form of \\\"str\\\"\\n\"\n\"                                       (basically: WxH+X+Y,...)\\n\"\n\"                                       Use \\\"+WxH+X+Y\\\" to append a single\\n\"\n\"                                       rectangle use \\\"-WxH+X+Y\\\" to delete one\\n\"\n\"                       xinerama        enable  -xinerama mode. (if applicable)\\n\"\n\"                       noxinerama      disable -xinerama mode.\\n\"\n\"                       xtrap           enable  -xtrap input mode(if applicable)\\n\"\n\"                       noxtrap         disable -xtrap input mode.\\n\"\n\"                       xrandr          enable  -xrandr mode. (if applicable)\\n\"\n\"                       noxrandr        disable -xrandr mode.\\n\"\n\"                       xrandr_mode:mode set the -xrandr mode to \\\"mode\\\".\\n\"\n\"                       rotate:mode     set the -rotate mode to \\\"mode\\\".\\n\"\n\"                       padgeom:WxH     set -padgeom to WxH (empty to disable)\\n\"\n\"                                       If WxH is \\\"force\\\" or \\\"do\\\" the padded\\n\"\n\"                                       geometry fb is immediately applied.\\n\"\n\"                       quiet           enable  -quiet mode.\\n\"\n\"                       noquiet         disable -quiet mode.\\n\"\n\"                       modtweak        enable  -modtweak mode.\\n\"\n\"                       nomodtweak      enable  -nomodtweak mode.\\n\"\n\"                       xkb             enable  -xkb modtweak mode.\\n\"\n\"                       noxkb           disable -xkb modtweak mode.\\n\"\n\"                       capslock        enable  -capslock mode.\\n\"\n\"                       nocapslock      disable -capslock mode.\\n\"\n\"                       skip_lockkeys   enable  -skip_lockkeys mode.\\n\"\n\"                       noskip_lockkeys disable -skip_lockkeys mode.\\n\"\n\"                       skip_keycodes:str enable -xkb -skip_keycodes \\\"str\\\".\\n\"\n\"                       sloppy_keys     enable  -sloppy_keys mode.\\n\"\n\"                       nosloppy_keys   disable -sloppy_keys mode.\\n\"\n\"                       skip_dups       enable  -skip_dups mode.\\n\"\n\"                       noskip_dups     disable -skip_dups mode.\\n\"\n\"                       add_keysyms     enable -add_keysyms mode.\\n\"\n\"                       noadd_keysyms   stop adding keysyms. those added will\\n\"\n\"                                       still be removed at exit.\\n\"\n\"                       clear_mods      enable  -clear_mods mode and clear them.\\n\"\n\"                       noclear_mods    disable -clear_mods mode.\\n\"\n\"                       clear_keys      enable  -clear_keys mode and clear them.\\n\"\n\"                       noclear_keys    disable -clear_keys mode.\\n\"\n\"                       clear_locks     do the clear_locks action.\\n\"\n\"                       clear_all       do the clear_all action.\\n\"\n\"                       keystate        have x11vnc print current keystate.\\n\"\n/* filename */\n\"                       remap:str       set -remap \\\"str\\\" (empty to disable).\\n\"\n\"                                       See -remap for the form of \\\"str\\\"\\n\"\n\"                                       (basically: key1-key2,key3-key4,...)\\n\"\n\"                                       Use \\\"+key1-key2\\\" to append a single\\n\"\n\"                                       keymapping, use \\\"-key1-key2\\\" to delete.\\n\"\n\"                       norepeat        enable  -norepeat mode.\\n\"\n\"                       repeat          disable -norepeat mode.\\n\"\n\"                       nofb            enable  -nofb mode.\\n\"\n\"                       fb              disable -nofb mode.\\n\"\n\"                       bell            enable  bell (if supported).\\n\"\n\"                       nobell          disable bell.\\n\"\n\"                       sendbell        ring the bell now.\\n\"\n\"                       nosel           enable  -nosel mode.\\n\"\n\"                       sel             disable -nosel mode.\\n\"\n\"                       noprimary       enable  -noprimary mode.\\n\"\n\"                       primary         disable -noprimary mode.\\n\"\n\"                       nosetprimary    enable  -nosetprimary mode.\\n\"\n\"                       setprimary      disable -nosetprimary mode.\\n\"\n\"                       noclipboard     enable  -noclipboard mode.\\n\"\n\"                       clipboard       disable -noclipboard mode.\\n\"\n\"                       nosetclipboard  enable  -nosetclipboard mode.\\n\"\n\"                       setclipboard    disable -nosetclipboard mode.\\n\"\n\"                       seldir:str      set -seldir to \\\"str\\\"\\n\"\n\"                       resend_cutbuffer resend the most recent CUTBUFFER0 copy\\n\"\n\"                       resend_clipboard resend the most recent CLIPBOARD copy\\n\"\n\"                       resend_primary   resend the most recent PRIMARY copy\\n\"\n\"                       cursor:mode     enable  -cursor \\\"mode\\\".\\n\"\n\"                       show_cursor     enable  showing a cursor.\\n\"\n\"                       noshow_cursor   disable showing a cursor. (same as\\n\"\n\"                                       \\\"nocursor\\\")\\n\"\n\"                       cursor_drag     enable  cursor changes during drag.\\n\"\n\"                       nocursor_drag   disable cursor changes during drag.\\n\"\n\"                       arrow:n         set -arrow to alternate n.\\n\"\n\"                       xfixes          enable  xfixes cursor shape mode.\\n\"\n\"                       noxfixes        disable xfixes cursor shape mode.\\n\"\n\"                       alphacut:n      set -alphacut to n.\\n\"\n\"                       alphafrac:f     set -alphafrac to f.\\n\"\n\"                       alpharemove     enable  -alpharemove mode.\\n\"\n\"                       noalpharemove   disable -alpharemove mode.\\n\"\n\"                       alphablend      disable -noalphablend mode.\\n\"\n\"                       noalphablend    enable  -noalphablend mode.\\n\"\n\"                       cursorshape     disable -nocursorshape mode.\\n\"\n\"                       nocursorshape   enable  -nocursorshape mode.\\n\"\n\"                       cursorpos       disable -nocursorpos mode.\\n\"\n\"                       nocursorpos     enable  -nocursorpos mode.\\n\"\n\"                       xwarp           enable  -xwarppointer mode.\\n\"\n\"                       noxwarp         disable -xwarppointer mode.\\n\"\n\"                       always_inject   enable  -always_inject mode.\\n\"\n\"                       noalways_inject disable -always_inject mode.\\n\"\n\"                       buttonmap:str   set -buttonmap \\\"str\\\", empty to disable\\n\"\n\"                       dragging        disable -nodragging mode.\\n\"\n\"                       nodragging      enable  -nodragging mode.\\n\"\n\"                       ncache          reenable -ncache mode.\\n\"\n\"                       noncache        disable  -ncache mode.\\n\"\n\"                       ncache_size:n   set -ncache size to n.\\n\"\n\"                       ncache_cr       enable  -ncache_cr mode.\\n\"\n\"                       noncache_cr     disable -ncache_cr mode.\\n\"\n\"                       ncache_no_moveraise     enable  no_moveraise mode.\\n\"\n\"                       noncache_no_moveraise   disable no_moveraise mode.\\n\"\n\"                       ncache_no_dtchange      enable  ncache_no_dtchange mode.\\n\"\n\"                       noncache_no_dtchange    disable ncache_no_dtchange mode.\\n\"\n\"                       ncache_old_wm           enable  ncache_old_wm mode.\\n\"\n\"                       noncache_old_wm         disable ncache_old_wm mode.\\n\"\n\"                       ncache_no_rootpixmap    enable  ncache_no_rootpixmap.\\n\"\n\"                       noncache_no_rootpixmap  disable ncache_no_rootpixmap.\\n\"\n\"                       ncache_reset_rootpixmap recheck the root pixmap, ncrp\\n\"\n\"                       ncache_keep_anims       enable  ncache_keep_anims.\\n\"\n\"                       noncache_keep_anims     disable ncache_keep_anims.\\n\"\n\"                       ncache_pad:n    set -ncache_pad to n.\\n\"\n\"                       wireframe       enable  -wireframe mode. same as \\\"wf\\\"\\n\"\n\"                       nowireframe     disable -wireframe mode. same as \\\"nowf\\\"\\n\"\n\"                       wireframe:str   enable  -wireframe mode string.\\n\"\n\"                       wireframe_mode:str enable  -wireframe mode string.\\n\"\n\"                       wireframelocal  enable  wireframelocal. same as \\\"wfl\\\"\\n\"\n\"                       nowireframe     disable wireframelocal. same as \\\"nowfl\\\"\\n\"\n\"                       wirecopyrect:str set -wirecopyrect string. same as \\\"wcr:\\\"\\n\"\n\"                       scrollcopyrect:str set -scrollcopyrect string. same \\\"scr\\\"\\n\"\n\"                       noscrollcopyrect disable -scrollcopyrect mode. \\\"noscr\\\"\\n\"\n\"                       scr_area:n      set -scr_area to n\\n\"\n\"                       scr_skip:list   set -scr_skip to \\\"list\\\"\\n\"\n\"                       scr_inc:list    set -scr_inc to \\\"list\\\"\\n\"\n\"                       scr_keys:list   set -scr_keys to \\\"list\\\"\\n\"\n\"                       scr_term:list   set -scr_term to \\\"list\\\"\\n\"\n\"                       scr_keyrepeat:str set -scr_keyrepeat to \\\"str\\\"\\n\"\n\"                       scr_parms:str   set -scr_parms parameters.\\n\"\n\"                       fixscreen:str   set -fixscreen to \\\"str\\\".\\n\"\n\"                       noxrecord       disable all use of RECORD extension.\\n\"\n\"                       xrecord         enable  use of RECORD extension.\\n\"\n\"                       reset_record    reset RECORD extension (if avail.)\\n\"\n\"                       pointer_mode:n  set -pointer_mode to n. same as \\\"pm\\\"\\n\"\n\"                       input_skip:n    set -input_skip to n.\\n\"\n\"                       allinput        enable  use of -allinput mode.\\n\"\n\"                       noallinput      disable use of -allinput mode.\\n\"\n\"                       input_eagerly   enable  use of -input_eagerly mode.\\n\"\n\"                       noinput_eagerly disable use of -input_eagerly mode.\\n\"\n\"                       ssltimeout:n    set -ssltimeout to n.\\n\"\n\"                       speeds:str      set -speeds to str.\\n\"\n\"                       wmdt:str        set -wmdt to str.\\n\"\n\"                       debug_pointer   enable  -debug_pointer, same as \\\"dp\\\"\\n\"\n\"                       nodebug_pointer disable -debug_pointer, same as \\\"nodp\\\"\\n\"\n\"                       debug_keyboard   enable  -debug_keyboard, same as \\\"dk\\\"\\n\"\n\"                       nodebug_keyboard disable -debug_keyboard, same as \\\"nodk\\\"\\n\"\n\"                       keycode:n       inject keystroke 'keycode' (xmodmap -pk)\\n\"\n\"                       keycode:n,down  inject 'keycode' (down=0,1)\\n\"\n\"                       keysym:str      inject keystroke 'keysym' (number/name)\\n\"\n\"                       keysym:str,down inject 'keysym' (down=0,1)\\n\"\n\"                       ptr:x,y,mask    inject pointer event x, y, button-mask\\n\"\n\"                       fakebuttonevent:button,down direct XTestFakeButtonEvent.\\n\"\n\"                       sleep:t         sleep floating point time t.\\n\"\n\"                       get_xprop:p     get X property named 'p'.\\n\"\n\"                       set_xprop:p:val set X property named 'p' to 'val'.\\n\"\n\"                                       p -> id=NNN:p for hex/dec window id.\\n\"\n\"                       wininfo:id      get info about X window id.  use 'root'\\n\"\n\"                                       for root window, use +id for children.\\n\"\n\"                       grab_state      get state of pointer and keyboard grab.\\n\"\n\"                       pointer_pos     print XQueryPointer x,y cursor position.\\n\"\n\"                       pointer_x       print XQueryPointer x cursor position.\\n\"\n\"                       pointer_y       print XQueryPointer y cursor position.\\n\"\n\"                       pointer_same    print XQueryPointer ptr on same screen.\\n\"\n\"                       pointer_root    print XQueryPointer curr ptr rootwin.\\n\"\n\"                       pointer_mask    print XQueryPointer button and mods mask\\n\"\n\"                       mouse_x         print x11vnc's idea of cursor position.\\n\"\n\"                       mouse_y         print x11vnc's idea of cursor position.\\n\"\n\"                       noop            do nothing.\\n\"\n\"                       defer:n         set -defer to n ms,same as deferupdate:n\\n\"\n\"                       wait:n          set -wait to n ms.\\n\"\n\"                       extra_fbur:n    set -extra_fbur to n.\\n\"\n\"                       wait_ui:f       set -wait_ui factor to f.\\n\"\n\"                       setdefer:n      set -setdefer to -2,-1,0,1, or 2.\\n\"\n\"                       wait_bog        disable -nowait_bog mode.\\n\"\n\"                       nowait_bog      enable  -nowait_bog mode.\\n\"\n\"                       slow_fb:f       set -slow_fb to f seconds.\\n\"\n\"                       xrefresh:f      set -xrefresh to f seconds.\\n\"\n\"                       readtimeout:n   set read timeout to n seconds.\\n\"\n\"                       nap             enable  -nap mode.\\n\"\n\"                       nonap           disable -nap mode.\\n\"\n\"                       sb:n            set -sb to n s, same as screen_blank:n\\n\"\n\"                       fbpm            disable -nofbpm mode.\\n\"\n\"                       nofbpm          enable  -nofbpm mode.\\n\"\n\"                       dpms            disable -nodpms mode.\\n\"\n\"                       nodpms          enable  -nodpms mode.\\n\"\n\"                       forcedpms       enable  -forcedpms mode.\\n\"\n\"                       noforcedpms     disable -forcedpms mode.\\n\"\n\"                       clientdpms      enable  -clientdpms mode.\\n\"\n\"                       noclientdpms    disable -clientdpms mode.\\n\"\n\"                       noserverdpms    enable  -noserverdpms mode.\\n\"\n\"                       serverdpms      disable -noserverdpms mode.\\n\"\n\"                       noultraext      enable  -noultraext mode.\\n\"\n\"                       ultraext        disable -noultraext mode.\\n\"\n\"                       chatwindow      enable  local chatwindow mode.\\n\"\n\"                       nochatwindow    disable local chatwindow mode.\\n\"\n\"                       chaton          begin chat using local window.\\n\"\n\"                       chatoff         end   chat using local window.\\n\"\n\"                       xdamage         enable  xdamage polling hints.\\n\"\n\"                       noxdamage       disable xdamage polling hints.\\n\"\n\"                       xd_area:A       set -xd_area max pixel area to \\\"A\\\"\\n\"\n\"                       xd_mem:f        set -xd_mem remembrance to \\\"f\\\"\\n\"\n\"                       fs:frac         set -fs fraction to \\\"frac\\\", e.g. 0.5\\n\"\n\"                       gaps:n          set -gaps to n.\\n\"\n\"                       grow:n          set -grow to n.\\n\"\n\"                       fuzz:n          set -fuzz to n.\\n\"\n\"                       snapfb          enable  -snapfb mode.\\n\"\n\"                       nosnapfb        disable -snapfb mode.\\n\"\n\"                       rawfb:str       set -rawfb mode to \\\"str\\\".\\n\"\n\"                       uinput_accel:f  set uinput_accel to f.\\n\"\n\"                       uinput_thresh:n set uinput_thresh to n.\\n\"\n\"                       uinput_reset:n  set uinput_reset to n ms.\\n\"\n\"                       uinput_always:n set uinput_always to 1/0.\\n\"\n\"                       progressive:n   set LibVNCServer -progressive slice\\n\"\n\"                                       height parameter to n.\\n\"\n\"                       desktop:str     set -desktop name to str for new clients.\\n\"\n\"                       rfbport:n       set -rfbport to n.\\n\"\n\"                       macnosaver      enable  -macnosaver mode.\\n\"\n\"                       macsaver        disable -macnosaver mode.\\n\"\n\"                       macnowait       enable  -macnowait  mode.\\n\"\n\"                       macwait         disable -macnowait  mode.\\n\"\n\"                       macwheel:n      set -macwheel to n.\\n\"\n\"                       macnoswap       enable  -macnoswap mouse button mode.\\n\"\n\"                       macswap         disable -macnoswap mouse button mode.\\n\"\n\"                       macnoresize     enable  -macnoresize mode.\\n\"\n\"                       macresize       disable -macnoresize mode.\\n\"\n\"                       maciconanim:n   set -maciconanim to n.\\n\"\n\"                       macmenu         enable  -macmenu  mode.\\n\"\n\"                       macnomenu       disable -macmenu  mode.\\n\"\n\"                       macuskbd        enable  -macuskbd mode.\\n\"\n\"                       macnouskbd      disable -macuskbd mode.\\n\"\n/* access */\n\"                       httpport:n      set -httpport to n.\\n\"\n\"                       httpdir:dir     set -httpdir to dir (and enable http).\\n\"\n\"                       enablehttpproxy   enable  -enablehttpproxy mode.\\n\"\n\"                       noenablehttpproxy disable -enablehttpproxy mode.\\n\"\n\"                       alwaysshared     enable  -alwaysshared mode.\\n\"\n\"                       noalwaysshared   disable -alwaysshared mode.\\n\"\n\"                                        (may interfere with other options)\\n\"\n\"                       nevershared      enable  -nevershared mode.\\n\"\n\"                       nonevershared    disable -nevershared mode.\\n\"\n\"                                        (may interfere with other options)\\n\"\n\"                       dontdisconnect   enable  -dontdisconnect mode.\\n\"\n\"                       nodontdisconnect disable -dontdisconnect mode.\\n\"\n\"                                        (may interfere with other options)\\n\"\n\"                       debug_xevents   enable  debugging X events.\\n\"\n\"                       nodebug_xevents disable debugging X events.\\n\"\n\"                       debug_xdamage   enable  debugging X DAMAGE mechanism.\\n\"\n\"                       nodebug_xdamage disable debugging X DAMAGE mechanism.\\n\"\n\"                       debug_wireframe enable   debugging wireframe mechanism.\\n\"\n\"                       nodebug_wireframe disable debugging wireframe mechanism.\\n\"\n\"                       debug_scroll    enable  debugging scrollcopy mechanism.\\n\"\n\"                       nodebug_scroll  disable debugging scrollcopy mechanism.\\n\"\n\"                       debug_tiles     enable  -debug_tiles\\n\"\n\"                       nodebug_tiles   disable -debug_tiles\\n\"\n\"                       debug_grabs     enable  -debug_grabs\\n\"\n\"                       nodebug_grabs   disable -debug_grabs\\n\"\n\"                       debug_sel       enable  -debug_sel\\n\"\n\"                       nodebug_sel     disable -debug_sel\\n\"\n\"                       debug_ncache    enable  -debug_ncache\\n\"\n\"                       nodebug_ncache  disable -debug_ncache\\n\"\n\"                       dbg             enable  -dbg crash shell\\n\"\n\"                       nodbg           disable -dbg crash shell\\n\"\n\"\\n\"\n\"                       noremote        disable the -remote command processing,\\n\"\n\"                                       it cannot be turned back on.\\n\"\n\"\\n\"\n\"                       bcx_xattach:str  This remote control command is for\\n\"\n\"                       use with the BARCO xattach program or the x2x program.\\n\"\n\"                       Both of these programs are for 'pointer and keyboard'\\n\"\n\"                       sharing between separate X displays.  In general the\\n\"\n\"                       two displays are usually nearby, e.g. on the same desk,\\n\"\n\"                       and this allows the user to share a single pointer and\\n\"\n\"                       keyboard between them.  The user moves the mouse to\\n\"\n\"                       an edge and then the mouse pointer appears to 'jump'\\n\"\n\"                       to the other display screen.  Thus it emulates what a\\n\"\n\"                       single X server would do for two screens (e.g. :0.0 and\\n\"\n\"                       :0.1) The illusion of a single Xserver with multiple\\n\"\n\"                       screens is achieved by forwarding events to the 2nd\\n\"\n\"                       one via the XTEST extension.\\n\"\n\"\\n\"\n\"                       What the x11vnc bcx_xattach command does is to perform\\n\"\n\"                       some pointer movements to try to INDUCE xattach/x2x\\n\"\n\"                       to 'jump' to the other display.  In what follows the\\n\"\n\"                       'master' display refers to the one that when it has\\n\"\n\"                       'focus' it is basically doing nothing besides watching\\n\"\n\"                       for the mouse to go over an edge.  The 'slave'\\n\"\n\"                       display refers to the one to which the mouse and\\n\"\n\"                       keyboard is redirected to once an edge in the master\\n\"\n\"                       has been crossed.  Note that the x11vnc executing the\\n\"\n\"                       bcx_xattach command MUST be the one connected to the\\n\"\n\"                       *master* display.\\n\"\n\"\\n\"\n\"                       Also note that when input is being redirected (via\\n\"\n\"                       XTEST) from the master display to the slave display,\\n\"\n\"                       the master display's pointer and keyboard are *grabbed*\\n\"\n\"                       by xattach/x2x.  x11vnc can use this info to verify that\\n\"\n\"                       the master/slave mode change has taken place correctly.\\n\"\n\"                       If you specify the \\\"ifneeded\\\" option (see below)\\n\"\n\"                       and the initial grab state is that of the desired\\n\"\n\"                       final state, then no pointer movements are injected\\n\"\n\"                       and \\\"DONE,GRAB_OK\\\" is returned.\\n\"\n\"\\n\"\n\"                       \\\"str\\\" must contain one of \\\"up\\\", \\\"down\\\", \\\"left\\\",\\n\"\n\"                       or \\\"right\\\" to indicate the direction of the 'jump'.\\n\"\n\"                       \\\"str\\\" must also contain one of \\\"master_to_slave\\\"\\n\"\n\"                       or \\\"slave_to_master\\\" to indicate the type of mode\\n\"\n\"                       change induced by the jump.  Use \\\"M2S\\\" and \\\"S2M\\\"\\n\"\n\"                       as shorter aliases.\\n\"\n\"\\n\"\n\"                       \\\"str\\\" may be a \\\"+\\\" separated list of additional\\n\"\n\"                       tuning options.  The \\\"shift=n\\\" option indicates an\\n\"\n\"                       offset shift position away from (0,0) (default 20).\\n\"\n\"                       \\\"final=x+y\\\" specifies the final position of the cursor\\n\"\n\"                       at the end of the normal move sequence; default 30+30.\\n\"\n\"                       \\\"extra_move=x+y\\\" means to do one more pointer move\\n\"\n\"                       after \\\"final\\\" to x+y.  \\\"dt=n\\\" sets the sleep time\\n\"\n\"                       in milliseconds between pointer moves (default: 40ms)\\n\"\n\"                       \\\"retry=n\\\" specifies the maximum number of retries if\\n\"\n\"                       the grab state change fails. \\\"ifneeded\\\" means to not\\n\"\n\"                       apply the pointer movements if the initial grab state is\\n\"\n\"                       that of the desired final state. \\\"nograbcheck\\\" means\\n\"\n\"                       to not check if the grab state changed as expected and\\n\"\n\"                       only apply the pointer movements (default is to check\\n\"\n\"                       the grab states.)\\n\"\n\"\\n\"\n\"                       If you do not specify \\\"up\\\", etc., to bcx_xattach\\n\"\n\"                       nothing will be attempted and the command returns\\n\"\n\"                       the string FAIL,NO_DIRECTION_SPECIFIED.  If you do\\n\"\n\"                       not specify \\\"master_to_slave\\\" or \\\"M2S\\\", etc., to\\n\"\n\"                       bcx_xattach nothing will be attempted and the command\\n\"\n\"                       returns the string FAIL,NO_MODE_CHANGE_SPECIFIED.\\n\"\n\"\\n\"\n\"                       Otherwise, the returned string will contain \\\"DONE\\\".\\n\"\n\"                       It will be \\\"DONE,GRAB_OK\\\" if the grab state changed\\n\"\n\"                       as expected (or if \\\"ifneeded\\\" was supplied and\\n\"\n\"                       the initial grab state was already the desired\\n\"\n\"                       one.)  If the initial grab state was incorrect,\\n\"\n\"                       but the final grab state was correct then it is\\n\"\n\"                       \\\"DONE,GRAB_FAIL_INIT\\\".  If the initial grab state\\n\"\n\"                       was correct, but the final grab state was incorrect\\n\"\n\"                       then it is \\\"DONE,GRAB_FAIL_FINAL\\\".  If both are\\n\"\n\"                       incorrect it will be \\\"DONE,GRAB_FAIL\\\".  Under grab\\n\"\n\"                       failure the string will be followed by \\\":p1,k1-p2,k2\\\"\\n\"\n\"                       where  p1,k1 indicates the initial pointer and keyboard\\n\"\n\"                       grab states and p2,k2 the final ones. If GRAB_FAIL or\\n\"\n\"                       GRAB_FAIL_FINAL occurs, the action will be retried up\\n\"\n\"                       to 3 times; trying to reset the state and sleeping a\\n\"\n\"                       bit between each try.  Set retry=n to adjust the number\\n\"\n\"                       of retries, zero to disable retries.\\n\"\n\"\\n\"\n\"                       Examples:\\n\"\n\"                           -R bcx_xattach:down+M2S\\n\"\n\"                           -R bcx_xattach:up+S2M\\n\"\n\"                           -R bcx_xattach:up+S2M+nograbcheck+dt=30\\n\"\n\"                           -R bcx_xattach:down+M2S+extra_move=100+100\\n\"\n\"\\n\"\n\"                       or use -Q instead of -R to retrieve the result text.\\n\"\n\"\\n\"\n\"                       End of the bcx_xattach:str description.\\n\"\n\"\\n\"\n\"                       The vncconnect(1) command from standard VNC\\n\"\n\"                       distributions may also be used if string is prefixed\\n\"\n\"                       with \\\"cmd=\\\" E.g. 'vncconnect cmd=stop'.  Under some\\n\"\n\"                       circumstances xprop(1) can used if it supports -set\\n\"\n\"                       (see the FAQ).\\n\"\n\"\\n\"\n\"                       If \\\"-connect /path/to/file\\\" has been supplied to the\\n\"\n\"                       running x11vnc server then that file can be used as a\\n\"\n\"                       communication channel (this is the only way to remote\\n\"\n\"                       control one of many x11vnc's polling the same X display)\\n\"\n\"                       Simply run: 'x11vnc -connect /path/to/file -remote ...'\\n\"\n\"                       or you can directly write to the file via something\\n\"\n\"                       like: \\\"echo cmd=stop > /path/to/file\\\", etc.\\n\"\n\"\\n\"\n\"-query variable        Like -remote, except just query the value of\\n\"\n\"                       \\\"variable\\\".  \\\"-Q\\\" is an alias for \\\"-query\\\".\\n\"\n\"                       Multiple queries can be done by separating variables\\n\"\n\"                       by commas, e.g. -query var1,var2. The results come\\n\"\n\"                       back in the form ans=var1:value1,ans=var2:value2,...\\n\"\n\"                       to the standard output.  If a variable is read-only,\\n\"\n\"                       it comes back with prefix \\\"aro=\\\" instead of \\\"ans=\\\".\\n\"\n\"\\n\"\n\"                       Some -remote commands are pure actions that do not make\\n\"\n\"                       sense as variables, e.g. \\\"stop\\\" or \\\"disconnect\\\", in\\n\"\n\"                       these cases the value returned is \\\"N/A\\\".  To direct a\\n\"\n\"                       query straight to the X11VNC_REMOTE property or connect\\n\"\n\"                       file use \\\"qry=...\\\" instead of \\\"cmd=...\\\"\\n\"\n\"\\n\"\n\"                       ans= stop quit exit shutdown ping resend_cutbuffer\\n\"\n\"                       resend_clipboard resend_primary blacken zero refresh\\n\"\n\"                       reset close disconnect id_cmd id sid waitmapped\\n\"\n\"                       nowaitmapped clip flashcmap noflashcmap shiftcmap\\n\"\n\"                       truecolor notruecolor overlay nooverlay overlay_cursor\\n\"\n\"                       overlay_yescursor nooverlay_nocursor nooverlay_cursor\\n\"\n\"                       nooverlay_yescursor overlay_nocursor 8to24 no8to24\\n\"\n\"                       8to24_opts 24to32 no24to32 visual scale scale_cursor\\n\"\n\"                       viewonly noviewonly shared noshared forever noforever\\n\"\n\"                       once timeout tightfilexfer notightfilexfer ultrafilexfer\\n\"\n\"                       noultrafilexfer rfbversion deny lock nodeny unlock avahi\\n\"\n\"                       mdns zeroconf noavahi nomdns nozeroconf connect proxy\\n\"\n\"                       allowonce allow noipv6 ipv6 noipv4 ipv4 no6 6 localhost\\n\"\n\"                       nolocalhost listen lookup nolookup accept afteraccept\\n\"\n\"                       gone shm noshm flipbyteorder noflipbyteorder onetile\\n\"\n\"                       noonetile solid_color solid nosolid blackout xinerama\\n\"\n\"                       noxinerama xtrap noxtrap xrandr noxrandr xrandr_mode\\n\"\n\"                       rotate padgeom quiet q noquiet modtweak nomodtweak xkb\\n\"\n\"                       noxkb capslock nocapslock skip_lockkeys noskip_lockkeys\\n\"\n\"                       skip_keycodes sloppy_keys nosloppy_keys skip_dups\\n\"\n\"                       noskip_dups add_keysyms noadd_keysyms clear_mods\\n\"\n\"                       noclear_mods clear_keys noclear_keys clear_all\\n\"\n\"                       clear_locks keystate remap repeat norepeat fb nofb bell\\n\"\n\"                       nobell sendbell sel nosel primary noprimary setprimary\\n\"\n\"                       nosetprimary clipboard noclipboard setclipboard\\n\"\n\"                       nosetclipboard seldir cursorshape nocursorshape\\n\"\n\"                       cursorpos nocursorpos cursor_drag nocursor_drag cursor\\n\"\n\"                       show_cursor noshow_cursor nocursor arrow xfixes noxfixes\\n\"\n\"                       xdamage noxdamage xd_area xd_mem alphacut alphafrac\\n\"\n\"                       alpharemove noalpharemove alphablend noalphablend\\n\"\n\"                       xwarppointer xwarp noxwarppointer noxwarp always_inject\\n\"\n\"                       noalways_inject buttonmap dragging nodragging ncache_cr\\n\"\n\"                       noncache_cr ncache_no_moveraise noncache_no_moveraise\\n\"\n\"                       ncache_no_dtchange noncache_no_dtchange\\n\"\n\"                       ncache_no_rootpixmap noncache_no_rootpixmap\\n\"\n\"                       ncache_reset_rootpixmap ncrp ncache_keep_anims\\n\"\n\"                       noncache_keep_anims ncache_old_wm noncache_old_wm\\n\"\n\"                       ncache_pad ncache noncache ncache_size debug_ncache\\n\"\n\"                       nodebug_ncache wireframe_mode wireframe wf nowireframe\\n\"\n\"                       nowf wireframelocal wfl nowireframelocal nowfl\\n\"\n\"                       wirecopyrect wcr nowirecopyrect nowcr scr_area\\n\"\n\"                       scr_skip scr_inc scr_keys scr_term scr_keyrepeat\\n\"\n\"                       scr_parms scrollcopyrect scr noscrollcopyrect\\n\"\n\"                       noscr fixscreen noxrecord xrecord reset_record\\n\"\n\"                       pointer_mode pm input_skip allinput noallinput\\n\"\n\"                       input_eagerly noinput_eagerly input grabkbd nograbkbd\\n\"\n\"                       grabptr nograbptr grabalways nograbalways grablocal\\n\"\n\"                       client_input ssltimeout speeds wmdt debug_pointer dp\\n\"\n\"                       nodebug_pointer nodp debug_keyboard dk nodebug_keyboard\\n\"\n\"                       nodk keycode keysym ptr fakebuttonevent sleep get_xprop\\n\"\n\"                       set_xprop wininfo bcx_xattach deferupdate defer\\n\"\n\"                       setdefer extra_fbur wait_ui wait_bog nowait_bog\\n\"\n\"                       slow_fb xrefresh wait readtimeout nap nonap sb\\n\"\n\"                       screen_blank fbpm nofbpm dpms nodpms clientdpms\\n\"\n\"                       noclientdpms forcedpms noforcedpms noserverdpms\\n\"\n\"                       serverdpms noultraext ultraext chatwindow nochatwindow\\n\"\n\"                       chaton chatoff fs gaps grow fuzz snapfb nosnapfb\\n\"\n\"                       rawfb uinput_accel uinput_thresh uinput_reset\\n\"\n\"                       uinput_always progressive rfbport http nohttp httpport\\n\"\n\"                       httpdir enablehttpproxy noenablehttpproxy alwaysshared\\n\"\n\"                       noalwaysshared nevershared noalwaysshared dontdisconnect\\n\"\n\"                       nodontdisconnect desktop debug_xevents nodebug_xevents\\n\"\n\"                       debug_xevents debug_xdamage nodebug_xdamage\\n\"\n\"                       debug_xdamage debug_wireframe nodebug_wireframe\\n\"\n\"                       debug_wireframe debug_scroll nodebug_scroll debug_scroll\\n\"\n\"                       debug_tiles dbt nodebug_tiles nodbt debug_tiles\\n\"\n\"                       debug_grabs nodebug_grabs debug_sel nodebug_sel dbg\\n\"\n\"                       nodbg macnosaver macsaver nomacnosaver macnowait macwait\\n\"\n\"                       nomacnowait macwheel macnoswap macswap nomacnoswap\\n\"\n\"                       macnoresize macresize nomacnoresize maciconanim macmenu\\n\"\n\"                       macnomenu nomacmenu macuskbd nomacuskbd noremote\\n\"\n\"\\n\"\n\"                       aro=  noop display vncdisplay icon_mode autoport\\n\"\n\"                       loop loopbg desktopname guess_desktop guess_dbus\\n\"\n\"                       http_url auth xauth users rootshift clipshift scale_str\\n\"\n\"                       scaled_x scaled_y scale_numer scale_denom scale_fac_x\\n\"\n\"                       scale_fac_y scaling_blend scaling_nomult4 scaling_pad\\n\"\n\"                       scaling_interpolate inetd privremote unsafe safer nocmds\\n\"\n\"                       passwdfile unixpw unixpw_nis unixpw_list ssl ssl_pem\\n\"\n\"                       sslverify stunnel stunnel_pem https httpsredir usepw\\n\"\n\"                       using_shm logfile o flag rmflag rc norc h help V version\\n\"\n\"                       lastmod bg sigpipe threads readrate netrate netlatency\\n\"\n\"                       pipeinput clients client_count pid ext_xtest ext_xtrap\\n\"\n\"                       ext_xrecord ext_xkb ext_xshm ext_xinerama ext_overlay\\n\"\n\"                       ext_xfixes ext_xdamage ext_xrandr rootwin num_buttons\\n\"\n\"                       button_mask mouse_x mouse_y grab_state pointer_pos\\n\"\n\"                       pointer_x pointer_y pointer_same pointer_root\\n\"\n\"                       pointer_mask bpp depth indexed_color dpy_x dpy_y wdpy_x\\n\"\n\"                       wdpy_y off_x off_y cdpy_x cdpy_y coff_x coff_y rfbauth\\n\"\n\"                       passwd viewpasswd\\n\"\n\"\\n\"\n\"-QD variable           Just like -query variable, but returns the default\\n\"\n\"                       value for that parameter (no running x11vnc server\\n\"\n\"                       is consulted)\\n\"\n\"\\n\"\n\"-sync                  By default -remote commands are run asynchronously, that\\n\"\n\"                       is, the request is posted and the program immediately\\n\"\n\"                       exits.  Use -sync to have the program wait for an\\n\"\n\"                       acknowledgement from the x11vnc server that command was\\n\"\n\"                       processed (somehow).  On the other hand -query requests\\n\"\n\"                       are always processed synchronously because they have\\n\"\n\"                       to wait for the answer.\\n\"\n\"\\n\"\n\"                       Also note that if both -remote and -query requests are\\n\"\n\"                       supplied on the command line, the -remote is processed\\n\"\n\"                       first (synchronously: no need for -sync), and then\\n\"\n\"                       the -query request is processed in the normal way.\\n\"\n\"                       This allows for a reliable way to see if the -remote\\n\"\n\"                       command was processed by querying for any new settings.\\n\"\n\"                       Note however that there is timeout of a few seconds\\n\"\n\"                       (see the next paragraph) so if the x11vnc takes longer\\n\"\n\"                       than that to process the requests the requester will\\n\"\n\"                       think that a failure has taken place.\\n\"\n\"\\n\"\n\"                       The default is to wait 3.5 seconds.  Or if cmd=stop\\n\"\n\"                       only 1.0 seconds.  If cmd matches 'script:' then it\\n\"\n\"                       will wait up to 10.0 seconds.  Set X11VNC_SYNC_TIMEOUT\\n\"\n\"                       to the number of seconds you want it to wait.\\n\"\n\"\\n\"\n\"-query_retries str     If a query fails to get a response from an x11vnc\\n\"\n\"                       server, retry up to n times.  \\\"str\\\" is specified as\\n\"\n\"                       n[:t][/match]  Optionally the delay between tries may\\n\"\n\"                       be specified by \\\"t\\\" a floating point time (default\\n\"\n\"                       0.5 seconds.)  Note: the response is not checked for\\n\"\n\"                       validity or whether it corresponds to the query sent.\\n\"\n\"                       The query \\\"ping:mystring\\\" may be used to help uniquely\\n\"\n\"                       identify the query.  Optionally, a matching string after\\n\"\n\"                       a \\\"/\\\" will be used to check the result text.  Up to\\n\"\n\"                       n retries will take place until the matching string is\\n\"\n\"                       found in the output text.  If the match string is never\\n\"\n\"                       found the program's exit code is 1; if the match is\\n\"\n\"                       found it exits with 0.  Note that there may be stdout\\n\"\n\"                       printed for each retry (i.e. multiple lines printed\\n\"\n\"                       out to stdout.)\\n\"\n\"                       Example: -query_retries 4:1.5/grab_state\\n\"\n\"\\n\"\n\"-remote_prefix str     Enable a remote-control communication channel for\\n\"\n\"                       connected VNC clients.  str is a non-empty string. If a\\n\"\n\"                       VNC client sends rfbCutText having the prefix \\\"str\\\"\\n\"\n\"                       then the part after it is processed as though it were\\n\"\n\"                       sent via 'x11vnc -remote ...'.  If it begins with\\n\"\n\"                       neither 'cmd=' nor 'qry=' then 'qry=' is assumed.\\n\"\n\"                       Any corresponding output text for that remote control\\n\"\n\"                       command is sent back to all client as rfbCutText.\\n\"\n\"                       The returned output is also prefixed with \\\"str\\\".\\n\"\n\"                       Example: -remote_prefix DO_THIS:\\n\"\n\"\\n\"\n\"                       Note that enabling -remote_prefix allows the remote\\n\"\n\"                       VNC viewers to run x11vnc -remote commands.  Do not\\n\"\n\"                       use this option if they are not to be trusted.\\n\"\n\"\\n\"\n\"-noremote              Do not process any remote control commands or queries.\\n\"\n\"-yesremote             Do process remote control commands or queries.\\n\"\n\"                       Default: %s\\n\"\n\"\\n\"\n\"                       A note about security wrt remote control commands.\\n\"\n\"                       If someone can connect to the X display and change\\n\"\n\"                       the property X11VNC_REMOTE, then they can remotely\\n\"\n\"                       control x11vnc.  Normally access to the X display is\\n\"\n\"                       protected.  Note that if they can modify X11VNC_REMOTE\\n\"\n\"                       on the X server, they have enough permissions to also\\n\"\n\"                       run their own x11vnc and thus have complete control\\n\"\n\"                       of the desktop.  If the  \\\"-connect /path/to/file\\\"\\n\"\n\"                       channel is being used, obviously anyone who can write\\n\"\n\"                       to /path/to/file can remotely control x11vnc.  So be\\n\"\n\"                       sure to protect the X display and that file's write\\n\"\n\"                       permissions.  See -privremote below.\\n\"\n\"\\n\"\n\"                       If you are paranoid and do not think -noremote is\\n\"\n\"                       enough, to disable the X11VNC_REMOTE property channel\\n\"\n\"                       completely use -novncconnect, or use the -safer option\\n\"\n\"                       that shuts many things off.\\n\"\n\"\\n\"\n\"-unsafe                A few remote commands are disabled by default\\n\"\n\"                       (currently: id:pick, accept:<cmd>, gone:<cmd>, and\\n\"\n\"                       rawfb:setup:<cmd>) because they are associated with\\n\"\n\"                       running external programs.  If you specify -unsafe, then\\n\"\n\"                       these remote-control commands are allowed.  Note that\\n\"\n\"                       you can still specify these parameters on the command\\n\"\n\"                       line, they just cannot be invoked via remote-control.\\n\"\n\"-safer                 Equivalent to: -novncconnect -noremote and prohibiting\\n\"\n\"                       -gui and the -connect file. Shuts off communication\\n\"\n\"                       channels.\\n\"\n\"-privremote            Perform some sanity checks and disable remote-control\\n\"\n\"                       commands if it appears that the X DISPLAY and/or\\n\"\n\"                       connectfile can be accessed by other users.  Once\\n\"\n\"                       remote-control is disabled it cannot be turned back on.\\n\"\n\"-nocmds                No external commands (e.g. system(3), popen(3), exec(3))\\n\"\n\"                       will be run at all.\\n\"\n\"-allowedcmds list      \\\"list\\\" contains a comma separated list of the only\\n\"\n\"                       external commands that can be run.  The full list of\\n\"\n\"                       associated options is:\\n\"\n\"\\n\"\n\"                        stunnel, ssl, unixpw, WAIT, zeroconf, id, accept,\\n\"\n\"                        afteraccept, gone, pipeinput, v4l-info, rawfb-setup,\\n\"\n\"                        dt, gui, ssh, storepasswd, passwdfile, custom_passwd,\\n\"\n\"                        findauth, crash.\\n\"\n\"\\n\"\n\"                       See each option's help to learn the associated external\\n\"\n\"                       command.  Note that the -nocmds option takes precedence\\n\"\n\"                       and disables all external commands.\\n\"\n\"\\n\"\n\"-deny_all              For use with -remote nodeny: start out denying all\\n\"\n\"                       incoming clients until \\\"-remote nodeny\\\" is used to\\n\"\n\"                       let them in.\\n\"\n\"\\n\"\n\"%s\\n\"\n\"\\n\"\n\"These options are passed to LibVNCServer:\\n\"\n\"\\n\"\n;\n\t/* have both our help and rfbUsage to stdout for more(1), etc. */\n\tdup2(1, 2);\n\n\t/* register extension(s) to get their help output */\n#ifdef LIBVNCSERVER_WITH_TIGHTVNC_FILETRANSFER\n\trfbRegisterTightVNCFileTransferExtension();\n#endif\n\n\tif (mode == 1) {\n\t\tchar *p;\t\n\t\tint l = 0;\n\t\tfprintf(stderr, \"x11vnc: allow VNC connections to real \"\n\t\t    \"X11 displays. %s\\n\\nx11vnc options:\\n\", lastmod);\n\t\tp = strtok(help, \"\\n\");\n\t\twhile (p) {\n\t\t\tint w = 23;\n\t\t\tchar tmp[100];\n\t\t\tif (p[0] == '-') {\n\t\t\t\tmemset(tmp, 0, sizeof(tmp));\n\t\t\t\tstrncpy(tmp, p, w);\n\t\t\t\tfprintf(stderr, \"  %s\", tmp);\n\t\t\t\tl++;\n\t\t\t\tif (l % 3 == 0) {\n\t\t\t\t\tfprintf(stderr, \"\\n\");\n\t\t\t\t}\n\t\t\t}\n\t\t\tp = strtok(NULL, \"\\n\");\n\t\t}\n\t\tfprintf(stderr, \"\\n\\nLibVNCServer options:\\n\");\n\t\trfbUsage();\n\t\tfprintf(stderr, \"\\n\");\n\t\texit(1);\n\t}\n#if 1\n\tfprintf(stderr, help, lastmod,\n\t\tPOLL_8TO24_DELAY,\n\t\tscaling_copyrect ? \":cr\":\":nocr\",\n\t\tview_only ? \"on\":\"off\",\n\t\tshared ? \"on\":\"off\",\n\t\tvnc_connect ? \"-vncconnect\":\"-novncconnect\",\n\t\txinerama ? \"-xinerama\":\"-noxinerama\",\n\t\tuse_modifier_tweak ? \"-modtweak\":\"-nomodtweak\",\n\t\tskip_duplicate_key_events ? \"-skip_dups\":\"-noskip_dups\",\n\t\tadd_keysyms ? \"-add_keysyms\":\"-noadd_keysyms\",\n\t\tno_autorepeat ? \"-norepeat\":\"-repeat\",\n\t\talt_arrow_max, alt_arrow,\n\t\talpha_threshold,\n\t\talpha_frac,\n\t\tcursor_pos_updates ? \"-cursorpos\":\"-nocursorpos\",\n\t\twireframe ? \"-wireframe\":\"-nowireframe\",\n\t\tWIREFRAME_PARMS,\n\t\twireframe_copyrect_default,\n\t\tscroll_copyrect_default,\n\t\tscrollcopyrect_min_area,\n\t\tscroll_skip_str0 ? scroll_skip_str0 : \"(empty)\",\n\t\tscroll_term_str0,\n\t\tmax_keyrepeat_str0,\n\t\tSCROLL_COPYRECT_PARMS,\n\t\tpointer_mode_max, pointer_mode,\n\t\tui_skip,\n\t\tdefer_update,\n\t\twaitms,\n\t\twait_ui,\n\t\ttake_naps ? \"take naps\":\"no naps\",\n\t\tscreen_blank,\n\t\trfbMaxClientWait/1000,\n\t\twatch_fbpm ? \"-nofbpm\":\"-fbpm\",\n\t\twatch_dpms ? \"-nodpms\":\"-dpms\",\n\t\txdamage_max_area, NSCAN, xdamage_memory,\n\t\tuse_threads ? \"-threads\":\"-nothreads\",\n\t\tfs_frac,\n\t\tgaps_fill,\n\t\tgrow_fill,\n\t\ttile_fuzz,\n\t\taccept_remote_cmds ? \"-yesremote\":\"-noremote\",\n\t\t\"\"\n\t);\n#else\n\tfprintf(stderr, \"%s\", help);\n#endif\n\n\trfbUsage();\n#endif\n\texit(1);\n}",
          "includes": [
            "#include \"cursor.h\"",
            "#include \"xdamage.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void print_help(int mode);",
            "void xopen_display_fail_message(char *disp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cursor.h\"\n#include \"xdamage.h\"\n#include \"x11vnc.h\"\n\nvoid print_help(int mode);\nvoid xopen_display_fail_message(char *disp);\n\nvoid print_help(int mode) {\n#if !SKIP_HELP\n\tchar help[] = \n\"\\n\"\n\"x11vnc: allow VNC connections to real X11 displays. %s\\n\"\n\"\\n\"\n\"(type \\\"x11vnc -opts\\\" to just list the options.)\\n\"\n\"\\n\"\n\"Typical usage is:\\n\"\n\"\\n\"\n\"   Run this command in a shell on the remote machine \\\"far-host\\\"\\n\"\n\"   with X session you wish to view:\\n\"\n\"\\n\"\n\"       x11vnc -display :0\\n\"\n\"\\n\"\n\"   Then run this in another window on the machine you are sitting at:\\n\"\n\"\\n\"\n\"       vncviewer far-host:0\\n\"\n\"\\n\"\n\"Once x11vnc establishes connections with the X11 server and starts listening\\n\"\n\"as a VNC server it will print out a string: PORT=XXXX where XXXX is typically\\n\"\n\"5900 (the default VNC server port).  One would next run something like\\n\"\n\"this on the local machine: \\\"vncviewer hostname:N\\\" where \\\"hostname\\\" is\\n\"\n\"the name of the machine running x11vnc and N is XXXX - 5900, i.e. usually\\n\"\n\"\\\"vncviewer hostname:0\\\".\\n\"\n\"\\n\"\n\"By default x11vnc will not allow the screen to be shared and it will exit\\n\"\n\"as soon as the client disconnects.  See -shared and -forever below to override\\n\"\n\"these protections.  See the FAQ for details how to tunnel the VNC connection\\n\"\n\"through an encrypted channel such as ssh(1).  In brief:\\n\"\n\"\\n\"\n\"       ssh -t -L 5900:localhost:5900 far-host 'x11vnc -localhost -display :0'\\n\"\n\"\\n\"\n\"       vncviewer -encodings 'copyrect tight zrle hextile' localhost:0\\n\"\n\"\\n\"\n\"Also, use of a VNC password (-rfbauth or -passwdfile) is strongly recommended.\\n\"\n\"\\n\"\n\"For additional info see: http://www.karlrunge.com/x11vnc/\\n\"\n\"                    and  http://www.karlrunge.com/x11vnc/faq.html\\n\"\n\"\\n\"\n\"\\n\"\n\"Config file support: if the file $HOME/.x11vncrc exists then each line in\\n\"\n\"it is treated as a single command line option.  Disable with -norc.  For\\n\"\n\"each option name, the leading character \\\"-\\\" is not required.  E.g. a line\\n\"\n\"that is either \\\"forever\\\" or \\\"-forever\\\" may be used and are equivalent.\\n\"\n\"Likewise \\\"wait 100\\\" or \\\"-wait 100\\\" are acceptable and equivalent lines.\\n\"\n\"The \\\"#\\\" character comments out to the end of the line in the usual way\\n\"\n\"(backslash it for a literal).  Leading and trailing whitespace is trimmed off.\\n\"\n\"Lines may be continued with a \\\"\\\\\\\" as the last character of a line (it\\n\"\n\"becomes a space character).\\n\"\n\"\\n\"\n\"Options:\\n\"\n\"\\n\"\n\"-display disp          X11 server display to connect to, usually :0.  The X\\n\"\n\"                       server process must be running on same machine and\\n\"\n\"                       support MIT-SHM.  Equivalent to setting the DISPLAY\\n\"\n\"                       environment variable to \\\"disp\\\".\\n\"\n\"\\n\"\n\"                       See the description below of the \\\"-display WAIT:...\\\"\\n\"\n\"                       extensions, where alias \\\"-find\\\" will find the user's\\n\"\n\"                       display automatically, and \\\"-create\\\" will create a\\n\"\n\"                       Xvfb session if no session is found.\\n\"\n\"\\n\"\n\"-auth file             Set the X authority file to be \\\"file\\\", equivalent to\\n\"\n\"                       setting the XAUTHORITY environment variable to \\\"file\\\"\\n\"\n\"                       before startup.  Same as -xauth file.  See Xsecurity(7),\\n\"\n\"                       xauth(1) man pages for more info.\\n\"\n\"\\n\"\n\"                       Use '-auth guess' to have x11vnc use its -findauth\\n\"\n\"                       mechanism (described below) to try to guess the\\n\"\n\"                       XAUTHORITY filename and use it.\\n\"\n\"\\n\"\n\"                       XDM/GDM/KDM: if you are running x11vnc as root and want\\n\"\n\"                       to find the XAUTHORITY before anyone has logged into an\\n\"\n\"                       X session yet, use: x11vnc -env FD_XDM=1 -auth guess ...\\n\"\n\"                       (This will also find the XAUTHORITY if a user is already\\n\"\n\"                       logged into the X session.)  When running as root,\\n\"\n\"                       FD_XDM=1 will be tried if the initial -auth guess fails.\\n\"\n\"\\n\"\n\"-N                     If the X display is :N, try to set the VNC display to\\n\"\n\"                       also be :N This just sets the -rfbport option to 5900+N\\n\"\n\"                       The program will exit immediately if that port is not\\n\"\n\"                       available. The -N option only works with normal -display\\n\"\n\"                       usage, e.g. :0 or :8, -N is ignored in the -display\\n\"\n\"                       WAIT:..., -create, -find, -svc, -redirect, etc modes.\\n\"\n\"\\n\"\n\"-autoport n            Automatically probe for a free VNC port starting at n.\\n\"\n\"                       The default is to start probing at 5900.  Use this to\\n\"\n\"                       stay away from other VNC servers near 5900.\\n\"\n\"\\n\"\n\"-rfbport str           The VNC port to listen on (a LibVNCServer option), e.g.\\n\"\n\"                       5900, 5901, etc.  If specified as \\\"-rfbport PROMPT\\\"\\n\"\n\"                       then the x11vnc -gui is used to prompt the user to\\n\"\n\"                       enter the port number.\\n\"\n\"\\n\"\n#if X11VNC_IPV6\n\"-6                     IPv6 listening support.  In addition to IPv4, the\\n\"\n\"                       IPv6 address is listened on for incoming connections.\\n\"\n\"                       The same port number as IPv4 is used.\\n\"\n\"\\n\"\n#if X11VNC_LISTEN6\n\"                       NOTE:  This x11vnc binary was compiled to have the\\n\"\n\"                       \\\"-6\\\" IPv6 listening mode ENABLED by default (CPPFLAGS\\n\"\n\"                       -DX11VNC_LISTEN6=1).  So to disable IPv6 listening mode\\n\"\n\"                       you MUST supply the \\\"-no6\\\" option (see below.)\\n\"\n#else\n\"                       NOTE:  This x11vnc binary was compiled to have\\n\"\n\"                       the \\\"-6\\\" IPv6 listening mode DISABLED by default\\n\"\n\"                       (CPPFLAGS -DX11VNC_LISTEN6=0).\\n\"\n#endif\n\"\\n\"\n\"                       The \\\"-6\\\" mode works for both normal connections and\\n\"\n\"                       -ssl encrypted ones.  Nearly everything is supported\\n\"\n\"                       for the IPv6 case, but there are a few exceptions.\\n\"\n\"                       See -stunnel for its IPv6 support.\\n\"\n\"\\n\"\n\"                       Currently, for absolutely everything to work correctly\\n\"\n\"                       the machine may need to have some IPv4 support, at the\\n\"\n\"                       least for the loopback interface.  However, for nearly\\n\"\n\"                       all usage modes no IPv4 support is required. See -noipv4.\\n\"\n\"\\n\"\n\"                       If you have trouble compiling or running in IPv6 mode,\\n\"\n\"                       set -DX11VNC_IPV6=0 in CPPFLAGS when configuring to\\n\"\n\"                       disable IPv6 support.\\n\"\n\"\\n\"\n\"-no6                   Disable IPv6 listening support (only useful if the\\n\"\n\"                       \\\"-6\\\" mode is compiled in to be the default; see the\\n\"\n\"                       X11VNC_LISTEN6 description above under \\\"-6\\\".)\\n\"\n\"\\n\"\n\"-noipv6                Do not try to use IPv6 for any listening or connecting\\n\"\n\"                       sockets.  This includes both the listening service\\n\"\n\"                       port(s) and outgoing connections from -connect,\\n\"\n\"                       -connect_or_exit, or -proxy.  Use this if you are having\\n\"\n\"                       problems due to IPv6.\\n\"\n\"\\n\"\n\"-noipv4                Do not try to use IPv4 for any listening or connecting\\n\"\n\"                       sockets.  This is mainly for exploring the behavior of\\n\"\n\"                       x11vnc on an IPv6-only system, but may have other uses.\\n\"\n\"\\n\"\n#endif\n\"-reopen                If the X server connection is disconnected, try to\\n\"\n\"                       reopen the X display (up to one time.)  This is of use\\n\"\n\"                       for display managers like GDM (KillInitClients option)\\n\"\n\"                       that kill x11vnc just after the user logs into the\\n\"\n\"                       X session.  Note: the reopened state may be unstable.\\n\"\n\"                       Set X11VNC_REOPEN_DISPLAY=n to reopen n times and\\n\"\n\"                       set X11VNC_REOPEN_SLEEP_MAX to the number of seconds,\\n\"\n\"                       default 10, to keep trying to reopen the display (once\\n\"\n\"                       per second.)\\n\"\n\"\\n\"\n\"                       Update: as of 0.9.9, x11vnc tries to automatically avoid\\n\"\n\"                       being killed by the display manager by delaying creating\\n\"\n\"                       windows or using XFIXES.  So you shouldn't need to use\\n\"\n\"                       KillInitClients=false as long as you log in quickly\\n\"\n\"                       enough (within 45 seconds of connecting.)  You can\\n\"\n\"                       disable this by setting X11VNC_AVOID_WINDOWS=never.\\n\"\n\"                       You can also set it to the number of seconds to delay.\\n\"\n\"\\n\"\n\"-reflect host:N        Instead of connecting to and polling an X display,\\n\"\n\"                       connect to the remote VNC server host:N and be a\\n\"\n\"                       reflector/repeater for it.  This is useful for trying\\n\"\n\"                       to manage the case of many simultaneous VNC viewers\\n\"\n\"                       (e.g. classroom broadcasting) where, e.g. you put\\n\"\n\"                       a repeater on each network switch, etc, to improve\\n\"\n\"                       performance by distributing the load and network\\n\"\n\"                       traffic.  Implies -shared (use -noshared as a later\\n\"\n\"                       option to disable). See the discussion below under\\n\"\n\"                       -rawfb vnc:host:N for more details.\\n\"\n\"\\n\"\n\"-id windowid           Show the X window corresponding to \\\"windowid\\\" not\\n\"\n\"                       the entire display.  New windows like popup menus,\\n\"\n\"                       transient toplevels, etc, may not be seen or may be\\n\"\n\"                       clipped.  Disabling SaveUnders or BackingStore in the\\n\"\n\"                       X server may help show them.  x11vnc may crash if the\\n\"\n\"                       window is initially partially obscured, changes size,\\n\"\n\"                       is iconified, etc.  Some steps are taken to avoid this\\n\"\n\"                       and the -xrandr mechanism is used to track resizes.  Use\\n\"\n\"                       xwininfo(1) to get the window id, or use \\\"-id pick\\\"\\n\"\n\"                       to have x11vnc run xwininfo(1) for you and extract\\n\"\n\"                       the id.  The -id option is useful for exporting very\\n\"\n\"                       simple applications (e.g. the current view on a webcam).\\n\"\n\"-sid windowid          As -id, but instead of using the window directly it\\n\"\n\"                       shifts a root view to it: this shows SaveUnders menus,\\n\"\n\"                       etc, although they will be clipped if they extend beyond\\n\"\n\"                       the window.\\n\"\n\"\\n\"\n\"-appshare              Simple application sharing based on the -id/-sid\\n\"\n\"                       mechanism.  Every new toplevel window that the\\n\"\n\"                       application creates induces a new viewer window via\\n\"\n\"                       a reverse connection.  The -id/-sid and -connect\\n\"\n\"                       options are required.  Run 'x11vnc -appshare -help'\\n\"\n\"                       for more info.\\n\"\n\"\\n\"\n#if 0\n\"-freeze_when_obscured  Probably only of use in -appshare mode: if the -id/-sid\\n\"\n\"                       window is partially or fully obscured by other windows,\\n\"\n\"                       stop checking for framebuffer updates.  Mouse and\\n\"\n\"                       keyboard events are still processed and injected.\\n\"\n\"\\n\"\n#endif\n\"-clip WxH+X+Y          Only show the sub-region of the full display that\\n\"\n\"                       corresponds to the rectangle geometry with size WxH and\\n\"\n\"                       offset +X+Y.  The VNC display has size WxH (i.e. smaller\\n\"\n\"                       than the full display).  This also works for -id/-sid\\n\"\n\"                       mode where the offset is relative to the upper left\\n\"\n\"                       corner of the selected window.  An example use of this\\n\"\n\"                       option would be to split a large (e.g. Xinerama) display\\n\"\n\"                       into two parts to be accessed via separate viewers by\\n\"\n\"                       running a separate x11vnc on each part.\\n\"\n\"\\n\"\n\"                       Use '-clip xinerama0' to clip to the first xinerama\\n\"\n\"                       sub-screen (if xinerama is active).  xinerama1 for the\\n\"\n\"                       2nd sub-screen, etc.  This way you don't need to figure\\n\"\n\"                       out the WxH+X+Y of the desired xinerama sub-screen.\\n\"\n\"                       screens are sorted in increasing distance from the\\n\"\n\"                       (0,0) origin (I.e. not the Xserver's order).\\n\"\n\"\\n\"\n\"-flashcmap             In 8bpp indexed color, let the installed colormap flash\\n\"\n\"                       as the pointer moves from window to window (slow).\\n\"\n\"                       Also try the -8to24 option to avoid flash altogether.\\n\"\n\"-shiftcmap n           Rare problem, but some 8bpp displays use less than 256\\n\"\n\"                       colorcells (e.g. 16-color grayscale, perhaps the other\\n\"\n\"                       bits are used for double buffering) *and* also need to\\n\"\n\"                       shift the pixels values away from 0, .., ncells.  \\\"n\\\"\\n\"\n\"                       indicates the shift to be applied to the pixel values.\\n\"\n\"                       To see the pixel values set DEBUG_CMAP=1 to print out\\n\"\n\"                       a colormap histogram.  Example: -shiftcmap 240\\n\"\n\"-notruecolor           For 8bpp displays, force indexed color (i.e. a colormap)\\n\"\n\"                       even if it looks like 8bpp TrueColor (rare problem).\\n\"\n\"-advertise_truecolor   If the X11 display is indexed color, lie to clients\\n\"\n\"                       when they first connect by telling them it is truecolor.\\n\"\n\"                       To workaround RealVNC: inPF has colourMap but not 8bpp\\n\"\n\"                       Use '-advertise_truecolor reset' to reset client fb too.\\n\"\n\"\\n\"\n\"-visual n              This option probably does not do what you think.\\n\"\n\"                       It simply *forces* the visual used for the framebuffer;\\n\"\n\"                       this may be a bad thing... (e.g. messes up colors or\\n\"\n\"                       cause a crash). It is useful for testing and for some\\n\"\n\"                       workarounds.  n may be a decimal number, or 0x hex.\\n\"\n\"                       Run xdpyinfo(1) for the values.  One may also use\\n\"\n\"                       \\\"TrueColor\\\", etc. see <X11/X.h> for a list.  If the\\n\"\n\"                       string ends in \\\":m\\\" then for better or for worse\\n\"\n\"                       the visual depth is forced to be m.  You may want to\\n\"\n\"                       use -noshm when using this option (so XGetImage may\\n\"\n\"                       automatically translate the pixel data).\\n\"\n\"\\n\"\n\"-overlay               Handle multiple depth visuals on one screen, e.g. 8+24\\n\"\n\"                       and 24+8 overlay visuals (the 32 bits per pixel are\\n\"\n\"                       packed with 8 for PseudoColor and 24 for TrueColor).\\n\"\n\"\\n\"\n\"                       Currently -overlay only works on Solaris via\\n\"\n\"                       XReadScreen(3X11) and IRIX using XReadDisplay(3).\\n\"\n\"                       On Solaris there is a problem with image \\\"bleeding\\\"\\n\"\n\"                       around transient popup menus (but not for the menu\\n\"\n\"                       itself): a workaround is to disable SaveUnders\\n\"\n\"                       by passing the \\\"-su\\\" argument to Xsun (in\\n\"\n\"                       /etc/dt/config/Xservers).\\n\"\n\"\\n\"\n\"                       Use -overlay as a workaround for situations like these:\\n\"\n\"                       Some legacy applications require the default visual to\\n\"\n\"                       be 8bpp (8+24), or they will use 8bpp PseudoColor even\\n\"\n\"                       when the default visual is depth 24 TrueColor (24+8).\\n\"\n\"                       In these cases colors in some windows will be incorrect\\n\"\n\"                       in x11vnc unless -overlay is used.  Another use of\\n\"\n\"                       -overlay is to enable showing the exact mouse cursor\\n\"\n\"                       shape (details below).\\n\"\n\"\\n\"\n\"                       Under -overlay, performance will be somewhat slower\\n\"\n\"                       due to the extra image transformations required.\\n\"\n\"                       For optimal performance do not use -overlay, but rather\\n\"\n\"                       configure the X server so that the default visual is\\n\"\n\"                       depth 24 TrueColor and try to have all apps use that\\n\"\n\"                       visual (e.g. some apps have -use24 or -visual options).\\n\"\n\"-overlay_nocursor      Sets -overlay, but does not try to draw the exact mouse\\n\"\n\"                       cursor shape using the overlay mechanism.\\n\"\n\"\\n\"\n\"-8to24 [opts]          Try this option if -overlay is not supported on your\\n\"\n\"                       OS, and you have a legacy 8bpp app that you want to\\n\"\n\"                       view on a multi-depth display with default depth 24\\n\"\n\"                       (and is 32 bpp) OR have a default depth 8 display with\\n\"\n\"                       depth 24 overlay windows for some apps.  This option\\n\"\n\"                       may not work on all X servers and hardware (tested\\n\"\n\"                       on XFree86/Xorg mga driver and Xsun).  The \\\"opts\\\"\\n\"\n\"                       string is not required and is described below.\\n\"\n\"\\n\"\n\"                       This mode enables a hack where x11vnc monitors windows\\n\"\n\"                       within 3 levels from the root window.  If it finds\\n\"\n\"                       any that are 8bpp it extracts the indexed color\\n\"\n\"                       pixel values using XGetImage() and then applies a\\n\"\n\"                       transformation using the colormap(s) to create TrueColor\\n\"\n\"                       RGB values that it in turn inserts into bits 1-24 of\\n\"\n\"                       the framebuffer.  This creates a depth 24 \\\"view\\\"\\n\"\n\"                       of the display that is then exported via VNC.\\n\"\n\"\\n\"\n\"                       Conversely, for default depth 8 displays, the depth\\n\"\n\"                       24 regions are read by XGetImage() and everything is\\n\"\n\"                       transformed and inserted into a depth 24 TrueColor\\n\"\n\"                       framebuffer.\\n\"\n\"\\n\"\n\"                       Note that even if there are *no* depth 24 visuals or\\n\"\n\"                       windows (i.e. pure 8bpp), this mode is potentially\\n\"\n\"                       an improvement over -flashcmap because it avoids the\\n\"\n\"                       flashing and shows each window in the correct color.\\n\"\n\"\\n\"\n\"                       This method works OK, but may still have bugs and it\\n\"\n\"                       does hog resources.  If there are multiple 8bpp windows\\n\"\n\"                       using different colormaps, one may have to iconify all\\n\"\n\"                       but one for the colors to be correct.\\n\"\n\"\\n\"\n\"                       There may be painting errors for clipping and switching\\n\"\n\"                       between windows of depths 8 and 24.  Heuristics are\\n\"\n\"                       applied to try to minimize the painting errors.  One can\\n\"\n\"                       also press 3 Alt_L's in a row to refresh the screen\\n\"\n\"                       if the error does not repair itself.  Also the option\\n\"\n\"                       -fixscreen 8=3.0 or -fixscreen V=3.0 may be used to\\n\"\n\"                       periodically refresh the screen at the cost of bandwidth\\n\"\n\"                       (every 3 sec for this example).\\n\"\n\"\\n\"\n\"                       The [opts] string can contain the following settings.\\n\"\n\"                       Multiple settings are separated by commas.\\n\"\n\"\\n\"\n\"                       For for some X servers with default depth 24 a\\n\"\n\"                       speedup may be achieved via the option \\\"nogetimage\\\".\\n\"\n\"                       This enables a scheme were XGetImage() is not used\\n\"\n\"                       to retrieve the 8bpp data.  Instead, it assumes that\\n\"\n\"                       the 8bpp data is in bits 25-32 of the 32bit X pixels.\\n\"\n\"                       There is no requirement that the X server should put\\n\"\n\"                       the data there for our poll requests, but some do and\\n\"\n\"                       so the extra steps to retrieve it can be skipped.\\n\"\n\"                       Tested with mga driver with XFree86/Xorg.  For the\\n\"\n\"                       default depth 8 case this option is ignored.\\n\"\n\"\\n\"\n\"                       To adjust how often XGetImage() is used to poll the\\n\"\n\"                       non-default visual regions for changes, use the option\\n\"\n\"                       \\\"poll=t\\\" where \\\"t\\\" is a floating point time.\\n\"\n\"                       (default: %.2f)\\n\"\n\"\\n\"\n\"                       Setting the option \\\"level2\\\" will limit the search\\n\"\n\"                       for non-default visual windows to two levels from the\\n\"\n\"                       root window.  Do this on slow machines where you know\\n\"\n\"                       the window manager only imposes one extra window between\\n\"\n\"                       the app window and the root window.\\n\"\n\"\\n\"\n\"                       Also for very slow machines use \\\"cachewin=t\\\"\\n\"\n\"                       where t is a floating point amount of time to cache\\n\"\n\"                       XGetWindowAttributes results.  E.g. cachewin=5.0.\\n\"\n\"                       This may lead to the windows being unnoticed for this\\n\"\n\"                       amount of time when deiconifying, painting errors, etc.\\n\"\n\"\\n\"\n\"                       While testing on a very old SS20 these options gave\\n\"\n\"                       tolerable response: -8to24 poll=0.2,cachewin=5.0. For\\n\"\n\"                       this machine -overlay is supported and gives better\\n\"\n\"                       response.\\n\"\n\"\\n\"\n\"                       Debugging for this mode can be enabled by setting\\n\"\n\"                       \\\"dbg=1\\\", \\\"dbg=2\\\", or \\\"dbg=3\\\".\\n\"\n\"\\n\"\n\"-24to32                Very rare problem: if the framebuffer (X display\\n\"\n\"                       or -rawfb) is 24bpp instead of the usual 32bpp, then\\n\"\n\"                       dynamically transform the pixels to 32bpp.  This will be\\n\"\n\"                       slower, but can be used to work around problems where\\n\"\n\"                       VNC viewers cannot handle 24bpp (e.g. \\\"main: setPF:\\n\"\n\"                       not 8, 16 or 32 bpp?\\\").  See the FAQ for more info.\\n\"\n\"\\n\"\n\"                       In the case of -rawfb mode, the pixels are directly\\n\"\n\"                       modified by inserting a 0 byte to pad them out to 32bpp.\\n\"\n\"                       For X displays, a kludge is done that is equivalent to\\n\"\n\"                       \\\"-noshm -visual TrueColor:32\\\".  (If better performance\\n\"\n\"                       is needed for the latter, feel free to ask).\\n\"\n\"\\n\"\n\"-scale fraction        Scale the framebuffer by factor \\\"fraction\\\".  Values\\n\"\n\"                       less than 1 shrink the fb, larger ones expand it. Note:\\n\"\n\"                       the image may not be sharp and response may be slower.\\n\"\n\"                       If \\\"fraction\\\" contains a decimal point \\\".\\\" it\\n\"\n\"                       is taken as a floating point number, alternatively\\n\"\n\"                       the notation \\\"m/n\\\" may be used to denote fractions\\n\"\n\"                       exactly, e.g. -scale 2/3\\n\"\n\"\\n\"\n\"                       To scale asymmetrically in the horizontal and vertical\\n\"\n\"                       directions, specify a WxH geometry to stretch to:\\n\"\n\"                       e.g. '-scale 1024x768', or also '-scale 0.9x0.75'\\n\"\n\"\\n\"\n\"                       Scaling Options: can be added after \\\"fraction\\\" via\\n\"\n\"                       \\\":\\\", to supply multiple \\\":\\\" options use commas.\\n\"\n\"                       If you just want a quick, rough scaling without\\n\"\n\"                       blending, append \\\":nb\\\" to \\\"fraction\\\" (e.g. -scale\\n\"\n\"                       1/3:nb).  No blending is the default for 8bpp indexed\\n\"\n\"                       color, to force blending for this case use \\\":fb\\\".\\n\"\n\"\\n\"\n\"                       To disable -scrollcopyrect and -wirecopyrect under\\n\"\n\"                       -scale use \\\":nocr\\\".  If you need to to enable them use\\n\"\n\"                       \\\":cr\\\" or specify them explicitly on the command line.\\n\"\n\"                       If a slow link is detected, \\\":nocr\\\" may be applied\\n\"\n\"                       automatically.  Default: %s\\n\"\n\"\\n\"\n\"                       More esoteric options: for compatibility with vncviewers\\n\"\n\"                       the scaled width is adjusted to be a multiple of 4:\\n\"\n\"                       to disable this use \\\":n4\\\".  \\\":in\\\" use interpolation\\n\"\n\"                       scheme even when shrinking, \\\":pad\\\" pad scaled width\\n\"\n\"                       and height to be multiples of scaling denominator\\n\"\n\"                       (e.g. 3 for 2/3).\\n\"\n\"\\n\"\n\"-geometry WxH          Same as -scale WxH\\n\"\n\"\\n\"\n\"-scale_cursor frac     By default if -scale is supplied the cursor shape is\\n\"\n\"                       scaled by the same factor.  Depending on your usage,\\n\"\n\"                       you may want to scale the cursor independently of the\\n\"\n\"                       screen or not at all.  If you specify -scale_cursor\\n\"\n\"                       the cursor will be scaled by that factor.  When using\\n\"\n\"                       -scale mode to keep the cursor at its \\\"natural\\\" size\\n\"\n\"                       use \\\"-scale_cursor 1\\\".  Most of the \\\":\\\" scaling\\n\"\n\"                       options apply here as well.\\n\"\n\"\\n\"\n\"-viewonly              All VNC clients can only watch (default %s).\\n\"\n\"-shared                VNC display is shared, i.e. more than one viewer can\\n\"\n\"                       connect at the same time (default %s).\\n\"\n\"-once                  Exit after the first successfully connected viewer\\n\"\n\"                       disconnects, opposite of -forever. This is the Default.\\n\"\n\"-forever               Keep listening for more connections rather than exiting\\n\"\n\"                       as soon as the first client(s) disconnect. Same as -many\\n\"\n\"\\n\"\n\"                       To get the standard non-shared VNC behavior where when\\n\"\n\"                       a new VNC client connects the existing VNC client is\\n\"\n\"                       dropped use:  -nevershared -forever   This method can\\n\"\n\"                       also be used to guard against hung TCP connections that\\n\"\n\"                       do not go away.\\n\"\n\"\\n\"\n\"-loop                  Create an outer loop restarting the x11vnc process\\n\"\n\"                       whenever it terminates.  -bg and -inetd are ignored\\n\"\n\"                       in this mode (however see -loopbg below).\\n\"\n\"\\n\"\n\"                       Useful for continuing even if the X server terminates\\n\"\n\"                       and restarts (at that moment the process will need\\n\"\n\"                       permission to reconnect to the new X server of course).\\n\"\n\"\\n\"\n\"                       Use, e.g., -loop100 to sleep 100 millisecs between\\n\"\n\"                       restarts, etc.  Default is 2000ms (i.e. 2 secs) Use,\\n\"\n\"                       e.g. -loop300,5 to sleep 300 ms and only loop 5 times.\\n\"\n\"\\n\"\n\"                       If -loopbg (plus any numbers) is specified instead,\\n\"\n\"                       the \\\"-bg\\\" option is implied and the mode approximates\\n\"\n\"                       inetd(8) usage to some degree.  In this case when\\n\"\n\"                       it goes into the background any listening sockets\\n\"\n\"                       (i.e. ports 5900, 5800) are closed, so the next one\\n\"\n\"                       in the loop can use them.  This mode will only be of\\n\"\n\"                       use if a VNC client (the only client for that process)\\n\"\n\"                       is already connected before the process goes into the\\n\"\n\"                       background, for example, usage of -display WAIT:..,\\n\"\n\"                       -svc, and -connect can make use of this \\\"poor man's\\\"\\n\"\n\"                       inetd mode.  The default wait time is 500ms in this\\n\"\n\"                       mode.  This usage could use useful:  -svc -bg -loopbg\\n\"\n\"\\n\"\n\"-timeout n             Exit unless a client connects within the first n seconds\\n\"\n\"                       after startup.\\n\"\n\"\\n\"\n\"                       If there have been no connection attempts after n\\n\"\n\"                       seconds x11vnc exits immediately.  If a client is\\n\"\n\"                       trying to connect but has not progressed to the normal\\n\"\n\"                       operating state, x11vnc gives it a few more seconds\\n\"\n\"                       to finish and exits if it does not make it to the\\n\"\n\"                       normal state.\\n\"\n\"\\n\"\n\"                       For reverse connections via -connect or -connect_or_exit\\n\"\n\"                       a timeout of n seconds will be set for all reverse\\n\"\n\"                       connects.  If the connect timeout alarm goes off,\\n\"\n\"                       x11vnc will exit immediately.\\n\"\n\"\\n\"\n\"-sleepin n             At startup sleep n seconds before proceeding (e.g. to\\n\"\n\"                       allow redirs and listening clients to start up)\\n\"\n\"\\n\"\n\"                       If a range is given: '-sleepin min-max', a random value\\n\"\n\"                       between min and max is slept. E.g. '-sleepin 0-20' and\\n\"\n\"                       '-sleepin 10-30'.  Floats are allowed too.\\n\"\n\"\\n\"\n\"-inetd                 Launched by inetd(8): stdio instead of listening socket.\\n\"\n\"                       Note: if you are not redirecting stderr to a log file\\n\"\n\"                       (via shell 2> or -o option) you MUST also specify the -q\\n\"\n\"                       option, otherwise the stderr goes to the viewer which\\n\"\n\"                       will cause it to abort.  Specifying both -inetd and -q\\n\"\n\"                       and no -o will automatically close the stderr.\\n\"\n\"\\n\"\n\"-tightfilexfer         Enable the TightVNC file transfer extension. Note that\\n\"\n\"                       that when the -viewonly option is supplied all file\\n\"\n\"                       transfers are disabled.  Also clients that log in\\n\"\n\"                       viewonly cannot transfer files.  However, if the remote\\n\"\n\"                       control mechanism is used to change the global or\\n\"\n\"                       per-client viewonly state the filetransfer permissions\\n\"\n\"                       will NOT change.\\n\"\n\"\\n\"\n\"                       IMPORTANT: please understand if -tightfilexfer is\\n\"\n\"                       specified and you run x11vnc as root for, say, inetd\\n\"\n\"                       or display manager (gdm, kdm, ...) access and you do\\n\"\n\"                       not have it switch users via the -users option, then\\n\"\n\"                       VNC Viewers that connect are able to do filetransfer\\n\"\n\"                       reads and writes as *root*.\\n\"\n\"\\n\"\n\"                       Also, tightfilexfer is disabled in -unixpw mode.\\n\"\n\"\\n\"\n\"-ultrafilexfer         Note: to enable UltraVNC filetransfer and to get it to\\n\"\n\"                       work you probably need to supply these LibVNCServer\\n\"\n\"                       options: \\\"-rfbversion 3.6 -permitfiletransfer\\\"\\n\"\n\"                       \\\"-ultrafilexfer\\\" is an alias for this combination.\\n\"\n\"\\n\"\n\"                       IMPORTANT: please understand if -ultrafilexfer is\\n\"\n\"                       specified and you run x11vnc as root for, say, inetd\\n\"\n\"                       or display manager (gdm, kdm, ...) access and you do\\n\"\n\"                       not have it switch users via the -users option, then\\n\"\n\"                       VNC Viewers that connect are able to do filetransfer\\n\"\n\"                       reads and writes as *root*.\\n\"\n\"\\n\"\n\"                       Note that sadly you cannot do both -tightfilexfer and\\n\"\n\"                       -ultrafilexfer at the same time because the latter\\n\"\n\"                       requires setting the version to 3.6 and tightvnc will\\n\"\n\"                       not do filetransfer when it sees that version number.\\n\"\n\"\\n\"\n\"-http                  Instead of using -httpdir (see below) to specify\\n\"\n\"                       where the Java vncviewer applet is, have x11vnc try\\n\"\n\"                       to *guess* where the directory is by looking relative\\n\"\n\"                       to the program location and in standard locations\\n\"\n\"                       (/usr/local/share/x11vnc/classes, etc).  Under -ssl or\\n\"\n\"                       -stunnel the ssl classes subdirectory is sought.\\n\"\n\"-http_ssl              As -http, but force lookup for ssl classes subdir.\\n\"\n\"\\n\"\n\"                       Note that for HTTPS, single-port Java applet delivery\\n\"\n\"                       you can set X11VNC_HTTPS_DOWNLOAD_WAIT_TIME to the\\n\"\n\"                       max number of seconds to wait for the applet download\\n\"\n\"                       to finish.  The default is 15.\\n\"\n\"\\n\"\n\"-avahi                 Use the Avahi/mDNS ZeroConf protocol to advertise\\n\"\n\"                       this VNC server to the local network. (Related terms:\\n\"\n\"                       Rendezvous, Bonjour).  Depending on your setup, you\\n\"\n\"                       may need to start avahi-daemon and open udp port 5353\\n\"\n\"                       in your firewall.\\n\"\n\"\\n\"\n\"                       You can set X11VNC_AVAHI_NAME, X11VNC_AVAHI_HOST,\\n\"\n\"                       and/or X11VNC_AVAHI_PORT environment variables\\n\"\n\"                       to override the default values.  For example:\\n\"\n\"                       -env X11VNC_AVAHI_NAME=wally\\n\"\n\"\\n\"\n\"                       If the avahi API cannot be found at build time, a helper\\n\"\n\"                       program like avahi-publish(1) or dns-sd(1) will be tried\\n\"\n\"\\n\"\n\"-mdns                  Same as -avahi.\\n\"\n\"-zeroconf              Same as -avahi.\\n\"\n\"\\n\"\n\"-connect string        For use with \\\"vncviewer -listen\\\" reverse connections.\\n\"\n\"                       If \\\"string\\\" has the form \\\"host\\\" or \\\"host:port\\\"\\n\"\n\"                       the connection is made once at startup.\\n\"\n\"\\n\"\n\"                       Use commas for a list of host's and host:port's.\\n\"\n\"                       E.g. -connect host1,host2 or host1:0,host2:5678.\\n\"\n\"                       Note that to reverse connect to multiple hosts at the\\n\"\n\"                       same time you will likely need to also supply: -shared\\n\"\n\"\\n\"\n\"                       Note that unlike most vnc servers, x11vnc will require a\\n\"\n\"                       password for reverse as well as for forward connections.\\n\"\n\"                       (provided password auth has been enabled, -rfbauth, etc)\\n\"\n\"                       If you do not want to require a password for reverse\\n\"\n\"                       connections set X11VNC_REVERSE_CONNECTION_NO_AUTH=1 in\\n\"\n\"                       your environment before starting x11vnc.\\n\"\n\"\\n\"\n\"                       If \\\"string\\\" contains \\\"/\\\" it is instead interpreted\\n\"\n\"                       as a file to periodically check for new hosts.\\n\"\n\"                       The first line is read and then the file is truncated.\\n\"\n\"                       Be careful about the location of this file if x11vnc\\n\"\n\"                       is running as root (e.g. via gdm(1), etc).\\n\"\n\"\\n\"\n\"\\n\"\n\"                       Repeater mode: Some services provide an intermediate\\n\"\n\"                       \\\"vnc repeater\\\": http://www.uvnc.com/addons/repeater.html\\n\"\n\"                       (and also http://koti.mbnet.fi/jtko/ for linux port)\\n\"\n\"                       that acts as a proxy/gateway.  Modes like these require\\n\"\n\"                       an initial string to be sent for the reverse connection\\n\"\n\"                       before the VNC protocol is started.  Here are the ways\\n\"\n\"                       to do this:\\n\"\n\"\\n\"\n\"                         -connect pre=some_string+host:port\\n\"\n\"                         -connect pre128=some_string+host:port\\n\"\n\"                         -connect repeater=ID:1234+host:port\\n\"\n\"                         -connect repeater=23.45.67.89::5501+host:port\\n\"\n\"\\n\"\n\"                       SSVNC notation is also supported:\\n\"\n\"\\n\"\n\"                         -connect repeater://host:port+ID:1234\\n\"\n\"\\n\"\n\"                       As with normal -connect usage, if the repeater port is\\n\"\n\"                       not supplied 5500 is assumed.\\n\"\n\"\\n\"\n\"                       The basic idea is between the special tag, e.g. \\\"pre=\\\"\\n\"\n\"                       and \\\"+\\\" is the pre-string to be sent.  Note that in\\n\"\n\"                       this case host:port is the repeater server, NOT the\\n\"\n\"                       vnc viewer.  Somehow the pre-string tells the repeater\\n\"\n\"                       server how to find the vnc viewer and connect you to it.\\n\"\n\"\\n\"\n\"                       In the case pre=some_string+host:port, \\\"some_string\\\"\\n\"\n\"                       is simply sent. In the case preNNN=some_string+host:port\\n\"\n\"                       \\\"some_string\\\" is sent in a null padded buffer of\\n\"\n\"                       length NNN.  repeater= is the same as pre250=, this is\\n\"\n\"                       the ultravnc repeater buffer size.\\n\"\n\"\\n\"\n\"                       Strings like \\\"\\\\n\\\" and \\\"\\\\r\\\", etc. are expanded to\\n\"\n\"                       newline and carriage return.  \\\"\\\\c\\\" is expanded to\\n\"\n\"                       \\\",\\\" since the connect string is comma separated.\\n\"\n\"\\n\"\n\"                       See also the -proxy option below for additional ways\\n\"\n\"                       to plumb reverse connections.\\n\"\n\"\\n\"\n\"                       Reverse SSL: using -connect in -ssl mode makes x11vnc\\n\"\n\"                       act as an SSL client (initiates SSL connection) rather\\n\"\n\"                       than an SSL server.  The idea is x11vnc might be\\n\"\n\"                       connecting to stunnel on the viewer side with the\\n\"\n\"                       viewer in listening mode.  If you do not want this\\n\"\n\"                       behavior, use -env X11VNC_DISABLE_SSL_CLIENT_MODE=1.\\n\"\n\"                       With this the viewer side can act as the SSL client\\n\"\n\"                       as it normally does for forward connections.\\n\"\n\"\\n\"\n\"                       Reverse SSL Repeater mode:  This will work, but note\\n\"\n\"                       that if the VNC Client does any sort of a 'Fetch Cert'\\n\"\n\"                       action before connecting, then the Repeater will\\n\"\n\"                       likely drop the connection and both sides will need\\n\"\n\"                       to restart.  Consider the use of -connect_or_exit\\n\"\n\"                       and -loop300,2 to have x11vnc reconnect once to the\\n\"\n\"                       repeater after the fetch.  You will probably also want\\n\"\n\"                       to supply -sslonly to avoid x11vnc thinking the delay\\n\"\n\"                       in response means the connection is VeNCrypt.  The env\\n\"\n\"                       var X11VNC_DISABLE_SSL_CLIENT_MODE=1 discussed above\\n\"\n\"                       may also be useful (i.e. the viewer can do a forward\\n\"\n\"                       connection as it normally does.)\\n\"\n\"\\n\"\n\"                       IPv6: as of x11vnc 0.9.10 the -connect option should\\n\"\n\"                       connect to IPv6 hosts properly.  If there are problems\\n\"\n\"                       you can disable IPv6 by setting -DX11VNC_IPV6=0\\n\"\n\"                       in CPPFLAGS when configuring.  If there problems\\n\"\n\"                       connecting to IPv6 hosts consider a relay like the\\n\"\n\"                       included inet6to4 script or the -proxy option.\\n\"\n\"\\n\"\n\"-connect_or_exit str   As with -connect, except if none of the reverse\\n\"\n\"                       connections succeed, then x11vnc shuts down immediately\\n\"\n\"\\n\"\n\"                       An easier to type alias for this option is '-coe'\\n\"\n\"\\n\"\n\"                       By the way, if you do not want x11vnc to listen on\\n\"\n\"                       ANY interface use -rfbport 0  which is handy for the\\n\"\n\"                       -connect_or_exit mode.\\n\"\n\"\\n\"\n\"-proxy string          Use proxy in string (e.g. host:port) as a proxy for\\n\"\n\"                       making reverse connections (-connect or -connect_or_exit\\n\"\n\"                       options).\\n\"\n\"\\n\"\n\"                       Web proxies are supported, but note by default most of\\n\"\n\"                       them only support destination connections to ports 443\\n\"\n\"                       or 563, so this might not be very useful (the viewer\\n\"\n\"                       would need to listen on that port or the router would\\n\"\n\"                       have to do a port redirection).\\n\"\n\"\\n\"\n\"                       A web proxy may be specified by either \\\"host:port\\\"\\n\"\n\"                       or \\\"http://host:port\\\" (the port is required even if\\n\"\n\"                       it is the common choices 80 or 8080)\\n\"\n\"\\n\"\n\"                       SOCKS4, SOCKS4a, and SOCKS5 are also supported.\\n\"\n\"                       SOCKS proxies normally do not have restrictions on the\\n\"\n\"                       destination port number.\\n\"\n\"\\n\"\n\"                       Use a format like this: socks://host:port or\\n\"\n\"                       socks5://host:port.  Note that ssh -D does not support\\n\"\n\"                       SOCKS4a, so use socks5://.  For socks:// SOCKS4 is used\\n\"\n\"                       on a numerical IP and \\\"localhost\\\", otherwise SOCKS4a\\n\"\n\"                       is used (and so the proxy tries to do the DNS lookup).\\n\"\n\"\\n\"\n\"                       An experimental mode is \\\"-proxy http://host:port/...\\\"\\n\"\n\"                       Note the \\\"/\\\" after the port that distinguishes it from\\n\"\n\"                       a normal web proxy.  The port must be supplied even if\\n\"\n\"                       it is the default 80.  For this mode a GET is done to\\n\"\n\"                       the supplied URL with the string host=H&port=P appended.\\n\"\n\"                       H and P will be the -connect reverse connect host\\n\"\n\"                       and port.  Use the string \\\"__END__\\\" to disable the\\n\"\n\"                       appending.  The basic idea here is that maybe some cgi\\n\"\n\"                       script provides the actual viewer hookup and tunnelling.\\n\"\n\"                       How to actually achieve this within cgi, php, etc. is\\n\"\n\"                       not clear...  A custom web server or apache module\\n\"\n\"                       would be straight-forward.\\n\"\n\"\\n\"\n\"                       Another experimental mode is \\\"-proxy ssh://user@host\\\"\\n\"\n\"                       in which case a SSH tunnel is used for the proxying.\\n\"\n\"                       \\\"user@\\\" is not needed unless your unix username is\\n\"\n\"                       different on \\\"host\\\".  For a non-standard SSH port\\n\"\n\"                       use ssh://user@host:port.  If proxies are chained (see\\n\"\n\"                       next paragraph) then the ssh one must be the first one.\\n\"\n\"                       If ssh-agent is not active, then the ssh password needs\\n\"\n\"                       to be entered in the terminal where x11vnc is running.\\n\"\n\"                       Examples:\\n\"\n\"\\n\"\n\"                         -connect localhost:0 -proxy ssh://me@friends-pc:2222\\n\"\n\"\\n\"\n\"                         -connect snoopy:0 -proxy ssh://ssh.company.com\\n\"\n\"\\n\"\n\"                       Multiple proxies may be chained together in case one\\n\"\n\"                       needs to ricochet off of a number of hosts to finally\\n\"\n\"                       reach the VNC viewer.  Up to 3 may be chained, separate\\n\"\n\"                       them by commas in the order they are to be connected to.\\n\"\n\"                       E.g.:  http://host1:port1,socks5://host2:port2 or three\\n\"\n\"                       like:  first,second,third\\n\"\n\"\\n\"\n\"                       IPv6: as of x11vnc 0.9.10 the -proxy option should\\n\"\n\"                       connect to IPv6 hosts properly.  If there are problems\\n\"\n\"                       you can disable IPv6 by setting -DX11VNC_IPV6=0\\n\"\n\"                       in CPPFLAGS when configuring.  If there problems\\n\"\n\"                       connecting to IPv6 hosts consider a relay like the\\n\"\n\"                       included inet6to4 script.\\n\"\n\"\\n\"\n\"-vncconnect            Monitor the VNC_CONNECT X property set by the standard\\n\"\n\"-novncconnect          VNC program vncconnect(1).  When the property is\\n\"\n\"                       set to \\\"host\\\" or \\\"host:port\\\" establish a reverse\\n\"\n\"                       connection.  Using xprop(1) instead of vncconnect may\\n\"\n\"                       work (see the FAQ).  The -remote control mechanism uses\\n\"\n\"                       X11VNC_REMOTE channel, and this option disables/enables\\n\"\n\"                       it as well.  Default: %s\\n\"\n\"\\n\"\n\"                       To use different names for these X11 properties (e.g. to\\n\"\n\"                       have separate communication channels for multiple\\n\"\n\"                       x11vnc's on the same display) set the VNC_CONNECT or\\n\"\n\"                       X11VNC_REMOTE env. vars. to the string you want, for\\n\"\n\"                       example: -env X11VNC_REMOTE=X11VNC_REMOTE_12345\\n\"\n\"                       Both sides of the channel must use the same unique name.\\n\"\n\"                       The same can be done for the internal X11VNC_TICKER\\n\"\n\"                       property (heartbeat and timestamp) if desired.\\n\"\n\"\\n\"\n\"-allow host1[,host2..] Only allow client connections from hosts matching\\n\"\n\"                       the comma separated list of hostnames or IP addresses.\\n\"\n\"                       Can also be a numerical IP prefix, e.g. \\\"192.168.100.\\\"\\n\"\n\"                       to match a simple subnet, for more control build\\n\"\n\"                       LibVNCServer with libwrap support (See the FAQ).  If the\\n\"\n\"                       list contains a \\\"/\\\" it instead is a interpreted\\n\"\n\"                       as a file containing addresses or prefixes that is\\n\"\n\"                       re-read each time a new client connects.  Lines can be\\n\"\n\"                       commented out with the \\\"#\\\" character in the usual way.\\n\"\n\"\\n\"\n\"                       -allow applies in -ssl mode, but not in -stunnel mode.\\n\"\n\"\\n\"\n\"                       IPv6: as of x11vnc 0.9.10 a host can be specified\\n\"\n\"                       in IPv6 numerical format, e.g. 2001:4860:b009::93.\\n\"\n\"\\n\"\n\"-localhost             Basically the same as \\\"-allow 127.0.0.1\\\".\\n\"\n\"\\n\"\n\"                       Note: if you want to restrict which network interface\\n\"\n\"                       x11vnc listens on, see the -listen option below.\\n\"\n\"                       E.g. \\\"-listen localhost\\\" or \\\"-listen 192.168.3.21\\\".\\n\"\n\"                       As a special case, the option \\\"-localhost\\\" implies\\n\"\n\"                       \\\"-listen localhost\\\".\\n\"\n\"\\n\"\n\"                       A rare case, but for non-localhost -listen usage, if\\n\"\n\"                       you use the remote control mechanism (-R) to change\\n\"\n\"                       the -listen interface you may need to manually adjust\\n\"\n\"                       the -allow list (and vice versa) to avoid situations\\n\"\n\"                       where no connections (or too many) are allowed.\\n\"\n\"\\n\"\n\"                       If you do not want x11vnc to listen on ANY interface\\n\"\n\"                       (evidently you are using -connect or -connect_or_exit,\\n\"\n\"                       or plan to use remote control: -R connect:host), use\\n\"\n\"                       -rfbport 0\\n\"\n\"\\n\"\n\"                       IPv6: if IPv6 is supported, this option automatically\\n\"\n\"                       implies the IPv6 loopback address '::1' as well.\\n\"\n\"\\n\"\n\"-unixsock str          Listen on the unix socket (AF_UNIX) 'str'\\n\"\n\"                       for connections.  This mode is for either local\\n\"\n\"                       connections or a tunnel endpoint where one wants the\\n\"\n\"                       file permission of the unix socket file to determine\\n\"\n\"                       what can connect to it.  (This currently requires an\\n\"\n\"                       edit to libvnserver/rfbserver.c: comment out lines 310\\n\"\n\"                       and 311, 'close(sock)' and 'return NULL' in rfbserver.c\\n\"\n\"                       after the setsockopt() call.) Note that to disable all\\n\"\n\"                       tcp listening ports specify '-rfbport 0' and should be\\n\"\n\"                       useful with this mode.  Example:\\n\"\n\"                           mkdir ~/s; chmod 700 ~/s;\\n\"\n\"                           x11vnc -unixsock ~/s/mysock -rfbport 0 ...\\n\"\n\"                       The SSVNC unix vncviewer can connect to unix sockets.\\n\"\n\"\\n\"\n#if X11VNC_IPV6\n\"-listen6 str           When in IPv6 listen mode \\\"-6\\\", listen only on the\\n\"\n\"                       network interface with address \\\"str\\\".  It also works\\n\"\n\"                       for link scope addresses (fe80::219:dbff:fee5:3f92%%eth0)\\n\"\n\"                       and IPv6 hostname strings (e.g. ipv6.google.com.)\\n\"\n\"                       Use LibVNCServer -listen option for the IPv4 interface.\\n\"\n\"\\n\"\n#endif\n\"-nolookup              Do not use gethostbyname() or gethostbyaddr() to look up\\n\"\n\"                       host names or IP numbers.  Use this if name resolution\\n\"\n\"                       is incorrectly set up and leads to long pauses as name\\n\"\n\"                       lookups time out, etc.\\n\"\n\"\\n\"\n\"-input string          Fine tuning of allowed user input.  If \\\"string\\\" does\\n\"\n\"                       not contain a comma \\\",\\\" the tuning applies only to\\n\"\n\"                       normal clients.  Otherwise the part before \\\",\\\" is\\n\"\n\"                       for normal clients and the part after for view-only\\n\"\n\"                       clients.  \\\"K\\\" is for Keystroke input, \\\"M\\\" for\\n\"\n\"                       Mouse-motion input, \\\"B\\\" for Button-click input, \\\"C\\\"\\n\"\n\"                       is for Clipboard input, and \\\"F\\\" is for File transfer\\n\"\n\"                       (ultravnc only).  Their presence in the string enables\\n\"\n\"                       that type of input.  E.g. \\\"-input M\\\" means normal\\n\"\n\"                       users can only move the mouse and  \\\"-input KMBCF,M\\\"\\n\"\n\"                       lets normal users do anything and enables view-only\\n\"\n\"                       users to move the mouse.  This option is ignored when\\n\"\n\"                       a global -viewonly is in effect (all input is discarded\\n\"\n\"                       in that case).\\n\"\n\"\\n\"\n\"-grabkbd               When VNC viewers are connected, attempt to the grab\\n\"\n\"                       the keyboard so a (non-malicious) user sitting at the\\n\"\n\"                       physical display is not able to enter keystrokes.\\n\"\n\"                       This method uses XGrabKeyboard(3X11) and so it is\\n\"\n\"                       not secure and does not rule out the person at the\\n\"\n\"                       physical display injecting keystrokes by flooding the\\n\"\n\"                       server with them, grabbing the keyboard himself, etc.\\n\"\n\"                       Some degree of cooperation from the person at the\\n\"\n\"                       display is assumed.  This is intended for remote\\n\"\n\"                       help-desk or educational usage modes.\\n\"\n\"\\n\"\n\"                       Note: on some recent (12/2010) X servers and/or\\n\"\n\"                       desktops, -grabkbd no longer works: it prevents the\\n\"\n\"                       window manager from resizing windows and similar things.\\n\"\n\"                       Try -ungrabboth below (might not work.)\\n\"\n\"\\n\"\n\"-grabptr               As -grabkbd, but for the mouse pointer using\\n\"\n\"                       XGrabPointer(3X11).  Unfortunately due to the way the X\\n\"\n\"                       server works, the mouse can still be moved around by the\\n\"\n\"                       user at the physical display, but he will not be able to\\n\"\n\"                       change window focus with it.  Also some window managers\\n\"\n\"                       that call XGrabServer(3X11) for resizes, etc, will\\n\"\n\"                       act on the local user's input.  Again, some degree of\\n\"\n\"                       cooperation from the person at the display is assumed.\\n\"\n\"\\n\"\n\"-ungrabboth            Whenever there is any input (either keyboard or\\n\"\n\"                       pointer), ungrab *both* the keyboard and the pointer\\n\"\n\"                       while injecting the synthetic input.  This is to allow\\n\"\n\"                       window managers, etc. a chance to grab.\\n\"\n\"\\n\"\n\"-grabalways            Apply both -grabkbd and -grabptr even when no VNC\\n\"\n\"                       viewers are connected.  If you only want one of them,\\n\"\n\"                       use the -R remote control to turn the other back on,\\n\"\n\"                       e.g. -R nograbptr.\\n\"\n\"\\n\"\n#ifdef ENABLE_GRABLOCAL\n\"-grablocal n           If it appears that a user sitting at the physical\\n\"\n\"                       display has injected a keystroke or mouse event ignore\\n\"\n\"                       any VNC client inputs for the next n seconds.  The idea\\n\"\n\"                       is that during a demonstration, etc, the local user\\n\"\n\"                       will not be interrupted by viewers accidentally moving\\n\"\n\"                       the mouse, etc.  The detection of local user input is\\n\"\n\"                       approximate and so at times gives unexpected results.\\n\"\n\"\\n\"\n#endif\n\"-viewpasswd string     Supply a 2nd password for view-only logins.  The -passwd\\n\"\n\"                       (full-access) password must also be supplied.\\n\"\n\"\\n\"\n\"-passwdfile filename   Specify the LibVNCServer password via the first line\\n\"\n\"                       of the file \\\"filename\\\" (instead of via -passwd on\\n\"\n\"                       the command line where others might see it via ps(1)).\\n\"\n\"\\n\"\n\"                       See the descriptions below for how to supply multiple\\n\"\n\"                       passwords, view-only passwords, to specify external\\n\"\n\"                       programs for the authentication, and other features.\\n\"\n\"\\n\"\n\"                       If the filename is prefixed with \\\"rm:\\\" it will be\\n\"\n\"                       removed after being read.  Perhaps this is useful in\\n\"\n\"                       limiting the readability of the file.  In general, the\\n\"\n\"                       password file should not be readable by untrusted users\\n\"\n\"                       (BTW: neither should the VNC -rfbauth file: it is NOT\\n\"\n\"                       encrypted, only obscured with a fixed key).\\n\"\n\"\\n\"\n\"                       If the filename is prefixed with \\\"read:\\\" it will\\n\"\n\"                       periodically be checked for changes and reread.  It is\\n\"\n\"                       guaranteed to be reread just when a new client connects\\n\"\n\"                       so that the latest passwords will be used.\\n\"\n\"\\n\"\n\"                       If \\\"filename\\\" is prefixed with \\\"cmd:\\\" then the\\n\"\n\"                       string after the \\\":\\\" is run as an external command:\\n\"\n\"                       the output of the command will be interpreted as if it\\n\"\n\"                       were read from a password file (see below).  If the\\n\"\n\"                       command does not exit with 0, then x11vnc terminates\\n\"\n\"                       immediately.  To specify more than 1000 passwords this\\n\"\n\"                       way set X11VNC_MAX_PASSWDS before starting x11vnc.\\n\"\n\"                       The environment variables are set as in -accept.\\n\"\n\"\\n\"\n\"                       Note that due to the VNC protocol only the first 8\\n\"\n\"                       characters of a password are used (DES key).\\n\"\n\"\\n\"\n\"                       If \\\"filename\\\" is prefixed with \\\"custom:\\\" then a\\n\"\n\"                       custom password checker is supplied as an external\\n\"\n\"                       command following the \\\":\\\". The command will be run\\n\"\n\"                       when a client authenticates.  If the command exits with\\n\"\n\"                       0 the client is accepted, otherwise it is rejected.\\n\"\n\"                       The environment variables are set as in -accept.\\n\"\n\"\\n\"\n\"                       The standard input to the custom command will be a\\n\"\n\"                       decimal digit \\\"len\\\" followed by a newline. \\\"len\\\"\\n\"\n\"                       specifies the challenge size and is usually 16 (the\\n\"\n\"                       VNC spec).  Then follows len bytes which is the random\\n\"\n\"                       challenge string that was sent to the client. This is\\n\"\n\"                       then followed by len more bytes holding the client's\\n\"\n\"                       response (i.e. the challenge string encrypted via DES\\n\"\n\"                       with the user password in the standard situation).\\n\"\n\"\\n\"\n\"                       The \\\"custom:\\\" scheme can be useful to implement\\n\"\n\"                       dynamic passwords or to implement methods where longer\\n\"\n\"                       passwords and/or different encryption algorithms\\n\"\n\"                       are used.  The latter will require customizing the VNC\\n\"\n\"                       client as well.  One could create an MD5SUM based scheme\\n\"\n\"                       for example.\\n\"\n\"\\n\"\n\"                       File format for -passwdfile:\\n\"\n\"\\n\"\n\"                       If multiple non-blank lines exist in the file they are\\n\"\n\"                       all taken as valid passwords.  Blank lines are ignored.\\n\"\n\"                       Password lines may be \\\"commented out\\\" (ignored) if\\n\"\n\"                       they begin with the character \\\"#\\\" or the line contains\\n\"\n\"                       the string \\\"__SKIP__\\\".  Lines may be annotated by use\\n\"\n\"                       of the \\\"__COMM__\\\" string: from it to the end of the\\n\"\n\"                       line is ignored.  An empty password may be specified\\n\"\n\"                       via the \\\"__EMPTY__\\\" string on a line by itself (note\\n\"\n\"                       your viewer might not accept empty passwords).\\n\"\n\"\\n\"\n\"                       If the string \\\"__BEGIN_VIEWONLY__\\\" appears on a\\n\"\n\"                       line by itself, the remaining passwords are used for\\n\"\n\"                       viewonly access.  For compatibility, as a special case\\n\"\n\"                       if the file contains only two password lines the 2nd\\n\"\n\"                       one is automatically taken as the viewonly password.\\n\"\n\"                       Otherwise the \\\"__BEGIN_VIEWONLY__\\\" token must be\\n\"\n\"                       used to have viewonly passwords.  (tip: make the 3rd\\n\"\n\"                       and last line be \\\"__BEGIN_VIEWONLY__\\\" to have 2\\n\"\n\"                       full-access passwords)\\n\"\n\"\\n\"\n\"-showrfbauth filename  Print to the screen the obscured VNC password kept in\\n\"\n\"                       the rfbauth file \\\"filename\\\" and then exit.\\n\"\n\"\\n\"\n\"-unixpw [list]         Use Unix username and password authentication.  x11vnc\\n\"\n\"                       will use the su(1) program to verify the user's\\n\"\n\"                       password.  [list] is an optional comma separated list\\n\"\n\"                       of allowed Unix usernames.  If the [list] string begins\\n\"\n\"                       with the character \\\"!\\\" then the entire list is taken\\n\"\n\"                       as an exclude list.  See below for per-user options\\n\"\n\"                       that can be applied.\\n\"\n\"\\n\"\n\"                       A familiar \\\"login:\\\" and \\\"Password:\\\" dialog is\\n\"\n\"                       presented to the user on a black screen inside the\\n\"\n\"                       vncviewer.  The connection is dropped if the user fails\\n\"\n\"                       to supply the correct password in 3 tries or does not\\n\"\n\"                       send one before a 45 second timeout.  Existing clients\\n\"\n\"                       are view-only during this period.\\n\"\n\"\\n\"\n\"                       If the first character received is \\\"Escape\\\" then the\\n\"\n\"                       unix username will not be displayed after \\\"login:\\\"\\n\"\n\"                       as it is typed.  This could be of use for VNC viewers\\n\"\n\"                       that automatically type the username and password.\\n\"\n\"\\n\"\n\"                       Since the detailed behavior of su(1) can vary from\\n\"\n\"                       OS to OS and for local configurations, test the mode\\n\"\n\"                       before deployment to make sure it is working properly.\\n\"\n\"                       x11vnc will attempt to be conservative and reject a\\n\"\n\"                       login if anything abnormal occurs.\\n\"\n\"\\n\"\n\"                       One case to note: FreeBSD and the other BSD's by\\n\"\n\"                       default it is impossible for the user running x11vnc to\\n\"\n\"                       validate his *own* password via su(1) (commenting out\\n\"\n\"                       the pam_self.so entry in /etc/pam.d/su eliminates this\\n\"\n\"                       behavior).  So the x11vnc login will always *FAIL* for\\n\"\n\"                       this case (even when the correct password is supplied).\\n\"\n\"\\n\"\n\"                       A possible workaround for this on *BSD would be to\\n\"\n\"                       start x11vnc as root with the \\\"-users +nobody\\\" option\\n\"\n\"                       to immediately switch to user nobody where the su'ing\\n\"\n\"                       will proceed normally.\\n\"\n\"\\n\"\n\"                       Another source of potential problems are PAM modules\\n\"\n\"                       that prompt for extra info, e.g. password aging modules.\\n\"\n\"                       These logins will fail as well even when the correct\\n\"\n\"                       password is supplied.\\n\"\n\"\\n\"\n\"                       **IMPORTANT**: to prevent the Unix password being sent\\n\"\n\"                       in *clear text* over the network, one of two schemes\\n\"\n\"                       will be enforced: 1) the -ssl builtin SSL mode, or 2)\\n\"\n\"                       require both -localhost and -stunnel be enabled.\\n\"\n\"\\n\"\n\"                       Method 1) ensures the traffic is encrypted between\\n\"\n\"                       viewer and server.  A PEM file will be required, see the\\n\"\n\"                       discussion under -ssl below (under some circumstances\\n\"\n\"                       a temporary one can be automatically generated).\\n\"\n\"\\n\"\n\"                       Method 2) requires the viewer connection to appear\\n\"\n\"                       to come from the same machine x11vnc is running on\\n\"\n\"                       (e.g. from a ssh -L port redirection).  And that the\\n\"\n\"                       -stunnel SSL mode be used for encryption over the\\n\"\n\"                       network. (see the description of -stunnel below).\\n\"\n\"\\n\"\n\"                       Note: as a convenience, if you ssh(1) in and start\\n\"\n\"                       x11vnc it will check if the environment variable\\n\"\n\"                       SSH_CONNECTION is set and appears reasonable.  If it\\n\"\n\"                       does, then the -ssl or -stunnel requirement will be\\n\"\n\"                       dropped since it is assumed you are using ssh for the\\n\"\n\"                       encrypted tunnelling.  -localhost is still enforced.\\n\"\n\"                       Use -ssl or -stunnel to force SSL usage even if\\n\"\n\"                       SSH_CONNECTION is set.\\n\"\n\"\\n\"\n\"                       To override the above restrictions you can set\\n\"\n\"                       environment variables before starting x11vnc:\\n\"\n\"\\n\"\n\"                       Set UNIXPW_DISABLE_SSL=1 to disable requiring either\\n\"\n\"                       -ssl or -stunnel (as under SSH_CONNECTION.)  Evidently\\n\"\n\"                       you will be using a different method to encrypt the\\n\"\n\"                       data between the vncviewer and x11vnc: perhaps ssh(1)\\n\"\n\"                       or an IPSEC VPN. -localhost is still enforced (however,\\n\"\n\"                       see the next paragraph.)\\n\"\n\"\\n\"\n\"                       Set UNIXPW_DISABLE_LOCALHOST=1 to disable the -localhost\\n\"\n\"                       requirement in -unixpw modes.  One should never do this\\n\"\n\"                       (i.e. allow the Unix passwords to be sniffed on the\\n\"\n\"                       network.)  This also disables the localhost requirement\\n\"\n\"                       for reverse connections (see below.)\\n\"\n\"\\n\"\n\"                       Note that use of -localhost with ssh(1) (and no -unixpw)\\n\"\n\"                       is roughly the same as requiring a Unix user login\\n\"\n\"                       (since a Unix password or the user's public key\\n\"\n\"                       authentication is used by sshd on the machine where\\n\"\n\"                       x11vnc runs and only local connections from that machine\\n\"\n\"                       are accepted).\\n\"\n\"\\n\"\n\"                       Regarding reverse connections (e.g. -R connect:host\\n\"\n\"                       and -connect host), when the -localhost constraint is\\n\"\n\"                       in effect then reverse connections can only be used\\n\"\n\"                       to connect to the same machine x11vnc is running on\\n\"\n\"                       (default port 5500).  Please use a ssh or stunnel port\\n\"\n\"                       redirection to the viewer machine to tunnel the reverse\\n\"\n\"                       connection over an encrypted channel.\\n\"\n\"\\n\"\n\"                       In -inetd mode the Method 1) will be enforced (not\\n\"\n\"                       Method 2).  With -ssl in effect reverse connections\\n\"\n\"                       are disabled.  If you override this via env. var, be\\n\"\n\"                       sure to also use encryption from the viewer to inetd.\\n\"\n\"                       Tip: you can also have your own stunnel spawn x11vnc\\n\"\n\"                       in -inetd mode (thereby bypassing inetd).  See the FAQ\\n\"\n\"                       for details.\\n\"\n\"\\n\"\n\"                       The user names in the comma separated [list] may have\\n\"\n\"                       per-user options after a \\\":\\\", e.g. \\\"fred:opts\\\"\\n\"\n\"                       where \\\"opts\\\" is a \\\"+\\\" separated list of\\n\"\n\"                       \\\"viewonly\\\", \\\"fullaccess\\\", \\\"input=XXXX\\\", or\\n\"\n\"                       \\\"deny\\\", e.g. \\\"karl,wally:viewonly,boss:input=M\\\".\\n\"\n\"                       For \\\"input=\\\" it is the K,M,B,C described under -input.\\n\"\n\"\\n\"\n\"                       If an item in the list is \\\"*\\\" that means those\\n\"\n\"                       options apply to all users.  It ALSO implies all users\\n\"\n\"                       are allowed to log in after supplying a valid password.\\n\"\n\"                       Use \\\"deny\\\" to explicitly deny some users if you use\\n\"\n\"                       \\\"*\\\" to set a global option.  If [list] begins with the\\n\"\n\"                       \\\"!\\\" character then \\\"*\\\" is ignored for checking if\\n\"\n\"                       the user is allowed, but the option values associated\\n\"\n\"                       with it do apply as normal.\\n\"\n\"\\n\"\n\"                       There are also some utilities for checking passwords\\n\"\n\"                       if [list] starts with the \\\"%%\\\" character.  See the\\n\"\n\"                       quick_pw() function for more details.  Description:\\n\"\n\"                       \\\"%%-\\\" or \\\"%%stdin\\\" means read one line from stdin.\\n\"\n\"                       \\\"%%env\\\" means it is in $UNIXPW env var.  A leading\\n\"\n\"                       \\\"%%/\\\" or \\\"%%.\\\" means read the first line from the\\n\"\n\"                       filename that follows after the %% character. %% by\\n\"\n\"                       itself means prompt for the username and password.\\n\"\n\"                       Otherwise: %%user:pass   E.g. -unixpw %%fred:swordfish\\n\"\n\"                       For the other cases user:pass is read from the indicated\\n\"\n\"                       source.  If the password is correct 'Y user' is printed\\n\"\n\"                       and the program exit code is 0.  If the password is\\n\"\n\"                       incorrect it prints 'N user' and the exit code is 1.\\n\"\n\"                       If there is some other error the exit code is 2.\\n\"\n\"                       This feature enables x11vnc to be a general unix user\\n\"\n\"                       password checking tool; it could be used from scripts\\n\"\n\"                       or other programs.  These %% password checks also apply\\n\"\n\"                       to the -unixpw_nis and -unixpw_cmd options.\\n\"\n\"\\n\"\n\"                       For the %% password check, if the env. var. UNIXPW_CMD\\n\"\n\"                       is set to a command then it is run as the user (assuming\\n\"\n\"                       the password is correct.)  The output of the command is\\n\"\n\"                       not printed, the program or script must manage that by\\n\"\n\"                       some other means.  The exit code of x11vnc will depend\\n\"\n\"                       on the exit code of the command that is run.\\n\"\n\"\\n\"\n\"                       Use -nounixpw to disable unixpw mode if it was enabled\\n\"\n\"                       earlier in the cmd line (e.g. -svc mode)\\n\"\n\"\\n\"\n\"-unixpw_nis [list]     As -unixpw above, however do not use su(1) but rather\\n\"\n\"                       use the traditional getpwnam(3) + crypt(3) method to\\n\"\n\"                       verify passwords. All of the above -unixpw options and\\n\"\n\"                       constraints apply.\\n\"\n\"\\n\"\n\"                       This mode requires that the encrypted passwords be\\n\"\n\"                       readable.  Encrypted passwords stored in /etc/shadow\\n\"\n\"                       will be inaccessible unless x11vnc is run as root.\\n\"\n\"\\n\"\n\"                       This is called \\\"NIS\\\" mode simply because in most\\n\"\n\"                       NIS setups user encrypted passwords are accessible\\n\"\n\"                       (e.g. \\\"ypcat passwd\\\") by an ordinary user and so that\\n\"\n\"                       user can authenticate ANY user.\\n\"\n\"\\n\"\n\"                       NIS is not required for this mode to work (only that\\n\"\n\"                       getpwnam(3) return the encrypted password is required),\\n\"\n\"                       but it is unlikely it will work (as an ordinary user)\\n\"\n\"                       for most modern environments unless NIS is available.\\n\"\n\"                       On the other hand, when x11vnc is run as root it will\\n\"\n\"                       be able to to access /etc/shadow even if NIS is not\\n\"\n\"                       available (note running as root is often done when\\n\"\n\"                       running x11vnc from inetd and xdm/gdm/kdm).\\n\"\n\"\\n\"\n\"                       Looked at another way, if you do not want to use the\\n\"\n\"                       su(1) method provided by -unixpw (i.e. su_verify()), you\\n\"\n\"                       can run x11vnc as root and use -unixpw_nis.  Any users\\n\"\n\"                       with passwords in /etc/shadow can then be authenticated.\\n\"\n\"\\n\"\n\"                       In -unixpw_nis mode, under no circumstances is x11vnc's\\n\"\n\"                       user password verifying function based on su called\\n\"\n\"                       (i.e. the function su_verify() that runs /bin/su\\n\"\n\"                       in a pseudoterminal to verify passwords.)  However,\\n\"\n\"                       if -unixpw_nis is used in conjunction with the -find\\n\"\n\"                       and -create -display WAIT:... modes then, if x11vnc is\\n\"\n\"                       running as root, /bin/su may be called externally to\\n\"\n\"                       run the find or create commands.\\n\"\n\"\\n\"\n\"-unixpw_cmd cmd        As -unixpw above, however do not use su(1) but rather\\n\"\n\"                       run the externally supplied command \\\"cmd\\\".  The first\\n\"\n\"                       line of its stdin will be the username and the second\\n\"\n\"                       line the received password.  If the command exits\\n\"\n\"                       with status 0 (success) the VNC user will be accepted.\\n\"\n\"                       It will be rejected for any other return status.\\n\"\n\"\\n\"\n\"                       Dynamic passwords and non-unix passwords, e.g. LDAP,\\n\"\n\"                       can be implemented this way by providing your own custom\\n\"\n\"                       helper program.  Note that the remote viewer is given 3\\n\"\n\"                       tries to enter the correct password, and so the program\\n\"\n\"                       may be called in a row that many (or more) times.\\n\"\n\"\\n\"\n\"                       If a list of allowed users is needed to limit who can\\n\"\n\"                       log in, use -unixpw [list] in addition to this option.\\n\"\n\"\\n\"\n\"                       In FINDDISPLAY and FINDCREATEDISPLAY modes the \\\"cmd\\\"\\n\"\n\"                       will also be run with the RFB_UNIXPW_CMD_RUN env. var.\\n\"\n\"                       non-empty and set to the corresponding display\\n\"\n\"                       find/create command.  The first two lines of input are\\n\"\n\"                       the username and passwd as in the normal case described\\n\"\n\"                       above.  To support FINDDISPLAY and FINDCREATEDISPLAY,\\n\"\n\"                       \\\"cmd\\\" should run the requested command as the user\\n\"\n\"                       (and most likely refusing to run it if the password is\\n\"\n\"                       not correct.)  Here is an example script (note it has\\n\"\n\"                       a hardwired bogus password \\\"abc\\\"!)\\n\"\n\"\\n\"\n\"                         #!/bin/sh\\n\"\n\"                         # Example x11vnc -unixpw_cmd script.\\n\"\n\"                         # Read the first two lines of stdin (user and passwd)\\n\"\n\"                         read user\\n\"\n\"                         read pass\\n\"\n\"                         \\n\"\n\"                         debug=0\\n\"\n\"                         if [ $debug = 1 ]; then\\n\"\n\"                         \techo \\\"user: $user\\\" 1>&2\\n\"\n\"                         \techo \\\"pass: $pass\\\" 1>&2\\n\"\n\"                         \tenv | egrep -i 'rfb|vnc' 1>&2\\n\"\n\"                         fi\\n\"\n\"                         \\n\"\n\"                         # Check if the password is valid.\\n\"\n\"                         # (A real example would use ldap lookup, etc!)\\n\"\n\"                         if [ \\\"X$pass\\\" != \\\"Xabc\\\" ]; then\\n\"\n\"                         \texit 1\t# incorrect password\\n\"\n\"                         fi\\n\"\n\"                         \\n\"\n\"                         if [ \\\"X$RFB_UNIXPW_CMD_RUN\\\" = \\\"X\\\" ]; then\\n\"\n\"                         \texit 0\t# correct password\\n\"\n\"                         else\\n\"\n\"                         \t# Run the requested command (finddisplay)\\n\"\n\"                         \tif [ $debug = 1 ]; then\\n\"\n\"                         \t\techo \\\"run: $RFB_UNIXPW_CMD_RUN\\\" 1>&2\\n\"\n\"                         \tfi\\n\"\n\"                         \texec /bin/su - \\\"$user\\\" -c \\\"$RFB_UNIXPW_CMD_RUN\\\"\\n\"\n\"                         fi\\n\"\n\"\\n\"\n\"                       In -unixpw_cmd mode, under no circumstances is x11vnc's\\n\"\n\"                       user password verifying function based on su called\\n\"\n\"                       (i.e. the function su_verify() that runs /bin/su in a\\n\"\n\"                       pseudoterminal to verify passwords.)  It is up to the\\n\"\n\"                       supplied unixpw_cmd to do user switching if desired\\n\"\n\"                       and if it has the permissions to do so.\\n\"\n\"\\n\"\n\"-find                  Find the user's display using FINDDISPLAY. This\\n\"\n\"                       is an alias for \\\"-display WAIT:cmd=FINDDISPLAY\\\".\\n\"\n\"\\n\"\n\"                       Note: if a -display occurs later on the command line\\n\"\n\"                       it will override the -find setting.\\n\"\n\"\\n\"\n\"                       For this and the next few options see -display WAIT:...\\n\"\n\"                       below for all of the details.\\n\"\n\"\\n\"\n\"-finddpy               Run the FINDDISPLAY program, print out the found\\n\"\n\"                       display (if any) and exit.  Output is like: DISPLAY=:0.0\\n\"\n\"                       DISPLAY=:0.0,XPID=12345 or DISPLAY=:0.0,VT=7.  XPID is\\n\"\n\"                       the process ID of the found X server.  VT is the Linux\\n\"\n\"                       virtual terminal of the X server.\\n\"\n\"-listdpy               Have the FINDDISPLAY program list all of your displays\\n\"\n\"                       (i.e. all the X displays on the local machine that you\\n\"\n\"                       have access rights to).  x11vnc then exits.\\n\"\n\"\\n\"\n\"-findauth [disp]       Apply the -find/-finddpy heuristics to try to guess\\n\"\n\"                       the XAUTHORITY file for DISPLAY 'disp'.  If 'disp'\\n\"\n\"                       is not supplied, then the value in the -display on\\n\"\n\"                       the cmdline is used; failing that $DISPLAY is used;\\n\"\n\"                       and failing that \\\":0\\\" is used.  x11vnc then exits.\\n\"\n\"\\n\"\n\"                       If nothing is printed out, that means no XAUTHORITY was\\n\"\n\"                       found for 'disp'; i.e. failure.  If \\\"XAUTHORITY=\\\"\\n\"\n\"                       is printed out, that means use the default (i.e. do\\n\"\n\"                       not set XAUTHORITY).  If \\\"XAUTHORITY=/path/to/file\\\"\\n\"\n\"                       is printed out, then use that file.\\n\"\n\"\\n\"\n\"                       XDM/GDM/KDM: if you are running x11vnc as root and want\\n\"\n\"                       to find the XAUTHORITY before anyone has logged into an\\n\"\n\"                       X session yet, use: x11vnc -env FD_XDM=1 -findauth ...\\n\"\n\"                       (This will also find the XAUTHORITY if a user is already\\n\"\n\"                       logged into the X session.)  When running as root,\\n\"\n\"                       FD_XDM=1 will be tried if the initial -findauth fails.\\n\"\n\"\\n\"\n\"-create                First try to find the user's display using FINDDISPLAY,\\n\"\n\"                       if that doesn't succeed create an X session via the\\n\"\n\"                       FINDCREATEDISPLAY method.  This is an alias for\\n\"\n\"                       \\\"-display WAIT:cmd=FINDCREATEDISPLAY-Xvfb\\\".\\n\"\n\"\\n\"\n\"                       Note: if a -display occurs later on the command line\\n\"\n\"                       it will override the -create setting.\\n\"\n\"\\n\"\n\"                       SSH NOTE: for both -find and -create you can (should!)\\n\"\n\"                       add the \\\"-localhost\\\" option to force SSH tunnel access.\\n\"\n\"\\n\"\n\"-xdummy                As in -create, except Xdummy instead of Xvfb.\\n\"\n\"-xvnc                  As in -create, except Xvnc instead of Xvfb.\\n\"\n\"-xvnc_redirect         As in -create, except Xvnc.redirect instead of Xvfb.\\n\"\n\"-xdummy_xvfb           Sets WAIT:cmd=FINDCREATEDISPLAY-Xdummy,Xvfb\\n\"\n\"\\n\"\n\"-create_xsrv str       Sets WAIT:cmd=FINDCREATEDISPLAY-<str>  Can be on cmdline\\n\"\n\"                       after anything that sets WAIT:.. and other things\\n\"\n\"                       (e.g. -svc, -xdmsvc) to adjust the X server list.\\n\"\n\"                       Example: -svc ... -create_xsrv Xdummy,X\\n\"\n\"\\n\"\n\"-svc                   Terminal services mode based on SSL access.  Alias for\\n\"\n\"                       -display WAIT:cmd=FINDCREATEDISPLAY-Xvfb -unixpw -users\\n\"\n\"                       unixpw= -ssl SAVE   Also \\\"-service\\\".\\n\"\n\"\\n\"\n\"                       Note: if a -display, -unixpw, -users, or -ssl occurs\\n\"\n\"                       later on the command line it will override the -svc\\n\"\n\"                       setting.\\n\"\n\"\\n\"\n\"-svc_xdummy            As -svc except Xdummy instead of Xvfb.\\n\"\n\"-svc_xvnc              As -svc except Xvnc instead of Xvfb.\\n\"\n\"-svc_xdummy_xvfb       As -svc with Xdummy,Xvfb.\\n\"\n\"\\n\"\n\"-xdmsvc                Display manager Terminal services mode based on SSL.\\n\"\n\"                       Alias for -display WAIT:cmd=FINDCREATEDISPLAY-Xvfb.xdmcp\\n\"\n\"                       -unixpw -users unixpw= -ssl SAVE  Also \\\"-xdm_service\\\".\\n\"\n\"\\n\"\n\"                       Note: if a -display, -unixpw, -users, or -ssl occurs\\n\"\n\"                       later on the command line it will override the -xdmsvc\\n\"\n\"                       setting.\\n\"\n\"\\n\"\n\"                       To create a session a user will have to first log in\\n\"\n\"                       to the -unixpw dialog and then log in again to the\\n\"\n\"                       XDM/GDM/KDM prompt.  Subsequent re-connections will\\n\"\n\"                       only require the -unixpw password.  See the discussion\\n\"\n\"                       under -display WAIT:... for more details about XDM,\\n\"\n\"                       etc configuration.\\n\"\n\"\\n\"\n\"                       Remember to enable XDMCP in the xdm-config, gdm.conf,\\n\"\n\"                       or kdmrc configuration file.  See -display WAIT: for\\n\"\n\"                       more info.\\n\"\n\"\\n\"\n\"-sshxdmsvc             Display manager Terminal services mode based on SSH.\\n\"\n\"                       Alias for -display WAIT:cmd=FINDCREATEDISPLAY-Xvfb.xdmcp\\n\"\n\"                       -localhost.\\n\"\n\"\\n\"\n\"                       The -localhost option constrains connections to come\\n\"\n\"                       in via a SSH tunnel (which will require a login).\\n\"\n\"                       To create a session a user will also have to log into\\n\"\n\"                       the XDM GDM KDM prompt. Subsequent re-connections will\\n\"\n\"                       only only require the SSH login.  See the discussion\\n\"\n\"                       under -display WAIT:... for more details about XDM,\\n\"\n\"                       etc configuration.\\n\"\n\"\\n\"\n\"                       Remember to enable XDMCP in the xdm-config, gdm.conf,\\n\"\n\"                       or kdmrc configuration file.  See -display WAIT: for\\n\"\n\"                       more info.\\n\"\n\"\\n\"\n\"-unixpw_system_greeter Present a \\\"Press 'Escape' for System Greeter\\\" option\\n\"\n\"                       to the connecting VNC client in combined -unixpw\\n\"\n\"                       and xdmcp FINDCREATEDISPLAY modes (e.g. -xdmsvc).\\n\"\n\"\\n\"\n\"                       Normally in a -unixpw mode the VNC client must\\n\"\n\"                       supply a valid username and password to gain access.\\n\"\n\"                       However, if -unixpw_system_greeter is supplied AND\\n\"\n\"                       the FINDCREATEDISPLAY command matches 'xdmcp', then\\n\"\n\"                       the user has the option to press Escape and then get a\\n\"\n\"                       XDM/GDM/KDM login/greeter panel instead. They will then\\n\"\n\"                       supply a username and password directly to the greeter.\\n\"\n\"\\n\"\n\"                       Otherwise, in xdmcp FINDCREATEDISPLAY mode the user\\n\"\n\"                       must supply his username and password TWICE.  First to\\n\"\n\"                       the initial unixpw login dialog, and second to the\\n\"\n\"                       subsequent XDM/GDM/KDM greeter.  Note that if the user\\n\"\n\"                       re-connects and supplies his username and password in\\n\"\n\"                       the unixpw dialog the xdmcp greeter is skipped and\\n\"\n\"                       he is connected directly to his existing X session.\\n\"\n\"                       So the -unixpw_system_greeter option avoids the extra\\n\"\n\"                       password at X session creation time.\\n\"\n\"\\n\"\n\"                       Example:  x11vnc -xdmsvc -unixpw_system_greeter\\n\"\n\"                       See -unixpw and -display WAIT:... for more info.\\n\"\n\"\\n\"\n\"                       The special options after a colon at the end of the\\n\"\n\"                       username (e.g. user:solid) described under -display\\n\"\n\"                       WAIT: are also applied in this mode if they are typed\\n\"\n\"                       in before the user hits Escape.  The username is ignored\\n\"\n\"                       but the colon options are not.\\n\"\n\"\\n\"\n\"                       The default message is 2 lines in a small font, set\\n\"\n\"                       the env. var. X11VNC_SYSTEM_GREETER1=true for a 1 line\\n\"\n\"                       message in a larger font.\\n\"\n\"\\n\"\n\"                       If the user pressed Escape the FINDCREATEDISPLAY command\\n\"\n\"                       will be run with the env. var. X11VNC_XDM_ONLY=1.\\n\"\n\"\\n\"\n\"                       Remember to enable XDMCP in the xdm-config, gdm.conf,\\n\"\n\"                       or kdmrc configuration file.  See -display WAIT: for\\n\"\n\"                       more info.\\n\"\n\"\\n\"\n\"-redirect port         As in FINDCREATEDISPLAY-Xvnc.redirect mode except\\n\"\n\"                       redirect immediately (i.e. without X session finding\\n\"\n\"                       or creation) to a VNC server listening on port. You\\n\"\n\"                       can also supply host:port to redirect to a different\\n\"\n\"                       machine.\\n\"\n\"\\n\"\n\"                       If 0 <= port < 200 it is taken as a VNC display (5900 is\\n\"\n\"                       added to get the actual port), if port < 0 then -port\\n\"\n\"                       is used.\\n\"\n\"\\n\"\n\"                       Probably the only reason to use the -redirect option\\n\"\n\"                       is in conjunction with SSL support, e.g. -ssl SAVE.\\n\"\n\"                       This provides an easy way to add SSL encryption to a VNC\\n\"\n\"                       server that does not support SSL (e.g. Xvnc or vnc.so)\\n\"\n\"                       In fact, the protocol does not even need to be VNC,\\n\"\n\"                       and so \\\"-rfbport port1 -ssl SAVE -redirect host:port2\\\"\\n\"\n\"                       can act as a replacement for stunnel(1).\\n\"\n\"\\n\"\n\"                       This mode only allows one redirected connection.\\n\"\n\"                       The -forever option does not apply.  Use -inetd or\\n\"\n\"                       -loop for persistent service.\\n\"\n\"\\n\"\n\"-display WAIT:...      A special usage mode for the normal -display option.\\n\"\n\"                       Useful with -unixpw, but can be used independently\\n\"\n\"                       of it.  If the display string begins with WAIT: then\\n\"\n\"                       x11vnc waits until a VNC client connects before opening\\n\"\n\"                       the X display (or -rawfb device).\\n\"\n\"\\n\"\n\"                       This could be useful for delaying opening the display\\n\"\n\"                       for certain usage modes (say if x11vnc is started at\\n\"\n\"                       boot time and no X server is running or users logged\\n\"\n\"                       in yet).\\n\"\n\"\\n\"\n\"                       If the string is, e.g. WAIT:0.0 or WAIT:1, i.e. \\\"WAIT\\\"\\n\"\n\"                       in front of a normal X display, then that indicated\\n\"\n\"                       display is used.\\n\"\n\"\\n\"\n\"                       One can also insert a geometry between colons, e.g.\\n\"\n\"                       WAIT:1280x1024:... to set the size of the display the\\n\"\n\"                       VNC client first attaches to since some VNC viewers\\n\"\n\"                       will not automatically adjust to a new framebuffer size.\\n\"\n\"\\n\"\n\"                       A more interesting case is like this:\\n\"\n\"\\n\"\n\"                            WAIT:cmd=/usr/local/bin/find_display\\n\"\n\"\\n\"\n\"                       in which case the command after \\\"cmd=\\\" is run to\\n\"\n\"                       dynamically work out the DISPLAY and optionally the\\n\"\n\"                       XAUTHORITY data.  The first line of the command output\\n\"\n\"                       must be of the form DISPLAY=<xdisplay>.  On Linux\\n\"\n\"                       if the virtual terminal is known append \\\",VT=n\\\" to\\n\"\n\"                       this string and the chvt(1) program will also be run.\\n\"\n\"                       Any remaining output is taken as XAUTHORITY data.\\n\"\n\"                       It can be either of the form XAUTHORITY=<file> or raw\\n\"\n\"                       xauthority data for the display. For example;\\n\"\n\"\\n\"\n\"                            xauth extract - $DISPLAY\\\"\\n\"\n\"\\n\"\n\"                       NOTE: As specified in the previous paragraph, you can\\n\"\n\"                       supply your own WAIT:cmd=... program or script, BUT\\n\"\n\"                       there are two very useful *BUILT-IN* ones: FINDDISPLAY\\n\"\n\"                       (alias -find above) and FINDCREATEDISPLAY (alias -create\\n\"\n\"                       above.)  Most people use these instead of creating\\n\"\n\"                       their own script.  Read the following (especially the\\n\"\n\"                       BUILT-IN modes sections) to see how to configure these\\n\"\n\"                       two useful builtin -display WAIT: modes.\\n\"\n\"\\n\"\n\"                       In the case of -unixpw (and -unixpw_nis only if x11vnc\\n\"\n\"                       is running as root), then the cmd= command is run\\n\"\n\"                       as the user who just authenticated via the login and\\n\"\n\"                       password prompt.\\n\"\n\"\\n\"\n\"                       In the case of -unixpw_cmd, the commands will also be\\n\"\n\"                       run as the logged-in user, as long as the user-supplied\\n\"\n\"                       helper program supports RFB_UNIXPW_CMD_RUN (see the\\n\"\n\"                       -unixpw_cmd option.)\\n\"\n\"\\n\"\n\"                       Also in the case of -unixpw, the user logging in can\\n\"\n\"                       place a colon at the end of her username and supply\\n\"\n\"                       a few options: scale=, scale_cursor= (or sc=), solid\\n\"\n\"                       (or so), id=, clear_mods (or cm), clear_keys (or\\n\"\n\"                       ck), clear_all (or ca), repeat, speeds= (or sp=),\\n\"\n\"                       readtimeout= (or rd=), viewonly (or vo), nodisplay=\\n\"\n\"                       (or nd=), rotate= (or ro=), or noncache (or nc),\\n\"\n\"                       all separated by commas if there is more than one.\\n\"\n\"                       After the user logs in successfully, these options will\\n\"\n\"                       be applied to the VNC screen.  For example,\\n\"\n\"\\n\"\n\"                          login: fred:scale=3/4,sc=1,repeat\\n\"\n\"                          Password: ...\\n\"\n\"\\n\"\n\"                          login: runge:sp=modem,rd=120,solid\\n\"\n\"\\n\"\n\"                       for convenience m/n implies scale= e.g. fred:3/4  If you\\n\"\n\"                       type and enter your password incorrectly, to retrieve\\n\"\n\"                       your long \\\"login:\\\" line press the Up arrow once\\n\"\n\"                       (before typing anything else).\\n\"\n\"\\n\"\n\"                       Most of these colon options only apply to the builtin\\n\"\n\"                       FINDDISPLAY and FINDCREATEDISPLAY modes, but note\\n\"\n\"                       that they are passed to the extrenal command in the\\n\"\n\"                       environment as well and so could be used.\\n\"\n\"\\n\"\n\"                       In the login panel, press F1 to get a list of the\\n\"\n\"                       available options that you can add after the username.\\n\"\n\"\\n\"\n\"                       Another option is \\\"geom=WxH\\\" or \\\"geom=WxHxD\\\" (or\\n\"\n\"                       ge=). This only has an effect in FINDCREATEDISPLAY\\n\"\n\"                       mode when a virtual X server such as Xvfb is going\\n\"\n\"                       to be created.  It sets the width and height of\\n\"\n\"                       the new display, and optionally the color depth as\\n\"\n\"                       well.\\n\"\n\"\\n\"\n\"                       You can also supply \\\"gnome\\\", \\\"kde\\\", \\\"twm\\\",\\n\"\n\"                       \\\"fvwm\\\", \\\"mwm\\\", \\\"dtwm\\\", \\\"wmaker\\\", \\\"xfce\\\",\\n\"\n\"                       \\\"lxde\\\", \\\"enlightenment\\\", \\\"Xsession\\\", or\\n\"\n\"                       \\\"failsafe\\\" (same as \\\"xterm\\\") to have the created\\n\"\n\"                       display use that mode for the user session.\\n\"\n\"\\n\"\n\"                       Specify \\\"tag=...\\\" to set the unique FD_TAG desktop\\n\"\n\"                       session tag described below.  Note: this option will\\n\"\n\"                       be ignored if the FD_TAG env. var. is already set or\\n\"\n\"                       if the viewer-side supplied value is not completely\\n\"\n\"                       composed of alphanumeric or '_' or '-' characters.\\n\"\n\"\\n\"\n\"                       User preferences file: Instead of having the user type\\n\"\n\"                       in geom=WxH,... etc. every time he logs in to find\\n\"\n\"                       or create his X session, if you set FD_USERPREFS to\\n\"\n\"                       a string that does not contain the \\\"/\\\" character,\\n\"\n\"                       then the user's home directory is prepended to that\\n\"\n\"                       string and if the file exists its first line is read\\n\"\n\"                       and appended to any options he supplied at the login:\\n\"\n\"                       prompt.  For example -env FD_USERPREFS=.x11vnc_create\\n\"\n\"                       and the user put \\\"geom=1600x1200\\\" in his\\n\"\n\"                       ~/.x11vnc_create file.\\n\"\n\"\\n\"\n\"                       To disable the option setting set the environment\\n\"\n\"                       variable X11VNC_NO_UNIXPW_OPTS=1 before starting x11vnc.\\n\"\n\"                       To set any other options, the user can use the gui\\n\"\n\"                       (x11vnc -gui connect) or the remote control method\\n\"\n\"                       (x11vnc -R opt:val) during his VNC session.\\n\"\n\"\\n\"\n\"                       So we see the combination of -display WAIT:cmd=... and\\n\"\n\"                       -unixpw allows automatic pairing of an unix\\n\"\n\"                       authenticated VNC user with his desktop.  This could\\n\"\n\"                       be very useful on SunRays and also any system where\\n\"\n\"                       multiple users share a given machine.  The user does\\n\"\n\"                       not need to remember special ports or passwords set up\\n\"\n\"                       for his desktop and VNC.\\n\"\n\"\\n\"\n\"                       A nice way to use WAIT:cmd=... is out of inetd(8)\\n\"\n\"                       (it automatically forks a new x11vnc for each user).\\n\"\n\"                       You can have the x11vnc inetd spawned process run as,\\n\"\n\"                       say, root or nobody.  When run as root (for either inetd\\n\"\n\"                       or display manager), you can also supply the option\\n\"\n\"                       \\\"-users unixpw=\\\" to have the x11vnc process switch to\\n\"\n\"                       the user as well.  Note: there will be a 2nd SSL helper\\n\"\n\"                       process that will not switch, but it is only encoding\\n\"\n\"                       and decoding the encrypted stream at that point.\\n\"\n\"\\n\"\n\"                       BUILT-IN modes:\\n\"\n\"\\n\"\n\"                       -- Automatic Finding of User X Sessions --\\n\"\n\"\\n\"\n\"                       As a special case, WAIT:cmd=FINDDISPLAY will run a\\n\"\n\"                       script that works on most Unixes to determine a user's\\n\"\n\"                       DISPLAY variable and xauthority data (see who(1)).\\n\"\n\"\\n\"\n\"                       NOTE: The option \\\"-find\\\" is an alias for this mode.\\n\"\n\"\\n\"\n\"                       To have this default script printed to stdout (e.g. for\\n\"\n\"                       customization) run with WAIT:cmd=FINDDISPLAY-print To\\n\"\n\"                       have the script run to print what display it would find\\n\"\n\"                       use \\\"-finddpy\\\" or WAIT:cmd=FINDDISPLAY-run\\n\"\n\"\\n\"\n\"                       The standard script runs xdpyinfo(1) run on potential\\n\"\n\"                       displays.  If your X server(s) have a login greeter\\n\"\n\"                       that exclusively grabs the Xserver, then xdpyinfo\\n\"\n\"                       blocks forever and this mode will not work.  See\\n\"\n\"                       www.karlrunge.com/x11vnc/faq.html#faq-display-manager\\n\"\n\"                       for how to disable this for dtgreet on Solaris and\\n\"\n\"                       possibly for other greeters.\\n\"\n\"\\n\"\n\"                       In -find/cmd=FINDDISPLAY mode, if you set FD_XDM=1,\\n\"\n\"                       e.g. 'x11vnc -env FD_XDM=1 -find ...' and x11vnc is\\n\"\n\"                       running as root (e.g. inetd) then it will try to find\\n\"\n\"                       the XAUTHORITY file of a running XDM/GDM/KDM login\\n\"\n\"                       greeter (i.e. no user has logged into an X session yet.)\\n\"\n\"\\n\"\n\"                       As another special case, WAIT:cmd=HTTPONCE will allow\\n\"\n\"                       x11vnc to service one http request and then exit.\\n\"\n\"                       This is usually done in -inetd mode to run on, say,\\n\"\n\"                       port 5800 and allow the Java vncviewer to be downloaded\\n\"\n\"                       by client web browsers.  For example:\\n\"\n\"\\n\"\n\"                        5815 stream tcp nowait root /usr/sbin/tcpd /.../x11vnc \\\\\\n\"\n\"                          -inetd -q -http_ssl -prog /.../x11vnc \\\\\\n\"\n\"                          -display WAIT:cmd=HTTPONCE\\n\"\n\"\\n\"\n\"                       Where /.../x11vnc is the full path to x11vnc.\\n\"\n\"                       It is used in the Apache SSL-portal example (see FAQ).\\n\"\n\"\\n\"\n\"                       In this mode you can set X11VNC_SKIP_DISPLAY to a\\n\"\n\"                       comma separated list of displays (e.g. \\\":0,:1\\\") to\\n\"\n\"                       ignore in the finding process.  The \\\":\\\" is optional.\\n\"\n\"                       Ranges n-m e.g. 0-20 can also be supplied. This string\\n\"\n\"                       can also be set by the connecting user via \\\"nd=\\\"\\n\"\n\"                       using \\\"+\\\" instead of \\\",\\\"  If \\\"nd=all\\\" or you set\\n\"\n\"                       X11VNC_SKIP_DISPLAY=all then all display finding fails\\n\"\n\"                       as if you set X11VNC_FINDDISPLAY_ALWAYS_FAILS=1 (below.)\\n\"\n\"\\n\"\n\"                       On some systems lsof(1) can be very slow.  Set the\\n\"\n\"                       env. var. FIND_DISPLAY_NO_LSOF=1 to skip using lsof to\\n\"\n\"                       try to find the Linux VT the X server is running on.\\n\"\n\"                       set FIND_DISPLAY_NO_VT_FIND=1 to avoid looking at all.\\n\"\n\"\\n\"\n\"                       -- Automatic Creation of User X Sessions --\\n\"\n\"\\n\"\n\"                       An interesting option is WAIT:cmd=FINDCREATEDISPLAY\\n\"\n\"                       that is like FINDDISPLAY in that is uses the same method\\n\"\n\"                       to find an existing display.  However, if it does not\\n\"\n\"                       find one it will try to *start* up an X server session\\n\"\n\"                       for the user.  This is the only time x11vnc tries to\\n\"\n\"                       actually start up an X server.\\n\"\n\"\\n\"\n\"                       NOTE: The option \\\"-create\\\" is an alias for this mode.\\n\"\n\"\\n\"\n\"                       It will start looking for an open display number at :20\\n\"\n\"                       Override via X11VNC_CREATE_STARTING_DISPLAY_NUMBER=n\\n\"\n\"                       By default 80 X displays are allowed (i.e. going to :99)\\n\"\n\"                       Override via X11VNC_CREATE_MAX_DISPLAYS=n\\n\"\n\"\\n\"\n\"                       For its heuristics, the create display script sets\\n\"\n\"                       LC_ALL=C so that command output is uniform.  By default\\n\"\n\"                       it will try to restore LC_ALL right before starting the\\n\"\n\"                       user session.  However, if you don't mind it keeping\\n\"\n\"                       LC_ALL=C set the env. var.: X11VNC_CREATE_LC_ALL_C_OK=1\\n\"\n\"\\n\"\n\"                       By default FINDCREATEDISPLAY will try Xvfb and then\\n\"\n\"                       Xdummy:\\n\"\n\"\\n\"\n\"                       The Xdummy wrapper is part of the x11vnc source code\\n\"\n\"                       (x11vnc/misc/Xdummy)  It should be available in PATH\\n\"\n\"                       and have run \\\"Xdummy -install\\\" once to create the\\n\"\n\"                       shared library.  Xdummy only works on Linux.  As of\\n\"\n\"                       12/2009 it no longer needs to be run as root, and the\\n\"\n\"                       default is to not run as root.  In some circumstances\\n\"\n\"                       permissions may require running it as root, in these\\n\"\n\"                       cases specify FD_XDUMMY_RUN_AS_ROOT=1, this is the same\\n\"\n\"                       as supplying -root to the Xdummy cmdline.\\n\"\n\"\\n\"\n\"                       Xvfb is available on most platforms and does not\\n\"\n\"                       require root.\\n\"\n\"\\n\"\n\"                       An advantage of Xdummy over Xvfb is that Xdummy supports\\n\"\n\"                       RANDR dynamic screen resizing.\\n\"\n\"\\n\"\n\"                       When x11vnc exits (i.e. user disconnects) the X\\n\"\n\"                       server session stays running in the background.\\n\"\n\"                       The FINDDISPLAY will find it directly next time.\\n\"\n\"                       The user must exit the X session in the usual way for\\n\"\n\"                       it to terminate (or kill the X server process if all\\n\"\n\"                       else fails).\\n\"\n\"\\n\"\n\"                       To troubleshoot the FINDCREATEDISPLAY mechanism,\\n\"\n\"                       set the following env. var. to an output log file,\\n\"\n\"                       e.g -env CREATE_DISPLAY_OUTPUT=/tmp/mydebug.txt\\n\"\n\"\\n\"\n\"                       So this is a somewhat odd mode for x11vnc in that it\\n\"\n\"                       will start up and poll virtual X servers!  This can\\n\"\n\"                       be used from, say, inetd(8) to provide a means of\\n\"\n\"                       definitely getting a desktop (either real or virtual)\\n\"\n\"                       on the machine.  E.g. a desktop service:\\n\"\n\"\\n\"\n\"                         5900 stream tcp nowait root /usr/sbin/tcpd /.../x11vnc\\n\"\n\"                          -inetd -q -http -ssl SAVE -unixpw -users unixpw=\\\\\\n\"\n\"                          -passwd secret -prog /.../x11vnc \\\\\\n\"\n\"                          -display WAIT:cmd=FINDCREATEDISPLAY\\n\"\n\"\\n\"\n\"                       Where /.../x11vnc is the full path to x11vnc.\\n\"\n\"\\n\"\n\"                       See the -svc/-service option alias above.\\n\"\n\"\\n\"\n\"                       If for some reason you do not want x11vnc to ever\\n\"\n\"                       try to find an existing display set the env. var\\n\"\n\"                       X11VNC_FINDDISPLAY_ALWAYS_FAILS=1 (also -env ...)\\n\"\n\"                       This is the same as setting X11VNC_SKIP_DISPLAY=all or\\n\"\n\"                       supplying \\\"nd=all\\\" after \\\"username:\\\"\\n\"\n\"\\n\"\n\"                       Use WAIT:cmd=FINDCREATEDISPLAY-print to print out the\\n\"\n\"                       script that is used for this.\\n\"\n\"\\n\"\n\"                       You can specify the preferred X server order via e.g.,\\n\"\n\"                       WAIT:cmd=FINDCREATEDISPLAY-Xdummy,Xvfb,X  and/or leave\\n\"\n\"                       out ones you do not want.  The the case \\\"X\\\" means try\\n\"\n\"                       to start up a real, hardware X server using xinit(1)\\n\"\n\"                       or startx(1).  If there is already an X server running\\n\"\n\"                       the X case may only work on Linux (see startx(1)).\\n\"\n\"\\n\"\n\"                       \\\"Xvnc\\\" will start up a VNC X server (real-\\n\"\n\"                       or tight-vnc, e.g. use if Xvfb is not available).\\n\"\n\"                       \\\"Xsrv\\\" will start up the server program in the\\n\"\n\"                       variable \\\"FD_XSRV\\\" if it is non-empty. You can make\\n\"\n\"                       this be a wrapper script if you like (it must handle :N,\\n\"\n\"                       -geometry, and -depth and other X server options).\\n\"\n\"\\n\"\n\"                       You can set the environment variable FD_GEOM (or\\n\"\n\"                       X11VNC_CREATE_GEOM) to WxH or WxHxD to set the width\\n\"\n\"                       and height and optionally the color depth of the\\n\"\n\"                       created display.  You can also set FD_SESS to be the\\n\"\n\"                       session (short name of the windowmanager: kde, gnome,\\n\"\n\"                       twm, failsafe, etc.). FD_OPTS contains extra options\\n\"\n\"                       to pass to the X server. You can also set FD_PROG to\\n\"\n\"                       be the full path to the session/windowmanager program.\\n\"\n\"\\n\"\n\"                       More FD tricks:  FD_CUPS=port or FD_CUPS=host:port\\n\"\n\"                       will set the cups printing environment.  Similarly for\\n\"\n\"                       FD_ESD=port or FD_ESD=host:port for esddsp sound\\n\"\n\"                       redirection.  Set FD_EXTRA to a command to be run a\\n\"\n\"                       few seconds after the X server starts up.  Set FD_TAG\\n\"\n\"                       to be a unique name for the session, it is set as an\\n\"\n\"                       X property, that makes FINDDISPLAY only find sessions\\n\"\n\"                       with that tag value.\\n\"\n\"\\n\"\n\"                       Set FD_XDMCP_IF to the network interface that the\\n\"\n\"                       display manager is running on; default is 'localhost'\\n\"\n\"                       but you may need to set it to '::1' on some IPv6 only\\n\"\n\"                       systems or misconfigured display managers.\\n\"\n\"\\n\"\n\"                       If you want the FINDCREATEDISPLAY session to contact an\\n\"\n\"                       XDMCP login manager (xdm/gdm/kdm) on the same machine,\\n\"\n\"                       then use \\\"Xvfb.xdmcp\\\" instead of \\\"Xvfb\\\", etc.\\n\"\n\"                       The user will have to supply his username and password\\n\"\n\"                       one more time (but he gets to select his desktop type\\n\"\n\"                       so that can be useful).  For this to work, you will\\n\"\n\"                       need to enable localhost XDMCP (udp port 177) for the\\n\"\n\"                       display manager.  This seems to be:\\n\"\n\"\\n\"\n\"                        for gdm in gdm.conf:   Enable=true in section [xdmcp]\\n\"\n\"                        for kdm in kdmrc:      Enable=true in section [Xdmcp]\\n\"\n\"                        for xdm in xdm-config: DisplayManager.requestPort: 177\\n\"\n\"\\n\"\n\"                       See the shorthand options above \\\"-svc\\\", \\\"-xdmsvc\\\"\\n\"\n\"                       and \\\"-sshxdmsvc\\\" that specify the above options for\\n\"\n\"                       some useful cases.\\n\"\n\"\\n\"\n\"                       If you set the env. var WAITBG=1 x11vnc will go into\\n\"\n\"                       the background once listening in wait mode.\\n\"\n\"\\n\"\n\"                       Another special mode is FINDCREATEDISPLAY-Xvnc.redirect,\\n\"\n\"                       (or FINDDISPLAY-Xvnc.redirect).  In this case it will\\n\"\n\"                       start up Xvnc as above if needed, but instead of\\n\"\n\"                       polling it in its normal way, it simply does a socket\\n\"\n\"                       redirection of the connected VNC viewer to the Xvnc.\\n\"\n\"\\n\"\n\"                       So in Xvnc.redirect x11vnc does no VNC but merely\\n\"\n\"                       transfers the data back and forth.  This should be\\n\"\n\"                       faster then x11vnc's polling method, but not as fast\\n\"\n\"                       as connecting directly to the Xvnc with the VNC Viewer.\\n\"\n\"                       The idea here is to take advantage of x11vnc's display\\n\"\n\"                       finding/creating scheme, SSL, and perhaps a few others.\\n\"\n\"                       Most of x11vnc's options do not apply in this mode.\\n\"\n\"\\n\"\n\"                       Xvnc.redirect should also work for the vnc.so X server\\n\"\n\"                       module for the h/w display however it will work only\\n\"\n\"                       for finding the display and the user must already be\\n\"\n\"                       logged into the X console.\\n\"\n\"\\n\"\n\"-vencrypt mode         The VeNCrypt extension to the VNC protocol allows\\n\"\n\"                       encrypted SSL/TLS connections.  If the -ssl mode is\\n\"\n\"                       enabled, then VeNCrypt is enabled as well BY DEFAULT\\n\"\n\"                       (they both use a SSL/TLS tunnel, only the protocol\\n\"\n\"                       handshake is a little different.)\\n\"\n\"\\n\"\n\"                       To control when and how VeNCrypt is used, specify the\\n\"\n\"                       mode string.  If mode is \\\"never\\\", then VeNCrypt is\\n\"\n\"                       not used.  If mode is \\\"support\\\" (the default) then\\n\"\n\"                       VeNCrypt is supported.  If mode is \\\"only\\\", then the\\n\"\n\"                       similar and older ANONTLS protocol is not simultaneously\\n\"\n\"                       supported.  x11vnc's normal SSL mode (vncs://) will be\\n\"\n\"                       supported under -ssl unless you set mode to \\\"force\\\".\\n\"\n\"\\n\"\n\"                       If mode is prefixed with \\\"nodh:\\\", then Diffie Hellman\\n\"\n\"                       anonymous key exchange is disabled.  If mode is prefixed\\n\"\n\"                       with \\\"nox509:\\\", then X509 key exchange is disabled.\\n\"\n\"\\n\"\n\"                       To disable all Anonymous Diffie-Hellman access\\n\"\n\"                       (susceptible to Man-In-The-Middle attack) you will need\\n\"\n\"                       to supply \\\"-vencrypt nodh:support -anontls never\\\"\\n\"\n\"                       or \\\"-vencrypt nodh:only\\\"\\n\"\n\"\\n\"\n\"                       If mode is prefixed with \\\"newdh:\\\", then new Diffie\\n\"\n\"                       Hellman parameters are generated for each connection\\n\"\n\"                       (this can be time consuming: 1-60 secs; see -dhparams\\n\"\n\"                       below for a faster way) rather than using the\\n\"\n\"                       fixed values in the program.  Using fixed, publicly\\n\"\n\"                       known values is not known to be a security problem.\\n\"\n\"                       This setting applies to ANONTLS as well.\\n\"\n\"\\n\"\n\"                       Long example: -vencrypt newdh:nox509:support\\n\"\n\"\\n\"\n\"                       Also, if mode is prefixed with \\\"plain:\\\", then\\n\"\n\"                       if -unixpw mode is active the VeNCrypt \\\"*Plain\\\"\\n\"\n\"                       username+passwd method is enabled for Unix logins.\\n\"\n\"                       Otherwise in -unixpw mode the normal login panel is\\n\"\n\"                       provided.\\n\"\n\"\\n\"\n\"                       You *MUST* supply the -ssl option for VeNCrypt to\\n\"\n\"                       be active.  The -vencrypt option only fine-tunes its\\n\"\n\"                       operation.\\n\"\n\"\\n\"\n\"-anontls mode          The ANONTLS extension to the VNC protocol allows\\n\"\n\"                       encrypted SSL/TLS connections.  If the -ssl mode is\\n\"\n\"                       enabled, then ANONTLS is enabled as well BY DEFAULT\\n\"\n\"                       (they both use a SSL/TLS tunnel, only the protocol\\n\"\n\"                       handshake is a little different.)\\n\"\n\"\\n\"\n\"                       ANONTLS is an older SSL/TLS mode introduced by vino.\\n\"\n\"\\n\"\n\"                       It is referred to as 'TLS' for its registered VNC\\n\"\n\"                       security-type name, but we use the more descriptive\\n\"\n\"                       'ANONTLS' here because it provides only Anonymous\\n\"\n\"                       Diffie-Hellman encrypted connections, and hence no\\n\"\n\"                       possibility for certificate authentication.\\n\"\n\"\\n\"\n\"                       To control when and how ANONTLS is used, specify the\\n\"\n\"                       mode string.  If mode is \\\"never\\\", then ANONTLS is not\\n\"\n\"                       used.  If mode is \\\"support\\\" (the default) then ANONTLS\\n\"\n\"                       is supported.  If mode is \\\"only\\\", then the similar\\n\"\n\"                       VeNCrypt protocol is not simultaneously supported.\\n\"\n\"                       x11vnc's normal SSL mode (vncs://) will be supported\\n\"\n\"                       under -ssl unless you set mode to \\\"force\\\".\\n\"\n\"\\n\"\n\"                       If mode is prefixed with \\\"newdh:\\\", then new Diffie\\n\"\n\"                       Hellman parameters are generated for each connection\\n\"\n\"                       (this can be time consuming: 1-60 secs; see -dhparams\\n\"\n\"                       below for a faster way) rather than using the\\n\"\n\"                       fixed values in the program.  Using fixed, publicly\\n\"\n\"                       known values is not known to be a security problem.\\n\"\n\"                       This setting applies to VeNCrypt as well.  See the\\n\"\n\"                       description of \\\"plain:\\\" under -vencrypt.\\n\"\n\"\\n\"\n\"                       Long example: -anontls newdh:plain:support\\n\"\n\"\\n\"\n\"                       You *MUST* supply the -ssl option for ANONTLS to\\n\"\n\"                       be active.  The -anontls option only fine-tunes its\\n\"\n\"                       operation.\\n\"\n\"\\n\"\n\"-sslonly               Same as: \\\"-vencrypt never -anontls never\\\"  i.e. it\\n\"\n\"                       disables the VeNCrypt and ANONTLS encryption methods\\n\"\n\"                       and only allows standard SSL tunneling.  You must also\\n\"\n\"                       supply the -ssl ... option (see below.)\\n\"\n\"\\n\"\n\"\\n\"\n\"-dhparams file         For some operations a set of Diffie Hellman parameters\\n\"\n\"                       (prime and generator) is needed.  If so, use the\\n\"\n\"                       parameters in \\\"file\\\". In particular, the VeNCrypt and\\n\"\n\"                       ANONTLS anonymous DH mode need them.  By default a\\n\"\n\"                       fixed set is used. If you do not want to do that you\\n\"\n\"                       can specify \\\"newdh:\\\" to the -vencrypt and -anontls\\n\"\n\"                       options to generate a new set each session.  If that\\n\"\n\"                       is too slow for you, use -dhparams file to a set you\\n\"\n\"                       created manually via \\\"openssl dhparam -out file 1024\\\"\\n\"\n\"\\n\"\n\"-nossl                 Disable the -ssl option (see below). Since -ssl is off\\n\"\n\"                       by default -nossl would only be used on the commandline\\n\"\n\"                       to unset any *earlier* -ssl option (or -svc...)\\n\"\n\"\\n\"\n\"-ssl [pem]             Use the openssl library (www.openssl.org) to provide a\\n\"\n\"                       built-in encrypted SSL/TLS tunnel between VNC viewers\\n\"\n\"                       and x11vnc.  This requires libssl support to be\\n\"\n\"                       compiled into x11vnc at build time.  If x11vnc is not\\n\"\n\"                       built with libssl support it will exit immediately when\\n\"\n\"                       -ssl is prescribed.  See the -stunnel option below for\\n\"\n\"                       an alternative.\\n\"\n\"\\n\"\n\"                       The VNC Viewer-side needs to support SSL/TLS as well.\\n\"\n\"                       See this URL and also the discussion below for\\n\"\n\"                       ideas on how to enable SSL support for the viewer:\\n\"\n\"                       http://www.karlrunge.com/x11vnc/faq.html#faq-ssl-tun\\n\"\n\"                       nel-viewers .  x11vnc provides an SSL enabled Java\\n\"\n\"                       viewer applet in the classes/ssl directory (-http or\\n\"\n\"                       -httpdir options.)  The SSVNC viewer package supports\\n\"\n\"                       SSL tunnels too.\\n\"\n\"\\n\"\n\"                       If the VNC Viewer supports VeNCrypt or ANONTLS (vino's\\n\"\n\"                       encryption mode) they are also supported by the -ssl\\n\"\n\"                       mode (see the -vencrypt and -anontls options for more\\n\"\n\"                       info; use -sslonly to disable both of them.)\\n\"\n\"\\n\"\n\"                       Use \\\"-ssl /path/to/mycert.pem\\\" to specify an SSL\\n\"\n\"                       certificate file in PEM format to use to identify and\\n\"\n\"                       provide a key for this server.  See openssl(1) for more\\n\"\n\"                       info about PEMs and the -sslGenCert and \\\"-ssl SAVE\\\"\\n\"\n\"                       options below for how to create them.\\n\"\n\"\\n\"\n\"                       The connecting VNC viewer SSL tunnel can (at its option)\\n\"\n\"                       authenticate this server if it has the public key part\\n\"\n\"                       of the certificate (or a common certificate authority,\\n\"\n\"                       CA, is a more sophisticated way to verify this server's\\n\"\n\"                       cert, see -sslGenCA below).  This authentication is\\n\"\n\"                       done to prevent Man-In-The-Middle attacks.  Otherwise,\\n\"\n\"                       if the VNC viewer simply accepts this server's key\\n\"\n\"                       WITHOUT verification, the traffic is protected from\\n\"\n\"                       passive sniffing on the network, but *NOT* from\\n\"\n\"                       Man-In-The-Middle attacks. There are hacker tools\\n\"\n\"                       like dsniff/webmitm and cain that implement SSL\\n\"\n\"                       Man-In-The-Middle attacks.\\n\"\n\"\\n\"\n\"                       If [pem] is empty or the string \\\"SAVE\\\" then the\\n\"\n\"                       openssl(1) command must be available to generate the\\n\"\n\"                       certificate the first time.  A self-signed certificate\\n\"\n\"                       is generated (see -sslGenCA and -sslGenCert for use\\n\"\n\"                       of a Certificate Authority.)  It will be saved to the\\n\"\n\"                       file ~/.vnc/certs/server.pem.  On subsequent calls if\\n\"\n\"                       that file already exists it will be used directly.\\n\"\n\"\\n\"\n\"                       Use \\\"SAVE_NOPROMPT\\\" to avoid being prompted to\\n\"\n\"                       protect the generated key with a passphrase.  However in\\n\"\n\"                       -inetd and -bg modes there will be no prompting for a\\n\"\n\"                       passphrase in either case.\\n\"\n\"\\n\"\n\"                       If [pem] is \\\"SAVE_PROMPT\\\" the server.pem certificate\\n\"\n\"                       will be created based on your answers to its prompts for\\n\"\n\"                       all info such as OrganizationalName, CommonName, etc.\\n\"\n\"\\n\"\n\"                       Use \\\"SAVE-<string>\\\" and \\\"SAVE_PROMPT-<string>\\\"\\n\"\n\"                       to refer to the file ~/.vnc/certs/server-<string>.pem\\n\"\n\"                       instead (it will be generated if it does not already\\n\"\n\"                       exist).  E.g. \\\"SAVE-charlie\\\" will store to the file\\n\"\n\"                       ~/.vnc/certs/server-charlie.pem\\n\"\n\"\\n\"\n\"                       Examples: x11vnc -ssl SAVE -display :0 ...\\n\"\n\"                                 x11vnc -ssl SAVE-someother -display :0 ...\\n\"\n\"\\n\"\n\"                       If [pem] is \\\"TMP\\\" and the openssl(1) utility\\n\"\n\"                       command exists in PATH, then a temporary, self-signed\\n\"\n\"                       certificate will be generated for this session.  If\\n\"\n\"                       openssl(1) cannot be used to generate a temporary\\n\"\n\"                       certificate x11vnc exits immediately.  The temporary\\n\"\n\"                       cert will be discarded when x11vnc exits.\\n\"\n\"\\n\"\n\"                       If successful in using openssl(1) to generate a\\n\"\n\"                       temporary certificate in \\\"SAVE\\\" or \\\"TMP\\\" creation\\n\"\n\"                       modes, the public part of it will be displayed to stderr\\n\"\n\"                       (e.g. one could copy it to the client-side to provide\\n\"\n\"                       authentication of the server to VNC viewers.)\\n\"\n\"\\n\"\n\"                       NOTE: In \\\"TMP\\\" mode, unless you safely copy the\\n\"\n\"                       public part of the temporary Cert to the viewer for\\n\"\n\"                       authenticate *every time* (unlikely...), then only\\n\"\n\"                       passive sniffing attacks are prevented and you are\\n\"\n\"                       still open to Man-In-The-Middle attacks.  This is\\n\"\n\"                       why the default \\\"SAVE\\\" mode is preferred (and more\\n\"\n\"                       sophisticated CA mode too).  Only with saved keys AND\\n\"\n\"                       the VNC viewer authenticating them (via the public\\n\"\n\"                       certificate), are Man-In-The-Middle attacks prevented.\\n\"\n\"\\n\"\n\"                       If [pem] is \\\"ANON\\\" then the Diffie-Hellman anonymous\\n\"\n\"                       key exchange method is used.  In this mode there\\n\"\n\"                       are *no* SSL certificates and so it is not possible\\n\"\n\"                       to authenticate either the VNC server or VNC client.\\n\"\n\"                       Thus only passive network sniffing attacks are avoided:\\n\"\n\"                       the \\\"ANON\\\" method is susceptible to Man-In-The-Middle\\n\"\n\"                       attacks.  \\\"ANON\\\" is not recommended; instead use\\n\"\n\"                       a SSL PEM you created or the default \\\"SAVE\\\" method.\\n\"\n\"\\n\"\n\"                       See -ssldir below to use a directory besides the\\n\"\n\"                       default ~/.vnc/certs\\n\"\n\"\\n\"\n\"                       If your x11vnc binary was not compiled with OpenSSL\\n\"\n\"                       library support, use of the -ssl option will induce an\\n\"\n\"                       immediate failure and exit.  For such binaries, consider\\n\"\n\"                       using the -stunnel option for SSL encrypted connections.\\n\"\n\"\\n\"\n\"                       Misc Info: In temporary cert creation mode \\\"TMP\\\", set\\n\"\n\"                       the env. var. X11VNC_SHOW_TMP_PEM=1 to have x11vnc print\\n\"\n\"                       out the entire certificate, including the PRIVATE KEY\\n\"\n\"                       part, to stderr.  There are better ways to get/save this\\n\"\n\"                       info.  See \\\"SAVE\\\" above and \\\"-sslGenCert\\\" below.\\n\"\n\"\\n\"\n\"-ssltimeout n          Set SSL read timeout to n seconds.  In some situations\\n\"\n\"                       (i.e. an iconified viewer in Windows) the viewer stops\\n\"\n\"                       talking and the connection is dropped after the default\\n\"\n\"                       timeout (25s for about the first minute, 43200s later).\\n\"\n\"                       Set to zero to poll forever.  Set to a negative value\\n\"\n\"                       to use the builtin setting.\\n\"\n\"\\n\"\n\"                       Note that this value does NOT apply to the *initial* ssl\\n\"\n\"                       init connection.  The default timeout for that is 20sec.\\n\"\n\"                       Use -env SSL_INIT_TIMEOUT=n to modify it.\\n\"\n\"\\n\"\n\"-sslnofail             Exit at the first SSL connection failure. Useful when\\n\"\n\"                       scripting SSL connections (e.g. x11vnc is started via\\n\"\n\"                       ssh) and you do not want x11vnc waiting around for more\\n\"\n\"                       connections, tying up ports, etc.\\n\"\n\"\\n\"\n\"-ssldir dir            Use \\\"dir\\\" as an alternate ssl certificate and key\\n\"\n\"                       management toplevel directory.  The default is\\n\"\n\"                       ~/.vnc/certs\\n\"\n\"\\n\"\n\"                       This directory is used to store server and other\\n\"\n\"                       certificates and keys and also other materials.  E.g. in\\n\"\n\"                       the simplest case, \\\"-ssl SAVE\\\" will store the x11vnc\\n\"\n\"                       server cert in dir/server.pem\\n\"\n\"\\n\"\n\"                       Use of alternate directories via -ssldir allows you to\\n\"\n\"                       manage multiple VNC Certificate Authority (CA) keys.\\n\"\n\"                       Another use is if ~/.vnc/cert is on an NFS share you\\n\"\n\"                       might want your certificates and keys to be on a local\\n\"\n\"                       filesystem to prevent network snooping (for example\\n\"\n\"                       -ssldir /var/lib/x11vnc-certs).\\n\"\n\"\\n\"\n\"                       -ssldir affects nearly all of the other -ssl* options,\\n\"\n\"                       e.g. -ssl SAVE, -sslGenCert, etc..\\n\"\n\"\\n\"\n\"-sslverify path        For either of the -ssl or -stunnel modes, use \\\"path\\\"\\n\"\n\"                       to provide certificates to authenticate incoming VNC\\n\"\n\"                       *Client* connections (normally only the server is\\n\"\n\"                       authenticated in SSL.)  This can be used as a method\\n\"\n\"                       to replace standard password authentication of clients.\\n\"\n\"\\n\"\n\"                       If \\\"path\\\" is a directory it contains the client (or CA)\\n\"\n\"                       certificates in separate files.  If path is a file,\\n\"\n\"                       it contains one or more certificates. See special tokens\\n\"\n\"                       below.  These correspond to the \\\"CApath = dir\\\" and\\n\"\n\"                       \\\"CAfile = file\\\" stunnel options.  See the stunnel(8)\\n\"\n\"                       manpage for details.\\n\"\n\"\\n\"\n\"                       Examples:\\n\"\n\"                              x11vnc -ssl -sslverify ~/my.crt\\n\"\n\"                              x11vnc -ssl -sslverify ~/my_pem_dir/\\n\"\n\"\\n\"\n\"                       Note that if path is a directory, it must contain\\n\"\n\"                       the certs in separate files named like <HASH>.0, where\\n\"\n\"                       the value of <HASH> is found by running the command\\n\"\n\"                       \\\"openssl x509 -hash -noout -in file.crt\\\". Evidently\\n\"\n\"                       one uses <HASH>.1 if there is a collision...\\n\"\n\"\\n\"\n\"                       The the key-management utility \\\"-sslCertInfo HASHON\\\"\\n\"\n\"                       and \\\"-sslCertInfo HASHOFF\\\" will create/delete these\\n\"\n\"                       hashes for you automatically (via symlink) in the HASH\\n\"\n\"                       subdirs it manages.  Then you can point -sslverify to\\n\"\n\"                       the HASH subdir.\\n\"\n\"\\n\"\n\"                       Special tokens: in -ssl mode, if \\\"path\\\" is not a file or\\n\"\n\"                       a directory, it is taken as a comma separated list of\\n\"\n\"                       tokens that are interpreted as follows:\\n\"\n\"\\n\"\n\"                       If a token is \\\"CA\\\" that means load the CA/cacert.pem\\n\"\n\"                       file from the ssl directory.  If a token is \\\"clients\\\"\\n\"\n\"                       then all the files clients/*.crt in the ssl directory\\n\"\n\"                       are loaded.  Otherwise the file clients/token.crt\\n\"\n\"                       is attempted to be loaded.  As a kludge, use a token\\n\"\n\"                       like ../server-foo to load a server cert if you find\\n\"\n\"                       that necessary.\\n\"\n\"\\n\"\n\"                       Use -ssldir to use a directory different from the\\n\"\n\"                       ~/.vnc/certs default.\\n\"\n\"\\n\"\n\"                       Note that if the \\\"CA\\\" cert is loaded you do not need\\n\"\n\"                       to load any of the certs that have been signed by it.\\n\"\n\"                       You will need to load any additional self-signed certs\\n\"\n\"                       however.\\n\"\n\"\\n\"\n\"                       Examples:\\n\"\n\"                              x11vnc -ssl -sslverify CA\\n\"\n\"                              x11vnc -ssl -sslverify self:fred,self:jim\\n\"\n\"                              x11vnc -ssl -sslverify CA,clients\\n\"\n\"\\n\"\n\"                       Usually \\\"-sslverify CA\\\" is the most effective.\\n\"\n\"                       See the -sslGenCA and -sslGenCert options below for\\n\"\n\"                       how to set up and manage the CA framework.\\n\"\n\"\\n\"\n\"\\n\"\n\"\\n\"\n\"                       NOTE: the following utilities, -sslGenCA, -sslGenCert,\\n\"\n\"                       -sslEncKey, -sslCertInfo, and -sslCRL are provided for\\n\"\n\"                       completeness, but for casual usage they are overkill.\\n\"\n\"\\n\"\n\"                       They provide VNC Certificate Authority (CA) key creation\\n\"\n\"                       and server / client key generation and signing.  So they\\n\"\n\"                       provide a basic Public Key management framework for\\n\"\n\"                       VNC-ing with x11vnc. (note that they require openssl(1)\\n\"\n\"                       be installed on the system)\\n\"\n\"\\n\"\n\"                       However, the simplest usage mode, \\\"-ssl TMP\\\" (where\\n\"\n\"                       x11vnc automatically generates its own, self-signed,\\n\"\n\"                       temporary key and the VNC viewers always accept it,\\n\"\n\"                       e.g. accepting via a dialog box) is probably safe enough\\n\"\n\"                       for most scenarios.  CA management is not needed.\\n\"\n\"\\n\"\n\"                       To protect against Man-In-The-Middle attacks the \\\"TMP\\\"\\n\"\n\"                       mode can be improved by using \\\"-ssl SAVE\\\" (same as\\n\"\n\"                       \\\"-ssl\\\", i.e. the default) to have x11vnc create a\\n\"\n\"                       longer term self-signed certificate, and then (safely)\\n\"\n\"                       copy the corresponding public key cert to the desired\\n\"\n\"                       client machines (care must be taken the private key part\\n\"\n\"                       is not stolen; you will be prompted for a passphrase).\\n\"\n\"\\n\"\n\"                       So keep in mind no CA key creation or management\\n\"\n\"                       (-sslGenCA and -sslGenCert) is needed for either of\\n\"\n\"                       the above two common usage modes.\\n\"\n\"\\n\"\n\"                       One might want to use -sslGenCA and -sslGenCert\\n\"\n\"                       if you had a large number of VNC client and server\\n\"\n\"                       workstations.  That way the administrator could generate\\n\"\n\"                       a single CA key with -sslGenCA and distribute its\\n\"\n\"                       certificate part to all of the workstations.\\n\"\n\"\\n\"\n\"                       Next, he could create signed VNC server keys\\n\"\n\"                       (-sslGenCert server ...) for each workstation or user\\n\"\n\"                       that then x11vnc would use to authenticate itself to\\n\"\n\"                       any VNC client that has the CA cert.\\n\"\n\"\\n\"\n\"                       Optionally, the admin could also make it so the\\n\"\n\"                       VNC clients themselves are authenticated to x11vnc\\n\"\n\"                       (-sslGenCert client ...)  For this -sslverify would be\\n\"\n\"                       pointed to the CA cert (and/or self-signed certs).\\n\"\n\"\\n\"\n\"                       x11vnc will be able to use all of these cert and\\n\"\n\"                       key files.  On the VNC client side, they will need to\\n\"\n\"                       be \\\"imported\\\" somehow.  Web browsers have \\\"Manage\\n\"\n\"                       Certificates\\\" actions as does the Java applet plugin\\n\"\n\"                       Control Panel.  stunnel can also use these files (see\\n\"\n\"                       the ss_vncviewer example script in the FAQ and SSVNC.)\\n\"\n\"\\n\"\n\"-sslCRL path           Set the Certificate Revocation Lists (CRL) to \\\"path\\\".\\n\"\n\"                       This setting applies for both -ssl and -stunnel modes.\\n\"\n\"\\n\"\n\"                       If path is a file, the file contains one or more CRLs\\n\"\n\"                       in PEM format.  If path is a directory, it contains\\n\"\n\"                       hash named files of CRLs in the usual OpenSSL manner.\\n\"\n\"                       See the OpenSSL and stunnel(8) documentation for\\n\"\n\"                       more info.\\n\"\n\"\\n\"\n\"                       This option only applies if -sslverify has been\\n\"\n\"                       supplied: it checks for revocation along the\\n\"\n\"                       certificate chain used to verify the VNC client.\\n\"\n\"                       The -sslCRL setting will be ignored when -sslverify is\\n\"\n\"                       not specified.\\n\"\n\"\\n\"\n\"                       Note that if a CRL's expiration date has passed, all\\n\"\n\"                       SSL connections will fail regardless of if they are\\n\"\n\"                       related to the subject of the CRL or not.\\n\"\n\"\\n\"\n\"                       Only rarely will one's x11vnc -ssl infrastructure be so\\n\"\n\"                       large that this option would be useful (since normally\\n\"\n\"                       maintaining the contents of the -sslverify file or\\n\"\n\"                       directory should be enough.)  However, when using\\n\"\n\"                       x11vnc with a Certificate Authority (see -sslGenCA)\\n\"\n\"                       to authenticate Clients via SSL/TLS, the -sslCRL option\\n\"\n\"                       can be useful to revoke users' certs whose private SSL\\n\"\n\"                       keys were lost or stolen (e.g. laptop.)  This way a new\\n\"\n\"                       CA cert+key does not need to be created and new signed\\n\"\n\"                       client keys generated and distributed to all users.\\n\"\n\"\\n\"\n\"                       To create a CRL file with revoked certificates the\\n\"\n\"                       commands 'openssl ca -revoke ...' and 'openssl ca\\n\"\n\"                       -gencrl ...' are useful.  (Run them in ~/.vnc/certs)\\n\"\n\"\\n\"\n\"-sslGenCA [dir]        Generate your own Certificate Authority private key,\\n\"\n\"                       certificate, and other files in directory [dir].\\n\"\n\"                       x11vnc then exits.\\n\"\n\"\\n\"\n\"                       If [dir] is not supplied, a -ssldir setting is used,\\n\"\n\"                       or otherwise ~/.vnc/certs is used.\\n\"\n\"\\n\"\n\"                       This command also creates directories where server and\\n\"\n\"                       client certs and keys will be stored.  The openssl(1)\\n\"\n\"                       program must be installed on the system and available\\n\"\n\"                       in PATH.\\n\"\n\"\\n\"\n\"                       After the CA files and directories are created the\\n\"\n\"                       x11vnc command exits; the VNC server is not run.\\n\"\n\"\\n\"\n\"                       You will be prompted for information to put into the CA\\n\"\n\"                       certificate.  The info does not have to be accurate just\\n\"\n\"                       as long as clients accept the cert for VNC connections.\\n\"\n\"                       You will also need to supply a passphrase of at least\\n\"\n\"                       4 characters for the CA private key.\\n\"\n\"\\n\"\n\"                       Once you have generated the CA you can distribute\\n\"\n\"                       its certificate part, [dir]/CA/cacert.pem, to other\\n\"\n\"                       workstations where VNC viewers will be run.  One will\\n\"\n\"                       need to \\\"import\\\" this certificate in the applications,\\n\"\n\"                       e.g. Web browser, Java applet plugin, stunnel, etc.\\n\"\n\"                       Next, you can create and sign keys using the CA with\\n\"\n\"                       the -sslGenCert option below.\\n\"\n\"\\n\"\n\"                       Examples:\\n\"\n\"                                x11vnc -sslGenCA\\n\"\n\"                                x11vnc -sslGenCA  ~/myCAdir\\n\"\n\"                                x11vnc -ssldir ~/myCAdir -sslGenCA\\n\"\n\"\\n\"\n\"                       (the last two lines are equivalent)\\n\"\n\"\\n\"\n\"-sslGenCert type name  Generate a VNC server or client certificate and private\\n\"\n\"                       key pair signed by the CA created previously with\\n\"\n\"                       -sslGenCA.  The openssl(1) program must be installed\\n\"\n\"                       on the system and available in PATH.\\n\"\n\"\\n\"\n\"                       After the Certificate is generated x11vnc exits; the\\n\"\n\"                       VNC server is not run.\\n\"\n\"\\n\"\n\"                       The type of key to be generated is the string \\\"type\\\".\\n\"\n\"                       It is either \\\"server\\\" (i.e. for use by x11vnc) or\\n\"\n\"                       \\\"client\\\" (for a VNC viewer).  Note that typically\\n\"\n\"                       only \\\"server\\\" is used: the VNC clients authenticate\\n\"\n\"                       themselves by a non-public-key method (e.g. VNC or\\n\"\n\"                       unix password).  \\\"type\\\" is required.\\n\"\n\"\\n\"\n\"                       An arbitrary default name you want to associate with\\n\"\n\"                       the key is supplied by the \\\"name\\\" string.  You can\\n\"\n\"                       change it at the various prompts when creating the key.\\n\"\n\"                       \\\"name\\\" is optional.\\n\"\n\"\\n\"\n\"                       If name is left blank for clients keys then \\\"nobody\\\"\\n\"\n\"                       is used.  If left blank for server keys, then the\\n\"\n\"                       primary server key: \\\"server.pem\\\" is created (this\\n\"\n\"                       is the saved one referenced by \\\"-ssl SAVE\\\" when the\\n\"\n\"                       server is started)\\n\"\n\"\\n\"\n\"                       If \\\"name\\\" begins with the string \\\"self:\\\" then\\n\"\n\"                       a self-signed certificate is created instead of one\\n\"\n\"                       signed by your CA key.\\n\"\n\"\\n\"\n\"                       If \\\"name\\\" begins with the string \\\"req:\\\" then only a\\n\"\n\"                       key (.key) and a certificate signing *request* (.req)\\n\"\n\"                       are generated.  You can then send the .req file to\\n\"\n\"                       an external CA (even a professional one, e.g. Thawte)\\n\"\n\"                       and then combine the .key and the received cert into\\n\"\n\"                       the .pem file with the same basename.\\n\"\n\"\\n\"\n\"                       The distinction between \\\"server\\\" and \\\"client\\\" is\\n\"\n\"                       simply the choice of output filenames and sub-directory.\\n\"\n\"                       This makes it so the -ssl SAVE-name option can easily\\n\"\n\"                       pick up the x11vnc PEM file this option generates.\\n\"\n\"                       And similarly makes it easy for the -sslverify option\\n\"\n\"                       to pick up your client certs.\\n\"\n\"\\n\"\n\"                       There is nothing special about the filename or directory\\n\"\n\"                       location of either the \\\"server\\\" and \\\"client\\\" certs.\\n\"\n\"                       You can rename the files or move them to wherever\\n\"\n\"                       you like.\\n\"\n\"\\n\"\n\"                       Precede this option with -ssldir [dir] to use a\\n\"\n\"                       directory other than the default ~/.vnc/certs You will\\n\"\n\"                       need to run -sslGenCA on that directory first before\\n\"\n\"                       doing any -sslGenCert key creation.\\n\"\n\"\\n\"\n\"                       Note you cannot recreate a cert with exactly the same\\n\"\n\"                       distiguished name (DN) as an existing one.  To do so,\\n\"\n\"                       you will need to edit the [dir]/CA/index.txt file to\\n\"\n\"                       delete the line.\\n\"\n\"\\n\"\n\"                       Similar to -sslGenCA, you will be prompted to fill\\n\"\n\"                       in some information that will be recorded in the\\n\"\n\"                       certificate when it is created.\\n\"\n\"\\n\"\n\"                       Tip: if you know the fully-qualified hostname other\\n\"\n\"                       people will be connecting to, you can use that as the\\n\"\n\"                       CommonName \\\"CN\\\" to avoid some applications (e.g. web\\n\"\n\"                       browsers and java plugin) complaining that it does not\\n\"\n\"                       match the hostname.\\n\"\n\"\\n\"\n\"                       You will also need to supply the CA private key\\n\"\n\"                       passphrase to unlock the private key created from\\n\"\n\"                       -sslGenCA.  This private key is used to sign the server\\n\"\n\"                       or client certificate.\\n\"\n\"\\n\"\n\"                       The \\\"server\\\" certs can be used by x11vnc directly by\\n\"\n\"                       pointing to them via the -ssl [pem] option.  The default\\n\"\n\"                       file will be ~/.vnc/certs/server.pem.  This one would\\n\"\n\"                       be used by simply typing -ssl SAVE.  The pem file\\n\"\n\"                       contains both the certificate and the private key.\\n\"\n\"                       server.crt file contains the cert only.\\n\"\n\"\\n\"\n\"                       The \\\"client\\\" cert + private key file will need\\n\"\n\"                       to be copied and imported into the VNC viewer\\n\"\n\"                       side applications (Web browser, Java plugin,\\n\"\n\"                       stunnel, etc.)  Once that is done you can delete the\\n\"\n\"                       \\\"client\\\" private key file on this machine since\\n\"\n\"                       it is only needed on the VNC viewer side.  The,\\n\"\n\"                       e.g. ~/.vnc/certs/clients/<name>.pem contains both\\n\"\n\"                       the cert and private key.  The <name>.crt contains the\\n\"\n\"                       certificate only.\\n\"\n\"\\n\"\n\"                       NOTE: It is very important to know one should\\n\"\n\"                       generate new keys with a passphrase.  Otherwise if an\\n\"\n\"                       untrusted user steals the key file he could use it to\\n\"\n\"                       masquerade as the x11vnc server (or VNC viewer client).\\n\"\n\"                       You will be prompted whether to encrypt the key with\\n\"\n\"                       a passphrase or not.  It is recommended that you do.\\n\"\n\"                       One inconvenience to a passphrase is that it must\\n\"\n\"                       be typed in EVERY time x11vnc or the client app is\\n\"\n\"                       started up.\\n\"\n\"\\n\"\n\"                       Examples:\\n\"\n\"\\n\"\n\"                               x11vnc -sslGenCert server\\n\"\n\"                               x11vnc -ssl SAVE -display :0 ...\\n\"\n\"\\n\"\n\"                       and then on viewer using ss_vncviewer stunnel wrapper\\n\"\n\"                       (see the FAQ):\\n\"\n\n\"                               ss_vncviewer -verify ./cacert.crt hostname:0\\n\"\n\"\\n\"\n\"                       (this assumes the cacert.crt cert from -sslGenCA\\n\"\n\"                       was safely copied to the VNC viewer machine where\\n\"\n\"                       ss_vncviewer is run)\\n\"\n\"\\n\"\n\"                       Example using a name:\\n\"\n\"\\n\"\n\"                               x11vnc -sslGenCert server charlie\\n\"\n\"                               x11vnc -ssl SAVE-charlie -display :0 ...\\n\"\n\"\\n\"\n\"                       Example for a client certificate (rarely used):\\n\"\n\"\\n\"\n\"                               x11vnc -sslGenCert client roger\\n\"\n\"                               scp ~/.vnc/certs/clients/roger.pem somehost:.\\n\"\n\"                               rm  ~/.vnc/certs/clients/roger.pem\\n\"\n\"\\n\"\n\"                       x11vnc is then started with the option -sslverify\\n\"\n\"                       ~/.vnc/certs/clients/roger.crt (or simply -sslverify\\n\"\n\"                       roger), and on the viewer user on somehost could do\\n\"\n\"                       for example:\\n\"\n\"\\n\"\n\"                               ss_vncviewer -mycert ./roger.pem hostname:0\\n\"\n\"\\n\"\n\"                       If you set the env. var REQ_ARGS='...' it will be\\n\"\n\"                       passed to openssl req(1).  A common use would be\\n\"\n\"                       REQ_ARGS='-days 1095' to bump up the expiration date\\n\"\n\"                       (3 years in this case).\\n\"\n\"\\n\"\n\"-sslEncKey pem         Utility to encrypt an existing PEM file with a\\n\"\n\"                       passphrase you supply when prompted.  For that key to be\\n\"\n\"                       used (e.g. by x11vnc) the passphrase must be supplied\\n\"\n\"                       each time.\\n\"\n\"\\n\"\n\"                       The \\\"SAVE\\\" notation described under -ssl applies as\\n\"\n\"                       well. (precede this option with -ssldir [dir] to refer\\n\"\n\"                       a directory besides the default ~/.vnc/certs)\\n\"\n\"\\n\"\n\"                       The openssl(1) program must be installed on the system\\n\"\n\"                       and available in PATH.  After the Key file is encrypted\\n\"\n\"                       the x11vnc command exits; the VNC server is not run.\\n\"\n\"\\n\"\n\"                       Examples:\\n\"\n\"                               x11vnc -sslEncKey /path/to/foo.pem\\n\"\n\"                               x11vnc -sslEncKey SAVE\\n\"\n\"                               x11vnc -sslEncKey SAVE-charlie\\n\"\n\"\\n\"\n\"-sslCertInfo pem       Prints out information about an existing PEM file.\\n\"\n\"                       In addition the public certificate is also printed.\\n\"\n\"                       The openssl(1) program must be in PATH. Basically the\\n\"\n\"                       command \\\"openssl x509 -text\\\" is run on the pem.\\n\"\n\"\\n\"\n\"                       After the info is printed the x11vnc command exits;\\n\"\n\"                       the VNC server is not run.\\n\"\n\"\\n\"\n\"                       The \\\"SAVE\\\" notation described under -ssl applies\\n\"\n\"                       as well.\\n\"\n\"\\n\"\n\"                       Using  \\\"LIST\\\" will give a list of all certs being\\n\"\n\"                       managed (in the ~/.vnc/certs dir, use -ssldir to refer\\n\"\n\"                       to another dir).  \\\"ALL\\\" will print out the info for\\n\"\n\"                       every managed key (this can be very long).  Giving a\\n\"\n\"                       client or server cert shortname will also try a lookup\\n\"\n\"                       (e.g. -sslCertInfo charlie).  Use \\\"LISTL\\\" or \\\"LL\\\"\\n\"\n\"                       for a long (ls -l style) listing.\\n\"\n\"\\n\"\n\"                       Using \\\"HASHON\\\" will create subdirs [dir]/HASH and\\n\"\n\"                       [dir]/HASH with OpenSSL hash filenames (e.g. 0d5fbbf1.0)\\n\"\n\"                       symlinks pointing up to the corresponding *.crt file.\\n\"\n\"                       ([dir] is ~/.vnc/certs or one given by -ssldir.)\\n\"\n\"                       This is a useful way for other OpenSSL applications\\n\"\n\"                       (e.g. stunnel) to access all of the certs without\\n\"\n\"                       having to concatenate them.  x11vnc will not use them\\n\"\n\"                       unless you specifically reference them.  \\\"HASHOFF\\\"\\n\"\n\"                       removes these HASH subdirs.\\n\"\n\"\\n\"\n\"                       The LIST, LISTL, LL, ALL, HASHON, HASHOFF words can\\n\"\n\"                       also be lowercase, e.g. \\\"list\\\".\\n\"\n\"\\n\"\n\"-sslDelCert pem        Prompts you to delete all .crt .pem .key .req files\\n\"\n\"                       associated with [pem].  x11vnc then exits. \\\"SAVE\\\"\\n\"\n\"                       and lookups as in -sslCertInfo apply as well.\\n\"\n\"\\n\"\n\"-sslScripts            Prints out both the 'genCA' and 'genCert' x11vnc\\n\"\n\"                       openssl wrapper scripts for you to examine, modify, etc.\\n\"\n\"                       The scripts are printed to stdout and then the x11vnc\\n\"\n\"                       program exits.\\n\"\n\"\\n\"\n\"\\n\"\n\"-stunnel [pem]         Use the stunnel(8) (stunnel.mirt.net) to provide an\\n\"\n\"                       encrypted SSL tunnel between viewers and x11vnc.\\n\"\n\"\\n\"\n\"                       This external tunnel method was implemented prior to the\\n\"\n\"                       integrated -ssl encryption described above.  It still\\n\"\n\"                       works well and avoids the requirement of linking with\\n\"\n\"                       the OpenSSL libraries.  This mode requires stunnel\\n\"\n\"                       to be installed on the system and available via PATH\\n\"\n\"                       (n.b. stunnel is often installed in sbin directories).\\n\"\n\"                       Version 4.x of stunnel is assumed (but see -stunnel3\\n\"\n\"                       below.)\\n\"\n\"\\n\"\n\"                       [pem] is optional, use \\\"-stunnel /path/to/stunnel.pem\\\"\\n\"\n\"                       to specify a PEM certificate file to pass to stunnel.\\n\"\n\"                       See the -ssl option for more info on certificate files.\\n\"\n\"\\n\"\n\"                       Whether or not your stunnel has its own certificate\\n\"\n\"                       depends on your stunnel configuration; stunnel often\\n\"\n\"                       generates one at install time.  See your stunnel\\n\"\n\"                       documentation for details.  In any event, if you want to\\n\"\n\"                       use this certificate you must supply the full path to it\\n\"\n\"                       as [pem].  Note: the file may only be readable by root.\\n\"\n\"\\n\"\n\"                       [pem] may also be the special strings \\\"TMP\\\", \\\"SAVE\\\",\\n\"\n\"                       and \\\"SAVE...\\\" as described in the -ssl option.\\n\"\n\"                       If [pem] is not supplied, \\\"SAVE\\\" is assumed.\\n\"\n\"\\n\"\n\"                       Note that the VeNCrypt, ANONTLS, and \\\"ANON\\\" modes\\n\"\n\"                       are not supported in -stunnel mode.\\n\"\n\"\\n\"\n\"                       stunnel is started up as a child process of x11vnc and\\n\"\n\"                       any SSL connections stunnel receives are decrypted and\\n\"\n\"                       sent to x11vnc over a local socket.  The strings\\n\"\n\"                       \\\"The SSL VNC desktop is ...\\\" and \\\"SSLPORT=...\\\"\\n\"\n\"                       are printed out at startup to indicate this.\\n\"\n\"\\n\"\n\"                       The -localhost option is enforced by default to avoid\\n\"\n\"                       people routing around the SSL channel.  Use -env\\n\"\n\"                       STUNNEL_DISABLE_LOCALHOST=1 to disable this security\\n\"\n\"                       requirement.\\n\"\n\"\\n\"\n\"                       Set -env STUNNEL_DEBUG=1 for more debugging printout.\\n\"\n\"\\n\"\n\"                       Set -env STUNNEL_PROG=xxx to the full path of stunnel\\n\"\n\"                       program you want to be used (e.g. /usr/bin/stunnel4).\\n\"\n\"\\n\"\n\"                       Set -env STUNNEL_LISTEN=xxx to the address of the\\n\"\n\"                       network interface to listen on (the default is to listen\\n\"\n\"                       on all interfaces), e.g. STUNNEL_LISTEN=192.168.1.100.\\n\"\n\"\\n\"\n\"                       A simple way to add IPv6 support is STUNNEL_LISTEN=::\\n\"\n\"\\n\"\n\"                       Your VNC viewer will also need to be able to connect\\n\"\n\"                       via SSL.  Unfortunately not too many do this.  See the\\n\"\n\"                       information about SSL viewers under the -ssl option.\\n\"\n\"                       The x11vnc project's SSVNC is an option.\\n\"\n\"\\n\"\n\"                       Also, in the x11vnc distribution, patched TightVNC\\n\"\n\"                       and UltraVNC Java applet jar files are provided in\\n\"\n\"                       the classes/ssl directory that do SSL connections.\\n\"\n\"                       Enable serving them with the -http, -http_ssl, or\\n\"\n\"                       -httpdir (see the option descriptions for more info.)\\n\"\n\"\\n\"\n\"                       Note that for the Java viewer applet usage the\\n\"\n\"                       \\\"?PORT=xxxx\\\" in the various URLs printed at startup\\n\"\n\"                       will need to be supplied to the web browser to connect\\n\"\n\"                       properly.\\n\"\n\"\\n\"\n\"                       Currently the automatic \\\"single port\\\" HTTPS mode of\\n\"\n\"                       -ssl is not fully supported in -stunnel mode.  However,\\n\"\n\"                       it can be emulated via:\\n\"\n\"\\n\"\n\"                         %% x11vnc -stunnel -http_ssl -http_oneport ...\\n\"\n\"\\n\"\n\"                       In general, it is also not too difficult to set up\\n\"\n\"                       an stunnel or other SSL tunnel on the viewer side.\\n\"\n\"                       A simple example on Unix using stunnel 3.x is:\\n\"\n\"\\n\"\n\"                         %% stunnel -c -d localhost:5901 -r remotehost:5900\\n\"\n\"                         %% vncviewer localhost:1\\n\"\n\"\\n\"\n\"                       For Windows, stunnel has been ported to it and there\\n\"\n\"                       are probably other such tools available.  See the FAQ\\n\"\n\"                       and SSVNC for more examples.\\n\"\n\"\\n\"\n\"-stunnel3  [pem]       Use version 3.x stunnel command line syntax instead of\\n\"\n\"                       version 4.x.  The -http/-httpdir Java applet serving\\n\"\n\"                       is currently not available in this mode.\\n\"\n\"\\n\"\n\"-enc cipher:keyfile    Use symmetric encryption with cipher \\\"cipher\\\"\\n\"\n\"                       and secret key data in \\\"keyfile\\\".  If keyfile is\\n\"\n\"                       pw=<string> then \\\"string\\\" is used as the key data.\\n\"\n\"\\n\"\n\"                       NOTE: It is recommended that you use SSL via the -ssl\\n\"\n\"                       option instead of this option because SSL is well\\n\"\n\"                       understood and takes great care to establish unique\\n\"\n\"                       session keys and is more compatible with other software.\\n\"\n\"                       Use this option if you do not want to deal with SSL\\n\"\n\"                       certificates for authentication and do not want to\\n\"\n\"                       use SSH but want some encryption for your VNC session.\\n\"\n\"                       Or if you must interface with a symmetric key tunnel\\n\"\n\"                       that you do not have control over.\\n\"\n\"\\n\"\n\"                       Note that this mode will NOT work with the UltraVNC DSM\\n\"\n\"                       plugins because they alter the RFB protocol in addition\\n\"\n\"                       to tunnelling with the symmetric cipher (an unfortunate\\n\"\n\"                       choice of implementation...)\\n\"\n\"\\n\"\n\"                       cipher can be one of:  arc4, aesv2, aes-cfb, blowfish,\\n\"\n\"                       aes256, or 3des.  See the OpenSSL documentation for\\n\"\n\"                       more info.  The keysize is 128 bits (except for aes256).\\n\"\n\"                       Here is one way to make a keyfile with that many bits:\\n\"\n\"\\n\"\n\"                            dd if=/dev/random of=./my.key bs=16 count=1\\n\"\n\"\\n\"\n\"                       you will need to securely share this key with the other\\n\"\n\"                       side of the VNC connection (See SSVNC for examples).\\n\"\n\"\\n\"\n\"                       Example:  -enc blowfish:./my.key\\n\"\n\"                       Example:  -enc blowfish:pw=swordfish\\n\"\n\"\\n\"\n\"                       By default 16 bytes of random salt followed by 16 bytes\\n\"\n\"                       of random initialization vector are sent at the very\\n\"\n\"                       beginning of the stream.  The other side must read these\\n\"\n\"                       and initialize their cipher with them.  These values\\n\"\n\"                       make the session key unique (without them the security\\n\"\n\"                       is minimal).  Similarly, the other side must send us\\n\"\n\"                       its random salt and IV with those same lengths.\\n\"\n\"\\n\"\n\"                       The salt and key data are combined to create a session\\n\"\n\"                       key using an md5 hash as described in EVP_BytesToKey(3).\\n\"\n\"\\n\"\n\"                       The exact call is: EVP_BytesToKey(Cipher, EVP_md5(),\\n\"\n\"                       salt, keydata, len, 1, keystr, NULL);  where salt is\\n\"\n\"                       the random data as described above, and keydata is the\\n\"\n\"                       shared secret key data.  keystr is the resulting session\\n\"\n\"                       key.  The cipher is then seeded with keystr and uses\\n\"\n\"                       the random initialization vector as its first block.\\n\"\n\"\\n\"\n\"                       To modify the amount of random salt and initialization\\n\"\n\"                       vector use cipher@n,m where n is the salt length and\\n\"\n\"                       m the initialization vector length.  E.g.\\n\"\n\"\\n\"\n\"                                 -enc aes-cfb@8,16:./my.key\\n\"\n\"\\n\"\n\"                       It is not a good idea to set either one to zero,\\n\"\n\"                       although you may be forced to if the other side of the\\n\"\n\"                       tunnel is not under your control.\\n\"\n\"\\n\"\n\"                       To skip the salt and EVP_BytesToKey MD5 entirely (no\\n\"\n\"                       hashing is done: the keydata is directly inserted into\\n\"\n\"                       the cipher) specify \\\"-1\\\" for the salt, e.g.\\n\"\n\"\\n\"\n\"                                 -enc blowfish@-1,16:./my.key\\n\"\n\"\\n\"\n\"                       The message digest can also be changed to something\\n\"\n\"                       besides the default MD5.  Use cipher@md+n,m where \\\"md\\\"\\n\"\n\"                       can be one of sha, sha1, md5, or ripe.  For example:\\n\"\n\"\\n\"\n\"                                 -enc arc4@sha+8,16:./my.key\\n\"\n\"\\n\"\n\"                       The SSVNC vnc viewer project supplies a symmetric\\n\"\n\"                       encryption tool named \\\"ultravnc_dsm_helper\\\" that can\\n\"\n\"                       be used on the viewer side.  For example:\\n\"\n\"\\n\"\n\"                       ssvncviewer exec='ultravnc_dsm_helper arc4 my.key 0 h:p'\\n\"\n\"\\n\"\n\"                       where h:p is the hostname and port of the x11vnc server.\\n\"\n\"                       ultravnc_dsm_helper may also be used standalone to\\n\"\n\"                       provide a symmetric encryption tunnel for any viewer\\n\"\n\"                       or server (VNC or otherwise.) The cipher (1st arg)\\n\"\n\"                       is basically the same syntax as we use above.\\n\"\n\"\\n\"\n\"                       Also see the 'Non-Ultra DSM' SSVNC option for the\\n\"\n\"                       'UltraVNC DSM Encryption Plugin' advanced option.\\n\"\n\"\\n\"\n\"                       For both ways of using the viewer, you can specify the\\n\"\n\"                       salt,ivec sizes (in GUI or, e.g. arc4@8,16).\\n\"\n\"\\n\"\n\"-https [port]          Use a special, separate HTTPS port (-ssl and\\n\"\n\"                       -stunnel modes only) for HTTPS Java viewer applet\\n\"\n\"                       downloading. I.e. not 5900 and not 5800 (the defaults.)\\n\"\n\"\\n\"\n\"                       BACKGROUND: In -ssl mode, it turns out you can use the\\n\"\n\"                       single VNC port (e.g. 5900) for both VNC and HTTPS\\n\"\n\"                       connections. (HTTPS is used to retrieve a SSL-aware\\n\"\n\"                       VncViewer.jar applet that is provided with x11vnc).\\n\"\n\"                       Since both use SSL the implementation was extended to\\n\"\n\"                       detect if HTTP traffic (i.e. GET) is taking place and\\n\"\n\"                       handle it accordingly.  The URL would be, e.g.:\\n\"\n\"\\n\"\n\"                       https://mymachine.org:5900/\\n\"\n\"\\n\"\n\"                       This is convenient for firewalls, etc, because only one\\n\"\n\"                       port needs to be allowed in.  However, this heuristic\\n\"\n\"                       adds a few seconds delay to each connection and can be\\n\"\n\"                       unreliable (especially if the user takes much time to\\n\"\n\"                       ponder the Certificate dialogs in his browser, Java VM,\\n\"\n\"                       or VNC Viewer applet.  That's right 3 separate \\\"Are\\n\"\n\"                       you sure you want to connect?\\\" dialogs!)\\n\"\n\"\\n\"\n\"                       END OF BACKGROUND.\\n\"\n\"\\n\"\n\"                       USAGE: So use the -https option to provide a separate,\\n\"\n\"                       more reliable HTTPS port that x11vnc will listen on.  If\\n\"\n\"                       [port] is not provided (or is 0), one is autoselected.\\n\"\n\"                       The URL to use is printed out at startup.\\n\"\n\"\\n\"\n\"                       The SSL Java applet directory is specified via the\\n\"\n\"                       -httpdir option.  If not supplied, -https will try\\n\"\n\"                       to guess the directory as though the -http option\\n\"\n\"                       was supplied.\\n\"\n\"\\n\"\n\"-httpsredir [port]     In -ssl mode with the Java applet retrieved via HTTPS,\\n\"\n\"                       when the HTML file containing applet parameters\\n\"\n\"                       ('index.vnc' or 'proxy.vnc') is sent do NOT set the\\n\"\n\"                       applet PORT parameter to the actual VNC port but set it\\n\"\n\"                       to \\\"port\\\" instead.  If \\\"port\\\" is not supplied, then\\n\"\n\"                       the port number is guessed from the Host: HTTP header.\\n\"\n\"\\n\"\n\"                       This is useful when an incoming TCP connection\\n\"\n\"                       redirection is performed by a router/gateway/firewall\\n\"\n\"                       from one port to an internal machine where x11vnc is\\n\"\n\"                       listening on a different port. The Java applet needs to\\n\"\n\"                       connect to the firewall/router port, not the VNC port\\n\"\n\"                       on the internal workstation. For example, one could\\n\"\n\"                       redir from mygateway.com:443 to workstation:5900.\\n\"\n\"\\n\"\n\"                       This spares the user from having to type in\\n\"\n\"                       https://mygateway.com/?PORT=443 into their web\\n\"\n\"                       browser. Note that port 443 is the default https port;\\n\"\n\"                       other ports must be explicitly indicated, for example:\\n\"\n\"                       https://mygateway.com:8000/?PORT=8000.  To avoid having\\n\"\n\"                       to include the PORT= in the browser URL, simply supply\\n\"\n\"                       \\\"-httpsredir\\\" to x11vnc.\\n\"\n\"\\n\"\n\"                       This option does not work in -stunnel mode.\\n\"\n\"\\n\"\n\"                       More tricks: set the env var X11VNC_EXTRA_HTTPS_PARAMS\\n\"\n\"                       to be extra URL parameters to use.  This way you do\\n\"\n\"                       not need to specify extra PARAMS in the index.vnc file.\\n\"\n\"                       E.g. x11vnc -env X11VNC_EXTRA_HTTPS_PARAMS='?GET=1' ...\\n\"\n\"\\n\"\n\"                       If you do not want to expose the non-SSL HTTP port to\\n\"\n\"                       the network (i.e. you just want the single VNC/HTTPS\\n\"\n\"                       port, e.g. 5900, open for connections) then specify the\\n\"\n\"                       option -env X11VNC_HTTP_LISTEN_LOCALHOST=1  This way\\n\"\n\"                       the connection to the LibVNCServer httpd server will\\n\"\n\"                       only be available on localhost (note that in -ssl mode,\\n\"\n\"                       HTTPS requests are redirected from SSL to the non-SSL\\n\"\n\"                       LibVNCServer HTTP server.)\\n\"\n\"\\n\"\n\"-http_oneport          For UN-encrypted connections mode (i.e. no -ssl,\\n\"\n\"                       -stunnel, or -enc options), allow the Java VNC Viewer\\n\"\n\"                       applet to be downloaded thru the VNC port via HTTP.\\n\"\n\"\\n\"\n\"                       That is to say, you can use a single port for Java\\n\"\n\"                       applet viewer connections by using a URL in your web\\n\"\n\"                       browser like this, for example:\\n\"\n\"\\n\"\n\"                       http://hostname:5900\\n\"\n\"\\n\"\n\"                       The regular, two-port mode, URL http://hostname:5800\\n\"\n\"                       will continue to work as well.\\n\"\n\"\\n\"\n\"                       As mentioned above, this mode will NOT work with\\n\"\n\"                       the -ssl, -stunnel, or -enc encryption options.\\n\"\n\"                       Note that is it equivalent to '-enc none' (i.e. it\\n\"\n\"                       uses the same detection mechanism as for HTTPS, but\\n\"\n\"                       with no encryption.)\\n\"\n\"\\n\"\n\"                       HTTPS single-port is on by default in -ssl encrypted\\n\"\n\"                       mode (and -enc too), so you only need -http_oneport\\n\"\n\"                       when doing non-SSL encrypted connections.\\n\"\n\"\\n\"\n\"                       This mode could also be useful for SSH tunnels since\\n\"\n\"                       it means only one port needs to be redirected.\\n\"\n\"\\n\"\n\"                       The -httpsredir option may also be useful for this\\n\"\n\"                       mode when using an SSH tunnel as well as for router\\n\"\n\"                       port redirections.\\n\"\n\"\\n\"\n\"                       Note that the -env X11VNC_HTTP_LISTEN_LOCALHOST=1\\n\"\n\"                       option described above under -httpsredir applies for\\n\"\n\"                       the LibVNCServer httpd server in all cases (ssl or not.)\\n\"\n\"\\n\"\n\"-ssh user@host:disp    Create a remote listening port on machine \\\"host\\\"\\n\"\n\"                       via a SSH tunnel using the -R rport:localhost:lport\\n\"\n\"                       method. lport will be the local x11vnc listening port,\\n\"\n\"                       so a connection to rport (5900+disp) on \\\"host\\\"\\n\"\n\"                       will reach x11vnc.  E.g. fred@snoopy.com:0\\n\"\n\"\\n\"\n\"                       This could be useful if a firewall/router prevents\\n\"\n\"                       incoming connections to the x11vnc machine, but\\n\"\n\"                       the ssh machine \\\"host\\\" can be reached by the VNC\\n\"\n\"                       viewer. \\\"user@\\\" is not needed unless the remote unix\\n\"\n\"                       username differs from the current one.\\n\"\n\"\\n\"\n\"                       By default the remote sshd is usually configured to\\n\"\n\"                       listen only on localhost for rport, so the viewer may\\n\"\n\"                       need to ssh -L redir to \\\"host\\\" as well (See SSVNC to\\n\"\n\"                       automate this).  The sshd setting GatewayPorts enables\\n\"\n\"                       listening on all interfaces for rport; viewers can\\n\"\n\"                       reach it more easily.\\n\"\n\"\\n\"\n\"                       \\\"disp\\\" is the VNC display for the remote SSH side,\\n\"\n\"                       e.g. 0 corresponds to port 5900, etc.  If disp is\\n\"\n\"                       greater than 200 the value is used as the port.  Use a\\n\"\n\"                       negative value to force a low port, e.g. host:-80 will\\n\"\n\"                       use port 80.\\n\"\n\"\\n\"\n\"                       If ssh-agent is not active, then the ssh password needs\\n\"\n\"                       to be entered in the terminal where x11vnc is running.\\n\"\n\"\\n\"\n\"                       By default the remote ssh will issue a 'sleep 300' to\\n\"\n\"                       wait for the incoming connection for 5 mins.  To modify\\n\"\n\"                       this use user@host:disp+secs.\\n\"\n\"\\n\"\n\"                       If the remote SSH server is on a non-standard port\\n\"\n\"                       (i.e. not 22) use user@host:port:disp+secs.\\n\"\n\"\\n\"\n\"                       Note that the ssh process MAY NOT be killed when\\n\"\n\"                       x11vnc exits.  It tries by looking at ps(1) output.\\n\"\n\"\\n\"\n\"-usepw                 If no other password method was supplied on the command\\n\"\n\"                       line, first look for ~/.vnc/passwd and if found use it\\n\"\n\"                       with -rfbauth; next, look for ~/.vnc/passwdfile and\\n\"\n\"                       use it with -passwdfile; otherwise, prompt the user\\n\"\n\"                       for a password to create ~/.vnc/passwd and use it with\\n\"\n\"                       the -rfbauth option.  If none of these succeed x11vnc\\n\"\n\"                       exits immediately.\\n\"\n\"\\n\"\n\"-storepasswd pass file Store password \\\"pass\\\" as the VNC password in the\\n\"\n\"                       file \\\"file\\\".  Once the password is stored the\\n\"\n\"                       program exits.  Use the password via \\\"-rfbauth file\\\"\\n\"\n\"\\n\"\n\"                       If called with no arguments, \\\"x11vnc -storepasswd\\\",\\n\"\n\"                       the user is prompted for a password and it is stored\\n\"\n\"                       in the file ~/.vnc/passwd.  Called with one argument,\\n\"\n\"                       that will be the file to store the prompted password in.\\n\"\n\"\\n\"\n\"-nopw                  Disable the big warning message when you use x11vnc\\n\"\n\"                       without some sort of password.\\n\"\n\"\\n\"\n\"-accept string         Run a command (possibly to prompt the user at the\\n\"\n\"                       X11 display) to decide whether an incoming client\\n\"\n\"                       should be allowed to connect or not.  \\\"string\\\" is\\n\"\n\"                       an external command run via system(3) or some special\\n\"\n\"                       cases described below.  Be sure to quote \\\"string\\\"\\n\"\n\"                       if it contains spaces, shell characters, etc.  If the\\n\"\n\"                       external command returns 0 the client is accepted,\\n\"\n\"                       otherwise the client is rejected.  See below for an\\n\"\n\"                       extension to accept a client view-only.\\n\"\n\"\\n\"\n\"                       If x11vnc is running as root (say from inetd(8) or from\\n\"\n\"                       display managers xdm(1), gdm(1), etc), think about the\\n\"\n\"                       security implications carefully before supplying this\\n\"\n\"                       option (likewise for the -gone option).\\n\"\n\"\\n\"\n\"                       Environment: The RFB_CLIENT_IP environment variable will\\n\"\n\"                       be set to the incoming client IP number and the port\\n\"\n\"                       in RFB_CLIENT_PORT (or -1 if unavailable).  Similarly,\\n\"\n\"                       RFB_SERVER_IP and RFB_SERVER_PORT (the x11vnc side\\n\"\n\"                       of the connection), are set to allow identification\\n\"\n\"                       of the tcp virtual circuit.  The x11vnc process\\n\"\n\"                       id will be in RFB_X11VNC_PID, a client id number in\\n\"\n\"                       RFB_CLIENT_ID, and the number of other connected clients\\n\"\n\"                       in RFB_CLIENT_COUNT.  RFB_MODE will be \\\"accept\\\".\\n\"\n\"                       RFB_STATE will be PROTOCOL_VERSION, SECURITY_TYPE,\\n\"\n\"                       AUTHENTICATION, INITIALISATION, NORMAL, or UNKNOWN\\n\"\n\"                       indicating up to which state the client has achieved.\\n\"\n\"                       RFB_LOGIN_VIEWONLY will be 0, 1, or -1 (unknown).\\n\"\n\"                       RFB_USERNAME, RFB_LOGIN_TIME, and RFB_CURRENT_TIME may\\n\"\n\"                       also be set.\\n\"\n\"\\n\"\n\"                       If \\\"string\\\" is \\\"popup\\\" then a builtin popup window\\n\"\n\"                       is used.  The popup will time out after 120 seconds,\\n\"\n\"                       use \\\"popup:N\\\" to modify the timeout to N seconds\\n\"\n\"                       (use 0 for no timeout).\\n\"\n\"\\n\"\n\"                       In the case of \\\"popup\\\" and when the -unixpw option\\n\"\n\"                       is specified, then a *second* window will be popped\\n\"\n\"                       up after the user successfully logs in via his UNIX\\n\"\n\"                       password.  This time the user will be identified as\\n\"\n\"                       UNIX:username@hostname, the \\\"UNIX:\\\" prefix indicates\\n\"\n\"                       which user the viewer logged as via -unixpw.  The first\\n\"\n\"                       popup is only for whether to allow him to even *try*\\n\"\n\"                       to login via unix password.\\n\"\n\"\\n\"\n\"                       If \\\"string\\\" is \\\"xmessage\\\" then an xmessage(1)\\n\"\n\"                       invocation is used for the command.  xmessage must be\\n\"\n\"                       installed on the machine for this to work.\\n\"\n\"\\n\"\n\"                       Both \\\"popup\\\" and \\\"xmessage\\\" will present an option\\n\"\n\"                       for accepting the client \\\"View-Only\\\" (the client\\n\"\n\"                       can only watch).  This option will not be presented if\\n\"\n\"                       -viewonly has been specified, in which case the entire\\n\"\n\"                       display is view only.\\n\"\n\"\\n\"\n\"                       If the user supplied command is prefixed with something\\n\"\n\"                       like \\\"yes:0,no:*,view:3 mycommand ...\\\" then this\\n\"\n\"                       associates the numerical command return code with\\n\"\n\"                       the actions: accept, reject, and accept-view-only,\\n\"\n\"                       respectively.  Use \\\"*\\\" instead of a number to indicate\\n\"\n\"                       the default action (in case the command returns an\\n\"\n\"                       unexpected value).  E.g. \\\"no:*\\\" is a good choice.\\n\"\n\"\\n\"\n\"                       Note that x11vnc blocks while the external command\\n\"\n\"                       or popup is running (other clients may see no updates\\n\"\n\"                       during this period).  So a person sitting a the physical\\n\"\n\"                       display is needed to respond to an popup prompt. (use\\n\"\n\"                       a 2nd x11vnc if you lock yourself out).\\n\"\n\"\\n\"\n\"                       More -accept tricks: use \\\"popupmouse\\\" to only allow\\n\"\n\"                       mouse clicks in the builtin popup to be recognized.\\n\"\n\"                       Similarly use \\\"popupkey\\\" to only recognize\\n\"\n\"                       keystroke responses.  These are to help avoid the\\n\"\n\"                       user accidentally accepting a client by typing or\\n\"\n\"                       clicking. All 3 of the popup keywords can be followed\\n\"\n\"                       by +N+M to supply a position for the popup window.\\n\"\n\"                       The default is to center the popup window.\\n\"\n\"-afteraccept string    As -accept, except to run a user supplied command after\\n\"\n\"                       a client has been accepted and authenticated. RFB_MODE\\n\"\n\"                       will be set to \\\"afteraccept\\\" and the other RFB_*\\n\"\n\"                       variables are as in -accept.  Unlike -accept, the\\n\"\n\"                       command return code is not interpreted by x11vnc.\\n\"\n\"                       Example: -afteraccept 'killall xlock &'\\n\"\n\"-gone string           As -accept, except to run a user supplied command when\\n\"\n\"                       a client goes away (disconnects).  RFB_MODE will be\\n\"\n\"                       set to \\\"gone\\\" and the other RFB_* variables are as\\n\"\n\"                       in -accept.  The \\\"popup\\\" actions apply as well.\\n\"\n\"                       Unlike -accept, the command return code is not\\n\"\n\"                       interpreted by x11vnc.  Example: -gone 'xlock &'\\n\"\n\"\\n\"\n\"-users list            If x11vnc is started as root (say from inetd(8) or from\\n\"\n\"                       display managers xdm(1), gdm(1), etc), then as soon\\n\"\n\"                       as possible after connections to the X display are\\n\"\n\"                       established try to switch to one of the users in the\\n\"\n\"                       comma separated \\\"list\\\".  If x11vnc is not running as\\n\"\n\"                       root this option is ignored.\\n\"\n\"\\n\"\n\"                       Why use this option?  In general it is not needed since\\n\"\n\"                       x11vnc is already connected to the X display and can\\n\"\n\"                       perform its primary functions.  The option was added\\n\"\n\"                       to make some of the *external* utility commands x11vnc\\n\"\n\"                       occasionally runs work properly.  In particular under\\n\"\n\"                       GNOME and KDE to implement the \\\"-solid color\\\" feature\\n\"\n\"                       external commands (gconftool-2 and dcop) unfortunately\\n\"\n\"                       must be run as the user owning the desktop session.\\n\"\n\"                       Since this option switches userid it also affects the\\n\"\n\"                       userid used to run the processes for the -accept and\\n\"\n\"                       -gone options.  It also affects the ability to read\\n\"\n\"                       files for options such as -connect, -allow, and -remap\\n\"\n\"                       and also the ultra and tight filetransfer feature if\\n\"\n\"                       enabled.  Note that the -connect file is also sometimes\\n\"\n\"                       written to.\\n\"\n\"\\n\"\n\"                       So be careful with this option since in some situations\\n\"\n\"                       its use can decrease security.\\n\"\n\"\\n\"\n\"                       In general the switch to a user will only take place\\n\"\n\"                       if the display can still be successfully opened as that\\n\"\n\"                       user (this is primarily to try to guess the actual owner\\n\"\n\"                       of the session). Example: \\\"-users fred,wilma,betty\\\".\\n\"\n\"                       Note that a malicious local user \\\"barney\\\" by\\n\"\n\"                       quickly using \\\"xhost +\\\" when logging in may possibly\\n\"\n\"                       get the x11vnc process to switch to user \\\"fred\\\".\\n\"\n\"                       What happens next?\\n\"\n\"\\n\"\n\"                       Under display managers it may be a long time before\\n\"\n\"                       the switch succeeds (i.e. a user logs in).  To instead\\n\"\n\"                       make it switch immediately regardless if the display\\n\"\n\"                       can be reopened prefix the username with the \\\"+\\\"\\n\"\n\"                       character. E.g. \\\"-users +bob\\\" or \\\"-users +nobody\\\".\\n\"\n\"\\n\"\n\"                       The latter (i.e. switching immediately to user\\n\"\n\"                       \\\"nobody\\\") is the only obvious use of the -users option\\n\"\n\"                       that increases security.\\n\"\n\"\\n\"\n\"                       Use the following notation to associate a group with\\n\"\n\"                       a user: user1.group1,user2.group2,...  Note that\\n\"\n\"                       initgroups(2) will still be called first to try to\\n\"\n\"                       switch to ALL of a user's groups (primary and additional\\n\"\n\"                       groups).  Only if that fails or it is not available\\n\"\n\"                       then the single group specified as above (or the user's\\n\"\n\"                       primary group if not specified) is switched to with\\n\"\n\"                       setgid(2).  Use -env X11VNC_SINGLE_GROUP=1 to prevent\\n\"\n\"                       trying initgroups(2) and only switch to the single\\n\"\n\"                       group.  This sort of setting is only really needed to\\n\"\n\"                       make the ultra or tight filetransfer permissions work\\n\"\n\"                       properly. This format applies to any comma separated list\\n\"\n\"                       of users, even the special \\\"=\\\" modes described below.\\n\"\n\"\\n\"\n\"                       In -unixpw mode, if \\\"-users unixpw=\\\" is supplied\\n\"\n\"                       then after a user authenticates himself via the\\n\"\n\"                       -unixpw mechanism, x11vnc will try to switch to that\\n\"\n\"                       user as though \\\"-users +username\\\" had been supplied.\\n\"\n\"                       If you want to limit which users this will be done for,\\n\"\n\"                       provide them as a comma separated list after \\\"unixpw=\\\"\\n\"\n\"                       Groups can also be specified as described above.\\n\"\n\"\\n\"\n\"                       Similarly, in -ssl mode, if \\\"-users sslpeer=\\\" is\\n\"\n\"                       supplied then after an SSL client authenticates with his\\n\"\n\"                       cert (the -sslverify option is required for this) x11vnc\\n\"\n\"                       will extract a UNIX username from the \\\"emailAddress\\\"\\n\"\n\"                       field (username@hostname.com) of the \\\"Subject\\\" of the\\n\"\n\"                       x509 SSL cert and then try to switch to that user as\\n\"\n\"                       though \\\"-users +username\\\" had been supplied.  If you\\n\"\n\"                       want to limit which users this will be done for, provide\\n\"\n\"                       them as a comma separated list after \\\"sslpeer=\\\".\\n\"\n\"                       Set the env. var X11VNC_SSLPEER_CN to use the Common\\n\"\n\"                       Name (normally a hostname) instead of the Email field.\\n\"\n\"\\n\"\n\"                       NOTE: for sslpeer= mode the x11vnc administrator must\\n\"\n\"                       take care that any client certs he adds to -sslverify\\n\"\n\"                       have the intended UNIX username in the \\\"emailAddress\\\"\\n\"\n\"                       field of the cert.  Otherwise a user may be able to\\n\"\n\"                       log in as another.  This command can be of use in\\n\"\n\"                       checking: \\\"openssl x509 -text -in file.crt\\\", see the\\n\"\n\"                       \\\"Subject:\\\" line.  Also, along with the normal RFB_*\\n\"\n\"                       env. vars. (see -accept) passed to external cmd=\\n\"\n\"                       commands, RFB_SSL_CLIENT_CERT will be set to the\\n\"\n\"                       client's x509 certificate string.\\n\"\n\"\\n\"\n\"                       The sslpeer= mode can aid finding X sessions via the\\n\"\n\"                       FINDDISPLAY and FINDCREATEDISPLAY mechanisms.\\n\"\n\"\\n\"\n\"                       To immediately switch to a user *before* connections\\n\"\n\"                       to the X display are made or any files opened use the\\n\"\n\"                       \\\"=\\\" character: \\\"-users =bob\\\".  That user needs to\\n\"\n\"                       be able to open the X display and any files of course.\\n\"\n\"\\n\"\n\"                       The special user \\\"guess=\\\" means to examine the utmpx\\n\"\n\"                       database (see who(1)) looking for a user attached to\\n\"\n\"                       the display number (from DISPLAY or -display option)\\n\"\n\"                       and try him/her.  To limit the list of guesses, use:\\n\"\n\"                       \\\"-users guess=bob,betty\\\".\\n\"\n\"\\n\"\n\"                       Even more sinister is the special user \\\"lurk=\\\"\\n\"\n\"                       that means to try to guess the DISPLAY from the utmpx\\n\"\n\"                       login database as well.  So it \\\"lurks\\\" waiting for\\n\"\n\"                       anyone to log into an X session and then connects to it.\\n\"\n\"                       Specify a list of users after the = to limit which users\\n\"\n\"                       will be tried.  To enable a different searching mode, if\\n\"\n\"                       the first user in the list is something like \\\":0\\\" or\\n\"\n\"                       \\\":0-2\\\" that indicates a range of DISPLAY numbers that\\n\"\n\"                       will be tried (regardless of whether they are in the\\n\"\n\"                       utmpx database) for all users that are logged in.  Also\\n\"\n\"                       see the \\\"-display WAIT:...\\\" functionality.  Examples:\\n\"\n\"                       \\\"-users lurk=\\\" and also \\\"-users lurk=:0-1,bob,mary\\\"\\n\"\n\"\\n\"\n\"                       Be especially careful using the \\\"guess=\\\" and \\\"lurk=\\\"\\n\"\n\"                       modes.  They are not recommended for use on machines\\n\"\n\"                       with untrustworthy local users.\\n\"\n\"\\n\"\n\"-noshm                 Do not use the MIT-SHM extension for the polling.\\n\"\n\"                       Remote displays can be polled this way: be careful this\\n\"\n\"                       can use large amounts of network bandwidth.  This is\\n\"\n\"                       also of use if the local machine has a limited number\\n\"\n\"                       of shm segments and -onetile is not sufficient.\\n\"\n\"-flipbyteorder         Sometimes needed if remotely polled host has different\\n\"\n\"                       endianness.  Ignored unless -noshm is set.\\n\"\n\"-onetile               Do not use the new copy_tiles() framebuffer mechanism,\\n\"\n\"                       just use 1 shm tile for polling.  Limits shm segments\\n\"\n\"                       used to 3.\\n\"\n\"\\n\"\n\"                       To disable any automatic shm reduction set the\\n\"\n\"                       env. var. X11VNC_NO_LIMIT_SHM.\\n\"\n\"\\n\"\n\"-solid [color]         To improve performance, when VNC clients are connected\\n\"\n\"                       try to change the desktop background to a solid color.\\n\"\n\"                       The [color] is optional: the default color is \\\"cyan4\\\".\\n\"\n\"                       For a different one specify the X color (rgb.txt name,\\n\"\n\"                       e.g. \\\"darkblue\\\" or numerical \\\"#RRGGBB\\\").\\n\"\n\"\\n\"\n\"                       Currently this option only works on GNOME, KDE, CDE,\\n\"\n\"                       XFCE, and classic X (i.e. with the background image\\n\"\n\"                       on the root window).  The \\\"gconftool-2\\\", \\\"dcop\\\"\\n\"\n\"                       and \\\"xfconf-query\\\" external commands are run for\\n\"\n\"                       GNOME, KDE, and XFCE respectively.  This also works\\n\"\n\"                       on native MacOSX.  (There is no color selection for\\n\"\n\"                       MacOSX or XFCE.)  Other desktops won't work, (send\\n\"\n\"                       us the corresponding commands if you find them).\\n\"\n\"                       If x11vnc is running as root (inetd(8) or gdm(1)),\\n\"\n\"                       the -users option may be needed for GNOME, KDE, XFCE.\\n\"\n\"                       If x11vnc guesses your desktop incorrectly, you can\\n\"\n\"                       force it by prefixing color with \\\"gnome:\\\", \\\"kde:\\\",\\n\"\n\"                       \\\"cde:\\\", \\\"xfce:\\\", or \\\"root:\\\".\\n\"\n\"\\n\"\n\"                       Update: -solid no longer works on KDE4.\\n\"\n\"\\n\"\n\"                       This mode works in a limited way on the Mac OS X Console\\n\"\n\"                       with one color ('kelp') using the screensaver writing\\n\"\n\"                       to the background.  Look in \\\"~/Library/Screen Savers\\\"\\n\"\n\"                       for VncSolidColor.png to change the color.\\n\"\n\"\\n\"\n\"-blackout string       Black out rectangles on the screen. \\\"string\\\" is a\\n\"\n\"                       comma separated list of WxH+X+Y type geometries for\\n\"\n\"                       each rectangle.  If one of the items on the list is the\\n\"\n\"                       string \\\"noptr\\\" the mouse pointer will not be allowed\\n\"\n\"                       to go into a blacked out region.\\n\"\n\"-xinerama              If your screen is composed of multiple monitors\\n\"\n\"-noxinerama            glued together via XINERAMA, and that screen is\\n\"\n\"                       not a rectangle this option will try to guess the\\n\"\n\"                       areas to black out (if your system has libXinerama).\\n\"\n\"                       default: %s\\n\"\n\"\\n\"\n\"                       In general, we have noticed on XINERAMA displays you may\\n\"\n\"                       need to use the \\\"-xwarppointer\\\" option if the mouse\\n\"\n\"                       pointer misbehaves and it is enabled by default. Use\\n\"\n\"                       \\\"-noxwarppointer\\\" if you do not want this.\\n\"\n\"\\n\"\n\"-xtrap                 Use the DEC-XTRAP extension for keystroke and mouse\\n\"\n\"                       input insertion.  For use on legacy systems, e.g. X11R5,\\n\"\n\"                       running an incomplete or missing XTEST extension.\\n\"\n\"                       By default DEC-XTRAP will be used if XTEST server grab\\n\"\n\"                       control is missing, use -xtrap to do the keystroke and\\n\"\n\"                       mouse insertion via DEC-XTRAP as well.\\n\"\n\"\\n\"\n\"-xrandr [mode]         If the display supports the XRANDR (X Resize, Rotate\\n\"\n\"                       and Reflection) extension, and you expect XRANDR events\\n\"\n\"                       to occur to the display while x11vnc is running, this\\n\"\n\"                       options indicates x11vnc should try to respond to\\n\"\n\"                       them (as opposed to simply crashing by assuming the\\n\"\n\"                       old screen size).  See the xrandr(1) manpage and run\\n\"\n\"                       'xrandr -q' for more info.  [mode] is optional and\\n\"\n\"                       described below.\\n\"\n\"\\n\"\n\"                       Since watching for XRANDR events and trapping errors\\n\"\n\"                       increases polling overhead, only use this option if\\n\"\n\"                       XRANDR changes are expected.  For example on a rotatable\\n\"\n\"                       screen PDA or laptop, or using a XRANDR-aware Desktop\\n\"\n\"                       where you resize often.  It is best to be viewing with a\\n\"\n\"                       vncviewer that supports the NewFBSize encoding, since it\\n\"\n\"                       knows how to react to screen size changes.  Otherwise,\\n\"\n\"                       LibVNCServer tries to do so something reasonable for\\n\"\n\"                       viewers that cannot do this (portions of the screen\\n\"\n\"                       may be clipped, unused, etc).\\n\"\n\"\\n\"\n\"                       Note: the default now is to check for XRANDR events, but\\n\"\n\"                       do not trap every X call that may fail due to resize.\\n\"\n\"                       If a resize event is received, the full -xrandr mode\\n\"\n\"                       is enabled.  To disable even checking for events supply:\\n\"\n\"                       -noxrandr.\\n\"\n\"\\n\"\n\"                       \\\"mode\\\" defaults to \\\"resize\\\", which means create a\\n\"\n\"                       new, resized, framebuffer and hope all viewers can cope\\n\"\n\"                       with the change.  \\\"newfbsize\\\" means first disconnect\\n\"\n\"                       all viewers that do not support the NewFBSize VNC\\n\"\n\"                       encoding, and then resize the framebuffer.  \\\"exit\\\"\\n\"\n\"                       means disconnect all viewer clients, and then terminate\\n\"\n\"                       x11vnc.\\n\"\n\"\\n\"\n\"-rotate string         Rotate and/or flip the framebuffer view exported by VNC.\\n\"\n\"                       This transformation is independent of XRANDR and is\\n\"\n\"                       done in software in main memory and so may be slower.\\n\"\n\"                       This mode could be useful on a handheld with portrait or\\n\"\n\"                       landscape modes that do not correspond to the scanline\\n\"\n\"                       order of the actual framebuffer.  \\\"string\\\" can be:\\n\"\n\"\\n\"\n\"                             x     flip along x-axis\\n\"\n\"                             y     flip along y-axis\\n\"\n\"                            xy     flip along x- and y-axes\\n\"\n\"                           +90     rotate 90 degrees clockwise\\n\"\n\"                           -90     rotate 90 degrees counter-clockwise\\n\"\n\"                          +90x     rotate 90 degrees CW, then flip along x\\n\"\n\"                          +90y     rotate 90 degrees CW, then flip along y\\n\"\n\"\\n\"\n\"                       these give all possible rotations and reflections.\\n\"\n\"\\n\"\n\"                       Aliases: same as xy:  yx, +180, -180, 180\\n\"\n\"                                same as -90: +270, 270\\n\"\n\"                                same as +90: 90, (ditto for 90x, 90y)\\n\"\n\"\\n\"\n\"                       Like -scale, this transformation is applied at the very\\n\"\n\"                       end of any chain of framebuffer transformations and so\\n\"\n\"                       any options with geometries, e.g. -blackout, -clip, etc.\\n\"\n\"                       are relative to the original X (or -rawfb) framebuffer,\\n\"\n\"                       not the final one sent to VNC viewers.\\n\"\n\"\\n\"\n\"                       If you do not want the cursor shape to be rotated\\n\"\n\"                       prefix \\\"string\\\" with \\\"nc:\\\", e.g. \\\"nc:+90\\\",\\n\"\n\"                       \\\"nc:xy\\\", etc.\\n\"\n\"\\n\"\n\"-padgeom WxH           Whenever a new vncviewer connects, the framebuffer is\\n\"\n\"                       replaced with a fake, solid black one of geometry WxH.\\n\"\n\"                       Shortly afterwards the framebuffer is replaced with the\\n\"\n\"                       real one.  This is intended for use with vncviewers\\n\"\n\"                       that do not support NewFBSize and one wants to make\\n\"\n\"                       sure the initial viewer geometry will be big enough\\n\"\n\"                       to handle all subsequent resizes (e.g. under -xrandr,\\n\"\n\"                       -remote id:windowid, rescaling, etc.)\\n\"\n\"\\n\"\n\"                       In -unixpw mode this sets the size of the login screen.\\n\"\n\"                       Use \\\"once:WxH\\\" it ignore padgeom after the login\\n\"\n\"                       screen is set up.\\n\"\n\"\\n\"\n\"-o logfile             Write stderr messages to file \\\"logfile\\\" instead of to\\n\"\n\"                       the terminal.  Same as \\\"-logfile file\\\".  To append\\n\"\n\"                       to the file use \\\"-oa file\\\" or \\\"-logappend file\\\".\\n\"\n\"                       If \\\"logfile\\\" contains the string \\\"%%VNCDISPLAY\\\"\\n\"\n\"                       it is expanded to the vnc display (the name may need\\n\"\n\"                       to be guessed at.)  \\\"%%HOME\\\" works too.\\n\"\n\"\\n\"\n\"-flag file             Write the \\\"PORT=NNNN\\\" (e.g. PORT=5900) string to\\n\"\n\"                       \\\"file\\\" in addition to stdout.  This option could be\\n\"\n\"                       useful by wrapper script to detect when x11vnc is ready.\\n\"\n\"\\n\"\n\"-rmflag file           Remove \\\"file\\\" at exit to signal when x11vnc is done.\\n\"\n\"                       The file is created at startup if it does not already\\n\"\n\"                       exist or if \\\"file\\\" is prefixed with \\\"create:\\\".\\n\"\n\"                       If the file is created, the x11vnc PID is placed in\\n\"\n\"                       the file.  Otherwise the files contents is not changed.\\n\"\n\"                       Use prefix \\\"nocreate:\\\" to prevent creation.\\n\"\n\"\\n\"\n\"-rc filename           Use \\\"filename\\\" instead of $HOME/.x11vncrc for rc file.\\n\"\n\"-norc                  Do not process any .x11vncrc file for options.\\n\"\n\"\\n\"\n\"-env VAR=VALUE         Set the environment variable 'VAR' to value 'VALUE'\\n\"\n\"                       at x11vnc startup.  This is a convenience utility to\\n\"\n\"                       avoid shell script wrappers, etc. to set the env. var.\\n\"\n\"                       You may specify as many of these as needed on the\\n\"\n\"                       command line.\\n\"\n\"-prog /path/to/x11vnc  Set the full path to the x11vnc program for cases when\\n\"\n\"                       it cannot be determined from argv[0] (e.g. tcpd/inetd)\\n\"\n\"\\n\"\n\"-h, -help              Print this help text.\\n\"\n\"-?, -opts              Only list the x11vnc options.\\n\"\n\"-V, -version           Print program version and last modification date.\\n\"\n\"-license               Print out license information.  Same as -copying and\\n\"\n\"                       -warranty.\\n\"\n\"\\n\"\n\"-dbg                   Instead of exiting after cleaning up, run a simple\\n\"\n\"                       \\\"debug crash shell\\\" when fatal errors are trapped.\\n\"\n\"\\n\"\n\"-q, -quiet             Be quiet by printing less informational output to\\n\"\n\"                       stderr. (use -noquiet to undo an earlier -quiet.)\\n\"\n\"\\n\"\n\"                       The -quiet option does not eliminate all informational\\n\"\n\"                       output, it only reduces it.  It is ignored in most\\n\"\n\"                       auxiliary usage modes, e.g. -storepasswd.  To eliminate\\n\"\n\"                       all output use: 2>/dev/null 1>&2, etc.\\n\"\n\"\\n\"\n\"-v, -verbose           Print out more information to stderr.\\n\"\n\"\\n\"\n\"-bg                    Go into the background after screen setup.  Messages to\\n\"\n\"                       stderr are lost unless -o logfile is used.  Something\\n\"\n\"                       like this could be useful in a script:\\n\"\n\"                        port=`ssh -t $host \\\"x11vnc -display :0 -bg\\\" | grep PORT`\\n\"\n\"                        port=`echo \\\"$port\\\" | sed -e 's/PORT=//'`\\n\"\n\"                        port=`expr $port - 5900`\\n\"\n\"                        vncviewer $host:$port\\n\"\n\"\\n\"\n\"-modtweak              Option -modtweak automatically tries to adjust the AltGr\\n\"\n\"-nomodtweak            and Shift modifiers for differing language keyboards\\n\"\n\"                       between client and host.  Otherwise, only a single key\\n\"\n\"                       press/release of a Keycode is simulated (i.e. ignoring\\n\"\n\"                       the state of the modifiers: this usually works for\\n\"\n\"                       identical keyboards).  Also useful in resolving cases\\n\"\n\"                       where a Keysym is bound to multiple keys (e.g. \\\"<\\\" + \\\">\\\"\\n\"\n\"                       and \\\",\\\" + \\\"<\\\" keys).  Default: %s\\n\"\n\"\\n\"\n\"                       If you are having trouble with with keys and -xkb or\\n\"\n\"                       -noxkb, and similar things don't help, try -nomodtweak.\\n\"\n\"\\n\"\n\"                       On some HP-UX systems it is been noted that they have\\n\"\n\"                       an odd keymapping where a single keycode will have a\\n\"\n\"                       keysym, e.g. \\\"#\\\", up to three times.  You can check\\n\"\n\"                       via \\\"xmodmap -pk\\\" or the -dk option.  The failure\\n\"\n\"                       is when you try to type \\\"#\\\" it yields \\\"3\\\".  If you\\n\"\n\"                       see this problem try setting the environment variable\\n\"\n\"                       MODTWEAK_LOWEST=1 to see if it helps.\\n\"\n\"\\n\"\n\"-xkb                   When in modtweak mode, use the XKEYBOARD extension (if\\n\"\n\"-noxkb                 the X display supports it) to do the modifier tweaking.\\n\"\n\"                       This is powerful and should be tried if there are still\\n\"\n\"                       keymapping problems when using -modtweak by itself.\\n\"\n\"                       The default is to check whether some common keysyms,\\n\"\n\"                       e.g. !, @, [, are only accessible via -xkb mode and if\\n\"\n\"                       so then automatically enable the mode.  To disable this\\n\"\n\"                       automatic detection use -noxkb.\\n\"\n\"\\n\"\n\"                       When -xkb mode is active you can set these env. vars.\\n\"\n\"                       They apply only when there is ambiguity as to which\\n\"\n\"                       key to choose (i.e the mapping is not one-to-one).\\n\"\n\"                       NOKEYHINTS=1: for up ascii keystrokes do not use score\\n\"\n\"                       hints saved when the key was pressed down. NOANYDOWN=1:\\n\"\n\"                       for up keystrokes do not resort to searching through\\n\"\n\"                       keys that are currently pressed down.  KEYSDOWN=N:\\n\"\n\"                       remember the last N keys press down for tie-breaking\\n\"\n\"                       when an up keystroke comes in.\\n\"\n\"\\n\"\n\"-capslock              When in -modtweak (the default) or -xkb mode,\\n\"\n\"                       if a keysym in the range A-Z comes in check the X\\n\"\n\"                       server to see if the Caps_Lock is set.  If it is do\\n\"\n\"                       not artificially press Shift to generate the keysym.\\n\"\n\"                       This will enable the CapsLock key to behave correctly\\n\"\n\"                       in some circumstances: namely *both* the VNC viewer\\n\"\n\"                       machine and the x11vnc X server are in the CapsLock\\n\"\n\"                       on state.  If one side has CapsLock on and the other\\n\"\n\"                       off and the keyboard is not behaving as you think it\\n\"\n\"                       should you should correct the CapsLock states (hint:\\n\"\n\"                       pressing CapsLock inside and outside of the viewer can\\n\"\n\"                       help toggle them both to the correct state).  However,\\n\"\n\"                       for best results do not use this option, but rather\\n\"\n\"                       *only* enable CapsLock on the VNC viewer side (i.e. by\\n\"\n\"                       pressing CapsLock outside of the viewer window, also\\n\"\n\"                       -skip_lockkeys below).  Also try -nomodtweak for a\\n\"\n\"                       possible workaround.\\n\"\n\"\\n\"\n\"-skip_lockkeys         Have x11vnc ignore all Caps_Lock, Shift_Lock, Num_Lock,\\n\"\n\"-noskip_lockkeys       Scroll_Lock keysyms received from viewers.  The idea is\\n\"\n\"                       you press Caps_Lock on the VNC Viewer side but that does\\n\"\n\"                       not change the lock state in the x11vnc-side X server.\\n\"\n\"                       Nevertheless your capitalized letters come in over\\n\"\n\"                       the wire and are applied correctly to the x11vnc-side\\n\"\n\"                       X server.  Note this mode probably won't do what you\\n\"\n\"                       want in -nomodtweak mode.  Also, a kludge for KP_n\\n\"\n\"                       digits is always done in this mode: they are mapped to\\n\"\n\"                       regular digit keysyms.  See also -capslock above.\\n\"\n\"                       The default is -noskip_lockkeys.\\n\"\n\"\\n\"\n\"-skip_keycodes string  Ignore the comma separated list of decimal keycodes.\\n\"\n\"                       Perhaps these are keycodes not on your keyboard but\\n\"\n\"                       your X server thinks exist.  Currently only applies\\n\"\n\"                       to -xkb mode.  Use this option to help x11vnc in the\\n\"\n\"                       reverse problem it tries to solve: Keysym -> Keycode(s)\\n\"\n\"                       when ambiguities exist (more than one Keycode per\\n\"\n\"                       Keysym).  Run 'xmodmap -pk' to see your keymapping.\\n\"\n\"                       Example: \\\"-skip_keycodes 94,114\\\"\\n\"\n\"-sloppy_keys           Experimental option that tries to correct some\\n\"\n\"                       \\\"sloppy\\\" key behavior.  E.g. if at the viewer you\\n\"\n\"                       press Shift+Key but then release the Shift before\\n\"\n\"                       Key that could give rise to extra unwanted characters\\n\"\n\"                       (usually only between keyboards of different languages).\\n\"\n\"                       Only use this option if you observe problems with\\n\"\n\"                       some keystrokes.\\n\"\n\"-skip_dups             Some VNC viewers send impossible repeated key events,\\n\"\n\"-noskip_dups           e.g. key-down, key-down, key-up, key-up all for the same\\n\"\n\"                       key, or 20 downs in a row for the same modifier key!\\n\"\n\"                       Setting -skip_dups means to skip these duplicates and\\n\"\n\"                       just process the first event. Note: some VNC viewers\\n\"\n\"                       assume they can send down's without the corresponding\\n\"\n\"                       up's and so you should not set this option for\\n\"\n\"                       these viewers (symptom: some keys do not autorepeat)\\n\"\n\"                       Default: %s\\n\"\n\"-add_keysyms           If a Keysym is received from a VNC viewer and that\\n\"\n\"-noadd_keysyms         Keysym does not exist in the X server, then add the\\n\"\n\"                       Keysym to the X server's keyboard mapping on an unused\\n\"\n\"                       key.  Added Keysyms will be removed periodically and\\n\"\n\"                       also when x11vnc exits.  Default: %s\\n\"\n\"-clear_mods            At startup and exit clear the modifier keys by sending\\n\"\n\"                       KeyRelease for each one. The Lock modifiers are skipped.\\n\"\n\"                       Used to clear the state if the display was accidentally\\n\"\n\"                       left with any pressed down.\\n\"\n\"-clear_keys            As -clear_mods, except try to release ANY pressed key.\\n\"\n\"                       Note that this option and -clear_mods can interfere\\n\"\n\"                       with a person typing at the physical keyboard.\\n\"\n\"-clear_all             As -clear_keys, except try to release any CapsLock,\\n\"\n\"                       NumLock, etc. locks as well.\\n\"\n\"\\n\"\n\"-remap string          Read Keysym remappings from file named \\\"string\\\".\\n\"\n\"                       Format is one pair of Keysyms per line (can be name\\n\"\n\"                       or hex value) separated by a space.  If no file named\\n\"\n\"                       \\\"string\\\" exists, it is instead interpreted as this\\n\"\n\"                       form: key1-key2,key3-key4,...  See <X11/keysymdef.h>\\n\"\n\"                       header file for a list of Keysym names, or use xev(1).\\n\"\n\"\\n\"\n\"                       To map a key to a button click, use the fake Keysyms\\n\"\n\"                       \\\"Button1\\\", ..., etc. E.g: \\\"-remap Super_R-Button2\\\"\\n\"\n\"                       (useful for pasting on a laptop)\\n\"\n\"\\n\"\n\"                       I use these if the machine I am viewing from does not\\n\"\n\"                       have a scrollwheel or I don't like using the one it has:\\n\"\n\"\\n\"\n\"                              -remap Super_R-Button4,Menu-Button5\\n\"\n\"                              -remap KP_Add-Button4,KP_Enter-Button5\\n\"\n\"\\n\"\n\"                       the former would be used on a PC, the latter on a\\n\"\n\"                       MacBook.  This way those little used keys can be used\\n\"\n\"                       to generate bigger hops than the Up and Down arrows\\n\"\n\"                       provide.  One can scroll through text or web pages more\\n\"\n\"                       quickly this way (especially if x11vnc scroll detection\\n\"\n\"                       is active.)\\n\"\n\"\\n\"\n\"                       Use Button44, Button12, etc. for multiple clicks.\\n\"\n\"\\n\"\n\"                       To disable a keysym (i.e. make it so it will not be\\n\"\n\"                       injected), remap it to \\\"NoSymbol\\\" or \\\"None\\\".\\n\"\n\"\\n\"\n\"                       Dead keys: \\\"dead\\\" (or silent, mute) keys are keys that\\n\"\n\"                       do not produce a character but must be followed by a 2nd\\n\"\n\"                       keystroke.  This is often used for accenting characters,\\n\"\n\"                       e.g. to put \\\"`\\\" on top of \\\"a\\\" by pressing the dead\\n\"\n\"                       key and then \\\"a\\\".  Note that this interpretation\\n\"\n\"                       is not part of core X11, it is up to the toolkit or\\n\"\n\"                       application to decide how to react to the sequence.\\n\"\n\"                       The X11 names for these keysyms are \\\"dead_grave\\\",\\n\"\n\"                       \\\"dead_acute\\\", etc.  However some VNC viewers send the\\n\"\n\"                       keysyms \\\"grave\\\", \\\"acute\\\" instead thereby disabling\\n\"\n\"                       the accenting.  To work around this -remap can be used.\\n\"\n\"                       For example \\\"-remap grave-dead_grave,acute-dead_acute\\\"\\n\"\n\"                       As a convenience, \\\"-remap DEAD\\\" applies these remaps:\\n\"\n\"\\n\"\n\"                               g     grave-dead_grave\\n\"\n\"                               a     acute-dead_acute\\n\"\n\"                               c     asciicircum-dead_circumflex\\n\"\n\"                               t     asciitilde-dead_tilde\\n\"\n\"                               m     macron-dead_macron\\n\"\n\"                               b     breve-dead_breve\\n\"\n\"                               D     abovedot-dead_abovedot\\n\"\n\"                               d     diaeresis-dead_diaeresis\\n\"\n\"                               o     degree-dead_abovering\\n\"\n\"                               A     doubleacute-dead_doubleacute\\n\"\n\"                               r     caron-dead_caron\\n\"\n\"                               e     cedilla-dead_cedilla\\n\"\n\"\\n\"\n\"                       If you just want a subset use the first letter\\n\"\n\"                       label, e.g. \\\"-remap DEAD=ga\\\" to get the first two.\\n\"\n\"                       Additional remaps may also be supplied via commas,\\n\"\n\"                       e.g.  \\\"-remap DEAD=ga,Super_R-Button2\\\".  Finally,\\n\"\n\"                       \\\"DEAD=missing\\\" means to apply all of the above as\\n\"\n\"                       long as the left hand member is not already in the\\n\"\n\"                       X11 keymap.\\n\"\n\"\\n\"\n\"-norepeat              Option -norepeat disables X server key auto repeat when\\n\"\n\"-repeat                VNC clients are connected and VNC keyboard input is\\n\"\n\"                       not idle for more than 5 minutes.  This works around a\\n\"\n\"                       repeating keystrokes bug (triggered by long processing\\n\"\n\"                       delays between key down and key up client events:\\n\"\n\"                       either from large screen changes or high latency).\\n\"\n\"                       Default: %s\\n\"\n\"\\n\"\n\"                       You can set the env. var. X11VNC_IDLE_TIMEOUT to the\\n\"\n\"                       number of idle seconds you want (5min = 300secs).\\n\"\n\"\\n\"\n\"                       Note: your VNC viewer side will likely do autorepeating,\\n\"\n\"                       so this is no loss unless someone is simultaneously at\\n\"\n\"                       the real X display.\\n\"\n\"\\n\"\n\"                       Use \\\"-norepeat N\\\" to set how many times norepeat will\\n\"\n\"                       be reset if something else (e.g. X session manager)\\n\"\n\"                       undoes it.  The default is 2.  Use a negative value\\n\"\n\"                       for unlimited resets.\\n\"\n\"\\n\"\n\"-nofb                  Ignore video framebuffer: only process keyboard and\\n\"\n\"                       pointer.  Intended for use with Win2VNC and x2vnc\\n\"\n\"                       dual-monitor setups.\\n\"\n\"-nobell                Do not watch for XBell events. (no beeps will be heard)\\n\"\n\"                       Note: XBell monitoring requires the XKEYBOARD extension.\\n\"\n\"-nosel                 Do not manage exchange of X selection/cutbuffer between\\n\"\n\"                       VNC viewers and the X server at all.\\n\"\n\"-noprimary             Do not poll the PRIMARY selection for changes to send\\n\"\n\"                       back to clients.  (PRIMARY is still set on received\\n\"\n\"                       changes, however).\\n\"\n\"-nosetprimary          Do not set the PRIMARY selection for changes received\\n\"\n\"                       from VNC clients.\\n\"\n\"-noclipboard           Do not poll the CLIPBOARD selection for changes to send\\n\"\n\"                       back to clients.  (CLIPBOARD is still set on received\\n\"\n\"                       changes, however).\\n\"\n\"-nosetclipboard        Do not set the CLIPBOARD selection for changes\\n\"\n\"                       received from VNC clients.\\n\"\n\"-seldir string         If direction string is \\\"send\\\", only send the selection\\n\"\n\"                       to viewers, and if it is \\\"recv\\\" only receive it from\\n\"\n\"                       viewers.  To work around apps setting the selection\\n\"\n\"                       too frequently and messing up the other end.  You can\\n\"\n\"                       actually supply a comma separated list of directions,\\n\"\n\"                       including \\\"debug\\\" to turn on debugging output.\\n\"\n\"\\n\"\n\"-cursor [mode]         Sets how the pointer cursor shape (little icon at the\\n\"\n\"-nocursor              mouse pointer) should be handled.  The \\\"mode\\\" string\\n\"\n\"                       is optional and is described below.  The default\\n\"\n\"                       is to show some sort of cursor shape(s).  How this\\n\"\n\"                       is done depends on the VNC viewer and the X server.\\n\"\n\"                       Use -nocursor to disable cursor shapes completely.\\n\"\n\"\\n\"\n\"                       Some VNC viewers support the TightVNC CursorPosUpdates\\n\"\n\"                       and CursorShapeUpdates extensions (cuts down on\\n\"\n\"                       network traffic by not having to send the cursor image\\n\"\n\"                       every time the pointer is moved), in which case these\\n\"\n\"                       extensions are used (see -nocursorshape and -nocursorpos\\n\"\n\"                       below to disable).  For other viewers the cursor shape\\n\"\n\"                       is written directly to the framebuffer every time the\\n\"\n\"                       pointer is moved or changed and gets sent along with\\n\"\n\"                       the other framebuffer updates.  In this case, there\\n\"\n\"                       will be some lag between the vnc viewer pointer and\\n\"\n\"                       the remote cursor position.\\n\"\n\"\\n\"\n\"                       If the X display supports retrieving the cursor shape\\n\"\n\"                       information from the X server, then the default is\\n\"\n\"                       to use that mode.  On Solaris this can be done with\\n\"\n\"                       the SUN_OVL extension using -overlay (see also the\\n\"\n\"                       -overlay_nocursor option).  A similar overlay scheme\\n\"\n\"                       is used on IRIX.  Xorg (e.g. Linux) and recent Solaris\\n\"\n\"                       Xsun servers support the XFIXES extension to retrieve\\n\"\n\"                       the exact cursor shape from the X server.  If XFIXES\\n\"\n\"                       is present it is preferred over Overlay and is used by\\n\"\n\"                       default (see -noxfixes below).  This can be disabled\\n\"\n\"                       with -nocursor, and also some values of the \\\"mode\\\"\\n\"\n\"                       option below.\\n\"\n\"\\n\"\n\"                       Note that under XFIXES cursors with transparency (alpha\\n\"\n\"                       channel) will usually not be exactly represented and one\\n\"\n\"                       may find Overlay preferable.  See also the -alphacut\\n\"\n\"                       and -alphafrac options below as fudge factors to try\\n\"\n\"                       to improve the situation for cursors with transparency\\n\"\n\"                       for a given theme.\\n\"\n\"\\n\"\n\"                       The \\\"mode\\\" string can be used to fine-tune the\\n\"\n\"                       displaying of cursor shapes.  It can be used the\\n\"\n\"                       following ways:\\n\"\n\"\\n\"\n\"                       \\\"-cursor arrow\\\" - just show the standard arrow\\n\"\n\"                       nothing more or nothing less.\\n\"\n\"\\n\"\n\"                       \\\"-cursor none\\\" - same as \\\"-nocursor\\\"\\n\"\n\"\\n\"\n\"                       \\\"-cursor X\\\" - when the cursor appears to be on the\\n\"\n\"                       root window, draw the familiar X shape.  Some desktops\\n\"\n\"                       such as GNOME cover up the root window completely,\\n\"\n\"                       and so this will not work, try \\\"X1\\\", etc, to try to\\n\"\n\"                       shift the tree depth.  On high latency links or slow\\n\"\n\"                       machines there will be a time lag between expected and\\n\"\n\"                       the actual cursor shape.\\n\"\n\"\\n\"\n\"                       \\\"-cursor some\\\" - like \\\"X\\\" but use additional\\n\"\n\"                       heuristics to try to guess if the window should have\\n\"\n\"                       a windowmanager-like resizer cursor or a text input\\n\"\n\"                       I-beam cursor.  This is a complete hack, but may be\\n\"\n\"                       useful in some situations because it provides a little\\n\"\n\"                       more feedback about the cursor shape.\\n\"\n\"\\n\"\n\"                       \\\"-cursor most\\\" - try to show as many cursors as\\n\"\n\"                       possible.  Often this will only be the same as \\\"some\\\"\\n\"\n\"                       unless the display has overlay visuals or XFIXES\\n\"\n\"                       extensions available.  On Solaris and IRIX if XFIXES\\n\"\n\"                       is not available, -overlay mode will be attempted.\\n\"\n\"\\n\"\n\"-cursor_drag           Show cursor shape changes even when the mouse is being\\n\"\n\"                       dragged with a mouse button down.  This is useful if you\\n\"\n\"                       want to be able to see Drag-and-Drop cursor icons, etc.\\n\"\n\"\\n\"\n\"-arrow n               Choose an alternate \\\"arrow\\\" cursor from a set of\\n\"\n\"                       some common ones.  n can be 1 to %d.  Default is: %d\\n\"\n\"                       Ignored when in XFIXES cursor-grabbing mode.\\n\"\n\"\\n\"\n\"-noxfixes              Do not use the XFIXES extension to draw the exact cursor\\n\"\n\"                       shape even if it is available.\\n\"\n\"\\n\"\n\"                       Note: To work around a crash in Xorg 1.5 and later\\n\"\n\"                       some people needed to use -noxfixes.  The Xorg crash\\n\"\n\"                       occurred right after a Display Manager (e.g. GDM) login.\\n\"\n\"                       Starting with x11vnc 0.9.9 it tries to automatically\\n\"\n\"                       avoid using XFIXES until it is sure a window manager\\n\"\n\"                       is running.  See the -reopen option for more info and\\n\"\n\"                       how to use X11VNC_AVOID_WINDOWS=never to disable it.\\n\"\n\"\\n\"\n\"-alphacut n            When using the XFIXES extension for the cursor shape,\\n\"\n\"                       cursors with transparency will not usually be displayed\\n\"\n\"                       exactly (but opaque ones will).  This option sets n as\\n\"\n\"                       a cutoff for cursors that have transparency (\\\"alpha\\n\"\n\"                       channel\\\" with values ranging from 0 to 255) Any cursor\\n\"\n\"                       pixel with alpha value less than n becomes completely\\n\"\n\"                       transparent.  Otherwise the pixel is completely opaque.\\n\"\n\"                       Default %d\\n\"\n\"\\n\"\n\"-alphafrac fraction    With the threshold in -alphacut some cursors will become\\n\"\n\"                       almost completely transparent because their alpha values\\n\"\n\"                       are not high enough.  For those cursors adjust the\\n\"\n\"                       alpha threshold until fraction of the non-zero alpha\\n\"\n\"                       channel pixels become opaque.  Default %.2f\\n\"\n\"-alpharemove           By default, XFIXES cursors pixels with transparency have\\n\"\n\"                       the alpha factor multiplied into the RGB color values\\n\"\n\"                       (i.e. that corresponding to blending the cursor with a\\n\"\n\"                       black background).  Specify this option to remove the\\n\"\n\"                       alpha factor. (useful for light colored semi-transparent\\n\"\n\"                       cursors).\\n\"\n\"-noalphablend          In XFIXES mode do not send cursor alpha channel data\\n\"\n\"                       to LibVNCServer.  The default is to send it.  The\\n\"\n\"                       alphablend effect will only be visible in -nocursorshape\\n\"\n\"                       mode or for clients with cursorshapeupdates turned\\n\"\n\"                       off. (However there is a hack for 32bpp with depth 24,\\n\"\n\"                       it uses the extra 8 bits to store cursor transparency\\n\"\n\"                       for use with a hacked vncviewer that applies the\\n\"\n\"                       transparency locally.  See the FAQ for more info).\\n\"\n\"\\n\"\n\"-nocursorshape         Do not use the TightVNC CursorShapeUpdates extension\\n\"\n\"                       even if clients support it.  See -cursor above.\\n\"\n\"-cursorpos             Option -cursorpos enables sending the X cursor position\\n\"\n\"-nocursorpos           back to all vnc clients that support the TightVNC\\n\"\n\"                       CursorPosUpdates extension.  Other clients will be able\\n\"\n\"                       to see the pointer motions. Default: %s\\n\"\n\"-xwarppointer          Move the pointer with XWarpPointer(3X) instead of\\n\"\n\"-noxwarppointer        the XTEST extension.  Use this as a workaround\\n\"\n\"                       if the pointer motion behaves incorrectly, e.g.\\n\"\n\"                       on touchscreens or other non-standard setups.\\n\"\n\"\\n\"\n\"                       It is also sometimes needed on XINERAMA displays and is\\n\"\n\"                       enabled by default if XINERAMA is found to be active.\\n\"\n\"                       To prevent this, use -noxwarppointer.\\n\"\n\"\\n\"\n\"-always_inject         Even if there is no displacement (dx = dy = 0) for a\\n\"\n\"                       VNC mouse event force the pointer to the indicated x,y\\n\"\n\"                       position anyway.  Recent (2009) gui toolkits (gnome)\\n\"\n\"                       have problems with x11vnc's original mouse input\\n\"\n\"                       injection method.  So x11vnc's mouse input injection\\n\"\n\"                       method has been modified.  To regain the OLD behavior\\n\"\n\"                       use this option: -always_inject.  Then x11vnc will\\n\"\n\"                       always force positioning the mouse to the x,y position\\n\"\n\"                       even if that position has not changed since the previous\\n\"\n\"                       VNC input event.\\n\"\n\"\\n\"\n\"                       The first place this problem was noticed was in gnome\\n\"\n\"                       terminal: if you pressed and released mouse button 3, a\\n\"\n\"                       menu was posted and then its first element 'New Terminal\\n\"\n\"                       Window' was activated.  This was because x11vnc injected\\n\"\n\"                       the mouse position twice: once on ButtonPress and again\\n\"\n\"                       on ButtonRelease.  The toolkit interpreted the 2nd one\\n\"\n\"                       as mouse motion even though the mouse hadn't moved.\\n\"\n\"                       So now by default x11vnc tries to avoid injecting the\\n\"\n\"                       2nd one.\\n\"\n\"\\n\"\n\"                       Note that with the new default x11vnc will be oblivious\\n\"\n\"                       to applications moving the pointer (warping) or the\\n\"\n\"                       user at the physical display moving it.  So it might,\\n\"\n\"                       e.g., inject ButtonRelease at the wrong position.\\n\"\n\"                       If this (or similar scenarios) causes problems in your\\n\"\n\"                       environment, specify -always_inject for the old method.\\n\"\n\"\\n\"\n\"-buttonmap string      String to remap mouse buttons.  Format: IJK-LMN, this\\n\"\n\"                       maps buttons I -> L, etc., e.g.  -buttonmap 13-31\\n\"\n\"\\n\"\n\"                       Button presses can also be mapped to keystrokes: replace\\n\"\n\"                       a button digit on the right of the dash with :<sym>:\\n\"\n\"                       or :<sym1>+<sym2>: etc. for multiple keys. For example,\\n\"\n\"                       if the viewing machine has a mouse-wheel (buttons 4 5)\\n\"\n\"                       but the x11vnc side does not, these will do scrolls:\\n\"\n\"                              -buttonmap 12345-123:Prior::Next:\\n\"\n\"                              -buttonmap 12345-123:Up+Up+Up::Down+Down+Down:\\n\"\n\"\\n\"\n\"                       See <X11/keysymdef.h> header file for a list of Keysyms,\\n\"\n\"                       or use the xev(1) program.  Note: mapping of button\\n\"\n\"                       clicks to Keysyms may not work if -modtweak or -xkb is\\n\"\n\"                       needed for the Keysym.\\n\"\n\"\\n\"\n\"                       If you include a modifier like \\\"Shift_L\\\" the\\n\"\n\"                       modifier's up/down state is toggled, e.g. to send\\n\"\n\"                       \\\"The\\\" use :Shift_L+t+Shift_L+h+e: (the 1st one is\\n\"\n\"                       shift down and the 2nd one is shift up). (note: the\\n\"\n\"                       initial state of the modifier is ignored and not reset)\\n\"\n\"                       To include button events use \\\"Button1\\\", ... etc.\\n\"\n\"\\n\"\n\"                       -buttonmap currently does not work on MacOSX console\\n\"\n\"                       or in -rawfb mode.\\n\"\n\"\\n\"\n\"                       Workaround: use -buttonmap IJ...-LM...=n to limit the\\n\"\n\"                       number of mouse buttons to n, e.g. 123-123=3.  This will\\n\"\n\"                       prevent x11vnc from crashing if the X server reports\\n\"\n\"                       there are 5 buttons (4/5 scroll wheel), but there are\\n\"\n\"                       only really 3.\\n\"\n\"\\n\"\n\"-nodragging            Do not update the display during mouse dragging events\\n\"\n\"                       (mouse button held down).  Greatly improves response on\\n\"\n\"                       slow setups, but you lose all visual feedback for drags,\\n\"\n\"                       text selection, and some menu traversals.  It overrides\\n\"\n\"                       any -pointer_mode setting.\\n\"\n\"\\n\"\n#ifndef NO_NCACHE\n\"-ncache n              Client-side caching scheme.  Framebuffer memory \\\"n\\\"\\n\"\n\"                       (an integer) times that of the full display is allocated\\n\"\n\"                       below the actual framebuffer to cache screen contents\\n\"\n\"                       for rapid retrieval.  So a W x H frambuffer is expanded\\n\"\n\"                       to a W x (n+1)*H one.  Use 0 to disable.\\n\"\n\"\\n\"\n\"                       The \\\"n\\\" is actually optional, the default is 10.\\n\"\n\"\\n\"\n\"                       For this and the other -ncache* options below you can\\n\"\n\"                       abbreviate \\\"-ncache\\\" with \\\"-nc\\\".  Also, \\\"-nonc\\\"\\n\"\n\"                       is the same as \\\"-ncache 0\\\"\\n\"\n\"\\n\"\n\"                       This is an experimental option, currently implemented in\\n\"\n\"                       an awkward way in that in the VNC Viewer you can see the\\n\"\n\"                       pixel cache contents if you scroll down, etc.  So you\\n\"\n\"                       will have to set things up so you can't see that region.\\n\"\n\"                       If this method is successful, the changes required for\\n\"\n\"                       clients to do this less awkwardly will be investigated.\\n\"\n\"\\n\"\n\"                       The SSVNC viewer does a good job at automatically hiding\\n\"\n\"                       the pixel cache region.  Or use SSVNC's -ycrop option\\n\"\n\"                       to explicitly hide the region.\\n\"\n\"\\n\"\n\"                       Note that this mode consumes a huge amount of memory,\\n\"\n\"                       both on the x11vnc server side and on the VNC Viewer\\n\"\n\"                       side.  If n=2 then the amount of RAM used is roughly\\n\"\n\"                       tripled for both x11vnc and the VNC Viewer.  As a rule\\n\"\n\"                       of thumb, note that 1280x1024 at depth 24 is about 5MB\\n\"\n\"                       of pixel data.\\n\"\n\"\\n\"\n\"                       For reasonable response when cycling through 4 to 6\\n\"\n\"                       large (e.g. web browser) windows a value n of 6 to 12\\n\"\n\"                       is recommended. (that's right: ~10X more memory...)\\n\"\n\"\\n\"\n\"                       Because of the way window backingstore and saveunders\\n\"\n\"                       are implemented, n must be even.  It will be incremented\\n\"\n\"                       by 1 if it is not.\\n\"\n\"\\n\"\n\"                       This mode also works for native MacOS X, but may not\\n\"\n\"                       be as effective as the X version.  This is due to a\\n\"\n\"                       number of things, one is the drop-shadow compositing\\n\"\n\"                       that leaves extra areas that need to be repaired (see\\n\"\n\"                       -ncache_pad).  Another is the window iconification\\n\"\n\"                       animations need to be avoided (see -macicontime).\\n\"\n\"                       It appears the that the 'Scale' animation mode gives\\n\"\n\"                       better results than the 'Genie' one.  Also, window event\\n\"\n\"                       detection not as accurate as the X version.\\n\"\n\"\\n\"\n\"-ncache_cr             In -ncache mode, try to do copyrect opaque window\\n\"\n\"                       moves/drags instead of wireframes (this can induce\\n\"\n\"                       painting errors).  The wireframe will still be used when\\n\"\n\"                       moving a window whose save-unders has not yet been set\\n\"\n\"                       or has been invalidated.\\n\"\n\"\\n\"\n\"                       Some VNC Viewers provide better response than others\\n\"\n\"                       with this option.  On Unix, realvnc viewer gives\\n\"\n\"                       smoother drags than tightvnc viewer.  Response may also\\n\"\n\"                       be choppy if the server side machine is too slow.\\n\"\n\"\\n\"\n\"                       Sometimes on very slow modem connections, this actually\\n\"\n\"                       gives an improvement because no pixel data at all\\n\"\n\"                       (not even the box animation) is sent during the drag.\\n\"\n\"\\n\"\n\"-ncache_no_moveraise   In -ncache mode, do not assume that moving a window\\n\"\n\"                       will cause the window manager to raise it to the top\\n\"\n\"                       of the stack.  The default is to assume it does, and\\n\"\n\"                       so at the beginning of any wireframe, etc, window moves\\n\"\n\"                       the window will be pushed to top in the VNC viewer.\\n\"\n\"\\n\"\n\"-ncache_no_dtchange    In -ncache mode, do not try to guess when the desktop\\n\"\n\"                       (viewport) changes to another one (i.e. another\\n\"\n\"                       workarea).  The default is to try to guess and when\\n\"\n\"                       detected try to make the transition more smoothly.\\n\"\n\"\\n\"\n\"-ncache_no_rootpixmap  In -ncache mode, do not try to snapshot the desktop\\n\"\n\"                       background to use in guessing or reconstructing window\\n\"\n\"                       save-unders.\\n\"\n\"\\n\"\n\"-ncache_keep_anims     In -ncache mode, do not try to disable window\\n\"\n\"                       manager animations and other effects (that usually\\n\"\n\"                       degrade ncache performance or cause painting errors).\\n\"\n\"                       The default is to try to disable them on KDE (but not\\n\"\n\"                       GNOME) when VNC clients are connected.\\n\"\n\"\\n\"\n\"                       For other window managers or desktops that provide\\n\"\n\"                       animations, effects, compositing, translucency,\\n\"\n\"                       etc. that interfere with the -ncache method you will\\n\"\n\"                       have to disable them manually.\\n\"\n\"\\n\"\n\"-ncache_old_wm         In -ncache mode, enable some heuristics for old style\\n\"\n\"                       window managers such as fvwm and twm.\\n\"\n\"\\n\"\n\"-ncache_pad n          In -ncache mode, pad each window with n pixels for the\\n\"\n\"                       caching rectangles.  This can be used to try to improve\\n\"\n\"                       the situation with dropshadows or other compositing\\n\"\n\"                       (e.g. MacOS X window manager), although it could make\\n\"\n\"                       things worse.  The default is 0 on Unix and 24 on\\n\"\n\"                       MacOS X.\\n\"\n\"-debug_ncache          Turn on debugging and profiling output under -ncache.\\n\"\n\"\\n\"\n#endif\n\"-wireframe [str]       Try to detect window moves or resizes when a mouse\\n\"\n\"-nowireframe           button is held down and show a wireframe instead of\\n\"\n\"                       the full opaque window.  This is based completely on\\n\"\n\"                       heuristics and may not always work: it depends on your\\n\"\n\"                       window manager and even how you move things around.\\n\"\n\"                       See -pointer_mode below for discussion of the \\\"bogging\\n\"\n\"                       down\\\" problem this tries to avoid.\\n\"\n\"                       Default: %s\\n\"\n\"\\n\"\n\"                       Shorter aliases:  -wf [str]  and -nowf\\n\"\n\"\\n\"\n\"                       The value \\\"str\\\" is optional and, of course, is\\n\"\n\"                       packed with many tunable parameters for this scheme:\\n\"\n\"\\n\"\n\"                       Format: shade,linewidth,percent,T+B+L+R,mod,t1+t2+t3+t4\\n\"\n\"                       Default: %s\\n\"\n\"\\n\"\n\"                       If you leave nothing between commas: \\\",,\\\" the default\\n\"\n\"                       value is used.  If you don't specify enough commas,\\n\"\n\"                       the trailing parameters are set to their defaults.\\n\"\n\"\\n\"\n\"                       \\\"shade\\\" indicate the \\\"color\\\" for the wireframe,\\n\"\n\"                       usually a greyscale: 0-255, however for 16 and 32bpp you\\n\"\n\"                       can specify an rgb.txt X color (e.g. \\\"dodgerblue\\\") or\\n\"\n\"                       a value > 255 is treated as RGB (e.g. red is 0xff0000).\\n\"\n\"                       \\\"linewidth\\\" sets the width of the wireframe in pixels.\\n\"\n\"                       \\\"percent\\\" indicates to not apply the wireframe scheme\\n\"\n\"                       to windows with area less than this percent of the\\n\"\n\"                       full screen.\\n\"\n\"\\n\"\n\"                       \\\"T+B+L+R\\\" indicates four integers for how close in\\n\"\n\"                       pixels the pointer has to be from the Top, Bottom, Left,\\n\"\n\"                       or Right edges of the window to consider wireframing.\\n\"\n\"                       This is a speedup to quickly exclude a window from being\\n\"\n\"                       wireframed: set them all to zero to not try the speedup\\n\"\n\"                       (scrolling and selecting text will likely be slower).\\n\"\n\"\\n\"\n\"                       \\\"mod\\\" specifies if a button down event in the\\n\"\n\"                       interior of the window with a modifier key (Alt, Shift,\\n\"\n\"                       etc.) down should indicate a wireframe opportunity.\\n\"\n\"                       It can be \\\"0\\\" or \\\"none\\\" to skip it, \\\"1\\\" or \\\"all\\\"\\n\"\n\"                       to apply it to any modifier, or \\\"Shift\\\", \\\"Alt\\\",\\n\"\n\"                       \\\"Control\\\", \\\"Meta\\\", \\\"Super\\\", or \\\"Hyper\\\" to only\\n\"\n\"                       apply for that type of modifier key.\\n\"\n\"\\n\"\n\"                       \\\"t1+t2+t3+t4\\\" specify four floating point times in\\n\"\n\"                       seconds: t1 is how long to wait for the pointer to move,\\n\"\n\"                       t2 is how long to wait for the window to start moving\\n\"\n\"                       or being resized (for some window managers this can be\\n\"\n\"                       rather long), t3 is how long to keep a wireframe moving\\n\"\n\"                       before repainting the window. t4 is the minimum time\\n\"\n\"                       between sending wireframe \\\"animations\\\".  If a slow\\n\"\n\"                       link is detected, these values may be automatically\\n\"\n\"                       changed to something better for a slow link.\\n\"\n\"\\n\"\n\"-nowireframelocal      By default, mouse motion and button presses of a\\n\"\n\"                       user sitting at the LOCAL display are monitored for\\n\"\n\"                       wireframing opportunities (so that the changes will be\\n\"\n\"                       sent efficiently to the VNC clients).  Use this option\\n\"\n\"                       to disable this behavior.\\n\"\n\"\\n\"\n\"-wirecopyrect mode     Since the -wireframe mechanism evidently tracks moving\\n\"\n\"-nowirecopyrect        windows accurately, a speedup can be obtained by\\n\"\n\"                       telling the VNC viewers to locally copy the translated\\n\"\n\"                       window region.  This is the VNC CopyRect encoding:\\n\"\n\"                       the framebuffer update doesn't need to send the actual\\n\"\n\"                       new image data.\\n\"\n\"\\n\"\n\"                       Shorter aliases:  -wcr [mode]  and -nowcr\\n\"\n\"\\n\"\n\"                       \\\"mode\\\" can be \\\"never\\\" (same as -nowirecopyrect)\\n\"\n\"                       to never try the copyrect, \\\"top\\\" means only do it if\\n\"\n\"                       the window was not covered by any other windows, and\\n\"\n\"                       \\\"always\\\" means to translate the originally unobscured\\n\"\n\"                       region (this may look odd as the remaining pieces come\\n\"\n\"                       in, but helps on a slow link).  Default: \\\"%s\\\"\\n\"\n\"\\n\"\n\"                       Note: there can be painting errors or slow response\\n\"\n\"                       when using -scale so you may want to disable CopyRect\\n\"\n\"                       in this case \\\"-wirecopyrect never\\\" on the command\\n\"\n\"                       line or by remote-control.  Or you can also use the\\n\"\n\"                       \\\"-scale xxx:nocr\\\" scale option.\\n\"\n\"\\n\"\n\"-debug_wireframe       Turn on debugging info printout for the wireframe\\n\"\n\"                       heuristics.  \\\"-dwf\\\" is an alias.  Specify multiple\\n\"\n\"                       times for more output.\\n\"\n\"\\n\"\n\"-scrollcopyrect mode   Like -wirecopyrect, but use heuristics to try to guess\\n\"\n\"-noscrollcopyrect      if a window has scrolled its contents (either vertically\\n\"\n\"                       or horizontally).  This requires the RECORD X extension\\n\"\n\"                       to \\\"snoop\\\" on X applications (currently for certain\\n\"\n\"                       XCopyArea and XConfigureWindow X protocol requests).\\n\"\n\"                       Examples: Hitting <Return> in a terminal window when the\\n\"\n\"                       cursor was at the bottom, the text scrolls up one line.\\n\"\n\"                       Hitting <Down> arrow in a web browser window, the web\\n\"\n\"                       page scrolls up a small amount.  Or scrolling with a\\n\"\n\"                       scrollbar or mouse wheel.\\n\"\n\"\\n\"\n\"                       Shorter aliases:  -scr [mode]  and -noscr\\n\"\n\"\\n\"\n\"                       This scheme will not always detect scrolls, but when\\n\"\n\"                       it does there is a nice speedup from using the VNC\\n\"\n\"                       CopyRect encoding (see -wirecopyrect).  The speedup\\n\"\n\"                       is both in reduced network traffic and reduced X\\n\"\n\"                       framebuffer polling/copying.  On the other hand, it may\\n\"\n\"                       induce undesired transients (e.g. a terminal cursor\\n\"\n\"                       being scrolled up when it should not be) or other\\n\"\n\"                       painting errors (window tearing, bunching-up, etc).\\n\"\n\"                       These are automatically repaired in a short period\\n\"\n\"                       of time.  If this is unacceptable disable the feature\\n\"\n\"                       with -noscrollcopyrect.\\n\"\n\"\\n\"\n\"                       Screen clearing kludges:  for testing at least, there\\n\"\n\"                       are some \\\"magic key sequences\\\" (must be done in less\\n\"\n\"                       than 1 second) to aid repairing painting errors that\\n\"\n\"                       may be seen when using this mode:\\n\"\n\"\\n\"\n\"                       3 Alt_L's   in a row: resend whole screen,\\n\"\n\"                       4 Alt_L's   in a row: reread and resend whole screen,\\n\"\n\"                       3 Super_L's in a row: mark whole screen for polling,\\n\"\n\"                       4 Super_L's in a row: reset RECORD context,\\n\"\n\"                       5 Super_L's in a row: try to push a black screen\\n\"\n\"\\n\"\n\"                       note: Alt_L is the Left \\\"Alt\\\" key (a single key)\\n\"\n\"                       Super_L is the Left \\\"Super\\\" key (Windows flag).\\n\"\n\"                       Both of these are modifier keys, and so should not\\n\"\n\"                       generate characters when pressed by themselves.  Also,\\n\"\n\"                       your VNC viewer may have its own refresh hot-key\\n\"\n\"                       or button.\\n\"\n\"\\n\"\n\"                       \\\"mode\\\" can be \\\"never\\\" (same as -noscrollcopyrect)\\n\"\n\"                       to never try the copyrect, \\\"keys\\\" means to try it\\n\"\n\"                       in response to keystrokes only, \\\"mouse\\\" means to\\n\"\n\"                       try it in response to mouse events only, \\\"always\\\"\\n\"\n\"                       means to do both. Default: \\\"%s\\\"\\n\"\n\"\\n\"\n\"                       Note: there can be painting errors or slow response\\n\"\n\"                       when using -scale so you may want to disable CopyRect\\n\"\n\"                       in this case \\\"-scrollcopyrect never\\\" on the command\\n\"\n\"                       line or by remote-control.  Or you can also use the\\n\"\n\"                       \\\"-scale xxx:nocr\\\" scale option.\\n\"\n\"\\n\"\n\"-scr_area n            Set the minimum area in pixels for a rectangle\\n\"\n\"                       to be considered for the -scrollcopyrect detection\\n\"\n\"                       scheme.  This is to avoid wasting the effort on small\\n\"\n\"                       rectangles that would be quickly updated the normal way.\\n\"\n\"                       E.g. suppose an app updated the position of its skinny\\n\"\n\"                       scrollbar first and then shifted the large panel\\n\"\n\"                       it controlled.  We want to be sure to skip the small\\n\"\n\"                       scrollbar and get the large panel. Default: %d\\n\"\n\"\\n\"\n\"-scr_skip list         Skip scroll detection for applications matching\\n\"\n\"                       the comma separated list of strings in \\\"list\\\".\\n\"\n\"                       Some applications implement their scrolling in\\n\"\n\"                       strange ways where the XCopyArea, etc, also applies\\n\"\n\"                       to invisible portions of the window: if we CopyRect\\n\"\n\"                       those areas it looks awful during the scroll and\\n\"\n\"                       there may be painting errors left after the scroll.\\n\"\n\"                       Soffice.bin is the worst known offender.\\n\"\n\"\\n\"\n\"                       Use \\\"##\\\" to denote the start of the application class\\n\"\n\"                       (e.g. \\\"##XTerm\\\") and \\\"++\\\" to denote the start\\n\"\n\"                       of the application instance name (e.g. \\\"++xterm\\\").\\n\"\n\"                       The string your list is matched against is of the form\\n\"\n\"                       \\\"^^WM_NAME##Class++Instance<same-for-any-subwindows>\\\"\\n\"\n\"                       The \\\"xlsclients -la\\\" command will provide this info.\\n\"\n\"\\n\"\n\"                       If a pattern is prefixed with \\\"KEY:\\\" it only applies\\n\"\n\"                       to Keystroke generated scrolls (e.g. Up arrow).  If it\\n\"\n\"                       is prefixed with \\\"MOUSE:\\\" it only applies to Mouse\\n\"\n\"                       induced scrolls (e.g. dragging on a scrollbar).\\n\"\n\"                       Default: %s\\n\"\n\"\\n\"\n\"-scr_inc list          Opposite of -scr_skip: this list is consulted first\\n\"\n\"                       and if there is a match the window will be monitored\\n\"\n\"                       via RECORD for scrolls irrespective of -scr_skip.\\n\"\n\"                       Use -scr_skip '*' to skip anything that does not match\\n\"\n\"                       your -scr_inc.  Use -scr_inc '*' to include everything.\\n\"\n\"\\n\"\n\"-scr_keys list         For keystroke scroll detection, only apply the RECORD\\n\"\n\"                       heuristics to the comma separated list of keysyms in\\n\"\n\"                       \\\"list\\\".  You may find the RECORD overhead for every\\n\"\n\"                       one of your keystrokes disrupts typing too much, but you\\n\"\n\"                       don't want to turn it off completely with \\\"-scr mouse\\\"\\n\"\n\"                       and -scr_parms does not work or is too confusing.\\n\"\n\"\\n\"\n\"                       The listed keysyms can be numeric or the keysym\\n\"\n\"                       names in the <X11/keysymdef.h> header file or from the\\n\"\n\"                       xev(1) program.  Example: \\\"-scr_keys Up,Down,Return\\\".\\n\"\n\"                       One probably wants to have application specific lists\\n\"\n\"                       (e.g. for terminals, etc) but that is too icky to think\\n\"\n\"                       about for now...\\n\"\n\"\\n\"\n\"                       If \\\"list\\\" begins with the \\\"-\\\" character the list\\n\"\n\"                       is taken as an exclude list: all keysyms except those\\n\"\n\"                       list will be considered.  The special string \\\"builtin\\\"\\n\"\n\"                       expands to an internal list of keysyms that are likely\\n\"\n\"                       to cause scrolls.  BTW, by default modifier keys,\\n\"\n\"                       Shift_L, Control_R, etc, are skipped since they almost\\n\"\n\"                       never induce scrolling by themselves.\\n\"\n\"\\n\"\n\"-scr_term list         Yet another cosmetic kludge.  Apply shell/terminal\\n\"\n\"                       heuristics to applications matching comma separated\\n\"\n\"                       list (same as for -scr_skip/-scr_inc).  For example an\\n\"\n\"                       annoying transient under scroll detection is if you\\n\"\n\"                       hit Enter in a terminal shell with full text window,\\n\"\n\"                       the solid text cursor block will be scrolled up.\\n\"\n\"                       So for a short time there are two (or more) block\\n\"\n\"                       cursors on the screen.  There are similar scenarios,\\n\"\n\"                       (e.g. an output line is duplicated).\\n\"\n\"\\n\"\n\"                       These transients are induced by the approximation of\\n\"\n\"                       scroll detection (e.g. it detects the scroll, but not\\n\"\n\"                       the fact that the block cursor was cleared just before\\n\"\n\"                       the scroll).  In nearly all cases these transient errors\\n\"\n\"                       are repaired when the true X framebuffer is consulted\\n\"\n\"                       by the normal polling.  But they are distracting, so\\n\"\n\"                       what this option provides is extra \\\"padding\\\" near the\\n\"\n\"                       bottom of the terminal window: a few extra lines near\\n\"\n\"                       the bottom will not be scrolled, but rather updated\\n\"\n\"                       from the actual X framebuffer.  This usually reduces\\n\"\n\"                       the annoying artifacts.  Use \\\"none\\\" to disable.\\n\"\n\"                       Default: \\\"%s\\\"\\n\"\n\"\\n\"\n\"-scr_keyrepeat lo-hi   If a key is held down (or otherwise repeats rapidly) and\\n\"\n\"                       this induces a rapid sequence of scrolls (e.g. holding\\n\"\n\"                       down an Arrow key) the \\\"scrollcopyrect\\\" detection\\n\"\n\"                       and overhead may not be able to keep up.  A time per\\n\"\n\"                       single scroll estimate is performed and if that estimate\\n\"\n\"                       predicts a sustainable scrollrate of keys per second\\n\"\n\"                       between \\\"lo\\\" and \\\"hi\\\" then repeated keys will be\\n\"\n\"                       DISCARDED to maintain the scrollrate. For example your\\n\"\n\"                       key autorepeat may be 25 keys/sec, but for a large\\n\"\n\"                       window or slow link only 8 scrolls per second can be\\n\"\n\"                       sustained, then roughly 2 out of every 3 repeated keys\\n\"\n\"                       will be discarded during this period. Default: \\\"%s\\\"\\n\"\n\"\\n\"\n\"-scr_parms string      Set various parameters for the scrollcopyrect mode.\\n\"\n\"                       The format is similar to that for -wireframe and packed\\n\"\n\"                       with lots of parameters:\\n\"\n\"\\n\"\n\"                       Format: T+B+L+R,t1+t2+t3,s1+s2+s3+s4+s5\\n\"\n\"                       Default: %s\\n\"\n\"\\n\"\n\"                       If you leave nothing between commas: \\\",,\\\" the default\\n\"\n\"                       value is used.  If you don't specify enough commas,\\n\"\n\"                       the trailing parameters are set to their defaults.\\n\"\n\"\\n\"\n\"                       \\\"T+B+L+R\\\" indicates four integers for how close in\\n\"\n\"                       pixels the pointer has to be from the Top, Bottom, Left,\\n\"\n\"                       or Right edges of the window to consider scrollcopyrect.\\n\"\n\"                       If -wireframe overlaps it takes precedence.  This is a\\n\"\n\"                       speedup to quickly exclude a window from being watched\\n\"\n\"                       for scrollcopyrect: set them all to zero to not try\\n\"\n\"                       the speedup (things like selecting text will likely\\n\"\n\"                       be slower).\\n\"\n\"\\n\"\n\"                       \\\"t1+t2+t3\\\" specify three floating point times in\\n\"\n\"                       seconds that apply to scrollcopyrect detection with\\n\"\n\"                       *Keystroke* input: t1 is how long to wait after a key\\n\"\n\"                       is pressed for the first scroll, t2 is how long to keep\\n\"\n\"                       looking after a Keystroke scroll for more scrolls.\\n\"\n\"                       t3 is how frequently to try to update surrounding\\n\"\n\"                       scrollbars outside of the scrolling area (0.0 to\\n\"\n\"                       disable)\\n\"\n\"\\n\"\n\"                       \\\"s1+s2+s3+s4+s5\\\" specify five floating point times\\n\"\n\"                       in seconds that apply to scrollcopyrect detection with\\n\"\n\"                       *Mouse* input: s1 is how long to wait after a mouse\\n\"\n\"                       button is pressed for the first scroll, s2 is how long\\n\"\n\"                       to keep waiting for additional scrolls after the first\\n\"\n\"                       Mouse scroll was detected.  s3 is how frequently to\\n\"\n\"                       try to update surrounding scrollbars outside of the\\n\"\n\"                       scrolling area (0.0 to disable).  s4 is how long to\\n\"\n\"                       buffer pointer motion (to try to get fewer, bigger\\n\"\n\"                       mouse scrolls). s5 is the maximum time to spend just\\n\"\n\"                       updating the scroll window without updating the rest\\n\"\n\"                       of the screen.\\n\"\n\"\\n\"\n\"-fixscreen string      Periodically \\\"repair\\\" the screen based on settings\\n\"\n\"                       in \\\"string\\\".  Hopefully you won't need this option,\\n\"\n\"                       it is intended for cases when the -scrollcopyrect or\\n\"\n\"                       -wirecopyrect features leave too many painting errors,\\n\"\n\"                       but it can be used for any scenario.  This option\\n\"\n\"                       periodically performs costly operations and so\\n\"\n\"                       interactive response may be reduced when it is on.\\n\"\n\"                       You can use 3 Alt_L's (the Left \\\"Alt\\\" key) taps in\\n\"\n\"                       a row (as described under -scrollcopyrect) instead to\\n\"\n\"                       manually request a screen repaint when it is needed.\\n\"\n\"\\n\"\n\"                       \\\"string\\\" is a comma separated list of one or more of\\n\"\n\"                       the following: \\\"V=t\\\", \\\"C=t\\\", \\\"X=t\\\", and \\\"8=t\\\".\\n\"\n\"                       In these \\\"t\\\" stands for a time in seconds (it is\\n\"\n\"                       a floating point even though one should usually use\\n\"\n\"                       values > 2 to avoid wasting resources).  V sets how\\n\"\n\"                       frequently the entire screen should be sent to viewers\\n\"\n\"                       (it is like the 3 Alt_L's).  C sets how long to wait\\n\"\n\"                       after a CopyRect to repaint the full screen.  X sets\\n\"\n\"                       how frequently to reread the full X11 framebuffer from\\n\"\n\"                       the X server and push it out to connected viewers.\\n\"\n\"                       Use of X should be rare, please report a bug if you\\n\"\n\"                       find you need it. 8= applies only for -8to24 mode: it\\n\"\n\"                       sets how often the non-default visual regions of the\\n\"\n\"                       screen (e.g. 8bpp windows) are refreshed.  Examples:\\n\"\n\"                       -fixscreen V=10 -fixscreen C=10\\n\"\n\"\\n\"\n\"-debug_scroll          Turn on debugging info printout for the scroll\\n\"\n\"                       heuristics.  \\\"-ds\\\" is an alias.  Specify it multiple\\n\"\n\"                       times for more output.\\n\"\n\"\\n\"\n\"-noxrecord             Disable any use of the RECORD extension.  This is\\n\"\n\"                       currently used by the -scrollcopyrect scheme and to\\n\"\n\"                       monitor X server grabs.\\n\"\n\"\\n\"\n\"-grab_buster           Some of the use of the RECORD extension can leave a\\n\"\n\"-nograb_buster         tiny window for XGrabServer deadlock.  This is only if\\n\"\n\"                       the whole-server grabbing application expects mouse or\\n\"\n\"                       keyboard input before releasing the grab.  It is usually\\n\"\n\"                       a window manager that does this.  x11vnc takes care to\\n\"\n\"                       avoid the problem, but if caught x11vnc will freeze.\\n\"\n\"                       Without -grab_buster, the only solution is to go the\\n\"\n\"                       physical display and give it some input to satisfy the\\n\"\n\"                       grabbing app.  Or manually kill and restart the window\\n\"\n\"                       manager if that is feasible.  With -grab_buster, x11vnc\\n\"\n\"                       will fork a helper thread and if x11vnc appears to be\\n\"\n\"                       stuck in a grab after a period of time (20-30 sec) then\\n\"\n\"                       it will inject some user input: button clicks, Escape,\\n\"\n\"                       mouse motion, etc to try to break the grab.  If you\\n\"\n\"                       experience a lot of grab deadlock, please report a bug.\\n\"\n\"\\n\"\n\"-debug_grabs           Turn on debugging info printout with respect to\\n\"\n\"                       XGrabServer() deadlock for -scrollcopyrect mode.\\n\"\n\"\\n\"\n\"-debug_sel             Turn on debugging info printout with respect to\\n\"\n\"                       PRIMARY, CLIPBOARD, and CUTBUFFER0 selections.\\n\"\n\"\\n\"\n\"-pointer_mode n        Various pointer motion update schemes. \\\"-pm\\\" is\\n\"\n\"                       an alias.  The problem is pointer motion can cause\\n\"\n\"                       rapid changes on the screen: consider the rapid\\n\"\n\"                       changes when you drag a large window around opaquely.\\n\"\n\"                       Neither x11vnc's screen polling and vnc compression\\n\"\n\"                       routines nor the bandwidth to the vncviewers can keep\\n\"\n\"                       up these rapid screen changes: everything will bog down\\n\"\n\"                       when dragging or scrolling.  So a scheme has to be used\\n\"\n\"                       to \\\"eat\\\" much of that pointer input before re-polling\\n\"\n\"                       the screen and sending out framebuffer updates. The\\n\"\n\"                       mode number \\\"n\\\" can be 0 to %d and selects one of\\n\"\n\"                       the schemes described below.\\n\"\n\"\\n\"\n\"                       Note that the -wireframe and -scrollcopyrect modes\\n\"\n\"                       complement -pointer_mode by detecting (and improving)\\n\"\n\"                       certain periods of \\\"rapid screen change\\\".\\n\"\n\"\\n\"\n\"                       n=0: does the same as -nodragging. (all screen polling\\n\"\n\"                       is suspended if a mouse button is pressed.)\\n\"\n\"\\n\"\n\"                       n=1: was the original scheme used to about Jan 2004:\\n\"\n\"                       it basically just skips -input_skip keyboard or pointer\\n\"\n\"                       events before repolling the screen.\\n\"\n\"\\n\"\n\"                       n=2 is an improved scheme: by watching the current rate\\n\"\n\"                       of input events it tries to detect if it should try to\\n\"\n\"                       \\\"eat\\\" additional pointer events before continuing.\\n\"\n\"\\n\"\n\"                       n=3 is basically a dynamic -nodragging mode: it detects\\n\"\n\"                       when the mouse motion has paused and then refreshes\\n\"\n\"                       the display.\\n\"\n\"\\n\"\n\"                       n=4 attempts to measures network rates and latency,\\n\"\n\"                       the video card read rate, and how many tiles have been\\n\"\n\"                       changed on the screen.  From this, it aggressively tries\\n\"\n\"                       to push screen \\\"frames\\\" when it decides it has enough\\n\"\n\"                       resources to do so.  NOT FINISHED.\\n\"\n\"\\n\"\n\"                       The default n is %d. Note that modes 2, 3, 4 will skip\\n\"\n\"                       -input_skip keyboard events (but it will not count\\n\"\n\"                       pointer events).  Also note that these modes are not\\n\"\n\"                       available in -threads mode which has its own pointer\\n\"\n\"                       event handling mechanism.\\n\"\n\"\\n\"\n\"                       To try out the different pointer modes to see which\\n\"\n\"                       one gives the best response for your usage, it is\\n\"\n\"                       convenient to use the remote control function, for\\n\"\n\"                       example \\\"x11vnc -R pm:4\\\" or the tcl/tk gui (Tuning ->\\n\"\n\"                       pointer_mode -> n).\\n\"\n\"\\n\"\n\"-input_skip n          For the pointer handling when non-threaded: try to\\n\"\n\"                       read n user input events before scanning display. n < 0\\n\"\n\"                       means to act as though there is always user input.\\n\"\n\"                       Default: %d\\n\"\n\"\\n\"\n\"-allinput              Have x11vnc read and process all available client input\\n\"\n\"                       before proceeding.\\n\"\n\"\\n\"\n\"-input_eagerly         Similar to -allinput but use the handleEventsEagerly\\n\"\n\"                       mechanism built into LibVNCServer.\\n\"\n\"\\n\"\n\"-multiptr              Enable support for per-client input devices. Each\\n\"\n\"                       client will get its own cursor and keyboard focus.\\n\"\n\"\\n\"\n\"-speeds rd,bw,lat      x11vnc tries to estimate some speed parameters that\\n\"\n\"                       are used to optimize scheduling (e.g. -pointer_mode\\n\"\n\"                       4, -wireframe, -scrollcopyrect) and other things.\\n\"\n\"                       Use the -speeds option to set these manually.\\n\"\n\"                       The triple \\\"rd,bw,lat\\\" corresponds to video h/w\\n\"\n\"                       read rate in MB/sec, network bandwidth to clients in\\n\"\n\"                       KB/sec, and network latency to clients in milliseconds,\\n\"\n\"                       respectively.  If a value is left blank, e.g. \\\"-speeds\\n\"\n\"                       ,100,15\\\", then the internal scheme is used to estimate\\n\"\n\"                       the empty value(s).\\n\"\n\"\\n\"\n\"                       Typical PC video cards have read rates of 5-10 MB/sec.\\n\"\n\"                       If the framebuffer is in main memory instead of video\\n\"\n\"                       h/w (e.g. SunRay, shadowfb, dummy driver, Xvfb), the\\n\"\n\"                       read rate may be much faster.  \\\"x11perf -getimage500\\\"\\n\"\n\"                       can be used to get a lower bound (remember to factor\\n\"\n\"                       in the bytes per pixel).  It is up to you to estimate\\n\"\n\"                       the network bandwidth and latency to clients.  For the\\n\"\n\"                       latency the ping(1) command can be used.\\n\"\n\"\\n\"\n\"                       For convenience there are some aliases provided,\\n\"\n\"                       e.g. \\\"-speeds modem\\\".  The aliases are: \\\"modem\\\" for\\n\"\n\"                       6,4,200; \\\"dsl\\\" for 6,100,50; and \\\"lan\\\" for 6,5000,1\\n\"\n\"\\n\"\n\"-wmdt string           For some features, e.g. -wireframe and -scrollcopyrect,\\n\"\n\"                       x11vnc has to work around issues for certain window\\n\"\n\"                       managers or desktops (currently kde and xfce).\\n\"\n\"                       By default it tries to guess which one, but it can\\n\"\n\"                       guess incorrectly.  Use this option to indicate which\\n\"\n\"                       wm/dt.  \\\"string\\\" can be \\\"gnome\\\", \\\"kde\\\", \\\"cde\\\",\\n\"\n\"                       \\\"xfce\\\", or \\\"root\\\" (classic X wm).  Anything else\\n\"\n\"                       is interpreted as \\\"root\\\".\\n\"\n\"\\n\"\n\"-debug_pointer         Print debugging output for every pointer event.\\n\"\n\"-debug_keyboard        Print debugging output for every keyboard event.\\n\"\n\"                       Same as -dp and -dk, respectively.  Use multiple\\n\"\n\"                       times for more output.\\n\"\n\"\\n\"\n\"-defer time            Time in ms to delay sending updates to connected clients\\n\"\n\"                       (deferUpdateTime)  Default: %d\\n\"\n\"\\n\"\n\"-wait time             Time in ms to pause between screen polls.  Used to cut\\n\"\n\"                       down on load.  Default: %d\\n\"\n\"\\n\"\n\"-extra_fbur n          Perform extra FrameBufferUpdateRequests checks to\\n\"\n\"                       try to be in better sync with the client's requests.\\n\"\n\"                       What this does is perform extra polls of the client\\n\"\n\"                       socket at critical times (before '-defer' and '-wait'\\n\"\n\"                       calls.)  The default is n=1.  Set to a larger number to\\n\"\n\"                       insert more checks or set to n=0 to disable.  A downside\\n\"\n\"                       of these extra calls is that more mouse input may be\\n\"\n\"                       processed than desired.\\n\"\n\"\\n\"\n\"-wait_ui factor        Factor by which to cut the -wait time if there\\n\"\n\"                       has been recent user input (pointer or keyboard).\\n\"\n\"                       Improves response, but increases the load whenever you\\n\"\n\"                       are moving the mouse or typing.  Default: %.2f\\n\"\n\"-setdefer n            When the -wait_ui mechanism cuts down the wait time ms,\\n\"\n\"                       set the defer time to the same ms value. n=1 to enable,\\n\"\n\"                       0 to disable, and -1 to set defer to 0 (no delay).\\n\"\n\"                       Similarly, 2 and -2 indicate 'urgent_update' mode should\\n\"\n\"                       be used to push the updates even sooner.  Default: 1\\n\"\n\"-nowait_bog            Do not detect if the screen polling is \\\"bogging down\\\"\\n\"\n\"                       and sleep more.  Some activities with no user input can\\n\"\n\"                       slow things down a lot: consider a large terminal window\\n\"\n\"                       with a long build running in it continuously streaming\\n\"\n\"                       text output.  By default x11vnc will try to detect this\\n\"\n\"                       (3 screen polls in a row each longer than 0.25 sec with\\n\"\n\"                       no user input), and sleep up to 1.5 secs to let things\\n\"\n\"                       \\\"catch up\\\".  Use this option to disable that detection.\\n\"\n\"-slow_fb time          Floating point time in seconds to delay all screen\\n\"\n\"                       polling.  For special purpose usage where a low frame\\n\"\n\"                       rate is acceptable and desirable, but you want the\\n\"\n\"                       user input processed at the normal rate so you cannot\\n\"\n\"                       use -wait.\\n\"\n\"-xrefresh time         Floating point time in seconds to indicate how often to\\n\"\n\"                       do the equivalent of xrefresh(1) to force all windows\\n\"\n\"                       (in the viewable area if -id, -sid, or -clip is used)\\n\"\n\"                       to repaint themselves.  Use this only if applications\\n\"\n\"                       misbehave by not repainting themselves properly.\\n\"\n\"                       See also -noxdamage.\\n\"\n\"-nap                   Monitor activity and if it is low take longer naps\\n\"\n\"-nonap                 between screen polls to really cut down load when idle.\\n\"\n\"                       Default: %s\\n\"\n\"-sb time               Time in seconds after NO activity (e.g. screen blank)\\n\"\n\"                       to really throttle down the screen polls (i.e. sleep\\n\"\n\"                       for about 1.5 secs). Use 0 to disable.  Default: %d\\n\"\n\"                       Set the env. var. X11VNC_SB_FACTOR to scale it.\\n\"\n\"\\n\"\n\"-readtimeout n         Set LibVNCServer rfbMaxClientWait to n seconds. On\\n\"\n\"                       slow links that take a long time to paint the first\\n\"\n\"                       screen LibVNCServer may hit the timeout and drop the\\n\"\n\"                       connection.  Default: %d seconds.\\n\"\n\"-ping n                Send a 1x1 framebuffer update to all clients every n\\n\"\n\"                       seconds (e.g. to try to keep a network connection alive)\\n\"\n\"\\n\"\n\"-nofbpm                If the system supports the FBPM (Frame Buffer Power\\n\"\n\"-fbpm                  Management) extension (i.e. some Sun systems), then\\n\"\n\"                       prevent the video h/w from going into a reduced power\\n\"\n\"                       state when VNC clients are connected.\\n\"\n\"\\n\"\n\"                       FBPM capable video h/w save energy when the workstation\\n\"\n\"                       is idle by going into low power states (similar to DPMS\\n\"\n\"                       for monitors).  This interferes with x11vnc's polling\\n\"\n\"                       of the framebuffer data.\\n\"\n\"\\n\"\n\"                       \\\"-nofbpm\\\" means prevent FBPM low power states whenever\\n\"\n\"                       VNC clients are connected, while \\\"-fbpm\\\" means to not\\n\"\n\"                       monitor the FBPM state at all.  See the xset(1) manpage\\n\"\n\"                       for details.  -nofbpm is basically the same as running\\n\"\n\"                       \\\"xset fbpm force on\\\" periodically.  Default: %s\\n\"\n\"\\n\"\n\"-nodpms                If the system supports the DPMS (Display Power Management\\n\"\n\"-dpms                  Signaling) extension, then prevent the monitor from\\n\"\n\"                       going into a reduced power state when VNC clients\\n\"\n\"                       are connected.\\n\"\n\"\\n\"\n\"                       DPMS reduced power monitor states are a good thing\\n\"\n\"                       and you normally want the power down to take place\\n\"\n\"                       (usually x11vnc has no problem exporting the display in\\n\"\n\"                       this state).  You probably only want to use \\\"-nodpms\\\"\\n\"\n\"                       to work around problems with Screen Savers kicking\\n\"\n\"                       on in DPMS low power states.  There is known problem\\n\"\n\"                       with kdesktop_lock on KDE where the screen saver keeps\\n\"\n\"                       kicking in every time user input stops for a second\\n\"\n\"                       or two.  Specifying \\\"-nodpms\\\" works around it.\\n\"\n\"\\n\"\n\"                       \\\"-nodpms\\\" means prevent DPMS low power states whenever\\n\"\n\"                       VNC clients are connected, while \\\"-dpms\\\" means to not\\n\"\n\"                       monitor the DPMS state at all.  See the xset(1) manpage\\n\"\n\"                       for details.  -nodpms is basically the same as running\\n\"\n\"                       \\\"xset dpms force on\\\" periodically.  Default: %s\\n\"\n\"\\n\"\n\"-forcedpms             If the system supports the DPMS (Display Power\\n\"\n\"                       Management Signaling) extension, then try to keep the\\n\"\n\"                       monitor in a powered off state.  This is to prevent\\n\"\n\"                       nosey people at the physical display from viewing what\\n\"\n\"                       is on the screen.  Be sure to lock the screen before\\n\"\n\"                       disconnecting.\\n\"\n\"\\n\"\n\"                       This method is far from bullet proof, e.g. suppose\\n\"\n\"                       someone attaches a non-DPMS monitor, or loads the\\n\"\n\"                       machine so that there is a gap of time before x11vnc\\n\"\n\"                       restores the powered off state?  On many machines if\\n\"\n\"                       he floods it with keyboard and mouse input he can see\\n\"\n\"                       flashes of what is on the screen before the DPMS off\\n\"\n\"                       state is reestablished.  For this to work securely\\n\"\n\"                       there would need to be support in the X server to do\\n\"\n\"                       this exactly rather than approximately with DPMS.\\n\"\n\"\\n\"\n\"-clientdpms            As -forcedpms but only when VNC clients are connected.\\n\"\n\"\\n\"\n\"-noserverdpms          The UltraVNC ServerInput extension is supported.\\n\"\n\"                       This allows the VNC viewer to click a button that will\\n\"\n\"                       cause the server (x11vnc) to try to disable keyboard\\n\"\n\"                       and mouse input at the physical display and put the\\n\"\n\"                       monitor in dpms powered off state.  Use this option to\\n\"\n\"                       skip powering off the monitor.\\n\"\n\"\\n\"\n\"-noultraext            Disable the following UltraVNC extensions: SingleWindow\\n\"\n\"                       and ServerInput.  The others managed by LibVNCServer\\n\"\n\"                       (textchat, 1/n scaling, rfbEncodingUltra) are not.\\n\"\n\"\\n\"\n\"-chatwindow            Place a local UltraVNC chat window on the X11 display\\n\"\n\"                       that x11vnc is polling.  That way the person on the VNC\\n\"\n\"                       viewer-side can chat with the person at the physical\\n\"\n\"                       X11 console. (e.g. helpdesk w/o telephone)\\n\"\n\"\\n\"\n\"                       For this to work the SSVNC package (version 1.0.21 or\\n\"\n\"                       later) MUST BE installed on the system where x11vnc runs\\n\"\n\"                       and the 'ssvnc' command must be available in $PATH.\\n\"\n\"                       The ssvncviewer is used as a chat window helper.\\n\"\n\"                       See http://www.karlrunge.com/x11vnc/ssvnc.html\\n\"\n\"\\n\"\n\"                       This option implies '-rfbversion 3.6' so as to trick\\n\"\n\"                       UltraVNC viewers, otherwise they assume chat is not\\n\"\n\"                       available.  To specify a different rfbversion, place\\n\"\n\"                       it after the -chatwindow option on the cmdline.\\n\"\n\"\\n\"\n\"                       See also the remote control 'chaton' and 'chatoff'\\n\"\n\"                       actions.  These can also be set from the tkx11vnc GUI.\\n\"\n\"\\n\"\n\"-noxdamage             Do not use the X DAMAGE extension to detect framebuffer\\n\"\n\"                       changes even if it is available.  Use -xdamage if your\\n\"\n\"                       default is to have it off.\\n\"\n\"\\n\"\n\"                       x11vnc's use of the DAMAGE extension: 1) significantly\\n\"\n\"                       reduces the load when the screen is not changing much,\\n\"\n\"                       and 2) detects changed areas (small ones by default)\\n\"\n\"                       more quickly.\\n\"\n\"\\n\"\n\"                       Currently the DAMAGE extension is overly conservative\\n\"\n\"                       and often reports large areas (e.g. a whole terminal\\n\"\n\"                       or browser window) as damaged even though the actual\\n\"\n\"                       changed region is much smaller (sometimes just a few\\n\"\n\"                       pixels).  So heuristics were introduced to skip large\\n\"\n\"                       areas and use the damage rectangles only as \\\"hints\\\"\\n\"\n\"                       for the traditional scanline polling.  The following\\n\"\n\"                       tuning parameters are introduced to adjust this\\n\"\n\"                       behavior:\\n\"\n\"\\n\"\n\"-xd_area A             Set the largest DAMAGE rectangle area \\\"A\\\" (in\\n\"\n\"                       pixels: width * height) to trust as truly damaged:\\n\"\n\"                       the rectangle will be copied from the framebuffer\\n\"\n\"                       (slow) no matter what.  Set to zero to trust *all*\\n\"\n\"                       rectangles. Default: %d\\n\"\n\"-xd_mem f              Set how long DAMAGE rectangles should be \\\"remembered\\\",\\n\"\n\"                       \\\"f\\\" is a floating point number and is in units of the\\n\"\n\"                       scanline repeat cycle time (%d iterations).  The default\\n\"\n\"                       (%.1f) should give no painting problems. Increase it if\\n\"\n\"                       there are problems or decrease it to live on the edge\\n\"\n\"                       (perhaps useful on a slow machine).\\n\"\n\"\\n\"\n\"-sigpipe string        Broken pipe (SIGPIPE) handling.  \\\"string\\\" can be\\n\"\n\"                       \\\"ignore\\\" or \\\"exit\\\".  For \\\"ignore\\\" LibVNCServer\\n\"\n\"                       will handle the abrupt loss of a client and continue,\\n\"\n\"                       for \\\"exit\\\" x11vnc will cleanup and exit at the 1st\\n\"\n\"                       broken connection.\\n\"\n\"\\n\"\n\"                       This option is not really needed since LibVNCServer\\n\"\n\"                       is doing the correct thing now for quite some time.\\n\"\n\"                       However, for convenience you can use it to ignore other\\n\"\n\"                       signals, e.g. \\\"-sigpipe ignore:HUP,INT,TERM\\\" in case\\n\"\n\"                       that would be useful for some sort of application.\\n\"\n\"                       You can also put \\\"exit:..\\\" in the list to have x11vnc\\n\"\n\"                       cleanup on the listed signals. \\\"-sig\\\" is an alias\\n\"\n\"                       for this option if you don't like the 'pipe'. Example:\\n\"\n\"                       -sig ignore:INT,TERM,exit:USR1\\n\"\n\"\\n\"\n\"-threads               Whether or not to use the threaded LibVNCServer\\n\"\n\"-nothreads             algorithm [rfbRunEventLoop] if libpthread is available.\\n\"\n\"                       In this mode new threads (one for input and one\\n\"\n\"                       for output) are created to handle each new client.\\n\"\n\"                       Default: %s.\\n\"\n\"\\n\"\n\"                       Thread stability is much improved in version 0.9.8.\\n\"\n\"\\n\"\n\"                       Multiple clients in threaded mode should be stable\\n\"\n\"                       for the ZRLE encoding on all platforms.  The Tight and\\n\"\n\"                       Zlib encodings are currently only stable on Linux for\\n\"\n\"                       multiple clients.  Compile with -DTLS=__thread if your\\n\"\n\"                       OS and compiler and linker support it.\\n\"\n\"\\n\"\n\"                       For resizes (randr, etc.) set this env. var. to the number\\n\"\n\"                       of milliseconds to sleep: X11VNC_THREADS_NEW_FB_SLEEP\\n\"\n\"                       at various places in the do_new_fb() action.  This is to\\n\"\n\"                       let various activities settle.  Default is about 500ms.\\n\"\n\"\\n\"\n\"                       Multiple clients in threaded mode could yield better\\n\"\n\"                       performance for 'class-room' broadcasting usage; also in\\n\"\n\"                       -appshare broadcast mode.  See also the -reflect option.\\n\"\n\"\\n\"\n\"-fs f                  If the fraction of changed tiles in a poll is greater\\n\"\n\"                       than f, the whole screen is updated.  Default: %.2f\\n\"\n\"-gaps n                Heuristic to fill in gaps in rows or cols of n or\\n\"\n\"                       less tiles.  Used to improve text paging.  Default: %d\\n\"\n\"-grow n                Heuristic to grow islands of changed tiles n or wider\\n\"\n\"                       by checking the tile near the boundary.  Default: %d\\n\"\n\"-fuzz n                Tolerance in pixels to mark a tiles edges as changed.\\n\"\n\"                       Default: %d\\n\"\n\"-debug_tiles           Print debugging output for tiles, fb updates, etc.\\n\"\n\"\\n\"\n\"-snapfb                Instead of polling the X display framebuffer (fb)\\n\"\n\"                       for changes, periodically copy all of X display fb\\n\"\n\"                       into main memory and examine that copy for changes.\\n\"\n\"                       (This setting also applies for non-X -rawfb modes).\\n\"\n\"                       Under some circumstances this will improve interactive\\n\"\n\"                       response, or at least make things look smoother, but in\\n\"\n\"                       others (most!) it will make the response worse.  If the\\n\"\n\"                       video h/w fb is such that reading small tiles is very\\n\"\n\"                       slow this mode could help.  To keep the \\\"framerate\\\"\\n\"\n\"                       up the screen size x bpp cannot be too large.  Note that\\n\"\n\"                       this mode is very wasteful of memory I/O resources\\n\"\n\"                       (it makes full screen copies even if nothing changes).\\n\"\n\"                       It may be of use in video capture-like applications,\\n\"\n\"                       webcams, or where window tearing is a problem.\\n\"\n\"\\n\"\n\"-rawfb string          Instead of polling X, poll the memory object specified\\n\"\n\"                       in \\\"string\\\".\\n\"\n\"\\n\"\n\"                       For file polling, to memory map mmap(2) a file use:\\n\"\n\"                       \\\"map:/path/to/a/file@WxHxB\\\", with framebuffer Width,\\n\"\n\"                       Height, and Bits per pixel.  \\\"mmap:...\\\" is the\\n\"\n\"                       same.\\n\"\n\"\\n\"\n\"                       If there is trouble with mmap, use \\\"file:/...\\\"\\n\"\n\"                       for slower lseek(2) based reading.\\n\"\n\"\\n\"\n\"                       Use \\\"snap:...\\\" to imply -snapfb mode and the \\\"file:\\\"\\n\"\n\"                       access (this is for unseekable devices that only provide\\n\"\n\"                       the fb all at once, e.g. a video camera provides the\\n\"\n\"                       whole frame).\\n\"\n\"\\n\"\n\"                       For shared memory segments string is of the form:\\n\"\n\"                       \\\"shm:N@WxHxB\\\" which specifies a shmid N and with\\n\"\n\"                       WxHxB as above.  See shmat(1) and ipcs(1)\\n\"\n\"\\n\"\n\"                       If you do not supply a type \\\"map\\\" is assumed if\\n\"\n\"                       the file exists (see the next paragraphs for some\\n\"\n\"                       exceptions to this.)\\n\"\n\"\\n\"\n\"                       If string is \\\"setup:cmd\\\", then the command \\\"cmd\\\"\\n\"\n\"                       is run and the first line from it is read and used\\n\"\n\"                       as \\\"string\\\".  This allows initializing the device,\\n\"\n\"                       determining WxHxB, etc. These are often done as root\\n\"\n\"                       so take care.\\n\"\n\"\\n\"\n\"                       If the string begins with \\\"video\\\", see the VIDEO4LINUX\\n\"\n\"                       discussion below where the device may be queried for\\n\"\n\"                       (and possibly set) the framebuffer parameters.\\n\"\n\"\\n\"\n\"                       If the string begins with \\\"console\\\", \\\"/dev/fb\\\",\\n\"\n\"                       \\\"fb\\\", or \\\"vt\\\", see the LINUX CONSOLE discussion\\n\"\n\"                       below where the framebuffer device is opened and\\n\"\n\"                       keystrokes (and possibly mouse events) are inserted\\n\"\n\"                       into the console.\\n\"\n\"\\n\"\n\"                       If the string begins with \\\"vnc\\\", see the VNC HOST\\n\"\n\"                       discussion below where the framebuffer is taken as that\\n\"\n\"                       of another remote VNC server.\\n\"\n\"\\n\"\n\"                       Optional suffixes are \\\":R/G/B\\\" and \\\"+O\\\" to specify\\n\"\n\"                       red, green, and blue masks (in hex) and an offset into\\n\"\n\"                       the memory object.  If the masks are not provided x11vnc\\n\"\n\"                       guesses them based on the bpp (if the colors look wrong,\\n\"\n\"                       you need to provide the masks.)\\n\"\n\"\\n\"\n\"                       Another optional suffix is the Bytes Per Line which in\\n\"\n\"                       some cases is not WxB/8.  Specify it as WxHxB-BPL\\n\"\n\"                       e.g. 800x600x16-2048.  This could be a normal width\\n\"\n\"                       1024 at 16bpp fb, but only width 800 shows up.\\n\"\n\"\\n\"\n\"                       So the full format is: mode:file@WxHxB:R/G/B+O-BPL\\n\"\n\"\\n\"\n\"                       Examples:\\n\"\n\"                           -rawfb shm:210337933@800x600x32:ff/ff00/ff0000\\n\"\n\"                           -rawfb map:/dev/fb0@1024x768x32\\n\"\n\"                           -rawfb map:/tmp/Xvfb_screen0@640x480x8+3232\\n\"\n\"                           -rawfb file:/tmp/my.pnm@250x200x24+37\\n\"\n\"                           -rawfb file:/dev/urandom@128x128x8\\n\"\n\"                           -rawfb snap:/dev/video0@320x240x24 -24to32\\n\"\n\"                           -rawfb video0\\n\"\n\"                           -rawfb video -pipeinput VID\\n\"\n\"                           -rawfb console\\n\"\n\"                           -rawfb vt2\\n\"\n\"                           -rawfb vnc:somehost:0\\n\"\n\"\\n\"\n\"                       (see ipcs(1) and fbset(1) for the first two examples)\\n\"\n\"\\n\"\n\"                       In general all user input is discarded by default (see\\n\"\n\"                       the -pipeinput option for how to use a helper program\\n\"\n\"                       to insert).  Most of the X11 (screen, keyboard, mouse)\\n\"\n\"                       options do not make sense and many will cause this\\n\"\n\"                       mode to crash, so please think twice before setting or\\n\"\n\"                       changing them in a running x11vnc.\\n\"\n\"\\n\"\n\"                       If you DO NOT want x11vnc to close the X DISPLAY in\\n\"\n\"                       rawfb mode, prepend a \\\"+\\\" e.g. +file:/dev/fb0...\\n\"\n\"                       Keeping the display open enables the default\\n\"\n\"                       remote-control channel, which could be useful.\\n\"\n\"                       Alternatively, if you specify -noviewonly, then the\\n\"\n\"                       mouse and keyboard input are STILL sent to the X\\n\"\n\"                       display, this usage should be very rare, i.e. doing\\n\"\n\"                       something strange with /dev/fb0.\\n\"\n\"\\n\"\n\"                       If the device is not \\\"seekable\\\" (e.g. webcam) try\\n\"\n\"                       reading it all at once in full snaps via the \\\"snap:\\\"\\n\"\n\"                       mode (note: this is a resource hog).  If you are using\\n\"\n\"                       file: or map: AND the device needs to be reopened for\\n\"\n\"                       *every* snapfb snapshot, set the environment variable:\\n\"\n\"                       SNAPFB_RAWFB_RESET=1 as well.\\n\"\n\"\\n\"\n\"                       If you want x11vnc to dynamically transform a 24bpp\\n\"\n\"                       rawfb to 32bpp (note that this will be slower) also\\n\"\n\"                       supply the -24to32 option.  This would be useful for,\\n\"\n\"                       say, a video camera that delivers the pixel data as\\n\"\n\"                       24bpp packed RGB.  This is the default under \\\"video\\\"\\n\"\n\"                       mode if the bpp is 24.\\n\"\n\"\\n\"\n\"                       Normally the bits per pixel, B, is 8, 16, or 32 (or\\n\"\n\"                       rarely 24), however there is also some support for\\n\"\n\"                       B < 8 (e.g. old graphics displays 4 bpp or 1 bpp).\\n\"\n\"                       In this case you certainly must supply the masks as\\n\"\n\"                       well: WxHxB:R/G/B.  The pixels will be padded out to\\n\"\n\"                       8 bpp using depth 8 truecolor.  The scheme currently\\n\"\n\"                       does not work with snap fb (ask if interested.) B=1\\n\"\n\"                       monochrome example: file:/dev/urandom@128x128x1:1/1/1\\n\"\n\"                       Some other like this are 128x128x2:3/3/3 128x128x4:7/7/7\\n\"\n\"\\n\"\n\"                       For B < 8 framebuffers you can also set the env. var\\n\"\n\"                       RAWFB_CGA=1 to try a CGA mapping for B=4 (e.g. linux\\n\"\n\"                       vga16fb driver.)  Note with low bpp and/or resolution\\n\"\n\"                       VGA and VGA16 modes on the Linux console one's attempt\\n\"\n\"                       to export them via x11vnc can often be thwarted due to\\n\"\n\"                       special color palettes, pixel packings, and even video\\n\"\n\"                       painting buffering.  OTOH, often experimenting with the\\n\"\n\"                       RGB masks can yield something recognizable.\\n\"\n\"\\n\"\n\"                       VIDEO4LINUX: on Linux some attempt is made to handle\\n\"\n\"                       video devices (webcams or TV tuners) automatically.\\n\"\n\"                       The idea is the WxHxB will be extracted from the\\n\"\n\"                       device itself.  So if you do not supply \\\"@WxHxB...\\n\"\n\"                       parameters x11vnc will try to determine them.  It first\\n\"\n\"                       tries the v4l API if that support has been compiled in.\\n\"\n\"                       Otherwise it will run the v4l-info(1) external program\\n\"\n\"                       if it is available.\\n\"\n\"\\n\"\n\"                       The simplest examples are \\\"-rawfb video\\\" and \\\"-rawfb\\n\"\n\"                       video1\\\" which imply the device file /dev/video and\\n\"\n\"                       /dev/video1, respectively.  You can also supply the\\n\"\n\"                       /dev if you like, e.g. \\\"-rawfb /dev/video0\\\"\\n\"\n\"\\n\"\n\"                       Since the video capture device framebuffer usually\\n\"\n\"                       changes continuously (e.g. brightness fluctuations),\\n\"\n\"                       you may want to use the -wait, -slow_fb, or -defer\\n\"\n\"                       options to lower the \\\"framerate\\\" to cut down on\\n\"\n\"                       network VNC traffic.\\n\"\n\"\\n\"\n\"                       A more sophisticated video device scheme allows\\n\"\n\"                       initializing the device's settings using:\\n\"\n\"\\n\"\n\"                           -rawfb video:<settings>\\n\"\n\"\\n\"\n\"                       The prefix could also be, as above, e.g. \\\"video1:\\\" to\\n\"\n\"                       specify the device file.  The v4l API must be available\\n\"\n\"                       for this to work.  Otherwise, you will need to try\\n\"\n\"                       to initialize the device with an external program,\\n\"\n\"                       e.g. xawtv, spcaview, and hope they persist when x11vnc\\n\"\n\"                       re-opens the device.\\n\"\n\"\\n\"\n\"                       <settings> is a comma separated list of key=value pairs.\\n\"\n\"                       The device's brightness, color, contrast, and hue can\\n\"\n\"                       be set to percentages, e.g. br=80,co=50,cn=44,hu=60.\\n\"\n\"\\n\"\n\"                       The device filename can be set too if needed (if it\\n\"\n\"                       does not start with \\\"video\\\"), e.g. fn=/dev/qcam.\\n\"\n\"\\n\"\n\"                       The width, height and bpp of the framebuffer can be\\n\"\n\"                       set via, e.g., w=160,h=120,bpp=16.\\n\"\n\"\\n\"\n\"                       Related to the bpp above, the pixel format can be set\\n\"\n\"                       via the fmt=XXX, where XXX can be one of: GREY, HI240,\\n\"\n\"                       RGB555, RGB565, RGB24, and RGB32 (with bpp 8, 8, 16, 16,\\n\"\n\"                       24, and 32 respectively).  See http://www.linuxtv.org\\n\"\n\"                       for more info (V4L api).\\n\"\n\"\\n\"\n\"                       For TV/rf tuner cards one can set the tuning mode\\n\"\n\"                       via tun=XXX where XXX can be one of PAL, NTSC, SECAM,\\n\"\n\"                       or AUTO.\\n\"\n\"\\n\"\n\"                       One can switch the input channel by the inp=XXX setting,\\n\"\n\"                       where XXX is the name of the input channel (Television,\\n\"\n\"                       Composite1, S-Video, etc).  Use the name that is in the\\n\"\n\"                       information about the device that is printed at startup.\\n\"\n\"\\n\"\n\"                       For input channels with tuners (e.g. Television) one\\n\"\n\"                       can change which station is selected by the sta=XXX\\n\"\n\"                       setting.  XXX is the station number.  Currently only\\n\"\n\"                       the ntsc-cable-us (US cable) channels are built into\\n\"\n\"                       x11vnc.  See the -freqtab option below to supply one\\n\"\n\"                       from xawtv. If XXX is greater than 500, then it is\\n\"\n\"                       interpreted as a raw frequency in KHz.\\n\"\n\"\\n\"\n\"                       Example:\\n\"\n\"\\n\"\n\"                       -rawfb video:br=80,w=320,h=240,fmt=RGB32,tun=NTSC,sta=47\\n\"\n\"\\n\"\n\"                       one might need to add inp=Television too for the input\\n\"\n\"                       channel to be TV if the card doesn't come up by default\\n\"\n\"                       in that one.\\n\"\n\"\\n\"\n\"                       Note that not all video capture devices will support\\n\"\n\"                       all of the above settings.\\n\"\n\"\\n\"\n\"                       See the -pipeinput VID option below for a way to control\\n\"\n\"                       the settings through the VNC Viewer via keystrokes.\\n\"\n\"                       As a shortcut, if the string begins \\\"Video..\\\" instead\\n\"\n\"                       of \\\"video..\\\" then -pipeinput VID is implied.\\n\"\n\"\\n\"\n\"                       As above, if you specify a \\\"@WxHxB...\\\" after the\\n\"\n\"                       <settings> string they are used verbatim: the device\\n\"\n\"                       is not queried for the current values.  Otherwise the\\n\"\n\"                       device will be queried.\\n\"\n\"\\n\"\n\"                       LINUX CONSOLE:  The following describes some ways to\\n\"\n\"                       view and possibly interact with the Linux text/graphics\\n\"\n\"                       console (i.e. not X11 XFree86/Xorg)\\n\"\n\"\\n\"\n\"                       Note: If the LibVNCServer LinuxVNC program is on your\\n\"\n\"                       system you may want to use that instead of the following\\n\"\n\"                       method because it will be faster and more accurate\\n\"\n\"                       for the Linux text console and includes mouse support.\\n\"\n\"                       There is, however, the basic LinuxVNC functionality in\\n\"\n\"                       x11vnc if you replace \\\"console\\\" with \\\"vt\\\" in the\\n\"\n\"                       examples below.\\n\"\n\"\\n\"\n\"                       If the rawfb string begins with \\\"console\\\" the\\n\"\n\"                       framebuffer device /dev/fb0 is opened and /dev/tty0 is\\n\"\n\"                       opened too.  The latter is used to inject keystrokes\\n\"\n\"                       (not all are supported, but the basic ones are).\\n\"\n\"                       You will need to be root to inject keystrokes, but\\n\"\n\"                       not necessarily to open /dev/fb0.  /dev/tty0 refers to\\n\"\n\"                       the active VT, to indicate one explicitly, use, e.g.,\\n\"\n\"                       \\\"console2\\\" for /dev/tty2, etc. by indicating the\\n\"\n\"                       specific VT number.\\n\"\n\"\\n\"\n\"                       For the Linux framebuffer device, /dev/fb0, (fb1,\\n\"\n\"                       etc) to be enabled the appropriate kernel drivers must\\n\"\n\"                       be loaded.  E.g. vesafb or vga16fb and also by setting\\n\"\n\"                       the boot parameter vga=0x301 (or 0x314, 0x317, etc.)\\n\"\n\"                       (The vga=... method is the preferred way; set your\\n\"\n\"                       machines up that way.)  Otherwise there will be a\\n\"\n\"                       'No such device' error.  You can also load a Linux\\n\"\n\"                       framebuffer driver specific to your make of video card\\n\"\n\"                       for more functionality.  Once the machine is booted one\\n\"\n\"                       can often 'modprobe' the fb driver as root to obtain\\n\"\n\"                       a framebuffer device.\\n\"\n\"\\n\"\n\"                       If you cannot get /dev/fb0 working on Linux, try\\n\"\n\"                       using the LinuxVNC emulation mode by \\\"-rawfb vtN\\\"\\n\"\n\"                       where N = 1, ... 6 is the Linux Virtual Terminal (aka\\n\"\n\"                       virtual console) you wish to view, e.g. \\\"-rawfb vt2\\\".\\n\"\n\"                       Unlike /dev/fb mode, it need not be the active Virtual\\n\"\n\"                       Terminal.  Note that this mode can only show text and\\n\"\n\"                       not graphics.  x11vnc polls the text in /dev/vcsaN\\n\"\n\"\\n\"\n\"                       Set the env. var. RAWFB_VCSA_BW=1 to disable colors in\\n\"\n\"                       the \\\"vtN\\\" mode (i.e. black and white only.)  If you\\n\"\n\"                       do not prefer the default 16bpp set RAWFB_VCSA_BPP to\\n\"\n\"                       8 or 32.  If you need to tweak the rawfb parameters by\\n\"\n\"                       using the 'console_guess' string printed at startup,\\n\"\n\"                       be sure to indicate the snap: method.\\n\"\n\"\\n\"\n\"                       uinput: If the Linux version appears to be 2.6\\n\"\n\"                       or later and the \\\"uinput\\\" module appears to be\\n\"\n\"                       present (modprobe uinput), then the uinput method\\n\"\n\"                       will be used instead of /dev/ttyN.  uinput allows\\n\"\n\"                       insertion of BOTH keystrokes and mouse input and so it\\n\"\n\"                       preferred when accessing graphical (e.g. QT-embedded)\\n\"\n\"                       linux console apps.  It also provides more accurate\\n\"\n\"                       keystroke insertion.  See -pipeinput UINPUT below for\\n\"\n\"                       more information on this mode; you will have to use\\n\"\n\"                       -pipeinput if you want to tweak any UINPUT parameters.\\n\"\n\"                       You may also want to also use the -nodragging and\\n\"\n\"                       -cursor none options.  Use \\\"console0\\\", etc  or\\n\"\n\"                       -pipeinput CONSOLE to force the /dev/ttyN method.\\n\"\n\"\\n\"\n\"                       Note you can change the Linux VT remotely using the\\n\"\n\"                       chvt(1) command to make the one you want be the active\\n\"\n\"                       one (e.g. 'chvt 3').  Sometimes switching out and back\\n\"\n\"                       corrects the framebuffer's graphics state.  For the\\n\"\n\"                       \\\"-rawfb vtN\\\" mode there is no need to switch the VT's.\\n\"\n\"\\n\"\n\"                       To skip input injecting entirely use \\\"consolex\\\"\\n\"\n\"                       or \\\"vtx\\\".\\n\"\n\"\\n\"\n\"                       The string \\\"/dev/fb0\\\" (1, etc.) can be used instead\\n\"\n\"                       of \\\"console\\\".  This can be used to specify a different\\n\"\n\"                       framebuffer device, e.g. /dev/fb1.  As a shortcut the\\n\"\n\"                       \\\"/dev/\\\" can be dropped.  If the name is something\\n\"\n\"                       nonstandard, use \\\"console:/dev/foofb\\\"\\n\"\n\"\\n\"\n\"                       If you do not want x11vnc to guess the framebuffer's\\n\"\n\"                       WxHxB and masks automatically (sometimes the kernel\\n\"\n\"                       gives incorrect information), specify them with a @WxHxB\\n\"\n\"                       (and optional :R/G/B masks) at the end of the string.\\n\"\n\"\\n\"\n\"                       Examples:\\n\"\n\"                           -rawfb console\\n\"\n\"                           -rawfb /dev/fb0           (same)\\n\"\n\"                           -rawfb console3           (force /dev/tty3)\\n\"\n\"                           -rawfb consolex           (no keystrokes or mouse)\\n\"\n\"                           -rawfb console:/dev/nonstd\\n\"\n\"                           -rawfb console -pipeinput UINPUT:accel=4.0\\n\"\n\"                           -rawfb vt3                (/dev/tty3 w/o /dev/fb0)\\n\"\n\"\\n\"\n\"                       VNC HOST: if the -rawfb string is of the form\\n\"\n\"                       \\\"vnc:host:N\\\" then the VNC display \\\"N\\\" on the remote\\n\"\n\"                       VNC server \\\"host\\\" is connected to (i.e. x11vnc acts as\\n\"\n\"                       a VNC client itself) and that framebuffer is exported.\\n\"\n\"\\n\"\n\"                       This mode is really only of use if you are trying\\n\"\n\"                       to improve performance in the case of many (e.g. >\\n\"\n\"                       10) simultaneous VNC viewers, and you try a divide\\n\"\n\"                       and conquer scheme to reduce bandwidth and improve\\n\"\n\"                       responsiveness.  (However, another user found this mode\\n\"\n\"                       useful to export a demo display through a slow link:\\n\"\n\"                       then multiple demo viewers connected to the reflecting\\n\"\n\"                       x11vnc on the fast side of the link, and so avoided\\n\"\n\"                       all of the demo viewers going through the slow link.)\\n\"\n\"\\n\"\n\"                       For example, if there will be 64 simultaneous VNC\\n\"\n\"                       viewers this can lead to a lot of redundant VNC traffic\\n\"\n\"                       to and from the server host:N, extra CPU usage,\\n\"\n\"                       and all viewers response can be reduced by having\\n\"\n\"                       to wait for writes to the slowest client to finish.\\n\"\n\"                       However, if you set up 8 reflectors/repeaters started\\n\"\n\"                       with option -rawfb vnc:host:N, then there are only\\n\"\n\"                       8 connections to host:N.  Each repeater then handles\\n\"\n\"                       8 vnc viewer connections thereby spreading the load\\n\"\n\"                       around.  In classroom broadcast usage, try to put the\\n\"\n\"                       repeaters on different switches.  This mode is the same\\n\"\n\"                       as -reflect host:N.  Replace \\\"host:N\\\" by \\\"listen\\\"\\n\"\n\"                       or \\\"listen:port\\\" for a reverse connection.\\n\"\n\"\\n\"\n\"                       Overall performance will not be as good as a single\\n\"\n\"                       direct connection because, among other things,\\n\"\n\"                       there is an additional level of framebuffer polling\\n\"\n\"                       and pointer motion can still induce many changes per\\n\"\n\"                       second that must be propagated.  Tip: if the remote VNC\\n\"\n\"                       is x11vnc doing wireframing, or an X display that does\\n\"\n\"                       wireframing that gives much better response than opaque\\n\"\n\"                       window dragging.  Consider the -nodragging option if\\n\"\n\"                       the problem is severe.\\n\"\n\"\\n\"\n\"                       The env. var. X11VNC_REFLECT_PASSWORD can be set to\\n\"\n\"                       the password needed to log into the vnc host server, or\\n\"\n\"                       to \\\"file:path_to_file\\\" to indicate a file containing\\n\"\n\"                       the password as its first line.\\n\"\n\"\\n\"\n\"                       To set the pixel format that x11vnc requests as a VNC\\n\"\n\"                       CLIENT set the env. vars: X11VNC_REFLECT_bitsPerSample\\n\"\n\"                       X11VNC_REFLECT_samplesPerPixel, and\\n\"\n\"                       X11VNC_REFLECT_bytesPerPixel; the defaults are 8, 3, 4.\\n\"\n\"                       2, 3, 1 would give a low color mode.  See the function\\n\"\n\"                       rfbGetClient() in libvncclient for more info.\\n\"\n\"\\n\"\n\"                       The VNC HOST mode implies -shared.  Use -noshared as\\n\"\n\"                       a subsequent cmdline option to disable sharing.\\n\"\n\"\\n\"\n\"-freqtab file          For use with \\\"-rawfb video\\\" for TV tuner devices to\\n\"\n\"                       specify station frequencies.  Instead of using the built\\n\"\n\"                       in ntsc-cable-us mapping of station number to frequency,\\n\"\n\"                       use the data in file.  For stations that are not\\n\"\n\"                       numeric, e.g. SE20, they are placed above the highest\\n\"\n\"                       numbered station in the order they are found.  Example:\\n\"\n\"                       \\\"-freqtab /usr/X11R6/share/xawtv/europe-west.list\\\"\\n\"\n\"                       You can make your own freqtab by copying the xawtv\\n\"\n\"                       format.\\n\"\n\"\\n\"\n\"-pipeinput cmd         This option lets you supply an external command in\\n\"\n\"                       \\\"cmd\\\" that x11vnc will pipe all of the user input\\n\"\n\"                       events to in a simple format.  In -pipeinput mode by\\n\"\n\"                       default x11vnc will not process any of the user input\\n\"\n\"                       events.  If you prefix \\\"cmd\\\" with \\\"tee:\\\" it will\\n\"\n\"                       both send them to the pipe command and process them.\\n\"\n\"                       For a description of the format run \\\"-pipeinput\\n\"\n\"                       tee:/bin/cat\\\".  Another prefix is \\\"reopen\\\" which\\n\"\n\"                       means to reopen pipe if it exits.  Separate multiple\\n\"\n\"                       prefixes with commas.\\n\"\n\"\\n\"\n\"                       In combination with -rawfb one might be able to\\n\"\n\"                       do amusing things (e.g. control non-X devices).\\n\"\n\"                       To facilitate this, if -rawfb is in effect then the\\n\"\n\"                       value is stored in X11VNC_RAWFB_STR for the pipe command\\n\"\n\"                       to use if it wants. Do 'env | grep X11VNC' for more.\\n\"\n\"\\n\"\n\"                       Built-in pipeinput modes (no external program required):\\n\"\n\"\\n\"\n\"                       If cmd is \\\"VID\\\" and you are using the -rawfb for a\\n\"\n\"                       video capture device, then an internal list of keyboard\\n\"\n\"                       mappings is used to set parameters of the video.\\n\"\n\"                       The mappings are:\\n\"\n\"\\n\"\n\"                         \\\"B\\\" and \\\"b\\\" adjust the brightness up and down.\\n\"\n\"                         \\\"H\\\" and \\\"h\\\" adjust the hue.\\n\"\n\"                         \\\"C\\\" and \\\"c\\\" adjust the colour.\\n\"\n\"                         \\\"N\\\" and \\\"n\\\" adjust the contrast.\\n\"\n\"                         \\\"S\\\" and \\\"s\\\" adjust the size of the capture screen.\\n\"\n\"                         \\\"I\\\" and \\\"i\\\" cycle through input channels.\\n\"\n\"                         Up and Down arrows adjust the station (if a tuner)\\n\"\n\"                         F1, F2, ..., F6 will switch the video capture pixel\\n\"\n\"                         format to HI240, RGB565, RGB24, RGB32, RGB555, and\\n\"\n\"                         GREY respectively.  See -rawfb video for details.\\n\"\n\"\\n\"\n\"                       If cmd is \\\"CONSOLE\\\" or \\\"CONSOLEn\\\" where n\\n\"\n\"                       is a Linux console number, then the linux console\\n\"\n\"                       keystroke insertion to /dev/ttyN (see -rawfb console)\\n\"\n\"                       is performed.\\n\"\n\"\\n\"\n\"                       If cmd begins with \\\"UINPUT\\\" then the Linux uinput\\n\"\n\"                       module is used to insert both keystroke and mouse events\\n\"\n\"                       to the Linux console (see -rawfb above).  This usually\\n\"\n\"                       is the /dev/input/uinput device file (you may need to\\n\"\n\"                       create it with \\\"mknod /dev/input/uinput c 10 223\\\"\\n\"\n\"                       and insert the module with \\\"modprobe uinput\\\".\\n\"\n\"\\n\"\n\"                       The UINPUT mode currently only does US keyboards (a\\n\"\n\"                       scan code option may be added), and not all keysyms\\n\"\n\"                       are supported.  But it is probably more accurate than\\n\"\n\"                       the \\\"CONSOLE\\\" method.\\n\"\n\"\\n\"\n\"                       You may want to use the options -cursor none and\\n\"\n\"                       -nodragging in this mode.\\n\"\n\"\\n\"\n\"                       Additional tuning options may be supplied via:\\n\"\n\"                       UINPUT:opt1,opt2,... (a comma separated list). If an\\n\"\n\"                       option begins with \\\"/\\\" it is taken as the uinput\\n\"\n\"                       device file.\\n\"\n\"                       \\n\"\n\"                       Which uinput is injected can be controlled by an option\\n\"\n\"                       string made of the characters \\\"K\\\", \\\"M\\\", and \\\"B\\\"\\n\"\n\"                       (see the -input option), e.g. \\\"KM\\\" allows keystroke\\n\"\n\"                       and motion but not button clicks.\\n\"\n\"\\n\"\n\"                       A UINPUT option of the form: accel=f, or accel=fx+fy\\n\"\n\"                       sets the mouse motion \\\"acceleration\\\".  This is used\\n\"\n\"                       to correct raw mouse relative motion into how much the\\n\"\n\"                       application cursor moves (x11vnc has no control over,\\n\"\n\"                       or knowledge of how the windowing application interprets\\n\"\n\"                       the raw mouse motions).  Typically the acceleration\\n\"\n\"                       for an X display is 2 (see xset \\\"m\\\" option).  \\\"f\\\"\\n\"\n\"                       is a floating point number, e.g. 3.0.  Use \\\"fx+fy\\\"\\n\"\n\"                       if you need to supply different corrections for x and y.\\n\"\n\"\\n\"\n\"                       Note: the default acceleration is 2.0 since it seems\\n\"\n\"                       both X and qt-embedded often (but not always) use\\n\"\n\"                       this value.\\n\"\n\"\\n\"\n\"                       Even with a correct accel setting the mouse position\\n\"\n\"                       will get out of sync (probably due to a mouse\\n\"\n\"                       \\\"threshold\\\" setting where the acceleration doe not\\n\"\n\"                       apply, set xset(1)).  The option reset=N sets the\\n\"\n\"                       number of ms (default 150) after which the cursor is\\n\"\n\"                       attempted to be reset (by forcing the mouse to (0,\\n\"\n\"                       0) via small increments and then back out to (x, y)\\n\"\n\"                       in 1 jump), This correction seems to be needed but can\\n\"\n\"                       cause jerkiness or unexpected behavior with menus, etc.\\n\"\n\"                       Use reset=0 to disable.\\n\"\n\"\\n\"\n\"                       If you set the env. var X11VNC_UINPUT_THRESHOLDS then\\n\"\n\"                       the thresh=n mode will be enabled.  It is currently\\n\"\n\"                       not working well.  If |dx| <= thresh and |dy| < thresh\\n\"\n\"                       no acceleration is applied.  Use \\\"thresh=+n\\\" |dx| +\\n\"\n\"                       |dy| < thresh to be used instead (X11?)\\n\"\n\"\\n\"\n\"                       Example:\\n\"\n\"                           -pipeinput UINPUT:accel=4.0 -cursor none\\n\"\n\"\\n\"\n\"                       If the uinput device has an absolute pointer (as opposed\\n\"\n\"                       to a normal mouse that is a relative pointer) you can\\n\"\n\"                       specify the option \\\"abs\\\".  Note that a touchpad\\n\"\n\"                       on a laptop is an absolute device to some degree.\\n\"\n\"                       This (usually) avoids all the problems with mouse\\n\"\n\"                       acceleration.  If x11vnc has trouble deducing the\\n\"\n\"                       size of the device, use \\\"abs=WxH\\\".  Furthermore,\\n\"\n\"                       if the device is a touchscreen (assumed to have an\\n\"\n\"                       absolute pointer) use \\\"touch\\\" or \\\"touch=WxH\\\".\\n\"\n\"                       For touchscreens, when a mouse button is pressed,\\n\"\n\"                       a pressure increase is injected, and when the button\\n\"\n\"                       is released a pressure of zero is injected.\\n\"\n\"\\n\"\n\"                       If touch has been set, use \\\"touch_always=1\\\" to\\n\"\n\"                       indicate whenever the mouse moves with no button\\n\"\n\"                       pressed, a touch event of zero pressure should be\\n\"\n\"                       sent anyway.  Also use \\\"btn_touch=1\\\" to indicate a\\n\"\n\"                       BTN_TOUCH keystroke press or release should be sent\\n\"\n\"                       instead of a pressure change.  Set \\\"dragskip=n\\\" to\\n\"\n\"                       skip n dragged mouse touches (with pressure applied)\\n\"\n\"                       before injecting one.  To indicate the pressure that\\n\"\n\"                       should be sent when there is a button click for a\\n\"\n\"                       touchscreen device, specify pressure=n, e.g. n=5. The\\n\"\n\"                       default is n=1.\\n\"\n\"\\n\"\n\"                       If a touch screen is being used (\\\"touch\\\" above)\\n\"\n\"                       and it is having its input processed by tslib, you can\\n\"\n\"                       specify the tslib calibration file via tslib_cal=<file>.\\n\"\n\"                       For example, tslib_cal=/etc/pointercal.  To get accurate\\n\"\n\"                       or even usable positioning this is required when tslib\\n\"\n\"                       is in use.\\n\"\n\"\\n\"\n\"                       The Linux uinput mechanism can be bypassed and one can\\n\"\n\"                       write input events DIRECTLY to the devices instead.\\n\"\n\"                       To do this, specify one or more of the following\\n\"\n\"                       for the input classes: direct_rel=<device>\\n\"\n\"                       direct_abs=<device> direct_btn=<device> or\\n\"\n\"                       direct_key=<device>.  The <device> file is usually\\n\"\n\"                       something like /dev/input/event1 but you can specify\\n\"\n\"                       any device file or pipe.  You must specify each one\\n\"\n\"                       of the above classes even if they correspond to the\\n\"\n\"                       same device file (rel/abs and btn are often the same.)\\n\"\n\"                       Look at the file /proc/bus/input/devices to get an idea\\n\"\n\"                       what is available and the device filenames.  Note:\\n\"\n\"                       The /dev/input/mouse* devices do not seem to work,\\n\"\n\"                       use the corresponding /dev/input/event* file instead.\\n\"\n\"                       Any input class not directly specified as above will be\\n\"\n\"                       handled via the uinput mechanism.  To disable creating a\\n\"\n\"                       uinput device (and thereby discarding unhandled input),\\n\"\n\"                       specify \\\"nouinput\\\".\\n\"\n\"\\n\"\n\"                       Examples:\\n\"\n\"\\n\"\n\"                         -pipeinput UINPUT:direct_abs=/dev/input/event1\\n\"\n\"\\n\"\n\"                       this was used on a qtmoko Neo freerunner (armel):\\n\"\n\"\\n\"\n\"                         -pipeinput UINPUT:touch,tslib_cal=/etc/pointercal,\\n\"\n\"                          direct_abs=/dev/input/event1,nouinput,dragskip=4\\n\"\n\"\\n\"\n\"                       (where the long line has been split into two.)\\n\"\n\"\\n\"\n\"                       You can set the env. var X11VNC_UINPUT_DEBUG=1 or higher\\n\"\n\"                       to get debugging output for UINPUT mode.\\n\"\n\"\\n\"\n\"-macnodim              For the native MacOSX server, disable dimming. \\n\"\n\"-macnosleep            For the native MacOSX server, disable display sleep.\\n\"\n\"-macnosaver            For the native MacOSX server, disable screensaver.\\n\"\n\"-macnowait             For the native MacOSX server, do not wait for the\\n\"\n\"                       user to switch back to his display.\\n\"\n\"-macwheel n            For the native MacOSX server, set the mouse wheel\\n\"\n\"                       speed to n (default 5).\\n\"\n\"-macnoswap             For the native MacOSX server, do not swap mouse\\n\"\n\"                       buttons 2 and 3.\\n\"\n\"-macnoresize           For the native MacOSX server, do not resize or reset\\n\"\n\"                       the framebuffer even if it is detected that the screen\\n\"\n\"                       resolution or depth has changed.\\n\"\n\"-maciconanim n         For the native MacOSX server, set n to the number\\n\"\n\"                       of milliseconds that the window iconify/deiconify\\n\"\n\"                       animation takes.  In -ncache mode this value will be\\n\"\n\"                       used to skip the animation if possible. (default 400)\\n\"\n\"-macmenu               For the native MacOSX server, in -ncache client-side\\n\"\n\"                       caching mode, try to cache pull down menus (not perfect\\n\"\n\"                       because they have animated fades, etc.)\\n\"\n\"-macuskbd              For the native MacOSX server, use the original\\n\"\n\"                       keystroke insertion code based on a US keyboard.\\n\"\n\"-macnoopengl           For the native MacOSX server, do not use OpenGL for\\n\"\n\"                       screen capture, but rather use the original, deprecated\\n\"\n\"                       raw memory access method: addr = CGDisplayBaseAddress().\\n\"\n\"-macnorawfb            For the native MacOSX server, disable the raw memory\\n\"\n\"                       address screen capture method.\\n\"\n\"\\n\"\n\"                       MACOSX NOTE: There are some deprecated MacOSX interfaces\\n\"\n\"                       to inject keyboard and mouse events and the raw memory\\n\"\n\"                       access method is deprecated as well (however, OpenGL\\n\"\n\"                       will be preferred if available because it is faster.)\\n\"\n\"                       One can force not using any deprecated interfaces at\\n\"\n\"                       compile time by setting -DX11VNC_MACOSX_NO_DEPRECATED=1\\n\"\n\"                       in CPPFLAGS.  Or to turn them off one by one:\\n\"\n\"                       -DX11VNC_MACOSX_NO_DEPRECATED_LOCALEVENTS=1,\\n\"\n\"                       -DX11VNC_MACOSX_NO_DEPRECATED_POSTEVENTS=1 or\\n\"\n\"                       -DX11VNC_MACOSX_NO_DEPRECATED_FRAMEBUFFER=1\\n\"\n\"                       At run time, for testing and workarounds, one can\\n\"\n\"                       disable them by using:\\n\"\n\"                       -env X11VNC_MACOSX_NO_DEPRECATED=1\\n\"\n\"                       -env X11VNC_MACOSX_NO_DEPRECATED_LOCALEVENTS=1\\n\"\n\"                       -env X11VNC_MACOSX_NO_DEPRECATED_POSTEVENTS=1 or\\n\"\n\"                       -env X11VNC_MACOSX_NO_DEPRECATED_FRAMEBUFFER=1\\n\"\n\"                       Note: When doing either of these for the mouse input\\n\"\n\"                       not everything works currently, e.g. double clicks and\\n\"\n\"                       wireframing.  Also, screen resolution and pixel depth\\n\"\n\"                       changes will not be automatically detected unless the\\n\"\n\"                       deprecated framebuffer interfaces are allowed.\\n\"\n\"\\n\"\n\"                       Conversely, if you are compiling on an\\n\"\n\"                       older machine that does not have some of\\n\"\n\"                       the newer interfaces, you may need to specify\\n\"\n\"                       -DX11VNC_MACOSX_NO_CGEVENTCREATESCROLLWHEELEVENT\\n\"\n\"                       -DX11VNC_MACOSX_NO_CGEVENTCREATEMOUSEEVENT or\\n\"\n\"                       -DX11VNC_MACOSX_NO_CGEVENTCREATEKEYBOARDEVENT.  Use\\n\"\n\"                       -DX11VNC_MACOSX_USE_GETMAINDEVICE to regain the very\\n\"\n\"                       old QuickDraw GetMainDevice() interface (rare...)\\n\"\n\"\\n\"\n\"-gui [gui-opts]        Start up a simple tcl/tk gui based on the remote\\n\"\n\"                       control options -remote/-query described below.\\n\"\n\"                       Requires the \\\"wish\\\" program to be installed on the\\n\"\n\"                       machine.  \\\"gui-opts\\\" is not required: the default\\n\"\n\"                       is to start up both the full gui and x11vnc with the\\n\"\n\"                       gui showing up on the X display in the environment\\n\"\n\"                       variable DISPLAY.\\n\"\n\"\\n\"\n\"                       \\\"gui-opts\\\" can be a comma separated list of items.\\n\"\n\"                       Currently there are these types of items: 1) a gui\\n\"\n\"                       mode, a 2) gui \\\"simplicity\\\", 3) the X display the\\n\"\n\"                       gui should display on, 4) a \\\"tray\\\" or \\\"icon\\\" mode,\\n\"\n\"                       and 5) a gui geometry.\\n\"\n\"\\n\"\n\"                       1) The gui mode can be \\\"start\\\", \\\"conn\\\", or \\\"wait\\\"\\n\"\n\"                       \\\"start\\\" is the default mode above and is not required.\\n\"\n\"                       \\\"conn\\\" means do not automatically start up x11vnc,\\n\"\n\"                       but instead just try to connect to an existing x11vnc\\n\"\n\"                       process.  \\\"wait\\\" means just start the gui and nothing\\n\"\n\"                       else (you will later instruct the gui to start x11vnc\\n\"\n\"                       or connect to an existing one.)\\n\"\n\"\\n\"\n\"                       2) The gui simplicity is off by default (a power-user\\n\"\n\"                       gui with all options is presented) To start with\\n\"\n\"                       something less daunting supply the string \\\"simple\\\"\\n\"\n\"                       (\\\"ez\\\" is an alias for this).  Once the gui is\\n\"\n\"                       started you can toggle between the two with \\\"Misc ->\\n\"\n\"                       simple_gui\\\".\\n\"\n\"\\n\"\n\"                       3) Note the possible confusion regarding the potentially\\n\"\n\"                       two different X displays: x11vnc polls one, but you\\n\"\n\"                       may want the gui to appear on another.  For example, if\\n\"\n\"                       you ssh in and x11vnc is not running yet you may want\\n\"\n\"                       the gui to come back to you via your ssh redirected X\\n\"\n\"                       display (e.g. localhost:10).\\n\"\n\"\\n\"\n\"                       If you do not specify a gui X display in \\\"gui-opts\\\"\\n\"\n\"                       then the DISPLAY environment variable and -display\\n\"\n\"                       option are tried (in that order).  Regarding the x11vnc\\n\"\n\"                       X display the gui will try to communication with, it\\n\"\n\"                       first tries -display and then DISPLAY.  For example,\\n\"\n\"                       \\\"x11vnc -display :0 -gui otherhost:0\\\", will remote\\n\"\n\"                       control an x11vnc polling :0 and display the gui on\\n\"\n\"                       otherhost:0 The \\\"tray/icon\\\" mode below reverses this\\n\"\n\"                       preference, preferring to display on the x11vnc display.\\n\"\n\"\\n\"\n\"                       4) When \\\"tray\\\" or \\\"icon\\\" is specified, the gui\\n\"\n\"                       presents itself as a small icon with behavior typical\\n\"\n\"                       of a \\\"system tray\\\" or \\\"dock applet\\\".  The color\\n\"\n\"                       of the icon indicates status (connected clients) and\\n\"\n\"                       there is also a balloon status.  Clicking on the icon\\n\"\n\"                       gives a menu from which properties, etc, can be set and\\n\"\n\"                       the full gui is available under \\\"Advanced\\\".  To be\\n\"\n\"                       fully functional, the gui mode should be \\\"start\\\"\\n\"\n\"                       (the default).\\n\"\n\"\\n\"\n\"                       Note that tray or icon mode will imply the -forever\\n\"\n\"                       x11vnc option (if the x11vnc server is started along\\n\"\n\"                       with the gui) unless -connect or -connect_or_exit has\\n\"\n\"                       been specified.  So x11vnc (and the tray/icon gui)\\n\"\n\"                       will wait for more connections after the first client\\n\"\n\"                       disconnects.  If you want only one viewer connection\\n\"\n\"                       include the -once option.\\n\"\n\"\\n\"\n\"                       For \\\"icon\\\" the gui just a small standalone window.\\n\"\n\"                       For \\\"tray\\\" it will attempt to embed itself in the\\n\"\n\"                       \\\"system tray\\\" if possible. If \\\"=setpass\\\" is appended then\\n\"\n\"                       at startup the X11 user will be prompted to set the\\n\"\n\"                       VNC session password.  If =<hexnumber> is appended\\n\"\n\"                       that icon will attempt to embed itself in the window\\n\"\n\"                       given by hexnumber.  Use =noadvanced to disable the\\n\"\n\"                       full gui. (To supply more than one, use \\\"+\\\" sign).\\n\"\n\"                       E.g. -gui tray=setpass and -gui icon=0x3600028\\n\"\n\"\\n\"\n\"                       Other modes: \\\"full\\\", the default and need not be\\n\"\n\"                       specified.  \\\"-gui none\\\", do not show a gui, useful\\n\"\n\"                       to override a ~/.x11vncrc setting, etc.\\n\"\n\"\\n\"\n\"                       5) When \\\"geom=+X+Y\\\" is specified, that geometry\\n\"\n\"                       is passed to the gui toplevel.  This is the icon in\\n\"\n\"                       icon/tray mode, or the full gui otherwise.  You can\\n\"\n\"                       also specify width and height, i.e. WxH+X+Y, but it\\n\"\n\"                       is not recommended.  In \\\"tray\\\" mode the geometry is\\n\"\n\"                       ignored unless the system tray manager does not seem\\n\"\n\"                       to be running.  One could imagine using something like\\n\"\n\"                       \\\"-gui tray,geom=+4000+4000\\\" with a display manager\\n\"\n\"                       to keep the gui invisible until someone logs in...\\n\"\n\"\\n\"\n\"                       More icon tricks, \\\"icon=minimal\\\" gives an icon just\\n\"\n\"                       with the VNC display number.  You can also set the font\\n\"\n\"                       with \\\"iconfont=...\\\".  The following could be useful:\\n\"\n\"                       \\\"-gui icon=minimal,iconfont=5x8,geom=24x10+0-0\\\"\\n\"\n\"\\n\"\n\"                       General examples of the -gui option: \\\"x11vnc -gui\\\",\\n\"\n\"                       \\\"x11vnc -gui ez\\\" \\\"x11vnc -gui localhost:10\\\",\\n\"\n\"                       \\\"x11vnc -gui conn,host:0\\\", \\\"x11vnc -gui tray,ez\\\"\\n\"\n\"                       \\\"x11vnc -gui tray=setpass\\\"\\n\"\n\"\\n\"\n\"                       If you do not intend to start x11vnc from the gui\\n\"\n\"                       (i.e. just remote control an existing one), then the\\n\"\n\"                       gui process can run on a different machine from the\\n\"\n\"                       x11vnc server as long as X permissions, etc. permit\\n\"\n\"                       communication between the two.\\n\"\n\"\\n\"\n\"                       FONTS: On some systems the tk fonts can be too small,\\n\"\n\"                       jagged, or otherwise unreadable.  There are 4 env vars\\n\"\n\"                       you can set to be the tk font you prefer:\\n\"\n\"\\n\"\n\"                       X11VNC_FONT_BOLD   main font for menus and buttons.\\n\"\n\"                       X11VNC_FONT_FIXED  font for fixed width text.\\n\"\n\"\\n\"\n\"                       X11VNC_FONT_BOLD_SMALL  tray icon font.\\n\"\n\"                       X11VNC_FONT_REG_SMALL   tray icon menu font.\\n\"\n\"\\n\"\n\"                       The last two only apply for the tray icon mode.\\n\"\n\"\\n\"\n\"                       Here are some examples:\\n\"\n\"\\n\"\n\"                       -env X11VNC_FONT_BOLD='Helvetica -16 bold'\\n\"\n\"                       -env X11VNC_FONT_FIXED='Courier -14'\\n\"\n\"                       -env X11VNC_FONT_REG_SMALL='Helvetica -12'\\n\"\n\"\\n\"\n\"                       You can put the lines like the above (without the\\n\"\n\"                       quotes) in your ~/.x11vncrc file to avoid having to\\n\"\n\"                       specify them on the x11vnc command line.\\n\"\n\"\\n\"\n\"-remote command        Remotely control some aspects of an already running\\n\"\n\"                       x11vnc server.  \\\"-R\\\" and \\\"-r\\\" are aliases for\\n\"\n\"                       \\\"-remote\\\".  After the remote control command is\\n\"\n\"                       sent to the running server the 'x11vnc -remote ...'\\n\"\n\"                       x11vnc command exits.  You can often use the -query\\n\"\n\"                       command (see below) to see if the x11vnc server\\n\"\n\"                       processed your -remote command.\\n\"\n\"\\n\"\n\"                       The default communication channel is that of X\\n\"\n\"                       properties (specifically X11VNC_REMOTE), and so this\\n\"\n\"                       command must be run with correct settings for DISPLAY\\n\"\n\"                       and possibly XAUTHORITY to connect to the X server\\n\"\n\"                       and set the property.  Alternatively, use the -display\\n\"\n\"                       and -auth options to set them to the correct values.\\n\"\n\"                       The running server cannot use the -novncconnect option\\n\"\n\"                       because that disables the communication channel.\\n\"\n\"                       See below for alternate channels.\\n\"\n\"\\n\"\n\"                       For example: 'x11vnc -remote stop' (which is the same as\\n\"\n\"                       'x11vnc -R stop') will close down the x11vnc server.\\n\"\n\"                       'x11vnc -R shared' will enable shared connections, and\\n\"\n\"                       'x11vnc -R scale:3/4' will rescale the desktop.\\n\"\n\"\\n\"\n\"                       To use a different name for the X11 property (e.g. to\\n\"\n\"                       have separate communication channels for multiple\\n\"\n\"                       x11vnc's on the same display) set the X11VNC_REMOTE\\n\"\n\"                       environment variable to the string you want, for\\n\"\n\"                       example: -env X11VNC_REMOTE=X11VNC_REMOTE_12345\\n\"\n\"                       Both sides of the channel must use the same unique name.\\n\"\n\"\\n\"\n\"                       To run a bunch of commands in a sequence use something\\n\"\n\"                       like: x11vnc -R 'script:firstcmd;secondcmd;...'\\n\"\n\"\\n\"\n\"                       Use x11vnc -R script:file=/path/to/file to read commands\\n\"\n\"                       from a file (can be multi-line and use the comment '#'\\n\"\n\"                       character in the normal way.  The ';' separator must\\n\"\n\"                       still be used to separate each command.)\\n\"\n\"\\n\"\n\"                       To not try to contact another x11vnc process and instead\\n\"\n\"                       just run the command (or query) directly, prefix the\\n\"\n\"                       command with the string \\\"DIRECT:\\\"\\n\"\n\"\\n\"\n\"                       The following -remote/-R commands are supported:\\n\"\n\"\\n\"\n\"                       stop            terminate the server, same as \\\"quit\\\"\\n\"\n\"                                       \\\"exit\\\" or \\\"shutdown\\\".\\n\"\n\"                       ping            see if the x11vnc server responds.\\n\"\n\"                                       return is: ans=ping:<display>\\n\"\n\"                       ping:mystring   as above, but use your own unique string.\\n\"\n\"                                       return is: ans=ping:mystring:<xdisplay>\\n\"\n\"                       blacken         try to push a black fb update to all\\n\"\n\"                                       clients (due to timings a client\\n\"\n\"                                       could miss it). Same as \\\"zero\\\", also\\n\"\n\"                                       \\\"zero:x1,y1,x2,y2\\\" for a rectangle.\\n\"\n\"                       refresh         send the entire fb to all clients.\\n\"\n\"                       reset           recreate the fb, polling memory, etc.\\n\"\n/* ext. cmd. */\n\"                       id:windowid     set -id window to \\\"windowid\\\". empty\\n\"\n\"                                       or \\\"root\\\" to go back to root window\\n\"\n\"                       sid:windowid    set -sid window to \\\"windowid\\\"\\n\"\n\"                       id_cmd:cmd      cmds: raise, lower, map, unmap, iconify,\\n\"\n\"                                       move:dXdY, resize:dWdH, geom:WxH+X+Y. dX\\n\"\n\"                                       dY, dW, and dH must have a leading \\\"+\\\"\\n\"\n\"                                       or \\\"-\\\" e.g.: move:-30+10 resize:+20+35\\n\"\n\"                                       also: wm_delete, wm_name:string and\\n\"\n\"                                       icon_name:string. Also id_cmd:win=N:cmd\\n\"\n\"                       waitmapped      wait until subwin is mapped.\\n\"\n\"                       nowaitmapped    do not wait until subwin is mapped.\\n\"\n\"                       clip:WxH+X+Y    set -clip mode to \\\"WxH+X+Y\\\"\\n\"\n\"                       flashcmap       enable  -flashcmap mode.\\n\"\n\"                       noflashcmap     disable -flashcmap mode.\\n\"\n\"                       shiftcmap:n     set -shiftcmap to n.\\n\"\n\"                       notruecolor     enable  -notruecolor mode.\\n\"\n\"                       truecolor       disable -notruecolor mode.\\n\"\n\"                       overlay         enable  -overlay mode (if applicable).\\n\"\n\"                       nooverlay       disable -overlay mode.\\n\"\n\"                       overlay_cursor  in -overlay mode, enable cursor drawing.\\n\"\n\"                       overlay_nocursor disable cursor drawing. same as\\n\"\n\"                                        nooverlay_cursor.\\n\"\n\"                       8to24           enable  -8to24 mode (if applicable).\\n\"\n\"                       no8to24         disable -8to24 mode.\\n\"\n\"                       8to24_opts:str  set the -8to24 opts to \\\"str\\\".\\n\"\n\"                       24to32          enable  -24to32 mode (if applicable).\\n\"\n\"                       no24to32        disable -24to32 mode.\\n\"\n\"                       visual:vis      set -visual to \\\"vis\\\"\\n\"\n\"                       scale:frac      set -scale to \\\"frac\\\"\\n\"\n\"                       scale_cursor:f  set -scale_cursor to \\\"f\\\"\\n\"\n\"                       viewonly        enable  -viewonly mode.\\n\"\n/* access view,share,forever */\n\"                       noviewonly      disable -viewonly mode.\\n\"\n\"                       shared          enable  -shared mode.\\n\"\n\"                       noshared        disable -shared mode.\\n\"\n\"                       forever         enable  -forever mode.\\n\"\n\"                       noforever       disable -forever mode.\\n\"\n\"                       timeout:n       reset -timeout to n, if there are\\n\"\n\"                                       currently no clients, exit unless one\\n\"\n\"                                       connects in the next n secs.\\n\"\n\"                       tightfilexfer   enable  filetransfer for NEW clients.\\n\"\n\"                       notightfilexfer disable filetransfer for NEW clients.\\n\"\n\"                       ultrafilexfer   enable  filetransfer for clients.\\n\"\n\"                       noultrafilexfer disable filetransfer for clients.\\n\"\n\"                       rfbversion:n.m  set -rfbversion for new clients.\\n\"\n/* access */\n\"                       http            enable  http client connections.\\n\"\n\"                       nohttp          disable http client connections.\\n\"\n\"                       deny            deny any new connections, same as \\\"lock\\\"\\n\"\n\"                       nodeny          allow new connections, same as \\\"unlock\\\"\\n\"\n\"                       avahi           enable  avahi service advertising.\\n\"\n\"                       noavahi         disable avahi service advertising.\\n\"\n\"                       mdns            enable  avahi service advertising.\\n\"\n\"                       nomdns          disable avahi service advertising.\\n\"\n\"                       zeroconf        enable  avahi service advertising.\\n\"\n\"                       nozeroconf      disable avahi service advertising.\\n\"\n/* access, filename */\n\"                       connect:host    do reverse connection to host, \\\"host\\\"\\n\"\n\"                                       may be a comma separated list of hosts\\n\"\n\"                                       or host:ports.  See -connect.  Passwords\\n\"\n\"                                       required as with fwd connections.\\n\"\n\"                                       See X11VNC_REVERSE_CONNECTION_NO_AUTH=1\\n\"\n\"                       disconnect:host disconnect any clients from \\\"host\\\"\\n\"\n\"                                       same as \\\"close:host\\\".  Use host\\n\"\n\"                                       \\\"all\\\" to close all current clients.\\n\"\n\"                                       If you know the client internal hex ID,\\n\"\n\"                                       e.g. 0x3 (returned by \\\"-query clients\\\"\\n\"\n\"                                       and RFB_CLIENT_ID) you can use that too.\\n\"\n\"                       proxy:host:port set reverse connection proxy (empty to\\n\"\n\"                                       disable).\\n\"\n/* access */\n\"                       allowonce:host  For the next connection only, allow\\n\"\n\"                                       connection from \\\"host\\\". In -ssl mode\\n\"\n\"                                       two connections are allowed (i.e. Fetch\\n\"\n\"                                       Cert) unless X11VNC_NO_SSL_ALLOW_TWICE=1\\n\"\n/* access */\n\"                       allow:hostlist  set -allow list to (comma separated)\\n\"\n\"                                       \\\"hostlist\\\". See -allow and -localhost.\\n\"\n\"                                       Do not use with -allow /path/to/file\\n\"\n\"                                       Use \\\"+host\\\" to add a single host, and\\n\"\n\"                                       use \\\"-host\\\" to delete a single host\\n\"\n\"                       localhost       enable  -localhost mode\\n\"\n\"                       nolocalhost     disable -localhost mode\\n\"\n\"                       listen:str      set -listen to str, empty to disable.\\n\"\n\"                       noipv6          enable  -noipv6 mode.\\n\"\n\"                       ipv6            disable -noipv6 mode.\\n\"\n\"                       noipv4          enable  -noipv4 mode.\\n\"\n\"                       ipv4            disable -noipv4 mode.\\n\"\n\"                       6               enable  -6 IPv6 listening mode.\\n\"\n\"                       no6             disable -6 IPv6 listening mode.\\n\"\n\"                       lookup          disable -nolookup mode.\\n\"\n\"                       nolookup        enable  -nolookup mode.\\n\"\n\"                       lookup          disable -nolookup mode.\\n\"\n\"                       input:str       set -input to \\\"str\\\", empty to disable.\\n\"\n\"                       grabkbd         enable  -grabkbd mode.\\n\"\n\"                       nograbkbd       disable -grabkbd mode.\\n\"\n\"                       grabptr         enable  -grabptr mode.\\n\"\n\"                       nograbptr       disable -grabptr mode.\\n\"\n\"                       grabalways      enable  -grabalways mode.\\n\"\n\"                       nograbalways    disable -grabalways mode.\\n\"\n\"                       grablocal:n     set -grablocal to n.\\n\"\n\"                       client_input:str set the K, M, B -input on a per-client\\n\"\n\"                                       basis.  select which client as for\\n\"\n\"                                       disconnect, e.g. client_input:host:MB\\n\"\n\"                                       or client_input:0x2:K\\n\"\n/* ext. cmd. */\n\"                       accept:cmd      set -accept \\\"cmd\\\" (empty to disable).\\n\"\n\"                       afteraccept:cmd set -afteraccept (empty to disable).\\n\"\n\"                       gone:cmd        set -gone \\\"cmd\\\" (empty to disable).\\n\"\n\"                       noshm           enable  -noshm mode.\\n\"\n\"                       shm             disable -noshm mode (i.e. use shm).\\n\"\n\"                       flipbyteorder   enable -flipbyteorder mode, you may need\\n\"\n\"                                       to set noshm for this to do something.\\n\"\n\"                       noflipbyteorder disable -flipbyteorder mode.\\n\"\n\"                       onetile         enable  -onetile mode. (you may need to\\n\"\n\"                                       set shm for this to do something)\\n\"\n\"                       noonetile       disable -onetile mode.\\n\"\n/* ext. cmd. */\n\"                       solid           enable  -solid mode\\n\"\n\"                       nosolid         disable -solid mode.\\n\"\n\"                       solid_color:color set -solid color (and apply it).\\n\"\n\"                       blackout:str    set -blackout \\\"str\\\" (empty to disable).\\n\"\n\"                                       See -blackout for the form of \\\"str\\\"\\n\"\n\"                                       (basically: WxH+X+Y,...)\\n\"\n\"                                       Use \\\"+WxH+X+Y\\\" to append a single\\n\"\n\"                                       rectangle use \\\"-WxH+X+Y\\\" to delete one\\n\"\n\"                       xinerama        enable  -xinerama mode. (if applicable)\\n\"\n\"                       noxinerama      disable -xinerama mode.\\n\"\n\"                       xtrap           enable  -xtrap input mode(if applicable)\\n\"\n\"                       noxtrap         disable -xtrap input mode.\\n\"\n\"                       xrandr          enable  -xrandr mode. (if applicable)\\n\"\n\"                       noxrandr        disable -xrandr mode.\\n\"\n\"                       xrandr_mode:mode set the -xrandr mode to \\\"mode\\\".\\n\"\n\"                       rotate:mode     set the -rotate mode to \\\"mode\\\".\\n\"\n\"                       padgeom:WxH     set -padgeom to WxH (empty to disable)\\n\"\n\"                                       If WxH is \\\"force\\\" or \\\"do\\\" the padded\\n\"\n\"                                       geometry fb is immediately applied.\\n\"\n\"                       quiet           enable  -quiet mode.\\n\"\n\"                       noquiet         disable -quiet mode.\\n\"\n\"                       modtweak        enable  -modtweak mode.\\n\"\n\"                       nomodtweak      enable  -nomodtweak mode.\\n\"\n\"                       xkb             enable  -xkb modtweak mode.\\n\"\n\"                       noxkb           disable -xkb modtweak mode.\\n\"\n\"                       capslock        enable  -capslock mode.\\n\"\n\"                       nocapslock      disable -capslock mode.\\n\"\n\"                       skip_lockkeys   enable  -skip_lockkeys mode.\\n\"\n\"                       noskip_lockkeys disable -skip_lockkeys mode.\\n\"\n\"                       skip_keycodes:str enable -xkb -skip_keycodes \\\"str\\\".\\n\"\n\"                       sloppy_keys     enable  -sloppy_keys mode.\\n\"\n\"                       nosloppy_keys   disable -sloppy_keys mode.\\n\"\n\"                       skip_dups       enable  -skip_dups mode.\\n\"\n\"                       noskip_dups     disable -skip_dups mode.\\n\"\n\"                       add_keysyms     enable -add_keysyms mode.\\n\"\n\"                       noadd_keysyms   stop adding keysyms. those added will\\n\"\n\"                                       still be removed at exit.\\n\"\n\"                       clear_mods      enable  -clear_mods mode and clear them.\\n\"\n\"                       noclear_mods    disable -clear_mods mode.\\n\"\n\"                       clear_keys      enable  -clear_keys mode and clear them.\\n\"\n\"                       noclear_keys    disable -clear_keys mode.\\n\"\n\"                       clear_locks     do the clear_locks action.\\n\"\n\"                       clear_all       do the clear_all action.\\n\"\n\"                       keystate        have x11vnc print current keystate.\\n\"\n/* filename */\n\"                       remap:str       set -remap \\\"str\\\" (empty to disable).\\n\"\n\"                                       See -remap for the form of \\\"str\\\"\\n\"\n\"                                       (basically: key1-key2,key3-key4,...)\\n\"\n\"                                       Use \\\"+key1-key2\\\" to append a single\\n\"\n\"                                       keymapping, use \\\"-key1-key2\\\" to delete.\\n\"\n\"                       norepeat        enable  -norepeat mode.\\n\"\n\"                       repeat          disable -norepeat mode.\\n\"\n\"                       nofb            enable  -nofb mode.\\n\"\n\"                       fb              disable -nofb mode.\\n\"\n\"                       bell            enable  bell (if supported).\\n\"\n\"                       nobell          disable bell.\\n\"\n\"                       sendbell        ring the bell now.\\n\"\n\"                       nosel           enable  -nosel mode.\\n\"\n\"                       sel             disable -nosel mode.\\n\"\n\"                       noprimary       enable  -noprimary mode.\\n\"\n\"                       primary         disable -noprimary mode.\\n\"\n\"                       nosetprimary    enable  -nosetprimary mode.\\n\"\n\"                       setprimary      disable -nosetprimary mode.\\n\"\n\"                       noclipboard     enable  -noclipboard mode.\\n\"\n\"                       clipboard       disable -noclipboard mode.\\n\"\n\"                       nosetclipboard  enable  -nosetclipboard mode.\\n\"\n\"                       setclipboard    disable -nosetclipboard mode.\\n\"\n\"                       seldir:str      set -seldir to \\\"str\\\"\\n\"\n\"                       resend_cutbuffer resend the most recent CUTBUFFER0 copy\\n\"\n\"                       resend_clipboard resend the most recent CLIPBOARD copy\\n\"\n\"                       resend_primary   resend the most recent PRIMARY copy\\n\"\n\"                       cursor:mode     enable  -cursor \\\"mode\\\".\\n\"\n\"                       show_cursor     enable  showing a cursor.\\n\"\n\"                       noshow_cursor   disable showing a cursor. (same as\\n\"\n\"                                       \\\"nocursor\\\")\\n\"\n\"                       cursor_drag     enable  cursor changes during drag.\\n\"\n\"                       nocursor_drag   disable cursor changes during drag.\\n\"\n\"                       arrow:n         set -arrow to alternate n.\\n\"\n\"                       xfixes          enable  xfixes cursor shape mode.\\n\"\n\"                       noxfixes        disable xfixes cursor shape mode.\\n\"\n\"                       alphacut:n      set -alphacut to n.\\n\"\n\"                       alphafrac:f     set -alphafrac to f.\\n\"\n\"                       alpharemove     enable  -alpharemove mode.\\n\"\n\"                       noalpharemove   disable -alpharemove mode.\\n\"\n\"                       alphablend      disable -noalphablend mode.\\n\"\n\"                       noalphablend    enable  -noalphablend mode.\\n\"\n\"                       cursorshape     disable -nocursorshape mode.\\n\"\n\"                       nocursorshape   enable  -nocursorshape mode.\\n\"\n\"                       cursorpos       disable -nocursorpos mode.\\n\"\n\"                       nocursorpos     enable  -nocursorpos mode.\\n\"\n\"                       xwarp           enable  -xwarppointer mode.\\n\"\n\"                       noxwarp         disable -xwarppointer mode.\\n\"\n\"                       always_inject   enable  -always_inject mode.\\n\"\n\"                       noalways_inject disable -always_inject mode.\\n\"\n\"                       buttonmap:str   set -buttonmap \\\"str\\\", empty to disable\\n\"\n\"                       dragging        disable -nodragging mode.\\n\"\n\"                       nodragging      enable  -nodragging mode.\\n\"\n\"                       ncache          reenable -ncache mode.\\n\"\n\"                       noncache        disable  -ncache mode.\\n\"\n\"                       ncache_size:n   set -ncache size to n.\\n\"\n\"                       ncache_cr       enable  -ncache_cr mode.\\n\"\n\"                       noncache_cr     disable -ncache_cr mode.\\n\"\n\"                       ncache_no_moveraise     enable  no_moveraise mode.\\n\"\n\"                       noncache_no_moveraise   disable no_moveraise mode.\\n\"\n\"                       ncache_no_dtchange      enable  ncache_no_dtchange mode.\\n\"\n\"                       noncache_no_dtchange    disable ncache_no_dtchange mode.\\n\"\n\"                       ncache_old_wm           enable  ncache_old_wm mode.\\n\"\n\"                       noncache_old_wm         disable ncache_old_wm mode.\\n\"\n\"                       ncache_no_rootpixmap    enable  ncache_no_rootpixmap.\\n\"\n\"                       noncache_no_rootpixmap  disable ncache_no_rootpixmap.\\n\"\n\"                       ncache_reset_rootpixmap recheck the root pixmap, ncrp\\n\"\n\"                       ncache_keep_anims       enable  ncache_keep_anims.\\n\"\n\"                       noncache_keep_anims     disable ncache_keep_anims.\\n\"\n\"                       ncache_pad:n    set -ncache_pad to n.\\n\"\n\"                       wireframe       enable  -wireframe mode. same as \\\"wf\\\"\\n\"\n\"                       nowireframe     disable -wireframe mode. same as \\\"nowf\\\"\\n\"\n\"                       wireframe:str   enable  -wireframe mode string.\\n\"\n\"                       wireframe_mode:str enable  -wireframe mode string.\\n\"\n\"                       wireframelocal  enable  wireframelocal. same as \\\"wfl\\\"\\n\"\n\"                       nowireframe     disable wireframelocal. same as \\\"nowfl\\\"\\n\"\n\"                       wirecopyrect:str set -wirecopyrect string. same as \\\"wcr:\\\"\\n\"\n\"                       scrollcopyrect:str set -scrollcopyrect string. same \\\"scr\\\"\\n\"\n\"                       noscrollcopyrect disable -scrollcopyrect mode. \\\"noscr\\\"\\n\"\n\"                       scr_area:n      set -scr_area to n\\n\"\n\"                       scr_skip:list   set -scr_skip to \\\"list\\\"\\n\"\n\"                       scr_inc:list    set -scr_inc to \\\"list\\\"\\n\"\n\"                       scr_keys:list   set -scr_keys to \\\"list\\\"\\n\"\n\"                       scr_term:list   set -scr_term to \\\"list\\\"\\n\"\n\"                       scr_keyrepeat:str set -scr_keyrepeat to \\\"str\\\"\\n\"\n\"                       scr_parms:str   set -scr_parms parameters.\\n\"\n\"                       fixscreen:str   set -fixscreen to \\\"str\\\".\\n\"\n\"                       noxrecord       disable all use of RECORD extension.\\n\"\n\"                       xrecord         enable  use of RECORD extension.\\n\"\n\"                       reset_record    reset RECORD extension (if avail.)\\n\"\n\"                       pointer_mode:n  set -pointer_mode to n. same as \\\"pm\\\"\\n\"\n\"                       input_skip:n    set -input_skip to n.\\n\"\n\"                       allinput        enable  use of -allinput mode.\\n\"\n\"                       noallinput      disable use of -allinput mode.\\n\"\n\"                       input_eagerly   enable  use of -input_eagerly mode.\\n\"\n\"                       noinput_eagerly disable use of -input_eagerly mode.\\n\"\n\"                       ssltimeout:n    set -ssltimeout to n.\\n\"\n\"                       speeds:str      set -speeds to str.\\n\"\n\"                       wmdt:str        set -wmdt to str.\\n\"\n\"                       debug_pointer   enable  -debug_pointer, same as \\\"dp\\\"\\n\"\n\"                       nodebug_pointer disable -debug_pointer, same as \\\"nodp\\\"\\n\"\n\"                       debug_keyboard   enable  -debug_keyboard, same as \\\"dk\\\"\\n\"\n\"                       nodebug_keyboard disable -debug_keyboard, same as \\\"nodk\\\"\\n\"\n\"                       keycode:n       inject keystroke 'keycode' (xmodmap -pk)\\n\"\n\"                       keycode:n,down  inject 'keycode' (down=0,1)\\n\"\n\"                       keysym:str      inject keystroke 'keysym' (number/name)\\n\"\n\"                       keysym:str,down inject 'keysym' (down=0,1)\\n\"\n\"                       ptr:x,y,mask    inject pointer event x, y, button-mask\\n\"\n\"                       fakebuttonevent:button,down direct XTestFakeButtonEvent.\\n\"\n\"                       sleep:t         sleep floating point time t.\\n\"\n\"                       get_xprop:p     get X property named 'p'.\\n\"\n\"                       set_xprop:p:val set X property named 'p' to 'val'.\\n\"\n\"                                       p -> id=NNN:p for hex/dec window id.\\n\"\n\"                       wininfo:id      get info about X window id.  use 'root'\\n\"\n\"                                       for root window, use +id for children.\\n\"\n\"                       grab_state      get state of pointer and keyboard grab.\\n\"\n\"                       pointer_pos     print XQueryPointer x,y cursor position.\\n\"\n\"                       pointer_x       print XQueryPointer x cursor position.\\n\"\n\"                       pointer_y       print XQueryPointer y cursor position.\\n\"\n\"                       pointer_same    print XQueryPointer ptr on same screen.\\n\"\n\"                       pointer_root    print XQueryPointer curr ptr rootwin.\\n\"\n\"                       pointer_mask    print XQueryPointer button and mods mask\\n\"\n\"                       mouse_x         print x11vnc's idea of cursor position.\\n\"\n\"                       mouse_y         print x11vnc's idea of cursor position.\\n\"\n\"                       noop            do nothing.\\n\"\n\"                       defer:n         set -defer to n ms,same as deferupdate:n\\n\"\n\"                       wait:n          set -wait to n ms.\\n\"\n\"                       extra_fbur:n    set -extra_fbur to n.\\n\"\n\"                       wait_ui:f       set -wait_ui factor to f.\\n\"\n\"                       setdefer:n      set -setdefer to -2,-1,0,1, or 2.\\n\"\n\"                       wait_bog        disable -nowait_bog mode.\\n\"\n\"                       nowait_bog      enable  -nowait_bog mode.\\n\"\n\"                       slow_fb:f       set -slow_fb to f seconds.\\n\"\n\"                       xrefresh:f      set -xrefresh to f seconds.\\n\"\n\"                       readtimeout:n   set read timeout to n seconds.\\n\"\n\"                       nap             enable  -nap mode.\\n\"\n\"                       nonap           disable -nap mode.\\n\"\n\"                       sb:n            set -sb to n s, same as screen_blank:n\\n\"\n\"                       fbpm            disable -nofbpm mode.\\n\"\n\"                       nofbpm          enable  -nofbpm mode.\\n\"\n\"                       dpms            disable -nodpms mode.\\n\"\n\"                       nodpms          enable  -nodpms mode.\\n\"\n\"                       forcedpms       enable  -forcedpms mode.\\n\"\n\"                       noforcedpms     disable -forcedpms mode.\\n\"\n\"                       clientdpms      enable  -clientdpms mode.\\n\"\n\"                       noclientdpms    disable -clientdpms mode.\\n\"\n\"                       noserverdpms    enable  -noserverdpms mode.\\n\"\n\"                       serverdpms      disable -noserverdpms mode.\\n\"\n\"                       noultraext      enable  -noultraext mode.\\n\"\n\"                       ultraext        disable -noultraext mode.\\n\"\n\"                       chatwindow      enable  local chatwindow mode.\\n\"\n\"                       nochatwindow    disable local chatwindow mode.\\n\"\n\"                       chaton          begin chat using local window.\\n\"\n\"                       chatoff         end   chat using local window.\\n\"\n\"                       xdamage         enable  xdamage polling hints.\\n\"\n\"                       noxdamage       disable xdamage polling hints.\\n\"\n\"                       xd_area:A       set -xd_area max pixel area to \\\"A\\\"\\n\"\n\"                       xd_mem:f        set -xd_mem remembrance to \\\"f\\\"\\n\"\n\"                       fs:frac         set -fs fraction to \\\"frac\\\", e.g. 0.5\\n\"\n\"                       gaps:n          set -gaps to n.\\n\"\n\"                       grow:n          set -grow to n.\\n\"\n\"                       fuzz:n          set -fuzz to n.\\n\"\n\"                       snapfb          enable  -snapfb mode.\\n\"\n\"                       nosnapfb        disable -snapfb mode.\\n\"\n\"                       rawfb:str       set -rawfb mode to \\\"str\\\".\\n\"\n\"                       uinput_accel:f  set uinput_accel to f.\\n\"\n\"                       uinput_thresh:n set uinput_thresh to n.\\n\"\n\"                       uinput_reset:n  set uinput_reset to n ms.\\n\"\n\"                       uinput_always:n set uinput_always to 1/0.\\n\"\n\"                       progressive:n   set LibVNCServer -progressive slice\\n\"\n\"                                       height parameter to n.\\n\"\n\"                       desktop:str     set -desktop name to str for new clients.\\n\"\n\"                       rfbport:n       set -rfbport to n.\\n\"\n\"                       macnosaver      enable  -macnosaver mode.\\n\"\n\"                       macsaver        disable -macnosaver mode.\\n\"\n\"                       macnowait       enable  -macnowait  mode.\\n\"\n\"                       macwait         disable -macnowait  mode.\\n\"\n\"                       macwheel:n      set -macwheel to n.\\n\"\n\"                       macnoswap       enable  -macnoswap mouse button mode.\\n\"\n\"                       macswap         disable -macnoswap mouse button mode.\\n\"\n\"                       macnoresize     enable  -macnoresize mode.\\n\"\n\"                       macresize       disable -macnoresize mode.\\n\"\n\"                       maciconanim:n   set -maciconanim to n.\\n\"\n\"                       macmenu         enable  -macmenu  mode.\\n\"\n\"                       macnomenu       disable -macmenu  mode.\\n\"\n\"                       macuskbd        enable  -macuskbd mode.\\n\"\n\"                       macnouskbd      disable -macuskbd mode.\\n\"\n/* access */\n\"                       httpport:n      set -httpport to n.\\n\"\n\"                       httpdir:dir     set -httpdir to dir (and enable http).\\n\"\n\"                       enablehttpproxy   enable  -enablehttpproxy mode.\\n\"\n\"                       noenablehttpproxy disable -enablehttpproxy mode.\\n\"\n\"                       alwaysshared     enable  -alwaysshared mode.\\n\"\n\"                       noalwaysshared   disable -alwaysshared mode.\\n\"\n\"                                        (may interfere with other options)\\n\"\n\"                       nevershared      enable  -nevershared mode.\\n\"\n\"                       nonevershared    disable -nevershared mode.\\n\"\n\"                                        (may interfere with other options)\\n\"\n\"                       dontdisconnect   enable  -dontdisconnect mode.\\n\"\n\"                       nodontdisconnect disable -dontdisconnect mode.\\n\"\n\"                                        (may interfere with other options)\\n\"\n\"                       debug_xevents   enable  debugging X events.\\n\"\n\"                       nodebug_xevents disable debugging X events.\\n\"\n\"                       debug_xdamage   enable  debugging X DAMAGE mechanism.\\n\"\n\"                       nodebug_xdamage disable debugging X DAMAGE mechanism.\\n\"\n\"                       debug_wireframe enable   debugging wireframe mechanism.\\n\"\n\"                       nodebug_wireframe disable debugging wireframe mechanism.\\n\"\n\"                       debug_scroll    enable  debugging scrollcopy mechanism.\\n\"\n\"                       nodebug_scroll  disable debugging scrollcopy mechanism.\\n\"\n\"                       debug_tiles     enable  -debug_tiles\\n\"\n\"                       nodebug_tiles   disable -debug_tiles\\n\"\n\"                       debug_grabs     enable  -debug_grabs\\n\"\n\"                       nodebug_grabs   disable -debug_grabs\\n\"\n\"                       debug_sel       enable  -debug_sel\\n\"\n\"                       nodebug_sel     disable -debug_sel\\n\"\n\"                       debug_ncache    enable  -debug_ncache\\n\"\n\"                       nodebug_ncache  disable -debug_ncache\\n\"\n\"                       dbg             enable  -dbg crash shell\\n\"\n\"                       nodbg           disable -dbg crash shell\\n\"\n\"\\n\"\n\"                       noremote        disable the -remote command processing,\\n\"\n\"                                       it cannot be turned back on.\\n\"\n\"\\n\"\n\"                       bcx_xattach:str  This remote control command is for\\n\"\n\"                       use with the BARCO xattach program or the x2x program.\\n\"\n\"                       Both of these programs are for 'pointer and keyboard'\\n\"\n\"                       sharing between separate X displays.  In general the\\n\"\n\"                       two displays are usually nearby, e.g. on the same desk,\\n\"\n\"                       and this allows the user to share a single pointer and\\n\"\n\"                       keyboard between them.  The user moves the mouse to\\n\"\n\"                       an edge and then the mouse pointer appears to 'jump'\\n\"\n\"                       to the other display screen.  Thus it emulates what a\\n\"\n\"                       single X server would do for two screens (e.g. :0.0 and\\n\"\n\"                       :0.1) The illusion of a single Xserver with multiple\\n\"\n\"                       screens is achieved by forwarding events to the 2nd\\n\"\n\"                       one via the XTEST extension.\\n\"\n\"\\n\"\n\"                       What the x11vnc bcx_xattach command does is to perform\\n\"\n\"                       some pointer movements to try to INDUCE xattach/x2x\\n\"\n\"                       to 'jump' to the other display.  In what follows the\\n\"\n\"                       'master' display refers to the one that when it has\\n\"\n\"                       'focus' it is basically doing nothing besides watching\\n\"\n\"                       for the mouse to go over an edge.  The 'slave'\\n\"\n\"                       display refers to the one to which the mouse and\\n\"\n\"                       keyboard is redirected to once an edge in the master\\n\"\n\"                       has been crossed.  Note that the x11vnc executing the\\n\"\n\"                       bcx_xattach command MUST be the one connected to the\\n\"\n\"                       *master* display.\\n\"\n\"\\n\"\n\"                       Also note that when input is being redirected (via\\n\"\n\"                       XTEST) from the master display to the slave display,\\n\"\n\"                       the master display's pointer and keyboard are *grabbed*\\n\"\n\"                       by xattach/x2x.  x11vnc can use this info to verify that\\n\"\n\"                       the master/slave mode change has taken place correctly.\\n\"\n\"                       If you specify the \\\"ifneeded\\\" option (see below)\\n\"\n\"                       and the initial grab state is that of the desired\\n\"\n\"                       final state, then no pointer movements are injected\\n\"\n\"                       and \\\"DONE,GRAB_OK\\\" is returned.\\n\"\n\"\\n\"\n\"                       \\\"str\\\" must contain one of \\\"up\\\", \\\"down\\\", \\\"left\\\",\\n\"\n\"                       or \\\"right\\\" to indicate the direction of the 'jump'.\\n\"\n\"                       \\\"str\\\" must also contain one of \\\"master_to_slave\\\"\\n\"\n\"                       or \\\"slave_to_master\\\" to indicate the type of mode\\n\"\n\"                       change induced by the jump.  Use \\\"M2S\\\" and \\\"S2M\\\"\\n\"\n\"                       as shorter aliases.\\n\"\n\"\\n\"\n\"                       \\\"str\\\" may be a \\\"+\\\" separated list of additional\\n\"\n\"                       tuning options.  The \\\"shift=n\\\" option indicates an\\n\"\n\"                       offset shift position away from (0,0) (default 20).\\n\"\n\"                       \\\"final=x+y\\\" specifies the final position of the cursor\\n\"\n\"                       at the end of the normal move sequence; default 30+30.\\n\"\n\"                       \\\"extra_move=x+y\\\" means to do one more pointer move\\n\"\n\"                       after \\\"final\\\" to x+y.  \\\"dt=n\\\" sets the sleep time\\n\"\n\"                       in milliseconds between pointer moves (default: 40ms)\\n\"\n\"                       \\\"retry=n\\\" specifies the maximum number of retries if\\n\"\n\"                       the grab state change fails. \\\"ifneeded\\\" means to not\\n\"\n\"                       apply the pointer movements if the initial grab state is\\n\"\n\"                       that of the desired final state. \\\"nograbcheck\\\" means\\n\"\n\"                       to not check if the grab state changed as expected and\\n\"\n\"                       only apply the pointer movements (default is to check\\n\"\n\"                       the grab states.)\\n\"\n\"\\n\"\n\"                       If you do not specify \\\"up\\\", etc., to bcx_xattach\\n\"\n\"                       nothing will be attempted and the command returns\\n\"\n\"                       the string FAIL,NO_DIRECTION_SPECIFIED.  If you do\\n\"\n\"                       not specify \\\"master_to_slave\\\" or \\\"M2S\\\", etc., to\\n\"\n\"                       bcx_xattach nothing will be attempted and the command\\n\"\n\"                       returns the string FAIL,NO_MODE_CHANGE_SPECIFIED.\\n\"\n\"\\n\"\n\"                       Otherwise, the returned string will contain \\\"DONE\\\".\\n\"\n\"                       It will be \\\"DONE,GRAB_OK\\\" if the grab state changed\\n\"\n\"                       as expected (or if \\\"ifneeded\\\" was supplied and\\n\"\n\"                       the initial grab state was already the desired\\n\"\n\"                       one.)  If the initial grab state was incorrect,\\n\"\n\"                       but the final grab state was correct then it is\\n\"\n\"                       \\\"DONE,GRAB_FAIL_INIT\\\".  If the initial grab state\\n\"\n\"                       was correct, but the final grab state was incorrect\\n\"\n\"                       then it is \\\"DONE,GRAB_FAIL_FINAL\\\".  If both are\\n\"\n\"                       incorrect it will be \\\"DONE,GRAB_FAIL\\\".  Under grab\\n\"\n\"                       failure the string will be followed by \\\":p1,k1-p2,k2\\\"\\n\"\n\"                       where  p1,k1 indicates the initial pointer and keyboard\\n\"\n\"                       grab states and p2,k2 the final ones. If GRAB_FAIL or\\n\"\n\"                       GRAB_FAIL_FINAL occurs, the action will be retried up\\n\"\n\"                       to 3 times; trying to reset the state and sleeping a\\n\"\n\"                       bit between each try.  Set retry=n to adjust the number\\n\"\n\"                       of retries, zero to disable retries.\\n\"\n\"\\n\"\n\"                       Examples:\\n\"\n\"                           -R bcx_xattach:down+M2S\\n\"\n\"                           -R bcx_xattach:up+S2M\\n\"\n\"                           -R bcx_xattach:up+S2M+nograbcheck+dt=30\\n\"\n\"                           -R bcx_xattach:down+M2S+extra_move=100+100\\n\"\n\"\\n\"\n\"                       or use -Q instead of -R to retrieve the result text.\\n\"\n\"\\n\"\n\"                       End of the bcx_xattach:str description.\\n\"\n\"\\n\"\n\"                       The vncconnect(1) command from standard VNC\\n\"\n\"                       distributions may also be used if string is prefixed\\n\"\n\"                       with \\\"cmd=\\\" E.g. 'vncconnect cmd=stop'.  Under some\\n\"\n\"                       circumstances xprop(1) can used if it supports -set\\n\"\n\"                       (see the FAQ).\\n\"\n\"\\n\"\n\"                       If \\\"-connect /path/to/file\\\" has been supplied to the\\n\"\n\"                       running x11vnc server then that file can be used as a\\n\"\n\"                       communication channel (this is the only way to remote\\n\"\n\"                       control one of many x11vnc's polling the same X display)\\n\"\n\"                       Simply run: 'x11vnc -connect /path/to/file -remote ...'\\n\"\n\"                       or you can directly write to the file via something\\n\"\n\"                       like: \\\"echo cmd=stop > /path/to/file\\\", etc.\\n\"\n\"\\n\"\n\"-query variable        Like -remote, except just query the value of\\n\"\n\"                       \\\"variable\\\".  \\\"-Q\\\" is an alias for \\\"-query\\\".\\n\"\n\"                       Multiple queries can be done by separating variables\\n\"\n\"                       by commas, e.g. -query var1,var2. The results come\\n\"\n\"                       back in the form ans=var1:value1,ans=var2:value2,...\\n\"\n\"                       to the standard output.  If a variable is read-only,\\n\"\n\"                       it comes back with prefix \\\"aro=\\\" instead of \\\"ans=\\\".\\n\"\n\"\\n\"\n\"                       Some -remote commands are pure actions that do not make\\n\"\n\"                       sense as variables, e.g. \\\"stop\\\" or \\\"disconnect\\\", in\\n\"\n\"                       these cases the value returned is \\\"N/A\\\".  To direct a\\n\"\n\"                       query straight to the X11VNC_REMOTE property or connect\\n\"\n\"                       file use \\\"qry=...\\\" instead of \\\"cmd=...\\\"\\n\"\n\"\\n\"\n\"                       ans= stop quit exit shutdown ping resend_cutbuffer\\n\"\n\"                       resend_clipboard resend_primary blacken zero refresh\\n\"\n\"                       reset close disconnect id_cmd id sid waitmapped\\n\"\n\"                       nowaitmapped clip flashcmap noflashcmap shiftcmap\\n\"\n\"                       truecolor notruecolor overlay nooverlay overlay_cursor\\n\"\n\"                       overlay_yescursor nooverlay_nocursor nooverlay_cursor\\n\"\n\"                       nooverlay_yescursor overlay_nocursor 8to24 no8to24\\n\"\n\"                       8to24_opts 24to32 no24to32 visual scale scale_cursor\\n\"\n\"                       viewonly noviewonly shared noshared forever noforever\\n\"\n\"                       once timeout tightfilexfer notightfilexfer ultrafilexfer\\n\"\n\"                       noultrafilexfer rfbversion deny lock nodeny unlock avahi\\n\"\n\"                       mdns zeroconf noavahi nomdns nozeroconf connect proxy\\n\"\n\"                       allowonce allow noipv6 ipv6 noipv4 ipv4 no6 6 localhost\\n\"\n\"                       nolocalhost listen lookup nolookup accept afteraccept\\n\"\n\"                       gone shm noshm flipbyteorder noflipbyteorder onetile\\n\"\n\"                       noonetile solid_color solid nosolid blackout xinerama\\n\"\n\"                       noxinerama xtrap noxtrap xrandr noxrandr xrandr_mode\\n\"\n\"                       rotate padgeom quiet q noquiet modtweak nomodtweak xkb\\n\"\n\"                       noxkb capslock nocapslock skip_lockkeys noskip_lockkeys\\n\"\n\"                       skip_keycodes sloppy_keys nosloppy_keys skip_dups\\n\"\n\"                       noskip_dups add_keysyms noadd_keysyms clear_mods\\n\"\n\"                       noclear_mods clear_keys noclear_keys clear_all\\n\"\n\"                       clear_locks keystate remap repeat norepeat fb nofb bell\\n\"\n\"                       nobell sendbell sel nosel primary noprimary setprimary\\n\"\n\"                       nosetprimary clipboard noclipboard setclipboard\\n\"\n\"                       nosetclipboard seldir cursorshape nocursorshape\\n\"\n\"                       cursorpos nocursorpos cursor_drag nocursor_drag cursor\\n\"\n\"                       show_cursor noshow_cursor nocursor arrow xfixes noxfixes\\n\"\n\"                       xdamage noxdamage xd_area xd_mem alphacut alphafrac\\n\"\n\"                       alpharemove noalpharemove alphablend noalphablend\\n\"\n\"                       xwarppointer xwarp noxwarppointer noxwarp always_inject\\n\"\n\"                       noalways_inject buttonmap dragging nodragging ncache_cr\\n\"\n\"                       noncache_cr ncache_no_moveraise noncache_no_moveraise\\n\"\n\"                       ncache_no_dtchange noncache_no_dtchange\\n\"\n\"                       ncache_no_rootpixmap noncache_no_rootpixmap\\n\"\n\"                       ncache_reset_rootpixmap ncrp ncache_keep_anims\\n\"\n\"                       noncache_keep_anims ncache_old_wm noncache_old_wm\\n\"\n\"                       ncache_pad ncache noncache ncache_size debug_ncache\\n\"\n\"                       nodebug_ncache wireframe_mode wireframe wf nowireframe\\n\"\n\"                       nowf wireframelocal wfl nowireframelocal nowfl\\n\"\n\"                       wirecopyrect wcr nowirecopyrect nowcr scr_area\\n\"\n\"                       scr_skip scr_inc scr_keys scr_term scr_keyrepeat\\n\"\n\"                       scr_parms scrollcopyrect scr noscrollcopyrect\\n\"\n\"                       noscr fixscreen noxrecord xrecord reset_record\\n\"\n\"                       pointer_mode pm input_skip allinput noallinput\\n\"\n\"                       input_eagerly noinput_eagerly input grabkbd nograbkbd\\n\"\n\"                       grabptr nograbptr grabalways nograbalways grablocal\\n\"\n\"                       client_input ssltimeout speeds wmdt debug_pointer dp\\n\"\n\"                       nodebug_pointer nodp debug_keyboard dk nodebug_keyboard\\n\"\n\"                       nodk keycode keysym ptr fakebuttonevent sleep get_xprop\\n\"\n\"                       set_xprop wininfo bcx_xattach deferupdate defer\\n\"\n\"                       setdefer extra_fbur wait_ui wait_bog nowait_bog\\n\"\n\"                       slow_fb xrefresh wait readtimeout nap nonap sb\\n\"\n\"                       screen_blank fbpm nofbpm dpms nodpms clientdpms\\n\"\n\"                       noclientdpms forcedpms noforcedpms noserverdpms\\n\"\n\"                       serverdpms noultraext ultraext chatwindow nochatwindow\\n\"\n\"                       chaton chatoff fs gaps grow fuzz snapfb nosnapfb\\n\"\n\"                       rawfb uinput_accel uinput_thresh uinput_reset\\n\"\n\"                       uinput_always progressive rfbport http nohttp httpport\\n\"\n\"                       httpdir enablehttpproxy noenablehttpproxy alwaysshared\\n\"\n\"                       noalwaysshared nevershared noalwaysshared dontdisconnect\\n\"\n\"                       nodontdisconnect desktop debug_xevents nodebug_xevents\\n\"\n\"                       debug_xevents debug_xdamage nodebug_xdamage\\n\"\n\"                       debug_xdamage debug_wireframe nodebug_wireframe\\n\"\n\"                       debug_wireframe debug_scroll nodebug_scroll debug_scroll\\n\"\n\"                       debug_tiles dbt nodebug_tiles nodbt debug_tiles\\n\"\n\"                       debug_grabs nodebug_grabs debug_sel nodebug_sel dbg\\n\"\n\"                       nodbg macnosaver macsaver nomacnosaver macnowait macwait\\n\"\n\"                       nomacnowait macwheel macnoswap macswap nomacnoswap\\n\"\n\"                       macnoresize macresize nomacnoresize maciconanim macmenu\\n\"\n\"                       macnomenu nomacmenu macuskbd nomacuskbd noremote\\n\"\n\"\\n\"\n\"                       aro=  noop display vncdisplay icon_mode autoport\\n\"\n\"                       loop loopbg desktopname guess_desktop guess_dbus\\n\"\n\"                       http_url auth xauth users rootshift clipshift scale_str\\n\"\n\"                       scaled_x scaled_y scale_numer scale_denom scale_fac_x\\n\"\n\"                       scale_fac_y scaling_blend scaling_nomult4 scaling_pad\\n\"\n\"                       scaling_interpolate inetd privremote unsafe safer nocmds\\n\"\n\"                       passwdfile unixpw unixpw_nis unixpw_list ssl ssl_pem\\n\"\n\"                       sslverify stunnel stunnel_pem https httpsredir usepw\\n\"\n\"                       using_shm logfile o flag rmflag rc norc h help V version\\n\"\n\"                       lastmod bg sigpipe threads readrate netrate netlatency\\n\"\n\"                       pipeinput clients client_count pid ext_xtest ext_xtrap\\n\"\n\"                       ext_xrecord ext_xkb ext_xshm ext_xinerama ext_overlay\\n\"\n\"                       ext_xfixes ext_xdamage ext_xrandr rootwin num_buttons\\n\"\n\"                       button_mask mouse_x mouse_y grab_state pointer_pos\\n\"\n\"                       pointer_x pointer_y pointer_same pointer_root\\n\"\n\"                       pointer_mask bpp depth indexed_color dpy_x dpy_y wdpy_x\\n\"\n\"                       wdpy_y off_x off_y cdpy_x cdpy_y coff_x coff_y rfbauth\\n\"\n\"                       passwd viewpasswd\\n\"\n\"\\n\"\n\"-QD variable           Just like -query variable, but returns the default\\n\"\n\"                       value for that parameter (no running x11vnc server\\n\"\n\"                       is consulted)\\n\"\n\"\\n\"\n\"-sync                  By default -remote commands are run asynchronously, that\\n\"\n\"                       is, the request is posted and the program immediately\\n\"\n\"                       exits.  Use -sync to have the program wait for an\\n\"\n\"                       acknowledgement from the x11vnc server that command was\\n\"\n\"                       processed (somehow).  On the other hand -query requests\\n\"\n\"                       are always processed synchronously because they have\\n\"\n\"                       to wait for the answer.\\n\"\n\"\\n\"\n\"                       Also note that if both -remote and -query requests are\\n\"\n\"                       supplied on the command line, the -remote is processed\\n\"\n\"                       first (synchronously: no need for -sync), and then\\n\"\n\"                       the -query request is processed in the normal way.\\n\"\n\"                       This allows for a reliable way to see if the -remote\\n\"\n\"                       command was processed by querying for any new settings.\\n\"\n\"                       Note however that there is timeout of a few seconds\\n\"\n\"                       (see the next paragraph) so if the x11vnc takes longer\\n\"\n\"                       than that to process the requests the requester will\\n\"\n\"                       think that a failure has taken place.\\n\"\n\"\\n\"\n\"                       The default is to wait 3.5 seconds.  Or if cmd=stop\\n\"\n\"                       only 1.0 seconds.  If cmd matches 'script:' then it\\n\"\n\"                       will wait up to 10.0 seconds.  Set X11VNC_SYNC_TIMEOUT\\n\"\n\"                       to the number of seconds you want it to wait.\\n\"\n\"\\n\"\n\"-query_retries str     If a query fails to get a response from an x11vnc\\n\"\n\"                       server, retry up to n times.  \\\"str\\\" is specified as\\n\"\n\"                       n[:t][/match]  Optionally the delay between tries may\\n\"\n\"                       be specified by \\\"t\\\" a floating point time (default\\n\"\n\"                       0.5 seconds.)  Note: the response is not checked for\\n\"\n\"                       validity or whether it corresponds to the query sent.\\n\"\n\"                       The query \\\"ping:mystring\\\" may be used to help uniquely\\n\"\n\"                       identify the query.  Optionally, a matching string after\\n\"\n\"                       a \\\"/\\\" will be used to check the result text.  Up to\\n\"\n\"                       n retries will take place until the matching string is\\n\"\n\"                       found in the output text.  If the match string is never\\n\"\n\"                       found the program's exit code is 1; if the match is\\n\"\n\"                       found it exits with 0.  Note that there may be stdout\\n\"\n\"                       printed for each retry (i.e. multiple lines printed\\n\"\n\"                       out to stdout.)\\n\"\n\"                       Example: -query_retries 4:1.5/grab_state\\n\"\n\"\\n\"\n\"-remote_prefix str     Enable a remote-control communication channel for\\n\"\n\"                       connected VNC clients.  str is a non-empty string. If a\\n\"\n\"                       VNC client sends rfbCutText having the prefix \\\"str\\\"\\n\"\n\"                       then the part after it is processed as though it were\\n\"\n\"                       sent via 'x11vnc -remote ...'.  If it begins with\\n\"\n\"                       neither 'cmd=' nor 'qry=' then 'qry=' is assumed.\\n\"\n\"                       Any corresponding output text for that remote control\\n\"\n\"                       command is sent back to all client as rfbCutText.\\n\"\n\"                       The returned output is also prefixed with \\\"str\\\".\\n\"\n\"                       Example: -remote_prefix DO_THIS:\\n\"\n\"\\n\"\n\"                       Note that enabling -remote_prefix allows the remote\\n\"\n\"                       VNC viewers to run x11vnc -remote commands.  Do not\\n\"\n\"                       use this option if they are not to be trusted.\\n\"\n\"\\n\"\n\"-noremote              Do not process any remote control commands or queries.\\n\"\n\"-yesremote             Do process remote control commands or queries.\\n\"\n\"                       Default: %s\\n\"\n\"\\n\"\n\"                       A note about security wrt remote control commands.\\n\"\n\"                       If someone can connect to the X display and change\\n\"\n\"                       the property X11VNC_REMOTE, then they can remotely\\n\"\n\"                       control x11vnc.  Normally access to the X display is\\n\"\n\"                       protected.  Note that if they can modify X11VNC_REMOTE\\n\"\n\"                       on the X server, they have enough permissions to also\\n\"\n\"                       run their own x11vnc and thus have complete control\\n\"\n\"                       of the desktop.  If the  \\\"-connect /path/to/file\\\"\\n\"\n\"                       channel is being used, obviously anyone who can write\\n\"\n\"                       to /path/to/file can remotely control x11vnc.  So be\\n\"\n\"                       sure to protect the X display and that file's write\\n\"\n\"                       permissions.  See -privremote below.\\n\"\n\"\\n\"\n\"                       If you are paranoid and do not think -noremote is\\n\"\n\"                       enough, to disable the X11VNC_REMOTE property channel\\n\"\n\"                       completely use -novncconnect, or use the -safer option\\n\"\n\"                       that shuts many things off.\\n\"\n\"\\n\"\n\"-unsafe                A few remote commands are disabled by default\\n\"\n\"                       (currently: id:pick, accept:<cmd>, gone:<cmd>, and\\n\"\n\"                       rawfb:setup:<cmd>) because they are associated with\\n\"\n\"                       running external programs.  If you specify -unsafe, then\\n\"\n\"                       these remote-control commands are allowed.  Note that\\n\"\n\"                       you can still specify these parameters on the command\\n\"\n\"                       line, they just cannot be invoked via remote-control.\\n\"\n\"-safer                 Equivalent to: -novncconnect -noremote and prohibiting\\n\"\n\"                       -gui and the -connect file. Shuts off communication\\n\"\n\"                       channels.\\n\"\n\"-privremote            Perform some sanity checks and disable remote-control\\n\"\n\"                       commands if it appears that the X DISPLAY and/or\\n\"\n\"                       connectfile can be accessed by other users.  Once\\n\"\n\"                       remote-control is disabled it cannot be turned back on.\\n\"\n\"-nocmds                No external commands (e.g. system(3), popen(3), exec(3))\\n\"\n\"                       will be run at all.\\n\"\n\"-allowedcmds list      \\\"list\\\" contains a comma separated list of the only\\n\"\n\"                       external commands that can be run.  The full list of\\n\"\n\"                       associated options is:\\n\"\n\"\\n\"\n\"                        stunnel, ssl, unixpw, WAIT, zeroconf, id, accept,\\n\"\n\"                        afteraccept, gone, pipeinput, v4l-info, rawfb-setup,\\n\"\n\"                        dt, gui, ssh, storepasswd, passwdfile, custom_passwd,\\n\"\n\"                        findauth, crash.\\n\"\n\"\\n\"\n\"                       See each option's help to learn the associated external\\n\"\n\"                       command.  Note that the -nocmds option takes precedence\\n\"\n\"                       and disables all external commands.\\n\"\n\"\\n\"\n\"-deny_all              For use with -remote nodeny: start out denying all\\n\"\n\"                       incoming clients until \\\"-remote nodeny\\\" is used to\\n\"\n\"                       let them in.\\n\"\n\"\\n\"\n\"%s\\n\"\n\"\\n\"\n\"These options are passed to LibVNCServer:\\n\"\n\"\\n\"\n;\n\t/* have both our help and rfbUsage to stdout for more(1), etc. */\n\tdup2(1, 2);\n\n\t/* register extension(s) to get their help output */\n#ifdef LIBVNCSERVER_WITH_TIGHTVNC_FILETRANSFER\n\trfbRegisterTightVNCFileTransferExtension();\n#endif\n\n\tif (mode == 1) {\n\t\tchar *p;\t\n\t\tint l = 0;\n\t\tfprintf(stderr, \"x11vnc: allow VNC connections to real \"\n\t\t    \"X11 displays. %s\\n\\nx11vnc options:\\n\", lastmod);\n\t\tp = strtok(help, \"\\n\");\n\t\twhile (p) {\n\t\t\tint w = 23;\n\t\t\tchar tmp[100];\n\t\t\tif (p[0] == '-') {\n\t\t\t\tmemset(tmp, 0, sizeof(tmp));\n\t\t\t\tstrncpy(tmp, p, w);\n\t\t\t\tfprintf(stderr, \"  %s\", tmp);\n\t\t\t\tl++;\n\t\t\t\tif (l % 3 == 0) {\n\t\t\t\t\tfprintf(stderr, \"\\n\");\n\t\t\t\t}\n\t\t\t}\n\t\t\tp = strtok(NULL, \"\\n\");\n\t\t}\n\t\tfprintf(stderr, \"\\n\\nLibVNCServer options:\\n\");\n\t\trfbUsage();\n\t\tfprintf(stderr, \"\\n\");\n\t\texit(1);\n\t}\n#if 1\n\tfprintf(stderr, help, lastmod,\n\t\tPOLL_8TO24_DELAY,\n\t\tscaling_copyrect ? \":cr\":\":nocr\",\n\t\tview_only ? \"on\":\"off\",\n\t\tshared ? \"on\":\"off\",\n\t\tvnc_connect ? \"-vncconnect\":\"-novncconnect\",\n\t\txinerama ? \"-xinerama\":\"-noxinerama\",\n\t\tuse_modifier_tweak ? \"-modtweak\":\"-nomodtweak\",\n\t\tskip_duplicate_key_events ? \"-skip_dups\":\"-noskip_dups\",\n\t\tadd_keysyms ? \"-add_keysyms\":\"-noadd_keysyms\",\n\t\tno_autorepeat ? \"-norepeat\":\"-repeat\",\n\t\talt_arrow_max, alt_arrow,\n\t\talpha_threshold,\n\t\talpha_frac,\n\t\tcursor_pos_updates ? \"-cursorpos\":\"-nocursorpos\",\n\t\twireframe ? \"-wireframe\":\"-nowireframe\",\n\t\tWIREFRAME_PARMS,\n\t\twireframe_copyrect_default,\n\t\tscroll_copyrect_default,\n\t\tscrollcopyrect_min_area,\n\t\tscroll_skip_str0 ? scroll_skip_str0 : \"(empty)\",\n\t\tscroll_term_str0,\n\t\tmax_keyrepeat_str0,\n\t\tSCROLL_COPYRECT_PARMS,\n\t\tpointer_mode_max, pointer_mode,\n\t\tui_skip,\n\t\tdefer_update,\n\t\twaitms,\n\t\twait_ui,\n\t\ttake_naps ? \"take naps\":\"no naps\",\n\t\tscreen_blank,\n\t\trfbMaxClientWait/1000,\n\t\twatch_fbpm ? \"-nofbpm\":\"-fbpm\",\n\t\twatch_dpms ? \"-nodpms\":\"-dpms\",\n\t\txdamage_max_area, NSCAN, xdamage_memory,\n\t\tuse_threads ? \"-threads\":\"-nothreads\",\n\t\tfs_frac,\n\t\tgaps_fill,\n\t\tgrow_fill,\n\t\ttile_fuzz,\n\t\taccept_remote_cmds ? \"-yesremote\":\"-noremote\",\n\t\t\"\"\n\t);\n#else\n\tfprintf(stderr, \"%s\", help);\n#endif\n\n\trfbUsage();\n#endif\n\texit(1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "arg",
            "\"-opts\""
          ],
          "line": 3168
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "arg",
            "\"-?\""
          ],
          "line": 3168
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "arg",
            "\"-help\""
          ],
          "line": 3164
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "arg",
            "\"-h\""
          ],
          "line": 3164
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "argv[++i]"
          ],
          "line": 3161
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "arg",
            "\"-prog\""
          ],
          "line": 3156
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "arg",
            "\"-env\""
          ],
          "line": 3152
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "arg",
            "\"-norc\""
          ],
          "line": 3148
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "arg",
            "\"-rc\""
          ],
          "line": 3144
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "argv[++i]"
          ],
          "line": 3141
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "arg",
            "\"-rmflag\""
          ],
          "line": 3139
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "argv[++i]"
          ],
          "line": 3136
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "arg",
            "\"-flag\""
          ],
          "line": 3134
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "argv[++i]"
          ],
          "line": 3131
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "arg",
            "\"-logappend\""
          ],
          "line": 3128
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "arg",
            "\"-oa\""
          ],
          "line": 3128
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "argv[++i]"
          ],
          "line": 3125
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "arg",
            "\"-logfile\""
          ],
          "line": 3122
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "arg",
            "\"-o\""
          ],
          "line": 3122
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "argv[++i]"
          ],
          "line": 3119
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "arg",
            "\"-padgeometry\""
          ],
          "line": 3117
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "arg",
            "\"-padgeom\""
          ],
          "line": 3116
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "argv[++i]"
          ],
          "line": 3113
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "arg",
            "\"-rotate\""
          ],
          "line": 3111
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "arg",
            "\"-noxrandr\""
          ],
          "line": 3105
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "s"
          ],
          "line": 3099
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "known_xrandr_mode",
          "args": [
            "s"
          ],
          "line": 3098
        },
        "resolved": true,
        "details": {
          "function_name": "known_xrandr_mode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/xrandr.c",
          "lines": "292-305",
          "snippet": "int known_xrandr_mode(char *s) {\n/*\n * default:\t\n * resize:\tthe default\n * exit:\tshutdown clients and exit.\n * newfbsize:\tshutdown clients that do not support NewFBSize encoding.\n */\n\tif (strcmp(s, \"default\") && strcmp(s, \"resize\") && \n\t    strcmp(s, \"exit\") && strcmp(s, \"newfbsize\")) {\n\t\treturn 0;\n\t} else {\n\t\treturn 1;\n\t}\n}",
          "includes": [
            "#include \"win_utils.h\"",
            "#include \"screen.h\"",
            "#include \"remote.h\"",
            "#include \"connections.h\"",
            "#include \"cleanup.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int known_xrandr_mode(char *s);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"win_utils.h\"\n#include \"screen.h\"\n#include \"remote.h\"\n#include \"connections.h\"\n#include \"cleanup.h\"\n#include \"x11vnc.h\"\n\nint known_xrandr_mode(char *s);\n\nint known_xrandr_mode(char *s) {\n/*\n * default:\t\n * resize:\tthe default\n * exit:\tshutdown clients and exit.\n * newfbsize:\tshutdown clients that do not support NewFBSize encoding.\n */\n\tif (strcmp(s, \"default\") && strcmp(s, \"resize\") && \n\t    strcmp(s, \"exit\") && strcmp(s, \"newfbsize\")) {\n\t\treturn 0;\n\t} else {\n\t\treturn 1;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "arg",
            "\"-xrandr\""
          ],
          "line": 3094
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "arg",
            "\"-xtrap\""
          ],
          "line": 3090
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "arg",
            "\"-noxinerama\""
          ],
          "line": 3086
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "arg",
            "\"-xinerama\""
          ],
          "line": 3082
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "argv[++i]"
          ],
          "line": 3079
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "arg",
            "\"-blackout\""
          ],
          "line": 3077
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "solid_default"
          ],
          "line": 3073
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "s"
          ],
          "line": 3068
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "arg",
            "\"-solid\""
          ],
          "line": 3063
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "arg",
            "\"-onetile\""
          ],
          "line": 3059
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "arg",
            "\"-flipbyteorder\""
          ],
          "line": 3055
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "arg",
            "\"-noshm\""
          ],
          "line": 3051
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "argv[++i]"
          ],
          "line": 3048
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "arg",
            "\"-gone\""
          ],
          "line": 3046
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "argv[++i]"
          ],
          "line": 3043
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "arg",
            "\"-afteraccept\""
          ],
          "line": 3041
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "argv[++i]"
          ],
          "line": 3038
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "arg",
            "\"-accept\""
          ],
          "line": 3036
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stdout",
            "\"rfbDecryptPasswdFromFile pass: %s\\n\"",
            "s"
          ],
          "line": 3032
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stdout",
            "\"rfbDecryptPasswdFromFile file: %s\\n\"",
            "f"
          ],
          "line": 3031
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"rfbDecryptPasswdFromFile failed: %s\\n\"",
            "f"
          ],
          "line": 3028
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "perror",
          "args": [
            "\"showrfbauth\""
          ],
          "line": 3027
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbDecryptPasswdFromFile",
          "args": [
            "f"
          ],
          "line": 3025
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "arg",
            "\"-showrfbauth\""
          ],
          "line": 3022
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"stored passwd in file: %s\\n\"",
            "argv[i+2]"
          ],
          "line": 3016
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"-storepasswd failed for file: %s\\n\"",
            "argv[i+2]"
          ],
          "line": 3012
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "perror",
          "args": [
            "\"storepasswd\""
          ],
          "line": 3011
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbEncryptAndStorePasswd",
          "args": [
            "argv[i+1]",
            "argv[i+2]"
          ],
          "line": 3009
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "store_homedir_passwd",
          "args": [
            "argv[i+1]"
          ],
          "line": 3006
        },
        "resolved": true,
        "details": {
          "function_name": "store_homedir_passwd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/x11vnc.c",
          "lines": "1746-1846",
          "snippet": "static void store_homedir_passwd(char *file) {\n\tchar str1[32], str2[32], *p, *h, *f;\n\tstruct stat sbuf;\n\n\tstr1[0] = '\\0';\n\tstr2[0] = '\\0';\n\t/* storepasswd */\n\tif (no_external_cmds || !cmd_ok(\"storepasswd\")) {\n\t\tfprintf(stderr, \"-nocmds cannot be used with -storepasswd\\n\");\n\t\texit(1);\n\t}\n\n\tfprintf(stderr, \"Enter VNC password: \");\n\tsystem(\"stty -echo\");\n\tif (fgets(str1, 32, stdin) == NULL) {\n\t\tperror(\"fgets\");\n\t\tsystem(\"stty echo\");\n\t\texit(1);\n\t}\n\tfprintf(stderr, \"\\n\");\n\n\tfprintf(stderr, \"Verify password:    \");\n\tif (fgets(str2, 32, stdin) == NULL) {\n\t\tperror(\"fgets\");\n\t\tsystem(\"stty echo\");\n\t\texit(1);\n\t}\n\tfprintf(stderr, \"\\n\");\n\tsystem(\"stty echo\");\n\n\tif ((p = strchr(str1, '\\n')) != NULL) {\n\t\t*p = '\\0';\n\t}\n\tif ((p = strchr(str2, '\\n')) != NULL) {\n\t\t*p = '\\0';\n\t}\n\tif (8 < strlen(str1)) {\n\t\t/* RFC6143 states: \"the password is truncated to eight characters\" */\n\t\t/* there's room for ambiguity (characters vs bytes) */\n\t\tfprintf(stderr, \"** password exceeds maximum 8 bytes.\\n\");\n\t\texit(1);\n\t}\n\tif (strcmp(str1, str2)) {\n\t\tfprintf(stderr, \"** passwords differ.\\n\");\n\t\texit(1);\n\t}\n\tif (str1[0] == '\\0') {\n\t\tfprintf(stderr, \"** no password supplied.\\n\");\n\t\texit(1);\n\t}\n\n\tif (file != NULL) {\n\t\tf = file;\n\t} else {\n\t\t\n\t\th = getenv(\"HOME\");\n\t\tif (! h) {\n\t\t\tfprintf(stderr, \"** $HOME not set.\\n\");\n\t\t\texit(1);\n\t\t}\n\n\t\tf = (char *) malloc(strlen(h) + strlen(\"/.vnc/passwd\") + 1);\n\t\tsprintf(f, \"%s/.vnc\", h);\n\n\t\tif (stat(f, &sbuf) != 0) {\n\t\t\tif (mkdir(f, 0755) != 0) {\n\t\t\t\tfprintf(stderr, \"** could not create directory %s\\n\", f);\n\t\t\t\tperror(\"mkdir\");\n\t\t\t\texit(1);\n\t\t\t}\n\t\t} else if (! S_ISDIR(sbuf.st_mode)) {\n\t\t\tfprintf(stderr, \"** not a directory %s\\n\", f);\n\t\t\texit(1);\n\t\t}\n\n\t\tsprintf(f, \"%s/.vnc/passwd\", h);\n\t}\n\tfprintf(stderr, \"Write password to %s?  [y]/n \", f);\n\n\tif (fgets(str2, 32, stdin) == NULL) {\n\t\tperror(\"fgets\");\n\t\texit(1);\n\t}\n\tif (str2[0] == 'n' || str2[0] == 'N') {\n\t\tfprintf(stderr, \"not creating password.\\n\");\n\t\texit(1);\n\t}\n\n\tif (rfbEncryptAndStorePasswd(str1, f) != 0) {\n\t\tfprintf(stderr, \"** error creating password: %s\\n\", f);\n\t\tperror(\"storepasswd\");\n\t\texit(1);\n\t}\n\tif (stat(f, &sbuf) != 0) {\n\t\tfprintf(stderr, \"** error creating password: %s\\n\", f);\n\t\tperror(\"stat\");\n\t\texit(1);\n\t}\n\tfprintf(stdout, \"Password written to: %s\\n\", f);\n\texit(0);\n}",
          "includes": [
            "#include \"xi2_devices.h\"",
            "#include \"solid.h\"",
            "#include \"pm.h\"",
            "#include \"selection.h\"",
            "#include \"sslhelper.h\"",
            "#include \"sslcmds.h\"",
            "#include \"inet.h\"",
            "#include \"unixpw.h\"",
            "#include \"rates.h\"",
            "#include \"connections.h\"",
            "#include \"screen.h\"",
            "#include \"userinput.h\"",
            "#include \"cursor.h\"",
            "#include \"pointer.h\"",
            "#include \"keyboard.h\"",
            "#include \"cleanup.h\"",
            "#include \"user.h\"",
            "#include \"help.h\"",
            "#include \"gui.h\"",
            "#include \"scan.h\"",
            "#include \"remote.h\"",
            "#include \"win_utils.h\"",
            "#include \"xkb_bell.h\"",
            "#include \"xrandr.h\"",
            "#include \"xinerama.h\"",
            "#include \"xevents.h\"",
            "#include \"xrecord.h\"",
            "#include \"xdamage.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xi2_devices.h\"\n#include \"solid.h\"\n#include \"pm.h\"\n#include \"selection.h\"\n#include \"sslhelper.h\"\n#include \"sslcmds.h\"\n#include \"inet.h\"\n#include \"unixpw.h\"\n#include \"rates.h\"\n#include \"connections.h\"\n#include \"screen.h\"\n#include \"userinput.h\"\n#include \"cursor.h\"\n#include \"pointer.h\"\n#include \"keyboard.h\"\n#include \"cleanup.h\"\n#include \"user.h\"\n#include \"help.h\"\n#include \"gui.h\"\n#include \"scan.h\"\n#include \"remote.h\"\n#include \"win_utils.h\"\n#include \"xkb_bell.h\"\n#include \"xrandr.h\"\n#include \"xinerama.h\"\n#include \"xevents.h\"\n#include \"xrecord.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nstatic void store_homedir_passwd(char *file) {\n\tchar str1[32], str2[32], *p, *h, *f;\n\tstruct stat sbuf;\n\n\tstr1[0] = '\\0';\n\tstr2[0] = '\\0';\n\t/* storepasswd */\n\tif (no_external_cmds || !cmd_ok(\"storepasswd\")) {\n\t\tfprintf(stderr, \"-nocmds cannot be used with -storepasswd\\n\");\n\t\texit(1);\n\t}\n\n\tfprintf(stderr, \"Enter VNC password: \");\n\tsystem(\"stty -echo\");\n\tif (fgets(str1, 32, stdin) == NULL) {\n\t\tperror(\"fgets\");\n\t\tsystem(\"stty echo\");\n\t\texit(1);\n\t}\n\tfprintf(stderr, \"\\n\");\n\n\tfprintf(stderr, \"Verify password:    \");\n\tif (fgets(str2, 32, stdin) == NULL) {\n\t\tperror(\"fgets\");\n\t\tsystem(\"stty echo\");\n\t\texit(1);\n\t}\n\tfprintf(stderr, \"\\n\");\n\tsystem(\"stty echo\");\n\n\tif ((p = strchr(str1, '\\n')) != NULL) {\n\t\t*p = '\\0';\n\t}\n\tif ((p = strchr(str2, '\\n')) != NULL) {\n\t\t*p = '\\0';\n\t}\n\tif (8 < strlen(str1)) {\n\t\t/* RFC6143 states: \"the password is truncated to eight characters\" */\n\t\t/* there's room for ambiguity (characters vs bytes) */\n\t\tfprintf(stderr, \"** password exceeds maximum 8 bytes.\\n\");\n\t\texit(1);\n\t}\n\tif (strcmp(str1, str2)) {\n\t\tfprintf(stderr, \"** passwords differ.\\n\");\n\t\texit(1);\n\t}\n\tif (str1[0] == '\\0') {\n\t\tfprintf(stderr, \"** no password supplied.\\n\");\n\t\texit(1);\n\t}\n\n\tif (file != NULL) {\n\t\tf = file;\n\t} else {\n\t\t\n\t\th = getenv(\"HOME\");\n\t\tif (! h) {\n\t\t\tfprintf(stderr, \"** $HOME not set.\\n\");\n\t\t\texit(1);\n\t\t}\n\n\t\tf = (char *) malloc(strlen(h) + strlen(\"/.vnc/passwd\") + 1);\n\t\tsprintf(f, \"%s/.vnc\", h);\n\n\t\tif (stat(f, &sbuf) != 0) {\n\t\t\tif (mkdir(f, 0755) != 0) {\n\t\t\t\tfprintf(stderr, \"** could not create directory %s\\n\", f);\n\t\t\t\tperror(\"mkdir\");\n\t\t\t\texit(1);\n\t\t\t}\n\t\t} else if (! S_ISDIR(sbuf.st_mode)) {\n\t\t\tfprintf(stderr, \"** not a directory %s\\n\", f);\n\t\t\texit(1);\n\t\t}\n\n\t\tsprintf(f, \"%s/.vnc/passwd\", h);\n\t}\n\tfprintf(stderr, \"Write password to %s?  [y]/n \", f);\n\n\tif (fgets(str2, 32, stdin) == NULL) {\n\t\tperror(\"fgets\");\n\t\texit(1);\n\t}\n\tif (str2[0] == 'n' || str2[0] == 'N') {\n\t\tfprintf(stderr, \"not creating password.\\n\");\n\t\texit(1);\n\t}\n\n\tif (rfbEncryptAndStorePasswd(str1, f) != 0) {\n\t\tfprintf(stderr, \"** error creating password: %s\\n\", f);\n\t\tperror(\"storepasswd\");\n\t\texit(1);\n\t}\n\tif (stat(f, &sbuf) != 0) {\n\t\tfprintf(stderr, \"** error creating password: %s\\n\", f);\n\t\tperror(\"stat\");\n\t\texit(1);\n\t}\n\tfprintf(stdout, \"Password written to: %s\\n\", f);\n\texit(0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "arg",
            "\"-storepasswd\""
          ],
          "line": 3000
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "arg",
            "\"-usepw\""
          ],
          "line": 2996
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "argv[++i]"
          ],
          "line": 2993
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "arg",
            "\"-ssh\""
          ],
          "line": 2991
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "arg",
            "\"-nopw\""
          ],
          "line": 2987
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atoi",
          "args": [
            "s"
          ],
          "line": 2981
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "arg",
            "\"-httpsredir\""
          ],
          "line": 2975
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atoi",
          "args": [
            "s"
          ],
          "line": 2969
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "arg",
            "\"-https\""
          ],
          "line": 2962
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "\"SAVE\""
          ],
          "line": 2958
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "\"SAVE\""
          ],
          "line": 2955
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "s"
          ],
          "line": 2951
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "s",
            "\"TMP\""
          ],
          "line": 2948
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "arg",
            "\"-stunnel3\""
          ],
          "line": 2942
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "\"SAVE\""
          ],
          "line": 2938
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "\"SAVE\""
          ],
          "line": 2935
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "s"
          ],
          "line": 2931
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "s",
            "\"TMP\""
          ],
          "line": 2928
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "arg",
            "\"-stunnel\""
          ],
          "line": 2922
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sslScripts",
          "args": [],
          "line": 2918
        },
        "resolved": true,
        "details": {
          "function_name": "sslScripts",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/sslcmds.c",
          "lines": "585-592",
          "snippet": "void sslScripts(void) {\n\tfprintf(stdout, \"======================================================\\n\");\n\tfprintf(stdout, \"genCA script for '-sslGenCA':\\n\\n\");\n\tfprintf(stdout, \"%s\\n\", genCA);\n\tfprintf(stdout, \"======================================================\\n\");\n\tfprintf(stdout, \"genCert script for '-sslGenCert', etc.:\\n\\n\");\n\tfprintf(stdout, \"%s\\n\", genCert);\n}",
          "includes": [
            "#include \"connections.h\"",
            "#include \"ssltools.h\"",
            "#include \"sslhelper.h\"",
            "#include \"cleanup.h\"",
            "#include \"inet.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void sslScripts(void);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"connections.h\"\n#include \"ssltools.h\"\n#include \"sslhelper.h\"\n#include \"cleanup.h\"\n#include \"inet.h\"\n#include \"x11vnc.h\"\n\nvoid sslScripts(void);\n\nvoid sslScripts(void) {\n\tfprintf(stdout, \"======================================================\\n\");\n\tfprintf(stdout, \"genCA script for '-sslGenCA':\\n\\n\");\n\tfprintf(stdout, \"%s\\n\", genCA);\n\tfprintf(stdout, \"======================================================\\n\");\n\tfprintf(stdout, \"genCert script for '-sslGenCert', etc.:\\n\\n\");\n\tfprintf(stdout, \"%s\\n\", genCert);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "arg",
            "\"-sslScripts\""
          ],
          "line": 2917
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sslEncKey",
          "args": [
            "s",
            "2"
          ],
          "line": 2912
        },
        "resolved": true,
        "details": {
          "function_name": "sslEncKey",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/sslcmds.c",
          "lines": "647-907",
          "snippet": "void sslEncKey(char *path, int mode) {\n\tchar *openssl = find_openssl_bin();\n\tchar *scr, *cert = NULL, *tca, *cdir = NULL;\n\tchar line[1024], tmp[] = \"/tmp/x11vnc-tmp.XXXXXX\";\n\tint tmp_fd, incert, info_only = 0, delete_only = 0, listlong = 0;\n\tstruct stat sbuf;\n\tFILE *file;\n\tstatic int depth = 0;\n\n\tif (depth > 0) {\n\t\t/* get_saved_pem may call us back. */\n\t\treturn;\n\t}\n\n\tif (! path) {\n\t\treturn;\n\t}\n\n\tdepth++;\n\n\tif (mode == 1) {\n\t\tinfo_only = 1;\n\t} else if (mode == 2) {\n\t\tdelete_only = 1;\n\t}\n\n\tif (! openssl) {\n\t\texit(1);\n\t}\n\n\tcdir = get_Cert_dir(NULL, &tca);\n\tif (! cdir || ! tca) {\n\t\tfprintf(stderr, \"could not find Cert dir\\n\");\n\t\texit(1);\n\t}\n\n\tif (!strcasecmp(path, \"LL\") || !strcasecmp(path, \"LISTL\")) {\n\t\tlistlong = 1;\n\t\tpath = \"LIST\";\n\t}\n\n\tif (strstr(path, \"SAVE\") == path) {\n\t\tchar *p = get_saved_pem(path, 0);\n\t\tif (p == NULL) {\n\t\t\tfprintf(stderr, \"could not find saved pem \"\n\t\t\t    \"matching: %s\\n\", path);\n\t\t\texit(1);\n\t\t}\n\t\tpath = p;\n\n\t} else if (!strcmp(path, \"CA\")) {\n\t\ttca = (char *) malloc(strlen(cdir)+strlen(\"/CA/cacert.pem\")+1);\n\t\tsprintf(tca, \"%s/CA/cacert.pem\", cdir);\n\t\tpath = tca;\n\n\t} else if (info_only && (!strcasecmp(path, \"LIST\") ||\n\t    !strcasecmp(path, \"LS\") || !strcasecmp(path, \"ALL\"))) {\n\n\t\tif (! program_name || strchr(program_name, ' ')) {\n\t\t\tfprintf(stderr, \"bad program name.\\n\");\n\t\t\texit(1);\n\t\t}\n\t\tif (strchr(cdir, '\\'')) {\n\t\t\tfprintf(stderr, \"bad certdir char: %s\\n\", cdir);\n\t\t\texit(1);\n\t\t}\n\n\t\ttca = (char *) malloc(2*strlen(cdir)+strlen(program_name)+1000);\n\n\t\tsprintf(tca, \"find '%s' | egrep '/(CA|tmp|clients)$|\"\n\t\t    \"\\\\.(crt|pem|key|req)$' | grep -v CA/newcerts\", cdir);\n\n\t\tif (!strcasecmp(path, \"ALL\")) {\n\t\t\t/* ugh.. */\n\t\t\tstrcat(tca, \" | egrep -v 'private/cakey.pem|\"\n\t\t\t    \"(CA|tmp|clients)$' | xargs -n1 \");\n\t\t\tstrcat(tca, program_name);\n\t\t\tstrcat(tca, \" -ssldir '\");\n\t\t\tstrcat(tca, cdir);\n\t\t\tstrcat(tca, \"' -sslCertInfo 2>&1 \");\n\t\t} else if (listlong) {\n\t\t\tstrcat(tca, \" | xargs ls -ld \");\n\t\t}\n\t\tsystem(tca);\n\t\tfree(tca);\n\n\t\tdepth--;\n\t\treturn;\n\n\t} else if (info_only && (!strcasecmp(path, \"HASHON\")\n\t    || !strcasecmp(path, \"HASHOFF\"))) {\n\n\t\ttmp_fd = mkstemp(tmp);\n\t\tif (tmp_fd < 0) {\n\t\t\texit(1);\n\t\t}\n\n\t\twrite(tmp_fd, genCert, strlen(genCert));\n\t\tclose(tmp_fd);\n\n\t\tscr = (char *) malloc(strlen(\"/bin/sh \") + strlen(tmp) + 1);\n\t\tsprintf(scr, \"/bin/sh %s\", tmp);\n\n\t\tset_env(\"BASE_DIR\", cdir);\n\t\tset_env(\"OPENSSL\", openssl);\n\t\tset_env(\"TYPE\", \"server\");\n\t\tif (!strcasecmp(path, \"HASHON\")) {\n\t\t\tset_env(\"HASHON\", \"1\");\n\t\t} else {\n\t\t\tset_env(\"HASHOFF\", \"1\");\n\t\t}\n\t\tsystem(scr);\n\t\tunlink(tmp);\n\t\tfree(scr);\n\n\t\tdepth--;\n\t\treturn;\n\t}\n\n\n\tif (stat(path, &sbuf) != 0) {\n\t    if (strstr(path, \"client\") || strchr(path, '/') == NULL) {\n\t\tint i;\n\t\ttca = (char *) malloc(strlen(cdir) + strlen(path) + 100);\n\t\tfor (i = 1; i <= 15; i++)  {\n\t\t\ttca[0] = '\\0';\n\t\t\tif (       i == 1) {\n\t\t\t    sprintf(tca, \"%s/%s\", cdir, path); \n\t\t\t} else if (i == 2 && mode > 0) {\n\t\t\t    sprintf(tca, \"%s/%s.crt\", cdir, path); \n\t\t\t} else if (i == 3) {\n\t\t\t    sprintf(tca, \"%s/%s.pem\", cdir, path); \n\t\t\t} else if (i == 4 && mode > 1) {\n\t\t\t    sprintf(tca, \"%s/%s.req\", cdir, path); \n\t\t\t} else if (i == 5 && mode > 1) {\n\t\t\t    sprintf(tca, \"%s/%s.key\", cdir, path); \n\t\t\t} else if (i == 6) {\n\t\t\t    sprintf(tca, \"%s/clients/%s\", cdir, path); \n\t\t\t} else if (i == 7 && mode > 0) {\n\t\t\t    sprintf(tca, \"%s/clients/%s.crt\", cdir, path); \n\t\t\t} else if (i == 8) {\n\t\t\t    sprintf(tca, \"%s/clients/%s.pem\", cdir, path); \n\t\t\t} else if (i == 9 && mode > 1) {\n\t\t\t    sprintf(tca, \"%s/clients/%s.req\", cdir, path); \n\t\t\t} else if (i == 10 && mode > 1) {\n\t\t\t    sprintf(tca, \"%s/clients/%s.key\", cdir, path); \n\t\t\t} else if (i == 11) {\n\t\t\t    sprintf(tca, \"%s/server-%s\", cdir, path); \n\t\t\t} else if (i == 12 && mode > 0) {\n\t\t\t    sprintf(tca, \"%s/server-%s.crt\", cdir, path); \n\t\t\t} else if (i == 13) {\n\t\t\t    sprintf(tca, \"%s/server-%s.pem\", cdir, path); \n\t\t\t} else if (i == 14 && mode > 1) {\n\t\t\t    sprintf(tca, \"%s/server-%s.req\", cdir, path); \n\t\t\t} else if (i == 15 && mode > 1) {\n\t\t\t    sprintf(tca, \"%s/server-%s.key\", cdir, path); \n\t\t\t}\n\t\t\tif (tca[0] == '\\0') {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (stat(tca, &sbuf) == 0) {\n\t\t\t\tpath = tca;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t    }\n\t}\n\n\tif (stat(path, &sbuf) != 0) {\n\t\trfbLog(\"sslEncKey: %s\\n\", path);\n\t\trfbLogPerror(\"stat\");\n\t\texit(1);\n\t}\n\n\tif (! info_only) {\n\t\tcert = (char *) malloc(2*(sbuf.st_size + 1024));\n\t\tfile = fopen(path, \"r\");\n\t\tif (file == NULL) {\n\t\t\trfbLog(\"sslEncKey: %s\\n\", path);\n\t\t\trfbLogPerror(\"fopen\");\n\t\t\texit(1);\n\t\t}\n\t\tincert = 0;\n\t\tcert[0] = '\\0';\n\t\twhile (fgets(line, sizeof line, file) != NULL) {\n\t\t\tif (strstr(line, \"-----BEGIN CERTIFICATE-----\")\n\t\t\t    == line) {\n\t\t\t\tincert = 1;\n\t\t\t}\n\t\t\tif (incert) {\n\t\t\t\tif (strlen(cert)+strlen(line) <\n\t\t\t\t    2 * (size_t) sbuf.st_size) {\n\t\t\t\t\tstrcat(cert, line);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (strstr(line, \"-----END CERTIFICATE-----\")\n\t\t\t    == line) {\n\t\t\t\tincert = 0;\n\t\t\t}\n\t\t}\n\t\tfclose(file);\n\t}\n\n\ttmp_fd = mkstemp(tmp);\n\tif (tmp_fd < 0) {\n\t\texit(1);\n\t}\n\n\twrite(tmp_fd, genCert, strlen(genCert));\n\tclose(tmp_fd);\n\n        scr = (char *) malloc(strlen(\"/bin/sh \") + strlen(tmp) + 1);\n\tsprintf(scr, \"/bin/sh %s\", tmp);\n\n\tset_env(\"BASE_DIR\", \"/no/such/dir\");\n\tset_env(\"OPENSSL\", openssl);\n\tset_env(\"TYPE\", \"server\");\n\tif (info_only) {\n\t\tset_env(\"INFO_ONLY\", path);\n\t} else if (delete_only) {\n\t\tset_env(\"DELETE_ONLY\", path);\n\t} else {\n\t\tset_env(\"ENCRYPT_ONLY\", path);\n\t}\n\tsystem(scr);\n\tunlink(tmp);\n\n\tif (! mode && cert && cert[0] != '\\0') {\n\t\tint got_cert = 0;\n\t\tfile = fopen(path, \"r\");\n\t\tif (file == NULL) {\n\t\t\trfbLog(\"sslEncKey: %s\\n\", path);\n\t\t\trfbLogPerror(\"fopen\");\n\t\t\texit(1);\n\t\t}\n\t\twhile (fgets(line, sizeof line, file) != NULL) {\n\t\t\tif (strstr(line, \"-----BEGIN CERTIFICATE-----\")\n\t\t\t    == line) {\n\t\t\t\tgot_cert++;\n\t\t\t}\n\t\t\tif (strstr(line, \"-----END CERTIFICATE-----\")\n\t\t\t    == line) {\n\t\t\t\tgot_cert++;\n\t\t\t}\n\t\t}\n\t\tfclose(file);\n\t\tif (got_cert < 2) {\n\t\t\tfile = fopen(path, \"a\");\n\t\t\tif (file == NULL) {\n\t\t\t\trfbLog(\"sslEncKey: %s\\n\", path);\n\t\t\t\trfbLogPerror(\"fopen\");\n\t\t\t\texit(1);\n\t\t\t}\n\t\t\tfprintf(file, \"%s\", cert);\n\t\t\tfclose(file);\n\t\t}\n\t\tfree(cert);\n\t}\n\n\tdepth--;\n}",
          "includes": [
            "#include \"connections.h\"",
            "#include \"ssltools.h\"",
            "#include \"sslhelper.h\"",
            "#include \"cleanup.h\"",
            "#include \"inet.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void sslGenCA(char *cdir);",
            "void sslEncKey(char *path, int info_only);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"connections.h\"\n#include \"ssltools.h\"\n#include \"sslhelper.h\"\n#include \"cleanup.h\"\n#include \"inet.h\"\n#include \"x11vnc.h\"\n\nvoid sslGenCA(char *cdir);\nvoid sslEncKey(char *path, int info_only);\n\nvoid sslEncKey(char *path, int mode) {\n\tchar *openssl = find_openssl_bin();\n\tchar *scr, *cert = NULL, *tca, *cdir = NULL;\n\tchar line[1024], tmp[] = \"/tmp/x11vnc-tmp.XXXXXX\";\n\tint tmp_fd, incert, info_only = 0, delete_only = 0, listlong = 0;\n\tstruct stat sbuf;\n\tFILE *file;\n\tstatic int depth = 0;\n\n\tif (depth > 0) {\n\t\t/* get_saved_pem may call us back. */\n\t\treturn;\n\t}\n\n\tif (! path) {\n\t\treturn;\n\t}\n\n\tdepth++;\n\n\tif (mode == 1) {\n\t\tinfo_only = 1;\n\t} else if (mode == 2) {\n\t\tdelete_only = 1;\n\t}\n\n\tif (! openssl) {\n\t\texit(1);\n\t}\n\n\tcdir = get_Cert_dir(NULL, &tca);\n\tif (! cdir || ! tca) {\n\t\tfprintf(stderr, \"could not find Cert dir\\n\");\n\t\texit(1);\n\t}\n\n\tif (!strcasecmp(path, \"LL\") || !strcasecmp(path, \"LISTL\")) {\n\t\tlistlong = 1;\n\t\tpath = \"LIST\";\n\t}\n\n\tif (strstr(path, \"SAVE\") == path) {\n\t\tchar *p = get_saved_pem(path, 0);\n\t\tif (p == NULL) {\n\t\t\tfprintf(stderr, \"could not find saved pem \"\n\t\t\t    \"matching: %s\\n\", path);\n\t\t\texit(1);\n\t\t}\n\t\tpath = p;\n\n\t} else if (!strcmp(path, \"CA\")) {\n\t\ttca = (char *) malloc(strlen(cdir)+strlen(\"/CA/cacert.pem\")+1);\n\t\tsprintf(tca, \"%s/CA/cacert.pem\", cdir);\n\t\tpath = tca;\n\n\t} else if (info_only && (!strcasecmp(path, \"LIST\") ||\n\t    !strcasecmp(path, \"LS\") || !strcasecmp(path, \"ALL\"))) {\n\n\t\tif (! program_name || strchr(program_name, ' ')) {\n\t\t\tfprintf(stderr, \"bad program name.\\n\");\n\t\t\texit(1);\n\t\t}\n\t\tif (strchr(cdir, '\\'')) {\n\t\t\tfprintf(stderr, \"bad certdir char: %s\\n\", cdir);\n\t\t\texit(1);\n\t\t}\n\n\t\ttca = (char *) malloc(2*strlen(cdir)+strlen(program_name)+1000);\n\n\t\tsprintf(tca, \"find '%s' | egrep '/(CA|tmp|clients)$|\"\n\t\t    \"\\\\.(crt|pem|key|req)$' | grep -v CA/newcerts\", cdir);\n\n\t\tif (!strcasecmp(path, \"ALL\")) {\n\t\t\t/* ugh.. */\n\t\t\tstrcat(tca, \" | egrep -v 'private/cakey.pem|\"\n\t\t\t    \"(CA|tmp|clients)$' | xargs -n1 \");\n\t\t\tstrcat(tca, program_name);\n\t\t\tstrcat(tca, \" -ssldir '\");\n\t\t\tstrcat(tca, cdir);\n\t\t\tstrcat(tca, \"' -sslCertInfo 2>&1 \");\n\t\t} else if (listlong) {\n\t\t\tstrcat(tca, \" | xargs ls -ld \");\n\t\t}\n\t\tsystem(tca);\n\t\tfree(tca);\n\n\t\tdepth--;\n\t\treturn;\n\n\t} else if (info_only && (!strcasecmp(path, \"HASHON\")\n\t    || !strcasecmp(path, \"HASHOFF\"))) {\n\n\t\ttmp_fd = mkstemp(tmp);\n\t\tif (tmp_fd < 0) {\n\t\t\texit(1);\n\t\t}\n\n\t\twrite(tmp_fd, genCert, strlen(genCert));\n\t\tclose(tmp_fd);\n\n\t\tscr = (char *) malloc(strlen(\"/bin/sh \") + strlen(tmp) + 1);\n\t\tsprintf(scr, \"/bin/sh %s\", tmp);\n\n\t\tset_env(\"BASE_DIR\", cdir);\n\t\tset_env(\"OPENSSL\", openssl);\n\t\tset_env(\"TYPE\", \"server\");\n\t\tif (!strcasecmp(path, \"HASHON\")) {\n\t\t\tset_env(\"HASHON\", \"1\");\n\t\t} else {\n\t\t\tset_env(\"HASHOFF\", \"1\");\n\t\t}\n\t\tsystem(scr);\n\t\tunlink(tmp);\n\t\tfree(scr);\n\n\t\tdepth--;\n\t\treturn;\n\t}\n\n\n\tif (stat(path, &sbuf) != 0) {\n\t    if (strstr(path, \"client\") || strchr(path, '/') == NULL) {\n\t\tint i;\n\t\ttca = (char *) malloc(strlen(cdir) + strlen(path) + 100);\n\t\tfor (i = 1; i <= 15; i++)  {\n\t\t\ttca[0] = '\\0';\n\t\t\tif (       i == 1) {\n\t\t\t    sprintf(tca, \"%s/%s\", cdir, path); \n\t\t\t} else if (i == 2 && mode > 0) {\n\t\t\t    sprintf(tca, \"%s/%s.crt\", cdir, path); \n\t\t\t} else if (i == 3) {\n\t\t\t    sprintf(tca, \"%s/%s.pem\", cdir, path); \n\t\t\t} else if (i == 4 && mode > 1) {\n\t\t\t    sprintf(tca, \"%s/%s.req\", cdir, path); \n\t\t\t} else if (i == 5 && mode > 1) {\n\t\t\t    sprintf(tca, \"%s/%s.key\", cdir, path); \n\t\t\t} else if (i == 6) {\n\t\t\t    sprintf(tca, \"%s/clients/%s\", cdir, path); \n\t\t\t} else if (i == 7 && mode > 0) {\n\t\t\t    sprintf(tca, \"%s/clients/%s.crt\", cdir, path); \n\t\t\t} else if (i == 8) {\n\t\t\t    sprintf(tca, \"%s/clients/%s.pem\", cdir, path); \n\t\t\t} else if (i == 9 && mode > 1) {\n\t\t\t    sprintf(tca, \"%s/clients/%s.req\", cdir, path); \n\t\t\t} else if (i == 10 && mode > 1) {\n\t\t\t    sprintf(tca, \"%s/clients/%s.key\", cdir, path); \n\t\t\t} else if (i == 11) {\n\t\t\t    sprintf(tca, \"%s/server-%s\", cdir, path); \n\t\t\t} else if (i == 12 && mode > 0) {\n\t\t\t    sprintf(tca, \"%s/server-%s.crt\", cdir, path); \n\t\t\t} else if (i == 13) {\n\t\t\t    sprintf(tca, \"%s/server-%s.pem\", cdir, path); \n\t\t\t} else if (i == 14 && mode > 1) {\n\t\t\t    sprintf(tca, \"%s/server-%s.req\", cdir, path); \n\t\t\t} else if (i == 15 && mode > 1) {\n\t\t\t    sprintf(tca, \"%s/server-%s.key\", cdir, path); \n\t\t\t}\n\t\t\tif (tca[0] == '\\0') {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (stat(tca, &sbuf) == 0) {\n\t\t\t\tpath = tca;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t    }\n\t}\n\n\tif (stat(path, &sbuf) != 0) {\n\t\trfbLog(\"sslEncKey: %s\\n\", path);\n\t\trfbLogPerror(\"stat\");\n\t\texit(1);\n\t}\n\n\tif (! info_only) {\n\t\tcert = (char *) malloc(2*(sbuf.st_size + 1024));\n\t\tfile = fopen(path, \"r\");\n\t\tif (file == NULL) {\n\t\t\trfbLog(\"sslEncKey: %s\\n\", path);\n\t\t\trfbLogPerror(\"fopen\");\n\t\t\texit(1);\n\t\t}\n\t\tincert = 0;\n\t\tcert[0] = '\\0';\n\t\twhile (fgets(line, sizeof line, file) != NULL) {\n\t\t\tif (strstr(line, \"-----BEGIN CERTIFICATE-----\")\n\t\t\t    == line) {\n\t\t\t\tincert = 1;\n\t\t\t}\n\t\t\tif (incert) {\n\t\t\t\tif (strlen(cert)+strlen(line) <\n\t\t\t\t    2 * (size_t) sbuf.st_size) {\n\t\t\t\t\tstrcat(cert, line);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (strstr(line, \"-----END CERTIFICATE-----\")\n\t\t\t    == line) {\n\t\t\t\tincert = 0;\n\t\t\t}\n\t\t}\n\t\tfclose(file);\n\t}\n\n\ttmp_fd = mkstemp(tmp);\n\tif (tmp_fd < 0) {\n\t\texit(1);\n\t}\n\n\twrite(tmp_fd, genCert, strlen(genCert));\n\tclose(tmp_fd);\n\n        scr = (char *) malloc(strlen(\"/bin/sh \") + strlen(tmp) + 1);\n\tsprintf(scr, \"/bin/sh %s\", tmp);\n\n\tset_env(\"BASE_DIR\", \"/no/such/dir\");\n\tset_env(\"OPENSSL\", openssl);\n\tset_env(\"TYPE\", \"server\");\n\tif (info_only) {\n\t\tset_env(\"INFO_ONLY\", path);\n\t} else if (delete_only) {\n\t\tset_env(\"DELETE_ONLY\", path);\n\t} else {\n\t\tset_env(\"ENCRYPT_ONLY\", path);\n\t}\n\tsystem(scr);\n\tunlink(tmp);\n\n\tif (! mode && cert && cert[0] != '\\0') {\n\t\tint got_cert = 0;\n\t\tfile = fopen(path, \"r\");\n\t\tif (file == NULL) {\n\t\t\trfbLog(\"sslEncKey: %s\\n\", path);\n\t\t\trfbLogPerror(\"fopen\");\n\t\t\texit(1);\n\t\t}\n\t\twhile (fgets(line, sizeof line, file) != NULL) {\n\t\t\tif (strstr(line, \"-----BEGIN CERTIFICATE-----\")\n\t\t\t    == line) {\n\t\t\t\tgot_cert++;\n\t\t\t}\n\t\t\tif (strstr(line, \"-----END CERTIFICATE-----\")\n\t\t\t    == line) {\n\t\t\t\tgot_cert++;\n\t\t\t}\n\t\t}\n\t\tfclose(file);\n\t\tif (got_cert < 2) {\n\t\t\tfile = fopen(path, \"a\");\n\t\t\tif (file == NULL) {\n\t\t\t\trfbLog(\"sslEncKey: %s\\n\", path);\n\t\t\t\trfbLogPerror(\"fopen\");\n\t\t\t\texit(1);\n\t\t\t}\n\t\t\tfprintf(file, \"%s\", cert);\n\t\t\tfclose(file);\n\t\t}\n\t\tfree(cert);\n\t}\n\n\tdepth--;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "arg",
            "\"-sslDelCert\""
          ],
          "line": 2909
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "arg",
            "\"-sslCertInfo\""
          ],
          "line": 2901
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "arg",
            "\"-sslEncKey\""
          ],
          "line": 2893
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sslGenCert",
          "args": [
            "ty",
            "nm"
          ],
          "line": 2889
        },
        "resolved": true,
        "details": {
          "function_name": "sslGenCert",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/sslcmds.c",
          "lines": "611-645",
          "snippet": "void sslGenCert(char *ty, char *nm) {\n\tchar *cmd, *scr = getsslscript(NULL, \"gencert\", genCert);\n\n\tif (! scr) {\n\t\texit(1);\n\t}\n\n\tcmd = (char *)malloc(strlen(\"/bin/sh \") + strlen(scr) + 1);\n\tsprintf(cmd, \"/bin/sh %s\", scr);\n\n\tif (! ty) {\n\t\tset_env(\"TYPE\", \"\");\n\t} else {\n\t\tset_env(\"TYPE\", ty);\n\t}\n\tif (! nm) {\n\t\tset_env(\"NAME\", \"\");\n\t} else {\n\t\tchar *q = strstr(nm, \"SAVE-\");\n\t\tif (!strcmp(nm, \"SAVE\")) {\n\t\t\tset_env(\"NAME\", \"\");\n\t\t} else if (q == nm) {\n\t\t\tq += strlen(\"SAVE-\");\n\t\t\tset_env(\"NAME\", q);\n\t\t} else {\n\t\t\tset_env(\"NAME\", nm);\n\t\t}\n\t}\n\n\tsystem(cmd);\n\tunlink(scr);\n\n\tfree(cmd);\n\tfree(scr);\n}",
          "includes": [
            "#include \"connections.h\"",
            "#include \"ssltools.h\"",
            "#include \"sslhelper.h\"",
            "#include \"cleanup.h\"",
            "#include \"inet.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void sslGenCert(char *ty, char *nm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"connections.h\"\n#include \"ssltools.h\"\n#include \"sslhelper.h\"\n#include \"cleanup.h\"\n#include \"inet.h\"\n#include \"x11vnc.h\"\n\nvoid sslGenCert(char *ty, char *nm);\n\nvoid sslGenCert(char *ty, char *nm) {\n\tchar *cmd, *scr = getsslscript(NULL, \"gencert\", genCert);\n\n\tif (! scr) {\n\t\texit(1);\n\t}\n\n\tcmd = (char *)malloc(strlen(\"/bin/sh \") + strlen(scr) + 1);\n\tsprintf(cmd, \"/bin/sh %s\", scr);\n\n\tif (! ty) {\n\t\tset_env(\"TYPE\", \"\");\n\t} else {\n\t\tset_env(\"TYPE\", ty);\n\t}\n\tif (! nm) {\n\t\tset_env(\"NAME\", \"\");\n\t} else {\n\t\tchar *q = strstr(nm, \"SAVE-\");\n\t\tif (!strcmp(nm, \"SAVE\")) {\n\t\t\tset_env(\"NAME\", \"\");\n\t\t} else if (q == nm) {\n\t\t\tq += strlen(\"SAVE-\");\n\t\t\tset_env(\"NAME\", q);\n\t\t} else {\n\t\t\tset_env(\"NAME\", nm);\n\t\t}\n\t}\n\n\tsystem(cmd);\n\tunlink(scr);\n\n\tfree(cmd);\n\tfree(scr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"or        x11vnc -sslGenCert client ...\\n\""
          ],
          "line": 2883
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"          x11vnc -sslGenCert server ...\\n\""
          ],
          "line": 2882
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Must be:\\n\""
          ],
          "line": 2881
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "ty",
            "\"client\""
          ],
          "line": 2880
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "ty",
            "\"server\""
          ],
          "line": 2880
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"or        x11vnc -sslGenCert client ...\\n\""
          ],
          "line": 2876
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"          x11vnc -sslGenCert server ...\\n\""
          ],
          "line": 2875
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Must be:\\n\""
          ],
          "line": 2874
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "arg",
            "\"-sslGenCert\""
          ],
          "line": 2871
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sslGenCA",
          "args": [
            "cdir"
          ],
          "line": 2867
        },
        "resolved": true,
        "details": {
          "function_name": "sslGenCA",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/sslcmds.c",
          "lines": "594-609",
          "snippet": "void sslGenCA(char *cdir) {\n\tchar *cmd, *scr = getsslscript(cdir, \"genca\", genCA);\n\n\tif (! scr) {\n\t\texit(1);\n\t}\n\n\tcmd = (char *)malloc(strlen(\"/bin/sh \") + strlen(scr) + 1);\n\tsprintf(cmd, \"/bin/sh %s\", scr);\n\n\tsystem(cmd);\n\tunlink(scr);\n\n\tfree(cmd);\n\tfree(scr);\n}",
          "includes": [
            "#include \"connections.h\"",
            "#include \"ssltools.h\"",
            "#include \"sslhelper.h\"",
            "#include \"cleanup.h\"",
            "#include \"inet.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void sslGenCA(char *cdir);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"connections.h\"\n#include \"ssltools.h\"\n#include \"sslhelper.h\"\n#include \"cleanup.h\"\n#include \"inet.h\"\n#include \"x11vnc.h\"\n\nvoid sslGenCA(char *cdir);\n\nvoid sslGenCA(char *cdir) {\n\tchar *cmd, *scr = getsslscript(cdir, \"genca\", genCA);\n\n\tif (! scr) {\n\t\texit(1);\n\t}\n\n\tcmd = (char *)malloc(strlen(\"/bin/sh \") + strlen(scr) + 1);\n\tsprintf(cmd, \"/bin/sh %s\", scr);\n\n\tsystem(cmd);\n\tunlink(scr);\n\n\tfree(cmd);\n\tfree(scr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "s"
          ],
          "line": 2863
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "arg",
            "\"-sslGenCA\""
          ],
          "line": 2858
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "argv[++i]"
          ],
          "line": 2854
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "arg",
            "\"-sslCRL\""
          ],
          "line": 2852
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "argv[++i]"
          ],
          "line": 2848
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "arg",
            "\"-sslverify\""
          ],
          "line": 2846
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "argv[++i]"
          ],
          "line": 2843
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "arg",
            "\"-ssldir\""
          ],
          "line": 2841
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "arg",
            "\"-sslnofail\""
          ],
          "line": 2837
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atoi",
          "args": [
            "argv[++i]"
          ],
          "line": 2834
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "arg",
            "\"-ssltimeout\""
          ],
          "line": 2832
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "\"none\""
          ],
          "line": 2829
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "arg",
            "\"-http_oneport\""
          ],
          "line": 2826
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "argv[++i]"
          ],
          "line": 2823
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "arg",
            "\"-enc\""
          ],
          "line": 2820
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "\"SAVE\""
          ],
          "line": 2816
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "\"SAVE\""
          ],
          "line": 2813
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "s"
          ],
          "line": 2809
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "s",
            "\"TMP\""
          ],
          "line": 2806
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "\"ANON\""
          ],
          "line": 2805
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "s",
            "\"ANONDH\""
          ],
          "line": 2804
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "\"ANON\""
          ],
          "line": 2803
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "s",
            "\"ADH\""
          ],
          "line": 2802
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "arg",
            "\"-ssl\""
          ],
          "line": 2797
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "arg",
            "\"-nossl\""
          ],
          "line": 2791
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "argv[++i]"
          ],
          "line": 2787
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "arg",
            "\"-dhparams\""
          ],
          "line": 2785
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "arg",
            "\"-sslonly\""
          ],
          "line": 2779
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "s",
            "\"newdh\""
          ],
          "line": 2773
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"invalid %s arg: %s\\n\"",
            "arg",
            "s"
          ],
          "line": 2770
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "s",
            "\"force\""
          ],
          "line": 2767
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "s",
            "\"only\""
          ],
          "line": 2765
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "s",
            "\"support\""
          ],
          "line": 2763
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "s",
            "\"never\""
          ],
          "line": 2761
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "argv[++i]"
          ],
          "line": 2759
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "arg",
            "\"-anontls\""
          ],
          "line": 2756
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "s",
            "\"plain\""
          ],
          "line": 2750
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "s",
            "\"noplain\""
          ],
          "line": 2748
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "s",
            "\"newdh\""
          ],
          "line": 2745
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "s",
            "\"nox509\""
          ],
          "line": 2742
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "s",
            "\"nodh\""
          ],
          "line": 2740
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"invalid %s arg: %s\\n\"",
            "arg",
            "s"
          ],
          "line": 2737
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "s",
            "\"force\""
          ],
          "line": 2734
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "s",
            "\"only\""
          ],
          "line": 2732
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "s",
            "\"support\""
          ],
          "line": 2730
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "s",
            "\"never\""
          ],
          "line": 2728
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "argv[++i]"
          ],
          "line": 2726
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "arg",
            "\"-vencrypt\""
          ],
          "line": 2723
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "arg",
            "\"-nounixpw\""
          ],
          "line": 2712
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_env",
          "args": [
            "\"UNIXPW_DISABLE_LOCALHOST\"",
            "\"1\""
          ],
          "line": 2708
        },
        "resolved": true,
        "details": {
          "function_name": "set_env",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/util.c",
          "lines": "239-249",
          "snippet": "void set_env(char *name, char *value) {\n\tchar *str;\n\tif (! name) {\n\t\treturn;\n\t}\n\tif (! value) {\n\t\tvalue = \"\";\n\t}\n\n\tsetenv(name, value, 1);\n}",
          "includes": [
            "#include \"connections.h\"",
            "#include \"unixpw.h\"",
            "#include \"win_utils.h\"",
            "#include \"cleanup.h\"",
            "#include \"x11vnc.h\"",
            "#include <stdlib.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void lowercase(char *str);",
            "void uppercase(char *str);",
            "char *lblanks(char *str);",
            "void strzero(char *str);",
            "void set_env(char *name, char *value);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"connections.h\"\n#include \"unixpw.h\"\n#include \"win_utils.h\"\n#include \"cleanup.h\"\n#include \"x11vnc.h\"\n#include <stdlib.h>\n\nvoid lowercase(char *str);\nvoid uppercase(char *str);\nchar *lblanks(char *str);\nvoid strzero(char *str);\nvoid set_env(char *name, char *value);\n\nvoid set_env(char *name, char *value) {\n\tchar *str;\n\tif (! name) {\n\t\treturn;\n\t}\n\tif (! value) {\n\t\tvalue = \"\";\n\t}\n\n\tsetenv(name, value, 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "arg",
            "\"_unsafe\""
          ],
          "line": 2705
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "quick_pw",
          "args": [
            "s"
          ],
          "line": 2701
        },
        "resolved": true,
        "details": {
          "function_name": "quick_pw",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/x11vnc.c",
          "lines": "1331-1443",
          "snippet": "static void quick_pw(char *str) {\n\tchar *p, *q;\n\tchar tmp[1024];\n\tint db = 0;\n\n\tif (db) fprintf(stderr, \"quick_pw: %s\\n\", str);\n\n\tif (! str || str[0] == '\\0') {\n\t\texit(2);\n\t}\n\tif (str[0] != '%') {\n\t\texit(2);\n\t}\n\t/*\n\t * \"%-\" or \"%stdin\" means read one line from stdin.\n\t *\n\t * \"%env\" means it is in $UNIXPW env var.\n\t *\n\t * starting \"%/\" or \"%.\" means read the first line from that file.\n\t *\n\t * \"%%\" or \"%\" means prompt user.\n\t *\n\t * otherwise: %user:pass\n\t */\n\tif (!strcmp(str, \"%-\") || !strcmp(str, \"%stdin\")) {\n\t\tif(fgets(tmp, 1024, stdin) == NULL) {\n\t\t\texit(2);\n\t\t}\n\t\tq = strdup(tmp);\n\t} else if (!strcmp(str, \"%env\")) {\n\t\tif (getenv(\"UNIXPW\") == NULL) {\n\t\t\texit(2);\n\t\t}\n\t\tq = strdup(getenv(\"UNIXPW\"));\n\t} else if (!strcmp(str, \"%%\") || !strcmp(str, \"%\")) {\n\t\tchar *t, inp[1024];\n\t\tfprintf(stdout, \"username: \");\n\t\tif(fgets(tmp, 128, stdin) == NULL) {\n\t\t\texit(2);\n\t\t}\n\t\tstrcpy(inp, tmp);\n\t\tt = strchr(inp, '\\n');\n\t\tif (t) {\n\t\t\t*t = ':'; \n\t\t} else {\n\t\t\tstrcat(inp, \":\");\n\t\t\t\n\t\t}\n\t\tfprintf(stdout, \"password: \");\n\t\t/* test mode: no_external_cmds does not apply */\n\t\tsystem(\"stty -echo\");\n\t\tif(fgets(tmp, 128, stdin) == NULL) {\n\t\t\tfprintf(stdout, \"\\n\");\n\t\t\tsystem(\"stty echo\");\n\t\t\texit(2);\n\t\t}\n\t\tsystem(\"stty echo\");\n\t\tfprintf(stdout, \"\\n\");\n\t\tstrcat(inp, tmp);\n\t\tq = strdup(inp);\n\t} else if (str[1] == '/' || str[1] == '.') {\n\t\tFILE *in = fopen(str+1, \"r\");\n\t\tif (in == NULL) {\n\t\t\texit(2);\n\t\t}\n\t\tif(fgets(tmp, 1024, in) == NULL) {\n\t\t\texit(2);\n\t\t}\n\t\tfclose(in);\n\t\tq = strdup(tmp);\n\t} else {\n\t\tq = strdup(str+1);\n\t}\n\tp = (char *) malloc(strlen(q) + 10);\n\tstrcpy(p, q);\n\tif (strchr(p, '\\n') == NULL) {\n\t\tstrcat(p, \"\\n\");\n\t}\n\n\tif ((q = strchr(p, ':')) == NULL) {\n\t\texit(2);\n\t}\n\t*q = '\\0';\n\tif (db) fprintf(stderr, \"'%s' '%s'\\n\", p, q+1);\n\tif (unixpw_cmd) {\n\t\tif (cmd_verify(p, q+1)) {\n\t\t\tfprintf(stdout, \"Y %s\\n\", p);\n\t\t\texit(0);\n\t\t} else {\n\t\t\tfprintf(stdout, \"N %s\\n\", p);\n\t\t\texit(1);\n\t\t}\n\t} else if (unixpw_nis) {\n\t\tif (crypt_verify(p, q+1)) {\n\t\t\tfprintf(stdout, \"Y %s\\n\", p);\n\t\t\texit(0);\n\t\t} else {\n\t\t\tfprintf(stdout, \"N %s\\n\", p);\n\t\t\texit(1);\n\t\t}\n\t} else {\n\t\tchar *ucmd = getenv(\"UNIXPW_CMD\");\n\t\tif (su_verify(p, q+1, ucmd, NULL, NULL, 1)) {\n\t\t\tfprintf(stdout, \"Y %s\\n\", p);\n\t\t\texit(0);\n\t\t} else {\n\t\t\tfprintf(stdout, \"N %s\\n\", p);\n\t\t\texit(1);\n\t\t}\n\t}\n\t/* NOTREACHED */\n\texit(2);\n}",
          "includes": [
            "#include \"xi2_devices.h\"",
            "#include \"solid.h\"",
            "#include \"pm.h\"",
            "#include \"selection.h\"",
            "#include \"sslhelper.h\"",
            "#include \"sslcmds.h\"",
            "#include \"inet.h\"",
            "#include \"unixpw.h\"",
            "#include \"rates.h\"",
            "#include \"connections.h\"",
            "#include \"screen.h\"",
            "#include \"userinput.h\"",
            "#include \"cursor.h\"",
            "#include \"pointer.h\"",
            "#include \"keyboard.h\"",
            "#include \"cleanup.h\"",
            "#include \"user.h\"",
            "#include \"help.h\"",
            "#include \"gui.h\"",
            "#include \"scan.h\"",
            "#include \"remote.h\"",
            "#include \"win_utils.h\"",
            "#include \"xkb_bell.h\"",
            "#include \"xrandr.h\"",
            "#include \"xinerama.h\"",
            "#include \"xevents.h\"",
            "#include \"xrecord.h\"",
            "#include \"xdamage.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xi2_devices.h\"\n#include \"solid.h\"\n#include \"pm.h\"\n#include \"selection.h\"\n#include \"sslhelper.h\"\n#include \"sslcmds.h\"\n#include \"inet.h\"\n#include \"unixpw.h\"\n#include \"rates.h\"\n#include \"connections.h\"\n#include \"screen.h\"\n#include \"userinput.h\"\n#include \"cursor.h\"\n#include \"pointer.h\"\n#include \"keyboard.h\"\n#include \"cleanup.h\"\n#include \"user.h\"\n#include \"help.h\"\n#include \"gui.h\"\n#include \"scan.h\"\n#include \"remote.h\"\n#include \"win_utils.h\"\n#include \"xkb_bell.h\"\n#include \"xrandr.h\"\n#include \"xinerama.h\"\n#include \"xevents.h\"\n#include \"xrecord.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nstatic void quick_pw(char *str) {\n\tchar *p, *q;\n\tchar tmp[1024];\n\tint db = 0;\n\n\tif (db) fprintf(stderr, \"quick_pw: %s\\n\", str);\n\n\tif (! str || str[0] == '\\0') {\n\t\texit(2);\n\t}\n\tif (str[0] != '%') {\n\t\texit(2);\n\t}\n\t/*\n\t * \"%-\" or \"%stdin\" means read one line from stdin.\n\t *\n\t * \"%env\" means it is in $UNIXPW env var.\n\t *\n\t * starting \"%/\" or \"%.\" means read the first line from that file.\n\t *\n\t * \"%%\" or \"%\" means prompt user.\n\t *\n\t * otherwise: %user:pass\n\t */\n\tif (!strcmp(str, \"%-\") || !strcmp(str, \"%stdin\")) {\n\t\tif(fgets(tmp, 1024, stdin) == NULL) {\n\t\t\texit(2);\n\t\t}\n\t\tq = strdup(tmp);\n\t} else if (!strcmp(str, \"%env\")) {\n\t\tif (getenv(\"UNIXPW\") == NULL) {\n\t\t\texit(2);\n\t\t}\n\t\tq = strdup(getenv(\"UNIXPW\"));\n\t} else if (!strcmp(str, \"%%\") || !strcmp(str, \"%\")) {\n\t\tchar *t, inp[1024];\n\t\tfprintf(stdout, \"username: \");\n\t\tif(fgets(tmp, 128, stdin) == NULL) {\n\t\t\texit(2);\n\t\t}\n\t\tstrcpy(inp, tmp);\n\t\tt = strchr(inp, '\\n');\n\t\tif (t) {\n\t\t\t*t = ':'; \n\t\t} else {\n\t\t\tstrcat(inp, \":\");\n\t\t\t\n\t\t}\n\t\tfprintf(stdout, \"password: \");\n\t\t/* test mode: no_external_cmds does not apply */\n\t\tsystem(\"stty -echo\");\n\t\tif(fgets(tmp, 128, stdin) == NULL) {\n\t\t\tfprintf(stdout, \"\\n\");\n\t\t\tsystem(\"stty echo\");\n\t\t\texit(2);\n\t\t}\n\t\tsystem(\"stty echo\");\n\t\tfprintf(stdout, \"\\n\");\n\t\tstrcat(inp, tmp);\n\t\tq = strdup(inp);\n\t} else if (str[1] == '/' || str[1] == '.') {\n\t\tFILE *in = fopen(str+1, \"r\");\n\t\tif (in == NULL) {\n\t\t\texit(2);\n\t\t}\n\t\tif(fgets(tmp, 1024, in) == NULL) {\n\t\t\texit(2);\n\t\t}\n\t\tfclose(in);\n\t\tq = strdup(tmp);\n\t} else {\n\t\tq = strdup(str+1);\n\t}\n\tp = (char *) malloc(strlen(q) + 10);\n\tstrcpy(p, q);\n\tif (strchr(p, '\\n') == NULL) {\n\t\tstrcat(p, \"\\n\");\n\t}\n\n\tif ((q = strchr(p, ':')) == NULL) {\n\t\texit(2);\n\t}\n\t*q = '\\0';\n\tif (db) fprintf(stderr, \"'%s' '%s'\\n\", p, q+1);\n\tif (unixpw_cmd) {\n\t\tif (cmd_verify(p, q+1)) {\n\t\t\tfprintf(stdout, \"Y %s\\n\", p);\n\t\t\texit(0);\n\t\t} else {\n\t\t\tfprintf(stdout, \"N %s\\n\", p);\n\t\t\texit(1);\n\t\t}\n\t} else if (unixpw_nis) {\n\t\tif (crypt_verify(p, q+1)) {\n\t\t\tfprintf(stdout, \"Y %s\\n\", p);\n\t\t\texit(0);\n\t\t} else {\n\t\t\tfprintf(stdout, \"N %s\\n\", p);\n\t\t\texit(1);\n\t\t}\n\t} else {\n\t\tchar *ucmd = getenv(\"UNIXPW_CMD\");\n\t\tif (su_verify(p, q+1, ucmd, NULL, NULL, 1)) {\n\t\t\tfprintf(stdout, \"Y %s\\n\", p);\n\t\t\texit(0);\n\t\t} else {\n\t\t\tfprintf(stdout, \"N %s\\n\", p);\n\t\t\texit(1);\n\t\t}\n\t}\n\t/* NOTREACHED */\n\texit(2);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "s"
          ],
          "line": 2696
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "arg",
            "\"-unixpw_nis\""
          ],
          "line": 2690
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "arg",
            "\"-unixpw\""
          ],
          "line": 2688
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "arg",
            "\"_unsafe\""
          ],
          "line": 2681
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "argv[++i]"
          ],
          "line": 2679
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "arg",
            "\"-unixpw_cmd_unsafe\""
          ],
          "line": 2677
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "arg",
            "\"-unixpw_cmd\""
          ],
          "line": 2676
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "arg",
            "\"-unixpw_system_greeter\""
          ],
          "line": 2672
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "\"127.0.0.1\""
          ],
          "line": 2668
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "\"WAIT:cmd=FINDCREATEDISPLAY-Xvfb.xdmcp\""
          ],
          "line": 2667
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "arg",
            "\"-sshxdmsvc\""
          ],
          "line": 2666
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "\"SAVE\""
          ],
          "line": 2663
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "\"unixpw=\""
          ],
          "line": 2661
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "\"WAIT:cmd=FINDCREATEDISPLAY-Xvfb.xdmcp\""
          ],
          "line": 2659
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "arg",
            "\"-xdm_service\""
          ],
          "line": 2658
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "arg",
            "\"-xdmsvc\""
          ],
          "line": 2658
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "\"SAVE\""
          ],
          "line": 2655
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "\"unixpw=\""
          ],
          "line": 2653
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "\"WAIT:cmd=FINDCREATEDISPLAY-Xvnc\""
          ],
          "line": 2651
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "arg",
            "\"-svc_xvnc\""
          ],
          "line": 2650
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "\"SAVE\""
          ],
          "line": 2647
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "\"unixpw=\""
          ],
          "line": 2645
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "\"WAIT:cmd=FINDCREATEDISPLAY-Xdummy,Xvfb\""
          ],
          "line": 2643
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "arg",
            "\"-svc_xdummy_xvfb\""
          ],
          "line": 2642
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "\"SAVE\""
          ],
          "line": 2639
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "\"unixpw=\""
          ],
          "line": 2637
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "\"WAIT:cmd=FINDCREATEDISPLAY-Xdummy\""
          ],
          "line": 2635
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "arg",
            "\"-svc_xdummy\""
          ],
          "line": 2634
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "\"SAVE\""
          ],
          "line": 2631
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "\"unixpw=\""
          ],
          "line": 2629
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "\"WAIT:cmd=FINDCREATEDISPLAY-Xvfb\""
          ],
          "line": 2627
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "arg",
            "\"-service\""
          ],
          "line": 2626
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "arg",
            "\"-svc\""
          ],
          "line": 2626
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "argv[++i]"
          ],
          "line": 2622
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "arg",
            "\"-passwdfile\""
          ],
          "line": 2620
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "argv[++i]"
          ],
          "line": 2616
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "arg",
            "\"-viewpasswd\""
          ],
          "line": 2613
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atoi",
          "args": [
            "argv[++i]"
          ],
          "line": 2609
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "arg",
            "\"-grablocal\""
          ],
          "line": 2607
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "arg",
            "\"-grabalways\""
          ],
          "line": 2600
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "arg",
            "\"-ungrabboth\""
          ],
          "line": 2596
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "arg",
            "\"-grabptr\""
          ],
          "line": 2592
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "arg",
            "\"-grabkbd\""
          ],
          "line": 2588
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "argv[++i]"
          ],
          "line": 2585
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "arg",
            "\"-input\""
          ],
          "line": 2583
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "arg",
            "\"-noipv4\""
          ],
          "line": 2578
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "arg",
            "\"-noipv6\""
          ],
          "line": 2574
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "arg",
            "\"-no6\""
          ],
          "line": 2567
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "arg",
            "\"-6\""
          ],
          "line": 2560
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "arg",
            "\"-nolookup\""
          ],
          "line": 2556
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "argv[++i]"
          ],
          "line": 2550
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "arg",
            "\"-listen6\""
          ],
          "line": 2547
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "argv[++i]"
          ],
          "line": 2544
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "arg",
            "\"-unixsock\""
          ],
          "line": 2542
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "\"127.0.0.1\""
          ],
          "line": 2538
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "arg",
            "\"-localhost\""
          ],
          "line": 2537
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "argv[++i]"
          ],
          "line": 2534
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "arg",
            "\"-allow\""
          ],
          "line": 2532
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "arg",
            "\"-novncconnect\""
          ],
          "line": 2528
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "arg",
            "\"-vncconnect\""
          ],
          "line": 2524
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "argv[++i]"
          ],
          "line": 2521
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "arg",
            "\"-proxy\""
          ],
          "line": 2519
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "argv[i]"
          ],
          "line": 2515
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fclose",
          "args": [
            "f"
          ],
          "line": 2512
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fopen",
          "args": [
            "client_connect_file",
            "\"w\""
          ],
          "line": 2511
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "stat",
          "args": [
            "client_connect_file",
            "&sb"
          ],
          "line": 2510
        },
        "resolved": true,
        "details": {
          "function_name": "grab_state",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/connections.c",
          "lines": "3178-3224",
          "snippet": "void grab_state(int *ptr_grabbed, int *kbd_grabbed) {\n\tint rcp, rck;\n\tdouble t0, t1;\n\tdouble ta, tb, tc;\n\t*ptr_grabbed = -1;\n\t*kbd_grabbed = -1;\n\n\tif (!dpy) {\n\t\treturn;\n\t}\n\t*ptr_grabbed = 0;\n\t*kbd_grabbed = 0;\n\n#if !NO_X11\n\tX_LOCK;\n\n\tXSync(dpy, False);\n\n\tta = t0 = dnow();\n\n\trcp = XGrabPointer(dpy, window, False, 0, GrabModeAsync, GrabModeAsync, None, None, CurrentTime);\n\tXUngrabPointer(dpy, CurrentTime);\n\n\ttb = dnow();\n\t\n\trck = XGrabKeyboard(dpy, window, False, GrabModeAsync, GrabModeAsync, CurrentTime);\n\tXUngrabKeyboard(dpy, CurrentTime);\n\n\ttc = dnow();\n\n\tXSync(dpy, False);\n\n\tt1 = dnow();\n\n\tX_UNLOCK;\n\tif (rcp == AlreadyGrabbed || rcp == GrabFrozen) {\n\t\t*ptr_grabbed = 1;\n\t}\n\tif (rck == AlreadyGrabbed || rck == GrabFrozen) {\n\t\t*kbd_grabbed = 1;\n\t}\n\tif (rc_npieces < 10) {\n\t\trfbLog(\"grab_state: checked %d,%d in %.6f sec (%.6f %.6f)\\n\",\n\t\t    *ptr_grabbed, *kbd_grabbed, t1-t0, tb-ta, tc-tb);\n\t}\n#endif\n}",
          "includes": [
            "#include \"xi2_devices.h\"",
            "#include \"xrandr.h\"",
            "#include \"pointer.h\"",
            "#include \"userinput.h\"",
            "#include \"macosxCG.h\"",
            "#include \"macosx.h\"",
            "#include \"win_utils.h\"",
            "#include \"xevents.h\"",
            "#include \"xwrappers.h\"",
            "#include \"sslhelper.h\"",
            "#include \"sslcmds.h\"",
            "#include \"scan.h\"",
            "#include \"user.h\"",
            "#include \"unixpw.h\"",
            "#include \"screen.h\"",
            "#include \"rates.h\"",
            "#include \"solid.h\"",
            "#include \"gui.h\"",
            "#include \"cleanup.h\"",
            "#include \"keyboard.h\"",
            "#include \"remote.h\"",
            "#include \"inet.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void grab_state(int *ptr_grabbed, int *kbd_grabbed);",
            "extern int rc_npieces;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xi2_devices.h\"\n#include \"xrandr.h\"\n#include \"pointer.h\"\n#include \"userinput.h\"\n#include \"macosxCG.h\"\n#include \"macosx.h\"\n#include \"win_utils.h\"\n#include \"xevents.h\"\n#include \"xwrappers.h\"\n#include \"sslhelper.h\"\n#include \"sslcmds.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"unixpw.h\"\n#include \"screen.h\"\n#include \"rates.h\"\n#include \"solid.h\"\n#include \"gui.h\"\n#include \"cleanup.h\"\n#include \"keyboard.h\"\n#include \"remote.h\"\n#include \"inet.h\"\n#include \"x11vnc.h\"\n\nvoid grab_state(int *ptr_grabbed, int *kbd_grabbed);\nextern int rc_npieces;\n\nvoid grab_state(int *ptr_grabbed, int *kbd_grabbed) {\n\tint rcp, rck;\n\tdouble t0, t1;\n\tdouble ta, tb, tc;\n\t*ptr_grabbed = -1;\n\t*kbd_grabbed = -1;\n\n\tif (!dpy) {\n\t\treturn;\n\t}\n\t*ptr_grabbed = 0;\n\t*kbd_grabbed = 0;\n\n#if !NO_X11\n\tX_LOCK;\n\n\tXSync(dpy, False);\n\n\tta = t0 = dnow();\n\n\trcp = XGrabPointer(dpy, window, False, 0, GrabModeAsync, GrabModeAsync, None, None, CurrentTime);\n\tXUngrabPointer(dpy, CurrentTime);\n\n\ttb = dnow();\n\t\n\trck = XGrabKeyboard(dpy, window, False, GrabModeAsync, GrabModeAsync, CurrentTime);\n\tXUngrabKeyboard(dpy, CurrentTime);\n\n\ttc = dnow();\n\n\tXSync(dpy, False);\n\n\tt1 = dnow();\n\n\tX_UNLOCK;\n\tif (rcp == AlreadyGrabbed || rcp == GrabFrozen) {\n\t\t*ptr_grabbed = 1;\n\t}\n\tif (rck == AlreadyGrabbed || rck == GrabFrozen) {\n\t\t*kbd_grabbed = 1;\n\t}\n\tif (rc_npieces < 10) {\n\t\trfbLog(\"grab_state: checked %d,%d in %.6f sec (%.6f %.6f)\\n\",\n\t\t    *ptr_grabbed, *kbd_grabbed, t1-t0, tb-ta, tc-tb);\n\t}\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "argv[i]"
          ],
          "line": 2509
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "argv[i]",
            "\"repeater://\""
          ],
          "line": 2507
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "argv[++i]",
            "'/'"
          ],
          "line": 2507
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "arg",
            "\"-coe\""
          ],
          "line": 2504
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "arg",
            "\"-coe\""
          ],
          "line": 2500
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "arg",
            "\"-connect_or_exit\""
          ],
          "line": 2499
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "arg",
            "\"-connect\""
          ],
          "line": 2498
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "arg",
            "\"-zeroconf\""
          ],
          "line": 2494
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "arg",
            "\"-mdns\""
          ],
          "line": 2494
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "arg",
            "\"-avahi\""
          ],
          "line": 2494
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "arg",
            "\"-http_ssl\""
          ],
          "line": 2488
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "arg",
            "\"-http\""
          ],
          "line": 2484
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "arg",
            "\"-tightfilexfer\""
          ],
          "line": 2480
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "arg",
            "\"-notightfilexfer\""
          ],
          "line": 2476
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "arg",
            "\"-inetd\""
          ],
          "line": 2472
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "argv[++i]"
          ],
          "line": 2469
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "arg",
            "\"-users\""
          ],
          "line": 2467
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "arg",
            "\"-sleepin\""
          ],
          "line": 2462
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atoi",
          "args": [
            "argv[++i]"
          ],
          "line": 2459
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "arg",
            "\"-timeout\""
          ],
          "line": 2457
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "arg",
            "\"-freeze_when_obscured\""
          ],
          "line": 2453
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "arg",
            "\"-appshare\""
          ],
          "line": 2449
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "arg",
            "\"-loop\""
          ],
          "line": 2445
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "arg",
            "\"-forever\""
          ],
          "line": 2441
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "arg",
            "\"-many\""
          ],
          "line": 2441
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "arg",
            "\"-once\""
          ],
          "line": 2436
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "arg",
            "\"-noshared\""
          ],
          "line": 2432
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "arg",
            "\"-shared\""
          ],
          "line": 2428
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "arg",
            "\"-noviewonly\""
          ],
          "line": 2423
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "arg",
            "\"-viewonly\""
          ],
          "line": 2419
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "argv[++i]"
          ],
          "line": 2416
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "arg",
            "\"-scale_cursor\""
          ],
          "line": 2414
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "argv[++i]"
          ],
          "line": 2411
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "arg",
            "\"-geometry\""
          ],
          "line": 2409
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "argv[++i]"
          ],
          "line": 2406
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "arg",
            "\"-scale\""
          ],
          "line": 2404
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "argv[++i]"
          ],
          "line": 2401
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "arg",
            "\"-visual\""
          ],
          "line": 2399
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "arg",
            "\"-24to32\""
          ],
          "line": 2395
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "s"
          ],
          "line": 2388
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "arg",
            "\"-8to24\""
          ],
          "line": 2382
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "arg",
            "\"-overlay_yescursor\""
          ],
          "line": 2377
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "arg",
            "\"-overlay_nocursor\""
          ],
          "line": 2372
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "arg",
            "\"-overlay\""
          ],
          "line": 2368
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "s",
            "\"reset\""
          ],
          "line": 2360
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "arg",
            "\"-advertise_truecolor\""
          ],
          "line": 2355
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "arg",
            "\"-notruecolor\""
          ],
          "line": 2351
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atoi",
          "args": [
            "argv[++i]"
          ],
          "line": 2348
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "arg",
            "\"-shiftcmap\""
          ],
          "line": 2346
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "arg",
            "\"-flashcmap\""
          ],
          "line": 2342
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "argv[++i]"
          ],
          "line": 2339
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "arg",
            "\"-clip\""
          ],
          "line": 2337
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "arg",
            "\"-waitmapped\""
          ],
          "line": 2333
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"invalid %s arg: %s\\n\"",
            "arg",
            "argv[i]"
          ],
          "line": 2327
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "scan_hexdec",
          "args": [
            "argv[i]",
            "&subwin"
          ],
          "line": 2326
        },
        "resolved": true,
        "details": {
          "function_name": "scan_hexdec",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/util.c",
          "lines": "201-208",
          "snippet": "int scan_hexdec(char *str, unsigned long *num) {\n\tif (sscanf(str, \"0x%lx\", num) != 1) {\n\t\tif (sscanf(str, \"%lu\", num) != 1) {\n\t\t\treturn 0;\n\t\t}\n\t}\n\treturn 1;\n}",
          "includes": [
            "#include \"connections.h\"",
            "#include \"unixpw.h\"",
            "#include \"win_utils.h\"",
            "#include \"cleanup.h\"",
            "#include \"x11vnc.h\"",
            "#include <stdlib.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void lowercase(char *str);",
            "void uppercase(char *str);",
            "char *lblanks(char *str);",
            "void strzero(char *str);",
            "int scan_hexdec(char *str, unsigned long *num);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"connections.h\"\n#include \"unixpw.h\"\n#include \"win_utils.h\"\n#include \"cleanup.h\"\n#include \"x11vnc.h\"\n#include <stdlib.h>\n\nvoid lowercase(char *str);\nvoid uppercase(char *str);\nchar *lblanks(char *str);\nvoid strzero(char *str);\nint scan_hexdec(char *str, unsigned long *num);\n\nint scan_hexdec(char *str, unsigned long *num) {\n\tif (sscanf(str, \"0x%lx\", num) != 1) {\n\t\tif (sscanf(str, \"%lu\", num) != 1) {\n\t\t\treturn 0;\n\t\t}\n\t}\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"invalid %s pick\\n\"",
            "arg"
          ],
          "line": 2322
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pick_windowid",
          "args": [
            "&subwin"
          ],
          "line": 2321
        },
        "resolved": true,
        "details": {
          "function_name": "pick_windowid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/win_utils.c",
          "lines": "405-478",
          "snippet": "int pick_windowid(unsigned long *num) {\n\tchar line[512];\n\tint ok = 0, n = 0, msec = 10, secmax = 15;\n\tFILE *p;\n\n\tRAWFB_RET(0)\n\n\tif (use_dpy) {\n\t\tset_env(\"DISPLAY\", use_dpy);\n\t}\n\t/* id */\n\tif (no_external_cmds || !cmd_ok(\"id\")) {\n\t\trfbLogEnable(1);\n\t\trfbLog(\"cannot run external commands in -nocmds mode:\\n\");\n\t\trfbLog(\"   \\\"%s\\\"\\n\", \"xwininfo\");\n\t\trfbLog(\"   exiting.\\n\");\n\t\tclean_up_exit(1);\n\t}\n\tclose_exec_fds();\n\tp = popen(\"xwininfo\", \"r\");\n\n\tif (! p) {\n\t\treturn 0;\n\t}\n\n\tfprintf(stderr, \"\\n\");\n\tfprintf(stderr, \"  Please select the window for x11vnc to poll\\n\");\n\tfprintf(stderr, \"  by clicking the mouse in that window.\\n\");\n\tfprintf(stderr, \"\\n\");\n\n\twhile (msec * n++ < 1000 * secmax) {\n\t\tunsigned long tmp;\n\t\tchar *q;\n\t\tfd_set set;\n\t\tstruct timeval tv;\n\n\t\tif (screen && screen->clientHead) {\n\t\t\t/* they may be doing the pointer-pick thru vnc: */\n\t\t\tint nfds;\n\t\t\ttv.tv_sec = 0;\n\t\t\ttv.tv_usec = msec * 1000;\n\t\t\tFD_ZERO(&set);\n\t\t\tFD_SET(fileno(p), &set);\n\n\t\t\tnfds = select(fileno(p)+1, &set, NULL, NULL, &tv);\n\t\t\t\n\t\t\tif (nfds == 0 || nfds < 0) {\n\t\t\t\t/* \n\t\t\t\t * select timedout or error.\n\t\t\t\t * note this rfbPE takes about 30ms too:\n\t\t\t\t */\n\t\t\t\trfbPE(-1);\n\t\t\t\tXFlush_wr(dpy);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\t\n\t\tif (fgets(line, 512, p) == NULL) {\n\t\t\tbreak;\n\t\t}\n\t\tq = strstr(line, \" id: 0x\"); \n\t\tif (q) {\n\t\t\tq += 5;\n\t\t\tif (sscanf(q, \"0x%lx \", &tmp) == 1) {\n\t\t\t\tok = 1;\n\t\t\t\t*num = tmp;\n\t\t\t\tfprintf(stderr, \"  Picked: 0x%lx\\n\\n\", tmp);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tpclose(p);\n\treturn ok;\n}",
          "includes": [
            "#include \"win_utils.h\"",
            "#include \"macosx.h\"",
            "#include \"xrandr.h\"",
            "#include \"connections.h\"",
            "#include \"xwrappers.h\"",
            "#include \"cleanup.h\"",
            "#include \"winattr_t.h\"",
            "#include \"xinerama.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"win_utils.h\"\n#include \"macosx.h\"\n#include \"xrandr.h\"\n#include \"connections.h\"\n#include \"xwrappers.h\"\n#include \"cleanup.h\"\n#include \"winattr_t.h\"\n#include \"xinerama.h\"\n#include \"x11vnc.h\"\n\nint pick_windowid(unsigned long *num) {\n\tchar line[512];\n\tint ok = 0, n = 0, msec = 10, secmax = 15;\n\tFILE *p;\n\n\tRAWFB_RET(0)\n\n\tif (use_dpy) {\n\t\tset_env(\"DISPLAY\", use_dpy);\n\t}\n\t/* id */\n\tif (no_external_cmds || !cmd_ok(\"id\")) {\n\t\trfbLogEnable(1);\n\t\trfbLog(\"cannot run external commands in -nocmds mode:\\n\");\n\t\trfbLog(\"   \\\"%s\\\"\\n\", \"xwininfo\");\n\t\trfbLog(\"   exiting.\\n\");\n\t\tclean_up_exit(1);\n\t}\n\tclose_exec_fds();\n\tp = popen(\"xwininfo\", \"r\");\n\n\tif (! p) {\n\t\treturn 0;\n\t}\n\n\tfprintf(stderr, \"\\n\");\n\tfprintf(stderr, \"  Please select the window for x11vnc to poll\\n\");\n\tfprintf(stderr, \"  by clicking the mouse in that window.\\n\");\n\tfprintf(stderr, \"\\n\");\n\n\twhile (msec * n++ < 1000 * secmax) {\n\t\tunsigned long tmp;\n\t\tchar *q;\n\t\tfd_set set;\n\t\tstruct timeval tv;\n\n\t\tif (screen && screen->clientHead) {\n\t\t\t/* they may be doing the pointer-pick thru vnc: */\n\t\t\tint nfds;\n\t\t\ttv.tv_sec = 0;\n\t\t\ttv.tv_usec = msec * 1000;\n\t\t\tFD_ZERO(&set);\n\t\t\tFD_SET(fileno(p), &set);\n\n\t\t\tnfds = select(fileno(p)+1, &set, NULL, NULL, &tv);\n\t\t\t\n\t\t\tif (nfds == 0 || nfds < 0) {\n\t\t\t\t/* \n\t\t\t\t * select timedout or error.\n\t\t\t\t * note this rfbPE takes about 30ms too:\n\t\t\t\t */\n\t\t\t\trfbPE(-1);\n\t\t\t\tXFlush_wr(dpy);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\t\n\t\tif (fgets(line, 512, p) == NULL) {\n\t\t\tbreak;\n\t\t}\n\t\tq = strstr(line, \" id: 0x\"); \n\t\tif (q) {\n\t\t\tq += 5;\n\t\t\tif (sscanf(q, \"0x%lx \", &tmp) == 1) {\n\t\t\t\tok = 1;\n\t\t\t\t*num = tmp;\n\t\t\t\tfprintf(stderr, \"  Picked: 0x%lx\\n\\n\", tmp);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tpclose(p);\n\treturn ok;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"unsafe: %s pick\\n\"",
            "arg"
          ],
          "line": 2318
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "\"pick\"",
            "argv[i]"
          ],
          "line": 2316
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "arg",
            "\"-sid\""
          ],
          "line": 2308
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "arg",
            "\"-id\""
          ],
          "line": 2308
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "argv[++i]"
          ],
          "line": 2305
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "arg",
            "\"-tsd\""
          ],
          "line": 2303
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "raw_fb_str",
            "\"vnc:%s\"",
            "argv[++i]"
          ],
          "line": 2299
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "4 + strlen(argv[i+1]) + 1"
          ],
          "line": 2298
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "argv[i+1]"
          ],
          "line": 2298
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "arg",
            "\"-reflect\""
          ],
          "line": 2296
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atoi",
          "args": [
            "argv[++i]"
          ],
          "line": 2293
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "arg",
            "\"-autoport\""
          ],
          "line": 2291
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "arg",
            "\"-N\""
          ],
          "line": 2287
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "argv[++i]"
          ],
          "line": 2284
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "arg",
            "\"-xauth\""
          ],
          "line": 2282
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "arg",
            "\"-auth\""
          ],
          "line": 2282
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "t",
            "\"%s=%s\"",
            "t0",
            "argv[i]"
          ],
          "line": 2278
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strrchr",
          "args": [
            "argv[i]",
            "':'"
          ],
          "line": 2276
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "strlen(t0) + strlen(argv[++i]) + 2"
          ],
          "line": 2275
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "argv[++i]"
          ],
          "line": 2275
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "t0"
          ],
          "line": 2275
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "arg",
            "\"-redirect\""
          ],
          "line": 2272
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "\"WAIT:cmd=FINDCREATEDISPLAY-Xvnc.redirect\""
          ],
          "line": 2269
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "arg",
            "\"-xvnc_redirect\""
          ],
          "line": 2268
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "\"WAIT:cmd=FINDCREATEDISPLAY-Xvnc\""
          ],
          "line": 2265
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "arg",
            "\"-xvnc\""
          ],
          "line": 2264
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "\"WAIT:cmd=FINDCREATEDISPLAY-Xdummy,Xvfb\""
          ],
          "line": 2261
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "arg",
            "\"-xdummy_xvfb\""
          ],
          "line": 2260
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "\"WAIT:cmd=FINDCREATEDISPLAY-Xdummy\""
          ],
          "line": 2257
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "arg",
            "\"-xdummy\""
          ],
          "line": 2256
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "use_dpy",
            "\"WAIT:cmd=FINDCREATEDISPLAY-%s\"",
            "argv[++i]"
          ],
          "line": 2253
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "strlen(argv[i+1])+100"
          ],
          "line": 2252
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "argv[i+1]"
          ],
          "line": 2252
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "arg",
            "\"-create_xsrv\""
          ],
          "line": 2250
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "\"WAIT:cmd=FINDCREATEDISPLAY-Xvfb\""
          ],
          "line": 2247
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "arg",
            "\"-create\""
          ],
          "line": 2246
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "arg",
            "\"-findauth\""
          ],
          "line": 2235
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wait_for_client",
          "args": [
            "&ic",
            "NULL",
            "0"
          ],
          "line": 2231
        },
        "resolved": true,
        "details": {
          "function_name": "wait_for_client",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/user.c",
          "lines": "2921-3157",
          "snippet": "int wait_for_client(int *argc, char** argv, int http) {\n\t/* ugh, here we go... */\n\tXImage* fb_image;\n\tint w = 640, h = 480, b = 32;\n\tint w0 = -1, h0 = -1, i, chg_raw_fb = 0;\n\tchar *str, *q, *cmd = NULL;\n\tint db = 0, dt = 0;\n\tchar *create_cmd = NULL;\n\tchar *users_list_save = NULL;\n\tint created_disp = 0, ncache_save;\n\tint did_client_connect = 0;\n\tchar *vnc_redirect_host = \"localhost\";\n\tint vnc_redirect_port = -1, vnc_redirect_cnt = 0;\n\tchar vnc_redirect_test[10];\n\n\tif (getenv(\"WAIT_FOR_CLIENT_DB\")) {\n\t\tdb = 1;\n\t}\n\n\tvnc_redirect = 0;\n\n\tif (! use_dpy || strstr(use_dpy, \"WAIT:\") != use_dpy) {\n\t\treturn 0;\n\t}\n\n\tfor (i=0; i < *argc; i++) {\n\t\tif (!strcmp(argv[i], \"-desktop\")) {\n\t\t\tdt = 1;\n\t\t}\n\t\tif (db) fprintf(stderr, \"args %d %s\\n\", i, argv[i]);\n\t}\n\tif (!quiet && !strstr(use_dpy, \"FINDDISPLAY-run\")) {\n\t\trfbLog(\"\\n\");\n\t\trfbLog(\"wait_for_client: %s\\n\", use_dpy);\n\t\trfbLog(\"\\n\");\n\t}\n\n\tstr = strdup(use_dpy);\n\tstr += strlen(\"WAIT\");\n\n\txdmcp_insert = NULL;\n\n\t/* get any leading geometry: */\n\tq = strchr(str+1, ':');\n\tif (q) {\n\t\t*q = '\\0';\n\t\tif (sscanf(str+1, \"%dx%d\", &w0, &h0) == 2)  {\n\t\t\tw = w0;\n\t\t\th = h0;\n\t\t\trfbLog(\"wait_for_client set: w=%d h=%d\\n\", w, h);\n\t\t} else {\n\t\t\tw0 = -1;\n\t\t\th0 = -1;\n\t\t}\n\t\t*q = ':';\n\t\tstr = q;\n\t}\n\tif ((w0 == -1 || h0 == -1) && pad_geometry != NULL) {\n\t\tint b0, del = 0;\n\t\tchar *s = pad_geometry;\n\t\tif (strstr(s, \"once:\") == s) {\n\t\t\tdel = 1;\n\t\t\ts += strlen(\"once:\");\n\t\t}\n\t\tif (sscanf(s, \"%dx%dx%d\", &w0, &h0, &b0) == 3)  {\n\t\t\tw = nabs(w0);\n\t\t\th = nabs(h0);\n\t\t\tb = nabs(b0);\n\t\t} else if (sscanf(s, \"%dx%d\", &w0, &h0) == 2)  {\n\t\t\tw = nabs(w0);\n\t\t\th = nabs(h0);\n\t\t}\n\t\tif (del) {\n\t\t\tpad_geometry = NULL;\n\t\t}\n\t}\n\n\t/* str currently begins with a ':' */\n\tif (strstr(str, \":cmd=\") == str) {\n\t\t/* cmd=/path/to/mycommand */\n\t\tstr++;\n\t} else if (strpbrk(str, \"0123456789\") == str+1) {\n\t\t/* :0.0 */\n\t\t;\n\t} else {\n\t\t/* hostname:0.0 */\n\t\tstr++;\n\t}\n\n\tif (db) fprintf(stderr, \"str: %s\\n\", str);\n\n\tif (strstr(str, \"cmd=\") == str) {\n\t\tcmd = setup_cmd(str, &vnc_redirect, &vnc_redirect_host, &vnc_redirect_port, db);\n\t}\n\t\n\tfb_image = &ximage_struct;\n\tsetup_fake_fb(fb_image, w, h, b);\n\n\tif (! dt) {\n\t\tchar *s;\n\t\targv[*argc] = strdup(\"-desktop\");\n\t\t*argc = (*argc) + 1;\n\n\t\tif (cmd) {\n\t\t\tchar *q;\n\t\t\ts = choose_title(\":0\");\n\t\t\tq = strstr(s, \":0\");\n\t\t\tif (q) {\n\t\t\t\t*q = '\\0';\n\t\t\t}\n\t\t} else {\n\t\t\ts = choose_title(str);\n\t\t}\n\t\trfb_desktop_name = strdup(s);\n\t\targv[*argc] = s;\n\t\t*argc = (*argc) + 1;\n\t}\n\n\tncache_save = ncache;\n\tncache = 0;\n\n\tinitialize_allowed_input();\n\n\tif (! multiple_cursors_mode) {\n\t\tmultiple_cursors_mode = strdup(\"default\");\n\t}\n\tinitialize_cursors_mode();\n\t\n\tinitialize_screen(argc, argv, fb_image);\n\n\tif (! inetd && ! use_openssl) {\n\t\tif (! screen->port || screen->listenSock < 0) {\n\t\t\tif (got_rfbport && got_rfbport_val == 0) {\n\t\t\t\t;\n\t\t\t} else if (ipv6_listen && ipv6_listen_fd >= 0) {\n\t\t\t\trfbLog(\"Info: listening on IPv6 interface only.  (wait for client)\\n\");\n\t\t\t} else {\n\t\t\t\trfbLogEnable(1);\n\t\t\t\trfbLog(\"Error: could not obtain listening port.  (wait for client)\\n\");\n\t\t\t\tif (!got_rfbport && !got_ipv6_listen) {\n\t\t\t\t\trfbLog(\"If this system is IPv6-only, use the -6 option.\\n\");\n\t\t\t\t}\n\t\t\t\tclean_up_exit(1);\n\t\t\t}\n\t\t}\n\t}\n\n\tinitialize_signals();\n\n\tif (ssh_str != NULL) {\n\t\tssh_remote_tunnel(ssh_str, screen->port);\n\t}\n\n\tif (! raw_fb) {\n\t\tchg_raw_fb = 1;\n\t\t/* kludge to get RAWFB_RET with dpy == NULL guards */\n\t\traw_fb = (char *) 0x1;\n\t}\n\n\tif (cmd && !strcmp(cmd, \"HTTPONCE\")) {\n\t\thandle_one_http_request();\t\n\t\tclean_up_exit(0);\n\t}\n\n\tif (http && check_httpdir()) {\n\t\thttp_connections(1);\n\t}\n\n\tif (cmd && unixpw) {\n\t\tkeep_unixpw = 1;\n\t}\n\n\tsetup_service();\n\n\tcheck_waitbg();\n\n\tif (vnc_redirect) {\n\t\tvnc_redirect_loop(vnc_redirect_test, &vnc_redirect_cnt);\n\t} else {\n\n\t\tif (use_threads && !started_rfbRunEventLoop) {\n\t\t\tstarted_rfbRunEventLoop = 1;\n\t\t\trfbRunEventLoop(screen, -1, TRUE);\n\t\t}\n\n\t\tif (inetd && use_openssl) {\n\t\t\taccept_openssl(OPENSSL_INETD, -1);\n\t\t}\n\n\t\tsetup_client_connect(&did_client_connect);\n\n\t\tloop_for_connect(did_client_connect);\n\n\t\tif (unixpw) {\n\t\t\tif (cmd && strstr(cmd, \"FINDCREATEDISPLAY\") == cmd) {\n\t\t\t\tif (users_list && strstr(users_list, \"unixpw=\") == users_list) {\n\t\t\t\t\tusers_list_save = users_list;\n\t\t\t\t\tusers_list = NULL;\n\t\t\t\t}\n\t\t\t}\n\t\t\tdo_unixpw_loop();\n\t\t} else if (cmd && !use_threads) {\n\t\t\t/* try to get RFB proto done now. */\n\t\t\tprogress_client();\n\t\t}\n\t}\n\n\tif (vnc_redirect == 2) {\n\t\t;\n\t} else if (cmd) {\n\t\tif (!do_run_cmd(cmd, create_cmd, users_list_save, created_disp, db)) {\n\t\t\treturn 0;\n\t\t}\n\t} else {\n\t\tuse_dpy = strdup(str);\n\t}\n\tif (chg_raw_fb) {\n\t\traw_fb = NULL;\n\t}\n\n\tncache = ncache_save;\n\n\tif (unixpw && keep_unixpw_opts && keep_unixpw_opts[0] != '\\0') {\n\t\tuser_supplied_opts(keep_unixpw_opts);\n\t}\n\tif (create_cmd) {\n\t\tfree(create_cmd);\n\t}\n\n\tif (vnc_redirect) {\n\t\tdo_vnc_redirect(created_disp, vnc_redirect_host, vnc_redirect_port,\n\t\t    vnc_redirect_cnt, vnc_redirect_test);\n\t\tclean_up_exit(0);\n\t}\n\n\treturn 1;\n}",
          "includes": [
            "#include \"avahi.h\"",
            "#include \"sslhelper.h\"",
            "#include \"remote.h\"",
            "#include \"cursor.h\"",
            "#include \"keyboard.h\"",
            "#include \"inet.h\"",
            "#include \"connections.h\"",
            "#include \"xwrappers.h\"",
            "#include \"sslhelper.h\"",
            "#include \"unixpw.h\"",
            "#include \"screen.h\"",
            "#include \"scan.h\"",
            "#include \"cleanup.h\"",
            "#include \"solid.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void lurk_loop(char *str);",
            "void progress_client(void);",
            "int wait_for_client(int *argc, char** argv, int http);",
            "char *xdmcp_insert = NULL;",
            "void ssh_remote_tunnel(char *, int);",
            "static XImage ximage_struct;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"avahi.h\"\n#include \"sslhelper.h\"\n#include \"remote.h\"\n#include \"cursor.h\"\n#include \"keyboard.h\"\n#include \"inet.h\"\n#include \"connections.h\"\n#include \"xwrappers.h\"\n#include \"sslhelper.h\"\n#include \"unixpw.h\"\n#include \"screen.h\"\n#include \"scan.h\"\n#include \"cleanup.h\"\n#include \"solid.h\"\n#include \"x11vnc.h\"\n\nvoid lurk_loop(char *str);\nvoid progress_client(void);\nint wait_for_client(int *argc, char** argv, int http);\nchar *xdmcp_insert = NULL;\nvoid ssh_remote_tunnel(char *, int);\nstatic XImage ximage_struct;\n\nint wait_for_client(int *argc, char** argv, int http) {\n\t/* ugh, here we go... */\n\tXImage* fb_image;\n\tint w = 640, h = 480, b = 32;\n\tint w0 = -1, h0 = -1, i, chg_raw_fb = 0;\n\tchar *str, *q, *cmd = NULL;\n\tint db = 0, dt = 0;\n\tchar *create_cmd = NULL;\n\tchar *users_list_save = NULL;\n\tint created_disp = 0, ncache_save;\n\tint did_client_connect = 0;\n\tchar *vnc_redirect_host = \"localhost\";\n\tint vnc_redirect_port = -1, vnc_redirect_cnt = 0;\n\tchar vnc_redirect_test[10];\n\n\tif (getenv(\"WAIT_FOR_CLIENT_DB\")) {\n\t\tdb = 1;\n\t}\n\n\tvnc_redirect = 0;\n\n\tif (! use_dpy || strstr(use_dpy, \"WAIT:\") != use_dpy) {\n\t\treturn 0;\n\t}\n\n\tfor (i=0; i < *argc; i++) {\n\t\tif (!strcmp(argv[i], \"-desktop\")) {\n\t\t\tdt = 1;\n\t\t}\n\t\tif (db) fprintf(stderr, \"args %d %s\\n\", i, argv[i]);\n\t}\n\tif (!quiet && !strstr(use_dpy, \"FINDDISPLAY-run\")) {\n\t\trfbLog(\"\\n\");\n\t\trfbLog(\"wait_for_client: %s\\n\", use_dpy);\n\t\trfbLog(\"\\n\");\n\t}\n\n\tstr = strdup(use_dpy);\n\tstr += strlen(\"WAIT\");\n\n\txdmcp_insert = NULL;\n\n\t/* get any leading geometry: */\n\tq = strchr(str+1, ':');\n\tif (q) {\n\t\t*q = '\\0';\n\t\tif (sscanf(str+1, \"%dx%d\", &w0, &h0) == 2)  {\n\t\t\tw = w0;\n\t\t\th = h0;\n\t\t\trfbLog(\"wait_for_client set: w=%d h=%d\\n\", w, h);\n\t\t} else {\n\t\t\tw0 = -1;\n\t\t\th0 = -1;\n\t\t}\n\t\t*q = ':';\n\t\tstr = q;\n\t}\n\tif ((w0 == -1 || h0 == -1) && pad_geometry != NULL) {\n\t\tint b0, del = 0;\n\t\tchar *s = pad_geometry;\n\t\tif (strstr(s, \"once:\") == s) {\n\t\t\tdel = 1;\n\t\t\ts += strlen(\"once:\");\n\t\t}\n\t\tif (sscanf(s, \"%dx%dx%d\", &w0, &h0, &b0) == 3)  {\n\t\t\tw = nabs(w0);\n\t\t\th = nabs(h0);\n\t\t\tb = nabs(b0);\n\t\t} else if (sscanf(s, \"%dx%d\", &w0, &h0) == 2)  {\n\t\t\tw = nabs(w0);\n\t\t\th = nabs(h0);\n\t\t}\n\t\tif (del) {\n\t\t\tpad_geometry = NULL;\n\t\t}\n\t}\n\n\t/* str currently begins with a ':' */\n\tif (strstr(str, \":cmd=\") == str) {\n\t\t/* cmd=/path/to/mycommand */\n\t\tstr++;\n\t} else if (strpbrk(str, \"0123456789\") == str+1) {\n\t\t/* :0.0 */\n\t\t;\n\t} else {\n\t\t/* hostname:0.0 */\n\t\tstr++;\n\t}\n\n\tif (db) fprintf(stderr, \"str: %s\\n\", str);\n\n\tif (strstr(str, \"cmd=\") == str) {\n\t\tcmd = setup_cmd(str, &vnc_redirect, &vnc_redirect_host, &vnc_redirect_port, db);\n\t}\n\t\n\tfb_image = &ximage_struct;\n\tsetup_fake_fb(fb_image, w, h, b);\n\n\tif (! dt) {\n\t\tchar *s;\n\t\targv[*argc] = strdup(\"-desktop\");\n\t\t*argc = (*argc) + 1;\n\n\t\tif (cmd) {\n\t\t\tchar *q;\n\t\t\ts = choose_title(\":0\");\n\t\t\tq = strstr(s, \":0\");\n\t\t\tif (q) {\n\t\t\t\t*q = '\\0';\n\t\t\t}\n\t\t} else {\n\t\t\ts = choose_title(str);\n\t\t}\n\t\trfb_desktop_name = strdup(s);\n\t\targv[*argc] = s;\n\t\t*argc = (*argc) + 1;\n\t}\n\n\tncache_save = ncache;\n\tncache = 0;\n\n\tinitialize_allowed_input();\n\n\tif (! multiple_cursors_mode) {\n\t\tmultiple_cursors_mode = strdup(\"default\");\n\t}\n\tinitialize_cursors_mode();\n\t\n\tinitialize_screen(argc, argv, fb_image);\n\n\tif (! inetd && ! use_openssl) {\n\t\tif (! screen->port || screen->listenSock < 0) {\n\t\t\tif (got_rfbport && got_rfbport_val == 0) {\n\t\t\t\t;\n\t\t\t} else if (ipv6_listen && ipv6_listen_fd >= 0) {\n\t\t\t\trfbLog(\"Info: listening on IPv6 interface only.  (wait for client)\\n\");\n\t\t\t} else {\n\t\t\t\trfbLogEnable(1);\n\t\t\t\trfbLog(\"Error: could not obtain listening port.  (wait for client)\\n\");\n\t\t\t\tif (!got_rfbport && !got_ipv6_listen) {\n\t\t\t\t\trfbLog(\"If this system is IPv6-only, use the -6 option.\\n\");\n\t\t\t\t}\n\t\t\t\tclean_up_exit(1);\n\t\t\t}\n\t\t}\n\t}\n\n\tinitialize_signals();\n\n\tif (ssh_str != NULL) {\n\t\tssh_remote_tunnel(ssh_str, screen->port);\n\t}\n\n\tif (! raw_fb) {\n\t\tchg_raw_fb = 1;\n\t\t/* kludge to get RAWFB_RET with dpy == NULL guards */\n\t\traw_fb = (char *) 0x1;\n\t}\n\n\tif (cmd && !strcmp(cmd, \"HTTPONCE\")) {\n\t\thandle_one_http_request();\t\n\t\tclean_up_exit(0);\n\t}\n\n\tif (http && check_httpdir()) {\n\t\thttp_connections(1);\n\t}\n\n\tif (cmd && unixpw) {\n\t\tkeep_unixpw = 1;\n\t}\n\n\tsetup_service();\n\n\tcheck_waitbg();\n\n\tif (vnc_redirect) {\n\t\tvnc_redirect_loop(vnc_redirect_test, &vnc_redirect_cnt);\n\t} else {\n\n\t\tif (use_threads && !started_rfbRunEventLoop) {\n\t\t\tstarted_rfbRunEventLoop = 1;\n\t\t\trfbRunEventLoop(screen, -1, TRUE);\n\t\t}\n\n\t\tif (inetd && use_openssl) {\n\t\t\taccept_openssl(OPENSSL_INETD, -1);\n\t\t}\n\n\t\tsetup_client_connect(&did_client_connect);\n\n\t\tloop_for_connect(did_client_connect);\n\n\t\tif (unixpw) {\n\t\t\tif (cmd && strstr(cmd, \"FINDCREATEDISPLAY\") == cmd) {\n\t\t\t\tif (users_list && strstr(users_list, \"unixpw=\") == users_list) {\n\t\t\t\t\tusers_list_save = users_list;\n\t\t\t\t\tusers_list = NULL;\n\t\t\t\t}\n\t\t\t}\n\t\t\tdo_unixpw_loop();\n\t\t} else if (cmd && !use_threads) {\n\t\t\t/* try to get RFB proto done now. */\n\t\t\tprogress_client();\n\t\t}\n\t}\n\n\tif (vnc_redirect == 2) {\n\t\t;\n\t} else if (cmd) {\n\t\tif (!do_run_cmd(cmd, create_cmd, users_list_save, created_disp, db)) {\n\t\t\treturn 0;\n\t\t}\n\t} else {\n\t\tuse_dpy = strdup(str);\n\t}\n\tif (chg_raw_fb) {\n\t\traw_fb = NULL;\n\t}\n\n\tncache = ncache_save;\n\n\tif (unixpw && keep_unixpw_opts && keep_unixpw_opts[0] != '\\0') {\n\t\tuser_supplied_opts(keep_unixpw_opts);\n\t}\n\tif (create_cmd) {\n\t\tfree(create_cmd);\n\t}\n\n\tif (vnc_redirect) {\n\t\tdo_vnc_redirect(created_disp, vnc_redirect_host, vnc_redirect_port,\n\t\t    vnc_redirect_cnt, vnc_redirect_test);\n\t\tclean_up_exit(0);\n\t}\n\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "arg",
            "\"-listdpy\""
          ],
          "line": 2228
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stdout",
            "\"X11VNC_USER=%s\\n\"",
            "getenv(\"X11VNC_USER\")"
          ],
          "line": 2226
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getenv",
          "args": [
            "\"X11VNC_USER\""
          ],
          "line": 2226
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "\"WAIT:cmd=FINDDISPLAY-run\""
          ],
          "line": 2223
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "arg",
            "\"-listdpy\""
          ],
          "line": 2221
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "arg",
            "\"-finddpy\""
          ],
          "line": 2221
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "\"WAIT:cmd=FINDDISPLAY\""
          ],
          "line": 2218
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "arg",
            "\"-find\""
          ],
          "line": 2217
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atoi",
          "args": [
            "str"
          ],
          "line": 2208
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getenv",
          "args": [
            "\"X11VNC_REOPEN_DISPLAY\""
          ],
          "line": 2206
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "arg",
            "\"-reopen\""
          ],
          "line": 2205
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stdout",
            "\"%s\"",
            "create_display"
          ],
          "line": 2199
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "use_dpy",
            "\"cmd=FINDCREATEDISPLAY-print\""
          ],
          "line": 2198
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stdout",
            "\"%s\"",
            "find_display"
          ],
          "line": 2195
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "use_dpy",
            "\"cmd=FINDDISPLAY-print\""
          ],
          "line": 2194
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "use_dpy",
            "\"WAIT\""
          ],
          "line": 2191
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "argv[++i]"
          ],
          "line": 2190
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "arg",
            "\"-display\""
          ],
          "line": 2188
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "arg",
            "\"--\""
          ],
          "line": 2184
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"no -env '=' found: %s\\n\"",
            "p"
          ],
          "line": 2171
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "p",
            "'='"
          ],
          "line": 2169
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "argv[++i]"
          ],
          "line": 2168
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "arg",
            "\"-env\""
          ],
          "line": 2166
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "arg",
            "\"--\""
          ],
          "line": 2163
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "argv[++i]"
          ],
          "line": 2153
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "arg",
            "\"-ssldir\""
          ],
          "line": 2151
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "arg",
            "\"--\""
          ],
          "line": 2148
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "check_rcfile",
          "args": [
            "argc",
            "argv"
          ],
          "line": 2132
        },
        "resolved": true,
        "details": {
          "function_name": "check_rcfile",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/x11vnc.c",
          "lines": "1023-1274",
          "snippet": "static void check_rcfile(int argc, char **argv) {\n\tint i, j, pwlast, enclast, norc = 0, argmax = 1024;\n\tchar *infile = NULL;\n\tchar rcfile[1024];\n\tFILE *rc = NULL; \n\n\tfor (i=1; i < argc; i++) {\n\t\tif (!strcmp(argv[i], \"-printgui\")) {\n\t\t\tfprintf(stdout, \"%s\", get_gui_code());\n\t\t\tfflush(stdout);\n\t\t\texit(0);\n\t\t}\n\t\tif (!strcmp(argv[i], \"-norc\")) {\n\t\t\tnorc = 1;\n\t\t\tgot_norc = 1;\n\t\t}\n\t\tif (!strcmp(argv[i], \"-QD\")) {\n\t\t\tnorc = 1;\n\t\t}\n\t\tif (!strcmp(argv[i], \"-rc\")) {\n\t\t\tif (i+1 >= argc) {\n\t\t\t\tfprintf(stderr, \"-rc option requires a \"\n\t\t\t\t    \"filename\\n\");\n\t\t\t\texit(1);\n\t\t\t} else {\n\t\t\t\tinfile = argv[i+1];\n\t\t\t}\n\t\t}\n\t}\n\trc_norc = norc;\n\trc_rcfile = strdup(\"\");\n\tif (norc) {\n\t\t;\n\t} else if (infile != NULL) {\n\t\trc = fopen(infile, \"r\");\n\t\trc_rcfile = strdup(infile);\n\t\tif (rc == NULL) {\n\t\t\tfprintf(stderr, \"could not open rcfile: %s\\n\", infile);\n\t\t\tperror(\"fopen\");\n\t\t\texit(1);\n\t\t}\n\t} else {\n\t\tchar *home = get_home_dir();\n\t\tif (! home) {\n\t\t\tnorc = 1;\n\t\t} else {\n\t\t\tmemset(rcfile, 0, sizeof(rcfile));\n\t\t\tstrncpy(rcfile, home, 500);\n\t\t\tfree(home);\n\n\t\t\tstrcat(rcfile, \"/.x11vncrc\");\n\t\t\tinfile = rcfile;\n\t\t\trc = fopen(rcfile, \"r\");\n\t\t\tif (rc == NULL) {\n\t\t\t\tnorc = 1;\n\t\t\t} else {\n\t\t\t\trc_rcfile = strdup(rcfile);\n\t\t\t\trc_rcfile_default = 1;\n\t\t\t}\n\t\t}\n\t}\n\n\targv2 = (char **) malloc(argmax * sizeof(char *));\n\targv2[argc2++] = strdup(argv[0]);\n\n\tif (! norc) {\n\t\tchar line[4096], parm[400], tmp[401];\n\t\tchar *buf, *tbuf;\n\t\tstruct stat sbuf;\n\t\tint sz;\n\n\t\tif (fstat(fileno(rc), &sbuf) != 0) {\n\t\t\tfprintf(stderr, \"problem with %s\\n\", infile);\n\t\t\tperror(\"fstat\");\n\t\t\texit(1);\n\t\t}\n\t\tsz = sbuf.st_size+1;\t/* allocate whole file size */\n\t\tif (sz < 1024) {\n\t\t\tsz = 1024;\n\t\t}\n\n\t\tbuf = (char *) malloc(sz);\n\t\tbuf[0] = '\\0';\n\n\t\twhile (fgets(line, 4096, rc) != NULL) {\n\t\t\tchar *q, *p = line;\n\t\t\tchar c;\n\t\t\tint cont = 0;\n\n\t\t\tq = p;\n\t\t\tc = '\\0';\n\t\t\twhile (*q) {\n\t\t\t\tif (*q == '#') {\n\t\t\t\t\tif (c != '\\\\') {\n\t\t\t\t\t\t*q = '\\0';\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tc = *q;\n\t\t\t\tq++;\n\t\t\t}\n\n\t\t\tq = p;\n\t\t\tc = '\\0';\n\t\t\twhile (*q) {\n\t\t\t\tif (*q == '\\n') {\n\t\t\t\t\tif (c == '\\\\') {\n\t\t\t\t\t\tcont = 1;\n\t\t\t\t\t\t*q = '\\0';\n\t\t\t\t\t\t*(q-1) = ' ';\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\twhile (isspace((unsigned char) (*q))) {\n\t\t\t\t\t\t*q = '\\0';\n\t\t\t\t\t\tif (q == p) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tq--;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tc = *q;\n\t\t\t\tq++;\n\t\t\t}\n\t\t\tif (q != p && !cont) {\n\t\t\t\tif (*q == '\\0') {\n\t\t\t\t\tq--;\n\t\t\t\t}\n\t\t\t\twhile (isspace((unsigned char) (*q))) {\n\t\t\t\t\t*q = '\\0';\n\t\t\t\t\tif (q == p) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tq--;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tp = lblanks(p);\n\n\t\t\tstrncat(buf, p, sz - strlen(buf) - 1);\n\t\t\tif (cont) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (buf[0] == '\\0') {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\ti = 0;\n\t\t\tq = buf;\n\t\t\twhile (*q) {\n\t\t\t\ti++;\n\t\t\t\tif (*q == '\\n' || isspace((unsigned char) (*q))) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tq++;\n\t\t\t}\n\n\t\t\tif (i >= 400) {\n\t\t\t\tfprintf(stderr, \"invalid rcfile line: %s/%s\\n\",\n\t\t\t\t    p, buf);\n\t\t\t\texit(1);\n\t\t\t}\n\n\t\t\tif (sscanf(buf, \"%s\", parm) != 1) {\n\t\t\t\tfprintf(stderr, \"invalid rcfile line: %s\\n\", p);\n\t\t\t\texit(1);\n\t\t\t}\n\t\t\tif (parm[0] == '-') {\n\t\t\t\tstrncpy(tmp, parm, 400); \n\t\t\t} else {\n\t\t\t\ttmp[0] = '-';\n\t\t\t\tstrncpy(tmp+1, parm, 400); \n\t\t\t}\n\n\t\t\tif (strstr(tmp, \"-loop\") == tmp) {\n\t\t\t\tif (! getenv(\"X11VNC_LOOP_MODE\")) {\n\t\t\t\t\tcheck_loop_mode(argc, argv, 1);\n\t\t\t\t\texit(0);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\targv2[argc2++] = strdup(tmp);\n\t\t\tif (argc2 >= argmax) {\n\t\t\t\tfprintf(stderr, \"too many rcfile options\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\t\t\t\n\t\t\tp = buf;\n\t\t\tp += strlen(parm);\n\t\t\tp = lblanks(p);\n\n\t\t\tif (*p == '\\0') {\n\t\t\t\tbuf[0] = '\\0';\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\ttbuf = (char *) calloc(strlen(p) + 1, 1);\n\n\t\t\tj = 0;\n\t\t\twhile (*p) {\n\t\t\t\tif (*p == '\\\\' && *(p+1) == '#') {\n\t\t\t\t\t;\n\t\t\t\t} else {\n\t\t\t\t\ttbuf[j++] = *p;\n\t\t\t\t}\n\t\t\t\tp++;\n\t\t\t}\n\n\t\t\targv2[argc2++] = strdup(tbuf);\n\t\t\tfree(tbuf);\n\t\t\tif (argc2 >= argmax) {\n\t\t\t\tfprintf(stderr, \"too many rcfile options\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\t\t\tbuf[0] = '\\0';\n\t\t}\n\t\tfclose(rc);\n\t\tfree(buf);\n\t}\n\tpwlast = 0;\n\tenclast = 0;\n\tfor (i=1; i < argc; i++) {\n\t\targv2[argc2++] = strdup(argv[i]);\n\n\t\tif (pwlast || !strcmp(\"-passwd\", argv[i])\n\t\t    || !strcmp(\"-viewpasswd\", argv[i])) {\n\t\t\tchar *p = argv[i];\t\t\n\t\t\tif (pwlast) {\n\t\t\t\tpwlast = 0;\n\t\t\t} else {\n\t\t\t\tpwlast = 1;\n\t\t\t}\n\t\t\tstrzero(p);\n\t\t}\n\t\tif (enclast || !strcmp(\"-enc\", argv[i])) {\n\t\t\tchar *q, *p = argv[i];\t\t\n\t\t\tif (enclast) {\n\t\t\t\tenclast = 0;\n\t\t\t} else {\n\t\t\t\tenclast = 1;\n\t\t\t}\n\t\t\tq = strstr(p, \"pw=\");\n\t\t\tif (q) {\n\t\t\t\tstrzero(q);\n\t\t\t}\n\t\t}\n\t\tif (argc2 >= argmax) {\n\t\t\tfprintf(stderr, \"too many rcfile options\\n\");\n\t\t\texit(1);\n\t\t}\n\t}\n}",
          "includes": [
            "#include \"xi2_devices.h\"",
            "#include \"solid.h\"",
            "#include \"pm.h\"",
            "#include \"selection.h\"",
            "#include \"sslhelper.h\"",
            "#include \"sslcmds.h\"",
            "#include \"inet.h\"",
            "#include \"unixpw.h\"",
            "#include \"rates.h\"",
            "#include \"connections.h\"",
            "#include \"screen.h\"",
            "#include \"userinput.h\"",
            "#include \"cursor.h\"",
            "#include \"pointer.h\"",
            "#include \"keyboard.h\"",
            "#include \"cleanup.h\"",
            "#include \"user.h\"",
            "#include \"help.h\"",
            "#include \"gui.h\"",
            "#include \"scan.h\"",
            "#include \"remote.h\"",
            "#include \"win_utils.h\"",
            "#include \"xkb_bell.h\"",
            "#include \"xrandr.h\"",
            "#include \"xinerama.h\"",
            "#include \"xevents.h\"",
            "#include \"xrecord.h\"",
            "#include \"xdamage.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void check_rcfile(int argc, char **argv);",
            "static void immediate_switch_user(int argc, char* argv[]);",
            "static void check_loop_mode(int argc, char* argv[], int force);",
            "static void check_appshare_mode(int argc, char* argv[]);",
            "static int argc2 = 0;",
            "static char **argv2;",
            "extern int appshare_main(int argc, char* argv[]);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xi2_devices.h\"\n#include \"solid.h\"\n#include \"pm.h\"\n#include \"selection.h\"\n#include \"sslhelper.h\"\n#include \"sslcmds.h\"\n#include \"inet.h\"\n#include \"unixpw.h\"\n#include \"rates.h\"\n#include \"connections.h\"\n#include \"screen.h\"\n#include \"userinput.h\"\n#include \"cursor.h\"\n#include \"pointer.h\"\n#include \"keyboard.h\"\n#include \"cleanup.h\"\n#include \"user.h\"\n#include \"help.h\"\n#include \"gui.h\"\n#include \"scan.h\"\n#include \"remote.h\"\n#include \"win_utils.h\"\n#include \"xkb_bell.h\"\n#include \"xrandr.h\"\n#include \"xinerama.h\"\n#include \"xevents.h\"\n#include \"xrecord.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nstatic void check_rcfile(int argc, char **argv);\nstatic void immediate_switch_user(int argc, char* argv[]);\nstatic void check_loop_mode(int argc, char* argv[], int force);\nstatic void check_appshare_mode(int argc, char* argv[]);\nstatic int argc2 = 0;\nstatic char **argv2;\nextern int appshare_main(int argc, char* argv[]);\n\nstatic void check_rcfile(int argc, char **argv) {\n\tint i, j, pwlast, enclast, norc = 0, argmax = 1024;\n\tchar *infile = NULL;\n\tchar rcfile[1024];\n\tFILE *rc = NULL; \n\n\tfor (i=1; i < argc; i++) {\n\t\tif (!strcmp(argv[i], \"-printgui\")) {\n\t\t\tfprintf(stdout, \"%s\", get_gui_code());\n\t\t\tfflush(stdout);\n\t\t\texit(0);\n\t\t}\n\t\tif (!strcmp(argv[i], \"-norc\")) {\n\t\t\tnorc = 1;\n\t\t\tgot_norc = 1;\n\t\t}\n\t\tif (!strcmp(argv[i], \"-QD\")) {\n\t\t\tnorc = 1;\n\t\t}\n\t\tif (!strcmp(argv[i], \"-rc\")) {\n\t\t\tif (i+1 >= argc) {\n\t\t\t\tfprintf(stderr, \"-rc option requires a \"\n\t\t\t\t    \"filename\\n\");\n\t\t\t\texit(1);\n\t\t\t} else {\n\t\t\t\tinfile = argv[i+1];\n\t\t\t}\n\t\t}\n\t}\n\trc_norc = norc;\n\trc_rcfile = strdup(\"\");\n\tif (norc) {\n\t\t;\n\t} else if (infile != NULL) {\n\t\trc = fopen(infile, \"r\");\n\t\trc_rcfile = strdup(infile);\n\t\tif (rc == NULL) {\n\t\t\tfprintf(stderr, \"could not open rcfile: %s\\n\", infile);\n\t\t\tperror(\"fopen\");\n\t\t\texit(1);\n\t\t}\n\t} else {\n\t\tchar *home = get_home_dir();\n\t\tif (! home) {\n\t\t\tnorc = 1;\n\t\t} else {\n\t\t\tmemset(rcfile, 0, sizeof(rcfile));\n\t\t\tstrncpy(rcfile, home, 500);\n\t\t\tfree(home);\n\n\t\t\tstrcat(rcfile, \"/.x11vncrc\");\n\t\t\tinfile = rcfile;\n\t\t\trc = fopen(rcfile, \"r\");\n\t\t\tif (rc == NULL) {\n\t\t\t\tnorc = 1;\n\t\t\t} else {\n\t\t\t\trc_rcfile = strdup(rcfile);\n\t\t\t\trc_rcfile_default = 1;\n\t\t\t}\n\t\t}\n\t}\n\n\targv2 = (char **) malloc(argmax * sizeof(char *));\n\targv2[argc2++] = strdup(argv[0]);\n\n\tif (! norc) {\n\t\tchar line[4096], parm[400], tmp[401];\n\t\tchar *buf, *tbuf;\n\t\tstruct stat sbuf;\n\t\tint sz;\n\n\t\tif (fstat(fileno(rc), &sbuf) != 0) {\n\t\t\tfprintf(stderr, \"problem with %s\\n\", infile);\n\t\t\tperror(\"fstat\");\n\t\t\texit(1);\n\t\t}\n\t\tsz = sbuf.st_size+1;\t/* allocate whole file size */\n\t\tif (sz < 1024) {\n\t\t\tsz = 1024;\n\t\t}\n\n\t\tbuf = (char *) malloc(sz);\n\t\tbuf[0] = '\\0';\n\n\t\twhile (fgets(line, 4096, rc) != NULL) {\n\t\t\tchar *q, *p = line;\n\t\t\tchar c;\n\t\t\tint cont = 0;\n\n\t\t\tq = p;\n\t\t\tc = '\\0';\n\t\t\twhile (*q) {\n\t\t\t\tif (*q == '#') {\n\t\t\t\t\tif (c != '\\\\') {\n\t\t\t\t\t\t*q = '\\0';\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tc = *q;\n\t\t\t\tq++;\n\t\t\t}\n\n\t\t\tq = p;\n\t\t\tc = '\\0';\n\t\t\twhile (*q) {\n\t\t\t\tif (*q == '\\n') {\n\t\t\t\t\tif (c == '\\\\') {\n\t\t\t\t\t\tcont = 1;\n\t\t\t\t\t\t*q = '\\0';\n\t\t\t\t\t\t*(q-1) = ' ';\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\twhile (isspace((unsigned char) (*q))) {\n\t\t\t\t\t\t*q = '\\0';\n\t\t\t\t\t\tif (q == p) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tq--;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tc = *q;\n\t\t\t\tq++;\n\t\t\t}\n\t\t\tif (q != p && !cont) {\n\t\t\t\tif (*q == '\\0') {\n\t\t\t\t\tq--;\n\t\t\t\t}\n\t\t\t\twhile (isspace((unsigned char) (*q))) {\n\t\t\t\t\t*q = '\\0';\n\t\t\t\t\tif (q == p) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tq--;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tp = lblanks(p);\n\n\t\t\tstrncat(buf, p, sz - strlen(buf) - 1);\n\t\t\tif (cont) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (buf[0] == '\\0') {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\ti = 0;\n\t\t\tq = buf;\n\t\t\twhile (*q) {\n\t\t\t\ti++;\n\t\t\t\tif (*q == '\\n' || isspace((unsigned char) (*q))) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tq++;\n\t\t\t}\n\n\t\t\tif (i >= 400) {\n\t\t\t\tfprintf(stderr, \"invalid rcfile line: %s/%s\\n\",\n\t\t\t\t    p, buf);\n\t\t\t\texit(1);\n\t\t\t}\n\n\t\t\tif (sscanf(buf, \"%s\", parm) != 1) {\n\t\t\t\tfprintf(stderr, \"invalid rcfile line: %s\\n\", p);\n\t\t\t\texit(1);\n\t\t\t}\n\t\t\tif (parm[0] == '-') {\n\t\t\t\tstrncpy(tmp, parm, 400); \n\t\t\t} else {\n\t\t\t\ttmp[0] = '-';\n\t\t\t\tstrncpy(tmp+1, parm, 400); \n\t\t\t}\n\n\t\t\tif (strstr(tmp, \"-loop\") == tmp) {\n\t\t\t\tif (! getenv(\"X11VNC_LOOP_MODE\")) {\n\t\t\t\t\tcheck_loop_mode(argc, argv, 1);\n\t\t\t\t\texit(0);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\targv2[argc2++] = strdup(tmp);\n\t\t\tif (argc2 >= argmax) {\n\t\t\t\tfprintf(stderr, \"too many rcfile options\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\t\t\t\n\t\t\tp = buf;\n\t\t\tp += strlen(parm);\n\t\t\tp = lblanks(p);\n\n\t\t\tif (*p == '\\0') {\n\t\t\t\tbuf[0] = '\\0';\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\ttbuf = (char *) calloc(strlen(p) + 1, 1);\n\n\t\t\tj = 0;\n\t\t\twhile (*p) {\n\t\t\t\tif (*p == '\\\\' && *(p+1) == '#') {\n\t\t\t\t\t;\n\t\t\t\t} else {\n\t\t\t\t\ttbuf[j++] = *p;\n\t\t\t\t}\n\t\t\t\tp++;\n\t\t\t}\n\n\t\t\targv2[argc2++] = strdup(tbuf);\n\t\t\tfree(tbuf);\n\t\t\tif (argc2 >= argmax) {\n\t\t\t\tfprintf(stderr, \"too many rcfile options\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\t\t\tbuf[0] = '\\0';\n\t\t}\n\t\tfclose(rc);\n\t\tfree(buf);\n\t}\n\tpwlast = 0;\n\tenclast = 0;\n\tfor (i=1; i < argc; i++) {\n\t\targv2[argc2++] = strdup(argv[i]);\n\n\t\tif (pwlast || !strcmp(\"-passwd\", argv[i])\n\t\t    || !strcmp(\"-viewpasswd\", argv[i])) {\n\t\t\tchar *p = argv[i];\t\t\n\t\t\tif (pwlast) {\n\t\t\t\tpwlast = 0;\n\t\t\t} else {\n\t\t\t\tpwlast = 1;\n\t\t\t}\n\t\t\tstrzero(p);\n\t\t}\n\t\tif (enclast || !strcmp(\"-enc\", argv[i])) {\n\t\t\tchar *q, *p = argv[i];\t\t\n\t\t\tif (enclast) {\n\t\t\t\tenclast = 0;\n\t\t\t} else {\n\t\t\t\tenclast = 1;\n\t\t\t}\n\t\t\tq = strstr(p, \"pw=\");\n\t\t\tif (q) {\n\t\t\t\tstrzero(q);\n\t\t\t}\n\t\t}\n\t\tif (argc2 >= argmax) {\n\t\t\tfprintf(stderr, \"too many rcfile options\\n\");\n\t\t\texit(1);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcat",
          "args": [
            "program_cmdline",
            "\"}}\""
          ],
          "line": 2124
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcat",
          "args": [
            "program_cmdline",
            "s"
          ],
          "line": 2123
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcat",
          "args": [
            "program_cmdline",
            "\"{{\""
          ],
          "line": 2122
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcat",
          "args": [
            "program_cmdline",
            "s"
          ],
          "line": 2120
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcat",
          "args": [
            "program_cmdline",
            "\" \""
          ],
          "line": 2117
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "len+1"
          ],
          "line": 2112
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "argv[i]"
          ],
          "line": 2110
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "solid_default"
          ],
          "line": 2106
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getpid",
          "args": [],
          "line": 2104
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "argv[0]"
          ],
          "line": 2103
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "argv[0]"
          ],
          "line": 2102
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "immediate_switch_user",
          "args": [
            "argc",
            "argv"
          ],
          "line": 2095
        },
        "resolved": true,
        "details": {
          "function_name": "immediate_switch_user",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/x11vnc.c",
          "lines": "1276-1329",
          "snippet": "static void immediate_switch_user(int argc, char* argv[]) {\n\tint i, bequiet = 0;\n\tfor (i=1; i < argc; i++) {\n\t\tif (strcmp(argv[i], \"-inetd\")) {\n\t\t\tbequiet = 1;\n\t\t}\n\t\tif (strcmp(argv[i], \"-quiet\")) {\n\t\t\tbequiet = 1;\n\t\t}\n\t\tif (strcmp(argv[i], \"-q\")) {\n\t\t\tbequiet = 1;\n\t\t}\n\t}\n\tfor (i=1; i < argc; i++) {\n\t\tchar *u, *q;\n\n\t\tif (strcmp(argv[i], \"-users\")) {\n\t\t\tcontinue;\n\t\t}\n\t\tif (i == argc - 1) {\n\t\t\tfprintf(stderr, \"not enough arguments for: -users\\n\");\n\t\t\texit(1);\n\t\t}\n\t\tif (*(argv[i+1]) != '=') {\n\t\t\tbreak;\n\t\t}\n\n\t\t/* wants an immediate switch: =bob */\n\t\tu = strdup(argv[i+1]);\n\t\t*u = '+';\n\t\tq = strchr(u, '.');\n\t\tif (q) {\n\t\t\tuser2group = (char **) malloc(2*sizeof(char *));\n\t\t\tuser2group[0] = strdup(u+1);\n\t\t\tuser2group[1] = NULL;\n\t\t\t*q = '\\0';\n\t\t}\n\t\tif (strstr(u, \"+guess\") == u) {\n\t\t\tfprintf(stderr, \"invalid user: %s\\n\", u+1);\n\t\t\texit(1);\n\t\t}\n\t\tif (!switch_user(u, 0)) {\n\t\t\tfprintf(stderr, \"Could not switch to user: %s\\n\", u+1);\n\t\t\texit(1);\n\t\t} else {\n\t\t\tif (!bequiet) {\n\t\t\t\tfprintf(stderr, \"Switched to user: %s\\n\", u+1);\n\t\t\t}\n\t\t\tstarted_as_root = 2;\n\t\t}\n\t\tfree(u);\n\t\tbreak;\n\t}\n}",
          "includes": [
            "#include \"xi2_devices.h\"",
            "#include \"solid.h\"",
            "#include \"pm.h\"",
            "#include \"selection.h\"",
            "#include \"sslhelper.h\"",
            "#include \"sslcmds.h\"",
            "#include \"inet.h\"",
            "#include \"unixpw.h\"",
            "#include \"rates.h\"",
            "#include \"connections.h\"",
            "#include \"screen.h\"",
            "#include \"userinput.h\"",
            "#include \"cursor.h\"",
            "#include \"pointer.h\"",
            "#include \"keyboard.h\"",
            "#include \"cleanup.h\"",
            "#include \"user.h\"",
            "#include \"help.h\"",
            "#include \"gui.h\"",
            "#include \"scan.h\"",
            "#include \"remote.h\"",
            "#include \"win_utils.h\"",
            "#include \"xkb_bell.h\"",
            "#include \"xrandr.h\"",
            "#include \"xinerama.h\"",
            "#include \"xevents.h\"",
            "#include \"xrecord.h\"",
            "#include \"xdamage.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void check_rcfile(int argc, char **argv);",
            "static void immediate_switch_user(int argc, char* argv[]);",
            "static void check_loop_mode(int argc, char* argv[], int force);",
            "static void check_appshare_mode(int argc, char* argv[]);",
            "extern int appshare_main(int argc, char* argv[]);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xi2_devices.h\"\n#include \"solid.h\"\n#include \"pm.h\"\n#include \"selection.h\"\n#include \"sslhelper.h\"\n#include \"sslcmds.h\"\n#include \"inet.h\"\n#include \"unixpw.h\"\n#include \"rates.h\"\n#include \"connections.h\"\n#include \"screen.h\"\n#include \"userinput.h\"\n#include \"cursor.h\"\n#include \"pointer.h\"\n#include \"keyboard.h\"\n#include \"cleanup.h\"\n#include \"user.h\"\n#include \"help.h\"\n#include \"gui.h\"\n#include \"scan.h\"\n#include \"remote.h\"\n#include \"win_utils.h\"\n#include \"xkb_bell.h\"\n#include \"xrandr.h\"\n#include \"xinerama.h\"\n#include \"xevents.h\"\n#include \"xrecord.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nstatic void check_rcfile(int argc, char **argv);\nstatic void immediate_switch_user(int argc, char* argv[]);\nstatic void check_loop_mode(int argc, char* argv[], int force);\nstatic void check_appshare_mode(int argc, char* argv[]);\nextern int appshare_main(int argc, char* argv[]);\n\nstatic void immediate_switch_user(int argc, char* argv[]) {\n\tint i, bequiet = 0;\n\tfor (i=1; i < argc; i++) {\n\t\tif (strcmp(argv[i], \"-inetd\")) {\n\t\t\tbequiet = 1;\n\t\t}\n\t\tif (strcmp(argv[i], \"-quiet\")) {\n\t\t\tbequiet = 1;\n\t\t}\n\t\tif (strcmp(argv[i], \"-q\")) {\n\t\t\tbequiet = 1;\n\t\t}\n\t}\n\tfor (i=1; i < argc; i++) {\n\t\tchar *u, *q;\n\n\t\tif (strcmp(argv[i], \"-users\")) {\n\t\t\tcontinue;\n\t\t}\n\t\tif (i == argc - 1) {\n\t\t\tfprintf(stderr, \"not enough arguments for: -users\\n\");\n\t\t\texit(1);\n\t\t}\n\t\tif (*(argv[i+1]) != '=') {\n\t\t\tbreak;\n\t\t}\n\n\t\t/* wants an immediate switch: =bob */\n\t\tu = strdup(argv[i+1]);\n\t\t*u = '+';\n\t\tq = strchr(u, '.');\n\t\tif (q) {\n\t\t\tuser2group = (char **) malloc(2*sizeof(char *));\n\t\t\tuser2group[0] = strdup(u+1);\n\t\t\tuser2group[1] = NULL;\n\t\t\t*q = '\\0';\n\t\t}\n\t\tif (strstr(u, \"+guess\") == u) {\n\t\t\tfprintf(stderr, \"invalid user: %s\\n\", u+1);\n\t\t\texit(1);\n\t\t}\n\t\tif (!switch_user(u, 0)) {\n\t\t\tfprintf(stderr, \"Could not switch to user: %s\\n\", u+1);\n\t\t\texit(1);\n\t\t} else {\n\t\t\tif (!bequiet) {\n\t\t\t\tfprintf(stderr, \"Switched to user: %s\\n\", u+1);\n\t\t\t}\n\t\t\tstarted_as_root = 2;\n\t\t}\n\t\tfree(u);\n\t\tbreak;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"getuid: %d  geteuid: %d\\n\"",
            "getuid()",
            "geteuid()"
          ],
          "line": 2091
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "geteuid",
          "args": [],
          "line": 2091
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getuid",
          "args": [],
          "line": 2091
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "geteuid",
          "args": [],
          "line": 2088
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getuid",
          "args": [],
          "line": 2088
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "argv[i]",
            "\"-inetd\""
          ],
          "line": 2083
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dtime0",
          "args": [
            "&x11vnc_start"
          ],
          "line": 2080
        },
        "resolved": true,
        "details": {
          "function_name": "dtime0",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/util.c",
          "lines": "429-432",
          "snippet": "double dtime0(double *t_old) {\n\t*t_old = 0.0;\n\treturn dtime(t_old);\n}",
          "includes": [
            "#include \"connections.h\"",
            "#include \"unixpw.h\"",
            "#include \"win_utils.h\"",
            "#include \"cleanup.h\"",
            "#include \"x11vnc.h\"",
            "#include <stdlib.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "double dtime(double *);",
            "double dtime0(double *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"connections.h\"\n#include \"unixpw.h\"\n#include \"win_utils.h\"\n#include \"cleanup.h\"\n#include \"x11vnc.h\"\n#include <stdlib.h>\n\ndouble dtime(double *);\ndouble dtime0(double *);\n\ndouble dtime0(double *t_old) {\n\t*t_old = 0.0;\n\treturn dtime(t_old);\n}"
        }
      },
      {
        "call_info": {
          "callee": "check_appshare_mode",
          "args": [
            "argc",
            "argv"
          ],
          "line": 2078
        },
        "resolved": true,
        "details": {
          "function_name": "check_appshare_mode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/x11vnc.c",
          "lines": "1731-1744",
          "snippet": "static void check_appshare_mode(int argc, char* argv[]) {\n\tint i;\n\n\tfor (i=1; i < argc; i++) {\n\t\tchar *p = argv[i];\n\t\tif (strstr(p, \"--\") == p) {\n\t\t\tp++;\n\t\t}\n\t\tif (strstr(p, \"-appshare\") == p) {\n\t\t\tappshare_main(argc, argv);\n\t\t\texit(0);\n\t\t}\n\t}\n}",
          "includes": [
            "#include \"xi2_devices.h\"",
            "#include \"solid.h\"",
            "#include \"pm.h\"",
            "#include \"selection.h\"",
            "#include \"sslhelper.h\"",
            "#include \"sslcmds.h\"",
            "#include \"inet.h\"",
            "#include \"unixpw.h\"",
            "#include \"rates.h\"",
            "#include \"connections.h\"",
            "#include \"screen.h\"",
            "#include \"userinput.h\"",
            "#include \"cursor.h\"",
            "#include \"pointer.h\"",
            "#include \"keyboard.h\"",
            "#include \"cleanup.h\"",
            "#include \"user.h\"",
            "#include \"help.h\"",
            "#include \"gui.h\"",
            "#include \"scan.h\"",
            "#include \"remote.h\"",
            "#include \"win_utils.h\"",
            "#include \"xkb_bell.h\"",
            "#include \"xrandr.h\"",
            "#include \"xinerama.h\"",
            "#include \"xevents.h\"",
            "#include \"xrecord.h\"",
            "#include \"xdamage.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void check_rcfile(int argc, char **argv);",
            "static void immediate_switch_user(int argc, char* argv[]);",
            "static void check_loop_mode(int argc, char* argv[], int force);",
            "static void check_appshare_mode(int argc, char* argv[]);",
            "extern int appshare_main(int argc, char* argv[]);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xi2_devices.h\"\n#include \"solid.h\"\n#include \"pm.h\"\n#include \"selection.h\"\n#include \"sslhelper.h\"\n#include \"sslcmds.h\"\n#include \"inet.h\"\n#include \"unixpw.h\"\n#include \"rates.h\"\n#include \"connections.h\"\n#include \"screen.h\"\n#include \"userinput.h\"\n#include \"cursor.h\"\n#include \"pointer.h\"\n#include \"keyboard.h\"\n#include \"cleanup.h\"\n#include \"user.h\"\n#include \"help.h\"\n#include \"gui.h\"\n#include \"scan.h\"\n#include \"remote.h\"\n#include \"win_utils.h\"\n#include \"xkb_bell.h\"\n#include \"xrandr.h\"\n#include \"xinerama.h\"\n#include \"xevents.h\"\n#include \"xrecord.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nstatic void check_rcfile(int argc, char **argv);\nstatic void immediate_switch_user(int argc, char* argv[]);\nstatic void check_loop_mode(int argc, char* argv[], int force);\nstatic void check_appshare_mode(int argc, char* argv[]);\nextern int appshare_main(int argc, char* argv[]);\n\nstatic void check_appshare_mode(int argc, char* argv[]) {\n\tint i;\n\n\tfor (i=1; i < argc; i++) {\n\t\tchar *p = argv[i];\n\t\tif (strstr(p, \"--\") == p) {\n\t\t\tp++;\n\t\t}\n\t\tif (strstr(p, \"-appshare\") == p) {\n\t\t\tappshare_main(argc, argv);\n\t\t\texit(0);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "check_loop_mode",
          "args": [
            "argc",
            "argv",
            "0"
          ],
          "line": 2075
        },
        "resolved": true,
        "details": {
          "function_name": "check_loop_mode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/x11vnc.c",
          "lines": "1644-1727",
          "snippet": "static void check_loop_mode(int argc, char* argv[], int force) {\n\tint i;\n\tint loop_mode = 0, loop_sleep = 2000, loop_max = 0;\n\n\tif (force) {\n\t\tloop_mode = 1;\n\t}\n\tfor (i=1; i < argc; i++) {\n\t\tchar *p = argv[i];\n\t\tif (strstr(p, \"--\") == p) {\n\t\t\tp++;\n\t\t}\n\t\tif (strstr(p, \"-loop\") == p) {\n\t\t\tchar *q;\n\t\t\tloop_mode = 1;\n\t\t\tif ((q = strchr(p, ',')) != NULL) {\n\t\t\t\tloop_max = atoi(q+1);\n\t\t\t\t*q = '\\0';\n\t\t\t}\n\t\t\tif (strstr(p, \"-loopbg\") == p) {\n\t\t\t\tset_env(\"X11VNC_LOOP_MODE_BG\", \"1\");\n\t\t\t\tloop_sleep = 500;\n\t\t\t}\n\t\t\t\n\t\t\tq = strpbrk(p, \"0123456789\");\n\t\t\tif (q) {\n\t\t\t\tloop_sleep = atoi(q);\n\t\t\t\tif (loop_sleep <= 0) {\n\t\t\t\t\tloop_sleep = 20;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tif (loop_mode && getenv(\"X11VNC_LOOP_MODE\") == NULL) {\n#if LIBVNCSERVER_HAVE_FORK\n\t\tchar **argv2;\n\t\tint k, i = 1;\n\n\t\tset_env(\"X11VNC_LOOP_MODE\", \"1\");\n\t\targv2 = (char **) malloc((argc+1)*sizeof(char *));\n\n\t\tfor (k=0; k < argc+1; k++) {\n\t\t\targv2[k] = NULL;\n\t\t\tif (k < argc) {\n\t\t\t\targv2[k] = argv[k];\n\t\t\t}\n\t\t}\n\t\twhile (1) {\n\t\t\tint status;\n\t\t\tpid_t p;\n\t\t\tfprintf(stderr, \"\\n --- x11vnc loop: %d ---\\n\\n\", i++);\n\t\t\tfflush(stderr);\n\t\t\tusleep(500 * 1000);\n\t\t\tif ((p = fork()) > 0)  {\n\t\t\t\tfprintf(stderr, \" --- x11vnc loop: waiting \"\n\t\t\t\t    \"for: %d\\n\\n\", p);\n\t\t\t\twait(&status);\n\t\t\t} else if (p == -1) {\n\t\t\t\tfprintf(stderr, \"could not fork\\n\");\n\t\t\t\tperror(\"fork\");\n\t\t\t\texit(1);\n\t\t\t} else {\n\t\t\t\t/* loop mode: no_external_cmds does not apply */\n\t\t\t\texecvp(argv[0], argv2); \n\t\t\t\texit(1);\n\t\t\t}\n\n\t\t\tif (loop_max > 0 && i > loop_max) {\n\t\t\t\tfprintf(stderr, \"\\n --- x11vnc loop: did %d\"\n\t\t\t\t    \" done. ---\\n\\n\", loop_max);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t\tfprintf(stderr, \"\\n --- x11vnc loop: sleeping %d ms \"\n\t\t\t    \"---\\n\\n\", loop_sleep);\n\t\t\tusleep(loop_sleep * 1000);\n\t\t}\n\t\texit(0);\n#else\n\t\tfprintf(stderr, \"fork unavailable, cannot do -loop mode\\n\");\n\t\texit(1);\n#endif\n\t}\n}",
          "includes": [
            "#include \"xi2_devices.h\"",
            "#include \"solid.h\"",
            "#include \"pm.h\"",
            "#include \"selection.h\"",
            "#include \"sslhelper.h\"",
            "#include \"sslcmds.h\"",
            "#include \"inet.h\"",
            "#include \"unixpw.h\"",
            "#include \"rates.h\"",
            "#include \"connections.h\"",
            "#include \"screen.h\"",
            "#include \"userinput.h\"",
            "#include \"cursor.h\"",
            "#include \"pointer.h\"",
            "#include \"keyboard.h\"",
            "#include \"cleanup.h\"",
            "#include \"user.h\"",
            "#include \"help.h\"",
            "#include \"gui.h\"",
            "#include \"scan.h\"",
            "#include \"remote.h\"",
            "#include \"win_utils.h\"",
            "#include \"xkb_bell.h\"",
            "#include \"xrandr.h\"",
            "#include \"xinerama.h\"",
            "#include \"xevents.h\"",
            "#include \"xrecord.h\"",
            "#include \"xdamage.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void check_rcfile(int argc, char **argv);",
            "static void immediate_switch_user(int argc, char* argv[]);",
            "static void check_loop_mode(int argc, char* argv[], int force);",
            "static void check_appshare_mode(int argc, char* argv[]);",
            "static char **argv2;",
            "extern int appshare_main(int argc, char* argv[]);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xi2_devices.h\"\n#include \"solid.h\"\n#include \"pm.h\"\n#include \"selection.h\"\n#include \"sslhelper.h\"\n#include \"sslcmds.h\"\n#include \"inet.h\"\n#include \"unixpw.h\"\n#include \"rates.h\"\n#include \"connections.h\"\n#include \"screen.h\"\n#include \"userinput.h\"\n#include \"cursor.h\"\n#include \"pointer.h\"\n#include \"keyboard.h\"\n#include \"cleanup.h\"\n#include \"user.h\"\n#include \"help.h\"\n#include \"gui.h\"\n#include \"scan.h\"\n#include \"remote.h\"\n#include \"win_utils.h\"\n#include \"xkb_bell.h\"\n#include \"xrandr.h\"\n#include \"xinerama.h\"\n#include \"xevents.h\"\n#include \"xrecord.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nstatic void check_rcfile(int argc, char **argv);\nstatic void immediate_switch_user(int argc, char* argv[]);\nstatic void check_loop_mode(int argc, char* argv[], int force);\nstatic void check_appshare_mode(int argc, char* argv[]);\nstatic char **argv2;\nextern int appshare_main(int argc, char* argv[]);\n\nstatic void check_loop_mode(int argc, char* argv[], int force) {\n\tint i;\n\tint loop_mode = 0, loop_sleep = 2000, loop_max = 0;\n\n\tif (force) {\n\t\tloop_mode = 1;\n\t}\n\tfor (i=1; i < argc; i++) {\n\t\tchar *p = argv[i];\n\t\tif (strstr(p, \"--\") == p) {\n\t\t\tp++;\n\t\t}\n\t\tif (strstr(p, \"-loop\") == p) {\n\t\t\tchar *q;\n\t\t\tloop_mode = 1;\n\t\t\tif ((q = strchr(p, ',')) != NULL) {\n\t\t\t\tloop_max = atoi(q+1);\n\t\t\t\t*q = '\\0';\n\t\t\t}\n\t\t\tif (strstr(p, \"-loopbg\") == p) {\n\t\t\t\tset_env(\"X11VNC_LOOP_MODE_BG\", \"1\");\n\t\t\t\tloop_sleep = 500;\n\t\t\t}\n\t\t\t\n\t\t\tq = strpbrk(p, \"0123456789\");\n\t\t\tif (q) {\n\t\t\t\tloop_sleep = atoi(q);\n\t\t\t\tif (loop_sleep <= 0) {\n\t\t\t\t\tloop_sleep = 20;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tif (loop_mode && getenv(\"X11VNC_LOOP_MODE\") == NULL) {\n#if LIBVNCSERVER_HAVE_FORK\n\t\tchar **argv2;\n\t\tint k, i = 1;\n\n\t\tset_env(\"X11VNC_LOOP_MODE\", \"1\");\n\t\targv2 = (char **) malloc((argc+1)*sizeof(char *));\n\n\t\tfor (k=0; k < argc+1; k++) {\n\t\t\targv2[k] = NULL;\n\t\t\tif (k < argc) {\n\t\t\t\targv2[k] = argv[k];\n\t\t\t}\n\t\t}\n\t\twhile (1) {\n\t\t\tint status;\n\t\t\tpid_t p;\n\t\t\tfprintf(stderr, \"\\n --- x11vnc loop: %d ---\\n\\n\", i++);\n\t\t\tfflush(stderr);\n\t\t\tusleep(500 * 1000);\n\t\t\tif ((p = fork()) > 0)  {\n\t\t\t\tfprintf(stderr, \" --- x11vnc loop: waiting \"\n\t\t\t\t    \"for: %d\\n\\n\", p);\n\t\t\t\twait(&status);\n\t\t\t} else if (p == -1) {\n\t\t\t\tfprintf(stderr, \"could not fork\\n\");\n\t\t\t\tperror(\"fork\");\n\t\t\t\texit(1);\n\t\t\t} else {\n\t\t\t\t/* loop mode: no_external_cmds does not apply */\n\t\t\t\texecvp(argv[0], argv2); \n\t\t\t\texit(1);\n\t\t\t}\n\n\t\t\tif (loop_max > 0 && i > loop_max) {\n\t\t\t\tfprintf(stderr, \"\\n --- x11vnc loop: did %d\"\n\t\t\t\t    \" done. ---\\n\\n\", loop_max);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t\tfprintf(stderr, \"\\n --- x11vnc loop: sleeping %d ms \"\n\t\t\t    \"---\\n\\n\", loop_sleep);\n\t\t\tusleep(loop_sleep * 1000);\n\t\t}\n\t\texit(0);\n#else\n\t\tfprintf(stderr, \"fork unavailable, cannot do -loop mode\\n\");\n\t\texit(1);\n#endif\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xi2_devices.h\"\n#include \"solid.h\"\n#include \"pm.h\"\n#include \"selection.h\"\n#include \"sslhelper.h\"\n#include \"sslcmds.h\"\n#include \"inet.h\"\n#include \"unixpw.h\"\n#include \"rates.h\"\n#include \"connections.h\"\n#include \"screen.h\"\n#include \"userinput.h\"\n#include \"cursor.h\"\n#include \"pointer.h\"\n#include \"keyboard.h\"\n#include \"cleanup.h\"\n#include \"user.h\"\n#include \"help.h\"\n#include \"gui.h\"\n#include \"scan.h\"\n#include \"remote.h\"\n#include \"win_utils.h\"\n#include \"xkb_bell.h\"\n#include \"xrandr.h\"\n#include \"xinerama.h\"\n#include \"xevents.h\"\n#include \"xrecord.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nstatic void check_rcfile(int argc, char **argv);\nstatic void immediate_switch_user(int argc, char* argv[]);\nstatic void print_settings(int try_http, int bg, char *gui_str);\nstatic void check_loop_mode(int argc, char* argv[], int force);\nstatic void check_appshare_mode(int argc, char* argv[]);\nstatic int argc2 = 0;\nstatic char **argv2;\nextern int appshare_main(int argc, char* argv[]);\nextern int is_decimal(char *);\n\nint main(int argc, char* argv[]) {\n\n\tint i, len, tmpi;\n\tint ev, er, maj, min;\n\tchar *arg;\n\tint remote_sync = 0;\n\tchar *remote_cmd = NULL;\n\tchar *query_cmd  = NULL;\n\tint query_retries = 0;\n\tdouble query_delay = 0.5;\n\tchar *query_match  = NULL;\n\tchar *gui_str = NULL;\n\tint got_gui_pw = 0;\n\tint pw_loc = -1, got_passwd = 0, got_rfbauth = 0, nopw = NOPW;\n\tint got_viewpasswd = 0, got_localhost = 0, got_passwdfile = 0;\n\tint vpw_loc = -1;\n\tint dt = 0, bg = 0;\n\tint got_rfbwait = 0;\n\tint got_httpdir = 0, try_http = 0;\n\tint orig_use_xdamage = use_xdamage;\n\tint http_oneport_msg = 0;\n\tXImage *fb0 = NULL;\n\tint ncache_msg = 0;\n\tchar *got_rfbport_str = NULL;\n\tint got_rfbport_pos = -1;\n\tint got_tls = 0;\n\tint got_inetd = 0;\n\tint got_noxrandr = 0;\n\n\t/* used to pass args we do not know about to rfbGetScreen(): */\n\tint argc_vnc_max = 1024;\n\tint argc_vnc = 1; char *argv_vnc[2048];\n\n\t/* check for -loop mode: */\n\tcheck_loop_mode(argc, argv, 0);\n\n\t/* check for -appshare mode: */\n\tcheck_appshare_mode(argc, argv);\n\n\tdtime0(&x11vnc_start);\n\n\tfor (i=1; i < argc; i++) {\n\t\tif (!strcmp(argv[i], \"-inetd\")) {\n\t\t\tgot_inetd = 1;\n\t\t}\n\t}\n\n\tif (!getuid() || !geteuid()) {\n\t\tstarted_as_root = 1;\n\t\tif (0 && !got_inetd) {\n\t\t\trfbLog(\"getuid: %d  geteuid: %d\\n\", getuid(), geteuid());\n\t\t}\n\n\t\t/* check for '-users =bob' */\n\t\timmediate_switch_user(argc, argv);\n\t}\n\n\tfor (i=0; i < 2048; i++) {\n\t\targv_vnc[i] = NULL;\n\t}\n\n\targv_vnc[0] = strdup(argv[0]);\n\tprogram_name = strdup(argv[0]);\n\tprogram_pid = (int) getpid();\n\n\tsolid_default = strdup(solid_default);\t/* for freeing with -R */\n\n\tlen = 0;\n\tfor (i=1; i < argc; i++) {\n\t\tlen += strlen(argv[i]) + 4 + 1;\n\t}\n\tprogram_cmdline = (char *) malloc(len+1);\n\tprogram_cmdline[0] = '\\0';\n\tfor (i=1; i < argc; i++) {\n\t\tchar *s = argv[i];\n\t\tif (program_cmdline[0]) {\n\t\t\tstrcat(program_cmdline, \" \");\n\t\t}\n\t\tif (*s == '-') {\n\t\t\tstrcat(program_cmdline, s);\n\t\t} else {\n\t\t\tstrcat(program_cmdline, \"{{\");\n\t\t\tstrcat(program_cmdline, s);\n\t\t\tstrcat(program_cmdline, \"}}\");\n\t\t}\n\t}\n\n\tfor (i=0; i<ICON_MODE_SOCKS; i++) {\n\t\ticon_mode_socks[i] = -1;\n\t}\n\n\tcheck_rcfile(argc, argv);\n\t/* kludge for the new array argv2 set in check_rcfile() */\n#\tdefine argc argc2\n#\tdefine argv argv2\n\n#\tdefine CHECK_ARGC if (i >= argc-1) { \\\n\t\tfprintf(stderr, \"not enough arguments for: %s\\n\", arg); \\\n\t\texit(1); \\\n\t}\n\n\t/*\n\t * do a quick check for parameters that apply to \"utility\"\n\t * commands, i.e. ones that do not run the server.\n\t */\n\tfor (i=1; i < argc; i++) {\n\t\targ = argv[i];\n\t\tif (strstr(arg, \"--\") == arg) {\n\t\t\targ++;\n\t\t}\n\t\tif (!strcmp(arg, \"-ssldir\")) {\n\t\t\tCHECK_ARGC\n\t\t\tssl_certs_dir = strdup(argv[++i]);\n\t\t}\n\t}\n\n\t/*\n\t * do a quick check for -env parameters\n\t */\n\tfor (i=1; i < argc; i++) {\n\t\tchar *p, *q;\n\t\targ = argv[i];\n\t\tif (strstr(arg, \"--\") == arg) {\n\t\t\targ++;\n\t\t}\n\t\tif (!strcmp(arg, \"-env\")) {\n\t\t\tCHECK_ARGC\n\t\t\tp = strdup(argv[++i]);\n\t\t\tq = strchr(p, '=');\n\t\t\tif (! q) {\n\t\t\t\tfprintf(stderr, \"no -env '=' found: %s\\n\", p);\n\t\t\t\texit(1);\n\t\t\t} else {\n\t\t\t\t*q = '\\0';\n\t\t\t}\n\t\t\tset_env(p, q+1);\n\t\t\tfree(p);\n\t\t}\n\t}\n\n\tfor (i=1; i < argc; i++) {\n\t\t/* quick-n-dirty --option handling. */\n\t\targ = argv[i];\n\t\tif (strstr(arg, \"--\") == arg) {\n\t\t\targ++;\n\t\t}\n\n\t\tif (!strcmp(arg, \"-display\")) {\n\t\t\tCHECK_ARGC\n\t\t\tuse_dpy = strdup(argv[++i]);\n\t\t\tif (strstr(use_dpy, \"WAIT\")) {\n\t\t\t\textern char find_display[];\n\t\t\t\textern char create_display[];\n\t\t\t\tif (strstr(use_dpy, \"cmd=FINDDISPLAY-print\")) {\n\t\t\t\t\tfprintf(stdout, \"%s\", find_display);\n\t\t\t\t\texit(0);\n\t\t\t\t}\n\t\t\t\tif (strstr(use_dpy, \"cmd=FINDCREATEDISPLAY-print\")) {\n\t\t\t\t\tfprintf(stdout, \"%s\", create_display);\n\t\t\t\t\texit(0);\n\t\t\t\t}\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strcmp(arg, \"-reopen\")) {\n\t\t\tchar *str = getenv(\"X11VNC_REOPEN_DISPLAY\");\n\t\t\tif (str) {\n\t\t\t\tint rmax = atoi(str);\n\t\t\t\tif (rmax > 0) {\n\t\t\t\t\tset_env(\"X11VNC_REOPEN_DISPLAY\", str);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tset_env(\"X11VNC_REOPEN_DISPLAY\", \"1\");\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strcmp(arg, \"-find\")) {\n\t\t\tuse_dpy = strdup(\"WAIT:cmd=FINDDISPLAY\");\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strcmp(arg, \"-finddpy\") || strstr(arg, \"-listdpy\") == arg) {\n\t\t\tint ic = 0;\n\t\t\tuse_dpy = strdup(\"WAIT:cmd=FINDDISPLAY-run\");\n\t\t\tif (argc > i+1) {\n\t\t\t\tset_env(\"X11VNC_USER\", argv[i+1]);\n\t\t\t\tfprintf(stdout, \"X11VNC_USER=%s\\n\", getenv(\"X11VNC_USER\"));\n\t\t\t}\n\t\t\tif (strstr(arg, \"-listdpy\") == arg) {\n\t\t\t\tset_env(\"FIND_DISPLAY_ALL\", \"1\");\n\t\t\t}\n\t\t\twait_for_client(&ic, NULL, 0);\n\t\t\texit(0);\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strcmp(arg, \"-findauth\")) {\n\t\t\tgot_findauth = 1;\n\t\t\tif (argc > i+1) {\n\t\t\t\tchar *s = argv[i+1];\n\t\t\t\tif (s[0] != '-') {\n\t\t\t\t\tset_env(\"FINDAUTH_DISPLAY\", argv[i+1]);\n\t\t\t\t\ti++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strcmp(arg, \"-create\")) {\n\t\t\tuse_dpy = strdup(\"WAIT:cmd=FINDCREATEDISPLAY-Xvfb\");\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strcmp(arg, \"-create_xsrv\")) {\n\t\t\tCHECK_ARGC\n\t\t\tuse_dpy = (char *) malloc(strlen(argv[i+1])+100); \n\t\t\tsprintf(use_dpy, \"WAIT:cmd=FINDCREATEDISPLAY-%s\", argv[++i]);\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strcmp(arg, \"-xdummy\")) {\n\t\t\tuse_dpy = strdup(\"WAIT:cmd=FINDCREATEDISPLAY-Xdummy\");\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strcmp(arg, \"-xdummy_xvfb\")) {\n\t\t\tuse_dpy = strdup(\"WAIT:cmd=FINDCREATEDISPLAY-Xdummy,Xvfb\");\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strcmp(arg, \"-xvnc\")) {\n\t\t\tuse_dpy = strdup(\"WAIT:cmd=FINDCREATEDISPLAY-Xvnc\");\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strcmp(arg, \"-xvnc_redirect\")) {\n\t\t\tuse_dpy = strdup(\"WAIT:cmd=FINDCREATEDISPLAY-Xvnc.redirect\");\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strcmp(arg, \"-redirect\")) {\n\t\t\tchar *q, *t, *t0 = \"WAIT:cmd=FINDDISPLAY-vnc_redirect\";\n\t\t\tCHECK_ARGC\n\t\t\tt = (char *) malloc(strlen(t0) + strlen(argv[++i]) + 2);\n\t\t\tq = strrchr(argv[i], ':');\n\t\t\tif (q) *q = ' ';\n\t\t\tsprintf(t, \"%s=%s\", t0, argv[i]);\n\t\t\tuse_dpy = t;\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strcmp(arg, \"-auth\") || !strcmp(arg, \"-xauth\")) {\n\t\t\tCHECK_ARGC\n\t\t\tauth_file = strdup(argv[++i]);\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strcmp(arg, \"-N\")) {\n\t\t\tdisplay_N = 1;\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strcmp(arg, \"-autoport\")) {\n\t\t\tCHECK_ARGC\n\t\t\tauto_port = atoi(argv[++i]);\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strcmp(arg, \"-reflect\")) {\n\t\t\tCHECK_ARGC\n\t\t\traw_fb_str = (char *) malloc(4 + strlen(argv[i+1]) + 1);\n\t\t\tsprintf(raw_fb_str, \"vnc:%s\", argv[++i]);\n\t\t\tshared = 1;\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strcmp(arg, \"-tsd\")) {\n\t\t\tCHECK_ARGC\n\t\t\tterminal_services_daemon = strdup(argv[++i]);\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strcmp(arg, \"-id\") || !strcmp(arg, \"-sid\")) {\n\t\t\tCHECK_ARGC\n\t\t\tif (!strcmp(arg, \"-sid\")) {\n\t\t\t\trootshift = 1;\n\t\t\t} else {\n\t\t\t\trootshift = 0;\n\t\t\t}\n\t\t\ti++;\n\t\t\tif (!strcmp(\"pick\", argv[i])) {\n\t\t\t\tif (started_as_root) {\n\t\t\t\t\tfprintf(stderr, \"unsafe: %s pick\\n\",\n\t\t\t\t\t    arg);\n\t\t\t\t\texit(1);\n\t\t\t\t} else if (! pick_windowid(&subwin)) {\n\t\t\t\t\tfprintf(stderr, \"invalid %s pick\\n\",\n\t\t\t\t\t    arg);\n\t\t\t\t\texit(1);\n\t\t\t\t}\n\t\t\t} else if (! scan_hexdec(argv[i], &subwin)) {\n\t\t\t\tfprintf(stderr, \"invalid %s arg: %s\\n\", arg,\n\t\t\t\t    argv[i]);\n\t\t\t\texit(1);\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strcmp(arg, \"-waitmapped\")) {\n\t\t\tsubwin_wait_mapped = 1;\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strcmp(arg, \"-clip\")) {\n\t\t\tCHECK_ARGC\n\t\t\tclip_str = strdup(argv[++i]);\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strcmp(arg, \"-flashcmap\")) {\n\t\t\tflash_cmap = 1;\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strcmp(arg, \"-shiftcmap\")) {\n\t\t\tCHECK_ARGC\n\t\t\tshift_cmap = atoi(argv[++i]);\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strcmp(arg, \"-notruecolor\")) {\n\t\t\tforce_indexed_color = 1;\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strcmp(arg, \"-advertise_truecolor\")) {\n\t\t\tadvertise_truecolor = 1;\n\t\t\tif (i < argc-1) {\n\t\t\t\tchar *s = argv[i+1];\n\t\t\t\tif (s[0] != '-') {\n\t\t\t\t\tif (strstr(s, \"reset\")) {\n\t\t\t\t\t\tadvertise_truecolor_reset = 1;\n\t\t\t\t\t}\n\t\t\t\t\ti++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strcmp(arg, \"-overlay\")) {\n\t\t\toverlay = 1;\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strcmp(arg, \"-overlay_nocursor\")) {\n\t\t\toverlay = 1;\n\t\t\toverlay_cursor = 0;\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strcmp(arg, \"-overlay_yescursor\")) {\n\t\t\toverlay = 1;\n\t\t\toverlay_cursor = 2;\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strcmp(arg, \"-8to24\")) {\n#if !SKIP_8TO24\n\t\t\tcmap8to24 = 1;\n\t\t\tif (i < argc-1) {\n\t\t\t\tchar *s = argv[i+1];\n\t\t\t\tif (s[0] != '-') {\n\t\t\t\t\tcmap8to24_str = strdup(s);\n\t\t\t\t\ti++;\n\t\t\t\t}\n\t\t\t}\n#endif\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strcmp(arg, \"-24to32\")) {\n\t\t\txform24to32 = 1;\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strcmp(arg, \"-visual\")) {\n\t\t\tCHECK_ARGC\n\t\t\tvisual_str = strdup(argv[++i]);\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strcmp(arg, \"-scale\")) {\n\t\t\tCHECK_ARGC\n\t\t\tscale_str = strdup(argv[++i]);\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strcmp(arg, \"-geometry\")) {\n\t\t\tCHECK_ARGC\n\t\t\tscale_str = strdup(argv[++i]);\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strcmp(arg, \"-scale_cursor\")) {\n\t\t\tCHECK_ARGC\n\t\t\tscale_cursor_str = strdup(argv[++i]);\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strcmp(arg, \"-viewonly\")) {\n\t\t\tview_only = 1;\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strcmp(arg, \"-noviewonly\")) {\n\t\t\tview_only = 0;\n\t\t\tgot_noviewonly = 1;\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strcmp(arg, \"-shared\")) {\n\t\t\tshared = 1;\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strcmp(arg, \"-noshared\")) {\n\t\t\tshared = 0;\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strcmp(arg, \"-once\")) {\n\t\t\tconnect_once = 1;\n\t\t\tgot_connect_once = 1;\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strcmp(arg, \"-many\") || !strcmp(arg, \"-forever\")) {\n\t\t\tconnect_once = 0;\n\t\t\tcontinue;\n\t\t}\n\t\tif (strstr(arg, \"-loop\") == arg) {\n\t\t\t;\t/* handled above */\n\t\t\tcontinue;\n\t\t}\n\t\tif (strstr(arg, \"-appshare\") == arg) {\n\t\t\t;\t/* handled above */\n\t\t\tcontinue;\n\t\t}\n\t\tif (strstr(arg, \"-freeze_when_obscured\") == arg) {\n\t\t\tfreeze_when_obscured = 1;\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strcmp(arg, \"-timeout\")) {\n\t\t\tCHECK_ARGC\n\t\t\tfirst_conn_timeout = atoi(argv[++i]);\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strcmp(arg, \"-sleepin\")) {\n\t\t\tCHECK_ARGC\n\t\t\tdo_sleepin(argv[++i]);\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strcmp(arg, \"-users\")) {\n\t\t\tCHECK_ARGC\n\t\t\tusers_list = strdup(argv[++i]);\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strcmp(arg, \"-inetd\")) {\n\t\t\tinetd = 1;\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strcmp(arg, \"-notightfilexfer\")) {\n\t\t\ttightfilexfer = 0;\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strcmp(arg, \"-tightfilexfer\")) {\n\t\t\ttightfilexfer = 1;\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strcmp(arg, \"-http\")) {\n\t\t\ttry_http = 1;\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strcmp(arg, \"-http_ssl\")) {\n\t\t\ttry_http = 1;\n\t\t\thttp_ssl = 1;\n\t\t\tgot_tls++;\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strcmp(arg, \"-avahi\") || !strcmp(arg, \"-mdns\") || !strcmp(arg, \"-zeroconf\")) {\n\t\t\tavahi = 1;\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strcmp(arg, \"-connect\") ||\n\t\t    !strcmp(arg, \"-connect_or_exit\") ||\n\t\t    !strcmp(arg, \"-coe\")) {\n\t\t\tCHECK_ARGC\n\t\t\tif (!strcmp(arg, \"-connect_or_exit\")) {\n\t\t\t\tconnect_or_exit = 1;\n\t\t\t} else if (!strcmp(arg, \"-coe\")) {\n\t\t\t\tconnect_or_exit = 1;\n\t\t\t}\n\t\t\tif (strchr(argv[++i], '/') && !strstr(argv[i], \"repeater://\")) {\n\t\t\t\tstruct stat sb;\n\t\t\t\tclient_connect_file = strdup(argv[i]);\n\t\t\t\tif (stat(client_connect_file, &sb) != 0) {\n\t\t\t\t\tFILE* f = fopen(client_connect_file, \"w\");\n\t\t\t\t\tif (f != NULL) fclose(f);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tclient_connect = strdup(argv[i]);\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strcmp(arg, \"-proxy\")) {\n\t\t\tCHECK_ARGC\n\t\t\tconnect_proxy = strdup(argv[++i]);\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strcmp(arg, \"-vncconnect\")) {\n\t\t\tvnc_connect = 1;\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strcmp(arg, \"-novncconnect\")) {\n\t\t\tvnc_connect = 0;\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strcmp(arg, \"-allow\")) {\n\t\t\tCHECK_ARGC\n\t\t\tallow_list = strdup(argv[++i]);\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strcmp(arg, \"-localhost\")) {\n\t\t\tallow_list = strdup(\"127.0.0.1\");\n\t\t\tgot_localhost = 1;\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strcmp(arg, \"-unixsock\")) {\n\t\t\tCHECK_ARGC\n\t\t\tunix_sock = strdup(argv[++i]);\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strcmp(arg, \"-listen6\")) {\n\t\t\tCHECK_ARGC\n#if X11VNC_IPV6\n\t\t\tlisten_str6 = strdup(argv[++i]);\n#else\n\t\t\t++i;\n#endif\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strcmp(arg, \"-nolookup\")) {\n\t\t\thost_lookup = 0;\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strcmp(arg, \"-6\")) {\n#if X11VNC_IPV6\n\t\t\tipv6_listen = 1;\n\t\t\tgot_ipv6_listen = 1;\n#endif\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strcmp(arg, \"-no6\")) {\n#if X11VNC_IPV6\n\t\t\tipv6_listen = 0;\n\t\t\tgot_ipv6_listen = 0;\n#endif\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strcmp(arg, \"-noipv6\")) {\n\t\t\tnoipv6 = 1;\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strcmp(arg, \"-noipv4\")) {\n\t\t\tnoipv4 = 1;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!strcmp(arg, \"-input\")) {\n\t\t\tCHECK_ARGC\n\t\t\tallowed_input_str = strdup(argv[++i]);\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strcmp(arg, \"-grabkbd\")) {\n\t\t\tgrab_kbd = 1;\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strcmp(arg, \"-grabptr\")) {\n\t\t\tgrab_ptr = 1;\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strcmp(arg, \"-ungrabboth\")) {\n\t\t\tungrab_both = 1;\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strcmp(arg, \"-grabalways\")) {\n\t\t\tgrab_kbd = 1;\n\t\t\tgrab_ptr = 1;\n\t\t\tgrab_always = 1;\n\t\t\tcontinue;\n\t\t}\n#ifdef ENABLE_GRABLOCAL\n\t\tif (!strcmp(arg, \"-grablocal\")) {\n\t\t\tCHECK_ARGC\n\t\t\tgrab_local = atoi(argv[++i]);\n\t\t\tcontinue;\n\t\t}\n#endif\n\t\tif (!strcmp(arg, \"-viewpasswd\")) {\n\t\t\tvpw_loc = i;\n\t\t\tCHECK_ARGC\n\t\t\tviewonly_passwd = strdup(argv[++i]);\n\t\t\tgot_viewpasswd = 1;\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strcmp(arg, \"-passwdfile\")) {\n\t\t\tCHECK_ARGC\n\t\t\tpasswdfile = strdup(argv[++i]);\n\t\t\tgot_passwdfile = 1;\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strcmp(arg, \"-svc\") || !strcmp(arg, \"-service\")) {\n\t\t\tuse_dpy = strdup(\"WAIT:cmd=FINDCREATEDISPLAY-Xvfb\");\n\t\t\tunixpw = 1;\n\t\t\tusers_list = strdup(\"unixpw=\");\n\t\t\tuse_openssl = 1;\n\t\t\topenssl_pem = strdup(\"SAVE\");\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strcmp(arg, \"-svc_xdummy\")) {\n\t\t\tuse_dpy = strdup(\"WAIT:cmd=FINDCREATEDISPLAY-Xdummy\");\n\t\t\tunixpw = 1;\n\t\t\tusers_list = strdup(\"unixpw=\");\n\t\t\tuse_openssl = 1;\n\t\t\topenssl_pem = strdup(\"SAVE\");\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strcmp(arg, \"-svc_xdummy_xvfb\")) {\n\t\t\tuse_dpy = strdup(\"WAIT:cmd=FINDCREATEDISPLAY-Xdummy,Xvfb\");\n\t\t\tunixpw = 1;\n\t\t\tusers_list = strdup(\"unixpw=\");\n\t\t\tuse_openssl = 1;\n\t\t\topenssl_pem = strdup(\"SAVE\");\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strcmp(arg, \"-svc_xvnc\")) {\n\t\t\tuse_dpy = strdup(\"WAIT:cmd=FINDCREATEDISPLAY-Xvnc\");\n\t\t\tunixpw = 1;\n\t\t\tusers_list = strdup(\"unixpw=\");\n\t\t\tuse_openssl = 1;\n\t\t\topenssl_pem = strdup(\"SAVE\");\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strcmp(arg, \"-xdmsvc\") || !strcmp(arg, \"-xdm_service\")) {\n\t\t\tuse_dpy = strdup(\"WAIT:cmd=FINDCREATEDISPLAY-Xvfb.xdmcp\");\n\t\t\tunixpw = 1;\n\t\t\tusers_list = strdup(\"unixpw=\");\n\t\t\tuse_openssl = 1;\n\t\t\topenssl_pem = strdup(\"SAVE\");\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strcmp(arg, \"-sshxdmsvc\")) {\n\t\t\tuse_dpy = strdup(\"WAIT:cmd=FINDCREATEDISPLAY-Xvfb.xdmcp\");\n\t\t\tallow_list = strdup(\"127.0.0.1\");\n\t\t\tgot_localhost = 1;\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strcmp(arg, \"-unixpw_system_greeter\")) {\n\t\t\tunixpw_system_greeter = 1;\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strcmp(arg, \"-unixpw_cmd\")\n\t\t    || !strcmp(arg, \"-unixpw_cmd_unsafe\")) {\n\t\t\tCHECK_ARGC\n\t\t\tunixpw_cmd = strdup(argv[++i]);\n\t\t\tunixpw = 1;\n\t\t\tif (strstr(arg, \"_unsafe\")) {\n\t\t\t\t/* hidden option for testing. */\n\t\t\t\tset_env(\"UNIXPW_DISABLE_SSL\", \"1\");\n\t\t\t\tset_env(\"UNIXPW_DISABLE_LOCALHOST\", \"1\");\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\t\tif (strstr(arg, \"-unixpw\") == arg) {\n\t\t\tunixpw = 1;\n\t\t\tif (strstr(arg, \"-unixpw_nis\")) {\n\t\t\t\tunixpw_nis = 1;\n\t\t\t}\n\t\t\tif (i < argc-1) {\n\t\t\t\tchar *s = argv[i+1];\n\t\t\t\tif (s[0] != '-') {\n\t\t\t\t\tunixpw_list = strdup(s);\n\t\t\t\t\ti++;\n\t\t\t\t}\n\t\t\t\tif (s[0] == '%') {\n\t\t\t\t\tunixpw_list = NULL;\n\t\t\t\t\tquick_pw(s);\n\t\t\t\t\texit(2);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (strstr(arg, \"_unsafe\")) {\n\t\t\t\t/* hidden option for testing. */\n\t\t\t\tset_env(\"UNIXPW_DISABLE_SSL\", \"1\");\n\t\t\t\tset_env(\"UNIXPW_DISABLE_LOCALHOST\", \"1\");\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\t\tif (strstr(arg, \"-nounixpw\") == arg) {\n\t\t\tunixpw = 0;\n\t\t\tunixpw_nis = 0;\n\t\t\tif (unixpw_list) {\n\t\t\t\tunixpw_list = NULL;\n\t\t\t}\n\t\t\tif (unixpw_cmd) {\n\t\t\t\tunixpw_cmd = NULL;\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strcmp(arg, \"-vencrypt\")) {\n\t\t\tchar *s;\n\t\t\tCHECK_ARGC\n\t\t\ts = strdup(argv[++i]);\n\t\t\tgot_tls++;\n\t\t\tif (strstr(s, \"never\")) {\n\t\t\t\tvencrypt_mode = VENCRYPT_NONE;\n\t\t\t} else if (strstr(s, \"support\")) {\n\t\t\t\tvencrypt_mode = VENCRYPT_SUPPORT;\n\t\t\t} else if (strstr(s, \"only\")) {\n\t\t\t\tvencrypt_mode = VENCRYPT_SOLE;\n\t\t\t} else if (strstr(s, \"force\")) {\n\t\t\t\tvencrypt_mode = VENCRYPT_FORCE;\n\t\t\t} else {\n\t\t\t\tfprintf(stderr, \"invalid %s arg: %s\\n\", arg, s);\n\t\t\t\texit(1);\n\t\t\t}\n\t\t\tif (strstr(s, \"nodh\")) {\n\t\t\t\tvencrypt_kx = VENCRYPT_NODH;\n\t\t\t} else if (strstr(s, \"nox509\")) {\n\t\t\t\tvencrypt_kx = VENCRYPT_NOX509;\n\t\t\t}\n\t\t\tif (strstr(s, \"newdh\")) {\n\t\t\t\tcreate_fresh_dhparams = 1;\n\t\t\t}\n\t\t\tif (strstr(s, \"noplain\")) {\n\t\t\t\tvencrypt_enable_plain_login = 0;\n\t\t\t} else if (strstr(s, \"plain\")) {\n\t\t\t\tvencrypt_enable_plain_login = 1;\n\t\t\t}\n\t\t\tfree(s);\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strcmp(arg, \"-anontls\")) {\n\t\t\tchar *s;\n\t\t\tCHECK_ARGC\n\t\t\ts = strdup(argv[++i]);\n\t\t\tgot_tls++;\n\t\t\tif (strstr(s, \"never\")) {\n\t\t\t\tanontls_mode = ANONTLS_NONE;\n\t\t\t} else if (strstr(s, \"support\")) {\n\t\t\t\tanontls_mode = ANONTLS_SUPPORT;\n\t\t\t} else if (strstr(s, \"only\")) {\n\t\t\t\tanontls_mode = ANONTLS_SOLE;\n\t\t\t} else if (strstr(s, \"force\")) {\n\t\t\t\tanontls_mode = ANONTLS_FORCE;\n\t\t\t} else {\n\t\t\t\tfprintf(stderr, \"invalid %s arg: %s\\n\", arg, s);\n\t\t\t\texit(1);\n\t\t\t}\n\t\t\tif (strstr(s, \"newdh\")) {\n\t\t\t\tcreate_fresh_dhparams = 1;\n\t\t\t}\n\t\t\tfree(s);\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strcmp(arg, \"-sslonly\")) {\n\t\t\tvencrypt_mode = VENCRYPT_NONE;\n\t\t\tanontls_mode = ANONTLS_NONE;\n\t\t\tgot_tls++;\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strcmp(arg, \"-dhparams\")) {\n\t\t\tCHECK_ARGC\n\t\t\tdhparams_file = strdup(argv[++i]);\n\t\t\tgot_tls++;\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strcmp(arg, \"-nossl\")) {\n\t\t\tuse_openssl = 0;\n\t\t\topenssl_pem = NULL;\n\t\t\tgot_tls = -1000;\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strcmp(arg, \"-ssl\")) {\n\t\t\tuse_openssl = 1;\n\t\t\tif (i < argc-1) {\n\t\t\t\tchar *s = argv[i+1];\n\t\t\t\tif (s[0] != '-') {\n\t\t\t\t\tif (!strcmp(s, \"ADH\")) {\n\t\t\t\t\t\topenssl_pem = strdup(\"ANON\");\n\t\t\t\t\t} else if (!strcmp(s, \"ANONDH\")) {\n\t\t\t\t\t\topenssl_pem = strdup(\"ANON\");\n\t\t\t\t\t} else if (!strcmp(s, \"TMP\")) {\n\t\t\t\t\t\topenssl_pem = NULL;\n\t\t\t\t\t} else {\n\t\t\t\t\t\topenssl_pem = strdup(s);\n\t\t\t\t\t}\n\t\t\t\t\ti++;\n\t\t\t\t} else {\n\t\t\t\t\topenssl_pem = strdup(\"SAVE\");\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\topenssl_pem = strdup(\"SAVE\");\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strcmp(arg, \"-enc\")) {\n\t\t\tuse_openssl = 1;\n\t\t\tCHECK_ARGC\n\t\t\tenc_str = strdup(argv[++i]);\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strcmp(arg, \"-http_oneport\")) {\n\t\t\thttp_oneport_msg = 1;\n\t\t\tuse_openssl = 1;\n\t\t\tenc_str = strdup(\"none\");\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strcmp(arg, \"-ssltimeout\")) {\n\t\t\tCHECK_ARGC\n\t\t\tssl_timeout_secs = atoi(argv[++i]);\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strcmp(arg, \"-sslnofail\")) {\n\t\t\tssl_no_fail = 1;\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strcmp(arg, \"-ssldir\")) {\n\t\t\tCHECK_ARGC\n\t\t\tssl_certs_dir = strdup(argv[++i]);\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strcmp(arg, \"-sslverify\")) {\n\t\t\tCHECK_ARGC\n\t\t\tssl_verify = strdup(argv[++i]);\n\t\t\tgot_tls++;\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strcmp(arg, \"-sslCRL\")) {\n\t\t\tCHECK_ARGC\n\t\t\tssl_crl = strdup(argv[++i]);\n\t\t\tgot_tls++;\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strcmp(arg, \"-sslGenCA\")) {\n\t\t\tchar *cdir = NULL;\n\t\t\tif (i < argc-1) {\n\t\t\t\tchar *s = argv[i+1];\n\t\t\t\tif (s[0] != '-') {\n\t\t\t\t\tcdir = strdup(s);\n\t\t\t\t\ti++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tsslGenCA(cdir);\n\t\t\texit(0);\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strcmp(arg, \"-sslGenCert\")) {\n\t\t\tchar *ty, *nm = NULL;\n\t\t\tif (i >= argc-1) {\n\t\t\t\tfprintf(stderr, \"Must be:\\n\");\n\t\t\t\tfprintf(stderr, \"          x11vnc -sslGenCert server ...\\n\");\n\t\t\t\tfprintf(stderr, \"or        x11vnc -sslGenCert client ...\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\t\t\tty = argv[i+1];\n\t\t\tif (strcmp(ty, \"server\") && strcmp(ty, \"client\")) {\n\t\t\t\tfprintf(stderr, \"Must be:\\n\");\n\t\t\t\tfprintf(stderr, \"          x11vnc -sslGenCert server ...\\n\");\n\t\t\t\tfprintf(stderr, \"or        x11vnc -sslGenCert client ...\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\t\t\tif (i < argc-2) {\n\t\t\t\tnm = argv[i+2];\n\t\t\t}\n\t\t\tsslGenCert(ty, nm);\n\t\t\texit(0);\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strcmp(arg, \"-sslEncKey\")) {\n\t\t\tif (i < argc-1) {\n\t\t\t\tchar *s = argv[i+1];\n\t\t\t\tsslEncKey(s, 0);\n\t\t\t}\n\t\t\texit(0);\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strcmp(arg, \"-sslCertInfo\")) {\n\t\t\tif (i < argc-1) {\n\t\t\t\tchar *s = argv[i+1];\n\t\t\t\tsslEncKey(s, 1);\n\t\t\t}\n\t\t\texit(0);\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strcmp(arg, \"-sslDelCert\")) {\n\t\t\tif (i < argc-1) {\n\t\t\t\tchar *s = argv[i+1];\n\t\t\t\tsslEncKey(s, 2);\n\t\t\t}\n\t\t\texit(0);\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strcmp(arg, \"-sslScripts\")) {\n\t\t\tsslScripts();\n\t\t\texit(0);\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strcmp(arg, \"-stunnel\")) {\n\t\t\tuse_stunnel = 1;\n\t\t\tgot_tls = -1000;\n\t\t\tif (i < argc-1) {\n\t\t\t\tchar *s = argv[i+1];\n\t\t\t\tif (s[0] != '-') {\n\t\t\t\t\tif (!strcmp(s, \"TMP\")) {\n\t\t\t\t\t\tstunnel_pem = NULL;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tstunnel_pem = strdup(s);\n\t\t\t\t\t}\n\t\t\t\t\ti++;\n\t\t\t\t} else {\n\t\t\t\t\tstunnel_pem = strdup(\"SAVE\");\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tstunnel_pem = strdup(\"SAVE\");\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strcmp(arg, \"-stunnel3\")) {\n\t\t\tuse_stunnel = 3;\n\t\t\tgot_tls = -1000;\n\t\t\tif (i < argc-1) {\n\t\t\t\tchar *s = argv[i+1];\n\t\t\t\tif (s[0] != '-') {\n\t\t\t\t\tif (!strcmp(s, \"TMP\")) {\n\t\t\t\t\t\tstunnel_pem = NULL;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tstunnel_pem = strdup(s);\n\t\t\t\t\t}\n\t\t\t\t\ti++;\n\t\t\t\t} else {\n\t\t\t\t\tstunnel_pem = strdup(\"SAVE\");\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tstunnel_pem = strdup(\"SAVE\");\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strcmp(arg, \"-https\")) {\n\t\t\thttps_port_num = 0;\n\t\t\ttry_http = 1;\n\t\t\tgot_tls++;\n\t\t\tif (i < argc-1) {\n\t\t\t\tchar *s = argv[i+1];\n\t\t\t\tif (s[0] != '-') {\n\t\t\t\t\thttps_port_num = atoi(s);\n\t\t\t\t\ti++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strcmp(arg, \"-httpsredir\")) {\n\t\t\thttps_port_redir = -1;\n\t\t\tgot_tls++;\n\t\t\tif (i < argc-1) {\n\t\t\t\tchar *s = argv[i+1];\n\t\t\t\tif (s[0] != '-') {\n\t\t\t\t\thttps_port_redir = atoi(s);\n\t\t\t\t\ti++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strcmp(arg, \"-nopw\")) {\n\t\t\tnopw = 1;\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strcmp(arg, \"-ssh\")) {\n\t\t\tCHECK_ARGC\n\t\t\tssh_str = strdup(argv[++i]);\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strcmp(arg, \"-usepw\")) {\n\t\t\tusepw = 1;\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strcmp(arg, \"-storepasswd\")) {\n\t\t\tif (argc == i+1) {\n\t\t\t\tstore_homedir_passwd(NULL);\n\t\t\t\texit(0);\n\t\t\t}\n\t\t\tif (argc == i+2) {\n\t\t\t\tstore_homedir_passwd(argv[i+1]);\n\t\t\t\texit(0);\n\t\t\t}\n\t\t\tif (argc >= i+4 || rfbEncryptAndStorePasswd(argv[i+1],\n\t\t\t    argv[i+2]) != 0) {\n\t\t\t\tperror(\"storepasswd\");\n\t\t\t\tfprintf(stderr, \"-storepasswd failed for file: %s\\n\",\n\t\t\t\t    argv[i+2]);\n\t\t\t\texit(1);\n\t\t\t} else {\n\t\t\t\tfprintf(stderr, \"stored passwd in file: %s\\n\",\n\t\t\t\t    argv[i+2]);\n\t\t\t\texit(0);\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strcmp(arg, \"-showrfbauth\")) {\n\t\t\tif (argc >= i+2) {\n\t\t\t\tchar *f = argv[i+1];\n\t\t\t\tchar *s = rfbDecryptPasswdFromFile(f);\n\t\t\t\tif (!s) {\n\t\t\t\t\tperror(\"showrfbauth\");\n\t\t\t\t\tfprintf(stderr, \"rfbDecryptPasswdFromFile failed: %s\\n\", f);\n\t\t\t\t\texit(1);\n\t\t\t\t}\n\t\t\t\tfprintf(stdout, \"rfbDecryptPasswdFromFile file: %s\\n\", f);\n\t\t\t\tfprintf(stdout, \"rfbDecryptPasswdFromFile pass: %s\\n\", s);\n\t\t\t}\n\t\t\texit(0);\n\t\t}\n\t\tif (!strcmp(arg, \"-accept\")) {\n\t\t\tCHECK_ARGC\n\t\t\taccept_cmd = strdup(argv[++i]);\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strcmp(arg, \"-afteraccept\")) {\n\t\t\tCHECK_ARGC\n\t\t\tafteraccept_cmd = strdup(argv[++i]);\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strcmp(arg, \"-gone\")) {\n\t\t\tCHECK_ARGC\n\t\t\tgone_cmd = strdup(argv[++i]);\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strcmp(arg, \"-noshm\")) {\n\t\t\tusing_shm = 0;\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strcmp(arg, \"-flipbyteorder\")) {\n\t\t\tflip_byte_order = 1;\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strcmp(arg, \"-onetile\")) {\n\t\t\tsingle_copytile = 1;\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strcmp(arg, \"-solid\")) {\n\t\t\tuse_solid_bg = 1;\n\t\t\tif (i < argc-1) {\n\t\t\t\tchar *s = argv[i+1];\n\t\t\t\tif (s[0] != '-') {\n\t\t\t\t\tsolid_str = strdup(s);\n\t\t\t\t\ti++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (! solid_str) {\n\t\t\t\tsolid_str = strdup(solid_default);\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strcmp(arg, \"-blackout\")) {\n\t\t\tCHECK_ARGC\n\t\t\tblackout_str = strdup(argv[++i]);\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strcmp(arg, \"-xinerama\")) {\n\t\t\txinerama = 1;\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strcmp(arg, \"-noxinerama\")) {\n\t\t\txinerama = 0;\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strcmp(arg, \"-xtrap\")) {\n\t\t\txtrap_input = 1;\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strcmp(arg, \"-xrandr\")) {\n\t\t\txrandr = 1;\n\t\t\tif (i < argc-1) {\n\t\t\t\tchar *s = argv[i+1];\n\t\t\t\tif (known_xrandr_mode(s)) {\n\t\t\t\t\txrandr_mode = strdup(s);\n\t\t\t\t\ti++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strcmp(arg, \"-noxrandr\")) {\n\t\t\txrandr = 0;\n\t\t\txrandr_maybe = 0;\n\t\t\tgot_noxrandr = 1;\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strcmp(arg, \"-rotate\")) {\n\t\t\tCHECK_ARGC\n\t\t\trotating_str = strdup(argv[++i]);\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strcmp(arg, \"-padgeom\")\n\t\t    || !strcmp(arg, \"-padgeometry\")) {\n\t\t\tCHECK_ARGC\n\t\t\tpad_geometry = strdup(argv[++i]);\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strcmp(arg, \"-o\") || !strcmp(arg, \"-logfile\")) {\n\t\t\tCHECK_ARGC\n\t\t\tlogfile_append = 0;\n\t\t\tlogfile = strdup(argv[++i]);\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strcmp(arg, \"-oa\") || !strcmp(arg, \"-logappend\")) {\n\t\t\tCHECK_ARGC\n\t\t\tlogfile_append = 1;\n\t\t\tlogfile = strdup(argv[++i]);\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strcmp(arg, \"-flag\")) {\n\t\t\tCHECK_ARGC\n\t\t\tflagfile = strdup(argv[++i]);\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strcmp(arg, \"-rmflag\")) {\n\t\t\tCHECK_ARGC\n\t\t\trm_flagfile = strdup(argv[++i]);\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strcmp(arg, \"-rc\")) {\n\t\t\ti++;\t/* done above */\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strcmp(arg, \"-norc\")) {\n\t\t\t;\t/* done above */\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strcmp(arg, \"-env\")) {\n\t\t\ti++;\t/* done above */\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strcmp(arg, \"-prog\")) {\n\t\t\tCHECK_ARGC\n\t\t\tif (program_name) {\n\t\t\t\tfree(program_name);\n\t\t\t}\n\t\t\tprogram_name = strdup(argv[++i]);\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strcmp(arg, \"-h\") || !strcmp(arg, \"-help\")) {\n\t\t\tprint_help(0);\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strcmp(arg, \"-?\") || !strcmp(arg, \"-opts\")) {\n\t\t\tprint_help(1);\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strcmp(arg, \"-V\") || !strcmp(arg, \"-version\")) {\n\t\t\tfprintf(stdout, \"x11vnc: %s\\n\", lastmod);\n\t\t\texit(0);\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strcmp(arg, \"-license\") ||\n\t\t    !strcmp(arg, \"-copying\") || !strcmp(arg, \"-warranty\")) {\n\t\t\tprint_license();\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strcmp(arg, \"-dbg\")) {\n\t\t\tcrash_debug = 1;\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strcmp(arg, \"-nodbg\")) {\n\t\t\tcrash_debug = 0;\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strcmp(arg, \"-q\") || !strcmp(arg, \"-quiet\")) {\n\t\t\tquiet = 1;\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strcmp(arg, \"-noquiet\")) {\n\t\t\tquiet = 0;\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strcmp(arg, \"-v\") || !strcmp(arg, \"-verbose\")) {\n\t\t\tverbose = 1;\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strcmp(arg, \"-bg\") || !strcmp(arg, \"-background\")) {\n#if HAVE_SETSID\n\t\t\tbg = 1;\n\t\t\topts_bg = bg;\n#else\n\t\t\tif (!got_inetd) {\n\t\t\t\tfprintf(stderr, \"warning: -bg mode not supported.\\n\");\n\t\t\t}\n#endif\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strcmp(arg, \"-modtweak\")) {\n\t\t\tuse_modifier_tweak = 1;\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strcmp(arg, \"-nomodtweak\")) {\n\t\t\tuse_modifier_tweak = 0;\n\t\t\tgot_nomodtweak = 1;\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strcmp(arg, \"-isolevel3\")) {\n\t\t\tuse_iso_level3 = 1;\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strcmp(arg, \"-xkb\")) {\n\t\t\tuse_modifier_tweak = 1;\n\t\t\tuse_xkb_modtweak = 1;\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strcmp(arg, \"-noxkb\")) {\n\t\t\tuse_xkb_modtweak = 0;\n\t\t\tgot_noxkb = 1;\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strcmp(arg, \"-capslock\")) {\n\t\t\twatch_capslock = 1;\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strcmp(arg, \"-skip_lockkeys\")) {\n\t\t\tskip_lockkeys = 1;\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strcmp(arg, \"-noskip_lockkeys\")) {\n\t\t\tskip_lockkeys = 0;\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strcmp(arg, \"-xkbcompat\")) {\n\t\t\txkbcompat = 1;\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strcmp(arg, \"-skip_keycodes\")) {\n\t\t\tCHECK_ARGC\n\t\t\tskip_keycodes = strdup(argv[++i]);\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strcmp(arg, \"-sloppy_keys\")) {\n\t\t\tsloppy_keys++;\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strcmp(arg, \"-skip_dups\")) {\n\t\t\tskip_duplicate_key_events = 1;\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strcmp(arg, \"-noskip_dups\")) {\n\t\t\tskip_duplicate_key_events = 0;\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strcmp(arg, \"-add_keysyms\")) {\n\t\t\tadd_keysyms++;\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strcmp(arg, \"-noadd_keysyms\")) {\n\t\t\tadd_keysyms = 0;\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strcmp(arg, \"-clear_mods\")) {\n\t\t\tclear_mods = 1;\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strcmp(arg, \"-clear_keys\")) {\n\t\t\tclear_mods = 2;\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strcmp(arg, \"-clear_all\")) {\n\t\t\tclear_mods = 3;\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strcmp(arg, \"-remap\")) {\n\t\t\tCHECK_ARGC\n\t\t\tremap_file = strdup(argv[++i]);\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strcmp(arg, \"-norepeat\")) {\n\t\t\tno_autorepeat = 1;\n\t\t\tif (i < argc-1) {\n\t\t\t\tchar *s = argv[i+1];\n\t\t\t\tif (*s == '-') {\n\t\t\t\t\ts++;\n\t\t\t\t}\n\t\t\t\tif (isdigit((unsigned char) (*s))) {\n\t\t\t\t\tno_repeat_countdown = atoi(argv[++i]);\n\t\t\t\t}\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strcmp(arg, \"-repeat\")) {\n\t\t\tno_autorepeat = 0;\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strcmp(arg, \"-nofb\")) {\n\t\t\tnofb = 1;\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strcmp(arg, \"-nobell\")) {\n\t\t\twatch_bell = 0;\n\t\t\tsound_bell = 0;\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strcmp(arg, \"-nosel\")) {\n\t\t\twatch_selection = 0;\n\t\t\twatch_primary = 0;\n\t\t\twatch_clipboard = 0;\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strcmp(arg, \"-noprimary\")) {\n\t\t\twatch_primary = 0;\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strcmp(arg, \"-nosetprimary\")) {\n\t\t\tset_primary = 0;\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strcmp(arg, \"-noclipboard\")) {\n\t\t\twatch_clipboard = 0;\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strcmp(arg, \"-nosetclipboard\")) {\n\t\t\tset_clipboard = 0;\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strcmp(arg, \"-seldir\")) {\n\t\t\tCHECK_ARGC\n\t\t\tsel_direction = strdup(argv[++i]);\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strcmp(arg, \"-cursor\")) {\n\t\t\tshow_cursor = 1;\n\t\t\tif (i < argc-1) {\n\t\t\t\tchar *s = argv[i+1];\n\t\t\t\tif (known_cursors_mode(s)) {\n\t\t\t\t\tmultiple_cursors_mode = strdup(s);\n\t\t\t\t\ti++;\n\t\t\t\t\tif (!strcmp(s, \"none\")) {\n\t\t\t\t\t\tshow_cursor = 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strcmp(arg, \"-nocursor\")) { \n\t\t\tmultiple_cursors_mode = strdup(\"none\");\n\t\t\tshow_cursor = 0;\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strcmp(arg, \"-cursor_drag\")) { \n\t\t\tcursor_drag_changes = 1;\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strcmp(arg, \"-nocursor_drag\")) { \n\t\t\tcursor_drag_changes = 0;\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strcmp(arg, \"-arrow\")) {\n\t\t\tCHECK_ARGC\n\t\t\talt_arrow = atoi(argv[++i]);\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strcmp(arg, \"-xfixes\")) { \n\t\t\tuse_xfixes = 1;\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strcmp(arg, \"-noxfixes\")) { \n\t\t\tuse_xfixes = 0;\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strcmp(arg, \"-alphacut\")) {\n\t\t\tCHECK_ARGC\n\t\t\talpha_threshold = atoi(argv[++i]);\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strcmp(arg, \"-alphafrac\")) {\n\t\t\tCHECK_ARGC\n\t\t\talpha_frac = atof(argv[++i]);\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strcmp(arg, \"-alpharemove\")) {\n\t\t\talpha_remove = 1;\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strcmp(arg, \"-noalphablend\")) {\n\t\t\talpha_blend = 0;\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strcmp(arg, \"-nocursorshape\")) {\n\t\t\tcursor_shape_updates = 0;\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strcmp(arg, \"-cursorpos\")) {\n\t\t\tcursor_pos_updates = 1;\n\t\t\tgot_cursorpos = 1;\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strcmp(arg, \"-nocursorpos\")) {\n\t\t\tcursor_pos_updates = 0;\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strcmp(arg, \"-xwarppointer\")) {\n\t\t\tuse_xwarppointer = 1;\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strcmp(arg, \"-noxwarppointer\")) {\n\t\t\tuse_xwarppointer = 0;\n\t\t\tgot_noxwarppointer = 1;\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strcmp(arg, \"-always_inject\")) {\n\t\t\talways_inject = 1;\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strcmp(arg, \"-buttonmap\")) {\n\t\t\tCHECK_ARGC\n\t\t\tpointer_remap = strdup(argv[++i]);\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strcmp(arg, \"-nodragging\")) {\n\t\t\tshow_dragging = 0;\n\t\t\tcontinue;\n\t\t}\n#ifndef NO_NCACHE\n\t\tif (!strcmp(arg, \"-ncache\") || !strcmp(arg, \"-nc\")) {\n\t\t\tif (i < argc-1) {\n\t\t\t\tchar *s = argv[i+1];\n\t\t\t\tif (s[0] != '-') {\n\t\t\t\t\tncache = atoi(s);\n\t\t\t\t\ti++;\n\t\t\t\t} else {\n\t\t\t\t\tncache = ncache_default;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tncache = ncache_default;\n\t\t\t}\n\t\t\tif (ncache % 2 != 0) {\n\t\t\t\tncache++;\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strcmp(arg, \"-noncache\") || !strcmp(arg, \"-nonc\")) {\n\t\t\tncache = 0;\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strcmp(arg, \"-ncache_cr\") || !strcmp(arg, \"-nc_cr\")) {\n\t\t\tncache_copyrect = 1;\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strcmp(arg, \"-ncache_no_moveraise\") || !strcmp(arg, \"-nc_no_moveraise\")) {\n\t\t\tncache_wf_raises = 1;\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strcmp(arg, \"-ncache_no_dtchange\") || !strcmp(arg, \"-nc_no_dtchange\")) {\n\t\t\tncache_dt_change = 0;\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strcmp(arg, \"-ncache_no_rootpixmap\") || !strcmp(arg, \"-nc_no_rootpixmap\")) {\n\t\t\tncache_xrootpmap = 0;\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strcmp(arg, \"-ncache_keep_anims\") || !strcmp(arg, \"-nc_keep_anims\")) {\n\t\t\tncache_keep_anims = 1;\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strcmp(arg, \"-ncache_old_wm\") || !strcmp(arg, \"-nc_old_wm\")) {\n\t\t\tncache_old_wm = 1;\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strcmp(arg, \"-ncache_pad\") || !strcmp(arg, \"-nc_pad\")) {\n\t\t\tCHECK_ARGC\n\t\t\tncache_pad = atoi(argv[++i]);\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strcmp(arg, \"-debug_ncache\")) {\n\t\t\tncdb++;\n\t\t\tcontinue;\n\t\t}\n#endif\n\t\tif (!strcmp(arg, \"-wireframe\")\n\t\t    || !strcmp(arg, \"-wf\")) {\n\t\t\twireframe = 1;\n\t\t\tif (i < argc-1) {\n\t\t\t\tchar *s = argv[i+1];\n\t\t\t\tif (*s != '-') {\n\t\t\t\t\twireframe_str = strdup(argv[++i]);\n\t\t\t\t}\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strcmp(arg, \"-nowireframe\")\n\t\t    || !strcmp(arg, \"-nowf\")) {\n\t\t\twireframe = 0;\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strcmp(arg, \"-nowireframelocal\")\n\t\t    || !strcmp(arg, \"-nowfl\")) {\n\t\t\twireframe_local = 0;\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strcmp(arg, \"-wirecopyrect\")\n\t\t    || !strcmp(arg, \"-wcr\")) {\n\t\t\tCHECK_ARGC\n\t\t\tset_wirecopyrect_mode(argv[++i]);\n\t\t\tgot_wirecopyrect = 1;\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strcmp(arg, \"-nowirecopyrect\")\n\t\t    || !strcmp(arg, \"-nowcr\")) {\n\t\t\tset_wirecopyrect_mode(\"never\");\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strcmp(arg, \"-debug_wireframe\")\n\t\t    || !strcmp(arg, \"-dwf\")) {\n\t\t\tdebug_wireframe++;\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strcmp(arg, \"-scrollcopyrect\")\n\t\t    || !strcmp(arg, \"-scr\")) {\n\t\t\tCHECK_ARGC\n\t\t\tset_scrollcopyrect_mode(argv[++i]);\n\t\t\tgot_scrollcopyrect = 1;\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strcmp(arg, \"-noscrollcopyrect\")\n\t\t    || !strcmp(arg, \"-noscr\")) {\n\t\t\tset_scrollcopyrect_mode(\"never\");\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strcmp(arg, \"-scr_area\")) {\n\t\t\tint tn;\n\t\t\tCHECK_ARGC\n\t\t\ttn = atoi(argv[++i]);\n\t\t\tif (tn >= 0) {\n\t\t\t\tscrollcopyrect_min_area = tn;\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strcmp(arg, \"-scr_skip\")) {\n\t\t\tCHECK_ARGC\n\t\t\tscroll_skip_str = strdup(argv[++i]);\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strcmp(arg, \"-scr_inc\")) {\n\t\t\tCHECK_ARGC\n\t\t\tscroll_good_str = strdup(argv[++i]);\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strcmp(arg, \"-scr_keys\")) {\n\t\t\tCHECK_ARGC\n\t\t\tscroll_key_list_str = strdup(argv[++i]);\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strcmp(arg, \"-scr_term\")) {\n\t\t\tCHECK_ARGC\n\t\t\tscroll_term_str = strdup(argv[++i]);\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strcmp(arg, \"-scr_keyrepeat\")) {\n\t\t\tCHECK_ARGC\n\t\t\tmax_keyrepeat_str = strdup(argv[++i]);\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strcmp(arg, \"-scr_parms\")) {\n\t\t\tCHECK_ARGC\n\t\t\tscroll_copyrect_str = strdup(argv[++i]);\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strcmp(arg, \"-fixscreen\")) {\n\t\t\tCHECK_ARGC\n\t\t\tscreen_fixup_str = strdup(argv[++i]);\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strcmp(arg, \"-debug_scroll\")\n\t\t    || !strcmp(arg, \"-ds\")) {\n\t\t\tdebug_scroll++;\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strcmp(arg, \"-noxrecord\")) {\n\t\t\tnoxrecord = 1;\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strcmp(arg, \"-pointer_mode\")\n\t\t    || !strcmp(arg, \"-pm\")) {\n\t\t\tchar *p, *s;\n\t\t\tCHECK_ARGC\n\t\t\ts = argv[++i];\n\t\t\tif ((p = strchr(s, ':')) != NULL) {\n\t\t\t\tui_skip = atoi(p+1);\n\t\t\t\tif (! ui_skip) ui_skip = 1;\n\t\t\t\t*p = '\\0';\n\t\t\t}\n\t\t\tif (atoi(s) < 1 || atoi(s) > pointer_mode_max) {\n\t\t\t\tif (!got_inetd) {\n\t\t\t\t\trfbLog(\"pointer_mode out of range 1-%d: %d\\n\",\n\t\t\t\t\t    pointer_mode_max, atoi(s));\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tpointer_mode = atoi(s);\n\t\t\t\tgot_pointer_mode = pointer_mode;\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strcmp(arg, \"-input_skip\")) {\n\t\t\tCHECK_ARGC\n\t\t\tui_skip = atoi(argv[++i]);\n\t\t\tif (! ui_skip) ui_skip = 1;\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strcmp(arg, \"-allinput\")) {\n\t\t\tall_input = 1;\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strcmp(arg, \"-noallinput\")) {\n\t\t\tall_input = 0;\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strcmp(arg, \"-input_eagerly\")) {\n\t\t\thandle_events_eagerly = 1;\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strcmp(arg, \"-noinput_eagerly\")) {\n\t\t\thandle_events_eagerly = 0;\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strcmp(arg, \"-speeds\")) {\n\t\t\tCHECK_ARGC\n\t\t\tspeeds_str = strdup(argv[++i]);\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strcmp(arg, \"-wmdt\")) {\n\t\t\tCHECK_ARGC\n\t\t\twmdt_str = strdup(argv[++i]);\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strcmp(arg, \"-debug_pointer\")\n\t\t    || !strcmp(arg, \"-dp\")) {\n\t\t\tdebug_pointer++;\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strcmp(arg, \"-debug_keyboard\")\n\t\t    || !strcmp(arg, \"-dk\")) {\n\t\t\tdebug_keyboard++;\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strcmp(arg, \"-debug_xdamage\")) {\n\t\t\tdebug_xdamage++;\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strcmp(arg, \"-defer\")) {\n\t\t\tCHECK_ARGC\n\t\t\tdefer_update = atoi(argv[++i]);\n\t\t\tgot_defer = 1;\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strcmp(arg, \"-setdefer\")) {\n\t\t\tCHECK_ARGC\n\t\t\tset_defer = atoi(argv[++i]);\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strcmp(arg, \"-wait\")) {\n\t\t\tCHECK_ARGC\n\t\t\twaitms = atoi(argv[++i]);\n\t\t\tgot_waitms = 1;\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strcmp(arg, \"-extra_fbur\")) {\n\t\t\tCHECK_ARGC\n\t\t\textra_fbur = atoi(argv[++i]);\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strcmp(arg, \"-wait_ui\")) {\n\t\t\tCHECK_ARGC\n\t\t\twait_ui = atof(argv[++i]);\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strcmp(arg, \"-nowait_bog\")) {\n\t\t\twait_bog = 0;\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strcmp(arg, \"-slow_fb\")) {\n\t\t\tCHECK_ARGC\n\t\t\tslow_fb = atof(argv[++i]);\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strcmp(arg, \"-xrefresh\")) {\n\t\t\tCHECK_ARGC\n\t\t\txrefresh = atof(argv[++i]);\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strcmp(arg, \"-readtimeout\")) {\n\t\t\tCHECK_ARGC\n\t\t\trfbMaxClientWait = atoi(argv[++i]) * 1000;\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strcmp(arg, \"-ping\")) {\n\t\t\tCHECK_ARGC\n\t\t\tping_interval = atoi(argv[++i]);\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strcmp(arg, \"-nap\")) {\n\t\t\ttake_naps = 1;\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strcmp(arg, \"-nonap\")) {\n\t\t\ttake_naps = 0;\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strcmp(arg, \"-sb\")) {\n\t\t\tCHECK_ARGC\n\t\t\tscreen_blank = atoi(argv[++i]);\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strcmp(arg, \"-nofbpm\")) {\n\t\t\twatch_fbpm = 1;\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strcmp(arg, \"-fbpm\")) {\n\t\t\twatch_fbpm = 0;\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strcmp(arg, \"-nodpms\")) {\n\t\t\twatch_dpms = 1;\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strcmp(arg, \"-dpms\")) {\n\t\t\twatch_dpms = 0;\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strcmp(arg, \"-forcedpms\")) {\n\t\t\tforce_dpms = 1;\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strcmp(arg, \"-clientdpms\")) {\n\t\t\tclient_dpms = 1;\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strcmp(arg, \"-noserverdpms\")) {\n\t\t\tno_ultra_dpms = 1;\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strcmp(arg, \"-noultraext\")) {\n\t\t\tno_ultra_ext = 1;\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strcmp(arg, \"-chatwindow\")) {\n\t\t\tchat_window = 1;\n\t\t\tif (argc_vnc + 1 < argc_vnc_max) {\n\t\t\t\tif (!got_inetd) {\n\t\t\t\t\trfbLog(\"setting '-rfbversion 3.6' for -chatwindow.\\n\");\n\t\t\t\t}\n\t\t\t\targv_vnc[argc_vnc++] = strdup(\"-rfbversion\");\n\t\t\t\targv_vnc[argc_vnc++] = strdup(\"3.6\");\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strcmp(arg, \"-xdamage\")) {\n\t\t\tuse_xdamage++;\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strcmp(arg, \"-noxdamage\")) {\n\t\t\tuse_xdamage = 0;\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strcmp(arg, \"-xd_area\")) {\n\t\t\tint tn;\n\t\t\tCHECK_ARGC\n\t\t\ttn = atoi(argv[++i]);\n\t\t\tif (tn >= 0) {\n\t\t\t\txdamage_max_area = tn;\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strcmp(arg, \"-xd_mem\")) {\n\t\t\tdouble f;\n\t\t\tCHECK_ARGC\n\t\t\tf = atof(argv[++i]);\n\t\t\tif (f >= 0.0) {\n\t\t\t\txdamage_memory = f;\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strcmp(arg, \"-xcomposite\")) {\n\t\t\tuse_xcomposite++;\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strcmp(arg, \"-noxcomposite\")) {\n\t\t\tuse_xcomposite = 0;\n\t\t\tcontinue;\n\t\t}\n#ifdef HAVE_XI2\n                if (!strcmp(arg, \"-multiptr\")) {\n                        use_multipointer++;\n \t\t\tcontinue;\n \t\t}\n#endif\n\n\t\tif (!strcmp(arg, \"-sigpipe\") || !strcmp(arg, \"-sig\")) {\n\t\t\tCHECK_ARGC\n\t\t\tif (known_sigpipe_mode(argv[++i])) {\n\t\t\t\tsigpipe = strdup(argv[i]);\n\t\t\t} else {\n\t\t\t\tfprintf(stderr, \"invalid -sigpipe arg: %s, must\"\n\t\t\t\t    \" be \\\"ignore\\\" or \\\"exit\\\"\\n\", argv[i]);\n\t\t\t\texit(1);\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n#if LIBVNCSERVER_HAVE_LIBPTHREAD\n\t\tif (!strcmp(arg, \"-threads\")) {\n#if defined(X11VNC_THREADED)\n\t\t\tuse_threads = 1;\n#else\n\t\t\tif (getenv(\"X11VNC_THREADED\")) {\n\t\t\t\tuse_threads = 1;\n\t\t\t} else if (1) {\n\t\t\t\t/* we re-enable it due to threaded mode bugfixes. */\n\t\t\t\tuse_threads = 1;\n\t\t\t} else {\n\t\t\t\tif (!got_inetd) {\n\t\t\t\t\trfbLog(\"\\n\");\n\t\t\t\t\trfbLog(\"The -threads mode is unstable and not tested or maintained.\\n\");\n\t\t\t\t\trfbLog(\"It is disabled in the source code.  If you really need\\n\");\n\t\t\t\t\trfbLog(\"the feature you can reenable it at build time by setting\\n\");\n\t\t\t\t\trfbLog(\"-DX11VNC_THREADED in CPPFLAGS. Or set X11VNC_THREADED=1\\n\");\n\t\t\t\t\trfbLog(\"in your runtime environment.\\n\");\n\t\t\t\t\trfbLog(\"\\n\");\n\t\t\t\t\tusleep(500*1000);\n\t\t\t\t}\n\t\t\t}\n#endif\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strcmp(arg, \"-nothreads\")) {\n\t\t\tuse_threads = 0;\n\t\t\tcontinue;\n\t\t}\n#endif\n\t\tif (!strcmp(arg, \"-fs\")) {\n\t\t\tCHECK_ARGC\n\t\t\tfs_frac = atof(argv[++i]);\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strcmp(arg, \"-gaps\")) {\n\t\t\tCHECK_ARGC\n\t\t\tgaps_fill = atoi(argv[++i]);\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strcmp(arg, \"-grow\")) {\n\t\t\tCHECK_ARGC\n\t\t\tgrow_fill = atoi(argv[++i]);\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strcmp(arg, \"-fuzz\")) {\n\t\t\tCHECK_ARGC\n\t\t\ttile_fuzz = atoi(argv[++i]);\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strcmp(arg, \"-debug_tiles\")\n\t\t    || !strcmp(arg, \"-dbt\")) {\n\t\t\tdebug_tiles++;\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strcmp(arg, \"-debug_grabs\")) {\n\t\t\tdebug_grabs++;\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strcmp(arg, \"-debug_sel\")) {\n\t\t\tdebug_sel++;\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strcmp(arg, \"-grab_buster\")) {\n\t\t\tgrab_buster++;\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strcmp(arg, \"-nograb_buster\")) {\n\t\t\tgrab_buster = 0;\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strcmp(arg, \"-snapfb\")) {\n\t\t\tuse_snapfb = 1;\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strcmp(arg, \"-rand\")) {\n\t\t\t/* equiv. to -nopw -rawfb rand for quick tests */\n\t\t\traw_fb_str = strdup(\"rand\");\n\t\t\tnopw = 1;\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strcmp(arg, \"-rawfb\")) {\n\t\t\tCHECK_ARGC\n\t\t\traw_fb_str = strdup(argv[++i]);\n\t\t\tif (strstr(raw_fb_str, \"vnc:\") == raw_fb_str) {\n\t\t\t\tshared = 1;\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strcmp(arg, \"-freqtab\")) {\n\t\t\tCHECK_ARGC\n\t\t\tfreqtab = strdup(argv[++i]);\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strcmp(arg, \"-pipeinput\")) {\n\t\t\tCHECK_ARGC\n\t\t\tpipeinput_str = strdup(argv[++i]);\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strcmp(arg, \"-macnodim\")) {\n\t\t\tmacosx_nodimming = 1;\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strcmp(arg, \"-macnosleep\")) {\n\t\t\tmacosx_nosleep = 1;\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strcmp(arg, \"-macnosaver\")) {\n\t\t\tmacosx_noscreensaver = 1;\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strcmp(arg, \"-macnowait\")) {\n\t\t\tmacosx_wait_for_switch = 0;\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strcmp(arg, \"-macwheel\")) {\n\t\t\tCHECK_ARGC\n\t\t\tmacosx_mouse_wheel_speed = atoi(argv[++i]);\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strcmp(arg, \"-macnoswap\")) {\n\t\t\tmacosx_swap23 = 0;\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strcmp(arg, \"-macnoresize\")) {\n\t\t\tmacosx_resize = 0;\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strcmp(arg, \"-maciconanim\")) {\n\t\t\tCHECK_ARGC\n\t\t\tmacosx_icon_anim_time = atoi(argv[++i]);\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strcmp(arg, \"-macmenu\")) {\n\t\t\tmacosx_ncache_macmenu = 1;\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strcmp(arg, \"-macuskbd\")) {\n\t\t\tmacosx_us_kbd = 1;\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strcmp(arg, \"-macnoopengl\")) {\n\t\t\tmacosx_no_opengl = 1;\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strcmp(arg, \"-macnorawfb\")) {\n\t\t\tmacosx_no_rawfb = 1;\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strcmp(arg, \"-gui\")) {\n\t\t\tlaunch_gui = 1;\n\t\t\tif (i < argc-1) {\n\t\t\t\tchar *s = argv[i+1];\n\t\t\t\tif (*s != '-') {\n\t\t\t\t\tgui_str = strdup(s);\n\t\t\t\t\tif (strstr(gui_str, \"setp\")) {\n\t\t\t\t\t\tgot_gui_pw = 1;\n\t\t\t\t\t}\n\t\t\t\t\ti++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strcmp(arg, \"-remote\") || !strcmp(arg, \"-R\")\n\t\t    || !strcmp(arg, \"-r\") || !strcmp(arg, \"-remote-control\")) {\n\t\t\tchar *str;\n\t\t\tCHECK_ARGC\n\t\t\ti++;\n\t\t\tstr = argv[i];\n\t\t\tif (*str == '-') {\n\t\t\t\t/* accidental leading '-' */\n\t\t\t\tstr++;\n\t\t\t}\n\t\t\tif (!strcmp(str, \"ping\")) {\n\t\t\t\tquery_cmd = strdup(str);\n\t\t\t} else {\n\t\t\t\tremote_cmd = strdup(str);\n\t\t\t}\n\t\t\tif (remote_cmd && strchr(remote_cmd, ':') == NULL) {\n\t\t\t    /* interpret -R -scale 3/4 at least */\n\t\t \t    if (i < argc-1 && *(argv[i+1]) != '-') {\n\t\t\t\tint n;\n\n\t\t\t\t/* it must be the parameter value */\n\t\t\t\ti++;\n\t\t\t\tn = strlen(remote_cmd) + strlen(argv[i]) + 2;\n\n\t\t\t\tstr = (char *) malloc(n);\n\t\t\t\tsprintf(str, \"%s:%s\", remote_cmd, argv[i]);\n\t\t\t\tfree(remote_cmd);\n\t\t\t\tremote_cmd = str;\n\t\t\t    }\n\t\t\t}\n\t\t\tif (!getenv(\"QUERY_VERBOSE\")) {\n\t\t\t\tquiet = 1;\n\t\t\t}\n\t\t\txkbcompat = 0;\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strcmp(arg, \"-query\") || !strcmp(arg, \"-Q\")) {\n\t\t\tCHECK_ARGC\n\t\t\tquery_cmd = strdup(argv[++i]);\n\t\t\tif (!getenv(\"QUERY_VERBOSE\")) {\n\t\t\t\tquiet = 1;\n\t\t\t}\n\t\t\txkbcompat = 0;\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strcmp(arg, \"-query_retries\")) {\n\t\t\tchar *s;\n\t\t\tCHECK_ARGC\n\t\t\ts = strdup(argv[++i]);\n\t\t\t/* n[:t][/match] */\n\t\t\tif (strchr(s, '/')) {\n\t\t\t\tchar *q = strchr(s, '/');\n\t\t\t\tquery_match = strdup(q+1);\n\t\t\t\t*q = '\\0';\n\t\t\t}\n\t\t\tif (strchr(s, ':')) {\n\t\t\t\tchar *q = strchr(s, ':');\n\t\t\t\tquery_delay = atof(q+1);\n\t\t\t}\n\t\t\tquery_retries = atoi(s);\n\t\t\tfree(s);\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strcmp(arg, \"-QD\")) {\n\t\t\tCHECK_ARGC\n\t\t\tquery_cmd = strdup(argv[++i]);\n\t\t\tquery_default = 1;\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strcmp(arg, \"-sync\")) {\n\t\t\tremote_sync = 1;\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strcmp(arg, \"-nosync\")) {\n\t\t\tremote_sync = 0;\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strcmp(arg, \"-remote_prefix\")) {\n\t\t\tCHECK_ARGC\n\t\t\tremote_prefix = strdup(argv[++i]);\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strcmp(arg, \"-noremote\")) {\n\t\t\taccept_remote_cmds = 0;\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strcmp(arg, \"-yesremote\")) {\n\t\t\taccept_remote_cmds = 1;\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strcmp(arg, \"-unsafe\")) {\n\t\t\tsafe_remote_only = 0;\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strcmp(arg, \"-privremote\")) {\n\t\t\tpriv_remote = 1;\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strcmp(arg, \"-safer\")) {\n\t\t\tmore_safe = 1;\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strcmp(arg, \"-nocmds\")) {\n\t\t\tno_external_cmds = 1;\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strcmp(arg, \"-allowedcmds\")) {\n\t\t\tCHECK_ARGC\n\t\t\tallowed_external_cmds = strdup(argv[++i]);\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strcmp(arg, \"-deny_all\")) {\n\t\t\tdeny_all = 1;\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strcmp(arg, \"-httpdir\")) {\n\t\t\tCHECK_ARGC\n\t\t\thttp_dir = strdup(argv[++i]);\n\t\t\tgot_httpdir = 1;\n\t\t\tcontinue;\n\t\t}\n\t\tif (1) {\n\t\t\tif (!strcmp(arg, \"-desktop\") && i < argc-1) {\n\t\t\t\tdt = 1;\n\t\t\t\trfb_desktop_name = strdup(argv[i+1]);\n\t\t\t}\n\t\t\tif (!strcmp(arg, \"-passwd\")) {\n\t\t\t\tpw_loc = i;\n\t\t\t\tgot_passwd = 1;\n\t\t\t}\n\t\t\tif (!strcmp(arg, \"-rfbauth\")) {\n\t\t\t\tgot_rfbauth = 1;\n\t\t\t}\n\t\t\tif (!strcmp(arg, \"-rfbwait\")) {\n\t\t\t\tgot_rfbwait = 1;\n\t\t\t}\n\t\t\tif (!strcmp(arg, \"-deferupdate\")) {\n\t\t\t\tgot_deferupdate = 1;\n\t\t\t}\n\t\t\tif (!strcmp(arg, \"-rfbport\") && i < argc-1) {\n\t\t\t\tgot_rfbport = 1;\n\t\t\t\tif (!strcasecmp(argv[i+1], \"prompt\")) {\n\t\t\t\t\t;\n\t\t\t\t} else if (!is_decimal(argv[i+1])) {\n\t\t\t\t\tif (!got_inetd) {\n\t\t\t\t\t\trfbLog(\"Invalid -rfbport value: '%s'\\n\", argv[i+1]);\n\t\t\t\t\t\trfbLog(\"setting it to '-1' to induce failure.\\n\");\n\t\t\t\t\t\targv[i+1] = strdup(\"-1\");\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tgot_rfbport_str = strdup(argv[i+1]);\n\t\t\t\tgot_rfbport_pos = argc_vnc+1;\n\t\t\t\tgot_rfbport_val = atoi(argv[i+1]);\n\t\t\t}\n\t\t\tif (!strcmp(arg, \"-httpport\") && i < argc-1) {\n\t\t\t\tif (!is_decimal(argv[i+1])) {\n\t\t\t\t\trfbLog(\"Invalid -httpport value: '%s'\\n\", argv[i+1]);\n\t\t\t\t\tclean_up_exit(1);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!strcmp(arg, \"-alwaysshared \")) {\n\t\t\t\tgot_alwaysshared = 1;\n\t\t\t}\n\t\t\tif (!strcmp(arg, \"-nevershared\")) {\n\t\t\t\tgot_nevershared = 1;\n\t\t\t}\n\t\t\tif (!strcmp(arg, \"-listen\") && i < argc-1) {\n\t\t\t\tlisten_str = strdup(argv[i+1]);\n\t\t\t}\n\t\t\t/* otherwise copy it for libvncserver use below. */\n\t\t\tif (!strcmp(arg, \"-ultrafilexfer\")) {\n\t\t\t\tgot_ultrafilexfer = 1;\n\t\t\t} else if (argc_vnc < argc_vnc_max) {\n\t\t\t\targv_vnc[argc_vnc++] = strdup(arg);\n\t\t\t} else {\n\t\t\t\trfbLog(\"too many arguments.\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\t}"
  },
  {
    "function_name": "check_guess_auth_file",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/x11vnc.c",
    "lines": "1961-2037",
    "snippet": "static void check_guess_auth_file(void)  {\n\tif (!strcasecmp(auth_file, \"guess\")) {\n\t\tchar line[4096], *cmd, *q, *disp = use_dpy ? use_dpy: \"\";\n\t\tFILE *p;\n\t\tint n;\n\t\tif (!program_name) {\n\t\t\trfbLog(\"-auth guess: no program_name found.\\n\");\n\t\t\tclean_up_exit(1);\n\t\t}\n\t\tif (strpbrk(program_name, \" \\t\\r\\n\")) {\n\t\t\trfbLog(\"-auth guess: whitespace in program_name '%s'\\n\", program_name);\n\t\t\tclean_up_exit(1);\n\t\t}\n\t\tif (no_external_cmds || !cmd_ok(\"findauth\")) {\n\t\t\trfbLog(\"-auth guess: cannot run external commands in -nocmds mode:\\n\");\n\t\t\tclean_up_exit(1);\n\t\t}\n\n\t\tcmd = (char *)malloc(100 + strlen(program_name) + strlen(disp));\n\t\tsprintf(cmd, \"%s -findauth %s -env _D_XDM=1\", program_name, disp);\n\t\tp = popen(cmd, \"r\");\n\t\tif (!p) {\n\t\t\trfbLog(\"-auth guess: could not run cmd '%s'\\n\", cmd);\n\t\t\tclean_up_exit(1);\n\t\t}\n\t\tmemset(line, 0, sizeof(line));\n\t\tn = fread(line, 1, sizeof(line), p);\n\t\tpclose(p);\n\t\tq = strrchr(line, '\\n');\n\t\tif (q) *q = '\\0';\n\t\tif (!strcmp(disp, \"\")) {\n\t\t\tdisp = getenv(\"DISPLAY\");\n\t\t\tif (!disp) {\n\t\t\t\tdisp = \"unset\";\n\t\t\t}\n\t\t}\n\t\tif (strstr(line, \"XAUTHORITY=\") != line && !getenv(\"FD_XDM\")) {\n\t\t\tif (use_dpy == NULL || strstr(use_dpy, \"cmd=FIND\") == NULL) {\n\t\t\t\tif (getuid() == 0 || geteuid() == 0) {\n\t\t\t\t\tchar *q = strstr(cmd, \"_D_XDM=1\");\n\t\t\t\t\tif (q) {\n\t\t\t\t\t\t*q = 'F';\n\t\t\t\t\t\trfbLog(\"-auth guess: failed for display='%s'\\n\", disp);\n\t\t\t\t\t\trfbLog(\"-auth guess: since we are root, retrying with FD_XDM=1\\n\");\n\t\t\t\t\t\tp = popen(cmd, \"r\");\n\t\t\t\t\t\tif (!p) {\n\t\t\t\t\t\t\trfbLog(\"-auth guess: could not run cmd '%s'\\n\", cmd);\n\t\t\t\t\t\t\tclean_up_exit(1);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tmemset(line, 0, sizeof(line));\n\t\t\t\t\t\tn = fread(line, 1, sizeof(line), p);\n\t\t\t\t\t\tpclose(p);\n\t\t\t\t\t\tq = strrchr(line, '\\n');\n\t\t\t\t\t\tif (q) *q = '\\0';\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (!strcmp(line, \"\")) {\n\t\t\trfbLog(\"-auth guess: failed for display='%s'\\n\", disp);\n\t\t\tclean_up_exit(1);\n\t\t} else if (strstr(line, \"XAUTHORITY=\") != line) {\n\t\t\trfbLog(\"-auth guess: failed. '%s' for display='%s'\\n\", line, disp);\n\t\t\tclean_up_exit(1);\n\t\t} else if (!strcmp(line, \"XAUTHORITY=\")) {\n\t\t\trfbLog(\"-auth guess: using default XAUTHORITY for display='%s'\\n\", disp);\n\t\t\tq = getenv(\"XAUTHORITY\");\n\t\t\tif (q) {\n\t\t\t\t*(q-2) = '_';\t/* yow */\n\t\t\t}\n\t\t\tauth_file = NULL;\n\t\t} else {\n\t\t\trfbLog(\"-auth guess: using '%s' for disp='%s'\\n\", line, disp);\n\t\t\tauth_file = strdup(line + strlen(\"XAUTHORITY=\"));\n\t\t}\n\t}\n}",
    "includes": [
      "#include \"xi2_devices.h\"",
      "#include \"solid.h\"",
      "#include \"pm.h\"",
      "#include \"selection.h\"",
      "#include \"sslhelper.h\"",
      "#include \"sslcmds.h\"",
      "#include \"inet.h\"",
      "#include \"unixpw.h\"",
      "#include \"rates.h\"",
      "#include \"connections.h\"",
      "#include \"screen.h\"",
      "#include \"userinput.h\"",
      "#include \"cursor.h\"",
      "#include \"pointer.h\"",
      "#include \"keyboard.h\"",
      "#include \"cleanup.h\"",
      "#include \"user.h\"",
      "#include \"help.h\"",
      "#include \"gui.h\"",
      "#include \"scan.h\"",
      "#include \"remote.h\"",
      "#include \"win_utils.h\"",
      "#include \"xkb_bell.h\"",
      "#include \"xrandr.h\"",
      "#include \"xinerama.h\"",
      "#include \"xevents.h\"",
      "#include \"xrecord.h\"",
      "#include \"xdamage.h\"",
      "#include \"xwrappers.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "line + strlen(\"XAUTHORITY=\")"
          ],
          "line": 2034
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "\"XAUTHORITY=\""
          ],
          "line": 2034
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"-auth guess: using '%s' for disp='%s'\\n\"",
            "line",
            "disp"
          ],
          "line": 2033
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getenv",
          "args": [
            "\"XAUTHORITY\""
          ],
          "line": 2027
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"-auth guess: using default XAUTHORITY for display='%s'\\n\"",
            "disp"
          ],
          "line": 2026
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "line",
            "\"XAUTHORITY=\""
          ],
          "line": 2025
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clean_up_exit",
          "args": [
            "1"
          ],
          "line": 2024
        },
        "resolved": true,
        "details": {
          "function_name": "clean_up_exit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/cleanup.c",
          "lines": "151-266",
          "snippet": "void clean_up_exit(int ret) {\n\tstatic int depth = 0;\n\texit_flag = 1;\n\n\tif (depth++ > 2) {\n\t\texit(ret);\n\t}\n\n\tif (icon_mode) {\n\t\tclean_icon_mode();\n\t}\n\n\t/* remove the shm areas: */\n\tclean_shm(0);\n\n\tstop_stunnel();\n\tif (use_openssl) {\n\t\tssl_helper_pid(0, 0);\t/* killall */\n\t}\n\n\tif (ssh_pid > 0) {\n\t\tkill(ssh_pid, SIGTERM);\n\t\tssh_pid = 0;\n\t}\n\n#ifdef MACOSX\n\tif (client_connect_file) {\n\t\tif (strstr(client_connect_file, \"/tmp/x11vnc-macosx-remote\")\n\t\t    == client_connect_file) {\n\t\t\tunlink(client_connect_file);\n\t\t}\n\t}\n\tif (macosx_console) {\n\t\tmacosxCG_fini();\n\t}\n#endif\n\n\tif (pipeinput_fh != NULL) {\n\t\tpclose(pipeinput_fh);\n\t\tpipeinput_fh = NULL;\n\t}\n\n\tshutdown_uinput();\n\n\tif (unix_sock) {\n\t\tif (unix_sock_fd >= 0) {\n\t\t\trfbLog(\"deleting unix sock: %s\\n\", unix_sock);\n\t\t\tclose(unix_sock_fd);\n\t\t\tunix_sock_fd = -1;\n\t\t\tunlink(unix_sock);\n\t\t}\n\t}\n\n\tif (! dpy) {\t/* raw_rb hack */\n\t\tif (rm_flagfile) {\n\t\t\tunlink(rm_flagfile);\n\t\t\trm_flagfile = NULL;\n\t\t}\n\t\texit(ret);\n\t}\n\n\t/* X keyboard cleanups */\n\tdelete_added_keycodes(0);\n\n\t/* remove all created XInput2 devices */\n\tif(use_multipointer)\n\t    removeAllMDs(dpy);\n\n\tif (clear_mods == 1) {\n\t\tclear_modifiers(0);\n\t} else if (clear_mods == 2) {\n\t\tclear_keys();\n\t} else if (clear_mods == 3) {\n\t\tclear_keys();\n\t\tclear_locks();\n\t}\n\n\tif (no_autorepeat) {\n\t\tautorepeat(1, 0);\n\t}\n\tif (use_solid_bg) {\n\t\tsolid_bg(1);\n\t}\n\tif (ncache || ncache0) {\n\t\tkde_no_animate(1);\n\t}\n\tX_LOCK;\n\tXTestDiscard_wr(dpy);\n#if HAVE_LIBXDAMAGE\n\tif (xdamage) {\n\t\tXDamageDestroy(dpy, xdamage);\n\t}\n#endif\n#if HAVE_LIBXTRAP\n\tif (trap_ctx) {\n\t\tXEFreeTC(trap_ctx);\n\t}\n#endif\n\t/* XXX rdpy_ctrl, etc. cannot close w/o blocking */\n\tXCloseDisplay_wr(dpy);\n\tX_UNLOCK;\n\n\tfflush(stderr);\n\n\tif (rm_flagfile) {\n\t\tunlink(rm_flagfile);\n\t\trm_flagfile = NULL;\n\t}\n\n\tif (avahi) {\n\t\tavahi_cleanup();\n\t\tfflush(stderr);\n\t}\n\n\texit(ret);\n}",
          "includes": [
            "#include \"xi2_devices.h\"",
            "#include \"uinput.h\"",
            "#include \"xevents.h\"",
            "#include \"xrecord.h\"",
            "#include \"screen.h\"",
            "#include \"avahi.h\"",
            "#include \"macosxCG.h\"",
            "#include \"macosx.h\"",
            "#include \"connections.h\"",
            "#include \"sslhelper.h\"",
            "#include \"sslcmds.h\"",
            "#include \"unixpw.h\"",
            "#include \"solid.h\"",
            "#include \"gui.h\"",
            "#include \"scan.h\"",
            "#include \"keyboard.h\"",
            "#include \"remote.h\"",
            "#include \"xdamage.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void clean_up_exit(int ret);",
            "int known_sigpipe_mode(char *s);",
            "static int exit_flag = 0;",
            "static void clean_icon_mode(void);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xi2_devices.h\"\n#include \"uinput.h\"\n#include \"xevents.h\"\n#include \"xrecord.h\"\n#include \"screen.h\"\n#include \"avahi.h\"\n#include \"macosxCG.h\"\n#include \"macosx.h\"\n#include \"connections.h\"\n#include \"sslhelper.h\"\n#include \"sslcmds.h\"\n#include \"unixpw.h\"\n#include \"solid.h\"\n#include \"gui.h\"\n#include \"scan.h\"\n#include \"keyboard.h\"\n#include \"remote.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nvoid clean_up_exit(int ret);\nint known_sigpipe_mode(char *s);\nstatic int exit_flag = 0;\nstatic void clean_icon_mode(void);\n\nvoid clean_up_exit(int ret) {\n\tstatic int depth = 0;\n\texit_flag = 1;\n\n\tif (depth++ > 2) {\n\t\texit(ret);\n\t}\n\n\tif (icon_mode) {\n\t\tclean_icon_mode();\n\t}\n\n\t/* remove the shm areas: */\n\tclean_shm(0);\n\n\tstop_stunnel();\n\tif (use_openssl) {\n\t\tssl_helper_pid(0, 0);\t/* killall */\n\t}\n\n\tif (ssh_pid > 0) {\n\t\tkill(ssh_pid, SIGTERM);\n\t\tssh_pid = 0;\n\t}\n\n#ifdef MACOSX\n\tif (client_connect_file) {\n\t\tif (strstr(client_connect_file, \"/tmp/x11vnc-macosx-remote\")\n\t\t    == client_connect_file) {\n\t\t\tunlink(client_connect_file);\n\t\t}\n\t}\n\tif (macosx_console) {\n\t\tmacosxCG_fini();\n\t}\n#endif\n\n\tif (pipeinput_fh != NULL) {\n\t\tpclose(pipeinput_fh);\n\t\tpipeinput_fh = NULL;\n\t}\n\n\tshutdown_uinput();\n\n\tif (unix_sock) {\n\t\tif (unix_sock_fd >= 0) {\n\t\t\trfbLog(\"deleting unix sock: %s\\n\", unix_sock);\n\t\t\tclose(unix_sock_fd);\n\t\t\tunix_sock_fd = -1;\n\t\t\tunlink(unix_sock);\n\t\t}\n\t}\n\n\tif (! dpy) {\t/* raw_rb hack */\n\t\tif (rm_flagfile) {\n\t\t\tunlink(rm_flagfile);\n\t\t\trm_flagfile = NULL;\n\t\t}\n\t\texit(ret);\n\t}\n\n\t/* X keyboard cleanups */\n\tdelete_added_keycodes(0);\n\n\t/* remove all created XInput2 devices */\n\tif(use_multipointer)\n\t    removeAllMDs(dpy);\n\n\tif (clear_mods == 1) {\n\t\tclear_modifiers(0);\n\t} else if (clear_mods == 2) {\n\t\tclear_keys();\n\t} else if (clear_mods == 3) {\n\t\tclear_keys();\n\t\tclear_locks();\n\t}\n\n\tif (no_autorepeat) {\n\t\tautorepeat(1, 0);\n\t}\n\tif (use_solid_bg) {\n\t\tsolid_bg(1);\n\t}\n\tif (ncache || ncache0) {\n\t\tkde_no_animate(1);\n\t}\n\tX_LOCK;\n\tXTestDiscard_wr(dpy);\n#if HAVE_LIBXDAMAGE\n\tif (xdamage) {\n\t\tXDamageDestroy(dpy, xdamage);\n\t}\n#endif\n#if HAVE_LIBXTRAP\n\tif (trap_ctx) {\n\t\tXEFreeTC(trap_ctx);\n\t}\n#endif\n\t/* XXX rdpy_ctrl, etc. cannot close w/o blocking */\n\tXCloseDisplay_wr(dpy);\n\tX_UNLOCK;\n\n\tfflush(stderr);\n\n\tif (rm_flagfile) {\n\t\tunlink(rm_flagfile);\n\t\trm_flagfile = NULL;\n\t}\n\n\tif (avahi) {\n\t\tavahi_cleanup();\n\t\tfflush(stderr);\n\t}\n\n\texit(ret);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"-auth guess: failed. '%s' for display='%s'\\n\"",
            "line",
            "disp"
          ],
          "line": 2023
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "line",
            "\"XAUTHORITY=\""
          ],
          "line": 2022
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"-auth guess: failed for display='%s'\\n\"",
            "disp"
          ],
          "line": 2020
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "line",
            "\"\""
          ],
          "line": 2019
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strrchr",
          "args": [
            "line",
            "'\\n'"
          ],
          "line": 2013
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pclose",
          "args": [
            "p"
          ],
          "line": 2012
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fread",
          "args": [
            "line",
            "1",
            "sizeof(line)",
            "p"
          ],
          "line": 2011
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "line",
            "0",
            "sizeof(line)"
          ],
          "line": 2010
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"-auth guess: could not run cmd '%s'\\n\"",
            "cmd"
          ],
          "line": 2007
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "popen",
          "args": [
            "cmd",
            "\"r\""
          ],
          "line": 2005
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"-auth guess: since we are root, retrying with FD_XDM=1\\n\""
          ],
          "line": 2004
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"-auth guess: failed for display='%s'\\n\"",
            "disp"
          ],
          "line": 2003
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "cmd",
            "\"_D_XDM=1\""
          ],
          "line": 2000
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "geteuid",
          "args": [],
          "line": 1999
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getuid",
          "args": [],
          "line": 1999
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "use_dpy",
            "\"cmd=FIND\""
          ],
          "line": 1998
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getenv",
          "args": [
            "\"FD_XDM\""
          ],
          "line": 1997
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "line",
            "\"XAUTHORITY=\""
          ],
          "line": 1997
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getenv",
          "args": [
            "\"DISPLAY\""
          ],
          "line": 1992
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "disp",
            "\"\""
          ],
          "line": 1991
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strrchr",
          "args": [
            "line",
            "'\\n'"
          ],
          "line": 1989
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pclose",
          "args": [
            "p"
          ],
          "line": 1988
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fread",
          "args": [
            "line",
            "1",
            "sizeof(line)",
            "p"
          ],
          "line": 1987
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "line",
            "0",
            "sizeof(line)"
          ],
          "line": 1986
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"-auth guess: could not run cmd '%s'\\n\"",
            "cmd"
          ],
          "line": 1983
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "popen",
          "args": [
            "cmd",
            "\"r\""
          ],
          "line": 1981
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "cmd",
            "\"%s -findauth %s -env _D_XDM=1\"",
            "program_name",
            "disp"
          ],
          "line": 1980
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "100 + strlen(program_name) + strlen(disp)"
          ],
          "line": 1979
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "disp"
          ],
          "line": 1979
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "program_name"
          ],
          "line": 1979
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"-auth guess: cannot run external commands in -nocmds mode:\\n\""
          ],
          "line": 1975
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cmd_ok",
          "args": [
            "\"findauth\""
          ],
          "line": 1974
        },
        "resolved": true,
        "details": {
          "function_name": "cmd_ok",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/connections.c",
          "lines": "436-460",
          "snippet": "int cmd_ok(char *cmd) {\n\tchar *p, *str;\n\tif (no_external_cmds) {\n\t\treturn 0;\n\t}\n\tif (! cmd || cmd[0] == '\\0') {\n\t\treturn 0;\n\t}\n\tif (! allowed_external_cmds) {\n\t\t/* default, allow any (overridden by -nocmds) */\n\t\treturn 1;\n\t}\n\n\tstr = strdup(allowed_external_cmds);\n\tp = strtok(str, \",\");\n\twhile (p) {\n\t\tif (!strcmp(p, cmd)) {\n\t\t\tfree(str);\n\t\t\treturn 1;\n\t\t}\n\t\tp = strtok(NULL, \",\");\n\t}\n\tfree(str);\n\treturn 0;\n}",
          "includes": [
            "#include \"xi2_devices.h\"",
            "#include \"xrandr.h\"",
            "#include \"pointer.h\"",
            "#include \"userinput.h\"",
            "#include \"macosxCG.h\"",
            "#include \"macosx.h\"",
            "#include \"win_utils.h\"",
            "#include \"xevents.h\"",
            "#include \"xwrappers.h\"",
            "#include \"sslhelper.h\"",
            "#include \"sslcmds.h\"",
            "#include \"scan.h\"",
            "#include \"user.h\"",
            "#include \"unixpw.h\"",
            "#include \"screen.h\"",
            "#include \"rates.h\"",
            "#include \"solid.h\"",
            "#include \"gui.h\"",
            "#include \"cleanup.h\"",
            "#include \"keyboard.h\"",
            "#include \"remote.h\"",
            "#include \"inet.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void close_clients(char *str);",
            "void set_client_input(char *str);",
            "int cmd_ok(char *cmd);",
            "void reverse_connect(char *str);",
            "void set_vnc_connect_prop(char *str);",
            "void set_x11vnc_remote_prop(char *str);",
            "void send_client_info(char *str);",
            "static rfbClientPtr *client_match(char *str);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xi2_devices.h\"\n#include \"xrandr.h\"\n#include \"pointer.h\"\n#include \"userinput.h\"\n#include \"macosxCG.h\"\n#include \"macosx.h\"\n#include \"win_utils.h\"\n#include \"xevents.h\"\n#include \"xwrappers.h\"\n#include \"sslhelper.h\"\n#include \"sslcmds.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"unixpw.h\"\n#include \"screen.h\"\n#include \"rates.h\"\n#include \"solid.h\"\n#include \"gui.h\"\n#include \"cleanup.h\"\n#include \"keyboard.h\"\n#include \"remote.h\"\n#include \"inet.h\"\n#include \"x11vnc.h\"\n\nvoid close_clients(char *str);\nvoid set_client_input(char *str);\nint cmd_ok(char *cmd);\nvoid reverse_connect(char *str);\nvoid set_vnc_connect_prop(char *str);\nvoid set_x11vnc_remote_prop(char *str);\nvoid send_client_info(char *str);\nstatic rfbClientPtr *client_match(char *str);\n\nint cmd_ok(char *cmd) {\n\tchar *p, *str;\n\tif (no_external_cmds) {\n\t\treturn 0;\n\t}\n\tif (! cmd || cmd[0] == '\\0') {\n\t\treturn 0;\n\t}\n\tif (! allowed_external_cmds) {\n\t\t/* default, allow any (overridden by -nocmds) */\n\t\treturn 1;\n\t}\n\n\tstr = strdup(allowed_external_cmds);\n\tp = strtok(str, \",\");\n\twhile (p) {\n\t\tif (!strcmp(p, cmd)) {\n\t\t\tfree(str);\n\t\t\treturn 1;\n\t\t}\n\t\tp = strtok(NULL, \",\");\n\t}\n\tfree(str);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"-auth guess: whitespace in program_name '%s'\\n\"",
            "program_name"
          ],
          "line": 1971
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strpbrk",
          "args": [
            "program_name",
            "\" \\t\\r\\n\""
          ],
          "line": 1970
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"-auth guess: no program_name found.\\n\""
          ],
          "line": 1967
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcasecmp",
          "args": [
            "auth_file",
            "\"guess\""
          ],
          "line": 1962
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xi2_devices.h\"\n#include \"solid.h\"\n#include \"pm.h\"\n#include \"selection.h\"\n#include \"sslhelper.h\"\n#include \"sslcmds.h\"\n#include \"inet.h\"\n#include \"unixpw.h\"\n#include \"rates.h\"\n#include \"connections.h\"\n#include \"screen.h\"\n#include \"userinput.h\"\n#include \"cursor.h\"\n#include \"pointer.h\"\n#include \"keyboard.h\"\n#include \"cleanup.h\"\n#include \"user.h\"\n#include \"help.h\"\n#include \"gui.h\"\n#include \"scan.h\"\n#include \"remote.h\"\n#include \"win_utils.h\"\n#include \"xkb_bell.h\"\n#include \"xrandr.h\"\n#include \"xinerama.h\"\n#include \"xevents.h\"\n#include \"xrecord.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nstatic void check_guess_auth_file(void)  {\n\tif (!strcasecmp(auth_file, \"guess\")) {\n\t\tchar line[4096], *cmd, *q, *disp = use_dpy ? use_dpy: \"\";\n\t\tFILE *p;\n\t\tint n;\n\t\tif (!program_name) {\n\t\t\trfbLog(\"-auth guess: no program_name found.\\n\");\n\t\t\tclean_up_exit(1);\n\t\t}\n\t\tif (strpbrk(program_name, \" \\t\\r\\n\")) {\n\t\t\trfbLog(\"-auth guess: whitespace in program_name '%s'\\n\", program_name);\n\t\t\tclean_up_exit(1);\n\t\t}\n\t\tif (no_external_cmds || !cmd_ok(\"findauth\")) {\n\t\t\trfbLog(\"-auth guess: cannot run external commands in -nocmds mode:\\n\");\n\t\t\tclean_up_exit(1);\n\t\t}\n\n\t\tcmd = (char *)malloc(100 + strlen(program_name) + strlen(disp));\n\t\tsprintf(cmd, \"%s -findauth %s -env _D_XDM=1\", program_name, disp);\n\t\tp = popen(cmd, \"r\");\n\t\tif (!p) {\n\t\t\trfbLog(\"-auth guess: could not run cmd '%s'\\n\", cmd);\n\t\t\tclean_up_exit(1);\n\t\t}\n\t\tmemset(line, 0, sizeof(line));\n\t\tn = fread(line, 1, sizeof(line), p);\n\t\tpclose(p);\n\t\tq = strrchr(line, '\\n');\n\t\tif (q) *q = '\\0';\n\t\tif (!strcmp(disp, \"\")) {\n\t\t\tdisp = getenv(\"DISPLAY\");\n\t\t\tif (!disp) {\n\t\t\t\tdisp = \"unset\";\n\t\t\t}\n\t\t}\n\t\tif (strstr(line, \"XAUTHORITY=\") != line && !getenv(\"FD_XDM\")) {\n\t\t\tif (use_dpy == NULL || strstr(use_dpy, \"cmd=FIND\") == NULL) {\n\t\t\t\tif (getuid() == 0 || geteuid() == 0) {\n\t\t\t\t\tchar *q = strstr(cmd, \"_D_XDM=1\");\n\t\t\t\t\tif (q) {\n\t\t\t\t\t\t*q = 'F';\n\t\t\t\t\t\trfbLog(\"-auth guess: failed for display='%s'\\n\", disp);\n\t\t\t\t\t\trfbLog(\"-auth guess: since we are root, retrying with FD_XDM=1\\n\");\n\t\t\t\t\t\tp = popen(cmd, \"r\");\n\t\t\t\t\t\tif (!p) {\n\t\t\t\t\t\t\trfbLog(\"-auth guess: could not run cmd '%s'\\n\", cmd);\n\t\t\t\t\t\t\tclean_up_exit(1);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tmemset(line, 0, sizeof(line));\n\t\t\t\t\t\tn = fread(line, 1, sizeof(line), p);\n\t\t\t\t\t\tpclose(p);\n\t\t\t\t\t\tq = strrchr(line, '\\n');\n\t\t\t\t\t\tif (q) *q = '\\0';\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (!strcmp(line, \"\")) {\n\t\t\trfbLog(\"-auth guess: failed for display='%s'\\n\", disp);\n\t\t\tclean_up_exit(1);\n\t\t} else if (strstr(line, \"XAUTHORITY=\") != line) {\n\t\t\trfbLog(\"-auth guess: failed. '%s' for display='%s'\\n\", line, disp);\n\t\t\tclean_up_exit(1);\n\t\t} else if (!strcmp(line, \"XAUTHORITY=\")) {\n\t\t\trfbLog(\"-auth guess: using default XAUTHORITY for display='%s'\\n\", disp);\n\t\t\tq = getenv(\"XAUTHORITY\");\n\t\t\tif (q) {\n\t\t\t\t*(q-2) = '_';\t/* yow */\n\t\t\t}\n\t\t\tauth_file = NULL;\n\t\t} else {\n\t\t\trfbLog(\"-auth guess: using '%s' for disp='%s'\\n\", line, disp);\n\t\t\tauth_file = strdup(line + strlen(\"XAUTHORITY=\"));\n\t\t}\n\t}\n}"
  },
  {
    "function_name": "do_sleepin",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/x11vnc.c",
    "lines": "1929-1959",
    "snippet": "static void do_sleepin(char *sleep) {\n\tint n1, n2, nt;\n\tdouble f1, f2, ft;\n\n\tif (strchr(sleep, '-')) {\n\t\tdouble s = atof(strchr(sleep, '-')+1); \n\t\tif (sscanf(sleep, \"%d-%d\", &n1, &n2) == 2) {\n\t\t\tif (n1 > n2) {\n\t\t\t\tnt = n1;\n\t\t\t\tn1 = n2;\n\t\t\t\tn2 = nt;\n\t\t\t}\n\t\t\ts = n1 + rfac() * (n2 - n1);\n\t\t} else if (sscanf(sleep, \"%lf-%lf\", &f1, &f2) == 2) {\n\t\t\tif (f1 > f2) {\n\t\t\t\tft = f1;\n\t\t\t\tf1 = f2;\n\t\t\t\tf2 = ft;\n\t\t\t}\n\t\t\ts = f1 + rfac() * (f2 - f1);\n\t\t}\n\t\tif (getenv(\"DEBUG_SLEEPIN\")) fprintf(stderr, \"sleepin: %f secs\\n\", s);\n\t\tusleep( (int) (1000*1000*s) );\n\t} else {\n\t\tn1 = atoi(sleep);\n\t\tif (getenv(\"DEBUG_SLEEPIN\")) fprintf(stderr, \"sleepin: %d secs\\n\", n1);\n\t\tif (n1 > 0) {\n\t\t\tusleep(1000*1000*n1);\n\t\t}\n\t}\n}",
    "includes": [
      "#include \"xi2_devices.h\"",
      "#include \"solid.h\"",
      "#include \"pm.h\"",
      "#include \"selection.h\"",
      "#include \"sslhelper.h\"",
      "#include \"sslcmds.h\"",
      "#include \"inet.h\"",
      "#include \"unixpw.h\"",
      "#include \"rates.h\"",
      "#include \"connections.h\"",
      "#include \"screen.h\"",
      "#include \"userinput.h\"",
      "#include \"cursor.h\"",
      "#include \"pointer.h\"",
      "#include \"keyboard.h\"",
      "#include \"cleanup.h\"",
      "#include \"user.h\"",
      "#include \"help.h\"",
      "#include \"gui.h\"",
      "#include \"scan.h\"",
      "#include \"remote.h\"",
      "#include \"win_utils.h\"",
      "#include \"xkb_bell.h\"",
      "#include \"xrandr.h\"",
      "#include \"xinerama.h\"",
      "#include \"xevents.h\"",
      "#include \"xrecord.h\"",
      "#include \"xdamage.h\"",
      "#include \"xwrappers.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "usleep",
          "args": [
            "1000*1000*n1"
          ],
          "line": 1956
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"sleepin: %d secs\\n\"",
            "n1"
          ],
          "line": 1954
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getenv",
          "args": [
            "\"DEBUG_SLEEPIN\""
          ],
          "line": 1954
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atoi",
          "args": [
            "sleep"
          ],
          "line": 1953
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "usleep",
          "args": [
            "(int) (1000*1000*s)"
          ],
          "line": 1951
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"sleepin: %f secs\\n\"",
            "s"
          ],
          "line": 1950
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getenv",
          "args": [
            "\"DEBUG_SLEEPIN\""
          ],
          "line": 1950
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfac",
          "args": [],
          "line": 1948
        },
        "resolved": true,
        "details": {
          "function_name": "rfac",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/util.c",
          "lines": "454-473",
          "snippet": "double rfac(void) {\n\tdouble f;\n\tstatic int first = 1;\n\n\tif (first) {\n\t\tunsigned int s;\n\t\tif (getenv(\"RAND_SEED\")) {\n\t\t\ts = (unsigned int) atoi(getenv(\"RAND_SEED\"));\n\t\t} else {\n\t\t\ts = (unsigned int) ((int) getpid() + 100000 * rnow());\n\t\t}\n\t\tsrand(s);\n\t\tfirst = 0;\n\t}\n\n\tf = (double) rand();\n\tf = f / ((double) RAND_MAX);\n\n\treturn f;\n}",
          "includes": [
            "#include \"connections.h\"",
            "#include \"unixpw.h\"",
            "#include \"win_utils.h\"",
            "#include \"cleanup.h\"",
            "#include \"x11vnc.h\"",
            "#include <stdlib.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "double rnow(void);",
            "double rfac(void);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"connections.h\"\n#include \"unixpw.h\"\n#include \"win_utils.h\"\n#include \"cleanup.h\"\n#include \"x11vnc.h\"\n#include <stdlib.h>\n\ndouble rnow(void);\ndouble rfac(void);\n\ndouble rfac(void) {\n\tdouble f;\n\tstatic int first = 1;\n\n\tif (first) {\n\t\tunsigned int s;\n\t\tif (getenv(\"RAND_SEED\")) {\n\t\t\ts = (unsigned int) atoi(getenv(\"RAND_SEED\"));\n\t\t} else {\n\t\t\ts = (unsigned int) ((int) getpid() + 100000 * rnow());\n\t\t}\n\t\tsrand(s);\n\t\tfirst = 0;\n\t}\n\n\tf = (double) rand();\n\tf = f / ((double) RAND_MAX);\n\n\treturn f;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sscanf",
          "args": [
            "sleep",
            "\"%lf-%lf\"",
            "&f1",
            "&f2"
          ],
          "line": 1942
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sscanf",
          "args": [
            "sleep",
            "\"%d-%d\"",
            "&n1",
            "&n2"
          ],
          "line": 1935
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atof",
          "args": [
            "strchr(sleep, '-')+1"
          ],
          "line": 1934
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "sleep",
            "'-'"
          ],
          "line": 1934
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "sleep",
            "'-'"
          ],
          "line": 1933
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xi2_devices.h\"\n#include \"solid.h\"\n#include \"pm.h\"\n#include \"selection.h\"\n#include \"sslhelper.h\"\n#include \"sslcmds.h\"\n#include \"inet.h\"\n#include \"unixpw.h\"\n#include \"rates.h\"\n#include \"connections.h\"\n#include \"screen.h\"\n#include \"userinput.h\"\n#include \"cursor.h\"\n#include \"pointer.h\"\n#include \"keyboard.h\"\n#include \"cleanup.h\"\n#include \"user.h\"\n#include \"help.h\"\n#include \"gui.h\"\n#include \"scan.h\"\n#include \"remote.h\"\n#include \"win_utils.h\"\n#include \"xkb_bell.h\"\n#include \"xrandr.h\"\n#include \"xinerama.h\"\n#include \"xevents.h\"\n#include \"xrecord.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nstatic void do_sleepin(char *sleep) {\n\tint n1, n2, nt;\n\tdouble f1, f2, ft;\n\n\tif (strchr(sleep, '-')) {\n\t\tdouble s = atof(strchr(sleep, '-')+1); \n\t\tif (sscanf(sleep, \"%d-%d\", &n1, &n2) == 2) {\n\t\t\tif (n1 > n2) {\n\t\t\t\tnt = n1;\n\t\t\t\tn1 = n2;\n\t\t\t\tn2 = nt;\n\t\t\t}\n\t\t\ts = n1 + rfac() * (n2 - n1);\n\t\t} else if (sscanf(sleep, \"%lf-%lf\", &f1, &f2) == 2) {\n\t\t\tif (f1 > f2) {\n\t\t\t\tft = f1;\n\t\t\t\tf1 = f2;\n\t\t\t\tf2 = ft;\n\t\t\t}\n\t\t\ts = f1 + rfac() * (f2 - f1);\n\t\t}\n\t\tif (getenv(\"DEBUG_SLEEPIN\")) fprintf(stderr, \"sleepin: %f secs\\n\", s);\n\t\tusleep( (int) (1000*1000*s) );\n\t} else {\n\t\tn1 = atoi(sleep);\n\t\tif (getenv(\"DEBUG_SLEEPIN\")) fprintf(stderr, \"sleepin: %d secs\\n\", n1);\n\t\tif (n1 > 0) {\n\t\t\tusleep(1000*1000*n1);\n\t\t}\n\t}\n}"
  },
  {
    "function_name": "ncache_beta_tester_message",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/x11vnc.c",
    "lines": "1848-1922",
    "snippet": "void ncache_beta_tester_message(void) {\n\nchar msg[] = \n\"\\n\"\n\"******************************************************************************\\n\"\n\"\\n\"\n\"Hello!  Exciting News!!\\n\"\n\"\\n\"\n\"You have been selected at random to beta-test the x11vnc '-ncache' VNC\\n\"\n\"client-side pixel caching feature!\\n\"\n\"\\n\"\n\"This scheme stores pixel data offscreen on the VNC viewer side for faster\\n\"\n\"retrieval.  It should work with any VNC viewer.\\n\"\n\"\\n\"\n\"This method requires much testing and so we hope you will try it out and\\n\"\n\"perhaps even report back your observations.  However, if you do not want\\n\"\n\"to test or use the feature, run x11vnc like this:\\n\"\n\"\\n\"\n\"    x11vnc -noncache ...\\n\"\n\"\\n\"\n\"Your current setting is: -ncache %d\\n\"\n\"\\n\"\n\"The feature needs additional testing because we want to have x11vnc\\n\"\n\"performance enhancements on by default.  Otherwise, only a relative few\\n\"\n\"would notice and use the -ncache option (e.g. the wireframe and scroll\\n\"\n\"detection features are on by default).  A couple things to note:\\n\"\n\"\\n\"\n\"    1) It uses a large amount of RAM (on both viewer and server sides)\\n\"\n\"\\n\"\n\"    2) You can actually see the cached pixel data if you scroll down\\n\"\n\"       to it in your viewer; adjust your viewer's size to hide it.\\n\"\n\"\\n\"\n\"More info: http://www.karlrunge.com/x11vnc/faq.html#faq-client-caching\\n\"\n\"\\n\"\n\"waiting for connections:\\n\"\n;\n\nchar msg2[] = \n\"\\n\"\n\"******************************************************************************\\n\"\n\"Have you tried the x11vnc '-ncache' VNC client-side pixel caching feature yet?\\n\"\n\"\\n\"\n\"The scheme stores pixel data offscreen on the VNC viewer side for faster\\n\"\n\"retrieval.  It should work with any VNC viewer.  Try it by running:\\n\"\n\"\\n\"\n\"    x11vnc -ncache 10 ...\\n\"\n\"\\n\"\n\"One can also add -ncache_cr for smooth 'copyrect' window motion.\\n\"\n\"More info: http://www.karlrunge.com/x11vnc/faq.html#faq-client-caching\\n\"\n\"\\n\"\n;\n\n\tif (raw_fb_str && !macosx_console) {\n\t\treturn;\n\t}\n\tif (quiet) {\n\t\treturn;\n\t}\n\tif (remote_direct) {\n\t\treturn;\n\t}\n\tif (nofb) {\n\t\treturn;\n\t}\n#ifdef NO_NCACHE\n\treturn;\n#endif\n\n\tif (ncache == 0) {\n\t\tfprintf(stderr, \"%s\", msg2);\n\t\tncache0 = ncache = 0;\n\t} else {\n\t\tfprintf(stderr, msg, ncache);\n\t}\n}",
    "includes": [
      "#include \"xi2_devices.h\"",
      "#include \"solid.h\"",
      "#include \"pm.h\"",
      "#include \"selection.h\"",
      "#include \"sslhelper.h\"",
      "#include \"sslcmds.h\"",
      "#include \"inet.h\"",
      "#include \"unixpw.h\"",
      "#include \"rates.h\"",
      "#include \"connections.h\"",
      "#include \"screen.h\"",
      "#include \"userinput.h\"",
      "#include \"cursor.h\"",
      "#include \"pointer.h\"",
      "#include \"keyboard.h\"",
      "#include \"cleanup.h\"",
      "#include \"user.h\"",
      "#include \"help.h\"",
      "#include \"gui.h\"",
      "#include \"scan.h\"",
      "#include \"remote.h\"",
      "#include \"win_utils.h\"",
      "#include \"xkb_bell.h\"",
      "#include \"xrandr.h\"",
      "#include \"xinerama.h\"",
      "#include \"xevents.h\"",
      "#include \"xrecord.h\"",
      "#include \"xdamage.h\"",
      "#include \"xwrappers.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "msg",
            "ncache"
          ],
          "line": 1920
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"%s\"",
            "msg2"
          ],
          "line": 1917
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xi2_devices.h\"\n#include \"solid.h\"\n#include \"pm.h\"\n#include \"selection.h\"\n#include \"sslhelper.h\"\n#include \"sslcmds.h\"\n#include \"inet.h\"\n#include \"unixpw.h\"\n#include \"rates.h\"\n#include \"connections.h\"\n#include \"screen.h\"\n#include \"userinput.h\"\n#include \"cursor.h\"\n#include \"pointer.h\"\n#include \"keyboard.h\"\n#include \"cleanup.h\"\n#include \"user.h\"\n#include \"help.h\"\n#include \"gui.h\"\n#include \"scan.h\"\n#include \"remote.h\"\n#include \"win_utils.h\"\n#include \"xkb_bell.h\"\n#include \"xrandr.h\"\n#include \"xinerama.h\"\n#include \"xevents.h\"\n#include \"xrecord.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nvoid ncache_beta_tester_message(void) {\n\nchar msg[] = \n\"\\n\"\n\"******************************************************************************\\n\"\n\"\\n\"\n\"Hello!  Exciting News!!\\n\"\n\"\\n\"\n\"You have been selected at random to beta-test the x11vnc '-ncache' VNC\\n\"\n\"client-side pixel caching feature!\\n\"\n\"\\n\"\n\"This scheme stores pixel data offscreen on the VNC viewer side for faster\\n\"\n\"retrieval.  It should work with any VNC viewer.\\n\"\n\"\\n\"\n\"This method requires much testing and so we hope you will try it out and\\n\"\n\"perhaps even report back your observations.  However, if you do not want\\n\"\n\"to test or use the feature, run x11vnc like this:\\n\"\n\"\\n\"\n\"    x11vnc -noncache ...\\n\"\n\"\\n\"\n\"Your current setting is: -ncache %d\\n\"\n\"\\n\"\n\"The feature needs additional testing because we want to have x11vnc\\n\"\n\"performance enhancements on by default.  Otherwise, only a relative few\\n\"\n\"would notice and use the -ncache option (e.g. the wireframe and scroll\\n\"\n\"detection features are on by default).  A couple things to note:\\n\"\n\"\\n\"\n\"    1) It uses a large amount of RAM (on both viewer and server sides)\\n\"\n\"\\n\"\n\"    2) You can actually see the cached pixel data if you scroll down\\n\"\n\"       to it in your viewer; adjust your viewer's size to hide it.\\n\"\n\"\\n\"\n\"More info: http://www.karlrunge.com/x11vnc/faq.html#faq-client-caching\\n\"\n\"\\n\"\n\"waiting for connections:\\n\"\n;\n\nchar msg2[] = \n\"\\n\"\n\"******************************************************************************\\n\"\n\"Have you tried the x11vnc '-ncache' VNC client-side pixel caching feature yet?\\n\"\n\"\\n\"\n\"The scheme stores pixel data offscreen on the VNC viewer side for faster\\n\"\n\"retrieval.  It should work with any VNC viewer.  Try it by running:\\n\"\n\"\\n\"\n\"    x11vnc -ncache 10 ...\\n\"\n\"\\n\"\n\"One can also add -ncache_cr for smooth 'copyrect' window motion.\\n\"\n\"More info: http://www.karlrunge.com/x11vnc/faq.html#faq-client-caching\\n\"\n\"\\n\"\n;\n\n\tif (raw_fb_str && !macosx_console) {\n\t\treturn;\n\t}\n\tif (quiet) {\n\t\treturn;\n\t}\n\tif (remote_direct) {\n\t\treturn;\n\t}\n\tif (nofb) {\n\t\treturn;\n\t}\n#ifdef NO_NCACHE\n\treturn;\n#endif\n\n\tif (ncache == 0) {\n\t\tfprintf(stderr, \"%s\", msg2);\n\t\tncache0 = ncache = 0;\n\t} else {\n\t\tfprintf(stderr, msg, ncache);\n\t}\n}"
  },
  {
    "function_name": "store_homedir_passwd",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/x11vnc.c",
    "lines": "1746-1846",
    "snippet": "static void store_homedir_passwd(char *file) {\n\tchar str1[32], str2[32], *p, *h, *f;\n\tstruct stat sbuf;\n\n\tstr1[0] = '\\0';\n\tstr2[0] = '\\0';\n\t/* storepasswd */\n\tif (no_external_cmds || !cmd_ok(\"storepasswd\")) {\n\t\tfprintf(stderr, \"-nocmds cannot be used with -storepasswd\\n\");\n\t\texit(1);\n\t}\n\n\tfprintf(stderr, \"Enter VNC password: \");\n\tsystem(\"stty -echo\");\n\tif (fgets(str1, 32, stdin) == NULL) {\n\t\tperror(\"fgets\");\n\t\tsystem(\"stty echo\");\n\t\texit(1);\n\t}\n\tfprintf(stderr, \"\\n\");\n\n\tfprintf(stderr, \"Verify password:    \");\n\tif (fgets(str2, 32, stdin) == NULL) {\n\t\tperror(\"fgets\");\n\t\tsystem(\"stty echo\");\n\t\texit(1);\n\t}\n\tfprintf(stderr, \"\\n\");\n\tsystem(\"stty echo\");\n\n\tif ((p = strchr(str1, '\\n')) != NULL) {\n\t\t*p = '\\0';\n\t}\n\tif ((p = strchr(str2, '\\n')) != NULL) {\n\t\t*p = '\\0';\n\t}\n\tif (8 < strlen(str1)) {\n\t\t/* RFC6143 states: \"the password is truncated to eight characters\" */\n\t\t/* there's room for ambiguity (characters vs bytes) */\n\t\tfprintf(stderr, \"** password exceeds maximum 8 bytes.\\n\");\n\t\texit(1);\n\t}\n\tif (strcmp(str1, str2)) {\n\t\tfprintf(stderr, \"** passwords differ.\\n\");\n\t\texit(1);\n\t}\n\tif (str1[0] == '\\0') {\n\t\tfprintf(stderr, \"** no password supplied.\\n\");\n\t\texit(1);\n\t}\n\n\tif (file != NULL) {\n\t\tf = file;\n\t} else {\n\t\t\n\t\th = getenv(\"HOME\");\n\t\tif (! h) {\n\t\t\tfprintf(stderr, \"** $HOME not set.\\n\");\n\t\t\texit(1);\n\t\t}\n\n\t\tf = (char *) malloc(strlen(h) + strlen(\"/.vnc/passwd\") + 1);\n\t\tsprintf(f, \"%s/.vnc\", h);\n\n\t\tif (stat(f, &sbuf) != 0) {\n\t\t\tif (mkdir(f, 0755) != 0) {\n\t\t\t\tfprintf(stderr, \"** could not create directory %s\\n\", f);\n\t\t\t\tperror(\"mkdir\");\n\t\t\t\texit(1);\n\t\t\t}\n\t\t} else if (! S_ISDIR(sbuf.st_mode)) {\n\t\t\tfprintf(stderr, \"** not a directory %s\\n\", f);\n\t\t\texit(1);\n\t\t}\n\n\t\tsprintf(f, \"%s/.vnc/passwd\", h);\n\t}\n\tfprintf(stderr, \"Write password to %s?  [y]/n \", f);\n\n\tif (fgets(str2, 32, stdin) == NULL) {\n\t\tperror(\"fgets\");\n\t\texit(1);\n\t}\n\tif (str2[0] == 'n' || str2[0] == 'N') {\n\t\tfprintf(stderr, \"not creating password.\\n\");\n\t\texit(1);\n\t}\n\n\tif (rfbEncryptAndStorePasswd(str1, f) != 0) {\n\t\tfprintf(stderr, \"** error creating password: %s\\n\", f);\n\t\tperror(\"storepasswd\");\n\t\texit(1);\n\t}\n\tif (stat(f, &sbuf) != 0) {\n\t\tfprintf(stderr, \"** error creating password: %s\\n\", f);\n\t\tperror(\"stat\");\n\t\texit(1);\n\t}\n\tfprintf(stdout, \"Password written to: %s\\n\", f);\n\texit(0);\n}",
    "includes": [
      "#include \"xi2_devices.h\"",
      "#include \"solid.h\"",
      "#include \"pm.h\"",
      "#include \"selection.h\"",
      "#include \"sslhelper.h\"",
      "#include \"sslcmds.h\"",
      "#include \"inet.h\"",
      "#include \"unixpw.h\"",
      "#include \"rates.h\"",
      "#include \"connections.h\"",
      "#include \"screen.h\"",
      "#include \"userinput.h\"",
      "#include \"cursor.h\"",
      "#include \"pointer.h\"",
      "#include \"keyboard.h\"",
      "#include \"cleanup.h\"",
      "#include \"user.h\"",
      "#include \"help.h\"",
      "#include \"gui.h\"",
      "#include \"scan.h\"",
      "#include \"remote.h\"",
      "#include \"win_utils.h\"",
      "#include \"xkb_bell.h\"",
      "#include \"xrandr.h\"",
      "#include \"xinerama.h\"",
      "#include \"xevents.h\"",
      "#include \"xrecord.h\"",
      "#include \"xdamage.h\"",
      "#include \"xwrappers.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "0"
          ],
          "line": 1845
        },
        "resolved": true,
        "details": {
          "function_name": "clean_up_exit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/cleanup.c",
          "lines": "151-266",
          "snippet": "void clean_up_exit(int ret) {\n\tstatic int depth = 0;\n\texit_flag = 1;\n\n\tif (depth++ > 2) {\n\t\texit(ret);\n\t}\n\n\tif (icon_mode) {\n\t\tclean_icon_mode();\n\t}\n\n\t/* remove the shm areas: */\n\tclean_shm(0);\n\n\tstop_stunnel();\n\tif (use_openssl) {\n\t\tssl_helper_pid(0, 0);\t/* killall */\n\t}\n\n\tif (ssh_pid > 0) {\n\t\tkill(ssh_pid, SIGTERM);\n\t\tssh_pid = 0;\n\t}\n\n#ifdef MACOSX\n\tif (client_connect_file) {\n\t\tif (strstr(client_connect_file, \"/tmp/x11vnc-macosx-remote\")\n\t\t    == client_connect_file) {\n\t\t\tunlink(client_connect_file);\n\t\t}\n\t}\n\tif (macosx_console) {\n\t\tmacosxCG_fini();\n\t}\n#endif\n\n\tif (pipeinput_fh != NULL) {\n\t\tpclose(pipeinput_fh);\n\t\tpipeinput_fh = NULL;\n\t}\n\n\tshutdown_uinput();\n\n\tif (unix_sock) {\n\t\tif (unix_sock_fd >= 0) {\n\t\t\trfbLog(\"deleting unix sock: %s\\n\", unix_sock);\n\t\t\tclose(unix_sock_fd);\n\t\t\tunix_sock_fd = -1;\n\t\t\tunlink(unix_sock);\n\t\t}\n\t}\n\n\tif (! dpy) {\t/* raw_rb hack */\n\t\tif (rm_flagfile) {\n\t\t\tunlink(rm_flagfile);\n\t\t\trm_flagfile = NULL;\n\t\t}\n\t\texit(ret);\n\t}\n\n\t/* X keyboard cleanups */\n\tdelete_added_keycodes(0);\n\n\t/* remove all created XInput2 devices */\n\tif(use_multipointer)\n\t    removeAllMDs(dpy);\n\n\tif (clear_mods == 1) {\n\t\tclear_modifiers(0);\n\t} else if (clear_mods == 2) {\n\t\tclear_keys();\n\t} else if (clear_mods == 3) {\n\t\tclear_keys();\n\t\tclear_locks();\n\t}\n\n\tif (no_autorepeat) {\n\t\tautorepeat(1, 0);\n\t}\n\tif (use_solid_bg) {\n\t\tsolid_bg(1);\n\t}\n\tif (ncache || ncache0) {\n\t\tkde_no_animate(1);\n\t}\n\tX_LOCK;\n\tXTestDiscard_wr(dpy);\n#if HAVE_LIBXDAMAGE\n\tif (xdamage) {\n\t\tXDamageDestroy(dpy, xdamage);\n\t}\n#endif\n#if HAVE_LIBXTRAP\n\tif (trap_ctx) {\n\t\tXEFreeTC(trap_ctx);\n\t}\n#endif\n\t/* XXX rdpy_ctrl, etc. cannot close w/o blocking */\n\tXCloseDisplay_wr(dpy);\n\tX_UNLOCK;\n\n\tfflush(stderr);\n\n\tif (rm_flagfile) {\n\t\tunlink(rm_flagfile);\n\t\trm_flagfile = NULL;\n\t}\n\n\tif (avahi) {\n\t\tavahi_cleanup();\n\t\tfflush(stderr);\n\t}\n\n\texit(ret);\n}",
          "includes": [
            "#include \"xi2_devices.h\"",
            "#include \"uinput.h\"",
            "#include \"xevents.h\"",
            "#include \"xrecord.h\"",
            "#include \"screen.h\"",
            "#include \"avahi.h\"",
            "#include \"macosxCG.h\"",
            "#include \"macosx.h\"",
            "#include \"connections.h\"",
            "#include \"sslhelper.h\"",
            "#include \"sslcmds.h\"",
            "#include \"unixpw.h\"",
            "#include \"solid.h\"",
            "#include \"gui.h\"",
            "#include \"scan.h\"",
            "#include \"keyboard.h\"",
            "#include \"remote.h\"",
            "#include \"xdamage.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void clean_up_exit(int ret);",
            "int known_sigpipe_mode(char *s);",
            "static int exit_flag = 0;",
            "static void clean_icon_mode(void);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xi2_devices.h\"\n#include \"uinput.h\"\n#include \"xevents.h\"\n#include \"xrecord.h\"\n#include \"screen.h\"\n#include \"avahi.h\"\n#include \"macosxCG.h\"\n#include \"macosx.h\"\n#include \"connections.h\"\n#include \"sslhelper.h\"\n#include \"sslcmds.h\"\n#include \"unixpw.h\"\n#include \"solid.h\"\n#include \"gui.h\"\n#include \"scan.h\"\n#include \"keyboard.h\"\n#include \"remote.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nvoid clean_up_exit(int ret);\nint known_sigpipe_mode(char *s);\nstatic int exit_flag = 0;\nstatic void clean_icon_mode(void);\n\nvoid clean_up_exit(int ret) {\n\tstatic int depth = 0;\n\texit_flag = 1;\n\n\tif (depth++ > 2) {\n\t\texit(ret);\n\t}\n\n\tif (icon_mode) {\n\t\tclean_icon_mode();\n\t}\n\n\t/* remove the shm areas: */\n\tclean_shm(0);\n\n\tstop_stunnel();\n\tif (use_openssl) {\n\t\tssl_helper_pid(0, 0);\t/* killall */\n\t}\n\n\tif (ssh_pid > 0) {\n\t\tkill(ssh_pid, SIGTERM);\n\t\tssh_pid = 0;\n\t}\n\n#ifdef MACOSX\n\tif (client_connect_file) {\n\t\tif (strstr(client_connect_file, \"/tmp/x11vnc-macosx-remote\")\n\t\t    == client_connect_file) {\n\t\t\tunlink(client_connect_file);\n\t\t}\n\t}\n\tif (macosx_console) {\n\t\tmacosxCG_fini();\n\t}\n#endif\n\n\tif (pipeinput_fh != NULL) {\n\t\tpclose(pipeinput_fh);\n\t\tpipeinput_fh = NULL;\n\t}\n\n\tshutdown_uinput();\n\n\tif (unix_sock) {\n\t\tif (unix_sock_fd >= 0) {\n\t\t\trfbLog(\"deleting unix sock: %s\\n\", unix_sock);\n\t\t\tclose(unix_sock_fd);\n\t\t\tunix_sock_fd = -1;\n\t\t\tunlink(unix_sock);\n\t\t}\n\t}\n\n\tif (! dpy) {\t/* raw_rb hack */\n\t\tif (rm_flagfile) {\n\t\t\tunlink(rm_flagfile);\n\t\t\trm_flagfile = NULL;\n\t\t}\n\t\texit(ret);\n\t}\n\n\t/* X keyboard cleanups */\n\tdelete_added_keycodes(0);\n\n\t/* remove all created XInput2 devices */\n\tif(use_multipointer)\n\t    removeAllMDs(dpy);\n\n\tif (clear_mods == 1) {\n\t\tclear_modifiers(0);\n\t} else if (clear_mods == 2) {\n\t\tclear_keys();\n\t} else if (clear_mods == 3) {\n\t\tclear_keys();\n\t\tclear_locks();\n\t}\n\n\tif (no_autorepeat) {\n\t\tautorepeat(1, 0);\n\t}\n\tif (use_solid_bg) {\n\t\tsolid_bg(1);\n\t}\n\tif (ncache || ncache0) {\n\t\tkde_no_animate(1);\n\t}\n\tX_LOCK;\n\tXTestDiscard_wr(dpy);\n#if HAVE_LIBXDAMAGE\n\tif (xdamage) {\n\t\tXDamageDestroy(dpy, xdamage);\n\t}\n#endif\n#if HAVE_LIBXTRAP\n\tif (trap_ctx) {\n\t\tXEFreeTC(trap_ctx);\n\t}\n#endif\n\t/* XXX rdpy_ctrl, etc. cannot close w/o blocking */\n\tXCloseDisplay_wr(dpy);\n\tX_UNLOCK;\n\n\tfflush(stderr);\n\n\tif (rm_flagfile) {\n\t\tunlink(rm_flagfile);\n\t\trm_flagfile = NULL;\n\t}\n\n\tif (avahi) {\n\t\tavahi_cleanup();\n\t\tfflush(stderr);\n\t}\n\n\texit(ret);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stdout",
            "\"Password written to: %s\\n\"",
            "f"
          ],
          "line": 1844
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "perror",
          "args": [
            "\"stat\""
          ],
          "line": 1841
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"** error creating password: %s\\n\"",
            "f"
          ],
          "line": 1840
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "stat",
          "args": [
            "f",
            "&sbuf"
          ],
          "line": 1839
        },
        "resolved": true,
        "details": {
          "function_name": "grab_state",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/connections.c",
          "lines": "3178-3224",
          "snippet": "void grab_state(int *ptr_grabbed, int *kbd_grabbed) {\n\tint rcp, rck;\n\tdouble t0, t1;\n\tdouble ta, tb, tc;\n\t*ptr_grabbed = -1;\n\t*kbd_grabbed = -1;\n\n\tif (!dpy) {\n\t\treturn;\n\t}\n\t*ptr_grabbed = 0;\n\t*kbd_grabbed = 0;\n\n#if !NO_X11\n\tX_LOCK;\n\n\tXSync(dpy, False);\n\n\tta = t0 = dnow();\n\n\trcp = XGrabPointer(dpy, window, False, 0, GrabModeAsync, GrabModeAsync, None, None, CurrentTime);\n\tXUngrabPointer(dpy, CurrentTime);\n\n\ttb = dnow();\n\t\n\trck = XGrabKeyboard(dpy, window, False, GrabModeAsync, GrabModeAsync, CurrentTime);\n\tXUngrabKeyboard(dpy, CurrentTime);\n\n\ttc = dnow();\n\n\tXSync(dpy, False);\n\n\tt1 = dnow();\n\n\tX_UNLOCK;\n\tif (rcp == AlreadyGrabbed || rcp == GrabFrozen) {\n\t\t*ptr_grabbed = 1;\n\t}\n\tif (rck == AlreadyGrabbed || rck == GrabFrozen) {\n\t\t*kbd_grabbed = 1;\n\t}\n\tif (rc_npieces < 10) {\n\t\trfbLog(\"grab_state: checked %d,%d in %.6f sec (%.6f %.6f)\\n\",\n\t\t    *ptr_grabbed, *kbd_grabbed, t1-t0, tb-ta, tc-tb);\n\t}\n#endif\n}",
          "includes": [
            "#include \"xi2_devices.h\"",
            "#include \"xrandr.h\"",
            "#include \"pointer.h\"",
            "#include \"userinput.h\"",
            "#include \"macosxCG.h\"",
            "#include \"macosx.h\"",
            "#include \"win_utils.h\"",
            "#include \"xevents.h\"",
            "#include \"xwrappers.h\"",
            "#include \"sslhelper.h\"",
            "#include \"sslcmds.h\"",
            "#include \"scan.h\"",
            "#include \"user.h\"",
            "#include \"unixpw.h\"",
            "#include \"screen.h\"",
            "#include \"rates.h\"",
            "#include \"solid.h\"",
            "#include \"gui.h\"",
            "#include \"cleanup.h\"",
            "#include \"keyboard.h\"",
            "#include \"remote.h\"",
            "#include \"inet.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void grab_state(int *ptr_grabbed, int *kbd_grabbed);",
            "extern int rc_npieces;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xi2_devices.h\"\n#include \"xrandr.h\"\n#include \"pointer.h\"\n#include \"userinput.h\"\n#include \"macosxCG.h\"\n#include \"macosx.h\"\n#include \"win_utils.h\"\n#include \"xevents.h\"\n#include \"xwrappers.h\"\n#include \"sslhelper.h\"\n#include \"sslcmds.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"unixpw.h\"\n#include \"screen.h\"\n#include \"rates.h\"\n#include \"solid.h\"\n#include \"gui.h\"\n#include \"cleanup.h\"\n#include \"keyboard.h\"\n#include \"remote.h\"\n#include \"inet.h\"\n#include \"x11vnc.h\"\n\nvoid grab_state(int *ptr_grabbed, int *kbd_grabbed);\nextern int rc_npieces;\n\nvoid grab_state(int *ptr_grabbed, int *kbd_grabbed) {\n\tint rcp, rck;\n\tdouble t0, t1;\n\tdouble ta, tb, tc;\n\t*ptr_grabbed = -1;\n\t*kbd_grabbed = -1;\n\n\tif (!dpy) {\n\t\treturn;\n\t}\n\t*ptr_grabbed = 0;\n\t*kbd_grabbed = 0;\n\n#if !NO_X11\n\tX_LOCK;\n\n\tXSync(dpy, False);\n\n\tta = t0 = dnow();\n\n\trcp = XGrabPointer(dpy, window, False, 0, GrabModeAsync, GrabModeAsync, None, None, CurrentTime);\n\tXUngrabPointer(dpy, CurrentTime);\n\n\ttb = dnow();\n\t\n\trck = XGrabKeyboard(dpy, window, False, GrabModeAsync, GrabModeAsync, CurrentTime);\n\tXUngrabKeyboard(dpy, CurrentTime);\n\n\ttc = dnow();\n\n\tXSync(dpy, False);\n\n\tt1 = dnow();\n\n\tX_UNLOCK;\n\tif (rcp == AlreadyGrabbed || rcp == GrabFrozen) {\n\t\t*ptr_grabbed = 1;\n\t}\n\tif (rck == AlreadyGrabbed || rck == GrabFrozen) {\n\t\t*kbd_grabbed = 1;\n\t}\n\tif (rc_npieces < 10) {\n\t\trfbLog(\"grab_state: checked %d,%d in %.6f sec (%.6f %.6f)\\n\",\n\t\t    *ptr_grabbed, *kbd_grabbed, t1-t0, tb-ta, tc-tb);\n\t}\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "perror",
          "args": [
            "\"storepasswd\""
          ],
          "line": 1836
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"** error creating password: %s\\n\"",
            "f"
          ],
          "line": 1835
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbEncryptAndStorePasswd",
          "args": [
            "str1",
            "f"
          ],
          "line": 1834
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"not creating password.\\n\""
          ],
          "line": 1830
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "perror",
          "args": [
            "\"fgets\""
          ],
          "line": 1826
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fgets",
          "args": [
            "str2",
            "32",
            "stdin"
          ],
          "line": 1825
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Write password to %s?  [y]/n \"",
            "f"
          ],
          "line": 1823
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "f",
            "\"%s/.vnc/passwd\"",
            "h"
          ],
          "line": 1821
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"** not a directory %s\\n\"",
            "f"
          ],
          "line": 1817
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISDIR",
          "args": [
            "sbuf.st_mode"
          ],
          "line": 1816
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "perror",
          "args": [
            "\"mkdir\""
          ],
          "line": 1813
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"** could not create directory %s\\n\"",
            "f"
          ],
          "line": 1812
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mkdir",
          "args": [
            "f",
            "0755"
          ],
          "line": 1811
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "f",
            "\"%s/.vnc\"",
            "h"
          ],
          "line": 1808
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "strlen(h) + strlen(\"/.vnc/passwd\") + 1"
          ],
          "line": 1807
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "\"/.vnc/passwd\""
          ],
          "line": 1807
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "h"
          ],
          "line": 1807
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"** $HOME not set.\\n\""
          ],
          "line": 1803
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getenv",
          "args": [
            "\"HOME\""
          ],
          "line": 1801
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"** no password supplied.\\n\""
          ],
          "line": 1793
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"** passwords differ.\\n\""
          ],
          "line": 1789
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "str1",
            "str2"
          ],
          "line": 1788
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"** password exceeds maximum 8 bytes.\\n\""
          ],
          "line": 1785
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "str1"
          ],
          "line": 1782
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "str2",
            "'\\n'"
          ],
          "line": 1779
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "str1",
            "'\\n'"
          ],
          "line": 1776
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "system",
          "args": [
            "\"stty echo\""
          ],
          "line": 1774
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"\\n\""
          ],
          "line": 1773
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "system",
          "args": [
            "\"stty echo\""
          ],
          "line": 1770
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "perror",
          "args": [
            "\"fgets\""
          ],
          "line": 1769
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fgets",
          "args": [
            "str2",
            "32",
            "stdin"
          ],
          "line": 1768
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Verify password:    \""
          ],
          "line": 1767
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"\\n\""
          ],
          "line": 1765
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "system",
          "args": [
            "\"stty echo\""
          ],
          "line": 1762
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "perror",
          "args": [
            "\"fgets\""
          ],
          "line": 1761
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fgets",
          "args": [
            "str1",
            "32",
            "stdin"
          ],
          "line": 1760
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "system",
          "args": [
            "\"stty -echo\""
          ],
          "line": 1759
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Enter VNC password: \""
          ],
          "line": 1758
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"-nocmds cannot be used with -storepasswd\\n\""
          ],
          "line": 1754
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cmd_ok",
          "args": [
            "\"storepasswd\""
          ],
          "line": 1753
        },
        "resolved": true,
        "details": {
          "function_name": "cmd_ok",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/connections.c",
          "lines": "436-460",
          "snippet": "int cmd_ok(char *cmd) {\n\tchar *p, *str;\n\tif (no_external_cmds) {\n\t\treturn 0;\n\t}\n\tif (! cmd || cmd[0] == '\\0') {\n\t\treturn 0;\n\t}\n\tif (! allowed_external_cmds) {\n\t\t/* default, allow any (overridden by -nocmds) */\n\t\treturn 1;\n\t}\n\n\tstr = strdup(allowed_external_cmds);\n\tp = strtok(str, \",\");\n\twhile (p) {\n\t\tif (!strcmp(p, cmd)) {\n\t\t\tfree(str);\n\t\t\treturn 1;\n\t\t}\n\t\tp = strtok(NULL, \",\");\n\t}\n\tfree(str);\n\treturn 0;\n}",
          "includes": [
            "#include \"xi2_devices.h\"",
            "#include \"xrandr.h\"",
            "#include \"pointer.h\"",
            "#include \"userinput.h\"",
            "#include \"macosxCG.h\"",
            "#include \"macosx.h\"",
            "#include \"win_utils.h\"",
            "#include \"xevents.h\"",
            "#include \"xwrappers.h\"",
            "#include \"sslhelper.h\"",
            "#include \"sslcmds.h\"",
            "#include \"scan.h\"",
            "#include \"user.h\"",
            "#include \"unixpw.h\"",
            "#include \"screen.h\"",
            "#include \"rates.h\"",
            "#include \"solid.h\"",
            "#include \"gui.h\"",
            "#include \"cleanup.h\"",
            "#include \"keyboard.h\"",
            "#include \"remote.h\"",
            "#include \"inet.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void close_clients(char *str);",
            "void set_client_input(char *str);",
            "int cmd_ok(char *cmd);",
            "void reverse_connect(char *str);",
            "void set_vnc_connect_prop(char *str);",
            "void set_x11vnc_remote_prop(char *str);",
            "void send_client_info(char *str);",
            "static rfbClientPtr *client_match(char *str);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xi2_devices.h\"\n#include \"xrandr.h\"\n#include \"pointer.h\"\n#include \"userinput.h\"\n#include \"macosxCG.h\"\n#include \"macosx.h\"\n#include \"win_utils.h\"\n#include \"xevents.h\"\n#include \"xwrappers.h\"\n#include \"sslhelper.h\"\n#include \"sslcmds.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"unixpw.h\"\n#include \"screen.h\"\n#include \"rates.h\"\n#include \"solid.h\"\n#include \"gui.h\"\n#include \"cleanup.h\"\n#include \"keyboard.h\"\n#include \"remote.h\"\n#include \"inet.h\"\n#include \"x11vnc.h\"\n\nvoid close_clients(char *str);\nvoid set_client_input(char *str);\nint cmd_ok(char *cmd);\nvoid reverse_connect(char *str);\nvoid set_vnc_connect_prop(char *str);\nvoid set_x11vnc_remote_prop(char *str);\nvoid send_client_info(char *str);\nstatic rfbClientPtr *client_match(char *str);\n\nint cmd_ok(char *cmd) {\n\tchar *p, *str;\n\tif (no_external_cmds) {\n\t\treturn 0;\n\t}\n\tif (! cmd || cmd[0] == '\\0') {\n\t\treturn 0;\n\t}\n\tif (! allowed_external_cmds) {\n\t\t/* default, allow any (overridden by -nocmds) */\n\t\treturn 1;\n\t}\n\n\tstr = strdup(allowed_external_cmds);\n\tp = strtok(str, \",\");\n\twhile (p) {\n\t\tif (!strcmp(p, cmd)) {\n\t\t\tfree(str);\n\t\t\treturn 1;\n\t\t}\n\t\tp = strtok(NULL, \",\");\n\t}\n\tfree(str);\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xi2_devices.h\"\n#include \"solid.h\"\n#include \"pm.h\"\n#include \"selection.h\"\n#include \"sslhelper.h\"\n#include \"sslcmds.h\"\n#include \"inet.h\"\n#include \"unixpw.h\"\n#include \"rates.h\"\n#include \"connections.h\"\n#include \"screen.h\"\n#include \"userinput.h\"\n#include \"cursor.h\"\n#include \"pointer.h\"\n#include \"keyboard.h\"\n#include \"cleanup.h\"\n#include \"user.h\"\n#include \"help.h\"\n#include \"gui.h\"\n#include \"scan.h\"\n#include \"remote.h\"\n#include \"win_utils.h\"\n#include \"xkb_bell.h\"\n#include \"xrandr.h\"\n#include \"xinerama.h\"\n#include \"xevents.h\"\n#include \"xrecord.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nstatic void store_homedir_passwd(char *file) {\n\tchar str1[32], str2[32], *p, *h, *f;\n\tstruct stat sbuf;\n\n\tstr1[0] = '\\0';\n\tstr2[0] = '\\0';\n\t/* storepasswd */\n\tif (no_external_cmds || !cmd_ok(\"storepasswd\")) {\n\t\tfprintf(stderr, \"-nocmds cannot be used with -storepasswd\\n\");\n\t\texit(1);\n\t}\n\n\tfprintf(stderr, \"Enter VNC password: \");\n\tsystem(\"stty -echo\");\n\tif (fgets(str1, 32, stdin) == NULL) {\n\t\tperror(\"fgets\");\n\t\tsystem(\"stty echo\");\n\t\texit(1);\n\t}\n\tfprintf(stderr, \"\\n\");\n\n\tfprintf(stderr, \"Verify password:    \");\n\tif (fgets(str2, 32, stdin) == NULL) {\n\t\tperror(\"fgets\");\n\t\tsystem(\"stty echo\");\n\t\texit(1);\n\t}\n\tfprintf(stderr, \"\\n\");\n\tsystem(\"stty echo\");\n\n\tif ((p = strchr(str1, '\\n')) != NULL) {\n\t\t*p = '\\0';\n\t}\n\tif ((p = strchr(str2, '\\n')) != NULL) {\n\t\t*p = '\\0';\n\t}\n\tif (8 < strlen(str1)) {\n\t\t/* RFC6143 states: \"the password is truncated to eight characters\" */\n\t\t/* there's room for ambiguity (characters vs bytes) */\n\t\tfprintf(stderr, \"** password exceeds maximum 8 bytes.\\n\");\n\t\texit(1);\n\t}\n\tif (strcmp(str1, str2)) {\n\t\tfprintf(stderr, \"** passwords differ.\\n\");\n\t\texit(1);\n\t}\n\tif (str1[0] == '\\0') {\n\t\tfprintf(stderr, \"** no password supplied.\\n\");\n\t\texit(1);\n\t}\n\n\tif (file != NULL) {\n\t\tf = file;\n\t} else {\n\t\t\n\t\th = getenv(\"HOME\");\n\t\tif (! h) {\n\t\t\tfprintf(stderr, \"** $HOME not set.\\n\");\n\t\t\texit(1);\n\t\t}\n\n\t\tf = (char *) malloc(strlen(h) + strlen(\"/.vnc/passwd\") + 1);\n\t\tsprintf(f, \"%s/.vnc\", h);\n\n\t\tif (stat(f, &sbuf) != 0) {\n\t\t\tif (mkdir(f, 0755) != 0) {\n\t\t\t\tfprintf(stderr, \"** could not create directory %s\\n\", f);\n\t\t\t\tperror(\"mkdir\");\n\t\t\t\texit(1);\n\t\t\t}\n\t\t} else if (! S_ISDIR(sbuf.st_mode)) {\n\t\t\tfprintf(stderr, \"** not a directory %s\\n\", f);\n\t\t\texit(1);\n\t\t}\n\n\t\tsprintf(f, \"%s/.vnc/passwd\", h);\n\t}\n\tfprintf(stderr, \"Write password to %s?  [y]/n \", f);\n\n\tif (fgets(str2, 32, stdin) == NULL) {\n\t\tperror(\"fgets\");\n\t\texit(1);\n\t}\n\tif (str2[0] == 'n' || str2[0] == 'N') {\n\t\tfprintf(stderr, \"not creating password.\\n\");\n\t\texit(1);\n\t}\n\n\tif (rfbEncryptAndStorePasswd(str1, f) != 0) {\n\t\tfprintf(stderr, \"** error creating password: %s\\n\", f);\n\t\tperror(\"storepasswd\");\n\t\texit(1);\n\t}\n\tif (stat(f, &sbuf) != 0) {\n\t\tfprintf(stderr, \"** error creating password: %s\\n\", f);\n\t\tperror(\"stat\");\n\t\texit(1);\n\t}\n\tfprintf(stdout, \"Password written to: %s\\n\", f);\n\texit(0);\n}"
  },
  {
    "function_name": "check_appshare_mode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/x11vnc.c",
    "lines": "1731-1744",
    "snippet": "static void check_appshare_mode(int argc, char* argv[]) {\n\tint i;\n\n\tfor (i=1; i < argc; i++) {\n\t\tchar *p = argv[i];\n\t\tif (strstr(p, \"--\") == p) {\n\t\t\tp++;\n\t\t}\n\t\tif (strstr(p, \"-appshare\") == p) {\n\t\t\tappshare_main(argc, argv);\n\t\t\texit(0);\n\t\t}\n\t}\n}",
    "includes": [
      "#include \"xi2_devices.h\"",
      "#include \"solid.h\"",
      "#include \"pm.h\"",
      "#include \"selection.h\"",
      "#include \"sslhelper.h\"",
      "#include \"sslcmds.h\"",
      "#include \"inet.h\"",
      "#include \"unixpw.h\"",
      "#include \"rates.h\"",
      "#include \"connections.h\"",
      "#include \"screen.h\"",
      "#include \"userinput.h\"",
      "#include \"cursor.h\"",
      "#include \"pointer.h\"",
      "#include \"keyboard.h\"",
      "#include \"cleanup.h\"",
      "#include \"user.h\"",
      "#include \"help.h\"",
      "#include \"gui.h\"",
      "#include \"scan.h\"",
      "#include \"remote.h\"",
      "#include \"win_utils.h\"",
      "#include \"xkb_bell.h\"",
      "#include \"xrandr.h\"",
      "#include \"xinerama.h\"",
      "#include \"xevents.h\"",
      "#include \"xrecord.h\"",
      "#include \"xdamage.h\"",
      "#include \"xwrappers.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void check_rcfile(int argc, char **argv);",
      "static void immediate_switch_user(int argc, char* argv[]);",
      "static void check_loop_mode(int argc, char* argv[], int force);",
      "static void check_appshare_mode(int argc, char* argv[]);",
      "extern int appshare_main(int argc, char* argv[]);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "0"
          ],
          "line": 1741
        },
        "resolved": true,
        "details": {
          "function_name": "clean_up_exit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/cleanup.c",
          "lines": "151-266",
          "snippet": "void clean_up_exit(int ret) {\n\tstatic int depth = 0;\n\texit_flag = 1;\n\n\tif (depth++ > 2) {\n\t\texit(ret);\n\t}\n\n\tif (icon_mode) {\n\t\tclean_icon_mode();\n\t}\n\n\t/* remove the shm areas: */\n\tclean_shm(0);\n\n\tstop_stunnel();\n\tif (use_openssl) {\n\t\tssl_helper_pid(0, 0);\t/* killall */\n\t}\n\n\tif (ssh_pid > 0) {\n\t\tkill(ssh_pid, SIGTERM);\n\t\tssh_pid = 0;\n\t}\n\n#ifdef MACOSX\n\tif (client_connect_file) {\n\t\tif (strstr(client_connect_file, \"/tmp/x11vnc-macosx-remote\")\n\t\t    == client_connect_file) {\n\t\t\tunlink(client_connect_file);\n\t\t}\n\t}\n\tif (macosx_console) {\n\t\tmacosxCG_fini();\n\t}\n#endif\n\n\tif (pipeinput_fh != NULL) {\n\t\tpclose(pipeinput_fh);\n\t\tpipeinput_fh = NULL;\n\t}\n\n\tshutdown_uinput();\n\n\tif (unix_sock) {\n\t\tif (unix_sock_fd >= 0) {\n\t\t\trfbLog(\"deleting unix sock: %s\\n\", unix_sock);\n\t\t\tclose(unix_sock_fd);\n\t\t\tunix_sock_fd = -1;\n\t\t\tunlink(unix_sock);\n\t\t}\n\t}\n\n\tif (! dpy) {\t/* raw_rb hack */\n\t\tif (rm_flagfile) {\n\t\t\tunlink(rm_flagfile);\n\t\t\trm_flagfile = NULL;\n\t\t}\n\t\texit(ret);\n\t}\n\n\t/* X keyboard cleanups */\n\tdelete_added_keycodes(0);\n\n\t/* remove all created XInput2 devices */\n\tif(use_multipointer)\n\t    removeAllMDs(dpy);\n\n\tif (clear_mods == 1) {\n\t\tclear_modifiers(0);\n\t} else if (clear_mods == 2) {\n\t\tclear_keys();\n\t} else if (clear_mods == 3) {\n\t\tclear_keys();\n\t\tclear_locks();\n\t}\n\n\tif (no_autorepeat) {\n\t\tautorepeat(1, 0);\n\t}\n\tif (use_solid_bg) {\n\t\tsolid_bg(1);\n\t}\n\tif (ncache || ncache0) {\n\t\tkde_no_animate(1);\n\t}\n\tX_LOCK;\n\tXTestDiscard_wr(dpy);\n#if HAVE_LIBXDAMAGE\n\tif (xdamage) {\n\t\tXDamageDestroy(dpy, xdamage);\n\t}\n#endif\n#if HAVE_LIBXTRAP\n\tif (trap_ctx) {\n\t\tXEFreeTC(trap_ctx);\n\t}\n#endif\n\t/* XXX rdpy_ctrl, etc. cannot close w/o blocking */\n\tXCloseDisplay_wr(dpy);\n\tX_UNLOCK;\n\n\tfflush(stderr);\n\n\tif (rm_flagfile) {\n\t\tunlink(rm_flagfile);\n\t\trm_flagfile = NULL;\n\t}\n\n\tif (avahi) {\n\t\tavahi_cleanup();\n\t\tfflush(stderr);\n\t}\n\n\texit(ret);\n}",
          "includes": [
            "#include \"xi2_devices.h\"",
            "#include \"uinput.h\"",
            "#include \"xevents.h\"",
            "#include \"xrecord.h\"",
            "#include \"screen.h\"",
            "#include \"avahi.h\"",
            "#include \"macosxCG.h\"",
            "#include \"macosx.h\"",
            "#include \"connections.h\"",
            "#include \"sslhelper.h\"",
            "#include \"sslcmds.h\"",
            "#include \"unixpw.h\"",
            "#include \"solid.h\"",
            "#include \"gui.h\"",
            "#include \"scan.h\"",
            "#include \"keyboard.h\"",
            "#include \"remote.h\"",
            "#include \"xdamage.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void clean_up_exit(int ret);",
            "int known_sigpipe_mode(char *s);",
            "static int exit_flag = 0;",
            "static void clean_icon_mode(void);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xi2_devices.h\"\n#include \"uinput.h\"\n#include \"xevents.h\"\n#include \"xrecord.h\"\n#include \"screen.h\"\n#include \"avahi.h\"\n#include \"macosxCG.h\"\n#include \"macosx.h\"\n#include \"connections.h\"\n#include \"sslhelper.h\"\n#include \"sslcmds.h\"\n#include \"unixpw.h\"\n#include \"solid.h\"\n#include \"gui.h\"\n#include \"scan.h\"\n#include \"keyboard.h\"\n#include \"remote.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nvoid clean_up_exit(int ret);\nint known_sigpipe_mode(char *s);\nstatic int exit_flag = 0;\nstatic void clean_icon_mode(void);\n\nvoid clean_up_exit(int ret) {\n\tstatic int depth = 0;\n\texit_flag = 1;\n\n\tif (depth++ > 2) {\n\t\texit(ret);\n\t}\n\n\tif (icon_mode) {\n\t\tclean_icon_mode();\n\t}\n\n\t/* remove the shm areas: */\n\tclean_shm(0);\n\n\tstop_stunnel();\n\tif (use_openssl) {\n\t\tssl_helper_pid(0, 0);\t/* killall */\n\t}\n\n\tif (ssh_pid > 0) {\n\t\tkill(ssh_pid, SIGTERM);\n\t\tssh_pid = 0;\n\t}\n\n#ifdef MACOSX\n\tif (client_connect_file) {\n\t\tif (strstr(client_connect_file, \"/tmp/x11vnc-macosx-remote\")\n\t\t    == client_connect_file) {\n\t\t\tunlink(client_connect_file);\n\t\t}\n\t}\n\tif (macosx_console) {\n\t\tmacosxCG_fini();\n\t}\n#endif\n\n\tif (pipeinput_fh != NULL) {\n\t\tpclose(pipeinput_fh);\n\t\tpipeinput_fh = NULL;\n\t}\n\n\tshutdown_uinput();\n\n\tif (unix_sock) {\n\t\tif (unix_sock_fd >= 0) {\n\t\t\trfbLog(\"deleting unix sock: %s\\n\", unix_sock);\n\t\t\tclose(unix_sock_fd);\n\t\t\tunix_sock_fd = -1;\n\t\t\tunlink(unix_sock);\n\t\t}\n\t}\n\n\tif (! dpy) {\t/* raw_rb hack */\n\t\tif (rm_flagfile) {\n\t\t\tunlink(rm_flagfile);\n\t\t\trm_flagfile = NULL;\n\t\t}\n\t\texit(ret);\n\t}\n\n\t/* X keyboard cleanups */\n\tdelete_added_keycodes(0);\n\n\t/* remove all created XInput2 devices */\n\tif(use_multipointer)\n\t    removeAllMDs(dpy);\n\n\tif (clear_mods == 1) {\n\t\tclear_modifiers(0);\n\t} else if (clear_mods == 2) {\n\t\tclear_keys();\n\t} else if (clear_mods == 3) {\n\t\tclear_keys();\n\t\tclear_locks();\n\t}\n\n\tif (no_autorepeat) {\n\t\tautorepeat(1, 0);\n\t}\n\tif (use_solid_bg) {\n\t\tsolid_bg(1);\n\t}\n\tif (ncache || ncache0) {\n\t\tkde_no_animate(1);\n\t}\n\tX_LOCK;\n\tXTestDiscard_wr(dpy);\n#if HAVE_LIBXDAMAGE\n\tif (xdamage) {\n\t\tXDamageDestroy(dpy, xdamage);\n\t}\n#endif\n#if HAVE_LIBXTRAP\n\tif (trap_ctx) {\n\t\tXEFreeTC(trap_ctx);\n\t}\n#endif\n\t/* XXX rdpy_ctrl, etc. cannot close w/o blocking */\n\tXCloseDisplay_wr(dpy);\n\tX_UNLOCK;\n\n\tfflush(stderr);\n\n\tif (rm_flagfile) {\n\t\tunlink(rm_flagfile);\n\t\trm_flagfile = NULL;\n\t}\n\n\tif (avahi) {\n\t\tavahi_cleanup();\n\t\tfflush(stderr);\n\t}\n\n\texit(ret);\n}"
        }
      },
      {
        "call_info": {
          "callee": "appshare_main",
          "args": [
            "argc",
            "argv"
          ],
          "line": 1740
        },
        "resolved": true,
        "details": {
          "function_name": "appshare_main",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/appshare.c",
          "lines": "1889-2123",
          "snippet": "int appshare_main(int argc, char *argv[]) {\n\tint i;\n\tchar *app_str = NULL;\n\tchar *dpy_str = NULL;\n\tlong xselectinput = 0;\n#if NO_X11\n\texiter(\"not compiled with X11\\n\", 1);\n#else\n\tfor (i=0; i < WMAX; i++) {\n\t\twatch[i] = None;\n\t\tstate[i] = 0;\n\t}\n\tfor (i=0; i < AMAX; i++) {\n\t\tapps[i]  = None;\n\t}\n\tfor (i=0; i < CMAX; i++) {\n\t\tclients[i] = NULL;\n\t}\n\n\tx11vnc = strdup(argv[0]);\n\n\tfor (i=1; i < argc; i++) {\n\t\tint end = (i == argc-1) ? 1 : 0;\n\t\tchar *s = argv[i];\n\t\tif (strstr(s, \"--\") == s) {\n\t\t\ts++;\n\t\t}\n\n\t\tif (!strcmp(s, \"-h\") || !strcmp(s, \"-help\")) {\n\t\t\tfprintf(stdout, \"%s\", usage);\n\t\t\texit(0);\n\t\t} else if (!strcmp(s, \"-id\")) {\n\t\t\tid_opt = \"-id\";\n\t\t\tif (end) exiter(\"no -id value supplied\\n\", 1);\n\t\t\tapp_str = strdup(argv[++i]);\n\t\t} else if (!strcmp(s, \"-sid\")) {\n\t\t\tid_opt = \"-sid\";\n\t\t\tif (end) exiter(\"no -sid value supplied\\n\", 1);\n\t\t\tapp_str = strdup(argv[++i]);\n\t\t} else if (!strcmp(s, \"-connect\") || !strcmp(s, \"-connect_or_exit\") || !strcmp(s, \"-coe\")) {\n\t\t\tif (end) exiter(\"no -connect value supplied\\n\", 1);\n\t\t\tconnect_to = strdup(argv[++i]);\n\t\t} else if (!strcmp(s, \"-control\")) {\n\t\t\tif (end) exiter(\"no -control value supplied\\n\", 1);\n\t\t\tcontrol = strdup(argv[++i]);\n\t\t\tif (!strcmp(control, \"shell\")) {\n\t\t\t\tfree(control);\n\t\t\t\tcontrol = strdup(\"internal\");\n\t\t\t\tshell = 1;\n\t\t\t}\n\t\t} else if (!strcmp(s, \"-trackdir\")) {\n\t\t\tif (end) exiter(\"no -trackdir value supplied\\n\", 1);\n\t\t\ttrackdir = strdup(argv[++i]);\n\t\t} else if (!strcmp(s, \"-display\")) {\n\t\t\tif (end) exiter(\"no -display value supplied\\n\", 1);\n\t\t\tdpy_str = strdup(argv[++i]);\n\t\t\tset_env(\"DISPLAY\", dpy_str);\n\t\t} else if (!strcmp(s, \"-delay\")) {\n\t\t\tif (end) exiter(\"no -delay value supplied\\n\", 1);\n\t\t\thelper_delay = atof(argv[++i]);\n\t\t} else if (!strcmp(s, \"-args\")) {\n\t\t\tif (end) exiter(\"no -args value supplied\\n\", 1);\n\t\t\tx11vnc_args = strdup(argv[++i]);\n\t\t} else if (!strcmp(s, \"-env\")) {\n\t\t\tif (end) exiter(\"no -env value supplied\\n\", 1);\n\t\t\tputenv(argv[++i]);\n\t\t} else if (!strcmp(s, \"-debug\")) {\n\t\t\tappshare_debug++;\n\t\t} else if (!strcmp(s, \"-showmenus\")) {\n\t\t\tskip_menus = 0;\n\t\t} else if (!strcmp(s, \"-noexit\")) {\n\t\t\texit_no_app_win = 0;\n\t\t} else if (!strcmp(s, \"-shell\")) {\n\t\t\tshell = 1;\n\t\t} else if (!strcmp(s, \"-nocmds\") || !strcmp(s, \"-safer\")) {\n\t\t\tfprintf(stderr, \"ignoring %s in -appshare mode.\\n\", s);\n\t\t} else if (!strcmp(s, \"-appshare\")) {\n\t\t\t;\n\t\t} else {\n\t\t\tfprintf(stderr, \"unrecognized 'x11vnc -appshare' option: %s\\n\", s);\n\t\t\texiter(\"\", 1);\n\t\t}\n\t}\n\n\tif (getenv(\"X11VNC_APPSHARE_DEBUG\")) {\n\t\tappshare_debug = atoi(getenv(\"X11VNC_APPSHARE_DEBUG\"));\n\t}\n\n\t/* let user override name for multiple instances: */\n\tif (getenv(\"X11VNC_APPSHARE_COMMAND_PROPNAME\")) {\n\t\tcmd_atom_str = strdup(getenv(\"X11VNC_APPSHARE_COMMAND_PROPNAME\"));\n\t}\n\tif (getenv(\"X11VNC_APPSHARE_TICKER_PROPNAME\")) {\n\t\tticker_atom_str = strdup(getenv(\"X11VNC_APPSHARE_TICKER_PROPNAME\"));\n\t}\n\n\tif (shell) {\n\t\tif (!control || strcmp(control, \"internal\")) {\n\t\t\texiter(\"mode -shell requires '-control internal'\\n\", 1);\n\t\t}\n\t}\n\n\tif (connect_to == NULL && control != NULL) {\n\t\tstruct stat sb;\n\t\tif (stat(control, &sb) == 0) {\n\t\t\tint len = 100 + sb.st_size;\n\t\t\tFILE *f = fopen(control, \"r\");\n\n\t\t\tif (f) {\n\t\t\t\tchar *line = (char *) malloc(len);\n\t\t\t\tconnect_to = (char *) calloc(2 * len, 1);\n\t\t\t\twhile (fgets(line, len, f) != NULL) {\n\t\t\t\t\tchar *q = strchr(line, '\\n');\n\t\t\t\t\tif (q) *q = '\\0';\n\t\t\t\t\tq = lblanks(line);\n\t\t\t\t\tif (q[0] == '#') {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tif (connect_to[0] != '\\0') {\n\t\t\t\t\t\tstrcat(connect_to, \",\");\n\t\t\t\t\t}\n\t\t\t\t\tstrcat(connect_to, q);\n\t\t\t\t}\n\t\t\t\tfclose(f);\n\t\t\t}\n\t\t\tfprintf(stderr, \"set -connect to: %s\\n\", connect_to);\n\t\t}\n\t}\n\tif (0 && connect_to == NULL && control == NULL) {\n\t\texiter(\"no -connect host or -control file specified.\\n\", 1);\n\t}\n\n\tif (control) {\n\t\tpid_t pid;\n\t\tparent_pid = getpid();\n\t\tpid = fork();\n\t\tif (pid == (pid_t) -1) {\n\t\t\t;\n\t\t} else if (pid == 0) {\n\t\t\tbe_helper_pid(dpy_str);\n\t\t\texit(0);\n\t\t} else {\n\t\t\thelper_pid = pid;\n\t\t}\n\t}\n\n\tdpy = XOpenDisplay(dpy_str);\n\tif (!dpy) {\n\t\texiter(\"cannot open display\\n\", 1);\n\t}\n\n\troot = DefaultRootWindow(dpy);\n\n\txselectinput = SubstructureNotifyMask;\n\tif (helper_pid > 0) {\n\t\tticker_atom = XInternAtom(dpy, ticker_atom_str, False);\n\t\txselectinput |= PropertyChangeMask;\n\t}\n\tXSelectInput(dpy, root, xselectinput);\n\n\tcmd_atom = XInternAtom(dpy, cmd_atom_str, False);\n\n\tinit_cmask();\n\n\tsprintf(unique_tag, \"X11VNC_APPSHARE_TAG=%d-tag\", getpid());\n\n\tstart_time = dnow();\n\n\tif (app_str == NULL) {\n\t\texiter(\"no -id/-sid window specified.\\n\", 1);\n\t} else {\n\t\tchar *p, *str = strdup(app_str);\n\t\tchar *alist[AMAX];\n\t\tint i, n = 0;\n\n\t\tp = strtok(str, \",\");\n\t\twhile (p) {\n\t\t\tif (n >= AMAX) {\n\t\t\t\tfprintf(stderr, \"ran out of app slots: %s\\n\", app_str);\n\t\t\t\texiter(\"\", 1);\n\t\t\t}\n\t\t\talist[n++] = strdup(p);\n\t\t\tp = strtok(NULL, \",\");\n\t\t}\n\t\tfree(str);\n\n\t\tfor (i=0; i < n; i++) {\n\t\t\tWindow app = None;\n\t\t\tp = alist[i];\n\t\t\tapp = parse_win(p);\n\t\t\tfree(p);\n\n\t\t\tif (app != None) {\n\t\t\t\tif (!ours(app)) {\n\t\t\t\t\tadd_app(app);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tset_trackdir();\n\n\tsignal(SIGINT,  appshare_cleanup);\n\tsignal(SIGTERM, appshare_cleanup);\n\n\trfbLogEnable(0);\n\n\tif (connect_to) {\n\t\tchar *p, *str = strdup(connect_to);\n\t\tint n = 0;\n\t\tp = strtok(str, \",\");\n\t\twhile (p) {\n\t\t\tclients[n++] = strdup(p);\n\t\t\tp = strtok(NULL, \",\");\n\t\t}\n\t\tfree(str);\n\t} else {\n\t\tconnect_to = strdup(\"\");\n\t}\n\n\tfor (i=0; i < AMAX; i++) {\n\t\tif (apps[i] == None) {\n\t\t\tcontinue;\n\t\t}\n\t\tfprintf(stdout, \"Using app win: 0x%08lx  root: 0x%08lx\\n\", apps[i], root);\n\t}\n\tfprintf(stdout, \"\\n\");\n\n\tmonitor();\n\n\tappshare_cleanup(0);\n\n#endif\n\treturn 0;\n}",
          "includes": [
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [
            "#define AMAX 32",
            "#define CMAX 128",
            "#define WMAX 192"
          ],
          "globals_used": [
            "extern char *get_xprop(char *prop, Window win);",
            "extern int set_xprop(char *prop, Window win, char *value);",
            "extern void set_env(char *name, char *value);",
            "extern double dnow(void);",
            "static char *usage =\n\"\\n\"\n\"  x11vnc -appshare: an experiment in application sharing via x11vnc.\\n\"\n\"\\n\""
          ],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"x11vnc.h\"\n\n#define AMAX 32\n#define CMAX 128\n#define WMAX 192\n\nextern char *get_xprop(char *prop, Window win);\nextern int set_xprop(char *prop, Window win, char *value);\nextern void set_env(char *name, char *value);\nextern double dnow(void);\nstatic char *usage =\n\"\\n\"\n\"  x11vnc -appshare: an experiment in application sharing via x11vnc.\\n\"\n\"\\n\";\n\nint appshare_main(int argc, char *argv[]) {\n\tint i;\n\tchar *app_str = NULL;\n\tchar *dpy_str = NULL;\n\tlong xselectinput = 0;\n#if NO_X11\n\texiter(\"not compiled with X11\\n\", 1);\n#else\n\tfor (i=0; i < WMAX; i++) {\n\t\twatch[i] = None;\n\t\tstate[i] = 0;\n\t}\n\tfor (i=0; i < AMAX; i++) {\n\t\tapps[i]  = None;\n\t}\n\tfor (i=0; i < CMAX; i++) {\n\t\tclients[i] = NULL;\n\t}\n\n\tx11vnc = strdup(argv[0]);\n\n\tfor (i=1; i < argc; i++) {\n\t\tint end = (i == argc-1) ? 1 : 0;\n\t\tchar *s = argv[i];\n\t\tif (strstr(s, \"--\") == s) {\n\t\t\ts++;\n\t\t}\n\n\t\tif (!strcmp(s, \"-h\") || !strcmp(s, \"-help\")) {\n\t\t\tfprintf(stdout, \"%s\", usage);\n\t\t\texit(0);\n\t\t} else if (!strcmp(s, \"-id\")) {\n\t\t\tid_opt = \"-id\";\n\t\t\tif (end) exiter(\"no -id value supplied\\n\", 1);\n\t\t\tapp_str = strdup(argv[++i]);\n\t\t} else if (!strcmp(s, \"-sid\")) {\n\t\t\tid_opt = \"-sid\";\n\t\t\tif (end) exiter(\"no -sid value supplied\\n\", 1);\n\t\t\tapp_str = strdup(argv[++i]);\n\t\t} else if (!strcmp(s, \"-connect\") || !strcmp(s, \"-connect_or_exit\") || !strcmp(s, \"-coe\")) {\n\t\t\tif (end) exiter(\"no -connect value supplied\\n\", 1);\n\t\t\tconnect_to = strdup(argv[++i]);\n\t\t} else if (!strcmp(s, \"-control\")) {\n\t\t\tif (end) exiter(\"no -control value supplied\\n\", 1);\n\t\t\tcontrol = strdup(argv[++i]);\n\t\t\tif (!strcmp(control, \"shell\")) {\n\t\t\t\tfree(control);\n\t\t\t\tcontrol = strdup(\"internal\");\n\t\t\t\tshell = 1;\n\t\t\t}\n\t\t} else if (!strcmp(s, \"-trackdir\")) {\n\t\t\tif (end) exiter(\"no -trackdir value supplied\\n\", 1);\n\t\t\ttrackdir = strdup(argv[++i]);\n\t\t} else if (!strcmp(s, \"-display\")) {\n\t\t\tif (end) exiter(\"no -display value supplied\\n\", 1);\n\t\t\tdpy_str = strdup(argv[++i]);\n\t\t\tset_env(\"DISPLAY\", dpy_str);\n\t\t} else if (!strcmp(s, \"-delay\")) {\n\t\t\tif (end) exiter(\"no -delay value supplied\\n\", 1);\n\t\t\thelper_delay = atof(argv[++i]);\n\t\t} else if (!strcmp(s, \"-args\")) {\n\t\t\tif (end) exiter(\"no -args value supplied\\n\", 1);\n\t\t\tx11vnc_args = strdup(argv[++i]);\n\t\t} else if (!strcmp(s, \"-env\")) {\n\t\t\tif (end) exiter(\"no -env value supplied\\n\", 1);\n\t\t\tputenv(argv[++i]);\n\t\t} else if (!strcmp(s, \"-debug\")) {\n\t\t\tappshare_debug++;\n\t\t} else if (!strcmp(s, \"-showmenus\")) {\n\t\t\tskip_menus = 0;\n\t\t} else if (!strcmp(s, \"-noexit\")) {\n\t\t\texit_no_app_win = 0;\n\t\t} else if (!strcmp(s, \"-shell\")) {\n\t\t\tshell = 1;\n\t\t} else if (!strcmp(s, \"-nocmds\") || !strcmp(s, \"-safer\")) {\n\t\t\tfprintf(stderr, \"ignoring %s in -appshare mode.\\n\", s);\n\t\t} else if (!strcmp(s, \"-appshare\")) {\n\t\t\t;\n\t\t} else {\n\t\t\tfprintf(stderr, \"unrecognized 'x11vnc -appshare' option: %s\\n\", s);\n\t\t\texiter(\"\", 1);\n\t\t}\n\t}\n\n\tif (getenv(\"X11VNC_APPSHARE_DEBUG\")) {\n\t\tappshare_debug = atoi(getenv(\"X11VNC_APPSHARE_DEBUG\"));\n\t}\n\n\t/* let user override name for multiple instances: */\n\tif (getenv(\"X11VNC_APPSHARE_COMMAND_PROPNAME\")) {\n\t\tcmd_atom_str = strdup(getenv(\"X11VNC_APPSHARE_COMMAND_PROPNAME\"));\n\t}\n\tif (getenv(\"X11VNC_APPSHARE_TICKER_PROPNAME\")) {\n\t\tticker_atom_str = strdup(getenv(\"X11VNC_APPSHARE_TICKER_PROPNAME\"));\n\t}\n\n\tif (shell) {\n\t\tif (!control || strcmp(control, \"internal\")) {\n\t\t\texiter(\"mode -shell requires '-control internal'\\n\", 1);\n\t\t}\n\t}\n\n\tif (connect_to == NULL && control != NULL) {\n\t\tstruct stat sb;\n\t\tif (stat(control, &sb) == 0) {\n\t\t\tint len = 100 + sb.st_size;\n\t\t\tFILE *f = fopen(control, \"r\");\n\n\t\t\tif (f) {\n\t\t\t\tchar *line = (char *) malloc(len);\n\t\t\t\tconnect_to = (char *) calloc(2 * len, 1);\n\t\t\t\twhile (fgets(line, len, f) != NULL) {\n\t\t\t\t\tchar *q = strchr(line, '\\n');\n\t\t\t\t\tif (q) *q = '\\0';\n\t\t\t\t\tq = lblanks(line);\n\t\t\t\t\tif (q[0] == '#') {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tif (connect_to[0] != '\\0') {\n\t\t\t\t\t\tstrcat(connect_to, \",\");\n\t\t\t\t\t}\n\t\t\t\t\tstrcat(connect_to, q);\n\t\t\t\t}\n\t\t\t\tfclose(f);\n\t\t\t}\n\t\t\tfprintf(stderr, \"set -connect to: %s\\n\", connect_to);\n\t\t}\n\t}\n\tif (0 && connect_to == NULL && control == NULL) {\n\t\texiter(\"no -connect host or -control file specified.\\n\", 1);\n\t}\n\n\tif (control) {\n\t\tpid_t pid;\n\t\tparent_pid = getpid();\n\t\tpid = fork();\n\t\tif (pid == (pid_t) -1) {\n\t\t\t;\n\t\t} else if (pid == 0) {\n\t\t\tbe_helper_pid(dpy_str);\n\t\t\texit(0);\n\t\t} else {\n\t\t\thelper_pid = pid;\n\t\t}\n\t}\n\n\tdpy = XOpenDisplay(dpy_str);\n\tif (!dpy) {\n\t\texiter(\"cannot open display\\n\", 1);\n\t}\n\n\troot = DefaultRootWindow(dpy);\n\n\txselectinput = SubstructureNotifyMask;\n\tif (helper_pid > 0) {\n\t\tticker_atom = XInternAtom(dpy, ticker_atom_str, False);\n\t\txselectinput |= PropertyChangeMask;\n\t}\n\tXSelectInput(dpy, root, xselectinput);\n\n\tcmd_atom = XInternAtom(dpy, cmd_atom_str, False);\n\n\tinit_cmask();\n\n\tsprintf(unique_tag, \"X11VNC_APPSHARE_TAG=%d-tag\", getpid());\n\n\tstart_time = dnow();\n\n\tif (app_str == NULL) {\n\t\texiter(\"no -id/-sid window specified.\\n\", 1);\n\t} else {\n\t\tchar *p, *str = strdup(app_str);\n\t\tchar *alist[AMAX];\n\t\tint i, n = 0;\n\n\t\tp = strtok(str, \",\");\n\t\twhile (p) {\n\t\t\tif (n >= AMAX) {\n\t\t\t\tfprintf(stderr, \"ran out of app slots: %s\\n\", app_str);\n\t\t\t\texiter(\"\", 1);\n\t\t\t}\n\t\t\talist[n++] = strdup(p);\n\t\t\tp = strtok(NULL, \",\");\n\t\t}\n\t\tfree(str);\n\n\t\tfor (i=0; i < n; i++) {\n\t\t\tWindow app = None;\n\t\t\tp = alist[i];\n\t\t\tapp = parse_win(p);\n\t\t\tfree(p);\n\n\t\t\tif (app != None) {\n\t\t\t\tif (!ours(app)) {\n\t\t\t\t\tadd_app(app);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tset_trackdir();\n\n\tsignal(SIGINT,  appshare_cleanup);\n\tsignal(SIGTERM, appshare_cleanup);\n\n\trfbLogEnable(0);\n\n\tif (connect_to) {\n\t\tchar *p, *str = strdup(connect_to);\n\t\tint n = 0;\n\t\tp = strtok(str, \",\");\n\t\twhile (p) {\n\t\t\tclients[n++] = strdup(p);\n\t\t\tp = strtok(NULL, \",\");\n\t\t}\n\t\tfree(str);\n\t} else {\n\t\tconnect_to = strdup(\"\");\n\t}\n\n\tfor (i=0; i < AMAX; i++) {\n\t\tif (apps[i] == None) {\n\t\t\tcontinue;\n\t\t}\n\t\tfprintf(stdout, \"Using app win: 0x%08lx  root: 0x%08lx\\n\", apps[i], root);\n\t}\n\tfprintf(stdout, \"\\n\");\n\n\tmonitor();\n\n\tappshare_cleanup(0);\n\n#endif\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "p",
            "\"-appshare\""
          ],
          "line": 1739
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "p",
            "\"--\""
          ],
          "line": 1736
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xi2_devices.h\"\n#include \"solid.h\"\n#include \"pm.h\"\n#include \"selection.h\"\n#include \"sslhelper.h\"\n#include \"sslcmds.h\"\n#include \"inet.h\"\n#include \"unixpw.h\"\n#include \"rates.h\"\n#include \"connections.h\"\n#include \"screen.h\"\n#include \"userinput.h\"\n#include \"cursor.h\"\n#include \"pointer.h\"\n#include \"keyboard.h\"\n#include \"cleanup.h\"\n#include \"user.h\"\n#include \"help.h\"\n#include \"gui.h\"\n#include \"scan.h\"\n#include \"remote.h\"\n#include \"win_utils.h\"\n#include \"xkb_bell.h\"\n#include \"xrandr.h\"\n#include \"xinerama.h\"\n#include \"xevents.h\"\n#include \"xrecord.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nstatic void check_rcfile(int argc, char **argv);\nstatic void immediate_switch_user(int argc, char* argv[]);\nstatic void check_loop_mode(int argc, char* argv[], int force);\nstatic void check_appshare_mode(int argc, char* argv[]);\nextern int appshare_main(int argc, char* argv[]);\n\nstatic void check_appshare_mode(int argc, char* argv[]) {\n\tint i;\n\n\tfor (i=1; i < argc; i++) {\n\t\tchar *p = argv[i];\n\t\tif (strstr(p, \"--\") == p) {\n\t\t\tp++;\n\t\t}\n\t\tif (strstr(p, \"-appshare\") == p) {\n\t\t\tappshare_main(argc, argv);\n\t\t\texit(0);\n\t\t}\n\t}\n}"
  },
  {
    "function_name": "check_loop_mode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/x11vnc.c",
    "lines": "1644-1727",
    "snippet": "static void check_loop_mode(int argc, char* argv[], int force) {\n\tint i;\n\tint loop_mode = 0, loop_sleep = 2000, loop_max = 0;\n\n\tif (force) {\n\t\tloop_mode = 1;\n\t}\n\tfor (i=1; i < argc; i++) {\n\t\tchar *p = argv[i];\n\t\tif (strstr(p, \"--\") == p) {\n\t\t\tp++;\n\t\t}\n\t\tif (strstr(p, \"-loop\") == p) {\n\t\t\tchar *q;\n\t\t\tloop_mode = 1;\n\t\t\tif ((q = strchr(p, ',')) != NULL) {\n\t\t\t\tloop_max = atoi(q+1);\n\t\t\t\t*q = '\\0';\n\t\t\t}\n\t\t\tif (strstr(p, \"-loopbg\") == p) {\n\t\t\t\tset_env(\"X11VNC_LOOP_MODE_BG\", \"1\");\n\t\t\t\tloop_sleep = 500;\n\t\t\t}\n\t\t\t\n\t\t\tq = strpbrk(p, \"0123456789\");\n\t\t\tif (q) {\n\t\t\t\tloop_sleep = atoi(q);\n\t\t\t\tif (loop_sleep <= 0) {\n\t\t\t\t\tloop_sleep = 20;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tif (loop_mode && getenv(\"X11VNC_LOOP_MODE\") == NULL) {\n#if LIBVNCSERVER_HAVE_FORK\n\t\tchar **argv2;\n\t\tint k, i = 1;\n\n\t\tset_env(\"X11VNC_LOOP_MODE\", \"1\");\n\t\targv2 = (char **) malloc((argc+1)*sizeof(char *));\n\n\t\tfor (k=0; k < argc+1; k++) {\n\t\t\targv2[k] = NULL;\n\t\t\tif (k < argc) {\n\t\t\t\targv2[k] = argv[k];\n\t\t\t}\n\t\t}\n\t\twhile (1) {\n\t\t\tint status;\n\t\t\tpid_t p;\n\t\t\tfprintf(stderr, \"\\n --- x11vnc loop: %d ---\\n\\n\", i++);\n\t\t\tfflush(stderr);\n\t\t\tusleep(500 * 1000);\n\t\t\tif ((p = fork()) > 0)  {\n\t\t\t\tfprintf(stderr, \" --- x11vnc loop: waiting \"\n\t\t\t\t    \"for: %d\\n\\n\", p);\n\t\t\t\twait(&status);\n\t\t\t} else if (p == -1) {\n\t\t\t\tfprintf(stderr, \"could not fork\\n\");\n\t\t\t\tperror(\"fork\");\n\t\t\t\texit(1);\n\t\t\t} else {\n\t\t\t\t/* loop mode: no_external_cmds does not apply */\n\t\t\t\texecvp(argv[0], argv2); \n\t\t\t\texit(1);\n\t\t\t}\n\n\t\t\tif (loop_max > 0 && i > loop_max) {\n\t\t\t\tfprintf(stderr, \"\\n --- x11vnc loop: did %d\"\n\t\t\t\t    \" done. ---\\n\\n\", loop_max);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t\tfprintf(stderr, \"\\n --- x11vnc loop: sleeping %d ms \"\n\t\t\t    \"---\\n\\n\", loop_sleep);\n\t\t\tusleep(loop_sleep * 1000);\n\t\t}\n\t\texit(0);\n#else\n\t\tfprintf(stderr, \"fork unavailable, cannot do -loop mode\\n\");\n\t\texit(1);\n#endif\n\t}\n}",
    "includes": [
      "#include \"xi2_devices.h\"",
      "#include \"solid.h\"",
      "#include \"pm.h\"",
      "#include \"selection.h\"",
      "#include \"sslhelper.h\"",
      "#include \"sslcmds.h\"",
      "#include \"inet.h\"",
      "#include \"unixpw.h\"",
      "#include \"rates.h\"",
      "#include \"connections.h\"",
      "#include \"screen.h\"",
      "#include \"userinput.h\"",
      "#include \"cursor.h\"",
      "#include \"pointer.h\"",
      "#include \"keyboard.h\"",
      "#include \"cleanup.h\"",
      "#include \"user.h\"",
      "#include \"help.h\"",
      "#include \"gui.h\"",
      "#include \"scan.h\"",
      "#include \"remote.h\"",
      "#include \"win_utils.h\"",
      "#include \"xkb_bell.h\"",
      "#include \"xrandr.h\"",
      "#include \"xinerama.h\"",
      "#include \"xevents.h\"",
      "#include \"xrecord.h\"",
      "#include \"xdamage.h\"",
      "#include \"xwrappers.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void check_rcfile(int argc, char **argv);",
      "static void immediate_switch_user(int argc, char* argv[]);",
      "static void check_loop_mode(int argc, char* argv[], int force);",
      "static void check_appshare_mode(int argc, char* argv[]);",
      "static char **argv2;",
      "extern int appshare_main(int argc, char* argv[]);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "1"
          ],
          "line": 1724
        },
        "resolved": true,
        "details": {
          "function_name": "clean_up_exit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/cleanup.c",
          "lines": "151-266",
          "snippet": "void clean_up_exit(int ret) {\n\tstatic int depth = 0;\n\texit_flag = 1;\n\n\tif (depth++ > 2) {\n\t\texit(ret);\n\t}\n\n\tif (icon_mode) {\n\t\tclean_icon_mode();\n\t}\n\n\t/* remove the shm areas: */\n\tclean_shm(0);\n\n\tstop_stunnel();\n\tif (use_openssl) {\n\t\tssl_helper_pid(0, 0);\t/* killall */\n\t}\n\n\tif (ssh_pid > 0) {\n\t\tkill(ssh_pid, SIGTERM);\n\t\tssh_pid = 0;\n\t}\n\n#ifdef MACOSX\n\tif (client_connect_file) {\n\t\tif (strstr(client_connect_file, \"/tmp/x11vnc-macosx-remote\")\n\t\t    == client_connect_file) {\n\t\t\tunlink(client_connect_file);\n\t\t}\n\t}\n\tif (macosx_console) {\n\t\tmacosxCG_fini();\n\t}\n#endif\n\n\tif (pipeinput_fh != NULL) {\n\t\tpclose(pipeinput_fh);\n\t\tpipeinput_fh = NULL;\n\t}\n\n\tshutdown_uinput();\n\n\tif (unix_sock) {\n\t\tif (unix_sock_fd >= 0) {\n\t\t\trfbLog(\"deleting unix sock: %s\\n\", unix_sock);\n\t\t\tclose(unix_sock_fd);\n\t\t\tunix_sock_fd = -1;\n\t\t\tunlink(unix_sock);\n\t\t}\n\t}\n\n\tif (! dpy) {\t/* raw_rb hack */\n\t\tif (rm_flagfile) {\n\t\t\tunlink(rm_flagfile);\n\t\t\trm_flagfile = NULL;\n\t\t}\n\t\texit(ret);\n\t}\n\n\t/* X keyboard cleanups */\n\tdelete_added_keycodes(0);\n\n\t/* remove all created XInput2 devices */\n\tif(use_multipointer)\n\t    removeAllMDs(dpy);\n\n\tif (clear_mods == 1) {\n\t\tclear_modifiers(0);\n\t} else if (clear_mods == 2) {\n\t\tclear_keys();\n\t} else if (clear_mods == 3) {\n\t\tclear_keys();\n\t\tclear_locks();\n\t}\n\n\tif (no_autorepeat) {\n\t\tautorepeat(1, 0);\n\t}\n\tif (use_solid_bg) {\n\t\tsolid_bg(1);\n\t}\n\tif (ncache || ncache0) {\n\t\tkde_no_animate(1);\n\t}\n\tX_LOCK;\n\tXTestDiscard_wr(dpy);\n#if HAVE_LIBXDAMAGE\n\tif (xdamage) {\n\t\tXDamageDestroy(dpy, xdamage);\n\t}\n#endif\n#if HAVE_LIBXTRAP\n\tif (trap_ctx) {\n\t\tXEFreeTC(trap_ctx);\n\t}\n#endif\n\t/* XXX rdpy_ctrl, etc. cannot close w/o blocking */\n\tXCloseDisplay_wr(dpy);\n\tX_UNLOCK;\n\n\tfflush(stderr);\n\n\tif (rm_flagfile) {\n\t\tunlink(rm_flagfile);\n\t\trm_flagfile = NULL;\n\t}\n\n\tif (avahi) {\n\t\tavahi_cleanup();\n\t\tfflush(stderr);\n\t}\n\n\texit(ret);\n}",
          "includes": [
            "#include \"xi2_devices.h\"",
            "#include \"uinput.h\"",
            "#include \"xevents.h\"",
            "#include \"xrecord.h\"",
            "#include \"screen.h\"",
            "#include \"avahi.h\"",
            "#include \"macosxCG.h\"",
            "#include \"macosx.h\"",
            "#include \"connections.h\"",
            "#include \"sslhelper.h\"",
            "#include \"sslcmds.h\"",
            "#include \"unixpw.h\"",
            "#include \"solid.h\"",
            "#include \"gui.h\"",
            "#include \"scan.h\"",
            "#include \"keyboard.h\"",
            "#include \"remote.h\"",
            "#include \"xdamage.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void clean_up_exit(int ret);",
            "int known_sigpipe_mode(char *s);",
            "static int exit_flag = 0;",
            "static void clean_icon_mode(void);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xi2_devices.h\"\n#include \"uinput.h\"\n#include \"xevents.h\"\n#include \"xrecord.h\"\n#include \"screen.h\"\n#include \"avahi.h\"\n#include \"macosxCG.h\"\n#include \"macosx.h\"\n#include \"connections.h\"\n#include \"sslhelper.h\"\n#include \"sslcmds.h\"\n#include \"unixpw.h\"\n#include \"solid.h\"\n#include \"gui.h\"\n#include \"scan.h\"\n#include \"keyboard.h\"\n#include \"remote.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nvoid clean_up_exit(int ret);\nint known_sigpipe_mode(char *s);\nstatic int exit_flag = 0;\nstatic void clean_icon_mode(void);\n\nvoid clean_up_exit(int ret) {\n\tstatic int depth = 0;\n\texit_flag = 1;\n\n\tif (depth++ > 2) {\n\t\texit(ret);\n\t}\n\n\tif (icon_mode) {\n\t\tclean_icon_mode();\n\t}\n\n\t/* remove the shm areas: */\n\tclean_shm(0);\n\n\tstop_stunnel();\n\tif (use_openssl) {\n\t\tssl_helper_pid(0, 0);\t/* killall */\n\t}\n\n\tif (ssh_pid > 0) {\n\t\tkill(ssh_pid, SIGTERM);\n\t\tssh_pid = 0;\n\t}\n\n#ifdef MACOSX\n\tif (client_connect_file) {\n\t\tif (strstr(client_connect_file, \"/tmp/x11vnc-macosx-remote\")\n\t\t    == client_connect_file) {\n\t\t\tunlink(client_connect_file);\n\t\t}\n\t}\n\tif (macosx_console) {\n\t\tmacosxCG_fini();\n\t}\n#endif\n\n\tif (pipeinput_fh != NULL) {\n\t\tpclose(pipeinput_fh);\n\t\tpipeinput_fh = NULL;\n\t}\n\n\tshutdown_uinput();\n\n\tif (unix_sock) {\n\t\tif (unix_sock_fd >= 0) {\n\t\t\trfbLog(\"deleting unix sock: %s\\n\", unix_sock);\n\t\t\tclose(unix_sock_fd);\n\t\t\tunix_sock_fd = -1;\n\t\t\tunlink(unix_sock);\n\t\t}\n\t}\n\n\tif (! dpy) {\t/* raw_rb hack */\n\t\tif (rm_flagfile) {\n\t\t\tunlink(rm_flagfile);\n\t\t\trm_flagfile = NULL;\n\t\t}\n\t\texit(ret);\n\t}\n\n\t/* X keyboard cleanups */\n\tdelete_added_keycodes(0);\n\n\t/* remove all created XInput2 devices */\n\tif(use_multipointer)\n\t    removeAllMDs(dpy);\n\n\tif (clear_mods == 1) {\n\t\tclear_modifiers(0);\n\t} else if (clear_mods == 2) {\n\t\tclear_keys();\n\t} else if (clear_mods == 3) {\n\t\tclear_keys();\n\t\tclear_locks();\n\t}\n\n\tif (no_autorepeat) {\n\t\tautorepeat(1, 0);\n\t}\n\tif (use_solid_bg) {\n\t\tsolid_bg(1);\n\t}\n\tif (ncache || ncache0) {\n\t\tkde_no_animate(1);\n\t}\n\tX_LOCK;\n\tXTestDiscard_wr(dpy);\n#if HAVE_LIBXDAMAGE\n\tif (xdamage) {\n\t\tXDamageDestroy(dpy, xdamage);\n\t}\n#endif\n#if HAVE_LIBXTRAP\n\tif (trap_ctx) {\n\t\tXEFreeTC(trap_ctx);\n\t}\n#endif\n\t/* XXX rdpy_ctrl, etc. cannot close w/o blocking */\n\tXCloseDisplay_wr(dpy);\n\tX_UNLOCK;\n\n\tfflush(stderr);\n\n\tif (rm_flagfile) {\n\t\tunlink(rm_flagfile);\n\t\trm_flagfile = NULL;\n\t}\n\n\tif (avahi) {\n\t\tavahi_cleanup();\n\t\tfflush(stderr);\n\t}\n\n\texit(ret);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"fork unavailable, cannot do -loop mode\\n\""
          ],
          "line": 1723
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "usleep",
          "args": [
            "loop_sleep * 1000"
          ],
          "line": 1719
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"\\n --- x11vnc loop: sleeping %d ms \"\n\t\t\t    \"---\\n\\n\"",
            "loop_sleep"
          ],
          "line": 1717
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"\\n --- x11vnc loop: did %d\"\n\t\t\t\t    \" done. ---\\n\\n\"",
            "loop_max"
          ],
          "line": 1712
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "execvp",
          "args": [
            "argv[0]",
            "argv2"
          ],
          "line": 1707
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "perror",
          "args": [
            "\"fork\""
          ],
          "line": 1703
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"could not fork\\n\""
          ],
          "line": 1702
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wait",
          "args": [
            "&status"
          ],
          "line": 1700
        },
        "resolved": true,
        "details": {
          "function_name": "wait_until_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/appshare.c",
          "lines": "995-1008",
          "snippet": "static void wait_until_empty(char *file) {\n\tdouble t = 0.0, dt = 0.05;\n\twhile (t < 1.0) {\n\t\tstruct stat sb;\n\t\tif (stat(file, &sb) != 0) {\n\t\t\treturn;\n\t\t}\n\t\tif (sb.st_size == 0) {\n\t\t\treturn;\n\t\t}\n\t\tt += dt;\n\t\tusleep( (int) (dt * 1000 * 1000) );\n\t}\n}",
          "includes": [
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"x11vnc.h\"\n\nstatic void wait_until_empty(char *file) {\n\tdouble t = 0.0, dt = 0.05;\n\twhile (t < 1.0) {\n\t\tstruct stat sb;\n\t\tif (stat(file, &sb) != 0) {\n\t\t\treturn;\n\t\t}\n\t\tif (sb.st_size == 0) {\n\t\t\treturn;\n\t\t}\n\t\tt += dt;\n\t\tusleep( (int) (dt * 1000 * 1000) );\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\" --- x11vnc loop: waiting \"\n\t\t\t\t    \"for: %d\\n\\n\"",
            "p"
          ],
          "line": 1698
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fork",
          "args": [],
          "line": 1697
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "usleep",
          "args": [
            "500 * 1000"
          ],
          "line": 1696
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fflush",
          "args": [
            "stderr"
          ],
          "line": 1695
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"\\n --- x11vnc loop: %d ---\\n\\n\"",
            "i++"
          ],
          "line": 1694
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "(argc+1)*sizeof(char *)"
          ],
          "line": 1683
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_env",
          "args": [
            "\"X11VNC_LOOP_MODE\"",
            "\"1\""
          ],
          "line": 1682
        },
        "resolved": true,
        "details": {
          "function_name": "set_env",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/util.c",
          "lines": "239-249",
          "snippet": "void set_env(char *name, char *value) {\n\tchar *str;\n\tif (! name) {\n\t\treturn;\n\t}\n\tif (! value) {\n\t\tvalue = \"\";\n\t}\n\n\tsetenv(name, value, 1);\n}",
          "includes": [
            "#include \"connections.h\"",
            "#include \"unixpw.h\"",
            "#include \"win_utils.h\"",
            "#include \"cleanup.h\"",
            "#include \"x11vnc.h\"",
            "#include <stdlib.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void lowercase(char *str);",
            "void uppercase(char *str);",
            "char *lblanks(char *str);",
            "void strzero(char *str);",
            "void set_env(char *name, char *value);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"connections.h\"\n#include \"unixpw.h\"\n#include \"win_utils.h\"\n#include \"cleanup.h\"\n#include \"x11vnc.h\"\n#include <stdlib.h>\n\nvoid lowercase(char *str);\nvoid uppercase(char *str);\nchar *lblanks(char *str);\nvoid strzero(char *str);\nvoid set_env(char *name, char *value);\n\nvoid set_env(char *name, char *value) {\n\tchar *str;\n\tif (! name) {\n\t\treturn;\n\t}\n\tif (! value) {\n\t\tvalue = \"\";\n\t}\n\n\tsetenv(name, value, 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "getenv",
          "args": [
            "\"X11VNC_LOOP_MODE\""
          ],
          "line": 1677
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atoi",
          "args": [
            "q"
          ],
          "line": 1670
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strpbrk",
          "args": [
            "p",
            "\"0123456789\""
          ],
          "line": 1668
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "p",
            "\"-loopbg\""
          ],
          "line": 1663
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atoi",
          "args": [
            "q+1"
          ],
          "line": 1660
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "p",
            "','"
          ],
          "line": 1659
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "p",
            "\"-loop\""
          ],
          "line": 1656
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "p",
            "\"--\""
          ],
          "line": 1653
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xi2_devices.h\"\n#include \"solid.h\"\n#include \"pm.h\"\n#include \"selection.h\"\n#include \"sslhelper.h\"\n#include \"sslcmds.h\"\n#include \"inet.h\"\n#include \"unixpw.h\"\n#include \"rates.h\"\n#include \"connections.h\"\n#include \"screen.h\"\n#include \"userinput.h\"\n#include \"cursor.h\"\n#include \"pointer.h\"\n#include \"keyboard.h\"\n#include \"cleanup.h\"\n#include \"user.h\"\n#include \"help.h\"\n#include \"gui.h\"\n#include \"scan.h\"\n#include \"remote.h\"\n#include \"win_utils.h\"\n#include \"xkb_bell.h\"\n#include \"xrandr.h\"\n#include \"xinerama.h\"\n#include \"xevents.h\"\n#include \"xrecord.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nstatic void check_rcfile(int argc, char **argv);\nstatic void immediate_switch_user(int argc, char* argv[]);\nstatic void check_loop_mode(int argc, char* argv[], int force);\nstatic void check_appshare_mode(int argc, char* argv[]);\nstatic char **argv2;\nextern int appshare_main(int argc, char* argv[]);\n\nstatic void check_loop_mode(int argc, char* argv[], int force) {\n\tint i;\n\tint loop_mode = 0, loop_sleep = 2000, loop_max = 0;\n\n\tif (force) {\n\t\tloop_mode = 1;\n\t}\n\tfor (i=1; i < argc; i++) {\n\t\tchar *p = argv[i];\n\t\tif (strstr(p, \"--\") == p) {\n\t\t\tp++;\n\t\t}\n\t\tif (strstr(p, \"-loop\") == p) {\n\t\t\tchar *q;\n\t\t\tloop_mode = 1;\n\t\t\tif ((q = strchr(p, ',')) != NULL) {\n\t\t\t\tloop_max = atoi(q+1);\n\t\t\t\t*q = '\\0';\n\t\t\t}\n\t\t\tif (strstr(p, \"-loopbg\") == p) {\n\t\t\t\tset_env(\"X11VNC_LOOP_MODE_BG\", \"1\");\n\t\t\t\tloop_sleep = 500;\n\t\t\t}\n\t\t\t\n\t\t\tq = strpbrk(p, \"0123456789\");\n\t\t\tif (q) {\n\t\t\t\tloop_sleep = atoi(q);\n\t\t\t\tif (loop_sleep <= 0) {\n\t\t\t\t\tloop_sleep = 20;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tif (loop_mode && getenv(\"X11VNC_LOOP_MODE\") == NULL) {\n#if LIBVNCSERVER_HAVE_FORK\n\t\tchar **argv2;\n\t\tint k, i = 1;\n\n\t\tset_env(\"X11VNC_LOOP_MODE\", \"1\");\n\t\targv2 = (char **) malloc((argc+1)*sizeof(char *));\n\n\t\tfor (k=0; k < argc+1; k++) {\n\t\t\targv2[k] = NULL;\n\t\t\tif (k < argc) {\n\t\t\t\targv2[k] = argv[k];\n\t\t\t}\n\t\t}\n\t\twhile (1) {\n\t\t\tint status;\n\t\t\tpid_t p;\n\t\t\tfprintf(stderr, \"\\n --- x11vnc loop: %d ---\\n\\n\", i++);\n\t\t\tfflush(stderr);\n\t\t\tusleep(500 * 1000);\n\t\t\tif ((p = fork()) > 0)  {\n\t\t\t\tfprintf(stderr, \" --- x11vnc loop: waiting \"\n\t\t\t\t    \"for: %d\\n\\n\", p);\n\t\t\t\twait(&status);\n\t\t\t} else if (p == -1) {\n\t\t\t\tfprintf(stderr, \"could not fork\\n\");\n\t\t\t\tperror(\"fork\");\n\t\t\t\texit(1);\n\t\t\t} else {\n\t\t\t\t/* loop mode: no_external_cmds does not apply */\n\t\t\t\texecvp(argv[0], argv2); \n\t\t\t\texit(1);\n\t\t\t}\n\n\t\t\tif (loop_max > 0 && i > loop_max) {\n\t\t\t\tfprintf(stderr, \"\\n --- x11vnc loop: did %d\"\n\t\t\t\t    \" done. ---\\n\\n\", loop_max);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t\tfprintf(stderr, \"\\n --- x11vnc loop: sleeping %d ms \"\n\t\t\t    \"---\\n\\n\", loop_sleep);\n\t\t\tusleep(loop_sleep * 1000);\n\t\t}\n\t\texit(0);\n#else\n\t\tfprintf(stderr, \"fork unavailable, cannot do -loop mode\\n\");\n\t\texit(1);\n#endif\n\t}\n}"
  },
  {
    "function_name": "print_settings",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/x11vnc.c",
    "lines": "1445-1641",
    "snippet": "static void print_settings(int try_http, int bg, char *gui_str) {\n\n\tfprintf(stderr, \"\\n\");\n\tfprintf(stderr, \"Settings:\\n\");\n\tfprintf(stderr, \" display:    %s\\n\", use_dpy ? use_dpy\n\t    : \"null\");\n#if SMALL_FOOTPRINT < 2\n\tfprintf(stderr, \" authfile:   %s\\n\", auth_file ? auth_file\n\t    : \"null\");\n\tfprintf(stderr, \" subwin:     0x%lx\\n\", subwin);\n\tfprintf(stderr, \" -sid mode:  %d\\n\", rootshift);\n\tfprintf(stderr, \" clip:       %s\\n\", clip_str ? clip_str\n\t    : \"null\");\n\tfprintf(stderr, \" flashcmap:  %d\\n\", flash_cmap);\n\tfprintf(stderr, \" shiftcmap:  %d\\n\", shift_cmap);\n\tfprintf(stderr, \" force_idx:  %d\\n\", force_indexed_color);\n\tfprintf(stderr, \" cmap8to24:  %d\\n\", cmap8to24);\n\tfprintf(stderr, \" 8to24_opts: %s\\n\", cmap8to24_str ? cmap8to24_str\n\t    : \"null\");\n\tfprintf(stderr, \" 24to32:     %d\\n\", xform24to32);\n\tfprintf(stderr, \" visual:     %s\\n\", visual_str ? visual_str\n\t    : \"null\");\n\tfprintf(stderr, \" overlay:    %d\\n\", overlay);\n\tfprintf(stderr, \" ovl_cursor: %d\\n\", overlay_cursor);\n\tfprintf(stderr, \" scaling:    %d %.4f %.4f\\n\", scaling, scale_fac_x, scale_fac_y);\n\tfprintf(stderr, \" viewonly:   %d\\n\", view_only);\n\tfprintf(stderr, \" shared:     %d\\n\", shared);\n\tfprintf(stderr, \" conn_once:  %d\\n\", connect_once);\n\tfprintf(stderr, \" timeout:    %d\\n\", first_conn_timeout);\n\tfprintf(stderr, \" ping:       %d\\n\", ping_interval);\n\tfprintf(stderr, \" inetd:      %d\\n\", inetd);\n\tfprintf(stderr, \" tightfilexfer:   %d\\n\", tightfilexfer);\n\tfprintf(stderr, \" http:       %d\\n\", try_http);\n\tfprintf(stderr, \" connect:    %s\\n\", client_connect\n\t    ? client_connect : \"null\");\n\tfprintf(stderr, \" connectfile %s\\n\", client_connect_file\n\t    ? client_connect_file : \"null\");\n\tfprintf(stderr, \" vnc_conn:   %d\\n\", vnc_connect);\n\tfprintf(stderr, \" allow:      %s\\n\", allow_list ? allow_list\n\t    : \"null\");\n\tfprintf(stderr, \" input:      %s\\n\", allowed_input_str\n\t    ? allowed_input_str : \"null\");\n\tfprintf(stderr, \" passfile:   %s\\n\", passwdfile ? passwdfile\n\t    : \"null\");\n\tfprintf(stderr, \" unixpw:     %d\\n\", unixpw);\n\tfprintf(stderr, \" unixpw_lst: %s\\n\", unixpw_list ? unixpw_list:\"null\");\n\tfprintf(stderr, \" ssl:        %s\\n\", openssl_pem ? openssl_pem:\"null\");\n\tfprintf(stderr, \" ssldir:     %s\\n\", ssl_certs_dir ? ssl_certs_dir:\"null\");\n\tfprintf(stderr, \" ssltimeout  %d\\n\", ssl_timeout_secs);\n\tfprintf(stderr, \" sslverify:  %s\\n\", ssl_verify ? ssl_verify:\"null\");\n\tfprintf(stderr, \" stunnel:    %d\\n\", use_stunnel);\n\tfprintf(stderr, \" accept:     %s\\n\", accept_cmd ? accept_cmd\n\t    : \"null\");\n\tfprintf(stderr, \" accept:     %s\\n\", afteraccept_cmd ? afteraccept_cmd\n\t    : \"null\");\n\tfprintf(stderr, \" gone:       %s\\n\", gone_cmd ? gone_cmd\n\t    : \"null\");\n\tfprintf(stderr, \" users:      %s\\n\", users_list ? users_list\n\t    : \"null\");\n\tfprintf(stderr, \" using_shm:  %d\\n\", using_shm);\n\tfprintf(stderr, \" flipbytes:  %d\\n\", flip_byte_order);\n\tfprintf(stderr, \" onetile:    %d\\n\", single_copytile);\n\tfprintf(stderr, \" solid:      %s\\n\", solid_str\n\t    ? solid_str : \"null\");\n\tfprintf(stderr, \" blackout:   %s\\n\", blackout_str\n\t    ? blackout_str : \"null\");\n\tfprintf(stderr, \" xinerama:   %d\\n\", xinerama);\n\tfprintf(stderr, \" xtrap:      %d\\n\", xtrap_input);\n\tfprintf(stderr, \" xrandr:     %d\\n\", xrandr);\n\tfprintf(stderr, \" xrandrmode: %s\\n\", xrandr_mode ? xrandr_mode\n\t    : \"null\");\n\tfprintf(stderr, \" padgeom:    %s\\n\", pad_geometry\n\t    ? pad_geometry : \"null\");\n\tfprintf(stderr, \" logfile:    %s\\n\", logfile ? logfile\n\t    : \"null\");\n\tfprintf(stderr, \" logappend:  %d\\n\", logfile_append);\n\tfprintf(stderr, \" flag:       %s\\n\", flagfile ? flagfile\n\t    : \"null\");\n\tfprintf(stderr, \" rm_flag:    %s\\n\", rm_flagfile ? rm_flagfile\n\t    : \"null\");\n\tfprintf(stderr, \" rc_file:    \\\"%s\\\"\\n\", rc_rcfile ? rc_rcfile\n\t    : \"null\");\n\tfprintf(stderr, \" norc:       %d\\n\", rc_norc);\n\tfprintf(stderr, \" dbg:        %d\\n\", crash_debug);\n\tfprintf(stderr, \" bg:         %d\\n\", bg);\n\tfprintf(stderr, \" mod_tweak:  %d\\n\", use_modifier_tweak);\n\tfprintf(stderr, \" isolevel3:  %d\\n\", use_iso_level3);\n\tfprintf(stderr, \" xkb:        %d\\n\", use_xkb_modtweak);\n\tfprintf(stderr, \" skipkeys:   %s\\n\",\n\t    skip_keycodes ? skip_keycodes : \"null\");\n\tfprintf(stderr, \" sloppykeys: %d\\n\", sloppy_keys);\n\tfprintf(stderr, \" skip_dups:  %d\\n\", skip_duplicate_key_events);\n\tfprintf(stderr, \" addkeysyms: %d\\n\", add_keysyms);\n\tfprintf(stderr, \" xkbcompat:  %d\\n\", xkbcompat);\n\tfprintf(stderr, \" clearmods:  %d\\n\", clear_mods);\n\tfprintf(stderr, \" remap:      %s\\n\", remap_file ? remap_file\n\t    : \"null\");\n\tfprintf(stderr, \" norepeat:   %d\\n\", no_autorepeat);\n\tfprintf(stderr, \" norepeatcnt:%d\\n\", no_repeat_countdown);\n\tfprintf(stderr, \" nofb:       %d\\n\", nofb);\n\tfprintf(stderr, \" watchbell:  %d\\n\", watch_bell);\n\tfprintf(stderr, \" watchsel:   %d\\n\", watch_selection);\n\tfprintf(stderr, \" watchprim:  %d\\n\", watch_primary);\n\tfprintf(stderr, \" seldir:     %s\\n\", sel_direction ?\n\t    sel_direction : \"null\");\n\tfprintf(stderr, \" cursor:     %d\\n\", show_cursor);\n\tfprintf(stderr, \" multicurs:  %d\\n\", show_multiple_cursors);\n\tfprintf(stderr, \" curs_mode:  %s\\n\", multiple_cursors_mode\n\t    ? multiple_cursors_mode : \"null\");\n\tfprintf(stderr, \" arrow:      %d\\n\", alt_arrow);\n\tfprintf(stderr, \" xfixes:     %d\\n\", use_xfixes);\n\tfprintf(stderr, \" alphacut:   %d\\n\", alpha_threshold);\n\tfprintf(stderr, \" alphafrac:  %.2f\\n\", alpha_frac);\n\tfprintf(stderr, \" alpharemove:%d\\n\", alpha_remove);\n\tfprintf(stderr, \" alphablend: %d\\n\", alpha_blend);\n\tfprintf(stderr, \" cursorshape:%d\\n\", cursor_shape_updates);\n\tfprintf(stderr, \" cursorpos:  %d\\n\", cursor_pos_updates);\n\tfprintf(stderr, \" xwarpptr:   %d\\n\", use_xwarppointer);\n\tfprintf(stderr, \" alwaysinj:  %d\\n\", always_inject);\n\tfprintf(stderr, \" buttonmap:  %s\\n\", pointer_remap\n\t    ? pointer_remap : \"null\");\n\tfprintf(stderr, \" dragging:   %d\\n\", show_dragging);\n\tfprintf(stderr, \" ncache:     %d\\n\", ncache);\n\tfprintf(stderr, \" wireframe:  %s\\n\", wireframe_str ?\n\t    wireframe_str : WIREFRAME_PARMS);\n\tfprintf(stderr, \" wirecopy:   %s\\n\", wireframe_copyrect ?\n\t    wireframe_copyrect : wireframe_copyrect_default);\n\tfprintf(stderr, \" scrollcopy: %s\\n\", scroll_copyrect ?\n\t    scroll_copyrect : scroll_copyrect_default);\n\tfprintf(stderr, \"  scr_area:  %d\\n\", scrollcopyrect_min_area);\n\tfprintf(stderr, \"  scr_skip:  %s\\n\", scroll_skip_str ?\n\t    scroll_skip_str : scroll_skip_str0);\n\tfprintf(stderr, \"  scr_inc:   %s\\n\", scroll_good_str ?\n\t    scroll_good_str : scroll_good_str0);\n\tfprintf(stderr, \"  scr_keys:  %s\\n\", scroll_key_list_str ?\n\t    scroll_key_list_str : \"null\");\n\tfprintf(stderr, \"  scr_term:  %s\\n\", scroll_term_str ?\n\t    scroll_term_str : \"null\");\n\tfprintf(stderr, \"  scr_keyrep: %s\\n\", max_keyrepeat_str ?\n\t    max_keyrepeat_str : \"null\");\n\tfprintf(stderr, \"  scr_parms: %s\\n\", scroll_copyrect_str ?\n\t    scroll_copyrect_str : SCROLL_COPYRECT_PARMS);\n\tfprintf(stderr, \" fixscreen:  %s\\n\", screen_fixup_str ?\n\t    screen_fixup_str : \"null\");\n\tfprintf(stderr, \" noxrecord:  %d\\n\", noxrecord);\n\tfprintf(stderr, \" grabbuster: %d\\n\", grab_buster);\n\tfprintf(stderr, \" ptr_mode:   %d\\n\", pointer_mode);\n\tfprintf(stderr, \" inputskip:  %d\\n\", ui_skip);\n\tfprintf(stderr, \" speeds:     %s\\n\", speeds_str\n\t    ? speeds_str : \"null\");\n\tfprintf(stderr, \" wmdt:       %s\\n\", wmdt_str\n\t    ? wmdt_str : \"null\");\n\tfprintf(stderr, \" debug_ptr:  %d\\n\", debug_pointer);\n\tfprintf(stderr, \" debug_key:  %d\\n\", debug_keyboard);\n\tfprintf(stderr, \" defer:      %d\\n\", defer_update);\n\tfprintf(stderr, \" waitms:     %d\\n\", waitms);\n\tfprintf(stderr, \" wait_ui:    %.2f\\n\", wait_ui);\n\tfprintf(stderr, \" nowait_bog: %d\\n\", !wait_bog);\n\tfprintf(stderr, \" slow_fb:    %.2f\\n\", slow_fb);\n\tfprintf(stderr, \" xrefresh:   %.2f\\n\", xrefresh);\n\tfprintf(stderr, \" readtimeout: %d\\n\", rfbMaxClientWait/1000);\n\tfprintf(stderr, \" take_naps:  %d\\n\", take_naps);\n\tfprintf(stderr, \" sb:         %d\\n\", screen_blank);\n\tfprintf(stderr, \" fbpm:       %d\\n\", !watch_fbpm);\n\tfprintf(stderr, \" dpms:       %d\\n\", !watch_dpms);\n\tfprintf(stderr, \" xdamage:    %d\\n\", use_xdamage);\n\tfprintf(stderr, \"  xd_area:   %d\\n\", xdamage_max_area);\n\tfprintf(stderr, \"  xd_mem:    %.3f\\n\", xdamage_memory);\n\tfprintf(stderr, \" xcomposite: %d\\n\", use_xcomposite);\n#ifdef HAVE_XI2\n\tfprintf(stderr, \" multiptr:   %d\\n\", use_multipointer);\n#endif\n\tfprintf(stderr, \" sigpipe:    %s\\n\", sigpipe\n\t    ? sigpipe : \"null\");\n\tfprintf(stderr, \" threads:    %d\\n\", use_threads);\n\tfprintf(stderr, \" fs_frac:    %.2f\\n\", fs_frac);\n\tfprintf(stderr, \" gaps_fill:  %d\\n\", gaps_fill);\n\tfprintf(stderr, \" grow_fill:  %d\\n\", grow_fill);\n\tfprintf(stderr, \" tile_fuzz:  %d\\n\", tile_fuzz);\n\tfprintf(stderr, \" snapfb:     %d\\n\", use_snapfb);\n\tfprintf(stderr, \" rawfb:      %s\\n\", raw_fb_str\n\t    ? raw_fb_str : \"null\");\n\tfprintf(stderr, \" pipeinput:  %s\\n\", pipeinput_str\n\t    ? pipeinput_str : \"null\");\n\tfprintf(stderr, \" gui:        %d\\n\", launch_gui);\n\tfprintf(stderr, \" gui_mode:   %s\\n\", gui_str\n\t    ? gui_str : \"null\");\n\tfprintf(stderr, \" noremote:   %d\\n\", !accept_remote_cmds);\n\tfprintf(stderr, \" unsafe:     %d\\n\", !safe_remote_only);\n\tfprintf(stderr, \" privremote: %d\\n\", priv_remote);\n\tfprintf(stderr, \" safer:      %d\\n\", more_safe);\n\tfprintf(stderr, \" nocmds:     %d\\n\", no_external_cmds);\n\tfprintf(stderr, \" deny_all:   %d\\n\", deny_all);\n\tfprintf(stderr, \" pid:        %d\\n\", getpid());\n\tfprintf(stderr, \"\\n\");\n#endif\n}",
    "includes": [
      "#include \"xi2_devices.h\"",
      "#include \"solid.h\"",
      "#include \"pm.h\"",
      "#include \"selection.h\"",
      "#include \"sslhelper.h\"",
      "#include \"sslcmds.h\"",
      "#include \"inet.h\"",
      "#include \"unixpw.h\"",
      "#include \"rates.h\"",
      "#include \"connections.h\"",
      "#include \"screen.h\"",
      "#include \"userinput.h\"",
      "#include \"cursor.h\"",
      "#include \"pointer.h\"",
      "#include \"keyboard.h\"",
      "#include \"cleanup.h\"",
      "#include \"user.h\"",
      "#include \"help.h\"",
      "#include \"gui.h\"",
      "#include \"scan.h\"",
      "#include \"remote.h\"",
      "#include \"win_utils.h\"",
      "#include \"xkb_bell.h\"",
      "#include \"xrandr.h\"",
      "#include \"xinerama.h\"",
      "#include \"xevents.h\"",
      "#include \"xrecord.h\"",
      "#include \"xdamage.h\"",
      "#include \"xwrappers.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void print_settings(int try_http, int bg, char *gui_str);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"\\n\""
          ],
          "line": 1639
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\" pid:        %d\\n\"",
            "getpid()"
          ],
          "line": 1638
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getpid",
          "args": [],
          "line": 1638
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\" deny_all:   %d\\n\"",
            "deny_all"
          ],
          "line": 1637
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\" nocmds:     %d\\n\"",
            "no_external_cmds"
          ],
          "line": 1636
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\" safer:      %d\\n\"",
            "more_safe"
          ],
          "line": 1635
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\" privremote: %d\\n\"",
            "priv_remote"
          ],
          "line": 1634
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\" unsafe:     %d\\n\"",
            "!safe_remote_only"
          ],
          "line": 1633
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\" noremote:   %d\\n\"",
            "!accept_remote_cmds"
          ],
          "line": 1632
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\" gui_mode:   %s\\n\"",
            "gui_str\n\t    ? gui_str : \"null\""
          ],
          "line": 1630
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\" gui:        %d\\n\"",
            "launch_gui"
          ],
          "line": 1629
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\" pipeinput:  %s\\n\"",
            "pipeinput_str\n\t    ? pipeinput_str : \"null\""
          ],
          "line": 1627
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\" rawfb:      %s\\n\"",
            "raw_fb_str\n\t    ? raw_fb_str : \"null\""
          ],
          "line": 1625
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\" snapfb:     %d\\n\"",
            "use_snapfb"
          ],
          "line": 1624
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\" tile_fuzz:  %d\\n\"",
            "tile_fuzz"
          ],
          "line": 1623
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\" grow_fill:  %d\\n\"",
            "grow_fill"
          ],
          "line": 1622
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\" gaps_fill:  %d\\n\"",
            "gaps_fill"
          ],
          "line": 1621
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\" fs_frac:    %.2f\\n\"",
            "fs_frac"
          ],
          "line": 1620
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\" threads:    %d\\n\"",
            "use_threads"
          ],
          "line": 1619
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\" sigpipe:    %s\\n\"",
            "sigpipe\n\t    ? sigpipe : \"null\""
          ],
          "line": 1617
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\" multiptr:   %d\\n\"",
            "use_multipointer"
          ],
          "line": 1615
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\" xcomposite: %d\\n\"",
            "use_xcomposite"
          ],
          "line": 1613
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"  xd_mem:    %.3f\\n\"",
            "xdamage_memory"
          ],
          "line": 1612
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"  xd_area:   %d\\n\"",
            "xdamage_max_area"
          ],
          "line": 1611
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\" xdamage:    %d\\n\"",
            "use_xdamage"
          ],
          "line": 1610
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\" dpms:       %d\\n\"",
            "!watch_dpms"
          ],
          "line": 1609
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\" fbpm:       %d\\n\"",
            "!watch_fbpm"
          ],
          "line": 1608
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\" sb:         %d\\n\"",
            "screen_blank"
          ],
          "line": 1607
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\" take_naps:  %d\\n\"",
            "take_naps"
          ],
          "line": 1606
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\" readtimeout: %d\\n\"",
            "rfbMaxClientWait/1000"
          ],
          "line": 1605
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\" xrefresh:   %.2f\\n\"",
            "xrefresh"
          ],
          "line": 1604
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\" slow_fb:    %.2f\\n\"",
            "slow_fb"
          ],
          "line": 1603
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\" nowait_bog: %d\\n\"",
            "!wait_bog"
          ],
          "line": 1602
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\" wait_ui:    %.2f\\n\"",
            "wait_ui"
          ],
          "line": 1601
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\" waitms:     %d\\n\"",
            "waitms"
          ],
          "line": 1600
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\" defer:      %d\\n\"",
            "defer_update"
          ],
          "line": 1599
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\" debug_key:  %d\\n\"",
            "debug_keyboard"
          ],
          "line": 1598
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\" debug_ptr:  %d\\n\"",
            "debug_pointer"
          ],
          "line": 1597
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\" wmdt:       %s\\n\"",
            "wmdt_str\n\t    ? wmdt_str : \"null\""
          ],
          "line": 1595
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\" speeds:     %s\\n\"",
            "speeds_str\n\t    ? speeds_str : \"null\""
          ],
          "line": 1593
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\" inputskip:  %d\\n\"",
            "ui_skip"
          ],
          "line": 1592
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\" ptr_mode:   %d\\n\"",
            "pointer_mode"
          ],
          "line": 1591
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\" grabbuster: %d\\n\"",
            "grab_buster"
          ],
          "line": 1590
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\" noxrecord:  %d\\n\"",
            "noxrecord"
          ],
          "line": 1589
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\" fixscreen:  %s\\n\"",
            "screen_fixup_str ?\n\t    screen_fixup_str : \"null\""
          ],
          "line": 1587
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"  scr_parms: %s\\n\"",
            "scroll_copyrect_str ?\n\t    scroll_copyrect_str : SCROLL_COPYRECT_PARMS"
          ],
          "line": 1585
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"  scr_keyrep: %s\\n\"",
            "max_keyrepeat_str ?\n\t    max_keyrepeat_str : \"null\""
          ],
          "line": 1583
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"  scr_term:  %s\\n\"",
            "scroll_term_str ?\n\t    scroll_term_str : \"null\""
          ],
          "line": 1581
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"  scr_keys:  %s\\n\"",
            "scroll_key_list_str ?\n\t    scroll_key_list_str : \"null\""
          ],
          "line": 1579
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"  scr_inc:   %s\\n\"",
            "scroll_good_str ?\n\t    scroll_good_str : scroll_good_str0"
          ],
          "line": 1577
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"  scr_skip:  %s\\n\"",
            "scroll_skip_str ?\n\t    scroll_skip_str : scroll_skip_str0"
          ],
          "line": 1575
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"  scr_area:  %d\\n\"",
            "scrollcopyrect_min_area"
          ],
          "line": 1574
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\" scrollcopy: %s\\n\"",
            "scroll_copyrect ?\n\t    scroll_copyrect : scroll_copyrect_default"
          ],
          "line": 1572
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\" wirecopy:   %s\\n\"",
            "wireframe_copyrect ?\n\t    wireframe_copyrect : wireframe_copyrect_default"
          ],
          "line": 1570
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\" wireframe:  %s\\n\"",
            "wireframe_str ?\n\t    wireframe_str : WIREFRAME_PARMS"
          ],
          "line": 1568
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\" ncache:     %d\\n\"",
            "ncache"
          ],
          "line": 1567
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\" dragging:   %d\\n\"",
            "show_dragging"
          ],
          "line": 1566
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\" buttonmap:  %s\\n\"",
            "pointer_remap\n\t    ? pointer_remap : \"null\""
          ],
          "line": 1564
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\" alwaysinj:  %d\\n\"",
            "always_inject"
          ],
          "line": 1563
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\" xwarpptr:   %d\\n\"",
            "use_xwarppointer"
          ],
          "line": 1562
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\" cursorpos:  %d\\n\"",
            "cursor_pos_updates"
          ],
          "line": 1561
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\" cursorshape:%d\\n\"",
            "cursor_shape_updates"
          ],
          "line": 1560
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\" alphablend: %d\\n\"",
            "alpha_blend"
          ],
          "line": 1559
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\" alpharemove:%d\\n\"",
            "alpha_remove"
          ],
          "line": 1558
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\" alphafrac:  %.2f\\n\"",
            "alpha_frac"
          ],
          "line": 1557
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\" alphacut:   %d\\n\"",
            "alpha_threshold"
          ],
          "line": 1556
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\" xfixes:     %d\\n\"",
            "use_xfixes"
          ],
          "line": 1555
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\" arrow:      %d\\n\"",
            "alt_arrow"
          ],
          "line": 1554
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\" curs_mode:  %s\\n\"",
            "multiple_cursors_mode\n\t    ? multiple_cursors_mode : \"null\""
          ],
          "line": 1552
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\" multicurs:  %d\\n\"",
            "show_multiple_cursors"
          ],
          "line": 1551
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\" cursor:     %d\\n\"",
            "show_cursor"
          ],
          "line": 1550
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\" seldir:     %s\\n\"",
            "sel_direction ?\n\t    sel_direction : \"null\""
          ],
          "line": 1548
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\" watchprim:  %d\\n\"",
            "watch_primary"
          ],
          "line": 1547
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\" watchsel:   %d\\n\"",
            "watch_selection"
          ],
          "line": 1546
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\" watchbell:  %d\\n\"",
            "watch_bell"
          ],
          "line": 1545
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\" nofb:       %d\\n\"",
            "nofb"
          ],
          "line": 1544
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\" norepeatcnt:%d\\n\"",
            "no_repeat_countdown"
          ],
          "line": 1543
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\" norepeat:   %d\\n\"",
            "no_autorepeat"
          ],
          "line": 1542
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\" remap:      %s\\n\"",
            "remap_file ? remap_file\n\t    : \"null\""
          ],
          "line": 1540
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\" clearmods:  %d\\n\"",
            "clear_mods"
          ],
          "line": 1539
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\" xkbcompat:  %d\\n\"",
            "xkbcompat"
          ],
          "line": 1538
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\" addkeysyms: %d\\n\"",
            "add_keysyms"
          ],
          "line": 1537
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\" skip_dups:  %d\\n\"",
            "skip_duplicate_key_events"
          ],
          "line": 1536
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\" sloppykeys: %d\\n\"",
            "sloppy_keys"
          ],
          "line": 1535
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\" skipkeys:   %s\\n\"",
            "skip_keycodes ? skip_keycodes : \"null\""
          ],
          "line": 1533
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\" xkb:        %d\\n\"",
            "use_xkb_modtweak"
          ],
          "line": 1532
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\" isolevel3:  %d\\n\"",
            "use_iso_level3"
          ],
          "line": 1531
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\" mod_tweak:  %d\\n\"",
            "use_modifier_tweak"
          ],
          "line": 1530
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\" bg:         %d\\n\"",
            "bg"
          ],
          "line": 1529
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\" dbg:        %d\\n\"",
            "crash_debug"
          ],
          "line": 1528
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\" norc:       %d\\n\"",
            "rc_norc"
          ],
          "line": 1527
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\" rc_file:    \\\"%s\\\"\\n\"",
            "rc_rcfile ? rc_rcfile\n\t    : \"null\""
          ],
          "line": 1525
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\" rm_flag:    %s\\n\"",
            "rm_flagfile ? rm_flagfile\n\t    : \"null\""
          ],
          "line": 1523
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\" flag:       %s\\n\"",
            "flagfile ? flagfile\n\t    : \"null\""
          ],
          "line": 1521
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\" logappend:  %d\\n\"",
            "logfile_append"
          ],
          "line": 1520
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\" logfile:    %s\\n\"",
            "logfile ? logfile\n\t    : \"null\""
          ],
          "line": 1518
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\" padgeom:    %s\\n\"",
            "pad_geometry\n\t    ? pad_geometry : \"null\""
          ],
          "line": 1516
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\" xrandrmode: %s\\n\"",
            "xrandr_mode ? xrandr_mode\n\t    : \"null\""
          ],
          "line": 1514
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\" xrandr:     %d\\n\"",
            "xrandr"
          ],
          "line": 1513
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\" xtrap:      %d\\n\"",
            "xtrap_input"
          ],
          "line": 1512
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\" xinerama:   %d\\n\"",
            "xinerama"
          ],
          "line": 1511
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\" blackout:   %s\\n\"",
            "blackout_str\n\t    ? blackout_str : \"null\""
          ],
          "line": 1509
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\" solid:      %s\\n\"",
            "solid_str\n\t    ? solid_str : \"null\""
          ],
          "line": 1507
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\" onetile:    %d\\n\"",
            "single_copytile"
          ],
          "line": 1506
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\" flipbytes:  %d\\n\"",
            "flip_byte_order"
          ],
          "line": 1505
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\" using_shm:  %d\\n\"",
            "using_shm"
          ],
          "line": 1504
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\" users:      %s\\n\"",
            "users_list ? users_list\n\t    : \"null\""
          ],
          "line": 1502
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\" gone:       %s\\n\"",
            "gone_cmd ? gone_cmd\n\t    : \"null\""
          ],
          "line": 1500
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\" accept:     %s\\n\"",
            "afteraccept_cmd ? afteraccept_cmd\n\t    : \"null\""
          ],
          "line": 1498
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\" accept:     %s\\n\"",
            "accept_cmd ? accept_cmd\n\t    : \"null\""
          ],
          "line": 1496
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\" stunnel:    %d\\n\"",
            "use_stunnel"
          ],
          "line": 1495
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\" sslverify:  %s\\n\"",
            "ssl_verify ? ssl_verify:\"null\""
          ],
          "line": 1494
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\" ssltimeout  %d\\n\"",
            "ssl_timeout_secs"
          ],
          "line": 1493
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\" ssldir:     %s\\n\"",
            "ssl_certs_dir ? ssl_certs_dir:\"null\""
          ],
          "line": 1492
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\" ssl:        %s\\n\"",
            "openssl_pem ? openssl_pem:\"null\""
          ],
          "line": 1491
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\" unixpw_lst: %s\\n\"",
            "unixpw_list ? unixpw_list:\"null\""
          ],
          "line": 1490
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\" unixpw:     %d\\n\"",
            "unixpw"
          ],
          "line": 1489
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\" passfile:   %s\\n\"",
            "passwdfile ? passwdfile\n\t    : \"null\""
          ],
          "line": 1487
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\" input:      %s\\n\"",
            "allowed_input_str\n\t    ? allowed_input_str : \"null\""
          ],
          "line": 1485
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\" allow:      %s\\n\"",
            "allow_list ? allow_list\n\t    : \"null\""
          ],
          "line": 1483
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\" vnc_conn:   %d\\n\"",
            "vnc_connect"
          ],
          "line": 1482
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\" connectfile %s\\n\"",
            "client_connect_file\n\t    ? client_connect_file : \"null\""
          ],
          "line": 1480
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\" connect:    %s\\n\"",
            "client_connect\n\t    ? client_connect : \"null\""
          ],
          "line": 1478
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\" http:       %d\\n\"",
            "try_http"
          ],
          "line": 1477
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\" tightfilexfer:   %d\\n\"",
            "tightfilexfer"
          ],
          "line": 1476
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\" inetd:      %d\\n\"",
            "inetd"
          ],
          "line": 1475
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\" ping:       %d\\n\"",
            "ping_interval"
          ],
          "line": 1474
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\" timeout:    %d\\n\"",
            "first_conn_timeout"
          ],
          "line": 1473
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\" conn_once:  %d\\n\"",
            "connect_once"
          ],
          "line": 1472
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\" shared:     %d\\n\"",
            "shared"
          ],
          "line": 1471
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\" viewonly:   %d\\n\"",
            "view_only"
          ],
          "line": 1470
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\" scaling:    %d %.4f %.4f\\n\"",
            "scaling",
            "scale_fac_x",
            "scale_fac_y"
          ],
          "line": 1469
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\" ovl_cursor: %d\\n\"",
            "overlay_cursor"
          ],
          "line": 1468
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\" overlay:    %d\\n\"",
            "overlay"
          ],
          "line": 1467
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\" visual:     %s\\n\"",
            "visual_str ? visual_str\n\t    : \"null\""
          ],
          "line": 1465
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\" 24to32:     %d\\n\"",
            "xform24to32"
          ],
          "line": 1464
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\" 8to24_opts: %s\\n\"",
            "cmap8to24_str ? cmap8to24_str\n\t    : \"null\""
          ],
          "line": 1462
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\" cmap8to24:  %d\\n\"",
            "cmap8to24"
          ],
          "line": 1461
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\" force_idx:  %d\\n\"",
            "force_indexed_color"
          ],
          "line": 1460
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\" shiftcmap:  %d\\n\"",
            "shift_cmap"
          ],
          "line": 1459
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\" flashcmap:  %d\\n\"",
            "flash_cmap"
          ],
          "line": 1458
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\" clip:       %s\\n\"",
            "clip_str ? clip_str\n\t    : \"null\""
          ],
          "line": 1456
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\" -sid mode:  %d\\n\"",
            "rootshift"
          ],
          "line": 1455
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\" subwin:     0x%lx\\n\"",
            "subwin"
          ],
          "line": 1454
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\" authfile:   %s\\n\"",
            "auth_file ? auth_file\n\t    : \"null\""
          ],
          "line": 1452
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\" display:    %s\\n\"",
            "use_dpy ? use_dpy\n\t    : \"null\""
          ],
          "line": 1449
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Settings:\\n\""
          ],
          "line": 1448
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"\\n\""
          ],
          "line": 1447
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xi2_devices.h\"\n#include \"solid.h\"\n#include \"pm.h\"\n#include \"selection.h\"\n#include \"sslhelper.h\"\n#include \"sslcmds.h\"\n#include \"inet.h\"\n#include \"unixpw.h\"\n#include \"rates.h\"\n#include \"connections.h\"\n#include \"screen.h\"\n#include \"userinput.h\"\n#include \"cursor.h\"\n#include \"pointer.h\"\n#include \"keyboard.h\"\n#include \"cleanup.h\"\n#include \"user.h\"\n#include \"help.h\"\n#include \"gui.h\"\n#include \"scan.h\"\n#include \"remote.h\"\n#include \"win_utils.h\"\n#include \"xkb_bell.h\"\n#include \"xrandr.h\"\n#include \"xinerama.h\"\n#include \"xevents.h\"\n#include \"xrecord.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nstatic void print_settings(int try_http, int bg, char *gui_str);\n\nstatic void print_settings(int try_http, int bg, char *gui_str) {\n\n\tfprintf(stderr, \"\\n\");\n\tfprintf(stderr, \"Settings:\\n\");\n\tfprintf(stderr, \" display:    %s\\n\", use_dpy ? use_dpy\n\t    : \"null\");\n#if SMALL_FOOTPRINT < 2\n\tfprintf(stderr, \" authfile:   %s\\n\", auth_file ? auth_file\n\t    : \"null\");\n\tfprintf(stderr, \" subwin:     0x%lx\\n\", subwin);\n\tfprintf(stderr, \" -sid mode:  %d\\n\", rootshift);\n\tfprintf(stderr, \" clip:       %s\\n\", clip_str ? clip_str\n\t    : \"null\");\n\tfprintf(stderr, \" flashcmap:  %d\\n\", flash_cmap);\n\tfprintf(stderr, \" shiftcmap:  %d\\n\", shift_cmap);\n\tfprintf(stderr, \" force_idx:  %d\\n\", force_indexed_color);\n\tfprintf(stderr, \" cmap8to24:  %d\\n\", cmap8to24);\n\tfprintf(stderr, \" 8to24_opts: %s\\n\", cmap8to24_str ? cmap8to24_str\n\t    : \"null\");\n\tfprintf(stderr, \" 24to32:     %d\\n\", xform24to32);\n\tfprintf(stderr, \" visual:     %s\\n\", visual_str ? visual_str\n\t    : \"null\");\n\tfprintf(stderr, \" overlay:    %d\\n\", overlay);\n\tfprintf(stderr, \" ovl_cursor: %d\\n\", overlay_cursor);\n\tfprintf(stderr, \" scaling:    %d %.4f %.4f\\n\", scaling, scale_fac_x, scale_fac_y);\n\tfprintf(stderr, \" viewonly:   %d\\n\", view_only);\n\tfprintf(stderr, \" shared:     %d\\n\", shared);\n\tfprintf(stderr, \" conn_once:  %d\\n\", connect_once);\n\tfprintf(stderr, \" timeout:    %d\\n\", first_conn_timeout);\n\tfprintf(stderr, \" ping:       %d\\n\", ping_interval);\n\tfprintf(stderr, \" inetd:      %d\\n\", inetd);\n\tfprintf(stderr, \" tightfilexfer:   %d\\n\", tightfilexfer);\n\tfprintf(stderr, \" http:       %d\\n\", try_http);\n\tfprintf(stderr, \" connect:    %s\\n\", client_connect\n\t    ? client_connect : \"null\");\n\tfprintf(stderr, \" connectfile %s\\n\", client_connect_file\n\t    ? client_connect_file : \"null\");\n\tfprintf(stderr, \" vnc_conn:   %d\\n\", vnc_connect);\n\tfprintf(stderr, \" allow:      %s\\n\", allow_list ? allow_list\n\t    : \"null\");\n\tfprintf(stderr, \" input:      %s\\n\", allowed_input_str\n\t    ? allowed_input_str : \"null\");\n\tfprintf(stderr, \" passfile:   %s\\n\", passwdfile ? passwdfile\n\t    : \"null\");\n\tfprintf(stderr, \" unixpw:     %d\\n\", unixpw);\n\tfprintf(stderr, \" unixpw_lst: %s\\n\", unixpw_list ? unixpw_list:\"null\");\n\tfprintf(stderr, \" ssl:        %s\\n\", openssl_pem ? openssl_pem:\"null\");\n\tfprintf(stderr, \" ssldir:     %s\\n\", ssl_certs_dir ? ssl_certs_dir:\"null\");\n\tfprintf(stderr, \" ssltimeout  %d\\n\", ssl_timeout_secs);\n\tfprintf(stderr, \" sslverify:  %s\\n\", ssl_verify ? ssl_verify:\"null\");\n\tfprintf(stderr, \" stunnel:    %d\\n\", use_stunnel);\n\tfprintf(stderr, \" accept:     %s\\n\", accept_cmd ? accept_cmd\n\t    : \"null\");\n\tfprintf(stderr, \" accept:     %s\\n\", afteraccept_cmd ? afteraccept_cmd\n\t    : \"null\");\n\tfprintf(stderr, \" gone:       %s\\n\", gone_cmd ? gone_cmd\n\t    : \"null\");\n\tfprintf(stderr, \" users:      %s\\n\", users_list ? users_list\n\t    : \"null\");\n\tfprintf(stderr, \" using_shm:  %d\\n\", using_shm);\n\tfprintf(stderr, \" flipbytes:  %d\\n\", flip_byte_order);\n\tfprintf(stderr, \" onetile:    %d\\n\", single_copytile);\n\tfprintf(stderr, \" solid:      %s\\n\", solid_str\n\t    ? solid_str : \"null\");\n\tfprintf(stderr, \" blackout:   %s\\n\", blackout_str\n\t    ? blackout_str : \"null\");\n\tfprintf(stderr, \" xinerama:   %d\\n\", xinerama);\n\tfprintf(stderr, \" xtrap:      %d\\n\", xtrap_input);\n\tfprintf(stderr, \" xrandr:     %d\\n\", xrandr);\n\tfprintf(stderr, \" xrandrmode: %s\\n\", xrandr_mode ? xrandr_mode\n\t    : \"null\");\n\tfprintf(stderr, \" padgeom:    %s\\n\", pad_geometry\n\t    ? pad_geometry : \"null\");\n\tfprintf(stderr, \" logfile:    %s\\n\", logfile ? logfile\n\t    : \"null\");\n\tfprintf(stderr, \" logappend:  %d\\n\", logfile_append);\n\tfprintf(stderr, \" flag:       %s\\n\", flagfile ? flagfile\n\t    : \"null\");\n\tfprintf(stderr, \" rm_flag:    %s\\n\", rm_flagfile ? rm_flagfile\n\t    : \"null\");\n\tfprintf(stderr, \" rc_file:    \\\"%s\\\"\\n\", rc_rcfile ? rc_rcfile\n\t    : \"null\");\n\tfprintf(stderr, \" norc:       %d\\n\", rc_norc);\n\tfprintf(stderr, \" dbg:        %d\\n\", crash_debug);\n\tfprintf(stderr, \" bg:         %d\\n\", bg);\n\tfprintf(stderr, \" mod_tweak:  %d\\n\", use_modifier_tweak);\n\tfprintf(stderr, \" isolevel3:  %d\\n\", use_iso_level3);\n\tfprintf(stderr, \" xkb:        %d\\n\", use_xkb_modtweak);\n\tfprintf(stderr, \" skipkeys:   %s\\n\",\n\t    skip_keycodes ? skip_keycodes : \"null\");\n\tfprintf(stderr, \" sloppykeys: %d\\n\", sloppy_keys);\n\tfprintf(stderr, \" skip_dups:  %d\\n\", skip_duplicate_key_events);\n\tfprintf(stderr, \" addkeysyms: %d\\n\", add_keysyms);\n\tfprintf(stderr, \" xkbcompat:  %d\\n\", xkbcompat);\n\tfprintf(stderr, \" clearmods:  %d\\n\", clear_mods);\n\tfprintf(stderr, \" remap:      %s\\n\", remap_file ? remap_file\n\t    : \"null\");\n\tfprintf(stderr, \" norepeat:   %d\\n\", no_autorepeat);\n\tfprintf(stderr, \" norepeatcnt:%d\\n\", no_repeat_countdown);\n\tfprintf(stderr, \" nofb:       %d\\n\", nofb);\n\tfprintf(stderr, \" watchbell:  %d\\n\", watch_bell);\n\tfprintf(stderr, \" watchsel:   %d\\n\", watch_selection);\n\tfprintf(stderr, \" watchprim:  %d\\n\", watch_primary);\n\tfprintf(stderr, \" seldir:     %s\\n\", sel_direction ?\n\t    sel_direction : \"null\");\n\tfprintf(stderr, \" cursor:     %d\\n\", show_cursor);\n\tfprintf(stderr, \" multicurs:  %d\\n\", show_multiple_cursors);\n\tfprintf(stderr, \" curs_mode:  %s\\n\", multiple_cursors_mode\n\t    ? multiple_cursors_mode : \"null\");\n\tfprintf(stderr, \" arrow:      %d\\n\", alt_arrow);\n\tfprintf(stderr, \" xfixes:     %d\\n\", use_xfixes);\n\tfprintf(stderr, \" alphacut:   %d\\n\", alpha_threshold);\n\tfprintf(stderr, \" alphafrac:  %.2f\\n\", alpha_frac);\n\tfprintf(stderr, \" alpharemove:%d\\n\", alpha_remove);\n\tfprintf(stderr, \" alphablend: %d\\n\", alpha_blend);\n\tfprintf(stderr, \" cursorshape:%d\\n\", cursor_shape_updates);\n\tfprintf(stderr, \" cursorpos:  %d\\n\", cursor_pos_updates);\n\tfprintf(stderr, \" xwarpptr:   %d\\n\", use_xwarppointer);\n\tfprintf(stderr, \" alwaysinj:  %d\\n\", always_inject);\n\tfprintf(stderr, \" buttonmap:  %s\\n\", pointer_remap\n\t    ? pointer_remap : \"null\");\n\tfprintf(stderr, \" dragging:   %d\\n\", show_dragging);\n\tfprintf(stderr, \" ncache:     %d\\n\", ncache);\n\tfprintf(stderr, \" wireframe:  %s\\n\", wireframe_str ?\n\t    wireframe_str : WIREFRAME_PARMS);\n\tfprintf(stderr, \" wirecopy:   %s\\n\", wireframe_copyrect ?\n\t    wireframe_copyrect : wireframe_copyrect_default);\n\tfprintf(stderr, \" scrollcopy: %s\\n\", scroll_copyrect ?\n\t    scroll_copyrect : scroll_copyrect_default);\n\tfprintf(stderr, \"  scr_area:  %d\\n\", scrollcopyrect_min_area);\n\tfprintf(stderr, \"  scr_skip:  %s\\n\", scroll_skip_str ?\n\t    scroll_skip_str : scroll_skip_str0);\n\tfprintf(stderr, \"  scr_inc:   %s\\n\", scroll_good_str ?\n\t    scroll_good_str : scroll_good_str0);\n\tfprintf(stderr, \"  scr_keys:  %s\\n\", scroll_key_list_str ?\n\t    scroll_key_list_str : \"null\");\n\tfprintf(stderr, \"  scr_term:  %s\\n\", scroll_term_str ?\n\t    scroll_term_str : \"null\");\n\tfprintf(stderr, \"  scr_keyrep: %s\\n\", max_keyrepeat_str ?\n\t    max_keyrepeat_str : \"null\");\n\tfprintf(stderr, \"  scr_parms: %s\\n\", scroll_copyrect_str ?\n\t    scroll_copyrect_str : SCROLL_COPYRECT_PARMS);\n\tfprintf(stderr, \" fixscreen:  %s\\n\", screen_fixup_str ?\n\t    screen_fixup_str : \"null\");\n\tfprintf(stderr, \" noxrecord:  %d\\n\", noxrecord);\n\tfprintf(stderr, \" grabbuster: %d\\n\", grab_buster);\n\tfprintf(stderr, \" ptr_mode:   %d\\n\", pointer_mode);\n\tfprintf(stderr, \" inputskip:  %d\\n\", ui_skip);\n\tfprintf(stderr, \" speeds:     %s\\n\", speeds_str\n\t    ? speeds_str : \"null\");\n\tfprintf(stderr, \" wmdt:       %s\\n\", wmdt_str\n\t    ? wmdt_str : \"null\");\n\tfprintf(stderr, \" debug_ptr:  %d\\n\", debug_pointer);\n\tfprintf(stderr, \" debug_key:  %d\\n\", debug_keyboard);\n\tfprintf(stderr, \" defer:      %d\\n\", defer_update);\n\tfprintf(stderr, \" waitms:     %d\\n\", waitms);\n\tfprintf(stderr, \" wait_ui:    %.2f\\n\", wait_ui);\n\tfprintf(stderr, \" nowait_bog: %d\\n\", !wait_bog);\n\tfprintf(stderr, \" slow_fb:    %.2f\\n\", slow_fb);\n\tfprintf(stderr, \" xrefresh:   %.2f\\n\", xrefresh);\n\tfprintf(stderr, \" readtimeout: %d\\n\", rfbMaxClientWait/1000);\n\tfprintf(stderr, \" take_naps:  %d\\n\", take_naps);\n\tfprintf(stderr, \" sb:         %d\\n\", screen_blank);\n\tfprintf(stderr, \" fbpm:       %d\\n\", !watch_fbpm);\n\tfprintf(stderr, \" dpms:       %d\\n\", !watch_dpms);\n\tfprintf(stderr, \" xdamage:    %d\\n\", use_xdamage);\n\tfprintf(stderr, \"  xd_area:   %d\\n\", xdamage_max_area);\n\tfprintf(stderr, \"  xd_mem:    %.3f\\n\", xdamage_memory);\n\tfprintf(stderr, \" xcomposite: %d\\n\", use_xcomposite);\n#ifdef HAVE_XI2\n\tfprintf(stderr, \" multiptr:   %d\\n\", use_multipointer);\n#endif\n\tfprintf(stderr, \" sigpipe:    %s\\n\", sigpipe\n\t    ? sigpipe : \"null\");\n\tfprintf(stderr, \" threads:    %d\\n\", use_threads);\n\tfprintf(stderr, \" fs_frac:    %.2f\\n\", fs_frac);\n\tfprintf(stderr, \" gaps_fill:  %d\\n\", gaps_fill);\n\tfprintf(stderr, \" grow_fill:  %d\\n\", grow_fill);\n\tfprintf(stderr, \" tile_fuzz:  %d\\n\", tile_fuzz);\n\tfprintf(stderr, \" snapfb:     %d\\n\", use_snapfb);\n\tfprintf(stderr, \" rawfb:      %s\\n\", raw_fb_str\n\t    ? raw_fb_str : \"null\");\n\tfprintf(stderr, \" pipeinput:  %s\\n\", pipeinput_str\n\t    ? pipeinput_str : \"null\");\n\tfprintf(stderr, \" gui:        %d\\n\", launch_gui);\n\tfprintf(stderr, \" gui_mode:   %s\\n\", gui_str\n\t    ? gui_str : \"null\");\n\tfprintf(stderr, \" noremote:   %d\\n\", !accept_remote_cmds);\n\tfprintf(stderr, \" unsafe:     %d\\n\", !safe_remote_only);\n\tfprintf(stderr, \" privremote: %d\\n\", priv_remote);\n\tfprintf(stderr, \" safer:      %d\\n\", more_safe);\n\tfprintf(stderr, \" nocmds:     %d\\n\", no_external_cmds);\n\tfprintf(stderr, \" deny_all:   %d\\n\", deny_all);\n\tfprintf(stderr, \" pid:        %d\\n\", getpid());\n\tfprintf(stderr, \"\\n\");\n#endif\n}"
  },
  {
    "function_name": "quick_pw",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/x11vnc.c",
    "lines": "1331-1443",
    "snippet": "static void quick_pw(char *str) {\n\tchar *p, *q;\n\tchar tmp[1024];\n\tint db = 0;\n\n\tif (db) fprintf(stderr, \"quick_pw: %s\\n\", str);\n\n\tif (! str || str[0] == '\\0') {\n\t\texit(2);\n\t}\n\tif (str[0] != '%') {\n\t\texit(2);\n\t}\n\t/*\n\t * \"%-\" or \"%stdin\" means read one line from stdin.\n\t *\n\t * \"%env\" means it is in $UNIXPW env var.\n\t *\n\t * starting \"%/\" or \"%.\" means read the first line from that file.\n\t *\n\t * \"%%\" or \"%\" means prompt user.\n\t *\n\t * otherwise: %user:pass\n\t */\n\tif (!strcmp(str, \"%-\") || !strcmp(str, \"%stdin\")) {\n\t\tif(fgets(tmp, 1024, stdin) == NULL) {\n\t\t\texit(2);\n\t\t}\n\t\tq = strdup(tmp);\n\t} else if (!strcmp(str, \"%env\")) {\n\t\tif (getenv(\"UNIXPW\") == NULL) {\n\t\t\texit(2);\n\t\t}\n\t\tq = strdup(getenv(\"UNIXPW\"));\n\t} else if (!strcmp(str, \"%%\") || !strcmp(str, \"%\")) {\n\t\tchar *t, inp[1024];\n\t\tfprintf(stdout, \"username: \");\n\t\tif(fgets(tmp, 128, stdin) == NULL) {\n\t\t\texit(2);\n\t\t}\n\t\tstrcpy(inp, tmp);\n\t\tt = strchr(inp, '\\n');\n\t\tif (t) {\n\t\t\t*t = ':'; \n\t\t} else {\n\t\t\tstrcat(inp, \":\");\n\t\t\t\n\t\t}\n\t\tfprintf(stdout, \"password: \");\n\t\t/* test mode: no_external_cmds does not apply */\n\t\tsystem(\"stty -echo\");\n\t\tif(fgets(tmp, 128, stdin) == NULL) {\n\t\t\tfprintf(stdout, \"\\n\");\n\t\t\tsystem(\"stty echo\");\n\t\t\texit(2);\n\t\t}\n\t\tsystem(\"stty echo\");\n\t\tfprintf(stdout, \"\\n\");\n\t\tstrcat(inp, tmp);\n\t\tq = strdup(inp);\n\t} else if (str[1] == '/' || str[1] == '.') {\n\t\tFILE *in = fopen(str+1, \"r\");\n\t\tif (in == NULL) {\n\t\t\texit(2);\n\t\t}\n\t\tif(fgets(tmp, 1024, in) == NULL) {\n\t\t\texit(2);\n\t\t}\n\t\tfclose(in);\n\t\tq = strdup(tmp);\n\t} else {\n\t\tq = strdup(str+1);\n\t}\n\tp = (char *) malloc(strlen(q) + 10);\n\tstrcpy(p, q);\n\tif (strchr(p, '\\n') == NULL) {\n\t\tstrcat(p, \"\\n\");\n\t}\n\n\tif ((q = strchr(p, ':')) == NULL) {\n\t\texit(2);\n\t}\n\t*q = '\\0';\n\tif (db) fprintf(stderr, \"'%s' '%s'\\n\", p, q+1);\n\tif (unixpw_cmd) {\n\t\tif (cmd_verify(p, q+1)) {\n\t\t\tfprintf(stdout, \"Y %s\\n\", p);\n\t\t\texit(0);\n\t\t} else {\n\t\t\tfprintf(stdout, \"N %s\\n\", p);\n\t\t\texit(1);\n\t\t}\n\t} else if (unixpw_nis) {\n\t\tif (crypt_verify(p, q+1)) {\n\t\t\tfprintf(stdout, \"Y %s\\n\", p);\n\t\t\texit(0);\n\t\t} else {\n\t\t\tfprintf(stdout, \"N %s\\n\", p);\n\t\t\texit(1);\n\t\t}\n\t} else {\n\t\tchar *ucmd = getenv(\"UNIXPW_CMD\");\n\t\tif (su_verify(p, q+1, ucmd, NULL, NULL, 1)) {\n\t\t\tfprintf(stdout, \"Y %s\\n\", p);\n\t\t\texit(0);\n\t\t} else {\n\t\t\tfprintf(stdout, \"N %s\\n\", p);\n\t\t\texit(1);\n\t\t}\n\t}\n\t/* NOTREACHED */\n\texit(2);\n}",
    "includes": [
      "#include \"xi2_devices.h\"",
      "#include \"solid.h\"",
      "#include \"pm.h\"",
      "#include \"selection.h\"",
      "#include \"sslhelper.h\"",
      "#include \"sslcmds.h\"",
      "#include \"inet.h\"",
      "#include \"unixpw.h\"",
      "#include \"rates.h\"",
      "#include \"connections.h\"",
      "#include \"screen.h\"",
      "#include \"userinput.h\"",
      "#include \"cursor.h\"",
      "#include \"pointer.h\"",
      "#include \"keyboard.h\"",
      "#include \"cleanup.h\"",
      "#include \"user.h\"",
      "#include \"help.h\"",
      "#include \"gui.h\"",
      "#include \"scan.h\"",
      "#include \"remote.h\"",
      "#include \"win_utils.h\"",
      "#include \"xkb_bell.h\"",
      "#include \"xrandr.h\"",
      "#include \"xinerama.h\"",
      "#include \"xevents.h\"",
      "#include \"xrecord.h\"",
      "#include \"xdamage.h\"",
      "#include \"xwrappers.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "2"
          ],
          "line": 1442
        },
        "resolved": true,
        "details": {
          "function_name": "clean_up_exit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/cleanup.c",
          "lines": "151-266",
          "snippet": "void clean_up_exit(int ret) {\n\tstatic int depth = 0;\n\texit_flag = 1;\n\n\tif (depth++ > 2) {\n\t\texit(ret);\n\t}\n\n\tif (icon_mode) {\n\t\tclean_icon_mode();\n\t}\n\n\t/* remove the shm areas: */\n\tclean_shm(0);\n\n\tstop_stunnel();\n\tif (use_openssl) {\n\t\tssl_helper_pid(0, 0);\t/* killall */\n\t}\n\n\tif (ssh_pid > 0) {\n\t\tkill(ssh_pid, SIGTERM);\n\t\tssh_pid = 0;\n\t}\n\n#ifdef MACOSX\n\tif (client_connect_file) {\n\t\tif (strstr(client_connect_file, \"/tmp/x11vnc-macosx-remote\")\n\t\t    == client_connect_file) {\n\t\t\tunlink(client_connect_file);\n\t\t}\n\t}\n\tif (macosx_console) {\n\t\tmacosxCG_fini();\n\t}\n#endif\n\n\tif (pipeinput_fh != NULL) {\n\t\tpclose(pipeinput_fh);\n\t\tpipeinput_fh = NULL;\n\t}\n\n\tshutdown_uinput();\n\n\tif (unix_sock) {\n\t\tif (unix_sock_fd >= 0) {\n\t\t\trfbLog(\"deleting unix sock: %s\\n\", unix_sock);\n\t\t\tclose(unix_sock_fd);\n\t\t\tunix_sock_fd = -1;\n\t\t\tunlink(unix_sock);\n\t\t}\n\t}\n\n\tif (! dpy) {\t/* raw_rb hack */\n\t\tif (rm_flagfile) {\n\t\t\tunlink(rm_flagfile);\n\t\t\trm_flagfile = NULL;\n\t\t}\n\t\texit(ret);\n\t}\n\n\t/* X keyboard cleanups */\n\tdelete_added_keycodes(0);\n\n\t/* remove all created XInput2 devices */\n\tif(use_multipointer)\n\t    removeAllMDs(dpy);\n\n\tif (clear_mods == 1) {\n\t\tclear_modifiers(0);\n\t} else if (clear_mods == 2) {\n\t\tclear_keys();\n\t} else if (clear_mods == 3) {\n\t\tclear_keys();\n\t\tclear_locks();\n\t}\n\n\tif (no_autorepeat) {\n\t\tautorepeat(1, 0);\n\t}\n\tif (use_solid_bg) {\n\t\tsolid_bg(1);\n\t}\n\tif (ncache || ncache0) {\n\t\tkde_no_animate(1);\n\t}\n\tX_LOCK;\n\tXTestDiscard_wr(dpy);\n#if HAVE_LIBXDAMAGE\n\tif (xdamage) {\n\t\tXDamageDestroy(dpy, xdamage);\n\t}\n#endif\n#if HAVE_LIBXTRAP\n\tif (trap_ctx) {\n\t\tXEFreeTC(trap_ctx);\n\t}\n#endif\n\t/* XXX rdpy_ctrl, etc. cannot close w/o blocking */\n\tXCloseDisplay_wr(dpy);\n\tX_UNLOCK;\n\n\tfflush(stderr);\n\n\tif (rm_flagfile) {\n\t\tunlink(rm_flagfile);\n\t\trm_flagfile = NULL;\n\t}\n\n\tif (avahi) {\n\t\tavahi_cleanup();\n\t\tfflush(stderr);\n\t}\n\n\texit(ret);\n}",
          "includes": [
            "#include \"xi2_devices.h\"",
            "#include \"uinput.h\"",
            "#include \"xevents.h\"",
            "#include \"xrecord.h\"",
            "#include \"screen.h\"",
            "#include \"avahi.h\"",
            "#include \"macosxCG.h\"",
            "#include \"macosx.h\"",
            "#include \"connections.h\"",
            "#include \"sslhelper.h\"",
            "#include \"sslcmds.h\"",
            "#include \"unixpw.h\"",
            "#include \"solid.h\"",
            "#include \"gui.h\"",
            "#include \"scan.h\"",
            "#include \"keyboard.h\"",
            "#include \"remote.h\"",
            "#include \"xdamage.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void clean_up_exit(int ret);",
            "int known_sigpipe_mode(char *s);",
            "static int exit_flag = 0;",
            "static void clean_icon_mode(void);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xi2_devices.h\"\n#include \"uinput.h\"\n#include \"xevents.h\"\n#include \"xrecord.h\"\n#include \"screen.h\"\n#include \"avahi.h\"\n#include \"macosxCG.h\"\n#include \"macosx.h\"\n#include \"connections.h\"\n#include \"sslhelper.h\"\n#include \"sslcmds.h\"\n#include \"unixpw.h\"\n#include \"solid.h\"\n#include \"gui.h\"\n#include \"scan.h\"\n#include \"keyboard.h\"\n#include \"remote.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nvoid clean_up_exit(int ret);\nint known_sigpipe_mode(char *s);\nstatic int exit_flag = 0;\nstatic void clean_icon_mode(void);\n\nvoid clean_up_exit(int ret) {\n\tstatic int depth = 0;\n\texit_flag = 1;\n\n\tif (depth++ > 2) {\n\t\texit(ret);\n\t}\n\n\tif (icon_mode) {\n\t\tclean_icon_mode();\n\t}\n\n\t/* remove the shm areas: */\n\tclean_shm(0);\n\n\tstop_stunnel();\n\tif (use_openssl) {\n\t\tssl_helper_pid(0, 0);\t/* killall */\n\t}\n\n\tif (ssh_pid > 0) {\n\t\tkill(ssh_pid, SIGTERM);\n\t\tssh_pid = 0;\n\t}\n\n#ifdef MACOSX\n\tif (client_connect_file) {\n\t\tif (strstr(client_connect_file, \"/tmp/x11vnc-macosx-remote\")\n\t\t    == client_connect_file) {\n\t\t\tunlink(client_connect_file);\n\t\t}\n\t}\n\tif (macosx_console) {\n\t\tmacosxCG_fini();\n\t}\n#endif\n\n\tif (pipeinput_fh != NULL) {\n\t\tpclose(pipeinput_fh);\n\t\tpipeinput_fh = NULL;\n\t}\n\n\tshutdown_uinput();\n\n\tif (unix_sock) {\n\t\tif (unix_sock_fd >= 0) {\n\t\t\trfbLog(\"deleting unix sock: %s\\n\", unix_sock);\n\t\t\tclose(unix_sock_fd);\n\t\t\tunix_sock_fd = -1;\n\t\t\tunlink(unix_sock);\n\t\t}\n\t}\n\n\tif (! dpy) {\t/* raw_rb hack */\n\t\tif (rm_flagfile) {\n\t\t\tunlink(rm_flagfile);\n\t\t\trm_flagfile = NULL;\n\t\t}\n\t\texit(ret);\n\t}\n\n\t/* X keyboard cleanups */\n\tdelete_added_keycodes(0);\n\n\t/* remove all created XInput2 devices */\n\tif(use_multipointer)\n\t    removeAllMDs(dpy);\n\n\tif (clear_mods == 1) {\n\t\tclear_modifiers(0);\n\t} else if (clear_mods == 2) {\n\t\tclear_keys();\n\t} else if (clear_mods == 3) {\n\t\tclear_keys();\n\t\tclear_locks();\n\t}\n\n\tif (no_autorepeat) {\n\t\tautorepeat(1, 0);\n\t}\n\tif (use_solid_bg) {\n\t\tsolid_bg(1);\n\t}\n\tif (ncache || ncache0) {\n\t\tkde_no_animate(1);\n\t}\n\tX_LOCK;\n\tXTestDiscard_wr(dpy);\n#if HAVE_LIBXDAMAGE\n\tif (xdamage) {\n\t\tXDamageDestroy(dpy, xdamage);\n\t}\n#endif\n#if HAVE_LIBXTRAP\n\tif (trap_ctx) {\n\t\tXEFreeTC(trap_ctx);\n\t}\n#endif\n\t/* XXX rdpy_ctrl, etc. cannot close w/o blocking */\n\tXCloseDisplay_wr(dpy);\n\tX_UNLOCK;\n\n\tfflush(stderr);\n\n\tif (rm_flagfile) {\n\t\tunlink(rm_flagfile);\n\t\trm_flagfile = NULL;\n\t}\n\n\tif (avahi) {\n\t\tavahi_cleanup();\n\t\tfflush(stderr);\n\t}\n\n\texit(ret);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stdout",
            "\"N %s\\n\"",
            "p"
          ],
          "line": 1437
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stdout",
            "\"Y %s\\n\"",
            "p"
          ],
          "line": 1434
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "su_verify",
          "args": [
            "p",
            "q+1",
            "ucmd",
            "NULL",
            "NULL",
            "1"
          ],
          "line": 1433
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getenv",
          "args": [
            "\"UNIXPW_CMD\""
          ],
          "line": 1432
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stdout",
            "\"N %s\\n\"",
            "p"
          ],
          "line": 1428
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stdout",
            "\"Y %s\\n\"",
            "p"
          ],
          "line": 1425
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "crypt_verify",
          "args": [
            "p",
            "q+1"
          ],
          "line": 1424
        },
        "resolved": true,
        "details": {
          "function_name": "crypt_verify",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/unixpw.c",
          "lines": "759-822",
          "snippet": "int crypt_verify(char *user, char *pass) {\n#if !defined UNIXPW_CRYPT || !defined HAVE_LIBCRYPT\n\treturn 0;\n#else\n\tstruct passwd *pwd;\n\tchar *realpw, *cr;\n\tint n;\n\n\tif (! scheck(user, 100, \"username\")) {\n\t\treturn 0;\n\t}\n\tif (! scheck(pass, 100, \"password\")) {\n\t\treturn 0;\n\t}\n\tif (! unixpw_list_match(user)) {\n\t\treturn 0;\n\t}\n\n\tpwd = getpwnam(user);\n\tif (! pwd) {\n\t\treturn 0;\n\t}\n\n\trealpw = pwd->pw_passwd;\n\tif (realpw == NULL || realpw[0] == '\\0') {\n\t\treturn 0;\n\t}\n\n\tif (db > 1) fprintf(stderr, \"realpw='%s'\\n\", realpw);\n\n\tif (strlen(realpw) < 12) {\n\t\t/* e.g. \"x\", try getspnam(), sometimes root for inetd, etc */\n#if HAVE_GETSPNAM\n\t\tstruct spwd *sp = getspnam(user);\n\t\tif (sp != NULL && sp->sp_pwdp != NULL) {\n\t\t\tif (db) fprintf(stderr, \"using getspnam()\\n\");\n\t\t\trealpw = sp->sp_pwdp;\n\t\t} else {\n\t\t\tif (db) fprintf(stderr, \"skipping getspnam()\\n\");\n\t\t}\n#endif\n\t}\n\n\tn = strlen(pass);\n\tif (pass[n-1] == '\\n') {\n\t\tpass[n-1] = '\\0';\n\t}\n\n\t/* XXX remove need for cast */\n\tcr = (char *) crypt(pass, realpw);\n\tif (db > 1) {\n\t\tfprintf(stderr, \"user='%s' pass='%s' realpw='%s' cr='%s'\\n\",\n\t\t    user, pass, realpw, cr ? cr : \"(null)\");\n\t}\n\tif (cr == NULL || cr[0] == '\\0') {\n\t\treturn 0;\n\t}\n\tif (!strcmp(cr, realpw)) {\n\t\treturn 1;\n\t} else {\n\t\treturn 0;\n\t}\n#endif\t/* UNIXPW_CRYPT */\n}",
          "includes": [
            "#include <sys/stropts.h>",
            "#include <termios.h>",
            "#include <sys/ioctl.h>",
            "#include <shadow.h>",
            "#include \"default8x16.h\"",
            "#include \"rates.h\"",
            "#include \"cursor.h\"",
            "#include \"sslhelper.h\"",
            "#include \"connections.h\"",
            "#include \"user.h\"",
            "#include \"connections.h\"",
            "#include \"xinerama.h\"",
            "#include \"cleanup.h\"",
            "#include \"scan.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [
            "#define UNIXPW_CRYPT",
            "#define HAVE_GETSPNAM 0"
          ],
          "globals_used": [
            "void unixpw_accept(char *user);",
            "int unixpw_cmd_run(char *user, char *pass, char *cmd, char *line, int *n);",
            "int crypt_verify(char *user, char *pass);",
            "int cmd_verify(char *user, char *pass);",
            "void unixpw_verify_screen(char *user, char *pass);",
            "static int db = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/stropts.h>\n#include <termios.h>\n#include <sys/ioctl.h>\n#include <shadow.h>\n#include \"default8x16.h\"\n#include \"rates.h\"\n#include \"cursor.h\"\n#include \"sslhelper.h\"\n#include \"connections.h\"\n#include \"user.h\"\n#include \"connections.h\"\n#include \"xinerama.h\"\n#include \"cleanup.h\"\n#include \"scan.h\"\n#include \"x11vnc.h\"\n\n#define UNIXPW_CRYPT\n#define HAVE_GETSPNAM 0\n\nvoid unixpw_accept(char *user);\nint unixpw_cmd_run(char *user, char *pass, char *cmd, char *line, int *n);\nint crypt_verify(char *user, char *pass);\nint cmd_verify(char *user, char *pass);\nvoid unixpw_verify_screen(char *user, char *pass);\nstatic int db = 0;\n\nint crypt_verify(char *user, char *pass) {\n#if !defined UNIXPW_CRYPT || !defined HAVE_LIBCRYPT\n\treturn 0;\n#else\n\tstruct passwd *pwd;\n\tchar *realpw, *cr;\n\tint n;\n\n\tif (! scheck(user, 100, \"username\")) {\n\t\treturn 0;\n\t}\n\tif (! scheck(pass, 100, \"password\")) {\n\t\treturn 0;\n\t}\n\tif (! unixpw_list_match(user)) {\n\t\treturn 0;\n\t}\n\n\tpwd = getpwnam(user);\n\tif (! pwd) {\n\t\treturn 0;\n\t}\n\n\trealpw = pwd->pw_passwd;\n\tif (realpw == NULL || realpw[0] == '\\0') {\n\t\treturn 0;\n\t}\n\n\tif (db > 1) fprintf(stderr, \"realpw='%s'\\n\", realpw);\n\n\tif (strlen(realpw) < 12) {\n\t\t/* e.g. \"x\", try getspnam(), sometimes root for inetd, etc */\n#if HAVE_GETSPNAM\n\t\tstruct spwd *sp = getspnam(user);\n\t\tif (sp != NULL && sp->sp_pwdp != NULL) {\n\t\t\tif (db) fprintf(stderr, \"using getspnam()\\n\");\n\t\t\trealpw = sp->sp_pwdp;\n\t\t} else {\n\t\t\tif (db) fprintf(stderr, \"skipping getspnam()\\n\");\n\t\t}\n#endif\n\t}\n\n\tn = strlen(pass);\n\tif (pass[n-1] == '\\n') {\n\t\tpass[n-1] = '\\0';\n\t}\n\n\t/* XXX remove need for cast */\n\tcr = (char *) crypt(pass, realpw);\n\tif (db > 1) {\n\t\tfprintf(stderr, \"user='%s' pass='%s' realpw='%s' cr='%s'\\n\",\n\t\t    user, pass, realpw, cr ? cr : \"(null)\");\n\t}\n\tif (cr == NULL || cr[0] == '\\0') {\n\t\treturn 0;\n\t}\n\tif (!strcmp(cr, realpw)) {\n\t\treturn 1;\n\t} else {\n\t\treturn 0;\n\t}\n#endif\t/* UNIXPW_CRYPT */\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stdout",
            "\"N %s\\n\"",
            "p"
          ],
          "line": 1420
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stdout",
            "\"Y %s\\n\"",
            "p"
          ],
          "line": 1417
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cmd_verify",
          "args": [
            "p",
            "q+1"
          ],
          "line": 1416
        },
        "resolved": true,
        "details": {
          "function_name": "cmd_verify",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/unixpw.c",
          "lines": "900-954",
          "snippet": "int cmd_verify(char *user, char *pass) {\n\tint i, len, rc;\n\tchar *str;\n\n\tif (! user || ! pass) {\n\t\treturn 0;\n\t}\n\tif (! unixpw_cmd || *unixpw_cmd == '\\0') {\n\t\treturn 0;\n\t}\n\n\tif (! scheck(user, 100, \"username\")) {\n\t\treturn 0;\n\t}\n\tif (! scheck(pass, 100, \"password\")) {\n\t\treturn 0;\n\t}\n\tif (! unixpw_list_match(user)) {\n\t\treturn 0;\n\t}\n\n\tif (unixpw_client) {\n\t\tClientData *cd = (ClientData *) unixpw_client->clientData;\n\t\tif (cd) {\n\t\t\tcd->username = strdup(user);\n\t\t}\n\t}\n\n\tlen = strlen(user) + 1 + strlen(pass) + 1 + 1;\n\tstr = (char *) malloc(len);\n\tif (! str) {\n\t\treturn 0;\n\t}\n\tstr[0] = '\\0';\n\tstrcat(str, user);\n\tstrcat(str, \"\\n\");\n\tstrcat(str, pass);\n\tif (!strchr(pass, '\\n')) {\n\t\tstrcat(str, \"\\n\");\n\t}\n\n\trc = run_user_command(unixpw_cmd, unixpw_client, \"cmd_verify\",\n\t    str, strlen(str), NULL);\n\n\tfor (i=0; i < len; i++) {\n\t\tstr[i] = '\\0';\n\t}\n\tfree(str);\n\n\tif (rc == 0) {\n\t\treturn 1;\n\t} else {\n\t\treturn 0;\n\t}\n}",
          "includes": [
            "#include <sys/stropts.h>",
            "#include <termios.h>",
            "#include <sys/ioctl.h>",
            "#include <shadow.h>",
            "#include \"default8x16.h\"",
            "#include \"rates.h\"",
            "#include \"cursor.h\"",
            "#include \"sslhelper.h\"",
            "#include \"connections.h\"",
            "#include \"user.h\"",
            "#include \"connections.h\"",
            "#include \"xinerama.h\"",
            "#include \"cleanup.h\"",
            "#include \"scan.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void unixpw_accept(char *user);",
            "int unixpw_cmd_run(char *user, char *pass, char *cmd, char *line, int *n);",
            "int crypt_verify(char *user, char *pass);",
            "int cmd_verify(char *user, char *pass);",
            "void unixpw_verify_screen(char *user, char *pass);",
            "rfbClientPtr unixpw_client = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/stropts.h>\n#include <termios.h>\n#include <sys/ioctl.h>\n#include <shadow.h>\n#include \"default8x16.h\"\n#include \"rates.h\"\n#include \"cursor.h\"\n#include \"sslhelper.h\"\n#include \"connections.h\"\n#include \"user.h\"\n#include \"connections.h\"\n#include \"xinerama.h\"\n#include \"cleanup.h\"\n#include \"scan.h\"\n#include \"x11vnc.h\"\n\nvoid unixpw_accept(char *user);\nint unixpw_cmd_run(char *user, char *pass, char *cmd, char *line, int *n);\nint crypt_verify(char *user, char *pass);\nint cmd_verify(char *user, char *pass);\nvoid unixpw_verify_screen(char *user, char *pass);\nrfbClientPtr unixpw_client = NULL;\n\nint cmd_verify(char *user, char *pass) {\n\tint i, len, rc;\n\tchar *str;\n\n\tif (! user || ! pass) {\n\t\treturn 0;\n\t}\n\tif (! unixpw_cmd || *unixpw_cmd == '\\0') {\n\t\treturn 0;\n\t}\n\n\tif (! scheck(user, 100, \"username\")) {\n\t\treturn 0;\n\t}\n\tif (! scheck(pass, 100, \"password\")) {\n\t\treturn 0;\n\t}\n\tif (! unixpw_list_match(user)) {\n\t\treturn 0;\n\t}\n\n\tif (unixpw_client) {\n\t\tClientData *cd = (ClientData *) unixpw_client->clientData;\n\t\tif (cd) {\n\t\t\tcd->username = strdup(user);\n\t\t}\n\t}\n\n\tlen = strlen(user) + 1 + strlen(pass) + 1 + 1;\n\tstr = (char *) malloc(len);\n\tif (! str) {\n\t\treturn 0;\n\t}\n\tstr[0] = '\\0';\n\tstrcat(str, user);\n\tstrcat(str, \"\\n\");\n\tstrcat(str, pass);\n\tif (!strchr(pass, '\\n')) {\n\t\tstrcat(str, \"\\n\");\n\t}\n\n\trc = run_user_command(unixpw_cmd, unixpw_client, \"cmd_verify\",\n\t    str, strlen(str), NULL);\n\n\tfor (i=0; i < len; i++) {\n\t\tstr[i] = '\\0';\n\t}\n\tfree(str);\n\n\tif (rc == 0) {\n\t\treturn 1;\n\t} else {\n\t\treturn 0;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"'%s' '%s'\\n\"",
            "p",
            "q+1"
          ],
          "line": 1414
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "p",
            "':'"
          ],
          "line": 1410
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcat",
          "args": [
            "p",
            "\"\\n\""
          ],
          "line": 1407
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "p",
            "'\\n'"
          ],
          "line": 1406
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcpy",
          "args": [
            "p",
            "q"
          ],
          "line": 1405
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "strlen(q) + 10"
          ],
          "line": 1404
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "q"
          ],
          "line": 1404
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "str+1"
          ],
          "line": 1402
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "tmp"
          ],
          "line": 1400
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fclose",
          "args": [
            "in"
          ],
          "line": 1399
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fgets",
          "args": [
            "tmp",
            "1024",
            "in"
          ],
          "line": 1396
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fopen",
          "args": [
            "str+1",
            "\"r\""
          ],
          "line": 1392
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "inp"
          ],
          "line": 1390
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcat",
          "args": [
            "inp",
            "tmp"
          ],
          "line": 1389
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stdout",
            "\"\\n\""
          ],
          "line": 1388
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "system",
          "args": [
            "\"stty echo\""
          ],
          "line": 1387
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "system",
          "args": [
            "\"stty echo\""
          ],
          "line": 1384
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stdout",
            "\"\\n\""
          ],
          "line": 1383
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fgets",
          "args": [
            "tmp",
            "128",
            "stdin"
          ],
          "line": 1382
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "system",
          "args": [
            "\"stty -echo\""
          ],
          "line": 1381
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stdout",
            "\"password: \""
          ],
          "line": 1379
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcat",
          "args": [
            "inp",
            "\":\""
          ],
          "line": 1376
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "inp",
            "'\\n'"
          ],
          "line": 1372
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcpy",
          "args": [
            "inp",
            "tmp"
          ],
          "line": 1371
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fgets",
          "args": [
            "tmp",
            "128",
            "stdin"
          ],
          "line": 1368
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stdout",
            "\"username: \""
          ],
          "line": 1367
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "str",
            "\"%\""
          ],
          "line": 1365
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "str",
            "\"%%\""
          ],
          "line": 1365
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "getenv(\"UNIXPW\")"
          ],
          "line": 1364
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getenv",
          "args": [
            "\"UNIXPW\""
          ],
          "line": 1364
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getenv",
          "args": [
            "\"UNIXPW\""
          ],
          "line": 1361
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "str",
            "\"%env\""
          ],
          "line": 1360
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "tmp"
          ],
          "line": 1359
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fgets",
          "args": [
            "tmp",
            "1024",
            "stdin"
          ],
          "line": 1356
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "str",
            "\"%stdin\""
          ],
          "line": 1355
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "str",
            "\"%-\""
          ],
          "line": 1355
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"quick_pw: %s\\n\"",
            "str"
          ],
          "line": 1336
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xi2_devices.h\"\n#include \"solid.h\"\n#include \"pm.h\"\n#include \"selection.h\"\n#include \"sslhelper.h\"\n#include \"sslcmds.h\"\n#include \"inet.h\"\n#include \"unixpw.h\"\n#include \"rates.h\"\n#include \"connections.h\"\n#include \"screen.h\"\n#include \"userinput.h\"\n#include \"cursor.h\"\n#include \"pointer.h\"\n#include \"keyboard.h\"\n#include \"cleanup.h\"\n#include \"user.h\"\n#include \"help.h\"\n#include \"gui.h\"\n#include \"scan.h\"\n#include \"remote.h\"\n#include \"win_utils.h\"\n#include \"xkb_bell.h\"\n#include \"xrandr.h\"\n#include \"xinerama.h\"\n#include \"xevents.h\"\n#include \"xrecord.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nstatic void quick_pw(char *str) {\n\tchar *p, *q;\n\tchar tmp[1024];\n\tint db = 0;\n\n\tif (db) fprintf(stderr, \"quick_pw: %s\\n\", str);\n\n\tif (! str || str[0] == '\\0') {\n\t\texit(2);\n\t}\n\tif (str[0] != '%') {\n\t\texit(2);\n\t}\n\t/*\n\t * \"%-\" or \"%stdin\" means read one line from stdin.\n\t *\n\t * \"%env\" means it is in $UNIXPW env var.\n\t *\n\t * starting \"%/\" or \"%.\" means read the first line from that file.\n\t *\n\t * \"%%\" or \"%\" means prompt user.\n\t *\n\t * otherwise: %user:pass\n\t */\n\tif (!strcmp(str, \"%-\") || !strcmp(str, \"%stdin\")) {\n\t\tif(fgets(tmp, 1024, stdin) == NULL) {\n\t\t\texit(2);\n\t\t}\n\t\tq = strdup(tmp);\n\t} else if (!strcmp(str, \"%env\")) {\n\t\tif (getenv(\"UNIXPW\") == NULL) {\n\t\t\texit(2);\n\t\t}\n\t\tq = strdup(getenv(\"UNIXPW\"));\n\t} else if (!strcmp(str, \"%%\") || !strcmp(str, \"%\")) {\n\t\tchar *t, inp[1024];\n\t\tfprintf(stdout, \"username: \");\n\t\tif(fgets(tmp, 128, stdin) == NULL) {\n\t\t\texit(2);\n\t\t}\n\t\tstrcpy(inp, tmp);\n\t\tt = strchr(inp, '\\n');\n\t\tif (t) {\n\t\t\t*t = ':'; \n\t\t} else {\n\t\t\tstrcat(inp, \":\");\n\t\t\t\n\t\t}\n\t\tfprintf(stdout, \"password: \");\n\t\t/* test mode: no_external_cmds does not apply */\n\t\tsystem(\"stty -echo\");\n\t\tif(fgets(tmp, 128, stdin) == NULL) {\n\t\t\tfprintf(stdout, \"\\n\");\n\t\t\tsystem(\"stty echo\");\n\t\t\texit(2);\n\t\t}\n\t\tsystem(\"stty echo\");\n\t\tfprintf(stdout, \"\\n\");\n\t\tstrcat(inp, tmp);\n\t\tq = strdup(inp);\n\t} else if (str[1] == '/' || str[1] == '.') {\n\t\tFILE *in = fopen(str+1, \"r\");\n\t\tif (in == NULL) {\n\t\t\texit(2);\n\t\t}\n\t\tif(fgets(tmp, 1024, in) == NULL) {\n\t\t\texit(2);\n\t\t}\n\t\tfclose(in);\n\t\tq = strdup(tmp);\n\t} else {\n\t\tq = strdup(str+1);\n\t}\n\tp = (char *) malloc(strlen(q) + 10);\n\tstrcpy(p, q);\n\tif (strchr(p, '\\n') == NULL) {\n\t\tstrcat(p, \"\\n\");\n\t}\n\n\tif ((q = strchr(p, ':')) == NULL) {\n\t\texit(2);\n\t}\n\t*q = '\\0';\n\tif (db) fprintf(stderr, \"'%s' '%s'\\n\", p, q+1);\n\tif (unixpw_cmd) {\n\t\tif (cmd_verify(p, q+1)) {\n\t\t\tfprintf(stdout, \"Y %s\\n\", p);\n\t\t\texit(0);\n\t\t} else {\n\t\t\tfprintf(stdout, \"N %s\\n\", p);\n\t\t\texit(1);\n\t\t}\n\t} else if (unixpw_nis) {\n\t\tif (crypt_verify(p, q+1)) {\n\t\t\tfprintf(stdout, \"Y %s\\n\", p);\n\t\t\texit(0);\n\t\t} else {\n\t\t\tfprintf(stdout, \"N %s\\n\", p);\n\t\t\texit(1);\n\t\t}\n\t} else {\n\t\tchar *ucmd = getenv(\"UNIXPW_CMD\");\n\t\tif (su_verify(p, q+1, ucmd, NULL, NULL, 1)) {\n\t\t\tfprintf(stdout, \"Y %s\\n\", p);\n\t\t\texit(0);\n\t\t} else {\n\t\t\tfprintf(stdout, \"N %s\\n\", p);\n\t\t\texit(1);\n\t\t}\n\t}\n\t/* NOTREACHED */\n\texit(2);\n}"
  },
  {
    "function_name": "immediate_switch_user",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/x11vnc.c",
    "lines": "1276-1329",
    "snippet": "static void immediate_switch_user(int argc, char* argv[]) {\n\tint i, bequiet = 0;\n\tfor (i=1; i < argc; i++) {\n\t\tif (strcmp(argv[i], \"-inetd\")) {\n\t\t\tbequiet = 1;\n\t\t}\n\t\tif (strcmp(argv[i], \"-quiet\")) {\n\t\t\tbequiet = 1;\n\t\t}\n\t\tif (strcmp(argv[i], \"-q\")) {\n\t\t\tbequiet = 1;\n\t\t}\n\t}\n\tfor (i=1; i < argc; i++) {\n\t\tchar *u, *q;\n\n\t\tif (strcmp(argv[i], \"-users\")) {\n\t\t\tcontinue;\n\t\t}\n\t\tif (i == argc - 1) {\n\t\t\tfprintf(stderr, \"not enough arguments for: -users\\n\");\n\t\t\texit(1);\n\t\t}\n\t\tif (*(argv[i+1]) != '=') {\n\t\t\tbreak;\n\t\t}\n\n\t\t/* wants an immediate switch: =bob */\n\t\tu = strdup(argv[i+1]);\n\t\t*u = '+';\n\t\tq = strchr(u, '.');\n\t\tif (q) {\n\t\t\tuser2group = (char **) malloc(2*sizeof(char *));\n\t\t\tuser2group[0] = strdup(u+1);\n\t\t\tuser2group[1] = NULL;\n\t\t\t*q = '\\0';\n\t\t}\n\t\tif (strstr(u, \"+guess\") == u) {\n\t\t\tfprintf(stderr, \"invalid user: %s\\n\", u+1);\n\t\t\texit(1);\n\t\t}\n\t\tif (!switch_user(u, 0)) {\n\t\t\tfprintf(stderr, \"Could not switch to user: %s\\n\", u+1);\n\t\t\texit(1);\n\t\t} else {\n\t\t\tif (!bequiet) {\n\t\t\t\tfprintf(stderr, \"Switched to user: %s\\n\", u+1);\n\t\t\t}\n\t\t\tstarted_as_root = 2;\n\t\t}\n\t\tfree(u);\n\t\tbreak;\n\t}\n}",
    "includes": [
      "#include \"xi2_devices.h\"",
      "#include \"solid.h\"",
      "#include \"pm.h\"",
      "#include \"selection.h\"",
      "#include \"sslhelper.h\"",
      "#include \"sslcmds.h\"",
      "#include \"inet.h\"",
      "#include \"unixpw.h\"",
      "#include \"rates.h\"",
      "#include \"connections.h\"",
      "#include \"screen.h\"",
      "#include \"userinput.h\"",
      "#include \"cursor.h\"",
      "#include \"pointer.h\"",
      "#include \"keyboard.h\"",
      "#include \"cleanup.h\"",
      "#include \"user.h\"",
      "#include \"help.h\"",
      "#include \"gui.h\"",
      "#include \"scan.h\"",
      "#include \"remote.h\"",
      "#include \"win_utils.h\"",
      "#include \"xkb_bell.h\"",
      "#include \"xrandr.h\"",
      "#include \"xinerama.h\"",
      "#include \"xevents.h\"",
      "#include \"xrecord.h\"",
      "#include \"xdamage.h\"",
      "#include \"xwrappers.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void check_rcfile(int argc, char **argv);",
      "static void immediate_switch_user(int argc, char* argv[]);",
      "static void check_loop_mode(int argc, char* argv[], int force);",
      "static void check_appshare_mode(int argc, char* argv[]);",
      "extern int appshare_main(int argc, char* argv[]);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "u"
          ],
          "line": 1326
        },
        "resolved": true,
        "details": {
          "function_name": "free_rect",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/userinput.c",
          "lines": "6200-6247",
          "snippet": "int free_rect(int idx) {\n\tint n, ok = 0;\n\tsraRegionPtr r1, r2;\n\tint x, y, w, h;\n\n\tif (idx < 0 || idx >= cache_list_num) {\nif (0) fprintf(stderr, \"free_rect: bad index: %d\\n\", idx);\n\t\tclean_up_exit(1);\n\t}\n\n\tx = cache_list[idx].bs_x;\n\ty = cache_list[idx].bs_y;\n\tw = cache_list[idx].bs_w;\n\th = cache_list[idx].bs_h;\n\n\tif (x < 0) {\n\t\tCLEAR(idx);\nif (dnow() > last_client + 5 && ncdb) fprintf(stderr, \"free_rect: already bs_x invalidated: %d bs_x: %d\\n\", idx, x);\n\t\treturn 1;\n\t}\n\n\tr2 = sraRgnCreateRect(x, y, x+w, y+h);\n\n\tn = get_bs_n(y);\n\tif (n >= 0) {\n\t\tr1 = rect_reg[n];\n\t\tsraRgnOr(r1, r2);\n\t\tok = 1;\n\t}\n\n\tif (zero_rects) {\n\t\tsraRgnOr(zero_rects, r2);\n\t\tx = cache_list[idx].su_x;\n\t\ty = cache_list[idx].su_y;\n\t\tw = cache_list[idx].su_w;\n\t\th = cache_list[idx].su_h;\n\t\tif (x >= 0) {\n\t\t\tsraRgnDestroy(r2);\n\t\t\tr2 = sraRgnCreateRect(x, y, x+w, y+h);\n\t\t\tsraRgnOr(zero_rects, r2);\n\t\t}\n\t}\n\tsraRgnDestroy(r2);\n\n\tCLEAR(idx);\nif (! ok && ncdb) fprintf(stderr, \"**** free_rect: not-found %d\\n\", idx);\n\treturn ok;\n}",
          "includes": [
            "#include \"default8x16.h\"",
            "#include \"connections.h\"",
            "#include \"screen.h\"",
            "#include \"cursor.h\"",
            "#include \"macosxCGS.h\"",
            "#include \"macosx.h\"",
            "#include \"unixpw.h\"",
            "#include \"8to24.h\"",
            "#include \"xrandr.h\"",
            "#include \"solid.h\"",
            "#include \"keyboard.h\"",
            "#include \"rates.h\"",
            "#include \"pointer.h\"",
            "#include \"cleanup.h\"",
            "#include \"scan.h\"",
            "#include \"user.h\"",
            "#include \"xevents.h\"",
            "#include \"win_utils.h\"",
            "#include \"xinerama.h\"",
            "#include \"xrecord.h\"",
            "#include \"xdamage.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void mark_for_xdamage(int x, int y, int w, int h);",
            "void set_xdamage_mark(int x, int y, int w, int h);",
            "int find_rect(int idx, int x, int y, int w, int h);",
            "winattr_t *cache_list;",
            "int clipped(int idx);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"default8x16.h\"\n#include \"connections.h\"\n#include \"screen.h\"\n#include \"cursor.h\"\n#include \"macosxCGS.h\"\n#include \"macosx.h\"\n#include \"unixpw.h\"\n#include \"8to24.h\"\n#include \"xrandr.h\"\n#include \"solid.h\"\n#include \"keyboard.h\"\n#include \"rates.h\"\n#include \"pointer.h\"\n#include \"cleanup.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"xevents.h\"\n#include \"win_utils.h\"\n#include \"xinerama.h\"\n#include \"xrecord.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nvoid mark_for_xdamage(int x, int y, int w, int h);\nvoid set_xdamage_mark(int x, int y, int w, int h);\nint find_rect(int idx, int x, int y, int w, int h);\nwinattr_t *cache_list;\nint clipped(int idx);\n\nint free_rect(int idx) {\n\tint n, ok = 0;\n\tsraRegionPtr r1, r2;\n\tint x, y, w, h;\n\n\tif (idx < 0 || idx >= cache_list_num) {\nif (0) fprintf(stderr, \"free_rect: bad index: %d\\n\", idx);\n\t\tclean_up_exit(1);\n\t}\n\n\tx = cache_list[idx].bs_x;\n\ty = cache_list[idx].bs_y;\n\tw = cache_list[idx].bs_w;\n\th = cache_list[idx].bs_h;\n\n\tif (x < 0) {\n\t\tCLEAR(idx);\nif (dnow() > last_client + 5 && ncdb) fprintf(stderr, \"free_rect: already bs_x invalidated: %d bs_x: %d\\n\", idx, x);\n\t\treturn 1;\n\t}\n\n\tr2 = sraRgnCreateRect(x, y, x+w, y+h);\n\n\tn = get_bs_n(y);\n\tif (n >= 0) {\n\t\tr1 = rect_reg[n];\n\t\tsraRgnOr(r1, r2);\n\t\tok = 1;\n\t}\n\n\tif (zero_rects) {\n\t\tsraRgnOr(zero_rects, r2);\n\t\tx = cache_list[idx].su_x;\n\t\ty = cache_list[idx].su_y;\n\t\tw = cache_list[idx].su_w;\n\t\th = cache_list[idx].su_h;\n\t\tif (x >= 0) {\n\t\t\tsraRgnDestroy(r2);\n\t\t\tr2 = sraRgnCreateRect(x, y, x+w, y+h);\n\t\t\tsraRgnOr(zero_rects, r2);\n\t\t}\n\t}\n\tsraRgnDestroy(r2);\n\n\tCLEAR(idx);\nif (! ok && ncdb) fprintf(stderr, \"**** free_rect: not-found %d\\n\", idx);\n\treturn ok;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Switched to user: %s\\n\"",
            "u+1"
          ],
          "line": 1322
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "1"
          ],
          "line": 1319
        },
        "resolved": true,
        "details": {
          "function_name": "clean_up_exit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/cleanup.c",
          "lines": "151-266",
          "snippet": "void clean_up_exit(int ret) {\n\tstatic int depth = 0;\n\texit_flag = 1;\n\n\tif (depth++ > 2) {\n\t\texit(ret);\n\t}\n\n\tif (icon_mode) {\n\t\tclean_icon_mode();\n\t}\n\n\t/* remove the shm areas: */\n\tclean_shm(0);\n\n\tstop_stunnel();\n\tif (use_openssl) {\n\t\tssl_helper_pid(0, 0);\t/* killall */\n\t}\n\n\tif (ssh_pid > 0) {\n\t\tkill(ssh_pid, SIGTERM);\n\t\tssh_pid = 0;\n\t}\n\n#ifdef MACOSX\n\tif (client_connect_file) {\n\t\tif (strstr(client_connect_file, \"/tmp/x11vnc-macosx-remote\")\n\t\t    == client_connect_file) {\n\t\t\tunlink(client_connect_file);\n\t\t}\n\t}\n\tif (macosx_console) {\n\t\tmacosxCG_fini();\n\t}\n#endif\n\n\tif (pipeinput_fh != NULL) {\n\t\tpclose(pipeinput_fh);\n\t\tpipeinput_fh = NULL;\n\t}\n\n\tshutdown_uinput();\n\n\tif (unix_sock) {\n\t\tif (unix_sock_fd >= 0) {\n\t\t\trfbLog(\"deleting unix sock: %s\\n\", unix_sock);\n\t\t\tclose(unix_sock_fd);\n\t\t\tunix_sock_fd = -1;\n\t\t\tunlink(unix_sock);\n\t\t}\n\t}\n\n\tif (! dpy) {\t/* raw_rb hack */\n\t\tif (rm_flagfile) {\n\t\t\tunlink(rm_flagfile);\n\t\t\trm_flagfile = NULL;\n\t\t}\n\t\texit(ret);\n\t}\n\n\t/* X keyboard cleanups */\n\tdelete_added_keycodes(0);\n\n\t/* remove all created XInput2 devices */\n\tif(use_multipointer)\n\t    removeAllMDs(dpy);\n\n\tif (clear_mods == 1) {\n\t\tclear_modifiers(0);\n\t} else if (clear_mods == 2) {\n\t\tclear_keys();\n\t} else if (clear_mods == 3) {\n\t\tclear_keys();\n\t\tclear_locks();\n\t}\n\n\tif (no_autorepeat) {\n\t\tautorepeat(1, 0);\n\t}\n\tif (use_solid_bg) {\n\t\tsolid_bg(1);\n\t}\n\tif (ncache || ncache0) {\n\t\tkde_no_animate(1);\n\t}\n\tX_LOCK;\n\tXTestDiscard_wr(dpy);\n#if HAVE_LIBXDAMAGE\n\tif (xdamage) {\n\t\tXDamageDestroy(dpy, xdamage);\n\t}\n#endif\n#if HAVE_LIBXTRAP\n\tif (trap_ctx) {\n\t\tXEFreeTC(trap_ctx);\n\t}\n#endif\n\t/* XXX rdpy_ctrl, etc. cannot close w/o blocking */\n\tXCloseDisplay_wr(dpy);\n\tX_UNLOCK;\n\n\tfflush(stderr);\n\n\tif (rm_flagfile) {\n\t\tunlink(rm_flagfile);\n\t\trm_flagfile = NULL;\n\t}\n\n\tif (avahi) {\n\t\tavahi_cleanup();\n\t\tfflush(stderr);\n\t}\n\n\texit(ret);\n}",
          "includes": [
            "#include \"xi2_devices.h\"",
            "#include \"uinput.h\"",
            "#include \"xevents.h\"",
            "#include \"xrecord.h\"",
            "#include \"screen.h\"",
            "#include \"avahi.h\"",
            "#include \"macosxCG.h\"",
            "#include \"macosx.h\"",
            "#include \"connections.h\"",
            "#include \"sslhelper.h\"",
            "#include \"sslcmds.h\"",
            "#include \"unixpw.h\"",
            "#include \"solid.h\"",
            "#include \"gui.h\"",
            "#include \"scan.h\"",
            "#include \"keyboard.h\"",
            "#include \"remote.h\"",
            "#include \"xdamage.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void clean_up_exit(int ret);",
            "int known_sigpipe_mode(char *s);",
            "static int exit_flag = 0;",
            "static void clean_icon_mode(void);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xi2_devices.h\"\n#include \"uinput.h\"\n#include \"xevents.h\"\n#include \"xrecord.h\"\n#include \"screen.h\"\n#include \"avahi.h\"\n#include \"macosxCG.h\"\n#include \"macosx.h\"\n#include \"connections.h\"\n#include \"sslhelper.h\"\n#include \"sslcmds.h\"\n#include \"unixpw.h\"\n#include \"solid.h\"\n#include \"gui.h\"\n#include \"scan.h\"\n#include \"keyboard.h\"\n#include \"remote.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nvoid clean_up_exit(int ret);\nint known_sigpipe_mode(char *s);\nstatic int exit_flag = 0;\nstatic void clean_icon_mode(void);\n\nvoid clean_up_exit(int ret) {\n\tstatic int depth = 0;\n\texit_flag = 1;\n\n\tif (depth++ > 2) {\n\t\texit(ret);\n\t}\n\n\tif (icon_mode) {\n\t\tclean_icon_mode();\n\t}\n\n\t/* remove the shm areas: */\n\tclean_shm(0);\n\n\tstop_stunnel();\n\tif (use_openssl) {\n\t\tssl_helper_pid(0, 0);\t/* killall */\n\t}\n\n\tif (ssh_pid > 0) {\n\t\tkill(ssh_pid, SIGTERM);\n\t\tssh_pid = 0;\n\t}\n\n#ifdef MACOSX\n\tif (client_connect_file) {\n\t\tif (strstr(client_connect_file, \"/tmp/x11vnc-macosx-remote\")\n\t\t    == client_connect_file) {\n\t\t\tunlink(client_connect_file);\n\t\t}\n\t}\n\tif (macosx_console) {\n\t\tmacosxCG_fini();\n\t}\n#endif\n\n\tif (pipeinput_fh != NULL) {\n\t\tpclose(pipeinput_fh);\n\t\tpipeinput_fh = NULL;\n\t}\n\n\tshutdown_uinput();\n\n\tif (unix_sock) {\n\t\tif (unix_sock_fd >= 0) {\n\t\t\trfbLog(\"deleting unix sock: %s\\n\", unix_sock);\n\t\t\tclose(unix_sock_fd);\n\t\t\tunix_sock_fd = -1;\n\t\t\tunlink(unix_sock);\n\t\t}\n\t}\n\n\tif (! dpy) {\t/* raw_rb hack */\n\t\tif (rm_flagfile) {\n\t\t\tunlink(rm_flagfile);\n\t\t\trm_flagfile = NULL;\n\t\t}\n\t\texit(ret);\n\t}\n\n\t/* X keyboard cleanups */\n\tdelete_added_keycodes(0);\n\n\t/* remove all created XInput2 devices */\n\tif(use_multipointer)\n\t    removeAllMDs(dpy);\n\n\tif (clear_mods == 1) {\n\t\tclear_modifiers(0);\n\t} else if (clear_mods == 2) {\n\t\tclear_keys();\n\t} else if (clear_mods == 3) {\n\t\tclear_keys();\n\t\tclear_locks();\n\t}\n\n\tif (no_autorepeat) {\n\t\tautorepeat(1, 0);\n\t}\n\tif (use_solid_bg) {\n\t\tsolid_bg(1);\n\t}\n\tif (ncache || ncache0) {\n\t\tkde_no_animate(1);\n\t}\n\tX_LOCK;\n\tXTestDiscard_wr(dpy);\n#if HAVE_LIBXDAMAGE\n\tif (xdamage) {\n\t\tXDamageDestroy(dpy, xdamage);\n\t}\n#endif\n#if HAVE_LIBXTRAP\n\tif (trap_ctx) {\n\t\tXEFreeTC(trap_ctx);\n\t}\n#endif\n\t/* XXX rdpy_ctrl, etc. cannot close w/o blocking */\n\tXCloseDisplay_wr(dpy);\n\tX_UNLOCK;\n\n\tfflush(stderr);\n\n\tif (rm_flagfile) {\n\t\tunlink(rm_flagfile);\n\t\trm_flagfile = NULL;\n\t}\n\n\tif (avahi) {\n\t\tavahi_cleanup();\n\t\tfflush(stderr);\n\t}\n\n\texit(ret);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Could not switch to user: %s\\n\"",
            "u+1"
          ],
          "line": 1318
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "switch_user",
          "args": [
            "u",
            "0"
          ],
          "line": 1317
        },
        "resolved": true,
        "details": {
          "function_name": "immediate_switch_user",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/x11vnc.c",
          "lines": "1276-1329",
          "snippet": "static void immediate_switch_user(int argc, char* argv[]) {\n\tint i, bequiet = 0;\n\tfor (i=1; i < argc; i++) {\n\t\tif (strcmp(argv[i], \"-inetd\")) {\n\t\t\tbequiet = 1;\n\t\t}\n\t\tif (strcmp(argv[i], \"-quiet\")) {\n\t\t\tbequiet = 1;\n\t\t}\n\t\tif (strcmp(argv[i], \"-q\")) {\n\t\t\tbequiet = 1;\n\t\t}\n\t}\n\tfor (i=1; i < argc; i++) {\n\t\tchar *u, *q;\n\n\t\tif (strcmp(argv[i], \"-users\")) {\n\t\t\tcontinue;\n\t\t}\n\t\tif (i == argc - 1) {\n\t\t\tfprintf(stderr, \"not enough arguments for: -users\\n\");\n\t\t\texit(1);\n\t\t}\n\t\tif (*(argv[i+1]) != '=') {\n\t\t\tbreak;\n\t\t}\n\n\t\t/* wants an immediate switch: =bob */\n\t\tu = strdup(argv[i+1]);\n\t\t*u = '+';\n\t\tq = strchr(u, '.');\n\t\tif (q) {\n\t\t\tuser2group = (char **) malloc(2*sizeof(char *));\n\t\t\tuser2group[0] = strdup(u+1);\n\t\t\tuser2group[1] = NULL;\n\t\t\t*q = '\\0';\n\t\t}\n\t\tif (strstr(u, \"+guess\") == u) {\n\t\t\tfprintf(stderr, \"invalid user: %s\\n\", u+1);\n\t\t\texit(1);\n\t\t}\n\t\tif (!switch_user(u, 0)) {\n\t\t\tfprintf(stderr, \"Could not switch to user: %s\\n\", u+1);\n\t\t\texit(1);\n\t\t} else {\n\t\t\tif (!bequiet) {\n\t\t\t\tfprintf(stderr, \"Switched to user: %s\\n\", u+1);\n\t\t\t}\n\t\t\tstarted_as_root = 2;\n\t\t}\n\t\tfree(u);\n\t\tbreak;\n\t}\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"invalid user: %s\\n\"",
            "u+1"
          ],
          "line": 1314
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "u",
            "\"+guess\""
          ],
          "line": 1313
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "u+1"
          ],
          "line": 1309
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "2*sizeof(char *)"
          ],
          "line": 1308
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "u",
            "'.'"
          ],
          "line": 1306
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "argv[i+1]"
          ],
          "line": 1304
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"not enough arguments for: -users\\n\""
          ],
          "line": 1296
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "argv[i]",
            "\"-users\""
          ],
          "line": 1292
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "argv[i]",
            "\"-q\""
          ],
          "line": 1285
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "argv[i]",
            "\"-quiet\""
          ],
          "line": 1282
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "argv[i]",
            "\"-inetd\""
          ],
          "line": 1279
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xi2_devices.h\"\n#include \"solid.h\"\n#include \"pm.h\"\n#include \"selection.h\"\n#include \"sslhelper.h\"\n#include \"sslcmds.h\"\n#include \"inet.h\"\n#include \"unixpw.h\"\n#include \"rates.h\"\n#include \"connections.h\"\n#include \"screen.h\"\n#include \"userinput.h\"\n#include \"cursor.h\"\n#include \"pointer.h\"\n#include \"keyboard.h\"\n#include \"cleanup.h\"\n#include \"user.h\"\n#include \"help.h\"\n#include \"gui.h\"\n#include \"scan.h\"\n#include \"remote.h\"\n#include \"win_utils.h\"\n#include \"xkb_bell.h\"\n#include \"xrandr.h\"\n#include \"xinerama.h\"\n#include \"xevents.h\"\n#include \"xrecord.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nstatic void check_rcfile(int argc, char **argv);\nstatic void immediate_switch_user(int argc, char* argv[]);\nstatic void check_loop_mode(int argc, char* argv[], int force);\nstatic void check_appshare_mode(int argc, char* argv[]);\nextern int appshare_main(int argc, char* argv[]);\n\nstatic void immediate_switch_user(int argc, char* argv[]) {\n\tint i, bequiet = 0;\n\tfor (i=1; i < argc; i++) {\n\t\tif (strcmp(argv[i], \"-inetd\")) {\n\t\t\tbequiet = 1;\n\t\t}\n\t\tif (strcmp(argv[i], \"-quiet\")) {\n\t\t\tbequiet = 1;\n\t\t}\n\t\tif (strcmp(argv[i], \"-q\")) {\n\t\t\tbequiet = 1;\n\t\t}\n\t}\n\tfor (i=1; i < argc; i++) {\n\t\tchar *u, *q;\n\n\t\tif (strcmp(argv[i], \"-users\")) {\n\t\t\tcontinue;\n\t\t}\n\t\tif (i == argc - 1) {\n\t\t\tfprintf(stderr, \"not enough arguments for: -users\\n\");\n\t\t\texit(1);\n\t\t}\n\t\tif (*(argv[i+1]) != '=') {\n\t\t\tbreak;\n\t\t}\n\n\t\t/* wants an immediate switch: =bob */\n\t\tu = strdup(argv[i+1]);\n\t\t*u = '+';\n\t\tq = strchr(u, '.');\n\t\tif (q) {\n\t\t\tuser2group = (char **) malloc(2*sizeof(char *));\n\t\t\tuser2group[0] = strdup(u+1);\n\t\t\tuser2group[1] = NULL;\n\t\t\t*q = '\\0';\n\t\t}\n\t\tif (strstr(u, \"+guess\") == u) {\n\t\t\tfprintf(stderr, \"invalid user: %s\\n\", u+1);\n\t\t\texit(1);\n\t\t}\n\t\tif (!switch_user(u, 0)) {\n\t\t\tfprintf(stderr, \"Could not switch to user: %s\\n\", u+1);\n\t\t\texit(1);\n\t\t} else {\n\t\t\tif (!bequiet) {\n\t\t\t\tfprintf(stderr, \"Switched to user: %s\\n\", u+1);\n\t\t\t}\n\t\t\tstarted_as_root = 2;\n\t\t}\n\t\tfree(u);\n\t\tbreak;\n\t}\n}"
  },
  {
    "function_name": "check_rcfile",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/x11vnc.c",
    "lines": "1023-1274",
    "snippet": "static void check_rcfile(int argc, char **argv) {\n\tint i, j, pwlast, enclast, norc = 0, argmax = 1024;\n\tchar *infile = NULL;\n\tchar rcfile[1024];\n\tFILE *rc = NULL; \n\n\tfor (i=1; i < argc; i++) {\n\t\tif (!strcmp(argv[i], \"-printgui\")) {\n\t\t\tfprintf(stdout, \"%s\", get_gui_code());\n\t\t\tfflush(stdout);\n\t\t\texit(0);\n\t\t}\n\t\tif (!strcmp(argv[i], \"-norc\")) {\n\t\t\tnorc = 1;\n\t\t\tgot_norc = 1;\n\t\t}\n\t\tif (!strcmp(argv[i], \"-QD\")) {\n\t\t\tnorc = 1;\n\t\t}\n\t\tif (!strcmp(argv[i], \"-rc\")) {\n\t\t\tif (i+1 >= argc) {\n\t\t\t\tfprintf(stderr, \"-rc option requires a \"\n\t\t\t\t    \"filename\\n\");\n\t\t\t\texit(1);\n\t\t\t} else {\n\t\t\t\tinfile = argv[i+1];\n\t\t\t}\n\t\t}\n\t}\n\trc_norc = norc;\n\trc_rcfile = strdup(\"\");\n\tif (norc) {\n\t\t;\n\t} else if (infile != NULL) {\n\t\trc = fopen(infile, \"r\");\n\t\trc_rcfile = strdup(infile);\n\t\tif (rc == NULL) {\n\t\t\tfprintf(stderr, \"could not open rcfile: %s\\n\", infile);\n\t\t\tperror(\"fopen\");\n\t\t\texit(1);\n\t\t}\n\t} else {\n\t\tchar *home = get_home_dir();\n\t\tif (! home) {\n\t\t\tnorc = 1;\n\t\t} else {\n\t\t\tmemset(rcfile, 0, sizeof(rcfile));\n\t\t\tstrncpy(rcfile, home, 500);\n\t\t\tfree(home);\n\n\t\t\tstrcat(rcfile, \"/.x11vncrc\");\n\t\t\tinfile = rcfile;\n\t\t\trc = fopen(rcfile, \"r\");\n\t\t\tif (rc == NULL) {\n\t\t\t\tnorc = 1;\n\t\t\t} else {\n\t\t\t\trc_rcfile = strdup(rcfile);\n\t\t\t\trc_rcfile_default = 1;\n\t\t\t}\n\t\t}\n\t}\n\n\targv2 = (char **) malloc(argmax * sizeof(char *));\n\targv2[argc2++] = strdup(argv[0]);\n\n\tif (! norc) {\n\t\tchar line[4096], parm[400], tmp[401];\n\t\tchar *buf, *tbuf;\n\t\tstruct stat sbuf;\n\t\tint sz;\n\n\t\tif (fstat(fileno(rc), &sbuf) != 0) {\n\t\t\tfprintf(stderr, \"problem with %s\\n\", infile);\n\t\t\tperror(\"fstat\");\n\t\t\texit(1);\n\t\t}\n\t\tsz = sbuf.st_size+1;\t/* allocate whole file size */\n\t\tif (sz < 1024) {\n\t\t\tsz = 1024;\n\t\t}\n\n\t\tbuf = (char *) malloc(sz);\n\t\tbuf[0] = '\\0';\n\n\t\twhile (fgets(line, 4096, rc) != NULL) {\n\t\t\tchar *q, *p = line;\n\t\t\tchar c;\n\t\t\tint cont = 0;\n\n\t\t\tq = p;\n\t\t\tc = '\\0';\n\t\t\twhile (*q) {\n\t\t\t\tif (*q == '#') {\n\t\t\t\t\tif (c != '\\\\') {\n\t\t\t\t\t\t*q = '\\0';\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tc = *q;\n\t\t\t\tq++;\n\t\t\t}\n\n\t\t\tq = p;\n\t\t\tc = '\\0';\n\t\t\twhile (*q) {\n\t\t\t\tif (*q == '\\n') {\n\t\t\t\t\tif (c == '\\\\') {\n\t\t\t\t\t\tcont = 1;\n\t\t\t\t\t\t*q = '\\0';\n\t\t\t\t\t\t*(q-1) = ' ';\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\twhile (isspace((unsigned char) (*q))) {\n\t\t\t\t\t\t*q = '\\0';\n\t\t\t\t\t\tif (q == p) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tq--;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tc = *q;\n\t\t\t\tq++;\n\t\t\t}\n\t\t\tif (q != p && !cont) {\n\t\t\t\tif (*q == '\\0') {\n\t\t\t\t\tq--;\n\t\t\t\t}\n\t\t\t\twhile (isspace((unsigned char) (*q))) {\n\t\t\t\t\t*q = '\\0';\n\t\t\t\t\tif (q == p) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tq--;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tp = lblanks(p);\n\n\t\t\tstrncat(buf, p, sz - strlen(buf) - 1);\n\t\t\tif (cont) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (buf[0] == '\\0') {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\ti = 0;\n\t\t\tq = buf;\n\t\t\twhile (*q) {\n\t\t\t\ti++;\n\t\t\t\tif (*q == '\\n' || isspace((unsigned char) (*q))) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tq++;\n\t\t\t}\n\n\t\t\tif (i >= 400) {\n\t\t\t\tfprintf(stderr, \"invalid rcfile line: %s/%s\\n\",\n\t\t\t\t    p, buf);\n\t\t\t\texit(1);\n\t\t\t}\n\n\t\t\tif (sscanf(buf, \"%s\", parm) != 1) {\n\t\t\t\tfprintf(stderr, \"invalid rcfile line: %s\\n\", p);\n\t\t\t\texit(1);\n\t\t\t}\n\t\t\tif (parm[0] == '-') {\n\t\t\t\tstrncpy(tmp, parm, 400); \n\t\t\t} else {\n\t\t\t\ttmp[0] = '-';\n\t\t\t\tstrncpy(tmp+1, parm, 400); \n\t\t\t}\n\n\t\t\tif (strstr(tmp, \"-loop\") == tmp) {\n\t\t\t\tif (! getenv(\"X11VNC_LOOP_MODE\")) {\n\t\t\t\t\tcheck_loop_mode(argc, argv, 1);\n\t\t\t\t\texit(0);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\targv2[argc2++] = strdup(tmp);\n\t\t\tif (argc2 >= argmax) {\n\t\t\t\tfprintf(stderr, \"too many rcfile options\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\t\t\t\n\t\t\tp = buf;\n\t\t\tp += strlen(parm);\n\t\t\tp = lblanks(p);\n\n\t\t\tif (*p == '\\0') {\n\t\t\t\tbuf[0] = '\\0';\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\ttbuf = (char *) calloc(strlen(p) + 1, 1);\n\n\t\t\tj = 0;\n\t\t\twhile (*p) {\n\t\t\t\tif (*p == '\\\\' && *(p+1) == '#') {\n\t\t\t\t\t;\n\t\t\t\t} else {\n\t\t\t\t\ttbuf[j++] = *p;\n\t\t\t\t}\n\t\t\t\tp++;\n\t\t\t}\n\n\t\t\targv2[argc2++] = strdup(tbuf);\n\t\t\tfree(tbuf);\n\t\t\tif (argc2 >= argmax) {\n\t\t\t\tfprintf(stderr, \"too many rcfile options\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\t\t\tbuf[0] = '\\0';\n\t\t}\n\t\tfclose(rc);\n\t\tfree(buf);\n\t}\n\tpwlast = 0;\n\tenclast = 0;\n\tfor (i=1; i < argc; i++) {\n\t\targv2[argc2++] = strdup(argv[i]);\n\n\t\tif (pwlast || !strcmp(\"-passwd\", argv[i])\n\t\t    || !strcmp(\"-viewpasswd\", argv[i])) {\n\t\t\tchar *p = argv[i];\t\t\n\t\t\tif (pwlast) {\n\t\t\t\tpwlast = 0;\n\t\t\t} else {\n\t\t\t\tpwlast = 1;\n\t\t\t}\n\t\t\tstrzero(p);\n\t\t}\n\t\tif (enclast || !strcmp(\"-enc\", argv[i])) {\n\t\t\tchar *q, *p = argv[i];\t\t\n\t\t\tif (enclast) {\n\t\t\t\tenclast = 0;\n\t\t\t} else {\n\t\t\t\tenclast = 1;\n\t\t\t}\n\t\t\tq = strstr(p, \"pw=\");\n\t\t\tif (q) {\n\t\t\t\tstrzero(q);\n\t\t\t}\n\t\t}\n\t\tif (argc2 >= argmax) {\n\t\t\tfprintf(stderr, \"too many rcfile options\\n\");\n\t\t\texit(1);\n\t\t}\n\t}\n}",
    "includes": [
      "#include \"xi2_devices.h\"",
      "#include \"solid.h\"",
      "#include \"pm.h\"",
      "#include \"selection.h\"",
      "#include \"sslhelper.h\"",
      "#include \"sslcmds.h\"",
      "#include \"inet.h\"",
      "#include \"unixpw.h\"",
      "#include \"rates.h\"",
      "#include \"connections.h\"",
      "#include \"screen.h\"",
      "#include \"userinput.h\"",
      "#include \"cursor.h\"",
      "#include \"pointer.h\"",
      "#include \"keyboard.h\"",
      "#include \"cleanup.h\"",
      "#include \"user.h\"",
      "#include \"help.h\"",
      "#include \"gui.h\"",
      "#include \"scan.h\"",
      "#include \"remote.h\"",
      "#include \"win_utils.h\"",
      "#include \"xkb_bell.h\"",
      "#include \"xrandr.h\"",
      "#include \"xinerama.h\"",
      "#include \"xevents.h\"",
      "#include \"xrecord.h\"",
      "#include \"xdamage.h\"",
      "#include \"xwrappers.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void check_rcfile(int argc, char **argv);",
      "static void immediate_switch_user(int argc, char* argv[]);",
      "static void check_loop_mode(int argc, char* argv[], int force);",
      "static void check_appshare_mode(int argc, char* argv[]);",
      "static int argc2 = 0;",
      "static char **argv2;",
      "extern int appshare_main(int argc, char* argv[]);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "1"
          ],
          "line": 1271
        },
        "resolved": true,
        "details": {
          "function_name": "clean_up_exit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/cleanup.c",
          "lines": "151-266",
          "snippet": "void clean_up_exit(int ret) {\n\tstatic int depth = 0;\n\texit_flag = 1;\n\n\tif (depth++ > 2) {\n\t\texit(ret);\n\t}\n\n\tif (icon_mode) {\n\t\tclean_icon_mode();\n\t}\n\n\t/* remove the shm areas: */\n\tclean_shm(0);\n\n\tstop_stunnel();\n\tif (use_openssl) {\n\t\tssl_helper_pid(0, 0);\t/* killall */\n\t}\n\n\tif (ssh_pid > 0) {\n\t\tkill(ssh_pid, SIGTERM);\n\t\tssh_pid = 0;\n\t}\n\n#ifdef MACOSX\n\tif (client_connect_file) {\n\t\tif (strstr(client_connect_file, \"/tmp/x11vnc-macosx-remote\")\n\t\t    == client_connect_file) {\n\t\t\tunlink(client_connect_file);\n\t\t}\n\t}\n\tif (macosx_console) {\n\t\tmacosxCG_fini();\n\t}\n#endif\n\n\tif (pipeinput_fh != NULL) {\n\t\tpclose(pipeinput_fh);\n\t\tpipeinput_fh = NULL;\n\t}\n\n\tshutdown_uinput();\n\n\tif (unix_sock) {\n\t\tif (unix_sock_fd >= 0) {\n\t\t\trfbLog(\"deleting unix sock: %s\\n\", unix_sock);\n\t\t\tclose(unix_sock_fd);\n\t\t\tunix_sock_fd = -1;\n\t\t\tunlink(unix_sock);\n\t\t}\n\t}\n\n\tif (! dpy) {\t/* raw_rb hack */\n\t\tif (rm_flagfile) {\n\t\t\tunlink(rm_flagfile);\n\t\t\trm_flagfile = NULL;\n\t\t}\n\t\texit(ret);\n\t}\n\n\t/* X keyboard cleanups */\n\tdelete_added_keycodes(0);\n\n\t/* remove all created XInput2 devices */\n\tif(use_multipointer)\n\t    removeAllMDs(dpy);\n\n\tif (clear_mods == 1) {\n\t\tclear_modifiers(0);\n\t} else if (clear_mods == 2) {\n\t\tclear_keys();\n\t} else if (clear_mods == 3) {\n\t\tclear_keys();\n\t\tclear_locks();\n\t}\n\n\tif (no_autorepeat) {\n\t\tautorepeat(1, 0);\n\t}\n\tif (use_solid_bg) {\n\t\tsolid_bg(1);\n\t}\n\tif (ncache || ncache0) {\n\t\tkde_no_animate(1);\n\t}\n\tX_LOCK;\n\tXTestDiscard_wr(dpy);\n#if HAVE_LIBXDAMAGE\n\tif (xdamage) {\n\t\tXDamageDestroy(dpy, xdamage);\n\t}\n#endif\n#if HAVE_LIBXTRAP\n\tif (trap_ctx) {\n\t\tXEFreeTC(trap_ctx);\n\t}\n#endif\n\t/* XXX rdpy_ctrl, etc. cannot close w/o blocking */\n\tXCloseDisplay_wr(dpy);\n\tX_UNLOCK;\n\n\tfflush(stderr);\n\n\tif (rm_flagfile) {\n\t\tunlink(rm_flagfile);\n\t\trm_flagfile = NULL;\n\t}\n\n\tif (avahi) {\n\t\tavahi_cleanup();\n\t\tfflush(stderr);\n\t}\n\n\texit(ret);\n}",
          "includes": [
            "#include \"xi2_devices.h\"",
            "#include \"uinput.h\"",
            "#include \"xevents.h\"",
            "#include \"xrecord.h\"",
            "#include \"screen.h\"",
            "#include \"avahi.h\"",
            "#include \"macosxCG.h\"",
            "#include \"macosx.h\"",
            "#include \"connections.h\"",
            "#include \"sslhelper.h\"",
            "#include \"sslcmds.h\"",
            "#include \"unixpw.h\"",
            "#include \"solid.h\"",
            "#include \"gui.h\"",
            "#include \"scan.h\"",
            "#include \"keyboard.h\"",
            "#include \"remote.h\"",
            "#include \"xdamage.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void clean_up_exit(int ret);",
            "int known_sigpipe_mode(char *s);",
            "static int exit_flag = 0;",
            "static void clean_icon_mode(void);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xi2_devices.h\"\n#include \"uinput.h\"\n#include \"xevents.h\"\n#include \"xrecord.h\"\n#include \"screen.h\"\n#include \"avahi.h\"\n#include \"macosxCG.h\"\n#include \"macosx.h\"\n#include \"connections.h\"\n#include \"sslhelper.h\"\n#include \"sslcmds.h\"\n#include \"unixpw.h\"\n#include \"solid.h\"\n#include \"gui.h\"\n#include \"scan.h\"\n#include \"keyboard.h\"\n#include \"remote.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nvoid clean_up_exit(int ret);\nint known_sigpipe_mode(char *s);\nstatic int exit_flag = 0;\nstatic void clean_icon_mode(void);\n\nvoid clean_up_exit(int ret) {\n\tstatic int depth = 0;\n\texit_flag = 1;\n\n\tif (depth++ > 2) {\n\t\texit(ret);\n\t}\n\n\tif (icon_mode) {\n\t\tclean_icon_mode();\n\t}\n\n\t/* remove the shm areas: */\n\tclean_shm(0);\n\n\tstop_stunnel();\n\tif (use_openssl) {\n\t\tssl_helper_pid(0, 0);\t/* killall */\n\t}\n\n\tif (ssh_pid > 0) {\n\t\tkill(ssh_pid, SIGTERM);\n\t\tssh_pid = 0;\n\t}\n\n#ifdef MACOSX\n\tif (client_connect_file) {\n\t\tif (strstr(client_connect_file, \"/tmp/x11vnc-macosx-remote\")\n\t\t    == client_connect_file) {\n\t\t\tunlink(client_connect_file);\n\t\t}\n\t}\n\tif (macosx_console) {\n\t\tmacosxCG_fini();\n\t}\n#endif\n\n\tif (pipeinput_fh != NULL) {\n\t\tpclose(pipeinput_fh);\n\t\tpipeinput_fh = NULL;\n\t}\n\n\tshutdown_uinput();\n\n\tif (unix_sock) {\n\t\tif (unix_sock_fd >= 0) {\n\t\t\trfbLog(\"deleting unix sock: %s\\n\", unix_sock);\n\t\t\tclose(unix_sock_fd);\n\t\t\tunix_sock_fd = -1;\n\t\t\tunlink(unix_sock);\n\t\t}\n\t}\n\n\tif (! dpy) {\t/* raw_rb hack */\n\t\tif (rm_flagfile) {\n\t\t\tunlink(rm_flagfile);\n\t\t\trm_flagfile = NULL;\n\t\t}\n\t\texit(ret);\n\t}\n\n\t/* X keyboard cleanups */\n\tdelete_added_keycodes(0);\n\n\t/* remove all created XInput2 devices */\n\tif(use_multipointer)\n\t    removeAllMDs(dpy);\n\n\tif (clear_mods == 1) {\n\t\tclear_modifiers(0);\n\t} else if (clear_mods == 2) {\n\t\tclear_keys();\n\t} else if (clear_mods == 3) {\n\t\tclear_keys();\n\t\tclear_locks();\n\t}\n\n\tif (no_autorepeat) {\n\t\tautorepeat(1, 0);\n\t}\n\tif (use_solid_bg) {\n\t\tsolid_bg(1);\n\t}\n\tif (ncache || ncache0) {\n\t\tkde_no_animate(1);\n\t}\n\tX_LOCK;\n\tXTestDiscard_wr(dpy);\n#if HAVE_LIBXDAMAGE\n\tif (xdamage) {\n\t\tXDamageDestroy(dpy, xdamage);\n\t}\n#endif\n#if HAVE_LIBXTRAP\n\tif (trap_ctx) {\n\t\tXEFreeTC(trap_ctx);\n\t}\n#endif\n\t/* XXX rdpy_ctrl, etc. cannot close w/o blocking */\n\tXCloseDisplay_wr(dpy);\n\tX_UNLOCK;\n\n\tfflush(stderr);\n\n\tif (rm_flagfile) {\n\t\tunlink(rm_flagfile);\n\t\trm_flagfile = NULL;\n\t}\n\n\tif (avahi) {\n\t\tavahi_cleanup();\n\t\tfflush(stderr);\n\t}\n\n\texit(ret);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"too many rcfile options\\n\""
          ],
          "line": 1270
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strzero",
          "args": [
            "q"
          ],
          "line": 1266
        },
        "resolved": true,
        "details": {
          "function_name": "strzero",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/util.c",
          "lines": "171-179",
          "snippet": "void strzero(char *str) {\n\tchar *p = str;\n\tif (p != NULL) {\n\t\twhile (*p != '\\0') {\n\t\t\t*p = '\\0';\n\t\t\tp++;\n\t\t}\n\t}\n}",
          "includes": [
            "#include \"connections.h\"",
            "#include \"unixpw.h\"",
            "#include \"win_utils.h\"",
            "#include \"cleanup.h\"",
            "#include \"x11vnc.h\"",
            "#include <stdlib.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void lowercase(char *str);",
            "void uppercase(char *str);",
            "char *lblanks(char *str);",
            "void strzero(char *str);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"connections.h\"\n#include \"unixpw.h\"\n#include \"win_utils.h\"\n#include \"cleanup.h\"\n#include \"x11vnc.h\"\n#include <stdlib.h>\n\nvoid lowercase(char *str);\nvoid uppercase(char *str);\nchar *lblanks(char *str);\nvoid strzero(char *str);\n\nvoid strzero(char *str) {\n\tchar *p = str;\n\tif (p != NULL) {\n\t\twhile (*p != '\\0') {\n\t\t\t*p = '\\0';\n\t\t\tp++;\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "p",
            "\"pw=\""
          ],
          "line": 1264
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "\"-enc\"",
            "argv[i]"
          ],
          "line": 1257
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "\"-viewpasswd\"",
            "argv[i]"
          ],
          "line": 1248
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "\"-passwd\"",
            "argv[i]"
          ],
          "line": 1247
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "argv[i]"
          ],
          "line": 1245
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "buf"
          ],
          "line": 1240
        },
        "resolved": true,
        "details": {
          "function_name": "free_rect",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/userinput.c",
          "lines": "6200-6247",
          "snippet": "int free_rect(int idx) {\n\tint n, ok = 0;\n\tsraRegionPtr r1, r2;\n\tint x, y, w, h;\n\n\tif (idx < 0 || idx >= cache_list_num) {\nif (0) fprintf(stderr, \"free_rect: bad index: %d\\n\", idx);\n\t\tclean_up_exit(1);\n\t}\n\n\tx = cache_list[idx].bs_x;\n\ty = cache_list[idx].bs_y;\n\tw = cache_list[idx].bs_w;\n\th = cache_list[idx].bs_h;\n\n\tif (x < 0) {\n\t\tCLEAR(idx);\nif (dnow() > last_client + 5 && ncdb) fprintf(stderr, \"free_rect: already bs_x invalidated: %d bs_x: %d\\n\", idx, x);\n\t\treturn 1;\n\t}\n\n\tr2 = sraRgnCreateRect(x, y, x+w, y+h);\n\n\tn = get_bs_n(y);\n\tif (n >= 0) {\n\t\tr1 = rect_reg[n];\n\t\tsraRgnOr(r1, r2);\n\t\tok = 1;\n\t}\n\n\tif (zero_rects) {\n\t\tsraRgnOr(zero_rects, r2);\n\t\tx = cache_list[idx].su_x;\n\t\ty = cache_list[idx].su_y;\n\t\tw = cache_list[idx].su_w;\n\t\th = cache_list[idx].su_h;\n\t\tif (x >= 0) {\n\t\t\tsraRgnDestroy(r2);\n\t\t\tr2 = sraRgnCreateRect(x, y, x+w, y+h);\n\t\t\tsraRgnOr(zero_rects, r2);\n\t\t}\n\t}\n\tsraRgnDestroy(r2);\n\n\tCLEAR(idx);\nif (! ok && ncdb) fprintf(stderr, \"**** free_rect: not-found %d\\n\", idx);\n\treturn ok;\n}",
          "includes": [
            "#include \"default8x16.h\"",
            "#include \"connections.h\"",
            "#include \"screen.h\"",
            "#include \"cursor.h\"",
            "#include \"macosxCGS.h\"",
            "#include \"macosx.h\"",
            "#include \"unixpw.h\"",
            "#include \"8to24.h\"",
            "#include \"xrandr.h\"",
            "#include \"solid.h\"",
            "#include \"keyboard.h\"",
            "#include \"rates.h\"",
            "#include \"pointer.h\"",
            "#include \"cleanup.h\"",
            "#include \"scan.h\"",
            "#include \"user.h\"",
            "#include \"xevents.h\"",
            "#include \"win_utils.h\"",
            "#include \"xinerama.h\"",
            "#include \"xrecord.h\"",
            "#include \"xdamage.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void mark_for_xdamage(int x, int y, int w, int h);",
            "void set_xdamage_mark(int x, int y, int w, int h);",
            "int find_rect(int idx, int x, int y, int w, int h);",
            "winattr_t *cache_list;",
            "int clipped(int idx);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"default8x16.h\"\n#include \"connections.h\"\n#include \"screen.h\"\n#include \"cursor.h\"\n#include \"macosxCGS.h\"\n#include \"macosx.h\"\n#include \"unixpw.h\"\n#include \"8to24.h\"\n#include \"xrandr.h\"\n#include \"solid.h\"\n#include \"keyboard.h\"\n#include \"rates.h\"\n#include \"pointer.h\"\n#include \"cleanup.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"xevents.h\"\n#include \"win_utils.h\"\n#include \"xinerama.h\"\n#include \"xrecord.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nvoid mark_for_xdamage(int x, int y, int w, int h);\nvoid set_xdamage_mark(int x, int y, int w, int h);\nint find_rect(int idx, int x, int y, int w, int h);\nwinattr_t *cache_list;\nint clipped(int idx);\n\nint free_rect(int idx) {\n\tint n, ok = 0;\n\tsraRegionPtr r1, r2;\n\tint x, y, w, h;\n\n\tif (idx < 0 || idx >= cache_list_num) {\nif (0) fprintf(stderr, \"free_rect: bad index: %d\\n\", idx);\n\t\tclean_up_exit(1);\n\t}\n\n\tx = cache_list[idx].bs_x;\n\ty = cache_list[idx].bs_y;\n\tw = cache_list[idx].bs_w;\n\th = cache_list[idx].bs_h;\n\n\tif (x < 0) {\n\t\tCLEAR(idx);\nif (dnow() > last_client + 5 && ncdb) fprintf(stderr, \"free_rect: already bs_x invalidated: %d bs_x: %d\\n\", idx, x);\n\t\treturn 1;\n\t}\n\n\tr2 = sraRgnCreateRect(x, y, x+w, y+h);\n\n\tn = get_bs_n(y);\n\tif (n >= 0) {\n\t\tr1 = rect_reg[n];\n\t\tsraRgnOr(r1, r2);\n\t\tok = 1;\n\t}\n\n\tif (zero_rects) {\n\t\tsraRgnOr(zero_rects, r2);\n\t\tx = cache_list[idx].su_x;\n\t\ty = cache_list[idx].su_y;\n\t\tw = cache_list[idx].su_w;\n\t\th = cache_list[idx].su_h;\n\t\tif (x >= 0) {\n\t\t\tsraRgnDestroy(r2);\n\t\t\tr2 = sraRgnCreateRect(x, y, x+w, y+h);\n\t\t\tsraRgnOr(zero_rects, r2);\n\t\t}\n\t}\n\tsraRgnDestroy(r2);\n\n\tCLEAR(idx);\nif (! ok && ncdb) fprintf(stderr, \"**** free_rect: not-found %d\\n\", idx);\n\treturn ok;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fclose",
          "args": [
            "rc"
          ],
          "line": 1239
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"too many rcfile options\\n\""
          ],
          "line": 1234
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "tbuf"
          ],
          "line": 1231
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "calloc",
          "args": [
            "strlen(p) + 1",
            "1"
          ],
          "line": 1219
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "p"
          ],
          "line": 1219
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lblanks",
          "args": [
            "p"
          ],
          "line": 1212
        },
        "resolved": true,
        "details": {
          "function_name": "lblanks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/util.c",
          "lines": "160-169",
          "snippet": "char *lblanks(char *str) {\n\tchar *p = str;\n\twhile (*p != '\\0') {\n\t\tif (! isspace((unsigned char) (*p))) {\n\t\t\tbreak;\n\t\t}\n\t\tp++;\n\t}\n\treturn p;\n}",
          "includes": [
            "#include \"connections.h\"",
            "#include \"unixpw.h\"",
            "#include \"win_utils.h\"",
            "#include \"cleanup.h\"",
            "#include \"x11vnc.h\"",
            "#include <stdlib.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void lowercase(char *str);",
            "void uppercase(char *str);",
            "char *lblanks(char *str);",
            "void strzero(char *str);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"connections.h\"\n#include \"unixpw.h\"\n#include \"win_utils.h\"\n#include \"cleanup.h\"\n#include \"x11vnc.h\"\n#include <stdlib.h>\n\nvoid lowercase(char *str);\nvoid uppercase(char *str);\nchar *lblanks(char *str);\nvoid strzero(char *str);\n\nchar *lblanks(char *str) {\n\tchar *p = str;\n\twhile (*p != '\\0') {\n\t\tif (! isspace((unsigned char) (*p))) {\n\t\t\tbreak;\n\t\t}\n\t\tp++;\n\t}\n\treturn p;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "parm"
          ],
          "line": 1211
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"too many rcfile options\\n\""
          ],
          "line": 1206
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "tmp"
          ],
          "line": 1204
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "check_loop_mode",
          "args": [
            "argc",
            "argv",
            "1"
          ],
          "line": 1199
        },
        "resolved": true,
        "details": {
          "function_name": "check_loop_mode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/x11vnc.c",
          "lines": "1644-1727",
          "snippet": "static void check_loop_mode(int argc, char* argv[], int force) {\n\tint i;\n\tint loop_mode = 0, loop_sleep = 2000, loop_max = 0;\n\n\tif (force) {\n\t\tloop_mode = 1;\n\t}\n\tfor (i=1; i < argc; i++) {\n\t\tchar *p = argv[i];\n\t\tif (strstr(p, \"--\") == p) {\n\t\t\tp++;\n\t\t}\n\t\tif (strstr(p, \"-loop\") == p) {\n\t\t\tchar *q;\n\t\t\tloop_mode = 1;\n\t\t\tif ((q = strchr(p, ',')) != NULL) {\n\t\t\t\tloop_max = atoi(q+1);\n\t\t\t\t*q = '\\0';\n\t\t\t}\n\t\t\tif (strstr(p, \"-loopbg\") == p) {\n\t\t\t\tset_env(\"X11VNC_LOOP_MODE_BG\", \"1\");\n\t\t\t\tloop_sleep = 500;\n\t\t\t}\n\t\t\t\n\t\t\tq = strpbrk(p, \"0123456789\");\n\t\t\tif (q) {\n\t\t\t\tloop_sleep = atoi(q);\n\t\t\t\tif (loop_sleep <= 0) {\n\t\t\t\t\tloop_sleep = 20;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tif (loop_mode && getenv(\"X11VNC_LOOP_MODE\") == NULL) {\n#if LIBVNCSERVER_HAVE_FORK\n\t\tchar **argv2;\n\t\tint k, i = 1;\n\n\t\tset_env(\"X11VNC_LOOP_MODE\", \"1\");\n\t\targv2 = (char **) malloc((argc+1)*sizeof(char *));\n\n\t\tfor (k=0; k < argc+1; k++) {\n\t\t\targv2[k] = NULL;\n\t\t\tif (k < argc) {\n\t\t\t\targv2[k] = argv[k];\n\t\t\t}\n\t\t}\n\t\twhile (1) {\n\t\t\tint status;\n\t\t\tpid_t p;\n\t\t\tfprintf(stderr, \"\\n --- x11vnc loop: %d ---\\n\\n\", i++);\n\t\t\tfflush(stderr);\n\t\t\tusleep(500 * 1000);\n\t\t\tif ((p = fork()) > 0)  {\n\t\t\t\tfprintf(stderr, \" --- x11vnc loop: waiting \"\n\t\t\t\t    \"for: %d\\n\\n\", p);\n\t\t\t\twait(&status);\n\t\t\t} else if (p == -1) {\n\t\t\t\tfprintf(stderr, \"could not fork\\n\");\n\t\t\t\tperror(\"fork\");\n\t\t\t\texit(1);\n\t\t\t} else {\n\t\t\t\t/* loop mode: no_external_cmds does not apply */\n\t\t\t\texecvp(argv[0], argv2); \n\t\t\t\texit(1);\n\t\t\t}\n\n\t\t\tif (loop_max > 0 && i > loop_max) {\n\t\t\t\tfprintf(stderr, \"\\n --- x11vnc loop: did %d\"\n\t\t\t\t    \" done. ---\\n\\n\", loop_max);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t\tfprintf(stderr, \"\\n --- x11vnc loop: sleeping %d ms \"\n\t\t\t    \"---\\n\\n\", loop_sleep);\n\t\t\tusleep(loop_sleep * 1000);\n\t\t}\n\t\texit(0);\n#else\n\t\tfprintf(stderr, \"fork unavailable, cannot do -loop mode\\n\");\n\t\texit(1);\n#endif\n\t}\n}",
          "includes": [
            "#include \"xi2_devices.h\"",
            "#include \"solid.h\"",
            "#include \"pm.h\"",
            "#include \"selection.h\"",
            "#include \"sslhelper.h\"",
            "#include \"sslcmds.h\"",
            "#include \"inet.h\"",
            "#include \"unixpw.h\"",
            "#include \"rates.h\"",
            "#include \"connections.h\"",
            "#include \"screen.h\"",
            "#include \"userinput.h\"",
            "#include \"cursor.h\"",
            "#include \"pointer.h\"",
            "#include \"keyboard.h\"",
            "#include \"cleanup.h\"",
            "#include \"user.h\"",
            "#include \"help.h\"",
            "#include \"gui.h\"",
            "#include \"scan.h\"",
            "#include \"remote.h\"",
            "#include \"win_utils.h\"",
            "#include \"xkb_bell.h\"",
            "#include \"xrandr.h\"",
            "#include \"xinerama.h\"",
            "#include \"xevents.h\"",
            "#include \"xrecord.h\"",
            "#include \"xdamage.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void check_rcfile(int argc, char **argv);",
            "static void immediate_switch_user(int argc, char* argv[]);",
            "static void check_loop_mode(int argc, char* argv[], int force);",
            "static void check_appshare_mode(int argc, char* argv[]);",
            "static char **argv2;",
            "extern int appshare_main(int argc, char* argv[]);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xi2_devices.h\"\n#include \"solid.h\"\n#include \"pm.h\"\n#include \"selection.h\"\n#include \"sslhelper.h\"\n#include \"sslcmds.h\"\n#include \"inet.h\"\n#include \"unixpw.h\"\n#include \"rates.h\"\n#include \"connections.h\"\n#include \"screen.h\"\n#include \"userinput.h\"\n#include \"cursor.h\"\n#include \"pointer.h\"\n#include \"keyboard.h\"\n#include \"cleanup.h\"\n#include \"user.h\"\n#include \"help.h\"\n#include \"gui.h\"\n#include \"scan.h\"\n#include \"remote.h\"\n#include \"win_utils.h\"\n#include \"xkb_bell.h\"\n#include \"xrandr.h\"\n#include \"xinerama.h\"\n#include \"xevents.h\"\n#include \"xrecord.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nstatic void check_rcfile(int argc, char **argv);\nstatic void immediate_switch_user(int argc, char* argv[]);\nstatic void check_loop_mode(int argc, char* argv[], int force);\nstatic void check_appshare_mode(int argc, char* argv[]);\nstatic char **argv2;\nextern int appshare_main(int argc, char* argv[]);\n\nstatic void check_loop_mode(int argc, char* argv[], int force) {\n\tint i;\n\tint loop_mode = 0, loop_sleep = 2000, loop_max = 0;\n\n\tif (force) {\n\t\tloop_mode = 1;\n\t}\n\tfor (i=1; i < argc; i++) {\n\t\tchar *p = argv[i];\n\t\tif (strstr(p, \"--\") == p) {\n\t\t\tp++;\n\t\t}\n\t\tif (strstr(p, \"-loop\") == p) {\n\t\t\tchar *q;\n\t\t\tloop_mode = 1;\n\t\t\tif ((q = strchr(p, ',')) != NULL) {\n\t\t\t\tloop_max = atoi(q+1);\n\t\t\t\t*q = '\\0';\n\t\t\t}\n\t\t\tif (strstr(p, \"-loopbg\") == p) {\n\t\t\t\tset_env(\"X11VNC_LOOP_MODE_BG\", \"1\");\n\t\t\t\tloop_sleep = 500;\n\t\t\t}\n\t\t\t\n\t\t\tq = strpbrk(p, \"0123456789\");\n\t\t\tif (q) {\n\t\t\t\tloop_sleep = atoi(q);\n\t\t\t\tif (loop_sleep <= 0) {\n\t\t\t\t\tloop_sleep = 20;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tif (loop_mode && getenv(\"X11VNC_LOOP_MODE\") == NULL) {\n#if LIBVNCSERVER_HAVE_FORK\n\t\tchar **argv2;\n\t\tint k, i = 1;\n\n\t\tset_env(\"X11VNC_LOOP_MODE\", \"1\");\n\t\targv2 = (char **) malloc((argc+1)*sizeof(char *));\n\n\t\tfor (k=0; k < argc+1; k++) {\n\t\t\targv2[k] = NULL;\n\t\t\tif (k < argc) {\n\t\t\t\targv2[k] = argv[k];\n\t\t\t}\n\t\t}\n\t\twhile (1) {\n\t\t\tint status;\n\t\t\tpid_t p;\n\t\t\tfprintf(stderr, \"\\n --- x11vnc loop: %d ---\\n\\n\", i++);\n\t\t\tfflush(stderr);\n\t\t\tusleep(500 * 1000);\n\t\t\tif ((p = fork()) > 0)  {\n\t\t\t\tfprintf(stderr, \" --- x11vnc loop: waiting \"\n\t\t\t\t    \"for: %d\\n\\n\", p);\n\t\t\t\twait(&status);\n\t\t\t} else if (p == -1) {\n\t\t\t\tfprintf(stderr, \"could not fork\\n\");\n\t\t\t\tperror(\"fork\");\n\t\t\t\texit(1);\n\t\t\t} else {\n\t\t\t\t/* loop mode: no_external_cmds does not apply */\n\t\t\t\texecvp(argv[0], argv2); \n\t\t\t\texit(1);\n\t\t\t}\n\n\t\t\tif (loop_max > 0 && i > loop_max) {\n\t\t\t\tfprintf(stderr, \"\\n --- x11vnc loop: did %d\"\n\t\t\t\t    \" done. ---\\n\\n\", loop_max);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t\tfprintf(stderr, \"\\n --- x11vnc loop: sleeping %d ms \"\n\t\t\t    \"---\\n\\n\", loop_sleep);\n\t\t\tusleep(loop_sleep * 1000);\n\t\t}\n\t\texit(0);\n#else\n\t\tfprintf(stderr, \"fork unavailable, cannot do -loop mode\\n\");\n\t\texit(1);\n#endif\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "getenv",
          "args": [
            "\"X11VNC_LOOP_MODE\""
          ],
          "line": 1198
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "tmp",
            "\"-loop\""
          ],
          "line": 1197
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncpy",
          "args": [
            "tmp+1",
            "parm",
            "400"
          ],
          "line": 1194
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncpy",
          "args": [
            "tmp",
            "parm",
            "400"
          ],
          "line": 1191
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"invalid rcfile line: %s\\n\"",
            "p"
          ],
          "line": 1187
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sscanf",
          "args": [
            "buf",
            "\"%s\"",
            "parm"
          ],
          "line": 1186
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"invalid rcfile line: %s/%s\\n\"",
            "p",
            "buf"
          ],
          "line": 1181
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isspace",
          "args": [
            "(unsigned char) (*q)"
          ],
          "line": 1174
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncat",
          "args": [
            "buf",
            "p",
            "sz - strlen(buf) - 1"
          ],
          "line": 1162
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "buf"
          ],
          "line": 1162
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isspace",
          "args": [
            "(unsigned char) (*q)"
          ],
          "line": 1151
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isspace",
          "args": [
            "(unsigned char) (*q)"
          ],
          "line": 1135
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fgets",
          "args": [
            "line",
            "4096",
            "rc"
          ],
          "line": 1107
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "sz"
          ],
          "line": 1104
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "perror",
          "args": [
            "\"fstat\""
          ],
          "line": 1096
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"problem with %s\\n\"",
            "infile"
          ],
          "line": 1095
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fstat",
          "args": [
            "fileno(rc)",
            "&sbuf"
          ],
          "line": 1094
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fileno",
          "args": [
            "rc"
          ],
          "line": 1094
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "argv[0]"
          ],
          "line": 1086
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "argmax * sizeof(char *)"
          ],
          "line": 1085
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "rcfile"
          ],
          "line": 1079
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fopen",
          "args": [
            "rcfile",
            "\"r\""
          ],
          "line": 1075
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcat",
          "args": [
            "rcfile",
            "\"/.x11vncrc\""
          ],
          "line": 1073
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncpy",
          "args": [
            "rcfile",
            "home",
            "500"
          ],
          "line": 1070
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "rcfile",
            "0",
            "sizeof(rcfile)"
          ],
          "line": 1069
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_home_dir",
          "args": [],
          "line": 1065
        },
        "resolved": true,
        "details": {
          "function_name": "get_home_dir",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/util.c",
          "lines": "295-314",
          "snippet": "char *get_home_dir(void) {\n\tchar *home = NULL;\n\n\thome = getenv(\"HOME\");\n\n#if HAVE_PWD_H\n\tif (home == NULL) {\n\t\tstruct passwd *pw = getpwuid(getuid());\n\t\tif (pw) {\n\t\t\thome = pw->pw_dir;\n\t\t}\n\t}\n#endif\n\n\tif (home) {\n\t\treturn(strdup(home));\n\t} else {\n\t\treturn(strdup(\"/\"));\n\t}\n}",
          "includes": [
            "#include \"connections.h\"",
            "#include \"unixpw.h\"",
            "#include \"win_utils.h\"",
            "#include \"cleanup.h\"",
            "#include \"x11vnc.h\"",
            "#include <stdlib.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "char *get_home_dir(void);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"connections.h\"\n#include \"unixpw.h\"\n#include \"win_utils.h\"\n#include \"cleanup.h\"\n#include \"x11vnc.h\"\n#include <stdlib.h>\n\nchar *get_home_dir(void);\n\nchar *get_home_dir(void) {\n\tchar *home = NULL;\n\n\thome = getenv(\"HOME\");\n\n#if HAVE_PWD_H\n\tif (home == NULL) {\n\t\tstruct passwd *pw = getpwuid(getuid());\n\t\tif (pw) {\n\t\t\thome = pw->pw_dir;\n\t\t}\n\t}\n#endif\n\n\tif (home) {\n\t\treturn(strdup(home));\n\t} else {\n\t\treturn(strdup(\"/\"));\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "perror",
          "args": [
            "\"fopen\""
          ],
          "line": 1061
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"could not open rcfile: %s\\n\"",
            "infile"
          ],
          "line": 1060
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "infile"
          ],
          "line": 1058
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fopen",
          "args": [
            "infile",
            "\"r\""
          ],
          "line": 1057
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "\"\""
          ],
          "line": 1053
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"-rc option requires a \"\n\t\t\t\t    \"filename\\n\""
          ],
          "line": 1044
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "argv[i]",
            "\"-rc\""
          ],
          "line": 1042
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "argv[i]",
            "\"-QD\""
          ],
          "line": 1039
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "argv[i]",
            "\"-norc\""
          ],
          "line": 1035
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fflush",
          "args": [
            "stdout"
          ],
          "line": 1032
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stdout",
            "\"%s\"",
            "get_gui_code()"
          ],
          "line": 1031
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_gui_code",
          "args": [],
          "line": 1031
        },
        "resolved": true,
        "details": {
          "function_name": "get_gui_code",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/gui.c",
          "lines": "74-76",
          "snippet": "char *get_gui_code(void) {\n\treturn gui_code;\n}",
          "includes": [
            "#include \"tkx11vnc.h\"",
            "#include \"connections.h\"",
            "#include \"xwrappers.h\"",
            "#include \"cleanup.h\"",
            "#include \"remote.h\"",
            "#include \"win_utils.h\"",
            "#include \"xevents.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "char *get_gui_code(void);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tkx11vnc.h\"\n#include \"connections.h\"\n#include \"xwrappers.h\"\n#include \"cleanup.h\"\n#include \"remote.h\"\n#include \"win_utils.h\"\n#include \"xevents.h\"\n#include \"x11vnc.h\"\n\nchar *get_gui_code(void);\n\nchar *get_gui_code(void) {\n\treturn gui_code;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "argv[i]",
            "\"-printgui\""
          ],
          "line": 1030
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xi2_devices.h\"\n#include \"solid.h\"\n#include \"pm.h\"\n#include \"selection.h\"\n#include \"sslhelper.h\"\n#include \"sslcmds.h\"\n#include \"inet.h\"\n#include \"unixpw.h\"\n#include \"rates.h\"\n#include \"connections.h\"\n#include \"screen.h\"\n#include \"userinput.h\"\n#include \"cursor.h\"\n#include \"pointer.h\"\n#include \"keyboard.h\"\n#include \"cleanup.h\"\n#include \"user.h\"\n#include \"help.h\"\n#include \"gui.h\"\n#include \"scan.h\"\n#include \"remote.h\"\n#include \"win_utils.h\"\n#include \"xkb_bell.h\"\n#include \"xrandr.h\"\n#include \"xinerama.h\"\n#include \"xevents.h\"\n#include \"xrecord.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nstatic void check_rcfile(int argc, char **argv);\nstatic void immediate_switch_user(int argc, char* argv[]);\nstatic void check_loop_mode(int argc, char* argv[], int force);\nstatic void check_appshare_mode(int argc, char* argv[]);\nstatic int argc2 = 0;\nstatic char **argv2;\nextern int appshare_main(int argc, char* argv[]);\n\nstatic void check_rcfile(int argc, char **argv) {\n\tint i, j, pwlast, enclast, norc = 0, argmax = 1024;\n\tchar *infile = NULL;\n\tchar rcfile[1024];\n\tFILE *rc = NULL; \n\n\tfor (i=1; i < argc; i++) {\n\t\tif (!strcmp(argv[i], \"-printgui\")) {\n\t\t\tfprintf(stdout, \"%s\", get_gui_code());\n\t\t\tfflush(stdout);\n\t\t\texit(0);\n\t\t}\n\t\tif (!strcmp(argv[i], \"-norc\")) {\n\t\t\tnorc = 1;\n\t\t\tgot_norc = 1;\n\t\t}\n\t\tif (!strcmp(argv[i], \"-QD\")) {\n\t\t\tnorc = 1;\n\t\t}\n\t\tif (!strcmp(argv[i], \"-rc\")) {\n\t\t\tif (i+1 >= argc) {\n\t\t\t\tfprintf(stderr, \"-rc option requires a \"\n\t\t\t\t    \"filename\\n\");\n\t\t\t\texit(1);\n\t\t\t} else {\n\t\t\t\tinfile = argv[i+1];\n\t\t\t}\n\t\t}\n\t}\n\trc_norc = norc;\n\trc_rcfile = strdup(\"\");\n\tif (norc) {\n\t\t;\n\t} else if (infile != NULL) {\n\t\trc = fopen(infile, \"r\");\n\t\trc_rcfile = strdup(infile);\n\t\tif (rc == NULL) {\n\t\t\tfprintf(stderr, \"could not open rcfile: %s\\n\", infile);\n\t\t\tperror(\"fopen\");\n\t\t\texit(1);\n\t\t}\n\t} else {\n\t\tchar *home = get_home_dir();\n\t\tif (! home) {\n\t\t\tnorc = 1;\n\t\t} else {\n\t\t\tmemset(rcfile, 0, sizeof(rcfile));\n\t\t\tstrncpy(rcfile, home, 500);\n\t\t\tfree(home);\n\n\t\t\tstrcat(rcfile, \"/.x11vncrc\");\n\t\t\tinfile = rcfile;\n\t\t\trc = fopen(rcfile, \"r\");\n\t\t\tif (rc == NULL) {\n\t\t\t\tnorc = 1;\n\t\t\t} else {\n\t\t\t\trc_rcfile = strdup(rcfile);\n\t\t\t\trc_rcfile_default = 1;\n\t\t\t}\n\t\t}\n\t}\n\n\targv2 = (char **) malloc(argmax * sizeof(char *));\n\targv2[argc2++] = strdup(argv[0]);\n\n\tif (! norc) {\n\t\tchar line[4096], parm[400], tmp[401];\n\t\tchar *buf, *tbuf;\n\t\tstruct stat sbuf;\n\t\tint sz;\n\n\t\tif (fstat(fileno(rc), &sbuf) != 0) {\n\t\t\tfprintf(stderr, \"problem with %s\\n\", infile);\n\t\t\tperror(\"fstat\");\n\t\t\texit(1);\n\t\t}\n\t\tsz = sbuf.st_size+1;\t/* allocate whole file size */\n\t\tif (sz < 1024) {\n\t\t\tsz = 1024;\n\t\t}\n\n\t\tbuf = (char *) malloc(sz);\n\t\tbuf[0] = '\\0';\n\n\t\twhile (fgets(line, 4096, rc) != NULL) {\n\t\t\tchar *q, *p = line;\n\t\t\tchar c;\n\t\t\tint cont = 0;\n\n\t\t\tq = p;\n\t\t\tc = '\\0';\n\t\t\twhile (*q) {\n\t\t\t\tif (*q == '#') {\n\t\t\t\t\tif (c != '\\\\') {\n\t\t\t\t\t\t*q = '\\0';\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tc = *q;\n\t\t\t\tq++;\n\t\t\t}\n\n\t\t\tq = p;\n\t\t\tc = '\\0';\n\t\t\twhile (*q) {\n\t\t\t\tif (*q == '\\n') {\n\t\t\t\t\tif (c == '\\\\') {\n\t\t\t\t\t\tcont = 1;\n\t\t\t\t\t\t*q = '\\0';\n\t\t\t\t\t\t*(q-1) = ' ';\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\twhile (isspace((unsigned char) (*q))) {\n\t\t\t\t\t\t*q = '\\0';\n\t\t\t\t\t\tif (q == p) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tq--;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tc = *q;\n\t\t\t\tq++;\n\t\t\t}\n\t\t\tif (q != p && !cont) {\n\t\t\t\tif (*q == '\\0') {\n\t\t\t\t\tq--;\n\t\t\t\t}\n\t\t\t\twhile (isspace((unsigned char) (*q))) {\n\t\t\t\t\t*q = '\\0';\n\t\t\t\t\tif (q == p) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tq--;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tp = lblanks(p);\n\n\t\t\tstrncat(buf, p, sz - strlen(buf) - 1);\n\t\t\tif (cont) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (buf[0] == '\\0') {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\ti = 0;\n\t\t\tq = buf;\n\t\t\twhile (*q) {\n\t\t\t\ti++;\n\t\t\t\tif (*q == '\\n' || isspace((unsigned char) (*q))) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tq++;\n\t\t\t}\n\n\t\t\tif (i >= 400) {\n\t\t\t\tfprintf(stderr, \"invalid rcfile line: %s/%s\\n\",\n\t\t\t\t    p, buf);\n\t\t\t\texit(1);\n\t\t\t}\n\n\t\t\tif (sscanf(buf, \"%s\", parm) != 1) {\n\t\t\t\tfprintf(stderr, \"invalid rcfile line: %s\\n\", p);\n\t\t\t\texit(1);\n\t\t\t}\n\t\t\tif (parm[0] == '-') {\n\t\t\t\tstrncpy(tmp, parm, 400); \n\t\t\t} else {\n\t\t\t\ttmp[0] = '-';\n\t\t\t\tstrncpy(tmp+1, parm, 400); \n\t\t\t}\n\n\t\t\tif (strstr(tmp, \"-loop\") == tmp) {\n\t\t\t\tif (! getenv(\"X11VNC_LOOP_MODE\")) {\n\t\t\t\t\tcheck_loop_mode(argc, argv, 1);\n\t\t\t\t\texit(0);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\targv2[argc2++] = strdup(tmp);\n\t\t\tif (argc2 >= argmax) {\n\t\t\t\tfprintf(stderr, \"too many rcfile options\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\t\t\t\n\t\t\tp = buf;\n\t\t\tp += strlen(parm);\n\t\t\tp = lblanks(p);\n\n\t\t\tif (*p == '\\0') {\n\t\t\t\tbuf[0] = '\\0';\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\ttbuf = (char *) calloc(strlen(p) + 1, 1);\n\n\t\t\tj = 0;\n\t\t\twhile (*p) {\n\t\t\t\tif (*p == '\\\\' && *(p+1) == '#') {\n\t\t\t\t\t;\n\t\t\t\t} else {\n\t\t\t\t\ttbuf[j++] = *p;\n\t\t\t\t}\n\t\t\t\tp++;\n\t\t\t}\n\n\t\t\targv2[argc2++] = strdup(tbuf);\n\t\t\tfree(tbuf);\n\t\t\tif (argc2 >= argmax) {\n\t\t\t\tfprintf(stderr, \"too many rcfile options\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\t\t\tbuf[0] = '\\0';\n\t\t}\n\t\tfclose(rc);\n\t\tfree(buf);\n\t}\n\tpwlast = 0;\n\tenclast = 0;\n\tfor (i=1; i < argc; i++) {\n\t\targv2[argc2++] = strdup(argv[i]);\n\n\t\tif (pwlast || !strcmp(\"-passwd\", argv[i])\n\t\t    || !strcmp(\"-viewpasswd\", argv[i])) {\n\t\t\tchar *p = argv[i];\t\t\n\t\t\tif (pwlast) {\n\t\t\t\tpwlast = 0;\n\t\t\t} else {\n\t\t\t\tpwlast = 1;\n\t\t\t}\n\t\t\tstrzero(p);\n\t\t}\n\t\tif (enclast || !strcmp(\"-enc\", argv[i])) {\n\t\t\tchar *q, *p = argv[i];\t\t\n\t\t\tif (enclast) {\n\t\t\t\tenclast = 0;\n\t\t\t} else {\n\t\t\t\tenclast = 1;\n\t\t\t}\n\t\t\tq = strstr(p, \"pw=\");\n\t\t\tif (q) {\n\t\t\t\tstrzero(q);\n\t\t\t}\n\t\t}\n\t\tif (argc2 >= argmax) {\n\t\t\tfprintf(stderr, \"too many rcfile options\\n\");\n\t\t\texit(1);\n\t\t}\n\t}\n}"
  },
  {
    "function_name": "limit_shm",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/x11vnc.c",
    "lines": "990-1014",
    "snippet": "static int limit_shm(void) {\n\tint limit = 0;\n\n\tif (UT.sysname == NULL) {\n\t\treturn 0;\n\t}\n\tif (getenv(\"X11VNC_NO_LIMIT_SHM\")) {\n\t\treturn 0;\n\t}\n\tif (!strcmp(UT.sysname, \"SunOS\")) {\n\t\tchar *r = UT.release;\n\t\tif (*r == '5' && *(r+1) == '.') {\n\t\t\tif (strchr(\"2345678\", *(r+2)) != NULL) {\n\t\t\t\tlimit = 1;\n\t\t\t}\n\t\t}\n\t} else if (!strcmp(UT.sysname, \"Darwin\")) {\n\t\tlimit = 1;\n\t}\n\tif (limit && ! quiet) {\n\t\tfprintf(stderr, \"reducing shm usage on %s %s (adding \"\n\t\t    \"-onetile)\\n\", UT.sysname, UT.release);\n\t}\n\treturn limit;\n}",
    "includes": [
      "#include \"xi2_devices.h\"",
      "#include \"solid.h\"",
      "#include \"pm.h\"",
      "#include \"selection.h\"",
      "#include \"sslhelper.h\"",
      "#include \"sslcmds.h\"",
      "#include \"inet.h\"",
      "#include \"unixpw.h\"",
      "#include \"rates.h\"",
      "#include \"connections.h\"",
      "#include \"screen.h\"",
      "#include \"userinput.h\"",
      "#include \"cursor.h\"",
      "#include \"pointer.h\"",
      "#include \"keyboard.h\"",
      "#include \"cleanup.h\"",
      "#include \"user.h\"",
      "#include \"help.h\"",
      "#include \"gui.h\"",
      "#include \"scan.h\"",
      "#include \"remote.h\"",
      "#include \"win_utils.h\"",
      "#include \"xkb_bell.h\"",
      "#include \"xrandr.h\"",
      "#include \"xinerama.h\"",
      "#include \"xevents.h\"",
      "#include \"xrecord.h\"",
      "#include \"xdamage.h\"",
      "#include \"xwrappers.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int limit_shm(void);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"reducing shm usage on %s %s (adding \"\n\t\t    \"-onetile)\\n\"",
            "UT.sysname",
            "UT.release"
          ],
          "line": 1010
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "UT.sysname",
            "\"Darwin\""
          ],
          "line": 1006
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "\"2345678\"",
            "*(r+2)"
          ],
          "line": 1002
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "UT.sysname",
            "\"SunOS\""
          ],
          "line": 999
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getenv",
          "args": [
            "\"X11VNC_NO_LIMIT_SHM\""
          ],
          "line": 996
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xi2_devices.h\"\n#include \"solid.h\"\n#include \"pm.h\"\n#include \"selection.h\"\n#include \"sslhelper.h\"\n#include \"sslcmds.h\"\n#include \"inet.h\"\n#include \"unixpw.h\"\n#include \"rates.h\"\n#include \"connections.h\"\n#include \"screen.h\"\n#include \"userinput.h\"\n#include \"cursor.h\"\n#include \"pointer.h\"\n#include \"keyboard.h\"\n#include \"cleanup.h\"\n#include \"user.h\"\n#include \"help.h\"\n#include \"gui.h\"\n#include \"scan.h\"\n#include \"remote.h\"\n#include \"win_utils.h\"\n#include \"xkb_bell.h\"\n#include \"xrandr.h\"\n#include \"xinerama.h\"\n#include \"xevents.h\"\n#include \"xrecord.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nstatic int limit_shm(void);\n\nstatic int limit_shm(void) {\n\tint limit = 0;\n\n\tif (UT.sysname == NULL) {\n\t\treturn 0;\n\t}\n\tif (getenv(\"X11VNC_NO_LIMIT_SHM\")) {\n\t\treturn 0;\n\t}\n\tif (!strcmp(UT.sysname, \"SunOS\")) {\n\t\tchar *r = UT.release;\n\t\tif (*r == '5' && *(r+1) == '.') {\n\t\t\tif (strchr(\"2345678\", *(r+2)) != NULL) {\n\t\t\t\tlimit = 1;\n\t\t\t}\n\t\t}\n\t} else if (!strcmp(UT.sysname, \"Darwin\")) {\n\t\tlimit = 1;\n\t}\n\tif (limit && ! quiet) {\n\t\tfprintf(stderr, \"reducing shm usage on %s %s (adding \"\n\t\t    \"-onetile)\\n\", UT.sysname, UT.release);\n\t}\n\treturn limit;\n}"
  },
  {
    "function_name": "ssh_remote_tunnel",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/x11vnc.c",
    "lines": "860-985",
    "snippet": "void ssh_remote_tunnel(char *instr, int lport) {\n\tchar *q, *cmd, *ssh;\n\tchar *s = strdup(instr);\n\tint sleep = 300, disp = 0, sport = 0;\n\tint rc, len, rport;\n\n\t/* user@host:port:disp+secs */\n\n\t/* +sleep */\n\tq = strrchr(s, '+');\n\tif (q) {\n\t\tsleep = atoi(q+1);\n\t\tif (sleep <= 0) {\n\t\t\tsleep = 1;\n\t\t}\n\t\t*q = '\\0';\n\t}\n\t/* :disp */\n\tq = strrchr(s, ':');\n\tif (q) {\n\t\tdisp = atoi(q+1);\n\t\t*q = '\\0';\n\t}\n\t\n\t/* :sshport */\n\tq = strrchr(s, ':');\n\tif (q) {\n\t\tsport = atoi(q+1);\n\t\t*q = '\\0';\n\t}\n\n\tif (getenv(\"SSH\")) {\n\t\tssh = getenv(\"SSH\");\n\t} else {\n\t\tssh = \"ssh\";\n\t}\n\n\tlen = 0;\n\tlen += strlen(ssh) + strlen(s) + 500;\n\tcmd = (char *) malloc(len);\n\n\tif (disp >= 0 && disp <= 200) {\n\t\trport = disp + 5900;\n\t} else if (disp < 0) {\n\t\trport = -disp;\n\t} else {\n\t\trport = disp;\n\t}\n\n\tif (sport > 0) {\n\t\tsprintf(cmd, \"%s -f -p %d -R '%d:localhost:%d' '%s' 'sleep %d'\", ssh, sport, rport, lport, s, sleep);\n\t} else {\n\t\tsprintf(cmd, \"%s -f       -R '%d:localhost:%d' '%s' 'sleep %d'\", ssh,        rport, lport, s, sleep);\n\t}\n\n\tif (no_external_cmds || !cmd_ok(\"ssh\")) {\n\t\trfbLogEnable(1);\n\t\trfbLog(\"cannot run external commands in -nocmds mode:\\n\");\n\t\trfbLog(\"   \\\"%s\\\"\\n\", cmd);\n\t\trfbLog(\"   exiting.\\n\");\n\t\tclean_up_exit(1);\n\t}\n\n\tclose_exec_fds();\n\tfprintf(stderr, \"\\n\");\n\trfbLog(\"running: %s\\n\", cmd);\n\trc = system(cmd);\n\n\tif (rc != 0) {\n\t\tfree(cmd);\n\t\tfree(s);\n\t\trfbLog(\"ssh remote listen failed.\\n\");\n\t\tclean_up_exit(1);\n\t}\n\n\tif (1) {\n\t\tFILE *pipe;\n\t\tint mypid = (int) getpid();\n\t\tint bestpid = -1;\n\t\tint best = -1;\n\t\tchar line[1024];\n\t\tchar *psef = \"ps -ef\";\n\t\tchar *psww = \"ps wwwwwwaux\";\n\t\tchar *ps = psef;\n\t\t/* not portable... but it is really good to terminate the ssh when done. */\n\t\t/* ps -ef | egrep 'ssh2.*-R.*5907:localhost:5900.*runge@celias.lbl.gov.*sleep 300' | grep -v grep | awk '{print $2}' */\n\t\tif (strstr(UT.sysname, \"Linux\")) {\n\t\t\tps = psww;\n\t\t} else if (strstr(UT.sysname, \"BSD\")) {\n\t\t\tps = psww;\n\t\t} else if (strstr(UT.sysname, \"Darwin\")) {\n\t\t\tps = psww;\n\t\t}\n\t\tsprintf(cmd, \"env COLUMNS=256 %s | egrep '%s.*-R *%d:localhost:%d.*%s.*sleep *%d' | grep -v grep | awk '{print $2}'\", ps, ssh, rport, lport, s, sleep);\n\t\tpipe = popen(cmd, \"r\");\n\t\tif (pipe) {\n\t\t\twhile (fgets(line, 1024, pipe) != NULL) {\n\t\t\t\tint p = atoi(line);\n\t\t\t\tif (p > 0) {\n\t\t\t\t\tint score;\n\t\t\t\t\tif (p > mypid) \t{\n\t\t\t\t\t\tscore = p - mypid;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tscore = p - mypid + 32768;\n\t\t\t\t\t\tif (score < 0) {\n\t\t\t\t\t\t\tscore = 32768;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (best < 0 || score < best) {\n\t\t\t\t\t\tbest = score;\n\t\t\t\t\t\tbestpid = p;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tpclose(pipe);\n\t\t}\n\n\t\tif (bestpid != -1) {\n\t\t\tssh_pid = (pid_t) bestpid;\n\t\t\trfbLog(\"guessed ssh pid=%d, will terminate it on exit.\\n\", bestpid);\n\t\t}\n\t}\n\n\tfree(cmd);\n\tfree(s);\n}",
    "includes": [
      "#include \"xi2_devices.h\"",
      "#include \"solid.h\"",
      "#include \"pm.h\"",
      "#include \"selection.h\"",
      "#include \"sslhelper.h\"",
      "#include \"sslcmds.h\"",
      "#include \"inet.h\"",
      "#include \"unixpw.h\"",
      "#include \"rates.h\"",
      "#include \"connections.h\"",
      "#include \"screen.h\"",
      "#include \"userinput.h\"",
      "#include \"cursor.h\"",
      "#include \"pointer.h\"",
      "#include \"keyboard.h\"",
      "#include \"cleanup.h\"",
      "#include \"user.h\"",
      "#include \"help.h\"",
      "#include \"gui.h\"",
      "#include \"scan.h\"",
      "#include \"remote.h\"",
      "#include \"win_utils.h\"",
      "#include \"xkb_bell.h\"",
      "#include \"xrandr.h\"",
      "#include \"xinerama.h\"",
      "#include \"xevents.h\"",
      "#include \"xrecord.h\"",
      "#include \"xdamage.h\"",
      "#include \"xwrappers.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "s"
          ],
          "line": 984
        },
        "resolved": true,
        "details": {
          "function_name": "free_rect",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/userinput.c",
          "lines": "6200-6247",
          "snippet": "int free_rect(int idx) {\n\tint n, ok = 0;\n\tsraRegionPtr r1, r2;\n\tint x, y, w, h;\n\n\tif (idx < 0 || idx >= cache_list_num) {\nif (0) fprintf(stderr, \"free_rect: bad index: %d\\n\", idx);\n\t\tclean_up_exit(1);\n\t}\n\n\tx = cache_list[idx].bs_x;\n\ty = cache_list[idx].bs_y;\n\tw = cache_list[idx].bs_w;\n\th = cache_list[idx].bs_h;\n\n\tif (x < 0) {\n\t\tCLEAR(idx);\nif (dnow() > last_client + 5 && ncdb) fprintf(stderr, \"free_rect: already bs_x invalidated: %d bs_x: %d\\n\", idx, x);\n\t\treturn 1;\n\t}\n\n\tr2 = sraRgnCreateRect(x, y, x+w, y+h);\n\n\tn = get_bs_n(y);\n\tif (n >= 0) {\n\t\tr1 = rect_reg[n];\n\t\tsraRgnOr(r1, r2);\n\t\tok = 1;\n\t}\n\n\tif (zero_rects) {\n\t\tsraRgnOr(zero_rects, r2);\n\t\tx = cache_list[idx].su_x;\n\t\ty = cache_list[idx].su_y;\n\t\tw = cache_list[idx].su_w;\n\t\th = cache_list[idx].su_h;\n\t\tif (x >= 0) {\n\t\t\tsraRgnDestroy(r2);\n\t\t\tr2 = sraRgnCreateRect(x, y, x+w, y+h);\n\t\t\tsraRgnOr(zero_rects, r2);\n\t\t}\n\t}\n\tsraRgnDestroy(r2);\n\n\tCLEAR(idx);\nif (! ok && ncdb) fprintf(stderr, \"**** free_rect: not-found %d\\n\", idx);\n\treturn ok;\n}",
          "includes": [
            "#include \"default8x16.h\"",
            "#include \"connections.h\"",
            "#include \"screen.h\"",
            "#include \"cursor.h\"",
            "#include \"macosxCGS.h\"",
            "#include \"macosx.h\"",
            "#include \"unixpw.h\"",
            "#include \"8to24.h\"",
            "#include \"xrandr.h\"",
            "#include \"solid.h\"",
            "#include \"keyboard.h\"",
            "#include \"rates.h\"",
            "#include \"pointer.h\"",
            "#include \"cleanup.h\"",
            "#include \"scan.h\"",
            "#include \"user.h\"",
            "#include \"xevents.h\"",
            "#include \"win_utils.h\"",
            "#include \"xinerama.h\"",
            "#include \"xrecord.h\"",
            "#include \"xdamage.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void mark_for_xdamage(int x, int y, int w, int h);",
            "void set_xdamage_mark(int x, int y, int w, int h);",
            "int find_rect(int idx, int x, int y, int w, int h);",
            "winattr_t *cache_list;",
            "int clipped(int idx);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"default8x16.h\"\n#include \"connections.h\"\n#include \"screen.h\"\n#include \"cursor.h\"\n#include \"macosxCGS.h\"\n#include \"macosx.h\"\n#include \"unixpw.h\"\n#include \"8to24.h\"\n#include \"xrandr.h\"\n#include \"solid.h\"\n#include \"keyboard.h\"\n#include \"rates.h\"\n#include \"pointer.h\"\n#include \"cleanup.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"xevents.h\"\n#include \"win_utils.h\"\n#include \"xinerama.h\"\n#include \"xrecord.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nvoid mark_for_xdamage(int x, int y, int w, int h);\nvoid set_xdamage_mark(int x, int y, int w, int h);\nint find_rect(int idx, int x, int y, int w, int h);\nwinattr_t *cache_list;\nint clipped(int idx);\n\nint free_rect(int idx) {\n\tint n, ok = 0;\n\tsraRegionPtr r1, r2;\n\tint x, y, w, h;\n\n\tif (idx < 0 || idx >= cache_list_num) {\nif (0) fprintf(stderr, \"free_rect: bad index: %d\\n\", idx);\n\t\tclean_up_exit(1);\n\t}\n\n\tx = cache_list[idx].bs_x;\n\ty = cache_list[idx].bs_y;\n\tw = cache_list[idx].bs_w;\n\th = cache_list[idx].bs_h;\n\n\tif (x < 0) {\n\t\tCLEAR(idx);\nif (dnow() > last_client + 5 && ncdb) fprintf(stderr, \"free_rect: already bs_x invalidated: %d bs_x: %d\\n\", idx, x);\n\t\treturn 1;\n\t}\n\n\tr2 = sraRgnCreateRect(x, y, x+w, y+h);\n\n\tn = get_bs_n(y);\n\tif (n >= 0) {\n\t\tr1 = rect_reg[n];\n\t\tsraRgnOr(r1, r2);\n\t\tok = 1;\n\t}\n\n\tif (zero_rects) {\n\t\tsraRgnOr(zero_rects, r2);\n\t\tx = cache_list[idx].su_x;\n\t\ty = cache_list[idx].su_y;\n\t\tw = cache_list[idx].su_w;\n\t\th = cache_list[idx].su_h;\n\t\tif (x >= 0) {\n\t\t\tsraRgnDestroy(r2);\n\t\t\tr2 = sraRgnCreateRect(x, y, x+w, y+h);\n\t\t\tsraRgnOr(zero_rects, r2);\n\t\t}\n\t}\n\tsraRgnDestroy(r2);\n\n\tCLEAR(idx);\nif (! ok && ncdb) fprintf(stderr, \"**** free_rect: not-found %d\\n\", idx);\n\treturn ok;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"guessed ssh pid=%d, will terminate it on exit.\\n\"",
            "bestpid"
          ],
          "line": 979
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pclose",
          "args": [
            "pipe"
          ],
          "line": 974
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atoi",
          "args": [
            "line"
          ],
          "line": 957
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fgets",
          "args": [
            "line",
            "1024",
            "pipe"
          ],
          "line": 956
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "popen",
          "args": [
            "cmd",
            "\"r\""
          ],
          "line": 954
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "cmd",
            "\"env COLUMNS=256 %s | egrep '%s.*-R *%d:localhost:%d.*%s.*sleep *%d' | grep -v grep | awk '{print $2}'\"",
            "ps",
            "ssh",
            "rport",
            "lport",
            "s",
            "sleep"
          ],
          "line": 953
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "UT.sysname",
            "\"Darwin\""
          ],
          "line": 950
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "UT.sysname",
            "\"BSD\""
          ],
          "line": 948
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "UT.sysname",
            "\"Linux\""
          ],
          "line": 946
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getpid",
          "args": [],
          "line": 937
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clean_up_exit",
          "args": [
            "1"
          ],
          "line": 932
        },
        "resolved": true,
        "details": {
          "function_name": "clean_up_exit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/cleanup.c",
          "lines": "151-266",
          "snippet": "void clean_up_exit(int ret) {\n\tstatic int depth = 0;\n\texit_flag = 1;\n\n\tif (depth++ > 2) {\n\t\texit(ret);\n\t}\n\n\tif (icon_mode) {\n\t\tclean_icon_mode();\n\t}\n\n\t/* remove the shm areas: */\n\tclean_shm(0);\n\n\tstop_stunnel();\n\tif (use_openssl) {\n\t\tssl_helper_pid(0, 0);\t/* killall */\n\t}\n\n\tif (ssh_pid > 0) {\n\t\tkill(ssh_pid, SIGTERM);\n\t\tssh_pid = 0;\n\t}\n\n#ifdef MACOSX\n\tif (client_connect_file) {\n\t\tif (strstr(client_connect_file, \"/tmp/x11vnc-macosx-remote\")\n\t\t    == client_connect_file) {\n\t\t\tunlink(client_connect_file);\n\t\t}\n\t}\n\tif (macosx_console) {\n\t\tmacosxCG_fini();\n\t}\n#endif\n\n\tif (pipeinput_fh != NULL) {\n\t\tpclose(pipeinput_fh);\n\t\tpipeinput_fh = NULL;\n\t}\n\n\tshutdown_uinput();\n\n\tif (unix_sock) {\n\t\tif (unix_sock_fd >= 0) {\n\t\t\trfbLog(\"deleting unix sock: %s\\n\", unix_sock);\n\t\t\tclose(unix_sock_fd);\n\t\t\tunix_sock_fd = -1;\n\t\t\tunlink(unix_sock);\n\t\t}\n\t}\n\n\tif (! dpy) {\t/* raw_rb hack */\n\t\tif (rm_flagfile) {\n\t\t\tunlink(rm_flagfile);\n\t\t\trm_flagfile = NULL;\n\t\t}\n\t\texit(ret);\n\t}\n\n\t/* X keyboard cleanups */\n\tdelete_added_keycodes(0);\n\n\t/* remove all created XInput2 devices */\n\tif(use_multipointer)\n\t    removeAllMDs(dpy);\n\n\tif (clear_mods == 1) {\n\t\tclear_modifiers(0);\n\t} else if (clear_mods == 2) {\n\t\tclear_keys();\n\t} else if (clear_mods == 3) {\n\t\tclear_keys();\n\t\tclear_locks();\n\t}\n\n\tif (no_autorepeat) {\n\t\tautorepeat(1, 0);\n\t}\n\tif (use_solid_bg) {\n\t\tsolid_bg(1);\n\t}\n\tif (ncache || ncache0) {\n\t\tkde_no_animate(1);\n\t}\n\tX_LOCK;\n\tXTestDiscard_wr(dpy);\n#if HAVE_LIBXDAMAGE\n\tif (xdamage) {\n\t\tXDamageDestroy(dpy, xdamage);\n\t}\n#endif\n#if HAVE_LIBXTRAP\n\tif (trap_ctx) {\n\t\tXEFreeTC(trap_ctx);\n\t}\n#endif\n\t/* XXX rdpy_ctrl, etc. cannot close w/o blocking */\n\tXCloseDisplay_wr(dpy);\n\tX_UNLOCK;\n\n\tfflush(stderr);\n\n\tif (rm_flagfile) {\n\t\tunlink(rm_flagfile);\n\t\trm_flagfile = NULL;\n\t}\n\n\tif (avahi) {\n\t\tavahi_cleanup();\n\t\tfflush(stderr);\n\t}\n\n\texit(ret);\n}",
          "includes": [
            "#include \"xi2_devices.h\"",
            "#include \"uinput.h\"",
            "#include \"xevents.h\"",
            "#include \"xrecord.h\"",
            "#include \"screen.h\"",
            "#include \"avahi.h\"",
            "#include \"macosxCG.h\"",
            "#include \"macosx.h\"",
            "#include \"connections.h\"",
            "#include \"sslhelper.h\"",
            "#include \"sslcmds.h\"",
            "#include \"unixpw.h\"",
            "#include \"solid.h\"",
            "#include \"gui.h\"",
            "#include \"scan.h\"",
            "#include \"keyboard.h\"",
            "#include \"remote.h\"",
            "#include \"xdamage.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void clean_up_exit(int ret);",
            "int known_sigpipe_mode(char *s);",
            "static int exit_flag = 0;",
            "static void clean_icon_mode(void);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xi2_devices.h\"\n#include \"uinput.h\"\n#include \"xevents.h\"\n#include \"xrecord.h\"\n#include \"screen.h\"\n#include \"avahi.h\"\n#include \"macosxCG.h\"\n#include \"macosx.h\"\n#include \"connections.h\"\n#include \"sslhelper.h\"\n#include \"sslcmds.h\"\n#include \"unixpw.h\"\n#include \"solid.h\"\n#include \"gui.h\"\n#include \"scan.h\"\n#include \"keyboard.h\"\n#include \"remote.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nvoid clean_up_exit(int ret);\nint known_sigpipe_mode(char *s);\nstatic int exit_flag = 0;\nstatic void clean_icon_mode(void);\n\nvoid clean_up_exit(int ret) {\n\tstatic int depth = 0;\n\texit_flag = 1;\n\n\tif (depth++ > 2) {\n\t\texit(ret);\n\t}\n\n\tif (icon_mode) {\n\t\tclean_icon_mode();\n\t}\n\n\t/* remove the shm areas: */\n\tclean_shm(0);\n\n\tstop_stunnel();\n\tif (use_openssl) {\n\t\tssl_helper_pid(0, 0);\t/* killall */\n\t}\n\n\tif (ssh_pid > 0) {\n\t\tkill(ssh_pid, SIGTERM);\n\t\tssh_pid = 0;\n\t}\n\n#ifdef MACOSX\n\tif (client_connect_file) {\n\t\tif (strstr(client_connect_file, \"/tmp/x11vnc-macosx-remote\")\n\t\t    == client_connect_file) {\n\t\t\tunlink(client_connect_file);\n\t\t}\n\t}\n\tif (macosx_console) {\n\t\tmacosxCG_fini();\n\t}\n#endif\n\n\tif (pipeinput_fh != NULL) {\n\t\tpclose(pipeinput_fh);\n\t\tpipeinput_fh = NULL;\n\t}\n\n\tshutdown_uinput();\n\n\tif (unix_sock) {\n\t\tif (unix_sock_fd >= 0) {\n\t\t\trfbLog(\"deleting unix sock: %s\\n\", unix_sock);\n\t\t\tclose(unix_sock_fd);\n\t\t\tunix_sock_fd = -1;\n\t\t\tunlink(unix_sock);\n\t\t}\n\t}\n\n\tif (! dpy) {\t/* raw_rb hack */\n\t\tif (rm_flagfile) {\n\t\t\tunlink(rm_flagfile);\n\t\t\trm_flagfile = NULL;\n\t\t}\n\t\texit(ret);\n\t}\n\n\t/* X keyboard cleanups */\n\tdelete_added_keycodes(0);\n\n\t/* remove all created XInput2 devices */\n\tif(use_multipointer)\n\t    removeAllMDs(dpy);\n\n\tif (clear_mods == 1) {\n\t\tclear_modifiers(0);\n\t} else if (clear_mods == 2) {\n\t\tclear_keys();\n\t} else if (clear_mods == 3) {\n\t\tclear_keys();\n\t\tclear_locks();\n\t}\n\n\tif (no_autorepeat) {\n\t\tautorepeat(1, 0);\n\t}\n\tif (use_solid_bg) {\n\t\tsolid_bg(1);\n\t}\n\tif (ncache || ncache0) {\n\t\tkde_no_animate(1);\n\t}\n\tX_LOCK;\n\tXTestDiscard_wr(dpy);\n#if HAVE_LIBXDAMAGE\n\tif (xdamage) {\n\t\tXDamageDestroy(dpy, xdamage);\n\t}\n#endif\n#if HAVE_LIBXTRAP\n\tif (trap_ctx) {\n\t\tXEFreeTC(trap_ctx);\n\t}\n#endif\n\t/* XXX rdpy_ctrl, etc. cannot close w/o blocking */\n\tXCloseDisplay_wr(dpy);\n\tX_UNLOCK;\n\n\tfflush(stderr);\n\n\tif (rm_flagfile) {\n\t\tunlink(rm_flagfile);\n\t\trm_flagfile = NULL;\n\t}\n\n\tif (avahi) {\n\t\tavahi_cleanup();\n\t\tfflush(stderr);\n\t}\n\n\texit(ret);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"ssh remote listen failed.\\n\""
          ],
          "line": 931
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "system",
          "args": [
            "cmd"
          ],
          "line": 926
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"running: %s\\n\"",
            "cmd"
          ],
          "line": 925
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"\\n\""
          ],
          "line": 924
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "close_exec_fds",
          "args": [],
          "line": 923
        },
        "resolved": true,
        "details": {
          "function_name": "close_exec_fds",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/cleanup.c",
          "lines": "754-765",
          "snippet": "void close_exec_fds(void) {\n\tint fd;\n#ifdef FD_CLOEXEC\n\tfor (fd = 3; fd < 64; fd++) {\n\t\tint flags = fcntl(fd, F_GETFD);\n\t\tif (flags != -1) {\n\t\t\tflags |= FD_CLOEXEC;\n\t\t\tfcntl(fd, F_SETFD, flags);\n\t\t}\n\t}\n#endif\n}",
          "includes": [
            "#include \"xi2_devices.h\"",
            "#include \"uinput.h\"",
            "#include \"xevents.h\"",
            "#include \"xrecord.h\"",
            "#include \"screen.h\"",
            "#include \"avahi.h\"",
            "#include \"macosxCG.h\"",
            "#include \"macosx.h\"",
            "#include \"connections.h\"",
            "#include \"sslhelper.h\"",
            "#include \"sslcmds.h\"",
            "#include \"unixpw.h\"",
            "#include \"solid.h\"",
            "#include \"gui.h\"",
            "#include \"scan.h\"",
            "#include \"keyboard.h\"",
            "#include \"remote.h\"",
            "#include \"xdamage.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void close_exec_fds(void);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xi2_devices.h\"\n#include \"uinput.h\"\n#include \"xevents.h\"\n#include \"xrecord.h\"\n#include \"screen.h\"\n#include \"avahi.h\"\n#include \"macosxCG.h\"\n#include \"macosx.h\"\n#include \"connections.h\"\n#include \"sslhelper.h\"\n#include \"sslcmds.h\"\n#include \"unixpw.h\"\n#include \"solid.h\"\n#include \"gui.h\"\n#include \"scan.h\"\n#include \"keyboard.h\"\n#include \"remote.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nvoid close_exec_fds(void);\n\nvoid close_exec_fds(void) {\n\tint fd;\n#ifdef FD_CLOEXEC\n\tfor (fd = 3; fd < 64; fd++) {\n\t\tint flags = fcntl(fd, F_GETFD);\n\t\tif (flags != -1) {\n\t\t\tflags |= FD_CLOEXEC;\n\t\t\tfcntl(fd, F_SETFD, flags);\n\t\t}\n\t}\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"   exiting.\\n\""
          ],
          "line": 919
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"   \\\"%s\\\"\\n\"",
            "cmd"
          ],
          "line": 918
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"cannot run external commands in -nocmds mode:\\n\""
          ],
          "line": 917
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLogEnable",
          "args": [
            "1"
          ],
          "line": 916
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cmd_ok",
          "args": [
            "\"ssh\""
          ],
          "line": 915
        },
        "resolved": true,
        "details": {
          "function_name": "cmd_ok",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/connections.c",
          "lines": "436-460",
          "snippet": "int cmd_ok(char *cmd) {\n\tchar *p, *str;\n\tif (no_external_cmds) {\n\t\treturn 0;\n\t}\n\tif (! cmd || cmd[0] == '\\0') {\n\t\treturn 0;\n\t}\n\tif (! allowed_external_cmds) {\n\t\t/* default, allow any (overridden by -nocmds) */\n\t\treturn 1;\n\t}\n\n\tstr = strdup(allowed_external_cmds);\n\tp = strtok(str, \",\");\n\twhile (p) {\n\t\tif (!strcmp(p, cmd)) {\n\t\t\tfree(str);\n\t\t\treturn 1;\n\t\t}\n\t\tp = strtok(NULL, \",\");\n\t}\n\tfree(str);\n\treturn 0;\n}",
          "includes": [
            "#include \"xi2_devices.h\"",
            "#include \"xrandr.h\"",
            "#include \"pointer.h\"",
            "#include \"userinput.h\"",
            "#include \"macosxCG.h\"",
            "#include \"macosx.h\"",
            "#include \"win_utils.h\"",
            "#include \"xevents.h\"",
            "#include \"xwrappers.h\"",
            "#include \"sslhelper.h\"",
            "#include \"sslcmds.h\"",
            "#include \"scan.h\"",
            "#include \"user.h\"",
            "#include \"unixpw.h\"",
            "#include \"screen.h\"",
            "#include \"rates.h\"",
            "#include \"solid.h\"",
            "#include \"gui.h\"",
            "#include \"cleanup.h\"",
            "#include \"keyboard.h\"",
            "#include \"remote.h\"",
            "#include \"inet.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void close_clients(char *str);",
            "void set_client_input(char *str);",
            "int cmd_ok(char *cmd);",
            "void reverse_connect(char *str);",
            "void set_vnc_connect_prop(char *str);",
            "void set_x11vnc_remote_prop(char *str);",
            "void send_client_info(char *str);",
            "static rfbClientPtr *client_match(char *str);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xi2_devices.h\"\n#include \"xrandr.h\"\n#include \"pointer.h\"\n#include \"userinput.h\"\n#include \"macosxCG.h\"\n#include \"macosx.h\"\n#include \"win_utils.h\"\n#include \"xevents.h\"\n#include \"xwrappers.h\"\n#include \"sslhelper.h\"\n#include \"sslcmds.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"unixpw.h\"\n#include \"screen.h\"\n#include \"rates.h\"\n#include \"solid.h\"\n#include \"gui.h\"\n#include \"cleanup.h\"\n#include \"keyboard.h\"\n#include \"remote.h\"\n#include \"inet.h\"\n#include \"x11vnc.h\"\n\nvoid close_clients(char *str);\nvoid set_client_input(char *str);\nint cmd_ok(char *cmd);\nvoid reverse_connect(char *str);\nvoid set_vnc_connect_prop(char *str);\nvoid set_x11vnc_remote_prop(char *str);\nvoid send_client_info(char *str);\nstatic rfbClientPtr *client_match(char *str);\n\nint cmd_ok(char *cmd) {\n\tchar *p, *str;\n\tif (no_external_cmds) {\n\t\treturn 0;\n\t}\n\tif (! cmd || cmd[0] == '\\0') {\n\t\treturn 0;\n\t}\n\tif (! allowed_external_cmds) {\n\t\t/* default, allow any (overridden by -nocmds) */\n\t\treturn 1;\n\t}\n\n\tstr = strdup(allowed_external_cmds);\n\tp = strtok(str, \",\");\n\twhile (p) {\n\t\tif (!strcmp(p, cmd)) {\n\t\t\tfree(str);\n\t\t\treturn 1;\n\t\t}\n\t\tp = strtok(NULL, \",\");\n\t}\n\tfree(str);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "cmd",
            "\"%s -f       -R '%d:localhost:%d' '%s' 'sleep %d'\"",
            "ssh",
            "rport",
            "lport",
            "s",
            "sleep"
          ],
          "line": 912
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "cmd",
            "\"%s -f -p %d -R '%d:localhost:%d' '%s' 'sleep %d'\"",
            "ssh",
            "sport",
            "rport",
            "lport",
            "s",
            "sleep"
          ],
          "line": 910
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "len"
          ],
          "line": 899
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "s"
          ],
          "line": 898
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "ssh"
          ],
          "line": 898
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getenv",
          "args": [
            "\"SSH\""
          ],
          "line": 892
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getenv",
          "args": [
            "\"SSH\""
          ],
          "line": 891
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atoi",
          "args": [
            "q+1"
          ],
          "line": 887
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strrchr",
          "args": [
            "s",
            "':'"
          ],
          "line": 885
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atoi",
          "args": [
            "q+1"
          ],
          "line": 880
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strrchr",
          "args": [
            "s",
            "':'"
          ],
          "line": 878
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atoi",
          "args": [
            "q+1"
          ],
          "line": 871
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strrchr",
          "args": [
            "s",
            "'+'"
          ],
          "line": 869
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "instr"
          ],
          "line": 862
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xi2_devices.h\"\n#include \"solid.h\"\n#include \"pm.h\"\n#include \"selection.h\"\n#include \"sslhelper.h\"\n#include \"sslcmds.h\"\n#include \"inet.h\"\n#include \"unixpw.h\"\n#include \"rates.h\"\n#include \"connections.h\"\n#include \"screen.h\"\n#include \"userinput.h\"\n#include \"cursor.h\"\n#include \"pointer.h\"\n#include \"keyboard.h\"\n#include \"cleanup.h\"\n#include \"user.h\"\n#include \"help.h\"\n#include \"gui.h\"\n#include \"scan.h\"\n#include \"remote.h\"\n#include \"win_utils.h\"\n#include \"xkb_bell.h\"\n#include \"xrandr.h\"\n#include \"xinerama.h\"\n#include \"xevents.h\"\n#include \"xrecord.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nvoid ssh_remote_tunnel(char *instr, int lport) {\n\tchar *q, *cmd, *ssh;\n\tchar *s = strdup(instr);\n\tint sleep = 300, disp = 0, sport = 0;\n\tint rc, len, rport;\n\n\t/* user@host:port:disp+secs */\n\n\t/* +sleep */\n\tq = strrchr(s, '+');\n\tif (q) {\n\t\tsleep = atoi(q+1);\n\t\tif (sleep <= 0) {\n\t\t\tsleep = 1;\n\t\t}\n\t\t*q = '\\0';\n\t}\n\t/* :disp */\n\tq = strrchr(s, ':');\n\tif (q) {\n\t\tdisp = atoi(q+1);\n\t\t*q = '\\0';\n\t}\n\t\n\t/* :sshport */\n\tq = strrchr(s, ':');\n\tif (q) {\n\t\tsport = atoi(q+1);\n\t\t*q = '\\0';\n\t}\n\n\tif (getenv(\"SSH\")) {\n\t\tssh = getenv(\"SSH\");\n\t} else {\n\t\tssh = \"ssh\";\n\t}\n\n\tlen = 0;\n\tlen += strlen(ssh) + strlen(s) + 500;\n\tcmd = (char *) malloc(len);\n\n\tif (disp >= 0 && disp <= 200) {\n\t\trport = disp + 5900;\n\t} else if (disp < 0) {\n\t\trport = -disp;\n\t} else {\n\t\trport = disp;\n\t}\n\n\tif (sport > 0) {\n\t\tsprintf(cmd, \"%s -f -p %d -R '%d:localhost:%d' '%s' 'sleep %d'\", ssh, sport, rport, lport, s, sleep);\n\t} else {\n\t\tsprintf(cmd, \"%s -f       -R '%d:localhost:%d' '%s' 'sleep %d'\", ssh,        rport, lport, s, sleep);\n\t}\n\n\tif (no_external_cmds || !cmd_ok(\"ssh\")) {\n\t\trfbLogEnable(1);\n\t\trfbLog(\"cannot run external commands in -nocmds mode:\\n\");\n\t\trfbLog(\"   \\\"%s\\\"\\n\", cmd);\n\t\trfbLog(\"   exiting.\\n\");\n\t\tclean_up_exit(1);\n\t}\n\n\tclose_exec_fds();\n\tfprintf(stderr, \"\\n\");\n\trfbLog(\"running: %s\\n\", cmd);\n\trc = system(cmd);\n\n\tif (rc != 0) {\n\t\tfree(cmd);\n\t\tfree(s);\n\t\trfbLog(\"ssh remote listen failed.\\n\");\n\t\tclean_up_exit(1);\n\t}\n\n\tif (1) {\n\t\tFILE *pipe;\n\t\tint mypid = (int) getpid();\n\t\tint bestpid = -1;\n\t\tint best = -1;\n\t\tchar line[1024];\n\t\tchar *psef = \"ps -ef\";\n\t\tchar *psww = \"ps wwwwwwaux\";\n\t\tchar *ps = psef;\n\t\t/* not portable... but it is really good to terminate the ssh when done. */\n\t\t/* ps -ef | egrep 'ssh2.*-R.*5907:localhost:5900.*runge@celias.lbl.gov.*sleep 300' | grep -v grep | awk '{print $2}' */\n\t\tif (strstr(UT.sysname, \"Linux\")) {\n\t\t\tps = psww;\n\t\t} else if (strstr(UT.sysname, \"BSD\")) {\n\t\t\tps = psww;\n\t\t} else if (strstr(UT.sysname, \"Darwin\")) {\n\t\t\tps = psww;\n\t\t}\n\t\tsprintf(cmd, \"env COLUMNS=256 %s | egrep '%s.*-R *%d:localhost:%d.*%s.*sleep *%d' | grep -v grep | awk '{print $2}'\", ps, ssh, rport, lport, s, sleep);\n\t\tpipe = popen(cmd, \"r\");\n\t\tif (pipe) {\n\t\t\twhile (fgets(line, 1024, pipe) != NULL) {\n\t\t\t\tint p = atoi(line);\n\t\t\t\tif (p > 0) {\n\t\t\t\t\tint score;\n\t\t\t\t\tif (p > mypid) \t{\n\t\t\t\t\t\tscore = p - mypid;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tscore = p - mypid + 32768;\n\t\t\t\t\t\tif (score < 0) {\n\t\t\t\t\t\t\tscore = 32768;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (best < 0 || score < best) {\n\t\t\t\t\t\tbest = score;\n\t\t\t\t\t\tbestpid = p;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tpclose(pipe);\n\t\t}\n\n\t\tif (bestpid != -1) {\n\t\t\tssh_pid = (pid_t) bestpid;\n\t\t\trfbLog(\"guessed ssh pid=%d, will terminate it on exit.\\n\", bestpid);\n\t\t}\n\t}\n\n\tfree(cmd);\n\tfree(s);\n}"
  },
  {
    "function_name": "check_redir_services",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/x11vnc.c",
    "lines": "778-858",
    "snippet": "static void check_redir_services(void) {\n#if !NO_X11\n\tAtom a;\n\tchar prop[513];\n\ttime_t tsd_last;\n\tint restart = 0;\n\tpid_t pid = 0;\n\tint db = 0;\n\tdb = 0;\n\n\tif (getenv(\"TS_REDIR_DEBUG\")) {\n\t\tdb = 1;\n\t}\n\tif (db) fprintf(stderr, \"check_redir_services in.\\n\");\n\n\tif (! dpy) {\n\t\treturn;\n\t}\n\n\ta = XInternAtom(dpy, \"TS_REDIR_PID\", False);\n\tif (a != None) {\n\t\tprop[0] = '\\0';\n\t\tget_prop(prop, sizeof prop-1, a, None);\n\t\tif (prop[0] != '\\0') {\n\t\t\tpid = (pid_t) atoi(prop);\n\t\t}\n\t}\n\tif (db) fprintf(stderr, \"TS_REDIR_PID Atom: %d = '%s'\\n\", (int) a, prop);\n\n\tif (getenv(\"FD_TAG\") && strcmp(getenv(\"FD_TAG\"), \"\")) {\n\t\ta = XInternAtom(dpy, \"FD_TAG\", False);\n\t\tif (a != None) {\n\t\t\tWindow rwin = RootWindow(dpy, DefaultScreen(dpy));\n\t\t\tchar *tag = getenv(\"FD_TAG\");\n\t\t\tXChangeProperty(dpy, rwin, a, XA_STRING, 8,\n\t\t\t    PropModeReplace, (unsigned char *)tag, strlen(tag));\n\t\t\tXSync(dpy, False);\n\t\t}\n\t\tif (db) fprintf(stderr, \"FD_TAG Atom: %d = '%s'\\n\", (int) a, prop);\n\t}\n\n\tprop[0] = '\\0';\n\ta = XInternAtom(dpy, \"TS_REDIR\", False);\n\tif (a != None) {\n\t\tget_prop(prop, sizeof prop-1, a, None);\n\t}\n\tif (db) fprintf(stderr, \"TS_REDIR Atom: %d = '%s'\\n\", (int) a, prop);\n\tif (prop[0] == '\\0') {\n\t\trfbLog(\"TS_REDIR is empty, restarting...\\n\");\n\t\trestart = 1;\n\t} else {\n\t\ttsd_last = (time_t) atoi(prop);\n\t\tif (time(NULL) > tsd_last + 30) {\n\t\t\trfbLog(\"TS_REDIR seems dead for: %d sec, restarting...\\n\",\n\t\t\t    time(NULL) - tsd_last);\n\t\t\trestart = 1;\n\t\t} else if (pid > 0 && time(NULL) > tsd_last + 6) {\n\t\t\tif (kill(pid, 0) != 0) {\n\t\t\t\trfbLog(\"TS_REDIR seems dead via kill(%d, 0), restarting...\\n\",\n\t\t\t\t    pid);\n\t\t\t\trestart = 1;\n\t\t\t}\n\t\t}\n\t}\n\tif (restart) {\n\n\t\tif (pid > 1) {\n\t\t\trfbLog(\"killing TS_REDIR_PID: %d\\n\", pid);\n\t\t\tkill(pid, SIGTERM);\n\t\t\tusleep(500*1000);\n\t\t\tkill(pid, SIGKILL);\n\t\t}\n\t\tdo_tsd();\n\t\tif (db) fprintf(stderr, \"check_redir_services restarted.\\n\");\n\t\treturn;\n\t}\n\n\tif (db) fprintf(stderr, \"check_redir_services, no restart, calling set_redir_properties.\\n\");\n\tset_redir_properties();\n#endif\n}",
    "includes": [
      "#include \"xi2_devices.h\"",
      "#include \"solid.h\"",
      "#include \"pm.h\"",
      "#include \"selection.h\"",
      "#include \"sslhelper.h\"",
      "#include \"sslcmds.h\"",
      "#include \"inet.h\"",
      "#include \"unixpw.h\"",
      "#include \"rates.h\"",
      "#include \"connections.h\"",
      "#include \"screen.h\"",
      "#include \"userinput.h\"",
      "#include \"cursor.h\"",
      "#include \"pointer.h\"",
      "#include \"keyboard.h\"",
      "#include \"cleanup.h\"",
      "#include \"user.h\"",
      "#include \"help.h\"",
      "#include \"gui.h\"",
      "#include \"scan.h\"",
      "#include \"remote.h\"",
      "#include \"win_utils.h\"",
      "#include \"xkb_bell.h\"",
      "#include \"xrandr.h\"",
      "#include \"xinerama.h\"",
      "#include \"xevents.h\"",
      "#include \"xrecord.h\"",
      "#include \"xdamage.h\"",
      "#include \"xwrappers.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "void set_redir_properties(void);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "set_redir_properties",
          "args": [],
          "line": 856
        },
        "resolved": true,
        "details": {
          "function_name": "set_redir_properties",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/x11vnc.c",
          "lines": "739-776",
          "snippet": "void set_redir_properties(void) {\n#if !NO_X11\n\tchar *e, *f, *t;\n\tAtom a;\n\tchar num[32];\n\tint i, p;\n\n\tif (! dpy) {\n\t\treturn;\n\t}\n\n\ti = 0;\n\twhile (ts_services[i][0] != NULL) {\n\t\tf = ts_services[i][0]; \n\t\tt = ts_services[i][1]; \n\t\te = getenv(f);\n\t\tif (!e || strstr(e, \"DAEMON-\") != e) {\n\t\t\ti++;\n\t\t\tcontinue;\n\t\t}\n\t\tp = atoi(e + strlen(\"DAEMON-\"));\n\t\tif (p <= 0) {\n\t\t\ti++;\n\t\t\tcontinue;\n\t\t}\n\t\tsprintf(num, \"%d\", p);\n\t\ta = XInternAtom(dpy, t, False);\n\t\tif (a != None) {\n\t\t\tWindow rwin = RootWindow(dpy, DefaultScreen(dpy));\nfprintf(stderr, \"Set: %s %s %s -> %s\\n\", f, t, e, num);\n\t\t\tXChangeProperty(dpy, rwin, a, XA_STRING, 8,\n\t\t\t    PropModeReplace, (unsigned char *) num, strlen(num));\n\t\t\tXSync(dpy, False);\n\t\t}\n\t\ti++;\n\t}\n#endif\n}",
          "includes": [
            "#include \"xi2_devices.h\"",
            "#include \"solid.h\"",
            "#include \"pm.h\"",
            "#include \"selection.h\"",
            "#include \"sslhelper.h\"",
            "#include \"sslcmds.h\"",
            "#include \"inet.h\"",
            "#include \"unixpw.h\"",
            "#include \"rates.h\"",
            "#include \"connections.h\"",
            "#include \"screen.h\"",
            "#include \"userinput.h\"",
            "#include \"cursor.h\"",
            "#include \"pointer.h\"",
            "#include \"keyboard.h\"",
            "#include \"cleanup.h\"",
            "#include \"user.h\"",
            "#include \"help.h\"",
            "#include \"gui.h\"",
            "#include \"scan.h\"",
            "#include \"remote.h\"",
            "#include \"win_utils.h\"",
            "#include \"xkb_bell.h\"",
            "#include \"xrandr.h\"",
            "#include \"xinerama.h\"",
            "#include \"xevents.h\"",
            "#include \"xrecord.h\"",
            "#include \"xdamage.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void set_redir_properties(void);",
            "char *ts_services[][2] = {\n\t{\"FD_CUPS\", \"TS_CUPS_REDIR\"},\n\t{\"FD_SMB\",  \"TS_SMB_REDIR\"},\n\t{\"FD_ESD\",  \"TS_ESD_REDIR\"},\n\t{\"FD_NAS\",  \"TS_NAS_REDIR\"},\n\t{NULL, NULL}\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xi2_devices.h\"\n#include \"solid.h\"\n#include \"pm.h\"\n#include \"selection.h\"\n#include \"sslhelper.h\"\n#include \"sslcmds.h\"\n#include \"inet.h\"\n#include \"unixpw.h\"\n#include \"rates.h\"\n#include \"connections.h\"\n#include \"screen.h\"\n#include \"userinput.h\"\n#include \"cursor.h\"\n#include \"pointer.h\"\n#include \"keyboard.h\"\n#include \"cleanup.h\"\n#include \"user.h\"\n#include \"help.h\"\n#include \"gui.h\"\n#include \"scan.h\"\n#include \"remote.h\"\n#include \"win_utils.h\"\n#include \"xkb_bell.h\"\n#include \"xrandr.h\"\n#include \"xinerama.h\"\n#include \"xevents.h\"\n#include \"xrecord.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nvoid set_redir_properties(void);\nchar *ts_services[][2] = {\n\t{\"FD_CUPS\", \"TS_CUPS_REDIR\"},\n\t{\"FD_SMB\",  \"TS_SMB_REDIR\"},\n\t{\"FD_ESD\",  \"TS_ESD_REDIR\"},\n\t{\"FD_NAS\",  \"TS_NAS_REDIR\"},\n\t{NULL, NULL}\n};\n\nvoid set_redir_properties(void) {\n#if !NO_X11\n\tchar *e, *f, *t;\n\tAtom a;\n\tchar num[32];\n\tint i, p;\n\n\tif (! dpy) {\n\t\treturn;\n\t}\n\n\ti = 0;\n\twhile (ts_services[i][0] != NULL) {\n\t\tf = ts_services[i][0]; \n\t\tt = ts_services[i][1]; \n\t\te = getenv(f);\n\t\tif (!e || strstr(e, \"DAEMON-\") != e) {\n\t\t\ti++;\n\t\t\tcontinue;\n\t\t}\n\t\tp = atoi(e + strlen(\"DAEMON-\"));\n\t\tif (p <= 0) {\n\t\t\ti++;\n\t\t\tcontinue;\n\t\t}\n\t\tsprintf(num, \"%d\", p);\n\t\ta = XInternAtom(dpy, t, False);\n\t\tif (a != None) {\n\t\t\tWindow rwin = RootWindow(dpy, DefaultScreen(dpy));\nfprintf(stderr, \"Set: %s %s %s -> %s\\n\", f, t, e, num);\n\t\t\tXChangeProperty(dpy, rwin, a, XA_STRING, 8,\n\t\t\t    PropModeReplace, (unsigned char *) num, strlen(num));\n\t\t\tXSync(dpy, False);\n\t\t}\n\t\ti++;\n\t}\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"check_redir_services, no restart, calling set_redir_properties.\\n\""
          ],
          "line": 855
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"check_redir_services restarted.\\n\""
          ],
          "line": 851
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "do_tsd",
          "args": [],
          "line": 850
        },
        "resolved": true,
        "details": {
          "function_name": "do_tsd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/x11vnc.c",
          "lines": "643-737",
          "snippet": "void do_tsd(void) {\n#if !NO_X11\n\tAtom a;\n\tchar prop[513];\n\tpid_t pid;\n\tchar *cmd;\n\tint n, sz = 0;\n\tchar *disp = DisplayString(dpy);\n\tchar *logfile = getenv(\"TS_REDIR_LOGFILE\");\n\tint db = 0;\n\n\tif (getenv(\"TS_REDIR_DEBUG\")) {\n\t\tdb = 1;\n\t}\n\tif (db) fprintf(stderr, \"do_tsd() in.\\n\");\n\n\tprop[0] = '\\0';\n\ta = XInternAtom(dpy, \"TS_REDIR_LIST\", False);\n\tif (a != None) {\n\t\tget_prop(prop, 512, a, None);\n\t}\n\tif (db) fprintf(stderr, \"TS_REDIR_LIST Atom: %d = '%s'\\n\", (int) a, prop);\n\n\tif (prop[0] == '\\0') {\n\t\treturn;\n\t}\n\n\tif (! program_name) {\n\t\tprogram_name = \"x11vnc\";\n\t}\n\tsz += strlen(program_name) + 1;\n\tsz += strlen(\"-display\") + 1;\n\tsz += strlen(disp) + 1;\n\tsz += strlen(\"-tsd\") + 1;\n\tsz += 1 + strlen(prop) + 1 + 1;\n\tsz += strlen(\"-env TSD_RESTART=1\") + 1;\n\tsz += strlen(\"</dev/null 1>/dev/null 2>&1\") + 1;\n\tsz += strlen(\" &\") + 1;\n\tif (logfile) {\n\t\tsz += strlen(logfile);\n\t}\n\tif (ipv6_listen) {\n\t\tsz += strlen(\"-6\") + 1;\n\t}\n\n\tcmd = (char *) malloc(sz);\n\n\tif (getenv(\"XAUTHORITY\")) {\n\t\tchar *xauth = getenv(\"XAUTHORITY\");\n\t\tif (!strcmp(xauth, \"\") || access(xauth, R_OK) != 0) {\n\t\t\t*(xauth-2) = '_';\t/* yow */\n\t\t}\n\t}\n\tsprintf(cmd, \"%s -display %s -tsd '%s' -env TSD_RESTART=1 %s </dev/null 1>%s 2>&1 &\",\n\t    program_name, disp, prop, ipv6_listen ? \"-6\" : \"\",\n\t    logfile ? logfile : \"/dev/null\" ); \n\trfbLog(\"running: %s\\n\", cmd);\n\n#if LIBVNCSERVER_HAVE_FORK && HAVE_SETSID\n\t/* fork into the background now */\n\tif ((pid = fork()) > 0)  {\n\t\tpid_t pidw;\n\t\tint status;\n\t\tdouble s = dnow();\n\n\t\twhile (dnow() < s + 1.5) {\n\t\t\tpidw = waitpid(pid, &status, WNOHANG);\n\t\t\tif (pidw == pid) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tusleep(100*1000);\n\t\t}\n\t\treturn;\n\n\t} else if (pid == -1) {\n\t\tsystem(cmd);\n\t} else {\n\t\tsetsid();\n\t\t/* adjust our stdio */\n\t\tn = open(\"/dev/null\", O_RDONLY);\n\t\tdup2(n, 0);\n\t\tdup2(n, 1);\n\t\tdup2(n, 2);\n\t\tif (n > 2) {\n\t\t\tclose(n);\n\t\t}\n\t\tsystem(cmd);\n\t\texit(0);\n\t}\n#else\n\tsystem(cmd);\n#endif\n\n#endif\n}",
          "includes": [
            "#include \"xi2_devices.h\"",
            "#include \"solid.h\"",
            "#include \"pm.h\"",
            "#include \"selection.h\"",
            "#include \"sslhelper.h\"",
            "#include \"sslcmds.h\"",
            "#include \"inet.h\"",
            "#include \"unixpw.h\"",
            "#include \"rates.h\"",
            "#include \"connections.h\"",
            "#include \"screen.h\"",
            "#include \"userinput.h\"",
            "#include \"cursor.h\"",
            "#include \"pointer.h\"",
            "#include \"keyboard.h\"",
            "#include \"cleanup.h\"",
            "#include \"user.h\"",
            "#include \"help.h\"",
            "#include \"gui.h\"",
            "#include \"scan.h\"",
            "#include \"remote.h\"",
            "#include \"win_utils.h\"",
            "#include \"xkb_bell.h\"",
            "#include \"xrandr.h\"",
            "#include \"xinerama.h\"",
            "#include \"xevents.h\"",
            "#include \"xrecord.h\"",
            "#include \"xdamage.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xi2_devices.h\"\n#include \"solid.h\"\n#include \"pm.h\"\n#include \"selection.h\"\n#include \"sslhelper.h\"\n#include \"sslcmds.h\"\n#include \"inet.h\"\n#include \"unixpw.h\"\n#include \"rates.h\"\n#include \"connections.h\"\n#include \"screen.h\"\n#include \"userinput.h\"\n#include \"cursor.h\"\n#include \"pointer.h\"\n#include \"keyboard.h\"\n#include \"cleanup.h\"\n#include \"user.h\"\n#include \"help.h\"\n#include \"gui.h\"\n#include \"scan.h\"\n#include \"remote.h\"\n#include \"win_utils.h\"\n#include \"xkb_bell.h\"\n#include \"xrandr.h\"\n#include \"xinerama.h\"\n#include \"xevents.h\"\n#include \"xrecord.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nvoid do_tsd(void) {\n#if !NO_X11\n\tAtom a;\n\tchar prop[513];\n\tpid_t pid;\n\tchar *cmd;\n\tint n, sz = 0;\n\tchar *disp = DisplayString(dpy);\n\tchar *logfile = getenv(\"TS_REDIR_LOGFILE\");\n\tint db = 0;\n\n\tif (getenv(\"TS_REDIR_DEBUG\")) {\n\t\tdb = 1;\n\t}\n\tif (db) fprintf(stderr, \"do_tsd() in.\\n\");\n\n\tprop[0] = '\\0';\n\ta = XInternAtom(dpy, \"TS_REDIR_LIST\", False);\n\tif (a != None) {\n\t\tget_prop(prop, 512, a, None);\n\t}\n\tif (db) fprintf(stderr, \"TS_REDIR_LIST Atom: %d = '%s'\\n\", (int) a, prop);\n\n\tif (prop[0] == '\\0') {\n\t\treturn;\n\t}\n\n\tif (! program_name) {\n\t\tprogram_name = \"x11vnc\";\n\t}\n\tsz += strlen(program_name) + 1;\n\tsz += strlen(\"-display\") + 1;\n\tsz += strlen(disp) + 1;\n\tsz += strlen(\"-tsd\") + 1;\n\tsz += 1 + strlen(prop) + 1 + 1;\n\tsz += strlen(\"-env TSD_RESTART=1\") + 1;\n\tsz += strlen(\"</dev/null 1>/dev/null 2>&1\") + 1;\n\tsz += strlen(\" &\") + 1;\n\tif (logfile) {\n\t\tsz += strlen(logfile);\n\t}\n\tif (ipv6_listen) {\n\t\tsz += strlen(\"-6\") + 1;\n\t}\n\n\tcmd = (char *) malloc(sz);\n\n\tif (getenv(\"XAUTHORITY\")) {\n\t\tchar *xauth = getenv(\"XAUTHORITY\");\n\t\tif (!strcmp(xauth, \"\") || access(xauth, R_OK) != 0) {\n\t\t\t*(xauth-2) = '_';\t/* yow */\n\t\t}\n\t}\n\tsprintf(cmd, \"%s -display %s -tsd '%s' -env TSD_RESTART=1 %s </dev/null 1>%s 2>&1 &\",\n\t    program_name, disp, prop, ipv6_listen ? \"-6\" : \"\",\n\t    logfile ? logfile : \"/dev/null\" ); \n\trfbLog(\"running: %s\\n\", cmd);\n\n#if LIBVNCSERVER_HAVE_FORK && HAVE_SETSID\n\t/* fork into the background now */\n\tif ((pid = fork()) > 0)  {\n\t\tpid_t pidw;\n\t\tint status;\n\t\tdouble s = dnow();\n\n\t\twhile (dnow() < s + 1.5) {\n\t\t\tpidw = waitpid(pid, &status, WNOHANG);\n\t\t\tif (pidw == pid) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tusleep(100*1000);\n\t\t}\n\t\treturn;\n\n\t} else if (pid == -1) {\n\t\tsystem(cmd);\n\t} else {\n\t\tsetsid();\n\t\t/* adjust our stdio */\n\t\tn = open(\"/dev/null\", O_RDONLY);\n\t\tdup2(n, 0);\n\t\tdup2(n, 1);\n\t\tdup2(n, 2);\n\t\tif (n > 2) {\n\t\t\tclose(n);\n\t\t}\n\t\tsystem(cmd);\n\t\texit(0);\n\t}\n#else\n\tsystem(cmd);\n#endif\n\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "kill",
          "args": [
            "pid",
            "SIGKILL"
          ],
          "line": 848
        },
        "resolved": true,
        "details": {
          "function_name": "kill_child",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/unixpw.c",
          "lines": "674-684",
          "snippet": "static void kill_child (pid_t pid, int fd) {\n\tint status;\n\n\tslave_fd = -1;\n\talarm_fired = 0;\n\tif (fd >= 0) {\n\t\tclose(fd);\n\t}\n\tkill(pid, SIGTERM);\n\twaitpid(pid, &status, WNOHANG); \n}",
          "includes": [
            "#include <sys/stropts.h>",
            "#include <termios.h>",
            "#include <sys/ioctl.h>",
            "#include <shadow.h>",
            "#include \"default8x16.h\"",
            "#include \"rates.h\"",
            "#include \"cursor.h\"",
            "#include \"sslhelper.h\"",
            "#include \"connections.h\"",
            "#include \"user.h\"",
            "#include \"connections.h\"",
            "#include \"xinerama.h\"",
            "#include \"cleanup.h\"",
            "#include \"scan.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int slave_fd = -1, alarm_fired = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/stropts.h>\n#include <termios.h>\n#include <sys/ioctl.h>\n#include <shadow.h>\n#include \"default8x16.h\"\n#include \"rates.h\"\n#include \"cursor.h\"\n#include \"sslhelper.h\"\n#include \"connections.h\"\n#include \"user.h\"\n#include \"connections.h\"\n#include \"xinerama.h\"\n#include \"cleanup.h\"\n#include \"scan.h\"\n#include \"x11vnc.h\"\n\nstatic int slave_fd = -1, alarm_fired = 0;\n\nstatic void kill_child (pid_t pid, int fd) {\n\tint status;\n\n\tslave_fd = -1;\n\talarm_fired = 0;\n\tif (fd >= 0) {\n\t\tclose(fd);\n\t}\n\tkill(pid, SIGTERM);\n\twaitpid(pid, &status, WNOHANG); \n}"
        }
      },
      {
        "call_info": {
          "callee": "usleep",
          "args": [
            "500*1000"
          ],
          "line": 847
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"killing TS_REDIR_PID: %d\\n\"",
            "pid"
          ],
          "line": 845
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"TS_REDIR seems dead via kill(%d, 0), restarting...\\n\"",
            "pid"
          ],
          "line": 836
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "time",
          "args": [
            "NULL"
          ],
          "line": 834
        },
        "resolved": true,
        "details": {
          "function_name": "tsdo_timeout",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/x11vnc.c",
          "lines": "180-183",
          "snippet": "static void tsdo_timeout (int sig) {\n\ttsdo_timeout_flag = 1;\n\tif (sig) {};\n}",
          "includes": [
            "#include \"xi2_devices.h\"",
            "#include \"solid.h\"",
            "#include \"pm.h\"",
            "#include \"selection.h\"",
            "#include \"sslhelper.h\"",
            "#include \"sslcmds.h\"",
            "#include \"inet.h\"",
            "#include \"unixpw.h\"",
            "#include \"rates.h\"",
            "#include \"connections.h\"",
            "#include \"screen.h\"",
            "#include \"userinput.h\"",
            "#include \"cursor.h\"",
            "#include \"pointer.h\"",
            "#include \"keyboard.h\"",
            "#include \"cleanup.h\"",
            "#include \"user.h\"",
            "#include \"help.h\"",
            "#include \"gui.h\"",
            "#include \"scan.h\"",
            "#include \"remote.h\"",
            "#include \"win_utils.h\"",
            "#include \"xkb_bell.h\"",
            "#include \"xrandr.h\"",
            "#include \"xinerama.h\"",
            "#include \"xevents.h\"",
            "#include \"xrecord.h\"",
            "#include \"xdamage.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int tsdo_timeout_flag;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xi2_devices.h\"\n#include \"solid.h\"\n#include \"pm.h\"\n#include \"selection.h\"\n#include \"sslhelper.h\"\n#include \"sslcmds.h\"\n#include \"inet.h\"\n#include \"unixpw.h\"\n#include \"rates.h\"\n#include \"connections.h\"\n#include \"screen.h\"\n#include \"userinput.h\"\n#include \"cursor.h\"\n#include \"pointer.h\"\n#include \"keyboard.h\"\n#include \"cleanup.h\"\n#include \"user.h\"\n#include \"help.h\"\n#include \"gui.h\"\n#include \"scan.h\"\n#include \"remote.h\"\n#include \"win_utils.h\"\n#include \"xkb_bell.h\"\n#include \"xrandr.h\"\n#include \"xinerama.h\"\n#include \"xevents.h\"\n#include \"xrecord.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nstatic int tsdo_timeout_flag;\n\nstatic void tsdo_timeout (int sig) {\n\ttsdo_timeout_flag = 1;\n\tif (sig) {};\n}"
        }
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"TS_REDIR seems dead for: %d sec, restarting...\\n\"",
            "time(NULL) - tsd_last"
          ],
          "line": 831
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atoi",
          "args": [
            "prop"
          ],
          "line": 829
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"TS_REDIR is empty, restarting...\\n\""
          ],
          "line": 826
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"TS_REDIR Atom: %d = '%s'\\n\"",
            "(int) a",
            "prop"
          ],
          "line": 824
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_prop",
          "args": [
            "prop",
            "sizeof prop-1",
            "a",
            "None"
          ],
          "line": 822
        },
        "resolved": true,
        "details": {
          "function_name": "get_prop",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/xevents.c",
          "lines": "448-494",
          "snippet": "void get_prop(char *str, int len, Atom prop, Window w) {\n\tint i;\n#if !NO_X11\n\tAtom type;\n\tint format, slen, dlen;\n\tunsigned long nitems = 0, bytes_after = 0;\n\tunsigned char* data = NULL;\n#endif\n\n\tfor (i=0; i<len; i++) {\n\t\tstr[i] = '\\0';\n\t}\n\tif (prop == None) {\n\t\treturn;\n\t}\n\n\tRAWFB_RET_VOID\n\n#if NO_X11\n\treturn;\n#else\n\n\tslen = 0;\n\tif (w == None) {\n\t\tw = DefaultRootWindow(dpy);\n\t}\n\n\tdo {\n\t\tif (XGetWindowProperty(dpy, w,\n\t\t    prop, nitems/4, len/16, False,\n\t\t    AnyPropertyType, &type, &format, &nitems, &bytes_after,\n\t\t    &data) == Success) {\n\n\t\t\tdlen = nitems * (format/8);\n\t\t\tif (slen + dlen > len) {\n\t\t\t\t/* too big */\n\t\t\t\tXFree_wr(data);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tmemcpy(str+slen, data, dlen);\n\t\t\tslen += dlen;\n\t\t\tstr[slen] = '\\0';\n\t\t\tXFree_wr(data);\n\t\t}\n\t} while (bytes_after > 0);\n#endif\t/* NO_X11 */\n}",
          "includes": [
            "#include <X11/extensions/scrnsaver.h>",
            "#include \"inet.h\"",
            "#include \"remote.h\"",
            "#include \"pointer.h\"",
            "#include \"pm.h\"",
            "#include \"screen.h\"",
            "#include \"macosx.h\"",
            "#include \"cleanup.h\"",
            "#include \"unixpw.h\"",
            "#include \"connections.h\"",
            "#include \"gui.h\"",
            "#include \"cursor.h\"",
            "#include \"keyboard.h\"",
            "#include \"selection.h\"",
            "#include \"xrecord.h\"",
            "#include \"xdamage.h\"",
            "#include \"xrandr.h\"",
            "#include \"xkb_bell.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void get_prop(char *str, int len, Atom prop, Window w);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <X11/extensions/scrnsaver.h>\n#include \"inet.h\"\n#include \"remote.h\"\n#include \"pointer.h\"\n#include \"pm.h\"\n#include \"screen.h\"\n#include \"macosx.h\"\n#include \"cleanup.h\"\n#include \"unixpw.h\"\n#include \"connections.h\"\n#include \"gui.h\"\n#include \"cursor.h\"\n#include \"keyboard.h\"\n#include \"selection.h\"\n#include \"xrecord.h\"\n#include \"xdamage.h\"\n#include \"xrandr.h\"\n#include \"xkb_bell.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nvoid get_prop(char *str, int len, Atom prop, Window w);\n\nvoid get_prop(char *str, int len, Atom prop, Window w) {\n\tint i;\n#if !NO_X11\n\tAtom type;\n\tint format, slen, dlen;\n\tunsigned long nitems = 0, bytes_after = 0;\n\tunsigned char* data = NULL;\n#endif\n\n\tfor (i=0; i<len; i++) {\n\t\tstr[i] = '\\0';\n\t}\n\tif (prop == None) {\n\t\treturn;\n\t}\n\n\tRAWFB_RET_VOID\n\n#if NO_X11\n\treturn;\n#else\n\n\tslen = 0;\n\tif (w == None) {\n\t\tw = DefaultRootWindow(dpy);\n\t}\n\n\tdo {\n\t\tif (XGetWindowProperty(dpy, w,\n\t\t    prop, nitems/4, len/16, False,\n\t\t    AnyPropertyType, &type, &format, &nitems, &bytes_after,\n\t\t    &data) == Success) {\n\n\t\t\tdlen = nitems * (format/8);\n\t\t\tif (slen + dlen > len) {\n\t\t\t\t/* too big */\n\t\t\t\tXFree_wr(data);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tmemcpy(str+slen, data, dlen);\n\t\t\tslen += dlen;\n\t\t\tstr[slen] = '\\0';\n\t\t\tXFree_wr(data);\n\t\t}\n\t} while (bytes_after > 0);\n#endif\t/* NO_X11 */\n}"
        }
      },
      {
        "call_info": {
          "callee": "XInternAtom",
          "args": [
            "dpy",
            "\"TS_REDIR\"",
            "False"
          ],
          "line": 820
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"FD_TAG Atom: %d = '%s'\\n\"",
            "(int) a",
            "prop"
          ],
          "line": 816
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XSync",
          "args": [
            "dpy",
            "False"
          ],
          "line": 814
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XChangeProperty",
          "args": [
            "dpy",
            "rwin",
            "a",
            "XA_STRING",
            "8",
            "PropModeReplace",
            "(unsigned char *)tag",
            "strlen(tag)"
          ],
          "line": 812
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "tag"
          ],
          "line": 813
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getenv",
          "args": [
            "\"FD_TAG\""
          ],
          "line": 811
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RootWindow",
          "args": [
            "dpy",
            "DefaultScreen(dpy)"
          ],
          "line": 810
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DefaultScreen",
          "args": [
            "dpy"
          ],
          "line": 810
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XInternAtom",
          "args": [
            "dpy",
            "\"FD_TAG\"",
            "False"
          ],
          "line": 808
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "getenv(\"FD_TAG\")",
            "\"\""
          ],
          "line": 807
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getenv",
          "args": [
            "\"FD_TAG\""
          ],
          "line": 807
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getenv",
          "args": [
            "\"FD_TAG\""
          ],
          "line": 807
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"TS_REDIR_PID Atom: %d = '%s'\\n\"",
            "(int) a",
            "prop"
          ],
          "line": 805
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atoi",
          "args": [
            "prop"
          ],
          "line": 802
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XInternAtom",
          "args": [
            "dpy",
            "\"TS_REDIR_PID\"",
            "False"
          ],
          "line": 797
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"check_redir_services in.\\n\""
          ],
          "line": 791
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getenv",
          "args": [
            "\"TS_REDIR_DEBUG\""
          ],
          "line": 788
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xi2_devices.h\"\n#include \"solid.h\"\n#include \"pm.h\"\n#include \"selection.h\"\n#include \"sslhelper.h\"\n#include \"sslcmds.h\"\n#include \"inet.h\"\n#include \"unixpw.h\"\n#include \"rates.h\"\n#include \"connections.h\"\n#include \"screen.h\"\n#include \"userinput.h\"\n#include \"cursor.h\"\n#include \"pointer.h\"\n#include \"keyboard.h\"\n#include \"cleanup.h\"\n#include \"user.h\"\n#include \"help.h\"\n#include \"gui.h\"\n#include \"scan.h\"\n#include \"remote.h\"\n#include \"win_utils.h\"\n#include \"xkb_bell.h\"\n#include \"xrandr.h\"\n#include \"xinerama.h\"\n#include \"xevents.h\"\n#include \"xrecord.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nvoid set_redir_properties(void);\n\nstatic void check_redir_services(void) {\n#if !NO_X11\n\tAtom a;\n\tchar prop[513];\n\ttime_t tsd_last;\n\tint restart = 0;\n\tpid_t pid = 0;\n\tint db = 0;\n\tdb = 0;\n\n\tif (getenv(\"TS_REDIR_DEBUG\")) {\n\t\tdb = 1;\n\t}\n\tif (db) fprintf(stderr, \"check_redir_services in.\\n\");\n\n\tif (! dpy) {\n\t\treturn;\n\t}\n\n\ta = XInternAtom(dpy, \"TS_REDIR_PID\", False);\n\tif (a != None) {\n\t\tprop[0] = '\\0';\n\t\tget_prop(prop, sizeof prop-1, a, None);\n\t\tif (prop[0] != '\\0') {\n\t\t\tpid = (pid_t) atoi(prop);\n\t\t}\n\t}\n\tif (db) fprintf(stderr, \"TS_REDIR_PID Atom: %d = '%s'\\n\", (int) a, prop);\n\n\tif (getenv(\"FD_TAG\") && strcmp(getenv(\"FD_TAG\"), \"\")) {\n\t\ta = XInternAtom(dpy, \"FD_TAG\", False);\n\t\tif (a != None) {\n\t\t\tWindow rwin = RootWindow(dpy, DefaultScreen(dpy));\n\t\t\tchar *tag = getenv(\"FD_TAG\");\n\t\t\tXChangeProperty(dpy, rwin, a, XA_STRING, 8,\n\t\t\t    PropModeReplace, (unsigned char *)tag, strlen(tag));\n\t\t\tXSync(dpy, False);\n\t\t}\n\t\tif (db) fprintf(stderr, \"FD_TAG Atom: %d = '%s'\\n\", (int) a, prop);\n\t}\n\n\tprop[0] = '\\0';\n\ta = XInternAtom(dpy, \"TS_REDIR\", False);\n\tif (a != None) {\n\t\tget_prop(prop, sizeof prop-1, a, None);\n\t}\n\tif (db) fprintf(stderr, \"TS_REDIR Atom: %d = '%s'\\n\", (int) a, prop);\n\tif (prop[0] == '\\0') {\n\t\trfbLog(\"TS_REDIR is empty, restarting...\\n\");\n\t\trestart = 1;\n\t} else {\n\t\ttsd_last = (time_t) atoi(prop);\n\t\tif (time(NULL) > tsd_last + 30) {\n\t\t\trfbLog(\"TS_REDIR seems dead for: %d sec, restarting...\\n\",\n\t\t\t    time(NULL) - tsd_last);\n\t\t\trestart = 1;\n\t\t} else if (pid > 0 && time(NULL) > tsd_last + 6) {\n\t\t\tif (kill(pid, 0) != 0) {\n\t\t\t\trfbLog(\"TS_REDIR seems dead via kill(%d, 0), restarting...\\n\",\n\t\t\t\t    pid);\n\t\t\t\trestart = 1;\n\t\t\t}\n\t\t}\n\t}\n\tif (restart) {\n\n\t\tif (pid > 1) {\n\t\t\trfbLog(\"killing TS_REDIR_PID: %d\\n\", pid);\n\t\t\tkill(pid, SIGTERM);\n\t\t\tusleep(500*1000);\n\t\t\tkill(pid, SIGKILL);\n\t\t}\n\t\tdo_tsd();\n\t\tif (db) fprintf(stderr, \"check_redir_services restarted.\\n\");\n\t\treturn;\n\t}\n\n\tif (db) fprintf(stderr, \"check_redir_services, no restart, calling set_redir_properties.\\n\");\n\tset_redir_properties();\n#endif\n}"
  },
  {
    "function_name": "set_redir_properties",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/x11vnc.c",
    "lines": "739-776",
    "snippet": "void set_redir_properties(void) {\n#if !NO_X11\n\tchar *e, *f, *t;\n\tAtom a;\n\tchar num[32];\n\tint i, p;\n\n\tif (! dpy) {\n\t\treturn;\n\t}\n\n\ti = 0;\n\twhile (ts_services[i][0] != NULL) {\n\t\tf = ts_services[i][0]; \n\t\tt = ts_services[i][1]; \n\t\te = getenv(f);\n\t\tif (!e || strstr(e, \"DAEMON-\") != e) {\n\t\t\ti++;\n\t\t\tcontinue;\n\t\t}\n\t\tp = atoi(e + strlen(\"DAEMON-\"));\n\t\tif (p <= 0) {\n\t\t\ti++;\n\t\t\tcontinue;\n\t\t}\n\t\tsprintf(num, \"%d\", p);\n\t\ta = XInternAtom(dpy, t, False);\n\t\tif (a != None) {\n\t\t\tWindow rwin = RootWindow(dpy, DefaultScreen(dpy));\nfprintf(stderr, \"Set: %s %s %s -> %s\\n\", f, t, e, num);\n\t\t\tXChangeProperty(dpy, rwin, a, XA_STRING, 8,\n\t\t\t    PropModeReplace, (unsigned char *) num, strlen(num));\n\t\t\tXSync(dpy, False);\n\t\t}\n\t\ti++;\n\t}\n#endif\n}",
    "includes": [
      "#include \"xi2_devices.h\"",
      "#include \"solid.h\"",
      "#include \"pm.h\"",
      "#include \"selection.h\"",
      "#include \"sslhelper.h\"",
      "#include \"sslcmds.h\"",
      "#include \"inet.h\"",
      "#include \"unixpw.h\"",
      "#include \"rates.h\"",
      "#include \"connections.h\"",
      "#include \"screen.h\"",
      "#include \"userinput.h\"",
      "#include \"cursor.h\"",
      "#include \"pointer.h\"",
      "#include \"keyboard.h\"",
      "#include \"cleanup.h\"",
      "#include \"user.h\"",
      "#include \"help.h\"",
      "#include \"gui.h\"",
      "#include \"scan.h\"",
      "#include \"remote.h\"",
      "#include \"win_utils.h\"",
      "#include \"xkb_bell.h\"",
      "#include \"xrandr.h\"",
      "#include \"xinerama.h\"",
      "#include \"xevents.h\"",
      "#include \"xrecord.h\"",
      "#include \"xdamage.h\"",
      "#include \"xwrappers.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "void set_redir_properties(void);",
      "char *ts_services[][2] = {\n\t{\"FD_CUPS\", \"TS_CUPS_REDIR\"},\n\t{\"FD_SMB\",  \"TS_SMB_REDIR\"},\n\t{\"FD_ESD\",  \"TS_ESD_REDIR\"},\n\t{\"FD_NAS\",  \"TS_NAS_REDIR\"},\n\t{NULL, NULL}\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "XSync",
          "args": [
            "dpy",
            "False"
          ],
          "line": 771
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XChangeProperty",
          "args": [
            "dpy",
            "rwin",
            "a",
            "XA_STRING",
            "8",
            "PropModeReplace",
            "(unsigned char *) num",
            "strlen(num)"
          ],
          "line": 769
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "num"
          ],
          "line": 770
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Set: %s %s %s -> %s\\n\"",
            "f",
            "t",
            "e",
            "num"
          ],
          "line": 768
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RootWindow",
          "args": [
            "dpy",
            "DefaultScreen(dpy)"
          ],
          "line": 767
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DefaultScreen",
          "args": [
            "dpy"
          ],
          "line": 767
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XInternAtom",
          "args": [
            "dpy",
            "t",
            "False"
          ],
          "line": 765
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "num",
            "\"%d\"",
            "p"
          ],
          "line": 764
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atoi",
          "args": [
            "e + strlen(\"DAEMON-\")"
          ],
          "line": 759
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "\"DAEMON-\""
          ],
          "line": 759
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "e",
            "\"DAEMON-\""
          ],
          "line": 755
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getenv",
          "args": [
            "f"
          ],
          "line": 754
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xi2_devices.h\"\n#include \"solid.h\"\n#include \"pm.h\"\n#include \"selection.h\"\n#include \"sslhelper.h\"\n#include \"sslcmds.h\"\n#include \"inet.h\"\n#include \"unixpw.h\"\n#include \"rates.h\"\n#include \"connections.h\"\n#include \"screen.h\"\n#include \"userinput.h\"\n#include \"cursor.h\"\n#include \"pointer.h\"\n#include \"keyboard.h\"\n#include \"cleanup.h\"\n#include \"user.h\"\n#include \"help.h\"\n#include \"gui.h\"\n#include \"scan.h\"\n#include \"remote.h\"\n#include \"win_utils.h\"\n#include \"xkb_bell.h\"\n#include \"xrandr.h\"\n#include \"xinerama.h\"\n#include \"xevents.h\"\n#include \"xrecord.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nvoid set_redir_properties(void);\nchar *ts_services[][2] = {\n\t{\"FD_CUPS\", \"TS_CUPS_REDIR\"},\n\t{\"FD_SMB\",  \"TS_SMB_REDIR\"},\n\t{\"FD_ESD\",  \"TS_ESD_REDIR\"},\n\t{\"FD_NAS\",  \"TS_NAS_REDIR\"},\n\t{NULL, NULL}\n};\n\nvoid set_redir_properties(void) {\n#if !NO_X11\n\tchar *e, *f, *t;\n\tAtom a;\n\tchar num[32];\n\tint i, p;\n\n\tif (! dpy) {\n\t\treturn;\n\t}\n\n\ti = 0;\n\twhile (ts_services[i][0] != NULL) {\n\t\tf = ts_services[i][0]; \n\t\tt = ts_services[i][1]; \n\t\te = getenv(f);\n\t\tif (!e || strstr(e, \"DAEMON-\") != e) {\n\t\t\ti++;\n\t\t\tcontinue;\n\t\t}\n\t\tp = atoi(e + strlen(\"DAEMON-\"));\n\t\tif (p <= 0) {\n\t\t\ti++;\n\t\t\tcontinue;\n\t\t}\n\t\tsprintf(num, \"%d\", p);\n\t\ta = XInternAtom(dpy, t, False);\n\t\tif (a != None) {\n\t\t\tWindow rwin = RootWindow(dpy, DefaultScreen(dpy));\nfprintf(stderr, \"Set: %s %s %s -> %s\\n\", f, t, e, num);\n\t\t\tXChangeProperty(dpy, rwin, a, XA_STRING, 8,\n\t\t\t    PropModeReplace, (unsigned char *) num, strlen(num));\n\t\t\tXSync(dpy, False);\n\t\t}\n\t\ti++;\n\t}\n#endif\n}"
  },
  {
    "function_name": "do_tsd",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/x11vnc.c",
    "lines": "643-737",
    "snippet": "void do_tsd(void) {\n#if !NO_X11\n\tAtom a;\n\tchar prop[513];\n\tpid_t pid;\n\tchar *cmd;\n\tint n, sz = 0;\n\tchar *disp = DisplayString(dpy);\n\tchar *logfile = getenv(\"TS_REDIR_LOGFILE\");\n\tint db = 0;\n\n\tif (getenv(\"TS_REDIR_DEBUG\")) {\n\t\tdb = 1;\n\t}\n\tif (db) fprintf(stderr, \"do_tsd() in.\\n\");\n\n\tprop[0] = '\\0';\n\ta = XInternAtom(dpy, \"TS_REDIR_LIST\", False);\n\tif (a != None) {\n\t\tget_prop(prop, 512, a, None);\n\t}\n\tif (db) fprintf(stderr, \"TS_REDIR_LIST Atom: %d = '%s'\\n\", (int) a, prop);\n\n\tif (prop[0] == '\\0') {\n\t\treturn;\n\t}\n\n\tif (! program_name) {\n\t\tprogram_name = \"x11vnc\";\n\t}\n\tsz += strlen(program_name) + 1;\n\tsz += strlen(\"-display\") + 1;\n\tsz += strlen(disp) + 1;\n\tsz += strlen(\"-tsd\") + 1;\n\tsz += 1 + strlen(prop) + 1 + 1;\n\tsz += strlen(\"-env TSD_RESTART=1\") + 1;\n\tsz += strlen(\"</dev/null 1>/dev/null 2>&1\") + 1;\n\tsz += strlen(\" &\") + 1;\n\tif (logfile) {\n\t\tsz += strlen(logfile);\n\t}\n\tif (ipv6_listen) {\n\t\tsz += strlen(\"-6\") + 1;\n\t}\n\n\tcmd = (char *) malloc(sz);\n\n\tif (getenv(\"XAUTHORITY\")) {\n\t\tchar *xauth = getenv(\"XAUTHORITY\");\n\t\tif (!strcmp(xauth, \"\") || access(xauth, R_OK) != 0) {\n\t\t\t*(xauth-2) = '_';\t/* yow */\n\t\t}\n\t}\n\tsprintf(cmd, \"%s -display %s -tsd '%s' -env TSD_RESTART=1 %s </dev/null 1>%s 2>&1 &\",\n\t    program_name, disp, prop, ipv6_listen ? \"-6\" : \"\",\n\t    logfile ? logfile : \"/dev/null\" ); \n\trfbLog(\"running: %s\\n\", cmd);\n\n#if LIBVNCSERVER_HAVE_FORK && HAVE_SETSID\n\t/* fork into the background now */\n\tif ((pid = fork()) > 0)  {\n\t\tpid_t pidw;\n\t\tint status;\n\t\tdouble s = dnow();\n\n\t\twhile (dnow() < s + 1.5) {\n\t\t\tpidw = waitpid(pid, &status, WNOHANG);\n\t\t\tif (pidw == pid) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tusleep(100*1000);\n\t\t}\n\t\treturn;\n\n\t} else if (pid == -1) {\n\t\tsystem(cmd);\n\t} else {\n\t\tsetsid();\n\t\t/* adjust our stdio */\n\t\tn = open(\"/dev/null\", O_RDONLY);\n\t\tdup2(n, 0);\n\t\tdup2(n, 1);\n\t\tdup2(n, 2);\n\t\tif (n > 2) {\n\t\t\tclose(n);\n\t\t}\n\t\tsystem(cmd);\n\t\texit(0);\n\t}\n#else\n\tsystem(cmd);\n#endif\n\n#endif\n}",
    "includes": [
      "#include \"xi2_devices.h\"",
      "#include \"solid.h\"",
      "#include \"pm.h\"",
      "#include \"selection.h\"",
      "#include \"sslhelper.h\"",
      "#include \"sslcmds.h\"",
      "#include \"inet.h\"",
      "#include \"unixpw.h\"",
      "#include \"rates.h\"",
      "#include \"connections.h\"",
      "#include \"screen.h\"",
      "#include \"userinput.h\"",
      "#include \"cursor.h\"",
      "#include \"pointer.h\"",
      "#include \"keyboard.h\"",
      "#include \"cleanup.h\"",
      "#include \"user.h\"",
      "#include \"help.h\"",
      "#include \"gui.h\"",
      "#include \"scan.h\"",
      "#include \"remote.h\"",
      "#include \"win_utils.h\"",
      "#include \"xkb_bell.h\"",
      "#include \"xrandr.h\"",
      "#include \"xinerama.h\"",
      "#include \"xevents.h\"",
      "#include \"xrecord.h\"",
      "#include \"xdamage.h\"",
      "#include \"xwrappers.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "system",
          "args": [
            "cmd"
          ],
          "line": 733
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "0"
          ],
          "line": 730
        },
        "resolved": true,
        "details": {
          "function_name": "clean_up_exit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/cleanup.c",
          "lines": "151-266",
          "snippet": "void clean_up_exit(int ret) {\n\tstatic int depth = 0;\n\texit_flag = 1;\n\n\tif (depth++ > 2) {\n\t\texit(ret);\n\t}\n\n\tif (icon_mode) {\n\t\tclean_icon_mode();\n\t}\n\n\t/* remove the shm areas: */\n\tclean_shm(0);\n\n\tstop_stunnel();\n\tif (use_openssl) {\n\t\tssl_helper_pid(0, 0);\t/* killall */\n\t}\n\n\tif (ssh_pid > 0) {\n\t\tkill(ssh_pid, SIGTERM);\n\t\tssh_pid = 0;\n\t}\n\n#ifdef MACOSX\n\tif (client_connect_file) {\n\t\tif (strstr(client_connect_file, \"/tmp/x11vnc-macosx-remote\")\n\t\t    == client_connect_file) {\n\t\t\tunlink(client_connect_file);\n\t\t}\n\t}\n\tif (macosx_console) {\n\t\tmacosxCG_fini();\n\t}\n#endif\n\n\tif (pipeinput_fh != NULL) {\n\t\tpclose(pipeinput_fh);\n\t\tpipeinput_fh = NULL;\n\t}\n\n\tshutdown_uinput();\n\n\tif (unix_sock) {\n\t\tif (unix_sock_fd >= 0) {\n\t\t\trfbLog(\"deleting unix sock: %s\\n\", unix_sock);\n\t\t\tclose(unix_sock_fd);\n\t\t\tunix_sock_fd = -1;\n\t\t\tunlink(unix_sock);\n\t\t}\n\t}\n\n\tif (! dpy) {\t/* raw_rb hack */\n\t\tif (rm_flagfile) {\n\t\t\tunlink(rm_flagfile);\n\t\t\trm_flagfile = NULL;\n\t\t}\n\t\texit(ret);\n\t}\n\n\t/* X keyboard cleanups */\n\tdelete_added_keycodes(0);\n\n\t/* remove all created XInput2 devices */\n\tif(use_multipointer)\n\t    removeAllMDs(dpy);\n\n\tif (clear_mods == 1) {\n\t\tclear_modifiers(0);\n\t} else if (clear_mods == 2) {\n\t\tclear_keys();\n\t} else if (clear_mods == 3) {\n\t\tclear_keys();\n\t\tclear_locks();\n\t}\n\n\tif (no_autorepeat) {\n\t\tautorepeat(1, 0);\n\t}\n\tif (use_solid_bg) {\n\t\tsolid_bg(1);\n\t}\n\tif (ncache || ncache0) {\n\t\tkde_no_animate(1);\n\t}\n\tX_LOCK;\n\tXTestDiscard_wr(dpy);\n#if HAVE_LIBXDAMAGE\n\tif (xdamage) {\n\t\tXDamageDestroy(dpy, xdamage);\n\t}\n#endif\n#if HAVE_LIBXTRAP\n\tif (trap_ctx) {\n\t\tXEFreeTC(trap_ctx);\n\t}\n#endif\n\t/* XXX rdpy_ctrl, etc. cannot close w/o blocking */\n\tXCloseDisplay_wr(dpy);\n\tX_UNLOCK;\n\n\tfflush(stderr);\n\n\tif (rm_flagfile) {\n\t\tunlink(rm_flagfile);\n\t\trm_flagfile = NULL;\n\t}\n\n\tif (avahi) {\n\t\tavahi_cleanup();\n\t\tfflush(stderr);\n\t}\n\n\texit(ret);\n}",
          "includes": [
            "#include \"xi2_devices.h\"",
            "#include \"uinput.h\"",
            "#include \"xevents.h\"",
            "#include \"xrecord.h\"",
            "#include \"screen.h\"",
            "#include \"avahi.h\"",
            "#include \"macosxCG.h\"",
            "#include \"macosx.h\"",
            "#include \"connections.h\"",
            "#include \"sslhelper.h\"",
            "#include \"sslcmds.h\"",
            "#include \"unixpw.h\"",
            "#include \"solid.h\"",
            "#include \"gui.h\"",
            "#include \"scan.h\"",
            "#include \"keyboard.h\"",
            "#include \"remote.h\"",
            "#include \"xdamage.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void clean_up_exit(int ret);",
            "int known_sigpipe_mode(char *s);",
            "static int exit_flag = 0;",
            "static void clean_icon_mode(void);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xi2_devices.h\"\n#include \"uinput.h\"\n#include \"xevents.h\"\n#include \"xrecord.h\"\n#include \"screen.h\"\n#include \"avahi.h\"\n#include \"macosxCG.h\"\n#include \"macosx.h\"\n#include \"connections.h\"\n#include \"sslhelper.h\"\n#include \"sslcmds.h\"\n#include \"unixpw.h\"\n#include \"solid.h\"\n#include \"gui.h\"\n#include \"scan.h\"\n#include \"keyboard.h\"\n#include \"remote.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nvoid clean_up_exit(int ret);\nint known_sigpipe_mode(char *s);\nstatic int exit_flag = 0;\nstatic void clean_icon_mode(void);\n\nvoid clean_up_exit(int ret) {\n\tstatic int depth = 0;\n\texit_flag = 1;\n\n\tif (depth++ > 2) {\n\t\texit(ret);\n\t}\n\n\tif (icon_mode) {\n\t\tclean_icon_mode();\n\t}\n\n\t/* remove the shm areas: */\n\tclean_shm(0);\n\n\tstop_stunnel();\n\tif (use_openssl) {\n\t\tssl_helper_pid(0, 0);\t/* killall */\n\t}\n\n\tif (ssh_pid > 0) {\n\t\tkill(ssh_pid, SIGTERM);\n\t\tssh_pid = 0;\n\t}\n\n#ifdef MACOSX\n\tif (client_connect_file) {\n\t\tif (strstr(client_connect_file, \"/tmp/x11vnc-macosx-remote\")\n\t\t    == client_connect_file) {\n\t\t\tunlink(client_connect_file);\n\t\t}\n\t}\n\tif (macosx_console) {\n\t\tmacosxCG_fini();\n\t}\n#endif\n\n\tif (pipeinput_fh != NULL) {\n\t\tpclose(pipeinput_fh);\n\t\tpipeinput_fh = NULL;\n\t}\n\n\tshutdown_uinput();\n\n\tif (unix_sock) {\n\t\tif (unix_sock_fd >= 0) {\n\t\t\trfbLog(\"deleting unix sock: %s\\n\", unix_sock);\n\t\t\tclose(unix_sock_fd);\n\t\t\tunix_sock_fd = -1;\n\t\t\tunlink(unix_sock);\n\t\t}\n\t}\n\n\tif (! dpy) {\t/* raw_rb hack */\n\t\tif (rm_flagfile) {\n\t\t\tunlink(rm_flagfile);\n\t\t\trm_flagfile = NULL;\n\t\t}\n\t\texit(ret);\n\t}\n\n\t/* X keyboard cleanups */\n\tdelete_added_keycodes(0);\n\n\t/* remove all created XInput2 devices */\n\tif(use_multipointer)\n\t    removeAllMDs(dpy);\n\n\tif (clear_mods == 1) {\n\t\tclear_modifiers(0);\n\t} else if (clear_mods == 2) {\n\t\tclear_keys();\n\t} else if (clear_mods == 3) {\n\t\tclear_keys();\n\t\tclear_locks();\n\t}\n\n\tif (no_autorepeat) {\n\t\tautorepeat(1, 0);\n\t}\n\tif (use_solid_bg) {\n\t\tsolid_bg(1);\n\t}\n\tif (ncache || ncache0) {\n\t\tkde_no_animate(1);\n\t}\n\tX_LOCK;\n\tXTestDiscard_wr(dpy);\n#if HAVE_LIBXDAMAGE\n\tif (xdamage) {\n\t\tXDamageDestroy(dpy, xdamage);\n\t}\n#endif\n#if HAVE_LIBXTRAP\n\tif (trap_ctx) {\n\t\tXEFreeTC(trap_ctx);\n\t}\n#endif\n\t/* XXX rdpy_ctrl, etc. cannot close w/o blocking */\n\tXCloseDisplay_wr(dpy);\n\tX_UNLOCK;\n\n\tfflush(stderr);\n\n\tif (rm_flagfile) {\n\t\tunlink(rm_flagfile);\n\t\trm_flagfile = NULL;\n\t}\n\n\tif (avahi) {\n\t\tavahi_cleanup();\n\t\tfflush(stderr);\n\t}\n\n\texit(ret);\n}"
        }
      },
      {
        "call_info": {
          "callee": "system",
          "args": [
            "cmd"
          ],
          "line": 729
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "close",
          "args": [
            "n"
          ],
          "line": 727
        },
        "resolved": true,
        "details": {
          "function_name": "close_alarm",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/unixpw.c",
          "lines": "666-672",
          "snippet": "static void close_alarm (int sig) {\n\tif (slave_fd >= 0) {\n\t\tclose(slave_fd);\n\t}\n\talarm_fired = 1;\n\tif (0) sig = 0;\t/* compiler warning */\n}",
          "includes": [
            "#include <sys/stropts.h>",
            "#include <termios.h>",
            "#include <sys/ioctl.h>",
            "#include <shadow.h>",
            "#include \"default8x16.h\"",
            "#include \"rates.h\"",
            "#include \"cursor.h\"",
            "#include \"sslhelper.h\"",
            "#include \"connections.h\"",
            "#include \"user.h\"",
            "#include \"connections.h\"",
            "#include \"xinerama.h\"",
            "#include \"cleanup.h\"",
            "#include \"scan.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int slave_fd = -1, alarm_fired = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/stropts.h>\n#include <termios.h>\n#include <sys/ioctl.h>\n#include <shadow.h>\n#include \"default8x16.h\"\n#include \"rates.h\"\n#include \"cursor.h\"\n#include \"sslhelper.h\"\n#include \"connections.h\"\n#include \"user.h\"\n#include \"connections.h\"\n#include \"xinerama.h\"\n#include \"cleanup.h\"\n#include \"scan.h\"\n#include \"x11vnc.h\"\n\nstatic int slave_fd = -1, alarm_fired = 0;\n\nstatic void close_alarm (int sig) {\n\tif (slave_fd >= 0) {\n\t\tclose(slave_fd);\n\t}\n\talarm_fired = 1;\n\tif (0) sig = 0;\t/* compiler warning */\n}"
        }
      },
      {
        "call_info": {
          "callee": "dup2",
          "args": [
            "n",
            "2"
          ],
          "line": 725
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dup2",
          "args": [
            "n",
            "1"
          ],
          "line": 724
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dup2",
          "args": [
            "n",
            "0"
          ],
          "line": 723
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "open",
          "args": [
            "\"/dev/null\"",
            "O_RDONLY"
          ],
          "line": 722
        },
        "resolved": true,
        "details": {
          "function_name": "accept_openssl",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/sslhelper.c",
          "lines": "3302-4284",
          "snippet": "void accept_openssl(int mode, int presock) {\n\tint sock = -1, listen = -1, cport, csock, vsock;\t\n\tint peerport = 0;\n\tint status, n, i, db = 0;\n\tstruct sockaddr_in addr;\n#ifdef __hpux\n\tint addrlen = sizeof(addr);\n#else\n\tsocklen_t addrlen = sizeof(addr);\n#endif\n\trfbClientPtr client;\n\tpid_t pid;\n\tchar uniq[] = \"_evilrats_\";\n\tchar cookie[256], rcookie[256], *name = NULL;\n\tint vencrypt_sel = 0;\n\tint anontls_sel = 0;\n\tchar *ipv6_name = NULL;\n\tstatic double last_https = 0.0;\n\tstatic char last_get[256];\n\tstatic int first = 1;\n\tunsigned char *rb;\n\n#if !LIBVNCSERVER_HAVE_LIBSSL && !HAVE_LIBSSL  \n\tif (enc_str == NULL || strcmp(enc_str, \"none\")) {\n\t\tbadnews(\"0 accept_openssl\");\n\t}\n#endif\n\n\topenssl_last_helper_pid = 0;\n\n\t/* zero buffers for use below. */\n\tfor (i=0; i<256; i++) {\n\t\tif (first) {\n\t\t\tlast_get[i] = '\\0';\n\t\t}\n\t\tcookie[i]  = '\\0';\n\t\trcookie[i] = '\\0';\n\t}\n\tfirst = 0;\n\n\tif (getenv(\"ACCEPT_OPENSSL_DEBUG\")) {\n\t\tdb = atoi(getenv(\"ACCEPT_OPENSSL_DEBUG\"));\n\t}\n\n\t/* do INETD, VNC, or HTTPS cases (result is client socket or pipe) */\n\tif (mode == OPENSSL_INETD) {\n\t\tssl_initialized = 1;\n\n\t} else if (mode == OPENSSL_VNC) {\n\t\tsock = accept(openssl_sock, (struct sockaddr *)&addr, &addrlen);\n\t\tif (sock < 0)  {\n\t\t\trfbLog(\"SSL: accept_openssl: accept connection failed\\n\");\n\t\t\trfbLogPerror(\"accept\");\n\t\t\tif (ssl_no_fail) {\n\t\t\t\tclean_up_exit(1);\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t\tlisten = openssl_sock;\n\n\t} else if (mode == OPENSSL_VNC6 || mode == OPENSSL_HTTPS6) {\n#if X11VNC_IPV6\n\t\tstruct sockaddr_in6 a6;\n\t\tsocklen_t a6len = sizeof(a6);\n\t\tint fd = (mode == OPENSSL_VNC6 ? openssl_sock6 : https_sock6); \n\n\t\tsock = accept(fd, (struct sockaddr *)&a6, &a6len);\n\t\tif (sock < 0)  {\n\t\t\trfbLog(\"SSL: accept_openssl: accept connection failed\\n\");\n\t\t\trfbLogPerror(\"accept\");\n\t\t\tif (ssl_no_fail) {\n\t\t\t\tclean_up_exit(1);\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t\tipv6_name = ipv6_getipaddr((struct sockaddr *)&a6, a6len);\n\t\tif (!ipv6_name) ipv6_name = strdup(\"unknown\");\n\t\tlisten = fd;\n#endif\n\t} else if (mode == OPENSSL_REVERSE) {\n\t\tsock = presock;\n\t\tif (sock < 0)  {\n\t\t\trfbLog(\"SSL: accept_openssl: connection failed\\n\");\n\t\t\tif (ssl_no_fail) {\n\t\t\t\tclean_up_exit(1);\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t\tif (getenv(\"OPENSSL_REVERSE_DEBUG\")) fprintf(stderr, \"OPENSSL_REVERSE: ipv6_client_ip_str: %s\\n\", ipv6_client_ip_str);\n\t\tif (ipv6_client_ip_str != NULL) {\n\t\t\tipv6_name = strdup(ipv6_client_ip_str);\n\t\t}\n\t\tlisten = -1;\n\n\t} else if (mode == OPENSSL_HTTPS) {\n\t\tsock = accept(https_sock, (struct sockaddr *)&addr, &addrlen);\n\t\tif (sock < 0)  {\n\t\t\trfbLog(\"SSL: accept_openssl: accept connection failed\\n\");\n\t\t\trfbLogPerror(\"accept\");\n\t\t\tif (ssl_no_fail) {\n\t\t\t\tclean_up_exit(1);\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t\tlisten = https_sock;\n\t}\n\tif (db) fprintf(stderr, \"SSL: accept_openssl: sock: %d\\n\", sock);\n\n\tif (openssl_last_ip) {\n\t\tfree(openssl_last_ip);\n\t\topenssl_last_ip = NULL;\n\t}\n\tif (mode == OPENSSL_INETD) {\n\t\topenssl_last_ip = get_remote_host(fileno(stdin));\n\t} else if (mode == OPENSSL_VNC6 || mode == OPENSSL_HTTPS6) {\n\t\topenssl_last_ip = ipv6_name;\n\t} else if (mode == OPENSSL_REVERSE && ipv6_name != NULL) {\n\t\topenssl_last_ip = ipv6_name;\n\t} else {\n\t\topenssl_last_ip = get_remote_host(sock);\n\t}\n\n\tif (!check_ssl_access(openssl_last_ip)) {\n\t\trfbLog(\"SSL: accept_openssl: denying client %s\\n\", openssl_last_ip);\n\t\trfbLog(\"SSL: accept_openssl: does not match -allow or other reason.\\n\");\n\t\tclose(sock);\n\t\tsock = -1;\n\t\tif (ssl_no_fail) {\n\t\t\tclean_up_exit(1);\n\t\t}\n\t\treturn;\n\t}\n\n\t/* now make a listening socket for child to connect back to us by: */\n\n\tcport = find_free_port(20000, 22000);\n\tif (! cport && ipv6_listen) {\n\t\trfbLog(\"SSL: accept_openssl: seeking IPv6 port.\\n\");\n\t\tcport = find_free_port6(20000, 22000);\n\t\trfbLog(\"SSL: accept_openssl: IPv6 port: %d\\n\", cport);\n\t}\n\tif (! cport) {\n\t\trfbLog(\"SSL: accept_openssl: could not find open port.\\n\");\n\t\tclose(sock);\n\t\tif (mode == OPENSSL_INETD || ssl_no_fail) {\n\t\t\tclean_up_exit(1);\n\t\t}\n\t\treturn;\n\t}\n\tif (db) fprintf(stderr, \"accept_openssl: cport: %d\\n\", cport);\n\n\tcsock = listen_tcp(cport, htonl(INADDR_LOOPBACK), 1);\n\n\tif (csock < 0) {\n\t\trfbLog(\"SSL: accept_openssl: could not listen on port %d.\\n\",\n\t\t    cport);\n\t\tclose(sock);\n\t\tif (mode == OPENSSL_INETD || ssl_no_fail) {\n\t\t\tclean_up_exit(1);\n\t\t}\n\t\treturn;\n\t}\n\tif (db) fprintf(stderr, \"accept_openssl: csock: %d\\n\", csock);\n\n\tfflush(stderr);\n\n\t/*\n\t * make a simple cookie to id the child socket, not foolproof\n\t * but hard to guess exactly (just worrying about local lusers\n\t * here, since we use INADDR_LOOPBACK).\n\t */\n\trb = (unsigned char *) calloc(6, 1);\n#if LIBVNCSERVER_HAVE_LIBSSL || HAVE_LIBSSL \n\tRAND_bytes(rb, 6);\n#endif\n\tsprintf(cookie, \"RB=%d%d%d%d%d%d/%f%f/%p\",\n\t    rb[0], rb[1], rb[2], rb[3], rb[4], rb[5],\n            dnow() - x11vnc_start, x11vnc_start, (void *)rb);\n\n\tif (mode == OPENSSL_VNC6) {\n\t\tname = strdup(ipv6_name);\n\t\tpeerport = get_remote_port(sock);\n\t} else if (mode == OPENSSL_REVERSE && ipv6_name != NULL) {\n\t\tname = strdup(ipv6_name);\n\t\tpeerport = get_remote_port(sock);\n\t} else if (mode != OPENSSL_INETD) {\n\t\tname = get_remote_host(sock);\n\t\tpeerport = get_remote_port(sock);\n\t} else {\n\t\topenssl_last_ip = get_remote_host(fileno(stdin));\n\t\tpeerport = get_remote_port(fileno(stdin));\n\t\tif (openssl_last_ip) {\n\t\t\tname = strdup(openssl_last_ip);\n\t\t} else {\n\t\t\tname = strdup(\"unknown\");\n\t\t}\n\t}\n\tif (name) {\n\t\tif (mode == OPENSSL_INETD) {\n\t\t\trfbLog(\"SSL: (inetd) spawning helper process \"\n\t\t\t    \"to handle: %s:%d\\n\", name, peerport);\n\t\t} else {\n\t\t\trfbLog(\"SSL: spawning helper process to handle: \"\n\t\t\t    \"%s:%d\\n\", name, peerport);\n\t\t}\n\t\tfree(name);\n\t\tname = NULL;\n\t}\n\n\tif (certret) {\n\t\tfree(certret);\n\t}\n\tif (certret_str) {\n\t\tfree(certret_str);\n\t\tcertret_str = NULL;\n\t}\n\tcertret = strdup(\"/tmp/x11vnc-certret.XXXXXX\");\n\tomode = umask(077);\n\tcertret_fd = mkstemp(certret);\n\tumask(omode);\n\tif (certret_fd < 0) {\n\t\tfree(certret);\n\t\tcertret = NULL;\n\t\tcertret_fd = -1;\n\t}\n\n\tif (dhret) {\n\t\tfree(dhret);\n\t}\n\tif (dhret_str) {\n\t\tfree(dhret_str);\n\t\tdhret_str = NULL;\n\t}\n\tdhret = strdup(\"/tmp/x11vnc-dhret.XXXXXX\");\n\tomode = umask(077);\n\tdhret_fd = mkstemp(dhret);\n\tumask(omode);\n\tif (dhret_fd < 0) {\n\t\tfree(dhret);\n\t\tdhret = NULL;\n\t\tdhret_fd = -1;\n\t}\n\n\t/* now fork the child to handle the SSL: */\n\tpid = fork();\n\n\tif (pid > 0) {\n\t\trfbLog(\"SSL: helper for peerport %d is pid %d: \\n\",\n\t\t    peerport, (int) pid);\n\t}\n\n\tif (pid < 0) {\n\t\trfbLog(\"SSL: accept_openssl: could not fork.\\n\");\n\t\trfbLogPerror(\"fork\");\n\t\tclose(sock);\n\t\tclose(csock);\n\t\tif (mode == OPENSSL_INETD || ssl_no_fail) {\n\t\t\tclean_up_exit(1);\n\t\t}\n\t\treturn;\n\n\t} else if (pid == 0) {\n\t\tint s_in, s_out, httpsock = -1;\n\t\tint vncsock;\n\t\tint i, have_httpd = 0;\n\t\tint f_in  = fileno(stdin);\n\t\tint f_out = fileno(stdout);\n\t\tint skip_vnc_tls = mode == OPENSSL_HTTPS ? 1 : 0;\n\n\t\tif (db) fprintf(stderr, \"helper pid in: %d %d %d %d\\n\", f_in, f_out, sock, listen);\n\n\t\t/* reset all handlers to default (no interrupted() calls) */\n\t\tunset_signals();\n\n\t\t/* close all non-essential fd's */\n\t\tfor (i=0; i<256; i++) {\n\t\t\tif (mode == OPENSSL_INETD) {\n\t\t\t\tif (i == f_in || i == f_out) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (i == sock) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (i == 2) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tclose(i);\n\t\t}\n\n\t\t/*\n\t\t * sadly, we are a long lived child and so the large\n\t\t * framebuffer memory areas will soon differ from parent.\n\t\t * try to free as much as possible.\n\t\t */\n\t\tlose_ram();\n\n\t\t/* now connect back to parent socket: */\n\t\tvncsock = connect_tcp(\"127.0.0.1\", cport);\n\t\tif (vncsock < 0) {\n\t\t\trfbLog(\"SSL: ssl_helper[%d]: could not connect\"\n\t\t\t    \" back to: %d\\n\", getpid(), cport);\n\t\t\trfbLog(\"SSL: ssl_helper[%d]: exit case 1 (no local vncsock)\\n\", getpid());\n\t\t\texit(1);\n\t\t}\n\t\tif (db) fprintf(stderr, \"vncsock %d\\n\", vncsock);\n\n\t\t/* try to initialize SSL with the remote client */\n\n\t\tif (mode == OPENSSL_INETD) {\n\t\t\ts_in  = fileno(stdin);\n\t\t\ts_out = fileno(stdout);\n\t\t} else {\n\t\t\ts_in = s_out = sock;\n\t\t}\n\n\t\tif (! ssl_init(s_in, s_out, skip_vnc_tls, last_https)) {\n\t\t\tclose(vncsock);\n\t\t\trfbLog(\"SSL: ssl_helper[%d]: exit case 2 (ssl_init failed)\\n\", getpid());\n\t\t\texit(1);\n\t\t}\n\n\t\tif (vencrypt_selected != 0) {\n\t\t\tchar *tbuf;\n\t\t\ttbuf = (char *) malloc(strlen(cookie) + 100);\n\t\t\tsprintf(tbuf, \"%s,VENCRYPT=%d,%s\", uniq, vencrypt_selected, cookie);\n\t\t\twrite(vncsock, tbuf, strlen(cookie));\n\t\t\tgoto wrote_cookie;\n\t\t} else if (anontls_selected != 0) {\n\t\t\tchar *tbuf;\n\t\t\ttbuf = (char *) malloc(strlen(cookie) + 100);\n\t\t\tsprintf(tbuf, \"%s,ANONTLS=%d,%s\", uniq, anontls_selected, cookie);\n\t\t\twrite(vncsock, tbuf, strlen(cookie));\n\t\t\tgoto wrote_cookie;\n\t\t}\n\n\t\t/*\n\t\t * things get messy below since we are trying to do\n\t\t * *both* VNC and Java applet httpd through the same\n\t\t * SSL socket.\n\t\t */\n\n\t\tif (! screen) {\n\t\t\tclose(vncsock);\n\t\t\texit(1);\n\t\t}\n\t\tif (screen->httpListenSock >= 0 && screen->httpPort > 0) {\n\t\t\thave_httpd = 1;\n\t\t} else if (ipv6_http_fd >= 0) {\n\t\t\thave_httpd = 1;\n\t\t} else if (screen->httpListenSock == -2) {\n\t\t\thave_httpd = 1;\n\t\t}\n\t\tif (mode == OPENSSL_HTTPS && ! have_httpd) {\n\t\t\trfbLog(\"SSL: accept_openssl[%d]: no httpd socket for \"\n\t\t\t    \"-https mode\\n\", getpid());\n\t\t\tclose(vncsock);\n\t\t\trfbLog(\"SSL: ssl_helper[%d]: exit case 3 (no httpd sock)\\n\", getpid());\n\t\t\texit(1);\n\t\t}\n\n\t\tif (have_httpd) {\n\t\t\tint n = 0, is_http = 0;\n\t\t\tint hport = screen->httpPort; \n\t\t\tchar *iface = NULL;\n\t\t\tchar *buf, *tbuf;\n\n\t\t\tbuf  = (char *) calloc((ABSIZE+1), 1);\n\t\t\ttbuf = (char *) calloc((2*ABSIZE+1), 1);\n\n\t\t\tif (mode == OPENSSL_HTTPS) {\n\t\t\t\t/*\n\t\t\t\t * for this mode we know it is HTTP traffic\n\t\t\t\t * so we skip trying to guess.\n\t\t\t\t */\n\t\t\t\tis_http = 1;\n\t\t\t\tn = 0;\n\t\t\t\tgoto connect_to_httpd;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * Check if there is stuff to read from remote end\n\t\t\t * if so it is likely a GET or HEAD.\n\t\t\t */\n\t\t\tif (! is_ssl_readable(s_in, last_https, last_get,\n\t\t\t    mode)) {\n\t\t\t\tgoto write_cookie;\n\t\t\t}\n\t\n\t\t\t/* \n\t\t\t * read first 2 bytes to try to guess.  sadly,\n\t\t\t * the user is often pondering a \"non-verified\n\t\t\t * cert\" dialog for a long time before the GET\n\t\t\t * is ever sent.  So often we timeout here.\n\t\t\t */\n\n\t\t\tif (db) fprintf(stderr, \"watch_for_http_traffic\\n\");\n\n\t\t\tis_http = watch_for_http_traffic(buf, &n, s_in);\n\n\t\t\tif (is_http < 0 || is_http == 0) {\n\t\t\t\t/*\n\t\t\t\t * error or http not detected, fall back\n\t\t\t\t * to normal VNC socket.\n\t\t\t\t */\n\t\t\t\tif (db) fprintf(stderr, \"is_http err: %d n: %d\\n\", is_http, n);\n\t\t\t\twrite(vncsock, cookie, strlen(cookie));\n\t\t\t\tif (n > 0) {\n\t\t\t\t\twrite(vncsock, buf, n);\n\t\t\t\t}\n\t\t\t\tgoto wrote_cookie;\n\t\t\t}\n\n\t\t\tif (db) fprintf(stderr, \"is_http: %d n: %d\\n\",\n\t\t\t    is_http, n);\n\t\t\tif (db) fprintf(stderr, \"buf: '%s'\\n\", buf);\n\n\t\t\tif (strstr(buf, \"/request.https.vnc.connection\")) {\n\t\t\t\tchar reply[] = \"HTTP/1.0 200 OK\\r\\n\"\n\t\t\t\t    \"Content-Type: octet-stream\\r\\n\"\n\t\t\t\t    \"Connection: Keep-Alive\\r\\n\"\n\t\t\t\t    \"VNC-Server: x11vnc\\r\\n\"\n\t\t\t\t    \"Pragma: no-cache\\r\\n\\r\\n\";\n\t\t\t\t/*\n\t\t\t\t * special case proxy coming thru https\n\t\t\t\t * instead of a direct SSL connection.\n\t\t\t\t */\n\t\t\t\trfbLog(\"Handling VNC request via https GET. [%d]\\n\", getpid());\n\t\t\t\trfbLog(\"-- %s\\n\", buf);\n\n\t\t\t\tif (strstr(buf, \"/reverse.proxy\")) {\n\t\t\t\t\tchar *buf2;\n\t\t\t\t\tint n, ptr;\n#if !LIBVNCSERVER_HAVE_LIBSSL && !HAVE_LIBSSL \n\t\t\t\t\twrite(s_out, reply, strlen(reply));\n#else\n\t\t\t\t\tSSL_write(ssl, reply, strlen(reply));\n#endif\n\t\t\t\t\n\t\t\t\t\tbuf2  = (char *) calloc((8192+1), 1);\n\t\t\t\t\tn = 0;\n\t\t\t\t\tptr = 0;\n\t\t\t\t\twhile (ptr < 8192) {\n#if !LIBVNCSERVER_HAVE_LIBSSL && !HAVE_LIBSSL \n\t\t\t\t\t\tn = read(s_in, buf2 + ptr, 1);\n#else\n\t\t\t\t\t\tn = SSL_read(ssl, buf2 + ptr, 1);\n#endif\n\t\t\t\t\t\tif (n > 0) {\n\t\t\t\t\t\t\tptr += n;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (db) fprintf(stderr, \"buf2: '%s'\\n\", buf2);\n\n\t\t\t\t\t\tif (strstr(buf2, \"\\r\\n\\r\\n\")) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tfree(buf2);\n\t\t\t\t}\n\t\t\t\tgoto write_cookie;\n\n\t\t\t} else if (strstr(buf, \"/check.https.proxy.connection\")) {\n\t\t\t\tchar reply[] = \"HTTP/1.0 200 OK\\r\\n\"\n\t\t\t\t    \"Connection: close\\r\\n\"\n\t\t\t\t    \"Content-Type: octet-stream\\r\\n\"\n\t\t\t\t    \"VNC-Server: x11vnc\\r\\n\"\n\t\t\t\t    \"Pragma: no-cache\\r\\n\\r\\n\";\n\n\t\t\t\trfbLog(\"Handling Check HTTPS request via https GET. [%d]\\n\", getpid());\n\t\t\t\trfbLog(\"-- %s\\n\", buf);\n\n#if !LIBVNCSERVER_HAVE_LIBSSL && !HAVE_LIBSSL \n\t\t\t\twrite(s_out, reply, strlen(reply));\n#else\n\t\t\t\tSSL_write(ssl, reply, strlen(reply));\n\t\t\t\tSSL_shutdown(ssl);\n#endif\n\n\t\t\t\tstrcpy(tbuf, uniq);\n\t\t\t\tstrcat(tbuf, cookie);\n\t\t\t\twrite(vncsock, tbuf, strlen(tbuf));\n\t\t\t\tclose(vncsock);\n\n\t\t\t\trfbLog(\"SSL: ssl_helper[%d]: exit case 4 (check.https.proxy.connection)\\n\", getpid());\n\t\t\t\texit(0);\n\t\t\t}\n\t\t\tconnect_to_httpd:\n\n\t\t\t/*\n\t\t\t * Here we go... no turning back.  we have to\n\t\t\t * send failure to parent and close socket to have\n\t\t\t * http processed at all in a timely fashion...\n\t\t\t */\n\n\t\t\t/* send the failure tag: */\n\t\t\tstrcpy(tbuf, uniq);\n\n\t\t\tif (https_port_redir < 0 || (strstr(buf, \"PORT=\") || strstr(buf, \"port=\"))) {\n\t\t\t\tchar *q = strstr(buf, \"Host:\");\n\t\t\t\tint fport = 443, match = 0;\n\t\t\t\tchar num[16];\n\n\t\t\t\tif (q && strstr(q, \"\\n\")) {\n\t\t\t\t    q += strlen(\"Host:\") + 1;\n\t\t\t\t    while (*q != '\\n') {\n\t\t\t\t\tint p;\n\t\t\t\t\tif (*q == ':' && sscanf(q, \":%d\", &p) == 1) {\n\t\t\t\t\t\tif (p > 0 && p < 65536) {\n\t\t\t\t\t\t\tfport = p;\n\t\t\t\t\t\t\tmatch = 1;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tq++;\n\t\t\t\t    }\n\t\t\t\t}\n\t\t\t\tif (!match || !https_port_redir) {\n\t\t\t\t\tint p;\n\t\t\t\t\tif (sscanf(buf, \"PORT=%d,\", &p) == 1) {\n\t\t\t\t\t\tif (p > 0 && p < 65536) {\n\t\t\t\t\t\t\tfport = p;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else if (sscanf(buf, \"port=%d,\", &p) == 1) {\n\t\t\t\t\t\tif (p > 0 && p < 65536) {\n\t\t\t\t\t\t\tfport = p;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tsprintf(num, \"HP=%d,\", fport);\n\t\t\t\tstrcat(tbuf, num);\n\t\t\t}\n\n\t\t\tif (strstr(buf, \"HTTP/\") != NULL)  {\n\t\t\t\tchar *q, *str;\n\t\t\t\t/*\n\t\t\t\t * Also send back the GET line for heuristics.\n\t\t\t\t * (last_https, get file).\n\t\t\t\t */\n\t\t\t\tstr = strdup(buf);\n\t\t\t\tq = strstr(str, \"HTTP/\");\n\t\t\t\tif (q != NULL) {\n\t\t\t\t\t*q = '\\0';\t\n\t\t\t\t\tstrcat(tbuf, str);\n\t\t\t\t}\n\t\t\t\tfree(str);\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * Also send the cookie to pad out the number of\n\t\t\t * bytes to more than the parent wants to read.\n\t\t\t * Since this is the failure case, it does not\n\t\t\t * matter that we send more than strlen(cookie).\n\t\t\t */\n\t\t\tstrcat(tbuf, cookie);\n\t\t\twrite(vncsock, tbuf, strlen(tbuf));\n\n\t\t\tusleep(150*1000);\n\t\t\tif (db) fprintf(stderr, \"close vncsock: %d\\n\", vncsock);\n\t\t\tclose(vncsock);\n\n\t\t\t/* now, finally, connect to the libvncserver httpd: */\n\t\t\tif (screen->listenInterface == htonl(INADDR_ANY) ||\n\t\t\t    screen->listenInterface == htonl(INADDR_NONE)) {\n\t\t\t\tiface = \"127.0.0.1\";\n\t\t\t} else {\n\t\t\t\tstruct in_addr in;\n\t\t\t\tin.s_addr = screen->listenInterface;\n\t\t\t\tiface = inet_ntoa(in);\n\t\t\t}\n\t\t\tif (iface == NULL || !strcmp(iface, \"\")) {\n\t\t\t\tiface = \"127.0.0.1\";\n\t\t\t}\n\t\t\tif (db) fprintf(stderr, \"iface: %s:%d\\n\", iface, hport);\n\t\t\tusleep(150*1000);\n\n\t\t\thttpsock = connect_tcp(iface, hport);\n\n\t\t\tif (httpsock < 0) {\n\t\t\t\t/* UGH, after all of that! */\n\t\t\t\trfbLog(\"Could not connect to httpd socket!\\n\");\n\t\t\t\trfbLog(\"SSL: ssl_helper[%d]: exit case 5.\\n\", getpid());\n\t\t\t\texit(1);\n\t\t\t}\n\t\t\tif (db) fprintf(stderr, \"ssl_helper[%d]: httpsock: %d %d\\n\",\n\t\t\t    getpid(), httpsock, n);\n\n\t\t\t/*\n\t\t\t * send what we read to httpd, and then connect\n\t\t\t * the rest of the SSL session to it:\n\t\t\t */\n\t\t\tif (n > 0) {\n\t\t\t\tchar *s = getenv(\"X11VNC_EXTRA_HTTPS_PARAMS\");\n\t\t\t\tint did_extra = 0;\n\n\t\t\t\tif (db) fprintf(stderr, \"sending http buffer httpsock: %d n=%d\\n'%s'\\n\", httpsock, n, buf);\n\t\t\t\tif (s != NULL) {\n\t\t\t\t\tchar *q = strstr(buf, \" HTTP/\");\n\t\t\t\t\tif (q) {\n\t\t\t\t\t\tint m;\n\t\t\t\t\t\t*q = '\\0';\n\t\t\t\t\t\tm = strlen(buf);\n\t\t\t\t\t\twrite(httpsock, buf, m);\n\t\t\t\t\t\twrite(httpsock, s, strlen(s));\n\t\t\t\t\t\t*q = ' ';\n\t\t\t\t\t\twrite(httpsock, q, n-m);\n\t\t\t\t\t\tdid_extra = 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (!did_extra) {\n\t\t\t\t\twrite(httpsock, buf, n);\n\t\t\t\t}\n\t\t\t}\n\t\t\tssl_xfer(httpsock, s_in, s_out, is_http);\n\t\t\trfbLog(\"SSL: ssl_helper[%d]: exit case 6 (https ssl_xfer done)\\n\", getpid());\n\t\t\texit(0);\n\t\t}\n\n\t\t/*\n\t\t * ok, back from the above https mess, simply send the\n\t\t * cookie back to the parent (who will attach us to\n\t\t * libvncserver), and connect the rest of the SSL session\n\t\t * to it.\n\t\t */\n\t\twrite_cookie:\n\t\twrite(vncsock, cookie, strlen(cookie));\n\n\t\twrote_cookie:\n\t\tssl_xfer(vncsock, s_in, s_out, 0);\n\t\trfbLog(\"SSL: ssl_helper[%d]: exit case 7 (ssl_xfer done)\\n\", getpid());\n\t\tif (0) usleep(50 * 1000);\n\t\texit(0);\n\t}\n\t/* parent here */\n\n\tif (mode != OPENSSL_INETD) {\n\t\tclose(sock);\n\t}\n\tif (db) fprintf(stderr, \"helper process is: %d\\n\", pid);\n\n\t/* accept connection from our child.  */\n\tsignal(SIGALRM, csock_timeout);\n\tcsock_timeout_sock = csock;\n\talarm(20);\n\n\tvsock = accept(csock, (struct sockaddr *)&addr, &addrlen);\n\n\talarm(0);\n\tsignal(SIGALRM, SIG_DFL);\n\tclose(csock);\n\n\n\tif (vsock < 0) {\n\t\trfbLog(\"SSL: accept_openssl: connection from ssl_helper[%d] FAILED.\\n\", pid);\n\t\trfbLogPerror(\"accept\");\n\n\t\tkill(pid, SIGTERM);\n\t\twaitpid(pid, &status, WNOHANG); \n\t\tif (mode == OPENSSL_INETD || ssl_no_fail) {\n\t\t\tclean_up_exit(1);\n\t\t}\n\t\tif (certret_fd >= 0) {\n\t\t\tclose(certret_fd);\n\t\t\tcertret_fd = -1;\n\t\t}\n\t\tif (certret) {\n\t\t\tunlink(certret);\n\t\t}\n\t\tif (dhret_fd >= 0) {\n\t\t\tclose(dhret_fd);\n\t\t\tdhret_fd = -1;\n\t\t}\n\t\tif (dhret) {\n\t\t\tunlink(dhret);\n\t\t}\n\t\treturn;\n\t}\n\tif (db) fprintf(stderr, \"accept_openssl: vsock: %d\\n\", vsock);\n\n\tn = read(vsock, rcookie, strlen(cookie));\n\tif (n < 0 && errno != 0) {\n\t\trfbLogPerror(\"read\");\n\t}\n\n\tif (certret) {\n\t\tstruct stat sbuf;\n\t\tsbuf.st_size = 0;\n\t\tif (certret_fd >= 0 && stat(certret, &sbuf) == 0 && sbuf.st_size > 0) {\n\t\t\tcertret_str = (char *) calloc(sbuf.st_size+1, 1);\n\t\t\tread(certret_fd, certret_str, sbuf.st_size);\n\t\t\tclose(certret_fd);\n\t\t\tcertret_fd = -1;\n\t\t}\n\t\tif (certret_fd >= 0) {\n\t\t\tclose(certret_fd);\n\t\t\tcertret_fd = -1;\n\t\t}\n\t\tunlink(certret);\n\t\tif (certret_str && strstr(certret_str, \"NOCERT\") == certret_str) {\n\t\t\tfree(certret_str);\n\t\t\tcertret_str = NULL;\n\t\t}\n\t\tif (0 && certret_str) {\n\t\t\tfprintf(stderr, \"certret_str[%d]:\\n%s\\n\", (int) sbuf.st_size, certret_str);\n\t\t}\n\t}\n\n\tif (dhret) {\n\t\tstruct stat sbuf;\n\t\tsbuf.st_size = 0;\n\t\tif (dhret_fd >= 0 && stat(dhret, &sbuf) == 0 && sbuf.st_size > 0) {\n\t\t\tdhret_str = (char *) calloc(sbuf.st_size+1, 1);\n\t\t\tread(dhret_fd, dhret_str, sbuf.st_size);\n\t\t\tclose(dhret_fd);\n\t\t\tdhret_fd = -1;\n\t\t}\n\t\tif (dhret_fd >= 0) {\n\t\t\tclose(dhret_fd);\n\t\t\tdhret_fd = -1;\n\t\t}\n\t\tunlink(dhret);\n\t\tif (dhret_str && strstr(dhret_str, \"NOCERT\") == dhret_str) {\n\t\t\tfree(dhret_str);\n\t\t\tdhret_str = NULL;\n\t\t}\n\t\tif (dhret_str) {\n\t\t\tif (new_dh_params == NULL) {\n\t\t\t\tfprintf(stderr, \"dhret_str[%d]:\\n%s\\n\", (int) sbuf.st_size, dhret_str);\n\t\t\t\tnew_dh_params = strdup(dhret_str);\n\t\t\t}\n\t\t}\n\t}\n\n\tif (0) {\n\t\tfprintf(stderr, \"rcookie: %s\\n\", rcookie);\n\t\tfprintf(stderr, \"cookie:  %s\\n\", cookie);\n\t}\n\n\tif (strstr(rcookie, uniq) == rcookie) {\n\t\tchar *q = strstr(rcookie, \"RB=\");\n\t\tif (q && strstr(cookie, q) == cookie) {\n\t\t\tvencrypt_sel = 0;\n\t\t\tanontls_sel = 0;\n\t\t\tq = strstr(rcookie, \"VENCRYPT=\");\n\t\t\tif (q && sscanf(q, \"VENCRYPT=%d,\", &vencrypt_sel) == 1) {\n\t\t\t\tif (vencrypt_sel != 0) {\n\t\t\t\t\trfbLog(\"SSL: VENCRYPT mode=%d accepted. helper[%d]\\n\", vencrypt_sel, pid);\n\t\t\t\t\tgoto accept_client;\n\t\t\t\t}\n\t\t\t}\n\t\t\tq = strstr(rcookie, \"ANONTLS=\");\n\t\t\tif (q && sscanf(q, \"ANONTLS=%d,\", &anontls_sel) == 1) {\n\t\t\t\tif (anontls_sel != 0) {\n\t\t\t\t\trfbLog(\"SSL: ANONTLS mode=%d accepted. helper[%d]\\n\", anontls_sel, pid);\n\t\t\t\t\tgoto accept_client;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tif (n != (int) strlen(cookie) || strncmp(cookie, rcookie, n)) {\n\t\trfbLog(\"SSL: accept_openssl: cookie from ssl_helper[%d] FAILED. %d\\n\", pid, n);\n\t\tif (db) fprintf(stderr, \"'%s'\\n'%s'\\n\", cookie, rcookie);\n\t\tclose(vsock);\n\n\t\tif (strstr(rcookie, uniq) == rcookie) {\n\t\t\tint i;\n\t\t\tdouble https_download_wait_time = 15.0;\n\n\t\t\tif (getenv(\"X11VNC_HTTPS_DOWNLOAD_WAIT_TIME\")) {\n\t\t\t\thttps_download_wait_time = atof(getenv(\"X11VNC_HTTPS_DOWNLOAD_WAIT_TIME\"));\n\t\t\t}\n\n\t\t\trfbLog(\"SSL: BUT WAIT! HTTPS for helper process[%d] succeeded. Good.\\n\", pid);\n\t\t\tif (mode != OPENSSL_HTTPS) {\n\t\t\t\tlast_https = dnow();\n\t\t\t\tfor (i=0; i<256; i++) {\n\t\t\t\t\tlast_get[i] = '\\0';\n\t\t\t\t}\n\t\t\t\tstrncpy(last_get, rcookie, 100);\n\t\t\t\tif (db) fprintf(stderr, \"last_get: '%s'\\n\", last_get);\n\t\t\t}\n\t\t\tif (rcookie && strstr(rcookie, \"VncViewer.class\")) {\n\t\t\t\trfbLog(\"\\n\");\n\t\t\t\trfbLog(\"helper[%d]:\\n\", pid);\n\t\t\t\trfbLog(\"***********************************************************\\n\");\n\t\t\t\trfbLog(\"SSL: WARNING CLIENT ASKED FOR NONEXISTENT 'VncViewer.class'\\n\");\n\t\t\t\trfbLog(\"SSL: USER NEEDS TO MAKE SURE THE JAVA PLUGIN IS INSTALLED\\n\");\n\t\t\t\trfbLog(\"SSL: AND WORKING PROPERLY (e.g. a test-java-plugin page.)\\n\");\n\t\t\t\trfbLog(\"SSL: AND/OR USER NEEDS TO **RESTART** HIS WEB BROWSER.\\n\");\n\t\t\t\trfbLog(\"SSL: SOMETIMES THE BROWSER 'REMEMBERS' FAILED APPLET DOWN-\\n\");\n\t\t\t\trfbLog(\"SSL: LOADS AND RESTARTING IT IS THE ONLY WAY TO FIX THINGS.\\n\");\n\t\t\t\trfbLog(\"***********************************************************\\n\");\n\t\t\t\trfbLog(\"\\n\");\n\t\t\t}\n\t\t\tssl_helper_pid(pid, -2);\n\n\t\t\tif (https_port_redir) {\n\t\t\t\tdouble start;\n\t\t\t\tint origport = screen->port;\n\t\t\t\tint useport = screen->port;\n\t\t\t\tint saw_httpsock = 0;\n\t\t\t\t/* to expand $PORT correctly in index.vnc */\n\t\t\t\tif (https_port_redir < 0) {\n\t\t\t\t\tchar *q = strstr(rcookie, \"HP=\");\n\t\t\t\t\tif (q) {\n\t\t\t\t\t\tint p;\n\t\t\t\t\t\tif (sscanf(q, \"HP=%d,\", &p) == 1) {\n\t\t\t\t\t\t\tuseport = p;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tuseport = https_port_redir;\n\t\t\t\t}\n\t\t\t\tscreen->port = useport;\n\t\t\t\tif (origport != useport) {\n\t\t\t\t\trfbLog(\"SSL: -httpsredir guess port: %d  helper[%d]\\n\", screen->port, pid);\n\t\t\t\t}\n\n\t\t\t\tstart = dnow();\n\t\t\t\twhile (dnow() < start + https_download_wait_time) {\n\t\t\t\t\tif (screen->httpSock >= 0) saw_httpsock = 1;\n\t\t\t\t\trfbPE(10000);\n\t\t\t\t\tusleep(10000);\n\t\t\t\t\tif (screen->httpSock >= 0) saw_httpsock = 1;\n\t\t\t\t\twaitpid(pid, &status, WNOHANG); \n\t\t\t\t\tif (kill(pid, 0) != 0) {\n\t\t\t\t\t\trfbLog(\"SSL: helper[%d] pid finished\\n\", pid);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif (0 && saw_httpsock && screen->httpSock < 0) {\n\t\t\t\t\t\t/* this check can kill the helper too soon. */\n\t\t\t\t\t\trfbLog(\"SSL: httpSock for helper[%d] went away\\n\", pid);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\trfbLog(\"SSL: guessing child helper[%d] https finished. dt=%.6f\\n\",\n\t\t\t\t    pid, dnow() - start);\n\n\t\t\t\trfbPE(10000);\n\t\t\t\trfbPE(10000);\n\t\t\t\trfbPE(10000);\n\n\t\t\t\tscreen->port = origport;\n\t\t\t\tssl_helper_pid(0, -2);\n\t\t\t\tif (mode == OPENSSL_INETD) {\n\t\t\t\t\tclean_up_exit(1);\n\t\t\t\t}\n\t\t\t} else if (mode == OPENSSL_INETD) {\n\t\t\t\tdouble start;\n\t\t\t\tint saw_httpsock = 0;\n\n\t\t\t\t/* to expand $PORT correctly in index.vnc */\n\t\t\t\tif (screen->port == 0) {\n\t\t\t\t\tint fd = fileno(stdin);\n\t\t\t\t\tif (getenv(\"X11VNC_INETD_PORT\")) {\n\t\t\t\t\t\t/* mutex */\n\t\t\t\t\t\tscreen->port = atoi(getenv(\n\t\t\t\t\t\t    \"X11VNC_INETD_PORT\"));\n\t\t\t\t\t} else {\n\t\t\t\t\t\tint tport = get_local_port(fd);\n\t\t\t\t\t\tif (tport > 0) {\n\t\t\t\t\t\t\tscreen->port = tport;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\trfbLog(\"SSL: screen->port %d for helper[%d]\\n\", screen->port, pid);\n\n\t\t\t\t/* kludge for https fetch via inetd */\n\t\t\t\tstart = dnow();\n\t\t\t\twhile (dnow() < start + https_download_wait_time) {\n\t\t\t\t\tif (screen->httpSock >= 0) saw_httpsock = 1;\n\t\t\t\t\trfbPE(10000);\n\t\t\t\t\tusleep(10000);\n\t\t\t\t\tif (screen->httpSock >= 0) saw_httpsock = 1;\n\t\t\t\t\twaitpid(pid, &status, WNOHANG); \n\t\t\t\t\tif (kill(pid, 0) != 0) {\n\t\t\t\t\t\trfbLog(\"SSL: helper[%d] pid finished\\n\", pid);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif (0 && saw_httpsock && screen->httpSock < 0) {\n\t\t\t\t\t\t/* this check can kill the helper too soon. */\n\t\t\t\t\t\trfbLog(\"SSL: httpSock for helper[%d] went away\\n\", pid);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\trfbLog(\"SSL: OPENSSL_INETD guessing \"\n\t\t\t\t    \"child helper[%d] https finished. dt=%.6f\\n\",\n\t\t\t\t    pid, dnow() - start);\n\n\t\t\t\trfbPE(10000);\n\t\t\t\trfbPE(10000);\n\t\t\t\trfbPE(10000);\n\n\t\t\t\tssl_helper_pid(0, -2);\n\t\t\t\tclean_up_exit(1);\n\t\t\t}\n\t\t\t/* this will actually only get earlier https */\n\t\t\tssl_helper_pid(0, -2);\n\t\t\treturn;\n\t\t}\n\t\tkill(pid, SIGTERM);\n\t\twaitpid(pid, &status, WNOHANG); \n\t\tif (mode == OPENSSL_INETD || ssl_no_fail) {\n\t\t\tclean_up_exit(1);\n\t\t}\n\t\treturn;\n\t}\n\n\taccept_client:\n\n\tif (db) fprintf(stderr, \"accept_openssl: cookie good: %s\\n\", cookie);\n\n\trfbLog(\"SSL: handshake with helper process[%d] succeeded.\\n\", pid);\n\n\topenssl_last_helper_pid = pid;\n\tssl_helper_pid(pid, vsock);\n\n\tif (vnc_redirect) {\n\t\tvnc_redirect_sock = vsock;\n\t\topenssl_last_helper_pid = 0;\n\t\treturn;\n\t}\n\n\tclient = create_new_client(vsock, 0);\n\topenssl_last_helper_pid = 0;\n\n\tif (client) {\n\t\tint swt = 0;\n\t\tif (mode == OPENSSL_VNC6 && openssl_last_ip != NULL) {\n\t\t\tswt = 1;\n\t\t} else if (mode == OPENSSL_REVERSE && ipv6_name != NULL && openssl_last_ip != NULL) {\n\t\t\tswt = 1;\n\t\t}\n\t\tif (swt) {\n\t\t\tif (client->host) {\n\t\t\t\tfree(client->host);\n\t\t\t}\n\t\t\tclient->host = strdup(openssl_last_ip);\n\t\t}\n\t\tif (db) fprintf(stderr, \"accept_openssl: client %p\\n\", (void *) client);\n\t\tif (db) fprintf(stderr, \"accept_openssl: new_client %p\\n\", (void *) screen->newClientHook);\n\t\tif (db) fprintf(stderr, \"accept_openssl: new_client %p\\n\", (void *) new_client);\n\t\tif (mode == OPENSSL_INETD) {\n\t\t\tinetd_client = client;\n\t\t\tclient->clientGoneHook = client_gone;\n\t\t}\n\t\tif (openssl_last_ip &&\n\t\t    strpbrk(openssl_last_ip, \"0123456789\") == openssl_last_ip) {\n\t\t\tclient->host = strdup(openssl_last_ip);\n\t\t}\n\t\tif (vencrypt_sel != 0) {\n\t\t\tclient->protocolMajorVersion = 3;\n\t\t\tclient->protocolMinorVersion = 8;\n#if LIBVNCSERVER_HAVE_LIBSSL || HAVE_LIBSSL \n\t\t\tif (!finish_vencrypt_auth(client, vencrypt_sel)) {\n\t\t\t\trfbCloseClient(client);\n\t\t\t\tclient = NULL;\n\t\t\t}\n#else\n\t\t\tbadnews(\"3 accept_openssl\");\n#endif\n\t\t} else if (anontls_sel != 0) {\n\t\t\tclient->protocolMajorVersion = 3;\n\t\t\tclient->protocolMinorVersion = 8;\n\t\t\trfbAuthNewClient(client);\n\t\t}\n\t\tif (use_threads && client != NULL) {\n\t\t\trfbStartOnHoldClient(client);\n\t\t}\n\t\t/* try to get RFB proto done now. */\n\t\tprogress_client();\n\t} else {\n\t\trfbLog(\"SSL: accept_openssl: rfbNewClient failed.\\n\");\n\t\tclose(vsock);\n\n\t\tkill(pid, SIGTERM);\n\t\twaitpid(pid, &status, WNOHANG); \n\t\tif (mode == OPENSSL_INETD || ssl_no_fail) {\n\t\t\tclean_up_exit(1);\n\t\t}\n\t\treturn;\n\t}\n}",
          "includes": [
            "#include <openssl/rand.h>",
            "#include <openssl/err.h>",
            "#include <openssl/ssl.h>",
            "#include \"user.h\"",
            "#include \"unixpw.h\"",
            "#include \"sslcmds.h\"",
            "#include \"connections.h\"",
            "#include \"scan.h\"",
            "#include \"screen.h\"",
            "#include \"cleanup.h\"",
            "#include \"inet.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [
            "#define HAVE_LIBSSL 0",
            "#define LIBVNCSERVER_HAVE_LIBSSL 0",
            "#define ABSIZE 16384",
            "#define OPENSSL_REVERSE 6",
            "#define OPENSSL_HTTPS6  5",
            "#define OPENSSL_HTTPS   4",
            "#define OPENSSL_VNC6    3",
            "#define OPENSSL_VNC     2",
            "#define OPENSSL_INETD   1"
          ],
          "globals_used": [
            "int openssl_sock = -1;",
            "int openssl_sock6 = -1;",
            "int https_sock = -1;",
            "int https_sock6 = -1;",
            "pid_t openssl_last_helper_pid = 0;",
            "char *openssl_last_ip = NULL;",
            "static char *certret = NULL;",
            "static int certret_fd = -1;",
            "static mode_t omode;",
            "char *certret_str = NULL;",
            "static char *dhret = NULL;",
            "static int dhret_fd = -1;",
            "char *dhret_str = NULL;",
            "char *new_dh_params = NULL;",
            "void raw_xfer(int csock, int s_in, int s_out);",
            "static char *get_input(char *tag, char **in);",
            "void ssl_helper_pid(pid_t pid, int sock);",
            "void accept_openssl(int mode, int presock);",
            "static void lose_ram(void);",
            "static int vencrypt_selected = 0;",
            "static int anontls_selected = 0;",
            "static int csock_timeout_sock = -1;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <openssl/rand.h>\n#include <openssl/err.h>\n#include <openssl/ssl.h>\n#include \"user.h\"\n#include \"unixpw.h\"\n#include \"sslcmds.h\"\n#include \"connections.h\"\n#include \"scan.h\"\n#include \"screen.h\"\n#include \"cleanup.h\"\n#include \"inet.h\"\n#include \"x11vnc.h\"\n\n#define HAVE_LIBSSL 0\n#define LIBVNCSERVER_HAVE_LIBSSL 0\n#define ABSIZE 16384\n#define OPENSSL_REVERSE 6\n#define OPENSSL_HTTPS6  5\n#define OPENSSL_HTTPS   4\n#define OPENSSL_VNC6    3\n#define OPENSSL_VNC     2\n#define OPENSSL_INETD   1\n\nint openssl_sock = -1;\nint openssl_sock6 = -1;\nint https_sock = -1;\nint https_sock6 = -1;\npid_t openssl_last_helper_pid = 0;\nchar *openssl_last_ip = NULL;\nstatic char *certret = NULL;\nstatic int certret_fd = -1;\nstatic mode_t omode;\nchar *certret_str = NULL;\nstatic char *dhret = NULL;\nstatic int dhret_fd = -1;\nchar *dhret_str = NULL;\nchar *new_dh_params = NULL;\nvoid raw_xfer(int csock, int s_in, int s_out);\nstatic char *get_input(char *tag, char **in);\nvoid ssl_helper_pid(pid_t pid, int sock);\nvoid accept_openssl(int mode, int presock);\nstatic void lose_ram(void);\nstatic int vencrypt_selected = 0;\nstatic int anontls_selected = 0;\nstatic int csock_timeout_sock = -1;\n\nvoid accept_openssl(int mode, int presock) {\n\tint sock = -1, listen = -1, cport, csock, vsock;\t\n\tint peerport = 0;\n\tint status, n, i, db = 0;\n\tstruct sockaddr_in addr;\n#ifdef __hpux\n\tint addrlen = sizeof(addr);\n#else\n\tsocklen_t addrlen = sizeof(addr);\n#endif\n\trfbClientPtr client;\n\tpid_t pid;\n\tchar uniq[] = \"_evilrats_\";\n\tchar cookie[256], rcookie[256], *name = NULL;\n\tint vencrypt_sel = 0;\n\tint anontls_sel = 0;\n\tchar *ipv6_name = NULL;\n\tstatic double last_https = 0.0;\n\tstatic char last_get[256];\n\tstatic int first = 1;\n\tunsigned char *rb;\n\n#if !LIBVNCSERVER_HAVE_LIBSSL && !HAVE_LIBSSL  \n\tif (enc_str == NULL || strcmp(enc_str, \"none\")) {\n\t\tbadnews(\"0 accept_openssl\");\n\t}\n#endif\n\n\topenssl_last_helper_pid = 0;\n\n\t/* zero buffers for use below. */\n\tfor (i=0; i<256; i++) {\n\t\tif (first) {\n\t\t\tlast_get[i] = '\\0';\n\t\t}\n\t\tcookie[i]  = '\\0';\n\t\trcookie[i] = '\\0';\n\t}\n\tfirst = 0;\n\n\tif (getenv(\"ACCEPT_OPENSSL_DEBUG\")) {\n\t\tdb = atoi(getenv(\"ACCEPT_OPENSSL_DEBUG\"));\n\t}\n\n\t/* do INETD, VNC, or HTTPS cases (result is client socket or pipe) */\n\tif (mode == OPENSSL_INETD) {\n\t\tssl_initialized = 1;\n\n\t} else if (mode == OPENSSL_VNC) {\n\t\tsock = accept(openssl_sock, (struct sockaddr *)&addr, &addrlen);\n\t\tif (sock < 0)  {\n\t\t\trfbLog(\"SSL: accept_openssl: accept connection failed\\n\");\n\t\t\trfbLogPerror(\"accept\");\n\t\t\tif (ssl_no_fail) {\n\t\t\t\tclean_up_exit(1);\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t\tlisten = openssl_sock;\n\n\t} else if (mode == OPENSSL_VNC6 || mode == OPENSSL_HTTPS6) {\n#if X11VNC_IPV6\n\t\tstruct sockaddr_in6 a6;\n\t\tsocklen_t a6len = sizeof(a6);\n\t\tint fd = (mode == OPENSSL_VNC6 ? openssl_sock6 : https_sock6); \n\n\t\tsock = accept(fd, (struct sockaddr *)&a6, &a6len);\n\t\tif (sock < 0)  {\n\t\t\trfbLog(\"SSL: accept_openssl: accept connection failed\\n\");\n\t\t\trfbLogPerror(\"accept\");\n\t\t\tif (ssl_no_fail) {\n\t\t\t\tclean_up_exit(1);\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t\tipv6_name = ipv6_getipaddr((struct sockaddr *)&a6, a6len);\n\t\tif (!ipv6_name) ipv6_name = strdup(\"unknown\");\n\t\tlisten = fd;\n#endif\n\t} else if (mode == OPENSSL_REVERSE) {\n\t\tsock = presock;\n\t\tif (sock < 0)  {\n\t\t\trfbLog(\"SSL: accept_openssl: connection failed\\n\");\n\t\t\tif (ssl_no_fail) {\n\t\t\t\tclean_up_exit(1);\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t\tif (getenv(\"OPENSSL_REVERSE_DEBUG\")) fprintf(stderr, \"OPENSSL_REVERSE: ipv6_client_ip_str: %s\\n\", ipv6_client_ip_str);\n\t\tif (ipv6_client_ip_str != NULL) {\n\t\t\tipv6_name = strdup(ipv6_client_ip_str);\n\t\t}\n\t\tlisten = -1;\n\n\t} else if (mode == OPENSSL_HTTPS) {\n\t\tsock = accept(https_sock, (struct sockaddr *)&addr, &addrlen);\n\t\tif (sock < 0)  {\n\t\t\trfbLog(\"SSL: accept_openssl: accept connection failed\\n\");\n\t\t\trfbLogPerror(\"accept\");\n\t\t\tif (ssl_no_fail) {\n\t\t\t\tclean_up_exit(1);\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t\tlisten = https_sock;\n\t}\n\tif (db) fprintf(stderr, \"SSL: accept_openssl: sock: %d\\n\", sock);\n\n\tif (openssl_last_ip) {\n\t\tfree(openssl_last_ip);\n\t\topenssl_last_ip = NULL;\n\t}\n\tif (mode == OPENSSL_INETD) {\n\t\topenssl_last_ip = get_remote_host(fileno(stdin));\n\t} else if (mode == OPENSSL_VNC6 || mode == OPENSSL_HTTPS6) {\n\t\topenssl_last_ip = ipv6_name;\n\t} else if (mode == OPENSSL_REVERSE && ipv6_name != NULL) {\n\t\topenssl_last_ip = ipv6_name;\n\t} else {\n\t\topenssl_last_ip = get_remote_host(sock);\n\t}\n\n\tif (!check_ssl_access(openssl_last_ip)) {\n\t\trfbLog(\"SSL: accept_openssl: denying client %s\\n\", openssl_last_ip);\n\t\trfbLog(\"SSL: accept_openssl: does not match -allow or other reason.\\n\");\n\t\tclose(sock);\n\t\tsock = -1;\n\t\tif (ssl_no_fail) {\n\t\t\tclean_up_exit(1);\n\t\t}\n\t\treturn;\n\t}\n\n\t/* now make a listening socket for child to connect back to us by: */\n\n\tcport = find_free_port(20000, 22000);\n\tif (! cport && ipv6_listen) {\n\t\trfbLog(\"SSL: accept_openssl: seeking IPv6 port.\\n\");\n\t\tcport = find_free_port6(20000, 22000);\n\t\trfbLog(\"SSL: accept_openssl: IPv6 port: %d\\n\", cport);\n\t}\n\tif (! cport) {\n\t\trfbLog(\"SSL: accept_openssl: could not find open port.\\n\");\n\t\tclose(sock);\n\t\tif (mode == OPENSSL_INETD || ssl_no_fail) {\n\t\t\tclean_up_exit(1);\n\t\t}\n\t\treturn;\n\t}\n\tif (db) fprintf(stderr, \"accept_openssl: cport: %d\\n\", cport);\n\n\tcsock = listen_tcp(cport, htonl(INADDR_LOOPBACK), 1);\n\n\tif (csock < 0) {\n\t\trfbLog(\"SSL: accept_openssl: could not listen on port %d.\\n\",\n\t\t    cport);\n\t\tclose(sock);\n\t\tif (mode == OPENSSL_INETD || ssl_no_fail) {\n\t\t\tclean_up_exit(1);\n\t\t}\n\t\treturn;\n\t}\n\tif (db) fprintf(stderr, \"accept_openssl: csock: %d\\n\", csock);\n\n\tfflush(stderr);\n\n\t/*\n\t * make a simple cookie to id the child socket, not foolproof\n\t * but hard to guess exactly (just worrying about local lusers\n\t * here, since we use INADDR_LOOPBACK).\n\t */\n\trb = (unsigned char *) calloc(6, 1);\n#if LIBVNCSERVER_HAVE_LIBSSL || HAVE_LIBSSL \n\tRAND_bytes(rb, 6);\n#endif\n\tsprintf(cookie, \"RB=%d%d%d%d%d%d/%f%f/%p\",\n\t    rb[0], rb[1], rb[2], rb[3], rb[4], rb[5],\n            dnow() - x11vnc_start, x11vnc_start, (void *)rb);\n\n\tif (mode == OPENSSL_VNC6) {\n\t\tname = strdup(ipv6_name);\n\t\tpeerport = get_remote_port(sock);\n\t} else if (mode == OPENSSL_REVERSE && ipv6_name != NULL) {\n\t\tname = strdup(ipv6_name);\n\t\tpeerport = get_remote_port(sock);\n\t} else if (mode != OPENSSL_INETD) {\n\t\tname = get_remote_host(sock);\n\t\tpeerport = get_remote_port(sock);\n\t} else {\n\t\topenssl_last_ip = get_remote_host(fileno(stdin));\n\t\tpeerport = get_remote_port(fileno(stdin));\n\t\tif (openssl_last_ip) {\n\t\t\tname = strdup(openssl_last_ip);\n\t\t} else {\n\t\t\tname = strdup(\"unknown\");\n\t\t}\n\t}\n\tif (name) {\n\t\tif (mode == OPENSSL_INETD) {\n\t\t\trfbLog(\"SSL: (inetd) spawning helper process \"\n\t\t\t    \"to handle: %s:%d\\n\", name, peerport);\n\t\t} else {\n\t\t\trfbLog(\"SSL: spawning helper process to handle: \"\n\t\t\t    \"%s:%d\\n\", name, peerport);\n\t\t}\n\t\tfree(name);\n\t\tname = NULL;\n\t}\n\n\tif (certret) {\n\t\tfree(certret);\n\t}\n\tif (certret_str) {\n\t\tfree(certret_str);\n\t\tcertret_str = NULL;\n\t}\n\tcertret = strdup(\"/tmp/x11vnc-certret.XXXXXX\");\n\tomode = umask(077);\n\tcertret_fd = mkstemp(certret);\n\tumask(omode);\n\tif (certret_fd < 0) {\n\t\tfree(certret);\n\t\tcertret = NULL;\n\t\tcertret_fd = -1;\n\t}\n\n\tif (dhret) {\n\t\tfree(dhret);\n\t}\n\tif (dhret_str) {\n\t\tfree(dhret_str);\n\t\tdhret_str = NULL;\n\t}\n\tdhret = strdup(\"/tmp/x11vnc-dhret.XXXXXX\");\n\tomode = umask(077);\n\tdhret_fd = mkstemp(dhret);\n\tumask(omode);\n\tif (dhret_fd < 0) {\n\t\tfree(dhret);\n\t\tdhret = NULL;\n\t\tdhret_fd = -1;\n\t}\n\n\t/* now fork the child to handle the SSL: */\n\tpid = fork();\n\n\tif (pid > 0) {\n\t\trfbLog(\"SSL: helper for peerport %d is pid %d: \\n\",\n\t\t    peerport, (int) pid);\n\t}\n\n\tif (pid < 0) {\n\t\trfbLog(\"SSL: accept_openssl: could not fork.\\n\");\n\t\trfbLogPerror(\"fork\");\n\t\tclose(sock);\n\t\tclose(csock);\n\t\tif (mode == OPENSSL_INETD || ssl_no_fail) {\n\t\t\tclean_up_exit(1);\n\t\t}\n\t\treturn;\n\n\t} else if (pid == 0) {\n\t\tint s_in, s_out, httpsock = -1;\n\t\tint vncsock;\n\t\tint i, have_httpd = 0;\n\t\tint f_in  = fileno(stdin);\n\t\tint f_out = fileno(stdout);\n\t\tint skip_vnc_tls = mode == OPENSSL_HTTPS ? 1 : 0;\n\n\t\tif (db) fprintf(stderr, \"helper pid in: %d %d %d %d\\n\", f_in, f_out, sock, listen);\n\n\t\t/* reset all handlers to default (no interrupted() calls) */\n\t\tunset_signals();\n\n\t\t/* close all non-essential fd's */\n\t\tfor (i=0; i<256; i++) {\n\t\t\tif (mode == OPENSSL_INETD) {\n\t\t\t\tif (i == f_in || i == f_out) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (i == sock) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (i == 2) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tclose(i);\n\t\t}\n\n\t\t/*\n\t\t * sadly, we are a long lived child and so the large\n\t\t * framebuffer memory areas will soon differ from parent.\n\t\t * try to free as much as possible.\n\t\t */\n\t\tlose_ram();\n\n\t\t/* now connect back to parent socket: */\n\t\tvncsock = connect_tcp(\"127.0.0.1\", cport);\n\t\tif (vncsock < 0) {\n\t\t\trfbLog(\"SSL: ssl_helper[%d]: could not connect\"\n\t\t\t    \" back to: %d\\n\", getpid(), cport);\n\t\t\trfbLog(\"SSL: ssl_helper[%d]: exit case 1 (no local vncsock)\\n\", getpid());\n\t\t\texit(1);\n\t\t}\n\t\tif (db) fprintf(stderr, \"vncsock %d\\n\", vncsock);\n\n\t\t/* try to initialize SSL with the remote client */\n\n\t\tif (mode == OPENSSL_INETD) {\n\t\t\ts_in  = fileno(stdin);\n\t\t\ts_out = fileno(stdout);\n\t\t} else {\n\t\t\ts_in = s_out = sock;\n\t\t}\n\n\t\tif (! ssl_init(s_in, s_out, skip_vnc_tls, last_https)) {\n\t\t\tclose(vncsock);\n\t\t\trfbLog(\"SSL: ssl_helper[%d]: exit case 2 (ssl_init failed)\\n\", getpid());\n\t\t\texit(1);\n\t\t}\n\n\t\tif (vencrypt_selected != 0) {\n\t\t\tchar *tbuf;\n\t\t\ttbuf = (char *) malloc(strlen(cookie) + 100);\n\t\t\tsprintf(tbuf, \"%s,VENCRYPT=%d,%s\", uniq, vencrypt_selected, cookie);\n\t\t\twrite(vncsock, tbuf, strlen(cookie));\n\t\t\tgoto wrote_cookie;\n\t\t} else if (anontls_selected != 0) {\n\t\t\tchar *tbuf;\n\t\t\ttbuf = (char *) malloc(strlen(cookie) + 100);\n\t\t\tsprintf(tbuf, \"%s,ANONTLS=%d,%s\", uniq, anontls_selected, cookie);\n\t\t\twrite(vncsock, tbuf, strlen(cookie));\n\t\t\tgoto wrote_cookie;\n\t\t}\n\n\t\t/*\n\t\t * things get messy below since we are trying to do\n\t\t * *both* VNC and Java applet httpd through the same\n\t\t * SSL socket.\n\t\t */\n\n\t\tif (! screen) {\n\t\t\tclose(vncsock);\n\t\t\texit(1);\n\t\t}\n\t\tif (screen->httpListenSock >= 0 && screen->httpPort > 0) {\n\t\t\thave_httpd = 1;\n\t\t} else if (ipv6_http_fd >= 0) {\n\t\t\thave_httpd = 1;\n\t\t} else if (screen->httpListenSock == -2) {\n\t\t\thave_httpd = 1;\n\t\t}\n\t\tif (mode == OPENSSL_HTTPS && ! have_httpd) {\n\t\t\trfbLog(\"SSL: accept_openssl[%d]: no httpd socket for \"\n\t\t\t    \"-https mode\\n\", getpid());\n\t\t\tclose(vncsock);\n\t\t\trfbLog(\"SSL: ssl_helper[%d]: exit case 3 (no httpd sock)\\n\", getpid());\n\t\t\texit(1);\n\t\t}\n\n\t\tif (have_httpd) {\n\t\t\tint n = 0, is_http = 0;\n\t\t\tint hport = screen->httpPort; \n\t\t\tchar *iface = NULL;\n\t\t\tchar *buf, *tbuf;\n\n\t\t\tbuf  = (char *) calloc((ABSIZE+1), 1);\n\t\t\ttbuf = (char *) calloc((2*ABSIZE+1), 1);\n\n\t\t\tif (mode == OPENSSL_HTTPS) {\n\t\t\t\t/*\n\t\t\t\t * for this mode we know it is HTTP traffic\n\t\t\t\t * so we skip trying to guess.\n\t\t\t\t */\n\t\t\t\tis_http = 1;\n\t\t\t\tn = 0;\n\t\t\t\tgoto connect_to_httpd;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * Check if there is stuff to read from remote end\n\t\t\t * if so it is likely a GET or HEAD.\n\t\t\t */\n\t\t\tif (! is_ssl_readable(s_in, last_https, last_get,\n\t\t\t    mode)) {\n\t\t\t\tgoto write_cookie;\n\t\t\t}\n\t\n\t\t\t/* \n\t\t\t * read first 2 bytes to try to guess.  sadly,\n\t\t\t * the user is often pondering a \"non-verified\n\t\t\t * cert\" dialog for a long time before the GET\n\t\t\t * is ever sent.  So often we timeout here.\n\t\t\t */\n\n\t\t\tif (db) fprintf(stderr, \"watch_for_http_traffic\\n\");\n\n\t\t\tis_http = watch_for_http_traffic(buf, &n, s_in);\n\n\t\t\tif (is_http < 0 || is_http == 0) {\n\t\t\t\t/*\n\t\t\t\t * error or http not detected, fall back\n\t\t\t\t * to normal VNC socket.\n\t\t\t\t */\n\t\t\t\tif (db) fprintf(stderr, \"is_http err: %d n: %d\\n\", is_http, n);\n\t\t\t\twrite(vncsock, cookie, strlen(cookie));\n\t\t\t\tif (n > 0) {\n\t\t\t\t\twrite(vncsock, buf, n);\n\t\t\t\t}\n\t\t\t\tgoto wrote_cookie;\n\t\t\t}\n\n\t\t\tif (db) fprintf(stderr, \"is_http: %d n: %d\\n\",\n\t\t\t    is_http, n);\n\t\t\tif (db) fprintf(stderr, \"buf: '%s'\\n\", buf);\n\n\t\t\tif (strstr(buf, \"/request.https.vnc.connection\")) {\n\t\t\t\tchar reply[] = \"HTTP/1.0 200 OK\\r\\n\"\n\t\t\t\t    \"Content-Type: octet-stream\\r\\n\"\n\t\t\t\t    \"Connection: Keep-Alive\\r\\n\"\n\t\t\t\t    \"VNC-Server: x11vnc\\r\\n\"\n\t\t\t\t    \"Pragma: no-cache\\r\\n\\r\\n\";\n\t\t\t\t/*\n\t\t\t\t * special case proxy coming thru https\n\t\t\t\t * instead of a direct SSL connection.\n\t\t\t\t */\n\t\t\t\trfbLog(\"Handling VNC request via https GET. [%d]\\n\", getpid());\n\t\t\t\trfbLog(\"-- %s\\n\", buf);\n\n\t\t\t\tif (strstr(buf, \"/reverse.proxy\")) {\n\t\t\t\t\tchar *buf2;\n\t\t\t\t\tint n, ptr;\n#if !LIBVNCSERVER_HAVE_LIBSSL && !HAVE_LIBSSL \n\t\t\t\t\twrite(s_out, reply, strlen(reply));\n#else\n\t\t\t\t\tSSL_write(ssl, reply, strlen(reply));\n#endif\n\t\t\t\t\n\t\t\t\t\tbuf2  = (char *) calloc((8192+1), 1);\n\t\t\t\t\tn = 0;\n\t\t\t\t\tptr = 0;\n\t\t\t\t\twhile (ptr < 8192) {\n#if !LIBVNCSERVER_HAVE_LIBSSL && !HAVE_LIBSSL \n\t\t\t\t\t\tn = read(s_in, buf2 + ptr, 1);\n#else\n\t\t\t\t\t\tn = SSL_read(ssl, buf2 + ptr, 1);\n#endif\n\t\t\t\t\t\tif (n > 0) {\n\t\t\t\t\t\t\tptr += n;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (db) fprintf(stderr, \"buf2: '%s'\\n\", buf2);\n\n\t\t\t\t\t\tif (strstr(buf2, \"\\r\\n\\r\\n\")) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tfree(buf2);\n\t\t\t\t}\n\t\t\t\tgoto write_cookie;\n\n\t\t\t} else if (strstr(buf, \"/check.https.proxy.connection\")) {\n\t\t\t\tchar reply[] = \"HTTP/1.0 200 OK\\r\\n\"\n\t\t\t\t    \"Connection: close\\r\\n\"\n\t\t\t\t    \"Content-Type: octet-stream\\r\\n\"\n\t\t\t\t    \"VNC-Server: x11vnc\\r\\n\"\n\t\t\t\t    \"Pragma: no-cache\\r\\n\\r\\n\";\n\n\t\t\t\trfbLog(\"Handling Check HTTPS request via https GET. [%d]\\n\", getpid());\n\t\t\t\trfbLog(\"-- %s\\n\", buf);\n\n#if !LIBVNCSERVER_HAVE_LIBSSL && !HAVE_LIBSSL \n\t\t\t\twrite(s_out, reply, strlen(reply));\n#else\n\t\t\t\tSSL_write(ssl, reply, strlen(reply));\n\t\t\t\tSSL_shutdown(ssl);\n#endif\n\n\t\t\t\tstrcpy(tbuf, uniq);\n\t\t\t\tstrcat(tbuf, cookie);\n\t\t\t\twrite(vncsock, tbuf, strlen(tbuf));\n\t\t\t\tclose(vncsock);\n\n\t\t\t\trfbLog(\"SSL: ssl_helper[%d]: exit case 4 (check.https.proxy.connection)\\n\", getpid());\n\t\t\t\texit(0);\n\t\t\t}\n\t\t\tconnect_to_httpd:\n\n\t\t\t/*\n\t\t\t * Here we go... no turning back.  we have to\n\t\t\t * send failure to parent and close socket to have\n\t\t\t * http processed at all in a timely fashion...\n\t\t\t */\n\n\t\t\t/* send the failure tag: */\n\t\t\tstrcpy(tbuf, uniq);\n\n\t\t\tif (https_port_redir < 0 || (strstr(buf, \"PORT=\") || strstr(buf, \"port=\"))) {\n\t\t\t\tchar *q = strstr(buf, \"Host:\");\n\t\t\t\tint fport = 443, match = 0;\n\t\t\t\tchar num[16];\n\n\t\t\t\tif (q && strstr(q, \"\\n\")) {\n\t\t\t\t    q += strlen(\"Host:\") + 1;\n\t\t\t\t    while (*q != '\\n') {\n\t\t\t\t\tint p;\n\t\t\t\t\tif (*q == ':' && sscanf(q, \":%d\", &p) == 1) {\n\t\t\t\t\t\tif (p > 0 && p < 65536) {\n\t\t\t\t\t\t\tfport = p;\n\t\t\t\t\t\t\tmatch = 1;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tq++;\n\t\t\t\t    }\n\t\t\t\t}\n\t\t\t\tif (!match || !https_port_redir) {\n\t\t\t\t\tint p;\n\t\t\t\t\tif (sscanf(buf, \"PORT=%d,\", &p) == 1) {\n\t\t\t\t\t\tif (p > 0 && p < 65536) {\n\t\t\t\t\t\t\tfport = p;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else if (sscanf(buf, \"port=%d,\", &p) == 1) {\n\t\t\t\t\t\tif (p > 0 && p < 65536) {\n\t\t\t\t\t\t\tfport = p;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tsprintf(num, \"HP=%d,\", fport);\n\t\t\t\tstrcat(tbuf, num);\n\t\t\t}\n\n\t\t\tif (strstr(buf, \"HTTP/\") != NULL)  {\n\t\t\t\tchar *q, *str;\n\t\t\t\t/*\n\t\t\t\t * Also send back the GET line for heuristics.\n\t\t\t\t * (last_https, get file).\n\t\t\t\t */\n\t\t\t\tstr = strdup(buf);\n\t\t\t\tq = strstr(str, \"HTTP/\");\n\t\t\t\tif (q != NULL) {\n\t\t\t\t\t*q = '\\0';\t\n\t\t\t\t\tstrcat(tbuf, str);\n\t\t\t\t}\n\t\t\t\tfree(str);\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * Also send the cookie to pad out the number of\n\t\t\t * bytes to more than the parent wants to read.\n\t\t\t * Since this is the failure case, it does not\n\t\t\t * matter that we send more than strlen(cookie).\n\t\t\t */\n\t\t\tstrcat(tbuf, cookie);\n\t\t\twrite(vncsock, tbuf, strlen(tbuf));\n\n\t\t\tusleep(150*1000);\n\t\t\tif (db) fprintf(stderr, \"close vncsock: %d\\n\", vncsock);\n\t\t\tclose(vncsock);\n\n\t\t\t/* now, finally, connect to the libvncserver httpd: */\n\t\t\tif (screen->listenInterface == htonl(INADDR_ANY) ||\n\t\t\t    screen->listenInterface == htonl(INADDR_NONE)) {\n\t\t\t\tiface = \"127.0.0.1\";\n\t\t\t} else {\n\t\t\t\tstruct in_addr in;\n\t\t\t\tin.s_addr = screen->listenInterface;\n\t\t\t\tiface = inet_ntoa(in);\n\t\t\t}\n\t\t\tif (iface == NULL || !strcmp(iface, \"\")) {\n\t\t\t\tiface = \"127.0.0.1\";\n\t\t\t}\n\t\t\tif (db) fprintf(stderr, \"iface: %s:%d\\n\", iface, hport);\n\t\t\tusleep(150*1000);\n\n\t\t\thttpsock = connect_tcp(iface, hport);\n\n\t\t\tif (httpsock < 0) {\n\t\t\t\t/* UGH, after all of that! */\n\t\t\t\trfbLog(\"Could not connect to httpd socket!\\n\");\n\t\t\t\trfbLog(\"SSL: ssl_helper[%d]: exit case 5.\\n\", getpid());\n\t\t\t\texit(1);\n\t\t\t}\n\t\t\tif (db) fprintf(stderr, \"ssl_helper[%d]: httpsock: %d %d\\n\",\n\t\t\t    getpid(), httpsock, n);\n\n\t\t\t/*\n\t\t\t * send what we read to httpd, and then connect\n\t\t\t * the rest of the SSL session to it:\n\t\t\t */\n\t\t\tif (n > 0) {\n\t\t\t\tchar *s = getenv(\"X11VNC_EXTRA_HTTPS_PARAMS\");\n\t\t\t\tint did_extra = 0;\n\n\t\t\t\tif (db) fprintf(stderr, \"sending http buffer httpsock: %d n=%d\\n'%s'\\n\", httpsock, n, buf);\n\t\t\t\tif (s != NULL) {\n\t\t\t\t\tchar *q = strstr(buf, \" HTTP/\");\n\t\t\t\t\tif (q) {\n\t\t\t\t\t\tint m;\n\t\t\t\t\t\t*q = '\\0';\n\t\t\t\t\t\tm = strlen(buf);\n\t\t\t\t\t\twrite(httpsock, buf, m);\n\t\t\t\t\t\twrite(httpsock, s, strlen(s));\n\t\t\t\t\t\t*q = ' ';\n\t\t\t\t\t\twrite(httpsock, q, n-m);\n\t\t\t\t\t\tdid_extra = 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (!did_extra) {\n\t\t\t\t\twrite(httpsock, buf, n);\n\t\t\t\t}\n\t\t\t}\n\t\t\tssl_xfer(httpsock, s_in, s_out, is_http);\n\t\t\trfbLog(\"SSL: ssl_helper[%d]: exit case 6 (https ssl_xfer done)\\n\", getpid());\n\t\t\texit(0);\n\t\t}\n\n\t\t/*\n\t\t * ok, back from the above https mess, simply send the\n\t\t * cookie back to the parent (who will attach us to\n\t\t * libvncserver), and connect the rest of the SSL session\n\t\t * to it.\n\t\t */\n\t\twrite_cookie:\n\t\twrite(vncsock, cookie, strlen(cookie));\n\n\t\twrote_cookie:\n\t\tssl_xfer(vncsock, s_in, s_out, 0);\n\t\trfbLog(\"SSL: ssl_helper[%d]: exit case 7 (ssl_xfer done)\\n\", getpid());\n\t\tif (0) usleep(50 * 1000);\n\t\texit(0);\n\t}\n\t/* parent here */\n\n\tif (mode != OPENSSL_INETD) {\n\t\tclose(sock);\n\t}\n\tif (db) fprintf(stderr, \"helper process is: %d\\n\", pid);\n\n\t/* accept connection from our child.  */\n\tsignal(SIGALRM, csock_timeout);\n\tcsock_timeout_sock = csock;\n\talarm(20);\n\n\tvsock = accept(csock, (struct sockaddr *)&addr, &addrlen);\n\n\talarm(0);\n\tsignal(SIGALRM, SIG_DFL);\n\tclose(csock);\n\n\n\tif (vsock < 0) {\n\t\trfbLog(\"SSL: accept_openssl: connection from ssl_helper[%d] FAILED.\\n\", pid);\n\t\trfbLogPerror(\"accept\");\n\n\t\tkill(pid, SIGTERM);\n\t\twaitpid(pid, &status, WNOHANG); \n\t\tif (mode == OPENSSL_INETD || ssl_no_fail) {\n\t\t\tclean_up_exit(1);\n\t\t}\n\t\tif (certret_fd >= 0) {\n\t\t\tclose(certret_fd);\n\t\t\tcertret_fd = -1;\n\t\t}\n\t\tif (certret) {\n\t\t\tunlink(certret);\n\t\t}\n\t\tif (dhret_fd >= 0) {\n\t\t\tclose(dhret_fd);\n\t\t\tdhret_fd = -1;\n\t\t}\n\t\tif (dhret) {\n\t\t\tunlink(dhret);\n\t\t}\n\t\treturn;\n\t}\n\tif (db) fprintf(stderr, \"accept_openssl: vsock: %d\\n\", vsock);\n\n\tn = read(vsock, rcookie, strlen(cookie));\n\tif (n < 0 && errno != 0) {\n\t\trfbLogPerror(\"read\");\n\t}\n\n\tif (certret) {\n\t\tstruct stat sbuf;\n\t\tsbuf.st_size = 0;\n\t\tif (certret_fd >= 0 && stat(certret, &sbuf) == 0 && sbuf.st_size > 0) {\n\t\t\tcertret_str = (char *) calloc(sbuf.st_size+1, 1);\n\t\t\tread(certret_fd, certret_str, sbuf.st_size);\n\t\t\tclose(certret_fd);\n\t\t\tcertret_fd = -1;\n\t\t}\n\t\tif (certret_fd >= 0) {\n\t\t\tclose(certret_fd);\n\t\t\tcertret_fd = -1;\n\t\t}\n\t\tunlink(certret);\n\t\tif (certret_str && strstr(certret_str, \"NOCERT\") == certret_str) {\n\t\t\tfree(certret_str);\n\t\t\tcertret_str = NULL;\n\t\t}\n\t\tif (0 && certret_str) {\n\t\t\tfprintf(stderr, \"certret_str[%d]:\\n%s\\n\", (int) sbuf.st_size, certret_str);\n\t\t}\n\t}\n\n\tif (dhret) {\n\t\tstruct stat sbuf;\n\t\tsbuf.st_size = 0;\n\t\tif (dhret_fd >= 0 && stat(dhret, &sbuf) == 0 && sbuf.st_size > 0) {\n\t\t\tdhret_str = (char *) calloc(sbuf.st_size+1, 1);\n\t\t\tread(dhret_fd, dhret_str, sbuf.st_size);\n\t\t\tclose(dhret_fd);\n\t\t\tdhret_fd = -1;\n\t\t}\n\t\tif (dhret_fd >= 0) {\n\t\t\tclose(dhret_fd);\n\t\t\tdhret_fd = -1;\n\t\t}\n\t\tunlink(dhret);\n\t\tif (dhret_str && strstr(dhret_str, \"NOCERT\") == dhret_str) {\n\t\t\tfree(dhret_str);\n\t\t\tdhret_str = NULL;\n\t\t}\n\t\tif (dhret_str) {\n\t\t\tif (new_dh_params == NULL) {\n\t\t\t\tfprintf(stderr, \"dhret_str[%d]:\\n%s\\n\", (int) sbuf.st_size, dhret_str);\n\t\t\t\tnew_dh_params = strdup(dhret_str);\n\t\t\t}\n\t\t}\n\t}\n\n\tif (0) {\n\t\tfprintf(stderr, \"rcookie: %s\\n\", rcookie);\n\t\tfprintf(stderr, \"cookie:  %s\\n\", cookie);\n\t}\n\n\tif (strstr(rcookie, uniq) == rcookie) {\n\t\tchar *q = strstr(rcookie, \"RB=\");\n\t\tif (q && strstr(cookie, q) == cookie) {\n\t\t\tvencrypt_sel = 0;\n\t\t\tanontls_sel = 0;\n\t\t\tq = strstr(rcookie, \"VENCRYPT=\");\n\t\t\tif (q && sscanf(q, \"VENCRYPT=%d,\", &vencrypt_sel) == 1) {\n\t\t\t\tif (vencrypt_sel != 0) {\n\t\t\t\t\trfbLog(\"SSL: VENCRYPT mode=%d accepted. helper[%d]\\n\", vencrypt_sel, pid);\n\t\t\t\t\tgoto accept_client;\n\t\t\t\t}\n\t\t\t}\n\t\t\tq = strstr(rcookie, \"ANONTLS=\");\n\t\t\tif (q && sscanf(q, \"ANONTLS=%d,\", &anontls_sel) == 1) {\n\t\t\t\tif (anontls_sel != 0) {\n\t\t\t\t\trfbLog(\"SSL: ANONTLS mode=%d accepted. helper[%d]\\n\", anontls_sel, pid);\n\t\t\t\t\tgoto accept_client;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tif (n != (int) strlen(cookie) || strncmp(cookie, rcookie, n)) {\n\t\trfbLog(\"SSL: accept_openssl: cookie from ssl_helper[%d] FAILED. %d\\n\", pid, n);\n\t\tif (db) fprintf(stderr, \"'%s'\\n'%s'\\n\", cookie, rcookie);\n\t\tclose(vsock);\n\n\t\tif (strstr(rcookie, uniq) == rcookie) {\n\t\t\tint i;\n\t\t\tdouble https_download_wait_time = 15.0;\n\n\t\t\tif (getenv(\"X11VNC_HTTPS_DOWNLOAD_WAIT_TIME\")) {\n\t\t\t\thttps_download_wait_time = atof(getenv(\"X11VNC_HTTPS_DOWNLOAD_WAIT_TIME\"));\n\t\t\t}\n\n\t\t\trfbLog(\"SSL: BUT WAIT! HTTPS for helper process[%d] succeeded. Good.\\n\", pid);\n\t\t\tif (mode != OPENSSL_HTTPS) {\n\t\t\t\tlast_https = dnow();\n\t\t\t\tfor (i=0; i<256; i++) {\n\t\t\t\t\tlast_get[i] = '\\0';\n\t\t\t\t}\n\t\t\t\tstrncpy(last_get, rcookie, 100);\n\t\t\t\tif (db) fprintf(stderr, \"last_get: '%s'\\n\", last_get);\n\t\t\t}\n\t\t\tif (rcookie && strstr(rcookie, \"VncViewer.class\")) {\n\t\t\t\trfbLog(\"\\n\");\n\t\t\t\trfbLog(\"helper[%d]:\\n\", pid);\n\t\t\t\trfbLog(\"***********************************************************\\n\");\n\t\t\t\trfbLog(\"SSL: WARNING CLIENT ASKED FOR NONEXISTENT 'VncViewer.class'\\n\");\n\t\t\t\trfbLog(\"SSL: USER NEEDS TO MAKE SURE THE JAVA PLUGIN IS INSTALLED\\n\");\n\t\t\t\trfbLog(\"SSL: AND WORKING PROPERLY (e.g. a test-java-plugin page.)\\n\");\n\t\t\t\trfbLog(\"SSL: AND/OR USER NEEDS TO **RESTART** HIS WEB BROWSER.\\n\");\n\t\t\t\trfbLog(\"SSL: SOMETIMES THE BROWSER 'REMEMBERS' FAILED APPLET DOWN-\\n\");\n\t\t\t\trfbLog(\"SSL: LOADS AND RESTARTING IT IS THE ONLY WAY TO FIX THINGS.\\n\");\n\t\t\t\trfbLog(\"***********************************************************\\n\");\n\t\t\t\trfbLog(\"\\n\");\n\t\t\t}\n\t\t\tssl_helper_pid(pid, -2);\n\n\t\t\tif (https_port_redir) {\n\t\t\t\tdouble start;\n\t\t\t\tint origport = screen->port;\n\t\t\t\tint useport = screen->port;\n\t\t\t\tint saw_httpsock = 0;\n\t\t\t\t/* to expand $PORT correctly in index.vnc */\n\t\t\t\tif (https_port_redir < 0) {\n\t\t\t\t\tchar *q = strstr(rcookie, \"HP=\");\n\t\t\t\t\tif (q) {\n\t\t\t\t\t\tint p;\n\t\t\t\t\t\tif (sscanf(q, \"HP=%d,\", &p) == 1) {\n\t\t\t\t\t\t\tuseport = p;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tuseport = https_port_redir;\n\t\t\t\t}\n\t\t\t\tscreen->port = useport;\n\t\t\t\tif (origport != useport) {\n\t\t\t\t\trfbLog(\"SSL: -httpsredir guess port: %d  helper[%d]\\n\", screen->port, pid);\n\t\t\t\t}\n\n\t\t\t\tstart = dnow();\n\t\t\t\twhile (dnow() < start + https_download_wait_time) {\n\t\t\t\t\tif (screen->httpSock >= 0) saw_httpsock = 1;\n\t\t\t\t\trfbPE(10000);\n\t\t\t\t\tusleep(10000);\n\t\t\t\t\tif (screen->httpSock >= 0) saw_httpsock = 1;\n\t\t\t\t\twaitpid(pid, &status, WNOHANG); \n\t\t\t\t\tif (kill(pid, 0) != 0) {\n\t\t\t\t\t\trfbLog(\"SSL: helper[%d] pid finished\\n\", pid);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif (0 && saw_httpsock && screen->httpSock < 0) {\n\t\t\t\t\t\t/* this check can kill the helper too soon. */\n\t\t\t\t\t\trfbLog(\"SSL: httpSock for helper[%d] went away\\n\", pid);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\trfbLog(\"SSL: guessing child helper[%d] https finished. dt=%.6f\\n\",\n\t\t\t\t    pid, dnow() - start);\n\n\t\t\t\trfbPE(10000);\n\t\t\t\trfbPE(10000);\n\t\t\t\trfbPE(10000);\n\n\t\t\t\tscreen->port = origport;\n\t\t\t\tssl_helper_pid(0, -2);\n\t\t\t\tif (mode == OPENSSL_INETD) {\n\t\t\t\t\tclean_up_exit(1);\n\t\t\t\t}\n\t\t\t} else if (mode == OPENSSL_INETD) {\n\t\t\t\tdouble start;\n\t\t\t\tint saw_httpsock = 0;\n\n\t\t\t\t/* to expand $PORT correctly in index.vnc */\n\t\t\t\tif (screen->port == 0) {\n\t\t\t\t\tint fd = fileno(stdin);\n\t\t\t\t\tif (getenv(\"X11VNC_INETD_PORT\")) {\n\t\t\t\t\t\t/* mutex */\n\t\t\t\t\t\tscreen->port = atoi(getenv(\n\t\t\t\t\t\t    \"X11VNC_INETD_PORT\"));\n\t\t\t\t\t} else {\n\t\t\t\t\t\tint tport = get_local_port(fd);\n\t\t\t\t\t\tif (tport > 0) {\n\t\t\t\t\t\t\tscreen->port = tport;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\trfbLog(\"SSL: screen->port %d for helper[%d]\\n\", screen->port, pid);\n\n\t\t\t\t/* kludge for https fetch via inetd */\n\t\t\t\tstart = dnow();\n\t\t\t\twhile (dnow() < start + https_download_wait_time) {\n\t\t\t\t\tif (screen->httpSock >= 0) saw_httpsock = 1;\n\t\t\t\t\trfbPE(10000);\n\t\t\t\t\tusleep(10000);\n\t\t\t\t\tif (screen->httpSock >= 0) saw_httpsock = 1;\n\t\t\t\t\twaitpid(pid, &status, WNOHANG); \n\t\t\t\t\tif (kill(pid, 0) != 0) {\n\t\t\t\t\t\trfbLog(\"SSL: helper[%d] pid finished\\n\", pid);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif (0 && saw_httpsock && screen->httpSock < 0) {\n\t\t\t\t\t\t/* this check can kill the helper too soon. */\n\t\t\t\t\t\trfbLog(\"SSL: httpSock for helper[%d] went away\\n\", pid);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\trfbLog(\"SSL: OPENSSL_INETD guessing \"\n\t\t\t\t    \"child helper[%d] https finished. dt=%.6f\\n\",\n\t\t\t\t    pid, dnow() - start);\n\n\t\t\t\trfbPE(10000);\n\t\t\t\trfbPE(10000);\n\t\t\t\trfbPE(10000);\n\n\t\t\t\tssl_helper_pid(0, -2);\n\t\t\t\tclean_up_exit(1);\n\t\t\t}\n\t\t\t/* this will actually only get earlier https */\n\t\t\tssl_helper_pid(0, -2);\n\t\t\treturn;\n\t\t}\n\t\tkill(pid, SIGTERM);\n\t\twaitpid(pid, &status, WNOHANG); \n\t\tif (mode == OPENSSL_INETD || ssl_no_fail) {\n\t\t\tclean_up_exit(1);\n\t\t}\n\t\treturn;\n\t}\n\n\taccept_client:\n\n\tif (db) fprintf(stderr, \"accept_openssl: cookie good: %s\\n\", cookie);\n\n\trfbLog(\"SSL: handshake with helper process[%d] succeeded.\\n\", pid);\n\n\topenssl_last_helper_pid = pid;\n\tssl_helper_pid(pid, vsock);\n\n\tif (vnc_redirect) {\n\t\tvnc_redirect_sock = vsock;\n\t\topenssl_last_helper_pid = 0;\n\t\treturn;\n\t}\n\n\tclient = create_new_client(vsock, 0);\n\topenssl_last_helper_pid = 0;\n\n\tif (client) {\n\t\tint swt = 0;\n\t\tif (mode == OPENSSL_VNC6 && openssl_last_ip != NULL) {\n\t\t\tswt = 1;\n\t\t} else if (mode == OPENSSL_REVERSE && ipv6_name != NULL && openssl_last_ip != NULL) {\n\t\t\tswt = 1;\n\t\t}\n\t\tif (swt) {\n\t\t\tif (client->host) {\n\t\t\t\tfree(client->host);\n\t\t\t}\n\t\t\tclient->host = strdup(openssl_last_ip);\n\t\t}\n\t\tif (db) fprintf(stderr, \"accept_openssl: client %p\\n\", (void *) client);\n\t\tif (db) fprintf(stderr, \"accept_openssl: new_client %p\\n\", (void *) screen->newClientHook);\n\t\tif (db) fprintf(stderr, \"accept_openssl: new_client %p\\n\", (void *) new_client);\n\t\tif (mode == OPENSSL_INETD) {\n\t\t\tinetd_client = client;\n\t\t\tclient->clientGoneHook = client_gone;\n\t\t}\n\t\tif (openssl_last_ip &&\n\t\t    strpbrk(openssl_last_ip, \"0123456789\") == openssl_last_ip) {\n\t\t\tclient->host = strdup(openssl_last_ip);\n\t\t}\n\t\tif (vencrypt_sel != 0) {\n\t\t\tclient->protocolMajorVersion = 3;\n\t\t\tclient->protocolMinorVersion = 8;\n#if LIBVNCSERVER_HAVE_LIBSSL || HAVE_LIBSSL \n\t\t\tif (!finish_vencrypt_auth(client, vencrypt_sel)) {\n\t\t\t\trfbCloseClient(client);\n\t\t\t\tclient = NULL;\n\t\t\t}\n#else\n\t\t\tbadnews(\"3 accept_openssl\");\n#endif\n\t\t} else if (anontls_sel != 0) {\n\t\t\tclient->protocolMajorVersion = 3;\n\t\t\tclient->protocolMinorVersion = 8;\n\t\t\trfbAuthNewClient(client);\n\t\t}\n\t\tif (use_threads && client != NULL) {\n\t\t\trfbStartOnHoldClient(client);\n\t\t}\n\t\t/* try to get RFB proto done now. */\n\t\tprogress_client();\n\t} else {\n\t\trfbLog(\"SSL: accept_openssl: rfbNewClient failed.\\n\");\n\t\tclose(vsock);\n\n\t\tkill(pid, SIGTERM);\n\t\twaitpid(pid, &status, WNOHANG); \n\t\tif (mode == OPENSSL_INETD || ssl_no_fail) {\n\t\t\tclean_up_exit(1);\n\t\t}\n\t\treturn;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "setsid",
          "args": [],
          "line": 720
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "system",
          "args": [
            "cmd"
          ],
          "line": 718
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "usleep",
          "args": [
            "100*1000"
          ],
          "line": 713
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "waitpid",
          "args": [
            "pid",
            "&status",
            "WNOHANG"
          ],
          "line": 709
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dnow",
          "args": [],
          "line": 708
        },
        "resolved": true,
        "details": {
          "function_name": "dnowx",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/util.c",
          "lines": "439-441",
          "snippet": "double dnowx(void) {\n\treturn dnow() - x11vnc_start;\n}",
          "includes": [
            "#include \"connections.h\"",
            "#include \"unixpw.h\"",
            "#include \"win_utils.h\"",
            "#include \"cleanup.h\"",
            "#include \"x11vnc.h\"",
            "#include <stdlib.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "double dnow(void);",
            "double dnowx(void);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"connections.h\"\n#include \"unixpw.h\"\n#include \"win_utils.h\"\n#include \"cleanup.h\"\n#include \"x11vnc.h\"\n#include <stdlib.h>\n\ndouble dnow(void);\ndouble dnowx(void);\n\ndouble dnowx(void) {\n\treturn dnow() - x11vnc_start;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fork",
          "args": [],
          "line": 703
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"running: %s\\n\"",
            "cmd"
          ],
          "line": 699
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "cmd",
            "\"%s -display %s -tsd '%s' -env TSD_RESTART=1 %s </dev/null 1>%s 2>&1 &\"",
            "program_name",
            "disp",
            "prop",
            "ipv6_listen ? \"-6\" : \"\"",
            "logfile ? logfile : \"/dev/null\""
          ],
          "line": 696
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "access",
          "args": [
            "xauth",
            "R_OK"
          ],
          "line": 692
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "xauth",
            "\"\""
          ],
          "line": 692
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getenv",
          "args": [
            "\"XAUTHORITY\""
          ],
          "line": 691
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getenv",
          "args": [
            "\"XAUTHORITY\""
          ],
          "line": 690
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "sz"
          ],
          "line": 688
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "\"-6\""
          ],
          "line": 685
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "logfile"
          ],
          "line": 682
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "\" &\""
          ],
          "line": 680
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "\"</dev/null 1>/dev/null 2>&1\""
          ],
          "line": 679
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "\"-env TSD_RESTART=1\""
          ],
          "line": 678
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "prop"
          ],
          "line": 677
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "\"-tsd\""
          ],
          "line": 676
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "disp"
          ],
          "line": 675
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "\"-display\""
          ],
          "line": 674
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "program_name"
          ],
          "line": 673
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"TS_REDIR_LIST Atom: %d = '%s'\\n\"",
            "(int) a",
            "prop"
          ],
          "line": 664
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_prop",
          "args": [
            "prop",
            "512",
            "a",
            "None"
          ],
          "line": 662
        },
        "resolved": true,
        "details": {
          "function_name": "get_prop",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/xevents.c",
          "lines": "448-494",
          "snippet": "void get_prop(char *str, int len, Atom prop, Window w) {\n\tint i;\n#if !NO_X11\n\tAtom type;\n\tint format, slen, dlen;\n\tunsigned long nitems = 0, bytes_after = 0;\n\tunsigned char* data = NULL;\n#endif\n\n\tfor (i=0; i<len; i++) {\n\t\tstr[i] = '\\0';\n\t}\n\tif (prop == None) {\n\t\treturn;\n\t}\n\n\tRAWFB_RET_VOID\n\n#if NO_X11\n\treturn;\n#else\n\n\tslen = 0;\n\tif (w == None) {\n\t\tw = DefaultRootWindow(dpy);\n\t}\n\n\tdo {\n\t\tif (XGetWindowProperty(dpy, w,\n\t\t    prop, nitems/4, len/16, False,\n\t\t    AnyPropertyType, &type, &format, &nitems, &bytes_after,\n\t\t    &data) == Success) {\n\n\t\t\tdlen = nitems * (format/8);\n\t\t\tif (slen + dlen > len) {\n\t\t\t\t/* too big */\n\t\t\t\tXFree_wr(data);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tmemcpy(str+slen, data, dlen);\n\t\t\tslen += dlen;\n\t\t\tstr[slen] = '\\0';\n\t\t\tXFree_wr(data);\n\t\t}\n\t} while (bytes_after > 0);\n#endif\t/* NO_X11 */\n}",
          "includes": [
            "#include <X11/extensions/scrnsaver.h>",
            "#include \"inet.h\"",
            "#include \"remote.h\"",
            "#include \"pointer.h\"",
            "#include \"pm.h\"",
            "#include \"screen.h\"",
            "#include \"macosx.h\"",
            "#include \"cleanup.h\"",
            "#include \"unixpw.h\"",
            "#include \"connections.h\"",
            "#include \"gui.h\"",
            "#include \"cursor.h\"",
            "#include \"keyboard.h\"",
            "#include \"selection.h\"",
            "#include \"xrecord.h\"",
            "#include \"xdamage.h\"",
            "#include \"xrandr.h\"",
            "#include \"xkb_bell.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void get_prop(char *str, int len, Atom prop, Window w);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <X11/extensions/scrnsaver.h>\n#include \"inet.h\"\n#include \"remote.h\"\n#include \"pointer.h\"\n#include \"pm.h\"\n#include \"screen.h\"\n#include \"macosx.h\"\n#include \"cleanup.h\"\n#include \"unixpw.h\"\n#include \"connections.h\"\n#include \"gui.h\"\n#include \"cursor.h\"\n#include \"keyboard.h\"\n#include \"selection.h\"\n#include \"xrecord.h\"\n#include \"xdamage.h\"\n#include \"xrandr.h\"\n#include \"xkb_bell.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nvoid get_prop(char *str, int len, Atom prop, Window w);\n\nvoid get_prop(char *str, int len, Atom prop, Window w) {\n\tint i;\n#if !NO_X11\n\tAtom type;\n\tint format, slen, dlen;\n\tunsigned long nitems = 0, bytes_after = 0;\n\tunsigned char* data = NULL;\n#endif\n\n\tfor (i=0; i<len; i++) {\n\t\tstr[i] = '\\0';\n\t}\n\tif (prop == None) {\n\t\treturn;\n\t}\n\n\tRAWFB_RET_VOID\n\n#if NO_X11\n\treturn;\n#else\n\n\tslen = 0;\n\tif (w == None) {\n\t\tw = DefaultRootWindow(dpy);\n\t}\n\n\tdo {\n\t\tif (XGetWindowProperty(dpy, w,\n\t\t    prop, nitems/4, len/16, False,\n\t\t    AnyPropertyType, &type, &format, &nitems, &bytes_after,\n\t\t    &data) == Success) {\n\n\t\t\tdlen = nitems * (format/8);\n\t\t\tif (slen + dlen > len) {\n\t\t\t\t/* too big */\n\t\t\t\tXFree_wr(data);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tmemcpy(str+slen, data, dlen);\n\t\t\tslen += dlen;\n\t\t\tstr[slen] = '\\0';\n\t\t\tXFree_wr(data);\n\t\t}\n\t} while (bytes_after > 0);\n#endif\t/* NO_X11 */\n}"
        }
      },
      {
        "call_info": {
          "callee": "XInternAtom",
          "args": [
            "dpy",
            "\"TS_REDIR_LIST\"",
            "False"
          ],
          "line": 660
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"do_tsd() in.\\n\""
          ],
          "line": 657
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getenv",
          "args": [
            "\"TS_REDIR_DEBUG\""
          ],
          "line": 654
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getenv",
          "args": [
            "\"TS_REDIR_LOGFILE\""
          ],
          "line": 651
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DisplayString",
          "args": [
            "dpy"
          ],
          "line": 650
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xi2_devices.h\"\n#include \"solid.h\"\n#include \"pm.h\"\n#include \"selection.h\"\n#include \"sslhelper.h\"\n#include \"sslcmds.h\"\n#include \"inet.h\"\n#include \"unixpw.h\"\n#include \"rates.h\"\n#include \"connections.h\"\n#include \"screen.h\"\n#include \"userinput.h\"\n#include \"cursor.h\"\n#include \"pointer.h\"\n#include \"keyboard.h\"\n#include \"cleanup.h\"\n#include \"user.h\"\n#include \"help.h\"\n#include \"gui.h\"\n#include \"scan.h\"\n#include \"remote.h\"\n#include \"win_utils.h\"\n#include \"xkb_bell.h\"\n#include \"xrandr.h\"\n#include \"xinerama.h\"\n#include \"xevents.h\"\n#include \"xrecord.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nvoid do_tsd(void) {\n#if !NO_X11\n\tAtom a;\n\tchar prop[513];\n\tpid_t pid;\n\tchar *cmd;\n\tint n, sz = 0;\n\tchar *disp = DisplayString(dpy);\n\tchar *logfile = getenv(\"TS_REDIR_LOGFILE\");\n\tint db = 0;\n\n\tif (getenv(\"TS_REDIR_DEBUG\")) {\n\t\tdb = 1;\n\t}\n\tif (db) fprintf(stderr, \"do_tsd() in.\\n\");\n\n\tprop[0] = '\\0';\n\ta = XInternAtom(dpy, \"TS_REDIR_LIST\", False);\n\tif (a != None) {\n\t\tget_prop(prop, 512, a, None);\n\t}\n\tif (db) fprintf(stderr, \"TS_REDIR_LIST Atom: %d = '%s'\\n\", (int) a, prop);\n\n\tif (prop[0] == '\\0') {\n\t\treturn;\n\t}\n\n\tif (! program_name) {\n\t\tprogram_name = \"x11vnc\";\n\t}\n\tsz += strlen(program_name) + 1;\n\tsz += strlen(\"-display\") + 1;\n\tsz += strlen(disp) + 1;\n\tsz += strlen(\"-tsd\") + 1;\n\tsz += 1 + strlen(prop) + 1 + 1;\n\tsz += strlen(\"-env TSD_RESTART=1\") + 1;\n\tsz += strlen(\"</dev/null 1>/dev/null 2>&1\") + 1;\n\tsz += strlen(\" &\") + 1;\n\tif (logfile) {\n\t\tsz += strlen(logfile);\n\t}\n\tif (ipv6_listen) {\n\t\tsz += strlen(\"-6\") + 1;\n\t}\n\n\tcmd = (char *) malloc(sz);\n\n\tif (getenv(\"XAUTHORITY\")) {\n\t\tchar *xauth = getenv(\"XAUTHORITY\");\n\t\tif (!strcmp(xauth, \"\") || access(xauth, R_OK) != 0) {\n\t\t\t*(xauth-2) = '_';\t/* yow */\n\t\t}\n\t}\n\tsprintf(cmd, \"%s -display %s -tsd '%s' -env TSD_RESTART=1 %s </dev/null 1>%s 2>&1 &\",\n\t    program_name, disp, prop, ipv6_listen ? \"-6\" : \"\",\n\t    logfile ? logfile : \"/dev/null\" ); \n\trfbLog(\"running: %s\\n\", cmd);\n\n#if LIBVNCSERVER_HAVE_FORK && HAVE_SETSID\n\t/* fork into the background now */\n\tif ((pid = fork()) > 0)  {\n\t\tpid_t pidw;\n\t\tint status;\n\t\tdouble s = dnow();\n\n\t\twhile (dnow() < s + 1.5) {\n\t\t\tpidw = waitpid(pid, &status, WNOHANG);\n\t\t\tif (pidw == pid) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tusleep(100*1000);\n\t\t}\n\t\treturn;\n\n\t} else if (pid == -1) {\n\t\tsystem(cmd);\n\t} else {\n\t\tsetsid();\n\t\t/* adjust our stdio */\n\t\tn = open(\"/dev/null\", O_RDONLY);\n\t\tdup2(n, 0);\n\t\tdup2(n, 1);\n\t\tdup2(n, 2);\n\t\tif (n > 2) {\n\t\t\tclose(n);\n\t\t}\n\t\tsystem(cmd);\n\t\texit(0);\n\t}\n#else\n\tsystem(cmd);\n#endif\n\n#endif\n}"
  },
  {
    "function_name": "terminal_services",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/x11vnc.c",
    "lines": "275-633",
    "snippet": "void terminal_services(char *list) {\n\tint i, j, n, db = 1;\n\tchar *p, *q, *r, *str;\n#if !NO_X11\n\tchar *tag[TSMAX];\n\tint listen[TSMAX], redir[TSMAX][TSSTK], socks[TSMAX], tstk[TSSTK];\n\tdouble rate_start;\n\tint rate_count;\n\tAtom at, atom[TSMAX];\n\tfd_set rd;\n\tWindow rwin;\n\tXErrorHandler   old_handler1;\n\tXIOErrorHandler old_handler2;\n\tchar num[32];\n\ttime_t last_clean = time(NULL);\n\n\tif (getenv(\"TS_REDIR_DEBUG\")) {\n\t\tdb = 2;\n\t}\n\n\tif (! dpy) {\n\t\treturn;\n\t}\n\n\trwin = RootWindow(dpy, DefaultScreen(dpy));\n\n\tat = XInternAtom(dpy, \"TS_REDIR_LIST\", False);\n\tif (at != None) {\n\t\tXChangeProperty(dpy, rwin, at, XA_STRING, 8,\n\t\t    PropModeReplace, (unsigned char *)list, strlen(list));\n\t\tXSync(dpy, False);\n\t}\n\tif (db) fprintf(stderr, \"TS_REDIR_LIST Atom: %d.\\n\", (int) at);\n\n\toh_restart_it_all:\n\n\tfor (i=0; i<TASKMAX; i++) {\n\t\tts_tasks[i] = 0;\n\t}\n\tfor (i=0; i<TSMAX; i++) {\n\t\tsocks[i] = -1;\n\t\tlisten[i] = -1;\n\t\tfor (j=0; j<TSSTK; j++) {\n\t\t\tredir[i][j] = 0;\n\t\t}\n\t}\n\n\trate_start = 0.0;\n\trate_count = 0;\n\n\tn = 0;\n\tstr = strdup(list);\n\tp = strtok(str, \",\");\n\twhile (p) {\n\t\tint m1, m2;\n\t\tif (db) fprintf(stderr, \"item: %s\\n\", p);\n\t\tq = strrchr(p, ':');\n\t\tif (!q) {\n\t\t\tp = strtok(NULL, \",\");\n\t\t\tcontinue;\n\t\t}\n\t\tr = strchr(p, ':');\n\t\tif (!r || r == q) {\n\t\t\tp = strtok(NULL, \",\");\n\t\t\tcontinue;\n\t\t}\n\n\t\tm1 = atoi(q+1);\n\t\t*q = '\\0';\n\t\tm2 = atoi(r+1);\n\t\t*r = '\\0';\n\n\t\tif (m1 <= 0 || m2 <= 0 || m1 >= 0xffff || m2 >= 0xffff) {\n\t\t\tp = strtok(NULL, \",\");\n\t\t\tcontinue;\n\t\t}\n\n\t\tredir[n][0] = m1;\n\t\tlisten[n] = m2;\n\t\ttag[n] = strdup(p);\n\n\t\tif (db) fprintf(stderr, \"     %d %d %s\\n\", redir[n][0], listen[n], tag[n]);\n\n\t\t*r = ':';\n\t\t*q = ':';\n\n\t\tn++;\n\t\tif (n >= TSMAX) {\n\t\t\tbreak;\n\t\t}\n\t\tp = strtok(NULL, \",\");\n\t}\n\tfree(str);\n\n\tif (n==0) {\n\t\treturn;\n\t}\n\n\tat = XInternAtom(dpy, \"TS_REDIR_PID\", False);\n\tif (at != None) {\n\t\tsprintf(num, \"%d\", getpid());\n\t\tXChangeProperty(dpy, rwin, at, XA_STRING, 8,\n\t\t    PropModeReplace, (unsigned char *)num, strlen(num));\n\t\tXSync(dpy, False);\n\t}\n\n\tfor (i=0; i<n; i++) {\n\t\tint k;\n\t\tatom[i] = XInternAtom(dpy, tag[i], False);\n\t\tif (db) fprintf(stderr, \"tag: %s atom: %d\\n\", tag[i], (int) atom[i]);\n\t\tif (atom[i] == None) {\n\t\t\tcontinue;\n\t\t}\n\t\tsprintf(num, \"%d\", redir[i][0]);\n\t\tif (db) fprintf(stderr, \"     listen: %d  redir: %s\\n\", listen[i], num);\n\t\tXChangeProperty(dpy, rwin, atom[i], XA_STRING, 8,\n\t\t    PropModeReplace, (unsigned char *)num, strlen(num));\n\t\tXSync(dpy, False);\n\n\t\tfor (k=1; k <= 5; k++) {\n\t\t\t/* XXX ::1 fallback? */\n\t\t\tsocks[i] = listen_tcp(listen[i], htonl(INADDR_LOOPBACK), 1);\n\t\t\tif (socks[i] >= 0) {\n\t\t\t\tif (db) fprintf(stderr, \"     listen succeeded: %d\\n\", listen[i]);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (db) fprintf(stderr, \"     listen failed***: %d\\n\", listen[i]);\n\t\t\tusleep(k * 2000*1000);\n\t\t}\n\t}\n\n\tif (getenv(\"TSD_RESTART\")) {\n\t\tif (!strcmp(getenv(\"TSD_RESTART\"), \"1\")) {\n\t\t\tset_redir_properties();\n\t\t}\n\t}\n\n\twhile (1) {\n\t\tstruct timeval tv;\n\t\tint nfd;\n\t\tint fmax = -1;\n\n\t\ttv.tv_sec  = 3;\n\t\ttv.tv_usec = 0;\n\n\t\tFD_ZERO(&rd);\n\t\tfor (i=0; i<n; i++) {\n\t\t\tif (socks[i] >= 0) {\n\t\t\t\tFD_SET(socks[i], &rd);\n\t\t\t\tif (socks[i] > fmax) {\n\t\t\t\t\tfmax = socks[i];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tnfd = select(fmax+1, &rd, NULL, NULL, &tv);\n\n\t\tif (db && 0) fprintf(stderr, \"nfd=%d\\n\", nfd);\n\t\tif (nfd < 0 && errno == EINTR) {\n\t\t\tXSync(dpy, True);\n\t\t\tcontinue;\n\t\t}\n\t\tif (nfd > 0) {\n\t\t\tint did_ts = 0;\n\t\t\tfor(i=0; i<n; i++) {\n\t\t\t\tint k = 0;\n\t\t\t\tfor (j = 0; j < TSSTK; j++) {\n\t\t\t\t\ttstk[j] = 0;\n\t\t\t\t}\n\t\t\t\tfor (j = 0; j < TSSTK; j++) {\n\t\t\t\t\tif (redir[i][j] != 0) {\n\t\t\t\t\t\ttstk[k++] = redir[i][j];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfor (j = 0; j < TSSTK; j++) {\n\t\t\t\t\tredir[i][j] = tstk[j];\nif (tstk[j] != 0) fprintf(stderr, \"B redir[%d][%d] = %d  %s\\n\", i, j, tstk[j], tag[i]);\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(i=0; i<n; i++) {\n\t\t\t\tint s = socks[i];\n\t\t\t\tif (s < 0) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (FD_ISSET(s, &rd)) {\n\t\t\t\t\tint p0, p, found = -1, jzero = -1;\n\t\t\t\t\tint conn = -1;\n\n\t\t\t\t\tget_prop(num, sizeof num, atom[i], None);\n\t\t\t\t\tp0 = atoi(num);\n\n\t\t\t\t\tfor (j = TSSTK-1; j >= 0; j--) {\n\t\t\t\t\t\tif (redir[i][j] == 0) {\n\t\t\t\t\t\t\tjzero = j;\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (p0 > 0 && p0 < 0xffff) {\n\t\t\t\t\t\t\tif (redir[i][j] == p0) {\n\t\t\t\t\t\t\t\tfound = j;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (jzero < 0) {\n\t\t\t\t\t\tjzero = TSSTK-1;\n\t\t\t\t\t}\n\t\t\t\t\tif (found < 0) {\n\t\t\t\t\t\tif (p0 > 0 && p0 < 0xffff) {\n\t\t\t\t\t\t\tredir[i][jzero] = p0;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tfor (j = TSSTK-1; j >= 0; j--) {\n\t\t\t\t\t\tint rc;\n\t\t\t\t\t\tp = redir[i][j];\n\t\t\t\t\t\tif (p <= 0 || p >= 0xffff) {\n\t\t\t\t\t\t\tredir[i][j] = 0;\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (dnow() > rate_start + 10.0) {\n\t\t\t\t\t\t\trate_start = dnow();\n\t\t\t\t\t\t\trate_count = 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t\trate_count++;\n\n\t\t\t\t\t\trc = tsdo(p, s, &conn);\n\t\t\t\t\t\tdid_ts++;\n\n\t\t\t\t\t\tif (rc == 0) {\n\t\t\t\t\t\t\t/* AOK */\n\t\t\t\t\t\t\tif (db) fprintf(stderr, \"tsdo[%d] OK: %d\\n\", i, p);\n\t\t\t\t\t\t\tif (p != p0) {\n\t\t\t\t\t\t\t\tsprintf(num, \"%d\", p);\n\t\t\t\t\t\t\t\tXChangeProperty(dpy, rwin, atom[i], XA_STRING, 8,\n\t\t\t\t\t\t\t\t    PropModeReplace, (unsigned char *)num, strlen(num));\n\t\t\t\t\t\t\t\tXSync(dpy, False);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t} else if (rc == 1) {\n\t\t\t\t\t\t\t/* accept failed */\n\t\t\t\t\t\t\tif (db) fprintf(stderr, \"tsdo[%d] accept failed: %d, sleep 50ms\\n\", i, p);\n\t\t\t\t\t\t\tusleep(50*1000);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t} else if (rc == 2) {\n\t\t\t\t\t\t\t/* connect failed */\n\t\t\t\t\t\t\tif (db) fprintf(stderr, \"tsdo[%d] connect failed: %d, sleep 50ms  rate: %d/10s\\n\", i, p, rate_count);\n\t\t\t\t\t\t\tredir[i][j] = 0;\n\t\t\t\t\t\t\tusleep(50*1000);\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t} else if (rc == 3) {\n\t\t\t\t\t\t\t/* fork failed */\n\t\t\t\t\t\t\tusleep(500*1000);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tfor (j = 0; j < TSSTK; j++) {\n\t\t\t\t\t\tif (redir[i][j] != 0) fprintf(stderr, \"A redir[%d][%d] = %d  %s\\n\", i, j, redir[i][j], tag[i]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (did_ts && rate_count > 100) {\n\t\t\t\tint db_netstat = 1;\n\t\t\t\tchar dcmd[100];\n\n\t\t\t\tif (no_external_cmds) {\n\t\t\t\t\tdb_netstat = 0;\n\t\t\t\t}\n\n\t\t\t\trfbLog(\"terminal_services: throttling high connect rate %d/10s\\n\", rate_count);\n\t\t\t\tusleep(2*1000*1000);\n\t\t\t\trfbLog(\"terminal_services: stopping ts services.\\n\");\n\t\t\t\tfor(i=0; i<n; i++) {\n\t\t\t\t\tint s = socks[i];\n\t\t\t\t\tif (s < 0) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\trfbLog(\"terminal_services: closing listen=%d sock=%d.\\n\", listen[i], socks[i]);\n\t\t\t\t\tif (listen[i] >= 0 && db_netstat) {\n\t\t\t\t\t\tsprintf(dcmd, \"netstat -an | grep -w '%d'\", listen[i]);\n\t\t\t\t\t\tfprintf(stderr, \"#1 %s\\n\", dcmd);\n\t\t\t\t\t\tsystem(dcmd);\n\t\t\t\t\t}\n\t\t\t\t\tclose(s);\n\t\t\t\t\tsocks[i] = -1;\n\t\t\t\t\tusleep(2*1000*1000);\n\t\t\t\t\tif (listen[i] >= 0 && db_netstat) {\n\t\t\t\t\t\tfprintf(stderr, \"#2 %s\\n\", dcmd);\n\t\t\t\t\t\tsystem(dcmd);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tusleep(10*1000*1000);\n\n\t\t\t\trfbLog(\"terminal_services: restarting ts services\\n\");\n\t\t\t\tgoto oh_restart_it_all;\n\t\t\t}\n\t\t}\n\t\tfor (i=0; i<TASKMAX; i++) {\n\t\t\tpid_t p = ts_tasks[i];\n\t\t\tif (p > 0) {\n\t\t\t\tint status;\n\t\t\t\tpid_t p2 = waitpid(p, &status, WNOHANG); \n\t\t\t\tif (p2 == p) {\n\t\t\t\t\tts_tasks[i] = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t/* this is to drop events and exit when X server is gone. */\n\t\told_handler1 = XSetErrorHandler(trap_xerror);\n\t\told_handler2 = XSetIOErrorHandler(trap_xioerror);\n\t\ttrapped_xerror = 0;\n\t\ttrapped_xioerror = 0;\n\n\t\tXSync(dpy, True);\n\n\t\tsprintf(num, \"%d\", (int) time(NULL));\n\t\tat = XInternAtom(dpy, \"TS_REDIR\", False);\n\t\tif (at != None) {\n\t\t\tXChangeProperty(dpy, rwin, at, XA_STRING, 8,\n\t\t\t    PropModeReplace, (unsigned char *)num, strlen(num));\n\t\t\tXSync(dpy, False);\n\t\t}\n\t\tif (time(NULL) > last_clean + 20 * 60) {\n\t\t\tint i, j;\n\t\t\tfor(i=0; i<n; i++) {\n\t\t\t\tint first = 1;\n\t\t\t\tfor (j = TSSTK-1; j >= 0; j--) {\n\t\t\t\t\tint s, p = redir[i][j];\n\t\t\t\t\tif (p <= 0 || p >= 0xffff) {\n\t\t\t\t\t\tredir[i][j] = 0;\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\ts = connect_tcp(\"127.0.0.1\", p);\n\t\t\t\t\tif (s < 0) {\n\t\t\t\t\t\tredir[i][j] = 0;\n\t\t\t\t\t\tif (db) fprintf(stderr, \"tsdo[%d][%d] clean: connect failed: %d\\n\", i, j, p);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tclose(s);\n\t\t\t\t\t\tif (first) {\n\t\t\t\t\t\t\tsprintf(num, \"%d\", p);\n\t\t\t\t\t\t\tXChangeProperty(dpy, rwin, atom[i], XA_STRING, 8,\n\t\t\t\t\t\t\t    PropModeReplace, (unsigned char *)num, strlen(num));\n\t\t\t\t\t\t\tXSync(dpy, False);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tfirst = 0;\n\t\t\t\t\t}\n\t\t\t\t\tusleep(500*1000);\n\t\t\t\t}\n\t\t\t}\n\t\t\tlast_clean = time(NULL);\n\t\t}\n\t\tif (trapped_xerror || trapped_xioerror) {\n\t\t\tif (db) fprintf(stderr, \"Xerror: %d/%d\\n\", trapped_xerror, trapped_xioerror);\n\t\t\texit(0);\n\t\t}\n\t\tXSetErrorHandler(old_handler1);\n\t\tXSetIOErrorHandler(old_handler2);\n\t}\n#endif\n}",
    "includes": [
      "#include \"xi2_devices.h\"",
      "#include \"solid.h\"",
      "#include \"pm.h\"",
      "#include \"selection.h\"",
      "#include \"sslhelper.h\"",
      "#include \"sslcmds.h\"",
      "#include \"inet.h\"",
      "#include \"unixpw.h\"",
      "#include \"rates.h\"",
      "#include \"connections.h\"",
      "#include \"screen.h\"",
      "#include \"userinput.h\"",
      "#include \"cursor.h\"",
      "#include \"pointer.h\"",
      "#include \"keyboard.h\"",
      "#include \"cleanup.h\"",
      "#include \"user.h\"",
      "#include \"help.h\"",
      "#include \"gui.h\"",
      "#include \"scan.h\"",
      "#include \"remote.h\"",
      "#include \"win_utils.h\"",
      "#include \"xkb_bell.h\"",
      "#include \"xrandr.h\"",
      "#include \"xinerama.h\"",
      "#include \"xevents.h\"",
      "#include \"xrecord.h\"",
      "#include \"xdamage.h\"",
      "#include \"xwrappers.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [
      "#define TSSTK 16",
      "#define TSMAX 32",
      "#define TASKMAX 32"
    ],
    "globals_used": [
      "static pid_t ts_tasks[TASKMAX];",
      "void set_redir_properties(void);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "XSetIOErrorHandler",
          "args": [
            "old_handler2"
          ],
          "line": 630
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XSetErrorHandler",
          "args": [
            "old_handler1"
          ],
          "line": 629
        },
        "resolved": true,
        "details": {
          "function_name": "XSetErrorHandler",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/nox11_funcs.h",
          "lines": "2819-2821",
          "snippet": "XErrorHandler XSetErrorHandler (XErrorHandler h) {\n\treturn h;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "XErrorHandler XSetErrorHandler (XErrorHandler h) {\n\treturn h;\n}"
        }
      },
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "0"
          ],
          "line": 627
        },
        "resolved": true,
        "details": {
          "function_name": "clean_up_exit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/cleanup.c",
          "lines": "151-266",
          "snippet": "void clean_up_exit(int ret) {\n\tstatic int depth = 0;\n\texit_flag = 1;\n\n\tif (depth++ > 2) {\n\t\texit(ret);\n\t}\n\n\tif (icon_mode) {\n\t\tclean_icon_mode();\n\t}\n\n\t/* remove the shm areas: */\n\tclean_shm(0);\n\n\tstop_stunnel();\n\tif (use_openssl) {\n\t\tssl_helper_pid(0, 0);\t/* killall */\n\t}\n\n\tif (ssh_pid > 0) {\n\t\tkill(ssh_pid, SIGTERM);\n\t\tssh_pid = 0;\n\t}\n\n#ifdef MACOSX\n\tif (client_connect_file) {\n\t\tif (strstr(client_connect_file, \"/tmp/x11vnc-macosx-remote\")\n\t\t    == client_connect_file) {\n\t\t\tunlink(client_connect_file);\n\t\t}\n\t}\n\tif (macosx_console) {\n\t\tmacosxCG_fini();\n\t}\n#endif\n\n\tif (pipeinput_fh != NULL) {\n\t\tpclose(pipeinput_fh);\n\t\tpipeinput_fh = NULL;\n\t}\n\n\tshutdown_uinput();\n\n\tif (unix_sock) {\n\t\tif (unix_sock_fd >= 0) {\n\t\t\trfbLog(\"deleting unix sock: %s\\n\", unix_sock);\n\t\t\tclose(unix_sock_fd);\n\t\t\tunix_sock_fd = -1;\n\t\t\tunlink(unix_sock);\n\t\t}\n\t}\n\n\tif (! dpy) {\t/* raw_rb hack */\n\t\tif (rm_flagfile) {\n\t\t\tunlink(rm_flagfile);\n\t\t\trm_flagfile = NULL;\n\t\t}\n\t\texit(ret);\n\t}\n\n\t/* X keyboard cleanups */\n\tdelete_added_keycodes(0);\n\n\t/* remove all created XInput2 devices */\n\tif(use_multipointer)\n\t    removeAllMDs(dpy);\n\n\tif (clear_mods == 1) {\n\t\tclear_modifiers(0);\n\t} else if (clear_mods == 2) {\n\t\tclear_keys();\n\t} else if (clear_mods == 3) {\n\t\tclear_keys();\n\t\tclear_locks();\n\t}\n\n\tif (no_autorepeat) {\n\t\tautorepeat(1, 0);\n\t}\n\tif (use_solid_bg) {\n\t\tsolid_bg(1);\n\t}\n\tif (ncache || ncache0) {\n\t\tkde_no_animate(1);\n\t}\n\tX_LOCK;\n\tXTestDiscard_wr(dpy);\n#if HAVE_LIBXDAMAGE\n\tif (xdamage) {\n\t\tXDamageDestroy(dpy, xdamage);\n\t}\n#endif\n#if HAVE_LIBXTRAP\n\tif (trap_ctx) {\n\t\tXEFreeTC(trap_ctx);\n\t}\n#endif\n\t/* XXX rdpy_ctrl, etc. cannot close w/o blocking */\n\tXCloseDisplay_wr(dpy);\n\tX_UNLOCK;\n\n\tfflush(stderr);\n\n\tif (rm_flagfile) {\n\t\tunlink(rm_flagfile);\n\t\trm_flagfile = NULL;\n\t}\n\n\tif (avahi) {\n\t\tavahi_cleanup();\n\t\tfflush(stderr);\n\t}\n\n\texit(ret);\n}",
          "includes": [
            "#include \"xi2_devices.h\"",
            "#include \"uinput.h\"",
            "#include \"xevents.h\"",
            "#include \"xrecord.h\"",
            "#include \"screen.h\"",
            "#include \"avahi.h\"",
            "#include \"macosxCG.h\"",
            "#include \"macosx.h\"",
            "#include \"connections.h\"",
            "#include \"sslhelper.h\"",
            "#include \"sslcmds.h\"",
            "#include \"unixpw.h\"",
            "#include \"solid.h\"",
            "#include \"gui.h\"",
            "#include \"scan.h\"",
            "#include \"keyboard.h\"",
            "#include \"remote.h\"",
            "#include \"xdamage.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void clean_up_exit(int ret);",
            "int known_sigpipe_mode(char *s);",
            "static int exit_flag = 0;",
            "static void clean_icon_mode(void);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xi2_devices.h\"\n#include \"uinput.h\"\n#include \"xevents.h\"\n#include \"xrecord.h\"\n#include \"screen.h\"\n#include \"avahi.h\"\n#include \"macosxCG.h\"\n#include \"macosx.h\"\n#include \"connections.h\"\n#include \"sslhelper.h\"\n#include \"sslcmds.h\"\n#include \"unixpw.h\"\n#include \"solid.h\"\n#include \"gui.h\"\n#include \"scan.h\"\n#include \"keyboard.h\"\n#include \"remote.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nvoid clean_up_exit(int ret);\nint known_sigpipe_mode(char *s);\nstatic int exit_flag = 0;\nstatic void clean_icon_mode(void);\n\nvoid clean_up_exit(int ret) {\n\tstatic int depth = 0;\n\texit_flag = 1;\n\n\tif (depth++ > 2) {\n\t\texit(ret);\n\t}\n\n\tif (icon_mode) {\n\t\tclean_icon_mode();\n\t}\n\n\t/* remove the shm areas: */\n\tclean_shm(0);\n\n\tstop_stunnel();\n\tif (use_openssl) {\n\t\tssl_helper_pid(0, 0);\t/* killall */\n\t}\n\n\tif (ssh_pid > 0) {\n\t\tkill(ssh_pid, SIGTERM);\n\t\tssh_pid = 0;\n\t}\n\n#ifdef MACOSX\n\tif (client_connect_file) {\n\t\tif (strstr(client_connect_file, \"/tmp/x11vnc-macosx-remote\")\n\t\t    == client_connect_file) {\n\t\t\tunlink(client_connect_file);\n\t\t}\n\t}\n\tif (macosx_console) {\n\t\tmacosxCG_fini();\n\t}\n#endif\n\n\tif (pipeinput_fh != NULL) {\n\t\tpclose(pipeinput_fh);\n\t\tpipeinput_fh = NULL;\n\t}\n\n\tshutdown_uinput();\n\n\tif (unix_sock) {\n\t\tif (unix_sock_fd >= 0) {\n\t\t\trfbLog(\"deleting unix sock: %s\\n\", unix_sock);\n\t\t\tclose(unix_sock_fd);\n\t\t\tunix_sock_fd = -1;\n\t\t\tunlink(unix_sock);\n\t\t}\n\t}\n\n\tif (! dpy) {\t/* raw_rb hack */\n\t\tif (rm_flagfile) {\n\t\t\tunlink(rm_flagfile);\n\t\t\trm_flagfile = NULL;\n\t\t}\n\t\texit(ret);\n\t}\n\n\t/* X keyboard cleanups */\n\tdelete_added_keycodes(0);\n\n\t/* remove all created XInput2 devices */\n\tif(use_multipointer)\n\t    removeAllMDs(dpy);\n\n\tif (clear_mods == 1) {\n\t\tclear_modifiers(0);\n\t} else if (clear_mods == 2) {\n\t\tclear_keys();\n\t} else if (clear_mods == 3) {\n\t\tclear_keys();\n\t\tclear_locks();\n\t}\n\n\tif (no_autorepeat) {\n\t\tautorepeat(1, 0);\n\t}\n\tif (use_solid_bg) {\n\t\tsolid_bg(1);\n\t}\n\tif (ncache || ncache0) {\n\t\tkde_no_animate(1);\n\t}\n\tX_LOCK;\n\tXTestDiscard_wr(dpy);\n#if HAVE_LIBXDAMAGE\n\tif (xdamage) {\n\t\tXDamageDestroy(dpy, xdamage);\n\t}\n#endif\n#if HAVE_LIBXTRAP\n\tif (trap_ctx) {\n\t\tXEFreeTC(trap_ctx);\n\t}\n#endif\n\t/* XXX rdpy_ctrl, etc. cannot close w/o blocking */\n\tXCloseDisplay_wr(dpy);\n\tX_UNLOCK;\n\n\tfflush(stderr);\n\n\tif (rm_flagfile) {\n\t\tunlink(rm_flagfile);\n\t\trm_flagfile = NULL;\n\t}\n\n\tif (avahi) {\n\t\tavahi_cleanup();\n\t\tfflush(stderr);\n\t}\n\n\texit(ret);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Xerror: %d/%d\\n\"",
            "trapped_xerror",
            "trapped_xioerror"
          ],
          "line": 626
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "time",
          "args": [
            "NULL"
          ],
          "line": 623
        },
        "resolved": true,
        "details": {
          "function_name": "tsdo_timeout",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/x11vnc.c",
          "lines": "180-183",
          "snippet": "static void tsdo_timeout (int sig) {\n\ttsdo_timeout_flag = 1;\n\tif (sig) {};\n}",
          "includes": [
            "#include \"xi2_devices.h\"",
            "#include \"solid.h\"",
            "#include \"pm.h\"",
            "#include \"selection.h\"",
            "#include \"sslhelper.h\"",
            "#include \"sslcmds.h\"",
            "#include \"inet.h\"",
            "#include \"unixpw.h\"",
            "#include \"rates.h\"",
            "#include \"connections.h\"",
            "#include \"screen.h\"",
            "#include \"userinput.h\"",
            "#include \"cursor.h\"",
            "#include \"pointer.h\"",
            "#include \"keyboard.h\"",
            "#include \"cleanup.h\"",
            "#include \"user.h\"",
            "#include \"help.h\"",
            "#include \"gui.h\"",
            "#include \"scan.h\"",
            "#include \"remote.h\"",
            "#include \"win_utils.h\"",
            "#include \"xkb_bell.h\"",
            "#include \"xrandr.h\"",
            "#include \"xinerama.h\"",
            "#include \"xevents.h\"",
            "#include \"xrecord.h\"",
            "#include \"xdamage.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int tsdo_timeout_flag;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xi2_devices.h\"\n#include \"solid.h\"\n#include \"pm.h\"\n#include \"selection.h\"\n#include \"sslhelper.h\"\n#include \"sslcmds.h\"\n#include \"inet.h\"\n#include \"unixpw.h\"\n#include \"rates.h\"\n#include \"connections.h\"\n#include \"screen.h\"\n#include \"userinput.h\"\n#include \"cursor.h\"\n#include \"pointer.h\"\n#include \"keyboard.h\"\n#include \"cleanup.h\"\n#include \"user.h\"\n#include \"help.h\"\n#include \"gui.h\"\n#include \"scan.h\"\n#include \"remote.h\"\n#include \"win_utils.h\"\n#include \"xkb_bell.h\"\n#include \"xrandr.h\"\n#include \"xinerama.h\"\n#include \"xevents.h\"\n#include \"xrecord.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nstatic int tsdo_timeout_flag;\n\nstatic void tsdo_timeout (int sig) {\n\ttsdo_timeout_flag = 1;\n\tif (sig) {};\n}"
        }
      },
      {
        "call_info": {
          "callee": "usleep",
          "args": [
            "500*1000"
          ],
          "line": 620
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XSync",
          "args": [
            "dpy",
            "False"
          ],
          "line": 616
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XChangeProperty",
          "args": [
            "dpy",
            "rwin",
            "atom[i]",
            "XA_STRING",
            "8",
            "PropModeReplace",
            "(unsigned char *)num",
            "strlen(num)"
          ],
          "line": 614
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "num"
          ],
          "line": 615
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "num",
            "\"%d\"",
            "p"
          ],
          "line": 613
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "close",
          "args": [
            "s"
          ],
          "line": 611
        },
        "resolved": true,
        "details": {
          "function_name": "close_alarm",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/unixpw.c",
          "lines": "666-672",
          "snippet": "static void close_alarm (int sig) {\n\tif (slave_fd >= 0) {\n\t\tclose(slave_fd);\n\t}\n\talarm_fired = 1;\n\tif (0) sig = 0;\t/* compiler warning */\n}",
          "includes": [
            "#include <sys/stropts.h>",
            "#include <termios.h>",
            "#include <sys/ioctl.h>",
            "#include <shadow.h>",
            "#include \"default8x16.h\"",
            "#include \"rates.h\"",
            "#include \"cursor.h\"",
            "#include \"sslhelper.h\"",
            "#include \"connections.h\"",
            "#include \"user.h\"",
            "#include \"connections.h\"",
            "#include \"xinerama.h\"",
            "#include \"cleanup.h\"",
            "#include \"scan.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int slave_fd = -1, alarm_fired = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/stropts.h>\n#include <termios.h>\n#include <sys/ioctl.h>\n#include <shadow.h>\n#include \"default8x16.h\"\n#include \"rates.h\"\n#include \"cursor.h\"\n#include \"sslhelper.h\"\n#include \"connections.h\"\n#include \"user.h\"\n#include \"connections.h\"\n#include \"xinerama.h\"\n#include \"cleanup.h\"\n#include \"scan.h\"\n#include \"x11vnc.h\"\n\nstatic int slave_fd = -1, alarm_fired = 0;\n\nstatic void close_alarm (int sig) {\n\tif (slave_fd >= 0) {\n\t\tclose(slave_fd);\n\t}\n\talarm_fired = 1;\n\tif (0) sig = 0;\t/* compiler warning */\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"tsdo[%d][%d] clean: connect failed: %d\\n\"",
            "i",
            "j",
            "p"
          ],
          "line": 609
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "connect_tcp",
          "args": [
            "\"127.0.0.1\"",
            "p"
          ],
          "line": 606
        },
        "resolved": true,
        "details": {
          "function_name": "connect_tcp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/inet.c",
          "lines": "716-893",
          "snippet": "int connect_tcp(char *host, int port) {\n\tdouble t0 = dnow();\n\tint fd = -1;\n\tint fail4 = noipv4;\n\tif (getenv(\"IPV4_FAILS\")) {\n\t\tfail4 = 2;\n\t}\n\n\trfbLog(\"connect_tcp: trying:   %s %d\\n\", host, port);\n\n\tif (fail4) {\n\t\tif (fail4 > 1) {\n\t\t\trfbLog(\"TESTING: IPV4_FAILS for connect_tcp.\\n\");\n\t\t}\n\t} else {\n\t\tfd = rfbConnectToTcpAddr(host, port);\n\t}\n\n\tif (fd >= 0) {\n\t\treturn fd;\n\t}\n\trfbLogPerror(\"connect_tcp: connection failed\");\n\n\tif (dnow() - t0 < 4.0) {\n\t\trfbLog(\"connect_tcp: re-trying %s %d\\n\", host, port);\n\t\tusleep (100 * 1000);\n\t\tif (!fail4) {\n\t\t\tfd = rfbConnectToTcpAddr(host, port);\n\t\t}\n\t\tif (fd < 0) {\n\t\t\trfbLogPerror(\"connect_tcp: connection failed\");\n\t\t}\n\t}\n\n\tif (fd < 0 && !noipv6) {\n#if X11VNC_IPV6\n\t\tint err;\n\t\tstruct addrinfo *ai;\n\t\tstruct addrinfo hints;\n\t\tchar service[32], *host2, *q;\n\n\t\trfbLog(\"connect_tcp: trying IPv6 %s %d\\n\", host, port);\n\n\t\tmemset(&hints, 0, sizeof(hints));\n\t\tsprintf(service, \"%d\", port);\n\n\t\thints.ai_family = AF_UNSPEC;\n\t\thints.ai_socktype = SOCK_STREAM;\n#ifdef AI_ADDRCONFIG\n\t\thints.ai_flags |= AI_ADDRCONFIG;\n#endif\n\t\tif(ipv6_ip(host)) {\n#ifdef AI_NUMERICHOST\n\t\t\trfbLog(\"connect_tcp[ipv6]: setting AI_NUMERICHOST for %s\\n\", host);\n\t\t\thints.ai_flags |= AI_NUMERICHOST;\n#endif\n\t\t}\n#ifdef AI_NUMERICSERV\n\t\thints.ai_flags |= AI_NUMERICSERV;\n#endif\n\n\t\tif (!strcmp(host, \"127.0.0.1\")) {\n\t\t\thost2 = strdup(\"::1\");\n\t\t} else if (host[0] == '[') {\n\t\t\thost2 = strdup(host+1);\n\t\t} else {\n\t\t\thost2 = strdup(host);\n\t\t}\n\t\tq = strrchr(host2, ']');\n\t\tif (q) {\n\t\t\t*q = '\\0';\n\t\t}\n\n\t\terr = getaddrinfo(host2, service, &hints, &ai);\n\t\tif (err != 0) {\n\t\t\trfbLog(\"connect_tcp[ipv6]: getaddrinfo[%d]: %s\\n\", err, gai_strerror(err));\n\t\t\tusleep(100 * 1000);\n\t\t\terr = getaddrinfo(host2, service, &hints, &ai);\n\t\t}\n\t\tfree(host2);\n\n\t\tif (err != 0) {\n\t\t\trfbLog(\"connect_tcp[ipv6]: getaddrinfo[%d]: %s\\n\", err, gai_strerror(err));\n\t\t} else {\n\t\t\tstruct addrinfo *ap = ai;\n\t\t\twhile (ap != NULL) {\n\t\t\t\tint sock;\n\n\t\t\t\tif (fail4) {\n\t\t\t\t\tstruct sockaddr_in6 *s6ptr;\n\t\t\t\t\tif (ap->ai_family != AF_INET6) {\n\t\t\t\t\t\trfbLog(\"connect_tcp[ipv6]: skipping AF_INET address under -noipv4\\n\");\n\t\t\t\t\t\tap = ap->ai_next;\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n#ifdef IN6_IS_ADDR_V4MAPPED\n\t\t\t\t\ts6ptr = (struct sockaddr_in6 *) ap->ai_addr;\n\t\t\t\t\tif (IN6_IS_ADDR_V4MAPPED(&(s6ptr->sin6_addr))) {\n\t\t\t\t\t\trfbLog(\"connect_tcp[ipv6]: skipping V4MAPPED address under -noipv4\\n\");\n\t\t\t\t\t\tap = ap->ai_next;\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n#endif\n\t\t\t\t}\n\n\t\t\t\tsock = socket(ap->ai_family, ap->ai_socktype, ap->ai_protocol);\n\n\t\t\t\tif (sock == -1) {\n\t\t\t\t\trfbLogPerror(\"connect_tcp[ipv6]: socket\");\n\t\t\t\t\tif (0) rfbLog(\"(Ignore the above error if this system is IPv4-only.)\\n\");\n\t\t\t\t} else {\n\t\t\t\t\tint res = -1, dmsg = 0;\n\t\t\t\t\tchar *s = ipv6_getipaddr(ap->ai_addr, ap->ai_addrlen);\n\t\t\t\t\tif (!s) s = strdup(\"unknown\");\n\n\t\t\t\t\trfbLog(\"connect_tcp[ipv6]: trying sock=%d fam=%d proto=%d using %s\\n\",\n\t\t\t\t\t    sock, ap->ai_family, ap->ai_protocol, s);\n\t\t\t\t\tres = connect(sock, ap->ai_addr, ap->ai_addrlen);\n#if defined(SOL_IPV6) && defined(IPV6_V6ONLY)\n\t\t\t\t\tif (res != 0) {\n\t\t\t\t\t\tint zero = 0;\n\t\t\t\t\t\trfbLogPerror(\"connect_tcp[ipv6]: connect\");\n\t\t\t\t\t\tdmsg = 1;\n\t\t\t\t\t\tif (setsockopt(sock, SOL_IPV6, IPV6_V6ONLY, (char *)&zero, sizeof(zero)) == 0) {\n\t\t\t\t\t\t\trfbLog(\"connect_tcp[ipv6]: trying again with IPV6_V6ONLY=0\\n\");\n\t\t\t\t\t\t\tres = connect(sock, ap->ai_addr, ap->ai_addrlen);\n\t\t\t\t\t\t\tdmsg = 0;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\trfbLogPerror(\"connect_tcp[ipv6]: setsockopt IPV6_V6ONLY\");\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n#endif\n\t\t\t\t\tif (res == 0) {\n\t\t\t\t\t\trfbLog(\"connect_tcp[ipv6]: connect OK\\n\");\n\t\t\t\t\t\tfd = sock;\n\t\t\t\t\t\tif (!ipv6_client_ip_str) {\n\t\t\t\t\t\t\tipv6_client_ip_str = strdup(s);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tfree(s);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif (!dmsg) rfbLogPerror(\"connect_tcp[ipv6]: connect\");\n\t\t\t\t\t\tclose(sock);\n\t\t\t\t\t}\n\t\t\t\t\tfree(s);\n\t\t\t\t}\n\t\t\t\tap = ap->ai_next;\n\t\t\t}\n\t\t\tfreeaddrinfo(ai);\n\t\t}\n#endif\n\t}\n\tif (fd < 0 && !fail4) {\n\t\t/* this is a kludge for IPv4-only machines getting v4mapped string. */\n\t\tchar *q, *host2;\n\t\tif (host[0] == '[') {\n\t\t\thost2 = strdup(host+1);\n\t\t} else {\n\t\t\thost2 = strdup(host);\n\t\t}\n\t\tq = strrchr(host2, ']');\n\t\tif (q) {\n\t\t\t*q = '\\0';\n\t\t}\n\t\tif (strstr(host2, \"::ffff:\") == host2 || strstr(host2, \"::FFFF:\") == host2) {\n\t\t\tchar *host3 = host2 + strlen(\"::ffff:\");\n\t\t\tif (dotted_ip(host3, 0)) {\n\t\t\t\trfbLog(\"connect_tcp[ipv4]: trying fallback to IPv4 for %s\\n\", host2);\n\t\t\t\tfd = rfbConnectToTcpAddr(host3, port);\n\t\t\t\tif (fd < 0) {\n\t\t\t\t\trfbLogPerror(\"connect_tcp[ipv4]: connection failed\");\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfree(host2);\n\t}\n\treturn fd;\n}",
          "includes": [
            "#include <sys/un.h>",
            "#include \"sslhelper.h\"",
            "#include \"unixpw.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "char *host2ip(char *host);",
            "int ipv6_ip(char *host);",
            "int get_remote_port(int sock);",
            "int get_local_port(int sock);",
            "char *get_remote_host(int sock);",
            "char *get_local_host(int sock);",
            "int listen6(int port);",
            "int accept_unix(int s);",
            "int connect_tcp(char *host, int port);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/un.h>\n#include \"sslhelper.h\"\n#include \"unixpw.h\"\n#include \"x11vnc.h\"\n\nchar *host2ip(char *host);\nint ipv6_ip(char *host);\nint get_remote_port(int sock);\nint get_local_port(int sock);\nchar *get_remote_host(int sock);\nchar *get_local_host(int sock);\nint listen6(int port);\nint accept_unix(int s);\nint connect_tcp(char *host, int port);\n\nint connect_tcp(char *host, int port) {\n\tdouble t0 = dnow();\n\tint fd = -1;\n\tint fail4 = noipv4;\n\tif (getenv(\"IPV4_FAILS\")) {\n\t\tfail4 = 2;\n\t}\n\n\trfbLog(\"connect_tcp: trying:   %s %d\\n\", host, port);\n\n\tif (fail4) {\n\t\tif (fail4 > 1) {\n\t\t\trfbLog(\"TESTING: IPV4_FAILS for connect_tcp.\\n\");\n\t\t}\n\t} else {\n\t\tfd = rfbConnectToTcpAddr(host, port);\n\t}\n\n\tif (fd >= 0) {\n\t\treturn fd;\n\t}\n\trfbLogPerror(\"connect_tcp: connection failed\");\n\n\tif (dnow() - t0 < 4.0) {\n\t\trfbLog(\"connect_tcp: re-trying %s %d\\n\", host, port);\n\t\tusleep (100 * 1000);\n\t\tif (!fail4) {\n\t\t\tfd = rfbConnectToTcpAddr(host, port);\n\t\t}\n\t\tif (fd < 0) {\n\t\t\trfbLogPerror(\"connect_tcp: connection failed\");\n\t\t}\n\t}\n\n\tif (fd < 0 && !noipv6) {\n#if X11VNC_IPV6\n\t\tint err;\n\t\tstruct addrinfo *ai;\n\t\tstruct addrinfo hints;\n\t\tchar service[32], *host2, *q;\n\n\t\trfbLog(\"connect_tcp: trying IPv6 %s %d\\n\", host, port);\n\n\t\tmemset(&hints, 0, sizeof(hints));\n\t\tsprintf(service, \"%d\", port);\n\n\t\thints.ai_family = AF_UNSPEC;\n\t\thints.ai_socktype = SOCK_STREAM;\n#ifdef AI_ADDRCONFIG\n\t\thints.ai_flags |= AI_ADDRCONFIG;\n#endif\n\t\tif(ipv6_ip(host)) {\n#ifdef AI_NUMERICHOST\n\t\t\trfbLog(\"connect_tcp[ipv6]: setting AI_NUMERICHOST for %s\\n\", host);\n\t\t\thints.ai_flags |= AI_NUMERICHOST;\n#endif\n\t\t}\n#ifdef AI_NUMERICSERV\n\t\thints.ai_flags |= AI_NUMERICSERV;\n#endif\n\n\t\tif (!strcmp(host, \"127.0.0.1\")) {\n\t\t\thost2 = strdup(\"::1\");\n\t\t} else if (host[0] == '[') {\n\t\t\thost2 = strdup(host+1);\n\t\t} else {\n\t\t\thost2 = strdup(host);\n\t\t}\n\t\tq = strrchr(host2, ']');\n\t\tif (q) {\n\t\t\t*q = '\\0';\n\t\t}\n\n\t\terr = getaddrinfo(host2, service, &hints, &ai);\n\t\tif (err != 0) {\n\t\t\trfbLog(\"connect_tcp[ipv6]: getaddrinfo[%d]: %s\\n\", err, gai_strerror(err));\n\t\t\tusleep(100 * 1000);\n\t\t\terr = getaddrinfo(host2, service, &hints, &ai);\n\t\t}\n\t\tfree(host2);\n\n\t\tif (err != 0) {\n\t\t\trfbLog(\"connect_tcp[ipv6]: getaddrinfo[%d]: %s\\n\", err, gai_strerror(err));\n\t\t} else {\n\t\t\tstruct addrinfo *ap = ai;\n\t\t\twhile (ap != NULL) {\n\t\t\t\tint sock;\n\n\t\t\t\tif (fail4) {\n\t\t\t\t\tstruct sockaddr_in6 *s6ptr;\n\t\t\t\t\tif (ap->ai_family != AF_INET6) {\n\t\t\t\t\t\trfbLog(\"connect_tcp[ipv6]: skipping AF_INET address under -noipv4\\n\");\n\t\t\t\t\t\tap = ap->ai_next;\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n#ifdef IN6_IS_ADDR_V4MAPPED\n\t\t\t\t\ts6ptr = (struct sockaddr_in6 *) ap->ai_addr;\n\t\t\t\t\tif (IN6_IS_ADDR_V4MAPPED(&(s6ptr->sin6_addr))) {\n\t\t\t\t\t\trfbLog(\"connect_tcp[ipv6]: skipping V4MAPPED address under -noipv4\\n\");\n\t\t\t\t\t\tap = ap->ai_next;\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n#endif\n\t\t\t\t}\n\n\t\t\t\tsock = socket(ap->ai_family, ap->ai_socktype, ap->ai_protocol);\n\n\t\t\t\tif (sock == -1) {\n\t\t\t\t\trfbLogPerror(\"connect_tcp[ipv6]: socket\");\n\t\t\t\t\tif (0) rfbLog(\"(Ignore the above error if this system is IPv4-only.)\\n\");\n\t\t\t\t} else {\n\t\t\t\t\tint res = -1, dmsg = 0;\n\t\t\t\t\tchar *s = ipv6_getipaddr(ap->ai_addr, ap->ai_addrlen);\n\t\t\t\t\tif (!s) s = strdup(\"unknown\");\n\n\t\t\t\t\trfbLog(\"connect_tcp[ipv6]: trying sock=%d fam=%d proto=%d using %s\\n\",\n\t\t\t\t\t    sock, ap->ai_family, ap->ai_protocol, s);\n\t\t\t\t\tres = connect(sock, ap->ai_addr, ap->ai_addrlen);\n#if defined(SOL_IPV6) && defined(IPV6_V6ONLY)\n\t\t\t\t\tif (res != 0) {\n\t\t\t\t\t\tint zero = 0;\n\t\t\t\t\t\trfbLogPerror(\"connect_tcp[ipv6]: connect\");\n\t\t\t\t\t\tdmsg = 1;\n\t\t\t\t\t\tif (setsockopt(sock, SOL_IPV6, IPV6_V6ONLY, (char *)&zero, sizeof(zero)) == 0) {\n\t\t\t\t\t\t\trfbLog(\"connect_tcp[ipv6]: trying again with IPV6_V6ONLY=0\\n\");\n\t\t\t\t\t\t\tres = connect(sock, ap->ai_addr, ap->ai_addrlen);\n\t\t\t\t\t\t\tdmsg = 0;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\trfbLogPerror(\"connect_tcp[ipv6]: setsockopt IPV6_V6ONLY\");\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n#endif\n\t\t\t\t\tif (res == 0) {\n\t\t\t\t\t\trfbLog(\"connect_tcp[ipv6]: connect OK\\n\");\n\t\t\t\t\t\tfd = sock;\n\t\t\t\t\t\tif (!ipv6_client_ip_str) {\n\t\t\t\t\t\t\tipv6_client_ip_str = strdup(s);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tfree(s);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif (!dmsg) rfbLogPerror(\"connect_tcp[ipv6]: connect\");\n\t\t\t\t\t\tclose(sock);\n\t\t\t\t\t}\n\t\t\t\t\tfree(s);\n\t\t\t\t}\n\t\t\t\tap = ap->ai_next;\n\t\t\t}\n\t\t\tfreeaddrinfo(ai);\n\t\t}\n#endif\n\t}\n\tif (fd < 0 && !fail4) {\n\t\t/* this is a kludge for IPv4-only machines getting v4mapped string. */\n\t\tchar *q, *host2;\n\t\tif (host[0] == '[') {\n\t\t\thost2 = strdup(host+1);\n\t\t} else {\n\t\t\thost2 = strdup(host);\n\t\t}\n\t\tq = strrchr(host2, ']');\n\t\tif (q) {\n\t\t\t*q = '\\0';\n\t\t}\n\t\tif (strstr(host2, \"::ffff:\") == host2 || strstr(host2, \"::FFFF:\") == host2) {\n\t\t\tchar *host3 = host2 + strlen(\"::ffff:\");\n\t\t\tif (dotted_ip(host3, 0)) {\n\t\t\t\trfbLog(\"connect_tcp[ipv4]: trying fallback to IPv4 for %s\\n\", host2);\n\t\t\t\tfd = rfbConnectToTcpAddr(host3, port);\n\t\t\t\tif (fd < 0) {\n\t\t\t\t\trfbLogPerror(\"connect_tcp[ipv4]: connection failed\");\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfree(host2);\n\t}\n\treturn fd;\n}"
        }
      },
      {
        "call_info": {
          "callee": "XSync",
          "args": [
            "dpy",
            "False"
          ],
          "line": 594
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XChangeProperty",
          "args": [
            "dpy",
            "rwin",
            "at",
            "XA_STRING",
            "8",
            "PropModeReplace",
            "(unsigned char *)num",
            "strlen(num)"
          ],
          "line": 592
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "num"
          ],
          "line": 593
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XInternAtom",
          "args": [
            "dpy",
            "\"TS_REDIR\"",
            "False"
          ],
          "line": 590
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "num",
            "\"%d\"",
            "(int) time(NULL)"
          ],
          "line": 589
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XSync",
          "args": [
            "dpy",
            "True"
          ],
          "line": 587
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XSetIOErrorHandler",
          "args": [
            "trap_xioerror"
          ],
          "line": 583
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "waitpid",
          "args": [
            "p",
            "&status",
            "WNOHANG"
          ],
          "line": 575
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"terminal_services: restarting ts services\\n\""
          ],
          "line": 567
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "usleep",
          "args": [
            "10*1000*1000"
          ],
          "line": 565
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "system",
          "args": [
            "dcmd"
          ],
          "line": 562
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"#2 %s\\n\"",
            "dcmd"
          ],
          "line": 561
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "usleep",
          "args": [
            "2*1000*1000"
          ],
          "line": 559
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "system",
          "args": [
            "dcmd"
          ],
          "line": 555
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"#1 %s\\n\"",
            "dcmd"
          ],
          "line": 554
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "dcmd",
            "\"netstat -an | grep -w '%d'\"",
            "listen[i]"
          ],
          "line": 553
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"terminal_services: closing listen=%d sock=%d.\\n\"",
            "listen[i]",
            "socks[i]"
          ],
          "line": 551
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"terminal_services: stopping ts services.\\n\""
          ],
          "line": 545
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "usleep",
          "args": [
            "2*1000*1000"
          ],
          "line": 544
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"terminal_services: throttling high connect rate %d/10s\\n\"",
            "rate_count"
          ],
          "line": 543
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"A redir[%d][%d] = %d  %s\\n\"",
            "i",
            "j",
            "redir[i][j]",
            "tag[i]"
          ],
          "line": 531
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "usleep",
          "args": [
            "500*1000"
          ],
          "line": 526
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "usleep",
          "args": [
            "50*1000"
          ],
          "line": 522
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"tsdo[%d] connect failed: %d, sleep 50ms  rate: %d/10s\\n\"",
            "i",
            "p",
            "rate_count"
          ],
          "line": 520
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "usleep",
          "args": [
            "50*1000"
          ],
          "line": 516
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"tsdo[%d] accept failed: %d, sleep 50ms\\n\"",
            "i",
            "p"
          ],
          "line": 515
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XSync",
          "args": [
            "dpy",
            "False"
          ],
          "line": 510
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XChangeProperty",
          "args": [
            "dpy",
            "rwin",
            "atom[i]",
            "XA_STRING",
            "8",
            "PropModeReplace",
            "(unsigned char *)num",
            "strlen(num)"
          ],
          "line": 508
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "num"
          ],
          "line": 509
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "num",
            "\"%d\"",
            "p"
          ],
          "line": 507
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"tsdo[%d] OK: %d\\n\"",
            "i",
            "p"
          ],
          "line": 505
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tsdo",
          "args": [
            "p",
            "s",
            "&conn"
          ],
          "line": 500
        },
        "resolved": true,
        "details": {
          "function_name": "tsdo",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/x11vnc.c",
          "lines": "189-268",
          "snippet": "int tsdo(int port, int lsock, int *conn) {\n\tint csock, rsock, i, db = 1;\n\tpid_t pid;\n\tstruct sockaddr_in addr;\n#ifdef __hpux\n\tint addrlen = sizeof(addr);\n#else\n\tsocklen_t addrlen = sizeof(addr);\n#endif\n\n\tif (*conn < 0) {\n\t\tsignal(SIGALRM, tsdo_timeout);\n\t\ttsdo_timeout_flag = 0;\n\n\t\talarm(10);\n\t\tcsock = accept(lsock, (struct sockaddr *)&addr, &addrlen);\n\t\talarm(0);\n\n\t\tif (db) rfbLog(\"tsdo: accept: lsock: %d, csock: %d, port: %d\\n\", lsock, csock, port);\n\n\t\tif (tsdo_timeout_flag > 0 || csock < 0) {\n\t\t\tclose(csock);\n\t\t\t*conn = -1;\n\t\t\treturn 1;\n\t\t}\n\t\t*conn = csock;\n\t} else {\n\t\tcsock = *conn;\n\t\tif (db) rfbLog(\"tsdo: using existing csock: %d, port: %d\\n\", csock, port);\n\t}\n\n\trsock = connect_tcp(\"127.0.0.1\", port);\n\tif (rsock < 0) {\n\t\tif (db) rfbLog(\"tsdo: connect_tcp(port=%d) failed.\\n\", port);\n\t\tclose(csock);\n\t\treturn 2;\n\t}\n\n\tpid = fork();\n\tif (pid < 0) {\n\t\tclose(csock);\n\t\tclose(rsock);\n\t\treturn 3;\n\t}\n\tif (pid > 0) {\n\t\tts_taskn = (ts_taskn+1) % TASKMAX;\n\t\tts_tasks[ts_taskn] = pid;\n\t\tclose(csock);\n\t\tclose(rsock);\n\t\t*conn = -1;\n\t\treturn 0;\n\t}\n\tif (pid == 0) {\n\t\tfor (i=0; i<255; i++) {\n\t\t\tif (i != csock && i != rsock && i != 2) {\n\t\t\t\tclose(i);\n\t\t\t}\n\t\t}\n#if HAVE_SETSID\n\t\tif (setsid() == -1) {\n\t\t\tperror(\"setsid\");\n\t\t\tclose(csock);\n\t\t\tclose(rsock);\n\t\t\texit(1);\n\t\t}\n#else\n\t\tif (setpgrp() == -1) {\n\t\t\tperror(\"setpgrp\");\n\t\t\tclose(csock);\n\t\t\tclose(rsock);\n\t\t\texit(1);\n\t\t}\n#endif\t/* SETSID */\n\t\traw_xfer(rsock, csock, csock);\n\t\tclose(csock);\n\t\tclose(rsock);\n\t\texit(0);\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"xi2_devices.h\"",
            "#include \"solid.h\"",
            "#include \"pm.h\"",
            "#include \"selection.h\"",
            "#include \"sslhelper.h\"",
            "#include \"sslcmds.h\"",
            "#include \"inet.h\"",
            "#include \"unixpw.h\"",
            "#include \"rates.h\"",
            "#include \"connections.h\"",
            "#include \"screen.h\"",
            "#include \"userinput.h\"",
            "#include \"cursor.h\"",
            "#include \"pointer.h\"",
            "#include \"keyboard.h\"",
            "#include \"cleanup.h\"",
            "#include \"user.h\"",
            "#include \"help.h\"",
            "#include \"gui.h\"",
            "#include \"scan.h\"",
            "#include \"remote.h\"",
            "#include \"win_utils.h\"",
            "#include \"xkb_bell.h\"",
            "#include \"xrandr.h\"",
            "#include \"xinerama.h\"",
            "#include \"xevents.h\"",
            "#include \"xrecord.h\"",
            "#include \"xdamage.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [
            "#define TASKMAX 32"
          ],
          "globals_used": [
            "static int tsdo_timeout_flag;",
            "static pid_t ts_tasks[TASKMAX];",
            "static int ts_taskn = -1;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xi2_devices.h\"\n#include \"solid.h\"\n#include \"pm.h\"\n#include \"selection.h\"\n#include \"sslhelper.h\"\n#include \"sslcmds.h\"\n#include \"inet.h\"\n#include \"unixpw.h\"\n#include \"rates.h\"\n#include \"connections.h\"\n#include \"screen.h\"\n#include \"userinput.h\"\n#include \"cursor.h\"\n#include \"pointer.h\"\n#include \"keyboard.h\"\n#include \"cleanup.h\"\n#include \"user.h\"\n#include \"help.h\"\n#include \"gui.h\"\n#include \"scan.h\"\n#include \"remote.h\"\n#include \"win_utils.h\"\n#include \"xkb_bell.h\"\n#include \"xrandr.h\"\n#include \"xinerama.h\"\n#include \"xevents.h\"\n#include \"xrecord.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\n#define TASKMAX 32\n\nstatic int tsdo_timeout_flag;\nstatic pid_t ts_tasks[TASKMAX];\nstatic int ts_taskn = -1;\n\nint tsdo(int port, int lsock, int *conn) {\n\tint csock, rsock, i, db = 1;\n\tpid_t pid;\n\tstruct sockaddr_in addr;\n#ifdef __hpux\n\tint addrlen = sizeof(addr);\n#else\n\tsocklen_t addrlen = sizeof(addr);\n#endif\n\n\tif (*conn < 0) {\n\t\tsignal(SIGALRM, tsdo_timeout);\n\t\ttsdo_timeout_flag = 0;\n\n\t\talarm(10);\n\t\tcsock = accept(lsock, (struct sockaddr *)&addr, &addrlen);\n\t\talarm(0);\n\n\t\tif (db) rfbLog(\"tsdo: accept: lsock: %d, csock: %d, port: %d\\n\", lsock, csock, port);\n\n\t\tif (tsdo_timeout_flag > 0 || csock < 0) {\n\t\t\tclose(csock);\n\t\t\t*conn = -1;\n\t\t\treturn 1;\n\t\t}\n\t\t*conn = csock;\n\t} else {\n\t\tcsock = *conn;\n\t\tif (db) rfbLog(\"tsdo: using existing csock: %d, port: %d\\n\", csock, port);\n\t}\n\n\trsock = connect_tcp(\"127.0.0.1\", port);\n\tif (rsock < 0) {\n\t\tif (db) rfbLog(\"tsdo: connect_tcp(port=%d) failed.\\n\", port);\n\t\tclose(csock);\n\t\treturn 2;\n\t}\n\n\tpid = fork();\n\tif (pid < 0) {\n\t\tclose(csock);\n\t\tclose(rsock);\n\t\treturn 3;\n\t}\n\tif (pid > 0) {\n\t\tts_taskn = (ts_taskn+1) % TASKMAX;\n\t\tts_tasks[ts_taskn] = pid;\n\t\tclose(csock);\n\t\tclose(rsock);\n\t\t*conn = -1;\n\t\treturn 0;\n\t}\n\tif (pid == 0) {\n\t\tfor (i=0; i<255; i++) {\n\t\t\tif (i != csock && i != rsock && i != 2) {\n\t\t\t\tclose(i);\n\t\t\t}\n\t\t}\n#if HAVE_SETSID\n\t\tif (setsid() == -1) {\n\t\t\tperror(\"setsid\");\n\t\t\tclose(csock);\n\t\t\tclose(rsock);\n\t\t\texit(1);\n\t\t}\n#else\n\t\tif (setpgrp() == -1) {\n\t\t\tperror(\"setpgrp\");\n\t\t\tclose(csock);\n\t\t\tclose(rsock);\n\t\t\texit(1);\n\t\t}\n#endif\t/* SETSID */\n\t\traw_xfer(rsock, csock, csock);\n\t\tclose(csock);\n\t\tclose(rsock);\n\t\texit(0);\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dnow",
          "args": [],
          "line": 495
        },
        "resolved": true,
        "details": {
          "function_name": "dnowx",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/util.c",
          "lines": "439-441",
          "snippet": "double dnowx(void) {\n\treturn dnow() - x11vnc_start;\n}",
          "includes": [
            "#include \"connections.h\"",
            "#include \"unixpw.h\"",
            "#include \"win_utils.h\"",
            "#include \"cleanup.h\"",
            "#include \"x11vnc.h\"",
            "#include <stdlib.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "double dnow(void);",
            "double dnowx(void);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"connections.h\"\n#include \"unixpw.h\"\n#include \"win_utils.h\"\n#include \"cleanup.h\"\n#include \"x11vnc.h\"\n#include <stdlib.h>\n\ndouble dnow(void);\ndouble dnowx(void);\n\ndouble dnowx(void) {\n\treturn dnow() - x11vnc_start;\n}"
        }
      },
      {
        "call_info": {
          "callee": "atoi",
          "args": [
            "num"
          ],
          "line": 464
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_prop",
          "args": [
            "num",
            "sizeof num",
            "atom[i]",
            "None"
          ],
          "line": 463
        },
        "resolved": true,
        "details": {
          "function_name": "get_prop",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/xevents.c",
          "lines": "448-494",
          "snippet": "void get_prop(char *str, int len, Atom prop, Window w) {\n\tint i;\n#if !NO_X11\n\tAtom type;\n\tint format, slen, dlen;\n\tunsigned long nitems = 0, bytes_after = 0;\n\tunsigned char* data = NULL;\n#endif\n\n\tfor (i=0; i<len; i++) {\n\t\tstr[i] = '\\0';\n\t}\n\tif (prop == None) {\n\t\treturn;\n\t}\n\n\tRAWFB_RET_VOID\n\n#if NO_X11\n\treturn;\n#else\n\n\tslen = 0;\n\tif (w == None) {\n\t\tw = DefaultRootWindow(dpy);\n\t}\n\n\tdo {\n\t\tif (XGetWindowProperty(dpy, w,\n\t\t    prop, nitems/4, len/16, False,\n\t\t    AnyPropertyType, &type, &format, &nitems, &bytes_after,\n\t\t    &data) == Success) {\n\n\t\t\tdlen = nitems * (format/8);\n\t\t\tif (slen + dlen > len) {\n\t\t\t\t/* too big */\n\t\t\t\tXFree_wr(data);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tmemcpy(str+slen, data, dlen);\n\t\t\tslen += dlen;\n\t\t\tstr[slen] = '\\0';\n\t\t\tXFree_wr(data);\n\t\t}\n\t} while (bytes_after > 0);\n#endif\t/* NO_X11 */\n}",
          "includes": [
            "#include <X11/extensions/scrnsaver.h>",
            "#include \"inet.h\"",
            "#include \"remote.h\"",
            "#include \"pointer.h\"",
            "#include \"pm.h\"",
            "#include \"screen.h\"",
            "#include \"macosx.h\"",
            "#include \"cleanup.h\"",
            "#include \"unixpw.h\"",
            "#include \"connections.h\"",
            "#include \"gui.h\"",
            "#include \"cursor.h\"",
            "#include \"keyboard.h\"",
            "#include \"selection.h\"",
            "#include \"xrecord.h\"",
            "#include \"xdamage.h\"",
            "#include \"xrandr.h\"",
            "#include \"xkb_bell.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void get_prop(char *str, int len, Atom prop, Window w);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <X11/extensions/scrnsaver.h>\n#include \"inet.h\"\n#include \"remote.h\"\n#include \"pointer.h\"\n#include \"pm.h\"\n#include \"screen.h\"\n#include \"macosx.h\"\n#include \"cleanup.h\"\n#include \"unixpw.h\"\n#include \"connections.h\"\n#include \"gui.h\"\n#include \"cursor.h\"\n#include \"keyboard.h\"\n#include \"selection.h\"\n#include \"xrecord.h\"\n#include \"xdamage.h\"\n#include \"xrandr.h\"\n#include \"xkb_bell.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nvoid get_prop(char *str, int len, Atom prop, Window w);\n\nvoid get_prop(char *str, int len, Atom prop, Window w) {\n\tint i;\n#if !NO_X11\n\tAtom type;\n\tint format, slen, dlen;\n\tunsigned long nitems = 0, bytes_after = 0;\n\tunsigned char* data = NULL;\n#endif\n\n\tfor (i=0; i<len; i++) {\n\t\tstr[i] = '\\0';\n\t}\n\tif (prop == None) {\n\t\treturn;\n\t}\n\n\tRAWFB_RET_VOID\n\n#if NO_X11\n\treturn;\n#else\n\n\tslen = 0;\n\tif (w == None) {\n\t\tw = DefaultRootWindow(dpy);\n\t}\n\n\tdo {\n\t\tif (XGetWindowProperty(dpy, w,\n\t\t    prop, nitems/4, len/16, False,\n\t\t    AnyPropertyType, &type, &format, &nitems, &bytes_after,\n\t\t    &data) == Success) {\n\n\t\t\tdlen = nitems * (format/8);\n\t\t\tif (slen + dlen > len) {\n\t\t\t\t/* too big */\n\t\t\t\tXFree_wr(data);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tmemcpy(str+slen, data, dlen);\n\t\t\tslen += dlen;\n\t\t\tstr[slen] = '\\0';\n\t\t\tXFree_wr(data);\n\t\t}\n\t} while (bytes_after > 0);\n#endif\t/* NO_X11 */\n}"
        }
      },
      {
        "call_info": {
          "callee": "FD_ISSET",
          "args": [
            "s",
            "&rd"
          ],
          "line": 459
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"B redir[%d][%d] = %d  %s\\n\"",
            "i",
            "j",
            "tstk[j]",
            "tag[i]"
          ],
          "line": 451
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XSync",
          "args": [
            "dpy",
            "True"
          ],
          "line": 434
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"nfd=%d\\n\"",
            "nfd"
          ],
          "line": 432
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "select",
          "args": [
            "fmax+1",
            "&rd",
            "NULL",
            "NULL",
            "&tv"
          ],
          "line": 430
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FD_SET",
          "args": [
            "socks[i]",
            "&rd"
          ],
          "line": 423
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FD_ZERO",
          "args": [
            "&rd"
          ],
          "line": 420
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_redir_properties",
          "args": [],
          "line": 408
        },
        "resolved": true,
        "details": {
          "function_name": "set_redir_properties",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/x11vnc.c",
          "lines": "739-776",
          "snippet": "void set_redir_properties(void) {\n#if !NO_X11\n\tchar *e, *f, *t;\n\tAtom a;\n\tchar num[32];\n\tint i, p;\n\n\tif (! dpy) {\n\t\treturn;\n\t}\n\n\ti = 0;\n\twhile (ts_services[i][0] != NULL) {\n\t\tf = ts_services[i][0]; \n\t\tt = ts_services[i][1]; \n\t\te = getenv(f);\n\t\tif (!e || strstr(e, \"DAEMON-\") != e) {\n\t\t\ti++;\n\t\t\tcontinue;\n\t\t}\n\t\tp = atoi(e + strlen(\"DAEMON-\"));\n\t\tif (p <= 0) {\n\t\t\ti++;\n\t\t\tcontinue;\n\t\t}\n\t\tsprintf(num, \"%d\", p);\n\t\ta = XInternAtom(dpy, t, False);\n\t\tif (a != None) {\n\t\t\tWindow rwin = RootWindow(dpy, DefaultScreen(dpy));\nfprintf(stderr, \"Set: %s %s %s -> %s\\n\", f, t, e, num);\n\t\t\tXChangeProperty(dpy, rwin, a, XA_STRING, 8,\n\t\t\t    PropModeReplace, (unsigned char *) num, strlen(num));\n\t\t\tXSync(dpy, False);\n\t\t}\n\t\ti++;\n\t}\n#endif\n}",
          "includes": [
            "#include \"xi2_devices.h\"",
            "#include \"solid.h\"",
            "#include \"pm.h\"",
            "#include \"selection.h\"",
            "#include \"sslhelper.h\"",
            "#include \"sslcmds.h\"",
            "#include \"inet.h\"",
            "#include \"unixpw.h\"",
            "#include \"rates.h\"",
            "#include \"connections.h\"",
            "#include \"screen.h\"",
            "#include \"userinput.h\"",
            "#include \"cursor.h\"",
            "#include \"pointer.h\"",
            "#include \"keyboard.h\"",
            "#include \"cleanup.h\"",
            "#include \"user.h\"",
            "#include \"help.h\"",
            "#include \"gui.h\"",
            "#include \"scan.h\"",
            "#include \"remote.h\"",
            "#include \"win_utils.h\"",
            "#include \"xkb_bell.h\"",
            "#include \"xrandr.h\"",
            "#include \"xinerama.h\"",
            "#include \"xevents.h\"",
            "#include \"xrecord.h\"",
            "#include \"xdamage.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void set_redir_properties(void);",
            "char *ts_services[][2] = {\n\t{\"FD_CUPS\", \"TS_CUPS_REDIR\"},\n\t{\"FD_SMB\",  \"TS_SMB_REDIR\"},\n\t{\"FD_ESD\",  \"TS_ESD_REDIR\"},\n\t{\"FD_NAS\",  \"TS_NAS_REDIR\"},\n\t{NULL, NULL}\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xi2_devices.h\"\n#include \"solid.h\"\n#include \"pm.h\"\n#include \"selection.h\"\n#include \"sslhelper.h\"\n#include \"sslcmds.h\"\n#include \"inet.h\"\n#include \"unixpw.h\"\n#include \"rates.h\"\n#include \"connections.h\"\n#include \"screen.h\"\n#include \"userinput.h\"\n#include \"cursor.h\"\n#include \"pointer.h\"\n#include \"keyboard.h\"\n#include \"cleanup.h\"\n#include \"user.h\"\n#include \"help.h\"\n#include \"gui.h\"\n#include \"scan.h\"\n#include \"remote.h\"\n#include \"win_utils.h\"\n#include \"xkb_bell.h\"\n#include \"xrandr.h\"\n#include \"xinerama.h\"\n#include \"xevents.h\"\n#include \"xrecord.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nvoid set_redir_properties(void);\nchar *ts_services[][2] = {\n\t{\"FD_CUPS\", \"TS_CUPS_REDIR\"},\n\t{\"FD_SMB\",  \"TS_SMB_REDIR\"},\n\t{\"FD_ESD\",  \"TS_ESD_REDIR\"},\n\t{\"FD_NAS\",  \"TS_NAS_REDIR\"},\n\t{NULL, NULL}\n};\n\nvoid set_redir_properties(void) {\n#if !NO_X11\n\tchar *e, *f, *t;\n\tAtom a;\n\tchar num[32];\n\tint i, p;\n\n\tif (! dpy) {\n\t\treturn;\n\t}\n\n\ti = 0;\n\twhile (ts_services[i][0] != NULL) {\n\t\tf = ts_services[i][0]; \n\t\tt = ts_services[i][1]; \n\t\te = getenv(f);\n\t\tif (!e || strstr(e, \"DAEMON-\") != e) {\n\t\t\ti++;\n\t\t\tcontinue;\n\t\t}\n\t\tp = atoi(e + strlen(\"DAEMON-\"));\n\t\tif (p <= 0) {\n\t\t\ti++;\n\t\t\tcontinue;\n\t\t}\n\t\tsprintf(num, \"%d\", p);\n\t\ta = XInternAtom(dpy, t, False);\n\t\tif (a != None) {\n\t\t\tWindow rwin = RootWindow(dpy, DefaultScreen(dpy));\nfprintf(stderr, \"Set: %s %s %s -> %s\\n\", f, t, e, num);\n\t\t\tXChangeProperty(dpy, rwin, a, XA_STRING, 8,\n\t\t\t    PropModeReplace, (unsigned char *) num, strlen(num));\n\t\t\tXSync(dpy, False);\n\t\t}\n\t\ti++;\n\t}\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "getenv(\"TSD_RESTART\")",
            "\"1\""
          ],
          "line": 407
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getenv",
          "args": [
            "\"TSD_RESTART\""
          ],
          "line": 407
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getenv",
          "args": [
            "\"TSD_RESTART\""
          ],
          "line": 406
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "usleep",
          "args": [
            "k * 2000*1000"
          ],
          "line": 402
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"     listen failed***: %d\\n\"",
            "listen[i]"
          ],
          "line": 401
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"     listen succeeded: %d\\n\"",
            "listen[i]"
          ],
          "line": 398
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "listen_tcp",
          "args": [
            "listen[i]",
            "htonl(INADDR_LOOPBACK)",
            "1"
          ],
          "line": 396
        },
        "resolved": true,
        "details": {
          "function_name": "listen_tcp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/inet.c",
          "lines": "895-938",
          "snippet": "int listen_tcp(int port, in_addr_t iface, int try6) {\n\tint fd = -1;\n\tint fail4 = noipv4;\n\tif (getenv(\"IPV4_FAILS\")) {\n\t\tfail4 = 2;\n\t}\n\n\tif (port <= 0 || 65535 < port) {\n\t\t/* for us, invalid port means do not listen. */\n\t\treturn -1;\n\t}\n\n\tif (fail4) {\n\t\tif (fail4 > 1) {\n\t\t\trfbLog(\"TESTING: IPV4_FAILS for listen_tcp: port=%d try6=%d\\n\", port, try6);\n\t\t}\n\t} else {\n\t\tfd = rfbListenOnTCPPort(port, iface);\n\t}\n\n\tif (fd >= 0) {\n\t\treturn fd;\n\t}\n\tif (fail4 > 1) {\n\t\trfbLogPerror(\"listen_tcp: listen failed\");\n\t}\n\n\tif (fd < 0 && try6 && ipv6_listen && !noipv6) {\n#if X11VNC_IPV6\n\t\tchar *save = listen_str6;\n\t\tif (iface == htonl(INADDR_LOOPBACK)) {\n\t\t\tlisten_str6 = \"localhost\";\n\t\t\trfbLog(\"listen_tcp: retrying on IPv6 in6addr_loopback ...\\n\");\n\t\t\tfd = listen6(port);\n\t\t} else if (iface == htonl(INADDR_ANY)) {\n\t\t\tlisten_str6 = NULL;\n\t\t\trfbLog(\"listen_tcp: retrying on IPv6 in6addr_any ...\\n\");\n\t\t\tfd = listen6(port);\n\t\t}\n\t\tlisten_str6 = save;\n#endif\n\t}\n\treturn fd;\n}",
          "includes": [
            "#include <sys/un.h>",
            "#include \"sslhelper.h\"",
            "#include \"unixpw.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int listen6(int port);",
            "int connect_tcp(char *host, int port);",
            "int listen_tcp(int port, in_addr_t iface, int try6);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/un.h>\n#include \"sslhelper.h\"\n#include \"unixpw.h\"\n#include \"x11vnc.h\"\n\nint listen6(int port);\nint connect_tcp(char *host, int port);\nint listen_tcp(int port, in_addr_t iface, int try6);\n\nint listen_tcp(int port, in_addr_t iface, int try6) {\n\tint fd = -1;\n\tint fail4 = noipv4;\n\tif (getenv(\"IPV4_FAILS\")) {\n\t\tfail4 = 2;\n\t}\n\n\tif (port <= 0 || 65535 < port) {\n\t\t/* for us, invalid port means do not listen. */\n\t\treturn -1;\n\t}\n\n\tif (fail4) {\n\t\tif (fail4 > 1) {\n\t\t\trfbLog(\"TESTING: IPV4_FAILS for listen_tcp: port=%d try6=%d\\n\", port, try6);\n\t\t}\n\t} else {\n\t\tfd = rfbListenOnTCPPort(port, iface);\n\t}\n\n\tif (fd >= 0) {\n\t\treturn fd;\n\t}\n\tif (fail4 > 1) {\n\t\trfbLogPerror(\"listen_tcp: listen failed\");\n\t}\n\n\tif (fd < 0 && try6 && ipv6_listen && !noipv6) {\n#if X11VNC_IPV6\n\t\tchar *save = listen_str6;\n\t\tif (iface == htonl(INADDR_LOOPBACK)) {\n\t\t\tlisten_str6 = \"localhost\";\n\t\t\trfbLog(\"listen_tcp: retrying on IPv6 in6addr_loopback ...\\n\");\n\t\t\tfd = listen6(port);\n\t\t} else if (iface == htonl(INADDR_ANY)) {\n\t\t\tlisten_str6 = NULL;\n\t\t\trfbLog(\"listen_tcp: retrying on IPv6 in6addr_any ...\\n\");\n\t\t\tfd = listen6(port);\n\t\t}\n\t\tlisten_str6 = save;\n#endif\n\t}\n\treturn fd;\n}"
        }
      },
      {
        "call_info": {
          "callee": "htonl",
          "args": [
            "INADDR_LOOPBACK"
          ],
          "line": 396
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XSync",
          "args": [
            "dpy",
            "False"
          ],
          "line": 392
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XChangeProperty",
          "args": [
            "dpy",
            "rwin",
            "atom[i]",
            "XA_STRING",
            "8",
            "PropModeReplace",
            "(unsigned char *)num",
            "strlen(num)"
          ],
          "line": 390
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "num"
          ],
          "line": 391
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"     listen: %d  redir: %s\\n\"",
            "listen[i]",
            "num"
          ],
          "line": 389
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "num",
            "\"%d\"",
            "redir[i][0]"
          ],
          "line": 388
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"tag: %s atom: %d\\n\"",
            "tag[i]",
            "(int) atom[i]"
          ],
          "line": 384
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XInternAtom",
          "args": [
            "dpy",
            "tag[i]",
            "False"
          ],
          "line": 383
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XSync",
          "args": [
            "dpy",
            "False"
          ],
          "line": 378
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XChangeProperty",
          "args": [
            "dpy",
            "rwin",
            "at",
            "XA_STRING",
            "8",
            "PropModeReplace",
            "(unsigned char *)num",
            "strlen(num)"
          ],
          "line": 376
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "num"
          ],
          "line": 377
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "num",
            "\"%d\"",
            "getpid()"
          ],
          "line": 375
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getpid",
          "args": [],
          "line": 375
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XInternAtom",
          "args": [
            "dpy",
            "\"TS_REDIR_PID\"",
            "False"
          ],
          "line": 373
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "str"
          ],
          "line": 367
        },
        "resolved": true,
        "details": {
          "function_name": "free_rect",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/userinput.c",
          "lines": "6200-6247",
          "snippet": "int free_rect(int idx) {\n\tint n, ok = 0;\n\tsraRegionPtr r1, r2;\n\tint x, y, w, h;\n\n\tif (idx < 0 || idx >= cache_list_num) {\nif (0) fprintf(stderr, \"free_rect: bad index: %d\\n\", idx);\n\t\tclean_up_exit(1);\n\t}\n\n\tx = cache_list[idx].bs_x;\n\ty = cache_list[idx].bs_y;\n\tw = cache_list[idx].bs_w;\n\th = cache_list[idx].bs_h;\n\n\tif (x < 0) {\n\t\tCLEAR(idx);\nif (dnow() > last_client + 5 && ncdb) fprintf(stderr, \"free_rect: already bs_x invalidated: %d bs_x: %d\\n\", idx, x);\n\t\treturn 1;\n\t}\n\n\tr2 = sraRgnCreateRect(x, y, x+w, y+h);\n\n\tn = get_bs_n(y);\n\tif (n >= 0) {\n\t\tr1 = rect_reg[n];\n\t\tsraRgnOr(r1, r2);\n\t\tok = 1;\n\t}\n\n\tif (zero_rects) {\n\t\tsraRgnOr(zero_rects, r2);\n\t\tx = cache_list[idx].su_x;\n\t\ty = cache_list[idx].su_y;\n\t\tw = cache_list[idx].su_w;\n\t\th = cache_list[idx].su_h;\n\t\tif (x >= 0) {\n\t\t\tsraRgnDestroy(r2);\n\t\t\tr2 = sraRgnCreateRect(x, y, x+w, y+h);\n\t\t\tsraRgnOr(zero_rects, r2);\n\t\t}\n\t}\n\tsraRgnDestroy(r2);\n\n\tCLEAR(idx);\nif (! ok && ncdb) fprintf(stderr, \"**** free_rect: not-found %d\\n\", idx);\n\treturn ok;\n}",
          "includes": [
            "#include \"default8x16.h\"",
            "#include \"connections.h\"",
            "#include \"screen.h\"",
            "#include \"cursor.h\"",
            "#include \"macosxCGS.h\"",
            "#include \"macosx.h\"",
            "#include \"unixpw.h\"",
            "#include \"8to24.h\"",
            "#include \"xrandr.h\"",
            "#include \"solid.h\"",
            "#include \"keyboard.h\"",
            "#include \"rates.h\"",
            "#include \"pointer.h\"",
            "#include \"cleanup.h\"",
            "#include \"scan.h\"",
            "#include \"user.h\"",
            "#include \"xevents.h\"",
            "#include \"win_utils.h\"",
            "#include \"xinerama.h\"",
            "#include \"xrecord.h\"",
            "#include \"xdamage.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void mark_for_xdamage(int x, int y, int w, int h);",
            "void set_xdamage_mark(int x, int y, int w, int h);",
            "int find_rect(int idx, int x, int y, int w, int h);",
            "winattr_t *cache_list;",
            "int clipped(int idx);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"default8x16.h\"\n#include \"connections.h\"\n#include \"screen.h\"\n#include \"cursor.h\"\n#include \"macosxCGS.h\"\n#include \"macosx.h\"\n#include \"unixpw.h\"\n#include \"8to24.h\"\n#include \"xrandr.h\"\n#include \"solid.h\"\n#include \"keyboard.h\"\n#include \"rates.h\"\n#include \"pointer.h\"\n#include \"cleanup.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"xevents.h\"\n#include \"win_utils.h\"\n#include \"xinerama.h\"\n#include \"xrecord.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nvoid mark_for_xdamage(int x, int y, int w, int h);\nvoid set_xdamage_mark(int x, int y, int w, int h);\nint find_rect(int idx, int x, int y, int w, int h);\nwinattr_t *cache_list;\nint clipped(int idx);\n\nint free_rect(int idx) {\n\tint n, ok = 0;\n\tsraRegionPtr r1, r2;\n\tint x, y, w, h;\n\n\tif (idx < 0 || idx >= cache_list_num) {\nif (0) fprintf(stderr, \"free_rect: bad index: %d\\n\", idx);\n\t\tclean_up_exit(1);\n\t}\n\n\tx = cache_list[idx].bs_x;\n\ty = cache_list[idx].bs_y;\n\tw = cache_list[idx].bs_w;\n\th = cache_list[idx].bs_h;\n\n\tif (x < 0) {\n\t\tCLEAR(idx);\nif (dnow() > last_client + 5 && ncdb) fprintf(stderr, \"free_rect: already bs_x invalidated: %d bs_x: %d\\n\", idx, x);\n\t\treturn 1;\n\t}\n\n\tr2 = sraRgnCreateRect(x, y, x+w, y+h);\n\n\tn = get_bs_n(y);\n\tif (n >= 0) {\n\t\tr1 = rect_reg[n];\n\t\tsraRgnOr(r1, r2);\n\t\tok = 1;\n\t}\n\n\tif (zero_rects) {\n\t\tsraRgnOr(zero_rects, r2);\n\t\tx = cache_list[idx].su_x;\n\t\ty = cache_list[idx].su_y;\n\t\tw = cache_list[idx].su_w;\n\t\th = cache_list[idx].su_h;\n\t\tif (x >= 0) {\n\t\t\tsraRgnDestroy(r2);\n\t\t\tr2 = sraRgnCreateRect(x, y, x+w, y+h);\n\t\t\tsraRgnOr(zero_rects, r2);\n\t\t}\n\t}\n\tsraRgnDestroy(r2);\n\n\tCLEAR(idx);\nif (! ok && ncdb) fprintf(stderr, \"**** free_rect: not-found %d\\n\", idx);\n\treturn ok;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strtok",
          "args": [
            "NULL",
            "\",\""
          ],
          "line": 365
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"     %d %d %s\\n\"",
            "redir[n][0]",
            "listen[n]",
            "tag[n]"
          ],
          "line": 356
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "p"
          ],
          "line": 354
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strtok",
          "args": [
            "NULL",
            "\",\""
          ],
          "line": 348
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atoi",
          "args": [
            "r+1"
          ],
          "line": 344
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atoi",
          "args": [
            "q+1"
          ],
          "line": 342
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strtok",
          "args": [
            "NULL",
            "\",\""
          ],
          "line": 338
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "p",
            "':'"
          ],
          "line": 336
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strtok",
          "args": [
            "NULL",
            "\",\""
          ],
          "line": 333
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strrchr",
          "args": [
            "p",
            "':'"
          ],
          "line": 331
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"item: %s\\n\"",
            "p"
          ],
          "line": 330
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strtok",
          "args": [
            "str",
            "\",\""
          ],
          "line": 327
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "list"
          ],
          "line": 326
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"TS_REDIR_LIST Atom: %d.\\n\"",
            "(int) at"
          ],
          "line": 307
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XSync",
          "args": [
            "dpy",
            "False"
          ],
          "line": 305
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XChangeProperty",
          "args": [
            "dpy",
            "rwin",
            "at",
            "XA_STRING",
            "8",
            "PropModeReplace",
            "(unsigned char *)list",
            "strlen(list)"
          ],
          "line": 303
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "list"
          ],
          "line": 304
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XInternAtom",
          "args": [
            "dpy",
            "\"TS_REDIR_LIST\"",
            "False"
          ],
          "line": 301
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RootWindow",
          "args": [
            "dpy",
            "DefaultScreen(dpy)"
          ],
          "line": 299
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DefaultScreen",
          "args": [
            "dpy"
          ],
          "line": 299
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getenv",
          "args": [
            "\"TS_REDIR_DEBUG\""
          ],
          "line": 291
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xi2_devices.h\"\n#include \"solid.h\"\n#include \"pm.h\"\n#include \"selection.h\"\n#include \"sslhelper.h\"\n#include \"sslcmds.h\"\n#include \"inet.h\"\n#include \"unixpw.h\"\n#include \"rates.h\"\n#include \"connections.h\"\n#include \"screen.h\"\n#include \"userinput.h\"\n#include \"cursor.h\"\n#include \"pointer.h\"\n#include \"keyboard.h\"\n#include \"cleanup.h\"\n#include \"user.h\"\n#include \"help.h\"\n#include \"gui.h\"\n#include \"scan.h\"\n#include \"remote.h\"\n#include \"win_utils.h\"\n#include \"xkb_bell.h\"\n#include \"xrandr.h\"\n#include \"xinerama.h\"\n#include \"xevents.h\"\n#include \"xrecord.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\n#define TSSTK 16\n#define TSMAX 32\n#define TASKMAX 32\n\nstatic pid_t ts_tasks[TASKMAX];\nvoid set_redir_properties(void);\n\nvoid terminal_services(char *list) {\n\tint i, j, n, db = 1;\n\tchar *p, *q, *r, *str;\n#if !NO_X11\n\tchar *tag[TSMAX];\n\tint listen[TSMAX], redir[TSMAX][TSSTK], socks[TSMAX], tstk[TSSTK];\n\tdouble rate_start;\n\tint rate_count;\n\tAtom at, atom[TSMAX];\n\tfd_set rd;\n\tWindow rwin;\n\tXErrorHandler   old_handler1;\n\tXIOErrorHandler old_handler2;\n\tchar num[32];\n\ttime_t last_clean = time(NULL);\n\n\tif (getenv(\"TS_REDIR_DEBUG\")) {\n\t\tdb = 2;\n\t}\n\n\tif (! dpy) {\n\t\treturn;\n\t}\n\n\trwin = RootWindow(dpy, DefaultScreen(dpy));\n\n\tat = XInternAtom(dpy, \"TS_REDIR_LIST\", False);\n\tif (at != None) {\n\t\tXChangeProperty(dpy, rwin, at, XA_STRING, 8,\n\t\t    PropModeReplace, (unsigned char *)list, strlen(list));\n\t\tXSync(dpy, False);\n\t}\n\tif (db) fprintf(stderr, \"TS_REDIR_LIST Atom: %d.\\n\", (int) at);\n\n\toh_restart_it_all:\n\n\tfor (i=0; i<TASKMAX; i++) {\n\t\tts_tasks[i] = 0;\n\t}\n\tfor (i=0; i<TSMAX; i++) {\n\t\tsocks[i] = -1;\n\t\tlisten[i] = -1;\n\t\tfor (j=0; j<TSSTK; j++) {\n\t\t\tredir[i][j] = 0;\n\t\t}\n\t}\n\n\trate_start = 0.0;\n\trate_count = 0;\n\n\tn = 0;\n\tstr = strdup(list);\n\tp = strtok(str, \",\");\n\twhile (p) {\n\t\tint m1, m2;\n\t\tif (db) fprintf(stderr, \"item: %s\\n\", p);\n\t\tq = strrchr(p, ':');\n\t\tif (!q) {\n\t\t\tp = strtok(NULL, \",\");\n\t\t\tcontinue;\n\t\t}\n\t\tr = strchr(p, ':');\n\t\tif (!r || r == q) {\n\t\t\tp = strtok(NULL, \",\");\n\t\t\tcontinue;\n\t\t}\n\n\t\tm1 = atoi(q+1);\n\t\t*q = '\\0';\n\t\tm2 = atoi(r+1);\n\t\t*r = '\\0';\n\n\t\tif (m1 <= 0 || m2 <= 0 || m1 >= 0xffff || m2 >= 0xffff) {\n\t\t\tp = strtok(NULL, \",\");\n\t\t\tcontinue;\n\t\t}\n\n\t\tredir[n][0] = m1;\n\t\tlisten[n] = m2;\n\t\ttag[n] = strdup(p);\n\n\t\tif (db) fprintf(stderr, \"     %d %d %s\\n\", redir[n][0], listen[n], tag[n]);\n\n\t\t*r = ':';\n\t\t*q = ':';\n\n\t\tn++;\n\t\tif (n >= TSMAX) {\n\t\t\tbreak;\n\t\t}\n\t\tp = strtok(NULL, \",\");\n\t}\n\tfree(str);\n\n\tif (n==0) {\n\t\treturn;\n\t}\n\n\tat = XInternAtom(dpy, \"TS_REDIR_PID\", False);\n\tif (at != None) {\n\t\tsprintf(num, \"%d\", getpid());\n\t\tXChangeProperty(dpy, rwin, at, XA_STRING, 8,\n\t\t    PropModeReplace, (unsigned char *)num, strlen(num));\n\t\tXSync(dpy, False);\n\t}\n\n\tfor (i=0; i<n; i++) {\n\t\tint k;\n\t\tatom[i] = XInternAtom(dpy, tag[i], False);\n\t\tif (db) fprintf(stderr, \"tag: %s atom: %d\\n\", tag[i], (int) atom[i]);\n\t\tif (atom[i] == None) {\n\t\t\tcontinue;\n\t\t}\n\t\tsprintf(num, \"%d\", redir[i][0]);\n\t\tif (db) fprintf(stderr, \"     listen: %d  redir: %s\\n\", listen[i], num);\n\t\tXChangeProperty(dpy, rwin, atom[i], XA_STRING, 8,\n\t\t    PropModeReplace, (unsigned char *)num, strlen(num));\n\t\tXSync(dpy, False);\n\n\t\tfor (k=1; k <= 5; k++) {\n\t\t\t/* XXX ::1 fallback? */\n\t\t\tsocks[i] = listen_tcp(listen[i], htonl(INADDR_LOOPBACK), 1);\n\t\t\tif (socks[i] >= 0) {\n\t\t\t\tif (db) fprintf(stderr, \"     listen succeeded: %d\\n\", listen[i]);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (db) fprintf(stderr, \"     listen failed***: %d\\n\", listen[i]);\n\t\t\tusleep(k * 2000*1000);\n\t\t}\n\t}\n\n\tif (getenv(\"TSD_RESTART\")) {\n\t\tif (!strcmp(getenv(\"TSD_RESTART\"), \"1\")) {\n\t\t\tset_redir_properties();\n\t\t}\n\t}\n\n\twhile (1) {\n\t\tstruct timeval tv;\n\t\tint nfd;\n\t\tint fmax = -1;\n\n\t\ttv.tv_sec  = 3;\n\t\ttv.tv_usec = 0;\n\n\t\tFD_ZERO(&rd);\n\t\tfor (i=0; i<n; i++) {\n\t\t\tif (socks[i] >= 0) {\n\t\t\t\tFD_SET(socks[i], &rd);\n\t\t\t\tif (socks[i] > fmax) {\n\t\t\t\t\tfmax = socks[i];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tnfd = select(fmax+1, &rd, NULL, NULL, &tv);\n\n\t\tif (db && 0) fprintf(stderr, \"nfd=%d\\n\", nfd);\n\t\tif (nfd < 0 && errno == EINTR) {\n\t\t\tXSync(dpy, True);\n\t\t\tcontinue;\n\t\t}\n\t\tif (nfd > 0) {\n\t\t\tint did_ts = 0;\n\t\t\tfor(i=0; i<n; i++) {\n\t\t\t\tint k = 0;\n\t\t\t\tfor (j = 0; j < TSSTK; j++) {\n\t\t\t\t\ttstk[j] = 0;\n\t\t\t\t}\n\t\t\t\tfor (j = 0; j < TSSTK; j++) {\n\t\t\t\t\tif (redir[i][j] != 0) {\n\t\t\t\t\t\ttstk[k++] = redir[i][j];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfor (j = 0; j < TSSTK; j++) {\n\t\t\t\t\tredir[i][j] = tstk[j];\nif (tstk[j] != 0) fprintf(stderr, \"B redir[%d][%d] = %d  %s\\n\", i, j, tstk[j], tag[i]);\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(i=0; i<n; i++) {\n\t\t\t\tint s = socks[i];\n\t\t\t\tif (s < 0) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (FD_ISSET(s, &rd)) {\n\t\t\t\t\tint p0, p, found = -1, jzero = -1;\n\t\t\t\t\tint conn = -1;\n\n\t\t\t\t\tget_prop(num, sizeof num, atom[i], None);\n\t\t\t\t\tp0 = atoi(num);\n\n\t\t\t\t\tfor (j = TSSTK-1; j >= 0; j--) {\n\t\t\t\t\t\tif (redir[i][j] == 0) {\n\t\t\t\t\t\t\tjzero = j;\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (p0 > 0 && p0 < 0xffff) {\n\t\t\t\t\t\t\tif (redir[i][j] == p0) {\n\t\t\t\t\t\t\t\tfound = j;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (jzero < 0) {\n\t\t\t\t\t\tjzero = TSSTK-1;\n\t\t\t\t\t}\n\t\t\t\t\tif (found < 0) {\n\t\t\t\t\t\tif (p0 > 0 && p0 < 0xffff) {\n\t\t\t\t\t\t\tredir[i][jzero] = p0;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tfor (j = TSSTK-1; j >= 0; j--) {\n\t\t\t\t\t\tint rc;\n\t\t\t\t\t\tp = redir[i][j];\n\t\t\t\t\t\tif (p <= 0 || p >= 0xffff) {\n\t\t\t\t\t\t\tredir[i][j] = 0;\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (dnow() > rate_start + 10.0) {\n\t\t\t\t\t\t\trate_start = dnow();\n\t\t\t\t\t\t\trate_count = 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t\trate_count++;\n\n\t\t\t\t\t\trc = tsdo(p, s, &conn);\n\t\t\t\t\t\tdid_ts++;\n\n\t\t\t\t\t\tif (rc == 0) {\n\t\t\t\t\t\t\t/* AOK */\n\t\t\t\t\t\t\tif (db) fprintf(stderr, \"tsdo[%d] OK: %d\\n\", i, p);\n\t\t\t\t\t\t\tif (p != p0) {\n\t\t\t\t\t\t\t\tsprintf(num, \"%d\", p);\n\t\t\t\t\t\t\t\tXChangeProperty(dpy, rwin, atom[i], XA_STRING, 8,\n\t\t\t\t\t\t\t\t    PropModeReplace, (unsigned char *)num, strlen(num));\n\t\t\t\t\t\t\t\tXSync(dpy, False);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t} else if (rc == 1) {\n\t\t\t\t\t\t\t/* accept failed */\n\t\t\t\t\t\t\tif (db) fprintf(stderr, \"tsdo[%d] accept failed: %d, sleep 50ms\\n\", i, p);\n\t\t\t\t\t\t\tusleep(50*1000);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t} else if (rc == 2) {\n\t\t\t\t\t\t\t/* connect failed */\n\t\t\t\t\t\t\tif (db) fprintf(stderr, \"tsdo[%d] connect failed: %d, sleep 50ms  rate: %d/10s\\n\", i, p, rate_count);\n\t\t\t\t\t\t\tredir[i][j] = 0;\n\t\t\t\t\t\t\tusleep(50*1000);\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t} else if (rc == 3) {\n\t\t\t\t\t\t\t/* fork failed */\n\t\t\t\t\t\t\tusleep(500*1000);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tfor (j = 0; j < TSSTK; j++) {\n\t\t\t\t\t\tif (redir[i][j] != 0) fprintf(stderr, \"A redir[%d][%d] = %d  %s\\n\", i, j, redir[i][j], tag[i]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (did_ts && rate_count > 100) {\n\t\t\t\tint db_netstat = 1;\n\t\t\t\tchar dcmd[100];\n\n\t\t\t\tif (no_external_cmds) {\n\t\t\t\t\tdb_netstat = 0;\n\t\t\t\t}\n\n\t\t\t\trfbLog(\"terminal_services: throttling high connect rate %d/10s\\n\", rate_count);\n\t\t\t\tusleep(2*1000*1000);\n\t\t\t\trfbLog(\"terminal_services: stopping ts services.\\n\");\n\t\t\t\tfor(i=0; i<n; i++) {\n\t\t\t\t\tint s = socks[i];\n\t\t\t\t\tif (s < 0) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\trfbLog(\"terminal_services: closing listen=%d sock=%d.\\n\", listen[i], socks[i]);\n\t\t\t\t\tif (listen[i] >= 0 && db_netstat) {\n\t\t\t\t\t\tsprintf(dcmd, \"netstat -an | grep -w '%d'\", listen[i]);\n\t\t\t\t\t\tfprintf(stderr, \"#1 %s\\n\", dcmd);\n\t\t\t\t\t\tsystem(dcmd);\n\t\t\t\t\t}\n\t\t\t\t\tclose(s);\n\t\t\t\t\tsocks[i] = -1;\n\t\t\t\t\tusleep(2*1000*1000);\n\t\t\t\t\tif (listen[i] >= 0 && db_netstat) {\n\t\t\t\t\t\tfprintf(stderr, \"#2 %s\\n\", dcmd);\n\t\t\t\t\t\tsystem(dcmd);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tusleep(10*1000*1000);\n\n\t\t\t\trfbLog(\"terminal_services: restarting ts services\\n\");\n\t\t\t\tgoto oh_restart_it_all;\n\t\t\t}\n\t\t}\n\t\tfor (i=0; i<TASKMAX; i++) {\n\t\t\tpid_t p = ts_tasks[i];\n\t\t\tif (p > 0) {\n\t\t\t\tint status;\n\t\t\t\tpid_t p2 = waitpid(p, &status, WNOHANG); \n\t\t\t\tif (p2 == p) {\n\t\t\t\t\tts_tasks[i] = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t/* this is to drop events and exit when X server is gone. */\n\t\told_handler1 = XSetErrorHandler(trap_xerror);\n\t\told_handler2 = XSetIOErrorHandler(trap_xioerror);\n\t\ttrapped_xerror = 0;\n\t\ttrapped_xioerror = 0;\n\n\t\tXSync(dpy, True);\n\n\t\tsprintf(num, \"%d\", (int) time(NULL));\n\t\tat = XInternAtom(dpy, \"TS_REDIR\", False);\n\t\tif (at != None) {\n\t\t\tXChangeProperty(dpy, rwin, at, XA_STRING, 8,\n\t\t\t    PropModeReplace, (unsigned char *)num, strlen(num));\n\t\t\tXSync(dpy, False);\n\t\t}\n\t\tif (time(NULL) > last_clean + 20 * 60) {\n\t\t\tint i, j;\n\t\t\tfor(i=0; i<n; i++) {\n\t\t\t\tint first = 1;\n\t\t\t\tfor (j = TSSTK-1; j >= 0; j--) {\n\t\t\t\t\tint s, p = redir[i][j];\n\t\t\t\t\tif (p <= 0 || p >= 0xffff) {\n\t\t\t\t\t\tredir[i][j] = 0;\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\ts = connect_tcp(\"127.0.0.1\", p);\n\t\t\t\t\tif (s < 0) {\n\t\t\t\t\t\tredir[i][j] = 0;\n\t\t\t\t\t\tif (db) fprintf(stderr, \"tsdo[%d][%d] clean: connect failed: %d\\n\", i, j, p);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tclose(s);\n\t\t\t\t\t\tif (first) {\n\t\t\t\t\t\t\tsprintf(num, \"%d\", p);\n\t\t\t\t\t\t\tXChangeProperty(dpy, rwin, atom[i], XA_STRING, 8,\n\t\t\t\t\t\t\t    PropModeReplace, (unsigned char *)num, strlen(num));\n\t\t\t\t\t\t\tXSync(dpy, False);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tfirst = 0;\n\t\t\t\t\t}\n\t\t\t\t\tusleep(500*1000);\n\t\t\t\t}\n\t\t\t}\n\t\t\tlast_clean = time(NULL);\n\t\t}\n\t\tif (trapped_xerror || trapped_xioerror) {\n\t\t\tif (db) fprintf(stderr, \"Xerror: %d/%d\\n\", trapped_xerror, trapped_xioerror);\n\t\t\texit(0);\n\t\t}\n\t\tXSetErrorHandler(old_handler1);\n\t\tXSetIOErrorHandler(old_handler2);\n\t}\n#endif\n}"
  },
  {
    "function_name": "tsdo",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/x11vnc.c",
    "lines": "189-268",
    "snippet": "int tsdo(int port, int lsock, int *conn) {\n\tint csock, rsock, i, db = 1;\n\tpid_t pid;\n\tstruct sockaddr_in addr;\n#ifdef __hpux\n\tint addrlen = sizeof(addr);\n#else\n\tsocklen_t addrlen = sizeof(addr);\n#endif\n\n\tif (*conn < 0) {\n\t\tsignal(SIGALRM, tsdo_timeout);\n\t\ttsdo_timeout_flag = 0;\n\n\t\talarm(10);\n\t\tcsock = accept(lsock, (struct sockaddr *)&addr, &addrlen);\n\t\talarm(0);\n\n\t\tif (db) rfbLog(\"tsdo: accept: lsock: %d, csock: %d, port: %d\\n\", lsock, csock, port);\n\n\t\tif (tsdo_timeout_flag > 0 || csock < 0) {\n\t\t\tclose(csock);\n\t\t\t*conn = -1;\n\t\t\treturn 1;\n\t\t}\n\t\t*conn = csock;\n\t} else {\n\t\tcsock = *conn;\n\t\tif (db) rfbLog(\"tsdo: using existing csock: %d, port: %d\\n\", csock, port);\n\t}\n\n\trsock = connect_tcp(\"127.0.0.1\", port);\n\tif (rsock < 0) {\n\t\tif (db) rfbLog(\"tsdo: connect_tcp(port=%d) failed.\\n\", port);\n\t\tclose(csock);\n\t\treturn 2;\n\t}\n\n\tpid = fork();\n\tif (pid < 0) {\n\t\tclose(csock);\n\t\tclose(rsock);\n\t\treturn 3;\n\t}\n\tif (pid > 0) {\n\t\tts_taskn = (ts_taskn+1) % TASKMAX;\n\t\tts_tasks[ts_taskn] = pid;\n\t\tclose(csock);\n\t\tclose(rsock);\n\t\t*conn = -1;\n\t\treturn 0;\n\t}\n\tif (pid == 0) {\n\t\tfor (i=0; i<255; i++) {\n\t\t\tif (i != csock && i != rsock && i != 2) {\n\t\t\t\tclose(i);\n\t\t\t}\n\t\t}\n#if HAVE_SETSID\n\t\tif (setsid() == -1) {\n\t\t\tperror(\"setsid\");\n\t\t\tclose(csock);\n\t\t\tclose(rsock);\n\t\t\texit(1);\n\t\t}\n#else\n\t\tif (setpgrp() == -1) {\n\t\t\tperror(\"setpgrp\");\n\t\t\tclose(csock);\n\t\t\tclose(rsock);\n\t\t\texit(1);\n\t\t}\n#endif\t/* SETSID */\n\t\traw_xfer(rsock, csock, csock);\n\t\tclose(csock);\n\t\tclose(rsock);\n\t\texit(0);\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include \"xi2_devices.h\"",
      "#include \"solid.h\"",
      "#include \"pm.h\"",
      "#include \"selection.h\"",
      "#include \"sslhelper.h\"",
      "#include \"sslcmds.h\"",
      "#include \"inet.h\"",
      "#include \"unixpw.h\"",
      "#include \"rates.h\"",
      "#include \"connections.h\"",
      "#include \"screen.h\"",
      "#include \"userinput.h\"",
      "#include \"cursor.h\"",
      "#include \"pointer.h\"",
      "#include \"keyboard.h\"",
      "#include \"cleanup.h\"",
      "#include \"user.h\"",
      "#include \"help.h\"",
      "#include \"gui.h\"",
      "#include \"scan.h\"",
      "#include \"remote.h\"",
      "#include \"win_utils.h\"",
      "#include \"xkb_bell.h\"",
      "#include \"xrandr.h\"",
      "#include \"xinerama.h\"",
      "#include \"xevents.h\"",
      "#include \"xrecord.h\"",
      "#include \"xdamage.h\"",
      "#include \"xwrappers.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [
      "#define TASKMAX 32"
    ],
    "globals_used": [
      "static int tsdo_timeout_flag;",
      "static pid_t ts_tasks[TASKMAX];",
      "static int ts_taskn = -1;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "0"
          ],
          "line": 265
        },
        "resolved": true,
        "details": {
          "function_name": "clean_up_exit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/cleanup.c",
          "lines": "151-266",
          "snippet": "void clean_up_exit(int ret) {\n\tstatic int depth = 0;\n\texit_flag = 1;\n\n\tif (depth++ > 2) {\n\t\texit(ret);\n\t}\n\n\tif (icon_mode) {\n\t\tclean_icon_mode();\n\t}\n\n\t/* remove the shm areas: */\n\tclean_shm(0);\n\n\tstop_stunnel();\n\tif (use_openssl) {\n\t\tssl_helper_pid(0, 0);\t/* killall */\n\t}\n\n\tif (ssh_pid > 0) {\n\t\tkill(ssh_pid, SIGTERM);\n\t\tssh_pid = 0;\n\t}\n\n#ifdef MACOSX\n\tif (client_connect_file) {\n\t\tif (strstr(client_connect_file, \"/tmp/x11vnc-macosx-remote\")\n\t\t    == client_connect_file) {\n\t\t\tunlink(client_connect_file);\n\t\t}\n\t}\n\tif (macosx_console) {\n\t\tmacosxCG_fini();\n\t}\n#endif\n\n\tif (pipeinput_fh != NULL) {\n\t\tpclose(pipeinput_fh);\n\t\tpipeinput_fh = NULL;\n\t}\n\n\tshutdown_uinput();\n\n\tif (unix_sock) {\n\t\tif (unix_sock_fd >= 0) {\n\t\t\trfbLog(\"deleting unix sock: %s\\n\", unix_sock);\n\t\t\tclose(unix_sock_fd);\n\t\t\tunix_sock_fd = -1;\n\t\t\tunlink(unix_sock);\n\t\t}\n\t}\n\n\tif (! dpy) {\t/* raw_rb hack */\n\t\tif (rm_flagfile) {\n\t\t\tunlink(rm_flagfile);\n\t\t\trm_flagfile = NULL;\n\t\t}\n\t\texit(ret);\n\t}\n\n\t/* X keyboard cleanups */\n\tdelete_added_keycodes(0);\n\n\t/* remove all created XInput2 devices */\n\tif(use_multipointer)\n\t    removeAllMDs(dpy);\n\n\tif (clear_mods == 1) {\n\t\tclear_modifiers(0);\n\t} else if (clear_mods == 2) {\n\t\tclear_keys();\n\t} else if (clear_mods == 3) {\n\t\tclear_keys();\n\t\tclear_locks();\n\t}\n\n\tif (no_autorepeat) {\n\t\tautorepeat(1, 0);\n\t}\n\tif (use_solid_bg) {\n\t\tsolid_bg(1);\n\t}\n\tif (ncache || ncache0) {\n\t\tkde_no_animate(1);\n\t}\n\tX_LOCK;\n\tXTestDiscard_wr(dpy);\n#if HAVE_LIBXDAMAGE\n\tif (xdamage) {\n\t\tXDamageDestroy(dpy, xdamage);\n\t}\n#endif\n#if HAVE_LIBXTRAP\n\tif (trap_ctx) {\n\t\tXEFreeTC(trap_ctx);\n\t}\n#endif\n\t/* XXX rdpy_ctrl, etc. cannot close w/o blocking */\n\tXCloseDisplay_wr(dpy);\n\tX_UNLOCK;\n\n\tfflush(stderr);\n\n\tif (rm_flagfile) {\n\t\tunlink(rm_flagfile);\n\t\trm_flagfile = NULL;\n\t}\n\n\tif (avahi) {\n\t\tavahi_cleanup();\n\t\tfflush(stderr);\n\t}\n\n\texit(ret);\n}",
          "includes": [
            "#include \"xi2_devices.h\"",
            "#include \"uinput.h\"",
            "#include \"xevents.h\"",
            "#include \"xrecord.h\"",
            "#include \"screen.h\"",
            "#include \"avahi.h\"",
            "#include \"macosxCG.h\"",
            "#include \"macosx.h\"",
            "#include \"connections.h\"",
            "#include \"sslhelper.h\"",
            "#include \"sslcmds.h\"",
            "#include \"unixpw.h\"",
            "#include \"solid.h\"",
            "#include \"gui.h\"",
            "#include \"scan.h\"",
            "#include \"keyboard.h\"",
            "#include \"remote.h\"",
            "#include \"xdamage.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void clean_up_exit(int ret);",
            "int known_sigpipe_mode(char *s);",
            "static int exit_flag = 0;",
            "static void clean_icon_mode(void);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xi2_devices.h\"\n#include \"uinput.h\"\n#include \"xevents.h\"\n#include \"xrecord.h\"\n#include \"screen.h\"\n#include \"avahi.h\"\n#include \"macosxCG.h\"\n#include \"macosx.h\"\n#include \"connections.h\"\n#include \"sslhelper.h\"\n#include \"sslcmds.h\"\n#include \"unixpw.h\"\n#include \"solid.h\"\n#include \"gui.h\"\n#include \"scan.h\"\n#include \"keyboard.h\"\n#include \"remote.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nvoid clean_up_exit(int ret);\nint known_sigpipe_mode(char *s);\nstatic int exit_flag = 0;\nstatic void clean_icon_mode(void);\n\nvoid clean_up_exit(int ret) {\n\tstatic int depth = 0;\n\texit_flag = 1;\n\n\tif (depth++ > 2) {\n\t\texit(ret);\n\t}\n\n\tif (icon_mode) {\n\t\tclean_icon_mode();\n\t}\n\n\t/* remove the shm areas: */\n\tclean_shm(0);\n\n\tstop_stunnel();\n\tif (use_openssl) {\n\t\tssl_helper_pid(0, 0);\t/* killall */\n\t}\n\n\tif (ssh_pid > 0) {\n\t\tkill(ssh_pid, SIGTERM);\n\t\tssh_pid = 0;\n\t}\n\n#ifdef MACOSX\n\tif (client_connect_file) {\n\t\tif (strstr(client_connect_file, \"/tmp/x11vnc-macosx-remote\")\n\t\t    == client_connect_file) {\n\t\t\tunlink(client_connect_file);\n\t\t}\n\t}\n\tif (macosx_console) {\n\t\tmacosxCG_fini();\n\t}\n#endif\n\n\tif (pipeinput_fh != NULL) {\n\t\tpclose(pipeinput_fh);\n\t\tpipeinput_fh = NULL;\n\t}\n\n\tshutdown_uinput();\n\n\tif (unix_sock) {\n\t\tif (unix_sock_fd >= 0) {\n\t\t\trfbLog(\"deleting unix sock: %s\\n\", unix_sock);\n\t\t\tclose(unix_sock_fd);\n\t\t\tunix_sock_fd = -1;\n\t\t\tunlink(unix_sock);\n\t\t}\n\t}\n\n\tif (! dpy) {\t/* raw_rb hack */\n\t\tif (rm_flagfile) {\n\t\t\tunlink(rm_flagfile);\n\t\t\trm_flagfile = NULL;\n\t\t}\n\t\texit(ret);\n\t}\n\n\t/* X keyboard cleanups */\n\tdelete_added_keycodes(0);\n\n\t/* remove all created XInput2 devices */\n\tif(use_multipointer)\n\t    removeAllMDs(dpy);\n\n\tif (clear_mods == 1) {\n\t\tclear_modifiers(0);\n\t} else if (clear_mods == 2) {\n\t\tclear_keys();\n\t} else if (clear_mods == 3) {\n\t\tclear_keys();\n\t\tclear_locks();\n\t}\n\n\tif (no_autorepeat) {\n\t\tautorepeat(1, 0);\n\t}\n\tif (use_solid_bg) {\n\t\tsolid_bg(1);\n\t}\n\tif (ncache || ncache0) {\n\t\tkde_no_animate(1);\n\t}\n\tX_LOCK;\n\tXTestDiscard_wr(dpy);\n#if HAVE_LIBXDAMAGE\n\tif (xdamage) {\n\t\tXDamageDestroy(dpy, xdamage);\n\t}\n#endif\n#if HAVE_LIBXTRAP\n\tif (trap_ctx) {\n\t\tXEFreeTC(trap_ctx);\n\t}\n#endif\n\t/* XXX rdpy_ctrl, etc. cannot close w/o blocking */\n\tXCloseDisplay_wr(dpy);\n\tX_UNLOCK;\n\n\tfflush(stderr);\n\n\tif (rm_flagfile) {\n\t\tunlink(rm_flagfile);\n\t\trm_flagfile = NULL;\n\t}\n\n\tif (avahi) {\n\t\tavahi_cleanup();\n\t\tfflush(stderr);\n\t}\n\n\texit(ret);\n}"
        }
      },
      {
        "call_info": {
          "callee": "close",
          "args": [
            "rsock"
          ],
          "line": 264
        },
        "resolved": true,
        "details": {
          "function_name": "close_alarm",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/unixpw.c",
          "lines": "666-672",
          "snippet": "static void close_alarm (int sig) {\n\tif (slave_fd >= 0) {\n\t\tclose(slave_fd);\n\t}\n\talarm_fired = 1;\n\tif (0) sig = 0;\t/* compiler warning */\n}",
          "includes": [
            "#include <sys/stropts.h>",
            "#include <termios.h>",
            "#include <sys/ioctl.h>",
            "#include <shadow.h>",
            "#include \"default8x16.h\"",
            "#include \"rates.h\"",
            "#include \"cursor.h\"",
            "#include \"sslhelper.h\"",
            "#include \"connections.h\"",
            "#include \"user.h\"",
            "#include \"connections.h\"",
            "#include \"xinerama.h\"",
            "#include \"cleanup.h\"",
            "#include \"scan.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int slave_fd = -1, alarm_fired = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/stropts.h>\n#include <termios.h>\n#include <sys/ioctl.h>\n#include <shadow.h>\n#include \"default8x16.h\"\n#include \"rates.h\"\n#include \"cursor.h\"\n#include \"sslhelper.h\"\n#include \"connections.h\"\n#include \"user.h\"\n#include \"connections.h\"\n#include \"xinerama.h\"\n#include \"cleanup.h\"\n#include \"scan.h\"\n#include \"x11vnc.h\"\n\nstatic int slave_fd = -1, alarm_fired = 0;\n\nstatic void close_alarm (int sig) {\n\tif (slave_fd >= 0) {\n\t\tclose(slave_fd);\n\t}\n\talarm_fired = 1;\n\tif (0) sig = 0;\t/* compiler warning */\n}"
        }
      },
      {
        "call_info": {
          "callee": "raw_xfer",
          "args": [
            "rsock",
            "csock",
            "csock"
          ],
          "line": 262
        },
        "resolved": true,
        "details": {
          "function_name": "raw_xfer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/sslhelper.c",
          "lines": "4286-4373",
          "snippet": "void raw_xfer(int csock, int s_in, int s_out) {\n\tchar buf0[8192];\n\tint sz = 8192, n, m, status, db = 1;\n\tchar *buf;\n#ifdef FORK_OK\n\tpid_t par = getpid();\n\tpid_t pid = fork();\n\n\tbuf = buf0;\n\tif (vnc_redirect) {\n\t\t/* change buf size some direction. */\n\t}\n\n\tif (getenv(\"X11VNC_DEBUG_RAW_XFER\")) {\n\t\tdb = atoi(getenv(\"X11VNC_DEBUG_RAW_XFER\"));\n\t}\n\tif (pid < 0) {\n\t\texit(1);\n\t}\n\t/* this is for testing or special helper usage, no SSL just socket redir */\n\tif (pid) {\n\t\tif (db) rfbLog(\"raw_xfer start: %d -> %d/%d\\n\", csock, s_in, s_out);\n\n\t\twhile (1) {\n\t\t\tn = read(csock, buf, sz);\n\t\t\tif (n == 0 || (n < 0 && errno != EINTR) ) {\n\t\t\t\tbreak;\n\t\t\t} else if (n > 0) {\n\t\t\t\tint len = n;\n\t\t\t\tchar *src = buf;\n\t\t\t\tif (db > 1) write(2, buf, n);\n\t\t\t\twhile (len > 0) {\n\t\t\t\t\tm = write(s_out, src, len);\n\t\t\t\t\tif (m > 0) {\n\t\t\t\t\t\tsrc += m;\n\t\t\t\t\t\tlen -= m;\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tif (m < 0 && (errno == EINTR || errno == EAGAIN)) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\nif (db) rfbLog(\"raw_xfer bad write:  %d -> %d | %d/%d  errno=%d\\n\", csock, s_out, m, n, errno);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tusleep(250*1000);\n\t\tkill(pid, SIGTERM);\n\t\twaitpid(pid, &status, WNOHANG); \n\t\tif (db) rfbLog(\"raw_xfer done:  %d -> %d\\n\", csock, s_out);\n\n\t} else {\n\t\tif (db) usleep(50*1000);\n\t\tif (db) rfbLog(\"raw_xfer start: %d <- %d\\n\", csock, s_in);\n\n\t\twhile (1) {\n\t\t\tn = read(s_in, buf, sz);\n\t\t\tif (n == 0 || (n < 0 && errno != EINTR) ) {\n\t\t\t\tbreak;\n\t\t\t} else if (n > 0) {\n\t\t\t\tint len = n;\n\t\t\t\tchar *src = buf;\n\t\t\t\tif (db > 1) write(2, buf, n);\n\t\t\t\twhile (len > 0) {\n\t\t\t\t\tm = write(csock, src, len);\n\t\t\t\t\tif (m > 0) {\n\t\t\t\t\t\tsrc += m;\n\t\t\t\t\t\tlen -= m;\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tif (m < 0 && (errno == EINTR || errno == EAGAIN)) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\tif (db) rfbLog(\"raw_xfer bad write:  %d <- %d | %d/%d errno=%d\\n\", csock, s_in, m, n, errno);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tusleep(250*1000);\n\t\tkill(par, SIGTERM);\n\t\twaitpid(par, &status, WNOHANG); \n\t\tif (db) rfbLog(\"raw_xfer done:  %d <- %d\\n\", csock, s_in);\n\t}\n\tclose(csock);\n\tclose(s_in);\n\tclose(s_out);\n#endif\t/* FORK_OK */\n}",
          "includes": [
            "#include <openssl/rand.h>",
            "#include <openssl/err.h>",
            "#include <openssl/ssl.h>",
            "#include \"user.h\"",
            "#include \"unixpw.h\"",
            "#include \"sslcmds.h\"",
            "#include \"connections.h\"",
            "#include \"scan.h\"",
            "#include \"screen.h\"",
            "#include \"cleanup.h\"",
            "#include \"inet.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [
            "#define FORK_OK"
          ],
          "globals_used": [
            "void raw_xfer(int csock, int s_in, int s_out);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <openssl/rand.h>\n#include <openssl/err.h>\n#include <openssl/ssl.h>\n#include \"user.h\"\n#include \"unixpw.h\"\n#include \"sslcmds.h\"\n#include \"connections.h\"\n#include \"scan.h\"\n#include \"screen.h\"\n#include \"cleanup.h\"\n#include \"inet.h\"\n#include \"x11vnc.h\"\n\n#define FORK_OK\n\nvoid raw_xfer(int csock, int s_in, int s_out);\n\nvoid raw_xfer(int csock, int s_in, int s_out) {\n\tchar buf0[8192];\n\tint sz = 8192, n, m, status, db = 1;\n\tchar *buf;\n#ifdef FORK_OK\n\tpid_t par = getpid();\n\tpid_t pid = fork();\n\n\tbuf = buf0;\n\tif (vnc_redirect) {\n\t\t/* change buf size some direction. */\n\t}\n\n\tif (getenv(\"X11VNC_DEBUG_RAW_XFER\")) {\n\t\tdb = atoi(getenv(\"X11VNC_DEBUG_RAW_XFER\"));\n\t}\n\tif (pid < 0) {\n\t\texit(1);\n\t}\n\t/* this is for testing or special helper usage, no SSL just socket redir */\n\tif (pid) {\n\t\tif (db) rfbLog(\"raw_xfer start: %d -> %d/%d\\n\", csock, s_in, s_out);\n\n\t\twhile (1) {\n\t\t\tn = read(csock, buf, sz);\n\t\t\tif (n == 0 || (n < 0 && errno != EINTR) ) {\n\t\t\t\tbreak;\n\t\t\t} else if (n > 0) {\n\t\t\t\tint len = n;\n\t\t\t\tchar *src = buf;\n\t\t\t\tif (db > 1) write(2, buf, n);\n\t\t\t\twhile (len > 0) {\n\t\t\t\t\tm = write(s_out, src, len);\n\t\t\t\t\tif (m > 0) {\n\t\t\t\t\t\tsrc += m;\n\t\t\t\t\t\tlen -= m;\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tif (m < 0 && (errno == EINTR || errno == EAGAIN)) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\nif (db) rfbLog(\"raw_xfer bad write:  %d -> %d | %d/%d  errno=%d\\n\", csock, s_out, m, n, errno);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tusleep(250*1000);\n\t\tkill(pid, SIGTERM);\n\t\twaitpid(pid, &status, WNOHANG); \n\t\tif (db) rfbLog(\"raw_xfer done:  %d -> %d\\n\", csock, s_out);\n\n\t} else {\n\t\tif (db) usleep(50*1000);\n\t\tif (db) rfbLog(\"raw_xfer start: %d <- %d\\n\", csock, s_in);\n\n\t\twhile (1) {\n\t\t\tn = read(s_in, buf, sz);\n\t\t\tif (n == 0 || (n < 0 && errno != EINTR) ) {\n\t\t\t\tbreak;\n\t\t\t} else if (n > 0) {\n\t\t\t\tint len = n;\n\t\t\t\tchar *src = buf;\n\t\t\t\tif (db > 1) write(2, buf, n);\n\t\t\t\twhile (len > 0) {\n\t\t\t\t\tm = write(csock, src, len);\n\t\t\t\t\tif (m > 0) {\n\t\t\t\t\t\tsrc += m;\n\t\t\t\t\t\tlen -= m;\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tif (m < 0 && (errno == EINTR || errno == EAGAIN)) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\tif (db) rfbLog(\"raw_xfer bad write:  %d <- %d | %d/%d errno=%d\\n\", csock, s_in, m, n, errno);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tusleep(250*1000);\n\t\tkill(par, SIGTERM);\n\t\twaitpid(par, &status, WNOHANG); \n\t\tif (db) rfbLog(\"raw_xfer done:  %d <- %d\\n\", csock, s_in);\n\t}\n\tclose(csock);\n\tclose(s_in);\n\tclose(s_out);\n#endif\t/* FORK_OK */\n}"
        }
      },
      {
        "call_info": {
          "callee": "perror",
          "args": [
            "\"setpgrp\""
          ],
          "line": 256
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "setpgrp",
          "args": [],
          "line": 255
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "perror",
          "args": [
            "\"setsid\""
          ],
          "line": 249
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "setsid",
          "args": [],
          "line": 248
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fork",
          "args": [],
          "line": 227
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"tsdo: connect_tcp(port=%d) failed.\\n\"",
            "port"
          ],
          "line": 222
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "connect_tcp",
          "args": [
            "\"127.0.0.1\"",
            "port"
          ],
          "line": 220
        },
        "resolved": true,
        "details": {
          "function_name": "connect_tcp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/inet.c",
          "lines": "716-893",
          "snippet": "int connect_tcp(char *host, int port) {\n\tdouble t0 = dnow();\n\tint fd = -1;\n\tint fail4 = noipv4;\n\tif (getenv(\"IPV4_FAILS\")) {\n\t\tfail4 = 2;\n\t}\n\n\trfbLog(\"connect_tcp: trying:   %s %d\\n\", host, port);\n\n\tif (fail4) {\n\t\tif (fail4 > 1) {\n\t\t\trfbLog(\"TESTING: IPV4_FAILS for connect_tcp.\\n\");\n\t\t}\n\t} else {\n\t\tfd = rfbConnectToTcpAddr(host, port);\n\t}\n\n\tif (fd >= 0) {\n\t\treturn fd;\n\t}\n\trfbLogPerror(\"connect_tcp: connection failed\");\n\n\tif (dnow() - t0 < 4.0) {\n\t\trfbLog(\"connect_tcp: re-trying %s %d\\n\", host, port);\n\t\tusleep (100 * 1000);\n\t\tif (!fail4) {\n\t\t\tfd = rfbConnectToTcpAddr(host, port);\n\t\t}\n\t\tif (fd < 0) {\n\t\t\trfbLogPerror(\"connect_tcp: connection failed\");\n\t\t}\n\t}\n\n\tif (fd < 0 && !noipv6) {\n#if X11VNC_IPV6\n\t\tint err;\n\t\tstruct addrinfo *ai;\n\t\tstruct addrinfo hints;\n\t\tchar service[32], *host2, *q;\n\n\t\trfbLog(\"connect_tcp: trying IPv6 %s %d\\n\", host, port);\n\n\t\tmemset(&hints, 0, sizeof(hints));\n\t\tsprintf(service, \"%d\", port);\n\n\t\thints.ai_family = AF_UNSPEC;\n\t\thints.ai_socktype = SOCK_STREAM;\n#ifdef AI_ADDRCONFIG\n\t\thints.ai_flags |= AI_ADDRCONFIG;\n#endif\n\t\tif(ipv6_ip(host)) {\n#ifdef AI_NUMERICHOST\n\t\t\trfbLog(\"connect_tcp[ipv6]: setting AI_NUMERICHOST for %s\\n\", host);\n\t\t\thints.ai_flags |= AI_NUMERICHOST;\n#endif\n\t\t}\n#ifdef AI_NUMERICSERV\n\t\thints.ai_flags |= AI_NUMERICSERV;\n#endif\n\n\t\tif (!strcmp(host, \"127.0.0.1\")) {\n\t\t\thost2 = strdup(\"::1\");\n\t\t} else if (host[0] == '[') {\n\t\t\thost2 = strdup(host+1);\n\t\t} else {\n\t\t\thost2 = strdup(host);\n\t\t}\n\t\tq = strrchr(host2, ']');\n\t\tif (q) {\n\t\t\t*q = '\\0';\n\t\t}\n\n\t\terr = getaddrinfo(host2, service, &hints, &ai);\n\t\tif (err != 0) {\n\t\t\trfbLog(\"connect_tcp[ipv6]: getaddrinfo[%d]: %s\\n\", err, gai_strerror(err));\n\t\t\tusleep(100 * 1000);\n\t\t\terr = getaddrinfo(host2, service, &hints, &ai);\n\t\t}\n\t\tfree(host2);\n\n\t\tif (err != 0) {\n\t\t\trfbLog(\"connect_tcp[ipv6]: getaddrinfo[%d]: %s\\n\", err, gai_strerror(err));\n\t\t} else {\n\t\t\tstruct addrinfo *ap = ai;\n\t\t\twhile (ap != NULL) {\n\t\t\t\tint sock;\n\n\t\t\t\tif (fail4) {\n\t\t\t\t\tstruct sockaddr_in6 *s6ptr;\n\t\t\t\t\tif (ap->ai_family != AF_INET6) {\n\t\t\t\t\t\trfbLog(\"connect_tcp[ipv6]: skipping AF_INET address under -noipv4\\n\");\n\t\t\t\t\t\tap = ap->ai_next;\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n#ifdef IN6_IS_ADDR_V4MAPPED\n\t\t\t\t\ts6ptr = (struct sockaddr_in6 *) ap->ai_addr;\n\t\t\t\t\tif (IN6_IS_ADDR_V4MAPPED(&(s6ptr->sin6_addr))) {\n\t\t\t\t\t\trfbLog(\"connect_tcp[ipv6]: skipping V4MAPPED address under -noipv4\\n\");\n\t\t\t\t\t\tap = ap->ai_next;\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n#endif\n\t\t\t\t}\n\n\t\t\t\tsock = socket(ap->ai_family, ap->ai_socktype, ap->ai_protocol);\n\n\t\t\t\tif (sock == -1) {\n\t\t\t\t\trfbLogPerror(\"connect_tcp[ipv6]: socket\");\n\t\t\t\t\tif (0) rfbLog(\"(Ignore the above error if this system is IPv4-only.)\\n\");\n\t\t\t\t} else {\n\t\t\t\t\tint res = -1, dmsg = 0;\n\t\t\t\t\tchar *s = ipv6_getipaddr(ap->ai_addr, ap->ai_addrlen);\n\t\t\t\t\tif (!s) s = strdup(\"unknown\");\n\n\t\t\t\t\trfbLog(\"connect_tcp[ipv6]: trying sock=%d fam=%d proto=%d using %s\\n\",\n\t\t\t\t\t    sock, ap->ai_family, ap->ai_protocol, s);\n\t\t\t\t\tres = connect(sock, ap->ai_addr, ap->ai_addrlen);\n#if defined(SOL_IPV6) && defined(IPV6_V6ONLY)\n\t\t\t\t\tif (res != 0) {\n\t\t\t\t\t\tint zero = 0;\n\t\t\t\t\t\trfbLogPerror(\"connect_tcp[ipv6]: connect\");\n\t\t\t\t\t\tdmsg = 1;\n\t\t\t\t\t\tif (setsockopt(sock, SOL_IPV6, IPV6_V6ONLY, (char *)&zero, sizeof(zero)) == 0) {\n\t\t\t\t\t\t\trfbLog(\"connect_tcp[ipv6]: trying again with IPV6_V6ONLY=0\\n\");\n\t\t\t\t\t\t\tres = connect(sock, ap->ai_addr, ap->ai_addrlen);\n\t\t\t\t\t\t\tdmsg = 0;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\trfbLogPerror(\"connect_tcp[ipv6]: setsockopt IPV6_V6ONLY\");\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n#endif\n\t\t\t\t\tif (res == 0) {\n\t\t\t\t\t\trfbLog(\"connect_tcp[ipv6]: connect OK\\n\");\n\t\t\t\t\t\tfd = sock;\n\t\t\t\t\t\tif (!ipv6_client_ip_str) {\n\t\t\t\t\t\t\tipv6_client_ip_str = strdup(s);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tfree(s);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif (!dmsg) rfbLogPerror(\"connect_tcp[ipv6]: connect\");\n\t\t\t\t\t\tclose(sock);\n\t\t\t\t\t}\n\t\t\t\t\tfree(s);\n\t\t\t\t}\n\t\t\t\tap = ap->ai_next;\n\t\t\t}\n\t\t\tfreeaddrinfo(ai);\n\t\t}\n#endif\n\t}\n\tif (fd < 0 && !fail4) {\n\t\t/* this is a kludge for IPv4-only machines getting v4mapped string. */\n\t\tchar *q, *host2;\n\t\tif (host[0] == '[') {\n\t\t\thost2 = strdup(host+1);\n\t\t} else {\n\t\t\thost2 = strdup(host);\n\t\t}\n\t\tq = strrchr(host2, ']');\n\t\tif (q) {\n\t\t\t*q = '\\0';\n\t\t}\n\t\tif (strstr(host2, \"::ffff:\") == host2 || strstr(host2, \"::FFFF:\") == host2) {\n\t\t\tchar *host3 = host2 + strlen(\"::ffff:\");\n\t\t\tif (dotted_ip(host3, 0)) {\n\t\t\t\trfbLog(\"connect_tcp[ipv4]: trying fallback to IPv4 for %s\\n\", host2);\n\t\t\t\tfd = rfbConnectToTcpAddr(host3, port);\n\t\t\t\tif (fd < 0) {\n\t\t\t\t\trfbLogPerror(\"connect_tcp[ipv4]: connection failed\");\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfree(host2);\n\t}\n\treturn fd;\n}",
          "includes": [
            "#include <sys/un.h>",
            "#include \"sslhelper.h\"",
            "#include \"unixpw.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "char *host2ip(char *host);",
            "int ipv6_ip(char *host);",
            "int get_remote_port(int sock);",
            "int get_local_port(int sock);",
            "char *get_remote_host(int sock);",
            "char *get_local_host(int sock);",
            "int listen6(int port);",
            "int accept_unix(int s);",
            "int connect_tcp(char *host, int port);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/un.h>\n#include \"sslhelper.h\"\n#include \"unixpw.h\"\n#include \"x11vnc.h\"\n\nchar *host2ip(char *host);\nint ipv6_ip(char *host);\nint get_remote_port(int sock);\nint get_local_port(int sock);\nchar *get_remote_host(int sock);\nchar *get_local_host(int sock);\nint listen6(int port);\nint accept_unix(int s);\nint connect_tcp(char *host, int port);\n\nint connect_tcp(char *host, int port) {\n\tdouble t0 = dnow();\n\tint fd = -1;\n\tint fail4 = noipv4;\n\tif (getenv(\"IPV4_FAILS\")) {\n\t\tfail4 = 2;\n\t}\n\n\trfbLog(\"connect_tcp: trying:   %s %d\\n\", host, port);\n\n\tif (fail4) {\n\t\tif (fail4 > 1) {\n\t\t\trfbLog(\"TESTING: IPV4_FAILS for connect_tcp.\\n\");\n\t\t}\n\t} else {\n\t\tfd = rfbConnectToTcpAddr(host, port);\n\t}\n\n\tif (fd >= 0) {\n\t\treturn fd;\n\t}\n\trfbLogPerror(\"connect_tcp: connection failed\");\n\n\tif (dnow() - t0 < 4.0) {\n\t\trfbLog(\"connect_tcp: re-trying %s %d\\n\", host, port);\n\t\tusleep (100 * 1000);\n\t\tif (!fail4) {\n\t\t\tfd = rfbConnectToTcpAddr(host, port);\n\t\t}\n\t\tif (fd < 0) {\n\t\t\trfbLogPerror(\"connect_tcp: connection failed\");\n\t\t}\n\t}\n\n\tif (fd < 0 && !noipv6) {\n#if X11VNC_IPV6\n\t\tint err;\n\t\tstruct addrinfo *ai;\n\t\tstruct addrinfo hints;\n\t\tchar service[32], *host2, *q;\n\n\t\trfbLog(\"connect_tcp: trying IPv6 %s %d\\n\", host, port);\n\n\t\tmemset(&hints, 0, sizeof(hints));\n\t\tsprintf(service, \"%d\", port);\n\n\t\thints.ai_family = AF_UNSPEC;\n\t\thints.ai_socktype = SOCK_STREAM;\n#ifdef AI_ADDRCONFIG\n\t\thints.ai_flags |= AI_ADDRCONFIG;\n#endif\n\t\tif(ipv6_ip(host)) {\n#ifdef AI_NUMERICHOST\n\t\t\trfbLog(\"connect_tcp[ipv6]: setting AI_NUMERICHOST for %s\\n\", host);\n\t\t\thints.ai_flags |= AI_NUMERICHOST;\n#endif\n\t\t}\n#ifdef AI_NUMERICSERV\n\t\thints.ai_flags |= AI_NUMERICSERV;\n#endif\n\n\t\tif (!strcmp(host, \"127.0.0.1\")) {\n\t\t\thost2 = strdup(\"::1\");\n\t\t} else if (host[0] == '[') {\n\t\t\thost2 = strdup(host+1);\n\t\t} else {\n\t\t\thost2 = strdup(host);\n\t\t}\n\t\tq = strrchr(host2, ']');\n\t\tif (q) {\n\t\t\t*q = '\\0';\n\t\t}\n\n\t\terr = getaddrinfo(host2, service, &hints, &ai);\n\t\tif (err != 0) {\n\t\t\trfbLog(\"connect_tcp[ipv6]: getaddrinfo[%d]: %s\\n\", err, gai_strerror(err));\n\t\t\tusleep(100 * 1000);\n\t\t\terr = getaddrinfo(host2, service, &hints, &ai);\n\t\t}\n\t\tfree(host2);\n\n\t\tif (err != 0) {\n\t\t\trfbLog(\"connect_tcp[ipv6]: getaddrinfo[%d]: %s\\n\", err, gai_strerror(err));\n\t\t} else {\n\t\t\tstruct addrinfo *ap = ai;\n\t\t\twhile (ap != NULL) {\n\t\t\t\tint sock;\n\n\t\t\t\tif (fail4) {\n\t\t\t\t\tstruct sockaddr_in6 *s6ptr;\n\t\t\t\t\tif (ap->ai_family != AF_INET6) {\n\t\t\t\t\t\trfbLog(\"connect_tcp[ipv6]: skipping AF_INET address under -noipv4\\n\");\n\t\t\t\t\t\tap = ap->ai_next;\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n#ifdef IN6_IS_ADDR_V4MAPPED\n\t\t\t\t\ts6ptr = (struct sockaddr_in6 *) ap->ai_addr;\n\t\t\t\t\tif (IN6_IS_ADDR_V4MAPPED(&(s6ptr->sin6_addr))) {\n\t\t\t\t\t\trfbLog(\"connect_tcp[ipv6]: skipping V4MAPPED address under -noipv4\\n\");\n\t\t\t\t\t\tap = ap->ai_next;\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n#endif\n\t\t\t\t}\n\n\t\t\t\tsock = socket(ap->ai_family, ap->ai_socktype, ap->ai_protocol);\n\n\t\t\t\tif (sock == -1) {\n\t\t\t\t\trfbLogPerror(\"connect_tcp[ipv6]: socket\");\n\t\t\t\t\tif (0) rfbLog(\"(Ignore the above error if this system is IPv4-only.)\\n\");\n\t\t\t\t} else {\n\t\t\t\t\tint res = -1, dmsg = 0;\n\t\t\t\t\tchar *s = ipv6_getipaddr(ap->ai_addr, ap->ai_addrlen);\n\t\t\t\t\tif (!s) s = strdup(\"unknown\");\n\n\t\t\t\t\trfbLog(\"connect_tcp[ipv6]: trying sock=%d fam=%d proto=%d using %s\\n\",\n\t\t\t\t\t    sock, ap->ai_family, ap->ai_protocol, s);\n\t\t\t\t\tres = connect(sock, ap->ai_addr, ap->ai_addrlen);\n#if defined(SOL_IPV6) && defined(IPV6_V6ONLY)\n\t\t\t\t\tif (res != 0) {\n\t\t\t\t\t\tint zero = 0;\n\t\t\t\t\t\trfbLogPerror(\"connect_tcp[ipv6]: connect\");\n\t\t\t\t\t\tdmsg = 1;\n\t\t\t\t\t\tif (setsockopt(sock, SOL_IPV6, IPV6_V6ONLY, (char *)&zero, sizeof(zero)) == 0) {\n\t\t\t\t\t\t\trfbLog(\"connect_tcp[ipv6]: trying again with IPV6_V6ONLY=0\\n\");\n\t\t\t\t\t\t\tres = connect(sock, ap->ai_addr, ap->ai_addrlen);\n\t\t\t\t\t\t\tdmsg = 0;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\trfbLogPerror(\"connect_tcp[ipv6]: setsockopt IPV6_V6ONLY\");\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n#endif\n\t\t\t\t\tif (res == 0) {\n\t\t\t\t\t\trfbLog(\"connect_tcp[ipv6]: connect OK\\n\");\n\t\t\t\t\t\tfd = sock;\n\t\t\t\t\t\tif (!ipv6_client_ip_str) {\n\t\t\t\t\t\t\tipv6_client_ip_str = strdup(s);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tfree(s);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif (!dmsg) rfbLogPerror(\"connect_tcp[ipv6]: connect\");\n\t\t\t\t\t\tclose(sock);\n\t\t\t\t\t}\n\t\t\t\t\tfree(s);\n\t\t\t\t}\n\t\t\t\tap = ap->ai_next;\n\t\t\t}\n\t\t\tfreeaddrinfo(ai);\n\t\t}\n#endif\n\t}\n\tif (fd < 0 && !fail4) {\n\t\t/* this is a kludge for IPv4-only machines getting v4mapped string. */\n\t\tchar *q, *host2;\n\t\tif (host[0] == '[') {\n\t\t\thost2 = strdup(host+1);\n\t\t} else {\n\t\t\thost2 = strdup(host);\n\t\t}\n\t\tq = strrchr(host2, ']');\n\t\tif (q) {\n\t\t\t*q = '\\0';\n\t\t}\n\t\tif (strstr(host2, \"::ffff:\") == host2 || strstr(host2, \"::FFFF:\") == host2) {\n\t\t\tchar *host3 = host2 + strlen(\"::ffff:\");\n\t\t\tif (dotted_ip(host3, 0)) {\n\t\t\t\trfbLog(\"connect_tcp[ipv4]: trying fallback to IPv4 for %s\\n\", host2);\n\t\t\t\tfd = rfbConnectToTcpAddr(host3, port);\n\t\t\t\tif (fd < 0) {\n\t\t\t\t\trfbLogPerror(\"connect_tcp[ipv4]: connection failed\");\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfree(host2);\n\t}\n\treturn fd;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"tsdo: using existing csock: %d, port: %d\\n\"",
            "csock",
            "port"
          ],
          "line": 217
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"tsdo: accept: lsock: %d, csock: %d, port: %d\\n\"",
            "lsock",
            "csock",
            "port"
          ],
          "line": 207
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "accept",
          "args": [
            "lsock",
            "(struct sockaddr *)&addr",
            "&addrlen"
          ],
          "line": 204
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "signal",
          "args": [
            "SIGALRM",
            "tsdo_timeout"
          ],
          "line": 200
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xi2_devices.h\"\n#include \"solid.h\"\n#include \"pm.h\"\n#include \"selection.h\"\n#include \"sslhelper.h\"\n#include \"sslcmds.h\"\n#include \"inet.h\"\n#include \"unixpw.h\"\n#include \"rates.h\"\n#include \"connections.h\"\n#include \"screen.h\"\n#include \"userinput.h\"\n#include \"cursor.h\"\n#include \"pointer.h\"\n#include \"keyboard.h\"\n#include \"cleanup.h\"\n#include \"user.h\"\n#include \"help.h\"\n#include \"gui.h\"\n#include \"scan.h\"\n#include \"remote.h\"\n#include \"win_utils.h\"\n#include \"xkb_bell.h\"\n#include \"xrandr.h\"\n#include \"xinerama.h\"\n#include \"xevents.h\"\n#include \"xrecord.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\n#define TASKMAX 32\n\nstatic int tsdo_timeout_flag;\nstatic pid_t ts_tasks[TASKMAX];\nstatic int ts_taskn = -1;\n\nint tsdo(int port, int lsock, int *conn) {\n\tint csock, rsock, i, db = 1;\n\tpid_t pid;\n\tstruct sockaddr_in addr;\n#ifdef __hpux\n\tint addrlen = sizeof(addr);\n#else\n\tsocklen_t addrlen = sizeof(addr);\n#endif\n\n\tif (*conn < 0) {\n\t\tsignal(SIGALRM, tsdo_timeout);\n\t\ttsdo_timeout_flag = 0;\n\n\t\talarm(10);\n\t\tcsock = accept(lsock, (struct sockaddr *)&addr, &addrlen);\n\t\talarm(0);\n\n\t\tif (db) rfbLog(\"tsdo: accept: lsock: %d, csock: %d, port: %d\\n\", lsock, csock, port);\n\n\t\tif (tsdo_timeout_flag > 0 || csock < 0) {\n\t\t\tclose(csock);\n\t\t\t*conn = -1;\n\t\t\treturn 1;\n\t\t}\n\t\t*conn = csock;\n\t} else {\n\t\tcsock = *conn;\n\t\tif (db) rfbLog(\"tsdo: using existing csock: %d, port: %d\\n\", csock, port);\n\t}\n\n\trsock = connect_tcp(\"127.0.0.1\", port);\n\tif (rsock < 0) {\n\t\tif (db) rfbLog(\"tsdo: connect_tcp(port=%d) failed.\\n\", port);\n\t\tclose(csock);\n\t\treturn 2;\n\t}\n\n\tpid = fork();\n\tif (pid < 0) {\n\t\tclose(csock);\n\t\tclose(rsock);\n\t\treturn 3;\n\t}\n\tif (pid > 0) {\n\t\tts_taskn = (ts_taskn+1) % TASKMAX;\n\t\tts_tasks[ts_taskn] = pid;\n\t\tclose(csock);\n\t\tclose(rsock);\n\t\t*conn = -1;\n\t\treturn 0;\n\t}\n\tif (pid == 0) {\n\t\tfor (i=0; i<255; i++) {\n\t\t\tif (i != csock && i != rsock && i != 2) {\n\t\t\t\tclose(i);\n\t\t\t}\n\t\t}\n#if HAVE_SETSID\n\t\tif (setsid() == -1) {\n\t\t\tperror(\"setsid\");\n\t\t\tclose(csock);\n\t\t\tclose(rsock);\n\t\t\texit(1);\n\t\t}\n#else\n\t\tif (setpgrp() == -1) {\n\t\t\tperror(\"setpgrp\");\n\t\t\tclose(csock);\n\t\t\tclose(rsock);\n\t\t\texit(1);\n\t\t}\n#endif\t/* SETSID */\n\t\traw_xfer(rsock, csock, csock);\n\t\tclose(csock);\n\t\tclose(rsock);\n\t\texit(0);\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "tsdo_timeout",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/x11vnc.c",
    "lines": "180-183",
    "snippet": "static void tsdo_timeout (int sig) {\n\ttsdo_timeout_flag = 1;\n\tif (sig) {};\n}",
    "includes": [
      "#include \"xi2_devices.h\"",
      "#include \"solid.h\"",
      "#include \"pm.h\"",
      "#include \"selection.h\"",
      "#include \"sslhelper.h\"",
      "#include \"sslcmds.h\"",
      "#include \"inet.h\"",
      "#include \"unixpw.h\"",
      "#include \"rates.h\"",
      "#include \"connections.h\"",
      "#include \"screen.h\"",
      "#include \"userinput.h\"",
      "#include \"cursor.h\"",
      "#include \"pointer.h\"",
      "#include \"keyboard.h\"",
      "#include \"cleanup.h\"",
      "#include \"user.h\"",
      "#include \"help.h\"",
      "#include \"gui.h\"",
      "#include \"scan.h\"",
      "#include \"remote.h\"",
      "#include \"win_utils.h\"",
      "#include \"xkb_bell.h\"",
      "#include \"xrandr.h\"",
      "#include \"xinerama.h\"",
      "#include \"xevents.h\"",
      "#include \"xrecord.h\"",
      "#include \"xdamage.h\"",
      "#include \"xwrappers.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int tsdo_timeout_flag;"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"xi2_devices.h\"\n#include \"solid.h\"\n#include \"pm.h\"\n#include \"selection.h\"\n#include \"sslhelper.h\"\n#include \"sslcmds.h\"\n#include \"inet.h\"\n#include \"unixpw.h\"\n#include \"rates.h\"\n#include \"connections.h\"\n#include \"screen.h\"\n#include \"userinput.h\"\n#include \"cursor.h\"\n#include \"pointer.h\"\n#include \"keyboard.h\"\n#include \"cleanup.h\"\n#include \"user.h\"\n#include \"help.h\"\n#include \"gui.h\"\n#include \"scan.h\"\n#include \"remote.h\"\n#include \"win_utils.h\"\n#include \"xkb_bell.h\"\n#include \"xrandr.h\"\n#include \"xinerama.h\"\n#include \"xevents.h\"\n#include \"xrecord.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nstatic int tsdo_timeout_flag;\n\nstatic void tsdo_timeout (int sig) {\n\ttsdo_timeout_flag = 1;\n\tif (sig) {};\n}"
  }
]