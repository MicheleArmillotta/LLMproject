[
  {
    "function_name": "wait_for_client",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/user.c",
    "lines": "2921-3157",
    "snippet": "int wait_for_client(int *argc, char** argv, int http) {\n\t/* ugh, here we go... */\n\tXImage* fb_image;\n\tint w = 640, h = 480, b = 32;\n\tint w0 = -1, h0 = -1, i, chg_raw_fb = 0;\n\tchar *str, *q, *cmd = NULL;\n\tint db = 0, dt = 0;\n\tchar *create_cmd = NULL;\n\tchar *users_list_save = NULL;\n\tint created_disp = 0, ncache_save;\n\tint did_client_connect = 0;\n\tchar *vnc_redirect_host = \"localhost\";\n\tint vnc_redirect_port = -1, vnc_redirect_cnt = 0;\n\tchar vnc_redirect_test[10];\n\n\tif (getenv(\"WAIT_FOR_CLIENT_DB\")) {\n\t\tdb = 1;\n\t}\n\n\tvnc_redirect = 0;\n\n\tif (! use_dpy || strstr(use_dpy, \"WAIT:\") != use_dpy) {\n\t\treturn 0;\n\t}\n\n\tfor (i=0; i < *argc; i++) {\n\t\tif (!strcmp(argv[i], \"-desktop\")) {\n\t\t\tdt = 1;\n\t\t}\n\t\tif (db) fprintf(stderr, \"args %d %s\\n\", i, argv[i]);\n\t}\n\tif (!quiet && !strstr(use_dpy, \"FINDDISPLAY-run\")) {\n\t\trfbLog(\"\\n\");\n\t\trfbLog(\"wait_for_client: %s\\n\", use_dpy);\n\t\trfbLog(\"\\n\");\n\t}\n\n\tstr = strdup(use_dpy);\n\tstr += strlen(\"WAIT\");\n\n\txdmcp_insert = NULL;\n\n\t/* get any leading geometry: */\n\tq = strchr(str+1, ':');\n\tif (q) {\n\t\t*q = '\\0';\n\t\tif (sscanf(str+1, \"%dx%d\", &w0, &h0) == 2)  {\n\t\t\tw = w0;\n\t\t\th = h0;\n\t\t\trfbLog(\"wait_for_client set: w=%d h=%d\\n\", w, h);\n\t\t} else {\n\t\t\tw0 = -1;\n\t\t\th0 = -1;\n\t\t}\n\t\t*q = ':';\n\t\tstr = q;\n\t}\n\tif ((w0 == -1 || h0 == -1) && pad_geometry != NULL) {\n\t\tint b0, del = 0;\n\t\tchar *s = pad_geometry;\n\t\tif (strstr(s, \"once:\") == s) {\n\t\t\tdel = 1;\n\t\t\ts += strlen(\"once:\");\n\t\t}\n\t\tif (sscanf(s, \"%dx%dx%d\", &w0, &h0, &b0) == 3)  {\n\t\t\tw = nabs(w0);\n\t\t\th = nabs(h0);\n\t\t\tb = nabs(b0);\n\t\t} else if (sscanf(s, \"%dx%d\", &w0, &h0) == 2)  {\n\t\t\tw = nabs(w0);\n\t\t\th = nabs(h0);\n\t\t}\n\t\tif (del) {\n\t\t\tpad_geometry = NULL;\n\t\t}\n\t}\n\n\t/* str currently begins with a ':' */\n\tif (strstr(str, \":cmd=\") == str) {\n\t\t/* cmd=/path/to/mycommand */\n\t\tstr++;\n\t} else if (strpbrk(str, \"0123456789\") == str+1) {\n\t\t/* :0.0 */\n\t\t;\n\t} else {\n\t\t/* hostname:0.0 */\n\t\tstr++;\n\t}\n\n\tif (db) fprintf(stderr, \"str: %s\\n\", str);\n\n\tif (strstr(str, \"cmd=\") == str) {\n\t\tcmd = setup_cmd(str, &vnc_redirect, &vnc_redirect_host, &vnc_redirect_port, db);\n\t}\n\t\n\tfb_image = &ximage_struct;\n\tsetup_fake_fb(fb_image, w, h, b);\n\n\tif (! dt) {\n\t\tchar *s;\n\t\targv[*argc] = strdup(\"-desktop\");\n\t\t*argc = (*argc) + 1;\n\n\t\tif (cmd) {\n\t\t\tchar *q;\n\t\t\ts = choose_title(\":0\");\n\t\t\tq = strstr(s, \":0\");\n\t\t\tif (q) {\n\t\t\t\t*q = '\\0';\n\t\t\t}\n\t\t} else {\n\t\t\ts = choose_title(str);\n\t\t}\n\t\trfb_desktop_name = strdup(s);\n\t\targv[*argc] = s;\n\t\t*argc = (*argc) + 1;\n\t}\n\n\tncache_save = ncache;\n\tncache = 0;\n\n\tinitialize_allowed_input();\n\n\tif (! multiple_cursors_mode) {\n\t\tmultiple_cursors_mode = strdup(\"default\");\n\t}\n\tinitialize_cursors_mode();\n\t\n\tinitialize_screen(argc, argv, fb_image);\n\n\tif (! inetd && ! use_openssl) {\n\t\tif (! screen->port || screen->listenSock < 0) {\n\t\t\tif (got_rfbport && got_rfbport_val == 0) {\n\t\t\t\t;\n\t\t\t} else if (ipv6_listen && ipv6_listen_fd >= 0) {\n\t\t\t\trfbLog(\"Info: listening on IPv6 interface only.  (wait for client)\\n\");\n\t\t\t} else {\n\t\t\t\trfbLogEnable(1);\n\t\t\t\trfbLog(\"Error: could not obtain listening port.  (wait for client)\\n\");\n\t\t\t\tif (!got_rfbport && !got_ipv6_listen) {\n\t\t\t\t\trfbLog(\"If this system is IPv6-only, use the -6 option.\\n\");\n\t\t\t\t}\n\t\t\t\tclean_up_exit(1);\n\t\t\t}\n\t\t}\n\t}\n\n\tinitialize_signals();\n\n\tif (ssh_str != NULL) {\n\t\tssh_remote_tunnel(ssh_str, screen->port);\n\t}\n\n\tif (! raw_fb) {\n\t\tchg_raw_fb = 1;\n\t\t/* kludge to get RAWFB_RET with dpy == NULL guards */\n\t\traw_fb = (char *) 0x1;\n\t}\n\n\tif (cmd && !strcmp(cmd, \"HTTPONCE\")) {\n\t\thandle_one_http_request();\t\n\t\tclean_up_exit(0);\n\t}\n\n\tif (http && check_httpdir()) {\n\t\thttp_connections(1);\n\t}\n\n\tif (cmd && unixpw) {\n\t\tkeep_unixpw = 1;\n\t}\n\n\tsetup_service();\n\n\tcheck_waitbg();\n\n\tif (vnc_redirect) {\n\t\tvnc_redirect_loop(vnc_redirect_test, &vnc_redirect_cnt);\n\t} else {\n\n\t\tif (use_threads && !started_rfbRunEventLoop) {\n\t\t\tstarted_rfbRunEventLoop = 1;\n\t\t\trfbRunEventLoop(screen, -1, TRUE);\n\t\t}\n\n\t\tif (inetd && use_openssl) {\n\t\t\taccept_openssl(OPENSSL_INETD, -1);\n\t\t}\n\n\t\tsetup_client_connect(&did_client_connect);\n\n\t\tloop_for_connect(did_client_connect);\n\n\t\tif (unixpw) {\n\t\t\tif (cmd && strstr(cmd, \"FINDCREATEDISPLAY\") == cmd) {\n\t\t\t\tif (users_list && strstr(users_list, \"unixpw=\") == users_list) {\n\t\t\t\t\tusers_list_save = users_list;\n\t\t\t\t\tusers_list = NULL;\n\t\t\t\t}\n\t\t\t}\n\t\t\tdo_unixpw_loop();\n\t\t} else if (cmd && !use_threads) {\n\t\t\t/* try to get RFB proto done now. */\n\t\t\tprogress_client();\n\t\t}\n\t}\n\n\tif (vnc_redirect == 2) {\n\t\t;\n\t} else if (cmd) {\n\t\tif (!do_run_cmd(cmd, create_cmd, users_list_save, created_disp, db)) {\n\t\t\treturn 0;\n\t\t}\n\t} else {\n\t\tuse_dpy = strdup(str);\n\t}\n\tif (chg_raw_fb) {\n\t\traw_fb = NULL;\n\t}\n\n\tncache = ncache_save;\n\n\tif (unixpw && keep_unixpw_opts && keep_unixpw_opts[0] != '\\0') {\n\t\tuser_supplied_opts(keep_unixpw_opts);\n\t}\n\tif (create_cmd) {\n\t\tfree(create_cmd);\n\t}\n\n\tif (vnc_redirect) {\n\t\tdo_vnc_redirect(created_disp, vnc_redirect_host, vnc_redirect_port,\n\t\t    vnc_redirect_cnt, vnc_redirect_test);\n\t\tclean_up_exit(0);\n\t}\n\n\treturn 1;\n}",
    "includes": [
      "#include \"avahi.h\"",
      "#include \"sslhelper.h\"",
      "#include \"remote.h\"",
      "#include \"cursor.h\"",
      "#include \"keyboard.h\"",
      "#include \"inet.h\"",
      "#include \"connections.h\"",
      "#include \"xwrappers.h\"",
      "#include \"sslhelper.h\"",
      "#include \"unixpw.h\"",
      "#include \"screen.h\"",
      "#include \"scan.h\"",
      "#include \"cleanup.h\"",
      "#include \"solid.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "void lurk_loop(char *str);",
      "void progress_client(void);",
      "int wait_for_client(int *argc, char** argv, int http);",
      "char *xdmcp_insert = NULL;",
      "void ssh_remote_tunnel(char *, int);",
      "static XImage ximage_struct;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "clean_up_exit",
          "args": [
            "0"
          ],
          "line": 3153
        },
        "resolved": true,
        "details": {
          "function_name": "clean_up_exit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/cleanup.c",
          "lines": "151-266",
          "snippet": "void clean_up_exit(int ret) {\n\tstatic int depth = 0;\n\texit_flag = 1;\n\n\tif (depth++ > 2) {\n\t\texit(ret);\n\t}\n\n\tif (icon_mode) {\n\t\tclean_icon_mode();\n\t}\n\n\t/* remove the shm areas: */\n\tclean_shm(0);\n\n\tstop_stunnel();\n\tif (use_openssl) {\n\t\tssl_helper_pid(0, 0);\t/* killall */\n\t}\n\n\tif (ssh_pid > 0) {\n\t\tkill(ssh_pid, SIGTERM);\n\t\tssh_pid = 0;\n\t}\n\n#ifdef MACOSX\n\tif (client_connect_file) {\n\t\tif (strstr(client_connect_file, \"/tmp/x11vnc-macosx-remote\")\n\t\t    == client_connect_file) {\n\t\t\tunlink(client_connect_file);\n\t\t}\n\t}\n\tif (macosx_console) {\n\t\tmacosxCG_fini();\n\t}\n#endif\n\n\tif (pipeinput_fh != NULL) {\n\t\tpclose(pipeinput_fh);\n\t\tpipeinput_fh = NULL;\n\t}\n\n\tshutdown_uinput();\n\n\tif (unix_sock) {\n\t\tif (unix_sock_fd >= 0) {\n\t\t\trfbLog(\"deleting unix sock: %s\\n\", unix_sock);\n\t\t\tclose(unix_sock_fd);\n\t\t\tunix_sock_fd = -1;\n\t\t\tunlink(unix_sock);\n\t\t}\n\t}\n\n\tif (! dpy) {\t/* raw_rb hack */\n\t\tif (rm_flagfile) {\n\t\t\tunlink(rm_flagfile);\n\t\t\trm_flagfile = NULL;\n\t\t}\n\t\texit(ret);\n\t}\n\n\t/* X keyboard cleanups */\n\tdelete_added_keycodes(0);\n\n\t/* remove all created XInput2 devices */\n\tif(use_multipointer)\n\t    removeAllMDs(dpy);\n\n\tif (clear_mods == 1) {\n\t\tclear_modifiers(0);\n\t} else if (clear_mods == 2) {\n\t\tclear_keys();\n\t} else if (clear_mods == 3) {\n\t\tclear_keys();\n\t\tclear_locks();\n\t}\n\n\tif (no_autorepeat) {\n\t\tautorepeat(1, 0);\n\t}\n\tif (use_solid_bg) {\n\t\tsolid_bg(1);\n\t}\n\tif (ncache || ncache0) {\n\t\tkde_no_animate(1);\n\t}\n\tX_LOCK;\n\tXTestDiscard_wr(dpy);\n#if HAVE_LIBXDAMAGE\n\tif (xdamage) {\n\t\tXDamageDestroy(dpy, xdamage);\n\t}\n#endif\n#if HAVE_LIBXTRAP\n\tif (trap_ctx) {\n\t\tXEFreeTC(trap_ctx);\n\t}\n#endif\n\t/* XXX rdpy_ctrl, etc. cannot close w/o blocking */\n\tXCloseDisplay_wr(dpy);\n\tX_UNLOCK;\n\n\tfflush(stderr);\n\n\tif (rm_flagfile) {\n\t\tunlink(rm_flagfile);\n\t\trm_flagfile = NULL;\n\t}\n\n\tif (avahi) {\n\t\tavahi_cleanup();\n\t\tfflush(stderr);\n\t}\n\n\texit(ret);\n}",
          "includes": [
            "#include \"xi2_devices.h\"",
            "#include \"uinput.h\"",
            "#include \"xevents.h\"",
            "#include \"xrecord.h\"",
            "#include \"screen.h\"",
            "#include \"avahi.h\"",
            "#include \"macosxCG.h\"",
            "#include \"macosx.h\"",
            "#include \"connections.h\"",
            "#include \"sslhelper.h\"",
            "#include \"sslcmds.h\"",
            "#include \"unixpw.h\"",
            "#include \"solid.h\"",
            "#include \"gui.h\"",
            "#include \"scan.h\"",
            "#include \"keyboard.h\"",
            "#include \"remote.h\"",
            "#include \"xdamage.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void clean_up_exit(int ret);",
            "int known_sigpipe_mode(char *s);",
            "static int exit_flag = 0;",
            "static void clean_icon_mode(void);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xi2_devices.h\"\n#include \"uinput.h\"\n#include \"xevents.h\"\n#include \"xrecord.h\"\n#include \"screen.h\"\n#include \"avahi.h\"\n#include \"macosxCG.h\"\n#include \"macosx.h\"\n#include \"connections.h\"\n#include \"sslhelper.h\"\n#include \"sslcmds.h\"\n#include \"unixpw.h\"\n#include \"solid.h\"\n#include \"gui.h\"\n#include \"scan.h\"\n#include \"keyboard.h\"\n#include \"remote.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nvoid clean_up_exit(int ret);\nint known_sigpipe_mode(char *s);\nstatic int exit_flag = 0;\nstatic void clean_icon_mode(void);\n\nvoid clean_up_exit(int ret) {\n\tstatic int depth = 0;\n\texit_flag = 1;\n\n\tif (depth++ > 2) {\n\t\texit(ret);\n\t}\n\n\tif (icon_mode) {\n\t\tclean_icon_mode();\n\t}\n\n\t/* remove the shm areas: */\n\tclean_shm(0);\n\n\tstop_stunnel();\n\tif (use_openssl) {\n\t\tssl_helper_pid(0, 0);\t/* killall */\n\t}\n\n\tif (ssh_pid > 0) {\n\t\tkill(ssh_pid, SIGTERM);\n\t\tssh_pid = 0;\n\t}\n\n#ifdef MACOSX\n\tif (client_connect_file) {\n\t\tif (strstr(client_connect_file, \"/tmp/x11vnc-macosx-remote\")\n\t\t    == client_connect_file) {\n\t\t\tunlink(client_connect_file);\n\t\t}\n\t}\n\tif (macosx_console) {\n\t\tmacosxCG_fini();\n\t}\n#endif\n\n\tif (pipeinput_fh != NULL) {\n\t\tpclose(pipeinput_fh);\n\t\tpipeinput_fh = NULL;\n\t}\n\n\tshutdown_uinput();\n\n\tif (unix_sock) {\n\t\tif (unix_sock_fd >= 0) {\n\t\t\trfbLog(\"deleting unix sock: %s\\n\", unix_sock);\n\t\t\tclose(unix_sock_fd);\n\t\t\tunix_sock_fd = -1;\n\t\t\tunlink(unix_sock);\n\t\t}\n\t}\n\n\tif (! dpy) {\t/* raw_rb hack */\n\t\tif (rm_flagfile) {\n\t\t\tunlink(rm_flagfile);\n\t\t\trm_flagfile = NULL;\n\t\t}\n\t\texit(ret);\n\t}\n\n\t/* X keyboard cleanups */\n\tdelete_added_keycodes(0);\n\n\t/* remove all created XInput2 devices */\n\tif(use_multipointer)\n\t    removeAllMDs(dpy);\n\n\tif (clear_mods == 1) {\n\t\tclear_modifiers(0);\n\t} else if (clear_mods == 2) {\n\t\tclear_keys();\n\t} else if (clear_mods == 3) {\n\t\tclear_keys();\n\t\tclear_locks();\n\t}\n\n\tif (no_autorepeat) {\n\t\tautorepeat(1, 0);\n\t}\n\tif (use_solid_bg) {\n\t\tsolid_bg(1);\n\t}\n\tif (ncache || ncache0) {\n\t\tkde_no_animate(1);\n\t}\n\tX_LOCK;\n\tXTestDiscard_wr(dpy);\n#if HAVE_LIBXDAMAGE\n\tif (xdamage) {\n\t\tXDamageDestroy(dpy, xdamage);\n\t}\n#endif\n#if HAVE_LIBXTRAP\n\tif (trap_ctx) {\n\t\tXEFreeTC(trap_ctx);\n\t}\n#endif\n\t/* XXX rdpy_ctrl, etc. cannot close w/o blocking */\n\tXCloseDisplay_wr(dpy);\n\tX_UNLOCK;\n\n\tfflush(stderr);\n\n\tif (rm_flagfile) {\n\t\tunlink(rm_flagfile);\n\t\trm_flagfile = NULL;\n\t}\n\n\tif (avahi) {\n\t\tavahi_cleanup();\n\t\tfflush(stderr);\n\t}\n\n\texit(ret);\n}"
        }
      },
      {
        "call_info": {
          "callee": "do_vnc_redirect",
          "args": [
            "created_disp",
            "vnc_redirect_host",
            "vnc_redirect_port",
            "vnc_redirect_cnt",
            "vnc_redirect_test"
          ],
          "line": 3151
        },
        "resolved": true,
        "details": {
          "function_name": "do_vnc_redirect",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/user.c",
          "lines": "1823-1880",
          "snippet": "static void do_vnc_redirect(int created_disp, char *vnc_redirect_host, int vnc_redirect_port,\n    int vnc_redirect_cnt, char *vnc_redirect_test) {\n\tchar *q = strrchr(use_dpy, ':');\n\tint vdpy = -1, sock = -1;\n\tint s_in, s_out, i;\n\tif (vnc_redirect == 2) {\n\t\tchar num[32];\t\n\t\tsprintf(num, \":%d\", vnc_redirect_port);\n\t\tq = num;\n\t}\n\tif (!q) {\n\t\trfbLog(\"wait_for_client: can't find number in X display: %s\\n\", use_dpy);\n\t\tclean_up_exit(1);\n\t}\n\tif (sscanf(q+1, \"%d\", &vdpy) != 1) {\n\t\trfbLog(\"wait_for_client: can't find number in X display: %s\\n\", q);\n\t\tclean_up_exit(1);\n\t}\n\tif (vdpy == -1 && vnc_redirect != 2) {\n\t\trfbLog(\"wait_for_client: can't find number in X display: %s\\n\", q);\n\t\tclean_up_exit(1);\n\t}\n\tif (vnc_redirect == 2) {\n\t\tif (vdpy < 0) {\n\t\t\tvdpy = -vdpy;\n\t\t} else if (vdpy < 200) {\n\t\t\tvdpy += 5900;\n\t\t}\n\t} else {\n\t\tvdpy += 5900;\n\t}\n\tif (created_disp) {\n\t\tusleep(1000*1000);\n\t}\n\tfor (i=0; i < 20; i++) {\n\t\tsock = connect_tcp(vnc_redirect_host, vdpy);\n\t\tif (sock >= 0) {\n\t\t\tbreak;\n\t\t}\n\t\trfbLog(\"wait_for_client: ...\\n\");\n\t\tusleep(500*1000);\n\t}\n\tif (sock < 0) {\n\t\trfbLog(\"wait_for_client: could not connect to a VNC Server at %s:%d\\n\", vnc_redirect_host, vdpy);\n\t\tclean_up_exit(1);\n\t}\n\tif (inetd) {\n\t\ts_in  = fileno(stdin);\n\t\ts_out = fileno(stdout);\n\t} else {\n\t\ts_in = s_out = vnc_redirect_sock;\n\t}\n\tif (vnc_redirect_cnt > 0) {\n\t\twrite(vnc_redirect_sock, vnc_redirect_test, vnc_redirect_cnt);\n\t}\n\trfbLog(\"wait_for_client: switching control to VNC Server at %s:%d\\n\", vnc_redirect_host, vdpy);\n\traw_xfer(sock, s_in, s_out);\n}",
          "includes": [
            "#include \"avahi.h\"",
            "#include \"sslhelper.h\"",
            "#include \"remote.h\"",
            "#include \"cursor.h\"",
            "#include \"keyboard.h\"",
            "#include \"inet.h\"",
            "#include \"connections.h\"",
            "#include \"xwrappers.h\"",
            "#include \"sslhelper.h\"",
            "#include \"unixpw.h\"",
            "#include \"screen.h\"",
            "#include \"scan.h\"",
            "#include \"cleanup.h\"",
            "#include \"solid.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"avahi.h\"\n#include \"sslhelper.h\"\n#include \"remote.h\"\n#include \"cursor.h\"\n#include \"keyboard.h\"\n#include \"inet.h\"\n#include \"connections.h\"\n#include \"xwrappers.h\"\n#include \"sslhelper.h\"\n#include \"unixpw.h\"\n#include \"screen.h\"\n#include \"scan.h\"\n#include \"cleanup.h\"\n#include \"solid.h\"\n#include \"x11vnc.h\"\n\nstatic void do_vnc_redirect(int created_disp, char *vnc_redirect_host, int vnc_redirect_port,\n    int vnc_redirect_cnt, char *vnc_redirect_test) {\n\tchar *q = strrchr(use_dpy, ':');\n\tint vdpy = -1, sock = -1;\n\tint s_in, s_out, i;\n\tif (vnc_redirect == 2) {\n\t\tchar num[32];\t\n\t\tsprintf(num, \":%d\", vnc_redirect_port);\n\t\tq = num;\n\t}\n\tif (!q) {\n\t\trfbLog(\"wait_for_client: can't find number in X display: %s\\n\", use_dpy);\n\t\tclean_up_exit(1);\n\t}\n\tif (sscanf(q+1, \"%d\", &vdpy) != 1) {\n\t\trfbLog(\"wait_for_client: can't find number in X display: %s\\n\", q);\n\t\tclean_up_exit(1);\n\t}\n\tif (vdpy == -1 && vnc_redirect != 2) {\n\t\trfbLog(\"wait_for_client: can't find number in X display: %s\\n\", q);\n\t\tclean_up_exit(1);\n\t}\n\tif (vnc_redirect == 2) {\n\t\tif (vdpy < 0) {\n\t\t\tvdpy = -vdpy;\n\t\t} else if (vdpy < 200) {\n\t\t\tvdpy += 5900;\n\t\t}\n\t} else {\n\t\tvdpy += 5900;\n\t}\n\tif (created_disp) {\n\t\tusleep(1000*1000);\n\t}\n\tfor (i=0; i < 20; i++) {\n\t\tsock = connect_tcp(vnc_redirect_host, vdpy);\n\t\tif (sock >= 0) {\n\t\t\tbreak;\n\t\t}\n\t\trfbLog(\"wait_for_client: ...\\n\");\n\t\tusleep(500*1000);\n\t}\n\tif (sock < 0) {\n\t\trfbLog(\"wait_for_client: could not connect to a VNC Server at %s:%d\\n\", vnc_redirect_host, vdpy);\n\t\tclean_up_exit(1);\n\t}\n\tif (inetd) {\n\t\ts_in  = fileno(stdin);\n\t\ts_out = fileno(stdout);\n\t} else {\n\t\ts_in = s_out = vnc_redirect_sock;\n\t}\n\tif (vnc_redirect_cnt > 0) {\n\t\twrite(vnc_redirect_sock, vnc_redirect_test, vnc_redirect_cnt);\n\t}\n\trfbLog(\"wait_for_client: switching control to VNC Server at %s:%d\\n\", vnc_redirect_host, vdpy);\n\traw_xfer(sock, s_in, s_out);\n}"
        }
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "create_cmd"
          ],
          "line": 3147
        },
        "resolved": true,
        "details": {
          "function_name": "free_rect",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/userinput.c",
          "lines": "6200-6247",
          "snippet": "int free_rect(int idx) {\n\tint n, ok = 0;\n\tsraRegionPtr r1, r2;\n\tint x, y, w, h;\n\n\tif (idx < 0 || idx >= cache_list_num) {\nif (0) fprintf(stderr, \"free_rect: bad index: %d\\n\", idx);\n\t\tclean_up_exit(1);\n\t}\n\n\tx = cache_list[idx].bs_x;\n\ty = cache_list[idx].bs_y;\n\tw = cache_list[idx].bs_w;\n\th = cache_list[idx].bs_h;\n\n\tif (x < 0) {\n\t\tCLEAR(idx);\nif (dnow() > last_client + 5 && ncdb) fprintf(stderr, \"free_rect: already bs_x invalidated: %d bs_x: %d\\n\", idx, x);\n\t\treturn 1;\n\t}\n\n\tr2 = sraRgnCreateRect(x, y, x+w, y+h);\n\n\tn = get_bs_n(y);\n\tif (n >= 0) {\n\t\tr1 = rect_reg[n];\n\t\tsraRgnOr(r1, r2);\n\t\tok = 1;\n\t}\n\n\tif (zero_rects) {\n\t\tsraRgnOr(zero_rects, r2);\n\t\tx = cache_list[idx].su_x;\n\t\ty = cache_list[idx].su_y;\n\t\tw = cache_list[idx].su_w;\n\t\th = cache_list[idx].su_h;\n\t\tif (x >= 0) {\n\t\t\tsraRgnDestroy(r2);\n\t\t\tr2 = sraRgnCreateRect(x, y, x+w, y+h);\n\t\t\tsraRgnOr(zero_rects, r2);\n\t\t}\n\t}\n\tsraRgnDestroy(r2);\n\n\tCLEAR(idx);\nif (! ok && ncdb) fprintf(stderr, \"**** free_rect: not-found %d\\n\", idx);\n\treturn ok;\n}",
          "includes": [
            "#include \"default8x16.h\"",
            "#include \"connections.h\"",
            "#include \"screen.h\"",
            "#include \"cursor.h\"",
            "#include \"macosxCGS.h\"",
            "#include \"macosx.h\"",
            "#include \"unixpw.h\"",
            "#include \"8to24.h\"",
            "#include \"xrandr.h\"",
            "#include \"solid.h\"",
            "#include \"keyboard.h\"",
            "#include \"rates.h\"",
            "#include \"pointer.h\"",
            "#include \"cleanup.h\"",
            "#include \"scan.h\"",
            "#include \"user.h\"",
            "#include \"xevents.h\"",
            "#include \"win_utils.h\"",
            "#include \"xinerama.h\"",
            "#include \"xrecord.h\"",
            "#include \"xdamage.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void mark_for_xdamage(int x, int y, int w, int h);",
            "void set_xdamage_mark(int x, int y, int w, int h);",
            "int find_rect(int idx, int x, int y, int w, int h);",
            "winattr_t *cache_list;",
            "int clipped(int idx);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"default8x16.h\"\n#include \"connections.h\"\n#include \"screen.h\"\n#include \"cursor.h\"\n#include \"macosxCGS.h\"\n#include \"macosx.h\"\n#include \"unixpw.h\"\n#include \"8to24.h\"\n#include \"xrandr.h\"\n#include \"solid.h\"\n#include \"keyboard.h\"\n#include \"rates.h\"\n#include \"pointer.h\"\n#include \"cleanup.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"xevents.h\"\n#include \"win_utils.h\"\n#include \"xinerama.h\"\n#include \"xrecord.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nvoid mark_for_xdamage(int x, int y, int w, int h);\nvoid set_xdamage_mark(int x, int y, int w, int h);\nint find_rect(int idx, int x, int y, int w, int h);\nwinattr_t *cache_list;\nint clipped(int idx);\n\nint free_rect(int idx) {\n\tint n, ok = 0;\n\tsraRegionPtr r1, r2;\n\tint x, y, w, h;\n\n\tif (idx < 0 || idx >= cache_list_num) {\nif (0) fprintf(stderr, \"free_rect: bad index: %d\\n\", idx);\n\t\tclean_up_exit(1);\n\t}\n\n\tx = cache_list[idx].bs_x;\n\ty = cache_list[idx].bs_y;\n\tw = cache_list[idx].bs_w;\n\th = cache_list[idx].bs_h;\n\n\tif (x < 0) {\n\t\tCLEAR(idx);\nif (dnow() > last_client + 5 && ncdb) fprintf(stderr, \"free_rect: already bs_x invalidated: %d bs_x: %d\\n\", idx, x);\n\t\treturn 1;\n\t}\n\n\tr2 = sraRgnCreateRect(x, y, x+w, y+h);\n\n\tn = get_bs_n(y);\n\tif (n >= 0) {\n\t\tr1 = rect_reg[n];\n\t\tsraRgnOr(r1, r2);\n\t\tok = 1;\n\t}\n\n\tif (zero_rects) {\n\t\tsraRgnOr(zero_rects, r2);\n\t\tx = cache_list[idx].su_x;\n\t\ty = cache_list[idx].su_y;\n\t\tw = cache_list[idx].su_w;\n\t\th = cache_list[idx].su_h;\n\t\tif (x >= 0) {\n\t\t\tsraRgnDestroy(r2);\n\t\t\tr2 = sraRgnCreateRect(x, y, x+w, y+h);\n\t\t\tsraRgnOr(zero_rects, r2);\n\t\t}\n\t}\n\tsraRgnDestroy(r2);\n\n\tCLEAR(idx);\nif (! ok && ncdb) fprintf(stderr, \"**** free_rect: not-found %d\\n\", idx);\n\treturn ok;\n}"
        }
      },
      {
        "call_info": {
          "callee": "user_supplied_opts",
          "args": [
            "keep_unixpw_opts"
          ],
          "line": 3144
        },
        "resolved": true,
        "details": {
          "function_name": "user_supplied_opts",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/user.c",
          "lines": "1254-1393",
          "snippet": "void user_supplied_opts(char *opts) {\n\tchar *p, *str;\n\tchar *allow[] = {\n\t\t\"skip-display\", \"skip-auth\", \"skip-shared\",\n\t\t\"scale\", \"scale_cursor\", \"sc\", \"solid\", \"so\", \"id\",\n\t\t\"clear_mods\", \"cm\", \"clear_keys\", \"ck\", \"repeat\",\n\t\t\"clear_all\", \"ca\",\n\t\t\"speeds\", \"sp\", \"readtimeout\", \"rd\",\n\t\t\"rotate\", \"ro\",\n\t\t\"geometry\", \"geom\", \"ge\",\n\t\t\"noncache\", \"nc\",\n\t\t\"nodisplay\", \"nd\",\n\t\t\"viewonly\", \"vo\",\n\t\t\"tag\",\n\t\tNULL\n\t};\n\n\tif (getenv(\"X11VNC_NO_UNIXPW_OPTS\")) {\n\t\treturn;\n\t}\n\n\tstr = strdup(opts);\n\n\tp = strtok(str, \",\");\n\twhile (p) {\n\t\tchar *q;\n\t\tint i, n, m, ok = 0;\n\n\t\ti = 0;\n\t\twhile (allow[i] != NULL) {\n\t\t\tif (strstr(allow[i], \"skip-\")) {\n\t\t\t\ti++;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (strstr(p, allow[i]) == p) \t{\n\t\t\t\tok = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\ti++;\n\t\t}\n\n\t\tif (! ok && strpbrk(p, \"0123456789\") == p &&\n\t\t    sscanf(p, \"%d/%d\", &n, &m) == 2) {\n\t\t\tif (scale_str) free(scale_str);\n\t\t\tscale_str = strdup(p);\n\t\t} else if (ok) {\n\t\t\tif (0 && strstr(p, \"display=\") == p) {\n\t\t\t\tif (use_dpy) free(use_dpy);\n\t\t\t\tuse_dpy = strdup(p + strlen(\"display=\"));\n\t\t\t} else if (0 && strstr(p, \"auth=\") == p) {\n\t\t\t\tif (auth_file) free(auth_file);\n\t\t\t\tauth_file = strdup(p + strlen(\"auth=\"));\n\t\t\t} else if (0 && !strcmp(p, \"shared\")) {\n\t\t\t\tshared = 1;\n\t\t\t} else if (strstr(p, \"scale=\") == p) {\n\t\t\t\tif (scale_str) free(scale_str);\n\t\t\t\tscale_str = strdup(p + strlen(\"scale=\"));\n\t\t\t} else if (strstr(p, \"scale_cursor=\") == p ||\n\t\t\t    strstr(p, \"sc=\") == p) {\n\t\t\t\tif (scale_cursor_str) free(scale_cursor_str);\n\t\t\t\tq = strchr(p, '=') + 1;\n\t\t\t\tscale_cursor_str = strdup(q);\n\t\t\t} else if (strstr(p, \"rotate=\") == p ||\n\t\t\t    strstr(p, \"ro=\") == p) {\n\t\t\t\tif (rotating_str) free(rotating_str);\n\t\t\t\tq = strchr(p, '=') + 1;\n\t\t\t\trotating_str = strdup(q);\n\t\t\t} else if (!strcmp(p, \"solid\") || !strcmp(p, \"so\")) {\n\t\t\t\tuse_solid_bg = 1;\n\t\t\t\tif (!solid_str) {\n\t\t\t\t\tsolid_str = strdup(solid_default);\n\t\t\t\t}\n\t\t\t} else if (!strcmp(p, \"viewonly\") || !strcmp(p, \"vo\")) {\n\t\t\t\tview_only = 1;\n\t\t\t} else if (strstr(p, \"solid=\") == p ||\n\t\t\t    strstr(p, \"so=\") == p) {\n\t\t\t\tuse_solid_bg = 1;\n\t\t\t\tif (solid_str) free(solid_str);\n\t\t\t\tq = strchr(p, '=') + 1;\n\t\t\t\tif (!strcmp(q, \"R\")) {\n\t\t\t\t\tsolid_str = strdup(\"root:\");\n\t\t\t\t} else {\n\t\t\t\t\tsolid_str = strdup(q);\n\t\t\t\t}\n\t\t\t} else if (strstr(p, \"id=\") == p) {\n\t\t\t\tunsigned long win;\n\t\t\t\tq = p + strlen(\"id=\");\n\t\t\t\tif (strcmp(q, \"pick\")) {\n\t\t\t\t\tif (scan_hexdec(q, &win)) {\n\t\t\t\t\t\tsubwin = win;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else if (!strcmp(p, \"clear_mods\") ||\n\t\t\t    !strcmp(p, \"cm\")) {\n\t\t\t\tclear_mods = 1;\n\t\t\t} else if (!strcmp(p, \"clear_keys\") ||\n\t\t\t    !strcmp(p, \"ck\")) {\n\t\t\t\tclear_mods = 2;\n\t\t\t} else if (!strcmp(p, \"clear_all\") ||\n\t\t\t    !strcmp(p, \"ca\")) {\n\t\t\t\tclear_mods = 3;\n\t\t\t} else if (!strcmp(p, \"noncache\") ||\n\t\t\t    !strcmp(p, \"nc\")) {\n\t\t\t\tncache  = 0;\n\t\t\t\tncache0 = 0;\n\t\t\t} else if (strstr(p, \"nc=\") == p) {\n\t\t\t\tint n2 = atoi(p + strlen(\"nc=\"));\n\t\t\t\tif (nabs(n2) < nabs(ncache)) {\n\t\t\t\t\tif (ncache < 0) {\n\t\t\t\t\t\tncache = -nabs(n2);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tncache = nabs(n2);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else if (!strcmp(p, \"repeat\")) {\n\t\t\t\tno_autorepeat = 0;\n\t\t\t} else if (strstr(p, \"speeds=\") == p ||\n\t\t\t    strstr(p, \"sp=\") == p) {\n\t\t\t\tif (speeds_str) free(speeds_str);\n\t\t\t\tq = strchr(p, '=') + 1;\n\t\t\t\tspeeds_str = strdup(q);\n\t\t\t\tq = speeds_str;\n\t\t\t\twhile (*q != '\\0') {\n\t\t\t\t\tif (*q == '-') {\n\t\t\t\t\t\t*q = ',';\n\t\t\t\t\t}\n\t\t\t\t\tq++;\n\t\t\t\t}\n\t\t\t} else if (strstr(p, \"readtimeout=\") == p ||\n\t\t\t    strstr(p, \"rd=\") == p) {\n\t\t\t\tq = strchr(p, '=') + 1;\n\t\t\t\trfbMaxClientWait = atoi(q) * 1000;\n\t\t\t}\n\t\t} else {\n\t\t\trfbLog(\"skipping option: %s\\n\", p);\n\t\t}\n\t\tp = strtok(NULL, \",\");\n\t}\n\tfree(str);\n}",
          "includes": [
            "#include \"avahi.h\"",
            "#include \"sslhelper.h\"",
            "#include \"remote.h\"",
            "#include \"cursor.h\"",
            "#include \"keyboard.h\"",
            "#include \"inet.h\"",
            "#include \"connections.h\"",
            "#include \"xwrappers.h\"",
            "#include \"sslhelper.h\"",
            "#include \"unixpw.h\"",
            "#include \"screen.h\"",
            "#include \"scan.h\"",
            "#include \"cleanup.h\"",
            "#include \"solid.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void lurk_loop(char *str);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"avahi.h\"\n#include \"sslhelper.h\"\n#include \"remote.h\"\n#include \"cursor.h\"\n#include \"keyboard.h\"\n#include \"inet.h\"\n#include \"connections.h\"\n#include \"xwrappers.h\"\n#include \"sslhelper.h\"\n#include \"unixpw.h\"\n#include \"screen.h\"\n#include \"scan.h\"\n#include \"cleanup.h\"\n#include \"solid.h\"\n#include \"x11vnc.h\"\n\nvoid lurk_loop(char *str);\n\nvoid user_supplied_opts(char *opts) {\n\tchar *p, *str;\n\tchar *allow[] = {\n\t\t\"skip-display\", \"skip-auth\", \"skip-shared\",\n\t\t\"scale\", \"scale_cursor\", \"sc\", \"solid\", \"so\", \"id\",\n\t\t\"clear_mods\", \"cm\", \"clear_keys\", \"ck\", \"repeat\",\n\t\t\"clear_all\", \"ca\",\n\t\t\"speeds\", \"sp\", \"readtimeout\", \"rd\",\n\t\t\"rotate\", \"ro\",\n\t\t\"geometry\", \"geom\", \"ge\",\n\t\t\"noncache\", \"nc\",\n\t\t\"nodisplay\", \"nd\",\n\t\t\"viewonly\", \"vo\",\n\t\t\"tag\",\n\t\tNULL\n\t};\n\n\tif (getenv(\"X11VNC_NO_UNIXPW_OPTS\")) {\n\t\treturn;\n\t}\n\n\tstr = strdup(opts);\n\n\tp = strtok(str, \",\");\n\twhile (p) {\n\t\tchar *q;\n\t\tint i, n, m, ok = 0;\n\n\t\ti = 0;\n\t\twhile (allow[i] != NULL) {\n\t\t\tif (strstr(allow[i], \"skip-\")) {\n\t\t\t\ti++;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (strstr(p, allow[i]) == p) \t{\n\t\t\t\tok = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\ti++;\n\t\t}\n\n\t\tif (! ok && strpbrk(p, \"0123456789\") == p &&\n\t\t    sscanf(p, \"%d/%d\", &n, &m) == 2) {\n\t\t\tif (scale_str) free(scale_str);\n\t\t\tscale_str = strdup(p);\n\t\t} else if (ok) {\n\t\t\tif (0 && strstr(p, \"display=\") == p) {\n\t\t\t\tif (use_dpy) free(use_dpy);\n\t\t\t\tuse_dpy = strdup(p + strlen(\"display=\"));\n\t\t\t} else if (0 && strstr(p, \"auth=\") == p) {\n\t\t\t\tif (auth_file) free(auth_file);\n\t\t\t\tauth_file = strdup(p + strlen(\"auth=\"));\n\t\t\t} else if (0 && !strcmp(p, \"shared\")) {\n\t\t\t\tshared = 1;\n\t\t\t} else if (strstr(p, \"scale=\") == p) {\n\t\t\t\tif (scale_str) free(scale_str);\n\t\t\t\tscale_str = strdup(p + strlen(\"scale=\"));\n\t\t\t} else if (strstr(p, \"scale_cursor=\") == p ||\n\t\t\t    strstr(p, \"sc=\") == p) {\n\t\t\t\tif (scale_cursor_str) free(scale_cursor_str);\n\t\t\t\tq = strchr(p, '=') + 1;\n\t\t\t\tscale_cursor_str = strdup(q);\n\t\t\t} else if (strstr(p, \"rotate=\") == p ||\n\t\t\t    strstr(p, \"ro=\") == p) {\n\t\t\t\tif (rotating_str) free(rotating_str);\n\t\t\t\tq = strchr(p, '=') + 1;\n\t\t\t\trotating_str = strdup(q);\n\t\t\t} else if (!strcmp(p, \"solid\") || !strcmp(p, \"so\")) {\n\t\t\t\tuse_solid_bg = 1;\n\t\t\t\tif (!solid_str) {\n\t\t\t\t\tsolid_str = strdup(solid_default);\n\t\t\t\t}\n\t\t\t} else if (!strcmp(p, \"viewonly\") || !strcmp(p, \"vo\")) {\n\t\t\t\tview_only = 1;\n\t\t\t} else if (strstr(p, \"solid=\") == p ||\n\t\t\t    strstr(p, \"so=\") == p) {\n\t\t\t\tuse_solid_bg = 1;\n\t\t\t\tif (solid_str) free(solid_str);\n\t\t\t\tq = strchr(p, '=') + 1;\n\t\t\t\tif (!strcmp(q, \"R\")) {\n\t\t\t\t\tsolid_str = strdup(\"root:\");\n\t\t\t\t} else {\n\t\t\t\t\tsolid_str = strdup(q);\n\t\t\t\t}\n\t\t\t} else if (strstr(p, \"id=\") == p) {\n\t\t\t\tunsigned long win;\n\t\t\t\tq = p + strlen(\"id=\");\n\t\t\t\tif (strcmp(q, \"pick\")) {\n\t\t\t\t\tif (scan_hexdec(q, &win)) {\n\t\t\t\t\t\tsubwin = win;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else if (!strcmp(p, \"clear_mods\") ||\n\t\t\t    !strcmp(p, \"cm\")) {\n\t\t\t\tclear_mods = 1;\n\t\t\t} else if (!strcmp(p, \"clear_keys\") ||\n\t\t\t    !strcmp(p, \"ck\")) {\n\t\t\t\tclear_mods = 2;\n\t\t\t} else if (!strcmp(p, \"clear_all\") ||\n\t\t\t    !strcmp(p, \"ca\")) {\n\t\t\t\tclear_mods = 3;\n\t\t\t} else if (!strcmp(p, \"noncache\") ||\n\t\t\t    !strcmp(p, \"nc\")) {\n\t\t\t\tncache  = 0;\n\t\t\t\tncache0 = 0;\n\t\t\t} else if (strstr(p, \"nc=\") == p) {\n\t\t\t\tint n2 = atoi(p + strlen(\"nc=\"));\n\t\t\t\tif (nabs(n2) < nabs(ncache)) {\n\t\t\t\t\tif (ncache < 0) {\n\t\t\t\t\t\tncache = -nabs(n2);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tncache = nabs(n2);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else if (!strcmp(p, \"repeat\")) {\n\t\t\t\tno_autorepeat = 0;\n\t\t\t} else if (strstr(p, \"speeds=\") == p ||\n\t\t\t    strstr(p, \"sp=\") == p) {\n\t\t\t\tif (speeds_str) free(speeds_str);\n\t\t\t\tq = strchr(p, '=') + 1;\n\t\t\t\tspeeds_str = strdup(q);\n\t\t\t\tq = speeds_str;\n\t\t\t\twhile (*q != '\\0') {\n\t\t\t\t\tif (*q == '-') {\n\t\t\t\t\t\t*q = ',';\n\t\t\t\t\t}\n\t\t\t\t\tq++;\n\t\t\t\t}\n\t\t\t} else if (strstr(p, \"readtimeout=\") == p ||\n\t\t\t    strstr(p, \"rd=\") == p) {\n\t\t\t\tq = strchr(p, '=') + 1;\n\t\t\t\trfbMaxClientWait = atoi(q) * 1000;\n\t\t\t}\n\t\t} else {\n\t\t\trfbLog(\"skipping option: %s\\n\", p);\n\t\t}\n\t\tp = strtok(NULL, \",\");\n\t}\n\tfree(str);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "str"
          ],
          "line": 3135
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "do_run_cmd",
          "args": [
            "cmd",
            "create_cmd",
            "users_list_save",
            "created_disp",
            "db"
          ],
          "line": 3131
        },
        "resolved": true,
        "details": {
          "function_name": "do_run_cmd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/user.c",
          "lines": "2464-2885",
          "snippet": "static int do_run_cmd(char *cmd, char *create_cmd, char *users_list_save, int created_disp, int db) {\n\tchar tmp[] = \"/tmp/x11vnc-find_display.XXXXXX\";\n\tchar line1[1024], line2[16384];\n\tchar *q, *usslpeer = NULL;\n\tint n, nodisp = 0, saw_xdmcp = 0;\n\tint tmp_fd = -1;\n\tint internal_cmd = 0;\n\tint tried_switch = 0;\n\n\tmemset(line1, 0, sizeof(line1));\n\tmemset(line2, 0, sizeof(line2));\n\n\tif (users_list && strstr(users_list, \"sslpeer=\") == users_list) {\n\t\tusslpeer = get_usslpeer();\n\t\tif (! usslpeer) {\n\t\t\treturn 0;\n\t\t}\n\t}\n\tif (getenv(\"DEBUG_RUN_CMD\")) db = 1;\n\n\t/* only sets environment variables: */\n\trun_user_command(\"\", latest_client, \"env\", NULL, 0, NULL);\n\n\tif (program_name) {\n\t\tset_env(\"X11VNC_PROG\", program_name);\n\t} else {\n\t\tset_env(\"X11VNC_PROG\", \"x11vnc\");\n\t}\n\n\tif (!strcmp(cmd, \"FINDDISPLAY\") ||\n\t    strstr(cmd, \"FINDCREATEDISPLAY\") == cmd) {\n\t\tchar *nd = \"\";\n\t\tchar *tag = \"\";\n\t\tchar fdout[128];\n\n\t\tinternal_cmd = 1;\n\n\t\ttmp_fd = mkstemp(tmp);\n\n\t\tif (tmp_fd < 0) {\n\t\t\trfbLog(\"wait_for_client: open failed: %s\\n\", tmp);\n\t\t\trfbLogPerror(\"mkstemp\");\n\t\t\tclean_up_exit(1);\n\t\t}\n\t\tchmod(tmp, 0644);\n\t\tif (getenv(\"X11VNC_FINDDISPLAY_ALWAYS_FAILS\")) {\n\t\t\tchar *s = \"#!/bin/sh\\necho _FAIL_\\nexit 1\\n\";\n\t\t\twrite(tmp_fd, s, strlen(s));\n\t\t} else {\n\t\t\twrite(tmp_fd, find_display, strlen(find_display));\n\t\t}\n\t\tclose(tmp_fd);\n\t\tnodisp = 1;\n\n\t\tif (strstr(cmd, \"FINDCREATEDISPLAY\") == cmd) {\n\t\t\tcreate_cmd = build_create_cmd(cmd, &saw_xdmcp, usslpeer, tmp);\n\t\t\tif (db) fprintf(stderr, \"create_cmd: %s\\n\", create_cmd);\n\t\t}\n\t\tif (getenv(\"X11VNC_SKIP_DISPLAY\")) {\n\t\t\tnd = strdup(getenv(\"X11VNC_SKIP_DISPLAY\"));\n\t\t}\n\t\tcheck_nodisplay(&nd, &tag);\n\n\t\tfdout[0] = '\\0';\n\t\tif (getenv(\"FIND_DISPLAY_OUTPUT\")) {\n\t\t\tsnprintf(fdout, sizeof fdout, \" FIND_DISPLAY_OUTPUT='%s' \", getenv(\"FIND_DISPLAY_OUTPUT\"));\n\t\t}\n\n\t\tcmd = (char *) malloc(strlen(\"env X11VNC_SKIP_DISPLAY='' \")\n\t\t    + strlen(nd) + strlen(\" FD_TAG='' \") + strlen(tag) + strlen(tmp) + strlen(\"/bin/sh \") + strlen(fdout) + 1);\n\n\t\tif (strcmp(tag, \"\")) {\n\t\t\tsprintf(cmd, \"env X11VNC_SKIP_DISPLAY='%s' FD_TAG='%s' %s /bin/sh %s\", nd, tag, fdout, tmp);\n\t\t} else {\n\t\t\tsprintf(cmd, \"env X11VNC_SKIP_DISPLAY='%s' %s /bin/sh %s\", nd, fdout, tmp);\n\t\t}\n\t}\n\n\trfbLog(\"wait_for_client: running: %s\\n\", cmd);\n\n\tif (create_cmd != NULL) {\n\t\tif (strstr(create_cmd, \"Xvfb\")) {\n\t\t\tpath_lookup(\"Xvfb\");\n\t\t}\n\t\tif (strstr(create_cmd, \"Xvnc\")) {\n\t\t\tpath_lookup(\"Xvnc\");\n\t\t}\n\t\tif (strstr(create_cmd, \"Xdummy\")) {\n\t\t\tpath_lookup(\"Xdummy\");\n\t\t}\n\t}\n\n\tif (unixpw && !unixpw_nis) {\n\t\tint res = 0, k, j, i;\n\t\tchar line[18000];\n\n\t\tmemset(line, 0, sizeof(line));\n\n\t\tif (unixpw_system_greeter_active == 2) {\n\t\t\trfbLog(\"unixpw_system_greeter: forcing find display failure.\\n\");\n\t\t\tres = 0;\n\t\t} else if (keep_unixpw_user && keep_unixpw_pass) {\n\t\t\tn = sizeof(line);\n\t\t\tif (unixpw_cmd != NULL) {\n\t\t\t\tres = unixpw_cmd_run(keep_unixpw_user,\n\t\t\t\t    keep_unixpw_pass, cmd, line, &n);\n\t\t\t} else {\n\t\t\t\tres = su_verify(keep_unixpw_user,\n\t\t\t\t    keep_unixpw_pass, cmd, line, &n, nodisp);\n\t\t\t}\n\t\t}\n\nif (db) {fprintf(stderr, \"line: \"); write(2, line, n); write(2, \"\\n\", 1); fprintf(stderr, \"res=%d n=%d\\n\", res, n);}\n\t\tif (! res) {\n\t\t\trfbLog(\"wait_for_client: find display cmd failed.\\n\");\n\t\t}\n\n\t\tif (! res && create_cmd) {\n\t\t\tFILE *mt = fopen(tmp, \"w\");\n\t\t\tif (! mt) {\n\t\t\t\trfbLog(\"wait_for_client: open failed: %s\\n\", tmp);\n\t\t\t\trfbLogPerror(\"fopen\");\n\t\t\t\tclean_up_exit(1);\n\t\t\t}\n\t\t\tfprintf(mt, \"%s\", create_display);\n\t\t\tfclose(mt);\n\n\t\t\tfindcreatedisplay = 1;\n\n\t\t\tif (unixpw_cmd != NULL) {\n\t\t\t\t/* let the external unixpw command do it: */\n\t\t\t\tn = sizeof(line);\n\t\t\t\tclose_exec_fds();\n\t\t\t\tres = unixpw_cmd_run(keep_unixpw_user,\n\t\t\t\t    keep_unixpw_pass, create_cmd, line, &n);\n\t\t\t} else if (getuid() != 0 && unixpw_system_greeter_active != 2) {\n\t\t\t\t/* if not root, run as the other user... */\n\t\t\t\tn = sizeof(line);\n\t\t\t\tclose_exec_fds();\n\t\t\t\tres = su_verify(keep_unixpw_user,\n\t\t\t\t    keep_unixpw_pass, create_cmd, line, &n, nodisp);\nif (db) fprintf(stderr, \"c-res=%d n=%d line: '%s'\\n\", res, n, line);\n\n\t\t\t} else {\n\t\t\t\tFILE *p;\n\t\t\t\tclose_exec_fds();\n\t\t\t\tif (unixpw_system_greeter_active == 2) {\n\t\t\t\t\trfbLog(\"unixpw_system_greeter: not trying su_verify() to run\\n\");\n\t\t\t\t\trfbLog(\"unixpw_system_greeter: create display command.\\n\");\n\t\t\t\t}\n\t\t\t\trfbLog(\"wait_for_client: running: %s\\n\", create_cmd);\n\t\t\t\tp = popen(create_cmd, \"r\");\n\t\t\t\tif (! p) {\n\t\t\t\t\trfbLog(\"wait_for_client: popen failed: %s\\n\", create_cmd);\n\t\t\t\t\tres = 0;\n\t\t\t\t} else if (fgets(line1, sizeof line1, p) == NULL) {\n\t\t\t\t\trfbLog(\"wait_for_client: read failed: %s\\n\", create_cmd);\n\t\t\t\t\tres = 0;\n\t\t\t\t} else {\n\t\t\t\t\tn = fread(line2, 1, sizeof line2, p);\n\t\t\t\t\tif (pclose(p) != 0) {\n\t\t\t\t\t\tres = 0;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tstrncpy(line, line1, 100);\n\t\t\t\t\t\tmemcpy(line + strlen(line1), line2, n);\nif (db) fprintf(stderr, \"line1: '%s'\\n\", line1);\n\t\t\t\t\t\tn += strlen(line1);\n\t\t\t\t\t\tcreated_disp = 1;\n\t\t\t\t\t\tres = 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (res && saw_xdmcp && unixpw_system_greeter_active != 2) {\n\t\t\t\txdmcp_insert = strdup(keep_unixpw_user);\n\t\t\t}\n\t\t}\n\n\t\tif (tmp_fd >= 0) {\n\t\t\tunlink(tmp);\n\t\t}\n\n\t\tif (! res) {\n\t\t\trfbLog(\"wait_for_client: cmd failed: %s\\n\", cmd);\n\t\t\tunixpw_msg(\"No DISPLAY found.\", 3);\n\t\t\tclean_up_exit(1);\n\t\t}\n\n\t\t/*\n\t\t * we need to hunt for DISPLAY= since there may be\n\t\t * a login banner or something at the beginning.\n\t\t */\n\t\tq = strstr(line, \"DISPLAY=\");\n\t\tif (! q) {\n\t\t\tq = line;\n\t\t}\n\t\tn -= (q - line);\n\n\t\tfor (k = 0; k < 1024; k++) {\n\t\t\tline1[k] = q[k];\n\t\t\tif (q[k] == '\\n') {\n\t\t\t\tk++;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tn -= k;\n\t\ti = 0;\n\t\tfor (j = 0; j < 16384; j++) {\n\t\t\tif (j < 16384 - 1) {\n\t\t\t\t/* xauth data, assume pty added CR */\n\t\t\t\tif (q[k+j] == '\\r' && q[k+j+1] == '\\n') {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tline2[i] = q[k+j];\n\t\t\ti++;\n\t\t}\nif (db) write(2, line, 100);\nif (db) fprintf(stderr, \"\\n\");\n\n\t} else {\n\t\tFILE *p;\n\t\tint rc;\n\t\tclose_exec_fds();\n\n\t\tif (usslpeer) {\n\t\t\tchar *c;\n\t\t\tif (getuid() == 0) {\n\t\t\t\tc = (char *) malloc(strlen(\"su - '' -c \\\"\")\n\t\t\t\t    + strlen(usslpeer) + strlen(cmd) + 1 + 1);\n\t\t\t\tsprintf(c, \"su - '%s' -c \\\"%s\\\"\", usslpeer, cmd);\n\t\t\t} else {\n\t\t\t\tc = strdup(cmd);\n\t\t\t}\n\t\t\tp = popen(c, \"r\");\n\t\t\tfree(c);\n\t\t\t\n\t\t} else if (unixpw_nis && keep_unixpw_user) {\n\t\t\tchar *c;\n\t\t\tif (getuid() == 0) {\n\t\t\t\tc = (char *) malloc(strlen(\"su - '' -c \\\"\")\n\t\t\t\t    + strlen(keep_unixpw_user) + strlen(cmd) + 1 + 1);\n\t\t\t\tsprintf(c, \"su - '%s' -c \\\"%s\\\"\", keep_unixpw_user, cmd);\n\t\t\t} else {\n\t\t\t\tc = strdup(cmd);\n\t\t\t}\n\t\t\tp = popen(c, \"r\");\n\t\t\tfree(c);\n\t\t\t\n\t\t} else {\n\t\t\tp = popen(cmd, \"r\");\n\t\t}\n\n\t\tif (! p) {\n\t\t\trfbLog(\"wait_for_client: cmd failed: %s\\n\", cmd);\n\t\t\trfbLogPerror(\"popen\");\n\t\t\tif (tmp_fd >= 0) {\n\t\t\t\tunlink(tmp);\n\t\t\t}\n\t\t\tclean_up_exit(1);\n\t\t}\n\t\tif (fgets(line1, sizeof line1, p) == NULL) {\n\t\t\trfbLog(\"wait_for_client: read failed: %s\\n\", cmd);\n\t\t\trfbLogPerror(\"fgets\");\n\t\t\tif (tmp_fd >= 0) {\n\t\t\t\tunlink(tmp);\n\t\t\t}\n\t\t\tclean_up_exit(1);\n\t\t}\n\t\tn = fread(line2, 1, sizeof line2, p);\n\t\trc = pclose(p);\n\n\t\tif (rc != 0) {\n\t\t\trfbLog(\"wait_for_client: find display cmd failed.\\n\");\n\t\t}\n\n\t\tif (create_cmd && rc != 0) {\n\t\t\tFILE *mt = fopen(tmp, \"w\");\n\t\t\tif (! mt) {\n\t\t\t\trfbLog(\"wait_for_client: open failed: %s\\n\", tmp);\n\t\t\t\trfbLogPerror(\"fopen\");\n\t\t\t\tif (tmp_fd >= 0) {\n\t\t\t\t\tunlink(tmp);\n\t\t\t\t}\n\t\t\t\tclean_up_exit(1);\n\t\t\t}\n\t\t\tfprintf(mt, \"%s\", create_display);\n\t\t\tfclose(mt);\n\n\t\t\tfindcreatedisplay = 1;\n\n\t\t\trfbLog(\"wait_for_client: FINDCREATEDISPLAY cmd: %s\\n\", create_cmd);\n\n\t\t\tp = popen(create_cmd, \"r\");\n\t\t\tif (! p) {\n\t\t\t\trfbLog(\"wait_for_client: cmd failed: %s\\n\", create_cmd);\n\t\t\t\trfbLogPerror(\"popen\");\n\t\t\t\tif (tmp_fd >= 0) {\n\t\t\t\t\tunlink(tmp);\n\t\t\t\t}\n\t\t\t\tclean_up_exit(1);\n\t\t\t}\n\t\t\tif (fgets(line1, sizeof line1, p) == NULL) {\n\t\t\t\trfbLog(\"wait_for_client: read failed: %s\\n\", create_cmd);\n\t\t\t\trfbLogPerror(\"fgets\");\n\t\t\t\tif (tmp_fd >= 0) {\n\t\t\t\t\tunlink(tmp);\n\t\t\t\t}\n\t\t\t\tclean_up_exit(1);\n\t\t\t}\n\t\t\tn = fread(line2, 1, sizeof line2, p);\n\t\t\tpclose(p);\n\t\t}\n\t\tif (tmp_fd >= 0) {\n\t\t\tunlink(tmp);\n\t\t}\n\t}\n\nif (db) fprintf(stderr, \"line1=%s\\n\", line1);\n\n\tif (strstr(line1, \"DISPLAY=\") != line1) {\n\t\trfbLog(\"wait_for_client: bad reply '%s'\\n\", line1);\n\t\tif (unixpw) {\n\t\t\tunixpw_msg(\"No DISPLAY found.\", 3);\n\t\t}\n\t\tclean_up_exit(1);\n\t}\n\n\n\tif (strstr(line1, \",VT=\")) {\n\t\tint vt;\n\t\tchar *t = strstr(line1, \",VT=\");\n\t\tvt = atoi(t + strlen(\",VT=\"));\n\t\t*t = '\\0';\n\t\tif (7 <= vt && vt <= 15) {\n\t\t\tdo_chvt(vt);\n\t\t}\n\t} else if (strstr(line1, \",XPID=\")) {\n\t\tint i, pvt, vt = -1;\n\t\tchar *t = strstr(line1, \",XPID=\");\n\t\tpvt = atoi(t + strlen(\",XPID=\"));\n\t\t*t = '\\0';\n\t\tif (pvt > 0) {\n\t\t\tfor (i=3; i <= 10; i++) {\n\t\t\t\tint k;\n\t\t\t\tchar proc[100];\n\t\t\t\tchar buf[100];\n\t\t\t\tsprintf(proc, \"/proc/%d/fd/%d\", pvt, i);\nif (db) fprintf(stderr, \"%d -- %s\\n\", i, proc);\n\t\t\t\tfor (k=0; k < 100; k++) {\n\t\t\t\t\tbuf[k] = '\\0';\n\t\t\t\t}\n\t\n\t\t\t\tif (readlink(proc, buf, sizeof buf) != -1) {\n\t\t\t\t\tbuf[100-1] = '\\0';\nif (db) fprintf(stderr, \"%d -- %s -- %s\\n\", i, proc, buf);\n\t\t\t\t\tif (strstr(buf, \"/dev/tty\") == buf) {\n\t\t\t\t\t\tvt = atoi(buf + strlen(\"/dev/tty\"));\n\t\t\t\t\t\tif (vt > 0) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (7 <= vt && vt <= 12) {\n\t\t\tdo_chvt(vt);\n\t\t}\n\t}\n\n\tuse_dpy = strdup(line1 + strlen(\"DISPLAY=\"));\n\tq = use_dpy;\n\twhile (*q != '\\0') {\n\t\tif (*q == '\\n' || *q == '\\r') *q = '\\0';\n\t\tq++;\n\t}\n\tif (line2[0] != '\\0') {\n\t\tif (strstr(line2, \"XAUTHORITY=\") == line2) {\n\t\t\tq = line2;\n\t\t\twhile (*q != '\\0') {\n\t\t\t\tif (*q == '\\n' || *q == '\\r') *q = '\\0';\n\t\t\t\tq++;\n\t\t\t}\n\t\t\tif (auth_file) {\n\t\t\t\tfree(auth_file);\n\t\t\t}\n\t\t\tauth_file = strdup(line2 + strlen(\"XAUTHORITY=\"));\n\n\t\t} else {\n\t\t\txauth_raw_data = (char *)malloc(n);\n\t\t\txauth_raw_len = n;\n\t\t\tmemcpy(xauth_raw_data, line2, n);\nif (db) {fprintf(stderr, \"xauth_raw_len: %d\\n\", n);\nwrite(2, xauth_raw_data, n);\nfprintf(stderr, \"\\n\");}\n\t\t}\n\t}\n\n\tif (!tried_switch) {\n\t\tdo_try_switch(usslpeer, users_list_save);\n\t\ttried_switch = 1;\n\t}\n\n\tif (unixpw) {\n\t\t/* Some cleanup and messaging for -unixpw case: */\n\t\tchar str[32];\n\n\t\tif (keep_unixpw_user && keep_unixpw_pass) {\n\t\t\tstrzero(keep_unixpw_user);\n\t\t\tstrzero(keep_unixpw_pass);\n\t\t\tkeep_unixpw = 0;\n\t\t}\n\n\t\tif (created_disp) {\n\t\t\tsnprintf(str, sizeof str, \"Created DISPLAY %s\", use_dpy);\n\t\t} else {\n\t\t\tsnprintf(str, sizeof str, \"Using DISPLAY %s\", use_dpy);\n\t\t}\n\t\tunixpw_msg(str, 2);\n\t}\n\treturn 1;\n}",
          "includes": [
            "#include \"avahi.h\"",
            "#include \"sslhelper.h\"",
            "#include \"remote.h\"",
            "#include \"cursor.h\"",
            "#include \"keyboard.h\"",
            "#include \"inet.h\"",
            "#include \"connections.h\"",
            "#include \"xwrappers.h\"",
            "#include \"sslhelper.h\"",
            "#include \"unixpw.h\"",
            "#include \"screen.h\"",
            "#include \"scan.h\"",
            "#include \"cleanup.h\"",
            "#include \"solid.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void lurk_loop(char *str);",
            "char *xdmcp_insert = NULL;",
            "extern char find_display[];",
            "extern char create_display[];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"avahi.h\"\n#include \"sslhelper.h\"\n#include \"remote.h\"\n#include \"cursor.h\"\n#include \"keyboard.h\"\n#include \"inet.h\"\n#include \"connections.h\"\n#include \"xwrappers.h\"\n#include \"sslhelper.h\"\n#include \"unixpw.h\"\n#include \"screen.h\"\n#include \"scan.h\"\n#include \"cleanup.h\"\n#include \"solid.h\"\n#include \"x11vnc.h\"\n\nvoid lurk_loop(char *str);\nchar *xdmcp_insert = NULL;\nextern char find_display[];\nextern char create_display[];\n\nstatic int do_run_cmd(char *cmd, char *create_cmd, char *users_list_save, int created_disp, int db) {\n\tchar tmp[] = \"/tmp/x11vnc-find_display.XXXXXX\";\n\tchar line1[1024], line2[16384];\n\tchar *q, *usslpeer = NULL;\n\tint n, nodisp = 0, saw_xdmcp = 0;\n\tint tmp_fd = -1;\n\tint internal_cmd = 0;\n\tint tried_switch = 0;\n\n\tmemset(line1, 0, sizeof(line1));\n\tmemset(line2, 0, sizeof(line2));\n\n\tif (users_list && strstr(users_list, \"sslpeer=\") == users_list) {\n\t\tusslpeer = get_usslpeer();\n\t\tif (! usslpeer) {\n\t\t\treturn 0;\n\t\t}\n\t}\n\tif (getenv(\"DEBUG_RUN_CMD\")) db = 1;\n\n\t/* only sets environment variables: */\n\trun_user_command(\"\", latest_client, \"env\", NULL, 0, NULL);\n\n\tif (program_name) {\n\t\tset_env(\"X11VNC_PROG\", program_name);\n\t} else {\n\t\tset_env(\"X11VNC_PROG\", \"x11vnc\");\n\t}\n\n\tif (!strcmp(cmd, \"FINDDISPLAY\") ||\n\t    strstr(cmd, \"FINDCREATEDISPLAY\") == cmd) {\n\t\tchar *nd = \"\";\n\t\tchar *tag = \"\";\n\t\tchar fdout[128];\n\n\t\tinternal_cmd = 1;\n\n\t\ttmp_fd = mkstemp(tmp);\n\n\t\tif (tmp_fd < 0) {\n\t\t\trfbLog(\"wait_for_client: open failed: %s\\n\", tmp);\n\t\t\trfbLogPerror(\"mkstemp\");\n\t\t\tclean_up_exit(1);\n\t\t}\n\t\tchmod(tmp, 0644);\n\t\tif (getenv(\"X11VNC_FINDDISPLAY_ALWAYS_FAILS\")) {\n\t\t\tchar *s = \"#!/bin/sh\\necho _FAIL_\\nexit 1\\n\";\n\t\t\twrite(tmp_fd, s, strlen(s));\n\t\t} else {\n\t\t\twrite(tmp_fd, find_display, strlen(find_display));\n\t\t}\n\t\tclose(tmp_fd);\n\t\tnodisp = 1;\n\n\t\tif (strstr(cmd, \"FINDCREATEDISPLAY\") == cmd) {\n\t\t\tcreate_cmd = build_create_cmd(cmd, &saw_xdmcp, usslpeer, tmp);\n\t\t\tif (db) fprintf(stderr, \"create_cmd: %s\\n\", create_cmd);\n\t\t}\n\t\tif (getenv(\"X11VNC_SKIP_DISPLAY\")) {\n\t\t\tnd = strdup(getenv(\"X11VNC_SKIP_DISPLAY\"));\n\t\t}\n\t\tcheck_nodisplay(&nd, &tag);\n\n\t\tfdout[0] = '\\0';\n\t\tif (getenv(\"FIND_DISPLAY_OUTPUT\")) {\n\t\t\tsnprintf(fdout, sizeof fdout, \" FIND_DISPLAY_OUTPUT='%s' \", getenv(\"FIND_DISPLAY_OUTPUT\"));\n\t\t}\n\n\t\tcmd = (char *) malloc(strlen(\"env X11VNC_SKIP_DISPLAY='' \")\n\t\t    + strlen(nd) + strlen(\" FD_TAG='' \") + strlen(tag) + strlen(tmp) + strlen(\"/bin/sh \") + strlen(fdout) + 1);\n\n\t\tif (strcmp(tag, \"\")) {\n\t\t\tsprintf(cmd, \"env X11VNC_SKIP_DISPLAY='%s' FD_TAG='%s' %s /bin/sh %s\", nd, tag, fdout, tmp);\n\t\t} else {\n\t\t\tsprintf(cmd, \"env X11VNC_SKIP_DISPLAY='%s' %s /bin/sh %s\", nd, fdout, tmp);\n\t\t}\n\t}\n\n\trfbLog(\"wait_for_client: running: %s\\n\", cmd);\n\n\tif (create_cmd != NULL) {\n\t\tif (strstr(create_cmd, \"Xvfb\")) {\n\t\t\tpath_lookup(\"Xvfb\");\n\t\t}\n\t\tif (strstr(create_cmd, \"Xvnc\")) {\n\t\t\tpath_lookup(\"Xvnc\");\n\t\t}\n\t\tif (strstr(create_cmd, \"Xdummy\")) {\n\t\t\tpath_lookup(\"Xdummy\");\n\t\t}\n\t}\n\n\tif (unixpw && !unixpw_nis) {\n\t\tint res = 0, k, j, i;\n\t\tchar line[18000];\n\n\t\tmemset(line, 0, sizeof(line));\n\n\t\tif (unixpw_system_greeter_active == 2) {\n\t\t\trfbLog(\"unixpw_system_greeter: forcing find display failure.\\n\");\n\t\t\tres = 0;\n\t\t} else if (keep_unixpw_user && keep_unixpw_pass) {\n\t\t\tn = sizeof(line);\n\t\t\tif (unixpw_cmd != NULL) {\n\t\t\t\tres = unixpw_cmd_run(keep_unixpw_user,\n\t\t\t\t    keep_unixpw_pass, cmd, line, &n);\n\t\t\t} else {\n\t\t\t\tres = su_verify(keep_unixpw_user,\n\t\t\t\t    keep_unixpw_pass, cmd, line, &n, nodisp);\n\t\t\t}\n\t\t}\n\nif (db) {fprintf(stderr, \"line: \"); write(2, line, n); write(2, \"\\n\", 1); fprintf(stderr, \"res=%d n=%d\\n\", res, n);}\n\t\tif (! res) {\n\t\t\trfbLog(\"wait_for_client: find display cmd failed.\\n\");\n\t\t}\n\n\t\tif (! res && create_cmd) {\n\t\t\tFILE *mt = fopen(tmp, \"w\");\n\t\t\tif (! mt) {\n\t\t\t\trfbLog(\"wait_for_client: open failed: %s\\n\", tmp);\n\t\t\t\trfbLogPerror(\"fopen\");\n\t\t\t\tclean_up_exit(1);\n\t\t\t}\n\t\t\tfprintf(mt, \"%s\", create_display);\n\t\t\tfclose(mt);\n\n\t\t\tfindcreatedisplay = 1;\n\n\t\t\tif (unixpw_cmd != NULL) {\n\t\t\t\t/* let the external unixpw command do it: */\n\t\t\t\tn = sizeof(line);\n\t\t\t\tclose_exec_fds();\n\t\t\t\tres = unixpw_cmd_run(keep_unixpw_user,\n\t\t\t\t    keep_unixpw_pass, create_cmd, line, &n);\n\t\t\t} else if (getuid() != 0 && unixpw_system_greeter_active != 2) {\n\t\t\t\t/* if not root, run as the other user... */\n\t\t\t\tn = sizeof(line);\n\t\t\t\tclose_exec_fds();\n\t\t\t\tres = su_verify(keep_unixpw_user,\n\t\t\t\t    keep_unixpw_pass, create_cmd, line, &n, nodisp);\nif (db) fprintf(stderr, \"c-res=%d n=%d line: '%s'\\n\", res, n, line);\n\n\t\t\t} else {\n\t\t\t\tFILE *p;\n\t\t\t\tclose_exec_fds();\n\t\t\t\tif (unixpw_system_greeter_active == 2) {\n\t\t\t\t\trfbLog(\"unixpw_system_greeter: not trying su_verify() to run\\n\");\n\t\t\t\t\trfbLog(\"unixpw_system_greeter: create display command.\\n\");\n\t\t\t\t}\n\t\t\t\trfbLog(\"wait_for_client: running: %s\\n\", create_cmd);\n\t\t\t\tp = popen(create_cmd, \"r\");\n\t\t\t\tif (! p) {\n\t\t\t\t\trfbLog(\"wait_for_client: popen failed: %s\\n\", create_cmd);\n\t\t\t\t\tres = 0;\n\t\t\t\t} else if (fgets(line1, sizeof line1, p) == NULL) {\n\t\t\t\t\trfbLog(\"wait_for_client: read failed: %s\\n\", create_cmd);\n\t\t\t\t\tres = 0;\n\t\t\t\t} else {\n\t\t\t\t\tn = fread(line2, 1, sizeof line2, p);\n\t\t\t\t\tif (pclose(p) != 0) {\n\t\t\t\t\t\tres = 0;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tstrncpy(line, line1, 100);\n\t\t\t\t\t\tmemcpy(line + strlen(line1), line2, n);\nif (db) fprintf(stderr, \"line1: '%s'\\n\", line1);\n\t\t\t\t\t\tn += strlen(line1);\n\t\t\t\t\t\tcreated_disp = 1;\n\t\t\t\t\t\tres = 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (res && saw_xdmcp && unixpw_system_greeter_active != 2) {\n\t\t\t\txdmcp_insert = strdup(keep_unixpw_user);\n\t\t\t}\n\t\t}\n\n\t\tif (tmp_fd >= 0) {\n\t\t\tunlink(tmp);\n\t\t}\n\n\t\tif (! res) {\n\t\t\trfbLog(\"wait_for_client: cmd failed: %s\\n\", cmd);\n\t\t\tunixpw_msg(\"No DISPLAY found.\", 3);\n\t\t\tclean_up_exit(1);\n\t\t}\n\n\t\t/*\n\t\t * we need to hunt for DISPLAY= since there may be\n\t\t * a login banner or something at the beginning.\n\t\t */\n\t\tq = strstr(line, \"DISPLAY=\");\n\t\tif (! q) {\n\t\t\tq = line;\n\t\t}\n\t\tn -= (q - line);\n\n\t\tfor (k = 0; k < 1024; k++) {\n\t\t\tline1[k] = q[k];\n\t\t\tif (q[k] == '\\n') {\n\t\t\t\tk++;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tn -= k;\n\t\ti = 0;\n\t\tfor (j = 0; j < 16384; j++) {\n\t\t\tif (j < 16384 - 1) {\n\t\t\t\t/* xauth data, assume pty added CR */\n\t\t\t\tif (q[k+j] == '\\r' && q[k+j+1] == '\\n') {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tline2[i] = q[k+j];\n\t\t\ti++;\n\t\t}\nif (db) write(2, line, 100);\nif (db) fprintf(stderr, \"\\n\");\n\n\t} else {\n\t\tFILE *p;\n\t\tint rc;\n\t\tclose_exec_fds();\n\n\t\tif (usslpeer) {\n\t\t\tchar *c;\n\t\t\tif (getuid() == 0) {\n\t\t\t\tc = (char *) malloc(strlen(\"su - '' -c \\\"\")\n\t\t\t\t    + strlen(usslpeer) + strlen(cmd) + 1 + 1);\n\t\t\t\tsprintf(c, \"su - '%s' -c \\\"%s\\\"\", usslpeer, cmd);\n\t\t\t} else {\n\t\t\t\tc = strdup(cmd);\n\t\t\t}\n\t\t\tp = popen(c, \"r\");\n\t\t\tfree(c);\n\t\t\t\n\t\t} else if (unixpw_nis && keep_unixpw_user) {\n\t\t\tchar *c;\n\t\t\tif (getuid() == 0) {\n\t\t\t\tc = (char *) malloc(strlen(\"su - '' -c \\\"\")\n\t\t\t\t    + strlen(keep_unixpw_user) + strlen(cmd) + 1 + 1);\n\t\t\t\tsprintf(c, \"su - '%s' -c \\\"%s\\\"\", keep_unixpw_user, cmd);\n\t\t\t} else {\n\t\t\t\tc = strdup(cmd);\n\t\t\t}\n\t\t\tp = popen(c, \"r\");\n\t\t\tfree(c);\n\t\t\t\n\t\t} else {\n\t\t\tp = popen(cmd, \"r\");\n\t\t}\n\n\t\tif (! p) {\n\t\t\trfbLog(\"wait_for_client: cmd failed: %s\\n\", cmd);\n\t\t\trfbLogPerror(\"popen\");\n\t\t\tif (tmp_fd >= 0) {\n\t\t\t\tunlink(tmp);\n\t\t\t}\n\t\t\tclean_up_exit(1);\n\t\t}\n\t\tif (fgets(line1, sizeof line1, p) == NULL) {\n\t\t\trfbLog(\"wait_for_client: read failed: %s\\n\", cmd);\n\t\t\trfbLogPerror(\"fgets\");\n\t\t\tif (tmp_fd >= 0) {\n\t\t\t\tunlink(tmp);\n\t\t\t}\n\t\t\tclean_up_exit(1);\n\t\t}\n\t\tn = fread(line2, 1, sizeof line2, p);\n\t\trc = pclose(p);\n\n\t\tif (rc != 0) {\n\t\t\trfbLog(\"wait_for_client: find display cmd failed.\\n\");\n\t\t}\n\n\t\tif (create_cmd && rc != 0) {\n\t\t\tFILE *mt = fopen(tmp, \"w\");\n\t\t\tif (! mt) {\n\t\t\t\trfbLog(\"wait_for_client: open failed: %s\\n\", tmp);\n\t\t\t\trfbLogPerror(\"fopen\");\n\t\t\t\tif (tmp_fd >= 0) {\n\t\t\t\t\tunlink(tmp);\n\t\t\t\t}\n\t\t\t\tclean_up_exit(1);\n\t\t\t}\n\t\t\tfprintf(mt, \"%s\", create_display);\n\t\t\tfclose(mt);\n\n\t\t\tfindcreatedisplay = 1;\n\n\t\t\trfbLog(\"wait_for_client: FINDCREATEDISPLAY cmd: %s\\n\", create_cmd);\n\n\t\t\tp = popen(create_cmd, \"r\");\n\t\t\tif (! p) {\n\t\t\t\trfbLog(\"wait_for_client: cmd failed: %s\\n\", create_cmd);\n\t\t\t\trfbLogPerror(\"popen\");\n\t\t\t\tif (tmp_fd >= 0) {\n\t\t\t\t\tunlink(tmp);\n\t\t\t\t}\n\t\t\t\tclean_up_exit(1);\n\t\t\t}\n\t\t\tif (fgets(line1, sizeof line1, p) == NULL) {\n\t\t\t\trfbLog(\"wait_for_client: read failed: %s\\n\", create_cmd);\n\t\t\t\trfbLogPerror(\"fgets\");\n\t\t\t\tif (tmp_fd >= 0) {\n\t\t\t\t\tunlink(tmp);\n\t\t\t\t}\n\t\t\t\tclean_up_exit(1);\n\t\t\t}\n\t\t\tn = fread(line2, 1, sizeof line2, p);\n\t\t\tpclose(p);\n\t\t}\n\t\tif (tmp_fd >= 0) {\n\t\t\tunlink(tmp);\n\t\t}\n\t}\n\nif (db) fprintf(stderr, \"line1=%s\\n\", line1);\n\n\tif (strstr(line1, \"DISPLAY=\") != line1) {\n\t\trfbLog(\"wait_for_client: bad reply '%s'\\n\", line1);\n\t\tif (unixpw) {\n\t\t\tunixpw_msg(\"No DISPLAY found.\", 3);\n\t\t}\n\t\tclean_up_exit(1);\n\t}\n\n\n\tif (strstr(line1, \",VT=\")) {\n\t\tint vt;\n\t\tchar *t = strstr(line1, \",VT=\");\n\t\tvt = atoi(t + strlen(\",VT=\"));\n\t\t*t = '\\0';\n\t\tif (7 <= vt && vt <= 15) {\n\t\t\tdo_chvt(vt);\n\t\t}\n\t} else if (strstr(line1, \",XPID=\")) {\n\t\tint i, pvt, vt = -1;\n\t\tchar *t = strstr(line1, \",XPID=\");\n\t\tpvt = atoi(t + strlen(\",XPID=\"));\n\t\t*t = '\\0';\n\t\tif (pvt > 0) {\n\t\t\tfor (i=3; i <= 10; i++) {\n\t\t\t\tint k;\n\t\t\t\tchar proc[100];\n\t\t\t\tchar buf[100];\n\t\t\t\tsprintf(proc, \"/proc/%d/fd/%d\", pvt, i);\nif (db) fprintf(stderr, \"%d -- %s\\n\", i, proc);\n\t\t\t\tfor (k=0; k < 100; k++) {\n\t\t\t\t\tbuf[k] = '\\0';\n\t\t\t\t}\n\t\n\t\t\t\tif (readlink(proc, buf, sizeof buf) != -1) {\n\t\t\t\t\tbuf[100-1] = '\\0';\nif (db) fprintf(stderr, \"%d -- %s -- %s\\n\", i, proc, buf);\n\t\t\t\t\tif (strstr(buf, \"/dev/tty\") == buf) {\n\t\t\t\t\t\tvt = atoi(buf + strlen(\"/dev/tty\"));\n\t\t\t\t\t\tif (vt > 0) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (7 <= vt && vt <= 12) {\n\t\t\tdo_chvt(vt);\n\t\t}\n\t}\n\n\tuse_dpy = strdup(line1 + strlen(\"DISPLAY=\"));\n\tq = use_dpy;\n\twhile (*q != '\\0') {\n\t\tif (*q == '\\n' || *q == '\\r') *q = '\\0';\n\t\tq++;\n\t}\n\tif (line2[0] != '\\0') {\n\t\tif (strstr(line2, \"XAUTHORITY=\") == line2) {\n\t\t\tq = line2;\n\t\t\twhile (*q != '\\0') {\n\t\t\t\tif (*q == '\\n' || *q == '\\r') *q = '\\0';\n\t\t\t\tq++;\n\t\t\t}\n\t\t\tif (auth_file) {\n\t\t\t\tfree(auth_file);\n\t\t\t}\n\t\t\tauth_file = strdup(line2 + strlen(\"XAUTHORITY=\"));\n\n\t\t} else {\n\t\t\txauth_raw_data = (char *)malloc(n);\n\t\t\txauth_raw_len = n;\n\t\t\tmemcpy(xauth_raw_data, line2, n);\nif (db) {fprintf(stderr, \"xauth_raw_len: %d\\n\", n);\nwrite(2, xauth_raw_data, n);\nfprintf(stderr, \"\\n\");}\n\t\t}\n\t}\n\n\tif (!tried_switch) {\n\t\tdo_try_switch(usslpeer, users_list_save);\n\t\ttried_switch = 1;\n\t}\n\n\tif (unixpw) {\n\t\t/* Some cleanup and messaging for -unixpw case: */\n\t\tchar str[32];\n\n\t\tif (keep_unixpw_user && keep_unixpw_pass) {\n\t\t\tstrzero(keep_unixpw_user);\n\t\t\tstrzero(keep_unixpw_pass);\n\t\t\tkeep_unixpw = 0;\n\t\t}\n\n\t\tif (created_disp) {\n\t\t\tsnprintf(str, sizeof str, \"Created DISPLAY %s\", use_dpy);\n\t\t} else {\n\t\t\tsnprintf(str, sizeof str, \"Using DISPLAY %s\", use_dpy);\n\t\t}\n\t\tunixpw_msg(str, 2);\n\t}\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "progress_client",
          "args": [],
          "line": 3124
        },
        "resolved": true,
        "details": {
          "function_name": "progress_client",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/user.c",
          "lines": "2891-2919",
          "snippet": "void progress_client(void) {\n\tint i, j = 0, progressed = 0, db = 0;\n\tdouble start = dnow();\n\tif (getenv(\"PROGRESS_CLIENT_DBG\")) {\n\t\trfbLog(\"progress_client: begin\\n\");\n\t\tdb = 1;\n\t}\n\tfor (i = 0; i < 15; i++) {\n\t\tif (latest_client) {\n\t\t\tfor (j = 0; j < 10; j++) {\n\t\t\t\tif (latest_client->state != RFB_PROTOCOL_VERSION) {\n\t\t\t\t\tprogressed = 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (db) rfbLog(\"progress_client: calling-1 rfbCFD(1) %.6f\\n\", dnow()-start);\n\t\t\t\trfbCFD(1);\n\t\t\t}\n\t\t}\n\t\tif (progressed) {\n\t\t\tbreak;\n\t\t}\n\t\tif (db) rfbLog(\"progress_client: calling-2 rfbCFD(1) %.6f\\n\", dnow()-start);\n\t\trfbCFD(1);\n\t}\n\tif (!quiet) {\n\t\trfbLog(\"client progressed=%d in %d/%d %.6f s\\n\",\n\t\t    progressed, i, j, dnow() - start);\n\t}\n}",
          "includes": [
            "#include \"avahi.h\"",
            "#include \"sslhelper.h\"",
            "#include \"remote.h\"",
            "#include \"cursor.h\"",
            "#include \"keyboard.h\"",
            "#include \"inet.h\"",
            "#include \"connections.h\"",
            "#include \"xwrappers.h\"",
            "#include \"sslhelper.h\"",
            "#include \"unixpw.h\"",
            "#include \"screen.h\"",
            "#include \"scan.h\"",
            "#include \"cleanup.h\"",
            "#include \"solid.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void progress_client(void);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"avahi.h\"\n#include \"sslhelper.h\"\n#include \"remote.h\"\n#include \"cursor.h\"\n#include \"keyboard.h\"\n#include \"inet.h\"\n#include \"connections.h\"\n#include \"xwrappers.h\"\n#include \"sslhelper.h\"\n#include \"unixpw.h\"\n#include \"screen.h\"\n#include \"scan.h\"\n#include \"cleanup.h\"\n#include \"solid.h\"\n#include \"x11vnc.h\"\n\nvoid progress_client(void);\n\nvoid progress_client(void) {\n\tint i, j = 0, progressed = 0, db = 0;\n\tdouble start = dnow();\n\tif (getenv(\"PROGRESS_CLIENT_DBG\")) {\n\t\trfbLog(\"progress_client: begin\\n\");\n\t\tdb = 1;\n\t}\n\tfor (i = 0; i < 15; i++) {\n\t\tif (latest_client) {\n\t\t\tfor (j = 0; j < 10; j++) {\n\t\t\t\tif (latest_client->state != RFB_PROTOCOL_VERSION) {\n\t\t\t\t\tprogressed = 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (db) rfbLog(\"progress_client: calling-1 rfbCFD(1) %.6f\\n\", dnow()-start);\n\t\t\t\trfbCFD(1);\n\t\t\t}\n\t\t}\n\t\tif (progressed) {\n\t\t\tbreak;\n\t\t}\n\t\tif (db) rfbLog(\"progress_client: calling-2 rfbCFD(1) %.6f\\n\", dnow()-start);\n\t\trfbCFD(1);\n\t}\n\tif (!quiet) {\n\t\trfbLog(\"client progressed=%d in %d/%d %.6f s\\n\",\n\t\t    progressed, i, j, dnow() - start);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "do_unixpw_loop",
          "args": [],
          "line": 3121
        },
        "resolved": true,
        "details": {
          "function_name": "do_unixpw_loop",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/user.c",
          "lines": "1657-1693",
          "snippet": "static void do_unixpw_loop(void) {\n\tif (unixpw) {\n\t\tif (! unixpw_in_progress && !vencrypt_enable_plain_login) {\n\t\t\trfbLog(\"unixpw but no unixpw_in_progress\\n\");\n\t\t\tclean_up_exit(1);\n\t\t}\n\t\tif (unixpw_client && unixpw_client->onHold) {\n\t\t\trfbLog(\"taking unixpw_client off hold.\\n\");\n\t\t\tunixpw_client->onHold = FALSE;\n\t\t}\n\t\twhile (1) {\n\t\t\tif (shut_down) {\n\t\t\t\tclean_up_exit(0);\n\t\t\t}\n\t\t\tif (! use_threads) {\n\t\t\t\tunixpw_in_rfbPE = 1;\n\t\t\t\trfbPE(-1);\n\t\t\t\tunixpw_in_rfbPE = 0;\n\t\t\t}\n\t\t\tif (unixpw_in_progress) {\n\t\t\t\tstatic double lping = 0.0;\n\t\t\t\tif (lping < dnow() + 5) {\n\t\t\t\t\tmark_rect_as_modified(0, 0, 1, 1, 1);\n\t\t\t\t\tlping = dnow();\n\t\t\t\t}\n\t\t\t\tif (time(NULL) > unixpw_last_try_time + 45) {\n\t\t\t\t\trfbLog(\"unixpw_deny: timed out waiting for reply.\\n\");\n\t\t\t\t\tunixpw_deny();\n\t\t\t\t}\n\t\t\t\tusleep(20 * 1000);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\trfbLog(\"wait_for_client: unixpw finished.\\n\");\n\t\t\tbreak;\n\t\t}\n\t}\n}",
          "includes": [
            "#include \"avahi.h\"",
            "#include \"sslhelper.h\"",
            "#include \"remote.h\"",
            "#include \"cursor.h\"",
            "#include \"keyboard.h\"",
            "#include \"inet.h\"",
            "#include \"connections.h\"",
            "#include \"xwrappers.h\"",
            "#include \"sslhelper.h\"",
            "#include \"unixpw.h\"",
            "#include \"screen.h\"",
            "#include \"scan.h\"",
            "#include \"cleanup.h\"",
            "#include \"solid.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"avahi.h\"\n#include \"sslhelper.h\"\n#include \"remote.h\"\n#include \"cursor.h\"\n#include \"keyboard.h\"\n#include \"inet.h\"\n#include \"connections.h\"\n#include \"xwrappers.h\"\n#include \"sslhelper.h\"\n#include \"unixpw.h\"\n#include \"screen.h\"\n#include \"scan.h\"\n#include \"cleanup.h\"\n#include \"solid.h\"\n#include \"x11vnc.h\"\n\nstatic void do_unixpw_loop(void) {\n\tif (unixpw) {\n\t\tif (! unixpw_in_progress && !vencrypt_enable_plain_login) {\n\t\t\trfbLog(\"unixpw but no unixpw_in_progress\\n\");\n\t\t\tclean_up_exit(1);\n\t\t}\n\t\tif (unixpw_client && unixpw_client->onHold) {\n\t\t\trfbLog(\"taking unixpw_client off hold.\\n\");\n\t\t\tunixpw_client->onHold = FALSE;\n\t\t}\n\t\twhile (1) {\n\t\t\tif (shut_down) {\n\t\t\t\tclean_up_exit(0);\n\t\t\t}\n\t\t\tif (! use_threads) {\n\t\t\t\tunixpw_in_rfbPE = 1;\n\t\t\t\trfbPE(-1);\n\t\t\t\tunixpw_in_rfbPE = 0;\n\t\t\t}\n\t\t\tif (unixpw_in_progress) {\n\t\t\t\tstatic double lping = 0.0;\n\t\t\t\tif (lping < dnow() + 5) {\n\t\t\t\t\tmark_rect_as_modified(0, 0, 1, 1, 1);\n\t\t\t\t\tlping = dnow();\n\t\t\t\t}\n\t\t\t\tif (time(NULL) > unixpw_last_try_time + 45) {\n\t\t\t\t\trfbLog(\"unixpw_deny: timed out waiting for reply.\\n\");\n\t\t\t\t\tunixpw_deny();\n\t\t\t\t}\n\t\t\t\tusleep(20 * 1000);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\trfbLog(\"wait_for_client: unixpw finished.\\n\");\n\t\t\tbreak;\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "users_list",
            "\"unixpw=\""
          ],
          "line": 3116
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "cmd",
            "\"FINDCREATEDISPLAY\""
          ],
          "line": 3115
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "loop_for_connect",
          "args": [
            "did_client_connect"
          ],
          "line": 3112
        },
        "resolved": true,
        "details": {
          "function_name": "loop_for_connect",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/user.c",
          "lines": "1555-1655",
          "snippet": "static void loop_for_connect(int did_client_connect) {\n\tint loop = 0;\n\ttime_t start = time(NULL);\n\n\tif (first_conn_timeout < 0) {\n\t\tfirst_conn_timeout = -first_conn_timeout;\n\t}\n\n\twhile (1) {\n\t\tloop++;\n\t\tif (first_conn_timeout && time(NULL) > start + first_conn_timeout) {\n\t\t\trfbLog(\"no client connect after %d seconds.\\n\", first_conn_timeout);\n\t\t\tshut_down = 1;\n\t\t}\n\t\tif (shut_down) {\n\t\t\tclean_up_exit(0);\n\t\t}\n\t\tif (loop < 2) {\n\t\t\tif (did_client_connect) {\n\t\t\t\tgoto screen_check;\n\t\t\t}\n\t\t\tif (inetd) {\n\t\t\t\tgoto screen_check;\n\t\t\t}\n\t\t\tif (screen && screen->clientHead) {\n\t\t\t\tgoto screen_check;\n\t\t\t}\n\t\t}\n\t\tif ((use_openssl || use_stunnel) && !inetd) {\n\t\t\tint enc_none = (enc_str && !strcmp(enc_str, \"none\"));\n\t\t\tif (!use_stunnel || enc_none) {\n\t\t\t\tcheck_openssl();\n\t\t\t\tcheck_https();\n\t\t\t}\n\t\t\t/*\n\t\t\t * This is to handle an initial verify cert from viewer,\n\t\t\t * they disconnect right after fetching the cert.\n\t\t\t */\n\t\t\tif (use_threads) {\n\t\t\t\tusleep(10 * 1000);\n\t\t\t} else {\n\t\t\t\trfbPE(-1);\n\t\t\t}\n\t\t\tif (screen && screen->clientHead) {\n\t\t\t\tint i;\n\t\t\t\tif (unixpw) {\n\t\t\t\t\tif (! unixpw_in_progress && !vencrypt_enable_plain_login) {\n\t\t\t\t\t\trfbLog(\"unixpw but no unixpw_in_progress\\n\");\n\t\t\t\t\t\tclean_up_exit(1);\n\t\t\t\t\t}\n\t\t\t\t\tif (unixpw_client && unixpw_client->onHold) {\n\t\t\t\t\t\trfbLog(\"taking unixpw_client off hold\\n\");\n\t\t\t\t\t\tunixpw_client->onHold = FALSE;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfor (i=0; i<10; i++) {\n\t\t\t\t\tif (shut_down) {\n\t\t\t\t\t\tclean_up_exit(0);\n\t\t\t\t\t}\n\t\t\t\t\tusleep(20 * 1000);\n\t\t\t\t\tif (0) rfbLog(\"wait_for_client: %d\\n\", i);\n\n\t\t\t\t\tif (! use_threads) {\n\t\t\t\t\t\tif (unixpw) {\n\t\t\t\t\t\t\tunixpw_in_rfbPE = 1;\n\t\t\t\t\t\t}\n\t\t\t\t\t\trfbPE(-1);\n\t\t\t\t\t\tif (unixpw) {\n\t\t\t\t\t\t\tunixpw_in_rfbPE = 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif (unixpw && !unixpw_in_progress) {\n\t\t\t\t\t\t/* XXX too soon. */\n\t\t\t\t\t\tgoto screen_check;\n\t\t\t\t\t}\n\t\t\t\t\tif (!screen->clientHead) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (use_openssl) {\n\t\t\tcheck_openssl();\n\t\t}\n\n\t\tif (use_threads) {\n\t\t\tusleep(10 * 1000);\n\t\t} else {\n\t\t\trfbPE(-1);\n\t\t}\n\n\t\tscreen_check:\n\t\tif (! screen || ! screen->clientHead) {\n\t\t\tusleep(100 * 1000);\n\t\t\tcontinue;\n\t\t}\n\n\t\trfbLog(\"wait_for_client: got client\\n\");\n\t\tbreak;\n\t}\n}",
          "includes": [
            "#include \"avahi.h\"",
            "#include \"sslhelper.h\"",
            "#include \"remote.h\"",
            "#include \"cursor.h\"",
            "#include \"keyboard.h\"",
            "#include \"inet.h\"",
            "#include \"connections.h\"",
            "#include \"xwrappers.h\"",
            "#include \"sslhelper.h\"",
            "#include \"unixpw.h\"",
            "#include \"screen.h\"",
            "#include \"scan.h\"",
            "#include \"cleanup.h\"",
            "#include \"solid.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"avahi.h\"\n#include \"sslhelper.h\"\n#include \"remote.h\"\n#include \"cursor.h\"\n#include \"keyboard.h\"\n#include \"inet.h\"\n#include \"connections.h\"\n#include \"xwrappers.h\"\n#include \"sslhelper.h\"\n#include \"unixpw.h\"\n#include \"screen.h\"\n#include \"scan.h\"\n#include \"cleanup.h\"\n#include \"solid.h\"\n#include \"x11vnc.h\"\n\nstatic void loop_for_connect(int did_client_connect) {\n\tint loop = 0;\n\ttime_t start = time(NULL);\n\n\tif (first_conn_timeout < 0) {\n\t\tfirst_conn_timeout = -first_conn_timeout;\n\t}\n\n\twhile (1) {\n\t\tloop++;\n\t\tif (first_conn_timeout && time(NULL) > start + first_conn_timeout) {\n\t\t\trfbLog(\"no client connect after %d seconds.\\n\", first_conn_timeout);\n\t\t\tshut_down = 1;\n\t\t}\n\t\tif (shut_down) {\n\t\t\tclean_up_exit(0);\n\t\t}\n\t\tif (loop < 2) {\n\t\t\tif (did_client_connect) {\n\t\t\t\tgoto screen_check;\n\t\t\t}\n\t\t\tif (inetd) {\n\t\t\t\tgoto screen_check;\n\t\t\t}\n\t\t\tif (screen && screen->clientHead) {\n\t\t\t\tgoto screen_check;\n\t\t\t}\n\t\t}\n\t\tif ((use_openssl || use_stunnel) && !inetd) {\n\t\t\tint enc_none = (enc_str && !strcmp(enc_str, \"none\"));\n\t\t\tif (!use_stunnel || enc_none) {\n\t\t\t\tcheck_openssl();\n\t\t\t\tcheck_https();\n\t\t\t}\n\t\t\t/*\n\t\t\t * This is to handle an initial verify cert from viewer,\n\t\t\t * they disconnect right after fetching the cert.\n\t\t\t */\n\t\t\tif (use_threads) {\n\t\t\t\tusleep(10 * 1000);\n\t\t\t} else {\n\t\t\t\trfbPE(-1);\n\t\t\t}\n\t\t\tif (screen && screen->clientHead) {\n\t\t\t\tint i;\n\t\t\t\tif (unixpw) {\n\t\t\t\t\tif (! unixpw_in_progress && !vencrypt_enable_plain_login) {\n\t\t\t\t\t\trfbLog(\"unixpw but no unixpw_in_progress\\n\");\n\t\t\t\t\t\tclean_up_exit(1);\n\t\t\t\t\t}\n\t\t\t\t\tif (unixpw_client && unixpw_client->onHold) {\n\t\t\t\t\t\trfbLog(\"taking unixpw_client off hold\\n\");\n\t\t\t\t\t\tunixpw_client->onHold = FALSE;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfor (i=0; i<10; i++) {\n\t\t\t\t\tif (shut_down) {\n\t\t\t\t\t\tclean_up_exit(0);\n\t\t\t\t\t}\n\t\t\t\t\tusleep(20 * 1000);\n\t\t\t\t\tif (0) rfbLog(\"wait_for_client: %d\\n\", i);\n\n\t\t\t\t\tif (! use_threads) {\n\t\t\t\t\t\tif (unixpw) {\n\t\t\t\t\t\t\tunixpw_in_rfbPE = 1;\n\t\t\t\t\t\t}\n\t\t\t\t\t\trfbPE(-1);\n\t\t\t\t\t\tif (unixpw) {\n\t\t\t\t\t\t\tunixpw_in_rfbPE = 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif (unixpw && !unixpw_in_progress) {\n\t\t\t\t\t\t/* XXX too soon. */\n\t\t\t\t\t\tgoto screen_check;\n\t\t\t\t\t}\n\t\t\t\t\tif (!screen->clientHead) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (use_openssl) {\n\t\t\tcheck_openssl();\n\t\t}\n\n\t\tif (use_threads) {\n\t\t\tusleep(10 * 1000);\n\t\t} else {\n\t\t\trfbPE(-1);\n\t\t}\n\n\t\tscreen_check:\n\t\tif (! screen || ! screen->clientHead) {\n\t\t\tusleep(100 * 1000);\n\t\t\tcontinue;\n\t\t}\n\n\t\trfbLog(\"wait_for_client: got client\\n\");\n\t\tbreak;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "setup_client_connect",
          "args": [
            "&did_client_connect"
          ],
          "line": 3110
        },
        "resolved": true,
        "details": {
          "function_name": "setup_client_connect",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/user.c",
          "lines": "1520-1553",
          "snippet": "static void setup_client_connect(int *did_client_connect) {\n\tif (client_connect != NULL) {\n\t\tchar *remainder = NULL;\n\t\tif (inetd) {\n\t\t\trfbLog(\"wait_for_client: -connect disallowed in inetd mode: %s\\n\",\n\t\t\t    client_connect);\n\t\t} else if (screen && screen->clientHead) {\n\t\t\trfbLog(\"wait_for_client: -connect disallowed: client exists: %s\\n\",\n\t\t\t    client_connect);\n\t\t} else if (strchr(client_connect, '=')) {\n\t\t\trfbLog(\"wait_for_client: invalid -connect string: %s\\n\",\n\t\t\t    client_connect);\n\t\t} else {\n\t\t\tchar *q = strchr(client_connect, ',');\n\t\t\tif (q) {\n\t\t\t\trfbLog(\"wait_for_client: only using first\"\n\t\t\t\t    \" connect host in: %s\\n\", client_connect);\n\t\t\t\tremainder = strdup(q+1);\n\t\t\t\t*q = '\\0';\n\t\t\t}\n\t\t\trfbLog(\"wait_for_client: reverse_connect(%s)\\n\",\n\t\t\t    client_connect);\n\t\t\treverse_connect(client_connect);\n\t\t\t*did_client_connect = 1;\n\t\t}\n\t\tfree(client_connect);\n\t\tif (remainder != NULL) {\n\t\t\t/* reset to host2,host3,... */\n\t\t\tclient_connect = remainder;\n\t\t} else {\n\t\t\tclient_connect = NULL;\n\t\t}\n\t}\n}",
          "includes": [
            "#include \"avahi.h\"",
            "#include \"sslhelper.h\"",
            "#include \"remote.h\"",
            "#include \"cursor.h\"",
            "#include \"keyboard.h\"",
            "#include \"inet.h\"",
            "#include \"connections.h\"",
            "#include \"xwrappers.h\"",
            "#include \"sslhelper.h\"",
            "#include \"unixpw.h\"",
            "#include \"screen.h\"",
            "#include \"scan.h\"",
            "#include \"cleanup.h\"",
            "#include \"solid.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"avahi.h\"\n#include \"sslhelper.h\"\n#include \"remote.h\"\n#include \"cursor.h\"\n#include \"keyboard.h\"\n#include \"inet.h\"\n#include \"connections.h\"\n#include \"xwrappers.h\"\n#include \"sslhelper.h\"\n#include \"unixpw.h\"\n#include \"screen.h\"\n#include \"scan.h\"\n#include \"cleanup.h\"\n#include \"solid.h\"\n#include \"x11vnc.h\"\n\nstatic void setup_client_connect(int *did_client_connect) {\n\tif (client_connect != NULL) {\n\t\tchar *remainder = NULL;\n\t\tif (inetd) {\n\t\t\trfbLog(\"wait_for_client: -connect disallowed in inetd mode: %s\\n\",\n\t\t\t    client_connect);\n\t\t} else if (screen && screen->clientHead) {\n\t\t\trfbLog(\"wait_for_client: -connect disallowed: client exists: %s\\n\",\n\t\t\t    client_connect);\n\t\t} else if (strchr(client_connect, '=')) {\n\t\t\trfbLog(\"wait_for_client: invalid -connect string: %s\\n\",\n\t\t\t    client_connect);\n\t\t} else {\n\t\t\tchar *q = strchr(client_connect, ',');\n\t\t\tif (q) {\n\t\t\t\trfbLog(\"wait_for_client: only using first\"\n\t\t\t\t    \" connect host in: %s\\n\", client_connect);\n\t\t\t\tremainder = strdup(q+1);\n\t\t\t\t*q = '\\0';\n\t\t\t}\n\t\t\trfbLog(\"wait_for_client: reverse_connect(%s)\\n\",\n\t\t\t    client_connect);\n\t\t\treverse_connect(client_connect);\n\t\t\t*did_client_connect = 1;\n\t\t}\n\t\tfree(client_connect);\n\t\tif (remainder != NULL) {\n\t\t\t/* reset to host2,host3,... */\n\t\t\tclient_connect = remainder;\n\t\t} else {\n\t\t\tclient_connect = NULL;\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "accept_openssl",
          "args": [
            "OPENSSL_INETD",
            "-1"
          ],
          "line": 3107
        },
        "resolved": true,
        "details": {
          "function_name": "accept_openssl",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/sslhelper.c",
          "lines": "3302-4284",
          "snippet": "void accept_openssl(int mode, int presock) {\n\tint sock = -1, listen = -1, cport, csock, vsock;\t\n\tint peerport = 0;\n\tint status, n, i, db = 0;\n\tstruct sockaddr_in addr;\n#ifdef __hpux\n\tint addrlen = sizeof(addr);\n#else\n\tsocklen_t addrlen = sizeof(addr);\n#endif\n\trfbClientPtr client;\n\tpid_t pid;\n\tchar uniq[] = \"_evilrats_\";\n\tchar cookie[256], rcookie[256], *name = NULL;\n\tint vencrypt_sel = 0;\n\tint anontls_sel = 0;\n\tchar *ipv6_name = NULL;\n\tstatic double last_https = 0.0;\n\tstatic char last_get[256];\n\tstatic int first = 1;\n\tunsigned char *rb;\n\n#if !LIBVNCSERVER_HAVE_LIBSSL && !HAVE_LIBSSL  \n\tif (enc_str == NULL || strcmp(enc_str, \"none\")) {\n\t\tbadnews(\"0 accept_openssl\");\n\t}\n#endif\n\n\topenssl_last_helper_pid = 0;\n\n\t/* zero buffers for use below. */\n\tfor (i=0; i<256; i++) {\n\t\tif (first) {\n\t\t\tlast_get[i] = '\\0';\n\t\t}\n\t\tcookie[i]  = '\\0';\n\t\trcookie[i] = '\\0';\n\t}\n\tfirst = 0;\n\n\tif (getenv(\"ACCEPT_OPENSSL_DEBUG\")) {\n\t\tdb = atoi(getenv(\"ACCEPT_OPENSSL_DEBUG\"));\n\t}\n\n\t/* do INETD, VNC, or HTTPS cases (result is client socket or pipe) */\n\tif (mode == OPENSSL_INETD) {\n\t\tssl_initialized = 1;\n\n\t} else if (mode == OPENSSL_VNC) {\n\t\tsock = accept(openssl_sock, (struct sockaddr *)&addr, &addrlen);\n\t\tif (sock < 0)  {\n\t\t\trfbLog(\"SSL: accept_openssl: accept connection failed\\n\");\n\t\t\trfbLogPerror(\"accept\");\n\t\t\tif (ssl_no_fail) {\n\t\t\t\tclean_up_exit(1);\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t\tlisten = openssl_sock;\n\n\t} else if (mode == OPENSSL_VNC6 || mode == OPENSSL_HTTPS6) {\n#if X11VNC_IPV6\n\t\tstruct sockaddr_in6 a6;\n\t\tsocklen_t a6len = sizeof(a6);\n\t\tint fd = (mode == OPENSSL_VNC6 ? openssl_sock6 : https_sock6); \n\n\t\tsock = accept(fd, (struct sockaddr *)&a6, &a6len);\n\t\tif (sock < 0)  {\n\t\t\trfbLog(\"SSL: accept_openssl: accept connection failed\\n\");\n\t\t\trfbLogPerror(\"accept\");\n\t\t\tif (ssl_no_fail) {\n\t\t\t\tclean_up_exit(1);\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t\tipv6_name = ipv6_getipaddr((struct sockaddr *)&a6, a6len);\n\t\tif (!ipv6_name) ipv6_name = strdup(\"unknown\");\n\t\tlisten = fd;\n#endif\n\t} else if (mode == OPENSSL_REVERSE) {\n\t\tsock = presock;\n\t\tif (sock < 0)  {\n\t\t\trfbLog(\"SSL: accept_openssl: connection failed\\n\");\n\t\t\tif (ssl_no_fail) {\n\t\t\t\tclean_up_exit(1);\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t\tif (getenv(\"OPENSSL_REVERSE_DEBUG\")) fprintf(stderr, \"OPENSSL_REVERSE: ipv6_client_ip_str: %s\\n\", ipv6_client_ip_str);\n\t\tif (ipv6_client_ip_str != NULL) {\n\t\t\tipv6_name = strdup(ipv6_client_ip_str);\n\t\t}\n\t\tlisten = -1;\n\n\t} else if (mode == OPENSSL_HTTPS) {\n\t\tsock = accept(https_sock, (struct sockaddr *)&addr, &addrlen);\n\t\tif (sock < 0)  {\n\t\t\trfbLog(\"SSL: accept_openssl: accept connection failed\\n\");\n\t\t\trfbLogPerror(\"accept\");\n\t\t\tif (ssl_no_fail) {\n\t\t\t\tclean_up_exit(1);\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t\tlisten = https_sock;\n\t}\n\tif (db) fprintf(stderr, \"SSL: accept_openssl: sock: %d\\n\", sock);\n\n\tif (openssl_last_ip) {\n\t\tfree(openssl_last_ip);\n\t\topenssl_last_ip = NULL;\n\t}\n\tif (mode == OPENSSL_INETD) {\n\t\topenssl_last_ip = get_remote_host(fileno(stdin));\n\t} else if (mode == OPENSSL_VNC6 || mode == OPENSSL_HTTPS6) {\n\t\topenssl_last_ip = ipv6_name;\n\t} else if (mode == OPENSSL_REVERSE && ipv6_name != NULL) {\n\t\topenssl_last_ip = ipv6_name;\n\t} else {\n\t\topenssl_last_ip = get_remote_host(sock);\n\t}\n\n\tif (!check_ssl_access(openssl_last_ip)) {\n\t\trfbLog(\"SSL: accept_openssl: denying client %s\\n\", openssl_last_ip);\n\t\trfbLog(\"SSL: accept_openssl: does not match -allow or other reason.\\n\");\n\t\tclose(sock);\n\t\tsock = -1;\n\t\tif (ssl_no_fail) {\n\t\t\tclean_up_exit(1);\n\t\t}\n\t\treturn;\n\t}\n\n\t/* now make a listening socket for child to connect back to us by: */\n\n\tcport = find_free_port(20000, 22000);\n\tif (! cport && ipv6_listen) {\n\t\trfbLog(\"SSL: accept_openssl: seeking IPv6 port.\\n\");\n\t\tcport = find_free_port6(20000, 22000);\n\t\trfbLog(\"SSL: accept_openssl: IPv6 port: %d\\n\", cport);\n\t}\n\tif (! cport) {\n\t\trfbLog(\"SSL: accept_openssl: could not find open port.\\n\");\n\t\tclose(sock);\n\t\tif (mode == OPENSSL_INETD || ssl_no_fail) {\n\t\t\tclean_up_exit(1);\n\t\t}\n\t\treturn;\n\t}\n\tif (db) fprintf(stderr, \"accept_openssl: cport: %d\\n\", cport);\n\n\tcsock = listen_tcp(cport, htonl(INADDR_LOOPBACK), 1);\n\n\tif (csock < 0) {\n\t\trfbLog(\"SSL: accept_openssl: could not listen on port %d.\\n\",\n\t\t    cport);\n\t\tclose(sock);\n\t\tif (mode == OPENSSL_INETD || ssl_no_fail) {\n\t\t\tclean_up_exit(1);\n\t\t}\n\t\treturn;\n\t}\n\tif (db) fprintf(stderr, \"accept_openssl: csock: %d\\n\", csock);\n\n\tfflush(stderr);\n\n\t/*\n\t * make a simple cookie to id the child socket, not foolproof\n\t * but hard to guess exactly (just worrying about local lusers\n\t * here, since we use INADDR_LOOPBACK).\n\t */\n\trb = (unsigned char *) calloc(6, 1);\n#if LIBVNCSERVER_HAVE_LIBSSL || HAVE_LIBSSL \n\tRAND_bytes(rb, 6);\n#endif\n\tsprintf(cookie, \"RB=%d%d%d%d%d%d/%f%f/%p\",\n\t    rb[0], rb[1], rb[2], rb[3], rb[4], rb[5],\n            dnow() - x11vnc_start, x11vnc_start, (void *)rb);\n\n\tif (mode == OPENSSL_VNC6) {\n\t\tname = strdup(ipv6_name);\n\t\tpeerport = get_remote_port(sock);\n\t} else if (mode == OPENSSL_REVERSE && ipv6_name != NULL) {\n\t\tname = strdup(ipv6_name);\n\t\tpeerport = get_remote_port(sock);\n\t} else if (mode != OPENSSL_INETD) {\n\t\tname = get_remote_host(sock);\n\t\tpeerport = get_remote_port(sock);\n\t} else {\n\t\topenssl_last_ip = get_remote_host(fileno(stdin));\n\t\tpeerport = get_remote_port(fileno(stdin));\n\t\tif (openssl_last_ip) {\n\t\t\tname = strdup(openssl_last_ip);\n\t\t} else {\n\t\t\tname = strdup(\"unknown\");\n\t\t}\n\t}\n\tif (name) {\n\t\tif (mode == OPENSSL_INETD) {\n\t\t\trfbLog(\"SSL: (inetd) spawning helper process \"\n\t\t\t    \"to handle: %s:%d\\n\", name, peerport);\n\t\t} else {\n\t\t\trfbLog(\"SSL: spawning helper process to handle: \"\n\t\t\t    \"%s:%d\\n\", name, peerport);\n\t\t}\n\t\tfree(name);\n\t\tname = NULL;\n\t}\n\n\tif (certret) {\n\t\tfree(certret);\n\t}\n\tif (certret_str) {\n\t\tfree(certret_str);\n\t\tcertret_str = NULL;\n\t}\n\tcertret = strdup(\"/tmp/x11vnc-certret.XXXXXX\");\n\tomode = umask(077);\n\tcertret_fd = mkstemp(certret);\n\tumask(omode);\n\tif (certret_fd < 0) {\n\t\tfree(certret);\n\t\tcertret = NULL;\n\t\tcertret_fd = -1;\n\t}\n\n\tif (dhret) {\n\t\tfree(dhret);\n\t}\n\tif (dhret_str) {\n\t\tfree(dhret_str);\n\t\tdhret_str = NULL;\n\t}\n\tdhret = strdup(\"/tmp/x11vnc-dhret.XXXXXX\");\n\tomode = umask(077);\n\tdhret_fd = mkstemp(dhret);\n\tumask(omode);\n\tif (dhret_fd < 0) {\n\t\tfree(dhret);\n\t\tdhret = NULL;\n\t\tdhret_fd = -1;\n\t}\n\n\t/* now fork the child to handle the SSL: */\n\tpid = fork();\n\n\tif (pid > 0) {\n\t\trfbLog(\"SSL: helper for peerport %d is pid %d: \\n\",\n\t\t    peerport, (int) pid);\n\t}\n\n\tif (pid < 0) {\n\t\trfbLog(\"SSL: accept_openssl: could not fork.\\n\");\n\t\trfbLogPerror(\"fork\");\n\t\tclose(sock);\n\t\tclose(csock);\n\t\tif (mode == OPENSSL_INETD || ssl_no_fail) {\n\t\t\tclean_up_exit(1);\n\t\t}\n\t\treturn;\n\n\t} else if (pid == 0) {\n\t\tint s_in, s_out, httpsock = -1;\n\t\tint vncsock;\n\t\tint i, have_httpd = 0;\n\t\tint f_in  = fileno(stdin);\n\t\tint f_out = fileno(stdout);\n\t\tint skip_vnc_tls = mode == OPENSSL_HTTPS ? 1 : 0;\n\n\t\tif (db) fprintf(stderr, \"helper pid in: %d %d %d %d\\n\", f_in, f_out, sock, listen);\n\n\t\t/* reset all handlers to default (no interrupted() calls) */\n\t\tunset_signals();\n\n\t\t/* close all non-essential fd's */\n\t\tfor (i=0; i<256; i++) {\n\t\t\tif (mode == OPENSSL_INETD) {\n\t\t\t\tif (i == f_in || i == f_out) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (i == sock) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (i == 2) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tclose(i);\n\t\t}\n\n\t\t/*\n\t\t * sadly, we are a long lived child and so the large\n\t\t * framebuffer memory areas will soon differ from parent.\n\t\t * try to free as much as possible.\n\t\t */\n\t\tlose_ram();\n\n\t\t/* now connect back to parent socket: */\n\t\tvncsock = connect_tcp(\"127.0.0.1\", cport);\n\t\tif (vncsock < 0) {\n\t\t\trfbLog(\"SSL: ssl_helper[%d]: could not connect\"\n\t\t\t    \" back to: %d\\n\", getpid(), cport);\n\t\t\trfbLog(\"SSL: ssl_helper[%d]: exit case 1 (no local vncsock)\\n\", getpid());\n\t\t\texit(1);\n\t\t}\n\t\tif (db) fprintf(stderr, \"vncsock %d\\n\", vncsock);\n\n\t\t/* try to initialize SSL with the remote client */\n\n\t\tif (mode == OPENSSL_INETD) {\n\t\t\ts_in  = fileno(stdin);\n\t\t\ts_out = fileno(stdout);\n\t\t} else {\n\t\t\ts_in = s_out = sock;\n\t\t}\n\n\t\tif (! ssl_init(s_in, s_out, skip_vnc_tls, last_https)) {\n\t\t\tclose(vncsock);\n\t\t\trfbLog(\"SSL: ssl_helper[%d]: exit case 2 (ssl_init failed)\\n\", getpid());\n\t\t\texit(1);\n\t\t}\n\n\t\tif (vencrypt_selected != 0) {\n\t\t\tchar *tbuf;\n\t\t\ttbuf = (char *) malloc(strlen(cookie) + 100);\n\t\t\tsprintf(tbuf, \"%s,VENCRYPT=%d,%s\", uniq, vencrypt_selected, cookie);\n\t\t\twrite(vncsock, tbuf, strlen(cookie));\n\t\t\tgoto wrote_cookie;\n\t\t} else if (anontls_selected != 0) {\n\t\t\tchar *tbuf;\n\t\t\ttbuf = (char *) malloc(strlen(cookie) + 100);\n\t\t\tsprintf(tbuf, \"%s,ANONTLS=%d,%s\", uniq, anontls_selected, cookie);\n\t\t\twrite(vncsock, tbuf, strlen(cookie));\n\t\t\tgoto wrote_cookie;\n\t\t}\n\n\t\t/*\n\t\t * things get messy below since we are trying to do\n\t\t * *both* VNC and Java applet httpd through the same\n\t\t * SSL socket.\n\t\t */\n\n\t\tif (! screen) {\n\t\t\tclose(vncsock);\n\t\t\texit(1);\n\t\t}\n\t\tif (screen->httpListenSock >= 0 && screen->httpPort > 0) {\n\t\t\thave_httpd = 1;\n\t\t} else if (ipv6_http_fd >= 0) {\n\t\t\thave_httpd = 1;\n\t\t} else if (screen->httpListenSock == -2) {\n\t\t\thave_httpd = 1;\n\t\t}\n\t\tif (mode == OPENSSL_HTTPS && ! have_httpd) {\n\t\t\trfbLog(\"SSL: accept_openssl[%d]: no httpd socket for \"\n\t\t\t    \"-https mode\\n\", getpid());\n\t\t\tclose(vncsock);\n\t\t\trfbLog(\"SSL: ssl_helper[%d]: exit case 3 (no httpd sock)\\n\", getpid());\n\t\t\texit(1);\n\t\t}\n\n\t\tif (have_httpd) {\n\t\t\tint n = 0, is_http = 0;\n\t\t\tint hport = screen->httpPort; \n\t\t\tchar *iface = NULL;\n\t\t\tchar *buf, *tbuf;\n\n\t\t\tbuf  = (char *) calloc((ABSIZE+1), 1);\n\t\t\ttbuf = (char *) calloc((2*ABSIZE+1), 1);\n\n\t\t\tif (mode == OPENSSL_HTTPS) {\n\t\t\t\t/*\n\t\t\t\t * for this mode we know it is HTTP traffic\n\t\t\t\t * so we skip trying to guess.\n\t\t\t\t */\n\t\t\t\tis_http = 1;\n\t\t\t\tn = 0;\n\t\t\t\tgoto connect_to_httpd;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * Check if there is stuff to read from remote end\n\t\t\t * if so it is likely a GET or HEAD.\n\t\t\t */\n\t\t\tif (! is_ssl_readable(s_in, last_https, last_get,\n\t\t\t    mode)) {\n\t\t\t\tgoto write_cookie;\n\t\t\t}\n\t\n\t\t\t/* \n\t\t\t * read first 2 bytes to try to guess.  sadly,\n\t\t\t * the user is often pondering a \"non-verified\n\t\t\t * cert\" dialog for a long time before the GET\n\t\t\t * is ever sent.  So often we timeout here.\n\t\t\t */\n\n\t\t\tif (db) fprintf(stderr, \"watch_for_http_traffic\\n\");\n\n\t\t\tis_http = watch_for_http_traffic(buf, &n, s_in);\n\n\t\t\tif (is_http < 0 || is_http == 0) {\n\t\t\t\t/*\n\t\t\t\t * error or http not detected, fall back\n\t\t\t\t * to normal VNC socket.\n\t\t\t\t */\n\t\t\t\tif (db) fprintf(stderr, \"is_http err: %d n: %d\\n\", is_http, n);\n\t\t\t\twrite(vncsock, cookie, strlen(cookie));\n\t\t\t\tif (n > 0) {\n\t\t\t\t\twrite(vncsock, buf, n);\n\t\t\t\t}\n\t\t\t\tgoto wrote_cookie;\n\t\t\t}\n\n\t\t\tif (db) fprintf(stderr, \"is_http: %d n: %d\\n\",\n\t\t\t    is_http, n);\n\t\t\tif (db) fprintf(stderr, \"buf: '%s'\\n\", buf);\n\n\t\t\tif (strstr(buf, \"/request.https.vnc.connection\")) {\n\t\t\t\tchar reply[] = \"HTTP/1.0 200 OK\\r\\n\"\n\t\t\t\t    \"Content-Type: octet-stream\\r\\n\"\n\t\t\t\t    \"Connection: Keep-Alive\\r\\n\"\n\t\t\t\t    \"VNC-Server: x11vnc\\r\\n\"\n\t\t\t\t    \"Pragma: no-cache\\r\\n\\r\\n\";\n\t\t\t\t/*\n\t\t\t\t * special case proxy coming thru https\n\t\t\t\t * instead of a direct SSL connection.\n\t\t\t\t */\n\t\t\t\trfbLog(\"Handling VNC request via https GET. [%d]\\n\", getpid());\n\t\t\t\trfbLog(\"-- %s\\n\", buf);\n\n\t\t\t\tif (strstr(buf, \"/reverse.proxy\")) {\n\t\t\t\t\tchar *buf2;\n\t\t\t\t\tint n, ptr;\n#if !LIBVNCSERVER_HAVE_LIBSSL && !HAVE_LIBSSL \n\t\t\t\t\twrite(s_out, reply, strlen(reply));\n#else\n\t\t\t\t\tSSL_write(ssl, reply, strlen(reply));\n#endif\n\t\t\t\t\n\t\t\t\t\tbuf2  = (char *) calloc((8192+1), 1);\n\t\t\t\t\tn = 0;\n\t\t\t\t\tptr = 0;\n\t\t\t\t\twhile (ptr < 8192) {\n#if !LIBVNCSERVER_HAVE_LIBSSL && !HAVE_LIBSSL \n\t\t\t\t\t\tn = read(s_in, buf2 + ptr, 1);\n#else\n\t\t\t\t\t\tn = SSL_read(ssl, buf2 + ptr, 1);\n#endif\n\t\t\t\t\t\tif (n > 0) {\n\t\t\t\t\t\t\tptr += n;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (db) fprintf(stderr, \"buf2: '%s'\\n\", buf2);\n\n\t\t\t\t\t\tif (strstr(buf2, \"\\r\\n\\r\\n\")) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tfree(buf2);\n\t\t\t\t}\n\t\t\t\tgoto write_cookie;\n\n\t\t\t} else if (strstr(buf, \"/check.https.proxy.connection\")) {\n\t\t\t\tchar reply[] = \"HTTP/1.0 200 OK\\r\\n\"\n\t\t\t\t    \"Connection: close\\r\\n\"\n\t\t\t\t    \"Content-Type: octet-stream\\r\\n\"\n\t\t\t\t    \"VNC-Server: x11vnc\\r\\n\"\n\t\t\t\t    \"Pragma: no-cache\\r\\n\\r\\n\";\n\n\t\t\t\trfbLog(\"Handling Check HTTPS request via https GET. [%d]\\n\", getpid());\n\t\t\t\trfbLog(\"-- %s\\n\", buf);\n\n#if !LIBVNCSERVER_HAVE_LIBSSL && !HAVE_LIBSSL \n\t\t\t\twrite(s_out, reply, strlen(reply));\n#else\n\t\t\t\tSSL_write(ssl, reply, strlen(reply));\n\t\t\t\tSSL_shutdown(ssl);\n#endif\n\n\t\t\t\tstrcpy(tbuf, uniq);\n\t\t\t\tstrcat(tbuf, cookie);\n\t\t\t\twrite(vncsock, tbuf, strlen(tbuf));\n\t\t\t\tclose(vncsock);\n\n\t\t\t\trfbLog(\"SSL: ssl_helper[%d]: exit case 4 (check.https.proxy.connection)\\n\", getpid());\n\t\t\t\texit(0);\n\t\t\t}\n\t\t\tconnect_to_httpd:\n\n\t\t\t/*\n\t\t\t * Here we go... no turning back.  we have to\n\t\t\t * send failure to parent and close socket to have\n\t\t\t * http processed at all in a timely fashion...\n\t\t\t */\n\n\t\t\t/* send the failure tag: */\n\t\t\tstrcpy(tbuf, uniq);\n\n\t\t\tif (https_port_redir < 0 || (strstr(buf, \"PORT=\") || strstr(buf, \"port=\"))) {\n\t\t\t\tchar *q = strstr(buf, \"Host:\");\n\t\t\t\tint fport = 443, match = 0;\n\t\t\t\tchar num[16];\n\n\t\t\t\tif (q && strstr(q, \"\\n\")) {\n\t\t\t\t    q += strlen(\"Host:\") + 1;\n\t\t\t\t    while (*q != '\\n') {\n\t\t\t\t\tint p;\n\t\t\t\t\tif (*q == ':' && sscanf(q, \":%d\", &p) == 1) {\n\t\t\t\t\t\tif (p > 0 && p < 65536) {\n\t\t\t\t\t\t\tfport = p;\n\t\t\t\t\t\t\tmatch = 1;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tq++;\n\t\t\t\t    }\n\t\t\t\t}\n\t\t\t\tif (!match || !https_port_redir) {\n\t\t\t\t\tint p;\n\t\t\t\t\tif (sscanf(buf, \"PORT=%d,\", &p) == 1) {\n\t\t\t\t\t\tif (p > 0 && p < 65536) {\n\t\t\t\t\t\t\tfport = p;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else if (sscanf(buf, \"port=%d,\", &p) == 1) {\n\t\t\t\t\t\tif (p > 0 && p < 65536) {\n\t\t\t\t\t\t\tfport = p;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tsprintf(num, \"HP=%d,\", fport);\n\t\t\t\tstrcat(tbuf, num);\n\t\t\t}\n\n\t\t\tif (strstr(buf, \"HTTP/\") != NULL)  {\n\t\t\t\tchar *q, *str;\n\t\t\t\t/*\n\t\t\t\t * Also send back the GET line for heuristics.\n\t\t\t\t * (last_https, get file).\n\t\t\t\t */\n\t\t\t\tstr = strdup(buf);\n\t\t\t\tq = strstr(str, \"HTTP/\");\n\t\t\t\tif (q != NULL) {\n\t\t\t\t\t*q = '\\0';\t\n\t\t\t\t\tstrcat(tbuf, str);\n\t\t\t\t}\n\t\t\t\tfree(str);\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * Also send the cookie to pad out the number of\n\t\t\t * bytes to more than the parent wants to read.\n\t\t\t * Since this is the failure case, it does not\n\t\t\t * matter that we send more than strlen(cookie).\n\t\t\t */\n\t\t\tstrcat(tbuf, cookie);\n\t\t\twrite(vncsock, tbuf, strlen(tbuf));\n\n\t\t\tusleep(150*1000);\n\t\t\tif (db) fprintf(stderr, \"close vncsock: %d\\n\", vncsock);\n\t\t\tclose(vncsock);\n\n\t\t\t/* now, finally, connect to the libvncserver httpd: */\n\t\t\tif (screen->listenInterface == htonl(INADDR_ANY) ||\n\t\t\t    screen->listenInterface == htonl(INADDR_NONE)) {\n\t\t\t\tiface = \"127.0.0.1\";\n\t\t\t} else {\n\t\t\t\tstruct in_addr in;\n\t\t\t\tin.s_addr = screen->listenInterface;\n\t\t\t\tiface = inet_ntoa(in);\n\t\t\t}\n\t\t\tif (iface == NULL || !strcmp(iface, \"\")) {\n\t\t\t\tiface = \"127.0.0.1\";\n\t\t\t}\n\t\t\tif (db) fprintf(stderr, \"iface: %s:%d\\n\", iface, hport);\n\t\t\tusleep(150*1000);\n\n\t\t\thttpsock = connect_tcp(iface, hport);\n\n\t\t\tif (httpsock < 0) {\n\t\t\t\t/* UGH, after all of that! */\n\t\t\t\trfbLog(\"Could not connect to httpd socket!\\n\");\n\t\t\t\trfbLog(\"SSL: ssl_helper[%d]: exit case 5.\\n\", getpid());\n\t\t\t\texit(1);\n\t\t\t}\n\t\t\tif (db) fprintf(stderr, \"ssl_helper[%d]: httpsock: %d %d\\n\",\n\t\t\t    getpid(), httpsock, n);\n\n\t\t\t/*\n\t\t\t * send what we read to httpd, and then connect\n\t\t\t * the rest of the SSL session to it:\n\t\t\t */\n\t\t\tif (n > 0) {\n\t\t\t\tchar *s = getenv(\"X11VNC_EXTRA_HTTPS_PARAMS\");\n\t\t\t\tint did_extra = 0;\n\n\t\t\t\tif (db) fprintf(stderr, \"sending http buffer httpsock: %d n=%d\\n'%s'\\n\", httpsock, n, buf);\n\t\t\t\tif (s != NULL) {\n\t\t\t\t\tchar *q = strstr(buf, \" HTTP/\");\n\t\t\t\t\tif (q) {\n\t\t\t\t\t\tint m;\n\t\t\t\t\t\t*q = '\\0';\n\t\t\t\t\t\tm = strlen(buf);\n\t\t\t\t\t\twrite(httpsock, buf, m);\n\t\t\t\t\t\twrite(httpsock, s, strlen(s));\n\t\t\t\t\t\t*q = ' ';\n\t\t\t\t\t\twrite(httpsock, q, n-m);\n\t\t\t\t\t\tdid_extra = 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (!did_extra) {\n\t\t\t\t\twrite(httpsock, buf, n);\n\t\t\t\t}\n\t\t\t}\n\t\t\tssl_xfer(httpsock, s_in, s_out, is_http);\n\t\t\trfbLog(\"SSL: ssl_helper[%d]: exit case 6 (https ssl_xfer done)\\n\", getpid());\n\t\t\texit(0);\n\t\t}\n\n\t\t/*\n\t\t * ok, back from the above https mess, simply send the\n\t\t * cookie back to the parent (who will attach us to\n\t\t * libvncserver), and connect the rest of the SSL session\n\t\t * to it.\n\t\t */\n\t\twrite_cookie:\n\t\twrite(vncsock, cookie, strlen(cookie));\n\n\t\twrote_cookie:\n\t\tssl_xfer(vncsock, s_in, s_out, 0);\n\t\trfbLog(\"SSL: ssl_helper[%d]: exit case 7 (ssl_xfer done)\\n\", getpid());\n\t\tif (0) usleep(50 * 1000);\n\t\texit(0);\n\t}\n\t/* parent here */\n\n\tif (mode != OPENSSL_INETD) {\n\t\tclose(sock);\n\t}\n\tif (db) fprintf(stderr, \"helper process is: %d\\n\", pid);\n\n\t/* accept connection from our child.  */\n\tsignal(SIGALRM, csock_timeout);\n\tcsock_timeout_sock = csock;\n\talarm(20);\n\n\tvsock = accept(csock, (struct sockaddr *)&addr, &addrlen);\n\n\talarm(0);\n\tsignal(SIGALRM, SIG_DFL);\n\tclose(csock);\n\n\n\tif (vsock < 0) {\n\t\trfbLog(\"SSL: accept_openssl: connection from ssl_helper[%d] FAILED.\\n\", pid);\n\t\trfbLogPerror(\"accept\");\n\n\t\tkill(pid, SIGTERM);\n\t\twaitpid(pid, &status, WNOHANG); \n\t\tif (mode == OPENSSL_INETD || ssl_no_fail) {\n\t\t\tclean_up_exit(1);\n\t\t}\n\t\tif (certret_fd >= 0) {\n\t\t\tclose(certret_fd);\n\t\t\tcertret_fd = -1;\n\t\t}\n\t\tif (certret) {\n\t\t\tunlink(certret);\n\t\t}\n\t\tif (dhret_fd >= 0) {\n\t\t\tclose(dhret_fd);\n\t\t\tdhret_fd = -1;\n\t\t}\n\t\tif (dhret) {\n\t\t\tunlink(dhret);\n\t\t}\n\t\treturn;\n\t}\n\tif (db) fprintf(stderr, \"accept_openssl: vsock: %d\\n\", vsock);\n\n\tn = read(vsock, rcookie, strlen(cookie));\n\tif (n < 0 && errno != 0) {\n\t\trfbLogPerror(\"read\");\n\t}\n\n\tif (certret) {\n\t\tstruct stat sbuf;\n\t\tsbuf.st_size = 0;\n\t\tif (certret_fd >= 0 && stat(certret, &sbuf) == 0 && sbuf.st_size > 0) {\n\t\t\tcertret_str = (char *) calloc(sbuf.st_size+1, 1);\n\t\t\tread(certret_fd, certret_str, sbuf.st_size);\n\t\t\tclose(certret_fd);\n\t\t\tcertret_fd = -1;\n\t\t}\n\t\tif (certret_fd >= 0) {\n\t\t\tclose(certret_fd);\n\t\t\tcertret_fd = -1;\n\t\t}\n\t\tunlink(certret);\n\t\tif (certret_str && strstr(certret_str, \"NOCERT\") == certret_str) {\n\t\t\tfree(certret_str);\n\t\t\tcertret_str = NULL;\n\t\t}\n\t\tif (0 && certret_str) {\n\t\t\tfprintf(stderr, \"certret_str[%d]:\\n%s\\n\", (int) sbuf.st_size, certret_str);\n\t\t}\n\t}\n\n\tif (dhret) {\n\t\tstruct stat sbuf;\n\t\tsbuf.st_size = 0;\n\t\tif (dhret_fd >= 0 && stat(dhret, &sbuf) == 0 && sbuf.st_size > 0) {\n\t\t\tdhret_str = (char *) calloc(sbuf.st_size+1, 1);\n\t\t\tread(dhret_fd, dhret_str, sbuf.st_size);\n\t\t\tclose(dhret_fd);\n\t\t\tdhret_fd = -1;\n\t\t}\n\t\tif (dhret_fd >= 0) {\n\t\t\tclose(dhret_fd);\n\t\t\tdhret_fd = -1;\n\t\t}\n\t\tunlink(dhret);\n\t\tif (dhret_str && strstr(dhret_str, \"NOCERT\") == dhret_str) {\n\t\t\tfree(dhret_str);\n\t\t\tdhret_str = NULL;\n\t\t}\n\t\tif (dhret_str) {\n\t\t\tif (new_dh_params == NULL) {\n\t\t\t\tfprintf(stderr, \"dhret_str[%d]:\\n%s\\n\", (int) sbuf.st_size, dhret_str);\n\t\t\t\tnew_dh_params = strdup(dhret_str);\n\t\t\t}\n\t\t}\n\t}\n\n\tif (0) {\n\t\tfprintf(stderr, \"rcookie: %s\\n\", rcookie);\n\t\tfprintf(stderr, \"cookie:  %s\\n\", cookie);\n\t}\n\n\tif (strstr(rcookie, uniq) == rcookie) {\n\t\tchar *q = strstr(rcookie, \"RB=\");\n\t\tif (q && strstr(cookie, q) == cookie) {\n\t\t\tvencrypt_sel = 0;\n\t\t\tanontls_sel = 0;\n\t\t\tq = strstr(rcookie, \"VENCRYPT=\");\n\t\t\tif (q && sscanf(q, \"VENCRYPT=%d,\", &vencrypt_sel) == 1) {\n\t\t\t\tif (vencrypt_sel != 0) {\n\t\t\t\t\trfbLog(\"SSL: VENCRYPT mode=%d accepted. helper[%d]\\n\", vencrypt_sel, pid);\n\t\t\t\t\tgoto accept_client;\n\t\t\t\t}\n\t\t\t}\n\t\t\tq = strstr(rcookie, \"ANONTLS=\");\n\t\t\tif (q && sscanf(q, \"ANONTLS=%d,\", &anontls_sel) == 1) {\n\t\t\t\tif (anontls_sel != 0) {\n\t\t\t\t\trfbLog(\"SSL: ANONTLS mode=%d accepted. helper[%d]\\n\", anontls_sel, pid);\n\t\t\t\t\tgoto accept_client;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tif (n != (int) strlen(cookie) || strncmp(cookie, rcookie, n)) {\n\t\trfbLog(\"SSL: accept_openssl: cookie from ssl_helper[%d] FAILED. %d\\n\", pid, n);\n\t\tif (db) fprintf(stderr, \"'%s'\\n'%s'\\n\", cookie, rcookie);\n\t\tclose(vsock);\n\n\t\tif (strstr(rcookie, uniq) == rcookie) {\n\t\t\tint i;\n\t\t\tdouble https_download_wait_time = 15.0;\n\n\t\t\tif (getenv(\"X11VNC_HTTPS_DOWNLOAD_WAIT_TIME\")) {\n\t\t\t\thttps_download_wait_time = atof(getenv(\"X11VNC_HTTPS_DOWNLOAD_WAIT_TIME\"));\n\t\t\t}\n\n\t\t\trfbLog(\"SSL: BUT WAIT! HTTPS for helper process[%d] succeeded. Good.\\n\", pid);\n\t\t\tif (mode != OPENSSL_HTTPS) {\n\t\t\t\tlast_https = dnow();\n\t\t\t\tfor (i=0; i<256; i++) {\n\t\t\t\t\tlast_get[i] = '\\0';\n\t\t\t\t}\n\t\t\t\tstrncpy(last_get, rcookie, 100);\n\t\t\t\tif (db) fprintf(stderr, \"last_get: '%s'\\n\", last_get);\n\t\t\t}\n\t\t\tif (rcookie && strstr(rcookie, \"VncViewer.class\")) {\n\t\t\t\trfbLog(\"\\n\");\n\t\t\t\trfbLog(\"helper[%d]:\\n\", pid);\n\t\t\t\trfbLog(\"***********************************************************\\n\");\n\t\t\t\trfbLog(\"SSL: WARNING CLIENT ASKED FOR NONEXISTENT 'VncViewer.class'\\n\");\n\t\t\t\trfbLog(\"SSL: USER NEEDS TO MAKE SURE THE JAVA PLUGIN IS INSTALLED\\n\");\n\t\t\t\trfbLog(\"SSL: AND WORKING PROPERLY (e.g. a test-java-plugin page.)\\n\");\n\t\t\t\trfbLog(\"SSL: AND/OR USER NEEDS TO **RESTART** HIS WEB BROWSER.\\n\");\n\t\t\t\trfbLog(\"SSL: SOMETIMES THE BROWSER 'REMEMBERS' FAILED APPLET DOWN-\\n\");\n\t\t\t\trfbLog(\"SSL: LOADS AND RESTARTING IT IS THE ONLY WAY TO FIX THINGS.\\n\");\n\t\t\t\trfbLog(\"***********************************************************\\n\");\n\t\t\t\trfbLog(\"\\n\");\n\t\t\t}\n\t\t\tssl_helper_pid(pid, -2);\n\n\t\t\tif (https_port_redir) {\n\t\t\t\tdouble start;\n\t\t\t\tint origport = screen->port;\n\t\t\t\tint useport = screen->port;\n\t\t\t\tint saw_httpsock = 0;\n\t\t\t\t/* to expand $PORT correctly in index.vnc */\n\t\t\t\tif (https_port_redir < 0) {\n\t\t\t\t\tchar *q = strstr(rcookie, \"HP=\");\n\t\t\t\t\tif (q) {\n\t\t\t\t\t\tint p;\n\t\t\t\t\t\tif (sscanf(q, \"HP=%d,\", &p) == 1) {\n\t\t\t\t\t\t\tuseport = p;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tuseport = https_port_redir;\n\t\t\t\t}\n\t\t\t\tscreen->port = useport;\n\t\t\t\tif (origport != useport) {\n\t\t\t\t\trfbLog(\"SSL: -httpsredir guess port: %d  helper[%d]\\n\", screen->port, pid);\n\t\t\t\t}\n\n\t\t\t\tstart = dnow();\n\t\t\t\twhile (dnow() < start + https_download_wait_time) {\n\t\t\t\t\tif (screen->httpSock >= 0) saw_httpsock = 1;\n\t\t\t\t\trfbPE(10000);\n\t\t\t\t\tusleep(10000);\n\t\t\t\t\tif (screen->httpSock >= 0) saw_httpsock = 1;\n\t\t\t\t\twaitpid(pid, &status, WNOHANG); \n\t\t\t\t\tif (kill(pid, 0) != 0) {\n\t\t\t\t\t\trfbLog(\"SSL: helper[%d] pid finished\\n\", pid);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif (0 && saw_httpsock && screen->httpSock < 0) {\n\t\t\t\t\t\t/* this check can kill the helper too soon. */\n\t\t\t\t\t\trfbLog(\"SSL: httpSock for helper[%d] went away\\n\", pid);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\trfbLog(\"SSL: guessing child helper[%d] https finished. dt=%.6f\\n\",\n\t\t\t\t    pid, dnow() - start);\n\n\t\t\t\trfbPE(10000);\n\t\t\t\trfbPE(10000);\n\t\t\t\trfbPE(10000);\n\n\t\t\t\tscreen->port = origport;\n\t\t\t\tssl_helper_pid(0, -2);\n\t\t\t\tif (mode == OPENSSL_INETD) {\n\t\t\t\t\tclean_up_exit(1);\n\t\t\t\t}\n\t\t\t} else if (mode == OPENSSL_INETD) {\n\t\t\t\tdouble start;\n\t\t\t\tint saw_httpsock = 0;\n\n\t\t\t\t/* to expand $PORT correctly in index.vnc */\n\t\t\t\tif (screen->port == 0) {\n\t\t\t\t\tint fd = fileno(stdin);\n\t\t\t\t\tif (getenv(\"X11VNC_INETD_PORT\")) {\n\t\t\t\t\t\t/* mutex */\n\t\t\t\t\t\tscreen->port = atoi(getenv(\n\t\t\t\t\t\t    \"X11VNC_INETD_PORT\"));\n\t\t\t\t\t} else {\n\t\t\t\t\t\tint tport = get_local_port(fd);\n\t\t\t\t\t\tif (tport > 0) {\n\t\t\t\t\t\t\tscreen->port = tport;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\trfbLog(\"SSL: screen->port %d for helper[%d]\\n\", screen->port, pid);\n\n\t\t\t\t/* kludge for https fetch via inetd */\n\t\t\t\tstart = dnow();\n\t\t\t\twhile (dnow() < start + https_download_wait_time) {\n\t\t\t\t\tif (screen->httpSock >= 0) saw_httpsock = 1;\n\t\t\t\t\trfbPE(10000);\n\t\t\t\t\tusleep(10000);\n\t\t\t\t\tif (screen->httpSock >= 0) saw_httpsock = 1;\n\t\t\t\t\twaitpid(pid, &status, WNOHANG); \n\t\t\t\t\tif (kill(pid, 0) != 0) {\n\t\t\t\t\t\trfbLog(\"SSL: helper[%d] pid finished\\n\", pid);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif (0 && saw_httpsock && screen->httpSock < 0) {\n\t\t\t\t\t\t/* this check can kill the helper too soon. */\n\t\t\t\t\t\trfbLog(\"SSL: httpSock for helper[%d] went away\\n\", pid);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\trfbLog(\"SSL: OPENSSL_INETD guessing \"\n\t\t\t\t    \"child helper[%d] https finished. dt=%.6f\\n\",\n\t\t\t\t    pid, dnow() - start);\n\n\t\t\t\trfbPE(10000);\n\t\t\t\trfbPE(10000);\n\t\t\t\trfbPE(10000);\n\n\t\t\t\tssl_helper_pid(0, -2);\n\t\t\t\tclean_up_exit(1);\n\t\t\t}\n\t\t\t/* this will actually only get earlier https */\n\t\t\tssl_helper_pid(0, -2);\n\t\t\treturn;\n\t\t}\n\t\tkill(pid, SIGTERM);\n\t\twaitpid(pid, &status, WNOHANG); \n\t\tif (mode == OPENSSL_INETD || ssl_no_fail) {\n\t\t\tclean_up_exit(1);\n\t\t}\n\t\treturn;\n\t}\n\n\taccept_client:\n\n\tif (db) fprintf(stderr, \"accept_openssl: cookie good: %s\\n\", cookie);\n\n\trfbLog(\"SSL: handshake with helper process[%d] succeeded.\\n\", pid);\n\n\topenssl_last_helper_pid = pid;\n\tssl_helper_pid(pid, vsock);\n\n\tif (vnc_redirect) {\n\t\tvnc_redirect_sock = vsock;\n\t\topenssl_last_helper_pid = 0;\n\t\treturn;\n\t}\n\n\tclient = create_new_client(vsock, 0);\n\topenssl_last_helper_pid = 0;\n\n\tif (client) {\n\t\tint swt = 0;\n\t\tif (mode == OPENSSL_VNC6 && openssl_last_ip != NULL) {\n\t\t\tswt = 1;\n\t\t} else if (mode == OPENSSL_REVERSE && ipv6_name != NULL && openssl_last_ip != NULL) {\n\t\t\tswt = 1;\n\t\t}\n\t\tif (swt) {\n\t\t\tif (client->host) {\n\t\t\t\tfree(client->host);\n\t\t\t}\n\t\t\tclient->host = strdup(openssl_last_ip);\n\t\t}\n\t\tif (db) fprintf(stderr, \"accept_openssl: client %p\\n\", (void *) client);\n\t\tif (db) fprintf(stderr, \"accept_openssl: new_client %p\\n\", (void *) screen->newClientHook);\n\t\tif (db) fprintf(stderr, \"accept_openssl: new_client %p\\n\", (void *) new_client);\n\t\tif (mode == OPENSSL_INETD) {\n\t\t\tinetd_client = client;\n\t\t\tclient->clientGoneHook = client_gone;\n\t\t}\n\t\tif (openssl_last_ip &&\n\t\t    strpbrk(openssl_last_ip, \"0123456789\") == openssl_last_ip) {\n\t\t\tclient->host = strdup(openssl_last_ip);\n\t\t}\n\t\tif (vencrypt_sel != 0) {\n\t\t\tclient->protocolMajorVersion = 3;\n\t\t\tclient->protocolMinorVersion = 8;\n#if LIBVNCSERVER_HAVE_LIBSSL || HAVE_LIBSSL \n\t\t\tif (!finish_vencrypt_auth(client, vencrypt_sel)) {\n\t\t\t\trfbCloseClient(client);\n\t\t\t\tclient = NULL;\n\t\t\t}\n#else\n\t\t\tbadnews(\"3 accept_openssl\");\n#endif\n\t\t} else if (anontls_sel != 0) {\n\t\t\tclient->protocolMajorVersion = 3;\n\t\t\tclient->protocolMinorVersion = 8;\n\t\t\trfbAuthNewClient(client);\n\t\t}\n\t\tif (use_threads && client != NULL) {\n\t\t\trfbStartOnHoldClient(client);\n\t\t}\n\t\t/* try to get RFB proto done now. */\n\t\tprogress_client();\n\t} else {\n\t\trfbLog(\"SSL: accept_openssl: rfbNewClient failed.\\n\");\n\t\tclose(vsock);\n\n\t\tkill(pid, SIGTERM);\n\t\twaitpid(pid, &status, WNOHANG); \n\t\tif (mode == OPENSSL_INETD || ssl_no_fail) {\n\t\t\tclean_up_exit(1);\n\t\t}\n\t\treturn;\n\t}\n}",
          "includes": [
            "#include <openssl/rand.h>",
            "#include <openssl/err.h>",
            "#include <openssl/ssl.h>",
            "#include \"user.h\"",
            "#include \"unixpw.h\"",
            "#include \"sslcmds.h\"",
            "#include \"connections.h\"",
            "#include \"scan.h\"",
            "#include \"screen.h\"",
            "#include \"cleanup.h\"",
            "#include \"inet.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [
            "#define HAVE_LIBSSL 0",
            "#define LIBVNCSERVER_HAVE_LIBSSL 0",
            "#define ABSIZE 16384",
            "#define OPENSSL_REVERSE 6",
            "#define OPENSSL_HTTPS6  5",
            "#define OPENSSL_HTTPS   4",
            "#define OPENSSL_VNC6    3",
            "#define OPENSSL_VNC     2",
            "#define OPENSSL_INETD   1"
          ],
          "globals_used": [
            "int openssl_sock = -1;",
            "int openssl_sock6 = -1;",
            "int https_sock = -1;",
            "int https_sock6 = -1;",
            "pid_t openssl_last_helper_pid = 0;",
            "char *openssl_last_ip = NULL;",
            "static char *certret = NULL;",
            "static int certret_fd = -1;",
            "static mode_t omode;",
            "char *certret_str = NULL;",
            "static char *dhret = NULL;",
            "static int dhret_fd = -1;",
            "char *dhret_str = NULL;",
            "char *new_dh_params = NULL;",
            "void raw_xfer(int csock, int s_in, int s_out);",
            "static char *get_input(char *tag, char **in);",
            "void ssl_helper_pid(pid_t pid, int sock);",
            "void accept_openssl(int mode, int presock);",
            "static void lose_ram(void);",
            "static int vencrypt_selected = 0;",
            "static int anontls_selected = 0;",
            "static int csock_timeout_sock = -1;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <openssl/rand.h>\n#include <openssl/err.h>\n#include <openssl/ssl.h>\n#include \"user.h\"\n#include \"unixpw.h\"\n#include \"sslcmds.h\"\n#include \"connections.h\"\n#include \"scan.h\"\n#include \"screen.h\"\n#include \"cleanup.h\"\n#include \"inet.h\"\n#include \"x11vnc.h\"\n\n#define HAVE_LIBSSL 0\n#define LIBVNCSERVER_HAVE_LIBSSL 0\n#define ABSIZE 16384\n#define OPENSSL_REVERSE 6\n#define OPENSSL_HTTPS6  5\n#define OPENSSL_HTTPS   4\n#define OPENSSL_VNC6    3\n#define OPENSSL_VNC     2\n#define OPENSSL_INETD   1\n\nint openssl_sock = -1;\nint openssl_sock6 = -1;\nint https_sock = -1;\nint https_sock6 = -1;\npid_t openssl_last_helper_pid = 0;\nchar *openssl_last_ip = NULL;\nstatic char *certret = NULL;\nstatic int certret_fd = -1;\nstatic mode_t omode;\nchar *certret_str = NULL;\nstatic char *dhret = NULL;\nstatic int dhret_fd = -1;\nchar *dhret_str = NULL;\nchar *new_dh_params = NULL;\nvoid raw_xfer(int csock, int s_in, int s_out);\nstatic char *get_input(char *tag, char **in);\nvoid ssl_helper_pid(pid_t pid, int sock);\nvoid accept_openssl(int mode, int presock);\nstatic void lose_ram(void);\nstatic int vencrypt_selected = 0;\nstatic int anontls_selected = 0;\nstatic int csock_timeout_sock = -1;\n\nvoid accept_openssl(int mode, int presock) {\n\tint sock = -1, listen = -1, cport, csock, vsock;\t\n\tint peerport = 0;\n\tint status, n, i, db = 0;\n\tstruct sockaddr_in addr;\n#ifdef __hpux\n\tint addrlen = sizeof(addr);\n#else\n\tsocklen_t addrlen = sizeof(addr);\n#endif\n\trfbClientPtr client;\n\tpid_t pid;\n\tchar uniq[] = \"_evilrats_\";\n\tchar cookie[256], rcookie[256], *name = NULL;\n\tint vencrypt_sel = 0;\n\tint anontls_sel = 0;\n\tchar *ipv6_name = NULL;\n\tstatic double last_https = 0.0;\n\tstatic char last_get[256];\n\tstatic int first = 1;\n\tunsigned char *rb;\n\n#if !LIBVNCSERVER_HAVE_LIBSSL && !HAVE_LIBSSL  \n\tif (enc_str == NULL || strcmp(enc_str, \"none\")) {\n\t\tbadnews(\"0 accept_openssl\");\n\t}\n#endif\n\n\topenssl_last_helper_pid = 0;\n\n\t/* zero buffers for use below. */\n\tfor (i=0; i<256; i++) {\n\t\tif (first) {\n\t\t\tlast_get[i] = '\\0';\n\t\t}\n\t\tcookie[i]  = '\\0';\n\t\trcookie[i] = '\\0';\n\t}\n\tfirst = 0;\n\n\tif (getenv(\"ACCEPT_OPENSSL_DEBUG\")) {\n\t\tdb = atoi(getenv(\"ACCEPT_OPENSSL_DEBUG\"));\n\t}\n\n\t/* do INETD, VNC, or HTTPS cases (result is client socket or pipe) */\n\tif (mode == OPENSSL_INETD) {\n\t\tssl_initialized = 1;\n\n\t} else if (mode == OPENSSL_VNC) {\n\t\tsock = accept(openssl_sock, (struct sockaddr *)&addr, &addrlen);\n\t\tif (sock < 0)  {\n\t\t\trfbLog(\"SSL: accept_openssl: accept connection failed\\n\");\n\t\t\trfbLogPerror(\"accept\");\n\t\t\tif (ssl_no_fail) {\n\t\t\t\tclean_up_exit(1);\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t\tlisten = openssl_sock;\n\n\t} else if (mode == OPENSSL_VNC6 || mode == OPENSSL_HTTPS6) {\n#if X11VNC_IPV6\n\t\tstruct sockaddr_in6 a6;\n\t\tsocklen_t a6len = sizeof(a6);\n\t\tint fd = (mode == OPENSSL_VNC6 ? openssl_sock6 : https_sock6); \n\n\t\tsock = accept(fd, (struct sockaddr *)&a6, &a6len);\n\t\tif (sock < 0)  {\n\t\t\trfbLog(\"SSL: accept_openssl: accept connection failed\\n\");\n\t\t\trfbLogPerror(\"accept\");\n\t\t\tif (ssl_no_fail) {\n\t\t\t\tclean_up_exit(1);\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t\tipv6_name = ipv6_getipaddr((struct sockaddr *)&a6, a6len);\n\t\tif (!ipv6_name) ipv6_name = strdup(\"unknown\");\n\t\tlisten = fd;\n#endif\n\t} else if (mode == OPENSSL_REVERSE) {\n\t\tsock = presock;\n\t\tif (sock < 0)  {\n\t\t\trfbLog(\"SSL: accept_openssl: connection failed\\n\");\n\t\t\tif (ssl_no_fail) {\n\t\t\t\tclean_up_exit(1);\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t\tif (getenv(\"OPENSSL_REVERSE_DEBUG\")) fprintf(stderr, \"OPENSSL_REVERSE: ipv6_client_ip_str: %s\\n\", ipv6_client_ip_str);\n\t\tif (ipv6_client_ip_str != NULL) {\n\t\t\tipv6_name = strdup(ipv6_client_ip_str);\n\t\t}\n\t\tlisten = -1;\n\n\t} else if (mode == OPENSSL_HTTPS) {\n\t\tsock = accept(https_sock, (struct sockaddr *)&addr, &addrlen);\n\t\tif (sock < 0)  {\n\t\t\trfbLog(\"SSL: accept_openssl: accept connection failed\\n\");\n\t\t\trfbLogPerror(\"accept\");\n\t\t\tif (ssl_no_fail) {\n\t\t\t\tclean_up_exit(1);\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t\tlisten = https_sock;\n\t}\n\tif (db) fprintf(stderr, \"SSL: accept_openssl: sock: %d\\n\", sock);\n\n\tif (openssl_last_ip) {\n\t\tfree(openssl_last_ip);\n\t\topenssl_last_ip = NULL;\n\t}\n\tif (mode == OPENSSL_INETD) {\n\t\topenssl_last_ip = get_remote_host(fileno(stdin));\n\t} else if (mode == OPENSSL_VNC6 || mode == OPENSSL_HTTPS6) {\n\t\topenssl_last_ip = ipv6_name;\n\t} else if (mode == OPENSSL_REVERSE && ipv6_name != NULL) {\n\t\topenssl_last_ip = ipv6_name;\n\t} else {\n\t\topenssl_last_ip = get_remote_host(sock);\n\t}\n\n\tif (!check_ssl_access(openssl_last_ip)) {\n\t\trfbLog(\"SSL: accept_openssl: denying client %s\\n\", openssl_last_ip);\n\t\trfbLog(\"SSL: accept_openssl: does not match -allow or other reason.\\n\");\n\t\tclose(sock);\n\t\tsock = -1;\n\t\tif (ssl_no_fail) {\n\t\t\tclean_up_exit(1);\n\t\t}\n\t\treturn;\n\t}\n\n\t/* now make a listening socket for child to connect back to us by: */\n\n\tcport = find_free_port(20000, 22000);\n\tif (! cport && ipv6_listen) {\n\t\trfbLog(\"SSL: accept_openssl: seeking IPv6 port.\\n\");\n\t\tcport = find_free_port6(20000, 22000);\n\t\trfbLog(\"SSL: accept_openssl: IPv6 port: %d\\n\", cport);\n\t}\n\tif (! cport) {\n\t\trfbLog(\"SSL: accept_openssl: could not find open port.\\n\");\n\t\tclose(sock);\n\t\tif (mode == OPENSSL_INETD || ssl_no_fail) {\n\t\t\tclean_up_exit(1);\n\t\t}\n\t\treturn;\n\t}\n\tif (db) fprintf(stderr, \"accept_openssl: cport: %d\\n\", cport);\n\n\tcsock = listen_tcp(cport, htonl(INADDR_LOOPBACK), 1);\n\n\tif (csock < 0) {\n\t\trfbLog(\"SSL: accept_openssl: could not listen on port %d.\\n\",\n\t\t    cport);\n\t\tclose(sock);\n\t\tif (mode == OPENSSL_INETD || ssl_no_fail) {\n\t\t\tclean_up_exit(1);\n\t\t}\n\t\treturn;\n\t}\n\tif (db) fprintf(stderr, \"accept_openssl: csock: %d\\n\", csock);\n\n\tfflush(stderr);\n\n\t/*\n\t * make a simple cookie to id the child socket, not foolproof\n\t * but hard to guess exactly (just worrying about local lusers\n\t * here, since we use INADDR_LOOPBACK).\n\t */\n\trb = (unsigned char *) calloc(6, 1);\n#if LIBVNCSERVER_HAVE_LIBSSL || HAVE_LIBSSL \n\tRAND_bytes(rb, 6);\n#endif\n\tsprintf(cookie, \"RB=%d%d%d%d%d%d/%f%f/%p\",\n\t    rb[0], rb[1], rb[2], rb[3], rb[4], rb[5],\n            dnow() - x11vnc_start, x11vnc_start, (void *)rb);\n\n\tif (mode == OPENSSL_VNC6) {\n\t\tname = strdup(ipv6_name);\n\t\tpeerport = get_remote_port(sock);\n\t} else if (mode == OPENSSL_REVERSE && ipv6_name != NULL) {\n\t\tname = strdup(ipv6_name);\n\t\tpeerport = get_remote_port(sock);\n\t} else if (mode != OPENSSL_INETD) {\n\t\tname = get_remote_host(sock);\n\t\tpeerport = get_remote_port(sock);\n\t} else {\n\t\topenssl_last_ip = get_remote_host(fileno(stdin));\n\t\tpeerport = get_remote_port(fileno(stdin));\n\t\tif (openssl_last_ip) {\n\t\t\tname = strdup(openssl_last_ip);\n\t\t} else {\n\t\t\tname = strdup(\"unknown\");\n\t\t}\n\t}\n\tif (name) {\n\t\tif (mode == OPENSSL_INETD) {\n\t\t\trfbLog(\"SSL: (inetd) spawning helper process \"\n\t\t\t    \"to handle: %s:%d\\n\", name, peerport);\n\t\t} else {\n\t\t\trfbLog(\"SSL: spawning helper process to handle: \"\n\t\t\t    \"%s:%d\\n\", name, peerport);\n\t\t}\n\t\tfree(name);\n\t\tname = NULL;\n\t}\n\n\tif (certret) {\n\t\tfree(certret);\n\t}\n\tif (certret_str) {\n\t\tfree(certret_str);\n\t\tcertret_str = NULL;\n\t}\n\tcertret = strdup(\"/tmp/x11vnc-certret.XXXXXX\");\n\tomode = umask(077);\n\tcertret_fd = mkstemp(certret);\n\tumask(omode);\n\tif (certret_fd < 0) {\n\t\tfree(certret);\n\t\tcertret = NULL;\n\t\tcertret_fd = -1;\n\t}\n\n\tif (dhret) {\n\t\tfree(dhret);\n\t}\n\tif (dhret_str) {\n\t\tfree(dhret_str);\n\t\tdhret_str = NULL;\n\t}\n\tdhret = strdup(\"/tmp/x11vnc-dhret.XXXXXX\");\n\tomode = umask(077);\n\tdhret_fd = mkstemp(dhret);\n\tumask(omode);\n\tif (dhret_fd < 0) {\n\t\tfree(dhret);\n\t\tdhret = NULL;\n\t\tdhret_fd = -1;\n\t}\n\n\t/* now fork the child to handle the SSL: */\n\tpid = fork();\n\n\tif (pid > 0) {\n\t\trfbLog(\"SSL: helper for peerport %d is pid %d: \\n\",\n\t\t    peerport, (int) pid);\n\t}\n\n\tif (pid < 0) {\n\t\trfbLog(\"SSL: accept_openssl: could not fork.\\n\");\n\t\trfbLogPerror(\"fork\");\n\t\tclose(sock);\n\t\tclose(csock);\n\t\tif (mode == OPENSSL_INETD || ssl_no_fail) {\n\t\t\tclean_up_exit(1);\n\t\t}\n\t\treturn;\n\n\t} else if (pid == 0) {\n\t\tint s_in, s_out, httpsock = -1;\n\t\tint vncsock;\n\t\tint i, have_httpd = 0;\n\t\tint f_in  = fileno(stdin);\n\t\tint f_out = fileno(stdout);\n\t\tint skip_vnc_tls = mode == OPENSSL_HTTPS ? 1 : 0;\n\n\t\tif (db) fprintf(stderr, \"helper pid in: %d %d %d %d\\n\", f_in, f_out, sock, listen);\n\n\t\t/* reset all handlers to default (no interrupted() calls) */\n\t\tunset_signals();\n\n\t\t/* close all non-essential fd's */\n\t\tfor (i=0; i<256; i++) {\n\t\t\tif (mode == OPENSSL_INETD) {\n\t\t\t\tif (i == f_in || i == f_out) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (i == sock) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (i == 2) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tclose(i);\n\t\t}\n\n\t\t/*\n\t\t * sadly, we are a long lived child and so the large\n\t\t * framebuffer memory areas will soon differ from parent.\n\t\t * try to free as much as possible.\n\t\t */\n\t\tlose_ram();\n\n\t\t/* now connect back to parent socket: */\n\t\tvncsock = connect_tcp(\"127.0.0.1\", cport);\n\t\tif (vncsock < 0) {\n\t\t\trfbLog(\"SSL: ssl_helper[%d]: could not connect\"\n\t\t\t    \" back to: %d\\n\", getpid(), cport);\n\t\t\trfbLog(\"SSL: ssl_helper[%d]: exit case 1 (no local vncsock)\\n\", getpid());\n\t\t\texit(1);\n\t\t}\n\t\tif (db) fprintf(stderr, \"vncsock %d\\n\", vncsock);\n\n\t\t/* try to initialize SSL with the remote client */\n\n\t\tif (mode == OPENSSL_INETD) {\n\t\t\ts_in  = fileno(stdin);\n\t\t\ts_out = fileno(stdout);\n\t\t} else {\n\t\t\ts_in = s_out = sock;\n\t\t}\n\n\t\tif (! ssl_init(s_in, s_out, skip_vnc_tls, last_https)) {\n\t\t\tclose(vncsock);\n\t\t\trfbLog(\"SSL: ssl_helper[%d]: exit case 2 (ssl_init failed)\\n\", getpid());\n\t\t\texit(1);\n\t\t}\n\n\t\tif (vencrypt_selected != 0) {\n\t\t\tchar *tbuf;\n\t\t\ttbuf = (char *) malloc(strlen(cookie) + 100);\n\t\t\tsprintf(tbuf, \"%s,VENCRYPT=%d,%s\", uniq, vencrypt_selected, cookie);\n\t\t\twrite(vncsock, tbuf, strlen(cookie));\n\t\t\tgoto wrote_cookie;\n\t\t} else if (anontls_selected != 0) {\n\t\t\tchar *tbuf;\n\t\t\ttbuf = (char *) malloc(strlen(cookie) + 100);\n\t\t\tsprintf(tbuf, \"%s,ANONTLS=%d,%s\", uniq, anontls_selected, cookie);\n\t\t\twrite(vncsock, tbuf, strlen(cookie));\n\t\t\tgoto wrote_cookie;\n\t\t}\n\n\t\t/*\n\t\t * things get messy below since we are trying to do\n\t\t * *both* VNC and Java applet httpd through the same\n\t\t * SSL socket.\n\t\t */\n\n\t\tif (! screen) {\n\t\t\tclose(vncsock);\n\t\t\texit(1);\n\t\t}\n\t\tif (screen->httpListenSock >= 0 && screen->httpPort > 0) {\n\t\t\thave_httpd = 1;\n\t\t} else if (ipv6_http_fd >= 0) {\n\t\t\thave_httpd = 1;\n\t\t} else if (screen->httpListenSock == -2) {\n\t\t\thave_httpd = 1;\n\t\t}\n\t\tif (mode == OPENSSL_HTTPS && ! have_httpd) {\n\t\t\trfbLog(\"SSL: accept_openssl[%d]: no httpd socket for \"\n\t\t\t    \"-https mode\\n\", getpid());\n\t\t\tclose(vncsock);\n\t\t\trfbLog(\"SSL: ssl_helper[%d]: exit case 3 (no httpd sock)\\n\", getpid());\n\t\t\texit(1);\n\t\t}\n\n\t\tif (have_httpd) {\n\t\t\tint n = 0, is_http = 0;\n\t\t\tint hport = screen->httpPort; \n\t\t\tchar *iface = NULL;\n\t\t\tchar *buf, *tbuf;\n\n\t\t\tbuf  = (char *) calloc((ABSIZE+1), 1);\n\t\t\ttbuf = (char *) calloc((2*ABSIZE+1), 1);\n\n\t\t\tif (mode == OPENSSL_HTTPS) {\n\t\t\t\t/*\n\t\t\t\t * for this mode we know it is HTTP traffic\n\t\t\t\t * so we skip trying to guess.\n\t\t\t\t */\n\t\t\t\tis_http = 1;\n\t\t\t\tn = 0;\n\t\t\t\tgoto connect_to_httpd;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * Check if there is stuff to read from remote end\n\t\t\t * if so it is likely a GET or HEAD.\n\t\t\t */\n\t\t\tif (! is_ssl_readable(s_in, last_https, last_get,\n\t\t\t    mode)) {\n\t\t\t\tgoto write_cookie;\n\t\t\t}\n\t\n\t\t\t/* \n\t\t\t * read first 2 bytes to try to guess.  sadly,\n\t\t\t * the user is often pondering a \"non-verified\n\t\t\t * cert\" dialog for a long time before the GET\n\t\t\t * is ever sent.  So often we timeout here.\n\t\t\t */\n\n\t\t\tif (db) fprintf(stderr, \"watch_for_http_traffic\\n\");\n\n\t\t\tis_http = watch_for_http_traffic(buf, &n, s_in);\n\n\t\t\tif (is_http < 0 || is_http == 0) {\n\t\t\t\t/*\n\t\t\t\t * error or http not detected, fall back\n\t\t\t\t * to normal VNC socket.\n\t\t\t\t */\n\t\t\t\tif (db) fprintf(stderr, \"is_http err: %d n: %d\\n\", is_http, n);\n\t\t\t\twrite(vncsock, cookie, strlen(cookie));\n\t\t\t\tif (n > 0) {\n\t\t\t\t\twrite(vncsock, buf, n);\n\t\t\t\t}\n\t\t\t\tgoto wrote_cookie;\n\t\t\t}\n\n\t\t\tif (db) fprintf(stderr, \"is_http: %d n: %d\\n\",\n\t\t\t    is_http, n);\n\t\t\tif (db) fprintf(stderr, \"buf: '%s'\\n\", buf);\n\n\t\t\tif (strstr(buf, \"/request.https.vnc.connection\")) {\n\t\t\t\tchar reply[] = \"HTTP/1.0 200 OK\\r\\n\"\n\t\t\t\t    \"Content-Type: octet-stream\\r\\n\"\n\t\t\t\t    \"Connection: Keep-Alive\\r\\n\"\n\t\t\t\t    \"VNC-Server: x11vnc\\r\\n\"\n\t\t\t\t    \"Pragma: no-cache\\r\\n\\r\\n\";\n\t\t\t\t/*\n\t\t\t\t * special case proxy coming thru https\n\t\t\t\t * instead of a direct SSL connection.\n\t\t\t\t */\n\t\t\t\trfbLog(\"Handling VNC request via https GET. [%d]\\n\", getpid());\n\t\t\t\trfbLog(\"-- %s\\n\", buf);\n\n\t\t\t\tif (strstr(buf, \"/reverse.proxy\")) {\n\t\t\t\t\tchar *buf2;\n\t\t\t\t\tint n, ptr;\n#if !LIBVNCSERVER_HAVE_LIBSSL && !HAVE_LIBSSL \n\t\t\t\t\twrite(s_out, reply, strlen(reply));\n#else\n\t\t\t\t\tSSL_write(ssl, reply, strlen(reply));\n#endif\n\t\t\t\t\n\t\t\t\t\tbuf2  = (char *) calloc((8192+1), 1);\n\t\t\t\t\tn = 0;\n\t\t\t\t\tptr = 0;\n\t\t\t\t\twhile (ptr < 8192) {\n#if !LIBVNCSERVER_HAVE_LIBSSL && !HAVE_LIBSSL \n\t\t\t\t\t\tn = read(s_in, buf2 + ptr, 1);\n#else\n\t\t\t\t\t\tn = SSL_read(ssl, buf2 + ptr, 1);\n#endif\n\t\t\t\t\t\tif (n > 0) {\n\t\t\t\t\t\t\tptr += n;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (db) fprintf(stderr, \"buf2: '%s'\\n\", buf2);\n\n\t\t\t\t\t\tif (strstr(buf2, \"\\r\\n\\r\\n\")) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tfree(buf2);\n\t\t\t\t}\n\t\t\t\tgoto write_cookie;\n\n\t\t\t} else if (strstr(buf, \"/check.https.proxy.connection\")) {\n\t\t\t\tchar reply[] = \"HTTP/1.0 200 OK\\r\\n\"\n\t\t\t\t    \"Connection: close\\r\\n\"\n\t\t\t\t    \"Content-Type: octet-stream\\r\\n\"\n\t\t\t\t    \"VNC-Server: x11vnc\\r\\n\"\n\t\t\t\t    \"Pragma: no-cache\\r\\n\\r\\n\";\n\n\t\t\t\trfbLog(\"Handling Check HTTPS request via https GET. [%d]\\n\", getpid());\n\t\t\t\trfbLog(\"-- %s\\n\", buf);\n\n#if !LIBVNCSERVER_HAVE_LIBSSL && !HAVE_LIBSSL \n\t\t\t\twrite(s_out, reply, strlen(reply));\n#else\n\t\t\t\tSSL_write(ssl, reply, strlen(reply));\n\t\t\t\tSSL_shutdown(ssl);\n#endif\n\n\t\t\t\tstrcpy(tbuf, uniq);\n\t\t\t\tstrcat(tbuf, cookie);\n\t\t\t\twrite(vncsock, tbuf, strlen(tbuf));\n\t\t\t\tclose(vncsock);\n\n\t\t\t\trfbLog(\"SSL: ssl_helper[%d]: exit case 4 (check.https.proxy.connection)\\n\", getpid());\n\t\t\t\texit(0);\n\t\t\t}\n\t\t\tconnect_to_httpd:\n\n\t\t\t/*\n\t\t\t * Here we go... no turning back.  we have to\n\t\t\t * send failure to parent and close socket to have\n\t\t\t * http processed at all in a timely fashion...\n\t\t\t */\n\n\t\t\t/* send the failure tag: */\n\t\t\tstrcpy(tbuf, uniq);\n\n\t\t\tif (https_port_redir < 0 || (strstr(buf, \"PORT=\") || strstr(buf, \"port=\"))) {\n\t\t\t\tchar *q = strstr(buf, \"Host:\");\n\t\t\t\tint fport = 443, match = 0;\n\t\t\t\tchar num[16];\n\n\t\t\t\tif (q && strstr(q, \"\\n\")) {\n\t\t\t\t    q += strlen(\"Host:\") + 1;\n\t\t\t\t    while (*q != '\\n') {\n\t\t\t\t\tint p;\n\t\t\t\t\tif (*q == ':' && sscanf(q, \":%d\", &p) == 1) {\n\t\t\t\t\t\tif (p > 0 && p < 65536) {\n\t\t\t\t\t\t\tfport = p;\n\t\t\t\t\t\t\tmatch = 1;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tq++;\n\t\t\t\t    }\n\t\t\t\t}\n\t\t\t\tif (!match || !https_port_redir) {\n\t\t\t\t\tint p;\n\t\t\t\t\tif (sscanf(buf, \"PORT=%d,\", &p) == 1) {\n\t\t\t\t\t\tif (p > 0 && p < 65536) {\n\t\t\t\t\t\t\tfport = p;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else if (sscanf(buf, \"port=%d,\", &p) == 1) {\n\t\t\t\t\t\tif (p > 0 && p < 65536) {\n\t\t\t\t\t\t\tfport = p;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tsprintf(num, \"HP=%d,\", fport);\n\t\t\t\tstrcat(tbuf, num);\n\t\t\t}\n\n\t\t\tif (strstr(buf, \"HTTP/\") != NULL)  {\n\t\t\t\tchar *q, *str;\n\t\t\t\t/*\n\t\t\t\t * Also send back the GET line for heuristics.\n\t\t\t\t * (last_https, get file).\n\t\t\t\t */\n\t\t\t\tstr = strdup(buf);\n\t\t\t\tq = strstr(str, \"HTTP/\");\n\t\t\t\tif (q != NULL) {\n\t\t\t\t\t*q = '\\0';\t\n\t\t\t\t\tstrcat(tbuf, str);\n\t\t\t\t}\n\t\t\t\tfree(str);\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * Also send the cookie to pad out the number of\n\t\t\t * bytes to more than the parent wants to read.\n\t\t\t * Since this is the failure case, it does not\n\t\t\t * matter that we send more than strlen(cookie).\n\t\t\t */\n\t\t\tstrcat(tbuf, cookie);\n\t\t\twrite(vncsock, tbuf, strlen(tbuf));\n\n\t\t\tusleep(150*1000);\n\t\t\tif (db) fprintf(stderr, \"close vncsock: %d\\n\", vncsock);\n\t\t\tclose(vncsock);\n\n\t\t\t/* now, finally, connect to the libvncserver httpd: */\n\t\t\tif (screen->listenInterface == htonl(INADDR_ANY) ||\n\t\t\t    screen->listenInterface == htonl(INADDR_NONE)) {\n\t\t\t\tiface = \"127.0.0.1\";\n\t\t\t} else {\n\t\t\t\tstruct in_addr in;\n\t\t\t\tin.s_addr = screen->listenInterface;\n\t\t\t\tiface = inet_ntoa(in);\n\t\t\t}\n\t\t\tif (iface == NULL || !strcmp(iface, \"\")) {\n\t\t\t\tiface = \"127.0.0.1\";\n\t\t\t}\n\t\t\tif (db) fprintf(stderr, \"iface: %s:%d\\n\", iface, hport);\n\t\t\tusleep(150*1000);\n\n\t\t\thttpsock = connect_tcp(iface, hport);\n\n\t\t\tif (httpsock < 0) {\n\t\t\t\t/* UGH, after all of that! */\n\t\t\t\trfbLog(\"Could not connect to httpd socket!\\n\");\n\t\t\t\trfbLog(\"SSL: ssl_helper[%d]: exit case 5.\\n\", getpid());\n\t\t\t\texit(1);\n\t\t\t}\n\t\t\tif (db) fprintf(stderr, \"ssl_helper[%d]: httpsock: %d %d\\n\",\n\t\t\t    getpid(), httpsock, n);\n\n\t\t\t/*\n\t\t\t * send what we read to httpd, and then connect\n\t\t\t * the rest of the SSL session to it:\n\t\t\t */\n\t\t\tif (n > 0) {\n\t\t\t\tchar *s = getenv(\"X11VNC_EXTRA_HTTPS_PARAMS\");\n\t\t\t\tint did_extra = 0;\n\n\t\t\t\tif (db) fprintf(stderr, \"sending http buffer httpsock: %d n=%d\\n'%s'\\n\", httpsock, n, buf);\n\t\t\t\tif (s != NULL) {\n\t\t\t\t\tchar *q = strstr(buf, \" HTTP/\");\n\t\t\t\t\tif (q) {\n\t\t\t\t\t\tint m;\n\t\t\t\t\t\t*q = '\\0';\n\t\t\t\t\t\tm = strlen(buf);\n\t\t\t\t\t\twrite(httpsock, buf, m);\n\t\t\t\t\t\twrite(httpsock, s, strlen(s));\n\t\t\t\t\t\t*q = ' ';\n\t\t\t\t\t\twrite(httpsock, q, n-m);\n\t\t\t\t\t\tdid_extra = 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (!did_extra) {\n\t\t\t\t\twrite(httpsock, buf, n);\n\t\t\t\t}\n\t\t\t}\n\t\t\tssl_xfer(httpsock, s_in, s_out, is_http);\n\t\t\trfbLog(\"SSL: ssl_helper[%d]: exit case 6 (https ssl_xfer done)\\n\", getpid());\n\t\t\texit(0);\n\t\t}\n\n\t\t/*\n\t\t * ok, back from the above https mess, simply send the\n\t\t * cookie back to the parent (who will attach us to\n\t\t * libvncserver), and connect the rest of the SSL session\n\t\t * to it.\n\t\t */\n\t\twrite_cookie:\n\t\twrite(vncsock, cookie, strlen(cookie));\n\n\t\twrote_cookie:\n\t\tssl_xfer(vncsock, s_in, s_out, 0);\n\t\trfbLog(\"SSL: ssl_helper[%d]: exit case 7 (ssl_xfer done)\\n\", getpid());\n\t\tif (0) usleep(50 * 1000);\n\t\texit(0);\n\t}\n\t/* parent here */\n\n\tif (mode != OPENSSL_INETD) {\n\t\tclose(sock);\n\t}\n\tif (db) fprintf(stderr, \"helper process is: %d\\n\", pid);\n\n\t/* accept connection from our child.  */\n\tsignal(SIGALRM, csock_timeout);\n\tcsock_timeout_sock = csock;\n\talarm(20);\n\n\tvsock = accept(csock, (struct sockaddr *)&addr, &addrlen);\n\n\talarm(0);\n\tsignal(SIGALRM, SIG_DFL);\n\tclose(csock);\n\n\n\tif (vsock < 0) {\n\t\trfbLog(\"SSL: accept_openssl: connection from ssl_helper[%d] FAILED.\\n\", pid);\n\t\trfbLogPerror(\"accept\");\n\n\t\tkill(pid, SIGTERM);\n\t\twaitpid(pid, &status, WNOHANG); \n\t\tif (mode == OPENSSL_INETD || ssl_no_fail) {\n\t\t\tclean_up_exit(1);\n\t\t}\n\t\tif (certret_fd >= 0) {\n\t\t\tclose(certret_fd);\n\t\t\tcertret_fd = -1;\n\t\t}\n\t\tif (certret) {\n\t\t\tunlink(certret);\n\t\t}\n\t\tif (dhret_fd >= 0) {\n\t\t\tclose(dhret_fd);\n\t\t\tdhret_fd = -1;\n\t\t}\n\t\tif (dhret) {\n\t\t\tunlink(dhret);\n\t\t}\n\t\treturn;\n\t}\n\tif (db) fprintf(stderr, \"accept_openssl: vsock: %d\\n\", vsock);\n\n\tn = read(vsock, rcookie, strlen(cookie));\n\tif (n < 0 && errno != 0) {\n\t\trfbLogPerror(\"read\");\n\t}\n\n\tif (certret) {\n\t\tstruct stat sbuf;\n\t\tsbuf.st_size = 0;\n\t\tif (certret_fd >= 0 && stat(certret, &sbuf) == 0 && sbuf.st_size > 0) {\n\t\t\tcertret_str = (char *) calloc(sbuf.st_size+1, 1);\n\t\t\tread(certret_fd, certret_str, sbuf.st_size);\n\t\t\tclose(certret_fd);\n\t\t\tcertret_fd = -1;\n\t\t}\n\t\tif (certret_fd >= 0) {\n\t\t\tclose(certret_fd);\n\t\t\tcertret_fd = -1;\n\t\t}\n\t\tunlink(certret);\n\t\tif (certret_str && strstr(certret_str, \"NOCERT\") == certret_str) {\n\t\t\tfree(certret_str);\n\t\t\tcertret_str = NULL;\n\t\t}\n\t\tif (0 && certret_str) {\n\t\t\tfprintf(stderr, \"certret_str[%d]:\\n%s\\n\", (int) sbuf.st_size, certret_str);\n\t\t}\n\t}\n\n\tif (dhret) {\n\t\tstruct stat sbuf;\n\t\tsbuf.st_size = 0;\n\t\tif (dhret_fd >= 0 && stat(dhret, &sbuf) == 0 && sbuf.st_size > 0) {\n\t\t\tdhret_str = (char *) calloc(sbuf.st_size+1, 1);\n\t\t\tread(dhret_fd, dhret_str, sbuf.st_size);\n\t\t\tclose(dhret_fd);\n\t\t\tdhret_fd = -1;\n\t\t}\n\t\tif (dhret_fd >= 0) {\n\t\t\tclose(dhret_fd);\n\t\t\tdhret_fd = -1;\n\t\t}\n\t\tunlink(dhret);\n\t\tif (dhret_str && strstr(dhret_str, \"NOCERT\") == dhret_str) {\n\t\t\tfree(dhret_str);\n\t\t\tdhret_str = NULL;\n\t\t}\n\t\tif (dhret_str) {\n\t\t\tif (new_dh_params == NULL) {\n\t\t\t\tfprintf(stderr, \"dhret_str[%d]:\\n%s\\n\", (int) sbuf.st_size, dhret_str);\n\t\t\t\tnew_dh_params = strdup(dhret_str);\n\t\t\t}\n\t\t}\n\t}\n\n\tif (0) {\n\t\tfprintf(stderr, \"rcookie: %s\\n\", rcookie);\n\t\tfprintf(stderr, \"cookie:  %s\\n\", cookie);\n\t}\n\n\tif (strstr(rcookie, uniq) == rcookie) {\n\t\tchar *q = strstr(rcookie, \"RB=\");\n\t\tif (q && strstr(cookie, q) == cookie) {\n\t\t\tvencrypt_sel = 0;\n\t\t\tanontls_sel = 0;\n\t\t\tq = strstr(rcookie, \"VENCRYPT=\");\n\t\t\tif (q && sscanf(q, \"VENCRYPT=%d,\", &vencrypt_sel) == 1) {\n\t\t\t\tif (vencrypt_sel != 0) {\n\t\t\t\t\trfbLog(\"SSL: VENCRYPT mode=%d accepted. helper[%d]\\n\", vencrypt_sel, pid);\n\t\t\t\t\tgoto accept_client;\n\t\t\t\t}\n\t\t\t}\n\t\t\tq = strstr(rcookie, \"ANONTLS=\");\n\t\t\tif (q && sscanf(q, \"ANONTLS=%d,\", &anontls_sel) == 1) {\n\t\t\t\tif (anontls_sel != 0) {\n\t\t\t\t\trfbLog(\"SSL: ANONTLS mode=%d accepted. helper[%d]\\n\", anontls_sel, pid);\n\t\t\t\t\tgoto accept_client;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tif (n != (int) strlen(cookie) || strncmp(cookie, rcookie, n)) {\n\t\trfbLog(\"SSL: accept_openssl: cookie from ssl_helper[%d] FAILED. %d\\n\", pid, n);\n\t\tif (db) fprintf(stderr, \"'%s'\\n'%s'\\n\", cookie, rcookie);\n\t\tclose(vsock);\n\n\t\tif (strstr(rcookie, uniq) == rcookie) {\n\t\t\tint i;\n\t\t\tdouble https_download_wait_time = 15.0;\n\n\t\t\tif (getenv(\"X11VNC_HTTPS_DOWNLOAD_WAIT_TIME\")) {\n\t\t\t\thttps_download_wait_time = atof(getenv(\"X11VNC_HTTPS_DOWNLOAD_WAIT_TIME\"));\n\t\t\t}\n\n\t\t\trfbLog(\"SSL: BUT WAIT! HTTPS for helper process[%d] succeeded. Good.\\n\", pid);\n\t\t\tif (mode != OPENSSL_HTTPS) {\n\t\t\t\tlast_https = dnow();\n\t\t\t\tfor (i=0; i<256; i++) {\n\t\t\t\t\tlast_get[i] = '\\0';\n\t\t\t\t}\n\t\t\t\tstrncpy(last_get, rcookie, 100);\n\t\t\t\tif (db) fprintf(stderr, \"last_get: '%s'\\n\", last_get);\n\t\t\t}\n\t\t\tif (rcookie && strstr(rcookie, \"VncViewer.class\")) {\n\t\t\t\trfbLog(\"\\n\");\n\t\t\t\trfbLog(\"helper[%d]:\\n\", pid);\n\t\t\t\trfbLog(\"***********************************************************\\n\");\n\t\t\t\trfbLog(\"SSL: WARNING CLIENT ASKED FOR NONEXISTENT 'VncViewer.class'\\n\");\n\t\t\t\trfbLog(\"SSL: USER NEEDS TO MAKE SURE THE JAVA PLUGIN IS INSTALLED\\n\");\n\t\t\t\trfbLog(\"SSL: AND WORKING PROPERLY (e.g. a test-java-plugin page.)\\n\");\n\t\t\t\trfbLog(\"SSL: AND/OR USER NEEDS TO **RESTART** HIS WEB BROWSER.\\n\");\n\t\t\t\trfbLog(\"SSL: SOMETIMES THE BROWSER 'REMEMBERS' FAILED APPLET DOWN-\\n\");\n\t\t\t\trfbLog(\"SSL: LOADS AND RESTARTING IT IS THE ONLY WAY TO FIX THINGS.\\n\");\n\t\t\t\trfbLog(\"***********************************************************\\n\");\n\t\t\t\trfbLog(\"\\n\");\n\t\t\t}\n\t\t\tssl_helper_pid(pid, -2);\n\n\t\t\tif (https_port_redir) {\n\t\t\t\tdouble start;\n\t\t\t\tint origport = screen->port;\n\t\t\t\tint useport = screen->port;\n\t\t\t\tint saw_httpsock = 0;\n\t\t\t\t/* to expand $PORT correctly in index.vnc */\n\t\t\t\tif (https_port_redir < 0) {\n\t\t\t\t\tchar *q = strstr(rcookie, \"HP=\");\n\t\t\t\t\tif (q) {\n\t\t\t\t\t\tint p;\n\t\t\t\t\t\tif (sscanf(q, \"HP=%d,\", &p) == 1) {\n\t\t\t\t\t\t\tuseport = p;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tuseport = https_port_redir;\n\t\t\t\t}\n\t\t\t\tscreen->port = useport;\n\t\t\t\tif (origport != useport) {\n\t\t\t\t\trfbLog(\"SSL: -httpsredir guess port: %d  helper[%d]\\n\", screen->port, pid);\n\t\t\t\t}\n\n\t\t\t\tstart = dnow();\n\t\t\t\twhile (dnow() < start + https_download_wait_time) {\n\t\t\t\t\tif (screen->httpSock >= 0) saw_httpsock = 1;\n\t\t\t\t\trfbPE(10000);\n\t\t\t\t\tusleep(10000);\n\t\t\t\t\tif (screen->httpSock >= 0) saw_httpsock = 1;\n\t\t\t\t\twaitpid(pid, &status, WNOHANG); \n\t\t\t\t\tif (kill(pid, 0) != 0) {\n\t\t\t\t\t\trfbLog(\"SSL: helper[%d] pid finished\\n\", pid);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif (0 && saw_httpsock && screen->httpSock < 0) {\n\t\t\t\t\t\t/* this check can kill the helper too soon. */\n\t\t\t\t\t\trfbLog(\"SSL: httpSock for helper[%d] went away\\n\", pid);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\trfbLog(\"SSL: guessing child helper[%d] https finished. dt=%.6f\\n\",\n\t\t\t\t    pid, dnow() - start);\n\n\t\t\t\trfbPE(10000);\n\t\t\t\trfbPE(10000);\n\t\t\t\trfbPE(10000);\n\n\t\t\t\tscreen->port = origport;\n\t\t\t\tssl_helper_pid(0, -2);\n\t\t\t\tif (mode == OPENSSL_INETD) {\n\t\t\t\t\tclean_up_exit(1);\n\t\t\t\t}\n\t\t\t} else if (mode == OPENSSL_INETD) {\n\t\t\t\tdouble start;\n\t\t\t\tint saw_httpsock = 0;\n\n\t\t\t\t/* to expand $PORT correctly in index.vnc */\n\t\t\t\tif (screen->port == 0) {\n\t\t\t\t\tint fd = fileno(stdin);\n\t\t\t\t\tif (getenv(\"X11VNC_INETD_PORT\")) {\n\t\t\t\t\t\t/* mutex */\n\t\t\t\t\t\tscreen->port = atoi(getenv(\n\t\t\t\t\t\t    \"X11VNC_INETD_PORT\"));\n\t\t\t\t\t} else {\n\t\t\t\t\t\tint tport = get_local_port(fd);\n\t\t\t\t\t\tif (tport > 0) {\n\t\t\t\t\t\t\tscreen->port = tport;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\trfbLog(\"SSL: screen->port %d for helper[%d]\\n\", screen->port, pid);\n\n\t\t\t\t/* kludge for https fetch via inetd */\n\t\t\t\tstart = dnow();\n\t\t\t\twhile (dnow() < start + https_download_wait_time) {\n\t\t\t\t\tif (screen->httpSock >= 0) saw_httpsock = 1;\n\t\t\t\t\trfbPE(10000);\n\t\t\t\t\tusleep(10000);\n\t\t\t\t\tif (screen->httpSock >= 0) saw_httpsock = 1;\n\t\t\t\t\twaitpid(pid, &status, WNOHANG); \n\t\t\t\t\tif (kill(pid, 0) != 0) {\n\t\t\t\t\t\trfbLog(\"SSL: helper[%d] pid finished\\n\", pid);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif (0 && saw_httpsock && screen->httpSock < 0) {\n\t\t\t\t\t\t/* this check can kill the helper too soon. */\n\t\t\t\t\t\trfbLog(\"SSL: httpSock for helper[%d] went away\\n\", pid);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\trfbLog(\"SSL: OPENSSL_INETD guessing \"\n\t\t\t\t    \"child helper[%d] https finished. dt=%.6f\\n\",\n\t\t\t\t    pid, dnow() - start);\n\n\t\t\t\trfbPE(10000);\n\t\t\t\trfbPE(10000);\n\t\t\t\trfbPE(10000);\n\n\t\t\t\tssl_helper_pid(0, -2);\n\t\t\t\tclean_up_exit(1);\n\t\t\t}\n\t\t\t/* this will actually only get earlier https */\n\t\t\tssl_helper_pid(0, -2);\n\t\t\treturn;\n\t\t}\n\t\tkill(pid, SIGTERM);\n\t\twaitpid(pid, &status, WNOHANG); \n\t\tif (mode == OPENSSL_INETD || ssl_no_fail) {\n\t\t\tclean_up_exit(1);\n\t\t}\n\t\treturn;\n\t}\n\n\taccept_client:\n\n\tif (db) fprintf(stderr, \"accept_openssl: cookie good: %s\\n\", cookie);\n\n\trfbLog(\"SSL: handshake with helper process[%d] succeeded.\\n\", pid);\n\n\topenssl_last_helper_pid = pid;\n\tssl_helper_pid(pid, vsock);\n\n\tif (vnc_redirect) {\n\t\tvnc_redirect_sock = vsock;\n\t\topenssl_last_helper_pid = 0;\n\t\treturn;\n\t}\n\n\tclient = create_new_client(vsock, 0);\n\topenssl_last_helper_pid = 0;\n\n\tif (client) {\n\t\tint swt = 0;\n\t\tif (mode == OPENSSL_VNC6 && openssl_last_ip != NULL) {\n\t\t\tswt = 1;\n\t\t} else if (mode == OPENSSL_REVERSE && ipv6_name != NULL && openssl_last_ip != NULL) {\n\t\t\tswt = 1;\n\t\t}\n\t\tif (swt) {\n\t\t\tif (client->host) {\n\t\t\t\tfree(client->host);\n\t\t\t}\n\t\t\tclient->host = strdup(openssl_last_ip);\n\t\t}\n\t\tif (db) fprintf(stderr, \"accept_openssl: client %p\\n\", (void *) client);\n\t\tif (db) fprintf(stderr, \"accept_openssl: new_client %p\\n\", (void *) screen->newClientHook);\n\t\tif (db) fprintf(stderr, \"accept_openssl: new_client %p\\n\", (void *) new_client);\n\t\tif (mode == OPENSSL_INETD) {\n\t\t\tinetd_client = client;\n\t\t\tclient->clientGoneHook = client_gone;\n\t\t}\n\t\tif (openssl_last_ip &&\n\t\t    strpbrk(openssl_last_ip, \"0123456789\") == openssl_last_ip) {\n\t\t\tclient->host = strdup(openssl_last_ip);\n\t\t}\n\t\tif (vencrypt_sel != 0) {\n\t\t\tclient->protocolMajorVersion = 3;\n\t\t\tclient->protocolMinorVersion = 8;\n#if LIBVNCSERVER_HAVE_LIBSSL || HAVE_LIBSSL \n\t\t\tif (!finish_vencrypt_auth(client, vencrypt_sel)) {\n\t\t\t\trfbCloseClient(client);\n\t\t\t\tclient = NULL;\n\t\t\t}\n#else\n\t\t\tbadnews(\"3 accept_openssl\");\n#endif\n\t\t} else if (anontls_sel != 0) {\n\t\t\tclient->protocolMajorVersion = 3;\n\t\t\tclient->protocolMinorVersion = 8;\n\t\t\trfbAuthNewClient(client);\n\t\t}\n\t\tif (use_threads && client != NULL) {\n\t\t\trfbStartOnHoldClient(client);\n\t\t}\n\t\t/* try to get RFB proto done now. */\n\t\tprogress_client();\n\t} else {\n\t\trfbLog(\"SSL: accept_openssl: rfbNewClient failed.\\n\");\n\t\tclose(vsock);\n\n\t\tkill(pid, SIGTERM);\n\t\twaitpid(pid, &status, WNOHANG); \n\t\tif (mode == OPENSSL_INETD || ssl_no_fail) {\n\t\t\tclean_up_exit(1);\n\t\t}\n\t\treturn;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "rfbRunEventLoop",
          "args": [
            "screen",
            "-1",
            "TRUE"
          ],
          "line": 3103
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vnc_redirect_loop",
          "args": [
            "vnc_redirect_test",
            "&vnc_redirect_cnt"
          ],
          "line": 3098
        },
        "resolved": true,
        "details": {
          "function_name": "vnc_redirect_loop",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/user.c",
          "lines": "1695-1821",
          "snippet": "static void vnc_redirect_loop(char *vnc_redirect_test, int *vnc_redirect_cnt) {\n\tif (unixpw) {\n\t\trfbLog(\"wait_for_client: -unixpw and Xvnc.redirect not allowed\\n\");\n\t\tclean_up_exit(1);\n\t}\n\tif (client_connect) {\n\t\trfbLog(\"wait_for_client: -connect and Xvnc.redirect not allowed\\n\");\n\t\tclean_up_exit(1);\n\t}\n\tif (inetd) {\n\t\tif (use_openssl) {\n\t\t\taccept_openssl(OPENSSL_INETD, -1);\n\t\t}\n\t} else {\n\t\tpid_t pid = 0;\n\t\t/* XXX ipv6 */\n\t\tif (screen->httpListenSock >= 0) {\n#if LIBVNCSERVER_HAVE_FORK\n\t\t\tif ((pid = fork()) > 0) {\n\t\t\t\tclose(screen->httpListenSock);\n\t\t\t\t/* mutex */\n\t\t\t\tscreen->httpListenSock = -2;\n\t\t\t\tusleep(500 * 1000);\n\t\t\t} else {\n\t\t\t\tclose(screen->listenSock);\n\t\t\t\tscreen->listenSock = -1;\n\t\t\t\twhile (1) {\n\t\t\t\t\tusleep(10 * 1000);\n\t\t\t\t\trfbHttpCheckFds(screen);\n\t\t\t\t}\n\t\t\t\texit(1);\n\t\t\t}\n#else\n\t\t\tclean_up_exit(1);\n#endif\n\t\t}\n\t\tif (first_conn_timeout) {\n\t\t\tif (first_conn_timeout < 0) {\n\t\t\t\tfirst_conn_timeout = -first_conn_timeout;\n\t\t\t}\n\t\t\tsignal(SIGALRM, vnc_redirect_timeout);\n\t\t\talarm(first_conn_timeout);\n\t\t}\n\t\tif (use_openssl) {\n\t\t\tint i;\n\t\t\tif (pid == 0) {\n\t\t\t\taccept_openssl(OPENSSL_VNC, -1);\n\t\t\t} else {\n\t\t\t\tfor (i=0; i < 16; i++) {\n\t\t\t\t\taccept_openssl(OPENSSL_VNC, -1);\n\t\t\t\t\trfbLog(\"iter %d: vnc_redirect_sock: %d\\n\", i, vnc_redirect_sock);\n\t\t\t\t\tif (vnc_redirect_sock >= 0) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tstruct sockaddr_in addr;\n#ifdef __hpux\n\t\t\tint addrlen = sizeof(addr);\n#else\n\t\t\tsocklen_t addrlen = sizeof(addr);\n#endif\n\t\t\tif (screen->listenSock < 0) {\n\t\t\t\trfbLog(\"wait_for_client: Xvnc.redirect not listening... sock=%d port=%d\\n\", screen->listenSock, screen->port);\n\t\t\t\tclean_up_exit(1);\n\t\t\t}\n\t\t\tvnc_redirect_sock = accept(screen->listenSock, (struct sockaddr *)&addr, &addrlen);\n\t\t}\n\t\tif (first_conn_timeout) {\n\t\t\talarm(0);\n\t\t}\n\t\tif (pid > 0) {\n#if LIBVNCSERVER_HAVE_FORK\n\t\t\tint rc;\n\t\t\tpid_t pidw;\n\t\t\trfbLog(\"wait_for_client: kill TERM: %d\\n\", (int) pid);\n\t\t\tkill(pid, SIGTERM);\n\t\t\tusleep(1000 * 1000);\t/* 1.0 sec */\n\t\t\tpidw = waitpid(pid, &rc, WNOHANG);\n\t\t\tif (pidw <= 0) {\n\t\t\t\tusleep(1000 * 1000);\t/* 1.0 sec */\n\t\t\t\tpidw = waitpid(pid, &rc, WNOHANG);\n\t\t\t}\n#else\n\t\t\tclean_up_exit(1);\n#endif\n\t\t}\n\t}\n\tif (vnc_redirect_sock < 0) {\n\t\trfbLog(\"wait_for_client: vnc_redirect failed.\\n\");\n\t\tclean_up_exit(1);\n\t}\n\tif (!inetd && use_openssl) {\n\t\t/* check for Fetch Cert closing */\n\t\tfd_set rfds;\n\t\tstruct timeval tv;\n\t\tint nfds;\n\n\t\tusleep(300*1000);\n\n\t\tFD_ZERO(&rfds);\n\t\tFD_SET(vnc_redirect_sock, &rfds);\n\n\t\ttv.tv_sec = 0;\n\t\ttv.tv_usec = 200000;\n\t\tnfds = select(vnc_redirect_sock+1, &rfds, NULL, NULL, &tv);\n\n\t\trfbLog(\"wait_for_client: vnc_redirect nfds: %d\\n\", nfds);\n\t\tif (nfds > 0) {\n\t\t\tint n;\n\t\t\tn = read(vnc_redirect_sock, vnc_redirect_test, 1);\n\t\t\tif (n <= 0) {\n\t\t\t\tclose(vnc_redirect_sock);\n\t\t\t\tvnc_redirect_sock = -1;\n\t\t\t\trfbLog(\"wait_for_client: waiting for 2nd connection (Fetch Cert?)\\n\");\n\t\t\t\taccept_openssl(OPENSSL_VNC, -1);\n\t\t\t\tif (vnc_redirect_sock < 0) {\n\t\t\t\t\trfbLog(\"wait_for_client: vnc_redirect failed.\\n\");\n\t\t\t\t\tclean_up_exit(1);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t*vnc_redirect_cnt = n;\n\t\t\t}\n\t\t}\n\t}\n}",
          "includes": [
            "#include \"avahi.h\"",
            "#include \"sslhelper.h\"",
            "#include \"remote.h\"",
            "#include \"cursor.h\"",
            "#include \"keyboard.h\"",
            "#include \"inet.h\"",
            "#include \"connections.h\"",
            "#include \"xwrappers.h\"",
            "#include \"sslhelper.h\"",
            "#include \"unixpw.h\"",
            "#include \"screen.h\"",
            "#include \"scan.h\"",
            "#include \"cleanup.h\"",
            "#include \"solid.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"avahi.h\"\n#include \"sslhelper.h\"\n#include \"remote.h\"\n#include \"cursor.h\"\n#include \"keyboard.h\"\n#include \"inet.h\"\n#include \"connections.h\"\n#include \"xwrappers.h\"\n#include \"sslhelper.h\"\n#include \"unixpw.h\"\n#include \"screen.h\"\n#include \"scan.h\"\n#include \"cleanup.h\"\n#include \"solid.h\"\n#include \"x11vnc.h\"\n\nstatic void vnc_redirect_loop(char *vnc_redirect_test, int *vnc_redirect_cnt) {\n\tif (unixpw) {\n\t\trfbLog(\"wait_for_client: -unixpw and Xvnc.redirect not allowed\\n\");\n\t\tclean_up_exit(1);\n\t}\n\tif (client_connect) {\n\t\trfbLog(\"wait_for_client: -connect and Xvnc.redirect not allowed\\n\");\n\t\tclean_up_exit(1);\n\t}\n\tif (inetd) {\n\t\tif (use_openssl) {\n\t\t\taccept_openssl(OPENSSL_INETD, -1);\n\t\t}\n\t} else {\n\t\tpid_t pid = 0;\n\t\t/* XXX ipv6 */\n\t\tif (screen->httpListenSock >= 0) {\n#if LIBVNCSERVER_HAVE_FORK\n\t\t\tif ((pid = fork()) > 0) {\n\t\t\t\tclose(screen->httpListenSock);\n\t\t\t\t/* mutex */\n\t\t\t\tscreen->httpListenSock = -2;\n\t\t\t\tusleep(500 * 1000);\n\t\t\t} else {\n\t\t\t\tclose(screen->listenSock);\n\t\t\t\tscreen->listenSock = -1;\n\t\t\t\twhile (1) {\n\t\t\t\t\tusleep(10 * 1000);\n\t\t\t\t\trfbHttpCheckFds(screen);\n\t\t\t\t}\n\t\t\t\texit(1);\n\t\t\t}\n#else\n\t\t\tclean_up_exit(1);\n#endif\n\t\t}\n\t\tif (first_conn_timeout) {\n\t\t\tif (first_conn_timeout < 0) {\n\t\t\t\tfirst_conn_timeout = -first_conn_timeout;\n\t\t\t}\n\t\t\tsignal(SIGALRM, vnc_redirect_timeout);\n\t\t\talarm(first_conn_timeout);\n\t\t}\n\t\tif (use_openssl) {\n\t\t\tint i;\n\t\t\tif (pid == 0) {\n\t\t\t\taccept_openssl(OPENSSL_VNC, -1);\n\t\t\t} else {\n\t\t\t\tfor (i=0; i < 16; i++) {\n\t\t\t\t\taccept_openssl(OPENSSL_VNC, -1);\n\t\t\t\t\trfbLog(\"iter %d: vnc_redirect_sock: %d\\n\", i, vnc_redirect_sock);\n\t\t\t\t\tif (vnc_redirect_sock >= 0) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tstruct sockaddr_in addr;\n#ifdef __hpux\n\t\t\tint addrlen = sizeof(addr);\n#else\n\t\t\tsocklen_t addrlen = sizeof(addr);\n#endif\n\t\t\tif (screen->listenSock < 0) {\n\t\t\t\trfbLog(\"wait_for_client: Xvnc.redirect not listening... sock=%d port=%d\\n\", screen->listenSock, screen->port);\n\t\t\t\tclean_up_exit(1);\n\t\t\t}\n\t\t\tvnc_redirect_sock = accept(screen->listenSock, (struct sockaddr *)&addr, &addrlen);\n\t\t}\n\t\tif (first_conn_timeout) {\n\t\t\talarm(0);\n\t\t}\n\t\tif (pid > 0) {\n#if LIBVNCSERVER_HAVE_FORK\n\t\t\tint rc;\n\t\t\tpid_t pidw;\n\t\t\trfbLog(\"wait_for_client: kill TERM: %d\\n\", (int) pid);\n\t\t\tkill(pid, SIGTERM);\n\t\t\tusleep(1000 * 1000);\t/* 1.0 sec */\n\t\t\tpidw = waitpid(pid, &rc, WNOHANG);\n\t\t\tif (pidw <= 0) {\n\t\t\t\tusleep(1000 * 1000);\t/* 1.0 sec */\n\t\t\t\tpidw = waitpid(pid, &rc, WNOHANG);\n\t\t\t}\n#else\n\t\t\tclean_up_exit(1);\n#endif\n\t\t}\n\t}\n\tif (vnc_redirect_sock < 0) {\n\t\trfbLog(\"wait_for_client: vnc_redirect failed.\\n\");\n\t\tclean_up_exit(1);\n\t}\n\tif (!inetd && use_openssl) {\n\t\t/* check for Fetch Cert closing */\n\t\tfd_set rfds;\n\t\tstruct timeval tv;\n\t\tint nfds;\n\n\t\tusleep(300*1000);\n\n\t\tFD_ZERO(&rfds);\n\t\tFD_SET(vnc_redirect_sock, &rfds);\n\n\t\ttv.tv_sec = 0;\n\t\ttv.tv_usec = 200000;\n\t\tnfds = select(vnc_redirect_sock+1, &rfds, NULL, NULL, &tv);\n\n\t\trfbLog(\"wait_for_client: vnc_redirect nfds: %d\\n\", nfds);\n\t\tif (nfds > 0) {\n\t\t\tint n;\n\t\t\tn = read(vnc_redirect_sock, vnc_redirect_test, 1);\n\t\t\tif (n <= 0) {\n\t\t\t\tclose(vnc_redirect_sock);\n\t\t\t\tvnc_redirect_sock = -1;\n\t\t\t\trfbLog(\"wait_for_client: waiting for 2nd connection (Fetch Cert?)\\n\");\n\t\t\t\taccept_openssl(OPENSSL_VNC, -1);\n\t\t\t\tif (vnc_redirect_sock < 0) {\n\t\t\t\t\trfbLog(\"wait_for_client: vnc_redirect failed.\\n\");\n\t\t\t\t\tclean_up_exit(1);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t*vnc_redirect_cnt = n;\n\t\t\t}\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "check_waitbg",
          "args": [],
          "line": 3095
        },
        "resolved": true,
        "details": {
          "function_name": "check_waitbg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/user.c",
          "lines": "1486-1518",
          "snippet": "static void check_waitbg(void) {\n\tif (getenv(\"WAITBG\")) {\n#if LIBVNCSERVER_HAVE_FORK && HAVE_SETSID\n\t\tint p, n;\n\t\tif ((p = fork()) > 0)  {\n\t\t\texit(0);\n\t\t} else if (p == -1) {\n\t\t\trfbLogEnable(1);\n\t\t\tfprintf(stderr, \"could not fork\\n\");\n\t\t\tperror(\"fork\");\n\t\t\tclean_up_exit(1);\n\t\t}\n\t\tif (setsid() == -1) {\n\t\t\trfbLogEnable(1);\n\t\t\tfprintf(stderr, \"setsid failed\\n\");\n\t\t\tperror(\"setsid\");\n\t\t\tclean_up_exit(1);\n\t\t}\n\t\t/* adjust our stdio */\n\t\tn = open(\"/dev/null\", O_RDONLY);\n\t\tdup2(n, 0);\n\t\tdup2(n, 1);\n\t\tif (! logfile) {\n\t\t\tdup2(n, 2);\n\t\t}\n\t\tif (n > 2) {\n\t\t\tclose(n);\n\t\t}\n#else\n\t\tclean_up_exit(1);\n#endif\n\t}\n}",
          "includes": [
            "#include \"avahi.h\"",
            "#include \"sslhelper.h\"",
            "#include \"remote.h\"",
            "#include \"cursor.h\"",
            "#include \"keyboard.h\"",
            "#include \"inet.h\"",
            "#include \"connections.h\"",
            "#include \"xwrappers.h\"",
            "#include \"sslhelper.h\"",
            "#include \"unixpw.h\"",
            "#include \"screen.h\"",
            "#include \"scan.h\"",
            "#include \"cleanup.h\"",
            "#include \"solid.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"avahi.h\"\n#include \"sslhelper.h\"\n#include \"remote.h\"\n#include \"cursor.h\"\n#include \"keyboard.h\"\n#include \"inet.h\"\n#include \"connections.h\"\n#include \"xwrappers.h\"\n#include \"sslhelper.h\"\n#include \"unixpw.h\"\n#include \"screen.h\"\n#include \"scan.h\"\n#include \"cleanup.h\"\n#include \"solid.h\"\n#include \"x11vnc.h\"\n\nstatic void check_waitbg(void) {\n\tif (getenv(\"WAITBG\")) {\n#if LIBVNCSERVER_HAVE_FORK && HAVE_SETSID\n\t\tint p, n;\n\t\tif ((p = fork()) > 0)  {\n\t\t\texit(0);\n\t\t} else if (p == -1) {\n\t\t\trfbLogEnable(1);\n\t\t\tfprintf(stderr, \"could not fork\\n\");\n\t\t\tperror(\"fork\");\n\t\t\tclean_up_exit(1);\n\t\t}\n\t\tif (setsid() == -1) {\n\t\t\trfbLogEnable(1);\n\t\t\tfprintf(stderr, \"setsid failed\\n\");\n\t\t\tperror(\"setsid\");\n\t\t\tclean_up_exit(1);\n\t\t}\n\t\t/* adjust our stdio */\n\t\tn = open(\"/dev/null\", O_RDONLY);\n\t\tdup2(n, 0);\n\t\tdup2(n, 1);\n\t\tif (! logfile) {\n\t\t\tdup2(n, 2);\n\t\t}\n\t\tif (n > 2) {\n\t\t\tclose(n);\n\t\t}\n#else\n\t\tclean_up_exit(1);\n#endif\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "setup_service",
          "args": [],
          "line": 3093
        },
        "resolved": true,
        "details": {
          "function_name": "setup_service",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/user.c",
          "lines": "1455-1484",
          "snippet": "static void setup_service(void) {\n\tif (remote_direct) {\n\t\treturn;\n\t}\n\tif (!inetd) {\n\t\tdo_mention_java_urls();\n\t\tdo_announce_http();\n\t\tif (!use_openssl) {\n\t\t\tannounce(screen->port, use_openssl, NULL);\n\t\t\tfprintf(stdout, \"PORT=%d\\n\", screen->port);\n\t\t} else {\n\t\t\tfprintf(stdout, \"PORT=%d\\n\", screen->port);\n\t\t\tif (stunnel_port) {\n\t\t\t\tfprintf(stdout, \"SSLPORT=%d\\n\", stunnel_port);\n\t\t\t} else if (use_openssl) {\n\t\t\t\tfprintf(stdout, \"SSLPORT=%d\\n\", screen->port);\n\t\t\t}\n\t\t}\n\t\tfflush(stdout);\n\t} else if (!use_openssl && avahi) {\n\t\tchar *name = rfb_desktop_name;\n\t\tchar *host = this_host();\n\t\tif (!name) {\n\t\t\tname = use_dpy;\n\t\t}\n\t\tavahi_initialise();\n\t\tavahi_advertise(name, host, screen->port);\n\t\tfree(host);\n\t}\n}",
          "includes": [
            "#include \"avahi.h\"",
            "#include \"sslhelper.h\"",
            "#include \"remote.h\"",
            "#include \"cursor.h\"",
            "#include \"keyboard.h\"",
            "#include \"inet.h\"",
            "#include \"connections.h\"",
            "#include \"xwrappers.h\"",
            "#include \"sslhelper.h\"",
            "#include \"unixpw.h\"",
            "#include \"screen.h\"",
            "#include \"scan.h\"",
            "#include \"cleanup.h\"",
            "#include \"solid.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void do_announce_http(void);",
            "void do_mention_java_urls(void);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"avahi.h\"\n#include \"sslhelper.h\"\n#include \"remote.h\"\n#include \"cursor.h\"\n#include \"keyboard.h\"\n#include \"inet.h\"\n#include \"connections.h\"\n#include \"xwrappers.h\"\n#include \"sslhelper.h\"\n#include \"unixpw.h\"\n#include \"screen.h\"\n#include \"scan.h\"\n#include \"cleanup.h\"\n#include \"solid.h\"\n#include \"x11vnc.h\"\n\nvoid do_announce_http(void);\nvoid do_mention_java_urls(void);\n\nstatic void setup_service(void) {\n\tif (remote_direct) {\n\t\treturn;\n\t}\n\tif (!inetd) {\n\t\tdo_mention_java_urls();\n\t\tdo_announce_http();\n\t\tif (!use_openssl) {\n\t\t\tannounce(screen->port, use_openssl, NULL);\n\t\t\tfprintf(stdout, \"PORT=%d\\n\", screen->port);\n\t\t} else {\n\t\t\tfprintf(stdout, \"PORT=%d\\n\", screen->port);\n\t\t\tif (stunnel_port) {\n\t\t\t\tfprintf(stdout, \"SSLPORT=%d\\n\", stunnel_port);\n\t\t\t} else if (use_openssl) {\n\t\t\t\tfprintf(stdout, \"SSLPORT=%d\\n\", screen->port);\n\t\t\t}\n\t\t}\n\t\tfflush(stdout);\n\t} else if (!use_openssl && avahi) {\n\t\tchar *name = rfb_desktop_name;\n\t\tchar *host = this_host();\n\t\tif (!name) {\n\t\t\tname = use_dpy;\n\t\t}\n\t\tavahi_initialise();\n\t\tavahi_advertise(name, host, screen->port);\n\t\tfree(host);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "http_connections",
          "args": [
            "1"
          ],
          "line": 3086
        },
        "resolved": true,
        "details": {
          "function_name": "http_connections",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/remote.c",
          "lines": "496-564",
          "snippet": "void http_connections(int on) {\n\tif (!screen) {\n\t\treturn;\n\t}\n\tif (on) {\n\t\trfbLog(\"http_connections: turning on http service.\\n\");\n\n\t\tif (inetd && use_openssl) {\n\t\t\t/*\n\t\t\t * try to work around rapid fire https requests\n\t\t\t * in inetd mode... ugh.\n\t\t\t */\n\t\t\tif (screen->httpPort == 0) {\n\t\t\t\tint port = find_free_port(5800, 5850);\n\t\t\t\tif (port) {\n\t\t\t\t\t/* mutex */\n\t\t\t\t\tscreen->httpPort = port;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tscreen->httpInitDone = FALSE;\n\t\tif (check_httpdir()) {\n\t\t\tint fd6 = -1;\n\t\t\tchar *save = listen_str6;\n\n\t\t\tscreen->httpDir = http_dir;\n\n\t\t\trfb_http_init_sockets();\n\n\t\t\tif (getenv(\"X11VNC_HTTP_LISTEN_LOCALHOST\")) {\n\t\t\t\tlisten_str6 = \"localhost\";\n\t\t\t}\n\n\t\t\tif (screen->httpPort != 0 && screen->httpListenSock < 0) {\n\t\t\t\trfbLog(\"http_connections: failed to listen on http port: %d\\n\", screen->httpPort);\n\t\t\t\tif (ipv6_listen) {\n\t\t\t\t\tfd6 = listen6(screen->httpPort);\n\t\t\t\t}\n\t\t\t\tif (fd6 < 0) {\n\t\t\t\t\tclean_up_exit(1);\n\t\t\t\t}\n\t\t\t\trfbLog(\"http_connections: trying IPv6 only mode.\\n\");\n\t\t\t}\n\t\t\tif (ipv6_listen && screen->httpPort > 0) {\n\t\t\t\tif (fd6 < 0) {\n\t\t\t\t\tfd6 = listen6(screen->httpPort);\n\t\t\t\t}\n\t\t\t\tipv6_http_fd = fd6;\n\t\t\t\tif (ipv6_http_fd >= 0) {\n\t\t\t\t\trfbLog(\"http_connections: Listening %s on IPv6 port %d (socket %d)\\n\",\n\t\t\t\t\t    screen->httpListenSock < 0 ? \"only\" : \"also\",\n\t\t\t\t\t    screen->httpPort, ipv6_http_fd);\n\t\t\t\t}\n\t\t\t}\n\t\t\tlisten_str6 = save;\n\t\t}\n\t} else {\n\t\trfbLog(\"http_connections: turning off http service.\\n\");\n\t\tif (screen->httpListenSock > -1) {\n\t\t\tclose(screen->httpListenSock);\n\t\t\tscreen->httpListenSock = -1;\n\t\t}\n\t\tscreen->httpDir = NULL;\n\t\tif (ipv6_http_fd >= 0) {\n\t\t\tclose(ipv6_http_fd);\n\t\t\tipv6_http_fd = -1;\n\t\t}\n\t}\n}",
          "includes": [
            "#include \"sslhelper.h\"",
            "#include \"avahi.h\"",
            "#include \"userinput.h\"",
            "#include \"uinput.h\"",
            "#include \"unixpw.h\"",
            "#include \"selection.h\"",
            "#include \"keyboard.h\"",
            "#include \"userinput.h\"",
            "#include \"cursor.h\"",
            "#include \"pointer.h\"",
            "#include \"connections.h\"",
            "#include \"scan.h\"",
            "#include \"rates.h\"",
            "#include \"user.h\"",
            "#include \"solid.h\"",
            "#include \"gui.h\"",
            "#include \"cleanup.h\"",
            "#include \"screen.h\"",
            "#include \"win_utils.h\"",
            "#include \"xkb_bell.h\"",
            "#include \"xrecord.h\"",
            "#include \"xdamage.h\"",
            "#include \"xrandr.h\"",
            "#include \"xinerama.h\"",
            "#include \"xevents.h\"",
            "#include \"xwrappers.h\"",
            "#include \"inet.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int check_httpdir(void);",
            "void http_connections(int on);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sslhelper.h\"\n#include \"avahi.h\"\n#include \"userinput.h\"\n#include \"uinput.h\"\n#include \"unixpw.h\"\n#include \"selection.h\"\n#include \"keyboard.h\"\n#include \"userinput.h\"\n#include \"cursor.h\"\n#include \"pointer.h\"\n#include \"connections.h\"\n#include \"scan.h\"\n#include \"rates.h\"\n#include \"user.h\"\n#include \"solid.h\"\n#include \"gui.h\"\n#include \"cleanup.h\"\n#include \"screen.h\"\n#include \"win_utils.h\"\n#include \"xkb_bell.h\"\n#include \"xrecord.h\"\n#include \"xdamage.h\"\n#include \"xrandr.h\"\n#include \"xinerama.h\"\n#include \"xevents.h\"\n#include \"xwrappers.h\"\n#include \"inet.h\"\n#include \"x11vnc.h\"\n\nint check_httpdir(void);\nvoid http_connections(int on);\n\nvoid http_connections(int on) {\n\tif (!screen) {\n\t\treturn;\n\t}\n\tif (on) {\n\t\trfbLog(\"http_connections: turning on http service.\\n\");\n\n\t\tif (inetd && use_openssl) {\n\t\t\t/*\n\t\t\t * try to work around rapid fire https requests\n\t\t\t * in inetd mode... ugh.\n\t\t\t */\n\t\t\tif (screen->httpPort == 0) {\n\t\t\t\tint port = find_free_port(5800, 5850);\n\t\t\t\tif (port) {\n\t\t\t\t\t/* mutex */\n\t\t\t\t\tscreen->httpPort = port;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tscreen->httpInitDone = FALSE;\n\t\tif (check_httpdir()) {\n\t\t\tint fd6 = -1;\n\t\t\tchar *save = listen_str6;\n\n\t\t\tscreen->httpDir = http_dir;\n\n\t\t\trfb_http_init_sockets();\n\n\t\t\tif (getenv(\"X11VNC_HTTP_LISTEN_LOCALHOST\")) {\n\t\t\t\tlisten_str6 = \"localhost\";\n\t\t\t}\n\n\t\t\tif (screen->httpPort != 0 && screen->httpListenSock < 0) {\n\t\t\t\trfbLog(\"http_connections: failed to listen on http port: %d\\n\", screen->httpPort);\n\t\t\t\tif (ipv6_listen) {\n\t\t\t\t\tfd6 = listen6(screen->httpPort);\n\t\t\t\t}\n\t\t\t\tif (fd6 < 0) {\n\t\t\t\t\tclean_up_exit(1);\n\t\t\t\t}\n\t\t\t\trfbLog(\"http_connections: trying IPv6 only mode.\\n\");\n\t\t\t}\n\t\t\tif (ipv6_listen && screen->httpPort > 0) {\n\t\t\t\tif (fd6 < 0) {\n\t\t\t\t\tfd6 = listen6(screen->httpPort);\n\t\t\t\t}\n\t\t\t\tipv6_http_fd = fd6;\n\t\t\t\tif (ipv6_http_fd >= 0) {\n\t\t\t\t\trfbLog(\"http_connections: Listening %s on IPv6 port %d (socket %d)\\n\",\n\t\t\t\t\t    screen->httpListenSock < 0 ? \"only\" : \"also\",\n\t\t\t\t\t    screen->httpPort, ipv6_http_fd);\n\t\t\t\t}\n\t\t\t}\n\t\t\tlisten_str6 = save;\n\t\t}\n\t} else {\n\t\trfbLog(\"http_connections: turning off http service.\\n\");\n\t\tif (screen->httpListenSock > -1) {\n\t\t\tclose(screen->httpListenSock);\n\t\t\tscreen->httpListenSock = -1;\n\t\t}\n\t\tscreen->httpDir = NULL;\n\t\tif (ipv6_http_fd >= 0) {\n\t\t\tclose(ipv6_http_fd);\n\t\t\tipv6_http_fd = -1;\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "check_httpdir",
          "args": [],
          "line": 3085
        },
        "resolved": true,
        "details": {
          "function_name": "check_httpdir",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/remote.c",
          "lines": "349-471",
          "snippet": "int check_httpdir(void) {\n\tif (http_dir && http_dir[0] != '\\0') {\n\t\treturn 1;\n\t} else {\n\t\tchar *prog = NULL, *httpdir, *q;\n\t\tstruct stat sbuf;\n\t\tint len;\n\n\t\trfbLog(\"check_httpdir: trying to guess httpdir... %s\\n\", program_name);\n\t\tif (program_name[0] == '/') {\n\t\t\tprog = strdup(program_name);\n\t\t} else {\n\t\t\tchar cwd[1024];\n\t\t\tgetcwd(cwd, 1024);\n\t\t\tlen = strlen(cwd) + 1 + strlen(program_name) + 1;\n\t\t\tprog = (char *) malloc(len);\n\t\t\tsnprintf(prog, len, \"%s/%s\", cwd, program_name);\n\t\t\tif (stat(prog, &sbuf) != 0) {\n\t\t\t\tchar *path = strdup(getenv(\"PATH\"));\n\t\t\t\tchar *p, *base;\n\t\t\t\tbase = strrchr(program_name, '/');\n\t\t\t\tif (base) {\n\t\t\t\t\tbase++;\n\t\t\t\t} else {\n\t\t\t\t\tbase = program_name;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tp = strtok(path, \":\");\n\t\t\t\twhile(p) {\n\t\t\t\t\tif (prog) {\n\t\t\t\t\t\tfree(prog);\n\t\t\t\t\t\tprog = NULL;\n\t\t\t\t\t}\n\t\t\t\t\tlen = strlen(p) + 1 + strlen(base) + 1;\n\t\t\t\t\tprog = (char *) malloc(len);\n\t\t\t\t\tsnprintf(prog, len, \"%s/%s\", p, base);\n\t\t\t\t\tif (stat(prog, &sbuf) == 0) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tp = strtok(NULL, \":\");\n\t\t\t\t}\n\t\t\t\tfree(path);\n\t\t\t}\n\t\t}\n\t\t/*\n\t\t * /path/to/bin/x11vnc\n\t\t * /path/to/bin/../share/x11vnc/classes\n\t\t *                    12345678901234567\n\t\t * /path/to/bin/../share/x11vnc/classes/ssl\n\t\t *                    123456789012345678901\n\t\t *                                        21\n\t\t */\n\t\tif ((q = strrchr(prog, '/')) == NULL) {\n\t\t\trfbLog(\"check_httpdir: bad program path: %s\\n\", prog);\n\t\t\tfree(prog);\n\t\t\trfbLog(\"check_httpdir: *HTTP disabled*  Use -httpdir path\\n\");\n\t\t\treturn 0;\n\t\t}\n\n\t\tlen = strlen(prog) + 21 + 1;\n\t\t*q = '\\0';\n\t\thttpdir = (char *) malloc(len);\n\t\tif (use_stunnel && http_ssl) {\n\t\t\tsnprintf(httpdir, len, \"%s/../share/x11vnc/classes/ssl\", prog);\n\t\t} else if (!enc_str && (use_openssl || use_stunnel || http_ssl)) {\n\t\t\tsnprintf(httpdir, len, \"%s/../share/x11vnc/classes/ssl\", prog);\n\t\t} else {\n\t\t\tsnprintf(httpdir, len, \"%s/../share/x11vnc/classes\", prog);\n\t\t}\n\t\tif (stat(httpdir, &sbuf) != 0) {\n\t\t\tif (use_stunnel && http_ssl) {\n\t\t\t\tsnprintf(httpdir, len, \"%s/../classes/ssl\", prog);\n\t\t\t} else if (!enc_str && (use_openssl || use_stunnel || http_ssl)) {\n\t\t\t\tsnprintf(httpdir, len, \"%s/../classes/ssl\", prog);\n\t\t\t} else {\n\t\t\t\tsnprintf(httpdir, len, \"%s/../classes\", prog);\n\t\t\t}\n\t\t}\n\t\tfree(prog);\n\n\t\tif (stat(httpdir, &sbuf) == 0) {\n\t\t\t/* good enough for me */\n\t\t\trfbLog(\"check_httpdir: guessed directory:\\n\");\n\t\t\trfbLog(\"   %s\\n\", httpdir);\n\t\t\thttp_dir = httpdir;\n\t\t\treturn 1;\n\t\t} else {\n\t\t\t/* try some hardwires: */\n\t\t\tint i;\n\t\t\tchar **use;\n\t\t\tchar *list[] = {\n\t\t\t\t\"/usr/local/share/x11vnc/classes\",\n\t\t\t\t\"/usr/share/x11vnc/classes\",\n\t\t\t\tNULL\n\t\t\t};\n\t\t\tchar *ssllist[] = {\n\t\t\t\t\"/usr/local/share/x11vnc/classes/ssl\",\n\t\t\t\t\"/usr/share/x11vnc/classes/ssl\",\n\t\t\t\tNULL\n\t\t\t};\n\t\t\tif (use_stunnel && http_ssl) {\n\t\t\t\tuse = ssllist;\n\t\t\t} else if (!enc_str && (use_openssl || use_stunnel || http_ssl)) {\n\t\t\t\tuse = ssllist;\n\t\t\t} else {\n\t\t\t\tuse = list;\n\t\t\t}\n\t\t\ti = 0;\n\t\t\twhile (use[i] != NULL) {\n\t\t\t\tif (stat(use[i], &sbuf) == 0) {\n\t\t\t\t\thttp_dir = strdup(use[i]);\t\n\t\t\t\t\treturn 1;\n\t\t\t\t}\n\t\t\t\ti++;\n\t\t\t}\n\n\t\t\trfbLog(\"check_httpdir: bad guess:\\n\");\n\t\t\trfbLog(\"   %s\\n\", httpdir);\n\t\t\trfbLog(\"check_httpdir: *HTTP disabled*  Use -httpdir path\\n\");\n\t\t\treturn 0;\n\t\t}\n\t}\n}",
          "includes": [
            "#include \"sslhelper.h\"",
            "#include \"avahi.h\"",
            "#include \"userinput.h\"",
            "#include \"uinput.h\"",
            "#include \"unixpw.h\"",
            "#include \"selection.h\"",
            "#include \"keyboard.h\"",
            "#include \"userinput.h\"",
            "#include \"cursor.h\"",
            "#include \"pointer.h\"",
            "#include \"connections.h\"",
            "#include \"scan.h\"",
            "#include \"rates.h\"",
            "#include \"user.h\"",
            "#include \"solid.h\"",
            "#include \"gui.h\"",
            "#include \"cleanup.h\"",
            "#include \"screen.h\"",
            "#include \"win_utils.h\"",
            "#include \"xkb_bell.h\"",
            "#include \"xrecord.h\"",
            "#include \"xdamage.h\"",
            "#include \"xrandr.h\"",
            "#include \"xinerama.h\"",
            "#include \"xevents.h\"",
            "#include \"xwrappers.h\"",
            "#include \"inet.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int check_httpdir(void);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sslhelper.h\"\n#include \"avahi.h\"\n#include \"userinput.h\"\n#include \"uinput.h\"\n#include \"unixpw.h\"\n#include \"selection.h\"\n#include \"keyboard.h\"\n#include \"userinput.h\"\n#include \"cursor.h\"\n#include \"pointer.h\"\n#include \"connections.h\"\n#include \"scan.h\"\n#include \"rates.h\"\n#include \"user.h\"\n#include \"solid.h\"\n#include \"gui.h\"\n#include \"cleanup.h\"\n#include \"screen.h\"\n#include \"win_utils.h\"\n#include \"xkb_bell.h\"\n#include \"xrecord.h\"\n#include \"xdamage.h\"\n#include \"xrandr.h\"\n#include \"xinerama.h\"\n#include \"xevents.h\"\n#include \"xwrappers.h\"\n#include \"inet.h\"\n#include \"x11vnc.h\"\n\nint check_httpdir(void);\n\nint check_httpdir(void) {\n\tif (http_dir && http_dir[0] != '\\0') {\n\t\treturn 1;\n\t} else {\n\t\tchar *prog = NULL, *httpdir, *q;\n\t\tstruct stat sbuf;\n\t\tint len;\n\n\t\trfbLog(\"check_httpdir: trying to guess httpdir... %s\\n\", program_name);\n\t\tif (program_name[0] == '/') {\n\t\t\tprog = strdup(program_name);\n\t\t} else {\n\t\t\tchar cwd[1024];\n\t\t\tgetcwd(cwd, 1024);\n\t\t\tlen = strlen(cwd) + 1 + strlen(program_name) + 1;\n\t\t\tprog = (char *) malloc(len);\n\t\t\tsnprintf(prog, len, \"%s/%s\", cwd, program_name);\n\t\t\tif (stat(prog, &sbuf) != 0) {\n\t\t\t\tchar *path = strdup(getenv(\"PATH\"));\n\t\t\t\tchar *p, *base;\n\t\t\t\tbase = strrchr(program_name, '/');\n\t\t\t\tif (base) {\n\t\t\t\t\tbase++;\n\t\t\t\t} else {\n\t\t\t\t\tbase = program_name;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tp = strtok(path, \":\");\n\t\t\t\twhile(p) {\n\t\t\t\t\tif (prog) {\n\t\t\t\t\t\tfree(prog);\n\t\t\t\t\t\tprog = NULL;\n\t\t\t\t\t}\n\t\t\t\t\tlen = strlen(p) + 1 + strlen(base) + 1;\n\t\t\t\t\tprog = (char *) malloc(len);\n\t\t\t\t\tsnprintf(prog, len, \"%s/%s\", p, base);\n\t\t\t\t\tif (stat(prog, &sbuf) == 0) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tp = strtok(NULL, \":\");\n\t\t\t\t}\n\t\t\t\tfree(path);\n\t\t\t}\n\t\t}\n\t\t/*\n\t\t * /path/to/bin/x11vnc\n\t\t * /path/to/bin/../share/x11vnc/classes\n\t\t *                    12345678901234567\n\t\t * /path/to/bin/../share/x11vnc/classes/ssl\n\t\t *                    123456789012345678901\n\t\t *                                        21\n\t\t */\n\t\tif ((q = strrchr(prog, '/')) == NULL) {\n\t\t\trfbLog(\"check_httpdir: bad program path: %s\\n\", prog);\n\t\t\tfree(prog);\n\t\t\trfbLog(\"check_httpdir: *HTTP disabled*  Use -httpdir path\\n\");\n\t\t\treturn 0;\n\t\t}\n\n\t\tlen = strlen(prog) + 21 + 1;\n\t\t*q = '\\0';\n\t\thttpdir = (char *) malloc(len);\n\t\tif (use_stunnel && http_ssl) {\n\t\t\tsnprintf(httpdir, len, \"%s/../share/x11vnc/classes/ssl\", prog);\n\t\t} else if (!enc_str && (use_openssl || use_stunnel || http_ssl)) {\n\t\t\tsnprintf(httpdir, len, \"%s/../share/x11vnc/classes/ssl\", prog);\n\t\t} else {\n\t\t\tsnprintf(httpdir, len, \"%s/../share/x11vnc/classes\", prog);\n\t\t}\n\t\tif (stat(httpdir, &sbuf) != 0) {\n\t\t\tif (use_stunnel && http_ssl) {\n\t\t\t\tsnprintf(httpdir, len, \"%s/../classes/ssl\", prog);\n\t\t\t} else if (!enc_str && (use_openssl || use_stunnel || http_ssl)) {\n\t\t\t\tsnprintf(httpdir, len, \"%s/../classes/ssl\", prog);\n\t\t\t} else {\n\t\t\t\tsnprintf(httpdir, len, \"%s/../classes\", prog);\n\t\t\t}\n\t\t}\n\t\tfree(prog);\n\n\t\tif (stat(httpdir, &sbuf) == 0) {\n\t\t\t/* good enough for me */\n\t\t\trfbLog(\"check_httpdir: guessed directory:\\n\");\n\t\t\trfbLog(\"   %s\\n\", httpdir);\n\t\t\thttp_dir = httpdir;\n\t\t\treturn 1;\n\t\t} else {\n\t\t\t/* try some hardwires: */\n\t\t\tint i;\n\t\t\tchar **use;\n\t\t\tchar *list[] = {\n\t\t\t\t\"/usr/local/share/x11vnc/classes\",\n\t\t\t\t\"/usr/share/x11vnc/classes\",\n\t\t\t\tNULL\n\t\t\t};\n\t\t\tchar *ssllist[] = {\n\t\t\t\t\"/usr/local/share/x11vnc/classes/ssl\",\n\t\t\t\t\"/usr/share/x11vnc/classes/ssl\",\n\t\t\t\tNULL\n\t\t\t};\n\t\t\tif (use_stunnel && http_ssl) {\n\t\t\t\tuse = ssllist;\n\t\t\t} else if (!enc_str && (use_openssl || use_stunnel || http_ssl)) {\n\t\t\t\tuse = ssllist;\n\t\t\t} else {\n\t\t\t\tuse = list;\n\t\t\t}\n\t\t\ti = 0;\n\t\t\twhile (use[i] != NULL) {\n\t\t\t\tif (stat(use[i], &sbuf) == 0) {\n\t\t\t\t\thttp_dir = strdup(use[i]);\t\n\t\t\t\t\treturn 1;\n\t\t\t\t}\n\t\t\t\ti++;\n\t\t\t}\n\n\t\t\trfbLog(\"check_httpdir: bad guess:\\n\");\n\t\t\trfbLog(\"   %s\\n\", httpdir);\n\t\t\trfbLog(\"check_httpdir: *HTTP disabled*  Use -httpdir path\\n\");\n\t\t\treturn 0;\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "handle_one_http_request",
          "args": [],
          "line": 3081
        },
        "resolved": true,
        "details": {
          "function_name": "handle_one_http_request",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/user.c",
          "lines": "1168-1252",
          "snippet": "static void handle_one_http_request(void) {\n\trfbLog(\"handle_one_http_request: begin.\\n\");\n\tif (inetd || screen->httpPort == 0) {\n\t\tint port = find_free_port(5800, 5860);\n\t\tif (port) {\n\t\t\t/* mutex */\n\t\t\tscreen->httpPort = port;\n\t\t} else {\n\t\t\trfbLog(\"handle_one_http_request: no http port.\\n\");\n\t\t\tclean_up_exit(1);\n\t\t}\n\t}\n\tscreen->autoPort = FALSE;\n\tscreen->port = 0;\n\n\thttp_connections(1);\n\n\trfbInitServer(screen);\n\n\tif (!inetd) {\n\t\t/* XXX ipv6 */\n\t\tint conn = 0;\n\t\twhile (1) {\n\t\t\tif (0) fprintf(stderr, \"%d %d %d  %d\\n\", conn, screen->listenSock, screen->httpSock, screen->httpListenSock);\n\t\t\tusleep(10 * 1000);\n\t\t\trfbHttpCheckFds(screen);\n\t\t\tif (conn) {\n\t\t\t\tif (screen->httpSock < 0) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (screen->httpSock >= 0) {\n\t\t\t\t\tconn = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!screen->httpDir) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (screen->httpListenSock < 0) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\trfbLog(\"handle_one_http_request: finished.\\n\");\n\t\treturn;\n\t} else {\n\t\t/* inetd case: */\n#if LIBVNCSERVER_HAVE_FORK\n\t\tpid_t pid;\n\t\tint s_in = screen->inetdSock;\n\t\tif (s_in < 0) {\n\t\t\trfbLog(\"handle_one_http_request: inetdSock not set up.\\n\");\n\t\t\tclean_up_exit(1);\n\t\t}\n\t\tpid = fork();\n\t\tif (pid < 0) {\n\t\t\trfbLog(\"handle_one_http_request: could not fork.\\n\");\n\t\t\tclean_up_exit(1);\n\t\t} else if (pid > 0) {\n\t\t\tint status;\n\t\t\tpid_t pidw;\n\t\t\twhile (1) {\n\t\t\t\trfbHttpCheckFds(screen);\n\t\t\t\tpidw = waitpid(pid, &status, WNOHANG); \n\t\t\t\tif (pidw == pid && WIFEXITED(status)) {\n\t\t\t\t\tbreak;\n\t\t\t\t} else if (pidw < 0) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\trfbLog(\"handle_one_http_request: finished.\\n\");\n\t\t\treturn;\n\t\t} else {\n\t\t\tint sock = connect_tcp(\"127.0.0.1\", screen->httpPort);\n\t\t\tif (sock < 0) {\n\t\t\t\texit(1);\n\t\t\t}\n\t\t\traw_xfer(sock, s_in, s_in);\n\t\t\texit(0);\n\t\t}\n#else\n\t\trfbLog(\"handle_one_http_request: fork not supported.\\n\");\n\t\tclean_up_exit(1);\n#endif\n\t}\n}",
          "includes": [
            "#include \"avahi.h\"",
            "#include \"sslhelper.h\"",
            "#include \"remote.h\"",
            "#include \"cursor.h\"",
            "#include \"keyboard.h\"",
            "#include \"inet.h\"",
            "#include \"connections.h\"",
            "#include \"xwrappers.h\"",
            "#include \"sslhelper.h\"",
            "#include \"unixpw.h\"",
            "#include \"screen.h\"",
            "#include \"scan.h\"",
            "#include \"cleanup.h\"",
            "#include \"solid.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int wait_for_client(int *argc, char** argv, int http);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"avahi.h\"\n#include \"sslhelper.h\"\n#include \"remote.h\"\n#include \"cursor.h\"\n#include \"keyboard.h\"\n#include \"inet.h\"\n#include \"connections.h\"\n#include \"xwrappers.h\"\n#include \"sslhelper.h\"\n#include \"unixpw.h\"\n#include \"screen.h\"\n#include \"scan.h\"\n#include \"cleanup.h\"\n#include \"solid.h\"\n#include \"x11vnc.h\"\n\nint wait_for_client(int *argc, char** argv, int http);\n\nstatic void handle_one_http_request(void) {\n\trfbLog(\"handle_one_http_request: begin.\\n\");\n\tif (inetd || screen->httpPort == 0) {\n\t\tint port = find_free_port(5800, 5860);\n\t\tif (port) {\n\t\t\t/* mutex */\n\t\t\tscreen->httpPort = port;\n\t\t} else {\n\t\t\trfbLog(\"handle_one_http_request: no http port.\\n\");\n\t\t\tclean_up_exit(1);\n\t\t}\n\t}\n\tscreen->autoPort = FALSE;\n\tscreen->port = 0;\n\n\thttp_connections(1);\n\n\trfbInitServer(screen);\n\n\tif (!inetd) {\n\t\t/* XXX ipv6 */\n\t\tint conn = 0;\n\t\twhile (1) {\n\t\t\tif (0) fprintf(stderr, \"%d %d %d  %d\\n\", conn, screen->listenSock, screen->httpSock, screen->httpListenSock);\n\t\t\tusleep(10 * 1000);\n\t\t\trfbHttpCheckFds(screen);\n\t\t\tif (conn) {\n\t\t\t\tif (screen->httpSock < 0) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (screen->httpSock >= 0) {\n\t\t\t\t\tconn = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!screen->httpDir) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (screen->httpListenSock < 0) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\trfbLog(\"handle_one_http_request: finished.\\n\");\n\t\treturn;\n\t} else {\n\t\t/* inetd case: */\n#if LIBVNCSERVER_HAVE_FORK\n\t\tpid_t pid;\n\t\tint s_in = screen->inetdSock;\n\t\tif (s_in < 0) {\n\t\t\trfbLog(\"handle_one_http_request: inetdSock not set up.\\n\");\n\t\t\tclean_up_exit(1);\n\t\t}\n\t\tpid = fork();\n\t\tif (pid < 0) {\n\t\t\trfbLog(\"handle_one_http_request: could not fork.\\n\");\n\t\t\tclean_up_exit(1);\n\t\t} else if (pid > 0) {\n\t\t\tint status;\n\t\t\tpid_t pidw;\n\t\t\twhile (1) {\n\t\t\t\trfbHttpCheckFds(screen);\n\t\t\t\tpidw = waitpid(pid, &status, WNOHANG); \n\t\t\t\tif (pidw == pid && WIFEXITED(status)) {\n\t\t\t\t\tbreak;\n\t\t\t\t} else if (pidw < 0) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\trfbLog(\"handle_one_http_request: finished.\\n\");\n\t\t\treturn;\n\t\t} else {\n\t\t\tint sock = connect_tcp(\"127.0.0.1\", screen->httpPort);\n\t\t\tif (sock < 0) {\n\t\t\t\texit(1);\n\t\t\t}\n\t\t\traw_xfer(sock, s_in, s_in);\n\t\t\texit(0);\n\t\t}\n#else\n\t\trfbLog(\"handle_one_http_request: fork not supported.\\n\");\n\t\tclean_up_exit(1);\n#endif\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "cmd",
            "\"HTTPONCE\""
          ],
          "line": 3080
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ssh_remote_tunnel",
          "args": [
            "ssh_str",
            "screen->port"
          ],
          "line": 3071
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_remote_tunnel",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/x11vnc.c",
          "lines": "860-985",
          "snippet": "void ssh_remote_tunnel(char *instr, int lport) {\n\tchar *q, *cmd, *ssh;\n\tchar *s = strdup(instr);\n\tint sleep = 300, disp = 0, sport = 0;\n\tint rc, len, rport;\n\n\t/* user@host:port:disp+secs */\n\n\t/* +sleep */\n\tq = strrchr(s, '+');\n\tif (q) {\n\t\tsleep = atoi(q+1);\n\t\tif (sleep <= 0) {\n\t\t\tsleep = 1;\n\t\t}\n\t\t*q = '\\0';\n\t}\n\t/* :disp */\n\tq = strrchr(s, ':');\n\tif (q) {\n\t\tdisp = atoi(q+1);\n\t\t*q = '\\0';\n\t}\n\t\n\t/* :sshport */\n\tq = strrchr(s, ':');\n\tif (q) {\n\t\tsport = atoi(q+1);\n\t\t*q = '\\0';\n\t}\n\n\tif (getenv(\"SSH\")) {\n\t\tssh = getenv(\"SSH\");\n\t} else {\n\t\tssh = \"ssh\";\n\t}\n\n\tlen = 0;\n\tlen += strlen(ssh) + strlen(s) + 500;\n\tcmd = (char *) malloc(len);\n\n\tif (disp >= 0 && disp <= 200) {\n\t\trport = disp + 5900;\n\t} else if (disp < 0) {\n\t\trport = -disp;\n\t} else {\n\t\trport = disp;\n\t}\n\n\tif (sport > 0) {\n\t\tsprintf(cmd, \"%s -f -p %d -R '%d:localhost:%d' '%s' 'sleep %d'\", ssh, sport, rport, lport, s, sleep);\n\t} else {\n\t\tsprintf(cmd, \"%s -f       -R '%d:localhost:%d' '%s' 'sleep %d'\", ssh,        rport, lport, s, sleep);\n\t}\n\n\tif (no_external_cmds || !cmd_ok(\"ssh\")) {\n\t\trfbLogEnable(1);\n\t\trfbLog(\"cannot run external commands in -nocmds mode:\\n\");\n\t\trfbLog(\"   \\\"%s\\\"\\n\", cmd);\n\t\trfbLog(\"   exiting.\\n\");\n\t\tclean_up_exit(1);\n\t}\n\n\tclose_exec_fds();\n\tfprintf(stderr, \"\\n\");\n\trfbLog(\"running: %s\\n\", cmd);\n\trc = system(cmd);\n\n\tif (rc != 0) {\n\t\tfree(cmd);\n\t\tfree(s);\n\t\trfbLog(\"ssh remote listen failed.\\n\");\n\t\tclean_up_exit(1);\n\t}\n\n\tif (1) {\n\t\tFILE *pipe;\n\t\tint mypid = (int) getpid();\n\t\tint bestpid = -1;\n\t\tint best = -1;\n\t\tchar line[1024];\n\t\tchar *psef = \"ps -ef\";\n\t\tchar *psww = \"ps wwwwwwaux\";\n\t\tchar *ps = psef;\n\t\t/* not portable... but it is really good to terminate the ssh when done. */\n\t\t/* ps -ef | egrep 'ssh2.*-R.*5907:localhost:5900.*runge@celias.lbl.gov.*sleep 300' | grep -v grep | awk '{print $2}' */\n\t\tif (strstr(UT.sysname, \"Linux\")) {\n\t\t\tps = psww;\n\t\t} else if (strstr(UT.sysname, \"BSD\")) {\n\t\t\tps = psww;\n\t\t} else if (strstr(UT.sysname, \"Darwin\")) {\n\t\t\tps = psww;\n\t\t}\n\t\tsprintf(cmd, \"env COLUMNS=256 %s | egrep '%s.*-R *%d:localhost:%d.*%s.*sleep *%d' | grep -v grep | awk '{print $2}'\", ps, ssh, rport, lport, s, sleep);\n\t\tpipe = popen(cmd, \"r\");\n\t\tif (pipe) {\n\t\t\twhile (fgets(line, 1024, pipe) != NULL) {\n\t\t\t\tint p = atoi(line);\n\t\t\t\tif (p > 0) {\n\t\t\t\t\tint score;\n\t\t\t\t\tif (p > mypid) \t{\n\t\t\t\t\t\tscore = p - mypid;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tscore = p - mypid + 32768;\n\t\t\t\t\t\tif (score < 0) {\n\t\t\t\t\t\t\tscore = 32768;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (best < 0 || score < best) {\n\t\t\t\t\t\tbest = score;\n\t\t\t\t\t\tbestpid = p;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tpclose(pipe);\n\t\t}\n\n\t\tif (bestpid != -1) {\n\t\t\tssh_pid = (pid_t) bestpid;\n\t\t\trfbLog(\"guessed ssh pid=%d, will terminate it on exit.\\n\", bestpid);\n\t\t}\n\t}\n\n\tfree(cmd);\n\tfree(s);\n}",
          "includes": [
            "#include \"xi2_devices.h\"",
            "#include \"solid.h\"",
            "#include \"pm.h\"",
            "#include \"selection.h\"",
            "#include \"sslhelper.h\"",
            "#include \"sslcmds.h\"",
            "#include \"inet.h\"",
            "#include \"unixpw.h\"",
            "#include \"rates.h\"",
            "#include \"connections.h\"",
            "#include \"screen.h\"",
            "#include \"userinput.h\"",
            "#include \"cursor.h\"",
            "#include \"pointer.h\"",
            "#include \"keyboard.h\"",
            "#include \"cleanup.h\"",
            "#include \"user.h\"",
            "#include \"help.h\"",
            "#include \"gui.h\"",
            "#include \"scan.h\"",
            "#include \"remote.h\"",
            "#include \"win_utils.h\"",
            "#include \"xkb_bell.h\"",
            "#include \"xrandr.h\"",
            "#include \"xinerama.h\"",
            "#include \"xevents.h\"",
            "#include \"xrecord.h\"",
            "#include \"xdamage.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xi2_devices.h\"\n#include \"solid.h\"\n#include \"pm.h\"\n#include \"selection.h\"\n#include \"sslhelper.h\"\n#include \"sslcmds.h\"\n#include \"inet.h\"\n#include \"unixpw.h\"\n#include \"rates.h\"\n#include \"connections.h\"\n#include \"screen.h\"\n#include \"userinput.h\"\n#include \"cursor.h\"\n#include \"pointer.h\"\n#include \"keyboard.h\"\n#include \"cleanup.h\"\n#include \"user.h\"\n#include \"help.h\"\n#include \"gui.h\"\n#include \"scan.h\"\n#include \"remote.h\"\n#include \"win_utils.h\"\n#include \"xkb_bell.h\"\n#include \"xrandr.h\"\n#include \"xinerama.h\"\n#include \"xevents.h\"\n#include \"xrecord.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nvoid ssh_remote_tunnel(char *instr, int lport) {\n\tchar *q, *cmd, *ssh;\n\tchar *s = strdup(instr);\n\tint sleep = 300, disp = 0, sport = 0;\n\tint rc, len, rport;\n\n\t/* user@host:port:disp+secs */\n\n\t/* +sleep */\n\tq = strrchr(s, '+');\n\tif (q) {\n\t\tsleep = atoi(q+1);\n\t\tif (sleep <= 0) {\n\t\t\tsleep = 1;\n\t\t}\n\t\t*q = '\\0';\n\t}\n\t/* :disp */\n\tq = strrchr(s, ':');\n\tif (q) {\n\t\tdisp = atoi(q+1);\n\t\t*q = '\\0';\n\t}\n\t\n\t/* :sshport */\n\tq = strrchr(s, ':');\n\tif (q) {\n\t\tsport = atoi(q+1);\n\t\t*q = '\\0';\n\t}\n\n\tif (getenv(\"SSH\")) {\n\t\tssh = getenv(\"SSH\");\n\t} else {\n\t\tssh = \"ssh\";\n\t}\n\n\tlen = 0;\n\tlen += strlen(ssh) + strlen(s) + 500;\n\tcmd = (char *) malloc(len);\n\n\tif (disp >= 0 && disp <= 200) {\n\t\trport = disp + 5900;\n\t} else if (disp < 0) {\n\t\trport = -disp;\n\t} else {\n\t\trport = disp;\n\t}\n\n\tif (sport > 0) {\n\t\tsprintf(cmd, \"%s -f -p %d -R '%d:localhost:%d' '%s' 'sleep %d'\", ssh, sport, rport, lport, s, sleep);\n\t} else {\n\t\tsprintf(cmd, \"%s -f       -R '%d:localhost:%d' '%s' 'sleep %d'\", ssh,        rport, lport, s, sleep);\n\t}\n\n\tif (no_external_cmds || !cmd_ok(\"ssh\")) {\n\t\trfbLogEnable(1);\n\t\trfbLog(\"cannot run external commands in -nocmds mode:\\n\");\n\t\trfbLog(\"   \\\"%s\\\"\\n\", cmd);\n\t\trfbLog(\"   exiting.\\n\");\n\t\tclean_up_exit(1);\n\t}\n\n\tclose_exec_fds();\n\tfprintf(stderr, \"\\n\");\n\trfbLog(\"running: %s\\n\", cmd);\n\trc = system(cmd);\n\n\tif (rc != 0) {\n\t\tfree(cmd);\n\t\tfree(s);\n\t\trfbLog(\"ssh remote listen failed.\\n\");\n\t\tclean_up_exit(1);\n\t}\n\n\tif (1) {\n\t\tFILE *pipe;\n\t\tint mypid = (int) getpid();\n\t\tint bestpid = -1;\n\t\tint best = -1;\n\t\tchar line[1024];\n\t\tchar *psef = \"ps -ef\";\n\t\tchar *psww = \"ps wwwwwwaux\";\n\t\tchar *ps = psef;\n\t\t/* not portable... but it is really good to terminate the ssh when done. */\n\t\t/* ps -ef | egrep 'ssh2.*-R.*5907:localhost:5900.*runge@celias.lbl.gov.*sleep 300' | grep -v grep | awk '{print $2}' */\n\t\tif (strstr(UT.sysname, \"Linux\")) {\n\t\t\tps = psww;\n\t\t} else if (strstr(UT.sysname, \"BSD\")) {\n\t\t\tps = psww;\n\t\t} else if (strstr(UT.sysname, \"Darwin\")) {\n\t\t\tps = psww;\n\t\t}\n\t\tsprintf(cmd, \"env COLUMNS=256 %s | egrep '%s.*-R *%d:localhost:%d.*%s.*sleep *%d' | grep -v grep | awk '{print $2}'\", ps, ssh, rport, lport, s, sleep);\n\t\tpipe = popen(cmd, \"r\");\n\t\tif (pipe) {\n\t\t\twhile (fgets(line, 1024, pipe) != NULL) {\n\t\t\t\tint p = atoi(line);\n\t\t\t\tif (p > 0) {\n\t\t\t\t\tint score;\n\t\t\t\t\tif (p > mypid) \t{\n\t\t\t\t\t\tscore = p - mypid;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tscore = p - mypid + 32768;\n\t\t\t\t\t\tif (score < 0) {\n\t\t\t\t\t\t\tscore = 32768;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (best < 0 || score < best) {\n\t\t\t\t\t\tbest = score;\n\t\t\t\t\t\tbestpid = p;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tpclose(pipe);\n\t\t}\n\n\t\tif (bestpid != -1) {\n\t\t\tssh_pid = (pid_t) bestpid;\n\t\t\trfbLog(\"guessed ssh pid=%d, will terminate it on exit.\\n\", bestpid);\n\t\t}\n\t}\n\n\tfree(cmd);\n\tfree(s);\n}"
        }
      },
      {
        "call_info": {
          "callee": "initialize_signals",
          "args": [],
          "line": 3068
        },
        "resolved": true,
        "details": {
          "function_name": "initialize_signals",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/cleanup.c",
          "lines": "707-740",
          "snippet": "void initialize_signals(void) {\n\tsignal(SIGHUP,  interrupted);\n\tsignal(SIGINT,  interrupted);\n\tsignal(SIGQUIT, interrupted);\n\tsignal(SIGABRT, interrupted);\n\tsignal(SIGTERM, interrupted);\n\tsignal(SIGBUS,  interrupted);\n\tsignal(SIGSEGV, interrupted);\n\tsignal(SIGFPE,  interrupted);\n\n\tif (!sigpipe || *sigpipe == '\\0' || !strcmp(sigpipe, \"skip\")) {\n\t\t;\n\t} else if (strstr(sigpipe, \"ignore:\") == sigpipe) {\n\t\tignore_sigs(sigpipe);\n\t} else if (strstr(sigpipe, \"exit:\") == sigpipe) {\n\t\tignore_sigs(sigpipe);\n\t} else if (!strcmp(sigpipe, \"ignore\")) {\n#ifdef SIG_IGN\n\t\tsignal(SIGPIPE, SIG_IGN);\n#endif\n\t} else if (!strcmp(sigpipe, \"exit\")) {\n\t\trfbLog(\"initialize_signals: will exit on SIGPIPE\\n\");\n\t\tsignal(SIGPIPE, interrupted);\n\t}\n\n#if NO_X11\n\treturn;\n#else\n\tX_LOCK;\n\tXerror_def = XSetErrorHandler(Xerror);\n\tXIOerr_def = XSetIOErrorHandler(XIOerr);\n\tX_UNLOCK;\n#endif\t/* NO_X11 */\n}",
          "includes": [
            "#include \"xi2_devices.h\"",
            "#include \"uinput.h\"",
            "#include \"xevents.h\"",
            "#include \"xrecord.h\"",
            "#include \"screen.h\"",
            "#include \"avahi.h\"",
            "#include \"macosxCG.h\"",
            "#include \"macosx.h\"",
            "#include \"connections.h\"",
            "#include \"sslhelper.h\"",
            "#include \"sslcmds.h\"",
            "#include \"unixpw.h\"",
            "#include \"solid.h\"",
            "#include \"gui.h\"",
            "#include \"scan.h\"",
            "#include \"keyboard.h\"",
            "#include \"remote.h\"",
            "#include \"xdamage.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void initialize_signals(void);",
            "static XErrorHandler   Xerror_def;",
            "static XIOErrorHandler XIOerr_def;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xi2_devices.h\"\n#include \"uinput.h\"\n#include \"xevents.h\"\n#include \"xrecord.h\"\n#include \"screen.h\"\n#include \"avahi.h\"\n#include \"macosxCG.h\"\n#include \"macosx.h\"\n#include \"connections.h\"\n#include \"sslhelper.h\"\n#include \"sslcmds.h\"\n#include \"unixpw.h\"\n#include \"solid.h\"\n#include \"gui.h\"\n#include \"scan.h\"\n#include \"keyboard.h\"\n#include \"remote.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nvoid initialize_signals(void);\nstatic XErrorHandler   Xerror_def;\nstatic XIOErrorHandler XIOerr_def;\n\nvoid initialize_signals(void) {\n\tsignal(SIGHUP,  interrupted);\n\tsignal(SIGINT,  interrupted);\n\tsignal(SIGQUIT, interrupted);\n\tsignal(SIGABRT, interrupted);\n\tsignal(SIGTERM, interrupted);\n\tsignal(SIGBUS,  interrupted);\n\tsignal(SIGSEGV, interrupted);\n\tsignal(SIGFPE,  interrupted);\n\n\tif (!sigpipe || *sigpipe == '\\0' || !strcmp(sigpipe, \"skip\")) {\n\t\t;\n\t} else if (strstr(sigpipe, \"ignore:\") == sigpipe) {\n\t\tignore_sigs(sigpipe);\n\t} else if (strstr(sigpipe, \"exit:\") == sigpipe) {\n\t\tignore_sigs(sigpipe);\n\t} else if (!strcmp(sigpipe, \"ignore\")) {\n#ifdef SIG_IGN\n\t\tsignal(SIGPIPE, SIG_IGN);\n#endif\n\t} else if (!strcmp(sigpipe, \"exit\")) {\n\t\trfbLog(\"initialize_signals: will exit on SIGPIPE\\n\");\n\t\tsignal(SIGPIPE, interrupted);\n\t}\n\n#if NO_X11\n\treturn;\n#else\n\tX_LOCK;\n\tXerror_def = XSetErrorHandler(Xerror);\n\tXIOerr_def = XSetIOErrorHandler(XIOerr);\n\tX_UNLOCK;\n#endif\t/* NO_X11 */\n}"
        }
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"If this system is IPv6-only, use the -6 option.\\n\""
          ],
          "line": 3061
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"Error: could not obtain listening port.  (wait for client)\\n\""
          ],
          "line": 3059
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLogEnable",
          "args": [
            "1"
          ],
          "line": 3058
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"Info: listening on IPv6 interface only.  (wait for client)\\n\""
          ],
          "line": 3056
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "initialize_screen",
          "args": [
            "argc",
            "argv",
            "fb_image"
          ],
          "line": 3049
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "initialize_cursors_mode",
          "args": [],
          "line": 3047
        },
        "resolved": true,
        "details": {
          "function_name": "initialize_cursors_mode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/cursor.c",
          "lines": "1470-1510",
          "snippet": "void initialize_cursors_mode(void) {\n\tchar *s = multiple_cursors_mode;\n\tif (!s || !known_cursors_mode(s)) {\n\t\trfbLog(\"unknown cursors mode: %s\\n\", s);\n\t\trfbLog(\"resetting cursors mode to \\\"default\\\"\\n\");\n\t\tif (multiple_cursors_mode) free(multiple_cursors_mode);\n\t\tmultiple_cursors_mode = strdup(\"default\");\n\t\ts = multiple_cursors_mode;\n\t}\n\tif (!strcmp(s, \"none\")) {\n\t\tshow_cursor = 0;\n\t} else {\n\t\t/* we do NOT set show_cursor = 1, let the caller do that */\n\t}\n\n\tshow_multiple_cursors = 0;\n\tif (show_cursor) {\n\t\tif (!strcmp(s, \"default\")) {\n\t\t\tif(multiple_cursors_mode) free(multiple_cursors_mode);\n\t\t\tmultiple_cursors_mode = strdup(\"X\");\n\t\t\ts = multiple_cursors_mode;\n\t\t}\n\t\tif (*s == 'X' || !strcmp(s, \"some\") || !strcmp(s, \"most\")) {\n\t\t\tshow_multiple_cursors = 1;\n\t\t} else {\n\t\t\tshow_multiple_cursors = 0;\n\t\t\t/* hmmm, some bug going back to arrow mode.. */\n\t\t\tset_rfb_cursor(CURS_ARROW);\n\t\t}\n\t\tif (screen) {\n\t\t\tset_cursor_was_changed(screen);\n\t\t}\n\t} else {\n\t\tif (screen) {\n\t\t\tLOCK(screen->cursorMutex);\n\t\t\tscreen->cursor = NULL;\n\t\t\tUNLOCK(screen->cursorMutex);\n\t\t\tset_cursor_was_changed(screen);\n\t\t}\n\t}\n}",
          "includes": [
            "#include \"xi2_devices.h\"",
            "#include \"macosx.h\"",
            "#include \"unixpw.h\"",
            "#include \"scan.h\"",
            "#include \"screen.h\"",
            "#include \"cleanup.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int known_cursors_mode(char *s);",
            "void initialize_cursors_mode(void);",
            "void restore_cursor_shape_updates(rfbScreenInfoPtr s);",
            "void disable_cursor_shape_updates(rfbScreenInfoPtr s);",
            "int cursor_shape_updates_clients(rfbScreenInfoPtr s);",
            "int cursor_pos_updates_clients(rfbScreenInfoPtr s);",
            "unsigned long get_cursor_serial(int mode);",
            "static void set_cursor_was_changed(rfbScreenInfoPtr s);",
            "static cursor_info_t *cursors[CURS_MAX];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xi2_devices.h\"\n#include \"macosx.h\"\n#include \"unixpw.h\"\n#include \"scan.h\"\n#include \"screen.h\"\n#include \"cleanup.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nint known_cursors_mode(char *s);\nvoid initialize_cursors_mode(void);\nvoid restore_cursor_shape_updates(rfbScreenInfoPtr s);\nvoid disable_cursor_shape_updates(rfbScreenInfoPtr s);\nint cursor_shape_updates_clients(rfbScreenInfoPtr s);\nint cursor_pos_updates_clients(rfbScreenInfoPtr s);\nunsigned long get_cursor_serial(int mode);\nstatic void set_cursor_was_changed(rfbScreenInfoPtr s);\nstatic cursor_info_t *cursors[CURS_MAX];\n\nvoid initialize_cursors_mode(void) {\n\tchar *s = multiple_cursors_mode;\n\tif (!s || !known_cursors_mode(s)) {\n\t\trfbLog(\"unknown cursors mode: %s\\n\", s);\n\t\trfbLog(\"resetting cursors mode to \\\"default\\\"\\n\");\n\t\tif (multiple_cursors_mode) free(multiple_cursors_mode);\n\t\tmultiple_cursors_mode = strdup(\"default\");\n\t\ts = multiple_cursors_mode;\n\t}\n\tif (!strcmp(s, \"none\")) {\n\t\tshow_cursor = 0;\n\t} else {\n\t\t/* we do NOT set show_cursor = 1, let the caller do that */\n\t}\n\n\tshow_multiple_cursors = 0;\n\tif (show_cursor) {\n\t\tif (!strcmp(s, \"default\")) {\n\t\t\tif(multiple_cursors_mode) free(multiple_cursors_mode);\n\t\t\tmultiple_cursors_mode = strdup(\"X\");\n\t\t\ts = multiple_cursors_mode;\n\t\t}\n\t\tif (*s == 'X' || !strcmp(s, \"some\") || !strcmp(s, \"most\")) {\n\t\t\tshow_multiple_cursors = 1;\n\t\t} else {\n\t\t\tshow_multiple_cursors = 0;\n\t\t\t/* hmmm, some bug going back to arrow mode.. */\n\t\t\tset_rfb_cursor(CURS_ARROW);\n\t\t}\n\t\tif (screen) {\n\t\t\tset_cursor_was_changed(screen);\n\t\t}\n\t} else {\n\t\tif (screen) {\n\t\t\tLOCK(screen->cursorMutex);\n\t\t\tscreen->cursor = NULL;\n\t\t\tUNLOCK(screen->cursorMutex);\n\t\t\tset_cursor_was_changed(screen);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "\"default\""
          ],
          "line": 3045
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "initialize_allowed_input",
          "args": [],
          "line": 3042
        },
        "resolved": true,
        "details": {
          "function_name": "initialize_allowed_input",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/keyboard.c",
          "lines": "2430-2507",
          "snippet": "void initialize_allowed_input(void) {\n\tchar *str;\n\n\tif (allowed_input_normal) {\n\t\tfree(allowed_input_normal);\n\t\tallowed_input_normal = NULL;\n\t}\n\tif (allowed_input_view_only) {\n\t\tfree(allowed_input_view_only);\n\t\tallowed_input_view_only = NULL;\n\t}\n\n\tif (! allowed_input_str) {\n\t\tallowed_input_normal = strdup(\"KMBCF\");\n\t\tallowed_input_view_only = strdup(\"\");\n\t} else {\n\t\tchar *p, *str = strdup(allowed_input_str);\n\t\tp = strchr(str, ',');\n\t\tif (p) {\n\t\t\tallowed_input_view_only = strdup(p+1);\n\t\t\t*p = '\\0';\n\t\t\tallowed_input_normal = strdup(str);\n\t\t} else {\n\t\t\tallowed_input_normal = strdup(str);\n\t\t\tallowed_input_view_only = strdup(\"\");\n\t\t}\n\t\tfree(str);\n\t}\n\n\t/* shorten them */\n\tstr = short_kmbcf(allowed_input_normal);\n\tfree(allowed_input_normal);\n\tallowed_input_normal = str;\n\n\tstr = short_kmbcf(allowed_input_view_only);\n\tfree(allowed_input_view_only);\n\tallowed_input_view_only = str;\n\n\tif (screen) {\n\t\trfbClientIteratorPtr iter;\n\t\trfbClientPtr cl;\n\n\t\titer = rfbGetClientIterator(screen);\n\t\twhile( (cl = rfbClientIteratorNext(iter)) ) {\n\t\t\tClientData *cd = (ClientData *) cl->clientData;\n\n\t\t\tif (! cd) {\n\t\t\t\tcontinue;\n\t\t\t}\n#if 0\nrfbLog(\"cd: %p\\n\", cd);\nrfbLog(\"cd->input: %s\\n\", cd->input);\nrfbLog(\"cd->login_viewonly: %d\\n\", cd->login_viewonly);\nrfbLog(\"allowed_input_view_only: %s\\n\", allowed_input_view_only);\n#endif\n\n\t\t\tif (cd->input[0] == '=') {\n\t\t\t\t;\t/* custom setting */\n\t\t\t} else if (cd->login_viewonly) {\n\t\t\t\tif (*allowed_input_view_only != '\\0') {\n\t\t\t\t\tcl->viewOnly = FALSE;\n\t\t\t\t\tcd->input[0] = '\\0';\n\t\t\t\t\tstrncpy(cd->input,\n\t\t\t\t\t    allowed_input_view_only, CILEN);\n\t\t\t\t} else {\n\t\t\t\t\tcl->viewOnly = TRUE;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (allowed_input_normal) {\n\t\t\t\t\tcd->input[0] = '\\0';\n\t\t\t\t\tstrncpy(cd->input,\n\t\t\t\t\t    allowed_input_normal, CILEN);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\trfbReleaseClientIterator(iter);\n\t}\n}",
          "includes": [
            "#include \"xi2_devices.h\"",
            "#include \"screen.h\"",
            "#include \"macosx.h\"",
            "#include \"uinput.h\"",
            "#include \"linuxfb.h\"",
            "#include \"v4l.h\"",
            "#include \"unixpw.h\"",
            "#include \"allowed_input_t.h\"",
            "#include \"cleanup.h\"",
            "#include \"rates.h\"",
            "#include \"win_utils.h\"",
            "#include \"userinput.h\"",
            "#include \"pointer.h\"",
            "#include \"xinerama.h\"",
            "#include \"xrecord.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "char *short_kmbcf(char *str);",
            "void initialize_allowed_input(void);",
            "void get_allowed_input(rfbClientPtr client, allowed_input_t *input);",
            "static void add_dead_keysyms(char *str);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xi2_devices.h\"\n#include \"screen.h\"\n#include \"macosx.h\"\n#include \"uinput.h\"\n#include \"linuxfb.h\"\n#include \"v4l.h\"\n#include \"unixpw.h\"\n#include \"allowed_input_t.h\"\n#include \"cleanup.h\"\n#include \"rates.h\"\n#include \"win_utils.h\"\n#include \"userinput.h\"\n#include \"pointer.h\"\n#include \"xinerama.h\"\n#include \"xrecord.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nchar *short_kmbcf(char *str);\nvoid initialize_allowed_input(void);\nvoid get_allowed_input(rfbClientPtr client, allowed_input_t *input);\nstatic void add_dead_keysyms(char *str);\n\nvoid initialize_allowed_input(void) {\n\tchar *str;\n\n\tif (allowed_input_normal) {\n\t\tfree(allowed_input_normal);\n\t\tallowed_input_normal = NULL;\n\t}\n\tif (allowed_input_view_only) {\n\t\tfree(allowed_input_view_only);\n\t\tallowed_input_view_only = NULL;\n\t}\n\n\tif (! allowed_input_str) {\n\t\tallowed_input_normal = strdup(\"KMBCF\");\n\t\tallowed_input_view_only = strdup(\"\");\n\t} else {\n\t\tchar *p, *str = strdup(allowed_input_str);\n\t\tp = strchr(str, ',');\n\t\tif (p) {\n\t\t\tallowed_input_view_only = strdup(p+1);\n\t\t\t*p = '\\0';\n\t\t\tallowed_input_normal = strdup(str);\n\t\t} else {\n\t\t\tallowed_input_normal = strdup(str);\n\t\t\tallowed_input_view_only = strdup(\"\");\n\t\t}\n\t\tfree(str);\n\t}\n\n\t/* shorten them */\n\tstr = short_kmbcf(allowed_input_normal);\n\tfree(allowed_input_normal);\n\tallowed_input_normal = str;\n\n\tstr = short_kmbcf(allowed_input_view_only);\n\tfree(allowed_input_view_only);\n\tallowed_input_view_only = str;\n\n\tif (screen) {\n\t\trfbClientIteratorPtr iter;\n\t\trfbClientPtr cl;\n\n\t\titer = rfbGetClientIterator(screen);\n\t\twhile( (cl = rfbClientIteratorNext(iter)) ) {\n\t\t\tClientData *cd = (ClientData *) cl->clientData;\n\n\t\t\tif (! cd) {\n\t\t\t\tcontinue;\n\t\t\t}\n#if 0\nrfbLog(\"cd: %p\\n\", cd);\nrfbLog(\"cd->input: %s\\n\", cd->input);\nrfbLog(\"cd->login_viewonly: %d\\n\", cd->login_viewonly);\nrfbLog(\"allowed_input_view_only: %s\\n\", allowed_input_view_only);\n#endif\n\n\t\t\tif (cd->input[0] == '=') {\n\t\t\t\t;\t/* custom setting */\n\t\t\t} else if (cd->login_viewonly) {\n\t\t\t\tif (*allowed_input_view_only != '\\0') {\n\t\t\t\t\tcl->viewOnly = FALSE;\n\t\t\t\t\tcd->input[0] = '\\0';\n\t\t\t\t\tstrncpy(cd->input,\n\t\t\t\t\t    allowed_input_view_only, CILEN);\n\t\t\t\t} else {\n\t\t\t\t\tcl->viewOnly = TRUE;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (allowed_input_normal) {\n\t\t\t\t\tcd->input[0] = '\\0';\n\t\t\t\t\tstrncpy(cd->input,\n\t\t\t\t\t    allowed_input_normal, CILEN);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\trfbReleaseClientIterator(iter);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "s"
          ],
          "line": 3034
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "choose_title",
          "args": [
            "str"
          ],
          "line": 3032
        },
        "resolved": true,
        "details": {
          "function_name": "choose_title",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/util.c",
          "lines": "713-790",
          "snippet": "char *choose_title(char *display) {\n\tstatic char title[(MAXN+10)];\t\n\n\tmemset(title, 0, sizeof(title));\n\tstrcpy(title, \"x11vnc\");\n\n\tif (display == NULL) {\n\t\tdisplay = getenv(\"DISPLAY\");\n\t}\n\n#ifdef MACOSX\n\tif (display == NULL || strstr(display, \"/tmp/\") == display) {\n\t\tchar *u = get_user_name();\n\t\tchar *th = this_host();\n\t\tif (strlen(u) > MAXN/4)  {\n\t\t\tu = \"someone\";\n\t\t}\n\t\tstrcpy(title, u);\n\t\tif (th || UT.nodename) {\n\t\t\tstrcat(title, \"@\");\n\t\t\tstrncat(title, th ? th : UT.nodename,\n\t\t\t\tMAXN - strlen(title));\n\t\t\tfree(th);\n\t\t}\n\t\treturn title;\n\t}\n#endif\n\n\tif (display == NULL) {\n\t\treturn title;\n\t}\n\n\t/* use display: */\n\ttitle[0] = '\\0';\n\tif (display[0] == ':') {\n\t\tchar *th = this_host();\n\t\tif (th != NULL) {\n\t\t\tstrncpy(title, th, MAXN - strlen(title));\n\t\t\tfree(th);\n\t\t}\n\t}\n\tstrncat(title, display, MAXN - strlen(title));\n\tX_LOCK;\n\tif (subwin && dpy && valid_window(subwin, NULL, 0)) {\n#if !NO_X11\n\t\tchar *name = NULL;\n\t\tint do_appshare = getenv(\"X11VNC_APPSHARE_ACTIVE\") ? 1 : 0;\n\t\tif (0 && do_appshare) {\n\t\t\ttitle[0] = '\\0';\n\t\t}\n\t\tif (XFetchName(dpy, subwin, &name)) {\n\t\t\tif (name) {\n\t\t\t\tif (title[0] != '\\0') {\n\t\t\t\t\tstrncat(title, \" \",  MAXN - strlen(title));\n\t\t\t\t}\n\t\t\t\tstrncat(title, name, MAXN - strlen(title));\n\t\t\t\tfree(name);\n\t\t\t}\n\t\t}\n\t\tif (do_appshare) {\n\t\t\tWindow c;\n\t\t\tint x, y;\n\t\t\tif (xtranslate(subwin, rootwin, 0, 0, &x, &y, &c, 1)) {\n\t\t\t\tchar tmp[32];\n\t\t\t\tif (scaling) {\n\t\t\t\t\tx *= scale_fac_x;\n\t\t\t\t\ty *= scale_fac_y;\n\t\t\t\t}\n\t\t\t\tsprintf(tmp, \" XY=%d,%d\", x, y);\n\t\t\t\tstrncat(title, tmp, MAXN - strlen(title));\n\t\t\t}\n\t\t\trfbLog(\"appshare title: %s\\n\", title);\n\t\t}\n#endif\t/* NO_X11 */\n\t}\n\tX_UNLOCK;\n\treturn title;\n}",
          "includes": [
            "#include \"connections.h\"",
            "#include \"unixpw.h\"",
            "#include \"win_utils.h\"",
            "#include \"cleanup.h\"",
            "#include \"x11vnc.h\"",
            "#include <stdlib.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int nfix(int i, int n);",
            "int nabs(int n);",
            "double dabs(double x);",
            "char *get_user_name(void);",
            "char *this_host(void);",
            "char *choose_title(char *display);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"connections.h\"\n#include \"unixpw.h\"\n#include \"win_utils.h\"\n#include \"cleanup.h\"\n#include \"x11vnc.h\"\n#include <stdlib.h>\n\nint nfix(int i, int n);\nint nabs(int n);\ndouble dabs(double x);\nchar *get_user_name(void);\nchar *this_host(void);\nchar *choose_title(char *display);\n\nchar *choose_title(char *display) {\n\tstatic char title[(MAXN+10)];\t\n\n\tmemset(title, 0, sizeof(title));\n\tstrcpy(title, \"x11vnc\");\n\n\tif (display == NULL) {\n\t\tdisplay = getenv(\"DISPLAY\");\n\t}\n\n#ifdef MACOSX\n\tif (display == NULL || strstr(display, \"/tmp/\") == display) {\n\t\tchar *u = get_user_name();\n\t\tchar *th = this_host();\n\t\tif (strlen(u) > MAXN/4)  {\n\t\t\tu = \"someone\";\n\t\t}\n\t\tstrcpy(title, u);\n\t\tif (th || UT.nodename) {\n\t\t\tstrcat(title, \"@\");\n\t\t\tstrncat(title, th ? th : UT.nodename,\n\t\t\t\tMAXN - strlen(title));\n\t\t\tfree(th);\n\t\t}\n\t\treturn title;\n\t}\n#endif\n\n\tif (display == NULL) {\n\t\treturn title;\n\t}\n\n\t/* use display: */\n\ttitle[0] = '\\0';\n\tif (display[0] == ':') {\n\t\tchar *th = this_host();\n\t\tif (th != NULL) {\n\t\t\tstrncpy(title, th, MAXN - strlen(title));\n\t\t\tfree(th);\n\t\t}\n\t}\n\tstrncat(title, display, MAXN - strlen(title));\n\tX_LOCK;\n\tif (subwin && dpy && valid_window(subwin, NULL, 0)) {\n#if !NO_X11\n\t\tchar *name = NULL;\n\t\tint do_appshare = getenv(\"X11VNC_APPSHARE_ACTIVE\") ? 1 : 0;\n\t\tif (0 && do_appshare) {\n\t\t\ttitle[0] = '\\0';\n\t\t}\n\t\tif (XFetchName(dpy, subwin, &name)) {\n\t\t\tif (name) {\n\t\t\t\tif (title[0] != '\\0') {\n\t\t\t\t\tstrncat(title, \" \",  MAXN - strlen(title));\n\t\t\t\t}\n\t\t\t\tstrncat(title, name, MAXN - strlen(title));\n\t\t\t\tfree(name);\n\t\t\t}\n\t\t}\n\t\tif (do_appshare) {\n\t\t\tWindow c;\n\t\t\tint x, y;\n\t\t\tif (xtranslate(subwin, rootwin, 0, 0, &x, &y, &c, 1)) {\n\t\t\t\tchar tmp[32];\n\t\t\t\tif (scaling) {\n\t\t\t\t\tx *= scale_fac_x;\n\t\t\t\t\ty *= scale_fac_y;\n\t\t\t\t}\n\t\t\t\tsprintf(tmp, \" XY=%d,%d\", x, y);\n\t\t\t\tstrncat(title, tmp, MAXN - strlen(title));\n\t\t\t}\n\t\t\trfbLog(\"appshare title: %s\\n\", title);\n\t\t}\n#endif\t/* NO_X11 */\n\t}\n\tX_UNLOCK;\n\treturn title;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "s",
            "\":0\""
          ],
          "line": 3027
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "\"-desktop\""
          ],
          "line": 3021
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "setup_fake_fb",
          "args": [
            "fb_image",
            "w",
            "h",
            "b"
          ],
          "line": 3017
        },
        "resolved": true,
        "details": {
          "function_name": "setup_fake_fb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/user.c",
          "lines": "1409-1450",
          "snippet": "static void setup_fake_fb(XImage* fb_image, int w, int h, int b) {\n\tif (fake_fb) {\n\t\tfree(fake_fb);\n\t}\n\tfake_fb = (char *) calloc(w*h*b/8, 1);\n\n\tfb_image->data = fake_fb;\n\tfb_image->format = ZPixmap;\n\tfb_image->width  = w;\n\tfb_image->height = h;\n\tfb_image->bits_per_pixel = b;\n\tfb_image->bytes_per_line = w*b/8;\n\tfb_image->bitmap_unit = -1;\n\tif (b >= 24) {\n\t\tfb_image->depth = 24;\n\t\tfb_image->red_mask   = 0xff0000;\n\t\tfb_image->green_mask = 0x00ff00;\n\t\tfb_image->blue_mask  = 0x0000ff;\n\t} else if (b >= 16) {\n\t\tfb_image->depth = 16;\n\t\tfb_image->red_mask   = 0x003f;\n\t\tfb_image->green_mask = 0x07c0;\n\t\tfb_image->blue_mask  = 0xf800;\n\t} else if (b >= 2) {\n\t\tfb_image->depth = 8;\n\t\tfb_image->red_mask   = 0x07;\n\t\tfb_image->green_mask = 0x38;\n\t\tfb_image->blue_mask  = 0xc0;\n\t} else {\n\t\tfb_image->depth = 1;\n\t\tfb_image->red_mask   = 0x1;\n\t\tfb_image->green_mask = 0x1;\n\t\tfb_image->blue_mask  = 0x1;\n\t}\n\n\tdepth = fb_image->depth;\n\n\tdpy_x = wdpy_x = w;\n\tdpy_y = wdpy_y = h;\n\toff_x = 0;\n\toff_y = 0;\n}",
          "includes": [
            "#include \"avahi.h\"",
            "#include \"sslhelper.h\"",
            "#include \"remote.h\"",
            "#include \"cursor.h\"",
            "#include \"keyboard.h\"",
            "#include \"inet.h\"",
            "#include \"connections.h\"",
            "#include \"xwrappers.h\"",
            "#include \"sslhelper.h\"",
            "#include \"unixpw.h\"",
            "#include \"screen.h\"",
            "#include \"scan.h\"",
            "#include \"cleanup.h\"",
            "#include \"solid.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"avahi.h\"\n#include \"sslhelper.h\"\n#include \"remote.h\"\n#include \"cursor.h\"\n#include \"keyboard.h\"\n#include \"inet.h\"\n#include \"connections.h\"\n#include \"xwrappers.h\"\n#include \"sslhelper.h\"\n#include \"unixpw.h\"\n#include \"screen.h\"\n#include \"scan.h\"\n#include \"cleanup.h\"\n#include \"solid.h\"\n#include \"x11vnc.h\"\n\nstatic void setup_fake_fb(XImage* fb_image, int w, int h, int b) {\n\tif (fake_fb) {\n\t\tfree(fake_fb);\n\t}\n\tfake_fb = (char *) calloc(w*h*b/8, 1);\n\n\tfb_image->data = fake_fb;\n\tfb_image->format = ZPixmap;\n\tfb_image->width  = w;\n\tfb_image->height = h;\n\tfb_image->bits_per_pixel = b;\n\tfb_image->bytes_per_line = w*b/8;\n\tfb_image->bitmap_unit = -1;\n\tif (b >= 24) {\n\t\tfb_image->depth = 24;\n\t\tfb_image->red_mask   = 0xff0000;\n\t\tfb_image->green_mask = 0x00ff00;\n\t\tfb_image->blue_mask  = 0x0000ff;\n\t} else if (b >= 16) {\n\t\tfb_image->depth = 16;\n\t\tfb_image->red_mask   = 0x003f;\n\t\tfb_image->green_mask = 0x07c0;\n\t\tfb_image->blue_mask  = 0xf800;\n\t} else if (b >= 2) {\n\t\tfb_image->depth = 8;\n\t\tfb_image->red_mask   = 0x07;\n\t\tfb_image->green_mask = 0x38;\n\t\tfb_image->blue_mask  = 0xc0;\n\t} else {\n\t\tfb_image->depth = 1;\n\t\tfb_image->red_mask   = 0x1;\n\t\tfb_image->green_mask = 0x1;\n\t\tfb_image->blue_mask  = 0x1;\n\t}\n\n\tdepth = fb_image->depth;\n\n\tdpy_x = wdpy_x = w;\n\tdpy_y = wdpy_y = h;\n\toff_x = 0;\n\toff_y = 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "setup_cmd",
          "args": [
            "str",
            "&vnc_redirect",
            "&vnc_redirect_host",
            "&vnc_redirect_port",
            "db"
          ],
          "line": 3013
        },
        "resolved": true,
        "details": {
          "function_name": "setup_cmd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/user.c",
          "lines": "1885-1956",
          "snippet": "char *setup_cmd(char *str, int *vnc_redirect, char **vnc_redirect_host, int *vnc_redirect_port, int db) {\n\tchar *cmd = NULL;\n\t\n\tif (no_external_cmds || !cmd_ok(\"WAIT\")) {\n\t\trfbLog(\"wait_for_client external cmds not allowed:\"\n\t\t    \" %s\\n\", use_dpy);\n\t\tclean_up_exit(1);\n\t}\n\n\tcmd = str + strlen(\"cmd=\");\n\tif (!strcmp(cmd, \"FINDDISPLAY-print\")) {\n\t\tfprintf(stdout, \"%s\", find_display);\n\t\tclean_up_exit(0);\n\t}\n\tif (!strcmp(cmd, \"FINDDISPLAY-run\")) {\n\t\tchar tmp[] = \"/tmp/fd.XXXXXX\";\n\t\tchar com[100];\n\t\tint fd = mkstemp(tmp);\n\t\tif (fd >= 0) {\n\t\t\tint ret;\n\t\t\twrite(fd, find_display, strlen(find_display));\n\t\t\tclose(fd);\n\t\t\tset_env(\"FINDDISPLAY_run\", \"1\");\n\t\t\tsprintf(com, \"/bin/sh %s -n\", tmp);\n\t\t\tret = system(com);\n\t\t\tif (WIFEXITED(ret) && WEXITSTATUS(ret) != 0) {\n\t\t\t\tif (got_findauth && !getenv(\"FD_XDM\")) {\n\t\t\t\t\tif (getuid() == 0 || geteuid() == 0) {\n\t\t\t\t\t\tset_env(\"FD_XDM\", \"1\");\n\t\t\t\t\t\tsystem(com);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tunlink(tmp);\n\t\texit(0);\n\t}\n\tif (!strcmp(str, \"FINDCREATEDISPLAY-print\")) {\n\t\tfprintf(stdout, \"%s\", create_display);\n\t\tclean_up_exit(0);\n\t}\n\tif (db) fprintf(stderr, \"cmd: %s\\n\", cmd);\n\tif (strstr(str, \"FINDCREATEDISPLAY\") || strstr(str, \"FINDDISPLAY\")) {\n\t\tif (strstr(str, \"Xvnc.redirect\") || strstr(str, \"X.redirect\")) {\n\t\t\t*vnc_redirect = 1;\n\t\t}\n\t}\n\tif (strstr(cmd, \"FINDDISPLAY-vnc_redirect\") == cmd) {\n\t\tint p;\n\t\tchar h[256];\n\t\tif (strlen(cmd) >= 256) {\n\t\t\trfbLog(\"wait_for_client string too long: %s\\n\", str);\n\t\t\tclean_up_exit(1);\n\t\t}\n\t\th[0] = '\\0';\n\t\tif (sscanf(cmd, \"FINDDISPLAY-vnc_redirect=%d\", &p) == 1) {\n\t\t\t;\n\t\t} else if (sscanf(cmd, \"FINDDISPLAY-vnc_redirect=%s %d\", h, &p) == 2) {\n\t\t\t;\n\t\t} else {\n\t\t\trfbLog(\"wait_for_client bad string: %s\\n\", cmd);\n\t\t\tclean_up_exit(1);\n\t\t}\n\t\t*vnc_redirect_port = p;\n\t\tif (strcmp(h, \"\")) {\n\t\t\t*vnc_redirect_host = strdup(h);\n\t\t}\n\t\t*vnc_redirect = 2;\n\t\trfbLog(\"wait_for_client: vnc_redirect: %s:%d\\n\", *vnc_redirect_host, *vnc_redirect_port);\n\t}\n\treturn cmd;\n}",
          "includes": [
            "#include \"avahi.h\"",
            "#include \"sslhelper.h\"",
            "#include \"remote.h\"",
            "#include \"cursor.h\"",
            "#include \"keyboard.h\"",
            "#include \"inet.h\"",
            "#include \"connections.h\"",
            "#include \"xwrappers.h\"",
            "#include \"sslhelper.h\"",
            "#include \"unixpw.h\"",
            "#include \"screen.h\"",
            "#include \"scan.h\"",
            "#include \"cleanup.h\"",
            "#include \"solid.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void lurk_loop(char *str);",
            "extern char find_display[];",
            "extern char create_display[];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"avahi.h\"\n#include \"sslhelper.h\"\n#include \"remote.h\"\n#include \"cursor.h\"\n#include \"keyboard.h\"\n#include \"inet.h\"\n#include \"connections.h\"\n#include \"xwrappers.h\"\n#include \"sslhelper.h\"\n#include \"unixpw.h\"\n#include \"screen.h\"\n#include \"scan.h\"\n#include \"cleanup.h\"\n#include \"solid.h\"\n#include \"x11vnc.h\"\n\nvoid lurk_loop(char *str);\nextern char find_display[];\nextern char create_display[];\n\nchar *setup_cmd(char *str, int *vnc_redirect, char **vnc_redirect_host, int *vnc_redirect_port, int db) {\n\tchar *cmd = NULL;\n\t\n\tif (no_external_cmds || !cmd_ok(\"WAIT\")) {\n\t\trfbLog(\"wait_for_client external cmds not allowed:\"\n\t\t    \" %s\\n\", use_dpy);\n\t\tclean_up_exit(1);\n\t}\n\n\tcmd = str + strlen(\"cmd=\");\n\tif (!strcmp(cmd, \"FINDDISPLAY-print\")) {\n\t\tfprintf(stdout, \"%s\", find_display);\n\t\tclean_up_exit(0);\n\t}\n\tif (!strcmp(cmd, \"FINDDISPLAY-run\")) {\n\t\tchar tmp[] = \"/tmp/fd.XXXXXX\";\n\t\tchar com[100];\n\t\tint fd = mkstemp(tmp);\n\t\tif (fd >= 0) {\n\t\t\tint ret;\n\t\t\twrite(fd, find_display, strlen(find_display));\n\t\t\tclose(fd);\n\t\t\tset_env(\"FINDDISPLAY_run\", \"1\");\n\t\t\tsprintf(com, \"/bin/sh %s -n\", tmp);\n\t\t\tret = system(com);\n\t\t\tif (WIFEXITED(ret) && WEXITSTATUS(ret) != 0) {\n\t\t\t\tif (got_findauth && !getenv(\"FD_XDM\")) {\n\t\t\t\t\tif (getuid() == 0 || geteuid() == 0) {\n\t\t\t\t\t\tset_env(\"FD_XDM\", \"1\");\n\t\t\t\t\t\tsystem(com);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tunlink(tmp);\n\t\texit(0);\n\t}\n\tif (!strcmp(str, \"FINDCREATEDISPLAY-print\")) {\n\t\tfprintf(stdout, \"%s\", create_display);\n\t\tclean_up_exit(0);\n\t}\n\tif (db) fprintf(stderr, \"cmd: %s\\n\", cmd);\n\tif (strstr(str, \"FINDCREATEDISPLAY\") || strstr(str, \"FINDDISPLAY\")) {\n\t\tif (strstr(str, \"Xvnc.redirect\") || strstr(str, \"X.redirect\")) {\n\t\t\t*vnc_redirect = 1;\n\t\t}\n\t}\n\tif (strstr(cmd, \"FINDDISPLAY-vnc_redirect\") == cmd) {\n\t\tint p;\n\t\tchar h[256];\n\t\tif (strlen(cmd) >= 256) {\n\t\t\trfbLog(\"wait_for_client string too long: %s\\n\", str);\n\t\t\tclean_up_exit(1);\n\t\t}\n\t\th[0] = '\\0';\n\t\tif (sscanf(cmd, \"FINDDISPLAY-vnc_redirect=%d\", &p) == 1) {\n\t\t\t;\n\t\t} else if (sscanf(cmd, \"FINDDISPLAY-vnc_redirect=%s %d\", h, &p) == 2) {\n\t\t\t;\n\t\t} else {\n\t\t\trfbLog(\"wait_for_client bad string: %s\\n\", cmd);\n\t\t\tclean_up_exit(1);\n\t\t}\n\t\t*vnc_redirect_port = p;\n\t\tif (strcmp(h, \"\")) {\n\t\t\t*vnc_redirect_host = strdup(h);\n\t\t}\n\t\t*vnc_redirect = 2;\n\t\trfbLog(\"wait_for_client: vnc_redirect: %s:%d\\n\", *vnc_redirect_host, *vnc_redirect_port);\n\t}\n\treturn cmd;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "str",
            "\"cmd=\""
          ],
          "line": 3012
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"str: %s\\n\"",
            "str"
          ],
          "line": 3010
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strpbrk",
          "args": [
            "str",
            "\"0123456789\""
          ],
          "line": 3002
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "str",
            "\":cmd=\""
          ],
          "line": 2999
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nabs",
          "args": [
            "h0"
          ],
          "line": 2991
        },
        "resolved": true,
        "details": {
          "function_name": "nabs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/util.c",
          "lines": "120-126",
          "snippet": "int nabs(int n) {\n\tif (n < 0) {\n\t\treturn -n;\n\t} else {\n\t\treturn n;\n\t}\n}",
          "includes": [
            "#include \"connections.h\"",
            "#include \"unixpw.h\"",
            "#include \"win_utils.h\"",
            "#include \"cleanup.h\"",
            "#include \"x11vnc.h\"",
            "#include <stdlib.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int nfix(int i, int n);",
            "int nabs(int n);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"connections.h\"\n#include \"unixpw.h\"\n#include \"win_utils.h\"\n#include \"cleanup.h\"\n#include \"x11vnc.h\"\n#include <stdlib.h>\n\nint nfix(int i, int n);\nint nabs(int n);\n\nint nabs(int n) {\n\tif (n < 0) {\n\t\treturn -n;\n\t} else {\n\t\treturn n;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "sscanf",
          "args": [
            "s",
            "\"%dx%d\"",
            "&w0",
            "&h0"
          ],
          "line": 2989
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sscanf",
          "args": [
            "s",
            "\"%dx%dx%d\"",
            "&w0",
            "&h0",
            "&b0"
          ],
          "line": 2985
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "\"once:\""
          ],
          "line": 2983
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "s",
            "\"once:\""
          ],
          "line": 2981
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"wait_for_client set: w=%d h=%d\\n\"",
            "w",
            "h"
          ],
          "line": 2970
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sscanf",
          "args": [
            "str+1",
            "\"%dx%d\"",
            "&w0",
            "&h0"
          ],
          "line": 2967
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "str+1",
            "':'"
          ],
          "line": 2964
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "\"WAIT\""
          ],
          "line": 2959
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "use_dpy"
          ],
          "line": 2958
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"\\n\""
          ],
          "line": 2955
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"wait_for_client: %s\\n\"",
            "use_dpy"
          ],
          "line": 2954
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"\\n\""
          ],
          "line": 2953
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "use_dpy",
            "\"FINDDISPLAY-run\""
          ],
          "line": 2952
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"args %d %s\\n\"",
            "i",
            "argv[i]"
          ],
          "line": 2950
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "argv[i]",
            "\"-desktop\""
          ],
          "line": 2947
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "use_dpy",
            "\"WAIT:\""
          ],
          "line": 2942
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getenv",
          "args": [
            "\"WAIT_FOR_CLIENT_DB\""
          ],
          "line": 2936
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"avahi.h\"\n#include \"sslhelper.h\"\n#include \"remote.h\"\n#include \"cursor.h\"\n#include \"keyboard.h\"\n#include \"inet.h\"\n#include \"connections.h\"\n#include \"xwrappers.h\"\n#include \"sslhelper.h\"\n#include \"unixpw.h\"\n#include \"screen.h\"\n#include \"scan.h\"\n#include \"cleanup.h\"\n#include \"solid.h\"\n#include \"x11vnc.h\"\n\nvoid lurk_loop(char *str);\nvoid progress_client(void);\nint wait_for_client(int *argc, char** argv, int http);\nchar *xdmcp_insert = NULL;\nvoid ssh_remote_tunnel(char *, int);\nstatic XImage ximage_struct;\n\nint wait_for_client(int *argc, char** argv, int http) {\n\t/* ugh, here we go... */\n\tXImage* fb_image;\n\tint w = 640, h = 480, b = 32;\n\tint w0 = -1, h0 = -1, i, chg_raw_fb = 0;\n\tchar *str, *q, *cmd = NULL;\n\tint db = 0, dt = 0;\n\tchar *create_cmd = NULL;\n\tchar *users_list_save = NULL;\n\tint created_disp = 0, ncache_save;\n\tint did_client_connect = 0;\n\tchar *vnc_redirect_host = \"localhost\";\n\tint vnc_redirect_port = -1, vnc_redirect_cnt = 0;\n\tchar vnc_redirect_test[10];\n\n\tif (getenv(\"WAIT_FOR_CLIENT_DB\")) {\n\t\tdb = 1;\n\t}\n\n\tvnc_redirect = 0;\n\n\tif (! use_dpy || strstr(use_dpy, \"WAIT:\") != use_dpy) {\n\t\treturn 0;\n\t}\n\n\tfor (i=0; i < *argc; i++) {\n\t\tif (!strcmp(argv[i], \"-desktop\")) {\n\t\t\tdt = 1;\n\t\t}\n\t\tif (db) fprintf(stderr, \"args %d %s\\n\", i, argv[i]);\n\t}\n\tif (!quiet && !strstr(use_dpy, \"FINDDISPLAY-run\")) {\n\t\trfbLog(\"\\n\");\n\t\trfbLog(\"wait_for_client: %s\\n\", use_dpy);\n\t\trfbLog(\"\\n\");\n\t}\n\n\tstr = strdup(use_dpy);\n\tstr += strlen(\"WAIT\");\n\n\txdmcp_insert = NULL;\n\n\t/* get any leading geometry: */\n\tq = strchr(str+1, ':');\n\tif (q) {\n\t\t*q = '\\0';\n\t\tif (sscanf(str+1, \"%dx%d\", &w0, &h0) == 2)  {\n\t\t\tw = w0;\n\t\t\th = h0;\n\t\t\trfbLog(\"wait_for_client set: w=%d h=%d\\n\", w, h);\n\t\t} else {\n\t\t\tw0 = -1;\n\t\t\th0 = -1;\n\t\t}\n\t\t*q = ':';\n\t\tstr = q;\n\t}\n\tif ((w0 == -1 || h0 == -1) && pad_geometry != NULL) {\n\t\tint b0, del = 0;\n\t\tchar *s = pad_geometry;\n\t\tif (strstr(s, \"once:\") == s) {\n\t\t\tdel = 1;\n\t\t\ts += strlen(\"once:\");\n\t\t}\n\t\tif (sscanf(s, \"%dx%dx%d\", &w0, &h0, &b0) == 3)  {\n\t\t\tw = nabs(w0);\n\t\t\th = nabs(h0);\n\t\t\tb = nabs(b0);\n\t\t} else if (sscanf(s, \"%dx%d\", &w0, &h0) == 2)  {\n\t\t\tw = nabs(w0);\n\t\t\th = nabs(h0);\n\t\t}\n\t\tif (del) {\n\t\t\tpad_geometry = NULL;\n\t\t}\n\t}\n\n\t/* str currently begins with a ':' */\n\tif (strstr(str, \":cmd=\") == str) {\n\t\t/* cmd=/path/to/mycommand */\n\t\tstr++;\n\t} else if (strpbrk(str, \"0123456789\") == str+1) {\n\t\t/* :0.0 */\n\t\t;\n\t} else {\n\t\t/* hostname:0.0 */\n\t\tstr++;\n\t}\n\n\tif (db) fprintf(stderr, \"str: %s\\n\", str);\n\n\tif (strstr(str, \"cmd=\") == str) {\n\t\tcmd = setup_cmd(str, &vnc_redirect, &vnc_redirect_host, &vnc_redirect_port, db);\n\t}\n\t\n\tfb_image = &ximage_struct;\n\tsetup_fake_fb(fb_image, w, h, b);\n\n\tif (! dt) {\n\t\tchar *s;\n\t\targv[*argc] = strdup(\"-desktop\");\n\t\t*argc = (*argc) + 1;\n\n\t\tif (cmd) {\n\t\t\tchar *q;\n\t\t\ts = choose_title(\":0\");\n\t\t\tq = strstr(s, \":0\");\n\t\t\tif (q) {\n\t\t\t\t*q = '\\0';\n\t\t\t}\n\t\t} else {\n\t\t\ts = choose_title(str);\n\t\t}\n\t\trfb_desktop_name = strdup(s);\n\t\targv[*argc] = s;\n\t\t*argc = (*argc) + 1;\n\t}\n\n\tncache_save = ncache;\n\tncache = 0;\n\n\tinitialize_allowed_input();\n\n\tif (! multiple_cursors_mode) {\n\t\tmultiple_cursors_mode = strdup(\"default\");\n\t}\n\tinitialize_cursors_mode();\n\t\n\tinitialize_screen(argc, argv, fb_image);\n\n\tif (! inetd && ! use_openssl) {\n\t\tif (! screen->port || screen->listenSock < 0) {\n\t\t\tif (got_rfbport && got_rfbport_val == 0) {\n\t\t\t\t;\n\t\t\t} else if (ipv6_listen && ipv6_listen_fd >= 0) {\n\t\t\t\trfbLog(\"Info: listening on IPv6 interface only.  (wait for client)\\n\");\n\t\t\t} else {\n\t\t\t\trfbLogEnable(1);\n\t\t\t\trfbLog(\"Error: could not obtain listening port.  (wait for client)\\n\");\n\t\t\t\tif (!got_rfbport && !got_ipv6_listen) {\n\t\t\t\t\trfbLog(\"If this system is IPv6-only, use the -6 option.\\n\");\n\t\t\t\t}\n\t\t\t\tclean_up_exit(1);\n\t\t\t}\n\t\t}\n\t}\n\n\tinitialize_signals();\n\n\tif (ssh_str != NULL) {\n\t\tssh_remote_tunnel(ssh_str, screen->port);\n\t}\n\n\tif (! raw_fb) {\n\t\tchg_raw_fb = 1;\n\t\t/* kludge to get RAWFB_RET with dpy == NULL guards */\n\t\traw_fb = (char *) 0x1;\n\t}\n\n\tif (cmd && !strcmp(cmd, \"HTTPONCE\")) {\n\t\thandle_one_http_request();\t\n\t\tclean_up_exit(0);\n\t}\n\n\tif (http && check_httpdir()) {\n\t\thttp_connections(1);\n\t}\n\n\tif (cmd && unixpw) {\n\t\tkeep_unixpw = 1;\n\t}\n\n\tsetup_service();\n\n\tcheck_waitbg();\n\n\tif (vnc_redirect) {\n\t\tvnc_redirect_loop(vnc_redirect_test, &vnc_redirect_cnt);\n\t} else {\n\n\t\tif (use_threads && !started_rfbRunEventLoop) {\n\t\t\tstarted_rfbRunEventLoop = 1;\n\t\t\trfbRunEventLoop(screen, -1, TRUE);\n\t\t}\n\n\t\tif (inetd && use_openssl) {\n\t\t\taccept_openssl(OPENSSL_INETD, -1);\n\t\t}\n\n\t\tsetup_client_connect(&did_client_connect);\n\n\t\tloop_for_connect(did_client_connect);\n\n\t\tif (unixpw) {\n\t\t\tif (cmd && strstr(cmd, \"FINDCREATEDISPLAY\") == cmd) {\n\t\t\t\tif (users_list && strstr(users_list, \"unixpw=\") == users_list) {\n\t\t\t\t\tusers_list_save = users_list;\n\t\t\t\t\tusers_list = NULL;\n\t\t\t\t}\n\t\t\t}\n\t\t\tdo_unixpw_loop();\n\t\t} else if (cmd && !use_threads) {\n\t\t\t/* try to get RFB proto done now. */\n\t\t\tprogress_client();\n\t\t}\n\t}\n\n\tif (vnc_redirect == 2) {\n\t\t;\n\t} else if (cmd) {\n\t\tif (!do_run_cmd(cmd, create_cmd, users_list_save, created_disp, db)) {\n\t\t\treturn 0;\n\t\t}\n\t} else {\n\t\tuse_dpy = strdup(str);\n\t}\n\tif (chg_raw_fb) {\n\t\traw_fb = NULL;\n\t}\n\n\tncache = ncache_save;\n\n\tif (unixpw && keep_unixpw_opts && keep_unixpw_opts[0] != '\\0') {\n\t\tuser_supplied_opts(keep_unixpw_opts);\n\t}\n\tif (create_cmd) {\n\t\tfree(create_cmd);\n\t}\n\n\tif (vnc_redirect) {\n\t\tdo_vnc_redirect(created_disp, vnc_redirect_host, vnc_redirect_port,\n\t\t    vnc_redirect_cnt, vnc_redirect_test);\n\t\tclean_up_exit(0);\n\t}\n\n\treturn 1;\n}"
  },
  {
    "function_name": "progress_client",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/user.c",
    "lines": "2891-2919",
    "snippet": "void progress_client(void) {\n\tint i, j = 0, progressed = 0, db = 0;\n\tdouble start = dnow();\n\tif (getenv(\"PROGRESS_CLIENT_DBG\")) {\n\t\trfbLog(\"progress_client: begin\\n\");\n\t\tdb = 1;\n\t}\n\tfor (i = 0; i < 15; i++) {\n\t\tif (latest_client) {\n\t\t\tfor (j = 0; j < 10; j++) {\n\t\t\t\tif (latest_client->state != RFB_PROTOCOL_VERSION) {\n\t\t\t\t\tprogressed = 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (db) rfbLog(\"progress_client: calling-1 rfbCFD(1) %.6f\\n\", dnow()-start);\n\t\t\t\trfbCFD(1);\n\t\t\t}\n\t\t}\n\t\tif (progressed) {\n\t\t\tbreak;\n\t\t}\n\t\tif (db) rfbLog(\"progress_client: calling-2 rfbCFD(1) %.6f\\n\", dnow()-start);\n\t\trfbCFD(1);\n\t}\n\tif (!quiet) {\n\t\trfbLog(\"client progressed=%d in %d/%d %.6f s\\n\",\n\t\t    progressed, i, j, dnow() - start);\n\t}\n}",
    "includes": [
      "#include \"avahi.h\"",
      "#include \"sslhelper.h\"",
      "#include \"remote.h\"",
      "#include \"cursor.h\"",
      "#include \"keyboard.h\"",
      "#include \"inet.h\"",
      "#include \"connections.h\"",
      "#include \"xwrappers.h\"",
      "#include \"sslhelper.h\"",
      "#include \"unixpw.h\"",
      "#include \"screen.h\"",
      "#include \"scan.h\"",
      "#include \"cleanup.h\"",
      "#include \"solid.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "void progress_client(void);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"client progressed=%d in %d/%d %.6f s\\n\"",
            "progressed",
            "i",
            "j",
            "dnow() - start"
          ],
          "line": 2916
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dnow",
          "args": [],
          "line": 2917
        },
        "resolved": true,
        "details": {
          "function_name": "dnowx",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/util.c",
          "lines": "439-441",
          "snippet": "double dnowx(void) {\n\treturn dnow() - x11vnc_start;\n}",
          "includes": [
            "#include \"connections.h\"",
            "#include \"unixpw.h\"",
            "#include \"win_utils.h\"",
            "#include \"cleanup.h\"",
            "#include \"x11vnc.h\"",
            "#include <stdlib.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "double dnow(void);",
            "double dnowx(void);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"connections.h\"\n#include \"unixpw.h\"\n#include \"win_utils.h\"\n#include \"cleanup.h\"\n#include \"x11vnc.h\"\n#include <stdlib.h>\n\ndouble dnow(void);\ndouble dnowx(void);\n\ndouble dnowx(void) {\n\treturn dnow() - x11vnc_start;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rfbCFD",
          "args": [
            "1"
          ],
          "line": 2913
        },
        "resolved": true,
        "details": {
          "function_name": "rfbCFD",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/util.c",
          "lines": "621-671",
          "snippet": "void rfbCFD(long usec) {\n\tint uip0 = unixpw_in_progress;\n\tif (! screen) {\n\t\treturn;\n\t}\n \tif (unixpw && unixpw_in_progress && !unixpw_in_rfbPE) {\n\t\tstatic int msgs = 0;\n\t\tstatic double last_reset = 0.0;\n\t\tif (dnow() > last_reset + 5.0) {\n\t\t\tmsgs = 0;\n\t\t\tlast_reset = dnow();\n\t\t}\n\t\tif (msgs++ < 10) {\n\t\t\trfbLog(\"unixpw_in_rfbPE: skipping rfbCFD\\n\");\n\t\t\tif (msgs == 10) {\n\t\t\t\trfbLog(\"unixpw_in_rfbPE: skipping rfbCFD ...\\n\");\n\t\t\t}\n\t\t}\n \t\treturn;\n \t}\n\tif (usec > USEC_MAX) {\n\t\tusec = USEC_MAX;\n\t}\n\n\tif (debug_tiles > 2) {\n\t\tdouble tm = dnow();\n\t\tfprintf(stderr, \"rfbCFD(%d) t: %.4f\\n\",\n\t\t    (int) usec, tm - x11vnc_start);\n\t}\n\n\n\tif (! use_threads) {\n\t\tif (all_input) {\n\t\t\tdo_allinput(usec);\n\t\t} else {\n\t\t\tif (handle_events_eagerly) {\n\t\t\t\tscreen->handleEventsEagerly = TRUE;\n\t\t\t} else {\n\t\t\t\tscreen->handleEventsEagerly = FALSE;\n\t\t\t}\n\t\t\trfbCheckFds(screen, usec);\n\t\t}\n\t}\n\n \tif (unixpw && unixpw_in_progress && !uip0) {\n\t\tif (!unixpw_in_rfbPE) {\n\t\t\trfbLog(\"rfbCFD: got new client in non-rfbPE\\n\");\n\t\t\t;\t/* this is new unixpw client  */\n\t\t}\n \t}\n}",
          "includes": [
            "#include \"connections.h\"",
            "#include \"unixpw.h\"",
            "#include \"win_utils.h\"",
            "#include \"cleanup.h\"",
            "#include \"x11vnc.h\"",
            "#include <stdlib.h>"
          ],
          "macros_used": [
            "#define USEC_MAX 999999\t\t/* libvncsever assumes < 1 second */"
          ],
          "globals_used": [
            "int nfix(int i, int n);",
            "int nabs(int n);",
            "double dnow(void);",
            "int rfbPE(long usec);",
            "void rfbCFD(long usec);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"connections.h\"\n#include \"unixpw.h\"\n#include \"win_utils.h\"\n#include \"cleanup.h\"\n#include \"x11vnc.h\"\n#include <stdlib.h>\n\n#define USEC_MAX 999999\t\t/* libvncsever assumes < 1 second */\n\nint nfix(int i, int n);\nint nabs(int n);\ndouble dnow(void);\nint rfbPE(long usec);\nvoid rfbCFD(long usec);\n\nvoid rfbCFD(long usec) {\n\tint uip0 = unixpw_in_progress;\n\tif (! screen) {\n\t\treturn;\n\t}\n \tif (unixpw && unixpw_in_progress && !unixpw_in_rfbPE) {\n\t\tstatic int msgs = 0;\n\t\tstatic double last_reset = 0.0;\n\t\tif (dnow() > last_reset + 5.0) {\n\t\t\tmsgs = 0;\n\t\t\tlast_reset = dnow();\n\t\t}\n\t\tif (msgs++ < 10) {\n\t\t\trfbLog(\"unixpw_in_rfbPE: skipping rfbCFD\\n\");\n\t\t\tif (msgs == 10) {\n\t\t\t\trfbLog(\"unixpw_in_rfbPE: skipping rfbCFD ...\\n\");\n\t\t\t}\n\t\t}\n \t\treturn;\n \t}\n\tif (usec > USEC_MAX) {\n\t\tusec = USEC_MAX;\n\t}\n\n\tif (debug_tiles > 2) {\n\t\tdouble tm = dnow();\n\t\tfprintf(stderr, \"rfbCFD(%d) t: %.4f\\n\",\n\t\t    (int) usec, tm - x11vnc_start);\n\t}\n\n\n\tif (! use_threads) {\n\t\tif (all_input) {\n\t\t\tdo_allinput(usec);\n\t\t} else {\n\t\t\tif (handle_events_eagerly) {\n\t\t\t\tscreen->handleEventsEagerly = TRUE;\n\t\t\t} else {\n\t\t\t\tscreen->handleEventsEagerly = FALSE;\n\t\t\t}\n\t\t\trfbCheckFds(screen, usec);\n\t\t}\n\t}\n\n \tif (unixpw && unixpw_in_progress && !uip0) {\n\t\tif (!unixpw_in_rfbPE) {\n\t\t\trfbLog(\"rfbCFD: got new client in non-rfbPE\\n\");\n\t\t\t;\t/* this is new unixpw client  */\n\t\t}\n \t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"progress_client: calling-2 rfbCFD(1) %.6f\\n\"",
            "dnow()-start"
          ],
          "line": 2912
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"progress_client: calling-1 rfbCFD(1) %.6f\\n\"",
            "dnow()-start"
          ],
          "line": 2905
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"progress_client: begin\\n\""
          ],
          "line": 2895
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getenv",
          "args": [
            "\"PROGRESS_CLIENT_DBG\""
          ],
          "line": 2894
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"avahi.h\"\n#include \"sslhelper.h\"\n#include \"remote.h\"\n#include \"cursor.h\"\n#include \"keyboard.h\"\n#include \"inet.h\"\n#include \"connections.h\"\n#include \"xwrappers.h\"\n#include \"sslhelper.h\"\n#include \"unixpw.h\"\n#include \"screen.h\"\n#include \"scan.h\"\n#include \"cleanup.h\"\n#include \"solid.h\"\n#include \"x11vnc.h\"\n\nvoid progress_client(void);\n\nvoid progress_client(void) {\n\tint i, j = 0, progressed = 0, db = 0;\n\tdouble start = dnow();\n\tif (getenv(\"PROGRESS_CLIENT_DBG\")) {\n\t\trfbLog(\"progress_client: begin\\n\");\n\t\tdb = 1;\n\t}\n\tfor (i = 0; i < 15; i++) {\n\t\tif (latest_client) {\n\t\t\tfor (j = 0; j < 10; j++) {\n\t\t\t\tif (latest_client->state != RFB_PROTOCOL_VERSION) {\n\t\t\t\t\tprogressed = 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (db) rfbLog(\"progress_client: calling-1 rfbCFD(1) %.6f\\n\", dnow()-start);\n\t\t\t\trfbCFD(1);\n\t\t\t}\n\t\t}\n\t\tif (progressed) {\n\t\t\tbreak;\n\t\t}\n\t\tif (db) rfbLog(\"progress_client: calling-2 rfbCFD(1) %.6f\\n\", dnow()-start);\n\t\trfbCFD(1);\n\t}\n\tif (!quiet) {\n\t\trfbLog(\"client progressed=%d in %d/%d %.6f s\\n\",\n\t\t    progressed, i, j, dnow() - start);\n\t}\n}"
  },
  {
    "function_name": "do_run_cmd",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/user.c",
    "lines": "2464-2885",
    "snippet": "static int do_run_cmd(char *cmd, char *create_cmd, char *users_list_save, int created_disp, int db) {\n\tchar tmp[] = \"/tmp/x11vnc-find_display.XXXXXX\";\n\tchar line1[1024], line2[16384];\n\tchar *q, *usslpeer = NULL;\n\tint n, nodisp = 0, saw_xdmcp = 0;\n\tint tmp_fd = -1;\n\tint internal_cmd = 0;\n\tint tried_switch = 0;\n\n\tmemset(line1, 0, sizeof(line1));\n\tmemset(line2, 0, sizeof(line2));\n\n\tif (users_list && strstr(users_list, \"sslpeer=\") == users_list) {\n\t\tusslpeer = get_usslpeer();\n\t\tif (! usslpeer) {\n\t\t\treturn 0;\n\t\t}\n\t}\n\tif (getenv(\"DEBUG_RUN_CMD\")) db = 1;\n\n\t/* only sets environment variables: */\n\trun_user_command(\"\", latest_client, \"env\", NULL, 0, NULL);\n\n\tif (program_name) {\n\t\tset_env(\"X11VNC_PROG\", program_name);\n\t} else {\n\t\tset_env(\"X11VNC_PROG\", \"x11vnc\");\n\t}\n\n\tif (!strcmp(cmd, \"FINDDISPLAY\") ||\n\t    strstr(cmd, \"FINDCREATEDISPLAY\") == cmd) {\n\t\tchar *nd = \"\";\n\t\tchar *tag = \"\";\n\t\tchar fdout[128];\n\n\t\tinternal_cmd = 1;\n\n\t\ttmp_fd = mkstemp(tmp);\n\n\t\tif (tmp_fd < 0) {\n\t\t\trfbLog(\"wait_for_client: open failed: %s\\n\", tmp);\n\t\t\trfbLogPerror(\"mkstemp\");\n\t\t\tclean_up_exit(1);\n\t\t}\n\t\tchmod(tmp, 0644);\n\t\tif (getenv(\"X11VNC_FINDDISPLAY_ALWAYS_FAILS\")) {\n\t\t\tchar *s = \"#!/bin/sh\\necho _FAIL_\\nexit 1\\n\";\n\t\t\twrite(tmp_fd, s, strlen(s));\n\t\t} else {\n\t\t\twrite(tmp_fd, find_display, strlen(find_display));\n\t\t}\n\t\tclose(tmp_fd);\n\t\tnodisp = 1;\n\n\t\tif (strstr(cmd, \"FINDCREATEDISPLAY\") == cmd) {\n\t\t\tcreate_cmd = build_create_cmd(cmd, &saw_xdmcp, usslpeer, tmp);\n\t\t\tif (db) fprintf(stderr, \"create_cmd: %s\\n\", create_cmd);\n\t\t}\n\t\tif (getenv(\"X11VNC_SKIP_DISPLAY\")) {\n\t\t\tnd = strdup(getenv(\"X11VNC_SKIP_DISPLAY\"));\n\t\t}\n\t\tcheck_nodisplay(&nd, &tag);\n\n\t\tfdout[0] = '\\0';\n\t\tif (getenv(\"FIND_DISPLAY_OUTPUT\")) {\n\t\t\tsnprintf(fdout, sizeof fdout, \" FIND_DISPLAY_OUTPUT='%s' \", getenv(\"FIND_DISPLAY_OUTPUT\"));\n\t\t}\n\n\t\tcmd = (char *) malloc(strlen(\"env X11VNC_SKIP_DISPLAY='' \")\n\t\t    + strlen(nd) + strlen(\" FD_TAG='' \") + strlen(tag) + strlen(tmp) + strlen(\"/bin/sh \") + strlen(fdout) + 1);\n\n\t\tif (strcmp(tag, \"\")) {\n\t\t\tsprintf(cmd, \"env X11VNC_SKIP_DISPLAY='%s' FD_TAG='%s' %s /bin/sh %s\", nd, tag, fdout, tmp);\n\t\t} else {\n\t\t\tsprintf(cmd, \"env X11VNC_SKIP_DISPLAY='%s' %s /bin/sh %s\", nd, fdout, tmp);\n\t\t}\n\t}\n\n\trfbLog(\"wait_for_client: running: %s\\n\", cmd);\n\n\tif (create_cmd != NULL) {\n\t\tif (strstr(create_cmd, \"Xvfb\")) {\n\t\t\tpath_lookup(\"Xvfb\");\n\t\t}\n\t\tif (strstr(create_cmd, \"Xvnc\")) {\n\t\t\tpath_lookup(\"Xvnc\");\n\t\t}\n\t\tif (strstr(create_cmd, \"Xdummy\")) {\n\t\t\tpath_lookup(\"Xdummy\");\n\t\t}\n\t}\n\n\tif (unixpw && !unixpw_nis) {\n\t\tint res = 0, k, j, i;\n\t\tchar line[18000];\n\n\t\tmemset(line, 0, sizeof(line));\n\n\t\tif (unixpw_system_greeter_active == 2) {\n\t\t\trfbLog(\"unixpw_system_greeter: forcing find display failure.\\n\");\n\t\t\tres = 0;\n\t\t} else if (keep_unixpw_user && keep_unixpw_pass) {\n\t\t\tn = sizeof(line);\n\t\t\tif (unixpw_cmd != NULL) {\n\t\t\t\tres = unixpw_cmd_run(keep_unixpw_user,\n\t\t\t\t    keep_unixpw_pass, cmd, line, &n);\n\t\t\t} else {\n\t\t\t\tres = su_verify(keep_unixpw_user,\n\t\t\t\t    keep_unixpw_pass, cmd, line, &n, nodisp);\n\t\t\t}\n\t\t}\n\nif (db) {fprintf(stderr, \"line: \"); write(2, line, n); write(2, \"\\n\", 1); fprintf(stderr, \"res=%d n=%d\\n\", res, n);}\n\t\tif (! res) {\n\t\t\trfbLog(\"wait_for_client: find display cmd failed.\\n\");\n\t\t}\n\n\t\tif (! res && create_cmd) {\n\t\t\tFILE *mt = fopen(tmp, \"w\");\n\t\t\tif (! mt) {\n\t\t\t\trfbLog(\"wait_for_client: open failed: %s\\n\", tmp);\n\t\t\t\trfbLogPerror(\"fopen\");\n\t\t\t\tclean_up_exit(1);\n\t\t\t}\n\t\t\tfprintf(mt, \"%s\", create_display);\n\t\t\tfclose(mt);\n\n\t\t\tfindcreatedisplay = 1;\n\n\t\t\tif (unixpw_cmd != NULL) {\n\t\t\t\t/* let the external unixpw command do it: */\n\t\t\t\tn = sizeof(line);\n\t\t\t\tclose_exec_fds();\n\t\t\t\tres = unixpw_cmd_run(keep_unixpw_user,\n\t\t\t\t    keep_unixpw_pass, create_cmd, line, &n);\n\t\t\t} else if (getuid() != 0 && unixpw_system_greeter_active != 2) {\n\t\t\t\t/* if not root, run as the other user... */\n\t\t\t\tn = sizeof(line);\n\t\t\t\tclose_exec_fds();\n\t\t\t\tres = su_verify(keep_unixpw_user,\n\t\t\t\t    keep_unixpw_pass, create_cmd, line, &n, nodisp);\nif (db) fprintf(stderr, \"c-res=%d n=%d line: '%s'\\n\", res, n, line);\n\n\t\t\t} else {\n\t\t\t\tFILE *p;\n\t\t\t\tclose_exec_fds();\n\t\t\t\tif (unixpw_system_greeter_active == 2) {\n\t\t\t\t\trfbLog(\"unixpw_system_greeter: not trying su_verify() to run\\n\");\n\t\t\t\t\trfbLog(\"unixpw_system_greeter: create display command.\\n\");\n\t\t\t\t}\n\t\t\t\trfbLog(\"wait_for_client: running: %s\\n\", create_cmd);\n\t\t\t\tp = popen(create_cmd, \"r\");\n\t\t\t\tif (! p) {\n\t\t\t\t\trfbLog(\"wait_for_client: popen failed: %s\\n\", create_cmd);\n\t\t\t\t\tres = 0;\n\t\t\t\t} else if (fgets(line1, sizeof line1, p) == NULL) {\n\t\t\t\t\trfbLog(\"wait_for_client: read failed: %s\\n\", create_cmd);\n\t\t\t\t\tres = 0;\n\t\t\t\t} else {\n\t\t\t\t\tn = fread(line2, 1, sizeof line2, p);\n\t\t\t\t\tif (pclose(p) != 0) {\n\t\t\t\t\t\tres = 0;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tstrncpy(line, line1, 100);\n\t\t\t\t\t\tmemcpy(line + strlen(line1), line2, n);\nif (db) fprintf(stderr, \"line1: '%s'\\n\", line1);\n\t\t\t\t\t\tn += strlen(line1);\n\t\t\t\t\t\tcreated_disp = 1;\n\t\t\t\t\t\tres = 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (res && saw_xdmcp && unixpw_system_greeter_active != 2) {\n\t\t\t\txdmcp_insert = strdup(keep_unixpw_user);\n\t\t\t}\n\t\t}\n\n\t\tif (tmp_fd >= 0) {\n\t\t\tunlink(tmp);\n\t\t}\n\n\t\tif (! res) {\n\t\t\trfbLog(\"wait_for_client: cmd failed: %s\\n\", cmd);\n\t\t\tunixpw_msg(\"No DISPLAY found.\", 3);\n\t\t\tclean_up_exit(1);\n\t\t}\n\n\t\t/*\n\t\t * we need to hunt for DISPLAY= since there may be\n\t\t * a login banner or something at the beginning.\n\t\t */\n\t\tq = strstr(line, \"DISPLAY=\");\n\t\tif (! q) {\n\t\t\tq = line;\n\t\t}\n\t\tn -= (q - line);\n\n\t\tfor (k = 0; k < 1024; k++) {\n\t\t\tline1[k] = q[k];\n\t\t\tif (q[k] == '\\n') {\n\t\t\t\tk++;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tn -= k;\n\t\ti = 0;\n\t\tfor (j = 0; j < 16384; j++) {\n\t\t\tif (j < 16384 - 1) {\n\t\t\t\t/* xauth data, assume pty added CR */\n\t\t\t\tif (q[k+j] == '\\r' && q[k+j+1] == '\\n') {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tline2[i] = q[k+j];\n\t\t\ti++;\n\t\t}\nif (db) write(2, line, 100);\nif (db) fprintf(stderr, \"\\n\");\n\n\t} else {\n\t\tFILE *p;\n\t\tint rc;\n\t\tclose_exec_fds();\n\n\t\tif (usslpeer) {\n\t\t\tchar *c;\n\t\t\tif (getuid() == 0) {\n\t\t\t\tc = (char *) malloc(strlen(\"su - '' -c \\\"\")\n\t\t\t\t    + strlen(usslpeer) + strlen(cmd) + 1 + 1);\n\t\t\t\tsprintf(c, \"su - '%s' -c \\\"%s\\\"\", usslpeer, cmd);\n\t\t\t} else {\n\t\t\t\tc = strdup(cmd);\n\t\t\t}\n\t\t\tp = popen(c, \"r\");\n\t\t\tfree(c);\n\t\t\t\n\t\t} else if (unixpw_nis && keep_unixpw_user) {\n\t\t\tchar *c;\n\t\t\tif (getuid() == 0) {\n\t\t\t\tc = (char *) malloc(strlen(\"su - '' -c \\\"\")\n\t\t\t\t    + strlen(keep_unixpw_user) + strlen(cmd) + 1 + 1);\n\t\t\t\tsprintf(c, \"su - '%s' -c \\\"%s\\\"\", keep_unixpw_user, cmd);\n\t\t\t} else {\n\t\t\t\tc = strdup(cmd);\n\t\t\t}\n\t\t\tp = popen(c, \"r\");\n\t\t\tfree(c);\n\t\t\t\n\t\t} else {\n\t\t\tp = popen(cmd, \"r\");\n\t\t}\n\n\t\tif (! p) {\n\t\t\trfbLog(\"wait_for_client: cmd failed: %s\\n\", cmd);\n\t\t\trfbLogPerror(\"popen\");\n\t\t\tif (tmp_fd >= 0) {\n\t\t\t\tunlink(tmp);\n\t\t\t}\n\t\t\tclean_up_exit(1);\n\t\t}\n\t\tif (fgets(line1, sizeof line1, p) == NULL) {\n\t\t\trfbLog(\"wait_for_client: read failed: %s\\n\", cmd);\n\t\t\trfbLogPerror(\"fgets\");\n\t\t\tif (tmp_fd >= 0) {\n\t\t\t\tunlink(tmp);\n\t\t\t}\n\t\t\tclean_up_exit(1);\n\t\t}\n\t\tn = fread(line2, 1, sizeof line2, p);\n\t\trc = pclose(p);\n\n\t\tif (rc != 0) {\n\t\t\trfbLog(\"wait_for_client: find display cmd failed.\\n\");\n\t\t}\n\n\t\tif (create_cmd && rc != 0) {\n\t\t\tFILE *mt = fopen(tmp, \"w\");\n\t\t\tif (! mt) {\n\t\t\t\trfbLog(\"wait_for_client: open failed: %s\\n\", tmp);\n\t\t\t\trfbLogPerror(\"fopen\");\n\t\t\t\tif (tmp_fd >= 0) {\n\t\t\t\t\tunlink(tmp);\n\t\t\t\t}\n\t\t\t\tclean_up_exit(1);\n\t\t\t}\n\t\t\tfprintf(mt, \"%s\", create_display);\n\t\t\tfclose(mt);\n\n\t\t\tfindcreatedisplay = 1;\n\n\t\t\trfbLog(\"wait_for_client: FINDCREATEDISPLAY cmd: %s\\n\", create_cmd);\n\n\t\t\tp = popen(create_cmd, \"r\");\n\t\t\tif (! p) {\n\t\t\t\trfbLog(\"wait_for_client: cmd failed: %s\\n\", create_cmd);\n\t\t\t\trfbLogPerror(\"popen\");\n\t\t\t\tif (tmp_fd >= 0) {\n\t\t\t\t\tunlink(tmp);\n\t\t\t\t}\n\t\t\t\tclean_up_exit(1);\n\t\t\t}\n\t\t\tif (fgets(line1, sizeof line1, p) == NULL) {\n\t\t\t\trfbLog(\"wait_for_client: read failed: %s\\n\", create_cmd);\n\t\t\t\trfbLogPerror(\"fgets\");\n\t\t\t\tif (tmp_fd >= 0) {\n\t\t\t\t\tunlink(tmp);\n\t\t\t\t}\n\t\t\t\tclean_up_exit(1);\n\t\t\t}\n\t\t\tn = fread(line2, 1, sizeof line2, p);\n\t\t\tpclose(p);\n\t\t}\n\t\tif (tmp_fd >= 0) {\n\t\t\tunlink(tmp);\n\t\t}\n\t}\n\nif (db) fprintf(stderr, \"line1=%s\\n\", line1);\n\n\tif (strstr(line1, \"DISPLAY=\") != line1) {\n\t\trfbLog(\"wait_for_client: bad reply '%s'\\n\", line1);\n\t\tif (unixpw) {\n\t\t\tunixpw_msg(\"No DISPLAY found.\", 3);\n\t\t}\n\t\tclean_up_exit(1);\n\t}\n\n\n\tif (strstr(line1, \",VT=\")) {\n\t\tint vt;\n\t\tchar *t = strstr(line1, \",VT=\");\n\t\tvt = atoi(t + strlen(\",VT=\"));\n\t\t*t = '\\0';\n\t\tif (7 <= vt && vt <= 15) {\n\t\t\tdo_chvt(vt);\n\t\t}\n\t} else if (strstr(line1, \",XPID=\")) {\n\t\tint i, pvt, vt = -1;\n\t\tchar *t = strstr(line1, \",XPID=\");\n\t\tpvt = atoi(t + strlen(\",XPID=\"));\n\t\t*t = '\\0';\n\t\tif (pvt > 0) {\n\t\t\tfor (i=3; i <= 10; i++) {\n\t\t\t\tint k;\n\t\t\t\tchar proc[100];\n\t\t\t\tchar buf[100];\n\t\t\t\tsprintf(proc, \"/proc/%d/fd/%d\", pvt, i);\nif (db) fprintf(stderr, \"%d -- %s\\n\", i, proc);\n\t\t\t\tfor (k=0; k < 100; k++) {\n\t\t\t\t\tbuf[k] = '\\0';\n\t\t\t\t}\n\t\n\t\t\t\tif (readlink(proc, buf, sizeof buf) != -1) {\n\t\t\t\t\tbuf[100-1] = '\\0';\nif (db) fprintf(stderr, \"%d -- %s -- %s\\n\", i, proc, buf);\n\t\t\t\t\tif (strstr(buf, \"/dev/tty\") == buf) {\n\t\t\t\t\t\tvt = atoi(buf + strlen(\"/dev/tty\"));\n\t\t\t\t\t\tif (vt > 0) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (7 <= vt && vt <= 12) {\n\t\t\tdo_chvt(vt);\n\t\t}\n\t}\n\n\tuse_dpy = strdup(line1 + strlen(\"DISPLAY=\"));\n\tq = use_dpy;\n\twhile (*q != '\\0') {\n\t\tif (*q == '\\n' || *q == '\\r') *q = '\\0';\n\t\tq++;\n\t}\n\tif (line2[0] != '\\0') {\n\t\tif (strstr(line2, \"XAUTHORITY=\") == line2) {\n\t\t\tq = line2;\n\t\t\twhile (*q != '\\0') {\n\t\t\t\tif (*q == '\\n' || *q == '\\r') *q = '\\0';\n\t\t\t\tq++;\n\t\t\t}\n\t\t\tif (auth_file) {\n\t\t\t\tfree(auth_file);\n\t\t\t}\n\t\t\tauth_file = strdup(line2 + strlen(\"XAUTHORITY=\"));\n\n\t\t} else {\n\t\t\txauth_raw_data = (char *)malloc(n);\n\t\t\txauth_raw_len = n;\n\t\t\tmemcpy(xauth_raw_data, line2, n);\nif (db) {fprintf(stderr, \"xauth_raw_len: %d\\n\", n);\nwrite(2, xauth_raw_data, n);\nfprintf(stderr, \"\\n\");}\n\t\t}\n\t}\n\n\tif (!tried_switch) {\n\t\tdo_try_switch(usslpeer, users_list_save);\n\t\ttried_switch = 1;\n\t}\n\n\tif (unixpw) {\n\t\t/* Some cleanup and messaging for -unixpw case: */\n\t\tchar str[32];\n\n\t\tif (keep_unixpw_user && keep_unixpw_pass) {\n\t\t\tstrzero(keep_unixpw_user);\n\t\t\tstrzero(keep_unixpw_pass);\n\t\t\tkeep_unixpw = 0;\n\t\t}\n\n\t\tif (created_disp) {\n\t\t\tsnprintf(str, sizeof str, \"Created DISPLAY %s\", use_dpy);\n\t\t} else {\n\t\t\tsnprintf(str, sizeof str, \"Using DISPLAY %s\", use_dpy);\n\t\t}\n\t\tunixpw_msg(str, 2);\n\t}\n\treturn 1;\n}",
    "includes": [
      "#include \"avahi.h\"",
      "#include \"sslhelper.h\"",
      "#include \"remote.h\"",
      "#include \"cursor.h\"",
      "#include \"keyboard.h\"",
      "#include \"inet.h\"",
      "#include \"connections.h\"",
      "#include \"xwrappers.h\"",
      "#include \"sslhelper.h\"",
      "#include \"unixpw.h\"",
      "#include \"screen.h\"",
      "#include \"scan.h\"",
      "#include \"cleanup.h\"",
      "#include \"solid.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "void lurk_loop(char *str);",
      "char *xdmcp_insert = NULL;",
      "extern char find_display[];",
      "extern char create_display[];"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "unixpw_msg",
          "args": [
            "str",
            "2"
          ],
          "line": 2882
        },
        "resolved": true,
        "details": {
          "function_name": "unixpw_msg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/unixpw.c",
          "lines": "2260-2281",
          "snippet": "void unixpw_msg(char *msg, int delay) {\n\tint x, y, i;\n\n\tchar_row += 2;\n\tchar_col = 0;\n\tx = char_x + char_col * char_w;\n\ty = char_y + char_row * char_h;\n\n\trfbDrawString(pscreen, &default8x16Font, x, y, msg, white_pixel());\n\tunixpw_mark();\n\n\tfor (i=0; i<5; i++) {\n\t\trfbPE(-1);\n\t\trfbPE(-1);\n\t\trfbPE(50 * 1000);\n\t\trfbPE(-1);\n\t\tusleep(500 * 1000);\n\t\tif (i >= delay) {\n\t\t\tbreak;\n\t\t}\n\t}\n}",
          "includes": [
            "#include <sys/stropts.h>",
            "#include <termios.h>",
            "#include <sys/ioctl.h>",
            "#include <shadow.h>",
            "#include \"default8x16.h\"",
            "#include \"rates.h\"",
            "#include \"cursor.h\"",
            "#include \"sslhelper.h\"",
            "#include \"connections.h\"",
            "#include \"user.h\"",
            "#include \"connections.h\"",
            "#include \"xinerama.h\"",
            "#include \"cleanup.h\"",
            "#include \"scan.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int white_pixel(void);",
            "void unixpw_msg(char *msg, int delay);",
            "static int char_row = 0, char_col = 0;",
            "static int char_x = 0, char_y = 0, char_w = 8, char_h = 16;",
            "static rfbScreenInfoPtr pscreen;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/stropts.h>\n#include <termios.h>\n#include <sys/ioctl.h>\n#include <shadow.h>\n#include \"default8x16.h\"\n#include \"rates.h\"\n#include \"cursor.h\"\n#include \"sslhelper.h\"\n#include \"connections.h\"\n#include \"user.h\"\n#include \"connections.h\"\n#include \"xinerama.h\"\n#include \"cleanup.h\"\n#include \"scan.h\"\n#include \"x11vnc.h\"\n\nint white_pixel(void);\nvoid unixpw_msg(char *msg, int delay);\nstatic int char_row = 0, char_col = 0;\nstatic int char_x = 0, char_y = 0, char_w = 8, char_h = 16;\nstatic rfbScreenInfoPtr pscreen;\n\nvoid unixpw_msg(char *msg, int delay) {\n\tint x, y, i;\n\n\tchar_row += 2;\n\tchar_col = 0;\n\tx = char_x + char_col * char_w;\n\ty = char_y + char_row * char_h;\n\n\trfbDrawString(pscreen, &default8x16Font, x, y, msg, white_pixel());\n\tunixpw_mark();\n\n\tfor (i=0; i<5; i++) {\n\t\trfbPE(-1);\n\t\trfbPE(-1);\n\t\trfbPE(50 * 1000);\n\t\trfbPE(-1);\n\t\tusleep(500 * 1000);\n\t\tif (i >= delay) {\n\t\t\tbreak;\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "str",
            "sizeof str",
            "\"Using DISPLAY %s\"",
            "use_dpy"
          ],
          "line": 2880
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "str",
            "sizeof str",
            "\"Created DISPLAY %s\"",
            "use_dpy"
          ],
          "line": 2878
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strzero",
          "args": [
            "keep_unixpw_pass"
          ],
          "line": 2873
        },
        "resolved": true,
        "details": {
          "function_name": "strzero",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/util.c",
          "lines": "171-179",
          "snippet": "void strzero(char *str) {\n\tchar *p = str;\n\tif (p != NULL) {\n\t\twhile (*p != '\\0') {\n\t\t\t*p = '\\0';\n\t\t\tp++;\n\t\t}\n\t}\n}",
          "includes": [
            "#include \"connections.h\"",
            "#include \"unixpw.h\"",
            "#include \"win_utils.h\"",
            "#include \"cleanup.h\"",
            "#include \"x11vnc.h\"",
            "#include <stdlib.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void lowercase(char *str);",
            "void uppercase(char *str);",
            "char *lblanks(char *str);",
            "void strzero(char *str);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"connections.h\"\n#include \"unixpw.h\"\n#include \"win_utils.h\"\n#include \"cleanup.h\"\n#include \"x11vnc.h\"\n#include <stdlib.h>\n\nvoid lowercase(char *str);\nvoid uppercase(char *str);\nchar *lblanks(char *str);\nvoid strzero(char *str);\n\nvoid strzero(char *str) {\n\tchar *p = str;\n\tif (p != NULL) {\n\t\twhile (*p != '\\0') {\n\t\t\t*p = '\\0';\n\t\t\tp++;\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "do_try_switch",
          "args": [
            "usslpeer",
            "users_list_save"
          ],
          "line": 2863
        },
        "resolved": true,
        "details": {
          "function_name": "do_try_switch",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/user.c",
          "lines": "2376-2422",
          "snippet": "static void do_try_switch(char *usslpeer, char *users_list_save) {\n\tif (unixpw_system_greeter_active == 2) {\n\t\trfbLog(\"unixpw_system_greeter: not trying switch to user '%s'\\n\", usslpeer ? usslpeer : \"\");\n\t\treturn;\n\t}\n\tif (usslpeer) {\n\t\tchar *u = (char *) malloc(strlen(usslpeer+2));\n\t\tsprintf(u, \"+%s\", usslpeer);\n\t\tif (switch_user(u, 0)) {\n\t\t\trfbLog(\"sslpeer switched to user: %s\\n\", usslpeer);\n\t\t} else {\n\t\t\trfbLog(\"sslpeer failed to switch to user: %s\\n\", usslpeer);\n\t\t}\n\t\tfree(u);\n\t\t\n\t} else if (users_list_save && keep_unixpw_user) {\n\t\tchar *user = keep_unixpw_user;\n\t\tchar *u = (char *)malloc(strlen(user)+1); \n\n\t\tusers_list = users_list_save;\n\n\t\tu[0] = '\\0';\n\t\tif (!strcmp(users_list, \"unixpw=\")) {\n\t\t\tsprintf(u, \"+%s\", user);\n\t\t} else {\n\t\t\tchar *p, *str = strdup(users_list);\n\t\t\tp = strtok(str + strlen(\"unixpw=\"), \",\");\n\t\t\twhile (p) {\n\t\t\t\tif (!strcmp(p, user)) {\n\t\t\t\t\tsprintf(u, \"+%s\", user);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tp = strtok(NULL, \",\");\n\t\t\t}\n\t\t\tfree(str);\n\t\t}\n\t\t\n\t\tif (u[0] == '\\0') {\n\t\t\trfbLog(\"unixpw_accept skipping switch to user: %s (drc)\\n\", user);\n\t\t} else if (switch_user(u, 0)) {\n\t\t\trfbLog(\"unixpw_accept switched to user: %s (drc)\\n\", user);\n\t\t} else {\n\t\t\trfbLog(\"unixpw_accept failed to switch to user: %s (drc)\\n\", user);\n\t\t}\n\t\tfree(u);\n\t}\n}",
          "includes": [
            "#include \"avahi.h\"",
            "#include \"sslhelper.h\"",
            "#include \"remote.h\"",
            "#include \"cursor.h\"",
            "#include \"keyboard.h\"",
            "#include \"inet.h\"",
            "#include \"connections.h\"",
            "#include \"xwrappers.h\"",
            "#include \"sslhelper.h\"",
            "#include \"unixpw.h\"",
            "#include \"screen.h\"",
            "#include \"scan.h\"",
            "#include \"cleanup.h\"",
            "#include \"solid.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void lurk_loop(char *str);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"avahi.h\"\n#include \"sslhelper.h\"\n#include \"remote.h\"\n#include \"cursor.h\"\n#include \"keyboard.h\"\n#include \"inet.h\"\n#include \"connections.h\"\n#include \"xwrappers.h\"\n#include \"sslhelper.h\"\n#include \"unixpw.h\"\n#include \"screen.h\"\n#include \"scan.h\"\n#include \"cleanup.h\"\n#include \"solid.h\"\n#include \"x11vnc.h\"\n\nvoid lurk_loop(char *str);\n\nstatic void do_try_switch(char *usslpeer, char *users_list_save) {\n\tif (unixpw_system_greeter_active == 2) {\n\t\trfbLog(\"unixpw_system_greeter: not trying switch to user '%s'\\n\", usslpeer ? usslpeer : \"\");\n\t\treturn;\n\t}\n\tif (usslpeer) {\n\t\tchar *u = (char *) malloc(strlen(usslpeer+2));\n\t\tsprintf(u, \"+%s\", usslpeer);\n\t\tif (switch_user(u, 0)) {\n\t\t\trfbLog(\"sslpeer switched to user: %s\\n\", usslpeer);\n\t\t} else {\n\t\t\trfbLog(\"sslpeer failed to switch to user: %s\\n\", usslpeer);\n\t\t}\n\t\tfree(u);\n\t\t\n\t} else if (users_list_save && keep_unixpw_user) {\n\t\tchar *user = keep_unixpw_user;\n\t\tchar *u = (char *)malloc(strlen(user)+1); \n\n\t\tusers_list = users_list_save;\n\n\t\tu[0] = '\\0';\n\t\tif (!strcmp(users_list, \"unixpw=\")) {\n\t\t\tsprintf(u, \"+%s\", user);\n\t\t} else {\n\t\t\tchar *p, *str = strdup(users_list);\n\t\t\tp = strtok(str + strlen(\"unixpw=\"), \",\");\n\t\t\twhile (p) {\n\t\t\t\tif (!strcmp(p, user)) {\n\t\t\t\t\tsprintf(u, \"+%s\", user);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tp = strtok(NULL, \",\");\n\t\t\t}\n\t\t\tfree(str);\n\t\t}\n\t\t\n\t\tif (u[0] == '\\0') {\n\t\t\trfbLog(\"unixpw_accept skipping switch to user: %s (drc)\\n\", user);\n\t\t} else if (switch_user(u, 0)) {\n\t\t\trfbLog(\"unixpw_accept switched to user: %s (drc)\\n\", user);\n\t\t} else {\n\t\t\trfbLog(\"unixpw_accept failed to switch to user: %s (drc)\\n\", user);\n\t\t}\n\t\tfree(u);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"\\n\""
          ],
          "line": 2858
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "write",
          "args": [
            "2",
            "xauth_raw_data",
            "n"
          ],
          "line": 2857
        },
        "resolved": true,
        "details": {
          "function_name": "write_exact",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/sslhelper.c",
          "lines": "1319-1344",
          "snippet": "static int write_exact(int sock, char *buf, int len) {\n\tint n, fail = 0;\n\tif (sock < 0) {\n\t\treturn 0;\n\t}\n\twhile (len > 0) {\n\t\tn = write(sock, buf, len);\n\t\tif (n > 0) {\n\t\t\tbuf += n;\n\t\t\tlen -= n;\n\t\t} else if (n == 0) {\n\t\t\tfail = 1;\n\t\t\tbreak;\n\t\t} else if (n < 0 && (errno == EAGAIN || errno == EWOULDBLOCK)) {\n\t\t\tusleep(10*1000);\n\t\t} else if (n < 0 && errno != EINTR) {\n\t\t\tfail = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (fail) {\n\t\treturn 0;\n\t} else {\n\t\treturn 1;\n\t}\n}",
          "includes": [
            "#include <openssl/rand.h>",
            "#include <openssl/err.h>",
            "#include <openssl/ssl.h>",
            "#include \"user.h\"",
            "#include \"unixpw.h\"",
            "#include \"sslcmds.h\"",
            "#include \"connections.h\"",
            "#include \"scan.h\"",
            "#include \"screen.h\"",
            "#include \"cleanup.h\"",
            "#include \"inet.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void ssl_helper_pid(pid_t pid, int sock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <openssl/rand.h>\n#include <openssl/err.h>\n#include <openssl/ssl.h>\n#include \"user.h\"\n#include \"unixpw.h\"\n#include \"sslcmds.h\"\n#include \"connections.h\"\n#include \"scan.h\"\n#include \"screen.h\"\n#include \"cleanup.h\"\n#include \"inet.h\"\n#include \"x11vnc.h\"\n\nvoid ssl_helper_pid(pid_t pid, int sock);\n\nstatic int write_exact(int sock, char *buf, int len) {\n\tint n, fail = 0;\n\tif (sock < 0) {\n\t\treturn 0;\n\t}\n\twhile (len > 0) {\n\t\tn = write(sock, buf, len);\n\t\tif (n > 0) {\n\t\t\tbuf += n;\n\t\t\tlen -= n;\n\t\t} else if (n == 0) {\n\t\t\tfail = 1;\n\t\t\tbreak;\n\t\t} else if (n < 0 && (errno == EAGAIN || errno == EWOULDBLOCK)) {\n\t\t\tusleep(10*1000);\n\t\t} else if (n < 0 && errno != EINTR) {\n\t\t\tfail = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (fail) {\n\t\treturn 0;\n\t} else {\n\t\treturn 1;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"xauth_raw_len: %d\\n\"",
            "n"
          ],
          "line": 2856
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "xauth_raw_data",
            "line2",
            "n"
          ],
          "line": 2855
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "n"
          ],
          "line": 2853
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "line2 + strlen(\"XAUTHORITY=\")"
          ],
          "line": 2850
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "\"XAUTHORITY=\""
          ],
          "line": 2850
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "auth_file"
          ],
          "line": 2848
        },
        "resolved": true,
        "details": {
          "function_name": "free_rect",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/userinput.c",
          "lines": "6200-6247",
          "snippet": "int free_rect(int idx) {\n\tint n, ok = 0;\n\tsraRegionPtr r1, r2;\n\tint x, y, w, h;\n\n\tif (idx < 0 || idx >= cache_list_num) {\nif (0) fprintf(stderr, \"free_rect: bad index: %d\\n\", idx);\n\t\tclean_up_exit(1);\n\t}\n\n\tx = cache_list[idx].bs_x;\n\ty = cache_list[idx].bs_y;\n\tw = cache_list[idx].bs_w;\n\th = cache_list[idx].bs_h;\n\n\tif (x < 0) {\n\t\tCLEAR(idx);\nif (dnow() > last_client + 5 && ncdb) fprintf(stderr, \"free_rect: already bs_x invalidated: %d bs_x: %d\\n\", idx, x);\n\t\treturn 1;\n\t}\n\n\tr2 = sraRgnCreateRect(x, y, x+w, y+h);\n\n\tn = get_bs_n(y);\n\tif (n >= 0) {\n\t\tr1 = rect_reg[n];\n\t\tsraRgnOr(r1, r2);\n\t\tok = 1;\n\t}\n\n\tif (zero_rects) {\n\t\tsraRgnOr(zero_rects, r2);\n\t\tx = cache_list[idx].su_x;\n\t\ty = cache_list[idx].su_y;\n\t\tw = cache_list[idx].su_w;\n\t\th = cache_list[idx].su_h;\n\t\tif (x >= 0) {\n\t\t\tsraRgnDestroy(r2);\n\t\t\tr2 = sraRgnCreateRect(x, y, x+w, y+h);\n\t\t\tsraRgnOr(zero_rects, r2);\n\t\t}\n\t}\n\tsraRgnDestroy(r2);\n\n\tCLEAR(idx);\nif (! ok && ncdb) fprintf(stderr, \"**** free_rect: not-found %d\\n\", idx);\n\treturn ok;\n}",
          "includes": [
            "#include \"default8x16.h\"",
            "#include \"connections.h\"",
            "#include \"screen.h\"",
            "#include \"cursor.h\"",
            "#include \"macosxCGS.h\"",
            "#include \"macosx.h\"",
            "#include \"unixpw.h\"",
            "#include \"8to24.h\"",
            "#include \"xrandr.h\"",
            "#include \"solid.h\"",
            "#include \"keyboard.h\"",
            "#include \"rates.h\"",
            "#include \"pointer.h\"",
            "#include \"cleanup.h\"",
            "#include \"scan.h\"",
            "#include \"user.h\"",
            "#include \"xevents.h\"",
            "#include \"win_utils.h\"",
            "#include \"xinerama.h\"",
            "#include \"xrecord.h\"",
            "#include \"xdamage.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void mark_for_xdamage(int x, int y, int w, int h);",
            "void set_xdamage_mark(int x, int y, int w, int h);",
            "int find_rect(int idx, int x, int y, int w, int h);",
            "winattr_t *cache_list;",
            "int clipped(int idx);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"default8x16.h\"\n#include \"connections.h\"\n#include \"screen.h\"\n#include \"cursor.h\"\n#include \"macosxCGS.h\"\n#include \"macosx.h\"\n#include \"unixpw.h\"\n#include \"8to24.h\"\n#include \"xrandr.h\"\n#include \"solid.h\"\n#include \"keyboard.h\"\n#include \"rates.h\"\n#include \"pointer.h\"\n#include \"cleanup.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"xevents.h\"\n#include \"win_utils.h\"\n#include \"xinerama.h\"\n#include \"xrecord.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nvoid mark_for_xdamage(int x, int y, int w, int h);\nvoid set_xdamage_mark(int x, int y, int w, int h);\nint find_rect(int idx, int x, int y, int w, int h);\nwinattr_t *cache_list;\nint clipped(int idx);\n\nint free_rect(int idx) {\n\tint n, ok = 0;\n\tsraRegionPtr r1, r2;\n\tint x, y, w, h;\n\n\tif (idx < 0 || idx >= cache_list_num) {\nif (0) fprintf(stderr, \"free_rect: bad index: %d\\n\", idx);\n\t\tclean_up_exit(1);\n\t}\n\n\tx = cache_list[idx].bs_x;\n\ty = cache_list[idx].bs_y;\n\tw = cache_list[idx].bs_w;\n\th = cache_list[idx].bs_h;\n\n\tif (x < 0) {\n\t\tCLEAR(idx);\nif (dnow() > last_client + 5 && ncdb) fprintf(stderr, \"free_rect: already bs_x invalidated: %d bs_x: %d\\n\", idx, x);\n\t\treturn 1;\n\t}\n\n\tr2 = sraRgnCreateRect(x, y, x+w, y+h);\n\n\tn = get_bs_n(y);\n\tif (n >= 0) {\n\t\tr1 = rect_reg[n];\n\t\tsraRgnOr(r1, r2);\n\t\tok = 1;\n\t}\n\n\tif (zero_rects) {\n\t\tsraRgnOr(zero_rects, r2);\n\t\tx = cache_list[idx].su_x;\n\t\ty = cache_list[idx].su_y;\n\t\tw = cache_list[idx].su_w;\n\t\th = cache_list[idx].su_h;\n\t\tif (x >= 0) {\n\t\t\tsraRgnDestroy(r2);\n\t\t\tr2 = sraRgnCreateRect(x, y, x+w, y+h);\n\t\t\tsraRgnOr(zero_rects, r2);\n\t\t}\n\t}\n\tsraRgnDestroy(r2);\n\n\tCLEAR(idx);\nif (! ok && ncdb) fprintf(stderr, \"**** free_rect: not-found %d\\n\", idx);\n\treturn ok;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "line2",
            "\"XAUTHORITY=\""
          ],
          "line": 2841
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "line1 + strlen(\"DISPLAY=\")"
          ],
          "line": 2834
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "\"DISPLAY=\""
          ],
          "line": 2834
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "do_chvt",
          "args": [
            "vt"
          ],
          "line": 2830
        },
        "resolved": true,
        "details": {
          "function_name": "do_chvt",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/user.c",
          "lines": "1401-1407",
          "snippet": "static void do_chvt(int vt) {\n\tchar chvt[100];\n\tsprintf(chvt, \"chvt %d >/dev/null 2>/dev/null &\", vt);\n\trfbLog(\"running: %s\\n\", chvt);\n\tsystem(chvt);\n\tsleep(2);\n}",
          "includes": [
            "#include \"avahi.h\"",
            "#include \"sslhelper.h\"",
            "#include \"remote.h\"",
            "#include \"cursor.h\"",
            "#include \"keyboard.h\"",
            "#include \"inet.h\"",
            "#include \"connections.h\"",
            "#include \"xwrappers.h\"",
            "#include \"sslhelper.h\"",
            "#include \"unixpw.h\"",
            "#include \"screen.h\"",
            "#include \"scan.h\"",
            "#include \"cleanup.h\"",
            "#include \"solid.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"avahi.h\"\n#include \"sslhelper.h\"\n#include \"remote.h\"\n#include \"cursor.h\"\n#include \"keyboard.h\"\n#include \"inet.h\"\n#include \"connections.h\"\n#include \"xwrappers.h\"\n#include \"sslhelper.h\"\n#include \"unixpw.h\"\n#include \"screen.h\"\n#include \"scan.h\"\n#include \"cleanup.h\"\n#include \"solid.h\"\n#include \"x11vnc.h\"\n\nstatic void do_chvt(int vt) {\n\tchar chvt[100];\n\tsprintf(chvt, \"chvt %d >/dev/null 2>/dev/null &\", vt);\n\trfbLog(\"running: %s\\n\", chvt);\n\tsystem(chvt);\n\tsleep(2);\n}"
        }
      },
      {
        "call_info": {
          "callee": "atoi",
          "args": [
            "buf + strlen(\"/dev/tty\")"
          ],
          "line": 2821
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "\"/dev/tty\""
          ],
          "line": 2821
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "buf",
            "\"/dev/tty\""
          ],
          "line": 2820
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"%d -- %s -- %s\\n\"",
            "i",
            "proc",
            "buf"
          ],
          "line": 2819
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "readlink",
          "args": [
            "proc",
            "buf",
            "sizeof buf"
          ],
          "line": 2817
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"%d -- %s\\n\"",
            "i",
            "proc"
          ],
          "line": 2812
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "proc",
            "\"/proc/%d/fd/%d\"",
            "pvt",
            "i"
          ],
          "line": 2811
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atoi",
          "args": [
            "t + strlen(\",XPID=\")"
          ],
          "line": 2804
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "\",XPID=\""
          ],
          "line": 2804
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "line1",
            "\",XPID=\""
          ],
          "line": 2803
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "line1",
            "\",XPID=\""
          ],
          "line": 2801
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atoi",
          "args": [
            "t + strlen(\",VT=\")"
          ],
          "line": 2796
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "\",VT=\""
          ],
          "line": 2796
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "line1",
            "\",VT=\""
          ],
          "line": 2795
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "line1",
            "\",VT=\""
          ],
          "line": 2793
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clean_up_exit",
          "args": [
            "1"
          ],
          "line": 2789
        },
        "resolved": true,
        "details": {
          "function_name": "clean_up_exit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/cleanup.c",
          "lines": "151-266",
          "snippet": "void clean_up_exit(int ret) {\n\tstatic int depth = 0;\n\texit_flag = 1;\n\n\tif (depth++ > 2) {\n\t\texit(ret);\n\t}\n\n\tif (icon_mode) {\n\t\tclean_icon_mode();\n\t}\n\n\t/* remove the shm areas: */\n\tclean_shm(0);\n\n\tstop_stunnel();\n\tif (use_openssl) {\n\t\tssl_helper_pid(0, 0);\t/* killall */\n\t}\n\n\tif (ssh_pid > 0) {\n\t\tkill(ssh_pid, SIGTERM);\n\t\tssh_pid = 0;\n\t}\n\n#ifdef MACOSX\n\tif (client_connect_file) {\n\t\tif (strstr(client_connect_file, \"/tmp/x11vnc-macosx-remote\")\n\t\t    == client_connect_file) {\n\t\t\tunlink(client_connect_file);\n\t\t}\n\t}\n\tif (macosx_console) {\n\t\tmacosxCG_fini();\n\t}\n#endif\n\n\tif (pipeinput_fh != NULL) {\n\t\tpclose(pipeinput_fh);\n\t\tpipeinput_fh = NULL;\n\t}\n\n\tshutdown_uinput();\n\n\tif (unix_sock) {\n\t\tif (unix_sock_fd >= 0) {\n\t\t\trfbLog(\"deleting unix sock: %s\\n\", unix_sock);\n\t\t\tclose(unix_sock_fd);\n\t\t\tunix_sock_fd = -1;\n\t\t\tunlink(unix_sock);\n\t\t}\n\t}\n\n\tif (! dpy) {\t/* raw_rb hack */\n\t\tif (rm_flagfile) {\n\t\t\tunlink(rm_flagfile);\n\t\t\trm_flagfile = NULL;\n\t\t}\n\t\texit(ret);\n\t}\n\n\t/* X keyboard cleanups */\n\tdelete_added_keycodes(0);\n\n\t/* remove all created XInput2 devices */\n\tif(use_multipointer)\n\t    removeAllMDs(dpy);\n\n\tif (clear_mods == 1) {\n\t\tclear_modifiers(0);\n\t} else if (clear_mods == 2) {\n\t\tclear_keys();\n\t} else if (clear_mods == 3) {\n\t\tclear_keys();\n\t\tclear_locks();\n\t}\n\n\tif (no_autorepeat) {\n\t\tautorepeat(1, 0);\n\t}\n\tif (use_solid_bg) {\n\t\tsolid_bg(1);\n\t}\n\tif (ncache || ncache0) {\n\t\tkde_no_animate(1);\n\t}\n\tX_LOCK;\n\tXTestDiscard_wr(dpy);\n#if HAVE_LIBXDAMAGE\n\tif (xdamage) {\n\t\tXDamageDestroy(dpy, xdamage);\n\t}\n#endif\n#if HAVE_LIBXTRAP\n\tif (trap_ctx) {\n\t\tXEFreeTC(trap_ctx);\n\t}\n#endif\n\t/* XXX rdpy_ctrl, etc. cannot close w/o blocking */\n\tXCloseDisplay_wr(dpy);\n\tX_UNLOCK;\n\n\tfflush(stderr);\n\n\tif (rm_flagfile) {\n\t\tunlink(rm_flagfile);\n\t\trm_flagfile = NULL;\n\t}\n\n\tif (avahi) {\n\t\tavahi_cleanup();\n\t\tfflush(stderr);\n\t}\n\n\texit(ret);\n}",
          "includes": [
            "#include \"xi2_devices.h\"",
            "#include \"uinput.h\"",
            "#include \"xevents.h\"",
            "#include \"xrecord.h\"",
            "#include \"screen.h\"",
            "#include \"avahi.h\"",
            "#include \"macosxCG.h\"",
            "#include \"macosx.h\"",
            "#include \"connections.h\"",
            "#include \"sslhelper.h\"",
            "#include \"sslcmds.h\"",
            "#include \"unixpw.h\"",
            "#include \"solid.h\"",
            "#include \"gui.h\"",
            "#include \"scan.h\"",
            "#include \"keyboard.h\"",
            "#include \"remote.h\"",
            "#include \"xdamage.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void clean_up_exit(int ret);",
            "int known_sigpipe_mode(char *s);",
            "static int exit_flag = 0;",
            "static void clean_icon_mode(void);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xi2_devices.h\"\n#include \"uinput.h\"\n#include \"xevents.h\"\n#include \"xrecord.h\"\n#include \"screen.h\"\n#include \"avahi.h\"\n#include \"macosxCG.h\"\n#include \"macosx.h\"\n#include \"connections.h\"\n#include \"sslhelper.h\"\n#include \"sslcmds.h\"\n#include \"unixpw.h\"\n#include \"solid.h\"\n#include \"gui.h\"\n#include \"scan.h\"\n#include \"keyboard.h\"\n#include \"remote.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nvoid clean_up_exit(int ret);\nint known_sigpipe_mode(char *s);\nstatic int exit_flag = 0;\nstatic void clean_icon_mode(void);\n\nvoid clean_up_exit(int ret) {\n\tstatic int depth = 0;\n\texit_flag = 1;\n\n\tif (depth++ > 2) {\n\t\texit(ret);\n\t}\n\n\tif (icon_mode) {\n\t\tclean_icon_mode();\n\t}\n\n\t/* remove the shm areas: */\n\tclean_shm(0);\n\n\tstop_stunnel();\n\tif (use_openssl) {\n\t\tssl_helper_pid(0, 0);\t/* killall */\n\t}\n\n\tif (ssh_pid > 0) {\n\t\tkill(ssh_pid, SIGTERM);\n\t\tssh_pid = 0;\n\t}\n\n#ifdef MACOSX\n\tif (client_connect_file) {\n\t\tif (strstr(client_connect_file, \"/tmp/x11vnc-macosx-remote\")\n\t\t    == client_connect_file) {\n\t\t\tunlink(client_connect_file);\n\t\t}\n\t}\n\tif (macosx_console) {\n\t\tmacosxCG_fini();\n\t}\n#endif\n\n\tif (pipeinput_fh != NULL) {\n\t\tpclose(pipeinput_fh);\n\t\tpipeinput_fh = NULL;\n\t}\n\n\tshutdown_uinput();\n\n\tif (unix_sock) {\n\t\tif (unix_sock_fd >= 0) {\n\t\t\trfbLog(\"deleting unix sock: %s\\n\", unix_sock);\n\t\t\tclose(unix_sock_fd);\n\t\t\tunix_sock_fd = -1;\n\t\t\tunlink(unix_sock);\n\t\t}\n\t}\n\n\tif (! dpy) {\t/* raw_rb hack */\n\t\tif (rm_flagfile) {\n\t\t\tunlink(rm_flagfile);\n\t\t\trm_flagfile = NULL;\n\t\t}\n\t\texit(ret);\n\t}\n\n\t/* X keyboard cleanups */\n\tdelete_added_keycodes(0);\n\n\t/* remove all created XInput2 devices */\n\tif(use_multipointer)\n\t    removeAllMDs(dpy);\n\n\tif (clear_mods == 1) {\n\t\tclear_modifiers(0);\n\t} else if (clear_mods == 2) {\n\t\tclear_keys();\n\t} else if (clear_mods == 3) {\n\t\tclear_keys();\n\t\tclear_locks();\n\t}\n\n\tif (no_autorepeat) {\n\t\tautorepeat(1, 0);\n\t}\n\tif (use_solid_bg) {\n\t\tsolid_bg(1);\n\t}\n\tif (ncache || ncache0) {\n\t\tkde_no_animate(1);\n\t}\n\tX_LOCK;\n\tXTestDiscard_wr(dpy);\n#if HAVE_LIBXDAMAGE\n\tif (xdamage) {\n\t\tXDamageDestroy(dpy, xdamage);\n\t}\n#endif\n#if HAVE_LIBXTRAP\n\tif (trap_ctx) {\n\t\tXEFreeTC(trap_ctx);\n\t}\n#endif\n\t/* XXX rdpy_ctrl, etc. cannot close w/o blocking */\n\tXCloseDisplay_wr(dpy);\n\tX_UNLOCK;\n\n\tfflush(stderr);\n\n\tif (rm_flagfile) {\n\t\tunlink(rm_flagfile);\n\t\trm_flagfile = NULL;\n\t}\n\n\tif (avahi) {\n\t\tavahi_cleanup();\n\t\tfflush(stderr);\n\t}\n\n\texit(ret);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"wait_for_client: bad reply '%s'\\n\"",
            "line1"
          ],
          "line": 2785
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "line1",
            "\"DISPLAY=\""
          ],
          "line": 2784
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"line1=%s\\n\"",
            "line1"
          ],
          "line": 2782
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlink",
          "args": [
            "tmp"
          ],
          "line": 2778
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pclose",
          "args": [
            "p"
          ],
          "line": 2775
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fread",
          "args": [
            "line2",
            "1",
            "sizeof line2",
            "p"
          ],
          "line": 2774
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlink",
          "args": [
            "tmp"
          ],
          "line": 2770
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLogPerror",
          "args": [
            "\"fgets\""
          ],
          "line": 2768
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"wait_for_client: read failed: %s\\n\"",
            "create_cmd"
          ],
          "line": 2767
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fgets",
          "args": [
            "line1",
            "sizeof line1",
            "p"
          ],
          "line": 2766
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlink",
          "args": [
            "tmp"
          ],
          "line": 2762
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLogPerror",
          "args": [
            "\"popen\""
          ],
          "line": 2760
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"wait_for_client: cmd failed: %s\\n\"",
            "create_cmd"
          ],
          "line": 2759
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "popen",
          "args": [
            "create_cmd",
            "\"r\""
          ],
          "line": 2757
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"wait_for_client: FINDCREATEDISPLAY cmd: %s\\n\"",
            "create_cmd"
          ],
          "line": 2755
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fclose",
          "args": [
            "mt"
          ],
          "line": 2751
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "mt",
            "\"%s\"",
            "create_display"
          ],
          "line": 2750
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlink",
          "args": [
            "tmp"
          ],
          "line": 2746
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLogPerror",
          "args": [
            "\"fopen\""
          ],
          "line": 2744
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"wait_for_client: open failed: %s\\n\"",
            "tmp"
          ],
          "line": 2743
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fopen",
          "args": [
            "tmp",
            "\"w\""
          ],
          "line": 2741
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"wait_for_client: find display cmd failed.\\n\""
          ],
          "line": 2737
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pclose",
          "args": [
            "p"
          ],
          "line": 2734
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fread",
          "args": [
            "line2",
            "1",
            "sizeof line2",
            "p"
          ],
          "line": 2733
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlink",
          "args": [
            "tmp"
          ],
          "line": 2729
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLogPerror",
          "args": [
            "\"fgets\""
          ],
          "line": 2727
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"wait_for_client: read failed: %s\\n\"",
            "cmd"
          ],
          "line": 2726
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fgets",
          "args": [
            "line1",
            "sizeof line1",
            "p"
          ],
          "line": 2725
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlink",
          "args": [
            "tmp"
          ],
          "line": 2721
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLogPerror",
          "args": [
            "\"popen\""
          ],
          "line": 2719
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"wait_for_client: cmd failed: %s\\n\"",
            "cmd"
          ],
          "line": 2718
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "popen",
          "args": [
            "cmd",
            "\"r\""
          ],
          "line": 2714
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "popen",
          "args": [
            "c",
            "\"r\""
          ],
          "line": 2710
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "cmd"
          ],
          "line": 2708
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "c",
            "\"su - '%s' -c \\\"%s\\\"\"",
            "keep_unixpw_user",
            "cmd"
          ],
          "line": 2706
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "strlen(\"su - '' -c \\\"\")\n\t\t\t\t    + strlen(keep_unixpw_user) + strlen(cmd) + 1 + 1"
          ],
          "line": 2704
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "cmd"
          ],
          "line": 2705
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "keep_unixpw_user"
          ],
          "line": 2705
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "\"su - '' -c \\\"\""
          ],
          "line": 2704
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getuid",
          "args": [],
          "line": 2703
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "popen",
          "args": [
            "c",
            "\"r\""
          ],
          "line": 2698
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "cmd"
          ],
          "line": 2696
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "c",
            "\"su - '%s' -c \\\"%s\\\"\"",
            "usslpeer",
            "cmd"
          ],
          "line": 2694
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "strlen(\"su - '' -c \\\"\")\n\t\t\t\t    + strlen(usslpeer) + strlen(cmd) + 1 + 1"
          ],
          "line": 2692
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "cmd"
          ],
          "line": 2693
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "usslpeer"
          ],
          "line": 2693
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "\"su - '' -c \\\"\""
          ],
          "line": 2692
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getuid",
          "args": [],
          "line": 2691
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "close_exec_fds",
          "args": [],
          "line": 2687
        },
        "resolved": true,
        "details": {
          "function_name": "close_exec_fds",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/cleanup.c",
          "lines": "754-765",
          "snippet": "void close_exec_fds(void) {\n\tint fd;\n#ifdef FD_CLOEXEC\n\tfor (fd = 3; fd < 64; fd++) {\n\t\tint flags = fcntl(fd, F_GETFD);\n\t\tif (flags != -1) {\n\t\t\tflags |= FD_CLOEXEC;\n\t\t\tfcntl(fd, F_SETFD, flags);\n\t\t}\n\t}\n#endif\n}",
          "includes": [
            "#include \"xi2_devices.h\"",
            "#include \"uinput.h\"",
            "#include \"xevents.h\"",
            "#include \"xrecord.h\"",
            "#include \"screen.h\"",
            "#include \"avahi.h\"",
            "#include \"macosxCG.h\"",
            "#include \"macosx.h\"",
            "#include \"connections.h\"",
            "#include \"sslhelper.h\"",
            "#include \"sslcmds.h\"",
            "#include \"unixpw.h\"",
            "#include \"solid.h\"",
            "#include \"gui.h\"",
            "#include \"scan.h\"",
            "#include \"keyboard.h\"",
            "#include \"remote.h\"",
            "#include \"xdamage.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void close_exec_fds(void);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xi2_devices.h\"\n#include \"uinput.h\"\n#include \"xevents.h\"\n#include \"xrecord.h\"\n#include \"screen.h\"\n#include \"avahi.h\"\n#include \"macosxCG.h\"\n#include \"macosx.h\"\n#include \"connections.h\"\n#include \"sslhelper.h\"\n#include \"sslcmds.h\"\n#include \"unixpw.h\"\n#include \"solid.h\"\n#include \"gui.h\"\n#include \"scan.h\"\n#include \"keyboard.h\"\n#include \"remote.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nvoid close_exec_fds(void);\n\nvoid close_exec_fds(void) {\n\tint fd;\n#ifdef FD_CLOEXEC\n\tfor (fd = 3; fd < 64; fd++) {\n\t\tint flags = fcntl(fd, F_GETFD);\n\t\tif (flags != -1) {\n\t\t\tflags |= FD_CLOEXEC;\n\t\t\tfcntl(fd, F_SETFD, flags);\n\t\t}\n\t}\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"\\n\""
          ],
          "line": 2682
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "line",
            "\"DISPLAY=\""
          ],
          "line": 2655
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"wait_for_client: cmd failed: %s\\n\"",
            "cmd"
          ],
          "line": 2646
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlink",
          "args": [
            "tmp"
          ],
          "line": 2642
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "keep_unixpw_user"
          ],
          "line": 2637
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "line1"
          ],
          "line": 2630
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"line1: '%s'\\n\"",
            "line1"
          ],
          "line": 2629
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "line + strlen(line1)",
            "line2",
            "n"
          ],
          "line": 2628
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "line1"
          ],
          "line": 2628
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncpy",
          "args": [
            "line",
            "line1",
            "100"
          ],
          "line": 2627
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pclose",
          "args": [
            "p"
          ],
          "line": 2624
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fread",
          "args": [
            "line2",
            "1",
            "sizeof line2",
            "p"
          ],
          "line": 2623
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"wait_for_client: read failed: %s\\n\"",
            "create_cmd"
          ],
          "line": 2620
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fgets",
          "args": [
            "line1",
            "sizeof line1",
            "p"
          ],
          "line": 2619
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"wait_for_client: popen failed: %s\\n\"",
            "create_cmd"
          ],
          "line": 2617
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "popen",
          "args": [
            "create_cmd",
            "\"r\""
          ],
          "line": 2615
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"wait_for_client: running: %s\\n\"",
            "create_cmd"
          ],
          "line": 2614
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"unixpw_system_greeter: create display command.\\n\""
          ],
          "line": 2612
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"unixpw_system_greeter: not trying su_verify() to run\\n\""
          ],
          "line": 2611
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"c-res=%d n=%d line: '%s'\\n\"",
            "res",
            "n",
            "line"
          ],
          "line": 2605
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "su_verify",
          "args": [
            "keep_unixpw_user",
            "keep_unixpw_pass",
            "create_cmd",
            "line",
            "&n",
            "nodisp"
          ],
          "line": 2603
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getuid",
          "args": [],
          "line": 2599
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unixpw_cmd_run",
          "args": [
            "keep_unixpw_user",
            "keep_unixpw_pass",
            "create_cmd",
            "line",
            "&n"
          ],
          "line": 2597
        },
        "resolved": true,
        "details": {
          "function_name": "unixpw_cmd_run",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/unixpw.c",
          "lines": "824-897",
          "snippet": "int unixpw_cmd_run(char *user, char *pass, char *cmd, char *line, int *n) {\n\tint i, len, rc;\n\tchar *str;\n\tFILE *out;\n\n\tif (! user || ! pass) {\n\t\treturn 0;\n\t}\n\tif (! unixpw_cmd || *unixpw_cmd == '\\0') {\n\t\treturn 0;\n\t}\n\n\tif (! scheck(user, 100, \"username\")) {\n\t\treturn 0;\n\t}\n\tif (! scheck(pass, 100, \"password\")) {\n\t\treturn 0;\n\t}\n\tif (! unixpw_list_match(user)) {\n\t\treturn 0;\n\t}\n\tif (cmd == NULL) {\n\t\tcmd = \"\";\n\t}\n\n\tlen = strlen(user) + 1 + strlen(pass) + 1 + 1;\n\tstr = (char *) malloc(len);\n\tif (! str) {\n\t\treturn 0;\n\t}\n\tstr[0] = '\\0';\n\tstrcat(str, user);\n\tstrcat(str, \"\\n\");\n\tstrcat(str, pass);\n\tif (!strchr(pass, '\\n')) {\n\t\tstrcat(str, \"\\n\");\n\t}\n\n\tout = tmpfile();\n\tif (out == NULL) {\n\t\trfbLog(\"unixpw_cmd_run tmpfile() failed.\\n\");\n\t\tclean_up_exit(1);\n\t}\n\n\tset_env(\"RFB_UNIXPW_CMD_RUN\", cmd);\n\n\trc = run_user_command(unixpw_cmd, unixpw_client, \"cmd_verify\",\n\t    str, strlen(str), out);\n\n\tset_env(\"RFB_UNIXPW_CMD_RUN\", \"\");\n\n\tfor (i=0; i < len; i++) {\n\t\tstr[i] = '\\0';\n\t}\n\tfree(str);\n\n\tfflush(out);\n\trewind(out);\n\tfor (i=0; i < (*n) - 1; i++) {\n\t\tint c = fgetc(out);\n\t\tif (c == EOF) {\n\t\t\tbreak;\n\t\t}\n\t\tline[i] = (char) c;\n\t}\n\tfclose(out);\n\t*n = i;\n\n\tif (rc == 0) {\n\t\treturn 1;\n\t} else {\n\t\treturn 0;\n\t}\n}",
          "includes": [
            "#include <sys/stropts.h>",
            "#include <termios.h>",
            "#include <sys/ioctl.h>",
            "#include <shadow.h>",
            "#include \"default8x16.h\"",
            "#include \"rates.h\"",
            "#include \"cursor.h\"",
            "#include \"sslhelper.h\"",
            "#include \"connections.h\"",
            "#include \"user.h\"",
            "#include \"connections.h\"",
            "#include \"xinerama.h\"",
            "#include \"cleanup.h\"",
            "#include \"scan.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void unixpw_accept(char *user);",
            "int unixpw_cmd_run(char *user, char *pass, char *cmd, char *line, int *n);",
            "int crypt_verify(char *user, char *pass);",
            "int cmd_verify(char *user, char *pass);",
            "void unixpw_verify_screen(char *user, char *pass);",
            "rfbClientPtr unixpw_client = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/stropts.h>\n#include <termios.h>\n#include <sys/ioctl.h>\n#include <shadow.h>\n#include \"default8x16.h\"\n#include \"rates.h\"\n#include \"cursor.h\"\n#include \"sslhelper.h\"\n#include \"connections.h\"\n#include \"user.h\"\n#include \"connections.h\"\n#include \"xinerama.h\"\n#include \"cleanup.h\"\n#include \"scan.h\"\n#include \"x11vnc.h\"\n\nvoid unixpw_accept(char *user);\nint unixpw_cmd_run(char *user, char *pass, char *cmd, char *line, int *n);\nint crypt_verify(char *user, char *pass);\nint cmd_verify(char *user, char *pass);\nvoid unixpw_verify_screen(char *user, char *pass);\nrfbClientPtr unixpw_client = NULL;\n\nint unixpw_cmd_run(char *user, char *pass, char *cmd, char *line, int *n) {\n\tint i, len, rc;\n\tchar *str;\n\tFILE *out;\n\n\tif (! user || ! pass) {\n\t\treturn 0;\n\t}\n\tif (! unixpw_cmd || *unixpw_cmd == '\\0') {\n\t\treturn 0;\n\t}\n\n\tif (! scheck(user, 100, \"username\")) {\n\t\treturn 0;\n\t}\n\tif (! scheck(pass, 100, \"password\")) {\n\t\treturn 0;\n\t}\n\tif (! unixpw_list_match(user)) {\n\t\treturn 0;\n\t}\n\tif (cmd == NULL) {\n\t\tcmd = \"\";\n\t}\n\n\tlen = strlen(user) + 1 + strlen(pass) + 1 + 1;\n\tstr = (char *) malloc(len);\n\tif (! str) {\n\t\treturn 0;\n\t}\n\tstr[0] = '\\0';\n\tstrcat(str, user);\n\tstrcat(str, \"\\n\");\n\tstrcat(str, pass);\n\tif (!strchr(pass, '\\n')) {\n\t\tstrcat(str, \"\\n\");\n\t}\n\n\tout = tmpfile();\n\tif (out == NULL) {\n\t\trfbLog(\"unixpw_cmd_run tmpfile() failed.\\n\");\n\t\tclean_up_exit(1);\n\t}\n\n\tset_env(\"RFB_UNIXPW_CMD_RUN\", cmd);\n\n\trc = run_user_command(unixpw_cmd, unixpw_client, \"cmd_verify\",\n\t    str, strlen(str), out);\n\n\tset_env(\"RFB_UNIXPW_CMD_RUN\", \"\");\n\n\tfor (i=0; i < len; i++) {\n\t\tstr[i] = '\\0';\n\t}\n\tfree(str);\n\n\tfflush(out);\n\trewind(out);\n\tfor (i=0; i < (*n) - 1; i++) {\n\t\tint c = fgetc(out);\n\t\tif (c == EOF) {\n\t\t\tbreak;\n\t\t}\n\t\tline[i] = (char) c;\n\t}\n\tfclose(out);\n\t*n = i;\n\n\tif (rc == 0) {\n\t\treturn 1;\n\t} else {\n\t\treturn 0;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "fclose",
          "args": [
            "mt"
          ],
          "line": 2589
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "mt",
            "\"%s\"",
            "create_display"
          ],
          "line": 2588
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLogPerror",
          "args": [
            "\"fopen\""
          ],
          "line": 2585
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"wait_for_client: open failed: %s\\n\"",
            "tmp"
          ],
          "line": 2584
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fopen",
          "args": [
            "tmp",
            "\"w\""
          ],
          "line": 2582
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"wait_for_client: find display cmd failed.\\n\""
          ],
          "line": 2578
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"res=%d n=%d\\n\"",
            "res",
            "n"
          ],
          "line": 2576
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"line: \""
          ],
          "line": 2576
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "su_verify",
          "args": [
            "keep_unixpw_user",
            "keep_unixpw_pass",
            "cmd",
            "line",
            "&n",
            "nodisp"
          ],
          "line": 2571
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"unixpw_system_greeter: forcing find display failure.\\n\""
          ],
          "line": 2563
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "line",
            "0",
            "sizeof(line)"
          ],
          "line": 2560
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "path_lookup",
          "args": [
            "\"Xdummy\""
          ],
          "line": 2552
        },
        "resolved": true,
        "details": {
          "function_name": "path_lookup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/user.c",
          "lines": "2424-2462",
          "snippet": "static void path_lookup(char *prog) {\n\t/* see create_display script */\n\tchar *create_display_extra = \"/usr/X11R6/bin:/usr/bin/X11:/usr/openwin/bin:/usr/dt/bin:/opt/kde4/bin:/opt/kde3/bin:/opt/gnome/bin:/usr/bin:/bin:/usr/sfw/bin:/usr/local/bin\";\n\tchar *path, *try, *p;\n\tint found = 0, len = strlen(create_display_extra);\n\n\tif (getenv(\"PATH\")) {\n\t\tlen += strlen(getenv(\"PATH\")) + 1;\n\t\tpath = (char *) malloc((len+1) * sizeof(char));\n\t\tsprintf(path, \"%s:%s\", getenv(\"PATH\"), create_display_extra);\n\t} else {\n\t\tpath = (char *) malloc((len+1) * sizeof(char));\n\t\tsprintf(path, \"%s\", create_display_extra);\n\t}\n\ttry = (char *) malloc((len+2+strlen(prog)) * sizeof(char));\n\n\tp = strtok(path, \":\");\n\twhile (p) {\n\t\tstruct stat sbuf;\n\n\t\tsprintf(try, \"%s/%s\", p, prog);\n\t\tif (stat(try, &sbuf) == 0) {\n\t\t\tfound = 1;\n\t\t\tbreak;\n\t\t}\n\t\tp = strtok(NULL, \":\");\n\t}\n\n\tfree(path);\n\tfree(try);\n\n\tif (!found) {\n\t\tfprintf(stderr, \"\\n\");\n\t\tfprintf(stderr, \"The program \\\"%s\\\" could not be found in PATH and standard locations.\\n\", prog);\n\t\tfprintf(stderr, \"You probably need to install a package that provides the \\\"%s\\\" program.\\n\", prog);\n\t\tfprintf(stderr, \"Without it FINDCREATEDISPLAY mode may not be able to create an X display.\\n\");\n\t\tfprintf(stderr, \"\\n\");\n\t}\n}",
          "includes": [
            "#include \"avahi.h\"",
            "#include \"sslhelper.h\"",
            "#include \"remote.h\"",
            "#include \"cursor.h\"",
            "#include \"keyboard.h\"",
            "#include \"inet.h\"",
            "#include \"connections.h\"",
            "#include \"xwrappers.h\"",
            "#include \"sslhelper.h\"",
            "#include \"unixpw.h\"",
            "#include \"screen.h\"",
            "#include \"scan.h\"",
            "#include \"cleanup.h\"",
            "#include \"solid.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "rfbBool custom_passwd_check(rfbClientPtr cl, const char *response, int len);",
            "extern char create_display[];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"avahi.h\"\n#include \"sslhelper.h\"\n#include \"remote.h\"\n#include \"cursor.h\"\n#include \"keyboard.h\"\n#include \"inet.h\"\n#include \"connections.h\"\n#include \"xwrappers.h\"\n#include \"sslhelper.h\"\n#include \"unixpw.h\"\n#include \"screen.h\"\n#include \"scan.h\"\n#include \"cleanup.h\"\n#include \"solid.h\"\n#include \"x11vnc.h\"\n\nrfbBool custom_passwd_check(rfbClientPtr cl, const char *response, int len);\nextern char create_display[];\n\nstatic void path_lookup(char *prog) {\n\t/* see create_display script */\n\tchar *create_display_extra = \"/usr/X11R6/bin:/usr/bin/X11:/usr/openwin/bin:/usr/dt/bin:/opt/kde4/bin:/opt/kde3/bin:/opt/gnome/bin:/usr/bin:/bin:/usr/sfw/bin:/usr/local/bin\";\n\tchar *path, *try, *p;\n\tint found = 0, len = strlen(create_display_extra);\n\n\tif (getenv(\"PATH\")) {\n\t\tlen += strlen(getenv(\"PATH\")) + 1;\n\t\tpath = (char *) malloc((len+1) * sizeof(char));\n\t\tsprintf(path, \"%s:%s\", getenv(\"PATH\"), create_display_extra);\n\t} else {\n\t\tpath = (char *) malloc((len+1) * sizeof(char));\n\t\tsprintf(path, \"%s\", create_display_extra);\n\t}\n\ttry = (char *) malloc((len+2+strlen(prog)) * sizeof(char));\n\n\tp = strtok(path, \":\");\n\twhile (p) {\n\t\tstruct stat sbuf;\n\n\t\tsprintf(try, \"%s/%s\", p, prog);\n\t\tif (stat(try, &sbuf) == 0) {\n\t\t\tfound = 1;\n\t\t\tbreak;\n\t\t}\n\t\tp = strtok(NULL, \":\");\n\t}\n\n\tfree(path);\n\tfree(try);\n\n\tif (!found) {\n\t\tfprintf(stderr, \"\\n\");\n\t\tfprintf(stderr, \"The program \\\"%s\\\" could not be found in PATH and standard locations.\\n\", prog);\n\t\tfprintf(stderr, \"You probably need to install a package that provides the \\\"%s\\\" program.\\n\", prog);\n\t\tfprintf(stderr, \"Without it FINDCREATEDISPLAY mode may not be able to create an X display.\\n\");\n\t\tfprintf(stderr, \"\\n\");\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "create_cmd",
            "\"Xdummy\""
          ],
          "line": 2551
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "create_cmd",
            "\"Xvnc\""
          ],
          "line": 2548
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "create_cmd",
            "\"Xvfb\""
          ],
          "line": 2545
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"wait_for_client: running: %s\\n\"",
            "cmd"
          ],
          "line": 2542
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "cmd",
            "\"env X11VNC_SKIP_DISPLAY='%s' %s /bin/sh %s\"",
            "nd",
            "fdout",
            "tmp"
          ],
          "line": 2538
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "cmd",
            "\"env X11VNC_SKIP_DISPLAY='%s' FD_TAG='%s' %s /bin/sh %s\"",
            "nd",
            "tag",
            "fdout",
            "tmp"
          ],
          "line": 2536
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "tag",
            "\"\""
          ],
          "line": 2535
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "strlen(\"env X11VNC_SKIP_DISPLAY='' \")\n\t\t    + strlen(nd) + strlen(\" FD_TAG='' \") + strlen(tag) + strlen(tmp) + strlen(\"/bin/sh \") + strlen(fdout) + 1"
          ],
          "line": 2532
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "fdout"
          ],
          "line": 2533
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "\"/bin/sh \""
          ],
          "line": 2533
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "tmp"
          ],
          "line": 2533
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "tag"
          ],
          "line": 2533
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "\" FD_TAG='' \""
          ],
          "line": 2533
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "nd"
          ],
          "line": 2533
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "\"env X11VNC_SKIP_DISPLAY='' \""
          ],
          "line": 2532
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "fdout",
            "sizeof fdout",
            "\" FIND_DISPLAY_OUTPUT='%s' \"",
            "getenv(\"FIND_DISPLAY_OUTPUT\")"
          ],
          "line": 2529
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getenv",
          "args": [
            "\"FIND_DISPLAY_OUTPUT\""
          ],
          "line": 2529
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getenv",
          "args": [
            "\"FIND_DISPLAY_OUTPUT\""
          ],
          "line": 2528
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "check_nodisplay",
          "args": [
            "&nd",
            "&tag"
          ],
          "line": 2525
        },
        "resolved": true,
        "details": {
          "function_name": "check_nodisplay",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/user.c",
          "lines": "2278-2338",
          "snippet": "static void check_nodisplay(char **nd, char **tag) {\n\tif (unixpw && !getenv(\"X11VNC_NO_UNIXPW_OPTS\") && keep_unixpw_opts && keep_unixpw_opts[0] != '\\0') {\n\t\tchar *q, *t2, *t = keep_unixpw_opts;\n\t\tq = strstr(t, \"nd=\");\n\t\tif (! q) q = strstr(t, \"nodisplay=\");\n\t\tif (q) {\n\t\t\tq = strchr(q, '=') + 1;\n\t\t\tt = strdup(q);\n\t\t\tq = t;\n\t\t\tt2 = strchr(t, ',');\n\t\t\tif (t2) *t2 = '\\0';\n\n\t\t\twhile (*t != '\\0') {\n\t\t\t\tif (*t == '+') {\n\t\t\t\t\t*t = ',';\n\t\t\t\t}\n\t\t\t\tt++;\n\t\t\t}\n\t\t\tif (!strchr(q, '\\'') && !strpbrk(q, \"[](){}`'\\\"$&*|<>\")) {\n\t\t\t\tif (! quiet) rfbLog(\"set X11VNC_SKIP_DISPLAY: %s\\n\", q);\n\t\t\t\t*nd = q;\n\t\t\t}\n\t\t}\n\n\t\tq = strstr(keep_unixpw_opts, \"tag=\");\n\t\tif (getenv(\"FD_TAG\")) {\n\t\t\t*tag = strdup(getenv(\"FD_TAG\"));\n\t\t} else if (q) {\n\t\t\tq = strchr(q, '=') + 1;\n\t\t\tt = strdup(q);\n\t\t\tq = t;\n\t\t\tt2 = strchr(t, ',');\n\t\t\tif (t2) *t2 = '\\0';\n\n\t\t\tif (strlen(q) < 120) {\n\t\t\t\tint ok = 1;\n\t\t\t\twhile (*t != '\\0') {\n\t\t\t\t\tchar c = *t;\n\t\t\t\t\tif (*t == '_' || *t == '-') {\n\t\t\t\t\t\t;\n\t\t\t\t\t} else if (!isalnum((int) c)) {\n\t\t\t\t\t\tok = 0;\n\t\t\t\t\t\trfbLog(\"bad tag char: '%c' in '%s'\\n\", c, q);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tt++;\n\t\t\t\t}\n\t\t\t\tif (ok) {\n\t\t\t\t\tif (! quiet) rfbLog(\"set FD_TAG: %s\\n\", q);\n\t\t\t\t\t*tag = q;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tif (unixpw_system_greeter_active == 2) {\n\t\tif (!keep_unixpw_user) {\n\t\t\tclean_up_exit(1);\n\t\t}\n\t\t*nd = strdup(\"all\");\n\t}\n}",
          "includes": [
            "#include \"avahi.h\"",
            "#include \"sslhelper.h\"",
            "#include \"remote.h\"",
            "#include \"cursor.h\"",
            "#include \"keyboard.h\"",
            "#include \"inet.h\"",
            "#include \"connections.h\"",
            "#include \"xwrappers.h\"",
            "#include \"sslhelper.h\"",
            "#include \"unixpw.h\"",
            "#include \"screen.h\"",
            "#include \"scan.h\"",
            "#include \"cleanup.h\"",
            "#include \"solid.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"avahi.h\"\n#include \"sslhelper.h\"\n#include \"remote.h\"\n#include \"cursor.h\"\n#include \"keyboard.h\"\n#include \"inet.h\"\n#include \"connections.h\"\n#include \"xwrappers.h\"\n#include \"sslhelper.h\"\n#include \"unixpw.h\"\n#include \"screen.h\"\n#include \"scan.h\"\n#include \"cleanup.h\"\n#include \"solid.h\"\n#include \"x11vnc.h\"\n\nstatic void check_nodisplay(char **nd, char **tag) {\n\tif (unixpw && !getenv(\"X11VNC_NO_UNIXPW_OPTS\") && keep_unixpw_opts && keep_unixpw_opts[0] != '\\0') {\n\t\tchar *q, *t2, *t = keep_unixpw_opts;\n\t\tq = strstr(t, \"nd=\");\n\t\tif (! q) q = strstr(t, \"nodisplay=\");\n\t\tif (q) {\n\t\t\tq = strchr(q, '=') + 1;\n\t\t\tt = strdup(q);\n\t\t\tq = t;\n\t\t\tt2 = strchr(t, ',');\n\t\t\tif (t2) *t2 = '\\0';\n\n\t\t\twhile (*t != '\\0') {\n\t\t\t\tif (*t == '+') {\n\t\t\t\t\t*t = ',';\n\t\t\t\t}\n\t\t\t\tt++;\n\t\t\t}\n\t\t\tif (!strchr(q, '\\'') && !strpbrk(q, \"[](){}`'\\\"$&*|<>\")) {\n\t\t\t\tif (! quiet) rfbLog(\"set X11VNC_SKIP_DISPLAY: %s\\n\", q);\n\t\t\t\t*nd = q;\n\t\t\t}\n\t\t}\n\n\t\tq = strstr(keep_unixpw_opts, \"tag=\");\n\t\tif (getenv(\"FD_TAG\")) {\n\t\t\t*tag = strdup(getenv(\"FD_TAG\"));\n\t\t} else if (q) {\n\t\t\tq = strchr(q, '=') + 1;\n\t\t\tt = strdup(q);\n\t\t\tq = t;\n\t\t\tt2 = strchr(t, ',');\n\t\t\tif (t2) *t2 = '\\0';\n\n\t\t\tif (strlen(q) < 120) {\n\t\t\t\tint ok = 1;\n\t\t\t\twhile (*t != '\\0') {\n\t\t\t\t\tchar c = *t;\n\t\t\t\t\tif (*t == '_' || *t == '-') {\n\t\t\t\t\t\t;\n\t\t\t\t\t} else if (!isalnum((int) c)) {\n\t\t\t\t\t\tok = 0;\n\t\t\t\t\t\trfbLog(\"bad tag char: '%c' in '%s'\\n\", c, q);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tt++;\n\t\t\t\t}\n\t\t\t\tif (ok) {\n\t\t\t\t\tif (! quiet) rfbLog(\"set FD_TAG: %s\\n\", q);\n\t\t\t\t\t*tag = q;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tif (unixpw_system_greeter_active == 2) {\n\t\tif (!keep_unixpw_user) {\n\t\t\tclean_up_exit(1);\n\t\t}\n\t\t*nd = strdup(\"all\");\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "getenv(\"X11VNC_SKIP_DISPLAY\")"
          ],
          "line": 2523
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getenv",
          "args": [
            "\"X11VNC_SKIP_DISPLAY\""
          ],
          "line": 2523
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getenv",
          "args": [
            "\"X11VNC_SKIP_DISPLAY\""
          ],
          "line": 2522
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"create_cmd: %s\\n\"",
            "create_cmd"
          ],
          "line": 2520
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "build_create_cmd",
          "args": [
            "cmd",
            "&saw_xdmcp",
            "usslpeer",
            "tmp"
          ],
          "line": 2519
        },
        "resolved": true,
        "details": {
          "function_name": "build_create_cmd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/user.c",
          "lines": "1958-2222",
          "snippet": "static char *build_create_cmd(char *cmd, int *saw_xdmcp, char *usslpeer, char *tmp) {\n\tchar *create_cmd = NULL;\n\tchar *opts = strchr(cmd, '-');\n\tchar st[] = \"\";\n\tchar fdgeom[128], fdsess[128], fdopts[128], fdextra[256], fdprog[128];\n\tchar fdxsrv[128], fdxdum[128], fdcups[128], fdesd[128];\n\tchar fdnas[128], fdsmb[128], fdtag[128], fdxdmcpif[128];\n\tchar cdout[128];\n\n\tif (opts) {\n\t\topts++;\n\t\tif (strstr(opts, \"xdmcp\")) {\n\t\t\t*saw_xdmcp = 1;\n\t\t}\n\t} else {\n\t\topts = st;\n\t}\n\tsprintf(fdgeom, \"NONE\");\n\tfdsess[0] = '\\0';\n\tfdgeom[0] = '\\0';\n\tfdopts[0] = '\\0';\n\tfdextra[0] = '\\0';\n\tfdprog[0] = '\\0';\n\tfdxsrv[0] = '\\0';\n\tfdxdum[0] = '\\0';\n\tfdcups[0] = '\\0';\n\tfdesd[0]  = '\\0';\n\tfdnas[0]  = '\\0';\n\tfdsmb[0]  = '\\0';\n\tfdtag[0]  = '\\0';\n\tfdxdmcpif[0]  = '\\0';\n\tcdout[0]  = '\\0';\n\n\tif (unixpw && keep_unixpw_opts && !getenv(\"X11VNC_NO_UNIXPW_OPTS\")) {\n\t\tchar *q, *p, *t = strdup(keep_unixpw_opts);\n\n\t\tif (strstr(t, \"gnome\")) {\n\t\t\tsprintf(fdsess, \"gnome\");\n\t\t} else if (strstr(t, \"kde\")) {\n\t\t\tsprintf(fdsess, \"kde\");\n\t\t} else if (strstr(t, \"lxde\")) {\n\t\t\tsprintf(fdsess, \"lxde\");\n\t\t} else if (strstr(t, \"twm\")) {\n\t\t\tsprintf(fdsess, \"twm\");\n\t\t} else if (strstr(t, \"fvwm\")) {\n\t\t\tsprintf(fdsess, \"fvwm\");\n\t\t} else if (strstr(t, \"mwm\")) {\n\t\t\tsprintf(fdsess, \"mwm\");\n\t\t} else if (strstr(t, \"cde\")) {\n\t\t\tsprintf(fdsess, \"cde\");\n\t\t} else if (strstr(t, \"dtwm\")) {\n\t\t\tsprintf(fdsess, \"dtwm\");\n\t\t} else if (strstr(t, \"xterm\")) {\n\t\t\tsprintf(fdsess, \"xterm\");\n\t\t} else if (strstr(t, \"wmaker\")) {\n\t\t\tsprintf(fdsess, \"wmaker\");\n\t\t} else if (strstr(t, \"xfce\")) {\n\t\t\tsprintf(fdsess, \"xfce\");\n\t\t} else if (strstr(t, \"enlightenment\")) {\n\t\t\tsprintf(fdsess, \"enlightenment\");\n\t\t} else if (strstr(t, \"Xsession\")) {\n\t\t\tsprintf(fdsess, \"Xsession\");\n\t\t} else if (strstr(t, \"failsafe\")) {\n\t\t\tsprintf(fdsess, \"failsafe\");\n\t\t}\n\n\t\tq = strstr(t, \"ge=\");\n\t\tif (! q) q = strstr(t, \"geom=\");\n\t\tif (! q) q = strstr(t, \"geometry=\");\n\t\tif (q) {\n\t\t\tint ok = 1;\n\t\t\tq = strstr(q, \"=\");\n\t\t\tq++;\n\t\t\tp = strstr(q, \",\");\n\t\t\tif (p) *p = '\\0';\n\t\t\tp = q;\n\t\t\twhile (*p) {\n\t\t\t\tif (*p == 'x') {\n\t\t\t\t\t;\n\t\t\t\t} else if (isdigit((int) *p)) {\n\t\t\t\t\t;\n\t\t\t\t} else {\n\t\t\t\t\tok = 0;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tp++;\n\t\t\t}\n\t\t\tif (ok && strlen(q) < 32) {\n\t\t\t\tsprintf(fdgeom, \"%s\", q);\n\t\t\t\tif (!quiet) {\n\t\t\t\t\trfbLog(\"set create display geom: %s\\n\", fdgeom);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tq = strstr(t, \"cups=\");\n\t\tif (q) {\n\t\t\tint p;\n\t\t\tif (sscanf(q, \"cups=%d\", &p) == 1) {\n\t\t\t\tsprintf(fdcups, \"%d\", p);\n\t\t\t}\n\t\t}\n\t\tq = strstr(t, \"esd=\");\n\t\tif (q) {\n\t\t\tint p;\n\t\t\tif (sscanf(q, \"esd=%d\", &p) == 1) {\n\t\t\t\tsprintf(fdesd, \"%d\", p);\n\t\t\t}\n\t\t}\n\t\tif (!getenv(\"FD_TAG\")) {\n\t\t\tchar *s = NULL;\n\n\t\t\tq = strstr(t, \"tag=\");\n\t\t\tif (q) s = strchr(q, ',');\n\t\t\tif (s) *s = '\\0';\n\n\t\t\tif (q && strlen(q) < 120) {\n\t\t\t\tchar *p;\n\t\t\t\tint ok = 1;\n\t\t\t\tq = strchr(q, '=') + 1;\n\t\t\t\tp = q;\n\t\t\t\twhile (*p != '\\0') {\n\t\t\t\t\tchar c = *p;\n\t\t\t\t\tif (*p == '_' || *p == '-') {\n\t\t\t\t\t\t;\n\t\t\t\t\t} else if (!isalnum((int) c)) {\n\t\t\t\t\t\tok = 0;\n\t\t\t\t\t\trfbLog(\"bad tag char: '%c' in '%s'\\n\", c, q);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tp++;\n\t\t\t\t}\n\t\t\t\tif (ok) {\n\t\t\t\t\tsprintf(fdtag, \"%s\", q);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (s) *s = ',';\n\t\t}\n\t\tfree(t);\n\t}\n\tif (fdgeom[0] == '\\0' && getenv(\"FD_GEOM\")) {\n\t\tsnprintf(fdgeom,  sizeof fdgeom, \"%s\", getenv(\"FD_GEOM\"));\n\t}\n\tif (fdsess[0] == '\\0' && getenv(\"FD_SESS\")) {\n\t\tsnprintf(fdsess, sizeof fdsess, \"%s\", getenv(\"FD_SESS\"));\n\t}\n\tif (fdopts[0] == '\\0' && getenv(\"FD_OPTS\")) {\n\t\tsnprintf(fdopts, sizeof fdopts, \"%s\", getenv(\"FD_OPTS\"));\n\t}\n\tif (fdextra[0] == '\\0' && getenv(\"FD_EXTRA\")) {\n\t\tif (!strchr(getenv(\"FD_EXTRA\"), '\\'')) {\n\t\t\tsnprintf(fdextra, sizeof fdextra, \"%s\", getenv(\"FD_EXTRA\"));\n\t\t}\n\t}\n\tif (fdprog[0] == '\\0' && getenv(\"FD_PROG\")) {\n\t\tsnprintf(fdprog, sizeof fdprog, \"%s\", getenv(\"FD_PROG\"));\n\t}\n\tif (fdxsrv[0] == '\\0' && getenv(\"FD_XSRV\")) {\n\t\tsnprintf(fdxsrv, sizeof fdxsrv, \"%s\", getenv(\"FD_XSRV\"));\n\t}\n\tif (fdcups[0] == '\\0' && getenv(\"FD_CUPS\")) {\n\t\tsnprintf(fdcups, sizeof fdcups, \"%s\", getenv(\"FD_CUPS\"));\n\t}\n\tif (fdesd[0] == '\\0' && getenv(\"FD_ESD\")) {\n\t\tsnprintf(fdesd, sizeof fdesd, \"%s\", getenv(\"FD_ESD\"));\n\t}\n\tif (fdnas[0] == '\\0' && getenv(\"FD_NAS\")) {\n\t\tsnprintf(fdnas, sizeof fdnas, \"%s\", getenv(\"FD_NAS\"));\n\t}\n\tif (fdsmb[0] == '\\0' && getenv(\"FD_SMB\")) {\n\t\tsnprintf(fdsmb, sizeof fdsmb, \"%s\", getenv(\"FD_SMB\"));\n\t}\n\tif (fdtag[0] == '\\0' && getenv(\"FD_TAG\")) {\n\t\tsnprintf(fdtag, sizeof fdtag, \"%s\", getenv(\"FD_TAG\"));\n\t}\n\tif (fdxdmcpif[0] == '\\0' && getenv(\"FD_XDMCP_IF\")) {\n\t\tsnprintf(fdxdmcpif,  sizeof fdxdmcpif, \"%s\", getenv(\"FD_XDMCP_IF\"));\n\t}\n\tif (fdxdum[0] == '\\0' && getenv(\"FD_XDUMMY_RUN_AS_ROOT\")) {\n\t\tsnprintf(fdxdum, sizeof fdxdum, \"%s\", getenv(\"FD_XDUMMY_RUN_AS_ROOT\"));\n\t}\n\tif (getenv(\"CREATE_DISPLAY_OUTPUT\")) {\n\t\tsnprintf(cdout, sizeof cdout, \"CREATE_DISPLAY_OUTPUT='%s'\", getenv(\"CREATE_DISPLAY_OUTPUT\"));\n\t}\n\n\tif (strchr(fdgeom, '\\''))\tfdgeom[0] = '\\0';\n\tif (strchr(fdopts, '\\''))\tfdopts[0] = '\\0';\n\tif (strchr(fdextra, '\\''))\tfdextra[0] = '\\0';\n\tif (strchr(fdprog, '\\''))\tfdprog[0] = '\\0';\n\tif (strchr(fdxsrv, '\\''))\tfdxsrv[0] = '\\0';\n\tif (strchr(fdcups, '\\''))\tfdcups[0] = '\\0';\n\tif (strchr(fdesd, '\\''))\tfdesd[0] = '\\0';\n\tif (strchr(fdnas, '\\''))\tfdnas[0] = '\\0';\n\tif (strchr(fdsmb, '\\''))\tfdsmb[0] = '\\0';\n\tif (strchr(fdtag, '\\''))\tfdtag[0] = '\\0';\n\tif (strchr(fdxdmcpif, '\\''))\tfdxdmcpif[0] = '\\0';\n\tif (strchr(fdxdum, '\\''))\tfdxdum[0] = '\\0';\n\tif (strchr(fdsess, '\\''))\tfdsess[0] = '\\0';\n\tif (strchr(cdout, '\\''))\tcdout[0] = '\\0';\n\n\tset_env(\"FD_GEOM\", fdgeom);\n\tset_env(\"FD_OPTS\", fdopts);\n\tset_env(\"FD_EXTRA\", fdextra);\n\tset_env(\"FD_PROG\", fdprog);\n\tset_env(\"FD_XSRV\", fdxsrv);\n\tset_env(\"FD_CUPS\", fdcups);\n\tset_env(\"FD_ESD\",  fdesd);\n\tset_env(\"FD_NAS\",  fdnas);\n\tset_env(\"FD_SMB\",  fdsmb);\n\tset_env(\"FD_TAG\",  fdtag);\n\tset_env(\"FD_XDMCP_IF\",  fdxdmcpif);\n\tset_env(\"FD_XDUMMY_RUN_AS_ROOT\", fdxdum);\n\tset_env(\"FD_SESS\", fdsess);\n\n\tif (usslpeer || (unixpw && keep_unixpw_user)) {\n\t\tchar *uu = usslpeer;\n\t\tif (!uu) {\n\t\t\tuu = keep_unixpw_user;\n\t\t}\n\t\tif (strchr(uu, '\\''))  {\n\t\t\tuu = \"\";\n\t\t}\n\t\tcreate_cmd = (char *) malloc(strlen(tmp)+1\n\t\t    + strlen(\"env USER='' \")\n\t\t    + strlen(\"FD_GEOM='' \")\n\t\t    + strlen(\"FD_OPTS='' \")\n\t\t    + strlen(\"FD_EXTRA='' \")\n\t\t    + strlen(\"FD_PROG='' \")\n\t\t    + strlen(\"FD_XSRV='' \")\n\t\t    + strlen(\"FD_CUPS='' \")\n\t\t    + strlen(\"FD_ESD='' \")\n\t\t    + strlen(\"FD_NAS='' \")\n\t\t    + strlen(\"FD_SMB='' \")\n\t\t    + strlen(\"FD_TAG='' \")\n\t\t    + strlen(\"FD_XDMCP_IF='' \")\n\t\t    + strlen(\"FD_XDUMMY_RUN_AS_ROOT='' \")\n\t\t    + strlen(\"FD_SESS='' /bin/sh \")\n\t\t    + strlen(uu) + 1\n\t\t    + strlen(fdgeom) + 1\n\t\t    + strlen(fdopts) + 1\n\t\t    + strlen(fdextra) + 1\n\t\t    + strlen(fdprog) + 1\n\t\t    + strlen(fdxsrv) + 1\n\t\t    + strlen(fdcups) + 1\n\t\t    + strlen(fdesd) + 1\n\t\t    + strlen(fdnas) + 1\n\t\t    + strlen(fdsmb) + 1\n\t\t    + strlen(fdtag) + 1\n\t\t    + strlen(fdxdmcpif) + 1\n\t\t    + strlen(fdxdum) + 1\n\t\t    + strlen(fdsess) + 1\n\t\t    + strlen(cdout) + 1\n\t\t    + strlen(opts) + 1);\n\t\tsprintf(create_cmd, \"env USER='%s' FD_GEOM='%s' FD_SESS='%s' \"\n\t\t    \"FD_OPTS='%s' FD_EXTRA='%s' FD_PROG='%s' FD_XSRV='%s' FD_CUPS='%s' \"\n\t\t    \"FD_ESD='%s' FD_NAS='%s' FD_SMB='%s' FD_TAG='%s' FD_XDMCP_IF='%s' \"\n\t\t    \"FD_XDUMMY_RUN_AS_ROOT='%s' %s /bin/sh %s %s\",\n\t\t    uu, fdgeom, fdsess, fdopts, fdextra, fdprog, fdxsrv,\n\t\t    fdcups, fdesd, fdnas, fdsmb, fdtag, fdxdmcpif, fdxdum, cdout, tmp, opts);\n\t} else {\n\t\tcreate_cmd = (char *) malloc(strlen(tmp)\n\t\t    + strlen(\"/bin/sh \") + 1 + strlen(opts) + 1);\n\t\tsprintf(create_cmd, \"/bin/sh %s %s\", tmp, opts);\n\t}\n\treturn create_cmd;\n}",
          "includes": [
            "#include \"avahi.h\"",
            "#include \"sslhelper.h\"",
            "#include \"remote.h\"",
            "#include \"cursor.h\"",
            "#include \"keyboard.h\"",
            "#include \"inet.h\"",
            "#include \"connections.h\"",
            "#include \"xwrappers.h\"",
            "#include \"sslhelper.h\"",
            "#include \"unixpw.h\"",
            "#include \"screen.h\"",
            "#include \"scan.h\"",
            "#include \"cleanup.h\"",
            "#include \"solid.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"avahi.h\"\n#include \"sslhelper.h\"\n#include \"remote.h\"\n#include \"cursor.h\"\n#include \"keyboard.h\"\n#include \"inet.h\"\n#include \"connections.h\"\n#include \"xwrappers.h\"\n#include \"sslhelper.h\"\n#include \"unixpw.h\"\n#include \"screen.h\"\n#include \"scan.h\"\n#include \"cleanup.h\"\n#include \"solid.h\"\n#include \"x11vnc.h\"\n\nstatic char *build_create_cmd(char *cmd, int *saw_xdmcp, char *usslpeer, char *tmp) {\n\tchar *create_cmd = NULL;\n\tchar *opts = strchr(cmd, '-');\n\tchar st[] = \"\";\n\tchar fdgeom[128], fdsess[128], fdopts[128], fdextra[256], fdprog[128];\n\tchar fdxsrv[128], fdxdum[128], fdcups[128], fdesd[128];\n\tchar fdnas[128], fdsmb[128], fdtag[128], fdxdmcpif[128];\n\tchar cdout[128];\n\n\tif (opts) {\n\t\topts++;\n\t\tif (strstr(opts, \"xdmcp\")) {\n\t\t\t*saw_xdmcp = 1;\n\t\t}\n\t} else {\n\t\topts = st;\n\t}\n\tsprintf(fdgeom, \"NONE\");\n\tfdsess[0] = '\\0';\n\tfdgeom[0] = '\\0';\n\tfdopts[0] = '\\0';\n\tfdextra[0] = '\\0';\n\tfdprog[0] = '\\0';\n\tfdxsrv[0] = '\\0';\n\tfdxdum[0] = '\\0';\n\tfdcups[0] = '\\0';\n\tfdesd[0]  = '\\0';\n\tfdnas[0]  = '\\0';\n\tfdsmb[0]  = '\\0';\n\tfdtag[0]  = '\\0';\n\tfdxdmcpif[0]  = '\\0';\n\tcdout[0]  = '\\0';\n\n\tif (unixpw && keep_unixpw_opts && !getenv(\"X11VNC_NO_UNIXPW_OPTS\")) {\n\t\tchar *q, *p, *t = strdup(keep_unixpw_opts);\n\n\t\tif (strstr(t, \"gnome\")) {\n\t\t\tsprintf(fdsess, \"gnome\");\n\t\t} else if (strstr(t, \"kde\")) {\n\t\t\tsprintf(fdsess, \"kde\");\n\t\t} else if (strstr(t, \"lxde\")) {\n\t\t\tsprintf(fdsess, \"lxde\");\n\t\t} else if (strstr(t, \"twm\")) {\n\t\t\tsprintf(fdsess, \"twm\");\n\t\t} else if (strstr(t, \"fvwm\")) {\n\t\t\tsprintf(fdsess, \"fvwm\");\n\t\t} else if (strstr(t, \"mwm\")) {\n\t\t\tsprintf(fdsess, \"mwm\");\n\t\t} else if (strstr(t, \"cde\")) {\n\t\t\tsprintf(fdsess, \"cde\");\n\t\t} else if (strstr(t, \"dtwm\")) {\n\t\t\tsprintf(fdsess, \"dtwm\");\n\t\t} else if (strstr(t, \"xterm\")) {\n\t\t\tsprintf(fdsess, \"xterm\");\n\t\t} else if (strstr(t, \"wmaker\")) {\n\t\t\tsprintf(fdsess, \"wmaker\");\n\t\t} else if (strstr(t, \"xfce\")) {\n\t\t\tsprintf(fdsess, \"xfce\");\n\t\t} else if (strstr(t, \"enlightenment\")) {\n\t\t\tsprintf(fdsess, \"enlightenment\");\n\t\t} else if (strstr(t, \"Xsession\")) {\n\t\t\tsprintf(fdsess, \"Xsession\");\n\t\t} else if (strstr(t, \"failsafe\")) {\n\t\t\tsprintf(fdsess, \"failsafe\");\n\t\t}\n\n\t\tq = strstr(t, \"ge=\");\n\t\tif (! q) q = strstr(t, \"geom=\");\n\t\tif (! q) q = strstr(t, \"geometry=\");\n\t\tif (q) {\n\t\t\tint ok = 1;\n\t\t\tq = strstr(q, \"=\");\n\t\t\tq++;\n\t\t\tp = strstr(q, \",\");\n\t\t\tif (p) *p = '\\0';\n\t\t\tp = q;\n\t\t\twhile (*p) {\n\t\t\t\tif (*p == 'x') {\n\t\t\t\t\t;\n\t\t\t\t} else if (isdigit((int) *p)) {\n\t\t\t\t\t;\n\t\t\t\t} else {\n\t\t\t\t\tok = 0;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tp++;\n\t\t\t}\n\t\t\tif (ok && strlen(q) < 32) {\n\t\t\t\tsprintf(fdgeom, \"%s\", q);\n\t\t\t\tif (!quiet) {\n\t\t\t\t\trfbLog(\"set create display geom: %s\\n\", fdgeom);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tq = strstr(t, \"cups=\");\n\t\tif (q) {\n\t\t\tint p;\n\t\t\tif (sscanf(q, \"cups=%d\", &p) == 1) {\n\t\t\t\tsprintf(fdcups, \"%d\", p);\n\t\t\t}\n\t\t}\n\t\tq = strstr(t, \"esd=\");\n\t\tif (q) {\n\t\t\tint p;\n\t\t\tif (sscanf(q, \"esd=%d\", &p) == 1) {\n\t\t\t\tsprintf(fdesd, \"%d\", p);\n\t\t\t}\n\t\t}\n\t\tif (!getenv(\"FD_TAG\")) {\n\t\t\tchar *s = NULL;\n\n\t\t\tq = strstr(t, \"tag=\");\n\t\t\tif (q) s = strchr(q, ',');\n\t\t\tif (s) *s = '\\0';\n\n\t\t\tif (q && strlen(q) < 120) {\n\t\t\t\tchar *p;\n\t\t\t\tint ok = 1;\n\t\t\t\tq = strchr(q, '=') + 1;\n\t\t\t\tp = q;\n\t\t\t\twhile (*p != '\\0') {\n\t\t\t\t\tchar c = *p;\n\t\t\t\t\tif (*p == '_' || *p == '-') {\n\t\t\t\t\t\t;\n\t\t\t\t\t} else if (!isalnum((int) c)) {\n\t\t\t\t\t\tok = 0;\n\t\t\t\t\t\trfbLog(\"bad tag char: '%c' in '%s'\\n\", c, q);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tp++;\n\t\t\t\t}\n\t\t\t\tif (ok) {\n\t\t\t\t\tsprintf(fdtag, \"%s\", q);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (s) *s = ',';\n\t\t}\n\t\tfree(t);\n\t}\n\tif (fdgeom[0] == '\\0' && getenv(\"FD_GEOM\")) {\n\t\tsnprintf(fdgeom,  sizeof fdgeom, \"%s\", getenv(\"FD_GEOM\"));\n\t}\n\tif (fdsess[0] == '\\0' && getenv(\"FD_SESS\")) {\n\t\tsnprintf(fdsess, sizeof fdsess, \"%s\", getenv(\"FD_SESS\"));\n\t}\n\tif (fdopts[0] == '\\0' && getenv(\"FD_OPTS\")) {\n\t\tsnprintf(fdopts, sizeof fdopts, \"%s\", getenv(\"FD_OPTS\"));\n\t}\n\tif (fdextra[0] == '\\0' && getenv(\"FD_EXTRA\")) {\n\t\tif (!strchr(getenv(\"FD_EXTRA\"), '\\'')) {\n\t\t\tsnprintf(fdextra, sizeof fdextra, \"%s\", getenv(\"FD_EXTRA\"));\n\t\t}\n\t}\n\tif (fdprog[0] == '\\0' && getenv(\"FD_PROG\")) {\n\t\tsnprintf(fdprog, sizeof fdprog, \"%s\", getenv(\"FD_PROG\"));\n\t}\n\tif (fdxsrv[0] == '\\0' && getenv(\"FD_XSRV\")) {\n\t\tsnprintf(fdxsrv, sizeof fdxsrv, \"%s\", getenv(\"FD_XSRV\"));\n\t}\n\tif (fdcups[0] == '\\0' && getenv(\"FD_CUPS\")) {\n\t\tsnprintf(fdcups, sizeof fdcups, \"%s\", getenv(\"FD_CUPS\"));\n\t}\n\tif (fdesd[0] == '\\0' && getenv(\"FD_ESD\")) {\n\t\tsnprintf(fdesd, sizeof fdesd, \"%s\", getenv(\"FD_ESD\"));\n\t}\n\tif (fdnas[0] == '\\0' && getenv(\"FD_NAS\")) {\n\t\tsnprintf(fdnas, sizeof fdnas, \"%s\", getenv(\"FD_NAS\"));\n\t}\n\tif (fdsmb[0] == '\\0' && getenv(\"FD_SMB\")) {\n\t\tsnprintf(fdsmb, sizeof fdsmb, \"%s\", getenv(\"FD_SMB\"));\n\t}\n\tif (fdtag[0] == '\\0' && getenv(\"FD_TAG\")) {\n\t\tsnprintf(fdtag, sizeof fdtag, \"%s\", getenv(\"FD_TAG\"));\n\t}\n\tif (fdxdmcpif[0] == '\\0' && getenv(\"FD_XDMCP_IF\")) {\n\t\tsnprintf(fdxdmcpif,  sizeof fdxdmcpif, \"%s\", getenv(\"FD_XDMCP_IF\"));\n\t}\n\tif (fdxdum[0] == '\\0' && getenv(\"FD_XDUMMY_RUN_AS_ROOT\")) {\n\t\tsnprintf(fdxdum, sizeof fdxdum, \"%s\", getenv(\"FD_XDUMMY_RUN_AS_ROOT\"));\n\t}\n\tif (getenv(\"CREATE_DISPLAY_OUTPUT\")) {\n\t\tsnprintf(cdout, sizeof cdout, \"CREATE_DISPLAY_OUTPUT='%s'\", getenv(\"CREATE_DISPLAY_OUTPUT\"));\n\t}\n\n\tif (strchr(fdgeom, '\\''))\tfdgeom[0] = '\\0';\n\tif (strchr(fdopts, '\\''))\tfdopts[0] = '\\0';\n\tif (strchr(fdextra, '\\''))\tfdextra[0] = '\\0';\n\tif (strchr(fdprog, '\\''))\tfdprog[0] = '\\0';\n\tif (strchr(fdxsrv, '\\''))\tfdxsrv[0] = '\\0';\n\tif (strchr(fdcups, '\\''))\tfdcups[0] = '\\0';\n\tif (strchr(fdesd, '\\''))\tfdesd[0] = '\\0';\n\tif (strchr(fdnas, '\\''))\tfdnas[0] = '\\0';\n\tif (strchr(fdsmb, '\\''))\tfdsmb[0] = '\\0';\n\tif (strchr(fdtag, '\\''))\tfdtag[0] = '\\0';\n\tif (strchr(fdxdmcpif, '\\''))\tfdxdmcpif[0] = '\\0';\n\tif (strchr(fdxdum, '\\''))\tfdxdum[0] = '\\0';\n\tif (strchr(fdsess, '\\''))\tfdsess[0] = '\\0';\n\tif (strchr(cdout, '\\''))\tcdout[0] = '\\0';\n\n\tset_env(\"FD_GEOM\", fdgeom);\n\tset_env(\"FD_OPTS\", fdopts);\n\tset_env(\"FD_EXTRA\", fdextra);\n\tset_env(\"FD_PROG\", fdprog);\n\tset_env(\"FD_XSRV\", fdxsrv);\n\tset_env(\"FD_CUPS\", fdcups);\n\tset_env(\"FD_ESD\",  fdesd);\n\tset_env(\"FD_NAS\",  fdnas);\n\tset_env(\"FD_SMB\",  fdsmb);\n\tset_env(\"FD_TAG\",  fdtag);\n\tset_env(\"FD_XDMCP_IF\",  fdxdmcpif);\n\tset_env(\"FD_XDUMMY_RUN_AS_ROOT\", fdxdum);\n\tset_env(\"FD_SESS\", fdsess);\n\n\tif (usslpeer || (unixpw && keep_unixpw_user)) {\n\t\tchar *uu = usslpeer;\n\t\tif (!uu) {\n\t\t\tuu = keep_unixpw_user;\n\t\t}\n\t\tif (strchr(uu, '\\''))  {\n\t\t\tuu = \"\";\n\t\t}\n\t\tcreate_cmd = (char *) malloc(strlen(tmp)+1\n\t\t    + strlen(\"env USER='' \")\n\t\t    + strlen(\"FD_GEOM='' \")\n\t\t    + strlen(\"FD_OPTS='' \")\n\t\t    + strlen(\"FD_EXTRA='' \")\n\t\t    + strlen(\"FD_PROG='' \")\n\t\t    + strlen(\"FD_XSRV='' \")\n\t\t    + strlen(\"FD_CUPS='' \")\n\t\t    + strlen(\"FD_ESD='' \")\n\t\t    + strlen(\"FD_NAS='' \")\n\t\t    + strlen(\"FD_SMB='' \")\n\t\t    + strlen(\"FD_TAG='' \")\n\t\t    + strlen(\"FD_XDMCP_IF='' \")\n\t\t    + strlen(\"FD_XDUMMY_RUN_AS_ROOT='' \")\n\t\t    + strlen(\"FD_SESS='' /bin/sh \")\n\t\t    + strlen(uu) + 1\n\t\t    + strlen(fdgeom) + 1\n\t\t    + strlen(fdopts) + 1\n\t\t    + strlen(fdextra) + 1\n\t\t    + strlen(fdprog) + 1\n\t\t    + strlen(fdxsrv) + 1\n\t\t    + strlen(fdcups) + 1\n\t\t    + strlen(fdesd) + 1\n\t\t    + strlen(fdnas) + 1\n\t\t    + strlen(fdsmb) + 1\n\t\t    + strlen(fdtag) + 1\n\t\t    + strlen(fdxdmcpif) + 1\n\t\t    + strlen(fdxdum) + 1\n\t\t    + strlen(fdsess) + 1\n\t\t    + strlen(cdout) + 1\n\t\t    + strlen(opts) + 1);\n\t\tsprintf(create_cmd, \"env USER='%s' FD_GEOM='%s' FD_SESS='%s' \"\n\t\t    \"FD_OPTS='%s' FD_EXTRA='%s' FD_PROG='%s' FD_XSRV='%s' FD_CUPS='%s' \"\n\t\t    \"FD_ESD='%s' FD_NAS='%s' FD_SMB='%s' FD_TAG='%s' FD_XDMCP_IF='%s' \"\n\t\t    \"FD_XDUMMY_RUN_AS_ROOT='%s' %s /bin/sh %s %s\",\n\t\t    uu, fdgeom, fdsess, fdopts, fdextra, fdprog, fdxsrv,\n\t\t    fdcups, fdesd, fdnas, fdsmb, fdtag, fdxdmcpif, fdxdum, cdout, tmp, opts);\n\t} else {\n\t\tcreate_cmd = (char *) malloc(strlen(tmp)\n\t\t    + strlen(\"/bin/sh \") + 1 + strlen(opts) + 1);\n\t\tsprintf(create_cmd, \"/bin/sh %s %s\", tmp, opts);\n\t}\n\treturn create_cmd;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "cmd",
            "\"FINDCREATEDISPLAY\""
          ],
          "line": 2518
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "close",
          "args": [
            "tmp_fd"
          ],
          "line": 2515
        },
        "resolved": true,
        "details": {
          "function_name": "close_alarm",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/unixpw.c",
          "lines": "666-672",
          "snippet": "static void close_alarm (int sig) {\n\tif (slave_fd >= 0) {\n\t\tclose(slave_fd);\n\t}\n\talarm_fired = 1;\n\tif (0) sig = 0;\t/* compiler warning */\n}",
          "includes": [
            "#include <sys/stropts.h>",
            "#include <termios.h>",
            "#include <sys/ioctl.h>",
            "#include <shadow.h>",
            "#include \"default8x16.h\"",
            "#include \"rates.h\"",
            "#include \"cursor.h\"",
            "#include \"sslhelper.h\"",
            "#include \"connections.h\"",
            "#include \"user.h\"",
            "#include \"connections.h\"",
            "#include \"xinerama.h\"",
            "#include \"cleanup.h\"",
            "#include \"scan.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int slave_fd = -1, alarm_fired = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/stropts.h>\n#include <termios.h>\n#include <sys/ioctl.h>\n#include <shadow.h>\n#include \"default8x16.h\"\n#include \"rates.h\"\n#include \"cursor.h\"\n#include \"sslhelper.h\"\n#include \"connections.h\"\n#include \"user.h\"\n#include \"connections.h\"\n#include \"xinerama.h\"\n#include \"cleanup.h\"\n#include \"scan.h\"\n#include \"x11vnc.h\"\n\nstatic int slave_fd = -1, alarm_fired = 0;\n\nstatic void close_alarm (int sig) {\n\tif (slave_fd >= 0) {\n\t\tclose(slave_fd);\n\t}\n\talarm_fired = 1;\n\tif (0) sig = 0;\t/* compiler warning */\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "find_display"
          ],
          "line": 2513
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "s"
          ],
          "line": 2511
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getenv",
          "args": [
            "\"X11VNC_FINDDISPLAY_ALWAYS_FAILS\""
          ],
          "line": 2509
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "chmod",
          "args": [
            "tmp",
            "0644"
          ],
          "line": 2508
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLogPerror",
          "args": [
            "\"mkstemp\""
          ],
          "line": 2505
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"wait_for_client: open failed: %s\\n\"",
            "tmp"
          ],
          "line": 2504
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mkstemp",
          "args": [
            "tmp"
          ],
          "line": 2501
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "cmd",
            "\"FINDCREATEDISPLAY\""
          ],
          "line": 2494
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "cmd",
            "\"FINDDISPLAY\""
          ],
          "line": 2493
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_env",
          "args": [
            "\"X11VNC_PROG\"",
            "\"x11vnc\""
          ],
          "line": 2490
        },
        "resolved": true,
        "details": {
          "function_name": "set_env",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/util.c",
          "lines": "239-249",
          "snippet": "void set_env(char *name, char *value) {\n\tchar *str;\n\tif (! name) {\n\t\treturn;\n\t}\n\tif (! value) {\n\t\tvalue = \"\";\n\t}\n\n\tsetenv(name, value, 1);\n}",
          "includes": [
            "#include \"connections.h\"",
            "#include \"unixpw.h\"",
            "#include \"win_utils.h\"",
            "#include \"cleanup.h\"",
            "#include \"x11vnc.h\"",
            "#include <stdlib.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void lowercase(char *str);",
            "void uppercase(char *str);",
            "char *lblanks(char *str);",
            "void strzero(char *str);",
            "void set_env(char *name, char *value);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"connections.h\"\n#include \"unixpw.h\"\n#include \"win_utils.h\"\n#include \"cleanup.h\"\n#include \"x11vnc.h\"\n#include <stdlib.h>\n\nvoid lowercase(char *str);\nvoid uppercase(char *str);\nchar *lblanks(char *str);\nvoid strzero(char *str);\nvoid set_env(char *name, char *value);\n\nvoid set_env(char *name, char *value) {\n\tchar *str;\n\tif (! name) {\n\t\treturn;\n\t}\n\tif (! value) {\n\t\tvalue = \"\";\n\t}\n\n\tsetenv(name, value, 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "run_user_command",
          "args": [
            "\"\"",
            "latest_client",
            "\"env\"",
            "NULL",
            "0",
            "NULL"
          ],
          "line": 2485
        },
        "resolved": true,
        "details": {
          "function_name": "run_user_command",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/connections.c",
          "lines": "466-763",
          "snippet": "int run_user_command(char *cmd, rfbClientPtr client, char *mode, char *input,\n   int len, FILE *output) {\n\tchar *old_display = NULL;\n\tchar *addr = NULL;\n\tchar str[100];\n\tint rc, ok;\n\tClientData *cd = NULL;\n\tclient_set_net(client);\n\tif (client != NULL) {\n\t\tcd = (ClientData *) client->clientData;\n\t\taddr = client->host;\n\t}\n\n\tif (addr == NULL || addr[0] == '\\0') {\n\t\taddr = \"unknown-host\";\n\t}\n\n\t/* set RFB_CLIENT_ID to semi unique id for command to use */\n\tif (cd && cd->uid) {\n\t\tsprintf(str, \"0x%x\", cd->uid);\n\t} else {\n\t\t/* not accepted yet: */\n\t\tsprintf(str, \"0x%x\", clients_served);\n\t}\n\tset_env(\"RFB_CLIENT_ID\", str);\n\n\t/* set RFB_CLIENT_IP to IP addr for command to use */\n\tset_env(\"RFB_CLIENT_IP\", addr);\n\n\t/* set RFB_X11VNC_PID to our pid for command to use */\n\tsprintf(str, \"%d\", (int) getpid());\n\tset_env(\"RFB_X11VNC_PID\", str);\n\n\tif (client == NULL) {\n\t\t;\n\t} else if (client->state == RFB_PROTOCOL_VERSION) {\n\t\tset_env(\"RFB_STATE\", \"PROTOCOL_VERSION\");\n\t} else if (client->state == RFB_SECURITY_TYPE) {\n\t\tset_env(\"RFB_STATE\", \"SECURITY_TYPE\");\n\t} else if (client->state == RFB_AUTHENTICATION) {\n\t\tset_env(\"RFB_STATE\", \"AUTHENTICATION\");\n\t} else if (client->state == RFB_INITIALISATION) {\n\t\tset_env(\"RFB_STATE\", \"INITIALISATION\");\n\t} else if (client->state == RFB_NORMAL) {\n\t\tset_env(\"RFB_STATE\", \"NORMAL\");\n\t} else {\n\t\tset_env(\"RFB_STATE\", \"UNKNOWN\");\n\t}\n\tif (certret_str) {\n\t\tset_env(\"RFB_SSL_CLIENT_CERT\", certret_str);\n\t} else {\n\t\tset_env(\"RFB_SSL_CLIENT_CERT\", \"\");\n\t}\n\n\t/* set RFB_CLIENT_PORT to peer port for command to use */\n\tif (cd && cd->client_port > 0) {\n\t\tsprintf(str, \"%d\", cd->client_port);\n\t} else if (client) {\n\t\tsprintf(str, \"%d\", get_remote_port(client->sock));\n\t}\n\tset_env(\"RFB_CLIENT_PORT\", str);\n\n\tset_env(\"RFB_MODE\", mode);\n\n\t/* \n\t * now do RFB_SERVER_IP and RFB_SERVER_PORT (i.e. us!)\n\t * This will establish a 5-tuple (including tcp) the external\n\t * program can potentially use to work out the virtual circuit\n\t * for this connection.\n\t */\n\tif (cd && cd->server_ip) {\n\t\tset_env(\"RFB_SERVER_IP\", cd->server_ip);\n\t} else if (client) {\n\t\tchar *sip = get_local_host(client->sock);\n\t\tset_env(\"RFB_SERVER_IP\", sip);\n\t\tif (sip) free(sip);\n\t}\n\n\tif (cd && cd->server_port > 0) {\n\t\tsprintf(str, \"%d\", cd->server_port);\n\t} else if (client) {\n\t\tsprintf(str, \"%d\", get_local_port(client->sock));\n\t}\n\tset_env(\"RFB_SERVER_PORT\", str);\n\n\tif (cd) {\n\t\tsprintf(str, \"%d\", cd->login_viewonly);\n\t} else {\n\t\tsprintf(str, \"%d\", -1);\n\t}\n\tset_env(\"RFB_LOGIN_VIEWONLY\", str);\n\n\tif (cd) {\n\t\tsprintf(str, \"%d\", (int) cd->login_time);\n\t} else {\n\t\tsprintf(str, \">%d\", (int) time(NULL));\n\t}\n\tset_env(\"RFB_LOGIN_TIME\", str);\n\n\tsprintf(str, \"%d\", (int) time(NULL));\n\tset_env(\"RFB_CURRENT_TIME\", str);\n\n\tif (!cd || !cd->username || cd->username[0] == '\\0') {\n\t\tset_env(\"RFB_USERNAME\", \"unknown-user\");\n\t} else {\n\t\tset_env(\"RFB_USERNAME\", cd->username);\n\t}\n\t/* \n\t * Better set DISPLAY to the one we are polling, if they\n\t * want something trickier, they can handle on their own\n\t * via environment, etc. \n\t */\n\tif (getenv(\"DISPLAY\")) {\n\t\told_display = strdup(getenv(\"DISPLAY\"));\n\t}\n\n\tif (raw_fb && ! dpy) {\t/* raw_fb hack */\n\t\tset_env(\"DISPLAY\", \"rawfb\");\n\t} else {\n\t\tset_env(\"DISPLAY\", DisplayString(dpy));\n\t}\n\n\t/*\n\t * work out the number of clients (have to use client_count\n\t * since there is deadlock in rfbGetClientIterator) \n\t */\n\tsprintf(str, \"%d\", client_count);\n\tset_env(\"RFB_CLIENT_COUNT\", str);\n\n\t/* gone, accept, afteraccept */\n\tok = 0;\n\tif (!strcmp(mode, \"env\")) {\n\t\treturn 1;\n\t}\n\tif (!strcmp(mode, \"accept\") && cmd_ok(\"accept\")) {\n\t\tok = 1;\n\t}\n\tif (!strcmp(mode, \"afteraccept\") && cmd_ok(\"afteraccept\")) {\n\t\tok = 1;\n\t}\n\tif (!strcmp(mode, \"gone\") && cmd_ok(\"gone\")) {\n\t\tok = 1;\n\t}\n\tif (!strcmp(mode, \"cmd_verify\") && cmd_ok(\"unixpw\")) {\n\t\tok = 1;\n\t}\n\tif (!strcmp(mode, \"read_passwds\") && cmd_ok(\"passwdfile\")) {\n\t\tok = 1;\n\t}\n\tif (!strcmp(mode, \"custom_passwd\") && cmd_ok(\"custom_passwd\")) {\n\t\tok = 1;\n\t}\n\tif (no_external_cmds || !ok) {\n\t\trfbLogEnable(1);\n\t\trfbLog(\"cannot run external commands in -nocmds mode:\\n\");\n\t\trfbLog(\"   \\\"%s\\\"\\n\", cmd);\n\t\trfbLog(\"   exiting.\\n\");\n\t\tclean_up_exit(1);\n\t}\n\trfbLog(\"running command:\\n\");\n\tif (!quiet) {\n\t\tfprintf(stderr, \"\\n  %s\\n\\n\", cmd);\n\t}\n\tclose_exec_fds();\n\n\tif (output != NULL) {\n\t\tFILE *ph;\n\t\tchar line[1024];\n\t\tchar *cmd2 = NULL;\n\t\tchar tmp[] = \"/tmp/x11vnc-tmp.XXXXXX\";\n\t\tint deltmp = 0;\n\n\t\tif (input != NULL) {\n\t\t\tint tmp_fd = mkstemp(tmp);\n\t\t\tif (tmp_fd < 0) {\n\t\t\t\trfbLog(\"mkstemp failed on: %s\\n\", tmp);\n\t\t\t\tclean_up_exit(1);\n\t\t\t}\n\t\t\twrite(tmp_fd, input, len);\n\t\t\tclose(tmp_fd);\n\t\t\tdeltmp = 1;\n\t\t\tcmd2 = (char *) malloc(100 + strlen(tmp) + strlen(cmd));\n\t\t\tsprintf(cmd2, \"/bin/cat %s | %s\", tmp, cmd);\n\t\t\t\n\t\t\tph = popen(cmd2, \"r\");\n\t\t} else {\n\t\t\tph = popen(cmd, \"r\");\n\t\t}\n\t\tif (ph == NULL) {\n\t\t\trfbLog(\"popen(%s) failed\", cmd);\n\t\t\trfbLogPerror(\"popen\");\n\t\t\tclean_up_exit(1);\n\t\t}\n\t\tmemset(line, 0, sizeof(line));\n\t\twhile (fgets(line, sizeof(line), ph) != NULL) {\n\t\t\tint j, k = -1;\n\t\t\tif (0) fprintf(stderr, \"line: %s\", line);\n\t\t\t/* take care to handle embedded nulls */\n\t\t\tfor (j=0; j < (int) sizeof(line); j++) {\n\t\t\t\tif (line[j] != '\\0') {\n\t\t\t\t\tk = j;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (k >= 0) {\n\t\t\t\twrite(fileno(output), line, k+1);\n\t\t\t}\n\t\t\tmemset(line, 0, sizeof(line));\n\t\t}\n\n\t\trc = pclose(ph);\n\n\t\tif (cmd2 != NULL) {\n\t\t\tfree(cmd2);\n\t\t}\n\t\tif (deltmp) {\n\t\t\tunlink(tmp);\n\t\t}\n\t\tgoto got_rc;\n\t} else if (input != NULL) {\n\t\tFILE *ph = popen(cmd, \"w\");\n\t\tif (ph == NULL) {\n\t\t\trfbLog(\"popen(%s) failed\", cmd);\n\t\t\trfbLogPerror(\"popen\");\n\t\t\tclean_up_exit(1);\n\t\t}\n\t\twrite(fileno(ph), input, len);\n\t\trc = pclose(ph);\n\t\tgoto got_rc;\n\t}\n\n#if LIBVNCSERVER_HAVE_FORK\n\t{\n\t\tpid_t pid;\n\t\tstruct sigaction sa, intr, quit;\n\t\tsigset_t omask;\n\n\t\tsa.sa_handler = SIG_IGN;\n\t\tsa.sa_flags = 0;\n\t\tsigemptyset(&sa.sa_mask);\n\t\tsigaction(SIGINT,  &sa, &intr);\n\t\tsigaction(SIGQUIT, &sa, &quit);\n\n\t\tsigaddset(&sa.sa_mask, SIGCHLD);\n\t\tsigprocmask(SIG_BLOCK, &sa.sa_mask, &omask);\n\n\t\tif ((pid = fork()) > 0 || pid == -1) {\n\n\t\t\tif (pid != -1) {\n\t\t\t\twaitpid(pid, &rc, 0);\n\t\t\t}\n\n\t\t\tsigaction(SIGINT,  &intr, (struct sigaction *) NULL);\n\t\t\tsigaction(SIGQUIT, &quit, (struct sigaction *) NULL);\n\t\t\tsigprocmask(SIG_SETMASK, &omask, (sigset_t *) NULL);\n\n\t\t\tif (pid == -1) {\n\t\t\t\tfprintf(stderr, \"could not fork\\n\");\n\t\t\t\trfbLogPerror(\"fork\");\n\t\t\t\trc = system(cmd);\n\t\t\t}\n\t\t} else {\n\t\t\t/* this should close port 5900, etc.. */\n\t\t\tint fd;\n\t\t\tsigaction(SIGINT,  &intr, (struct sigaction *) NULL);\n\t\t\tsigaction(SIGQUIT, &quit, (struct sigaction *) NULL);\n\t\t\tsigprocmask(SIG_SETMASK, &omask, (sigset_t *) NULL);\n\t\t\tfor (fd=3; fd<256; fd++) {\n\t\t\t\tclose(fd);\n\t\t\t}\n/* XXX test more */\n\t\t\tif (!strcmp(mode, \"gone\")) {\n#if HAVE_SETSID\n\t\t\t\tsetsid();\n#else\n\t\t\t\tsetpgrp();\n#endif\n\t\t\t}\n\t\t\texeclp(\"/bin/sh\", \"/bin/sh\", \"-c\", cmd, (char *) NULL);\n\t\t\texit(1);\n\t\t}\n\t}\n#else\n\trc = system(cmd);\n#endif\n\tgot_rc:\n\n\tif (rc >= 256) {\n\t\trc = rc/256;\n\t}\n\trfbLog(\"command returned: %d\\n\", rc);\n\n\tif (old_display) {\n\t\tset_env(\"DISPLAY\", old_display);\n\t\tfree(old_display);\n\t}\n\n\treturn rc;\n}",
          "includes": [
            "#include \"xi2_devices.h\"",
            "#include \"xrandr.h\"",
            "#include \"pointer.h\"",
            "#include \"userinput.h\"",
            "#include \"macosxCG.h\"",
            "#include \"macosx.h\"",
            "#include \"win_utils.h\"",
            "#include \"xevents.h\"",
            "#include \"xwrappers.h\"",
            "#include \"sslhelper.h\"",
            "#include \"sslcmds.h\"",
            "#include \"scan.h\"",
            "#include \"user.h\"",
            "#include \"unixpw.h\"",
            "#include \"screen.h\"",
            "#include \"rates.h\"",
            "#include \"solid.h\"",
            "#include \"gui.h\"",
            "#include \"cleanup.h\"",
            "#include \"keyboard.h\"",
            "#include \"remote.h\"",
            "#include \"inet.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int new_fb_size_clients(rfbScreenInfoPtr s);",
            "void close_clients(char *str);",
            "void set_client_input(char *str);",
            "int cmd_ok(char *cmd);",
            "void client_gone(rfbClientPtr client);",
            "void client_gone_chat_helper(rfbClientPtr client);",
            "void reverse_connect(char *str);",
            "void set_vnc_connect_prop(char *str);",
            "void set_x11vnc_remote_prop(char *str);",
            "enum rfbNewClientAction new_client(rfbClientPtr client);",
            "enum rfbNewClientAction new_client_chat_helper(rfbClientPtr client);",
            "rfbBool password_check_chat_helper(rfbClientPtr cl, const char* response, int len);",
            "void send_client_info(char *str);",
            "void adjust_grabs(int grab, int quiet);",
            "int accept_client(rfbClientPtr client);",
            "int run_user_command(char *cmd, rfbClientPtr client, char *mode, char *input,\n    int len, FILE *output);",
            "int check_access(char *addr);",
            "void client_set_net(rfbClientPtr client);",
            "static rfbClientPtr *client_match(char *str);",
            "static void free_client_data(rfbClientPtr client);",
            "static int ugly_window(char *addr, char *userhost, int X, int Y,\n    int timeout, char *mode, int accept);",
            "static int action_match(char *action, int rc);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xi2_devices.h\"\n#include \"xrandr.h\"\n#include \"pointer.h\"\n#include \"userinput.h\"\n#include \"macosxCG.h\"\n#include \"macosx.h\"\n#include \"win_utils.h\"\n#include \"xevents.h\"\n#include \"xwrappers.h\"\n#include \"sslhelper.h\"\n#include \"sslcmds.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"unixpw.h\"\n#include \"screen.h\"\n#include \"rates.h\"\n#include \"solid.h\"\n#include \"gui.h\"\n#include \"cleanup.h\"\n#include \"keyboard.h\"\n#include \"remote.h\"\n#include \"inet.h\"\n#include \"x11vnc.h\"\n\nint new_fb_size_clients(rfbScreenInfoPtr s);\nvoid close_clients(char *str);\nvoid set_client_input(char *str);\nint cmd_ok(char *cmd);\nvoid client_gone(rfbClientPtr client);\nvoid client_gone_chat_helper(rfbClientPtr client);\nvoid reverse_connect(char *str);\nvoid set_vnc_connect_prop(char *str);\nvoid set_x11vnc_remote_prop(char *str);\nenum rfbNewClientAction new_client(rfbClientPtr client);\nenum rfbNewClientAction new_client_chat_helper(rfbClientPtr client);\nrfbBool password_check_chat_helper(rfbClientPtr cl, const char* response, int len);\nvoid send_client_info(char *str);\nvoid adjust_grabs(int grab, int quiet);\nint accept_client(rfbClientPtr client);\nint run_user_command(char *cmd, rfbClientPtr client, char *mode, char *input,\n    int len, FILE *output);\nint check_access(char *addr);\nvoid client_set_net(rfbClientPtr client);\nstatic rfbClientPtr *client_match(char *str);\nstatic void free_client_data(rfbClientPtr client);\nstatic int ugly_window(char *addr, char *userhost, int X, int Y,\n    int timeout, char *mode, int accept);\nstatic int action_match(char *action, int rc);\n\nint run_user_command(char *cmd, rfbClientPtr client, char *mode, char *input,\n   int len, FILE *output) {\n\tchar *old_display = NULL;\n\tchar *addr = NULL;\n\tchar str[100];\n\tint rc, ok;\n\tClientData *cd = NULL;\n\tclient_set_net(client);\n\tif (client != NULL) {\n\t\tcd = (ClientData *) client->clientData;\n\t\taddr = client->host;\n\t}\n\n\tif (addr == NULL || addr[0] == '\\0') {\n\t\taddr = \"unknown-host\";\n\t}\n\n\t/* set RFB_CLIENT_ID to semi unique id for command to use */\n\tif (cd && cd->uid) {\n\t\tsprintf(str, \"0x%x\", cd->uid);\n\t} else {\n\t\t/* not accepted yet: */\n\t\tsprintf(str, \"0x%x\", clients_served);\n\t}\n\tset_env(\"RFB_CLIENT_ID\", str);\n\n\t/* set RFB_CLIENT_IP to IP addr for command to use */\n\tset_env(\"RFB_CLIENT_IP\", addr);\n\n\t/* set RFB_X11VNC_PID to our pid for command to use */\n\tsprintf(str, \"%d\", (int) getpid());\n\tset_env(\"RFB_X11VNC_PID\", str);\n\n\tif (client == NULL) {\n\t\t;\n\t} else if (client->state == RFB_PROTOCOL_VERSION) {\n\t\tset_env(\"RFB_STATE\", \"PROTOCOL_VERSION\");\n\t} else if (client->state == RFB_SECURITY_TYPE) {\n\t\tset_env(\"RFB_STATE\", \"SECURITY_TYPE\");\n\t} else if (client->state == RFB_AUTHENTICATION) {\n\t\tset_env(\"RFB_STATE\", \"AUTHENTICATION\");\n\t} else if (client->state == RFB_INITIALISATION) {\n\t\tset_env(\"RFB_STATE\", \"INITIALISATION\");\n\t} else if (client->state == RFB_NORMAL) {\n\t\tset_env(\"RFB_STATE\", \"NORMAL\");\n\t} else {\n\t\tset_env(\"RFB_STATE\", \"UNKNOWN\");\n\t}\n\tif (certret_str) {\n\t\tset_env(\"RFB_SSL_CLIENT_CERT\", certret_str);\n\t} else {\n\t\tset_env(\"RFB_SSL_CLIENT_CERT\", \"\");\n\t}\n\n\t/* set RFB_CLIENT_PORT to peer port for command to use */\n\tif (cd && cd->client_port > 0) {\n\t\tsprintf(str, \"%d\", cd->client_port);\n\t} else if (client) {\n\t\tsprintf(str, \"%d\", get_remote_port(client->sock));\n\t}\n\tset_env(\"RFB_CLIENT_PORT\", str);\n\n\tset_env(\"RFB_MODE\", mode);\n\n\t/* \n\t * now do RFB_SERVER_IP and RFB_SERVER_PORT (i.e. us!)\n\t * This will establish a 5-tuple (including tcp) the external\n\t * program can potentially use to work out the virtual circuit\n\t * for this connection.\n\t */\n\tif (cd && cd->server_ip) {\n\t\tset_env(\"RFB_SERVER_IP\", cd->server_ip);\n\t} else if (client) {\n\t\tchar *sip = get_local_host(client->sock);\n\t\tset_env(\"RFB_SERVER_IP\", sip);\n\t\tif (sip) free(sip);\n\t}\n\n\tif (cd && cd->server_port > 0) {\n\t\tsprintf(str, \"%d\", cd->server_port);\n\t} else if (client) {\n\t\tsprintf(str, \"%d\", get_local_port(client->sock));\n\t}\n\tset_env(\"RFB_SERVER_PORT\", str);\n\n\tif (cd) {\n\t\tsprintf(str, \"%d\", cd->login_viewonly);\n\t} else {\n\t\tsprintf(str, \"%d\", -1);\n\t}\n\tset_env(\"RFB_LOGIN_VIEWONLY\", str);\n\n\tif (cd) {\n\t\tsprintf(str, \"%d\", (int) cd->login_time);\n\t} else {\n\t\tsprintf(str, \">%d\", (int) time(NULL));\n\t}\n\tset_env(\"RFB_LOGIN_TIME\", str);\n\n\tsprintf(str, \"%d\", (int) time(NULL));\n\tset_env(\"RFB_CURRENT_TIME\", str);\n\n\tif (!cd || !cd->username || cd->username[0] == '\\0') {\n\t\tset_env(\"RFB_USERNAME\", \"unknown-user\");\n\t} else {\n\t\tset_env(\"RFB_USERNAME\", cd->username);\n\t}\n\t/* \n\t * Better set DISPLAY to the one we are polling, if they\n\t * want something trickier, they can handle on their own\n\t * via environment, etc. \n\t */\n\tif (getenv(\"DISPLAY\")) {\n\t\told_display = strdup(getenv(\"DISPLAY\"));\n\t}\n\n\tif (raw_fb && ! dpy) {\t/* raw_fb hack */\n\t\tset_env(\"DISPLAY\", \"rawfb\");\n\t} else {\n\t\tset_env(\"DISPLAY\", DisplayString(dpy));\n\t}\n\n\t/*\n\t * work out the number of clients (have to use client_count\n\t * since there is deadlock in rfbGetClientIterator) \n\t */\n\tsprintf(str, \"%d\", client_count);\n\tset_env(\"RFB_CLIENT_COUNT\", str);\n\n\t/* gone, accept, afteraccept */\n\tok = 0;\n\tif (!strcmp(mode, \"env\")) {\n\t\treturn 1;\n\t}\n\tif (!strcmp(mode, \"accept\") && cmd_ok(\"accept\")) {\n\t\tok = 1;\n\t}\n\tif (!strcmp(mode, \"afteraccept\") && cmd_ok(\"afteraccept\")) {\n\t\tok = 1;\n\t}\n\tif (!strcmp(mode, \"gone\") && cmd_ok(\"gone\")) {\n\t\tok = 1;\n\t}\n\tif (!strcmp(mode, \"cmd_verify\") && cmd_ok(\"unixpw\")) {\n\t\tok = 1;\n\t}\n\tif (!strcmp(mode, \"read_passwds\") && cmd_ok(\"passwdfile\")) {\n\t\tok = 1;\n\t}\n\tif (!strcmp(mode, \"custom_passwd\") && cmd_ok(\"custom_passwd\")) {\n\t\tok = 1;\n\t}\n\tif (no_external_cmds || !ok) {\n\t\trfbLogEnable(1);\n\t\trfbLog(\"cannot run external commands in -nocmds mode:\\n\");\n\t\trfbLog(\"   \\\"%s\\\"\\n\", cmd);\n\t\trfbLog(\"   exiting.\\n\");\n\t\tclean_up_exit(1);\n\t}\n\trfbLog(\"running command:\\n\");\n\tif (!quiet) {\n\t\tfprintf(stderr, \"\\n  %s\\n\\n\", cmd);\n\t}\n\tclose_exec_fds();\n\n\tif (output != NULL) {\n\t\tFILE *ph;\n\t\tchar line[1024];\n\t\tchar *cmd2 = NULL;\n\t\tchar tmp[] = \"/tmp/x11vnc-tmp.XXXXXX\";\n\t\tint deltmp = 0;\n\n\t\tif (input != NULL) {\n\t\t\tint tmp_fd = mkstemp(tmp);\n\t\t\tif (tmp_fd < 0) {\n\t\t\t\trfbLog(\"mkstemp failed on: %s\\n\", tmp);\n\t\t\t\tclean_up_exit(1);\n\t\t\t}\n\t\t\twrite(tmp_fd, input, len);\n\t\t\tclose(tmp_fd);\n\t\t\tdeltmp = 1;\n\t\t\tcmd2 = (char *) malloc(100 + strlen(tmp) + strlen(cmd));\n\t\t\tsprintf(cmd2, \"/bin/cat %s | %s\", tmp, cmd);\n\t\t\t\n\t\t\tph = popen(cmd2, \"r\");\n\t\t} else {\n\t\t\tph = popen(cmd, \"r\");\n\t\t}\n\t\tif (ph == NULL) {\n\t\t\trfbLog(\"popen(%s) failed\", cmd);\n\t\t\trfbLogPerror(\"popen\");\n\t\t\tclean_up_exit(1);\n\t\t}\n\t\tmemset(line, 0, sizeof(line));\n\t\twhile (fgets(line, sizeof(line), ph) != NULL) {\n\t\t\tint j, k = -1;\n\t\t\tif (0) fprintf(stderr, \"line: %s\", line);\n\t\t\t/* take care to handle embedded nulls */\n\t\t\tfor (j=0; j < (int) sizeof(line); j++) {\n\t\t\t\tif (line[j] != '\\0') {\n\t\t\t\t\tk = j;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (k >= 0) {\n\t\t\t\twrite(fileno(output), line, k+1);\n\t\t\t}\n\t\t\tmemset(line, 0, sizeof(line));\n\t\t}\n\n\t\trc = pclose(ph);\n\n\t\tif (cmd2 != NULL) {\n\t\t\tfree(cmd2);\n\t\t}\n\t\tif (deltmp) {\n\t\t\tunlink(tmp);\n\t\t}\n\t\tgoto got_rc;\n\t} else if (input != NULL) {\n\t\tFILE *ph = popen(cmd, \"w\");\n\t\tif (ph == NULL) {\n\t\t\trfbLog(\"popen(%s) failed\", cmd);\n\t\t\trfbLogPerror(\"popen\");\n\t\t\tclean_up_exit(1);\n\t\t}\n\t\twrite(fileno(ph), input, len);\n\t\trc = pclose(ph);\n\t\tgoto got_rc;\n\t}\n\n#if LIBVNCSERVER_HAVE_FORK\n\t{\n\t\tpid_t pid;\n\t\tstruct sigaction sa, intr, quit;\n\t\tsigset_t omask;\n\n\t\tsa.sa_handler = SIG_IGN;\n\t\tsa.sa_flags = 0;\n\t\tsigemptyset(&sa.sa_mask);\n\t\tsigaction(SIGINT,  &sa, &intr);\n\t\tsigaction(SIGQUIT, &sa, &quit);\n\n\t\tsigaddset(&sa.sa_mask, SIGCHLD);\n\t\tsigprocmask(SIG_BLOCK, &sa.sa_mask, &omask);\n\n\t\tif ((pid = fork()) > 0 || pid == -1) {\n\n\t\t\tif (pid != -1) {\n\t\t\t\twaitpid(pid, &rc, 0);\n\t\t\t}\n\n\t\t\tsigaction(SIGINT,  &intr, (struct sigaction *) NULL);\n\t\t\tsigaction(SIGQUIT, &quit, (struct sigaction *) NULL);\n\t\t\tsigprocmask(SIG_SETMASK, &omask, (sigset_t *) NULL);\n\n\t\t\tif (pid == -1) {\n\t\t\t\tfprintf(stderr, \"could not fork\\n\");\n\t\t\t\trfbLogPerror(\"fork\");\n\t\t\t\trc = system(cmd);\n\t\t\t}\n\t\t} else {\n\t\t\t/* this should close port 5900, etc.. */\n\t\t\tint fd;\n\t\t\tsigaction(SIGINT,  &intr, (struct sigaction *) NULL);\n\t\t\tsigaction(SIGQUIT, &quit, (struct sigaction *) NULL);\n\t\t\tsigprocmask(SIG_SETMASK, &omask, (sigset_t *) NULL);\n\t\t\tfor (fd=3; fd<256; fd++) {\n\t\t\t\tclose(fd);\n\t\t\t}\n/* XXX test more */\n\t\t\tif (!strcmp(mode, \"gone\")) {\n#if HAVE_SETSID\n\t\t\t\tsetsid();\n#else\n\t\t\t\tsetpgrp();\n#endif\n\t\t\t}\n\t\t\texeclp(\"/bin/sh\", \"/bin/sh\", \"-c\", cmd, (char *) NULL);\n\t\t\texit(1);\n\t\t}\n\t}\n#else\n\trc = system(cmd);\n#endif\n\tgot_rc:\n\n\tif (rc >= 256) {\n\t\trc = rc/256;\n\t}\n\trfbLog(\"command returned: %d\\n\", rc);\n\n\tif (old_display) {\n\t\tset_env(\"DISPLAY\", old_display);\n\t\tfree(old_display);\n\t}\n\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "getenv",
          "args": [
            "\"DEBUG_RUN_CMD\""
          ],
          "line": 2482
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_usslpeer",
          "args": [],
          "line": 2477
        },
        "resolved": true,
        "details": {
          "function_name": "get_usslpeer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/user.c",
          "lines": "2340-2374",
          "snippet": "static char *get_usslpeer() {\n\tchar *u = NULL, *upeer = NULL;\n\n\tif (certret_str) {\n\t\tupeer = certret_extract();\n\t}\n\tif (!upeer) {\n\t\treturn NULL;\n\t}\n\trfbLog(\"sslpeer unix username extracted from x509 cert: %s\\n\", upeer);\n\n\tu = (char *) malloc(strlen(upeer+2));\n\tu[0] = '\\0';\n\tif (!strcmp(users_list, \"sslpeer=\")) {\n\t\tsprintf(u, \"+%s\", upeer);\n\t} else {\n\t\tchar *p, *str = strdup(users_list);\n\t\tp = strtok(str + strlen(\"sslpeer=\"), \",\");\n\t\twhile (p) {\n\t\t\tif (!strcmp(p, upeer)) {\n\t\t\t\tsprintf(u, \"+%s\", upeer);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tp = strtok(NULL, \",\");\n\t\t}\n\t\tfree(str);\n\t}\n\tif (u[0] == '\\0') {\n\t\trfbLog(\"sslpeer cannot determine user: %s\\n\", upeer);\n\t\tfree(u);\n\t\treturn NULL;\n\t}\n\tfree(u);\n\treturn upeer;\n}",
          "includes": [
            "#include \"avahi.h\"",
            "#include \"sslhelper.h\"",
            "#include \"remote.h\"",
            "#include \"cursor.h\"",
            "#include \"keyboard.h\"",
            "#include \"inet.h\"",
            "#include \"connections.h\"",
            "#include \"xwrappers.h\"",
            "#include \"sslhelper.h\"",
            "#include \"unixpw.h\"",
            "#include \"screen.h\"",
            "#include \"scan.h\"",
            "#include \"cleanup.h\"",
            "#include \"solid.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void lurk_loop(char *str);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"avahi.h\"\n#include \"sslhelper.h\"\n#include \"remote.h\"\n#include \"cursor.h\"\n#include \"keyboard.h\"\n#include \"inet.h\"\n#include \"connections.h\"\n#include \"xwrappers.h\"\n#include \"sslhelper.h\"\n#include \"unixpw.h\"\n#include \"screen.h\"\n#include \"scan.h\"\n#include \"cleanup.h\"\n#include \"solid.h\"\n#include \"x11vnc.h\"\n\nvoid lurk_loop(char *str);\n\nstatic char *get_usslpeer() {\n\tchar *u = NULL, *upeer = NULL;\n\n\tif (certret_str) {\n\t\tupeer = certret_extract();\n\t}\n\tif (!upeer) {\n\t\treturn NULL;\n\t}\n\trfbLog(\"sslpeer unix username extracted from x509 cert: %s\\n\", upeer);\n\n\tu = (char *) malloc(strlen(upeer+2));\n\tu[0] = '\\0';\n\tif (!strcmp(users_list, \"sslpeer=\")) {\n\t\tsprintf(u, \"+%s\", upeer);\n\t} else {\n\t\tchar *p, *str = strdup(users_list);\n\t\tp = strtok(str + strlen(\"sslpeer=\"), \",\");\n\t\twhile (p) {\n\t\t\tif (!strcmp(p, upeer)) {\n\t\t\t\tsprintf(u, \"+%s\", upeer);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tp = strtok(NULL, \",\");\n\t\t}\n\t\tfree(str);\n\t}\n\tif (u[0] == '\\0') {\n\t\trfbLog(\"sslpeer cannot determine user: %s\\n\", upeer);\n\t\tfree(u);\n\t\treturn NULL;\n\t}\n\tfree(u);\n\treturn upeer;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "users_list",
            "\"sslpeer=\""
          ],
          "line": 2476
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "line2",
            "0",
            "sizeof(line2)"
          ],
          "line": 2474
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "line1",
            "0",
            "sizeof(line1)"
          ],
          "line": 2473
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"avahi.h\"\n#include \"sslhelper.h\"\n#include \"remote.h\"\n#include \"cursor.h\"\n#include \"keyboard.h\"\n#include \"inet.h\"\n#include \"connections.h\"\n#include \"xwrappers.h\"\n#include \"sslhelper.h\"\n#include \"unixpw.h\"\n#include \"screen.h\"\n#include \"scan.h\"\n#include \"cleanup.h\"\n#include \"solid.h\"\n#include \"x11vnc.h\"\n\nvoid lurk_loop(char *str);\nchar *xdmcp_insert = NULL;\nextern char find_display[];\nextern char create_display[];\n\nstatic int do_run_cmd(char *cmd, char *create_cmd, char *users_list_save, int created_disp, int db) {\n\tchar tmp[] = \"/tmp/x11vnc-find_display.XXXXXX\";\n\tchar line1[1024], line2[16384];\n\tchar *q, *usslpeer = NULL;\n\tint n, nodisp = 0, saw_xdmcp = 0;\n\tint tmp_fd = -1;\n\tint internal_cmd = 0;\n\tint tried_switch = 0;\n\n\tmemset(line1, 0, sizeof(line1));\n\tmemset(line2, 0, sizeof(line2));\n\n\tif (users_list && strstr(users_list, \"sslpeer=\") == users_list) {\n\t\tusslpeer = get_usslpeer();\n\t\tif (! usslpeer) {\n\t\t\treturn 0;\n\t\t}\n\t}\n\tif (getenv(\"DEBUG_RUN_CMD\")) db = 1;\n\n\t/* only sets environment variables: */\n\trun_user_command(\"\", latest_client, \"env\", NULL, 0, NULL);\n\n\tif (program_name) {\n\t\tset_env(\"X11VNC_PROG\", program_name);\n\t} else {\n\t\tset_env(\"X11VNC_PROG\", \"x11vnc\");\n\t}\n\n\tif (!strcmp(cmd, \"FINDDISPLAY\") ||\n\t    strstr(cmd, \"FINDCREATEDISPLAY\") == cmd) {\n\t\tchar *nd = \"\";\n\t\tchar *tag = \"\";\n\t\tchar fdout[128];\n\n\t\tinternal_cmd = 1;\n\n\t\ttmp_fd = mkstemp(tmp);\n\n\t\tif (tmp_fd < 0) {\n\t\t\trfbLog(\"wait_for_client: open failed: %s\\n\", tmp);\n\t\t\trfbLogPerror(\"mkstemp\");\n\t\t\tclean_up_exit(1);\n\t\t}\n\t\tchmod(tmp, 0644);\n\t\tif (getenv(\"X11VNC_FINDDISPLAY_ALWAYS_FAILS\")) {\n\t\t\tchar *s = \"#!/bin/sh\\necho _FAIL_\\nexit 1\\n\";\n\t\t\twrite(tmp_fd, s, strlen(s));\n\t\t} else {\n\t\t\twrite(tmp_fd, find_display, strlen(find_display));\n\t\t}\n\t\tclose(tmp_fd);\n\t\tnodisp = 1;\n\n\t\tif (strstr(cmd, \"FINDCREATEDISPLAY\") == cmd) {\n\t\t\tcreate_cmd = build_create_cmd(cmd, &saw_xdmcp, usslpeer, tmp);\n\t\t\tif (db) fprintf(stderr, \"create_cmd: %s\\n\", create_cmd);\n\t\t}\n\t\tif (getenv(\"X11VNC_SKIP_DISPLAY\")) {\n\t\t\tnd = strdup(getenv(\"X11VNC_SKIP_DISPLAY\"));\n\t\t}\n\t\tcheck_nodisplay(&nd, &tag);\n\n\t\tfdout[0] = '\\0';\n\t\tif (getenv(\"FIND_DISPLAY_OUTPUT\")) {\n\t\t\tsnprintf(fdout, sizeof fdout, \" FIND_DISPLAY_OUTPUT='%s' \", getenv(\"FIND_DISPLAY_OUTPUT\"));\n\t\t}\n\n\t\tcmd = (char *) malloc(strlen(\"env X11VNC_SKIP_DISPLAY='' \")\n\t\t    + strlen(nd) + strlen(\" FD_TAG='' \") + strlen(tag) + strlen(tmp) + strlen(\"/bin/sh \") + strlen(fdout) + 1);\n\n\t\tif (strcmp(tag, \"\")) {\n\t\t\tsprintf(cmd, \"env X11VNC_SKIP_DISPLAY='%s' FD_TAG='%s' %s /bin/sh %s\", nd, tag, fdout, tmp);\n\t\t} else {\n\t\t\tsprintf(cmd, \"env X11VNC_SKIP_DISPLAY='%s' %s /bin/sh %s\", nd, fdout, tmp);\n\t\t}\n\t}\n\n\trfbLog(\"wait_for_client: running: %s\\n\", cmd);\n\n\tif (create_cmd != NULL) {\n\t\tif (strstr(create_cmd, \"Xvfb\")) {\n\t\t\tpath_lookup(\"Xvfb\");\n\t\t}\n\t\tif (strstr(create_cmd, \"Xvnc\")) {\n\t\t\tpath_lookup(\"Xvnc\");\n\t\t}\n\t\tif (strstr(create_cmd, \"Xdummy\")) {\n\t\t\tpath_lookup(\"Xdummy\");\n\t\t}\n\t}\n\n\tif (unixpw && !unixpw_nis) {\n\t\tint res = 0, k, j, i;\n\t\tchar line[18000];\n\n\t\tmemset(line, 0, sizeof(line));\n\n\t\tif (unixpw_system_greeter_active == 2) {\n\t\t\trfbLog(\"unixpw_system_greeter: forcing find display failure.\\n\");\n\t\t\tres = 0;\n\t\t} else if (keep_unixpw_user && keep_unixpw_pass) {\n\t\t\tn = sizeof(line);\n\t\t\tif (unixpw_cmd != NULL) {\n\t\t\t\tres = unixpw_cmd_run(keep_unixpw_user,\n\t\t\t\t    keep_unixpw_pass, cmd, line, &n);\n\t\t\t} else {\n\t\t\t\tres = su_verify(keep_unixpw_user,\n\t\t\t\t    keep_unixpw_pass, cmd, line, &n, nodisp);\n\t\t\t}\n\t\t}\n\nif (db) {fprintf(stderr, \"line: \"); write(2, line, n); write(2, \"\\n\", 1); fprintf(stderr, \"res=%d n=%d\\n\", res, n);}\n\t\tif (! res) {\n\t\t\trfbLog(\"wait_for_client: find display cmd failed.\\n\");\n\t\t}\n\n\t\tif (! res && create_cmd) {\n\t\t\tFILE *mt = fopen(tmp, \"w\");\n\t\t\tif (! mt) {\n\t\t\t\trfbLog(\"wait_for_client: open failed: %s\\n\", tmp);\n\t\t\t\trfbLogPerror(\"fopen\");\n\t\t\t\tclean_up_exit(1);\n\t\t\t}\n\t\t\tfprintf(mt, \"%s\", create_display);\n\t\t\tfclose(mt);\n\n\t\t\tfindcreatedisplay = 1;\n\n\t\t\tif (unixpw_cmd != NULL) {\n\t\t\t\t/* let the external unixpw command do it: */\n\t\t\t\tn = sizeof(line);\n\t\t\t\tclose_exec_fds();\n\t\t\t\tres = unixpw_cmd_run(keep_unixpw_user,\n\t\t\t\t    keep_unixpw_pass, create_cmd, line, &n);\n\t\t\t} else if (getuid() != 0 && unixpw_system_greeter_active != 2) {\n\t\t\t\t/* if not root, run as the other user... */\n\t\t\t\tn = sizeof(line);\n\t\t\t\tclose_exec_fds();\n\t\t\t\tres = su_verify(keep_unixpw_user,\n\t\t\t\t    keep_unixpw_pass, create_cmd, line, &n, nodisp);\nif (db) fprintf(stderr, \"c-res=%d n=%d line: '%s'\\n\", res, n, line);\n\n\t\t\t} else {\n\t\t\t\tFILE *p;\n\t\t\t\tclose_exec_fds();\n\t\t\t\tif (unixpw_system_greeter_active == 2) {\n\t\t\t\t\trfbLog(\"unixpw_system_greeter: not trying su_verify() to run\\n\");\n\t\t\t\t\trfbLog(\"unixpw_system_greeter: create display command.\\n\");\n\t\t\t\t}\n\t\t\t\trfbLog(\"wait_for_client: running: %s\\n\", create_cmd);\n\t\t\t\tp = popen(create_cmd, \"r\");\n\t\t\t\tif (! p) {\n\t\t\t\t\trfbLog(\"wait_for_client: popen failed: %s\\n\", create_cmd);\n\t\t\t\t\tres = 0;\n\t\t\t\t} else if (fgets(line1, sizeof line1, p) == NULL) {\n\t\t\t\t\trfbLog(\"wait_for_client: read failed: %s\\n\", create_cmd);\n\t\t\t\t\tres = 0;\n\t\t\t\t} else {\n\t\t\t\t\tn = fread(line2, 1, sizeof line2, p);\n\t\t\t\t\tif (pclose(p) != 0) {\n\t\t\t\t\t\tres = 0;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tstrncpy(line, line1, 100);\n\t\t\t\t\t\tmemcpy(line + strlen(line1), line2, n);\nif (db) fprintf(stderr, \"line1: '%s'\\n\", line1);\n\t\t\t\t\t\tn += strlen(line1);\n\t\t\t\t\t\tcreated_disp = 1;\n\t\t\t\t\t\tres = 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (res && saw_xdmcp && unixpw_system_greeter_active != 2) {\n\t\t\t\txdmcp_insert = strdup(keep_unixpw_user);\n\t\t\t}\n\t\t}\n\n\t\tif (tmp_fd >= 0) {\n\t\t\tunlink(tmp);\n\t\t}\n\n\t\tif (! res) {\n\t\t\trfbLog(\"wait_for_client: cmd failed: %s\\n\", cmd);\n\t\t\tunixpw_msg(\"No DISPLAY found.\", 3);\n\t\t\tclean_up_exit(1);\n\t\t}\n\n\t\t/*\n\t\t * we need to hunt for DISPLAY= since there may be\n\t\t * a login banner or something at the beginning.\n\t\t */\n\t\tq = strstr(line, \"DISPLAY=\");\n\t\tif (! q) {\n\t\t\tq = line;\n\t\t}\n\t\tn -= (q - line);\n\n\t\tfor (k = 0; k < 1024; k++) {\n\t\t\tline1[k] = q[k];\n\t\t\tif (q[k] == '\\n') {\n\t\t\t\tk++;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tn -= k;\n\t\ti = 0;\n\t\tfor (j = 0; j < 16384; j++) {\n\t\t\tif (j < 16384 - 1) {\n\t\t\t\t/* xauth data, assume pty added CR */\n\t\t\t\tif (q[k+j] == '\\r' && q[k+j+1] == '\\n') {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tline2[i] = q[k+j];\n\t\t\ti++;\n\t\t}\nif (db) write(2, line, 100);\nif (db) fprintf(stderr, \"\\n\");\n\n\t} else {\n\t\tFILE *p;\n\t\tint rc;\n\t\tclose_exec_fds();\n\n\t\tif (usslpeer) {\n\t\t\tchar *c;\n\t\t\tif (getuid() == 0) {\n\t\t\t\tc = (char *) malloc(strlen(\"su - '' -c \\\"\")\n\t\t\t\t    + strlen(usslpeer) + strlen(cmd) + 1 + 1);\n\t\t\t\tsprintf(c, \"su - '%s' -c \\\"%s\\\"\", usslpeer, cmd);\n\t\t\t} else {\n\t\t\t\tc = strdup(cmd);\n\t\t\t}\n\t\t\tp = popen(c, \"r\");\n\t\t\tfree(c);\n\t\t\t\n\t\t} else if (unixpw_nis && keep_unixpw_user) {\n\t\t\tchar *c;\n\t\t\tif (getuid() == 0) {\n\t\t\t\tc = (char *) malloc(strlen(\"su - '' -c \\\"\")\n\t\t\t\t    + strlen(keep_unixpw_user) + strlen(cmd) + 1 + 1);\n\t\t\t\tsprintf(c, \"su - '%s' -c \\\"%s\\\"\", keep_unixpw_user, cmd);\n\t\t\t} else {\n\t\t\t\tc = strdup(cmd);\n\t\t\t}\n\t\t\tp = popen(c, \"r\");\n\t\t\tfree(c);\n\t\t\t\n\t\t} else {\n\t\t\tp = popen(cmd, \"r\");\n\t\t}\n\n\t\tif (! p) {\n\t\t\trfbLog(\"wait_for_client: cmd failed: %s\\n\", cmd);\n\t\t\trfbLogPerror(\"popen\");\n\t\t\tif (tmp_fd >= 0) {\n\t\t\t\tunlink(tmp);\n\t\t\t}\n\t\t\tclean_up_exit(1);\n\t\t}\n\t\tif (fgets(line1, sizeof line1, p) == NULL) {\n\t\t\trfbLog(\"wait_for_client: read failed: %s\\n\", cmd);\n\t\t\trfbLogPerror(\"fgets\");\n\t\t\tif (tmp_fd >= 0) {\n\t\t\t\tunlink(tmp);\n\t\t\t}\n\t\t\tclean_up_exit(1);\n\t\t}\n\t\tn = fread(line2, 1, sizeof line2, p);\n\t\trc = pclose(p);\n\n\t\tif (rc != 0) {\n\t\t\trfbLog(\"wait_for_client: find display cmd failed.\\n\");\n\t\t}\n\n\t\tif (create_cmd && rc != 0) {\n\t\t\tFILE *mt = fopen(tmp, \"w\");\n\t\t\tif (! mt) {\n\t\t\t\trfbLog(\"wait_for_client: open failed: %s\\n\", tmp);\n\t\t\t\trfbLogPerror(\"fopen\");\n\t\t\t\tif (tmp_fd >= 0) {\n\t\t\t\t\tunlink(tmp);\n\t\t\t\t}\n\t\t\t\tclean_up_exit(1);\n\t\t\t}\n\t\t\tfprintf(mt, \"%s\", create_display);\n\t\t\tfclose(mt);\n\n\t\t\tfindcreatedisplay = 1;\n\n\t\t\trfbLog(\"wait_for_client: FINDCREATEDISPLAY cmd: %s\\n\", create_cmd);\n\n\t\t\tp = popen(create_cmd, \"r\");\n\t\t\tif (! p) {\n\t\t\t\trfbLog(\"wait_for_client: cmd failed: %s\\n\", create_cmd);\n\t\t\t\trfbLogPerror(\"popen\");\n\t\t\t\tif (tmp_fd >= 0) {\n\t\t\t\t\tunlink(tmp);\n\t\t\t\t}\n\t\t\t\tclean_up_exit(1);\n\t\t\t}\n\t\t\tif (fgets(line1, sizeof line1, p) == NULL) {\n\t\t\t\trfbLog(\"wait_for_client: read failed: %s\\n\", create_cmd);\n\t\t\t\trfbLogPerror(\"fgets\");\n\t\t\t\tif (tmp_fd >= 0) {\n\t\t\t\t\tunlink(tmp);\n\t\t\t\t}\n\t\t\t\tclean_up_exit(1);\n\t\t\t}\n\t\t\tn = fread(line2, 1, sizeof line2, p);\n\t\t\tpclose(p);\n\t\t}\n\t\tif (tmp_fd >= 0) {\n\t\t\tunlink(tmp);\n\t\t}\n\t}\n\nif (db) fprintf(stderr, \"line1=%s\\n\", line1);\n\n\tif (strstr(line1, \"DISPLAY=\") != line1) {\n\t\trfbLog(\"wait_for_client: bad reply '%s'\\n\", line1);\n\t\tif (unixpw) {\n\t\t\tunixpw_msg(\"No DISPLAY found.\", 3);\n\t\t}\n\t\tclean_up_exit(1);\n\t}\n\n\n\tif (strstr(line1, \",VT=\")) {\n\t\tint vt;\n\t\tchar *t = strstr(line1, \",VT=\");\n\t\tvt = atoi(t + strlen(\",VT=\"));\n\t\t*t = '\\0';\n\t\tif (7 <= vt && vt <= 15) {\n\t\t\tdo_chvt(vt);\n\t\t}\n\t} else if (strstr(line1, \",XPID=\")) {\n\t\tint i, pvt, vt = -1;\n\t\tchar *t = strstr(line1, \",XPID=\");\n\t\tpvt = atoi(t + strlen(\",XPID=\"));\n\t\t*t = '\\0';\n\t\tif (pvt > 0) {\n\t\t\tfor (i=3; i <= 10; i++) {\n\t\t\t\tint k;\n\t\t\t\tchar proc[100];\n\t\t\t\tchar buf[100];\n\t\t\t\tsprintf(proc, \"/proc/%d/fd/%d\", pvt, i);\nif (db) fprintf(stderr, \"%d -- %s\\n\", i, proc);\n\t\t\t\tfor (k=0; k < 100; k++) {\n\t\t\t\t\tbuf[k] = '\\0';\n\t\t\t\t}\n\t\n\t\t\t\tif (readlink(proc, buf, sizeof buf) != -1) {\n\t\t\t\t\tbuf[100-1] = '\\0';\nif (db) fprintf(stderr, \"%d -- %s -- %s\\n\", i, proc, buf);\n\t\t\t\t\tif (strstr(buf, \"/dev/tty\") == buf) {\n\t\t\t\t\t\tvt = atoi(buf + strlen(\"/dev/tty\"));\n\t\t\t\t\t\tif (vt > 0) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (7 <= vt && vt <= 12) {\n\t\t\tdo_chvt(vt);\n\t\t}\n\t}\n\n\tuse_dpy = strdup(line1 + strlen(\"DISPLAY=\"));\n\tq = use_dpy;\n\twhile (*q != '\\0') {\n\t\tif (*q == '\\n' || *q == '\\r') *q = '\\0';\n\t\tq++;\n\t}\n\tif (line2[0] != '\\0') {\n\t\tif (strstr(line2, \"XAUTHORITY=\") == line2) {\n\t\t\tq = line2;\n\t\t\twhile (*q != '\\0') {\n\t\t\t\tif (*q == '\\n' || *q == '\\r') *q = '\\0';\n\t\t\t\tq++;\n\t\t\t}\n\t\t\tif (auth_file) {\n\t\t\t\tfree(auth_file);\n\t\t\t}\n\t\t\tauth_file = strdup(line2 + strlen(\"XAUTHORITY=\"));\n\n\t\t} else {\n\t\t\txauth_raw_data = (char *)malloc(n);\n\t\t\txauth_raw_len = n;\n\t\t\tmemcpy(xauth_raw_data, line2, n);\nif (db) {fprintf(stderr, \"xauth_raw_len: %d\\n\", n);\nwrite(2, xauth_raw_data, n);\nfprintf(stderr, \"\\n\");}\n\t\t}\n\t}\n\n\tif (!tried_switch) {\n\t\tdo_try_switch(usslpeer, users_list_save);\n\t\ttried_switch = 1;\n\t}\n\n\tif (unixpw) {\n\t\t/* Some cleanup and messaging for -unixpw case: */\n\t\tchar str[32];\n\n\t\tif (keep_unixpw_user && keep_unixpw_pass) {\n\t\t\tstrzero(keep_unixpw_user);\n\t\t\tstrzero(keep_unixpw_pass);\n\t\t\tkeep_unixpw = 0;\n\t\t}\n\n\t\tif (created_disp) {\n\t\t\tsnprintf(str, sizeof str, \"Created DISPLAY %s\", use_dpy);\n\t\t} else {\n\t\t\tsnprintf(str, sizeof str, \"Using DISPLAY %s\", use_dpy);\n\t\t}\n\t\tunixpw_msg(str, 2);\n\t}\n\treturn 1;\n}"
  },
  {
    "function_name": "path_lookup",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/user.c",
    "lines": "2424-2462",
    "snippet": "static void path_lookup(char *prog) {\n\t/* see create_display script */\n\tchar *create_display_extra = \"/usr/X11R6/bin:/usr/bin/X11:/usr/openwin/bin:/usr/dt/bin:/opt/kde4/bin:/opt/kde3/bin:/opt/gnome/bin:/usr/bin:/bin:/usr/sfw/bin:/usr/local/bin\";\n\tchar *path, *try, *p;\n\tint found = 0, len = strlen(create_display_extra);\n\n\tif (getenv(\"PATH\")) {\n\t\tlen += strlen(getenv(\"PATH\")) + 1;\n\t\tpath = (char *) malloc((len+1) * sizeof(char));\n\t\tsprintf(path, \"%s:%s\", getenv(\"PATH\"), create_display_extra);\n\t} else {\n\t\tpath = (char *) malloc((len+1) * sizeof(char));\n\t\tsprintf(path, \"%s\", create_display_extra);\n\t}\n\ttry = (char *) malloc((len+2+strlen(prog)) * sizeof(char));\n\n\tp = strtok(path, \":\");\n\twhile (p) {\n\t\tstruct stat sbuf;\n\n\t\tsprintf(try, \"%s/%s\", p, prog);\n\t\tif (stat(try, &sbuf) == 0) {\n\t\t\tfound = 1;\n\t\t\tbreak;\n\t\t}\n\t\tp = strtok(NULL, \":\");\n\t}\n\n\tfree(path);\n\tfree(try);\n\n\tif (!found) {\n\t\tfprintf(stderr, \"\\n\");\n\t\tfprintf(stderr, \"The program \\\"%s\\\" could not be found in PATH and standard locations.\\n\", prog);\n\t\tfprintf(stderr, \"You probably need to install a package that provides the \\\"%s\\\" program.\\n\", prog);\n\t\tfprintf(stderr, \"Without it FINDCREATEDISPLAY mode may not be able to create an X display.\\n\");\n\t\tfprintf(stderr, \"\\n\");\n\t}\n}",
    "includes": [
      "#include \"avahi.h\"",
      "#include \"sslhelper.h\"",
      "#include \"remote.h\"",
      "#include \"cursor.h\"",
      "#include \"keyboard.h\"",
      "#include \"inet.h\"",
      "#include \"connections.h\"",
      "#include \"xwrappers.h\"",
      "#include \"sslhelper.h\"",
      "#include \"unixpw.h\"",
      "#include \"screen.h\"",
      "#include \"scan.h\"",
      "#include \"cleanup.h\"",
      "#include \"solid.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "rfbBool custom_passwd_check(rfbClientPtr cl, const char *response, int len);",
      "extern char create_display[];"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"\\n\""
          ],
          "line": 2460
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Without it FINDCREATEDISPLAY mode may not be able to create an X display.\\n\""
          ],
          "line": 2459
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"You probably need to install a package that provides the \\\"%s\\\" program.\\n\"",
            "prog"
          ],
          "line": 2458
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"The program \\\"%s\\\" could not be found in PATH and standard locations.\\n\"",
            "prog"
          ],
          "line": 2457
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"\\n\""
          ],
          "line": 2456
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "try"
          ],
          "line": 2453
        },
        "resolved": true,
        "details": {
          "function_name": "free_rect",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/userinput.c",
          "lines": "6200-6247",
          "snippet": "int free_rect(int idx) {\n\tint n, ok = 0;\n\tsraRegionPtr r1, r2;\n\tint x, y, w, h;\n\n\tif (idx < 0 || idx >= cache_list_num) {\nif (0) fprintf(stderr, \"free_rect: bad index: %d\\n\", idx);\n\t\tclean_up_exit(1);\n\t}\n\n\tx = cache_list[idx].bs_x;\n\ty = cache_list[idx].bs_y;\n\tw = cache_list[idx].bs_w;\n\th = cache_list[idx].bs_h;\n\n\tif (x < 0) {\n\t\tCLEAR(idx);\nif (dnow() > last_client + 5 && ncdb) fprintf(stderr, \"free_rect: already bs_x invalidated: %d bs_x: %d\\n\", idx, x);\n\t\treturn 1;\n\t}\n\n\tr2 = sraRgnCreateRect(x, y, x+w, y+h);\n\n\tn = get_bs_n(y);\n\tif (n >= 0) {\n\t\tr1 = rect_reg[n];\n\t\tsraRgnOr(r1, r2);\n\t\tok = 1;\n\t}\n\n\tif (zero_rects) {\n\t\tsraRgnOr(zero_rects, r2);\n\t\tx = cache_list[idx].su_x;\n\t\ty = cache_list[idx].su_y;\n\t\tw = cache_list[idx].su_w;\n\t\th = cache_list[idx].su_h;\n\t\tif (x >= 0) {\n\t\t\tsraRgnDestroy(r2);\n\t\t\tr2 = sraRgnCreateRect(x, y, x+w, y+h);\n\t\t\tsraRgnOr(zero_rects, r2);\n\t\t}\n\t}\n\tsraRgnDestroy(r2);\n\n\tCLEAR(idx);\nif (! ok && ncdb) fprintf(stderr, \"**** free_rect: not-found %d\\n\", idx);\n\treturn ok;\n}",
          "includes": [
            "#include \"default8x16.h\"",
            "#include \"connections.h\"",
            "#include \"screen.h\"",
            "#include \"cursor.h\"",
            "#include \"macosxCGS.h\"",
            "#include \"macosx.h\"",
            "#include \"unixpw.h\"",
            "#include \"8to24.h\"",
            "#include \"xrandr.h\"",
            "#include \"solid.h\"",
            "#include \"keyboard.h\"",
            "#include \"rates.h\"",
            "#include \"pointer.h\"",
            "#include \"cleanup.h\"",
            "#include \"scan.h\"",
            "#include \"user.h\"",
            "#include \"xevents.h\"",
            "#include \"win_utils.h\"",
            "#include \"xinerama.h\"",
            "#include \"xrecord.h\"",
            "#include \"xdamage.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void mark_for_xdamage(int x, int y, int w, int h);",
            "void set_xdamage_mark(int x, int y, int w, int h);",
            "int find_rect(int idx, int x, int y, int w, int h);",
            "winattr_t *cache_list;",
            "int clipped(int idx);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"default8x16.h\"\n#include \"connections.h\"\n#include \"screen.h\"\n#include \"cursor.h\"\n#include \"macosxCGS.h\"\n#include \"macosx.h\"\n#include \"unixpw.h\"\n#include \"8to24.h\"\n#include \"xrandr.h\"\n#include \"solid.h\"\n#include \"keyboard.h\"\n#include \"rates.h\"\n#include \"pointer.h\"\n#include \"cleanup.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"xevents.h\"\n#include \"win_utils.h\"\n#include \"xinerama.h\"\n#include \"xrecord.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nvoid mark_for_xdamage(int x, int y, int w, int h);\nvoid set_xdamage_mark(int x, int y, int w, int h);\nint find_rect(int idx, int x, int y, int w, int h);\nwinattr_t *cache_list;\nint clipped(int idx);\n\nint free_rect(int idx) {\n\tint n, ok = 0;\n\tsraRegionPtr r1, r2;\n\tint x, y, w, h;\n\n\tif (idx < 0 || idx >= cache_list_num) {\nif (0) fprintf(stderr, \"free_rect: bad index: %d\\n\", idx);\n\t\tclean_up_exit(1);\n\t}\n\n\tx = cache_list[idx].bs_x;\n\ty = cache_list[idx].bs_y;\n\tw = cache_list[idx].bs_w;\n\th = cache_list[idx].bs_h;\n\n\tif (x < 0) {\n\t\tCLEAR(idx);\nif (dnow() > last_client + 5 && ncdb) fprintf(stderr, \"free_rect: already bs_x invalidated: %d bs_x: %d\\n\", idx, x);\n\t\treturn 1;\n\t}\n\n\tr2 = sraRgnCreateRect(x, y, x+w, y+h);\n\n\tn = get_bs_n(y);\n\tif (n >= 0) {\n\t\tr1 = rect_reg[n];\n\t\tsraRgnOr(r1, r2);\n\t\tok = 1;\n\t}\n\n\tif (zero_rects) {\n\t\tsraRgnOr(zero_rects, r2);\n\t\tx = cache_list[idx].su_x;\n\t\ty = cache_list[idx].su_y;\n\t\tw = cache_list[idx].su_w;\n\t\th = cache_list[idx].su_h;\n\t\tif (x >= 0) {\n\t\t\tsraRgnDestroy(r2);\n\t\t\tr2 = sraRgnCreateRect(x, y, x+w, y+h);\n\t\t\tsraRgnOr(zero_rects, r2);\n\t\t}\n\t}\n\tsraRgnDestroy(r2);\n\n\tCLEAR(idx);\nif (! ok && ncdb) fprintf(stderr, \"**** free_rect: not-found %d\\n\", idx);\n\treturn ok;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strtok",
          "args": [
            "NULL",
            "\":\""
          ],
          "line": 2449
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "stat",
          "args": [
            "try",
            "&sbuf"
          ],
          "line": 2445
        },
        "resolved": true,
        "details": {
          "function_name": "grab_state",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/connections.c",
          "lines": "3178-3224",
          "snippet": "void grab_state(int *ptr_grabbed, int *kbd_grabbed) {\n\tint rcp, rck;\n\tdouble t0, t1;\n\tdouble ta, tb, tc;\n\t*ptr_grabbed = -1;\n\t*kbd_grabbed = -1;\n\n\tif (!dpy) {\n\t\treturn;\n\t}\n\t*ptr_grabbed = 0;\n\t*kbd_grabbed = 0;\n\n#if !NO_X11\n\tX_LOCK;\n\n\tXSync(dpy, False);\n\n\tta = t0 = dnow();\n\n\trcp = XGrabPointer(dpy, window, False, 0, GrabModeAsync, GrabModeAsync, None, None, CurrentTime);\n\tXUngrabPointer(dpy, CurrentTime);\n\n\ttb = dnow();\n\t\n\trck = XGrabKeyboard(dpy, window, False, GrabModeAsync, GrabModeAsync, CurrentTime);\n\tXUngrabKeyboard(dpy, CurrentTime);\n\n\ttc = dnow();\n\n\tXSync(dpy, False);\n\n\tt1 = dnow();\n\n\tX_UNLOCK;\n\tif (rcp == AlreadyGrabbed || rcp == GrabFrozen) {\n\t\t*ptr_grabbed = 1;\n\t}\n\tif (rck == AlreadyGrabbed || rck == GrabFrozen) {\n\t\t*kbd_grabbed = 1;\n\t}\n\tif (rc_npieces < 10) {\n\t\trfbLog(\"grab_state: checked %d,%d in %.6f sec (%.6f %.6f)\\n\",\n\t\t    *ptr_grabbed, *kbd_grabbed, t1-t0, tb-ta, tc-tb);\n\t}\n#endif\n}",
          "includes": [
            "#include \"xi2_devices.h\"",
            "#include \"xrandr.h\"",
            "#include \"pointer.h\"",
            "#include \"userinput.h\"",
            "#include \"macosxCG.h\"",
            "#include \"macosx.h\"",
            "#include \"win_utils.h\"",
            "#include \"xevents.h\"",
            "#include \"xwrappers.h\"",
            "#include \"sslhelper.h\"",
            "#include \"sslcmds.h\"",
            "#include \"scan.h\"",
            "#include \"user.h\"",
            "#include \"unixpw.h\"",
            "#include \"screen.h\"",
            "#include \"rates.h\"",
            "#include \"solid.h\"",
            "#include \"gui.h\"",
            "#include \"cleanup.h\"",
            "#include \"keyboard.h\"",
            "#include \"remote.h\"",
            "#include \"inet.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void grab_state(int *ptr_grabbed, int *kbd_grabbed);",
            "extern int rc_npieces;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xi2_devices.h\"\n#include \"xrandr.h\"\n#include \"pointer.h\"\n#include \"userinput.h\"\n#include \"macosxCG.h\"\n#include \"macosx.h\"\n#include \"win_utils.h\"\n#include \"xevents.h\"\n#include \"xwrappers.h\"\n#include \"sslhelper.h\"\n#include \"sslcmds.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"unixpw.h\"\n#include \"screen.h\"\n#include \"rates.h\"\n#include \"solid.h\"\n#include \"gui.h\"\n#include \"cleanup.h\"\n#include \"keyboard.h\"\n#include \"remote.h\"\n#include \"inet.h\"\n#include \"x11vnc.h\"\n\nvoid grab_state(int *ptr_grabbed, int *kbd_grabbed);\nextern int rc_npieces;\n\nvoid grab_state(int *ptr_grabbed, int *kbd_grabbed) {\n\tint rcp, rck;\n\tdouble t0, t1;\n\tdouble ta, tb, tc;\n\t*ptr_grabbed = -1;\n\t*kbd_grabbed = -1;\n\n\tif (!dpy) {\n\t\treturn;\n\t}\n\t*ptr_grabbed = 0;\n\t*kbd_grabbed = 0;\n\n#if !NO_X11\n\tX_LOCK;\n\n\tXSync(dpy, False);\n\n\tta = t0 = dnow();\n\n\trcp = XGrabPointer(dpy, window, False, 0, GrabModeAsync, GrabModeAsync, None, None, CurrentTime);\n\tXUngrabPointer(dpy, CurrentTime);\n\n\ttb = dnow();\n\t\n\trck = XGrabKeyboard(dpy, window, False, GrabModeAsync, GrabModeAsync, CurrentTime);\n\tXUngrabKeyboard(dpy, CurrentTime);\n\n\ttc = dnow();\n\n\tXSync(dpy, False);\n\n\tt1 = dnow();\n\n\tX_UNLOCK;\n\tif (rcp == AlreadyGrabbed || rcp == GrabFrozen) {\n\t\t*ptr_grabbed = 1;\n\t}\n\tif (rck == AlreadyGrabbed || rck == GrabFrozen) {\n\t\t*kbd_grabbed = 1;\n\t}\n\tif (rc_npieces < 10) {\n\t\trfbLog(\"grab_state: checked %d,%d in %.6f sec (%.6f %.6f)\\n\",\n\t\t    *ptr_grabbed, *kbd_grabbed, t1-t0, tb-ta, tc-tb);\n\t}\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "try",
            "\"%s/%s\"",
            "p",
            "prog"
          ],
          "line": 2444
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strtok",
          "args": [
            "path",
            "\":\""
          ],
          "line": 2440
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "(len+2+strlen(prog)) * sizeof(char)"
          ],
          "line": 2438
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "prog"
          ],
          "line": 2438
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "path",
            "\"%s\"",
            "create_display_extra"
          ],
          "line": 2436
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "(len+1) * sizeof(char)"
          ],
          "line": 2435
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "path",
            "\"%s:%s\"",
            "getenv(\"PATH\")",
            "create_display_extra"
          ],
          "line": 2433
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getenv",
          "args": [
            "\"PATH\""
          ],
          "line": 2433
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "(len+1) * sizeof(char)"
          ],
          "line": 2432
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "getenv(\"PATH\")"
          ],
          "line": 2431
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getenv",
          "args": [
            "\"PATH\""
          ],
          "line": 2431
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getenv",
          "args": [
            "\"PATH\""
          ],
          "line": 2430
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "create_display_extra"
          ],
          "line": 2428
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"avahi.h\"\n#include \"sslhelper.h\"\n#include \"remote.h\"\n#include \"cursor.h\"\n#include \"keyboard.h\"\n#include \"inet.h\"\n#include \"connections.h\"\n#include \"xwrappers.h\"\n#include \"sslhelper.h\"\n#include \"unixpw.h\"\n#include \"screen.h\"\n#include \"scan.h\"\n#include \"cleanup.h\"\n#include \"solid.h\"\n#include \"x11vnc.h\"\n\nrfbBool custom_passwd_check(rfbClientPtr cl, const char *response, int len);\nextern char create_display[];\n\nstatic void path_lookup(char *prog) {\n\t/* see create_display script */\n\tchar *create_display_extra = \"/usr/X11R6/bin:/usr/bin/X11:/usr/openwin/bin:/usr/dt/bin:/opt/kde4/bin:/opt/kde3/bin:/opt/gnome/bin:/usr/bin:/bin:/usr/sfw/bin:/usr/local/bin\";\n\tchar *path, *try, *p;\n\tint found = 0, len = strlen(create_display_extra);\n\n\tif (getenv(\"PATH\")) {\n\t\tlen += strlen(getenv(\"PATH\")) + 1;\n\t\tpath = (char *) malloc((len+1) * sizeof(char));\n\t\tsprintf(path, \"%s:%s\", getenv(\"PATH\"), create_display_extra);\n\t} else {\n\t\tpath = (char *) malloc((len+1) * sizeof(char));\n\t\tsprintf(path, \"%s\", create_display_extra);\n\t}\n\ttry = (char *) malloc((len+2+strlen(prog)) * sizeof(char));\n\n\tp = strtok(path, \":\");\n\twhile (p) {\n\t\tstruct stat sbuf;\n\n\t\tsprintf(try, \"%s/%s\", p, prog);\n\t\tif (stat(try, &sbuf) == 0) {\n\t\t\tfound = 1;\n\t\t\tbreak;\n\t\t}\n\t\tp = strtok(NULL, \":\");\n\t}\n\n\tfree(path);\n\tfree(try);\n\n\tif (!found) {\n\t\tfprintf(stderr, \"\\n\");\n\t\tfprintf(stderr, \"The program \\\"%s\\\" could not be found in PATH and standard locations.\\n\", prog);\n\t\tfprintf(stderr, \"You probably need to install a package that provides the \\\"%s\\\" program.\\n\", prog);\n\t\tfprintf(stderr, \"Without it FINDCREATEDISPLAY mode may not be able to create an X display.\\n\");\n\t\tfprintf(stderr, \"\\n\");\n\t}\n}"
  },
  {
    "function_name": "do_try_switch",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/user.c",
    "lines": "2376-2422",
    "snippet": "static void do_try_switch(char *usslpeer, char *users_list_save) {\n\tif (unixpw_system_greeter_active == 2) {\n\t\trfbLog(\"unixpw_system_greeter: not trying switch to user '%s'\\n\", usslpeer ? usslpeer : \"\");\n\t\treturn;\n\t}\n\tif (usslpeer) {\n\t\tchar *u = (char *) malloc(strlen(usslpeer+2));\n\t\tsprintf(u, \"+%s\", usslpeer);\n\t\tif (switch_user(u, 0)) {\n\t\t\trfbLog(\"sslpeer switched to user: %s\\n\", usslpeer);\n\t\t} else {\n\t\t\trfbLog(\"sslpeer failed to switch to user: %s\\n\", usslpeer);\n\t\t}\n\t\tfree(u);\n\t\t\n\t} else if (users_list_save && keep_unixpw_user) {\n\t\tchar *user = keep_unixpw_user;\n\t\tchar *u = (char *)malloc(strlen(user)+1); \n\n\t\tusers_list = users_list_save;\n\n\t\tu[0] = '\\0';\n\t\tif (!strcmp(users_list, \"unixpw=\")) {\n\t\t\tsprintf(u, \"+%s\", user);\n\t\t} else {\n\t\t\tchar *p, *str = strdup(users_list);\n\t\t\tp = strtok(str + strlen(\"unixpw=\"), \",\");\n\t\t\twhile (p) {\n\t\t\t\tif (!strcmp(p, user)) {\n\t\t\t\t\tsprintf(u, \"+%s\", user);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tp = strtok(NULL, \",\");\n\t\t\t}\n\t\t\tfree(str);\n\t\t}\n\t\t\n\t\tif (u[0] == '\\0') {\n\t\t\trfbLog(\"unixpw_accept skipping switch to user: %s (drc)\\n\", user);\n\t\t} else if (switch_user(u, 0)) {\n\t\t\trfbLog(\"unixpw_accept switched to user: %s (drc)\\n\", user);\n\t\t} else {\n\t\t\trfbLog(\"unixpw_accept failed to switch to user: %s (drc)\\n\", user);\n\t\t}\n\t\tfree(u);\n\t}\n}",
    "includes": [
      "#include \"avahi.h\"",
      "#include \"sslhelper.h\"",
      "#include \"remote.h\"",
      "#include \"cursor.h\"",
      "#include \"keyboard.h\"",
      "#include \"inet.h\"",
      "#include \"connections.h\"",
      "#include \"xwrappers.h\"",
      "#include \"sslhelper.h\"",
      "#include \"unixpw.h\"",
      "#include \"screen.h\"",
      "#include \"scan.h\"",
      "#include \"cleanup.h\"",
      "#include \"solid.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "void lurk_loop(char *str);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "u"
          ],
          "line": 2420
        },
        "resolved": true,
        "details": {
          "function_name": "free_rect",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/userinput.c",
          "lines": "6200-6247",
          "snippet": "int free_rect(int idx) {\n\tint n, ok = 0;\n\tsraRegionPtr r1, r2;\n\tint x, y, w, h;\n\n\tif (idx < 0 || idx >= cache_list_num) {\nif (0) fprintf(stderr, \"free_rect: bad index: %d\\n\", idx);\n\t\tclean_up_exit(1);\n\t}\n\n\tx = cache_list[idx].bs_x;\n\ty = cache_list[idx].bs_y;\n\tw = cache_list[idx].bs_w;\n\th = cache_list[idx].bs_h;\n\n\tif (x < 0) {\n\t\tCLEAR(idx);\nif (dnow() > last_client + 5 && ncdb) fprintf(stderr, \"free_rect: already bs_x invalidated: %d bs_x: %d\\n\", idx, x);\n\t\treturn 1;\n\t}\n\n\tr2 = sraRgnCreateRect(x, y, x+w, y+h);\n\n\tn = get_bs_n(y);\n\tif (n >= 0) {\n\t\tr1 = rect_reg[n];\n\t\tsraRgnOr(r1, r2);\n\t\tok = 1;\n\t}\n\n\tif (zero_rects) {\n\t\tsraRgnOr(zero_rects, r2);\n\t\tx = cache_list[idx].su_x;\n\t\ty = cache_list[idx].su_y;\n\t\tw = cache_list[idx].su_w;\n\t\th = cache_list[idx].su_h;\n\t\tif (x >= 0) {\n\t\t\tsraRgnDestroy(r2);\n\t\t\tr2 = sraRgnCreateRect(x, y, x+w, y+h);\n\t\t\tsraRgnOr(zero_rects, r2);\n\t\t}\n\t}\n\tsraRgnDestroy(r2);\n\n\tCLEAR(idx);\nif (! ok && ncdb) fprintf(stderr, \"**** free_rect: not-found %d\\n\", idx);\n\treturn ok;\n}",
          "includes": [
            "#include \"default8x16.h\"",
            "#include \"connections.h\"",
            "#include \"screen.h\"",
            "#include \"cursor.h\"",
            "#include \"macosxCGS.h\"",
            "#include \"macosx.h\"",
            "#include \"unixpw.h\"",
            "#include \"8to24.h\"",
            "#include \"xrandr.h\"",
            "#include \"solid.h\"",
            "#include \"keyboard.h\"",
            "#include \"rates.h\"",
            "#include \"pointer.h\"",
            "#include \"cleanup.h\"",
            "#include \"scan.h\"",
            "#include \"user.h\"",
            "#include \"xevents.h\"",
            "#include \"win_utils.h\"",
            "#include \"xinerama.h\"",
            "#include \"xrecord.h\"",
            "#include \"xdamage.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void mark_for_xdamage(int x, int y, int w, int h);",
            "void set_xdamage_mark(int x, int y, int w, int h);",
            "int find_rect(int idx, int x, int y, int w, int h);",
            "winattr_t *cache_list;",
            "int clipped(int idx);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"default8x16.h\"\n#include \"connections.h\"\n#include \"screen.h\"\n#include \"cursor.h\"\n#include \"macosxCGS.h\"\n#include \"macosx.h\"\n#include \"unixpw.h\"\n#include \"8to24.h\"\n#include \"xrandr.h\"\n#include \"solid.h\"\n#include \"keyboard.h\"\n#include \"rates.h\"\n#include \"pointer.h\"\n#include \"cleanup.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"xevents.h\"\n#include \"win_utils.h\"\n#include \"xinerama.h\"\n#include \"xrecord.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nvoid mark_for_xdamage(int x, int y, int w, int h);\nvoid set_xdamage_mark(int x, int y, int w, int h);\nint find_rect(int idx, int x, int y, int w, int h);\nwinattr_t *cache_list;\nint clipped(int idx);\n\nint free_rect(int idx) {\n\tint n, ok = 0;\n\tsraRegionPtr r1, r2;\n\tint x, y, w, h;\n\n\tif (idx < 0 || idx >= cache_list_num) {\nif (0) fprintf(stderr, \"free_rect: bad index: %d\\n\", idx);\n\t\tclean_up_exit(1);\n\t}\n\n\tx = cache_list[idx].bs_x;\n\ty = cache_list[idx].bs_y;\n\tw = cache_list[idx].bs_w;\n\th = cache_list[idx].bs_h;\n\n\tif (x < 0) {\n\t\tCLEAR(idx);\nif (dnow() > last_client + 5 && ncdb) fprintf(stderr, \"free_rect: already bs_x invalidated: %d bs_x: %d\\n\", idx, x);\n\t\treturn 1;\n\t}\n\n\tr2 = sraRgnCreateRect(x, y, x+w, y+h);\n\n\tn = get_bs_n(y);\n\tif (n >= 0) {\n\t\tr1 = rect_reg[n];\n\t\tsraRgnOr(r1, r2);\n\t\tok = 1;\n\t}\n\n\tif (zero_rects) {\n\t\tsraRgnOr(zero_rects, r2);\n\t\tx = cache_list[idx].su_x;\n\t\ty = cache_list[idx].su_y;\n\t\tw = cache_list[idx].su_w;\n\t\th = cache_list[idx].su_h;\n\t\tif (x >= 0) {\n\t\t\tsraRgnDestroy(r2);\n\t\t\tr2 = sraRgnCreateRect(x, y, x+w, y+h);\n\t\t\tsraRgnOr(zero_rects, r2);\n\t\t}\n\t}\n\tsraRgnDestroy(r2);\n\n\tCLEAR(idx);\nif (! ok && ncdb) fprintf(stderr, \"**** free_rect: not-found %d\\n\", idx);\n\treturn ok;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"unixpw_accept failed to switch to user: %s (drc)\\n\"",
            "user"
          ],
          "line": 2418
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"unixpw_accept switched to user: %s (drc)\\n\"",
            "user"
          ],
          "line": 2416
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "switch_user",
          "args": [
            "u",
            "0"
          ],
          "line": 2415
        },
        "resolved": true,
        "details": {
          "function_name": "switch_user",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/user.c",
          "lines": "715-757",
          "snippet": "int switch_user(char *user, int fb_mode) {\n\t/* NO strtoks */\n\tint doit = 0;\n\tuid_t uid = 0;\n\tgid_t gid = 0;\n\tchar *name, *home;\n\n\tif (*user == '+') {\n\t\tdoit = 1;\n\t\tuser++;\n\t}\n\n\tssl_helper_pid(0, -2);\t/* waitall */\n\n\tif (strstr(user, \"guess=\") == user) {\n\t\treturn guess_user_and_switch(user, fb_mode);\n\t}\n\n\tuser2uid(user, &uid, &gid, &name, &home);\n\n\tif (uid == (uid_t) -1 || uid == 0) {\n\t\treturn 0;\n\t}\n\tif (gid == 0) {\n\t\treturn 0;\n\t}\n\n\tif (! doit && dpy) {\n\t\t/* see if this display works: */\n\t\tchar *dstr = DisplayString(dpy);\n\t\tdoit = try_user_and_display(uid, gid, dstr);\n\t}\n\n\tif (doit) {\n\t\tint rc = switch_user_env(uid, gid, name, home, fb_mode);\n\t\tif (rc) {\n\t\t\tstarted_as_root = 2;\n\t\t}\n\t\treturn rc;\n\t} else {\n\t\treturn 0;\n\t}\n}",
          "includes": [
            "#include \"avahi.h\"",
            "#include \"sslhelper.h\"",
            "#include \"remote.h\"",
            "#include \"cursor.h\"",
            "#include \"keyboard.h\"",
            "#include \"inet.h\"",
            "#include \"connections.h\"",
            "#include \"xwrappers.h\"",
            "#include \"sslhelper.h\"",
            "#include \"unixpw.h\"",
            "#include \"screen.h\"",
            "#include \"scan.h\"",
            "#include \"cleanup.h\"",
            "#include \"solid.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int switch_user(char *user, int fb_mode);",
            "static void user2uid(char *user, uid_t *uid, gid_t *gid, char **name, char **home);",
            "static int guess_user_and_switch(char *str, int fb_mode);",
            "static int switch_user_env(uid_t uid, gid_t gid, char *name, char *home, int fb_mode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"avahi.h\"\n#include \"sslhelper.h\"\n#include \"remote.h\"\n#include \"cursor.h\"\n#include \"keyboard.h\"\n#include \"inet.h\"\n#include \"connections.h\"\n#include \"xwrappers.h\"\n#include \"sslhelper.h\"\n#include \"unixpw.h\"\n#include \"screen.h\"\n#include \"scan.h\"\n#include \"cleanup.h\"\n#include \"solid.h\"\n#include \"x11vnc.h\"\n\nint switch_user(char *user, int fb_mode);\nstatic void user2uid(char *user, uid_t *uid, gid_t *gid, char **name, char **home);\nstatic int guess_user_and_switch(char *str, int fb_mode);\nstatic int switch_user_env(uid_t uid, gid_t gid, char *name, char *home, int fb_mode);\n\nint switch_user(char *user, int fb_mode) {\n\t/* NO strtoks */\n\tint doit = 0;\n\tuid_t uid = 0;\n\tgid_t gid = 0;\n\tchar *name, *home;\n\n\tif (*user == '+') {\n\t\tdoit = 1;\n\t\tuser++;\n\t}\n\n\tssl_helper_pid(0, -2);\t/* waitall */\n\n\tif (strstr(user, \"guess=\") == user) {\n\t\treturn guess_user_and_switch(user, fb_mode);\n\t}\n\n\tuser2uid(user, &uid, &gid, &name, &home);\n\n\tif (uid == (uid_t) -1 || uid == 0) {\n\t\treturn 0;\n\t}\n\tif (gid == 0) {\n\t\treturn 0;\n\t}\n\n\tif (! doit && dpy) {\n\t\t/* see if this display works: */\n\t\tchar *dstr = DisplayString(dpy);\n\t\tdoit = try_user_and_display(uid, gid, dstr);\n\t}\n\n\tif (doit) {\n\t\tint rc = switch_user_env(uid, gid, name, home, fb_mode);\n\t\tif (rc) {\n\t\t\tstarted_as_root = 2;\n\t\t}\n\t\treturn rc;\n\t} else {\n\t\treturn 0;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"unixpw_accept skipping switch to user: %s (drc)\\n\"",
            "user"
          ],
          "line": 2414
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strtok",
          "args": [
            "NULL",
            "\",\""
          ],
          "line": 2408
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "u",
            "\"+%s\"",
            "user"
          ],
          "line": 2405
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "p",
            "user"
          ],
          "line": 2404
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strtok",
          "args": [
            "str + strlen(\"unixpw=\")",
            "\",\""
          ],
          "line": 2402
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "\"unixpw=\""
          ],
          "line": 2402
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "users_list"
          ],
          "line": 2401
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "u",
            "\"+%s\"",
            "user"
          ],
          "line": 2399
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "users_list",
            "\"unixpw=\""
          ],
          "line": 2398
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "strlen(user)+1"
          ],
          "line": 2393
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "user"
          ],
          "line": 2393
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"sslpeer failed to switch to user: %s\\n\"",
            "usslpeer"
          ],
          "line": 2387
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"sslpeer switched to user: %s\\n\"",
            "usslpeer"
          ],
          "line": 2385
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "u",
            "\"+%s\"",
            "usslpeer"
          ],
          "line": 2383
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "strlen(usslpeer+2)"
          ],
          "line": 2382
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "usslpeer+2"
          ],
          "line": 2382
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"unixpw_system_greeter: not trying switch to user '%s'\\n\"",
            "usslpeer ? usslpeer : \"\""
          ],
          "line": 2378
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"avahi.h\"\n#include \"sslhelper.h\"\n#include \"remote.h\"\n#include \"cursor.h\"\n#include \"keyboard.h\"\n#include \"inet.h\"\n#include \"connections.h\"\n#include \"xwrappers.h\"\n#include \"sslhelper.h\"\n#include \"unixpw.h\"\n#include \"screen.h\"\n#include \"scan.h\"\n#include \"cleanup.h\"\n#include \"solid.h\"\n#include \"x11vnc.h\"\n\nvoid lurk_loop(char *str);\n\nstatic void do_try_switch(char *usslpeer, char *users_list_save) {\n\tif (unixpw_system_greeter_active == 2) {\n\t\trfbLog(\"unixpw_system_greeter: not trying switch to user '%s'\\n\", usslpeer ? usslpeer : \"\");\n\t\treturn;\n\t}\n\tif (usslpeer) {\n\t\tchar *u = (char *) malloc(strlen(usslpeer+2));\n\t\tsprintf(u, \"+%s\", usslpeer);\n\t\tif (switch_user(u, 0)) {\n\t\t\trfbLog(\"sslpeer switched to user: %s\\n\", usslpeer);\n\t\t} else {\n\t\t\trfbLog(\"sslpeer failed to switch to user: %s\\n\", usslpeer);\n\t\t}\n\t\tfree(u);\n\t\t\n\t} else if (users_list_save && keep_unixpw_user) {\n\t\tchar *user = keep_unixpw_user;\n\t\tchar *u = (char *)malloc(strlen(user)+1); \n\n\t\tusers_list = users_list_save;\n\n\t\tu[0] = '\\0';\n\t\tif (!strcmp(users_list, \"unixpw=\")) {\n\t\t\tsprintf(u, \"+%s\", user);\n\t\t} else {\n\t\t\tchar *p, *str = strdup(users_list);\n\t\t\tp = strtok(str + strlen(\"unixpw=\"), \",\");\n\t\t\twhile (p) {\n\t\t\t\tif (!strcmp(p, user)) {\n\t\t\t\t\tsprintf(u, \"+%s\", user);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tp = strtok(NULL, \",\");\n\t\t\t}\n\t\t\tfree(str);\n\t\t}\n\t\t\n\t\tif (u[0] == '\\0') {\n\t\t\trfbLog(\"unixpw_accept skipping switch to user: %s (drc)\\n\", user);\n\t\t} else if (switch_user(u, 0)) {\n\t\t\trfbLog(\"unixpw_accept switched to user: %s (drc)\\n\", user);\n\t\t} else {\n\t\t\trfbLog(\"unixpw_accept failed to switch to user: %s (drc)\\n\", user);\n\t\t}\n\t\tfree(u);\n\t}\n}"
  },
  {
    "function_name": "get_usslpeer",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/user.c",
    "lines": "2340-2374",
    "snippet": "static char *get_usslpeer() {\n\tchar *u = NULL, *upeer = NULL;\n\n\tif (certret_str) {\n\t\tupeer = certret_extract();\n\t}\n\tif (!upeer) {\n\t\treturn NULL;\n\t}\n\trfbLog(\"sslpeer unix username extracted from x509 cert: %s\\n\", upeer);\n\n\tu = (char *) malloc(strlen(upeer+2));\n\tu[0] = '\\0';\n\tif (!strcmp(users_list, \"sslpeer=\")) {\n\t\tsprintf(u, \"+%s\", upeer);\n\t} else {\n\t\tchar *p, *str = strdup(users_list);\n\t\tp = strtok(str + strlen(\"sslpeer=\"), \",\");\n\t\twhile (p) {\n\t\t\tif (!strcmp(p, upeer)) {\n\t\t\t\tsprintf(u, \"+%s\", upeer);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tp = strtok(NULL, \",\");\n\t\t}\n\t\tfree(str);\n\t}\n\tif (u[0] == '\\0') {\n\t\trfbLog(\"sslpeer cannot determine user: %s\\n\", upeer);\n\t\tfree(u);\n\t\treturn NULL;\n\t}\n\tfree(u);\n\treturn upeer;\n}",
    "includes": [
      "#include \"avahi.h\"",
      "#include \"sslhelper.h\"",
      "#include \"remote.h\"",
      "#include \"cursor.h\"",
      "#include \"keyboard.h\"",
      "#include \"inet.h\"",
      "#include \"connections.h\"",
      "#include \"xwrappers.h\"",
      "#include \"sslhelper.h\"",
      "#include \"unixpw.h\"",
      "#include \"screen.h\"",
      "#include \"scan.h\"",
      "#include \"cleanup.h\"",
      "#include \"solid.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "void lurk_loop(char *str);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "u"
          ],
          "line": 2372
        },
        "resolved": true,
        "details": {
          "function_name": "free_rect",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/userinput.c",
          "lines": "6200-6247",
          "snippet": "int free_rect(int idx) {\n\tint n, ok = 0;\n\tsraRegionPtr r1, r2;\n\tint x, y, w, h;\n\n\tif (idx < 0 || idx >= cache_list_num) {\nif (0) fprintf(stderr, \"free_rect: bad index: %d\\n\", idx);\n\t\tclean_up_exit(1);\n\t}\n\n\tx = cache_list[idx].bs_x;\n\ty = cache_list[idx].bs_y;\n\tw = cache_list[idx].bs_w;\n\th = cache_list[idx].bs_h;\n\n\tif (x < 0) {\n\t\tCLEAR(idx);\nif (dnow() > last_client + 5 && ncdb) fprintf(stderr, \"free_rect: already bs_x invalidated: %d bs_x: %d\\n\", idx, x);\n\t\treturn 1;\n\t}\n\n\tr2 = sraRgnCreateRect(x, y, x+w, y+h);\n\n\tn = get_bs_n(y);\n\tif (n >= 0) {\n\t\tr1 = rect_reg[n];\n\t\tsraRgnOr(r1, r2);\n\t\tok = 1;\n\t}\n\n\tif (zero_rects) {\n\t\tsraRgnOr(zero_rects, r2);\n\t\tx = cache_list[idx].su_x;\n\t\ty = cache_list[idx].su_y;\n\t\tw = cache_list[idx].su_w;\n\t\th = cache_list[idx].su_h;\n\t\tif (x >= 0) {\n\t\t\tsraRgnDestroy(r2);\n\t\t\tr2 = sraRgnCreateRect(x, y, x+w, y+h);\n\t\t\tsraRgnOr(zero_rects, r2);\n\t\t}\n\t}\n\tsraRgnDestroy(r2);\n\n\tCLEAR(idx);\nif (! ok && ncdb) fprintf(stderr, \"**** free_rect: not-found %d\\n\", idx);\n\treturn ok;\n}",
          "includes": [
            "#include \"default8x16.h\"",
            "#include \"connections.h\"",
            "#include \"screen.h\"",
            "#include \"cursor.h\"",
            "#include \"macosxCGS.h\"",
            "#include \"macosx.h\"",
            "#include \"unixpw.h\"",
            "#include \"8to24.h\"",
            "#include \"xrandr.h\"",
            "#include \"solid.h\"",
            "#include \"keyboard.h\"",
            "#include \"rates.h\"",
            "#include \"pointer.h\"",
            "#include \"cleanup.h\"",
            "#include \"scan.h\"",
            "#include \"user.h\"",
            "#include \"xevents.h\"",
            "#include \"win_utils.h\"",
            "#include \"xinerama.h\"",
            "#include \"xrecord.h\"",
            "#include \"xdamage.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void mark_for_xdamage(int x, int y, int w, int h);",
            "void set_xdamage_mark(int x, int y, int w, int h);",
            "int find_rect(int idx, int x, int y, int w, int h);",
            "winattr_t *cache_list;",
            "int clipped(int idx);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"default8x16.h\"\n#include \"connections.h\"\n#include \"screen.h\"\n#include \"cursor.h\"\n#include \"macosxCGS.h\"\n#include \"macosx.h\"\n#include \"unixpw.h\"\n#include \"8to24.h\"\n#include \"xrandr.h\"\n#include \"solid.h\"\n#include \"keyboard.h\"\n#include \"rates.h\"\n#include \"pointer.h\"\n#include \"cleanup.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"xevents.h\"\n#include \"win_utils.h\"\n#include \"xinerama.h\"\n#include \"xrecord.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nvoid mark_for_xdamage(int x, int y, int w, int h);\nvoid set_xdamage_mark(int x, int y, int w, int h);\nint find_rect(int idx, int x, int y, int w, int h);\nwinattr_t *cache_list;\nint clipped(int idx);\n\nint free_rect(int idx) {\n\tint n, ok = 0;\n\tsraRegionPtr r1, r2;\n\tint x, y, w, h;\n\n\tif (idx < 0 || idx >= cache_list_num) {\nif (0) fprintf(stderr, \"free_rect: bad index: %d\\n\", idx);\n\t\tclean_up_exit(1);\n\t}\n\n\tx = cache_list[idx].bs_x;\n\ty = cache_list[idx].bs_y;\n\tw = cache_list[idx].bs_w;\n\th = cache_list[idx].bs_h;\n\n\tif (x < 0) {\n\t\tCLEAR(idx);\nif (dnow() > last_client + 5 && ncdb) fprintf(stderr, \"free_rect: already bs_x invalidated: %d bs_x: %d\\n\", idx, x);\n\t\treturn 1;\n\t}\n\n\tr2 = sraRgnCreateRect(x, y, x+w, y+h);\n\n\tn = get_bs_n(y);\n\tif (n >= 0) {\n\t\tr1 = rect_reg[n];\n\t\tsraRgnOr(r1, r2);\n\t\tok = 1;\n\t}\n\n\tif (zero_rects) {\n\t\tsraRgnOr(zero_rects, r2);\n\t\tx = cache_list[idx].su_x;\n\t\ty = cache_list[idx].su_y;\n\t\tw = cache_list[idx].su_w;\n\t\th = cache_list[idx].su_h;\n\t\tif (x >= 0) {\n\t\t\tsraRgnDestroy(r2);\n\t\t\tr2 = sraRgnCreateRect(x, y, x+w, y+h);\n\t\t\tsraRgnOr(zero_rects, r2);\n\t\t}\n\t}\n\tsraRgnDestroy(r2);\n\n\tCLEAR(idx);\nif (! ok && ncdb) fprintf(stderr, \"**** free_rect: not-found %d\\n\", idx);\n\treturn ok;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"sslpeer cannot determine user: %s\\n\"",
            "upeer"
          ],
          "line": 2368
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strtok",
          "args": [
            "NULL",
            "\",\""
          ],
          "line": 2363
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "u",
            "\"+%s\"",
            "upeer"
          ],
          "line": 2360
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "p",
            "upeer"
          ],
          "line": 2359
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strtok",
          "args": [
            "str + strlen(\"sslpeer=\")",
            "\",\""
          ],
          "line": 2357
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "\"sslpeer=\""
          ],
          "line": 2357
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "users_list"
          ],
          "line": 2356
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "u",
            "\"+%s\"",
            "upeer"
          ],
          "line": 2354
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "users_list",
            "\"sslpeer=\""
          ],
          "line": 2353
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "strlen(upeer+2)"
          ],
          "line": 2351
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "upeer+2"
          ],
          "line": 2351
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"sslpeer unix username extracted from x509 cert: %s\\n\"",
            "upeer"
          ],
          "line": 2349
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "certret_extract",
          "args": [],
          "line": 2344
        },
        "resolved": true,
        "details": {
          "function_name": "certret_extract",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/user.c",
          "lines": "2224-2276",
          "snippet": "static char *certret_extract() {\n\tchar *q, *p, *str = strdup(certret_str);\n\tchar *upeer = NULL;\n\tint ok = 0;\n\n\tq = strstr(str, \"Subject: \");\n\tif (! q) return NULL;\n\n\tp = strstr(q, \"\\n\");\n\tif (p) *p = '\\0';\n\n\tq = strstr(q, \"CN=\");\n\tif (! q) return NULL;\n\n\tif (! getenv(\"X11VNC_SSLPEER_CN\")) {\n\t\tp = q;\n\t\tq = strstr(q, \"/emailAddress=\");\n\t\tif (! q) q = strstr(p, \"/Email=\");\n\t\tif (! q) return NULL;\n\t}\n\n\tq = strstr(q, \"=\");\n\tif (! q) return NULL;\n\n\tq++;\n\tp = strstr(q, \" \");\n\tif (p) *p = '\\0';\n\tp = strstr(q, \"@\");\n\tif (p) *p = '\\0';\n\tp = strstr(q, \"/\");\n\tif (p) *p = '\\0';\n\n\tupeer = strdup(q);\n\n\tif (strcmp(upeer, \"\")) {\n\t\tp = upeer;\n\t\twhile (*p != '\\0') {\n\t\t\tchar c = *p;\n\t\t\tif (!isalnum((int) c)) {\n\t\t\t\t*p = '\\0';\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tp++;\n\t\t}\n\t\tif (strcmp(upeer, \"\")) {\n\t\t\tok = 1;\n\t\t}\n\t}\n\tif (! ok) {\n\t\tupeer = NULL;\n\t}\n\treturn upeer;\n}",
          "includes": [
            "#include \"avahi.h\"",
            "#include \"sslhelper.h\"",
            "#include \"remote.h\"",
            "#include \"cursor.h\"",
            "#include \"keyboard.h\"",
            "#include \"inet.h\"",
            "#include \"connections.h\"",
            "#include \"xwrappers.h\"",
            "#include \"sslhelper.h\"",
            "#include \"unixpw.h\"",
            "#include \"screen.h\"",
            "#include \"scan.h\"",
            "#include \"cleanup.h\"",
            "#include \"solid.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void lurk_loop(char *str);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"avahi.h\"\n#include \"sslhelper.h\"\n#include \"remote.h\"\n#include \"cursor.h\"\n#include \"keyboard.h\"\n#include \"inet.h\"\n#include \"connections.h\"\n#include \"xwrappers.h\"\n#include \"sslhelper.h\"\n#include \"unixpw.h\"\n#include \"screen.h\"\n#include \"scan.h\"\n#include \"cleanup.h\"\n#include \"solid.h\"\n#include \"x11vnc.h\"\n\nvoid lurk_loop(char *str);\n\nstatic char *certret_extract() {\n\tchar *q, *p, *str = strdup(certret_str);\n\tchar *upeer = NULL;\n\tint ok = 0;\n\n\tq = strstr(str, \"Subject: \");\n\tif (! q) return NULL;\n\n\tp = strstr(q, \"\\n\");\n\tif (p) *p = '\\0';\n\n\tq = strstr(q, \"CN=\");\n\tif (! q) return NULL;\n\n\tif (! getenv(\"X11VNC_SSLPEER_CN\")) {\n\t\tp = q;\n\t\tq = strstr(q, \"/emailAddress=\");\n\t\tif (! q) q = strstr(p, \"/Email=\");\n\t\tif (! q) return NULL;\n\t}\n\n\tq = strstr(q, \"=\");\n\tif (! q) return NULL;\n\n\tq++;\n\tp = strstr(q, \" \");\n\tif (p) *p = '\\0';\n\tp = strstr(q, \"@\");\n\tif (p) *p = '\\0';\n\tp = strstr(q, \"/\");\n\tif (p) *p = '\\0';\n\n\tupeer = strdup(q);\n\n\tif (strcmp(upeer, \"\")) {\n\t\tp = upeer;\n\t\twhile (*p != '\\0') {\n\t\t\tchar c = *p;\n\t\t\tif (!isalnum((int) c)) {\n\t\t\t\t*p = '\\0';\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tp++;\n\t\t}\n\t\tif (strcmp(upeer, \"\")) {\n\t\t\tok = 1;\n\t\t}\n\t}\n\tif (! ok) {\n\t\tupeer = NULL;\n\t}\n\treturn upeer;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"avahi.h\"\n#include \"sslhelper.h\"\n#include \"remote.h\"\n#include \"cursor.h\"\n#include \"keyboard.h\"\n#include \"inet.h\"\n#include \"connections.h\"\n#include \"xwrappers.h\"\n#include \"sslhelper.h\"\n#include \"unixpw.h\"\n#include \"screen.h\"\n#include \"scan.h\"\n#include \"cleanup.h\"\n#include \"solid.h\"\n#include \"x11vnc.h\"\n\nvoid lurk_loop(char *str);\n\nstatic char *get_usslpeer() {\n\tchar *u = NULL, *upeer = NULL;\n\n\tif (certret_str) {\n\t\tupeer = certret_extract();\n\t}\n\tif (!upeer) {\n\t\treturn NULL;\n\t}\n\trfbLog(\"sslpeer unix username extracted from x509 cert: %s\\n\", upeer);\n\n\tu = (char *) malloc(strlen(upeer+2));\n\tu[0] = '\\0';\n\tif (!strcmp(users_list, \"sslpeer=\")) {\n\t\tsprintf(u, \"+%s\", upeer);\n\t} else {\n\t\tchar *p, *str = strdup(users_list);\n\t\tp = strtok(str + strlen(\"sslpeer=\"), \",\");\n\t\twhile (p) {\n\t\t\tif (!strcmp(p, upeer)) {\n\t\t\t\tsprintf(u, \"+%s\", upeer);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tp = strtok(NULL, \",\");\n\t\t}\n\t\tfree(str);\n\t}\n\tif (u[0] == '\\0') {\n\t\trfbLog(\"sslpeer cannot determine user: %s\\n\", upeer);\n\t\tfree(u);\n\t\treturn NULL;\n\t}\n\tfree(u);\n\treturn upeer;\n}"
  },
  {
    "function_name": "check_nodisplay",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/user.c",
    "lines": "2278-2338",
    "snippet": "static void check_nodisplay(char **nd, char **tag) {\n\tif (unixpw && !getenv(\"X11VNC_NO_UNIXPW_OPTS\") && keep_unixpw_opts && keep_unixpw_opts[0] != '\\0') {\n\t\tchar *q, *t2, *t = keep_unixpw_opts;\n\t\tq = strstr(t, \"nd=\");\n\t\tif (! q) q = strstr(t, \"nodisplay=\");\n\t\tif (q) {\n\t\t\tq = strchr(q, '=') + 1;\n\t\t\tt = strdup(q);\n\t\t\tq = t;\n\t\t\tt2 = strchr(t, ',');\n\t\t\tif (t2) *t2 = '\\0';\n\n\t\t\twhile (*t != '\\0') {\n\t\t\t\tif (*t == '+') {\n\t\t\t\t\t*t = ',';\n\t\t\t\t}\n\t\t\t\tt++;\n\t\t\t}\n\t\t\tif (!strchr(q, '\\'') && !strpbrk(q, \"[](){}`'\\\"$&*|<>\")) {\n\t\t\t\tif (! quiet) rfbLog(\"set X11VNC_SKIP_DISPLAY: %s\\n\", q);\n\t\t\t\t*nd = q;\n\t\t\t}\n\t\t}\n\n\t\tq = strstr(keep_unixpw_opts, \"tag=\");\n\t\tif (getenv(\"FD_TAG\")) {\n\t\t\t*tag = strdup(getenv(\"FD_TAG\"));\n\t\t} else if (q) {\n\t\t\tq = strchr(q, '=') + 1;\n\t\t\tt = strdup(q);\n\t\t\tq = t;\n\t\t\tt2 = strchr(t, ',');\n\t\t\tif (t2) *t2 = '\\0';\n\n\t\t\tif (strlen(q) < 120) {\n\t\t\t\tint ok = 1;\n\t\t\t\twhile (*t != '\\0') {\n\t\t\t\t\tchar c = *t;\n\t\t\t\t\tif (*t == '_' || *t == '-') {\n\t\t\t\t\t\t;\n\t\t\t\t\t} else if (!isalnum((int) c)) {\n\t\t\t\t\t\tok = 0;\n\t\t\t\t\t\trfbLog(\"bad tag char: '%c' in '%s'\\n\", c, q);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tt++;\n\t\t\t\t}\n\t\t\t\tif (ok) {\n\t\t\t\t\tif (! quiet) rfbLog(\"set FD_TAG: %s\\n\", q);\n\t\t\t\t\t*tag = q;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tif (unixpw_system_greeter_active == 2) {\n\t\tif (!keep_unixpw_user) {\n\t\t\tclean_up_exit(1);\n\t\t}\n\t\t*nd = strdup(\"all\");\n\t}\n}",
    "includes": [
      "#include \"avahi.h\"",
      "#include \"sslhelper.h\"",
      "#include \"remote.h\"",
      "#include \"cursor.h\"",
      "#include \"keyboard.h\"",
      "#include \"inet.h\"",
      "#include \"connections.h\"",
      "#include \"xwrappers.h\"",
      "#include \"sslhelper.h\"",
      "#include \"unixpw.h\"",
      "#include \"screen.h\"",
      "#include \"scan.h\"",
      "#include \"cleanup.h\"",
      "#include \"solid.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "\"all\""
          ],
          "line": 2336
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clean_up_exit",
          "args": [
            "1"
          ],
          "line": 2334
        },
        "resolved": true,
        "details": {
          "function_name": "clean_up_exit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/cleanup.c",
          "lines": "151-266",
          "snippet": "void clean_up_exit(int ret) {\n\tstatic int depth = 0;\n\texit_flag = 1;\n\n\tif (depth++ > 2) {\n\t\texit(ret);\n\t}\n\n\tif (icon_mode) {\n\t\tclean_icon_mode();\n\t}\n\n\t/* remove the shm areas: */\n\tclean_shm(0);\n\n\tstop_stunnel();\n\tif (use_openssl) {\n\t\tssl_helper_pid(0, 0);\t/* killall */\n\t}\n\n\tif (ssh_pid > 0) {\n\t\tkill(ssh_pid, SIGTERM);\n\t\tssh_pid = 0;\n\t}\n\n#ifdef MACOSX\n\tif (client_connect_file) {\n\t\tif (strstr(client_connect_file, \"/tmp/x11vnc-macosx-remote\")\n\t\t    == client_connect_file) {\n\t\t\tunlink(client_connect_file);\n\t\t}\n\t}\n\tif (macosx_console) {\n\t\tmacosxCG_fini();\n\t}\n#endif\n\n\tif (pipeinput_fh != NULL) {\n\t\tpclose(pipeinput_fh);\n\t\tpipeinput_fh = NULL;\n\t}\n\n\tshutdown_uinput();\n\n\tif (unix_sock) {\n\t\tif (unix_sock_fd >= 0) {\n\t\t\trfbLog(\"deleting unix sock: %s\\n\", unix_sock);\n\t\t\tclose(unix_sock_fd);\n\t\t\tunix_sock_fd = -1;\n\t\t\tunlink(unix_sock);\n\t\t}\n\t}\n\n\tif (! dpy) {\t/* raw_rb hack */\n\t\tif (rm_flagfile) {\n\t\t\tunlink(rm_flagfile);\n\t\t\trm_flagfile = NULL;\n\t\t}\n\t\texit(ret);\n\t}\n\n\t/* X keyboard cleanups */\n\tdelete_added_keycodes(0);\n\n\t/* remove all created XInput2 devices */\n\tif(use_multipointer)\n\t    removeAllMDs(dpy);\n\n\tif (clear_mods == 1) {\n\t\tclear_modifiers(0);\n\t} else if (clear_mods == 2) {\n\t\tclear_keys();\n\t} else if (clear_mods == 3) {\n\t\tclear_keys();\n\t\tclear_locks();\n\t}\n\n\tif (no_autorepeat) {\n\t\tautorepeat(1, 0);\n\t}\n\tif (use_solid_bg) {\n\t\tsolid_bg(1);\n\t}\n\tif (ncache || ncache0) {\n\t\tkde_no_animate(1);\n\t}\n\tX_LOCK;\n\tXTestDiscard_wr(dpy);\n#if HAVE_LIBXDAMAGE\n\tif (xdamage) {\n\t\tXDamageDestroy(dpy, xdamage);\n\t}\n#endif\n#if HAVE_LIBXTRAP\n\tif (trap_ctx) {\n\t\tXEFreeTC(trap_ctx);\n\t}\n#endif\n\t/* XXX rdpy_ctrl, etc. cannot close w/o blocking */\n\tXCloseDisplay_wr(dpy);\n\tX_UNLOCK;\n\n\tfflush(stderr);\n\n\tif (rm_flagfile) {\n\t\tunlink(rm_flagfile);\n\t\trm_flagfile = NULL;\n\t}\n\n\tif (avahi) {\n\t\tavahi_cleanup();\n\t\tfflush(stderr);\n\t}\n\n\texit(ret);\n}",
          "includes": [
            "#include \"xi2_devices.h\"",
            "#include \"uinput.h\"",
            "#include \"xevents.h\"",
            "#include \"xrecord.h\"",
            "#include \"screen.h\"",
            "#include \"avahi.h\"",
            "#include \"macosxCG.h\"",
            "#include \"macosx.h\"",
            "#include \"connections.h\"",
            "#include \"sslhelper.h\"",
            "#include \"sslcmds.h\"",
            "#include \"unixpw.h\"",
            "#include \"solid.h\"",
            "#include \"gui.h\"",
            "#include \"scan.h\"",
            "#include \"keyboard.h\"",
            "#include \"remote.h\"",
            "#include \"xdamage.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void clean_up_exit(int ret);",
            "int known_sigpipe_mode(char *s);",
            "static int exit_flag = 0;",
            "static void clean_icon_mode(void);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xi2_devices.h\"\n#include \"uinput.h\"\n#include \"xevents.h\"\n#include \"xrecord.h\"\n#include \"screen.h\"\n#include \"avahi.h\"\n#include \"macosxCG.h\"\n#include \"macosx.h\"\n#include \"connections.h\"\n#include \"sslhelper.h\"\n#include \"sslcmds.h\"\n#include \"unixpw.h\"\n#include \"solid.h\"\n#include \"gui.h\"\n#include \"scan.h\"\n#include \"keyboard.h\"\n#include \"remote.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nvoid clean_up_exit(int ret);\nint known_sigpipe_mode(char *s);\nstatic int exit_flag = 0;\nstatic void clean_icon_mode(void);\n\nvoid clean_up_exit(int ret) {\n\tstatic int depth = 0;\n\texit_flag = 1;\n\n\tif (depth++ > 2) {\n\t\texit(ret);\n\t}\n\n\tif (icon_mode) {\n\t\tclean_icon_mode();\n\t}\n\n\t/* remove the shm areas: */\n\tclean_shm(0);\n\n\tstop_stunnel();\n\tif (use_openssl) {\n\t\tssl_helper_pid(0, 0);\t/* killall */\n\t}\n\n\tif (ssh_pid > 0) {\n\t\tkill(ssh_pid, SIGTERM);\n\t\tssh_pid = 0;\n\t}\n\n#ifdef MACOSX\n\tif (client_connect_file) {\n\t\tif (strstr(client_connect_file, \"/tmp/x11vnc-macosx-remote\")\n\t\t    == client_connect_file) {\n\t\t\tunlink(client_connect_file);\n\t\t}\n\t}\n\tif (macosx_console) {\n\t\tmacosxCG_fini();\n\t}\n#endif\n\n\tif (pipeinput_fh != NULL) {\n\t\tpclose(pipeinput_fh);\n\t\tpipeinput_fh = NULL;\n\t}\n\n\tshutdown_uinput();\n\n\tif (unix_sock) {\n\t\tif (unix_sock_fd >= 0) {\n\t\t\trfbLog(\"deleting unix sock: %s\\n\", unix_sock);\n\t\t\tclose(unix_sock_fd);\n\t\t\tunix_sock_fd = -1;\n\t\t\tunlink(unix_sock);\n\t\t}\n\t}\n\n\tif (! dpy) {\t/* raw_rb hack */\n\t\tif (rm_flagfile) {\n\t\t\tunlink(rm_flagfile);\n\t\t\trm_flagfile = NULL;\n\t\t}\n\t\texit(ret);\n\t}\n\n\t/* X keyboard cleanups */\n\tdelete_added_keycodes(0);\n\n\t/* remove all created XInput2 devices */\n\tif(use_multipointer)\n\t    removeAllMDs(dpy);\n\n\tif (clear_mods == 1) {\n\t\tclear_modifiers(0);\n\t} else if (clear_mods == 2) {\n\t\tclear_keys();\n\t} else if (clear_mods == 3) {\n\t\tclear_keys();\n\t\tclear_locks();\n\t}\n\n\tif (no_autorepeat) {\n\t\tautorepeat(1, 0);\n\t}\n\tif (use_solid_bg) {\n\t\tsolid_bg(1);\n\t}\n\tif (ncache || ncache0) {\n\t\tkde_no_animate(1);\n\t}\n\tX_LOCK;\n\tXTestDiscard_wr(dpy);\n#if HAVE_LIBXDAMAGE\n\tif (xdamage) {\n\t\tXDamageDestroy(dpy, xdamage);\n\t}\n#endif\n#if HAVE_LIBXTRAP\n\tif (trap_ctx) {\n\t\tXEFreeTC(trap_ctx);\n\t}\n#endif\n\t/* XXX rdpy_ctrl, etc. cannot close w/o blocking */\n\tXCloseDisplay_wr(dpy);\n\tX_UNLOCK;\n\n\tfflush(stderr);\n\n\tif (rm_flagfile) {\n\t\tunlink(rm_flagfile);\n\t\trm_flagfile = NULL;\n\t}\n\n\tif (avahi) {\n\t\tavahi_cleanup();\n\t\tfflush(stderr);\n\t}\n\n\texit(ret);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"set FD_TAG: %s\\n\"",
            "q"
          ],
          "line": 2326
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"bad tag char: '%c' in '%s'\\n\"",
            "c",
            "q"
          ],
          "line": 2320
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isalnum",
          "args": [
            "(int) c"
          ],
          "line": 2318
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "q"
          ],
          "line": 2312
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "t",
            "','"
          ],
          "line": 2309
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "q"
          ],
          "line": 2307
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "q",
            "'='"
          ],
          "line": 2306
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "getenv(\"FD_TAG\")"
          ],
          "line": 2304
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getenv",
          "args": [
            "\"FD_TAG\""
          ],
          "line": 2304
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getenv",
          "args": [
            "\"FD_TAG\""
          ],
          "line": 2303
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "keep_unixpw_opts",
            "\"tag=\""
          ],
          "line": 2302
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"set X11VNC_SKIP_DISPLAY: %s\\n\"",
            "q"
          ],
          "line": 2297
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strpbrk",
          "args": [
            "q",
            "\"[](){}`'\\\"$&*|<>\""
          ],
          "line": 2296
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "q",
            "'\\''"
          ],
          "line": 2296
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "t",
            "','"
          ],
          "line": 2287
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "q"
          ],
          "line": 2285
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "q",
            "'='"
          ],
          "line": 2284
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "t",
            "\"nodisplay=\""
          ],
          "line": 2282
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "t",
            "\"nd=\""
          ],
          "line": 2281
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getenv",
          "args": [
            "\"X11VNC_NO_UNIXPW_OPTS\""
          ],
          "line": 2279
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"avahi.h\"\n#include \"sslhelper.h\"\n#include \"remote.h\"\n#include \"cursor.h\"\n#include \"keyboard.h\"\n#include \"inet.h\"\n#include \"connections.h\"\n#include \"xwrappers.h\"\n#include \"sslhelper.h\"\n#include \"unixpw.h\"\n#include \"screen.h\"\n#include \"scan.h\"\n#include \"cleanup.h\"\n#include \"solid.h\"\n#include \"x11vnc.h\"\n\nstatic void check_nodisplay(char **nd, char **tag) {\n\tif (unixpw && !getenv(\"X11VNC_NO_UNIXPW_OPTS\") && keep_unixpw_opts && keep_unixpw_opts[0] != '\\0') {\n\t\tchar *q, *t2, *t = keep_unixpw_opts;\n\t\tq = strstr(t, \"nd=\");\n\t\tif (! q) q = strstr(t, \"nodisplay=\");\n\t\tif (q) {\n\t\t\tq = strchr(q, '=') + 1;\n\t\t\tt = strdup(q);\n\t\t\tq = t;\n\t\t\tt2 = strchr(t, ',');\n\t\t\tif (t2) *t2 = '\\0';\n\n\t\t\twhile (*t != '\\0') {\n\t\t\t\tif (*t == '+') {\n\t\t\t\t\t*t = ',';\n\t\t\t\t}\n\t\t\t\tt++;\n\t\t\t}\n\t\t\tif (!strchr(q, '\\'') && !strpbrk(q, \"[](){}`'\\\"$&*|<>\")) {\n\t\t\t\tif (! quiet) rfbLog(\"set X11VNC_SKIP_DISPLAY: %s\\n\", q);\n\t\t\t\t*nd = q;\n\t\t\t}\n\t\t}\n\n\t\tq = strstr(keep_unixpw_opts, \"tag=\");\n\t\tif (getenv(\"FD_TAG\")) {\n\t\t\t*tag = strdup(getenv(\"FD_TAG\"));\n\t\t} else if (q) {\n\t\t\tq = strchr(q, '=') + 1;\n\t\t\tt = strdup(q);\n\t\t\tq = t;\n\t\t\tt2 = strchr(t, ',');\n\t\t\tif (t2) *t2 = '\\0';\n\n\t\t\tif (strlen(q) < 120) {\n\t\t\t\tint ok = 1;\n\t\t\t\twhile (*t != '\\0') {\n\t\t\t\t\tchar c = *t;\n\t\t\t\t\tif (*t == '_' || *t == '-') {\n\t\t\t\t\t\t;\n\t\t\t\t\t} else if (!isalnum((int) c)) {\n\t\t\t\t\t\tok = 0;\n\t\t\t\t\t\trfbLog(\"bad tag char: '%c' in '%s'\\n\", c, q);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tt++;\n\t\t\t\t}\n\t\t\t\tif (ok) {\n\t\t\t\t\tif (! quiet) rfbLog(\"set FD_TAG: %s\\n\", q);\n\t\t\t\t\t*tag = q;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tif (unixpw_system_greeter_active == 2) {\n\t\tif (!keep_unixpw_user) {\n\t\t\tclean_up_exit(1);\n\t\t}\n\t\t*nd = strdup(\"all\");\n\t}\n}"
  },
  {
    "function_name": "certret_extract",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/user.c",
    "lines": "2224-2276",
    "snippet": "static char *certret_extract() {\n\tchar *q, *p, *str = strdup(certret_str);\n\tchar *upeer = NULL;\n\tint ok = 0;\n\n\tq = strstr(str, \"Subject: \");\n\tif (! q) return NULL;\n\n\tp = strstr(q, \"\\n\");\n\tif (p) *p = '\\0';\n\n\tq = strstr(q, \"CN=\");\n\tif (! q) return NULL;\n\n\tif (! getenv(\"X11VNC_SSLPEER_CN\")) {\n\t\tp = q;\n\t\tq = strstr(q, \"/emailAddress=\");\n\t\tif (! q) q = strstr(p, \"/Email=\");\n\t\tif (! q) return NULL;\n\t}\n\n\tq = strstr(q, \"=\");\n\tif (! q) return NULL;\n\n\tq++;\n\tp = strstr(q, \" \");\n\tif (p) *p = '\\0';\n\tp = strstr(q, \"@\");\n\tif (p) *p = '\\0';\n\tp = strstr(q, \"/\");\n\tif (p) *p = '\\0';\n\n\tupeer = strdup(q);\n\n\tif (strcmp(upeer, \"\")) {\n\t\tp = upeer;\n\t\twhile (*p != '\\0') {\n\t\t\tchar c = *p;\n\t\t\tif (!isalnum((int) c)) {\n\t\t\t\t*p = '\\0';\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tp++;\n\t\t}\n\t\tif (strcmp(upeer, \"\")) {\n\t\t\tok = 1;\n\t\t}\n\t}\n\tif (! ok) {\n\t\tupeer = NULL;\n\t}\n\treturn upeer;\n}",
    "includes": [
      "#include \"avahi.h\"",
      "#include \"sslhelper.h\"",
      "#include \"remote.h\"",
      "#include \"cursor.h\"",
      "#include \"keyboard.h\"",
      "#include \"inet.h\"",
      "#include \"connections.h\"",
      "#include \"xwrappers.h\"",
      "#include \"sslhelper.h\"",
      "#include \"unixpw.h\"",
      "#include \"screen.h\"",
      "#include \"scan.h\"",
      "#include \"cleanup.h\"",
      "#include \"solid.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "void lurk_loop(char *str);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "upeer",
            "\"\""
          ],
          "line": 2268
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isalnum",
          "args": [
            "(int) c"
          ],
          "line": 2262
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "upeer",
            "\"\""
          ],
          "line": 2258
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "q"
          ],
          "line": 2256
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "q",
            "\"/\""
          ],
          "line": 2253
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "q",
            "\"@\""
          ],
          "line": 2251
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "q",
            "\" \""
          ],
          "line": 2249
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "q",
            "\"=\""
          ],
          "line": 2245
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "p",
            "\"/Email=\""
          ],
          "line": 2241
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "q",
            "\"/emailAddress=\""
          ],
          "line": 2240
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getenv",
          "args": [
            "\"X11VNC_SSLPEER_CN\""
          ],
          "line": 2238
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "q",
            "\"CN=\""
          ],
          "line": 2235
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "q",
            "\"\\n\""
          ],
          "line": 2232
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "str",
            "\"Subject: \""
          ],
          "line": 2229
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "certret_str"
          ],
          "line": 2225
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"avahi.h\"\n#include \"sslhelper.h\"\n#include \"remote.h\"\n#include \"cursor.h\"\n#include \"keyboard.h\"\n#include \"inet.h\"\n#include \"connections.h\"\n#include \"xwrappers.h\"\n#include \"sslhelper.h\"\n#include \"unixpw.h\"\n#include \"screen.h\"\n#include \"scan.h\"\n#include \"cleanup.h\"\n#include \"solid.h\"\n#include \"x11vnc.h\"\n\nvoid lurk_loop(char *str);\n\nstatic char *certret_extract() {\n\tchar *q, *p, *str = strdup(certret_str);\n\tchar *upeer = NULL;\n\tint ok = 0;\n\n\tq = strstr(str, \"Subject: \");\n\tif (! q) return NULL;\n\n\tp = strstr(q, \"\\n\");\n\tif (p) *p = '\\0';\n\n\tq = strstr(q, \"CN=\");\n\tif (! q) return NULL;\n\n\tif (! getenv(\"X11VNC_SSLPEER_CN\")) {\n\t\tp = q;\n\t\tq = strstr(q, \"/emailAddress=\");\n\t\tif (! q) q = strstr(p, \"/Email=\");\n\t\tif (! q) return NULL;\n\t}\n\n\tq = strstr(q, \"=\");\n\tif (! q) return NULL;\n\n\tq++;\n\tp = strstr(q, \" \");\n\tif (p) *p = '\\0';\n\tp = strstr(q, \"@\");\n\tif (p) *p = '\\0';\n\tp = strstr(q, \"/\");\n\tif (p) *p = '\\0';\n\n\tupeer = strdup(q);\n\n\tif (strcmp(upeer, \"\")) {\n\t\tp = upeer;\n\t\twhile (*p != '\\0') {\n\t\t\tchar c = *p;\n\t\t\tif (!isalnum((int) c)) {\n\t\t\t\t*p = '\\0';\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tp++;\n\t\t}\n\t\tif (strcmp(upeer, \"\")) {\n\t\t\tok = 1;\n\t\t}\n\t}\n\tif (! ok) {\n\t\tupeer = NULL;\n\t}\n\treturn upeer;\n}"
  },
  {
    "function_name": "build_create_cmd",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/user.c",
    "lines": "1958-2222",
    "snippet": "static char *build_create_cmd(char *cmd, int *saw_xdmcp, char *usslpeer, char *tmp) {\n\tchar *create_cmd = NULL;\n\tchar *opts = strchr(cmd, '-');\n\tchar st[] = \"\";\n\tchar fdgeom[128], fdsess[128], fdopts[128], fdextra[256], fdprog[128];\n\tchar fdxsrv[128], fdxdum[128], fdcups[128], fdesd[128];\n\tchar fdnas[128], fdsmb[128], fdtag[128], fdxdmcpif[128];\n\tchar cdout[128];\n\n\tif (opts) {\n\t\topts++;\n\t\tif (strstr(opts, \"xdmcp\")) {\n\t\t\t*saw_xdmcp = 1;\n\t\t}\n\t} else {\n\t\topts = st;\n\t}\n\tsprintf(fdgeom, \"NONE\");\n\tfdsess[0] = '\\0';\n\tfdgeom[0] = '\\0';\n\tfdopts[0] = '\\0';\n\tfdextra[0] = '\\0';\n\tfdprog[0] = '\\0';\n\tfdxsrv[0] = '\\0';\n\tfdxdum[0] = '\\0';\n\tfdcups[0] = '\\0';\n\tfdesd[0]  = '\\0';\n\tfdnas[0]  = '\\0';\n\tfdsmb[0]  = '\\0';\n\tfdtag[0]  = '\\0';\n\tfdxdmcpif[0]  = '\\0';\n\tcdout[0]  = '\\0';\n\n\tif (unixpw && keep_unixpw_opts && !getenv(\"X11VNC_NO_UNIXPW_OPTS\")) {\n\t\tchar *q, *p, *t = strdup(keep_unixpw_opts);\n\n\t\tif (strstr(t, \"gnome\")) {\n\t\t\tsprintf(fdsess, \"gnome\");\n\t\t} else if (strstr(t, \"kde\")) {\n\t\t\tsprintf(fdsess, \"kde\");\n\t\t} else if (strstr(t, \"lxde\")) {\n\t\t\tsprintf(fdsess, \"lxde\");\n\t\t} else if (strstr(t, \"twm\")) {\n\t\t\tsprintf(fdsess, \"twm\");\n\t\t} else if (strstr(t, \"fvwm\")) {\n\t\t\tsprintf(fdsess, \"fvwm\");\n\t\t} else if (strstr(t, \"mwm\")) {\n\t\t\tsprintf(fdsess, \"mwm\");\n\t\t} else if (strstr(t, \"cde\")) {\n\t\t\tsprintf(fdsess, \"cde\");\n\t\t} else if (strstr(t, \"dtwm\")) {\n\t\t\tsprintf(fdsess, \"dtwm\");\n\t\t} else if (strstr(t, \"xterm\")) {\n\t\t\tsprintf(fdsess, \"xterm\");\n\t\t} else if (strstr(t, \"wmaker\")) {\n\t\t\tsprintf(fdsess, \"wmaker\");\n\t\t} else if (strstr(t, \"xfce\")) {\n\t\t\tsprintf(fdsess, \"xfce\");\n\t\t} else if (strstr(t, \"enlightenment\")) {\n\t\t\tsprintf(fdsess, \"enlightenment\");\n\t\t} else if (strstr(t, \"Xsession\")) {\n\t\t\tsprintf(fdsess, \"Xsession\");\n\t\t} else if (strstr(t, \"failsafe\")) {\n\t\t\tsprintf(fdsess, \"failsafe\");\n\t\t}\n\n\t\tq = strstr(t, \"ge=\");\n\t\tif (! q) q = strstr(t, \"geom=\");\n\t\tif (! q) q = strstr(t, \"geometry=\");\n\t\tif (q) {\n\t\t\tint ok = 1;\n\t\t\tq = strstr(q, \"=\");\n\t\t\tq++;\n\t\t\tp = strstr(q, \",\");\n\t\t\tif (p) *p = '\\0';\n\t\t\tp = q;\n\t\t\twhile (*p) {\n\t\t\t\tif (*p == 'x') {\n\t\t\t\t\t;\n\t\t\t\t} else if (isdigit((int) *p)) {\n\t\t\t\t\t;\n\t\t\t\t} else {\n\t\t\t\t\tok = 0;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tp++;\n\t\t\t}\n\t\t\tif (ok && strlen(q) < 32) {\n\t\t\t\tsprintf(fdgeom, \"%s\", q);\n\t\t\t\tif (!quiet) {\n\t\t\t\t\trfbLog(\"set create display geom: %s\\n\", fdgeom);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tq = strstr(t, \"cups=\");\n\t\tif (q) {\n\t\t\tint p;\n\t\t\tif (sscanf(q, \"cups=%d\", &p) == 1) {\n\t\t\t\tsprintf(fdcups, \"%d\", p);\n\t\t\t}\n\t\t}\n\t\tq = strstr(t, \"esd=\");\n\t\tif (q) {\n\t\t\tint p;\n\t\t\tif (sscanf(q, \"esd=%d\", &p) == 1) {\n\t\t\t\tsprintf(fdesd, \"%d\", p);\n\t\t\t}\n\t\t}\n\t\tif (!getenv(\"FD_TAG\")) {\n\t\t\tchar *s = NULL;\n\n\t\t\tq = strstr(t, \"tag=\");\n\t\t\tif (q) s = strchr(q, ',');\n\t\t\tif (s) *s = '\\0';\n\n\t\t\tif (q && strlen(q) < 120) {\n\t\t\t\tchar *p;\n\t\t\t\tint ok = 1;\n\t\t\t\tq = strchr(q, '=') + 1;\n\t\t\t\tp = q;\n\t\t\t\twhile (*p != '\\0') {\n\t\t\t\t\tchar c = *p;\n\t\t\t\t\tif (*p == '_' || *p == '-') {\n\t\t\t\t\t\t;\n\t\t\t\t\t} else if (!isalnum((int) c)) {\n\t\t\t\t\t\tok = 0;\n\t\t\t\t\t\trfbLog(\"bad tag char: '%c' in '%s'\\n\", c, q);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tp++;\n\t\t\t\t}\n\t\t\t\tif (ok) {\n\t\t\t\t\tsprintf(fdtag, \"%s\", q);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (s) *s = ',';\n\t\t}\n\t\tfree(t);\n\t}\n\tif (fdgeom[0] == '\\0' && getenv(\"FD_GEOM\")) {\n\t\tsnprintf(fdgeom,  sizeof fdgeom, \"%s\", getenv(\"FD_GEOM\"));\n\t}\n\tif (fdsess[0] == '\\0' && getenv(\"FD_SESS\")) {\n\t\tsnprintf(fdsess, sizeof fdsess, \"%s\", getenv(\"FD_SESS\"));\n\t}\n\tif (fdopts[0] == '\\0' && getenv(\"FD_OPTS\")) {\n\t\tsnprintf(fdopts, sizeof fdopts, \"%s\", getenv(\"FD_OPTS\"));\n\t}\n\tif (fdextra[0] == '\\0' && getenv(\"FD_EXTRA\")) {\n\t\tif (!strchr(getenv(\"FD_EXTRA\"), '\\'')) {\n\t\t\tsnprintf(fdextra, sizeof fdextra, \"%s\", getenv(\"FD_EXTRA\"));\n\t\t}\n\t}\n\tif (fdprog[0] == '\\0' && getenv(\"FD_PROG\")) {\n\t\tsnprintf(fdprog, sizeof fdprog, \"%s\", getenv(\"FD_PROG\"));\n\t}\n\tif (fdxsrv[0] == '\\0' && getenv(\"FD_XSRV\")) {\n\t\tsnprintf(fdxsrv, sizeof fdxsrv, \"%s\", getenv(\"FD_XSRV\"));\n\t}\n\tif (fdcups[0] == '\\0' && getenv(\"FD_CUPS\")) {\n\t\tsnprintf(fdcups, sizeof fdcups, \"%s\", getenv(\"FD_CUPS\"));\n\t}\n\tif (fdesd[0] == '\\0' && getenv(\"FD_ESD\")) {\n\t\tsnprintf(fdesd, sizeof fdesd, \"%s\", getenv(\"FD_ESD\"));\n\t}\n\tif (fdnas[0] == '\\0' && getenv(\"FD_NAS\")) {\n\t\tsnprintf(fdnas, sizeof fdnas, \"%s\", getenv(\"FD_NAS\"));\n\t}\n\tif (fdsmb[0] == '\\0' && getenv(\"FD_SMB\")) {\n\t\tsnprintf(fdsmb, sizeof fdsmb, \"%s\", getenv(\"FD_SMB\"));\n\t}\n\tif (fdtag[0] == '\\0' && getenv(\"FD_TAG\")) {\n\t\tsnprintf(fdtag, sizeof fdtag, \"%s\", getenv(\"FD_TAG\"));\n\t}\n\tif (fdxdmcpif[0] == '\\0' && getenv(\"FD_XDMCP_IF\")) {\n\t\tsnprintf(fdxdmcpif,  sizeof fdxdmcpif, \"%s\", getenv(\"FD_XDMCP_IF\"));\n\t}\n\tif (fdxdum[0] == '\\0' && getenv(\"FD_XDUMMY_RUN_AS_ROOT\")) {\n\t\tsnprintf(fdxdum, sizeof fdxdum, \"%s\", getenv(\"FD_XDUMMY_RUN_AS_ROOT\"));\n\t}\n\tif (getenv(\"CREATE_DISPLAY_OUTPUT\")) {\n\t\tsnprintf(cdout, sizeof cdout, \"CREATE_DISPLAY_OUTPUT='%s'\", getenv(\"CREATE_DISPLAY_OUTPUT\"));\n\t}\n\n\tif (strchr(fdgeom, '\\''))\tfdgeom[0] = '\\0';\n\tif (strchr(fdopts, '\\''))\tfdopts[0] = '\\0';\n\tif (strchr(fdextra, '\\''))\tfdextra[0] = '\\0';\n\tif (strchr(fdprog, '\\''))\tfdprog[0] = '\\0';\n\tif (strchr(fdxsrv, '\\''))\tfdxsrv[0] = '\\0';\n\tif (strchr(fdcups, '\\''))\tfdcups[0] = '\\0';\n\tif (strchr(fdesd, '\\''))\tfdesd[0] = '\\0';\n\tif (strchr(fdnas, '\\''))\tfdnas[0] = '\\0';\n\tif (strchr(fdsmb, '\\''))\tfdsmb[0] = '\\0';\n\tif (strchr(fdtag, '\\''))\tfdtag[0] = '\\0';\n\tif (strchr(fdxdmcpif, '\\''))\tfdxdmcpif[0] = '\\0';\n\tif (strchr(fdxdum, '\\''))\tfdxdum[0] = '\\0';\n\tif (strchr(fdsess, '\\''))\tfdsess[0] = '\\0';\n\tif (strchr(cdout, '\\''))\tcdout[0] = '\\0';\n\n\tset_env(\"FD_GEOM\", fdgeom);\n\tset_env(\"FD_OPTS\", fdopts);\n\tset_env(\"FD_EXTRA\", fdextra);\n\tset_env(\"FD_PROG\", fdprog);\n\tset_env(\"FD_XSRV\", fdxsrv);\n\tset_env(\"FD_CUPS\", fdcups);\n\tset_env(\"FD_ESD\",  fdesd);\n\tset_env(\"FD_NAS\",  fdnas);\n\tset_env(\"FD_SMB\",  fdsmb);\n\tset_env(\"FD_TAG\",  fdtag);\n\tset_env(\"FD_XDMCP_IF\",  fdxdmcpif);\n\tset_env(\"FD_XDUMMY_RUN_AS_ROOT\", fdxdum);\n\tset_env(\"FD_SESS\", fdsess);\n\n\tif (usslpeer || (unixpw && keep_unixpw_user)) {\n\t\tchar *uu = usslpeer;\n\t\tif (!uu) {\n\t\t\tuu = keep_unixpw_user;\n\t\t}\n\t\tif (strchr(uu, '\\''))  {\n\t\t\tuu = \"\";\n\t\t}\n\t\tcreate_cmd = (char *) malloc(strlen(tmp)+1\n\t\t    + strlen(\"env USER='' \")\n\t\t    + strlen(\"FD_GEOM='' \")\n\t\t    + strlen(\"FD_OPTS='' \")\n\t\t    + strlen(\"FD_EXTRA='' \")\n\t\t    + strlen(\"FD_PROG='' \")\n\t\t    + strlen(\"FD_XSRV='' \")\n\t\t    + strlen(\"FD_CUPS='' \")\n\t\t    + strlen(\"FD_ESD='' \")\n\t\t    + strlen(\"FD_NAS='' \")\n\t\t    + strlen(\"FD_SMB='' \")\n\t\t    + strlen(\"FD_TAG='' \")\n\t\t    + strlen(\"FD_XDMCP_IF='' \")\n\t\t    + strlen(\"FD_XDUMMY_RUN_AS_ROOT='' \")\n\t\t    + strlen(\"FD_SESS='' /bin/sh \")\n\t\t    + strlen(uu) + 1\n\t\t    + strlen(fdgeom) + 1\n\t\t    + strlen(fdopts) + 1\n\t\t    + strlen(fdextra) + 1\n\t\t    + strlen(fdprog) + 1\n\t\t    + strlen(fdxsrv) + 1\n\t\t    + strlen(fdcups) + 1\n\t\t    + strlen(fdesd) + 1\n\t\t    + strlen(fdnas) + 1\n\t\t    + strlen(fdsmb) + 1\n\t\t    + strlen(fdtag) + 1\n\t\t    + strlen(fdxdmcpif) + 1\n\t\t    + strlen(fdxdum) + 1\n\t\t    + strlen(fdsess) + 1\n\t\t    + strlen(cdout) + 1\n\t\t    + strlen(opts) + 1);\n\t\tsprintf(create_cmd, \"env USER='%s' FD_GEOM='%s' FD_SESS='%s' \"\n\t\t    \"FD_OPTS='%s' FD_EXTRA='%s' FD_PROG='%s' FD_XSRV='%s' FD_CUPS='%s' \"\n\t\t    \"FD_ESD='%s' FD_NAS='%s' FD_SMB='%s' FD_TAG='%s' FD_XDMCP_IF='%s' \"\n\t\t    \"FD_XDUMMY_RUN_AS_ROOT='%s' %s /bin/sh %s %s\",\n\t\t    uu, fdgeom, fdsess, fdopts, fdextra, fdprog, fdxsrv,\n\t\t    fdcups, fdesd, fdnas, fdsmb, fdtag, fdxdmcpif, fdxdum, cdout, tmp, opts);\n\t} else {\n\t\tcreate_cmd = (char *) malloc(strlen(tmp)\n\t\t    + strlen(\"/bin/sh \") + 1 + strlen(opts) + 1);\n\t\tsprintf(create_cmd, \"/bin/sh %s %s\", tmp, opts);\n\t}\n\treturn create_cmd;\n}",
    "includes": [
      "#include \"avahi.h\"",
      "#include \"sslhelper.h\"",
      "#include \"remote.h\"",
      "#include \"cursor.h\"",
      "#include \"keyboard.h\"",
      "#include \"inet.h\"",
      "#include \"connections.h\"",
      "#include \"xwrappers.h\"",
      "#include \"sslhelper.h\"",
      "#include \"unixpw.h\"",
      "#include \"screen.h\"",
      "#include \"scan.h\"",
      "#include \"cleanup.h\"",
      "#include \"solid.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "create_cmd",
            "\"/bin/sh %s %s\"",
            "tmp",
            "opts"
          ],
          "line": 2219
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "strlen(tmp)\n\t\t    + strlen(\"/bin/sh \") + 1 + strlen(opts) + 1"
          ],
          "line": 2217
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "opts"
          ],
          "line": 2218
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "\"/bin/sh \""
          ],
          "line": 2218
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "tmp"
          ],
          "line": 2217
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "create_cmd",
            "\"env USER='%s' FD_GEOM='%s' FD_SESS='%s' \"\n\t\t    \"FD_OPTS='%s' FD_EXTRA='%s' FD_PROG='%s' FD_XSRV='%s' FD_CUPS='%s' \"\n\t\t    \"FD_ESD='%s' FD_NAS='%s' FD_SMB='%s' FD_TAG='%s' FD_XDMCP_IF='%s' \"\n\t\t    \"FD_XDUMMY_RUN_AS_ROOT='%s' %s /bin/sh %s %s\"",
            "uu",
            "fdgeom",
            "fdsess",
            "fdopts",
            "fdextra",
            "fdprog",
            "fdxsrv",
            "fdcups",
            "fdesd",
            "fdnas",
            "fdsmb",
            "fdtag",
            "fdxdmcpif",
            "fdxdum",
            "cdout",
            "tmp",
            "opts"
          ],
          "line": 2210
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "strlen(tmp)+1\n\t\t    + strlen(\"env USER='' \")\n\t\t    + strlen(\"FD_GEOM='' \")\n\t\t    + strlen(\"FD_OPTS='' \")\n\t\t    + strlen(\"FD_EXTRA='' \")\n\t\t    + strlen(\"FD_PROG='' \")\n\t\t    + strlen(\"FD_XSRV='' \")\n\t\t    + strlen(\"FD_CUPS='' \")\n\t\t    + strlen(\"FD_ESD='' \")\n\t\t    + strlen(\"FD_NAS='' \")\n\t\t    + strlen(\"FD_SMB='' \")\n\t\t    + strlen(\"FD_TAG='' \")\n\t\t    + strlen(\"FD_XDMCP_IF='' \")\n\t\t    + strlen(\"FD_XDUMMY_RUN_AS_ROOT='' \")\n\t\t    + strlen(\"FD_SESS='' /bin/sh \")\n\t\t    + strlen(uu) + 1\n\t\t    + strlen(fdgeom) + 1\n\t\t    + strlen(fdopts) + 1\n\t\t    + strlen(fdextra) + 1\n\t\t    + strlen(fdprog) + 1\n\t\t    + strlen(fdxsrv) + 1\n\t\t    + strlen(fdcups) + 1\n\t\t    + strlen(fdesd) + 1\n\t\t    + strlen(fdnas) + 1\n\t\t    + strlen(fdsmb) + 1\n\t\t    + strlen(fdtag) + 1\n\t\t    + strlen(fdxdmcpif) + 1\n\t\t    + strlen(fdxdum) + 1\n\t\t    + strlen(fdsess) + 1\n\t\t    + strlen(cdout) + 1\n\t\t    + strlen(opts) + 1"
          ],
          "line": 2179
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "opts"
          ],
          "line": 2209
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "cdout"
          ],
          "line": 2208
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "fdsess"
          ],
          "line": 2207
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "fdxdum"
          ],
          "line": 2206
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "fdxdmcpif"
          ],
          "line": 2205
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "fdtag"
          ],
          "line": 2204
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "fdsmb"
          ],
          "line": 2203
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "fdnas"
          ],
          "line": 2202
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "fdesd"
          ],
          "line": 2201
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "fdcups"
          ],
          "line": 2200
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "fdxsrv"
          ],
          "line": 2199
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "fdprog"
          ],
          "line": 2198
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "fdextra"
          ],
          "line": 2197
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "fdopts"
          ],
          "line": 2196
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "fdgeom"
          ],
          "line": 2195
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "uu"
          ],
          "line": 2194
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "\"FD_SESS='' /bin/sh \""
          ],
          "line": 2193
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "\"FD_XDUMMY_RUN_AS_ROOT='' \""
          ],
          "line": 2192
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "\"FD_XDMCP_IF='' \""
          ],
          "line": 2191
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "\"FD_TAG='' \""
          ],
          "line": 2190
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "\"FD_SMB='' \""
          ],
          "line": 2189
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "\"FD_NAS='' \""
          ],
          "line": 2188
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "\"FD_ESD='' \""
          ],
          "line": 2187
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "\"FD_CUPS='' \""
          ],
          "line": 2186
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "\"FD_XSRV='' \""
          ],
          "line": 2185
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "\"FD_PROG='' \""
          ],
          "line": 2184
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "\"FD_EXTRA='' \""
          ],
          "line": 2183
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "\"FD_OPTS='' \""
          ],
          "line": 2182
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "\"FD_GEOM='' \""
          ],
          "line": 2181
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "\"env USER='' \""
          ],
          "line": 2180
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "tmp"
          ],
          "line": 2179
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "uu",
            "'\\''"
          ],
          "line": 2176
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_env",
          "args": [
            "\"FD_SESS\"",
            "fdsess"
          ],
          "line": 2169
        },
        "resolved": true,
        "details": {
          "function_name": "set_env",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/util.c",
          "lines": "239-249",
          "snippet": "void set_env(char *name, char *value) {\n\tchar *str;\n\tif (! name) {\n\t\treturn;\n\t}\n\tif (! value) {\n\t\tvalue = \"\";\n\t}\n\n\tsetenv(name, value, 1);\n}",
          "includes": [
            "#include \"connections.h\"",
            "#include \"unixpw.h\"",
            "#include \"win_utils.h\"",
            "#include \"cleanup.h\"",
            "#include \"x11vnc.h\"",
            "#include <stdlib.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void lowercase(char *str);",
            "void uppercase(char *str);",
            "char *lblanks(char *str);",
            "void strzero(char *str);",
            "void set_env(char *name, char *value);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"connections.h\"\n#include \"unixpw.h\"\n#include \"win_utils.h\"\n#include \"cleanup.h\"\n#include \"x11vnc.h\"\n#include <stdlib.h>\n\nvoid lowercase(char *str);\nvoid uppercase(char *str);\nchar *lblanks(char *str);\nvoid strzero(char *str);\nvoid set_env(char *name, char *value);\n\nvoid set_env(char *name, char *value) {\n\tchar *str;\n\tif (! name) {\n\t\treturn;\n\t}\n\tif (! value) {\n\t\tvalue = \"\";\n\t}\n\n\tsetenv(name, value, 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "cdout",
            "'\\''"
          ],
          "line": 2155
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "fdsess",
            "'\\''"
          ],
          "line": 2154
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "fdxdum",
            "'\\''"
          ],
          "line": 2153
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "fdxdmcpif",
            "'\\''"
          ],
          "line": 2152
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "fdtag",
            "'\\''"
          ],
          "line": 2151
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "fdsmb",
            "'\\''"
          ],
          "line": 2150
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "fdnas",
            "'\\''"
          ],
          "line": 2149
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "fdesd",
            "'\\''"
          ],
          "line": 2148
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "fdcups",
            "'\\''"
          ],
          "line": 2147
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "fdxsrv",
            "'\\''"
          ],
          "line": 2146
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "fdprog",
            "'\\''"
          ],
          "line": 2145
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "fdextra",
            "'\\''"
          ],
          "line": 2144
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "fdopts",
            "'\\''"
          ],
          "line": 2143
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "fdgeom",
            "'\\''"
          ],
          "line": 2142
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "cdout",
            "sizeof cdout",
            "\"CREATE_DISPLAY_OUTPUT='%s'\"",
            "getenv(\"CREATE_DISPLAY_OUTPUT\")"
          ],
          "line": 2139
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getenv",
          "args": [
            "\"CREATE_DISPLAY_OUTPUT\""
          ],
          "line": 2139
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getenv",
          "args": [
            "\"CREATE_DISPLAY_OUTPUT\""
          ],
          "line": 2138
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "fdxdum",
            "sizeof fdxdum",
            "\"%s\"",
            "getenv(\"FD_XDUMMY_RUN_AS_ROOT\")"
          ],
          "line": 2136
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getenv",
          "args": [
            "\"FD_XDUMMY_RUN_AS_ROOT\""
          ],
          "line": 2136
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getenv",
          "args": [
            "\"FD_XDUMMY_RUN_AS_ROOT\""
          ],
          "line": 2135
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "fdxdmcpif",
            "sizeof fdxdmcpif",
            "\"%s\"",
            "getenv(\"FD_XDMCP_IF\")"
          ],
          "line": 2133
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getenv",
          "args": [
            "\"FD_XDMCP_IF\""
          ],
          "line": 2133
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getenv",
          "args": [
            "\"FD_XDMCP_IF\""
          ],
          "line": 2132
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "fdtag",
            "sizeof fdtag",
            "\"%s\"",
            "getenv(\"FD_TAG\")"
          ],
          "line": 2130
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getenv",
          "args": [
            "\"FD_TAG\""
          ],
          "line": 2130
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getenv",
          "args": [
            "\"FD_TAG\""
          ],
          "line": 2129
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "fdsmb",
            "sizeof fdsmb",
            "\"%s\"",
            "getenv(\"FD_SMB\")"
          ],
          "line": 2127
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getenv",
          "args": [
            "\"FD_SMB\""
          ],
          "line": 2127
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getenv",
          "args": [
            "\"FD_SMB\""
          ],
          "line": 2126
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "fdnas",
            "sizeof fdnas",
            "\"%s\"",
            "getenv(\"FD_NAS\")"
          ],
          "line": 2124
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getenv",
          "args": [
            "\"FD_NAS\""
          ],
          "line": 2124
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getenv",
          "args": [
            "\"FD_NAS\""
          ],
          "line": 2123
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "fdesd",
            "sizeof fdesd",
            "\"%s\"",
            "getenv(\"FD_ESD\")"
          ],
          "line": 2121
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getenv",
          "args": [
            "\"FD_ESD\""
          ],
          "line": 2121
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getenv",
          "args": [
            "\"FD_ESD\""
          ],
          "line": 2120
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "fdcups",
            "sizeof fdcups",
            "\"%s\"",
            "getenv(\"FD_CUPS\")"
          ],
          "line": 2118
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getenv",
          "args": [
            "\"FD_CUPS\""
          ],
          "line": 2118
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getenv",
          "args": [
            "\"FD_CUPS\""
          ],
          "line": 2117
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "fdxsrv",
            "sizeof fdxsrv",
            "\"%s\"",
            "getenv(\"FD_XSRV\")"
          ],
          "line": 2115
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getenv",
          "args": [
            "\"FD_XSRV\""
          ],
          "line": 2115
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getenv",
          "args": [
            "\"FD_XSRV\""
          ],
          "line": 2114
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "fdprog",
            "sizeof fdprog",
            "\"%s\"",
            "getenv(\"FD_PROG\")"
          ],
          "line": 2112
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getenv",
          "args": [
            "\"FD_PROG\""
          ],
          "line": 2112
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getenv",
          "args": [
            "\"FD_PROG\""
          ],
          "line": 2111
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "fdextra",
            "sizeof fdextra",
            "\"%s\"",
            "getenv(\"FD_EXTRA\")"
          ],
          "line": 2108
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getenv",
          "args": [
            "\"FD_EXTRA\""
          ],
          "line": 2108
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "getenv(\"FD_EXTRA\")",
            "'\\''"
          ],
          "line": 2107
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getenv",
          "args": [
            "\"FD_EXTRA\""
          ],
          "line": 2107
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getenv",
          "args": [
            "\"FD_EXTRA\""
          ],
          "line": 2106
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "fdopts",
            "sizeof fdopts",
            "\"%s\"",
            "getenv(\"FD_OPTS\")"
          ],
          "line": 2104
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getenv",
          "args": [
            "\"FD_OPTS\""
          ],
          "line": 2104
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getenv",
          "args": [
            "\"FD_OPTS\""
          ],
          "line": 2103
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "fdsess",
            "sizeof fdsess",
            "\"%s\"",
            "getenv(\"FD_SESS\")"
          ],
          "line": 2101
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getenv",
          "args": [
            "\"FD_SESS\""
          ],
          "line": 2101
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getenv",
          "args": [
            "\"FD_SESS\""
          ],
          "line": 2100
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "fdgeom",
            "sizeof fdgeom",
            "\"%s\"",
            "getenv(\"FD_GEOM\")"
          ],
          "line": 2098
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getenv",
          "args": [
            "\"FD_GEOM\""
          ],
          "line": 2098
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getenv",
          "args": [
            "\"FD_GEOM\""
          ],
          "line": 2097
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "t"
          ],
          "line": 2095
        },
        "resolved": true,
        "details": {
          "function_name": "free_rect",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/userinput.c",
          "lines": "6200-6247",
          "snippet": "int free_rect(int idx) {\n\tint n, ok = 0;\n\tsraRegionPtr r1, r2;\n\tint x, y, w, h;\n\n\tif (idx < 0 || idx >= cache_list_num) {\nif (0) fprintf(stderr, \"free_rect: bad index: %d\\n\", idx);\n\t\tclean_up_exit(1);\n\t}\n\n\tx = cache_list[idx].bs_x;\n\ty = cache_list[idx].bs_y;\n\tw = cache_list[idx].bs_w;\n\th = cache_list[idx].bs_h;\n\n\tif (x < 0) {\n\t\tCLEAR(idx);\nif (dnow() > last_client + 5 && ncdb) fprintf(stderr, \"free_rect: already bs_x invalidated: %d bs_x: %d\\n\", idx, x);\n\t\treturn 1;\n\t}\n\n\tr2 = sraRgnCreateRect(x, y, x+w, y+h);\n\n\tn = get_bs_n(y);\n\tif (n >= 0) {\n\t\tr1 = rect_reg[n];\n\t\tsraRgnOr(r1, r2);\n\t\tok = 1;\n\t}\n\n\tif (zero_rects) {\n\t\tsraRgnOr(zero_rects, r2);\n\t\tx = cache_list[idx].su_x;\n\t\ty = cache_list[idx].su_y;\n\t\tw = cache_list[idx].su_w;\n\t\th = cache_list[idx].su_h;\n\t\tif (x >= 0) {\n\t\t\tsraRgnDestroy(r2);\n\t\t\tr2 = sraRgnCreateRect(x, y, x+w, y+h);\n\t\t\tsraRgnOr(zero_rects, r2);\n\t\t}\n\t}\n\tsraRgnDestroy(r2);\n\n\tCLEAR(idx);\nif (! ok && ncdb) fprintf(stderr, \"**** free_rect: not-found %d\\n\", idx);\n\treturn ok;\n}",
          "includes": [
            "#include \"default8x16.h\"",
            "#include \"connections.h\"",
            "#include \"screen.h\"",
            "#include \"cursor.h\"",
            "#include \"macosxCGS.h\"",
            "#include \"macosx.h\"",
            "#include \"unixpw.h\"",
            "#include \"8to24.h\"",
            "#include \"xrandr.h\"",
            "#include \"solid.h\"",
            "#include \"keyboard.h\"",
            "#include \"rates.h\"",
            "#include \"pointer.h\"",
            "#include \"cleanup.h\"",
            "#include \"scan.h\"",
            "#include \"user.h\"",
            "#include \"xevents.h\"",
            "#include \"win_utils.h\"",
            "#include \"xinerama.h\"",
            "#include \"xrecord.h\"",
            "#include \"xdamage.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void mark_for_xdamage(int x, int y, int w, int h);",
            "void set_xdamage_mark(int x, int y, int w, int h);",
            "int find_rect(int idx, int x, int y, int w, int h);",
            "winattr_t *cache_list;",
            "int clipped(int idx);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"default8x16.h\"\n#include \"connections.h\"\n#include \"screen.h\"\n#include \"cursor.h\"\n#include \"macosxCGS.h\"\n#include \"macosx.h\"\n#include \"unixpw.h\"\n#include \"8to24.h\"\n#include \"xrandr.h\"\n#include \"solid.h\"\n#include \"keyboard.h\"\n#include \"rates.h\"\n#include \"pointer.h\"\n#include \"cleanup.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"xevents.h\"\n#include \"win_utils.h\"\n#include \"xinerama.h\"\n#include \"xrecord.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nvoid mark_for_xdamage(int x, int y, int w, int h);\nvoid set_xdamage_mark(int x, int y, int w, int h);\nint find_rect(int idx, int x, int y, int w, int h);\nwinattr_t *cache_list;\nint clipped(int idx);\n\nint free_rect(int idx) {\n\tint n, ok = 0;\n\tsraRegionPtr r1, r2;\n\tint x, y, w, h;\n\n\tif (idx < 0 || idx >= cache_list_num) {\nif (0) fprintf(stderr, \"free_rect: bad index: %d\\n\", idx);\n\t\tclean_up_exit(1);\n\t}\n\n\tx = cache_list[idx].bs_x;\n\ty = cache_list[idx].bs_y;\n\tw = cache_list[idx].bs_w;\n\th = cache_list[idx].bs_h;\n\n\tif (x < 0) {\n\t\tCLEAR(idx);\nif (dnow() > last_client + 5 && ncdb) fprintf(stderr, \"free_rect: already bs_x invalidated: %d bs_x: %d\\n\", idx, x);\n\t\treturn 1;\n\t}\n\n\tr2 = sraRgnCreateRect(x, y, x+w, y+h);\n\n\tn = get_bs_n(y);\n\tif (n >= 0) {\n\t\tr1 = rect_reg[n];\n\t\tsraRgnOr(r1, r2);\n\t\tok = 1;\n\t}\n\n\tif (zero_rects) {\n\t\tsraRgnOr(zero_rects, r2);\n\t\tx = cache_list[idx].su_x;\n\t\ty = cache_list[idx].su_y;\n\t\tw = cache_list[idx].su_w;\n\t\th = cache_list[idx].su_h;\n\t\tif (x >= 0) {\n\t\t\tsraRgnDestroy(r2);\n\t\t\tr2 = sraRgnCreateRect(x, y, x+w, y+h);\n\t\t\tsraRgnOr(zero_rects, r2);\n\t\t}\n\t}\n\tsraRgnDestroy(r2);\n\n\tCLEAR(idx);\nif (! ok && ncdb) fprintf(stderr, \"**** free_rect: not-found %d\\n\", idx);\n\treturn ok;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "fdtag",
            "\"%s\"",
            "q"
          ],
          "line": 2090
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"bad tag char: '%c' in '%s'\\n\"",
            "c",
            "q"
          ],
          "line": 2084
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isalnum",
          "args": [
            "(int) c"
          ],
          "line": 2082
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "q",
            "'='"
          ],
          "line": 2076
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "q"
          ],
          "line": 2073
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "q",
            "','"
          ],
          "line": 2070
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "t",
            "\"tag=\""
          ],
          "line": 2069
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getenv",
          "args": [
            "\"FD_TAG\""
          ],
          "line": 2066
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "fdesd",
            "\"%d\"",
            "p"
          ],
          "line": 2063
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sscanf",
          "args": [
            "q",
            "\"esd=%d\"",
            "&p"
          ],
          "line": 2062
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "t",
            "\"esd=\""
          ],
          "line": 2059
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "fdcups",
            "\"%d\"",
            "p"
          ],
          "line": 2056
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sscanf",
          "args": [
            "q",
            "\"cups=%d\"",
            "&p"
          ],
          "line": 2055
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "t",
            "\"cups=\""
          ],
          "line": 2052
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"set create display geom: %s\\n\"",
            "fdgeom"
          ],
          "line": 2048
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "fdgeom",
            "\"%s\"",
            "q"
          ],
          "line": 2046
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "q"
          ],
          "line": 2045
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isdigit",
          "args": [
            "(int) *p"
          ],
          "line": 2037
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "q",
            "\",\""
          ],
          "line": 2031
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "q",
            "\"=\""
          ],
          "line": 2029
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "t",
            "\"geometry=\""
          ],
          "line": 2026
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "t",
            "\"geom=\""
          ],
          "line": 2025
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "t",
            "\"ge=\""
          ],
          "line": 2024
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "fdsess",
            "\"failsafe\""
          ],
          "line": 2021
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "t",
            "\"failsafe\""
          ],
          "line": 2020
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "fdsess",
            "\"Xsession\""
          ],
          "line": 2019
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "t",
            "\"Xsession\""
          ],
          "line": 2018
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "fdsess",
            "\"enlightenment\""
          ],
          "line": 2017
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "t",
            "\"enlightenment\""
          ],
          "line": 2016
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "fdsess",
            "\"xfce\""
          ],
          "line": 2015
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "t",
            "\"xfce\""
          ],
          "line": 2014
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "fdsess",
            "\"wmaker\""
          ],
          "line": 2013
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "t",
            "\"wmaker\""
          ],
          "line": 2012
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "fdsess",
            "\"xterm\""
          ],
          "line": 2011
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "t",
            "\"xterm\""
          ],
          "line": 2010
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "fdsess",
            "\"dtwm\""
          ],
          "line": 2009
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "t",
            "\"dtwm\""
          ],
          "line": 2008
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "fdsess",
            "\"cde\""
          ],
          "line": 2007
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "t",
            "\"cde\""
          ],
          "line": 2006
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "fdsess",
            "\"mwm\""
          ],
          "line": 2005
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "t",
            "\"mwm\""
          ],
          "line": 2004
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "fdsess",
            "\"fvwm\""
          ],
          "line": 2003
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "t",
            "\"fvwm\""
          ],
          "line": 2002
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "fdsess",
            "\"twm\""
          ],
          "line": 2001
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "t",
            "\"twm\""
          ],
          "line": 2000
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "fdsess",
            "\"lxde\""
          ],
          "line": 1999
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "t",
            "\"lxde\""
          ],
          "line": 1998
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "fdsess",
            "\"kde\""
          ],
          "line": 1997
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "t",
            "\"kde\""
          ],
          "line": 1996
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "fdsess",
            "\"gnome\""
          ],
          "line": 1995
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "t",
            "\"gnome\""
          ],
          "line": 1994
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "keep_unixpw_opts"
          ],
          "line": 1992
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getenv",
          "args": [
            "\"X11VNC_NO_UNIXPW_OPTS\""
          ],
          "line": 1991
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "fdgeom",
            "\"NONE\""
          ],
          "line": 1975
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "opts",
            "\"xdmcp\""
          ],
          "line": 1969
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "cmd",
            "'-'"
          ],
          "line": 1960
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"avahi.h\"\n#include \"sslhelper.h\"\n#include \"remote.h\"\n#include \"cursor.h\"\n#include \"keyboard.h\"\n#include \"inet.h\"\n#include \"connections.h\"\n#include \"xwrappers.h\"\n#include \"sslhelper.h\"\n#include \"unixpw.h\"\n#include \"screen.h\"\n#include \"scan.h\"\n#include \"cleanup.h\"\n#include \"solid.h\"\n#include \"x11vnc.h\"\n\nstatic char *build_create_cmd(char *cmd, int *saw_xdmcp, char *usslpeer, char *tmp) {\n\tchar *create_cmd = NULL;\n\tchar *opts = strchr(cmd, '-');\n\tchar st[] = \"\";\n\tchar fdgeom[128], fdsess[128], fdopts[128], fdextra[256], fdprog[128];\n\tchar fdxsrv[128], fdxdum[128], fdcups[128], fdesd[128];\n\tchar fdnas[128], fdsmb[128], fdtag[128], fdxdmcpif[128];\n\tchar cdout[128];\n\n\tif (opts) {\n\t\topts++;\n\t\tif (strstr(opts, \"xdmcp\")) {\n\t\t\t*saw_xdmcp = 1;\n\t\t}\n\t} else {\n\t\topts = st;\n\t}\n\tsprintf(fdgeom, \"NONE\");\n\tfdsess[0] = '\\0';\n\tfdgeom[0] = '\\0';\n\tfdopts[0] = '\\0';\n\tfdextra[0] = '\\0';\n\tfdprog[0] = '\\0';\n\tfdxsrv[0] = '\\0';\n\tfdxdum[0] = '\\0';\n\tfdcups[0] = '\\0';\n\tfdesd[0]  = '\\0';\n\tfdnas[0]  = '\\0';\n\tfdsmb[0]  = '\\0';\n\tfdtag[0]  = '\\0';\n\tfdxdmcpif[0]  = '\\0';\n\tcdout[0]  = '\\0';\n\n\tif (unixpw && keep_unixpw_opts && !getenv(\"X11VNC_NO_UNIXPW_OPTS\")) {\n\t\tchar *q, *p, *t = strdup(keep_unixpw_opts);\n\n\t\tif (strstr(t, \"gnome\")) {\n\t\t\tsprintf(fdsess, \"gnome\");\n\t\t} else if (strstr(t, \"kde\")) {\n\t\t\tsprintf(fdsess, \"kde\");\n\t\t} else if (strstr(t, \"lxde\")) {\n\t\t\tsprintf(fdsess, \"lxde\");\n\t\t} else if (strstr(t, \"twm\")) {\n\t\t\tsprintf(fdsess, \"twm\");\n\t\t} else if (strstr(t, \"fvwm\")) {\n\t\t\tsprintf(fdsess, \"fvwm\");\n\t\t} else if (strstr(t, \"mwm\")) {\n\t\t\tsprintf(fdsess, \"mwm\");\n\t\t} else if (strstr(t, \"cde\")) {\n\t\t\tsprintf(fdsess, \"cde\");\n\t\t} else if (strstr(t, \"dtwm\")) {\n\t\t\tsprintf(fdsess, \"dtwm\");\n\t\t} else if (strstr(t, \"xterm\")) {\n\t\t\tsprintf(fdsess, \"xterm\");\n\t\t} else if (strstr(t, \"wmaker\")) {\n\t\t\tsprintf(fdsess, \"wmaker\");\n\t\t} else if (strstr(t, \"xfce\")) {\n\t\t\tsprintf(fdsess, \"xfce\");\n\t\t} else if (strstr(t, \"enlightenment\")) {\n\t\t\tsprintf(fdsess, \"enlightenment\");\n\t\t} else if (strstr(t, \"Xsession\")) {\n\t\t\tsprintf(fdsess, \"Xsession\");\n\t\t} else if (strstr(t, \"failsafe\")) {\n\t\t\tsprintf(fdsess, \"failsafe\");\n\t\t}\n\n\t\tq = strstr(t, \"ge=\");\n\t\tif (! q) q = strstr(t, \"geom=\");\n\t\tif (! q) q = strstr(t, \"geometry=\");\n\t\tif (q) {\n\t\t\tint ok = 1;\n\t\t\tq = strstr(q, \"=\");\n\t\t\tq++;\n\t\t\tp = strstr(q, \",\");\n\t\t\tif (p) *p = '\\0';\n\t\t\tp = q;\n\t\t\twhile (*p) {\n\t\t\t\tif (*p == 'x') {\n\t\t\t\t\t;\n\t\t\t\t} else if (isdigit((int) *p)) {\n\t\t\t\t\t;\n\t\t\t\t} else {\n\t\t\t\t\tok = 0;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tp++;\n\t\t\t}\n\t\t\tif (ok && strlen(q) < 32) {\n\t\t\t\tsprintf(fdgeom, \"%s\", q);\n\t\t\t\tif (!quiet) {\n\t\t\t\t\trfbLog(\"set create display geom: %s\\n\", fdgeom);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tq = strstr(t, \"cups=\");\n\t\tif (q) {\n\t\t\tint p;\n\t\t\tif (sscanf(q, \"cups=%d\", &p) == 1) {\n\t\t\t\tsprintf(fdcups, \"%d\", p);\n\t\t\t}\n\t\t}\n\t\tq = strstr(t, \"esd=\");\n\t\tif (q) {\n\t\t\tint p;\n\t\t\tif (sscanf(q, \"esd=%d\", &p) == 1) {\n\t\t\t\tsprintf(fdesd, \"%d\", p);\n\t\t\t}\n\t\t}\n\t\tif (!getenv(\"FD_TAG\")) {\n\t\t\tchar *s = NULL;\n\n\t\t\tq = strstr(t, \"tag=\");\n\t\t\tif (q) s = strchr(q, ',');\n\t\t\tif (s) *s = '\\0';\n\n\t\t\tif (q && strlen(q) < 120) {\n\t\t\t\tchar *p;\n\t\t\t\tint ok = 1;\n\t\t\t\tq = strchr(q, '=') + 1;\n\t\t\t\tp = q;\n\t\t\t\twhile (*p != '\\0') {\n\t\t\t\t\tchar c = *p;\n\t\t\t\t\tif (*p == '_' || *p == '-') {\n\t\t\t\t\t\t;\n\t\t\t\t\t} else if (!isalnum((int) c)) {\n\t\t\t\t\t\tok = 0;\n\t\t\t\t\t\trfbLog(\"bad tag char: '%c' in '%s'\\n\", c, q);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tp++;\n\t\t\t\t}\n\t\t\t\tif (ok) {\n\t\t\t\t\tsprintf(fdtag, \"%s\", q);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (s) *s = ',';\n\t\t}\n\t\tfree(t);\n\t}\n\tif (fdgeom[0] == '\\0' && getenv(\"FD_GEOM\")) {\n\t\tsnprintf(fdgeom,  sizeof fdgeom, \"%s\", getenv(\"FD_GEOM\"));\n\t}\n\tif (fdsess[0] == '\\0' && getenv(\"FD_SESS\")) {\n\t\tsnprintf(fdsess, sizeof fdsess, \"%s\", getenv(\"FD_SESS\"));\n\t}\n\tif (fdopts[0] == '\\0' && getenv(\"FD_OPTS\")) {\n\t\tsnprintf(fdopts, sizeof fdopts, \"%s\", getenv(\"FD_OPTS\"));\n\t}\n\tif (fdextra[0] == '\\0' && getenv(\"FD_EXTRA\")) {\n\t\tif (!strchr(getenv(\"FD_EXTRA\"), '\\'')) {\n\t\t\tsnprintf(fdextra, sizeof fdextra, \"%s\", getenv(\"FD_EXTRA\"));\n\t\t}\n\t}\n\tif (fdprog[0] == '\\0' && getenv(\"FD_PROG\")) {\n\t\tsnprintf(fdprog, sizeof fdprog, \"%s\", getenv(\"FD_PROG\"));\n\t}\n\tif (fdxsrv[0] == '\\0' && getenv(\"FD_XSRV\")) {\n\t\tsnprintf(fdxsrv, sizeof fdxsrv, \"%s\", getenv(\"FD_XSRV\"));\n\t}\n\tif (fdcups[0] == '\\0' && getenv(\"FD_CUPS\")) {\n\t\tsnprintf(fdcups, sizeof fdcups, \"%s\", getenv(\"FD_CUPS\"));\n\t}\n\tif (fdesd[0] == '\\0' && getenv(\"FD_ESD\")) {\n\t\tsnprintf(fdesd, sizeof fdesd, \"%s\", getenv(\"FD_ESD\"));\n\t}\n\tif (fdnas[0] == '\\0' && getenv(\"FD_NAS\")) {\n\t\tsnprintf(fdnas, sizeof fdnas, \"%s\", getenv(\"FD_NAS\"));\n\t}\n\tif (fdsmb[0] == '\\0' && getenv(\"FD_SMB\")) {\n\t\tsnprintf(fdsmb, sizeof fdsmb, \"%s\", getenv(\"FD_SMB\"));\n\t}\n\tif (fdtag[0] == '\\0' && getenv(\"FD_TAG\")) {\n\t\tsnprintf(fdtag, sizeof fdtag, \"%s\", getenv(\"FD_TAG\"));\n\t}\n\tif (fdxdmcpif[0] == '\\0' && getenv(\"FD_XDMCP_IF\")) {\n\t\tsnprintf(fdxdmcpif,  sizeof fdxdmcpif, \"%s\", getenv(\"FD_XDMCP_IF\"));\n\t}\n\tif (fdxdum[0] == '\\0' && getenv(\"FD_XDUMMY_RUN_AS_ROOT\")) {\n\t\tsnprintf(fdxdum, sizeof fdxdum, \"%s\", getenv(\"FD_XDUMMY_RUN_AS_ROOT\"));\n\t}\n\tif (getenv(\"CREATE_DISPLAY_OUTPUT\")) {\n\t\tsnprintf(cdout, sizeof cdout, \"CREATE_DISPLAY_OUTPUT='%s'\", getenv(\"CREATE_DISPLAY_OUTPUT\"));\n\t}\n\n\tif (strchr(fdgeom, '\\''))\tfdgeom[0] = '\\0';\n\tif (strchr(fdopts, '\\''))\tfdopts[0] = '\\0';\n\tif (strchr(fdextra, '\\''))\tfdextra[0] = '\\0';\n\tif (strchr(fdprog, '\\''))\tfdprog[0] = '\\0';\n\tif (strchr(fdxsrv, '\\''))\tfdxsrv[0] = '\\0';\n\tif (strchr(fdcups, '\\''))\tfdcups[0] = '\\0';\n\tif (strchr(fdesd, '\\''))\tfdesd[0] = '\\0';\n\tif (strchr(fdnas, '\\''))\tfdnas[0] = '\\0';\n\tif (strchr(fdsmb, '\\''))\tfdsmb[0] = '\\0';\n\tif (strchr(fdtag, '\\''))\tfdtag[0] = '\\0';\n\tif (strchr(fdxdmcpif, '\\''))\tfdxdmcpif[0] = '\\0';\n\tif (strchr(fdxdum, '\\''))\tfdxdum[0] = '\\0';\n\tif (strchr(fdsess, '\\''))\tfdsess[0] = '\\0';\n\tif (strchr(cdout, '\\''))\tcdout[0] = '\\0';\n\n\tset_env(\"FD_GEOM\", fdgeom);\n\tset_env(\"FD_OPTS\", fdopts);\n\tset_env(\"FD_EXTRA\", fdextra);\n\tset_env(\"FD_PROG\", fdprog);\n\tset_env(\"FD_XSRV\", fdxsrv);\n\tset_env(\"FD_CUPS\", fdcups);\n\tset_env(\"FD_ESD\",  fdesd);\n\tset_env(\"FD_NAS\",  fdnas);\n\tset_env(\"FD_SMB\",  fdsmb);\n\tset_env(\"FD_TAG\",  fdtag);\n\tset_env(\"FD_XDMCP_IF\",  fdxdmcpif);\n\tset_env(\"FD_XDUMMY_RUN_AS_ROOT\", fdxdum);\n\tset_env(\"FD_SESS\", fdsess);\n\n\tif (usslpeer || (unixpw && keep_unixpw_user)) {\n\t\tchar *uu = usslpeer;\n\t\tif (!uu) {\n\t\t\tuu = keep_unixpw_user;\n\t\t}\n\t\tif (strchr(uu, '\\''))  {\n\t\t\tuu = \"\";\n\t\t}\n\t\tcreate_cmd = (char *) malloc(strlen(tmp)+1\n\t\t    + strlen(\"env USER='' \")\n\t\t    + strlen(\"FD_GEOM='' \")\n\t\t    + strlen(\"FD_OPTS='' \")\n\t\t    + strlen(\"FD_EXTRA='' \")\n\t\t    + strlen(\"FD_PROG='' \")\n\t\t    + strlen(\"FD_XSRV='' \")\n\t\t    + strlen(\"FD_CUPS='' \")\n\t\t    + strlen(\"FD_ESD='' \")\n\t\t    + strlen(\"FD_NAS='' \")\n\t\t    + strlen(\"FD_SMB='' \")\n\t\t    + strlen(\"FD_TAG='' \")\n\t\t    + strlen(\"FD_XDMCP_IF='' \")\n\t\t    + strlen(\"FD_XDUMMY_RUN_AS_ROOT='' \")\n\t\t    + strlen(\"FD_SESS='' /bin/sh \")\n\t\t    + strlen(uu) + 1\n\t\t    + strlen(fdgeom) + 1\n\t\t    + strlen(fdopts) + 1\n\t\t    + strlen(fdextra) + 1\n\t\t    + strlen(fdprog) + 1\n\t\t    + strlen(fdxsrv) + 1\n\t\t    + strlen(fdcups) + 1\n\t\t    + strlen(fdesd) + 1\n\t\t    + strlen(fdnas) + 1\n\t\t    + strlen(fdsmb) + 1\n\t\t    + strlen(fdtag) + 1\n\t\t    + strlen(fdxdmcpif) + 1\n\t\t    + strlen(fdxdum) + 1\n\t\t    + strlen(fdsess) + 1\n\t\t    + strlen(cdout) + 1\n\t\t    + strlen(opts) + 1);\n\t\tsprintf(create_cmd, \"env USER='%s' FD_GEOM='%s' FD_SESS='%s' \"\n\t\t    \"FD_OPTS='%s' FD_EXTRA='%s' FD_PROG='%s' FD_XSRV='%s' FD_CUPS='%s' \"\n\t\t    \"FD_ESD='%s' FD_NAS='%s' FD_SMB='%s' FD_TAG='%s' FD_XDMCP_IF='%s' \"\n\t\t    \"FD_XDUMMY_RUN_AS_ROOT='%s' %s /bin/sh %s %s\",\n\t\t    uu, fdgeom, fdsess, fdopts, fdextra, fdprog, fdxsrv,\n\t\t    fdcups, fdesd, fdnas, fdsmb, fdtag, fdxdmcpif, fdxdum, cdout, tmp, opts);\n\t} else {\n\t\tcreate_cmd = (char *) malloc(strlen(tmp)\n\t\t    + strlen(\"/bin/sh \") + 1 + strlen(opts) + 1);\n\t\tsprintf(create_cmd, \"/bin/sh %s %s\", tmp, opts);\n\t}\n\treturn create_cmd;\n}"
  },
  {
    "function_name": "setup_cmd",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/user.c",
    "lines": "1885-1956",
    "snippet": "char *setup_cmd(char *str, int *vnc_redirect, char **vnc_redirect_host, int *vnc_redirect_port, int db) {\n\tchar *cmd = NULL;\n\t\n\tif (no_external_cmds || !cmd_ok(\"WAIT\")) {\n\t\trfbLog(\"wait_for_client external cmds not allowed:\"\n\t\t    \" %s\\n\", use_dpy);\n\t\tclean_up_exit(1);\n\t}\n\n\tcmd = str + strlen(\"cmd=\");\n\tif (!strcmp(cmd, \"FINDDISPLAY-print\")) {\n\t\tfprintf(stdout, \"%s\", find_display);\n\t\tclean_up_exit(0);\n\t}\n\tif (!strcmp(cmd, \"FINDDISPLAY-run\")) {\n\t\tchar tmp[] = \"/tmp/fd.XXXXXX\";\n\t\tchar com[100];\n\t\tint fd = mkstemp(tmp);\n\t\tif (fd >= 0) {\n\t\t\tint ret;\n\t\t\twrite(fd, find_display, strlen(find_display));\n\t\t\tclose(fd);\n\t\t\tset_env(\"FINDDISPLAY_run\", \"1\");\n\t\t\tsprintf(com, \"/bin/sh %s -n\", tmp);\n\t\t\tret = system(com);\n\t\t\tif (WIFEXITED(ret) && WEXITSTATUS(ret) != 0) {\n\t\t\t\tif (got_findauth && !getenv(\"FD_XDM\")) {\n\t\t\t\t\tif (getuid() == 0 || geteuid() == 0) {\n\t\t\t\t\t\tset_env(\"FD_XDM\", \"1\");\n\t\t\t\t\t\tsystem(com);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tunlink(tmp);\n\t\texit(0);\n\t}\n\tif (!strcmp(str, \"FINDCREATEDISPLAY-print\")) {\n\t\tfprintf(stdout, \"%s\", create_display);\n\t\tclean_up_exit(0);\n\t}\n\tif (db) fprintf(stderr, \"cmd: %s\\n\", cmd);\n\tif (strstr(str, \"FINDCREATEDISPLAY\") || strstr(str, \"FINDDISPLAY\")) {\n\t\tif (strstr(str, \"Xvnc.redirect\") || strstr(str, \"X.redirect\")) {\n\t\t\t*vnc_redirect = 1;\n\t\t}\n\t}\n\tif (strstr(cmd, \"FINDDISPLAY-vnc_redirect\") == cmd) {\n\t\tint p;\n\t\tchar h[256];\n\t\tif (strlen(cmd) >= 256) {\n\t\t\trfbLog(\"wait_for_client string too long: %s\\n\", str);\n\t\t\tclean_up_exit(1);\n\t\t}\n\t\th[0] = '\\0';\n\t\tif (sscanf(cmd, \"FINDDISPLAY-vnc_redirect=%d\", &p) == 1) {\n\t\t\t;\n\t\t} else if (sscanf(cmd, \"FINDDISPLAY-vnc_redirect=%s %d\", h, &p) == 2) {\n\t\t\t;\n\t\t} else {\n\t\t\trfbLog(\"wait_for_client bad string: %s\\n\", cmd);\n\t\t\tclean_up_exit(1);\n\t\t}\n\t\t*vnc_redirect_port = p;\n\t\tif (strcmp(h, \"\")) {\n\t\t\t*vnc_redirect_host = strdup(h);\n\t\t}\n\t\t*vnc_redirect = 2;\n\t\trfbLog(\"wait_for_client: vnc_redirect: %s:%d\\n\", *vnc_redirect_host, *vnc_redirect_port);\n\t}\n\treturn cmd;\n}",
    "includes": [
      "#include \"avahi.h\"",
      "#include \"sslhelper.h\"",
      "#include \"remote.h\"",
      "#include \"cursor.h\"",
      "#include \"keyboard.h\"",
      "#include \"inet.h\"",
      "#include \"connections.h\"",
      "#include \"xwrappers.h\"",
      "#include \"sslhelper.h\"",
      "#include \"unixpw.h\"",
      "#include \"screen.h\"",
      "#include \"scan.h\"",
      "#include \"cleanup.h\"",
      "#include \"solid.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "void lurk_loop(char *str);",
      "extern char find_display[];",
      "extern char create_display[];"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"wait_for_client: vnc_redirect: %s:%d\\n\"",
            "*vnc_redirect_host",
            "*vnc_redirect_port"
          ],
          "line": 1953
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "h"
          ],
          "line": 1950
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "h",
            "\"\""
          ],
          "line": 1949
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clean_up_exit",
          "args": [
            "1"
          ],
          "line": 1946
        },
        "resolved": true,
        "details": {
          "function_name": "clean_up_exit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/cleanup.c",
          "lines": "151-266",
          "snippet": "void clean_up_exit(int ret) {\n\tstatic int depth = 0;\n\texit_flag = 1;\n\n\tif (depth++ > 2) {\n\t\texit(ret);\n\t}\n\n\tif (icon_mode) {\n\t\tclean_icon_mode();\n\t}\n\n\t/* remove the shm areas: */\n\tclean_shm(0);\n\n\tstop_stunnel();\n\tif (use_openssl) {\n\t\tssl_helper_pid(0, 0);\t/* killall */\n\t}\n\n\tif (ssh_pid > 0) {\n\t\tkill(ssh_pid, SIGTERM);\n\t\tssh_pid = 0;\n\t}\n\n#ifdef MACOSX\n\tif (client_connect_file) {\n\t\tif (strstr(client_connect_file, \"/tmp/x11vnc-macosx-remote\")\n\t\t    == client_connect_file) {\n\t\t\tunlink(client_connect_file);\n\t\t}\n\t}\n\tif (macosx_console) {\n\t\tmacosxCG_fini();\n\t}\n#endif\n\n\tif (pipeinput_fh != NULL) {\n\t\tpclose(pipeinput_fh);\n\t\tpipeinput_fh = NULL;\n\t}\n\n\tshutdown_uinput();\n\n\tif (unix_sock) {\n\t\tif (unix_sock_fd >= 0) {\n\t\t\trfbLog(\"deleting unix sock: %s\\n\", unix_sock);\n\t\t\tclose(unix_sock_fd);\n\t\t\tunix_sock_fd = -1;\n\t\t\tunlink(unix_sock);\n\t\t}\n\t}\n\n\tif (! dpy) {\t/* raw_rb hack */\n\t\tif (rm_flagfile) {\n\t\t\tunlink(rm_flagfile);\n\t\t\trm_flagfile = NULL;\n\t\t}\n\t\texit(ret);\n\t}\n\n\t/* X keyboard cleanups */\n\tdelete_added_keycodes(0);\n\n\t/* remove all created XInput2 devices */\n\tif(use_multipointer)\n\t    removeAllMDs(dpy);\n\n\tif (clear_mods == 1) {\n\t\tclear_modifiers(0);\n\t} else if (clear_mods == 2) {\n\t\tclear_keys();\n\t} else if (clear_mods == 3) {\n\t\tclear_keys();\n\t\tclear_locks();\n\t}\n\n\tif (no_autorepeat) {\n\t\tautorepeat(1, 0);\n\t}\n\tif (use_solid_bg) {\n\t\tsolid_bg(1);\n\t}\n\tif (ncache || ncache0) {\n\t\tkde_no_animate(1);\n\t}\n\tX_LOCK;\n\tXTestDiscard_wr(dpy);\n#if HAVE_LIBXDAMAGE\n\tif (xdamage) {\n\t\tXDamageDestroy(dpy, xdamage);\n\t}\n#endif\n#if HAVE_LIBXTRAP\n\tif (trap_ctx) {\n\t\tXEFreeTC(trap_ctx);\n\t}\n#endif\n\t/* XXX rdpy_ctrl, etc. cannot close w/o blocking */\n\tXCloseDisplay_wr(dpy);\n\tX_UNLOCK;\n\n\tfflush(stderr);\n\n\tif (rm_flagfile) {\n\t\tunlink(rm_flagfile);\n\t\trm_flagfile = NULL;\n\t}\n\n\tif (avahi) {\n\t\tavahi_cleanup();\n\t\tfflush(stderr);\n\t}\n\n\texit(ret);\n}",
          "includes": [
            "#include \"xi2_devices.h\"",
            "#include \"uinput.h\"",
            "#include \"xevents.h\"",
            "#include \"xrecord.h\"",
            "#include \"screen.h\"",
            "#include \"avahi.h\"",
            "#include \"macosxCG.h\"",
            "#include \"macosx.h\"",
            "#include \"connections.h\"",
            "#include \"sslhelper.h\"",
            "#include \"sslcmds.h\"",
            "#include \"unixpw.h\"",
            "#include \"solid.h\"",
            "#include \"gui.h\"",
            "#include \"scan.h\"",
            "#include \"keyboard.h\"",
            "#include \"remote.h\"",
            "#include \"xdamage.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void clean_up_exit(int ret);",
            "int known_sigpipe_mode(char *s);",
            "static int exit_flag = 0;",
            "static void clean_icon_mode(void);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xi2_devices.h\"\n#include \"uinput.h\"\n#include \"xevents.h\"\n#include \"xrecord.h\"\n#include \"screen.h\"\n#include \"avahi.h\"\n#include \"macosxCG.h\"\n#include \"macosx.h\"\n#include \"connections.h\"\n#include \"sslhelper.h\"\n#include \"sslcmds.h\"\n#include \"unixpw.h\"\n#include \"solid.h\"\n#include \"gui.h\"\n#include \"scan.h\"\n#include \"keyboard.h\"\n#include \"remote.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nvoid clean_up_exit(int ret);\nint known_sigpipe_mode(char *s);\nstatic int exit_flag = 0;\nstatic void clean_icon_mode(void);\n\nvoid clean_up_exit(int ret) {\n\tstatic int depth = 0;\n\texit_flag = 1;\n\n\tif (depth++ > 2) {\n\t\texit(ret);\n\t}\n\n\tif (icon_mode) {\n\t\tclean_icon_mode();\n\t}\n\n\t/* remove the shm areas: */\n\tclean_shm(0);\n\n\tstop_stunnel();\n\tif (use_openssl) {\n\t\tssl_helper_pid(0, 0);\t/* killall */\n\t}\n\n\tif (ssh_pid > 0) {\n\t\tkill(ssh_pid, SIGTERM);\n\t\tssh_pid = 0;\n\t}\n\n#ifdef MACOSX\n\tif (client_connect_file) {\n\t\tif (strstr(client_connect_file, \"/tmp/x11vnc-macosx-remote\")\n\t\t    == client_connect_file) {\n\t\t\tunlink(client_connect_file);\n\t\t}\n\t}\n\tif (macosx_console) {\n\t\tmacosxCG_fini();\n\t}\n#endif\n\n\tif (pipeinput_fh != NULL) {\n\t\tpclose(pipeinput_fh);\n\t\tpipeinput_fh = NULL;\n\t}\n\n\tshutdown_uinput();\n\n\tif (unix_sock) {\n\t\tif (unix_sock_fd >= 0) {\n\t\t\trfbLog(\"deleting unix sock: %s\\n\", unix_sock);\n\t\t\tclose(unix_sock_fd);\n\t\t\tunix_sock_fd = -1;\n\t\t\tunlink(unix_sock);\n\t\t}\n\t}\n\n\tif (! dpy) {\t/* raw_rb hack */\n\t\tif (rm_flagfile) {\n\t\t\tunlink(rm_flagfile);\n\t\t\trm_flagfile = NULL;\n\t\t}\n\t\texit(ret);\n\t}\n\n\t/* X keyboard cleanups */\n\tdelete_added_keycodes(0);\n\n\t/* remove all created XInput2 devices */\n\tif(use_multipointer)\n\t    removeAllMDs(dpy);\n\n\tif (clear_mods == 1) {\n\t\tclear_modifiers(0);\n\t} else if (clear_mods == 2) {\n\t\tclear_keys();\n\t} else if (clear_mods == 3) {\n\t\tclear_keys();\n\t\tclear_locks();\n\t}\n\n\tif (no_autorepeat) {\n\t\tautorepeat(1, 0);\n\t}\n\tif (use_solid_bg) {\n\t\tsolid_bg(1);\n\t}\n\tif (ncache || ncache0) {\n\t\tkde_no_animate(1);\n\t}\n\tX_LOCK;\n\tXTestDiscard_wr(dpy);\n#if HAVE_LIBXDAMAGE\n\tif (xdamage) {\n\t\tXDamageDestroy(dpy, xdamage);\n\t}\n#endif\n#if HAVE_LIBXTRAP\n\tif (trap_ctx) {\n\t\tXEFreeTC(trap_ctx);\n\t}\n#endif\n\t/* XXX rdpy_ctrl, etc. cannot close w/o blocking */\n\tXCloseDisplay_wr(dpy);\n\tX_UNLOCK;\n\n\tfflush(stderr);\n\n\tif (rm_flagfile) {\n\t\tunlink(rm_flagfile);\n\t\trm_flagfile = NULL;\n\t}\n\n\tif (avahi) {\n\t\tavahi_cleanup();\n\t\tfflush(stderr);\n\t}\n\n\texit(ret);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"wait_for_client bad string: %s\\n\"",
            "cmd"
          ],
          "line": 1945
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sscanf",
          "args": [
            "cmd",
            "\"FINDDISPLAY-vnc_redirect=%s %d\"",
            "h",
            "&p"
          ],
          "line": 1942
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sscanf",
          "args": [
            "cmd",
            "\"FINDDISPLAY-vnc_redirect=%d\"",
            "&p"
          ],
          "line": 1940
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"wait_for_client string too long: %s\\n\"",
            "str"
          ],
          "line": 1936
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "cmd"
          ],
          "line": 1935
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "cmd",
            "\"FINDDISPLAY-vnc_redirect\""
          ],
          "line": 1932
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "str",
            "\"X.redirect\""
          ],
          "line": 1928
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "str",
            "\"Xvnc.redirect\""
          ],
          "line": 1928
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "str",
            "\"FINDDISPLAY\""
          ],
          "line": 1927
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "str",
            "\"FINDCREATEDISPLAY\""
          ],
          "line": 1927
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"cmd: %s\\n\"",
            "cmd"
          ],
          "line": 1926
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stdout",
            "\"%s\"",
            "create_display"
          ],
          "line": 1923
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "str",
            "\"FINDCREATEDISPLAY-print\""
          ],
          "line": 1922
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlink",
          "args": [
            "tmp"
          ],
          "line": 1919
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "system",
          "args": [
            "com"
          ],
          "line": 1914
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_env",
          "args": [
            "\"FD_XDM\"",
            "\"1\""
          ],
          "line": 1913
        },
        "resolved": true,
        "details": {
          "function_name": "set_env",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/util.c",
          "lines": "239-249",
          "snippet": "void set_env(char *name, char *value) {\n\tchar *str;\n\tif (! name) {\n\t\treturn;\n\t}\n\tif (! value) {\n\t\tvalue = \"\";\n\t}\n\n\tsetenv(name, value, 1);\n}",
          "includes": [
            "#include \"connections.h\"",
            "#include \"unixpw.h\"",
            "#include \"win_utils.h\"",
            "#include \"cleanup.h\"",
            "#include \"x11vnc.h\"",
            "#include <stdlib.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void lowercase(char *str);",
            "void uppercase(char *str);",
            "char *lblanks(char *str);",
            "void strzero(char *str);",
            "void set_env(char *name, char *value);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"connections.h\"\n#include \"unixpw.h\"\n#include \"win_utils.h\"\n#include \"cleanup.h\"\n#include \"x11vnc.h\"\n#include <stdlib.h>\n\nvoid lowercase(char *str);\nvoid uppercase(char *str);\nchar *lblanks(char *str);\nvoid strzero(char *str);\nvoid set_env(char *name, char *value);\n\nvoid set_env(char *name, char *value) {\n\tchar *str;\n\tif (! name) {\n\t\treturn;\n\t}\n\tif (! value) {\n\t\tvalue = \"\";\n\t}\n\n\tsetenv(name, value, 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "geteuid",
          "args": [],
          "line": 1912
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getuid",
          "args": [],
          "line": 1912
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getenv",
          "args": [
            "\"FD_XDM\""
          ],
          "line": 1911
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WEXITSTATUS",
          "args": [
            "ret"
          ],
          "line": 1910
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WIFEXITED",
          "args": [
            "ret"
          ],
          "line": 1910
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "system",
          "args": [
            "com"
          ],
          "line": 1909
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "com",
            "\"/bin/sh %s -n\"",
            "tmp"
          ],
          "line": 1908
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "close",
          "args": [
            "fd"
          ],
          "line": 1906
        },
        "resolved": true,
        "details": {
          "function_name": "close_alarm",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/unixpw.c",
          "lines": "666-672",
          "snippet": "static void close_alarm (int sig) {\n\tif (slave_fd >= 0) {\n\t\tclose(slave_fd);\n\t}\n\talarm_fired = 1;\n\tif (0) sig = 0;\t/* compiler warning */\n}",
          "includes": [
            "#include <sys/stropts.h>",
            "#include <termios.h>",
            "#include <sys/ioctl.h>",
            "#include <shadow.h>",
            "#include \"default8x16.h\"",
            "#include \"rates.h\"",
            "#include \"cursor.h\"",
            "#include \"sslhelper.h\"",
            "#include \"connections.h\"",
            "#include \"user.h\"",
            "#include \"connections.h\"",
            "#include \"xinerama.h\"",
            "#include \"cleanup.h\"",
            "#include \"scan.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int slave_fd = -1, alarm_fired = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/stropts.h>\n#include <termios.h>\n#include <sys/ioctl.h>\n#include <shadow.h>\n#include \"default8x16.h\"\n#include \"rates.h\"\n#include \"cursor.h\"\n#include \"sslhelper.h\"\n#include \"connections.h\"\n#include \"user.h\"\n#include \"connections.h\"\n#include \"xinerama.h\"\n#include \"cleanup.h\"\n#include \"scan.h\"\n#include \"x11vnc.h\"\n\nstatic int slave_fd = -1, alarm_fired = 0;\n\nstatic void close_alarm (int sig) {\n\tif (slave_fd >= 0) {\n\t\tclose(slave_fd);\n\t}\n\talarm_fired = 1;\n\tif (0) sig = 0;\t/* compiler warning */\n}"
        }
      },
      {
        "call_info": {
          "callee": "write",
          "args": [
            "fd",
            "find_display",
            "strlen(find_display)"
          ],
          "line": 1905
        },
        "resolved": true,
        "details": {
          "function_name": "write_exact",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/sslhelper.c",
          "lines": "1319-1344",
          "snippet": "static int write_exact(int sock, char *buf, int len) {\n\tint n, fail = 0;\n\tif (sock < 0) {\n\t\treturn 0;\n\t}\n\twhile (len > 0) {\n\t\tn = write(sock, buf, len);\n\t\tif (n > 0) {\n\t\t\tbuf += n;\n\t\t\tlen -= n;\n\t\t} else if (n == 0) {\n\t\t\tfail = 1;\n\t\t\tbreak;\n\t\t} else if (n < 0 && (errno == EAGAIN || errno == EWOULDBLOCK)) {\n\t\t\tusleep(10*1000);\n\t\t} else if (n < 0 && errno != EINTR) {\n\t\t\tfail = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (fail) {\n\t\treturn 0;\n\t} else {\n\t\treturn 1;\n\t}\n}",
          "includes": [
            "#include <openssl/rand.h>",
            "#include <openssl/err.h>",
            "#include <openssl/ssl.h>",
            "#include \"user.h\"",
            "#include \"unixpw.h\"",
            "#include \"sslcmds.h\"",
            "#include \"connections.h\"",
            "#include \"scan.h\"",
            "#include \"screen.h\"",
            "#include \"cleanup.h\"",
            "#include \"inet.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void ssl_helper_pid(pid_t pid, int sock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <openssl/rand.h>\n#include <openssl/err.h>\n#include <openssl/ssl.h>\n#include \"user.h\"\n#include \"unixpw.h\"\n#include \"sslcmds.h\"\n#include \"connections.h\"\n#include \"scan.h\"\n#include \"screen.h\"\n#include \"cleanup.h\"\n#include \"inet.h\"\n#include \"x11vnc.h\"\n\nvoid ssl_helper_pid(pid_t pid, int sock);\n\nstatic int write_exact(int sock, char *buf, int len) {\n\tint n, fail = 0;\n\tif (sock < 0) {\n\t\treturn 0;\n\t}\n\twhile (len > 0) {\n\t\tn = write(sock, buf, len);\n\t\tif (n > 0) {\n\t\t\tbuf += n;\n\t\t\tlen -= n;\n\t\t} else if (n == 0) {\n\t\t\tfail = 1;\n\t\t\tbreak;\n\t\t} else if (n < 0 && (errno == EAGAIN || errno == EWOULDBLOCK)) {\n\t\t\tusleep(10*1000);\n\t\t} else if (n < 0 && errno != EINTR) {\n\t\t\tfail = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (fail) {\n\t\treturn 0;\n\t} else {\n\t\treturn 1;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "find_display"
          ],
          "line": 1905
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mkstemp",
          "args": [
            "tmp"
          ],
          "line": 1902
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "cmd",
            "\"FINDDISPLAY-run\""
          ],
          "line": 1899
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stdout",
            "\"%s\"",
            "find_display"
          ],
          "line": 1896
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "cmd",
            "\"FINDDISPLAY-print\""
          ],
          "line": 1895
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "\"cmd=\""
          ],
          "line": 1894
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"wait_for_client external cmds not allowed:\"\n\t\t    \" %s\\n\"",
            "use_dpy"
          ],
          "line": 1889
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cmd_ok",
          "args": [
            "\"WAIT\""
          ],
          "line": 1888
        },
        "resolved": true,
        "details": {
          "function_name": "cmd_ok",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/connections.c",
          "lines": "436-460",
          "snippet": "int cmd_ok(char *cmd) {\n\tchar *p, *str;\n\tif (no_external_cmds) {\n\t\treturn 0;\n\t}\n\tif (! cmd || cmd[0] == '\\0') {\n\t\treturn 0;\n\t}\n\tif (! allowed_external_cmds) {\n\t\t/* default, allow any (overridden by -nocmds) */\n\t\treturn 1;\n\t}\n\n\tstr = strdup(allowed_external_cmds);\n\tp = strtok(str, \",\");\n\twhile (p) {\n\t\tif (!strcmp(p, cmd)) {\n\t\t\tfree(str);\n\t\t\treturn 1;\n\t\t}\n\t\tp = strtok(NULL, \",\");\n\t}\n\tfree(str);\n\treturn 0;\n}",
          "includes": [
            "#include \"xi2_devices.h\"",
            "#include \"xrandr.h\"",
            "#include \"pointer.h\"",
            "#include \"userinput.h\"",
            "#include \"macosxCG.h\"",
            "#include \"macosx.h\"",
            "#include \"win_utils.h\"",
            "#include \"xevents.h\"",
            "#include \"xwrappers.h\"",
            "#include \"sslhelper.h\"",
            "#include \"sslcmds.h\"",
            "#include \"scan.h\"",
            "#include \"user.h\"",
            "#include \"unixpw.h\"",
            "#include \"screen.h\"",
            "#include \"rates.h\"",
            "#include \"solid.h\"",
            "#include \"gui.h\"",
            "#include \"cleanup.h\"",
            "#include \"keyboard.h\"",
            "#include \"remote.h\"",
            "#include \"inet.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void close_clients(char *str);",
            "void set_client_input(char *str);",
            "int cmd_ok(char *cmd);",
            "void reverse_connect(char *str);",
            "void set_vnc_connect_prop(char *str);",
            "void set_x11vnc_remote_prop(char *str);",
            "void send_client_info(char *str);",
            "static rfbClientPtr *client_match(char *str);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xi2_devices.h\"\n#include \"xrandr.h\"\n#include \"pointer.h\"\n#include \"userinput.h\"\n#include \"macosxCG.h\"\n#include \"macosx.h\"\n#include \"win_utils.h\"\n#include \"xevents.h\"\n#include \"xwrappers.h\"\n#include \"sslhelper.h\"\n#include \"sslcmds.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"unixpw.h\"\n#include \"screen.h\"\n#include \"rates.h\"\n#include \"solid.h\"\n#include \"gui.h\"\n#include \"cleanup.h\"\n#include \"keyboard.h\"\n#include \"remote.h\"\n#include \"inet.h\"\n#include \"x11vnc.h\"\n\nvoid close_clients(char *str);\nvoid set_client_input(char *str);\nint cmd_ok(char *cmd);\nvoid reverse_connect(char *str);\nvoid set_vnc_connect_prop(char *str);\nvoid set_x11vnc_remote_prop(char *str);\nvoid send_client_info(char *str);\nstatic rfbClientPtr *client_match(char *str);\n\nint cmd_ok(char *cmd) {\n\tchar *p, *str;\n\tif (no_external_cmds) {\n\t\treturn 0;\n\t}\n\tif (! cmd || cmd[0] == '\\0') {\n\t\treturn 0;\n\t}\n\tif (! allowed_external_cmds) {\n\t\t/* default, allow any (overridden by -nocmds) */\n\t\treturn 1;\n\t}\n\n\tstr = strdup(allowed_external_cmds);\n\tp = strtok(str, \",\");\n\twhile (p) {\n\t\tif (!strcmp(p, cmd)) {\n\t\t\tfree(str);\n\t\t\treturn 1;\n\t\t}\n\t\tp = strtok(NULL, \",\");\n\t}\n\tfree(str);\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"avahi.h\"\n#include \"sslhelper.h\"\n#include \"remote.h\"\n#include \"cursor.h\"\n#include \"keyboard.h\"\n#include \"inet.h\"\n#include \"connections.h\"\n#include \"xwrappers.h\"\n#include \"sslhelper.h\"\n#include \"unixpw.h\"\n#include \"screen.h\"\n#include \"scan.h\"\n#include \"cleanup.h\"\n#include \"solid.h\"\n#include \"x11vnc.h\"\n\nvoid lurk_loop(char *str);\nextern char find_display[];\nextern char create_display[];\n\nchar *setup_cmd(char *str, int *vnc_redirect, char **vnc_redirect_host, int *vnc_redirect_port, int db) {\n\tchar *cmd = NULL;\n\t\n\tif (no_external_cmds || !cmd_ok(\"WAIT\")) {\n\t\trfbLog(\"wait_for_client external cmds not allowed:\"\n\t\t    \" %s\\n\", use_dpy);\n\t\tclean_up_exit(1);\n\t}\n\n\tcmd = str + strlen(\"cmd=\");\n\tif (!strcmp(cmd, \"FINDDISPLAY-print\")) {\n\t\tfprintf(stdout, \"%s\", find_display);\n\t\tclean_up_exit(0);\n\t}\n\tif (!strcmp(cmd, \"FINDDISPLAY-run\")) {\n\t\tchar tmp[] = \"/tmp/fd.XXXXXX\";\n\t\tchar com[100];\n\t\tint fd = mkstemp(tmp);\n\t\tif (fd >= 0) {\n\t\t\tint ret;\n\t\t\twrite(fd, find_display, strlen(find_display));\n\t\t\tclose(fd);\n\t\t\tset_env(\"FINDDISPLAY_run\", \"1\");\n\t\t\tsprintf(com, \"/bin/sh %s -n\", tmp);\n\t\t\tret = system(com);\n\t\t\tif (WIFEXITED(ret) && WEXITSTATUS(ret) != 0) {\n\t\t\t\tif (got_findauth && !getenv(\"FD_XDM\")) {\n\t\t\t\t\tif (getuid() == 0 || geteuid() == 0) {\n\t\t\t\t\t\tset_env(\"FD_XDM\", \"1\");\n\t\t\t\t\t\tsystem(com);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tunlink(tmp);\n\t\texit(0);\n\t}\n\tif (!strcmp(str, \"FINDCREATEDISPLAY-print\")) {\n\t\tfprintf(stdout, \"%s\", create_display);\n\t\tclean_up_exit(0);\n\t}\n\tif (db) fprintf(stderr, \"cmd: %s\\n\", cmd);\n\tif (strstr(str, \"FINDCREATEDISPLAY\") || strstr(str, \"FINDDISPLAY\")) {\n\t\tif (strstr(str, \"Xvnc.redirect\") || strstr(str, \"X.redirect\")) {\n\t\t\t*vnc_redirect = 1;\n\t\t}\n\t}\n\tif (strstr(cmd, \"FINDDISPLAY-vnc_redirect\") == cmd) {\n\t\tint p;\n\t\tchar h[256];\n\t\tif (strlen(cmd) >= 256) {\n\t\t\trfbLog(\"wait_for_client string too long: %s\\n\", str);\n\t\t\tclean_up_exit(1);\n\t\t}\n\t\th[0] = '\\0';\n\t\tif (sscanf(cmd, \"FINDDISPLAY-vnc_redirect=%d\", &p) == 1) {\n\t\t\t;\n\t\t} else if (sscanf(cmd, \"FINDDISPLAY-vnc_redirect=%s %d\", h, &p) == 2) {\n\t\t\t;\n\t\t} else {\n\t\t\trfbLog(\"wait_for_client bad string: %s\\n\", cmd);\n\t\t\tclean_up_exit(1);\n\t\t}\n\t\t*vnc_redirect_port = p;\n\t\tif (strcmp(h, \"\")) {\n\t\t\t*vnc_redirect_host = strdup(h);\n\t\t}\n\t\t*vnc_redirect = 2;\n\t\trfbLog(\"wait_for_client: vnc_redirect: %s:%d\\n\", *vnc_redirect_host, *vnc_redirect_port);\n\t}\n\treturn cmd;\n}"
  },
  {
    "function_name": "do_vnc_redirect",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/user.c",
    "lines": "1823-1880",
    "snippet": "static void do_vnc_redirect(int created_disp, char *vnc_redirect_host, int vnc_redirect_port,\n    int vnc_redirect_cnt, char *vnc_redirect_test) {\n\tchar *q = strrchr(use_dpy, ':');\n\tint vdpy = -1, sock = -1;\n\tint s_in, s_out, i;\n\tif (vnc_redirect == 2) {\n\t\tchar num[32];\t\n\t\tsprintf(num, \":%d\", vnc_redirect_port);\n\t\tq = num;\n\t}\n\tif (!q) {\n\t\trfbLog(\"wait_for_client: can't find number in X display: %s\\n\", use_dpy);\n\t\tclean_up_exit(1);\n\t}\n\tif (sscanf(q+1, \"%d\", &vdpy) != 1) {\n\t\trfbLog(\"wait_for_client: can't find number in X display: %s\\n\", q);\n\t\tclean_up_exit(1);\n\t}\n\tif (vdpy == -1 && vnc_redirect != 2) {\n\t\trfbLog(\"wait_for_client: can't find number in X display: %s\\n\", q);\n\t\tclean_up_exit(1);\n\t}\n\tif (vnc_redirect == 2) {\n\t\tif (vdpy < 0) {\n\t\t\tvdpy = -vdpy;\n\t\t} else if (vdpy < 200) {\n\t\t\tvdpy += 5900;\n\t\t}\n\t} else {\n\t\tvdpy += 5900;\n\t}\n\tif (created_disp) {\n\t\tusleep(1000*1000);\n\t}\n\tfor (i=0; i < 20; i++) {\n\t\tsock = connect_tcp(vnc_redirect_host, vdpy);\n\t\tif (sock >= 0) {\n\t\t\tbreak;\n\t\t}\n\t\trfbLog(\"wait_for_client: ...\\n\");\n\t\tusleep(500*1000);\n\t}\n\tif (sock < 0) {\n\t\trfbLog(\"wait_for_client: could not connect to a VNC Server at %s:%d\\n\", vnc_redirect_host, vdpy);\n\t\tclean_up_exit(1);\n\t}\n\tif (inetd) {\n\t\ts_in  = fileno(stdin);\n\t\ts_out = fileno(stdout);\n\t} else {\n\t\ts_in = s_out = vnc_redirect_sock;\n\t}\n\tif (vnc_redirect_cnt > 0) {\n\t\twrite(vnc_redirect_sock, vnc_redirect_test, vnc_redirect_cnt);\n\t}\n\trfbLog(\"wait_for_client: switching control to VNC Server at %s:%d\\n\", vnc_redirect_host, vdpy);\n\traw_xfer(sock, s_in, s_out);\n}",
    "includes": [
      "#include \"avahi.h\"",
      "#include \"sslhelper.h\"",
      "#include \"remote.h\"",
      "#include \"cursor.h\"",
      "#include \"keyboard.h\"",
      "#include \"inet.h\"",
      "#include \"connections.h\"",
      "#include \"xwrappers.h\"",
      "#include \"sslhelper.h\"",
      "#include \"unixpw.h\"",
      "#include \"screen.h\"",
      "#include \"scan.h\"",
      "#include \"cleanup.h\"",
      "#include \"solid.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "raw_xfer",
          "args": [
            "sock",
            "s_in",
            "s_out"
          ],
          "line": 1879
        },
        "resolved": true,
        "details": {
          "function_name": "raw_xfer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/sslhelper.c",
          "lines": "4286-4373",
          "snippet": "void raw_xfer(int csock, int s_in, int s_out) {\n\tchar buf0[8192];\n\tint sz = 8192, n, m, status, db = 1;\n\tchar *buf;\n#ifdef FORK_OK\n\tpid_t par = getpid();\n\tpid_t pid = fork();\n\n\tbuf = buf0;\n\tif (vnc_redirect) {\n\t\t/* change buf size some direction. */\n\t}\n\n\tif (getenv(\"X11VNC_DEBUG_RAW_XFER\")) {\n\t\tdb = atoi(getenv(\"X11VNC_DEBUG_RAW_XFER\"));\n\t}\n\tif (pid < 0) {\n\t\texit(1);\n\t}\n\t/* this is for testing or special helper usage, no SSL just socket redir */\n\tif (pid) {\n\t\tif (db) rfbLog(\"raw_xfer start: %d -> %d/%d\\n\", csock, s_in, s_out);\n\n\t\twhile (1) {\n\t\t\tn = read(csock, buf, sz);\n\t\t\tif (n == 0 || (n < 0 && errno != EINTR) ) {\n\t\t\t\tbreak;\n\t\t\t} else if (n > 0) {\n\t\t\t\tint len = n;\n\t\t\t\tchar *src = buf;\n\t\t\t\tif (db > 1) write(2, buf, n);\n\t\t\t\twhile (len > 0) {\n\t\t\t\t\tm = write(s_out, src, len);\n\t\t\t\t\tif (m > 0) {\n\t\t\t\t\t\tsrc += m;\n\t\t\t\t\t\tlen -= m;\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tif (m < 0 && (errno == EINTR || errno == EAGAIN)) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\nif (db) rfbLog(\"raw_xfer bad write:  %d -> %d | %d/%d  errno=%d\\n\", csock, s_out, m, n, errno);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tusleep(250*1000);\n\t\tkill(pid, SIGTERM);\n\t\twaitpid(pid, &status, WNOHANG); \n\t\tif (db) rfbLog(\"raw_xfer done:  %d -> %d\\n\", csock, s_out);\n\n\t} else {\n\t\tif (db) usleep(50*1000);\n\t\tif (db) rfbLog(\"raw_xfer start: %d <- %d\\n\", csock, s_in);\n\n\t\twhile (1) {\n\t\t\tn = read(s_in, buf, sz);\n\t\t\tif (n == 0 || (n < 0 && errno != EINTR) ) {\n\t\t\t\tbreak;\n\t\t\t} else if (n > 0) {\n\t\t\t\tint len = n;\n\t\t\t\tchar *src = buf;\n\t\t\t\tif (db > 1) write(2, buf, n);\n\t\t\t\twhile (len > 0) {\n\t\t\t\t\tm = write(csock, src, len);\n\t\t\t\t\tif (m > 0) {\n\t\t\t\t\t\tsrc += m;\n\t\t\t\t\t\tlen -= m;\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tif (m < 0 && (errno == EINTR || errno == EAGAIN)) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\tif (db) rfbLog(\"raw_xfer bad write:  %d <- %d | %d/%d errno=%d\\n\", csock, s_in, m, n, errno);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tusleep(250*1000);\n\t\tkill(par, SIGTERM);\n\t\twaitpid(par, &status, WNOHANG); \n\t\tif (db) rfbLog(\"raw_xfer done:  %d <- %d\\n\", csock, s_in);\n\t}\n\tclose(csock);\n\tclose(s_in);\n\tclose(s_out);\n#endif\t/* FORK_OK */\n}",
          "includes": [
            "#include <openssl/rand.h>",
            "#include <openssl/err.h>",
            "#include <openssl/ssl.h>",
            "#include \"user.h\"",
            "#include \"unixpw.h\"",
            "#include \"sslcmds.h\"",
            "#include \"connections.h\"",
            "#include \"scan.h\"",
            "#include \"screen.h\"",
            "#include \"cleanup.h\"",
            "#include \"inet.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [
            "#define FORK_OK"
          ],
          "globals_used": [
            "void raw_xfer(int csock, int s_in, int s_out);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <openssl/rand.h>\n#include <openssl/err.h>\n#include <openssl/ssl.h>\n#include \"user.h\"\n#include \"unixpw.h\"\n#include \"sslcmds.h\"\n#include \"connections.h\"\n#include \"scan.h\"\n#include \"screen.h\"\n#include \"cleanup.h\"\n#include \"inet.h\"\n#include \"x11vnc.h\"\n\n#define FORK_OK\n\nvoid raw_xfer(int csock, int s_in, int s_out);\n\nvoid raw_xfer(int csock, int s_in, int s_out) {\n\tchar buf0[8192];\n\tint sz = 8192, n, m, status, db = 1;\n\tchar *buf;\n#ifdef FORK_OK\n\tpid_t par = getpid();\n\tpid_t pid = fork();\n\n\tbuf = buf0;\n\tif (vnc_redirect) {\n\t\t/* change buf size some direction. */\n\t}\n\n\tif (getenv(\"X11VNC_DEBUG_RAW_XFER\")) {\n\t\tdb = atoi(getenv(\"X11VNC_DEBUG_RAW_XFER\"));\n\t}\n\tif (pid < 0) {\n\t\texit(1);\n\t}\n\t/* this is for testing or special helper usage, no SSL just socket redir */\n\tif (pid) {\n\t\tif (db) rfbLog(\"raw_xfer start: %d -> %d/%d\\n\", csock, s_in, s_out);\n\n\t\twhile (1) {\n\t\t\tn = read(csock, buf, sz);\n\t\t\tif (n == 0 || (n < 0 && errno != EINTR) ) {\n\t\t\t\tbreak;\n\t\t\t} else if (n > 0) {\n\t\t\t\tint len = n;\n\t\t\t\tchar *src = buf;\n\t\t\t\tif (db > 1) write(2, buf, n);\n\t\t\t\twhile (len > 0) {\n\t\t\t\t\tm = write(s_out, src, len);\n\t\t\t\t\tif (m > 0) {\n\t\t\t\t\t\tsrc += m;\n\t\t\t\t\t\tlen -= m;\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tif (m < 0 && (errno == EINTR || errno == EAGAIN)) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\nif (db) rfbLog(\"raw_xfer bad write:  %d -> %d | %d/%d  errno=%d\\n\", csock, s_out, m, n, errno);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tusleep(250*1000);\n\t\tkill(pid, SIGTERM);\n\t\twaitpid(pid, &status, WNOHANG); \n\t\tif (db) rfbLog(\"raw_xfer done:  %d -> %d\\n\", csock, s_out);\n\n\t} else {\n\t\tif (db) usleep(50*1000);\n\t\tif (db) rfbLog(\"raw_xfer start: %d <- %d\\n\", csock, s_in);\n\n\t\twhile (1) {\n\t\t\tn = read(s_in, buf, sz);\n\t\t\tif (n == 0 || (n < 0 && errno != EINTR) ) {\n\t\t\t\tbreak;\n\t\t\t} else if (n > 0) {\n\t\t\t\tint len = n;\n\t\t\t\tchar *src = buf;\n\t\t\t\tif (db > 1) write(2, buf, n);\n\t\t\t\twhile (len > 0) {\n\t\t\t\t\tm = write(csock, src, len);\n\t\t\t\t\tif (m > 0) {\n\t\t\t\t\t\tsrc += m;\n\t\t\t\t\t\tlen -= m;\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tif (m < 0 && (errno == EINTR || errno == EAGAIN)) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\tif (db) rfbLog(\"raw_xfer bad write:  %d <- %d | %d/%d errno=%d\\n\", csock, s_in, m, n, errno);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tusleep(250*1000);\n\t\tkill(par, SIGTERM);\n\t\twaitpid(par, &status, WNOHANG); \n\t\tif (db) rfbLog(\"raw_xfer done:  %d <- %d\\n\", csock, s_in);\n\t}\n\tclose(csock);\n\tclose(s_in);\n\tclose(s_out);\n#endif\t/* FORK_OK */\n}"
        }
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"wait_for_client: switching control to VNC Server at %s:%d\\n\"",
            "vnc_redirect_host",
            "vdpy"
          ],
          "line": 1878
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "write",
          "args": [
            "vnc_redirect_sock",
            "vnc_redirect_test",
            "vnc_redirect_cnt"
          ],
          "line": 1876
        },
        "resolved": true,
        "details": {
          "function_name": "write_exact",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/sslhelper.c",
          "lines": "1319-1344",
          "snippet": "static int write_exact(int sock, char *buf, int len) {\n\tint n, fail = 0;\n\tif (sock < 0) {\n\t\treturn 0;\n\t}\n\twhile (len > 0) {\n\t\tn = write(sock, buf, len);\n\t\tif (n > 0) {\n\t\t\tbuf += n;\n\t\t\tlen -= n;\n\t\t} else if (n == 0) {\n\t\t\tfail = 1;\n\t\t\tbreak;\n\t\t} else if (n < 0 && (errno == EAGAIN || errno == EWOULDBLOCK)) {\n\t\t\tusleep(10*1000);\n\t\t} else if (n < 0 && errno != EINTR) {\n\t\t\tfail = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (fail) {\n\t\treturn 0;\n\t} else {\n\t\treturn 1;\n\t}\n}",
          "includes": [
            "#include <openssl/rand.h>",
            "#include <openssl/err.h>",
            "#include <openssl/ssl.h>",
            "#include \"user.h\"",
            "#include \"unixpw.h\"",
            "#include \"sslcmds.h\"",
            "#include \"connections.h\"",
            "#include \"scan.h\"",
            "#include \"screen.h\"",
            "#include \"cleanup.h\"",
            "#include \"inet.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void ssl_helper_pid(pid_t pid, int sock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <openssl/rand.h>\n#include <openssl/err.h>\n#include <openssl/ssl.h>\n#include \"user.h\"\n#include \"unixpw.h\"\n#include \"sslcmds.h\"\n#include \"connections.h\"\n#include \"scan.h\"\n#include \"screen.h\"\n#include \"cleanup.h\"\n#include \"inet.h\"\n#include \"x11vnc.h\"\n\nvoid ssl_helper_pid(pid_t pid, int sock);\n\nstatic int write_exact(int sock, char *buf, int len) {\n\tint n, fail = 0;\n\tif (sock < 0) {\n\t\treturn 0;\n\t}\n\twhile (len > 0) {\n\t\tn = write(sock, buf, len);\n\t\tif (n > 0) {\n\t\t\tbuf += n;\n\t\t\tlen -= n;\n\t\t} else if (n == 0) {\n\t\t\tfail = 1;\n\t\t\tbreak;\n\t\t} else if (n < 0 && (errno == EAGAIN || errno == EWOULDBLOCK)) {\n\t\t\tusleep(10*1000);\n\t\t} else if (n < 0 && errno != EINTR) {\n\t\t\tfail = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (fail) {\n\t\treturn 0;\n\t} else {\n\t\treturn 1;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "fileno",
          "args": [
            "stdout"
          ],
          "line": 1871
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fileno",
          "args": [
            "stdin"
          ],
          "line": 1870
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clean_up_exit",
          "args": [
            "1"
          ],
          "line": 1867
        },
        "resolved": true,
        "details": {
          "function_name": "clean_up_exit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/cleanup.c",
          "lines": "151-266",
          "snippet": "void clean_up_exit(int ret) {\n\tstatic int depth = 0;\n\texit_flag = 1;\n\n\tif (depth++ > 2) {\n\t\texit(ret);\n\t}\n\n\tif (icon_mode) {\n\t\tclean_icon_mode();\n\t}\n\n\t/* remove the shm areas: */\n\tclean_shm(0);\n\n\tstop_stunnel();\n\tif (use_openssl) {\n\t\tssl_helper_pid(0, 0);\t/* killall */\n\t}\n\n\tif (ssh_pid > 0) {\n\t\tkill(ssh_pid, SIGTERM);\n\t\tssh_pid = 0;\n\t}\n\n#ifdef MACOSX\n\tif (client_connect_file) {\n\t\tif (strstr(client_connect_file, \"/tmp/x11vnc-macosx-remote\")\n\t\t    == client_connect_file) {\n\t\t\tunlink(client_connect_file);\n\t\t}\n\t}\n\tif (macosx_console) {\n\t\tmacosxCG_fini();\n\t}\n#endif\n\n\tif (pipeinput_fh != NULL) {\n\t\tpclose(pipeinput_fh);\n\t\tpipeinput_fh = NULL;\n\t}\n\n\tshutdown_uinput();\n\n\tif (unix_sock) {\n\t\tif (unix_sock_fd >= 0) {\n\t\t\trfbLog(\"deleting unix sock: %s\\n\", unix_sock);\n\t\t\tclose(unix_sock_fd);\n\t\t\tunix_sock_fd = -1;\n\t\t\tunlink(unix_sock);\n\t\t}\n\t}\n\n\tif (! dpy) {\t/* raw_rb hack */\n\t\tif (rm_flagfile) {\n\t\t\tunlink(rm_flagfile);\n\t\t\trm_flagfile = NULL;\n\t\t}\n\t\texit(ret);\n\t}\n\n\t/* X keyboard cleanups */\n\tdelete_added_keycodes(0);\n\n\t/* remove all created XInput2 devices */\n\tif(use_multipointer)\n\t    removeAllMDs(dpy);\n\n\tif (clear_mods == 1) {\n\t\tclear_modifiers(0);\n\t} else if (clear_mods == 2) {\n\t\tclear_keys();\n\t} else if (clear_mods == 3) {\n\t\tclear_keys();\n\t\tclear_locks();\n\t}\n\n\tif (no_autorepeat) {\n\t\tautorepeat(1, 0);\n\t}\n\tif (use_solid_bg) {\n\t\tsolid_bg(1);\n\t}\n\tif (ncache || ncache0) {\n\t\tkde_no_animate(1);\n\t}\n\tX_LOCK;\n\tXTestDiscard_wr(dpy);\n#if HAVE_LIBXDAMAGE\n\tif (xdamage) {\n\t\tXDamageDestroy(dpy, xdamage);\n\t}\n#endif\n#if HAVE_LIBXTRAP\n\tif (trap_ctx) {\n\t\tXEFreeTC(trap_ctx);\n\t}\n#endif\n\t/* XXX rdpy_ctrl, etc. cannot close w/o blocking */\n\tXCloseDisplay_wr(dpy);\n\tX_UNLOCK;\n\n\tfflush(stderr);\n\n\tif (rm_flagfile) {\n\t\tunlink(rm_flagfile);\n\t\trm_flagfile = NULL;\n\t}\n\n\tif (avahi) {\n\t\tavahi_cleanup();\n\t\tfflush(stderr);\n\t}\n\n\texit(ret);\n}",
          "includes": [
            "#include \"xi2_devices.h\"",
            "#include \"uinput.h\"",
            "#include \"xevents.h\"",
            "#include \"xrecord.h\"",
            "#include \"screen.h\"",
            "#include \"avahi.h\"",
            "#include \"macosxCG.h\"",
            "#include \"macosx.h\"",
            "#include \"connections.h\"",
            "#include \"sslhelper.h\"",
            "#include \"sslcmds.h\"",
            "#include \"unixpw.h\"",
            "#include \"solid.h\"",
            "#include \"gui.h\"",
            "#include \"scan.h\"",
            "#include \"keyboard.h\"",
            "#include \"remote.h\"",
            "#include \"xdamage.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void clean_up_exit(int ret);",
            "int known_sigpipe_mode(char *s);",
            "static int exit_flag = 0;",
            "static void clean_icon_mode(void);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xi2_devices.h\"\n#include \"uinput.h\"\n#include \"xevents.h\"\n#include \"xrecord.h\"\n#include \"screen.h\"\n#include \"avahi.h\"\n#include \"macosxCG.h\"\n#include \"macosx.h\"\n#include \"connections.h\"\n#include \"sslhelper.h\"\n#include \"sslcmds.h\"\n#include \"unixpw.h\"\n#include \"solid.h\"\n#include \"gui.h\"\n#include \"scan.h\"\n#include \"keyboard.h\"\n#include \"remote.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nvoid clean_up_exit(int ret);\nint known_sigpipe_mode(char *s);\nstatic int exit_flag = 0;\nstatic void clean_icon_mode(void);\n\nvoid clean_up_exit(int ret) {\n\tstatic int depth = 0;\n\texit_flag = 1;\n\n\tif (depth++ > 2) {\n\t\texit(ret);\n\t}\n\n\tif (icon_mode) {\n\t\tclean_icon_mode();\n\t}\n\n\t/* remove the shm areas: */\n\tclean_shm(0);\n\n\tstop_stunnel();\n\tif (use_openssl) {\n\t\tssl_helper_pid(0, 0);\t/* killall */\n\t}\n\n\tif (ssh_pid > 0) {\n\t\tkill(ssh_pid, SIGTERM);\n\t\tssh_pid = 0;\n\t}\n\n#ifdef MACOSX\n\tif (client_connect_file) {\n\t\tif (strstr(client_connect_file, \"/tmp/x11vnc-macosx-remote\")\n\t\t    == client_connect_file) {\n\t\t\tunlink(client_connect_file);\n\t\t}\n\t}\n\tif (macosx_console) {\n\t\tmacosxCG_fini();\n\t}\n#endif\n\n\tif (pipeinput_fh != NULL) {\n\t\tpclose(pipeinput_fh);\n\t\tpipeinput_fh = NULL;\n\t}\n\n\tshutdown_uinput();\n\n\tif (unix_sock) {\n\t\tif (unix_sock_fd >= 0) {\n\t\t\trfbLog(\"deleting unix sock: %s\\n\", unix_sock);\n\t\t\tclose(unix_sock_fd);\n\t\t\tunix_sock_fd = -1;\n\t\t\tunlink(unix_sock);\n\t\t}\n\t}\n\n\tif (! dpy) {\t/* raw_rb hack */\n\t\tif (rm_flagfile) {\n\t\t\tunlink(rm_flagfile);\n\t\t\trm_flagfile = NULL;\n\t\t}\n\t\texit(ret);\n\t}\n\n\t/* X keyboard cleanups */\n\tdelete_added_keycodes(0);\n\n\t/* remove all created XInput2 devices */\n\tif(use_multipointer)\n\t    removeAllMDs(dpy);\n\n\tif (clear_mods == 1) {\n\t\tclear_modifiers(0);\n\t} else if (clear_mods == 2) {\n\t\tclear_keys();\n\t} else if (clear_mods == 3) {\n\t\tclear_keys();\n\t\tclear_locks();\n\t}\n\n\tif (no_autorepeat) {\n\t\tautorepeat(1, 0);\n\t}\n\tif (use_solid_bg) {\n\t\tsolid_bg(1);\n\t}\n\tif (ncache || ncache0) {\n\t\tkde_no_animate(1);\n\t}\n\tX_LOCK;\n\tXTestDiscard_wr(dpy);\n#if HAVE_LIBXDAMAGE\n\tif (xdamage) {\n\t\tXDamageDestroy(dpy, xdamage);\n\t}\n#endif\n#if HAVE_LIBXTRAP\n\tif (trap_ctx) {\n\t\tXEFreeTC(trap_ctx);\n\t}\n#endif\n\t/* XXX rdpy_ctrl, etc. cannot close w/o blocking */\n\tXCloseDisplay_wr(dpy);\n\tX_UNLOCK;\n\n\tfflush(stderr);\n\n\tif (rm_flagfile) {\n\t\tunlink(rm_flagfile);\n\t\trm_flagfile = NULL;\n\t}\n\n\tif (avahi) {\n\t\tavahi_cleanup();\n\t\tfflush(stderr);\n\t}\n\n\texit(ret);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"wait_for_client: could not connect to a VNC Server at %s:%d\\n\"",
            "vnc_redirect_host",
            "vdpy"
          ],
          "line": 1866
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "usleep",
          "args": [
            "500*1000"
          ],
          "line": 1863
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"wait_for_client: ...\\n\""
          ],
          "line": 1862
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "connect_tcp",
          "args": [
            "vnc_redirect_host",
            "vdpy"
          ],
          "line": 1858
        },
        "resolved": true,
        "details": {
          "function_name": "connect_tcp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/inet.c",
          "lines": "716-893",
          "snippet": "int connect_tcp(char *host, int port) {\n\tdouble t0 = dnow();\n\tint fd = -1;\n\tint fail4 = noipv4;\n\tif (getenv(\"IPV4_FAILS\")) {\n\t\tfail4 = 2;\n\t}\n\n\trfbLog(\"connect_tcp: trying:   %s %d\\n\", host, port);\n\n\tif (fail4) {\n\t\tif (fail4 > 1) {\n\t\t\trfbLog(\"TESTING: IPV4_FAILS for connect_tcp.\\n\");\n\t\t}\n\t} else {\n\t\tfd = rfbConnectToTcpAddr(host, port);\n\t}\n\n\tif (fd >= 0) {\n\t\treturn fd;\n\t}\n\trfbLogPerror(\"connect_tcp: connection failed\");\n\n\tif (dnow() - t0 < 4.0) {\n\t\trfbLog(\"connect_tcp: re-trying %s %d\\n\", host, port);\n\t\tusleep (100 * 1000);\n\t\tif (!fail4) {\n\t\t\tfd = rfbConnectToTcpAddr(host, port);\n\t\t}\n\t\tif (fd < 0) {\n\t\t\trfbLogPerror(\"connect_tcp: connection failed\");\n\t\t}\n\t}\n\n\tif (fd < 0 && !noipv6) {\n#if X11VNC_IPV6\n\t\tint err;\n\t\tstruct addrinfo *ai;\n\t\tstruct addrinfo hints;\n\t\tchar service[32], *host2, *q;\n\n\t\trfbLog(\"connect_tcp: trying IPv6 %s %d\\n\", host, port);\n\n\t\tmemset(&hints, 0, sizeof(hints));\n\t\tsprintf(service, \"%d\", port);\n\n\t\thints.ai_family = AF_UNSPEC;\n\t\thints.ai_socktype = SOCK_STREAM;\n#ifdef AI_ADDRCONFIG\n\t\thints.ai_flags |= AI_ADDRCONFIG;\n#endif\n\t\tif(ipv6_ip(host)) {\n#ifdef AI_NUMERICHOST\n\t\t\trfbLog(\"connect_tcp[ipv6]: setting AI_NUMERICHOST for %s\\n\", host);\n\t\t\thints.ai_flags |= AI_NUMERICHOST;\n#endif\n\t\t}\n#ifdef AI_NUMERICSERV\n\t\thints.ai_flags |= AI_NUMERICSERV;\n#endif\n\n\t\tif (!strcmp(host, \"127.0.0.1\")) {\n\t\t\thost2 = strdup(\"::1\");\n\t\t} else if (host[0] == '[') {\n\t\t\thost2 = strdup(host+1);\n\t\t} else {\n\t\t\thost2 = strdup(host);\n\t\t}\n\t\tq = strrchr(host2, ']');\n\t\tif (q) {\n\t\t\t*q = '\\0';\n\t\t}\n\n\t\terr = getaddrinfo(host2, service, &hints, &ai);\n\t\tif (err != 0) {\n\t\t\trfbLog(\"connect_tcp[ipv6]: getaddrinfo[%d]: %s\\n\", err, gai_strerror(err));\n\t\t\tusleep(100 * 1000);\n\t\t\terr = getaddrinfo(host2, service, &hints, &ai);\n\t\t}\n\t\tfree(host2);\n\n\t\tif (err != 0) {\n\t\t\trfbLog(\"connect_tcp[ipv6]: getaddrinfo[%d]: %s\\n\", err, gai_strerror(err));\n\t\t} else {\n\t\t\tstruct addrinfo *ap = ai;\n\t\t\twhile (ap != NULL) {\n\t\t\t\tint sock;\n\n\t\t\t\tif (fail4) {\n\t\t\t\t\tstruct sockaddr_in6 *s6ptr;\n\t\t\t\t\tif (ap->ai_family != AF_INET6) {\n\t\t\t\t\t\trfbLog(\"connect_tcp[ipv6]: skipping AF_INET address under -noipv4\\n\");\n\t\t\t\t\t\tap = ap->ai_next;\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n#ifdef IN6_IS_ADDR_V4MAPPED\n\t\t\t\t\ts6ptr = (struct sockaddr_in6 *) ap->ai_addr;\n\t\t\t\t\tif (IN6_IS_ADDR_V4MAPPED(&(s6ptr->sin6_addr))) {\n\t\t\t\t\t\trfbLog(\"connect_tcp[ipv6]: skipping V4MAPPED address under -noipv4\\n\");\n\t\t\t\t\t\tap = ap->ai_next;\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n#endif\n\t\t\t\t}\n\n\t\t\t\tsock = socket(ap->ai_family, ap->ai_socktype, ap->ai_protocol);\n\n\t\t\t\tif (sock == -1) {\n\t\t\t\t\trfbLogPerror(\"connect_tcp[ipv6]: socket\");\n\t\t\t\t\tif (0) rfbLog(\"(Ignore the above error if this system is IPv4-only.)\\n\");\n\t\t\t\t} else {\n\t\t\t\t\tint res = -1, dmsg = 0;\n\t\t\t\t\tchar *s = ipv6_getipaddr(ap->ai_addr, ap->ai_addrlen);\n\t\t\t\t\tif (!s) s = strdup(\"unknown\");\n\n\t\t\t\t\trfbLog(\"connect_tcp[ipv6]: trying sock=%d fam=%d proto=%d using %s\\n\",\n\t\t\t\t\t    sock, ap->ai_family, ap->ai_protocol, s);\n\t\t\t\t\tres = connect(sock, ap->ai_addr, ap->ai_addrlen);\n#if defined(SOL_IPV6) && defined(IPV6_V6ONLY)\n\t\t\t\t\tif (res != 0) {\n\t\t\t\t\t\tint zero = 0;\n\t\t\t\t\t\trfbLogPerror(\"connect_tcp[ipv6]: connect\");\n\t\t\t\t\t\tdmsg = 1;\n\t\t\t\t\t\tif (setsockopt(sock, SOL_IPV6, IPV6_V6ONLY, (char *)&zero, sizeof(zero)) == 0) {\n\t\t\t\t\t\t\trfbLog(\"connect_tcp[ipv6]: trying again with IPV6_V6ONLY=0\\n\");\n\t\t\t\t\t\t\tres = connect(sock, ap->ai_addr, ap->ai_addrlen);\n\t\t\t\t\t\t\tdmsg = 0;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\trfbLogPerror(\"connect_tcp[ipv6]: setsockopt IPV6_V6ONLY\");\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n#endif\n\t\t\t\t\tif (res == 0) {\n\t\t\t\t\t\trfbLog(\"connect_tcp[ipv6]: connect OK\\n\");\n\t\t\t\t\t\tfd = sock;\n\t\t\t\t\t\tif (!ipv6_client_ip_str) {\n\t\t\t\t\t\t\tipv6_client_ip_str = strdup(s);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tfree(s);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif (!dmsg) rfbLogPerror(\"connect_tcp[ipv6]: connect\");\n\t\t\t\t\t\tclose(sock);\n\t\t\t\t\t}\n\t\t\t\t\tfree(s);\n\t\t\t\t}\n\t\t\t\tap = ap->ai_next;\n\t\t\t}\n\t\t\tfreeaddrinfo(ai);\n\t\t}\n#endif\n\t}\n\tif (fd < 0 && !fail4) {\n\t\t/* this is a kludge for IPv4-only machines getting v4mapped string. */\n\t\tchar *q, *host2;\n\t\tif (host[0] == '[') {\n\t\t\thost2 = strdup(host+1);\n\t\t} else {\n\t\t\thost2 = strdup(host);\n\t\t}\n\t\tq = strrchr(host2, ']');\n\t\tif (q) {\n\t\t\t*q = '\\0';\n\t\t}\n\t\tif (strstr(host2, \"::ffff:\") == host2 || strstr(host2, \"::FFFF:\") == host2) {\n\t\t\tchar *host3 = host2 + strlen(\"::ffff:\");\n\t\t\tif (dotted_ip(host3, 0)) {\n\t\t\t\trfbLog(\"connect_tcp[ipv4]: trying fallback to IPv4 for %s\\n\", host2);\n\t\t\t\tfd = rfbConnectToTcpAddr(host3, port);\n\t\t\t\tif (fd < 0) {\n\t\t\t\t\trfbLogPerror(\"connect_tcp[ipv4]: connection failed\");\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfree(host2);\n\t}\n\treturn fd;\n}",
          "includes": [
            "#include <sys/un.h>",
            "#include \"sslhelper.h\"",
            "#include \"unixpw.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "char *host2ip(char *host);",
            "int ipv6_ip(char *host);",
            "int get_remote_port(int sock);",
            "int get_local_port(int sock);",
            "char *get_remote_host(int sock);",
            "char *get_local_host(int sock);",
            "int listen6(int port);",
            "int accept_unix(int s);",
            "int connect_tcp(char *host, int port);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/un.h>\n#include \"sslhelper.h\"\n#include \"unixpw.h\"\n#include \"x11vnc.h\"\n\nchar *host2ip(char *host);\nint ipv6_ip(char *host);\nint get_remote_port(int sock);\nint get_local_port(int sock);\nchar *get_remote_host(int sock);\nchar *get_local_host(int sock);\nint listen6(int port);\nint accept_unix(int s);\nint connect_tcp(char *host, int port);\n\nint connect_tcp(char *host, int port) {\n\tdouble t0 = dnow();\n\tint fd = -1;\n\tint fail4 = noipv4;\n\tif (getenv(\"IPV4_FAILS\")) {\n\t\tfail4 = 2;\n\t}\n\n\trfbLog(\"connect_tcp: trying:   %s %d\\n\", host, port);\n\n\tif (fail4) {\n\t\tif (fail4 > 1) {\n\t\t\trfbLog(\"TESTING: IPV4_FAILS for connect_tcp.\\n\");\n\t\t}\n\t} else {\n\t\tfd = rfbConnectToTcpAddr(host, port);\n\t}\n\n\tif (fd >= 0) {\n\t\treturn fd;\n\t}\n\trfbLogPerror(\"connect_tcp: connection failed\");\n\n\tif (dnow() - t0 < 4.0) {\n\t\trfbLog(\"connect_tcp: re-trying %s %d\\n\", host, port);\n\t\tusleep (100 * 1000);\n\t\tif (!fail4) {\n\t\t\tfd = rfbConnectToTcpAddr(host, port);\n\t\t}\n\t\tif (fd < 0) {\n\t\t\trfbLogPerror(\"connect_tcp: connection failed\");\n\t\t}\n\t}\n\n\tif (fd < 0 && !noipv6) {\n#if X11VNC_IPV6\n\t\tint err;\n\t\tstruct addrinfo *ai;\n\t\tstruct addrinfo hints;\n\t\tchar service[32], *host2, *q;\n\n\t\trfbLog(\"connect_tcp: trying IPv6 %s %d\\n\", host, port);\n\n\t\tmemset(&hints, 0, sizeof(hints));\n\t\tsprintf(service, \"%d\", port);\n\n\t\thints.ai_family = AF_UNSPEC;\n\t\thints.ai_socktype = SOCK_STREAM;\n#ifdef AI_ADDRCONFIG\n\t\thints.ai_flags |= AI_ADDRCONFIG;\n#endif\n\t\tif(ipv6_ip(host)) {\n#ifdef AI_NUMERICHOST\n\t\t\trfbLog(\"connect_tcp[ipv6]: setting AI_NUMERICHOST for %s\\n\", host);\n\t\t\thints.ai_flags |= AI_NUMERICHOST;\n#endif\n\t\t}\n#ifdef AI_NUMERICSERV\n\t\thints.ai_flags |= AI_NUMERICSERV;\n#endif\n\n\t\tif (!strcmp(host, \"127.0.0.1\")) {\n\t\t\thost2 = strdup(\"::1\");\n\t\t} else if (host[0] == '[') {\n\t\t\thost2 = strdup(host+1);\n\t\t} else {\n\t\t\thost2 = strdup(host);\n\t\t}\n\t\tq = strrchr(host2, ']');\n\t\tif (q) {\n\t\t\t*q = '\\0';\n\t\t}\n\n\t\terr = getaddrinfo(host2, service, &hints, &ai);\n\t\tif (err != 0) {\n\t\t\trfbLog(\"connect_tcp[ipv6]: getaddrinfo[%d]: %s\\n\", err, gai_strerror(err));\n\t\t\tusleep(100 * 1000);\n\t\t\terr = getaddrinfo(host2, service, &hints, &ai);\n\t\t}\n\t\tfree(host2);\n\n\t\tif (err != 0) {\n\t\t\trfbLog(\"connect_tcp[ipv6]: getaddrinfo[%d]: %s\\n\", err, gai_strerror(err));\n\t\t} else {\n\t\t\tstruct addrinfo *ap = ai;\n\t\t\twhile (ap != NULL) {\n\t\t\t\tint sock;\n\n\t\t\t\tif (fail4) {\n\t\t\t\t\tstruct sockaddr_in6 *s6ptr;\n\t\t\t\t\tif (ap->ai_family != AF_INET6) {\n\t\t\t\t\t\trfbLog(\"connect_tcp[ipv6]: skipping AF_INET address under -noipv4\\n\");\n\t\t\t\t\t\tap = ap->ai_next;\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n#ifdef IN6_IS_ADDR_V4MAPPED\n\t\t\t\t\ts6ptr = (struct sockaddr_in6 *) ap->ai_addr;\n\t\t\t\t\tif (IN6_IS_ADDR_V4MAPPED(&(s6ptr->sin6_addr))) {\n\t\t\t\t\t\trfbLog(\"connect_tcp[ipv6]: skipping V4MAPPED address under -noipv4\\n\");\n\t\t\t\t\t\tap = ap->ai_next;\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n#endif\n\t\t\t\t}\n\n\t\t\t\tsock = socket(ap->ai_family, ap->ai_socktype, ap->ai_protocol);\n\n\t\t\t\tif (sock == -1) {\n\t\t\t\t\trfbLogPerror(\"connect_tcp[ipv6]: socket\");\n\t\t\t\t\tif (0) rfbLog(\"(Ignore the above error if this system is IPv4-only.)\\n\");\n\t\t\t\t} else {\n\t\t\t\t\tint res = -1, dmsg = 0;\n\t\t\t\t\tchar *s = ipv6_getipaddr(ap->ai_addr, ap->ai_addrlen);\n\t\t\t\t\tif (!s) s = strdup(\"unknown\");\n\n\t\t\t\t\trfbLog(\"connect_tcp[ipv6]: trying sock=%d fam=%d proto=%d using %s\\n\",\n\t\t\t\t\t    sock, ap->ai_family, ap->ai_protocol, s);\n\t\t\t\t\tres = connect(sock, ap->ai_addr, ap->ai_addrlen);\n#if defined(SOL_IPV6) && defined(IPV6_V6ONLY)\n\t\t\t\t\tif (res != 0) {\n\t\t\t\t\t\tint zero = 0;\n\t\t\t\t\t\trfbLogPerror(\"connect_tcp[ipv6]: connect\");\n\t\t\t\t\t\tdmsg = 1;\n\t\t\t\t\t\tif (setsockopt(sock, SOL_IPV6, IPV6_V6ONLY, (char *)&zero, sizeof(zero)) == 0) {\n\t\t\t\t\t\t\trfbLog(\"connect_tcp[ipv6]: trying again with IPV6_V6ONLY=0\\n\");\n\t\t\t\t\t\t\tres = connect(sock, ap->ai_addr, ap->ai_addrlen);\n\t\t\t\t\t\t\tdmsg = 0;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\trfbLogPerror(\"connect_tcp[ipv6]: setsockopt IPV6_V6ONLY\");\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n#endif\n\t\t\t\t\tif (res == 0) {\n\t\t\t\t\t\trfbLog(\"connect_tcp[ipv6]: connect OK\\n\");\n\t\t\t\t\t\tfd = sock;\n\t\t\t\t\t\tif (!ipv6_client_ip_str) {\n\t\t\t\t\t\t\tipv6_client_ip_str = strdup(s);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tfree(s);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif (!dmsg) rfbLogPerror(\"connect_tcp[ipv6]: connect\");\n\t\t\t\t\t\tclose(sock);\n\t\t\t\t\t}\n\t\t\t\t\tfree(s);\n\t\t\t\t}\n\t\t\t\tap = ap->ai_next;\n\t\t\t}\n\t\t\tfreeaddrinfo(ai);\n\t\t}\n#endif\n\t}\n\tif (fd < 0 && !fail4) {\n\t\t/* this is a kludge for IPv4-only machines getting v4mapped string. */\n\t\tchar *q, *host2;\n\t\tif (host[0] == '[') {\n\t\t\thost2 = strdup(host+1);\n\t\t} else {\n\t\t\thost2 = strdup(host);\n\t\t}\n\t\tq = strrchr(host2, ']');\n\t\tif (q) {\n\t\t\t*q = '\\0';\n\t\t}\n\t\tif (strstr(host2, \"::ffff:\") == host2 || strstr(host2, \"::FFFF:\") == host2) {\n\t\t\tchar *host3 = host2 + strlen(\"::ffff:\");\n\t\t\tif (dotted_ip(host3, 0)) {\n\t\t\t\trfbLog(\"connect_tcp[ipv4]: trying fallback to IPv4 for %s\\n\", host2);\n\t\t\t\tfd = rfbConnectToTcpAddr(host3, port);\n\t\t\t\tif (fd < 0) {\n\t\t\t\t\trfbLogPerror(\"connect_tcp[ipv4]: connection failed\");\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfree(host2);\n\t}\n\treturn fd;\n}"
        }
      },
      {
        "call_info": {
          "callee": "usleep",
          "args": [
            "1000*1000"
          ],
          "line": 1855
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"wait_for_client: can't find number in X display: %s\\n\"",
            "q"
          ],
          "line": 1842
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"wait_for_client: can't find number in X display: %s\\n\"",
            "q"
          ],
          "line": 1838
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sscanf",
          "args": [
            "q+1",
            "\"%d\"",
            "&vdpy"
          ],
          "line": 1837
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"wait_for_client: can't find number in X display: %s\\n\"",
            "use_dpy"
          ],
          "line": 1834
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "num",
            "\":%d\"",
            "vnc_redirect_port"
          ],
          "line": 1830
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strrchr",
          "args": [
            "use_dpy",
            "':'"
          ],
          "line": 1825
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"avahi.h\"\n#include \"sslhelper.h\"\n#include \"remote.h\"\n#include \"cursor.h\"\n#include \"keyboard.h\"\n#include \"inet.h\"\n#include \"connections.h\"\n#include \"xwrappers.h\"\n#include \"sslhelper.h\"\n#include \"unixpw.h\"\n#include \"screen.h\"\n#include \"scan.h\"\n#include \"cleanup.h\"\n#include \"solid.h\"\n#include \"x11vnc.h\"\n\nstatic void do_vnc_redirect(int created_disp, char *vnc_redirect_host, int vnc_redirect_port,\n    int vnc_redirect_cnt, char *vnc_redirect_test) {\n\tchar *q = strrchr(use_dpy, ':');\n\tint vdpy = -1, sock = -1;\n\tint s_in, s_out, i;\n\tif (vnc_redirect == 2) {\n\t\tchar num[32];\t\n\t\tsprintf(num, \":%d\", vnc_redirect_port);\n\t\tq = num;\n\t}\n\tif (!q) {\n\t\trfbLog(\"wait_for_client: can't find number in X display: %s\\n\", use_dpy);\n\t\tclean_up_exit(1);\n\t}\n\tif (sscanf(q+1, \"%d\", &vdpy) != 1) {\n\t\trfbLog(\"wait_for_client: can't find number in X display: %s\\n\", q);\n\t\tclean_up_exit(1);\n\t}\n\tif (vdpy == -1 && vnc_redirect != 2) {\n\t\trfbLog(\"wait_for_client: can't find number in X display: %s\\n\", q);\n\t\tclean_up_exit(1);\n\t}\n\tif (vnc_redirect == 2) {\n\t\tif (vdpy < 0) {\n\t\t\tvdpy = -vdpy;\n\t\t} else if (vdpy < 200) {\n\t\t\tvdpy += 5900;\n\t\t}\n\t} else {\n\t\tvdpy += 5900;\n\t}\n\tif (created_disp) {\n\t\tusleep(1000*1000);\n\t}\n\tfor (i=0; i < 20; i++) {\n\t\tsock = connect_tcp(vnc_redirect_host, vdpy);\n\t\tif (sock >= 0) {\n\t\t\tbreak;\n\t\t}\n\t\trfbLog(\"wait_for_client: ...\\n\");\n\t\tusleep(500*1000);\n\t}\n\tif (sock < 0) {\n\t\trfbLog(\"wait_for_client: could not connect to a VNC Server at %s:%d\\n\", vnc_redirect_host, vdpy);\n\t\tclean_up_exit(1);\n\t}\n\tif (inetd) {\n\t\ts_in  = fileno(stdin);\n\t\ts_out = fileno(stdout);\n\t} else {\n\t\ts_in = s_out = vnc_redirect_sock;\n\t}\n\tif (vnc_redirect_cnt > 0) {\n\t\twrite(vnc_redirect_sock, vnc_redirect_test, vnc_redirect_cnt);\n\t}\n\trfbLog(\"wait_for_client: switching control to VNC Server at %s:%d\\n\", vnc_redirect_host, vdpy);\n\traw_xfer(sock, s_in, s_out);\n}"
  },
  {
    "function_name": "vnc_redirect_loop",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/user.c",
    "lines": "1695-1821",
    "snippet": "static void vnc_redirect_loop(char *vnc_redirect_test, int *vnc_redirect_cnt) {\n\tif (unixpw) {\n\t\trfbLog(\"wait_for_client: -unixpw and Xvnc.redirect not allowed\\n\");\n\t\tclean_up_exit(1);\n\t}\n\tif (client_connect) {\n\t\trfbLog(\"wait_for_client: -connect and Xvnc.redirect not allowed\\n\");\n\t\tclean_up_exit(1);\n\t}\n\tif (inetd) {\n\t\tif (use_openssl) {\n\t\t\taccept_openssl(OPENSSL_INETD, -1);\n\t\t}\n\t} else {\n\t\tpid_t pid = 0;\n\t\t/* XXX ipv6 */\n\t\tif (screen->httpListenSock >= 0) {\n#if LIBVNCSERVER_HAVE_FORK\n\t\t\tif ((pid = fork()) > 0) {\n\t\t\t\tclose(screen->httpListenSock);\n\t\t\t\t/* mutex */\n\t\t\t\tscreen->httpListenSock = -2;\n\t\t\t\tusleep(500 * 1000);\n\t\t\t} else {\n\t\t\t\tclose(screen->listenSock);\n\t\t\t\tscreen->listenSock = -1;\n\t\t\t\twhile (1) {\n\t\t\t\t\tusleep(10 * 1000);\n\t\t\t\t\trfbHttpCheckFds(screen);\n\t\t\t\t}\n\t\t\t\texit(1);\n\t\t\t}\n#else\n\t\t\tclean_up_exit(1);\n#endif\n\t\t}\n\t\tif (first_conn_timeout) {\n\t\t\tif (first_conn_timeout < 0) {\n\t\t\t\tfirst_conn_timeout = -first_conn_timeout;\n\t\t\t}\n\t\t\tsignal(SIGALRM, vnc_redirect_timeout);\n\t\t\talarm(first_conn_timeout);\n\t\t}\n\t\tif (use_openssl) {\n\t\t\tint i;\n\t\t\tif (pid == 0) {\n\t\t\t\taccept_openssl(OPENSSL_VNC, -1);\n\t\t\t} else {\n\t\t\t\tfor (i=0; i < 16; i++) {\n\t\t\t\t\taccept_openssl(OPENSSL_VNC, -1);\n\t\t\t\t\trfbLog(\"iter %d: vnc_redirect_sock: %d\\n\", i, vnc_redirect_sock);\n\t\t\t\t\tif (vnc_redirect_sock >= 0) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tstruct sockaddr_in addr;\n#ifdef __hpux\n\t\t\tint addrlen = sizeof(addr);\n#else\n\t\t\tsocklen_t addrlen = sizeof(addr);\n#endif\n\t\t\tif (screen->listenSock < 0) {\n\t\t\t\trfbLog(\"wait_for_client: Xvnc.redirect not listening... sock=%d port=%d\\n\", screen->listenSock, screen->port);\n\t\t\t\tclean_up_exit(1);\n\t\t\t}\n\t\t\tvnc_redirect_sock = accept(screen->listenSock, (struct sockaddr *)&addr, &addrlen);\n\t\t}\n\t\tif (first_conn_timeout) {\n\t\t\talarm(0);\n\t\t}\n\t\tif (pid > 0) {\n#if LIBVNCSERVER_HAVE_FORK\n\t\t\tint rc;\n\t\t\tpid_t pidw;\n\t\t\trfbLog(\"wait_for_client: kill TERM: %d\\n\", (int) pid);\n\t\t\tkill(pid, SIGTERM);\n\t\t\tusleep(1000 * 1000);\t/* 1.0 sec */\n\t\t\tpidw = waitpid(pid, &rc, WNOHANG);\n\t\t\tif (pidw <= 0) {\n\t\t\t\tusleep(1000 * 1000);\t/* 1.0 sec */\n\t\t\t\tpidw = waitpid(pid, &rc, WNOHANG);\n\t\t\t}\n#else\n\t\t\tclean_up_exit(1);\n#endif\n\t\t}\n\t}\n\tif (vnc_redirect_sock < 0) {\n\t\trfbLog(\"wait_for_client: vnc_redirect failed.\\n\");\n\t\tclean_up_exit(1);\n\t}\n\tif (!inetd && use_openssl) {\n\t\t/* check for Fetch Cert closing */\n\t\tfd_set rfds;\n\t\tstruct timeval tv;\n\t\tint nfds;\n\n\t\tusleep(300*1000);\n\n\t\tFD_ZERO(&rfds);\n\t\tFD_SET(vnc_redirect_sock, &rfds);\n\n\t\ttv.tv_sec = 0;\n\t\ttv.tv_usec = 200000;\n\t\tnfds = select(vnc_redirect_sock+1, &rfds, NULL, NULL, &tv);\n\n\t\trfbLog(\"wait_for_client: vnc_redirect nfds: %d\\n\", nfds);\n\t\tif (nfds > 0) {\n\t\t\tint n;\n\t\t\tn = read(vnc_redirect_sock, vnc_redirect_test, 1);\n\t\t\tif (n <= 0) {\n\t\t\t\tclose(vnc_redirect_sock);\n\t\t\t\tvnc_redirect_sock = -1;\n\t\t\t\trfbLog(\"wait_for_client: waiting for 2nd connection (Fetch Cert?)\\n\");\n\t\t\t\taccept_openssl(OPENSSL_VNC, -1);\n\t\t\t\tif (vnc_redirect_sock < 0) {\n\t\t\t\t\trfbLog(\"wait_for_client: vnc_redirect failed.\\n\");\n\t\t\t\t\tclean_up_exit(1);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t*vnc_redirect_cnt = n;\n\t\t\t}\n\t\t}\n\t}\n}",
    "includes": [
      "#include \"avahi.h\"",
      "#include \"sslhelper.h\"",
      "#include \"remote.h\"",
      "#include \"cursor.h\"",
      "#include \"keyboard.h\"",
      "#include \"inet.h\"",
      "#include \"connections.h\"",
      "#include \"xwrappers.h\"",
      "#include \"sslhelper.h\"",
      "#include \"unixpw.h\"",
      "#include \"screen.h\"",
      "#include \"scan.h\"",
      "#include \"cleanup.h\"",
      "#include \"solid.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "clean_up_exit",
          "args": [
            "1"
          ],
          "line": 1814
        },
        "resolved": true,
        "details": {
          "function_name": "clean_up_exit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/cleanup.c",
          "lines": "151-266",
          "snippet": "void clean_up_exit(int ret) {\n\tstatic int depth = 0;\n\texit_flag = 1;\n\n\tif (depth++ > 2) {\n\t\texit(ret);\n\t}\n\n\tif (icon_mode) {\n\t\tclean_icon_mode();\n\t}\n\n\t/* remove the shm areas: */\n\tclean_shm(0);\n\n\tstop_stunnel();\n\tif (use_openssl) {\n\t\tssl_helper_pid(0, 0);\t/* killall */\n\t}\n\n\tif (ssh_pid > 0) {\n\t\tkill(ssh_pid, SIGTERM);\n\t\tssh_pid = 0;\n\t}\n\n#ifdef MACOSX\n\tif (client_connect_file) {\n\t\tif (strstr(client_connect_file, \"/tmp/x11vnc-macosx-remote\")\n\t\t    == client_connect_file) {\n\t\t\tunlink(client_connect_file);\n\t\t}\n\t}\n\tif (macosx_console) {\n\t\tmacosxCG_fini();\n\t}\n#endif\n\n\tif (pipeinput_fh != NULL) {\n\t\tpclose(pipeinput_fh);\n\t\tpipeinput_fh = NULL;\n\t}\n\n\tshutdown_uinput();\n\n\tif (unix_sock) {\n\t\tif (unix_sock_fd >= 0) {\n\t\t\trfbLog(\"deleting unix sock: %s\\n\", unix_sock);\n\t\t\tclose(unix_sock_fd);\n\t\t\tunix_sock_fd = -1;\n\t\t\tunlink(unix_sock);\n\t\t}\n\t}\n\n\tif (! dpy) {\t/* raw_rb hack */\n\t\tif (rm_flagfile) {\n\t\t\tunlink(rm_flagfile);\n\t\t\trm_flagfile = NULL;\n\t\t}\n\t\texit(ret);\n\t}\n\n\t/* X keyboard cleanups */\n\tdelete_added_keycodes(0);\n\n\t/* remove all created XInput2 devices */\n\tif(use_multipointer)\n\t    removeAllMDs(dpy);\n\n\tif (clear_mods == 1) {\n\t\tclear_modifiers(0);\n\t} else if (clear_mods == 2) {\n\t\tclear_keys();\n\t} else if (clear_mods == 3) {\n\t\tclear_keys();\n\t\tclear_locks();\n\t}\n\n\tif (no_autorepeat) {\n\t\tautorepeat(1, 0);\n\t}\n\tif (use_solid_bg) {\n\t\tsolid_bg(1);\n\t}\n\tif (ncache || ncache0) {\n\t\tkde_no_animate(1);\n\t}\n\tX_LOCK;\n\tXTestDiscard_wr(dpy);\n#if HAVE_LIBXDAMAGE\n\tif (xdamage) {\n\t\tXDamageDestroy(dpy, xdamage);\n\t}\n#endif\n#if HAVE_LIBXTRAP\n\tif (trap_ctx) {\n\t\tXEFreeTC(trap_ctx);\n\t}\n#endif\n\t/* XXX rdpy_ctrl, etc. cannot close w/o blocking */\n\tXCloseDisplay_wr(dpy);\n\tX_UNLOCK;\n\n\tfflush(stderr);\n\n\tif (rm_flagfile) {\n\t\tunlink(rm_flagfile);\n\t\trm_flagfile = NULL;\n\t}\n\n\tif (avahi) {\n\t\tavahi_cleanup();\n\t\tfflush(stderr);\n\t}\n\n\texit(ret);\n}",
          "includes": [
            "#include \"xi2_devices.h\"",
            "#include \"uinput.h\"",
            "#include \"xevents.h\"",
            "#include \"xrecord.h\"",
            "#include \"screen.h\"",
            "#include \"avahi.h\"",
            "#include \"macosxCG.h\"",
            "#include \"macosx.h\"",
            "#include \"connections.h\"",
            "#include \"sslhelper.h\"",
            "#include \"sslcmds.h\"",
            "#include \"unixpw.h\"",
            "#include \"solid.h\"",
            "#include \"gui.h\"",
            "#include \"scan.h\"",
            "#include \"keyboard.h\"",
            "#include \"remote.h\"",
            "#include \"xdamage.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void clean_up_exit(int ret);",
            "int known_sigpipe_mode(char *s);",
            "static int exit_flag = 0;",
            "static void clean_icon_mode(void);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xi2_devices.h\"\n#include \"uinput.h\"\n#include \"xevents.h\"\n#include \"xrecord.h\"\n#include \"screen.h\"\n#include \"avahi.h\"\n#include \"macosxCG.h\"\n#include \"macosx.h\"\n#include \"connections.h\"\n#include \"sslhelper.h\"\n#include \"sslcmds.h\"\n#include \"unixpw.h\"\n#include \"solid.h\"\n#include \"gui.h\"\n#include \"scan.h\"\n#include \"keyboard.h\"\n#include \"remote.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nvoid clean_up_exit(int ret);\nint known_sigpipe_mode(char *s);\nstatic int exit_flag = 0;\nstatic void clean_icon_mode(void);\n\nvoid clean_up_exit(int ret) {\n\tstatic int depth = 0;\n\texit_flag = 1;\n\n\tif (depth++ > 2) {\n\t\texit(ret);\n\t}\n\n\tif (icon_mode) {\n\t\tclean_icon_mode();\n\t}\n\n\t/* remove the shm areas: */\n\tclean_shm(0);\n\n\tstop_stunnel();\n\tif (use_openssl) {\n\t\tssl_helper_pid(0, 0);\t/* killall */\n\t}\n\n\tif (ssh_pid > 0) {\n\t\tkill(ssh_pid, SIGTERM);\n\t\tssh_pid = 0;\n\t}\n\n#ifdef MACOSX\n\tif (client_connect_file) {\n\t\tif (strstr(client_connect_file, \"/tmp/x11vnc-macosx-remote\")\n\t\t    == client_connect_file) {\n\t\t\tunlink(client_connect_file);\n\t\t}\n\t}\n\tif (macosx_console) {\n\t\tmacosxCG_fini();\n\t}\n#endif\n\n\tif (pipeinput_fh != NULL) {\n\t\tpclose(pipeinput_fh);\n\t\tpipeinput_fh = NULL;\n\t}\n\n\tshutdown_uinput();\n\n\tif (unix_sock) {\n\t\tif (unix_sock_fd >= 0) {\n\t\t\trfbLog(\"deleting unix sock: %s\\n\", unix_sock);\n\t\t\tclose(unix_sock_fd);\n\t\t\tunix_sock_fd = -1;\n\t\t\tunlink(unix_sock);\n\t\t}\n\t}\n\n\tif (! dpy) {\t/* raw_rb hack */\n\t\tif (rm_flagfile) {\n\t\t\tunlink(rm_flagfile);\n\t\t\trm_flagfile = NULL;\n\t\t}\n\t\texit(ret);\n\t}\n\n\t/* X keyboard cleanups */\n\tdelete_added_keycodes(0);\n\n\t/* remove all created XInput2 devices */\n\tif(use_multipointer)\n\t    removeAllMDs(dpy);\n\n\tif (clear_mods == 1) {\n\t\tclear_modifiers(0);\n\t} else if (clear_mods == 2) {\n\t\tclear_keys();\n\t} else if (clear_mods == 3) {\n\t\tclear_keys();\n\t\tclear_locks();\n\t}\n\n\tif (no_autorepeat) {\n\t\tautorepeat(1, 0);\n\t}\n\tif (use_solid_bg) {\n\t\tsolid_bg(1);\n\t}\n\tif (ncache || ncache0) {\n\t\tkde_no_animate(1);\n\t}\n\tX_LOCK;\n\tXTestDiscard_wr(dpy);\n#if HAVE_LIBXDAMAGE\n\tif (xdamage) {\n\t\tXDamageDestroy(dpy, xdamage);\n\t}\n#endif\n#if HAVE_LIBXTRAP\n\tif (trap_ctx) {\n\t\tXEFreeTC(trap_ctx);\n\t}\n#endif\n\t/* XXX rdpy_ctrl, etc. cannot close w/o blocking */\n\tXCloseDisplay_wr(dpy);\n\tX_UNLOCK;\n\n\tfflush(stderr);\n\n\tif (rm_flagfile) {\n\t\tunlink(rm_flagfile);\n\t\trm_flagfile = NULL;\n\t}\n\n\tif (avahi) {\n\t\tavahi_cleanup();\n\t\tfflush(stderr);\n\t}\n\n\texit(ret);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"wait_for_client: vnc_redirect failed.\\n\""
          ],
          "line": 1813
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "accept_openssl",
          "args": [
            "OPENSSL_VNC",
            "-1"
          ],
          "line": 1811
        },
        "resolved": true,
        "details": {
          "function_name": "accept_openssl",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/sslhelper.c",
          "lines": "3302-4284",
          "snippet": "void accept_openssl(int mode, int presock) {\n\tint sock = -1, listen = -1, cport, csock, vsock;\t\n\tint peerport = 0;\n\tint status, n, i, db = 0;\n\tstruct sockaddr_in addr;\n#ifdef __hpux\n\tint addrlen = sizeof(addr);\n#else\n\tsocklen_t addrlen = sizeof(addr);\n#endif\n\trfbClientPtr client;\n\tpid_t pid;\n\tchar uniq[] = \"_evilrats_\";\n\tchar cookie[256], rcookie[256], *name = NULL;\n\tint vencrypt_sel = 0;\n\tint anontls_sel = 0;\n\tchar *ipv6_name = NULL;\n\tstatic double last_https = 0.0;\n\tstatic char last_get[256];\n\tstatic int first = 1;\n\tunsigned char *rb;\n\n#if !LIBVNCSERVER_HAVE_LIBSSL && !HAVE_LIBSSL  \n\tif (enc_str == NULL || strcmp(enc_str, \"none\")) {\n\t\tbadnews(\"0 accept_openssl\");\n\t}\n#endif\n\n\topenssl_last_helper_pid = 0;\n\n\t/* zero buffers for use below. */\n\tfor (i=0; i<256; i++) {\n\t\tif (first) {\n\t\t\tlast_get[i] = '\\0';\n\t\t}\n\t\tcookie[i]  = '\\0';\n\t\trcookie[i] = '\\0';\n\t}\n\tfirst = 0;\n\n\tif (getenv(\"ACCEPT_OPENSSL_DEBUG\")) {\n\t\tdb = atoi(getenv(\"ACCEPT_OPENSSL_DEBUG\"));\n\t}\n\n\t/* do INETD, VNC, or HTTPS cases (result is client socket or pipe) */\n\tif (mode == OPENSSL_INETD) {\n\t\tssl_initialized = 1;\n\n\t} else if (mode == OPENSSL_VNC) {\n\t\tsock = accept(openssl_sock, (struct sockaddr *)&addr, &addrlen);\n\t\tif (sock < 0)  {\n\t\t\trfbLog(\"SSL: accept_openssl: accept connection failed\\n\");\n\t\t\trfbLogPerror(\"accept\");\n\t\t\tif (ssl_no_fail) {\n\t\t\t\tclean_up_exit(1);\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t\tlisten = openssl_sock;\n\n\t} else if (mode == OPENSSL_VNC6 || mode == OPENSSL_HTTPS6) {\n#if X11VNC_IPV6\n\t\tstruct sockaddr_in6 a6;\n\t\tsocklen_t a6len = sizeof(a6);\n\t\tint fd = (mode == OPENSSL_VNC6 ? openssl_sock6 : https_sock6); \n\n\t\tsock = accept(fd, (struct sockaddr *)&a6, &a6len);\n\t\tif (sock < 0)  {\n\t\t\trfbLog(\"SSL: accept_openssl: accept connection failed\\n\");\n\t\t\trfbLogPerror(\"accept\");\n\t\t\tif (ssl_no_fail) {\n\t\t\t\tclean_up_exit(1);\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t\tipv6_name = ipv6_getipaddr((struct sockaddr *)&a6, a6len);\n\t\tif (!ipv6_name) ipv6_name = strdup(\"unknown\");\n\t\tlisten = fd;\n#endif\n\t} else if (mode == OPENSSL_REVERSE) {\n\t\tsock = presock;\n\t\tif (sock < 0)  {\n\t\t\trfbLog(\"SSL: accept_openssl: connection failed\\n\");\n\t\t\tif (ssl_no_fail) {\n\t\t\t\tclean_up_exit(1);\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t\tif (getenv(\"OPENSSL_REVERSE_DEBUG\")) fprintf(stderr, \"OPENSSL_REVERSE: ipv6_client_ip_str: %s\\n\", ipv6_client_ip_str);\n\t\tif (ipv6_client_ip_str != NULL) {\n\t\t\tipv6_name = strdup(ipv6_client_ip_str);\n\t\t}\n\t\tlisten = -1;\n\n\t} else if (mode == OPENSSL_HTTPS) {\n\t\tsock = accept(https_sock, (struct sockaddr *)&addr, &addrlen);\n\t\tif (sock < 0)  {\n\t\t\trfbLog(\"SSL: accept_openssl: accept connection failed\\n\");\n\t\t\trfbLogPerror(\"accept\");\n\t\t\tif (ssl_no_fail) {\n\t\t\t\tclean_up_exit(1);\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t\tlisten = https_sock;\n\t}\n\tif (db) fprintf(stderr, \"SSL: accept_openssl: sock: %d\\n\", sock);\n\n\tif (openssl_last_ip) {\n\t\tfree(openssl_last_ip);\n\t\topenssl_last_ip = NULL;\n\t}\n\tif (mode == OPENSSL_INETD) {\n\t\topenssl_last_ip = get_remote_host(fileno(stdin));\n\t} else if (mode == OPENSSL_VNC6 || mode == OPENSSL_HTTPS6) {\n\t\topenssl_last_ip = ipv6_name;\n\t} else if (mode == OPENSSL_REVERSE && ipv6_name != NULL) {\n\t\topenssl_last_ip = ipv6_name;\n\t} else {\n\t\topenssl_last_ip = get_remote_host(sock);\n\t}\n\n\tif (!check_ssl_access(openssl_last_ip)) {\n\t\trfbLog(\"SSL: accept_openssl: denying client %s\\n\", openssl_last_ip);\n\t\trfbLog(\"SSL: accept_openssl: does not match -allow or other reason.\\n\");\n\t\tclose(sock);\n\t\tsock = -1;\n\t\tif (ssl_no_fail) {\n\t\t\tclean_up_exit(1);\n\t\t}\n\t\treturn;\n\t}\n\n\t/* now make a listening socket for child to connect back to us by: */\n\n\tcport = find_free_port(20000, 22000);\n\tif (! cport && ipv6_listen) {\n\t\trfbLog(\"SSL: accept_openssl: seeking IPv6 port.\\n\");\n\t\tcport = find_free_port6(20000, 22000);\n\t\trfbLog(\"SSL: accept_openssl: IPv6 port: %d\\n\", cport);\n\t}\n\tif (! cport) {\n\t\trfbLog(\"SSL: accept_openssl: could not find open port.\\n\");\n\t\tclose(sock);\n\t\tif (mode == OPENSSL_INETD || ssl_no_fail) {\n\t\t\tclean_up_exit(1);\n\t\t}\n\t\treturn;\n\t}\n\tif (db) fprintf(stderr, \"accept_openssl: cport: %d\\n\", cport);\n\n\tcsock = listen_tcp(cport, htonl(INADDR_LOOPBACK), 1);\n\n\tif (csock < 0) {\n\t\trfbLog(\"SSL: accept_openssl: could not listen on port %d.\\n\",\n\t\t    cport);\n\t\tclose(sock);\n\t\tif (mode == OPENSSL_INETD || ssl_no_fail) {\n\t\t\tclean_up_exit(1);\n\t\t}\n\t\treturn;\n\t}\n\tif (db) fprintf(stderr, \"accept_openssl: csock: %d\\n\", csock);\n\n\tfflush(stderr);\n\n\t/*\n\t * make a simple cookie to id the child socket, not foolproof\n\t * but hard to guess exactly (just worrying about local lusers\n\t * here, since we use INADDR_LOOPBACK).\n\t */\n\trb = (unsigned char *) calloc(6, 1);\n#if LIBVNCSERVER_HAVE_LIBSSL || HAVE_LIBSSL \n\tRAND_bytes(rb, 6);\n#endif\n\tsprintf(cookie, \"RB=%d%d%d%d%d%d/%f%f/%p\",\n\t    rb[0], rb[1], rb[2], rb[3], rb[4], rb[5],\n            dnow() - x11vnc_start, x11vnc_start, (void *)rb);\n\n\tif (mode == OPENSSL_VNC6) {\n\t\tname = strdup(ipv6_name);\n\t\tpeerport = get_remote_port(sock);\n\t} else if (mode == OPENSSL_REVERSE && ipv6_name != NULL) {\n\t\tname = strdup(ipv6_name);\n\t\tpeerport = get_remote_port(sock);\n\t} else if (mode != OPENSSL_INETD) {\n\t\tname = get_remote_host(sock);\n\t\tpeerport = get_remote_port(sock);\n\t} else {\n\t\topenssl_last_ip = get_remote_host(fileno(stdin));\n\t\tpeerport = get_remote_port(fileno(stdin));\n\t\tif (openssl_last_ip) {\n\t\t\tname = strdup(openssl_last_ip);\n\t\t} else {\n\t\t\tname = strdup(\"unknown\");\n\t\t}\n\t}\n\tif (name) {\n\t\tif (mode == OPENSSL_INETD) {\n\t\t\trfbLog(\"SSL: (inetd) spawning helper process \"\n\t\t\t    \"to handle: %s:%d\\n\", name, peerport);\n\t\t} else {\n\t\t\trfbLog(\"SSL: spawning helper process to handle: \"\n\t\t\t    \"%s:%d\\n\", name, peerport);\n\t\t}\n\t\tfree(name);\n\t\tname = NULL;\n\t}\n\n\tif (certret) {\n\t\tfree(certret);\n\t}\n\tif (certret_str) {\n\t\tfree(certret_str);\n\t\tcertret_str = NULL;\n\t}\n\tcertret = strdup(\"/tmp/x11vnc-certret.XXXXXX\");\n\tomode = umask(077);\n\tcertret_fd = mkstemp(certret);\n\tumask(omode);\n\tif (certret_fd < 0) {\n\t\tfree(certret);\n\t\tcertret = NULL;\n\t\tcertret_fd = -1;\n\t}\n\n\tif (dhret) {\n\t\tfree(dhret);\n\t}\n\tif (dhret_str) {\n\t\tfree(dhret_str);\n\t\tdhret_str = NULL;\n\t}\n\tdhret = strdup(\"/tmp/x11vnc-dhret.XXXXXX\");\n\tomode = umask(077);\n\tdhret_fd = mkstemp(dhret);\n\tumask(omode);\n\tif (dhret_fd < 0) {\n\t\tfree(dhret);\n\t\tdhret = NULL;\n\t\tdhret_fd = -1;\n\t}\n\n\t/* now fork the child to handle the SSL: */\n\tpid = fork();\n\n\tif (pid > 0) {\n\t\trfbLog(\"SSL: helper for peerport %d is pid %d: \\n\",\n\t\t    peerport, (int) pid);\n\t}\n\n\tif (pid < 0) {\n\t\trfbLog(\"SSL: accept_openssl: could not fork.\\n\");\n\t\trfbLogPerror(\"fork\");\n\t\tclose(sock);\n\t\tclose(csock);\n\t\tif (mode == OPENSSL_INETD || ssl_no_fail) {\n\t\t\tclean_up_exit(1);\n\t\t}\n\t\treturn;\n\n\t} else if (pid == 0) {\n\t\tint s_in, s_out, httpsock = -1;\n\t\tint vncsock;\n\t\tint i, have_httpd = 0;\n\t\tint f_in  = fileno(stdin);\n\t\tint f_out = fileno(stdout);\n\t\tint skip_vnc_tls = mode == OPENSSL_HTTPS ? 1 : 0;\n\n\t\tif (db) fprintf(stderr, \"helper pid in: %d %d %d %d\\n\", f_in, f_out, sock, listen);\n\n\t\t/* reset all handlers to default (no interrupted() calls) */\n\t\tunset_signals();\n\n\t\t/* close all non-essential fd's */\n\t\tfor (i=0; i<256; i++) {\n\t\t\tif (mode == OPENSSL_INETD) {\n\t\t\t\tif (i == f_in || i == f_out) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (i == sock) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (i == 2) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tclose(i);\n\t\t}\n\n\t\t/*\n\t\t * sadly, we are a long lived child and so the large\n\t\t * framebuffer memory areas will soon differ from parent.\n\t\t * try to free as much as possible.\n\t\t */\n\t\tlose_ram();\n\n\t\t/* now connect back to parent socket: */\n\t\tvncsock = connect_tcp(\"127.0.0.1\", cport);\n\t\tif (vncsock < 0) {\n\t\t\trfbLog(\"SSL: ssl_helper[%d]: could not connect\"\n\t\t\t    \" back to: %d\\n\", getpid(), cport);\n\t\t\trfbLog(\"SSL: ssl_helper[%d]: exit case 1 (no local vncsock)\\n\", getpid());\n\t\t\texit(1);\n\t\t}\n\t\tif (db) fprintf(stderr, \"vncsock %d\\n\", vncsock);\n\n\t\t/* try to initialize SSL with the remote client */\n\n\t\tif (mode == OPENSSL_INETD) {\n\t\t\ts_in  = fileno(stdin);\n\t\t\ts_out = fileno(stdout);\n\t\t} else {\n\t\t\ts_in = s_out = sock;\n\t\t}\n\n\t\tif (! ssl_init(s_in, s_out, skip_vnc_tls, last_https)) {\n\t\t\tclose(vncsock);\n\t\t\trfbLog(\"SSL: ssl_helper[%d]: exit case 2 (ssl_init failed)\\n\", getpid());\n\t\t\texit(1);\n\t\t}\n\n\t\tif (vencrypt_selected != 0) {\n\t\t\tchar *tbuf;\n\t\t\ttbuf = (char *) malloc(strlen(cookie) + 100);\n\t\t\tsprintf(tbuf, \"%s,VENCRYPT=%d,%s\", uniq, vencrypt_selected, cookie);\n\t\t\twrite(vncsock, tbuf, strlen(cookie));\n\t\t\tgoto wrote_cookie;\n\t\t} else if (anontls_selected != 0) {\n\t\t\tchar *tbuf;\n\t\t\ttbuf = (char *) malloc(strlen(cookie) + 100);\n\t\t\tsprintf(tbuf, \"%s,ANONTLS=%d,%s\", uniq, anontls_selected, cookie);\n\t\t\twrite(vncsock, tbuf, strlen(cookie));\n\t\t\tgoto wrote_cookie;\n\t\t}\n\n\t\t/*\n\t\t * things get messy below since we are trying to do\n\t\t * *both* VNC and Java applet httpd through the same\n\t\t * SSL socket.\n\t\t */\n\n\t\tif (! screen) {\n\t\t\tclose(vncsock);\n\t\t\texit(1);\n\t\t}\n\t\tif (screen->httpListenSock >= 0 && screen->httpPort > 0) {\n\t\t\thave_httpd = 1;\n\t\t} else if (ipv6_http_fd >= 0) {\n\t\t\thave_httpd = 1;\n\t\t} else if (screen->httpListenSock == -2) {\n\t\t\thave_httpd = 1;\n\t\t}\n\t\tif (mode == OPENSSL_HTTPS && ! have_httpd) {\n\t\t\trfbLog(\"SSL: accept_openssl[%d]: no httpd socket for \"\n\t\t\t    \"-https mode\\n\", getpid());\n\t\t\tclose(vncsock);\n\t\t\trfbLog(\"SSL: ssl_helper[%d]: exit case 3 (no httpd sock)\\n\", getpid());\n\t\t\texit(1);\n\t\t}\n\n\t\tif (have_httpd) {\n\t\t\tint n = 0, is_http = 0;\n\t\t\tint hport = screen->httpPort; \n\t\t\tchar *iface = NULL;\n\t\t\tchar *buf, *tbuf;\n\n\t\t\tbuf  = (char *) calloc((ABSIZE+1), 1);\n\t\t\ttbuf = (char *) calloc((2*ABSIZE+1), 1);\n\n\t\t\tif (mode == OPENSSL_HTTPS) {\n\t\t\t\t/*\n\t\t\t\t * for this mode we know it is HTTP traffic\n\t\t\t\t * so we skip trying to guess.\n\t\t\t\t */\n\t\t\t\tis_http = 1;\n\t\t\t\tn = 0;\n\t\t\t\tgoto connect_to_httpd;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * Check if there is stuff to read from remote end\n\t\t\t * if so it is likely a GET or HEAD.\n\t\t\t */\n\t\t\tif (! is_ssl_readable(s_in, last_https, last_get,\n\t\t\t    mode)) {\n\t\t\t\tgoto write_cookie;\n\t\t\t}\n\t\n\t\t\t/* \n\t\t\t * read first 2 bytes to try to guess.  sadly,\n\t\t\t * the user is often pondering a \"non-verified\n\t\t\t * cert\" dialog for a long time before the GET\n\t\t\t * is ever sent.  So often we timeout here.\n\t\t\t */\n\n\t\t\tif (db) fprintf(stderr, \"watch_for_http_traffic\\n\");\n\n\t\t\tis_http = watch_for_http_traffic(buf, &n, s_in);\n\n\t\t\tif (is_http < 0 || is_http == 0) {\n\t\t\t\t/*\n\t\t\t\t * error or http not detected, fall back\n\t\t\t\t * to normal VNC socket.\n\t\t\t\t */\n\t\t\t\tif (db) fprintf(stderr, \"is_http err: %d n: %d\\n\", is_http, n);\n\t\t\t\twrite(vncsock, cookie, strlen(cookie));\n\t\t\t\tif (n > 0) {\n\t\t\t\t\twrite(vncsock, buf, n);\n\t\t\t\t}\n\t\t\t\tgoto wrote_cookie;\n\t\t\t}\n\n\t\t\tif (db) fprintf(stderr, \"is_http: %d n: %d\\n\",\n\t\t\t    is_http, n);\n\t\t\tif (db) fprintf(stderr, \"buf: '%s'\\n\", buf);\n\n\t\t\tif (strstr(buf, \"/request.https.vnc.connection\")) {\n\t\t\t\tchar reply[] = \"HTTP/1.0 200 OK\\r\\n\"\n\t\t\t\t    \"Content-Type: octet-stream\\r\\n\"\n\t\t\t\t    \"Connection: Keep-Alive\\r\\n\"\n\t\t\t\t    \"VNC-Server: x11vnc\\r\\n\"\n\t\t\t\t    \"Pragma: no-cache\\r\\n\\r\\n\";\n\t\t\t\t/*\n\t\t\t\t * special case proxy coming thru https\n\t\t\t\t * instead of a direct SSL connection.\n\t\t\t\t */\n\t\t\t\trfbLog(\"Handling VNC request via https GET. [%d]\\n\", getpid());\n\t\t\t\trfbLog(\"-- %s\\n\", buf);\n\n\t\t\t\tif (strstr(buf, \"/reverse.proxy\")) {\n\t\t\t\t\tchar *buf2;\n\t\t\t\t\tint n, ptr;\n#if !LIBVNCSERVER_HAVE_LIBSSL && !HAVE_LIBSSL \n\t\t\t\t\twrite(s_out, reply, strlen(reply));\n#else\n\t\t\t\t\tSSL_write(ssl, reply, strlen(reply));\n#endif\n\t\t\t\t\n\t\t\t\t\tbuf2  = (char *) calloc((8192+1), 1);\n\t\t\t\t\tn = 0;\n\t\t\t\t\tptr = 0;\n\t\t\t\t\twhile (ptr < 8192) {\n#if !LIBVNCSERVER_HAVE_LIBSSL && !HAVE_LIBSSL \n\t\t\t\t\t\tn = read(s_in, buf2 + ptr, 1);\n#else\n\t\t\t\t\t\tn = SSL_read(ssl, buf2 + ptr, 1);\n#endif\n\t\t\t\t\t\tif (n > 0) {\n\t\t\t\t\t\t\tptr += n;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (db) fprintf(stderr, \"buf2: '%s'\\n\", buf2);\n\n\t\t\t\t\t\tif (strstr(buf2, \"\\r\\n\\r\\n\")) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tfree(buf2);\n\t\t\t\t}\n\t\t\t\tgoto write_cookie;\n\n\t\t\t} else if (strstr(buf, \"/check.https.proxy.connection\")) {\n\t\t\t\tchar reply[] = \"HTTP/1.0 200 OK\\r\\n\"\n\t\t\t\t    \"Connection: close\\r\\n\"\n\t\t\t\t    \"Content-Type: octet-stream\\r\\n\"\n\t\t\t\t    \"VNC-Server: x11vnc\\r\\n\"\n\t\t\t\t    \"Pragma: no-cache\\r\\n\\r\\n\";\n\n\t\t\t\trfbLog(\"Handling Check HTTPS request via https GET. [%d]\\n\", getpid());\n\t\t\t\trfbLog(\"-- %s\\n\", buf);\n\n#if !LIBVNCSERVER_HAVE_LIBSSL && !HAVE_LIBSSL \n\t\t\t\twrite(s_out, reply, strlen(reply));\n#else\n\t\t\t\tSSL_write(ssl, reply, strlen(reply));\n\t\t\t\tSSL_shutdown(ssl);\n#endif\n\n\t\t\t\tstrcpy(tbuf, uniq);\n\t\t\t\tstrcat(tbuf, cookie);\n\t\t\t\twrite(vncsock, tbuf, strlen(tbuf));\n\t\t\t\tclose(vncsock);\n\n\t\t\t\trfbLog(\"SSL: ssl_helper[%d]: exit case 4 (check.https.proxy.connection)\\n\", getpid());\n\t\t\t\texit(0);\n\t\t\t}\n\t\t\tconnect_to_httpd:\n\n\t\t\t/*\n\t\t\t * Here we go... no turning back.  we have to\n\t\t\t * send failure to parent and close socket to have\n\t\t\t * http processed at all in a timely fashion...\n\t\t\t */\n\n\t\t\t/* send the failure tag: */\n\t\t\tstrcpy(tbuf, uniq);\n\n\t\t\tif (https_port_redir < 0 || (strstr(buf, \"PORT=\") || strstr(buf, \"port=\"))) {\n\t\t\t\tchar *q = strstr(buf, \"Host:\");\n\t\t\t\tint fport = 443, match = 0;\n\t\t\t\tchar num[16];\n\n\t\t\t\tif (q && strstr(q, \"\\n\")) {\n\t\t\t\t    q += strlen(\"Host:\") + 1;\n\t\t\t\t    while (*q != '\\n') {\n\t\t\t\t\tint p;\n\t\t\t\t\tif (*q == ':' && sscanf(q, \":%d\", &p) == 1) {\n\t\t\t\t\t\tif (p > 0 && p < 65536) {\n\t\t\t\t\t\t\tfport = p;\n\t\t\t\t\t\t\tmatch = 1;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tq++;\n\t\t\t\t    }\n\t\t\t\t}\n\t\t\t\tif (!match || !https_port_redir) {\n\t\t\t\t\tint p;\n\t\t\t\t\tif (sscanf(buf, \"PORT=%d,\", &p) == 1) {\n\t\t\t\t\t\tif (p > 0 && p < 65536) {\n\t\t\t\t\t\t\tfport = p;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else if (sscanf(buf, \"port=%d,\", &p) == 1) {\n\t\t\t\t\t\tif (p > 0 && p < 65536) {\n\t\t\t\t\t\t\tfport = p;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tsprintf(num, \"HP=%d,\", fport);\n\t\t\t\tstrcat(tbuf, num);\n\t\t\t}\n\n\t\t\tif (strstr(buf, \"HTTP/\") != NULL)  {\n\t\t\t\tchar *q, *str;\n\t\t\t\t/*\n\t\t\t\t * Also send back the GET line for heuristics.\n\t\t\t\t * (last_https, get file).\n\t\t\t\t */\n\t\t\t\tstr = strdup(buf);\n\t\t\t\tq = strstr(str, \"HTTP/\");\n\t\t\t\tif (q != NULL) {\n\t\t\t\t\t*q = '\\0';\t\n\t\t\t\t\tstrcat(tbuf, str);\n\t\t\t\t}\n\t\t\t\tfree(str);\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * Also send the cookie to pad out the number of\n\t\t\t * bytes to more than the parent wants to read.\n\t\t\t * Since this is the failure case, it does not\n\t\t\t * matter that we send more than strlen(cookie).\n\t\t\t */\n\t\t\tstrcat(tbuf, cookie);\n\t\t\twrite(vncsock, tbuf, strlen(tbuf));\n\n\t\t\tusleep(150*1000);\n\t\t\tif (db) fprintf(stderr, \"close vncsock: %d\\n\", vncsock);\n\t\t\tclose(vncsock);\n\n\t\t\t/* now, finally, connect to the libvncserver httpd: */\n\t\t\tif (screen->listenInterface == htonl(INADDR_ANY) ||\n\t\t\t    screen->listenInterface == htonl(INADDR_NONE)) {\n\t\t\t\tiface = \"127.0.0.1\";\n\t\t\t} else {\n\t\t\t\tstruct in_addr in;\n\t\t\t\tin.s_addr = screen->listenInterface;\n\t\t\t\tiface = inet_ntoa(in);\n\t\t\t}\n\t\t\tif (iface == NULL || !strcmp(iface, \"\")) {\n\t\t\t\tiface = \"127.0.0.1\";\n\t\t\t}\n\t\t\tif (db) fprintf(stderr, \"iface: %s:%d\\n\", iface, hport);\n\t\t\tusleep(150*1000);\n\n\t\t\thttpsock = connect_tcp(iface, hport);\n\n\t\t\tif (httpsock < 0) {\n\t\t\t\t/* UGH, after all of that! */\n\t\t\t\trfbLog(\"Could not connect to httpd socket!\\n\");\n\t\t\t\trfbLog(\"SSL: ssl_helper[%d]: exit case 5.\\n\", getpid());\n\t\t\t\texit(1);\n\t\t\t}\n\t\t\tif (db) fprintf(stderr, \"ssl_helper[%d]: httpsock: %d %d\\n\",\n\t\t\t    getpid(), httpsock, n);\n\n\t\t\t/*\n\t\t\t * send what we read to httpd, and then connect\n\t\t\t * the rest of the SSL session to it:\n\t\t\t */\n\t\t\tif (n > 0) {\n\t\t\t\tchar *s = getenv(\"X11VNC_EXTRA_HTTPS_PARAMS\");\n\t\t\t\tint did_extra = 0;\n\n\t\t\t\tif (db) fprintf(stderr, \"sending http buffer httpsock: %d n=%d\\n'%s'\\n\", httpsock, n, buf);\n\t\t\t\tif (s != NULL) {\n\t\t\t\t\tchar *q = strstr(buf, \" HTTP/\");\n\t\t\t\t\tif (q) {\n\t\t\t\t\t\tint m;\n\t\t\t\t\t\t*q = '\\0';\n\t\t\t\t\t\tm = strlen(buf);\n\t\t\t\t\t\twrite(httpsock, buf, m);\n\t\t\t\t\t\twrite(httpsock, s, strlen(s));\n\t\t\t\t\t\t*q = ' ';\n\t\t\t\t\t\twrite(httpsock, q, n-m);\n\t\t\t\t\t\tdid_extra = 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (!did_extra) {\n\t\t\t\t\twrite(httpsock, buf, n);\n\t\t\t\t}\n\t\t\t}\n\t\t\tssl_xfer(httpsock, s_in, s_out, is_http);\n\t\t\trfbLog(\"SSL: ssl_helper[%d]: exit case 6 (https ssl_xfer done)\\n\", getpid());\n\t\t\texit(0);\n\t\t}\n\n\t\t/*\n\t\t * ok, back from the above https mess, simply send the\n\t\t * cookie back to the parent (who will attach us to\n\t\t * libvncserver), and connect the rest of the SSL session\n\t\t * to it.\n\t\t */\n\t\twrite_cookie:\n\t\twrite(vncsock, cookie, strlen(cookie));\n\n\t\twrote_cookie:\n\t\tssl_xfer(vncsock, s_in, s_out, 0);\n\t\trfbLog(\"SSL: ssl_helper[%d]: exit case 7 (ssl_xfer done)\\n\", getpid());\n\t\tif (0) usleep(50 * 1000);\n\t\texit(0);\n\t}\n\t/* parent here */\n\n\tif (mode != OPENSSL_INETD) {\n\t\tclose(sock);\n\t}\n\tif (db) fprintf(stderr, \"helper process is: %d\\n\", pid);\n\n\t/* accept connection from our child.  */\n\tsignal(SIGALRM, csock_timeout);\n\tcsock_timeout_sock = csock;\n\talarm(20);\n\n\tvsock = accept(csock, (struct sockaddr *)&addr, &addrlen);\n\n\talarm(0);\n\tsignal(SIGALRM, SIG_DFL);\n\tclose(csock);\n\n\n\tif (vsock < 0) {\n\t\trfbLog(\"SSL: accept_openssl: connection from ssl_helper[%d] FAILED.\\n\", pid);\n\t\trfbLogPerror(\"accept\");\n\n\t\tkill(pid, SIGTERM);\n\t\twaitpid(pid, &status, WNOHANG); \n\t\tif (mode == OPENSSL_INETD || ssl_no_fail) {\n\t\t\tclean_up_exit(1);\n\t\t}\n\t\tif (certret_fd >= 0) {\n\t\t\tclose(certret_fd);\n\t\t\tcertret_fd = -1;\n\t\t}\n\t\tif (certret) {\n\t\t\tunlink(certret);\n\t\t}\n\t\tif (dhret_fd >= 0) {\n\t\t\tclose(dhret_fd);\n\t\t\tdhret_fd = -1;\n\t\t}\n\t\tif (dhret) {\n\t\t\tunlink(dhret);\n\t\t}\n\t\treturn;\n\t}\n\tif (db) fprintf(stderr, \"accept_openssl: vsock: %d\\n\", vsock);\n\n\tn = read(vsock, rcookie, strlen(cookie));\n\tif (n < 0 && errno != 0) {\n\t\trfbLogPerror(\"read\");\n\t}\n\n\tif (certret) {\n\t\tstruct stat sbuf;\n\t\tsbuf.st_size = 0;\n\t\tif (certret_fd >= 0 && stat(certret, &sbuf) == 0 && sbuf.st_size > 0) {\n\t\t\tcertret_str = (char *) calloc(sbuf.st_size+1, 1);\n\t\t\tread(certret_fd, certret_str, sbuf.st_size);\n\t\t\tclose(certret_fd);\n\t\t\tcertret_fd = -1;\n\t\t}\n\t\tif (certret_fd >= 0) {\n\t\t\tclose(certret_fd);\n\t\t\tcertret_fd = -1;\n\t\t}\n\t\tunlink(certret);\n\t\tif (certret_str && strstr(certret_str, \"NOCERT\") == certret_str) {\n\t\t\tfree(certret_str);\n\t\t\tcertret_str = NULL;\n\t\t}\n\t\tif (0 && certret_str) {\n\t\t\tfprintf(stderr, \"certret_str[%d]:\\n%s\\n\", (int) sbuf.st_size, certret_str);\n\t\t}\n\t}\n\n\tif (dhret) {\n\t\tstruct stat sbuf;\n\t\tsbuf.st_size = 0;\n\t\tif (dhret_fd >= 0 && stat(dhret, &sbuf) == 0 && sbuf.st_size > 0) {\n\t\t\tdhret_str = (char *) calloc(sbuf.st_size+1, 1);\n\t\t\tread(dhret_fd, dhret_str, sbuf.st_size);\n\t\t\tclose(dhret_fd);\n\t\t\tdhret_fd = -1;\n\t\t}\n\t\tif (dhret_fd >= 0) {\n\t\t\tclose(dhret_fd);\n\t\t\tdhret_fd = -1;\n\t\t}\n\t\tunlink(dhret);\n\t\tif (dhret_str && strstr(dhret_str, \"NOCERT\") == dhret_str) {\n\t\t\tfree(dhret_str);\n\t\t\tdhret_str = NULL;\n\t\t}\n\t\tif (dhret_str) {\n\t\t\tif (new_dh_params == NULL) {\n\t\t\t\tfprintf(stderr, \"dhret_str[%d]:\\n%s\\n\", (int) sbuf.st_size, dhret_str);\n\t\t\t\tnew_dh_params = strdup(dhret_str);\n\t\t\t}\n\t\t}\n\t}\n\n\tif (0) {\n\t\tfprintf(stderr, \"rcookie: %s\\n\", rcookie);\n\t\tfprintf(stderr, \"cookie:  %s\\n\", cookie);\n\t}\n\n\tif (strstr(rcookie, uniq) == rcookie) {\n\t\tchar *q = strstr(rcookie, \"RB=\");\n\t\tif (q && strstr(cookie, q) == cookie) {\n\t\t\tvencrypt_sel = 0;\n\t\t\tanontls_sel = 0;\n\t\t\tq = strstr(rcookie, \"VENCRYPT=\");\n\t\t\tif (q && sscanf(q, \"VENCRYPT=%d,\", &vencrypt_sel) == 1) {\n\t\t\t\tif (vencrypt_sel != 0) {\n\t\t\t\t\trfbLog(\"SSL: VENCRYPT mode=%d accepted. helper[%d]\\n\", vencrypt_sel, pid);\n\t\t\t\t\tgoto accept_client;\n\t\t\t\t}\n\t\t\t}\n\t\t\tq = strstr(rcookie, \"ANONTLS=\");\n\t\t\tif (q && sscanf(q, \"ANONTLS=%d,\", &anontls_sel) == 1) {\n\t\t\t\tif (anontls_sel != 0) {\n\t\t\t\t\trfbLog(\"SSL: ANONTLS mode=%d accepted. helper[%d]\\n\", anontls_sel, pid);\n\t\t\t\t\tgoto accept_client;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tif (n != (int) strlen(cookie) || strncmp(cookie, rcookie, n)) {\n\t\trfbLog(\"SSL: accept_openssl: cookie from ssl_helper[%d] FAILED. %d\\n\", pid, n);\n\t\tif (db) fprintf(stderr, \"'%s'\\n'%s'\\n\", cookie, rcookie);\n\t\tclose(vsock);\n\n\t\tif (strstr(rcookie, uniq) == rcookie) {\n\t\t\tint i;\n\t\t\tdouble https_download_wait_time = 15.0;\n\n\t\t\tif (getenv(\"X11VNC_HTTPS_DOWNLOAD_WAIT_TIME\")) {\n\t\t\t\thttps_download_wait_time = atof(getenv(\"X11VNC_HTTPS_DOWNLOAD_WAIT_TIME\"));\n\t\t\t}\n\n\t\t\trfbLog(\"SSL: BUT WAIT! HTTPS for helper process[%d] succeeded. Good.\\n\", pid);\n\t\t\tif (mode != OPENSSL_HTTPS) {\n\t\t\t\tlast_https = dnow();\n\t\t\t\tfor (i=0; i<256; i++) {\n\t\t\t\t\tlast_get[i] = '\\0';\n\t\t\t\t}\n\t\t\t\tstrncpy(last_get, rcookie, 100);\n\t\t\t\tif (db) fprintf(stderr, \"last_get: '%s'\\n\", last_get);\n\t\t\t}\n\t\t\tif (rcookie && strstr(rcookie, \"VncViewer.class\")) {\n\t\t\t\trfbLog(\"\\n\");\n\t\t\t\trfbLog(\"helper[%d]:\\n\", pid);\n\t\t\t\trfbLog(\"***********************************************************\\n\");\n\t\t\t\trfbLog(\"SSL: WARNING CLIENT ASKED FOR NONEXISTENT 'VncViewer.class'\\n\");\n\t\t\t\trfbLog(\"SSL: USER NEEDS TO MAKE SURE THE JAVA PLUGIN IS INSTALLED\\n\");\n\t\t\t\trfbLog(\"SSL: AND WORKING PROPERLY (e.g. a test-java-plugin page.)\\n\");\n\t\t\t\trfbLog(\"SSL: AND/OR USER NEEDS TO **RESTART** HIS WEB BROWSER.\\n\");\n\t\t\t\trfbLog(\"SSL: SOMETIMES THE BROWSER 'REMEMBERS' FAILED APPLET DOWN-\\n\");\n\t\t\t\trfbLog(\"SSL: LOADS AND RESTARTING IT IS THE ONLY WAY TO FIX THINGS.\\n\");\n\t\t\t\trfbLog(\"***********************************************************\\n\");\n\t\t\t\trfbLog(\"\\n\");\n\t\t\t}\n\t\t\tssl_helper_pid(pid, -2);\n\n\t\t\tif (https_port_redir) {\n\t\t\t\tdouble start;\n\t\t\t\tint origport = screen->port;\n\t\t\t\tint useport = screen->port;\n\t\t\t\tint saw_httpsock = 0;\n\t\t\t\t/* to expand $PORT correctly in index.vnc */\n\t\t\t\tif (https_port_redir < 0) {\n\t\t\t\t\tchar *q = strstr(rcookie, \"HP=\");\n\t\t\t\t\tif (q) {\n\t\t\t\t\t\tint p;\n\t\t\t\t\t\tif (sscanf(q, \"HP=%d,\", &p) == 1) {\n\t\t\t\t\t\t\tuseport = p;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tuseport = https_port_redir;\n\t\t\t\t}\n\t\t\t\tscreen->port = useport;\n\t\t\t\tif (origport != useport) {\n\t\t\t\t\trfbLog(\"SSL: -httpsredir guess port: %d  helper[%d]\\n\", screen->port, pid);\n\t\t\t\t}\n\n\t\t\t\tstart = dnow();\n\t\t\t\twhile (dnow() < start + https_download_wait_time) {\n\t\t\t\t\tif (screen->httpSock >= 0) saw_httpsock = 1;\n\t\t\t\t\trfbPE(10000);\n\t\t\t\t\tusleep(10000);\n\t\t\t\t\tif (screen->httpSock >= 0) saw_httpsock = 1;\n\t\t\t\t\twaitpid(pid, &status, WNOHANG); \n\t\t\t\t\tif (kill(pid, 0) != 0) {\n\t\t\t\t\t\trfbLog(\"SSL: helper[%d] pid finished\\n\", pid);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif (0 && saw_httpsock && screen->httpSock < 0) {\n\t\t\t\t\t\t/* this check can kill the helper too soon. */\n\t\t\t\t\t\trfbLog(\"SSL: httpSock for helper[%d] went away\\n\", pid);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\trfbLog(\"SSL: guessing child helper[%d] https finished. dt=%.6f\\n\",\n\t\t\t\t    pid, dnow() - start);\n\n\t\t\t\trfbPE(10000);\n\t\t\t\trfbPE(10000);\n\t\t\t\trfbPE(10000);\n\n\t\t\t\tscreen->port = origport;\n\t\t\t\tssl_helper_pid(0, -2);\n\t\t\t\tif (mode == OPENSSL_INETD) {\n\t\t\t\t\tclean_up_exit(1);\n\t\t\t\t}\n\t\t\t} else if (mode == OPENSSL_INETD) {\n\t\t\t\tdouble start;\n\t\t\t\tint saw_httpsock = 0;\n\n\t\t\t\t/* to expand $PORT correctly in index.vnc */\n\t\t\t\tif (screen->port == 0) {\n\t\t\t\t\tint fd = fileno(stdin);\n\t\t\t\t\tif (getenv(\"X11VNC_INETD_PORT\")) {\n\t\t\t\t\t\t/* mutex */\n\t\t\t\t\t\tscreen->port = atoi(getenv(\n\t\t\t\t\t\t    \"X11VNC_INETD_PORT\"));\n\t\t\t\t\t} else {\n\t\t\t\t\t\tint tport = get_local_port(fd);\n\t\t\t\t\t\tif (tport > 0) {\n\t\t\t\t\t\t\tscreen->port = tport;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\trfbLog(\"SSL: screen->port %d for helper[%d]\\n\", screen->port, pid);\n\n\t\t\t\t/* kludge for https fetch via inetd */\n\t\t\t\tstart = dnow();\n\t\t\t\twhile (dnow() < start + https_download_wait_time) {\n\t\t\t\t\tif (screen->httpSock >= 0) saw_httpsock = 1;\n\t\t\t\t\trfbPE(10000);\n\t\t\t\t\tusleep(10000);\n\t\t\t\t\tif (screen->httpSock >= 0) saw_httpsock = 1;\n\t\t\t\t\twaitpid(pid, &status, WNOHANG); \n\t\t\t\t\tif (kill(pid, 0) != 0) {\n\t\t\t\t\t\trfbLog(\"SSL: helper[%d] pid finished\\n\", pid);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif (0 && saw_httpsock && screen->httpSock < 0) {\n\t\t\t\t\t\t/* this check can kill the helper too soon. */\n\t\t\t\t\t\trfbLog(\"SSL: httpSock for helper[%d] went away\\n\", pid);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\trfbLog(\"SSL: OPENSSL_INETD guessing \"\n\t\t\t\t    \"child helper[%d] https finished. dt=%.6f\\n\",\n\t\t\t\t    pid, dnow() - start);\n\n\t\t\t\trfbPE(10000);\n\t\t\t\trfbPE(10000);\n\t\t\t\trfbPE(10000);\n\n\t\t\t\tssl_helper_pid(0, -2);\n\t\t\t\tclean_up_exit(1);\n\t\t\t}\n\t\t\t/* this will actually only get earlier https */\n\t\t\tssl_helper_pid(0, -2);\n\t\t\treturn;\n\t\t}\n\t\tkill(pid, SIGTERM);\n\t\twaitpid(pid, &status, WNOHANG); \n\t\tif (mode == OPENSSL_INETD || ssl_no_fail) {\n\t\t\tclean_up_exit(1);\n\t\t}\n\t\treturn;\n\t}\n\n\taccept_client:\n\n\tif (db) fprintf(stderr, \"accept_openssl: cookie good: %s\\n\", cookie);\n\n\trfbLog(\"SSL: handshake with helper process[%d] succeeded.\\n\", pid);\n\n\topenssl_last_helper_pid = pid;\n\tssl_helper_pid(pid, vsock);\n\n\tif (vnc_redirect) {\n\t\tvnc_redirect_sock = vsock;\n\t\topenssl_last_helper_pid = 0;\n\t\treturn;\n\t}\n\n\tclient = create_new_client(vsock, 0);\n\topenssl_last_helper_pid = 0;\n\n\tif (client) {\n\t\tint swt = 0;\n\t\tif (mode == OPENSSL_VNC6 && openssl_last_ip != NULL) {\n\t\t\tswt = 1;\n\t\t} else if (mode == OPENSSL_REVERSE && ipv6_name != NULL && openssl_last_ip != NULL) {\n\t\t\tswt = 1;\n\t\t}\n\t\tif (swt) {\n\t\t\tif (client->host) {\n\t\t\t\tfree(client->host);\n\t\t\t}\n\t\t\tclient->host = strdup(openssl_last_ip);\n\t\t}\n\t\tif (db) fprintf(stderr, \"accept_openssl: client %p\\n\", (void *) client);\n\t\tif (db) fprintf(stderr, \"accept_openssl: new_client %p\\n\", (void *) screen->newClientHook);\n\t\tif (db) fprintf(stderr, \"accept_openssl: new_client %p\\n\", (void *) new_client);\n\t\tif (mode == OPENSSL_INETD) {\n\t\t\tinetd_client = client;\n\t\t\tclient->clientGoneHook = client_gone;\n\t\t}\n\t\tif (openssl_last_ip &&\n\t\t    strpbrk(openssl_last_ip, \"0123456789\") == openssl_last_ip) {\n\t\t\tclient->host = strdup(openssl_last_ip);\n\t\t}\n\t\tif (vencrypt_sel != 0) {\n\t\t\tclient->protocolMajorVersion = 3;\n\t\t\tclient->protocolMinorVersion = 8;\n#if LIBVNCSERVER_HAVE_LIBSSL || HAVE_LIBSSL \n\t\t\tif (!finish_vencrypt_auth(client, vencrypt_sel)) {\n\t\t\t\trfbCloseClient(client);\n\t\t\t\tclient = NULL;\n\t\t\t}\n#else\n\t\t\tbadnews(\"3 accept_openssl\");\n#endif\n\t\t} else if (anontls_sel != 0) {\n\t\t\tclient->protocolMajorVersion = 3;\n\t\t\tclient->protocolMinorVersion = 8;\n\t\t\trfbAuthNewClient(client);\n\t\t}\n\t\tif (use_threads && client != NULL) {\n\t\t\trfbStartOnHoldClient(client);\n\t\t}\n\t\t/* try to get RFB proto done now. */\n\t\tprogress_client();\n\t} else {\n\t\trfbLog(\"SSL: accept_openssl: rfbNewClient failed.\\n\");\n\t\tclose(vsock);\n\n\t\tkill(pid, SIGTERM);\n\t\twaitpid(pid, &status, WNOHANG); \n\t\tif (mode == OPENSSL_INETD || ssl_no_fail) {\n\t\t\tclean_up_exit(1);\n\t\t}\n\t\treturn;\n\t}\n}",
          "includes": [
            "#include <openssl/rand.h>",
            "#include <openssl/err.h>",
            "#include <openssl/ssl.h>",
            "#include \"user.h\"",
            "#include \"unixpw.h\"",
            "#include \"sslcmds.h\"",
            "#include \"connections.h\"",
            "#include \"scan.h\"",
            "#include \"screen.h\"",
            "#include \"cleanup.h\"",
            "#include \"inet.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [
            "#define HAVE_LIBSSL 0",
            "#define LIBVNCSERVER_HAVE_LIBSSL 0",
            "#define ABSIZE 16384",
            "#define OPENSSL_REVERSE 6",
            "#define OPENSSL_HTTPS6  5",
            "#define OPENSSL_HTTPS   4",
            "#define OPENSSL_VNC6    3",
            "#define OPENSSL_VNC     2",
            "#define OPENSSL_INETD   1"
          ],
          "globals_used": [
            "int openssl_sock = -1;",
            "int openssl_sock6 = -1;",
            "int https_sock = -1;",
            "int https_sock6 = -1;",
            "pid_t openssl_last_helper_pid = 0;",
            "char *openssl_last_ip = NULL;",
            "static char *certret = NULL;",
            "static int certret_fd = -1;",
            "static mode_t omode;",
            "char *certret_str = NULL;",
            "static char *dhret = NULL;",
            "static int dhret_fd = -1;",
            "char *dhret_str = NULL;",
            "char *new_dh_params = NULL;",
            "void raw_xfer(int csock, int s_in, int s_out);",
            "static char *get_input(char *tag, char **in);",
            "void ssl_helper_pid(pid_t pid, int sock);",
            "void accept_openssl(int mode, int presock);",
            "static void lose_ram(void);",
            "static int vencrypt_selected = 0;",
            "static int anontls_selected = 0;",
            "static int csock_timeout_sock = -1;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <openssl/rand.h>\n#include <openssl/err.h>\n#include <openssl/ssl.h>\n#include \"user.h\"\n#include \"unixpw.h\"\n#include \"sslcmds.h\"\n#include \"connections.h\"\n#include \"scan.h\"\n#include \"screen.h\"\n#include \"cleanup.h\"\n#include \"inet.h\"\n#include \"x11vnc.h\"\n\n#define HAVE_LIBSSL 0\n#define LIBVNCSERVER_HAVE_LIBSSL 0\n#define ABSIZE 16384\n#define OPENSSL_REVERSE 6\n#define OPENSSL_HTTPS6  5\n#define OPENSSL_HTTPS   4\n#define OPENSSL_VNC6    3\n#define OPENSSL_VNC     2\n#define OPENSSL_INETD   1\n\nint openssl_sock = -1;\nint openssl_sock6 = -1;\nint https_sock = -1;\nint https_sock6 = -1;\npid_t openssl_last_helper_pid = 0;\nchar *openssl_last_ip = NULL;\nstatic char *certret = NULL;\nstatic int certret_fd = -1;\nstatic mode_t omode;\nchar *certret_str = NULL;\nstatic char *dhret = NULL;\nstatic int dhret_fd = -1;\nchar *dhret_str = NULL;\nchar *new_dh_params = NULL;\nvoid raw_xfer(int csock, int s_in, int s_out);\nstatic char *get_input(char *tag, char **in);\nvoid ssl_helper_pid(pid_t pid, int sock);\nvoid accept_openssl(int mode, int presock);\nstatic void lose_ram(void);\nstatic int vencrypt_selected = 0;\nstatic int anontls_selected = 0;\nstatic int csock_timeout_sock = -1;\n\nvoid accept_openssl(int mode, int presock) {\n\tint sock = -1, listen = -1, cport, csock, vsock;\t\n\tint peerport = 0;\n\tint status, n, i, db = 0;\n\tstruct sockaddr_in addr;\n#ifdef __hpux\n\tint addrlen = sizeof(addr);\n#else\n\tsocklen_t addrlen = sizeof(addr);\n#endif\n\trfbClientPtr client;\n\tpid_t pid;\n\tchar uniq[] = \"_evilrats_\";\n\tchar cookie[256], rcookie[256], *name = NULL;\n\tint vencrypt_sel = 0;\n\tint anontls_sel = 0;\n\tchar *ipv6_name = NULL;\n\tstatic double last_https = 0.0;\n\tstatic char last_get[256];\n\tstatic int first = 1;\n\tunsigned char *rb;\n\n#if !LIBVNCSERVER_HAVE_LIBSSL && !HAVE_LIBSSL  \n\tif (enc_str == NULL || strcmp(enc_str, \"none\")) {\n\t\tbadnews(\"0 accept_openssl\");\n\t}\n#endif\n\n\topenssl_last_helper_pid = 0;\n\n\t/* zero buffers for use below. */\n\tfor (i=0; i<256; i++) {\n\t\tif (first) {\n\t\t\tlast_get[i] = '\\0';\n\t\t}\n\t\tcookie[i]  = '\\0';\n\t\trcookie[i] = '\\0';\n\t}\n\tfirst = 0;\n\n\tif (getenv(\"ACCEPT_OPENSSL_DEBUG\")) {\n\t\tdb = atoi(getenv(\"ACCEPT_OPENSSL_DEBUG\"));\n\t}\n\n\t/* do INETD, VNC, or HTTPS cases (result is client socket or pipe) */\n\tif (mode == OPENSSL_INETD) {\n\t\tssl_initialized = 1;\n\n\t} else if (mode == OPENSSL_VNC) {\n\t\tsock = accept(openssl_sock, (struct sockaddr *)&addr, &addrlen);\n\t\tif (sock < 0)  {\n\t\t\trfbLog(\"SSL: accept_openssl: accept connection failed\\n\");\n\t\t\trfbLogPerror(\"accept\");\n\t\t\tif (ssl_no_fail) {\n\t\t\t\tclean_up_exit(1);\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t\tlisten = openssl_sock;\n\n\t} else if (mode == OPENSSL_VNC6 || mode == OPENSSL_HTTPS6) {\n#if X11VNC_IPV6\n\t\tstruct sockaddr_in6 a6;\n\t\tsocklen_t a6len = sizeof(a6);\n\t\tint fd = (mode == OPENSSL_VNC6 ? openssl_sock6 : https_sock6); \n\n\t\tsock = accept(fd, (struct sockaddr *)&a6, &a6len);\n\t\tif (sock < 0)  {\n\t\t\trfbLog(\"SSL: accept_openssl: accept connection failed\\n\");\n\t\t\trfbLogPerror(\"accept\");\n\t\t\tif (ssl_no_fail) {\n\t\t\t\tclean_up_exit(1);\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t\tipv6_name = ipv6_getipaddr((struct sockaddr *)&a6, a6len);\n\t\tif (!ipv6_name) ipv6_name = strdup(\"unknown\");\n\t\tlisten = fd;\n#endif\n\t} else if (mode == OPENSSL_REVERSE) {\n\t\tsock = presock;\n\t\tif (sock < 0)  {\n\t\t\trfbLog(\"SSL: accept_openssl: connection failed\\n\");\n\t\t\tif (ssl_no_fail) {\n\t\t\t\tclean_up_exit(1);\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t\tif (getenv(\"OPENSSL_REVERSE_DEBUG\")) fprintf(stderr, \"OPENSSL_REVERSE: ipv6_client_ip_str: %s\\n\", ipv6_client_ip_str);\n\t\tif (ipv6_client_ip_str != NULL) {\n\t\t\tipv6_name = strdup(ipv6_client_ip_str);\n\t\t}\n\t\tlisten = -1;\n\n\t} else if (mode == OPENSSL_HTTPS) {\n\t\tsock = accept(https_sock, (struct sockaddr *)&addr, &addrlen);\n\t\tif (sock < 0)  {\n\t\t\trfbLog(\"SSL: accept_openssl: accept connection failed\\n\");\n\t\t\trfbLogPerror(\"accept\");\n\t\t\tif (ssl_no_fail) {\n\t\t\t\tclean_up_exit(1);\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t\tlisten = https_sock;\n\t}\n\tif (db) fprintf(stderr, \"SSL: accept_openssl: sock: %d\\n\", sock);\n\n\tif (openssl_last_ip) {\n\t\tfree(openssl_last_ip);\n\t\topenssl_last_ip = NULL;\n\t}\n\tif (mode == OPENSSL_INETD) {\n\t\topenssl_last_ip = get_remote_host(fileno(stdin));\n\t} else if (mode == OPENSSL_VNC6 || mode == OPENSSL_HTTPS6) {\n\t\topenssl_last_ip = ipv6_name;\n\t} else if (mode == OPENSSL_REVERSE && ipv6_name != NULL) {\n\t\topenssl_last_ip = ipv6_name;\n\t} else {\n\t\topenssl_last_ip = get_remote_host(sock);\n\t}\n\n\tif (!check_ssl_access(openssl_last_ip)) {\n\t\trfbLog(\"SSL: accept_openssl: denying client %s\\n\", openssl_last_ip);\n\t\trfbLog(\"SSL: accept_openssl: does not match -allow or other reason.\\n\");\n\t\tclose(sock);\n\t\tsock = -1;\n\t\tif (ssl_no_fail) {\n\t\t\tclean_up_exit(1);\n\t\t}\n\t\treturn;\n\t}\n\n\t/* now make a listening socket for child to connect back to us by: */\n\n\tcport = find_free_port(20000, 22000);\n\tif (! cport && ipv6_listen) {\n\t\trfbLog(\"SSL: accept_openssl: seeking IPv6 port.\\n\");\n\t\tcport = find_free_port6(20000, 22000);\n\t\trfbLog(\"SSL: accept_openssl: IPv6 port: %d\\n\", cport);\n\t}\n\tif (! cport) {\n\t\trfbLog(\"SSL: accept_openssl: could not find open port.\\n\");\n\t\tclose(sock);\n\t\tif (mode == OPENSSL_INETD || ssl_no_fail) {\n\t\t\tclean_up_exit(1);\n\t\t}\n\t\treturn;\n\t}\n\tif (db) fprintf(stderr, \"accept_openssl: cport: %d\\n\", cport);\n\n\tcsock = listen_tcp(cport, htonl(INADDR_LOOPBACK), 1);\n\n\tif (csock < 0) {\n\t\trfbLog(\"SSL: accept_openssl: could not listen on port %d.\\n\",\n\t\t    cport);\n\t\tclose(sock);\n\t\tif (mode == OPENSSL_INETD || ssl_no_fail) {\n\t\t\tclean_up_exit(1);\n\t\t}\n\t\treturn;\n\t}\n\tif (db) fprintf(stderr, \"accept_openssl: csock: %d\\n\", csock);\n\n\tfflush(stderr);\n\n\t/*\n\t * make a simple cookie to id the child socket, not foolproof\n\t * but hard to guess exactly (just worrying about local lusers\n\t * here, since we use INADDR_LOOPBACK).\n\t */\n\trb = (unsigned char *) calloc(6, 1);\n#if LIBVNCSERVER_HAVE_LIBSSL || HAVE_LIBSSL \n\tRAND_bytes(rb, 6);\n#endif\n\tsprintf(cookie, \"RB=%d%d%d%d%d%d/%f%f/%p\",\n\t    rb[0], rb[1], rb[2], rb[3], rb[4], rb[5],\n            dnow() - x11vnc_start, x11vnc_start, (void *)rb);\n\n\tif (mode == OPENSSL_VNC6) {\n\t\tname = strdup(ipv6_name);\n\t\tpeerport = get_remote_port(sock);\n\t} else if (mode == OPENSSL_REVERSE && ipv6_name != NULL) {\n\t\tname = strdup(ipv6_name);\n\t\tpeerport = get_remote_port(sock);\n\t} else if (mode != OPENSSL_INETD) {\n\t\tname = get_remote_host(sock);\n\t\tpeerport = get_remote_port(sock);\n\t} else {\n\t\topenssl_last_ip = get_remote_host(fileno(stdin));\n\t\tpeerport = get_remote_port(fileno(stdin));\n\t\tif (openssl_last_ip) {\n\t\t\tname = strdup(openssl_last_ip);\n\t\t} else {\n\t\t\tname = strdup(\"unknown\");\n\t\t}\n\t}\n\tif (name) {\n\t\tif (mode == OPENSSL_INETD) {\n\t\t\trfbLog(\"SSL: (inetd) spawning helper process \"\n\t\t\t    \"to handle: %s:%d\\n\", name, peerport);\n\t\t} else {\n\t\t\trfbLog(\"SSL: spawning helper process to handle: \"\n\t\t\t    \"%s:%d\\n\", name, peerport);\n\t\t}\n\t\tfree(name);\n\t\tname = NULL;\n\t}\n\n\tif (certret) {\n\t\tfree(certret);\n\t}\n\tif (certret_str) {\n\t\tfree(certret_str);\n\t\tcertret_str = NULL;\n\t}\n\tcertret = strdup(\"/tmp/x11vnc-certret.XXXXXX\");\n\tomode = umask(077);\n\tcertret_fd = mkstemp(certret);\n\tumask(omode);\n\tif (certret_fd < 0) {\n\t\tfree(certret);\n\t\tcertret = NULL;\n\t\tcertret_fd = -1;\n\t}\n\n\tif (dhret) {\n\t\tfree(dhret);\n\t}\n\tif (dhret_str) {\n\t\tfree(dhret_str);\n\t\tdhret_str = NULL;\n\t}\n\tdhret = strdup(\"/tmp/x11vnc-dhret.XXXXXX\");\n\tomode = umask(077);\n\tdhret_fd = mkstemp(dhret);\n\tumask(omode);\n\tif (dhret_fd < 0) {\n\t\tfree(dhret);\n\t\tdhret = NULL;\n\t\tdhret_fd = -1;\n\t}\n\n\t/* now fork the child to handle the SSL: */\n\tpid = fork();\n\n\tif (pid > 0) {\n\t\trfbLog(\"SSL: helper for peerport %d is pid %d: \\n\",\n\t\t    peerport, (int) pid);\n\t}\n\n\tif (pid < 0) {\n\t\trfbLog(\"SSL: accept_openssl: could not fork.\\n\");\n\t\trfbLogPerror(\"fork\");\n\t\tclose(sock);\n\t\tclose(csock);\n\t\tif (mode == OPENSSL_INETD || ssl_no_fail) {\n\t\t\tclean_up_exit(1);\n\t\t}\n\t\treturn;\n\n\t} else if (pid == 0) {\n\t\tint s_in, s_out, httpsock = -1;\n\t\tint vncsock;\n\t\tint i, have_httpd = 0;\n\t\tint f_in  = fileno(stdin);\n\t\tint f_out = fileno(stdout);\n\t\tint skip_vnc_tls = mode == OPENSSL_HTTPS ? 1 : 0;\n\n\t\tif (db) fprintf(stderr, \"helper pid in: %d %d %d %d\\n\", f_in, f_out, sock, listen);\n\n\t\t/* reset all handlers to default (no interrupted() calls) */\n\t\tunset_signals();\n\n\t\t/* close all non-essential fd's */\n\t\tfor (i=0; i<256; i++) {\n\t\t\tif (mode == OPENSSL_INETD) {\n\t\t\t\tif (i == f_in || i == f_out) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (i == sock) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (i == 2) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tclose(i);\n\t\t}\n\n\t\t/*\n\t\t * sadly, we are a long lived child and so the large\n\t\t * framebuffer memory areas will soon differ from parent.\n\t\t * try to free as much as possible.\n\t\t */\n\t\tlose_ram();\n\n\t\t/* now connect back to parent socket: */\n\t\tvncsock = connect_tcp(\"127.0.0.1\", cport);\n\t\tif (vncsock < 0) {\n\t\t\trfbLog(\"SSL: ssl_helper[%d]: could not connect\"\n\t\t\t    \" back to: %d\\n\", getpid(), cport);\n\t\t\trfbLog(\"SSL: ssl_helper[%d]: exit case 1 (no local vncsock)\\n\", getpid());\n\t\t\texit(1);\n\t\t}\n\t\tif (db) fprintf(stderr, \"vncsock %d\\n\", vncsock);\n\n\t\t/* try to initialize SSL with the remote client */\n\n\t\tif (mode == OPENSSL_INETD) {\n\t\t\ts_in  = fileno(stdin);\n\t\t\ts_out = fileno(stdout);\n\t\t} else {\n\t\t\ts_in = s_out = sock;\n\t\t}\n\n\t\tif (! ssl_init(s_in, s_out, skip_vnc_tls, last_https)) {\n\t\t\tclose(vncsock);\n\t\t\trfbLog(\"SSL: ssl_helper[%d]: exit case 2 (ssl_init failed)\\n\", getpid());\n\t\t\texit(1);\n\t\t}\n\n\t\tif (vencrypt_selected != 0) {\n\t\t\tchar *tbuf;\n\t\t\ttbuf = (char *) malloc(strlen(cookie) + 100);\n\t\t\tsprintf(tbuf, \"%s,VENCRYPT=%d,%s\", uniq, vencrypt_selected, cookie);\n\t\t\twrite(vncsock, tbuf, strlen(cookie));\n\t\t\tgoto wrote_cookie;\n\t\t} else if (anontls_selected != 0) {\n\t\t\tchar *tbuf;\n\t\t\ttbuf = (char *) malloc(strlen(cookie) + 100);\n\t\t\tsprintf(tbuf, \"%s,ANONTLS=%d,%s\", uniq, anontls_selected, cookie);\n\t\t\twrite(vncsock, tbuf, strlen(cookie));\n\t\t\tgoto wrote_cookie;\n\t\t}\n\n\t\t/*\n\t\t * things get messy below since we are trying to do\n\t\t * *both* VNC and Java applet httpd through the same\n\t\t * SSL socket.\n\t\t */\n\n\t\tif (! screen) {\n\t\t\tclose(vncsock);\n\t\t\texit(1);\n\t\t}\n\t\tif (screen->httpListenSock >= 0 && screen->httpPort > 0) {\n\t\t\thave_httpd = 1;\n\t\t} else if (ipv6_http_fd >= 0) {\n\t\t\thave_httpd = 1;\n\t\t} else if (screen->httpListenSock == -2) {\n\t\t\thave_httpd = 1;\n\t\t}\n\t\tif (mode == OPENSSL_HTTPS && ! have_httpd) {\n\t\t\trfbLog(\"SSL: accept_openssl[%d]: no httpd socket for \"\n\t\t\t    \"-https mode\\n\", getpid());\n\t\t\tclose(vncsock);\n\t\t\trfbLog(\"SSL: ssl_helper[%d]: exit case 3 (no httpd sock)\\n\", getpid());\n\t\t\texit(1);\n\t\t}\n\n\t\tif (have_httpd) {\n\t\t\tint n = 0, is_http = 0;\n\t\t\tint hport = screen->httpPort; \n\t\t\tchar *iface = NULL;\n\t\t\tchar *buf, *tbuf;\n\n\t\t\tbuf  = (char *) calloc((ABSIZE+1), 1);\n\t\t\ttbuf = (char *) calloc((2*ABSIZE+1), 1);\n\n\t\t\tif (mode == OPENSSL_HTTPS) {\n\t\t\t\t/*\n\t\t\t\t * for this mode we know it is HTTP traffic\n\t\t\t\t * so we skip trying to guess.\n\t\t\t\t */\n\t\t\t\tis_http = 1;\n\t\t\t\tn = 0;\n\t\t\t\tgoto connect_to_httpd;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * Check if there is stuff to read from remote end\n\t\t\t * if so it is likely a GET or HEAD.\n\t\t\t */\n\t\t\tif (! is_ssl_readable(s_in, last_https, last_get,\n\t\t\t    mode)) {\n\t\t\t\tgoto write_cookie;\n\t\t\t}\n\t\n\t\t\t/* \n\t\t\t * read first 2 bytes to try to guess.  sadly,\n\t\t\t * the user is often pondering a \"non-verified\n\t\t\t * cert\" dialog for a long time before the GET\n\t\t\t * is ever sent.  So often we timeout here.\n\t\t\t */\n\n\t\t\tif (db) fprintf(stderr, \"watch_for_http_traffic\\n\");\n\n\t\t\tis_http = watch_for_http_traffic(buf, &n, s_in);\n\n\t\t\tif (is_http < 0 || is_http == 0) {\n\t\t\t\t/*\n\t\t\t\t * error or http not detected, fall back\n\t\t\t\t * to normal VNC socket.\n\t\t\t\t */\n\t\t\t\tif (db) fprintf(stderr, \"is_http err: %d n: %d\\n\", is_http, n);\n\t\t\t\twrite(vncsock, cookie, strlen(cookie));\n\t\t\t\tif (n > 0) {\n\t\t\t\t\twrite(vncsock, buf, n);\n\t\t\t\t}\n\t\t\t\tgoto wrote_cookie;\n\t\t\t}\n\n\t\t\tif (db) fprintf(stderr, \"is_http: %d n: %d\\n\",\n\t\t\t    is_http, n);\n\t\t\tif (db) fprintf(stderr, \"buf: '%s'\\n\", buf);\n\n\t\t\tif (strstr(buf, \"/request.https.vnc.connection\")) {\n\t\t\t\tchar reply[] = \"HTTP/1.0 200 OK\\r\\n\"\n\t\t\t\t    \"Content-Type: octet-stream\\r\\n\"\n\t\t\t\t    \"Connection: Keep-Alive\\r\\n\"\n\t\t\t\t    \"VNC-Server: x11vnc\\r\\n\"\n\t\t\t\t    \"Pragma: no-cache\\r\\n\\r\\n\";\n\t\t\t\t/*\n\t\t\t\t * special case proxy coming thru https\n\t\t\t\t * instead of a direct SSL connection.\n\t\t\t\t */\n\t\t\t\trfbLog(\"Handling VNC request via https GET. [%d]\\n\", getpid());\n\t\t\t\trfbLog(\"-- %s\\n\", buf);\n\n\t\t\t\tif (strstr(buf, \"/reverse.proxy\")) {\n\t\t\t\t\tchar *buf2;\n\t\t\t\t\tint n, ptr;\n#if !LIBVNCSERVER_HAVE_LIBSSL && !HAVE_LIBSSL \n\t\t\t\t\twrite(s_out, reply, strlen(reply));\n#else\n\t\t\t\t\tSSL_write(ssl, reply, strlen(reply));\n#endif\n\t\t\t\t\n\t\t\t\t\tbuf2  = (char *) calloc((8192+1), 1);\n\t\t\t\t\tn = 0;\n\t\t\t\t\tptr = 0;\n\t\t\t\t\twhile (ptr < 8192) {\n#if !LIBVNCSERVER_HAVE_LIBSSL && !HAVE_LIBSSL \n\t\t\t\t\t\tn = read(s_in, buf2 + ptr, 1);\n#else\n\t\t\t\t\t\tn = SSL_read(ssl, buf2 + ptr, 1);\n#endif\n\t\t\t\t\t\tif (n > 0) {\n\t\t\t\t\t\t\tptr += n;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (db) fprintf(stderr, \"buf2: '%s'\\n\", buf2);\n\n\t\t\t\t\t\tif (strstr(buf2, \"\\r\\n\\r\\n\")) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tfree(buf2);\n\t\t\t\t}\n\t\t\t\tgoto write_cookie;\n\n\t\t\t} else if (strstr(buf, \"/check.https.proxy.connection\")) {\n\t\t\t\tchar reply[] = \"HTTP/1.0 200 OK\\r\\n\"\n\t\t\t\t    \"Connection: close\\r\\n\"\n\t\t\t\t    \"Content-Type: octet-stream\\r\\n\"\n\t\t\t\t    \"VNC-Server: x11vnc\\r\\n\"\n\t\t\t\t    \"Pragma: no-cache\\r\\n\\r\\n\";\n\n\t\t\t\trfbLog(\"Handling Check HTTPS request via https GET. [%d]\\n\", getpid());\n\t\t\t\trfbLog(\"-- %s\\n\", buf);\n\n#if !LIBVNCSERVER_HAVE_LIBSSL && !HAVE_LIBSSL \n\t\t\t\twrite(s_out, reply, strlen(reply));\n#else\n\t\t\t\tSSL_write(ssl, reply, strlen(reply));\n\t\t\t\tSSL_shutdown(ssl);\n#endif\n\n\t\t\t\tstrcpy(tbuf, uniq);\n\t\t\t\tstrcat(tbuf, cookie);\n\t\t\t\twrite(vncsock, tbuf, strlen(tbuf));\n\t\t\t\tclose(vncsock);\n\n\t\t\t\trfbLog(\"SSL: ssl_helper[%d]: exit case 4 (check.https.proxy.connection)\\n\", getpid());\n\t\t\t\texit(0);\n\t\t\t}\n\t\t\tconnect_to_httpd:\n\n\t\t\t/*\n\t\t\t * Here we go... no turning back.  we have to\n\t\t\t * send failure to parent and close socket to have\n\t\t\t * http processed at all in a timely fashion...\n\t\t\t */\n\n\t\t\t/* send the failure tag: */\n\t\t\tstrcpy(tbuf, uniq);\n\n\t\t\tif (https_port_redir < 0 || (strstr(buf, \"PORT=\") || strstr(buf, \"port=\"))) {\n\t\t\t\tchar *q = strstr(buf, \"Host:\");\n\t\t\t\tint fport = 443, match = 0;\n\t\t\t\tchar num[16];\n\n\t\t\t\tif (q && strstr(q, \"\\n\")) {\n\t\t\t\t    q += strlen(\"Host:\") + 1;\n\t\t\t\t    while (*q != '\\n') {\n\t\t\t\t\tint p;\n\t\t\t\t\tif (*q == ':' && sscanf(q, \":%d\", &p) == 1) {\n\t\t\t\t\t\tif (p > 0 && p < 65536) {\n\t\t\t\t\t\t\tfport = p;\n\t\t\t\t\t\t\tmatch = 1;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tq++;\n\t\t\t\t    }\n\t\t\t\t}\n\t\t\t\tif (!match || !https_port_redir) {\n\t\t\t\t\tint p;\n\t\t\t\t\tif (sscanf(buf, \"PORT=%d,\", &p) == 1) {\n\t\t\t\t\t\tif (p > 0 && p < 65536) {\n\t\t\t\t\t\t\tfport = p;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else if (sscanf(buf, \"port=%d,\", &p) == 1) {\n\t\t\t\t\t\tif (p > 0 && p < 65536) {\n\t\t\t\t\t\t\tfport = p;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tsprintf(num, \"HP=%d,\", fport);\n\t\t\t\tstrcat(tbuf, num);\n\t\t\t}\n\n\t\t\tif (strstr(buf, \"HTTP/\") != NULL)  {\n\t\t\t\tchar *q, *str;\n\t\t\t\t/*\n\t\t\t\t * Also send back the GET line for heuristics.\n\t\t\t\t * (last_https, get file).\n\t\t\t\t */\n\t\t\t\tstr = strdup(buf);\n\t\t\t\tq = strstr(str, \"HTTP/\");\n\t\t\t\tif (q != NULL) {\n\t\t\t\t\t*q = '\\0';\t\n\t\t\t\t\tstrcat(tbuf, str);\n\t\t\t\t}\n\t\t\t\tfree(str);\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * Also send the cookie to pad out the number of\n\t\t\t * bytes to more than the parent wants to read.\n\t\t\t * Since this is the failure case, it does not\n\t\t\t * matter that we send more than strlen(cookie).\n\t\t\t */\n\t\t\tstrcat(tbuf, cookie);\n\t\t\twrite(vncsock, tbuf, strlen(tbuf));\n\n\t\t\tusleep(150*1000);\n\t\t\tif (db) fprintf(stderr, \"close vncsock: %d\\n\", vncsock);\n\t\t\tclose(vncsock);\n\n\t\t\t/* now, finally, connect to the libvncserver httpd: */\n\t\t\tif (screen->listenInterface == htonl(INADDR_ANY) ||\n\t\t\t    screen->listenInterface == htonl(INADDR_NONE)) {\n\t\t\t\tiface = \"127.0.0.1\";\n\t\t\t} else {\n\t\t\t\tstruct in_addr in;\n\t\t\t\tin.s_addr = screen->listenInterface;\n\t\t\t\tiface = inet_ntoa(in);\n\t\t\t}\n\t\t\tif (iface == NULL || !strcmp(iface, \"\")) {\n\t\t\t\tiface = \"127.0.0.1\";\n\t\t\t}\n\t\t\tif (db) fprintf(stderr, \"iface: %s:%d\\n\", iface, hport);\n\t\t\tusleep(150*1000);\n\n\t\t\thttpsock = connect_tcp(iface, hport);\n\n\t\t\tif (httpsock < 0) {\n\t\t\t\t/* UGH, after all of that! */\n\t\t\t\trfbLog(\"Could not connect to httpd socket!\\n\");\n\t\t\t\trfbLog(\"SSL: ssl_helper[%d]: exit case 5.\\n\", getpid());\n\t\t\t\texit(1);\n\t\t\t}\n\t\t\tif (db) fprintf(stderr, \"ssl_helper[%d]: httpsock: %d %d\\n\",\n\t\t\t    getpid(), httpsock, n);\n\n\t\t\t/*\n\t\t\t * send what we read to httpd, and then connect\n\t\t\t * the rest of the SSL session to it:\n\t\t\t */\n\t\t\tif (n > 0) {\n\t\t\t\tchar *s = getenv(\"X11VNC_EXTRA_HTTPS_PARAMS\");\n\t\t\t\tint did_extra = 0;\n\n\t\t\t\tif (db) fprintf(stderr, \"sending http buffer httpsock: %d n=%d\\n'%s'\\n\", httpsock, n, buf);\n\t\t\t\tif (s != NULL) {\n\t\t\t\t\tchar *q = strstr(buf, \" HTTP/\");\n\t\t\t\t\tif (q) {\n\t\t\t\t\t\tint m;\n\t\t\t\t\t\t*q = '\\0';\n\t\t\t\t\t\tm = strlen(buf);\n\t\t\t\t\t\twrite(httpsock, buf, m);\n\t\t\t\t\t\twrite(httpsock, s, strlen(s));\n\t\t\t\t\t\t*q = ' ';\n\t\t\t\t\t\twrite(httpsock, q, n-m);\n\t\t\t\t\t\tdid_extra = 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (!did_extra) {\n\t\t\t\t\twrite(httpsock, buf, n);\n\t\t\t\t}\n\t\t\t}\n\t\t\tssl_xfer(httpsock, s_in, s_out, is_http);\n\t\t\trfbLog(\"SSL: ssl_helper[%d]: exit case 6 (https ssl_xfer done)\\n\", getpid());\n\t\t\texit(0);\n\t\t}\n\n\t\t/*\n\t\t * ok, back from the above https mess, simply send the\n\t\t * cookie back to the parent (who will attach us to\n\t\t * libvncserver), and connect the rest of the SSL session\n\t\t * to it.\n\t\t */\n\t\twrite_cookie:\n\t\twrite(vncsock, cookie, strlen(cookie));\n\n\t\twrote_cookie:\n\t\tssl_xfer(vncsock, s_in, s_out, 0);\n\t\trfbLog(\"SSL: ssl_helper[%d]: exit case 7 (ssl_xfer done)\\n\", getpid());\n\t\tif (0) usleep(50 * 1000);\n\t\texit(0);\n\t}\n\t/* parent here */\n\n\tif (mode != OPENSSL_INETD) {\n\t\tclose(sock);\n\t}\n\tif (db) fprintf(stderr, \"helper process is: %d\\n\", pid);\n\n\t/* accept connection from our child.  */\n\tsignal(SIGALRM, csock_timeout);\n\tcsock_timeout_sock = csock;\n\talarm(20);\n\n\tvsock = accept(csock, (struct sockaddr *)&addr, &addrlen);\n\n\talarm(0);\n\tsignal(SIGALRM, SIG_DFL);\n\tclose(csock);\n\n\n\tif (vsock < 0) {\n\t\trfbLog(\"SSL: accept_openssl: connection from ssl_helper[%d] FAILED.\\n\", pid);\n\t\trfbLogPerror(\"accept\");\n\n\t\tkill(pid, SIGTERM);\n\t\twaitpid(pid, &status, WNOHANG); \n\t\tif (mode == OPENSSL_INETD || ssl_no_fail) {\n\t\t\tclean_up_exit(1);\n\t\t}\n\t\tif (certret_fd >= 0) {\n\t\t\tclose(certret_fd);\n\t\t\tcertret_fd = -1;\n\t\t}\n\t\tif (certret) {\n\t\t\tunlink(certret);\n\t\t}\n\t\tif (dhret_fd >= 0) {\n\t\t\tclose(dhret_fd);\n\t\t\tdhret_fd = -1;\n\t\t}\n\t\tif (dhret) {\n\t\t\tunlink(dhret);\n\t\t}\n\t\treturn;\n\t}\n\tif (db) fprintf(stderr, \"accept_openssl: vsock: %d\\n\", vsock);\n\n\tn = read(vsock, rcookie, strlen(cookie));\n\tif (n < 0 && errno != 0) {\n\t\trfbLogPerror(\"read\");\n\t}\n\n\tif (certret) {\n\t\tstruct stat sbuf;\n\t\tsbuf.st_size = 0;\n\t\tif (certret_fd >= 0 && stat(certret, &sbuf) == 0 && sbuf.st_size > 0) {\n\t\t\tcertret_str = (char *) calloc(sbuf.st_size+1, 1);\n\t\t\tread(certret_fd, certret_str, sbuf.st_size);\n\t\t\tclose(certret_fd);\n\t\t\tcertret_fd = -1;\n\t\t}\n\t\tif (certret_fd >= 0) {\n\t\t\tclose(certret_fd);\n\t\t\tcertret_fd = -1;\n\t\t}\n\t\tunlink(certret);\n\t\tif (certret_str && strstr(certret_str, \"NOCERT\") == certret_str) {\n\t\t\tfree(certret_str);\n\t\t\tcertret_str = NULL;\n\t\t}\n\t\tif (0 && certret_str) {\n\t\t\tfprintf(stderr, \"certret_str[%d]:\\n%s\\n\", (int) sbuf.st_size, certret_str);\n\t\t}\n\t}\n\n\tif (dhret) {\n\t\tstruct stat sbuf;\n\t\tsbuf.st_size = 0;\n\t\tif (dhret_fd >= 0 && stat(dhret, &sbuf) == 0 && sbuf.st_size > 0) {\n\t\t\tdhret_str = (char *) calloc(sbuf.st_size+1, 1);\n\t\t\tread(dhret_fd, dhret_str, sbuf.st_size);\n\t\t\tclose(dhret_fd);\n\t\t\tdhret_fd = -1;\n\t\t}\n\t\tif (dhret_fd >= 0) {\n\t\t\tclose(dhret_fd);\n\t\t\tdhret_fd = -1;\n\t\t}\n\t\tunlink(dhret);\n\t\tif (dhret_str && strstr(dhret_str, \"NOCERT\") == dhret_str) {\n\t\t\tfree(dhret_str);\n\t\t\tdhret_str = NULL;\n\t\t}\n\t\tif (dhret_str) {\n\t\t\tif (new_dh_params == NULL) {\n\t\t\t\tfprintf(stderr, \"dhret_str[%d]:\\n%s\\n\", (int) sbuf.st_size, dhret_str);\n\t\t\t\tnew_dh_params = strdup(dhret_str);\n\t\t\t}\n\t\t}\n\t}\n\n\tif (0) {\n\t\tfprintf(stderr, \"rcookie: %s\\n\", rcookie);\n\t\tfprintf(stderr, \"cookie:  %s\\n\", cookie);\n\t}\n\n\tif (strstr(rcookie, uniq) == rcookie) {\n\t\tchar *q = strstr(rcookie, \"RB=\");\n\t\tif (q && strstr(cookie, q) == cookie) {\n\t\t\tvencrypt_sel = 0;\n\t\t\tanontls_sel = 0;\n\t\t\tq = strstr(rcookie, \"VENCRYPT=\");\n\t\t\tif (q && sscanf(q, \"VENCRYPT=%d,\", &vencrypt_sel) == 1) {\n\t\t\t\tif (vencrypt_sel != 0) {\n\t\t\t\t\trfbLog(\"SSL: VENCRYPT mode=%d accepted. helper[%d]\\n\", vencrypt_sel, pid);\n\t\t\t\t\tgoto accept_client;\n\t\t\t\t}\n\t\t\t}\n\t\t\tq = strstr(rcookie, \"ANONTLS=\");\n\t\t\tif (q && sscanf(q, \"ANONTLS=%d,\", &anontls_sel) == 1) {\n\t\t\t\tif (anontls_sel != 0) {\n\t\t\t\t\trfbLog(\"SSL: ANONTLS mode=%d accepted. helper[%d]\\n\", anontls_sel, pid);\n\t\t\t\t\tgoto accept_client;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tif (n != (int) strlen(cookie) || strncmp(cookie, rcookie, n)) {\n\t\trfbLog(\"SSL: accept_openssl: cookie from ssl_helper[%d] FAILED. %d\\n\", pid, n);\n\t\tif (db) fprintf(stderr, \"'%s'\\n'%s'\\n\", cookie, rcookie);\n\t\tclose(vsock);\n\n\t\tif (strstr(rcookie, uniq) == rcookie) {\n\t\t\tint i;\n\t\t\tdouble https_download_wait_time = 15.0;\n\n\t\t\tif (getenv(\"X11VNC_HTTPS_DOWNLOAD_WAIT_TIME\")) {\n\t\t\t\thttps_download_wait_time = atof(getenv(\"X11VNC_HTTPS_DOWNLOAD_WAIT_TIME\"));\n\t\t\t}\n\n\t\t\trfbLog(\"SSL: BUT WAIT! HTTPS for helper process[%d] succeeded. Good.\\n\", pid);\n\t\t\tif (mode != OPENSSL_HTTPS) {\n\t\t\t\tlast_https = dnow();\n\t\t\t\tfor (i=0; i<256; i++) {\n\t\t\t\t\tlast_get[i] = '\\0';\n\t\t\t\t}\n\t\t\t\tstrncpy(last_get, rcookie, 100);\n\t\t\t\tif (db) fprintf(stderr, \"last_get: '%s'\\n\", last_get);\n\t\t\t}\n\t\t\tif (rcookie && strstr(rcookie, \"VncViewer.class\")) {\n\t\t\t\trfbLog(\"\\n\");\n\t\t\t\trfbLog(\"helper[%d]:\\n\", pid);\n\t\t\t\trfbLog(\"***********************************************************\\n\");\n\t\t\t\trfbLog(\"SSL: WARNING CLIENT ASKED FOR NONEXISTENT 'VncViewer.class'\\n\");\n\t\t\t\trfbLog(\"SSL: USER NEEDS TO MAKE SURE THE JAVA PLUGIN IS INSTALLED\\n\");\n\t\t\t\trfbLog(\"SSL: AND WORKING PROPERLY (e.g. a test-java-plugin page.)\\n\");\n\t\t\t\trfbLog(\"SSL: AND/OR USER NEEDS TO **RESTART** HIS WEB BROWSER.\\n\");\n\t\t\t\trfbLog(\"SSL: SOMETIMES THE BROWSER 'REMEMBERS' FAILED APPLET DOWN-\\n\");\n\t\t\t\trfbLog(\"SSL: LOADS AND RESTARTING IT IS THE ONLY WAY TO FIX THINGS.\\n\");\n\t\t\t\trfbLog(\"***********************************************************\\n\");\n\t\t\t\trfbLog(\"\\n\");\n\t\t\t}\n\t\t\tssl_helper_pid(pid, -2);\n\n\t\t\tif (https_port_redir) {\n\t\t\t\tdouble start;\n\t\t\t\tint origport = screen->port;\n\t\t\t\tint useport = screen->port;\n\t\t\t\tint saw_httpsock = 0;\n\t\t\t\t/* to expand $PORT correctly in index.vnc */\n\t\t\t\tif (https_port_redir < 0) {\n\t\t\t\t\tchar *q = strstr(rcookie, \"HP=\");\n\t\t\t\t\tif (q) {\n\t\t\t\t\t\tint p;\n\t\t\t\t\t\tif (sscanf(q, \"HP=%d,\", &p) == 1) {\n\t\t\t\t\t\t\tuseport = p;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tuseport = https_port_redir;\n\t\t\t\t}\n\t\t\t\tscreen->port = useport;\n\t\t\t\tif (origport != useport) {\n\t\t\t\t\trfbLog(\"SSL: -httpsredir guess port: %d  helper[%d]\\n\", screen->port, pid);\n\t\t\t\t}\n\n\t\t\t\tstart = dnow();\n\t\t\t\twhile (dnow() < start + https_download_wait_time) {\n\t\t\t\t\tif (screen->httpSock >= 0) saw_httpsock = 1;\n\t\t\t\t\trfbPE(10000);\n\t\t\t\t\tusleep(10000);\n\t\t\t\t\tif (screen->httpSock >= 0) saw_httpsock = 1;\n\t\t\t\t\twaitpid(pid, &status, WNOHANG); \n\t\t\t\t\tif (kill(pid, 0) != 0) {\n\t\t\t\t\t\trfbLog(\"SSL: helper[%d] pid finished\\n\", pid);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif (0 && saw_httpsock && screen->httpSock < 0) {\n\t\t\t\t\t\t/* this check can kill the helper too soon. */\n\t\t\t\t\t\trfbLog(\"SSL: httpSock for helper[%d] went away\\n\", pid);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\trfbLog(\"SSL: guessing child helper[%d] https finished. dt=%.6f\\n\",\n\t\t\t\t    pid, dnow() - start);\n\n\t\t\t\trfbPE(10000);\n\t\t\t\trfbPE(10000);\n\t\t\t\trfbPE(10000);\n\n\t\t\t\tscreen->port = origport;\n\t\t\t\tssl_helper_pid(0, -2);\n\t\t\t\tif (mode == OPENSSL_INETD) {\n\t\t\t\t\tclean_up_exit(1);\n\t\t\t\t}\n\t\t\t} else if (mode == OPENSSL_INETD) {\n\t\t\t\tdouble start;\n\t\t\t\tint saw_httpsock = 0;\n\n\t\t\t\t/* to expand $PORT correctly in index.vnc */\n\t\t\t\tif (screen->port == 0) {\n\t\t\t\t\tint fd = fileno(stdin);\n\t\t\t\t\tif (getenv(\"X11VNC_INETD_PORT\")) {\n\t\t\t\t\t\t/* mutex */\n\t\t\t\t\t\tscreen->port = atoi(getenv(\n\t\t\t\t\t\t    \"X11VNC_INETD_PORT\"));\n\t\t\t\t\t} else {\n\t\t\t\t\t\tint tport = get_local_port(fd);\n\t\t\t\t\t\tif (tport > 0) {\n\t\t\t\t\t\t\tscreen->port = tport;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\trfbLog(\"SSL: screen->port %d for helper[%d]\\n\", screen->port, pid);\n\n\t\t\t\t/* kludge for https fetch via inetd */\n\t\t\t\tstart = dnow();\n\t\t\t\twhile (dnow() < start + https_download_wait_time) {\n\t\t\t\t\tif (screen->httpSock >= 0) saw_httpsock = 1;\n\t\t\t\t\trfbPE(10000);\n\t\t\t\t\tusleep(10000);\n\t\t\t\t\tif (screen->httpSock >= 0) saw_httpsock = 1;\n\t\t\t\t\twaitpid(pid, &status, WNOHANG); \n\t\t\t\t\tif (kill(pid, 0) != 0) {\n\t\t\t\t\t\trfbLog(\"SSL: helper[%d] pid finished\\n\", pid);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif (0 && saw_httpsock && screen->httpSock < 0) {\n\t\t\t\t\t\t/* this check can kill the helper too soon. */\n\t\t\t\t\t\trfbLog(\"SSL: httpSock for helper[%d] went away\\n\", pid);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\trfbLog(\"SSL: OPENSSL_INETD guessing \"\n\t\t\t\t    \"child helper[%d] https finished. dt=%.6f\\n\",\n\t\t\t\t    pid, dnow() - start);\n\n\t\t\t\trfbPE(10000);\n\t\t\t\trfbPE(10000);\n\t\t\t\trfbPE(10000);\n\n\t\t\t\tssl_helper_pid(0, -2);\n\t\t\t\tclean_up_exit(1);\n\t\t\t}\n\t\t\t/* this will actually only get earlier https */\n\t\t\tssl_helper_pid(0, -2);\n\t\t\treturn;\n\t\t}\n\t\tkill(pid, SIGTERM);\n\t\twaitpid(pid, &status, WNOHANG); \n\t\tif (mode == OPENSSL_INETD || ssl_no_fail) {\n\t\t\tclean_up_exit(1);\n\t\t}\n\t\treturn;\n\t}\n\n\taccept_client:\n\n\tif (db) fprintf(stderr, \"accept_openssl: cookie good: %s\\n\", cookie);\n\n\trfbLog(\"SSL: handshake with helper process[%d] succeeded.\\n\", pid);\n\n\topenssl_last_helper_pid = pid;\n\tssl_helper_pid(pid, vsock);\n\n\tif (vnc_redirect) {\n\t\tvnc_redirect_sock = vsock;\n\t\topenssl_last_helper_pid = 0;\n\t\treturn;\n\t}\n\n\tclient = create_new_client(vsock, 0);\n\topenssl_last_helper_pid = 0;\n\n\tif (client) {\n\t\tint swt = 0;\n\t\tif (mode == OPENSSL_VNC6 && openssl_last_ip != NULL) {\n\t\t\tswt = 1;\n\t\t} else if (mode == OPENSSL_REVERSE && ipv6_name != NULL && openssl_last_ip != NULL) {\n\t\t\tswt = 1;\n\t\t}\n\t\tif (swt) {\n\t\t\tif (client->host) {\n\t\t\t\tfree(client->host);\n\t\t\t}\n\t\t\tclient->host = strdup(openssl_last_ip);\n\t\t}\n\t\tif (db) fprintf(stderr, \"accept_openssl: client %p\\n\", (void *) client);\n\t\tif (db) fprintf(stderr, \"accept_openssl: new_client %p\\n\", (void *) screen->newClientHook);\n\t\tif (db) fprintf(stderr, \"accept_openssl: new_client %p\\n\", (void *) new_client);\n\t\tif (mode == OPENSSL_INETD) {\n\t\t\tinetd_client = client;\n\t\t\tclient->clientGoneHook = client_gone;\n\t\t}\n\t\tif (openssl_last_ip &&\n\t\t    strpbrk(openssl_last_ip, \"0123456789\") == openssl_last_ip) {\n\t\t\tclient->host = strdup(openssl_last_ip);\n\t\t}\n\t\tif (vencrypt_sel != 0) {\n\t\t\tclient->protocolMajorVersion = 3;\n\t\t\tclient->protocolMinorVersion = 8;\n#if LIBVNCSERVER_HAVE_LIBSSL || HAVE_LIBSSL \n\t\t\tif (!finish_vencrypt_auth(client, vencrypt_sel)) {\n\t\t\t\trfbCloseClient(client);\n\t\t\t\tclient = NULL;\n\t\t\t}\n#else\n\t\t\tbadnews(\"3 accept_openssl\");\n#endif\n\t\t} else if (anontls_sel != 0) {\n\t\t\tclient->protocolMajorVersion = 3;\n\t\t\tclient->protocolMinorVersion = 8;\n\t\t\trfbAuthNewClient(client);\n\t\t}\n\t\tif (use_threads && client != NULL) {\n\t\t\trfbStartOnHoldClient(client);\n\t\t}\n\t\t/* try to get RFB proto done now. */\n\t\tprogress_client();\n\t} else {\n\t\trfbLog(\"SSL: accept_openssl: rfbNewClient failed.\\n\");\n\t\tclose(vsock);\n\n\t\tkill(pid, SIGTERM);\n\t\twaitpid(pid, &status, WNOHANG); \n\t\tif (mode == OPENSSL_INETD || ssl_no_fail) {\n\t\t\tclean_up_exit(1);\n\t\t}\n\t\treturn;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"wait_for_client: waiting for 2nd connection (Fetch Cert?)\\n\""
          ],
          "line": 1810
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "close",
          "args": [
            "vnc_redirect_sock"
          ],
          "line": 1808
        },
        "resolved": true,
        "details": {
          "function_name": "close_alarm",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/unixpw.c",
          "lines": "666-672",
          "snippet": "static void close_alarm (int sig) {\n\tif (slave_fd >= 0) {\n\t\tclose(slave_fd);\n\t}\n\talarm_fired = 1;\n\tif (0) sig = 0;\t/* compiler warning */\n}",
          "includes": [
            "#include <sys/stropts.h>",
            "#include <termios.h>",
            "#include <sys/ioctl.h>",
            "#include <shadow.h>",
            "#include \"default8x16.h\"",
            "#include \"rates.h\"",
            "#include \"cursor.h\"",
            "#include \"sslhelper.h\"",
            "#include \"connections.h\"",
            "#include \"user.h\"",
            "#include \"connections.h\"",
            "#include \"xinerama.h\"",
            "#include \"cleanup.h\"",
            "#include \"scan.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int slave_fd = -1, alarm_fired = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/stropts.h>\n#include <termios.h>\n#include <sys/ioctl.h>\n#include <shadow.h>\n#include \"default8x16.h\"\n#include \"rates.h\"\n#include \"cursor.h\"\n#include \"sslhelper.h\"\n#include \"connections.h\"\n#include \"user.h\"\n#include \"connections.h\"\n#include \"xinerama.h\"\n#include \"cleanup.h\"\n#include \"scan.h\"\n#include \"x11vnc.h\"\n\nstatic int slave_fd = -1, alarm_fired = 0;\n\nstatic void close_alarm (int sig) {\n\tif (slave_fd >= 0) {\n\t\tclose(slave_fd);\n\t}\n\talarm_fired = 1;\n\tif (0) sig = 0;\t/* compiler warning */\n}"
        }
      },
      {
        "call_info": {
          "callee": "read",
          "args": [
            "vnc_redirect_sock",
            "vnc_redirect_test",
            "1"
          ],
          "line": 1806
        },
        "resolved": true,
        "details": {
          "function_name": "read_exact",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/sslhelper.c",
          "lines": "1292-1317",
          "snippet": "static int read_exact(int sock, char *buf, int len) {\n\tint n, fail = 0;\n\tif (sock < 0) {\n\t\treturn 0;\n\t}\n\twhile (len > 0) {\n\t\tn = read(sock, buf, len);\n\t\tif (n > 0) {\n\t\t\tbuf += n;\n\t\t\tlen -= n;\n\t\t} else if (n == 0) {\n\t\t\tfail = 1;\n\t\t\tbreak;\n\t\t} else if (n < 0 && (errno == EAGAIN || errno == EWOULDBLOCK)) {\n\t\t\tusleep(10*1000);\n\t\t} else if (n < 0 && errno != EINTR) {\n\t\t\tfail = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (fail) {\n\t\treturn 0;\n\t} else {\n\t\treturn 1;\n\t}\n}",
          "includes": [
            "#include <openssl/rand.h>",
            "#include <openssl/err.h>",
            "#include <openssl/ssl.h>",
            "#include \"user.h\"",
            "#include \"unixpw.h\"",
            "#include \"sslcmds.h\"",
            "#include \"connections.h\"",
            "#include \"scan.h\"",
            "#include \"screen.h\"",
            "#include \"cleanup.h\"",
            "#include \"inet.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void ssl_helper_pid(pid_t pid, int sock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <openssl/rand.h>\n#include <openssl/err.h>\n#include <openssl/ssl.h>\n#include \"user.h\"\n#include \"unixpw.h\"\n#include \"sslcmds.h\"\n#include \"connections.h\"\n#include \"scan.h\"\n#include \"screen.h\"\n#include \"cleanup.h\"\n#include \"inet.h\"\n#include \"x11vnc.h\"\n\nvoid ssl_helper_pid(pid_t pid, int sock);\n\nstatic int read_exact(int sock, char *buf, int len) {\n\tint n, fail = 0;\n\tif (sock < 0) {\n\t\treturn 0;\n\t}\n\twhile (len > 0) {\n\t\tn = read(sock, buf, len);\n\t\tif (n > 0) {\n\t\t\tbuf += n;\n\t\t\tlen -= n;\n\t\t} else if (n == 0) {\n\t\t\tfail = 1;\n\t\t\tbreak;\n\t\t} else if (n < 0 && (errno == EAGAIN || errno == EWOULDBLOCK)) {\n\t\t\tusleep(10*1000);\n\t\t} else if (n < 0 && errno != EINTR) {\n\t\t\tfail = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (fail) {\n\t\treturn 0;\n\t} else {\n\t\treturn 1;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"wait_for_client: vnc_redirect nfds: %d\\n\"",
            "nfds"
          ],
          "line": 1803
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "select",
          "args": [
            "vnc_redirect_sock+1",
            "&rfds",
            "NULL",
            "NULL",
            "&tv"
          ],
          "line": 1801
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FD_SET",
          "args": [
            "vnc_redirect_sock",
            "&rfds"
          ],
          "line": 1797
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FD_ZERO",
          "args": [
            "&rfds"
          ],
          "line": 1796
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "usleep",
          "args": [
            "300*1000"
          ],
          "line": 1794
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"wait_for_client: vnc_redirect failed.\\n\""
          ],
          "line": 1785
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "waitpid",
          "args": [
            "pid",
            "&rc",
            "WNOHANG"
          ],
          "line": 1777
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "usleep",
          "args": [
            "1000 * 1000"
          ],
          "line": 1776
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "waitpid",
          "args": [
            "pid",
            "&rc",
            "WNOHANG"
          ],
          "line": 1774
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "usleep",
          "args": [
            "1000 * 1000"
          ],
          "line": 1773
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kill",
          "args": [
            "pid",
            "SIGTERM"
          ],
          "line": 1772
        },
        "resolved": true,
        "details": {
          "function_name": "kill_child",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/unixpw.c",
          "lines": "674-684",
          "snippet": "static void kill_child (pid_t pid, int fd) {\n\tint status;\n\n\tslave_fd = -1;\n\talarm_fired = 0;\n\tif (fd >= 0) {\n\t\tclose(fd);\n\t}\n\tkill(pid, SIGTERM);\n\twaitpid(pid, &status, WNOHANG); \n}",
          "includes": [
            "#include <sys/stropts.h>",
            "#include <termios.h>",
            "#include <sys/ioctl.h>",
            "#include <shadow.h>",
            "#include \"default8x16.h\"",
            "#include \"rates.h\"",
            "#include \"cursor.h\"",
            "#include \"sslhelper.h\"",
            "#include \"connections.h\"",
            "#include \"user.h\"",
            "#include \"connections.h\"",
            "#include \"xinerama.h\"",
            "#include \"cleanup.h\"",
            "#include \"scan.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int slave_fd = -1, alarm_fired = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/stropts.h>\n#include <termios.h>\n#include <sys/ioctl.h>\n#include <shadow.h>\n#include \"default8x16.h\"\n#include \"rates.h\"\n#include \"cursor.h\"\n#include \"sslhelper.h\"\n#include \"connections.h\"\n#include \"user.h\"\n#include \"connections.h\"\n#include \"xinerama.h\"\n#include \"cleanup.h\"\n#include \"scan.h\"\n#include \"x11vnc.h\"\n\nstatic int slave_fd = -1, alarm_fired = 0;\n\nstatic void kill_child (pid_t pid, int fd) {\n\tint status;\n\n\tslave_fd = -1;\n\talarm_fired = 0;\n\tif (fd >= 0) {\n\t\tclose(fd);\n\t}\n\tkill(pid, SIGTERM);\n\twaitpid(pid, &status, WNOHANG); \n}"
        }
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"wait_for_client: kill TERM: %d\\n\"",
            "(int) pid"
          ],
          "line": 1771
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "accept",
          "args": [
            "screen->listenSock",
            "(struct sockaddr *)&addr",
            "&addrlen"
          ],
          "line": 1762
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"wait_for_client: Xvnc.redirect not listening... sock=%d port=%d\\n\"",
            "screen->listenSock",
            "screen->port"
          ],
          "line": 1759
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"iter %d: vnc_redirect_sock: %d\\n\"",
            "i",
            "vnc_redirect_sock"
          ],
          "line": 1745
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "signal",
          "args": [
            "SIGALRM",
            "vnc_redirect_timeout"
          ],
          "line": 1735
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbHttpCheckFds",
          "args": [
            "screen"
          ],
          "line": 1723
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "usleep",
          "args": [
            "10 * 1000"
          ],
          "line": 1722
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "usleep",
          "args": [
            "500 * 1000"
          ],
          "line": 1717
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fork",
          "args": [],
          "line": 1713
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"wait_for_client: -connect and Xvnc.redirect not allowed\\n\""
          ],
          "line": 1701
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"wait_for_client: -unixpw and Xvnc.redirect not allowed\\n\""
          ],
          "line": 1697
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"avahi.h\"\n#include \"sslhelper.h\"\n#include \"remote.h\"\n#include \"cursor.h\"\n#include \"keyboard.h\"\n#include \"inet.h\"\n#include \"connections.h\"\n#include \"xwrappers.h\"\n#include \"sslhelper.h\"\n#include \"unixpw.h\"\n#include \"screen.h\"\n#include \"scan.h\"\n#include \"cleanup.h\"\n#include \"solid.h\"\n#include \"x11vnc.h\"\n\nstatic void vnc_redirect_loop(char *vnc_redirect_test, int *vnc_redirect_cnt) {\n\tif (unixpw) {\n\t\trfbLog(\"wait_for_client: -unixpw and Xvnc.redirect not allowed\\n\");\n\t\tclean_up_exit(1);\n\t}\n\tif (client_connect) {\n\t\trfbLog(\"wait_for_client: -connect and Xvnc.redirect not allowed\\n\");\n\t\tclean_up_exit(1);\n\t}\n\tif (inetd) {\n\t\tif (use_openssl) {\n\t\t\taccept_openssl(OPENSSL_INETD, -1);\n\t\t}\n\t} else {\n\t\tpid_t pid = 0;\n\t\t/* XXX ipv6 */\n\t\tif (screen->httpListenSock >= 0) {\n#if LIBVNCSERVER_HAVE_FORK\n\t\t\tif ((pid = fork()) > 0) {\n\t\t\t\tclose(screen->httpListenSock);\n\t\t\t\t/* mutex */\n\t\t\t\tscreen->httpListenSock = -2;\n\t\t\t\tusleep(500 * 1000);\n\t\t\t} else {\n\t\t\t\tclose(screen->listenSock);\n\t\t\t\tscreen->listenSock = -1;\n\t\t\t\twhile (1) {\n\t\t\t\t\tusleep(10 * 1000);\n\t\t\t\t\trfbHttpCheckFds(screen);\n\t\t\t\t}\n\t\t\t\texit(1);\n\t\t\t}\n#else\n\t\t\tclean_up_exit(1);\n#endif\n\t\t}\n\t\tif (first_conn_timeout) {\n\t\t\tif (first_conn_timeout < 0) {\n\t\t\t\tfirst_conn_timeout = -first_conn_timeout;\n\t\t\t}\n\t\t\tsignal(SIGALRM, vnc_redirect_timeout);\n\t\t\talarm(first_conn_timeout);\n\t\t}\n\t\tif (use_openssl) {\n\t\t\tint i;\n\t\t\tif (pid == 0) {\n\t\t\t\taccept_openssl(OPENSSL_VNC, -1);\n\t\t\t} else {\n\t\t\t\tfor (i=0; i < 16; i++) {\n\t\t\t\t\taccept_openssl(OPENSSL_VNC, -1);\n\t\t\t\t\trfbLog(\"iter %d: vnc_redirect_sock: %d\\n\", i, vnc_redirect_sock);\n\t\t\t\t\tif (vnc_redirect_sock >= 0) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tstruct sockaddr_in addr;\n#ifdef __hpux\n\t\t\tint addrlen = sizeof(addr);\n#else\n\t\t\tsocklen_t addrlen = sizeof(addr);\n#endif\n\t\t\tif (screen->listenSock < 0) {\n\t\t\t\trfbLog(\"wait_for_client: Xvnc.redirect not listening... sock=%d port=%d\\n\", screen->listenSock, screen->port);\n\t\t\t\tclean_up_exit(1);\n\t\t\t}\n\t\t\tvnc_redirect_sock = accept(screen->listenSock, (struct sockaddr *)&addr, &addrlen);\n\t\t}\n\t\tif (first_conn_timeout) {\n\t\t\talarm(0);\n\t\t}\n\t\tif (pid > 0) {\n#if LIBVNCSERVER_HAVE_FORK\n\t\t\tint rc;\n\t\t\tpid_t pidw;\n\t\t\trfbLog(\"wait_for_client: kill TERM: %d\\n\", (int) pid);\n\t\t\tkill(pid, SIGTERM);\n\t\t\tusleep(1000 * 1000);\t/* 1.0 sec */\n\t\t\tpidw = waitpid(pid, &rc, WNOHANG);\n\t\t\tif (pidw <= 0) {\n\t\t\t\tusleep(1000 * 1000);\t/* 1.0 sec */\n\t\t\t\tpidw = waitpid(pid, &rc, WNOHANG);\n\t\t\t}\n#else\n\t\t\tclean_up_exit(1);\n#endif\n\t\t}\n\t}\n\tif (vnc_redirect_sock < 0) {\n\t\trfbLog(\"wait_for_client: vnc_redirect failed.\\n\");\n\t\tclean_up_exit(1);\n\t}\n\tif (!inetd && use_openssl) {\n\t\t/* check for Fetch Cert closing */\n\t\tfd_set rfds;\n\t\tstruct timeval tv;\n\t\tint nfds;\n\n\t\tusleep(300*1000);\n\n\t\tFD_ZERO(&rfds);\n\t\tFD_SET(vnc_redirect_sock, &rfds);\n\n\t\ttv.tv_sec = 0;\n\t\ttv.tv_usec = 200000;\n\t\tnfds = select(vnc_redirect_sock+1, &rfds, NULL, NULL, &tv);\n\n\t\trfbLog(\"wait_for_client: vnc_redirect nfds: %d\\n\", nfds);\n\t\tif (nfds > 0) {\n\t\t\tint n;\n\t\t\tn = read(vnc_redirect_sock, vnc_redirect_test, 1);\n\t\t\tif (n <= 0) {\n\t\t\t\tclose(vnc_redirect_sock);\n\t\t\t\tvnc_redirect_sock = -1;\n\t\t\t\trfbLog(\"wait_for_client: waiting for 2nd connection (Fetch Cert?)\\n\");\n\t\t\t\taccept_openssl(OPENSSL_VNC, -1);\n\t\t\t\tif (vnc_redirect_sock < 0) {\n\t\t\t\t\trfbLog(\"wait_for_client: vnc_redirect failed.\\n\");\n\t\t\t\t\tclean_up_exit(1);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t*vnc_redirect_cnt = n;\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "function_name": "do_unixpw_loop",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/user.c",
    "lines": "1657-1693",
    "snippet": "static void do_unixpw_loop(void) {\n\tif (unixpw) {\n\t\tif (! unixpw_in_progress && !vencrypt_enable_plain_login) {\n\t\t\trfbLog(\"unixpw but no unixpw_in_progress\\n\");\n\t\t\tclean_up_exit(1);\n\t\t}\n\t\tif (unixpw_client && unixpw_client->onHold) {\n\t\t\trfbLog(\"taking unixpw_client off hold.\\n\");\n\t\t\tunixpw_client->onHold = FALSE;\n\t\t}\n\t\twhile (1) {\n\t\t\tif (shut_down) {\n\t\t\t\tclean_up_exit(0);\n\t\t\t}\n\t\t\tif (! use_threads) {\n\t\t\t\tunixpw_in_rfbPE = 1;\n\t\t\t\trfbPE(-1);\n\t\t\t\tunixpw_in_rfbPE = 0;\n\t\t\t}\n\t\t\tif (unixpw_in_progress) {\n\t\t\t\tstatic double lping = 0.0;\n\t\t\t\tif (lping < dnow() + 5) {\n\t\t\t\t\tmark_rect_as_modified(0, 0, 1, 1, 1);\n\t\t\t\t\tlping = dnow();\n\t\t\t\t}\n\t\t\t\tif (time(NULL) > unixpw_last_try_time + 45) {\n\t\t\t\t\trfbLog(\"unixpw_deny: timed out waiting for reply.\\n\");\n\t\t\t\t\tunixpw_deny();\n\t\t\t\t}\n\t\t\t\tusleep(20 * 1000);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\trfbLog(\"wait_for_client: unixpw finished.\\n\");\n\t\t\tbreak;\n\t\t}\n\t}\n}",
    "includes": [
      "#include \"avahi.h\"",
      "#include \"sslhelper.h\"",
      "#include \"remote.h\"",
      "#include \"cursor.h\"",
      "#include \"keyboard.h\"",
      "#include \"inet.h\"",
      "#include \"connections.h\"",
      "#include \"xwrappers.h\"",
      "#include \"sslhelper.h\"",
      "#include \"unixpw.h\"",
      "#include \"screen.h\"",
      "#include \"scan.h\"",
      "#include \"cleanup.h\"",
      "#include \"solid.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"wait_for_client: unixpw finished.\\n\""
          ],
          "line": 1689
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "usleep",
          "args": [
            "20 * 1000"
          ],
          "line": 1686
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unixpw_deny",
          "args": [],
          "line": 1684
        },
        "resolved": true,
        "details": {
          "function_name": "unixpw_deny",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/unixpw.c",
          "lines": "2218-2258",
          "snippet": "void unixpw_deny(void) {\n\tint x, y, i;\n\tchar pd[] = \"Permission denied.\";\n\n\trfbLog(\"unixpw_deny: %d, %d\\n\", unixpw_denied, unixpw_in_progress);\n\tif (! unixpw_denied) {\n\t\tunixpw_denied = 1;\n\n\t\tchar_row += 2;\n\t\tchar_col = 0;\n\t\tx = char_x + char_col * char_w;\n\t\ty = char_y + char_row * char_h;\n\n\t\trfbDrawString(pscreen, &default8x16Font, x, y, pd, white_pixel());\n\t\tunixpw_mark();\n\n\t\tfor (i=0; i<5; i++) {\n\t\t\trfbPE(-1);\n\t\t\trfbPE(-1);\n\t\t\tusleep(500 * 1000);\n\t\t}\n\t}\n\n\tif (unixpw_client) {\n\t\trfbCloseClient(unixpw_client);\n\t\trfbClientConnectionGone(unixpw_client);\n\t\trfbPE(-1);\n\t}\n\n\tunixpw_in_progress = 0;\n\t/* mutex */\n\tscreen->permitFileTransfer = unixpw_file_xfer_save;\n\tif ((tightfilexfer = unixpw_tightvnc_xfer_save)) {\n#ifdef LIBVNCSERVER_WITH_TIGHTVNC_FILETRANSFER\n\t\trfbLog(\"rfbRegisterTightVNCFileTransferExtension: 2\\n\");\n                rfbRegisterTightVNCFileTransferExtension();\n#endif\n\t}\n\tunixpw_client = NULL;\n\tcopy_screen();\n}",
          "includes": [
            "#include <sys/stropts.h>",
            "#include <termios.h>",
            "#include <sys/ioctl.h>",
            "#include <shadow.h>",
            "#include \"default8x16.h\"",
            "#include \"rates.h\"",
            "#include \"cursor.h\"",
            "#include \"sslhelper.h\"",
            "#include \"connections.h\"",
            "#include \"user.h\"",
            "#include \"connections.h\"",
            "#include \"xinerama.h\"",
            "#include \"cleanup.h\"",
            "#include \"scan.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int white_pixel(void);",
            "void unixpw_deny(void);",
            "int unixpw_cmd_run(char *user, char *pass, char *cmd, char *line, int *n);",
            "int unixpw_in_progress = 0;",
            "int unixpw_denied = 0;",
            "int unixpw_tightvnc_xfer_save = 0;",
            "rfbBool unixpw_file_xfer_save = FALSE;",
            "rfbClientPtr unixpw_client = NULL;",
            "static int char_row = 0, char_col = 0;",
            "static int char_x = 0, char_y = 0, char_w = 8, char_h = 16;",
            "static rfbScreenInfoPtr pscreen;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/stropts.h>\n#include <termios.h>\n#include <sys/ioctl.h>\n#include <shadow.h>\n#include \"default8x16.h\"\n#include \"rates.h\"\n#include \"cursor.h\"\n#include \"sslhelper.h\"\n#include \"connections.h\"\n#include \"user.h\"\n#include \"connections.h\"\n#include \"xinerama.h\"\n#include \"cleanup.h\"\n#include \"scan.h\"\n#include \"x11vnc.h\"\n\nint white_pixel(void);\nvoid unixpw_deny(void);\nint unixpw_cmd_run(char *user, char *pass, char *cmd, char *line, int *n);\nint unixpw_in_progress = 0;\nint unixpw_denied = 0;\nint unixpw_tightvnc_xfer_save = 0;\nrfbBool unixpw_file_xfer_save = FALSE;\nrfbClientPtr unixpw_client = NULL;\nstatic int char_row = 0, char_col = 0;\nstatic int char_x = 0, char_y = 0, char_w = 8, char_h = 16;\nstatic rfbScreenInfoPtr pscreen;\n\nvoid unixpw_deny(void) {\n\tint x, y, i;\n\tchar pd[] = \"Permission denied.\";\n\n\trfbLog(\"unixpw_deny: %d, %d\\n\", unixpw_denied, unixpw_in_progress);\n\tif (! unixpw_denied) {\n\t\tunixpw_denied = 1;\n\n\t\tchar_row += 2;\n\t\tchar_col = 0;\n\t\tx = char_x + char_col * char_w;\n\t\ty = char_y + char_row * char_h;\n\n\t\trfbDrawString(pscreen, &default8x16Font, x, y, pd, white_pixel());\n\t\tunixpw_mark();\n\n\t\tfor (i=0; i<5; i++) {\n\t\t\trfbPE(-1);\n\t\t\trfbPE(-1);\n\t\t\tusleep(500 * 1000);\n\t\t}\n\t}\n\n\tif (unixpw_client) {\n\t\trfbCloseClient(unixpw_client);\n\t\trfbClientConnectionGone(unixpw_client);\n\t\trfbPE(-1);\n\t}\n\n\tunixpw_in_progress = 0;\n\t/* mutex */\n\tscreen->permitFileTransfer = unixpw_file_xfer_save;\n\tif ((tightfilexfer = unixpw_tightvnc_xfer_save)) {\n#ifdef LIBVNCSERVER_WITH_TIGHTVNC_FILETRANSFER\n\t\trfbLog(\"rfbRegisterTightVNCFileTransferExtension: 2\\n\");\n                rfbRegisterTightVNCFileTransferExtension();\n#endif\n\t}\n\tunixpw_client = NULL;\n\tcopy_screen();\n}"
        }
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"unixpw_deny: timed out waiting for reply.\\n\""
          ],
          "line": 1683
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "time",
          "args": [
            "NULL"
          ],
          "line": 1682
        },
        "resolved": true,
        "details": {
          "function_name": "vnc_redirect_timeout",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/user.c",
          "lines": "1395-1399",
          "snippet": "static void vnc_redirect_timeout (int sig) {\n\twrite(2, \"timeout: no clients connected.\\n\", 31);\n\tif (sig) {};\n\texit(0);\n}",
          "includes": [
            "#include \"avahi.h\"",
            "#include \"sslhelper.h\"",
            "#include \"remote.h\"",
            "#include \"cursor.h\"",
            "#include \"keyboard.h\"",
            "#include \"inet.h\"",
            "#include \"connections.h\"",
            "#include \"xwrappers.h\"",
            "#include \"sslhelper.h\"",
            "#include \"unixpw.h\"",
            "#include \"screen.h\"",
            "#include \"scan.h\"",
            "#include \"cleanup.h\"",
            "#include \"solid.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"avahi.h\"\n#include \"sslhelper.h\"\n#include \"remote.h\"\n#include \"cursor.h\"\n#include \"keyboard.h\"\n#include \"inet.h\"\n#include \"connections.h\"\n#include \"xwrappers.h\"\n#include \"sslhelper.h\"\n#include \"unixpw.h\"\n#include \"screen.h\"\n#include \"scan.h\"\n#include \"cleanup.h\"\n#include \"solid.h\"\n#include \"x11vnc.h\"\n\nstatic void vnc_redirect_timeout (int sig) {\n\twrite(2, \"timeout: no clients connected.\\n\", 31);\n\tif (sig) {};\n\texit(0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dnow",
          "args": [],
          "line": 1680
        },
        "resolved": true,
        "details": {
          "function_name": "dnowx",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/util.c",
          "lines": "439-441",
          "snippet": "double dnowx(void) {\n\treturn dnow() - x11vnc_start;\n}",
          "includes": [
            "#include \"connections.h\"",
            "#include \"unixpw.h\"",
            "#include \"win_utils.h\"",
            "#include \"cleanup.h\"",
            "#include \"x11vnc.h\"",
            "#include <stdlib.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "double dnow(void);",
            "double dnowx(void);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"connections.h\"\n#include \"unixpw.h\"\n#include \"win_utils.h\"\n#include \"cleanup.h\"\n#include \"x11vnc.h\"\n#include <stdlib.h>\n\ndouble dnow(void);\ndouble dnowx(void);\n\ndouble dnowx(void) {\n\treturn dnow() - x11vnc_start;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mark_rect_as_modified",
          "args": [
            "0",
            "0",
            "1",
            "1",
            "1"
          ],
          "line": 1679
        },
        "resolved": true,
        "details": {
          "function_name": "mark_rect_as_modified",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/scan.c",
          "lines": "1643-1682",
          "snippet": "void mark_rect_as_modified(int x1, int y1, int x2, int y2, int force) {\n\n\tif (damage_time != 0) {\n\t\t/*\n\t\t * This is not XDAMAGE, rather a hack for testing\n\t\t * where we allow the framebuffer to be corrupted for\n\t\t * damage_delay seconds.\n\t\t */\n\t\tint debug = 0;\n\t\tif (time(NULL) > damage_time + damage_delay) {\n\t\t\tif (! quiet) {\n\t\t\t\trfbLog(\"damaging turned off.\\n\");\n\t\t\t}\n\t\t\tdamage_time = 0;\n\t\t\tdamage_delay = 0;\n\t\t} else {\n\t\t\tif (debug) {\n\t\t\t\trfbLog(\"damaging viewer fb by not marking \"\n\t\t\t\t    \"rect: %d,%d,%d,%d\\n\", x1, y1, x2, y2);\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t}\n\n\n\tif (rfb_fb == main_fb || force) {\n\t\tmark_wrapper(x1, y1, x2, y2);\n\t\treturn;\n\t}\n\n\tif (cmap8to24) {\n\t\tbpp8to24(x1, y1, x2, y2);\n\t}\n\n\tif (scaling) {\n\t\tscale_and_mark_rect(x1, y1, x2, y2, 1);\n\t} else {\n\t\tmark_wrapper(x1, y1, x2, y2);\n\t}\n}",
          "includes": [
            "#include <default8x16.h>",
            "#include \"userinput.h\"",
            "#include \"macosx.h\"",
            "#include \"screen.h\"",
            "#include \"unixpw.h\"",
            "#include \"cleanup.h\"",
            "#include \"pointer.h\"",
            "#include \"screen.h\"",
            "#include \"8to24.h\"",
            "#include \"win_utils.h\"",
            "#include \"xrandr.h\"",
            "#include \"xdamage.h\"",
            "#include \"xwrappers.h\"",
            "#include \"xinerama.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void mark_rect_as_modified(int x1, int y1, int x2, int y2, int force);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <default8x16.h>\n#include \"userinput.h\"\n#include \"macosx.h\"\n#include \"screen.h\"\n#include \"unixpw.h\"\n#include \"cleanup.h\"\n#include \"pointer.h\"\n#include \"screen.h\"\n#include \"8to24.h\"\n#include \"win_utils.h\"\n#include \"xrandr.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"xinerama.h\"\n#include \"x11vnc.h\"\n\nvoid mark_rect_as_modified(int x1, int y1, int x2, int y2, int force);\n\nvoid mark_rect_as_modified(int x1, int y1, int x2, int y2, int force) {\n\n\tif (damage_time != 0) {\n\t\t/*\n\t\t * This is not XDAMAGE, rather a hack for testing\n\t\t * where we allow the framebuffer to be corrupted for\n\t\t * damage_delay seconds.\n\t\t */\n\t\tint debug = 0;\n\t\tif (time(NULL) > damage_time + damage_delay) {\n\t\t\tif (! quiet) {\n\t\t\t\trfbLog(\"damaging turned off.\\n\");\n\t\t\t}\n\t\t\tdamage_time = 0;\n\t\t\tdamage_delay = 0;\n\t\t} else {\n\t\t\tif (debug) {\n\t\t\t\trfbLog(\"damaging viewer fb by not marking \"\n\t\t\t\t    \"rect: %d,%d,%d,%d\\n\", x1, y1, x2, y2);\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t}\n\n\n\tif (rfb_fb == main_fb || force) {\n\t\tmark_wrapper(x1, y1, x2, y2);\n\t\treturn;\n\t}\n\n\tif (cmap8to24) {\n\t\tbpp8to24(x1, y1, x2, y2);\n\t}\n\n\tif (scaling) {\n\t\tscale_and_mark_rect(x1, y1, x2, y2, 1);\n\t} else {\n\t\tmark_wrapper(x1, y1, x2, y2);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "rfbPE",
          "args": [
            "-1"
          ],
          "line": 1673
        },
        "resolved": true,
        "details": {
          "function_name": "rfbPE",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/util.c",
          "lines": "561-619",
          "snippet": "int rfbPE(long usec) {\n\tint uip0 = unixpw_in_progress;\n\tstatic int check_rate = -1;\n\tint res = 0;\n\tif (! screen) {\n\t\treturn res;\n\t}\n \tif (unixpw && unixpw_in_progress && !unixpw_in_rfbPE) {\n\t\trfbLog(\"unixpw_in_rfbPE: skipping rfbPE\\n\");\n \t\treturn res;\n \t}\n\n\tif (debug_tiles > 2) {\n\t\tdouble tm = dnow();\n\t\tfprintf(stderr, \"rfbPE(%d)  t: %.4f\\n\",\n\t\t    (int) usec, tm - x11vnc_start);\n\t}\n\n\tif (usec > USEC_MAX) {\n\t\tusec = USEC_MAX;\n\t}\n\tif (! use_threads) {\n\t\trfbBool r;\n\t\tr = rfbProcessEvents(screen, usec);\n\t\tif (r) {\n\t\t\tres = 1;\n\t\t}\n\t}\n\n \tif (unixpw && unixpw_in_progress && !uip0) {\n\t\tif (!unixpw_in_rfbPE) {\n\t\t\trfbLog(\"rfbPE: got new client in non-rfbPE\\n\");\n\t\t\t;\t/* this is new unixpw client  */\n\t\t}\n \t}\n\n\tif (ipv6_listen) {\n\t\tcheck_ipv6_listen(usec);\n\t}\n\tif (unix_sock) {\n\t\tcheck_unix_sock(usec);\n\t}\n\tif (check_rate != 0) {\n\t\tif (check_rate < 0) {\n\t\t\tif (getenv(\"CHECK_RATE\")) {\n\t\t\t\tcheck_rate = 1;\n\t\t\t} else {\n\t\t\t\tcheck_rate = 0;\n\t\t\t}\n\t\t}\n\t\tif (check_rate && !all_input && x11vnc_current < last_client + 45)  {\n\t\t\tcheck_allinput_rate();\n\t\t}\n\t}\n\tif (all_input) {\n\t\tdo_allinput(usec);\n\t}\n\treturn res;\n}",
          "includes": [
            "#include \"connections.h\"",
            "#include \"unixpw.h\"",
            "#include \"win_utils.h\"",
            "#include \"cleanup.h\"",
            "#include \"x11vnc.h\"",
            "#include <stdlib.h>"
          ],
          "macros_used": [
            "#define USEC_MAX 999999\t\t/* libvncsever assumes < 1 second */"
          ],
          "globals_used": [
            "int nfix(int i, int n);",
            "int nabs(int n);",
            "double dnow(void);",
            "int rfbPE(long usec);",
            "void rfbCFD(long usec);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"connections.h\"\n#include \"unixpw.h\"\n#include \"win_utils.h\"\n#include \"cleanup.h\"\n#include \"x11vnc.h\"\n#include <stdlib.h>\n\n#define USEC_MAX 999999\t\t/* libvncsever assumes < 1 second */\n\nint nfix(int i, int n);\nint nabs(int n);\ndouble dnow(void);\nint rfbPE(long usec);\nvoid rfbCFD(long usec);\n\nint rfbPE(long usec) {\n\tint uip0 = unixpw_in_progress;\n\tstatic int check_rate = -1;\n\tint res = 0;\n\tif (! screen) {\n\t\treturn res;\n\t}\n \tif (unixpw && unixpw_in_progress && !unixpw_in_rfbPE) {\n\t\trfbLog(\"unixpw_in_rfbPE: skipping rfbPE\\n\");\n \t\treturn res;\n \t}\n\n\tif (debug_tiles > 2) {\n\t\tdouble tm = dnow();\n\t\tfprintf(stderr, \"rfbPE(%d)  t: %.4f\\n\",\n\t\t    (int) usec, tm - x11vnc_start);\n\t}\n\n\tif (usec > USEC_MAX) {\n\t\tusec = USEC_MAX;\n\t}\n\tif (! use_threads) {\n\t\trfbBool r;\n\t\tr = rfbProcessEvents(screen, usec);\n\t\tif (r) {\n\t\t\tres = 1;\n\t\t}\n\t}\n\n \tif (unixpw && unixpw_in_progress && !uip0) {\n\t\tif (!unixpw_in_rfbPE) {\n\t\t\trfbLog(\"rfbPE: got new client in non-rfbPE\\n\");\n\t\t\t;\t/* this is new unixpw client  */\n\t\t}\n \t}\n\n\tif (ipv6_listen) {\n\t\tcheck_ipv6_listen(usec);\n\t}\n\tif (unix_sock) {\n\t\tcheck_unix_sock(usec);\n\t}\n\tif (check_rate != 0) {\n\t\tif (check_rate < 0) {\n\t\t\tif (getenv(\"CHECK_RATE\")) {\n\t\t\t\tcheck_rate = 1;\n\t\t\t} else {\n\t\t\t\tcheck_rate = 0;\n\t\t\t}\n\t\t}\n\t\tif (check_rate && !all_input && x11vnc_current < last_client + 45)  {\n\t\t\tcheck_allinput_rate();\n\t\t}\n\t}\n\tif (all_input) {\n\t\tdo_allinput(usec);\n\t}\n\treturn res;\n}"
        }
      },
      {
        "call_info": {
          "callee": "clean_up_exit",
          "args": [
            "0"
          ],
          "line": 1669
        },
        "resolved": true,
        "details": {
          "function_name": "clean_up_exit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/cleanup.c",
          "lines": "151-266",
          "snippet": "void clean_up_exit(int ret) {\n\tstatic int depth = 0;\n\texit_flag = 1;\n\n\tif (depth++ > 2) {\n\t\texit(ret);\n\t}\n\n\tif (icon_mode) {\n\t\tclean_icon_mode();\n\t}\n\n\t/* remove the shm areas: */\n\tclean_shm(0);\n\n\tstop_stunnel();\n\tif (use_openssl) {\n\t\tssl_helper_pid(0, 0);\t/* killall */\n\t}\n\n\tif (ssh_pid > 0) {\n\t\tkill(ssh_pid, SIGTERM);\n\t\tssh_pid = 0;\n\t}\n\n#ifdef MACOSX\n\tif (client_connect_file) {\n\t\tif (strstr(client_connect_file, \"/tmp/x11vnc-macosx-remote\")\n\t\t    == client_connect_file) {\n\t\t\tunlink(client_connect_file);\n\t\t}\n\t}\n\tif (macosx_console) {\n\t\tmacosxCG_fini();\n\t}\n#endif\n\n\tif (pipeinput_fh != NULL) {\n\t\tpclose(pipeinput_fh);\n\t\tpipeinput_fh = NULL;\n\t}\n\n\tshutdown_uinput();\n\n\tif (unix_sock) {\n\t\tif (unix_sock_fd >= 0) {\n\t\t\trfbLog(\"deleting unix sock: %s\\n\", unix_sock);\n\t\t\tclose(unix_sock_fd);\n\t\t\tunix_sock_fd = -1;\n\t\t\tunlink(unix_sock);\n\t\t}\n\t}\n\n\tif (! dpy) {\t/* raw_rb hack */\n\t\tif (rm_flagfile) {\n\t\t\tunlink(rm_flagfile);\n\t\t\trm_flagfile = NULL;\n\t\t}\n\t\texit(ret);\n\t}\n\n\t/* X keyboard cleanups */\n\tdelete_added_keycodes(0);\n\n\t/* remove all created XInput2 devices */\n\tif(use_multipointer)\n\t    removeAllMDs(dpy);\n\n\tif (clear_mods == 1) {\n\t\tclear_modifiers(0);\n\t} else if (clear_mods == 2) {\n\t\tclear_keys();\n\t} else if (clear_mods == 3) {\n\t\tclear_keys();\n\t\tclear_locks();\n\t}\n\n\tif (no_autorepeat) {\n\t\tautorepeat(1, 0);\n\t}\n\tif (use_solid_bg) {\n\t\tsolid_bg(1);\n\t}\n\tif (ncache || ncache0) {\n\t\tkde_no_animate(1);\n\t}\n\tX_LOCK;\n\tXTestDiscard_wr(dpy);\n#if HAVE_LIBXDAMAGE\n\tif (xdamage) {\n\t\tXDamageDestroy(dpy, xdamage);\n\t}\n#endif\n#if HAVE_LIBXTRAP\n\tif (trap_ctx) {\n\t\tXEFreeTC(trap_ctx);\n\t}\n#endif\n\t/* XXX rdpy_ctrl, etc. cannot close w/o blocking */\n\tXCloseDisplay_wr(dpy);\n\tX_UNLOCK;\n\n\tfflush(stderr);\n\n\tif (rm_flagfile) {\n\t\tunlink(rm_flagfile);\n\t\trm_flagfile = NULL;\n\t}\n\n\tif (avahi) {\n\t\tavahi_cleanup();\n\t\tfflush(stderr);\n\t}\n\n\texit(ret);\n}",
          "includes": [
            "#include \"xi2_devices.h\"",
            "#include \"uinput.h\"",
            "#include \"xevents.h\"",
            "#include \"xrecord.h\"",
            "#include \"screen.h\"",
            "#include \"avahi.h\"",
            "#include \"macosxCG.h\"",
            "#include \"macosx.h\"",
            "#include \"connections.h\"",
            "#include \"sslhelper.h\"",
            "#include \"sslcmds.h\"",
            "#include \"unixpw.h\"",
            "#include \"solid.h\"",
            "#include \"gui.h\"",
            "#include \"scan.h\"",
            "#include \"keyboard.h\"",
            "#include \"remote.h\"",
            "#include \"xdamage.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void clean_up_exit(int ret);",
            "int known_sigpipe_mode(char *s);",
            "static int exit_flag = 0;",
            "static void clean_icon_mode(void);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xi2_devices.h\"\n#include \"uinput.h\"\n#include \"xevents.h\"\n#include \"xrecord.h\"\n#include \"screen.h\"\n#include \"avahi.h\"\n#include \"macosxCG.h\"\n#include \"macosx.h\"\n#include \"connections.h\"\n#include \"sslhelper.h\"\n#include \"sslcmds.h\"\n#include \"unixpw.h\"\n#include \"solid.h\"\n#include \"gui.h\"\n#include \"scan.h\"\n#include \"keyboard.h\"\n#include \"remote.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nvoid clean_up_exit(int ret);\nint known_sigpipe_mode(char *s);\nstatic int exit_flag = 0;\nstatic void clean_icon_mode(void);\n\nvoid clean_up_exit(int ret) {\n\tstatic int depth = 0;\n\texit_flag = 1;\n\n\tif (depth++ > 2) {\n\t\texit(ret);\n\t}\n\n\tif (icon_mode) {\n\t\tclean_icon_mode();\n\t}\n\n\t/* remove the shm areas: */\n\tclean_shm(0);\n\n\tstop_stunnel();\n\tif (use_openssl) {\n\t\tssl_helper_pid(0, 0);\t/* killall */\n\t}\n\n\tif (ssh_pid > 0) {\n\t\tkill(ssh_pid, SIGTERM);\n\t\tssh_pid = 0;\n\t}\n\n#ifdef MACOSX\n\tif (client_connect_file) {\n\t\tif (strstr(client_connect_file, \"/tmp/x11vnc-macosx-remote\")\n\t\t    == client_connect_file) {\n\t\t\tunlink(client_connect_file);\n\t\t}\n\t}\n\tif (macosx_console) {\n\t\tmacosxCG_fini();\n\t}\n#endif\n\n\tif (pipeinput_fh != NULL) {\n\t\tpclose(pipeinput_fh);\n\t\tpipeinput_fh = NULL;\n\t}\n\n\tshutdown_uinput();\n\n\tif (unix_sock) {\n\t\tif (unix_sock_fd >= 0) {\n\t\t\trfbLog(\"deleting unix sock: %s\\n\", unix_sock);\n\t\t\tclose(unix_sock_fd);\n\t\t\tunix_sock_fd = -1;\n\t\t\tunlink(unix_sock);\n\t\t}\n\t}\n\n\tif (! dpy) {\t/* raw_rb hack */\n\t\tif (rm_flagfile) {\n\t\t\tunlink(rm_flagfile);\n\t\t\trm_flagfile = NULL;\n\t\t}\n\t\texit(ret);\n\t}\n\n\t/* X keyboard cleanups */\n\tdelete_added_keycodes(0);\n\n\t/* remove all created XInput2 devices */\n\tif(use_multipointer)\n\t    removeAllMDs(dpy);\n\n\tif (clear_mods == 1) {\n\t\tclear_modifiers(0);\n\t} else if (clear_mods == 2) {\n\t\tclear_keys();\n\t} else if (clear_mods == 3) {\n\t\tclear_keys();\n\t\tclear_locks();\n\t}\n\n\tif (no_autorepeat) {\n\t\tautorepeat(1, 0);\n\t}\n\tif (use_solid_bg) {\n\t\tsolid_bg(1);\n\t}\n\tif (ncache || ncache0) {\n\t\tkde_no_animate(1);\n\t}\n\tX_LOCK;\n\tXTestDiscard_wr(dpy);\n#if HAVE_LIBXDAMAGE\n\tif (xdamage) {\n\t\tXDamageDestroy(dpy, xdamage);\n\t}\n#endif\n#if HAVE_LIBXTRAP\n\tif (trap_ctx) {\n\t\tXEFreeTC(trap_ctx);\n\t}\n#endif\n\t/* XXX rdpy_ctrl, etc. cannot close w/o blocking */\n\tXCloseDisplay_wr(dpy);\n\tX_UNLOCK;\n\n\tfflush(stderr);\n\n\tif (rm_flagfile) {\n\t\tunlink(rm_flagfile);\n\t\trm_flagfile = NULL;\n\t}\n\n\tif (avahi) {\n\t\tavahi_cleanup();\n\t\tfflush(stderr);\n\t}\n\n\texit(ret);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"taking unixpw_client off hold.\\n\""
          ],
          "line": 1664
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"unixpw but no unixpw_in_progress\\n\""
          ],
          "line": 1660
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"avahi.h\"\n#include \"sslhelper.h\"\n#include \"remote.h\"\n#include \"cursor.h\"\n#include \"keyboard.h\"\n#include \"inet.h\"\n#include \"connections.h\"\n#include \"xwrappers.h\"\n#include \"sslhelper.h\"\n#include \"unixpw.h\"\n#include \"screen.h\"\n#include \"scan.h\"\n#include \"cleanup.h\"\n#include \"solid.h\"\n#include \"x11vnc.h\"\n\nstatic void do_unixpw_loop(void) {\n\tif (unixpw) {\n\t\tif (! unixpw_in_progress && !vencrypt_enable_plain_login) {\n\t\t\trfbLog(\"unixpw but no unixpw_in_progress\\n\");\n\t\t\tclean_up_exit(1);\n\t\t}\n\t\tif (unixpw_client && unixpw_client->onHold) {\n\t\t\trfbLog(\"taking unixpw_client off hold.\\n\");\n\t\t\tunixpw_client->onHold = FALSE;\n\t\t}\n\t\twhile (1) {\n\t\t\tif (shut_down) {\n\t\t\t\tclean_up_exit(0);\n\t\t\t}\n\t\t\tif (! use_threads) {\n\t\t\t\tunixpw_in_rfbPE = 1;\n\t\t\t\trfbPE(-1);\n\t\t\t\tunixpw_in_rfbPE = 0;\n\t\t\t}\n\t\t\tif (unixpw_in_progress) {\n\t\t\t\tstatic double lping = 0.0;\n\t\t\t\tif (lping < dnow() + 5) {\n\t\t\t\t\tmark_rect_as_modified(0, 0, 1, 1, 1);\n\t\t\t\t\tlping = dnow();\n\t\t\t\t}\n\t\t\t\tif (time(NULL) > unixpw_last_try_time + 45) {\n\t\t\t\t\trfbLog(\"unixpw_deny: timed out waiting for reply.\\n\");\n\t\t\t\t\tunixpw_deny();\n\t\t\t\t}\n\t\t\t\tusleep(20 * 1000);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\trfbLog(\"wait_for_client: unixpw finished.\\n\");\n\t\t\tbreak;\n\t\t}\n\t}\n}"
  },
  {
    "function_name": "loop_for_connect",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/user.c",
    "lines": "1555-1655",
    "snippet": "static void loop_for_connect(int did_client_connect) {\n\tint loop = 0;\n\ttime_t start = time(NULL);\n\n\tif (first_conn_timeout < 0) {\n\t\tfirst_conn_timeout = -first_conn_timeout;\n\t}\n\n\twhile (1) {\n\t\tloop++;\n\t\tif (first_conn_timeout && time(NULL) > start + first_conn_timeout) {\n\t\t\trfbLog(\"no client connect after %d seconds.\\n\", first_conn_timeout);\n\t\t\tshut_down = 1;\n\t\t}\n\t\tif (shut_down) {\n\t\t\tclean_up_exit(0);\n\t\t}\n\t\tif (loop < 2) {\n\t\t\tif (did_client_connect) {\n\t\t\t\tgoto screen_check;\n\t\t\t}\n\t\t\tif (inetd) {\n\t\t\t\tgoto screen_check;\n\t\t\t}\n\t\t\tif (screen && screen->clientHead) {\n\t\t\t\tgoto screen_check;\n\t\t\t}\n\t\t}\n\t\tif ((use_openssl || use_stunnel) && !inetd) {\n\t\t\tint enc_none = (enc_str && !strcmp(enc_str, \"none\"));\n\t\t\tif (!use_stunnel || enc_none) {\n\t\t\t\tcheck_openssl();\n\t\t\t\tcheck_https();\n\t\t\t}\n\t\t\t/*\n\t\t\t * This is to handle an initial verify cert from viewer,\n\t\t\t * they disconnect right after fetching the cert.\n\t\t\t */\n\t\t\tif (use_threads) {\n\t\t\t\tusleep(10 * 1000);\n\t\t\t} else {\n\t\t\t\trfbPE(-1);\n\t\t\t}\n\t\t\tif (screen && screen->clientHead) {\n\t\t\t\tint i;\n\t\t\t\tif (unixpw) {\n\t\t\t\t\tif (! unixpw_in_progress && !vencrypt_enable_plain_login) {\n\t\t\t\t\t\trfbLog(\"unixpw but no unixpw_in_progress\\n\");\n\t\t\t\t\t\tclean_up_exit(1);\n\t\t\t\t\t}\n\t\t\t\t\tif (unixpw_client && unixpw_client->onHold) {\n\t\t\t\t\t\trfbLog(\"taking unixpw_client off hold\\n\");\n\t\t\t\t\t\tunixpw_client->onHold = FALSE;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfor (i=0; i<10; i++) {\n\t\t\t\t\tif (shut_down) {\n\t\t\t\t\t\tclean_up_exit(0);\n\t\t\t\t\t}\n\t\t\t\t\tusleep(20 * 1000);\n\t\t\t\t\tif (0) rfbLog(\"wait_for_client: %d\\n\", i);\n\n\t\t\t\t\tif (! use_threads) {\n\t\t\t\t\t\tif (unixpw) {\n\t\t\t\t\t\t\tunixpw_in_rfbPE = 1;\n\t\t\t\t\t\t}\n\t\t\t\t\t\trfbPE(-1);\n\t\t\t\t\t\tif (unixpw) {\n\t\t\t\t\t\t\tunixpw_in_rfbPE = 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif (unixpw && !unixpw_in_progress) {\n\t\t\t\t\t\t/* XXX too soon. */\n\t\t\t\t\t\tgoto screen_check;\n\t\t\t\t\t}\n\t\t\t\t\tif (!screen->clientHead) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (use_openssl) {\n\t\t\tcheck_openssl();\n\t\t}\n\n\t\tif (use_threads) {\n\t\t\tusleep(10 * 1000);\n\t\t} else {\n\t\t\trfbPE(-1);\n\t\t}\n\n\t\tscreen_check:\n\t\tif (! screen || ! screen->clientHead) {\n\t\t\tusleep(100 * 1000);\n\t\t\tcontinue;\n\t\t}\n\n\t\trfbLog(\"wait_for_client: got client\\n\");\n\t\tbreak;\n\t}\n}",
    "includes": [
      "#include \"avahi.h\"",
      "#include \"sslhelper.h\"",
      "#include \"remote.h\"",
      "#include \"cursor.h\"",
      "#include \"keyboard.h\"",
      "#include \"inet.h\"",
      "#include \"connections.h\"",
      "#include \"xwrappers.h\"",
      "#include \"sslhelper.h\"",
      "#include \"unixpw.h\"",
      "#include \"screen.h\"",
      "#include \"scan.h\"",
      "#include \"cleanup.h\"",
      "#include \"solid.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"wait_for_client: got client\\n\""
          ],
          "line": 1652
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "usleep",
          "args": [
            "100 * 1000"
          ],
          "line": 1648
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbPE",
          "args": [
            "-1"
          ],
          "line": 1643
        },
        "resolved": true,
        "details": {
          "function_name": "rfbPE",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/util.c",
          "lines": "561-619",
          "snippet": "int rfbPE(long usec) {\n\tint uip0 = unixpw_in_progress;\n\tstatic int check_rate = -1;\n\tint res = 0;\n\tif (! screen) {\n\t\treturn res;\n\t}\n \tif (unixpw && unixpw_in_progress && !unixpw_in_rfbPE) {\n\t\trfbLog(\"unixpw_in_rfbPE: skipping rfbPE\\n\");\n \t\treturn res;\n \t}\n\n\tif (debug_tiles > 2) {\n\t\tdouble tm = dnow();\n\t\tfprintf(stderr, \"rfbPE(%d)  t: %.4f\\n\",\n\t\t    (int) usec, tm - x11vnc_start);\n\t}\n\n\tif (usec > USEC_MAX) {\n\t\tusec = USEC_MAX;\n\t}\n\tif (! use_threads) {\n\t\trfbBool r;\n\t\tr = rfbProcessEvents(screen, usec);\n\t\tif (r) {\n\t\t\tres = 1;\n\t\t}\n\t}\n\n \tif (unixpw && unixpw_in_progress && !uip0) {\n\t\tif (!unixpw_in_rfbPE) {\n\t\t\trfbLog(\"rfbPE: got new client in non-rfbPE\\n\");\n\t\t\t;\t/* this is new unixpw client  */\n\t\t}\n \t}\n\n\tif (ipv6_listen) {\n\t\tcheck_ipv6_listen(usec);\n\t}\n\tif (unix_sock) {\n\t\tcheck_unix_sock(usec);\n\t}\n\tif (check_rate != 0) {\n\t\tif (check_rate < 0) {\n\t\t\tif (getenv(\"CHECK_RATE\")) {\n\t\t\t\tcheck_rate = 1;\n\t\t\t} else {\n\t\t\t\tcheck_rate = 0;\n\t\t\t}\n\t\t}\n\t\tif (check_rate && !all_input && x11vnc_current < last_client + 45)  {\n\t\t\tcheck_allinput_rate();\n\t\t}\n\t}\n\tif (all_input) {\n\t\tdo_allinput(usec);\n\t}\n\treturn res;\n}",
          "includes": [
            "#include \"connections.h\"",
            "#include \"unixpw.h\"",
            "#include \"win_utils.h\"",
            "#include \"cleanup.h\"",
            "#include \"x11vnc.h\"",
            "#include <stdlib.h>"
          ],
          "macros_used": [
            "#define USEC_MAX 999999\t\t/* libvncsever assumes < 1 second */"
          ],
          "globals_used": [
            "int nfix(int i, int n);",
            "int nabs(int n);",
            "double dnow(void);",
            "int rfbPE(long usec);",
            "void rfbCFD(long usec);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"connections.h\"\n#include \"unixpw.h\"\n#include \"win_utils.h\"\n#include \"cleanup.h\"\n#include \"x11vnc.h\"\n#include <stdlib.h>\n\n#define USEC_MAX 999999\t\t/* libvncsever assumes < 1 second */\n\nint nfix(int i, int n);\nint nabs(int n);\ndouble dnow(void);\nint rfbPE(long usec);\nvoid rfbCFD(long usec);\n\nint rfbPE(long usec) {\n\tint uip0 = unixpw_in_progress;\n\tstatic int check_rate = -1;\n\tint res = 0;\n\tif (! screen) {\n\t\treturn res;\n\t}\n \tif (unixpw && unixpw_in_progress && !unixpw_in_rfbPE) {\n\t\trfbLog(\"unixpw_in_rfbPE: skipping rfbPE\\n\");\n \t\treturn res;\n \t}\n\n\tif (debug_tiles > 2) {\n\t\tdouble tm = dnow();\n\t\tfprintf(stderr, \"rfbPE(%d)  t: %.4f\\n\",\n\t\t    (int) usec, tm - x11vnc_start);\n\t}\n\n\tif (usec > USEC_MAX) {\n\t\tusec = USEC_MAX;\n\t}\n\tif (! use_threads) {\n\t\trfbBool r;\n\t\tr = rfbProcessEvents(screen, usec);\n\t\tif (r) {\n\t\t\tres = 1;\n\t\t}\n\t}\n\n \tif (unixpw && unixpw_in_progress && !uip0) {\n\t\tif (!unixpw_in_rfbPE) {\n\t\t\trfbLog(\"rfbPE: got new client in non-rfbPE\\n\");\n\t\t\t;\t/* this is new unixpw client  */\n\t\t}\n \t}\n\n\tif (ipv6_listen) {\n\t\tcheck_ipv6_listen(usec);\n\t}\n\tif (unix_sock) {\n\t\tcheck_unix_sock(usec);\n\t}\n\tif (check_rate != 0) {\n\t\tif (check_rate < 0) {\n\t\t\tif (getenv(\"CHECK_RATE\")) {\n\t\t\t\tcheck_rate = 1;\n\t\t\t} else {\n\t\t\t\tcheck_rate = 0;\n\t\t\t}\n\t\t}\n\t\tif (check_rate && !all_input && x11vnc_current < last_client + 45)  {\n\t\t\tcheck_allinput_rate();\n\t\t}\n\t}\n\tif (all_input) {\n\t\tdo_allinput(usec);\n\t}\n\treturn res;\n}"
        }
      },
      {
        "call_info": {
          "callee": "usleep",
          "args": [
            "10 * 1000"
          ],
          "line": 1641
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "check_openssl",
          "args": [],
          "line": 1637
        },
        "resolved": true,
        "details": {
          "function_name": "check_openssl",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/sslhelper.c",
          "lines": "2689-2744",
          "snippet": "void check_openssl(void) {\n\tfd_set fds;\n\tstruct timeval tv;\n\tint nfds, nmax = openssl_sock;\n\tstatic time_t last_waitall = 0;\n\tstatic double last_check = 0.0;\n\tdouble now;\n\n\tif (! use_openssl) {\n\t\treturn;\n\t}\n\n\tif (time(NULL) > last_waitall + 120) {\n\t\tlast_waitall = time(NULL);\n\t\tssl_helper_pid(0, -2);\t/* waitall */\n\t}\n\n\tif (openssl_sock < 0 && openssl_sock6 < 0) {\n\t\treturn;\n\t}\n\n\tnow = dnow();\n\tif (now < last_check + 0.5) {\n\t\treturn;\n\t}\n\tlast_check = now;\n\n\tFD_ZERO(&fds);\n\tif (openssl_sock >= 0) {\n\t\tFD_SET(openssl_sock, &fds);\n\t}\n\tif (openssl_sock6 >= 0) {\n\t\tFD_SET(openssl_sock6, &fds);\n\t\tif (openssl_sock6 > openssl_sock) {\n\t\t\tnmax = openssl_sock6;\n\t\t}\n\t}\n\n\ttv.tv_sec = 0;\n\ttv.tv_usec = 0;\n\n\tnfds = select(nmax+1, &fds, NULL, NULL, &tv);\n\n\tif (nfds <= 0) {\n\t\treturn;\n\t}\n\n\tif (openssl_sock >= 0 && FD_ISSET(openssl_sock, &fds)) {\n\t\trfbLog(\"SSL: accept_openssl(OPENSSL_VNC)\\n\");\n\t\taccept_openssl(OPENSSL_VNC, -1);\n\t}\n\tif (openssl_sock6 >= 0 && FD_ISSET(openssl_sock6, &fds)) {\n\t\trfbLog(\"SSL: accept_openssl(OPENSSL_VNC6)\\n\");\n\t\taccept_openssl(OPENSSL_VNC6, -1);\n\t}\n}",
          "includes": [
            "#include <openssl/rand.h>",
            "#include <openssl/err.h>",
            "#include <openssl/ssl.h>",
            "#include \"user.h\"",
            "#include \"unixpw.h\"",
            "#include \"sslcmds.h\"",
            "#include \"connections.h\"",
            "#include \"scan.h\"",
            "#include \"screen.h\"",
            "#include \"cleanup.h\"",
            "#include \"inet.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [
            "#define OPENSSL_VNC6    3",
            "#define OPENSSL_VNC     2"
          ],
          "globals_used": [
            "int openssl_sock = -1;",
            "int openssl_sock6 = -1;",
            "void check_openssl(void);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <openssl/rand.h>\n#include <openssl/err.h>\n#include <openssl/ssl.h>\n#include \"user.h\"\n#include \"unixpw.h\"\n#include \"sslcmds.h\"\n#include \"connections.h\"\n#include \"scan.h\"\n#include \"screen.h\"\n#include \"cleanup.h\"\n#include \"inet.h\"\n#include \"x11vnc.h\"\n\n#define OPENSSL_VNC6    3\n#define OPENSSL_VNC     2\n\nint openssl_sock = -1;\nint openssl_sock6 = -1;\nvoid check_openssl(void);\n\nvoid check_openssl(void) {\n\tfd_set fds;\n\tstruct timeval tv;\n\tint nfds, nmax = openssl_sock;\n\tstatic time_t last_waitall = 0;\n\tstatic double last_check = 0.0;\n\tdouble now;\n\n\tif (! use_openssl) {\n\t\treturn;\n\t}\n\n\tif (time(NULL) > last_waitall + 120) {\n\t\tlast_waitall = time(NULL);\n\t\tssl_helper_pid(0, -2);\t/* waitall */\n\t}\n\n\tif (openssl_sock < 0 && openssl_sock6 < 0) {\n\t\treturn;\n\t}\n\n\tnow = dnow();\n\tif (now < last_check + 0.5) {\n\t\treturn;\n\t}\n\tlast_check = now;\n\n\tFD_ZERO(&fds);\n\tif (openssl_sock >= 0) {\n\t\tFD_SET(openssl_sock, &fds);\n\t}\n\tif (openssl_sock6 >= 0) {\n\t\tFD_SET(openssl_sock6, &fds);\n\t\tif (openssl_sock6 > openssl_sock) {\n\t\t\tnmax = openssl_sock6;\n\t\t}\n\t}\n\n\ttv.tv_sec = 0;\n\ttv.tv_usec = 0;\n\n\tnfds = select(nmax+1, &fds, NULL, NULL, &tv);\n\n\tif (nfds <= 0) {\n\t\treturn;\n\t}\n\n\tif (openssl_sock >= 0 && FD_ISSET(openssl_sock, &fds)) {\n\t\trfbLog(\"SSL: accept_openssl(OPENSSL_VNC)\\n\");\n\t\taccept_openssl(OPENSSL_VNC, -1);\n\t}\n\tif (openssl_sock6 >= 0 && FD_ISSET(openssl_sock6, &fds)) {\n\t\trfbLog(\"SSL: accept_openssl(OPENSSL_VNC6)\\n\");\n\t\taccept_openssl(OPENSSL_VNC6, -1);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"wait_for_client: %d\\n\"",
            "i"
          ],
          "line": 1615
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "usleep",
          "args": [
            "20 * 1000"
          ],
          "line": 1614
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clean_up_exit",
          "args": [
            "0"
          ],
          "line": 1612
        },
        "resolved": true,
        "details": {
          "function_name": "clean_up_exit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/cleanup.c",
          "lines": "151-266",
          "snippet": "void clean_up_exit(int ret) {\n\tstatic int depth = 0;\n\texit_flag = 1;\n\n\tif (depth++ > 2) {\n\t\texit(ret);\n\t}\n\n\tif (icon_mode) {\n\t\tclean_icon_mode();\n\t}\n\n\t/* remove the shm areas: */\n\tclean_shm(0);\n\n\tstop_stunnel();\n\tif (use_openssl) {\n\t\tssl_helper_pid(0, 0);\t/* killall */\n\t}\n\n\tif (ssh_pid > 0) {\n\t\tkill(ssh_pid, SIGTERM);\n\t\tssh_pid = 0;\n\t}\n\n#ifdef MACOSX\n\tif (client_connect_file) {\n\t\tif (strstr(client_connect_file, \"/tmp/x11vnc-macosx-remote\")\n\t\t    == client_connect_file) {\n\t\t\tunlink(client_connect_file);\n\t\t}\n\t}\n\tif (macosx_console) {\n\t\tmacosxCG_fini();\n\t}\n#endif\n\n\tif (pipeinput_fh != NULL) {\n\t\tpclose(pipeinput_fh);\n\t\tpipeinput_fh = NULL;\n\t}\n\n\tshutdown_uinput();\n\n\tif (unix_sock) {\n\t\tif (unix_sock_fd >= 0) {\n\t\t\trfbLog(\"deleting unix sock: %s\\n\", unix_sock);\n\t\t\tclose(unix_sock_fd);\n\t\t\tunix_sock_fd = -1;\n\t\t\tunlink(unix_sock);\n\t\t}\n\t}\n\n\tif (! dpy) {\t/* raw_rb hack */\n\t\tif (rm_flagfile) {\n\t\t\tunlink(rm_flagfile);\n\t\t\trm_flagfile = NULL;\n\t\t}\n\t\texit(ret);\n\t}\n\n\t/* X keyboard cleanups */\n\tdelete_added_keycodes(0);\n\n\t/* remove all created XInput2 devices */\n\tif(use_multipointer)\n\t    removeAllMDs(dpy);\n\n\tif (clear_mods == 1) {\n\t\tclear_modifiers(0);\n\t} else if (clear_mods == 2) {\n\t\tclear_keys();\n\t} else if (clear_mods == 3) {\n\t\tclear_keys();\n\t\tclear_locks();\n\t}\n\n\tif (no_autorepeat) {\n\t\tautorepeat(1, 0);\n\t}\n\tif (use_solid_bg) {\n\t\tsolid_bg(1);\n\t}\n\tif (ncache || ncache0) {\n\t\tkde_no_animate(1);\n\t}\n\tX_LOCK;\n\tXTestDiscard_wr(dpy);\n#if HAVE_LIBXDAMAGE\n\tif (xdamage) {\n\t\tXDamageDestroy(dpy, xdamage);\n\t}\n#endif\n#if HAVE_LIBXTRAP\n\tif (trap_ctx) {\n\t\tXEFreeTC(trap_ctx);\n\t}\n#endif\n\t/* XXX rdpy_ctrl, etc. cannot close w/o blocking */\n\tXCloseDisplay_wr(dpy);\n\tX_UNLOCK;\n\n\tfflush(stderr);\n\n\tif (rm_flagfile) {\n\t\tunlink(rm_flagfile);\n\t\trm_flagfile = NULL;\n\t}\n\n\tif (avahi) {\n\t\tavahi_cleanup();\n\t\tfflush(stderr);\n\t}\n\n\texit(ret);\n}",
          "includes": [
            "#include \"xi2_devices.h\"",
            "#include \"uinput.h\"",
            "#include \"xevents.h\"",
            "#include \"xrecord.h\"",
            "#include \"screen.h\"",
            "#include \"avahi.h\"",
            "#include \"macosxCG.h\"",
            "#include \"macosx.h\"",
            "#include \"connections.h\"",
            "#include \"sslhelper.h\"",
            "#include \"sslcmds.h\"",
            "#include \"unixpw.h\"",
            "#include \"solid.h\"",
            "#include \"gui.h\"",
            "#include \"scan.h\"",
            "#include \"keyboard.h\"",
            "#include \"remote.h\"",
            "#include \"xdamage.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void clean_up_exit(int ret);",
            "int known_sigpipe_mode(char *s);",
            "static int exit_flag = 0;",
            "static void clean_icon_mode(void);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xi2_devices.h\"\n#include \"uinput.h\"\n#include \"xevents.h\"\n#include \"xrecord.h\"\n#include \"screen.h\"\n#include \"avahi.h\"\n#include \"macosxCG.h\"\n#include \"macosx.h\"\n#include \"connections.h\"\n#include \"sslhelper.h\"\n#include \"sslcmds.h\"\n#include \"unixpw.h\"\n#include \"solid.h\"\n#include \"gui.h\"\n#include \"scan.h\"\n#include \"keyboard.h\"\n#include \"remote.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nvoid clean_up_exit(int ret);\nint known_sigpipe_mode(char *s);\nstatic int exit_flag = 0;\nstatic void clean_icon_mode(void);\n\nvoid clean_up_exit(int ret) {\n\tstatic int depth = 0;\n\texit_flag = 1;\n\n\tif (depth++ > 2) {\n\t\texit(ret);\n\t}\n\n\tif (icon_mode) {\n\t\tclean_icon_mode();\n\t}\n\n\t/* remove the shm areas: */\n\tclean_shm(0);\n\n\tstop_stunnel();\n\tif (use_openssl) {\n\t\tssl_helper_pid(0, 0);\t/* killall */\n\t}\n\n\tif (ssh_pid > 0) {\n\t\tkill(ssh_pid, SIGTERM);\n\t\tssh_pid = 0;\n\t}\n\n#ifdef MACOSX\n\tif (client_connect_file) {\n\t\tif (strstr(client_connect_file, \"/tmp/x11vnc-macosx-remote\")\n\t\t    == client_connect_file) {\n\t\t\tunlink(client_connect_file);\n\t\t}\n\t}\n\tif (macosx_console) {\n\t\tmacosxCG_fini();\n\t}\n#endif\n\n\tif (pipeinput_fh != NULL) {\n\t\tpclose(pipeinput_fh);\n\t\tpipeinput_fh = NULL;\n\t}\n\n\tshutdown_uinput();\n\n\tif (unix_sock) {\n\t\tif (unix_sock_fd >= 0) {\n\t\t\trfbLog(\"deleting unix sock: %s\\n\", unix_sock);\n\t\t\tclose(unix_sock_fd);\n\t\t\tunix_sock_fd = -1;\n\t\t\tunlink(unix_sock);\n\t\t}\n\t}\n\n\tif (! dpy) {\t/* raw_rb hack */\n\t\tif (rm_flagfile) {\n\t\t\tunlink(rm_flagfile);\n\t\t\trm_flagfile = NULL;\n\t\t}\n\t\texit(ret);\n\t}\n\n\t/* X keyboard cleanups */\n\tdelete_added_keycodes(0);\n\n\t/* remove all created XInput2 devices */\n\tif(use_multipointer)\n\t    removeAllMDs(dpy);\n\n\tif (clear_mods == 1) {\n\t\tclear_modifiers(0);\n\t} else if (clear_mods == 2) {\n\t\tclear_keys();\n\t} else if (clear_mods == 3) {\n\t\tclear_keys();\n\t\tclear_locks();\n\t}\n\n\tif (no_autorepeat) {\n\t\tautorepeat(1, 0);\n\t}\n\tif (use_solid_bg) {\n\t\tsolid_bg(1);\n\t}\n\tif (ncache || ncache0) {\n\t\tkde_no_animate(1);\n\t}\n\tX_LOCK;\n\tXTestDiscard_wr(dpy);\n#if HAVE_LIBXDAMAGE\n\tif (xdamage) {\n\t\tXDamageDestroy(dpy, xdamage);\n\t}\n#endif\n#if HAVE_LIBXTRAP\n\tif (trap_ctx) {\n\t\tXEFreeTC(trap_ctx);\n\t}\n#endif\n\t/* XXX rdpy_ctrl, etc. cannot close w/o blocking */\n\tXCloseDisplay_wr(dpy);\n\tX_UNLOCK;\n\n\tfflush(stderr);\n\n\tif (rm_flagfile) {\n\t\tunlink(rm_flagfile);\n\t\trm_flagfile = NULL;\n\t}\n\n\tif (avahi) {\n\t\tavahi_cleanup();\n\t\tfflush(stderr);\n\t}\n\n\texit(ret);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"taking unixpw_client off hold\\n\""
          ],
          "line": 1606
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"unixpw but no unixpw_in_progress\\n\""
          ],
          "line": 1602
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "usleep",
          "args": [
            "10 * 1000"
          ],
          "line": 1594
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "check_https",
          "args": [],
          "line": 1587
        },
        "resolved": true,
        "details": {
          "function_name": "check_https",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/sslhelper.c",
          "lines": "2746-2791",
          "snippet": "void check_https(void) {\n\tfd_set fds;\n\tstruct timeval tv;\n\tint nfds, nmax = https_sock;\n\tstatic double last_check = 0.0;\n\tdouble now;\n\n\tif (! use_openssl || (https_sock < 0 && https_sock6 < 0)) {\n\t\treturn;\n\t}\n\n\tnow = dnow();\n\tif (now < last_check + 0.5) {\n\t\treturn;\n\t}\n\tlast_check = now;\n\n\tFD_ZERO(&fds);\n\tif (https_sock >= 0) {\n\t\tFD_SET(https_sock, &fds);\n\t}\n\tif (https_sock6 >= 0) {\n\t\tFD_SET(https_sock6, &fds);\n\t\tif (https_sock6 > https_sock) {\n\t\t\tnmax = https_sock6;\n\t\t}\n\t}\n\n\ttv.tv_sec = 0;\n\ttv.tv_usec = 0;\n\n\tnfds = select(nmax+1, &fds, NULL, NULL, &tv);\n\n\tif (nfds <= 0) {\n\t\treturn;\n\t}\n\n\tif (https_sock >= 0 && FD_ISSET(https_sock, &fds)) {\n\t\trfbLog(\"SSL: accept_openssl(OPENSSL_HTTPS)\\n\");\n\t\taccept_openssl(OPENSSL_HTTPS, -1);\n\t}\n\tif (https_sock6 >= 0 && FD_ISSET(https_sock6, &fds)) {\n\t\trfbLog(\"SSL: accept_openssl(OPENSSL_HTTPS6)\\n\");\n\t\taccept_openssl(OPENSSL_HTTPS6, -1);\n\t}\n}",
          "includes": [
            "#include <openssl/rand.h>",
            "#include <openssl/err.h>",
            "#include <openssl/ssl.h>",
            "#include \"user.h\"",
            "#include \"unixpw.h\"",
            "#include \"sslcmds.h\"",
            "#include \"connections.h\"",
            "#include \"scan.h\"",
            "#include \"screen.h\"",
            "#include \"cleanup.h\"",
            "#include \"inet.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [
            "#define OPENSSL_HTTPS6  5",
            "#define OPENSSL_HTTPS   4"
          ],
          "globals_used": [
            "int https_sock = -1;",
            "int https_sock6 = -1;",
            "void check_https(void);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <openssl/rand.h>\n#include <openssl/err.h>\n#include <openssl/ssl.h>\n#include \"user.h\"\n#include \"unixpw.h\"\n#include \"sslcmds.h\"\n#include \"connections.h\"\n#include \"scan.h\"\n#include \"screen.h\"\n#include \"cleanup.h\"\n#include \"inet.h\"\n#include \"x11vnc.h\"\n\n#define OPENSSL_HTTPS6  5\n#define OPENSSL_HTTPS   4\n\nint https_sock = -1;\nint https_sock6 = -1;\nvoid check_https(void);\n\nvoid check_https(void) {\n\tfd_set fds;\n\tstruct timeval tv;\n\tint nfds, nmax = https_sock;\n\tstatic double last_check = 0.0;\n\tdouble now;\n\n\tif (! use_openssl || (https_sock < 0 && https_sock6 < 0)) {\n\t\treturn;\n\t}\n\n\tnow = dnow();\n\tif (now < last_check + 0.5) {\n\t\treturn;\n\t}\n\tlast_check = now;\n\n\tFD_ZERO(&fds);\n\tif (https_sock >= 0) {\n\t\tFD_SET(https_sock, &fds);\n\t}\n\tif (https_sock6 >= 0) {\n\t\tFD_SET(https_sock6, &fds);\n\t\tif (https_sock6 > https_sock) {\n\t\t\tnmax = https_sock6;\n\t\t}\n\t}\n\n\ttv.tv_sec = 0;\n\ttv.tv_usec = 0;\n\n\tnfds = select(nmax+1, &fds, NULL, NULL, &tv);\n\n\tif (nfds <= 0) {\n\t\treturn;\n\t}\n\n\tif (https_sock >= 0 && FD_ISSET(https_sock, &fds)) {\n\t\trfbLog(\"SSL: accept_openssl(OPENSSL_HTTPS)\\n\");\n\t\taccept_openssl(OPENSSL_HTTPS, -1);\n\t}\n\tif (https_sock6 >= 0 && FD_ISSET(https_sock6, &fds)) {\n\t\trfbLog(\"SSL: accept_openssl(OPENSSL_HTTPS6)\\n\");\n\t\taccept_openssl(OPENSSL_HTTPS6, -1);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "enc_str",
            "\"none\""
          ],
          "line": 1584
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"no client connect after %d seconds.\\n\"",
            "first_conn_timeout"
          ],
          "line": 1566
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "time",
          "args": [
            "NULL"
          ],
          "line": 1565
        },
        "resolved": true,
        "details": {
          "function_name": "vnc_redirect_timeout",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/user.c",
          "lines": "1395-1399",
          "snippet": "static void vnc_redirect_timeout (int sig) {\n\twrite(2, \"timeout: no clients connected.\\n\", 31);\n\tif (sig) {};\n\texit(0);\n}",
          "includes": [
            "#include \"avahi.h\"",
            "#include \"sslhelper.h\"",
            "#include \"remote.h\"",
            "#include \"cursor.h\"",
            "#include \"keyboard.h\"",
            "#include \"inet.h\"",
            "#include \"connections.h\"",
            "#include \"xwrappers.h\"",
            "#include \"sslhelper.h\"",
            "#include \"unixpw.h\"",
            "#include \"screen.h\"",
            "#include \"scan.h\"",
            "#include \"cleanup.h\"",
            "#include \"solid.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"avahi.h\"\n#include \"sslhelper.h\"\n#include \"remote.h\"\n#include \"cursor.h\"\n#include \"keyboard.h\"\n#include \"inet.h\"\n#include \"connections.h\"\n#include \"xwrappers.h\"\n#include \"sslhelper.h\"\n#include \"unixpw.h\"\n#include \"screen.h\"\n#include \"scan.h\"\n#include \"cleanup.h\"\n#include \"solid.h\"\n#include \"x11vnc.h\"\n\nstatic void vnc_redirect_timeout (int sig) {\n\twrite(2, \"timeout: no clients connected.\\n\", 31);\n\tif (sig) {};\n\texit(0);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"avahi.h\"\n#include \"sslhelper.h\"\n#include \"remote.h\"\n#include \"cursor.h\"\n#include \"keyboard.h\"\n#include \"inet.h\"\n#include \"connections.h\"\n#include \"xwrappers.h\"\n#include \"sslhelper.h\"\n#include \"unixpw.h\"\n#include \"screen.h\"\n#include \"scan.h\"\n#include \"cleanup.h\"\n#include \"solid.h\"\n#include \"x11vnc.h\"\n\nstatic void loop_for_connect(int did_client_connect) {\n\tint loop = 0;\n\ttime_t start = time(NULL);\n\n\tif (first_conn_timeout < 0) {\n\t\tfirst_conn_timeout = -first_conn_timeout;\n\t}\n\n\twhile (1) {\n\t\tloop++;\n\t\tif (first_conn_timeout && time(NULL) > start + first_conn_timeout) {\n\t\t\trfbLog(\"no client connect after %d seconds.\\n\", first_conn_timeout);\n\t\t\tshut_down = 1;\n\t\t}\n\t\tif (shut_down) {\n\t\t\tclean_up_exit(0);\n\t\t}\n\t\tif (loop < 2) {\n\t\t\tif (did_client_connect) {\n\t\t\t\tgoto screen_check;\n\t\t\t}\n\t\t\tif (inetd) {\n\t\t\t\tgoto screen_check;\n\t\t\t}\n\t\t\tif (screen && screen->clientHead) {\n\t\t\t\tgoto screen_check;\n\t\t\t}\n\t\t}\n\t\tif ((use_openssl || use_stunnel) && !inetd) {\n\t\t\tint enc_none = (enc_str && !strcmp(enc_str, \"none\"));\n\t\t\tif (!use_stunnel || enc_none) {\n\t\t\t\tcheck_openssl();\n\t\t\t\tcheck_https();\n\t\t\t}\n\t\t\t/*\n\t\t\t * This is to handle an initial verify cert from viewer,\n\t\t\t * they disconnect right after fetching the cert.\n\t\t\t */\n\t\t\tif (use_threads) {\n\t\t\t\tusleep(10 * 1000);\n\t\t\t} else {\n\t\t\t\trfbPE(-1);\n\t\t\t}\n\t\t\tif (screen && screen->clientHead) {\n\t\t\t\tint i;\n\t\t\t\tif (unixpw) {\n\t\t\t\t\tif (! unixpw_in_progress && !vencrypt_enable_plain_login) {\n\t\t\t\t\t\trfbLog(\"unixpw but no unixpw_in_progress\\n\");\n\t\t\t\t\t\tclean_up_exit(1);\n\t\t\t\t\t}\n\t\t\t\t\tif (unixpw_client && unixpw_client->onHold) {\n\t\t\t\t\t\trfbLog(\"taking unixpw_client off hold\\n\");\n\t\t\t\t\t\tunixpw_client->onHold = FALSE;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfor (i=0; i<10; i++) {\n\t\t\t\t\tif (shut_down) {\n\t\t\t\t\t\tclean_up_exit(0);\n\t\t\t\t\t}\n\t\t\t\t\tusleep(20 * 1000);\n\t\t\t\t\tif (0) rfbLog(\"wait_for_client: %d\\n\", i);\n\n\t\t\t\t\tif (! use_threads) {\n\t\t\t\t\t\tif (unixpw) {\n\t\t\t\t\t\t\tunixpw_in_rfbPE = 1;\n\t\t\t\t\t\t}\n\t\t\t\t\t\trfbPE(-1);\n\t\t\t\t\t\tif (unixpw) {\n\t\t\t\t\t\t\tunixpw_in_rfbPE = 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif (unixpw && !unixpw_in_progress) {\n\t\t\t\t\t\t/* XXX too soon. */\n\t\t\t\t\t\tgoto screen_check;\n\t\t\t\t\t}\n\t\t\t\t\tif (!screen->clientHead) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (use_openssl) {\n\t\t\tcheck_openssl();\n\t\t}\n\n\t\tif (use_threads) {\n\t\t\tusleep(10 * 1000);\n\t\t} else {\n\t\t\trfbPE(-1);\n\t\t}\n\n\t\tscreen_check:\n\t\tif (! screen || ! screen->clientHead) {\n\t\t\tusleep(100 * 1000);\n\t\t\tcontinue;\n\t\t}\n\n\t\trfbLog(\"wait_for_client: got client\\n\");\n\t\tbreak;\n\t}\n}"
  },
  {
    "function_name": "setup_client_connect",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/user.c",
    "lines": "1520-1553",
    "snippet": "static void setup_client_connect(int *did_client_connect) {\n\tif (client_connect != NULL) {\n\t\tchar *remainder = NULL;\n\t\tif (inetd) {\n\t\t\trfbLog(\"wait_for_client: -connect disallowed in inetd mode: %s\\n\",\n\t\t\t    client_connect);\n\t\t} else if (screen && screen->clientHead) {\n\t\t\trfbLog(\"wait_for_client: -connect disallowed: client exists: %s\\n\",\n\t\t\t    client_connect);\n\t\t} else if (strchr(client_connect, '=')) {\n\t\t\trfbLog(\"wait_for_client: invalid -connect string: %s\\n\",\n\t\t\t    client_connect);\n\t\t} else {\n\t\t\tchar *q = strchr(client_connect, ',');\n\t\t\tif (q) {\n\t\t\t\trfbLog(\"wait_for_client: only using first\"\n\t\t\t\t    \" connect host in: %s\\n\", client_connect);\n\t\t\t\tremainder = strdup(q+1);\n\t\t\t\t*q = '\\0';\n\t\t\t}\n\t\t\trfbLog(\"wait_for_client: reverse_connect(%s)\\n\",\n\t\t\t    client_connect);\n\t\t\treverse_connect(client_connect);\n\t\t\t*did_client_connect = 1;\n\t\t}\n\t\tfree(client_connect);\n\t\tif (remainder != NULL) {\n\t\t\t/* reset to host2,host3,... */\n\t\t\tclient_connect = remainder;\n\t\t} else {\n\t\t\tclient_connect = NULL;\n\t\t}\n\t}\n}",
    "includes": [
      "#include \"avahi.h\"",
      "#include \"sslhelper.h\"",
      "#include \"remote.h\"",
      "#include \"cursor.h\"",
      "#include \"keyboard.h\"",
      "#include \"inet.h\"",
      "#include \"connections.h\"",
      "#include \"xwrappers.h\"",
      "#include \"sslhelper.h\"",
      "#include \"unixpw.h\"",
      "#include \"screen.h\"",
      "#include \"scan.h\"",
      "#include \"cleanup.h\"",
      "#include \"solid.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "client_connect"
          ],
          "line": 1545
        },
        "resolved": true,
        "details": {
          "function_name": "free_rect",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/userinput.c",
          "lines": "6200-6247",
          "snippet": "int free_rect(int idx) {\n\tint n, ok = 0;\n\tsraRegionPtr r1, r2;\n\tint x, y, w, h;\n\n\tif (idx < 0 || idx >= cache_list_num) {\nif (0) fprintf(stderr, \"free_rect: bad index: %d\\n\", idx);\n\t\tclean_up_exit(1);\n\t}\n\n\tx = cache_list[idx].bs_x;\n\ty = cache_list[idx].bs_y;\n\tw = cache_list[idx].bs_w;\n\th = cache_list[idx].bs_h;\n\n\tif (x < 0) {\n\t\tCLEAR(idx);\nif (dnow() > last_client + 5 && ncdb) fprintf(stderr, \"free_rect: already bs_x invalidated: %d bs_x: %d\\n\", idx, x);\n\t\treturn 1;\n\t}\n\n\tr2 = sraRgnCreateRect(x, y, x+w, y+h);\n\n\tn = get_bs_n(y);\n\tif (n >= 0) {\n\t\tr1 = rect_reg[n];\n\t\tsraRgnOr(r1, r2);\n\t\tok = 1;\n\t}\n\n\tif (zero_rects) {\n\t\tsraRgnOr(zero_rects, r2);\n\t\tx = cache_list[idx].su_x;\n\t\ty = cache_list[idx].su_y;\n\t\tw = cache_list[idx].su_w;\n\t\th = cache_list[idx].su_h;\n\t\tif (x >= 0) {\n\t\t\tsraRgnDestroy(r2);\n\t\t\tr2 = sraRgnCreateRect(x, y, x+w, y+h);\n\t\t\tsraRgnOr(zero_rects, r2);\n\t\t}\n\t}\n\tsraRgnDestroy(r2);\n\n\tCLEAR(idx);\nif (! ok && ncdb) fprintf(stderr, \"**** free_rect: not-found %d\\n\", idx);\n\treturn ok;\n}",
          "includes": [
            "#include \"default8x16.h\"",
            "#include \"connections.h\"",
            "#include \"screen.h\"",
            "#include \"cursor.h\"",
            "#include \"macosxCGS.h\"",
            "#include \"macosx.h\"",
            "#include \"unixpw.h\"",
            "#include \"8to24.h\"",
            "#include \"xrandr.h\"",
            "#include \"solid.h\"",
            "#include \"keyboard.h\"",
            "#include \"rates.h\"",
            "#include \"pointer.h\"",
            "#include \"cleanup.h\"",
            "#include \"scan.h\"",
            "#include \"user.h\"",
            "#include \"xevents.h\"",
            "#include \"win_utils.h\"",
            "#include \"xinerama.h\"",
            "#include \"xrecord.h\"",
            "#include \"xdamage.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void mark_for_xdamage(int x, int y, int w, int h);",
            "void set_xdamage_mark(int x, int y, int w, int h);",
            "int find_rect(int idx, int x, int y, int w, int h);",
            "winattr_t *cache_list;",
            "int clipped(int idx);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"default8x16.h\"\n#include \"connections.h\"\n#include \"screen.h\"\n#include \"cursor.h\"\n#include \"macosxCGS.h\"\n#include \"macosx.h\"\n#include \"unixpw.h\"\n#include \"8to24.h\"\n#include \"xrandr.h\"\n#include \"solid.h\"\n#include \"keyboard.h\"\n#include \"rates.h\"\n#include \"pointer.h\"\n#include \"cleanup.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"xevents.h\"\n#include \"win_utils.h\"\n#include \"xinerama.h\"\n#include \"xrecord.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nvoid mark_for_xdamage(int x, int y, int w, int h);\nvoid set_xdamage_mark(int x, int y, int w, int h);\nint find_rect(int idx, int x, int y, int w, int h);\nwinattr_t *cache_list;\nint clipped(int idx);\n\nint free_rect(int idx) {\n\tint n, ok = 0;\n\tsraRegionPtr r1, r2;\n\tint x, y, w, h;\n\n\tif (idx < 0 || idx >= cache_list_num) {\nif (0) fprintf(stderr, \"free_rect: bad index: %d\\n\", idx);\n\t\tclean_up_exit(1);\n\t}\n\n\tx = cache_list[idx].bs_x;\n\ty = cache_list[idx].bs_y;\n\tw = cache_list[idx].bs_w;\n\th = cache_list[idx].bs_h;\n\n\tif (x < 0) {\n\t\tCLEAR(idx);\nif (dnow() > last_client + 5 && ncdb) fprintf(stderr, \"free_rect: already bs_x invalidated: %d bs_x: %d\\n\", idx, x);\n\t\treturn 1;\n\t}\n\n\tr2 = sraRgnCreateRect(x, y, x+w, y+h);\n\n\tn = get_bs_n(y);\n\tif (n >= 0) {\n\t\tr1 = rect_reg[n];\n\t\tsraRgnOr(r1, r2);\n\t\tok = 1;\n\t}\n\n\tif (zero_rects) {\n\t\tsraRgnOr(zero_rects, r2);\n\t\tx = cache_list[idx].su_x;\n\t\ty = cache_list[idx].su_y;\n\t\tw = cache_list[idx].su_w;\n\t\th = cache_list[idx].su_h;\n\t\tif (x >= 0) {\n\t\t\tsraRgnDestroy(r2);\n\t\t\tr2 = sraRgnCreateRect(x, y, x+w, y+h);\n\t\t\tsraRgnOr(zero_rects, r2);\n\t\t}\n\t}\n\tsraRgnDestroy(r2);\n\n\tCLEAR(idx);\nif (! ok && ncdb) fprintf(stderr, \"**** free_rect: not-found %d\\n\", idx);\n\treturn ok;\n}"
        }
      },
      {
        "call_info": {
          "callee": "reverse_connect",
          "args": [
            "client_connect"
          ],
          "line": 1542
        },
        "resolved": true,
        "details": {
          "function_name": "reverse_connect",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/connections.c",
          "lines": "2853-3026",
          "snippet": "void reverse_connect(char *str) {\n\tchar *p, *tmp;\n\tint sleep_between_host = 300;\n\tint sleep_min = 1500, sleep_max = 4500, n_max = 5;\n\tint n, tot, t, dt = 100, cnt = 0;\n\tint nclients0 = client_count;\n\tint lcnt, j;\n\tchar **list;\n\tint do_appshare = 0;\n\n\tif (!getenv(\"X11VNC_REVERSE_USE_OLD_SLEEP\")) {\n\t\tsleep_min = 500;\n\t\tsleep_max = 2500;\n\t}\n\n\tif (unixpw_in_progress) return;\n\n\ttmp = strdup(str);\n\n\tlist = (char **) calloc( (strlen(tmp)+2) * sizeof (char *), 1);\n\tlcnt = 0;\n\n\tp = strtok(tmp, \", \\t\\r\\n\");\n\twhile (p) {\n\t\tlist[lcnt++] = strdup(p);\n\t\tp = strtok(NULL, \", \\t\\r\\n\");\n\t}\n\tfree(tmp);\n\n\tif (subwin && getenv(\"X11VNC_APPSHARE_ACTIVE\")) {\n\t\tdo_appshare = 1;\n\t\tsleep_between_host = 0;\t/* too agressive??? */\n\t}\n\tif (getenv(\"X11VNC_REVERSE_SLEEP_BETWEEN_HOST\")) {\n\t\tsleep_between_host = atoi(getenv(\"X11VNC_REVERSE_SLEEP_BETWEEN_HOST\"));\n\t}\n\n\tif (do_appshare) {\n\t\tif (screen && dpy) {\n\t\t\tchar *s = choose_title(DisplayString(dpy));\n\n\t\t\t/* mutex */\n\t\t\tscreen->desktopName = s;\n\t\t\tif (rfb_desktop_name) {\n\t\t\t\tfree(rfb_desktop_name);\n\t\t\t}\n\t\t\trfb_desktop_name = strdup(s);\n\t\t}\n\t}\n\n\tfor (j = 0; j < lcnt; j++) {\n\t\tp = list[j];\n\t\t\n\t\tif ((n = do_reverse_connect(p)) != 0) {\n\t\t\tint i;\n\t\t\tprogress_client();\n\t\t\tfor (i=0; i < 3; i++) {\n\t\t\t\trfbPE(-1);\n\t\t\t}\n\t\t}\n\t\tcnt += n;\n\t\tif (list[j+1] != NULL) {\n\t\t\tt = 0;\n\t\t\twhile (t < sleep_between_host) {\n\t\t\t\tdouble t1, t2;\n\t\t\t\tint i;\n\t\t\t\tt1 = dnow();\n\t\t\t\tfor (i=0; i < 8; i++) {\n\t\t\t\t\trfbPE(-1);\n\t\t\t\t\tif (do_appshare && t == 0) {\n\t\t\t\t\t\trfbPE(-1);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tt2 = dnow();\n\t\t\t\tt += (int) (1000 * (t2 - t1));\n\t\t\t\tif (t >= sleep_between_host) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tusleep(dt * 1000);\n\t\t\t\tt += dt;\n\t\t\t}\n\t\t}\n\t}\n\n\tfor (j = 0; j < lcnt; j++) {\n\t\tp = list[j];\n\t\tif (p) free(p);\n\t}\n\tfree(list);\n\n\tif (cnt == 0) {\n\t\tif (connect_or_exit) {\n\t\t\trfbLogEnable(1);\n\t\t\trfbLog(\"exiting under -connect_or_exit\\n\");\n\t\t\tif (gui_pid > 0) {\n\t\t\t\trfbLog(\"killing gui_pid %d\\n\", gui_pid);\n\t\t\t\tkill(gui_pid, SIGTERM);\n\t\t\t}\n\t\t\tclean_up_exit(1);\n\t\t}\n\t\tif (xrandr || xrandr_maybe) {\n\t\t\tcheck_xrandr_event(\"reverse_connect1\");\n\t\t}\n\t\treturn;\n\t}\n\n\t/*\n\t * XXX: we need to process some of the initial handshaking\n\t * events, otherwise the client can get messed up (why??) \n\t * so we send rfbProcessEvents() all over the place.\n\t *\n\t * How much is this still needed?\n\t */\n\n\tn = cnt;\n\tif (n >= n_max) {\n\t\tn = n_max; \n\t}\n\tt = sleep_max - sleep_min;\n\ttot = sleep_min + ((n-1) * t) / (n_max-1);\n\n\tif (do_appshare) {\n\t\ttot /= 3;\n\t\tif (tot < dt) {\n\t\t\ttot = dt;\n\t\t}\n\t\ttot = 0;\t/* too agressive??? */\n\t}\n\n\tif (getenv(\"X11VNC_REVERSE_SLEEP_MAX\")) {\n\t\ttot = atoi(getenv(\"X11VNC_REVERSE_SLEEP_MAX\"));\n\t}\n\n\tt = 0;\n\twhile (t < tot) {\n\t\tint i;\n\t\tdouble t1, t2;\n\t\tt1 = dnow();\n\t\tfor (i=0; i < 8; i++) {\n\t\t\trfbPE(-1);\n\t\t\tif (t == 0) rfbPE(-1);\n\t\t}\n\t\tt2 = dnow();\n\t\tt += (int) (1000 * (t2 - t1));\n\t\tif (t >= tot) {\n\t\t\tbreak;\n\t\t}\n\t\tusleep(dt * 1000);\n\t\tt += dt;\n\t}\n\tif (connect_or_exit) {\n\t\tif (client_count <= nclients0)  {\n\t\t\tfor (t = 0; t < 10; t++) {\n\t\t\t\tint i;\n\t\t\t\tfor (i=0; i < 3; i++) {\n\t\t\t\t\trfbPE(-1);\n\t\t\t\t}\n\t\t\t\tusleep(100 * 1000);\n\t\t\t}\n\t\t}\n\t\tif (client_count <= nclients0)  {\n\t\t\trfbLogEnable(1);\n\t\t\trfbLog(\"exiting under -connect_or_exit\\n\");\n\t\t\tif (gui_pid > 0) {\n\t\t\t\trfbLog(\"killing gui_pid %d\\n\", gui_pid);\n\t\t\t\tkill(gui_pid, SIGTERM);\n\t\t\t}\n\t\t\tclean_up_exit(1);\n\t\t}\n\t}\n\tif (xrandr || xrandr_maybe) {\n\t\tcheck_xrandr_event(\"reverse_connect2\");\n\t}\n}",
          "includes": [
            "#include \"xi2_devices.h\"",
            "#include \"xrandr.h\"",
            "#include \"pointer.h\"",
            "#include \"userinput.h\"",
            "#include \"macosxCG.h\"",
            "#include \"macosx.h\"",
            "#include \"win_utils.h\"",
            "#include \"xevents.h\"",
            "#include \"xwrappers.h\"",
            "#include \"sslhelper.h\"",
            "#include \"sslcmds.h\"",
            "#include \"scan.h\"",
            "#include \"user.h\"",
            "#include \"unixpw.h\"",
            "#include \"screen.h\"",
            "#include \"rates.h\"",
            "#include \"solid.h\"",
            "#include \"gui.h\"",
            "#include \"cleanup.h\"",
            "#include \"keyboard.h\"",
            "#include \"remote.h\"",
            "#include \"inet.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int new_fb_size_clients(rfbScreenInfoPtr s);",
            "void close_clients(char *str);",
            "void set_client_input(char *str);",
            "void client_gone(rfbClientPtr client);",
            "void client_gone_chat_helper(rfbClientPtr client);",
            "void reverse_connect(char *str);",
            "void set_vnc_connect_prop(char *str);",
            "void set_x11vnc_remote_prop(char *str);",
            "enum rfbNewClientAction new_client(rfbClientPtr client);",
            "enum rfbNewClientAction new_client_chat_helper(rfbClientPtr client);",
            "void send_client_info(char *str);",
            "int accept_client(rfbClientPtr client);",
            "void client_set_net(rfbClientPtr client);",
            "static rfbClientPtr *client_match(char *str);",
            "static void free_client_data(rfbClientPtr client);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xi2_devices.h\"\n#include \"xrandr.h\"\n#include \"pointer.h\"\n#include \"userinput.h\"\n#include \"macosxCG.h\"\n#include \"macosx.h\"\n#include \"win_utils.h\"\n#include \"xevents.h\"\n#include \"xwrappers.h\"\n#include \"sslhelper.h\"\n#include \"sslcmds.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"unixpw.h\"\n#include \"screen.h\"\n#include \"rates.h\"\n#include \"solid.h\"\n#include \"gui.h\"\n#include \"cleanup.h\"\n#include \"keyboard.h\"\n#include \"remote.h\"\n#include \"inet.h\"\n#include \"x11vnc.h\"\n\nint new_fb_size_clients(rfbScreenInfoPtr s);\nvoid close_clients(char *str);\nvoid set_client_input(char *str);\nvoid client_gone(rfbClientPtr client);\nvoid client_gone_chat_helper(rfbClientPtr client);\nvoid reverse_connect(char *str);\nvoid set_vnc_connect_prop(char *str);\nvoid set_x11vnc_remote_prop(char *str);\nenum rfbNewClientAction new_client(rfbClientPtr client);\nenum rfbNewClientAction new_client_chat_helper(rfbClientPtr client);\nvoid send_client_info(char *str);\nint accept_client(rfbClientPtr client);\nvoid client_set_net(rfbClientPtr client);\nstatic rfbClientPtr *client_match(char *str);\nstatic void free_client_data(rfbClientPtr client);\n\nvoid reverse_connect(char *str) {\n\tchar *p, *tmp;\n\tint sleep_between_host = 300;\n\tint sleep_min = 1500, sleep_max = 4500, n_max = 5;\n\tint n, tot, t, dt = 100, cnt = 0;\n\tint nclients0 = client_count;\n\tint lcnt, j;\n\tchar **list;\n\tint do_appshare = 0;\n\n\tif (!getenv(\"X11VNC_REVERSE_USE_OLD_SLEEP\")) {\n\t\tsleep_min = 500;\n\t\tsleep_max = 2500;\n\t}\n\n\tif (unixpw_in_progress) return;\n\n\ttmp = strdup(str);\n\n\tlist = (char **) calloc( (strlen(tmp)+2) * sizeof (char *), 1);\n\tlcnt = 0;\n\n\tp = strtok(tmp, \", \\t\\r\\n\");\n\twhile (p) {\n\t\tlist[lcnt++] = strdup(p);\n\t\tp = strtok(NULL, \", \\t\\r\\n\");\n\t}\n\tfree(tmp);\n\n\tif (subwin && getenv(\"X11VNC_APPSHARE_ACTIVE\")) {\n\t\tdo_appshare = 1;\n\t\tsleep_between_host = 0;\t/* too agressive??? */\n\t}\n\tif (getenv(\"X11VNC_REVERSE_SLEEP_BETWEEN_HOST\")) {\n\t\tsleep_between_host = atoi(getenv(\"X11VNC_REVERSE_SLEEP_BETWEEN_HOST\"));\n\t}\n\n\tif (do_appshare) {\n\t\tif (screen && dpy) {\n\t\t\tchar *s = choose_title(DisplayString(dpy));\n\n\t\t\t/* mutex */\n\t\t\tscreen->desktopName = s;\n\t\t\tif (rfb_desktop_name) {\n\t\t\t\tfree(rfb_desktop_name);\n\t\t\t}\n\t\t\trfb_desktop_name = strdup(s);\n\t\t}\n\t}\n\n\tfor (j = 0; j < lcnt; j++) {\n\t\tp = list[j];\n\t\t\n\t\tif ((n = do_reverse_connect(p)) != 0) {\n\t\t\tint i;\n\t\t\tprogress_client();\n\t\t\tfor (i=0; i < 3; i++) {\n\t\t\t\trfbPE(-1);\n\t\t\t}\n\t\t}\n\t\tcnt += n;\n\t\tif (list[j+1] != NULL) {\n\t\t\tt = 0;\n\t\t\twhile (t < sleep_between_host) {\n\t\t\t\tdouble t1, t2;\n\t\t\t\tint i;\n\t\t\t\tt1 = dnow();\n\t\t\t\tfor (i=0; i < 8; i++) {\n\t\t\t\t\trfbPE(-1);\n\t\t\t\t\tif (do_appshare && t == 0) {\n\t\t\t\t\t\trfbPE(-1);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tt2 = dnow();\n\t\t\t\tt += (int) (1000 * (t2 - t1));\n\t\t\t\tif (t >= sleep_between_host) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tusleep(dt * 1000);\n\t\t\t\tt += dt;\n\t\t\t}\n\t\t}\n\t}\n\n\tfor (j = 0; j < lcnt; j++) {\n\t\tp = list[j];\n\t\tif (p) free(p);\n\t}\n\tfree(list);\n\n\tif (cnt == 0) {\n\t\tif (connect_or_exit) {\n\t\t\trfbLogEnable(1);\n\t\t\trfbLog(\"exiting under -connect_or_exit\\n\");\n\t\t\tif (gui_pid > 0) {\n\t\t\t\trfbLog(\"killing gui_pid %d\\n\", gui_pid);\n\t\t\t\tkill(gui_pid, SIGTERM);\n\t\t\t}\n\t\t\tclean_up_exit(1);\n\t\t}\n\t\tif (xrandr || xrandr_maybe) {\n\t\t\tcheck_xrandr_event(\"reverse_connect1\");\n\t\t}\n\t\treturn;\n\t}\n\n\t/*\n\t * XXX: we need to process some of the initial handshaking\n\t * events, otherwise the client can get messed up (why??) \n\t * so we send rfbProcessEvents() all over the place.\n\t *\n\t * How much is this still needed?\n\t */\n\n\tn = cnt;\n\tif (n >= n_max) {\n\t\tn = n_max; \n\t}\n\tt = sleep_max - sleep_min;\n\ttot = sleep_min + ((n-1) * t) / (n_max-1);\n\n\tif (do_appshare) {\n\t\ttot /= 3;\n\t\tif (tot < dt) {\n\t\t\ttot = dt;\n\t\t}\n\t\ttot = 0;\t/* too agressive??? */\n\t}\n\n\tif (getenv(\"X11VNC_REVERSE_SLEEP_MAX\")) {\n\t\ttot = atoi(getenv(\"X11VNC_REVERSE_SLEEP_MAX\"));\n\t}\n\n\tt = 0;\n\twhile (t < tot) {\n\t\tint i;\n\t\tdouble t1, t2;\n\t\tt1 = dnow();\n\t\tfor (i=0; i < 8; i++) {\n\t\t\trfbPE(-1);\n\t\t\tif (t == 0) rfbPE(-1);\n\t\t}\n\t\tt2 = dnow();\n\t\tt += (int) (1000 * (t2 - t1));\n\t\tif (t >= tot) {\n\t\t\tbreak;\n\t\t}\n\t\tusleep(dt * 1000);\n\t\tt += dt;\n\t}\n\tif (connect_or_exit) {\n\t\tif (client_count <= nclients0)  {\n\t\t\tfor (t = 0; t < 10; t++) {\n\t\t\t\tint i;\n\t\t\t\tfor (i=0; i < 3; i++) {\n\t\t\t\t\trfbPE(-1);\n\t\t\t\t}\n\t\t\t\tusleep(100 * 1000);\n\t\t\t}\n\t\t}\n\t\tif (client_count <= nclients0)  {\n\t\t\trfbLogEnable(1);\n\t\t\trfbLog(\"exiting under -connect_or_exit\\n\");\n\t\t\tif (gui_pid > 0) {\n\t\t\t\trfbLog(\"killing gui_pid %d\\n\", gui_pid);\n\t\t\t\tkill(gui_pid, SIGTERM);\n\t\t\t}\n\t\t\tclean_up_exit(1);\n\t\t}\n\t}\n\tif (xrandr || xrandr_maybe) {\n\t\tcheck_xrandr_event(\"reverse_connect2\");\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"wait_for_client: reverse_connect(%s)\\n\"",
            "client_connect"
          ],
          "line": 1540
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "q+1"
          ],
          "line": 1537
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"wait_for_client: only using first\"\n\t\t\t\t    \" connect host in: %s\\n\"",
            "client_connect"
          ],
          "line": 1535
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "client_connect",
            "','"
          ],
          "line": 1533
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"wait_for_client: invalid -connect string: %s\\n\"",
            "client_connect"
          ],
          "line": 1530
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "client_connect",
            "'='"
          ],
          "line": 1529
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"wait_for_client: -connect disallowed: client exists: %s\\n\"",
            "client_connect"
          ],
          "line": 1527
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"wait_for_client: -connect disallowed in inetd mode: %s\\n\"",
            "client_connect"
          ],
          "line": 1524
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"avahi.h\"\n#include \"sslhelper.h\"\n#include \"remote.h\"\n#include \"cursor.h\"\n#include \"keyboard.h\"\n#include \"inet.h\"\n#include \"connections.h\"\n#include \"xwrappers.h\"\n#include \"sslhelper.h\"\n#include \"unixpw.h\"\n#include \"screen.h\"\n#include \"scan.h\"\n#include \"cleanup.h\"\n#include \"solid.h\"\n#include \"x11vnc.h\"\n\nstatic void setup_client_connect(int *did_client_connect) {\n\tif (client_connect != NULL) {\n\t\tchar *remainder = NULL;\n\t\tif (inetd) {\n\t\t\trfbLog(\"wait_for_client: -connect disallowed in inetd mode: %s\\n\",\n\t\t\t    client_connect);\n\t\t} else if (screen && screen->clientHead) {\n\t\t\trfbLog(\"wait_for_client: -connect disallowed: client exists: %s\\n\",\n\t\t\t    client_connect);\n\t\t} else if (strchr(client_connect, '=')) {\n\t\t\trfbLog(\"wait_for_client: invalid -connect string: %s\\n\",\n\t\t\t    client_connect);\n\t\t} else {\n\t\t\tchar *q = strchr(client_connect, ',');\n\t\t\tif (q) {\n\t\t\t\trfbLog(\"wait_for_client: only using first\"\n\t\t\t\t    \" connect host in: %s\\n\", client_connect);\n\t\t\t\tremainder = strdup(q+1);\n\t\t\t\t*q = '\\0';\n\t\t\t}\n\t\t\trfbLog(\"wait_for_client: reverse_connect(%s)\\n\",\n\t\t\t    client_connect);\n\t\t\treverse_connect(client_connect);\n\t\t\t*did_client_connect = 1;\n\t\t}\n\t\tfree(client_connect);\n\t\tif (remainder != NULL) {\n\t\t\t/* reset to host2,host3,... */\n\t\t\tclient_connect = remainder;\n\t\t} else {\n\t\t\tclient_connect = NULL;\n\t\t}\n\t}\n}"
  },
  {
    "function_name": "check_waitbg",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/user.c",
    "lines": "1486-1518",
    "snippet": "static void check_waitbg(void) {\n\tif (getenv(\"WAITBG\")) {\n#if LIBVNCSERVER_HAVE_FORK && HAVE_SETSID\n\t\tint p, n;\n\t\tif ((p = fork()) > 0)  {\n\t\t\texit(0);\n\t\t} else if (p == -1) {\n\t\t\trfbLogEnable(1);\n\t\t\tfprintf(stderr, \"could not fork\\n\");\n\t\t\tperror(\"fork\");\n\t\t\tclean_up_exit(1);\n\t\t}\n\t\tif (setsid() == -1) {\n\t\t\trfbLogEnable(1);\n\t\t\tfprintf(stderr, \"setsid failed\\n\");\n\t\t\tperror(\"setsid\");\n\t\t\tclean_up_exit(1);\n\t\t}\n\t\t/* adjust our stdio */\n\t\tn = open(\"/dev/null\", O_RDONLY);\n\t\tdup2(n, 0);\n\t\tdup2(n, 1);\n\t\tif (! logfile) {\n\t\t\tdup2(n, 2);\n\t\t}\n\t\tif (n > 2) {\n\t\t\tclose(n);\n\t\t}\n#else\n\t\tclean_up_exit(1);\n#endif\n\t}\n}",
    "includes": [
      "#include \"avahi.h\"",
      "#include \"sslhelper.h\"",
      "#include \"remote.h\"",
      "#include \"cursor.h\"",
      "#include \"keyboard.h\"",
      "#include \"inet.h\"",
      "#include \"connections.h\"",
      "#include \"xwrappers.h\"",
      "#include \"sslhelper.h\"",
      "#include \"unixpw.h\"",
      "#include \"screen.h\"",
      "#include \"scan.h\"",
      "#include \"cleanup.h\"",
      "#include \"solid.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "clean_up_exit",
          "args": [
            "1"
          ],
          "line": 1515
        },
        "resolved": true,
        "details": {
          "function_name": "clean_up_exit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/cleanup.c",
          "lines": "151-266",
          "snippet": "void clean_up_exit(int ret) {\n\tstatic int depth = 0;\n\texit_flag = 1;\n\n\tif (depth++ > 2) {\n\t\texit(ret);\n\t}\n\n\tif (icon_mode) {\n\t\tclean_icon_mode();\n\t}\n\n\t/* remove the shm areas: */\n\tclean_shm(0);\n\n\tstop_stunnel();\n\tif (use_openssl) {\n\t\tssl_helper_pid(0, 0);\t/* killall */\n\t}\n\n\tif (ssh_pid > 0) {\n\t\tkill(ssh_pid, SIGTERM);\n\t\tssh_pid = 0;\n\t}\n\n#ifdef MACOSX\n\tif (client_connect_file) {\n\t\tif (strstr(client_connect_file, \"/tmp/x11vnc-macosx-remote\")\n\t\t    == client_connect_file) {\n\t\t\tunlink(client_connect_file);\n\t\t}\n\t}\n\tif (macosx_console) {\n\t\tmacosxCG_fini();\n\t}\n#endif\n\n\tif (pipeinput_fh != NULL) {\n\t\tpclose(pipeinput_fh);\n\t\tpipeinput_fh = NULL;\n\t}\n\n\tshutdown_uinput();\n\n\tif (unix_sock) {\n\t\tif (unix_sock_fd >= 0) {\n\t\t\trfbLog(\"deleting unix sock: %s\\n\", unix_sock);\n\t\t\tclose(unix_sock_fd);\n\t\t\tunix_sock_fd = -1;\n\t\t\tunlink(unix_sock);\n\t\t}\n\t}\n\n\tif (! dpy) {\t/* raw_rb hack */\n\t\tif (rm_flagfile) {\n\t\t\tunlink(rm_flagfile);\n\t\t\trm_flagfile = NULL;\n\t\t}\n\t\texit(ret);\n\t}\n\n\t/* X keyboard cleanups */\n\tdelete_added_keycodes(0);\n\n\t/* remove all created XInput2 devices */\n\tif(use_multipointer)\n\t    removeAllMDs(dpy);\n\n\tif (clear_mods == 1) {\n\t\tclear_modifiers(0);\n\t} else if (clear_mods == 2) {\n\t\tclear_keys();\n\t} else if (clear_mods == 3) {\n\t\tclear_keys();\n\t\tclear_locks();\n\t}\n\n\tif (no_autorepeat) {\n\t\tautorepeat(1, 0);\n\t}\n\tif (use_solid_bg) {\n\t\tsolid_bg(1);\n\t}\n\tif (ncache || ncache0) {\n\t\tkde_no_animate(1);\n\t}\n\tX_LOCK;\n\tXTestDiscard_wr(dpy);\n#if HAVE_LIBXDAMAGE\n\tif (xdamage) {\n\t\tXDamageDestroy(dpy, xdamage);\n\t}\n#endif\n#if HAVE_LIBXTRAP\n\tif (trap_ctx) {\n\t\tXEFreeTC(trap_ctx);\n\t}\n#endif\n\t/* XXX rdpy_ctrl, etc. cannot close w/o blocking */\n\tXCloseDisplay_wr(dpy);\n\tX_UNLOCK;\n\n\tfflush(stderr);\n\n\tif (rm_flagfile) {\n\t\tunlink(rm_flagfile);\n\t\trm_flagfile = NULL;\n\t}\n\n\tif (avahi) {\n\t\tavahi_cleanup();\n\t\tfflush(stderr);\n\t}\n\n\texit(ret);\n}",
          "includes": [
            "#include \"xi2_devices.h\"",
            "#include \"uinput.h\"",
            "#include \"xevents.h\"",
            "#include \"xrecord.h\"",
            "#include \"screen.h\"",
            "#include \"avahi.h\"",
            "#include \"macosxCG.h\"",
            "#include \"macosx.h\"",
            "#include \"connections.h\"",
            "#include \"sslhelper.h\"",
            "#include \"sslcmds.h\"",
            "#include \"unixpw.h\"",
            "#include \"solid.h\"",
            "#include \"gui.h\"",
            "#include \"scan.h\"",
            "#include \"keyboard.h\"",
            "#include \"remote.h\"",
            "#include \"xdamage.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void clean_up_exit(int ret);",
            "int known_sigpipe_mode(char *s);",
            "static int exit_flag = 0;",
            "static void clean_icon_mode(void);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xi2_devices.h\"\n#include \"uinput.h\"\n#include \"xevents.h\"\n#include \"xrecord.h\"\n#include \"screen.h\"\n#include \"avahi.h\"\n#include \"macosxCG.h\"\n#include \"macosx.h\"\n#include \"connections.h\"\n#include \"sslhelper.h\"\n#include \"sslcmds.h\"\n#include \"unixpw.h\"\n#include \"solid.h\"\n#include \"gui.h\"\n#include \"scan.h\"\n#include \"keyboard.h\"\n#include \"remote.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nvoid clean_up_exit(int ret);\nint known_sigpipe_mode(char *s);\nstatic int exit_flag = 0;\nstatic void clean_icon_mode(void);\n\nvoid clean_up_exit(int ret) {\n\tstatic int depth = 0;\n\texit_flag = 1;\n\n\tif (depth++ > 2) {\n\t\texit(ret);\n\t}\n\n\tif (icon_mode) {\n\t\tclean_icon_mode();\n\t}\n\n\t/* remove the shm areas: */\n\tclean_shm(0);\n\n\tstop_stunnel();\n\tif (use_openssl) {\n\t\tssl_helper_pid(0, 0);\t/* killall */\n\t}\n\n\tif (ssh_pid > 0) {\n\t\tkill(ssh_pid, SIGTERM);\n\t\tssh_pid = 0;\n\t}\n\n#ifdef MACOSX\n\tif (client_connect_file) {\n\t\tif (strstr(client_connect_file, \"/tmp/x11vnc-macosx-remote\")\n\t\t    == client_connect_file) {\n\t\t\tunlink(client_connect_file);\n\t\t}\n\t}\n\tif (macosx_console) {\n\t\tmacosxCG_fini();\n\t}\n#endif\n\n\tif (pipeinput_fh != NULL) {\n\t\tpclose(pipeinput_fh);\n\t\tpipeinput_fh = NULL;\n\t}\n\n\tshutdown_uinput();\n\n\tif (unix_sock) {\n\t\tif (unix_sock_fd >= 0) {\n\t\t\trfbLog(\"deleting unix sock: %s\\n\", unix_sock);\n\t\t\tclose(unix_sock_fd);\n\t\t\tunix_sock_fd = -1;\n\t\t\tunlink(unix_sock);\n\t\t}\n\t}\n\n\tif (! dpy) {\t/* raw_rb hack */\n\t\tif (rm_flagfile) {\n\t\t\tunlink(rm_flagfile);\n\t\t\trm_flagfile = NULL;\n\t\t}\n\t\texit(ret);\n\t}\n\n\t/* X keyboard cleanups */\n\tdelete_added_keycodes(0);\n\n\t/* remove all created XInput2 devices */\n\tif(use_multipointer)\n\t    removeAllMDs(dpy);\n\n\tif (clear_mods == 1) {\n\t\tclear_modifiers(0);\n\t} else if (clear_mods == 2) {\n\t\tclear_keys();\n\t} else if (clear_mods == 3) {\n\t\tclear_keys();\n\t\tclear_locks();\n\t}\n\n\tif (no_autorepeat) {\n\t\tautorepeat(1, 0);\n\t}\n\tif (use_solid_bg) {\n\t\tsolid_bg(1);\n\t}\n\tif (ncache || ncache0) {\n\t\tkde_no_animate(1);\n\t}\n\tX_LOCK;\n\tXTestDiscard_wr(dpy);\n#if HAVE_LIBXDAMAGE\n\tif (xdamage) {\n\t\tXDamageDestroy(dpy, xdamage);\n\t}\n#endif\n#if HAVE_LIBXTRAP\n\tif (trap_ctx) {\n\t\tXEFreeTC(trap_ctx);\n\t}\n#endif\n\t/* XXX rdpy_ctrl, etc. cannot close w/o blocking */\n\tXCloseDisplay_wr(dpy);\n\tX_UNLOCK;\n\n\tfflush(stderr);\n\n\tif (rm_flagfile) {\n\t\tunlink(rm_flagfile);\n\t\trm_flagfile = NULL;\n\t}\n\n\tif (avahi) {\n\t\tavahi_cleanup();\n\t\tfflush(stderr);\n\t}\n\n\texit(ret);\n}"
        }
      },
      {
        "call_info": {
          "callee": "close",
          "args": [
            "n"
          ],
          "line": 1512
        },
        "resolved": true,
        "details": {
          "function_name": "close_alarm",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/unixpw.c",
          "lines": "666-672",
          "snippet": "static void close_alarm (int sig) {\n\tif (slave_fd >= 0) {\n\t\tclose(slave_fd);\n\t}\n\talarm_fired = 1;\n\tif (0) sig = 0;\t/* compiler warning */\n}",
          "includes": [
            "#include <sys/stropts.h>",
            "#include <termios.h>",
            "#include <sys/ioctl.h>",
            "#include <shadow.h>",
            "#include \"default8x16.h\"",
            "#include \"rates.h\"",
            "#include \"cursor.h\"",
            "#include \"sslhelper.h\"",
            "#include \"connections.h\"",
            "#include \"user.h\"",
            "#include \"connections.h\"",
            "#include \"xinerama.h\"",
            "#include \"cleanup.h\"",
            "#include \"scan.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int slave_fd = -1, alarm_fired = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/stropts.h>\n#include <termios.h>\n#include <sys/ioctl.h>\n#include <shadow.h>\n#include \"default8x16.h\"\n#include \"rates.h\"\n#include \"cursor.h\"\n#include \"sslhelper.h\"\n#include \"connections.h\"\n#include \"user.h\"\n#include \"connections.h\"\n#include \"xinerama.h\"\n#include \"cleanup.h\"\n#include \"scan.h\"\n#include \"x11vnc.h\"\n\nstatic int slave_fd = -1, alarm_fired = 0;\n\nstatic void close_alarm (int sig) {\n\tif (slave_fd >= 0) {\n\t\tclose(slave_fd);\n\t}\n\talarm_fired = 1;\n\tif (0) sig = 0;\t/* compiler warning */\n}"
        }
      },
      {
        "call_info": {
          "callee": "dup2",
          "args": [
            "n",
            "2"
          ],
          "line": 1509
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dup2",
          "args": [
            "n",
            "1"
          ],
          "line": 1507
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dup2",
          "args": [
            "n",
            "0"
          ],
          "line": 1506
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "open",
          "args": [
            "\"/dev/null\"",
            "O_RDONLY"
          ],
          "line": 1505
        },
        "resolved": true,
        "details": {
          "function_name": "accept_openssl",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/sslhelper.c",
          "lines": "3302-4284",
          "snippet": "void accept_openssl(int mode, int presock) {\n\tint sock = -1, listen = -1, cport, csock, vsock;\t\n\tint peerport = 0;\n\tint status, n, i, db = 0;\n\tstruct sockaddr_in addr;\n#ifdef __hpux\n\tint addrlen = sizeof(addr);\n#else\n\tsocklen_t addrlen = sizeof(addr);\n#endif\n\trfbClientPtr client;\n\tpid_t pid;\n\tchar uniq[] = \"_evilrats_\";\n\tchar cookie[256], rcookie[256], *name = NULL;\n\tint vencrypt_sel = 0;\n\tint anontls_sel = 0;\n\tchar *ipv6_name = NULL;\n\tstatic double last_https = 0.0;\n\tstatic char last_get[256];\n\tstatic int first = 1;\n\tunsigned char *rb;\n\n#if !LIBVNCSERVER_HAVE_LIBSSL && !HAVE_LIBSSL  \n\tif (enc_str == NULL || strcmp(enc_str, \"none\")) {\n\t\tbadnews(\"0 accept_openssl\");\n\t}\n#endif\n\n\topenssl_last_helper_pid = 0;\n\n\t/* zero buffers for use below. */\n\tfor (i=0; i<256; i++) {\n\t\tif (first) {\n\t\t\tlast_get[i] = '\\0';\n\t\t}\n\t\tcookie[i]  = '\\0';\n\t\trcookie[i] = '\\0';\n\t}\n\tfirst = 0;\n\n\tif (getenv(\"ACCEPT_OPENSSL_DEBUG\")) {\n\t\tdb = atoi(getenv(\"ACCEPT_OPENSSL_DEBUG\"));\n\t}\n\n\t/* do INETD, VNC, or HTTPS cases (result is client socket or pipe) */\n\tif (mode == OPENSSL_INETD) {\n\t\tssl_initialized = 1;\n\n\t} else if (mode == OPENSSL_VNC) {\n\t\tsock = accept(openssl_sock, (struct sockaddr *)&addr, &addrlen);\n\t\tif (sock < 0)  {\n\t\t\trfbLog(\"SSL: accept_openssl: accept connection failed\\n\");\n\t\t\trfbLogPerror(\"accept\");\n\t\t\tif (ssl_no_fail) {\n\t\t\t\tclean_up_exit(1);\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t\tlisten = openssl_sock;\n\n\t} else if (mode == OPENSSL_VNC6 || mode == OPENSSL_HTTPS6) {\n#if X11VNC_IPV6\n\t\tstruct sockaddr_in6 a6;\n\t\tsocklen_t a6len = sizeof(a6);\n\t\tint fd = (mode == OPENSSL_VNC6 ? openssl_sock6 : https_sock6); \n\n\t\tsock = accept(fd, (struct sockaddr *)&a6, &a6len);\n\t\tif (sock < 0)  {\n\t\t\trfbLog(\"SSL: accept_openssl: accept connection failed\\n\");\n\t\t\trfbLogPerror(\"accept\");\n\t\t\tif (ssl_no_fail) {\n\t\t\t\tclean_up_exit(1);\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t\tipv6_name = ipv6_getipaddr((struct sockaddr *)&a6, a6len);\n\t\tif (!ipv6_name) ipv6_name = strdup(\"unknown\");\n\t\tlisten = fd;\n#endif\n\t} else if (mode == OPENSSL_REVERSE) {\n\t\tsock = presock;\n\t\tif (sock < 0)  {\n\t\t\trfbLog(\"SSL: accept_openssl: connection failed\\n\");\n\t\t\tif (ssl_no_fail) {\n\t\t\t\tclean_up_exit(1);\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t\tif (getenv(\"OPENSSL_REVERSE_DEBUG\")) fprintf(stderr, \"OPENSSL_REVERSE: ipv6_client_ip_str: %s\\n\", ipv6_client_ip_str);\n\t\tif (ipv6_client_ip_str != NULL) {\n\t\t\tipv6_name = strdup(ipv6_client_ip_str);\n\t\t}\n\t\tlisten = -1;\n\n\t} else if (mode == OPENSSL_HTTPS) {\n\t\tsock = accept(https_sock, (struct sockaddr *)&addr, &addrlen);\n\t\tif (sock < 0)  {\n\t\t\trfbLog(\"SSL: accept_openssl: accept connection failed\\n\");\n\t\t\trfbLogPerror(\"accept\");\n\t\t\tif (ssl_no_fail) {\n\t\t\t\tclean_up_exit(1);\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t\tlisten = https_sock;\n\t}\n\tif (db) fprintf(stderr, \"SSL: accept_openssl: sock: %d\\n\", sock);\n\n\tif (openssl_last_ip) {\n\t\tfree(openssl_last_ip);\n\t\topenssl_last_ip = NULL;\n\t}\n\tif (mode == OPENSSL_INETD) {\n\t\topenssl_last_ip = get_remote_host(fileno(stdin));\n\t} else if (mode == OPENSSL_VNC6 || mode == OPENSSL_HTTPS6) {\n\t\topenssl_last_ip = ipv6_name;\n\t} else if (mode == OPENSSL_REVERSE && ipv6_name != NULL) {\n\t\topenssl_last_ip = ipv6_name;\n\t} else {\n\t\topenssl_last_ip = get_remote_host(sock);\n\t}\n\n\tif (!check_ssl_access(openssl_last_ip)) {\n\t\trfbLog(\"SSL: accept_openssl: denying client %s\\n\", openssl_last_ip);\n\t\trfbLog(\"SSL: accept_openssl: does not match -allow or other reason.\\n\");\n\t\tclose(sock);\n\t\tsock = -1;\n\t\tif (ssl_no_fail) {\n\t\t\tclean_up_exit(1);\n\t\t}\n\t\treturn;\n\t}\n\n\t/* now make a listening socket for child to connect back to us by: */\n\n\tcport = find_free_port(20000, 22000);\n\tif (! cport && ipv6_listen) {\n\t\trfbLog(\"SSL: accept_openssl: seeking IPv6 port.\\n\");\n\t\tcport = find_free_port6(20000, 22000);\n\t\trfbLog(\"SSL: accept_openssl: IPv6 port: %d\\n\", cport);\n\t}\n\tif (! cport) {\n\t\trfbLog(\"SSL: accept_openssl: could not find open port.\\n\");\n\t\tclose(sock);\n\t\tif (mode == OPENSSL_INETD || ssl_no_fail) {\n\t\t\tclean_up_exit(1);\n\t\t}\n\t\treturn;\n\t}\n\tif (db) fprintf(stderr, \"accept_openssl: cport: %d\\n\", cport);\n\n\tcsock = listen_tcp(cport, htonl(INADDR_LOOPBACK), 1);\n\n\tif (csock < 0) {\n\t\trfbLog(\"SSL: accept_openssl: could not listen on port %d.\\n\",\n\t\t    cport);\n\t\tclose(sock);\n\t\tif (mode == OPENSSL_INETD || ssl_no_fail) {\n\t\t\tclean_up_exit(1);\n\t\t}\n\t\treturn;\n\t}\n\tif (db) fprintf(stderr, \"accept_openssl: csock: %d\\n\", csock);\n\n\tfflush(stderr);\n\n\t/*\n\t * make a simple cookie to id the child socket, not foolproof\n\t * but hard to guess exactly (just worrying about local lusers\n\t * here, since we use INADDR_LOOPBACK).\n\t */\n\trb = (unsigned char *) calloc(6, 1);\n#if LIBVNCSERVER_HAVE_LIBSSL || HAVE_LIBSSL \n\tRAND_bytes(rb, 6);\n#endif\n\tsprintf(cookie, \"RB=%d%d%d%d%d%d/%f%f/%p\",\n\t    rb[0], rb[1], rb[2], rb[3], rb[4], rb[5],\n            dnow() - x11vnc_start, x11vnc_start, (void *)rb);\n\n\tif (mode == OPENSSL_VNC6) {\n\t\tname = strdup(ipv6_name);\n\t\tpeerport = get_remote_port(sock);\n\t} else if (mode == OPENSSL_REVERSE && ipv6_name != NULL) {\n\t\tname = strdup(ipv6_name);\n\t\tpeerport = get_remote_port(sock);\n\t} else if (mode != OPENSSL_INETD) {\n\t\tname = get_remote_host(sock);\n\t\tpeerport = get_remote_port(sock);\n\t} else {\n\t\topenssl_last_ip = get_remote_host(fileno(stdin));\n\t\tpeerport = get_remote_port(fileno(stdin));\n\t\tif (openssl_last_ip) {\n\t\t\tname = strdup(openssl_last_ip);\n\t\t} else {\n\t\t\tname = strdup(\"unknown\");\n\t\t}\n\t}\n\tif (name) {\n\t\tif (mode == OPENSSL_INETD) {\n\t\t\trfbLog(\"SSL: (inetd) spawning helper process \"\n\t\t\t    \"to handle: %s:%d\\n\", name, peerport);\n\t\t} else {\n\t\t\trfbLog(\"SSL: spawning helper process to handle: \"\n\t\t\t    \"%s:%d\\n\", name, peerport);\n\t\t}\n\t\tfree(name);\n\t\tname = NULL;\n\t}\n\n\tif (certret) {\n\t\tfree(certret);\n\t}\n\tif (certret_str) {\n\t\tfree(certret_str);\n\t\tcertret_str = NULL;\n\t}\n\tcertret = strdup(\"/tmp/x11vnc-certret.XXXXXX\");\n\tomode = umask(077);\n\tcertret_fd = mkstemp(certret);\n\tumask(omode);\n\tif (certret_fd < 0) {\n\t\tfree(certret);\n\t\tcertret = NULL;\n\t\tcertret_fd = -1;\n\t}\n\n\tif (dhret) {\n\t\tfree(dhret);\n\t}\n\tif (dhret_str) {\n\t\tfree(dhret_str);\n\t\tdhret_str = NULL;\n\t}\n\tdhret = strdup(\"/tmp/x11vnc-dhret.XXXXXX\");\n\tomode = umask(077);\n\tdhret_fd = mkstemp(dhret);\n\tumask(omode);\n\tif (dhret_fd < 0) {\n\t\tfree(dhret);\n\t\tdhret = NULL;\n\t\tdhret_fd = -1;\n\t}\n\n\t/* now fork the child to handle the SSL: */\n\tpid = fork();\n\n\tif (pid > 0) {\n\t\trfbLog(\"SSL: helper for peerport %d is pid %d: \\n\",\n\t\t    peerport, (int) pid);\n\t}\n\n\tif (pid < 0) {\n\t\trfbLog(\"SSL: accept_openssl: could not fork.\\n\");\n\t\trfbLogPerror(\"fork\");\n\t\tclose(sock);\n\t\tclose(csock);\n\t\tif (mode == OPENSSL_INETD || ssl_no_fail) {\n\t\t\tclean_up_exit(1);\n\t\t}\n\t\treturn;\n\n\t} else if (pid == 0) {\n\t\tint s_in, s_out, httpsock = -1;\n\t\tint vncsock;\n\t\tint i, have_httpd = 0;\n\t\tint f_in  = fileno(stdin);\n\t\tint f_out = fileno(stdout);\n\t\tint skip_vnc_tls = mode == OPENSSL_HTTPS ? 1 : 0;\n\n\t\tif (db) fprintf(stderr, \"helper pid in: %d %d %d %d\\n\", f_in, f_out, sock, listen);\n\n\t\t/* reset all handlers to default (no interrupted() calls) */\n\t\tunset_signals();\n\n\t\t/* close all non-essential fd's */\n\t\tfor (i=0; i<256; i++) {\n\t\t\tif (mode == OPENSSL_INETD) {\n\t\t\t\tif (i == f_in || i == f_out) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (i == sock) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (i == 2) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tclose(i);\n\t\t}\n\n\t\t/*\n\t\t * sadly, we are a long lived child and so the large\n\t\t * framebuffer memory areas will soon differ from parent.\n\t\t * try to free as much as possible.\n\t\t */\n\t\tlose_ram();\n\n\t\t/* now connect back to parent socket: */\n\t\tvncsock = connect_tcp(\"127.0.0.1\", cport);\n\t\tif (vncsock < 0) {\n\t\t\trfbLog(\"SSL: ssl_helper[%d]: could not connect\"\n\t\t\t    \" back to: %d\\n\", getpid(), cport);\n\t\t\trfbLog(\"SSL: ssl_helper[%d]: exit case 1 (no local vncsock)\\n\", getpid());\n\t\t\texit(1);\n\t\t}\n\t\tif (db) fprintf(stderr, \"vncsock %d\\n\", vncsock);\n\n\t\t/* try to initialize SSL with the remote client */\n\n\t\tif (mode == OPENSSL_INETD) {\n\t\t\ts_in  = fileno(stdin);\n\t\t\ts_out = fileno(stdout);\n\t\t} else {\n\t\t\ts_in = s_out = sock;\n\t\t}\n\n\t\tif (! ssl_init(s_in, s_out, skip_vnc_tls, last_https)) {\n\t\t\tclose(vncsock);\n\t\t\trfbLog(\"SSL: ssl_helper[%d]: exit case 2 (ssl_init failed)\\n\", getpid());\n\t\t\texit(1);\n\t\t}\n\n\t\tif (vencrypt_selected != 0) {\n\t\t\tchar *tbuf;\n\t\t\ttbuf = (char *) malloc(strlen(cookie) + 100);\n\t\t\tsprintf(tbuf, \"%s,VENCRYPT=%d,%s\", uniq, vencrypt_selected, cookie);\n\t\t\twrite(vncsock, tbuf, strlen(cookie));\n\t\t\tgoto wrote_cookie;\n\t\t} else if (anontls_selected != 0) {\n\t\t\tchar *tbuf;\n\t\t\ttbuf = (char *) malloc(strlen(cookie) + 100);\n\t\t\tsprintf(tbuf, \"%s,ANONTLS=%d,%s\", uniq, anontls_selected, cookie);\n\t\t\twrite(vncsock, tbuf, strlen(cookie));\n\t\t\tgoto wrote_cookie;\n\t\t}\n\n\t\t/*\n\t\t * things get messy below since we are trying to do\n\t\t * *both* VNC and Java applet httpd through the same\n\t\t * SSL socket.\n\t\t */\n\n\t\tif (! screen) {\n\t\t\tclose(vncsock);\n\t\t\texit(1);\n\t\t}\n\t\tif (screen->httpListenSock >= 0 && screen->httpPort > 0) {\n\t\t\thave_httpd = 1;\n\t\t} else if (ipv6_http_fd >= 0) {\n\t\t\thave_httpd = 1;\n\t\t} else if (screen->httpListenSock == -2) {\n\t\t\thave_httpd = 1;\n\t\t}\n\t\tif (mode == OPENSSL_HTTPS && ! have_httpd) {\n\t\t\trfbLog(\"SSL: accept_openssl[%d]: no httpd socket for \"\n\t\t\t    \"-https mode\\n\", getpid());\n\t\t\tclose(vncsock);\n\t\t\trfbLog(\"SSL: ssl_helper[%d]: exit case 3 (no httpd sock)\\n\", getpid());\n\t\t\texit(1);\n\t\t}\n\n\t\tif (have_httpd) {\n\t\t\tint n = 0, is_http = 0;\n\t\t\tint hport = screen->httpPort; \n\t\t\tchar *iface = NULL;\n\t\t\tchar *buf, *tbuf;\n\n\t\t\tbuf  = (char *) calloc((ABSIZE+1), 1);\n\t\t\ttbuf = (char *) calloc((2*ABSIZE+1), 1);\n\n\t\t\tif (mode == OPENSSL_HTTPS) {\n\t\t\t\t/*\n\t\t\t\t * for this mode we know it is HTTP traffic\n\t\t\t\t * so we skip trying to guess.\n\t\t\t\t */\n\t\t\t\tis_http = 1;\n\t\t\t\tn = 0;\n\t\t\t\tgoto connect_to_httpd;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * Check if there is stuff to read from remote end\n\t\t\t * if so it is likely a GET or HEAD.\n\t\t\t */\n\t\t\tif (! is_ssl_readable(s_in, last_https, last_get,\n\t\t\t    mode)) {\n\t\t\t\tgoto write_cookie;\n\t\t\t}\n\t\n\t\t\t/* \n\t\t\t * read first 2 bytes to try to guess.  sadly,\n\t\t\t * the user is often pondering a \"non-verified\n\t\t\t * cert\" dialog for a long time before the GET\n\t\t\t * is ever sent.  So often we timeout here.\n\t\t\t */\n\n\t\t\tif (db) fprintf(stderr, \"watch_for_http_traffic\\n\");\n\n\t\t\tis_http = watch_for_http_traffic(buf, &n, s_in);\n\n\t\t\tif (is_http < 0 || is_http == 0) {\n\t\t\t\t/*\n\t\t\t\t * error or http not detected, fall back\n\t\t\t\t * to normal VNC socket.\n\t\t\t\t */\n\t\t\t\tif (db) fprintf(stderr, \"is_http err: %d n: %d\\n\", is_http, n);\n\t\t\t\twrite(vncsock, cookie, strlen(cookie));\n\t\t\t\tif (n > 0) {\n\t\t\t\t\twrite(vncsock, buf, n);\n\t\t\t\t}\n\t\t\t\tgoto wrote_cookie;\n\t\t\t}\n\n\t\t\tif (db) fprintf(stderr, \"is_http: %d n: %d\\n\",\n\t\t\t    is_http, n);\n\t\t\tif (db) fprintf(stderr, \"buf: '%s'\\n\", buf);\n\n\t\t\tif (strstr(buf, \"/request.https.vnc.connection\")) {\n\t\t\t\tchar reply[] = \"HTTP/1.0 200 OK\\r\\n\"\n\t\t\t\t    \"Content-Type: octet-stream\\r\\n\"\n\t\t\t\t    \"Connection: Keep-Alive\\r\\n\"\n\t\t\t\t    \"VNC-Server: x11vnc\\r\\n\"\n\t\t\t\t    \"Pragma: no-cache\\r\\n\\r\\n\";\n\t\t\t\t/*\n\t\t\t\t * special case proxy coming thru https\n\t\t\t\t * instead of a direct SSL connection.\n\t\t\t\t */\n\t\t\t\trfbLog(\"Handling VNC request via https GET. [%d]\\n\", getpid());\n\t\t\t\trfbLog(\"-- %s\\n\", buf);\n\n\t\t\t\tif (strstr(buf, \"/reverse.proxy\")) {\n\t\t\t\t\tchar *buf2;\n\t\t\t\t\tint n, ptr;\n#if !LIBVNCSERVER_HAVE_LIBSSL && !HAVE_LIBSSL \n\t\t\t\t\twrite(s_out, reply, strlen(reply));\n#else\n\t\t\t\t\tSSL_write(ssl, reply, strlen(reply));\n#endif\n\t\t\t\t\n\t\t\t\t\tbuf2  = (char *) calloc((8192+1), 1);\n\t\t\t\t\tn = 0;\n\t\t\t\t\tptr = 0;\n\t\t\t\t\twhile (ptr < 8192) {\n#if !LIBVNCSERVER_HAVE_LIBSSL && !HAVE_LIBSSL \n\t\t\t\t\t\tn = read(s_in, buf2 + ptr, 1);\n#else\n\t\t\t\t\t\tn = SSL_read(ssl, buf2 + ptr, 1);\n#endif\n\t\t\t\t\t\tif (n > 0) {\n\t\t\t\t\t\t\tptr += n;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (db) fprintf(stderr, \"buf2: '%s'\\n\", buf2);\n\n\t\t\t\t\t\tif (strstr(buf2, \"\\r\\n\\r\\n\")) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tfree(buf2);\n\t\t\t\t}\n\t\t\t\tgoto write_cookie;\n\n\t\t\t} else if (strstr(buf, \"/check.https.proxy.connection\")) {\n\t\t\t\tchar reply[] = \"HTTP/1.0 200 OK\\r\\n\"\n\t\t\t\t    \"Connection: close\\r\\n\"\n\t\t\t\t    \"Content-Type: octet-stream\\r\\n\"\n\t\t\t\t    \"VNC-Server: x11vnc\\r\\n\"\n\t\t\t\t    \"Pragma: no-cache\\r\\n\\r\\n\";\n\n\t\t\t\trfbLog(\"Handling Check HTTPS request via https GET. [%d]\\n\", getpid());\n\t\t\t\trfbLog(\"-- %s\\n\", buf);\n\n#if !LIBVNCSERVER_HAVE_LIBSSL && !HAVE_LIBSSL \n\t\t\t\twrite(s_out, reply, strlen(reply));\n#else\n\t\t\t\tSSL_write(ssl, reply, strlen(reply));\n\t\t\t\tSSL_shutdown(ssl);\n#endif\n\n\t\t\t\tstrcpy(tbuf, uniq);\n\t\t\t\tstrcat(tbuf, cookie);\n\t\t\t\twrite(vncsock, tbuf, strlen(tbuf));\n\t\t\t\tclose(vncsock);\n\n\t\t\t\trfbLog(\"SSL: ssl_helper[%d]: exit case 4 (check.https.proxy.connection)\\n\", getpid());\n\t\t\t\texit(0);\n\t\t\t}\n\t\t\tconnect_to_httpd:\n\n\t\t\t/*\n\t\t\t * Here we go... no turning back.  we have to\n\t\t\t * send failure to parent and close socket to have\n\t\t\t * http processed at all in a timely fashion...\n\t\t\t */\n\n\t\t\t/* send the failure tag: */\n\t\t\tstrcpy(tbuf, uniq);\n\n\t\t\tif (https_port_redir < 0 || (strstr(buf, \"PORT=\") || strstr(buf, \"port=\"))) {\n\t\t\t\tchar *q = strstr(buf, \"Host:\");\n\t\t\t\tint fport = 443, match = 0;\n\t\t\t\tchar num[16];\n\n\t\t\t\tif (q && strstr(q, \"\\n\")) {\n\t\t\t\t    q += strlen(\"Host:\") + 1;\n\t\t\t\t    while (*q != '\\n') {\n\t\t\t\t\tint p;\n\t\t\t\t\tif (*q == ':' && sscanf(q, \":%d\", &p) == 1) {\n\t\t\t\t\t\tif (p > 0 && p < 65536) {\n\t\t\t\t\t\t\tfport = p;\n\t\t\t\t\t\t\tmatch = 1;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tq++;\n\t\t\t\t    }\n\t\t\t\t}\n\t\t\t\tif (!match || !https_port_redir) {\n\t\t\t\t\tint p;\n\t\t\t\t\tif (sscanf(buf, \"PORT=%d,\", &p) == 1) {\n\t\t\t\t\t\tif (p > 0 && p < 65536) {\n\t\t\t\t\t\t\tfport = p;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else if (sscanf(buf, \"port=%d,\", &p) == 1) {\n\t\t\t\t\t\tif (p > 0 && p < 65536) {\n\t\t\t\t\t\t\tfport = p;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tsprintf(num, \"HP=%d,\", fport);\n\t\t\t\tstrcat(tbuf, num);\n\t\t\t}\n\n\t\t\tif (strstr(buf, \"HTTP/\") != NULL)  {\n\t\t\t\tchar *q, *str;\n\t\t\t\t/*\n\t\t\t\t * Also send back the GET line for heuristics.\n\t\t\t\t * (last_https, get file).\n\t\t\t\t */\n\t\t\t\tstr = strdup(buf);\n\t\t\t\tq = strstr(str, \"HTTP/\");\n\t\t\t\tif (q != NULL) {\n\t\t\t\t\t*q = '\\0';\t\n\t\t\t\t\tstrcat(tbuf, str);\n\t\t\t\t}\n\t\t\t\tfree(str);\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * Also send the cookie to pad out the number of\n\t\t\t * bytes to more than the parent wants to read.\n\t\t\t * Since this is the failure case, it does not\n\t\t\t * matter that we send more than strlen(cookie).\n\t\t\t */\n\t\t\tstrcat(tbuf, cookie);\n\t\t\twrite(vncsock, tbuf, strlen(tbuf));\n\n\t\t\tusleep(150*1000);\n\t\t\tif (db) fprintf(stderr, \"close vncsock: %d\\n\", vncsock);\n\t\t\tclose(vncsock);\n\n\t\t\t/* now, finally, connect to the libvncserver httpd: */\n\t\t\tif (screen->listenInterface == htonl(INADDR_ANY) ||\n\t\t\t    screen->listenInterface == htonl(INADDR_NONE)) {\n\t\t\t\tiface = \"127.0.0.1\";\n\t\t\t} else {\n\t\t\t\tstruct in_addr in;\n\t\t\t\tin.s_addr = screen->listenInterface;\n\t\t\t\tiface = inet_ntoa(in);\n\t\t\t}\n\t\t\tif (iface == NULL || !strcmp(iface, \"\")) {\n\t\t\t\tiface = \"127.0.0.1\";\n\t\t\t}\n\t\t\tif (db) fprintf(stderr, \"iface: %s:%d\\n\", iface, hport);\n\t\t\tusleep(150*1000);\n\n\t\t\thttpsock = connect_tcp(iface, hport);\n\n\t\t\tif (httpsock < 0) {\n\t\t\t\t/* UGH, after all of that! */\n\t\t\t\trfbLog(\"Could not connect to httpd socket!\\n\");\n\t\t\t\trfbLog(\"SSL: ssl_helper[%d]: exit case 5.\\n\", getpid());\n\t\t\t\texit(1);\n\t\t\t}\n\t\t\tif (db) fprintf(stderr, \"ssl_helper[%d]: httpsock: %d %d\\n\",\n\t\t\t    getpid(), httpsock, n);\n\n\t\t\t/*\n\t\t\t * send what we read to httpd, and then connect\n\t\t\t * the rest of the SSL session to it:\n\t\t\t */\n\t\t\tif (n > 0) {\n\t\t\t\tchar *s = getenv(\"X11VNC_EXTRA_HTTPS_PARAMS\");\n\t\t\t\tint did_extra = 0;\n\n\t\t\t\tif (db) fprintf(stderr, \"sending http buffer httpsock: %d n=%d\\n'%s'\\n\", httpsock, n, buf);\n\t\t\t\tif (s != NULL) {\n\t\t\t\t\tchar *q = strstr(buf, \" HTTP/\");\n\t\t\t\t\tif (q) {\n\t\t\t\t\t\tint m;\n\t\t\t\t\t\t*q = '\\0';\n\t\t\t\t\t\tm = strlen(buf);\n\t\t\t\t\t\twrite(httpsock, buf, m);\n\t\t\t\t\t\twrite(httpsock, s, strlen(s));\n\t\t\t\t\t\t*q = ' ';\n\t\t\t\t\t\twrite(httpsock, q, n-m);\n\t\t\t\t\t\tdid_extra = 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (!did_extra) {\n\t\t\t\t\twrite(httpsock, buf, n);\n\t\t\t\t}\n\t\t\t}\n\t\t\tssl_xfer(httpsock, s_in, s_out, is_http);\n\t\t\trfbLog(\"SSL: ssl_helper[%d]: exit case 6 (https ssl_xfer done)\\n\", getpid());\n\t\t\texit(0);\n\t\t}\n\n\t\t/*\n\t\t * ok, back from the above https mess, simply send the\n\t\t * cookie back to the parent (who will attach us to\n\t\t * libvncserver), and connect the rest of the SSL session\n\t\t * to it.\n\t\t */\n\t\twrite_cookie:\n\t\twrite(vncsock, cookie, strlen(cookie));\n\n\t\twrote_cookie:\n\t\tssl_xfer(vncsock, s_in, s_out, 0);\n\t\trfbLog(\"SSL: ssl_helper[%d]: exit case 7 (ssl_xfer done)\\n\", getpid());\n\t\tif (0) usleep(50 * 1000);\n\t\texit(0);\n\t}\n\t/* parent here */\n\n\tif (mode != OPENSSL_INETD) {\n\t\tclose(sock);\n\t}\n\tif (db) fprintf(stderr, \"helper process is: %d\\n\", pid);\n\n\t/* accept connection from our child.  */\n\tsignal(SIGALRM, csock_timeout);\n\tcsock_timeout_sock = csock;\n\talarm(20);\n\n\tvsock = accept(csock, (struct sockaddr *)&addr, &addrlen);\n\n\talarm(0);\n\tsignal(SIGALRM, SIG_DFL);\n\tclose(csock);\n\n\n\tif (vsock < 0) {\n\t\trfbLog(\"SSL: accept_openssl: connection from ssl_helper[%d] FAILED.\\n\", pid);\n\t\trfbLogPerror(\"accept\");\n\n\t\tkill(pid, SIGTERM);\n\t\twaitpid(pid, &status, WNOHANG); \n\t\tif (mode == OPENSSL_INETD || ssl_no_fail) {\n\t\t\tclean_up_exit(1);\n\t\t}\n\t\tif (certret_fd >= 0) {\n\t\t\tclose(certret_fd);\n\t\t\tcertret_fd = -1;\n\t\t}\n\t\tif (certret) {\n\t\t\tunlink(certret);\n\t\t}\n\t\tif (dhret_fd >= 0) {\n\t\t\tclose(dhret_fd);\n\t\t\tdhret_fd = -1;\n\t\t}\n\t\tif (dhret) {\n\t\t\tunlink(dhret);\n\t\t}\n\t\treturn;\n\t}\n\tif (db) fprintf(stderr, \"accept_openssl: vsock: %d\\n\", vsock);\n\n\tn = read(vsock, rcookie, strlen(cookie));\n\tif (n < 0 && errno != 0) {\n\t\trfbLogPerror(\"read\");\n\t}\n\n\tif (certret) {\n\t\tstruct stat sbuf;\n\t\tsbuf.st_size = 0;\n\t\tif (certret_fd >= 0 && stat(certret, &sbuf) == 0 && sbuf.st_size > 0) {\n\t\t\tcertret_str = (char *) calloc(sbuf.st_size+1, 1);\n\t\t\tread(certret_fd, certret_str, sbuf.st_size);\n\t\t\tclose(certret_fd);\n\t\t\tcertret_fd = -1;\n\t\t}\n\t\tif (certret_fd >= 0) {\n\t\t\tclose(certret_fd);\n\t\t\tcertret_fd = -1;\n\t\t}\n\t\tunlink(certret);\n\t\tif (certret_str && strstr(certret_str, \"NOCERT\") == certret_str) {\n\t\t\tfree(certret_str);\n\t\t\tcertret_str = NULL;\n\t\t}\n\t\tif (0 && certret_str) {\n\t\t\tfprintf(stderr, \"certret_str[%d]:\\n%s\\n\", (int) sbuf.st_size, certret_str);\n\t\t}\n\t}\n\n\tif (dhret) {\n\t\tstruct stat sbuf;\n\t\tsbuf.st_size = 0;\n\t\tif (dhret_fd >= 0 && stat(dhret, &sbuf) == 0 && sbuf.st_size > 0) {\n\t\t\tdhret_str = (char *) calloc(sbuf.st_size+1, 1);\n\t\t\tread(dhret_fd, dhret_str, sbuf.st_size);\n\t\t\tclose(dhret_fd);\n\t\t\tdhret_fd = -1;\n\t\t}\n\t\tif (dhret_fd >= 0) {\n\t\t\tclose(dhret_fd);\n\t\t\tdhret_fd = -1;\n\t\t}\n\t\tunlink(dhret);\n\t\tif (dhret_str && strstr(dhret_str, \"NOCERT\") == dhret_str) {\n\t\t\tfree(dhret_str);\n\t\t\tdhret_str = NULL;\n\t\t}\n\t\tif (dhret_str) {\n\t\t\tif (new_dh_params == NULL) {\n\t\t\t\tfprintf(stderr, \"dhret_str[%d]:\\n%s\\n\", (int) sbuf.st_size, dhret_str);\n\t\t\t\tnew_dh_params = strdup(dhret_str);\n\t\t\t}\n\t\t}\n\t}\n\n\tif (0) {\n\t\tfprintf(stderr, \"rcookie: %s\\n\", rcookie);\n\t\tfprintf(stderr, \"cookie:  %s\\n\", cookie);\n\t}\n\n\tif (strstr(rcookie, uniq) == rcookie) {\n\t\tchar *q = strstr(rcookie, \"RB=\");\n\t\tif (q && strstr(cookie, q) == cookie) {\n\t\t\tvencrypt_sel = 0;\n\t\t\tanontls_sel = 0;\n\t\t\tq = strstr(rcookie, \"VENCRYPT=\");\n\t\t\tif (q && sscanf(q, \"VENCRYPT=%d,\", &vencrypt_sel) == 1) {\n\t\t\t\tif (vencrypt_sel != 0) {\n\t\t\t\t\trfbLog(\"SSL: VENCRYPT mode=%d accepted. helper[%d]\\n\", vencrypt_sel, pid);\n\t\t\t\t\tgoto accept_client;\n\t\t\t\t}\n\t\t\t}\n\t\t\tq = strstr(rcookie, \"ANONTLS=\");\n\t\t\tif (q && sscanf(q, \"ANONTLS=%d,\", &anontls_sel) == 1) {\n\t\t\t\tif (anontls_sel != 0) {\n\t\t\t\t\trfbLog(\"SSL: ANONTLS mode=%d accepted. helper[%d]\\n\", anontls_sel, pid);\n\t\t\t\t\tgoto accept_client;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tif (n != (int) strlen(cookie) || strncmp(cookie, rcookie, n)) {\n\t\trfbLog(\"SSL: accept_openssl: cookie from ssl_helper[%d] FAILED. %d\\n\", pid, n);\n\t\tif (db) fprintf(stderr, \"'%s'\\n'%s'\\n\", cookie, rcookie);\n\t\tclose(vsock);\n\n\t\tif (strstr(rcookie, uniq) == rcookie) {\n\t\t\tint i;\n\t\t\tdouble https_download_wait_time = 15.0;\n\n\t\t\tif (getenv(\"X11VNC_HTTPS_DOWNLOAD_WAIT_TIME\")) {\n\t\t\t\thttps_download_wait_time = atof(getenv(\"X11VNC_HTTPS_DOWNLOAD_WAIT_TIME\"));\n\t\t\t}\n\n\t\t\trfbLog(\"SSL: BUT WAIT! HTTPS for helper process[%d] succeeded. Good.\\n\", pid);\n\t\t\tif (mode != OPENSSL_HTTPS) {\n\t\t\t\tlast_https = dnow();\n\t\t\t\tfor (i=0; i<256; i++) {\n\t\t\t\t\tlast_get[i] = '\\0';\n\t\t\t\t}\n\t\t\t\tstrncpy(last_get, rcookie, 100);\n\t\t\t\tif (db) fprintf(stderr, \"last_get: '%s'\\n\", last_get);\n\t\t\t}\n\t\t\tif (rcookie && strstr(rcookie, \"VncViewer.class\")) {\n\t\t\t\trfbLog(\"\\n\");\n\t\t\t\trfbLog(\"helper[%d]:\\n\", pid);\n\t\t\t\trfbLog(\"***********************************************************\\n\");\n\t\t\t\trfbLog(\"SSL: WARNING CLIENT ASKED FOR NONEXISTENT 'VncViewer.class'\\n\");\n\t\t\t\trfbLog(\"SSL: USER NEEDS TO MAKE SURE THE JAVA PLUGIN IS INSTALLED\\n\");\n\t\t\t\trfbLog(\"SSL: AND WORKING PROPERLY (e.g. a test-java-plugin page.)\\n\");\n\t\t\t\trfbLog(\"SSL: AND/OR USER NEEDS TO **RESTART** HIS WEB BROWSER.\\n\");\n\t\t\t\trfbLog(\"SSL: SOMETIMES THE BROWSER 'REMEMBERS' FAILED APPLET DOWN-\\n\");\n\t\t\t\trfbLog(\"SSL: LOADS AND RESTARTING IT IS THE ONLY WAY TO FIX THINGS.\\n\");\n\t\t\t\trfbLog(\"***********************************************************\\n\");\n\t\t\t\trfbLog(\"\\n\");\n\t\t\t}\n\t\t\tssl_helper_pid(pid, -2);\n\n\t\t\tif (https_port_redir) {\n\t\t\t\tdouble start;\n\t\t\t\tint origport = screen->port;\n\t\t\t\tint useport = screen->port;\n\t\t\t\tint saw_httpsock = 0;\n\t\t\t\t/* to expand $PORT correctly in index.vnc */\n\t\t\t\tif (https_port_redir < 0) {\n\t\t\t\t\tchar *q = strstr(rcookie, \"HP=\");\n\t\t\t\t\tif (q) {\n\t\t\t\t\t\tint p;\n\t\t\t\t\t\tif (sscanf(q, \"HP=%d,\", &p) == 1) {\n\t\t\t\t\t\t\tuseport = p;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tuseport = https_port_redir;\n\t\t\t\t}\n\t\t\t\tscreen->port = useport;\n\t\t\t\tif (origport != useport) {\n\t\t\t\t\trfbLog(\"SSL: -httpsredir guess port: %d  helper[%d]\\n\", screen->port, pid);\n\t\t\t\t}\n\n\t\t\t\tstart = dnow();\n\t\t\t\twhile (dnow() < start + https_download_wait_time) {\n\t\t\t\t\tif (screen->httpSock >= 0) saw_httpsock = 1;\n\t\t\t\t\trfbPE(10000);\n\t\t\t\t\tusleep(10000);\n\t\t\t\t\tif (screen->httpSock >= 0) saw_httpsock = 1;\n\t\t\t\t\twaitpid(pid, &status, WNOHANG); \n\t\t\t\t\tif (kill(pid, 0) != 0) {\n\t\t\t\t\t\trfbLog(\"SSL: helper[%d] pid finished\\n\", pid);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif (0 && saw_httpsock && screen->httpSock < 0) {\n\t\t\t\t\t\t/* this check can kill the helper too soon. */\n\t\t\t\t\t\trfbLog(\"SSL: httpSock for helper[%d] went away\\n\", pid);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\trfbLog(\"SSL: guessing child helper[%d] https finished. dt=%.6f\\n\",\n\t\t\t\t    pid, dnow() - start);\n\n\t\t\t\trfbPE(10000);\n\t\t\t\trfbPE(10000);\n\t\t\t\trfbPE(10000);\n\n\t\t\t\tscreen->port = origport;\n\t\t\t\tssl_helper_pid(0, -2);\n\t\t\t\tif (mode == OPENSSL_INETD) {\n\t\t\t\t\tclean_up_exit(1);\n\t\t\t\t}\n\t\t\t} else if (mode == OPENSSL_INETD) {\n\t\t\t\tdouble start;\n\t\t\t\tint saw_httpsock = 0;\n\n\t\t\t\t/* to expand $PORT correctly in index.vnc */\n\t\t\t\tif (screen->port == 0) {\n\t\t\t\t\tint fd = fileno(stdin);\n\t\t\t\t\tif (getenv(\"X11VNC_INETD_PORT\")) {\n\t\t\t\t\t\t/* mutex */\n\t\t\t\t\t\tscreen->port = atoi(getenv(\n\t\t\t\t\t\t    \"X11VNC_INETD_PORT\"));\n\t\t\t\t\t} else {\n\t\t\t\t\t\tint tport = get_local_port(fd);\n\t\t\t\t\t\tif (tport > 0) {\n\t\t\t\t\t\t\tscreen->port = tport;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\trfbLog(\"SSL: screen->port %d for helper[%d]\\n\", screen->port, pid);\n\n\t\t\t\t/* kludge for https fetch via inetd */\n\t\t\t\tstart = dnow();\n\t\t\t\twhile (dnow() < start + https_download_wait_time) {\n\t\t\t\t\tif (screen->httpSock >= 0) saw_httpsock = 1;\n\t\t\t\t\trfbPE(10000);\n\t\t\t\t\tusleep(10000);\n\t\t\t\t\tif (screen->httpSock >= 0) saw_httpsock = 1;\n\t\t\t\t\twaitpid(pid, &status, WNOHANG); \n\t\t\t\t\tif (kill(pid, 0) != 0) {\n\t\t\t\t\t\trfbLog(\"SSL: helper[%d] pid finished\\n\", pid);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif (0 && saw_httpsock && screen->httpSock < 0) {\n\t\t\t\t\t\t/* this check can kill the helper too soon. */\n\t\t\t\t\t\trfbLog(\"SSL: httpSock for helper[%d] went away\\n\", pid);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\trfbLog(\"SSL: OPENSSL_INETD guessing \"\n\t\t\t\t    \"child helper[%d] https finished. dt=%.6f\\n\",\n\t\t\t\t    pid, dnow() - start);\n\n\t\t\t\trfbPE(10000);\n\t\t\t\trfbPE(10000);\n\t\t\t\trfbPE(10000);\n\n\t\t\t\tssl_helper_pid(0, -2);\n\t\t\t\tclean_up_exit(1);\n\t\t\t}\n\t\t\t/* this will actually only get earlier https */\n\t\t\tssl_helper_pid(0, -2);\n\t\t\treturn;\n\t\t}\n\t\tkill(pid, SIGTERM);\n\t\twaitpid(pid, &status, WNOHANG); \n\t\tif (mode == OPENSSL_INETD || ssl_no_fail) {\n\t\t\tclean_up_exit(1);\n\t\t}\n\t\treturn;\n\t}\n\n\taccept_client:\n\n\tif (db) fprintf(stderr, \"accept_openssl: cookie good: %s\\n\", cookie);\n\n\trfbLog(\"SSL: handshake with helper process[%d] succeeded.\\n\", pid);\n\n\topenssl_last_helper_pid = pid;\n\tssl_helper_pid(pid, vsock);\n\n\tif (vnc_redirect) {\n\t\tvnc_redirect_sock = vsock;\n\t\topenssl_last_helper_pid = 0;\n\t\treturn;\n\t}\n\n\tclient = create_new_client(vsock, 0);\n\topenssl_last_helper_pid = 0;\n\n\tif (client) {\n\t\tint swt = 0;\n\t\tif (mode == OPENSSL_VNC6 && openssl_last_ip != NULL) {\n\t\t\tswt = 1;\n\t\t} else if (mode == OPENSSL_REVERSE && ipv6_name != NULL && openssl_last_ip != NULL) {\n\t\t\tswt = 1;\n\t\t}\n\t\tif (swt) {\n\t\t\tif (client->host) {\n\t\t\t\tfree(client->host);\n\t\t\t}\n\t\t\tclient->host = strdup(openssl_last_ip);\n\t\t}\n\t\tif (db) fprintf(stderr, \"accept_openssl: client %p\\n\", (void *) client);\n\t\tif (db) fprintf(stderr, \"accept_openssl: new_client %p\\n\", (void *) screen->newClientHook);\n\t\tif (db) fprintf(stderr, \"accept_openssl: new_client %p\\n\", (void *) new_client);\n\t\tif (mode == OPENSSL_INETD) {\n\t\t\tinetd_client = client;\n\t\t\tclient->clientGoneHook = client_gone;\n\t\t}\n\t\tif (openssl_last_ip &&\n\t\t    strpbrk(openssl_last_ip, \"0123456789\") == openssl_last_ip) {\n\t\t\tclient->host = strdup(openssl_last_ip);\n\t\t}\n\t\tif (vencrypt_sel != 0) {\n\t\t\tclient->protocolMajorVersion = 3;\n\t\t\tclient->protocolMinorVersion = 8;\n#if LIBVNCSERVER_HAVE_LIBSSL || HAVE_LIBSSL \n\t\t\tif (!finish_vencrypt_auth(client, vencrypt_sel)) {\n\t\t\t\trfbCloseClient(client);\n\t\t\t\tclient = NULL;\n\t\t\t}\n#else\n\t\t\tbadnews(\"3 accept_openssl\");\n#endif\n\t\t} else if (anontls_sel != 0) {\n\t\t\tclient->protocolMajorVersion = 3;\n\t\t\tclient->protocolMinorVersion = 8;\n\t\t\trfbAuthNewClient(client);\n\t\t}\n\t\tif (use_threads && client != NULL) {\n\t\t\trfbStartOnHoldClient(client);\n\t\t}\n\t\t/* try to get RFB proto done now. */\n\t\tprogress_client();\n\t} else {\n\t\trfbLog(\"SSL: accept_openssl: rfbNewClient failed.\\n\");\n\t\tclose(vsock);\n\n\t\tkill(pid, SIGTERM);\n\t\twaitpid(pid, &status, WNOHANG); \n\t\tif (mode == OPENSSL_INETD || ssl_no_fail) {\n\t\t\tclean_up_exit(1);\n\t\t}\n\t\treturn;\n\t}\n}",
          "includes": [
            "#include <openssl/rand.h>",
            "#include <openssl/err.h>",
            "#include <openssl/ssl.h>",
            "#include \"user.h\"",
            "#include \"unixpw.h\"",
            "#include \"sslcmds.h\"",
            "#include \"connections.h\"",
            "#include \"scan.h\"",
            "#include \"screen.h\"",
            "#include \"cleanup.h\"",
            "#include \"inet.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [
            "#define HAVE_LIBSSL 0",
            "#define LIBVNCSERVER_HAVE_LIBSSL 0",
            "#define ABSIZE 16384",
            "#define OPENSSL_REVERSE 6",
            "#define OPENSSL_HTTPS6  5",
            "#define OPENSSL_HTTPS   4",
            "#define OPENSSL_VNC6    3",
            "#define OPENSSL_VNC     2",
            "#define OPENSSL_INETD   1"
          ],
          "globals_used": [
            "int openssl_sock = -1;",
            "int openssl_sock6 = -1;",
            "int https_sock = -1;",
            "int https_sock6 = -1;",
            "pid_t openssl_last_helper_pid = 0;",
            "char *openssl_last_ip = NULL;",
            "static char *certret = NULL;",
            "static int certret_fd = -1;",
            "static mode_t omode;",
            "char *certret_str = NULL;",
            "static char *dhret = NULL;",
            "static int dhret_fd = -1;",
            "char *dhret_str = NULL;",
            "char *new_dh_params = NULL;",
            "void raw_xfer(int csock, int s_in, int s_out);",
            "static char *get_input(char *tag, char **in);",
            "void ssl_helper_pid(pid_t pid, int sock);",
            "void accept_openssl(int mode, int presock);",
            "static void lose_ram(void);",
            "static int vencrypt_selected = 0;",
            "static int anontls_selected = 0;",
            "static int csock_timeout_sock = -1;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <openssl/rand.h>\n#include <openssl/err.h>\n#include <openssl/ssl.h>\n#include \"user.h\"\n#include \"unixpw.h\"\n#include \"sslcmds.h\"\n#include \"connections.h\"\n#include \"scan.h\"\n#include \"screen.h\"\n#include \"cleanup.h\"\n#include \"inet.h\"\n#include \"x11vnc.h\"\n\n#define HAVE_LIBSSL 0\n#define LIBVNCSERVER_HAVE_LIBSSL 0\n#define ABSIZE 16384\n#define OPENSSL_REVERSE 6\n#define OPENSSL_HTTPS6  5\n#define OPENSSL_HTTPS   4\n#define OPENSSL_VNC6    3\n#define OPENSSL_VNC     2\n#define OPENSSL_INETD   1\n\nint openssl_sock = -1;\nint openssl_sock6 = -1;\nint https_sock = -1;\nint https_sock6 = -1;\npid_t openssl_last_helper_pid = 0;\nchar *openssl_last_ip = NULL;\nstatic char *certret = NULL;\nstatic int certret_fd = -1;\nstatic mode_t omode;\nchar *certret_str = NULL;\nstatic char *dhret = NULL;\nstatic int dhret_fd = -1;\nchar *dhret_str = NULL;\nchar *new_dh_params = NULL;\nvoid raw_xfer(int csock, int s_in, int s_out);\nstatic char *get_input(char *tag, char **in);\nvoid ssl_helper_pid(pid_t pid, int sock);\nvoid accept_openssl(int mode, int presock);\nstatic void lose_ram(void);\nstatic int vencrypt_selected = 0;\nstatic int anontls_selected = 0;\nstatic int csock_timeout_sock = -1;\n\nvoid accept_openssl(int mode, int presock) {\n\tint sock = -1, listen = -1, cport, csock, vsock;\t\n\tint peerport = 0;\n\tint status, n, i, db = 0;\n\tstruct sockaddr_in addr;\n#ifdef __hpux\n\tint addrlen = sizeof(addr);\n#else\n\tsocklen_t addrlen = sizeof(addr);\n#endif\n\trfbClientPtr client;\n\tpid_t pid;\n\tchar uniq[] = \"_evilrats_\";\n\tchar cookie[256], rcookie[256], *name = NULL;\n\tint vencrypt_sel = 0;\n\tint anontls_sel = 0;\n\tchar *ipv6_name = NULL;\n\tstatic double last_https = 0.0;\n\tstatic char last_get[256];\n\tstatic int first = 1;\n\tunsigned char *rb;\n\n#if !LIBVNCSERVER_HAVE_LIBSSL && !HAVE_LIBSSL  \n\tif (enc_str == NULL || strcmp(enc_str, \"none\")) {\n\t\tbadnews(\"0 accept_openssl\");\n\t}\n#endif\n\n\topenssl_last_helper_pid = 0;\n\n\t/* zero buffers for use below. */\n\tfor (i=0; i<256; i++) {\n\t\tif (first) {\n\t\t\tlast_get[i] = '\\0';\n\t\t}\n\t\tcookie[i]  = '\\0';\n\t\trcookie[i] = '\\0';\n\t}\n\tfirst = 0;\n\n\tif (getenv(\"ACCEPT_OPENSSL_DEBUG\")) {\n\t\tdb = atoi(getenv(\"ACCEPT_OPENSSL_DEBUG\"));\n\t}\n\n\t/* do INETD, VNC, or HTTPS cases (result is client socket or pipe) */\n\tif (mode == OPENSSL_INETD) {\n\t\tssl_initialized = 1;\n\n\t} else if (mode == OPENSSL_VNC) {\n\t\tsock = accept(openssl_sock, (struct sockaddr *)&addr, &addrlen);\n\t\tif (sock < 0)  {\n\t\t\trfbLog(\"SSL: accept_openssl: accept connection failed\\n\");\n\t\t\trfbLogPerror(\"accept\");\n\t\t\tif (ssl_no_fail) {\n\t\t\t\tclean_up_exit(1);\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t\tlisten = openssl_sock;\n\n\t} else if (mode == OPENSSL_VNC6 || mode == OPENSSL_HTTPS6) {\n#if X11VNC_IPV6\n\t\tstruct sockaddr_in6 a6;\n\t\tsocklen_t a6len = sizeof(a6);\n\t\tint fd = (mode == OPENSSL_VNC6 ? openssl_sock6 : https_sock6); \n\n\t\tsock = accept(fd, (struct sockaddr *)&a6, &a6len);\n\t\tif (sock < 0)  {\n\t\t\trfbLog(\"SSL: accept_openssl: accept connection failed\\n\");\n\t\t\trfbLogPerror(\"accept\");\n\t\t\tif (ssl_no_fail) {\n\t\t\t\tclean_up_exit(1);\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t\tipv6_name = ipv6_getipaddr((struct sockaddr *)&a6, a6len);\n\t\tif (!ipv6_name) ipv6_name = strdup(\"unknown\");\n\t\tlisten = fd;\n#endif\n\t} else if (mode == OPENSSL_REVERSE) {\n\t\tsock = presock;\n\t\tif (sock < 0)  {\n\t\t\trfbLog(\"SSL: accept_openssl: connection failed\\n\");\n\t\t\tif (ssl_no_fail) {\n\t\t\t\tclean_up_exit(1);\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t\tif (getenv(\"OPENSSL_REVERSE_DEBUG\")) fprintf(stderr, \"OPENSSL_REVERSE: ipv6_client_ip_str: %s\\n\", ipv6_client_ip_str);\n\t\tif (ipv6_client_ip_str != NULL) {\n\t\t\tipv6_name = strdup(ipv6_client_ip_str);\n\t\t}\n\t\tlisten = -1;\n\n\t} else if (mode == OPENSSL_HTTPS) {\n\t\tsock = accept(https_sock, (struct sockaddr *)&addr, &addrlen);\n\t\tif (sock < 0)  {\n\t\t\trfbLog(\"SSL: accept_openssl: accept connection failed\\n\");\n\t\t\trfbLogPerror(\"accept\");\n\t\t\tif (ssl_no_fail) {\n\t\t\t\tclean_up_exit(1);\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t\tlisten = https_sock;\n\t}\n\tif (db) fprintf(stderr, \"SSL: accept_openssl: sock: %d\\n\", sock);\n\n\tif (openssl_last_ip) {\n\t\tfree(openssl_last_ip);\n\t\topenssl_last_ip = NULL;\n\t}\n\tif (mode == OPENSSL_INETD) {\n\t\topenssl_last_ip = get_remote_host(fileno(stdin));\n\t} else if (mode == OPENSSL_VNC6 || mode == OPENSSL_HTTPS6) {\n\t\topenssl_last_ip = ipv6_name;\n\t} else if (mode == OPENSSL_REVERSE && ipv6_name != NULL) {\n\t\topenssl_last_ip = ipv6_name;\n\t} else {\n\t\topenssl_last_ip = get_remote_host(sock);\n\t}\n\n\tif (!check_ssl_access(openssl_last_ip)) {\n\t\trfbLog(\"SSL: accept_openssl: denying client %s\\n\", openssl_last_ip);\n\t\trfbLog(\"SSL: accept_openssl: does not match -allow or other reason.\\n\");\n\t\tclose(sock);\n\t\tsock = -1;\n\t\tif (ssl_no_fail) {\n\t\t\tclean_up_exit(1);\n\t\t}\n\t\treturn;\n\t}\n\n\t/* now make a listening socket for child to connect back to us by: */\n\n\tcport = find_free_port(20000, 22000);\n\tif (! cport && ipv6_listen) {\n\t\trfbLog(\"SSL: accept_openssl: seeking IPv6 port.\\n\");\n\t\tcport = find_free_port6(20000, 22000);\n\t\trfbLog(\"SSL: accept_openssl: IPv6 port: %d\\n\", cport);\n\t}\n\tif (! cport) {\n\t\trfbLog(\"SSL: accept_openssl: could not find open port.\\n\");\n\t\tclose(sock);\n\t\tif (mode == OPENSSL_INETD || ssl_no_fail) {\n\t\t\tclean_up_exit(1);\n\t\t}\n\t\treturn;\n\t}\n\tif (db) fprintf(stderr, \"accept_openssl: cport: %d\\n\", cport);\n\n\tcsock = listen_tcp(cport, htonl(INADDR_LOOPBACK), 1);\n\n\tif (csock < 0) {\n\t\trfbLog(\"SSL: accept_openssl: could not listen on port %d.\\n\",\n\t\t    cport);\n\t\tclose(sock);\n\t\tif (mode == OPENSSL_INETD || ssl_no_fail) {\n\t\t\tclean_up_exit(1);\n\t\t}\n\t\treturn;\n\t}\n\tif (db) fprintf(stderr, \"accept_openssl: csock: %d\\n\", csock);\n\n\tfflush(stderr);\n\n\t/*\n\t * make a simple cookie to id the child socket, not foolproof\n\t * but hard to guess exactly (just worrying about local lusers\n\t * here, since we use INADDR_LOOPBACK).\n\t */\n\trb = (unsigned char *) calloc(6, 1);\n#if LIBVNCSERVER_HAVE_LIBSSL || HAVE_LIBSSL \n\tRAND_bytes(rb, 6);\n#endif\n\tsprintf(cookie, \"RB=%d%d%d%d%d%d/%f%f/%p\",\n\t    rb[0], rb[1], rb[2], rb[3], rb[4], rb[5],\n            dnow() - x11vnc_start, x11vnc_start, (void *)rb);\n\n\tif (mode == OPENSSL_VNC6) {\n\t\tname = strdup(ipv6_name);\n\t\tpeerport = get_remote_port(sock);\n\t} else if (mode == OPENSSL_REVERSE && ipv6_name != NULL) {\n\t\tname = strdup(ipv6_name);\n\t\tpeerport = get_remote_port(sock);\n\t} else if (mode != OPENSSL_INETD) {\n\t\tname = get_remote_host(sock);\n\t\tpeerport = get_remote_port(sock);\n\t} else {\n\t\topenssl_last_ip = get_remote_host(fileno(stdin));\n\t\tpeerport = get_remote_port(fileno(stdin));\n\t\tif (openssl_last_ip) {\n\t\t\tname = strdup(openssl_last_ip);\n\t\t} else {\n\t\t\tname = strdup(\"unknown\");\n\t\t}\n\t}\n\tif (name) {\n\t\tif (mode == OPENSSL_INETD) {\n\t\t\trfbLog(\"SSL: (inetd) spawning helper process \"\n\t\t\t    \"to handle: %s:%d\\n\", name, peerport);\n\t\t} else {\n\t\t\trfbLog(\"SSL: spawning helper process to handle: \"\n\t\t\t    \"%s:%d\\n\", name, peerport);\n\t\t}\n\t\tfree(name);\n\t\tname = NULL;\n\t}\n\n\tif (certret) {\n\t\tfree(certret);\n\t}\n\tif (certret_str) {\n\t\tfree(certret_str);\n\t\tcertret_str = NULL;\n\t}\n\tcertret = strdup(\"/tmp/x11vnc-certret.XXXXXX\");\n\tomode = umask(077);\n\tcertret_fd = mkstemp(certret);\n\tumask(omode);\n\tif (certret_fd < 0) {\n\t\tfree(certret);\n\t\tcertret = NULL;\n\t\tcertret_fd = -1;\n\t}\n\n\tif (dhret) {\n\t\tfree(dhret);\n\t}\n\tif (dhret_str) {\n\t\tfree(dhret_str);\n\t\tdhret_str = NULL;\n\t}\n\tdhret = strdup(\"/tmp/x11vnc-dhret.XXXXXX\");\n\tomode = umask(077);\n\tdhret_fd = mkstemp(dhret);\n\tumask(omode);\n\tif (dhret_fd < 0) {\n\t\tfree(dhret);\n\t\tdhret = NULL;\n\t\tdhret_fd = -1;\n\t}\n\n\t/* now fork the child to handle the SSL: */\n\tpid = fork();\n\n\tif (pid > 0) {\n\t\trfbLog(\"SSL: helper for peerport %d is pid %d: \\n\",\n\t\t    peerport, (int) pid);\n\t}\n\n\tif (pid < 0) {\n\t\trfbLog(\"SSL: accept_openssl: could not fork.\\n\");\n\t\trfbLogPerror(\"fork\");\n\t\tclose(sock);\n\t\tclose(csock);\n\t\tif (mode == OPENSSL_INETD || ssl_no_fail) {\n\t\t\tclean_up_exit(1);\n\t\t}\n\t\treturn;\n\n\t} else if (pid == 0) {\n\t\tint s_in, s_out, httpsock = -1;\n\t\tint vncsock;\n\t\tint i, have_httpd = 0;\n\t\tint f_in  = fileno(stdin);\n\t\tint f_out = fileno(stdout);\n\t\tint skip_vnc_tls = mode == OPENSSL_HTTPS ? 1 : 0;\n\n\t\tif (db) fprintf(stderr, \"helper pid in: %d %d %d %d\\n\", f_in, f_out, sock, listen);\n\n\t\t/* reset all handlers to default (no interrupted() calls) */\n\t\tunset_signals();\n\n\t\t/* close all non-essential fd's */\n\t\tfor (i=0; i<256; i++) {\n\t\t\tif (mode == OPENSSL_INETD) {\n\t\t\t\tif (i == f_in || i == f_out) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (i == sock) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (i == 2) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tclose(i);\n\t\t}\n\n\t\t/*\n\t\t * sadly, we are a long lived child and so the large\n\t\t * framebuffer memory areas will soon differ from parent.\n\t\t * try to free as much as possible.\n\t\t */\n\t\tlose_ram();\n\n\t\t/* now connect back to parent socket: */\n\t\tvncsock = connect_tcp(\"127.0.0.1\", cport);\n\t\tif (vncsock < 0) {\n\t\t\trfbLog(\"SSL: ssl_helper[%d]: could not connect\"\n\t\t\t    \" back to: %d\\n\", getpid(), cport);\n\t\t\trfbLog(\"SSL: ssl_helper[%d]: exit case 1 (no local vncsock)\\n\", getpid());\n\t\t\texit(1);\n\t\t}\n\t\tif (db) fprintf(stderr, \"vncsock %d\\n\", vncsock);\n\n\t\t/* try to initialize SSL with the remote client */\n\n\t\tif (mode == OPENSSL_INETD) {\n\t\t\ts_in  = fileno(stdin);\n\t\t\ts_out = fileno(stdout);\n\t\t} else {\n\t\t\ts_in = s_out = sock;\n\t\t}\n\n\t\tif (! ssl_init(s_in, s_out, skip_vnc_tls, last_https)) {\n\t\t\tclose(vncsock);\n\t\t\trfbLog(\"SSL: ssl_helper[%d]: exit case 2 (ssl_init failed)\\n\", getpid());\n\t\t\texit(1);\n\t\t}\n\n\t\tif (vencrypt_selected != 0) {\n\t\t\tchar *tbuf;\n\t\t\ttbuf = (char *) malloc(strlen(cookie) + 100);\n\t\t\tsprintf(tbuf, \"%s,VENCRYPT=%d,%s\", uniq, vencrypt_selected, cookie);\n\t\t\twrite(vncsock, tbuf, strlen(cookie));\n\t\t\tgoto wrote_cookie;\n\t\t} else if (anontls_selected != 0) {\n\t\t\tchar *tbuf;\n\t\t\ttbuf = (char *) malloc(strlen(cookie) + 100);\n\t\t\tsprintf(tbuf, \"%s,ANONTLS=%d,%s\", uniq, anontls_selected, cookie);\n\t\t\twrite(vncsock, tbuf, strlen(cookie));\n\t\t\tgoto wrote_cookie;\n\t\t}\n\n\t\t/*\n\t\t * things get messy below since we are trying to do\n\t\t * *both* VNC and Java applet httpd through the same\n\t\t * SSL socket.\n\t\t */\n\n\t\tif (! screen) {\n\t\t\tclose(vncsock);\n\t\t\texit(1);\n\t\t}\n\t\tif (screen->httpListenSock >= 0 && screen->httpPort > 0) {\n\t\t\thave_httpd = 1;\n\t\t} else if (ipv6_http_fd >= 0) {\n\t\t\thave_httpd = 1;\n\t\t} else if (screen->httpListenSock == -2) {\n\t\t\thave_httpd = 1;\n\t\t}\n\t\tif (mode == OPENSSL_HTTPS && ! have_httpd) {\n\t\t\trfbLog(\"SSL: accept_openssl[%d]: no httpd socket for \"\n\t\t\t    \"-https mode\\n\", getpid());\n\t\t\tclose(vncsock);\n\t\t\trfbLog(\"SSL: ssl_helper[%d]: exit case 3 (no httpd sock)\\n\", getpid());\n\t\t\texit(1);\n\t\t}\n\n\t\tif (have_httpd) {\n\t\t\tint n = 0, is_http = 0;\n\t\t\tint hport = screen->httpPort; \n\t\t\tchar *iface = NULL;\n\t\t\tchar *buf, *tbuf;\n\n\t\t\tbuf  = (char *) calloc((ABSIZE+1), 1);\n\t\t\ttbuf = (char *) calloc((2*ABSIZE+1), 1);\n\n\t\t\tif (mode == OPENSSL_HTTPS) {\n\t\t\t\t/*\n\t\t\t\t * for this mode we know it is HTTP traffic\n\t\t\t\t * so we skip trying to guess.\n\t\t\t\t */\n\t\t\t\tis_http = 1;\n\t\t\t\tn = 0;\n\t\t\t\tgoto connect_to_httpd;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * Check if there is stuff to read from remote end\n\t\t\t * if so it is likely a GET or HEAD.\n\t\t\t */\n\t\t\tif (! is_ssl_readable(s_in, last_https, last_get,\n\t\t\t    mode)) {\n\t\t\t\tgoto write_cookie;\n\t\t\t}\n\t\n\t\t\t/* \n\t\t\t * read first 2 bytes to try to guess.  sadly,\n\t\t\t * the user is often pondering a \"non-verified\n\t\t\t * cert\" dialog for a long time before the GET\n\t\t\t * is ever sent.  So often we timeout here.\n\t\t\t */\n\n\t\t\tif (db) fprintf(stderr, \"watch_for_http_traffic\\n\");\n\n\t\t\tis_http = watch_for_http_traffic(buf, &n, s_in);\n\n\t\t\tif (is_http < 0 || is_http == 0) {\n\t\t\t\t/*\n\t\t\t\t * error or http not detected, fall back\n\t\t\t\t * to normal VNC socket.\n\t\t\t\t */\n\t\t\t\tif (db) fprintf(stderr, \"is_http err: %d n: %d\\n\", is_http, n);\n\t\t\t\twrite(vncsock, cookie, strlen(cookie));\n\t\t\t\tif (n > 0) {\n\t\t\t\t\twrite(vncsock, buf, n);\n\t\t\t\t}\n\t\t\t\tgoto wrote_cookie;\n\t\t\t}\n\n\t\t\tif (db) fprintf(stderr, \"is_http: %d n: %d\\n\",\n\t\t\t    is_http, n);\n\t\t\tif (db) fprintf(stderr, \"buf: '%s'\\n\", buf);\n\n\t\t\tif (strstr(buf, \"/request.https.vnc.connection\")) {\n\t\t\t\tchar reply[] = \"HTTP/1.0 200 OK\\r\\n\"\n\t\t\t\t    \"Content-Type: octet-stream\\r\\n\"\n\t\t\t\t    \"Connection: Keep-Alive\\r\\n\"\n\t\t\t\t    \"VNC-Server: x11vnc\\r\\n\"\n\t\t\t\t    \"Pragma: no-cache\\r\\n\\r\\n\";\n\t\t\t\t/*\n\t\t\t\t * special case proxy coming thru https\n\t\t\t\t * instead of a direct SSL connection.\n\t\t\t\t */\n\t\t\t\trfbLog(\"Handling VNC request via https GET. [%d]\\n\", getpid());\n\t\t\t\trfbLog(\"-- %s\\n\", buf);\n\n\t\t\t\tif (strstr(buf, \"/reverse.proxy\")) {\n\t\t\t\t\tchar *buf2;\n\t\t\t\t\tint n, ptr;\n#if !LIBVNCSERVER_HAVE_LIBSSL && !HAVE_LIBSSL \n\t\t\t\t\twrite(s_out, reply, strlen(reply));\n#else\n\t\t\t\t\tSSL_write(ssl, reply, strlen(reply));\n#endif\n\t\t\t\t\n\t\t\t\t\tbuf2  = (char *) calloc((8192+1), 1);\n\t\t\t\t\tn = 0;\n\t\t\t\t\tptr = 0;\n\t\t\t\t\twhile (ptr < 8192) {\n#if !LIBVNCSERVER_HAVE_LIBSSL && !HAVE_LIBSSL \n\t\t\t\t\t\tn = read(s_in, buf2 + ptr, 1);\n#else\n\t\t\t\t\t\tn = SSL_read(ssl, buf2 + ptr, 1);\n#endif\n\t\t\t\t\t\tif (n > 0) {\n\t\t\t\t\t\t\tptr += n;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (db) fprintf(stderr, \"buf2: '%s'\\n\", buf2);\n\n\t\t\t\t\t\tif (strstr(buf2, \"\\r\\n\\r\\n\")) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tfree(buf2);\n\t\t\t\t}\n\t\t\t\tgoto write_cookie;\n\n\t\t\t} else if (strstr(buf, \"/check.https.proxy.connection\")) {\n\t\t\t\tchar reply[] = \"HTTP/1.0 200 OK\\r\\n\"\n\t\t\t\t    \"Connection: close\\r\\n\"\n\t\t\t\t    \"Content-Type: octet-stream\\r\\n\"\n\t\t\t\t    \"VNC-Server: x11vnc\\r\\n\"\n\t\t\t\t    \"Pragma: no-cache\\r\\n\\r\\n\";\n\n\t\t\t\trfbLog(\"Handling Check HTTPS request via https GET. [%d]\\n\", getpid());\n\t\t\t\trfbLog(\"-- %s\\n\", buf);\n\n#if !LIBVNCSERVER_HAVE_LIBSSL && !HAVE_LIBSSL \n\t\t\t\twrite(s_out, reply, strlen(reply));\n#else\n\t\t\t\tSSL_write(ssl, reply, strlen(reply));\n\t\t\t\tSSL_shutdown(ssl);\n#endif\n\n\t\t\t\tstrcpy(tbuf, uniq);\n\t\t\t\tstrcat(tbuf, cookie);\n\t\t\t\twrite(vncsock, tbuf, strlen(tbuf));\n\t\t\t\tclose(vncsock);\n\n\t\t\t\trfbLog(\"SSL: ssl_helper[%d]: exit case 4 (check.https.proxy.connection)\\n\", getpid());\n\t\t\t\texit(0);\n\t\t\t}\n\t\t\tconnect_to_httpd:\n\n\t\t\t/*\n\t\t\t * Here we go... no turning back.  we have to\n\t\t\t * send failure to parent and close socket to have\n\t\t\t * http processed at all in a timely fashion...\n\t\t\t */\n\n\t\t\t/* send the failure tag: */\n\t\t\tstrcpy(tbuf, uniq);\n\n\t\t\tif (https_port_redir < 0 || (strstr(buf, \"PORT=\") || strstr(buf, \"port=\"))) {\n\t\t\t\tchar *q = strstr(buf, \"Host:\");\n\t\t\t\tint fport = 443, match = 0;\n\t\t\t\tchar num[16];\n\n\t\t\t\tif (q && strstr(q, \"\\n\")) {\n\t\t\t\t    q += strlen(\"Host:\") + 1;\n\t\t\t\t    while (*q != '\\n') {\n\t\t\t\t\tint p;\n\t\t\t\t\tif (*q == ':' && sscanf(q, \":%d\", &p) == 1) {\n\t\t\t\t\t\tif (p > 0 && p < 65536) {\n\t\t\t\t\t\t\tfport = p;\n\t\t\t\t\t\t\tmatch = 1;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tq++;\n\t\t\t\t    }\n\t\t\t\t}\n\t\t\t\tif (!match || !https_port_redir) {\n\t\t\t\t\tint p;\n\t\t\t\t\tif (sscanf(buf, \"PORT=%d,\", &p) == 1) {\n\t\t\t\t\t\tif (p > 0 && p < 65536) {\n\t\t\t\t\t\t\tfport = p;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else if (sscanf(buf, \"port=%d,\", &p) == 1) {\n\t\t\t\t\t\tif (p > 0 && p < 65536) {\n\t\t\t\t\t\t\tfport = p;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tsprintf(num, \"HP=%d,\", fport);\n\t\t\t\tstrcat(tbuf, num);\n\t\t\t}\n\n\t\t\tif (strstr(buf, \"HTTP/\") != NULL)  {\n\t\t\t\tchar *q, *str;\n\t\t\t\t/*\n\t\t\t\t * Also send back the GET line for heuristics.\n\t\t\t\t * (last_https, get file).\n\t\t\t\t */\n\t\t\t\tstr = strdup(buf);\n\t\t\t\tq = strstr(str, \"HTTP/\");\n\t\t\t\tif (q != NULL) {\n\t\t\t\t\t*q = '\\0';\t\n\t\t\t\t\tstrcat(tbuf, str);\n\t\t\t\t}\n\t\t\t\tfree(str);\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * Also send the cookie to pad out the number of\n\t\t\t * bytes to more than the parent wants to read.\n\t\t\t * Since this is the failure case, it does not\n\t\t\t * matter that we send more than strlen(cookie).\n\t\t\t */\n\t\t\tstrcat(tbuf, cookie);\n\t\t\twrite(vncsock, tbuf, strlen(tbuf));\n\n\t\t\tusleep(150*1000);\n\t\t\tif (db) fprintf(stderr, \"close vncsock: %d\\n\", vncsock);\n\t\t\tclose(vncsock);\n\n\t\t\t/* now, finally, connect to the libvncserver httpd: */\n\t\t\tif (screen->listenInterface == htonl(INADDR_ANY) ||\n\t\t\t    screen->listenInterface == htonl(INADDR_NONE)) {\n\t\t\t\tiface = \"127.0.0.1\";\n\t\t\t} else {\n\t\t\t\tstruct in_addr in;\n\t\t\t\tin.s_addr = screen->listenInterface;\n\t\t\t\tiface = inet_ntoa(in);\n\t\t\t}\n\t\t\tif (iface == NULL || !strcmp(iface, \"\")) {\n\t\t\t\tiface = \"127.0.0.1\";\n\t\t\t}\n\t\t\tif (db) fprintf(stderr, \"iface: %s:%d\\n\", iface, hport);\n\t\t\tusleep(150*1000);\n\n\t\t\thttpsock = connect_tcp(iface, hport);\n\n\t\t\tif (httpsock < 0) {\n\t\t\t\t/* UGH, after all of that! */\n\t\t\t\trfbLog(\"Could not connect to httpd socket!\\n\");\n\t\t\t\trfbLog(\"SSL: ssl_helper[%d]: exit case 5.\\n\", getpid());\n\t\t\t\texit(1);\n\t\t\t}\n\t\t\tif (db) fprintf(stderr, \"ssl_helper[%d]: httpsock: %d %d\\n\",\n\t\t\t    getpid(), httpsock, n);\n\n\t\t\t/*\n\t\t\t * send what we read to httpd, and then connect\n\t\t\t * the rest of the SSL session to it:\n\t\t\t */\n\t\t\tif (n > 0) {\n\t\t\t\tchar *s = getenv(\"X11VNC_EXTRA_HTTPS_PARAMS\");\n\t\t\t\tint did_extra = 0;\n\n\t\t\t\tif (db) fprintf(stderr, \"sending http buffer httpsock: %d n=%d\\n'%s'\\n\", httpsock, n, buf);\n\t\t\t\tif (s != NULL) {\n\t\t\t\t\tchar *q = strstr(buf, \" HTTP/\");\n\t\t\t\t\tif (q) {\n\t\t\t\t\t\tint m;\n\t\t\t\t\t\t*q = '\\0';\n\t\t\t\t\t\tm = strlen(buf);\n\t\t\t\t\t\twrite(httpsock, buf, m);\n\t\t\t\t\t\twrite(httpsock, s, strlen(s));\n\t\t\t\t\t\t*q = ' ';\n\t\t\t\t\t\twrite(httpsock, q, n-m);\n\t\t\t\t\t\tdid_extra = 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (!did_extra) {\n\t\t\t\t\twrite(httpsock, buf, n);\n\t\t\t\t}\n\t\t\t}\n\t\t\tssl_xfer(httpsock, s_in, s_out, is_http);\n\t\t\trfbLog(\"SSL: ssl_helper[%d]: exit case 6 (https ssl_xfer done)\\n\", getpid());\n\t\t\texit(0);\n\t\t}\n\n\t\t/*\n\t\t * ok, back from the above https mess, simply send the\n\t\t * cookie back to the parent (who will attach us to\n\t\t * libvncserver), and connect the rest of the SSL session\n\t\t * to it.\n\t\t */\n\t\twrite_cookie:\n\t\twrite(vncsock, cookie, strlen(cookie));\n\n\t\twrote_cookie:\n\t\tssl_xfer(vncsock, s_in, s_out, 0);\n\t\trfbLog(\"SSL: ssl_helper[%d]: exit case 7 (ssl_xfer done)\\n\", getpid());\n\t\tif (0) usleep(50 * 1000);\n\t\texit(0);\n\t}\n\t/* parent here */\n\n\tif (mode != OPENSSL_INETD) {\n\t\tclose(sock);\n\t}\n\tif (db) fprintf(stderr, \"helper process is: %d\\n\", pid);\n\n\t/* accept connection from our child.  */\n\tsignal(SIGALRM, csock_timeout);\n\tcsock_timeout_sock = csock;\n\talarm(20);\n\n\tvsock = accept(csock, (struct sockaddr *)&addr, &addrlen);\n\n\talarm(0);\n\tsignal(SIGALRM, SIG_DFL);\n\tclose(csock);\n\n\n\tif (vsock < 0) {\n\t\trfbLog(\"SSL: accept_openssl: connection from ssl_helper[%d] FAILED.\\n\", pid);\n\t\trfbLogPerror(\"accept\");\n\n\t\tkill(pid, SIGTERM);\n\t\twaitpid(pid, &status, WNOHANG); \n\t\tif (mode == OPENSSL_INETD || ssl_no_fail) {\n\t\t\tclean_up_exit(1);\n\t\t}\n\t\tif (certret_fd >= 0) {\n\t\t\tclose(certret_fd);\n\t\t\tcertret_fd = -1;\n\t\t}\n\t\tif (certret) {\n\t\t\tunlink(certret);\n\t\t}\n\t\tif (dhret_fd >= 0) {\n\t\t\tclose(dhret_fd);\n\t\t\tdhret_fd = -1;\n\t\t}\n\t\tif (dhret) {\n\t\t\tunlink(dhret);\n\t\t}\n\t\treturn;\n\t}\n\tif (db) fprintf(stderr, \"accept_openssl: vsock: %d\\n\", vsock);\n\n\tn = read(vsock, rcookie, strlen(cookie));\n\tif (n < 0 && errno != 0) {\n\t\trfbLogPerror(\"read\");\n\t}\n\n\tif (certret) {\n\t\tstruct stat sbuf;\n\t\tsbuf.st_size = 0;\n\t\tif (certret_fd >= 0 && stat(certret, &sbuf) == 0 && sbuf.st_size > 0) {\n\t\t\tcertret_str = (char *) calloc(sbuf.st_size+1, 1);\n\t\t\tread(certret_fd, certret_str, sbuf.st_size);\n\t\t\tclose(certret_fd);\n\t\t\tcertret_fd = -1;\n\t\t}\n\t\tif (certret_fd >= 0) {\n\t\t\tclose(certret_fd);\n\t\t\tcertret_fd = -1;\n\t\t}\n\t\tunlink(certret);\n\t\tif (certret_str && strstr(certret_str, \"NOCERT\") == certret_str) {\n\t\t\tfree(certret_str);\n\t\t\tcertret_str = NULL;\n\t\t}\n\t\tif (0 && certret_str) {\n\t\t\tfprintf(stderr, \"certret_str[%d]:\\n%s\\n\", (int) sbuf.st_size, certret_str);\n\t\t}\n\t}\n\n\tif (dhret) {\n\t\tstruct stat sbuf;\n\t\tsbuf.st_size = 0;\n\t\tif (dhret_fd >= 0 && stat(dhret, &sbuf) == 0 && sbuf.st_size > 0) {\n\t\t\tdhret_str = (char *) calloc(sbuf.st_size+1, 1);\n\t\t\tread(dhret_fd, dhret_str, sbuf.st_size);\n\t\t\tclose(dhret_fd);\n\t\t\tdhret_fd = -1;\n\t\t}\n\t\tif (dhret_fd >= 0) {\n\t\t\tclose(dhret_fd);\n\t\t\tdhret_fd = -1;\n\t\t}\n\t\tunlink(dhret);\n\t\tif (dhret_str && strstr(dhret_str, \"NOCERT\") == dhret_str) {\n\t\t\tfree(dhret_str);\n\t\t\tdhret_str = NULL;\n\t\t}\n\t\tif (dhret_str) {\n\t\t\tif (new_dh_params == NULL) {\n\t\t\t\tfprintf(stderr, \"dhret_str[%d]:\\n%s\\n\", (int) sbuf.st_size, dhret_str);\n\t\t\t\tnew_dh_params = strdup(dhret_str);\n\t\t\t}\n\t\t}\n\t}\n\n\tif (0) {\n\t\tfprintf(stderr, \"rcookie: %s\\n\", rcookie);\n\t\tfprintf(stderr, \"cookie:  %s\\n\", cookie);\n\t}\n\n\tif (strstr(rcookie, uniq) == rcookie) {\n\t\tchar *q = strstr(rcookie, \"RB=\");\n\t\tif (q && strstr(cookie, q) == cookie) {\n\t\t\tvencrypt_sel = 0;\n\t\t\tanontls_sel = 0;\n\t\t\tq = strstr(rcookie, \"VENCRYPT=\");\n\t\t\tif (q && sscanf(q, \"VENCRYPT=%d,\", &vencrypt_sel) == 1) {\n\t\t\t\tif (vencrypt_sel != 0) {\n\t\t\t\t\trfbLog(\"SSL: VENCRYPT mode=%d accepted. helper[%d]\\n\", vencrypt_sel, pid);\n\t\t\t\t\tgoto accept_client;\n\t\t\t\t}\n\t\t\t}\n\t\t\tq = strstr(rcookie, \"ANONTLS=\");\n\t\t\tif (q && sscanf(q, \"ANONTLS=%d,\", &anontls_sel) == 1) {\n\t\t\t\tif (anontls_sel != 0) {\n\t\t\t\t\trfbLog(\"SSL: ANONTLS mode=%d accepted. helper[%d]\\n\", anontls_sel, pid);\n\t\t\t\t\tgoto accept_client;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tif (n != (int) strlen(cookie) || strncmp(cookie, rcookie, n)) {\n\t\trfbLog(\"SSL: accept_openssl: cookie from ssl_helper[%d] FAILED. %d\\n\", pid, n);\n\t\tif (db) fprintf(stderr, \"'%s'\\n'%s'\\n\", cookie, rcookie);\n\t\tclose(vsock);\n\n\t\tif (strstr(rcookie, uniq) == rcookie) {\n\t\t\tint i;\n\t\t\tdouble https_download_wait_time = 15.0;\n\n\t\t\tif (getenv(\"X11VNC_HTTPS_DOWNLOAD_WAIT_TIME\")) {\n\t\t\t\thttps_download_wait_time = atof(getenv(\"X11VNC_HTTPS_DOWNLOAD_WAIT_TIME\"));\n\t\t\t}\n\n\t\t\trfbLog(\"SSL: BUT WAIT! HTTPS for helper process[%d] succeeded. Good.\\n\", pid);\n\t\t\tif (mode != OPENSSL_HTTPS) {\n\t\t\t\tlast_https = dnow();\n\t\t\t\tfor (i=0; i<256; i++) {\n\t\t\t\t\tlast_get[i] = '\\0';\n\t\t\t\t}\n\t\t\t\tstrncpy(last_get, rcookie, 100);\n\t\t\t\tif (db) fprintf(stderr, \"last_get: '%s'\\n\", last_get);\n\t\t\t}\n\t\t\tif (rcookie && strstr(rcookie, \"VncViewer.class\")) {\n\t\t\t\trfbLog(\"\\n\");\n\t\t\t\trfbLog(\"helper[%d]:\\n\", pid);\n\t\t\t\trfbLog(\"***********************************************************\\n\");\n\t\t\t\trfbLog(\"SSL: WARNING CLIENT ASKED FOR NONEXISTENT 'VncViewer.class'\\n\");\n\t\t\t\trfbLog(\"SSL: USER NEEDS TO MAKE SURE THE JAVA PLUGIN IS INSTALLED\\n\");\n\t\t\t\trfbLog(\"SSL: AND WORKING PROPERLY (e.g. a test-java-plugin page.)\\n\");\n\t\t\t\trfbLog(\"SSL: AND/OR USER NEEDS TO **RESTART** HIS WEB BROWSER.\\n\");\n\t\t\t\trfbLog(\"SSL: SOMETIMES THE BROWSER 'REMEMBERS' FAILED APPLET DOWN-\\n\");\n\t\t\t\trfbLog(\"SSL: LOADS AND RESTARTING IT IS THE ONLY WAY TO FIX THINGS.\\n\");\n\t\t\t\trfbLog(\"***********************************************************\\n\");\n\t\t\t\trfbLog(\"\\n\");\n\t\t\t}\n\t\t\tssl_helper_pid(pid, -2);\n\n\t\t\tif (https_port_redir) {\n\t\t\t\tdouble start;\n\t\t\t\tint origport = screen->port;\n\t\t\t\tint useport = screen->port;\n\t\t\t\tint saw_httpsock = 0;\n\t\t\t\t/* to expand $PORT correctly in index.vnc */\n\t\t\t\tif (https_port_redir < 0) {\n\t\t\t\t\tchar *q = strstr(rcookie, \"HP=\");\n\t\t\t\t\tif (q) {\n\t\t\t\t\t\tint p;\n\t\t\t\t\t\tif (sscanf(q, \"HP=%d,\", &p) == 1) {\n\t\t\t\t\t\t\tuseport = p;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tuseport = https_port_redir;\n\t\t\t\t}\n\t\t\t\tscreen->port = useport;\n\t\t\t\tif (origport != useport) {\n\t\t\t\t\trfbLog(\"SSL: -httpsredir guess port: %d  helper[%d]\\n\", screen->port, pid);\n\t\t\t\t}\n\n\t\t\t\tstart = dnow();\n\t\t\t\twhile (dnow() < start + https_download_wait_time) {\n\t\t\t\t\tif (screen->httpSock >= 0) saw_httpsock = 1;\n\t\t\t\t\trfbPE(10000);\n\t\t\t\t\tusleep(10000);\n\t\t\t\t\tif (screen->httpSock >= 0) saw_httpsock = 1;\n\t\t\t\t\twaitpid(pid, &status, WNOHANG); \n\t\t\t\t\tif (kill(pid, 0) != 0) {\n\t\t\t\t\t\trfbLog(\"SSL: helper[%d] pid finished\\n\", pid);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif (0 && saw_httpsock && screen->httpSock < 0) {\n\t\t\t\t\t\t/* this check can kill the helper too soon. */\n\t\t\t\t\t\trfbLog(\"SSL: httpSock for helper[%d] went away\\n\", pid);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\trfbLog(\"SSL: guessing child helper[%d] https finished. dt=%.6f\\n\",\n\t\t\t\t    pid, dnow() - start);\n\n\t\t\t\trfbPE(10000);\n\t\t\t\trfbPE(10000);\n\t\t\t\trfbPE(10000);\n\n\t\t\t\tscreen->port = origport;\n\t\t\t\tssl_helper_pid(0, -2);\n\t\t\t\tif (mode == OPENSSL_INETD) {\n\t\t\t\t\tclean_up_exit(1);\n\t\t\t\t}\n\t\t\t} else if (mode == OPENSSL_INETD) {\n\t\t\t\tdouble start;\n\t\t\t\tint saw_httpsock = 0;\n\n\t\t\t\t/* to expand $PORT correctly in index.vnc */\n\t\t\t\tif (screen->port == 0) {\n\t\t\t\t\tint fd = fileno(stdin);\n\t\t\t\t\tif (getenv(\"X11VNC_INETD_PORT\")) {\n\t\t\t\t\t\t/* mutex */\n\t\t\t\t\t\tscreen->port = atoi(getenv(\n\t\t\t\t\t\t    \"X11VNC_INETD_PORT\"));\n\t\t\t\t\t} else {\n\t\t\t\t\t\tint tport = get_local_port(fd);\n\t\t\t\t\t\tif (tport > 0) {\n\t\t\t\t\t\t\tscreen->port = tport;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\trfbLog(\"SSL: screen->port %d for helper[%d]\\n\", screen->port, pid);\n\n\t\t\t\t/* kludge for https fetch via inetd */\n\t\t\t\tstart = dnow();\n\t\t\t\twhile (dnow() < start + https_download_wait_time) {\n\t\t\t\t\tif (screen->httpSock >= 0) saw_httpsock = 1;\n\t\t\t\t\trfbPE(10000);\n\t\t\t\t\tusleep(10000);\n\t\t\t\t\tif (screen->httpSock >= 0) saw_httpsock = 1;\n\t\t\t\t\twaitpid(pid, &status, WNOHANG); \n\t\t\t\t\tif (kill(pid, 0) != 0) {\n\t\t\t\t\t\trfbLog(\"SSL: helper[%d] pid finished\\n\", pid);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif (0 && saw_httpsock && screen->httpSock < 0) {\n\t\t\t\t\t\t/* this check can kill the helper too soon. */\n\t\t\t\t\t\trfbLog(\"SSL: httpSock for helper[%d] went away\\n\", pid);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\trfbLog(\"SSL: OPENSSL_INETD guessing \"\n\t\t\t\t    \"child helper[%d] https finished. dt=%.6f\\n\",\n\t\t\t\t    pid, dnow() - start);\n\n\t\t\t\trfbPE(10000);\n\t\t\t\trfbPE(10000);\n\t\t\t\trfbPE(10000);\n\n\t\t\t\tssl_helper_pid(0, -2);\n\t\t\t\tclean_up_exit(1);\n\t\t\t}\n\t\t\t/* this will actually only get earlier https */\n\t\t\tssl_helper_pid(0, -2);\n\t\t\treturn;\n\t\t}\n\t\tkill(pid, SIGTERM);\n\t\twaitpid(pid, &status, WNOHANG); \n\t\tif (mode == OPENSSL_INETD || ssl_no_fail) {\n\t\t\tclean_up_exit(1);\n\t\t}\n\t\treturn;\n\t}\n\n\taccept_client:\n\n\tif (db) fprintf(stderr, \"accept_openssl: cookie good: %s\\n\", cookie);\n\n\trfbLog(\"SSL: handshake with helper process[%d] succeeded.\\n\", pid);\n\n\topenssl_last_helper_pid = pid;\n\tssl_helper_pid(pid, vsock);\n\n\tif (vnc_redirect) {\n\t\tvnc_redirect_sock = vsock;\n\t\topenssl_last_helper_pid = 0;\n\t\treturn;\n\t}\n\n\tclient = create_new_client(vsock, 0);\n\topenssl_last_helper_pid = 0;\n\n\tif (client) {\n\t\tint swt = 0;\n\t\tif (mode == OPENSSL_VNC6 && openssl_last_ip != NULL) {\n\t\t\tswt = 1;\n\t\t} else if (mode == OPENSSL_REVERSE && ipv6_name != NULL && openssl_last_ip != NULL) {\n\t\t\tswt = 1;\n\t\t}\n\t\tif (swt) {\n\t\t\tif (client->host) {\n\t\t\t\tfree(client->host);\n\t\t\t}\n\t\t\tclient->host = strdup(openssl_last_ip);\n\t\t}\n\t\tif (db) fprintf(stderr, \"accept_openssl: client %p\\n\", (void *) client);\n\t\tif (db) fprintf(stderr, \"accept_openssl: new_client %p\\n\", (void *) screen->newClientHook);\n\t\tif (db) fprintf(stderr, \"accept_openssl: new_client %p\\n\", (void *) new_client);\n\t\tif (mode == OPENSSL_INETD) {\n\t\t\tinetd_client = client;\n\t\t\tclient->clientGoneHook = client_gone;\n\t\t}\n\t\tif (openssl_last_ip &&\n\t\t    strpbrk(openssl_last_ip, \"0123456789\") == openssl_last_ip) {\n\t\t\tclient->host = strdup(openssl_last_ip);\n\t\t}\n\t\tif (vencrypt_sel != 0) {\n\t\t\tclient->protocolMajorVersion = 3;\n\t\t\tclient->protocolMinorVersion = 8;\n#if LIBVNCSERVER_HAVE_LIBSSL || HAVE_LIBSSL \n\t\t\tif (!finish_vencrypt_auth(client, vencrypt_sel)) {\n\t\t\t\trfbCloseClient(client);\n\t\t\t\tclient = NULL;\n\t\t\t}\n#else\n\t\t\tbadnews(\"3 accept_openssl\");\n#endif\n\t\t} else if (anontls_sel != 0) {\n\t\t\tclient->protocolMajorVersion = 3;\n\t\t\tclient->protocolMinorVersion = 8;\n\t\t\trfbAuthNewClient(client);\n\t\t}\n\t\tif (use_threads && client != NULL) {\n\t\t\trfbStartOnHoldClient(client);\n\t\t}\n\t\t/* try to get RFB proto done now. */\n\t\tprogress_client();\n\t} else {\n\t\trfbLog(\"SSL: accept_openssl: rfbNewClient failed.\\n\");\n\t\tclose(vsock);\n\n\t\tkill(pid, SIGTERM);\n\t\twaitpid(pid, &status, WNOHANG); \n\t\tif (mode == OPENSSL_INETD || ssl_no_fail) {\n\t\t\tclean_up_exit(1);\n\t\t}\n\t\treturn;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "perror",
          "args": [
            "\"setsid\""
          ],
          "line": 1501
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"setsid failed\\n\""
          ],
          "line": 1500
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLogEnable",
          "args": [
            "1"
          ],
          "line": 1499
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "setsid",
          "args": [],
          "line": 1498
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "perror",
          "args": [
            "\"fork\""
          ],
          "line": 1495
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"could not fork\\n\""
          ],
          "line": 1494
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLogEnable",
          "args": [
            "1"
          ],
          "line": 1493
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fork",
          "args": [],
          "line": 1490
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getenv",
          "args": [
            "\"WAITBG\""
          ],
          "line": 1487
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"avahi.h\"\n#include \"sslhelper.h\"\n#include \"remote.h\"\n#include \"cursor.h\"\n#include \"keyboard.h\"\n#include \"inet.h\"\n#include \"connections.h\"\n#include \"xwrappers.h\"\n#include \"sslhelper.h\"\n#include \"unixpw.h\"\n#include \"screen.h\"\n#include \"scan.h\"\n#include \"cleanup.h\"\n#include \"solid.h\"\n#include \"x11vnc.h\"\n\nstatic void check_waitbg(void) {\n\tif (getenv(\"WAITBG\")) {\n#if LIBVNCSERVER_HAVE_FORK && HAVE_SETSID\n\t\tint p, n;\n\t\tif ((p = fork()) > 0)  {\n\t\t\texit(0);\n\t\t} else if (p == -1) {\n\t\t\trfbLogEnable(1);\n\t\t\tfprintf(stderr, \"could not fork\\n\");\n\t\t\tperror(\"fork\");\n\t\t\tclean_up_exit(1);\n\t\t}\n\t\tif (setsid() == -1) {\n\t\t\trfbLogEnable(1);\n\t\t\tfprintf(stderr, \"setsid failed\\n\");\n\t\t\tperror(\"setsid\");\n\t\t\tclean_up_exit(1);\n\t\t}\n\t\t/* adjust our stdio */\n\t\tn = open(\"/dev/null\", O_RDONLY);\n\t\tdup2(n, 0);\n\t\tdup2(n, 1);\n\t\tif (! logfile) {\n\t\t\tdup2(n, 2);\n\t\t}\n\t\tif (n > 2) {\n\t\t\tclose(n);\n\t\t}\n#else\n\t\tclean_up_exit(1);\n#endif\n\t}\n}"
  },
  {
    "function_name": "setup_service",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/user.c",
    "lines": "1455-1484",
    "snippet": "static void setup_service(void) {\n\tif (remote_direct) {\n\t\treturn;\n\t}\n\tif (!inetd) {\n\t\tdo_mention_java_urls();\n\t\tdo_announce_http();\n\t\tif (!use_openssl) {\n\t\t\tannounce(screen->port, use_openssl, NULL);\n\t\t\tfprintf(stdout, \"PORT=%d\\n\", screen->port);\n\t\t} else {\n\t\t\tfprintf(stdout, \"PORT=%d\\n\", screen->port);\n\t\t\tif (stunnel_port) {\n\t\t\t\tfprintf(stdout, \"SSLPORT=%d\\n\", stunnel_port);\n\t\t\t} else if (use_openssl) {\n\t\t\t\tfprintf(stdout, \"SSLPORT=%d\\n\", screen->port);\n\t\t\t}\n\t\t}\n\t\tfflush(stdout);\n\t} else if (!use_openssl && avahi) {\n\t\tchar *name = rfb_desktop_name;\n\t\tchar *host = this_host();\n\t\tif (!name) {\n\t\t\tname = use_dpy;\n\t\t}\n\t\tavahi_initialise();\n\t\tavahi_advertise(name, host, screen->port);\n\t\tfree(host);\n\t}\n}",
    "includes": [
      "#include \"avahi.h\"",
      "#include \"sslhelper.h\"",
      "#include \"remote.h\"",
      "#include \"cursor.h\"",
      "#include \"keyboard.h\"",
      "#include \"inet.h\"",
      "#include \"connections.h\"",
      "#include \"xwrappers.h\"",
      "#include \"sslhelper.h\"",
      "#include \"unixpw.h\"",
      "#include \"screen.h\"",
      "#include \"scan.h\"",
      "#include \"cleanup.h\"",
      "#include \"solid.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "void do_announce_http(void);",
      "void do_mention_java_urls(void);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "host"
          ],
          "line": 1482
        },
        "resolved": true,
        "details": {
          "function_name": "free_rect",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/userinput.c",
          "lines": "6200-6247",
          "snippet": "int free_rect(int idx) {\n\tint n, ok = 0;\n\tsraRegionPtr r1, r2;\n\tint x, y, w, h;\n\n\tif (idx < 0 || idx >= cache_list_num) {\nif (0) fprintf(stderr, \"free_rect: bad index: %d\\n\", idx);\n\t\tclean_up_exit(1);\n\t}\n\n\tx = cache_list[idx].bs_x;\n\ty = cache_list[idx].bs_y;\n\tw = cache_list[idx].bs_w;\n\th = cache_list[idx].bs_h;\n\n\tif (x < 0) {\n\t\tCLEAR(idx);\nif (dnow() > last_client + 5 && ncdb) fprintf(stderr, \"free_rect: already bs_x invalidated: %d bs_x: %d\\n\", idx, x);\n\t\treturn 1;\n\t}\n\n\tr2 = sraRgnCreateRect(x, y, x+w, y+h);\n\n\tn = get_bs_n(y);\n\tif (n >= 0) {\n\t\tr1 = rect_reg[n];\n\t\tsraRgnOr(r1, r2);\n\t\tok = 1;\n\t}\n\n\tif (zero_rects) {\n\t\tsraRgnOr(zero_rects, r2);\n\t\tx = cache_list[idx].su_x;\n\t\ty = cache_list[idx].su_y;\n\t\tw = cache_list[idx].su_w;\n\t\th = cache_list[idx].su_h;\n\t\tif (x >= 0) {\n\t\t\tsraRgnDestroy(r2);\n\t\t\tr2 = sraRgnCreateRect(x, y, x+w, y+h);\n\t\t\tsraRgnOr(zero_rects, r2);\n\t\t}\n\t}\n\tsraRgnDestroy(r2);\n\n\tCLEAR(idx);\nif (! ok && ncdb) fprintf(stderr, \"**** free_rect: not-found %d\\n\", idx);\n\treturn ok;\n}",
          "includes": [
            "#include \"default8x16.h\"",
            "#include \"connections.h\"",
            "#include \"screen.h\"",
            "#include \"cursor.h\"",
            "#include \"macosxCGS.h\"",
            "#include \"macosx.h\"",
            "#include \"unixpw.h\"",
            "#include \"8to24.h\"",
            "#include \"xrandr.h\"",
            "#include \"solid.h\"",
            "#include \"keyboard.h\"",
            "#include \"rates.h\"",
            "#include \"pointer.h\"",
            "#include \"cleanup.h\"",
            "#include \"scan.h\"",
            "#include \"user.h\"",
            "#include \"xevents.h\"",
            "#include \"win_utils.h\"",
            "#include \"xinerama.h\"",
            "#include \"xrecord.h\"",
            "#include \"xdamage.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void mark_for_xdamage(int x, int y, int w, int h);",
            "void set_xdamage_mark(int x, int y, int w, int h);",
            "int find_rect(int idx, int x, int y, int w, int h);",
            "winattr_t *cache_list;",
            "int clipped(int idx);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"default8x16.h\"\n#include \"connections.h\"\n#include \"screen.h\"\n#include \"cursor.h\"\n#include \"macosxCGS.h\"\n#include \"macosx.h\"\n#include \"unixpw.h\"\n#include \"8to24.h\"\n#include \"xrandr.h\"\n#include \"solid.h\"\n#include \"keyboard.h\"\n#include \"rates.h\"\n#include \"pointer.h\"\n#include \"cleanup.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"xevents.h\"\n#include \"win_utils.h\"\n#include \"xinerama.h\"\n#include \"xrecord.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nvoid mark_for_xdamage(int x, int y, int w, int h);\nvoid set_xdamage_mark(int x, int y, int w, int h);\nint find_rect(int idx, int x, int y, int w, int h);\nwinattr_t *cache_list;\nint clipped(int idx);\n\nint free_rect(int idx) {\n\tint n, ok = 0;\n\tsraRegionPtr r1, r2;\n\tint x, y, w, h;\n\n\tif (idx < 0 || idx >= cache_list_num) {\nif (0) fprintf(stderr, \"free_rect: bad index: %d\\n\", idx);\n\t\tclean_up_exit(1);\n\t}\n\n\tx = cache_list[idx].bs_x;\n\ty = cache_list[idx].bs_y;\n\tw = cache_list[idx].bs_w;\n\th = cache_list[idx].bs_h;\n\n\tif (x < 0) {\n\t\tCLEAR(idx);\nif (dnow() > last_client + 5 && ncdb) fprintf(stderr, \"free_rect: already bs_x invalidated: %d bs_x: %d\\n\", idx, x);\n\t\treturn 1;\n\t}\n\n\tr2 = sraRgnCreateRect(x, y, x+w, y+h);\n\n\tn = get_bs_n(y);\n\tif (n >= 0) {\n\t\tr1 = rect_reg[n];\n\t\tsraRgnOr(r1, r2);\n\t\tok = 1;\n\t}\n\n\tif (zero_rects) {\n\t\tsraRgnOr(zero_rects, r2);\n\t\tx = cache_list[idx].su_x;\n\t\ty = cache_list[idx].su_y;\n\t\tw = cache_list[idx].su_w;\n\t\th = cache_list[idx].su_h;\n\t\tif (x >= 0) {\n\t\t\tsraRgnDestroy(r2);\n\t\t\tr2 = sraRgnCreateRect(x, y, x+w, y+h);\n\t\t\tsraRgnOr(zero_rects, r2);\n\t\t}\n\t}\n\tsraRgnDestroy(r2);\n\n\tCLEAR(idx);\nif (! ok && ncdb) fprintf(stderr, \"**** free_rect: not-found %d\\n\", idx);\n\treturn ok;\n}"
        }
      },
      {
        "call_info": {
          "callee": "avahi_advertise",
          "args": [
            "name",
            "host",
            "screen->port"
          ],
          "line": 1481
        },
        "resolved": true,
        "details": {
          "function_name": "avahi_advertise",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/avahi.c",
          "lines": "331-377",
          "snippet": "void avahi_advertise(char *name, char *host, uint16_t port) {\n\tint i;\n\tchar *t;\n\tt = getenv(\"X11VNC_AVAHI_NAME\"); if (t) name = t;\n\tt = getenv(\"X11VNC_AVAHI_HOST\"); if (t) host = t;\n\tt = getenv(\"X11VNC_AVAHI_PORT\"); if (t) port = atoi(t);\n\nif (db) fprintf(stderr, \"in  avahi_advertise: '%s' '%s' %d\\n\", name, host, port);\n\tif (!_client) {\nif (db) fprintf(stderr, \"    avahi_advertise client null\\n\");\n\t\treturn;\n\t}\n\tif (_poll == NULL) {\n\t\trfbLog(\"Avahi poll not initialized.\\n\");\n\t\treturn;\n\t}\n\t/* well, we just track it ourselves... */\n\tfor (i=0; i<NREG; i++) {\n\t\tif (!registered[i].name) {\n\t\t\tcontinue;\n\t\t}\n\t\tif (strcmp(registered[i].name, name)) {\n\t\t\tcontinue;\n\t\t}\n\t\tif (strcmp(registered[i].host, host)) {\n\t\t\tcontinue;\n\t\t}\n\t\tif (registered[i].port != port) {\n\t\t\tcontinue;\n\t\t}\nif (db) fprintf(stderr, \"    avahi_advertise already did this one\\n\");\n\t\treturn;\n\t}\n\tfor (i=0; i<NREG; i++) {\n\t\tif (!registered[i].name) {\n\t\t\tregistered[i].name = strdup(name);\n\t\t\tregistered[i].host = strdup(host);\n\t\t\tregistered[i].port = port;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tavahi_threaded_poll_lock(_poll);\n\t_avahi_create_services(name, host, port >= 5900 ? port : 5900+port);\n\tavahi_threaded_poll_unlock(_poll);\nif (db) fprintf(stderr, \"out avahi_advertise\\n\");\n}",
          "includes": [
            "#include <avahi-common/error.h>",
            "#include <avahi-common/malloc.h>",
            "#include <avahi-client/publish.h>",
            "#include <avahi-client/client.h>",
            "#include <avahi-common/alternative.h>",
            "#include <avahi-common/thread-watch.h>",
            "#include \"cleanup.h\"",
            "#include \"connections.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [
            "#define NREG 16"
          ],
          "globals_used": [
            "void avahi_advertise(char *name, char *host, uint16_t port);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <avahi-common/error.h>\n#include <avahi-common/malloc.h>\n#include <avahi-client/publish.h>\n#include <avahi-client/client.h>\n#include <avahi-common/alternative.h>\n#include <avahi-common/thread-watch.h>\n#include \"cleanup.h\"\n#include \"connections.h\"\n#include \"x11vnc.h\"\n\n#define NREG 16\n\nvoid avahi_advertise(char *name, char *host, uint16_t port);\n\nvoid avahi_advertise(char *name, char *host, uint16_t port) {\n\tint i;\n\tchar *t;\n\tt = getenv(\"X11VNC_AVAHI_NAME\"); if (t) name = t;\n\tt = getenv(\"X11VNC_AVAHI_HOST\"); if (t) host = t;\n\tt = getenv(\"X11VNC_AVAHI_PORT\"); if (t) port = atoi(t);\n\nif (db) fprintf(stderr, \"in  avahi_advertise: '%s' '%s' %d\\n\", name, host, port);\n\tif (!_client) {\nif (db) fprintf(stderr, \"    avahi_advertise client null\\n\");\n\t\treturn;\n\t}\n\tif (_poll == NULL) {\n\t\trfbLog(\"Avahi poll not initialized.\\n\");\n\t\treturn;\n\t}\n\t/* well, we just track it ourselves... */\n\tfor (i=0; i<NREG; i++) {\n\t\tif (!registered[i].name) {\n\t\t\tcontinue;\n\t\t}\n\t\tif (strcmp(registered[i].name, name)) {\n\t\t\tcontinue;\n\t\t}\n\t\tif (strcmp(registered[i].host, host)) {\n\t\t\tcontinue;\n\t\t}\n\t\tif (registered[i].port != port) {\n\t\t\tcontinue;\n\t\t}\nif (db) fprintf(stderr, \"    avahi_advertise already did this one\\n\");\n\t\treturn;\n\t}\n\tfor (i=0; i<NREG; i++) {\n\t\tif (!registered[i].name) {\n\t\t\tregistered[i].name = strdup(name);\n\t\t\tregistered[i].host = strdup(host);\n\t\t\tregistered[i].port = port;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tavahi_threaded_poll_lock(_poll);\n\t_avahi_create_services(name, host, port >= 5900 ? port : 5900+port);\n\tavahi_threaded_poll_unlock(_poll);\nif (db) fprintf(stderr, \"out avahi_advertise\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "avahi_initialise",
          "args": [],
          "line": 1480
        },
        "resolved": true,
        "details": {
          "function_name": "avahi_initialise",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/avahi.c",
          "lines": "203-250",
          "snippet": "void avahi_initialise(void) {\n\tint ret;\n\tstatic int first = 1;\n\n\tif (getenv(\"AVAHI_DEBUG\")) {\n\t\tdb = 1;\n\t}\n\tif (first) {\n\t\tint i;\n\t\tfor (i=0; i<NREG; i++) {\n\t\t\tregistered[i].name = NULL;\n\t\t\tregistered[i].host = NULL;\n\t\t}\n\t\tfirst = 0;\n\t}\n\nif (db) fprintf(stderr, \"in  avahi_initialise\\n\");\n\tif (_poll) {\nif (db) fprintf(stderr, \"    avahi_initialise: poll not null\\n\");\n\t\treturn;\n\t}\n\n\tif (! (_poll = avahi_threaded_poll_new()) ) {\n\t\trfbLog(\"warning: unable to open Avahi poll.\\n\");\n\t\treturn;\n\t}\n\n\t_client = avahi_client_new(avahi_threaded_poll_get(_poll),\n\t    0, NULL, NULL, &ret);\n\tif (! _client) {\n\t\trfbLog(\"warning: unable to open Avahi client: %s\\n\",\n\t\t    avahi_strerror(ret));\n\n\t\tavahi_threaded_poll_free(_poll);\n\t\t_poll = NULL;\n\t\treturn;\n\t}\n\n\tif (avahi_threaded_poll_start(_poll) < 0) {\n\t\trfbLog(\"warning: unable to start Avahi poll.\\n\");\n\t\tavahi_client_free(_client);\n\t\t_client = NULL;\n\t\tavahi_threaded_poll_free(_poll);\n\t\t_poll = NULL;\n\t\treturn;\n\t}\nif (db) fprintf(stderr, \"out avahi_initialise\\n\");\n}",
          "includes": [
            "#include <avahi-common/error.h>",
            "#include <avahi-common/malloc.h>",
            "#include <avahi-client/publish.h>",
            "#include <avahi-client/client.h>",
            "#include <avahi-common/alternative.h>",
            "#include <avahi-common/thread-watch.h>",
            "#include \"cleanup.h\"",
            "#include \"connections.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [
            "#define NREG 16"
          ],
          "globals_used": [
            "void avahi_initialise(void);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <avahi-common/error.h>\n#include <avahi-common/malloc.h>\n#include <avahi-client/publish.h>\n#include <avahi-client/client.h>\n#include <avahi-common/alternative.h>\n#include <avahi-common/thread-watch.h>\n#include \"cleanup.h\"\n#include \"connections.h\"\n#include \"x11vnc.h\"\n\n#define NREG 16\n\nvoid avahi_initialise(void);\n\nvoid avahi_initialise(void) {\n\tint ret;\n\tstatic int first = 1;\n\n\tif (getenv(\"AVAHI_DEBUG\")) {\n\t\tdb = 1;\n\t}\n\tif (first) {\n\t\tint i;\n\t\tfor (i=0; i<NREG; i++) {\n\t\t\tregistered[i].name = NULL;\n\t\t\tregistered[i].host = NULL;\n\t\t}\n\t\tfirst = 0;\n\t}\n\nif (db) fprintf(stderr, \"in  avahi_initialise\\n\");\n\tif (_poll) {\nif (db) fprintf(stderr, \"    avahi_initialise: poll not null\\n\");\n\t\treturn;\n\t}\n\n\tif (! (_poll = avahi_threaded_poll_new()) ) {\n\t\trfbLog(\"warning: unable to open Avahi poll.\\n\");\n\t\treturn;\n\t}\n\n\t_client = avahi_client_new(avahi_threaded_poll_get(_poll),\n\t    0, NULL, NULL, &ret);\n\tif (! _client) {\n\t\trfbLog(\"warning: unable to open Avahi client: %s\\n\",\n\t\t    avahi_strerror(ret));\n\n\t\tavahi_threaded_poll_free(_poll);\n\t\t_poll = NULL;\n\t\treturn;\n\t}\n\n\tif (avahi_threaded_poll_start(_poll) < 0) {\n\t\trfbLog(\"warning: unable to start Avahi poll.\\n\");\n\t\tavahi_client_free(_client);\n\t\t_client = NULL;\n\t\tavahi_threaded_poll_free(_poll);\n\t\t_poll = NULL;\n\t\treturn;\n\t}\nif (db) fprintf(stderr, \"out avahi_initialise\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "this_host",
          "args": [],
          "line": 1476
        },
        "resolved": true,
        "details": {
          "function_name": "this_host",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/util.c",
          "lines": "340-351",
          "snippet": "char *this_host(void) {\n\tchar host[MAXN];\n#if LIBVNCSERVER_HAVE_GETHOSTNAME\n\tif (gethostname(host, MAXN) == 0) {\n\t\thost[MAXN-1] = '\\0';\n\t\treturn strdup(host);\n\t} else if (UT.nodename) {\n\t\treturn strdup(UT.nodename);\n\t}\n#endif\n\treturn NULL;\n}",
          "includes": [
            "#include \"connections.h\"",
            "#include \"unixpw.h\"",
            "#include \"win_utils.h\"",
            "#include \"cleanup.h\"",
            "#include \"x11vnc.h\"",
            "#include <stdlib.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "char *this_host(void);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"connections.h\"\n#include \"unixpw.h\"\n#include \"win_utils.h\"\n#include \"cleanup.h\"\n#include \"x11vnc.h\"\n#include <stdlib.h>\n\nchar *this_host(void);\n\nchar *this_host(void) {\n\tchar host[MAXN];\n#if LIBVNCSERVER_HAVE_GETHOSTNAME\n\tif (gethostname(host, MAXN) == 0) {\n\t\thost[MAXN-1] = '\\0';\n\t\treturn strdup(host);\n\t} else if (UT.nodename) {\n\t\treturn strdup(UT.nodename);\n\t}\n#endif\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fflush",
          "args": [
            "stdout"
          ],
          "line": 1473
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stdout",
            "\"SSLPORT=%d\\n\"",
            "screen->port"
          ],
          "line": 1470
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stdout",
            "\"SSLPORT=%d\\n\"",
            "stunnel_port"
          ],
          "line": 1468
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stdout",
            "\"PORT=%d\\n\"",
            "screen->port"
          ],
          "line": 1466
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stdout",
            "\"PORT=%d\\n\"",
            "screen->port"
          ],
          "line": 1464
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "announce",
          "args": [
            "screen->port",
            "use_openssl",
            "NULL"
          ],
          "line": 1463
        },
        "resolved": true,
        "details": {
          "function_name": "announce",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/screen.c",
          "lines": "3797-3863",
          "snippet": "void announce(int lport, int ssl, char *iface) {\n\t\n\tchar *host = this_host();\n\tchar *tvdt;\n\n\tif (remote_direct) {\n\t\treturn;\n\t}\n\n\tif (! ssl) {\n\t\ttvdt = \"The VNC desktop is:     \";\n\t} else {\n\t\tif (enc_str && !strcmp(enc_str, \"none\")) {\n\t\t\ttvdt = \"The VNC desktop is:     \";\n\t\t} else if (enc_str) {\n\t\t\ttvdt = \"The ENC VNC desktop is: \";\n\t\t} else {\n\t\t\ttvdt = \"The SSL VNC desktop is: \";\n\t\t}\n\t}\n\n\tif (iface != NULL && *iface != '\\0' && strcmp(iface, \"any\")) {\n\t\tfree(host);\n\t\thost = iface;\n\t}\n\tif (host != NULL) {\n\t\t/* note that vncviewer special cases 5900-5999 */\n\t\tint sz = 256;\n\t\tif (inetd) {\n\t\t\t;\t/* should not occur (port) */\n\t\t} else if (quiet) {\n\t\t\tif (lport >= 5900) {\n\t\t\t\tsnprintf(vnc_desktop_name, sz, \"%s:%d\",\n\t\t\t\t    host, lport - 5900);\n\t\t\t\tDO_AVAHI\n\t\t\t\tfprintf(stderr, \"\\n%s %s\\n\", tvdt,\n\t\t\t\t    vnc_desktop_name);\n\t\t\t} else {\n\t\t\t\tsnprintf(vnc_desktop_name, sz, \"%s:%d\",\n\t\t\t\t    host, lport);\n\t\t\t\tDO_AVAHI\n\t\t\t\tfprintf(stderr, \"\\n%s %s\\n\", tvdt,\n\t\t\t\t    vnc_desktop_name);\n\t\t\t}\n\t\t} else if (lport >= 5900) {\n\t\t\tsnprintf(vnc_desktop_name, sz, \"%s:%d\",\n\t\t\t    host, lport - 5900);\n\t\t\tDO_AVAHI\n\t\t\tfprintf(stderr, \"\\n%s %s\\n\", tvdt, vnc_desktop_name);\n\t\t\tif (lport >= 6000) {\n\t\t\t\trfbLog(\"possible aliases:  %s:%d, \"\n\t\t\t\t    \"%s::%d\\n\", host, lport,\n\t\t\t\t    host, lport);\n\t\t\t}\n\t\t} else {\n\t\t\tsnprintf(vnc_desktop_name, sz, \"%s:%d\",\n\t\t\t    host, lport);\n\t\t\tDO_AVAHI\n\t\t\tfprintf(stderr, \"\\n%s %s\\n\", tvdt, vnc_desktop_name);\n\t\t\trfbLog(\"possible alias:    %s::%d\\n\",\n\t\t\t    host, lport);\n\t\t}\n\n\t\tif (host != iface)\n\t\t\tfree(host);\n\t}\n}",
          "includes": [
            "#include <rfb/rfbclient.h>",
            "#include \"xi2_devices.h\"",
            "#include \"pm.h\"",
            "#include \"xrecord.h\"",
            "#include \"xrandr.h\"",
            "#include \"inet.h\"",
            "#include \"solid.h\"",
            "#include \"avahi.h\"",
            "#include \"macosxCG.h\"",
            "#include \"macosx.h\"",
            "#include \"linuxfb.h\"",
            "#include \"v4l.h\"",
            "#include \"sslhelper.h\"",
            "#include \"sslcmds.h\"",
            "#include \"unixpw.h\"",
            "#include \"remote.h\"",
            "#include \"connections.h\"",
            "#include \"cursor.h\"",
            "#include \"keyboard.h\"",
            "#include \"pointer.h\"",
            "#include \"rates.h\"",
            "#include \"user.h\"",
            "#include \"scan.h\"",
            "#include \"userinput.h\"",
            "#include \"cleanup.h\"",
            "#include \"win_utils.h\"",
            "#include \"xdamage.h\"",
            "#include \"xinerama.h\"",
            "#include \"xwrappers.h\"",
            "#include \"xevents.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [
            "#define DO_AVAHI \\\n\tif (avahi) { \\\n\t\tavahi_initialise(); \\\n\t\tavahi_advertise(vnc_desktop_name, host, lport); \\\n\t\tusleep(1000*1000); \\\n\t}"
          ],
          "globals_used": [
            "void announce(int lport, int ssl, char *iface);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <rfb/rfbclient.h>\n#include \"xi2_devices.h\"\n#include \"pm.h\"\n#include \"xrecord.h\"\n#include \"xrandr.h\"\n#include \"inet.h\"\n#include \"solid.h\"\n#include \"avahi.h\"\n#include \"macosxCG.h\"\n#include \"macosx.h\"\n#include \"linuxfb.h\"\n#include \"v4l.h\"\n#include \"sslhelper.h\"\n#include \"sslcmds.h\"\n#include \"unixpw.h\"\n#include \"remote.h\"\n#include \"connections.h\"\n#include \"cursor.h\"\n#include \"keyboard.h\"\n#include \"pointer.h\"\n#include \"rates.h\"\n#include \"user.h\"\n#include \"scan.h\"\n#include \"userinput.h\"\n#include \"cleanup.h\"\n#include \"win_utils.h\"\n#include \"xdamage.h\"\n#include \"xinerama.h\"\n#include \"xwrappers.h\"\n#include \"xevents.h\"\n#include \"x11vnc.h\"\n\n#define DO_AVAHI \\\n\tif (avahi) { \\\n\t\tavahi_initialise(); \\\n\t\tavahi_advertise(vnc_desktop_name, host, lport); \\\n\t\tusleep(1000*1000); \\\n\t}\n\nvoid announce(int lport, int ssl, char *iface);\n\nvoid announce(int lport, int ssl, char *iface) {\n\t\n\tchar *host = this_host();\n\tchar *tvdt;\n\n\tif (remote_direct) {\n\t\treturn;\n\t}\n\n\tif (! ssl) {\n\t\ttvdt = \"The VNC desktop is:     \";\n\t} else {\n\t\tif (enc_str && !strcmp(enc_str, \"none\")) {\n\t\t\ttvdt = \"The VNC desktop is:     \";\n\t\t} else if (enc_str) {\n\t\t\ttvdt = \"The ENC VNC desktop is: \";\n\t\t} else {\n\t\t\ttvdt = \"The SSL VNC desktop is: \";\n\t\t}\n\t}\n\n\tif (iface != NULL && *iface != '\\0' && strcmp(iface, \"any\")) {\n\t\tfree(host);\n\t\thost = iface;\n\t}\n\tif (host != NULL) {\n\t\t/* note that vncviewer special cases 5900-5999 */\n\t\tint sz = 256;\n\t\tif (inetd) {\n\t\t\t;\t/* should not occur (port) */\n\t\t} else if (quiet) {\n\t\t\tif (lport >= 5900) {\n\t\t\t\tsnprintf(vnc_desktop_name, sz, \"%s:%d\",\n\t\t\t\t    host, lport - 5900);\n\t\t\t\tDO_AVAHI\n\t\t\t\tfprintf(stderr, \"\\n%s %s\\n\", tvdt,\n\t\t\t\t    vnc_desktop_name);\n\t\t\t} else {\n\t\t\t\tsnprintf(vnc_desktop_name, sz, \"%s:%d\",\n\t\t\t\t    host, lport);\n\t\t\t\tDO_AVAHI\n\t\t\t\tfprintf(stderr, \"\\n%s %s\\n\", tvdt,\n\t\t\t\t    vnc_desktop_name);\n\t\t\t}\n\t\t} else if (lport >= 5900) {\n\t\t\tsnprintf(vnc_desktop_name, sz, \"%s:%d\",\n\t\t\t    host, lport - 5900);\n\t\t\tDO_AVAHI\n\t\t\tfprintf(stderr, \"\\n%s %s\\n\", tvdt, vnc_desktop_name);\n\t\t\tif (lport >= 6000) {\n\t\t\t\trfbLog(\"possible aliases:  %s:%d, \"\n\t\t\t\t    \"%s::%d\\n\", host, lport,\n\t\t\t\t    host, lport);\n\t\t\t}\n\t\t} else {\n\t\t\tsnprintf(vnc_desktop_name, sz, \"%s:%d\",\n\t\t\t    host, lport);\n\t\t\tDO_AVAHI\n\t\t\tfprintf(stderr, \"\\n%s %s\\n\", tvdt, vnc_desktop_name);\n\t\t\trfbLog(\"possible alias:    %s::%d\\n\",\n\t\t\t    host, lport);\n\t\t}\n\n\t\tif (host != iface)\n\t\t\tfree(host);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "do_announce_http",
          "args": [],
          "line": 1461
        },
        "resolved": true,
        "details": {
          "function_name": "do_announce_http",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/screen.c",
          "lines": "3899-3939",
          "snippet": "void do_announce_http(void) {\n\tif (!screen) {\n\t\treturn;\n\t}\n\tif (remote_direct) {\n\t\treturn;\n\t}\n\n\t/* XXX ipv6? */\n\tif ((screen->httpListenSock > -1 || ipv6_http_fd > -1) && screen->httpPort) {\n\t\tint enc_none = (enc_str && !strcmp(enc_str, \"none\"));\n\t\tchar *SPORT = \"   (single port)\";\n\t\tif (use_openssl && ! enc_none) {\n\t\t\tannounce_http(screen->port, 1, listen_str, SPORT);\n\t\t\tif (https_port_num >= 0) {\n\t\t\t\tannounce_http(https_port_num, 1,\n\t\t\t\t    listen_str, \"\");\n\t\t\t}\n\t\t\tannounce_http(screen->httpPort, 2, listen_str, \"\");\n\t\t} else if (use_stunnel) {\n\t\t\tchar pmsg[100];\n\t\t\tpmsg[0] = '\\0';\n\t\t\tif (stunnel_port) {\n\t\t\t\tsprintf(pmsg, \"?PORT=%d\", stunnel_port);\n\t\t\t}\n\t\t\tannounce_http(screen->httpPort, 2, listen_str, pmsg);\n\t\t\tif (stunnel_http_port > 0) {\n\t\t\t\tannounce_http(stunnel_http_port, 1, NULL, pmsg);\n\t\t\t}\n\t\t\tif (enc_none) {\n\t\t\t\tstrcat(pmsg, SPORT);\n\t\t\t\tannounce_http(stunnel_port, 1, NULL, pmsg);\n\t\t\t}\n\t\t} else {\n\t\t\tannounce_http(screen->httpPort, 0, listen_str, \"\");\n\t\t\tif (enc_none) {\n\t\t\t\tannounce_http(screen->port, 1, NULL, SPORT);\n\t\t\t}\n\t\t}\n\t}\n}",
          "includes": [
            "#include <rfb/rfbclient.h>",
            "#include \"xi2_devices.h\"",
            "#include \"pm.h\"",
            "#include \"xrecord.h\"",
            "#include \"xrandr.h\"",
            "#include \"inet.h\"",
            "#include \"solid.h\"",
            "#include \"avahi.h\"",
            "#include \"macosxCG.h\"",
            "#include \"macosx.h\"",
            "#include \"linuxfb.h\"",
            "#include \"v4l.h\"",
            "#include \"sslhelper.h\"",
            "#include \"sslcmds.h\"",
            "#include \"unixpw.h\"",
            "#include \"remote.h\"",
            "#include \"connections.h\"",
            "#include \"cursor.h\"",
            "#include \"keyboard.h\"",
            "#include \"pointer.h\"",
            "#include \"rates.h\"",
            "#include \"user.h\"",
            "#include \"scan.h\"",
            "#include \"userinput.h\"",
            "#include \"cleanup.h\"",
            "#include \"win_utils.h\"",
            "#include \"xdamage.h\"",
            "#include \"xinerama.h\"",
            "#include \"xwrappers.h\"",
            "#include \"xevents.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <rfb/rfbclient.h>\n#include \"xi2_devices.h\"\n#include \"pm.h\"\n#include \"xrecord.h\"\n#include \"xrandr.h\"\n#include \"inet.h\"\n#include \"solid.h\"\n#include \"avahi.h\"\n#include \"macosxCG.h\"\n#include \"macosx.h\"\n#include \"linuxfb.h\"\n#include \"v4l.h\"\n#include \"sslhelper.h\"\n#include \"sslcmds.h\"\n#include \"unixpw.h\"\n#include \"remote.h\"\n#include \"connections.h\"\n#include \"cursor.h\"\n#include \"keyboard.h\"\n#include \"pointer.h\"\n#include \"rates.h\"\n#include \"user.h\"\n#include \"scan.h\"\n#include \"userinput.h\"\n#include \"cleanup.h\"\n#include \"win_utils.h\"\n#include \"xdamage.h\"\n#include \"xinerama.h\"\n#include \"xwrappers.h\"\n#include \"xevents.h\"\n#include \"x11vnc.h\"\n\nvoid do_announce_http(void) {\n\tif (!screen) {\n\t\treturn;\n\t}\n\tif (remote_direct) {\n\t\treturn;\n\t}\n\n\t/* XXX ipv6? */\n\tif ((screen->httpListenSock > -1 || ipv6_http_fd > -1) && screen->httpPort) {\n\t\tint enc_none = (enc_str && !strcmp(enc_str, \"none\"));\n\t\tchar *SPORT = \"   (single port)\";\n\t\tif (use_openssl && ! enc_none) {\n\t\t\tannounce_http(screen->port, 1, listen_str, SPORT);\n\t\t\tif (https_port_num >= 0) {\n\t\t\t\tannounce_http(https_port_num, 1,\n\t\t\t\t    listen_str, \"\");\n\t\t\t}\n\t\t\tannounce_http(screen->httpPort, 2, listen_str, \"\");\n\t\t} else if (use_stunnel) {\n\t\t\tchar pmsg[100];\n\t\t\tpmsg[0] = '\\0';\n\t\t\tif (stunnel_port) {\n\t\t\t\tsprintf(pmsg, \"?PORT=%d\", stunnel_port);\n\t\t\t}\n\t\t\tannounce_http(screen->httpPort, 2, listen_str, pmsg);\n\t\t\tif (stunnel_http_port > 0) {\n\t\t\t\tannounce_http(stunnel_http_port, 1, NULL, pmsg);\n\t\t\t}\n\t\t\tif (enc_none) {\n\t\t\t\tstrcat(pmsg, SPORT);\n\t\t\t\tannounce_http(stunnel_port, 1, NULL, pmsg);\n\t\t\t}\n\t\t} else {\n\t\t\tannounce_http(screen->httpPort, 0, listen_str, \"\");\n\t\t\tif (enc_none) {\n\t\t\t\tannounce_http(screen->port, 1, NULL, SPORT);\n\t\t\t}\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "do_mention_java_urls",
          "args": [],
          "line": 1460
        },
        "resolved": true,
        "details": {
          "function_name": "do_mention_java_urls",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/screen.c",
          "lines": "3941-3968",
          "snippet": "void do_mention_java_urls(void) {\n\tif (! quiet && screen) {\n\t\t/* XXX ipv6? */\n\t\tif (screen->httpListenSock > -1 && screen->httpPort) {\n\t\t\trfbLog(\"\\n\");\n\t\t\trfbLog(\"The URLs printed out below ('Java ... viewer URL') can\\n\");\n\t\t\trfbLog(\"be used for Java enabled Web browser connections.\\n\");\n\t\t\tif (!stunnel_port && enc_str && !strcmp(enc_str, \"none\")) {\n\t\t\t\t;\n\t\t\t} else if (use_openssl || stunnel_port) {\n\t\t\t\trfbLog(\"Here are some additional possibilities:\\n\");\n\t\t\t\trfbLog(\"\\n\");\n\t\t\t\trfbLog(\"https://host:port/proxy.vnc (MUST be used if Web Proxy used)\\n\");\n\t\t\t\trfbLog(\"\\n\");\n\t\t\t\trfbLog(\"https://host:port/ultra.vnc (Use UltraVNC Java Viewer)\\n\");\n\t\t\t\trfbLog(\"https://host:port/ultraproxy.vnc (Web Proxy with UltraVNC)\\n\");\n\t\t\t\trfbLog(\"https://host:port/ultrasigned.vnc (Signed UltraVNC Filexfer)\\n\");\n\t\t\t\trfbLog(\"\\n\");\n\t\t\t\trfbLog(\"Where you replace \\\"host:port\\\" with that printed below, or\\n\");\n\t\t\t\trfbLog(\"whatever is needed to reach the host e.g. Internet IP number\\n\");\n\t\t\t\trfbLog(\"\\n\");\n\t\t\t\trfbLog(\"Append ?GET=1 to a URL for faster loading or supply:\\n\");\n\t\t\t\trfbLog(\"-env X11VNC_EXTRA_HTTPS_PARAMS='?GET=1' to cmdline.\\n\");\n\t\t\t}\n\t\t}\n\t\trfbLog(\"\\n\");\n\t}\n}",
          "includes": [
            "#include <rfb/rfbclient.h>",
            "#include \"xi2_devices.h\"",
            "#include \"pm.h\"",
            "#include \"xrecord.h\"",
            "#include \"xrandr.h\"",
            "#include \"inet.h\"",
            "#include \"solid.h\"",
            "#include \"avahi.h\"",
            "#include \"macosxCG.h\"",
            "#include \"macosx.h\"",
            "#include \"linuxfb.h\"",
            "#include \"v4l.h\"",
            "#include \"sslhelper.h\"",
            "#include \"sslcmds.h\"",
            "#include \"unixpw.h\"",
            "#include \"remote.h\"",
            "#include \"connections.h\"",
            "#include \"cursor.h\"",
            "#include \"keyboard.h\"",
            "#include \"pointer.h\"",
            "#include \"rates.h\"",
            "#include \"user.h\"",
            "#include \"scan.h\"",
            "#include \"userinput.h\"",
            "#include \"cleanup.h\"",
            "#include \"win_utils.h\"",
            "#include \"xdamage.h\"",
            "#include \"xinerama.h\"",
            "#include \"xwrappers.h\"",
            "#include \"xevents.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <rfb/rfbclient.h>\n#include \"xi2_devices.h\"\n#include \"pm.h\"\n#include \"xrecord.h\"\n#include \"xrandr.h\"\n#include \"inet.h\"\n#include \"solid.h\"\n#include \"avahi.h\"\n#include \"macosxCG.h\"\n#include \"macosx.h\"\n#include \"linuxfb.h\"\n#include \"v4l.h\"\n#include \"sslhelper.h\"\n#include \"sslcmds.h\"\n#include \"unixpw.h\"\n#include \"remote.h\"\n#include \"connections.h\"\n#include \"cursor.h\"\n#include \"keyboard.h\"\n#include \"pointer.h\"\n#include \"rates.h\"\n#include \"user.h\"\n#include \"scan.h\"\n#include \"userinput.h\"\n#include \"cleanup.h\"\n#include \"win_utils.h\"\n#include \"xdamage.h\"\n#include \"xinerama.h\"\n#include \"xwrappers.h\"\n#include \"xevents.h\"\n#include \"x11vnc.h\"\n\nvoid do_mention_java_urls(void) {\n\tif (! quiet && screen) {\n\t\t/* XXX ipv6? */\n\t\tif (screen->httpListenSock > -1 && screen->httpPort) {\n\t\t\trfbLog(\"\\n\");\n\t\t\trfbLog(\"The URLs printed out below ('Java ... viewer URL') can\\n\");\n\t\t\trfbLog(\"be used for Java enabled Web browser connections.\\n\");\n\t\t\tif (!stunnel_port && enc_str && !strcmp(enc_str, \"none\")) {\n\t\t\t\t;\n\t\t\t} else if (use_openssl || stunnel_port) {\n\t\t\t\trfbLog(\"Here are some additional possibilities:\\n\");\n\t\t\t\trfbLog(\"\\n\");\n\t\t\t\trfbLog(\"https://host:port/proxy.vnc (MUST be used if Web Proxy used)\\n\");\n\t\t\t\trfbLog(\"\\n\");\n\t\t\t\trfbLog(\"https://host:port/ultra.vnc (Use UltraVNC Java Viewer)\\n\");\n\t\t\t\trfbLog(\"https://host:port/ultraproxy.vnc (Web Proxy with UltraVNC)\\n\");\n\t\t\t\trfbLog(\"https://host:port/ultrasigned.vnc (Signed UltraVNC Filexfer)\\n\");\n\t\t\t\trfbLog(\"\\n\");\n\t\t\t\trfbLog(\"Where you replace \\\"host:port\\\" with that printed below, or\\n\");\n\t\t\t\trfbLog(\"whatever is needed to reach the host e.g. Internet IP number\\n\");\n\t\t\t\trfbLog(\"\\n\");\n\t\t\t\trfbLog(\"Append ?GET=1 to a URL for faster loading or supply:\\n\");\n\t\t\t\trfbLog(\"-env X11VNC_EXTRA_HTTPS_PARAMS='?GET=1' to cmdline.\\n\");\n\t\t\t}\n\t\t}\n\t\trfbLog(\"\\n\");\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"avahi.h\"\n#include \"sslhelper.h\"\n#include \"remote.h\"\n#include \"cursor.h\"\n#include \"keyboard.h\"\n#include \"inet.h\"\n#include \"connections.h\"\n#include \"xwrappers.h\"\n#include \"sslhelper.h\"\n#include \"unixpw.h\"\n#include \"screen.h\"\n#include \"scan.h\"\n#include \"cleanup.h\"\n#include \"solid.h\"\n#include \"x11vnc.h\"\n\nvoid do_announce_http(void);\nvoid do_mention_java_urls(void);\n\nstatic void setup_service(void) {\n\tif (remote_direct) {\n\t\treturn;\n\t}\n\tif (!inetd) {\n\t\tdo_mention_java_urls();\n\t\tdo_announce_http();\n\t\tif (!use_openssl) {\n\t\t\tannounce(screen->port, use_openssl, NULL);\n\t\t\tfprintf(stdout, \"PORT=%d\\n\", screen->port);\n\t\t} else {\n\t\t\tfprintf(stdout, \"PORT=%d\\n\", screen->port);\n\t\t\tif (stunnel_port) {\n\t\t\t\tfprintf(stdout, \"SSLPORT=%d\\n\", stunnel_port);\n\t\t\t} else if (use_openssl) {\n\t\t\t\tfprintf(stdout, \"SSLPORT=%d\\n\", screen->port);\n\t\t\t}\n\t\t}\n\t\tfflush(stdout);\n\t} else if (!use_openssl && avahi) {\n\t\tchar *name = rfb_desktop_name;\n\t\tchar *host = this_host();\n\t\tif (!name) {\n\t\t\tname = use_dpy;\n\t\t}\n\t\tavahi_initialise();\n\t\tavahi_advertise(name, host, screen->port);\n\t\tfree(host);\n\t}\n}"
  },
  {
    "function_name": "setup_fake_fb",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/user.c",
    "lines": "1409-1450",
    "snippet": "static void setup_fake_fb(XImage* fb_image, int w, int h, int b) {\n\tif (fake_fb) {\n\t\tfree(fake_fb);\n\t}\n\tfake_fb = (char *) calloc(w*h*b/8, 1);\n\n\tfb_image->data = fake_fb;\n\tfb_image->format = ZPixmap;\n\tfb_image->width  = w;\n\tfb_image->height = h;\n\tfb_image->bits_per_pixel = b;\n\tfb_image->bytes_per_line = w*b/8;\n\tfb_image->bitmap_unit = -1;\n\tif (b >= 24) {\n\t\tfb_image->depth = 24;\n\t\tfb_image->red_mask   = 0xff0000;\n\t\tfb_image->green_mask = 0x00ff00;\n\t\tfb_image->blue_mask  = 0x0000ff;\n\t} else if (b >= 16) {\n\t\tfb_image->depth = 16;\n\t\tfb_image->red_mask   = 0x003f;\n\t\tfb_image->green_mask = 0x07c0;\n\t\tfb_image->blue_mask  = 0xf800;\n\t} else if (b >= 2) {\n\t\tfb_image->depth = 8;\n\t\tfb_image->red_mask   = 0x07;\n\t\tfb_image->green_mask = 0x38;\n\t\tfb_image->blue_mask  = 0xc0;\n\t} else {\n\t\tfb_image->depth = 1;\n\t\tfb_image->red_mask   = 0x1;\n\t\tfb_image->green_mask = 0x1;\n\t\tfb_image->blue_mask  = 0x1;\n\t}\n\n\tdepth = fb_image->depth;\n\n\tdpy_x = wdpy_x = w;\n\tdpy_y = wdpy_y = h;\n\toff_x = 0;\n\toff_y = 0;\n}",
    "includes": [
      "#include \"avahi.h\"",
      "#include \"sslhelper.h\"",
      "#include \"remote.h\"",
      "#include \"cursor.h\"",
      "#include \"keyboard.h\"",
      "#include \"inet.h\"",
      "#include \"connections.h\"",
      "#include \"xwrappers.h\"",
      "#include \"sslhelper.h\"",
      "#include \"unixpw.h\"",
      "#include \"screen.h\"",
      "#include \"scan.h\"",
      "#include \"cleanup.h\"",
      "#include \"solid.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "calloc",
          "args": [
            "w*h*b/8",
            "1"
          ],
          "line": 1413
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "fake_fb"
          ],
          "line": 1411
        },
        "resolved": true,
        "details": {
          "function_name": "free_rect",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/userinput.c",
          "lines": "6200-6247",
          "snippet": "int free_rect(int idx) {\n\tint n, ok = 0;\n\tsraRegionPtr r1, r2;\n\tint x, y, w, h;\n\n\tif (idx < 0 || idx >= cache_list_num) {\nif (0) fprintf(stderr, \"free_rect: bad index: %d\\n\", idx);\n\t\tclean_up_exit(1);\n\t}\n\n\tx = cache_list[idx].bs_x;\n\ty = cache_list[idx].bs_y;\n\tw = cache_list[idx].bs_w;\n\th = cache_list[idx].bs_h;\n\n\tif (x < 0) {\n\t\tCLEAR(idx);\nif (dnow() > last_client + 5 && ncdb) fprintf(stderr, \"free_rect: already bs_x invalidated: %d bs_x: %d\\n\", idx, x);\n\t\treturn 1;\n\t}\n\n\tr2 = sraRgnCreateRect(x, y, x+w, y+h);\n\n\tn = get_bs_n(y);\n\tif (n >= 0) {\n\t\tr1 = rect_reg[n];\n\t\tsraRgnOr(r1, r2);\n\t\tok = 1;\n\t}\n\n\tif (zero_rects) {\n\t\tsraRgnOr(zero_rects, r2);\n\t\tx = cache_list[idx].su_x;\n\t\ty = cache_list[idx].su_y;\n\t\tw = cache_list[idx].su_w;\n\t\th = cache_list[idx].su_h;\n\t\tif (x >= 0) {\n\t\t\tsraRgnDestroy(r2);\n\t\t\tr2 = sraRgnCreateRect(x, y, x+w, y+h);\n\t\t\tsraRgnOr(zero_rects, r2);\n\t\t}\n\t}\n\tsraRgnDestroy(r2);\n\n\tCLEAR(idx);\nif (! ok && ncdb) fprintf(stderr, \"**** free_rect: not-found %d\\n\", idx);\n\treturn ok;\n}",
          "includes": [
            "#include \"default8x16.h\"",
            "#include \"connections.h\"",
            "#include \"screen.h\"",
            "#include \"cursor.h\"",
            "#include \"macosxCGS.h\"",
            "#include \"macosx.h\"",
            "#include \"unixpw.h\"",
            "#include \"8to24.h\"",
            "#include \"xrandr.h\"",
            "#include \"solid.h\"",
            "#include \"keyboard.h\"",
            "#include \"rates.h\"",
            "#include \"pointer.h\"",
            "#include \"cleanup.h\"",
            "#include \"scan.h\"",
            "#include \"user.h\"",
            "#include \"xevents.h\"",
            "#include \"win_utils.h\"",
            "#include \"xinerama.h\"",
            "#include \"xrecord.h\"",
            "#include \"xdamage.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void mark_for_xdamage(int x, int y, int w, int h);",
            "void set_xdamage_mark(int x, int y, int w, int h);",
            "int find_rect(int idx, int x, int y, int w, int h);",
            "winattr_t *cache_list;",
            "int clipped(int idx);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"default8x16.h\"\n#include \"connections.h\"\n#include \"screen.h\"\n#include \"cursor.h\"\n#include \"macosxCGS.h\"\n#include \"macosx.h\"\n#include \"unixpw.h\"\n#include \"8to24.h\"\n#include \"xrandr.h\"\n#include \"solid.h\"\n#include \"keyboard.h\"\n#include \"rates.h\"\n#include \"pointer.h\"\n#include \"cleanup.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"xevents.h\"\n#include \"win_utils.h\"\n#include \"xinerama.h\"\n#include \"xrecord.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nvoid mark_for_xdamage(int x, int y, int w, int h);\nvoid set_xdamage_mark(int x, int y, int w, int h);\nint find_rect(int idx, int x, int y, int w, int h);\nwinattr_t *cache_list;\nint clipped(int idx);\n\nint free_rect(int idx) {\n\tint n, ok = 0;\n\tsraRegionPtr r1, r2;\n\tint x, y, w, h;\n\n\tif (idx < 0 || idx >= cache_list_num) {\nif (0) fprintf(stderr, \"free_rect: bad index: %d\\n\", idx);\n\t\tclean_up_exit(1);\n\t}\n\n\tx = cache_list[idx].bs_x;\n\ty = cache_list[idx].bs_y;\n\tw = cache_list[idx].bs_w;\n\th = cache_list[idx].bs_h;\n\n\tif (x < 0) {\n\t\tCLEAR(idx);\nif (dnow() > last_client + 5 && ncdb) fprintf(stderr, \"free_rect: already bs_x invalidated: %d bs_x: %d\\n\", idx, x);\n\t\treturn 1;\n\t}\n\n\tr2 = sraRgnCreateRect(x, y, x+w, y+h);\n\n\tn = get_bs_n(y);\n\tif (n >= 0) {\n\t\tr1 = rect_reg[n];\n\t\tsraRgnOr(r1, r2);\n\t\tok = 1;\n\t}\n\n\tif (zero_rects) {\n\t\tsraRgnOr(zero_rects, r2);\n\t\tx = cache_list[idx].su_x;\n\t\ty = cache_list[idx].su_y;\n\t\tw = cache_list[idx].su_w;\n\t\th = cache_list[idx].su_h;\n\t\tif (x >= 0) {\n\t\t\tsraRgnDestroy(r2);\n\t\t\tr2 = sraRgnCreateRect(x, y, x+w, y+h);\n\t\t\tsraRgnOr(zero_rects, r2);\n\t\t}\n\t}\n\tsraRgnDestroy(r2);\n\n\tCLEAR(idx);\nif (! ok && ncdb) fprintf(stderr, \"**** free_rect: not-found %d\\n\", idx);\n\treturn ok;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"avahi.h\"\n#include \"sslhelper.h\"\n#include \"remote.h\"\n#include \"cursor.h\"\n#include \"keyboard.h\"\n#include \"inet.h\"\n#include \"connections.h\"\n#include \"xwrappers.h\"\n#include \"sslhelper.h\"\n#include \"unixpw.h\"\n#include \"screen.h\"\n#include \"scan.h\"\n#include \"cleanup.h\"\n#include \"solid.h\"\n#include \"x11vnc.h\"\n\nstatic void setup_fake_fb(XImage* fb_image, int w, int h, int b) {\n\tif (fake_fb) {\n\t\tfree(fake_fb);\n\t}\n\tfake_fb = (char *) calloc(w*h*b/8, 1);\n\n\tfb_image->data = fake_fb;\n\tfb_image->format = ZPixmap;\n\tfb_image->width  = w;\n\tfb_image->height = h;\n\tfb_image->bits_per_pixel = b;\n\tfb_image->bytes_per_line = w*b/8;\n\tfb_image->bitmap_unit = -1;\n\tif (b >= 24) {\n\t\tfb_image->depth = 24;\n\t\tfb_image->red_mask   = 0xff0000;\n\t\tfb_image->green_mask = 0x00ff00;\n\t\tfb_image->blue_mask  = 0x0000ff;\n\t} else if (b >= 16) {\n\t\tfb_image->depth = 16;\n\t\tfb_image->red_mask   = 0x003f;\n\t\tfb_image->green_mask = 0x07c0;\n\t\tfb_image->blue_mask  = 0xf800;\n\t} else if (b >= 2) {\n\t\tfb_image->depth = 8;\n\t\tfb_image->red_mask   = 0x07;\n\t\tfb_image->green_mask = 0x38;\n\t\tfb_image->blue_mask  = 0xc0;\n\t} else {\n\t\tfb_image->depth = 1;\n\t\tfb_image->red_mask   = 0x1;\n\t\tfb_image->green_mask = 0x1;\n\t\tfb_image->blue_mask  = 0x1;\n\t}\n\n\tdepth = fb_image->depth;\n\n\tdpy_x = wdpy_x = w;\n\tdpy_y = wdpy_y = h;\n\toff_x = 0;\n\toff_y = 0;\n}"
  },
  {
    "function_name": "do_chvt",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/user.c",
    "lines": "1401-1407",
    "snippet": "static void do_chvt(int vt) {\n\tchar chvt[100];\n\tsprintf(chvt, \"chvt %d >/dev/null 2>/dev/null &\", vt);\n\trfbLog(\"running: %s\\n\", chvt);\n\tsystem(chvt);\n\tsleep(2);\n}",
    "includes": [
      "#include \"avahi.h\"",
      "#include \"sslhelper.h\"",
      "#include \"remote.h\"",
      "#include \"cursor.h\"",
      "#include \"keyboard.h\"",
      "#include \"inet.h\"",
      "#include \"connections.h\"",
      "#include \"xwrappers.h\"",
      "#include \"sslhelper.h\"",
      "#include \"unixpw.h\"",
      "#include \"screen.h\"",
      "#include \"scan.h\"",
      "#include \"cleanup.h\"",
      "#include \"solid.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "sleep",
          "args": [
            "2"
          ],
          "line": 1406
        },
        "resolved": true,
        "details": {
          "function_name": "do_sleepin",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/x11vnc.c",
          "lines": "1929-1959",
          "snippet": "static void do_sleepin(char *sleep) {\n\tint n1, n2, nt;\n\tdouble f1, f2, ft;\n\n\tif (strchr(sleep, '-')) {\n\t\tdouble s = atof(strchr(sleep, '-')+1); \n\t\tif (sscanf(sleep, \"%d-%d\", &n1, &n2) == 2) {\n\t\t\tif (n1 > n2) {\n\t\t\t\tnt = n1;\n\t\t\t\tn1 = n2;\n\t\t\t\tn2 = nt;\n\t\t\t}\n\t\t\ts = n1 + rfac() * (n2 - n1);\n\t\t} else if (sscanf(sleep, \"%lf-%lf\", &f1, &f2) == 2) {\n\t\t\tif (f1 > f2) {\n\t\t\t\tft = f1;\n\t\t\t\tf1 = f2;\n\t\t\t\tf2 = ft;\n\t\t\t}\n\t\t\ts = f1 + rfac() * (f2 - f1);\n\t\t}\n\t\tif (getenv(\"DEBUG_SLEEPIN\")) fprintf(stderr, \"sleepin: %f secs\\n\", s);\n\t\tusleep( (int) (1000*1000*s) );\n\t} else {\n\t\tn1 = atoi(sleep);\n\t\tif (getenv(\"DEBUG_SLEEPIN\")) fprintf(stderr, \"sleepin: %d secs\\n\", n1);\n\t\tif (n1 > 0) {\n\t\t\tusleep(1000*1000*n1);\n\t\t}\n\t}\n}",
          "includes": [
            "#include \"xi2_devices.h\"",
            "#include \"solid.h\"",
            "#include \"pm.h\"",
            "#include \"selection.h\"",
            "#include \"sslhelper.h\"",
            "#include \"sslcmds.h\"",
            "#include \"inet.h\"",
            "#include \"unixpw.h\"",
            "#include \"rates.h\"",
            "#include \"connections.h\"",
            "#include \"screen.h\"",
            "#include \"userinput.h\"",
            "#include \"cursor.h\"",
            "#include \"pointer.h\"",
            "#include \"keyboard.h\"",
            "#include \"cleanup.h\"",
            "#include \"user.h\"",
            "#include \"help.h\"",
            "#include \"gui.h\"",
            "#include \"scan.h\"",
            "#include \"remote.h\"",
            "#include \"win_utils.h\"",
            "#include \"xkb_bell.h\"",
            "#include \"xrandr.h\"",
            "#include \"xinerama.h\"",
            "#include \"xevents.h\"",
            "#include \"xrecord.h\"",
            "#include \"xdamage.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xi2_devices.h\"\n#include \"solid.h\"\n#include \"pm.h\"\n#include \"selection.h\"\n#include \"sslhelper.h\"\n#include \"sslcmds.h\"\n#include \"inet.h\"\n#include \"unixpw.h\"\n#include \"rates.h\"\n#include \"connections.h\"\n#include \"screen.h\"\n#include \"userinput.h\"\n#include \"cursor.h\"\n#include \"pointer.h\"\n#include \"keyboard.h\"\n#include \"cleanup.h\"\n#include \"user.h\"\n#include \"help.h\"\n#include \"gui.h\"\n#include \"scan.h\"\n#include \"remote.h\"\n#include \"win_utils.h\"\n#include \"xkb_bell.h\"\n#include \"xrandr.h\"\n#include \"xinerama.h\"\n#include \"xevents.h\"\n#include \"xrecord.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nstatic void do_sleepin(char *sleep) {\n\tint n1, n2, nt;\n\tdouble f1, f2, ft;\n\n\tif (strchr(sleep, '-')) {\n\t\tdouble s = atof(strchr(sleep, '-')+1); \n\t\tif (sscanf(sleep, \"%d-%d\", &n1, &n2) == 2) {\n\t\t\tif (n1 > n2) {\n\t\t\t\tnt = n1;\n\t\t\t\tn1 = n2;\n\t\t\t\tn2 = nt;\n\t\t\t}\n\t\t\ts = n1 + rfac() * (n2 - n1);\n\t\t} else if (sscanf(sleep, \"%lf-%lf\", &f1, &f2) == 2) {\n\t\t\tif (f1 > f2) {\n\t\t\t\tft = f1;\n\t\t\t\tf1 = f2;\n\t\t\t\tf2 = ft;\n\t\t\t}\n\t\t\ts = f1 + rfac() * (f2 - f1);\n\t\t}\n\t\tif (getenv(\"DEBUG_SLEEPIN\")) fprintf(stderr, \"sleepin: %f secs\\n\", s);\n\t\tusleep( (int) (1000*1000*s) );\n\t} else {\n\t\tn1 = atoi(sleep);\n\t\tif (getenv(\"DEBUG_SLEEPIN\")) fprintf(stderr, \"sleepin: %d secs\\n\", n1);\n\t\tif (n1 > 0) {\n\t\t\tusleep(1000*1000*n1);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "system",
          "args": [
            "chvt"
          ],
          "line": 1405
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"running: %s\\n\"",
            "chvt"
          ],
          "line": 1404
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "chvt",
            "\"chvt %d >/dev/null 2>/dev/null &\"",
            "vt"
          ],
          "line": 1403
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"avahi.h\"\n#include \"sslhelper.h\"\n#include \"remote.h\"\n#include \"cursor.h\"\n#include \"keyboard.h\"\n#include \"inet.h\"\n#include \"connections.h\"\n#include \"xwrappers.h\"\n#include \"sslhelper.h\"\n#include \"unixpw.h\"\n#include \"screen.h\"\n#include \"scan.h\"\n#include \"cleanup.h\"\n#include \"solid.h\"\n#include \"x11vnc.h\"\n\nstatic void do_chvt(int vt) {\n\tchar chvt[100];\n\tsprintf(chvt, \"chvt %d >/dev/null 2>/dev/null &\", vt);\n\trfbLog(\"running: %s\\n\", chvt);\n\tsystem(chvt);\n\tsleep(2);\n}"
  },
  {
    "function_name": "vnc_redirect_timeout",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/user.c",
    "lines": "1395-1399",
    "snippet": "static void vnc_redirect_timeout (int sig) {\n\twrite(2, \"timeout: no clients connected.\\n\", 31);\n\tif (sig) {};\n\texit(0);\n}",
    "includes": [
      "#include \"avahi.h\"",
      "#include \"sslhelper.h\"",
      "#include \"remote.h\"",
      "#include \"cursor.h\"",
      "#include \"keyboard.h\"",
      "#include \"inet.h\"",
      "#include \"connections.h\"",
      "#include \"xwrappers.h\"",
      "#include \"sslhelper.h\"",
      "#include \"unixpw.h\"",
      "#include \"screen.h\"",
      "#include \"scan.h\"",
      "#include \"cleanup.h\"",
      "#include \"solid.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "0"
          ],
          "line": 1398
        },
        "resolved": true,
        "details": {
          "function_name": "clean_up_exit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/cleanup.c",
          "lines": "151-266",
          "snippet": "void clean_up_exit(int ret) {\n\tstatic int depth = 0;\n\texit_flag = 1;\n\n\tif (depth++ > 2) {\n\t\texit(ret);\n\t}\n\n\tif (icon_mode) {\n\t\tclean_icon_mode();\n\t}\n\n\t/* remove the shm areas: */\n\tclean_shm(0);\n\n\tstop_stunnel();\n\tif (use_openssl) {\n\t\tssl_helper_pid(0, 0);\t/* killall */\n\t}\n\n\tif (ssh_pid > 0) {\n\t\tkill(ssh_pid, SIGTERM);\n\t\tssh_pid = 0;\n\t}\n\n#ifdef MACOSX\n\tif (client_connect_file) {\n\t\tif (strstr(client_connect_file, \"/tmp/x11vnc-macosx-remote\")\n\t\t    == client_connect_file) {\n\t\t\tunlink(client_connect_file);\n\t\t}\n\t}\n\tif (macosx_console) {\n\t\tmacosxCG_fini();\n\t}\n#endif\n\n\tif (pipeinput_fh != NULL) {\n\t\tpclose(pipeinput_fh);\n\t\tpipeinput_fh = NULL;\n\t}\n\n\tshutdown_uinput();\n\n\tif (unix_sock) {\n\t\tif (unix_sock_fd >= 0) {\n\t\t\trfbLog(\"deleting unix sock: %s\\n\", unix_sock);\n\t\t\tclose(unix_sock_fd);\n\t\t\tunix_sock_fd = -1;\n\t\t\tunlink(unix_sock);\n\t\t}\n\t}\n\n\tif (! dpy) {\t/* raw_rb hack */\n\t\tif (rm_flagfile) {\n\t\t\tunlink(rm_flagfile);\n\t\t\trm_flagfile = NULL;\n\t\t}\n\t\texit(ret);\n\t}\n\n\t/* X keyboard cleanups */\n\tdelete_added_keycodes(0);\n\n\t/* remove all created XInput2 devices */\n\tif(use_multipointer)\n\t    removeAllMDs(dpy);\n\n\tif (clear_mods == 1) {\n\t\tclear_modifiers(0);\n\t} else if (clear_mods == 2) {\n\t\tclear_keys();\n\t} else if (clear_mods == 3) {\n\t\tclear_keys();\n\t\tclear_locks();\n\t}\n\n\tif (no_autorepeat) {\n\t\tautorepeat(1, 0);\n\t}\n\tif (use_solid_bg) {\n\t\tsolid_bg(1);\n\t}\n\tif (ncache || ncache0) {\n\t\tkde_no_animate(1);\n\t}\n\tX_LOCK;\n\tXTestDiscard_wr(dpy);\n#if HAVE_LIBXDAMAGE\n\tif (xdamage) {\n\t\tXDamageDestroy(dpy, xdamage);\n\t}\n#endif\n#if HAVE_LIBXTRAP\n\tif (trap_ctx) {\n\t\tXEFreeTC(trap_ctx);\n\t}\n#endif\n\t/* XXX rdpy_ctrl, etc. cannot close w/o blocking */\n\tXCloseDisplay_wr(dpy);\n\tX_UNLOCK;\n\n\tfflush(stderr);\n\n\tif (rm_flagfile) {\n\t\tunlink(rm_flagfile);\n\t\trm_flagfile = NULL;\n\t}\n\n\tif (avahi) {\n\t\tavahi_cleanup();\n\t\tfflush(stderr);\n\t}\n\n\texit(ret);\n}",
          "includes": [
            "#include \"xi2_devices.h\"",
            "#include \"uinput.h\"",
            "#include \"xevents.h\"",
            "#include \"xrecord.h\"",
            "#include \"screen.h\"",
            "#include \"avahi.h\"",
            "#include \"macosxCG.h\"",
            "#include \"macosx.h\"",
            "#include \"connections.h\"",
            "#include \"sslhelper.h\"",
            "#include \"sslcmds.h\"",
            "#include \"unixpw.h\"",
            "#include \"solid.h\"",
            "#include \"gui.h\"",
            "#include \"scan.h\"",
            "#include \"keyboard.h\"",
            "#include \"remote.h\"",
            "#include \"xdamage.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void clean_up_exit(int ret);",
            "int known_sigpipe_mode(char *s);",
            "static int exit_flag = 0;",
            "static void clean_icon_mode(void);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xi2_devices.h\"\n#include \"uinput.h\"\n#include \"xevents.h\"\n#include \"xrecord.h\"\n#include \"screen.h\"\n#include \"avahi.h\"\n#include \"macosxCG.h\"\n#include \"macosx.h\"\n#include \"connections.h\"\n#include \"sslhelper.h\"\n#include \"sslcmds.h\"\n#include \"unixpw.h\"\n#include \"solid.h\"\n#include \"gui.h\"\n#include \"scan.h\"\n#include \"keyboard.h\"\n#include \"remote.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nvoid clean_up_exit(int ret);\nint known_sigpipe_mode(char *s);\nstatic int exit_flag = 0;\nstatic void clean_icon_mode(void);\n\nvoid clean_up_exit(int ret) {\n\tstatic int depth = 0;\n\texit_flag = 1;\n\n\tif (depth++ > 2) {\n\t\texit(ret);\n\t}\n\n\tif (icon_mode) {\n\t\tclean_icon_mode();\n\t}\n\n\t/* remove the shm areas: */\n\tclean_shm(0);\n\n\tstop_stunnel();\n\tif (use_openssl) {\n\t\tssl_helper_pid(0, 0);\t/* killall */\n\t}\n\n\tif (ssh_pid > 0) {\n\t\tkill(ssh_pid, SIGTERM);\n\t\tssh_pid = 0;\n\t}\n\n#ifdef MACOSX\n\tif (client_connect_file) {\n\t\tif (strstr(client_connect_file, \"/tmp/x11vnc-macosx-remote\")\n\t\t    == client_connect_file) {\n\t\t\tunlink(client_connect_file);\n\t\t}\n\t}\n\tif (macosx_console) {\n\t\tmacosxCG_fini();\n\t}\n#endif\n\n\tif (pipeinput_fh != NULL) {\n\t\tpclose(pipeinput_fh);\n\t\tpipeinput_fh = NULL;\n\t}\n\n\tshutdown_uinput();\n\n\tif (unix_sock) {\n\t\tif (unix_sock_fd >= 0) {\n\t\t\trfbLog(\"deleting unix sock: %s\\n\", unix_sock);\n\t\t\tclose(unix_sock_fd);\n\t\t\tunix_sock_fd = -1;\n\t\t\tunlink(unix_sock);\n\t\t}\n\t}\n\n\tif (! dpy) {\t/* raw_rb hack */\n\t\tif (rm_flagfile) {\n\t\t\tunlink(rm_flagfile);\n\t\t\trm_flagfile = NULL;\n\t\t}\n\t\texit(ret);\n\t}\n\n\t/* X keyboard cleanups */\n\tdelete_added_keycodes(0);\n\n\t/* remove all created XInput2 devices */\n\tif(use_multipointer)\n\t    removeAllMDs(dpy);\n\n\tif (clear_mods == 1) {\n\t\tclear_modifiers(0);\n\t} else if (clear_mods == 2) {\n\t\tclear_keys();\n\t} else if (clear_mods == 3) {\n\t\tclear_keys();\n\t\tclear_locks();\n\t}\n\n\tif (no_autorepeat) {\n\t\tautorepeat(1, 0);\n\t}\n\tif (use_solid_bg) {\n\t\tsolid_bg(1);\n\t}\n\tif (ncache || ncache0) {\n\t\tkde_no_animate(1);\n\t}\n\tX_LOCK;\n\tXTestDiscard_wr(dpy);\n#if HAVE_LIBXDAMAGE\n\tif (xdamage) {\n\t\tXDamageDestroy(dpy, xdamage);\n\t}\n#endif\n#if HAVE_LIBXTRAP\n\tif (trap_ctx) {\n\t\tXEFreeTC(trap_ctx);\n\t}\n#endif\n\t/* XXX rdpy_ctrl, etc. cannot close w/o blocking */\n\tXCloseDisplay_wr(dpy);\n\tX_UNLOCK;\n\n\tfflush(stderr);\n\n\tif (rm_flagfile) {\n\t\tunlink(rm_flagfile);\n\t\trm_flagfile = NULL;\n\t}\n\n\tif (avahi) {\n\t\tavahi_cleanup();\n\t\tfflush(stderr);\n\t}\n\n\texit(ret);\n}"
        }
      },
      {
        "call_info": {
          "callee": "write",
          "args": [
            "2",
            "\"timeout: no clients connected.\\n\"",
            "31"
          ],
          "line": 1396
        },
        "resolved": true,
        "details": {
          "function_name": "write_exact",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/sslhelper.c",
          "lines": "1319-1344",
          "snippet": "static int write_exact(int sock, char *buf, int len) {\n\tint n, fail = 0;\n\tif (sock < 0) {\n\t\treturn 0;\n\t}\n\twhile (len > 0) {\n\t\tn = write(sock, buf, len);\n\t\tif (n > 0) {\n\t\t\tbuf += n;\n\t\t\tlen -= n;\n\t\t} else if (n == 0) {\n\t\t\tfail = 1;\n\t\t\tbreak;\n\t\t} else if (n < 0 && (errno == EAGAIN || errno == EWOULDBLOCK)) {\n\t\t\tusleep(10*1000);\n\t\t} else if (n < 0 && errno != EINTR) {\n\t\t\tfail = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (fail) {\n\t\treturn 0;\n\t} else {\n\t\treturn 1;\n\t}\n}",
          "includes": [
            "#include <openssl/rand.h>",
            "#include <openssl/err.h>",
            "#include <openssl/ssl.h>",
            "#include \"user.h\"",
            "#include \"unixpw.h\"",
            "#include \"sslcmds.h\"",
            "#include \"connections.h\"",
            "#include \"scan.h\"",
            "#include \"screen.h\"",
            "#include \"cleanup.h\"",
            "#include \"inet.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void ssl_helper_pid(pid_t pid, int sock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <openssl/rand.h>\n#include <openssl/err.h>\n#include <openssl/ssl.h>\n#include \"user.h\"\n#include \"unixpw.h\"\n#include \"sslcmds.h\"\n#include \"connections.h\"\n#include \"scan.h\"\n#include \"screen.h\"\n#include \"cleanup.h\"\n#include \"inet.h\"\n#include \"x11vnc.h\"\n\nvoid ssl_helper_pid(pid_t pid, int sock);\n\nstatic int write_exact(int sock, char *buf, int len) {\n\tint n, fail = 0;\n\tif (sock < 0) {\n\t\treturn 0;\n\t}\n\twhile (len > 0) {\n\t\tn = write(sock, buf, len);\n\t\tif (n > 0) {\n\t\t\tbuf += n;\n\t\t\tlen -= n;\n\t\t} else if (n == 0) {\n\t\t\tfail = 1;\n\t\t\tbreak;\n\t\t} else if (n < 0 && (errno == EAGAIN || errno == EWOULDBLOCK)) {\n\t\t\tusleep(10*1000);\n\t\t} else if (n < 0 && errno != EINTR) {\n\t\t\tfail = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (fail) {\n\t\treturn 0;\n\t} else {\n\t\treturn 1;\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"avahi.h\"\n#include \"sslhelper.h\"\n#include \"remote.h\"\n#include \"cursor.h\"\n#include \"keyboard.h\"\n#include \"inet.h\"\n#include \"connections.h\"\n#include \"xwrappers.h\"\n#include \"sslhelper.h\"\n#include \"unixpw.h\"\n#include \"screen.h\"\n#include \"scan.h\"\n#include \"cleanup.h\"\n#include \"solid.h\"\n#include \"x11vnc.h\"\n\nstatic void vnc_redirect_timeout (int sig) {\n\twrite(2, \"timeout: no clients connected.\\n\", 31);\n\tif (sig) {};\n\texit(0);\n}"
  },
  {
    "function_name": "user_supplied_opts",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/user.c",
    "lines": "1254-1393",
    "snippet": "void user_supplied_opts(char *opts) {\n\tchar *p, *str;\n\tchar *allow[] = {\n\t\t\"skip-display\", \"skip-auth\", \"skip-shared\",\n\t\t\"scale\", \"scale_cursor\", \"sc\", \"solid\", \"so\", \"id\",\n\t\t\"clear_mods\", \"cm\", \"clear_keys\", \"ck\", \"repeat\",\n\t\t\"clear_all\", \"ca\",\n\t\t\"speeds\", \"sp\", \"readtimeout\", \"rd\",\n\t\t\"rotate\", \"ro\",\n\t\t\"geometry\", \"geom\", \"ge\",\n\t\t\"noncache\", \"nc\",\n\t\t\"nodisplay\", \"nd\",\n\t\t\"viewonly\", \"vo\",\n\t\t\"tag\",\n\t\tNULL\n\t};\n\n\tif (getenv(\"X11VNC_NO_UNIXPW_OPTS\")) {\n\t\treturn;\n\t}\n\n\tstr = strdup(opts);\n\n\tp = strtok(str, \",\");\n\twhile (p) {\n\t\tchar *q;\n\t\tint i, n, m, ok = 0;\n\n\t\ti = 0;\n\t\twhile (allow[i] != NULL) {\n\t\t\tif (strstr(allow[i], \"skip-\")) {\n\t\t\t\ti++;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (strstr(p, allow[i]) == p) \t{\n\t\t\t\tok = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\ti++;\n\t\t}\n\n\t\tif (! ok && strpbrk(p, \"0123456789\") == p &&\n\t\t    sscanf(p, \"%d/%d\", &n, &m) == 2) {\n\t\t\tif (scale_str) free(scale_str);\n\t\t\tscale_str = strdup(p);\n\t\t} else if (ok) {\n\t\t\tif (0 && strstr(p, \"display=\") == p) {\n\t\t\t\tif (use_dpy) free(use_dpy);\n\t\t\t\tuse_dpy = strdup(p + strlen(\"display=\"));\n\t\t\t} else if (0 && strstr(p, \"auth=\") == p) {\n\t\t\t\tif (auth_file) free(auth_file);\n\t\t\t\tauth_file = strdup(p + strlen(\"auth=\"));\n\t\t\t} else if (0 && !strcmp(p, \"shared\")) {\n\t\t\t\tshared = 1;\n\t\t\t} else if (strstr(p, \"scale=\") == p) {\n\t\t\t\tif (scale_str) free(scale_str);\n\t\t\t\tscale_str = strdup(p + strlen(\"scale=\"));\n\t\t\t} else if (strstr(p, \"scale_cursor=\") == p ||\n\t\t\t    strstr(p, \"sc=\") == p) {\n\t\t\t\tif (scale_cursor_str) free(scale_cursor_str);\n\t\t\t\tq = strchr(p, '=') + 1;\n\t\t\t\tscale_cursor_str = strdup(q);\n\t\t\t} else if (strstr(p, \"rotate=\") == p ||\n\t\t\t    strstr(p, \"ro=\") == p) {\n\t\t\t\tif (rotating_str) free(rotating_str);\n\t\t\t\tq = strchr(p, '=') + 1;\n\t\t\t\trotating_str = strdup(q);\n\t\t\t} else if (!strcmp(p, \"solid\") || !strcmp(p, \"so\")) {\n\t\t\t\tuse_solid_bg = 1;\n\t\t\t\tif (!solid_str) {\n\t\t\t\t\tsolid_str = strdup(solid_default);\n\t\t\t\t}\n\t\t\t} else if (!strcmp(p, \"viewonly\") || !strcmp(p, \"vo\")) {\n\t\t\t\tview_only = 1;\n\t\t\t} else if (strstr(p, \"solid=\") == p ||\n\t\t\t    strstr(p, \"so=\") == p) {\n\t\t\t\tuse_solid_bg = 1;\n\t\t\t\tif (solid_str) free(solid_str);\n\t\t\t\tq = strchr(p, '=') + 1;\n\t\t\t\tif (!strcmp(q, \"R\")) {\n\t\t\t\t\tsolid_str = strdup(\"root:\");\n\t\t\t\t} else {\n\t\t\t\t\tsolid_str = strdup(q);\n\t\t\t\t}\n\t\t\t} else if (strstr(p, \"id=\") == p) {\n\t\t\t\tunsigned long win;\n\t\t\t\tq = p + strlen(\"id=\");\n\t\t\t\tif (strcmp(q, \"pick\")) {\n\t\t\t\t\tif (scan_hexdec(q, &win)) {\n\t\t\t\t\t\tsubwin = win;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else if (!strcmp(p, \"clear_mods\") ||\n\t\t\t    !strcmp(p, \"cm\")) {\n\t\t\t\tclear_mods = 1;\n\t\t\t} else if (!strcmp(p, \"clear_keys\") ||\n\t\t\t    !strcmp(p, \"ck\")) {\n\t\t\t\tclear_mods = 2;\n\t\t\t} else if (!strcmp(p, \"clear_all\") ||\n\t\t\t    !strcmp(p, \"ca\")) {\n\t\t\t\tclear_mods = 3;\n\t\t\t} else if (!strcmp(p, \"noncache\") ||\n\t\t\t    !strcmp(p, \"nc\")) {\n\t\t\t\tncache  = 0;\n\t\t\t\tncache0 = 0;\n\t\t\t} else if (strstr(p, \"nc=\") == p) {\n\t\t\t\tint n2 = atoi(p + strlen(\"nc=\"));\n\t\t\t\tif (nabs(n2) < nabs(ncache)) {\n\t\t\t\t\tif (ncache < 0) {\n\t\t\t\t\t\tncache = -nabs(n2);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tncache = nabs(n2);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else if (!strcmp(p, \"repeat\")) {\n\t\t\t\tno_autorepeat = 0;\n\t\t\t} else if (strstr(p, \"speeds=\") == p ||\n\t\t\t    strstr(p, \"sp=\") == p) {\n\t\t\t\tif (speeds_str) free(speeds_str);\n\t\t\t\tq = strchr(p, '=') + 1;\n\t\t\t\tspeeds_str = strdup(q);\n\t\t\t\tq = speeds_str;\n\t\t\t\twhile (*q != '\\0') {\n\t\t\t\t\tif (*q == '-') {\n\t\t\t\t\t\t*q = ',';\n\t\t\t\t\t}\n\t\t\t\t\tq++;\n\t\t\t\t}\n\t\t\t} else if (strstr(p, \"readtimeout=\") == p ||\n\t\t\t    strstr(p, \"rd=\") == p) {\n\t\t\t\tq = strchr(p, '=') + 1;\n\t\t\t\trfbMaxClientWait = atoi(q) * 1000;\n\t\t\t}\n\t\t} else {\n\t\t\trfbLog(\"skipping option: %s\\n\", p);\n\t\t}\n\t\tp = strtok(NULL, \",\");\n\t}\n\tfree(str);\n}",
    "includes": [
      "#include \"avahi.h\"",
      "#include \"sslhelper.h\"",
      "#include \"remote.h\"",
      "#include \"cursor.h\"",
      "#include \"keyboard.h\"",
      "#include \"inet.h\"",
      "#include \"connections.h\"",
      "#include \"xwrappers.h\"",
      "#include \"sslhelper.h\"",
      "#include \"unixpw.h\"",
      "#include \"screen.h\"",
      "#include \"scan.h\"",
      "#include \"cleanup.h\"",
      "#include \"solid.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "void lurk_loop(char *str);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "str"
          ],
          "line": 1392
        },
        "resolved": true,
        "details": {
          "function_name": "free_rect",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/userinput.c",
          "lines": "6200-6247",
          "snippet": "int free_rect(int idx) {\n\tint n, ok = 0;\n\tsraRegionPtr r1, r2;\n\tint x, y, w, h;\n\n\tif (idx < 0 || idx >= cache_list_num) {\nif (0) fprintf(stderr, \"free_rect: bad index: %d\\n\", idx);\n\t\tclean_up_exit(1);\n\t}\n\n\tx = cache_list[idx].bs_x;\n\ty = cache_list[idx].bs_y;\n\tw = cache_list[idx].bs_w;\n\th = cache_list[idx].bs_h;\n\n\tif (x < 0) {\n\t\tCLEAR(idx);\nif (dnow() > last_client + 5 && ncdb) fprintf(stderr, \"free_rect: already bs_x invalidated: %d bs_x: %d\\n\", idx, x);\n\t\treturn 1;\n\t}\n\n\tr2 = sraRgnCreateRect(x, y, x+w, y+h);\n\n\tn = get_bs_n(y);\n\tif (n >= 0) {\n\t\tr1 = rect_reg[n];\n\t\tsraRgnOr(r1, r2);\n\t\tok = 1;\n\t}\n\n\tif (zero_rects) {\n\t\tsraRgnOr(zero_rects, r2);\n\t\tx = cache_list[idx].su_x;\n\t\ty = cache_list[idx].su_y;\n\t\tw = cache_list[idx].su_w;\n\t\th = cache_list[idx].su_h;\n\t\tif (x >= 0) {\n\t\t\tsraRgnDestroy(r2);\n\t\t\tr2 = sraRgnCreateRect(x, y, x+w, y+h);\n\t\t\tsraRgnOr(zero_rects, r2);\n\t\t}\n\t}\n\tsraRgnDestroy(r2);\n\n\tCLEAR(idx);\nif (! ok && ncdb) fprintf(stderr, \"**** free_rect: not-found %d\\n\", idx);\n\treturn ok;\n}",
          "includes": [
            "#include \"default8x16.h\"",
            "#include \"connections.h\"",
            "#include \"screen.h\"",
            "#include \"cursor.h\"",
            "#include \"macosxCGS.h\"",
            "#include \"macosx.h\"",
            "#include \"unixpw.h\"",
            "#include \"8to24.h\"",
            "#include \"xrandr.h\"",
            "#include \"solid.h\"",
            "#include \"keyboard.h\"",
            "#include \"rates.h\"",
            "#include \"pointer.h\"",
            "#include \"cleanup.h\"",
            "#include \"scan.h\"",
            "#include \"user.h\"",
            "#include \"xevents.h\"",
            "#include \"win_utils.h\"",
            "#include \"xinerama.h\"",
            "#include \"xrecord.h\"",
            "#include \"xdamage.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void mark_for_xdamage(int x, int y, int w, int h);",
            "void set_xdamage_mark(int x, int y, int w, int h);",
            "int find_rect(int idx, int x, int y, int w, int h);",
            "winattr_t *cache_list;",
            "int clipped(int idx);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"default8x16.h\"\n#include \"connections.h\"\n#include \"screen.h\"\n#include \"cursor.h\"\n#include \"macosxCGS.h\"\n#include \"macosx.h\"\n#include \"unixpw.h\"\n#include \"8to24.h\"\n#include \"xrandr.h\"\n#include \"solid.h\"\n#include \"keyboard.h\"\n#include \"rates.h\"\n#include \"pointer.h\"\n#include \"cleanup.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"xevents.h\"\n#include \"win_utils.h\"\n#include \"xinerama.h\"\n#include \"xrecord.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nvoid mark_for_xdamage(int x, int y, int w, int h);\nvoid set_xdamage_mark(int x, int y, int w, int h);\nint find_rect(int idx, int x, int y, int w, int h);\nwinattr_t *cache_list;\nint clipped(int idx);\n\nint free_rect(int idx) {\n\tint n, ok = 0;\n\tsraRegionPtr r1, r2;\n\tint x, y, w, h;\n\n\tif (idx < 0 || idx >= cache_list_num) {\nif (0) fprintf(stderr, \"free_rect: bad index: %d\\n\", idx);\n\t\tclean_up_exit(1);\n\t}\n\n\tx = cache_list[idx].bs_x;\n\ty = cache_list[idx].bs_y;\n\tw = cache_list[idx].bs_w;\n\th = cache_list[idx].bs_h;\n\n\tif (x < 0) {\n\t\tCLEAR(idx);\nif (dnow() > last_client + 5 && ncdb) fprintf(stderr, \"free_rect: already bs_x invalidated: %d bs_x: %d\\n\", idx, x);\n\t\treturn 1;\n\t}\n\n\tr2 = sraRgnCreateRect(x, y, x+w, y+h);\n\n\tn = get_bs_n(y);\n\tif (n >= 0) {\n\t\tr1 = rect_reg[n];\n\t\tsraRgnOr(r1, r2);\n\t\tok = 1;\n\t}\n\n\tif (zero_rects) {\n\t\tsraRgnOr(zero_rects, r2);\n\t\tx = cache_list[idx].su_x;\n\t\ty = cache_list[idx].su_y;\n\t\tw = cache_list[idx].su_w;\n\t\th = cache_list[idx].su_h;\n\t\tif (x >= 0) {\n\t\t\tsraRgnDestroy(r2);\n\t\t\tr2 = sraRgnCreateRect(x, y, x+w, y+h);\n\t\t\tsraRgnOr(zero_rects, r2);\n\t\t}\n\t}\n\tsraRgnDestroy(r2);\n\n\tCLEAR(idx);\nif (! ok && ncdb) fprintf(stderr, \"**** free_rect: not-found %d\\n\", idx);\n\treturn ok;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strtok",
          "args": [
            "NULL",
            "\",\""
          ],
          "line": 1390
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"skipping option: %s\\n\"",
            "p"
          ],
          "line": 1388
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atoi",
          "args": [
            "q"
          ],
          "line": 1385
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "p",
            "'='"
          ],
          "line": 1384
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "p",
            "\"rd=\""
          ],
          "line": 1383
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "p",
            "\"readtimeout=\""
          ],
          "line": 1382
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "q"
          ],
          "line": 1374
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "p",
            "'='"
          ],
          "line": 1373
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "p",
            "\"sp=\""
          ],
          "line": 1371
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "p",
            "\"speeds=\""
          ],
          "line": 1370
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "p",
            "\"repeat\""
          ],
          "line": 1368
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nabs",
          "args": [
            "n2"
          ],
          "line": 1365
        },
        "resolved": true,
        "details": {
          "function_name": "nabs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/util.c",
          "lines": "120-126",
          "snippet": "int nabs(int n) {\n\tif (n < 0) {\n\t\treturn -n;\n\t} else {\n\t\treturn n;\n\t}\n}",
          "includes": [
            "#include \"connections.h\"",
            "#include \"unixpw.h\"",
            "#include \"win_utils.h\"",
            "#include \"cleanup.h\"",
            "#include \"x11vnc.h\"",
            "#include <stdlib.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int nfix(int i, int n);",
            "int nabs(int n);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"connections.h\"\n#include \"unixpw.h\"\n#include \"win_utils.h\"\n#include \"cleanup.h\"\n#include \"x11vnc.h\"\n#include <stdlib.h>\n\nint nfix(int i, int n);\nint nabs(int n);\n\nint nabs(int n) {\n\tif (n < 0) {\n\t\treturn -n;\n\t} else {\n\t\treturn n;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "atoi",
          "args": [
            "p + strlen(\"nc=\")"
          ],
          "line": 1360
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "\"nc=\""
          ],
          "line": 1360
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "p",
            "\"nc=\""
          ],
          "line": 1359
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "p",
            "\"nc\""
          ],
          "line": 1356
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "p",
            "\"noncache\""
          ],
          "line": 1355
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "p",
            "\"ca\""
          ],
          "line": 1353
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "p",
            "\"clear_all\""
          ],
          "line": 1352
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "p",
            "\"ck\""
          ],
          "line": 1350
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "p",
            "\"clear_keys\""
          ],
          "line": 1349
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "p",
            "\"cm\""
          ],
          "line": 1347
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "p",
            "\"clear_mods\""
          ],
          "line": 1346
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "scan_hexdec",
          "args": [
            "q",
            "&win"
          ],
          "line": 1342
        },
        "resolved": true,
        "details": {
          "function_name": "scan_hexdec",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/util.c",
          "lines": "201-208",
          "snippet": "int scan_hexdec(char *str, unsigned long *num) {\n\tif (sscanf(str, \"0x%lx\", num) != 1) {\n\t\tif (sscanf(str, \"%lu\", num) != 1) {\n\t\t\treturn 0;\n\t\t}\n\t}\n\treturn 1;\n}",
          "includes": [
            "#include \"connections.h\"",
            "#include \"unixpw.h\"",
            "#include \"win_utils.h\"",
            "#include \"cleanup.h\"",
            "#include \"x11vnc.h\"",
            "#include <stdlib.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void lowercase(char *str);",
            "void uppercase(char *str);",
            "char *lblanks(char *str);",
            "void strzero(char *str);",
            "int scan_hexdec(char *str, unsigned long *num);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"connections.h\"\n#include \"unixpw.h\"\n#include \"win_utils.h\"\n#include \"cleanup.h\"\n#include \"x11vnc.h\"\n#include <stdlib.h>\n\nvoid lowercase(char *str);\nvoid uppercase(char *str);\nchar *lblanks(char *str);\nvoid strzero(char *str);\nint scan_hexdec(char *str, unsigned long *num);\n\nint scan_hexdec(char *str, unsigned long *num) {\n\tif (sscanf(str, \"0x%lx\", num) != 1) {\n\t\tif (sscanf(str, \"%lu\", num) != 1) {\n\t\t\treturn 0;\n\t\t}\n\t}\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "q",
            "\"pick\""
          ],
          "line": 1341
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "\"id=\""
          ],
          "line": 1340
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "p",
            "\"id=\""
          ],
          "line": 1338
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "q"
          ],
          "line": 1336
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "\"root:\""
          ],
          "line": 1334
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "q",
            "\"R\""
          ],
          "line": 1333
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "p",
            "'='"
          ],
          "line": 1332
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "p",
            "\"so=\""
          ],
          "line": 1329
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "p",
            "\"solid=\""
          ],
          "line": 1328
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "p",
            "\"vo\""
          ],
          "line": 1326
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "p",
            "\"viewonly\""
          ],
          "line": 1326
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "solid_default"
          ],
          "line": 1324
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "p",
            "\"so\""
          ],
          "line": 1321
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "p",
            "\"solid\""
          ],
          "line": 1321
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "q"
          ],
          "line": 1320
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "p",
            "'='"
          ],
          "line": 1319
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "p",
            "\"ro=\""
          ],
          "line": 1317
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "p",
            "\"rotate=\""
          ],
          "line": 1316
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "q"
          ],
          "line": 1315
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "p",
            "'='"
          ],
          "line": 1314
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "p",
            "\"sc=\""
          ],
          "line": 1312
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "p",
            "\"scale_cursor=\""
          ],
          "line": 1311
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "p + strlen(\"scale=\")"
          ],
          "line": 1310
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "\"scale=\""
          ],
          "line": 1310
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "p",
            "\"scale=\""
          ],
          "line": 1308
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "p",
            "\"shared\""
          ],
          "line": 1306
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "p + strlen(\"auth=\")"
          ],
          "line": 1305
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "\"auth=\""
          ],
          "line": 1305
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "p",
            "\"auth=\""
          ],
          "line": 1303
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "p + strlen(\"display=\")"
          ],
          "line": 1302
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "\"display=\""
          ],
          "line": 1302
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "p",
            "\"display=\""
          ],
          "line": 1300
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "p"
          ],
          "line": 1298
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sscanf",
          "args": [
            "p",
            "\"%d/%d\"",
            "&n",
            "&m"
          ],
          "line": 1296
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strpbrk",
          "args": [
            "p",
            "\"0123456789\""
          ],
          "line": 1295
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "p",
            "allow[i]"
          ],
          "line": 1288
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "allow[i]",
            "\"skip-\""
          ],
          "line": 1284
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strtok",
          "args": [
            "str",
            "\",\""
          ],
          "line": 1277
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "opts"
          ],
          "line": 1275
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getenv",
          "args": [
            "\"X11VNC_NO_UNIXPW_OPTS\""
          ],
          "line": 1271
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"avahi.h\"\n#include \"sslhelper.h\"\n#include \"remote.h\"\n#include \"cursor.h\"\n#include \"keyboard.h\"\n#include \"inet.h\"\n#include \"connections.h\"\n#include \"xwrappers.h\"\n#include \"sslhelper.h\"\n#include \"unixpw.h\"\n#include \"screen.h\"\n#include \"scan.h\"\n#include \"cleanup.h\"\n#include \"solid.h\"\n#include \"x11vnc.h\"\n\nvoid lurk_loop(char *str);\n\nvoid user_supplied_opts(char *opts) {\n\tchar *p, *str;\n\tchar *allow[] = {\n\t\t\"skip-display\", \"skip-auth\", \"skip-shared\",\n\t\t\"scale\", \"scale_cursor\", \"sc\", \"solid\", \"so\", \"id\",\n\t\t\"clear_mods\", \"cm\", \"clear_keys\", \"ck\", \"repeat\",\n\t\t\"clear_all\", \"ca\",\n\t\t\"speeds\", \"sp\", \"readtimeout\", \"rd\",\n\t\t\"rotate\", \"ro\",\n\t\t\"geometry\", \"geom\", \"ge\",\n\t\t\"noncache\", \"nc\",\n\t\t\"nodisplay\", \"nd\",\n\t\t\"viewonly\", \"vo\",\n\t\t\"tag\",\n\t\tNULL\n\t};\n\n\tif (getenv(\"X11VNC_NO_UNIXPW_OPTS\")) {\n\t\treturn;\n\t}\n\n\tstr = strdup(opts);\n\n\tp = strtok(str, \",\");\n\twhile (p) {\n\t\tchar *q;\n\t\tint i, n, m, ok = 0;\n\n\t\ti = 0;\n\t\twhile (allow[i] != NULL) {\n\t\t\tif (strstr(allow[i], \"skip-\")) {\n\t\t\t\ti++;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (strstr(p, allow[i]) == p) \t{\n\t\t\t\tok = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\ti++;\n\t\t}\n\n\t\tif (! ok && strpbrk(p, \"0123456789\") == p &&\n\t\t    sscanf(p, \"%d/%d\", &n, &m) == 2) {\n\t\t\tif (scale_str) free(scale_str);\n\t\t\tscale_str = strdup(p);\n\t\t} else if (ok) {\n\t\t\tif (0 && strstr(p, \"display=\") == p) {\n\t\t\t\tif (use_dpy) free(use_dpy);\n\t\t\t\tuse_dpy = strdup(p + strlen(\"display=\"));\n\t\t\t} else if (0 && strstr(p, \"auth=\") == p) {\n\t\t\t\tif (auth_file) free(auth_file);\n\t\t\t\tauth_file = strdup(p + strlen(\"auth=\"));\n\t\t\t} else if (0 && !strcmp(p, \"shared\")) {\n\t\t\t\tshared = 1;\n\t\t\t} else if (strstr(p, \"scale=\") == p) {\n\t\t\t\tif (scale_str) free(scale_str);\n\t\t\t\tscale_str = strdup(p + strlen(\"scale=\"));\n\t\t\t} else if (strstr(p, \"scale_cursor=\") == p ||\n\t\t\t    strstr(p, \"sc=\") == p) {\n\t\t\t\tif (scale_cursor_str) free(scale_cursor_str);\n\t\t\t\tq = strchr(p, '=') + 1;\n\t\t\t\tscale_cursor_str = strdup(q);\n\t\t\t} else if (strstr(p, \"rotate=\") == p ||\n\t\t\t    strstr(p, \"ro=\") == p) {\n\t\t\t\tif (rotating_str) free(rotating_str);\n\t\t\t\tq = strchr(p, '=') + 1;\n\t\t\t\trotating_str = strdup(q);\n\t\t\t} else if (!strcmp(p, \"solid\") || !strcmp(p, \"so\")) {\n\t\t\t\tuse_solid_bg = 1;\n\t\t\t\tif (!solid_str) {\n\t\t\t\t\tsolid_str = strdup(solid_default);\n\t\t\t\t}\n\t\t\t} else if (!strcmp(p, \"viewonly\") || !strcmp(p, \"vo\")) {\n\t\t\t\tview_only = 1;\n\t\t\t} else if (strstr(p, \"solid=\") == p ||\n\t\t\t    strstr(p, \"so=\") == p) {\n\t\t\t\tuse_solid_bg = 1;\n\t\t\t\tif (solid_str) free(solid_str);\n\t\t\t\tq = strchr(p, '=') + 1;\n\t\t\t\tif (!strcmp(q, \"R\")) {\n\t\t\t\t\tsolid_str = strdup(\"root:\");\n\t\t\t\t} else {\n\t\t\t\t\tsolid_str = strdup(q);\n\t\t\t\t}\n\t\t\t} else if (strstr(p, \"id=\") == p) {\n\t\t\t\tunsigned long win;\n\t\t\t\tq = p + strlen(\"id=\");\n\t\t\t\tif (strcmp(q, \"pick\")) {\n\t\t\t\t\tif (scan_hexdec(q, &win)) {\n\t\t\t\t\t\tsubwin = win;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else if (!strcmp(p, \"clear_mods\") ||\n\t\t\t    !strcmp(p, \"cm\")) {\n\t\t\t\tclear_mods = 1;\n\t\t\t} else if (!strcmp(p, \"clear_keys\") ||\n\t\t\t    !strcmp(p, \"ck\")) {\n\t\t\t\tclear_mods = 2;\n\t\t\t} else if (!strcmp(p, \"clear_all\") ||\n\t\t\t    !strcmp(p, \"ca\")) {\n\t\t\t\tclear_mods = 3;\n\t\t\t} else if (!strcmp(p, \"noncache\") ||\n\t\t\t    !strcmp(p, \"nc\")) {\n\t\t\t\tncache  = 0;\n\t\t\t\tncache0 = 0;\n\t\t\t} else if (strstr(p, \"nc=\") == p) {\n\t\t\t\tint n2 = atoi(p + strlen(\"nc=\"));\n\t\t\t\tif (nabs(n2) < nabs(ncache)) {\n\t\t\t\t\tif (ncache < 0) {\n\t\t\t\t\t\tncache = -nabs(n2);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tncache = nabs(n2);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else if (!strcmp(p, \"repeat\")) {\n\t\t\t\tno_autorepeat = 0;\n\t\t\t} else if (strstr(p, \"speeds=\") == p ||\n\t\t\t    strstr(p, \"sp=\") == p) {\n\t\t\t\tif (speeds_str) free(speeds_str);\n\t\t\t\tq = strchr(p, '=') + 1;\n\t\t\t\tspeeds_str = strdup(q);\n\t\t\t\tq = speeds_str;\n\t\t\t\twhile (*q != '\\0') {\n\t\t\t\t\tif (*q == '-') {\n\t\t\t\t\t\t*q = ',';\n\t\t\t\t\t}\n\t\t\t\t\tq++;\n\t\t\t\t}\n\t\t\t} else if (strstr(p, \"readtimeout=\") == p ||\n\t\t\t    strstr(p, \"rd=\") == p) {\n\t\t\t\tq = strchr(p, '=') + 1;\n\t\t\t\trfbMaxClientWait = atoi(q) * 1000;\n\t\t\t}\n\t\t} else {\n\t\t\trfbLog(\"skipping option: %s\\n\", p);\n\t\t}\n\t\tp = strtok(NULL, \",\");\n\t}\n\tfree(str);\n}"
  },
  {
    "function_name": "handle_one_http_request",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/user.c",
    "lines": "1168-1252",
    "snippet": "static void handle_one_http_request(void) {\n\trfbLog(\"handle_one_http_request: begin.\\n\");\n\tif (inetd || screen->httpPort == 0) {\n\t\tint port = find_free_port(5800, 5860);\n\t\tif (port) {\n\t\t\t/* mutex */\n\t\t\tscreen->httpPort = port;\n\t\t} else {\n\t\t\trfbLog(\"handle_one_http_request: no http port.\\n\");\n\t\t\tclean_up_exit(1);\n\t\t}\n\t}\n\tscreen->autoPort = FALSE;\n\tscreen->port = 0;\n\n\thttp_connections(1);\n\n\trfbInitServer(screen);\n\n\tif (!inetd) {\n\t\t/* XXX ipv6 */\n\t\tint conn = 0;\n\t\twhile (1) {\n\t\t\tif (0) fprintf(stderr, \"%d %d %d  %d\\n\", conn, screen->listenSock, screen->httpSock, screen->httpListenSock);\n\t\t\tusleep(10 * 1000);\n\t\t\trfbHttpCheckFds(screen);\n\t\t\tif (conn) {\n\t\t\t\tif (screen->httpSock < 0) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (screen->httpSock >= 0) {\n\t\t\t\t\tconn = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!screen->httpDir) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (screen->httpListenSock < 0) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\trfbLog(\"handle_one_http_request: finished.\\n\");\n\t\treturn;\n\t} else {\n\t\t/* inetd case: */\n#if LIBVNCSERVER_HAVE_FORK\n\t\tpid_t pid;\n\t\tint s_in = screen->inetdSock;\n\t\tif (s_in < 0) {\n\t\t\trfbLog(\"handle_one_http_request: inetdSock not set up.\\n\");\n\t\t\tclean_up_exit(1);\n\t\t}\n\t\tpid = fork();\n\t\tif (pid < 0) {\n\t\t\trfbLog(\"handle_one_http_request: could not fork.\\n\");\n\t\t\tclean_up_exit(1);\n\t\t} else if (pid > 0) {\n\t\t\tint status;\n\t\t\tpid_t pidw;\n\t\t\twhile (1) {\n\t\t\t\trfbHttpCheckFds(screen);\n\t\t\t\tpidw = waitpid(pid, &status, WNOHANG); \n\t\t\t\tif (pidw == pid && WIFEXITED(status)) {\n\t\t\t\t\tbreak;\n\t\t\t\t} else if (pidw < 0) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\trfbLog(\"handle_one_http_request: finished.\\n\");\n\t\t\treturn;\n\t\t} else {\n\t\t\tint sock = connect_tcp(\"127.0.0.1\", screen->httpPort);\n\t\t\tif (sock < 0) {\n\t\t\t\texit(1);\n\t\t\t}\n\t\t\traw_xfer(sock, s_in, s_in);\n\t\t\texit(0);\n\t\t}\n#else\n\t\trfbLog(\"handle_one_http_request: fork not supported.\\n\");\n\t\tclean_up_exit(1);\n#endif\n\t}\n}",
    "includes": [
      "#include \"avahi.h\"",
      "#include \"sslhelper.h\"",
      "#include \"remote.h\"",
      "#include \"cursor.h\"",
      "#include \"keyboard.h\"",
      "#include \"inet.h\"",
      "#include \"connections.h\"",
      "#include \"xwrappers.h\"",
      "#include \"sslhelper.h\"",
      "#include \"unixpw.h\"",
      "#include \"screen.h\"",
      "#include \"scan.h\"",
      "#include \"cleanup.h\"",
      "#include \"solid.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "int wait_for_client(int *argc, char** argv, int http);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "clean_up_exit",
          "args": [
            "1"
          ],
          "line": 1249
        },
        "resolved": true,
        "details": {
          "function_name": "clean_up_exit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/cleanup.c",
          "lines": "151-266",
          "snippet": "void clean_up_exit(int ret) {\n\tstatic int depth = 0;\n\texit_flag = 1;\n\n\tif (depth++ > 2) {\n\t\texit(ret);\n\t}\n\n\tif (icon_mode) {\n\t\tclean_icon_mode();\n\t}\n\n\t/* remove the shm areas: */\n\tclean_shm(0);\n\n\tstop_stunnel();\n\tif (use_openssl) {\n\t\tssl_helper_pid(0, 0);\t/* killall */\n\t}\n\n\tif (ssh_pid > 0) {\n\t\tkill(ssh_pid, SIGTERM);\n\t\tssh_pid = 0;\n\t}\n\n#ifdef MACOSX\n\tif (client_connect_file) {\n\t\tif (strstr(client_connect_file, \"/tmp/x11vnc-macosx-remote\")\n\t\t    == client_connect_file) {\n\t\t\tunlink(client_connect_file);\n\t\t}\n\t}\n\tif (macosx_console) {\n\t\tmacosxCG_fini();\n\t}\n#endif\n\n\tif (pipeinput_fh != NULL) {\n\t\tpclose(pipeinput_fh);\n\t\tpipeinput_fh = NULL;\n\t}\n\n\tshutdown_uinput();\n\n\tif (unix_sock) {\n\t\tif (unix_sock_fd >= 0) {\n\t\t\trfbLog(\"deleting unix sock: %s\\n\", unix_sock);\n\t\t\tclose(unix_sock_fd);\n\t\t\tunix_sock_fd = -1;\n\t\t\tunlink(unix_sock);\n\t\t}\n\t}\n\n\tif (! dpy) {\t/* raw_rb hack */\n\t\tif (rm_flagfile) {\n\t\t\tunlink(rm_flagfile);\n\t\t\trm_flagfile = NULL;\n\t\t}\n\t\texit(ret);\n\t}\n\n\t/* X keyboard cleanups */\n\tdelete_added_keycodes(0);\n\n\t/* remove all created XInput2 devices */\n\tif(use_multipointer)\n\t    removeAllMDs(dpy);\n\n\tif (clear_mods == 1) {\n\t\tclear_modifiers(0);\n\t} else if (clear_mods == 2) {\n\t\tclear_keys();\n\t} else if (clear_mods == 3) {\n\t\tclear_keys();\n\t\tclear_locks();\n\t}\n\n\tif (no_autorepeat) {\n\t\tautorepeat(1, 0);\n\t}\n\tif (use_solid_bg) {\n\t\tsolid_bg(1);\n\t}\n\tif (ncache || ncache0) {\n\t\tkde_no_animate(1);\n\t}\n\tX_LOCK;\n\tXTestDiscard_wr(dpy);\n#if HAVE_LIBXDAMAGE\n\tif (xdamage) {\n\t\tXDamageDestroy(dpy, xdamage);\n\t}\n#endif\n#if HAVE_LIBXTRAP\n\tif (trap_ctx) {\n\t\tXEFreeTC(trap_ctx);\n\t}\n#endif\n\t/* XXX rdpy_ctrl, etc. cannot close w/o blocking */\n\tXCloseDisplay_wr(dpy);\n\tX_UNLOCK;\n\n\tfflush(stderr);\n\n\tif (rm_flagfile) {\n\t\tunlink(rm_flagfile);\n\t\trm_flagfile = NULL;\n\t}\n\n\tif (avahi) {\n\t\tavahi_cleanup();\n\t\tfflush(stderr);\n\t}\n\n\texit(ret);\n}",
          "includes": [
            "#include \"xi2_devices.h\"",
            "#include \"uinput.h\"",
            "#include \"xevents.h\"",
            "#include \"xrecord.h\"",
            "#include \"screen.h\"",
            "#include \"avahi.h\"",
            "#include \"macosxCG.h\"",
            "#include \"macosx.h\"",
            "#include \"connections.h\"",
            "#include \"sslhelper.h\"",
            "#include \"sslcmds.h\"",
            "#include \"unixpw.h\"",
            "#include \"solid.h\"",
            "#include \"gui.h\"",
            "#include \"scan.h\"",
            "#include \"keyboard.h\"",
            "#include \"remote.h\"",
            "#include \"xdamage.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void clean_up_exit(int ret);",
            "int known_sigpipe_mode(char *s);",
            "static int exit_flag = 0;",
            "static void clean_icon_mode(void);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xi2_devices.h\"\n#include \"uinput.h\"\n#include \"xevents.h\"\n#include \"xrecord.h\"\n#include \"screen.h\"\n#include \"avahi.h\"\n#include \"macosxCG.h\"\n#include \"macosx.h\"\n#include \"connections.h\"\n#include \"sslhelper.h\"\n#include \"sslcmds.h\"\n#include \"unixpw.h\"\n#include \"solid.h\"\n#include \"gui.h\"\n#include \"scan.h\"\n#include \"keyboard.h\"\n#include \"remote.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nvoid clean_up_exit(int ret);\nint known_sigpipe_mode(char *s);\nstatic int exit_flag = 0;\nstatic void clean_icon_mode(void);\n\nvoid clean_up_exit(int ret) {\n\tstatic int depth = 0;\n\texit_flag = 1;\n\n\tif (depth++ > 2) {\n\t\texit(ret);\n\t}\n\n\tif (icon_mode) {\n\t\tclean_icon_mode();\n\t}\n\n\t/* remove the shm areas: */\n\tclean_shm(0);\n\n\tstop_stunnel();\n\tif (use_openssl) {\n\t\tssl_helper_pid(0, 0);\t/* killall */\n\t}\n\n\tif (ssh_pid > 0) {\n\t\tkill(ssh_pid, SIGTERM);\n\t\tssh_pid = 0;\n\t}\n\n#ifdef MACOSX\n\tif (client_connect_file) {\n\t\tif (strstr(client_connect_file, \"/tmp/x11vnc-macosx-remote\")\n\t\t    == client_connect_file) {\n\t\t\tunlink(client_connect_file);\n\t\t}\n\t}\n\tif (macosx_console) {\n\t\tmacosxCG_fini();\n\t}\n#endif\n\n\tif (pipeinput_fh != NULL) {\n\t\tpclose(pipeinput_fh);\n\t\tpipeinput_fh = NULL;\n\t}\n\n\tshutdown_uinput();\n\n\tif (unix_sock) {\n\t\tif (unix_sock_fd >= 0) {\n\t\t\trfbLog(\"deleting unix sock: %s\\n\", unix_sock);\n\t\t\tclose(unix_sock_fd);\n\t\t\tunix_sock_fd = -1;\n\t\t\tunlink(unix_sock);\n\t\t}\n\t}\n\n\tif (! dpy) {\t/* raw_rb hack */\n\t\tif (rm_flagfile) {\n\t\t\tunlink(rm_flagfile);\n\t\t\trm_flagfile = NULL;\n\t\t}\n\t\texit(ret);\n\t}\n\n\t/* X keyboard cleanups */\n\tdelete_added_keycodes(0);\n\n\t/* remove all created XInput2 devices */\n\tif(use_multipointer)\n\t    removeAllMDs(dpy);\n\n\tif (clear_mods == 1) {\n\t\tclear_modifiers(0);\n\t} else if (clear_mods == 2) {\n\t\tclear_keys();\n\t} else if (clear_mods == 3) {\n\t\tclear_keys();\n\t\tclear_locks();\n\t}\n\n\tif (no_autorepeat) {\n\t\tautorepeat(1, 0);\n\t}\n\tif (use_solid_bg) {\n\t\tsolid_bg(1);\n\t}\n\tif (ncache || ncache0) {\n\t\tkde_no_animate(1);\n\t}\n\tX_LOCK;\n\tXTestDiscard_wr(dpy);\n#if HAVE_LIBXDAMAGE\n\tif (xdamage) {\n\t\tXDamageDestroy(dpy, xdamage);\n\t}\n#endif\n#if HAVE_LIBXTRAP\n\tif (trap_ctx) {\n\t\tXEFreeTC(trap_ctx);\n\t}\n#endif\n\t/* XXX rdpy_ctrl, etc. cannot close w/o blocking */\n\tXCloseDisplay_wr(dpy);\n\tX_UNLOCK;\n\n\tfflush(stderr);\n\n\tif (rm_flagfile) {\n\t\tunlink(rm_flagfile);\n\t\trm_flagfile = NULL;\n\t}\n\n\tif (avahi) {\n\t\tavahi_cleanup();\n\t\tfflush(stderr);\n\t}\n\n\texit(ret);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"handle_one_http_request: fork not supported.\\n\""
          ],
          "line": 1248
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "raw_xfer",
          "args": [
            "sock",
            "s_in",
            "s_in"
          ],
          "line": 1244
        },
        "resolved": true,
        "details": {
          "function_name": "raw_xfer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/sslhelper.c",
          "lines": "4286-4373",
          "snippet": "void raw_xfer(int csock, int s_in, int s_out) {\n\tchar buf0[8192];\n\tint sz = 8192, n, m, status, db = 1;\n\tchar *buf;\n#ifdef FORK_OK\n\tpid_t par = getpid();\n\tpid_t pid = fork();\n\n\tbuf = buf0;\n\tif (vnc_redirect) {\n\t\t/* change buf size some direction. */\n\t}\n\n\tif (getenv(\"X11VNC_DEBUG_RAW_XFER\")) {\n\t\tdb = atoi(getenv(\"X11VNC_DEBUG_RAW_XFER\"));\n\t}\n\tif (pid < 0) {\n\t\texit(1);\n\t}\n\t/* this is for testing or special helper usage, no SSL just socket redir */\n\tif (pid) {\n\t\tif (db) rfbLog(\"raw_xfer start: %d -> %d/%d\\n\", csock, s_in, s_out);\n\n\t\twhile (1) {\n\t\t\tn = read(csock, buf, sz);\n\t\t\tif (n == 0 || (n < 0 && errno != EINTR) ) {\n\t\t\t\tbreak;\n\t\t\t} else if (n > 0) {\n\t\t\t\tint len = n;\n\t\t\t\tchar *src = buf;\n\t\t\t\tif (db > 1) write(2, buf, n);\n\t\t\t\twhile (len > 0) {\n\t\t\t\t\tm = write(s_out, src, len);\n\t\t\t\t\tif (m > 0) {\n\t\t\t\t\t\tsrc += m;\n\t\t\t\t\t\tlen -= m;\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tif (m < 0 && (errno == EINTR || errno == EAGAIN)) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\nif (db) rfbLog(\"raw_xfer bad write:  %d -> %d | %d/%d  errno=%d\\n\", csock, s_out, m, n, errno);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tusleep(250*1000);\n\t\tkill(pid, SIGTERM);\n\t\twaitpid(pid, &status, WNOHANG); \n\t\tif (db) rfbLog(\"raw_xfer done:  %d -> %d\\n\", csock, s_out);\n\n\t} else {\n\t\tif (db) usleep(50*1000);\n\t\tif (db) rfbLog(\"raw_xfer start: %d <- %d\\n\", csock, s_in);\n\n\t\twhile (1) {\n\t\t\tn = read(s_in, buf, sz);\n\t\t\tif (n == 0 || (n < 0 && errno != EINTR) ) {\n\t\t\t\tbreak;\n\t\t\t} else if (n > 0) {\n\t\t\t\tint len = n;\n\t\t\t\tchar *src = buf;\n\t\t\t\tif (db > 1) write(2, buf, n);\n\t\t\t\twhile (len > 0) {\n\t\t\t\t\tm = write(csock, src, len);\n\t\t\t\t\tif (m > 0) {\n\t\t\t\t\t\tsrc += m;\n\t\t\t\t\t\tlen -= m;\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tif (m < 0 && (errno == EINTR || errno == EAGAIN)) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\tif (db) rfbLog(\"raw_xfer bad write:  %d <- %d | %d/%d errno=%d\\n\", csock, s_in, m, n, errno);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tusleep(250*1000);\n\t\tkill(par, SIGTERM);\n\t\twaitpid(par, &status, WNOHANG); \n\t\tif (db) rfbLog(\"raw_xfer done:  %d <- %d\\n\", csock, s_in);\n\t}\n\tclose(csock);\n\tclose(s_in);\n\tclose(s_out);\n#endif\t/* FORK_OK */\n}",
          "includes": [
            "#include <openssl/rand.h>",
            "#include <openssl/err.h>",
            "#include <openssl/ssl.h>",
            "#include \"user.h\"",
            "#include \"unixpw.h\"",
            "#include \"sslcmds.h\"",
            "#include \"connections.h\"",
            "#include \"scan.h\"",
            "#include \"screen.h\"",
            "#include \"cleanup.h\"",
            "#include \"inet.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [
            "#define FORK_OK"
          ],
          "globals_used": [
            "void raw_xfer(int csock, int s_in, int s_out);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <openssl/rand.h>\n#include <openssl/err.h>\n#include <openssl/ssl.h>\n#include \"user.h\"\n#include \"unixpw.h\"\n#include \"sslcmds.h\"\n#include \"connections.h\"\n#include \"scan.h\"\n#include \"screen.h\"\n#include \"cleanup.h\"\n#include \"inet.h\"\n#include \"x11vnc.h\"\n\n#define FORK_OK\n\nvoid raw_xfer(int csock, int s_in, int s_out);\n\nvoid raw_xfer(int csock, int s_in, int s_out) {\n\tchar buf0[8192];\n\tint sz = 8192, n, m, status, db = 1;\n\tchar *buf;\n#ifdef FORK_OK\n\tpid_t par = getpid();\n\tpid_t pid = fork();\n\n\tbuf = buf0;\n\tif (vnc_redirect) {\n\t\t/* change buf size some direction. */\n\t}\n\n\tif (getenv(\"X11VNC_DEBUG_RAW_XFER\")) {\n\t\tdb = atoi(getenv(\"X11VNC_DEBUG_RAW_XFER\"));\n\t}\n\tif (pid < 0) {\n\t\texit(1);\n\t}\n\t/* this is for testing or special helper usage, no SSL just socket redir */\n\tif (pid) {\n\t\tif (db) rfbLog(\"raw_xfer start: %d -> %d/%d\\n\", csock, s_in, s_out);\n\n\t\twhile (1) {\n\t\t\tn = read(csock, buf, sz);\n\t\t\tif (n == 0 || (n < 0 && errno != EINTR) ) {\n\t\t\t\tbreak;\n\t\t\t} else if (n > 0) {\n\t\t\t\tint len = n;\n\t\t\t\tchar *src = buf;\n\t\t\t\tif (db > 1) write(2, buf, n);\n\t\t\t\twhile (len > 0) {\n\t\t\t\t\tm = write(s_out, src, len);\n\t\t\t\t\tif (m > 0) {\n\t\t\t\t\t\tsrc += m;\n\t\t\t\t\t\tlen -= m;\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tif (m < 0 && (errno == EINTR || errno == EAGAIN)) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\nif (db) rfbLog(\"raw_xfer bad write:  %d -> %d | %d/%d  errno=%d\\n\", csock, s_out, m, n, errno);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tusleep(250*1000);\n\t\tkill(pid, SIGTERM);\n\t\twaitpid(pid, &status, WNOHANG); \n\t\tif (db) rfbLog(\"raw_xfer done:  %d -> %d\\n\", csock, s_out);\n\n\t} else {\n\t\tif (db) usleep(50*1000);\n\t\tif (db) rfbLog(\"raw_xfer start: %d <- %d\\n\", csock, s_in);\n\n\t\twhile (1) {\n\t\t\tn = read(s_in, buf, sz);\n\t\t\tif (n == 0 || (n < 0 && errno != EINTR) ) {\n\t\t\t\tbreak;\n\t\t\t} else if (n > 0) {\n\t\t\t\tint len = n;\n\t\t\t\tchar *src = buf;\n\t\t\t\tif (db > 1) write(2, buf, n);\n\t\t\t\twhile (len > 0) {\n\t\t\t\t\tm = write(csock, src, len);\n\t\t\t\t\tif (m > 0) {\n\t\t\t\t\t\tsrc += m;\n\t\t\t\t\t\tlen -= m;\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tif (m < 0 && (errno == EINTR || errno == EAGAIN)) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\tif (db) rfbLog(\"raw_xfer bad write:  %d <- %d | %d/%d errno=%d\\n\", csock, s_in, m, n, errno);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tusleep(250*1000);\n\t\tkill(par, SIGTERM);\n\t\twaitpid(par, &status, WNOHANG); \n\t\tif (db) rfbLog(\"raw_xfer done:  %d <- %d\\n\", csock, s_in);\n\t}\n\tclose(csock);\n\tclose(s_in);\n\tclose(s_out);\n#endif\t/* FORK_OK */\n}"
        }
      },
      {
        "call_info": {
          "callee": "connect_tcp",
          "args": [
            "\"127.0.0.1\"",
            "screen->httpPort"
          ],
          "line": 1240
        },
        "resolved": true,
        "details": {
          "function_name": "connect_tcp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/inet.c",
          "lines": "716-893",
          "snippet": "int connect_tcp(char *host, int port) {\n\tdouble t0 = dnow();\n\tint fd = -1;\n\tint fail4 = noipv4;\n\tif (getenv(\"IPV4_FAILS\")) {\n\t\tfail4 = 2;\n\t}\n\n\trfbLog(\"connect_tcp: trying:   %s %d\\n\", host, port);\n\n\tif (fail4) {\n\t\tif (fail4 > 1) {\n\t\t\trfbLog(\"TESTING: IPV4_FAILS for connect_tcp.\\n\");\n\t\t}\n\t} else {\n\t\tfd = rfbConnectToTcpAddr(host, port);\n\t}\n\n\tif (fd >= 0) {\n\t\treturn fd;\n\t}\n\trfbLogPerror(\"connect_tcp: connection failed\");\n\n\tif (dnow() - t0 < 4.0) {\n\t\trfbLog(\"connect_tcp: re-trying %s %d\\n\", host, port);\n\t\tusleep (100 * 1000);\n\t\tif (!fail4) {\n\t\t\tfd = rfbConnectToTcpAddr(host, port);\n\t\t}\n\t\tif (fd < 0) {\n\t\t\trfbLogPerror(\"connect_tcp: connection failed\");\n\t\t}\n\t}\n\n\tif (fd < 0 && !noipv6) {\n#if X11VNC_IPV6\n\t\tint err;\n\t\tstruct addrinfo *ai;\n\t\tstruct addrinfo hints;\n\t\tchar service[32], *host2, *q;\n\n\t\trfbLog(\"connect_tcp: trying IPv6 %s %d\\n\", host, port);\n\n\t\tmemset(&hints, 0, sizeof(hints));\n\t\tsprintf(service, \"%d\", port);\n\n\t\thints.ai_family = AF_UNSPEC;\n\t\thints.ai_socktype = SOCK_STREAM;\n#ifdef AI_ADDRCONFIG\n\t\thints.ai_flags |= AI_ADDRCONFIG;\n#endif\n\t\tif(ipv6_ip(host)) {\n#ifdef AI_NUMERICHOST\n\t\t\trfbLog(\"connect_tcp[ipv6]: setting AI_NUMERICHOST for %s\\n\", host);\n\t\t\thints.ai_flags |= AI_NUMERICHOST;\n#endif\n\t\t}\n#ifdef AI_NUMERICSERV\n\t\thints.ai_flags |= AI_NUMERICSERV;\n#endif\n\n\t\tif (!strcmp(host, \"127.0.0.1\")) {\n\t\t\thost2 = strdup(\"::1\");\n\t\t} else if (host[0] == '[') {\n\t\t\thost2 = strdup(host+1);\n\t\t} else {\n\t\t\thost2 = strdup(host);\n\t\t}\n\t\tq = strrchr(host2, ']');\n\t\tif (q) {\n\t\t\t*q = '\\0';\n\t\t}\n\n\t\terr = getaddrinfo(host2, service, &hints, &ai);\n\t\tif (err != 0) {\n\t\t\trfbLog(\"connect_tcp[ipv6]: getaddrinfo[%d]: %s\\n\", err, gai_strerror(err));\n\t\t\tusleep(100 * 1000);\n\t\t\terr = getaddrinfo(host2, service, &hints, &ai);\n\t\t}\n\t\tfree(host2);\n\n\t\tif (err != 0) {\n\t\t\trfbLog(\"connect_tcp[ipv6]: getaddrinfo[%d]: %s\\n\", err, gai_strerror(err));\n\t\t} else {\n\t\t\tstruct addrinfo *ap = ai;\n\t\t\twhile (ap != NULL) {\n\t\t\t\tint sock;\n\n\t\t\t\tif (fail4) {\n\t\t\t\t\tstruct sockaddr_in6 *s6ptr;\n\t\t\t\t\tif (ap->ai_family != AF_INET6) {\n\t\t\t\t\t\trfbLog(\"connect_tcp[ipv6]: skipping AF_INET address under -noipv4\\n\");\n\t\t\t\t\t\tap = ap->ai_next;\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n#ifdef IN6_IS_ADDR_V4MAPPED\n\t\t\t\t\ts6ptr = (struct sockaddr_in6 *) ap->ai_addr;\n\t\t\t\t\tif (IN6_IS_ADDR_V4MAPPED(&(s6ptr->sin6_addr))) {\n\t\t\t\t\t\trfbLog(\"connect_tcp[ipv6]: skipping V4MAPPED address under -noipv4\\n\");\n\t\t\t\t\t\tap = ap->ai_next;\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n#endif\n\t\t\t\t}\n\n\t\t\t\tsock = socket(ap->ai_family, ap->ai_socktype, ap->ai_protocol);\n\n\t\t\t\tif (sock == -1) {\n\t\t\t\t\trfbLogPerror(\"connect_tcp[ipv6]: socket\");\n\t\t\t\t\tif (0) rfbLog(\"(Ignore the above error if this system is IPv4-only.)\\n\");\n\t\t\t\t} else {\n\t\t\t\t\tint res = -1, dmsg = 0;\n\t\t\t\t\tchar *s = ipv6_getipaddr(ap->ai_addr, ap->ai_addrlen);\n\t\t\t\t\tif (!s) s = strdup(\"unknown\");\n\n\t\t\t\t\trfbLog(\"connect_tcp[ipv6]: trying sock=%d fam=%d proto=%d using %s\\n\",\n\t\t\t\t\t    sock, ap->ai_family, ap->ai_protocol, s);\n\t\t\t\t\tres = connect(sock, ap->ai_addr, ap->ai_addrlen);\n#if defined(SOL_IPV6) && defined(IPV6_V6ONLY)\n\t\t\t\t\tif (res != 0) {\n\t\t\t\t\t\tint zero = 0;\n\t\t\t\t\t\trfbLogPerror(\"connect_tcp[ipv6]: connect\");\n\t\t\t\t\t\tdmsg = 1;\n\t\t\t\t\t\tif (setsockopt(sock, SOL_IPV6, IPV6_V6ONLY, (char *)&zero, sizeof(zero)) == 0) {\n\t\t\t\t\t\t\trfbLog(\"connect_tcp[ipv6]: trying again with IPV6_V6ONLY=0\\n\");\n\t\t\t\t\t\t\tres = connect(sock, ap->ai_addr, ap->ai_addrlen);\n\t\t\t\t\t\t\tdmsg = 0;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\trfbLogPerror(\"connect_tcp[ipv6]: setsockopt IPV6_V6ONLY\");\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n#endif\n\t\t\t\t\tif (res == 0) {\n\t\t\t\t\t\trfbLog(\"connect_tcp[ipv6]: connect OK\\n\");\n\t\t\t\t\t\tfd = sock;\n\t\t\t\t\t\tif (!ipv6_client_ip_str) {\n\t\t\t\t\t\t\tipv6_client_ip_str = strdup(s);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tfree(s);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif (!dmsg) rfbLogPerror(\"connect_tcp[ipv6]: connect\");\n\t\t\t\t\t\tclose(sock);\n\t\t\t\t\t}\n\t\t\t\t\tfree(s);\n\t\t\t\t}\n\t\t\t\tap = ap->ai_next;\n\t\t\t}\n\t\t\tfreeaddrinfo(ai);\n\t\t}\n#endif\n\t}\n\tif (fd < 0 && !fail4) {\n\t\t/* this is a kludge for IPv4-only machines getting v4mapped string. */\n\t\tchar *q, *host2;\n\t\tif (host[0] == '[') {\n\t\t\thost2 = strdup(host+1);\n\t\t} else {\n\t\t\thost2 = strdup(host);\n\t\t}\n\t\tq = strrchr(host2, ']');\n\t\tif (q) {\n\t\t\t*q = '\\0';\n\t\t}\n\t\tif (strstr(host2, \"::ffff:\") == host2 || strstr(host2, \"::FFFF:\") == host2) {\n\t\t\tchar *host3 = host2 + strlen(\"::ffff:\");\n\t\t\tif (dotted_ip(host3, 0)) {\n\t\t\t\trfbLog(\"connect_tcp[ipv4]: trying fallback to IPv4 for %s\\n\", host2);\n\t\t\t\tfd = rfbConnectToTcpAddr(host3, port);\n\t\t\t\tif (fd < 0) {\n\t\t\t\t\trfbLogPerror(\"connect_tcp[ipv4]: connection failed\");\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfree(host2);\n\t}\n\treturn fd;\n}",
          "includes": [
            "#include <sys/un.h>",
            "#include \"sslhelper.h\"",
            "#include \"unixpw.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "char *host2ip(char *host);",
            "int ipv6_ip(char *host);",
            "int get_remote_port(int sock);",
            "int get_local_port(int sock);",
            "char *get_remote_host(int sock);",
            "char *get_local_host(int sock);",
            "int listen6(int port);",
            "int accept_unix(int s);",
            "int connect_tcp(char *host, int port);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/un.h>\n#include \"sslhelper.h\"\n#include \"unixpw.h\"\n#include \"x11vnc.h\"\n\nchar *host2ip(char *host);\nint ipv6_ip(char *host);\nint get_remote_port(int sock);\nint get_local_port(int sock);\nchar *get_remote_host(int sock);\nchar *get_local_host(int sock);\nint listen6(int port);\nint accept_unix(int s);\nint connect_tcp(char *host, int port);\n\nint connect_tcp(char *host, int port) {\n\tdouble t0 = dnow();\n\tint fd = -1;\n\tint fail4 = noipv4;\n\tif (getenv(\"IPV4_FAILS\")) {\n\t\tfail4 = 2;\n\t}\n\n\trfbLog(\"connect_tcp: trying:   %s %d\\n\", host, port);\n\n\tif (fail4) {\n\t\tif (fail4 > 1) {\n\t\t\trfbLog(\"TESTING: IPV4_FAILS for connect_tcp.\\n\");\n\t\t}\n\t} else {\n\t\tfd = rfbConnectToTcpAddr(host, port);\n\t}\n\n\tif (fd >= 0) {\n\t\treturn fd;\n\t}\n\trfbLogPerror(\"connect_tcp: connection failed\");\n\n\tif (dnow() - t0 < 4.0) {\n\t\trfbLog(\"connect_tcp: re-trying %s %d\\n\", host, port);\n\t\tusleep (100 * 1000);\n\t\tif (!fail4) {\n\t\t\tfd = rfbConnectToTcpAddr(host, port);\n\t\t}\n\t\tif (fd < 0) {\n\t\t\trfbLogPerror(\"connect_tcp: connection failed\");\n\t\t}\n\t}\n\n\tif (fd < 0 && !noipv6) {\n#if X11VNC_IPV6\n\t\tint err;\n\t\tstruct addrinfo *ai;\n\t\tstruct addrinfo hints;\n\t\tchar service[32], *host2, *q;\n\n\t\trfbLog(\"connect_tcp: trying IPv6 %s %d\\n\", host, port);\n\n\t\tmemset(&hints, 0, sizeof(hints));\n\t\tsprintf(service, \"%d\", port);\n\n\t\thints.ai_family = AF_UNSPEC;\n\t\thints.ai_socktype = SOCK_STREAM;\n#ifdef AI_ADDRCONFIG\n\t\thints.ai_flags |= AI_ADDRCONFIG;\n#endif\n\t\tif(ipv6_ip(host)) {\n#ifdef AI_NUMERICHOST\n\t\t\trfbLog(\"connect_tcp[ipv6]: setting AI_NUMERICHOST for %s\\n\", host);\n\t\t\thints.ai_flags |= AI_NUMERICHOST;\n#endif\n\t\t}\n#ifdef AI_NUMERICSERV\n\t\thints.ai_flags |= AI_NUMERICSERV;\n#endif\n\n\t\tif (!strcmp(host, \"127.0.0.1\")) {\n\t\t\thost2 = strdup(\"::1\");\n\t\t} else if (host[0] == '[') {\n\t\t\thost2 = strdup(host+1);\n\t\t} else {\n\t\t\thost2 = strdup(host);\n\t\t}\n\t\tq = strrchr(host2, ']');\n\t\tif (q) {\n\t\t\t*q = '\\0';\n\t\t}\n\n\t\terr = getaddrinfo(host2, service, &hints, &ai);\n\t\tif (err != 0) {\n\t\t\trfbLog(\"connect_tcp[ipv6]: getaddrinfo[%d]: %s\\n\", err, gai_strerror(err));\n\t\t\tusleep(100 * 1000);\n\t\t\terr = getaddrinfo(host2, service, &hints, &ai);\n\t\t}\n\t\tfree(host2);\n\n\t\tif (err != 0) {\n\t\t\trfbLog(\"connect_tcp[ipv6]: getaddrinfo[%d]: %s\\n\", err, gai_strerror(err));\n\t\t} else {\n\t\t\tstruct addrinfo *ap = ai;\n\t\t\twhile (ap != NULL) {\n\t\t\t\tint sock;\n\n\t\t\t\tif (fail4) {\n\t\t\t\t\tstruct sockaddr_in6 *s6ptr;\n\t\t\t\t\tif (ap->ai_family != AF_INET6) {\n\t\t\t\t\t\trfbLog(\"connect_tcp[ipv6]: skipping AF_INET address under -noipv4\\n\");\n\t\t\t\t\t\tap = ap->ai_next;\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n#ifdef IN6_IS_ADDR_V4MAPPED\n\t\t\t\t\ts6ptr = (struct sockaddr_in6 *) ap->ai_addr;\n\t\t\t\t\tif (IN6_IS_ADDR_V4MAPPED(&(s6ptr->sin6_addr))) {\n\t\t\t\t\t\trfbLog(\"connect_tcp[ipv6]: skipping V4MAPPED address under -noipv4\\n\");\n\t\t\t\t\t\tap = ap->ai_next;\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n#endif\n\t\t\t\t}\n\n\t\t\t\tsock = socket(ap->ai_family, ap->ai_socktype, ap->ai_protocol);\n\n\t\t\t\tif (sock == -1) {\n\t\t\t\t\trfbLogPerror(\"connect_tcp[ipv6]: socket\");\n\t\t\t\t\tif (0) rfbLog(\"(Ignore the above error if this system is IPv4-only.)\\n\");\n\t\t\t\t} else {\n\t\t\t\t\tint res = -1, dmsg = 0;\n\t\t\t\t\tchar *s = ipv6_getipaddr(ap->ai_addr, ap->ai_addrlen);\n\t\t\t\t\tif (!s) s = strdup(\"unknown\");\n\n\t\t\t\t\trfbLog(\"connect_tcp[ipv6]: trying sock=%d fam=%d proto=%d using %s\\n\",\n\t\t\t\t\t    sock, ap->ai_family, ap->ai_protocol, s);\n\t\t\t\t\tres = connect(sock, ap->ai_addr, ap->ai_addrlen);\n#if defined(SOL_IPV6) && defined(IPV6_V6ONLY)\n\t\t\t\t\tif (res != 0) {\n\t\t\t\t\t\tint zero = 0;\n\t\t\t\t\t\trfbLogPerror(\"connect_tcp[ipv6]: connect\");\n\t\t\t\t\t\tdmsg = 1;\n\t\t\t\t\t\tif (setsockopt(sock, SOL_IPV6, IPV6_V6ONLY, (char *)&zero, sizeof(zero)) == 0) {\n\t\t\t\t\t\t\trfbLog(\"connect_tcp[ipv6]: trying again with IPV6_V6ONLY=0\\n\");\n\t\t\t\t\t\t\tres = connect(sock, ap->ai_addr, ap->ai_addrlen);\n\t\t\t\t\t\t\tdmsg = 0;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\trfbLogPerror(\"connect_tcp[ipv6]: setsockopt IPV6_V6ONLY\");\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n#endif\n\t\t\t\t\tif (res == 0) {\n\t\t\t\t\t\trfbLog(\"connect_tcp[ipv6]: connect OK\\n\");\n\t\t\t\t\t\tfd = sock;\n\t\t\t\t\t\tif (!ipv6_client_ip_str) {\n\t\t\t\t\t\t\tipv6_client_ip_str = strdup(s);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tfree(s);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif (!dmsg) rfbLogPerror(\"connect_tcp[ipv6]: connect\");\n\t\t\t\t\t\tclose(sock);\n\t\t\t\t\t}\n\t\t\t\t\tfree(s);\n\t\t\t\t}\n\t\t\t\tap = ap->ai_next;\n\t\t\t}\n\t\t\tfreeaddrinfo(ai);\n\t\t}\n#endif\n\t}\n\tif (fd < 0 && !fail4) {\n\t\t/* this is a kludge for IPv4-only machines getting v4mapped string. */\n\t\tchar *q, *host2;\n\t\tif (host[0] == '[') {\n\t\t\thost2 = strdup(host+1);\n\t\t} else {\n\t\t\thost2 = strdup(host);\n\t\t}\n\t\tq = strrchr(host2, ']');\n\t\tif (q) {\n\t\t\t*q = '\\0';\n\t\t}\n\t\tif (strstr(host2, \"::ffff:\") == host2 || strstr(host2, \"::FFFF:\") == host2) {\n\t\t\tchar *host3 = host2 + strlen(\"::ffff:\");\n\t\t\tif (dotted_ip(host3, 0)) {\n\t\t\t\trfbLog(\"connect_tcp[ipv4]: trying fallback to IPv4 for %s\\n\", host2);\n\t\t\t\tfd = rfbConnectToTcpAddr(host3, port);\n\t\t\t\tif (fd < 0) {\n\t\t\t\t\trfbLogPerror(\"connect_tcp[ipv4]: connection failed\");\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfree(host2);\n\t}\n\treturn fd;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"handle_one_http_request: finished.\\n\""
          ],
          "line": 1237
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WIFEXITED",
          "args": [
            "status"
          ],
          "line": 1231
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "waitpid",
          "args": [
            "pid",
            "&status",
            "WNOHANG"
          ],
          "line": 1230
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbHttpCheckFds",
          "args": [
            "screen"
          ],
          "line": 1229
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"handle_one_http_request: could not fork.\\n\""
          ],
          "line": 1223
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fork",
          "args": [],
          "line": 1221
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"handle_one_http_request: inetdSock not set up.\\n\""
          ],
          "line": 1218
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"handle_one_http_request: finished.\\n\""
          ],
          "line": 1210
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbHttpCheckFds",
          "args": [
            "screen"
          ],
          "line": 1193
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "usleep",
          "args": [
            "10 * 1000"
          ],
          "line": 1192
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"%d %d %d  %d\\n\"",
            "conn",
            "screen->listenSock",
            "screen->httpSock",
            "screen->httpListenSock"
          ],
          "line": 1191
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbInitServer",
          "args": [
            "screen"
          ],
          "line": 1185
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "http_connections",
          "args": [
            "1"
          ],
          "line": 1183
        },
        "resolved": true,
        "details": {
          "function_name": "http_connections",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/remote.c",
          "lines": "496-564",
          "snippet": "void http_connections(int on) {\n\tif (!screen) {\n\t\treturn;\n\t}\n\tif (on) {\n\t\trfbLog(\"http_connections: turning on http service.\\n\");\n\n\t\tif (inetd && use_openssl) {\n\t\t\t/*\n\t\t\t * try to work around rapid fire https requests\n\t\t\t * in inetd mode... ugh.\n\t\t\t */\n\t\t\tif (screen->httpPort == 0) {\n\t\t\t\tint port = find_free_port(5800, 5850);\n\t\t\t\tif (port) {\n\t\t\t\t\t/* mutex */\n\t\t\t\t\tscreen->httpPort = port;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tscreen->httpInitDone = FALSE;\n\t\tif (check_httpdir()) {\n\t\t\tint fd6 = -1;\n\t\t\tchar *save = listen_str6;\n\n\t\t\tscreen->httpDir = http_dir;\n\n\t\t\trfb_http_init_sockets();\n\n\t\t\tif (getenv(\"X11VNC_HTTP_LISTEN_LOCALHOST\")) {\n\t\t\t\tlisten_str6 = \"localhost\";\n\t\t\t}\n\n\t\t\tif (screen->httpPort != 0 && screen->httpListenSock < 0) {\n\t\t\t\trfbLog(\"http_connections: failed to listen on http port: %d\\n\", screen->httpPort);\n\t\t\t\tif (ipv6_listen) {\n\t\t\t\t\tfd6 = listen6(screen->httpPort);\n\t\t\t\t}\n\t\t\t\tif (fd6 < 0) {\n\t\t\t\t\tclean_up_exit(1);\n\t\t\t\t}\n\t\t\t\trfbLog(\"http_connections: trying IPv6 only mode.\\n\");\n\t\t\t}\n\t\t\tif (ipv6_listen && screen->httpPort > 0) {\n\t\t\t\tif (fd6 < 0) {\n\t\t\t\t\tfd6 = listen6(screen->httpPort);\n\t\t\t\t}\n\t\t\t\tipv6_http_fd = fd6;\n\t\t\t\tif (ipv6_http_fd >= 0) {\n\t\t\t\t\trfbLog(\"http_connections: Listening %s on IPv6 port %d (socket %d)\\n\",\n\t\t\t\t\t    screen->httpListenSock < 0 ? \"only\" : \"also\",\n\t\t\t\t\t    screen->httpPort, ipv6_http_fd);\n\t\t\t\t}\n\t\t\t}\n\t\t\tlisten_str6 = save;\n\t\t}\n\t} else {\n\t\trfbLog(\"http_connections: turning off http service.\\n\");\n\t\tif (screen->httpListenSock > -1) {\n\t\t\tclose(screen->httpListenSock);\n\t\t\tscreen->httpListenSock = -1;\n\t\t}\n\t\tscreen->httpDir = NULL;\n\t\tif (ipv6_http_fd >= 0) {\n\t\t\tclose(ipv6_http_fd);\n\t\t\tipv6_http_fd = -1;\n\t\t}\n\t}\n}",
          "includes": [
            "#include \"sslhelper.h\"",
            "#include \"avahi.h\"",
            "#include \"userinput.h\"",
            "#include \"uinput.h\"",
            "#include \"unixpw.h\"",
            "#include \"selection.h\"",
            "#include \"keyboard.h\"",
            "#include \"userinput.h\"",
            "#include \"cursor.h\"",
            "#include \"pointer.h\"",
            "#include \"connections.h\"",
            "#include \"scan.h\"",
            "#include \"rates.h\"",
            "#include \"user.h\"",
            "#include \"solid.h\"",
            "#include \"gui.h\"",
            "#include \"cleanup.h\"",
            "#include \"screen.h\"",
            "#include \"win_utils.h\"",
            "#include \"xkb_bell.h\"",
            "#include \"xrecord.h\"",
            "#include \"xdamage.h\"",
            "#include \"xrandr.h\"",
            "#include \"xinerama.h\"",
            "#include \"xevents.h\"",
            "#include \"xwrappers.h\"",
            "#include \"inet.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int check_httpdir(void);",
            "void http_connections(int on);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sslhelper.h\"\n#include \"avahi.h\"\n#include \"userinput.h\"\n#include \"uinput.h\"\n#include \"unixpw.h\"\n#include \"selection.h\"\n#include \"keyboard.h\"\n#include \"userinput.h\"\n#include \"cursor.h\"\n#include \"pointer.h\"\n#include \"connections.h\"\n#include \"scan.h\"\n#include \"rates.h\"\n#include \"user.h\"\n#include \"solid.h\"\n#include \"gui.h\"\n#include \"cleanup.h\"\n#include \"screen.h\"\n#include \"win_utils.h\"\n#include \"xkb_bell.h\"\n#include \"xrecord.h\"\n#include \"xdamage.h\"\n#include \"xrandr.h\"\n#include \"xinerama.h\"\n#include \"xevents.h\"\n#include \"xwrappers.h\"\n#include \"inet.h\"\n#include \"x11vnc.h\"\n\nint check_httpdir(void);\nvoid http_connections(int on);\n\nvoid http_connections(int on) {\n\tif (!screen) {\n\t\treturn;\n\t}\n\tif (on) {\n\t\trfbLog(\"http_connections: turning on http service.\\n\");\n\n\t\tif (inetd && use_openssl) {\n\t\t\t/*\n\t\t\t * try to work around rapid fire https requests\n\t\t\t * in inetd mode... ugh.\n\t\t\t */\n\t\t\tif (screen->httpPort == 0) {\n\t\t\t\tint port = find_free_port(5800, 5850);\n\t\t\t\tif (port) {\n\t\t\t\t\t/* mutex */\n\t\t\t\t\tscreen->httpPort = port;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tscreen->httpInitDone = FALSE;\n\t\tif (check_httpdir()) {\n\t\t\tint fd6 = -1;\n\t\t\tchar *save = listen_str6;\n\n\t\t\tscreen->httpDir = http_dir;\n\n\t\t\trfb_http_init_sockets();\n\n\t\t\tif (getenv(\"X11VNC_HTTP_LISTEN_LOCALHOST\")) {\n\t\t\t\tlisten_str6 = \"localhost\";\n\t\t\t}\n\n\t\t\tif (screen->httpPort != 0 && screen->httpListenSock < 0) {\n\t\t\t\trfbLog(\"http_connections: failed to listen on http port: %d\\n\", screen->httpPort);\n\t\t\t\tif (ipv6_listen) {\n\t\t\t\t\tfd6 = listen6(screen->httpPort);\n\t\t\t\t}\n\t\t\t\tif (fd6 < 0) {\n\t\t\t\t\tclean_up_exit(1);\n\t\t\t\t}\n\t\t\t\trfbLog(\"http_connections: trying IPv6 only mode.\\n\");\n\t\t\t}\n\t\t\tif (ipv6_listen && screen->httpPort > 0) {\n\t\t\t\tif (fd6 < 0) {\n\t\t\t\t\tfd6 = listen6(screen->httpPort);\n\t\t\t\t}\n\t\t\t\tipv6_http_fd = fd6;\n\t\t\t\tif (ipv6_http_fd >= 0) {\n\t\t\t\t\trfbLog(\"http_connections: Listening %s on IPv6 port %d (socket %d)\\n\",\n\t\t\t\t\t    screen->httpListenSock < 0 ? \"only\" : \"also\",\n\t\t\t\t\t    screen->httpPort, ipv6_http_fd);\n\t\t\t\t}\n\t\t\t}\n\t\t\tlisten_str6 = save;\n\t\t}\n\t} else {\n\t\trfbLog(\"http_connections: turning off http service.\\n\");\n\t\tif (screen->httpListenSock > -1) {\n\t\t\tclose(screen->httpListenSock);\n\t\t\tscreen->httpListenSock = -1;\n\t\t}\n\t\tscreen->httpDir = NULL;\n\t\tif (ipv6_http_fd >= 0) {\n\t\t\tclose(ipv6_http_fd);\n\t\t\tipv6_http_fd = -1;\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"handle_one_http_request: no http port.\\n\""
          ],
          "line": 1176
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "find_free_port",
          "args": [
            "5800",
            "5860"
          ],
          "line": 1171
        },
        "resolved": true,
        "details": {
          "function_name": "find_free_port6",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/inet.c",
          "lines": "431-447",
          "snippet": "int find_free_port6(int start, int end) {\n\tint port;\n\tif (start <= 0) {\n\t\tstart = 1024;\n\t}\n\tif (end <= 0) {\n\t\tend = 65530;\n\t}\n\tfor (port = start; port <= end; port++)  {\n\t\tint sock = listen6(port);\n\t\tif (sock >= 0) {\n\t\t\tclose(sock);\n\t\t\treturn port;\n\t\t}\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include <sys/un.h>",
            "#include \"sslhelper.h\"",
            "#include \"unixpw.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int get_remote_port(int sock);",
            "int get_local_port(int sock);",
            "char *get_remote_host(int sock);",
            "char *get_local_host(int sock);",
            "int find_free_port(int start, int end);",
            "int find_free_port6(int start, int end);",
            "int listen6(int port);",
            "int connect_tcp(char *host, int port);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/un.h>\n#include \"sslhelper.h\"\n#include \"unixpw.h\"\n#include \"x11vnc.h\"\n\nint get_remote_port(int sock);\nint get_local_port(int sock);\nchar *get_remote_host(int sock);\nchar *get_local_host(int sock);\nint find_free_port(int start, int end);\nint find_free_port6(int start, int end);\nint listen6(int port);\nint connect_tcp(char *host, int port);\n\nint find_free_port6(int start, int end) {\n\tint port;\n\tif (start <= 0) {\n\t\tstart = 1024;\n\t}\n\tif (end <= 0) {\n\t\tend = 65530;\n\t}\n\tfor (port = start; port <= end; port++)  {\n\t\tint sock = listen6(port);\n\t\tif (sock >= 0) {\n\t\t\tclose(sock);\n\t\t\treturn port;\n\t\t}\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"handle_one_http_request: begin.\\n\""
          ],
          "line": 1169
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"avahi.h\"\n#include \"sslhelper.h\"\n#include \"remote.h\"\n#include \"cursor.h\"\n#include \"keyboard.h\"\n#include \"inet.h\"\n#include \"connections.h\"\n#include \"xwrappers.h\"\n#include \"sslhelper.h\"\n#include \"unixpw.h\"\n#include \"screen.h\"\n#include \"scan.h\"\n#include \"cleanup.h\"\n#include \"solid.h\"\n#include \"x11vnc.h\"\n\nint wait_for_client(int *argc, char** argv, int http);\n\nstatic void handle_one_http_request(void) {\n\trfbLog(\"handle_one_http_request: begin.\\n\");\n\tif (inetd || screen->httpPort == 0) {\n\t\tint port = find_free_port(5800, 5860);\n\t\tif (port) {\n\t\t\t/* mutex */\n\t\t\tscreen->httpPort = port;\n\t\t} else {\n\t\t\trfbLog(\"handle_one_http_request: no http port.\\n\");\n\t\t\tclean_up_exit(1);\n\t\t}\n\t}\n\tscreen->autoPort = FALSE;\n\tscreen->port = 0;\n\n\thttp_connections(1);\n\n\trfbInitServer(screen);\n\n\tif (!inetd) {\n\t\t/* XXX ipv6 */\n\t\tint conn = 0;\n\t\twhile (1) {\n\t\t\tif (0) fprintf(stderr, \"%d %d %d  %d\\n\", conn, screen->listenSock, screen->httpSock, screen->httpListenSock);\n\t\t\tusleep(10 * 1000);\n\t\t\trfbHttpCheckFds(screen);\n\t\t\tif (conn) {\n\t\t\t\tif (screen->httpSock < 0) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (screen->httpSock >= 0) {\n\t\t\t\t\tconn = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!screen->httpDir) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (screen->httpListenSock < 0) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\trfbLog(\"handle_one_http_request: finished.\\n\");\n\t\treturn;\n\t} else {\n\t\t/* inetd case: */\n#if LIBVNCSERVER_HAVE_FORK\n\t\tpid_t pid;\n\t\tint s_in = screen->inetdSock;\n\t\tif (s_in < 0) {\n\t\t\trfbLog(\"handle_one_http_request: inetdSock not set up.\\n\");\n\t\t\tclean_up_exit(1);\n\t\t}\n\t\tpid = fork();\n\t\tif (pid < 0) {\n\t\t\trfbLog(\"handle_one_http_request: could not fork.\\n\");\n\t\t\tclean_up_exit(1);\n\t\t} else if (pid > 0) {\n\t\t\tint status;\n\t\t\tpid_t pidw;\n\t\t\twhile (1) {\n\t\t\t\trfbHttpCheckFds(screen);\n\t\t\t\tpidw = waitpid(pid, &status, WNOHANG); \n\t\t\t\tif (pidw == pid && WIFEXITED(status)) {\n\t\t\t\t\tbreak;\n\t\t\t\t} else if (pidw < 0) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\trfbLog(\"handle_one_http_request: finished.\\n\");\n\t\t\treturn;\n\t\t} else {\n\t\t\tint sock = connect_tcp(\"127.0.0.1\", screen->httpPort);\n\t\t\tif (sock < 0) {\n\t\t\t\texit(1);\n\t\t\t}\n\t\t\traw_xfer(sock, s_in, s_in);\n\t\t\texit(0);\n\t\t}\n#else\n\t\trfbLog(\"handle_one_http_request: fork not supported.\\n\");\n\t\tclean_up_exit(1);\n#endif\n\t}\n}"
  },
  {
    "function_name": "custom_passwd_check",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/user.c",
    "lines": "1130-1166",
    "snippet": "rfbBool custom_passwd_check(rfbClientPtr cl, const char *response, int len) {\n\tchar *input, *cmd;\n\tchar num[16];\n\tint j, i, n, rc;\n\n\trfbLog(\"custom_passwd_check: len=%d\\n\", len);\n\n\tif (!passwdfile || strstr(passwdfile, \"custom:\") != passwdfile) {\n\t\treturn FALSE;\n\t}\n\tcmd = passwdfile + strlen(\"custom:\");\n\n\tsprintf(num, \"%d\\n\", len);\n\n\tinput = (char *) malloc(2 * len + 16 + 1);\n\t\n\tinput[0] = '\\0';\n\tstrcat(input, num);\n\tn = strlen(num);\n\n\tj = n;\n\tfor (i=0; i < len; i++) {\n\t\tinput[j] = cl->authChallenge[i];\n\t\tj++;\n\t}\n\tfor (i=0; i < len; i++) {\n\t\tinput[j] = response[i];\n\t\tj++;\n\t}\n\trc = run_user_command(cmd, cl, \"custom_passwd\", input, n+2*len, NULL);\n\tfree(input);\n\tif (rc == 0) {\n\t\treturn TRUE;\n\t} else {\n\t\treturn FALSE;\n\t}\n}",
    "includes": [
      "#include \"avahi.h\"",
      "#include \"sslhelper.h\"",
      "#include \"remote.h\"",
      "#include \"cursor.h\"",
      "#include \"keyboard.h\"",
      "#include \"inet.h\"",
      "#include \"connections.h\"",
      "#include \"xwrappers.h\"",
      "#include \"sslhelper.h\"",
      "#include \"unixpw.h\"",
      "#include \"screen.h\"",
      "#include \"scan.h\"",
      "#include \"cleanup.h\"",
      "#include \"solid.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "rfbBool custom_passwd_check(rfbClientPtr cl, const char *response, int len);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "input"
          ],
          "line": 1160
        },
        "resolved": true,
        "details": {
          "function_name": "free_rect",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/userinput.c",
          "lines": "6200-6247",
          "snippet": "int free_rect(int idx) {\n\tint n, ok = 0;\n\tsraRegionPtr r1, r2;\n\tint x, y, w, h;\n\n\tif (idx < 0 || idx >= cache_list_num) {\nif (0) fprintf(stderr, \"free_rect: bad index: %d\\n\", idx);\n\t\tclean_up_exit(1);\n\t}\n\n\tx = cache_list[idx].bs_x;\n\ty = cache_list[idx].bs_y;\n\tw = cache_list[idx].bs_w;\n\th = cache_list[idx].bs_h;\n\n\tif (x < 0) {\n\t\tCLEAR(idx);\nif (dnow() > last_client + 5 && ncdb) fprintf(stderr, \"free_rect: already bs_x invalidated: %d bs_x: %d\\n\", idx, x);\n\t\treturn 1;\n\t}\n\n\tr2 = sraRgnCreateRect(x, y, x+w, y+h);\n\n\tn = get_bs_n(y);\n\tif (n >= 0) {\n\t\tr1 = rect_reg[n];\n\t\tsraRgnOr(r1, r2);\n\t\tok = 1;\n\t}\n\n\tif (zero_rects) {\n\t\tsraRgnOr(zero_rects, r2);\n\t\tx = cache_list[idx].su_x;\n\t\ty = cache_list[idx].su_y;\n\t\tw = cache_list[idx].su_w;\n\t\th = cache_list[idx].su_h;\n\t\tif (x >= 0) {\n\t\t\tsraRgnDestroy(r2);\n\t\t\tr2 = sraRgnCreateRect(x, y, x+w, y+h);\n\t\t\tsraRgnOr(zero_rects, r2);\n\t\t}\n\t}\n\tsraRgnDestroy(r2);\n\n\tCLEAR(idx);\nif (! ok && ncdb) fprintf(stderr, \"**** free_rect: not-found %d\\n\", idx);\n\treturn ok;\n}",
          "includes": [
            "#include \"default8x16.h\"",
            "#include \"connections.h\"",
            "#include \"screen.h\"",
            "#include \"cursor.h\"",
            "#include \"macosxCGS.h\"",
            "#include \"macosx.h\"",
            "#include \"unixpw.h\"",
            "#include \"8to24.h\"",
            "#include \"xrandr.h\"",
            "#include \"solid.h\"",
            "#include \"keyboard.h\"",
            "#include \"rates.h\"",
            "#include \"pointer.h\"",
            "#include \"cleanup.h\"",
            "#include \"scan.h\"",
            "#include \"user.h\"",
            "#include \"xevents.h\"",
            "#include \"win_utils.h\"",
            "#include \"xinerama.h\"",
            "#include \"xrecord.h\"",
            "#include \"xdamage.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void mark_for_xdamage(int x, int y, int w, int h);",
            "void set_xdamage_mark(int x, int y, int w, int h);",
            "int find_rect(int idx, int x, int y, int w, int h);",
            "winattr_t *cache_list;",
            "int clipped(int idx);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"default8x16.h\"\n#include \"connections.h\"\n#include \"screen.h\"\n#include \"cursor.h\"\n#include \"macosxCGS.h\"\n#include \"macosx.h\"\n#include \"unixpw.h\"\n#include \"8to24.h\"\n#include \"xrandr.h\"\n#include \"solid.h\"\n#include \"keyboard.h\"\n#include \"rates.h\"\n#include \"pointer.h\"\n#include \"cleanup.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"xevents.h\"\n#include \"win_utils.h\"\n#include \"xinerama.h\"\n#include \"xrecord.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nvoid mark_for_xdamage(int x, int y, int w, int h);\nvoid set_xdamage_mark(int x, int y, int w, int h);\nint find_rect(int idx, int x, int y, int w, int h);\nwinattr_t *cache_list;\nint clipped(int idx);\n\nint free_rect(int idx) {\n\tint n, ok = 0;\n\tsraRegionPtr r1, r2;\n\tint x, y, w, h;\n\n\tif (idx < 0 || idx >= cache_list_num) {\nif (0) fprintf(stderr, \"free_rect: bad index: %d\\n\", idx);\n\t\tclean_up_exit(1);\n\t}\n\n\tx = cache_list[idx].bs_x;\n\ty = cache_list[idx].bs_y;\n\tw = cache_list[idx].bs_w;\n\th = cache_list[idx].bs_h;\n\n\tif (x < 0) {\n\t\tCLEAR(idx);\nif (dnow() > last_client + 5 && ncdb) fprintf(stderr, \"free_rect: already bs_x invalidated: %d bs_x: %d\\n\", idx, x);\n\t\treturn 1;\n\t}\n\n\tr2 = sraRgnCreateRect(x, y, x+w, y+h);\n\n\tn = get_bs_n(y);\n\tif (n >= 0) {\n\t\tr1 = rect_reg[n];\n\t\tsraRgnOr(r1, r2);\n\t\tok = 1;\n\t}\n\n\tif (zero_rects) {\n\t\tsraRgnOr(zero_rects, r2);\n\t\tx = cache_list[idx].su_x;\n\t\ty = cache_list[idx].su_y;\n\t\tw = cache_list[idx].su_w;\n\t\th = cache_list[idx].su_h;\n\t\tif (x >= 0) {\n\t\t\tsraRgnDestroy(r2);\n\t\t\tr2 = sraRgnCreateRect(x, y, x+w, y+h);\n\t\t\tsraRgnOr(zero_rects, r2);\n\t\t}\n\t}\n\tsraRgnDestroy(r2);\n\n\tCLEAR(idx);\nif (! ok && ncdb) fprintf(stderr, \"**** free_rect: not-found %d\\n\", idx);\n\treturn ok;\n}"
        }
      },
      {
        "call_info": {
          "callee": "run_user_command",
          "args": [
            "cmd",
            "cl",
            "\"custom_passwd\"",
            "input",
            "n+2*len",
            "NULL"
          ],
          "line": 1159
        },
        "resolved": true,
        "details": {
          "function_name": "run_user_command",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/connections.c",
          "lines": "466-763",
          "snippet": "int run_user_command(char *cmd, rfbClientPtr client, char *mode, char *input,\n   int len, FILE *output) {\n\tchar *old_display = NULL;\n\tchar *addr = NULL;\n\tchar str[100];\n\tint rc, ok;\n\tClientData *cd = NULL;\n\tclient_set_net(client);\n\tif (client != NULL) {\n\t\tcd = (ClientData *) client->clientData;\n\t\taddr = client->host;\n\t}\n\n\tif (addr == NULL || addr[0] == '\\0') {\n\t\taddr = \"unknown-host\";\n\t}\n\n\t/* set RFB_CLIENT_ID to semi unique id for command to use */\n\tif (cd && cd->uid) {\n\t\tsprintf(str, \"0x%x\", cd->uid);\n\t} else {\n\t\t/* not accepted yet: */\n\t\tsprintf(str, \"0x%x\", clients_served);\n\t}\n\tset_env(\"RFB_CLIENT_ID\", str);\n\n\t/* set RFB_CLIENT_IP to IP addr for command to use */\n\tset_env(\"RFB_CLIENT_IP\", addr);\n\n\t/* set RFB_X11VNC_PID to our pid for command to use */\n\tsprintf(str, \"%d\", (int) getpid());\n\tset_env(\"RFB_X11VNC_PID\", str);\n\n\tif (client == NULL) {\n\t\t;\n\t} else if (client->state == RFB_PROTOCOL_VERSION) {\n\t\tset_env(\"RFB_STATE\", \"PROTOCOL_VERSION\");\n\t} else if (client->state == RFB_SECURITY_TYPE) {\n\t\tset_env(\"RFB_STATE\", \"SECURITY_TYPE\");\n\t} else if (client->state == RFB_AUTHENTICATION) {\n\t\tset_env(\"RFB_STATE\", \"AUTHENTICATION\");\n\t} else if (client->state == RFB_INITIALISATION) {\n\t\tset_env(\"RFB_STATE\", \"INITIALISATION\");\n\t} else if (client->state == RFB_NORMAL) {\n\t\tset_env(\"RFB_STATE\", \"NORMAL\");\n\t} else {\n\t\tset_env(\"RFB_STATE\", \"UNKNOWN\");\n\t}\n\tif (certret_str) {\n\t\tset_env(\"RFB_SSL_CLIENT_CERT\", certret_str);\n\t} else {\n\t\tset_env(\"RFB_SSL_CLIENT_CERT\", \"\");\n\t}\n\n\t/* set RFB_CLIENT_PORT to peer port for command to use */\n\tif (cd && cd->client_port > 0) {\n\t\tsprintf(str, \"%d\", cd->client_port);\n\t} else if (client) {\n\t\tsprintf(str, \"%d\", get_remote_port(client->sock));\n\t}\n\tset_env(\"RFB_CLIENT_PORT\", str);\n\n\tset_env(\"RFB_MODE\", mode);\n\n\t/* \n\t * now do RFB_SERVER_IP and RFB_SERVER_PORT (i.e. us!)\n\t * This will establish a 5-tuple (including tcp) the external\n\t * program can potentially use to work out the virtual circuit\n\t * for this connection.\n\t */\n\tif (cd && cd->server_ip) {\n\t\tset_env(\"RFB_SERVER_IP\", cd->server_ip);\n\t} else if (client) {\n\t\tchar *sip = get_local_host(client->sock);\n\t\tset_env(\"RFB_SERVER_IP\", sip);\n\t\tif (sip) free(sip);\n\t}\n\n\tif (cd && cd->server_port > 0) {\n\t\tsprintf(str, \"%d\", cd->server_port);\n\t} else if (client) {\n\t\tsprintf(str, \"%d\", get_local_port(client->sock));\n\t}\n\tset_env(\"RFB_SERVER_PORT\", str);\n\n\tif (cd) {\n\t\tsprintf(str, \"%d\", cd->login_viewonly);\n\t} else {\n\t\tsprintf(str, \"%d\", -1);\n\t}\n\tset_env(\"RFB_LOGIN_VIEWONLY\", str);\n\n\tif (cd) {\n\t\tsprintf(str, \"%d\", (int) cd->login_time);\n\t} else {\n\t\tsprintf(str, \">%d\", (int) time(NULL));\n\t}\n\tset_env(\"RFB_LOGIN_TIME\", str);\n\n\tsprintf(str, \"%d\", (int) time(NULL));\n\tset_env(\"RFB_CURRENT_TIME\", str);\n\n\tif (!cd || !cd->username || cd->username[0] == '\\0') {\n\t\tset_env(\"RFB_USERNAME\", \"unknown-user\");\n\t} else {\n\t\tset_env(\"RFB_USERNAME\", cd->username);\n\t}\n\t/* \n\t * Better set DISPLAY to the one we are polling, if they\n\t * want something trickier, they can handle on their own\n\t * via environment, etc. \n\t */\n\tif (getenv(\"DISPLAY\")) {\n\t\told_display = strdup(getenv(\"DISPLAY\"));\n\t}\n\n\tif (raw_fb && ! dpy) {\t/* raw_fb hack */\n\t\tset_env(\"DISPLAY\", \"rawfb\");\n\t} else {\n\t\tset_env(\"DISPLAY\", DisplayString(dpy));\n\t}\n\n\t/*\n\t * work out the number of clients (have to use client_count\n\t * since there is deadlock in rfbGetClientIterator) \n\t */\n\tsprintf(str, \"%d\", client_count);\n\tset_env(\"RFB_CLIENT_COUNT\", str);\n\n\t/* gone, accept, afteraccept */\n\tok = 0;\n\tif (!strcmp(mode, \"env\")) {\n\t\treturn 1;\n\t}\n\tif (!strcmp(mode, \"accept\") && cmd_ok(\"accept\")) {\n\t\tok = 1;\n\t}\n\tif (!strcmp(mode, \"afteraccept\") && cmd_ok(\"afteraccept\")) {\n\t\tok = 1;\n\t}\n\tif (!strcmp(mode, \"gone\") && cmd_ok(\"gone\")) {\n\t\tok = 1;\n\t}\n\tif (!strcmp(mode, \"cmd_verify\") && cmd_ok(\"unixpw\")) {\n\t\tok = 1;\n\t}\n\tif (!strcmp(mode, \"read_passwds\") && cmd_ok(\"passwdfile\")) {\n\t\tok = 1;\n\t}\n\tif (!strcmp(mode, \"custom_passwd\") && cmd_ok(\"custom_passwd\")) {\n\t\tok = 1;\n\t}\n\tif (no_external_cmds || !ok) {\n\t\trfbLogEnable(1);\n\t\trfbLog(\"cannot run external commands in -nocmds mode:\\n\");\n\t\trfbLog(\"   \\\"%s\\\"\\n\", cmd);\n\t\trfbLog(\"   exiting.\\n\");\n\t\tclean_up_exit(1);\n\t}\n\trfbLog(\"running command:\\n\");\n\tif (!quiet) {\n\t\tfprintf(stderr, \"\\n  %s\\n\\n\", cmd);\n\t}\n\tclose_exec_fds();\n\n\tif (output != NULL) {\n\t\tFILE *ph;\n\t\tchar line[1024];\n\t\tchar *cmd2 = NULL;\n\t\tchar tmp[] = \"/tmp/x11vnc-tmp.XXXXXX\";\n\t\tint deltmp = 0;\n\n\t\tif (input != NULL) {\n\t\t\tint tmp_fd = mkstemp(tmp);\n\t\t\tif (tmp_fd < 0) {\n\t\t\t\trfbLog(\"mkstemp failed on: %s\\n\", tmp);\n\t\t\t\tclean_up_exit(1);\n\t\t\t}\n\t\t\twrite(tmp_fd, input, len);\n\t\t\tclose(tmp_fd);\n\t\t\tdeltmp = 1;\n\t\t\tcmd2 = (char *) malloc(100 + strlen(tmp) + strlen(cmd));\n\t\t\tsprintf(cmd2, \"/bin/cat %s | %s\", tmp, cmd);\n\t\t\t\n\t\t\tph = popen(cmd2, \"r\");\n\t\t} else {\n\t\t\tph = popen(cmd, \"r\");\n\t\t}\n\t\tif (ph == NULL) {\n\t\t\trfbLog(\"popen(%s) failed\", cmd);\n\t\t\trfbLogPerror(\"popen\");\n\t\t\tclean_up_exit(1);\n\t\t}\n\t\tmemset(line, 0, sizeof(line));\n\t\twhile (fgets(line, sizeof(line), ph) != NULL) {\n\t\t\tint j, k = -1;\n\t\t\tif (0) fprintf(stderr, \"line: %s\", line);\n\t\t\t/* take care to handle embedded nulls */\n\t\t\tfor (j=0; j < (int) sizeof(line); j++) {\n\t\t\t\tif (line[j] != '\\0') {\n\t\t\t\t\tk = j;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (k >= 0) {\n\t\t\t\twrite(fileno(output), line, k+1);\n\t\t\t}\n\t\t\tmemset(line, 0, sizeof(line));\n\t\t}\n\n\t\trc = pclose(ph);\n\n\t\tif (cmd2 != NULL) {\n\t\t\tfree(cmd2);\n\t\t}\n\t\tif (deltmp) {\n\t\t\tunlink(tmp);\n\t\t}\n\t\tgoto got_rc;\n\t} else if (input != NULL) {\n\t\tFILE *ph = popen(cmd, \"w\");\n\t\tif (ph == NULL) {\n\t\t\trfbLog(\"popen(%s) failed\", cmd);\n\t\t\trfbLogPerror(\"popen\");\n\t\t\tclean_up_exit(1);\n\t\t}\n\t\twrite(fileno(ph), input, len);\n\t\trc = pclose(ph);\n\t\tgoto got_rc;\n\t}\n\n#if LIBVNCSERVER_HAVE_FORK\n\t{\n\t\tpid_t pid;\n\t\tstruct sigaction sa, intr, quit;\n\t\tsigset_t omask;\n\n\t\tsa.sa_handler = SIG_IGN;\n\t\tsa.sa_flags = 0;\n\t\tsigemptyset(&sa.sa_mask);\n\t\tsigaction(SIGINT,  &sa, &intr);\n\t\tsigaction(SIGQUIT, &sa, &quit);\n\n\t\tsigaddset(&sa.sa_mask, SIGCHLD);\n\t\tsigprocmask(SIG_BLOCK, &sa.sa_mask, &omask);\n\n\t\tif ((pid = fork()) > 0 || pid == -1) {\n\n\t\t\tif (pid != -1) {\n\t\t\t\twaitpid(pid, &rc, 0);\n\t\t\t}\n\n\t\t\tsigaction(SIGINT,  &intr, (struct sigaction *) NULL);\n\t\t\tsigaction(SIGQUIT, &quit, (struct sigaction *) NULL);\n\t\t\tsigprocmask(SIG_SETMASK, &omask, (sigset_t *) NULL);\n\n\t\t\tif (pid == -1) {\n\t\t\t\tfprintf(stderr, \"could not fork\\n\");\n\t\t\t\trfbLogPerror(\"fork\");\n\t\t\t\trc = system(cmd);\n\t\t\t}\n\t\t} else {\n\t\t\t/* this should close port 5900, etc.. */\n\t\t\tint fd;\n\t\t\tsigaction(SIGINT,  &intr, (struct sigaction *) NULL);\n\t\t\tsigaction(SIGQUIT, &quit, (struct sigaction *) NULL);\n\t\t\tsigprocmask(SIG_SETMASK, &omask, (sigset_t *) NULL);\n\t\t\tfor (fd=3; fd<256; fd++) {\n\t\t\t\tclose(fd);\n\t\t\t}\n/* XXX test more */\n\t\t\tif (!strcmp(mode, \"gone\")) {\n#if HAVE_SETSID\n\t\t\t\tsetsid();\n#else\n\t\t\t\tsetpgrp();\n#endif\n\t\t\t}\n\t\t\texeclp(\"/bin/sh\", \"/bin/sh\", \"-c\", cmd, (char *) NULL);\n\t\t\texit(1);\n\t\t}\n\t}\n#else\n\trc = system(cmd);\n#endif\n\tgot_rc:\n\n\tif (rc >= 256) {\n\t\trc = rc/256;\n\t}\n\trfbLog(\"command returned: %d\\n\", rc);\n\n\tif (old_display) {\n\t\tset_env(\"DISPLAY\", old_display);\n\t\tfree(old_display);\n\t}\n\n\treturn rc;\n}",
          "includes": [
            "#include \"xi2_devices.h\"",
            "#include \"xrandr.h\"",
            "#include \"pointer.h\"",
            "#include \"userinput.h\"",
            "#include \"macosxCG.h\"",
            "#include \"macosx.h\"",
            "#include \"win_utils.h\"",
            "#include \"xevents.h\"",
            "#include \"xwrappers.h\"",
            "#include \"sslhelper.h\"",
            "#include \"sslcmds.h\"",
            "#include \"scan.h\"",
            "#include \"user.h\"",
            "#include \"unixpw.h\"",
            "#include \"screen.h\"",
            "#include \"rates.h\"",
            "#include \"solid.h\"",
            "#include \"gui.h\"",
            "#include \"cleanup.h\"",
            "#include \"keyboard.h\"",
            "#include \"remote.h\"",
            "#include \"inet.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int new_fb_size_clients(rfbScreenInfoPtr s);",
            "void close_clients(char *str);",
            "void set_client_input(char *str);",
            "int cmd_ok(char *cmd);",
            "void client_gone(rfbClientPtr client);",
            "void client_gone_chat_helper(rfbClientPtr client);",
            "void reverse_connect(char *str);",
            "void set_vnc_connect_prop(char *str);",
            "void set_x11vnc_remote_prop(char *str);",
            "enum rfbNewClientAction new_client(rfbClientPtr client);",
            "enum rfbNewClientAction new_client_chat_helper(rfbClientPtr client);",
            "rfbBool password_check_chat_helper(rfbClientPtr cl, const char* response, int len);",
            "void send_client_info(char *str);",
            "void adjust_grabs(int grab, int quiet);",
            "int accept_client(rfbClientPtr client);",
            "int run_user_command(char *cmd, rfbClientPtr client, char *mode, char *input,\n    int len, FILE *output);",
            "int check_access(char *addr);",
            "void client_set_net(rfbClientPtr client);",
            "static rfbClientPtr *client_match(char *str);",
            "static void free_client_data(rfbClientPtr client);",
            "static int ugly_window(char *addr, char *userhost, int X, int Y,\n    int timeout, char *mode, int accept);",
            "static int action_match(char *action, int rc);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xi2_devices.h\"\n#include \"xrandr.h\"\n#include \"pointer.h\"\n#include \"userinput.h\"\n#include \"macosxCG.h\"\n#include \"macosx.h\"\n#include \"win_utils.h\"\n#include \"xevents.h\"\n#include \"xwrappers.h\"\n#include \"sslhelper.h\"\n#include \"sslcmds.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"unixpw.h\"\n#include \"screen.h\"\n#include \"rates.h\"\n#include \"solid.h\"\n#include \"gui.h\"\n#include \"cleanup.h\"\n#include \"keyboard.h\"\n#include \"remote.h\"\n#include \"inet.h\"\n#include \"x11vnc.h\"\n\nint new_fb_size_clients(rfbScreenInfoPtr s);\nvoid close_clients(char *str);\nvoid set_client_input(char *str);\nint cmd_ok(char *cmd);\nvoid client_gone(rfbClientPtr client);\nvoid client_gone_chat_helper(rfbClientPtr client);\nvoid reverse_connect(char *str);\nvoid set_vnc_connect_prop(char *str);\nvoid set_x11vnc_remote_prop(char *str);\nenum rfbNewClientAction new_client(rfbClientPtr client);\nenum rfbNewClientAction new_client_chat_helper(rfbClientPtr client);\nrfbBool password_check_chat_helper(rfbClientPtr cl, const char* response, int len);\nvoid send_client_info(char *str);\nvoid adjust_grabs(int grab, int quiet);\nint accept_client(rfbClientPtr client);\nint run_user_command(char *cmd, rfbClientPtr client, char *mode, char *input,\n    int len, FILE *output);\nint check_access(char *addr);\nvoid client_set_net(rfbClientPtr client);\nstatic rfbClientPtr *client_match(char *str);\nstatic void free_client_data(rfbClientPtr client);\nstatic int ugly_window(char *addr, char *userhost, int X, int Y,\n    int timeout, char *mode, int accept);\nstatic int action_match(char *action, int rc);\n\nint run_user_command(char *cmd, rfbClientPtr client, char *mode, char *input,\n   int len, FILE *output) {\n\tchar *old_display = NULL;\n\tchar *addr = NULL;\n\tchar str[100];\n\tint rc, ok;\n\tClientData *cd = NULL;\n\tclient_set_net(client);\n\tif (client != NULL) {\n\t\tcd = (ClientData *) client->clientData;\n\t\taddr = client->host;\n\t}\n\n\tif (addr == NULL || addr[0] == '\\0') {\n\t\taddr = \"unknown-host\";\n\t}\n\n\t/* set RFB_CLIENT_ID to semi unique id for command to use */\n\tif (cd && cd->uid) {\n\t\tsprintf(str, \"0x%x\", cd->uid);\n\t} else {\n\t\t/* not accepted yet: */\n\t\tsprintf(str, \"0x%x\", clients_served);\n\t}\n\tset_env(\"RFB_CLIENT_ID\", str);\n\n\t/* set RFB_CLIENT_IP to IP addr for command to use */\n\tset_env(\"RFB_CLIENT_IP\", addr);\n\n\t/* set RFB_X11VNC_PID to our pid for command to use */\n\tsprintf(str, \"%d\", (int) getpid());\n\tset_env(\"RFB_X11VNC_PID\", str);\n\n\tif (client == NULL) {\n\t\t;\n\t} else if (client->state == RFB_PROTOCOL_VERSION) {\n\t\tset_env(\"RFB_STATE\", \"PROTOCOL_VERSION\");\n\t} else if (client->state == RFB_SECURITY_TYPE) {\n\t\tset_env(\"RFB_STATE\", \"SECURITY_TYPE\");\n\t} else if (client->state == RFB_AUTHENTICATION) {\n\t\tset_env(\"RFB_STATE\", \"AUTHENTICATION\");\n\t} else if (client->state == RFB_INITIALISATION) {\n\t\tset_env(\"RFB_STATE\", \"INITIALISATION\");\n\t} else if (client->state == RFB_NORMAL) {\n\t\tset_env(\"RFB_STATE\", \"NORMAL\");\n\t} else {\n\t\tset_env(\"RFB_STATE\", \"UNKNOWN\");\n\t}\n\tif (certret_str) {\n\t\tset_env(\"RFB_SSL_CLIENT_CERT\", certret_str);\n\t} else {\n\t\tset_env(\"RFB_SSL_CLIENT_CERT\", \"\");\n\t}\n\n\t/* set RFB_CLIENT_PORT to peer port for command to use */\n\tif (cd && cd->client_port > 0) {\n\t\tsprintf(str, \"%d\", cd->client_port);\n\t} else if (client) {\n\t\tsprintf(str, \"%d\", get_remote_port(client->sock));\n\t}\n\tset_env(\"RFB_CLIENT_PORT\", str);\n\n\tset_env(\"RFB_MODE\", mode);\n\n\t/* \n\t * now do RFB_SERVER_IP and RFB_SERVER_PORT (i.e. us!)\n\t * This will establish a 5-tuple (including tcp) the external\n\t * program can potentially use to work out the virtual circuit\n\t * for this connection.\n\t */\n\tif (cd && cd->server_ip) {\n\t\tset_env(\"RFB_SERVER_IP\", cd->server_ip);\n\t} else if (client) {\n\t\tchar *sip = get_local_host(client->sock);\n\t\tset_env(\"RFB_SERVER_IP\", sip);\n\t\tif (sip) free(sip);\n\t}\n\n\tif (cd && cd->server_port > 0) {\n\t\tsprintf(str, \"%d\", cd->server_port);\n\t} else if (client) {\n\t\tsprintf(str, \"%d\", get_local_port(client->sock));\n\t}\n\tset_env(\"RFB_SERVER_PORT\", str);\n\n\tif (cd) {\n\t\tsprintf(str, \"%d\", cd->login_viewonly);\n\t} else {\n\t\tsprintf(str, \"%d\", -1);\n\t}\n\tset_env(\"RFB_LOGIN_VIEWONLY\", str);\n\n\tif (cd) {\n\t\tsprintf(str, \"%d\", (int) cd->login_time);\n\t} else {\n\t\tsprintf(str, \">%d\", (int) time(NULL));\n\t}\n\tset_env(\"RFB_LOGIN_TIME\", str);\n\n\tsprintf(str, \"%d\", (int) time(NULL));\n\tset_env(\"RFB_CURRENT_TIME\", str);\n\n\tif (!cd || !cd->username || cd->username[0] == '\\0') {\n\t\tset_env(\"RFB_USERNAME\", \"unknown-user\");\n\t} else {\n\t\tset_env(\"RFB_USERNAME\", cd->username);\n\t}\n\t/* \n\t * Better set DISPLAY to the one we are polling, if they\n\t * want something trickier, they can handle on their own\n\t * via environment, etc. \n\t */\n\tif (getenv(\"DISPLAY\")) {\n\t\told_display = strdup(getenv(\"DISPLAY\"));\n\t}\n\n\tif (raw_fb && ! dpy) {\t/* raw_fb hack */\n\t\tset_env(\"DISPLAY\", \"rawfb\");\n\t} else {\n\t\tset_env(\"DISPLAY\", DisplayString(dpy));\n\t}\n\n\t/*\n\t * work out the number of clients (have to use client_count\n\t * since there is deadlock in rfbGetClientIterator) \n\t */\n\tsprintf(str, \"%d\", client_count);\n\tset_env(\"RFB_CLIENT_COUNT\", str);\n\n\t/* gone, accept, afteraccept */\n\tok = 0;\n\tif (!strcmp(mode, \"env\")) {\n\t\treturn 1;\n\t}\n\tif (!strcmp(mode, \"accept\") && cmd_ok(\"accept\")) {\n\t\tok = 1;\n\t}\n\tif (!strcmp(mode, \"afteraccept\") && cmd_ok(\"afteraccept\")) {\n\t\tok = 1;\n\t}\n\tif (!strcmp(mode, \"gone\") && cmd_ok(\"gone\")) {\n\t\tok = 1;\n\t}\n\tif (!strcmp(mode, \"cmd_verify\") && cmd_ok(\"unixpw\")) {\n\t\tok = 1;\n\t}\n\tif (!strcmp(mode, \"read_passwds\") && cmd_ok(\"passwdfile\")) {\n\t\tok = 1;\n\t}\n\tif (!strcmp(mode, \"custom_passwd\") && cmd_ok(\"custom_passwd\")) {\n\t\tok = 1;\n\t}\n\tif (no_external_cmds || !ok) {\n\t\trfbLogEnable(1);\n\t\trfbLog(\"cannot run external commands in -nocmds mode:\\n\");\n\t\trfbLog(\"   \\\"%s\\\"\\n\", cmd);\n\t\trfbLog(\"   exiting.\\n\");\n\t\tclean_up_exit(1);\n\t}\n\trfbLog(\"running command:\\n\");\n\tif (!quiet) {\n\t\tfprintf(stderr, \"\\n  %s\\n\\n\", cmd);\n\t}\n\tclose_exec_fds();\n\n\tif (output != NULL) {\n\t\tFILE *ph;\n\t\tchar line[1024];\n\t\tchar *cmd2 = NULL;\n\t\tchar tmp[] = \"/tmp/x11vnc-tmp.XXXXXX\";\n\t\tint deltmp = 0;\n\n\t\tif (input != NULL) {\n\t\t\tint tmp_fd = mkstemp(tmp);\n\t\t\tif (tmp_fd < 0) {\n\t\t\t\trfbLog(\"mkstemp failed on: %s\\n\", tmp);\n\t\t\t\tclean_up_exit(1);\n\t\t\t}\n\t\t\twrite(tmp_fd, input, len);\n\t\t\tclose(tmp_fd);\n\t\t\tdeltmp = 1;\n\t\t\tcmd2 = (char *) malloc(100 + strlen(tmp) + strlen(cmd));\n\t\t\tsprintf(cmd2, \"/bin/cat %s | %s\", tmp, cmd);\n\t\t\t\n\t\t\tph = popen(cmd2, \"r\");\n\t\t} else {\n\t\t\tph = popen(cmd, \"r\");\n\t\t}\n\t\tif (ph == NULL) {\n\t\t\trfbLog(\"popen(%s) failed\", cmd);\n\t\t\trfbLogPerror(\"popen\");\n\t\t\tclean_up_exit(1);\n\t\t}\n\t\tmemset(line, 0, sizeof(line));\n\t\twhile (fgets(line, sizeof(line), ph) != NULL) {\n\t\t\tint j, k = -1;\n\t\t\tif (0) fprintf(stderr, \"line: %s\", line);\n\t\t\t/* take care to handle embedded nulls */\n\t\t\tfor (j=0; j < (int) sizeof(line); j++) {\n\t\t\t\tif (line[j] != '\\0') {\n\t\t\t\t\tk = j;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (k >= 0) {\n\t\t\t\twrite(fileno(output), line, k+1);\n\t\t\t}\n\t\t\tmemset(line, 0, sizeof(line));\n\t\t}\n\n\t\trc = pclose(ph);\n\n\t\tif (cmd2 != NULL) {\n\t\t\tfree(cmd2);\n\t\t}\n\t\tif (deltmp) {\n\t\t\tunlink(tmp);\n\t\t}\n\t\tgoto got_rc;\n\t} else if (input != NULL) {\n\t\tFILE *ph = popen(cmd, \"w\");\n\t\tif (ph == NULL) {\n\t\t\trfbLog(\"popen(%s) failed\", cmd);\n\t\t\trfbLogPerror(\"popen\");\n\t\t\tclean_up_exit(1);\n\t\t}\n\t\twrite(fileno(ph), input, len);\n\t\trc = pclose(ph);\n\t\tgoto got_rc;\n\t}\n\n#if LIBVNCSERVER_HAVE_FORK\n\t{\n\t\tpid_t pid;\n\t\tstruct sigaction sa, intr, quit;\n\t\tsigset_t omask;\n\n\t\tsa.sa_handler = SIG_IGN;\n\t\tsa.sa_flags = 0;\n\t\tsigemptyset(&sa.sa_mask);\n\t\tsigaction(SIGINT,  &sa, &intr);\n\t\tsigaction(SIGQUIT, &sa, &quit);\n\n\t\tsigaddset(&sa.sa_mask, SIGCHLD);\n\t\tsigprocmask(SIG_BLOCK, &sa.sa_mask, &omask);\n\n\t\tif ((pid = fork()) > 0 || pid == -1) {\n\n\t\t\tif (pid != -1) {\n\t\t\t\twaitpid(pid, &rc, 0);\n\t\t\t}\n\n\t\t\tsigaction(SIGINT,  &intr, (struct sigaction *) NULL);\n\t\t\tsigaction(SIGQUIT, &quit, (struct sigaction *) NULL);\n\t\t\tsigprocmask(SIG_SETMASK, &omask, (sigset_t *) NULL);\n\n\t\t\tif (pid == -1) {\n\t\t\t\tfprintf(stderr, \"could not fork\\n\");\n\t\t\t\trfbLogPerror(\"fork\");\n\t\t\t\trc = system(cmd);\n\t\t\t}\n\t\t} else {\n\t\t\t/* this should close port 5900, etc.. */\n\t\t\tint fd;\n\t\t\tsigaction(SIGINT,  &intr, (struct sigaction *) NULL);\n\t\t\tsigaction(SIGQUIT, &quit, (struct sigaction *) NULL);\n\t\t\tsigprocmask(SIG_SETMASK, &omask, (sigset_t *) NULL);\n\t\t\tfor (fd=3; fd<256; fd++) {\n\t\t\t\tclose(fd);\n\t\t\t}\n/* XXX test more */\n\t\t\tif (!strcmp(mode, \"gone\")) {\n#if HAVE_SETSID\n\t\t\t\tsetsid();\n#else\n\t\t\t\tsetpgrp();\n#endif\n\t\t\t}\n\t\t\texeclp(\"/bin/sh\", \"/bin/sh\", \"-c\", cmd, (char *) NULL);\n\t\t\texit(1);\n\t\t}\n\t}\n#else\n\trc = system(cmd);\n#endif\n\tgot_rc:\n\n\tif (rc >= 256) {\n\t\trc = rc/256;\n\t}\n\trfbLog(\"command returned: %d\\n\", rc);\n\n\tif (old_display) {\n\t\tset_env(\"DISPLAY\", old_display);\n\t\tfree(old_display);\n\t}\n\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "num"
          ],
          "line": 1148
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcat",
          "args": [
            "input",
            "num"
          ],
          "line": 1147
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "2 * len + 16 + 1"
          ],
          "line": 1144
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "num",
            "\"%d\\n\"",
            "len"
          ],
          "line": 1142
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "\"custom:\""
          ],
          "line": 1140
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "passwdfile",
            "\"custom:\""
          ],
          "line": 1137
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"custom_passwd_check: len=%d\\n\"",
            "len"
          ],
          "line": 1135
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"avahi.h\"\n#include \"sslhelper.h\"\n#include \"remote.h\"\n#include \"cursor.h\"\n#include \"keyboard.h\"\n#include \"inet.h\"\n#include \"connections.h\"\n#include \"xwrappers.h\"\n#include \"sslhelper.h\"\n#include \"unixpw.h\"\n#include \"screen.h\"\n#include \"scan.h\"\n#include \"cleanup.h\"\n#include \"solid.h\"\n#include \"x11vnc.h\"\n\nrfbBool custom_passwd_check(rfbClientPtr cl, const char *response, int len);\n\nrfbBool custom_passwd_check(rfbClientPtr cl, const char *response, int len) {\n\tchar *input, *cmd;\n\tchar num[16];\n\tint j, i, n, rc;\n\n\trfbLog(\"custom_passwd_check: len=%d\\n\", len);\n\n\tif (!passwdfile || strstr(passwdfile, \"custom:\") != passwdfile) {\n\t\treturn FALSE;\n\t}\n\tcmd = passwdfile + strlen(\"custom:\");\n\n\tsprintf(num, \"%d\\n\", len);\n\n\tinput = (char *) malloc(2 * len + 16 + 1);\n\t\n\tinput[0] = '\\0';\n\tstrcat(input, num);\n\tn = strlen(num);\n\n\tj = n;\n\tfor (i=0; i < len; i++) {\n\t\tinput[j] = cl->authChallenge[i];\n\t\tj++;\n\t}\n\tfor (i=0; i < len; i++) {\n\t\tinput[j] = response[i];\n\t\tj++;\n\t}\n\trc = run_user_command(cmd, cl, \"custom_passwd\", input, n+2*len, NULL);\n\tfree(input);\n\tif (rc == 0) {\n\t\treturn TRUE;\n\t} else {\n\t\treturn FALSE;\n\t}\n}"
  },
  {
    "function_name": "check_new_passwds",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/user.c",
    "lines": "1105-1128",
    "snippet": "void check_new_passwds(int force) {\n\tstatic time_t last_check = 0;\n\ttime_t now;\n\n\tif (! passwdfile) {\n\t\treturn;\n\t}\n\tif (strstr(passwdfile, \"read:\") != passwdfile) {\n\t\treturn;\n\t}\n\tif (unixpw_in_progress) return;\n\n\tif (force) {\n\t\tlast_check = 0;\n\t}\n\n\tnow = time(NULL);\n\tif (now > last_check + 1) {\n\t\tif (read_passwds(passwdfile)) {\n\t\t\tinstall_passwds();\n\t\t}\n\t\tlast_check = now;\n\t}\n}",
    "includes": [
      "#include \"avahi.h\"",
      "#include \"sslhelper.h\"",
      "#include \"remote.h\"",
      "#include \"cursor.h\"",
      "#include \"keyboard.h\"",
      "#include \"inet.h\"",
      "#include \"connections.h\"",
      "#include \"xwrappers.h\"",
      "#include \"sslhelper.h\"",
      "#include \"unixpw.h\"",
      "#include \"screen.h\"",
      "#include \"scan.h\"",
      "#include \"cleanup.h\"",
      "#include \"solid.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "void install_passwds(void);",
      "void check_new_passwds(int force);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "install_passwds",
          "args": [],
          "line": 1124
        },
        "resolved": true,
        "details": {
          "function_name": "install_passwds",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/user.c",
          "lines": "1081-1103",
          "snippet": "void install_passwds(void) {\n\tif (viewonly_passwd) {\n\t\t/* append the view only passwd after the normal passwd */\n\t\tchar **passwds_new = (char **) malloc(3*sizeof(char *));\n\t\tchar **passwds_old = (char **) screen->authPasswdData;\n\t\tpasswds_new[0] = passwds_old[0];\n\t\tpasswds_new[1] = viewonly_passwd;\n\t\tpasswds_new[2] = NULL;\n\t\t/* mutex */\n\t\tscreen->authPasswdData = (void*) passwds_new;\n\t} else if (passwd_list) {\n\t\tint i = 0;\n\t\twhile(passwd_list[i] != NULL) {\n\t\t\ti++;\n\t\t}\n\t\tif (begin_viewonly < 0) {\n\t\t\tbegin_viewonly = i+1;\n\t\t}\n\t\t/* mutex */\n\t\tscreen->authPasswdData = (void*) passwd_list;\n\t\tscreen->authPasswdFirstViewOnly = begin_viewonly;\n\t}\n}",
          "includes": [
            "#include \"avahi.h\"",
            "#include \"sslhelper.h\"",
            "#include \"remote.h\"",
            "#include \"cursor.h\"",
            "#include \"keyboard.h\"",
            "#include \"inet.h\"",
            "#include \"connections.h\"",
            "#include \"xwrappers.h\"",
            "#include \"sslhelper.h\"",
            "#include \"unixpw.h\"",
            "#include \"screen.h\"",
            "#include \"scan.h\"",
            "#include \"cleanup.h\"",
            "#include \"solid.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void install_passwds(void);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"avahi.h\"\n#include \"sslhelper.h\"\n#include \"remote.h\"\n#include \"cursor.h\"\n#include \"keyboard.h\"\n#include \"inet.h\"\n#include \"connections.h\"\n#include \"xwrappers.h\"\n#include \"sslhelper.h\"\n#include \"unixpw.h\"\n#include \"screen.h\"\n#include \"scan.h\"\n#include \"cleanup.h\"\n#include \"solid.h\"\n#include \"x11vnc.h\"\n\nvoid install_passwds(void);\n\nvoid install_passwds(void) {\n\tif (viewonly_passwd) {\n\t\t/* append the view only passwd after the normal passwd */\n\t\tchar **passwds_new = (char **) malloc(3*sizeof(char *));\n\t\tchar **passwds_old = (char **) screen->authPasswdData;\n\t\tpasswds_new[0] = passwds_old[0];\n\t\tpasswds_new[1] = viewonly_passwd;\n\t\tpasswds_new[2] = NULL;\n\t\t/* mutex */\n\t\tscreen->authPasswdData = (void*) passwds_new;\n\t} else if (passwd_list) {\n\t\tint i = 0;\n\t\twhile(passwd_list[i] != NULL) {\n\t\t\ti++;\n\t\t}\n\t\tif (begin_viewonly < 0) {\n\t\t\tbegin_viewonly = i+1;\n\t\t}\n\t\t/* mutex */\n\t\tscreen->authPasswdData = (void*) passwd_list;\n\t\tscreen->authPasswdFirstViewOnly = begin_viewonly;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "read_passwds",
          "args": [
            "passwdfile"
          ],
          "line": 1123
        },
        "resolved": true,
        "details": {
          "function_name": "read_passwds",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/user.c",
          "lines": "867-1079",
          "snippet": "int read_passwds(char *passfile) {\n\tchar line[1024];\n\tchar *filename;\n\tchar **old_passwd_list = passwd_list;\n\tint linecount = 0, i, remove = 0, read_mode = 0, begin_vo = -1;\n\tstruct stat sbuf;\n\tstatic int max = -1;\n\tFILE *in = NULL;\n\tstatic time_t last_read = 0;\n\tstatic int read_cnt = 0;\n\tint db_passwd = 0;\n\n\tif (max < 0) {\n\t\tmax = 1000;\n\t\tif (getenv(\"X11VNC_MAX_PASSWDS\")) {\n\t\t\tmax = atoi(getenv(\"X11VNC_MAX_PASSWDS\"));\n\t\t}\n\t}\n\n\tfilename = passfile;\n\tif (strstr(filename, \"rm:\") == filename) {\n\t\tfilename += strlen(\"rm:\");\n\t\tremove = 1;\n\t} else if (strstr(filename, \"read:\") == filename) {\n\t\tfilename += strlen(\"read:\");\n\t\tread_mode = 1;\n\t\tif (stat(filename, &sbuf) == 0) {\n\t\t\tif (sbuf.st_mtime <= last_read) {\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t\tlast_read = sbuf.st_mtime;\n\t\t}\n\t} else if (strstr(filename, \"cmd:\") == filename) {\n\t\tint rc;\n\n\t\tfilename += strlen(\"cmd:\");\n\t\tread_mode = 1;\n\t\tin = tmpfile();\n\t\tif (in == NULL) {\n\t\t\trfbLog(\"run_user_command tmpfile() failed: %s\\n\",\n\t\t\t    filename);\n\t\t\tclean_up_exit(1);\n\t\t}\n\t\trc = run_user_command(filename, latest_client, \"read_passwds\",\n\t\t    NULL, 0, in);\n\t\tif (rc != 0) {\n\t\t\trfbLog(\"run_user_command command failed: %s\\n\",\n\t\t\t    filename);\n\t\t\tclean_up_exit(1);\n\t\t}\n\t\trewind(in);\n\t} else if (strstr(filename, \"custom:\") == filename) {\n\t\treturn 1;\n\t}\n\n\tif (in == NULL && stat(filename, &sbuf) == 0) {\n\t\t/* (poor...) upper bound to number of lines */\n\t\tmax = (int) sbuf.st_size;\n\t\tlast_read = sbuf.st_mtime;\n\t}\n\n\t/* create 1 more than max to have it be the ending NULL */\n\tpasswd_list = (char **) malloc( (max+1) * (sizeof(char *)) );\n\tfor (i=0; i<max+1; i++) {\n\t\tpasswd_list[i] = NULL;\n\t}\n\t\n\tif (in == NULL) {\n\t\tin = fopen(filename, \"r\");\n\t}\n\tif (in == NULL) {\n\t\trfbLog(\"cannot open passwdfile: %s\\n\", passfile);\n\t\trfbLogPerror(\"fopen\");\n\t\tif (remove) {\n\t\t\tunlink(filename);\n\t\t}\n\t\tclean_up_exit(1);\n\t}\n\n\tif (getenv(\"DEBUG_PASSWDFILE\") != NULL) {\n\t\tdb_passwd = 1;\n\t}\n\n\twhile (fgets(line, sizeof line, in) != NULL) {\n\t\tchar *p;\n\t\tint blank = 1;\n\t\tint len = strlen(line); \n\n\t\tif (db_passwd) {\n\t\t\tfprintf(stderr, \"read_passwds: raw line: %s\\n\", line);\n\t\t}\n\n\t\tif (len == 0) {\n\t\t\tcontinue;\n\t\t} else if (line[len-1] == '\\n') {\n\t\t\tline[len-1] = '\\0';\n\t\t}\n\t\tif (line[0] == '\\0') {\n\t\t\tcontinue;\n\t\t}\n\t\tif (strstr(line, \"__SKIP__\") != NULL) {\n\t\t\tcontinue;\n\t\t}\n\t\tif (strstr(line, \"__COMM__\") == line) {\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strcmp(line, \"__BEGIN_VIEWONLY__\")) {\n\t\t\tif (begin_vo < 0) {\n\t\t\t\tbegin_vo = linecount;\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\t\tif (line[0] == '#') {\n\t\t\t/* commented out, cannot have password beginning with # */\n\t\t\tcontinue;\n\t\t}\n\t\tp = line;\n\t\twhile (*p != '\\0') {\n\t\t\tif (! isspace((unsigned char) (*p))) {\n\t\t\t\tblank = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tp++;\n\t\t}\n\t\tif (blank) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tpasswd_list[linecount++] = strdup(line);\n\t\tif (db_passwd) {\n\t\t\tfprintf(stderr, \"read_passwds: keepline: %s\\n\", line);\n\t\t\tfprintf(stderr, \"read_passwds: begin_vo: %d\\n\", begin_vo);\n\t\t}\n\n\t\tif (linecount >= max) {\n\t\t\trfbLog(\"read_passwds: hit max passwd: %d\\n\", max);\n\t\t\tbreak;\n\t\t}\n\t}\n\tfclose(in);\n\n\tfor (i=0; i<1024; i++) {\n\t\tline[i] = '\\0';\n\t}\n\n\tif (remove) {\n\t\tunlink(filename);\n\t}\n\n\tif (! linecount) {\n\t\trfbLog(\"cannot read a valid line from passwdfile: %s\\n\",\n\t\t    passfile);\n\t\tif (read_cnt == 0) {\n\t\t\tclean_up_exit(1);\n\t\t} else {\n\t\t\treturn 0;\n\t\t}\n\t}\n\tread_cnt++;\n\n\tfor (i=0; i<linecount; i++) {\n\t\tchar *q, *p = passwd_list[i];\n\t\tif (!strcmp(p, \"__EMPTY__\")) {\n\t\t\t*p = '\\0';\n\t\t} else if ((q = strstr(p, \"__COMM__\")) != NULL) {\n\t\t\t*q = '\\0';\n\t\t}\n\t\tpasswd_list[i] = strdup(p);\n\t\tif (db_passwd) {\n\t\t\tfprintf(stderr, \"read_passwds: trimline: %s\\n\", p);\n\t\t}\n\t\tstrzero(p);\n\t}\n\n\tbegin_viewonly = begin_vo;\n\tif (read_mode && read_cnt > 1) {\n\t\tif (viewonly_passwd) {\n\t\t\tfree(viewonly_passwd);\n\t\t\tviewonly_passwd = NULL;\n\t\t}\n\t}\n\n\tif (begin_viewonly < 0 && linecount == 2) {\n\t\t/* for compatibility with previous 2-line usage: */\n\t\tviewonly_passwd = strdup(passwd_list[1]);\n\t\tif (db_passwd) {\n\t\t\tfprintf(stderr, \"read_passwds: linecount is 2.\\n\");\n\t\t}\n\t\tif (screen) {\n\t\t\tchar **apd = (char **) screen->authPasswdData;\n\t\t\tif (apd) {\n\t\t\t\tif (apd[0] != NULL) {\n\t\t\t\t\tstrzero(apd[0]);\n\t\t\t\t}\n\t\t\t\tapd[0] = strdup(passwd_list[0]);\n\t\t\t}\n\t\t}\n\t\tbegin_viewonly = 1;\n\t}\n\n\tif (old_passwd_list != NULL) {\n\t\tchar *p;\n\t\ti = 0;\n\t\twhile (old_passwd_list[i] != NULL) {\n\t\t\tp = old_passwd_list[i];\n\t\t\tstrzero(p);\n\t\t\tfree(old_passwd_list[i]);\n\t\t\ti++;\n\t\t}\n\t\tfree(old_passwd_list);\n\t}\n\treturn 1;\n}",
          "includes": [
            "#include \"avahi.h\"",
            "#include \"sslhelper.h\"",
            "#include \"remote.h\"",
            "#include \"cursor.h\"",
            "#include \"keyboard.h\"",
            "#include \"inet.h\"",
            "#include \"connections.h\"",
            "#include \"xwrappers.h\"",
            "#include \"sslhelper.h\"",
            "#include \"unixpw.h\"",
            "#include \"screen.h\"",
            "#include \"scan.h\"",
            "#include \"cleanup.h\"",
            "#include \"solid.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int read_passwds(char *passfile);",
            "rfbBool custom_passwd_check(rfbClientPtr cl, const char *response, int len);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"avahi.h\"\n#include \"sslhelper.h\"\n#include \"remote.h\"\n#include \"cursor.h\"\n#include \"keyboard.h\"\n#include \"inet.h\"\n#include \"connections.h\"\n#include \"xwrappers.h\"\n#include \"sslhelper.h\"\n#include \"unixpw.h\"\n#include \"screen.h\"\n#include \"scan.h\"\n#include \"cleanup.h\"\n#include \"solid.h\"\n#include \"x11vnc.h\"\n\nint read_passwds(char *passfile);\nrfbBool custom_passwd_check(rfbClientPtr cl, const char *response, int len);\n\nint read_passwds(char *passfile) {\n\tchar line[1024];\n\tchar *filename;\n\tchar **old_passwd_list = passwd_list;\n\tint linecount = 0, i, remove = 0, read_mode = 0, begin_vo = -1;\n\tstruct stat sbuf;\n\tstatic int max = -1;\n\tFILE *in = NULL;\n\tstatic time_t last_read = 0;\n\tstatic int read_cnt = 0;\n\tint db_passwd = 0;\n\n\tif (max < 0) {\n\t\tmax = 1000;\n\t\tif (getenv(\"X11VNC_MAX_PASSWDS\")) {\n\t\t\tmax = atoi(getenv(\"X11VNC_MAX_PASSWDS\"));\n\t\t}\n\t}\n\n\tfilename = passfile;\n\tif (strstr(filename, \"rm:\") == filename) {\n\t\tfilename += strlen(\"rm:\");\n\t\tremove = 1;\n\t} else if (strstr(filename, \"read:\") == filename) {\n\t\tfilename += strlen(\"read:\");\n\t\tread_mode = 1;\n\t\tif (stat(filename, &sbuf) == 0) {\n\t\t\tif (sbuf.st_mtime <= last_read) {\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t\tlast_read = sbuf.st_mtime;\n\t\t}\n\t} else if (strstr(filename, \"cmd:\") == filename) {\n\t\tint rc;\n\n\t\tfilename += strlen(\"cmd:\");\n\t\tread_mode = 1;\n\t\tin = tmpfile();\n\t\tif (in == NULL) {\n\t\t\trfbLog(\"run_user_command tmpfile() failed: %s\\n\",\n\t\t\t    filename);\n\t\t\tclean_up_exit(1);\n\t\t}\n\t\trc = run_user_command(filename, latest_client, \"read_passwds\",\n\t\t    NULL, 0, in);\n\t\tif (rc != 0) {\n\t\t\trfbLog(\"run_user_command command failed: %s\\n\",\n\t\t\t    filename);\n\t\t\tclean_up_exit(1);\n\t\t}\n\t\trewind(in);\n\t} else if (strstr(filename, \"custom:\") == filename) {\n\t\treturn 1;\n\t}\n\n\tif (in == NULL && stat(filename, &sbuf) == 0) {\n\t\t/* (poor...) upper bound to number of lines */\n\t\tmax = (int) sbuf.st_size;\n\t\tlast_read = sbuf.st_mtime;\n\t}\n\n\t/* create 1 more than max to have it be the ending NULL */\n\tpasswd_list = (char **) malloc( (max+1) * (sizeof(char *)) );\n\tfor (i=0; i<max+1; i++) {\n\t\tpasswd_list[i] = NULL;\n\t}\n\t\n\tif (in == NULL) {\n\t\tin = fopen(filename, \"r\");\n\t}\n\tif (in == NULL) {\n\t\trfbLog(\"cannot open passwdfile: %s\\n\", passfile);\n\t\trfbLogPerror(\"fopen\");\n\t\tif (remove) {\n\t\t\tunlink(filename);\n\t\t}\n\t\tclean_up_exit(1);\n\t}\n\n\tif (getenv(\"DEBUG_PASSWDFILE\") != NULL) {\n\t\tdb_passwd = 1;\n\t}\n\n\twhile (fgets(line, sizeof line, in) != NULL) {\n\t\tchar *p;\n\t\tint blank = 1;\n\t\tint len = strlen(line); \n\n\t\tif (db_passwd) {\n\t\t\tfprintf(stderr, \"read_passwds: raw line: %s\\n\", line);\n\t\t}\n\n\t\tif (len == 0) {\n\t\t\tcontinue;\n\t\t} else if (line[len-1] == '\\n') {\n\t\t\tline[len-1] = '\\0';\n\t\t}\n\t\tif (line[0] == '\\0') {\n\t\t\tcontinue;\n\t\t}\n\t\tif (strstr(line, \"__SKIP__\") != NULL) {\n\t\t\tcontinue;\n\t\t}\n\t\tif (strstr(line, \"__COMM__\") == line) {\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strcmp(line, \"__BEGIN_VIEWONLY__\")) {\n\t\t\tif (begin_vo < 0) {\n\t\t\t\tbegin_vo = linecount;\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\t\tif (line[0] == '#') {\n\t\t\t/* commented out, cannot have password beginning with # */\n\t\t\tcontinue;\n\t\t}\n\t\tp = line;\n\t\twhile (*p != '\\0') {\n\t\t\tif (! isspace((unsigned char) (*p))) {\n\t\t\t\tblank = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tp++;\n\t\t}\n\t\tif (blank) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tpasswd_list[linecount++] = strdup(line);\n\t\tif (db_passwd) {\n\t\t\tfprintf(stderr, \"read_passwds: keepline: %s\\n\", line);\n\t\t\tfprintf(stderr, \"read_passwds: begin_vo: %d\\n\", begin_vo);\n\t\t}\n\n\t\tif (linecount >= max) {\n\t\t\trfbLog(\"read_passwds: hit max passwd: %d\\n\", max);\n\t\t\tbreak;\n\t\t}\n\t}\n\tfclose(in);\n\n\tfor (i=0; i<1024; i++) {\n\t\tline[i] = '\\0';\n\t}\n\n\tif (remove) {\n\t\tunlink(filename);\n\t}\n\n\tif (! linecount) {\n\t\trfbLog(\"cannot read a valid line from passwdfile: %s\\n\",\n\t\t    passfile);\n\t\tif (read_cnt == 0) {\n\t\t\tclean_up_exit(1);\n\t\t} else {\n\t\t\treturn 0;\n\t\t}\n\t}\n\tread_cnt++;\n\n\tfor (i=0; i<linecount; i++) {\n\t\tchar *q, *p = passwd_list[i];\n\t\tif (!strcmp(p, \"__EMPTY__\")) {\n\t\t\t*p = '\\0';\n\t\t} else if ((q = strstr(p, \"__COMM__\")) != NULL) {\n\t\t\t*q = '\\0';\n\t\t}\n\t\tpasswd_list[i] = strdup(p);\n\t\tif (db_passwd) {\n\t\t\tfprintf(stderr, \"read_passwds: trimline: %s\\n\", p);\n\t\t}\n\t\tstrzero(p);\n\t}\n\n\tbegin_viewonly = begin_vo;\n\tif (read_mode && read_cnt > 1) {\n\t\tif (viewonly_passwd) {\n\t\t\tfree(viewonly_passwd);\n\t\t\tviewonly_passwd = NULL;\n\t\t}\n\t}\n\n\tif (begin_viewonly < 0 && linecount == 2) {\n\t\t/* for compatibility with previous 2-line usage: */\n\t\tviewonly_passwd = strdup(passwd_list[1]);\n\t\tif (db_passwd) {\n\t\t\tfprintf(stderr, \"read_passwds: linecount is 2.\\n\");\n\t\t}\n\t\tif (screen) {\n\t\t\tchar **apd = (char **) screen->authPasswdData;\n\t\t\tif (apd) {\n\t\t\t\tif (apd[0] != NULL) {\n\t\t\t\t\tstrzero(apd[0]);\n\t\t\t\t}\n\t\t\t\tapd[0] = strdup(passwd_list[0]);\n\t\t\t}\n\t\t}\n\t\tbegin_viewonly = 1;\n\t}\n\n\tif (old_passwd_list != NULL) {\n\t\tchar *p;\n\t\ti = 0;\n\t\twhile (old_passwd_list[i] != NULL) {\n\t\t\tp = old_passwd_list[i];\n\t\t\tstrzero(p);\n\t\t\tfree(old_passwd_list[i]);\n\t\t\ti++;\n\t\t}\n\t\tfree(old_passwd_list);\n\t}\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "time",
          "args": [
            "NULL"
          ],
          "line": 1121
        },
        "resolved": true,
        "details": {
          "function_name": "vnc_redirect_timeout",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/user.c",
          "lines": "1395-1399",
          "snippet": "static void vnc_redirect_timeout (int sig) {\n\twrite(2, \"timeout: no clients connected.\\n\", 31);\n\tif (sig) {};\n\texit(0);\n}",
          "includes": [
            "#include \"avahi.h\"",
            "#include \"sslhelper.h\"",
            "#include \"remote.h\"",
            "#include \"cursor.h\"",
            "#include \"keyboard.h\"",
            "#include \"inet.h\"",
            "#include \"connections.h\"",
            "#include \"xwrappers.h\"",
            "#include \"sslhelper.h\"",
            "#include \"unixpw.h\"",
            "#include \"screen.h\"",
            "#include \"scan.h\"",
            "#include \"cleanup.h\"",
            "#include \"solid.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"avahi.h\"\n#include \"sslhelper.h\"\n#include \"remote.h\"\n#include \"cursor.h\"\n#include \"keyboard.h\"\n#include \"inet.h\"\n#include \"connections.h\"\n#include \"xwrappers.h\"\n#include \"sslhelper.h\"\n#include \"unixpw.h\"\n#include \"screen.h\"\n#include \"scan.h\"\n#include \"cleanup.h\"\n#include \"solid.h\"\n#include \"x11vnc.h\"\n\nstatic void vnc_redirect_timeout (int sig) {\n\twrite(2, \"timeout: no clients connected.\\n\", 31);\n\tif (sig) {};\n\texit(0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "passwdfile",
            "\"read:\""
          ],
          "line": 1112
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"avahi.h\"\n#include \"sslhelper.h\"\n#include \"remote.h\"\n#include \"cursor.h\"\n#include \"keyboard.h\"\n#include \"inet.h\"\n#include \"connections.h\"\n#include \"xwrappers.h\"\n#include \"sslhelper.h\"\n#include \"unixpw.h\"\n#include \"screen.h\"\n#include \"scan.h\"\n#include \"cleanup.h\"\n#include \"solid.h\"\n#include \"x11vnc.h\"\n\nvoid install_passwds(void);\nvoid check_new_passwds(int force);\n\nvoid check_new_passwds(int force) {\n\tstatic time_t last_check = 0;\n\ttime_t now;\n\n\tif (! passwdfile) {\n\t\treturn;\n\t}\n\tif (strstr(passwdfile, \"read:\") != passwdfile) {\n\t\treturn;\n\t}\n\tif (unixpw_in_progress) return;\n\n\tif (force) {\n\t\tlast_check = 0;\n\t}\n\n\tnow = time(NULL);\n\tif (now > last_check + 1) {\n\t\tif (read_passwds(passwdfile)) {\n\t\t\tinstall_passwds();\n\t\t}\n\t\tlast_check = now;\n\t}\n}"
  },
  {
    "function_name": "install_passwds",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/user.c",
    "lines": "1081-1103",
    "snippet": "void install_passwds(void) {\n\tif (viewonly_passwd) {\n\t\t/* append the view only passwd after the normal passwd */\n\t\tchar **passwds_new = (char **) malloc(3*sizeof(char *));\n\t\tchar **passwds_old = (char **) screen->authPasswdData;\n\t\tpasswds_new[0] = passwds_old[0];\n\t\tpasswds_new[1] = viewonly_passwd;\n\t\tpasswds_new[2] = NULL;\n\t\t/* mutex */\n\t\tscreen->authPasswdData = (void*) passwds_new;\n\t} else if (passwd_list) {\n\t\tint i = 0;\n\t\twhile(passwd_list[i] != NULL) {\n\t\t\ti++;\n\t\t}\n\t\tif (begin_viewonly < 0) {\n\t\t\tbegin_viewonly = i+1;\n\t\t}\n\t\t/* mutex */\n\t\tscreen->authPasswdData = (void*) passwd_list;\n\t\tscreen->authPasswdFirstViewOnly = begin_viewonly;\n\t}\n}",
    "includes": [
      "#include \"avahi.h\"",
      "#include \"sslhelper.h\"",
      "#include \"remote.h\"",
      "#include \"cursor.h\"",
      "#include \"keyboard.h\"",
      "#include \"inet.h\"",
      "#include \"connections.h\"",
      "#include \"xwrappers.h\"",
      "#include \"sslhelper.h\"",
      "#include \"unixpw.h\"",
      "#include \"screen.h\"",
      "#include \"scan.h\"",
      "#include \"cleanup.h\"",
      "#include \"solid.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "void install_passwds(void);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "3*sizeof(char *)"
          ],
          "line": 1084
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"avahi.h\"\n#include \"sslhelper.h\"\n#include \"remote.h\"\n#include \"cursor.h\"\n#include \"keyboard.h\"\n#include \"inet.h\"\n#include \"connections.h\"\n#include \"xwrappers.h\"\n#include \"sslhelper.h\"\n#include \"unixpw.h\"\n#include \"screen.h\"\n#include \"scan.h\"\n#include \"cleanup.h\"\n#include \"solid.h\"\n#include \"x11vnc.h\"\n\nvoid install_passwds(void);\n\nvoid install_passwds(void) {\n\tif (viewonly_passwd) {\n\t\t/* append the view only passwd after the normal passwd */\n\t\tchar **passwds_new = (char **) malloc(3*sizeof(char *));\n\t\tchar **passwds_old = (char **) screen->authPasswdData;\n\t\tpasswds_new[0] = passwds_old[0];\n\t\tpasswds_new[1] = viewonly_passwd;\n\t\tpasswds_new[2] = NULL;\n\t\t/* mutex */\n\t\tscreen->authPasswdData = (void*) passwds_new;\n\t} else if (passwd_list) {\n\t\tint i = 0;\n\t\twhile(passwd_list[i] != NULL) {\n\t\t\ti++;\n\t\t}\n\t\tif (begin_viewonly < 0) {\n\t\t\tbegin_viewonly = i+1;\n\t\t}\n\t\t/* mutex */\n\t\tscreen->authPasswdData = (void*) passwd_list;\n\t\tscreen->authPasswdFirstViewOnly = begin_viewonly;\n\t}\n}"
  },
  {
    "function_name": "read_passwds",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/user.c",
    "lines": "867-1079",
    "snippet": "int read_passwds(char *passfile) {\n\tchar line[1024];\n\tchar *filename;\n\tchar **old_passwd_list = passwd_list;\n\tint linecount = 0, i, remove = 0, read_mode = 0, begin_vo = -1;\n\tstruct stat sbuf;\n\tstatic int max = -1;\n\tFILE *in = NULL;\n\tstatic time_t last_read = 0;\n\tstatic int read_cnt = 0;\n\tint db_passwd = 0;\n\n\tif (max < 0) {\n\t\tmax = 1000;\n\t\tif (getenv(\"X11VNC_MAX_PASSWDS\")) {\n\t\t\tmax = atoi(getenv(\"X11VNC_MAX_PASSWDS\"));\n\t\t}\n\t}\n\n\tfilename = passfile;\n\tif (strstr(filename, \"rm:\") == filename) {\n\t\tfilename += strlen(\"rm:\");\n\t\tremove = 1;\n\t} else if (strstr(filename, \"read:\") == filename) {\n\t\tfilename += strlen(\"read:\");\n\t\tread_mode = 1;\n\t\tif (stat(filename, &sbuf) == 0) {\n\t\t\tif (sbuf.st_mtime <= last_read) {\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t\tlast_read = sbuf.st_mtime;\n\t\t}\n\t} else if (strstr(filename, \"cmd:\") == filename) {\n\t\tint rc;\n\n\t\tfilename += strlen(\"cmd:\");\n\t\tread_mode = 1;\n\t\tin = tmpfile();\n\t\tif (in == NULL) {\n\t\t\trfbLog(\"run_user_command tmpfile() failed: %s\\n\",\n\t\t\t    filename);\n\t\t\tclean_up_exit(1);\n\t\t}\n\t\trc = run_user_command(filename, latest_client, \"read_passwds\",\n\t\t    NULL, 0, in);\n\t\tif (rc != 0) {\n\t\t\trfbLog(\"run_user_command command failed: %s\\n\",\n\t\t\t    filename);\n\t\t\tclean_up_exit(1);\n\t\t}\n\t\trewind(in);\n\t} else if (strstr(filename, \"custom:\") == filename) {\n\t\treturn 1;\n\t}\n\n\tif (in == NULL && stat(filename, &sbuf) == 0) {\n\t\t/* (poor...) upper bound to number of lines */\n\t\tmax = (int) sbuf.st_size;\n\t\tlast_read = sbuf.st_mtime;\n\t}\n\n\t/* create 1 more than max to have it be the ending NULL */\n\tpasswd_list = (char **) malloc( (max+1) * (sizeof(char *)) );\n\tfor (i=0; i<max+1; i++) {\n\t\tpasswd_list[i] = NULL;\n\t}\n\t\n\tif (in == NULL) {\n\t\tin = fopen(filename, \"r\");\n\t}\n\tif (in == NULL) {\n\t\trfbLog(\"cannot open passwdfile: %s\\n\", passfile);\n\t\trfbLogPerror(\"fopen\");\n\t\tif (remove) {\n\t\t\tunlink(filename);\n\t\t}\n\t\tclean_up_exit(1);\n\t}\n\n\tif (getenv(\"DEBUG_PASSWDFILE\") != NULL) {\n\t\tdb_passwd = 1;\n\t}\n\n\twhile (fgets(line, sizeof line, in) != NULL) {\n\t\tchar *p;\n\t\tint blank = 1;\n\t\tint len = strlen(line); \n\n\t\tif (db_passwd) {\n\t\t\tfprintf(stderr, \"read_passwds: raw line: %s\\n\", line);\n\t\t}\n\n\t\tif (len == 0) {\n\t\t\tcontinue;\n\t\t} else if (line[len-1] == '\\n') {\n\t\t\tline[len-1] = '\\0';\n\t\t}\n\t\tif (line[0] == '\\0') {\n\t\t\tcontinue;\n\t\t}\n\t\tif (strstr(line, \"__SKIP__\") != NULL) {\n\t\t\tcontinue;\n\t\t}\n\t\tif (strstr(line, \"__COMM__\") == line) {\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strcmp(line, \"__BEGIN_VIEWONLY__\")) {\n\t\t\tif (begin_vo < 0) {\n\t\t\t\tbegin_vo = linecount;\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\t\tif (line[0] == '#') {\n\t\t\t/* commented out, cannot have password beginning with # */\n\t\t\tcontinue;\n\t\t}\n\t\tp = line;\n\t\twhile (*p != '\\0') {\n\t\t\tif (! isspace((unsigned char) (*p))) {\n\t\t\t\tblank = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tp++;\n\t\t}\n\t\tif (blank) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tpasswd_list[linecount++] = strdup(line);\n\t\tif (db_passwd) {\n\t\t\tfprintf(stderr, \"read_passwds: keepline: %s\\n\", line);\n\t\t\tfprintf(stderr, \"read_passwds: begin_vo: %d\\n\", begin_vo);\n\t\t}\n\n\t\tif (linecount >= max) {\n\t\t\trfbLog(\"read_passwds: hit max passwd: %d\\n\", max);\n\t\t\tbreak;\n\t\t}\n\t}\n\tfclose(in);\n\n\tfor (i=0; i<1024; i++) {\n\t\tline[i] = '\\0';\n\t}\n\n\tif (remove) {\n\t\tunlink(filename);\n\t}\n\n\tif (! linecount) {\n\t\trfbLog(\"cannot read a valid line from passwdfile: %s\\n\",\n\t\t    passfile);\n\t\tif (read_cnt == 0) {\n\t\t\tclean_up_exit(1);\n\t\t} else {\n\t\t\treturn 0;\n\t\t}\n\t}\n\tread_cnt++;\n\n\tfor (i=0; i<linecount; i++) {\n\t\tchar *q, *p = passwd_list[i];\n\t\tif (!strcmp(p, \"__EMPTY__\")) {\n\t\t\t*p = '\\0';\n\t\t} else if ((q = strstr(p, \"__COMM__\")) != NULL) {\n\t\t\t*q = '\\0';\n\t\t}\n\t\tpasswd_list[i] = strdup(p);\n\t\tif (db_passwd) {\n\t\t\tfprintf(stderr, \"read_passwds: trimline: %s\\n\", p);\n\t\t}\n\t\tstrzero(p);\n\t}\n\n\tbegin_viewonly = begin_vo;\n\tif (read_mode && read_cnt > 1) {\n\t\tif (viewonly_passwd) {\n\t\t\tfree(viewonly_passwd);\n\t\t\tviewonly_passwd = NULL;\n\t\t}\n\t}\n\n\tif (begin_viewonly < 0 && linecount == 2) {\n\t\t/* for compatibility with previous 2-line usage: */\n\t\tviewonly_passwd = strdup(passwd_list[1]);\n\t\tif (db_passwd) {\n\t\t\tfprintf(stderr, \"read_passwds: linecount is 2.\\n\");\n\t\t}\n\t\tif (screen) {\n\t\t\tchar **apd = (char **) screen->authPasswdData;\n\t\t\tif (apd) {\n\t\t\t\tif (apd[0] != NULL) {\n\t\t\t\t\tstrzero(apd[0]);\n\t\t\t\t}\n\t\t\t\tapd[0] = strdup(passwd_list[0]);\n\t\t\t}\n\t\t}\n\t\tbegin_viewonly = 1;\n\t}\n\n\tif (old_passwd_list != NULL) {\n\t\tchar *p;\n\t\ti = 0;\n\t\twhile (old_passwd_list[i] != NULL) {\n\t\t\tp = old_passwd_list[i];\n\t\t\tstrzero(p);\n\t\t\tfree(old_passwd_list[i]);\n\t\t\ti++;\n\t\t}\n\t\tfree(old_passwd_list);\n\t}\n\treturn 1;\n}",
    "includes": [
      "#include \"avahi.h\"",
      "#include \"sslhelper.h\"",
      "#include \"remote.h\"",
      "#include \"cursor.h\"",
      "#include \"keyboard.h\"",
      "#include \"inet.h\"",
      "#include \"connections.h\"",
      "#include \"xwrappers.h\"",
      "#include \"sslhelper.h\"",
      "#include \"unixpw.h\"",
      "#include \"screen.h\"",
      "#include \"scan.h\"",
      "#include \"cleanup.h\"",
      "#include \"solid.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "int read_passwds(char *passfile);",
      "rfbBool custom_passwd_check(rfbClientPtr cl, const char *response, int len);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "old_passwd_list"
          ],
          "line": 1076
        },
        "resolved": true,
        "details": {
          "function_name": "free_rect",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/userinput.c",
          "lines": "6200-6247",
          "snippet": "int free_rect(int idx) {\n\tint n, ok = 0;\n\tsraRegionPtr r1, r2;\n\tint x, y, w, h;\n\n\tif (idx < 0 || idx >= cache_list_num) {\nif (0) fprintf(stderr, \"free_rect: bad index: %d\\n\", idx);\n\t\tclean_up_exit(1);\n\t}\n\n\tx = cache_list[idx].bs_x;\n\ty = cache_list[idx].bs_y;\n\tw = cache_list[idx].bs_w;\n\th = cache_list[idx].bs_h;\n\n\tif (x < 0) {\n\t\tCLEAR(idx);\nif (dnow() > last_client + 5 && ncdb) fprintf(stderr, \"free_rect: already bs_x invalidated: %d bs_x: %d\\n\", idx, x);\n\t\treturn 1;\n\t}\n\n\tr2 = sraRgnCreateRect(x, y, x+w, y+h);\n\n\tn = get_bs_n(y);\n\tif (n >= 0) {\n\t\tr1 = rect_reg[n];\n\t\tsraRgnOr(r1, r2);\n\t\tok = 1;\n\t}\n\n\tif (zero_rects) {\n\t\tsraRgnOr(zero_rects, r2);\n\t\tx = cache_list[idx].su_x;\n\t\ty = cache_list[idx].su_y;\n\t\tw = cache_list[idx].su_w;\n\t\th = cache_list[idx].su_h;\n\t\tif (x >= 0) {\n\t\t\tsraRgnDestroy(r2);\n\t\t\tr2 = sraRgnCreateRect(x, y, x+w, y+h);\n\t\t\tsraRgnOr(zero_rects, r2);\n\t\t}\n\t}\n\tsraRgnDestroy(r2);\n\n\tCLEAR(idx);\nif (! ok && ncdb) fprintf(stderr, \"**** free_rect: not-found %d\\n\", idx);\n\treturn ok;\n}",
          "includes": [
            "#include \"default8x16.h\"",
            "#include \"connections.h\"",
            "#include \"screen.h\"",
            "#include \"cursor.h\"",
            "#include \"macosxCGS.h\"",
            "#include \"macosx.h\"",
            "#include \"unixpw.h\"",
            "#include \"8to24.h\"",
            "#include \"xrandr.h\"",
            "#include \"solid.h\"",
            "#include \"keyboard.h\"",
            "#include \"rates.h\"",
            "#include \"pointer.h\"",
            "#include \"cleanup.h\"",
            "#include \"scan.h\"",
            "#include \"user.h\"",
            "#include \"xevents.h\"",
            "#include \"win_utils.h\"",
            "#include \"xinerama.h\"",
            "#include \"xrecord.h\"",
            "#include \"xdamage.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void mark_for_xdamage(int x, int y, int w, int h);",
            "void set_xdamage_mark(int x, int y, int w, int h);",
            "int find_rect(int idx, int x, int y, int w, int h);",
            "winattr_t *cache_list;",
            "int clipped(int idx);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"default8x16.h\"\n#include \"connections.h\"\n#include \"screen.h\"\n#include \"cursor.h\"\n#include \"macosxCGS.h\"\n#include \"macosx.h\"\n#include \"unixpw.h\"\n#include \"8to24.h\"\n#include \"xrandr.h\"\n#include \"solid.h\"\n#include \"keyboard.h\"\n#include \"rates.h\"\n#include \"pointer.h\"\n#include \"cleanup.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"xevents.h\"\n#include \"win_utils.h\"\n#include \"xinerama.h\"\n#include \"xrecord.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nvoid mark_for_xdamage(int x, int y, int w, int h);\nvoid set_xdamage_mark(int x, int y, int w, int h);\nint find_rect(int idx, int x, int y, int w, int h);\nwinattr_t *cache_list;\nint clipped(int idx);\n\nint free_rect(int idx) {\n\tint n, ok = 0;\n\tsraRegionPtr r1, r2;\n\tint x, y, w, h;\n\n\tif (idx < 0 || idx >= cache_list_num) {\nif (0) fprintf(stderr, \"free_rect: bad index: %d\\n\", idx);\n\t\tclean_up_exit(1);\n\t}\n\n\tx = cache_list[idx].bs_x;\n\ty = cache_list[idx].bs_y;\n\tw = cache_list[idx].bs_w;\n\th = cache_list[idx].bs_h;\n\n\tif (x < 0) {\n\t\tCLEAR(idx);\nif (dnow() > last_client + 5 && ncdb) fprintf(stderr, \"free_rect: already bs_x invalidated: %d bs_x: %d\\n\", idx, x);\n\t\treturn 1;\n\t}\n\n\tr2 = sraRgnCreateRect(x, y, x+w, y+h);\n\n\tn = get_bs_n(y);\n\tif (n >= 0) {\n\t\tr1 = rect_reg[n];\n\t\tsraRgnOr(r1, r2);\n\t\tok = 1;\n\t}\n\n\tif (zero_rects) {\n\t\tsraRgnOr(zero_rects, r2);\n\t\tx = cache_list[idx].su_x;\n\t\ty = cache_list[idx].su_y;\n\t\tw = cache_list[idx].su_w;\n\t\th = cache_list[idx].su_h;\n\t\tif (x >= 0) {\n\t\t\tsraRgnDestroy(r2);\n\t\t\tr2 = sraRgnCreateRect(x, y, x+w, y+h);\n\t\t\tsraRgnOr(zero_rects, r2);\n\t\t}\n\t}\n\tsraRgnDestroy(r2);\n\n\tCLEAR(idx);\nif (! ok && ncdb) fprintf(stderr, \"**** free_rect: not-found %d\\n\", idx);\n\treturn ok;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strzero",
          "args": [
            "p"
          ],
          "line": 1072
        },
        "resolved": true,
        "details": {
          "function_name": "strzero",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/util.c",
          "lines": "171-179",
          "snippet": "void strzero(char *str) {\n\tchar *p = str;\n\tif (p != NULL) {\n\t\twhile (*p != '\\0') {\n\t\t\t*p = '\\0';\n\t\t\tp++;\n\t\t}\n\t}\n}",
          "includes": [
            "#include \"connections.h\"",
            "#include \"unixpw.h\"",
            "#include \"win_utils.h\"",
            "#include \"cleanup.h\"",
            "#include \"x11vnc.h\"",
            "#include <stdlib.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void lowercase(char *str);",
            "void uppercase(char *str);",
            "char *lblanks(char *str);",
            "void strzero(char *str);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"connections.h\"\n#include \"unixpw.h\"\n#include \"win_utils.h\"\n#include \"cleanup.h\"\n#include \"x11vnc.h\"\n#include <stdlib.h>\n\nvoid lowercase(char *str);\nvoid uppercase(char *str);\nchar *lblanks(char *str);\nvoid strzero(char *str);\n\nvoid strzero(char *str) {\n\tchar *p = str;\n\tif (p != NULL) {\n\t\twhile (*p != '\\0') {\n\t\t\t*p = '\\0';\n\t\t\tp++;\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "passwd_list[0]"
          ],
          "line": 1061
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"read_passwds: linecount is 2.\\n\""
          ],
          "line": 1053
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "passwd_list[1]"
          ],
          "line": 1051
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"read_passwds: trimline: %s\\n\"",
            "p"
          ],
          "line": 1036
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "p"
          ],
          "line": 1034
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "p",
            "\"__COMM__\""
          ],
          "line": 1031
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "p",
            "\"__EMPTY__\""
          ],
          "line": 1029
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clean_up_exit",
          "args": [
            "1"
          ],
          "line": 1020
        },
        "resolved": true,
        "details": {
          "function_name": "clean_up_exit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/cleanup.c",
          "lines": "151-266",
          "snippet": "void clean_up_exit(int ret) {\n\tstatic int depth = 0;\n\texit_flag = 1;\n\n\tif (depth++ > 2) {\n\t\texit(ret);\n\t}\n\n\tif (icon_mode) {\n\t\tclean_icon_mode();\n\t}\n\n\t/* remove the shm areas: */\n\tclean_shm(0);\n\n\tstop_stunnel();\n\tif (use_openssl) {\n\t\tssl_helper_pid(0, 0);\t/* killall */\n\t}\n\n\tif (ssh_pid > 0) {\n\t\tkill(ssh_pid, SIGTERM);\n\t\tssh_pid = 0;\n\t}\n\n#ifdef MACOSX\n\tif (client_connect_file) {\n\t\tif (strstr(client_connect_file, \"/tmp/x11vnc-macosx-remote\")\n\t\t    == client_connect_file) {\n\t\t\tunlink(client_connect_file);\n\t\t}\n\t}\n\tif (macosx_console) {\n\t\tmacosxCG_fini();\n\t}\n#endif\n\n\tif (pipeinput_fh != NULL) {\n\t\tpclose(pipeinput_fh);\n\t\tpipeinput_fh = NULL;\n\t}\n\n\tshutdown_uinput();\n\n\tif (unix_sock) {\n\t\tif (unix_sock_fd >= 0) {\n\t\t\trfbLog(\"deleting unix sock: %s\\n\", unix_sock);\n\t\t\tclose(unix_sock_fd);\n\t\t\tunix_sock_fd = -1;\n\t\t\tunlink(unix_sock);\n\t\t}\n\t}\n\n\tif (! dpy) {\t/* raw_rb hack */\n\t\tif (rm_flagfile) {\n\t\t\tunlink(rm_flagfile);\n\t\t\trm_flagfile = NULL;\n\t\t}\n\t\texit(ret);\n\t}\n\n\t/* X keyboard cleanups */\n\tdelete_added_keycodes(0);\n\n\t/* remove all created XInput2 devices */\n\tif(use_multipointer)\n\t    removeAllMDs(dpy);\n\n\tif (clear_mods == 1) {\n\t\tclear_modifiers(0);\n\t} else if (clear_mods == 2) {\n\t\tclear_keys();\n\t} else if (clear_mods == 3) {\n\t\tclear_keys();\n\t\tclear_locks();\n\t}\n\n\tif (no_autorepeat) {\n\t\tautorepeat(1, 0);\n\t}\n\tif (use_solid_bg) {\n\t\tsolid_bg(1);\n\t}\n\tif (ncache || ncache0) {\n\t\tkde_no_animate(1);\n\t}\n\tX_LOCK;\n\tXTestDiscard_wr(dpy);\n#if HAVE_LIBXDAMAGE\n\tif (xdamage) {\n\t\tXDamageDestroy(dpy, xdamage);\n\t}\n#endif\n#if HAVE_LIBXTRAP\n\tif (trap_ctx) {\n\t\tXEFreeTC(trap_ctx);\n\t}\n#endif\n\t/* XXX rdpy_ctrl, etc. cannot close w/o blocking */\n\tXCloseDisplay_wr(dpy);\n\tX_UNLOCK;\n\n\tfflush(stderr);\n\n\tif (rm_flagfile) {\n\t\tunlink(rm_flagfile);\n\t\trm_flagfile = NULL;\n\t}\n\n\tif (avahi) {\n\t\tavahi_cleanup();\n\t\tfflush(stderr);\n\t}\n\n\texit(ret);\n}",
          "includes": [
            "#include \"xi2_devices.h\"",
            "#include \"uinput.h\"",
            "#include \"xevents.h\"",
            "#include \"xrecord.h\"",
            "#include \"screen.h\"",
            "#include \"avahi.h\"",
            "#include \"macosxCG.h\"",
            "#include \"macosx.h\"",
            "#include \"connections.h\"",
            "#include \"sslhelper.h\"",
            "#include \"sslcmds.h\"",
            "#include \"unixpw.h\"",
            "#include \"solid.h\"",
            "#include \"gui.h\"",
            "#include \"scan.h\"",
            "#include \"keyboard.h\"",
            "#include \"remote.h\"",
            "#include \"xdamage.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void clean_up_exit(int ret);",
            "int known_sigpipe_mode(char *s);",
            "static int exit_flag = 0;",
            "static void clean_icon_mode(void);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xi2_devices.h\"\n#include \"uinput.h\"\n#include \"xevents.h\"\n#include \"xrecord.h\"\n#include \"screen.h\"\n#include \"avahi.h\"\n#include \"macosxCG.h\"\n#include \"macosx.h\"\n#include \"connections.h\"\n#include \"sslhelper.h\"\n#include \"sslcmds.h\"\n#include \"unixpw.h\"\n#include \"solid.h\"\n#include \"gui.h\"\n#include \"scan.h\"\n#include \"keyboard.h\"\n#include \"remote.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nvoid clean_up_exit(int ret);\nint known_sigpipe_mode(char *s);\nstatic int exit_flag = 0;\nstatic void clean_icon_mode(void);\n\nvoid clean_up_exit(int ret) {\n\tstatic int depth = 0;\n\texit_flag = 1;\n\n\tif (depth++ > 2) {\n\t\texit(ret);\n\t}\n\n\tif (icon_mode) {\n\t\tclean_icon_mode();\n\t}\n\n\t/* remove the shm areas: */\n\tclean_shm(0);\n\n\tstop_stunnel();\n\tif (use_openssl) {\n\t\tssl_helper_pid(0, 0);\t/* killall */\n\t}\n\n\tif (ssh_pid > 0) {\n\t\tkill(ssh_pid, SIGTERM);\n\t\tssh_pid = 0;\n\t}\n\n#ifdef MACOSX\n\tif (client_connect_file) {\n\t\tif (strstr(client_connect_file, \"/tmp/x11vnc-macosx-remote\")\n\t\t    == client_connect_file) {\n\t\t\tunlink(client_connect_file);\n\t\t}\n\t}\n\tif (macosx_console) {\n\t\tmacosxCG_fini();\n\t}\n#endif\n\n\tif (pipeinput_fh != NULL) {\n\t\tpclose(pipeinput_fh);\n\t\tpipeinput_fh = NULL;\n\t}\n\n\tshutdown_uinput();\n\n\tif (unix_sock) {\n\t\tif (unix_sock_fd >= 0) {\n\t\t\trfbLog(\"deleting unix sock: %s\\n\", unix_sock);\n\t\t\tclose(unix_sock_fd);\n\t\t\tunix_sock_fd = -1;\n\t\t\tunlink(unix_sock);\n\t\t}\n\t}\n\n\tif (! dpy) {\t/* raw_rb hack */\n\t\tif (rm_flagfile) {\n\t\t\tunlink(rm_flagfile);\n\t\t\trm_flagfile = NULL;\n\t\t}\n\t\texit(ret);\n\t}\n\n\t/* X keyboard cleanups */\n\tdelete_added_keycodes(0);\n\n\t/* remove all created XInput2 devices */\n\tif(use_multipointer)\n\t    removeAllMDs(dpy);\n\n\tif (clear_mods == 1) {\n\t\tclear_modifiers(0);\n\t} else if (clear_mods == 2) {\n\t\tclear_keys();\n\t} else if (clear_mods == 3) {\n\t\tclear_keys();\n\t\tclear_locks();\n\t}\n\n\tif (no_autorepeat) {\n\t\tautorepeat(1, 0);\n\t}\n\tif (use_solid_bg) {\n\t\tsolid_bg(1);\n\t}\n\tif (ncache || ncache0) {\n\t\tkde_no_animate(1);\n\t}\n\tX_LOCK;\n\tXTestDiscard_wr(dpy);\n#if HAVE_LIBXDAMAGE\n\tif (xdamage) {\n\t\tXDamageDestroy(dpy, xdamage);\n\t}\n#endif\n#if HAVE_LIBXTRAP\n\tif (trap_ctx) {\n\t\tXEFreeTC(trap_ctx);\n\t}\n#endif\n\t/* XXX rdpy_ctrl, etc. cannot close w/o blocking */\n\tXCloseDisplay_wr(dpy);\n\tX_UNLOCK;\n\n\tfflush(stderr);\n\n\tif (rm_flagfile) {\n\t\tunlink(rm_flagfile);\n\t\trm_flagfile = NULL;\n\t}\n\n\tif (avahi) {\n\t\tavahi_cleanup();\n\t\tfflush(stderr);\n\t}\n\n\texit(ret);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"cannot read a valid line from passwdfile: %s\\n\"",
            "passfile"
          ],
          "line": 1017
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlink",
          "args": [
            "filename"
          ],
          "line": 1013
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fclose",
          "args": [
            "in"
          ],
          "line": 1006
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"read_passwds: hit max passwd: %d\\n\"",
            "max"
          ],
          "line": 1002
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"read_passwds: begin_vo: %d\\n\"",
            "begin_vo"
          ],
          "line": 998
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"read_passwds: keepline: %s\\n\"",
            "line"
          ],
          "line": 997
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "line"
          ],
          "line": 995
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isspace",
          "args": [
            "(unsigned char) (*p)"
          ],
          "line": 985
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "line",
            "\"__BEGIN_VIEWONLY__\""
          ],
          "line": 973
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "line",
            "\"__COMM__\""
          ],
          "line": 970
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "line",
            "\"__SKIP__\""
          ],
          "line": 967
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"read_passwds: raw line: %s\\n\"",
            "line"
          ],
          "line": 956
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "line"
          ],
          "line": 953
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fgets",
          "args": [
            "line",
            "sizeof line",
            "in"
          ],
          "line": 950
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getenv",
          "args": [
            "\"DEBUG_PASSWDFILE\""
          ],
          "line": 946
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlink",
          "args": [
            "filename"
          ],
          "line": 941
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLogPerror",
          "args": [
            "\"fopen\""
          ],
          "line": 939
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"cannot open passwdfile: %s\\n\"",
            "passfile"
          ],
          "line": 938
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fopen",
          "args": [
            "filename",
            "\"r\""
          ],
          "line": 935
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "(max+1) * (sizeof(char *))"
          ],
          "line": 929
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "stat",
          "args": [
            "filename",
            "&sbuf"
          ],
          "line": 922
        },
        "resolved": true,
        "details": {
          "function_name": "grab_state",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/connections.c",
          "lines": "3178-3224",
          "snippet": "void grab_state(int *ptr_grabbed, int *kbd_grabbed) {\n\tint rcp, rck;\n\tdouble t0, t1;\n\tdouble ta, tb, tc;\n\t*ptr_grabbed = -1;\n\t*kbd_grabbed = -1;\n\n\tif (!dpy) {\n\t\treturn;\n\t}\n\t*ptr_grabbed = 0;\n\t*kbd_grabbed = 0;\n\n#if !NO_X11\n\tX_LOCK;\n\n\tXSync(dpy, False);\n\n\tta = t0 = dnow();\n\n\trcp = XGrabPointer(dpy, window, False, 0, GrabModeAsync, GrabModeAsync, None, None, CurrentTime);\n\tXUngrabPointer(dpy, CurrentTime);\n\n\ttb = dnow();\n\t\n\trck = XGrabKeyboard(dpy, window, False, GrabModeAsync, GrabModeAsync, CurrentTime);\n\tXUngrabKeyboard(dpy, CurrentTime);\n\n\ttc = dnow();\n\n\tXSync(dpy, False);\n\n\tt1 = dnow();\n\n\tX_UNLOCK;\n\tif (rcp == AlreadyGrabbed || rcp == GrabFrozen) {\n\t\t*ptr_grabbed = 1;\n\t}\n\tif (rck == AlreadyGrabbed || rck == GrabFrozen) {\n\t\t*kbd_grabbed = 1;\n\t}\n\tif (rc_npieces < 10) {\n\t\trfbLog(\"grab_state: checked %d,%d in %.6f sec (%.6f %.6f)\\n\",\n\t\t    *ptr_grabbed, *kbd_grabbed, t1-t0, tb-ta, tc-tb);\n\t}\n#endif\n}",
          "includes": [
            "#include \"xi2_devices.h\"",
            "#include \"xrandr.h\"",
            "#include \"pointer.h\"",
            "#include \"userinput.h\"",
            "#include \"macosxCG.h\"",
            "#include \"macosx.h\"",
            "#include \"win_utils.h\"",
            "#include \"xevents.h\"",
            "#include \"xwrappers.h\"",
            "#include \"sslhelper.h\"",
            "#include \"sslcmds.h\"",
            "#include \"scan.h\"",
            "#include \"user.h\"",
            "#include \"unixpw.h\"",
            "#include \"screen.h\"",
            "#include \"rates.h\"",
            "#include \"solid.h\"",
            "#include \"gui.h\"",
            "#include \"cleanup.h\"",
            "#include \"keyboard.h\"",
            "#include \"remote.h\"",
            "#include \"inet.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void grab_state(int *ptr_grabbed, int *kbd_grabbed);",
            "extern int rc_npieces;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xi2_devices.h\"\n#include \"xrandr.h\"\n#include \"pointer.h\"\n#include \"userinput.h\"\n#include \"macosxCG.h\"\n#include \"macosx.h\"\n#include \"win_utils.h\"\n#include \"xevents.h\"\n#include \"xwrappers.h\"\n#include \"sslhelper.h\"\n#include \"sslcmds.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"unixpw.h\"\n#include \"screen.h\"\n#include \"rates.h\"\n#include \"solid.h\"\n#include \"gui.h\"\n#include \"cleanup.h\"\n#include \"keyboard.h\"\n#include \"remote.h\"\n#include \"inet.h\"\n#include \"x11vnc.h\"\n\nvoid grab_state(int *ptr_grabbed, int *kbd_grabbed);\nextern int rc_npieces;\n\nvoid grab_state(int *ptr_grabbed, int *kbd_grabbed) {\n\tint rcp, rck;\n\tdouble t0, t1;\n\tdouble ta, tb, tc;\n\t*ptr_grabbed = -1;\n\t*kbd_grabbed = -1;\n\n\tif (!dpy) {\n\t\treturn;\n\t}\n\t*ptr_grabbed = 0;\n\t*kbd_grabbed = 0;\n\n#if !NO_X11\n\tX_LOCK;\n\n\tXSync(dpy, False);\n\n\tta = t0 = dnow();\n\n\trcp = XGrabPointer(dpy, window, False, 0, GrabModeAsync, GrabModeAsync, None, None, CurrentTime);\n\tXUngrabPointer(dpy, CurrentTime);\n\n\ttb = dnow();\n\t\n\trck = XGrabKeyboard(dpy, window, False, GrabModeAsync, GrabModeAsync, CurrentTime);\n\tXUngrabKeyboard(dpy, CurrentTime);\n\n\ttc = dnow();\n\n\tXSync(dpy, False);\n\n\tt1 = dnow();\n\n\tX_UNLOCK;\n\tif (rcp == AlreadyGrabbed || rcp == GrabFrozen) {\n\t\t*ptr_grabbed = 1;\n\t}\n\tif (rck == AlreadyGrabbed || rck == GrabFrozen) {\n\t\t*kbd_grabbed = 1;\n\t}\n\tif (rc_npieces < 10) {\n\t\trfbLog(\"grab_state: checked %d,%d in %.6f sec (%.6f %.6f)\\n\",\n\t\t    *ptr_grabbed, *kbd_grabbed, t1-t0, tb-ta, tc-tb);\n\t}\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "filename",
            "\"custom:\""
          ],
          "line": 918
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rewind",
          "args": [
            "in"
          ],
          "line": 917
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"run_user_command command failed: %s\\n\"",
            "filename"
          ],
          "line": 913
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "run_user_command",
          "args": [
            "filename",
            "latest_client",
            "\"read_passwds\"",
            "NULL",
            "0",
            "in"
          ],
          "line": 910
        },
        "resolved": true,
        "details": {
          "function_name": "run_user_command",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/connections.c",
          "lines": "466-763",
          "snippet": "int run_user_command(char *cmd, rfbClientPtr client, char *mode, char *input,\n   int len, FILE *output) {\n\tchar *old_display = NULL;\n\tchar *addr = NULL;\n\tchar str[100];\n\tint rc, ok;\n\tClientData *cd = NULL;\n\tclient_set_net(client);\n\tif (client != NULL) {\n\t\tcd = (ClientData *) client->clientData;\n\t\taddr = client->host;\n\t}\n\n\tif (addr == NULL || addr[0] == '\\0') {\n\t\taddr = \"unknown-host\";\n\t}\n\n\t/* set RFB_CLIENT_ID to semi unique id for command to use */\n\tif (cd && cd->uid) {\n\t\tsprintf(str, \"0x%x\", cd->uid);\n\t} else {\n\t\t/* not accepted yet: */\n\t\tsprintf(str, \"0x%x\", clients_served);\n\t}\n\tset_env(\"RFB_CLIENT_ID\", str);\n\n\t/* set RFB_CLIENT_IP to IP addr for command to use */\n\tset_env(\"RFB_CLIENT_IP\", addr);\n\n\t/* set RFB_X11VNC_PID to our pid for command to use */\n\tsprintf(str, \"%d\", (int) getpid());\n\tset_env(\"RFB_X11VNC_PID\", str);\n\n\tif (client == NULL) {\n\t\t;\n\t} else if (client->state == RFB_PROTOCOL_VERSION) {\n\t\tset_env(\"RFB_STATE\", \"PROTOCOL_VERSION\");\n\t} else if (client->state == RFB_SECURITY_TYPE) {\n\t\tset_env(\"RFB_STATE\", \"SECURITY_TYPE\");\n\t} else if (client->state == RFB_AUTHENTICATION) {\n\t\tset_env(\"RFB_STATE\", \"AUTHENTICATION\");\n\t} else if (client->state == RFB_INITIALISATION) {\n\t\tset_env(\"RFB_STATE\", \"INITIALISATION\");\n\t} else if (client->state == RFB_NORMAL) {\n\t\tset_env(\"RFB_STATE\", \"NORMAL\");\n\t} else {\n\t\tset_env(\"RFB_STATE\", \"UNKNOWN\");\n\t}\n\tif (certret_str) {\n\t\tset_env(\"RFB_SSL_CLIENT_CERT\", certret_str);\n\t} else {\n\t\tset_env(\"RFB_SSL_CLIENT_CERT\", \"\");\n\t}\n\n\t/* set RFB_CLIENT_PORT to peer port for command to use */\n\tif (cd && cd->client_port > 0) {\n\t\tsprintf(str, \"%d\", cd->client_port);\n\t} else if (client) {\n\t\tsprintf(str, \"%d\", get_remote_port(client->sock));\n\t}\n\tset_env(\"RFB_CLIENT_PORT\", str);\n\n\tset_env(\"RFB_MODE\", mode);\n\n\t/* \n\t * now do RFB_SERVER_IP and RFB_SERVER_PORT (i.e. us!)\n\t * This will establish a 5-tuple (including tcp) the external\n\t * program can potentially use to work out the virtual circuit\n\t * for this connection.\n\t */\n\tif (cd && cd->server_ip) {\n\t\tset_env(\"RFB_SERVER_IP\", cd->server_ip);\n\t} else if (client) {\n\t\tchar *sip = get_local_host(client->sock);\n\t\tset_env(\"RFB_SERVER_IP\", sip);\n\t\tif (sip) free(sip);\n\t}\n\n\tif (cd && cd->server_port > 0) {\n\t\tsprintf(str, \"%d\", cd->server_port);\n\t} else if (client) {\n\t\tsprintf(str, \"%d\", get_local_port(client->sock));\n\t}\n\tset_env(\"RFB_SERVER_PORT\", str);\n\n\tif (cd) {\n\t\tsprintf(str, \"%d\", cd->login_viewonly);\n\t} else {\n\t\tsprintf(str, \"%d\", -1);\n\t}\n\tset_env(\"RFB_LOGIN_VIEWONLY\", str);\n\n\tif (cd) {\n\t\tsprintf(str, \"%d\", (int) cd->login_time);\n\t} else {\n\t\tsprintf(str, \">%d\", (int) time(NULL));\n\t}\n\tset_env(\"RFB_LOGIN_TIME\", str);\n\n\tsprintf(str, \"%d\", (int) time(NULL));\n\tset_env(\"RFB_CURRENT_TIME\", str);\n\n\tif (!cd || !cd->username || cd->username[0] == '\\0') {\n\t\tset_env(\"RFB_USERNAME\", \"unknown-user\");\n\t} else {\n\t\tset_env(\"RFB_USERNAME\", cd->username);\n\t}\n\t/* \n\t * Better set DISPLAY to the one we are polling, if they\n\t * want something trickier, they can handle on their own\n\t * via environment, etc. \n\t */\n\tif (getenv(\"DISPLAY\")) {\n\t\told_display = strdup(getenv(\"DISPLAY\"));\n\t}\n\n\tif (raw_fb && ! dpy) {\t/* raw_fb hack */\n\t\tset_env(\"DISPLAY\", \"rawfb\");\n\t} else {\n\t\tset_env(\"DISPLAY\", DisplayString(dpy));\n\t}\n\n\t/*\n\t * work out the number of clients (have to use client_count\n\t * since there is deadlock in rfbGetClientIterator) \n\t */\n\tsprintf(str, \"%d\", client_count);\n\tset_env(\"RFB_CLIENT_COUNT\", str);\n\n\t/* gone, accept, afteraccept */\n\tok = 0;\n\tif (!strcmp(mode, \"env\")) {\n\t\treturn 1;\n\t}\n\tif (!strcmp(mode, \"accept\") && cmd_ok(\"accept\")) {\n\t\tok = 1;\n\t}\n\tif (!strcmp(mode, \"afteraccept\") && cmd_ok(\"afteraccept\")) {\n\t\tok = 1;\n\t}\n\tif (!strcmp(mode, \"gone\") && cmd_ok(\"gone\")) {\n\t\tok = 1;\n\t}\n\tif (!strcmp(mode, \"cmd_verify\") && cmd_ok(\"unixpw\")) {\n\t\tok = 1;\n\t}\n\tif (!strcmp(mode, \"read_passwds\") && cmd_ok(\"passwdfile\")) {\n\t\tok = 1;\n\t}\n\tif (!strcmp(mode, \"custom_passwd\") && cmd_ok(\"custom_passwd\")) {\n\t\tok = 1;\n\t}\n\tif (no_external_cmds || !ok) {\n\t\trfbLogEnable(1);\n\t\trfbLog(\"cannot run external commands in -nocmds mode:\\n\");\n\t\trfbLog(\"   \\\"%s\\\"\\n\", cmd);\n\t\trfbLog(\"   exiting.\\n\");\n\t\tclean_up_exit(1);\n\t}\n\trfbLog(\"running command:\\n\");\n\tif (!quiet) {\n\t\tfprintf(stderr, \"\\n  %s\\n\\n\", cmd);\n\t}\n\tclose_exec_fds();\n\n\tif (output != NULL) {\n\t\tFILE *ph;\n\t\tchar line[1024];\n\t\tchar *cmd2 = NULL;\n\t\tchar tmp[] = \"/tmp/x11vnc-tmp.XXXXXX\";\n\t\tint deltmp = 0;\n\n\t\tif (input != NULL) {\n\t\t\tint tmp_fd = mkstemp(tmp);\n\t\t\tif (tmp_fd < 0) {\n\t\t\t\trfbLog(\"mkstemp failed on: %s\\n\", tmp);\n\t\t\t\tclean_up_exit(1);\n\t\t\t}\n\t\t\twrite(tmp_fd, input, len);\n\t\t\tclose(tmp_fd);\n\t\t\tdeltmp = 1;\n\t\t\tcmd2 = (char *) malloc(100 + strlen(tmp) + strlen(cmd));\n\t\t\tsprintf(cmd2, \"/bin/cat %s | %s\", tmp, cmd);\n\t\t\t\n\t\t\tph = popen(cmd2, \"r\");\n\t\t} else {\n\t\t\tph = popen(cmd, \"r\");\n\t\t}\n\t\tif (ph == NULL) {\n\t\t\trfbLog(\"popen(%s) failed\", cmd);\n\t\t\trfbLogPerror(\"popen\");\n\t\t\tclean_up_exit(1);\n\t\t}\n\t\tmemset(line, 0, sizeof(line));\n\t\twhile (fgets(line, sizeof(line), ph) != NULL) {\n\t\t\tint j, k = -1;\n\t\t\tif (0) fprintf(stderr, \"line: %s\", line);\n\t\t\t/* take care to handle embedded nulls */\n\t\t\tfor (j=0; j < (int) sizeof(line); j++) {\n\t\t\t\tif (line[j] != '\\0') {\n\t\t\t\t\tk = j;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (k >= 0) {\n\t\t\t\twrite(fileno(output), line, k+1);\n\t\t\t}\n\t\t\tmemset(line, 0, sizeof(line));\n\t\t}\n\n\t\trc = pclose(ph);\n\n\t\tif (cmd2 != NULL) {\n\t\t\tfree(cmd2);\n\t\t}\n\t\tif (deltmp) {\n\t\t\tunlink(tmp);\n\t\t}\n\t\tgoto got_rc;\n\t} else if (input != NULL) {\n\t\tFILE *ph = popen(cmd, \"w\");\n\t\tif (ph == NULL) {\n\t\t\trfbLog(\"popen(%s) failed\", cmd);\n\t\t\trfbLogPerror(\"popen\");\n\t\t\tclean_up_exit(1);\n\t\t}\n\t\twrite(fileno(ph), input, len);\n\t\trc = pclose(ph);\n\t\tgoto got_rc;\n\t}\n\n#if LIBVNCSERVER_HAVE_FORK\n\t{\n\t\tpid_t pid;\n\t\tstruct sigaction sa, intr, quit;\n\t\tsigset_t omask;\n\n\t\tsa.sa_handler = SIG_IGN;\n\t\tsa.sa_flags = 0;\n\t\tsigemptyset(&sa.sa_mask);\n\t\tsigaction(SIGINT,  &sa, &intr);\n\t\tsigaction(SIGQUIT, &sa, &quit);\n\n\t\tsigaddset(&sa.sa_mask, SIGCHLD);\n\t\tsigprocmask(SIG_BLOCK, &sa.sa_mask, &omask);\n\n\t\tif ((pid = fork()) > 0 || pid == -1) {\n\n\t\t\tif (pid != -1) {\n\t\t\t\twaitpid(pid, &rc, 0);\n\t\t\t}\n\n\t\t\tsigaction(SIGINT,  &intr, (struct sigaction *) NULL);\n\t\t\tsigaction(SIGQUIT, &quit, (struct sigaction *) NULL);\n\t\t\tsigprocmask(SIG_SETMASK, &omask, (sigset_t *) NULL);\n\n\t\t\tif (pid == -1) {\n\t\t\t\tfprintf(stderr, \"could not fork\\n\");\n\t\t\t\trfbLogPerror(\"fork\");\n\t\t\t\trc = system(cmd);\n\t\t\t}\n\t\t} else {\n\t\t\t/* this should close port 5900, etc.. */\n\t\t\tint fd;\n\t\t\tsigaction(SIGINT,  &intr, (struct sigaction *) NULL);\n\t\t\tsigaction(SIGQUIT, &quit, (struct sigaction *) NULL);\n\t\t\tsigprocmask(SIG_SETMASK, &omask, (sigset_t *) NULL);\n\t\t\tfor (fd=3; fd<256; fd++) {\n\t\t\t\tclose(fd);\n\t\t\t}\n/* XXX test more */\n\t\t\tif (!strcmp(mode, \"gone\")) {\n#if HAVE_SETSID\n\t\t\t\tsetsid();\n#else\n\t\t\t\tsetpgrp();\n#endif\n\t\t\t}\n\t\t\texeclp(\"/bin/sh\", \"/bin/sh\", \"-c\", cmd, (char *) NULL);\n\t\t\texit(1);\n\t\t}\n\t}\n#else\n\trc = system(cmd);\n#endif\n\tgot_rc:\n\n\tif (rc >= 256) {\n\t\trc = rc/256;\n\t}\n\trfbLog(\"command returned: %d\\n\", rc);\n\n\tif (old_display) {\n\t\tset_env(\"DISPLAY\", old_display);\n\t\tfree(old_display);\n\t}\n\n\treturn rc;\n}",
          "includes": [
            "#include \"xi2_devices.h\"",
            "#include \"xrandr.h\"",
            "#include \"pointer.h\"",
            "#include \"userinput.h\"",
            "#include \"macosxCG.h\"",
            "#include \"macosx.h\"",
            "#include \"win_utils.h\"",
            "#include \"xevents.h\"",
            "#include \"xwrappers.h\"",
            "#include \"sslhelper.h\"",
            "#include \"sslcmds.h\"",
            "#include \"scan.h\"",
            "#include \"user.h\"",
            "#include \"unixpw.h\"",
            "#include \"screen.h\"",
            "#include \"rates.h\"",
            "#include \"solid.h\"",
            "#include \"gui.h\"",
            "#include \"cleanup.h\"",
            "#include \"keyboard.h\"",
            "#include \"remote.h\"",
            "#include \"inet.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int new_fb_size_clients(rfbScreenInfoPtr s);",
            "void close_clients(char *str);",
            "void set_client_input(char *str);",
            "int cmd_ok(char *cmd);",
            "void client_gone(rfbClientPtr client);",
            "void client_gone_chat_helper(rfbClientPtr client);",
            "void reverse_connect(char *str);",
            "void set_vnc_connect_prop(char *str);",
            "void set_x11vnc_remote_prop(char *str);",
            "enum rfbNewClientAction new_client(rfbClientPtr client);",
            "enum rfbNewClientAction new_client_chat_helper(rfbClientPtr client);",
            "rfbBool password_check_chat_helper(rfbClientPtr cl, const char* response, int len);",
            "void send_client_info(char *str);",
            "void adjust_grabs(int grab, int quiet);",
            "int accept_client(rfbClientPtr client);",
            "int run_user_command(char *cmd, rfbClientPtr client, char *mode, char *input,\n    int len, FILE *output);",
            "int check_access(char *addr);",
            "void client_set_net(rfbClientPtr client);",
            "static rfbClientPtr *client_match(char *str);",
            "static void free_client_data(rfbClientPtr client);",
            "static int ugly_window(char *addr, char *userhost, int X, int Y,\n    int timeout, char *mode, int accept);",
            "static int action_match(char *action, int rc);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xi2_devices.h\"\n#include \"xrandr.h\"\n#include \"pointer.h\"\n#include \"userinput.h\"\n#include \"macosxCG.h\"\n#include \"macosx.h\"\n#include \"win_utils.h\"\n#include \"xevents.h\"\n#include \"xwrappers.h\"\n#include \"sslhelper.h\"\n#include \"sslcmds.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"unixpw.h\"\n#include \"screen.h\"\n#include \"rates.h\"\n#include \"solid.h\"\n#include \"gui.h\"\n#include \"cleanup.h\"\n#include \"keyboard.h\"\n#include \"remote.h\"\n#include \"inet.h\"\n#include \"x11vnc.h\"\n\nint new_fb_size_clients(rfbScreenInfoPtr s);\nvoid close_clients(char *str);\nvoid set_client_input(char *str);\nint cmd_ok(char *cmd);\nvoid client_gone(rfbClientPtr client);\nvoid client_gone_chat_helper(rfbClientPtr client);\nvoid reverse_connect(char *str);\nvoid set_vnc_connect_prop(char *str);\nvoid set_x11vnc_remote_prop(char *str);\nenum rfbNewClientAction new_client(rfbClientPtr client);\nenum rfbNewClientAction new_client_chat_helper(rfbClientPtr client);\nrfbBool password_check_chat_helper(rfbClientPtr cl, const char* response, int len);\nvoid send_client_info(char *str);\nvoid adjust_grabs(int grab, int quiet);\nint accept_client(rfbClientPtr client);\nint run_user_command(char *cmd, rfbClientPtr client, char *mode, char *input,\n    int len, FILE *output);\nint check_access(char *addr);\nvoid client_set_net(rfbClientPtr client);\nstatic rfbClientPtr *client_match(char *str);\nstatic void free_client_data(rfbClientPtr client);\nstatic int ugly_window(char *addr, char *userhost, int X, int Y,\n    int timeout, char *mode, int accept);\nstatic int action_match(char *action, int rc);\n\nint run_user_command(char *cmd, rfbClientPtr client, char *mode, char *input,\n   int len, FILE *output) {\n\tchar *old_display = NULL;\n\tchar *addr = NULL;\n\tchar str[100];\n\tint rc, ok;\n\tClientData *cd = NULL;\n\tclient_set_net(client);\n\tif (client != NULL) {\n\t\tcd = (ClientData *) client->clientData;\n\t\taddr = client->host;\n\t}\n\n\tif (addr == NULL || addr[0] == '\\0') {\n\t\taddr = \"unknown-host\";\n\t}\n\n\t/* set RFB_CLIENT_ID to semi unique id for command to use */\n\tif (cd && cd->uid) {\n\t\tsprintf(str, \"0x%x\", cd->uid);\n\t} else {\n\t\t/* not accepted yet: */\n\t\tsprintf(str, \"0x%x\", clients_served);\n\t}\n\tset_env(\"RFB_CLIENT_ID\", str);\n\n\t/* set RFB_CLIENT_IP to IP addr for command to use */\n\tset_env(\"RFB_CLIENT_IP\", addr);\n\n\t/* set RFB_X11VNC_PID to our pid for command to use */\n\tsprintf(str, \"%d\", (int) getpid());\n\tset_env(\"RFB_X11VNC_PID\", str);\n\n\tif (client == NULL) {\n\t\t;\n\t} else if (client->state == RFB_PROTOCOL_VERSION) {\n\t\tset_env(\"RFB_STATE\", \"PROTOCOL_VERSION\");\n\t} else if (client->state == RFB_SECURITY_TYPE) {\n\t\tset_env(\"RFB_STATE\", \"SECURITY_TYPE\");\n\t} else if (client->state == RFB_AUTHENTICATION) {\n\t\tset_env(\"RFB_STATE\", \"AUTHENTICATION\");\n\t} else if (client->state == RFB_INITIALISATION) {\n\t\tset_env(\"RFB_STATE\", \"INITIALISATION\");\n\t} else if (client->state == RFB_NORMAL) {\n\t\tset_env(\"RFB_STATE\", \"NORMAL\");\n\t} else {\n\t\tset_env(\"RFB_STATE\", \"UNKNOWN\");\n\t}\n\tif (certret_str) {\n\t\tset_env(\"RFB_SSL_CLIENT_CERT\", certret_str);\n\t} else {\n\t\tset_env(\"RFB_SSL_CLIENT_CERT\", \"\");\n\t}\n\n\t/* set RFB_CLIENT_PORT to peer port for command to use */\n\tif (cd && cd->client_port > 0) {\n\t\tsprintf(str, \"%d\", cd->client_port);\n\t} else if (client) {\n\t\tsprintf(str, \"%d\", get_remote_port(client->sock));\n\t}\n\tset_env(\"RFB_CLIENT_PORT\", str);\n\n\tset_env(\"RFB_MODE\", mode);\n\n\t/* \n\t * now do RFB_SERVER_IP and RFB_SERVER_PORT (i.e. us!)\n\t * This will establish a 5-tuple (including tcp) the external\n\t * program can potentially use to work out the virtual circuit\n\t * for this connection.\n\t */\n\tif (cd && cd->server_ip) {\n\t\tset_env(\"RFB_SERVER_IP\", cd->server_ip);\n\t} else if (client) {\n\t\tchar *sip = get_local_host(client->sock);\n\t\tset_env(\"RFB_SERVER_IP\", sip);\n\t\tif (sip) free(sip);\n\t}\n\n\tif (cd && cd->server_port > 0) {\n\t\tsprintf(str, \"%d\", cd->server_port);\n\t} else if (client) {\n\t\tsprintf(str, \"%d\", get_local_port(client->sock));\n\t}\n\tset_env(\"RFB_SERVER_PORT\", str);\n\n\tif (cd) {\n\t\tsprintf(str, \"%d\", cd->login_viewonly);\n\t} else {\n\t\tsprintf(str, \"%d\", -1);\n\t}\n\tset_env(\"RFB_LOGIN_VIEWONLY\", str);\n\n\tif (cd) {\n\t\tsprintf(str, \"%d\", (int) cd->login_time);\n\t} else {\n\t\tsprintf(str, \">%d\", (int) time(NULL));\n\t}\n\tset_env(\"RFB_LOGIN_TIME\", str);\n\n\tsprintf(str, \"%d\", (int) time(NULL));\n\tset_env(\"RFB_CURRENT_TIME\", str);\n\n\tif (!cd || !cd->username || cd->username[0] == '\\0') {\n\t\tset_env(\"RFB_USERNAME\", \"unknown-user\");\n\t} else {\n\t\tset_env(\"RFB_USERNAME\", cd->username);\n\t}\n\t/* \n\t * Better set DISPLAY to the one we are polling, if they\n\t * want something trickier, they can handle on their own\n\t * via environment, etc. \n\t */\n\tif (getenv(\"DISPLAY\")) {\n\t\told_display = strdup(getenv(\"DISPLAY\"));\n\t}\n\n\tif (raw_fb && ! dpy) {\t/* raw_fb hack */\n\t\tset_env(\"DISPLAY\", \"rawfb\");\n\t} else {\n\t\tset_env(\"DISPLAY\", DisplayString(dpy));\n\t}\n\n\t/*\n\t * work out the number of clients (have to use client_count\n\t * since there is deadlock in rfbGetClientIterator) \n\t */\n\tsprintf(str, \"%d\", client_count);\n\tset_env(\"RFB_CLIENT_COUNT\", str);\n\n\t/* gone, accept, afteraccept */\n\tok = 0;\n\tif (!strcmp(mode, \"env\")) {\n\t\treturn 1;\n\t}\n\tif (!strcmp(mode, \"accept\") && cmd_ok(\"accept\")) {\n\t\tok = 1;\n\t}\n\tif (!strcmp(mode, \"afteraccept\") && cmd_ok(\"afteraccept\")) {\n\t\tok = 1;\n\t}\n\tif (!strcmp(mode, \"gone\") && cmd_ok(\"gone\")) {\n\t\tok = 1;\n\t}\n\tif (!strcmp(mode, \"cmd_verify\") && cmd_ok(\"unixpw\")) {\n\t\tok = 1;\n\t}\n\tif (!strcmp(mode, \"read_passwds\") && cmd_ok(\"passwdfile\")) {\n\t\tok = 1;\n\t}\n\tif (!strcmp(mode, \"custom_passwd\") && cmd_ok(\"custom_passwd\")) {\n\t\tok = 1;\n\t}\n\tif (no_external_cmds || !ok) {\n\t\trfbLogEnable(1);\n\t\trfbLog(\"cannot run external commands in -nocmds mode:\\n\");\n\t\trfbLog(\"   \\\"%s\\\"\\n\", cmd);\n\t\trfbLog(\"   exiting.\\n\");\n\t\tclean_up_exit(1);\n\t}\n\trfbLog(\"running command:\\n\");\n\tif (!quiet) {\n\t\tfprintf(stderr, \"\\n  %s\\n\\n\", cmd);\n\t}\n\tclose_exec_fds();\n\n\tif (output != NULL) {\n\t\tFILE *ph;\n\t\tchar line[1024];\n\t\tchar *cmd2 = NULL;\n\t\tchar tmp[] = \"/tmp/x11vnc-tmp.XXXXXX\";\n\t\tint deltmp = 0;\n\n\t\tif (input != NULL) {\n\t\t\tint tmp_fd = mkstemp(tmp);\n\t\t\tif (tmp_fd < 0) {\n\t\t\t\trfbLog(\"mkstemp failed on: %s\\n\", tmp);\n\t\t\t\tclean_up_exit(1);\n\t\t\t}\n\t\t\twrite(tmp_fd, input, len);\n\t\t\tclose(tmp_fd);\n\t\t\tdeltmp = 1;\n\t\t\tcmd2 = (char *) malloc(100 + strlen(tmp) + strlen(cmd));\n\t\t\tsprintf(cmd2, \"/bin/cat %s | %s\", tmp, cmd);\n\t\t\t\n\t\t\tph = popen(cmd2, \"r\");\n\t\t} else {\n\t\t\tph = popen(cmd, \"r\");\n\t\t}\n\t\tif (ph == NULL) {\n\t\t\trfbLog(\"popen(%s) failed\", cmd);\n\t\t\trfbLogPerror(\"popen\");\n\t\t\tclean_up_exit(1);\n\t\t}\n\t\tmemset(line, 0, sizeof(line));\n\t\twhile (fgets(line, sizeof(line), ph) != NULL) {\n\t\t\tint j, k = -1;\n\t\t\tif (0) fprintf(stderr, \"line: %s\", line);\n\t\t\t/* take care to handle embedded nulls */\n\t\t\tfor (j=0; j < (int) sizeof(line); j++) {\n\t\t\t\tif (line[j] != '\\0') {\n\t\t\t\t\tk = j;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (k >= 0) {\n\t\t\t\twrite(fileno(output), line, k+1);\n\t\t\t}\n\t\t\tmemset(line, 0, sizeof(line));\n\t\t}\n\n\t\trc = pclose(ph);\n\n\t\tif (cmd2 != NULL) {\n\t\t\tfree(cmd2);\n\t\t}\n\t\tif (deltmp) {\n\t\t\tunlink(tmp);\n\t\t}\n\t\tgoto got_rc;\n\t} else if (input != NULL) {\n\t\tFILE *ph = popen(cmd, \"w\");\n\t\tif (ph == NULL) {\n\t\t\trfbLog(\"popen(%s) failed\", cmd);\n\t\t\trfbLogPerror(\"popen\");\n\t\t\tclean_up_exit(1);\n\t\t}\n\t\twrite(fileno(ph), input, len);\n\t\trc = pclose(ph);\n\t\tgoto got_rc;\n\t}\n\n#if LIBVNCSERVER_HAVE_FORK\n\t{\n\t\tpid_t pid;\n\t\tstruct sigaction sa, intr, quit;\n\t\tsigset_t omask;\n\n\t\tsa.sa_handler = SIG_IGN;\n\t\tsa.sa_flags = 0;\n\t\tsigemptyset(&sa.sa_mask);\n\t\tsigaction(SIGINT,  &sa, &intr);\n\t\tsigaction(SIGQUIT, &sa, &quit);\n\n\t\tsigaddset(&sa.sa_mask, SIGCHLD);\n\t\tsigprocmask(SIG_BLOCK, &sa.sa_mask, &omask);\n\n\t\tif ((pid = fork()) > 0 || pid == -1) {\n\n\t\t\tif (pid != -1) {\n\t\t\t\twaitpid(pid, &rc, 0);\n\t\t\t}\n\n\t\t\tsigaction(SIGINT,  &intr, (struct sigaction *) NULL);\n\t\t\tsigaction(SIGQUIT, &quit, (struct sigaction *) NULL);\n\t\t\tsigprocmask(SIG_SETMASK, &omask, (sigset_t *) NULL);\n\n\t\t\tif (pid == -1) {\n\t\t\t\tfprintf(stderr, \"could not fork\\n\");\n\t\t\t\trfbLogPerror(\"fork\");\n\t\t\t\trc = system(cmd);\n\t\t\t}\n\t\t} else {\n\t\t\t/* this should close port 5900, etc.. */\n\t\t\tint fd;\n\t\t\tsigaction(SIGINT,  &intr, (struct sigaction *) NULL);\n\t\t\tsigaction(SIGQUIT, &quit, (struct sigaction *) NULL);\n\t\t\tsigprocmask(SIG_SETMASK, &omask, (sigset_t *) NULL);\n\t\t\tfor (fd=3; fd<256; fd++) {\n\t\t\t\tclose(fd);\n\t\t\t}\n/* XXX test more */\n\t\t\tif (!strcmp(mode, \"gone\")) {\n#if HAVE_SETSID\n\t\t\t\tsetsid();\n#else\n\t\t\t\tsetpgrp();\n#endif\n\t\t\t}\n\t\t\texeclp(\"/bin/sh\", \"/bin/sh\", \"-c\", cmd, (char *) NULL);\n\t\t\texit(1);\n\t\t}\n\t}\n#else\n\trc = system(cmd);\n#endif\n\tgot_rc:\n\n\tif (rc >= 256) {\n\t\trc = rc/256;\n\t}\n\trfbLog(\"command returned: %d\\n\", rc);\n\n\tif (old_display) {\n\t\tset_env(\"DISPLAY\", old_display);\n\t\tfree(old_display);\n\t}\n\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"run_user_command tmpfile() failed: %s\\n\"",
            "filename"
          ],
          "line": 906
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tmpfile",
          "args": [],
          "line": 904
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "\"cmd:\""
          ],
          "line": 902
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "filename",
            "\"cmd:\""
          ],
          "line": 899
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "\"read:\""
          ],
          "line": 891
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "filename",
            "\"read:\""
          ],
          "line": 890
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "\"rm:\""
          ],
          "line": 888
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "filename",
            "\"rm:\""
          ],
          "line": 887
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atoi",
          "args": [
            "getenv(\"X11VNC_MAX_PASSWDS\")"
          ],
          "line": 882
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getenv",
          "args": [
            "\"X11VNC_MAX_PASSWDS\""
          ],
          "line": 882
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getenv",
          "args": [
            "\"X11VNC_MAX_PASSWDS\""
          ],
          "line": 881
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"avahi.h\"\n#include \"sslhelper.h\"\n#include \"remote.h\"\n#include \"cursor.h\"\n#include \"keyboard.h\"\n#include \"inet.h\"\n#include \"connections.h\"\n#include \"xwrappers.h\"\n#include \"sslhelper.h\"\n#include \"unixpw.h\"\n#include \"screen.h\"\n#include \"scan.h\"\n#include \"cleanup.h\"\n#include \"solid.h\"\n#include \"x11vnc.h\"\n\nint read_passwds(char *passfile);\nrfbBool custom_passwd_check(rfbClientPtr cl, const char *response, int len);\n\nint read_passwds(char *passfile) {\n\tchar line[1024];\n\tchar *filename;\n\tchar **old_passwd_list = passwd_list;\n\tint linecount = 0, i, remove = 0, read_mode = 0, begin_vo = -1;\n\tstruct stat sbuf;\n\tstatic int max = -1;\n\tFILE *in = NULL;\n\tstatic time_t last_read = 0;\n\tstatic int read_cnt = 0;\n\tint db_passwd = 0;\n\n\tif (max < 0) {\n\t\tmax = 1000;\n\t\tif (getenv(\"X11VNC_MAX_PASSWDS\")) {\n\t\t\tmax = atoi(getenv(\"X11VNC_MAX_PASSWDS\"));\n\t\t}\n\t}\n\n\tfilename = passfile;\n\tif (strstr(filename, \"rm:\") == filename) {\n\t\tfilename += strlen(\"rm:\");\n\t\tremove = 1;\n\t} else if (strstr(filename, \"read:\") == filename) {\n\t\tfilename += strlen(\"read:\");\n\t\tread_mode = 1;\n\t\tif (stat(filename, &sbuf) == 0) {\n\t\t\tif (sbuf.st_mtime <= last_read) {\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t\tlast_read = sbuf.st_mtime;\n\t\t}\n\t} else if (strstr(filename, \"cmd:\") == filename) {\n\t\tint rc;\n\n\t\tfilename += strlen(\"cmd:\");\n\t\tread_mode = 1;\n\t\tin = tmpfile();\n\t\tif (in == NULL) {\n\t\t\trfbLog(\"run_user_command tmpfile() failed: %s\\n\",\n\t\t\t    filename);\n\t\t\tclean_up_exit(1);\n\t\t}\n\t\trc = run_user_command(filename, latest_client, \"read_passwds\",\n\t\t    NULL, 0, in);\n\t\tif (rc != 0) {\n\t\t\trfbLog(\"run_user_command command failed: %s\\n\",\n\t\t\t    filename);\n\t\t\tclean_up_exit(1);\n\t\t}\n\t\trewind(in);\n\t} else if (strstr(filename, \"custom:\") == filename) {\n\t\treturn 1;\n\t}\n\n\tif (in == NULL && stat(filename, &sbuf) == 0) {\n\t\t/* (poor...) upper bound to number of lines */\n\t\tmax = (int) sbuf.st_size;\n\t\tlast_read = sbuf.st_mtime;\n\t}\n\n\t/* create 1 more than max to have it be the ending NULL */\n\tpasswd_list = (char **) malloc( (max+1) * (sizeof(char *)) );\n\tfor (i=0; i<max+1; i++) {\n\t\tpasswd_list[i] = NULL;\n\t}\n\t\n\tif (in == NULL) {\n\t\tin = fopen(filename, \"r\");\n\t}\n\tif (in == NULL) {\n\t\trfbLog(\"cannot open passwdfile: %s\\n\", passfile);\n\t\trfbLogPerror(\"fopen\");\n\t\tif (remove) {\n\t\t\tunlink(filename);\n\t\t}\n\t\tclean_up_exit(1);\n\t}\n\n\tif (getenv(\"DEBUG_PASSWDFILE\") != NULL) {\n\t\tdb_passwd = 1;\n\t}\n\n\twhile (fgets(line, sizeof line, in) != NULL) {\n\t\tchar *p;\n\t\tint blank = 1;\n\t\tint len = strlen(line); \n\n\t\tif (db_passwd) {\n\t\t\tfprintf(stderr, \"read_passwds: raw line: %s\\n\", line);\n\t\t}\n\n\t\tif (len == 0) {\n\t\t\tcontinue;\n\t\t} else if (line[len-1] == '\\n') {\n\t\t\tline[len-1] = '\\0';\n\t\t}\n\t\tif (line[0] == '\\0') {\n\t\t\tcontinue;\n\t\t}\n\t\tif (strstr(line, \"__SKIP__\") != NULL) {\n\t\t\tcontinue;\n\t\t}\n\t\tif (strstr(line, \"__COMM__\") == line) {\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strcmp(line, \"__BEGIN_VIEWONLY__\")) {\n\t\t\tif (begin_vo < 0) {\n\t\t\t\tbegin_vo = linecount;\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\t\tif (line[0] == '#') {\n\t\t\t/* commented out, cannot have password beginning with # */\n\t\t\tcontinue;\n\t\t}\n\t\tp = line;\n\t\twhile (*p != '\\0') {\n\t\t\tif (! isspace((unsigned char) (*p))) {\n\t\t\t\tblank = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tp++;\n\t\t}\n\t\tif (blank) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tpasswd_list[linecount++] = strdup(line);\n\t\tif (db_passwd) {\n\t\t\tfprintf(stderr, \"read_passwds: keepline: %s\\n\", line);\n\t\t\tfprintf(stderr, \"read_passwds: begin_vo: %d\\n\", begin_vo);\n\t\t}\n\n\t\tif (linecount >= max) {\n\t\t\trfbLog(\"read_passwds: hit max passwd: %d\\n\", max);\n\t\t\tbreak;\n\t\t}\n\t}\n\tfclose(in);\n\n\tfor (i=0; i<1024; i++) {\n\t\tline[i] = '\\0';\n\t}\n\n\tif (remove) {\n\t\tunlink(filename);\n\t}\n\n\tif (! linecount) {\n\t\trfbLog(\"cannot read a valid line from passwdfile: %s\\n\",\n\t\t    passfile);\n\t\tif (read_cnt == 0) {\n\t\t\tclean_up_exit(1);\n\t\t} else {\n\t\t\treturn 0;\n\t\t}\n\t}\n\tread_cnt++;\n\n\tfor (i=0; i<linecount; i++) {\n\t\tchar *q, *p = passwd_list[i];\n\t\tif (!strcmp(p, \"__EMPTY__\")) {\n\t\t\t*p = '\\0';\n\t\t} else if ((q = strstr(p, \"__COMM__\")) != NULL) {\n\t\t\t*q = '\\0';\n\t\t}\n\t\tpasswd_list[i] = strdup(p);\n\t\tif (db_passwd) {\n\t\t\tfprintf(stderr, \"read_passwds: trimline: %s\\n\", p);\n\t\t}\n\t\tstrzero(p);\n\t}\n\n\tbegin_viewonly = begin_vo;\n\tif (read_mode && read_cnt > 1) {\n\t\tif (viewonly_passwd) {\n\t\t\tfree(viewonly_passwd);\n\t\t\tviewonly_passwd = NULL;\n\t\t}\n\t}\n\n\tif (begin_viewonly < 0 && linecount == 2) {\n\t\t/* for compatibility with previous 2-line usage: */\n\t\tviewonly_passwd = strdup(passwd_list[1]);\n\t\tif (db_passwd) {\n\t\t\tfprintf(stderr, \"read_passwds: linecount is 2.\\n\");\n\t\t}\n\t\tif (screen) {\n\t\t\tchar **apd = (char **) screen->authPasswdData;\n\t\t\tif (apd) {\n\t\t\t\tif (apd[0] != NULL) {\n\t\t\t\t\tstrzero(apd[0]);\n\t\t\t\t}\n\t\t\t\tapd[0] = strdup(passwd_list[0]);\n\t\t\t}\n\t\t}\n\t\tbegin_viewonly = 1;\n\t}\n\n\tif (old_passwd_list != NULL) {\n\t\tchar *p;\n\t\ti = 0;\n\t\twhile (old_passwd_list[i] != NULL) {\n\t\t\tp = old_passwd_list[i];\n\t\t\tstrzero(p);\n\t\t\tfree(old_passwd_list[i]);\n\t\t\ti++;\n\t\t}\n\t\tfree(old_passwd_list);\n\t}\n\treturn 1;\n}"
  },
  {
    "function_name": "try_to_switch_users",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/user.c",
    "lines": "827-865",
    "snippet": "static void try_to_switch_users(void) {\n\tstatic time_t last_try = 0;\n\ttime_t now = time(NULL);\n\tchar *users, *p;\n\n\tif (getuid() && geteuid()) {\n\t\trfbLog(\"try_to_switch_users: not root\\n\");\n\t\tstarted_as_root = 2;\n\t\treturn;\n\t}\n\tif (!last_try) {\n\t\tlast_try = now;\n\t} else if (now <= last_try + 2) {\n\t\t/* try every 3 secs or so */\n\t\treturn;\n\t}\n\tlast_try = now;\n\n\tusers = strdup(users_list);\n\n\tif (strstr(users, \"guess=\") == users) {\n\t\tif (switch_user(users, 1)) {\n\t\t\tstarted_as_root = 2;\n\t\t}\n\t\tfree(users);\n\t\treturn;\n\t}\n\n\tp = strtok(users, \",\");\n\twhile (p) {\n\t\tif (switch_user(p, 1)) {\n\t\t\tstarted_as_root = 2;\n\t\t\trfbLog(\"try_to_switch_users: now %s\\n\", p);\n\t\t\tbreak;\n\t\t}\n\t\tp = strtok(NULL, \",\");\n\t}\n\tfree(users);\n}",
    "includes": [
      "#include \"avahi.h\"",
      "#include \"sslhelper.h\"",
      "#include \"remote.h\"",
      "#include \"cursor.h\"",
      "#include \"keyboard.h\"",
      "#include \"inet.h\"",
      "#include \"connections.h\"",
      "#include \"xwrappers.h\"",
      "#include \"sslhelper.h\"",
      "#include \"unixpw.h\"",
      "#include \"screen.h\"",
      "#include \"scan.h\"",
      "#include \"cleanup.h\"",
      "#include \"solid.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int lurk(char **users);",
      "static void try_to_switch_users(void);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "users"
          ],
          "line": 864
        },
        "resolved": true,
        "details": {
          "function_name": "free_rect",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/userinput.c",
          "lines": "6200-6247",
          "snippet": "int free_rect(int idx) {\n\tint n, ok = 0;\n\tsraRegionPtr r1, r2;\n\tint x, y, w, h;\n\n\tif (idx < 0 || idx >= cache_list_num) {\nif (0) fprintf(stderr, \"free_rect: bad index: %d\\n\", idx);\n\t\tclean_up_exit(1);\n\t}\n\n\tx = cache_list[idx].bs_x;\n\ty = cache_list[idx].bs_y;\n\tw = cache_list[idx].bs_w;\n\th = cache_list[idx].bs_h;\n\n\tif (x < 0) {\n\t\tCLEAR(idx);\nif (dnow() > last_client + 5 && ncdb) fprintf(stderr, \"free_rect: already bs_x invalidated: %d bs_x: %d\\n\", idx, x);\n\t\treturn 1;\n\t}\n\n\tr2 = sraRgnCreateRect(x, y, x+w, y+h);\n\n\tn = get_bs_n(y);\n\tif (n >= 0) {\n\t\tr1 = rect_reg[n];\n\t\tsraRgnOr(r1, r2);\n\t\tok = 1;\n\t}\n\n\tif (zero_rects) {\n\t\tsraRgnOr(zero_rects, r2);\n\t\tx = cache_list[idx].su_x;\n\t\ty = cache_list[idx].su_y;\n\t\tw = cache_list[idx].su_w;\n\t\th = cache_list[idx].su_h;\n\t\tif (x >= 0) {\n\t\t\tsraRgnDestroy(r2);\n\t\t\tr2 = sraRgnCreateRect(x, y, x+w, y+h);\n\t\t\tsraRgnOr(zero_rects, r2);\n\t\t}\n\t}\n\tsraRgnDestroy(r2);\n\n\tCLEAR(idx);\nif (! ok && ncdb) fprintf(stderr, \"**** free_rect: not-found %d\\n\", idx);\n\treturn ok;\n}",
          "includes": [
            "#include \"default8x16.h\"",
            "#include \"connections.h\"",
            "#include \"screen.h\"",
            "#include \"cursor.h\"",
            "#include \"macosxCGS.h\"",
            "#include \"macosx.h\"",
            "#include \"unixpw.h\"",
            "#include \"8to24.h\"",
            "#include \"xrandr.h\"",
            "#include \"solid.h\"",
            "#include \"keyboard.h\"",
            "#include \"rates.h\"",
            "#include \"pointer.h\"",
            "#include \"cleanup.h\"",
            "#include \"scan.h\"",
            "#include \"user.h\"",
            "#include \"xevents.h\"",
            "#include \"win_utils.h\"",
            "#include \"xinerama.h\"",
            "#include \"xrecord.h\"",
            "#include \"xdamage.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void mark_for_xdamage(int x, int y, int w, int h);",
            "void set_xdamage_mark(int x, int y, int w, int h);",
            "int find_rect(int idx, int x, int y, int w, int h);",
            "winattr_t *cache_list;",
            "int clipped(int idx);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"default8x16.h\"\n#include \"connections.h\"\n#include \"screen.h\"\n#include \"cursor.h\"\n#include \"macosxCGS.h\"\n#include \"macosx.h\"\n#include \"unixpw.h\"\n#include \"8to24.h\"\n#include \"xrandr.h\"\n#include \"solid.h\"\n#include \"keyboard.h\"\n#include \"rates.h\"\n#include \"pointer.h\"\n#include \"cleanup.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"xevents.h\"\n#include \"win_utils.h\"\n#include \"xinerama.h\"\n#include \"xrecord.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nvoid mark_for_xdamage(int x, int y, int w, int h);\nvoid set_xdamage_mark(int x, int y, int w, int h);\nint find_rect(int idx, int x, int y, int w, int h);\nwinattr_t *cache_list;\nint clipped(int idx);\n\nint free_rect(int idx) {\n\tint n, ok = 0;\n\tsraRegionPtr r1, r2;\n\tint x, y, w, h;\n\n\tif (idx < 0 || idx >= cache_list_num) {\nif (0) fprintf(stderr, \"free_rect: bad index: %d\\n\", idx);\n\t\tclean_up_exit(1);\n\t}\n\n\tx = cache_list[idx].bs_x;\n\ty = cache_list[idx].bs_y;\n\tw = cache_list[idx].bs_w;\n\th = cache_list[idx].bs_h;\n\n\tif (x < 0) {\n\t\tCLEAR(idx);\nif (dnow() > last_client + 5 && ncdb) fprintf(stderr, \"free_rect: already bs_x invalidated: %d bs_x: %d\\n\", idx, x);\n\t\treturn 1;\n\t}\n\n\tr2 = sraRgnCreateRect(x, y, x+w, y+h);\n\n\tn = get_bs_n(y);\n\tif (n >= 0) {\n\t\tr1 = rect_reg[n];\n\t\tsraRgnOr(r1, r2);\n\t\tok = 1;\n\t}\n\n\tif (zero_rects) {\n\t\tsraRgnOr(zero_rects, r2);\n\t\tx = cache_list[idx].su_x;\n\t\ty = cache_list[idx].su_y;\n\t\tw = cache_list[idx].su_w;\n\t\th = cache_list[idx].su_h;\n\t\tif (x >= 0) {\n\t\t\tsraRgnDestroy(r2);\n\t\t\tr2 = sraRgnCreateRect(x, y, x+w, y+h);\n\t\t\tsraRgnOr(zero_rects, r2);\n\t\t}\n\t}\n\tsraRgnDestroy(r2);\n\n\tCLEAR(idx);\nif (! ok && ncdb) fprintf(stderr, \"**** free_rect: not-found %d\\n\", idx);\n\treturn ok;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strtok",
          "args": [
            "NULL",
            "\",\""
          ],
          "line": 862
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"try_to_switch_users: now %s\\n\"",
            "p"
          ],
          "line": 859
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "switch_user",
          "args": [
            "p",
            "1"
          ],
          "line": 857
        },
        "resolved": true,
        "details": {
          "function_name": "switch_user",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/user.c",
          "lines": "715-757",
          "snippet": "int switch_user(char *user, int fb_mode) {\n\t/* NO strtoks */\n\tint doit = 0;\n\tuid_t uid = 0;\n\tgid_t gid = 0;\n\tchar *name, *home;\n\n\tif (*user == '+') {\n\t\tdoit = 1;\n\t\tuser++;\n\t}\n\n\tssl_helper_pid(0, -2);\t/* waitall */\n\n\tif (strstr(user, \"guess=\") == user) {\n\t\treturn guess_user_and_switch(user, fb_mode);\n\t}\n\n\tuser2uid(user, &uid, &gid, &name, &home);\n\n\tif (uid == (uid_t) -1 || uid == 0) {\n\t\treturn 0;\n\t}\n\tif (gid == 0) {\n\t\treturn 0;\n\t}\n\n\tif (! doit && dpy) {\n\t\t/* see if this display works: */\n\t\tchar *dstr = DisplayString(dpy);\n\t\tdoit = try_user_and_display(uid, gid, dstr);\n\t}\n\n\tif (doit) {\n\t\tint rc = switch_user_env(uid, gid, name, home, fb_mode);\n\t\tif (rc) {\n\t\t\tstarted_as_root = 2;\n\t\t}\n\t\treturn rc;\n\t} else {\n\t\treturn 0;\n\t}\n}",
          "includes": [
            "#include \"avahi.h\"",
            "#include \"sslhelper.h\"",
            "#include \"remote.h\"",
            "#include \"cursor.h\"",
            "#include \"keyboard.h\"",
            "#include \"inet.h\"",
            "#include \"connections.h\"",
            "#include \"xwrappers.h\"",
            "#include \"sslhelper.h\"",
            "#include \"unixpw.h\"",
            "#include \"screen.h\"",
            "#include \"scan.h\"",
            "#include \"cleanup.h\"",
            "#include \"solid.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int switch_user(char *user, int fb_mode);",
            "static void user2uid(char *user, uid_t *uid, gid_t *gid, char **name, char **home);",
            "static int guess_user_and_switch(char *str, int fb_mode);",
            "static int switch_user_env(uid_t uid, gid_t gid, char *name, char *home, int fb_mode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"avahi.h\"\n#include \"sslhelper.h\"\n#include \"remote.h\"\n#include \"cursor.h\"\n#include \"keyboard.h\"\n#include \"inet.h\"\n#include \"connections.h\"\n#include \"xwrappers.h\"\n#include \"sslhelper.h\"\n#include \"unixpw.h\"\n#include \"screen.h\"\n#include \"scan.h\"\n#include \"cleanup.h\"\n#include \"solid.h\"\n#include \"x11vnc.h\"\n\nint switch_user(char *user, int fb_mode);\nstatic void user2uid(char *user, uid_t *uid, gid_t *gid, char **name, char **home);\nstatic int guess_user_and_switch(char *str, int fb_mode);\nstatic int switch_user_env(uid_t uid, gid_t gid, char *name, char *home, int fb_mode);\n\nint switch_user(char *user, int fb_mode) {\n\t/* NO strtoks */\n\tint doit = 0;\n\tuid_t uid = 0;\n\tgid_t gid = 0;\n\tchar *name, *home;\n\n\tif (*user == '+') {\n\t\tdoit = 1;\n\t\tuser++;\n\t}\n\n\tssl_helper_pid(0, -2);\t/* waitall */\n\n\tif (strstr(user, \"guess=\") == user) {\n\t\treturn guess_user_and_switch(user, fb_mode);\n\t}\n\n\tuser2uid(user, &uid, &gid, &name, &home);\n\n\tif (uid == (uid_t) -1 || uid == 0) {\n\t\treturn 0;\n\t}\n\tif (gid == 0) {\n\t\treturn 0;\n\t}\n\n\tif (! doit && dpy) {\n\t\t/* see if this display works: */\n\t\tchar *dstr = DisplayString(dpy);\n\t\tdoit = try_user_and_display(uid, gid, dstr);\n\t}\n\n\tif (doit) {\n\t\tint rc = switch_user_env(uid, gid, name, home, fb_mode);\n\t\tif (rc) {\n\t\t\tstarted_as_root = 2;\n\t\t}\n\t\treturn rc;\n\t} else {\n\t\treturn 0;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "strtok",
          "args": [
            "users",
            "\",\""
          ],
          "line": 855
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "users",
            "\"guess=\""
          ],
          "line": 847
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "users_list"
          ],
          "line": 845
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"try_to_switch_users: not root\\n\""
          ],
          "line": 833
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "geteuid",
          "args": [],
          "line": 832
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getuid",
          "args": [],
          "line": 832
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "time",
          "args": [
            "NULL"
          ],
          "line": 829
        },
        "resolved": true,
        "details": {
          "function_name": "vnc_redirect_timeout",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/user.c",
          "lines": "1395-1399",
          "snippet": "static void vnc_redirect_timeout (int sig) {\n\twrite(2, \"timeout: no clients connected.\\n\", 31);\n\tif (sig) {};\n\texit(0);\n}",
          "includes": [
            "#include \"avahi.h\"",
            "#include \"sslhelper.h\"",
            "#include \"remote.h\"",
            "#include \"cursor.h\"",
            "#include \"keyboard.h\"",
            "#include \"inet.h\"",
            "#include \"connections.h\"",
            "#include \"xwrappers.h\"",
            "#include \"sslhelper.h\"",
            "#include \"unixpw.h\"",
            "#include \"screen.h\"",
            "#include \"scan.h\"",
            "#include \"cleanup.h\"",
            "#include \"solid.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"avahi.h\"\n#include \"sslhelper.h\"\n#include \"remote.h\"\n#include \"cursor.h\"\n#include \"keyboard.h\"\n#include \"inet.h\"\n#include \"connections.h\"\n#include \"xwrappers.h\"\n#include \"sslhelper.h\"\n#include \"unixpw.h\"\n#include \"screen.h\"\n#include \"scan.h\"\n#include \"cleanup.h\"\n#include \"solid.h\"\n#include \"x11vnc.h\"\n\nstatic void vnc_redirect_timeout (int sig) {\n\twrite(2, \"timeout: no clients connected.\\n\", 31);\n\tif (sig) {};\n\texit(0);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"avahi.h\"\n#include \"sslhelper.h\"\n#include \"remote.h\"\n#include \"cursor.h\"\n#include \"keyboard.h\"\n#include \"inet.h\"\n#include \"connections.h\"\n#include \"xwrappers.h\"\n#include \"sslhelper.h\"\n#include \"unixpw.h\"\n#include \"screen.h\"\n#include \"scan.h\"\n#include \"cleanup.h\"\n#include \"solid.h\"\n#include \"x11vnc.h\"\n\nstatic int lurk(char **users);\nstatic void try_to_switch_users(void);\n\nstatic void try_to_switch_users(void) {\n\tstatic time_t last_try = 0;\n\ttime_t now = time(NULL);\n\tchar *users, *p;\n\n\tif (getuid() && geteuid()) {\n\t\trfbLog(\"try_to_switch_users: not root\\n\");\n\t\tstarted_as_root = 2;\n\t\treturn;\n\t}\n\tif (!last_try) {\n\t\tlast_try = now;\n\t} else if (now <= last_try + 2) {\n\t\t/* try every 3 secs or so */\n\t\treturn;\n\t}\n\tlast_try = now;\n\n\tusers = strdup(users_list);\n\n\tif (strstr(users, \"guess=\") == users) {\n\t\tif (switch_user(users, 1)) {\n\t\t\tstarted_as_root = 2;\n\t\t}\n\t\tfree(users);\n\t\treturn;\n\t}\n\n\tp = strtok(users, \",\");\n\twhile (p) {\n\t\tif (switch_user(p, 1)) {\n\t\t\tstarted_as_root = 2;\n\t\t\trfbLog(\"try_to_switch_users: now %s\\n\", p);\n\t\t\tbreak;\n\t\t}\n\t\tp = strtok(NULL, \",\");\n\t}\n\tfree(users);\n}"
  },
  {
    "function_name": "switch_user_env",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/user.c",
    "lines": "759-825",
    "snippet": "static int switch_user_env(uid_t uid, gid_t gid, char *name, char *home, int fb_mode) {\n\t/* NO strtoks */\n\tchar *xauth;\n\tint reset_fb = 0;\n\tint grp_ok = 0;\n\n#if !HAVE_SETUID\n\treturn 0;\n#else\n\t/*\n\t * OK, tricky here, we need to free the shm... otherwise\n\t * we won't be able to delete it as the other user...\n\t */\n\tif (fb_mode == 1 && (using_shm && ! xform24to32)) {\n\t\treset_fb = 1;\n\t\tclean_shm(0);\n\t\tfree_tiles();\n\t}\n#if HAVE_INITGROUPS\n#if HAVE_PWD_H\n\tif (getpwuid(uid) != NULL && getenv(\"X11VNC_SINGLE_GROUP\") == NULL) {\n\t\tstruct passwd *p = getpwuid(uid);\n\t\t/* another possibility is p->pw_gid instead of gid */\n\t\tif (setgid(gid) == 0 && initgroups(p->pw_name, gid) == 0)  {\n\t\t\tgrp_ok = 1;\n\t\t} else {\n\t\t\trfbLogPerror(\"initgroups\");\n\t\t}\n\t\tendgrent();\n\t}\n#endif\n#endif\n\tif (! grp_ok) {\n\t\tif (setgid(gid) == 0) {\n\t\t\tgrp_ok = 1;\n\t\t}\n\t}\n\tif (! grp_ok) {\n\t\tif (reset_fb) {\n\t\t\t/* 2 means we did clean_shm and free_tiles */\n\t\t\tdo_new_fb(2);\n\t\t}\n\t\treturn 0;\n\t}\n\n\tif (setuid(uid) != 0) {\n\t\tif (reset_fb) {\n\t\t\t/* 2 means we did clean_shm and free_tiles */\n\t\t\tdo_new_fb(2);\n\t\t}\n\t\treturn 0;\n\t}\n#endif\n\tif (reset_fb) {\n\t\tdo_new_fb(2);\n\t}\n\n\txauth = getenv(\"XAUTHORITY\");\n\tif (xauth && access(xauth, R_OK) != 0) {\n\t\t*(xauth-2) = '_';\t/* yow */\n\t}\n\t\n\tset_env(\"USER\", name);\n\tset_env(\"LOGNAME\", name);\n\tset_env(\"HOME\", home);\n\treturn 1;\n}",
    "includes": [
      "#include \"avahi.h\"",
      "#include \"sslhelper.h\"",
      "#include \"remote.h\"",
      "#include \"cursor.h\"",
      "#include \"keyboard.h\"",
      "#include \"inet.h\"",
      "#include \"connections.h\"",
      "#include \"xwrappers.h\"",
      "#include \"sslhelper.h\"",
      "#include \"unixpw.h\"",
      "#include \"screen.h\"",
      "#include \"scan.h\"",
      "#include \"cleanup.h\"",
      "#include \"solid.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "int switch_user(char *user, int fb_mode);",
      "static void user2uid(char *user, uid_t *uid, gid_t *gid, char **name, char **home);",
      "static int guess_user_and_switch(char *str, int fb_mode);",
      "static int switch_user_env(uid_t uid, gid_t gid, char *name, char *home, int fb_mode);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "set_env",
          "args": [
            "\"HOME\"",
            "home"
          ],
          "line": 823
        },
        "resolved": true,
        "details": {
          "function_name": "set_env",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/util.c",
          "lines": "239-249",
          "snippet": "void set_env(char *name, char *value) {\n\tchar *str;\n\tif (! name) {\n\t\treturn;\n\t}\n\tif (! value) {\n\t\tvalue = \"\";\n\t}\n\n\tsetenv(name, value, 1);\n}",
          "includes": [
            "#include \"connections.h\"",
            "#include \"unixpw.h\"",
            "#include \"win_utils.h\"",
            "#include \"cleanup.h\"",
            "#include \"x11vnc.h\"",
            "#include <stdlib.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void lowercase(char *str);",
            "void uppercase(char *str);",
            "char *lblanks(char *str);",
            "void strzero(char *str);",
            "void set_env(char *name, char *value);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"connections.h\"\n#include \"unixpw.h\"\n#include \"win_utils.h\"\n#include \"cleanup.h\"\n#include \"x11vnc.h\"\n#include <stdlib.h>\n\nvoid lowercase(char *str);\nvoid uppercase(char *str);\nchar *lblanks(char *str);\nvoid strzero(char *str);\nvoid set_env(char *name, char *value);\n\nvoid set_env(char *name, char *value) {\n\tchar *str;\n\tif (! name) {\n\t\treturn;\n\t}\n\tif (! value) {\n\t\tvalue = \"\";\n\t}\n\n\tsetenv(name, value, 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "access",
          "args": [
            "xauth",
            "R_OK"
          ],
          "line": 817
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getenv",
          "args": [
            "\"XAUTHORITY\""
          ],
          "line": 816
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "do_new_fb",
          "args": [
            "2"
          ],
          "line": 813
        },
        "resolved": true,
        "details": {
          "function_name": "do_new_fb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/screen.c",
          "lines": "1008-1068",
          "snippet": "void do_new_fb(int reset_mem) {\n\tXImage *fb;\n\n\t/* for threaded we really should lock libvncserver out. */\n\tif (use_threads) {\n\t\tint ms = 1000;\n\t\tif (getenv(\"X11VNC_THREADS_NEW_FB_SLEEP\")) {\n\t\t\tms = atoi(getenv(\"X11VNC_THREADS_NEW_FB_SLEEP\"));\n\t\t} else if (subwin) {\n\t\t\tms = 500;\n\t\t} else {\n\t\t\tms = 1000;\n\t\t}\n\t\trfbLog(\"Warning: changing framebuffers in threaded mode may be unstable.\\n\");\n\t\tthreads_drop_input = 1;\n\t\tusleep(ms * 1000);\n\t}\n\n\tINPUT_LOCK;\n\tlock_client_sends(1);\n\n\tif (use_threads) {\n\t\tsettle_clients(1);\n\t}\n\n#ifdef MACOSX\n\tif (macosx_console) {\n\t\tmacosxCG_fini();\n\t}\n#endif\n\tif (reset_mem == 1) {\n\t\t/* reset_mem == 2 is a hack for changing users... */\n\t\tclean_shm(0);\n\t\tfree_tiles();\n\t}\n\n\tfree_old_fb();\n\n\tfb = initialize_xdisplay_fb();\n\n\tinitialize_screen(NULL, NULL, fb);\n\n\tif (reset_mem) {\n\t\tinitialize_tiles();\n\t\tinitialize_blackouts_and_xinerama();\n\t\tinitialize_polling_images();\n\t}\n\tif (ncache) {\n\t\tcheck_ncache(1, 0);\n\t}\n\n\tprep_clients_for_new_fb();\n\tlock_client_sends(0);\n\tINPUT_UNLOCK;\n\n\tif (use_threads) {\n\t\t/* need to let things settle... */\n\t\tsettle_clients(0);\n\t\tthreads_drop_input = 0;\n\t}\n}",
          "includes": [
            "#include <rfb/rfbclient.h>",
            "#include \"xi2_devices.h\"",
            "#include \"pm.h\"",
            "#include \"xrecord.h\"",
            "#include \"xrandr.h\"",
            "#include \"inet.h\"",
            "#include \"solid.h\"",
            "#include \"avahi.h\"",
            "#include \"macosxCG.h\"",
            "#include \"macosx.h\"",
            "#include \"linuxfb.h\"",
            "#include \"v4l.h\"",
            "#include \"sslhelper.h\"",
            "#include \"sslcmds.h\"",
            "#include \"unixpw.h\"",
            "#include \"remote.h\"",
            "#include \"connections.h\"",
            "#include \"cursor.h\"",
            "#include \"keyboard.h\"",
            "#include \"pointer.h\"",
            "#include \"rates.h\"",
            "#include \"user.h\"",
            "#include \"scan.h\"",
            "#include \"userinput.h\"",
            "#include \"cleanup.h\"",
            "#include \"win_utils.h\"",
            "#include \"xdamage.h\"",
            "#include \"xinerama.h\"",
            "#include \"xwrappers.h\"",
            "#include \"xevents.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void do_new_fb(int reset_mem);",
            "void free_old_fb(void);",
            "XImage *initialize_xdisplay_fb(void);",
            "int parse_rotate_string(char *str, int *mode);",
            "void initialize_screen(int *argc, char **argv, XImage *fb);",
            "static void debug_colormap(XImage *fb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <rfb/rfbclient.h>\n#include \"xi2_devices.h\"\n#include \"pm.h\"\n#include \"xrecord.h\"\n#include \"xrandr.h\"\n#include \"inet.h\"\n#include \"solid.h\"\n#include \"avahi.h\"\n#include \"macosxCG.h\"\n#include \"macosx.h\"\n#include \"linuxfb.h\"\n#include \"v4l.h\"\n#include \"sslhelper.h\"\n#include \"sslcmds.h\"\n#include \"unixpw.h\"\n#include \"remote.h\"\n#include \"connections.h\"\n#include \"cursor.h\"\n#include \"keyboard.h\"\n#include \"pointer.h\"\n#include \"rates.h\"\n#include \"user.h\"\n#include \"scan.h\"\n#include \"userinput.h\"\n#include \"cleanup.h\"\n#include \"win_utils.h\"\n#include \"xdamage.h\"\n#include \"xinerama.h\"\n#include \"xwrappers.h\"\n#include \"xevents.h\"\n#include \"x11vnc.h\"\n\nvoid do_new_fb(int reset_mem);\nvoid free_old_fb(void);\nXImage *initialize_xdisplay_fb(void);\nint parse_rotate_string(char *str, int *mode);\nvoid initialize_screen(int *argc, char **argv, XImage *fb);\nstatic void debug_colormap(XImage *fb);\n\nvoid do_new_fb(int reset_mem) {\n\tXImage *fb;\n\n\t/* for threaded we really should lock libvncserver out. */\n\tif (use_threads) {\n\t\tint ms = 1000;\n\t\tif (getenv(\"X11VNC_THREADS_NEW_FB_SLEEP\")) {\n\t\t\tms = atoi(getenv(\"X11VNC_THREADS_NEW_FB_SLEEP\"));\n\t\t} else if (subwin) {\n\t\t\tms = 500;\n\t\t} else {\n\t\t\tms = 1000;\n\t\t}\n\t\trfbLog(\"Warning: changing framebuffers in threaded mode may be unstable.\\n\");\n\t\tthreads_drop_input = 1;\n\t\tusleep(ms * 1000);\n\t}\n\n\tINPUT_LOCK;\n\tlock_client_sends(1);\n\n\tif (use_threads) {\n\t\tsettle_clients(1);\n\t}\n\n#ifdef MACOSX\n\tif (macosx_console) {\n\t\tmacosxCG_fini();\n\t}\n#endif\n\tif (reset_mem == 1) {\n\t\t/* reset_mem == 2 is a hack for changing users... */\n\t\tclean_shm(0);\n\t\tfree_tiles();\n\t}\n\n\tfree_old_fb();\n\n\tfb = initialize_xdisplay_fb();\n\n\tinitialize_screen(NULL, NULL, fb);\n\n\tif (reset_mem) {\n\t\tinitialize_tiles();\n\t\tinitialize_blackouts_and_xinerama();\n\t\tinitialize_polling_images();\n\t}\n\tif (ncache) {\n\t\tcheck_ncache(1, 0);\n\t}\n\n\tprep_clients_for_new_fb();\n\tlock_client_sends(0);\n\tINPUT_UNLOCK;\n\n\tif (use_threads) {\n\t\t/* need to let things settle... */\n\t\tsettle_clients(0);\n\t\tthreads_drop_input = 0;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "setuid",
          "args": [
            "uid"
          ],
          "line": 804
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "setgid",
          "args": [
            "gid"
          ],
          "line": 792
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "endgrent",
          "args": [],
          "line": 787
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLogPerror",
          "args": [
            "\"initgroups\""
          ],
          "line": 785
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "initgroups",
          "args": [
            "p->pw_name",
            "gid"
          ],
          "line": 782
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "setgid",
          "args": [
            "gid"
          ],
          "line": 782
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getpwuid",
          "args": [
            "uid"
          ],
          "line": 780
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getenv",
          "args": [
            "\"X11VNC_SINGLE_GROUP\""
          ],
          "line": 779
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getpwuid",
          "args": [
            "uid"
          ],
          "line": 779
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free_tiles",
          "args": [],
          "line": 775
        },
        "resolved": true,
        "details": {
          "function_name": "free_tiles",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/scan.c",
          "lines": "160-201",
          "snippet": "void free_tiles(void) {\n\tif (tile_has_diff) {\n\t\tfree(tile_has_diff);\n\t\ttile_has_diff = NULL;\n\t}\n\tif (tile_has_xdamage_diff) {\n\t\tfree(tile_has_xdamage_diff);\n\t\ttile_has_xdamage_diff = NULL;\n\t}\n\tif (tile_row_has_xdamage_diff) {\n\t\tfree(tile_row_has_xdamage_diff);\n\t\ttile_row_has_xdamage_diff = NULL;\n\t}\n\tif (tile_tried) {\n\t\tfree(tile_tried);\n\t\ttile_tried = NULL;\n\t}\n\tif (tile_copied) {\n\t\tfree(tile_copied);\n\t\ttile_copied = NULL;\n\t}\n\tif (tile_blackout) {\n\t\tfree(tile_blackout);\n\t\ttile_blackout = NULL;\n\t}\n\tif (tile_region) {\n\t\tfree(tile_region);\n\t\ttile_region = NULL;\n\t}\n\tif (tile_row) {\n\t\tfree(tile_row);\n\t\ttile_row = NULL;\n\t}\n\tif (tile_row_shm) {\n\t\tfree(tile_row_shm);\n\t\ttile_row_shm = NULL;\n\t}\n\tif (hint_list) {\n\t\tfree(hint_list);\n\t\thint_list = NULL;\n\t}\n}",
          "includes": [
            "#include <default8x16.h>",
            "#include \"userinput.h\"",
            "#include \"macosx.h\"",
            "#include \"screen.h\"",
            "#include \"unixpw.h\"",
            "#include \"cleanup.h\"",
            "#include \"pointer.h\"",
            "#include \"screen.h\"",
            "#include \"8to24.h\"",
            "#include \"win_utils.h\"",
            "#include \"xrandr.h\"",
            "#include \"xdamage.h\"",
            "#include \"xwrappers.h\"",
            "#include \"xinerama.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void free_tiles(void);",
            "static hint_t *hint_list;",
            "static region_t *tile_region;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <default8x16.h>\n#include \"userinput.h\"\n#include \"macosx.h\"\n#include \"screen.h\"\n#include \"unixpw.h\"\n#include \"cleanup.h\"\n#include \"pointer.h\"\n#include \"screen.h\"\n#include \"8to24.h\"\n#include \"win_utils.h\"\n#include \"xrandr.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"xinerama.h\"\n#include \"x11vnc.h\"\n\nvoid free_tiles(void);\nstatic hint_t *hint_list;\nstatic region_t *tile_region;\n\nvoid free_tiles(void) {\n\tif (tile_has_diff) {\n\t\tfree(tile_has_diff);\n\t\ttile_has_diff = NULL;\n\t}\n\tif (tile_has_xdamage_diff) {\n\t\tfree(tile_has_xdamage_diff);\n\t\ttile_has_xdamage_diff = NULL;\n\t}\n\tif (tile_row_has_xdamage_diff) {\n\t\tfree(tile_row_has_xdamage_diff);\n\t\ttile_row_has_xdamage_diff = NULL;\n\t}\n\tif (tile_tried) {\n\t\tfree(tile_tried);\n\t\ttile_tried = NULL;\n\t}\n\tif (tile_copied) {\n\t\tfree(tile_copied);\n\t\ttile_copied = NULL;\n\t}\n\tif (tile_blackout) {\n\t\tfree(tile_blackout);\n\t\ttile_blackout = NULL;\n\t}\n\tif (tile_region) {\n\t\tfree(tile_region);\n\t\ttile_region = NULL;\n\t}\n\tif (tile_row) {\n\t\tfree(tile_row);\n\t\ttile_row = NULL;\n\t}\n\tif (tile_row_shm) {\n\t\tfree(tile_row_shm);\n\t\ttile_row_shm = NULL;\n\t}\n\tif (hint_list) {\n\t\tfree(hint_list);\n\t\thint_list = NULL;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "clean_shm",
          "args": [
            "0"
          ],
          "line": 774
        },
        "resolved": true,
        "details": {
          "function_name": "clean_shm",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/cleanup.c",
          "lines": "93-132",
          "snippet": "void clean_shm(int quick) {\n\tint i, cnt = 0;\n\n\t/*\n\t * to avoid deadlock, etc, under quick=1 we just delete the shm\n\t * areas and leave the X stuff hanging.\n\t */\n\tif (quick) {\n\t\tshm_delete(&scanline_shm);\n\t\tshm_delete(&fullscreen_shm);\n\t\tshm_delete(&snaprect_shm);\n\t} else {\n\t\tshm_clean(&scanline_shm, scanline);\n\t\tshm_clean(&fullscreen_shm, fullscreen);\n\t\tshm_clean(&snaprect_shm, snaprect);\n\t}\n\n\t/* \n\t * Here we have to clean up quite a few shm areas for all\n\t * the possible tile row runs (40 for 1280), not as robust\n\t * as one might like... sometimes need to run ipcrm(1). \n\t */\n\tfor(i=1; i<=ntiles_x; i++) {\n\t\tif (i > tile_shm_count) {\n\t\t\tbreak;\n\t\t}\n\t\tif (quick) {\n\t\t\tshm_delete(&tile_row_shm[i]);\n\t\t} else {\n\t\t\tshm_clean(&tile_row_shm[i], tile_row[i]);\n\t\t}\n\t\tcnt++;\n\t\tif (single_copytile_count && i >= single_copytile_count) {\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (!quiet && cnt > 0) {\n\t\trfbLog(\"deleted %d tile_row polling images.\\n\", cnt);\n\t}\n}",
          "includes": [
            "#include \"xi2_devices.h\"",
            "#include \"uinput.h\"",
            "#include \"xevents.h\"",
            "#include \"xrecord.h\"",
            "#include \"screen.h\"",
            "#include \"avahi.h\"",
            "#include \"macosxCG.h\"",
            "#include \"macosx.h\"",
            "#include \"connections.h\"",
            "#include \"sslhelper.h\"",
            "#include \"sslcmds.h\"",
            "#include \"unixpw.h\"",
            "#include \"solid.h\"",
            "#include \"gui.h\"",
            "#include \"scan.h\"",
            "#include \"keyboard.h\"",
            "#include \"remote.h\"",
            "#include \"xdamage.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void clean_shm(int quick);",
            "int trap_xioerror(Display *d);",
            "static int XIOerr(Display *d);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xi2_devices.h\"\n#include \"uinput.h\"\n#include \"xevents.h\"\n#include \"xrecord.h\"\n#include \"screen.h\"\n#include \"avahi.h\"\n#include \"macosxCG.h\"\n#include \"macosx.h\"\n#include \"connections.h\"\n#include \"sslhelper.h\"\n#include \"sslcmds.h\"\n#include \"unixpw.h\"\n#include \"solid.h\"\n#include \"gui.h\"\n#include \"scan.h\"\n#include \"keyboard.h\"\n#include \"remote.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nvoid clean_shm(int quick);\nint trap_xioerror(Display *d);\nstatic int XIOerr(Display *d);\n\nvoid clean_shm(int quick) {\n\tint i, cnt = 0;\n\n\t/*\n\t * to avoid deadlock, etc, under quick=1 we just delete the shm\n\t * areas and leave the X stuff hanging.\n\t */\n\tif (quick) {\n\t\tshm_delete(&scanline_shm);\n\t\tshm_delete(&fullscreen_shm);\n\t\tshm_delete(&snaprect_shm);\n\t} else {\n\t\tshm_clean(&scanline_shm, scanline);\n\t\tshm_clean(&fullscreen_shm, fullscreen);\n\t\tshm_clean(&snaprect_shm, snaprect);\n\t}\n\n\t/* \n\t * Here we have to clean up quite a few shm areas for all\n\t * the possible tile row runs (40 for 1280), not as robust\n\t * as one might like... sometimes need to run ipcrm(1). \n\t */\n\tfor(i=1; i<=ntiles_x; i++) {\n\t\tif (i > tile_shm_count) {\n\t\t\tbreak;\n\t\t}\n\t\tif (quick) {\n\t\t\tshm_delete(&tile_row_shm[i]);\n\t\t} else {\n\t\t\tshm_clean(&tile_row_shm[i], tile_row[i]);\n\t\t}\n\t\tcnt++;\n\t\tif (single_copytile_count && i >= single_copytile_count) {\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (!quiet && cnt > 0) {\n\t\trfbLog(\"deleted %d tile_row polling images.\\n\", cnt);\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"avahi.h\"\n#include \"sslhelper.h\"\n#include \"remote.h\"\n#include \"cursor.h\"\n#include \"keyboard.h\"\n#include \"inet.h\"\n#include \"connections.h\"\n#include \"xwrappers.h\"\n#include \"sslhelper.h\"\n#include \"unixpw.h\"\n#include \"screen.h\"\n#include \"scan.h\"\n#include \"cleanup.h\"\n#include \"solid.h\"\n#include \"x11vnc.h\"\n\nint switch_user(char *user, int fb_mode);\nstatic void user2uid(char *user, uid_t *uid, gid_t *gid, char **name, char **home);\nstatic int guess_user_and_switch(char *str, int fb_mode);\nstatic int switch_user_env(uid_t uid, gid_t gid, char *name, char *home, int fb_mode);\n\nstatic int switch_user_env(uid_t uid, gid_t gid, char *name, char *home, int fb_mode) {\n\t/* NO strtoks */\n\tchar *xauth;\n\tint reset_fb = 0;\n\tint grp_ok = 0;\n\n#if !HAVE_SETUID\n\treturn 0;\n#else\n\t/*\n\t * OK, tricky here, we need to free the shm... otherwise\n\t * we won't be able to delete it as the other user...\n\t */\n\tif (fb_mode == 1 && (using_shm && ! xform24to32)) {\n\t\treset_fb = 1;\n\t\tclean_shm(0);\n\t\tfree_tiles();\n\t}\n#if HAVE_INITGROUPS\n#if HAVE_PWD_H\n\tif (getpwuid(uid) != NULL && getenv(\"X11VNC_SINGLE_GROUP\") == NULL) {\n\t\tstruct passwd *p = getpwuid(uid);\n\t\t/* another possibility is p->pw_gid instead of gid */\n\t\tif (setgid(gid) == 0 && initgroups(p->pw_name, gid) == 0)  {\n\t\t\tgrp_ok = 1;\n\t\t} else {\n\t\t\trfbLogPerror(\"initgroups\");\n\t\t}\n\t\tendgrent();\n\t}\n#endif\n#endif\n\tif (! grp_ok) {\n\t\tif (setgid(gid) == 0) {\n\t\t\tgrp_ok = 1;\n\t\t}\n\t}\n\tif (! grp_ok) {\n\t\tif (reset_fb) {\n\t\t\t/* 2 means we did clean_shm and free_tiles */\n\t\t\tdo_new_fb(2);\n\t\t}\n\t\treturn 0;\n\t}\n\n\tif (setuid(uid) != 0) {\n\t\tif (reset_fb) {\n\t\t\t/* 2 means we did clean_shm and free_tiles */\n\t\t\tdo_new_fb(2);\n\t\t}\n\t\treturn 0;\n\t}\n#endif\n\tif (reset_fb) {\n\t\tdo_new_fb(2);\n\t}\n\n\txauth = getenv(\"XAUTHORITY\");\n\tif (xauth && access(xauth, R_OK) != 0) {\n\t\t*(xauth-2) = '_';\t/* yow */\n\t}\n\t\n\tset_env(\"USER\", name);\n\tset_env(\"LOGNAME\", name);\n\tset_env(\"HOME\", home);\n\treturn 1;\n}"
  },
  {
    "function_name": "switch_user",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/user.c",
    "lines": "715-757",
    "snippet": "int switch_user(char *user, int fb_mode) {\n\t/* NO strtoks */\n\tint doit = 0;\n\tuid_t uid = 0;\n\tgid_t gid = 0;\n\tchar *name, *home;\n\n\tif (*user == '+') {\n\t\tdoit = 1;\n\t\tuser++;\n\t}\n\n\tssl_helper_pid(0, -2);\t/* waitall */\n\n\tif (strstr(user, \"guess=\") == user) {\n\t\treturn guess_user_and_switch(user, fb_mode);\n\t}\n\n\tuser2uid(user, &uid, &gid, &name, &home);\n\n\tif (uid == (uid_t) -1 || uid == 0) {\n\t\treturn 0;\n\t}\n\tif (gid == 0) {\n\t\treturn 0;\n\t}\n\n\tif (! doit && dpy) {\n\t\t/* see if this display works: */\n\t\tchar *dstr = DisplayString(dpy);\n\t\tdoit = try_user_and_display(uid, gid, dstr);\n\t}\n\n\tif (doit) {\n\t\tint rc = switch_user_env(uid, gid, name, home, fb_mode);\n\t\tif (rc) {\n\t\t\tstarted_as_root = 2;\n\t\t}\n\t\treturn rc;\n\t} else {\n\t\treturn 0;\n\t}\n}",
    "includes": [
      "#include \"avahi.h\"",
      "#include \"sslhelper.h\"",
      "#include \"remote.h\"",
      "#include \"cursor.h\"",
      "#include \"keyboard.h\"",
      "#include \"inet.h\"",
      "#include \"connections.h\"",
      "#include \"xwrappers.h\"",
      "#include \"sslhelper.h\"",
      "#include \"unixpw.h\"",
      "#include \"screen.h\"",
      "#include \"scan.h\"",
      "#include \"cleanup.h\"",
      "#include \"solid.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "int switch_user(char *user, int fb_mode);",
      "static void user2uid(char *user, uid_t *uid, gid_t *gid, char **name, char **home);",
      "static int guess_user_and_switch(char *str, int fb_mode);",
      "static int switch_user_env(uid_t uid, gid_t gid, char *name, char *home, int fb_mode);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "switch_user_env",
          "args": [
            "uid",
            "gid",
            "name",
            "home",
            "fb_mode"
          ],
          "line": 749
        },
        "resolved": true,
        "details": {
          "function_name": "switch_user_env",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/user.c",
          "lines": "759-825",
          "snippet": "static int switch_user_env(uid_t uid, gid_t gid, char *name, char *home, int fb_mode) {\n\t/* NO strtoks */\n\tchar *xauth;\n\tint reset_fb = 0;\n\tint grp_ok = 0;\n\n#if !HAVE_SETUID\n\treturn 0;\n#else\n\t/*\n\t * OK, tricky here, we need to free the shm... otherwise\n\t * we won't be able to delete it as the other user...\n\t */\n\tif (fb_mode == 1 && (using_shm && ! xform24to32)) {\n\t\treset_fb = 1;\n\t\tclean_shm(0);\n\t\tfree_tiles();\n\t}\n#if HAVE_INITGROUPS\n#if HAVE_PWD_H\n\tif (getpwuid(uid) != NULL && getenv(\"X11VNC_SINGLE_GROUP\") == NULL) {\n\t\tstruct passwd *p = getpwuid(uid);\n\t\t/* another possibility is p->pw_gid instead of gid */\n\t\tif (setgid(gid) == 0 && initgroups(p->pw_name, gid) == 0)  {\n\t\t\tgrp_ok = 1;\n\t\t} else {\n\t\t\trfbLogPerror(\"initgroups\");\n\t\t}\n\t\tendgrent();\n\t}\n#endif\n#endif\n\tif (! grp_ok) {\n\t\tif (setgid(gid) == 0) {\n\t\t\tgrp_ok = 1;\n\t\t}\n\t}\n\tif (! grp_ok) {\n\t\tif (reset_fb) {\n\t\t\t/* 2 means we did clean_shm and free_tiles */\n\t\t\tdo_new_fb(2);\n\t\t}\n\t\treturn 0;\n\t}\n\n\tif (setuid(uid) != 0) {\n\t\tif (reset_fb) {\n\t\t\t/* 2 means we did clean_shm and free_tiles */\n\t\t\tdo_new_fb(2);\n\t\t}\n\t\treturn 0;\n\t}\n#endif\n\tif (reset_fb) {\n\t\tdo_new_fb(2);\n\t}\n\n\txauth = getenv(\"XAUTHORITY\");\n\tif (xauth && access(xauth, R_OK) != 0) {\n\t\t*(xauth-2) = '_';\t/* yow */\n\t}\n\t\n\tset_env(\"USER\", name);\n\tset_env(\"LOGNAME\", name);\n\tset_env(\"HOME\", home);\n\treturn 1;\n}",
          "includes": [
            "#include \"avahi.h\"",
            "#include \"sslhelper.h\"",
            "#include \"remote.h\"",
            "#include \"cursor.h\"",
            "#include \"keyboard.h\"",
            "#include \"inet.h\"",
            "#include \"connections.h\"",
            "#include \"xwrappers.h\"",
            "#include \"sslhelper.h\"",
            "#include \"unixpw.h\"",
            "#include \"screen.h\"",
            "#include \"scan.h\"",
            "#include \"cleanup.h\"",
            "#include \"solid.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int switch_user(char *user, int fb_mode);",
            "static void user2uid(char *user, uid_t *uid, gid_t *gid, char **name, char **home);",
            "static int guess_user_and_switch(char *str, int fb_mode);",
            "static int switch_user_env(uid_t uid, gid_t gid, char *name, char *home, int fb_mode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"avahi.h\"\n#include \"sslhelper.h\"\n#include \"remote.h\"\n#include \"cursor.h\"\n#include \"keyboard.h\"\n#include \"inet.h\"\n#include \"connections.h\"\n#include \"xwrappers.h\"\n#include \"sslhelper.h\"\n#include \"unixpw.h\"\n#include \"screen.h\"\n#include \"scan.h\"\n#include \"cleanup.h\"\n#include \"solid.h\"\n#include \"x11vnc.h\"\n\nint switch_user(char *user, int fb_mode);\nstatic void user2uid(char *user, uid_t *uid, gid_t *gid, char **name, char **home);\nstatic int guess_user_and_switch(char *str, int fb_mode);\nstatic int switch_user_env(uid_t uid, gid_t gid, char *name, char *home, int fb_mode);\n\nstatic int switch_user_env(uid_t uid, gid_t gid, char *name, char *home, int fb_mode) {\n\t/* NO strtoks */\n\tchar *xauth;\n\tint reset_fb = 0;\n\tint grp_ok = 0;\n\n#if !HAVE_SETUID\n\treturn 0;\n#else\n\t/*\n\t * OK, tricky here, we need to free the shm... otherwise\n\t * we won't be able to delete it as the other user...\n\t */\n\tif (fb_mode == 1 && (using_shm && ! xform24to32)) {\n\t\treset_fb = 1;\n\t\tclean_shm(0);\n\t\tfree_tiles();\n\t}\n#if HAVE_INITGROUPS\n#if HAVE_PWD_H\n\tif (getpwuid(uid) != NULL && getenv(\"X11VNC_SINGLE_GROUP\") == NULL) {\n\t\tstruct passwd *p = getpwuid(uid);\n\t\t/* another possibility is p->pw_gid instead of gid */\n\t\tif (setgid(gid) == 0 && initgroups(p->pw_name, gid) == 0)  {\n\t\t\tgrp_ok = 1;\n\t\t} else {\n\t\t\trfbLogPerror(\"initgroups\");\n\t\t}\n\t\tendgrent();\n\t}\n#endif\n#endif\n\tif (! grp_ok) {\n\t\tif (setgid(gid) == 0) {\n\t\t\tgrp_ok = 1;\n\t\t}\n\t}\n\tif (! grp_ok) {\n\t\tif (reset_fb) {\n\t\t\t/* 2 means we did clean_shm and free_tiles */\n\t\t\tdo_new_fb(2);\n\t\t}\n\t\treturn 0;\n\t}\n\n\tif (setuid(uid) != 0) {\n\t\tif (reset_fb) {\n\t\t\t/* 2 means we did clean_shm and free_tiles */\n\t\t\tdo_new_fb(2);\n\t\t}\n\t\treturn 0;\n\t}\n#endif\n\tif (reset_fb) {\n\t\tdo_new_fb(2);\n\t}\n\n\txauth = getenv(\"XAUTHORITY\");\n\tif (xauth && access(xauth, R_OK) != 0) {\n\t\t*(xauth-2) = '_';\t/* yow */\n\t}\n\t\n\tset_env(\"USER\", name);\n\tset_env(\"LOGNAME\", name);\n\tset_env(\"HOME\", home);\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "try_user_and_display",
          "args": [
            "uid",
            "gid",
            "dstr"
          ],
          "line": 745
        },
        "resolved": true,
        "details": {
          "function_name": "try_user_and_display",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/user.c",
          "lines": "652-713",
          "snippet": "static int try_user_and_display(uid_t uid, gid_t gid, char *dpystr) {\n\t/* NO strtoks */\n#if LIBVNCSERVER_HAVE_FORK && LIBVNCSERVER_HAVE_SYS_WAIT_H && HAVE_PWD_H\n\tpid_t pid, pidw;\n\tchar *home, *name;\n\tint st;\n\tstruct passwd *pw;\n\t\n\tpw = getpwuid(uid);\n\tif (pw) {\n\t\tname = pw->pw_name;\n\t\thome = pw->pw_dir;\n\t} else {\n\t\treturn 0;\n\t}\n\n\t/* \n\t * We fork here and try to open the display again as the\n\t * new user.  Unreadable XAUTHORITY could be a problem...\n\t * This is not really needed since we have DISPLAY open but:\n\t * 1) is a good indicator this user owns the session and  2)\n\t * some activities do spawn new X apps, e.g.  xmessage(1), etc.\n\t */\n\tif ((pid = fork()) > 0) {\n\t\t;\n\t} else if (pid == -1) {\n\t\tfprintf(stderr, \"could not fork\\n\");\n\t\trfbLogPerror(\"fork\");\n\t\treturn 0;\n\t} else {\n\t\t/* child */\n\t\tDisplay *dpy2 = NULL;\n\t\tint rc;\n\n\t\tsignal(SIGHUP,  SIG_DFL);\n\t\tsignal(SIGINT,  SIG_DFL);\n\t\tsignal(SIGQUIT, SIG_DFL);\n\t\tsignal(SIGTERM, SIG_DFL);\n\n\t\trc = switch_user_env(uid, gid, name, home, 0); \n\t\tif (! rc) {\n\t\t\texit(1);\n\t\t}\n\n\t\tfclose(stderr);\n\t\tdpy2 = XOpenDisplay_wr(dpystr);\n\t\tif (dpy2) {\n\t\t\tXCloseDisplay_wr(dpy2);\n\t\t\texit(0);\t/* success */\n\t\t} else {\n\t\t\texit(2);\t/* fail */\n\t\t}\n\t}\n\n\t/* see what the child says: */\n\tpidw = waitpid(pid, &st, 0);\n\tif (pidw == pid && WIFEXITED(st) && WEXITSTATUS(st) == 0) {\n\t\treturn 1;\n\t}\n#endif\t/* LIBVNCSERVER_HAVE_FORK ... */\n\treturn 0;\n}",
          "includes": [
            "#include \"avahi.h\"",
            "#include \"sslhelper.h\"",
            "#include \"remote.h\"",
            "#include \"cursor.h\"",
            "#include \"keyboard.h\"",
            "#include \"inet.h\"",
            "#include \"connections.h\"",
            "#include \"xwrappers.h\"",
            "#include \"sslhelper.h\"",
            "#include \"unixpw.h\"",
            "#include \"screen.h\"",
            "#include \"scan.h\"",
            "#include \"cleanup.h\"",
            "#include \"solid.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void user2uid(char *user, uid_t *uid, gid_t *gid, char **name, char **home);",
            "static int try_user_and_display(uid_t uid, gid_t gid, char *dpystr);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"avahi.h\"\n#include \"sslhelper.h\"\n#include \"remote.h\"\n#include \"cursor.h\"\n#include \"keyboard.h\"\n#include \"inet.h\"\n#include \"connections.h\"\n#include \"xwrappers.h\"\n#include \"sslhelper.h\"\n#include \"unixpw.h\"\n#include \"screen.h\"\n#include \"scan.h\"\n#include \"cleanup.h\"\n#include \"solid.h\"\n#include \"x11vnc.h\"\n\nstatic void user2uid(char *user, uid_t *uid, gid_t *gid, char **name, char **home);\nstatic int try_user_and_display(uid_t uid, gid_t gid, char *dpystr);\n\nstatic int try_user_and_display(uid_t uid, gid_t gid, char *dpystr) {\n\t/* NO strtoks */\n#if LIBVNCSERVER_HAVE_FORK && LIBVNCSERVER_HAVE_SYS_WAIT_H && HAVE_PWD_H\n\tpid_t pid, pidw;\n\tchar *home, *name;\n\tint st;\n\tstruct passwd *pw;\n\t\n\tpw = getpwuid(uid);\n\tif (pw) {\n\t\tname = pw->pw_name;\n\t\thome = pw->pw_dir;\n\t} else {\n\t\treturn 0;\n\t}\n\n\t/* \n\t * We fork here and try to open the display again as the\n\t * new user.  Unreadable XAUTHORITY could be a problem...\n\t * This is not really needed since we have DISPLAY open but:\n\t * 1) is a good indicator this user owns the session and  2)\n\t * some activities do spawn new X apps, e.g.  xmessage(1), etc.\n\t */\n\tif ((pid = fork()) > 0) {\n\t\t;\n\t} else if (pid == -1) {\n\t\tfprintf(stderr, \"could not fork\\n\");\n\t\trfbLogPerror(\"fork\");\n\t\treturn 0;\n\t} else {\n\t\t/* child */\n\t\tDisplay *dpy2 = NULL;\n\t\tint rc;\n\n\t\tsignal(SIGHUP,  SIG_DFL);\n\t\tsignal(SIGINT,  SIG_DFL);\n\t\tsignal(SIGQUIT, SIG_DFL);\n\t\tsignal(SIGTERM, SIG_DFL);\n\n\t\trc = switch_user_env(uid, gid, name, home, 0); \n\t\tif (! rc) {\n\t\t\texit(1);\n\t\t}\n\n\t\tfclose(stderr);\n\t\tdpy2 = XOpenDisplay_wr(dpystr);\n\t\tif (dpy2) {\n\t\t\tXCloseDisplay_wr(dpy2);\n\t\t\texit(0);\t/* success */\n\t\t} else {\n\t\t\texit(2);\t/* fail */\n\t\t}\n\t}\n\n\t/* see what the child says: */\n\tpidw = waitpid(pid, &st, 0);\n\tif (pidw == pid && WIFEXITED(st) && WEXITSTATUS(st) == 0) {\n\t\treturn 1;\n\t}\n#endif\t/* LIBVNCSERVER_HAVE_FORK ... */\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "DisplayString",
          "args": [
            "dpy"
          ],
          "line": 744
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "user2uid",
          "args": [
            "user",
            "&uid",
            "&gid",
            "&name",
            "&home"
          ],
          "line": 733
        },
        "resolved": true,
        "details": {
          "function_name": "user2uid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/user.c",
          "lines": "274-361",
          "snippet": "static void user2uid(char *user, uid_t *uid, gid_t *gid, char **name, char **home) {\n\tint numerical = 1, gotgroup = 0;\n\tchar *q;\n\n\t*uid = (uid_t) -1;\n\t*name = NULL;\n\t*home = NULL;\n\n\tq = user;\n\twhile (*q) {\n\t\tif (! isdigit((unsigned char) (*q++))) {\n\t\t\tnumerical = 0;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (user2group != NULL) {\n\t\tstatic int *did = NULL;\n\t\tint i;\n\n\t\tif (did == NULL) {\n\t\t\tint n = 0;\n\t\t\ti = 0;\n\t\t\twhile (user2group[i] != NULL) {\n\t\t\t\tn++;\n\t\t\t\ti++;\n\t\t\t}\n\t\t\tdid = (int *) malloc((n+1) * sizeof(int)); \n\t\t\ti = 0;\n\t\t\tfor (i=0; i<n; i++) {\n\t\t\t\tdid[i] = 0;\n\t\t\t}\n\t\t}\n\t\ti = 0;\n\t\twhile (user2group[i] != NULL) {\n\t\t\tif (strstr(user2group[i], user) == user2group[i]) {\n\t\t\t\tchar *w = user2group[i] + strlen(user);\n\t\t\t\tif (*w == '.') {\n#if (SMALL_FOOTPRINT > 2)\n\t\t\t\t\tgotgroup = 0;\n#else\n\t\t\t\t\tstruct group* gr = getgrnam(++w);\n\t\t\t\t\tif (! gr) {\n\t\t\t\t\t\trfbLog(\"Invalid group: %s\\n\", w);\n\t\t\t\t\t\tclean_up_exit(1);\n\t\t\t\t\t}\n\t\t\t\t\t*gid = gr->gr_gid;\n\t\t\t\t\tif (! did[i]) {\n\t\t\t\t\t\trfbLog(\"user2uid: using group %s (%d) for %s\\n\",\n\t\t\t\t\t\t    w, (int) *gid, user);\n\t\t\t\t\t\tdid[i] = 1;\n\t\t\t\t\t}\n\t\t\t\t\tgotgroup = 1;\n#endif\n\t\t\t\t}\n\t\t\t}\n\t\t\ti++;\n\t\t}\n\t}\n\n\tif (numerical) {\n\t\tint u = atoi(user);\n\n\t\tif (u < 0) {\n\t\t\treturn;\n\t\t}\n\t\t*uid = (uid_t) u;\n\t}\n\n#if HAVE_PWD_H\n\tif (1) {\n\t\tstruct passwd *pw;\n\t\tif (numerical) {\n\t\t\tpw = getpwuid(*uid);\n\t\t} else {\n\t\t\tpw = getpwnam(user);\n\t\t}\n\t\tif (pw) {\n\t\t\t*uid  = pw->pw_uid;\n\t\t\tif (! gotgroup) {\n\t\t\t\t*gid  = pw->pw_gid;\n\t\t\t}\n\t\t\t*name = pw->pw_name;\t/* n.b. use immediately */\n\t\t\t*home = pw->pw_dir;\n\t\t}\n\t}\n#endif\n}",
          "includes": [
            "#include \"avahi.h\"",
            "#include \"sslhelper.h\"",
            "#include \"remote.h\"",
            "#include \"cursor.h\"",
            "#include \"keyboard.h\"",
            "#include \"inet.h\"",
            "#include \"connections.h\"",
            "#include \"xwrappers.h\"",
            "#include \"sslhelper.h\"",
            "#include \"unixpw.h\"",
            "#include \"screen.h\"",
            "#include \"scan.h\"",
            "#include \"cleanup.h\"",
            "#include \"solid.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void user2uid(char *user, uid_t *uid, gid_t *gid, char **name, char **home);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"avahi.h\"\n#include \"sslhelper.h\"\n#include \"remote.h\"\n#include \"cursor.h\"\n#include \"keyboard.h\"\n#include \"inet.h\"\n#include \"connections.h\"\n#include \"xwrappers.h\"\n#include \"sslhelper.h\"\n#include \"unixpw.h\"\n#include \"screen.h\"\n#include \"scan.h\"\n#include \"cleanup.h\"\n#include \"solid.h\"\n#include \"x11vnc.h\"\n\nstatic void user2uid(char *user, uid_t *uid, gid_t *gid, char **name, char **home);\n\nstatic void user2uid(char *user, uid_t *uid, gid_t *gid, char **name, char **home) {\n\tint numerical = 1, gotgroup = 0;\n\tchar *q;\n\n\t*uid = (uid_t) -1;\n\t*name = NULL;\n\t*home = NULL;\n\n\tq = user;\n\twhile (*q) {\n\t\tif (! isdigit((unsigned char) (*q++))) {\n\t\t\tnumerical = 0;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (user2group != NULL) {\n\t\tstatic int *did = NULL;\n\t\tint i;\n\n\t\tif (did == NULL) {\n\t\t\tint n = 0;\n\t\t\ti = 0;\n\t\t\twhile (user2group[i] != NULL) {\n\t\t\t\tn++;\n\t\t\t\ti++;\n\t\t\t}\n\t\t\tdid = (int *) malloc((n+1) * sizeof(int)); \n\t\t\ti = 0;\n\t\t\tfor (i=0; i<n; i++) {\n\t\t\t\tdid[i] = 0;\n\t\t\t}\n\t\t}\n\t\ti = 0;\n\t\twhile (user2group[i] != NULL) {\n\t\t\tif (strstr(user2group[i], user) == user2group[i]) {\n\t\t\t\tchar *w = user2group[i] + strlen(user);\n\t\t\t\tif (*w == '.') {\n#if (SMALL_FOOTPRINT > 2)\n\t\t\t\t\tgotgroup = 0;\n#else\n\t\t\t\t\tstruct group* gr = getgrnam(++w);\n\t\t\t\t\tif (! gr) {\n\t\t\t\t\t\trfbLog(\"Invalid group: %s\\n\", w);\n\t\t\t\t\t\tclean_up_exit(1);\n\t\t\t\t\t}\n\t\t\t\t\t*gid = gr->gr_gid;\n\t\t\t\t\tif (! did[i]) {\n\t\t\t\t\t\trfbLog(\"user2uid: using group %s (%d) for %s\\n\",\n\t\t\t\t\t\t    w, (int) *gid, user);\n\t\t\t\t\t\tdid[i] = 1;\n\t\t\t\t\t}\n\t\t\t\t\tgotgroup = 1;\n#endif\n\t\t\t\t}\n\t\t\t}\n\t\t\ti++;\n\t\t}\n\t}\n\n\tif (numerical) {\n\t\tint u = atoi(user);\n\n\t\tif (u < 0) {\n\t\t\treturn;\n\t\t}\n\t\t*uid = (uid_t) u;\n\t}\n\n#if HAVE_PWD_H\n\tif (1) {\n\t\tstruct passwd *pw;\n\t\tif (numerical) {\n\t\t\tpw = getpwuid(*uid);\n\t\t} else {\n\t\t\tpw = getpwnam(user);\n\t\t}\n\t\tif (pw) {\n\t\t\t*uid  = pw->pw_uid;\n\t\t\tif (! gotgroup) {\n\t\t\t\t*gid  = pw->pw_gid;\n\t\t\t}\n\t\t\t*name = pw->pw_name;\t/* n.b. use immediately */\n\t\t\t*home = pw->pw_dir;\n\t\t}\n\t}\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "guess_user_and_switch",
          "args": [
            "user",
            "fb_mode"
          ],
          "line": 730
        },
        "resolved": true,
        "details": {
          "function_name": "guess_user_and_switch",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/user.c",
          "lines": "556-650",
          "snippet": "static int guess_user_and_switch(char *str, int fb_mode) {\n\tchar *dstr, *d;\n\tchar *p, *tstr = NULL, *allowed = NULL, *logins, **users = NULL;\n\tint dpy1, ret = 0;\n\tchar **list;\n\tint lind;\n\n\tRAWFB_RET(0)\n\n\td = DisplayString(dpy);\n\t/* pick out \":N\" */\n\tdstr = strchr(d, ':');\n\tif (! dstr) {\n\t\treturn 0;\n\t}\n\tif (sscanf(dstr, \":%d\", &dpy1) != 1) {\n\t\treturn 0;\n\t}\n\tif (dpy1 < 0) {\n\t\treturn 0;\n\t}\n\n\tif (strstr(str, \"guess=\") == str && strlen(str) > strlen(\"guess=\")) {\n\t\tallowed = strchr(str, '=');\n\t\tallowed++;\n\n\t\ttstr = strdup(allowed);\n\t\tusers = user_list(tstr);\n\t}\n\n\t/* loop over the utmpx entries looking for this display */\n\tlogins = get_login_list(1);\n\n\tlist = (char **) calloc((strlen(logins)+2)*sizeof(char *), 1);\n\tlind = 0;\n\tp = strtok(logins, \",\");\n\twhile (p) {\n\t\tlist[lind++] = strdup(p);\n\t\tp = strtok(NULL, \",\");\n\t}\n\n\tlind = 0;\n\twhile (list[lind] != NULL) {\n\t\tchar *user, *q, *t;\n\t\tint dpy2, ok = 1;\n\n\t\tp = list[lind++];\n\n\t\tt = strdup(p);\n\t\tq = strchr(t, ':'); \n\t\tif (! q) {\n\t\t\tfree(t);\n\t\t\tbreak;\n\t\t}\n\t\t*q = '\\0';\n\t\tuser = t;\n\t\tdpy2 = atoi(q+1);\n\n\t\tif (users) {\n\t\t\tchar **u = users;\n\t\t\tok = 0;\n\t\t\twhile (*u != NULL) {\n\t\t\t\tif (!strcmp(user, *u++)) {\n\t\t\t\t\tok = 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (dpy1 != dpy2) {\n\t\t\tok = 0;\n\t\t}\n\n\t\tif (! ok) {\n\t\t\tfree(t);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (switch_user(user, fb_mode)) {\n\t\t\trfbLog(\"switched to guessed user: %s\\n\", user);\n\t\t\tfree(t);\n\t\t\tret = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (tstr) {\n\t\tfree(tstr);\n\t}\n\tif (users) {\n\t\tfree(users);\n\t}\n\tif (logins) {\n\t\tfree(logins);\n\t}\n\treturn ret;\n}",
          "includes": [
            "#include \"avahi.h\"",
            "#include \"sslhelper.h\"",
            "#include \"remote.h\"",
            "#include \"cursor.h\"",
            "#include \"keyboard.h\"",
            "#include \"inet.h\"",
            "#include \"connections.h\"",
            "#include \"xwrappers.h\"",
            "#include \"sslhelper.h\"",
            "#include \"unixpw.h\"",
            "#include \"screen.h\"",
            "#include \"scan.h\"",
            "#include \"cleanup.h\"",
            "#include \"solid.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void lurk_loop(char *str);",
            "int switch_user(char *user, int fb_mode);",
            "static int lurk(char **users);",
            "static int guess_user_and_switch(char *str, int fb_mode);",
            "static int switch_user_env(uid_t uid, gid_t gid, char *name, char *home, int fb_mode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"avahi.h\"\n#include \"sslhelper.h\"\n#include \"remote.h\"\n#include \"cursor.h\"\n#include \"keyboard.h\"\n#include \"inet.h\"\n#include \"connections.h\"\n#include \"xwrappers.h\"\n#include \"sslhelper.h\"\n#include \"unixpw.h\"\n#include \"screen.h\"\n#include \"scan.h\"\n#include \"cleanup.h\"\n#include \"solid.h\"\n#include \"x11vnc.h\"\n\nvoid lurk_loop(char *str);\nint switch_user(char *user, int fb_mode);\nstatic int lurk(char **users);\nstatic int guess_user_and_switch(char *str, int fb_mode);\nstatic int switch_user_env(uid_t uid, gid_t gid, char *name, char *home, int fb_mode);\n\nstatic int guess_user_and_switch(char *str, int fb_mode) {\n\tchar *dstr, *d;\n\tchar *p, *tstr = NULL, *allowed = NULL, *logins, **users = NULL;\n\tint dpy1, ret = 0;\n\tchar **list;\n\tint lind;\n\n\tRAWFB_RET(0)\n\n\td = DisplayString(dpy);\n\t/* pick out \":N\" */\n\tdstr = strchr(d, ':');\n\tif (! dstr) {\n\t\treturn 0;\n\t}\n\tif (sscanf(dstr, \":%d\", &dpy1) != 1) {\n\t\treturn 0;\n\t}\n\tif (dpy1 < 0) {\n\t\treturn 0;\n\t}\n\n\tif (strstr(str, \"guess=\") == str && strlen(str) > strlen(\"guess=\")) {\n\t\tallowed = strchr(str, '=');\n\t\tallowed++;\n\n\t\ttstr = strdup(allowed);\n\t\tusers = user_list(tstr);\n\t}\n\n\t/* loop over the utmpx entries looking for this display */\n\tlogins = get_login_list(1);\n\n\tlist = (char **) calloc((strlen(logins)+2)*sizeof(char *), 1);\n\tlind = 0;\n\tp = strtok(logins, \",\");\n\twhile (p) {\n\t\tlist[lind++] = strdup(p);\n\t\tp = strtok(NULL, \",\");\n\t}\n\n\tlind = 0;\n\twhile (list[lind] != NULL) {\n\t\tchar *user, *q, *t;\n\t\tint dpy2, ok = 1;\n\n\t\tp = list[lind++];\n\n\t\tt = strdup(p);\n\t\tq = strchr(t, ':'); \n\t\tif (! q) {\n\t\t\tfree(t);\n\t\t\tbreak;\n\t\t}\n\t\t*q = '\\0';\n\t\tuser = t;\n\t\tdpy2 = atoi(q+1);\n\n\t\tif (users) {\n\t\t\tchar **u = users;\n\t\t\tok = 0;\n\t\t\twhile (*u != NULL) {\n\t\t\t\tif (!strcmp(user, *u++)) {\n\t\t\t\t\tok = 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (dpy1 != dpy2) {\n\t\t\tok = 0;\n\t\t}\n\n\t\tif (! ok) {\n\t\t\tfree(t);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (switch_user(user, fb_mode)) {\n\t\t\trfbLog(\"switched to guessed user: %s\\n\", user);\n\t\t\tfree(t);\n\t\t\tret = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (tstr) {\n\t\tfree(tstr);\n\t}\n\tif (users) {\n\t\tfree(users);\n\t}\n\tif (logins) {\n\t\tfree(logins);\n\t}\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "user",
            "\"guess=\""
          ],
          "line": 729
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ssl_helper_pid",
          "args": [
            "0",
            "-2"
          ],
          "line": 727
        },
        "resolved": true,
        "details": {
          "function_name": "ssl_helper_pid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/sslhelper.c",
          "lines": "2999-3117",
          "snippet": "void ssl_helper_pid(pid_t pid, int sock) {\n#\tdefine HPSIZE 256\n\tstatic pid_t helpers[HPSIZE];\n\tstatic int   sockets[HPSIZE], first = 1;\n\tint i, empty, set, status;\n\tstatic int db = 0;\n\n\tif (first) {\n\t\tfor (i=0; i < HPSIZE; i++)  {\n\t\t\thelpers[i] = 0;\n\t\t\tsockets[i] = 0;\n\t\t}\n\t\tif (getenv(\"SSL_HELPER_PID_DB\")) {\n\t\t\tdb = 1;\n\t\t}\n\t\tfirst = 0;\n\t}\n\n\n\tif (pid == 0) {\n\t\t/* killall or waitall */\n\t\tfor (i=0; i < HPSIZE; i++) {\n\t\t\tif (helpers[i] == 0) {\n\t\t\t\tsockets[i] = -1;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (kill(helpers[i], 0) == 0) {\n\t\t\t\tint kret = -2;\n\t\t\t\tpid_t wret;\n\t\t\t\tif (sock != -2) {\n\t\t\t\t\tif (sockets[i] >= 0) {\n\t\t\t\t\t\tclose(sockets[i]);\n\t\t\t\t\t}\n\t\t\t\t\tkret = kill(helpers[i], SIGTERM);\n\t\t\t\t\tif (kret == 0) {\n\t\t\t\t\t\tusleep(20 * 1000);\n\t\t\t\t\t}\n\t\t\t\t}\n\n#if LIBVNCSERVER_HAVE_SYS_WAIT_H && HAVE_WAITPID\n\t\t\t\twret = waitpid(helpers[i], &status, WNOHANG); \n\nif (db) fprintf(stderr, \"waitpid(%d)\\n\", helpers[i]);\nif (db) fprintf(stderr, \"  waitret1=%d\\n\", wret);\n\n\t\t\t\tif (kret == 0 && wret != helpers[i]) {\n\t\t\t\t\tint k;\n\t\t\t\t\tfor (k=0; k < 10; k++) {\n\t\t\t\t\t\tusleep(100 * 1000);\n\t\t\t\t\t\twret = waitpid(helpers[i], &status, WNOHANG); \nif (db) fprintf(stderr, \"  waitret2=%d\\n\", wret);\n\t\t\t\t\t\tif (wret == helpers[i]) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n#endif\n\t\t\t\tif (sock == -2) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\t\t\thelpers[i] = 0;\n\t\t\tsockets[i] = -1;\n\t\t}\n\t\treturn;\n\t}\n\nif (db) fprintf(stderr, \"ssl_helper_pid(%d, %d)\\n\", pid, sock);\n\n\t/* add (or delete for sock == -1) */\n\tset = 0;\n\tempty = -1;\n\tfor (i=0; i < HPSIZE; i++) {\n\t\tif (helpers[i] == pid) {\n\t\t\tif (sock == -1) {\n#if LIBVNCSERVER_HAVE_SYS_WAIT_H && HAVE_WAITPID\n\t\t\t\tpid_t wret;\n\t\t\t\twret = waitpid(helpers[i], &status, WNOHANG); \n\nif (db) fprintf(stderr, \"waitpid(%d) 2\\n\", helpers[i]);\nif (db) fprintf(stderr, \"  waitret1=%d\\n\", wret);\n#endif\n\t\t\t\thelpers[i] = 0;\n\t\t\t}\n\t\t\tsockets[i] = sock;\n\t\t\tset = 1;\n\t\t} else if (empty == -1 && helpers[i] == 0) {\n\t\t\tempty = i;\n\t\t}\n\t}\n\tif (set || sock == -1) {\n\t\treturn;\t/* done */\n\t}\n\n\t/* now try to store */\n\tif (empty >= 0) {\n\t\thelpers[empty] = pid;\n\t\tsockets[empty] = sock;\n\t\treturn;\n\t}\n\tfor (i=0; i < HPSIZE; i++) {\n\t\tif (helpers[i] == 0) {\n\t\t\tcontinue;\n\t\t}\n\t\t/* clear out stale pids: */\n\t\tif (kill(helpers[i], 0) != 0) {\n\t\t\thelpers[i] = 0;\n\t\t\tsockets[i] = -1;\n\t\t\t\n\t\t\tif (empty == -1) {\n\t\t\t\tempty = i;\n\t\t\t}\n\t\t}\n\t}\n\tif (empty >= 0) {\n\t\thelpers[empty] = pid;\n\t\tsockets[empty] = sock;\n\t}\n}",
          "includes": [
            "#include <openssl/rand.h>",
            "#include <openssl/err.h>",
            "#include <openssl/ssl.h>",
            "#include \"user.h\"",
            "#include \"unixpw.h\"",
            "#include \"sslcmds.h\"",
            "#include \"connections.h\"",
            "#include \"scan.h\"",
            "#include \"screen.h\"",
            "#include \"cleanup.h\"",
            "#include \"inet.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void ssl_helper_pid(pid_t pid, int sock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <openssl/rand.h>\n#include <openssl/err.h>\n#include <openssl/ssl.h>\n#include \"user.h\"\n#include \"unixpw.h\"\n#include \"sslcmds.h\"\n#include \"connections.h\"\n#include \"scan.h\"\n#include \"screen.h\"\n#include \"cleanup.h\"\n#include \"inet.h\"\n#include \"x11vnc.h\"\n\nvoid ssl_helper_pid(pid_t pid, int sock);\n\nvoid ssl_helper_pid(pid_t pid, int sock) {\n#\tdefine HPSIZE 256\n\tstatic pid_t helpers[HPSIZE];\n\tstatic int   sockets[HPSIZE], first = 1;\n\tint i, empty, set, status;\n\tstatic int db = 0;\n\n\tif (first) {\n\t\tfor (i=0; i < HPSIZE; i++)  {\n\t\t\thelpers[i] = 0;\n\t\t\tsockets[i] = 0;\n\t\t}\n\t\tif (getenv(\"SSL_HELPER_PID_DB\")) {\n\t\t\tdb = 1;\n\t\t}\n\t\tfirst = 0;\n\t}\n\n\n\tif (pid == 0) {\n\t\t/* killall or waitall */\n\t\tfor (i=0; i < HPSIZE; i++) {\n\t\t\tif (helpers[i] == 0) {\n\t\t\t\tsockets[i] = -1;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (kill(helpers[i], 0) == 0) {\n\t\t\t\tint kret = -2;\n\t\t\t\tpid_t wret;\n\t\t\t\tif (sock != -2) {\n\t\t\t\t\tif (sockets[i] >= 0) {\n\t\t\t\t\t\tclose(sockets[i]);\n\t\t\t\t\t}\n\t\t\t\t\tkret = kill(helpers[i], SIGTERM);\n\t\t\t\t\tif (kret == 0) {\n\t\t\t\t\t\tusleep(20 * 1000);\n\t\t\t\t\t}\n\t\t\t\t}\n\n#if LIBVNCSERVER_HAVE_SYS_WAIT_H && HAVE_WAITPID\n\t\t\t\twret = waitpid(helpers[i], &status, WNOHANG); \n\nif (db) fprintf(stderr, \"waitpid(%d)\\n\", helpers[i]);\nif (db) fprintf(stderr, \"  waitret1=%d\\n\", wret);\n\n\t\t\t\tif (kret == 0 && wret != helpers[i]) {\n\t\t\t\t\tint k;\n\t\t\t\t\tfor (k=0; k < 10; k++) {\n\t\t\t\t\t\tusleep(100 * 1000);\n\t\t\t\t\t\twret = waitpid(helpers[i], &status, WNOHANG); \nif (db) fprintf(stderr, \"  waitret2=%d\\n\", wret);\n\t\t\t\t\t\tif (wret == helpers[i]) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n#endif\n\t\t\t\tif (sock == -2) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\t\t\thelpers[i] = 0;\n\t\t\tsockets[i] = -1;\n\t\t}\n\t\treturn;\n\t}\n\nif (db) fprintf(stderr, \"ssl_helper_pid(%d, %d)\\n\", pid, sock);\n\n\t/* add (or delete for sock == -1) */\n\tset = 0;\n\tempty = -1;\n\tfor (i=0; i < HPSIZE; i++) {\n\t\tif (helpers[i] == pid) {\n\t\t\tif (sock == -1) {\n#if LIBVNCSERVER_HAVE_SYS_WAIT_H && HAVE_WAITPID\n\t\t\t\tpid_t wret;\n\t\t\t\twret = waitpid(helpers[i], &status, WNOHANG); \n\nif (db) fprintf(stderr, \"waitpid(%d) 2\\n\", helpers[i]);\nif (db) fprintf(stderr, \"  waitret1=%d\\n\", wret);\n#endif\n\t\t\t\thelpers[i] = 0;\n\t\t\t}\n\t\t\tsockets[i] = sock;\n\t\t\tset = 1;\n\t\t} else if (empty == -1 && helpers[i] == 0) {\n\t\t\tempty = i;\n\t\t}\n\t}\n\tif (set || sock == -1) {\n\t\treturn;\t/* done */\n\t}\n\n\t/* now try to store */\n\tif (empty >= 0) {\n\t\thelpers[empty] = pid;\n\t\tsockets[empty] = sock;\n\t\treturn;\n\t}\n\tfor (i=0; i < HPSIZE; i++) {\n\t\tif (helpers[i] == 0) {\n\t\t\tcontinue;\n\t\t}\n\t\t/* clear out stale pids: */\n\t\tif (kill(helpers[i], 0) != 0) {\n\t\t\thelpers[i] = 0;\n\t\t\tsockets[i] = -1;\n\t\t\t\n\t\t\tif (empty == -1) {\n\t\t\t\tempty = i;\n\t\t\t}\n\t\t}\n\t}\n\tif (empty >= 0) {\n\t\thelpers[empty] = pid;\n\t\tsockets[empty] = sock;\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"avahi.h\"\n#include \"sslhelper.h\"\n#include \"remote.h\"\n#include \"cursor.h\"\n#include \"keyboard.h\"\n#include \"inet.h\"\n#include \"connections.h\"\n#include \"xwrappers.h\"\n#include \"sslhelper.h\"\n#include \"unixpw.h\"\n#include \"screen.h\"\n#include \"scan.h\"\n#include \"cleanup.h\"\n#include \"solid.h\"\n#include \"x11vnc.h\"\n\nint switch_user(char *user, int fb_mode);\nstatic void user2uid(char *user, uid_t *uid, gid_t *gid, char **name, char **home);\nstatic int guess_user_and_switch(char *str, int fb_mode);\nstatic int switch_user_env(uid_t uid, gid_t gid, char *name, char *home, int fb_mode);\n\nint switch_user(char *user, int fb_mode) {\n\t/* NO strtoks */\n\tint doit = 0;\n\tuid_t uid = 0;\n\tgid_t gid = 0;\n\tchar *name, *home;\n\n\tif (*user == '+') {\n\t\tdoit = 1;\n\t\tuser++;\n\t}\n\n\tssl_helper_pid(0, -2);\t/* waitall */\n\n\tif (strstr(user, \"guess=\") == user) {\n\t\treturn guess_user_and_switch(user, fb_mode);\n\t}\n\n\tuser2uid(user, &uid, &gid, &name, &home);\n\n\tif (uid == (uid_t) -1 || uid == 0) {\n\t\treturn 0;\n\t}\n\tif (gid == 0) {\n\t\treturn 0;\n\t}\n\n\tif (! doit && dpy) {\n\t\t/* see if this display works: */\n\t\tchar *dstr = DisplayString(dpy);\n\t\tdoit = try_user_and_display(uid, gid, dstr);\n\t}\n\n\tif (doit) {\n\t\tint rc = switch_user_env(uid, gid, name, home, fb_mode);\n\t\tif (rc) {\n\t\t\tstarted_as_root = 2;\n\t\t}\n\t\treturn rc;\n\t} else {\n\t\treturn 0;\n\t}\n}"
  },
  {
    "function_name": "try_user_and_display",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/user.c",
    "lines": "652-713",
    "snippet": "static int try_user_and_display(uid_t uid, gid_t gid, char *dpystr) {\n\t/* NO strtoks */\n#if LIBVNCSERVER_HAVE_FORK && LIBVNCSERVER_HAVE_SYS_WAIT_H && HAVE_PWD_H\n\tpid_t pid, pidw;\n\tchar *home, *name;\n\tint st;\n\tstruct passwd *pw;\n\t\n\tpw = getpwuid(uid);\n\tif (pw) {\n\t\tname = pw->pw_name;\n\t\thome = pw->pw_dir;\n\t} else {\n\t\treturn 0;\n\t}\n\n\t/* \n\t * We fork here and try to open the display again as the\n\t * new user.  Unreadable XAUTHORITY could be a problem...\n\t * This is not really needed since we have DISPLAY open but:\n\t * 1) is a good indicator this user owns the session and  2)\n\t * some activities do spawn new X apps, e.g.  xmessage(1), etc.\n\t */\n\tif ((pid = fork()) > 0) {\n\t\t;\n\t} else if (pid == -1) {\n\t\tfprintf(stderr, \"could not fork\\n\");\n\t\trfbLogPerror(\"fork\");\n\t\treturn 0;\n\t} else {\n\t\t/* child */\n\t\tDisplay *dpy2 = NULL;\n\t\tint rc;\n\n\t\tsignal(SIGHUP,  SIG_DFL);\n\t\tsignal(SIGINT,  SIG_DFL);\n\t\tsignal(SIGQUIT, SIG_DFL);\n\t\tsignal(SIGTERM, SIG_DFL);\n\n\t\trc = switch_user_env(uid, gid, name, home, 0); \n\t\tif (! rc) {\n\t\t\texit(1);\n\t\t}\n\n\t\tfclose(stderr);\n\t\tdpy2 = XOpenDisplay_wr(dpystr);\n\t\tif (dpy2) {\n\t\t\tXCloseDisplay_wr(dpy2);\n\t\t\texit(0);\t/* success */\n\t\t} else {\n\t\t\texit(2);\t/* fail */\n\t\t}\n\t}\n\n\t/* see what the child says: */\n\tpidw = waitpid(pid, &st, 0);\n\tif (pidw == pid && WIFEXITED(st) && WEXITSTATUS(st) == 0) {\n\t\treturn 1;\n\t}\n#endif\t/* LIBVNCSERVER_HAVE_FORK ... */\n\treturn 0;\n}",
    "includes": [
      "#include \"avahi.h\"",
      "#include \"sslhelper.h\"",
      "#include \"remote.h\"",
      "#include \"cursor.h\"",
      "#include \"keyboard.h\"",
      "#include \"inet.h\"",
      "#include \"connections.h\"",
      "#include \"xwrappers.h\"",
      "#include \"sslhelper.h\"",
      "#include \"unixpw.h\"",
      "#include \"screen.h\"",
      "#include \"scan.h\"",
      "#include \"cleanup.h\"",
      "#include \"solid.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void user2uid(char *user, uid_t *uid, gid_t *gid, char **name, char **home);",
      "static int try_user_and_display(uid_t uid, gid_t gid, char *dpystr);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "WEXITSTATUS",
          "args": [
            "st"
          ],
          "line": 708
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WIFEXITED",
          "args": [
            "st"
          ],
          "line": 708
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "waitpid",
          "args": [
            "pid",
            "&st",
            "0"
          ],
          "line": 707
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "2"
          ],
          "line": 702
        },
        "resolved": true,
        "details": {
          "function_name": "clean_up_exit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/cleanup.c",
          "lines": "151-266",
          "snippet": "void clean_up_exit(int ret) {\n\tstatic int depth = 0;\n\texit_flag = 1;\n\n\tif (depth++ > 2) {\n\t\texit(ret);\n\t}\n\n\tif (icon_mode) {\n\t\tclean_icon_mode();\n\t}\n\n\t/* remove the shm areas: */\n\tclean_shm(0);\n\n\tstop_stunnel();\n\tif (use_openssl) {\n\t\tssl_helper_pid(0, 0);\t/* killall */\n\t}\n\n\tif (ssh_pid > 0) {\n\t\tkill(ssh_pid, SIGTERM);\n\t\tssh_pid = 0;\n\t}\n\n#ifdef MACOSX\n\tif (client_connect_file) {\n\t\tif (strstr(client_connect_file, \"/tmp/x11vnc-macosx-remote\")\n\t\t    == client_connect_file) {\n\t\t\tunlink(client_connect_file);\n\t\t}\n\t}\n\tif (macosx_console) {\n\t\tmacosxCG_fini();\n\t}\n#endif\n\n\tif (pipeinput_fh != NULL) {\n\t\tpclose(pipeinput_fh);\n\t\tpipeinput_fh = NULL;\n\t}\n\n\tshutdown_uinput();\n\n\tif (unix_sock) {\n\t\tif (unix_sock_fd >= 0) {\n\t\t\trfbLog(\"deleting unix sock: %s\\n\", unix_sock);\n\t\t\tclose(unix_sock_fd);\n\t\t\tunix_sock_fd = -1;\n\t\t\tunlink(unix_sock);\n\t\t}\n\t}\n\n\tif (! dpy) {\t/* raw_rb hack */\n\t\tif (rm_flagfile) {\n\t\t\tunlink(rm_flagfile);\n\t\t\trm_flagfile = NULL;\n\t\t}\n\t\texit(ret);\n\t}\n\n\t/* X keyboard cleanups */\n\tdelete_added_keycodes(0);\n\n\t/* remove all created XInput2 devices */\n\tif(use_multipointer)\n\t    removeAllMDs(dpy);\n\n\tif (clear_mods == 1) {\n\t\tclear_modifiers(0);\n\t} else if (clear_mods == 2) {\n\t\tclear_keys();\n\t} else if (clear_mods == 3) {\n\t\tclear_keys();\n\t\tclear_locks();\n\t}\n\n\tif (no_autorepeat) {\n\t\tautorepeat(1, 0);\n\t}\n\tif (use_solid_bg) {\n\t\tsolid_bg(1);\n\t}\n\tif (ncache || ncache0) {\n\t\tkde_no_animate(1);\n\t}\n\tX_LOCK;\n\tXTestDiscard_wr(dpy);\n#if HAVE_LIBXDAMAGE\n\tif (xdamage) {\n\t\tXDamageDestroy(dpy, xdamage);\n\t}\n#endif\n#if HAVE_LIBXTRAP\n\tif (trap_ctx) {\n\t\tXEFreeTC(trap_ctx);\n\t}\n#endif\n\t/* XXX rdpy_ctrl, etc. cannot close w/o blocking */\n\tXCloseDisplay_wr(dpy);\n\tX_UNLOCK;\n\n\tfflush(stderr);\n\n\tif (rm_flagfile) {\n\t\tunlink(rm_flagfile);\n\t\trm_flagfile = NULL;\n\t}\n\n\tif (avahi) {\n\t\tavahi_cleanup();\n\t\tfflush(stderr);\n\t}\n\n\texit(ret);\n}",
          "includes": [
            "#include \"xi2_devices.h\"",
            "#include \"uinput.h\"",
            "#include \"xevents.h\"",
            "#include \"xrecord.h\"",
            "#include \"screen.h\"",
            "#include \"avahi.h\"",
            "#include \"macosxCG.h\"",
            "#include \"macosx.h\"",
            "#include \"connections.h\"",
            "#include \"sslhelper.h\"",
            "#include \"sslcmds.h\"",
            "#include \"unixpw.h\"",
            "#include \"solid.h\"",
            "#include \"gui.h\"",
            "#include \"scan.h\"",
            "#include \"keyboard.h\"",
            "#include \"remote.h\"",
            "#include \"xdamage.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void clean_up_exit(int ret);",
            "int known_sigpipe_mode(char *s);",
            "static int exit_flag = 0;",
            "static void clean_icon_mode(void);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xi2_devices.h\"\n#include \"uinput.h\"\n#include \"xevents.h\"\n#include \"xrecord.h\"\n#include \"screen.h\"\n#include \"avahi.h\"\n#include \"macosxCG.h\"\n#include \"macosx.h\"\n#include \"connections.h\"\n#include \"sslhelper.h\"\n#include \"sslcmds.h\"\n#include \"unixpw.h\"\n#include \"solid.h\"\n#include \"gui.h\"\n#include \"scan.h\"\n#include \"keyboard.h\"\n#include \"remote.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nvoid clean_up_exit(int ret);\nint known_sigpipe_mode(char *s);\nstatic int exit_flag = 0;\nstatic void clean_icon_mode(void);\n\nvoid clean_up_exit(int ret) {\n\tstatic int depth = 0;\n\texit_flag = 1;\n\n\tif (depth++ > 2) {\n\t\texit(ret);\n\t}\n\n\tif (icon_mode) {\n\t\tclean_icon_mode();\n\t}\n\n\t/* remove the shm areas: */\n\tclean_shm(0);\n\n\tstop_stunnel();\n\tif (use_openssl) {\n\t\tssl_helper_pid(0, 0);\t/* killall */\n\t}\n\n\tif (ssh_pid > 0) {\n\t\tkill(ssh_pid, SIGTERM);\n\t\tssh_pid = 0;\n\t}\n\n#ifdef MACOSX\n\tif (client_connect_file) {\n\t\tif (strstr(client_connect_file, \"/tmp/x11vnc-macosx-remote\")\n\t\t    == client_connect_file) {\n\t\t\tunlink(client_connect_file);\n\t\t}\n\t}\n\tif (macosx_console) {\n\t\tmacosxCG_fini();\n\t}\n#endif\n\n\tif (pipeinput_fh != NULL) {\n\t\tpclose(pipeinput_fh);\n\t\tpipeinput_fh = NULL;\n\t}\n\n\tshutdown_uinput();\n\n\tif (unix_sock) {\n\t\tif (unix_sock_fd >= 0) {\n\t\t\trfbLog(\"deleting unix sock: %s\\n\", unix_sock);\n\t\t\tclose(unix_sock_fd);\n\t\t\tunix_sock_fd = -1;\n\t\t\tunlink(unix_sock);\n\t\t}\n\t}\n\n\tif (! dpy) {\t/* raw_rb hack */\n\t\tif (rm_flagfile) {\n\t\t\tunlink(rm_flagfile);\n\t\t\trm_flagfile = NULL;\n\t\t}\n\t\texit(ret);\n\t}\n\n\t/* X keyboard cleanups */\n\tdelete_added_keycodes(0);\n\n\t/* remove all created XInput2 devices */\n\tif(use_multipointer)\n\t    removeAllMDs(dpy);\n\n\tif (clear_mods == 1) {\n\t\tclear_modifiers(0);\n\t} else if (clear_mods == 2) {\n\t\tclear_keys();\n\t} else if (clear_mods == 3) {\n\t\tclear_keys();\n\t\tclear_locks();\n\t}\n\n\tif (no_autorepeat) {\n\t\tautorepeat(1, 0);\n\t}\n\tif (use_solid_bg) {\n\t\tsolid_bg(1);\n\t}\n\tif (ncache || ncache0) {\n\t\tkde_no_animate(1);\n\t}\n\tX_LOCK;\n\tXTestDiscard_wr(dpy);\n#if HAVE_LIBXDAMAGE\n\tif (xdamage) {\n\t\tXDamageDestroy(dpy, xdamage);\n\t}\n#endif\n#if HAVE_LIBXTRAP\n\tif (trap_ctx) {\n\t\tXEFreeTC(trap_ctx);\n\t}\n#endif\n\t/* XXX rdpy_ctrl, etc. cannot close w/o blocking */\n\tXCloseDisplay_wr(dpy);\n\tX_UNLOCK;\n\n\tfflush(stderr);\n\n\tif (rm_flagfile) {\n\t\tunlink(rm_flagfile);\n\t\trm_flagfile = NULL;\n\t}\n\n\tif (avahi) {\n\t\tavahi_cleanup();\n\t\tfflush(stderr);\n\t}\n\n\texit(ret);\n}"
        }
      },
      {
        "call_info": {
          "callee": "XCloseDisplay_wr",
          "args": [
            "dpy2"
          ],
          "line": 699
        },
        "resolved": true,
        "details": {
          "function_name": "XCloseDisplay_wr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/xwrappers.c",
          "lines": "1504-1512",
          "snippet": "int XCloseDisplay_wr(Display *display) {\n\tint db = 0;\n\tif (db) fprintf(stderr, \"XCloseDisplay_wr: %p\\n\", (void *)display);\n#if NO_X11\n\treturn 0;\n#else\n\treturn XCloseDisplay(display);\n#endif\t/* NO_X11 */\n}",
          "includes": [
            "#include \"nox11_funcs.h\"",
            "#include \"xwrappers.h\"",
            "#include \"xi2_devices.h\"",
            "#include \"macosx.h\"",
            "#include \"cleanup.h\"",
            "#include \"connections.h\"",
            "#include \"xevents.h\"",
            "#include \"keyboard.h\"",
            "#include \"xrecord.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int XCloseDisplay_wr(Display *display);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"nox11_funcs.h\"\n#include \"xwrappers.h\"\n#include \"xi2_devices.h\"\n#include \"macosx.h\"\n#include \"cleanup.h\"\n#include \"connections.h\"\n#include \"xevents.h\"\n#include \"keyboard.h\"\n#include \"xrecord.h\"\n#include \"x11vnc.h\"\n\nint XCloseDisplay_wr(Display *display);\n\nint XCloseDisplay_wr(Display *display) {\n\tint db = 0;\n\tif (db) fprintf(stderr, \"XCloseDisplay_wr: %p\\n\", (void *)display);\n#if NO_X11\n\treturn 0;\n#else\n\treturn XCloseDisplay(display);\n#endif\t/* NO_X11 */\n}"
        }
      },
      {
        "call_info": {
          "callee": "XOpenDisplay_wr",
          "args": [
            "dpystr"
          ],
          "line": 697
        },
        "resolved": true,
        "details": {
          "function_name": "XOpenDisplay_wr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/xwrappers.c",
          "lines": "1461-1502",
          "snippet": "Display *XOpenDisplay_wr(char *display_name) {\n\tDisplay *d = NULL;\n\tint db = 0;\n\n\tif (! xauth_raw(1)) {\n\t\treturn NULL;\n\t}\n#if NO_X11\n\trfbLog(\"This x11vnc was built without X11 support (-rawfb only).\\n\");\n\tif (!display_name || !d || !db) {}\n\treturn NULL;\n#else\n\n\td = XOpenDisplay(display_name);\n\tif (db) fprintf(stderr, \"XOpenDisplay_wr: %s  %p\\n\", display_name, (void *)d);\n\n\tif (d == NULL && !getenv(\"NO_XAUTHLOCALHOSTNAME\")) {\n\t\tchar *xalhn = getenv(\"XAUTHLOCALHOSTNAME\");\n\t\tif (1 || !xalhn) {\n\t\t\trfbLog(\"XOpenDisplay(\\\"%s\\\") failed.\\n\",\n\t\t\t    display_name ? display_name : \"\");\n\t\t\trfbLog(\"Trying again with XAUTHLOCALHOSTNAME=localhost ...\\n\");\n\t\t\tset_env(\"XAUTHLOCALHOSTNAME\", \"localhost\");\n\t\t\td = XOpenDisplay(display_name);\n\t\t\tif (d == NULL && xalhn) {\n\t\t\t\tchar *ptr = getenv(\"XAUTHLOCALHOSTNAME\");\n\t\t\t\tif (ptr) {\n\t\t\t\t\t*(ptr-2) = '_';\t/* yow */\n\t\t\t\t\trfbLog(\"XOpenDisplay(\\\"%s\\\") failed.\\n\",\n\t\t\t\t\t    display_name ? display_name : \"\");\n\t\t\t\t\trfbLog(\"Trying again with unset XAUTHLOCALHOSTNAME ...\\n\");\n\t\t\t\t\td = XOpenDisplay(display_name);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\txauth_raw(0);\n\n\treturn d;\n#endif\t/* NO_X11 */\n}",
          "includes": [
            "#include \"nox11_funcs.h\"",
            "#include \"xwrappers.h\"",
            "#include \"xi2_devices.h\"",
            "#include \"macosx.h\"",
            "#include \"cleanup.h\"",
            "#include \"connections.h\"",
            "#include \"xevents.h\"",
            "#include \"keyboard.h\"",
            "#include \"xrecord.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "Display *XOpenDisplay_wr(char *display_name);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"nox11_funcs.h\"\n#include \"xwrappers.h\"\n#include \"xi2_devices.h\"\n#include \"macosx.h\"\n#include \"cleanup.h\"\n#include \"connections.h\"\n#include \"xevents.h\"\n#include \"keyboard.h\"\n#include \"xrecord.h\"\n#include \"x11vnc.h\"\n\nDisplay *XOpenDisplay_wr(char *display_name);\n\nDisplay *XOpenDisplay_wr(char *display_name) {\n\tDisplay *d = NULL;\n\tint db = 0;\n\n\tif (! xauth_raw(1)) {\n\t\treturn NULL;\n\t}\n#if NO_X11\n\trfbLog(\"This x11vnc was built without X11 support (-rawfb only).\\n\");\n\tif (!display_name || !d || !db) {}\n\treturn NULL;\n#else\n\n\td = XOpenDisplay(display_name);\n\tif (db) fprintf(stderr, \"XOpenDisplay_wr: %s  %p\\n\", display_name, (void *)d);\n\n\tif (d == NULL && !getenv(\"NO_XAUTHLOCALHOSTNAME\")) {\n\t\tchar *xalhn = getenv(\"XAUTHLOCALHOSTNAME\");\n\t\tif (1 || !xalhn) {\n\t\t\trfbLog(\"XOpenDisplay(\\\"%s\\\") failed.\\n\",\n\t\t\t    display_name ? display_name : \"\");\n\t\t\trfbLog(\"Trying again with XAUTHLOCALHOSTNAME=localhost ...\\n\");\n\t\t\tset_env(\"XAUTHLOCALHOSTNAME\", \"localhost\");\n\t\t\td = XOpenDisplay(display_name);\n\t\t\tif (d == NULL && xalhn) {\n\t\t\t\tchar *ptr = getenv(\"XAUTHLOCALHOSTNAME\");\n\t\t\t\tif (ptr) {\n\t\t\t\t\t*(ptr-2) = '_';\t/* yow */\n\t\t\t\t\trfbLog(\"XOpenDisplay(\\\"%s\\\") failed.\\n\",\n\t\t\t\t\t    display_name ? display_name : \"\");\n\t\t\t\t\trfbLog(\"Trying again with unset XAUTHLOCALHOSTNAME ...\\n\");\n\t\t\t\t\td = XOpenDisplay(display_name);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\txauth_raw(0);\n\n\treturn d;\n#endif\t/* NO_X11 */\n}"
        }
      },
      {
        "call_info": {
          "callee": "fclose",
          "args": [
            "stderr"
          ],
          "line": 696
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "switch_user_env",
          "args": [
            "uid",
            "gid",
            "name",
            "home",
            "0"
          ],
          "line": 691
        },
        "resolved": true,
        "details": {
          "function_name": "switch_user_env",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/user.c",
          "lines": "759-825",
          "snippet": "static int switch_user_env(uid_t uid, gid_t gid, char *name, char *home, int fb_mode) {\n\t/* NO strtoks */\n\tchar *xauth;\n\tint reset_fb = 0;\n\tint grp_ok = 0;\n\n#if !HAVE_SETUID\n\treturn 0;\n#else\n\t/*\n\t * OK, tricky here, we need to free the shm... otherwise\n\t * we won't be able to delete it as the other user...\n\t */\n\tif (fb_mode == 1 && (using_shm && ! xform24to32)) {\n\t\treset_fb = 1;\n\t\tclean_shm(0);\n\t\tfree_tiles();\n\t}\n#if HAVE_INITGROUPS\n#if HAVE_PWD_H\n\tif (getpwuid(uid) != NULL && getenv(\"X11VNC_SINGLE_GROUP\") == NULL) {\n\t\tstruct passwd *p = getpwuid(uid);\n\t\t/* another possibility is p->pw_gid instead of gid */\n\t\tif (setgid(gid) == 0 && initgroups(p->pw_name, gid) == 0)  {\n\t\t\tgrp_ok = 1;\n\t\t} else {\n\t\t\trfbLogPerror(\"initgroups\");\n\t\t}\n\t\tendgrent();\n\t}\n#endif\n#endif\n\tif (! grp_ok) {\n\t\tif (setgid(gid) == 0) {\n\t\t\tgrp_ok = 1;\n\t\t}\n\t}\n\tif (! grp_ok) {\n\t\tif (reset_fb) {\n\t\t\t/* 2 means we did clean_shm and free_tiles */\n\t\t\tdo_new_fb(2);\n\t\t}\n\t\treturn 0;\n\t}\n\n\tif (setuid(uid) != 0) {\n\t\tif (reset_fb) {\n\t\t\t/* 2 means we did clean_shm and free_tiles */\n\t\t\tdo_new_fb(2);\n\t\t}\n\t\treturn 0;\n\t}\n#endif\n\tif (reset_fb) {\n\t\tdo_new_fb(2);\n\t}\n\n\txauth = getenv(\"XAUTHORITY\");\n\tif (xauth && access(xauth, R_OK) != 0) {\n\t\t*(xauth-2) = '_';\t/* yow */\n\t}\n\t\n\tset_env(\"USER\", name);\n\tset_env(\"LOGNAME\", name);\n\tset_env(\"HOME\", home);\n\treturn 1;\n}",
          "includes": [
            "#include \"avahi.h\"",
            "#include \"sslhelper.h\"",
            "#include \"remote.h\"",
            "#include \"cursor.h\"",
            "#include \"keyboard.h\"",
            "#include \"inet.h\"",
            "#include \"connections.h\"",
            "#include \"xwrappers.h\"",
            "#include \"sslhelper.h\"",
            "#include \"unixpw.h\"",
            "#include \"screen.h\"",
            "#include \"scan.h\"",
            "#include \"cleanup.h\"",
            "#include \"solid.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int switch_user(char *user, int fb_mode);",
            "static void user2uid(char *user, uid_t *uid, gid_t *gid, char **name, char **home);",
            "static int guess_user_and_switch(char *str, int fb_mode);",
            "static int switch_user_env(uid_t uid, gid_t gid, char *name, char *home, int fb_mode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"avahi.h\"\n#include \"sslhelper.h\"\n#include \"remote.h\"\n#include \"cursor.h\"\n#include \"keyboard.h\"\n#include \"inet.h\"\n#include \"connections.h\"\n#include \"xwrappers.h\"\n#include \"sslhelper.h\"\n#include \"unixpw.h\"\n#include \"screen.h\"\n#include \"scan.h\"\n#include \"cleanup.h\"\n#include \"solid.h\"\n#include \"x11vnc.h\"\n\nint switch_user(char *user, int fb_mode);\nstatic void user2uid(char *user, uid_t *uid, gid_t *gid, char **name, char **home);\nstatic int guess_user_and_switch(char *str, int fb_mode);\nstatic int switch_user_env(uid_t uid, gid_t gid, char *name, char *home, int fb_mode);\n\nstatic int switch_user_env(uid_t uid, gid_t gid, char *name, char *home, int fb_mode) {\n\t/* NO strtoks */\n\tchar *xauth;\n\tint reset_fb = 0;\n\tint grp_ok = 0;\n\n#if !HAVE_SETUID\n\treturn 0;\n#else\n\t/*\n\t * OK, tricky here, we need to free the shm... otherwise\n\t * we won't be able to delete it as the other user...\n\t */\n\tif (fb_mode == 1 && (using_shm && ! xform24to32)) {\n\t\treset_fb = 1;\n\t\tclean_shm(0);\n\t\tfree_tiles();\n\t}\n#if HAVE_INITGROUPS\n#if HAVE_PWD_H\n\tif (getpwuid(uid) != NULL && getenv(\"X11VNC_SINGLE_GROUP\") == NULL) {\n\t\tstruct passwd *p = getpwuid(uid);\n\t\t/* another possibility is p->pw_gid instead of gid */\n\t\tif (setgid(gid) == 0 && initgroups(p->pw_name, gid) == 0)  {\n\t\t\tgrp_ok = 1;\n\t\t} else {\n\t\t\trfbLogPerror(\"initgroups\");\n\t\t}\n\t\tendgrent();\n\t}\n#endif\n#endif\n\tif (! grp_ok) {\n\t\tif (setgid(gid) == 0) {\n\t\t\tgrp_ok = 1;\n\t\t}\n\t}\n\tif (! grp_ok) {\n\t\tif (reset_fb) {\n\t\t\t/* 2 means we did clean_shm and free_tiles */\n\t\t\tdo_new_fb(2);\n\t\t}\n\t\treturn 0;\n\t}\n\n\tif (setuid(uid) != 0) {\n\t\tif (reset_fb) {\n\t\t\t/* 2 means we did clean_shm and free_tiles */\n\t\t\tdo_new_fb(2);\n\t\t}\n\t\treturn 0;\n\t}\n#endif\n\tif (reset_fb) {\n\t\tdo_new_fb(2);\n\t}\n\n\txauth = getenv(\"XAUTHORITY\");\n\tif (xauth && access(xauth, R_OK) != 0) {\n\t\t*(xauth-2) = '_';\t/* yow */\n\t}\n\t\n\tset_env(\"USER\", name);\n\tset_env(\"LOGNAME\", name);\n\tset_env(\"HOME\", home);\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "signal",
          "args": [
            "SIGTERM",
            "SIG_DFL"
          ],
          "line": 689
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "signal",
          "args": [
            "SIGQUIT",
            "SIG_DFL"
          ],
          "line": 688
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "signal",
          "args": [
            "SIGINT",
            "SIG_DFL"
          ],
          "line": 687
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "signal",
          "args": [
            "SIGHUP",
            "SIG_DFL"
          ],
          "line": 686
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLogPerror",
          "args": [
            "\"fork\""
          ],
          "line": 679
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"could not fork\\n\""
          ],
          "line": 678
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fork",
          "args": [],
          "line": 675
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getpwuid",
          "args": [
            "uid"
          ],
          "line": 660
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"avahi.h\"\n#include \"sslhelper.h\"\n#include \"remote.h\"\n#include \"cursor.h\"\n#include \"keyboard.h\"\n#include \"inet.h\"\n#include \"connections.h\"\n#include \"xwrappers.h\"\n#include \"sslhelper.h\"\n#include \"unixpw.h\"\n#include \"screen.h\"\n#include \"scan.h\"\n#include \"cleanup.h\"\n#include \"solid.h\"\n#include \"x11vnc.h\"\n\nstatic void user2uid(char *user, uid_t *uid, gid_t *gid, char **name, char **home);\nstatic int try_user_and_display(uid_t uid, gid_t gid, char *dpystr);\n\nstatic int try_user_and_display(uid_t uid, gid_t gid, char *dpystr) {\n\t/* NO strtoks */\n#if LIBVNCSERVER_HAVE_FORK && LIBVNCSERVER_HAVE_SYS_WAIT_H && HAVE_PWD_H\n\tpid_t pid, pidw;\n\tchar *home, *name;\n\tint st;\n\tstruct passwd *pw;\n\t\n\tpw = getpwuid(uid);\n\tif (pw) {\n\t\tname = pw->pw_name;\n\t\thome = pw->pw_dir;\n\t} else {\n\t\treturn 0;\n\t}\n\n\t/* \n\t * We fork here and try to open the display again as the\n\t * new user.  Unreadable XAUTHORITY could be a problem...\n\t * This is not really needed since we have DISPLAY open but:\n\t * 1) is a good indicator this user owns the session and  2)\n\t * some activities do spawn new X apps, e.g.  xmessage(1), etc.\n\t */\n\tif ((pid = fork()) > 0) {\n\t\t;\n\t} else if (pid == -1) {\n\t\tfprintf(stderr, \"could not fork\\n\");\n\t\trfbLogPerror(\"fork\");\n\t\treturn 0;\n\t} else {\n\t\t/* child */\n\t\tDisplay *dpy2 = NULL;\n\t\tint rc;\n\n\t\tsignal(SIGHUP,  SIG_DFL);\n\t\tsignal(SIGINT,  SIG_DFL);\n\t\tsignal(SIGQUIT, SIG_DFL);\n\t\tsignal(SIGTERM, SIG_DFL);\n\n\t\trc = switch_user_env(uid, gid, name, home, 0); \n\t\tif (! rc) {\n\t\t\texit(1);\n\t\t}\n\n\t\tfclose(stderr);\n\t\tdpy2 = XOpenDisplay_wr(dpystr);\n\t\tif (dpy2) {\n\t\t\tXCloseDisplay_wr(dpy2);\n\t\t\texit(0);\t/* success */\n\t\t} else {\n\t\t\texit(2);\t/* fail */\n\t\t}\n\t}\n\n\t/* see what the child says: */\n\tpidw = waitpid(pid, &st, 0);\n\tif (pidw == pid && WIFEXITED(st) && WEXITSTATUS(st) == 0) {\n\t\treturn 1;\n\t}\n#endif\t/* LIBVNCSERVER_HAVE_FORK ... */\n\treturn 0;\n}"
  },
  {
    "function_name": "guess_user_and_switch",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/user.c",
    "lines": "556-650",
    "snippet": "static int guess_user_and_switch(char *str, int fb_mode) {\n\tchar *dstr, *d;\n\tchar *p, *tstr = NULL, *allowed = NULL, *logins, **users = NULL;\n\tint dpy1, ret = 0;\n\tchar **list;\n\tint lind;\n\n\tRAWFB_RET(0)\n\n\td = DisplayString(dpy);\n\t/* pick out \":N\" */\n\tdstr = strchr(d, ':');\n\tif (! dstr) {\n\t\treturn 0;\n\t}\n\tif (sscanf(dstr, \":%d\", &dpy1) != 1) {\n\t\treturn 0;\n\t}\n\tif (dpy1 < 0) {\n\t\treturn 0;\n\t}\n\n\tif (strstr(str, \"guess=\") == str && strlen(str) > strlen(\"guess=\")) {\n\t\tallowed = strchr(str, '=');\n\t\tallowed++;\n\n\t\ttstr = strdup(allowed);\n\t\tusers = user_list(tstr);\n\t}\n\n\t/* loop over the utmpx entries looking for this display */\n\tlogins = get_login_list(1);\n\n\tlist = (char **) calloc((strlen(logins)+2)*sizeof(char *), 1);\n\tlind = 0;\n\tp = strtok(logins, \",\");\n\twhile (p) {\n\t\tlist[lind++] = strdup(p);\n\t\tp = strtok(NULL, \",\");\n\t}\n\n\tlind = 0;\n\twhile (list[lind] != NULL) {\n\t\tchar *user, *q, *t;\n\t\tint dpy2, ok = 1;\n\n\t\tp = list[lind++];\n\n\t\tt = strdup(p);\n\t\tq = strchr(t, ':'); \n\t\tif (! q) {\n\t\t\tfree(t);\n\t\t\tbreak;\n\t\t}\n\t\t*q = '\\0';\n\t\tuser = t;\n\t\tdpy2 = atoi(q+1);\n\n\t\tif (users) {\n\t\t\tchar **u = users;\n\t\t\tok = 0;\n\t\t\twhile (*u != NULL) {\n\t\t\t\tif (!strcmp(user, *u++)) {\n\t\t\t\t\tok = 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (dpy1 != dpy2) {\n\t\t\tok = 0;\n\t\t}\n\n\t\tif (! ok) {\n\t\t\tfree(t);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (switch_user(user, fb_mode)) {\n\t\t\trfbLog(\"switched to guessed user: %s\\n\", user);\n\t\t\tfree(t);\n\t\t\tret = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (tstr) {\n\t\tfree(tstr);\n\t}\n\tif (users) {\n\t\tfree(users);\n\t}\n\tif (logins) {\n\t\tfree(logins);\n\t}\n\treturn ret;\n}",
    "includes": [
      "#include \"avahi.h\"",
      "#include \"sslhelper.h\"",
      "#include \"remote.h\"",
      "#include \"cursor.h\"",
      "#include \"keyboard.h\"",
      "#include \"inet.h\"",
      "#include \"connections.h\"",
      "#include \"xwrappers.h\"",
      "#include \"sslhelper.h\"",
      "#include \"unixpw.h\"",
      "#include \"screen.h\"",
      "#include \"scan.h\"",
      "#include \"cleanup.h\"",
      "#include \"solid.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "void lurk_loop(char *str);",
      "int switch_user(char *user, int fb_mode);",
      "static int lurk(char **users);",
      "static int guess_user_and_switch(char *str, int fb_mode);",
      "static int switch_user_env(uid_t uid, gid_t gid, char *name, char *home, int fb_mode);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "logins"
          ],
          "line": 647
        },
        "resolved": true,
        "details": {
          "function_name": "free_rect",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/userinput.c",
          "lines": "6200-6247",
          "snippet": "int free_rect(int idx) {\n\tint n, ok = 0;\n\tsraRegionPtr r1, r2;\n\tint x, y, w, h;\n\n\tif (idx < 0 || idx >= cache_list_num) {\nif (0) fprintf(stderr, \"free_rect: bad index: %d\\n\", idx);\n\t\tclean_up_exit(1);\n\t}\n\n\tx = cache_list[idx].bs_x;\n\ty = cache_list[idx].bs_y;\n\tw = cache_list[idx].bs_w;\n\th = cache_list[idx].bs_h;\n\n\tif (x < 0) {\n\t\tCLEAR(idx);\nif (dnow() > last_client + 5 && ncdb) fprintf(stderr, \"free_rect: already bs_x invalidated: %d bs_x: %d\\n\", idx, x);\n\t\treturn 1;\n\t}\n\n\tr2 = sraRgnCreateRect(x, y, x+w, y+h);\n\n\tn = get_bs_n(y);\n\tif (n >= 0) {\n\t\tr1 = rect_reg[n];\n\t\tsraRgnOr(r1, r2);\n\t\tok = 1;\n\t}\n\n\tif (zero_rects) {\n\t\tsraRgnOr(zero_rects, r2);\n\t\tx = cache_list[idx].su_x;\n\t\ty = cache_list[idx].su_y;\n\t\tw = cache_list[idx].su_w;\n\t\th = cache_list[idx].su_h;\n\t\tif (x >= 0) {\n\t\t\tsraRgnDestroy(r2);\n\t\t\tr2 = sraRgnCreateRect(x, y, x+w, y+h);\n\t\t\tsraRgnOr(zero_rects, r2);\n\t\t}\n\t}\n\tsraRgnDestroy(r2);\n\n\tCLEAR(idx);\nif (! ok && ncdb) fprintf(stderr, \"**** free_rect: not-found %d\\n\", idx);\n\treturn ok;\n}",
          "includes": [
            "#include \"default8x16.h\"",
            "#include \"connections.h\"",
            "#include \"screen.h\"",
            "#include \"cursor.h\"",
            "#include \"macosxCGS.h\"",
            "#include \"macosx.h\"",
            "#include \"unixpw.h\"",
            "#include \"8to24.h\"",
            "#include \"xrandr.h\"",
            "#include \"solid.h\"",
            "#include \"keyboard.h\"",
            "#include \"rates.h\"",
            "#include \"pointer.h\"",
            "#include \"cleanup.h\"",
            "#include \"scan.h\"",
            "#include \"user.h\"",
            "#include \"xevents.h\"",
            "#include \"win_utils.h\"",
            "#include \"xinerama.h\"",
            "#include \"xrecord.h\"",
            "#include \"xdamage.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void mark_for_xdamage(int x, int y, int w, int h);",
            "void set_xdamage_mark(int x, int y, int w, int h);",
            "int find_rect(int idx, int x, int y, int w, int h);",
            "winattr_t *cache_list;",
            "int clipped(int idx);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"default8x16.h\"\n#include \"connections.h\"\n#include \"screen.h\"\n#include \"cursor.h\"\n#include \"macosxCGS.h\"\n#include \"macosx.h\"\n#include \"unixpw.h\"\n#include \"8to24.h\"\n#include \"xrandr.h\"\n#include \"solid.h\"\n#include \"keyboard.h\"\n#include \"rates.h\"\n#include \"pointer.h\"\n#include \"cleanup.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"xevents.h\"\n#include \"win_utils.h\"\n#include \"xinerama.h\"\n#include \"xrecord.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nvoid mark_for_xdamage(int x, int y, int w, int h);\nvoid set_xdamage_mark(int x, int y, int w, int h);\nint find_rect(int idx, int x, int y, int w, int h);\nwinattr_t *cache_list;\nint clipped(int idx);\n\nint free_rect(int idx) {\n\tint n, ok = 0;\n\tsraRegionPtr r1, r2;\n\tint x, y, w, h;\n\n\tif (idx < 0 || idx >= cache_list_num) {\nif (0) fprintf(stderr, \"free_rect: bad index: %d\\n\", idx);\n\t\tclean_up_exit(1);\n\t}\n\n\tx = cache_list[idx].bs_x;\n\ty = cache_list[idx].bs_y;\n\tw = cache_list[idx].bs_w;\n\th = cache_list[idx].bs_h;\n\n\tif (x < 0) {\n\t\tCLEAR(idx);\nif (dnow() > last_client + 5 && ncdb) fprintf(stderr, \"free_rect: already bs_x invalidated: %d bs_x: %d\\n\", idx, x);\n\t\treturn 1;\n\t}\n\n\tr2 = sraRgnCreateRect(x, y, x+w, y+h);\n\n\tn = get_bs_n(y);\n\tif (n >= 0) {\n\t\tr1 = rect_reg[n];\n\t\tsraRgnOr(r1, r2);\n\t\tok = 1;\n\t}\n\n\tif (zero_rects) {\n\t\tsraRgnOr(zero_rects, r2);\n\t\tx = cache_list[idx].su_x;\n\t\ty = cache_list[idx].su_y;\n\t\tw = cache_list[idx].su_w;\n\t\th = cache_list[idx].su_h;\n\t\tif (x >= 0) {\n\t\t\tsraRgnDestroy(r2);\n\t\t\tr2 = sraRgnCreateRect(x, y, x+w, y+h);\n\t\t\tsraRgnOr(zero_rects, r2);\n\t\t}\n\t}\n\tsraRgnDestroy(r2);\n\n\tCLEAR(idx);\nif (! ok && ncdb) fprintf(stderr, \"**** free_rect: not-found %d\\n\", idx);\n\treturn ok;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"switched to guessed user: %s\\n\"",
            "user"
          ],
          "line": 634
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "switch_user",
          "args": [
            "user",
            "fb_mode"
          ],
          "line": 633
        },
        "resolved": true,
        "details": {
          "function_name": "switch_user",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/user.c",
          "lines": "715-757",
          "snippet": "int switch_user(char *user, int fb_mode) {\n\t/* NO strtoks */\n\tint doit = 0;\n\tuid_t uid = 0;\n\tgid_t gid = 0;\n\tchar *name, *home;\n\n\tif (*user == '+') {\n\t\tdoit = 1;\n\t\tuser++;\n\t}\n\n\tssl_helper_pid(0, -2);\t/* waitall */\n\n\tif (strstr(user, \"guess=\") == user) {\n\t\treturn guess_user_and_switch(user, fb_mode);\n\t}\n\n\tuser2uid(user, &uid, &gid, &name, &home);\n\n\tif (uid == (uid_t) -1 || uid == 0) {\n\t\treturn 0;\n\t}\n\tif (gid == 0) {\n\t\treturn 0;\n\t}\n\n\tif (! doit && dpy) {\n\t\t/* see if this display works: */\n\t\tchar *dstr = DisplayString(dpy);\n\t\tdoit = try_user_and_display(uid, gid, dstr);\n\t}\n\n\tif (doit) {\n\t\tint rc = switch_user_env(uid, gid, name, home, fb_mode);\n\t\tif (rc) {\n\t\t\tstarted_as_root = 2;\n\t\t}\n\t\treturn rc;\n\t} else {\n\t\treturn 0;\n\t}\n}",
          "includes": [
            "#include \"avahi.h\"",
            "#include \"sslhelper.h\"",
            "#include \"remote.h\"",
            "#include \"cursor.h\"",
            "#include \"keyboard.h\"",
            "#include \"inet.h\"",
            "#include \"connections.h\"",
            "#include \"xwrappers.h\"",
            "#include \"sslhelper.h\"",
            "#include \"unixpw.h\"",
            "#include \"screen.h\"",
            "#include \"scan.h\"",
            "#include \"cleanup.h\"",
            "#include \"solid.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int switch_user(char *user, int fb_mode);",
            "static void user2uid(char *user, uid_t *uid, gid_t *gid, char **name, char **home);",
            "static int guess_user_and_switch(char *str, int fb_mode);",
            "static int switch_user_env(uid_t uid, gid_t gid, char *name, char *home, int fb_mode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"avahi.h\"\n#include \"sslhelper.h\"\n#include \"remote.h\"\n#include \"cursor.h\"\n#include \"keyboard.h\"\n#include \"inet.h\"\n#include \"connections.h\"\n#include \"xwrappers.h\"\n#include \"sslhelper.h\"\n#include \"unixpw.h\"\n#include \"screen.h\"\n#include \"scan.h\"\n#include \"cleanup.h\"\n#include \"solid.h\"\n#include \"x11vnc.h\"\n\nint switch_user(char *user, int fb_mode);\nstatic void user2uid(char *user, uid_t *uid, gid_t *gid, char **name, char **home);\nstatic int guess_user_and_switch(char *str, int fb_mode);\nstatic int switch_user_env(uid_t uid, gid_t gid, char *name, char *home, int fb_mode);\n\nint switch_user(char *user, int fb_mode) {\n\t/* NO strtoks */\n\tint doit = 0;\n\tuid_t uid = 0;\n\tgid_t gid = 0;\n\tchar *name, *home;\n\n\tif (*user == '+') {\n\t\tdoit = 1;\n\t\tuser++;\n\t}\n\n\tssl_helper_pid(0, -2);\t/* waitall */\n\n\tif (strstr(user, \"guess=\") == user) {\n\t\treturn guess_user_and_switch(user, fb_mode);\n\t}\n\n\tuser2uid(user, &uid, &gid, &name, &home);\n\n\tif (uid == (uid_t) -1 || uid == 0) {\n\t\treturn 0;\n\t}\n\tif (gid == 0) {\n\t\treturn 0;\n\t}\n\n\tif (! doit && dpy) {\n\t\t/* see if this display works: */\n\t\tchar *dstr = DisplayString(dpy);\n\t\tdoit = try_user_and_display(uid, gid, dstr);\n\t}\n\n\tif (doit) {\n\t\tint rc = switch_user_env(uid, gid, name, home, fb_mode);\n\t\tif (rc) {\n\t\t\tstarted_as_root = 2;\n\t\t}\n\t\treturn rc;\n\t} else {\n\t\treturn 0;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "user",
            "*u++"
          ],
          "line": 618
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atoi",
          "args": [
            "q+1"
          ],
          "line": 612
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "t",
            "':'"
          ],
          "line": 605
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "p"
          ],
          "line": 604
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strtok",
          "args": [
            "NULL",
            "\",\""
          ],
          "line": 594
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "p"
          ],
          "line": 593
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strtok",
          "args": [
            "logins",
            "\",\""
          ],
          "line": 591
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "calloc",
          "args": [
            "(strlen(logins)+2)*sizeof(char *)",
            "1"
          ],
          "line": 589
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "logins"
          ],
          "line": 589
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_login_list",
          "args": [
            "1"
          ],
          "line": 587
        },
        "resolved": true,
        "details": {
          "function_name": "get_login_list",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/user.c",
          "lines": "141-249",
          "snippet": "static char *get_login_list(int with_display) {\n\tchar *out;\n#if HAVE_UTMPX_H\n\tint i, cnt, max = 200, ut_namesize = 32;\n#define DPYMAX 1000\n\tint sawdpy[DPYMAX];\n\tstruct utmpx *utx;\n\n\t/* size based on \"username:999,\" * max */\n\tout = (char *) malloc(max * (ut_namesize+1+3+1) + 1);\n\tout[0] = '\\0';\n\n\tfor (i=0; i < DPYMAX; i++) {\n\t\tsawdpy[i] = 0;\n\t}\n\n\tsetutxent();\n\tcnt = 0;\n\twhile (1) {\n\t\tchar *user, *line, *host, *id;\n\t\tchar tmp[10];\n\t\tint d = -1;\n\t\tutx = getutxent();\n\t\tif (! utx) {\n\t\t\tbreak;\n\t\t}\n\t\tif (utx->ut_type != USER_PROCESS) {\n\t\t\tcontinue;\n\t\t}\n\t\tuser = lblanks(utx->ut_user);\n\t\tif (*user == '\\0') {\n\t\t\tcontinue;\n\t\t}\n\t\tif (strchr(user, ',')) {\n\t\t\tcontinue;\t/* unlikely, but comma is our sep. */\n\t\t}\n\n\t\tline = lblanks(utx->ut_line);\n\t\thost = lblanks(utx->ut_host);\n\t\tid   = lblanks(utx->ut_id);\n\n\t\tif (with_display) {\n\t\t\tif (0 && line[0] != ':' && strcmp(line, \"dtlocal\")) {\n\t\t\t\t/* XXX useful? */\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (line[0] == ':') {\n\t\t\t\tif (sscanf(line, \":%d\", &d) != 1)  {\n\t\t\t\t\td = -1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (d < 0 && host[0] == ':') {\n\t\t\t\tif (sscanf(host, \":%d\", &d) != 1)  {\n\t\t\t\t\td = -1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (d < 0 && id[0] == ':') {\n\t\t\t\tif (sscanf(id, \":%d\", &d) != 1)  {\n\t\t\t\t\td = -1;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (d < 0 || d >= DPYMAX || sawdpy[d]) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tsawdpy[d] = 1;\n\t\t\tsprintf(tmp, \":%d\", d);\n\t\t} else {\n\t\t\t/* try to eliminate repeats */\n\t\t\tint repeat = 0;\n\t\t\tchar *q;\n\n\t\t\tq = out;\n\t\t\twhile ((q = strstr(q, user)) != NULL) {\n\t\t\t\tchar *p = q + strlen(user) + strlen(\":DPY\");\n\t\t\t\tif (q == out || *(q-1) == ',') {\n\t\t\t\t\t/* bounded on left. */\n\t\t\t\t\tif (*p == ',' || *p == '\\0') {\n\t\t\t\t\t\t/* bounded on right. */\n\t\t\t\t\t\trepeat = 1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tq = p;\n\t\t\t}\n\t\t\tif (repeat) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tsprintf(tmp, \":DPY\");\n\t\t}\n\n\t\tif (*out) {\n\t\t\tstrcat(out, \",\");\n\t\t}\n\t\tstrcat(out, user);\n\t\tstrcat(out, tmp);\n\n\t\tcnt++;\n\t\tif (cnt >= max) {\n\t\t\tbreak;\n\t\t}\n\t}\n\tendutxent();\n#else\n\tout = strdup(\"\");\n#endif\n\treturn out;\n}",
          "includes": [
            "#include \"avahi.h\"",
            "#include \"sslhelper.h\"",
            "#include \"remote.h\"",
            "#include \"cursor.h\"",
            "#include \"keyboard.h\"",
            "#include \"inet.h\"",
            "#include \"connections.h\"",
            "#include \"xwrappers.h\"",
            "#include \"sslhelper.h\"",
            "#include \"unixpw.h\"",
            "#include \"screen.h\"",
            "#include \"scan.h\"",
            "#include \"cleanup.h\"",
            "#include \"solid.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [
            "#define DPYMAX 1000"
          ],
          "globals_used": [
            "static char *get_login_list(int with_display);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"avahi.h\"\n#include \"sslhelper.h\"\n#include \"remote.h\"\n#include \"cursor.h\"\n#include \"keyboard.h\"\n#include \"inet.h\"\n#include \"connections.h\"\n#include \"xwrappers.h\"\n#include \"sslhelper.h\"\n#include \"unixpw.h\"\n#include \"screen.h\"\n#include \"scan.h\"\n#include \"cleanup.h\"\n#include \"solid.h\"\n#include \"x11vnc.h\"\n\n#define DPYMAX 1000\n\nstatic char *get_login_list(int with_display);\n\nstatic char *get_login_list(int with_display) {\n\tchar *out;\n#if HAVE_UTMPX_H\n\tint i, cnt, max = 200, ut_namesize = 32;\n#define DPYMAX 1000\n\tint sawdpy[DPYMAX];\n\tstruct utmpx *utx;\n\n\t/* size based on \"username:999,\" * max */\n\tout = (char *) malloc(max * (ut_namesize+1+3+1) + 1);\n\tout[0] = '\\0';\n\n\tfor (i=0; i < DPYMAX; i++) {\n\t\tsawdpy[i] = 0;\n\t}\n\n\tsetutxent();\n\tcnt = 0;\n\twhile (1) {\n\t\tchar *user, *line, *host, *id;\n\t\tchar tmp[10];\n\t\tint d = -1;\n\t\tutx = getutxent();\n\t\tif (! utx) {\n\t\t\tbreak;\n\t\t}\n\t\tif (utx->ut_type != USER_PROCESS) {\n\t\t\tcontinue;\n\t\t}\n\t\tuser = lblanks(utx->ut_user);\n\t\tif (*user == '\\0') {\n\t\t\tcontinue;\n\t\t}\n\t\tif (strchr(user, ',')) {\n\t\t\tcontinue;\t/* unlikely, but comma is our sep. */\n\t\t}\n\n\t\tline = lblanks(utx->ut_line);\n\t\thost = lblanks(utx->ut_host);\n\t\tid   = lblanks(utx->ut_id);\n\n\t\tif (with_display) {\n\t\t\tif (0 && line[0] != ':' && strcmp(line, \"dtlocal\")) {\n\t\t\t\t/* XXX useful? */\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (line[0] == ':') {\n\t\t\t\tif (sscanf(line, \":%d\", &d) != 1)  {\n\t\t\t\t\td = -1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (d < 0 && host[0] == ':') {\n\t\t\t\tif (sscanf(host, \":%d\", &d) != 1)  {\n\t\t\t\t\td = -1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (d < 0 && id[0] == ':') {\n\t\t\t\tif (sscanf(id, \":%d\", &d) != 1)  {\n\t\t\t\t\td = -1;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (d < 0 || d >= DPYMAX || sawdpy[d]) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tsawdpy[d] = 1;\n\t\t\tsprintf(tmp, \":%d\", d);\n\t\t} else {\n\t\t\t/* try to eliminate repeats */\n\t\t\tint repeat = 0;\n\t\t\tchar *q;\n\n\t\t\tq = out;\n\t\t\twhile ((q = strstr(q, user)) != NULL) {\n\t\t\t\tchar *p = q + strlen(user) + strlen(\":DPY\");\n\t\t\t\tif (q == out || *(q-1) == ',') {\n\t\t\t\t\t/* bounded on left. */\n\t\t\t\t\tif (*p == ',' || *p == '\\0') {\n\t\t\t\t\t\t/* bounded on right. */\n\t\t\t\t\t\trepeat = 1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tq = p;\n\t\t\t}\n\t\t\tif (repeat) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tsprintf(tmp, \":DPY\");\n\t\t}\n\n\t\tif (*out) {\n\t\t\tstrcat(out, \",\");\n\t\t}\n\t\tstrcat(out, user);\n\t\tstrcat(out, tmp);\n\n\t\tcnt++;\n\t\tif (cnt >= max) {\n\t\t\tbreak;\n\t\t}\n\t}\n\tendutxent();\n#else\n\tout = strdup(\"\");\n#endif\n\treturn out;\n}"
        }
      },
      {
        "call_info": {
          "callee": "user_list",
          "args": [
            "tstr"
          ],
          "line": 583
        },
        "resolved": true,
        "details": {
          "function_name": "user_list",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/user.c",
          "lines": "251-272",
          "snippet": "static char **user_list(char *user_str) {\n\tint n, i;\n\tchar *p, **list;\n\t\n\tp = user_str;\n\tn = 1;\n\twhile (*p++) {\n\t\tif (*p == ',') {\n\t\t\tn++;\n\t\t}\n\t}\n\tlist = (char **) calloc((n+1)*sizeof(char *), 1);\n\n\tp = strtok(user_str, \",\");\n\ti = 0;\n\twhile (p) {\n\t\tlist[i++] = strdup(p);\n\t\tp = strtok(NULL, \",\");\n\t}\n\tlist[i] = NULL;\n\treturn list;\n}",
          "includes": [
            "#include \"avahi.h\"",
            "#include \"sslhelper.h\"",
            "#include \"remote.h\"",
            "#include \"cursor.h\"",
            "#include \"keyboard.h\"",
            "#include \"inet.h\"",
            "#include \"connections.h\"",
            "#include \"xwrappers.h\"",
            "#include \"sslhelper.h\"",
            "#include \"unixpw.h\"",
            "#include \"screen.h\"",
            "#include \"scan.h\"",
            "#include \"cleanup.h\"",
            "#include \"solid.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static char **user_list(char *user_str);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"avahi.h\"\n#include \"sslhelper.h\"\n#include \"remote.h\"\n#include \"cursor.h\"\n#include \"keyboard.h\"\n#include \"inet.h\"\n#include \"connections.h\"\n#include \"xwrappers.h\"\n#include \"sslhelper.h\"\n#include \"unixpw.h\"\n#include \"screen.h\"\n#include \"scan.h\"\n#include \"cleanup.h\"\n#include \"solid.h\"\n#include \"x11vnc.h\"\n\nstatic char **user_list(char *user_str);\n\nstatic char **user_list(char *user_str) {\n\tint n, i;\n\tchar *p, **list;\n\t\n\tp = user_str;\n\tn = 1;\n\twhile (*p++) {\n\t\tif (*p == ',') {\n\t\t\tn++;\n\t\t}\n\t}\n\tlist = (char **) calloc((n+1)*sizeof(char *), 1);\n\n\tp = strtok(user_str, \",\");\n\ti = 0;\n\twhile (p) {\n\t\tlist[i++] = strdup(p);\n\t\tp = strtok(NULL, \",\");\n\t}\n\tlist[i] = NULL;\n\treturn list;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "allowed"
          ],
          "line": 582
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "str",
            "'='"
          ],
          "line": 579
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "\"guess=\""
          ],
          "line": 578
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "str"
          ],
          "line": 578
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "str",
            "\"guess=\""
          ],
          "line": 578
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sscanf",
          "args": [
            "dstr",
            "\":%d\"",
            "&dpy1"
          ],
          "line": 571
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "d",
            "':'"
          ],
          "line": 567
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DisplayString",
          "args": [
            "dpy"
          ],
          "line": 565
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RAWFB_RET",
          "args": [
            "0"
          ],
          "line": 563
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"avahi.h\"\n#include \"sslhelper.h\"\n#include \"remote.h\"\n#include \"cursor.h\"\n#include \"keyboard.h\"\n#include \"inet.h\"\n#include \"connections.h\"\n#include \"xwrappers.h\"\n#include \"sslhelper.h\"\n#include \"unixpw.h\"\n#include \"screen.h\"\n#include \"scan.h\"\n#include \"cleanup.h\"\n#include \"solid.h\"\n#include \"x11vnc.h\"\n\nvoid lurk_loop(char *str);\nint switch_user(char *user, int fb_mode);\nstatic int lurk(char **users);\nstatic int guess_user_and_switch(char *str, int fb_mode);\nstatic int switch_user_env(uid_t uid, gid_t gid, char *name, char *home, int fb_mode);\n\nstatic int guess_user_and_switch(char *str, int fb_mode) {\n\tchar *dstr, *d;\n\tchar *p, *tstr = NULL, *allowed = NULL, *logins, **users = NULL;\n\tint dpy1, ret = 0;\n\tchar **list;\n\tint lind;\n\n\tRAWFB_RET(0)\n\n\td = DisplayString(dpy);\n\t/* pick out \":N\" */\n\tdstr = strchr(d, ':');\n\tif (! dstr) {\n\t\treturn 0;\n\t}\n\tif (sscanf(dstr, \":%d\", &dpy1) != 1) {\n\t\treturn 0;\n\t}\n\tif (dpy1 < 0) {\n\t\treturn 0;\n\t}\n\n\tif (strstr(str, \"guess=\") == str && strlen(str) > strlen(\"guess=\")) {\n\t\tallowed = strchr(str, '=');\n\t\tallowed++;\n\n\t\ttstr = strdup(allowed);\n\t\tusers = user_list(tstr);\n\t}\n\n\t/* loop over the utmpx entries looking for this display */\n\tlogins = get_login_list(1);\n\n\tlist = (char **) calloc((strlen(logins)+2)*sizeof(char *), 1);\n\tlind = 0;\n\tp = strtok(logins, \",\");\n\twhile (p) {\n\t\tlist[lind++] = strdup(p);\n\t\tp = strtok(NULL, \",\");\n\t}\n\n\tlind = 0;\n\twhile (list[lind] != NULL) {\n\t\tchar *user, *q, *t;\n\t\tint dpy2, ok = 1;\n\n\t\tp = list[lind++];\n\n\t\tt = strdup(p);\n\t\tq = strchr(t, ':'); \n\t\tif (! q) {\n\t\t\tfree(t);\n\t\t\tbreak;\n\t\t}\n\t\t*q = '\\0';\n\t\tuser = t;\n\t\tdpy2 = atoi(q+1);\n\n\t\tif (users) {\n\t\t\tchar **u = users;\n\t\t\tok = 0;\n\t\t\twhile (*u != NULL) {\n\t\t\t\tif (!strcmp(user, *u++)) {\n\t\t\t\t\tok = 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (dpy1 != dpy2) {\n\t\t\tok = 0;\n\t\t}\n\n\t\tif (! ok) {\n\t\t\tfree(t);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (switch_user(user, fb_mode)) {\n\t\t\trfbLog(\"switched to guessed user: %s\\n\", user);\n\t\t\tfree(t);\n\t\t\tret = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (tstr) {\n\t\tfree(tstr);\n\t}\n\tif (users) {\n\t\tfree(users);\n\t}\n\tif (logins) {\n\t\tfree(logins);\n\t}\n\treturn ret;\n}"
  },
  {
    "function_name": "lurk_loop",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/user.c",
    "lines": "529-554",
    "snippet": "void lurk_loop(char *str) {\n\tchar *tstr = NULL, **users = NULL;\n\n\tif (strstr(str, \"lurk=\") != str) {\n\t\texit(1);\n\t}\n\trfbLog(\"lurking for logins using: '%s'\\n\", str);\n\tif (strlen(str) > strlen(\"lurk=\")) {\n\t\tchar *q = strchr(str, '=');\n\t\ttstr = strdup(q+1);\n\t\tusers = user_list(tstr);\n\t}\n\n\twhile (1) {\n\t\tif (lurk(users)) {\n\t\t\tbreak;\n\t\t}\n\t\tsleep(3);\n\t}\n\tif (tstr) {\n\t\tfree(tstr);\n\t}\n\tif (users) {\n\t\tfree(users);\n\t}\n}",
    "includes": [
      "#include \"avahi.h\"",
      "#include \"sslhelper.h\"",
      "#include \"remote.h\"",
      "#include \"cursor.h\"",
      "#include \"keyboard.h\"",
      "#include \"inet.h\"",
      "#include \"connections.h\"",
      "#include \"xwrappers.h\"",
      "#include \"sslhelper.h\"",
      "#include \"unixpw.h\"",
      "#include \"screen.h\"",
      "#include \"scan.h\"",
      "#include \"cleanup.h\"",
      "#include \"solid.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "void lurk_loop(char *str);",
      "static int lurk(char **users);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "users"
          ],
          "line": 552
        },
        "resolved": true,
        "details": {
          "function_name": "free_rect",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/userinput.c",
          "lines": "6200-6247",
          "snippet": "int free_rect(int idx) {\n\tint n, ok = 0;\n\tsraRegionPtr r1, r2;\n\tint x, y, w, h;\n\n\tif (idx < 0 || idx >= cache_list_num) {\nif (0) fprintf(stderr, \"free_rect: bad index: %d\\n\", idx);\n\t\tclean_up_exit(1);\n\t}\n\n\tx = cache_list[idx].bs_x;\n\ty = cache_list[idx].bs_y;\n\tw = cache_list[idx].bs_w;\n\th = cache_list[idx].bs_h;\n\n\tif (x < 0) {\n\t\tCLEAR(idx);\nif (dnow() > last_client + 5 && ncdb) fprintf(stderr, \"free_rect: already bs_x invalidated: %d bs_x: %d\\n\", idx, x);\n\t\treturn 1;\n\t}\n\n\tr2 = sraRgnCreateRect(x, y, x+w, y+h);\n\n\tn = get_bs_n(y);\n\tif (n >= 0) {\n\t\tr1 = rect_reg[n];\n\t\tsraRgnOr(r1, r2);\n\t\tok = 1;\n\t}\n\n\tif (zero_rects) {\n\t\tsraRgnOr(zero_rects, r2);\n\t\tx = cache_list[idx].su_x;\n\t\ty = cache_list[idx].su_y;\n\t\tw = cache_list[idx].su_w;\n\t\th = cache_list[idx].su_h;\n\t\tif (x >= 0) {\n\t\t\tsraRgnDestroy(r2);\n\t\t\tr2 = sraRgnCreateRect(x, y, x+w, y+h);\n\t\t\tsraRgnOr(zero_rects, r2);\n\t\t}\n\t}\n\tsraRgnDestroy(r2);\n\n\tCLEAR(idx);\nif (! ok && ncdb) fprintf(stderr, \"**** free_rect: not-found %d\\n\", idx);\n\treturn ok;\n}",
          "includes": [
            "#include \"default8x16.h\"",
            "#include \"connections.h\"",
            "#include \"screen.h\"",
            "#include \"cursor.h\"",
            "#include \"macosxCGS.h\"",
            "#include \"macosx.h\"",
            "#include \"unixpw.h\"",
            "#include \"8to24.h\"",
            "#include \"xrandr.h\"",
            "#include \"solid.h\"",
            "#include \"keyboard.h\"",
            "#include \"rates.h\"",
            "#include \"pointer.h\"",
            "#include \"cleanup.h\"",
            "#include \"scan.h\"",
            "#include \"user.h\"",
            "#include \"xevents.h\"",
            "#include \"win_utils.h\"",
            "#include \"xinerama.h\"",
            "#include \"xrecord.h\"",
            "#include \"xdamage.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void mark_for_xdamage(int x, int y, int w, int h);",
            "void set_xdamage_mark(int x, int y, int w, int h);",
            "int find_rect(int idx, int x, int y, int w, int h);",
            "winattr_t *cache_list;",
            "int clipped(int idx);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"default8x16.h\"\n#include \"connections.h\"\n#include \"screen.h\"\n#include \"cursor.h\"\n#include \"macosxCGS.h\"\n#include \"macosx.h\"\n#include \"unixpw.h\"\n#include \"8to24.h\"\n#include \"xrandr.h\"\n#include \"solid.h\"\n#include \"keyboard.h\"\n#include \"rates.h\"\n#include \"pointer.h\"\n#include \"cleanup.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"xevents.h\"\n#include \"win_utils.h\"\n#include \"xinerama.h\"\n#include \"xrecord.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nvoid mark_for_xdamage(int x, int y, int w, int h);\nvoid set_xdamage_mark(int x, int y, int w, int h);\nint find_rect(int idx, int x, int y, int w, int h);\nwinattr_t *cache_list;\nint clipped(int idx);\n\nint free_rect(int idx) {\n\tint n, ok = 0;\n\tsraRegionPtr r1, r2;\n\tint x, y, w, h;\n\n\tif (idx < 0 || idx >= cache_list_num) {\nif (0) fprintf(stderr, \"free_rect: bad index: %d\\n\", idx);\n\t\tclean_up_exit(1);\n\t}\n\n\tx = cache_list[idx].bs_x;\n\ty = cache_list[idx].bs_y;\n\tw = cache_list[idx].bs_w;\n\th = cache_list[idx].bs_h;\n\n\tif (x < 0) {\n\t\tCLEAR(idx);\nif (dnow() > last_client + 5 && ncdb) fprintf(stderr, \"free_rect: already bs_x invalidated: %d bs_x: %d\\n\", idx, x);\n\t\treturn 1;\n\t}\n\n\tr2 = sraRgnCreateRect(x, y, x+w, y+h);\n\n\tn = get_bs_n(y);\n\tif (n >= 0) {\n\t\tr1 = rect_reg[n];\n\t\tsraRgnOr(r1, r2);\n\t\tok = 1;\n\t}\n\n\tif (zero_rects) {\n\t\tsraRgnOr(zero_rects, r2);\n\t\tx = cache_list[idx].su_x;\n\t\ty = cache_list[idx].su_y;\n\t\tw = cache_list[idx].su_w;\n\t\th = cache_list[idx].su_h;\n\t\tif (x >= 0) {\n\t\t\tsraRgnDestroy(r2);\n\t\t\tr2 = sraRgnCreateRect(x, y, x+w, y+h);\n\t\t\tsraRgnOr(zero_rects, r2);\n\t\t}\n\t}\n\tsraRgnDestroy(r2);\n\n\tCLEAR(idx);\nif (! ok && ncdb) fprintf(stderr, \"**** free_rect: not-found %d\\n\", idx);\n\treturn ok;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sleep",
          "args": [
            "3"
          ],
          "line": 546
        },
        "resolved": true,
        "details": {
          "function_name": "do_sleepin",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/x11vnc.c",
          "lines": "1929-1959",
          "snippet": "static void do_sleepin(char *sleep) {\n\tint n1, n2, nt;\n\tdouble f1, f2, ft;\n\n\tif (strchr(sleep, '-')) {\n\t\tdouble s = atof(strchr(sleep, '-')+1); \n\t\tif (sscanf(sleep, \"%d-%d\", &n1, &n2) == 2) {\n\t\t\tif (n1 > n2) {\n\t\t\t\tnt = n1;\n\t\t\t\tn1 = n2;\n\t\t\t\tn2 = nt;\n\t\t\t}\n\t\t\ts = n1 + rfac() * (n2 - n1);\n\t\t} else if (sscanf(sleep, \"%lf-%lf\", &f1, &f2) == 2) {\n\t\t\tif (f1 > f2) {\n\t\t\t\tft = f1;\n\t\t\t\tf1 = f2;\n\t\t\t\tf2 = ft;\n\t\t\t}\n\t\t\ts = f1 + rfac() * (f2 - f1);\n\t\t}\n\t\tif (getenv(\"DEBUG_SLEEPIN\")) fprintf(stderr, \"sleepin: %f secs\\n\", s);\n\t\tusleep( (int) (1000*1000*s) );\n\t} else {\n\t\tn1 = atoi(sleep);\n\t\tif (getenv(\"DEBUG_SLEEPIN\")) fprintf(stderr, \"sleepin: %d secs\\n\", n1);\n\t\tif (n1 > 0) {\n\t\t\tusleep(1000*1000*n1);\n\t\t}\n\t}\n}",
          "includes": [
            "#include \"xi2_devices.h\"",
            "#include \"solid.h\"",
            "#include \"pm.h\"",
            "#include \"selection.h\"",
            "#include \"sslhelper.h\"",
            "#include \"sslcmds.h\"",
            "#include \"inet.h\"",
            "#include \"unixpw.h\"",
            "#include \"rates.h\"",
            "#include \"connections.h\"",
            "#include \"screen.h\"",
            "#include \"userinput.h\"",
            "#include \"cursor.h\"",
            "#include \"pointer.h\"",
            "#include \"keyboard.h\"",
            "#include \"cleanup.h\"",
            "#include \"user.h\"",
            "#include \"help.h\"",
            "#include \"gui.h\"",
            "#include \"scan.h\"",
            "#include \"remote.h\"",
            "#include \"win_utils.h\"",
            "#include \"xkb_bell.h\"",
            "#include \"xrandr.h\"",
            "#include \"xinerama.h\"",
            "#include \"xevents.h\"",
            "#include \"xrecord.h\"",
            "#include \"xdamage.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xi2_devices.h\"\n#include \"solid.h\"\n#include \"pm.h\"\n#include \"selection.h\"\n#include \"sslhelper.h\"\n#include \"sslcmds.h\"\n#include \"inet.h\"\n#include \"unixpw.h\"\n#include \"rates.h\"\n#include \"connections.h\"\n#include \"screen.h\"\n#include \"userinput.h\"\n#include \"cursor.h\"\n#include \"pointer.h\"\n#include \"keyboard.h\"\n#include \"cleanup.h\"\n#include \"user.h\"\n#include \"help.h\"\n#include \"gui.h\"\n#include \"scan.h\"\n#include \"remote.h\"\n#include \"win_utils.h\"\n#include \"xkb_bell.h\"\n#include \"xrandr.h\"\n#include \"xinerama.h\"\n#include \"xevents.h\"\n#include \"xrecord.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nstatic void do_sleepin(char *sleep) {\n\tint n1, n2, nt;\n\tdouble f1, f2, ft;\n\n\tif (strchr(sleep, '-')) {\n\t\tdouble s = atof(strchr(sleep, '-')+1); \n\t\tif (sscanf(sleep, \"%d-%d\", &n1, &n2) == 2) {\n\t\t\tif (n1 > n2) {\n\t\t\t\tnt = n1;\n\t\t\t\tn1 = n2;\n\t\t\t\tn2 = nt;\n\t\t\t}\n\t\t\ts = n1 + rfac() * (n2 - n1);\n\t\t} else if (sscanf(sleep, \"%lf-%lf\", &f1, &f2) == 2) {\n\t\t\tif (f1 > f2) {\n\t\t\t\tft = f1;\n\t\t\t\tf1 = f2;\n\t\t\t\tf2 = ft;\n\t\t\t}\n\t\t\ts = f1 + rfac() * (f2 - f1);\n\t\t}\n\t\tif (getenv(\"DEBUG_SLEEPIN\")) fprintf(stderr, \"sleepin: %f secs\\n\", s);\n\t\tusleep( (int) (1000*1000*s) );\n\t} else {\n\t\tn1 = atoi(sleep);\n\t\tif (getenv(\"DEBUG_SLEEPIN\")) fprintf(stderr, \"sleepin: %d secs\\n\", n1);\n\t\tif (n1 > 0) {\n\t\t\tusleep(1000*1000*n1);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "lurk",
          "args": [
            "users"
          ],
          "line": 543
        },
        "resolved": true,
        "details": {
          "function_name": "lurk_loop",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/user.c",
          "lines": "529-554",
          "snippet": "void lurk_loop(char *str) {\n\tchar *tstr = NULL, **users = NULL;\n\n\tif (strstr(str, \"lurk=\") != str) {\n\t\texit(1);\n\t}\n\trfbLog(\"lurking for logins using: '%s'\\n\", str);\n\tif (strlen(str) > strlen(\"lurk=\")) {\n\t\tchar *q = strchr(str, '=');\n\t\ttstr = strdup(q+1);\n\t\tusers = user_list(tstr);\n\t}\n\n\twhile (1) {\n\t\tif (lurk(users)) {\n\t\t\tbreak;\n\t\t}\n\t\tsleep(3);\n\t}\n\tif (tstr) {\n\t\tfree(tstr);\n\t}\n\tif (users) {\n\t\tfree(users);\n\t}\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "user_list",
          "args": [
            "tstr"
          ],
          "line": 539
        },
        "resolved": true,
        "details": {
          "function_name": "user_list",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/user.c",
          "lines": "251-272",
          "snippet": "static char **user_list(char *user_str) {\n\tint n, i;\n\tchar *p, **list;\n\t\n\tp = user_str;\n\tn = 1;\n\twhile (*p++) {\n\t\tif (*p == ',') {\n\t\t\tn++;\n\t\t}\n\t}\n\tlist = (char **) calloc((n+1)*sizeof(char *), 1);\n\n\tp = strtok(user_str, \",\");\n\ti = 0;\n\twhile (p) {\n\t\tlist[i++] = strdup(p);\n\t\tp = strtok(NULL, \",\");\n\t}\n\tlist[i] = NULL;\n\treturn list;\n}",
          "includes": [
            "#include \"avahi.h\"",
            "#include \"sslhelper.h\"",
            "#include \"remote.h\"",
            "#include \"cursor.h\"",
            "#include \"keyboard.h\"",
            "#include \"inet.h\"",
            "#include \"connections.h\"",
            "#include \"xwrappers.h\"",
            "#include \"sslhelper.h\"",
            "#include \"unixpw.h\"",
            "#include \"screen.h\"",
            "#include \"scan.h\"",
            "#include \"cleanup.h\"",
            "#include \"solid.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static char **user_list(char *user_str);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"avahi.h\"\n#include \"sslhelper.h\"\n#include \"remote.h\"\n#include \"cursor.h\"\n#include \"keyboard.h\"\n#include \"inet.h\"\n#include \"connections.h\"\n#include \"xwrappers.h\"\n#include \"sslhelper.h\"\n#include \"unixpw.h\"\n#include \"screen.h\"\n#include \"scan.h\"\n#include \"cleanup.h\"\n#include \"solid.h\"\n#include \"x11vnc.h\"\n\nstatic char **user_list(char *user_str);\n\nstatic char **user_list(char *user_str) {\n\tint n, i;\n\tchar *p, **list;\n\t\n\tp = user_str;\n\tn = 1;\n\twhile (*p++) {\n\t\tif (*p == ',') {\n\t\t\tn++;\n\t\t}\n\t}\n\tlist = (char **) calloc((n+1)*sizeof(char *), 1);\n\n\tp = strtok(user_str, \",\");\n\ti = 0;\n\twhile (p) {\n\t\tlist[i++] = strdup(p);\n\t\tp = strtok(NULL, \",\");\n\t}\n\tlist[i] = NULL;\n\treturn list;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "q+1"
          ],
          "line": 538
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "str",
            "'='"
          ],
          "line": 537
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "\"lurk=\""
          ],
          "line": 536
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "str"
          ],
          "line": 536
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"lurking for logins using: '%s'\\n\"",
            "str"
          ],
          "line": 535
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "1"
          ],
          "line": 533
        },
        "resolved": true,
        "details": {
          "function_name": "clean_up_exit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/cleanup.c",
          "lines": "151-266",
          "snippet": "void clean_up_exit(int ret) {\n\tstatic int depth = 0;\n\texit_flag = 1;\n\n\tif (depth++ > 2) {\n\t\texit(ret);\n\t}\n\n\tif (icon_mode) {\n\t\tclean_icon_mode();\n\t}\n\n\t/* remove the shm areas: */\n\tclean_shm(0);\n\n\tstop_stunnel();\n\tif (use_openssl) {\n\t\tssl_helper_pid(0, 0);\t/* killall */\n\t}\n\n\tif (ssh_pid > 0) {\n\t\tkill(ssh_pid, SIGTERM);\n\t\tssh_pid = 0;\n\t}\n\n#ifdef MACOSX\n\tif (client_connect_file) {\n\t\tif (strstr(client_connect_file, \"/tmp/x11vnc-macosx-remote\")\n\t\t    == client_connect_file) {\n\t\t\tunlink(client_connect_file);\n\t\t}\n\t}\n\tif (macosx_console) {\n\t\tmacosxCG_fini();\n\t}\n#endif\n\n\tif (pipeinput_fh != NULL) {\n\t\tpclose(pipeinput_fh);\n\t\tpipeinput_fh = NULL;\n\t}\n\n\tshutdown_uinput();\n\n\tif (unix_sock) {\n\t\tif (unix_sock_fd >= 0) {\n\t\t\trfbLog(\"deleting unix sock: %s\\n\", unix_sock);\n\t\t\tclose(unix_sock_fd);\n\t\t\tunix_sock_fd = -1;\n\t\t\tunlink(unix_sock);\n\t\t}\n\t}\n\n\tif (! dpy) {\t/* raw_rb hack */\n\t\tif (rm_flagfile) {\n\t\t\tunlink(rm_flagfile);\n\t\t\trm_flagfile = NULL;\n\t\t}\n\t\texit(ret);\n\t}\n\n\t/* X keyboard cleanups */\n\tdelete_added_keycodes(0);\n\n\t/* remove all created XInput2 devices */\n\tif(use_multipointer)\n\t    removeAllMDs(dpy);\n\n\tif (clear_mods == 1) {\n\t\tclear_modifiers(0);\n\t} else if (clear_mods == 2) {\n\t\tclear_keys();\n\t} else if (clear_mods == 3) {\n\t\tclear_keys();\n\t\tclear_locks();\n\t}\n\n\tif (no_autorepeat) {\n\t\tautorepeat(1, 0);\n\t}\n\tif (use_solid_bg) {\n\t\tsolid_bg(1);\n\t}\n\tif (ncache || ncache0) {\n\t\tkde_no_animate(1);\n\t}\n\tX_LOCK;\n\tXTestDiscard_wr(dpy);\n#if HAVE_LIBXDAMAGE\n\tif (xdamage) {\n\t\tXDamageDestroy(dpy, xdamage);\n\t}\n#endif\n#if HAVE_LIBXTRAP\n\tif (trap_ctx) {\n\t\tXEFreeTC(trap_ctx);\n\t}\n#endif\n\t/* XXX rdpy_ctrl, etc. cannot close w/o blocking */\n\tXCloseDisplay_wr(dpy);\n\tX_UNLOCK;\n\n\tfflush(stderr);\n\n\tif (rm_flagfile) {\n\t\tunlink(rm_flagfile);\n\t\trm_flagfile = NULL;\n\t}\n\n\tif (avahi) {\n\t\tavahi_cleanup();\n\t\tfflush(stderr);\n\t}\n\n\texit(ret);\n}",
          "includes": [
            "#include \"xi2_devices.h\"",
            "#include \"uinput.h\"",
            "#include \"xevents.h\"",
            "#include \"xrecord.h\"",
            "#include \"screen.h\"",
            "#include \"avahi.h\"",
            "#include \"macosxCG.h\"",
            "#include \"macosx.h\"",
            "#include \"connections.h\"",
            "#include \"sslhelper.h\"",
            "#include \"sslcmds.h\"",
            "#include \"unixpw.h\"",
            "#include \"solid.h\"",
            "#include \"gui.h\"",
            "#include \"scan.h\"",
            "#include \"keyboard.h\"",
            "#include \"remote.h\"",
            "#include \"xdamage.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void clean_up_exit(int ret);",
            "int known_sigpipe_mode(char *s);",
            "static int exit_flag = 0;",
            "static void clean_icon_mode(void);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xi2_devices.h\"\n#include \"uinput.h\"\n#include \"xevents.h\"\n#include \"xrecord.h\"\n#include \"screen.h\"\n#include \"avahi.h\"\n#include \"macosxCG.h\"\n#include \"macosx.h\"\n#include \"connections.h\"\n#include \"sslhelper.h\"\n#include \"sslcmds.h\"\n#include \"unixpw.h\"\n#include \"solid.h\"\n#include \"gui.h\"\n#include \"scan.h\"\n#include \"keyboard.h\"\n#include \"remote.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nvoid clean_up_exit(int ret);\nint known_sigpipe_mode(char *s);\nstatic int exit_flag = 0;\nstatic void clean_icon_mode(void);\n\nvoid clean_up_exit(int ret) {\n\tstatic int depth = 0;\n\texit_flag = 1;\n\n\tif (depth++ > 2) {\n\t\texit(ret);\n\t}\n\n\tif (icon_mode) {\n\t\tclean_icon_mode();\n\t}\n\n\t/* remove the shm areas: */\n\tclean_shm(0);\n\n\tstop_stunnel();\n\tif (use_openssl) {\n\t\tssl_helper_pid(0, 0);\t/* killall */\n\t}\n\n\tif (ssh_pid > 0) {\n\t\tkill(ssh_pid, SIGTERM);\n\t\tssh_pid = 0;\n\t}\n\n#ifdef MACOSX\n\tif (client_connect_file) {\n\t\tif (strstr(client_connect_file, \"/tmp/x11vnc-macosx-remote\")\n\t\t    == client_connect_file) {\n\t\t\tunlink(client_connect_file);\n\t\t}\n\t}\n\tif (macosx_console) {\n\t\tmacosxCG_fini();\n\t}\n#endif\n\n\tif (pipeinput_fh != NULL) {\n\t\tpclose(pipeinput_fh);\n\t\tpipeinput_fh = NULL;\n\t}\n\n\tshutdown_uinput();\n\n\tif (unix_sock) {\n\t\tif (unix_sock_fd >= 0) {\n\t\t\trfbLog(\"deleting unix sock: %s\\n\", unix_sock);\n\t\t\tclose(unix_sock_fd);\n\t\t\tunix_sock_fd = -1;\n\t\t\tunlink(unix_sock);\n\t\t}\n\t}\n\n\tif (! dpy) {\t/* raw_rb hack */\n\t\tif (rm_flagfile) {\n\t\t\tunlink(rm_flagfile);\n\t\t\trm_flagfile = NULL;\n\t\t}\n\t\texit(ret);\n\t}\n\n\t/* X keyboard cleanups */\n\tdelete_added_keycodes(0);\n\n\t/* remove all created XInput2 devices */\n\tif(use_multipointer)\n\t    removeAllMDs(dpy);\n\n\tif (clear_mods == 1) {\n\t\tclear_modifiers(0);\n\t} else if (clear_mods == 2) {\n\t\tclear_keys();\n\t} else if (clear_mods == 3) {\n\t\tclear_keys();\n\t\tclear_locks();\n\t}\n\n\tif (no_autorepeat) {\n\t\tautorepeat(1, 0);\n\t}\n\tif (use_solid_bg) {\n\t\tsolid_bg(1);\n\t}\n\tif (ncache || ncache0) {\n\t\tkde_no_animate(1);\n\t}\n\tX_LOCK;\n\tXTestDiscard_wr(dpy);\n#if HAVE_LIBXDAMAGE\n\tif (xdamage) {\n\t\tXDamageDestroy(dpy, xdamage);\n\t}\n#endif\n#if HAVE_LIBXTRAP\n\tif (trap_ctx) {\n\t\tXEFreeTC(trap_ctx);\n\t}\n#endif\n\t/* XXX rdpy_ctrl, etc. cannot close w/o blocking */\n\tXCloseDisplay_wr(dpy);\n\tX_UNLOCK;\n\n\tfflush(stderr);\n\n\tif (rm_flagfile) {\n\t\tunlink(rm_flagfile);\n\t\trm_flagfile = NULL;\n\t}\n\n\tif (avahi) {\n\t\tavahi_cleanup();\n\t\tfflush(stderr);\n\t}\n\n\texit(ret);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "str",
            "\"lurk=\""
          ],
          "line": 532
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"avahi.h\"\n#include \"sslhelper.h\"\n#include \"remote.h\"\n#include \"cursor.h\"\n#include \"keyboard.h\"\n#include \"inet.h\"\n#include \"connections.h\"\n#include \"xwrappers.h\"\n#include \"sslhelper.h\"\n#include \"unixpw.h\"\n#include \"screen.h\"\n#include \"scan.h\"\n#include \"cleanup.h\"\n#include \"solid.h\"\n#include \"x11vnc.h\"\n\nvoid lurk_loop(char *str);\nstatic int lurk(char **users);\n\nvoid lurk_loop(char *str) {\n\tchar *tstr = NULL, **users = NULL;\n\n\tif (strstr(str, \"lurk=\") != str) {\n\t\texit(1);\n\t}\n\trfbLog(\"lurking for logins using: '%s'\\n\", str);\n\tif (strlen(str) > strlen(\"lurk=\")) {\n\t\tchar *q = strchr(str, '=');\n\t\ttstr = strdup(q+1);\n\t\tusers = user_list(tstr);\n\t}\n\n\twhile (1) {\n\t\tif (lurk(users)) {\n\t\t\tbreak;\n\t\t}\n\t\tsleep(3);\n\t}\n\tif (tstr) {\n\t\tfree(tstr);\n\t}\n\tif (users) {\n\t\tfree(users);\n\t}\n}"
  },
  {
    "function_name": "lurk",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/user.c",
    "lines": "364-527",
    "snippet": "static int lurk(char **users) {\n\tuid_t uid;\n\tgid_t gid;\n\tint success = 0, dmin = -1, dmax = -1;\n\tchar *p, *logins, **u;\n\tchar **list;\n\tint lind;\n\n\tif ((u = users) != NULL && *u != NULL && *(*u) == ':') {\n\t\tint len;\n\t\tchar *tmp;\n\n\t\t/* extract min and max display numbers */\n\t\ttmp = *u;\n\t\tif (strchr(tmp, '-')) {\n\t\t\tif (sscanf(tmp, \":%d-%d\", &dmin, &dmax) != 2) {\n\t\t\t\tdmin = -1;\n\t\t\t\tdmax = -1;\n\t\t\t}\n\t\t}\n\t\tif (dmin < 0) {\n\t\t\tif (sscanf(tmp, \":%d\", &dmin) != 1) {\n\t\t\t\tdmin = -1;\n\t\t\t\tdmax = -1;\n\t\t\t} else {\n\t\t\t\tdmax = dmin;\n\t\t\t}\n\t\t}\n\t\tif ((dmin < 0 || dmax < 0) || dmin > dmax || dmax > 10000) {\n\t\t\tdmin = -1;\n\t\t\tdmax = -1;\n\t\t}\n\n\t\t/* get user logins regardless of having a display: */\n\t\tlogins = get_login_list(0);\n\n\t\t/*\n\t\t * now we append the list in users (might as well try\n\t\t * them) this will probably allow weird ways of starting\n\t\t * xservers to work.\n\t\t */\n\t\tlen = strlen(logins);\n\t\tu++;\n\t\twhile (*u != NULL) {\n\t\t\tlen += strlen(*u) + strlen(\":DPY,\");\n\t\t\tu++;\n\t\t}\n\t\ttmp = (char *) malloc(len+1);\n\t\tstrcpy(tmp, logins);\n\n\t\t/* now concatenate them: */\n\t\tu = users+1;\n\t\twhile (*u != NULL) {\n\t\t\tchar *q, chk[100];\n\t\t\tsnprintf(chk, sizeof chk, \"%s:DPY\", *u);\n\t\t\tq = strstr(tmp, chk);\n\t\t\tif (q) {\n\t\t\t\tchar *p = q + strlen(chk);\n\t\t\t\t\n\t\t\t\tif (q == tmp || *(q-1) == ',') {\n\t\t\t\t\t/* bounded on left. */\n\t\t\t\t\tif (*p == ',' || *p == '\\0') {\n\t\t\t\t\t\t/* bounded on right. */\n\t\t\t\t\t\tu++;\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tif (*tmp) {\n\t\t\t\tstrcat(tmp, \",\");\n\t\t\t}\n\t\t\tstrcat(tmp, *u);\n\t\t\tstrcat(tmp, \":DPY\");\n\t\t\tu++;\n\t\t}\n\t\tfree(logins);\n\t\tlogins = tmp;\n\t\t\n\t} else {\n\t\tlogins = get_login_list(1);\n\t}\n\n\tlist = (char **) calloc((strlen(logins)+2)*sizeof(char *), 1);\n\tlind = 0;\n\tp = strtok(logins, \",\");\n\twhile (p) {\n\t\tlist[lind++] = strdup(p);\n\t\tp = strtok(NULL, \",\");\n\t}\n\tfree(logins);\n\n\tlind = 0;\n\twhile (list[lind] != NULL) {\n\t\tchar *user, *name, *home, dpystr[10];\n\t\tchar *q, *t;\n\t\tint ok = 1, dn;\n\n\t\tp = list[lind++];\n\t\t\n\t\tt = strdup(p);\t/* bob:0 */\n\t\tq = strchr(t, ':'); \n\t\tif (! q) {\n\t\t\tfree(t);\n\t\t\tbreak;\n\t\t}\n\t\t*q = '\\0';\n\t\tuser = t;\n\t\tsnprintf(dpystr, sizeof dpystr, \":%s\", q+1);\n\n\t\tif (users) {\n\t\t\tu = users;\n\t\t\tok = 0;\n\t\t\twhile (*u != NULL) {\n\t\t\t\tif (*(*u) == ':') {\n\t\t\t\t\tu++;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (!strcmp(user, *u++)) {\n\t\t\t\t\tok = 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tuser2uid(user, &uid, &gid, &name, &home);\n\t\tfree(t);\n\n\t\tif (! uid || ! gid) {\n\t\t\tok = 0;\n\t\t}\n\n\t\tif (! ok) {\n\t\t\tcontinue;\n\t\t}\n\t\t\n\t\tfor (dn = dmin; dn <= dmax; dn++) {\n\t\t\tif (dn >= 0) {\n\t\t\t\tsprintf(dpystr, \":%d\", dn);\n\t\t\t}\n\t\t\tif (try_user_and_display(uid, gid, dpystr)) {\n\t\t\t\tif (switch_user_env(uid, gid, name, home, 0)) {\n\t\t\t\t\trfbLog(\"lurk: now user: %s @ %s\\n\",\n\t\t\t\t\t    name, dpystr);\n\t\t\t\t\tstarted_as_root = 2;\n\t\t\t\t\tsuccess = 1;\n\t\t\t\t}\n\t\t\t\tset_env(\"DISPLAY\", dpystr);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (success) {\n\t\t\t break;\n\t\t}\n\t}\n\n\tlind = 0;\n\twhile (list[lind] != NULL) {\n\t\tfree(list[lind]);\n\t\tlind++;\n\t}\n\n\treturn success;\n}",
    "includes": [
      "#include \"avahi.h\"",
      "#include \"sslhelper.h\"",
      "#include \"remote.h\"",
      "#include \"cursor.h\"",
      "#include \"keyboard.h\"",
      "#include \"inet.h\"",
      "#include \"connections.h\"",
      "#include \"xwrappers.h\"",
      "#include \"sslhelper.h\"",
      "#include \"unixpw.h\"",
      "#include \"screen.h\"",
      "#include \"scan.h\"",
      "#include \"cleanup.h\"",
      "#include \"solid.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "rfbBool custom_passwd_check(rfbClientPtr cl, const char *response, int len);",
      "static void user2uid(char *user, uid_t *uid, gid_t *gid, char **name, char **home);",
      "static int lurk(char **users);",
      "static int try_user_and_display(uid_t uid, gid_t gid, char *dpystr);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "list[lind]"
          ],
          "line": 522
        },
        "resolved": true,
        "details": {
          "function_name": "free_rect",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/userinput.c",
          "lines": "6200-6247",
          "snippet": "int free_rect(int idx) {\n\tint n, ok = 0;\n\tsraRegionPtr r1, r2;\n\tint x, y, w, h;\n\n\tif (idx < 0 || idx >= cache_list_num) {\nif (0) fprintf(stderr, \"free_rect: bad index: %d\\n\", idx);\n\t\tclean_up_exit(1);\n\t}\n\n\tx = cache_list[idx].bs_x;\n\ty = cache_list[idx].bs_y;\n\tw = cache_list[idx].bs_w;\n\th = cache_list[idx].bs_h;\n\n\tif (x < 0) {\n\t\tCLEAR(idx);\nif (dnow() > last_client + 5 && ncdb) fprintf(stderr, \"free_rect: already bs_x invalidated: %d bs_x: %d\\n\", idx, x);\n\t\treturn 1;\n\t}\n\n\tr2 = sraRgnCreateRect(x, y, x+w, y+h);\n\n\tn = get_bs_n(y);\n\tif (n >= 0) {\n\t\tr1 = rect_reg[n];\n\t\tsraRgnOr(r1, r2);\n\t\tok = 1;\n\t}\n\n\tif (zero_rects) {\n\t\tsraRgnOr(zero_rects, r2);\n\t\tx = cache_list[idx].su_x;\n\t\ty = cache_list[idx].su_y;\n\t\tw = cache_list[idx].su_w;\n\t\th = cache_list[idx].su_h;\n\t\tif (x >= 0) {\n\t\t\tsraRgnDestroy(r2);\n\t\t\tr2 = sraRgnCreateRect(x, y, x+w, y+h);\n\t\t\tsraRgnOr(zero_rects, r2);\n\t\t}\n\t}\n\tsraRgnDestroy(r2);\n\n\tCLEAR(idx);\nif (! ok && ncdb) fprintf(stderr, \"**** free_rect: not-found %d\\n\", idx);\n\treturn ok;\n}",
          "includes": [
            "#include \"default8x16.h\"",
            "#include \"connections.h\"",
            "#include \"screen.h\"",
            "#include \"cursor.h\"",
            "#include \"macosxCGS.h\"",
            "#include \"macosx.h\"",
            "#include \"unixpw.h\"",
            "#include \"8to24.h\"",
            "#include \"xrandr.h\"",
            "#include \"solid.h\"",
            "#include \"keyboard.h\"",
            "#include \"rates.h\"",
            "#include \"pointer.h\"",
            "#include \"cleanup.h\"",
            "#include \"scan.h\"",
            "#include \"user.h\"",
            "#include \"xevents.h\"",
            "#include \"win_utils.h\"",
            "#include \"xinerama.h\"",
            "#include \"xrecord.h\"",
            "#include \"xdamage.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void mark_for_xdamage(int x, int y, int w, int h);",
            "void set_xdamage_mark(int x, int y, int w, int h);",
            "int find_rect(int idx, int x, int y, int w, int h);",
            "winattr_t *cache_list;",
            "int clipped(int idx);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"default8x16.h\"\n#include \"connections.h\"\n#include \"screen.h\"\n#include \"cursor.h\"\n#include \"macosxCGS.h\"\n#include \"macosx.h\"\n#include \"unixpw.h\"\n#include \"8to24.h\"\n#include \"xrandr.h\"\n#include \"solid.h\"\n#include \"keyboard.h\"\n#include \"rates.h\"\n#include \"pointer.h\"\n#include \"cleanup.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"xevents.h\"\n#include \"win_utils.h\"\n#include \"xinerama.h\"\n#include \"xrecord.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nvoid mark_for_xdamage(int x, int y, int w, int h);\nvoid set_xdamage_mark(int x, int y, int w, int h);\nint find_rect(int idx, int x, int y, int w, int h);\nwinattr_t *cache_list;\nint clipped(int idx);\n\nint free_rect(int idx) {\n\tint n, ok = 0;\n\tsraRegionPtr r1, r2;\n\tint x, y, w, h;\n\n\tif (idx < 0 || idx >= cache_list_num) {\nif (0) fprintf(stderr, \"free_rect: bad index: %d\\n\", idx);\n\t\tclean_up_exit(1);\n\t}\n\n\tx = cache_list[idx].bs_x;\n\ty = cache_list[idx].bs_y;\n\tw = cache_list[idx].bs_w;\n\th = cache_list[idx].bs_h;\n\n\tif (x < 0) {\n\t\tCLEAR(idx);\nif (dnow() > last_client + 5 && ncdb) fprintf(stderr, \"free_rect: already bs_x invalidated: %d bs_x: %d\\n\", idx, x);\n\t\treturn 1;\n\t}\n\n\tr2 = sraRgnCreateRect(x, y, x+w, y+h);\n\n\tn = get_bs_n(y);\n\tif (n >= 0) {\n\t\tr1 = rect_reg[n];\n\t\tsraRgnOr(r1, r2);\n\t\tok = 1;\n\t}\n\n\tif (zero_rects) {\n\t\tsraRgnOr(zero_rects, r2);\n\t\tx = cache_list[idx].su_x;\n\t\ty = cache_list[idx].su_y;\n\t\tw = cache_list[idx].su_w;\n\t\th = cache_list[idx].su_h;\n\t\tif (x >= 0) {\n\t\t\tsraRgnDestroy(r2);\n\t\t\tr2 = sraRgnCreateRect(x, y, x+w, y+h);\n\t\t\tsraRgnOr(zero_rects, r2);\n\t\t}\n\t}\n\tsraRgnDestroy(r2);\n\n\tCLEAR(idx);\nif (! ok && ncdb) fprintf(stderr, \"**** free_rect: not-found %d\\n\", idx);\n\treturn ok;\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_env",
          "args": [
            "\"DISPLAY\"",
            "dpystr"
          ],
          "line": 511
        },
        "resolved": true,
        "details": {
          "function_name": "set_env",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/util.c",
          "lines": "239-249",
          "snippet": "void set_env(char *name, char *value) {\n\tchar *str;\n\tif (! name) {\n\t\treturn;\n\t}\n\tif (! value) {\n\t\tvalue = \"\";\n\t}\n\n\tsetenv(name, value, 1);\n}",
          "includes": [
            "#include \"connections.h\"",
            "#include \"unixpw.h\"",
            "#include \"win_utils.h\"",
            "#include \"cleanup.h\"",
            "#include \"x11vnc.h\"",
            "#include <stdlib.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void lowercase(char *str);",
            "void uppercase(char *str);",
            "char *lblanks(char *str);",
            "void strzero(char *str);",
            "void set_env(char *name, char *value);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"connections.h\"\n#include \"unixpw.h\"\n#include \"win_utils.h\"\n#include \"cleanup.h\"\n#include \"x11vnc.h\"\n#include <stdlib.h>\n\nvoid lowercase(char *str);\nvoid uppercase(char *str);\nchar *lblanks(char *str);\nvoid strzero(char *str);\nvoid set_env(char *name, char *value);\n\nvoid set_env(char *name, char *value) {\n\tchar *str;\n\tif (! name) {\n\t\treturn;\n\t}\n\tif (! value) {\n\t\tvalue = \"\";\n\t}\n\n\tsetenv(name, value, 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"lurk: now user: %s @ %s\\n\"",
            "name",
            "dpystr"
          ],
          "line": 506
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "switch_user_env",
          "args": [
            "uid",
            "gid",
            "name",
            "home",
            "0"
          ],
          "line": 505
        },
        "resolved": true,
        "details": {
          "function_name": "switch_user_env",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/user.c",
          "lines": "759-825",
          "snippet": "static int switch_user_env(uid_t uid, gid_t gid, char *name, char *home, int fb_mode) {\n\t/* NO strtoks */\n\tchar *xauth;\n\tint reset_fb = 0;\n\tint grp_ok = 0;\n\n#if !HAVE_SETUID\n\treturn 0;\n#else\n\t/*\n\t * OK, tricky here, we need to free the shm... otherwise\n\t * we won't be able to delete it as the other user...\n\t */\n\tif (fb_mode == 1 && (using_shm && ! xform24to32)) {\n\t\treset_fb = 1;\n\t\tclean_shm(0);\n\t\tfree_tiles();\n\t}\n#if HAVE_INITGROUPS\n#if HAVE_PWD_H\n\tif (getpwuid(uid) != NULL && getenv(\"X11VNC_SINGLE_GROUP\") == NULL) {\n\t\tstruct passwd *p = getpwuid(uid);\n\t\t/* another possibility is p->pw_gid instead of gid */\n\t\tif (setgid(gid) == 0 && initgroups(p->pw_name, gid) == 0)  {\n\t\t\tgrp_ok = 1;\n\t\t} else {\n\t\t\trfbLogPerror(\"initgroups\");\n\t\t}\n\t\tendgrent();\n\t}\n#endif\n#endif\n\tif (! grp_ok) {\n\t\tif (setgid(gid) == 0) {\n\t\t\tgrp_ok = 1;\n\t\t}\n\t}\n\tif (! grp_ok) {\n\t\tif (reset_fb) {\n\t\t\t/* 2 means we did clean_shm and free_tiles */\n\t\t\tdo_new_fb(2);\n\t\t}\n\t\treturn 0;\n\t}\n\n\tif (setuid(uid) != 0) {\n\t\tif (reset_fb) {\n\t\t\t/* 2 means we did clean_shm and free_tiles */\n\t\t\tdo_new_fb(2);\n\t\t}\n\t\treturn 0;\n\t}\n#endif\n\tif (reset_fb) {\n\t\tdo_new_fb(2);\n\t}\n\n\txauth = getenv(\"XAUTHORITY\");\n\tif (xauth && access(xauth, R_OK) != 0) {\n\t\t*(xauth-2) = '_';\t/* yow */\n\t}\n\t\n\tset_env(\"USER\", name);\n\tset_env(\"LOGNAME\", name);\n\tset_env(\"HOME\", home);\n\treturn 1;\n}",
          "includes": [
            "#include \"avahi.h\"",
            "#include \"sslhelper.h\"",
            "#include \"remote.h\"",
            "#include \"cursor.h\"",
            "#include \"keyboard.h\"",
            "#include \"inet.h\"",
            "#include \"connections.h\"",
            "#include \"xwrappers.h\"",
            "#include \"sslhelper.h\"",
            "#include \"unixpw.h\"",
            "#include \"screen.h\"",
            "#include \"scan.h\"",
            "#include \"cleanup.h\"",
            "#include \"solid.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int switch_user(char *user, int fb_mode);",
            "static void user2uid(char *user, uid_t *uid, gid_t *gid, char **name, char **home);",
            "static int guess_user_and_switch(char *str, int fb_mode);",
            "static int switch_user_env(uid_t uid, gid_t gid, char *name, char *home, int fb_mode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"avahi.h\"\n#include \"sslhelper.h\"\n#include \"remote.h\"\n#include \"cursor.h\"\n#include \"keyboard.h\"\n#include \"inet.h\"\n#include \"connections.h\"\n#include \"xwrappers.h\"\n#include \"sslhelper.h\"\n#include \"unixpw.h\"\n#include \"screen.h\"\n#include \"scan.h\"\n#include \"cleanup.h\"\n#include \"solid.h\"\n#include \"x11vnc.h\"\n\nint switch_user(char *user, int fb_mode);\nstatic void user2uid(char *user, uid_t *uid, gid_t *gid, char **name, char **home);\nstatic int guess_user_and_switch(char *str, int fb_mode);\nstatic int switch_user_env(uid_t uid, gid_t gid, char *name, char *home, int fb_mode);\n\nstatic int switch_user_env(uid_t uid, gid_t gid, char *name, char *home, int fb_mode) {\n\t/* NO strtoks */\n\tchar *xauth;\n\tint reset_fb = 0;\n\tint grp_ok = 0;\n\n#if !HAVE_SETUID\n\treturn 0;\n#else\n\t/*\n\t * OK, tricky here, we need to free the shm... otherwise\n\t * we won't be able to delete it as the other user...\n\t */\n\tif (fb_mode == 1 && (using_shm && ! xform24to32)) {\n\t\treset_fb = 1;\n\t\tclean_shm(0);\n\t\tfree_tiles();\n\t}\n#if HAVE_INITGROUPS\n#if HAVE_PWD_H\n\tif (getpwuid(uid) != NULL && getenv(\"X11VNC_SINGLE_GROUP\") == NULL) {\n\t\tstruct passwd *p = getpwuid(uid);\n\t\t/* another possibility is p->pw_gid instead of gid */\n\t\tif (setgid(gid) == 0 && initgroups(p->pw_name, gid) == 0)  {\n\t\t\tgrp_ok = 1;\n\t\t} else {\n\t\t\trfbLogPerror(\"initgroups\");\n\t\t}\n\t\tendgrent();\n\t}\n#endif\n#endif\n\tif (! grp_ok) {\n\t\tif (setgid(gid) == 0) {\n\t\t\tgrp_ok = 1;\n\t\t}\n\t}\n\tif (! grp_ok) {\n\t\tif (reset_fb) {\n\t\t\t/* 2 means we did clean_shm and free_tiles */\n\t\t\tdo_new_fb(2);\n\t\t}\n\t\treturn 0;\n\t}\n\n\tif (setuid(uid) != 0) {\n\t\tif (reset_fb) {\n\t\t\t/* 2 means we did clean_shm and free_tiles */\n\t\t\tdo_new_fb(2);\n\t\t}\n\t\treturn 0;\n\t}\n#endif\n\tif (reset_fb) {\n\t\tdo_new_fb(2);\n\t}\n\n\txauth = getenv(\"XAUTHORITY\");\n\tif (xauth && access(xauth, R_OK) != 0) {\n\t\t*(xauth-2) = '_';\t/* yow */\n\t}\n\t\n\tset_env(\"USER\", name);\n\tset_env(\"LOGNAME\", name);\n\tset_env(\"HOME\", home);\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "try_user_and_display",
          "args": [
            "uid",
            "gid",
            "dpystr"
          ],
          "line": 504
        },
        "resolved": true,
        "details": {
          "function_name": "try_user_and_display",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/user.c",
          "lines": "652-713",
          "snippet": "static int try_user_and_display(uid_t uid, gid_t gid, char *dpystr) {\n\t/* NO strtoks */\n#if LIBVNCSERVER_HAVE_FORK && LIBVNCSERVER_HAVE_SYS_WAIT_H && HAVE_PWD_H\n\tpid_t pid, pidw;\n\tchar *home, *name;\n\tint st;\n\tstruct passwd *pw;\n\t\n\tpw = getpwuid(uid);\n\tif (pw) {\n\t\tname = pw->pw_name;\n\t\thome = pw->pw_dir;\n\t} else {\n\t\treturn 0;\n\t}\n\n\t/* \n\t * We fork here and try to open the display again as the\n\t * new user.  Unreadable XAUTHORITY could be a problem...\n\t * This is not really needed since we have DISPLAY open but:\n\t * 1) is a good indicator this user owns the session and  2)\n\t * some activities do spawn new X apps, e.g.  xmessage(1), etc.\n\t */\n\tif ((pid = fork()) > 0) {\n\t\t;\n\t} else if (pid == -1) {\n\t\tfprintf(stderr, \"could not fork\\n\");\n\t\trfbLogPerror(\"fork\");\n\t\treturn 0;\n\t} else {\n\t\t/* child */\n\t\tDisplay *dpy2 = NULL;\n\t\tint rc;\n\n\t\tsignal(SIGHUP,  SIG_DFL);\n\t\tsignal(SIGINT,  SIG_DFL);\n\t\tsignal(SIGQUIT, SIG_DFL);\n\t\tsignal(SIGTERM, SIG_DFL);\n\n\t\trc = switch_user_env(uid, gid, name, home, 0); \n\t\tif (! rc) {\n\t\t\texit(1);\n\t\t}\n\n\t\tfclose(stderr);\n\t\tdpy2 = XOpenDisplay_wr(dpystr);\n\t\tif (dpy2) {\n\t\t\tXCloseDisplay_wr(dpy2);\n\t\t\texit(0);\t/* success */\n\t\t} else {\n\t\t\texit(2);\t/* fail */\n\t\t}\n\t}\n\n\t/* see what the child says: */\n\tpidw = waitpid(pid, &st, 0);\n\tif (pidw == pid && WIFEXITED(st) && WEXITSTATUS(st) == 0) {\n\t\treturn 1;\n\t}\n#endif\t/* LIBVNCSERVER_HAVE_FORK ... */\n\treturn 0;\n}",
          "includes": [
            "#include \"avahi.h\"",
            "#include \"sslhelper.h\"",
            "#include \"remote.h\"",
            "#include \"cursor.h\"",
            "#include \"keyboard.h\"",
            "#include \"inet.h\"",
            "#include \"connections.h\"",
            "#include \"xwrappers.h\"",
            "#include \"sslhelper.h\"",
            "#include \"unixpw.h\"",
            "#include \"screen.h\"",
            "#include \"scan.h\"",
            "#include \"cleanup.h\"",
            "#include \"solid.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void user2uid(char *user, uid_t *uid, gid_t *gid, char **name, char **home);",
            "static int try_user_and_display(uid_t uid, gid_t gid, char *dpystr);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"avahi.h\"\n#include \"sslhelper.h\"\n#include \"remote.h\"\n#include \"cursor.h\"\n#include \"keyboard.h\"\n#include \"inet.h\"\n#include \"connections.h\"\n#include \"xwrappers.h\"\n#include \"sslhelper.h\"\n#include \"unixpw.h\"\n#include \"screen.h\"\n#include \"scan.h\"\n#include \"cleanup.h\"\n#include \"solid.h\"\n#include \"x11vnc.h\"\n\nstatic void user2uid(char *user, uid_t *uid, gid_t *gid, char **name, char **home);\nstatic int try_user_and_display(uid_t uid, gid_t gid, char *dpystr);\n\nstatic int try_user_and_display(uid_t uid, gid_t gid, char *dpystr) {\n\t/* NO strtoks */\n#if LIBVNCSERVER_HAVE_FORK && LIBVNCSERVER_HAVE_SYS_WAIT_H && HAVE_PWD_H\n\tpid_t pid, pidw;\n\tchar *home, *name;\n\tint st;\n\tstruct passwd *pw;\n\t\n\tpw = getpwuid(uid);\n\tif (pw) {\n\t\tname = pw->pw_name;\n\t\thome = pw->pw_dir;\n\t} else {\n\t\treturn 0;\n\t}\n\n\t/* \n\t * We fork here and try to open the display again as the\n\t * new user.  Unreadable XAUTHORITY could be a problem...\n\t * This is not really needed since we have DISPLAY open but:\n\t * 1) is a good indicator this user owns the session and  2)\n\t * some activities do spawn new X apps, e.g.  xmessage(1), etc.\n\t */\n\tif ((pid = fork()) > 0) {\n\t\t;\n\t} else if (pid == -1) {\n\t\tfprintf(stderr, \"could not fork\\n\");\n\t\trfbLogPerror(\"fork\");\n\t\treturn 0;\n\t} else {\n\t\t/* child */\n\t\tDisplay *dpy2 = NULL;\n\t\tint rc;\n\n\t\tsignal(SIGHUP,  SIG_DFL);\n\t\tsignal(SIGINT,  SIG_DFL);\n\t\tsignal(SIGQUIT, SIG_DFL);\n\t\tsignal(SIGTERM, SIG_DFL);\n\n\t\trc = switch_user_env(uid, gid, name, home, 0); \n\t\tif (! rc) {\n\t\t\texit(1);\n\t\t}\n\n\t\tfclose(stderr);\n\t\tdpy2 = XOpenDisplay_wr(dpystr);\n\t\tif (dpy2) {\n\t\t\tXCloseDisplay_wr(dpy2);\n\t\t\texit(0);\t/* success */\n\t\t} else {\n\t\t\texit(2);\t/* fail */\n\t\t}\n\t}\n\n\t/* see what the child says: */\n\tpidw = waitpid(pid, &st, 0);\n\tif (pidw == pid && WIFEXITED(st) && WEXITSTATUS(st) == 0) {\n\t\treturn 1;\n\t}\n#endif\t/* LIBVNCSERVER_HAVE_FORK ... */\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "dpystr",
            "\":%d\"",
            "dn"
          ],
          "line": 502
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "user2uid",
          "args": [
            "user",
            "&uid",
            "&gid",
            "&name",
            "&home"
          ],
          "line": 489
        },
        "resolved": true,
        "details": {
          "function_name": "user2uid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/user.c",
          "lines": "274-361",
          "snippet": "static void user2uid(char *user, uid_t *uid, gid_t *gid, char **name, char **home) {\n\tint numerical = 1, gotgroup = 0;\n\tchar *q;\n\n\t*uid = (uid_t) -1;\n\t*name = NULL;\n\t*home = NULL;\n\n\tq = user;\n\twhile (*q) {\n\t\tif (! isdigit((unsigned char) (*q++))) {\n\t\t\tnumerical = 0;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (user2group != NULL) {\n\t\tstatic int *did = NULL;\n\t\tint i;\n\n\t\tif (did == NULL) {\n\t\t\tint n = 0;\n\t\t\ti = 0;\n\t\t\twhile (user2group[i] != NULL) {\n\t\t\t\tn++;\n\t\t\t\ti++;\n\t\t\t}\n\t\t\tdid = (int *) malloc((n+1) * sizeof(int)); \n\t\t\ti = 0;\n\t\t\tfor (i=0; i<n; i++) {\n\t\t\t\tdid[i] = 0;\n\t\t\t}\n\t\t}\n\t\ti = 0;\n\t\twhile (user2group[i] != NULL) {\n\t\t\tif (strstr(user2group[i], user) == user2group[i]) {\n\t\t\t\tchar *w = user2group[i] + strlen(user);\n\t\t\t\tif (*w == '.') {\n#if (SMALL_FOOTPRINT > 2)\n\t\t\t\t\tgotgroup = 0;\n#else\n\t\t\t\t\tstruct group* gr = getgrnam(++w);\n\t\t\t\t\tif (! gr) {\n\t\t\t\t\t\trfbLog(\"Invalid group: %s\\n\", w);\n\t\t\t\t\t\tclean_up_exit(1);\n\t\t\t\t\t}\n\t\t\t\t\t*gid = gr->gr_gid;\n\t\t\t\t\tif (! did[i]) {\n\t\t\t\t\t\trfbLog(\"user2uid: using group %s (%d) for %s\\n\",\n\t\t\t\t\t\t    w, (int) *gid, user);\n\t\t\t\t\t\tdid[i] = 1;\n\t\t\t\t\t}\n\t\t\t\t\tgotgroup = 1;\n#endif\n\t\t\t\t}\n\t\t\t}\n\t\t\ti++;\n\t\t}\n\t}\n\n\tif (numerical) {\n\t\tint u = atoi(user);\n\n\t\tif (u < 0) {\n\t\t\treturn;\n\t\t}\n\t\t*uid = (uid_t) u;\n\t}\n\n#if HAVE_PWD_H\n\tif (1) {\n\t\tstruct passwd *pw;\n\t\tif (numerical) {\n\t\t\tpw = getpwuid(*uid);\n\t\t} else {\n\t\t\tpw = getpwnam(user);\n\t\t}\n\t\tif (pw) {\n\t\t\t*uid  = pw->pw_uid;\n\t\t\tif (! gotgroup) {\n\t\t\t\t*gid  = pw->pw_gid;\n\t\t\t}\n\t\t\t*name = pw->pw_name;\t/* n.b. use immediately */\n\t\t\t*home = pw->pw_dir;\n\t\t}\n\t}\n#endif\n}",
          "includes": [
            "#include \"avahi.h\"",
            "#include \"sslhelper.h\"",
            "#include \"remote.h\"",
            "#include \"cursor.h\"",
            "#include \"keyboard.h\"",
            "#include \"inet.h\"",
            "#include \"connections.h\"",
            "#include \"xwrappers.h\"",
            "#include \"sslhelper.h\"",
            "#include \"unixpw.h\"",
            "#include \"screen.h\"",
            "#include \"scan.h\"",
            "#include \"cleanup.h\"",
            "#include \"solid.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void user2uid(char *user, uid_t *uid, gid_t *gid, char **name, char **home);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"avahi.h\"\n#include \"sslhelper.h\"\n#include \"remote.h\"\n#include \"cursor.h\"\n#include \"keyboard.h\"\n#include \"inet.h\"\n#include \"connections.h\"\n#include \"xwrappers.h\"\n#include \"sslhelper.h\"\n#include \"unixpw.h\"\n#include \"screen.h\"\n#include \"scan.h\"\n#include \"cleanup.h\"\n#include \"solid.h\"\n#include \"x11vnc.h\"\n\nstatic void user2uid(char *user, uid_t *uid, gid_t *gid, char **name, char **home);\n\nstatic void user2uid(char *user, uid_t *uid, gid_t *gid, char **name, char **home) {\n\tint numerical = 1, gotgroup = 0;\n\tchar *q;\n\n\t*uid = (uid_t) -1;\n\t*name = NULL;\n\t*home = NULL;\n\n\tq = user;\n\twhile (*q) {\n\t\tif (! isdigit((unsigned char) (*q++))) {\n\t\t\tnumerical = 0;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (user2group != NULL) {\n\t\tstatic int *did = NULL;\n\t\tint i;\n\n\t\tif (did == NULL) {\n\t\t\tint n = 0;\n\t\t\ti = 0;\n\t\t\twhile (user2group[i] != NULL) {\n\t\t\t\tn++;\n\t\t\t\ti++;\n\t\t\t}\n\t\t\tdid = (int *) malloc((n+1) * sizeof(int)); \n\t\t\ti = 0;\n\t\t\tfor (i=0; i<n; i++) {\n\t\t\t\tdid[i] = 0;\n\t\t\t}\n\t\t}\n\t\ti = 0;\n\t\twhile (user2group[i] != NULL) {\n\t\t\tif (strstr(user2group[i], user) == user2group[i]) {\n\t\t\t\tchar *w = user2group[i] + strlen(user);\n\t\t\t\tif (*w == '.') {\n#if (SMALL_FOOTPRINT > 2)\n\t\t\t\t\tgotgroup = 0;\n#else\n\t\t\t\t\tstruct group* gr = getgrnam(++w);\n\t\t\t\t\tif (! gr) {\n\t\t\t\t\t\trfbLog(\"Invalid group: %s\\n\", w);\n\t\t\t\t\t\tclean_up_exit(1);\n\t\t\t\t\t}\n\t\t\t\t\t*gid = gr->gr_gid;\n\t\t\t\t\tif (! did[i]) {\n\t\t\t\t\t\trfbLog(\"user2uid: using group %s (%d) for %s\\n\",\n\t\t\t\t\t\t    w, (int) *gid, user);\n\t\t\t\t\t\tdid[i] = 1;\n\t\t\t\t\t}\n\t\t\t\t\tgotgroup = 1;\n#endif\n\t\t\t\t}\n\t\t\t}\n\t\t\ti++;\n\t\t}\n\t}\n\n\tif (numerical) {\n\t\tint u = atoi(user);\n\n\t\tif (u < 0) {\n\t\t\treturn;\n\t\t}\n\t\t*uid = (uid_t) u;\n\t}\n\n#if HAVE_PWD_H\n\tif (1) {\n\t\tstruct passwd *pw;\n\t\tif (numerical) {\n\t\t\tpw = getpwuid(*uid);\n\t\t} else {\n\t\t\tpw = getpwnam(user);\n\t\t}\n\t\tif (pw) {\n\t\t\t*uid  = pw->pw_uid;\n\t\t\tif (! gotgroup) {\n\t\t\t\t*gid  = pw->pw_gid;\n\t\t\t}\n\t\t\t*name = pw->pw_name;\t/* n.b. use immediately */\n\t\t\t*home = pw->pw_dir;\n\t\t}\n\t}\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "user",
            "*u++"
          ],
          "line": 482
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "dpystr",
            "sizeof dpystr",
            "\":%s\"",
            "q+1"
          ],
          "line": 472
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "t",
            "':'"
          ],
          "line": 465
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "p"
          ],
          "line": 464
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strtok",
          "args": [
            "NULL",
            "\",\""
          ],
          "line": 452
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "p"
          ],
          "line": 451
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strtok",
          "args": [
            "logins",
            "\",\""
          ],
          "line": 449
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "calloc",
          "args": [
            "(strlen(logins)+2)*sizeof(char *)",
            "1"
          ],
          "line": 447
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "logins"
          ],
          "line": 447
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_login_list",
          "args": [
            "1"
          ],
          "line": 444
        },
        "resolved": true,
        "details": {
          "function_name": "get_login_list",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/user.c",
          "lines": "141-249",
          "snippet": "static char *get_login_list(int with_display) {\n\tchar *out;\n#if HAVE_UTMPX_H\n\tint i, cnt, max = 200, ut_namesize = 32;\n#define DPYMAX 1000\n\tint sawdpy[DPYMAX];\n\tstruct utmpx *utx;\n\n\t/* size based on \"username:999,\" * max */\n\tout = (char *) malloc(max * (ut_namesize+1+3+1) + 1);\n\tout[0] = '\\0';\n\n\tfor (i=0; i < DPYMAX; i++) {\n\t\tsawdpy[i] = 0;\n\t}\n\n\tsetutxent();\n\tcnt = 0;\n\twhile (1) {\n\t\tchar *user, *line, *host, *id;\n\t\tchar tmp[10];\n\t\tint d = -1;\n\t\tutx = getutxent();\n\t\tif (! utx) {\n\t\t\tbreak;\n\t\t}\n\t\tif (utx->ut_type != USER_PROCESS) {\n\t\t\tcontinue;\n\t\t}\n\t\tuser = lblanks(utx->ut_user);\n\t\tif (*user == '\\0') {\n\t\t\tcontinue;\n\t\t}\n\t\tif (strchr(user, ',')) {\n\t\t\tcontinue;\t/* unlikely, but comma is our sep. */\n\t\t}\n\n\t\tline = lblanks(utx->ut_line);\n\t\thost = lblanks(utx->ut_host);\n\t\tid   = lblanks(utx->ut_id);\n\n\t\tif (with_display) {\n\t\t\tif (0 && line[0] != ':' && strcmp(line, \"dtlocal\")) {\n\t\t\t\t/* XXX useful? */\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (line[0] == ':') {\n\t\t\t\tif (sscanf(line, \":%d\", &d) != 1)  {\n\t\t\t\t\td = -1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (d < 0 && host[0] == ':') {\n\t\t\t\tif (sscanf(host, \":%d\", &d) != 1)  {\n\t\t\t\t\td = -1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (d < 0 && id[0] == ':') {\n\t\t\t\tif (sscanf(id, \":%d\", &d) != 1)  {\n\t\t\t\t\td = -1;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (d < 0 || d >= DPYMAX || sawdpy[d]) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tsawdpy[d] = 1;\n\t\t\tsprintf(tmp, \":%d\", d);\n\t\t} else {\n\t\t\t/* try to eliminate repeats */\n\t\t\tint repeat = 0;\n\t\t\tchar *q;\n\n\t\t\tq = out;\n\t\t\twhile ((q = strstr(q, user)) != NULL) {\n\t\t\t\tchar *p = q + strlen(user) + strlen(\":DPY\");\n\t\t\t\tif (q == out || *(q-1) == ',') {\n\t\t\t\t\t/* bounded on left. */\n\t\t\t\t\tif (*p == ',' || *p == '\\0') {\n\t\t\t\t\t\t/* bounded on right. */\n\t\t\t\t\t\trepeat = 1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tq = p;\n\t\t\t}\n\t\t\tif (repeat) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tsprintf(tmp, \":DPY\");\n\t\t}\n\n\t\tif (*out) {\n\t\t\tstrcat(out, \",\");\n\t\t}\n\t\tstrcat(out, user);\n\t\tstrcat(out, tmp);\n\n\t\tcnt++;\n\t\tif (cnt >= max) {\n\t\t\tbreak;\n\t\t}\n\t}\n\tendutxent();\n#else\n\tout = strdup(\"\");\n#endif\n\treturn out;\n}",
          "includes": [
            "#include \"avahi.h\"",
            "#include \"sslhelper.h\"",
            "#include \"remote.h\"",
            "#include \"cursor.h\"",
            "#include \"keyboard.h\"",
            "#include \"inet.h\"",
            "#include \"connections.h\"",
            "#include \"xwrappers.h\"",
            "#include \"sslhelper.h\"",
            "#include \"unixpw.h\"",
            "#include \"screen.h\"",
            "#include \"scan.h\"",
            "#include \"cleanup.h\"",
            "#include \"solid.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [
            "#define DPYMAX 1000"
          ],
          "globals_used": [
            "static char *get_login_list(int with_display);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"avahi.h\"\n#include \"sslhelper.h\"\n#include \"remote.h\"\n#include \"cursor.h\"\n#include \"keyboard.h\"\n#include \"inet.h\"\n#include \"connections.h\"\n#include \"xwrappers.h\"\n#include \"sslhelper.h\"\n#include \"unixpw.h\"\n#include \"screen.h\"\n#include \"scan.h\"\n#include \"cleanup.h\"\n#include \"solid.h\"\n#include \"x11vnc.h\"\n\n#define DPYMAX 1000\n\nstatic char *get_login_list(int with_display);\n\nstatic char *get_login_list(int with_display) {\n\tchar *out;\n#if HAVE_UTMPX_H\n\tint i, cnt, max = 200, ut_namesize = 32;\n#define DPYMAX 1000\n\tint sawdpy[DPYMAX];\n\tstruct utmpx *utx;\n\n\t/* size based on \"username:999,\" * max */\n\tout = (char *) malloc(max * (ut_namesize+1+3+1) + 1);\n\tout[0] = '\\0';\n\n\tfor (i=0; i < DPYMAX; i++) {\n\t\tsawdpy[i] = 0;\n\t}\n\n\tsetutxent();\n\tcnt = 0;\n\twhile (1) {\n\t\tchar *user, *line, *host, *id;\n\t\tchar tmp[10];\n\t\tint d = -1;\n\t\tutx = getutxent();\n\t\tif (! utx) {\n\t\t\tbreak;\n\t\t}\n\t\tif (utx->ut_type != USER_PROCESS) {\n\t\t\tcontinue;\n\t\t}\n\t\tuser = lblanks(utx->ut_user);\n\t\tif (*user == '\\0') {\n\t\t\tcontinue;\n\t\t}\n\t\tif (strchr(user, ',')) {\n\t\t\tcontinue;\t/* unlikely, but comma is our sep. */\n\t\t}\n\n\t\tline = lblanks(utx->ut_line);\n\t\thost = lblanks(utx->ut_host);\n\t\tid   = lblanks(utx->ut_id);\n\n\t\tif (with_display) {\n\t\t\tif (0 && line[0] != ':' && strcmp(line, \"dtlocal\")) {\n\t\t\t\t/* XXX useful? */\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (line[0] == ':') {\n\t\t\t\tif (sscanf(line, \":%d\", &d) != 1)  {\n\t\t\t\t\td = -1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (d < 0 && host[0] == ':') {\n\t\t\t\tif (sscanf(host, \":%d\", &d) != 1)  {\n\t\t\t\t\td = -1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (d < 0 && id[0] == ':') {\n\t\t\t\tif (sscanf(id, \":%d\", &d) != 1)  {\n\t\t\t\t\td = -1;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (d < 0 || d >= DPYMAX || sawdpy[d]) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tsawdpy[d] = 1;\n\t\t\tsprintf(tmp, \":%d\", d);\n\t\t} else {\n\t\t\t/* try to eliminate repeats */\n\t\t\tint repeat = 0;\n\t\t\tchar *q;\n\n\t\t\tq = out;\n\t\t\twhile ((q = strstr(q, user)) != NULL) {\n\t\t\t\tchar *p = q + strlen(user) + strlen(\":DPY\");\n\t\t\t\tif (q == out || *(q-1) == ',') {\n\t\t\t\t\t/* bounded on left. */\n\t\t\t\t\tif (*p == ',' || *p == '\\0') {\n\t\t\t\t\t\t/* bounded on right. */\n\t\t\t\t\t\trepeat = 1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tq = p;\n\t\t\t}\n\t\t\tif (repeat) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tsprintf(tmp, \":DPY\");\n\t\t}\n\n\t\tif (*out) {\n\t\t\tstrcat(out, \",\");\n\t\t}\n\t\tstrcat(out, user);\n\t\tstrcat(out, tmp);\n\n\t\tcnt++;\n\t\tif (cnt >= max) {\n\t\t\tbreak;\n\t\t}\n\t}\n\tendutxent();\n#else\n\tout = strdup(\"\");\n#endif\n\treturn out;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcat",
          "args": [
            "tmp",
            "\":DPY\""
          ],
          "line": 437
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcat",
          "args": [
            "tmp",
            "*u"
          ],
          "line": 436
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcat",
          "args": [
            "tmp",
            "\",\""
          ],
          "line": 434
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "chk"
          ],
          "line": 421
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "tmp",
            "chk"
          ],
          "line": 419
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "chk",
            "sizeof chk",
            "\"%s:DPY\"",
            "*u"
          ],
          "line": 418
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcpy",
          "args": [
            "tmp",
            "logins"
          ],
          "line": 412
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "len+1"
          ],
          "line": 411
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "\":DPY,\""
          ],
          "line": 408
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "*u"
          ],
          "line": 408
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "logins"
          ],
          "line": 405
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sscanf",
          "args": [
            "tmp",
            "\":%d\"",
            "&dmin"
          ],
          "line": 385
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sscanf",
          "args": [
            "tmp",
            "\":%d-%d\"",
            "&dmin",
            "&dmax"
          ],
          "line": 379
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "tmp",
            "'-'"
          ],
          "line": 378
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"avahi.h\"\n#include \"sslhelper.h\"\n#include \"remote.h\"\n#include \"cursor.h\"\n#include \"keyboard.h\"\n#include \"inet.h\"\n#include \"connections.h\"\n#include \"xwrappers.h\"\n#include \"sslhelper.h\"\n#include \"unixpw.h\"\n#include \"screen.h\"\n#include \"scan.h\"\n#include \"cleanup.h\"\n#include \"solid.h\"\n#include \"x11vnc.h\"\n\nrfbBool custom_passwd_check(rfbClientPtr cl, const char *response, int len);\nstatic void user2uid(char *user, uid_t *uid, gid_t *gid, char **name, char **home);\nstatic int lurk(char **users);\nstatic int try_user_and_display(uid_t uid, gid_t gid, char *dpystr);\n\nstatic int lurk(char **users) {\n\tuid_t uid;\n\tgid_t gid;\n\tint success = 0, dmin = -1, dmax = -1;\n\tchar *p, *logins, **u;\n\tchar **list;\n\tint lind;\n\n\tif ((u = users) != NULL && *u != NULL && *(*u) == ':') {\n\t\tint len;\n\t\tchar *tmp;\n\n\t\t/* extract min and max display numbers */\n\t\ttmp = *u;\n\t\tif (strchr(tmp, '-')) {\n\t\t\tif (sscanf(tmp, \":%d-%d\", &dmin, &dmax) != 2) {\n\t\t\t\tdmin = -1;\n\t\t\t\tdmax = -1;\n\t\t\t}\n\t\t}\n\t\tif (dmin < 0) {\n\t\t\tif (sscanf(tmp, \":%d\", &dmin) != 1) {\n\t\t\t\tdmin = -1;\n\t\t\t\tdmax = -1;\n\t\t\t} else {\n\t\t\t\tdmax = dmin;\n\t\t\t}\n\t\t}\n\t\tif ((dmin < 0 || dmax < 0) || dmin > dmax || dmax > 10000) {\n\t\t\tdmin = -1;\n\t\t\tdmax = -1;\n\t\t}\n\n\t\t/* get user logins regardless of having a display: */\n\t\tlogins = get_login_list(0);\n\n\t\t/*\n\t\t * now we append the list in users (might as well try\n\t\t * them) this will probably allow weird ways of starting\n\t\t * xservers to work.\n\t\t */\n\t\tlen = strlen(logins);\n\t\tu++;\n\t\twhile (*u != NULL) {\n\t\t\tlen += strlen(*u) + strlen(\":DPY,\");\n\t\t\tu++;\n\t\t}\n\t\ttmp = (char *) malloc(len+1);\n\t\tstrcpy(tmp, logins);\n\n\t\t/* now concatenate them: */\n\t\tu = users+1;\n\t\twhile (*u != NULL) {\n\t\t\tchar *q, chk[100];\n\t\t\tsnprintf(chk, sizeof chk, \"%s:DPY\", *u);\n\t\t\tq = strstr(tmp, chk);\n\t\t\tif (q) {\n\t\t\t\tchar *p = q + strlen(chk);\n\t\t\t\t\n\t\t\t\tif (q == tmp || *(q-1) == ',') {\n\t\t\t\t\t/* bounded on left. */\n\t\t\t\t\tif (*p == ',' || *p == '\\0') {\n\t\t\t\t\t\t/* bounded on right. */\n\t\t\t\t\t\tu++;\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tif (*tmp) {\n\t\t\t\tstrcat(tmp, \",\");\n\t\t\t}\n\t\t\tstrcat(tmp, *u);\n\t\t\tstrcat(tmp, \":DPY\");\n\t\t\tu++;\n\t\t}\n\t\tfree(logins);\n\t\tlogins = tmp;\n\t\t\n\t} else {\n\t\tlogins = get_login_list(1);\n\t}\n\n\tlist = (char **) calloc((strlen(logins)+2)*sizeof(char *), 1);\n\tlind = 0;\n\tp = strtok(logins, \",\");\n\twhile (p) {\n\t\tlist[lind++] = strdup(p);\n\t\tp = strtok(NULL, \",\");\n\t}\n\tfree(logins);\n\n\tlind = 0;\n\twhile (list[lind] != NULL) {\n\t\tchar *user, *name, *home, dpystr[10];\n\t\tchar *q, *t;\n\t\tint ok = 1, dn;\n\n\t\tp = list[lind++];\n\t\t\n\t\tt = strdup(p);\t/* bob:0 */\n\t\tq = strchr(t, ':'); \n\t\tif (! q) {\n\t\t\tfree(t);\n\t\t\tbreak;\n\t\t}\n\t\t*q = '\\0';\n\t\tuser = t;\n\t\tsnprintf(dpystr, sizeof dpystr, \":%s\", q+1);\n\n\t\tif (users) {\n\t\t\tu = users;\n\t\t\tok = 0;\n\t\t\twhile (*u != NULL) {\n\t\t\t\tif (*(*u) == ':') {\n\t\t\t\t\tu++;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (!strcmp(user, *u++)) {\n\t\t\t\t\tok = 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tuser2uid(user, &uid, &gid, &name, &home);\n\t\tfree(t);\n\n\t\tif (! uid || ! gid) {\n\t\t\tok = 0;\n\t\t}\n\n\t\tif (! ok) {\n\t\t\tcontinue;\n\t\t}\n\t\t\n\t\tfor (dn = dmin; dn <= dmax; dn++) {\n\t\t\tif (dn >= 0) {\n\t\t\t\tsprintf(dpystr, \":%d\", dn);\n\t\t\t}\n\t\t\tif (try_user_and_display(uid, gid, dpystr)) {\n\t\t\t\tif (switch_user_env(uid, gid, name, home, 0)) {\n\t\t\t\t\trfbLog(\"lurk: now user: %s @ %s\\n\",\n\t\t\t\t\t    name, dpystr);\n\t\t\t\t\tstarted_as_root = 2;\n\t\t\t\t\tsuccess = 1;\n\t\t\t\t}\n\t\t\t\tset_env(\"DISPLAY\", dpystr);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (success) {\n\t\t\t break;\n\t\t}\n\t}\n\n\tlind = 0;\n\twhile (list[lind] != NULL) {\n\t\tfree(list[lind]);\n\t\tlind++;\n\t}\n\n\treturn success;\n}"
  },
  {
    "function_name": "user2uid",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/user.c",
    "lines": "274-361",
    "snippet": "static void user2uid(char *user, uid_t *uid, gid_t *gid, char **name, char **home) {\n\tint numerical = 1, gotgroup = 0;\n\tchar *q;\n\n\t*uid = (uid_t) -1;\n\t*name = NULL;\n\t*home = NULL;\n\n\tq = user;\n\twhile (*q) {\n\t\tif (! isdigit((unsigned char) (*q++))) {\n\t\t\tnumerical = 0;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (user2group != NULL) {\n\t\tstatic int *did = NULL;\n\t\tint i;\n\n\t\tif (did == NULL) {\n\t\t\tint n = 0;\n\t\t\ti = 0;\n\t\t\twhile (user2group[i] != NULL) {\n\t\t\t\tn++;\n\t\t\t\ti++;\n\t\t\t}\n\t\t\tdid = (int *) malloc((n+1) * sizeof(int)); \n\t\t\ti = 0;\n\t\t\tfor (i=0; i<n; i++) {\n\t\t\t\tdid[i] = 0;\n\t\t\t}\n\t\t}\n\t\ti = 0;\n\t\twhile (user2group[i] != NULL) {\n\t\t\tif (strstr(user2group[i], user) == user2group[i]) {\n\t\t\t\tchar *w = user2group[i] + strlen(user);\n\t\t\t\tif (*w == '.') {\n#if (SMALL_FOOTPRINT > 2)\n\t\t\t\t\tgotgroup = 0;\n#else\n\t\t\t\t\tstruct group* gr = getgrnam(++w);\n\t\t\t\t\tif (! gr) {\n\t\t\t\t\t\trfbLog(\"Invalid group: %s\\n\", w);\n\t\t\t\t\t\tclean_up_exit(1);\n\t\t\t\t\t}\n\t\t\t\t\t*gid = gr->gr_gid;\n\t\t\t\t\tif (! did[i]) {\n\t\t\t\t\t\trfbLog(\"user2uid: using group %s (%d) for %s\\n\",\n\t\t\t\t\t\t    w, (int) *gid, user);\n\t\t\t\t\t\tdid[i] = 1;\n\t\t\t\t\t}\n\t\t\t\t\tgotgroup = 1;\n#endif\n\t\t\t\t}\n\t\t\t}\n\t\t\ti++;\n\t\t}\n\t}\n\n\tif (numerical) {\n\t\tint u = atoi(user);\n\n\t\tif (u < 0) {\n\t\t\treturn;\n\t\t}\n\t\t*uid = (uid_t) u;\n\t}\n\n#if HAVE_PWD_H\n\tif (1) {\n\t\tstruct passwd *pw;\n\t\tif (numerical) {\n\t\t\tpw = getpwuid(*uid);\n\t\t} else {\n\t\t\tpw = getpwnam(user);\n\t\t}\n\t\tif (pw) {\n\t\t\t*uid  = pw->pw_uid;\n\t\t\tif (! gotgroup) {\n\t\t\t\t*gid  = pw->pw_gid;\n\t\t\t}\n\t\t\t*name = pw->pw_name;\t/* n.b. use immediately */\n\t\t\t*home = pw->pw_dir;\n\t\t}\n\t}\n#endif\n}",
    "includes": [
      "#include \"avahi.h\"",
      "#include \"sslhelper.h\"",
      "#include \"remote.h\"",
      "#include \"cursor.h\"",
      "#include \"keyboard.h\"",
      "#include \"inet.h\"",
      "#include \"connections.h\"",
      "#include \"xwrappers.h\"",
      "#include \"sslhelper.h\"",
      "#include \"unixpw.h\"",
      "#include \"screen.h\"",
      "#include \"scan.h\"",
      "#include \"cleanup.h\"",
      "#include \"solid.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void user2uid(char *user, uid_t *uid, gid_t *gid, char **name, char **home);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "getpwnam",
          "args": [
            "user"
          ],
          "line": 349
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getpwuid",
          "args": [
            "*uid"
          ],
          "line": 347
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atoi",
          "args": [
            "user"
          ],
          "line": 335
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"user2uid: using group %s (%d) for %s\\n\"",
            "w",
            "(int) *gid",
            "user"
          ],
          "line": 322
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clean_up_exit",
          "args": [
            "1"
          ],
          "line": 318
        },
        "resolved": true,
        "details": {
          "function_name": "clean_up_exit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/cleanup.c",
          "lines": "151-266",
          "snippet": "void clean_up_exit(int ret) {\n\tstatic int depth = 0;\n\texit_flag = 1;\n\n\tif (depth++ > 2) {\n\t\texit(ret);\n\t}\n\n\tif (icon_mode) {\n\t\tclean_icon_mode();\n\t}\n\n\t/* remove the shm areas: */\n\tclean_shm(0);\n\n\tstop_stunnel();\n\tif (use_openssl) {\n\t\tssl_helper_pid(0, 0);\t/* killall */\n\t}\n\n\tif (ssh_pid > 0) {\n\t\tkill(ssh_pid, SIGTERM);\n\t\tssh_pid = 0;\n\t}\n\n#ifdef MACOSX\n\tif (client_connect_file) {\n\t\tif (strstr(client_connect_file, \"/tmp/x11vnc-macosx-remote\")\n\t\t    == client_connect_file) {\n\t\t\tunlink(client_connect_file);\n\t\t}\n\t}\n\tif (macosx_console) {\n\t\tmacosxCG_fini();\n\t}\n#endif\n\n\tif (pipeinput_fh != NULL) {\n\t\tpclose(pipeinput_fh);\n\t\tpipeinput_fh = NULL;\n\t}\n\n\tshutdown_uinput();\n\n\tif (unix_sock) {\n\t\tif (unix_sock_fd >= 0) {\n\t\t\trfbLog(\"deleting unix sock: %s\\n\", unix_sock);\n\t\t\tclose(unix_sock_fd);\n\t\t\tunix_sock_fd = -1;\n\t\t\tunlink(unix_sock);\n\t\t}\n\t}\n\n\tif (! dpy) {\t/* raw_rb hack */\n\t\tif (rm_flagfile) {\n\t\t\tunlink(rm_flagfile);\n\t\t\trm_flagfile = NULL;\n\t\t}\n\t\texit(ret);\n\t}\n\n\t/* X keyboard cleanups */\n\tdelete_added_keycodes(0);\n\n\t/* remove all created XInput2 devices */\n\tif(use_multipointer)\n\t    removeAllMDs(dpy);\n\n\tif (clear_mods == 1) {\n\t\tclear_modifiers(0);\n\t} else if (clear_mods == 2) {\n\t\tclear_keys();\n\t} else if (clear_mods == 3) {\n\t\tclear_keys();\n\t\tclear_locks();\n\t}\n\n\tif (no_autorepeat) {\n\t\tautorepeat(1, 0);\n\t}\n\tif (use_solid_bg) {\n\t\tsolid_bg(1);\n\t}\n\tif (ncache || ncache0) {\n\t\tkde_no_animate(1);\n\t}\n\tX_LOCK;\n\tXTestDiscard_wr(dpy);\n#if HAVE_LIBXDAMAGE\n\tif (xdamage) {\n\t\tXDamageDestroy(dpy, xdamage);\n\t}\n#endif\n#if HAVE_LIBXTRAP\n\tif (trap_ctx) {\n\t\tXEFreeTC(trap_ctx);\n\t}\n#endif\n\t/* XXX rdpy_ctrl, etc. cannot close w/o blocking */\n\tXCloseDisplay_wr(dpy);\n\tX_UNLOCK;\n\n\tfflush(stderr);\n\n\tif (rm_flagfile) {\n\t\tunlink(rm_flagfile);\n\t\trm_flagfile = NULL;\n\t}\n\n\tif (avahi) {\n\t\tavahi_cleanup();\n\t\tfflush(stderr);\n\t}\n\n\texit(ret);\n}",
          "includes": [
            "#include \"xi2_devices.h\"",
            "#include \"uinput.h\"",
            "#include \"xevents.h\"",
            "#include \"xrecord.h\"",
            "#include \"screen.h\"",
            "#include \"avahi.h\"",
            "#include \"macosxCG.h\"",
            "#include \"macosx.h\"",
            "#include \"connections.h\"",
            "#include \"sslhelper.h\"",
            "#include \"sslcmds.h\"",
            "#include \"unixpw.h\"",
            "#include \"solid.h\"",
            "#include \"gui.h\"",
            "#include \"scan.h\"",
            "#include \"keyboard.h\"",
            "#include \"remote.h\"",
            "#include \"xdamage.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void clean_up_exit(int ret);",
            "int known_sigpipe_mode(char *s);",
            "static int exit_flag = 0;",
            "static void clean_icon_mode(void);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xi2_devices.h\"\n#include \"uinput.h\"\n#include \"xevents.h\"\n#include \"xrecord.h\"\n#include \"screen.h\"\n#include \"avahi.h\"\n#include \"macosxCG.h\"\n#include \"macosx.h\"\n#include \"connections.h\"\n#include \"sslhelper.h\"\n#include \"sslcmds.h\"\n#include \"unixpw.h\"\n#include \"solid.h\"\n#include \"gui.h\"\n#include \"scan.h\"\n#include \"keyboard.h\"\n#include \"remote.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nvoid clean_up_exit(int ret);\nint known_sigpipe_mode(char *s);\nstatic int exit_flag = 0;\nstatic void clean_icon_mode(void);\n\nvoid clean_up_exit(int ret) {\n\tstatic int depth = 0;\n\texit_flag = 1;\n\n\tif (depth++ > 2) {\n\t\texit(ret);\n\t}\n\n\tif (icon_mode) {\n\t\tclean_icon_mode();\n\t}\n\n\t/* remove the shm areas: */\n\tclean_shm(0);\n\n\tstop_stunnel();\n\tif (use_openssl) {\n\t\tssl_helper_pid(0, 0);\t/* killall */\n\t}\n\n\tif (ssh_pid > 0) {\n\t\tkill(ssh_pid, SIGTERM);\n\t\tssh_pid = 0;\n\t}\n\n#ifdef MACOSX\n\tif (client_connect_file) {\n\t\tif (strstr(client_connect_file, \"/tmp/x11vnc-macosx-remote\")\n\t\t    == client_connect_file) {\n\t\t\tunlink(client_connect_file);\n\t\t}\n\t}\n\tif (macosx_console) {\n\t\tmacosxCG_fini();\n\t}\n#endif\n\n\tif (pipeinput_fh != NULL) {\n\t\tpclose(pipeinput_fh);\n\t\tpipeinput_fh = NULL;\n\t}\n\n\tshutdown_uinput();\n\n\tif (unix_sock) {\n\t\tif (unix_sock_fd >= 0) {\n\t\t\trfbLog(\"deleting unix sock: %s\\n\", unix_sock);\n\t\t\tclose(unix_sock_fd);\n\t\t\tunix_sock_fd = -1;\n\t\t\tunlink(unix_sock);\n\t\t}\n\t}\n\n\tif (! dpy) {\t/* raw_rb hack */\n\t\tif (rm_flagfile) {\n\t\t\tunlink(rm_flagfile);\n\t\t\trm_flagfile = NULL;\n\t\t}\n\t\texit(ret);\n\t}\n\n\t/* X keyboard cleanups */\n\tdelete_added_keycodes(0);\n\n\t/* remove all created XInput2 devices */\n\tif(use_multipointer)\n\t    removeAllMDs(dpy);\n\n\tif (clear_mods == 1) {\n\t\tclear_modifiers(0);\n\t} else if (clear_mods == 2) {\n\t\tclear_keys();\n\t} else if (clear_mods == 3) {\n\t\tclear_keys();\n\t\tclear_locks();\n\t}\n\n\tif (no_autorepeat) {\n\t\tautorepeat(1, 0);\n\t}\n\tif (use_solid_bg) {\n\t\tsolid_bg(1);\n\t}\n\tif (ncache || ncache0) {\n\t\tkde_no_animate(1);\n\t}\n\tX_LOCK;\n\tXTestDiscard_wr(dpy);\n#if HAVE_LIBXDAMAGE\n\tif (xdamage) {\n\t\tXDamageDestroy(dpy, xdamage);\n\t}\n#endif\n#if HAVE_LIBXTRAP\n\tif (trap_ctx) {\n\t\tXEFreeTC(trap_ctx);\n\t}\n#endif\n\t/* XXX rdpy_ctrl, etc. cannot close w/o blocking */\n\tXCloseDisplay_wr(dpy);\n\tX_UNLOCK;\n\n\tfflush(stderr);\n\n\tif (rm_flagfile) {\n\t\tunlink(rm_flagfile);\n\t\trm_flagfile = NULL;\n\t}\n\n\tif (avahi) {\n\t\tavahi_cleanup();\n\t\tfflush(stderr);\n\t}\n\n\texit(ret);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"Invalid group: %s\\n\"",
            "w"
          ],
          "line": 317
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getgrnam",
          "args": [
            "++w"
          ],
          "line": 315
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "user"
          ],
          "line": 310
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "user2group[i]",
            "user"
          ],
          "line": 309
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "(n+1) * sizeof(int)"
          ],
          "line": 301
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isdigit",
          "args": [
            "(unsigned char) (*q++)"
          ],
          "line": 284
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"avahi.h\"\n#include \"sslhelper.h\"\n#include \"remote.h\"\n#include \"cursor.h\"\n#include \"keyboard.h\"\n#include \"inet.h\"\n#include \"connections.h\"\n#include \"xwrappers.h\"\n#include \"sslhelper.h\"\n#include \"unixpw.h\"\n#include \"screen.h\"\n#include \"scan.h\"\n#include \"cleanup.h\"\n#include \"solid.h\"\n#include \"x11vnc.h\"\n\nstatic void user2uid(char *user, uid_t *uid, gid_t *gid, char **name, char **home);\n\nstatic void user2uid(char *user, uid_t *uid, gid_t *gid, char **name, char **home) {\n\tint numerical = 1, gotgroup = 0;\n\tchar *q;\n\n\t*uid = (uid_t) -1;\n\t*name = NULL;\n\t*home = NULL;\n\n\tq = user;\n\twhile (*q) {\n\t\tif (! isdigit((unsigned char) (*q++))) {\n\t\t\tnumerical = 0;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (user2group != NULL) {\n\t\tstatic int *did = NULL;\n\t\tint i;\n\n\t\tif (did == NULL) {\n\t\t\tint n = 0;\n\t\t\ti = 0;\n\t\t\twhile (user2group[i] != NULL) {\n\t\t\t\tn++;\n\t\t\t\ti++;\n\t\t\t}\n\t\t\tdid = (int *) malloc((n+1) * sizeof(int)); \n\t\t\ti = 0;\n\t\t\tfor (i=0; i<n; i++) {\n\t\t\t\tdid[i] = 0;\n\t\t\t}\n\t\t}\n\t\ti = 0;\n\t\twhile (user2group[i] != NULL) {\n\t\t\tif (strstr(user2group[i], user) == user2group[i]) {\n\t\t\t\tchar *w = user2group[i] + strlen(user);\n\t\t\t\tif (*w == '.') {\n#if (SMALL_FOOTPRINT > 2)\n\t\t\t\t\tgotgroup = 0;\n#else\n\t\t\t\t\tstruct group* gr = getgrnam(++w);\n\t\t\t\t\tif (! gr) {\n\t\t\t\t\t\trfbLog(\"Invalid group: %s\\n\", w);\n\t\t\t\t\t\tclean_up_exit(1);\n\t\t\t\t\t}\n\t\t\t\t\t*gid = gr->gr_gid;\n\t\t\t\t\tif (! did[i]) {\n\t\t\t\t\t\trfbLog(\"user2uid: using group %s (%d) for %s\\n\",\n\t\t\t\t\t\t    w, (int) *gid, user);\n\t\t\t\t\t\tdid[i] = 1;\n\t\t\t\t\t}\n\t\t\t\t\tgotgroup = 1;\n#endif\n\t\t\t\t}\n\t\t\t}\n\t\t\ti++;\n\t\t}\n\t}\n\n\tif (numerical) {\n\t\tint u = atoi(user);\n\n\t\tif (u < 0) {\n\t\t\treturn;\n\t\t}\n\t\t*uid = (uid_t) u;\n\t}\n\n#if HAVE_PWD_H\n\tif (1) {\n\t\tstruct passwd *pw;\n\t\tif (numerical) {\n\t\t\tpw = getpwuid(*uid);\n\t\t} else {\n\t\t\tpw = getpwnam(user);\n\t\t}\n\t\tif (pw) {\n\t\t\t*uid  = pw->pw_uid;\n\t\t\tif (! gotgroup) {\n\t\t\t\t*gid  = pw->pw_gid;\n\t\t\t}\n\t\t\t*name = pw->pw_name;\t/* n.b. use immediately */\n\t\t\t*home = pw->pw_dir;\n\t\t}\n\t}\n#endif\n}"
  },
  {
    "function_name": "user_list",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/user.c",
    "lines": "251-272",
    "snippet": "static char **user_list(char *user_str) {\n\tint n, i;\n\tchar *p, **list;\n\t\n\tp = user_str;\n\tn = 1;\n\twhile (*p++) {\n\t\tif (*p == ',') {\n\t\t\tn++;\n\t\t}\n\t}\n\tlist = (char **) calloc((n+1)*sizeof(char *), 1);\n\n\tp = strtok(user_str, \",\");\n\ti = 0;\n\twhile (p) {\n\t\tlist[i++] = strdup(p);\n\t\tp = strtok(NULL, \",\");\n\t}\n\tlist[i] = NULL;\n\treturn list;\n}",
    "includes": [
      "#include \"avahi.h\"",
      "#include \"sslhelper.h\"",
      "#include \"remote.h\"",
      "#include \"cursor.h\"",
      "#include \"keyboard.h\"",
      "#include \"inet.h\"",
      "#include \"connections.h\"",
      "#include \"xwrappers.h\"",
      "#include \"sslhelper.h\"",
      "#include \"unixpw.h\"",
      "#include \"screen.h\"",
      "#include \"scan.h\"",
      "#include \"cleanup.h\"",
      "#include \"solid.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static char **user_list(char *user_str);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "strtok",
          "args": [
            "NULL",
            "\",\""
          ],
          "line": 268
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "p"
          ],
          "line": 267
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strtok",
          "args": [
            "user_str",
            "\",\""
          ],
          "line": 264
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "calloc",
          "args": [
            "(n+1)*sizeof(char *)",
            "1"
          ],
          "line": 262
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"avahi.h\"\n#include \"sslhelper.h\"\n#include \"remote.h\"\n#include \"cursor.h\"\n#include \"keyboard.h\"\n#include \"inet.h\"\n#include \"connections.h\"\n#include \"xwrappers.h\"\n#include \"sslhelper.h\"\n#include \"unixpw.h\"\n#include \"screen.h\"\n#include \"scan.h\"\n#include \"cleanup.h\"\n#include \"solid.h\"\n#include \"x11vnc.h\"\n\nstatic char **user_list(char *user_str);\n\nstatic char **user_list(char *user_str) {\n\tint n, i;\n\tchar *p, **list;\n\t\n\tp = user_str;\n\tn = 1;\n\twhile (*p++) {\n\t\tif (*p == ',') {\n\t\t\tn++;\n\t\t}\n\t}\n\tlist = (char **) calloc((n+1)*sizeof(char *), 1);\n\n\tp = strtok(user_str, \",\");\n\ti = 0;\n\twhile (p) {\n\t\tlist[i++] = strdup(p);\n\t\tp = strtok(NULL, \",\");\n\t}\n\tlist[i] = NULL;\n\treturn list;\n}"
  },
  {
    "function_name": "get_login_list",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/user.c",
    "lines": "141-249",
    "snippet": "static char *get_login_list(int with_display) {\n\tchar *out;\n#if HAVE_UTMPX_H\n\tint i, cnt, max = 200, ut_namesize = 32;\n#define DPYMAX 1000\n\tint sawdpy[DPYMAX];\n\tstruct utmpx *utx;\n\n\t/* size based on \"username:999,\" * max */\n\tout = (char *) malloc(max * (ut_namesize+1+3+1) + 1);\n\tout[0] = '\\0';\n\n\tfor (i=0; i < DPYMAX; i++) {\n\t\tsawdpy[i] = 0;\n\t}\n\n\tsetutxent();\n\tcnt = 0;\n\twhile (1) {\n\t\tchar *user, *line, *host, *id;\n\t\tchar tmp[10];\n\t\tint d = -1;\n\t\tutx = getutxent();\n\t\tif (! utx) {\n\t\t\tbreak;\n\t\t}\n\t\tif (utx->ut_type != USER_PROCESS) {\n\t\t\tcontinue;\n\t\t}\n\t\tuser = lblanks(utx->ut_user);\n\t\tif (*user == '\\0') {\n\t\t\tcontinue;\n\t\t}\n\t\tif (strchr(user, ',')) {\n\t\t\tcontinue;\t/* unlikely, but comma is our sep. */\n\t\t}\n\n\t\tline = lblanks(utx->ut_line);\n\t\thost = lblanks(utx->ut_host);\n\t\tid   = lblanks(utx->ut_id);\n\n\t\tif (with_display) {\n\t\t\tif (0 && line[0] != ':' && strcmp(line, \"dtlocal\")) {\n\t\t\t\t/* XXX useful? */\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (line[0] == ':') {\n\t\t\t\tif (sscanf(line, \":%d\", &d) != 1)  {\n\t\t\t\t\td = -1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (d < 0 && host[0] == ':') {\n\t\t\t\tif (sscanf(host, \":%d\", &d) != 1)  {\n\t\t\t\t\td = -1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (d < 0 && id[0] == ':') {\n\t\t\t\tif (sscanf(id, \":%d\", &d) != 1)  {\n\t\t\t\t\td = -1;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (d < 0 || d >= DPYMAX || sawdpy[d]) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tsawdpy[d] = 1;\n\t\t\tsprintf(tmp, \":%d\", d);\n\t\t} else {\n\t\t\t/* try to eliminate repeats */\n\t\t\tint repeat = 0;\n\t\t\tchar *q;\n\n\t\t\tq = out;\n\t\t\twhile ((q = strstr(q, user)) != NULL) {\n\t\t\t\tchar *p = q + strlen(user) + strlen(\":DPY\");\n\t\t\t\tif (q == out || *(q-1) == ',') {\n\t\t\t\t\t/* bounded on left. */\n\t\t\t\t\tif (*p == ',' || *p == '\\0') {\n\t\t\t\t\t\t/* bounded on right. */\n\t\t\t\t\t\trepeat = 1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tq = p;\n\t\t\t}\n\t\t\tif (repeat) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tsprintf(tmp, \":DPY\");\n\t\t}\n\n\t\tif (*out) {\n\t\t\tstrcat(out, \",\");\n\t\t}\n\t\tstrcat(out, user);\n\t\tstrcat(out, tmp);\n\n\t\tcnt++;\n\t\tif (cnt >= max) {\n\t\t\tbreak;\n\t\t}\n\t}\n\tendutxent();\n#else\n\tout = strdup(\"\");\n#endif\n\treturn out;\n}",
    "includes": [
      "#include \"avahi.h\"",
      "#include \"sslhelper.h\"",
      "#include \"remote.h\"",
      "#include \"cursor.h\"",
      "#include \"keyboard.h\"",
      "#include \"inet.h\"",
      "#include \"connections.h\"",
      "#include \"xwrappers.h\"",
      "#include \"sslhelper.h\"",
      "#include \"unixpw.h\"",
      "#include \"screen.h\"",
      "#include \"scan.h\"",
      "#include \"cleanup.h\"",
      "#include \"solid.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [
      "#define DPYMAX 1000"
    ],
    "globals_used": [
      "static char *get_login_list(int with_display);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "\"\""
          ],
          "line": 246
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "endutxent",
          "args": [],
          "line": 244
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcat",
          "args": [
            "out",
            "tmp"
          ],
          "line": 237
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcat",
          "args": [
            "out",
            "user"
          ],
          "line": 236
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcat",
          "args": [
            "out",
            "\",\""
          ],
          "line": 234
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "tmp",
            "\":DPY\""
          ],
          "line": 230
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "\":DPY\""
          ],
          "line": 216
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "user"
          ],
          "line": 216
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "q",
            "user"
          ],
          "line": 215
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "tmp",
            "\":%d\"",
            "d"
          ],
          "line": 208
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sscanf",
          "args": [
            "id",
            "\":%d\"",
            "&d"
          ],
          "line": 199
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sscanf",
          "args": [
            "host",
            "\":%d\"",
            "&d"
          ],
          "line": 194
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sscanf",
          "args": [
            "line",
            "\":%d\"",
            "&d"
          ],
          "line": 189
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "line",
            "\"dtlocal\""
          ],
          "line": 183
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lblanks",
          "args": [
            "utx->ut_id"
          ],
          "line": 180
        },
        "resolved": true,
        "details": {
          "function_name": "lblanks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/util.c",
          "lines": "160-169",
          "snippet": "char *lblanks(char *str) {\n\tchar *p = str;\n\twhile (*p != '\\0') {\n\t\tif (! isspace((unsigned char) (*p))) {\n\t\t\tbreak;\n\t\t}\n\t\tp++;\n\t}\n\treturn p;\n}",
          "includes": [
            "#include \"connections.h\"",
            "#include \"unixpw.h\"",
            "#include \"win_utils.h\"",
            "#include \"cleanup.h\"",
            "#include \"x11vnc.h\"",
            "#include <stdlib.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void lowercase(char *str);",
            "void uppercase(char *str);",
            "char *lblanks(char *str);",
            "void strzero(char *str);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"connections.h\"\n#include \"unixpw.h\"\n#include \"win_utils.h\"\n#include \"cleanup.h\"\n#include \"x11vnc.h\"\n#include <stdlib.h>\n\nvoid lowercase(char *str);\nvoid uppercase(char *str);\nchar *lblanks(char *str);\nvoid strzero(char *str);\n\nchar *lblanks(char *str) {\n\tchar *p = str;\n\twhile (*p != '\\0') {\n\t\tif (! isspace((unsigned char) (*p))) {\n\t\t\tbreak;\n\t\t}\n\t\tp++;\n\t}\n\treturn p;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "user",
            "','"
          ],
          "line": 174
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getutxent",
          "args": [],
          "line": 163
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "setutxent",
          "args": [],
          "line": 157
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "max * (ut_namesize+1+3+1) + 1"
          ],
          "line": 150
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"avahi.h\"\n#include \"sslhelper.h\"\n#include \"remote.h\"\n#include \"cursor.h\"\n#include \"keyboard.h\"\n#include \"inet.h\"\n#include \"connections.h\"\n#include \"xwrappers.h\"\n#include \"sslhelper.h\"\n#include \"unixpw.h\"\n#include \"screen.h\"\n#include \"scan.h\"\n#include \"cleanup.h\"\n#include \"solid.h\"\n#include \"x11vnc.h\"\n\n#define DPYMAX 1000\n\nstatic char *get_login_list(int with_display);\n\nstatic char *get_login_list(int with_display) {\n\tchar *out;\n#if HAVE_UTMPX_H\n\tint i, cnt, max = 200, ut_namesize = 32;\n#define DPYMAX 1000\n\tint sawdpy[DPYMAX];\n\tstruct utmpx *utx;\n\n\t/* size based on \"username:999,\" * max */\n\tout = (char *) malloc(max * (ut_namesize+1+3+1) + 1);\n\tout[0] = '\\0';\n\n\tfor (i=0; i < DPYMAX; i++) {\n\t\tsawdpy[i] = 0;\n\t}\n\n\tsetutxent();\n\tcnt = 0;\n\twhile (1) {\n\t\tchar *user, *line, *host, *id;\n\t\tchar tmp[10];\n\t\tint d = -1;\n\t\tutx = getutxent();\n\t\tif (! utx) {\n\t\t\tbreak;\n\t\t}\n\t\tif (utx->ut_type != USER_PROCESS) {\n\t\t\tcontinue;\n\t\t}\n\t\tuser = lblanks(utx->ut_user);\n\t\tif (*user == '\\0') {\n\t\t\tcontinue;\n\t\t}\n\t\tif (strchr(user, ',')) {\n\t\t\tcontinue;\t/* unlikely, but comma is our sep. */\n\t\t}\n\n\t\tline = lblanks(utx->ut_line);\n\t\thost = lblanks(utx->ut_host);\n\t\tid   = lblanks(utx->ut_id);\n\n\t\tif (with_display) {\n\t\t\tif (0 && line[0] != ':' && strcmp(line, \"dtlocal\")) {\n\t\t\t\t/* XXX useful? */\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (line[0] == ':') {\n\t\t\t\tif (sscanf(line, \":%d\", &d) != 1)  {\n\t\t\t\t\td = -1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (d < 0 && host[0] == ':') {\n\t\t\t\tif (sscanf(host, \":%d\", &d) != 1)  {\n\t\t\t\t\td = -1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (d < 0 && id[0] == ':') {\n\t\t\t\tif (sscanf(id, \":%d\", &d) != 1)  {\n\t\t\t\t\td = -1;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (d < 0 || d >= DPYMAX || sawdpy[d]) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tsawdpy[d] = 1;\n\t\t\tsprintf(tmp, \":%d\", d);\n\t\t} else {\n\t\t\t/* try to eliminate repeats */\n\t\t\tint repeat = 0;\n\t\t\tchar *q;\n\n\t\t\tq = out;\n\t\t\twhile ((q = strstr(q, user)) != NULL) {\n\t\t\t\tchar *p = q + strlen(user) + strlen(\":DPY\");\n\t\t\t\tif (q == out || *(q-1) == ',') {\n\t\t\t\t\t/* bounded on left. */\n\t\t\t\t\tif (*p == ',' || *p == '\\0') {\n\t\t\t\t\t\t/* bounded on right. */\n\t\t\t\t\t\trepeat = 1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tq = p;\n\t\t\t}\n\t\t\tif (repeat) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tsprintf(tmp, \":DPY\");\n\t\t}\n\n\t\tif (*out) {\n\t\t\tstrcat(out, \",\");\n\t\t}\n\t\tstrcat(out, user);\n\t\tstrcat(out, tmp);\n\n\t\tcnt++;\n\t\tif (cnt >= max) {\n\t\t\tbreak;\n\t\t}\n\t}\n\tendutxent();\n#else\n\tout = strdup(\"\");\n#endif\n\treturn out;\n}"
  },
  {
    "function_name": "check_switched_user",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/user.c",
    "lines": "85-138",
    "snippet": "void check_switched_user(void) {\n\tstatic time_t sched_switched_user = 0;\n\tstatic int did_solid = 0;\n\tstatic int did_dummy = 0;\n\tint delay = 15;\n\ttime_t now = time(NULL);\n\n\tif (unixpw_in_progress) return;\n\n\tif (started_as_root == 1 && users_list) {\n\t\ttry_to_switch_users();\n\t\tif (started_as_root == 2) {\n\t\t\t/*\n\t\t\t * schedule the switch_user_tasks() call\n\t\t\t * 15 secs is for piggy desktops to start up.\n\t\t\t * might not be enough for slow machines...\n\t\t\t */\n\t\t\tsched_switched_user = now;\n\t\t\tdid_dummy = 0;\n\t\t\tdid_solid = 0;\n\t\t\t/* add other activities */\n\t\t}\n\t}\n\tif (! sched_switched_user) {\n\t\treturn;\n\t}\n\n\tif (! did_dummy) {\n\t\tswitch_user_task_dummy();\n\t\tdid_dummy = 1;\n\t}\n\tif (! did_solid) {\n\t\tint doit = 0;\n\t\tchar *ss = solid_str;\n\t\tif (now >= sched_switched_user + delay) {\n\t\t\tdoit = 1;\n\t\t} else if (ss && strstr(ss, \"root:\") == ss) {\n\t\t    \tif (now >= sched_switched_user + 3) {\n\t\t\t\tdoit = 1;\n\t\t\t}\n\t\t} else if (strcmp(\"root\", guess_desktop())) {\n\t\t\tusleep(1000 * 1000);\n\t\t\tdoit = 1;\n\t\t}\n\t\tif (doit) {\n\t\t\tswitch_user_task_solid_bg();\n\t\t\tdid_solid = 1;\n\t\t}\n\t}\n\n\tif (did_dummy && did_solid) {\n\t\tsched_switched_user = 0;\n\t}\n}",
    "includes": [
      "#include \"avahi.h\"",
      "#include \"sslhelper.h\"",
      "#include \"remote.h\"",
      "#include \"cursor.h\"",
      "#include \"keyboard.h\"",
      "#include \"inet.h\"",
      "#include \"connections.h\"",
      "#include \"xwrappers.h\"",
      "#include \"sslhelper.h\"",
      "#include \"unixpw.h\"",
      "#include \"screen.h\"",
      "#include \"scan.h\"",
      "#include \"cleanup.h\"",
      "#include \"solid.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "void check_switched_user(void);",
      "static void switch_user_task_dummy(void);",
      "static void switch_user_task_solid_bg(void);",
      "static void try_to_switch_users(void);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "switch_user_task_solid_bg",
          "args": [],
          "line": 130
        },
        "resolved": true,
        "details": {
          "function_name": "switch_user_task_solid_bg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/user.c",
          "lines": "78-83",
          "snippet": "static void switch_user_task_solid_bg(void) {\n\t/* we have switched users, some things to do. */\n\tif (use_solid_bg && client_count) {\n\t\tsolid_bg(0);\n\t}\n}",
          "includes": [
            "#include \"avahi.h\"",
            "#include \"sslhelper.h\"",
            "#include \"remote.h\"",
            "#include \"cursor.h\"",
            "#include \"keyboard.h\"",
            "#include \"inet.h\"",
            "#include \"connections.h\"",
            "#include \"xwrappers.h\"",
            "#include \"sslhelper.h\"",
            "#include \"unixpw.h\"",
            "#include \"screen.h\"",
            "#include \"scan.h\"",
            "#include \"cleanup.h\"",
            "#include \"solid.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void switch_user_task_solid_bg(void);",
            "static int lurk(char **users);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"avahi.h\"\n#include \"sslhelper.h\"\n#include \"remote.h\"\n#include \"cursor.h\"\n#include \"keyboard.h\"\n#include \"inet.h\"\n#include \"connections.h\"\n#include \"xwrappers.h\"\n#include \"sslhelper.h\"\n#include \"unixpw.h\"\n#include \"screen.h\"\n#include \"scan.h\"\n#include \"cleanup.h\"\n#include \"solid.h\"\n#include \"x11vnc.h\"\n\nstatic void switch_user_task_solid_bg(void);\nstatic int lurk(char **users);\n\nstatic void switch_user_task_solid_bg(void) {\n\t/* we have switched users, some things to do. */\n\tif (use_solid_bg && client_count) {\n\t\tsolid_bg(0);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "usleep",
          "args": [
            "1000 * 1000"
          ],
          "line": 126
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "\"root\"",
            "guess_desktop()"
          ],
          "line": 125
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "guess_desktop",
          "args": [],
          "line": 125
        },
        "resolved": true,
        "details": {
          "function_name": "guess_desktop",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/solid.c",
          "lines": "1232-1292",
          "snippet": "char *guess_desktop(void) {\n#if NO_X11\n\tRAWFB_RET(\"root\")\n\treturn \"root\";\n#else\n\tAtom prop;\n\n\tRAWFB_RET(\"root\")\n\n\tif (wmdt_str && *wmdt_str != '\\0') {\n\t\tchar *s = wmdt_str;\n\t\tlowercase(s);\n\t\tif (strstr(s, \"xfce\")) {\n\t\t\treturn \"xfce\";\n\t\t}\n\t\tif (strstr(s, \"gnome\") || strstr(s, \"metacity\")) {\n\t\t\treturn \"gnome\";\n\t\t}\n\t\tif (strstr(s, \"kde\") || strstr(s, \"kwin\")) {\n\t\t\treturn \"kde\";\n\t\t}\n\t\tif (strstr(s, \"cde\")) {\n\t\t\treturn \"cde\";\n\t\t}\n\t\treturn \"root\";\n\t}\n\n\tif (! dpy) {\n\t\treturn \"\";\n\t}\n\n\tprop = XInternAtom(dpy, \"XFCE_DESKTOP_WINDOW\", True);\n\tif (prop != None) return \"xfce\";\n\n\t/* special case windowmaker */\n\tprop = XInternAtom(dpy, \"_WINDOWMAKER_WM_PROTOCOLS\", True);\n\tif (prop != None)  return \"root\";\n\n\tprop = XInternAtom(dpy, \"_WINDOWMAKER_COMMAND\", True);\n\tif (prop != None) return \"root\";\n\n\tprop = XInternAtom(dpy, \"NAUTILUS_DESKTOP_WINDOW_ID\", True);\n\tif (prop != None) return \"gnome\";\n\n\tprop = XInternAtom(dpy, \"KWIN_RUNNING\", True);\n\tif (prop != None) {\n\t\tprop = XInternAtom(dpy, \"_KDE_RUNNING\", True);\n\t\tif (prop != None) {\n\t\t\tprop = XInternAtom(dpy, \"KDE_DESKTOP_WINDOW\", True);\n\t\t\tif (prop != None) return \"kde\";\n\t\t}\n\t}\n\n\tprop = XInternAtom(dpy, \"_MOTIF_WM_INFO\", True);\n\tif (prop != None) {\n\t\tprop = XInternAtom(dpy, \"_DT_WORKSPACE_LIST\", True);\n\t\tif (prop != None) return \"cde\";\n\t}\n\treturn \"root\";\n#endif\t/* NO_X11 */\n}",
          "includes": [
            "#include \"xevents.h\"",
            "#include \"cleanup.h\"",
            "#include \"connections.h\"",
            "#include \"xwrappers.h\"",
            "#include \"win_utils.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "char *guess_desktop(void);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xevents.h\"\n#include \"cleanup.h\"\n#include \"connections.h\"\n#include \"xwrappers.h\"\n#include \"win_utils.h\"\n#include \"x11vnc.h\"\n\nchar *guess_desktop(void);\n\nchar *guess_desktop(void) {\n#if NO_X11\n\tRAWFB_RET(\"root\")\n\treturn \"root\";\n#else\n\tAtom prop;\n\n\tRAWFB_RET(\"root\")\n\n\tif (wmdt_str && *wmdt_str != '\\0') {\n\t\tchar *s = wmdt_str;\n\t\tlowercase(s);\n\t\tif (strstr(s, \"xfce\")) {\n\t\t\treturn \"xfce\";\n\t\t}\n\t\tif (strstr(s, \"gnome\") || strstr(s, \"metacity\")) {\n\t\t\treturn \"gnome\";\n\t\t}\n\t\tif (strstr(s, \"kde\") || strstr(s, \"kwin\")) {\n\t\t\treturn \"kde\";\n\t\t}\n\t\tif (strstr(s, \"cde\")) {\n\t\t\treturn \"cde\";\n\t\t}\n\t\treturn \"root\";\n\t}\n\n\tif (! dpy) {\n\t\treturn \"\";\n\t}\n\n\tprop = XInternAtom(dpy, \"XFCE_DESKTOP_WINDOW\", True);\n\tif (prop != None) return \"xfce\";\n\n\t/* special case windowmaker */\n\tprop = XInternAtom(dpy, \"_WINDOWMAKER_WM_PROTOCOLS\", True);\n\tif (prop != None)  return \"root\";\n\n\tprop = XInternAtom(dpy, \"_WINDOWMAKER_COMMAND\", True);\n\tif (prop != None) return \"root\";\n\n\tprop = XInternAtom(dpy, \"NAUTILUS_DESKTOP_WINDOW_ID\", True);\n\tif (prop != None) return \"gnome\";\n\n\tprop = XInternAtom(dpy, \"KWIN_RUNNING\", True);\n\tif (prop != None) {\n\t\tprop = XInternAtom(dpy, \"_KDE_RUNNING\", True);\n\t\tif (prop != None) {\n\t\t\tprop = XInternAtom(dpy, \"KDE_DESKTOP_WINDOW\", True);\n\t\t\tif (prop != None) return \"kde\";\n\t\t}\n\t}\n\n\tprop = XInternAtom(dpy, \"_MOTIF_WM_INFO\", True);\n\tif (prop != None) {\n\t\tprop = XInternAtom(dpy, \"_DT_WORKSPACE_LIST\", True);\n\t\tif (prop != None) return \"cde\";\n\t}\n\treturn \"root\";\n#endif\t/* NO_X11 */\n}"
        }
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "ss",
            "\"root:\""
          ],
          "line": 121
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "switch_user_task_dummy",
          "args": [],
          "line": 113
        },
        "resolved": true,
        "details": {
          "function_name": "switch_user_task_dummy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/user.c",
          "lines": "75-77",
          "snippet": "static void switch_user_task_dummy(void) {\n\t;\t/* dummy does nothing */\n}",
          "includes": [
            "#include \"avahi.h\"",
            "#include \"sslhelper.h\"",
            "#include \"remote.h\"",
            "#include \"cursor.h\"",
            "#include \"keyboard.h\"",
            "#include \"inet.h\"",
            "#include \"connections.h\"",
            "#include \"xwrappers.h\"",
            "#include \"sslhelper.h\"",
            "#include \"unixpw.h\"",
            "#include \"screen.h\"",
            "#include \"scan.h\"",
            "#include \"cleanup.h\"",
            "#include \"solid.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void switch_user_task_dummy(void);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"avahi.h\"\n#include \"sslhelper.h\"\n#include \"remote.h\"\n#include \"cursor.h\"\n#include \"keyboard.h\"\n#include \"inet.h\"\n#include \"connections.h\"\n#include \"xwrappers.h\"\n#include \"sslhelper.h\"\n#include \"unixpw.h\"\n#include \"screen.h\"\n#include \"scan.h\"\n#include \"cleanup.h\"\n#include \"solid.h\"\n#include \"x11vnc.h\"\n\nstatic void switch_user_task_dummy(void);\n\nstatic void switch_user_task_dummy(void) {\n\t;\t/* dummy does nothing */\n}"
        }
      },
      {
        "call_info": {
          "callee": "try_to_switch_users",
          "args": [],
          "line": 95
        },
        "resolved": true,
        "details": {
          "function_name": "try_to_switch_users",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/user.c",
          "lines": "827-865",
          "snippet": "static void try_to_switch_users(void) {\n\tstatic time_t last_try = 0;\n\ttime_t now = time(NULL);\n\tchar *users, *p;\n\n\tif (getuid() && geteuid()) {\n\t\trfbLog(\"try_to_switch_users: not root\\n\");\n\t\tstarted_as_root = 2;\n\t\treturn;\n\t}\n\tif (!last_try) {\n\t\tlast_try = now;\n\t} else if (now <= last_try + 2) {\n\t\t/* try every 3 secs or so */\n\t\treturn;\n\t}\n\tlast_try = now;\n\n\tusers = strdup(users_list);\n\n\tif (strstr(users, \"guess=\") == users) {\n\t\tif (switch_user(users, 1)) {\n\t\t\tstarted_as_root = 2;\n\t\t}\n\t\tfree(users);\n\t\treturn;\n\t}\n\n\tp = strtok(users, \",\");\n\twhile (p) {\n\t\tif (switch_user(p, 1)) {\n\t\t\tstarted_as_root = 2;\n\t\t\trfbLog(\"try_to_switch_users: now %s\\n\", p);\n\t\t\tbreak;\n\t\t}\n\t\tp = strtok(NULL, \",\");\n\t}\n\tfree(users);\n}",
          "includes": [
            "#include \"avahi.h\"",
            "#include \"sslhelper.h\"",
            "#include \"remote.h\"",
            "#include \"cursor.h\"",
            "#include \"keyboard.h\"",
            "#include \"inet.h\"",
            "#include \"connections.h\"",
            "#include \"xwrappers.h\"",
            "#include \"sslhelper.h\"",
            "#include \"unixpw.h\"",
            "#include \"screen.h\"",
            "#include \"scan.h\"",
            "#include \"cleanup.h\"",
            "#include \"solid.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int lurk(char **users);",
            "static void try_to_switch_users(void);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"avahi.h\"\n#include \"sslhelper.h\"\n#include \"remote.h\"\n#include \"cursor.h\"\n#include \"keyboard.h\"\n#include \"inet.h\"\n#include \"connections.h\"\n#include \"xwrappers.h\"\n#include \"sslhelper.h\"\n#include \"unixpw.h\"\n#include \"screen.h\"\n#include \"scan.h\"\n#include \"cleanup.h\"\n#include \"solid.h\"\n#include \"x11vnc.h\"\n\nstatic int lurk(char **users);\nstatic void try_to_switch_users(void);\n\nstatic void try_to_switch_users(void) {\n\tstatic time_t last_try = 0;\n\ttime_t now = time(NULL);\n\tchar *users, *p;\n\n\tif (getuid() && geteuid()) {\n\t\trfbLog(\"try_to_switch_users: not root\\n\");\n\t\tstarted_as_root = 2;\n\t\treturn;\n\t}\n\tif (!last_try) {\n\t\tlast_try = now;\n\t} else if (now <= last_try + 2) {\n\t\t/* try every 3 secs or so */\n\t\treturn;\n\t}\n\tlast_try = now;\n\n\tusers = strdup(users_list);\n\n\tif (strstr(users, \"guess=\") == users) {\n\t\tif (switch_user(users, 1)) {\n\t\t\tstarted_as_root = 2;\n\t\t}\n\t\tfree(users);\n\t\treturn;\n\t}\n\n\tp = strtok(users, \",\");\n\twhile (p) {\n\t\tif (switch_user(p, 1)) {\n\t\t\tstarted_as_root = 2;\n\t\t\trfbLog(\"try_to_switch_users: now %s\\n\", p);\n\t\t\tbreak;\n\t\t}\n\t\tp = strtok(NULL, \",\");\n\t}\n\tfree(users);\n}"
        }
      },
      {
        "call_info": {
          "callee": "time",
          "args": [
            "NULL"
          ],
          "line": 90
        },
        "resolved": true,
        "details": {
          "function_name": "vnc_redirect_timeout",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/user.c",
          "lines": "1395-1399",
          "snippet": "static void vnc_redirect_timeout (int sig) {\n\twrite(2, \"timeout: no clients connected.\\n\", 31);\n\tif (sig) {};\n\texit(0);\n}",
          "includes": [
            "#include \"avahi.h\"",
            "#include \"sslhelper.h\"",
            "#include \"remote.h\"",
            "#include \"cursor.h\"",
            "#include \"keyboard.h\"",
            "#include \"inet.h\"",
            "#include \"connections.h\"",
            "#include \"xwrappers.h\"",
            "#include \"sslhelper.h\"",
            "#include \"unixpw.h\"",
            "#include \"screen.h\"",
            "#include \"scan.h\"",
            "#include \"cleanup.h\"",
            "#include \"solid.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"avahi.h\"\n#include \"sslhelper.h\"\n#include \"remote.h\"\n#include \"cursor.h\"\n#include \"keyboard.h\"\n#include \"inet.h\"\n#include \"connections.h\"\n#include \"xwrappers.h\"\n#include \"sslhelper.h\"\n#include \"unixpw.h\"\n#include \"screen.h\"\n#include \"scan.h\"\n#include \"cleanup.h\"\n#include \"solid.h\"\n#include \"x11vnc.h\"\n\nstatic void vnc_redirect_timeout (int sig) {\n\twrite(2, \"timeout: no clients connected.\\n\", 31);\n\tif (sig) {};\n\texit(0);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"avahi.h\"\n#include \"sslhelper.h\"\n#include \"remote.h\"\n#include \"cursor.h\"\n#include \"keyboard.h\"\n#include \"inet.h\"\n#include \"connections.h\"\n#include \"xwrappers.h\"\n#include \"sslhelper.h\"\n#include \"unixpw.h\"\n#include \"screen.h\"\n#include \"scan.h\"\n#include \"cleanup.h\"\n#include \"solid.h\"\n#include \"x11vnc.h\"\n\nvoid check_switched_user(void);\nstatic void switch_user_task_dummy(void);\nstatic void switch_user_task_solid_bg(void);\nstatic void try_to_switch_users(void);\n\nvoid check_switched_user(void) {\n\tstatic time_t sched_switched_user = 0;\n\tstatic int did_solid = 0;\n\tstatic int did_dummy = 0;\n\tint delay = 15;\n\ttime_t now = time(NULL);\n\n\tif (unixpw_in_progress) return;\n\n\tif (started_as_root == 1 && users_list) {\n\t\ttry_to_switch_users();\n\t\tif (started_as_root == 2) {\n\t\t\t/*\n\t\t\t * schedule the switch_user_tasks() call\n\t\t\t * 15 secs is for piggy desktops to start up.\n\t\t\t * might not be enough for slow machines...\n\t\t\t */\n\t\t\tsched_switched_user = now;\n\t\t\tdid_dummy = 0;\n\t\t\tdid_solid = 0;\n\t\t\t/* add other activities */\n\t\t}\n\t}\n\tif (! sched_switched_user) {\n\t\treturn;\n\t}\n\n\tif (! did_dummy) {\n\t\tswitch_user_task_dummy();\n\t\tdid_dummy = 1;\n\t}\n\tif (! did_solid) {\n\t\tint doit = 0;\n\t\tchar *ss = solid_str;\n\t\tif (now >= sched_switched_user + delay) {\n\t\t\tdoit = 1;\n\t\t} else if (ss && strstr(ss, \"root:\") == ss) {\n\t\t    \tif (now >= sched_switched_user + 3) {\n\t\t\t\tdoit = 1;\n\t\t\t}\n\t\t} else if (strcmp(\"root\", guess_desktop())) {\n\t\t\tusleep(1000 * 1000);\n\t\t\tdoit = 1;\n\t\t}\n\t\tif (doit) {\n\t\t\tswitch_user_task_solid_bg();\n\t\t\tdid_solid = 1;\n\t\t}\n\t}\n\n\tif (did_dummy && did_solid) {\n\t\tsched_switched_user = 0;\n\t}\n}"
  },
  {
    "function_name": "switch_user_task_solid_bg",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/user.c",
    "lines": "78-83",
    "snippet": "static void switch_user_task_solid_bg(void) {\n\t/* we have switched users, some things to do. */\n\tif (use_solid_bg && client_count) {\n\t\tsolid_bg(0);\n\t}\n}",
    "includes": [
      "#include \"avahi.h\"",
      "#include \"sslhelper.h\"",
      "#include \"remote.h\"",
      "#include \"cursor.h\"",
      "#include \"keyboard.h\"",
      "#include \"inet.h\"",
      "#include \"connections.h\"",
      "#include \"xwrappers.h\"",
      "#include \"sslhelper.h\"",
      "#include \"unixpw.h\"",
      "#include \"screen.h\"",
      "#include \"scan.h\"",
      "#include \"cleanup.h\"",
      "#include \"solid.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void switch_user_task_solid_bg(void);",
      "static int lurk(char **users);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "solid_bg",
          "args": [
            "0"
          ],
          "line": 81
        },
        "resolved": true,
        "details": {
          "function_name": "solid_bg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/solid.c",
          "lines": "1330-1425",
          "snippet": "void solid_bg(int restore) {\n\tstatic int desktop = -1;\n\tstatic int solid_on = 0;\n\tstatic char *prev_str;\n\tchar *dtname, *color;\n\n\tif (started_as_root == 1 && users_list) {\n\t\t/* we are still root, don't try. */\n\t\treturn;\n\t}\n\n\tif (macosx_console) {\n\t\tsolid_macosx(restore);\n\t\treturn;\n\t}\n\n\tRAWFB_RET_VOID\n\n\tif (restore) {\n\t\tif (! solid_on) {\n\t\t\treturn;\n\t\t}\n\t\tif (desktop == 0) {\n\t\t\tsolid_root(NULL);\n\t\t} else if (desktop == 1) {\n\t\t\tsolid_gnome(NULL);\n\t\t} else if (desktop == 2) {\n\t\t\tsolid_kde(NULL);\n\t\t} else if (desktop == 3) {\n\t\t\tsolid_cde(NULL);\n\t\t} else if (desktop == 4) {\n\t\t\tsolid_xfce(NULL);\n\t\t}\n\t\tsolid_on = 0;\n\t\treturn;\n\t}\n\tif (! solid_str) {\n\t\treturn;\n\t}\n\tif (solid_on && !strcmp(prev_str, solid_str)) {\n\t\treturn;\n\t}\n\tif (strstr(solid_str, \"guess:\") == solid_str\n\t    || !strchr(solid_str, ':')) {\n\t\tdtname = guess_desktop();\n\t\trfbLog(\"guessed desktop: %s\\n\", dtname);\n\t} else {\n\t\tif (strstr(solid_str, \"gnome:\") == solid_str) {\n\t\t\tdtname = \"gnome\";\n\t\t} else if (strstr(solid_str, \"kde:\") == solid_str) {\n\t\t\tdtname = \"kde\";\n\t\t} else if (strstr(solid_str, \"cde:\") == solid_str) {\n\t\t\tdtname = \"cde\";\n\t\t} else if (strstr(solid_str, \"xfce:\") == solid_str) {\n\t\t\tdtname = \"xfce\";\n\t\t} else {\n\t\t\tdtname = \"root\";\n\t\t}\n\t}\n\n\tcolor = strchr(solid_str, ':');\n\tif (! color) {\n\t\tcolor = solid_str;\n\t} else {\n\t\tcolor++;\n\t\tif (*color == '\\0') {\n\t\t\tcolor = solid_default;\n\t\t}\n\t}\n\tif (last_color) {\n\t\tfree(last_color);\n\t}\n\tlast_color = strdup(color);\n\n\tif (!strcmp(dtname, \"gnome\")) {\n\t\tdesktop = 1;\n\t\tsolid_gnome(color);\n\t} else if (!strcmp(dtname, \"kde\")) {\n\t\tdesktop = 2;\n\t\tsolid_kde(color);\n\t} else if (!strcmp(dtname, \"cde\")) {\n\t\tdesktop = 3;\n\t\tsolid_cde(color);\n\t} else if (!strcmp(dtname, \"xfce\")) {\n\t\tdesktop = 4;\n\t\tsolid_xfce(color);\n\t} else {\n\t\tdesktop = 0;\n\t\tsolid_root(color);\n\t}\n\tif (prev_str) {\n\t\tfree(prev_str);\n\t}\n\tprev_str = strdup(solid_str);\n\tsolid_on = 1;\n}",
          "includes": [
            "#include \"xevents.h\"",
            "#include \"cleanup.h\"",
            "#include \"connections.h\"",
            "#include \"xwrappers.h\"",
            "#include \"win_utils.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "char *guess_desktop(void);",
            "void solid_bg(int restore);",
            "static void usr_bin_path(int restore);",
            "XImage *solid_root(char *color);",
            "static void solid_cde(char *color);",
            "static void solid_gnome(char *color);",
            "static void solid_kde(char *color);",
            "static void solid_macosx(int restore);",
            "static char *last_color = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xevents.h\"\n#include \"cleanup.h\"\n#include \"connections.h\"\n#include \"xwrappers.h\"\n#include \"win_utils.h\"\n#include \"x11vnc.h\"\n\nchar *guess_desktop(void);\nvoid solid_bg(int restore);\nstatic void usr_bin_path(int restore);\nXImage *solid_root(char *color);\nstatic void solid_cde(char *color);\nstatic void solid_gnome(char *color);\nstatic void solid_kde(char *color);\nstatic void solid_macosx(int restore);\nstatic char *last_color = NULL;\n\nvoid solid_bg(int restore) {\n\tstatic int desktop = -1;\n\tstatic int solid_on = 0;\n\tstatic char *prev_str;\n\tchar *dtname, *color;\n\n\tif (started_as_root == 1 && users_list) {\n\t\t/* we are still root, don't try. */\n\t\treturn;\n\t}\n\n\tif (macosx_console) {\n\t\tsolid_macosx(restore);\n\t\treturn;\n\t}\n\n\tRAWFB_RET_VOID\n\n\tif (restore) {\n\t\tif (! solid_on) {\n\t\t\treturn;\n\t\t}\n\t\tif (desktop == 0) {\n\t\t\tsolid_root(NULL);\n\t\t} else if (desktop == 1) {\n\t\t\tsolid_gnome(NULL);\n\t\t} else if (desktop == 2) {\n\t\t\tsolid_kde(NULL);\n\t\t} else if (desktop == 3) {\n\t\t\tsolid_cde(NULL);\n\t\t} else if (desktop == 4) {\n\t\t\tsolid_xfce(NULL);\n\t\t}\n\t\tsolid_on = 0;\n\t\treturn;\n\t}\n\tif (! solid_str) {\n\t\treturn;\n\t}\n\tif (solid_on && !strcmp(prev_str, solid_str)) {\n\t\treturn;\n\t}\n\tif (strstr(solid_str, \"guess:\") == solid_str\n\t    || !strchr(solid_str, ':')) {\n\t\tdtname = guess_desktop();\n\t\trfbLog(\"guessed desktop: %s\\n\", dtname);\n\t} else {\n\t\tif (strstr(solid_str, \"gnome:\") == solid_str) {\n\t\t\tdtname = \"gnome\";\n\t\t} else if (strstr(solid_str, \"kde:\") == solid_str) {\n\t\t\tdtname = \"kde\";\n\t\t} else if (strstr(solid_str, \"cde:\") == solid_str) {\n\t\t\tdtname = \"cde\";\n\t\t} else if (strstr(solid_str, \"xfce:\") == solid_str) {\n\t\t\tdtname = \"xfce\";\n\t\t} else {\n\t\t\tdtname = \"root\";\n\t\t}\n\t}\n\n\tcolor = strchr(solid_str, ':');\n\tif (! color) {\n\t\tcolor = solid_str;\n\t} else {\n\t\tcolor++;\n\t\tif (*color == '\\0') {\n\t\t\tcolor = solid_default;\n\t\t}\n\t}\n\tif (last_color) {\n\t\tfree(last_color);\n\t}\n\tlast_color = strdup(color);\n\n\tif (!strcmp(dtname, \"gnome\")) {\n\t\tdesktop = 1;\n\t\tsolid_gnome(color);\n\t} else if (!strcmp(dtname, \"kde\")) {\n\t\tdesktop = 2;\n\t\tsolid_kde(color);\n\t} else if (!strcmp(dtname, \"cde\")) {\n\t\tdesktop = 3;\n\t\tsolid_cde(color);\n\t} else if (!strcmp(dtname, \"xfce\")) {\n\t\tdesktop = 4;\n\t\tsolid_xfce(color);\n\t} else {\n\t\tdesktop = 0;\n\t\tsolid_root(color);\n\t}\n\tif (prev_str) {\n\t\tfree(prev_str);\n\t}\n\tprev_str = strdup(solid_str);\n\tsolid_on = 1;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"avahi.h\"\n#include \"sslhelper.h\"\n#include \"remote.h\"\n#include \"cursor.h\"\n#include \"keyboard.h\"\n#include \"inet.h\"\n#include \"connections.h\"\n#include \"xwrappers.h\"\n#include \"sslhelper.h\"\n#include \"unixpw.h\"\n#include \"screen.h\"\n#include \"scan.h\"\n#include \"cleanup.h\"\n#include \"solid.h\"\n#include \"x11vnc.h\"\n\nstatic void switch_user_task_solid_bg(void);\nstatic int lurk(char **users);\n\nstatic void switch_user_task_solid_bg(void) {\n\t/* we have switched users, some things to do. */\n\tif (use_solid_bg && client_count) {\n\t\tsolid_bg(0);\n\t}\n}"
  },
  {
    "function_name": "switch_user_task_dummy",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/user.c",
    "lines": "75-77",
    "snippet": "static void switch_user_task_dummy(void) {\n\t;\t/* dummy does nothing */\n}",
    "includes": [
      "#include \"avahi.h\"",
      "#include \"sslhelper.h\"",
      "#include \"remote.h\"",
      "#include \"cursor.h\"",
      "#include \"keyboard.h\"",
      "#include \"inet.h\"",
      "#include \"connections.h\"",
      "#include \"xwrappers.h\"",
      "#include \"sslhelper.h\"",
      "#include \"unixpw.h\"",
      "#include \"screen.h\"",
      "#include \"scan.h\"",
      "#include \"cleanup.h\"",
      "#include \"solid.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void switch_user_task_dummy(void);"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"avahi.h\"\n#include \"sslhelper.h\"\n#include \"remote.h\"\n#include \"cursor.h\"\n#include \"keyboard.h\"\n#include \"inet.h\"\n#include \"connections.h\"\n#include \"xwrappers.h\"\n#include \"sslhelper.h\"\n#include \"unixpw.h\"\n#include \"screen.h\"\n#include \"scan.h\"\n#include \"cleanup.h\"\n#include \"solid.h\"\n#include \"x11vnc.h\"\n\nstatic void switch_user_task_dummy(void);\n\nstatic void switch_user_task_dummy(void) {\n\t;\t/* dummy does nothing */\n}"
  }
]