[
  {
    "function_name": "zero_fb",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/xinerama.c",
    "lines": "531-561",
    "snippet": "void zero_fb(int x1, int y1, int x2, int y2) {\n\tint pixelsize = bpp/8;\n\tint line, fill = 0, yfac = 1;\n\tchar *dst;\n\n#ifndef NO_NCACHE\n\tif (ncache > 0) {\n\t\tyfac = 1+ncache;\n\t\tif (ncache_xrootpmap) {\n\t\t\tyfac++;\n\t\t}\n\t}\n#endif\n\t\n\tif (x1 < 0 || x2 <= x1 || x2 > dpy_x) {\n\t\treturn;\n\t}\n\tif (y1 < 0 || y2 <= y1 || y2 > yfac * dpy_y) {\n\t\treturn;\n\t}\n\tif (! main_fb) {\n\t\treturn;\n\t}\n\n\tdst = main_fb + y1 * main_bytes_per_line + x1 * pixelsize;\n\tline = y1;\n\twhile (line++ < y2) {\n\t\tmemset(dst, fill, (size_t) (x2 - x1) * pixelsize);\n\t\tdst += main_bytes_per_line;\n\t}\n}",
    "includes": [
      "#include \"scan.h\"",
      "#include \"blackout_t.h\"",
      "#include \"xwrappers.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "void zero_fb(int x1, int y1, int x2, int y2);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "dst",
            "fill",
            "(size_t) (x2 - x1) * pixelsize"
          ],
          "line": 558
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"scan.h\"\n#include \"blackout_t.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nvoid zero_fb(int x1, int y1, int x2, int y2);\n\nvoid zero_fb(int x1, int y1, int x2, int y2) {\n\tint pixelsize = bpp/8;\n\tint line, fill = 0, yfac = 1;\n\tchar *dst;\n\n#ifndef NO_NCACHE\n\tif (ncache > 0) {\n\t\tyfac = 1+ncache;\n\t\tif (ncache_xrootpmap) {\n\t\t\tyfac++;\n\t\t}\n\t}\n#endif\n\t\n\tif (x1 < 0 || x2 <= x1 || x2 > dpy_x) {\n\t\treturn;\n\t}\n\tif (y1 < 0 || y2 <= y1 || y2 > yfac * dpy_y) {\n\t\treturn;\n\t}\n\tif (! main_fb) {\n\t\treturn;\n\t}\n\n\tdst = main_fb + y1 * main_bytes_per_line + x1 * pixelsize;\n\tline = y1;\n\twhile (line++ < y2) {\n\t\tmemset(dst, fill, (size_t) (x2 - x1) * pixelsize);\n\t\tdst += main_bytes_per_line;\n\t}\n}"
  },
  {
    "function_name": "refresh_screen",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/xinerama.c",
    "lines": "517-526",
    "snippet": "void refresh_screen(int push) {\n\tint i;\n\tif (!screen) {\n\t\treturn;\n\t}\n\tmark_rect_as_modified(0, 0, dpy_x, dpy_y, 0);\n\tfor (i=0; i<push; i++) {\n\t\trfbPE(-1);\n\t}\n}",
    "includes": [
      "#include \"scan.h\"",
      "#include \"blackout_t.h\"",
      "#include \"xwrappers.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "void refresh_screen(int push);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "rfbPE",
          "args": [
            "-1"
          ],
          "line": 524
        },
        "resolved": true,
        "details": {
          "function_name": "rfbPE",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/util.c",
          "lines": "561-619",
          "snippet": "int rfbPE(long usec) {\n\tint uip0 = unixpw_in_progress;\n\tstatic int check_rate = -1;\n\tint res = 0;\n\tif (! screen) {\n\t\treturn res;\n\t}\n \tif (unixpw && unixpw_in_progress && !unixpw_in_rfbPE) {\n\t\trfbLog(\"unixpw_in_rfbPE: skipping rfbPE\\n\");\n \t\treturn res;\n \t}\n\n\tif (debug_tiles > 2) {\n\t\tdouble tm = dnow();\n\t\tfprintf(stderr, \"rfbPE(%d)  t: %.4f\\n\",\n\t\t    (int) usec, tm - x11vnc_start);\n\t}\n\n\tif (usec > USEC_MAX) {\n\t\tusec = USEC_MAX;\n\t}\n\tif (! use_threads) {\n\t\trfbBool r;\n\t\tr = rfbProcessEvents(screen, usec);\n\t\tif (r) {\n\t\t\tres = 1;\n\t\t}\n\t}\n\n \tif (unixpw && unixpw_in_progress && !uip0) {\n\t\tif (!unixpw_in_rfbPE) {\n\t\t\trfbLog(\"rfbPE: got new client in non-rfbPE\\n\");\n\t\t\t;\t/* this is new unixpw client  */\n\t\t}\n \t}\n\n\tif (ipv6_listen) {\n\t\tcheck_ipv6_listen(usec);\n\t}\n\tif (unix_sock) {\n\t\tcheck_unix_sock(usec);\n\t}\n\tif (check_rate != 0) {\n\t\tif (check_rate < 0) {\n\t\t\tif (getenv(\"CHECK_RATE\")) {\n\t\t\t\tcheck_rate = 1;\n\t\t\t} else {\n\t\t\t\tcheck_rate = 0;\n\t\t\t}\n\t\t}\n\t\tif (check_rate && !all_input && x11vnc_current < last_client + 45)  {\n\t\t\tcheck_allinput_rate();\n\t\t}\n\t}\n\tif (all_input) {\n\t\tdo_allinput(usec);\n\t}\n\treturn res;\n}",
          "includes": [
            "#include \"connections.h\"",
            "#include \"unixpw.h\"",
            "#include \"win_utils.h\"",
            "#include \"cleanup.h\"",
            "#include \"x11vnc.h\"",
            "#include <stdlib.h>"
          ],
          "macros_used": [
            "#define USEC_MAX 999999\t\t/* libvncsever assumes < 1 second */"
          ],
          "globals_used": [
            "int nfix(int i, int n);",
            "int nabs(int n);",
            "double dnow(void);",
            "int rfbPE(long usec);",
            "void rfbCFD(long usec);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"connections.h\"\n#include \"unixpw.h\"\n#include \"win_utils.h\"\n#include \"cleanup.h\"\n#include \"x11vnc.h\"\n#include <stdlib.h>\n\n#define USEC_MAX 999999\t\t/* libvncsever assumes < 1 second */\n\nint nfix(int i, int n);\nint nabs(int n);\ndouble dnow(void);\nint rfbPE(long usec);\nvoid rfbCFD(long usec);\n\nint rfbPE(long usec) {\n\tint uip0 = unixpw_in_progress;\n\tstatic int check_rate = -1;\n\tint res = 0;\n\tif (! screen) {\n\t\treturn res;\n\t}\n \tif (unixpw && unixpw_in_progress && !unixpw_in_rfbPE) {\n\t\trfbLog(\"unixpw_in_rfbPE: skipping rfbPE\\n\");\n \t\treturn res;\n \t}\n\n\tif (debug_tiles > 2) {\n\t\tdouble tm = dnow();\n\t\tfprintf(stderr, \"rfbPE(%d)  t: %.4f\\n\",\n\t\t    (int) usec, tm - x11vnc_start);\n\t}\n\n\tif (usec > USEC_MAX) {\n\t\tusec = USEC_MAX;\n\t}\n\tif (! use_threads) {\n\t\trfbBool r;\n\t\tr = rfbProcessEvents(screen, usec);\n\t\tif (r) {\n\t\t\tres = 1;\n\t\t}\n\t}\n\n \tif (unixpw && unixpw_in_progress && !uip0) {\n\t\tif (!unixpw_in_rfbPE) {\n\t\t\trfbLog(\"rfbPE: got new client in non-rfbPE\\n\");\n\t\t\t;\t/* this is new unixpw client  */\n\t\t}\n \t}\n\n\tif (ipv6_listen) {\n\t\tcheck_ipv6_listen(usec);\n\t}\n\tif (unix_sock) {\n\t\tcheck_unix_sock(usec);\n\t}\n\tif (check_rate != 0) {\n\t\tif (check_rate < 0) {\n\t\t\tif (getenv(\"CHECK_RATE\")) {\n\t\t\t\tcheck_rate = 1;\n\t\t\t} else {\n\t\t\t\tcheck_rate = 0;\n\t\t\t}\n\t\t}\n\t\tif (check_rate && !all_input && x11vnc_current < last_client + 45)  {\n\t\t\tcheck_allinput_rate();\n\t\t}\n\t}\n\tif (all_input) {\n\t\tdo_allinput(usec);\n\t}\n\treturn res;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mark_rect_as_modified",
          "args": [
            "0",
            "0",
            "dpy_x",
            "dpy_y",
            "0"
          ],
          "line": 522
        },
        "resolved": true,
        "details": {
          "function_name": "mark_rect_as_modified",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/scan.c",
          "lines": "1643-1682",
          "snippet": "void mark_rect_as_modified(int x1, int y1, int x2, int y2, int force) {\n\n\tif (damage_time != 0) {\n\t\t/*\n\t\t * This is not XDAMAGE, rather a hack for testing\n\t\t * where we allow the framebuffer to be corrupted for\n\t\t * damage_delay seconds.\n\t\t */\n\t\tint debug = 0;\n\t\tif (time(NULL) > damage_time + damage_delay) {\n\t\t\tif (! quiet) {\n\t\t\t\trfbLog(\"damaging turned off.\\n\");\n\t\t\t}\n\t\t\tdamage_time = 0;\n\t\t\tdamage_delay = 0;\n\t\t} else {\n\t\t\tif (debug) {\n\t\t\t\trfbLog(\"damaging viewer fb by not marking \"\n\t\t\t\t    \"rect: %d,%d,%d,%d\\n\", x1, y1, x2, y2);\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t}\n\n\n\tif (rfb_fb == main_fb || force) {\n\t\tmark_wrapper(x1, y1, x2, y2);\n\t\treturn;\n\t}\n\n\tif (cmap8to24) {\n\t\tbpp8to24(x1, y1, x2, y2);\n\t}\n\n\tif (scaling) {\n\t\tscale_and_mark_rect(x1, y1, x2, y2, 1);\n\t} else {\n\t\tmark_wrapper(x1, y1, x2, y2);\n\t}\n}",
          "includes": [
            "#include <default8x16.h>",
            "#include \"userinput.h\"",
            "#include \"macosx.h\"",
            "#include \"screen.h\"",
            "#include \"unixpw.h\"",
            "#include \"cleanup.h\"",
            "#include \"pointer.h\"",
            "#include \"screen.h\"",
            "#include \"8to24.h\"",
            "#include \"win_utils.h\"",
            "#include \"xrandr.h\"",
            "#include \"xdamage.h\"",
            "#include \"xwrappers.h\"",
            "#include \"xinerama.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void mark_rect_as_modified(int x1, int y1, int x2, int y2, int force);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <default8x16.h>\n#include \"userinput.h\"\n#include \"macosx.h\"\n#include \"screen.h\"\n#include \"unixpw.h\"\n#include \"cleanup.h\"\n#include \"pointer.h\"\n#include \"screen.h\"\n#include \"8to24.h\"\n#include \"win_utils.h\"\n#include \"xrandr.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"xinerama.h\"\n#include \"x11vnc.h\"\n\nvoid mark_rect_as_modified(int x1, int y1, int x2, int y2, int force);\n\nvoid mark_rect_as_modified(int x1, int y1, int x2, int y2, int force) {\n\n\tif (damage_time != 0) {\n\t\t/*\n\t\t * This is not XDAMAGE, rather a hack for testing\n\t\t * where we allow the framebuffer to be corrupted for\n\t\t * damage_delay seconds.\n\t\t */\n\t\tint debug = 0;\n\t\tif (time(NULL) > damage_time + damage_delay) {\n\t\t\tif (! quiet) {\n\t\t\t\trfbLog(\"damaging turned off.\\n\");\n\t\t\t}\n\t\t\tdamage_time = 0;\n\t\t\tdamage_delay = 0;\n\t\t} else {\n\t\t\tif (debug) {\n\t\t\t\trfbLog(\"damaging viewer fb by not marking \"\n\t\t\t\t    \"rect: %d,%d,%d,%d\\n\", x1, y1, x2, y2);\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t}\n\n\n\tif (rfb_fb == main_fb || force) {\n\t\tmark_wrapper(x1, y1, x2, y2);\n\t\treturn;\n\t}\n\n\tif (cmap8to24) {\n\t\tbpp8to24(x1, y1, x2, y2);\n\t}\n\n\tif (scaling) {\n\t\tscale_and_mark_rect(x1, y1, x2, y2, 1);\n\t} else {\n\t\tmark_wrapper(x1, y1, x2, y2);\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"scan.h\"\n#include \"blackout_t.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nvoid refresh_screen(int push);\n\nvoid refresh_screen(int push) {\n\tint i;\n\tif (!screen) {\n\t\treturn;\n\t}\n\tmark_rect_as_modified(0, 0, dpy_x, dpy_y, 0);\n\tfor (i=0; i<push; i++) {\n\t\trfbPE(-1);\n\t}\n}"
  },
  {
    "function_name": "push_black_screen",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/xinerama.c",
    "lines": "502-515",
    "snippet": "void push_black_screen(int n) {\n\tint Lx = dpy_x, Ly = dpy_y;\n\tif (!screen) {\n\t\treturn;\n\t}\n#ifndef NO_NCACHE\n\tif (ncache > 0) {\n\t\tLy = dpy_y * (1+ncache);\n\t}\n#endif\n\tzero_fb(0, 0, Lx, Ly);\n\tmark_rect_as_modified(0, 0, Lx, Ly, 0);\n\tpush_sleep(n);\n}",
    "includes": [
      "#include \"scan.h\"",
      "#include \"blackout_t.h\"",
      "#include \"xwrappers.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "void push_sleep(int n);",
      "void push_black_screen(int n);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "push_sleep",
          "args": [
            "n"
          ],
          "line": 514
        },
        "resolved": true,
        "details": {
          "function_name": "push_sleep",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/xinerama.c",
          "lines": "489-497",
          "snippet": "void push_sleep(int n) {\n\tint i;\n\tfor (i=0; i<n; i++) {\n\t\trfbPE(-1);\n\t\tif (i != n-1 && defer_update) {\n\t\t\tusleep(defer_update * 1000);\n\t\t}\n\t}\n}",
          "includes": [
            "#include \"scan.h\"",
            "#include \"blackout_t.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void push_sleep(int n);",
            "void push_black_screen(int n);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"scan.h\"\n#include \"blackout_t.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nvoid push_sleep(int n);\nvoid push_black_screen(int n);\n\nvoid push_sleep(int n) {\n\tint i;\n\tfor (i=0; i<n; i++) {\n\t\trfbPE(-1);\n\t\tif (i != n-1 && defer_update) {\n\t\t\tusleep(defer_update * 1000);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "mark_rect_as_modified",
          "args": [
            "0",
            "0",
            "Lx",
            "Ly",
            "0"
          ],
          "line": 513
        },
        "resolved": true,
        "details": {
          "function_name": "mark_rect_as_modified",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/scan.c",
          "lines": "1643-1682",
          "snippet": "void mark_rect_as_modified(int x1, int y1, int x2, int y2, int force) {\n\n\tif (damage_time != 0) {\n\t\t/*\n\t\t * This is not XDAMAGE, rather a hack for testing\n\t\t * where we allow the framebuffer to be corrupted for\n\t\t * damage_delay seconds.\n\t\t */\n\t\tint debug = 0;\n\t\tif (time(NULL) > damage_time + damage_delay) {\n\t\t\tif (! quiet) {\n\t\t\t\trfbLog(\"damaging turned off.\\n\");\n\t\t\t}\n\t\t\tdamage_time = 0;\n\t\t\tdamage_delay = 0;\n\t\t} else {\n\t\t\tif (debug) {\n\t\t\t\trfbLog(\"damaging viewer fb by not marking \"\n\t\t\t\t    \"rect: %d,%d,%d,%d\\n\", x1, y1, x2, y2);\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t}\n\n\n\tif (rfb_fb == main_fb || force) {\n\t\tmark_wrapper(x1, y1, x2, y2);\n\t\treturn;\n\t}\n\n\tif (cmap8to24) {\n\t\tbpp8to24(x1, y1, x2, y2);\n\t}\n\n\tif (scaling) {\n\t\tscale_and_mark_rect(x1, y1, x2, y2, 1);\n\t} else {\n\t\tmark_wrapper(x1, y1, x2, y2);\n\t}\n}",
          "includes": [
            "#include <default8x16.h>",
            "#include \"userinput.h\"",
            "#include \"macosx.h\"",
            "#include \"screen.h\"",
            "#include \"unixpw.h\"",
            "#include \"cleanup.h\"",
            "#include \"pointer.h\"",
            "#include \"screen.h\"",
            "#include \"8to24.h\"",
            "#include \"win_utils.h\"",
            "#include \"xrandr.h\"",
            "#include \"xdamage.h\"",
            "#include \"xwrappers.h\"",
            "#include \"xinerama.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void mark_rect_as_modified(int x1, int y1, int x2, int y2, int force);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <default8x16.h>\n#include \"userinput.h\"\n#include \"macosx.h\"\n#include \"screen.h\"\n#include \"unixpw.h\"\n#include \"cleanup.h\"\n#include \"pointer.h\"\n#include \"screen.h\"\n#include \"8to24.h\"\n#include \"win_utils.h\"\n#include \"xrandr.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"xinerama.h\"\n#include \"x11vnc.h\"\n\nvoid mark_rect_as_modified(int x1, int y1, int x2, int y2, int force);\n\nvoid mark_rect_as_modified(int x1, int y1, int x2, int y2, int force) {\n\n\tif (damage_time != 0) {\n\t\t/*\n\t\t * This is not XDAMAGE, rather a hack for testing\n\t\t * where we allow the framebuffer to be corrupted for\n\t\t * damage_delay seconds.\n\t\t */\n\t\tint debug = 0;\n\t\tif (time(NULL) > damage_time + damage_delay) {\n\t\t\tif (! quiet) {\n\t\t\t\trfbLog(\"damaging turned off.\\n\");\n\t\t\t}\n\t\t\tdamage_time = 0;\n\t\t\tdamage_delay = 0;\n\t\t} else {\n\t\t\tif (debug) {\n\t\t\t\trfbLog(\"damaging viewer fb by not marking \"\n\t\t\t\t    \"rect: %d,%d,%d,%d\\n\", x1, y1, x2, y2);\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t}\n\n\n\tif (rfb_fb == main_fb || force) {\n\t\tmark_wrapper(x1, y1, x2, y2);\n\t\treturn;\n\t}\n\n\tif (cmap8to24) {\n\t\tbpp8to24(x1, y1, x2, y2);\n\t}\n\n\tif (scaling) {\n\t\tscale_and_mark_rect(x1, y1, x2, y2, 1);\n\t} else {\n\t\tmark_wrapper(x1, y1, x2, y2);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "zero_fb",
          "args": [
            "0",
            "0",
            "Lx",
            "Ly"
          ],
          "line": 512
        },
        "resolved": true,
        "details": {
          "function_name": "zero_fb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/xinerama.c",
          "lines": "531-561",
          "snippet": "void zero_fb(int x1, int y1, int x2, int y2) {\n\tint pixelsize = bpp/8;\n\tint line, fill = 0, yfac = 1;\n\tchar *dst;\n\n#ifndef NO_NCACHE\n\tif (ncache > 0) {\n\t\tyfac = 1+ncache;\n\t\tif (ncache_xrootpmap) {\n\t\t\tyfac++;\n\t\t}\n\t}\n#endif\n\t\n\tif (x1 < 0 || x2 <= x1 || x2 > dpy_x) {\n\t\treturn;\n\t}\n\tif (y1 < 0 || y2 <= y1 || y2 > yfac * dpy_y) {\n\t\treturn;\n\t}\n\tif (! main_fb) {\n\t\treturn;\n\t}\n\n\tdst = main_fb + y1 * main_bytes_per_line + x1 * pixelsize;\n\tline = y1;\n\twhile (line++ < y2) {\n\t\tmemset(dst, fill, (size_t) (x2 - x1) * pixelsize);\n\t\tdst += main_bytes_per_line;\n\t}\n}",
          "includes": [
            "#include \"scan.h\"",
            "#include \"blackout_t.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void zero_fb(int x1, int y1, int x2, int y2);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"scan.h\"\n#include \"blackout_t.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nvoid zero_fb(int x1, int y1, int x2, int y2);\n\nvoid zero_fb(int x1, int y1, int x2, int y2) {\n\tint pixelsize = bpp/8;\n\tint line, fill = 0, yfac = 1;\n\tchar *dst;\n\n#ifndef NO_NCACHE\n\tif (ncache > 0) {\n\t\tyfac = 1+ncache;\n\t\tif (ncache_xrootpmap) {\n\t\t\tyfac++;\n\t\t}\n\t}\n#endif\n\t\n\tif (x1 < 0 || x2 <= x1 || x2 > dpy_x) {\n\t\treturn;\n\t}\n\tif (y1 < 0 || y2 <= y1 || y2 > yfac * dpy_y) {\n\t\treturn;\n\t}\n\tif (! main_fb) {\n\t\treturn;\n\t}\n\n\tdst = main_fb + y1 * main_bytes_per_line + x1 * pixelsize;\n\tline = y1;\n\twhile (line++ < y2) {\n\t\tmemset(dst, fill, (size_t) (x2 - x1) * pixelsize);\n\t\tdst += main_bytes_per_line;\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"scan.h\"\n#include \"blackout_t.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nvoid push_sleep(int n);\nvoid push_black_screen(int n);\n\nvoid push_black_screen(int n) {\n\tint Lx = dpy_x, Ly = dpy_y;\n\tif (!screen) {\n\t\treturn;\n\t}\n#ifndef NO_NCACHE\n\tif (ncache > 0) {\n\t\tLy = dpy_y * (1+ncache);\n\t}\n#endif\n\tzero_fb(0, 0, Lx, Ly);\n\tmark_rect_as_modified(0, 0, Lx, Ly, 0);\n\tpush_sleep(n);\n}"
  },
  {
    "function_name": "push_sleep",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/xinerama.c",
    "lines": "489-497",
    "snippet": "void push_sleep(int n) {\n\tint i;\n\tfor (i=0; i<n; i++) {\n\t\trfbPE(-1);\n\t\tif (i != n-1 && defer_update) {\n\t\t\tusleep(defer_update * 1000);\n\t\t}\n\t}\n}",
    "includes": [
      "#include \"scan.h\"",
      "#include \"blackout_t.h\"",
      "#include \"xwrappers.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "void push_sleep(int n);",
      "void push_black_screen(int n);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "usleep",
          "args": [
            "defer_update * 1000"
          ],
          "line": 494
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbPE",
          "args": [
            "-1"
          ],
          "line": 492
        },
        "resolved": true,
        "details": {
          "function_name": "rfbPE",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/util.c",
          "lines": "561-619",
          "snippet": "int rfbPE(long usec) {\n\tint uip0 = unixpw_in_progress;\n\tstatic int check_rate = -1;\n\tint res = 0;\n\tif (! screen) {\n\t\treturn res;\n\t}\n \tif (unixpw && unixpw_in_progress && !unixpw_in_rfbPE) {\n\t\trfbLog(\"unixpw_in_rfbPE: skipping rfbPE\\n\");\n \t\treturn res;\n \t}\n\n\tif (debug_tiles > 2) {\n\t\tdouble tm = dnow();\n\t\tfprintf(stderr, \"rfbPE(%d)  t: %.4f\\n\",\n\t\t    (int) usec, tm - x11vnc_start);\n\t}\n\n\tif (usec > USEC_MAX) {\n\t\tusec = USEC_MAX;\n\t}\n\tif (! use_threads) {\n\t\trfbBool r;\n\t\tr = rfbProcessEvents(screen, usec);\n\t\tif (r) {\n\t\t\tres = 1;\n\t\t}\n\t}\n\n \tif (unixpw && unixpw_in_progress && !uip0) {\n\t\tif (!unixpw_in_rfbPE) {\n\t\t\trfbLog(\"rfbPE: got new client in non-rfbPE\\n\");\n\t\t\t;\t/* this is new unixpw client  */\n\t\t}\n \t}\n\n\tif (ipv6_listen) {\n\t\tcheck_ipv6_listen(usec);\n\t}\n\tif (unix_sock) {\n\t\tcheck_unix_sock(usec);\n\t}\n\tif (check_rate != 0) {\n\t\tif (check_rate < 0) {\n\t\t\tif (getenv(\"CHECK_RATE\")) {\n\t\t\t\tcheck_rate = 1;\n\t\t\t} else {\n\t\t\t\tcheck_rate = 0;\n\t\t\t}\n\t\t}\n\t\tif (check_rate && !all_input && x11vnc_current < last_client + 45)  {\n\t\t\tcheck_allinput_rate();\n\t\t}\n\t}\n\tif (all_input) {\n\t\tdo_allinput(usec);\n\t}\n\treturn res;\n}",
          "includes": [
            "#include \"connections.h\"",
            "#include \"unixpw.h\"",
            "#include \"win_utils.h\"",
            "#include \"cleanup.h\"",
            "#include \"x11vnc.h\"",
            "#include <stdlib.h>"
          ],
          "macros_used": [
            "#define USEC_MAX 999999\t\t/* libvncsever assumes < 1 second */"
          ],
          "globals_used": [
            "int nfix(int i, int n);",
            "int nabs(int n);",
            "double dnow(void);",
            "int rfbPE(long usec);",
            "void rfbCFD(long usec);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"connections.h\"\n#include \"unixpw.h\"\n#include \"win_utils.h\"\n#include \"cleanup.h\"\n#include \"x11vnc.h\"\n#include <stdlib.h>\n\n#define USEC_MAX 999999\t\t/* libvncsever assumes < 1 second */\n\nint nfix(int i, int n);\nint nabs(int n);\ndouble dnow(void);\nint rfbPE(long usec);\nvoid rfbCFD(long usec);\n\nint rfbPE(long usec) {\n\tint uip0 = unixpw_in_progress;\n\tstatic int check_rate = -1;\n\tint res = 0;\n\tif (! screen) {\n\t\treturn res;\n\t}\n \tif (unixpw && unixpw_in_progress && !unixpw_in_rfbPE) {\n\t\trfbLog(\"unixpw_in_rfbPE: skipping rfbPE\\n\");\n \t\treturn res;\n \t}\n\n\tif (debug_tiles > 2) {\n\t\tdouble tm = dnow();\n\t\tfprintf(stderr, \"rfbPE(%d)  t: %.4f\\n\",\n\t\t    (int) usec, tm - x11vnc_start);\n\t}\n\n\tif (usec > USEC_MAX) {\n\t\tusec = USEC_MAX;\n\t}\n\tif (! use_threads) {\n\t\trfbBool r;\n\t\tr = rfbProcessEvents(screen, usec);\n\t\tif (r) {\n\t\t\tres = 1;\n\t\t}\n\t}\n\n \tif (unixpw && unixpw_in_progress && !uip0) {\n\t\tif (!unixpw_in_rfbPE) {\n\t\t\trfbLog(\"rfbPE: got new client in non-rfbPE\\n\");\n\t\t\t;\t/* this is new unixpw client  */\n\t\t}\n \t}\n\n\tif (ipv6_listen) {\n\t\tcheck_ipv6_listen(usec);\n\t}\n\tif (unix_sock) {\n\t\tcheck_unix_sock(usec);\n\t}\n\tif (check_rate != 0) {\n\t\tif (check_rate < 0) {\n\t\t\tif (getenv(\"CHECK_RATE\")) {\n\t\t\t\tcheck_rate = 1;\n\t\t\t} else {\n\t\t\t\tcheck_rate = 0;\n\t\t\t}\n\t\t}\n\t\tif (check_rate && !all_input && x11vnc_current < last_client + 45)  {\n\t\t\tcheck_allinput_rate();\n\t\t}\n\t}\n\tif (all_input) {\n\t\tdo_allinput(usec);\n\t}\n\treturn res;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"scan.h\"\n#include \"blackout_t.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nvoid push_sleep(int n);\nvoid push_black_screen(int n);\n\nvoid push_sleep(int n) {\n\tint i;\n\tfor (i=0; i<n; i++) {\n\t\trfbPE(-1);\n\t\tif (i != n-1 && defer_update) {\n\t\t\tusleep(defer_update * 1000);\n\t\t}\n\t}\n}"
  },
  {
    "function_name": "initialize_blackouts_and_xinerama",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/xinerama.c",
    "lines": "471-487",
    "snippet": "void initialize_blackouts_and_xinerama(void) {\n\n\tblackouts = 0;\n\tblackout_ptr = 0;\n\n\tif (blackout_str != NULL) {\n\t\tinitialize_blackouts(blackout_str);\n\t}\n\tif (xinerama) {\n\t\tinitialize_xinerama();\n\t}\n\tif (blackouts) {\n\t\tblackout_tiles();\n\t\t/* schedule a copy_screen(), now is too early. */\n\t\tdo_copy_screen = 1;\n\t}\n}",
    "includes": [
      "#include \"scan.h\"",
      "#include \"blackout_t.h\"",
      "#include \"xwrappers.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "int blackouts = 0;",
      "void initialize_blackouts_and_xinerama(void);",
      "static void blackout_tiles(void);",
      "static void initialize_xinerama (void);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "blackout_tiles",
          "args": [],
          "line": 483
        },
        "resolved": true,
        "details": {
          "function_name": "blackout_tiles",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/xinerama.c",
          "lines": "142-267",
          "snippet": "static void blackout_tiles(void) {\n\tint tx, ty;\n\tint debug_bo = 0;\n\tif (! blackouts) {\n\t\treturn;\n\t}\n\tif (getenv(\"DEBUG_BLACKOUT\") != NULL) {\n\t\tdebug_bo = 1;\n\t}\n\n\t/* \n\t * to simplify things drop down to single copy mode, etc...\n\t */\n\tsingle_copytile = 1;\n\t/* loop over all tiles. */\n\tfor (ty=0; ty < ntiles_y; ty++) {\n\t\tfor (tx=0; tx < ntiles_x; tx++) {\n\t\t\tsraRegionPtr tile_reg, black_reg;\n\t\t\tsraRect rect;\n\t\t\tsraRectangleIterator *iter;\n\t\t\tint n, b, x1, y1, x2, y2, cnt;\n\n\t\t\t/* tile number and coordinates: */\n\t\t\tn = tx + ty * ntiles_x;\n\t\t\tx1 = tx * tile_x;\n\t\t\ty1 = ty * tile_y;\n\t\t\tx2 = x1 + tile_x;\n\t\t\ty2 = y1 + tile_y;\n\t\t\tif (x2 > dpy_x) {\n\t\t\t\tx2 = dpy_x;\n\t\t\t}\n\t\t\tif (y2 > dpy_y) {\n\t\t\t\ty2 = dpy_y;\n\t\t\t}\n\n\t\t\t/* make regions for the tile and the blackouts: */\n\t\t\tblack_reg = (sraRegionPtr) sraRgnCreate();\n\t\t\ttile_reg  = (sraRegionPtr) sraRgnCreateRect(x1, y1,\n\t\t\t    x2, y2);\n\n\t\t\ttile_blackout[n].cover = 0;\n\t\t\ttile_blackout[n].count = 0;\n\n\t\t\t/* union of blackouts */\n\t\t\tfor (b=0; b < blackouts; b++) {\n\t\t\t\tsraRegionPtr tmp_reg = (sraRegionPtr)\n\t\t\t\t    sraRgnCreateRect(blackr[b].x1,\n\t\t\t\t    blackr[b].y1, blackr[b].x2, blackr[b].y2);\n\n\t\t\t\tsraRgnOr(black_reg, tmp_reg);\n\t\t\t\tsraRgnDestroy(tmp_reg);\n\t\t\t}\n\n\t\t\tif (! sraRgnAnd(black_reg, tile_reg)) {\n\t\t\t\t/*\n\t\t\t\t * no intersection for this tile, so we\n\t\t\t\t * are done.\n\t\t\t\t */\n\t\t\t\tsraRgnDestroy(black_reg);\n\t\t\t\tsraRgnDestroy(tile_reg);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * loop over rectangles that make up the blackout\n\t\t\t * region:\n\t\t\t */\n\t\t\tcnt = 0;\n\t\t\titer = sraRgnGetIterator(black_reg);\n\t\t\twhile (sraRgnIteratorNext(iter, &rect)) {\n\n\t\t\t\t/* make sure x1 < x2 and y1 < y2 */\n\t\t\t\tif (rect.x1 > rect.x2) {\n\t\t\t\t\tint tmp = rect.x2;\n\t\t\t\t\trect.x2 = rect.x1;\n\t\t\t\t\trect.x1 = tmp;\n\t\t\t\t}\n\t\t\t\tif (rect.y1 > rect.y2) {\n\t\t\t\t\tint tmp = rect.y2;\n\t\t\t\t\trect.y2 = rect.y1;\n\t\t\t\t\trect.y1 = tmp;\n\t\t\t\t}\n\n\t\t\t\t/* store coordinates */\n\t\t\t\ttile_blackout[n].bo[cnt].x1 = rect.x1;\n\t\t\t\ttile_blackout[n].bo[cnt].y1 = rect.y1;\n\t\t\t\ttile_blackout[n].bo[cnt].x2 = rect.x2;\n\t\t\t\ttile_blackout[n].bo[cnt].y2 = rect.y2;\n\n\t\t\t\t/* note if the tile is completely obscured */\n\t\t\t\tif (rect.x1 == x1 && rect.y1 == y1 &&\n\t\t\t\t    rect.x2 == x2 && rect.y2 == y2) {\n\t\t\t\t\ttile_blackout[n].cover = 2;\n\t\t\t\t\tif (debug_bo) {\n \t\t\t\t\t\tfprintf(stderr, \"full: %d=%d,%d\"\n\t\t\t\t\t\t    \"  (%d-%d)  (%d-%d)\\n\",\n\t\t\t\t\t\t    n, tx, ty, x1, x2, y1, y2);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\ttile_blackout[n].cover = 1;\n\t\t\t\t\tif (debug_bo) {\n\t\t\t\t\t\tfprintf(stderr, \"part: %d=%d,%d\"\n\t\t\t\t\t\t    \"  (%d-%d)  (%d-%d)\\n\",\n\t\t\t\t\t\t    n, tx, ty, x1, x2, y1, y2);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (++cnt >= BO_MAX) {\n\t\t\t\t\trfbLog(\"too many blackout rectangles \"\n\t\t\t\t\t    \"for tile %d=%d,%d.\\n\", n, tx, ty);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tsraRgnReleaseIterator(iter);\n\n\t\t\tsraRgnDestroy(black_reg);\n\t\t\tsraRgnDestroy(tile_reg);\n\n\t\t\ttile_blackout[n].count = cnt;\n\t\t\tif (debug_bo && cnt > 1) {\n \t\t\t\trfbLog(\"warning: multiple region overlaps[%d] \"\n\t\t\t\t    \"for tile %d=%d,%d.\\n\", cnt, n, tx, ty);\n\t\t\t}\n\t\t}\n\t}\n}",
          "includes": [
            "#include \"scan.h\"",
            "#include \"blackout_t.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "blackout_t blackr[BLACKR_MAX];",
            "tile_blackout_t *tile_blackout;",
            "int blackouts = 0;",
            "void push_sleep(int n);",
            "void push_black_screen(int n);",
            "void zero_fb(int x1, int y1, int x2, int y2);",
            "static void blackout_tiles(void);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"scan.h\"\n#include \"blackout_t.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nblackout_t blackr[BLACKR_MAX];\ntile_blackout_t *tile_blackout;\nint blackouts = 0;\nvoid push_sleep(int n);\nvoid push_black_screen(int n);\nvoid zero_fb(int x1, int y1, int x2, int y2);\nstatic void blackout_tiles(void);\n\nstatic void blackout_tiles(void) {\n\tint tx, ty;\n\tint debug_bo = 0;\n\tif (! blackouts) {\n\t\treturn;\n\t}\n\tif (getenv(\"DEBUG_BLACKOUT\") != NULL) {\n\t\tdebug_bo = 1;\n\t}\n\n\t/* \n\t * to simplify things drop down to single copy mode, etc...\n\t */\n\tsingle_copytile = 1;\n\t/* loop over all tiles. */\n\tfor (ty=0; ty < ntiles_y; ty++) {\n\t\tfor (tx=0; tx < ntiles_x; tx++) {\n\t\t\tsraRegionPtr tile_reg, black_reg;\n\t\t\tsraRect rect;\n\t\t\tsraRectangleIterator *iter;\n\t\t\tint n, b, x1, y1, x2, y2, cnt;\n\n\t\t\t/* tile number and coordinates: */\n\t\t\tn = tx + ty * ntiles_x;\n\t\t\tx1 = tx * tile_x;\n\t\t\ty1 = ty * tile_y;\n\t\t\tx2 = x1 + tile_x;\n\t\t\ty2 = y1 + tile_y;\n\t\t\tif (x2 > dpy_x) {\n\t\t\t\tx2 = dpy_x;\n\t\t\t}\n\t\t\tif (y2 > dpy_y) {\n\t\t\t\ty2 = dpy_y;\n\t\t\t}\n\n\t\t\t/* make regions for the tile and the blackouts: */\n\t\t\tblack_reg = (sraRegionPtr) sraRgnCreate();\n\t\t\ttile_reg  = (sraRegionPtr) sraRgnCreateRect(x1, y1,\n\t\t\t    x2, y2);\n\n\t\t\ttile_blackout[n].cover = 0;\n\t\t\ttile_blackout[n].count = 0;\n\n\t\t\t/* union of blackouts */\n\t\t\tfor (b=0; b < blackouts; b++) {\n\t\t\t\tsraRegionPtr tmp_reg = (sraRegionPtr)\n\t\t\t\t    sraRgnCreateRect(blackr[b].x1,\n\t\t\t\t    blackr[b].y1, blackr[b].x2, blackr[b].y2);\n\n\t\t\t\tsraRgnOr(black_reg, tmp_reg);\n\t\t\t\tsraRgnDestroy(tmp_reg);\n\t\t\t}\n\n\t\t\tif (! sraRgnAnd(black_reg, tile_reg)) {\n\t\t\t\t/*\n\t\t\t\t * no intersection for this tile, so we\n\t\t\t\t * are done.\n\t\t\t\t */\n\t\t\t\tsraRgnDestroy(black_reg);\n\t\t\t\tsraRgnDestroy(tile_reg);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * loop over rectangles that make up the blackout\n\t\t\t * region:\n\t\t\t */\n\t\t\tcnt = 0;\n\t\t\titer = sraRgnGetIterator(black_reg);\n\t\t\twhile (sraRgnIteratorNext(iter, &rect)) {\n\n\t\t\t\t/* make sure x1 < x2 and y1 < y2 */\n\t\t\t\tif (rect.x1 > rect.x2) {\n\t\t\t\t\tint tmp = rect.x2;\n\t\t\t\t\trect.x2 = rect.x1;\n\t\t\t\t\trect.x1 = tmp;\n\t\t\t\t}\n\t\t\t\tif (rect.y1 > rect.y2) {\n\t\t\t\t\tint tmp = rect.y2;\n\t\t\t\t\trect.y2 = rect.y1;\n\t\t\t\t\trect.y1 = tmp;\n\t\t\t\t}\n\n\t\t\t\t/* store coordinates */\n\t\t\t\ttile_blackout[n].bo[cnt].x1 = rect.x1;\n\t\t\t\ttile_blackout[n].bo[cnt].y1 = rect.y1;\n\t\t\t\ttile_blackout[n].bo[cnt].x2 = rect.x2;\n\t\t\t\ttile_blackout[n].bo[cnt].y2 = rect.y2;\n\n\t\t\t\t/* note if the tile is completely obscured */\n\t\t\t\tif (rect.x1 == x1 && rect.y1 == y1 &&\n\t\t\t\t    rect.x2 == x2 && rect.y2 == y2) {\n\t\t\t\t\ttile_blackout[n].cover = 2;\n\t\t\t\t\tif (debug_bo) {\n \t\t\t\t\t\tfprintf(stderr, \"full: %d=%d,%d\"\n\t\t\t\t\t\t    \"  (%d-%d)  (%d-%d)\\n\",\n\t\t\t\t\t\t    n, tx, ty, x1, x2, y1, y2);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\ttile_blackout[n].cover = 1;\n\t\t\t\t\tif (debug_bo) {\n\t\t\t\t\t\tfprintf(stderr, \"part: %d=%d,%d\"\n\t\t\t\t\t\t    \"  (%d-%d)  (%d-%d)\\n\",\n\t\t\t\t\t\t    n, tx, ty, x1, x2, y1, y2);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (++cnt >= BO_MAX) {\n\t\t\t\t\trfbLog(\"too many blackout rectangles \"\n\t\t\t\t\t    \"for tile %d=%d,%d.\\n\", n, tx, ty);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tsraRgnReleaseIterator(iter);\n\n\t\t\tsraRgnDestroy(black_reg);\n\t\t\tsraRgnDestroy(tile_reg);\n\n\t\t\ttile_blackout[n].count = cnt;\n\t\t\tif (debug_bo && cnt > 1) {\n \t\t\t\trfbLog(\"warning: multiple region overlaps[%d] \"\n\t\t\t\t    \"for tile %d=%d,%d.\\n\", cnt, n, tx, ty);\n\t\t\t}\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "initialize_xinerama",
          "args": [],
          "line": 480
        },
        "resolved": true,
        "details": {
          "function_name": "initialize_xinerama",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/xinerama.c",
          "lines": "339-469",
          "snippet": "static void initialize_xinerama (void) {\n#if !HAVE_LIBXINERAMA\n\tif (!raw_fb_str) {\n\t\trfbLog(\"Xinerama: Library libXinerama is not available to determine\\n\");\n\t\trfbLog(\"Xinerama: the head geometries, consider using -blackout\\n\");\n\t\trfbLog(\"Xinerama: if the screen is non-rectangular.\\n\");\n\t}\n#else\n\tXineramaScreenInfo *sc, *xineramas;\n\tsraRegionPtr black_region, tmp_region;\n\tsraRectangleIterator *iter;\n\tsraRect rect;\n\tchar *bstr, *tstr;\n\tint ev, er, i, n, rcnt;\n\n\tRAWFB_RET_VOID\n\n\tX_LOCK;\n\tif (! XineramaQueryExtension(dpy, &ev, &er)) {\n\t\tif (verbose) {\n\t\t\trfbLog(\"Xinerama: disabling: display does not support it.\\n\");\n\t\t}\n\t\txinerama = 0;\n\t\txinerama_present = 0;\n\t\tX_UNLOCK;\n\t\treturn;\n\t}\n\tif (! XineramaIsActive(dpy)) {\n\t\t/* n.b. change to XineramaActive(dpy, window) someday */\n\t\tif (verbose) {\n\t\t\trfbLog(\"Xinerama: disabling: not active on display.\\n\");\n\t\t}\n\t\txinerama = 0;\n\t\txinerama_present = 0;\n\t\tX_UNLOCK;\n\t\treturn;\n\t}\n\txinerama_present = 1;\n\trfbLog(\"\\n\");\n\trfbLog(\"Xinerama is present and active (e.g. multi-head).\\n\");\n\n\t/* n.b. change to XineramaGetData() someday */\n\txineramas = XineramaQueryScreens(dpy, &n);\n\trfbLog(\"Xinerama: number of sub-screens: %d\\n\", n);\n\n\tif (! use_xwarppointer && ! got_noxwarppointer && n > 1) {\n\t\trfbLog(\"Xinerama: enabling -xwarppointer mode to try to correct\\n\");\n\t\trfbLog(\"Xinerama: mouse pointer motion. XTEST+XINERAMA bug.\\n\");\n\t\trfbLog(\"Xinerama: Use -noxwarppointer to force XTEST.\\n\");\n\t\tuse_xwarppointer = 1;\n\t}\n\n\tif (n == 1) {\n\t\trfbLog(\"Xinerama: no blackouts needed (only one sub-screen)\\n\");\n\t\trfbLog(\"\\n\");\n\t\tXFree_wr(xineramas);\n\t\tX_UNLOCK;\n\t\treturn;\t\t/* must be OK w/o change */\n\t}\n\n\tblack_region = sraRgnCreateRect(0, 0, dpy_x, dpy_y);\n\n\tsc = xineramas;\n\tfor (i=0; i<n; i++) {\n\t\tint x, y, w, h;\n\t\t\n\t\tx = sc->x_org;\n\t\ty = sc->y_org;\n\t\tw = sc->width;\n\t\th = sc->height;\n\n\t\trfbLog(\"Xinerama: sub-screen[%d]  %dx%d+%d+%d\\n\", i, w, h, x, y);\n\n\t\ttmp_region = sraRgnCreateRect(x, y, x + w, y + h);\n\n\t\tsraRgnSubtract(black_region, tmp_region);\n\t\tsraRgnDestroy(tmp_region);\n\t\tsc++;\n\t}\n\tXFree_wr(xineramas);\n\tX_UNLOCK;\n\n\n\tif (sraRgnEmpty(black_region)) {\n\t\trfbLog(\"Xinerama: no blackouts needed (screen fills\"\n\t\t    \" rectangle)\\n\");\n\t\trfbLog(\"\\n\");\n\t\tsraRgnDestroy(black_region);\n\t\treturn;\n\t}\n\tif (did_xinerama_clip) {\n\t\trfbLog(\"Xinerama: no blackouts due to -clip xinerama.\\n\");\n\t\treturn;\n\t}\n\n\t/* max len is 10000x10000+10000+10000 (23 chars) per geometry */\n\trcnt = (int) sraRgnCountRects(black_region);\n\tbstr = (char *) malloc(30 * (rcnt+1));\n\ttstr = (char *) malloc(30);\n\tbstr[0] = '\\0';\n\n\titer = sraRgnGetIterator(black_region);\n\twhile (sraRgnIteratorNext(iter, &rect)) {\n\t\tint x, y, w, h;\n\n\t\t/* make sure x1 < x2 and y1 < y2 */\n\t\tif (rect.x1 > rect.x2) {\n\t\t\tint tmp = rect.x2;\n\t\t\trect.x2 = rect.x1;\n\t\t\trect.x1 = tmp;\n\t\t}\n\t\tif (rect.y1 > rect.y2) {\n\t\t\tint tmp = rect.y2;\n\t\t\trect.y2 = rect.y1;\n\t\t\trect.y1 = tmp;\n\t\t}\n\t\tx = rect.x1;\n\t\ty = rect.y1;\n\t\tw = rect.x2 - x;\n\t\th = rect.y2 - y;\n\t\tsprintf(tstr, \"%dx%d+%d+%d,\", w, h, x, y);\n\t\tstrcat(bstr, tstr);\n\t}\n\tsraRgnReleaseIterator(iter);\n\tinitialize_blackouts(bstr);\n\trfbLog(\"\\n\");\n\n\tfree(bstr);\n\tfree(tstr);\n#endif\n}",
          "includes": [
            "#include \"scan.h\"",
            "#include \"blackout_t.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int blackouts = 0;",
            "void push_sleep(int n);",
            "void push_black_screen(int n);",
            "void zero_fb(int x1, int y1, int x2, int y2);",
            "static void initialize_xinerama (void);",
            "static int did_xinerama_clip = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"scan.h\"\n#include \"blackout_t.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nint blackouts = 0;\nvoid push_sleep(int n);\nvoid push_black_screen(int n);\nvoid zero_fb(int x1, int y1, int x2, int y2);\nstatic void initialize_xinerama (void);\nstatic int did_xinerama_clip = 0;\n\nstatic void initialize_xinerama (void) {\n#if !HAVE_LIBXINERAMA\n\tif (!raw_fb_str) {\n\t\trfbLog(\"Xinerama: Library libXinerama is not available to determine\\n\");\n\t\trfbLog(\"Xinerama: the head geometries, consider using -blackout\\n\");\n\t\trfbLog(\"Xinerama: if the screen is non-rectangular.\\n\");\n\t}\n#else\n\tXineramaScreenInfo *sc, *xineramas;\n\tsraRegionPtr black_region, tmp_region;\n\tsraRectangleIterator *iter;\n\tsraRect rect;\n\tchar *bstr, *tstr;\n\tint ev, er, i, n, rcnt;\n\n\tRAWFB_RET_VOID\n\n\tX_LOCK;\n\tif (! XineramaQueryExtension(dpy, &ev, &er)) {\n\t\tif (verbose) {\n\t\t\trfbLog(\"Xinerama: disabling: display does not support it.\\n\");\n\t\t}\n\t\txinerama = 0;\n\t\txinerama_present = 0;\n\t\tX_UNLOCK;\n\t\treturn;\n\t}\n\tif (! XineramaIsActive(dpy)) {\n\t\t/* n.b. change to XineramaActive(dpy, window) someday */\n\t\tif (verbose) {\n\t\t\trfbLog(\"Xinerama: disabling: not active on display.\\n\");\n\t\t}\n\t\txinerama = 0;\n\t\txinerama_present = 0;\n\t\tX_UNLOCK;\n\t\treturn;\n\t}\n\txinerama_present = 1;\n\trfbLog(\"\\n\");\n\trfbLog(\"Xinerama is present and active (e.g. multi-head).\\n\");\n\n\t/* n.b. change to XineramaGetData() someday */\n\txineramas = XineramaQueryScreens(dpy, &n);\n\trfbLog(\"Xinerama: number of sub-screens: %d\\n\", n);\n\n\tif (! use_xwarppointer && ! got_noxwarppointer && n > 1) {\n\t\trfbLog(\"Xinerama: enabling -xwarppointer mode to try to correct\\n\");\n\t\trfbLog(\"Xinerama: mouse pointer motion. XTEST+XINERAMA bug.\\n\");\n\t\trfbLog(\"Xinerama: Use -noxwarppointer to force XTEST.\\n\");\n\t\tuse_xwarppointer = 1;\n\t}\n\n\tif (n == 1) {\n\t\trfbLog(\"Xinerama: no blackouts needed (only one sub-screen)\\n\");\n\t\trfbLog(\"\\n\");\n\t\tXFree_wr(xineramas);\n\t\tX_UNLOCK;\n\t\treturn;\t\t/* must be OK w/o change */\n\t}\n\n\tblack_region = sraRgnCreateRect(0, 0, dpy_x, dpy_y);\n\n\tsc = xineramas;\n\tfor (i=0; i<n; i++) {\n\t\tint x, y, w, h;\n\t\t\n\t\tx = sc->x_org;\n\t\ty = sc->y_org;\n\t\tw = sc->width;\n\t\th = sc->height;\n\n\t\trfbLog(\"Xinerama: sub-screen[%d]  %dx%d+%d+%d\\n\", i, w, h, x, y);\n\n\t\ttmp_region = sraRgnCreateRect(x, y, x + w, y + h);\n\n\t\tsraRgnSubtract(black_region, tmp_region);\n\t\tsraRgnDestroy(tmp_region);\n\t\tsc++;\n\t}\n\tXFree_wr(xineramas);\n\tX_UNLOCK;\n\n\n\tif (sraRgnEmpty(black_region)) {\n\t\trfbLog(\"Xinerama: no blackouts needed (screen fills\"\n\t\t    \" rectangle)\\n\");\n\t\trfbLog(\"\\n\");\n\t\tsraRgnDestroy(black_region);\n\t\treturn;\n\t}\n\tif (did_xinerama_clip) {\n\t\trfbLog(\"Xinerama: no blackouts due to -clip xinerama.\\n\");\n\t\treturn;\n\t}\n\n\t/* max len is 10000x10000+10000+10000 (23 chars) per geometry */\n\trcnt = (int) sraRgnCountRects(black_region);\n\tbstr = (char *) malloc(30 * (rcnt+1));\n\ttstr = (char *) malloc(30);\n\tbstr[0] = '\\0';\n\n\titer = sraRgnGetIterator(black_region);\n\twhile (sraRgnIteratorNext(iter, &rect)) {\n\t\tint x, y, w, h;\n\n\t\t/* make sure x1 < x2 and y1 < y2 */\n\t\tif (rect.x1 > rect.x2) {\n\t\t\tint tmp = rect.x2;\n\t\t\trect.x2 = rect.x1;\n\t\t\trect.x1 = tmp;\n\t\t}\n\t\tif (rect.y1 > rect.y2) {\n\t\t\tint tmp = rect.y2;\n\t\t\trect.y2 = rect.y1;\n\t\t\trect.y1 = tmp;\n\t\t}\n\t\tx = rect.x1;\n\t\ty = rect.y1;\n\t\tw = rect.x2 - x;\n\t\th = rect.y2 - y;\n\t\tsprintf(tstr, \"%dx%d+%d+%d,\", w, h, x, y);\n\t\tstrcat(bstr, tstr);\n\t}\n\tsraRgnReleaseIterator(iter);\n\tinitialize_blackouts(bstr);\n\trfbLog(\"\\n\");\n\n\tfree(bstr);\n\tfree(tstr);\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "initialize_blackouts",
          "args": [
            "blackout_str"
          ],
          "line": 477
        },
        "resolved": true,
        "details": {
          "function_name": "initialize_blackouts",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/xinerama.c",
          "lines": "67-135",
          "snippet": "static void initialize_blackouts(char *list) {\n\tchar *p, *blist = strdup(list);\n\tint x, y, X, Y, h, w, t;\n\n\tp = strtok(blist, \", \\t\");\n\twhile (p) {\n\t\tif (!strcmp(\"noptr\", p)) {\n\t\t\tblackout_ptr = 1;\n\t\t\trfbLog(\"pointer will be blocked from blackout \"\n\t\t\t    \"regions\\n\");\n\t\t\tp = strtok(NULL, \", \\t\");\n\t\t\tcontinue;\n\t\t}\n\t\tif (! parse_geom(p, &w, &h, &x, &y, dpy_x, dpy_y)) {\n\t\t\tif (*p != '\\0') {\n\t\t\t\trfbLog(\"skipping invalid geometry: %s\\n\", p);\n\t\t\t}\n\t\t\tp = strtok(NULL, \", \\t\");\n\t\t\tcontinue;\n\t\t}\n\t\tw = nabs(w);\n\t\th = nabs(h);\n\t\tx = nfix(x, dpy_x);\n\t\ty = nfix(y, dpy_y);\n\t\tX = x + w;\n\t\tY = y + h;\n\t\tX = nfix(X, dpy_x+1);\n\t\tY = nfix(Y, dpy_y+1);\n\t\tif (x > X) {\n\t\t\tt = X; X = x; x = t;\n\t\t}\n\t\tif (y > Y) {\n\t\t\tt = Y; Y = y; y = t;\n\t\t}\n\n\t\t/* take clipping region into account */\n\t\tx = nfix(x - coff_x, wdpy_x);\n\t\tX = nfix(X - coff_x, wdpy_x);\n\t\ty = nfix(y - coff_y, wdpy_y);\n\t\tY = nfix(Y - coff_y, wdpy_y);\n\n\t\tif (x < 0 || x > dpy_x || y < 0 || y > dpy_y ||\n\t\t    X < 0 || X > dpy_x || Y < 0 || Y > dpy_y ||\n\t\t    x == X || y == Y) {\n\t\t\trfbLog(\"skipping invalid blackout geometry: %s x=\"\n\t\t\t    \"%d-%d,y=%d-%d,w=%d,h=%d\\n\", p, x, X, y, Y, w, h);\n\t\t} else {\n\t\t\trfbLog(\"blackout rect: %s: x=%d-%d y=%d-%d\\n\", p,\n\t\t\t    x, X, y, Y);\n\n\t\t\t/*\n\t\t\t * note that the black out is x1 <= x but x < x2\n\t\t\t * for the region. i.e. the x2, y2 are outside\n\t\t\t * by 1 pixel. \n\t\t\t */\n\t\t\tblackr[blackouts].x1 = x;\n\t\t\tblackr[blackouts].y1 = y;\n\t\t\tblackr[blackouts].x2 = X;\n\t\t\tblackr[blackouts].y2 = Y;\n\t\t\tblackouts++;\n\t\t\tif (blackouts >= BLACKR_MAX) {\n\t\t\t\trfbLog(\"too many blackouts: %d\\n\", blackouts);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tp = strtok(NULL, \", \\t\");\n\t}\n\tfree(blist);\n}",
          "includes": [
            "#include \"scan.h\"",
            "#include \"blackout_t.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [
            "#define BLACKR_MAX 100"
          ],
          "globals_used": [
            "blackout_t blackr[BLACKR_MAX];",
            "int blackouts = 0;",
            "void push_sleep(int n);",
            "void push_black_screen(int n);",
            "void zero_fb(int x1, int y1, int x2, int y2);",
            "static void initialize_blackouts(char *list);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"scan.h\"\n#include \"blackout_t.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\n#define BLACKR_MAX 100\n\nblackout_t blackr[BLACKR_MAX];\nint blackouts = 0;\nvoid push_sleep(int n);\nvoid push_black_screen(int n);\nvoid zero_fb(int x1, int y1, int x2, int y2);\nstatic void initialize_blackouts(char *list);\n\nstatic void initialize_blackouts(char *list) {\n\tchar *p, *blist = strdup(list);\n\tint x, y, X, Y, h, w, t;\n\n\tp = strtok(blist, \", \\t\");\n\twhile (p) {\n\t\tif (!strcmp(\"noptr\", p)) {\n\t\t\tblackout_ptr = 1;\n\t\t\trfbLog(\"pointer will be blocked from blackout \"\n\t\t\t    \"regions\\n\");\n\t\t\tp = strtok(NULL, \", \\t\");\n\t\t\tcontinue;\n\t\t}\n\t\tif (! parse_geom(p, &w, &h, &x, &y, dpy_x, dpy_y)) {\n\t\t\tif (*p != '\\0') {\n\t\t\t\trfbLog(\"skipping invalid geometry: %s\\n\", p);\n\t\t\t}\n\t\t\tp = strtok(NULL, \", \\t\");\n\t\t\tcontinue;\n\t\t}\n\t\tw = nabs(w);\n\t\th = nabs(h);\n\t\tx = nfix(x, dpy_x);\n\t\ty = nfix(y, dpy_y);\n\t\tX = x + w;\n\t\tY = y + h;\n\t\tX = nfix(X, dpy_x+1);\n\t\tY = nfix(Y, dpy_y+1);\n\t\tif (x > X) {\n\t\t\tt = X; X = x; x = t;\n\t\t}\n\t\tif (y > Y) {\n\t\t\tt = Y; Y = y; y = t;\n\t\t}\n\n\t\t/* take clipping region into account */\n\t\tx = nfix(x - coff_x, wdpy_x);\n\t\tX = nfix(X - coff_x, wdpy_x);\n\t\ty = nfix(y - coff_y, wdpy_y);\n\t\tY = nfix(Y - coff_y, wdpy_y);\n\n\t\tif (x < 0 || x > dpy_x || y < 0 || y > dpy_y ||\n\t\t    X < 0 || X > dpy_x || Y < 0 || Y > dpy_y ||\n\t\t    x == X || y == Y) {\n\t\t\trfbLog(\"skipping invalid blackout geometry: %s x=\"\n\t\t\t    \"%d-%d,y=%d-%d,w=%d,h=%d\\n\", p, x, X, y, Y, w, h);\n\t\t} else {\n\t\t\trfbLog(\"blackout rect: %s: x=%d-%d y=%d-%d\\n\", p,\n\t\t\t    x, X, y, Y);\n\n\t\t\t/*\n\t\t\t * note that the black out is x1 <= x but x < x2\n\t\t\t * for the region. i.e. the x2, y2 are outside\n\t\t\t * by 1 pixel. \n\t\t\t */\n\t\t\tblackr[blackouts].x1 = x;\n\t\t\tblackr[blackouts].y1 = y;\n\t\t\tblackr[blackouts].x2 = X;\n\t\t\tblackr[blackouts].y2 = Y;\n\t\t\tblackouts++;\n\t\t\tif (blackouts >= BLACKR_MAX) {\n\t\t\t\trfbLog(\"too many blackouts: %d\\n\", blackouts);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tp = strtok(NULL, \", \\t\");\n\t}\n\tfree(blist);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"scan.h\"\n#include \"blackout_t.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nint blackouts = 0;\nvoid initialize_blackouts_and_xinerama(void);\nstatic void blackout_tiles(void);\nstatic void initialize_xinerama (void);\n\nvoid initialize_blackouts_and_xinerama(void) {\n\n\tblackouts = 0;\n\tblackout_ptr = 0;\n\n\tif (blackout_str != NULL) {\n\t\tinitialize_blackouts(blackout_str);\n\t}\n\tif (xinerama) {\n\t\tinitialize_xinerama();\n\t}\n\tif (blackouts) {\n\t\tblackout_tiles();\n\t\t/* schedule a copy_screen(), now is too early. */\n\t\tdo_copy_screen = 1;\n\t}\n}"
  },
  {
    "function_name": "initialize_xinerama",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/xinerama.c",
    "lines": "339-469",
    "snippet": "static void initialize_xinerama (void) {\n#if !HAVE_LIBXINERAMA\n\tif (!raw_fb_str) {\n\t\trfbLog(\"Xinerama: Library libXinerama is not available to determine\\n\");\n\t\trfbLog(\"Xinerama: the head geometries, consider using -blackout\\n\");\n\t\trfbLog(\"Xinerama: if the screen is non-rectangular.\\n\");\n\t}\n#else\n\tXineramaScreenInfo *sc, *xineramas;\n\tsraRegionPtr black_region, tmp_region;\n\tsraRectangleIterator *iter;\n\tsraRect rect;\n\tchar *bstr, *tstr;\n\tint ev, er, i, n, rcnt;\n\n\tRAWFB_RET_VOID\n\n\tX_LOCK;\n\tif (! XineramaQueryExtension(dpy, &ev, &er)) {\n\t\tif (verbose) {\n\t\t\trfbLog(\"Xinerama: disabling: display does not support it.\\n\");\n\t\t}\n\t\txinerama = 0;\n\t\txinerama_present = 0;\n\t\tX_UNLOCK;\n\t\treturn;\n\t}\n\tif (! XineramaIsActive(dpy)) {\n\t\t/* n.b. change to XineramaActive(dpy, window) someday */\n\t\tif (verbose) {\n\t\t\trfbLog(\"Xinerama: disabling: not active on display.\\n\");\n\t\t}\n\t\txinerama = 0;\n\t\txinerama_present = 0;\n\t\tX_UNLOCK;\n\t\treturn;\n\t}\n\txinerama_present = 1;\n\trfbLog(\"\\n\");\n\trfbLog(\"Xinerama is present and active (e.g. multi-head).\\n\");\n\n\t/* n.b. change to XineramaGetData() someday */\n\txineramas = XineramaQueryScreens(dpy, &n);\n\trfbLog(\"Xinerama: number of sub-screens: %d\\n\", n);\n\n\tif (! use_xwarppointer && ! got_noxwarppointer && n > 1) {\n\t\trfbLog(\"Xinerama: enabling -xwarppointer mode to try to correct\\n\");\n\t\trfbLog(\"Xinerama: mouse pointer motion. XTEST+XINERAMA bug.\\n\");\n\t\trfbLog(\"Xinerama: Use -noxwarppointer to force XTEST.\\n\");\n\t\tuse_xwarppointer = 1;\n\t}\n\n\tif (n == 1) {\n\t\trfbLog(\"Xinerama: no blackouts needed (only one sub-screen)\\n\");\n\t\trfbLog(\"\\n\");\n\t\tXFree_wr(xineramas);\n\t\tX_UNLOCK;\n\t\treturn;\t\t/* must be OK w/o change */\n\t}\n\n\tblack_region = sraRgnCreateRect(0, 0, dpy_x, dpy_y);\n\n\tsc = xineramas;\n\tfor (i=0; i<n; i++) {\n\t\tint x, y, w, h;\n\t\t\n\t\tx = sc->x_org;\n\t\ty = sc->y_org;\n\t\tw = sc->width;\n\t\th = sc->height;\n\n\t\trfbLog(\"Xinerama: sub-screen[%d]  %dx%d+%d+%d\\n\", i, w, h, x, y);\n\n\t\ttmp_region = sraRgnCreateRect(x, y, x + w, y + h);\n\n\t\tsraRgnSubtract(black_region, tmp_region);\n\t\tsraRgnDestroy(tmp_region);\n\t\tsc++;\n\t}\n\tXFree_wr(xineramas);\n\tX_UNLOCK;\n\n\n\tif (sraRgnEmpty(black_region)) {\n\t\trfbLog(\"Xinerama: no blackouts needed (screen fills\"\n\t\t    \" rectangle)\\n\");\n\t\trfbLog(\"\\n\");\n\t\tsraRgnDestroy(black_region);\n\t\treturn;\n\t}\n\tif (did_xinerama_clip) {\n\t\trfbLog(\"Xinerama: no blackouts due to -clip xinerama.\\n\");\n\t\treturn;\n\t}\n\n\t/* max len is 10000x10000+10000+10000 (23 chars) per geometry */\n\trcnt = (int) sraRgnCountRects(black_region);\n\tbstr = (char *) malloc(30 * (rcnt+1));\n\ttstr = (char *) malloc(30);\n\tbstr[0] = '\\0';\n\n\titer = sraRgnGetIterator(black_region);\n\twhile (sraRgnIteratorNext(iter, &rect)) {\n\t\tint x, y, w, h;\n\n\t\t/* make sure x1 < x2 and y1 < y2 */\n\t\tif (rect.x1 > rect.x2) {\n\t\t\tint tmp = rect.x2;\n\t\t\trect.x2 = rect.x1;\n\t\t\trect.x1 = tmp;\n\t\t}\n\t\tif (rect.y1 > rect.y2) {\n\t\t\tint tmp = rect.y2;\n\t\t\trect.y2 = rect.y1;\n\t\t\trect.y1 = tmp;\n\t\t}\n\t\tx = rect.x1;\n\t\ty = rect.y1;\n\t\tw = rect.x2 - x;\n\t\th = rect.y2 - y;\n\t\tsprintf(tstr, \"%dx%d+%d+%d,\", w, h, x, y);\n\t\tstrcat(bstr, tstr);\n\t}\n\tsraRgnReleaseIterator(iter);\n\tinitialize_blackouts(bstr);\n\trfbLog(\"\\n\");\n\n\tfree(bstr);\n\tfree(tstr);\n#endif\n}",
    "includes": [
      "#include \"scan.h\"",
      "#include \"blackout_t.h\"",
      "#include \"xwrappers.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "int blackouts = 0;",
      "void push_sleep(int n);",
      "void push_black_screen(int n);",
      "void zero_fb(int x1, int y1, int x2, int y2);",
      "static void initialize_xinerama (void);",
      "static int did_xinerama_clip = 0;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "tstr"
          ],
          "line": 467
        },
        "resolved": true,
        "details": {
          "function_name": "free_rect",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/userinput.c",
          "lines": "6200-6247",
          "snippet": "int free_rect(int idx) {\n\tint n, ok = 0;\n\tsraRegionPtr r1, r2;\n\tint x, y, w, h;\n\n\tif (idx < 0 || idx >= cache_list_num) {\nif (0) fprintf(stderr, \"free_rect: bad index: %d\\n\", idx);\n\t\tclean_up_exit(1);\n\t}\n\n\tx = cache_list[idx].bs_x;\n\ty = cache_list[idx].bs_y;\n\tw = cache_list[idx].bs_w;\n\th = cache_list[idx].bs_h;\n\n\tif (x < 0) {\n\t\tCLEAR(idx);\nif (dnow() > last_client + 5 && ncdb) fprintf(stderr, \"free_rect: already bs_x invalidated: %d bs_x: %d\\n\", idx, x);\n\t\treturn 1;\n\t}\n\n\tr2 = sraRgnCreateRect(x, y, x+w, y+h);\n\n\tn = get_bs_n(y);\n\tif (n >= 0) {\n\t\tr1 = rect_reg[n];\n\t\tsraRgnOr(r1, r2);\n\t\tok = 1;\n\t}\n\n\tif (zero_rects) {\n\t\tsraRgnOr(zero_rects, r2);\n\t\tx = cache_list[idx].su_x;\n\t\ty = cache_list[idx].su_y;\n\t\tw = cache_list[idx].su_w;\n\t\th = cache_list[idx].su_h;\n\t\tif (x >= 0) {\n\t\t\tsraRgnDestroy(r2);\n\t\t\tr2 = sraRgnCreateRect(x, y, x+w, y+h);\n\t\t\tsraRgnOr(zero_rects, r2);\n\t\t}\n\t}\n\tsraRgnDestroy(r2);\n\n\tCLEAR(idx);\nif (! ok && ncdb) fprintf(stderr, \"**** free_rect: not-found %d\\n\", idx);\n\treturn ok;\n}",
          "includes": [
            "#include \"default8x16.h\"",
            "#include \"connections.h\"",
            "#include \"screen.h\"",
            "#include \"cursor.h\"",
            "#include \"macosxCGS.h\"",
            "#include \"macosx.h\"",
            "#include \"unixpw.h\"",
            "#include \"8to24.h\"",
            "#include \"xrandr.h\"",
            "#include \"solid.h\"",
            "#include \"keyboard.h\"",
            "#include \"rates.h\"",
            "#include \"pointer.h\"",
            "#include \"cleanup.h\"",
            "#include \"scan.h\"",
            "#include \"user.h\"",
            "#include \"xevents.h\"",
            "#include \"win_utils.h\"",
            "#include \"xinerama.h\"",
            "#include \"xrecord.h\"",
            "#include \"xdamage.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void mark_for_xdamage(int x, int y, int w, int h);",
            "void set_xdamage_mark(int x, int y, int w, int h);",
            "int find_rect(int idx, int x, int y, int w, int h);",
            "winattr_t *cache_list;",
            "int clipped(int idx);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"default8x16.h\"\n#include \"connections.h\"\n#include \"screen.h\"\n#include \"cursor.h\"\n#include \"macosxCGS.h\"\n#include \"macosx.h\"\n#include \"unixpw.h\"\n#include \"8to24.h\"\n#include \"xrandr.h\"\n#include \"solid.h\"\n#include \"keyboard.h\"\n#include \"rates.h\"\n#include \"pointer.h\"\n#include \"cleanup.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"xevents.h\"\n#include \"win_utils.h\"\n#include \"xinerama.h\"\n#include \"xrecord.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nvoid mark_for_xdamage(int x, int y, int w, int h);\nvoid set_xdamage_mark(int x, int y, int w, int h);\nint find_rect(int idx, int x, int y, int w, int h);\nwinattr_t *cache_list;\nint clipped(int idx);\n\nint free_rect(int idx) {\n\tint n, ok = 0;\n\tsraRegionPtr r1, r2;\n\tint x, y, w, h;\n\n\tif (idx < 0 || idx >= cache_list_num) {\nif (0) fprintf(stderr, \"free_rect: bad index: %d\\n\", idx);\n\t\tclean_up_exit(1);\n\t}\n\n\tx = cache_list[idx].bs_x;\n\ty = cache_list[idx].bs_y;\n\tw = cache_list[idx].bs_w;\n\th = cache_list[idx].bs_h;\n\n\tif (x < 0) {\n\t\tCLEAR(idx);\nif (dnow() > last_client + 5 && ncdb) fprintf(stderr, \"free_rect: already bs_x invalidated: %d bs_x: %d\\n\", idx, x);\n\t\treturn 1;\n\t}\n\n\tr2 = sraRgnCreateRect(x, y, x+w, y+h);\n\n\tn = get_bs_n(y);\n\tif (n >= 0) {\n\t\tr1 = rect_reg[n];\n\t\tsraRgnOr(r1, r2);\n\t\tok = 1;\n\t}\n\n\tif (zero_rects) {\n\t\tsraRgnOr(zero_rects, r2);\n\t\tx = cache_list[idx].su_x;\n\t\ty = cache_list[idx].su_y;\n\t\tw = cache_list[idx].su_w;\n\t\th = cache_list[idx].su_h;\n\t\tif (x >= 0) {\n\t\t\tsraRgnDestroy(r2);\n\t\t\tr2 = sraRgnCreateRect(x, y, x+w, y+h);\n\t\t\tsraRgnOr(zero_rects, r2);\n\t\t}\n\t}\n\tsraRgnDestroy(r2);\n\n\tCLEAR(idx);\nif (! ok && ncdb) fprintf(stderr, \"**** free_rect: not-found %d\\n\", idx);\n\treturn ok;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"\\n\""
          ],
          "line": 464
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "initialize_blackouts",
          "args": [
            "bstr"
          ],
          "line": 463
        },
        "resolved": true,
        "details": {
          "function_name": "initialize_blackouts",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/xinerama.c",
          "lines": "67-135",
          "snippet": "static void initialize_blackouts(char *list) {\n\tchar *p, *blist = strdup(list);\n\tint x, y, X, Y, h, w, t;\n\n\tp = strtok(blist, \", \\t\");\n\twhile (p) {\n\t\tif (!strcmp(\"noptr\", p)) {\n\t\t\tblackout_ptr = 1;\n\t\t\trfbLog(\"pointer will be blocked from blackout \"\n\t\t\t    \"regions\\n\");\n\t\t\tp = strtok(NULL, \", \\t\");\n\t\t\tcontinue;\n\t\t}\n\t\tif (! parse_geom(p, &w, &h, &x, &y, dpy_x, dpy_y)) {\n\t\t\tif (*p != '\\0') {\n\t\t\t\trfbLog(\"skipping invalid geometry: %s\\n\", p);\n\t\t\t}\n\t\t\tp = strtok(NULL, \", \\t\");\n\t\t\tcontinue;\n\t\t}\n\t\tw = nabs(w);\n\t\th = nabs(h);\n\t\tx = nfix(x, dpy_x);\n\t\ty = nfix(y, dpy_y);\n\t\tX = x + w;\n\t\tY = y + h;\n\t\tX = nfix(X, dpy_x+1);\n\t\tY = nfix(Y, dpy_y+1);\n\t\tif (x > X) {\n\t\t\tt = X; X = x; x = t;\n\t\t}\n\t\tif (y > Y) {\n\t\t\tt = Y; Y = y; y = t;\n\t\t}\n\n\t\t/* take clipping region into account */\n\t\tx = nfix(x - coff_x, wdpy_x);\n\t\tX = nfix(X - coff_x, wdpy_x);\n\t\ty = nfix(y - coff_y, wdpy_y);\n\t\tY = nfix(Y - coff_y, wdpy_y);\n\n\t\tif (x < 0 || x > dpy_x || y < 0 || y > dpy_y ||\n\t\t    X < 0 || X > dpy_x || Y < 0 || Y > dpy_y ||\n\t\t    x == X || y == Y) {\n\t\t\trfbLog(\"skipping invalid blackout geometry: %s x=\"\n\t\t\t    \"%d-%d,y=%d-%d,w=%d,h=%d\\n\", p, x, X, y, Y, w, h);\n\t\t} else {\n\t\t\trfbLog(\"blackout rect: %s: x=%d-%d y=%d-%d\\n\", p,\n\t\t\t    x, X, y, Y);\n\n\t\t\t/*\n\t\t\t * note that the black out is x1 <= x but x < x2\n\t\t\t * for the region. i.e. the x2, y2 are outside\n\t\t\t * by 1 pixel. \n\t\t\t */\n\t\t\tblackr[blackouts].x1 = x;\n\t\t\tblackr[blackouts].y1 = y;\n\t\t\tblackr[blackouts].x2 = X;\n\t\t\tblackr[blackouts].y2 = Y;\n\t\t\tblackouts++;\n\t\t\tif (blackouts >= BLACKR_MAX) {\n\t\t\t\trfbLog(\"too many blackouts: %d\\n\", blackouts);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tp = strtok(NULL, \", \\t\");\n\t}\n\tfree(blist);\n}",
          "includes": [
            "#include \"scan.h\"",
            "#include \"blackout_t.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [
            "#define BLACKR_MAX 100"
          ],
          "globals_used": [
            "blackout_t blackr[BLACKR_MAX];",
            "int blackouts = 0;",
            "void push_sleep(int n);",
            "void push_black_screen(int n);",
            "void zero_fb(int x1, int y1, int x2, int y2);",
            "static void initialize_blackouts(char *list);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"scan.h\"\n#include \"blackout_t.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\n#define BLACKR_MAX 100\n\nblackout_t blackr[BLACKR_MAX];\nint blackouts = 0;\nvoid push_sleep(int n);\nvoid push_black_screen(int n);\nvoid zero_fb(int x1, int y1, int x2, int y2);\nstatic void initialize_blackouts(char *list);\n\nstatic void initialize_blackouts(char *list) {\n\tchar *p, *blist = strdup(list);\n\tint x, y, X, Y, h, w, t;\n\n\tp = strtok(blist, \", \\t\");\n\twhile (p) {\n\t\tif (!strcmp(\"noptr\", p)) {\n\t\t\tblackout_ptr = 1;\n\t\t\trfbLog(\"pointer will be blocked from blackout \"\n\t\t\t    \"regions\\n\");\n\t\t\tp = strtok(NULL, \", \\t\");\n\t\t\tcontinue;\n\t\t}\n\t\tif (! parse_geom(p, &w, &h, &x, &y, dpy_x, dpy_y)) {\n\t\t\tif (*p != '\\0') {\n\t\t\t\trfbLog(\"skipping invalid geometry: %s\\n\", p);\n\t\t\t}\n\t\t\tp = strtok(NULL, \", \\t\");\n\t\t\tcontinue;\n\t\t}\n\t\tw = nabs(w);\n\t\th = nabs(h);\n\t\tx = nfix(x, dpy_x);\n\t\ty = nfix(y, dpy_y);\n\t\tX = x + w;\n\t\tY = y + h;\n\t\tX = nfix(X, dpy_x+1);\n\t\tY = nfix(Y, dpy_y+1);\n\t\tif (x > X) {\n\t\t\tt = X; X = x; x = t;\n\t\t}\n\t\tif (y > Y) {\n\t\t\tt = Y; Y = y; y = t;\n\t\t}\n\n\t\t/* take clipping region into account */\n\t\tx = nfix(x - coff_x, wdpy_x);\n\t\tX = nfix(X - coff_x, wdpy_x);\n\t\ty = nfix(y - coff_y, wdpy_y);\n\t\tY = nfix(Y - coff_y, wdpy_y);\n\n\t\tif (x < 0 || x > dpy_x || y < 0 || y > dpy_y ||\n\t\t    X < 0 || X > dpy_x || Y < 0 || Y > dpy_y ||\n\t\t    x == X || y == Y) {\n\t\t\trfbLog(\"skipping invalid blackout geometry: %s x=\"\n\t\t\t    \"%d-%d,y=%d-%d,w=%d,h=%d\\n\", p, x, X, y, Y, w, h);\n\t\t} else {\n\t\t\trfbLog(\"blackout rect: %s: x=%d-%d y=%d-%d\\n\", p,\n\t\t\t    x, X, y, Y);\n\n\t\t\t/*\n\t\t\t * note that the black out is x1 <= x but x < x2\n\t\t\t * for the region. i.e. the x2, y2 are outside\n\t\t\t * by 1 pixel. \n\t\t\t */\n\t\t\tblackr[blackouts].x1 = x;\n\t\t\tblackr[blackouts].y1 = y;\n\t\t\tblackr[blackouts].x2 = X;\n\t\t\tblackr[blackouts].y2 = Y;\n\t\t\tblackouts++;\n\t\t\tif (blackouts >= BLACKR_MAX) {\n\t\t\t\trfbLog(\"too many blackouts: %d\\n\", blackouts);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tp = strtok(NULL, \", \\t\");\n\t}\n\tfree(blist);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sraRgnReleaseIterator",
          "args": [
            "iter"
          ],
          "line": 462
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcat",
          "args": [
            "bstr",
            "tstr"
          ],
          "line": 460
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "tstr",
            "\"%dx%d+%d+%d,\"",
            "w",
            "h",
            "x",
            "y"
          ],
          "line": 459
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sraRgnIteratorNext",
          "args": [
            "iter",
            "&rect"
          ],
          "line": 441
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sraRgnGetIterator",
          "args": [
            "black_region"
          ],
          "line": 440
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "30"
          ],
          "line": 437
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "30 * (rcnt+1)"
          ],
          "line": 436
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sraRgnCountRects",
          "args": [
            "black_region"
          ],
          "line": 435
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"Xinerama: no blackouts due to -clip xinerama.\\n\""
          ],
          "line": 430
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sraRgnDestroy",
          "args": [
            "black_region"
          ],
          "line": 426
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"\\n\""
          ],
          "line": 425
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"Xinerama: no blackouts needed (screen fills\"\n\t\t    \" rectangle)\\n\""
          ],
          "line": 423
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sraRgnEmpty",
          "args": [
            "black_region"
          ],
          "line": 422
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFree_wr",
          "args": [
            "xineramas"
          ],
          "line": 418
        },
        "resolved": true,
        "details": {
          "function_name": "XFree_wr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/xwrappers.c",
          "lines": "1664-1676",
          "snippet": "int XFree_wr(void *data) {\n\tif (data == NULL) {\n\t\treturn 1;\n\t}\n\tif (! dpy) {\n\t\treturn 1;\n\t}\n#if NO_X11\n\treturn 1;\n#else\n\treturn XFree(data);\n#endif\n}",
          "includes": [
            "#include \"nox11_funcs.h\"",
            "#include \"xwrappers.h\"",
            "#include \"xi2_devices.h\"",
            "#include \"macosx.h\"",
            "#include \"cleanup.h\"",
            "#include \"connections.h\"",
            "#include \"xevents.h\"",
            "#include \"keyboard.h\"",
            "#include \"xrecord.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void XTestDiscard_wr(Display *dpy);",
            "int XFree_wr(void *data);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"nox11_funcs.h\"\n#include \"xwrappers.h\"\n#include \"xi2_devices.h\"\n#include \"macosx.h\"\n#include \"cleanup.h\"\n#include \"connections.h\"\n#include \"xevents.h\"\n#include \"keyboard.h\"\n#include \"xrecord.h\"\n#include \"x11vnc.h\"\n\nvoid XTestDiscard_wr(Display *dpy);\nint XFree_wr(void *data);\n\nint XFree_wr(void *data) {\n\tif (data == NULL) {\n\t\treturn 1;\n\t}\n\tif (! dpy) {\n\t\treturn 1;\n\t}\n#if NO_X11\n\treturn 1;\n#else\n\treturn XFree(data);\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "sraRgnDestroy",
          "args": [
            "tmp_region"
          ],
          "line": 415
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sraRgnSubtract",
          "args": [
            "black_region",
            "tmp_region"
          ],
          "line": 414
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sraRgnCreateRect",
          "args": [
            "x",
            "y",
            "x + w",
            "y + h"
          ],
          "line": 412
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"Xinerama: sub-screen[%d]  %dx%d+%d+%d\\n\"",
            "i",
            "w",
            "h",
            "x",
            "y"
          ],
          "line": 410
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sraRgnCreateRect",
          "args": [
            "0",
            "0",
            "dpy_x",
            "dpy_y"
          ],
          "line": 399
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"\\n\""
          ],
          "line": 393
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"Xinerama: no blackouts needed (only one sub-screen)\\n\""
          ],
          "line": 392
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"Xinerama: Use -noxwarppointer to force XTEST.\\n\""
          ],
          "line": 387
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"Xinerama: mouse pointer motion. XTEST+XINERAMA bug.\\n\""
          ],
          "line": 386
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"Xinerama: enabling -xwarppointer mode to try to correct\\n\""
          ],
          "line": 385
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"Xinerama: number of sub-screens: %d\\n\"",
            "n"
          ],
          "line": 382
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XineramaQueryScreens",
          "args": [
            "dpy",
            "&n"
          ],
          "line": 381
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"Xinerama is present and active (e.g. multi-head).\\n\""
          ],
          "line": 378
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"\\n\""
          ],
          "line": 377
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"Xinerama: disabling: not active on display.\\n\""
          ],
          "line": 369
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XineramaIsActive",
          "args": [
            "dpy"
          ],
          "line": 366
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"Xinerama: disabling: display does not support it.\\n\""
          ],
          "line": 359
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XineramaQueryExtension",
          "args": [
            "dpy",
            "&ev",
            "&er"
          ],
          "line": 357
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"Xinerama: if the screen is non-rectangular.\\n\""
          ],
          "line": 344
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"Xinerama: the head geometries, consider using -blackout\\n\""
          ],
          "line": 343
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"Xinerama: Library libXinerama is not available to determine\\n\""
          ],
          "line": 342
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"scan.h\"\n#include \"blackout_t.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nint blackouts = 0;\nvoid push_sleep(int n);\nvoid push_black_screen(int n);\nvoid zero_fb(int x1, int y1, int x2, int y2);\nstatic void initialize_xinerama (void);\nstatic int did_xinerama_clip = 0;\n\nstatic void initialize_xinerama (void) {\n#if !HAVE_LIBXINERAMA\n\tif (!raw_fb_str) {\n\t\trfbLog(\"Xinerama: Library libXinerama is not available to determine\\n\");\n\t\trfbLog(\"Xinerama: the head geometries, consider using -blackout\\n\");\n\t\trfbLog(\"Xinerama: if the screen is non-rectangular.\\n\");\n\t}\n#else\n\tXineramaScreenInfo *sc, *xineramas;\n\tsraRegionPtr black_region, tmp_region;\n\tsraRectangleIterator *iter;\n\tsraRect rect;\n\tchar *bstr, *tstr;\n\tint ev, er, i, n, rcnt;\n\n\tRAWFB_RET_VOID\n\n\tX_LOCK;\n\tif (! XineramaQueryExtension(dpy, &ev, &er)) {\n\t\tif (verbose) {\n\t\t\trfbLog(\"Xinerama: disabling: display does not support it.\\n\");\n\t\t}\n\t\txinerama = 0;\n\t\txinerama_present = 0;\n\t\tX_UNLOCK;\n\t\treturn;\n\t}\n\tif (! XineramaIsActive(dpy)) {\n\t\t/* n.b. change to XineramaActive(dpy, window) someday */\n\t\tif (verbose) {\n\t\t\trfbLog(\"Xinerama: disabling: not active on display.\\n\");\n\t\t}\n\t\txinerama = 0;\n\t\txinerama_present = 0;\n\t\tX_UNLOCK;\n\t\treturn;\n\t}\n\txinerama_present = 1;\n\trfbLog(\"\\n\");\n\trfbLog(\"Xinerama is present and active (e.g. multi-head).\\n\");\n\n\t/* n.b. change to XineramaGetData() someday */\n\txineramas = XineramaQueryScreens(dpy, &n);\n\trfbLog(\"Xinerama: number of sub-screens: %d\\n\", n);\n\n\tif (! use_xwarppointer && ! got_noxwarppointer && n > 1) {\n\t\trfbLog(\"Xinerama: enabling -xwarppointer mode to try to correct\\n\");\n\t\trfbLog(\"Xinerama: mouse pointer motion. XTEST+XINERAMA bug.\\n\");\n\t\trfbLog(\"Xinerama: Use -noxwarppointer to force XTEST.\\n\");\n\t\tuse_xwarppointer = 1;\n\t}\n\n\tif (n == 1) {\n\t\trfbLog(\"Xinerama: no blackouts needed (only one sub-screen)\\n\");\n\t\trfbLog(\"\\n\");\n\t\tXFree_wr(xineramas);\n\t\tX_UNLOCK;\n\t\treturn;\t\t/* must be OK w/o change */\n\t}\n\n\tblack_region = sraRgnCreateRect(0, 0, dpy_x, dpy_y);\n\n\tsc = xineramas;\n\tfor (i=0; i<n; i++) {\n\t\tint x, y, w, h;\n\t\t\n\t\tx = sc->x_org;\n\t\ty = sc->y_org;\n\t\tw = sc->width;\n\t\th = sc->height;\n\n\t\trfbLog(\"Xinerama: sub-screen[%d]  %dx%d+%d+%d\\n\", i, w, h, x, y);\n\n\t\ttmp_region = sraRgnCreateRect(x, y, x + w, y + h);\n\n\t\tsraRgnSubtract(black_region, tmp_region);\n\t\tsraRgnDestroy(tmp_region);\n\t\tsc++;\n\t}\n\tXFree_wr(xineramas);\n\tX_UNLOCK;\n\n\n\tif (sraRgnEmpty(black_region)) {\n\t\trfbLog(\"Xinerama: no blackouts needed (screen fills\"\n\t\t    \" rectangle)\\n\");\n\t\trfbLog(\"\\n\");\n\t\tsraRgnDestroy(black_region);\n\t\treturn;\n\t}\n\tif (did_xinerama_clip) {\n\t\trfbLog(\"Xinerama: no blackouts due to -clip xinerama.\\n\");\n\t\treturn;\n\t}\n\n\t/* max len is 10000x10000+10000+10000 (23 chars) per geometry */\n\trcnt = (int) sraRgnCountRects(black_region);\n\tbstr = (char *) malloc(30 * (rcnt+1));\n\ttstr = (char *) malloc(30);\n\tbstr[0] = '\\0';\n\n\titer = sraRgnGetIterator(black_region);\n\twhile (sraRgnIteratorNext(iter, &rect)) {\n\t\tint x, y, w, h;\n\n\t\t/* make sure x1 < x2 and y1 < y2 */\n\t\tif (rect.x1 > rect.x2) {\n\t\t\tint tmp = rect.x2;\n\t\t\trect.x2 = rect.x1;\n\t\t\trect.x1 = tmp;\n\t\t}\n\t\tif (rect.y1 > rect.y2) {\n\t\t\tint tmp = rect.y2;\n\t\t\trect.y2 = rect.y1;\n\t\t\trect.y1 = tmp;\n\t\t}\n\t\tx = rect.x1;\n\t\ty = rect.y1;\n\t\tw = rect.x2 - x;\n\t\th = rect.y2 - y;\n\t\tsprintf(tstr, \"%dx%d+%d+%d,\", w, h, x, y);\n\t\tstrcat(bstr, tstr);\n\t}\n\tsraRgnReleaseIterator(iter);\n\tinitialize_blackouts(bstr);\n\trfbLog(\"\\n\");\n\n\tfree(bstr);\n\tfree(tstr);\n#endif\n}"
  },
  {
    "function_name": "check_xinerama_clip",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/xinerama.c",
    "lines": "271-337",
    "snippet": "void check_xinerama_clip(void) {\n#if HAVE_LIBXINERAMA\n\tint n, k, i, ev, er, juse = -1;\n\tint score[32], is = 0;\n\tXineramaScreenInfo *x;\n\n\tif (!clip_str || !dpy) {\n\t\treturn;\n\t}\n\tif (sscanf(clip_str, \"xinerama%d\", &k) == 1) {\n\t\t;\n\t} else if (sscanf(clip_str, \"screen%d\", &k) == 1) {\n\t\t;\n\t} else {\n\t\treturn;\n\t}\n\n\tfree(clip_str);\n\tclip_str = NULL;\n\n\tif (! XineramaQueryExtension(dpy, &ev, &er)) {\n\t\treturn;\n\t}\n\tif (! XineramaIsActive(dpy)) {\n\t\treturn;\n\t}\n\tx = XineramaQueryScreens(dpy, &n);\n\tif (k < 0 || k >= n) {\n\t\tXFree_wr(x);\n\t\treturn;\n\t}\n\tfor (i=0; i < n; i++) {\n\t\tscore[is++] = nabs(x[i].x_org) + nabs(x[i].y_org);\n\t\tif (is >= 32) {\n\t\t\tbreak;\n\t\t}\n\t}\n\tfor (i=0; i <= k; i++) {\n\t\tint j, jmon = 0, mon = -1, mox = -1;\n\t\tfor (j=0; j < is; j++) {\n\t\t\tif (mon < 0 || score[j] < mon) {\n\t\t\t\tmon = score[j];\n\t\t\t\tjmon = j;\n\t\t\t}\n\t\t\tif (mox < 0 || score[j] > mox) {\n\t\t\t\tmox = score[j];\n\t\t\t}\n\t\t}\n\t\tjuse = jmon;\n\t\tscore[juse] = mox+1+i;\n\t}\n\n\tif (juse >= 0 && juse < n) {\n\t\tchar str[64];\n\t\tsprintf(str, \"%dx%d+%d+%d\", x[juse].width, x[juse].height,\n\t\t    x[juse].x_org, x[juse].y_org);\n\t\tclip_str = strdup(str);\n\t\tdid_xinerama_clip = 1;\n\t} else {\n\t\tclip_str = strdup(\"\");\n\t}\n\tXFree_wr(x);\n\tif (!quiet) {\n\t\trfbLog(\"set -clip to '%s' for xinerama%d\\n\", clip_str, k);\n\t}\n#endif\n}",
    "includes": [
      "#include \"scan.h\"",
      "#include \"blackout_t.h\"",
      "#include \"xwrappers.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "void push_sleep(int n);",
      "void push_black_screen(int n);",
      "static int did_xinerama_clip = 0;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"set -clip to '%s' for xinerama%d\\n\"",
            "clip_str",
            "k"
          ],
          "line": 334
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFree_wr",
          "args": [
            "x"
          ],
          "line": 332
        },
        "resolved": true,
        "details": {
          "function_name": "XFree_wr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/xwrappers.c",
          "lines": "1664-1676",
          "snippet": "int XFree_wr(void *data) {\n\tif (data == NULL) {\n\t\treturn 1;\n\t}\n\tif (! dpy) {\n\t\treturn 1;\n\t}\n#if NO_X11\n\treturn 1;\n#else\n\treturn XFree(data);\n#endif\n}",
          "includes": [
            "#include \"nox11_funcs.h\"",
            "#include \"xwrappers.h\"",
            "#include \"xi2_devices.h\"",
            "#include \"macosx.h\"",
            "#include \"cleanup.h\"",
            "#include \"connections.h\"",
            "#include \"xevents.h\"",
            "#include \"keyboard.h\"",
            "#include \"xrecord.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void XTestDiscard_wr(Display *dpy);",
            "int XFree_wr(void *data);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"nox11_funcs.h\"\n#include \"xwrappers.h\"\n#include \"xi2_devices.h\"\n#include \"macosx.h\"\n#include \"cleanup.h\"\n#include \"connections.h\"\n#include \"xevents.h\"\n#include \"keyboard.h\"\n#include \"xrecord.h\"\n#include \"x11vnc.h\"\n\nvoid XTestDiscard_wr(Display *dpy);\nint XFree_wr(void *data);\n\nint XFree_wr(void *data) {\n\tif (data == NULL) {\n\t\treturn 1;\n\t}\n\tif (! dpy) {\n\t\treturn 1;\n\t}\n#if NO_X11\n\treturn 1;\n#else\n\treturn XFree(data);\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "\"\""
          ],
          "line": 330
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "str"
          ],
          "line": 327
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "str",
            "\"%dx%d+%d+%d\"",
            "x[juse].width",
            "x[juse].height",
            "x[juse].x_org",
            "x[juse].y_org"
          ],
          "line": 325
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nabs",
          "args": [
            "x[i].y_org"
          ],
          "line": 303
        },
        "resolved": true,
        "details": {
          "function_name": "nabs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/util.c",
          "lines": "120-126",
          "snippet": "int nabs(int n) {\n\tif (n < 0) {\n\t\treturn -n;\n\t} else {\n\t\treturn n;\n\t}\n}",
          "includes": [
            "#include \"connections.h\"",
            "#include \"unixpw.h\"",
            "#include \"win_utils.h\"",
            "#include \"cleanup.h\"",
            "#include \"x11vnc.h\"",
            "#include <stdlib.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int nfix(int i, int n);",
            "int nabs(int n);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"connections.h\"\n#include \"unixpw.h\"\n#include \"win_utils.h\"\n#include \"cleanup.h\"\n#include \"x11vnc.h\"\n#include <stdlib.h>\n\nint nfix(int i, int n);\nint nabs(int n);\n\nint nabs(int n) {\n\tif (n < 0) {\n\t\treturn -n;\n\t} else {\n\t\treturn n;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "XineramaQueryScreens",
          "args": [
            "dpy",
            "&n"
          ],
          "line": 297
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XineramaIsActive",
          "args": [
            "dpy"
          ],
          "line": 294
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XineramaQueryExtension",
          "args": [
            "dpy",
            "&ev",
            "&er"
          ],
          "line": 291
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "clip_str"
          ],
          "line": 288
        },
        "resolved": true,
        "details": {
          "function_name": "free_rect",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/userinput.c",
          "lines": "6200-6247",
          "snippet": "int free_rect(int idx) {\n\tint n, ok = 0;\n\tsraRegionPtr r1, r2;\n\tint x, y, w, h;\n\n\tif (idx < 0 || idx >= cache_list_num) {\nif (0) fprintf(stderr, \"free_rect: bad index: %d\\n\", idx);\n\t\tclean_up_exit(1);\n\t}\n\n\tx = cache_list[idx].bs_x;\n\ty = cache_list[idx].bs_y;\n\tw = cache_list[idx].bs_w;\n\th = cache_list[idx].bs_h;\n\n\tif (x < 0) {\n\t\tCLEAR(idx);\nif (dnow() > last_client + 5 && ncdb) fprintf(stderr, \"free_rect: already bs_x invalidated: %d bs_x: %d\\n\", idx, x);\n\t\treturn 1;\n\t}\n\n\tr2 = sraRgnCreateRect(x, y, x+w, y+h);\n\n\tn = get_bs_n(y);\n\tif (n >= 0) {\n\t\tr1 = rect_reg[n];\n\t\tsraRgnOr(r1, r2);\n\t\tok = 1;\n\t}\n\n\tif (zero_rects) {\n\t\tsraRgnOr(zero_rects, r2);\n\t\tx = cache_list[idx].su_x;\n\t\ty = cache_list[idx].su_y;\n\t\tw = cache_list[idx].su_w;\n\t\th = cache_list[idx].su_h;\n\t\tif (x >= 0) {\n\t\t\tsraRgnDestroy(r2);\n\t\t\tr2 = sraRgnCreateRect(x, y, x+w, y+h);\n\t\t\tsraRgnOr(zero_rects, r2);\n\t\t}\n\t}\n\tsraRgnDestroy(r2);\n\n\tCLEAR(idx);\nif (! ok && ncdb) fprintf(stderr, \"**** free_rect: not-found %d\\n\", idx);\n\treturn ok;\n}",
          "includes": [
            "#include \"default8x16.h\"",
            "#include \"connections.h\"",
            "#include \"screen.h\"",
            "#include \"cursor.h\"",
            "#include \"macosxCGS.h\"",
            "#include \"macosx.h\"",
            "#include \"unixpw.h\"",
            "#include \"8to24.h\"",
            "#include \"xrandr.h\"",
            "#include \"solid.h\"",
            "#include \"keyboard.h\"",
            "#include \"rates.h\"",
            "#include \"pointer.h\"",
            "#include \"cleanup.h\"",
            "#include \"scan.h\"",
            "#include \"user.h\"",
            "#include \"xevents.h\"",
            "#include \"win_utils.h\"",
            "#include \"xinerama.h\"",
            "#include \"xrecord.h\"",
            "#include \"xdamage.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void mark_for_xdamage(int x, int y, int w, int h);",
            "void set_xdamage_mark(int x, int y, int w, int h);",
            "int find_rect(int idx, int x, int y, int w, int h);",
            "winattr_t *cache_list;",
            "int clipped(int idx);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"default8x16.h\"\n#include \"connections.h\"\n#include \"screen.h\"\n#include \"cursor.h\"\n#include \"macosxCGS.h\"\n#include \"macosx.h\"\n#include \"unixpw.h\"\n#include \"8to24.h\"\n#include \"xrandr.h\"\n#include \"solid.h\"\n#include \"keyboard.h\"\n#include \"rates.h\"\n#include \"pointer.h\"\n#include \"cleanup.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"xevents.h\"\n#include \"win_utils.h\"\n#include \"xinerama.h\"\n#include \"xrecord.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nvoid mark_for_xdamage(int x, int y, int w, int h);\nvoid set_xdamage_mark(int x, int y, int w, int h);\nint find_rect(int idx, int x, int y, int w, int h);\nwinattr_t *cache_list;\nint clipped(int idx);\n\nint free_rect(int idx) {\n\tint n, ok = 0;\n\tsraRegionPtr r1, r2;\n\tint x, y, w, h;\n\n\tif (idx < 0 || idx >= cache_list_num) {\nif (0) fprintf(stderr, \"free_rect: bad index: %d\\n\", idx);\n\t\tclean_up_exit(1);\n\t}\n\n\tx = cache_list[idx].bs_x;\n\ty = cache_list[idx].bs_y;\n\tw = cache_list[idx].bs_w;\n\th = cache_list[idx].bs_h;\n\n\tif (x < 0) {\n\t\tCLEAR(idx);\nif (dnow() > last_client + 5 && ncdb) fprintf(stderr, \"free_rect: already bs_x invalidated: %d bs_x: %d\\n\", idx, x);\n\t\treturn 1;\n\t}\n\n\tr2 = sraRgnCreateRect(x, y, x+w, y+h);\n\n\tn = get_bs_n(y);\n\tif (n >= 0) {\n\t\tr1 = rect_reg[n];\n\t\tsraRgnOr(r1, r2);\n\t\tok = 1;\n\t}\n\n\tif (zero_rects) {\n\t\tsraRgnOr(zero_rects, r2);\n\t\tx = cache_list[idx].su_x;\n\t\ty = cache_list[idx].su_y;\n\t\tw = cache_list[idx].su_w;\n\t\th = cache_list[idx].su_h;\n\t\tif (x >= 0) {\n\t\t\tsraRgnDestroy(r2);\n\t\t\tr2 = sraRgnCreateRect(x, y, x+w, y+h);\n\t\t\tsraRgnOr(zero_rects, r2);\n\t\t}\n\t}\n\tsraRgnDestroy(r2);\n\n\tCLEAR(idx);\nif (! ok && ncdb) fprintf(stderr, \"**** free_rect: not-found %d\\n\", idx);\n\treturn ok;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sscanf",
          "args": [
            "clip_str",
            "\"screen%d\"",
            "&k"
          ],
          "line": 282
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sscanf",
          "args": [
            "clip_str",
            "\"xinerama%d\"",
            "&k"
          ],
          "line": 280
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"scan.h\"\n#include \"blackout_t.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nvoid push_sleep(int n);\nvoid push_black_screen(int n);\nstatic int did_xinerama_clip = 0;\n\nvoid check_xinerama_clip(void) {\n#if HAVE_LIBXINERAMA\n\tint n, k, i, ev, er, juse = -1;\n\tint score[32], is = 0;\n\tXineramaScreenInfo *x;\n\n\tif (!clip_str || !dpy) {\n\t\treturn;\n\t}\n\tif (sscanf(clip_str, \"xinerama%d\", &k) == 1) {\n\t\t;\n\t} else if (sscanf(clip_str, \"screen%d\", &k) == 1) {\n\t\t;\n\t} else {\n\t\treturn;\n\t}\n\n\tfree(clip_str);\n\tclip_str = NULL;\n\n\tif (! XineramaQueryExtension(dpy, &ev, &er)) {\n\t\treturn;\n\t}\n\tif (! XineramaIsActive(dpy)) {\n\t\treturn;\n\t}\n\tx = XineramaQueryScreens(dpy, &n);\n\tif (k < 0 || k >= n) {\n\t\tXFree_wr(x);\n\t\treturn;\n\t}\n\tfor (i=0; i < n; i++) {\n\t\tscore[is++] = nabs(x[i].x_org) + nabs(x[i].y_org);\n\t\tif (is >= 32) {\n\t\t\tbreak;\n\t\t}\n\t}\n\tfor (i=0; i <= k; i++) {\n\t\tint j, jmon = 0, mon = -1, mox = -1;\n\t\tfor (j=0; j < is; j++) {\n\t\t\tif (mon < 0 || score[j] < mon) {\n\t\t\t\tmon = score[j];\n\t\t\t\tjmon = j;\n\t\t\t}\n\t\t\tif (mox < 0 || score[j] > mox) {\n\t\t\t\tmox = score[j];\n\t\t\t}\n\t\t}\n\t\tjuse = jmon;\n\t\tscore[juse] = mox+1+i;\n\t}\n\n\tif (juse >= 0 && juse < n) {\n\t\tchar str[64];\n\t\tsprintf(str, \"%dx%d+%d+%d\", x[juse].width, x[juse].height,\n\t\t    x[juse].x_org, x[juse].y_org);\n\t\tclip_str = strdup(str);\n\t\tdid_xinerama_clip = 1;\n\t} else {\n\t\tclip_str = strdup(\"\");\n\t}\n\tXFree_wr(x);\n\tif (!quiet) {\n\t\trfbLog(\"set -clip to '%s' for xinerama%d\\n\", clip_str, k);\n\t}\n#endif\n}"
  },
  {
    "function_name": "blackout_tiles",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/xinerama.c",
    "lines": "142-267",
    "snippet": "static void blackout_tiles(void) {\n\tint tx, ty;\n\tint debug_bo = 0;\n\tif (! blackouts) {\n\t\treturn;\n\t}\n\tif (getenv(\"DEBUG_BLACKOUT\") != NULL) {\n\t\tdebug_bo = 1;\n\t}\n\n\t/* \n\t * to simplify things drop down to single copy mode, etc...\n\t */\n\tsingle_copytile = 1;\n\t/* loop over all tiles. */\n\tfor (ty=0; ty < ntiles_y; ty++) {\n\t\tfor (tx=0; tx < ntiles_x; tx++) {\n\t\t\tsraRegionPtr tile_reg, black_reg;\n\t\t\tsraRect rect;\n\t\t\tsraRectangleIterator *iter;\n\t\t\tint n, b, x1, y1, x2, y2, cnt;\n\n\t\t\t/* tile number and coordinates: */\n\t\t\tn = tx + ty * ntiles_x;\n\t\t\tx1 = tx * tile_x;\n\t\t\ty1 = ty * tile_y;\n\t\t\tx2 = x1 + tile_x;\n\t\t\ty2 = y1 + tile_y;\n\t\t\tif (x2 > dpy_x) {\n\t\t\t\tx2 = dpy_x;\n\t\t\t}\n\t\t\tif (y2 > dpy_y) {\n\t\t\t\ty2 = dpy_y;\n\t\t\t}\n\n\t\t\t/* make regions for the tile and the blackouts: */\n\t\t\tblack_reg = (sraRegionPtr) sraRgnCreate();\n\t\t\ttile_reg  = (sraRegionPtr) sraRgnCreateRect(x1, y1,\n\t\t\t    x2, y2);\n\n\t\t\ttile_blackout[n].cover = 0;\n\t\t\ttile_blackout[n].count = 0;\n\n\t\t\t/* union of blackouts */\n\t\t\tfor (b=0; b < blackouts; b++) {\n\t\t\t\tsraRegionPtr tmp_reg = (sraRegionPtr)\n\t\t\t\t    sraRgnCreateRect(blackr[b].x1,\n\t\t\t\t    blackr[b].y1, blackr[b].x2, blackr[b].y2);\n\n\t\t\t\tsraRgnOr(black_reg, tmp_reg);\n\t\t\t\tsraRgnDestroy(tmp_reg);\n\t\t\t}\n\n\t\t\tif (! sraRgnAnd(black_reg, tile_reg)) {\n\t\t\t\t/*\n\t\t\t\t * no intersection for this tile, so we\n\t\t\t\t * are done.\n\t\t\t\t */\n\t\t\t\tsraRgnDestroy(black_reg);\n\t\t\t\tsraRgnDestroy(tile_reg);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * loop over rectangles that make up the blackout\n\t\t\t * region:\n\t\t\t */\n\t\t\tcnt = 0;\n\t\t\titer = sraRgnGetIterator(black_reg);\n\t\t\twhile (sraRgnIteratorNext(iter, &rect)) {\n\n\t\t\t\t/* make sure x1 < x2 and y1 < y2 */\n\t\t\t\tif (rect.x1 > rect.x2) {\n\t\t\t\t\tint tmp = rect.x2;\n\t\t\t\t\trect.x2 = rect.x1;\n\t\t\t\t\trect.x1 = tmp;\n\t\t\t\t}\n\t\t\t\tif (rect.y1 > rect.y2) {\n\t\t\t\t\tint tmp = rect.y2;\n\t\t\t\t\trect.y2 = rect.y1;\n\t\t\t\t\trect.y1 = tmp;\n\t\t\t\t}\n\n\t\t\t\t/* store coordinates */\n\t\t\t\ttile_blackout[n].bo[cnt].x1 = rect.x1;\n\t\t\t\ttile_blackout[n].bo[cnt].y1 = rect.y1;\n\t\t\t\ttile_blackout[n].bo[cnt].x2 = rect.x2;\n\t\t\t\ttile_blackout[n].bo[cnt].y2 = rect.y2;\n\n\t\t\t\t/* note if the tile is completely obscured */\n\t\t\t\tif (rect.x1 == x1 && rect.y1 == y1 &&\n\t\t\t\t    rect.x2 == x2 && rect.y2 == y2) {\n\t\t\t\t\ttile_blackout[n].cover = 2;\n\t\t\t\t\tif (debug_bo) {\n \t\t\t\t\t\tfprintf(stderr, \"full: %d=%d,%d\"\n\t\t\t\t\t\t    \"  (%d-%d)  (%d-%d)\\n\",\n\t\t\t\t\t\t    n, tx, ty, x1, x2, y1, y2);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\ttile_blackout[n].cover = 1;\n\t\t\t\t\tif (debug_bo) {\n\t\t\t\t\t\tfprintf(stderr, \"part: %d=%d,%d\"\n\t\t\t\t\t\t    \"  (%d-%d)  (%d-%d)\\n\",\n\t\t\t\t\t\t    n, tx, ty, x1, x2, y1, y2);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (++cnt >= BO_MAX) {\n\t\t\t\t\trfbLog(\"too many blackout rectangles \"\n\t\t\t\t\t    \"for tile %d=%d,%d.\\n\", n, tx, ty);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tsraRgnReleaseIterator(iter);\n\n\t\t\tsraRgnDestroy(black_reg);\n\t\t\tsraRgnDestroy(tile_reg);\n\n\t\t\ttile_blackout[n].count = cnt;\n\t\t\tif (debug_bo && cnt > 1) {\n \t\t\t\trfbLog(\"warning: multiple region overlaps[%d] \"\n\t\t\t\t    \"for tile %d=%d,%d.\\n\", cnt, n, tx, ty);\n\t\t\t}\n\t\t}\n\t}\n}",
    "includes": [
      "#include \"scan.h\"",
      "#include \"blackout_t.h\"",
      "#include \"xwrappers.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "blackout_t blackr[BLACKR_MAX];",
      "tile_blackout_t *tile_blackout;",
      "int blackouts = 0;",
      "void push_sleep(int n);",
      "void push_black_screen(int n);",
      "void zero_fb(int x1, int y1, int x2, int y2);",
      "static void blackout_tiles(void);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"warning: multiple region overlaps[%d] \"\n\t\t\t\t    \"for tile %d=%d,%d.\\n\"",
            "cnt",
            "n",
            "tx",
            "ty"
          ],
          "line": 262
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sraRgnDestroy",
          "args": [
            "tile_reg"
          ],
          "line": 258
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sraRgnDestroy",
          "args": [
            "black_reg"
          ],
          "line": 257
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sraRgnReleaseIterator",
          "args": [
            "iter"
          ],
          "line": 255
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"too many blackout rectangles \"\n\t\t\t\t\t    \"for tile %d=%d,%d.\\n\"",
            "n",
            "tx",
            "ty"
          ],
          "line": 250
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"part: %d=%d,%d\"\n\t\t\t\t\t\t    \"  (%d-%d)  (%d-%d)\\n\"",
            "n",
            "tx",
            "ty",
            "x1",
            "x2",
            "y1",
            "y2"
          ],
          "line": 243
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"full: %d=%d,%d\"\n\t\t\t\t\t\t    \"  (%d-%d)  (%d-%d)\\n\"",
            "n",
            "tx",
            "ty",
            "x1",
            "x2",
            "y1",
            "y2"
          ],
          "line": 236
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sraRgnIteratorNext",
          "args": [
            "iter",
            "&rect"
          ],
          "line": 211
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sraRgnGetIterator",
          "args": [
            "black_reg"
          ],
          "line": 210
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sraRgnDestroy",
          "args": [
            "tile_reg"
          ],
          "line": 201
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sraRgnDestroy",
          "args": [
            "black_reg"
          ],
          "line": 200
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sraRgnAnd",
          "args": [
            "black_reg",
            "tile_reg"
          ],
          "line": 195
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sraRgnDestroy",
          "args": [
            "tmp_reg"
          ],
          "line": 192
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sraRgnOr",
          "args": [
            "black_reg",
            "tmp_reg"
          ],
          "line": 191
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sraRgnCreateRect",
          "args": [
            "blackr[b].x1",
            "blackr[b].y1",
            "blackr[b].x2",
            "blackr[b].y2"
          ],
          "line": 188
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sraRgnCreateRect",
          "args": [
            "x1",
            "y1",
            "x2",
            "y2"
          ],
          "line": 179
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sraRgnCreate",
          "args": [],
          "line": 178
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getenv",
          "args": [
            "\"DEBUG_BLACKOUT\""
          ],
          "line": 148
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"scan.h\"\n#include \"blackout_t.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nblackout_t blackr[BLACKR_MAX];\ntile_blackout_t *tile_blackout;\nint blackouts = 0;\nvoid push_sleep(int n);\nvoid push_black_screen(int n);\nvoid zero_fb(int x1, int y1, int x2, int y2);\nstatic void blackout_tiles(void);\n\nstatic void blackout_tiles(void) {\n\tint tx, ty;\n\tint debug_bo = 0;\n\tif (! blackouts) {\n\t\treturn;\n\t}\n\tif (getenv(\"DEBUG_BLACKOUT\") != NULL) {\n\t\tdebug_bo = 1;\n\t}\n\n\t/* \n\t * to simplify things drop down to single copy mode, etc...\n\t */\n\tsingle_copytile = 1;\n\t/* loop over all tiles. */\n\tfor (ty=0; ty < ntiles_y; ty++) {\n\t\tfor (tx=0; tx < ntiles_x; tx++) {\n\t\t\tsraRegionPtr tile_reg, black_reg;\n\t\t\tsraRect rect;\n\t\t\tsraRectangleIterator *iter;\n\t\t\tint n, b, x1, y1, x2, y2, cnt;\n\n\t\t\t/* tile number and coordinates: */\n\t\t\tn = tx + ty * ntiles_x;\n\t\t\tx1 = tx * tile_x;\n\t\t\ty1 = ty * tile_y;\n\t\t\tx2 = x1 + tile_x;\n\t\t\ty2 = y1 + tile_y;\n\t\t\tif (x2 > dpy_x) {\n\t\t\t\tx2 = dpy_x;\n\t\t\t}\n\t\t\tif (y2 > dpy_y) {\n\t\t\t\ty2 = dpy_y;\n\t\t\t}\n\n\t\t\t/* make regions for the tile and the blackouts: */\n\t\t\tblack_reg = (sraRegionPtr) sraRgnCreate();\n\t\t\ttile_reg  = (sraRegionPtr) sraRgnCreateRect(x1, y1,\n\t\t\t    x2, y2);\n\n\t\t\ttile_blackout[n].cover = 0;\n\t\t\ttile_blackout[n].count = 0;\n\n\t\t\t/* union of blackouts */\n\t\t\tfor (b=0; b < blackouts; b++) {\n\t\t\t\tsraRegionPtr tmp_reg = (sraRegionPtr)\n\t\t\t\t    sraRgnCreateRect(blackr[b].x1,\n\t\t\t\t    blackr[b].y1, blackr[b].x2, blackr[b].y2);\n\n\t\t\t\tsraRgnOr(black_reg, tmp_reg);\n\t\t\t\tsraRgnDestroy(tmp_reg);\n\t\t\t}\n\n\t\t\tif (! sraRgnAnd(black_reg, tile_reg)) {\n\t\t\t\t/*\n\t\t\t\t * no intersection for this tile, so we\n\t\t\t\t * are done.\n\t\t\t\t */\n\t\t\t\tsraRgnDestroy(black_reg);\n\t\t\t\tsraRgnDestroy(tile_reg);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * loop over rectangles that make up the blackout\n\t\t\t * region:\n\t\t\t */\n\t\t\tcnt = 0;\n\t\t\titer = sraRgnGetIterator(black_reg);\n\t\t\twhile (sraRgnIteratorNext(iter, &rect)) {\n\n\t\t\t\t/* make sure x1 < x2 and y1 < y2 */\n\t\t\t\tif (rect.x1 > rect.x2) {\n\t\t\t\t\tint tmp = rect.x2;\n\t\t\t\t\trect.x2 = rect.x1;\n\t\t\t\t\trect.x1 = tmp;\n\t\t\t\t}\n\t\t\t\tif (rect.y1 > rect.y2) {\n\t\t\t\t\tint tmp = rect.y2;\n\t\t\t\t\trect.y2 = rect.y1;\n\t\t\t\t\trect.y1 = tmp;\n\t\t\t\t}\n\n\t\t\t\t/* store coordinates */\n\t\t\t\ttile_blackout[n].bo[cnt].x1 = rect.x1;\n\t\t\t\ttile_blackout[n].bo[cnt].y1 = rect.y1;\n\t\t\t\ttile_blackout[n].bo[cnt].x2 = rect.x2;\n\t\t\t\ttile_blackout[n].bo[cnt].y2 = rect.y2;\n\n\t\t\t\t/* note if the tile is completely obscured */\n\t\t\t\tif (rect.x1 == x1 && rect.y1 == y1 &&\n\t\t\t\t    rect.x2 == x2 && rect.y2 == y2) {\n\t\t\t\t\ttile_blackout[n].cover = 2;\n\t\t\t\t\tif (debug_bo) {\n \t\t\t\t\t\tfprintf(stderr, \"full: %d=%d,%d\"\n\t\t\t\t\t\t    \"  (%d-%d)  (%d-%d)\\n\",\n\t\t\t\t\t\t    n, tx, ty, x1, x2, y1, y2);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\ttile_blackout[n].cover = 1;\n\t\t\t\t\tif (debug_bo) {\n\t\t\t\t\t\tfprintf(stderr, \"part: %d=%d,%d\"\n\t\t\t\t\t\t    \"  (%d-%d)  (%d-%d)\\n\",\n\t\t\t\t\t\t    n, tx, ty, x1, x2, y1, y2);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (++cnt >= BO_MAX) {\n\t\t\t\t\trfbLog(\"too many blackout rectangles \"\n\t\t\t\t\t    \"for tile %d=%d,%d.\\n\", n, tx, ty);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tsraRgnReleaseIterator(iter);\n\n\t\t\tsraRgnDestroy(black_reg);\n\t\t\tsraRgnDestroy(tile_reg);\n\n\t\t\ttile_blackout[n].count = cnt;\n\t\t\tif (debug_bo && cnt > 1) {\n \t\t\t\trfbLog(\"warning: multiple region overlaps[%d] \"\n\t\t\t\t    \"for tile %d=%d,%d.\\n\", cnt, n, tx, ty);\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "function_name": "initialize_blackouts",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/xinerama.c",
    "lines": "67-135",
    "snippet": "static void initialize_blackouts(char *list) {\n\tchar *p, *blist = strdup(list);\n\tint x, y, X, Y, h, w, t;\n\n\tp = strtok(blist, \", \\t\");\n\twhile (p) {\n\t\tif (!strcmp(\"noptr\", p)) {\n\t\t\tblackout_ptr = 1;\n\t\t\trfbLog(\"pointer will be blocked from blackout \"\n\t\t\t    \"regions\\n\");\n\t\t\tp = strtok(NULL, \", \\t\");\n\t\t\tcontinue;\n\t\t}\n\t\tif (! parse_geom(p, &w, &h, &x, &y, dpy_x, dpy_y)) {\n\t\t\tif (*p != '\\0') {\n\t\t\t\trfbLog(\"skipping invalid geometry: %s\\n\", p);\n\t\t\t}\n\t\t\tp = strtok(NULL, \", \\t\");\n\t\t\tcontinue;\n\t\t}\n\t\tw = nabs(w);\n\t\th = nabs(h);\n\t\tx = nfix(x, dpy_x);\n\t\ty = nfix(y, dpy_y);\n\t\tX = x + w;\n\t\tY = y + h;\n\t\tX = nfix(X, dpy_x+1);\n\t\tY = nfix(Y, dpy_y+1);\n\t\tif (x > X) {\n\t\t\tt = X; X = x; x = t;\n\t\t}\n\t\tif (y > Y) {\n\t\t\tt = Y; Y = y; y = t;\n\t\t}\n\n\t\t/* take clipping region into account */\n\t\tx = nfix(x - coff_x, wdpy_x);\n\t\tX = nfix(X - coff_x, wdpy_x);\n\t\ty = nfix(y - coff_y, wdpy_y);\n\t\tY = nfix(Y - coff_y, wdpy_y);\n\n\t\tif (x < 0 || x > dpy_x || y < 0 || y > dpy_y ||\n\t\t    X < 0 || X > dpy_x || Y < 0 || Y > dpy_y ||\n\t\t    x == X || y == Y) {\n\t\t\trfbLog(\"skipping invalid blackout geometry: %s x=\"\n\t\t\t    \"%d-%d,y=%d-%d,w=%d,h=%d\\n\", p, x, X, y, Y, w, h);\n\t\t} else {\n\t\t\trfbLog(\"blackout rect: %s: x=%d-%d y=%d-%d\\n\", p,\n\t\t\t    x, X, y, Y);\n\n\t\t\t/*\n\t\t\t * note that the black out is x1 <= x but x < x2\n\t\t\t * for the region. i.e. the x2, y2 are outside\n\t\t\t * by 1 pixel. \n\t\t\t */\n\t\t\tblackr[blackouts].x1 = x;\n\t\t\tblackr[blackouts].y1 = y;\n\t\t\tblackr[blackouts].x2 = X;\n\t\t\tblackr[blackouts].y2 = Y;\n\t\t\tblackouts++;\n\t\t\tif (blackouts >= BLACKR_MAX) {\n\t\t\t\trfbLog(\"too many blackouts: %d\\n\", blackouts);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tp = strtok(NULL, \", \\t\");\n\t}\n\tfree(blist);\n}",
    "includes": [
      "#include \"scan.h\"",
      "#include \"blackout_t.h\"",
      "#include \"xwrappers.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [
      "#define BLACKR_MAX 100"
    ],
    "globals_used": [
      "blackout_t blackr[BLACKR_MAX];",
      "int blackouts = 0;",
      "void push_sleep(int n);",
      "void push_black_screen(int n);",
      "void zero_fb(int x1, int y1, int x2, int y2);",
      "static void initialize_blackouts(char *list);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "blist"
          ],
          "line": 134
        },
        "resolved": true,
        "details": {
          "function_name": "free_rect",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/userinput.c",
          "lines": "6200-6247",
          "snippet": "int free_rect(int idx) {\n\tint n, ok = 0;\n\tsraRegionPtr r1, r2;\n\tint x, y, w, h;\n\n\tif (idx < 0 || idx >= cache_list_num) {\nif (0) fprintf(stderr, \"free_rect: bad index: %d\\n\", idx);\n\t\tclean_up_exit(1);\n\t}\n\n\tx = cache_list[idx].bs_x;\n\ty = cache_list[idx].bs_y;\n\tw = cache_list[idx].bs_w;\n\th = cache_list[idx].bs_h;\n\n\tif (x < 0) {\n\t\tCLEAR(idx);\nif (dnow() > last_client + 5 && ncdb) fprintf(stderr, \"free_rect: already bs_x invalidated: %d bs_x: %d\\n\", idx, x);\n\t\treturn 1;\n\t}\n\n\tr2 = sraRgnCreateRect(x, y, x+w, y+h);\n\n\tn = get_bs_n(y);\n\tif (n >= 0) {\n\t\tr1 = rect_reg[n];\n\t\tsraRgnOr(r1, r2);\n\t\tok = 1;\n\t}\n\n\tif (zero_rects) {\n\t\tsraRgnOr(zero_rects, r2);\n\t\tx = cache_list[idx].su_x;\n\t\ty = cache_list[idx].su_y;\n\t\tw = cache_list[idx].su_w;\n\t\th = cache_list[idx].su_h;\n\t\tif (x >= 0) {\n\t\t\tsraRgnDestroy(r2);\n\t\t\tr2 = sraRgnCreateRect(x, y, x+w, y+h);\n\t\t\tsraRgnOr(zero_rects, r2);\n\t\t}\n\t}\n\tsraRgnDestroy(r2);\n\n\tCLEAR(idx);\nif (! ok && ncdb) fprintf(stderr, \"**** free_rect: not-found %d\\n\", idx);\n\treturn ok;\n}",
          "includes": [
            "#include \"default8x16.h\"",
            "#include \"connections.h\"",
            "#include \"screen.h\"",
            "#include \"cursor.h\"",
            "#include \"macosxCGS.h\"",
            "#include \"macosx.h\"",
            "#include \"unixpw.h\"",
            "#include \"8to24.h\"",
            "#include \"xrandr.h\"",
            "#include \"solid.h\"",
            "#include \"keyboard.h\"",
            "#include \"rates.h\"",
            "#include \"pointer.h\"",
            "#include \"cleanup.h\"",
            "#include \"scan.h\"",
            "#include \"user.h\"",
            "#include \"xevents.h\"",
            "#include \"win_utils.h\"",
            "#include \"xinerama.h\"",
            "#include \"xrecord.h\"",
            "#include \"xdamage.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void mark_for_xdamage(int x, int y, int w, int h);",
            "void set_xdamage_mark(int x, int y, int w, int h);",
            "int find_rect(int idx, int x, int y, int w, int h);",
            "winattr_t *cache_list;",
            "int clipped(int idx);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"default8x16.h\"\n#include \"connections.h\"\n#include \"screen.h\"\n#include \"cursor.h\"\n#include \"macosxCGS.h\"\n#include \"macosx.h\"\n#include \"unixpw.h\"\n#include \"8to24.h\"\n#include \"xrandr.h\"\n#include \"solid.h\"\n#include \"keyboard.h\"\n#include \"rates.h\"\n#include \"pointer.h\"\n#include \"cleanup.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"xevents.h\"\n#include \"win_utils.h\"\n#include \"xinerama.h\"\n#include \"xrecord.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nvoid mark_for_xdamage(int x, int y, int w, int h);\nvoid set_xdamage_mark(int x, int y, int w, int h);\nint find_rect(int idx, int x, int y, int w, int h);\nwinattr_t *cache_list;\nint clipped(int idx);\n\nint free_rect(int idx) {\n\tint n, ok = 0;\n\tsraRegionPtr r1, r2;\n\tint x, y, w, h;\n\n\tif (idx < 0 || idx >= cache_list_num) {\nif (0) fprintf(stderr, \"free_rect: bad index: %d\\n\", idx);\n\t\tclean_up_exit(1);\n\t}\n\n\tx = cache_list[idx].bs_x;\n\ty = cache_list[idx].bs_y;\n\tw = cache_list[idx].bs_w;\n\th = cache_list[idx].bs_h;\n\n\tif (x < 0) {\n\t\tCLEAR(idx);\nif (dnow() > last_client + 5 && ncdb) fprintf(stderr, \"free_rect: already bs_x invalidated: %d bs_x: %d\\n\", idx, x);\n\t\treturn 1;\n\t}\n\n\tr2 = sraRgnCreateRect(x, y, x+w, y+h);\n\n\tn = get_bs_n(y);\n\tif (n >= 0) {\n\t\tr1 = rect_reg[n];\n\t\tsraRgnOr(r1, r2);\n\t\tok = 1;\n\t}\n\n\tif (zero_rects) {\n\t\tsraRgnOr(zero_rects, r2);\n\t\tx = cache_list[idx].su_x;\n\t\ty = cache_list[idx].su_y;\n\t\tw = cache_list[idx].su_w;\n\t\th = cache_list[idx].su_h;\n\t\tif (x >= 0) {\n\t\t\tsraRgnDestroy(r2);\n\t\t\tr2 = sraRgnCreateRect(x, y, x+w, y+h);\n\t\t\tsraRgnOr(zero_rects, r2);\n\t\t}\n\t}\n\tsraRgnDestroy(r2);\n\n\tCLEAR(idx);\nif (! ok && ncdb) fprintf(stderr, \"**** free_rect: not-found %d\\n\", idx);\n\treturn ok;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strtok",
          "args": [
            "NULL",
            "\", \\t\""
          ],
          "line": 132
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"too many blackouts: %d\\n\"",
            "blackouts"
          ],
          "line": 128
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"blackout rect: %s: x=%d-%d y=%d-%d\\n\"",
            "p",
            "x",
            "X",
            "y",
            "Y"
          ],
          "line": 114
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"skipping invalid blackout geometry: %s x=\"\n\t\t\t    \"%d-%d,y=%d-%d,w=%d,h=%d\\n\"",
            "p",
            "x",
            "X",
            "y",
            "Y",
            "w",
            "h"
          ],
          "line": 111
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfix",
          "args": [
            "Y - coff_y",
            "wdpy_y"
          ],
          "line": 106
        },
        "resolved": true,
        "details": {
          "function_name": "nfix",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/util.c",
          "lines": "95-102",
          "snippet": "int nfix(int i, int n) {\n\tif (i < 0) {\n\t\ti = 0;\n\t} else if (i >= n) {\n\t\ti = n - 1;\n\t}\n\treturn i;\n}",
          "includes": [
            "#include \"connections.h\"",
            "#include \"unixpw.h\"",
            "#include \"win_utils.h\"",
            "#include \"cleanup.h\"",
            "#include \"x11vnc.h\"",
            "#include <stdlib.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int nfix(int i, int n);",
            "int nabs(int n);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"connections.h\"\n#include \"unixpw.h\"\n#include \"win_utils.h\"\n#include \"cleanup.h\"\n#include \"x11vnc.h\"\n#include <stdlib.h>\n\nint nfix(int i, int n);\nint nabs(int n);\n\nint nfix(int i, int n) {\n\tif (i < 0) {\n\t\ti = 0;\n\t} else if (i >= n) {\n\t\ti = n - 1;\n\t}\n\treturn i;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nabs",
          "args": [
            "h"
          ],
          "line": 88
        },
        "resolved": true,
        "details": {
          "function_name": "nabs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/util.c",
          "lines": "120-126",
          "snippet": "int nabs(int n) {\n\tif (n < 0) {\n\t\treturn -n;\n\t} else {\n\t\treturn n;\n\t}\n}",
          "includes": [
            "#include \"connections.h\"",
            "#include \"unixpw.h\"",
            "#include \"win_utils.h\"",
            "#include \"cleanup.h\"",
            "#include \"x11vnc.h\"",
            "#include <stdlib.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int nfix(int i, int n);",
            "int nabs(int n);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"connections.h\"\n#include \"unixpw.h\"\n#include \"win_utils.h\"\n#include \"cleanup.h\"\n#include \"x11vnc.h\"\n#include <stdlib.h>\n\nint nfix(int i, int n);\nint nabs(int n);\n\nint nabs(int n) {\n\tif (n < 0) {\n\t\treturn -n;\n\t} else {\n\t\treturn n;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "strtok",
          "args": [
            "NULL",
            "\", \\t\""
          ],
          "line": 84
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"skipping invalid geometry: %s\\n\"",
            "p"
          ],
          "line": 82
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "parse_geom",
          "args": [
            "p",
            "&w",
            "&h",
            "&x",
            "&y",
            "dpy_x",
            "dpy_y"
          ],
          "line": 80
        },
        "resolved": true,
        "details": {
          "function_name": "parse_geom",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/util.c",
          "lines": "210-237",
          "snippet": "int parse_geom(char *str, int *wp, int *hp, int *xp, int *yp, int W, int H) {\n\tint w, h, x, y;\n\tif (! str) {\n\t\treturn 0;\n\t}\n\t/* handle +/-x and +/-y */\n\tif (sscanf(str, \"%dx%d+%d+%d\", &w, &h, &x, &y) == 4) {\n\t\t;\n\t} else if (sscanf(str, \"%dx%d-%d+%d\", &w, &h, &x, &y) == 4) {\n\t\tw = nabs(w);\n\t\tx = W - x - w;\n\t} else if (sscanf(str, \"%dx%d+%d-%d\", &w, &h, &x, &y) == 4) {\n\t\th = nabs(h);\n\t\ty = H - y - h;\n\t} else if (sscanf(str, \"%dx%d-%d-%d\", &w, &h, &x, &y) == 4) {\n\t\tw = nabs(w);\n\t\th = nabs(h);\n\t\tx = W - x - w;\n\t\ty = H - y - h;\n\t} else {\n\t\treturn 0;\n\t}\n\t*wp = w;\n\t*hp = h;\n\t*xp = x;\n\t*yp = y;\n\treturn 1;\n}",
          "includes": [
            "#include \"connections.h\"",
            "#include \"unixpw.h\"",
            "#include \"win_utils.h\"",
            "#include \"cleanup.h\"",
            "#include \"x11vnc.h\"",
            "#include <stdlib.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "double dabs(double x);",
            "void lowercase(char *str);",
            "void uppercase(char *str);",
            "char *lblanks(char *str);",
            "void strzero(char *str);",
            "int parse_geom(char *str, int *wp, int *hp, int *xp, int *yp, int W, int H);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"connections.h\"\n#include \"unixpw.h\"\n#include \"win_utils.h\"\n#include \"cleanup.h\"\n#include \"x11vnc.h\"\n#include <stdlib.h>\n\ndouble dabs(double x);\nvoid lowercase(char *str);\nvoid uppercase(char *str);\nchar *lblanks(char *str);\nvoid strzero(char *str);\nint parse_geom(char *str, int *wp, int *hp, int *xp, int *yp, int W, int H);\n\nint parse_geom(char *str, int *wp, int *hp, int *xp, int *yp, int W, int H) {\n\tint w, h, x, y;\n\tif (! str) {\n\t\treturn 0;\n\t}\n\t/* handle +/-x and +/-y */\n\tif (sscanf(str, \"%dx%d+%d+%d\", &w, &h, &x, &y) == 4) {\n\t\t;\n\t} else if (sscanf(str, \"%dx%d-%d+%d\", &w, &h, &x, &y) == 4) {\n\t\tw = nabs(w);\n\t\tx = W - x - w;\n\t} else if (sscanf(str, \"%dx%d+%d-%d\", &w, &h, &x, &y) == 4) {\n\t\th = nabs(h);\n\t\ty = H - y - h;\n\t} else if (sscanf(str, \"%dx%d-%d-%d\", &w, &h, &x, &y) == 4) {\n\t\tw = nabs(w);\n\t\th = nabs(h);\n\t\tx = W - x - w;\n\t\ty = H - y - h;\n\t} else {\n\t\treturn 0;\n\t}\n\t*wp = w;\n\t*hp = h;\n\t*xp = x;\n\t*yp = y;\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strtok",
          "args": [
            "NULL",
            "\", \\t\""
          ],
          "line": 77
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"pointer will be blocked from blackout \"\n\t\t\t    \"regions\\n\""
          ],
          "line": 75
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "\"noptr\"",
            "p"
          ],
          "line": 73
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strtok",
          "args": [
            "blist",
            "\", \\t\""
          ],
          "line": 71
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "list"
          ],
          "line": 68
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"scan.h\"\n#include \"blackout_t.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\n#define BLACKR_MAX 100\n\nblackout_t blackr[BLACKR_MAX];\nint blackouts = 0;\nvoid push_sleep(int n);\nvoid push_black_screen(int n);\nvoid zero_fb(int x1, int y1, int x2, int y2);\nstatic void initialize_blackouts(char *list);\n\nstatic void initialize_blackouts(char *list) {\n\tchar *p, *blist = strdup(list);\n\tint x, y, X, Y, h, w, t;\n\n\tp = strtok(blist, \", \\t\");\n\twhile (p) {\n\t\tif (!strcmp(\"noptr\", p)) {\n\t\t\tblackout_ptr = 1;\n\t\t\trfbLog(\"pointer will be blocked from blackout \"\n\t\t\t    \"regions\\n\");\n\t\t\tp = strtok(NULL, \", \\t\");\n\t\t\tcontinue;\n\t\t}\n\t\tif (! parse_geom(p, &w, &h, &x, &y, dpy_x, dpy_y)) {\n\t\t\tif (*p != '\\0') {\n\t\t\t\trfbLog(\"skipping invalid geometry: %s\\n\", p);\n\t\t\t}\n\t\t\tp = strtok(NULL, \", \\t\");\n\t\t\tcontinue;\n\t\t}\n\t\tw = nabs(w);\n\t\th = nabs(h);\n\t\tx = nfix(x, dpy_x);\n\t\ty = nfix(y, dpy_y);\n\t\tX = x + w;\n\t\tY = y + h;\n\t\tX = nfix(X, dpy_x+1);\n\t\tY = nfix(Y, dpy_y+1);\n\t\tif (x > X) {\n\t\t\tt = X; X = x; x = t;\n\t\t}\n\t\tif (y > Y) {\n\t\t\tt = Y; Y = y; y = t;\n\t\t}\n\n\t\t/* take clipping region into account */\n\t\tx = nfix(x - coff_x, wdpy_x);\n\t\tX = nfix(X - coff_x, wdpy_x);\n\t\ty = nfix(y - coff_y, wdpy_y);\n\t\tY = nfix(Y - coff_y, wdpy_y);\n\n\t\tif (x < 0 || x > dpy_x || y < 0 || y > dpy_y ||\n\t\t    X < 0 || X > dpy_x || Y < 0 || Y > dpy_y ||\n\t\t    x == X || y == Y) {\n\t\t\trfbLog(\"skipping invalid blackout geometry: %s x=\"\n\t\t\t    \"%d-%d,y=%d-%d,w=%d,h=%d\\n\", p, x, X, y, Y, w, h);\n\t\t} else {\n\t\t\trfbLog(\"blackout rect: %s: x=%d-%d y=%d-%d\\n\", p,\n\t\t\t    x, X, y, Y);\n\n\t\t\t/*\n\t\t\t * note that the black out is x1 <= x but x < x2\n\t\t\t * for the region. i.e. the x2, y2 are outside\n\t\t\t * by 1 pixel. \n\t\t\t */\n\t\t\tblackr[blackouts].x1 = x;\n\t\t\tblackr[blackouts].y1 = y;\n\t\t\tblackr[blackouts].x2 = X;\n\t\t\tblackr[blackouts].y2 = Y;\n\t\t\tblackouts++;\n\t\t\tif (blackouts >= BLACKR_MAX) {\n\t\t\t\trfbLog(\"too many blackouts: %d\\n\", blackouts);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tp = strtok(NULL, \", \\t\");\n\t}\n\tfree(blist);\n}"
  }
]