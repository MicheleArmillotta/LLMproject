[
  {
    "function_name": "exit_hppfs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hppfs/hppfs.c",
    "lines": "759-762",
    "snippet": "static void __exit exit_hppfs(void)\n{\n\tunregister_filesystem(&hppfs_type);\n}",
    "includes": [
      "#include <os.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/namei.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/types.h>",
      "#include <linux/statfs.h>",
      "#include <linux/slab.h>",
      "#include <linux/mount.h>",
      "#include <linux/module.h>",
      "#include <linux/list.h>",
      "#include <linux/kernel.h>",
      "#include <linux/init.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/dcache.h>",
      "#include <linux/ctype.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct file_system_type hppfs_type = {\n\t.owner \t\t= THIS_MODULE,\n\t.name \t\t= \"hppfs\",\n\t.mount \t\t= hppfs_read_super,\n\t.kill_sb\t= kill_anon_super,\n\t.fs_flags \t= 0,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "unregister_filesystem",
          "args": [
            "&hppfs_type"
          ],
          "line": 761
        },
        "resolved": true,
        "details": {
          "function_name": "unregister_filesystem",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/filesystems.c",
          "lines": "101-120",
          "snippet": "int unregister_filesystem(struct file_system_type * fs)\n{\n\tstruct file_system_type ** tmp;\n\n\twrite_lock(&file_systems_lock);\n\ttmp = &file_systems;\n\twhile (*tmp) {\n\t\tif (fs == *tmp) {\n\t\t\t*tmp = fs->next;\n\t\t\tfs->next = NULL;\n\t\t\twrite_unlock(&file_systems_lock);\n\t\t\tsynchronize_rcu();\n\t\t\treturn 0;\n\t\t}\n\t\ttmp = &(*tmp)->next;\n\t}\n\twrite_unlock(&file_systems_lock);\n\n\treturn -EINVAL;\n}",
          "includes": [
            "#include <asm/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/kmod.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct file_system_type *file_systems;",
            "static DEFINE_RWLOCK(file_systems_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/uaccess.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kmod.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n\nstatic struct file_system_type *file_systems;\nstatic DEFINE_RWLOCK(file_systems_lock);\n\nint unregister_filesystem(struct file_system_type * fs)\n{\n\tstruct file_system_type ** tmp;\n\n\twrite_lock(&file_systems_lock);\n\ttmp = &file_systems;\n\twhile (*tmp) {\n\t\tif (fs == *tmp) {\n\t\t\t*tmp = fs->next;\n\t\t\tfs->next = NULL;\n\t\t\twrite_unlock(&file_systems_lock);\n\t\t\tsynchronize_rcu();\n\t\t\treturn 0;\n\t\t}\n\t\ttmp = &(*tmp)->next;\n\t}\n\twrite_unlock(&file_systems_lock);\n\n\treturn -EINVAL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <os.h>\n#include <asm/uaccess.h>\n#include <linux/namei.h>\n#include <linux/pid_namespace.h>\n#include <linux/types.h>\n#include <linux/statfs.h>\n#include <linux/slab.h>\n#include <linux/mount.h>\n#include <linux/module.h>\n#include <linux/list.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/dcache.h>\n#include <linux/ctype.h>\n\nstatic struct file_system_type hppfs_type = {\n\t.owner \t\t= THIS_MODULE,\n\t.name \t\t= \"hppfs\",\n\t.mount \t\t= hppfs_read_super,\n\t.kill_sb\t= kill_anon_super,\n\t.fs_flags \t= 0,\n};\n\nstatic void __exit exit_hppfs(void)\n{\n\tunregister_filesystem(&hppfs_type);\n}"
  },
  {
    "function_name": "init_hppfs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hppfs/hppfs.c",
    "lines": "754-757",
    "snippet": "static int __init init_hppfs(void)\n{\n\treturn register_filesystem(&hppfs_type);\n}",
    "includes": [
      "#include <os.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/namei.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/types.h>",
      "#include <linux/statfs.h>",
      "#include <linux/slab.h>",
      "#include <linux/mount.h>",
      "#include <linux/module.h>",
      "#include <linux/list.h>",
      "#include <linux/kernel.h>",
      "#include <linux/init.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/dcache.h>",
      "#include <linux/ctype.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct file_system_type hppfs_type = {\n\t.owner \t\t= THIS_MODULE,\n\t.name \t\t= \"hppfs\",\n\t.mount \t\t= hppfs_read_super,\n\t.kill_sb\t= kill_anon_super,\n\t.fs_flags \t= 0,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "register_filesystem",
          "args": [
            "&hppfs_type"
          ],
          "line": 756
        },
        "resolved": true,
        "details": {
          "function_name": "unregister_filesystem",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/filesystems.c",
          "lines": "101-120",
          "snippet": "int unregister_filesystem(struct file_system_type * fs)\n{\n\tstruct file_system_type ** tmp;\n\n\twrite_lock(&file_systems_lock);\n\ttmp = &file_systems;\n\twhile (*tmp) {\n\t\tif (fs == *tmp) {\n\t\t\t*tmp = fs->next;\n\t\t\tfs->next = NULL;\n\t\t\twrite_unlock(&file_systems_lock);\n\t\t\tsynchronize_rcu();\n\t\t\treturn 0;\n\t\t}\n\t\ttmp = &(*tmp)->next;\n\t}\n\twrite_unlock(&file_systems_lock);\n\n\treturn -EINVAL;\n}",
          "includes": [
            "#include <asm/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/kmod.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct file_system_type *file_systems;",
            "static DEFINE_RWLOCK(file_systems_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/uaccess.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kmod.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n\nstatic struct file_system_type *file_systems;\nstatic DEFINE_RWLOCK(file_systems_lock);\n\nint unregister_filesystem(struct file_system_type * fs)\n{\n\tstruct file_system_type ** tmp;\n\n\twrite_lock(&file_systems_lock);\n\ttmp = &file_systems;\n\twhile (*tmp) {\n\t\tif (fs == *tmp) {\n\t\t\t*tmp = fs->next;\n\t\t\tfs->next = NULL;\n\t\t\twrite_unlock(&file_systems_lock);\n\t\t\tsynchronize_rcu();\n\t\t\treturn 0;\n\t\t}\n\t\ttmp = &(*tmp)->next;\n\t}\n\twrite_unlock(&file_systems_lock);\n\n\treturn -EINVAL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <os.h>\n#include <asm/uaccess.h>\n#include <linux/namei.h>\n#include <linux/pid_namespace.h>\n#include <linux/types.h>\n#include <linux/statfs.h>\n#include <linux/slab.h>\n#include <linux/mount.h>\n#include <linux/module.h>\n#include <linux/list.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/dcache.h>\n#include <linux/ctype.h>\n\nstatic struct file_system_type hppfs_type = {\n\t.owner \t\t= THIS_MODULE,\n\t.name \t\t= \"hppfs\",\n\t.mount \t\t= hppfs_read_super,\n\t.kill_sb\t= kill_anon_super,\n\t.fs_flags \t= 0,\n};\n\nstatic int __init init_hppfs(void)\n{\n\treturn register_filesystem(&hppfs_type);\n}"
  },
  {
    "function_name": "hppfs_read_super",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hppfs/hppfs.c",
    "lines": "738-743",
    "snippet": "static struct dentry *hppfs_read_super(struct file_system_type *type,\n\t\t\t    int flags, const char *dev_name,\n\t\t\t    void *data)\n{\n\treturn mount_nodev(type, flags, data, hppfs_fill_super);\n}",
    "includes": [
      "#include <os.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/namei.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/types.h>",
      "#include <linux/statfs.h>",
      "#include <linux/slab.h>",
      "#include <linux/mount.h>",
      "#include <linux/module.h>",
      "#include <linux/list.h>",
      "#include <linux/kernel.h>",
      "#include <linux/init.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/dcache.h>",
      "#include <linux/ctype.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct inode *get_inode(struct super_block *, struct dentry *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mount_nodev",
          "args": [
            "type",
            "flags",
            "data",
            "hppfs_fill_super"
          ],
          "line": 742
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <os.h>\n#include <asm/uaccess.h>\n#include <linux/namei.h>\n#include <linux/pid_namespace.h>\n#include <linux/types.h>\n#include <linux/statfs.h>\n#include <linux/slab.h>\n#include <linux/mount.h>\n#include <linux/module.h>\n#include <linux/list.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/dcache.h>\n#include <linux/ctype.h>\n\nstatic struct inode *get_inode(struct super_block *, struct dentry *);\n\nstatic struct dentry *hppfs_read_super(struct file_system_type *type,\n\t\t\t    int flags, const char *dev_name,\n\t\t\t    void *data)\n{\n\treturn mount_nodev(type, flags, data, hppfs_fill_super);\n}"
  },
  {
    "function_name": "hppfs_fill_super",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hppfs/hppfs.c",
    "lines": "708-736",
    "snippet": "static int hppfs_fill_super(struct super_block *sb, void *d, int silent)\n{\n\tstruct inode *root_inode;\n\tstruct vfsmount *proc_mnt;\n\tint err = -ENOENT;\n\n\tproc_mnt = mntget(task_active_pid_ns(current)->proc_mnt);\n\tif (IS_ERR(proc_mnt))\n\t\tgoto out;\n\n\tsb->s_blocksize = 1024;\n\tsb->s_blocksize_bits = 10;\n\tsb->s_magic = HPPFS_SUPER_MAGIC;\n\tsb->s_op = &hppfs_sbops;\n\tsb->s_fs_info = proc_mnt;\n\n\terr = -ENOMEM;\n\troot_inode = get_inode(sb, dget(proc_mnt->mnt_root));\n\tsb->s_root = d_make_root(root_inode);\n\tif (!sb->s_root)\n\t\tgoto out_mntput;\n\n\treturn 0;\n\n out_mntput:\n\tmntput(proc_mnt);\n out:\n\treturn(err);\n}",
    "includes": [
      "#include <os.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/namei.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/types.h>",
      "#include <linux/statfs.h>",
      "#include <linux/slab.h>",
      "#include <linux/mount.h>",
      "#include <linux/module.h>",
      "#include <linux/list.h>",
      "#include <linux/kernel.h>",
      "#include <linux/init.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/dcache.h>",
      "#include <linux/ctype.h>"
    ],
    "macros_used": [
      "#define HPPFS_SUPER_MAGIC 0xb00000ee"
    ],
    "globals_used": [
      "static const struct super_operations hppfs_sbops;",
      "static const struct super_operations hppfs_sbops = {\n\t.alloc_inode\t= hppfs_alloc_inode,\n\t.destroy_inode\t= hppfs_destroy_inode,\n\t.evict_inode\t= hppfs_evict_inode,\n\t.statfs\t\t= hppfs_statfs,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mntput",
          "args": [
            "proc_mnt"
          ],
          "line": 733
        },
        "resolved": true,
        "details": {
          "function_name": "mntput",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namespace.c",
          "lines": "1118-1127",
          "snippet": "void mntput(struct vfsmount *mnt)\n{\n\tif (mnt) {\n\t\tstruct mount *m = real_mount(mnt);\n\t\t/* avoid cacheline pingpong, hope gcc doesn't get \"smart\" */\n\t\tif (unlikely(m->mnt_expiry_mark))\n\t\t\tm->mnt_expiry_mark = 0;\n\t\tmntput_no_expire(m);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"pnode.h\"",
            "#include <linux/task_work.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/magic.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
            "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
            "#include <linux/init.h>\t\t/* init_rootfs */",
            "#include <linux/idr.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/mnt_namespace.h>",
            "#include <linux/capability.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void shrink_submounts(struct mount *mnt);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/task_work.h>\n#include <linux/bootmem.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic void shrink_submounts(struct mount *mnt);\n\nvoid mntput(struct vfsmount *mnt)\n{\n\tif (mnt) {\n\t\tstruct mount *m = real_mount(mnt);\n\t\t/* avoid cacheline pingpong, hope gcc doesn't get \"smart\" */\n\t\tif (unlikely(m->mnt_expiry_mark))\n\t\t\tm->mnt_expiry_mark = 0;\n\t\tmntput_no_expire(m);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "d_make_root",
          "args": [
            "root_inode"
          ],
          "line": 726
        },
        "resolved": true,
        "details": {
          "function_name": "d_make_root",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "1857-1871",
          "snippet": "struct dentry *d_make_root(struct inode *root_inode)\n{\n\tstruct dentry *res = NULL;\n\n\tif (root_inode) {\n\t\tstatic const struct qstr name = QSTR_INIT(\"/\", 1);\n\n\t\tres = __d_alloc(root_inode->i_sb, &name);\n\t\tif (res)\n\t\t\td_instantiate(res, root_inode);\n\t\telse\n\t\t\tiput(root_inode);\n\t}\n\treturn res;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nstruct dentry *d_make_root(struct inode *root_inode)\n{\n\tstruct dentry *res = NULL;\n\n\tif (root_inode) {\n\t\tstatic const struct qstr name = QSTR_INIT(\"/\", 1);\n\n\t\tres = __d_alloc(root_inode->i_sb, &name);\n\t\tif (res)\n\t\t\td_instantiate(res, root_inode);\n\t\telse\n\t\t\tiput(root_inode);\n\t}\n\treturn res;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_inode",
          "args": [
            "sb",
            "dget(proc_mnt->mnt_root)"
          ],
          "line": 725
        },
        "resolved": true,
        "details": {
          "function_name": "get_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hppfs/hppfs.c",
          "lines": "671-706",
          "snippet": "static struct inode *get_inode(struct super_block *sb, struct dentry *dentry)\n{\n\tstruct inode *proc_ino = dentry->d_inode;\n\tstruct inode *inode = new_inode(sb);\n\n\tif (!inode) {\n\t\tdput(dentry);\n\t\treturn NULL;\n\t}\n\n\tif (d_is_dir(dentry)) {\n\t\tinode->i_op = &hppfs_dir_iops;\n\t\tinode->i_fop = &hppfs_dir_fops;\n\t} else if (d_is_symlink(dentry)) {\n\t\tinode->i_op = &hppfs_link_iops;\n\t\tinode->i_fop = &hppfs_file_fops;\n\t} else {\n\t\tinode->i_op = &hppfs_file_iops;\n\t\tinode->i_fop = &hppfs_file_fops;\n\t}\n\n\tHPPFS_I(inode)->proc_dentry = dentry;\n\n\tinode->i_uid = proc_ino->i_uid;\n\tinode->i_gid = proc_ino->i_gid;\n\tinode->i_atime = proc_ino->i_atime;\n\tinode->i_mtime = proc_ino->i_mtime;\n\tinode->i_ctime = proc_ino->i_ctime;\n\tinode->i_ino = proc_ino->i_ino;\n\tinode->i_mode = proc_ino->i_mode;\n\tset_nlink(inode, proc_ino->i_nlink);\n\tinode->i_size = proc_ino->i_size;\n\tinode->i_blocks = proc_ino->i_blocks;\n\n\treturn inode;\n}",
          "includes": [
            "#include <os.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/namei.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/types.h>",
            "#include <linux/statfs.h>",
            "#include <linux/slab.h>",
            "#include <linux/mount.h>",
            "#include <linux/module.h>",
            "#include <linux/list.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/dcache.h>",
            "#include <linux/ctype.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct inode *get_inode(struct super_block *, struct dentry *);",
            "static const struct inode_operations hppfs_file_iops = {\n};",
            "static const struct file_operations hppfs_file_fops = {\n\t.owner\t\t= NULL,\n\t.llseek\t\t= hppfs_llseek,\n\t.read\t\t= hppfs_read,\n\t.write\t\t= hppfs_write,\n\t.open\t\t= hppfs_open,\n\t.release\t= hppfs_release,\n};",
            "static const struct file_operations hppfs_dir_fops = {\n\t.owner\t\t= NULL,\n\t.iterate\t= hppfs_readdir,\n\t.open\t\t= hppfs_dir_open,\n\t.llseek\t\t= default_llseek,\n\t.release\t= hppfs_release,\n};",
            "static const struct inode_operations hppfs_dir_iops = {\n\t.lookup\t\t= hppfs_lookup,\n};",
            "static const struct inode_operations hppfs_link_iops = {\n\t.readlink\t= hppfs_readlink,\n\t.follow_link\t= hppfs_follow_link,\n\t.put_link\t= hppfs_put_link,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <os.h>\n#include <asm/uaccess.h>\n#include <linux/namei.h>\n#include <linux/pid_namespace.h>\n#include <linux/types.h>\n#include <linux/statfs.h>\n#include <linux/slab.h>\n#include <linux/mount.h>\n#include <linux/module.h>\n#include <linux/list.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/dcache.h>\n#include <linux/ctype.h>\n\nstatic struct inode *get_inode(struct super_block *, struct dentry *);\nstatic const struct inode_operations hppfs_file_iops = {\n};\nstatic const struct file_operations hppfs_file_fops = {\n\t.owner\t\t= NULL,\n\t.llseek\t\t= hppfs_llseek,\n\t.read\t\t= hppfs_read,\n\t.write\t\t= hppfs_write,\n\t.open\t\t= hppfs_open,\n\t.release\t= hppfs_release,\n};\nstatic const struct file_operations hppfs_dir_fops = {\n\t.owner\t\t= NULL,\n\t.iterate\t= hppfs_readdir,\n\t.open\t\t= hppfs_dir_open,\n\t.llseek\t\t= default_llseek,\n\t.release\t= hppfs_release,\n};\nstatic const struct inode_operations hppfs_dir_iops = {\n\t.lookup\t\t= hppfs_lookup,\n};\nstatic const struct inode_operations hppfs_link_iops = {\n\t.readlink\t= hppfs_readlink,\n\t.follow_link\t= hppfs_follow_link,\n\t.put_link\t= hppfs_put_link,\n};\n\nstatic struct inode *get_inode(struct super_block *sb, struct dentry *dentry)\n{\n\tstruct inode *proc_ino = dentry->d_inode;\n\tstruct inode *inode = new_inode(sb);\n\n\tif (!inode) {\n\t\tdput(dentry);\n\t\treturn NULL;\n\t}\n\n\tif (d_is_dir(dentry)) {\n\t\tinode->i_op = &hppfs_dir_iops;\n\t\tinode->i_fop = &hppfs_dir_fops;\n\t} else if (d_is_symlink(dentry)) {\n\t\tinode->i_op = &hppfs_link_iops;\n\t\tinode->i_fop = &hppfs_file_fops;\n\t} else {\n\t\tinode->i_op = &hppfs_file_iops;\n\t\tinode->i_fop = &hppfs_file_fops;\n\t}\n\n\tHPPFS_I(inode)->proc_dentry = dentry;\n\n\tinode->i_uid = proc_ino->i_uid;\n\tinode->i_gid = proc_ino->i_gid;\n\tinode->i_atime = proc_ino->i_atime;\n\tinode->i_mtime = proc_ino->i_mtime;\n\tinode->i_ctime = proc_ino->i_ctime;\n\tinode->i_ino = proc_ino->i_ino;\n\tinode->i_mode = proc_ino->i_mode;\n\tset_nlink(inode, proc_ino->i_nlink);\n\tinode->i_size = proc_ino->i_size;\n\tinode->i_blocks = proc_ino->i_blocks;\n\n\treturn inode;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dget",
          "args": [
            "proc_mnt->mnt_root"
          ],
          "line": 725
        },
        "resolved": true,
        "details": {
          "function_name": "dget_parent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "777-814",
          "snippet": "struct dentry *dget_parent(struct dentry *dentry)\n{\n\tint gotref;\n\tstruct dentry *ret;\n\n\t/*\n\t * Do optimistic parent lookup without any\n\t * locking.\n\t */\n\trcu_read_lock();\n\tret = ACCESS_ONCE(dentry->d_parent);\n\tgotref = lockref_get_not_zero(&ret->d_lockref);\n\trcu_read_unlock();\n\tif (likely(gotref)) {\n\t\tif (likely(ret == ACCESS_ONCE(dentry->d_parent)))\n\t\t\treturn ret;\n\t\tdput(ret);\n\t}\n\nrepeat:\n\t/*\n\t * Don't need rcu_dereference because we re-check it was correct under\n\t * the lock.\n\t */\n\trcu_read_lock();\n\tret = dentry->d_parent;\n\tspin_lock(&ret->d_lock);\n\tif (unlikely(ret != dentry->d_parent)) {\n\t\tspin_unlock(&ret->d_lock);\n\t\trcu_read_unlock();\n\t\tgoto repeat;\n\t}\n\trcu_read_unlock();\n\tBUG_ON(!ret->d_lockref.count);\n\tret->d_lockref.count++;\n\tspin_unlock(&ret->d_lock);\n\treturn ret;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nstruct dentry *dget_parent(struct dentry *dentry)\n{\n\tint gotref;\n\tstruct dentry *ret;\n\n\t/*\n\t * Do optimistic parent lookup without any\n\t * locking.\n\t */\n\trcu_read_lock();\n\tret = ACCESS_ONCE(dentry->d_parent);\n\tgotref = lockref_get_not_zero(&ret->d_lockref);\n\trcu_read_unlock();\n\tif (likely(gotref)) {\n\t\tif (likely(ret == ACCESS_ONCE(dentry->d_parent)))\n\t\t\treturn ret;\n\t\tdput(ret);\n\t}\n\nrepeat:\n\t/*\n\t * Don't need rcu_dereference because we re-check it was correct under\n\t * the lock.\n\t */\n\trcu_read_lock();\n\tret = dentry->d_parent;\n\tspin_lock(&ret->d_lock);\n\tif (unlikely(ret != dentry->d_parent)) {\n\t\tspin_unlock(&ret->d_lock);\n\t\trcu_read_unlock();\n\t\tgoto repeat;\n\t}\n\trcu_read_unlock();\n\tBUG_ON(!ret->d_lockref.count);\n\tret->d_lockref.count++;\n\tspin_unlock(&ret->d_lock);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "proc_mnt"
          ],
          "line": 715
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mntget",
          "args": [
            "task_active_pid_ns(current)->proc_mnt"
          ],
          "line": 714
        },
        "resolved": true,
        "details": {
          "function_name": "mntget",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namespace.c",
          "lines": "1130-1135",
          "snippet": "struct vfsmount *mntget(struct vfsmount *mnt)\n{\n\tif (mnt)\n\t\tmnt_add_count(real_mount(mnt), 1);\n\treturn mnt;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"pnode.h\"",
            "#include <linux/task_work.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/magic.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
            "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
            "#include <linux/init.h>\t\t/* init_rootfs */",
            "#include <linux/idr.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/mnt_namespace.h>",
            "#include <linux/capability.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void shrink_submounts(struct mount *mnt);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/task_work.h>\n#include <linux/bootmem.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic void shrink_submounts(struct mount *mnt);\n\nstruct vfsmount *mntget(struct vfsmount *mnt)\n{\n\tif (mnt)\n\t\tmnt_add_count(real_mount(mnt), 1);\n\treturn mnt;\n}"
        }
      },
      {
        "call_info": {
          "callee": "task_active_pid_ns",
          "args": [
            "current"
          ],
          "line": 714
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <os.h>\n#include <asm/uaccess.h>\n#include <linux/namei.h>\n#include <linux/pid_namespace.h>\n#include <linux/types.h>\n#include <linux/statfs.h>\n#include <linux/slab.h>\n#include <linux/mount.h>\n#include <linux/module.h>\n#include <linux/list.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/dcache.h>\n#include <linux/ctype.h>\n\n#define HPPFS_SUPER_MAGIC 0xb00000ee\n\nstatic const struct super_operations hppfs_sbops;\nstatic const struct super_operations hppfs_sbops = {\n\t.alloc_inode\t= hppfs_alloc_inode,\n\t.destroy_inode\t= hppfs_destroy_inode,\n\t.evict_inode\t= hppfs_evict_inode,\n\t.statfs\t\t= hppfs_statfs,\n};\n\nstatic int hppfs_fill_super(struct super_block *sb, void *d, int silent)\n{\n\tstruct inode *root_inode;\n\tstruct vfsmount *proc_mnt;\n\tint err = -ENOENT;\n\n\tproc_mnt = mntget(task_active_pid_ns(current)->proc_mnt);\n\tif (IS_ERR(proc_mnt))\n\t\tgoto out;\n\n\tsb->s_blocksize = 1024;\n\tsb->s_blocksize_bits = 10;\n\tsb->s_magic = HPPFS_SUPER_MAGIC;\n\tsb->s_op = &hppfs_sbops;\n\tsb->s_fs_info = proc_mnt;\n\n\terr = -ENOMEM;\n\troot_inode = get_inode(sb, dget(proc_mnt->mnt_root));\n\tsb->s_root = d_make_root(root_inode);\n\tif (!sb->s_root)\n\t\tgoto out_mntput;\n\n\treturn 0;\n\n out_mntput:\n\tmntput(proc_mnt);\n out:\n\treturn(err);\n}"
  },
  {
    "function_name": "get_inode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hppfs/hppfs.c",
    "lines": "671-706",
    "snippet": "static struct inode *get_inode(struct super_block *sb, struct dentry *dentry)\n{\n\tstruct inode *proc_ino = dentry->d_inode;\n\tstruct inode *inode = new_inode(sb);\n\n\tif (!inode) {\n\t\tdput(dentry);\n\t\treturn NULL;\n\t}\n\n\tif (d_is_dir(dentry)) {\n\t\tinode->i_op = &hppfs_dir_iops;\n\t\tinode->i_fop = &hppfs_dir_fops;\n\t} else if (d_is_symlink(dentry)) {\n\t\tinode->i_op = &hppfs_link_iops;\n\t\tinode->i_fop = &hppfs_file_fops;\n\t} else {\n\t\tinode->i_op = &hppfs_file_iops;\n\t\tinode->i_fop = &hppfs_file_fops;\n\t}\n\n\tHPPFS_I(inode)->proc_dentry = dentry;\n\n\tinode->i_uid = proc_ino->i_uid;\n\tinode->i_gid = proc_ino->i_gid;\n\tinode->i_atime = proc_ino->i_atime;\n\tinode->i_mtime = proc_ino->i_mtime;\n\tinode->i_ctime = proc_ino->i_ctime;\n\tinode->i_ino = proc_ino->i_ino;\n\tinode->i_mode = proc_ino->i_mode;\n\tset_nlink(inode, proc_ino->i_nlink);\n\tinode->i_size = proc_ino->i_size;\n\tinode->i_blocks = proc_ino->i_blocks;\n\n\treturn inode;\n}",
    "includes": [
      "#include <os.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/namei.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/types.h>",
      "#include <linux/statfs.h>",
      "#include <linux/slab.h>",
      "#include <linux/mount.h>",
      "#include <linux/module.h>",
      "#include <linux/list.h>",
      "#include <linux/kernel.h>",
      "#include <linux/init.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/dcache.h>",
      "#include <linux/ctype.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct inode *get_inode(struct super_block *, struct dentry *);",
      "static const struct inode_operations hppfs_file_iops = {\n};",
      "static const struct file_operations hppfs_file_fops = {\n\t.owner\t\t= NULL,\n\t.llseek\t\t= hppfs_llseek,\n\t.read\t\t= hppfs_read,\n\t.write\t\t= hppfs_write,\n\t.open\t\t= hppfs_open,\n\t.release\t= hppfs_release,\n};",
      "static const struct file_operations hppfs_dir_fops = {\n\t.owner\t\t= NULL,\n\t.iterate\t= hppfs_readdir,\n\t.open\t\t= hppfs_dir_open,\n\t.llseek\t\t= default_llseek,\n\t.release\t= hppfs_release,\n};",
      "static const struct inode_operations hppfs_dir_iops = {\n\t.lookup\t\t= hppfs_lookup,\n};",
      "static const struct inode_operations hppfs_link_iops = {\n\t.readlink\t= hppfs_readlink,\n\t.follow_link\t= hppfs_follow_link,\n\t.put_link\t= hppfs_put_link,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "set_nlink",
          "args": [
            "inode",
            "proc_ino->i_nlink"
          ],
          "line": 701
        },
        "resolved": true,
        "details": {
          "function_name": "set_nlink",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "305-316",
          "snippet": "void set_nlink(struct inode *inode, unsigned int nlink)\n{\n\tif (!nlink) {\n\t\tclear_nlink(inode);\n\t} else {\n\t\t/* Yes, some filesystems do change nlink from zero to one */\n\t\tif (inode->i_nlink == 0)\n\t\t\tatomic_long_dec(&inode->i_sb->s_remove_count);\n\n\t\tinode->__i_nlink = nlink;\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid set_nlink(struct inode *inode, unsigned int nlink)\n{\n\tif (!nlink) {\n\t\tclear_nlink(inode);\n\t} else {\n\t\t/* Yes, some filesystems do change nlink from zero to one */\n\t\tif (inode->i_nlink == 0)\n\t\t\tatomic_long_dec(&inode->i_sb->s_remove_count);\n\n\t\tinode->__i_nlink = nlink;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "HPPFS_I",
          "args": [
            "inode"
          ],
          "line": 692
        },
        "resolved": true,
        "details": {
          "function_name": "HPPFS_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hppfs/hppfs.c",
          "lines": "42-45",
          "snippet": "static inline struct hppfs_inode_info *HPPFS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct hppfs_inode_info, vfs_inode);\n}",
          "includes": [
            "#include <os.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/namei.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/types.h>",
            "#include <linux/statfs.h>",
            "#include <linux/slab.h>",
            "#include <linux/mount.h>",
            "#include <linux/module.h>",
            "#include <linux/list.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/dcache.h>",
            "#include <linux/ctype.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <os.h>\n#include <asm/uaccess.h>\n#include <linux/namei.h>\n#include <linux/pid_namespace.h>\n#include <linux/types.h>\n#include <linux/statfs.h>\n#include <linux/slab.h>\n#include <linux/mount.h>\n#include <linux/module.h>\n#include <linux/list.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/dcache.h>\n#include <linux/ctype.h>\n\nstatic inline struct hppfs_inode_info *HPPFS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct hppfs_inode_info, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "d_is_symlink",
          "args": [
            "dentry"
          ],
          "line": 684
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "d_is_dir",
          "args": [
            "dentry"
          ],
          "line": 681
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dput",
          "args": [
            "dentry"
          ],
          "line": 677
        },
        "resolved": true,
        "details": {
          "function_name": "dput",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "726-762",
          "snippet": "void dput(struct dentry *dentry)\n{\n\tif (unlikely(!dentry))\n\t\treturn;\n\nrepeat:\n\trcu_read_lock();\n\tif (likely(fast_dput(dentry))) {\n\t\trcu_read_unlock();\n\t\treturn;\n\t}\n\n\t/* Slow case: now with the dentry lock held */\n\trcu_read_unlock();\n\n\t/* Unreachable? Get rid of it */\n\tif (unlikely(d_unhashed(dentry)))\n\t\tgoto kill_it;\n\n\tif (unlikely(dentry->d_flags & DCACHE_OP_DELETE)) {\n\t\tif (dentry->d_op->d_delete(dentry))\n\t\t\tgoto kill_it;\n\t}\n\n\tif (!(dentry->d_flags & DCACHE_REFERENCED))\n\t\tdentry->d_flags |= DCACHE_REFERENCED;\n\tdentry_lru_add(dentry);\n\n\tdentry->d_lockref.count--;\n\tspin_unlock(&dentry->d_lock);\n\treturn;\n\nkill_it:\n\tdentry = dentry_kill(dentry);\n\tif (dentry)\n\t\tgoto repeat;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nvoid dput(struct dentry *dentry)\n{\n\tif (unlikely(!dentry))\n\t\treturn;\n\nrepeat:\n\trcu_read_lock();\n\tif (likely(fast_dput(dentry))) {\n\t\trcu_read_unlock();\n\t\treturn;\n\t}\n\n\t/* Slow case: now with the dentry lock held */\n\trcu_read_unlock();\n\n\t/* Unreachable? Get rid of it */\n\tif (unlikely(d_unhashed(dentry)))\n\t\tgoto kill_it;\n\n\tif (unlikely(dentry->d_flags & DCACHE_OP_DELETE)) {\n\t\tif (dentry->d_op->d_delete(dentry))\n\t\t\tgoto kill_it;\n\t}\n\n\tif (!(dentry->d_flags & DCACHE_REFERENCED))\n\t\tdentry->d_flags |= DCACHE_REFERENCED;\n\tdentry_lru_add(dentry);\n\n\tdentry->d_lockref.count--;\n\tspin_unlock(&dentry->d_lock);\n\treturn;\n\nkill_it:\n\tdentry = dentry_kill(dentry);\n\tif (dentry)\n\t\tgoto repeat;\n}"
        }
      },
      {
        "call_info": {
          "callee": "new_inode",
          "args": [
            "sb"
          ],
          "line": 674
        },
        "resolved": true,
        "details": {
          "function_name": "unlock_new_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "924-933",
          "snippet": "void unlock_new_inode(struct inode *inode)\n{\n\tlockdep_annotate_inode_mutex_key(inode);\n\tspin_lock(&inode->i_lock);\n\tWARN_ON(!(inode->i_state & I_NEW));\n\tinode->i_state &= ~I_NEW;\n\tsmp_mb();\n\twake_up_bit(&inode->i_state, __I_NEW);\n\tspin_unlock(&inode->i_lock);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid unlock_new_inode(struct inode *inode)\n{\n\tlockdep_annotate_inode_mutex_key(inode);\n\tspin_lock(&inode->i_lock);\n\tWARN_ON(!(inode->i_state & I_NEW));\n\tinode->i_state &= ~I_NEW;\n\tsmp_mb();\n\twake_up_bit(&inode->i_state, __I_NEW);\n\tspin_unlock(&inode->i_lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <os.h>\n#include <asm/uaccess.h>\n#include <linux/namei.h>\n#include <linux/pid_namespace.h>\n#include <linux/types.h>\n#include <linux/statfs.h>\n#include <linux/slab.h>\n#include <linux/mount.h>\n#include <linux/module.h>\n#include <linux/list.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/dcache.h>\n#include <linux/ctype.h>\n\nstatic struct inode *get_inode(struct super_block *, struct dentry *);\nstatic const struct inode_operations hppfs_file_iops = {\n};\nstatic const struct file_operations hppfs_file_fops = {\n\t.owner\t\t= NULL,\n\t.llseek\t\t= hppfs_llseek,\n\t.read\t\t= hppfs_read,\n\t.write\t\t= hppfs_write,\n\t.open\t\t= hppfs_open,\n\t.release\t= hppfs_release,\n};\nstatic const struct file_operations hppfs_dir_fops = {\n\t.owner\t\t= NULL,\n\t.iterate\t= hppfs_readdir,\n\t.open\t\t= hppfs_dir_open,\n\t.llseek\t\t= default_llseek,\n\t.release\t= hppfs_release,\n};\nstatic const struct inode_operations hppfs_dir_iops = {\n\t.lookup\t\t= hppfs_lookup,\n};\nstatic const struct inode_operations hppfs_link_iops = {\n\t.readlink\t= hppfs_readlink,\n\t.follow_link\t= hppfs_follow_link,\n\t.put_link\t= hppfs_put_link,\n};\n\nstatic struct inode *get_inode(struct super_block *sb, struct dentry *dentry)\n{\n\tstruct inode *proc_ino = dentry->d_inode;\n\tstruct inode *inode = new_inode(sb);\n\n\tif (!inode) {\n\t\tdput(dentry);\n\t\treturn NULL;\n\t}\n\n\tif (d_is_dir(dentry)) {\n\t\tinode->i_op = &hppfs_dir_iops;\n\t\tinode->i_fop = &hppfs_dir_fops;\n\t} else if (d_is_symlink(dentry)) {\n\t\tinode->i_op = &hppfs_link_iops;\n\t\tinode->i_fop = &hppfs_file_fops;\n\t} else {\n\t\tinode->i_op = &hppfs_file_iops;\n\t\tinode->i_fop = &hppfs_file_fops;\n\t}\n\n\tHPPFS_I(inode)->proc_dentry = dentry;\n\n\tinode->i_uid = proc_ino->i_uid;\n\tinode->i_gid = proc_ino->i_gid;\n\tinode->i_atime = proc_ino->i_atime;\n\tinode->i_mtime = proc_ino->i_mtime;\n\tinode->i_ctime = proc_ino->i_ctime;\n\tinode->i_ino = proc_ino->i_ino;\n\tinode->i_mode = proc_ino->i_mode;\n\tset_nlink(inode, proc_ino->i_nlink);\n\tinode->i_size = proc_ino->i_size;\n\tinode->i_blocks = proc_ino->i_blocks;\n\n\treturn inode;\n}"
  },
  {
    "function_name": "hppfs_put_link",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hppfs/hppfs.c",
    "lines": "652-659",
    "snippet": "static void hppfs_put_link(struct dentry *dentry, struct nameidata *nd,\n\t\t\t   void *cookie)\n{\n\tstruct dentry *proc_dentry = HPPFS_I(dentry->d_inode)->proc_dentry;\n\n\tif (proc_dentry->d_inode->i_op->put_link)\n\t\tproc_dentry->d_inode->i_op->put_link(proc_dentry, nd, cookie);\n}",
    "includes": [
      "#include <os.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/namei.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/types.h>",
      "#include <linux/statfs.h>",
      "#include <linux/slab.h>",
      "#include <linux/mount.h>",
      "#include <linux/module.h>",
      "#include <linux/list.h>",
      "#include <linux/kernel.h>",
      "#include <linux/init.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/dcache.h>",
      "#include <linux/ctype.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct inode *get_inode(struct super_block *, struct dentry *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "proc_dentry->d_inode->i_op->put_link",
          "args": [
            "proc_dentry",
            "nd",
            "cookie"
          ],
          "line": 658
        },
        "resolved": true,
        "details": {
          "function_name": "put_link",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namei.c",
          "lines": "729-735",
          "snippet": "static inline void put_link(struct nameidata *nd, struct path *link, void *cookie)\n{\n\tstruct inode *inode = link->dentry->d_inode;\n\tif (inode->i_op->put_link)\n\t\tinode->i_op->put_link(link->dentry, nd, cookie);\n\tpath_put(link);\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/hash.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/device_cgroup.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>",
            "#include <linux/audit.h>",
            "#include <linux/mount.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/ima.h>",
            "#include <linux/security.h>",
            "#include <linux/personality.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int link_path_walk(const char *, struct nameidata *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/hash.h>\n#include <linux/posix_acl.h>\n#include <linux/fs_struct.h>\n#include <linux/device_cgroup.h>\n#include <linux/fcntl.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n#include <linux/audit.h>\n#include <linux/mount.h>\n#include <linux/syscalls.h>\n#include <linux/ima.h>\n#include <linux/security.h>\n#include <linux/personality.h>\n#include <linux/fsnotify.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n#include <linux/init.h>\n\nstatic int link_path_walk(const char *, struct nameidata *);\n\nstatic inline void put_link(struct nameidata *nd, struct path *link, void *cookie)\n{\n\tstruct inode *inode = link->dentry->d_inode;\n\tif (inode->i_op->put_link)\n\t\tinode->i_op->put_link(link->dentry, nd, cookie);\n\tpath_put(link);\n}"
        }
      },
      {
        "call_info": {
          "callee": "HPPFS_I",
          "args": [
            "dentry->d_inode"
          ],
          "line": 655
        },
        "resolved": true,
        "details": {
          "function_name": "HPPFS_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hppfs/hppfs.c",
          "lines": "42-45",
          "snippet": "static inline struct hppfs_inode_info *HPPFS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct hppfs_inode_info, vfs_inode);\n}",
          "includes": [
            "#include <os.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/namei.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/types.h>",
            "#include <linux/statfs.h>",
            "#include <linux/slab.h>",
            "#include <linux/mount.h>",
            "#include <linux/module.h>",
            "#include <linux/list.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/dcache.h>",
            "#include <linux/ctype.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <os.h>\n#include <asm/uaccess.h>\n#include <linux/namei.h>\n#include <linux/pid_namespace.h>\n#include <linux/types.h>\n#include <linux/statfs.h>\n#include <linux/slab.h>\n#include <linux/mount.h>\n#include <linux/module.h>\n#include <linux/list.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/dcache.h>\n#include <linux/ctype.h>\n\nstatic inline struct hppfs_inode_info *HPPFS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct hppfs_inode_info, vfs_inode);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <os.h>\n#include <asm/uaccess.h>\n#include <linux/namei.h>\n#include <linux/pid_namespace.h>\n#include <linux/types.h>\n#include <linux/statfs.h>\n#include <linux/slab.h>\n#include <linux/mount.h>\n#include <linux/module.h>\n#include <linux/list.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/dcache.h>\n#include <linux/ctype.h>\n\nstatic struct inode *get_inode(struct super_block *, struct dentry *);\n\nstatic void hppfs_put_link(struct dentry *dentry, struct nameidata *nd,\n\t\t\t   void *cookie)\n{\n\tstruct dentry *proc_dentry = HPPFS_I(dentry->d_inode)->proc_dentry;\n\n\tif (proc_dentry->d_inode->i_op->put_link)\n\t\tproc_dentry->d_inode->i_op->put_link(proc_dentry, nd, cookie);\n}"
  },
  {
    "function_name": "hppfs_follow_link",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hppfs/hppfs.c",
    "lines": "645-650",
    "snippet": "static void *hppfs_follow_link(struct dentry *dentry, struct nameidata *nd)\n{\n\tstruct dentry *proc_dentry = HPPFS_I(dentry->d_inode)->proc_dentry;\n\n\treturn proc_dentry->d_inode->i_op->follow_link(proc_dentry, nd);\n}",
    "includes": [
      "#include <os.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/namei.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/types.h>",
      "#include <linux/statfs.h>",
      "#include <linux/slab.h>",
      "#include <linux/mount.h>",
      "#include <linux/module.h>",
      "#include <linux/list.h>",
      "#include <linux/kernel.h>",
      "#include <linux/init.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/dcache.h>",
      "#include <linux/ctype.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct inode *get_inode(struct super_block *, struct dentry *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "proc_dentry->d_inode->i_op->follow_link",
          "args": [
            "proc_dentry",
            "nd"
          ],
          "line": 649
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HPPFS_I",
          "args": [
            "dentry->d_inode"
          ],
          "line": 647
        },
        "resolved": true,
        "details": {
          "function_name": "HPPFS_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hppfs/hppfs.c",
          "lines": "42-45",
          "snippet": "static inline struct hppfs_inode_info *HPPFS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct hppfs_inode_info, vfs_inode);\n}",
          "includes": [
            "#include <os.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/namei.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/types.h>",
            "#include <linux/statfs.h>",
            "#include <linux/slab.h>",
            "#include <linux/mount.h>",
            "#include <linux/module.h>",
            "#include <linux/list.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/dcache.h>",
            "#include <linux/ctype.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <os.h>\n#include <asm/uaccess.h>\n#include <linux/namei.h>\n#include <linux/pid_namespace.h>\n#include <linux/types.h>\n#include <linux/statfs.h>\n#include <linux/slab.h>\n#include <linux/mount.h>\n#include <linux/module.h>\n#include <linux/list.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/dcache.h>\n#include <linux/ctype.h>\n\nstatic inline struct hppfs_inode_info *HPPFS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct hppfs_inode_info, vfs_inode);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <os.h>\n#include <asm/uaccess.h>\n#include <linux/namei.h>\n#include <linux/pid_namespace.h>\n#include <linux/types.h>\n#include <linux/statfs.h>\n#include <linux/slab.h>\n#include <linux/mount.h>\n#include <linux/module.h>\n#include <linux/list.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/dcache.h>\n#include <linux/ctype.h>\n\nstatic struct inode *get_inode(struct super_block *, struct dentry *);\n\nstatic void *hppfs_follow_link(struct dentry *dentry, struct nameidata *nd)\n{\n\tstruct dentry *proc_dentry = HPPFS_I(dentry->d_inode)->proc_dentry;\n\n\treturn proc_dentry->d_inode->i_op->follow_link(proc_dentry, nd);\n}"
  },
  {
    "function_name": "hppfs_readlink",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hppfs/hppfs.c",
    "lines": "637-643",
    "snippet": "static int hppfs_readlink(struct dentry *dentry, char __user *buffer,\n\t\t\t  int buflen)\n{\n\tstruct dentry *proc_dentry = HPPFS_I(dentry->d_inode)->proc_dentry;\n\treturn proc_dentry->d_inode->i_op->readlink(proc_dentry, buffer,\n\t\t\t\t\t\t    buflen);\n}",
    "includes": [
      "#include <os.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/namei.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/types.h>",
      "#include <linux/statfs.h>",
      "#include <linux/slab.h>",
      "#include <linux/mount.h>",
      "#include <linux/module.h>",
      "#include <linux/list.h>",
      "#include <linux/kernel.h>",
      "#include <linux/init.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/dcache.h>",
      "#include <linux/ctype.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct inode *get_inode(struct super_block *, struct dentry *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "proc_dentry->d_inode->i_op->readlink",
          "args": [
            "proc_dentry",
            "buffer",
            "buflen"
          ],
          "line": 641
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HPPFS_I",
          "args": [
            "dentry->d_inode"
          ],
          "line": 640
        },
        "resolved": true,
        "details": {
          "function_name": "HPPFS_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hppfs/hppfs.c",
          "lines": "42-45",
          "snippet": "static inline struct hppfs_inode_info *HPPFS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct hppfs_inode_info, vfs_inode);\n}",
          "includes": [
            "#include <os.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/namei.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/types.h>",
            "#include <linux/statfs.h>",
            "#include <linux/slab.h>",
            "#include <linux/mount.h>",
            "#include <linux/module.h>",
            "#include <linux/list.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/dcache.h>",
            "#include <linux/ctype.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <os.h>\n#include <asm/uaccess.h>\n#include <linux/namei.h>\n#include <linux/pid_namespace.h>\n#include <linux/types.h>\n#include <linux/statfs.h>\n#include <linux/slab.h>\n#include <linux/mount.h>\n#include <linux/module.h>\n#include <linux/list.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/dcache.h>\n#include <linux/ctype.h>\n\nstatic inline struct hppfs_inode_info *HPPFS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct hppfs_inode_info, vfs_inode);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <os.h>\n#include <asm/uaccess.h>\n#include <linux/namei.h>\n#include <linux/pid_namespace.h>\n#include <linux/types.h>\n#include <linux/statfs.h>\n#include <linux/slab.h>\n#include <linux/mount.h>\n#include <linux/module.h>\n#include <linux/list.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/dcache.h>\n#include <linux/ctype.h>\n\nstatic struct inode *get_inode(struct super_block *, struct dentry *);\n\nstatic int hppfs_readlink(struct dentry *dentry, char __user *buffer,\n\t\t\t  int buflen)\n{\n\tstruct dentry *proc_dentry = HPPFS_I(dentry->d_inode)->proc_dentry;\n\treturn proc_dentry->d_inode->i_op->readlink(proc_dentry, buffer,\n\t\t\t\t\t\t    buflen);\n}"
  },
  {
    "function_name": "hppfs_destroy_inode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hppfs/hppfs.c",
    "lines": "625-628",
    "snippet": "static void hppfs_destroy_inode(struct inode *inode)\n{\n\tcall_rcu(&inode->i_rcu, hppfs_i_callback);\n}",
    "includes": [
      "#include <os.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/namei.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/types.h>",
      "#include <linux/statfs.h>",
      "#include <linux/slab.h>",
      "#include <linux/mount.h>",
      "#include <linux/module.h>",
      "#include <linux/list.h>",
      "#include <linux/kernel.h>",
      "#include <linux/init.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/dcache.h>",
      "#include <linux/ctype.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "call_rcu",
          "args": [
            "&inode->i_rcu",
            "hppfs_i_callback"
          ],
          "line": 627
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <os.h>\n#include <asm/uaccess.h>\n#include <linux/namei.h>\n#include <linux/pid_namespace.h>\n#include <linux/types.h>\n#include <linux/statfs.h>\n#include <linux/slab.h>\n#include <linux/mount.h>\n#include <linux/module.h>\n#include <linux/list.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/dcache.h>\n#include <linux/ctype.h>\n\nstatic void hppfs_destroy_inode(struct inode *inode)\n{\n\tcall_rcu(&inode->i_rcu, hppfs_i_callback);\n}"
  },
  {
    "function_name": "hppfs_i_callback",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hppfs/hppfs.c",
    "lines": "619-623",
    "snippet": "static void hppfs_i_callback(struct rcu_head *head)\n{\n\tstruct inode *inode = container_of(head, struct inode, i_rcu);\n\tkfree(HPPFS_I(inode));\n}",
    "includes": [
      "#include <os.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/namei.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/types.h>",
      "#include <linux/statfs.h>",
      "#include <linux/slab.h>",
      "#include <linux/mount.h>",
      "#include <linux/module.h>",
      "#include <linux/list.h>",
      "#include <linux/kernel.h>",
      "#include <linux/init.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/dcache.h>",
      "#include <linux/ctype.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "HPPFS_I(inode)"
          ],
          "line": 622
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HPPFS_I",
          "args": [
            "inode"
          ],
          "line": 622
        },
        "resolved": true,
        "details": {
          "function_name": "HPPFS_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hppfs/hppfs.c",
          "lines": "42-45",
          "snippet": "static inline struct hppfs_inode_info *HPPFS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct hppfs_inode_info, vfs_inode);\n}",
          "includes": [
            "#include <os.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/namei.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/types.h>",
            "#include <linux/statfs.h>",
            "#include <linux/slab.h>",
            "#include <linux/mount.h>",
            "#include <linux/module.h>",
            "#include <linux/list.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/dcache.h>",
            "#include <linux/ctype.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <os.h>\n#include <asm/uaccess.h>\n#include <linux/namei.h>\n#include <linux/pid_namespace.h>\n#include <linux/types.h>\n#include <linux/statfs.h>\n#include <linux/slab.h>\n#include <linux/mount.h>\n#include <linux/module.h>\n#include <linux/list.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/dcache.h>\n#include <linux/ctype.h>\n\nstatic inline struct hppfs_inode_info *HPPFS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct hppfs_inode_info, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "head",
            "structinode",
            "i_rcu"
          ],
          "line": 621
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <os.h>\n#include <asm/uaccess.h>\n#include <linux/namei.h>\n#include <linux/pid_namespace.h>\n#include <linux/types.h>\n#include <linux/statfs.h>\n#include <linux/slab.h>\n#include <linux/mount.h>\n#include <linux/module.h>\n#include <linux/list.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/dcache.h>\n#include <linux/ctype.h>\n\nstatic void hppfs_i_callback(struct rcu_head *head)\n{\n\tstruct inode *inode = container_of(head, struct inode, i_rcu);\n\tkfree(HPPFS_I(inode));\n}"
  },
  {
    "function_name": "hppfs_evict_inode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hppfs/hppfs.c",
    "lines": "612-617",
    "snippet": "void hppfs_evict_inode(struct inode *ino)\n{\n\tclear_inode(ino);\n\tdput(HPPFS_I(ino)->proc_dentry);\n\tmntput(ino->i_sb->s_fs_info);\n}",
    "includes": [
      "#include <os.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/namei.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/types.h>",
      "#include <linux/statfs.h>",
      "#include <linux/slab.h>",
      "#include <linux/mount.h>",
      "#include <linux/module.h>",
      "#include <linux/list.h>",
      "#include <linux/kernel.h>",
      "#include <linux/init.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/dcache.h>",
      "#include <linux/ctype.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mntput",
          "args": [
            "ino->i_sb->s_fs_info"
          ],
          "line": 616
        },
        "resolved": true,
        "details": {
          "function_name": "mntput",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namespace.c",
          "lines": "1118-1127",
          "snippet": "void mntput(struct vfsmount *mnt)\n{\n\tif (mnt) {\n\t\tstruct mount *m = real_mount(mnt);\n\t\t/* avoid cacheline pingpong, hope gcc doesn't get \"smart\" */\n\t\tif (unlikely(m->mnt_expiry_mark))\n\t\t\tm->mnt_expiry_mark = 0;\n\t\tmntput_no_expire(m);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"pnode.h\"",
            "#include <linux/task_work.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/magic.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
            "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
            "#include <linux/init.h>\t\t/* init_rootfs */",
            "#include <linux/idr.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/mnt_namespace.h>",
            "#include <linux/capability.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void shrink_submounts(struct mount *mnt);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/task_work.h>\n#include <linux/bootmem.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic void shrink_submounts(struct mount *mnt);\n\nvoid mntput(struct vfsmount *mnt)\n{\n\tif (mnt) {\n\t\tstruct mount *m = real_mount(mnt);\n\t\t/* avoid cacheline pingpong, hope gcc doesn't get \"smart\" */\n\t\tif (unlikely(m->mnt_expiry_mark))\n\t\t\tm->mnt_expiry_mark = 0;\n\t\tmntput_no_expire(m);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "dput",
          "args": [
            "HPPFS_I(ino)->proc_dentry"
          ],
          "line": 615
        },
        "resolved": true,
        "details": {
          "function_name": "dput",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "726-762",
          "snippet": "void dput(struct dentry *dentry)\n{\n\tif (unlikely(!dentry))\n\t\treturn;\n\nrepeat:\n\trcu_read_lock();\n\tif (likely(fast_dput(dentry))) {\n\t\trcu_read_unlock();\n\t\treturn;\n\t}\n\n\t/* Slow case: now with the dentry lock held */\n\trcu_read_unlock();\n\n\t/* Unreachable? Get rid of it */\n\tif (unlikely(d_unhashed(dentry)))\n\t\tgoto kill_it;\n\n\tif (unlikely(dentry->d_flags & DCACHE_OP_DELETE)) {\n\t\tif (dentry->d_op->d_delete(dentry))\n\t\t\tgoto kill_it;\n\t}\n\n\tif (!(dentry->d_flags & DCACHE_REFERENCED))\n\t\tdentry->d_flags |= DCACHE_REFERENCED;\n\tdentry_lru_add(dentry);\n\n\tdentry->d_lockref.count--;\n\tspin_unlock(&dentry->d_lock);\n\treturn;\n\nkill_it:\n\tdentry = dentry_kill(dentry);\n\tif (dentry)\n\t\tgoto repeat;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nvoid dput(struct dentry *dentry)\n{\n\tif (unlikely(!dentry))\n\t\treturn;\n\nrepeat:\n\trcu_read_lock();\n\tif (likely(fast_dput(dentry))) {\n\t\trcu_read_unlock();\n\t\treturn;\n\t}\n\n\t/* Slow case: now with the dentry lock held */\n\trcu_read_unlock();\n\n\t/* Unreachable? Get rid of it */\n\tif (unlikely(d_unhashed(dentry)))\n\t\tgoto kill_it;\n\n\tif (unlikely(dentry->d_flags & DCACHE_OP_DELETE)) {\n\t\tif (dentry->d_op->d_delete(dentry))\n\t\t\tgoto kill_it;\n\t}\n\n\tif (!(dentry->d_flags & DCACHE_REFERENCED))\n\t\tdentry->d_flags |= DCACHE_REFERENCED;\n\tdentry_lru_add(dentry);\n\n\tdentry->d_lockref.count--;\n\tspin_unlock(&dentry->d_lock);\n\treturn;\n\nkill_it:\n\tdentry = dentry_kill(dentry);\n\tif (dentry)\n\t\tgoto repeat;\n}"
        }
      },
      {
        "call_info": {
          "callee": "HPPFS_I",
          "args": [
            "ino"
          ],
          "line": 615
        },
        "resolved": true,
        "details": {
          "function_name": "HPPFS_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hppfs/hppfs.c",
          "lines": "42-45",
          "snippet": "static inline struct hppfs_inode_info *HPPFS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct hppfs_inode_info, vfs_inode);\n}",
          "includes": [
            "#include <os.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/namei.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/types.h>",
            "#include <linux/statfs.h>",
            "#include <linux/slab.h>",
            "#include <linux/mount.h>",
            "#include <linux/module.h>",
            "#include <linux/list.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/dcache.h>",
            "#include <linux/ctype.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <os.h>\n#include <asm/uaccess.h>\n#include <linux/namei.h>\n#include <linux/pid_namespace.h>\n#include <linux/types.h>\n#include <linux/statfs.h>\n#include <linux/slab.h>\n#include <linux/mount.h>\n#include <linux/module.h>\n#include <linux/list.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/dcache.h>\n#include <linux/ctype.h>\n\nstatic inline struct hppfs_inode_info *HPPFS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct hppfs_inode_info, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "clear_inode",
          "args": [
            "ino"
          ],
          "line": 614
        },
        "resolved": true,
        "details": {
          "function_name": "clear_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "488-505",
          "snippet": "void clear_inode(struct inode *inode)\n{\n\tmight_sleep();\n\t/*\n\t * We have to cycle tree_lock here because reclaim can be still in the\n\t * process of removing the last page (in __delete_from_page_cache())\n\t * and we must not free mapping under it.\n\t */\n\tspin_lock_irq(&inode->i_data.tree_lock);\n\tBUG_ON(inode->i_data.nrpages);\n\tBUG_ON(inode->i_data.nrshadows);\n\tspin_unlock_irq(&inode->i_data.tree_lock);\n\tBUG_ON(!list_empty(&inode->i_data.private_list));\n\tBUG_ON(!(inode->i_state & I_FREEING));\n\tBUG_ON(inode->i_state & I_CLEAR);\n\t/* don't need i_lock here, no concurrent mods to i_state */\n\tinode->i_state = I_FREEING | I_CLEAR;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid clear_inode(struct inode *inode)\n{\n\tmight_sleep();\n\t/*\n\t * We have to cycle tree_lock here because reclaim can be still in the\n\t * process of removing the last page (in __delete_from_page_cache())\n\t * and we must not free mapping under it.\n\t */\n\tspin_lock_irq(&inode->i_data.tree_lock);\n\tBUG_ON(inode->i_data.nrpages);\n\tBUG_ON(inode->i_data.nrshadows);\n\tspin_unlock_irq(&inode->i_data.tree_lock);\n\tBUG_ON(!list_empty(&inode->i_data.private_list));\n\tBUG_ON(!(inode->i_state & I_FREEING));\n\tBUG_ON(inode->i_state & I_CLEAR);\n\t/* don't need i_lock here, no concurrent mods to i_state */\n\tinode->i_state = I_FREEING | I_CLEAR;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <os.h>\n#include <asm/uaccess.h>\n#include <linux/namei.h>\n#include <linux/pid_namespace.h>\n#include <linux/types.h>\n#include <linux/statfs.h>\n#include <linux/slab.h>\n#include <linux/mount.h>\n#include <linux/module.h>\n#include <linux/list.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/dcache.h>\n#include <linux/ctype.h>\n\nvoid hppfs_evict_inode(struct inode *ino)\n{\n\tclear_inode(ino);\n\tdput(HPPFS_I(ino)->proc_dentry);\n\tmntput(ino->i_sb->s_fs_info);\n}"
  },
  {
    "function_name": "hppfs_alloc_inode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hppfs/hppfs.c",
    "lines": "599-610",
    "snippet": "static struct inode *hppfs_alloc_inode(struct super_block *sb)\n{\n\tstruct hppfs_inode_info *hi;\n\n\thi = kmalloc(sizeof(*hi), GFP_KERNEL);\n\tif (!hi)\n\t\treturn NULL;\n\n\thi->proc_dentry = NULL;\n\tinode_init_once(&hi->vfs_inode);\n\treturn &hi->vfs_inode;\n}",
    "includes": [
      "#include <os.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/namei.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/types.h>",
      "#include <linux/statfs.h>",
      "#include <linux/slab.h>",
      "#include <linux/mount.h>",
      "#include <linux/module.h>",
      "#include <linux/list.h>",
      "#include <linux/kernel.h>",
      "#include <linux/init.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/dcache.h>",
      "#include <linux/ctype.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "inode_init_once",
          "args": [
            "&hi->vfs_inode"
          ],
          "line": 608
        },
        "resolved": true,
        "details": {
          "function_name": "inode_init_once",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "355-367",
          "snippet": "void inode_init_once(struct inode *inode)\n{\n\tmemset(inode, 0, sizeof(*inode));\n\tINIT_HLIST_NODE(&inode->i_hash);\n\tINIT_LIST_HEAD(&inode->i_devices);\n\tINIT_LIST_HEAD(&inode->i_wb_list);\n\tINIT_LIST_HEAD(&inode->i_lru);\n\taddress_space_init_once(&inode->i_data);\n\ti_size_ordered_init(inode);\n#ifdef CONFIG_FSNOTIFY\n\tINIT_HLIST_HEAD(&inode->i_fsnotify_marks);\n#endif\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid inode_init_once(struct inode *inode)\n{\n\tmemset(inode, 0, sizeof(*inode));\n\tINIT_HLIST_NODE(&inode->i_hash);\n\tINIT_LIST_HEAD(&inode->i_devices);\n\tINIT_LIST_HEAD(&inode->i_wb_list);\n\tINIT_LIST_HEAD(&inode->i_lru);\n\taddress_space_init_once(&inode->i_data);\n\ti_size_ordered_init(inode);\n#ifdef CONFIG_FSNOTIFY\n\tINIT_HLIST_HEAD(&inode->i_fsnotify_marks);\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "sizeof(*hi)",
            "GFP_KERNEL"
          ],
          "line": 603
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dx_dir_kmalloc_leaves",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "2534-2546",
          "snippet": "static struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <os.h>\n#include <asm/uaccess.h>\n#include <linux/namei.h>\n#include <linux/pid_namespace.h>\n#include <linux/types.h>\n#include <linux/statfs.h>\n#include <linux/slab.h>\n#include <linux/mount.h>\n#include <linux/module.h>\n#include <linux/list.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/dcache.h>\n#include <linux/ctype.h>\n\nstatic struct inode *hppfs_alloc_inode(struct super_block *sb)\n{\n\tstruct hppfs_inode_info *hi;\n\n\thi = kmalloc(sizeof(*hi), GFP_KERNEL);\n\tif (!hi)\n\t\treturn NULL;\n\n\thi->proc_dentry = NULL;\n\tinode_init_once(&hi->vfs_inode);\n\treturn &hi->vfs_inode;\n}"
  },
  {
    "function_name": "hppfs_statfs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hppfs/hppfs.c",
    "lines": "588-597",
    "snippet": "static int hppfs_statfs(struct dentry *dentry, struct kstatfs *sf)\n{\n\tsf->f_blocks = 0;\n\tsf->f_bfree = 0;\n\tsf->f_bavail = 0;\n\tsf->f_files = 0;\n\tsf->f_ffree = 0;\n\tsf->f_type = HPPFS_SUPER_MAGIC;\n\treturn 0;\n}",
    "includes": [
      "#include <os.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/namei.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/types.h>",
      "#include <linux/statfs.h>",
      "#include <linux/slab.h>",
      "#include <linux/mount.h>",
      "#include <linux/module.h>",
      "#include <linux/list.h>",
      "#include <linux/kernel.h>",
      "#include <linux/init.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/dcache.h>",
      "#include <linux/ctype.h>"
    ],
    "macros_used": [
      "#define HPPFS_SUPER_MAGIC 0xb00000ee"
    ],
    "globals_used": [
      "static struct inode *get_inode(struct super_block *, struct dentry *);"
    ],
    "called_functions": [],
    "contextual_snippet": "#include <os.h>\n#include <asm/uaccess.h>\n#include <linux/namei.h>\n#include <linux/pid_namespace.h>\n#include <linux/types.h>\n#include <linux/statfs.h>\n#include <linux/slab.h>\n#include <linux/mount.h>\n#include <linux/module.h>\n#include <linux/list.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/dcache.h>\n#include <linux/ctype.h>\n\n#define HPPFS_SUPER_MAGIC 0xb00000ee\n\nstatic struct inode *get_inode(struct super_block *, struct dentry *);\n\nstatic int hppfs_statfs(struct dentry *dentry, struct kstatfs *sf)\n{\n\tsf->f_blocks = 0;\n\tsf->f_bfree = 0;\n\tsf->f_bavail = 0;\n\tsf->f_files = 0;\n\tsf->f_ffree = 0;\n\tsf->f_type = HPPFS_SUPER_MAGIC;\n\treturn 0;\n}"
  },
  {
    "function_name": "hppfs_readdir",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hppfs/hppfs.c",
    "lines": "564-578",
    "snippet": "static int hppfs_readdir(struct file *file, struct dir_context *ctx)\n{\n\tstruct hppfs_private *data = file->private_data;\n\tstruct file *proc_file = data->proc_file;\n\tstruct hppfs_dirent d = {\n\t\t.ctx.actor\t= hppfs_filldir,\n\t\t.caller\t\t= ctx,\n\t\t.dentry  \t= file->f_path.dentry\n\t};\n\tint err;\n\tproc_file->f_pos = ctx->pos;\n\terr = iterate_dir(proc_file, &d.ctx);\n\tctx->pos = d.ctx.pos;\n\treturn err;\n}",
    "includes": [
      "#include <os.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/namei.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/types.h>",
      "#include <linux/statfs.h>",
      "#include <linux/slab.h>",
      "#include <linux/mount.h>",
      "#include <linux/module.h>",
      "#include <linux/list.h>",
      "#include <linux/kernel.h>",
      "#include <linux/init.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/dcache.h>",
      "#include <linux/ctype.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct inode *get_inode(struct super_block *, struct dentry *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "iterate_dir",
          "args": [
            "proc_file",
            "&d.ctx"
          ],
          "line": 575
        },
        "resolved": true,
        "details": {
          "function_name": "iterate_dir",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/readdir.c",
          "lines": "24-50",
          "snippet": "int iterate_dir(struct file *file, struct dir_context *ctx)\n{\n\tstruct inode *inode = file_inode(file);\n\tint res = -ENOTDIR;\n\tif (!file->f_op->iterate)\n\t\tgoto out;\n\n\tres = security_file_permission(file, MAY_READ);\n\tif (res)\n\t\tgoto out;\n\n\tres = mutex_lock_killable(&inode->i_mutex);\n\tif (res)\n\t\tgoto out;\n\n\tres = -ENOENT;\n\tif (!IS_DEADDIR(inode)) {\n\t\tctx->pos = file->f_pos;\n\t\tres = file->f_op->iterate(file, ctx);\n\t\tfile->f_pos = ctx->pos;\n\t\tfsnotify_access(file);\n\t\tfile_accessed(file);\n\t}\n\tmutex_unlock(&inode->i_mutex);\nout:\n\treturn res;\n}",
          "includes": [
            "#include <asm/uaccess.h>",
            "#include <linux/unistd.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/dirent.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/stat.h>",
            "#include <linux/errno.h>",
            "#include <linux/mm.h>",
            "#include <linux/time.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/uaccess.h>\n#include <linux/unistd.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/dirent.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/stat.h>\n#include <linux/errno.h>\n#include <linux/mm.h>\n#include <linux/time.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n#include <linux/stddef.h>\n\nint iterate_dir(struct file *file, struct dir_context *ctx)\n{\n\tstruct inode *inode = file_inode(file);\n\tint res = -ENOTDIR;\n\tif (!file->f_op->iterate)\n\t\tgoto out;\n\n\tres = security_file_permission(file, MAY_READ);\n\tif (res)\n\t\tgoto out;\n\n\tres = mutex_lock_killable(&inode->i_mutex);\n\tif (res)\n\t\tgoto out;\n\n\tres = -ENOENT;\n\tif (!IS_DEADDIR(inode)) {\n\t\tctx->pos = file->f_pos;\n\t\tres = file->f_op->iterate(file, ctx);\n\t\tfile->f_pos = ctx->pos;\n\t\tfsnotify_access(file);\n\t\tfile_accessed(file);\n\t}\n\tmutex_unlock(&inode->i_mutex);\nout:\n\treturn res;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <os.h>\n#include <asm/uaccess.h>\n#include <linux/namei.h>\n#include <linux/pid_namespace.h>\n#include <linux/types.h>\n#include <linux/statfs.h>\n#include <linux/slab.h>\n#include <linux/mount.h>\n#include <linux/module.h>\n#include <linux/list.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/dcache.h>\n#include <linux/ctype.h>\n\nstatic struct inode *get_inode(struct super_block *, struct dentry *);\n\nstatic int hppfs_readdir(struct file *file, struct dir_context *ctx)\n{\n\tstruct hppfs_private *data = file->private_data;\n\tstruct file *proc_file = data->proc_file;\n\tstruct hppfs_dirent d = {\n\t\t.ctx.actor\t= hppfs_filldir,\n\t\t.caller\t\t= ctx,\n\t\t.dentry  \t= file->f_path.dentry\n\t};\n\tint err;\n\tproc_file->f_pos = ctx->pos;\n\terr = iterate_dir(proc_file, &d.ctx);\n\tctx->pos = d.ctx.pos;\n\treturn err;\n}"
  },
  {
    "function_name": "hppfs_filldir",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hppfs/hppfs.c",
    "lines": "551-562",
    "snippet": "static int hppfs_filldir(struct dir_context *ctx, const char *name, int size,\n\t\t\t loff_t offset, u64 inode, unsigned int type)\n{\n\tstruct hppfs_dirent *dirent =\n\t\tcontainer_of(ctx, struct hppfs_dirent, ctx);\n\n\tif (file_removed(dirent->dentry, name))\n\t\treturn 0;\n\n\tdirent->caller->pos = dirent->ctx.pos;\n\treturn !dir_emit(dirent->caller, name, size, inode, type);\n}",
    "includes": [
      "#include <os.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/namei.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/types.h>",
      "#include <linux/statfs.h>",
      "#include <linux/slab.h>",
      "#include <linux/mount.h>",
      "#include <linux/module.h>",
      "#include <linux/list.h>",
      "#include <linux/kernel.h>",
      "#include <linux/init.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/dcache.h>",
      "#include <linux/ctype.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct inode *get_inode(struct super_block *, struct dentry *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "dir_emit",
          "args": [
            "dirent->caller",
            "name",
            "size",
            "inode",
            "type"
          ],
          "line": 561
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "file_removed",
          "args": [
            "dirent->dentry",
            "name"
          ],
          "line": 557
        },
        "resolved": true,
        "details": {
          "function_name": "file_removed",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hppfs/hppfs.c",
          "lines": "111-139",
          "snippet": "static int file_removed(struct dentry *dentry, const char *file)\n{\n\tchar *host_file;\n\tint extra, fd;\n\n\textra = 0;\n\tif (file != NULL)\n\t\textra += strlen(file) + 1;\n\n\thost_file = dentry_name(dentry, extra + strlen(\"/remove\"));\n\tif (host_file == NULL) {\n\t\tprintk(KERN_ERR \"file_removed : allocation failed\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tif (file != NULL) {\n\t\tstrcat(host_file, \"/\");\n\t\tstrcat(host_file, file);\n\t}\n\tstrcat(host_file, \"/remove\");\n\n\tfd = os_open_file(host_file, of_read(OPENFLAGS()), 0);\n\tkfree(host_file);\n\tif (fd > 0) {\n\t\tos_close_file(fd);\n\t\treturn 1;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include <os.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/namei.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/types.h>",
            "#include <linux/statfs.h>",
            "#include <linux/slab.h>",
            "#include <linux/mount.h>",
            "#include <linux/module.h>",
            "#include <linux/list.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/dcache.h>",
            "#include <linux/ctype.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct inode *get_inode(struct super_block *, struct dentry *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <os.h>\n#include <asm/uaccess.h>\n#include <linux/namei.h>\n#include <linux/pid_namespace.h>\n#include <linux/types.h>\n#include <linux/statfs.h>\n#include <linux/slab.h>\n#include <linux/mount.h>\n#include <linux/module.h>\n#include <linux/list.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/dcache.h>\n#include <linux/ctype.h>\n\nstatic struct inode *get_inode(struct super_block *, struct dentry *);\n\nstatic int file_removed(struct dentry *dentry, const char *file)\n{\n\tchar *host_file;\n\tint extra, fd;\n\n\textra = 0;\n\tif (file != NULL)\n\t\textra += strlen(file) + 1;\n\n\thost_file = dentry_name(dentry, extra + strlen(\"/remove\"));\n\tif (host_file == NULL) {\n\t\tprintk(KERN_ERR \"file_removed : allocation failed\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tif (file != NULL) {\n\t\tstrcat(host_file, \"/\");\n\t\tstrcat(host_file, file);\n\t}\n\tstrcat(host_file, \"/remove\");\n\n\tfd = os_open_file(host_file, of_read(OPENFLAGS()), 0);\n\tkfree(host_file);\n\tif (fd > 0) {\n\t\tos_close_file(fd);\n\t\treturn 1;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "ctx",
            "structhppfs_dirent",
            "ctx"
          ],
          "line": 555
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <os.h>\n#include <asm/uaccess.h>\n#include <linux/namei.h>\n#include <linux/pid_namespace.h>\n#include <linux/types.h>\n#include <linux/statfs.h>\n#include <linux/slab.h>\n#include <linux/mount.h>\n#include <linux/module.h>\n#include <linux/list.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/dcache.h>\n#include <linux/ctype.h>\n\nstatic struct inode *get_inode(struct super_block *, struct dentry *);\n\nstatic int hppfs_filldir(struct dir_context *ctx, const char *name, int size,\n\t\t\t loff_t offset, u64 inode, unsigned int type)\n{\n\tstruct hppfs_dirent *dirent =\n\t\tcontainer_of(ctx, struct hppfs_dirent, ctx);\n\n\tif (file_removed(dirent->dentry, name))\n\t\treturn 0;\n\n\tdirent->caller->pos = dirent->ctx.pos;\n\treturn !dir_emit(dirent->caller, name, size, inode, type);\n}"
  },
  {
    "function_name": "hppfs_release",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hppfs/hppfs.c",
    "lines": "526-534",
    "snippet": "static int hppfs_release(struct inode *inode, struct file *file)\n{\n\tstruct hppfs_private *data = file->private_data;\n\tstruct file *proc_file = data->proc_file;\n\tif (proc_file)\n\t\tfput(proc_file);\n\tkfree(data);\n\treturn 0;\n}",
    "includes": [
      "#include <os.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/namei.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/types.h>",
      "#include <linux/statfs.h>",
      "#include <linux/slab.h>",
      "#include <linux/mount.h>",
      "#include <linux/module.h>",
      "#include <linux/list.h>",
      "#include <linux/kernel.h>",
      "#include <linux/init.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/dcache.h>",
      "#include <linux/ctype.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "data"
          ],
          "line": 532
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fput",
          "args": [
            "proc_file"
          ],
          "line": 531
        },
        "resolved": true,
        "details": {
          "function_name": "__fput_sync",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/file_table.c",
          "lines": "293-300",
          "snippet": "void __fput_sync(struct file *file)\n{\n\tif (atomic_long_dec_and_test(&file->f_count)) {\n\t\tstruct task_struct *task = current;\n\t\tBUG_ON(!(task->flags & PF_KTHREAD));\n\t\t__fput(file);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/atomic.h>",
            "#include <linux/ima.h>",
            "#include <linux/task_work.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/percpu.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/lglock.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/cdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/mount.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/eventpoll.h>",
            "#include <linux/security.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/atomic.h>\n#include <linux/ima.h>\n#include <linux/task_work.h>\n#include <linux/hardirq.h>\n#include <linux/percpu.h>\n#include <linux/percpu_counter.h>\n#include <linux/lglock.h>\n#include <linux/sysctl.h>\n#include <linux/fsnotify.h>\n#include <linux/cdev.h>\n#include <linux/capability.h>\n#include <linux/mount.h>\n#include <linux/rcupdate.h>\n#include <linux/eventpoll.h>\n#include <linux/security.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n\nvoid __fput_sync(struct file *file)\n{\n\tif (atomic_long_dec_and_test(&file->f_count)) {\n\t\tstruct task_struct *task = current;\n\t\tBUG_ON(!(task->flags & PF_KTHREAD));\n\t\t__fput(file);\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include <os.h>\n#include <asm/uaccess.h>\n#include <linux/namei.h>\n#include <linux/pid_namespace.h>\n#include <linux/types.h>\n#include <linux/statfs.h>\n#include <linux/slab.h>\n#include <linux/mount.h>\n#include <linux/module.h>\n#include <linux/list.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/dcache.h>\n#include <linux/ctype.h>\n\nstatic int hppfs_release(struct inode *inode, struct file *file)\n{\n\tstruct hppfs_private *data = file->private_data;\n\tstruct file *proc_file = data->proc_file;\n\tif (proc_file)\n\t\tfput(proc_file);\n\tkfree(data);\n\treturn 0;\n}"
  },
  {
    "function_name": "hppfs_llseek",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hppfs/hppfs.c",
    "lines": "509-524",
    "snippet": "static loff_t hppfs_llseek(struct file *file, loff_t off, int where)\n{\n\tstruct hppfs_private *data = file->private_data;\n\tstruct file *proc_file = data->proc_file;\n\tloff_t (*llseek)(struct file *, loff_t, int);\n\tloff_t ret;\n\n\tllseek = file_inode(proc_file)->i_fop->llseek;\n\tif (llseek != NULL) {\n\t\tret = (*llseek)(proc_file, off, where);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\n\treturn default_llseek(file, off, where);\n}",
    "includes": [
      "#include <os.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/namei.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/types.h>",
      "#include <linux/statfs.h>",
      "#include <linux/slab.h>",
      "#include <linux/mount.h>",
      "#include <linux/module.h>",
      "#include <linux/list.h>",
      "#include <linux/kernel.h>",
      "#include <linux/init.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/dcache.h>",
      "#include <linux/ctype.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "default_llseek",
          "args": [
            "file",
            "off",
            "where"
          ],
          "line": 523
        },
        "resolved": true,
        "details": {
          "function_name": "default_llseek",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/read_write.c",
          "lines": "200-252",
          "snippet": "loff_t default_llseek(struct file *file, loff_t offset, int whence)\n{\n\tstruct inode *inode = file_inode(file);\n\tloff_t retval;\n\n\tmutex_lock(&inode->i_mutex);\n\tswitch (whence) {\n\t\tcase SEEK_END:\n\t\t\toffset += i_size_read(inode);\n\t\t\tbreak;\n\t\tcase SEEK_CUR:\n\t\t\tif (offset == 0) {\n\t\t\t\tretval = file->f_pos;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\toffset += file->f_pos;\n\t\t\tbreak;\n\t\tcase SEEK_DATA:\n\t\t\t/*\n\t\t\t * In the generic case the entire file is data, so as\n\t\t\t * long as offset isn't at the end of the file then the\n\t\t\t * offset is data.\n\t\t\t */\n\t\t\tif (offset >= inode->i_size) {\n\t\t\t\tretval = -ENXIO;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase SEEK_HOLE:\n\t\t\t/*\n\t\t\t * There is a virtual hole at the end of the file, so\n\t\t\t * as long as offset isn't i_size or larger, return\n\t\t\t * i_size.\n\t\t\t */\n\t\t\tif (offset >= inode->i_size) {\n\t\t\t\tretval = -ENXIO;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\toffset = inode->i_size;\n\t\t\tbreak;\n\t}\n\tretval = -EINVAL;\n\tif (offset >= 0 || unsigned_offsets(file)) {\n\t\tif (offset != file->f_pos) {\n\t\t\tfile->f_pos = offset;\n\t\t\tfile->f_version = 0;\n\t\t}\n\t\tretval = offset;\n\t}\nout:\n\tmutex_unlock(&inode->i_mutex);\n\treturn retval;\n}",
          "includes": [
            "#include <asm/unistd.h>",
            "#include <asm/uaccess.h>",
            "#include \"internal.h\"",
            "#include <linux/compat.h>",
            "#include <linux/splice.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/export.h>",
            "#include <linux/security.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/aio.h>",
            "#include <linux/uio.h>",
            "#include <linux/file.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/stat.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/unistd.h>\n#include <asm/uaccess.h>\n#include \"internal.h\"\n#include <linux/compat.h>\n#include <linux/splice.h>\n#include <linux/pagemap.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/security.h>\n#include <linux/fsnotify.h>\n#include <linux/aio.h>\n#include <linux/uio.h>\n#include <linux/file.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/slab.h>\n\nloff_t default_llseek(struct file *file, loff_t offset, int whence)\n{\n\tstruct inode *inode = file_inode(file);\n\tloff_t retval;\n\n\tmutex_lock(&inode->i_mutex);\n\tswitch (whence) {\n\t\tcase SEEK_END:\n\t\t\toffset += i_size_read(inode);\n\t\t\tbreak;\n\t\tcase SEEK_CUR:\n\t\t\tif (offset == 0) {\n\t\t\t\tretval = file->f_pos;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\toffset += file->f_pos;\n\t\t\tbreak;\n\t\tcase SEEK_DATA:\n\t\t\t/*\n\t\t\t * In the generic case the entire file is data, so as\n\t\t\t * long as offset isn't at the end of the file then the\n\t\t\t * offset is data.\n\t\t\t */\n\t\t\tif (offset >= inode->i_size) {\n\t\t\t\tretval = -ENXIO;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase SEEK_HOLE:\n\t\t\t/*\n\t\t\t * There is a virtual hole at the end of the file, so\n\t\t\t * as long as offset isn't i_size or larger, return\n\t\t\t * i_size.\n\t\t\t */\n\t\t\tif (offset >= inode->i_size) {\n\t\t\t\tretval = -ENXIO;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\toffset = inode->i_size;\n\t\t\tbreak;\n\t}\n\tretval = -EINVAL;\n\tif (offset >= 0 || unsigned_offsets(file)) {\n\t\tif (offset != file->f_pos) {\n\t\t\tfile->f_pos = offset;\n\t\t\tfile->f_version = 0;\n\t\t}\n\t\tretval = offset;\n\t}\nout:\n\tmutex_unlock(&inode->i_mutex);\n\treturn retval;\n}"
        }
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "proc_file",
            "off",
            "where"
          ],
          "line": 518
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "file_inode",
          "args": [
            "proc_file"
          ],
          "line": 516
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_init_file_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/file.c",
          "lines": "3009-3013",
          "snippet": "void fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}",
          "includes": [
            "#include <linux/falloc.h>",
            "#include <linux/aio.h>",
            "#include <linux/swap.h>",
            "#include <linux/compat.h>",
            "#include <linux/module.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};",
            "static const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/compat.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};\nstatic const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};\n\nvoid fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <os.h>\n#include <asm/uaccess.h>\n#include <linux/namei.h>\n#include <linux/pid_namespace.h>\n#include <linux/types.h>\n#include <linux/statfs.h>\n#include <linux/slab.h>\n#include <linux/mount.h>\n#include <linux/module.h>\n#include <linux/list.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/dcache.h>\n#include <linux/ctype.h>\n\nstatic loff_t hppfs_llseek(struct file *file, loff_t off, int where)\n{\n\tstruct hppfs_private *data = file->private_data;\n\tstruct file *proc_file = data->proc_file;\n\tloff_t (*llseek)(struct file *, loff_t, int);\n\tloff_t ret;\n\n\tllseek = file_inode(proc_file)->i_fop->llseek;\n\tif (llseek != NULL) {\n\t\tret = (*llseek)(proc_file, off, where);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\n\treturn default_llseek(file, off, where);\n}"
  },
  {
    "function_name": "hppfs_dir_open",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hppfs/hppfs.c",
    "lines": "481-507",
    "snippet": "static int hppfs_dir_open(struct inode *inode, struct file *file)\n{\n\tconst struct cred *cred = file->f_cred;\n\tstruct hppfs_private *data;\n\tstruct path path;\n\tint err;\n\n\terr = -ENOMEM;\n\tdata = hppfs_data();\n\tif (data == NULL)\n\t\tgoto out;\n\n\tpath.mnt = inode->i_sb->s_fs_info;\n\tpath.dentry = HPPFS_I(inode)->proc_dentry;\n\tdata->proc_file = dentry_open(&path, file_mode(file->f_mode), cred);\n\terr = PTR_ERR(data->proc_file);\n\tif (IS_ERR(data->proc_file))\n\t\tgoto out_free;\n\n\tfile->private_data = data;\n\treturn 0;\n\n out_free:\n\tkfree(data);\n out:\n\treturn err;\n}",
    "includes": [
      "#include <os.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/namei.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/types.h>",
      "#include <linux/statfs.h>",
      "#include <linux/slab.h>",
      "#include <linux/mount.h>",
      "#include <linux/module.h>",
      "#include <linux/list.h>",
      "#include <linux/kernel.h>",
      "#include <linux/init.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/dcache.h>",
      "#include <linux/ctype.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct inode *get_inode(struct super_block *, struct dentry *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "data"
          ],
          "line": 504
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "data->proc_file"
          ],
          "line": 497
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "data->proc_file"
          ],
          "line": 496
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dentry_open",
          "args": [
            "&path",
            "file_mode(file->f_mode)",
            "cred"
          ],
          "line": 495
        },
        "resolved": true,
        "details": {
          "function_name": "dentry_open",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/open.c",
          "lines": "821-849",
          "snippet": "struct file *dentry_open(const struct path *path, int flags,\n\t\t\t const struct cred *cred)\n{\n\tint error;\n\tstruct file *f;\n\n\tvalidate_creds(cred);\n\n\t/* We must always pass in a valid mount pointer. */\n\tBUG_ON(!path->mnt);\n\n\tf = get_empty_filp();\n\tif (!IS_ERR(f)) {\n\t\tf->f_flags = flags;\n\t\terror = vfs_open(path, f, cred);\n\t\tif (!error) {\n\t\t\t/* from now on we need fput() to dispose of f */\n\t\t\terror = open_check_o_direct(f);\n\t\t\tif (error) {\n\t\t\t\tfput(f);\n\t\t\t\tf = ERR_PTR(error);\n\t\t\t}\n\t\t} else { \n\t\t\tput_filp(f);\n\t\t\tf = ERR_PTR(error);\n\t\t}\n\t}\n\treturn f;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/compat.h>",
            "#include <linux/dnotify.h>",
            "#include <linux/ima.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/falloc.h>",
            "#include <linux/audit.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/personality.h>",
            "#include <linux/fs.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/mount.h>",
            "#include <linux/security.h>",
            "#include <linux/securebits.h>",
            "#include <linux/capability.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/namei.h>",
            "#include <linux/tty.h>",
            "#include <linux/module.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/compat.h>\n#include <linux/dnotify.h>\n#include <linux/ima.h>\n#include <linux/fs_struct.h>\n#include <linux/falloc.h>\n#include <linux/audit.h>\n#include <linux/rcupdate.h>\n#include <linux/syscalls.h>\n#include <linux/pagemap.h>\n#include <linux/personality.h>\n#include <linux/fs.h>\n#include <asm/uaccess.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/mount.h>\n#include <linux/security.h>\n#include <linux/securebits.h>\n#include <linux/capability.h>\n#include <linux/backing-dev.h>\n#include <linux/namei.h>\n#include <linux/tty.h>\n#include <linux/module.h>\n#include <linux/fsnotify.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n\nstruct file *dentry_open(const struct path *path, int flags,\n\t\t\t const struct cred *cred)\n{\n\tint error;\n\tstruct file *f;\n\n\tvalidate_creds(cred);\n\n\t/* We must always pass in a valid mount pointer. */\n\tBUG_ON(!path->mnt);\n\n\tf = get_empty_filp();\n\tif (!IS_ERR(f)) {\n\t\tf->f_flags = flags;\n\t\terror = vfs_open(path, f, cred);\n\t\tif (!error) {\n\t\t\t/* from now on we need fput() to dispose of f */\n\t\t\terror = open_check_o_direct(f);\n\t\t\tif (error) {\n\t\t\t\tfput(f);\n\t\t\t\tf = ERR_PTR(error);\n\t\t\t}\n\t\t} else { \n\t\t\tput_filp(f);\n\t\t\tf = ERR_PTR(error);\n\t\t}\n\t}\n\treturn f;\n}"
        }
      },
      {
        "call_info": {
          "callee": "file_mode",
          "args": [
            "file->f_mode"
          ],
          "line": 495
        },
        "resolved": true,
        "details": {
          "function_name": "file_mode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hppfs/hppfs.c",
          "lines": "409-418",
          "snippet": "static int file_mode(int fmode)\n{\n\tif (fmode == (FMODE_READ | FMODE_WRITE))\n\t\treturn O_RDWR;\n\tif (fmode == FMODE_READ)\n\t\treturn O_RDONLY;\n\tif (fmode == FMODE_WRITE)\n\t\treturn O_WRONLY;\n\treturn 0;\n}",
          "includes": [
            "#include <os.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/namei.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/types.h>",
            "#include <linux/statfs.h>",
            "#include <linux/slab.h>",
            "#include <linux/mount.h>",
            "#include <linux/module.h>",
            "#include <linux/list.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/dcache.h>",
            "#include <linux/ctype.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <os.h>\n#include <asm/uaccess.h>\n#include <linux/namei.h>\n#include <linux/pid_namespace.h>\n#include <linux/types.h>\n#include <linux/statfs.h>\n#include <linux/slab.h>\n#include <linux/mount.h>\n#include <linux/module.h>\n#include <linux/list.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/dcache.h>\n#include <linux/ctype.h>\n\nstatic int file_mode(int fmode)\n{\n\tif (fmode == (FMODE_READ | FMODE_WRITE))\n\t\treturn O_RDWR;\n\tif (fmode == FMODE_READ)\n\t\treturn O_RDONLY;\n\tif (fmode == FMODE_WRITE)\n\t\treturn O_WRONLY;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "HPPFS_I",
          "args": [
            "inode"
          ],
          "line": 494
        },
        "resolved": true,
        "details": {
          "function_name": "HPPFS_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hppfs/hppfs.c",
          "lines": "42-45",
          "snippet": "static inline struct hppfs_inode_info *HPPFS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct hppfs_inode_info, vfs_inode);\n}",
          "includes": [
            "#include <os.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/namei.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/types.h>",
            "#include <linux/statfs.h>",
            "#include <linux/slab.h>",
            "#include <linux/mount.h>",
            "#include <linux/module.h>",
            "#include <linux/list.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/dcache.h>",
            "#include <linux/ctype.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <os.h>\n#include <asm/uaccess.h>\n#include <linux/namei.h>\n#include <linux/pid_namespace.h>\n#include <linux/types.h>\n#include <linux/statfs.h>\n#include <linux/slab.h>\n#include <linux/mount.h>\n#include <linux/module.h>\n#include <linux/list.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/dcache.h>\n#include <linux/ctype.h>\n\nstatic inline struct hppfs_inode_info *HPPFS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct hppfs_inode_info, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "hppfs_data",
          "args": [],
          "line": 489
        },
        "resolved": true,
        "details": {
          "function_name": "hppfs_data",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hppfs/hppfs.c",
          "lines": "395-407",
          "snippet": "static struct hppfs_private *hppfs_data(void)\n{\n\tstruct hppfs_private *data;\n\n\tdata = kmalloc(sizeof(*data), GFP_KERNEL);\n\tif (data == NULL)\n\t\treturn data;\n\n\t*data = ((struct hppfs_private ) { .host_fd  \t\t= -1,\n\t\t\t\t\t   .len  \t\t= -1,\n\t\t\t\t\t   .contents \t\t= NULL } );\n\treturn data;\n}",
          "includes": [
            "#include <os.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/namei.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/types.h>",
            "#include <linux/statfs.h>",
            "#include <linux/slab.h>",
            "#include <linux/mount.h>",
            "#include <linux/module.h>",
            "#include <linux/list.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/dcache.h>",
            "#include <linux/ctype.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <os.h>\n#include <asm/uaccess.h>\n#include <linux/namei.h>\n#include <linux/pid_namespace.h>\n#include <linux/types.h>\n#include <linux/statfs.h>\n#include <linux/slab.h>\n#include <linux/mount.h>\n#include <linux/module.h>\n#include <linux/list.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/dcache.h>\n#include <linux/ctype.h>\n\nstatic struct hppfs_private *hppfs_data(void)\n{\n\tstruct hppfs_private *data;\n\n\tdata = kmalloc(sizeof(*data), GFP_KERNEL);\n\tif (data == NULL)\n\t\treturn data;\n\n\t*data = ((struct hppfs_private ) { .host_fd  \t\t= -1,\n\t\t\t\t\t   .len  \t\t= -1,\n\t\t\t\t\t   .contents \t\t= NULL } );\n\treturn data;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <os.h>\n#include <asm/uaccess.h>\n#include <linux/namei.h>\n#include <linux/pid_namespace.h>\n#include <linux/types.h>\n#include <linux/statfs.h>\n#include <linux/slab.h>\n#include <linux/mount.h>\n#include <linux/module.h>\n#include <linux/list.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/dcache.h>\n#include <linux/ctype.h>\n\nstatic struct inode *get_inode(struct super_block *, struct dentry *);\n\nstatic int hppfs_dir_open(struct inode *inode, struct file *file)\n{\n\tconst struct cred *cred = file->f_cred;\n\tstruct hppfs_private *data;\n\tstruct path path;\n\tint err;\n\n\terr = -ENOMEM;\n\tdata = hppfs_data();\n\tif (data == NULL)\n\t\tgoto out;\n\n\tpath.mnt = inode->i_sb->s_fs_info;\n\tpath.dentry = HPPFS_I(inode)->proc_dentry;\n\tdata->proc_file = dentry_open(&path, file_mode(file->f_mode), cred);\n\terr = PTR_ERR(data->proc_file);\n\tif (IS_ERR(data->proc_file))\n\t\tgoto out_free;\n\n\tfile->private_data = data;\n\treturn 0;\n\n out_free:\n\tkfree(data);\n out:\n\treturn err;\n}"
  },
  {
    "function_name": "hppfs_open",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hppfs/hppfs.c",
    "lines": "420-479",
    "snippet": "static int hppfs_open(struct inode *inode, struct file *file)\n{\n\tconst struct cred *cred = file->f_cred;\n\tstruct hppfs_private *data;\n\tstruct path path;\n\tchar *host_file;\n\tint err, fd, type, filter;\n\n\terr = -ENOMEM;\n\tdata = hppfs_data();\n\tif (data == NULL)\n\t\tgoto out;\n\n\thost_file = dentry_name(file->f_path.dentry, strlen(\"/rw\"));\n\tif (host_file == NULL)\n\t\tgoto out_free2;\n\n\tpath.mnt = inode->i_sb->s_fs_info;\n\tpath.dentry = HPPFS_I(inode)->proc_dentry;\n\n\tdata->proc_file = dentry_open(&path, file_mode(file->f_mode), cred);\n\terr = PTR_ERR(data->proc_file);\n\tif (IS_ERR(data->proc_file))\n\t\tgoto out_free1;\n\n\ttype = os_file_type(host_file);\n\tif (type == OS_TYPE_FILE) {\n\t\tfd = os_open_file(host_file, of_read(OPENFLAGS()), 0);\n\t\tif (fd >= 0)\n\t\t\tdata->host_fd = fd;\n\t\telse\n\t\t\tprintk(KERN_ERR \"hppfs_open : failed to open '%s', \"\n\t\t\t       \"errno = %d\\n\", host_file, -fd);\n\n\t\tdata->contents = NULL;\n\t} else if (type == OS_TYPE_DIR) {\n\t\tfd = open_host_sock(host_file, &filter);\n\t\tif (fd > 0) {\n\t\t\tdata->contents = hppfs_get_data(fd, filter,\n\t\t\t\t\t\t\tdata->proc_file,\n\t\t\t\t\t\t\tfile, &data->len);\n\t\t\tif (!IS_ERR(data->contents))\n\t\t\t\tdata->host_fd = fd;\n\t\t} else\n\t\t\tprintk(KERN_ERR \"hppfs_open : failed to open a socket \"\n\t\t\t       \"in '%s', errno = %d\\n\", host_file, -fd);\n\t}\n\tkfree(host_file);\n\n\tfile->private_data = data;\n\treturn 0;\n\n out_free1:\n\tkfree(host_file);\n out_free2:\n\tfree_contents(data->contents);\n\tkfree(data);\n out:\n\treturn err;\n}",
    "includes": [
      "#include <os.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/namei.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/types.h>",
      "#include <linux/statfs.h>",
      "#include <linux/slab.h>",
      "#include <linux/mount.h>",
      "#include <linux/module.h>",
      "#include <linux/list.h>",
      "#include <linux/kernel.h>",
      "#include <linux/init.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/dcache.h>",
      "#include <linux/ctype.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct inode *get_inode(struct super_block *, struct dentry *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "data"
          ],
          "line": 476
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free_contents",
          "args": [
            "data->contents"
          ],
          "line": 475
        },
        "resolved": true,
        "details": {
          "function_name": "free_contents",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hppfs/hppfs.c",
          "lines": "314-327",
          "snippet": "static void free_contents(struct hppfs_data *head)\n{\n\tstruct hppfs_data *data;\n\tstruct list_head *ele, *next;\n\n\tif (head == NULL)\n\t\treturn;\n\n\tlist_for_each_safe(ele, next, &head->list) {\n\t\tdata = list_entry(ele, struct hppfs_data, list);\n\t\tkfree(data);\n\t}\n\tkfree(head);\n}",
          "includes": [
            "#include <os.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/namei.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/types.h>",
            "#include <linux/statfs.h>",
            "#include <linux/slab.h>",
            "#include <linux/mount.h>",
            "#include <linux/module.h>",
            "#include <linux/list.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/dcache.h>",
            "#include <linux/ctype.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <os.h>\n#include <asm/uaccess.h>\n#include <linux/namei.h>\n#include <linux/pid_namespace.h>\n#include <linux/types.h>\n#include <linux/statfs.h>\n#include <linux/slab.h>\n#include <linux/mount.h>\n#include <linux/module.h>\n#include <linux/list.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/dcache.h>\n#include <linux/ctype.h>\n\nstatic void free_contents(struct hppfs_data *head)\n{\n\tstruct hppfs_data *data;\n\tstruct list_head *ele, *next;\n\n\tif (head == NULL)\n\t\treturn;\n\n\tlist_for_each_safe(ele, next, &head->list) {\n\t\tdata = list_entry(ele, struct hppfs_data, list);\n\t\tkfree(data);\n\t}\n\tkfree(head);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "host_file"
          ],
          "line": 473
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "host_file"
          ],
          "line": 467
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_ERR \"hppfs_open : failed to open a socket \"\n\t\t\t       \"in '%s', errno = %d\\n\"",
            "host_file",
            "-fd"
          ],
          "line": 464
        },
        "resolved": true,
        "details": {
          "function_name": "compat_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/compat.c",
          "lines": "59-69",
          "snippet": "int compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/ioctls.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/aio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/mm.h>",
            "#include <linux/poll.h>",
            "#include <linux/signal.h>",
            "#include <linux/highmem.h>",
            "#include <linux/security.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/personality.h>",
            "#include <linux/highuid.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/dirent.h>",
            "#include <linux/ctype.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/nfs4_mount.h>",
            "#include <linux/ncp_mount.h>",
            "#include <linux/init.h>",
            "#include <linux/ioctl.h>",
            "#include <linux/vfs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/namei.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/errno.h>",
            "#include <linux/compat.h>",
            "#include <linux/linkage.h>",
            "#include <linux/kernel.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int compat_log = 1;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/ioctls.h>\n#include <asm/mmu_context.h>\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/fs_struct.h>\n#include <linux/mm.h>\n#include <linux/poll.h>\n#include <linux/signal.h>\n#include <linux/highmem.h>\n#include <linux/security.h>\n#include <linux/tsacct_kern.h>\n#include <linux/rwsem.h>\n#include <linux/personality.h>\n#include <linux/highuid.h>\n#include <linux/fsnotify.h>\n#include <linux/dirent.h>\n#include <linux/ctype.h>\n#include <linux/syscalls.h>\n#include <linux/nfs4_mount.h>\n#include <linux/ncp_mount.h>\n#include <linux/init.h>\n#include <linux/ioctl.h>\n#include <linux/vfs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/namei.h>\n#include <linux/fcntl.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <linux/compat.h>\n#include <linux/linkage.h>\n#include <linux/kernel.h>\n#include <linux/stddef.h>\n\nint compat_log = 1;\n\nint compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "data->contents"
          ],
          "line": 461
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hppfs_get_data",
          "args": [
            "fd",
            "filter",
            "data->proc_file",
            "file",
            "&data->len"
          ],
          "line": 458
        },
        "resolved": true,
        "details": {
          "function_name": "hppfs_get_data",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hppfs/hppfs.c",
          "lines": "329-393",
          "snippet": "static struct hppfs_data *hppfs_get_data(int fd, int filter,\n\t\t\t\t\t struct file *proc_file,\n\t\t\t\t\t struct file *hppfs_file,\n\t\t\t\t\t loff_t *size_out)\n{\n\tstruct hppfs_data *data, *new, *head;\n\tint n, err;\n\n\terr = -ENOMEM;\n\tdata = kmalloc(sizeof(*data), GFP_KERNEL);\n\tif (data == NULL) {\n\t\tprintk(KERN_ERR \"hppfs_get_data : head allocation failed\\n\");\n\t\tgoto failed;\n\t}\n\n\tINIT_LIST_HEAD(&data->list);\n\n\thead = data;\n\t*size_out = 0;\n\n\tif (filter) {\n\t\twhile ((n = read_proc(proc_file, data->contents,\n\t\t\t\t      sizeof(data->contents), NULL, 0)) > 0)\n\t\t\tos_write_file(fd, data->contents, n);\n\t\terr = os_shutdown_socket(fd, 0, 1);\n\t\tif (err) {\n\t\t\tprintk(KERN_ERR \"hppfs_get_data : failed to shut down \"\n\t\t\t       \"socket\\n\");\n\t\t\tgoto failed_free;\n\t\t}\n\t}\n\twhile (1) {\n\t\tn = os_read_file(fd, data->contents, sizeof(data->contents));\n\t\tif (n < 0) {\n\t\t\terr = n;\n\t\t\tprintk(KERN_ERR \"hppfs_get_data : read failed, \"\n\t\t\t       \"errno = %d\\n\", err);\n\t\t\tgoto failed_free;\n\t\t} else if (n == 0)\n\t\t\tbreak;\n\n\t\t*size_out += n;\n\n\t\tif (n < sizeof(data->contents))\n\t\t\tbreak;\n\n\t\tnew = kmalloc(sizeof(*data), GFP_KERNEL);\n\t\tif (new == 0) {\n\t\t\tprintk(KERN_ERR \"hppfs_get_data : data allocation \"\n\t\t\t       \"failed\\n\");\n\t\t\terr = -ENOMEM;\n\t\t\tgoto failed_free;\n\t\t}\n\n\t\tINIT_LIST_HEAD(&new->list);\n\t\tlist_add(&new->list, &data->list);\n\t\tdata = new;\n\t}\n\treturn head;\n\n failed_free:\n\tfree_contents(head);\n failed:\n\treturn ERR_PTR(err);\n}",
          "includes": [
            "#include <os.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/namei.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/types.h>",
            "#include <linux/statfs.h>",
            "#include <linux/slab.h>",
            "#include <linux/mount.h>",
            "#include <linux/module.h>",
            "#include <linux/list.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/dcache.h>",
            "#include <linux/ctype.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <os.h>\n#include <asm/uaccess.h>\n#include <linux/namei.h>\n#include <linux/pid_namespace.h>\n#include <linux/types.h>\n#include <linux/statfs.h>\n#include <linux/slab.h>\n#include <linux/mount.h>\n#include <linux/module.h>\n#include <linux/list.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/dcache.h>\n#include <linux/ctype.h>\n\nstatic struct hppfs_data *hppfs_get_data(int fd, int filter,\n\t\t\t\t\t struct file *proc_file,\n\t\t\t\t\t struct file *hppfs_file,\n\t\t\t\t\t loff_t *size_out)\n{\n\tstruct hppfs_data *data, *new, *head;\n\tint n, err;\n\n\terr = -ENOMEM;\n\tdata = kmalloc(sizeof(*data), GFP_KERNEL);\n\tif (data == NULL) {\n\t\tprintk(KERN_ERR \"hppfs_get_data : head allocation failed\\n\");\n\t\tgoto failed;\n\t}\n\n\tINIT_LIST_HEAD(&data->list);\n\n\thead = data;\n\t*size_out = 0;\n\n\tif (filter) {\n\t\twhile ((n = read_proc(proc_file, data->contents,\n\t\t\t\t      sizeof(data->contents), NULL, 0)) > 0)\n\t\t\tos_write_file(fd, data->contents, n);\n\t\terr = os_shutdown_socket(fd, 0, 1);\n\t\tif (err) {\n\t\t\tprintk(KERN_ERR \"hppfs_get_data : failed to shut down \"\n\t\t\t       \"socket\\n\");\n\t\t\tgoto failed_free;\n\t\t}\n\t}\n\twhile (1) {\n\t\tn = os_read_file(fd, data->contents, sizeof(data->contents));\n\t\tif (n < 0) {\n\t\t\terr = n;\n\t\t\tprintk(KERN_ERR \"hppfs_get_data : read failed, \"\n\t\t\t       \"errno = %d\\n\", err);\n\t\t\tgoto failed_free;\n\t\t} else if (n == 0)\n\t\t\tbreak;\n\n\t\t*size_out += n;\n\n\t\tif (n < sizeof(data->contents))\n\t\t\tbreak;\n\n\t\tnew = kmalloc(sizeof(*data), GFP_KERNEL);\n\t\tif (new == 0) {\n\t\t\tprintk(KERN_ERR \"hppfs_get_data : data allocation \"\n\t\t\t       \"failed\\n\");\n\t\t\terr = -ENOMEM;\n\t\t\tgoto failed_free;\n\t\t}\n\n\t\tINIT_LIST_HEAD(&new->list);\n\t\tlist_add(&new->list, &data->list);\n\t\tdata = new;\n\t}\n\treturn head;\n\n failed_free:\n\tfree_contents(head);\n failed:\n\treturn ERR_PTR(err);\n}"
        }
      },
      {
        "call_info": {
          "callee": "open_host_sock",
          "args": [
            "host_file",
            "&filter"
          ],
          "line": 456
        },
        "resolved": true,
        "details": {
          "function_name": "open_host_sock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hppfs/hppfs.c",
          "lines": "296-312",
          "snippet": "static int open_host_sock(char *host_file, int *filter_out)\n{\n\tchar *end;\n\tint fd;\n\n\tend = &host_file[strlen(host_file)];\n\tstrcpy(end, \"/rw\");\n\t*filter_out = 1;\n\tfd = os_connect_socket(host_file);\n\tif (fd > 0)\n\t\treturn fd;\n\n\tstrcpy(end, \"/r\");\n\t*filter_out = 0;\n\tfd = os_connect_socket(host_file);\n\treturn fd;\n}",
          "includes": [
            "#include <os.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/namei.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/types.h>",
            "#include <linux/statfs.h>",
            "#include <linux/slab.h>",
            "#include <linux/mount.h>",
            "#include <linux/module.h>",
            "#include <linux/list.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/dcache.h>",
            "#include <linux/ctype.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <os.h>\n#include <asm/uaccess.h>\n#include <linux/namei.h>\n#include <linux/pid_namespace.h>\n#include <linux/types.h>\n#include <linux/statfs.h>\n#include <linux/slab.h>\n#include <linux/mount.h>\n#include <linux/module.h>\n#include <linux/list.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/dcache.h>\n#include <linux/ctype.h>\n\nstatic int open_host_sock(char *host_file, int *filter_out)\n{\n\tchar *end;\n\tint fd;\n\n\tend = &host_file[strlen(host_file)];\n\tstrcpy(end, \"/rw\");\n\t*filter_out = 1;\n\tfd = os_connect_socket(host_file);\n\tif (fd > 0)\n\t\treturn fd;\n\n\tstrcpy(end, \"/r\");\n\t*filter_out = 0;\n\tfd = os_connect_socket(host_file);\n\treturn fd;\n}"
        }
      },
      {
        "call_info": {
          "callee": "os_open_file",
          "args": [
            "host_file",
            "of_read(OPENFLAGS())",
            "0"
          ],
          "line": 447
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "of_read",
          "args": [
            "OPENFLAGS()"
          ],
          "line": 447
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OPENFLAGS",
          "args": [],
          "line": 447
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "os_file_type",
          "args": [
            "host_file"
          ],
          "line": 445
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "data->proc_file"
          ],
          "line": 442
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "data->proc_file"
          ],
          "line": 441
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dentry_open",
          "args": [
            "&path",
            "file_mode(file->f_mode)",
            "cred"
          ],
          "line": 440
        },
        "resolved": true,
        "details": {
          "function_name": "dentry_open",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/open.c",
          "lines": "821-849",
          "snippet": "struct file *dentry_open(const struct path *path, int flags,\n\t\t\t const struct cred *cred)\n{\n\tint error;\n\tstruct file *f;\n\n\tvalidate_creds(cred);\n\n\t/* We must always pass in a valid mount pointer. */\n\tBUG_ON(!path->mnt);\n\n\tf = get_empty_filp();\n\tif (!IS_ERR(f)) {\n\t\tf->f_flags = flags;\n\t\terror = vfs_open(path, f, cred);\n\t\tif (!error) {\n\t\t\t/* from now on we need fput() to dispose of f */\n\t\t\terror = open_check_o_direct(f);\n\t\t\tif (error) {\n\t\t\t\tfput(f);\n\t\t\t\tf = ERR_PTR(error);\n\t\t\t}\n\t\t} else { \n\t\t\tput_filp(f);\n\t\t\tf = ERR_PTR(error);\n\t\t}\n\t}\n\treturn f;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/compat.h>",
            "#include <linux/dnotify.h>",
            "#include <linux/ima.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/falloc.h>",
            "#include <linux/audit.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/personality.h>",
            "#include <linux/fs.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/mount.h>",
            "#include <linux/security.h>",
            "#include <linux/securebits.h>",
            "#include <linux/capability.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/namei.h>",
            "#include <linux/tty.h>",
            "#include <linux/module.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/compat.h>\n#include <linux/dnotify.h>\n#include <linux/ima.h>\n#include <linux/fs_struct.h>\n#include <linux/falloc.h>\n#include <linux/audit.h>\n#include <linux/rcupdate.h>\n#include <linux/syscalls.h>\n#include <linux/pagemap.h>\n#include <linux/personality.h>\n#include <linux/fs.h>\n#include <asm/uaccess.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/mount.h>\n#include <linux/security.h>\n#include <linux/securebits.h>\n#include <linux/capability.h>\n#include <linux/backing-dev.h>\n#include <linux/namei.h>\n#include <linux/tty.h>\n#include <linux/module.h>\n#include <linux/fsnotify.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n\nstruct file *dentry_open(const struct path *path, int flags,\n\t\t\t const struct cred *cred)\n{\n\tint error;\n\tstruct file *f;\n\n\tvalidate_creds(cred);\n\n\t/* We must always pass in a valid mount pointer. */\n\tBUG_ON(!path->mnt);\n\n\tf = get_empty_filp();\n\tif (!IS_ERR(f)) {\n\t\tf->f_flags = flags;\n\t\terror = vfs_open(path, f, cred);\n\t\tif (!error) {\n\t\t\t/* from now on we need fput() to dispose of f */\n\t\t\terror = open_check_o_direct(f);\n\t\t\tif (error) {\n\t\t\t\tfput(f);\n\t\t\t\tf = ERR_PTR(error);\n\t\t\t}\n\t\t} else { \n\t\t\tput_filp(f);\n\t\t\tf = ERR_PTR(error);\n\t\t}\n\t}\n\treturn f;\n}"
        }
      },
      {
        "call_info": {
          "callee": "file_mode",
          "args": [
            "file->f_mode"
          ],
          "line": 440
        },
        "resolved": true,
        "details": {
          "function_name": "file_mode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hppfs/hppfs.c",
          "lines": "409-418",
          "snippet": "static int file_mode(int fmode)\n{\n\tif (fmode == (FMODE_READ | FMODE_WRITE))\n\t\treturn O_RDWR;\n\tif (fmode == FMODE_READ)\n\t\treturn O_RDONLY;\n\tif (fmode == FMODE_WRITE)\n\t\treturn O_WRONLY;\n\treturn 0;\n}",
          "includes": [
            "#include <os.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/namei.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/types.h>",
            "#include <linux/statfs.h>",
            "#include <linux/slab.h>",
            "#include <linux/mount.h>",
            "#include <linux/module.h>",
            "#include <linux/list.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/dcache.h>",
            "#include <linux/ctype.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <os.h>\n#include <asm/uaccess.h>\n#include <linux/namei.h>\n#include <linux/pid_namespace.h>\n#include <linux/types.h>\n#include <linux/statfs.h>\n#include <linux/slab.h>\n#include <linux/mount.h>\n#include <linux/module.h>\n#include <linux/list.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/dcache.h>\n#include <linux/ctype.h>\n\nstatic int file_mode(int fmode)\n{\n\tif (fmode == (FMODE_READ | FMODE_WRITE))\n\t\treturn O_RDWR;\n\tif (fmode == FMODE_READ)\n\t\treturn O_RDONLY;\n\tif (fmode == FMODE_WRITE)\n\t\treturn O_WRONLY;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "HPPFS_I",
          "args": [
            "inode"
          ],
          "line": 438
        },
        "resolved": true,
        "details": {
          "function_name": "HPPFS_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hppfs/hppfs.c",
          "lines": "42-45",
          "snippet": "static inline struct hppfs_inode_info *HPPFS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct hppfs_inode_info, vfs_inode);\n}",
          "includes": [
            "#include <os.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/namei.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/types.h>",
            "#include <linux/statfs.h>",
            "#include <linux/slab.h>",
            "#include <linux/mount.h>",
            "#include <linux/module.h>",
            "#include <linux/list.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/dcache.h>",
            "#include <linux/ctype.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <os.h>\n#include <asm/uaccess.h>\n#include <linux/namei.h>\n#include <linux/pid_namespace.h>\n#include <linux/types.h>\n#include <linux/statfs.h>\n#include <linux/slab.h>\n#include <linux/mount.h>\n#include <linux/module.h>\n#include <linux/list.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/dcache.h>\n#include <linux/ctype.h>\n\nstatic inline struct hppfs_inode_info *HPPFS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct hppfs_inode_info, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dentry_name",
          "args": [
            "file->f_path.dentry",
            "strlen(\"/rw\")"
          ],
          "line": 433
        },
        "resolved": true,
        "details": {
          "function_name": "dentry_name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hppfs/hppfs.c",
          "lines": "67-109",
          "snippet": "static char *dentry_name(struct dentry *dentry, int extra)\n{\n\tstruct dentry *parent;\n\tchar *root, *name;\n\tconst char *seg_name;\n\tint len, seg_len, root_len;\n\n\tlen = 0;\n\tparent = dentry;\n\twhile (parent->d_parent != parent) {\n\t\tif (is_pid(parent))\n\t\t\tlen += strlen(\"pid\") + 1;\n\t\telse len += parent->d_name.len + 1;\n\t\tparent = parent->d_parent;\n\t}\n\n\troot = \"proc\";\n\troot_len = strlen(root);\n\tlen += root_len;\n\tname = kmalloc(len + extra + 1, GFP_KERNEL);\n\tif (name == NULL)\n\t\treturn NULL;\n\n\tname[len] = '\\0';\n\tparent = dentry;\n\twhile (parent->d_parent != parent) {\n\t\tif (is_pid(parent)) {\n\t\t\tseg_name = \"pid\";\n\t\t\tseg_len = strlen(seg_name);\n\t\t}\n\t\telse {\n\t\t\tseg_name = parent->d_name.name;\n\t\t\tseg_len = parent->d_name.len;\n\t\t}\n\n\t\tlen -= seg_len + 1;\n\t\tname[len] = '/';\n\t\tmemcpy(&name[len + 1], seg_name, seg_len);\n\t\tparent = parent->d_parent;\n\t}\n\tmemcpy(name, root, root_len);\n\treturn name;\n}",
          "includes": [
            "#include <os.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/namei.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/types.h>",
            "#include <linux/statfs.h>",
            "#include <linux/slab.h>",
            "#include <linux/mount.h>",
            "#include <linux/module.h>",
            "#include <linux/list.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/dcache.h>",
            "#include <linux/ctype.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct inode *get_inode(struct super_block *, struct dentry *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <os.h>\n#include <asm/uaccess.h>\n#include <linux/namei.h>\n#include <linux/pid_namespace.h>\n#include <linux/types.h>\n#include <linux/statfs.h>\n#include <linux/slab.h>\n#include <linux/mount.h>\n#include <linux/module.h>\n#include <linux/list.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/dcache.h>\n#include <linux/ctype.h>\n\nstatic struct inode *get_inode(struct super_block *, struct dentry *);\n\nstatic char *dentry_name(struct dentry *dentry, int extra)\n{\n\tstruct dentry *parent;\n\tchar *root, *name;\n\tconst char *seg_name;\n\tint len, seg_len, root_len;\n\n\tlen = 0;\n\tparent = dentry;\n\twhile (parent->d_parent != parent) {\n\t\tif (is_pid(parent))\n\t\t\tlen += strlen(\"pid\") + 1;\n\t\telse len += parent->d_name.len + 1;\n\t\tparent = parent->d_parent;\n\t}\n\n\troot = \"proc\";\n\troot_len = strlen(root);\n\tlen += root_len;\n\tname = kmalloc(len + extra + 1, GFP_KERNEL);\n\tif (name == NULL)\n\t\treturn NULL;\n\n\tname[len] = '\\0';\n\tparent = dentry;\n\twhile (parent->d_parent != parent) {\n\t\tif (is_pid(parent)) {\n\t\t\tseg_name = \"pid\";\n\t\t\tseg_len = strlen(seg_name);\n\t\t}\n\t\telse {\n\t\t\tseg_name = parent->d_name.name;\n\t\t\tseg_len = parent->d_name.len;\n\t\t}\n\n\t\tlen -= seg_len + 1;\n\t\tname[len] = '/';\n\t\tmemcpy(&name[len + 1], seg_name, seg_len);\n\t\tparent = parent->d_parent;\n\t}\n\tmemcpy(name, root, root_len);\n\treturn name;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "\"/rw\""
          ],
          "line": 433
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_ea_strlen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/xattr.c",
          "lines": "351-363",
          "snippet": "static inline unsigned int gfs2_ea_strlen(struct gfs2_ea_header *ea)\n{\n\tswitch (ea->ea_type) {\n\tcase GFS2_EATYPE_USR:\n\t\treturn 5 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SYS:\n\t\treturn 7 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SECURITY:\n\t\treturn 9 + ea->ea_name_len + 1;\n\tdefault:\n\t\treturn 0;\n\t}\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"inode.h\"",
            "#include \"glock.h\"",
            "#include \"xattr.h\"",
            "#include \"acl.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/xattr.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"trans.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/xattr.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstatic inline unsigned int gfs2_ea_strlen(struct gfs2_ea_header *ea)\n{\n\tswitch (ea->ea_type) {\n\tcase GFS2_EATYPE_USR:\n\t\treturn 5 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SYS:\n\t\treturn 7 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SECURITY:\n\t\treturn 9 + ea->ea_name_len + 1;\n\tdefault:\n\t\treturn 0;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "hppfs_data",
          "args": [],
          "line": 429
        },
        "resolved": true,
        "details": {
          "function_name": "hppfs_data",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hppfs/hppfs.c",
          "lines": "395-407",
          "snippet": "static struct hppfs_private *hppfs_data(void)\n{\n\tstruct hppfs_private *data;\n\n\tdata = kmalloc(sizeof(*data), GFP_KERNEL);\n\tif (data == NULL)\n\t\treturn data;\n\n\t*data = ((struct hppfs_private ) { .host_fd  \t\t= -1,\n\t\t\t\t\t   .len  \t\t= -1,\n\t\t\t\t\t   .contents \t\t= NULL } );\n\treturn data;\n}",
          "includes": [
            "#include <os.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/namei.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/types.h>",
            "#include <linux/statfs.h>",
            "#include <linux/slab.h>",
            "#include <linux/mount.h>",
            "#include <linux/module.h>",
            "#include <linux/list.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/dcache.h>",
            "#include <linux/ctype.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <os.h>\n#include <asm/uaccess.h>\n#include <linux/namei.h>\n#include <linux/pid_namespace.h>\n#include <linux/types.h>\n#include <linux/statfs.h>\n#include <linux/slab.h>\n#include <linux/mount.h>\n#include <linux/module.h>\n#include <linux/list.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/dcache.h>\n#include <linux/ctype.h>\n\nstatic struct hppfs_private *hppfs_data(void)\n{\n\tstruct hppfs_private *data;\n\n\tdata = kmalloc(sizeof(*data), GFP_KERNEL);\n\tif (data == NULL)\n\t\treturn data;\n\n\t*data = ((struct hppfs_private ) { .host_fd  \t\t= -1,\n\t\t\t\t\t   .len  \t\t= -1,\n\t\t\t\t\t   .contents \t\t= NULL } );\n\treturn data;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <os.h>\n#include <asm/uaccess.h>\n#include <linux/namei.h>\n#include <linux/pid_namespace.h>\n#include <linux/types.h>\n#include <linux/statfs.h>\n#include <linux/slab.h>\n#include <linux/mount.h>\n#include <linux/module.h>\n#include <linux/list.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/dcache.h>\n#include <linux/ctype.h>\n\nstatic struct inode *get_inode(struct super_block *, struct dentry *);\n\nstatic int hppfs_open(struct inode *inode, struct file *file)\n{\n\tconst struct cred *cred = file->f_cred;\n\tstruct hppfs_private *data;\n\tstruct path path;\n\tchar *host_file;\n\tint err, fd, type, filter;\n\n\terr = -ENOMEM;\n\tdata = hppfs_data();\n\tif (data == NULL)\n\t\tgoto out;\n\n\thost_file = dentry_name(file->f_path.dentry, strlen(\"/rw\"));\n\tif (host_file == NULL)\n\t\tgoto out_free2;\n\n\tpath.mnt = inode->i_sb->s_fs_info;\n\tpath.dentry = HPPFS_I(inode)->proc_dentry;\n\n\tdata->proc_file = dentry_open(&path, file_mode(file->f_mode), cred);\n\terr = PTR_ERR(data->proc_file);\n\tif (IS_ERR(data->proc_file))\n\t\tgoto out_free1;\n\n\ttype = os_file_type(host_file);\n\tif (type == OS_TYPE_FILE) {\n\t\tfd = os_open_file(host_file, of_read(OPENFLAGS()), 0);\n\t\tif (fd >= 0)\n\t\t\tdata->host_fd = fd;\n\t\telse\n\t\t\tprintk(KERN_ERR \"hppfs_open : failed to open '%s', \"\n\t\t\t       \"errno = %d\\n\", host_file, -fd);\n\n\t\tdata->contents = NULL;\n\t} else if (type == OS_TYPE_DIR) {\n\t\tfd = open_host_sock(host_file, &filter);\n\t\tif (fd > 0) {\n\t\t\tdata->contents = hppfs_get_data(fd, filter,\n\t\t\t\t\t\t\tdata->proc_file,\n\t\t\t\t\t\t\tfile, &data->len);\n\t\t\tif (!IS_ERR(data->contents))\n\t\t\t\tdata->host_fd = fd;\n\t\t} else\n\t\t\tprintk(KERN_ERR \"hppfs_open : failed to open a socket \"\n\t\t\t       \"in '%s', errno = %d\\n\", host_file, -fd);\n\t}\n\tkfree(host_file);\n\n\tfile->private_data = data;\n\treturn 0;\n\n out_free1:\n\tkfree(host_file);\n out_free2:\n\tfree_contents(data->contents);\n\tkfree(data);\n out:\n\treturn err;\n}"
  },
  {
    "function_name": "file_mode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hppfs/hppfs.c",
    "lines": "409-418",
    "snippet": "static int file_mode(int fmode)\n{\n\tif (fmode == (FMODE_READ | FMODE_WRITE))\n\t\treturn O_RDWR;\n\tif (fmode == FMODE_READ)\n\t\treturn O_RDONLY;\n\tif (fmode == FMODE_WRITE)\n\t\treturn O_WRONLY;\n\treturn 0;\n}",
    "includes": [
      "#include <os.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/namei.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/types.h>",
      "#include <linux/statfs.h>",
      "#include <linux/slab.h>",
      "#include <linux/mount.h>",
      "#include <linux/module.h>",
      "#include <linux/list.h>",
      "#include <linux/kernel.h>",
      "#include <linux/init.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/dcache.h>",
      "#include <linux/ctype.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <os.h>\n#include <asm/uaccess.h>\n#include <linux/namei.h>\n#include <linux/pid_namespace.h>\n#include <linux/types.h>\n#include <linux/statfs.h>\n#include <linux/slab.h>\n#include <linux/mount.h>\n#include <linux/module.h>\n#include <linux/list.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/dcache.h>\n#include <linux/ctype.h>\n\nstatic int file_mode(int fmode)\n{\n\tif (fmode == (FMODE_READ | FMODE_WRITE))\n\t\treturn O_RDWR;\n\tif (fmode == FMODE_READ)\n\t\treturn O_RDONLY;\n\tif (fmode == FMODE_WRITE)\n\t\treturn O_WRONLY;\n\treturn 0;\n}"
  },
  {
    "function_name": "hppfs_data",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hppfs/hppfs.c",
    "lines": "395-407",
    "snippet": "static struct hppfs_private *hppfs_data(void)\n{\n\tstruct hppfs_private *data;\n\n\tdata = kmalloc(sizeof(*data), GFP_KERNEL);\n\tif (data == NULL)\n\t\treturn data;\n\n\t*data = ((struct hppfs_private ) { .host_fd  \t\t= -1,\n\t\t\t\t\t   .len  \t\t= -1,\n\t\t\t\t\t   .contents \t\t= NULL } );\n\treturn data;\n}",
    "includes": [
      "#include <os.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/namei.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/types.h>",
      "#include <linux/statfs.h>",
      "#include <linux/slab.h>",
      "#include <linux/mount.h>",
      "#include <linux/module.h>",
      "#include <linux/list.h>",
      "#include <linux/kernel.h>",
      "#include <linux/init.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/dcache.h>",
      "#include <linux/ctype.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "sizeof(*data)",
            "GFP_KERNEL"
          ],
          "line": 399
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dx_dir_kmalloc_leaves",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "2534-2546",
          "snippet": "static struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <os.h>\n#include <asm/uaccess.h>\n#include <linux/namei.h>\n#include <linux/pid_namespace.h>\n#include <linux/types.h>\n#include <linux/statfs.h>\n#include <linux/slab.h>\n#include <linux/mount.h>\n#include <linux/module.h>\n#include <linux/list.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/dcache.h>\n#include <linux/ctype.h>\n\nstatic struct hppfs_private *hppfs_data(void)\n{\n\tstruct hppfs_private *data;\n\n\tdata = kmalloc(sizeof(*data), GFP_KERNEL);\n\tif (data == NULL)\n\t\treturn data;\n\n\t*data = ((struct hppfs_private ) { .host_fd  \t\t= -1,\n\t\t\t\t\t   .len  \t\t= -1,\n\t\t\t\t\t   .contents \t\t= NULL } );\n\treturn data;\n}"
  },
  {
    "function_name": "hppfs_get_data",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hppfs/hppfs.c",
    "lines": "329-393",
    "snippet": "static struct hppfs_data *hppfs_get_data(int fd, int filter,\n\t\t\t\t\t struct file *proc_file,\n\t\t\t\t\t struct file *hppfs_file,\n\t\t\t\t\t loff_t *size_out)\n{\n\tstruct hppfs_data *data, *new, *head;\n\tint n, err;\n\n\terr = -ENOMEM;\n\tdata = kmalloc(sizeof(*data), GFP_KERNEL);\n\tif (data == NULL) {\n\t\tprintk(KERN_ERR \"hppfs_get_data : head allocation failed\\n\");\n\t\tgoto failed;\n\t}\n\n\tINIT_LIST_HEAD(&data->list);\n\n\thead = data;\n\t*size_out = 0;\n\n\tif (filter) {\n\t\twhile ((n = read_proc(proc_file, data->contents,\n\t\t\t\t      sizeof(data->contents), NULL, 0)) > 0)\n\t\t\tos_write_file(fd, data->contents, n);\n\t\terr = os_shutdown_socket(fd, 0, 1);\n\t\tif (err) {\n\t\t\tprintk(KERN_ERR \"hppfs_get_data : failed to shut down \"\n\t\t\t       \"socket\\n\");\n\t\t\tgoto failed_free;\n\t\t}\n\t}\n\twhile (1) {\n\t\tn = os_read_file(fd, data->contents, sizeof(data->contents));\n\t\tif (n < 0) {\n\t\t\terr = n;\n\t\t\tprintk(KERN_ERR \"hppfs_get_data : read failed, \"\n\t\t\t       \"errno = %d\\n\", err);\n\t\t\tgoto failed_free;\n\t\t} else if (n == 0)\n\t\t\tbreak;\n\n\t\t*size_out += n;\n\n\t\tif (n < sizeof(data->contents))\n\t\t\tbreak;\n\n\t\tnew = kmalloc(sizeof(*data), GFP_KERNEL);\n\t\tif (new == 0) {\n\t\t\tprintk(KERN_ERR \"hppfs_get_data : data allocation \"\n\t\t\t       \"failed\\n\");\n\t\t\terr = -ENOMEM;\n\t\t\tgoto failed_free;\n\t\t}\n\n\t\tINIT_LIST_HEAD(&new->list);\n\t\tlist_add(&new->list, &data->list);\n\t\tdata = new;\n\t}\n\treturn head;\n\n failed_free:\n\tfree_contents(head);\n failed:\n\treturn ERR_PTR(err);\n}",
    "includes": [
      "#include <os.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/namei.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/types.h>",
      "#include <linux/statfs.h>",
      "#include <linux/slab.h>",
      "#include <linux/mount.h>",
      "#include <linux/module.h>",
      "#include <linux/list.h>",
      "#include <linux/kernel.h>",
      "#include <linux/init.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/dcache.h>",
      "#include <linux/ctype.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "err"
          ],
          "line": 392
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free_contents",
          "args": [
            "head"
          ],
          "line": 390
        },
        "resolved": true,
        "details": {
          "function_name": "free_contents",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hppfs/hppfs.c",
          "lines": "314-327",
          "snippet": "static void free_contents(struct hppfs_data *head)\n{\n\tstruct hppfs_data *data;\n\tstruct list_head *ele, *next;\n\n\tif (head == NULL)\n\t\treturn;\n\n\tlist_for_each_safe(ele, next, &head->list) {\n\t\tdata = list_entry(ele, struct hppfs_data, list);\n\t\tkfree(data);\n\t}\n\tkfree(head);\n}",
          "includes": [
            "#include <os.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/namei.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/types.h>",
            "#include <linux/statfs.h>",
            "#include <linux/slab.h>",
            "#include <linux/mount.h>",
            "#include <linux/module.h>",
            "#include <linux/list.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/dcache.h>",
            "#include <linux/ctype.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <os.h>\n#include <asm/uaccess.h>\n#include <linux/namei.h>\n#include <linux/pid_namespace.h>\n#include <linux/types.h>\n#include <linux/statfs.h>\n#include <linux/slab.h>\n#include <linux/mount.h>\n#include <linux/module.h>\n#include <linux/list.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/dcache.h>\n#include <linux/ctype.h>\n\nstatic void free_contents(struct hppfs_data *head)\n{\n\tstruct hppfs_data *data;\n\tstruct list_head *ele, *next;\n\n\tif (head == NULL)\n\t\treturn;\n\n\tlist_for_each_safe(ele, next, &head->list) {\n\t\tdata = list_entry(ele, struct hppfs_data, list);\n\t\tkfree(data);\n\t}\n\tkfree(head);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_add",
          "args": [
            "&new->list",
            "&data->list"
          ],
          "line": 384
        },
        "resolved": true,
        "details": {
          "function_name": "simple_xattr_list_add",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xattr.c",
          "lines": "966-972",
          "snippet": "void simple_xattr_list_add(struct simple_xattrs *xattrs,\n\t\t\t   struct simple_xattr *new_xattr)\n{\n\tspin_lock(&xattrs->lock);\n\tlist_add(&new_xattr->list, &xattrs->head);\n\tspin_unlock(&xattrs->lock);\n}",
          "includes": [
            "#include <asm/uaccess.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/audit.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/evm.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/xattr.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/vmalloc.h>\n#include <linux/audit.h>\n#include <linux/fsnotify.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n#include <linux/evm.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/xattr.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nvoid simple_xattr_list_add(struct simple_xattrs *xattrs,\n\t\t\t   struct simple_xattr *new_xattr)\n{\n\tspin_lock(&xattrs->lock);\n\tlist_add(&new_xattr->list, &xattrs->head);\n\tspin_unlock(&xattrs->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&new->list"
          ],
          "line": 383
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_ERR \"hppfs_get_data : data allocation \"\n\t\t\t       \"failed\\n\""
          ],
          "line": 377
        },
        "resolved": true,
        "details": {
          "function_name": "compat_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/compat.c",
          "lines": "59-69",
          "snippet": "int compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/ioctls.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/aio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/mm.h>",
            "#include <linux/poll.h>",
            "#include <linux/signal.h>",
            "#include <linux/highmem.h>",
            "#include <linux/security.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/personality.h>",
            "#include <linux/highuid.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/dirent.h>",
            "#include <linux/ctype.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/nfs4_mount.h>",
            "#include <linux/ncp_mount.h>",
            "#include <linux/init.h>",
            "#include <linux/ioctl.h>",
            "#include <linux/vfs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/namei.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/errno.h>",
            "#include <linux/compat.h>",
            "#include <linux/linkage.h>",
            "#include <linux/kernel.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int compat_log = 1;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/ioctls.h>\n#include <asm/mmu_context.h>\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/fs_struct.h>\n#include <linux/mm.h>\n#include <linux/poll.h>\n#include <linux/signal.h>\n#include <linux/highmem.h>\n#include <linux/security.h>\n#include <linux/tsacct_kern.h>\n#include <linux/rwsem.h>\n#include <linux/personality.h>\n#include <linux/highuid.h>\n#include <linux/fsnotify.h>\n#include <linux/dirent.h>\n#include <linux/ctype.h>\n#include <linux/syscalls.h>\n#include <linux/nfs4_mount.h>\n#include <linux/ncp_mount.h>\n#include <linux/init.h>\n#include <linux/ioctl.h>\n#include <linux/vfs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/namei.h>\n#include <linux/fcntl.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <linux/compat.h>\n#include <linux/linkage.h>\n#include <linux/kernel.h>\n#include <linux/stddef.h>\n\nint compat_log = 1;\n\nint compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "sizeof(*data)",
            "GFP_KERNEL"
          ],
          "line": 375
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dx_dir_kmalloc_leaves",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "2534-2546",
          "snippet": "static struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}"
        }
      },
      {
        "call_info": {
          "callee": "os_read_file",
          "args": [
            "fd",
            "data->contents",
            "sizeof(data->contents)"
          ],
          "line": 361
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "os_shutdown_socket",
          "args": [
            "fd",
            "0",
            "1"
          ],
          "line": 353
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "os_write_file",
          "args": [
            "fd",
            "data->contents",
            "n"
          ],
          "line": 352
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "read_proc",
          "args": [
            "proc_file",
            "data->contents",
            "sizeof(data->contents)",
            "NULL",
            "0"
          ],
          "line": 350
        },
        "resolved": true,
        "details": {
          "function_name": "read_proc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hppfs/hppfs.c",
          "lines": "178-197",
          "snippet": "static ssize_t read_proc(struct file *file, char __user *buf, ssize_t count,\n\t\t\t loff_t *ppos, int is_user)\n{\n\tssize_t (*read)(struct file *, char __user *, size_t, loff_t *);\n\tssize_t n;\n\n\tread = file_inode(file)->i_fop->read;\n\n\tif (!is_user)\n\t\tset_fs(KERNEL_DS);\n\n\tn = (*read)(file, buf, count, &file->f_pos);\n\n\tif (!is_user)\n\t\tset_fs(USER_DS);\n\n\tif (ppos)\n\t\t*ppos = file->f_pos;\n\treturn n;\n}",
          "includes": [
            "#include <os.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/namei.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/types.h>",
            "#include <linux/statfs.h>",
            "#include <linux/slab.h>",
            "#include <linux/mount.h>",
            "#include <linux/module.h>",
            "#include <linux/list.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/dcache.h>",
            "#include <linux/ctype.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <os.h>\n#include <asm/uaccess.h>\n#include <linux/namei.h>\n#include <linux/pid_namespace.h>\n#include <linux/types.h>\n#include <linux/statfs.h>\n#include <linux/slab.h>\n#include <linux/mount.h>\n#include <linux/module.h>\n#include <linux/list.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/dcache.h>\n#include <linux/ctype.h>\n\nstatic ssize_t read_proc(struct file *file, char __user *buf, ssize_t count,\n\t\t\t loff_t *ppos, int is_user)\n{\n\tssize_t (*read)(struct file *, char __user *, size_t, loff_t *);\n\tssize_t n;\n\n\tread = file_inode(file)->i_fop->read;\n\n\tif (!is_user)\n\t\tset_fs(KERNEL_DS);\n\n\tn = (*read)(file, buf, count, &file->f_pos);\n\n\tif (!is_user)\n\t\tset_fs(USER_DS);\n\n\tif (ppos)\n\t\t*ppos = file->f_pos;\n\treturn n;\n}"
        }
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&data->list"
          ],
          "line": 344
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <os.h>\n#include <asm/uaccess.h>\n#include <linux/namei.h>\n#include <linux/pid_namespace.h>\n#include <linux/types.h>\n#include <linux/statfs.h>\n#include <linux/slab.h>\n#include <linux/mount.h>\n#include <linux/module.h>\n#include <linux/list.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/dcache.h>\n#include <linux/ctype.h>\n\nstatic struct hppfs_data *hppfs_get_data(int fd, int filter,\n\t\t\t\t\t struct file *proc_file,\n\t\t\t\t\t struct file *hppfs_file,\n\t\t\t\t\t loff_t *size_out)\n{\n\tstruct hppfs_data *data, *new, *head;\n\tint n, err;\n\n\terr = -ENOMEM;\n\tdata = kmalloc(sizeof(*data), GFP_KERNEL);\n\tif (data == NULL) {\n\t\tprintk(KERN_ERR \"hppfs_get_data : head allocation failed\\n\");\n\t\tgoto failed;\n\t}\n\n\tINIT_LIST_HEAD(&data->list);\n\n\thead = data;\n\t*size_out = 0;\n\n\tif (filter) {\n\t\twhile ((n = read_proc(proc_file, data->contents,\n\t\t\t\t      sizeof(data->contents), NULL, 0)) > 0)\n\t\t\tos_write_file(fd, data->contents, n);\n\t\terr = os_shutdown_socket(fd, 0, 1);\n\t\tif (err) {\n\t\t\tprintk(KERN_ERR \"hppfs_get_data : failed to shut down \"\n\t\t\t       \"socket\\n\");\n\t\t\tgoto failed_free;\n\t\t}\n\t}\n\twhile (1) {\n\t\tn = os_read_file(fd, data->contents, sizeof(data->contents));\n\t\tif (n < 0) {\n\t\t\terr = n;\n\t\t\tprintk(KERN_ERR \"hppfs_get_data : read failed, \"\n\t\t\t       \"errno = %d\\n\", err);\n\t\t\tgoto failed_free;\n\t\t} else if (n == 0)\n\t\t\tbreak;\n\n\t\t*size_out += n;\n\n\t\tif (n < sizeof(data->contents))\n\t\t\tbreak;\n\n\t\tnew = kmalloc(sizeof(*data), GFP_KERNEL);\n\t\tif (new == 0) {\n\t\t\tprintk(KERN_ERR \"hppfs_get_data : data allocation \"\n\t\t\t       \"failed\\n\");\n\t\t\terr = -ENOMEM;\n\t\t\tgoto failed_free;\n\t\t}\n\n\t\tINIT_LIST_HEAD(&new->list);\n\t\tlist_add(&new->list, &data->list);\n\t\tdata = new;\n\t}\n\treturn head;\n\n failed_free:\n\tfree_contents(head);\n failed:\n\treturn ERR_PTR(err);\n}"
  },
  {
    "function_name": "free_contents",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hppfs/hppfs.c",
    "lines": "314-327",
    "snippet": "static void free_contents(struct hppfs_data *head)\n{\n\tstruct hppfs_data *data;\n\tstruct list_head *ele, *next;\n\n\tif (head == NULL)\n\t\treturn;\n\n\tlist_for_each_safe(ele, next, &head->list) {\n\t\tdata = list_entry(ele, struct hppfs_data, list);\n\t\tkfree(data);\n\t}\n\tkfree(head);\n}",
    "includes": [
      "#include <os.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/namei.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/types.h>",
      "#include <linux/statfs.h>",
      "#include <linux/slab.h>",
      "#include <linux/mount.h>",
      "#include <linux/module.h>",
      "#include <linux/list.h>",
      "#include <linux/kernel.h>",
      "#include <linux/init.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/dcache.h>",
      "#include <linux/ctype.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "head"
          ],
          "line": 326
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "data"
          ],
          "line": 324
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_entry",
          "args": [
            "ele",
            "structhppfs_data",
            "list"
          ],
          "line": 323
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_safe",
          "args": [
            "ele",
            "next",
            "&head->list"
          ],
          "line": 322
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <os.h>\n#include <asm/uaccess.h>\n#include <linux/namei.h>\n#include <linux/pid_namespace.h>\n#include <linux/types.h>\n#include <linux/statfs.h>\n#include <linux/slab.h>\n#include <linux/mount.h>\n#include <linux/module.h>\n#include <linux/list.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/dcache.h>\n#include <linux/ctype.h>\n\nstatic void free_contents(struct hppfs_data *head)\n{\n\tstruct hppfs_data *data;\n\tstruct list_head *ele, *next;\n\n\tif (head == NULL)\n\t\treturn;\n\n\tlist_for_each_safe(ele, next, &head->list) {\n\t\tdata = list_entry(ele, struct hppfs_data, list);\n\t\tkfree(data);\n\t}\n\tkfree(head);\n}"
  },
  {
    "function_name": "open_host_sock",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hppfs/hppfs.c",
    "lines": "296-312",
    "snippet": "static int open_host_sock(char *host_file, int *filter_out)\n{\n\tchar *end;\n\tint fd;\n\n\tend = &host_file[strlen(host_file)];\n\tstrcpy(end, \"/rw\");\n\t*filter_out = 1;\n\tfd = os_connect_socket(host_file);\n\tif (fd > 0)\n\t\treturn fd;\n\n\tstrcpy(end, \"/r\");\n\t*filter_out = 0;\n\tfd = os_connect_socket(host_file);\n\treturn fd;\n}",
    "includes": [
      "#include <os.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/namei.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/types.h>",
      "#include <linux/statfs.h>",
      "#include <linux/slab.h>",
      "#include <linux/mount.h>",
      "#include <linux/module.h>",
      "#include <linux/list.h>",
      "#include <linux/kernel.h>",
      "#include <linux/init.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/dcache.h>",
      "#include <linux/ctype.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "os_connect_socket",
          "args": [
            "host_file"
          ],
          "line": 310
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcpy",
          "args": [
            "end",
            "\"/r\""
          ],
          "line": 308
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "os_connect_socket",
          "args": [
            "host_file"
          ],
          "line": 304
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcpy",
          "args": [
            "end",
            "\"/rw\""
          ],
          "line": 302
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "host_file"
          ],
          "line": 301
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_ea_strlen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/xattr.c",
          "lines": "351-363",
          "snippet": "static inline unsigned int gfs2_ea_strlen(struct gfs2_ea_header *ea)\n{\n\tswitch (ea->ea_type) {\n\tcase GFS2_EATYPE_USR:\n\t\treturn 5 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SYS:\n\t\treturn 7 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SECURITY:\n\t\treturn 9 + ea->ea_name_len + 1;\n\tdefault:\n\t\treturn 0;\n\t}\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"inode.h\"",
            "#include \"glock.h\"",
            "#include \"xattr.h\"",
            "#include \"acl.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/xattr.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"trans.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/xattr.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstatic inline unsigned int gfs2_ea_strlen(struct gfs2_ea_header *ea)\n{\n\tswitch (ea->ea_type) {\n\tcase GFS2_EATYPE_USR:\n\t\treturn 5 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SYS:\n\t\treturn 7 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SECURITY:\n\t\treturn 9 + ea->ea_name_len + 1;\n\tdefault:\n\t\treturn 0;\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include <os.h>\n#include <asm/uaccess.h>\n#include <linux/namei.h>\n#include <linux/pid_namespace.h>\n#include <linux/types.h>\n#include <linux/statfs.h>\n#include <linux/slab.h>\n#include <linux/mount.h>\n#include <linux/module.h>\n#include <linux/list.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/dcache.h>\n#include <linux/ctype.h>\n\nstatic int open_host_sock(char *host_file, int *filter_out)\n{\n\tchar *end;\n\tint fd;\n\n\tend = &host_file[strlen(host_file)];\n\tstrcpy(end, \"/rw\");\n\t*filter_out = 1;\n\tfd = os_connect_socket(host_file);\n\tif (fd > 0)\n\t\treturn fd;\n\n\tstrcpy(end, \"/r\");\n\t*filter_out = 0;\n\tfd = os_connect_socket(host_file);\n\treturn fd;\n}"
  },
  {
    "function_name": "hppfs_write",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hppfs/hppfs.c",
    "lines": "285-294",
    "snippet": "static ssize_t hppfs_write(struct file *file, const char __user *buf,\n\t\t\t   size_t len, loff_t *ppos)\n{\n\tstruct hppfs_private *data = file->private_data;\n\tstruct file *proc_file = data->proc_file;\n\tssize_t (*write)(struct file *, const char __user *, size_t, loff_t *);\n\n\twrite = file_inode(proc_file)->i_fop->write;\n\treturn (*write)(proc_file, buf, len, ppos);\n}",
    "includes": [
      "#include <os.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/namei.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/types.h>",
      "#include <linux/statfs.h>",
      "#include <linux/slab.h>",
      "#include <linux/mount.h>",
      "#include <linux/module.h>",
      "#include <linux/list.h>",
      "#include <linux/kernel.h>",
      "#include <linux/init.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/dcache.h>",
      "#include <linux/ctype.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "",
          "args": [
            "proc_file",
            "buf",
            "len",
            "ppos"
          ],
          "line": 293
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "file_inode",
          "args": [
            "proc_file"
          ],
          "line": 292
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_init_file_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/file.c",
          "lines": "3009-3013",
          "snippet": "void fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}",
          "includes": [
            "#include <linux/falloc.h>",
            "#include <linux/aio.h>",
            "#include <linux/swap.h>",
            "#include <linux/compat.h>",
            "#include <linux/module.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};",
            "static const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/compat.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};\nstatic const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};\n\nvoid fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <os.h>\n#include <asm/uaccess.h>\n#include <linux/namei.h>\n#include <linux/pid_namespace.h>\n#include <linux/types.h>\n#include <linux/statfs.h>\n#include <linux/slab.h>\n#include <linux/mount.h>\n#include <linux/module.h>\n#include <linux/list.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/dcache.h>\n#include <linux/ctype.h>\n\nstatic ssize_t hppfs_write(struct file *file, const char __user *buf,\n\t\t\t   size_t len, loff_t *ppos)\n{\n\tstruct hppfs_private *data = file->private_data;\n\tstruct file *proc_file = data->proc_file;\n\tssize_t (*write)(struct file *, const char __user *, size_t, loff_t *);\n\n\twrite = file_inode(proc_file)->i_fop->write;\n\treturn (*write)(proc_file, buf, len, ppos);\n}"
  },
  {
    "function_name": "hppfs_read",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hppfs/hppfs.c",
    "lines": "236-283",
    "snippet": "static ssize_t hppfs_read(struct file *file, char __user *buf, size_t count,\n\t\t\t  loff_t *ppos)\n{\n\tstruct hppfs_private *hppfs = file->private_data;\n\tstruct hppfs_data *data;\n\tloff_t off;\n\tint err;\n\n\tif (hppfs->contents != NULL) {\n\t\tint rem;\n\n\t\tif (*ppos >= hppfs->len)\n\t\t\treturn 0;\n\n\t\tdata = hppfs->contents;\n\t\toff = *ppos;\n\t\twhile (off >= sizeof(data->contents)) {\n\t\t\tdata = list_entry(data->list.next, struct hppfs_data,\n\t\t\t\t\t  list);\n\t\t\toff -= sizeof(data->contents);\n\t\t}\n\n\t\tif (off + count > hppfs->len)\n\t\t\tcount = hppfs->len - off;\n\t\trem = copy_to_user(buf, &data->contents[off], count);\n\t\t*ppos += count - rem;\n\t\tif (rem > 0)\n\t\t\treturn -EFAULT;\n\t} else if (hppfs->host_fd != -1) {\n\t\terr = os_seek_file(hppfs->host_fd, *ppos);\n\t\tif (err) {\n\t\t\tprintk(KERN_ERR \"hppfs_read : seek failed, \"\n\t\t\t       \"errno = %d\\n\", err);\n\t\t\treturn err;\n\t\t}\n\t\terr = hppfs_read_file(hppfs->host_fd, buf, count);\n\t\tif (err < 0) {\n\t\t\tprintk(KERN_ERR \"hppfs_read: read failed: %d\\n\", err);\n\t\t\treturn err;\n\t\t}\n\t\tcount = err;\n\t\tif (count > 0)\n\t\t\t*ppos += count;\n\t}\n\telse count = read_proc(hppfs->proc_file, buf, count, ppos, 1);\n\n\treturn count;\n}",
    "includes": [
      "#include <os.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/namei.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/types.h>",
      "#include <linux/statfs.h>",
      "#include <linux/slab.h>",
      "#include <linux/mount.h>",
      "#include <linux/module.h>",
      "#include <linux/list.h>",
      "#include <linux/kernel.h>",
      "#include <linux/init.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/dcache.h>",
      "#include <linux/ctype.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "read_proc",
          "args": [
            "hppfs->proc_file",
            "buf",
            "count",
            "ppos",
            "1"
          ],
          "line": 280
        },
        "resolved": true,
        "details": {
          "function_name": "read_proc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hppfs/hppfs.c",
          "lines": "178-197",
          "snippet": "static ssize_t read_proc(struct file *file, char __user *buf, ssize_t count,\n\t\t\t loff_t *ppos, int is_user)\n{\n\tssize_t (*read)(struct file *, char __user *, size_t, loff_t *);\n\tssize_t n;\n\n\tread = file_inode(file)->i_fop->read;\n\n\tif (!is_user)\n\t\tset_fs(KERNEL_DS);\n\n\tn = (*read)(file, buf, count, &file->f_pos);\n\n\tif (!is_user)\n\t\tset_fs(USER_DS);\n\n\tif (ppos)\n\t\t*ppos = file->f_pos;\n\treturn n;\n}",
          "includes": [
            "#include <os.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/namei.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/types.h>",
            "#include <linux/statfs.h>",
            "#include <linux/slab.h>",
            "#include <linux/mount.h>",
            "#include <linux/module.h>",
            "#include <linux/list.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/dcache.h>",
            "#include <linux/ctype.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <os.h>\n#include <asm/uaccess.h>\n#include <linux/namei.h>\n#include <linux/pid_namespace.h>\n#include <linux/types.h>\n#include <linux/statfs.h>\n#include <linux/slab.h>\n#include <linux/mount.h>\n#include <linux/module.h>\n#include <linux/list.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/dcache.h>\n#include <linux/ctype.h>\n\nstatic ssize_t read_proc(struct file *file, char __user *buf, ssize_t count,\n\t\t\t loff_t *ppos, int is_user)\n{\n\tssize_t (*read)(struct file *, char __user *, size_t, loff_t *);\n\tssize_t n;\n\n\tread = file_inode(file)->i_fop->read;\n\n\tif (!is_user)\n\t\tset_fs(KERNEL_DS);\n\n\tn = (*read)(file, buf, count, &file->f_pos);\n\n\tif (!is_user)\n\t\tset_fs(USER_DS);\n\n\tif (ppos)\n\t\t*ppos = file->f_pos;\n\treturn n;\n}"
        }
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_ERR \"hppfs_read: read failed: %d\\n\"",
            "err"
          ],
          "line": 273
        },
        "resolved": true,
        "details": {
          "function_name": "compat_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/compat.c",
          "lines": "59-69",
          "snippet": "int compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/ioctls.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/aio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/mm.h>",
            "#include <linux/poll.h>",
            "#include <linux/signal.h>",
            "#include <linux/highmem.h>",
            "#include <linux/security.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/personality.h>",
            "#include <linux/highuid.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/dirent.h>",
            "#include <linux/ctype.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/nfs4_mount.h>",
            "#include <linux/ncp_mount.h>",
            "#include <linux/init.h>",
            "#include <linux/ioctl.h>",
            "#include <linux/vfs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/namei.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/errno.h>",
            "#include <linux/compat.h>",
            "#include <linux/linkage.h>",
            "#include <linux/kernel.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int compat_log = 1;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/ioctls.h>\n#include <asm/mmu_context.h>\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/fs_struct.h>\n#include <linux/mm.h>\n#include <linux/poll.h>\n#include <linux/signal.h>\n#include <linux/highmem.h>\n#include <linux/security.h>\n#include <linux/tsacct_kern.h>\n#include <linux/rwsem.h>\n#include <linux/personality.h>\n#include <linux/highuid.h>\n#include <linux/fsnotify.h>\n#include <linux/dirent.h>\n#include <linux/ctype.h>\n#include <linux/syscalls.h>\n#include <linux/nfs4_mount.h>\n#include <linux/ncp_mount.h>\n#include <linux/init.h>\n#include <linux/ioctl.h>\n#include <linux/vfs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/namei.h>\n#include <linux/fcntl.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <linux/compat.h>\n#include <linux/linkage.h>\n#include <linux/kernel.h>\n#include <linux/stddef.h>\n\nint compat_log = 1;\n\nint compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "hppfs_read_file",
          "args": [
            "hppfs->host_fd",
            "buf",
            "count"
          ],
          "line": 271
        },
        "resolved": true,
        "details": {
          "function_name": "hppfs_read_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hppfs/hppfs.c",
          "lines": "199-234",
          "snippet": "static ssize_t hppfs_read_file(int fd, char __user *buf, ssize_t count)\n{\n\tssize_t n;\n\tint cur, err;\n\tchar *new_buf;\n\n\tn = -ENOMEM;\n\tnew_buf = kmalloc(PAGE_SIZE, GFP_KERNEL);\n\tif (new_buf == NULL) {\n\t\tprintk(KERN_ERR \"hppfs_read_file : kmalloc failed\\n\");\n\t\tgoto out;\n\t}\n\tn = 0;\n\twhile (count > 0) {\n\t\tcur = min_t(ssize_t, count, PAGE_SIZE);\n\t\terr = os_read_file(fd, new_buf, cur);\n\t\tif (err < 0) {\n\t\t\tprintk(KERN_ERR \"hppfs_read : read failed, \"\n\t\t\t       \"errno = %d\\n\", err);\n\t\t\tn = err;\n\t\t\tgoto out_free;\n\t\t} else if (err == 0)\n\t\t\tbreak;\n\n\t\tif (copy_to_user(buf, new_buf, err)) {\n\t\t\tn = -EFAULT;\n\t\t\tgoto out_free;\n\t\t}\n\t\tn += err;\n\t\tcount -= err;\n\t}\n out_free:\n\tkfree(new_buf);\n out:\n\treturn n;\n}",
          "includes": [
            "#include <os.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/namei.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/types.h>",
            "#include <linux/statfs.h>",
            "#include <linux/slab.h>",
            "#include <linux/mount.h>",
            "#include <linux/module.h>",
            "#include <linux/list.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/dcache.h>",
            "#include <linux/ctype.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <os.h>\n#include <asm/uaccess.h>\n#include <linux/namei.h>\n#include <linux/pid_namespace.h>\n#include <linux/types.h>\n#include <linux/statfs.h>\n#include <linux/slab.h>\n#include <linux/mount.h>\n#include <linux/module.h>\n#include <linux/list.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/dcache.h>\n#include <linux/ctype.h>\n\nstatic ssize_t hppfs_read_file(int fd, char __user *buf, ssize_t count)\n{\n\tssize_t n;\n\tint cur, err;\n\tchar *new_buf;\n\n\tn = -ENOMEM;\n\tnew_buf = kmalloc(PAGE_SIZE, GFP_KERNEL);\n\tif (new_buf == NULL) {\n\t\tprintk(KERN_ERR \"hppfs_read_file : kmalloc failed\\n\");\n\t\tgoto out;\n\t}\n\tn = 0;\n\twhile (count > 0) {\n\t\tcur = min_t(ssize_t, count, PAGE_SIZE);\n\t\terr = os_read_file(fd, new_buf, cur);\n\t\tif (err < 0) {\n\t\t\tprintk(KERN_ERR \"hppfs_read : read failed, \"\n\t\t\t       \"errno = %d\\n\", err);\n\t\t\tn = err;\n\t\t\tgoto out_free;\n\t\t} else if (err == 0)\n\t\t\tbreak;\n\n\t\tif (copy_to_user(buf, new_buf, err)) {\n\t\t\tn = -EFAULT;\n\t\t\tgoto out_free;\n\t\t}\n\t\tn += err;\n\t\tcount -= err;\n\t}\n out_free:\n\tkfree(new_buf);\n out:\n\treturn n;\n}"
        }
      },
      {
        "call_info": {
          "callee": "os_seek_file",
          "args": [
            "hppfs->host_fd",
            "*ppos"
          ],
          "line": 265
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "copy_to_user",
          "args": [
            "buf",
            "&data->contents[off]",
            "count"
          ],
          "line": 260
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_entry",
          "args": [
            "data->list.next",
            "structhppfs_data",
            "list"
          ],
          "line": 253
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <os.h>\n#include <asm/uaccess.h>\n#include <linux/namei.h>\n#include <linux/pid_namespace.h>\n#include <linux/types.h>\n#include <linux/statfs.h>\n#include <linux/slab.h>\n#include <linux/mount.h>\n#include <linux/module.h>\n#include <linux/list.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/dcache.h>\n#include <linux/ctype.h>\n\nstatic ssize_t hppfs_read(struct file *file, char __user *buf, size_t count,\n\t\t\t  loff_t *ppos)\n{\n\tstruct hppfs_private *hppfs = file->private_data;\n\tstruct hppfs_data *data;\n\tloff_t off;\n\tint err;\n\n\tif (hppfs->contents != NULL) {\n\t\tint rem;\n\n\t\tif (*ppos >= hppfs->len)\n\t\t\treturn 0;\n\n\t\tdata = hppfs->contents;\n\t\toff = *ppos;\n\t\twhile (off >= sizeof(data->contents)) {\n\t\t\tdata = list_entry(data->list.next, struct hppfs_data,\n\t\t\t\t\t  list);\n\t\t\toff -= sizeof(data->contents);\n\t\t}\n\n\t\tif (off + count > hppfs->len)\n\t\t\tcount = hppfs->len - off;\n\t\trem = copy_to_user(buf, &data->contents[off], count);\n\t\t*ppos += count - rem;\n\t\tif (rem > 0)\n\t\t\treturn -EFAULT;\n\t} else if (hppfs->host_fd != -1) {\n\t\terr = os_seek_file(hppfs->host_fd, *ppos);\n\t\tif (err) {\n\t\t\tprintk(KERN_ERR \"hppfs_read : seek failed, \"\n\t\t\t       \"errno = %d\\n\", err);\n\t\t\treturn err;\n\t\t}\n\t\terr = hppfs_read_file(hppfs->host_fd, buf, count);\n\t\tif (err < 0) {\n\t\t\tprintk(KERN_ERR \"hppfs_read: read failed: %d\\n\", err);\n\t\t\treturn err;\n\t\t}\n\t\tcount = err;\n\t\tif (count > 0)\n\t\t\t*ppos += count;\n\t}\n\telse count = read_proc(hppfs->proc_file, buf, count, ppos, 1);\n\n\treturn count;\n}"
  },
  {
    "function_name": "hppfs_read_file",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hppfs/hppfs.c",
    "lines": "199-234",
    "snippet": "static ssize_t hppfs_read_file(int fd, char __user *buf, ssize_t count)\n{\n\tssize_t n;\n\tint cur, err;\n\tchar *new_buf;\n\n\tn = -ENOMEM;\n\tnew_buf = kmalloc(PAGE_SIZE, GFP_KERNEL);\n\tif (new_buf == NULL) {\n\t\tprintk(KERN_ERR \"hppfs_read_file : kmalloc failed\\n\");\n\t\tgoto out;\n\t}\n\tn = 0;\n\twhile (count > 0) {\n\t\tcur = min_t(ssize_t, count, PAGE_SIZE);\n\t\terr = os_read_file(fd, new_buf, cur);\n\t\tif (err < 0) {\n\t\t\tprintk(KERN_ERR \"hppfs_read : read failed, \"\n\t\t\t       \"errno = %d\\n\", err);\n\t\t\tn = err;\n\t\t\tgoto out_free;\n\t\t} else if (err == 0)\n\t\t\tbreak;\n\n\t\tif (copy_to_user(buf, new_buf, err)) {\n\t\t\tn = -EFAULT;\n\t\t\tgoto out_free;\n\t\t}\n\t\tn += err;\n\t\tcount -= err;\n\t}\n out_free:\n\tkfree(new_buf);\n out:\n\treturn n;\n}",
    "includes": [
      "#include <os.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/namei.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/types.h>",
      "#include <linux/statfs.h>",
      "#include <linux/slab.h>",
      "#include <linux/mount.h>",
      "#include <linux/module.h>",
      "#include <linux/list.h>",
      "#include <linux/kernel.h>",
      "#include <linux/init.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/dcache.h>",
      "#include <linux/ctype.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "new_buf"
          ],
          "line": 231
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "copy_to_user",
          "args": [
            "buf",
            "new_buf",
            "err"
          ],
          "line": 223
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_ERR \"hppfs_read : read failed, \"\n\t\t\t       \"errno = %d\\n\"",
            "err"
          ],
          "line": 216
        },
        "resolved": true,
        "details": {
          "function_name": "compat_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/compat.c",
          "lines": "59-69",
          "snippet": "int compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/ioctls.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/aio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/mm.h>",
            "#include <linux/poll.h>",
            "#include <linux/signal.h>",
            "#include <linux/highmem.h>",
            "#include <linux/security.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/personality.h>",
            "#include <linux/highuid.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/dirent.h>",
            "#include <linux/ctype.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/nfs4_mount.h>",
            "#include <linux/ncp_mount.h>",
            "#include <linux/init.h>",
            "#include <linux/ioctl.h>",
            "#include <linux/vfs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/namei.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/errno.h>",
            "#include <linux/compat.h>",
            "#include <linux/linkage.h>",
            "#include <linux/kernel.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int compat_log = 1;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/ioctls.h>\n#include <asm/mmu_context.h>\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/fs_struct.h>\n#include <linux/mm.h>\n#include <linux/poll.h>\n#include <linux/signal.h>\n#include <linux/highmem.h>\n#include <linux/security.h>\n#include <linux/tsacct_kern.h>\n#include <linux/rwsem.h>\n#include <linux/personality.h>\n#include <linux/highuid.h>\n#include <linux/fsnotify.h>\n#include <linux/dirent.h>\n#include <linux/ctype.h>\n#include <linux/syscalls.h>\n#include <linux/nfs4_mount.h>\n#include <linux/ncp_mount.h>\n#include <linux/init.h>\n#include <linux/ioctl.h>\n#include <linux/vfs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/namei.h>\n#include <linux/fcntl.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <linux/compat.h>\n#include <linux/linkage.h>\n#include <linux/kernel.h>\n#include <linux/stddef.h>\n\nint compat_log = 1;\n\nint compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "os_read_file",
          "args": [
            "fd",
            "new_buf",
            "cur"
          ],
          "line": 214
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "min_t",
          "args": [
            "ssize_t",
            "count",
            "PAGE_SIZE"
          ],
          "line": 213
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "PAGE_SIZE",
            "GFP_KERNEL"
          ],
          "line": 206
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dx_dir_kmalloc_leaves",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "2534-2546",
          "snippet": "static struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <os.h>\n#include <asm/uaccess.h>\n#include <linux/namei.h>\n#include <linux/pid_namespace.h>\n#include <linux/types.h>\n#include <linux/statfs.h>\n#include <linux/slab.h>\n#include <linux/mount.h>\n#include <linux/module.h>\n#include <linux/list.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/dcache.h>\n#include <linux/ctype.h>\n\nstatic ssize_t hppfs_read_file(int fd, char __user *buf, ssize_t count)\n{\n\tssize_t n;\n\tint cur, err;\n\tchar *new_buf;\n\n\tn = -ENOMEM;\n\tnew_buf = kmalloc(PAGE_SIZE, GFP_KERNEL);\n\tif (new_buf == NULL) {\n\t\tprintk(KERN_ERR \"hppfs_read_file : kmalloc failed\\n\");\n\t\tgoto out;\n\t}\n\tn = 0;\n\twhile (count > 0) {\n\t\tcur = min_t(ssize_t, count, PAGE_SIZE);\n\t\terr = os_read_file(fd, new_buf, cur);\n\t\tif (err < 0) {\n\t\t\tprintk(KERN_ERR \"hppfs_read : read failed, \"\n\t\t\t       \"errno = %d\\n\", err);\n\t\t\tn = err;\n\t\t\tgoto out_free;\n\t\t} else if (err == 0)\n\t\t\tbreak;\n\n\t\tif (copy_to_user(buf, new_buf, err)) {\n\t\t\tn = -EFAULT;\n\t\t\tgoto out_free;\n\t\t}\n\t\tn += err;\n\t\tcount -= err;\n\t}\n out_free:\n\tkfree(new_buf);\n out:\n\treturn n;\n}"
  },
  {
    "function_name": "read_proc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hppfs/hppfs.c",
    "lines": "178-197",
    "snippet": "static ssize_t read_proc(struct file *file, char __user *buf, ssize_t count,\n\t\t\t loff_t *ppos, int is_user)\n{\n\tssize_t (*read)(struct file *, char __user *, size_t, loff_t *);\n\tssize_t n;\n\n\tread = file_inode(file)->i_fop->read;\n\n\tif (!is_user)\n\t\tset_fs(KERNEL_DS);\n\n\tn = (*read)(file, buf, count, &file->f_pos);\n\n\tif (!is_user)\n\t\tset_fs(USER_DS);\n\n\tif (ppos)\n\t\t*ppos = file->f_pos;\n\treturn n;\n}",
    "includes": [
      "#include <os.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/namei.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/types.h>",
      "#include <linux/statfs.h>",
      "#include <linux/slab.h>",
      "#include <linux/mount.h>",
      "#include <linux/module.h>",
      "#include <linux/list.h>",
      "#include <linux/kernel.h>",
      "#include <linux/init.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/dcache.h>",
      "#include <linux/ctype.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "set_fs",
          "args": [
            "USER_DS"
          ],
          "line": 192
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "file",
            "buf",
            "count",
            "&file->f_pos"
          ],
          "line": 189
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_fs",
          "args": [
            "KERNEL_DS"
          ],
          "line": 187
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "file_inode",
          "args": [
            "file"
          ],
          "line": 184
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_init_file_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/file.c",
          "lines": "3009-3013",
          "snippet": "void fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}",
          "includes": [
            "#include <linux/falloc.h>",
            "#include <linux/aio.h>",
            "#include <linux/swap.h>",
            "#include <linux/compat.h>",
            "#include <linux/module.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};",
            "static const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/compat.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};\nstatic const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};\n\nvoid fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <os.h>\n#include <asm/uaccess.h>\n#include <linux/namei.h>\n#include <linux/pid_namespace.h>\n#include <linux/types.h>\n#include <linux/statfs.h>\n#include <linux/slab.h>\n#include <linux/mount.h>\n#include <linux/module.h>\n#include <linux/list.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/dcache.h>\n#include <linux/ctype.h>\n\nstatic ssize_t read_proc(struct file *file, char __user *buf, ssize_t count,\n\t\t\t loff_t *ppos, int is_user)\n{\n\tssize_t (*read)(struct file *, char __user *, size_t, loff_t *);\n\tssize_t n;\n\n\tread = file_inode(file)->i_fop->read;\n\n\tif (!is_user)\n\t\tset_fs(KERNEL_DS);\n\n\tn = (*read)(file, buf, count, &file->f_pos);\n\n\tif (!is_user)\n\t\tset_fs(USER_DS);\n\n\tif (ppos)\n\t\t*ppos = file->f_pos;\n\treturn n;\n}"
  },
  {
    "function_name": "hppfs_lookup",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hppfs/hppfs.c",
    "lines": "141-173",
    "snippet": "static struct dentry *hppfs_lookup(struct inode *ino, struct dentry *dentry,\n\t\t\t\t   unsigned int flags)\n{\n\tstruct dentry *proc_dentry, *parent;\n\tstruct qstr *name = &dentry->d_name;\n\tstruct inode *inode;\n\tint err, deleted;\n\n\tdeleted = file_removed(dentry, NULL);\n\tif (deleted < 0)\n\t\treturn ERR_PTR(deleted);\n\telse if (deleted)\n\t\treturn ERR_PTR(-ENOENT);\n\n\tparent = HPPFS_I(ino)->proc_dentry;\n\tmutex_lock(&parent->d_inode->i_mutex);\n\tproc_dentry = lookup_one_len(name->name, parent, name->len);\n\tmutex_unlock(&parent->d_inode->i_mutex);\n\n\tif (IS_ERR(proc_dentry))\n\t\treturn proc_dentry;\n\n\terr = -ENOMEM;\n\tinode = get_inode(ino->i_sb, proc_dentry);\n\tif (!inode)\n\t\tgoto out;\n\n \td_add(dentry, inode);\n\treturn NULL;\n\n out:\n\treturn ERR_PTR(err);\n}",
    "includes": [
      "#include <os.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/namei.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/types.h>",
      "#include <linux/statfs.h>",
      "#include <linux/slab.h>",
      "#include <linux/mount.h>",
      "#include <linux/module.h>",
      "#include <linux/list.h>",
      "#include <linux/kernel.h>",
      "#include <linux/init.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/dcache.h>",
      "#include <linux/ctype.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct inode *get_inode(struct super_block *, struct dentry *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "err"
          ],
          "line": 172
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "d_add",
          "args": [
            "dentry",
            "inode"
          ],
          "line": 168
        },
        "resolved": true,
        "details": {
          "function_name": "v9fs_fid_add",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/9p/fid.c",
          "lines": "49-54",
          "snippet": "void v9fs_fid_add(struct dentry *dentry, struct p9_fid *fid)\n{\n\tspin_lock(&dentry->d_lock);\n\t__add_fid(dentry, fid);\n\tspin_unlock(&dentry->d_lock);\n}",
          "includes": [
            "#include \"fid.h\"",
            "#include \"v9fs_vfs.h\"",
            "#include \"v9fs.h\"",
            "#include <net/9p/client.h>",
            "#include <net/9p/9p.h>",
            "#include <linux/idr.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/errno.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fid.h\"\n#include \"v9fs_vfs.h\"\n#include \"v9fs.h\"\n#include <net/9p/client.h>\n#include <net/9p/9p.h>\n#include <linux/idr.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <linux/module.h>\n\nvoid v9fs_fid_add(struct dentry *dentry, struct p9_fid *fid)\n{\n\tspin_lock(&dentry->d_lock);\n\t__add_fid(dentry, fid);\n\tspin_unlock(&dentry->d_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_inode",
          "args": [
            "ino->i_sb",
            "proc_dentry"
          ],
          "line": 164
        },
        "resolved": true,
        "details": {
          "function_name": "get_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hppfs/hppfs.c",
          "lines": "671-706",
          "snippet": "static struct inode *get_inode(struct super_block *sb, struct dentry *dentry)\n{\n\tstruct inode *proc_ino = dentry->d_inode;\n\tstruct inode *inode = new_inode(sb);\n\n\tif (!inode) {\n\t\tdput(dentry);\n\t\treturn NULL;\n\t}\n\n\tif (d_is_dir(dentry)) {\n\t\tinode->i_op = &hppfs_dir_iops;\n\t\tinode->i_fop = &hppfs_dir_fops;\n\t} else if (d_is_symlink(dentry)) {\n\t\tinode->i_op = &hppfs_link_iops;\n\t\tinode->i_fop = &hppfs_file_fops;\n\t} else {\n\t\tinode->i_op = &hppfs_file_iops;\n\t\tinode->i_fop = &hppfs_file_fops;\n\t}\n\n\tHPPFS_I(inode)->proc_dentry = dentry;\n\n\tinode->i_uid = proc_ino->i_uid;\n\tinode->i_gid = proc_ino->i_gid;\n\tinode->i_atime = proc_ino->i_atime;\n\tinode->i_mtime = proc_ino->i_mtime;\n\tinode->i_ctime = proc_ino->i_ctime;\n\tinode->i_ino = proc_ino->i_ino;\n\tinode->i_mode = proc_ino->i_mode;\n\tset_nlink(inode, proc_ino->i_nlink);\n\tinode->i_size = proc_ino->i_size;\n\tinode->i_blocks = proc_ino->i_blocks;\n\n\treturn inode;\n}",
          "includes": [
            "#include <os.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/namei.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/types.h>",
            "#include <linux/statfs.h>",
            "#include <linux/slab.h>",
            "#include <linux/mount.h>",
            "#include <linux/module.h>",
            "#include <linux/list.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/dcache.h>",
            "#include <linux/ctype.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct inode *get_inode(struct super_block *, struct dentry *);",
            "static const struct inode_operations hppfs_file_iops = {\n};",
            "static const struct file_operations hppfs_file_fops = {\n\t.owner\t\t= NULL,\n\t.llseek\t\t= hppfs_llseek,\n\t.read\t\t= hppfs_read,\n\t.write\t\t= hppfs_write,\n\t.open\t\t= hppfs_open,\n\t.release\t= hppfs_release,\n};",
            "static const struct file_operations hppfs_dir_fops = {\n\t.owner\t\t= NULL,\n\t.iterate\t= hppfs_readdir,\n\t.open\t\t= hppfs_dir_open,\n\t.llseek\t\t= default_llseek,\n\t.release\t= hppfs_release,\n};",
            "static const struct inode_operations hppfs_dir_iops = {\n\t.lookup\t\t= hppfs_lookup,\n};",
            "static const struct inode_operations hppfs_link_iops = {\n\t.readlink\t= hppfs_readlink,\n\t.follow_link\t= hppfs_follow_link,\n\t.put_link\t= hppfs_put_link,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <os.h>\n#include <asm/uaccess.h>\n#include <linux/namei.h>\n#include <linux/pid_namespace.h>\n#include <linux/types.h>\n#include <linux/statfs.h>\n#include <linux/slab.h>\n#include <linux/mount.h>\n#include <linux/module.h>\n#include <linux/list.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/dcache.h>\n#include <linux/ctype.h>\n\nstatic struct inode *get_inode(struct super_block *, struct dentry *);\nstatic const struct inode_operations hppfs_file_iops = {\n};\nstatic const struct file_operations hppfs_file_fops = {\n\t.owner\t\t= NULL,\n\t.llseek\t\t= hppfs_llseek,\n\t.read\t\t= hppfs_read,\n\t.write\t\t= hppfs_write,\n\t.open\t\t= hppfs_open,\n\t.release\t= hppfs_release,\n};\nstatic const struct file_operations hppfs_dir_fops = {\n\t.owner\t\t= NULL,\n\t.iterate\t= hppfs_readdir,\n\t.open\t\t= hppfs_dir_open,\n\t.llseek\t\t= default_llseek,\n\t.release\t= hppfs_release,\n};\nstatic const struct inode_operations hppfs_dir_iops = {\n\t.lookup\t\t= hppfs_lookup,\n};\nstatic const struct inode_operations hppfs_link_iops = {\n\t.readlink\t= hppfs_readlink,\n\t.follow_link\t= hppfs_follow_link,\n\t.put_link\t= hppfs_put_link,\n};\n\nstatic struct inode *get_inode(struct super_block *sb, struct dentry *dentry)\n{\n\tstruct inode *proc_ino = dentry->d_inode;\n\tstruct inode *inode = new_inode(sb);\n\n\tif (!inode) {\n\t\tdput(dentry);\n\t\treturn NULL;\n\t}\n\n\tif (d_is_dir(dentry)) {\n\t\tinode->i_op = &hppfs_dir_iops;\n\t\tinode->i_fop = &hppfs_dir_fops;\n\t} else if (d_is_symlink(dentry)) {\n\t\tinode->i_op = &hppfs_link_iops;\n\t\tinode->i_fop = &hppfs_file_fops;\n\t} else {\n\t\tinode->i_op = &hppfs_file_iops;\n\t\tinode->i_fop = &hppfs_file_fops;\n\t}\n\n\tHPPFS_I(inode)->proc_dentry = dentry;\n\n\tinode->i_uid = proc_ino->i_uid;\n\tinode->i_gid = proc_ino->i_gid;\n\tinode->i_atime = proc_ino->i_atime;\n\tinode->i_mtime = proc_ino->i_mtime;\n\tinode->i_ctime = proc_ino->i_ctime;\n\tinode->i_ino = proc_ino->i_ino;\n\tinode->i_mode = proc_ino->i_mode;\n\tset_nlink(inode, proc_ino->i_nlink);\n\tinode->i_size = proc_ino->i_size;\n\tinode->i_blocks = proc_ino->i_blocks;\n\n\treturn inode;\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "proc_dentry"
          ],
          "line": 160
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&parent->d_inode->i_mutex"
          ],
          "line": 158
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lookup_one_len",
          "args": [
            "name->name",
            "parent",
            "name->len"
          ],
          "line": 157
        },
        "resolved": true,
        "details": {
          "function_name": "lookup_one_len",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namei.c",
          "lines": "2145-2184",
          "snippet": "struct dentry *lookup_one_len(const char *name, struct dentry *base, int len)\n{\n\tstruct qstr this;\n\tunsigned int c;\n\tint err;\n\n\tWARN_ON_ONCE(!mutex_is_locked(&base->d_inode->i_mutex));\n\n\tthis.name = name;\n\tthis.len = len;\n\tthis.hash = full_name_hash(name, len);\n\tif (!len)\n\t\treturn ERR_PTR(-EACCES);\n\n\tif (unlikely(name[0] == '.')) {\n\t\tif (len < 2 || (len == 2 && name[1] == '.'))\n\t\t\treturn ERR_PTR(-EACCES);\n\t}\n\n\twhile (len--) {\n\t\tc = *(const unsigned char *)name++;\n\t\tif (c == '/' || c == '\\0')\n\t\t\treturn ERR_PTR(-EACCES);\n\t}\n\t/*\n\t * See if the low-level filesystem might want\n\t * to use its own hash..\n\t */\n\tif (base->d_flags & DCACHE_OP_HASH) {\n\t\tint err = base->d_op->d_hash(base, &this);\n\t\tif (err < 0)\n\t\t\treturn ERR_PTR(err);\n\t}\n\n\terr = inode_permission(base->d_inode, MAY_EXEC);\n\tif (err)\n\t\treturn ERR_PTR(err);\n\n\treturn __lookup_hash(&this, base, 0);\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/hash.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/device_cgroup.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>",
            "#include <linux/audit.h>",
            "#include <linux/mount.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/ima.h>",
            "#include <linux/security.h>",
            "#include <linux/personality.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/hash.h>\n#include <linux/posix_acl.h>\n#include <linux/fs_struct.h>\n#include <linux/device_cgroup.h>\n#include <linux/fcntl.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n#include <linux/audit.h>\n#include <linux/mount.h>\n#include <linux/syscalls.h>\n#include <linux/ima.h>\n#include <linux/security.h>\n#include <linux/personality.h>\n#include <linux/fsnotify.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n#include <linux/init.h>\n\nstruct dentry *lookup_one_len(const char *name, struct dentry *base, int len)\n{\n\tstruct qstr this;\n\tunsigned int c;\n\tint err;\n\n\tWARN_ON_ONCE(!mutex_is_locked(&base->d_inode->i_mutex));\n\n\tthis.name = name;\n\tthis.len = len;\n\tthis.hash = full_name_hash(name, len);\n\tif (!len)\n\t\treturn ERR_PTR(-EACCES);\n\n\tif (unlikely(name[0] == '.')) {\n\t\tif (len < 2 || (len == 2 && name[1] == '.'))\n\t\t\treturn ERR_PTR(-EACCES);\n\t}\n\n\twhile (len--) {\n\t\tc = *(const unsigned char *)name++;\n\t\tif (c == '/' || c == '\\0')\n\t\t\treturn ERR_PTR(-EACCES);\n\t}\n\t/*\n\t * See if the low-level filesystem might want\n\t * to use its own hash..\n\t */\n\tif (base->d_flags & DCACHE_OP_HASH) {\n\t\tint err = base->d_op->d_hash(base, &this);\n\t\tif (err < 0)\n\t\t\treturn ERR_PTR(err);\n\t}\n\n\terr = inode_permission(base->d_inode, MAY_EXEC);\n\tif (err)\n\t\treturn ERR_PTR(err);\n\n\treturn __lookup_hash(&this, base, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&parent->d_inode->i_mutex"
          ],
          "line": 156
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HPPFS_I",
          "args": [
            "ino"
          ],
          "line": 155
        },
        "resolved": true,
        "details": {
          "function_name": "HPPFS_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hppfs/hppfs.c",
          "lines": "42-45",
          "snippet": "static inline struct hppfs_inode_info *HPPFS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct hppfs_inode_info, vfs_inode);\n}",
          "includes": [
            "#include <os.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/namei.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/types.h>",
            "#include <linux/statfs.h>",
            "#include <linux/slab.h>",
            "#include <linux/mount.h>",
            "#include <linux/module.h>",
            "#include <linux/list.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/dcache.h>",
            "#include <linux/ctype.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <os.h>\n#include <asm/uaccess.h>\n#include <linux/namei.h>\n#include <linux/pid_namespace.h>\n#include <linux/types.h>\n#include <linux/statfs.h>\n#include <linux/slab.h>\n#include <linux/mount.h>\n#include <linux/module.h>\n#include <linux/list.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/dcache.h>\n#include <linux/ctype.h>\n\nstatic inline struct hppfs_inode_info *HPPFS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct hppfs_inode_info, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ENOENT"
          ],
          "line": 153
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "deleted"
          ],
          "line": 151
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "file_removed",
          "args": [
            "dentry",
            "NULL"
          ],
          "line": 149
        },
        "resolved": true,
        "details": {
          "function_name": "file_removed",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hppfs/hppfs.c",
          "lines": "111-139",
          "snippet": "static int file_removed(struct dentry *dentry, const char *file)\n{\n\tchar *host_file;\n\tint extra, fd;\n\n\textra = 0;\n\tif (file != NULL)\n\t\textra += strlen(file) + 1;\n\n\thost_file = dentry_name(dentry, extra + strlen(\"/remove\"));\n\tif (host_file == NULL) {\n\t\tprintk(KERN_ERR \"file_removed : allocation failed\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tif (file != NULL) {\n\t\tstrcat(host_file, \"/\");\n\t\tstrcat(host_file, file);\n\t}\n\tstrcat(host_file, \"/remove\");\n\n\tfd = os_open_file(host_file, of_read(OPENFLAGS()), 0);\n\tkfree(host_file);\n\tif (fd > 0) {\n\t\tos_close_file(fd);\n\t\treturn 1;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include <os.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/namei.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/types.h>",
            "#include <linux/statfs.h>",
            "#include <linux/slab.h>",
            "#include <linux/mount.h>",
            "#include <linux/module.h>",
            "#include <linux/list.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/dcache.h>",
            "#include <linux/ctype.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct inode *get_inode(struct super_block *, struct dentry *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <os.h>\n#include <asm/uaccess.h>\n#include <linux/namei.h>\n#include <linux/pid_namespace.h>\n#include <linux/types.h>\n#include <linux/statfs.h>\n#include <linux/slab.h>\n#include <linux/mount.h>\n#include <linux/module.h>\n#include <linux/list.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/dcache.h>\n#include <linux/ctype.h>\n\nstatic struct inode *get_inode(struct super_block *, struct dentry *);\n\nstatic int file_removed(struct dentry *dentry, const char *file)\n{\n\tchar *host_file;\n\tint extra, fd;\n\n\textra = 0;\n\tif (file != NULL)\n\t\textra += strlen(file) + 1;\n\n\thost_file = dentry_name(dentry, extra + strlen(\"/remove\"));\n\tif (host_file == NULL) {\n\t\tprintk(KERN_ERR \"file_removed : allocation failed\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tif (file != NULL) {\n\t\tstrcat(host_file, \"/\");\n\t\tstrcat(host_file, file);\n\t}\n\tstrcat(host_file, \"/remove\");\n\n\tfd = os_open_file(host_file, of_read(OPENFLAGS()), 0);\n\tkfree(host_file);\n\tif (fd > 0) {\n\t\tos_close_file(fd);\n\t\treturn 1;\n\t}\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <os.h>\n#include <asm/uaccess.h>\n#include <linux/namei.h>\n#include <linux/pid_namespace.h>\n#include <linux/types.h>\n#include <linux/statfs.h>\n#include <linux/slab.h>\n#include <linux/mount.h>\n#include <linux/module.h>\n#include <linux/list.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/dcache.h>\n#include <linux/ctype.h>\n\nstatic struct inode *get_inode(struct super_block *, struct dentry *);\n\nstatic struct dentry *hppfs_lookup(struct inode *ino, struct dentry *dentry,\n\t\t\t\t   unsigned int flags)\n{\n\tstruct dentry *proc_dentry, *parent;\n\tstruct qstr *name = &dentry->d_name;\n\tstruct inode *inode;\n\tint err, deleted;\n\n\tdeleted = file_removed(dentry, NULL);\n\tif (deleted < 0)\n\t\treturn ERR_PTR(deleted);\n\telse if (deleted)\n\t\treturn ERR_PTR(-ENOENT);\n\n\tparent = HPPFS_I(ino)->proc_dentry;\n\tmutex_lock(&parent->d_inode->i_mutex);\n\tproc_dentry = lookup_one_len(name->name, parent, name->len);\n\tmutex_unlock(&parent->d_inode->i_mutex);\n\n\tif (IS_ERR(proc_dentry))\n\t\treturn proc_dentry;\n\n\terr = -ENOMEM;\n\tinode = get_inode(ino->i_sb, proc_dentry);\n\tif (!inode)\n\t\tgoto out;\n\n \td_add(dentry, inode);\n\treturn NULL;\n\n out:\n\treturn ERR_PTR(err);\n}"
  },
  {
    "function_name": "file_removed",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hppfs/hppfs.c",
    "lines": "111-139",
    "snippet": "static int file_removed(struct dentry *dentry, const char *file)\n{\n\tchar *host_file;\n\tint extra, fd;\n\n\textra = 0;\n\tif (file != NULL)\n\t\textra += strlen(file) + 1;\n\n\thost_file = dentry_name(dentry, extra + strlen(\"/remove\"));\n\tif (host_file == NULL) {\n\t\tprintk(KERN_ERR \"file_removed : allocation failed\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tif (file != NULL) {\n\t\tstrcat(host_file, \"/\");\n\t\tstrcat(host_file, file);\n\t}\n\tstrcat(host_file, \"/remove\");\n\n\tfd = os_open_file(host_file, of_read(OPENFLAGS()), 0);\n\tkfree(host_file);\n\tif (fd > 0) {\n\t\tos_close_file(fd);\n\t\treturn 1;\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include <os.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/namei.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/types.h>",
      "#include <linux/statfs.h>",
      "#include <linux/slab.h>",
      "#include <linux/mount.h>",
      "#include <linux/module.h>",
      "#include <linux/list.h>",
      "#include <linux/kernel.h>",
      "#include <linux/init.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/dcache.h>",
      "#include <linux/ctype.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct inode *get_inode(struct super_block *, struct dentry *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "os_close_file",
          "args": [
            "fd"
          ],
          "line": 135
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "host_file"
          ],
          "line": 133
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "os_open_file",
          "args": [
            "host_file",
            "of_read(OPENFLAGS())",
            "0"
          ],
          "line": 132
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "of_read",
          "args": [
            "OPENFLAGS()"
          ],
          "line": 132
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OPENFLAGS",
          "args": [],
          "line": 132
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcat",
          "args": [
            "host_file",
            "\"/remove\""
          ],
          "line": 130
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcat",
          "args": [
            "host_file",
            "file"
          ],
          "line": 128
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcat",
          "args": [
            "host_file",
            "\"/\""
          ],
          "line": 127
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_ERR \"file_removed : allocation failed\\n\""
          ],
          "line": 122
        },
        "resolved": true,
        "details": {
          "function_name": "compat_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/compat.c",
          "lines": "59-69",
          "snippet": "int compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/ioctls.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/aio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/mm.h>",
            "#include <linux/poll.h>",
            "#include <linux/signal.h>",
            "#include <linux/highmem.h>",
            "#include <linux/security.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/personality.h>",
            "#include <linux/highuid.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/dirent.h>",
            "#include <linux/ctype.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/nfs4_mount.h>",
            "#include <linux/ncp_mount.h>",
            "#include <linux/init.h>",
            "#include <linux/ioctl.h>",
            "#include <linux/vfs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/namei.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/errno.h>",
            "#include <linux/compat.h>",
            "#include <linux/linkage.h>",
            "#include <linux/kernel.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int compat_log = 1;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/ioctls.h>\n#include <asm/mmu_context.h>\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/fs_struct.h>\n#include <linux/mm.h>\n#include <linux/poll.h>\n#include <linux/signal.h>\n#include <linux/highmem.h>\n#include <linux/security.h>\n#include <linux/tsacct_kern.h>\n#include <linux/rwsem.h>\n#include <linux/personality.h>\n#include <linux/highuid.h>\n#include <linux/fsnotify.h>\n#include <linux/dirent.h>\n#include <linux/ctype.h>\n#include <linux/syscalls.h>\n#include <linux/nfs4_mount.h>\n#include <linux/ncp_mount.h>\n#include <linux/init.h>\n#include <linux/ioctl.h>\n#include <linux/vfs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/namei.h>\n#include <linux/fcntl.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <linux/compat.h>\n#include <linux/linkage.h>\n#include <linux/kernel.h>\n#include <linux/stddef.h>\n\nint compat_log = 1;\n\nint compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dentry_name",
          "args": [
            "dentry",
            "extra + strlen(\"/remove\")"
          ],
          "line": 120
        },
        "resolved": true,
        "details": {
          "function_name": "dentry_name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hppfs/hppfs.c",
          "lines": "67-109",
          "snippet": "static char *dentry_name(struct dentry *dentry, int extra)\n{\n\tstruct dentry *parent;\n\tchar *root, *name;\n\tconst char *seg_name;\n\tint len, seg_len, root_len;\n\n\tlen = 0;\n\tparent = dentry;\n\twhile (parent->d_parent != parent) {\n\t\tif (is_pid(parent))\n\t\t\tlen += strlen(\"pid\") + 1;\n\t\telse len += parent->d_name.len + 1;\n\t\tparent = parent->d_parent;\n\t}\n\n\troot = \"proc\";\n\troot_len = strlen(root);\n\tlen += root_len;\n\tname = kmalloc(len + extra + 1, GFP_KERNEL);\n\tif (name == NULL)\n\t\treturn NULL;\n\n\tname[len] = '\\0';\n\tparent = dentry;\n\twhile (parent->d_parent != parent) {\n\t\tif (is_pid(parent)) {\n\t\t\tseg_name = \"pid\";\n\t\t\tseg_len = strlen(seg_name);\n\t\t}\n\t\telse {\n\t\t\tseg_name = parent->d_name.name;\n\t\t\tseg_len = parent->d_name.len;\n\t\t}\n\n\t\tlen -= seg_len + 1;\n\t\tname[len] = '/';\n\t\tmemcpy(&name[len + 1], seg_name, seg_len);\n\t\tparent = parent->d_parent;\n\t}\n\tmemcpy(name, root, root_len);\n\treturn name;\n}",
          "includes": [
            "#include <os.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/namei.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/types.h>",
            "#include <linux/statfs.h>",
            "#include <linux/slab.h>",
            "#include <linux/mount.h>",
            "#include <linux/module.h>",
            "#include <linux/list.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/dcache.h>",
            "#include <linux/ctype.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct inode *get_inode(struct super_block *, struct dentry *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <os.h>\n#include <asm/uaccess.h>\n#include <linux/namei.h>\n#include <linux/pid_namespace.h>\n#include <linux/types.h>\n#include <linux/statfs.h>\n#include <linux/slab.h>\n#include <linux/mount.h>\n#include <linux/module.h>\n#include <linux/list.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/dcache.h>\n#include <linux/ctype.h>\n\nstatic struct inode *get_inode(struct super_block *, struct dentry *);\n\nstatic char *dentry_name(struct dentry *dentry, int extra)\n{\n\tstruct dentry *parent;\n\tchar *root, *name;\n\tconst char *seg_name;\n\tint len, seg_len, root_len;\n\n\tlen = 0;\n\tparent = dentry;\n\twhile (parent->d_parent != parent) {\n\t\tif (is_pid(parent))\n\t\t\tlen += strlen(\"pid\") + 1;\n\t\telse len += parent->d_name.len + 1;\n\t\tparent = parent->d_parent;\n\t}\n\n\troot = \"proc\";\n\troot_len = strlen(root);\n\tlen += root_len;\n\tname = kmalloc(len + extra + 1, GFP_KERNEL);\n\tif (name == NULL)\n\t\treturn NULL;\n\n\tname[len] = '\\0';\n\tparent = dentry;\n\twhile (parent->d_parent != parent) {\n\t\tif (is_pid(parent)) {\n\t\t\tseg_name = \"pid\";\n\t\t\tseg_len = strlen(seg_name);\n\t\t}\n\t\telse {\n\t\t\tseg_name = parent->d_name.name;\n\t\t\tseg_len = parent->d_name.len;\n\t\t}\n\n\t\tlen -= seg_len + 1;\n\t\tname[len] = '/';\n\t\tmemcpy(&name[len + 1], seg_name, seg_len);\n\t\tparent = parent->d_parent;\n\t}\n\tmemcpy(name, root, root_len);\n\treturn name;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "\"/remove\""
          ],
          "line": 120
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_ea_strlen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/xattr.c",
          "lines": "351-363",
          "snippet": "static inline unsigned int gfs2_ea_strlen(struct gfs2_ea_header *ea)\n{\n\tswitch (ea->ea_type) {\n\tcase GFS2_EATYPE_USR:\n\t\treturn 5 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SYS:\n\t\treturn 7 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SECURITY:\n\t\treturn 9 + ea->ea_name_len + 1;\n\tdefault:\n\t\treturn 0;\n\t}\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"inode.h\"",
            "#include \"glock.h\"",
            "#include \"xattr.h\"",
            "#include \"acl.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/xattr.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"trans.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/xattr.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstatic inline unsigned int gfs2_ea_strlen(struct gfs2_ea_header *ea)\n{\n\tswitch (ea->ea_type) {\n\tcase GFS2_EATYPE_USR:\n\t\treturn 5 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SYS:\n\t\treturn 7 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SECURITY:\n\t\treturn 9 + ea->ea_name_len + 1;\n\tdefault:\n\t\treturn 0;\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include <os.h>\n#include <asm/uaccess.h>\n#include <linux/namei.h>\n#include <linux/pid_namespace.h>\n#include <linux/types.h>\n#include <linux/statfs.h>\n#include <linux/slab.h>\n#include <linux/mount.h>\n#include <linux/module.h>\n#include <linux/list.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/dcache.h>\n#include <linux/ctype.h>\n\nstatic struct inode *get_inode(struct super_block *, struct dentry *);\n\nstatic int file_removed(struct dentry *dentry, const char *file)\n{\n\tchar *host_file;\n\tint extra, fd;\n\n\textra = 0;\n\tif (file != NULL)\n\t\textra += strlen(file) + 1;\n\n\thost_file = dentry_name(dentry, extra + strlen(\"/remove\"));\n\tif (host_file == NULL) {\n\t\tprintk(KERN_ERR \"file_removed : allocation failed\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tif (file != NULL) {\n\t\tstrcat(host_file, \"/\");\n\t\tstrcat(host_file, file);\n\t}\n\tstrcat(host_file, \"/remove\");\n\n\tfd = os_open_file(host_file, of_read(OPENFLAGS()), 0);\n\tkfree(host_file);\n\tif (fd > 0) {\n\t\tos_close_file(fd);\n\t\treturn 1;\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "dentry_name",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hppfs/hppfs.c",
    "lines": "67-109",
    "snippet": "static char *dentry_name(struct dentry *dentry, int extra)\n{\n\tstruct dentry *parent;\n\tchar *root, *name;\n\tconst char *seg_name;\n\tint len, seg_len, root_len;\n\n\tlen = 0;\n\tparent = dentry;\n\twhile (parent->d_parent != parent) {\n\t\tif (is_pid(parent))\n\t\t\tlen += strlen(\"pid\") + 1;\n\t\telse len += parent->d_name.len + 1;\n\t\tparent = parent->d_parent;\n\t}\n\n\troot = \"proc\";\n\troot_len = strlen(root);\n\tlen += root_len;\n\tname = kmalloc(len + extra + 1, GFP_KERNEL);\n\tif (name == NULL)\n\t\treturn NULL;\n\n\tname[len] = '\\0';\n\tparent = dentry;\n\twhile (parent->d_parent != parent) {\n\t\tif (is_pid(parent)) {\n\t\t\tseg_name = \"pid\";\n\t\t\tseg_len = strlen(seg_name);\n\t\t}\n\t\telse {\n\t\t\tseg_name = parent->d_name.name;\n\t\t\tseg_len = parent->d_name.len;\n\t\t}\n\n\t\tlen -= seg_len + 1;\n\t\tname[len] = '/';\n\t\tmemcpy(&name[len + 1], seg_name, seg_len);\n\t\tparent = parent->d_parent;\n\t}\n\tmemcpy(name, root, root_len);\n\treturn name;\n}",
    "includes": [
      "#include <os.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/namei.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/types.h>",
      "#include <linux/statfs.h>",
      "#include <linux/slab.h>",
      "#include <linux/mount.h>",
      "#include <linux/module.h>",
      "#include <linux/list.h>",
      "#include <linux/kernel.h>",
      "#include <linux/init.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/dcache.h>",
      "#include <linux/ctype.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct inode *get_inode(struct super_block *, struct dentry *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "name",
            "root",
            "root_len"
          ],
          "line": 107
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "&name[len + 1]",
            "seg_name",
            "seg_len"
          ],
          "line": 104
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "seg_name"
          ],
          "line": 95
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_ea_strlen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/xattr.c",
          "lines": "351-363",
          "snippet": "static inline unsigned int gfs2_ea_strlen(struct gfs2_ea_header *ea)\n{\n\tswitch (ea->ea_type) {\n\tcase GFS2_EATYPE_USR:\n\t\treturn 5 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SYS:\n\t\treturn 7 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SECURITY:\n\t\treturn 9 + ea->ea_name_len + 1;\n\tdefault:\n\t\treturn 0;\n\t}\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"inode.h\"",
            "#include \"glock.h\"",
            "#include \"xattr.h\"",
            "#include \"acl.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/xattr.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"trans.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/xattr.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstatic inline unsigned int gfs2_ea_strlen(struct gfs2_ea_header *ea)\n{\n\tswitch (ea->ea_type) {\n\tcase GFS2_EATYPE_USR:\n\t\treturn 5 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SYS:\n\t\treturn 7 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SECURITY:\n\t\treturn 9 + ea->ea_name_len + 1;\n\tdefault:\n\t\treturn 0;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_pid",
          "args": [
            "parent"
          ],
          "line": 93
        },
        "resolved": true,
        "details": {
          "function_name": "is_pid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hppfs/hppfs.c",
          "lines": "51-65",
          "snippet": "static int is_pid(struct dentry *dentry)\n{\n\tstruct super_block *sb;\n\tint i;\n\n\tsb = dentry->d_sb;\n\tif (dentry->d_parent != sb->s_root)\n\t\treturn 0;\n\n\tfor (i = 0; i < dentry->d_name.len; i++) {\n\t\tif (!isdigit(dentry->d_name.name[i]))\n\t\t\treturn 0;\n\t}\n\treturn 1;\n}",
          "includes": [
            "#include <os.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/namei.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/types.h>",
            "#include <linux/statfs.h>",
            "#include <linux/slab.h>",
            "#include <linux/mount.h>",
            "#include <linux/module.h>",
            "#include <linux/list.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/dcache.h>",
            "#include <linux/ctype.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct inode *get_inode(struct super_block *, struct dentry *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <os.h>\n#include <asm/uaccess.h>\n#include <linux/namei.h>\n#include <linux/pid_namespace.h>\n#include <linux/types.h>\n#include <linux/statfs.h>\n#include <linux/slab.h>\n#include <linux/mount.h>\n#include <linux/module.h>\n#include <linux/list.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/dcache.h>\n#include <linux/ctype.h>\n\nstatic struct inode *get_inode(struct super_block *, struct dentry *);\n\nstatic int is_pid(struct dentry *dentry)\n{\n\tstruct super_block *sb;\n\tint i;\n\n\tsb = dentry->d_sb;\n\tif (dentry->d_parent != sb->s_root)\n\t\treturn 0;\n\n\tfor (i = 0; i < dentry->d_name.len; i++) {\n\t\tif (!isdigit(dentry->d_name.name[i]))\n\t\t\treturn 0;\n\t}\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "len + extra + 1",
            "GFP_KERNEL"
          ],
          "line": 86
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dx_dir_kmalloc_leaves",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "2534-2546",
          "snippet": "static struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <os.h>\n#include <asm/uaccess.h>\n#include <linux/namei.h>\n#include <linux/pid_namespace.h>\n#include <linux/types.h>\n#include <linux/statfs.h>\n#include <linux/slab.h>\n#include <linux/mount.h>\n#include <linux/module.h>\n#include <linux/list.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/dcache.h>\n#include <linux/ctype.h>\n\nstatic struct inode *get_inode(struct super_block *, struct dentry *);\n\nstatic char *dentry_name(struct dentry *dentry, int extra)\n{\n\tstruct dentry *parent;\n\tchar *root, *name;\n\tconst char *seg_name;\n\tint len, seg_len, root_len;\n\n\tlen = 0;\n\tparent = dentry;\n\twhile (parent->d_parent != parent) {\n\t\tif (is_pid(parent))\n\t\t\tlen += strlen(\"pid\") + 1;\n\t\telse len += parent->d_name.len + 1;\n\t\tparent = parent->d_parent;\n\t}\n\n\troot = \"proc\";\n\troot_len = strlen(root);\n\tlen += root_len;\n\tname = kmalloc(len + extra + 1, GFP_KERNEL);\n\tif (name == NULL)\n\t\treturn NULL;\n\n\tname[len] = '\\0';\n\tparent = dentry;\n\twhile (parent->d_parent != parent) {\n\t\tif (is_pid(parent)) {\n\t\t\tseg_name = \"pid\";\n\t\t\tseg_len = strlen(seg_name);\n\t\t}\n\t\telse {\n\t\t\tseg_name = parent->d_name.name;\n\t\t\tseg_len = parent->d_name.len;\n\t\t}\n\n\t\tlen -= seg_len + 1;\n\t\tname[len] = '/';\n\t\tmemcpy(&name[len + 1], seg_name, seg_len);\n\t\tparent = parent->d_parent;\n\t}\n\tmemcpy(name, root, root_len);\n\treturn name;\n}"
  },
  {
    "function_name": "is_pid",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hppfs/hppfs.c",
    "lines": "51-65",
    "snippet": "static int is_pid(struct dentry *dentry)\n{\n\tstruct super_block *sb;\n\tint i;\n\n\tsb = dentry->d_sb;\n\tif (dentry->d_parent != sb->s_root)\n\t\treturn 0;\n\n\tfor (i = 0; i < dentry->d_name.len; i++) {\n\t\tif (!isdigit(dentry->d_name.name[i]))\n\t\t\treturn 0;\n\t}\n\treturn 1;\n}",
    "includes": [
      "#include <os.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/namei.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/types.h>",
      "#include <linux/statfs.h>",
      "#include <linux/slab.h>",
      "#include <linux/mount.h>",
      "#include <linux/module.h>",
      "#include <linux/list.h>",
      "#include <linux/kernel.h>",
      "#include <linux/init.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/dcache.h>",
      "#include <linux/ctype.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct inode *get_inode(struct super_block *, struct dentry *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "isdigit",
          "args": [
            "dentry->d_name.name[i]"
          ],
          "line": 61
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <os.h>\n#include <asm/uaccess.h>\n#include <linux/namei.h>\n#include <linux/pid_namespace.h>\n#include <linux/types.h>\n#include <linux/statfs.h>\n#include <linux/slab.h>\n#include <linux/mount.h>\n#include <linux/module.h>\n#include <linux/list.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/dcache.h>\n#include <linux/ctype.h>\n\nstatic struct inode *get_inode(struct super_block *, struct dentry *);\n\nstatic int is_pid(struct dentry *dentry)\n{\n\tstruct super_block *sb;\n\tint i;\n\n\tsb = dentry->d_sb;\n\tif (dentry->d_parent != sb->s_root)\n\t\treturn 0;\n\n\tfor (i = 0; i < dentry->d_name.len; i++) {\n\t\tif (!isdigit(dentry->d_name.name[i]))\n\t\t\treturn 0;\n\t}\n\treturn 1;\n}"
  },
  {
    "function_name": "HPPFS_I",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hppfs/hppfs.c",
    "lines": "42-45",
    "snippet": "static inline struct hppfs_inode_info *HPPFS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct hppfs_inode_info, vfs_inode);\n}",
    "includes": [
      "#include <os.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/namei.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/types.h>",
      "#include <linux/statfs.h>",
      "#include <linux/slab.h>",
      "#include <linux/mount.h>",
      "#include <linux/module.h>",
      "#include <linux/list.h>",
      "#include <linux/kernel.h>",
      "#include <linux/init.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/dcache.h>",
      "#include <linux/ctype.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "inode",
            "structhppfs_inode_info",
            "vfs_inode"
          ],
          "line": 44
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <os.h>\n#include <asm/uaccess.h>\n#include <linux/namei.h>\n#include <linux/pid_namespace.h>\n#include <linux/types.h>\n#include <linux/statfs.h>\n#include <linux/slab.h>\n#include <linux/mount.h>\n#include <linux/module.h>\n#include <linux/list.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/dcache.h>\n#include <linux/ctype.h>\n\nstatic inline struct hppfs_inode_info *HPPFS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct hppfs_inode_info, vfs_inode);\n}"
  }
]