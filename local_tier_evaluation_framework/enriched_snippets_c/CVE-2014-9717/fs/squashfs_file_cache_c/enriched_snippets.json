[
  {
    "function_name": "squashfs_readpage_block",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/squashfs/file_cache.c",
    "lines": "23-38",
    "snippet": "int squashfs_readpage_block(struct page *page, u64 block, int bsize)\n{\n\tstruct inode *i = page->mapping->host;\n\tstruct squashfs_cache_entry *buffer = squashfs_get_datablock(i->i_sb,\n\t\tblock, bsize);\n\tint res = buffer->error;\n\n\tif (res)\n\t\tERROR(\"Unable to read page, block %llx, size %x\\n\", block,\n\t\t\tbsize);\n\telse\n\t\tsquashfs_copy_cache(page, buffer, buffer->length, 0);\n\n\tsquashfs_cache_put(buffer);\n\treturn res;\n}",
    "includes": [
      "#include \"squashfs.h\"",
      "#include \"squashfs_fs_i.h\"",
      "#include \"squashfs_fs_sb.h\"",
      "#include \"squashfs_fs.h\"",
      "#include <linux/mutex.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/string.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>",
      "#include <linux/vfs.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "squashfs_cache_put",
          "args": [
            "buffer"
          ],
          "line": 36
        },
        "resolved": true,
        "details": {
          "function_name": "squashfs_cache_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/squashfs/cache.c",
          "lines": "186-205",
          "snippet": "void squashfs_cache_put(struct squashfs_cache_entry *entry)\n{\n\tstruct squashfs_cache *cache = entry->cache;\n\n\tspin_lock(&cache->lock);\n\tentry->refcount--;\n\tif (entry->refcount == 0) {\n\t\tcache->unused++;\n\t\t/*\n\t\t * If there's any processes waiting for a block to become\n\t\t * available, wake one up.\n\t\t */\n\t\tif (cache->num_waiters) {\n\t\t\tspin_unlock(&cache->lock);\n\t\t\twake_up(&cache->wait_queue);\n\t\t\treturn;\n\t\t}\n\t}\n\tspin_unlock(&cache->lock);\n}",
          "includes": [
            "#include \"page_actor.h\"",
            "#include \"squashfs.h\"",
            "#include \"squashfs_fs_sb.h\"",
            "#include \"squashfs_fs.h\"",
            "#include <linux/pagemap.h>",
            "#include <linux/wait.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/sched.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/vfs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"page_actor.h\"\n#include \"squashfs.h\"\n#include \"squashfs_fs_sb.h\"\n#include \"squashfs_fs.h\"\n#include <linux/pagemap.h>\n#include <linux/wait.h>\n#include <linux/spinlock.h>\n#include <linux/sched.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/vfs.h>\n#include <linux/fs.h>\n\nvoid squashfs_cache_put(struct squashfs_cache_entry *entry)\n{\n\tstruct squashfs_cache *cache = entry->cache;\n\n\tspin_lock(&cache->lock);\n\tentry->refcount--;\n\tif (entry->refcount == 0) {\n\t\tcache->unused++;\n\t\t/*\n\t\t * If there's any processes waiting for a block to become\n\t\t * available, wake one up.\n\t\t */\n\t\tif (cache->num_waiters) {\n\t\t\tspin_unlock(&cache->lock);\n\t\t\twake_up(&cache->wait_queue);\n\t\t\treturn;\n\t\t}\n\t}\n\tspin_unlock(&cache->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "squashfs_copy_cache",
          "args": [
            "page",
            "buffer",
            "buffer->length",
            "0"
          ],
          "line": 34
        },
        "resolved": true,
        "details": {
          "function_name": "squashfs_copy_cache",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/squashfs/file.c",
          "lines": "374-416",
          "snippet": "void squashfs_copy_cache(struct page *page, struct squashfs_cache_entry *buffer,\n\tint bytes, int offset)\n{\n\tstruct inode *inode = page->mapping->host;\n\tstruct squashfs_sb_info *msblk = inode->i_sb->s_fs_info;\n\tvoid *pageaddr;\n\tint i, mask = (1 << (msblk->block_log - PAGE_CACHE_SHIFT)) - 1;\n\tint start_index = page->index & ~mask, end_index = start_index | mask;\n\n\t/*\n\t * Loop copying datablock into pages.  As the datablock likely covers\n\t * many PAGE_CACHE_SIZE pages (default block size is 128 KiB) explicitly\n\t * grab the pages from the page cache, except for the page that we've\n\t * been called to fill.\n\t */\n\tfor (i = start_index; i <= end_index && bytes > 0; i++,\n\t\t\tbytes -= PAGE_CACHE_SIZE, offset += PAGE_CACHE_SIZE) {\n\t\tstruct page *push_page;\n\t\tint avail = buffer ? min_t(int, bytes, PAGE_CACHE_SIZE) : 0;\n\n\t\tTRACE(\"bytes %d, i %d, available_bytes %d\\n\", bytes, i, avail);\n\n\t\tpush_page = (i == page->index) ? page :\n\t\t\tgrab_cache_page_nowait(page->mapping, i);\n\n\t\tif (!push_page)\n\t\t\tcontinue;\n\n\t\tif (PageUptodate(push_page))\n\t\t\tgoto skip_page;\n\n\t\tpageaddr = kmap_atomic(push_page);\n\t\tsquashfs_copy_data(pageaddr, buffer, offset, avail);\n\t\tmemset(pageaddr + avail, 0, PAGE_CACHE_SIZE - avail);\n\t\tkunmap_atomic(pageaddr);\n\t\tflush_dcache_page(push_page);\n\t\tSetPageUptodate(push_page);\nskip_page:\n\t\tunlock_page(push_page);\n\t\tif (i != page->index)\n\t\t\tpage_cache_release(push_page);\n\t}\n}",
          "includes": [
            "#include \"squashfs.h\"",
            "#include \"squashfs_fs_i.h\"",
            "#include \"squashfs_fs_sb.h\"",
            "#include \"squashfs_fs.h\"",
            "#include <linux/mutex.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/vfs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"squashfs.h\"\n#include \"squashfs_fs_i.h\"\n#include \"squashfs_fs_sb.h\"\n#include \"squashfs_fs.h\"\n#include <linux/mutex.h>\n#include <linux/pagemap.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/vfs.h>\n#include <linux/fs.h>\n\nvoid squashfs_copy_cache(struct page *page, struct squashfs_cache_entry *buffer,\n\tint bytes, int offset)\n{\n\tstruct inode *inode = page->mapping->host;\n\tstruct squashfs_sb_info *msblk = inode->i_sb->s_fs_info;\n\tvoid *pageaddr;\n\tint i, mask = (1 << (msblk->block_log - PAGE_CACHE_SHIFT)) - 1;\n\tint start_index = page->index & ~mask, end_index = start_index | mask;\n\n\t/*\n\t * Loop copying datablock into pages.  As the datablock likely covers\n\t * many PAGE_CACHE_SIZE pages (default block size is 128 KiB) explicitly\n\t * grab the pages from the page cache, except for the page that we've\n\t * been called to fill.\n\t */\n\tfor (i = start_index; i <= end_index && bytes > 0; i++,\n\t\t\tbytes -= PAGE_CACHE_SIZE, offset += PAGE_CACHE_SIZE) {\n\t\tstruct page *push_page;\n\t\tint avail = buffer ? min_t(int, bytes, PAGE_CACHE_SIZE) : 0;\n\n\t\tTRACE(\"bytes %d, i %d, available_bytes %d\\n\", bytes, i, avail);\n\n\t\tpush_page = (i == page->index) ? page :\n\t\t\tgrab_cache_page_nowait(page->mapping, i);\n\n\t\tif (!push_page)\n\t\t\tcontinue;\n\n\t\tif (PageUptodate(push_page))\n\t\t\tgoto skip_page;\n\n\t\tpageaddr = kmap_atomic(push_page);\n\t\tsquashfs_copy_data(pageaddr, buffer, offset, avail);\n\t\tmemset(pageaddr + avail, 0, PAGE_CACHE_SIZE - avail);\n\t\tkunmap_atomic(pageaddr);\n\t\tflush_dcache_page(push_page);\n\t\tSetPageUptodate(push_page);\nskip_page:\n\t\tunlock_page(push_page);\n\t\tif (i != page->index)\n\t\t\tpage_cache_release(push_page);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"Unable to read page, block %llx, size %x\\n\"",
            "block",
            "bsize"
          ],
          "line": 31
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "squashfs_get_datablock",
          "args": [
            "i->i_sb",
            "block",
            "bsize"
          ],
          "line": 26
        },
        "resolved": true,
        "details": {
          "function_name": "squashfs_get_datablock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/squashfs/cache.c",
          "lines": "404-410",
          "snippet": "struct squashfs_cache_entry *squashfs_get_datablock(struct super_block *sb,\n\t\t\t\tu64 start_block, int length)\n{\n\tstruct squashfs_sb_info *msblk = sb->s_fs_info;\n\n\treturn squashfs_cache_get(sb, msblk->read_page, start_block, length);\n}",
          "includes": [
            "#include \"page_actor.h\"",
            "#include \"squashfs.h\"",
            "#include \"squashfs_fs_sb.h\"",
            "#include \"squashfs_fs.h\"",
            "#include <linux/pagemap.h>",
            "#include <linux/wait.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/sched.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/vfs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"page_actor.h\"\n#include \"squashfs.h\"\n#include \"squashfs_fs_sb.h\"\n#include \"squashfs_fs.h\"\n#include <linux/pagemap.h>\n#include <linux/wait.h>\n#include <linux/spinlock.h>\n#include <linux/sched.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/vfs.h>\n#include <linux/fs.h>\n\nstruct squashfs_cache_entry *squashfs_get_datablock(struct super_block *sb,\n\t\t\t\tu64 start_block, int length)\n{\n\tstruct squashfs_sb_info *msblk = sb->s_fs_info;\n\n\treturn squashfs_cache_get(sb, msblk->read_page, start_block, length);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"squashfs.h\"\n#include \"squashfs_fs_i.h\"\n#include \"squashfs_fs_sb.h\"\n#include \"squashfs_fs.h\"\n#include <linux/mutex.h>\n#include <linux/pagemap.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/vfs.h>\n#include <linux/fs.h>\n\nint squashfs_readpage_block(struct page *page, u64 block, int bsize)\n{\n\tstruct inode *i = page->mapping->host;\n\tstruct squashfs_cache_entry *buffer = squashfs_get_datablock(i->i_sb,\n\t\tblock, bsize);\n\tint res = buffer->error;\n\n\tif (res)\n\t\tERROR(\"Unable to read page, block %llx, size %x\\n\", block,\n\t\t\tbsize);\n\telse\n\t\tsquashfs_copy_cache(page, buffer, buffer->length, 0);\n\n\tsquashfs_cache_put(buffer);\n\treturn res;\n}"
  }
]