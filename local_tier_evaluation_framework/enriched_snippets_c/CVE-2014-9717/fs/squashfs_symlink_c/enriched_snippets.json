[
  {
    "function_name": "squashfs_symlink_readpage",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/squashfs/symlink.c",
    "lines": "46-113",
    "snippet": "static int squashfs_symlink_readpage(struct file *file, struct page *page)\n{\n\tstruct inode *inode = page->mapping->host;\n\tstruct super_block *sb = inode->i_sb;\n\tstruct squashfs_sb_info *msblk = sb->s_fs_info;\n\tint index = page->index << PAGE_CACHE_SHIFT;\n\tu64 block = squashfs_i(inode)->start;\n\tint offset = squashfs_i(inode)->offset;\n\tint length = min_t(int, i_size_read(inode) - index, PAGE_CACHE_SIZE);\n\tint bytes, copied;\n\tvoid *pageaddr;\n\tstruct squashfs_cache_entry *entry;\n\n\tTRACE(\"Entered squashfs_symlink_readpage, page index %ld, start block \"\n\t\t\t\"%llx, offset %x\\n\", page->index, block, offset);\n\n\t/*\n\t * Skip index bytes into symlink metadata.\n\t */\n\tif (index) {\n\t\tbytes = squashfs_read_metadata(sb, NULL, &block, &offset,\n\t\t\t\t\t\t\t\tindex);\n\t\tif (bytes < 0) {\n\t\t\tERROR(\"Unable to read symlink [%llx:%x]\\n\",\n\t\t\t\tsquashfs_i(inode)->start,\n\t\t\t\tsquashfs_i(inode)->offset);\n\t\t\tgoto error_out;\n\t\t}\n\t}\n\n\t/*\n\t * Read length bytes from symlink metadata.  Squashfs_read_metadata\n\t * is not used here because it can sleep and we want to use\n\t * kmap_atomic to map the page.  Instead call the underlying\n\t * squashfs_cache_get routine.  As length bytes may overlap metadata\n\t * blocks, we may need to call squashfs_cache_get multiple times.\n\t */\n\tfor (bytes = 0; bytes < length; offset = 0, bytes += copied) {\n\t\tentry = squashfs_cache_get(sb, msblk->block_cache, block, 0);\n\t\tif (entry->error) {\n\t\t\tERROR(\"Unable to read symlink [%llx:%x]\\n\",\n\t\t\t\tsquashfs_i(inode)->start,\n\t\t\t\tsquashfs_i(inode)->offset);\n\t\t\tsquashfs_cache_put(entry);\n\t\t\tgoto error_out;\n\t\t}\n\n\t\tpageaddr = kmap_atomic(page);\n\t\tcopied = squashfs_copy_data(pageaddr + bytes, entry, offset,\n\t\t\t\t\t\t\t\tlength - bytes);\n\t\tif (copied == length - bytes)\n\t\t\tmemset(pageaddr + length, 0, PAGE_CACHE_SIZE - length);\n\t\telse\n\t\t\tblock = entry->next_index;\n\t\tkunmap_atomic(pageaddr);\n\t\tsquashfs_cache_put(entry);\n\t}\n\n\tflush_dcache_page(page);\n\tSetPageUptodate(page);\n\tunlock_page(page);\n\treturn 0;\n\nerror_out:\n\tSetPageError(page);\n\tunlock_page(page);\n\treturn 0;\n}",
    "includes": [
      "#include \"xattr.h\"",
      "#include \"squashfs.h\"",
      "#include \"squashfs_fs_i.h\"",
      "#include \"squashfs_fs_sb.h\"",
      "#include \"squashfs_fs.h\"",
      "#include <linux/xattr.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/string.h>",
      "#include <linux/kernel.h>",
      "#include <linux/vfs.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "unlock_page",
          "args": [
            "page"
          ],
          "line": 111
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_unlock_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/aops.c",
          "lines": "1127-1148",
          "snippet": "static void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tpage_cache_release(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}",
          "includes": [
            "#include \"sysfile.h\"",
            "#include \"namei.h\"",
            "#include \"dir.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"symlink.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/swap.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfile.h\"\n#include \"namei.h\"\n#include \"dir.h\"\n#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"symlink.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/mpage.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/swap.h>\n#include <asm/byteorder.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tpage_cache_release(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}"
        }
      },
      {
        "call_info": {
          "callee": "SetPageError",
          "args": [
            "page"
          ],
          "line": 110
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SetPageUptodate",
          "args": [
            "page"
          ],
          "line": 105
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "flush_dcache_page",
          "args": [
            "page"
          ],
          "line": 104
        },
        "resolved": true,
        "details": {
          "function_name": "ntfs_index_entry_flush_dcache_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/index.h",
          "lines": "111-117",
          "snippet": "static inline void ntfs_index_entry_flush_dcache_page(ntfs_index_context *ictx)\n{\n\tif (ictx->is_in_root)\n\t\tflush_dcache_mft_record_page(ictx->actx->ntfs_ino);\n\telse\n\t\tflush_dcache_page(ictx->page);\n}",
          "includes": [
            "#include \"aops.h\"",
            "#include \"mft.h\"",
            "#include \"attrib.h\"",
            "#include \"inode.h\"",
            "#include \"layout.h\"",
            "#include \"types.h\"",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"aops.h\"\n#include \"mft.h\"\n#include \"attrib.h\"\n#include \"inode.h\"\n#include \"layout.h\"\n#include \"types.h\"\n#include <linux/fs.h>\n\nstatic inline void ntfs_index_entry_flush_dcache_page(ntfs_index_context *ictx)\n{\n\tif (ictx->is_in_root)\n\t\tflush_dcache_mft_record_page(ictx->actx->ntfs_ino);\n\telse\n\t\tflush_dcache_page(ictx->page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "squashfs_cache_put",
          "args": [
            "entry"
          ],
          "line": 101
        },
        "resolved": true,
        "details": {
          "function_name": "squashfs_cache_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/squashfs/cache.c",
          "lines": "186-205",
          "snippet": "void squashfs_cache_put(struct squashfs_cache_entry *entry)\n{\n\tstruct squashfs_cache *cache = entry->cache;\n\n\tspin_lock(&cache->lock);\n\tentry->refcount--;\n\tif (entry->refcount == 0) {\n\t\tcache->unused++;\n\t\t/*\n\t\t * If there's any processes waiting for a block to become\n\t\t * available, wake one up.\n\t\t */\n\t\tif (cache->num_waiters) {\n\t\t\tspin_unlock(&cache->lock);\n\t\t\twake_up(&cache->wait_queue);\n\t\t\treturn;\n\t\t}\n\t}\n\tspin_unlock(&cache->lock);\n}",
          "includes": [
            "#include \"page_actor.h\"",
            "#include \"squashfs.h\"",
            "#include \"squashfs_fs_sb.h\"",
            "#include \"squashfs_fs.h\"",
            "#include <linux/pagemap.h>",
            "#include <linux/wait.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/sched.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/vfs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"page_actor.h\"\n#include \"squashfs.h\"\n#include \"squashfs_fs_sb.h\"\n#include \"squashfs_fs.h\"\n#include <linux/pagemap.h>\n#include <linux/wait.h>\n#include <linux/spinlock.h>\n#include <linux/sched.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/vfs.h>\n#include <linux/fs.h>\n\nvoid squashfs_cache_put(struct squashfs_cache_entry *entry)\n{\n\tstruct squashfs_cache *cache = entry->cache;\n\n\tspin_lock(&cache->lock);\n\tentry->refcount--;\n\tif (entry->refcount == 0) {\n\t\tcache->unused++;\n\t\t/*\n\t\t * If there's any processes waiting for a block to become\n\t\t * available, wake one up.\n\t\t */\n\t\tif (cache->num_waiters) {\n\t\t\tspin_unlock(&cache->lock);\n\t\t\twake_up(&cache->wait_queue);\n\t\t\treturn;\n\t\t}\n\t}\n\tspin_unlock(&cache->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kunmap_atomic",
          "args": [
            "pageaddr"
          ],
          "line": 100
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "pageaddr + length",
            "0",
            "PAGE_CACHE_SIZE - length"
          ],
          "line": 97
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "squashfs_copy_data",
          "args": [
            "pageaddr + bytes",
            "entry",
            "offset",
            "length - bytes"
          ],
          "line": 94
        },
        "resolved": true,
        "details": {
          "function_name": "squashfs_copy_data",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/squashfs/cache.c",
          "lines": "306-335",
          "snippet": "int squashfs_copy_data(void *buffer, struct squashfs_cache_entry *entry,\n\t\tint offset, int length)\n{\n\tint remaining = length;\n\n\tif (length == 0)\n\t\treturn 0;\n\telse if (buffer == NULL)\n\t\treturn min(length, entry->length - offset);\n\n\twhile (offset < entry->length) {\n\t\tvoid *buff = entry->data[offset / PAGE_CACHE_SIZE]\n\t\t\t\t+ (offset % PAGE_CACHE_SIZE);\n\t\tint bytes = min_t(int, entry->length - offset,\n\t\t\t\tPAGE_CACHE_SIZE - (offset % PAGE_CACHE_SIZE));\n\n\t\tif (bytes >= remaining) {\n\t\t\tmemcpy(buffer, buff, remaining);\n\t\t\tremaining = 0;\n\t\t\tbreak;\n\t\t}\n\n\t\tmemcpy(buffer, buff, bytes);\n\t\tbuffer += bytes;\n\t\tremaining -= bytes;\n\t\toffset += bytes;\n\t}\n\n\treturn length - remaining;\n}",
          "includes": [
            "#include \"page_actor.h\"",
            "#include \"squashfs.h\"",
            "#include \"squashfs_fs_sb.h\"",
            "#include \"squashfs_fs.h\"",
            "#include <linux/pagemap.h>",
            "#include <linux/wait.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/sched.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/vfs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"page_actor.h\"\n#include \"squashfs.h\"\n#include \"squashfs_fs_sb.h\"\n#include \"squashfs_fs.h\"\n#include <linux/pagemap.h>\n#include <linux/wait.h>\n#include <linux/spinlock.h>\n#include <linux/sched.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/vfs.h>\n#include <linux/fs.h>\n\nint squashfs_copy_data(void *buffer, struct squashfs_cache_entry *entry,\n\t\tint offset, int length)\n{\n\tint remaining = length;\n\n\tif (length == 0)\n\t\treturn 0;\n\telse if (buffer == NULL)\n\t\treturn min(length, entry->length - offset);\n\n\twhile (offset < entry->length) {\n\t\tvoid *buff = entry->data[offset / PAGE_CACHE_SIZE]\n\t\t\t\t+ (offset % PAGE_CACHE_SIZE);\n\t\tint bytes = min_t(int, entry->length - offset,\n\t\t\t\tPAGE_CACHE_SIZE - (offset % PAGE_CACHE_SIZE));\n\n\t\tif (bytes >= remaining) {\n\t\t\tmemcpy(buffer, buff, remaining);\n\t\t\tremaining = 0;\n\t\t\tbreak;\n\t\t}\n\n\t\tmemcpy(buffer, buff, bytes);\n\t\tbuffer += bytes;\n\t\tremaining -= bytes;\n\t\toffset += bytes;\n\t}\n\n\treturn length - remaining;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kmap_atomic",
          "args": [
            "page"
          ],
          "line": 93
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"Unable to read symlink [%llx:%x]\\n\"",
            "squashfs_i(inode)->start",
            "squashfs_i(inode)->offset"
          ],
          "line": 86
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "squashfs_i",
          "args": [
            "inode"
          ],
          "line": 88
        },
        "resolved": true,
        "details": {
          "function_name": "squashfs_i",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/squashfs/squashfs_fs_i.h",
          "lines": "50-53",
          "snippet": "static inline struct squashfs_inode_info *squashfs_i(struct inode *inode)\n{\n\treturn list_entry(inode, struct squashfs_inode_info, vfs_inode);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline struct squashfs_inode_info *squashfs_i(struct inode *inode)\n{\n\treturn list_entry(inode, struct squashfs_inode_info, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "squashfs_cache_get",
          "args": [
            "sb",
            "msblk->block_cache",
            "block",
            "0"
          ],
          "line": 84
        },
        "resolved": true,
        "details": {
          "function_name": "squashfs_cache_get",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/squashfs/cache.c",
          "lines": "65-180",
          "snippet": "struct squashfs_cache_entry *squashfs_cache_get(struct super_block *sb,\n\tstruct squashfs_cache *cache, u64 block, int length)\n{\n\tint i, n;\n\tstruct squashfs_cache_entry *entry;\n\n\tspin_lock(&cache->lock);\n\n\twhile (1) {\n\t\tfor (i = cache->curr_blk, n = 0; n < cache->entries; n++) {\n\t\t\tif (cache->entry[i].block == block) {\n\t\t\t\tcache->curr_blk = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\ti = (i + 1) % cache->entries;\n\t\t}\n\n\t\tif (n == cache->entries) {\n\t\t\t/*\n\t\t\t * Block not in cache, if all cache entries are used\n\t\t\t * go to sleep waiting for one to become available.\n\t\t\t */\n\t\t\tif (cache->unused == 0) {\n\t\t\t\tcache->num_waiters++;\n\t\t\t\tspin_unlock(&cache->lock);\n\t\t\t\twait_event(cache->wait_queue, cache->unused);\n\t\t\t\tspin_lock(&cache->lock);\n\t\t\t\tcache->num_waiters--;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * At least one unused cache entry.  A simple\n\t\t\t * round-robin strategy is used to choose the entry to\n\t\t\t * be evicted from the cache.\n\t\t\t */\n\t\t\ti = cache->next_blk;\n\t\t\tfor (n = 0; n < cache->entries; n++) {\n\t\t\t\tif (cache->entry[i].refcount == 0)\n\t\t\t\t\tbreak;\n\t\t\t\ti = (i + 1) % cache->entries;\n\t\t\t}\n\n\t\t\tcache->next_blk = (i + 1) % cache->entries;\n\t\t\tentry = &cache->entry[i];\n\n\t\t\t/*\n\t\t\t * Initialise chosen cache entry, and fill it in from\n\t\t\t * disk.\n\t\t\t */\n\t\t\tcache->unused--;\n\t\t\tentry->block = block;\n\t\t\tentry->refcount = 1;\n\t\t\tentry->pending = 1;\n\t\t\tentry->num_waiters = 0;\n\t\t\tentry->error = 0;\n\t\t\tspin_unlock(&cache->lock);\n\n\t\t\tentry->length = squashfs_read_data(sb, block, length,\n\t\t\t\t&entry->next_index, entry->actor);\n\n\t\t\tspin_lock(&cache->lock);\n\n\t\t\tif (entry->length < 0)\n\t\t\t\tentry->error = entry->length;\n\n\t\t\tentry->pending = 0;\n\n\t\t\t/*\n\t\t\t * While filling this entry one or more other processes\n\t\t\t * have looked it up in the cache, and have slept\n\t\t\t * waiting for it to become available.\n\t\t\t */\n\t\t\tif (entry->num_waiters) {\n\t\t\t\tspin_unlock(&cache->lock);\n\t\t\t\twake_up_all(&entry->wait_queue);\n\t\t\t} else\n\t\t\t\tspin_unlock(&cache->lock);\n\n\t\t\tgoto out;\n\t\t}\n\n\t\t/*\n\t\t * Block already in cache.  Increment refcount so it doesn't\n\t\t * get reused until we're finished with it, if it was\n\t\t * previously unused there's one less cache entry available\n\t\t * for reuse.\n\t\t */\n\t\tentry = &cache->entry[i];\n\t\tif (entry->refcount == 0)\n\t\t\tcache->unused--;\n\t\tentry->refcount++;\n\n\t\t/*\n\t\t * If the entry is currently being filled in by another process\n\t\t * go to sleep waiting for it to become available.\n\t\t */\n\t\tif (entry->pending) {\n\t\t\tentry->num_waiters++;\n\t\t\tspin_unlock(&cache->lock);\n\t\t\twait_event(entry->wait_queue, !entry->pending);\n\t\t} else\n\t\t\tspin_unlock(&cache->lock);\n\n\t\tgoto out;\n\t}\n\nout:\n\tTRACE(\"Got %s %d, start block %lld, refcount %d, error %d\\n\",\n\t\tcache->name, i, entry->block, entry->refcount, entry->error);\n\n\tif (entry->error)\n\t\tERROR(\"Unable to read %s cache entry [%llx]\\n\", cache->name,\n\t\t\t\t\t\t\tblock);\n\treturn entry;\n}",
          "includes": [
            "#include \"page_actor.h\"",
            "#include \"squashfs.h\"",
            "#include \"squashfs_fs_sb.h\"",
            "#include \"squashfs_fs.h\"",
            "#include <linux/pagemap.h>",
            "#include <linux/wait.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/sched.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/vfs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"page_actor.h\"\n#include \"squashfs.h\"\n#include \"squashfs_fs_sb.h\"\n#include \"squashfs_fs.h\"\n#include <linux/pagemap.h>\n#include <linux/wait.h>\n#include <linux/spinlock.h>\n#include <linux/sched.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/vfs.h>\n#include <linux/fs.h>\n\nstruct squashfs_cache_entry *squashfs_cache_get(struct super_block *sb,\n\tstruct squashfs_cache *cache, u64 block, int length)\n{\n\tint i, n;\n\tstruct squashfs_cache_entry *entry;\n\n\tspin_lock(&cache->lock);\n\n\twhile (1) {\n\t\tfor (i = cache->curr_blk, n = 0; n < cache->entries; n++) {\n\t\t\tif (cache->entry[i].block == block) {\n\t\t\t\tcache->curr_blk = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\ti = (i + 1) % cache->entries;\n\t\t}\n\n\t\tif (n == cache->entries) {\n\t\t\t/*\n\t\t\t * Block not in cache, if all cache entries are used\n\t\t\t * go to sleep waiting for one to become available.\n\t\t\t */\n\t\t\tif (cache->unused == 0) {\n\t\t\t\tcache->num_waiters++;\n\t\t\t\tspin_unlock(&cache->lock);\n\t\t\t\twait_event(cache->wait_queue, cache->unused);\n\t\t\t\tspin_lock(&cache->lock);\n\t\t\t\tcache->num_waiters--;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * At least one unused cache entry.  A simple\n\t\t\t * round-robin strategy is used to choose the entry to\n\t\t\t * be evicted from the cache.\n\t\t\t */\n\t\t\ti = cache->next_blk;\n\t\t\tfor (n = 0; n < cache->entries; n++) {\n\t\t\t\tif (cache->entry[i].refcount == 0)\n\t\t\t\t\tbreak;\n\t\t\t\ti = (i + 1) % cache->entries;\n\t\t\t}\n\n\t\t\tcache->next_blk = (i + 1) % cache->entries;\n\t\t\tentry = &cache->entry[i];\n\n\t\t\t/*\n\t\t\t * Initialise chosen cache entry, and fill it in from\n\t\t\t * disk.\n\t\t\t */\n\t\t\tcache->unused--;\n\t\t\tentry->block = block;\n\t\t\tentry->refcount = 1;\n\t\t\tentry->pending = 1;\n\t\t\tentry->num_waiters = 0;\n\t\t\tentry->error = 0;\n\t\t\tspin_unlock(&cache->lock);\n\n\t\t\tentry->length = squashfs_read_data(sb, block, length,\n\t\t\t\t&entry->next_index, entry->actor);\n\n\t\t\tspin_lock(&cache->lock);\n\n\t\t\tif (entry->length < 0)\n\t\t\t\tentry->error = entry->length;\n\n\t\t\tentry->pending = 0;\n\n\t\t\t/*\n\t\t\t * While filling this entry one or more other processes\n\t\t\t * have looked it up in the cache, and have slept\n\t\t\t * waiting for it to become available.\n\t\t\t */\n\t\t\tif (entry->num_waiters) {\n\t\t\t\tspin_unlock(&cache->lock);\n\t\t\t\twake_up_all(&entry->wait_queue);\n\t\t\t} else\n\t\t\t\tspin_unlock(&cache->lock);\n\n\t\t\tgoto out;\n\t\t}\n\n\t\t/*\n\t\t * Block already in cache.  Increment refcount so it doesn't\n\t\t * get reused until we're finished with it, if it was\n\t\t * previously unused there's one less cache entry available\n\t\t * for reuse.\n\t\t */\n\t\tentry = &cache->entry[i];\n\t\tif (entry->refcount == 0)\n\t\t\tcache->unused--;\n\t\tentry->refcount++;\n\n\t\t/*\n\t\t * If the entry is currently being filled in by another process\n\t\t * go to sleep waiting for it to become available.\n\t\t */\n\t\tif (entry->pending) {\n\t\t\tentry->num_waiters++;\n\t\t\tspin_unlock(&cache->lock);\n\t\t\twait_event(entry->wait_queue, !entry->pending);\n\t\t} else\n\t\t\tspin_unlock(&cache->lock);\n\n\t\tgoto out;\n\t}\n\nout:\n\tTRACE(\"Got %s %d, start block %lld, refcount %d, error %d\\n\",\n\t\tcache->name, i, entry->block, entry->refcount, entry->error);\n\n\tif (entry->error)\n\t\tERROR(\"Unable to read %s cache entry [%llx]\\n\", cache->name,\n\t\t\t\t\t\t\tblock);\n\treturn entry;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"Unable to read symlink [%llx:%x]\\n\"",
            "squashfs_i(inode)->start",
            "squashfs_i(inode)->offset"
          ],
          "line": 69
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "squashfs_read_metadata",
          "args": [
            "sb",
            "NULL",
            "&block",
            "&offset",
            "index"
          ],
          "line": 66
        },
        "resolved": true,
        "details": {
          "function_name": "squashfs_read_metadata",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/squashfs/cache.c",
          "lines": "344-382",
          "snippet": "int squashfs_read_metadata(struct super_block *sb, void *buffer,\n\t\tu64 *block, int *offset, int length)\n{\n\tstruct squashfs_sb_info *msblk = sb->s_fs_info;\n\tint bytes, res = length;\n\tstruct squashfs_cache_entry *entry;\n\n\tTRACE(\"Entered squashfs_read_metadata [%llx:%x]\\n\", *block, *offset);\n\n\twhile (length) {\n\t\tentry = squashfs_cache_get(sb, msblk->block_cache, *block, 0);\n\t\tif (entry->error) {\n\t\t\tres = entry->error;\n\t\t\tgoto error;\n\t\t} else if (*offset >= entry->length) {\n\t\t\tres = -EIO;\n\t\t\tgoto error;\n\t\t}\n\n\t\tbytes = squashfs_copy_data(buffer, entry, *offset, length);\n\t\tif (buffer)\n\t\t\tbuffer += bytes;\n\t\tlength -= bytes;\n\t\t*offset += bytes;\n\n\t\tif (*offset == entry->length) {\n\t\t\t*block = entry->next_index;\n\t\t\t*offset = 0;\n\t\t}\n\n\t\tsquashfs_cache_put(entry);\n\t}\n\n\treturn res;\n\nerror:\n\tsquashfs_cache_put(entry);\n\treturn res;\n}",
          "includes": [
            "#include \"page_actor.h\"",
            "#include \"squashfs.h\"",
            "#include \"squashfs_fs_sb.h\"",
            "#include \"squashfs_fs.h\"",
            "#include <linux/pagemap.h>",
            "#include <linux/wait.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/sched.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/vfs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"page_actor.h\"\n#include \"squashfs.h\"\n#include \"squashfs_fs_sb.h\"\n#include \"squashfs_fs.h\"\n#include <linux/pagemap.h>\n#include <linux/wait.h>\n#include <linux/spinlock.h>\n#include <linux/sched.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/vfs.h>\n#include <linux/fs.h>\n\nint squashfs_read_metadata(struct super_block *sb, void *buffer,\n\t\tu64 *block, int *offset, int length)\n{\n\tstruct squashfs_sb_info *msblk = sb->s_fs_info;\n\tint bytes, res = length;\n\tstruct squashfs_cache_entry *entry;\n\n\tTRACE(\"Entered squashfs_read_metadata [%llx:%x]\\n\", *block, *offset);\n\n\twhile (length) {\n\t\tentry = squashfs_cache_get(sb, msblk->block_cache, *block, 0);\n\t\tif (entry->error) {\n\t\t\tres = entry->error;\n\t\t\tgoto error;\n\t\t} else if (*offset >= entry->length) {\n\t\t\tres = -EIO;\n\t\t\tgoto error;\n\t\t}\n\n\t\tbytes = squashfs_copy_data(buffer, entry, *offset, length);\n\t\tif (buffer)\n\t\t\tbuffer += bytes;\n\t\tlength -= bytes;\n\t\t*offset += bytes;\n\n\t\tif (*offset == entry->length) {\n\t\t\t*block = entry->next_index;\n\t\t\t*offset = 0;\n\t\t}\n\n\t\tsquashfs_cache_put(entry);\n\t}\n\n\treturn res;\n\nerror:\n\tsquashfs_cache_put(entry);\n\treturn res;\n}"
        }
      },
      {
        "call_info": {
          "callee": "TRACE",
          "args": [
            "\"Entered squashfs_symlink_readpage, page index %ld, start block \"\n\t\t\t\"%llx, offset %x\\n\"",
            "page->index",
            "block",
            "offset"
          ],
          "line": 59
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "min_t",
          "args": [
            "int",
            "i_size_read(inode) - index",
            "PAGE_CACHE_SIZE"
          ],
          "line": 54
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "i_size_read",
          "args": [
            "inode"
          ],
          "line": 54
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xattr.h\"\n#include \"squashfs.h\"\n#include \"squashfs_fs_i.h\"\n#include \"squashfs_fs_sb.h\"\n#include \"squashfs_fs.h\"\n#include <linux/xattr.h>\n#include <linux/pagemap.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n#include <linux/vfs.h>\n#include <linux/fs.h>\n\nstatic int squashfs_symlink_readpage(struct file *file, struct page *page)\n{\n\tstruct inode *inode = page->mapping->host;\n\tstruct super_block *sb = inode->i_sb;\n\tstruct squashfs_sb_info *msblk = sb->s_fs_info;\n\tint index = page->index << PAGE_CACHE_SHIFT;\n\tu64 block = squashfs_i(inode)->start;\n\tint offset = squashfs_i(inode)->offset;\n\tint length = min_t(int, i_size_read(inode) - index, PAGE_CACHE_SIZE);\n\tint bytes, copied;\n\tvoid *pageaddr;\n\tstruct squashfs_cache_entry *entry;\n\n\tTRACE(\"Entered squashfs_symlink_readpage, page index %ld, start block \"\n\t\t\t\"%llx, offset %x\\n\", page->index, block, offset);\n\n\t/*\n\t * Skip index bytes into symlink metadata.\n\t */\n\tif (index) {\n\t\tbytes = squashfs_read_metadata(sb, NULL, &block, &offset,\n\t\t\t\t\t\t\t\tindex);\n\t\tif (bytes < 0) {\n\t\t\tERROR(\"Unable to read symlink [%llx:%x]\\n\",\n\t\t\t\tsquashfs_i(inode)->start,\n\t\t\t\tsquashfs_i(inode)->offset);\n\t\t\tgoto error_out;\n\t\t}\n\t}\n\n\t/*\n\t * Read length bytes from symlink metadata.  Squashfs_read_metadata\n\t * is not used here because it can sleep and we want to use\n\t * kmap_atomic to map the page.  Instead call the underlying\n\t * squashfs_cache_get routine.  As length bytes may overlap metadata\n\t * blocks, we may need to call squashfs_cache_get multiple times.\n\t */\n\tfor (bytes = 0; bytes < length; offset = 0, bytes += copied) {\n\t\tentry = squashfs_cache_get(sb, msblk->block_cache, block, 0);\n\t\tif (entry->error) {\n\t\t\tERROR(\"Unable to read symlink [%llx:%x]\\n\",\n\t\t\t\tsquashfs_i(inode)->start,\n\t\t\t\tsquashfs_i(inode)->offset);\n\t\t\tsquashfs_cache_put(entry);\n\t\t\tgoto error_out;\n\t\t}\n\n\t\tpageaddr = kmap_atomic(page);\n\t\tcopied = squashfs_copy_data(pageaddr + bytes, entry, offset,\n\t\t\t\t\t\t\t\tlength - bytes);\n\t\tif (copied == length - bytes)\n\t\t\tmemset(pageaddr + length, 0, PAGE_CACHE_SIZE - length);\n\t\telse\n\t\t\tblock = entry->next_index;\n\t\tkunmap_atomic(pageaddr);\n\t\tsquashfs_cache_put(entry);\n\t}\n\n\tflush_dcache_page(page);\n\tSetPageUptodate(page);\n\tunlock_page(page);\n\treturn 0;\n\nerror_out:\n\tSetPageError(page);\n\tunlock_page(page);\n\treturn 0;\n}"
  }
]