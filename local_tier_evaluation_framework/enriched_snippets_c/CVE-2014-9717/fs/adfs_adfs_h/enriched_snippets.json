[
  {
    "function_name": "__adfs_block_map",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/adfs/adfs.h",
    "lines": "196-208",
    "snippet": "static inline int\n__adfs_block_map(struct super_block *sb, unsigned int object_id,\n\t\t unsigned int block)\n{\n\tif (object_id & 255) {\n\t\tunsigned int off;\n\n\t\toff = (object_id & 255) - 1;\n\t\tblock += off << ADFS_SB(sb)->s_log2sharesize;\n\t}\n\n\treturn adfs_map_lookup(sb, object_id >> 8, block);\n}",
    "includes": [
      "#include \"dir_f.h\"",
      "#include <linux/adfs_fs.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "extern unsigned int adfs_map_free(struct super_block *sb);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "adfs_map_lookup",
          "args": [
            "sb",
            "object_id >> 8",
            "block"
          ],
          "line": 207
        },
        "resolved": true,
        "details": {
          "function_name": "adfs_map_lookup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/adfs/map.c",
          "lines": "247-290",
          "snippet": "int\nadfs_map_lookup(struct super_block *sb, unsigned int frag_id,\n\t\tunsigned int offset)\n{\n\tstruct adfs_sb_info *asb = ADFS_SB(sb);\n\tunsigned int zone, mapoff;\n\tint result;\n\n\t/*\n\t * map & root fragment is special - it starts in the center of the\n\t * disk.  The other fragments start at zone (frag / ids_per_zone)\n\t */\n\tif (frag_id == ADFS_ROOT_FRAG)\n\t\tzone = asb->s_map_size >> 1;\n\telse\n\t\tzone = frag_id / asb->s_ids_per_zone;\n\n\tif (zone >= asb->s_map_size)\n\t\tgoto bad_fragment;\n\n\t/* Convert sector offset to map offset */\n\tmapoff = signed_asl(offset, -asb->s_map2blk);\n\n\tread_lock(&adfs_map_lock);\n\tresult = scan_map(asb, zone, frag_id, mapoff);\n\tread_unlock(&adfs_map_lock);\n\n\tif (result > 0) {\n\t\tunsigned int secoff;\n\n\t\t/* Calculate sector offset into map block */\n\t\tsecoff = offset - signed_asl(mapoff, asb->s_map2blk);\n\t\treturn secoff + signed_asl(result, asb->s_map2blk);\n\t}\n\n\tadfs_error(sb, \"fragment 0x%04x at offset %d not found in map\",\n\t\t   frag_id, offset);\n\treturn 0;\n\nbad_fragment:\n\tadfs_error(sb, \"invalid fragment 0x%04x (zone = %d, max = %d)\",\n\t\t   frag_id, zone, asb->s_map_size);\n\treturn 0;\n}",
          "includes": [
            "#include \"adfs.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_RWLOCK(adfs_map_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"adfs.h\"\n#include <asm/unaligned.h>\n#include <linux/buffer_head.h>\n\nstatic DEFINE_RWLOCK(adfs_map_lock);\n\nint\nadfs_map_lookup(struct super_block *sb, unsigned int frag_id,\n\t\tunsigned int offset)\n{\n\tstruct adfs_sb_info *asb = ADFS_SB(sb);\n\tunsigned int zone, mapoff;\n\tint result;\n\n\t/*\n\t * map & root fragment is special - it starts in the center of the\n\t * disk.  The other fragments start at zone (frag / ids_per_zone)\n\t */\n\tif (frag_id == ADFS_ROOT_FRAG)\n\t\tzone = asb->s_map_size >> 1;\n\telse\n\t\tzone = frag_id / asb->s_ids_per_zone;\n\n\tif (zone >= asb->s_map_size)\n\t\tgoto bad_fragment;\n\n\t/* Convert sector offset to map offset */\n\tmapoff = signed_asl(offset, -asb->s_map2blk);\n\n\tread_lock(&adfs_map_lock);\n\tresult = scan_map(asb, zone, frag_id, mapoff);\n\tread_unlock(&adfs_map_lock);\n\n\tif (result > 0) {\n\t\tunsigned int secoff;\n\n\t\t/* Calculate sector offset into map block */\n\t\tsecoff = offset - signed_asl(mapoff, asb->s_map2blk);\n\t\treturn secoff + signed_asl(result, asb->s_map2blk);\n\t}\n\n\tadfs_error(sb, \"fragment 0x%04x at offset %d not found in map\",\n\t\t   frag_id, offset);\n\treturn 0;\n\nbad_fragment:\n\tadfs_error(sb, \"invalid fragment 0x%04x (zone = %d, max = %d)\",\n\t\t   frag_id, zone, asb->s_map_size);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ADFS_SB",
          "args": [
            "sb"
          ],
          "line": 204
        },
        "resolved": true,
        "details": {
          "function_name": "ADFS_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/adfs/adfs.h",
          "lines": "68-71",
          "snippet": "static inline struct adfs_sb_info *ADFS_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"dir_f.h\"",
            "#include <linux/adfs_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern unsigned int adfs_map_free(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"dir_f.h\"\n#include <linux/adfs_fs.h>\n#include <linux/fs.h>\n\nextern unsigned int adfs_map_free(struct super_block *sb);\n\nstatic inline struct adfs_sb_info *ADFS_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"dir_f.h\"\n#include <linux/adfs_fs.h>\n#include <linux/fs.h>\n\nextern unsigned int adfs_map_free(struct super_block *sb);\n\nstatic inline int\n__adfs_block_map(struct super_block *sb, unsigned int object_id,\n\t\t unsigned int block)\n{\n\tif (object_id & 255) {\n\t\tunsigned int off;\n\n\t\toff = (object_id & 255) - 1;\n\t\tblock += off << ADFS_SB(sb)->s_log2sharesize;\n\t}\n\n\treturn adfs_map_lookup(sb, object_id >> 8, block);\n}"
  },
  {
    "function_name": "signed_asl",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/adfs/adfs.h",
    "lines": "181-188",
    "snippet": "static inline __u32 signed_asl(__u32 val, signed int shift)\n{\n\tif (shift >= 0)\n\t\tval <<= shift;\n\telse\n\t\tval >>= -shift;\n\treturn val;\n}",
    "includes": [
      "#include \"dir_f.h\"",
      "#include <linux/adfs_fs.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"dir_f.h\"\n#include <linux/adfs_fs.h>\n#include <linux/fs.h>\n\nstatic inline __u32 signed_asl(__u32 val, signed int shift)\n{\n\tif (shift >= 0)\n\t\tval <<= shift;\n\telse\n\t\tval >>= -shift;\n\treturn val;\n}"
  },
  {
    "function_name": "append_filetype_suffix",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/adfs/adfs.h",
    "lines": "116-126",
    "snippet": "static inline int append_filetype_suffix(char *buf, __u16 filetype)\n{\n\tif (filetype == 0xffff)\t/* no explicit 12-bit file type was set */\n\t\treturn 0;\n\n\t*buf++ = ',';\n\t*buf++ = hex_asc_lo(filetype >> 8);\n\t*buf++ = hex_asc_lo(filetype >> 4);\n\t*buf++ = hex_asc_lo(filetype >> 0);\n\treturn 4;\n}",
    "includes": [
      "#include \"dir_f.h\"",
      "#include <linux/adfs_fs.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "hex_asc_lo",
          "args": [
            "filetype >> 0"
          ],
          "line": 124
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hex_asc_lo",
          "args": [
            "filetype >> 4"
          ],
          "line": 123
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hex_asc_lo",
          "args": [
            "filetype >> 8"
          ],
          "line": 122
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"dir_f.h\"\n#include <linux/adfs_fs.h>\n#include <linux/fs.h>\n\nstatic inline int append_filetype_suffix(char *buf, __u16 filetype)\n{\n\tif (filetype == 0xffff)\t/* no explicit 12-bit file type was set */\n\t\treturn 0;\n\n\t*buf++ = ',';\n\t*buf++ = hex_asc_lo(filetype >> 8);\n\t*buf++ = hex_asc_lo(filetype >> 4);\n\t*buf++ = hex_asc_lo(filetype >> 0);\n\treturn 4;\n}"
  },
  {
    "function_name": "ADFS_I",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/adfs/adfs.h",
    "lines": "73-76",
    "snippet": "static inline struct adfs_inode_info *ADFS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct adfs_inode_info, vfs_inode);\n}",
    "includes": [
      "#include \"dir_f.h\"",
      "#include <linux/adfs_fs.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "inode",
            "structadfs_inode_info",
            "vfs_inode"
          ],
          "line": 75
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"dir_f.h\"\n#include <linux/adfs_fs.h>\n#include <linux/fs.h>\n\nstatic inline struct adfs_inode_info *ADFS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct adfs_inode_info, vfs_inode);\n}"
  },
  {
    "function_name": "ADFS_SB",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/adfs/adfs.h",
    "lines": "68-71",
    "snippet": "static inline struct adfs_sb_info *ADFS_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
    "includes": [
      "#include \"dir_f.h\"",
      "#include <linux/adfs_fs.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "extern unsigned int adfs_map_free(struct super_block *sb);"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"dir_f.h\"\n#include <linux/adfs_fs.h>\n#include <linux/fs.h>\n\nextern unsigned int adfs_map_free(struct super_block *sb);\n\nstatic inline struct adfs_sb_info *ADFS_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
  }
]