[
  {
    "function_name": "do_sendfile",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/read_write.c",
    "lines": "1252-1350",
    "snippet": "static ssize_t do_sendfile(int out_fd, int in_fd, loff_t *ppos,\n\t\t  \t   size_t count, loff_t max)\n{\n\tstruct fd in, out;\n\tstruct inode *in_inode, *out_inode;\n\tloff_t pos;\n\tloff_t out_pos;\n\tssize_t retval;\n\tint fl;\n\n\t/*\n\t * Get input file, and verify that it is ok..\n\t */\n\tretval = -EBADF;\n\tin = fdget(in_fd);\n\tif (!in.file)\n\t\tgoto out;\n\tif (!(in.file->f_mode & FMODE_READ))\n\t\tgoto fput_in;\n\tretval = -ESPIPE;\n\tif (!ppos) {\n\t\tpos = in.file->f_pos;\n\t} else {\n\t\tpos = *ppos;\n\t\tif (!(in.file->f_mode & FMODE_PREAD))\n\t\t\tgoto fput_in;\n\t}\n\tretval = rw_verify_area(READ, in.file, &pos, count);\n\tif (retval < 0)\n\t\tgoto fput_in;\n\tcount = retval;\n\n\t/*\n\t * Get output file, and verify that it is ok..\n\t */\n\tretval = -EBADF;\n\tout = fdget(out_fd);\n\tif (!out.file)\n\t\tgoto fput_in;\n\tif (!(out.file->f_mode & FMODE_WRITE))\n\t\tgoto fput_out;\n\tretval = -EINVAL;\n\tin_inode = file_inode(in.file);\n\tout_inode = file_inode(out.file);\n\tout_pos = out.file->f_pos;\n\tretval = rw_verify_area(WRITE, out.file, &out_pos, count);\n\tif (retval < 0)\n\t\tgoto fput_out;\n\tcount = retval;\n\n\tif (!max)\n\t\tmax = min(in_inode->i_sb->s_maxbytes, out_inode->i_sb->s_maxbytes);\n\n\tif (unlikely(pos + count > max)) {\n\t\tretval = -EOVERFLOW;\n\t\tif (pos >= max)\n\t\t\tgoto fput_out;\n\t\tcount = max - pos;\n\t}\n\n\tfl = 0;\n#if 0\n\t/*\n\t * We need to debate whether we can enable this or not. The\n\t * man page documents EAGAIN return for the output at least,\n\t * and the application is arguably buggy if it doesn't expect\n\t * EAGAIN on a non-blocking file descriptor.\n\t */\n\tif (in.file->f_flags & O_NONBLOCK)\n\t\tfl = SPLICE_F_NONBLOCK;\n#endif\n\tfile_start_write(out.file);\n\tretval = do_splice_direct(in.file, &pos, out.file, &out_pos, count, fl);\n\tfile_end_write(out.file);\n\n\tif (retval > 0) {\n\t\tadd_rchar(current, retval);\n\t\tadd_wchar(current, retval);\n\t\tfsnotify_access(in.file);\n\t\tfsnotify_modify(out.file);\n\t\tout.file->f_pos = out_pos;\n\t\tif (ppos)\n\t\t\t*ppos = pos;\n\t\telse\n\t\t\tin.file->f_pos = pos;\n\t}\n\n\tinc_syscr(current);\n\tinc_syscw(current);\n\tif (pos > max)\n\t\tretval = -EOVERFLOW;\n\nfput_out:\n\tfdput(out);\nfput_in:\n\tfdput(in);\nout:\n\treturn retval;\n}",
    "includes": [
      "#include <asm/unistd.h>",
      "#include <asm/uaccess.h>",
      "#include \"internal.h\"",
      "#include <linux/compat.h>",
      "#include <linux/splice.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/export.h>",
      "#include <linux/security.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/aio.h>",
      "#include <linux/uio.h>",
      "#include <linux/file.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/stat.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fdput",
          "args": [
            "in"
          ],
          "line": 1347
        },
        "resolved": true,
        "details": {
          "function_name": "fdput_pos",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/read_write.c",
          "lines": "273-278",
          "snippet": "static inline void fdput_pos(struct fd f)\n{\n\tif (f.flags & FDPUT_POS_UNLOCK)\n\t\tmutex_unlock(&f.file->f_pos_lock);\n\tfdput(f);\n}",
          "includes": [
            "#include <asm/unistd.h>",
            "#include <asm/uaccess.h>",
            "#include \"internal.h\"",
            "#include <linux/compat.h>",
            "#include <linux/splice.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/export.h>",
            "#include <linux/security.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/aio.h>",
            "#include <linux/uio.h>",
            "#include <linux/file.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/stat.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/unistd.h>\n#include <asm/uaccess.h>\n#include \"internal.h\"\n#include <linux/compat.h>\n#include <linux/splice.h>\n#include <linux/pagemap.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/security.h>\n#include <linux/fsnotify.h>\n#include <linux/aio.h>\n#include <linux/uio.h>\n#include <linux/file.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/slab.h>\n\nstatic inline void fdput_pos(struct fd f)\n{\n\tif (f.flags & FDPUT_POS_UNLOCK)\n\t\tmutex_unlock(&f.file->f_pos_lock);\n\tfdput(f);\n}"
        }
      },
      {
        "call_info": {
          "callee": "inc_syscw",
          "args": [
            "current"
          ],
          "line": 1340
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "inc_syscr",
          "args": [
            "current"
          ],
          "line": 1339
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fsnotify_modify",
          "args": [
            "out.file"
          ],
          "line": 1331
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fsnotify_access",
          "args": [
            "in.file"
          ],
          "line": 1330
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "add_wchar",
          "args": [
            "current",
            "retval"
          ],
          "line": 1329
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "add_rchar",
          "args": [
            "current",
            "retval"
          ],
          "line": 1328
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "file_end_write",
          "args": [
            "out.file"
          ],
          "line": 1325
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "do_splice_direct",
          "args": [
            "in.file",
            "&pos",
            "out.file",
            "&out_pos",
            "count",
            "fl"
          ],
          "line": 1324
        },
        "resolved": true,
        "details": {
          "function_name": "do_splice_direct",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/splice.c",
          "lines": "1289-1317",
          "snippet": "long do_splice_direct(struct file *in, loff_t *ppos, struct file *out,\n\t\t      loff_t *opos, size_t len, unsigned int flags)\n{\n\tstruct splice_desc sd = {\n\t\t.len\t\t= len,\n\t\t.total_len\t= len,\n\t\t.flags\t\t= flags,\n\t\t.pos\t\t= *ppos,\n\t\t.u.file\t\t= out,\n\t\t.opos\t\t= opos,\n\t};\n\tlong ret;\n\n\tif (unlikely(!(out->f_mode & FMODE_WRITE)))\n\t\treturn -EBADF;\n\n\tif (unlikely(out->f_flags & O_APPEND))\n\t\treturn -EINVAL;\n\n\tret = rw_verify_area(WRITE, out, opos, len);\n\tif (unlikely(ret < 0))\n\t\treturn ret;\n\n\tret = splice_direct_to_actor(in, &sd, direct_splice_actor);\n\tif (ret > 0)\n\t\t*ppos = sd.pos;\n\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/aio.h>",
            "#include <linux/compat.h>",
            "#include <linux/socket.h>",
            "#include <linux/gfp.h>",
            "#include <linux/security.h>",
            "#include <linux/uio.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/export.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/splice.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int splice_pipe_to_pipe(struct pipe_inode_info *ipipe,\n\t\t\t       struct pipe_inode_info *opipe,\n\t\t\t       size_t len, unsigned int flags);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/aio.h>\n#include <linux/compat.h>\n#include <linux/socket.h>\n#include <linux/gfp.h>\n#include <linux/security.h>\n#include <linux/uio.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/mm_inline.h>\n#include <linux/memcontrol.h>\n#include <linux/splice.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n\nstatic int splice_pipe_to_pipe(struct pipe_inode_info *ipipe,\n\t\t\t       struct pipe_inode_info *opipe,\n\t\t\t       size_t len, unsigned int flags);\n\nlong do_splice_direct(struct file *in, loff_t *ppos, struct file *out,\n\t\t      loff_t *opos, size_t len, unsigned int flags)\n{\n\tstruct splice_desc sd = {\n\t\t.len\t\t= len,\n\t\t.total_len\t= len,\n\t\t.flags\t\t= flags,\n\t\t.pos\t\t= *ppos,\n\t\t.u.file\t\t= out,\n\t\t.opos\t\t= opos,\n\t};\n\tlong ret;\n\n\tif (unlikely(!(out->f_mode & FMODE_WRITE)))\n\t\treturn -EBADF;\n\n\tif (unlikely(out->f_flags & O_APPEND))\n\t\treturn -EINVAL;\n\n\tret = rw_verify_area(WRITE, out, opos, len);\n\tif (unlikely(ret < 0))\n\t\treturn ret;\n\n\tret = splice_direct_to_actor(in, &sd, direct_splice_actor);\n\tif (ret > 0)\n\t\t*ppos = sd.pos;\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "file_start_write",
          "args": [
            "out.file"
          ],
          "line": 1323
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "pos + count > max"
          ],
          "line": 1305
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "min",
          "args": [
            "in_inode->i_sb->s_maxbytes",
            "out_inode->i_sb->s_maxbytes"
          ],
          "line": 1303
        },
        "resolved": true,
        "details": {
          "function_name": "get_dominating_id",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/pnode.c",
          "lines": "55-66",
          "snippet": "int get_dominating_id(struct mount *mnt, const struct path *root)\n{\n\tstruct mount *m;\n\n\tfor (m = mnt->mnt_master; m != NULL; m = m->mnt_master) {\n\t\tstruct mount *d = get_peer_under_root(m, mnt->mnt_ns, root);\n\t\tif (d)\n\t\t\treturn d->mnt_group_id;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"pnode.h\"",
            "#include \"internal.h\"",
            "#include <linux/nsproxy.h>",
            "#include <linux/fs.h>",
            "#include <linux/mount.h>",
            "#include <linux/mnt_namespace.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnode.h\"\n#include \"internal.h\"\n#include <linux/nsproxy.h>\n#include <linux/fs.h>\n#include <linux/mount.h>\n#include <linux/mnt_namespace.h>\n\nint get_dominating_id(struct mount *mnt, const struct path *root)\n{\n\tstruct mount *m;\n\n\tfor (m = mnt->mnt_master; m != NULL; m = m->mnt_master) {\n\t\tstruct mount *d = get_peer_under_root(m, mnt->mnt_ns, root);\n\t\tif (d)\n\t\t\treturn d->mnt_group_id;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rw_verify_area",
          "args": [
            "WRITE",
            "out.file",
            "&out_pos",
            "count"
          ],
          "line": 1297
        },
        "resolved": true,
        "details": {
          "function_name": "rw_verify_area",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/read_write.c",
          "lines": "387-419",
          "snippet": "int rw_verify_area(int read_write, struct file *file, const loff_t *ppos, size_t count)\n{\n\tstruct inode *inode;\n\tloff_t pos;\n\tint retval = -EINVAL;\n\n\tinode = file_inode(file);\n\tif (unlikely((ssize_t) count < 0))\n\t\treturn retval;\n\tpos = *ppos;\n\tif (unlikely(pos < 0)) {\n\t\tif (!unsigned_offsets(file))\n\t\t\treturn retval;\n\t\tif (count >= -pos) /* both values are in 0..LLONG_MAX */\n\t\t\treturn -EOVERFLOW;\n\t} else if (unlikely((loff_t) (pos + count) < 0)) {\n\t\tif (!unsigned_offsets(file))\n\t\t\treturn retval;\n\t}\n\n\tif (unlikely(inode->i_flctx && mandatory_lock(inode))) {\n\t\tretval = locks_mandatory_area(\n\t\t\tread_write == READ ? FLOCK_VERIFY_READ : FLOCK_VERIFY_WRITE,\n\t\t\tinode, file, pos, count);\n\t\tif (retval < 0)\n\t\t\treturn retval;\n\t}\n\tretval = security_file_permission(file,\n\t\t\t\tread_write == READ ? MAY_READ : MAY_WRITE);\n\tif (retval)\n\t\treturn retval;\n\treturn count > MAX_RW_COUNT ? MAX_RW_COUNT : count;\n}",
          "includes": [
            "#include <asm/unistd.h>",
            "#include <asm/uaccess.h>",
            "#include \"internal.h\"",
            "#include <linux/compat.h>",
            "#include <linux/splice.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/export.h>",
            "#include <linux/security.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/aio.h>",
            "#include <linux/uio.h>",
            "#include <linux/file.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/stat.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/unistd.h>\n#include <asm/uaccess.h>\n#include \"internal.h\"\n#include <linux/compat.h>\n#include <linux/splice.h>\n#include <linux/pagemap.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/security.h>\n#include <linux/fsnotify.h>\n#include <linux/aio.h>\n#include <linux/uio.h>\n#include <linux/file.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/slab.h>\n\nint rw_verify_area(int read_write, struct file *file, const loff_t *ppos, size_t count)\n{\n\tstruct inode *inode;\n\tloff_t pos;\n\tint retval = -EINVAL;\n\n\tinode = file_inode(file);\n\tif (unlikely((ssize_t) count < 0))\n\t\treturn retval;\n\tpos = *ppos;\n\tif (unlikely(pos < 0)) {\n\t\tif (!unsigned_offsets(file))\n\t\t\treturn retval;\n\t\tif (count >= -pos) /* both values are in 0..LLONG_MAX */\n\t\t\treturn -EOVERFLOW;\n\t} else if (unlikely((loff_t) (pos + count) < 0)) {\n\t\tif (!unsigned_offsets(file))\n\t\t\treturn retval;\n\t}\n\n\tif (unlikely(inode->i_flctx && mandatory_lock(inode))) {\n\t\tretval = locks_mandatory_area(\n\t\t\tread_write == READ ? FLOCK_VERIFY_READ : FLOCK_VERIFY_WRITE,\n\t\t\tinode, file, pos, count);\n\t\tif (retval < 0)\n\t\t\treturn retval;\n\t}\n\tretval = security_file_permission(file,\n\t\t\t\tread_write == READ ? MAY_READ : MAY_WRITE);\n\tif (retval)\n\t\treturn retval;\n\treturn count > MAX_RW_COUNT ? MAX_RW_COUNT : count;\n}"
        }
      },
      {
        "call_info": {
          "callee": "file_inode",
          "args": [
            "out.file"
          ],
          "line": 1295
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_init_file_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/file.c",
          "lines": "3009-3013",
          "snippet": "void fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}",
          "includes": [
            "#include <linux/falloc.h>",
            "#include <linux/aio.h>",
            "#include <linux/swap.h>",
            "#include <linux/compat.h>",
            "#include <linux/module.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};",
            "static const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/compat.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};\nstatic const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};\n\nvoid fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fdget",
          "args": [
            "out_fd"
          ],
          "line": 1288
        },
        "resolved": true,
        "details": {
          "function_name": "fdget_pos",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/read_write.c",
          "lines": "268-271",
          "snippet": "static inline struct fd fdget_pos(int fd)\n{\n\treturn __to_fd(__fdget_pos(fd));\n}",
          "includes": [
            "#include <asm/unistd.h>",
            "#include <asm/uaccess.h>",
            "#include \"internal.h\"",
            "#include <linux/compat.h>",
            "#include <linux/splice.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/export.h>",
            "#include <linux/security.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/aio.h>",
            "#include <linux/uio.h>",
            "#include <linux/file.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/stat.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/unistd.h>\n#include <asm/uaccess.h>\n#include \"internal.h\"\n#include <linux/compat.h>\n#include <linux/splice.h>\n#include <linux/pagemap.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/security.h>\n#include <linux/fsnotify.h>\n#include <linux/aio.h>\n#include <linux/uio.h>\n#include <linux/file.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/slab.h>\n\nstatic inline struct fd fdget_pos(int fd)\n{\n\treturn __to_fd(__fdget_pos(fd));\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/unistd.h>\n#include <asm/uaccess.h>\n#include \"internal.h\"\n#include <linux/compat.h>\n#include <linux/splice.h>\n#include <linux/pagemap.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/security.h>\n#include <linux/fsnotify.h>\n#include <linux/aio.h>\n#include <linux/uio.h>\n#include <linux/file.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/slab.h>\n\nstatic ssize_t do_sendfile(int out_fd, int in_fd, loff_t *ppos,\n\t\t  \t   size_t count, loff_t max)\n{\n\tstruct fd in, out;\n\tstruct inode *in_inode, *out_inode;\n\tloff_t pos;\n\tloff_t out_pos;\n\tssize_t retval;\n\tint fl;\n\n\t/*\n\t * Get input file, and verify that it is ok..\n\t */\n\tretval = -EBADF;\n\tin = fdget(in_fd);\n\tif (!in.file)\n\t\tgoto out;\n\tif (!(in.file->f_mode & FMODE_READ))\n\t\tgoto fput_in;\n\tretval = -ESPIPE;\n\tif (!ppos) {\n\t\tpos = in.file->f_pos;\n\t} else {\n\t\tpos = *ppos;\n\t\tif (!(in.file->f_mode & FMODE_PREAD))\n\t\t\tgoto fput_in;\n\t}\n\tretval = rw_verify_area(READ, in.file, &pos, count);\n\tif (retval < 0)\n\t\tgoto fput_in;\n\tcount = retval;\n\n\t/*\n\t * Get output file, and verify that it is ok..\n\t */\n\tretval = -EBADF;\n\tout = fdget(out_fd);\n\tif (!out.file)\n\t\tgoto fput_in;\n\tif (!(out.file->f_mode & FMODE_WRITE))\n\t\tgoto fput_out;\n\tretval = -EINVAL;\n\tin_inode = file_inode(in.file);\n\tout_inode = file_inode(out.file);\n\tout_pos = out.file->f_pos;\n\tretval = rw_verify_area(WRITE, out.file, &out_pos, count);\n\tif (retval < 0)\n\t\tgoto fput_out;\n\tcount = retval;\n\n\tif (!max)\n\t\tmax = min(in_inode->i_sb->s_maxbytes, out_inode->i_sb->s_maxbytes);\n\n\tif (unlikely(pos + count > max)) {\n\t\tretval = -EOVERFLOW;\n\t\tif (pos >= max)\n\t\t\tgoto fput_out;\n\t\tcount = max - pos;\n\t}\n\n\tfl = 0;\n#if 0\n\t/*\n\t * We need to debate whether we can enable this or not. The\n\t * man page documents EAGAIN return for the output at least,\n\t * and the application is arguably buggy if it doesn't expect\n\t * EAGAIN on a non-blocking file descriptor.\n\t */\n\tif (in.file->f_flags & O_NONBLOCK)\n\t\tfl = SPLICE_F_NONBLOCK;\n#endif\n\tfile_start_write(out.file);\n\tretval = do_splice_direct(in.file, &pos, out.file, &out_pos, count, fl);\n\tfile_end_write(out.file);\n\n\tif (retval > 0) {\n\t\tadd_rchar(current, retval);\n\t\tadd_wchar(current, retval);\n\t\tfsnotify_access(in.file);\n\t\tfsnotify_modify(out.file);\n\t\tout.file->f_pos = out_pos;\n\t\tif (ppos)\n\t\t\t*ppos = pos;\n\t\telse\n\t\t\tin.file->f_pos = pos;\n\t}\n\n\tinc_syscr(current);\n\tinc_syscw(current);\n\tif (pos > max)\n\t\tretval = -EOVERFLOW;\n\nfput_out:\n\tfdput(out);\nfput_in:\n\tfdput(in);\nout:\n\treturn retval;\n}"
  },
  {
    "function_name": "__compat_sys_pwritev64",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/read_write.c",
    "lines": "1214-1231",
    "snippet": "static long __compat_sys_pwritev64(unsigned long fd,\n\t\t\t\t   const struct compat_iovec __user *vec,\n\t\t\t\t   unsigned long vlen, loff_t pos)\n{\n\tstruct fd f;\n\tssize_t ret;\n\n\tif (pos < 0)\n\t\treturn -EINVAL;\n\tf = fdget(fd);\n\tif (!f.file)\n\t\treturn -EBADF;\n\tret = -ESPIPE;\n\tif (f.file->f_mode & FMODE_PWRITE)\n\t\tret = compat_writev(f.file, vec, vlen, &pos);\n\tfdput(f);\n\treturn ret;\n}",
    "includes": [
      "#include <asm/unistd.h>",
      "#include <asm/uaccess.h>",
      "#include \"internal.h\"",
      "#include <linux/compat.h>",
      "#include <linux/splice.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/export.h>",
      "#include <linux/security.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/aio.h>",
      "#include <linux/uio.h>",
      "#include <linux/file.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/stat.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fdput",
          "args": [
            "f"
          ],
          "line": 1229
        },
        "resolved": true,
        "details": {
          "function_name": "fdput_pos",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/read_write.c",
          "lines": "273-278",
          "snippet": "static inline void fdput_pos(struct fd f)\n{\n\tif (f.flags & FDPUT_POS_UNLOCK)\n\t\tmutex_unlock(&f.file->f_pos_lock);\n\tfdput(f);\n}",
          "includes": [
            "#include <asm/unistd.h>",
            "#include <asm/uaccess.h>",
            "#include \"internal.h\"",
            "#include <linux/compat.h>",
            "#include <linux/splice.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/export.h>",
            "#include <linux/security.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/aio.h>",
            "#include <linux/uio.h>",
            "#include <linux/file.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/stat.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/unistd.h>\n#include <asm/uaccess.h>\n#include \"internal.h\"\n#include <linux/compat.h>\n#include <linux/splice.h>\n#include <linux/pagemap.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/security.h>\n#include <linux/fsnotify.h>\n#include <linux/aio.h>\n#include <linux/uio.h>\n#include <linux/file.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/slab.h>\n\nstatic inline void fdput_pos(struct fd f)\n{\n\tif (f.flags & FDPUT_POS_UNLOCK)\n\t\tmutex_unlock(&f.file->f_pos_lock);\n\tfdput(f);\n}"
        }
      },
      {
        "call_info": {
          "callee": "compat_writev",
          "args": [
            "f.file",
            "vec",
            "vlen",
            "&pos"
          ],
          "line": 1228
        },
        "resolved": true,
        "details": {
          "function_name": "compat_writev",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/read_write.c",
          "lines": "1174-1194",
          "snippet": "static size_t compat_writev(struct file *file,\n\t\t\t    const struct compat_iovec __user *vec,\n\t\t\t    unsigned long vlen, loff_t *pos)\n{\n\tssize_t ret = -EBADF;\n\n\tif (!(file->f_mode & FMODE_WRITE))\n\t\tgoto out;\n\n\tret = -EINVAL;\n\tif (!(file->f_mode & FMODE_CAN_WRITE))\n\t\tgoto out;\n\n\tret = compat_do_readv_writev(WRITE, file, vec, vlen, pos);\n\nout:\n\tif (ret > 0)\n\t\tadd_wchar(current, ret);\n\tinc_syscw(current);\n\treturn ret;\n}",
          "includes": [
            "#include <asm/unistd.h>",
            "#include <asm/uaccess.h>",
            "#include \"internal.h\"",
            "#include <linux/compat.h>",
            "#include <linux/splice.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/export.h>",
            "#include <linux/security.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/aio.h>",
            "#include <linux/uio.h>",
            "#include <linux/file.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/stat.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/unistd.h>\n#include <asm/uaccess.h>\n#include \"internal.h\"\n#include <linux/compat.h>\n#include <linux/splice.h>\n#include <linux/pagemap.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/security.h>\n#include <linux/fsnotify.h>\n#include <linux/aio.h>\n#include <linux/uio.h>\n#include <linux/file.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/slab.h>\n\nstatic size_t compat_writev(struct file *file,\n\t\t\t    const struct compat_iovec __user *vec,\n\t\t\t    unsigned long vlen, loff_t *pos)\n{\n\tssize_t ret = -EBADF;\n\n\tif (!(file->f_mode & FMODE_WRITE))\n\t\tgoto out;\n\n\tret = -EINVAL;\n\tif (!(file->f_mode & FMODE_CAN_WRITE))\n\t\tgoto out;\n\n\tret = compat_do_readv_writev(WRITE, file, vec, vlen, pos);\n\nout:\n\tif (ret > 0)\n\t\tadd_wchar(current, ret);\n\tinc_syscw(current);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fdget",
          "args": [
            "fd"
          ],
          "line": 1223
        },
        "resolved": true,
        "details": {
          "function_name": "fdget_pos",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/read_write.c",
          "lines": "268-271",
          "snippet": "static inline struct fd fdget_pos(int fd)\n{\n\treturn __to_fd(__fdget_pos(fd));\n}",
          "includes": [
            "#include <asm/unistd.h>",
            "#include <asm/uaccess.h>",
            "#include \"internal.h\"",
            "#include <linux/compat.h>",
            "#include <linux/splice.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/export.h>",
            "#include <linux/security.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/aio.h>",
            "#include <linux/uio.h>",
            "#include <linux/file.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/stat.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/unistd.h>\n#include <asm/uaccess.h>\n#include \"internal.h\"\n#include <linux/compat.h>\n#include <linux/splice.h>\n#include <linux/pagemap.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/security.h>\n#include <linux/fsnotify.h>\n#include <linux/aio.h>\n#include <linux/uio.h>\n#include <linux/file.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/slab.h>\n\nstatic inline struct fd fdget_pos(int fd)\n{\n\treturn __to_fd(__fdget_pos(fd));\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/unistd.h>\n#include <asm/uaccess.h>\n#include \"internal.h\"\n#include <linux/compat.h>\n#include <linux/splice.h>\n#include <linux/pagemap.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/security.h>\n#include <linux/fsnotify.h>\n#include <linux/aio.h>\n#include <linux/uio.h>\n#include <linux/file.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/slab.h>\n\nstatic long __compat_sys_pwritev64(unsigned long fd,\n\t\t\t\t   const struct compat_iovec __user *vec,\n\t\t\t\t   unsigned long vlen, loff_t pos)\n{\n\tstruct fd f;\n\tssize_t ret;\n\n\tif (pos < 0)\n\t\treturn -EINVAL;\n\tf = fdget(fd);\n\tif (!f.file)\n\t\treturn -EBADF;\n\tret = -ESPIPE;\n\tif (f.file->f_mode & FMODE_PWRITE)\n\t\tret = compat_writev(f.file, vec, vlen, &pos);\n\tfdput(f);\n\treturn ret;\n}"
  },
  {
    "function_name": "compat_writev",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/read_write.c",
    "lines": "1174-1194",
    "snippet": "static size_t compat_writev(struct file *file,\n\t\t\t    const struct compat_iovec __user *vec,\n\t\t\t    unsigned long vlen, loff_t *pos)\n{\n\tssize_t ret = -EBADF;\n\n\tif (!(file->f_mode & FMODE_WRITE))\n\t\tgoto out;\n\n\tret = -EINVAL;\n\tif (!(file->f_mode & FMODE_CAN_WRITE))\n\t\tgoto out;\n\n\tret = compat_do_readv_writev(WRITE, file, vec, vlen, pos);\n\nout:\n\tif (ret > 0)\n\t\tadd_wchar(current, ret);\n\tinc_syscw(current);\n\treturn ret;\n}",
    "includes": [
      "#include <asm/unistd.h>",
      "#include <asm/uaccess.h>",
      "#include \"internal.h\"",
      "#include <linux/compat.h>",
      "#include <linux/splice.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/export.h>",
      "#include <linux/security.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/aio.h>",
      "#include <linux/uio.h>",
      "#include <linux/file.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/stat.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "inc_syscw",
          "args": [
            "current"
          ],
          "line": 1192
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "add_wchar",
          "args": [
            "current",
            "ret"
          ],
          "line": 1191
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "compat_do_readv_writev",
          "args": [
            "WRITE",
            "file",
            "vec",
            "vlen",
            "pos"
          ],
          "line": 1187
        },
        "resolved": true,
        "details": {
          "function_name": "compat_do_readv_writev",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/read_write.c",
          "lines": "1039-1095",
          "snippet": "static ssize_t compat_do_readv_writev(int type, struct file *file,\n\t\t\t       const struct compat_iovec __user *uvector,\n\t\t\t       unsigned long nr_segs, loff_t *pos)\n{\n\tcompat_ssize_t tot_len;\n\tstruct iovec iovstack[UIO_FASTIOV];\n\tstruct iovec *iov = iovstack;\n\tssize_t ret;\n\tio_fn_t fn;\n\tiov_fn_t fnv;\n\titer_fn_t iter_fn;\n\n\tret = compat_rw_copy_check_uvector(type, uvector, nr_segs,\n\t\t\t\t\t       UIO_FASTIOV, iovstack, &iov);\n\tif (ret <= 0)\n\t\tgoto out;\n\n\ttot_len = ret;\n\tret = rw_verify_area(type, file, pos, tot_len);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tfnv = NULL;\n\tif (type == READ) {\n\t\tfn = file->f_op->read;\n\t\tfnv = file->f_op->aio_read;\n\t\titer_fn = file->f_op->read_iter;\n\t} else {\n\t\tfn = (io_fn_t)file->f_op->write;\n\t\tfnv = file->f_op->aio_write;\n\t\titer_fn = file->f_op->write_iter;\n\t\tfile_start_write(file);\n\t}\n\n\tif (iter_fn)\n\t\tret = do_iter_readv_writev(file, type, iov, nr_segs, tot_len,\n\t\t\t\t\t\tpos, iter_fn);\n\telse if (fnv)\n\t\tret = do_sync_readv_writev(file, iov, nr_segs, tot_len,\n\t\t\t\t\t\tpos, fnv);\n\telse\n\t\tret = do_loop_readv_writev(file, iov, nr_segs, pos, fn);\n\n\tif (type != READ)\n\t\tfile_end_write(file);\n\nout:\n\tif (iov != iovstack)\n\t\tkfree(iov);\n\tif ((ret + (type == READ)) > 0) {\n\t\tif (type == READ)\n\t\t\tfsnotify_access(file);\n\t\telse\n\t\t\tfsnotify_modify(file);\n\t}\n\treturn ret;\n}",
          "includes": [
            "#include <asm/unistd.h>",
            "#include <asm/uaccess.h>",
            "#include \"internal.h\"",
            "#include <linux/compat.h>",
            "#include <linux/splice.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/export.h>",
            "#include <linux/security.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/aio.h>",
            "#include <linux/uio.h>",
            "#include <linux/file.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/stat.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/unistd.h>\n#include <asm/uaccess.h>\n#include \"internal.h\"\n#include <linux/compat.h>\n#include <linux/splice.h>\n#include <linux/pagemap.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/security.h>\n#include <linux/fsnotify.h>\n#include <linux/aio.h>\n#include <linux/uio.h>\n#include <linux/file.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/slab.h>\n\nstatic ssize_t compat_do_readv_writev(int type, struct file *file,\n\t\t\t       const struct compat_iovec __user *uvector,\n\t\t\t       unsigned long nr_segs, loff_t *pos)\n{\n\tcompat_ssize_t tot_len;\n\tstruct iovec iovstack[UIO_FASTIOV];\n\tstruct iovec *iov = iovstack;\n\tssize_t ret;\n\tio_fn_t fn;\n\tiov_fn_t fnv;\n\titer_fn_t iter_fn;\n\n\tret = compat_rw_copy_check_uvector(type, uvector, nr_segs,\n\t\t\t\t\t       UIO_FASTIOV, iovstack, &iov);\n\tif (ret <= 0)\n\t\tgoto out;\n\n\ttot_len = ret;\n\tret = rw_verify_area(type, file, pos, tot_len);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tfnv = NULL;\n\tif (type == READ) {\n\t\tfn = file->f_op->read;\n\t\tfnv = file->f_op->aio_read;\n\t\titer_fn = file->f_op->read_iter;\n\t} else {\n\t\tfn = (io_fn_t)file->f_op->write;\n\t\tfnv = file->f_op->aio_write;\n\t\titer_fn = file->f_op->write_iter;\n\t\tfile_start_write(file);\n\t}\n\n\tif (iter_fn)\n\t\tret = do_iter_readv_writev(file, type, iov, nr_segs, tot_len,\n\t\t\t\t\t\tpos, iter_fn);\n\telse if (fnv)\n\t\tret = do_sync_readv_writev(file, iov, nr_segs, tot_len,\n\t\t\t\t\t\tpos, fnv);\n\telse\n\t\tret = do_loop_readv_writev(file, iov, nr_segs, pos, fn);\n\n\tif (type != READ)\n\t\tfile_end_write(file);\n\nout:\n\tif (iov != iovstack)\n\t\tkfree(iov);\n\tif ((ret + (type == READ)) > 0) {\n\t\tif (type == READ)\n\t\t\tfsnotify_access(file);\n\t\telse\n\t\t\tfsnotify_modify(file);\n\t}\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/unistd.h>\n#include <asm/uaccess.h>\n#include \"internal.h\"\n#include <linux/compat.h>\n#include <linux/splice.h>\n#include <linux/pagemap.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/security.h>\n#include <linux/fsnotify.h>\n#include <linux/aio.h>\n#include <linux/uio.h>\n#include <linux/file.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/slab.h>\n\nstatic size_t compat_writev(struct file *file,\n\t\t\t    const struct compat_iovec __user *vec,\n\t\t\t    unsigned long vlen, loff_t *pos)\n{\n\tssize_t ret = -EBADF;\n\n\tif (!(file->f_mode & FMODE_WRITE))\n\t\tgoto out;\n\n\tret = -EINVAL;\n\tif (!(file->f_mode & FMODE_CAN_WRITE))\n\t\tgoto out;\n\n\tret = compat_do_readv_writev(WRITE, file, vec, vlen, pos);\n\nout:\n\tif (ret > 0)\n\t\tadd_wchar(current, ret);\n\tinc_syscw(current);\n\treturn ret;\n}"
  },
  {
    "function_name": "__compat_sys_preadv64",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/read_write.c",
    "lines": "1137-1154",
    "snippet": "static long __compat_sys_preadv64(unsigned long fd,\n\t\t\t\t  const struct compat_iovec __user *vec,\n\t\t\t\t  unsigned long vlen, loff_t pos)\n{\n\tstruct fd f;\n\tssize_t ret;\n\n\tif (pos < 0)\n\t\treturn -EINVAL;\n\tf = fdget(fd);\n\tif (!f.file)\n\t\treturn -EBADF;\n\tret = -ESPIPE;\n\tif (f.file->f_mode & FMODE_PREAD)\n\t\tret = compat_readv(f.file, vec, vlen, &pos);\n\tfdput(f);\n\treturn ret;\n}",
    "includes": [
      "#include <asm/unistd.h>",
      "#include <asm/uaccess.h>",
      "#include \"internal.h\"",
      "#include <linux/compat.h>",
      "#include <linux/splice.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/export.h>",
      "#include <linux/security.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/aio.h>",
      "#include <linux/uio.h>",
      "#include <linux/file.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/stat.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fdput",
          "args": [
            "f"
          ],
          "line": 1152
        },
        "resolved": true,
        "details": {
          "function_name": "fdput_pos",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/read_write.c",
          "lines": "273-278",
          "snippet": "static inline void fdput_pos(struct fd f)\n{\n\tif (f.flags & FDPUT_POS_UNLOCK)\n\t\tmutex_unlock(&f.file->f_pos_lock);\n\tfdput(f);\n}",
          "includes": [
            "#include <asm/unistd.h>",
            "#include <asm/uaccess.h>",
            "#include \"internal.h\"",
            "#include <linux/compat.h>",
            "#include <linux/splice.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/export.h>",
            "#include <linux/security.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/aio.h>",
            "#include <linux/uio.h>",
            "#include <linux/file.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/stat.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/unistd.h>\n#include <asm/uaccess.h>\n#include \"internal.h\"\n#include <linux/compat.h>\n#include <linux/splice.h>\n#include <linux/pagemap.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/security.h>\n#include <linux/fsnotify.h>\n#include <linux/aio.h>\n#include <linux/uio.h>\n#include <linux/file.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/slab.h>\n\nstatic inline void fdput_pos(struct fd f)\n{\n\tif (f.flags & FDPUT_POS_UNLOCK)\n\t\tmutex_unlock(&f.file->f_pos_lock);\n\tfdput(f);\n}"
        }
      },
      {
        "call_info": {
          "callee": "compat_readv",
          "args": [
            "f.file",
            "vec",
            "vlen",
            "&pos"
          ],
          "line": 1151
        },
        "resolved": true,
        "details": {
          "function_name": "compat_readv",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/read_write.c",
          "lines": "1097-1117",
          "snippet": "static size_t compat_readv(struct file *file,\n\t\t\t   const struct compat_iovec __user *vec,\n\t\t\t   unsigned long vlen, loff_t *pos)\n{\n\tssize_t ret = -EBADF;\n\n\tif (!(file->f_mode & FMODE_READ))\n\t\tgoto out;\n\n\tret = -EINVAL;\n\tif (!(file->f_mode & FMODE_CAN_READ))\n\t\tgoto out;\n\n\tret = compat_do_readv_writev(READ, file, vec, vlen, pos);\n\nout:\n\tif (ret > 0)\n\t\tadd_rchar(current, ret);\n\tinc_syscr(current);\n\treturn ret;\n}",
          "includes": [
            "#include <asm/unistd.h>",
            "#include <asm/uaccess.h>",
            "#include \"internal.h\"",
            "#include <linux/compat.h>",
            "#include <linux/splice.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/export.h>",
            "#include <linux/security.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/aio.h>",
            "#include <linux/uio.h>",
            "#include <linux/file.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/stat.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/unistd.h>\n#include <asm/uaccess.h>\n#include \"internal.h\"\n#include <linux/compat.h>\n#include <linux/splice.h>\n#include <linux/pagemap.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/security.h>\n#include <linux/fsnotify.h>\n#include <linux/aio.h>\n#include <linux/uio.h>\n#include <linux/file.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/slab.h>\n\nstatic size_t compat_readv(struct file *file,\n\t\t\t   const struct compat_iovec __user *vec,\n\t\t\t   unsigned long vlen, loff_t *pos)\n{\n\tssize_t ret = -EBADF;\n\n\tif (!(file->f_mode & FMODE_READ))\n\t\tgoto out;\n\n\tret = -EINVAL;\n\tif (!(file->f_mode & FMODE_CAN_READ))\n\t\tgoto out;\n\n\tret = compat_do_readv_writev(READ, file, vec, vlen, pos);\n\nout:\n\tif (ret > 0)\n\t\tadd_rchar(current, ret);\n\tinc_syscr(current);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fdget",
          "args": [
            "fd"
          ],
          "line": 1146
        },
        "resolved": true,
        "details": {
          "function_name": "fdget_pos",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/read_write.c",
          "lines": "268-271",
          "snippet": "static inline struct fd fdget_pos(int fd)\n{\n\treturn __to_fd(__fdget_pos(fd));\n}",
          "includes": [
            "#include <asm/unistd.h>",
            "#include <asm/uaccess.h>",
            "#include \"internal.h\"",
            "#include <linux/compat.h>",
            "#include <linux/splice.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/export.h>",
            "#include <linux/security.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/aio.h>",
            "#include <linux/uio.h>",
            "#include <linux/file.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/stat.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/unistd.h>\n#include <asm/uaccess.h>\n#include \"internal.h\"\n#include <linux/compat.h>\n#include <linux/splice.h>\n#include <linux/pagemap.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/security.h>\n#include <linux/fsnotify.h>\n#include <linux/aio.h>\n#include <linux/uio.h>\n#include <linux/file.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/slab.h>\n\nstatic inline struct fd fdget_pos(int fd)\n{\n\treturn __to_fd(__fdget_pos(fd));\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/unistd.h>\n#include <asm/uaccess.h>\n#include \"internal.h\"\n#include <linux/compat.h>\n#include <linux/splice.h>\n#include <linux/pagemap.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/security.h>\n#include <linux/fsnotify.h>\n#include <linux/aio.h>\n#include <linux/uio.h>\n#include <linux/file.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/slab.h>\n\nstatic long __compat_sys_preadv64(unsigned long fd,\n\t\t\t\t  const struct compat_iovec __user *vec,\n\t\t\t\t  unsigned long vlen, loff_t pos)\n{\n\tstruct fd f;\n\tssize_t ret;\n\n\tif (pos < 0)\n\t\treturn -EINVAL;\n\tf = fdget(fd);\n\tif (!f.file)\n\t\treturn -EBADF;\n\tret = -ESPIPE;\n\tif (f.file->f_mode & FMODE_PREAD)\n\t\tret = compat_readv(f.file, vec, vlen, &pos);\n\tfdput(f);\n\treturn ret;\n}"
  },
  {
    "function_name": "compat_readv",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/read_write.c",
    "lines": "1097-1117",
    "snippet": "static size_t compat_readv(struct file *file,\n\t\t\t   const struct compat_iovec __user *vec,\n\t\t\t   unsigned long vlen, loff_t *pos)\n{\n\tssize_t ret = -EBADF;\n\n\tif (!(file->f_mode & FMODE_READ))\n\t\tgoto out;\n\n\tret = -EINVAL;\n\tif (!(file->f_mode & FMODE_CAN_READ))\n\t\tgoto out;\n\n\tret = compat_do_readv_writev(READ, file, vec, vlen, pos);\n\nout:\n\tif (ret > 0)\n\t\tadd_rchar(current, ret);\n\tinc_syscr(current);\n\treturn ret;\n}",
    "includes": [
      "#include <asm/unistd.h>",
      "#include <asm/uaccess.h>",
      "#include \"internal.h\"",
      "#include <linux/compat.h>",
      "#include <linux/splice.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/export.h>",
      "#include <linux/security.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/aio.h>",
      "#include <linux/uio.h>",
      "#include <linux/file.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/stat.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "inc_syscr",
          "args": [
            "current"
          ],
          "line": 1115
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "add_rchar",
          "args": [
            "current",
            "ret"
          ],
          "line": 1114
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "compat_do_readv_writev",
          "args": [
            "READ",
            "file",
            "vec",
            "vlen",
            "pos"
          ],
          "line": 1110
        },
        "resolved": true,
        "details": {
          "function_name": "compat_do_readv_writev",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/read_write.c",
          "lines": "1039-1095",
          "snippet": "static ssize_t compat_do_readv_writev(int type, struct file *file,\n\t\t\t       const struct compat_iovec __user *uvector,\n\t\t\t       unsigned long nr_segs, loff_t *pos)\n{\n\tcompat_ssize_t tot_len;\n\tstruct iovec iovstack[UIO_FASTIOV];\n\tstruct iovec *iov = iovstack;\n\tssize_t ret;\n\tio_fn_t fn;\n\tiov_fn_t fnv;\n\titer_fn_t iter_fn;\n\n\tret = compat_rw_copy_check_uvector(type, uvector, nr_segs,\n\t\t\t\t\t       UIO_FASTIOV, iovstack, &iov);\n\tif (ret <= 0)\n\t\tgoto out;\n\n\ttot_len = ret;\n\tret = rw_verify_area(type, file, pos, tot_len);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tfnv = NULL;\n\tif (type == READ) {\n\t\tfn = file->f_op->read;\n\t\tfnv = file->f_op->aio_read;\n\t\titer_fn = file->f_op->read_iter;\n\t} else {\n\t\tfn = (io_fn_t)file->f_op->write;\n\t\tfnv = file->f_op->aio_write;\n\t\titer_fn = file->f_op->write_iter;\n\t\tfile_start_write(file);\n\t}\n\n\tif (iter_fn)\n\t\tret = do_iter_readv_writev(file, type, iov, nr_segs, tot_len,\n\t\t\t\t\t\tpos, iter_fn);\n\telse if (fnv)\n\t\tret = do_sync_readv_writev(file, iov, nr_segs, tot_len,\n\t\t\t\t\t\tpos, fnv);\n\telse\n\t\tret = do_loop_readv_writev(file, iov, nr_segs, pos, fn);\n\n\tif (type != READ)\n\t\tfile_end_write(file);\n\nout:\n\tif (iov != iovstack)\n\t\tkfree(iov);\n\tif ((ret + (type == READ)) > 0) {\n\t\tif (type == READ)\n\t\t\tfsnotify_access(file);\n\t\telse\n\t\t\tfsnotify_modify(file);\n\t}\n\treturn ret;\n}",
          "includes": [
            "#include <asm/unistd.h>",
            "#include <asm/uaccess.h>",
            "#include \"internal.h\"",
            "#include <linux/compat.h>",
            "#include <linux/splice.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/export.h>",
            "#include <linux/security.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/aio.h>",
            "#include <linux/uio.h>",
            "#include <linux/file.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/stat.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/unistd.h>\n#include <asm/uaccess.h>\n#include \"internal.h\"\n#include <linux/compat.h>\n#include <linux/splice.h>\n#include <linux/pagemap.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/security.h>\n#include <linux/fsnotify.h>\n#include <linux/aio.h>\n#include <linux/uio.h>\n#include <linux/file.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/slab.h>\n\nstatic ssize_t compat_do_readv_writev(int type, struct file *file,\n\t\t\t       const struct compat_iovec __user *uvector,\n\t\t\t       unsigned long nr_segs, loff_t *pos)\n{\n\tcompat_ssize_t tot_len;\n\tstruct iovec iovstack[UIO_FASTIOV];\n\tstruct iovec *iov = iovstack;\n\tssize_t ret;\n\tio_fn_t fn;\n\tiov_fn_t fnv;\n\titer_fn_t iter_fn;\n\n\tret = compat_rw_copy_check_uvector(type, uvector, nr_segs,\n\t\t\t\t\t       UIO_FASTIOV, iovstack, &iov);\n\tif (ret <= 0)\n\t\tgoto out;\n\n\ttot_len = ret;\n\tret = rw_verify_area(type, file, pos, tot_len);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tfnv = NULL;\n\tif (type == READ) {\n\t\tfn = file->f_op->read;\n\t\tfnv = file->f_op->aio_read;\n\t\titer_fn = file->f_op->read_iter;\n\t} else {\n\t\tfn = (io_fn_t)file->f_op->write;\n\t\tfnv = file->f_op->aio_write;\n\t\titer_fn = file->f_op->write_iter;\n\t\tfile_start_write(file);\n\t}\n\n\tif (iter_fn)\n\t\tret = do_iter_readv_writev(file, type, iov, nr_segs, tot_len,\n\t\t\t\t\t\tpos, iter_fn);\n\telse if (fnv)\n\t\tret = do_sync_readv_writev(file, iov, nr_segs, tot_len,\n\t\t\t\t\t\tpos, fnv);\n\telse\n\t\tret = do_loop_readv_writev(file, iov, nr_segs, pos, fn);\n\n\tif (type != READ)\n\t\tfile_end_write(file);\n\nout:\n\tif (iov != iovstack)\n\t\tkfree(iov);\n\tif ((ret + (type == READ)) > 0) {\n\t\tif (type == READ)\n\t\t\tfsnotify_access(file);\n\t\telse\n\t\t\tfsnotify_modify(file);\n\t}\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/unistd.h>\n#include <asm/uaccess.h>\n#include \"internal.h\"\n#include <linux/compat.h>\n#include <linux/splice.h>\n#include <linux/pagemap.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/security.h>\n#include <linux/fsnotify.h>\n#include <linux/aio.h>\n#include <linux/uio.h>\n#include <linux/file.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/slab.h>\n\nstatic size_t compat_readv(struct file *file,\n\t\t\t   const struct compat_iovec __user *vec,\n\t\t\t   unsigned long vlen, loff_t *pos)\n{\n\tssize_t ret = -EBADF;\n\n\tif (!(file->f_mode & FMODE_READ))\n\t\tgoto out;\n\n\tret = -EINVAL;\n\tif (!(file->f_mode & FMODE_CAN_READ))\n\t\tgoto out;\n\n\tret = compat_do_readv_writev(READ, file, vec, vlen, pos);\n\nout:\n\tif (ret > 0)\n\t\tadd_rchar(current, ret);\n\tinc_syscr(current);\n\treturn ret;\n}"
  },
  {
    "function_name": "compat_do_readv_writev",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/read_write.c",
    "lines": "1039-1095",
    "snippet": "static ssize_t compat_do_readv_writev(int type, struct file *file,\n\t\t\t       const struct compat_iovec __user *uvector,\n\t\t\t       unsigned long nr_segs, loff_t *pos)\n{\n\tcompat_ssize_t tot_len;\n\tstruct iovec iovstack[UIO_FASTIOV];\n\tstruct iovec *iov = iovstack;\n\tssize_t ret;\n\tio_fn_t fn;\n\tiov_fn_t fnv;\n\titer_fn_t iter_fn;\n\n\tret = compat_rw_copy_check_uvector(type, uvector, nr_segs,\n\t\t\t\t\t       UIO_FASTIOV, iovstack, &iov);\n\tif (ret <= 0)\n\t\tgoto out;\n\n\ttot_len = ret;\n\tret = rw_verify_area(type, file, pos, tot_len);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tfnv = NULL;\n\tif (type == READ) {\n\t\tfn = file->f_op->read;\n\t\tfnv = file->f_op->aio_read;\n\t\titer_fn = file->f_op->read_iter;\n\t} else {\n\t\tfn = (io_fn_t)file->f_op->write;\n\t\tfnv = file->f_op->aio_write;\n\t\titer_fn = file->f_op->write_iter;\n\t\tfile_start_write(file);\n\t}\n\n\tif (iter_fn)\n\t\tret = do_iter_readv_writev(file, type, iov, nr_segs, tot_len,\n\t\t\t\t\t\tpos, iter_fn);\n\telse if (fnv)\n\t\tret = do_sync_readv_writev(file, iov, nr_segs, tot_len,\n\t\t\t\t\t\tpos, fnv);\n\telse\n\t\tret = do_loop_readv_writev(file, iov, nr_segs, pos, fn);\n\n\tif (type != READ)\n\t\tfile_end_write(file);\n\nout:\n\tif (iov != iovstack)\n\t\tkfree(iov);\n\tif ((ret + (type == READ)) > 0) {\n\t\tif (type == READ)\n\t\t\tfsnotify_access(file);\n\t\telse\n\t\t\tfsnotify_modify(file);\n\t}\n\treturn ret;\n}",
    "includes": [
      "#include <asm/unistd.h>",
      "#include <asm/uaccess.h>",
      "#include \"internal.h\"",
      "#include <linux/compat.h>",
      "#include <linux/splice.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/export.h>",
      "#include <linux/security.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/aio.h>",
      "#include <linux/uio.h>",
      "#include <linux/file.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/stat.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fsnotify_modify",
          "args": [
            "file"
          ],
          "line": 1092
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fsnotify_access",
          "args": [
            "file"
          ],
          "line": 1090
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "iov"
          ],
          "line": 1087
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "file_end_write",
          "args": [
            "file"
          ],
          "line": 1083
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "do_loop_readv_writev",
          "args": [
            "file",
            "iov",
            "nr_segs",
            "pos",
            "fn"
          ],
          "line": 1080
        },
        "resolved": true,
        "details": {
          "function_name": "do_loop_readv_writev",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/read_write.c",
          "lines": "750-779",
          "snippet": "static ssize_t do_loop_readv_writev(struct file *filp, struct iovec *iov,\n\t\tunsigned long nr_segs, loff_t *ppos, io_fn_t fn)\n{\n\tstruct iovec *vector = iov;\n\tssize_t ret = 0;\n\n\twhile (nr_segs > 0) {\n\t\tvoid __user *base;\n\t\tsize_t len;\n\t\tssize_t nr;\n\n\t\tbase = vector->iov_base;\n\t\tlen = vector->iov_len;\n\t\tvector++;\n\t\tnr_segs--;\n\n\t\tnr = fn(filp, base, len, ppos);\n\n\t\tif (nr < 0) {\n\t\t\tif (!ret)\n\t\t\t\tret = nr;\n\t\t\tbreak;\n\t\t}\n\t\tret += nr;\n\t\tif (nr != len)\n\t\t\tbreak;\n\t}\n\n\treturn ret;\n}",
          "includes": [
            "#include <asm/unistd.h>",
            "#include <asm/uaccess.h>",
            "#include \"internal.h\"",
            "#include <linux/compat.h>",
            "#include <linux/splice.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/export.h>",
            "#include <linux/security.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/aio.h>",
            "#include <linux/uio.h>",
            "#include <linux/file.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/stat.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/unistd.h>\n#include <asm/uaccess.h>\n#include \"internal.h\"\n#include <linux/compat.h>\n#include <linux/splice.h>\n#include <linux/pagemap.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/security.h>\n#include <linux/fsnotify.h>\n#include <linux/aio.h>\n#include <linux/uio.h>\n#include <linux/file.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/slab.h>\n\nstatic ssize_t do_loop_readv_writev(struct file *filp, struct iovec *iov,\n\t\tunsigned long nr_segs, loff_t *ppos, io_fn_t fn)\n{\n\tstruct iovec *vector = iov;\n\tssize_t ret = 0;\n\n\twhile (nr_segs > 0) {\n\t\tvoid __user *base;\n\t\tsize_t len;\n\t\tssize_t nr;\n\n\t\tbase = vector->iov_base;\n\t\tlen = vector->iov_len;\n\t\tvector++;\n\t\tnr_segs--;\n\n\t\tnr = fn(filp, base, len, ppos);\n\n\t\tif (nr < 0) {\n\t\t\tif (!ret)\n\t\t\t\tret = nr;\n\t\t\tbreak;\n\t\t}\n\t\tret += nr;\n\t\tif (nr != len)\n\t\t\tbreak;\n\t}\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "do_sync_readv_writev",
          "args": [
            "file",
            "iov",
            "nr_segs",
            "tot_len",
            "pos",
            "fnv"
          ],
          "line": 1077
        },
        "resolved": true,
        "details": {
          "function_name": "do_sync_readv_writev",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/read_write.c",
          "lines": "732-747",
          "snippet": "static ssize_t do_sync_readv_writev(struct file *filp, const struct iovec *iov,\n\t\tunsigned long nr_segs, size_t len, loff_t *ppos, iov_fn_t fn)\n{\n\tstruct kiocb kiocb;\n\tssize_t ret;\n\n\tinit_sync_kiocb(&kiocb, filp);\n\tkiocb.ki_pos = *ppos;\n\tkiocb.ki_nbytes = len;\n\n\tret = fn(&kiocb, iov, nr_segs, kiocb.ki_pos);\n\tif (ret == -EIOCBQUEUED)\n\t\tret = wait_on_sync_kiocb(&kiocb);\n\t*ppos = kiocb.ki_pos;\n\treturn ret;\n}",
          "includes": [
            "#include <asm/unistd.h>",
            "#include <asm/uaccess.h>",
            "#include \"internal.h\"",
            "#include <linux/compat.h>",
            "#include <linux/splice.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/export.h>",
            "#include <linux/security.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/aio.h>",
            "#include <linux/uio.h>",
            "#include <linux/file.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/stat.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/unistd.h>\n#include <asm/uaccess.h>\n#include \"internal.h\"\n#include <linux/compat.h>\n#include <linux/splice.h>\n#include <linux/pagemap.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/security.h>\n#include <linux/fsnotify.h>\n#include <linux/aio.h>\n#include <linux/uio.h>\n#include <linux/file.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/slab.h>\n\nstatic ssize_t do_sync_readv_writev(struct file *filp, const struct iovec *iov,\n\t\tunsigned long nr_segs, size_t len, loff_t *ppos, iov_fn_t fn)\n{\n\tstruct kiocb kiocb;\n\tssize_t ret;\n\n\tinit_sync_kiocb(&kiocb, filp);\n\tkiocb.ki_pos = *ppos;\n\tkiocb.ki_nbytes = len;\n\n\tret = fn(&kiocb, iov, nr_segs, kiocb.ki_pos);\n\tif (ret == -EIOCBQUEUED)\n\t\tret = wait_on_sync_kiocb(&kiocb);\n\t*ppos = kiocb.ki_pos;\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "do_iter_readv_writev",
          "args": [
            "file",
            "type",
            "iov",
            "nr_segs",
            "tot_len",
            "pos",
            "iter_fn"
          ],
          "line": 1074
        },
        "resolved": true,
        "details": {
          "function_name": "do_iter_readv_writev",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/read_write.c",
          "lines": "713-730",
          "snippet": "static ssize_t do_iter_readv_writev(struct file *filp, int rw, const struct iovec *iov,\n\t\tunsigned long nr_segs, size_t len, loff_t *ppos, iter_fn_t fn)\n{\n\tstruct kiocb kiocb;\n\tstruct iov_iter iter;\n\tssize_t ret;\n\n\tinit_sync_kiocb(&kiocb, filp);\n\tkiocb.ki_pos = *ppos;\n\tkiocb.ki_nbytes = len;\n\n\tiov_iter_init(&iter, rw, iov, nr_segs, len);\n\tret = fn(&kiocb, &iter);\n\tif (ret == -EIOCBQUEUED)\n\t\tret = wait_on_sync_kiocb(&kiocb);\n\t*ppos = kiocb.ki_pos;\n\treturn ret;\n}",
          "includes": [
            "#include <asm/unistd.h>",
            "#include <asm/uaccess.h>",
            "#include \"internal.h\"",
            "#include <linux/compat.h>",
            "#include <linux/splice.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/export.h>",
            "#include <linux/security.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/aio.h>",
            "#include <linux/uio.h>",
            "#include <linux/file.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/stat.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/unistd.h>\n#include <asm/uaccess.h>\n#include \"internal.h\"\n#include <linux/compat.h>\n#include <linux/splice.h>\n#include <linux/pagemap.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/security.h>\n#include <linux/fsnotify.h>\n#include <linux/aio.h>\n#include <linux/uio.h>\n#include <linux/file.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/slab.h>\n\nstatic ssize_t do_iter_readv_writev(struct file *filp, int rw, const struct iovec *iov,\n\t\tunsigned long nr_segs, size_t len, loff_t *ppos, iter_fn_t fn)\n{\n\tstruct kiocb kiocb;\n\tstruct iov_iter iter;\n\tssize_t ret;\n\n\tinit_sync_kiocb(&kiocb, filp);\n\tkiocb.ki_pos = *ppos;\n\tkiocb.ki_nbytes = len;\n\n\tiov_iter_init(&iter, rw, iov, nr_segs, len);\n\tret = fn(&kiocb, &iter);\n\tif (ret == -EIOCBQUEUED)\n\t\tret = wait_on_sync_kiocb(&kiocb);\n\t*ppos = kiocb.ki_pos;\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "file_start_write",
          "args": [
            "file"
          ],
          "line": 1070
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rw_verify_area",
          "args": [
            "type",
            "file",
            "pos",
            "tot_len"
          ],
          "line": 1057
        },
        "resolved": true,
        "details": {
          "function_name": "rw_verify_area",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/read_write.c",
          "lines": "387-419",
          "snippet": "int rw_verify_area(int read_write, struct file *file, const loff_t *ppos, size_t count)\n{\n\tstruct inode *inode;\n\tloff_t pos;\n\tint retval = -EINVAL;\n\n\tinode = file_inode(file);\n\tif (unlikely((ssize_t) count < 0))\n\t\treturn retval;\n\tpos = *ppos;\n\tif (unlikely(pos < 0)) {\n\t\tif (!unsigned_offsets(file))\n\t\t\treturn retval;\n\t\tif (count >= -pos) /* both values are in 0..LLONG_MAX */\n\t\t\treturn -EOVERFLOW;\n\t} else if (unlikely((loff_t) (pos + count) < 0)) {\n\t\tif (!unsigned_offsets(file))\n\t\t\treturn retval;\n\t}\n\n\tif (unlikely(inode->i_flctx && mandatory_lock(inode))) {\n\t\tretval = locks_mandatory_area(\n\t\t\tread_write == READ ? FLOCK_VERIFY_READ : FLOCK_VERIFY_WRITE,\n\t\t\tinode, file, pos, count);\n\t\tif (retval < 0)\n\t\t\treturn retval;\n\t}\n\tretval = security_file_permission(file,\n\t\t\t\tread_write == READ ? MAY_READ : MAY_WRITE);\n\tif (retval)\n\t\treturn retval;\n\treturn count > MAX_RW_COUNT ? MAX_RW_COUNT : count;\n}",
          "includes": [
            "#include <asm/unistd.h>",
            "#include <asm/uaccess.h>",
            "#include \"internal.h\"",
            "#include <linux/compat.h>",
            "#include <linux/splice.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/export.h>",
            "#include <linux/security.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/aio.h>",
            "#include <linux/uio.h>",
            "#include <linux/file.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/stat.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/unistd.h>\n#include <asm/uaccess.h>\n#include \"internal.h\"\n#include <linux/compat.h>\n#include <linux/splice.h>\n#include <linux/pagemap.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/security.h>\n#include <linux/fsnotify.h>\n#include <linux/aio.h>\n#include <linux/uio.h>\n#include <linux/file.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/slab.h>\n\nint rw_verify_area(int read_write, struct file *file, const loff_t *ppos, size_t count)\n{\n\tstruct inode *inode;\n\tloff_t pos;\n\tint retval = -EINVAL;\n\n\tinode = file_inode(file);\n\tif (unlikely((ssize_t) count < 0))\n\t\treturn retval;\n\tpos = *ppos;\n\tif (unlikely(pos < 0)) {\n\t\tif (!unsigned_offsets(file))\n\t\t\treturn retval;\n\t\tif (count >= -pos) /* both values are in 0..LLONG_MAX */\n\t\t\treturn -EOVERFLOW;\n\t} else if (unlikely((loff_t) (pos + count) < 0)) {\n\t\tif (!unsigned_offsets(file))\n\t\t\treturn retval;\n\t}\n\n\tif (unlikely(inode->i_flctx && mandatory_lock(inode))) {\n\t\tretval = locks_mandatory_area(\n\t\t\tread_write == READ ? FLOCK_VERIFY_READ : FLOCK_VERIFY_WRITE,\n\t\t\tinode, file, pos, count);\n\t\tif (retval < 0)\n\t\t\treturn retval;\n\t}\n\tretval = security_file_permission(file,\n\t\t\t\tread_write == READ ? MAY_READ : MAY_WRITE);\n\tif (retval)\n\t\treturn retval;\n\treturn count > MAX_RW_COUNT ? MAX_RW_COUNT : count;\n}"
        }
      },
      {
        "call_info": {
          "callee": "compat_rw_copy_check_uvector",
          "args": [
            "type",
            "uvector",
            "nr_segs",
            "UIO_FASTIOV",
            "iovstack",
            "&iov"
          ],
          "line": 1051
        },
        "resolved": true,
        "details": {
          "function_name": "compat_rw_copy_check_uvector",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/compat.c",
          "lines": "546-617",
          "snippet": "ssize_t compat_rw_copy_check_uvector(int type,\n\t\tconst struct compat_iovec __user *uvector, unsigned long nr_segs,\n\t\tunsigned long fast_segs, struct iovec *fast_pointer,\n\t\tstruct iovec **ret_pointer)\n{\n\tcompat_ssize_t tot_len;\n\tstruct iovec *iov = *ret_pointer = fast_pointer;\n\tssize_t ret = 0;\n\tint seg;\n\n\t/*\n\t * SuS says \"The readv() function *may* fail if the iovcnt argument\n\t * was less than or equal to 0, or greater than {IOV_MAX}.  Linux has\n\t * traditionally returned zero for zero segments, so...\n\t */\n\tif (nr_segs == 0)\n\t\tgoto out;\n\n\tret = -EINVAL;\n\tif (nr_segs > UIO_MAXIOV || nr_segs < 0)\n\t\tgoto out;\n\tif (nr_segs > fast_segs) {\n\t\tret = -ENOMEM;\n\t\tiov = kmalloc(nr_segs*sizeof(struct iovec), GFP_KERNEL);\n\t\tif (iov == NULL)\n\t\t\tgoto out;\n\t}\n\t*ret_pointer = iov;\n\n\tret = -EFAULT;\n\tif (!access_ok(VERIFY_READ, uvector, nr_segs*sizeof(*uvector)))\n\t\tgoto out;\n\n\t/*\n\t * Single unix specification:\n\t * We should -EINVAL if an element length is not >= 0 and fitting an\n\t * ssize_t.\n\t *\n\t * In Linux, the total length is limited to MAX_RW_COUNT, there is\n\t * no overflow possibility.\n\t */\n\ttot_len = 0;\n\tret = -EINVAL;\n\tfor (seg = 0; seg < nr_segs; seg++) {\n\t\tcompat_uptr_t buf;\n\t\tcompat_ssize_t len;\n\n\t\tif (__get_user(len, &uvector->iov_len) ||\n\t\t   __get_user(buf, &uvector->iov_base)) {\n\t\t\tret = -EFAULT;\n\t\t\tgoto out;\n\t\t}\n\t\tif (len < 0)\t/* size_t not fitting in compat_ssize_t .. */\n\t\t\tgoto out;\n\t\tif (type >= 0 &&\n\t\t    !access_ok(vrfy_dir(type), compat_ptr(buf), len)) {\n\t\t\tret = -EFAULT;\n\t\t\tgoto out;\n\t\t}\n\t\tif (len > MAX_RW_COUNT - tot_len)\n\t\t\tlen = MAX_RW_COUNT - tot_len;\n\t\ttot_len += len;\n\t\tiov->iov_base = compat_ptr(buf);\n\t\tiov->iov_len = (compat_size_t) len;\n\t\tuvector++;\n\t\tiov++;\n\t}\n\tret = tot_len;\n\nout:\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/ioctls.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/aio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/mm.h>",
            "#include <linux/poll.h>",
            "#include <linux/signal.h>",
            "#include <linux/highmem.h>",
            "#include <linux/security.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/personality.h>",
            "#include <linux/highuid.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/dirent.h>",
            "#include <linux/ctype.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/nfs4_mount.h>",
            "#include <linux/ncp_mount.h>",
            "#include <linux/init.h>",
            "#include <linux/ioctl.h>",
            "#include <linux/vfs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/namei.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/errno.h>",
            "#include <linux/compat.h>",
            "#include <linux/linkage.h>",
            "#include <linux/kernel.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/ioctls.h>\n#include <asm/mmu_context.h>\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/fs_struct.h>\n#include <linux/mm.h>\n#include <linux/poll.h>\n#include <linux/signal.h>\n#include <linux/highmem.h>\n#include <linux/security.h>\n#include <linux/tsacct_kern.h>\n#include <linux/rwsem.h>\n#include <linux/personality.h>\n#include <linux/highuid.h>\n#include <linux/fsnotify.h>\n#include <linux/dirent.h>\n#include <linux/ctype.h>\n#include <linux/syscalls.h>\n#include <linux/nfs4_mount.h>\n#include <linux/ncp_mount.h>\n#include <linux/init.h>\n#include <linux/ioctl.h>\n#include <linux/vfs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/namei.h>\n#include <linux/fcntl.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <linux/compat.h>\n#include <linux/linkage.h>\n#include <linux/kernel.h>\n#include <linux/stddef.h>\n\nssize_t compat_rw_copy_check_uvector(int type,\n\t\tconst struct compat_iovec __user *uvector, unsigned long nr_segs,\n\t\tunsigned long fast_segs, struct iovec *fast_pointer,\n\t\tstruct iovec **ret_pointer)\n{\n\tcompat_ssize_t tot_len;\n\tstruct iovec *iov = *ret_pointer = fast_pointer;\n\tssize_t ret = 0;\n\tint seg;\n\n\t/*\n\t * SuS says \"The readv() function *may* fail if the iovcnt argument\n\t * was less than or equal to 0, or greater than {IOV_MAX}.  Linux has\n\t * traditionally returned zero for zero segments, so...\n\t */\n\tif (nr_segs == 0)\n\t\tgoto out;\n\n\tret = -EINVAL;\n\tif (nr_segs > UIO_MAXIOV || nr_segs < 0)\n\t\tgoto out;\n\tif (nr_segs > fast_segs) {\n\t\tret = -ENOMEM;\n\t\tiov = kmalloc(nr_segs*sizeof(struct iovec), GFP_KERNEL);\n\t\tif (iov == NULL)\n\t\t\tgoto out;\n\t}\n\t*ret_pointer = iov;\n\n\tret = -EFAULT;\n\tif (!access_ok(VERIFY_READ, uvector, nr_segs*sizeof(*uvector)))\n\t\tgoto out;\n\n\t/*\n\t * Single unix specification:\n\t * We should -EINVAL if an element length is not >= 0 and fitting an\n\t * ssize_t.\n\t *\n\t * In Linux, the total length is limited to MAX_RW_COUNT, there is\n\t * no overflow possibility.\n\t */\n\ttot_len = 0;\n\tret = -EINVAL;\n\tfor (seg = 0; seg < nr_segs; seg++) {\n\t\tcompat_uptr_t buf;\n\t\tcompat_ssize_t len;\n\n\t\tif (__get_user(len, &uvector->iov_len) ||\n\t\t   __get_user(buf, &uvector->iov_base)) {\n\t\t\tret = -EFAULT;\n\t\t\tgoto out;\n\t\t}\n\t\tif (len < 0)\t/* size_t not fitting in compat_ssize_t .. */\n\t\t\tgoto out;\n\t\tif (type >= 0 &&\n\t\t    !access_ok(vrfy_dir(type), compat_ptr(buf), len)) {\n\t\t\tret = -EFAULT;\n\t\t\tgoto out;\n\t\t}\n\t\tif (len > MAX_RW_COUNT - tot_len)\n\t\t\tlen = MAX_RW_COUNT - tot_len;\n\t\ttot_len += len;\n\t\tiov->iov_base = compat_ptr(buf);\n\t\tiov->iov_len = (compat_size_t) len;\n\t\tuvector++;\n\t\tiov++;\n\t}\n\tret = tot_len;\n\nout:\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/unistd.h>\n#include <asm/uaccess.h>\n#include \"internal.h\"\n#include <linux/compat.h>\n#include <linux/splice.h>\n#include <linux/pagemap.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/security.h>\n#include <linux/fsnotify.h>\n#include <linux/aio.h>\n#include <linux/uio.h>\n#include <linux/file.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/slab.h>\n\nstatic ssize_t compat_do_readv_writev(int type, struct file *file,\n\t\t\t       const struct compat_iovec __user *uvector,\n\t\t\t       unsigned long nr_segs, loff_t *pos)\n{\n\tcompat_ssize_t tot_len;\n\tstruct iovec iovstack[UIO_FASTIOV];\n\tstruct iovec *iov = iovstack;\n\tssize_t ret;\n\tio_fn_t fn;\n\tiov_fn_t fnv;\n\titer_fn_t iter_fn;\n\n\tret = compat_rw_copy_check_uvector(type, uvector, nr_segs,\n\t\t\t\t\t       UIO_FASTIOV, iovstack, &iov);\n\tif (ret <= 0)\n\t\tgoto out;\n\n\ttot_len = ret;\n\tret = rw_verify_area(type, file, pos, tot_len);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tfnv = NULL;\n\tif (type == READ) {\n\t\tfn = file->f_op->read;\n\t\tfnv = file->f_op->aio_read;\n\t\titer_fn = file->f_op->read_iter;\n\t} else {\n\t\tfn = (io_fn_t)file->f_op->write;\n\t\tfnv = file->f_op->aio_write;\n\t\titer_fn = file->f_op->write_iter;\n\t\tfile_start_write(file);\n\t}\n\n\tif (iter_fn)\n\t\tret = do_iter_readv_writev(file, type, iov, nr_segs, tot_len,\n\t\t\t\t\t\tpos, iter_fn);\n\telse if (fnv)\n\t\tret = do_sync_readv_writev(file, iov, nr_segs, tot_len,\n\t\t\t\t\t\tpos, fnv);\n\telse\n\t\tret = do_loop_readv_writev(file, iov, nr_segs, pos, fn);\n\n\tif (type != READ)\n\t\tfile_end_write(file);\n\nout:\n\tif (iov != iovstack)\n\t\tkfree(iov);\n\tif ((ret + (type == READ)) > 0) {\n\t\tif (type == READ)\n\t\t\tfsnotify_access(file);\n\t\telse\n\t\t\tfsnotify_modify(file);\n\t}\n\treturn ret;\n}"
  },
  {
    "function_name": "pos_from_hilo",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/read_write.c",
    "lines": "983-987",
    "snippet": "static inline loff_t pos_from_hilo(unsigned long high, unsigned long low)\n{\n#define HALF_LONG_BITS (BITS_PER_LONG / 2)\n\treturn (((loff_t)high << HALF_LONG_BITS) << HALF_LONG_BITS) | low;\n}",
    "includes": [
      "#include <asm/unistd.h>",
      "#include <asm/uaccess.h>",
      "#include \"internal.h\"",
      "#include <linux/compat.h>",
      "#include <linux/splice.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/export.h>",
      "#include <linux/security.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/aio.h>",
      "#include <linux/uio.h>",
      "#include <linux/file.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/stat.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [
      "#define HALF_LONG_BITS (BITS_PER_LONG / 2)"
    ],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <asm/unistd.h>\n#include <asm/uaccess.h>\n#include \"internal.h\"\n#include <linux/compat.h>\n#include <linux/splice.h>\n#include <linux/pagemap.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/security.h>\n#include <linux/fsnotify.h>\n#include <linux/aio.h>\n#include <linux/uio.h>\n#include <linux/file.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/slab.h>\n\n#define HALF_LONG_BITS (BITS_PER_LONG / 2)\n\nstatic inline loff_t pos_from_hilo(unsigned long high, unsigned long low)\n{\n#define HALF_LONG_BITS (BITS_PER_LONG / 2)\n\treturn (((loff_t)high << HALF_LONG_BITS) << HALF_LONG_BITS) | low;\n}"
  },
  {
    "function_name": "vfs_writev",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/read_write.c",
    "lines": "930-939",
    "snippet": "ssize_t vfs_writev(struct file *file, const struct iovec __user *vec,\n\t\t   unsigned long vlen, loff_t *pos)\n{\n\tif (!(file->f_mode & FMODE_WRITE))\n\t\treturn -EBADF;\n\tif (!(file->f_mode & FMODE_CAN_WRITE))\n\t\treturn -EINVAL;\n\n\treturn do_readv_writev(WRITE, file, vec, vlen, pos);\n}",
    "includes": [
      "#include <asm/unistd.h>",
      "#include <asm/uaccess.h>",
      "#include \"internal.h\"",
      "#include <linux/compat.h>",
      "#include <linux/splice.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/export.h>",
      "#include <linux/security.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/aio.h>",
      "#include <linux/uio.h>",
      "#include <linux/file.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/stat.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "do_readv_writev",
          "args": [
            "WRITE",
            "file",
            "vec",
            "vlen",
            "pos"
          ],
          "line": 938
        },
        "resolved": true,
        "details": {
          "function_name": "compat_do_readv_writev",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/read_write.c",
          "lines": "1039-1095",
          "snippet": "static ssize_t compat_do_readv_writev(int type, struct file *file,\n\t\t\t       const struct compat_iovec __user *uvector,\n\t\t\t       unsigned long nr_segs, loff_t *pos)\n{\n\tcompat_ssize_t tot_len;\n\tstruct iovec iovstack[UIO_FASTIOV];\n\tstruct iovec *iov = iovstack;\n\tssize_t ret;\n\tio_fn_t fn;\n\tiov_fn_t fnv;\n\titer_fn_t iter_fn;\n\n\tret = compat_rw_copy_check_uvector(type, uvector, nr_segs,\n\t\t\t\t\t       UIO_FASTIOV, iovstack, &iov);\n\tif (ret <= 0)\n\t\tgoto out;\n\n\ttot_len = ret;\n\tret = rw_verify_area(type, file, pos, tot_len);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tfnv = NULL;\n\tif (type == READ) {\n\t\tfn = file->f_op->read;\n\t\tfnv = file->f_op->aio_read;\n\t\titer_fn = file->f_op->read_iter;\n\t} else {\n\t\tfn = (io_fn_t)file->f_op->write;\n\t\tfnv = file->f_op->aio_write;\n\t\titer_fn = file->f_op->write_iter;\n\t\tfile_start_write(file);\n\t}\n\n\tif (iter_fn)\n\t\tret = do_iter_readv_writev(file, type, iov, nr_segs, tot_len,\n\t\t\t\t\t\tpos, iter_fn);\n\telse if (fnv)\n\t\tret = do_sync_readv_writev(file, iov, nr_segs, tot_len,\n\t\t\t\t\t\tpos, fnv);\n\telse\n\t\tret = do_loop_readv_writev(file, iov, nr_segs, pos, fn);\n\n\tif (type != READ)\n\t\tfile_end_write(file);\n\nout:\n\tif (iov != iovstack)\n\t\tkfree(iov);\n\tif ((ret + (type == READ)) > 0) {\n\t\tif (type == READ)\n\t\t\tfsnotify_access(file);\n\t\telse\n\t\t\tfsnotify_modify(file);\n\t}\n\treturn ret;\n}",
          "includes": [
            "#include <asm/unistd.h>",
            "#include <asm/uaccess.h>",
            "#include \"internal.h\"",
            "#include <linux/compat.h>",
            "#include <linux/splice.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/export.h>",
            "#include <linux/security.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/aio.h>",
            "#include <linux/uio.h>",
            "#include <linux/file.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/stat.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/unistd.h>\n#include <asm/uaccess.h>\n#include \"internal.h\"\n#include <linux/compat.h>\n#include <linux/splice.h>\n#include <linux/pagemap.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/security.h>\n#include <linux/fsnotify.h>\n#include <linux/aio.h>\n#include <linux/uio.h>\n#include <linux/file.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/slab.h>\n\nstatic ssize_t compat_do_readv_writev(int type, struct file *file,\n\t\t\t       const struct compat_iovec __user *uvector,\n\t\t\t       unsigned long nr_segs, loff_t *pos)\n{\n\tcompat_ssize_t tot_len;\n\tstruct iovec iovstack[UIO_FASTIOV];\n\tstruct iovec *iov = iovstack;\n\tssize_t ret;\n\tio_fn_t fn;\n\tiov_fn_t fnv;\n\titer_fn_t iter_fn;\n\n\tret = compat_rw_copy_check_uvector(type, uvector, nr_segs,\n\t\t\t\t\t       UIO_FASTIOV, iovstack, &iov);\n\tif (ret <= 0)\n\t\tgoto out;\n\n\ttot_len = ret;\n\tret = rw_verify_area(type, file, pos, tot_len);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tfnv = NULL;\n\tif (type == READ) {\n\t\tfn = file->f_op->read;\n\t\tfnv = file->f_op->aio_read;\n\t\titer_fn = file->f_op->read_iter;\n\t} else {\n\t\tfn = (io_fn_t)file->f_op->write;\n\t\tfnv = file->f_op->aio_write;\n\t\titer_fn = file->f_op->write_iter;\n\t\tfile_start_write(file);\n\t}\n\n\tif (iter_fn)\n\t\tret = do_iter_readv_writev(file, type, iov, nr_segs, tot_len,\n\t\t\t\t\t\tpos, iter_fn);\n\telse if (fnv)\n\t\tret = do_sync_readv_writev(file, iov, nr_segs, tot_len,\n\t\t\t\t\t\tpos, fnv);\n\telse\n\t\tret = do_loop_readv_writev(file, iov, nr_segs, pos, fn);\n\n\tif (type != READ)\n\t\tfile_end_write(file);\n\nout:\n\tif (iov != iovstack)\n\t\tkfree(iov);\n\tif ((ret + (type == READ)) > 0) {\n\t\tif (type == READ)\n\t\t\tfsnotify_access(file);\n\t\telse\n\t\t\tfsnotify_modify(file);\n\t}\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/unistd.h>\n#include <asm/uaccess.h>\n#include \"internal.h\"\n#include <linux/compat.h>\n#include <linux/splice.h>\n#include <linux/pagemap.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/security.h>\n#include <linux/fsnotify.h>\n#include <linux/aio.h>\n#include <linux/uio.h>\n#include <linux/file.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/slab.h>\n\nssize_t vfs_writev(struct file *file, const struct iovec __user *vec,\n\t\t   unsigned long vlen, loff_t *pos)\n{\n\tif (!(file->f_mode & FMODE_WRITE))\n\t\treturn -EBADF;\n\tif (!(file->f_mode & FMODE_CAN_WRITE))\n\t\treturn -EINVAL;\n\n\treturn do_readv_writev(WRITE, file, vec, vlen, pos);\n}"
  },
  {
    "function_name": "vfs_readv",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/read_write.c",
    "lines": "917-926",
    "snippet": "ssize_t vfs_readv(struct file *file, const struct iovec __user *vec,\n\t\t  unsigned long vlen, loff_t *pos)\n{\n\tif (!(file->f_mode & FMODE_READ))\n\t\treturn -EBADF;\n\tif (!(file->f_mode & FMODE_CAN_READ))\n\t\treturn -EINVAL;\n\n\treturn do_readv_writev(READ, file, vec, vlen, pos);\n}",
    "includes": [
      "#include <asm/unistd.h>",
      "#include <asm/uaccess.h>",
      "#include \"internal.h\"",
      "#include <linux/compat.h>",
      "#include <linux/splice.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/export.h>",
      "#include <linux/security.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/aio.h>",
      "#include <linux/uio.h>",
      "#include <linux/file.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/stat.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "do_readv_writev",
          "args": [
            "READ",
            "file",
            "vec",
            "vlen",
            "pos"
          ],
          "line": 925
        },
        "resolved": true,
        "details": {
          "function_name": "compat_do_readv_writev",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/read_write.c",
          "lines": "1039-1095",
          "snippet": "static ssize_t compat_do_readv_writev(int type, struct file *file,\n\t\t\t       const struct compat_iovec __user *uvector,\n\t\t\t       unsigned long nr_segs, loff_t *pos)\n{\n\tcompat_ssize_t tot_len;\n\tstruct iovec iovstack[UIO_FASTIOV];\n\tstruct iovec *iov = iovstack;\n\tssize_t ret;\n\tio_fn_t fn;\n\tiov_fn_t fnv;\n\titer_fn_t iter_fn;\n\n\tret = compat_rw_copy_check_uvector(type, uvector, nr_segs,\n\t\t\t\t\t       UIO_FASTIOV, iovstack, &iov);\n\tif (ret <= 0)\n\t\tgoto out;\n\n\ttot_len = ret;\n\tret = rw_verify_area(type, file, pos, tot_len);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tfnv = NULL;\n\tif (type == READ) {\n\t\tfn = file->f_op->read;\n\t\tfnv = file->f_op->aio_read;\n\t\titer_fn = file->f_op->read_iter;\n\t} else {\n\t\tfn = (io_fn_t)file->f_op->write;\n\t\tfnv = file->f_op->aio_write;\n\t\titer_fn = file->f_op->write_iter;\n\t\tfile_start_write(file);\n\t}\n\n\tif (iter_fn)\n\t\tret = do_iter_readv_writev(file, type, iov, nr_segs, tot_len,\n\t\t\t\t\t\tpos, iter_fn);\n\telse if (fnv)\n\t\tret = do_sync_readv_writev(file, iov, nr_segs, tot_len,\n\t\t\t\t\t\tpos, fnv);\n\telse\n\t\tret = do_loop_readv_writev(file, iov, nr_segs, pos, fn);\n\n\tif (type != READ)\n\t\tfile_end_write(file);\n\nout:\n\tif (iov != iovstack)\n\t\tkfree(iov);\n\tif ((ret + (type == READ)) > 0) {\n\t\tif (type == READ)\n\t\t\tfsnotify_access(file);\n\t\telse\n\t\t\tfsnotify_modify(file);\n\t}\n\treturn ret;\n}",
          "includes": [
            "#include <asm/unistd.h>",
            "#include <asm/uaccess.h>",
            "#include \"internal.h\"",
            "#include <linux/compat.h>",
            "#include <linux/splice.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/export.h>",
            "#include <linux/security.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/aio.h>",
            "#include <linux/uio.h>",
            "#include <linux/file.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/stat.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/unistd.h>\n#include <asm/uaccess.h>\n#include \"internal.h\"\n#include <linux/compat.h>\n#include <linux/splice.h>\n#include <linux/pagemap.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/security.h>\n#include <linux/fsnotify.h>\n#include <linux/aio.h>\n#include <linux/uio.h>\n#include <linux/file.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/slab.h>\n\nstatic ssize_t compat_do_readv_writev(int type, struct file *file,\n\t\t\t       const struct compat_iovec __user *uvector,\n\t\t\t       unsigned long nr_segs, loff_t *pos)\n{\n\tcompat_ssize_t tot_len;\n\tstruct iovec iovstack[UIO_FASTIOV];\n\tstruct iovec *iov = iovstack;\n\tssize_t ret;\n\tio_fn_t fn;\n\tiov_fn_t fnv;\n\titer_fn_t iter_fn;\n\n\tret = compat_rw_copy_check_uvector(type, uvector, nr_segs,\n\t\t\t\t\t       UIO_FASTIOV, iovstack, &iov);\n\tif (ret <= 0)\n\t\tgoto out;\n\n\ttot_len = ret;\n\tret = rw_verify_area(type, file, pos, tot_len);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tfnv = NULL;\n\tif (type == READ) {\n\t\tfn = file->f_op->read;\n\t\tfnv = file->f_op->aio_read;\n\t\titer_fn = file->f_op->read_iter;\n\t} else {\n\t\tfn = (io_fn_t)file->f_op->write;\n\t\tfnv = file->f_op->aio_write;\n\t\titer_fn = file->f_op->write_iter;\n\t\tfile_start_write(file);\n\t}\n\n\tif (iter_fn)\n\t\tret = do_iter_readv_writev(file, type, iov, nr_segs, tot_len,\n\t\t\t\t\t\tpos, iter_fn);\n\telse if (fnv)\n\t\tret = do_sync_readv_writev(file, iov, nr_segs, tot_len,\n\t\t\t\t\t\tpos, fnv);\n\telse\n\t\tret = do_loop_readv_writev(file, iov, nr_segs, pos, fn);\n\n\tif (type != READ)\n\t\tfile_end_write(file);\n\nout:\n\tif (iov != iovstack)\n\t\tkfree(iov);\n\tif ((ret + (type == READ)) > 0) {\n\t\tif (type == READ)\n\t\t\tfsnotify_access(file);\n\t\telse\n\t\t\tfsnotify_modify(file);\n\t}\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/unistd.h>\n#include <asm/uaccess.h>\n#include \"internal.h\"\n#include <linux/compat.h>\n#include <linux/splice.h>\n#include <linux/pagemap.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/security.h>\n#include <linux/fsnotify.h>\n#include <linux/aio.h>\n#include <linux/uio.h>\n#include <linux/file.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/slab.h>\n\nssize_t vfs_readv(struct file *file, const struct iovec __user *vec,\n\t\t  unsigned long vlen, loff_t *pos)\n{\n\tif (!(file->f_mode & FMODE_READ))\n\t\treturn -EBADF;\n\tif (!(file->f_mode & FMODE_CAN_READ))\n\t\treturn -EINVAL;\n\n\treturn do_readv_writev(READ, file, vec, vlen, pos);\n}"
  },
  {
    "function_name": "do_readv_writev",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/read_write.c",
    "lines": "859-915",
    "snippet": "static ssize_t do_readv_writev(int type, struct file *file,\n\t\t\t       const struct iovec __user * uvector,\n\t\t\t       unsigned long nr_segs, loff_t *pos)\n{\n\tsize_t tot_len;\n\tstruct iovec iovstack[UIO_FASTIOV];\n\tstruct iovec *iov = iovstack;\n\tssize_t ret;\n\tio_fn_t fn;\n\tiov_fn_t fnv;\n\titer_fn_t iter_fn;\n\n\tret = rw_copy_check_uvector(type, uvector, nr_segs,\n\t\t\t\t    ARRAY_SIZE(iovstack), iovstack, &iov);\n\tif (ret <= 0)\n\t\tgoto out;\n\n\ttot_len = ret;\n\tret = rw_verify_area(type, file, pos, tot_len);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tfnv = NULL;\n\tif (type == READ) {\n\t\tfn = file->f_op->read;\n\t\tfnv = file->f_op->aio_read;\n\t\titer_fn = file->f_op->read_iter;\n\t} else {\n\t\tfn = (io_fn_t)file->f_op->write;\n\t\tfnv = file->f_op->aio_write;\n\t\titer_fn = file->f_op->write_iter;\n\t\tfile_start_write(file);\n\t}\n\n\tif (iter_fn)\n\t\tret = do_iter_readv_writev(file, type, iov, nr_segs, tot_len,\n\t\t\t\t\t\tpos, iter_fn);\n\telse if (fnv)\n\t\tret = do_sync_readv_writev(file, iov, nr_segs, tot_len,\n\t\t\t\t\t\tpos, fnv);\n\telse\n\t\tret = do_loop_readv_writev(file, iov, nr_segs, pos, fn);\n\n\tif (type != READ)\n\t\tfile_end_write(file);\n\nout:\n\tif (iov != iovstack)\n\t\tkfree(iov);\n\tif ((ret + (type == READ)) > 0) {\n\t\tif (type == READ)\n\t\t\tfsnotify_access(file);\n\t\telse\n\t\t\tfsnotify_modify(file);\n\t}\n\treturn ret;\n}",
    "includes": [
      "#include <asm/unistd.h>",
      "#include <asm/uaccess.h>",
      "#include \"internal.h\"",
      "#include <linux/compat.h>",
      "#include <linux/splice.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/export.h>",
      "#include <linux/security.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/aio.h>",
      "#include <linux/uio.h>",
      "#include <linux/file.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/stat.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fsnotify_modify",
          "args": [
            "file"
          ],
          "line": 912
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fsnotify_access",
          "args": [
            "file"
          ],
          "line": 910
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "iov"
          ],
          "line": 907
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "file_end_write",
          "args": [
            "file"
          ],
          "line": 903
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "do_loop_readv_writev",
          "args": [
            "file",
            "iov",
            "nr_segs",
            "pos",
            "fn"
          ],
          "line": 900
        },
        "resolved": true,
        "details": {
          "function_name": "do_loop_readv_writev",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/read_write.c",
          "lines": "750-779",
          "snippet": "static ssize_t do_loop_readv_writev(struct file *filp, struct iovec *iov,\n\t\tunsigned long nr_segs, loff_t *ppos, io_fn_t fn)\n{\n\tstruct iovec *vector = iov;\n\tssize_t ret = 0;\n\n\twhile (nr_segs > 0) {\n\t\tvoid __user *base;\n\t\tsize_t len;\n\t\tssize_t nr;\n\n\t\tbase = vector->iov_base;\n\t\tlen = vector->iov_len;\n\t\tvector++;\n\t\tnr_segs--;\n\n\t\tnr = fn(filp, base, len, ppos);\n\n\t\tif (nr < 0) {\n\t\t\tif (!ret)\n\t\t\t\tret = nr;\n\t\t\tbreak;\n\t\t}\n\t\tret += nr;\n\t\tif (nr != len)\n\t\t\tbreak;\n\t}\n\n\treturn ret;\n}",
          "includes": [
            "#include <asm/unistd.h>",
            "#include <asm/uaccess.h>",
            "#include \"internal.h\"",
            "#include <linux/compat.h>",
            "#include <linux/splice.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/export.h>",
            "#include <linux/security.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/aio.h>",
            "#include <linux/uio.h>",
            "#include <linux/file.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/stat.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/unistd.h>\n#include <asm/uaccess.h>\n#include \"internal.h\"\n#include <linux/compat.h>\n#include <linux/splice.h>\n#include <linux/pagemap.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/security.h>\n#include <linux/fsnotify.h>\n#include <linux/aio.h>\n#include <linux/uio.h>\n#include <linux/file.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/slab.h>\n\nstatic ssize_t do_loop_readv_writev(struct file *filp, struct iovec *iov,\n\t\tunsigned long nr_segs, loff_t *ppos, io_fn_t fn)\n{\n\tstruct iovec *vector = iov;\n\tssize_t ret = 0;\n\n\twhile (nr_segs > 0) {\n\t\tvoid __user *base;\n\t\tsize_t len;\n\t\tssize_t nr;\n\n\t\tbase = vector->iov_base;\n\t\tlen = vector->iov_len;\n\t\tvector++;\n\t\tnr_segs--;\n\n\t\tnr = fn(filp, base, len, ppos);\n\n\t\tif (nr < 0) {\n\t\t\tif (!ret)\n\t\t\t\tret = nr;\n\t\t\tbreak;\n\t\t}\n\t\tret += nr;\n\t\tif (nr != len)\n\t\t\tbreak;\n\t}\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "do_sync_readv_writev",
          "args": [
            "file",
            "iov",
            "nr_segs",
            "tot_len",
            "pos",
            "fnv"
          ],
          "line": 897
        },
        "resolved": true,
        "details": {
          "function_name": "do_sync_readv_writev",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/read_write.c",
          "lines": "732-747",
          "snippet": "static ssize_t do_sync_readv_writev(struct file *filp, const struct iovec *iov,\n\t\tunsigned long nr_segs, size_t len, loff_t *ppos, iov_fn_t fn)\n{\n\tstruct kiocb kiocb;\n\tssize_t ret;\n\n\tinit_sync_kiocb(&kiocb, filp);\n\tkiocb.ki_pos = *ppos;\n\tkiocb.ki_nbytes = len;\n\n\tret = fn(&kiocb, iov, nr_segs, kiocb.ki_pos);\n\tif (ret == -EIOCBQUEUED)\n\t\tret = wait_on_sync_kiocb(&kiocb);\n\t*ppos = kiocb.ki_pos;\n\treturn ret;\n}",
          "includes": [
            "#include <asm/unistd.h>",
            "#include <asm/uaccess.h>",
            "#include \"internal.h\"",
            "#include <linux/compat.h>",
            "#include <linux/splice.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/export.h>",
            "#include <linux/security.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/aio.h>",
            "#include <linux/uio.h>",
            "#include <linux/file.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/stat.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/unistd.h>\n#include <asm/uaccess.h>\n#include \"internal.h\"\n#include <linux/compat.h>\n#include <linux/splice.h>\n#include <linux/pagemap.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/security.h>\n#include <linux/fsnotify.h>\n#include <linux/aio.h>\n#include <linux/uio.h>\n#include <linux/file.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/slab.h>\n\nstatic ssize_t do_sync_readv_writev(struct file *filp, const struct iovec *iov,\n\t\tunsigned long nr_segs, size_t len, loff_t *ppos, iov_fn_t fn)\n{\n\tstruct kiocb kiocb;\n\tssize_t ret;\n\n\tinit_sync_kiocb(&kiocb, filp);\n\tkiocb.ki_pos = *ppos;\n\tkiocb.ki_nbytes = len;\n\n\tret = fn(&kiocb, iov, nr_segs, kiocb.ki_pos);\n\tif (ret == -EIOCBQUEUED)\n\t\tret = wait_on_sync_kiocb(&kiocb);\n\t*ppos = kiocb.ki_pos;\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "do_iter_readv_writev",
          "args": [
            "file",
            "type",
            "iov",
            "nr_segs",
            "tot_len",
            "pos",
            "iter_fn"
          ],
          "line": 894
        },
        "resolved": true,
        "details": {
          "function_name": "do_iter_readv_writev",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/read_write.c",
          "lines": "713-730",
          "snippet": "static ssize_t do_iter_readv_writev(struct file *filp, int rw, const struct iovec *iov,\n\t\tunsigned long nr_segs, size_t len, loff_t *ppos, iter_fn_t fn)\n{\n\tstruct kiocb kiocb;\n\tstruct iov_iter iter;\n\tssize_t ret;\n\n\tinit_sync_kiocb(&kiocb, filp);\n\tkiocb.ki_pos = *ppos;\n\tkiocb.ki_nbytes = len;\n\n\tiov_iter_init(&iter, rw, iov, nr_segs, len);\n\tret = fn(&kiocb, &iter);\n\tif (ret == -EIOCBQUEUED)\n\t\tret = wait_on_sync_kiocb(&kiocb);\n\t*ppos = kiocb.ki_pos;\n\treturn ret;\n}",
          "includes": [
            "#include <asm/unistd.h>",
            "#include <asm/uaccess.h>",
            "#include \"internal.h\"",
            "#include <linux/compat.h>",
            "#include <linux/splice.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/export.h>",
            "#include <linux/security.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/aio.h>",
            "#include <linux/uio.h>",
            "#include <linux/file.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/stat.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/unistd.h>\n#include <asm/uaccess.h>\n#include \"internal.h\"\n#include <linux/compat.h>\n#include <linux/splice.h>\n#include <linux/pagemap.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/security.h>\n#include <linux/fsnotify.h>\n#include <linux/aio.h>\n#include <linux/uio.h>\n#include <linux/file.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/slab.h>\n\nstatic ssize_t do_iter_readv_writev(struct file *filp, int rw, const struct iovec *iov,\n\t\tunsigned long nr_segs, size_t len, loff_t *ppos, iter_fn_t fn)\n{\n\tstruct kiocb kiocb;\n\tstruct iov_iter iter;\n\tssize_t ret;\n\n\tinit_sync_kiocb(&kiocb, filp);\n\tkiocb.ki_pos = *ppos;\n\tkiocb.ki_nbytes = len;\n\n\tiov_iter_init(&iter, rw, iov, nr_segs, len);\n\tret = fn(&kiocb, &iter);\n\tif (ret == -EIOCBQUEUED)\n\t\tret = wait_on_sync_kiocb(&kiocb);\n\t*ppos = kiocb.ki_pos;\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "file_start_write",
          "args": [
            "file"
          ],
          "line": 890
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rw_verify_area",
          "args": [
            "type",
            "file",
            "pos",
            "tot_len"
          ],
          "line": 877
        },
        "resolved": true,
        "details": {
          "function_name": "rw_verify_area",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/read_write.c",
          "lines": "387-419",
          "snippet": "int rw_verify_area(int read_write, struct file *file, const loff_t *ppos, size_t count)\n{\n\tstruct inode *inode;\n\tloff_t pos;\n\tint retval = -EINVAL;\n\n\tinode = file_inode(file);\n\tif (unlikely((ssize_t) count < 0))\n\t\treturn retval;\n\tpos = *ppos;\n\tif (unlikely(pos < 0)) {\n\t\tif (!unsigned_offsets(file))\n\t\t\treturn retval;\n\t\tif (count >= -pos) /* both values are in 0..LLONG_MAX */\n\t\t\treturn -EOVERFLOW;\n\t} else if (unlikely((loff_t) (pos + count) < 0)) {\n\t\tif (!unsigned_offsets(file))\n\t\t\treturn retval;\n\t}\n\n\tif (unlikely(inode->i_flctx && mandatory_lock(inode))) {\n\t\tretval = locks_mandatory_area(\n\t\t\tread_write == READ ? FLOCK_VERIFY_READ : FLOCK_VERIFY_WRITE,\n\t\t\tinode, file, pos, count);\n\t\tif (retval < 0)\n\t\t\treturn retval;\n\t}\n\tretval = security_file_permission(file,\n\t\t\t\tread_write == READ ? MAY_READ : MAY_WRITE);\n\tif (retval)\n\t\treturn retval;\n\treturn count > MAX_RW_COUNT ? MAX_RW_COUNT : count;\n}",
          "includes": [
            "#include <asm/unistd.h>",
            "#include <asm/uaccess.h>",
            "#include \"internal.h\"",
            "#include <linux/compat.h>",
            "#include <linux/splice.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/export.h>",
            "#include <linux/security.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/aio.h>",
            "#include <linux/uio.h>",
            "#include <linux/file.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/stat.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/unistd.h>\n#include <asm/uaccess.h>\n#include \"internal.h\"\n#include <linux/compat.h>\n#include <linux/splice.h>\n#include <linux/pagemap.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/security.h>\n#include <linux/fsnotify.h>\n#include <linux/aio.h>\n#include <linux/uio.h>\n#include <linux/file.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/slab.h>\n\nint rw_verify_area(int read_write, struct file *file, const loff_t *ppos, size_t count)\n{\n\tstruct inode *inode;\n\tloff_t pos;\n\tint retval = -EINVAL;\n\n\tinode = file_inode(file);\n\tif (unlikely((ssize_t) count < 0))\n\t\treturn retval;\n\tpos = *ppos;\n\tif (unlikely(pos < 0)) {\n\t\tif (!unsigned_offsets(file))\n\t\t\treturn retval;\n\t\tif (count >= -pos) /* both values are in 0..LLONG_MAX */\n\t\t\treturn -EOVERFLOW;\n\t} else if (unlikely((loff_t) (pos + count) < 0)) {\n\t\tif (!unsigned_offsets(file))\n\t\t\treturn retval;\n\t}\n\n\tif (unlikely(inode->i_flctx && mandatory_lock(inode))) {\n\t\tretval = locks_mandatory_area(\n\t\t\tread_write == READ ? FLOCK_VERIFY_READ : FLOCK_VERIFY_WRITE,\n\t\t\tinode, file, pos, count);\n\t\tif (retval < 0)\n\t\t\treturn retval;\n\t}\n\tretval = security_file_permission(file,\n\t\t\t\tread_write == READ ? MAY_READ : MAY_WRITE);\n\tif (retval)\n\t\treturn retval;\n\treturn count > MAX_RW_COUNT ? MAX_RW_COUNT : count;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rw_copy_check_uvector",
          "args": [
            "type",
            "uvector",
            "nr_segs",
            "ARRAY_SIZE(iovstack)",
            "iovstack",
            "&iov"
          ],
          "line": 871
        },
        "resolved": true,
        "details": {
          "function_name": "rw_copy_check_uvector",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/read_write.c",
          "lines": "784-857",
          "snippet": "ssize_t rw_copy_check_uvector(int type, const struct iovec __user * uvector,\n\t\t\t      unsigned long nr_segs, unsigned long fast_segs,\n\t\t\t      struct iovec *fast_pointer,\n\t\t\t      struct iovec **ret_pointer)\n{\n\tunsigned long seg;\n\tssize_t ret;\n\tstruct iovec *iov = fast_pointer;\n\n\t/*\n\t * SuS says \"The readv() function *may* fail if the iovcnt argument\n\t * was less than or equal to 0, or greater than {IOV_MAX}.  Linux has\n\t * traditionally returned zero for zero segments, so...\n\t */\n\tif (nr_segs == 0) {\n\t\tret = 0;\n\t\tgoto out;\n\t}\n\n\t/*\n\t * First get the \"struct iovec\" from user memory and\n\t * verify all the pointers\n\t */\n\tif (nr_segs > UIO_MAXIOV) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\tif (nr_segs > fast_segs) {\n\t\tiov = kmalloc(nr_segs*sizeof(struct iovec), GFP_KERNEL);\n\t\tif (iov == NULL) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\t}\n\tif (copy_from_user(iov, uvector, nr_segs*sizeof(*uvector))) {\n\t\tret = -EFAULT;\n\t\tgoto out;\n\t}\n\n\t/*\n\t * According to the Single Unix Specification we should return EINVAL\n\t * if an element length is < 0 when cast to ssize_t or if the\n\t * total length would overflow the ssize_t return value of the\n\t * system call.\n\t *\n\t * Linux caps all read/write calls to MAX_RW_COUNT, and avoids the\n\t * overflow case.\n\t */\n\tret = 0;\n\tfor (seg = 0; seg < nr_segs; seg++) {\n\t\tvoid __user *buf = iov[seg].iov_base;\n\t\tssize_t len = (ssize_t)iov[seg].iov_len;\n\n\t\t/* see if we we're about to use an invalid len or if\n\t\t * it's about to overflow ssize_t */\n\t\tif (len < 0) {\n\t\t\tret = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\t\tif (type >= 0\n\t\t    && unlikely(!access_ok(vrfy_dir(type), buf, len))) {\n\t\t\tret = -EFAULT;\n\t\t\tgoto out;\n\t\t}\n\t\tif (len > MAX_RW_COUNT - ret) {\n\t\t\tlen = MAX_RW_COUNT - ret;\n\t\t\tiov[seg].iov_len = len;\n\t\t}\n\t\tret += len;\n\t}\nout:\n\t*ret_pointer = iov;\n\treturn ret;\n}",
          "includes": [
            "#include <asm/unistd.h>",
            "#include <asm/uaccess.h>",
            "#include \"internal.h\"",
            "#include <linux/compat.h>",
            "#include <linux/splice.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/export.h>",
            "#include <linux/security.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/aio.h>",
            "#include <linux/uio.h>",
            "#include <linux/file.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/stat.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/unistd.h>\n#include <asm/uaccess.h>\n#include \"internal.h\"\n#include <linux/compat.h>\n#include <linux/splice.h>\n#include <linux/pagemap.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/security.h>\n#include <linux/fsnotify.h>\n#include <linux/aio.h>\n#include <linux/uio.h>\n#include <linux/file.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/slab.h>\n\nssize_t rw_copy_check_uvector(int type, const struct iovec __user * uvector,\n\t\t\t      unsigned long nr_segs, unsigned long fast_segs,\n\t\t\t      struct iovec *fast_pointer,\n\t\t\t      struct iovec **ret_pointer)\n{\n\tunsigned long seg;\n\tssize_t ret;\n\tstruct iovec *iov = fast_pointer;\n\n\t/*\n\t * SuS says \"The readv() function *may* fail if the iovcnt argument\n\t * was less than or equal to 0, or greater than {IOV_MAX}.  Linux has\n\t * traditionally returned zero for zero segments, so...\n\t */\n\tif (nr_segs == 0) {\n\t\tret = 0;\n\t\tgoto out;\n\t}\n\n\t/*\n\t * First get the \"struct iovec\" from user memory and\n\t * verify all the pointers\n\t */\n\tif (nr_segs > UIO_MAXIOV) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\tif (nr_segs > fast_segs) {\n\t\tiov = kmalloc(nr_segs*sizeof(struct iovec), GFP_KERNEL);\n\t\tif (iov == NULL) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\t}\n\tif (copy_from_user(iov, uvector, nr_segs*sizeof(*uvector))) {\n\t\tret = -EFAULT;\n\t\tgoto out;\n\t}\n\n\t/*\n\t * According to the Single Unix Specification we should return EINVAL\n\t * if an element length is < 0 when cast to ssize_t or if the\n\t * total length would overflow the ssize_t return value of the\n\t * system call.\n\t *\n\t * Linux caps all read/write calls to MAX_RW_COUNT, and avoids the\n\t * overflow case.\n\t */\n\tret = 0;\n\tfor (seg = 0; seg < nr_segs; seg++) {\n\t\tvoid __user *buf = iov[seg].iov_base;\n\t\tssize_t len = (ssize_t)iov[seg].iov_len;\n\n\t\t/* see if we we're about to use an invalid len or if\n\t\t * it's about to overflow ssize_t */\n\t\tif (len < 0) {\n\t\t\tret = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\t\tif (type >= 0\n\t\t    && unlikely(!access_ok(vrfy_dir(type), buf, len))) {\n\t\t\tret = -EFAULT;\n\t\t\tgoto out;\n\t\t}\n\t\tif (len > MAX_RW_COUNT - ret) {\n\t\t\tlen = MAX_RW_COUNT - ret;\n\t\t\tiov[seg].iov_len = len;\n\t\t}\n\t\tret += len;\n\t}\nout:\n\t*ret_pointer = iov;\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ARRAY_SIZE",
          "args": [
            "iovstack"
          ],
          "line": 872
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/unistd.h>\n#include <asm/uaccess.h>\n#include \"internal.h\"\n#include <linux/compat.h>\n#include <linux/splice.h>\n#include <linux/pagemap.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/security.h>\n#include <linux/fsnotify.h>\n#include <linux/aio.h>\n#include <linux/uio.h>\n#include <linux/file.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/slab.h>\n\nstatic ssize_t do_readv_writev(int type, struct file *file,\n\t\t\t       const struct iovec __user * uvector,\n\t\t\t       unsigned long nr_segs, loff_t *pos)\n{\n\tsize_t tot_len;\n\tstruct iovec iovstack[UIO_FASTIOV];\n\tstruct iovec *iov = iovstack;\n\tssize_t ret;\n\tio_fn_t fn;\n\tiov_fn_t fnv;\n\titer_fn_t iter_fn;\n\n\tret = rw_copy_check_uvector(type, uvector, nr_segs,\n\t\t\t\t    ARRAY_SIZE(iovstack), iovstack, &iov);\n\tif (ret <= 0)\n\t\tgoto out;\n\n\ttot_len = ret;\n\tret = rw_verify_area(type, file, pos, tot_len);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tfnv = NULL;\n\tif (type == READ) {\n\t\tfn = file->f_op->read;\n\t\tfnv = file->f_op->aio_read;\n\t\titer_fn = file->f_op->read_iter;\n\t} else {\n\t\tfn = (io_fn_t)file->f_op->write;\n\t\tfnv = file->f_op->aio_write;\n\t\titer_fn = file->f_op->write_iter;\n\t\tfile_start_write(file);\n\t}\n\n\tif (iter_fn)\n\t\tret = do_iter_readv_writev(file, type, iov, nr_segs, tot_len,\n\t\t\t\t\t\tpos, iter_fn);\n\telse if (fnv)\n\t\tret = do_sync_readv_writev(file, iov, nr_segs, tot_len,\n\t\t\t\t\t\tpos, fnv);\n\telse\n\t\tret = do_loop_readv_writev(file, iov, nr_segs, pos, fn);\n\n\tif (type != READ)\n\t\tfile_end_write(file);\n\nout:\n\tif (iov != iovstack)\n\t\tkfree(iov);\n\tif ((ret + (type == READ)) > 0) {\n\t\tif (type == READ)\n\t\t\tfsnotify_access(file);\n\t\telse\n\t\t\tfsnotify_modify(file);\n\t}\n\treturn ret;\n}"
  },
  {
    "function_name": "rw_copy_check_uvector",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/read_write.c",
    "lines": "784-857",
    "snippet": "ssize_t rw_copy_check_uvector(int type, const struct iovec __user * uvector,\n\t\t\t      unsigned long nr_segs, unsigned long fast_segs,\n\t\t\t      struct iovec *fast_pointer,\n\t\t\t      struct iovec **ret_pointer)\n{\n\tunsigned long seg;\n\tssize_t ret;\n\tstruct iovec *iov = fast_pointer;\n\n\t/*\n\t * SuS says \"The readv() function *may* fail if the iovcnt argument\n\t * was less than or equal to 0, or greater than {IOV_MAX}.  Linux has\n\t * traditionally returned zero for zero segments, so...\n\t */\n\tif (nr_segs == 0) {\n\t\tret = 0;\n\t\tgoto out;\n\t}\n\n\t/*\n\t * First get the \"struct iovec\" from user memory and\n\t * verify all the pointers\n\t */\n\tif (nr_segs > UIO_MAXIOV) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\tif (nr_segs > fast_segs) {\n\t\tiov = kmalloc(nr_segs*sizeof(struct iovec), GFP_KERNEL);\n\t\tif (iov == NULL) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\t}\n\tif (copy_from_user(iov, uvector, nr_segs*sizeof(*uvector))) {\n\t\tret = -EFAULT;\n\t\tgoto out;\n\t}\n\n\t/*\n\t * According to the Single Unix Specification we should return EINVAL\n\t * if an element length is < 0 when cast to ssize_t or if the\n\t * total length would overflow the ssize_t return value of the\n\t * system call.\n\t *\n\t * Linux caps all read/write calls to MAX_RW_COUNT, and avoids the\n\t * overflow case.\n\t */\n\tret = 0;\n\tfor (seg = 0; seg < nr_segs; seg++) {\n\t\tvoid __user *buf = iov[seg].iov_base;\n\t\tssize_t len = (ssize_t)iov[seg].iov_len;\n\n\t\t/* see if we we're about to use an invalid len or if\n\t\t * it's about to overflow ssize_t */\n\t\tif (len < 0) {\n\t\t\tret = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\t\tif (type >= 0\n\t\t    && unlikely(!access_ok(vrfy_dir(type), buf, len))) {\n\t\t\tret = -EFAULT;\n\t\t\tgoto out;\n\t\t}\n\t\tif (len > MAX_RW_COUNT - ret) {\n\t\t\tlen = MAX_RW_COUNT - ret;\n\t\t\tiov[seg].iov_len = len;\n\t\t}\n\t\tret += len;\n\t}\nout:\n\t*ret_pointer = iov;\n\treturn ret;\n}",
    "includes": [
      "#include <asm/unistd.h>",
      "#include <asm/uaccess.h>",
      "#include \"internal.h\"",
      "#include <linux/compat.h>",
      "#include <linux/splice.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/export.h>",
      "#include <linux/security.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/aio.h>",
      "#include <linux/uio.h>",
      "#include <linux/file.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/stat.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!access_ok(vrfy_dir(type), buf, len)"
          ],
          "line": 844
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "access_ok",
          "args": [
            "vrfy_dir(type)",
            "buf",
            "len"
          ],
          "line": 844
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vrfy_dir",
          "args": [
            "type"
          ],
          "line": 844
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "copy_from_user",
          "args": [
            "iov",
            "uvector",
            "nr_segs*sizeof(*uvector)"
          ],
          "line": 818
        },
        "resolved": true,
        "details": {
          "function_name": "exact_copy_from_user",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namespace.c",
          "lines": "2514-2534",
          "snippet": "static long exact_copy_from_user(void *to, const void __user * from,\n\t\t\t\t unsigned long n)\n{\n\tchar *t = to;\n\tconst char __user *f = from;\n\tchar c;\n\n\tif (!access_ok(VERIFY_READ, from, n))\n\t\treturn n;\n\n\twhile (n) {\n\t\tif (__get_user(c, f)) {\n\t\t\tmemset(t, 0, n);\n\t\t\tbreak;\n\t\t}\n\t\t*t++ = c;\n\t\tf++;\n\t\tn--;\n\t}\n\treturn n;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"pnode.h\"",
            "#include <linux/task_work.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/magic.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
            "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
            "#include <linux/init.h>\t\t/* init_rootfs */",
            "#include <linux/idr.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/mnt_namespace.h>",
            "#include <linux/capability.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/task_work.h>\n#include <linux/bootmem.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic long exact_copy_from_user(void *to, const void __user * from,\n\t\t\t\t unsigned long n)\n{\n\tchar *t = to;\n\tconst char __user *f = from;\n\tchar c;\n\n\tif (!access_ok(VERIFY_READ, from, n))\n\t\treturn n;\n\n\twhile (n) {\n\t\tif (__get_user(c, f)) {\n\t\t\tmemset(t, 0, n);\n\t\t\tbreak;\n\t\t}\n\t\t*t++ = c;\n\t\tf++;\n\t\tn--;\n\t}\n\treturn n;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "nr_segs*sizeof(struct iovec)",
            "GFP_KERNEL"
          ],
          "line": 812
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dx_dir_kmalloc_leaves",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "2534-2546",
          "snippet": "static struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/unistd.h>\n#include <asm/uaccess.h>\n#include \"internal.h\"\n#include <linux/compat.h>\n#include <linux/splice.h>\n#include <linux/pagemap.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/security.h>\n#include <linux/fsnotify.h>\n#include <linux/aio.h>\n#include <linux/uio.h>\n#include <linux/file.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/slab.h>\n\nssize_t rw_copy_check_uvector(int type, const struct iovec __user * uvector,\n\t\t\t      unsigned long nr_segs, unsigned long fast_segs,\n\t\t\t      struct iovec *fast_pointer,\n\t\t\t      struct iovec **ret_pointer)\n{\n\tunsigned long seg;\n\tssize_t ret;\n\tstruct iovec *iov = fast_pointer;\n\n\t/*\n\t * SuS says \"The readv() function *may* fail if the iovcnt argument\n\t * was less than or equal to 0, or greater than {IOV_MAX}.  Linux has\n\t * traditionally returned zero for zero segments, so...\n\t */\n\tif (nr_segs == 0) {\n\t\tret = 0;\n\t\tgoto out;\n\t}\n\n\t/*\n\t * First get the \"struct iovec\" from user memory and\n\t * verify all the pointers\n\t */\n\tif (nr_segs > UIO_MAXIOV) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\tif (nr_segs > fast_segs) {\n\t\tiov = kmalloc(nr_segs*sizeof(struct iovec), GFP_KERNEL);\n\t\tif (iov == NULL) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\t}\n\tif (copy_from_user(iov, uvector, nr_segs*sizeof(*uvector))) {\n\t\tret = -EFAULT;\n\t\tgoto out;\n\t}\n\n\t/*\n\t * According to the Single Unix Specification we should return EINVAL\n\t * if an element length is < 0 when cast to ssize_t or if the\n\t * total length would overflow the ssize_t return value of the\n\t * system call.\n\t *\n\t * Linux caps all read/write calls to MAX_RW_COUNT, and avoids the\n\t * overflow case.\n\t */\n\tret = 0;\n\tfor (seg = 0; seg < nr_segs; seg++) {\n\t\tvoid __user *buf = iov[seg].iov_base;\n\t\tssize_t len = (ssize_t)iov[seg].iov_len;\n\n\t\t/* see if we we're about to use an invalid len or if\n\t\t * it's about to overflow ssize_t */\n\t\tif (len < 0) {\n\t\t\tret = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\t\tif (type >= 0\n\t\t    && unlikely(!access_ok(vrfy_dir(type), buf, len))) {\n\t\t\tret = -EFAULT;\n\t\t\tgoto out;\n\t\t}\n\t\tif (len > MAX_RW_COUNT - ret) {\n\t\t\tlen = MAX_RW_COUNT - ret;\n\t\t\tiov[seg].iov_len = len;\n\t\t}\n\t\tret += len;\n\t}\nout:\n\t*ret_pointer = iov;\n\treturn ret;\n}"
  },
  {
    "function_name": "do_loop_readv_writev",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/read_write.c",
    "lines": "750-779",
    "snippet": "static ssize_t do_loop_readv_writev(struct file *filp, struct iovec *iov,\n\t\tunsigned long nr_segs, loff_t *ppos, io_fn_t fn)\n{\n\tstruct iovec *vector = iov;\n\tssize_t ret = 0;\n\n\twhile (nr_segs > 0) {\n\t\tvoid __user *base;\n\t\tsize_t len;\n\t\tssize_t nr;\n\n\t\tbase = vector->iov_base;\n\t\tlen = vector->iov_len;\n\t\tvector++;\n\t\tnr_segs--;\n\n\t\tnr = fn(filp, base, len, ppos);\n\n\t\tif (nr < 0) {\n\t\t\tif (!ret)\n\t\t\t\tret = nr;\n\t\t\tbreak;\n\t\t}\n\t\tret += nr;\n\t\tif (nr != len)\n\t\t\tbreak;\n\t}\n\n\treturn ret;\n}",
    "includes": [
      "#include <asm/unistd.h>",
      "#include <asm/uaccess.h>",
      "#include \"internal.h\"",
      "#include <linux/compat.h>",
      "#include <linux/splice.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/export.h>",
      "#include <linux/security.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/aio.h>",
      "#include <linux/uio.h>",
      "#include <linux/file.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/stat.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fn",
          "args": [
            "filp",
            "base",
            "len",
            "ppos"
          ],
          "line": 766
        },
        "resolved": true,
        "details": {
          "function_name": "hpfs_alloc_fnode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/alloc.c",
          "lines": "453-468",
          "snippet": "struct fnode *hpfs_alloc_fnode(struct super_block *s, secno near, fnode_secno *fno,\n\t\t\t  struct buffer_head **bh)\n{\n\tstruct fnode *f;\n\tif (!(*fno = hpfs_alloc_sector(s, near, 1, FNODE_ALLOC_FWD))) return NULL;\n\tif (!(f = hpfs_get_sector(s, *fno, bh))) {\n\t\thpfs_free_sectors(s, *fno, 1);\n\t\treturn NULL;\n\t}\t\n\tmemset(f, 0, 512);\n\tf->magic = cpu_to_le32(FNODE_MAGIC);\n\tf->ea_offs = cpu_to_le16(0xc4);\n\tf->btree.n_free_nodes = 8;\n\tf->btree.first_free = cpu_to_le16(8);\n\treturn f;\n}",
          "includes": [
            "#include \"hpfs_fn.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hpfs_fn.h\"\n\nstruct fnode *hpfs_alloc_fnode(struct super_block *s, secno near, fnode_secno *fno,\n\t\t\t  struct buffer_head **bh)\n{\n\tstruct fnode *f;\n\tif (!(*fno = hpfs_alloc_sector(s, near, 1, FNODE_ALLOC_FWD))) return NULL;\n\tif (!(f = hpfs_get_sector(s, *fno, bh))) {\n\t\thpfs_free_sectors(s, *fno, 1);\n\t\treturn NULL;\n\t}\t\n\tmemset(f, 0, 512);\n\tf->magic = cpu_to_le32(FNODE_MAGIC);\n\tf->ea_offs = cpu_to_le16(0xc4);\n\tf->btree.n_free_nodes = 8;\n\tf->btree.first_free = cpu_to_le16(8);\n\treturn f;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/unistd.h>\n#include <asm/uaccess.h>\n#include \"internal.h\"\n#include <linux/compat.h>\n#include <linux/splice.h>\n#include <linux/pagemap.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/security.h>\n#include <linux/fsnotify.h>\n#include <linux/aio.h>\n#include <linux/uio.h>\n#include <linux/file.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/slab.h>\n\nstatic ssize_t do_loop_readv_writev(struct file *filp, struct iovec *iov,\n\t\tunsigned long nr_segs, loff_t *ppos, io_fn_t fn)\n{\n\tstruct iovec *vector = iov;\n\tssize_t ret = 0;\n\n\twhile (nr_segs > 0) {\n\t\tvoid __user *base;\n\t\tsize_t len;\n\t\tssize_t nr;\n\n\t\tbase = vector->iov_base;\n\t\tlen = vector->iov_len;\n\t\tvector++;\n\t\tnr_segs--;\n\n\t\tnr = fn(filp, base, len, ppos);\n\n\t\tif (nr < 0) {\n\t\t\tif (!ret)\n\t\t\t\tret = nr;\n\t\t\tbreak;\n\t\t}\n\t\tret += nr;\n\t\tif (nr != len)\n\t\t\tbreak;\n\t}\n\n\treturn ret;\n}"
  },
  {
    "function_name": "do_sync_readv_writev",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/read_write.c",
    "lines": "732-747",
    "snippet": "static ssize_t do_sync_readv_writev(struct file *filp, const struct iovec *iov,\n\t\tunsigned long nr_segs, size_t len, loff_t *ppos, iov_fn_t fn)\n{\n\tstruct kiocb kiocb;\n\tssize_t ret;\n\n\tinit_sync_kiocb(&kiocb, filp);\n\tkiocb.ki_pos = *ppos;\n\tkiocb.ki_nbytes = len;\n\n\tret = fn(&kiocb, iov, nr_segs, kiocb.ki_pos);\n\tif (ret == -EIOCBQUEUED)\n\t\tret = wait_on_sync_kiocb(&kiocb);\n\t*ppos = kiocb.ki_pos;\n\treturn ret;\n}",
    "includes": [
      "#include <asm/unistd.h>",
      "#include <asm/uaccess.h>",
      "#include \"internal.h\"",
      "#include <linux/compat.h>",
      "#include <linux/splice.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/export.h>",
      "#include <linux/security.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/aio.h>",
      "#include <linux/uio.h>",
      "#include <linux/file.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/stat.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "wait_on_sync_kiocb",
          "args": [
            "&kiocb"
          ],
          "line": 744
        },
        "resolved": true,
        "details": {
          "function_name": "wait_on_sync_kiocb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/aio.c",
          "lines": "784-794",
          "snippet": "ssize_t wait_on_sync_kiocb(struct kiocb *req)\n{\n\twhile (!req->ki_ctx) {\n\t\tset_current_state(TASK_UNINTERRUPTIBLE);\n\t\tif (req->ki_ctx)\n\t\t\tbreak;\n\t\tio_schedule();\n\t}\n\t__set_current_state(TASK_RUNNING);\n\treturn req->ki_user_data;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <asm/kmap_types.h>",
            "#include <linux/mount.h>",
            "#include <linux/percpu-refcount.h>",
            "#include <linux/ramfs.h>",
            "#include <linux/migrate.h>",
            "#include <linux/compat.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/eventfd.h>",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/highmem.h>",
            "#include <linux/aio.h>",
            "#include <linux/timer.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mmu_context.h>",
            "#include <linux/mman.h>",
            "#include <linux/mm.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/uio.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/export.h>",
            "#include <linux/aio_abi.h>",
            "#include <linux/time.h>",
            "#include <linux/errno.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <asm/kmap_types.h>\n#include <linux/mount.h>\n#include <linux/percpu-refcount.h>\n#include <linux/ramfs.h>\n#include <linux/migrate.h>\n#include <linux/compat.h>\n#include <linux/blkdev.h>\n#include <linux/eventfd.h>\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/highmem.h>\n#include <linux/aio.h>\n#include <linux/timer.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mmu_context.h>\n#include <linux/mman.h>\n#include <linux/mm.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/backing-dev.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/aio_abi.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n\nssize_t wait_on_sync_kiocb(struct kiocb *req)\n{\n\twhile (!req->ki_ctx) {\n\t\tset_current_state(TASK_UNINTERRUPTIBLE);\n\t\tif (req->ki_ctx)\n\t\t\tbreak;\n\t\tio_schedule();\n\t}\n\t__set_current_state(TASK_RUNNING);\n\treturn req->ki_user_data;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fn",
          "args": [
            "&kiocb",
            "iov",
            "nr_segs",
            "kiocb.ki_pos"
          ],
          "line": 742
        },
        "resolved": true,
        "details": {
          "function_name": "hpfs_alloc_fnode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/alloc.c",
          "lines": "453-468",
          "snippet": "struct fnode *hpfs_alloc_fnode(struct super_block *s, secno near, fnode_secno *fno,\n\t\t\t  struct buffer_head **bh)\n{\n\tstruct fnode *f;\n\tif (!(*fno = hpfs_alloc_sector(s, near, 1, FNODE_ALLOC_FWD))) return NULL;\n\tif (!(f = hpfs_get_sector(s, *fno, bh))) {\n\t\thpfs_free_sectors(s, *fno, 1);\n\t\treturn NULL;\n\t}\t\n\tmemset(f, 0, 512);\n\tf->magic = cpu_to_le32(FNODE_MAGIC);\n\tf->ea_offs = cpu_to_le16(0xc4);\n\tf->btree.n_free_nodes = 8;\n\tf->btree.first_free = cpu_to_le16(8);\n\treturn f;\n}",
          "includes": [
            "#include \"hpfs_fn.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hpfs_fn.h\"\n\nstruct fnode *hpfs_alloc_fnode(struct super_block *s, secno near, fnode_secno *fno,\n\t\t\t  struct buffer_head **bh)\n{\n\tstruct fnode *f;\n\tif (!(*fno = hpfs_alloc_sector(s, near, 1, FNODE_ALLOC_FWD))) return NULL;\n\tif (!(f = hpfs_get_sector(s, *fno, bh))) {\n\t\thpfs_free_sectors(s, *fno, 1);\n\t\treturn NULL;\n\t}\t\n\tmemset(f, 0, 512);\n\tf->magic = cpu_to_le32(FNODE_MAGIC);\n\tf->ea_offs = cpu_to_le16(0xc4);\n\tf->btree.n_free_nodes = 8;\n\tf->btree.first_free = cpu_to_le16(8);\n\treturn f;\n}"
        }
      },
      {
        "call_info": {
          "callee": "init_sync_kiocb",
          "args": [
            "&kiocb",
            "filp"
          ],
          "line": 738
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/unistd.h>\n#include <asm/uaccess.h>\n#include \"internal.h\"\n#include <linux/compat.h>\n#include <linux/splice.h>\n#include <linux/pagemap.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/security.h>\n#include <linux/fsnotify.h>\n#include <linux/aio.h>\n#include <linux/uio.h>\n#include <linux/file.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/slab.h>\n\nstatic ssize_t do_sync_readv_writev(struct file *filp, const struct iovec *iov,\n\t\tunsigned long nr_segs, size_t len, loff_t *ppos, iov_fn_t fn)\n{\n\tstruct kiocb kiocb;\n\tssize_t ret;\n\n\tinit_sync_kiocb(&kiocb, filp);\n\tkiocb.ki_pos = *ppos;\n\tkiocb.ki_nbytes = len;\n\n\tret = fn(&kiocb, iov, nr_segs, kiocb.ki_pos);\n\tif (ret == -EIOCBQUEUED)\n\t\tret = wait_on_sync_kiocb(&kiocb);\n\t*ppos = kiocb.ki_pos;\n\treturn ret;\n}"
  },
  {
    "function_name": "do_iter_readv_writev",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/read_write.c",
    "lines": "713-730",
    "snippet": "static ssize_t do_iter_readv_writev(struct file *filp, int rw, const struct iovec *iov,\n\t\tunsigned long nr_segs, size_t len, loff_t *ppos, iter_fn_t fn)\n{\n\tstruct kiocb kiocb;\n\tstruct iov_iter iter;\n\tssize_t ret;\n\n\tinit_sync_kiocb(&kiocb, filp);\n\tkiocb.ki_pos = *ppos;\n\tkiocb.ki_nbytes = len;\n\n\tiov_iter_init(&iter, rw, iov, nr_segs, len);\n\tret = fn(&kiocb, &iter);\n\tif (ret == -EIOCBQUEUED)\n\t\tret = wait_on_sync_kiocb(&kiocb);\n\t*ppos = kiocb.ki_pos;\n\treturn ret;\n}",
    "includes": [
      "#include <asm/unistd.h>",
      "#include <asm/uaccess.h>",
      "#include \"internal.h\"",
      "#include <linux/compat.h>",
      "#include <linux/splice.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/export.h>",
      "#include <linux/security.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/aio.h>",
      "#include <linux/uio.h>",
      "#include <linux/file.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/stat.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "wait_on_sync_kiocb",
          "args": [
            "&kiocb"
          ],
          "line": 727
        },
        "resolved": true,
        "details": {
          "function_name": "wait_on_sync_kiocb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/aio.c",
          "lines": "784-794",
          "snippet": "ssize_t wait_on_sync_kiocb(struct kiocb *req)\n{\n\twhile (!req->ki_ctx) {\n\t\tset_current_state(TASK_UNINTERRUPTIBLE);\n\t\tif (req->ki_ctx)\n\t\t\tbreak;\n\t\tio_schedule();\n\t}\n\t__set_current_state(TASK_RUNNING);\n\treturn req->ki_user_data;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <asm/kmap_types.h>",
            "#include <linux/mount.h>",
            "#include <linux/percpu-refcount.h>",
            "#include <linux/ramfs.h>",
            "#include <linux/migrate.h>",
            "#include <linux/compat.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/eventfd.h>",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/highmem.h>",
            "#include <linux/aio.h>",
            "#include <linux/timer.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mmu_context.h>",
            "#include <linux/mman.h>",
            "#include <linux/mm.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/uio.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/export.h>",
            "#include <linux/aio_abi.h>",
            "#include <linux/time.h>",
            "#include <linux/errno.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <asm/kmap_types.h>\n#include <linux/mount.h>\n#include <linux/percpu-refcount.h>\n#include <linux/ramfs.h>\n#include <linux/migrate.h>\n#include <linux/compat.h>\n#include <linux/blkdev.h>\n#include <linux/eventfd.h>\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/highmem.h>\n#include <linux/aio.h>\n#include <linux/timer.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mmu_context.h>\n#include <linux/mman.h>\n#include <linux/mm.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/backing-dev.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/aio_abi.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n\nssize_t wait_on_sync_kiocb(struct kiocb *req)\n{\n\twhile (!req->ki_ctx) {\n\t\tset_current_state(TASK_UNINTERRUPTIBLE);\n\t\tif (req->ki_ctx)\n\t\t\tbreak;\n\t\tio_schedule();\n\t}\n\t__set_current_state(TASK_RUNNING);\n\treturn req->ki_user_data;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fn",
          "args": [
            "&kiocb",
            "&iter"
          ],
          "line": 725
        },
        "resolved": true,
        "details": {
          "function_name": "kiocb_set_cancel_fn",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/aio.c",
          "lines": "483-496",
          "snippet": "void kiocb_set_cancel_fn(struct kiocb *req, kiocb_cancel_fn *cancel)\n{\n\tstruct kioctx *ctx = req->ki_ctx;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&ctx->ctx_lock, flags);\n\n\tif (!req->ki_list.next)\n\t\tlist_add(&req->ki_list, &ctx->active_reqs);\n\n\treq->ki_cancel = cancel;\n\n\tspin_unlock_irqrestore(&ctx->ctx_lock, flags);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <asm/kmap_types.h>",
            "#include <linux/mount.h>",
            "#include <linux/percpu-refcount.h>",
            "#include <linux/ramfs.h>",
            "#include <linux/migrate.h>",
            "#include <linux/compat.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/eventfd.h>",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/highmem.h>",
            "#include <linux/aio.h>",
            "#include <linux/timer.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mmu_context.h>",
            "#include <linux/mman.h>",
            "#include <linux/mm.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/uio.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/export.h>",
            "#include <linux/aio_abi.h>",
            "#include <linux/time.h>",
            "#include <linux/errno.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <asm/kmap_types.h>\n#include <linux/mount.h>\n#include <linux/percpu-refcount.h>\n#include <linux/ramfs.h>\n#include <linux/migrate.h>\n#include <linux/compat.h>\n#include <linux/blkdev.h>\n#include <linux/eventfd.h>\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/highmem.h>\n#include <linux/aio.h>\n#include <linux/timer.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mmu_context.h>\n#include <linux/mman.h>\n#include <linux/mm.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/backing-dev.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/aio_abi.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n\nvoid kiocb_set_cancel_fn(struct kiocb *req, kiocb_cancel_fn *cancel)\n{\n\tstruct kioctx *ctx = req->ki_ctx;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&ctx->ctx_lock, flags);\n\n\tif (!req->ki_list.next)\n\t\tlist_add(&req->ki_list, &ctx->active_reqs);\n\n\treq->ki_cancel = cancel;\n\n\tspin_unlock_irqrestore(&ctx->ctx_lock, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "iov_iter_init",
          "args": [
            "&iter",
            "rw",
            "iov",
            "nr_segs",
            "len"
          ],
          "line": 724
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "init_sync_kiocb",
          "args": [
            "&kiocb",
            "filp"
          ],
          "line": 720
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/unistd.h>\n#include <asm/uaccess.h>\n#include \"internal.h\"\n#include <linux/compat.h>\n#include <linux/splice.h>\n#include <linux/pagemap.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/security.h>\n#include <linux/fsnotify.h>\n#include <linux/aio.h>\n#include <linux/uio.h>\n#include <linux/file.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/slab.h>\n\nstatic ssize_t do_iter_readv_writev(struct file *filp, int rw, const struct iovec *iov,\n\t\tunsigned long nr_segs, size_t len, loff_t *ppos, iter_fn_t fn)\n{\n\tstruct kiocb kiocb;\n\tstruct iov_iter iter;\n\tssize_t ret;\n\n\tinit_sync_kiocb(&kiocb, filp);\n\tkiocb.ki_pos = *ppos;\n\tkiocb.ki_nbytes = len;\n\n\tiov_iter_init(&iter, rw, iov, nr_segs, len);\n\tret = fn(&kiocb, &iter);\n\tif (ret == -EIOCBQUEUED)\n\t\tret = wait_on_sync_kiocb(&kiocb);\n\t*ppos = kiocb.ki_pos;\n\treturn ret;\n}"
  },
  {
    "function_name": "iov_shorten",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/read_write.c",
    "lines": "695-710",
    "snippet": "unsigned long iov_shorten(struct iovec *iov, unsigned long nr_segs, size_t to)\n{\n\tunsigned long seg = 0;\n\tsize_t len = 0;\n\n\twhile (seg < nr_segs) {\n\t\tseg++;\n\t\tif (len + iov->iov_len >= to) {\n\t\t\tiov->iov_len = to - len;\n\t\t\tbreak;\n\t\t}\n\t\tlen += iov->iov_len;\n\t\tiov++;\n\t}\n\treturn seg;\n}",
    "includes": [
      "#include <asm/unistd.h>",
      "#include <asm/uaccess.h>",
      "#include \"internal.h\"",
      "#include <linux/compat.h>",
      "#include <linux/splice.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/export.h>",
      "#include <linux/security.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/aio.h>",
      "#include <linux/uio.h>",
      "#include <linux/file.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/stat.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <asm/unistd.h>\n#include <asm/uaccess.h>\n#include \"internal.h\"\n#include <linux/compat.h>\n#include <linux/splice.h>\n#include <linux/pagemap.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/security.h>\n#include <linux/fsnotify.h>\n#include <linux/aio.h>\n#include <linux/uio.h>\n#include <linux/file.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/slab.h>\n\nunsigned long iov_shorten(struct iovec *iov, unsigned long nr_segs, size_t to)\n{\n\tunsigned long seg = 0;\n\tsize_t len = 0;\n\n\twhile (seg < nr_segs) {\n\t\tseg++;\n\t\tif (len + iov->iov_len >= to) {\n\t\t\tiov->iov_len = to - len;\n\t\t\tbreak;\n\t\t}\n\t\tlen += iov->iov_len;\n\t\tiov++;\n\t}\n\treturn seg;\n}"
  },
  {
    "function_name": "file_pos_write",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/read_write.c",
    "lines": "615-618",
    "snippet": "static inline void file_pos_write(struct file *file, loff_t pos)\n{\n\tfile->f_pos = pos;\n}",
    "includes": [
      "#include <asm/unistd.h>",
      "#include <asm/uaccess.h>",
      "#include \"internal.h\"",
      "#include <linux/compat.h>",
      "#include <linux/splice.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/export.h>",
      "#include <linux/security.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/aio.h>",
      "#include <linux/uio.h>",
      "#include <linux/file.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/stat.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <asm/unistd.h>\n#include <asm/uaccess.h>\n#include \"internal.h\"\n#include <linux/compat.h>\n#include <linux/splice.h>\n#include <linux/pagemap.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/security.h>\n#include <linux/fsnotify.h>\n#include <linux/aio.h>\n#include <linux/uio.h>\n#include <linux/file.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/slab.h>\n\nstatic inline void file_pos_write(struct file *file, loff_t pos)\n{\n\tfile->f_pos = pos;\n}"
  },
  {
    "function_name": "file_pos_read",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/read_write.c",
    "lines": "610-613",
    "snippet": "static inline loff_t file_pos_read(struct file *file)\n{\n\treturn file->f_pos;\n}",
    "includes": [
      "#include <asm/unistd.h>",
      "#include <asm/uaccess.h>",
      "#include \"internal.h\"",
      "#include <linux/compat.h>",
      "#include <linux/splice.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/export.h>",
      "#include <linux/security.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/aio.h>",
      "#include <linux/uio.h>",
      "#include <linux/file.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/stat.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <asm/unistd.h>\n#include <asm/uaccess.h>\n#include \"internal.h\"\n#include <linux/compat.h>\n#include <linux/splice.h>\n#include <linux/pagemap.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/security.h>\n#include <linux/fsnotify.h>\n#include <linux/aio.h>\n#include <linux/uio.h>\n#include <linux/file.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/slab.h>\n\nstatic inline loff_t file_pos_read(struct file *file)\n{\n\treturn file->f_pos;\n}"
  },
  {
    "function_name": "vfs_write",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/read_write.c",
    "lines": "576-606",
    "snippet": "ssize_t vfs_write(struct file *file, const char __user *buf, size_t count, loff_t *pos)\n{\n\tssize_t ret;\n\n\tif (!(file->f_mode & FMODE_WRITE))\n\t\treturn -EBADF;\n\tif (!(file->f_mode & FMODE_CAN_WRITE))\n\t\treturn -EINVAL;\n\tif (unlikely(!access_ok(VERIFY_READ, buf, count)))\n\t\treturn -EFAULT;\n\n\tret = rw_verify_area(WRITE, file, pos, count);\n\tif (ret >= 0) {\n\t\tcount = ret;\n\t\tfile_start_write(file);\n\t\tif (file->f_op->write)\n\t\t\tret = file->f_op->write(file, buf, count, pos);\n\t\telse if (file->f_op->aio_write)\n\t\t\tret = do_sync_write(file, buf, count, pos);\n\t\telse\n\t\t\tret = new_sync_write(file, buf, count, pos);\n\t\tif (ret > 0) {\n\t\t\tfsnotify_modify(file);\n\t\t\tadd_wchar(current, ret);\n\t\t}\n\t\tinc_syscw(current);\n\t\tfile_end_write(file);\n\t}\n\n\treturn ret;\n}",
    "includes": [
      "#include <asm/unistd.h>",
      "#include <asm/uaccess.h>",
      "#include \"internal.h\"",
      "#include <linux/compat.h>",
      "#include <linux/splice.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/export.h>",
      "#include <linux/security.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/aio.h>",
      "#include <linux/uio.h>",
      "#include <linux/file.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/stat.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "file_end_write",
          "args": [
            "file"
          ],
          "line": 602
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "inc_syscw",
          "args": [
            "current"
          ],
          "line": 601
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "add_wchar",
          "args": [
            "current",
            "ret"
          ],
          "line": 599
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fsnotify_modify",
          "args": [
            "file"
          ],
          "line": 598
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "new_sync_write",
          "args": [
            "file",
            "buf",
            "count",
            "pos"
          ],
          "line": 596
        },
        "resolved": true,
        "details": {
          "function_name": "new_sync_write",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/read_write.c",
          "lines": "524-541",
          "snippet": "ssize_t new_sync_write(struct file *filp, const char __user *buf, size_t len, loff_t *ppos)\n{\n\tstruct iovec iov = { .iov_base = (void __user *)buf, .iov_len = len };\n\tstruct kiocb kiocb;\n\tstruct iov_iter iter;\n\tssize_t ret;\n\n\tinit_sync_kiocb(&kiocb, filp);\n\tkiocb.ki_pos = *ppos;\n\tkiocb.ki_nbytes = len;\n\tiov_iter_init(&iter, WRITE, &iov, 1, len);\n\n\tret = filp->f_op->write_iter(&kiocb, &iter);\n\tif (-EIOCBQUEUED == ret)\n\t\tret = wait_on_sync_kiocb(&kiocb);\n\t*ppos = kiocb.ki_pos;\n\treturn ret;\n}",
          "includes": [
            "#include <asm/unistd.h>",
            "#include <asm/uaccess.h>",
            "#include \"internal.h\"",
            "#include <linux/compat.h>",
            "#include <linux/splice.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/export.h>",
            "#include <linux/security.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/aio.h>",
            "#include <linux/uio.h>",
            "#include <linux/file.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/stat.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/unistd.h>\n#include <asm/uaccess.h>\n#include \"internal.h\"\n#include <linux/compat.h>\n#include <linux/splice.h>\n#include <linux/pagemap.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/security.h>\n#include <linux/fsnotify.h>\n#include <linux/aio.h>\n#include <linux/uio.h>\n#include <linux/file.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/slab.h>\n\nssize_t new_sync_write(struct file *filp, const char __user *buf, size_t len, loff_t *ppos)\n{\n\tstruct iovec iov = { .iov_base = (void __user *)buf, .iov_len = len };\n\tstruct kiocb kiocb;\n\tstruct iov_iter iter;\n\tssize_t ret;\n\n\tinit_sync_kiocb(&kiocb, filp);\n\tkiocb.ki_pos = *ppos;\n\tkiocb.ki_nbytes = len;\n\tiov_iter_init(&iter, WRITE, &iov, 1, len);\n\n\tret = filp->f_op->write_iter(&kiocb, &iter);\n\tif (-EIOCBQUEUED == ret)\n\t\tret = wait_on_sync_kiocb(&kiocb);\n\t*ppos = kiocb.ki_pos;\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "do_sync_write",
          "args": [
            "file",
            "buf",
            "count",
            "pos"
          ],
          "line": 594
        },
        "resolved": true,
        "details": {
          "function_name": "do_sync_write",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/read_write.c",
          "lines": "505-520",
          "snippet": "ssize_t do_sync_write(struct file *filp, const char __user *buf, size_t len, loff_t *ppos)\n{\n\tstruct iovec iov = { .iov_base = (void __user *)buf, .iov_len = len };\n\tstruct kiocb kiocb;\n\tssize_t ret;\n\n\tinit_sync_kiocb(&kiocb, filp);\n\tkiocb.ki_pos = *ppos;\n\tkiocb.ki_nbytes = len;\n\n\tret = filp->f_op->aio_write(&kiocb, &iov, 1, kiocb.ki_pos);\n\tif (-EIOCBQUEUED == ret)\n\t\tret = wait_on_sync_kiocb(&kiocb);\n\t*ppos = kiocb.ki_pos;\n\treturn ret;\n}",
          "includes": [
            "#include <asm/unistd.h>",
            "#include <asm/uaccess.h>",
            "#include \"internal.h\"",
            "#include <linux/compat.h>",
            "#include <linux/splice.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/export.h>",
            "#include <linux/security.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/aio.h>",
            "#include <linux/uio.h>",
            "#include <linux/file.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/stat.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/unistd.h>\n#include <asm/uaccess.h>\n#include \"internal.h\"\n#include <linux/compat.h>\n#include <linux/splice.h>\n#include <linux/pagemap.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/security.h>\n#include <linux/fsnotify.h>\n#include <linux/aio.h>\n#include <linux/uio.h>\n#include <linux/file.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/slab.h>\n\nssize_t do_sync_write(struct file *filp, const char __user *buf, size_t len, loff_t *ppos)\n{\n\tstruct iovec iov = { .iov_base = (void __user *)buf, .iov_len = len };\n\tstruct kiocb kiocb;\n\tssize_t ret;\n\n\tinit_sync_kiocb(&kiocb, filp);\n\tkiocb.ki_pos = *ppos;\n\tkiocb.ki_nbytes = len;\n\n\tret = filp->f_op->aio_write(&kiocb, &iov, 1, kiocb.ki_pos);\n\tif (-EIOCBQUEUED == ret)\n\t\tret = wait_on_sync_kiocb(&kiocb);\n\t*ppos = kiocb.ki_pos;\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "file->f_op->write",
          "args": [
            "file",
            "buf",
            "count",
            "pos"
          ],
          "line": 592
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "file_start_write",
          "args": [
            "file"
          ],
          "line": 590
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rw_verify_area",
          "args": [
            "WRITE",
            "file",
            "pos",
            "count"
          ],
          "line": 587
        },
        "resolved": true,
        "details": {
          "function_name": "rw_verify_area",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/read_write.c",
          "lines": "387-419",
          "snippet": "int rw_verify_area(int read_write, struct file *file, const loff_t *ppos, size_t count)\n{\n\tstruct inode *inode;\n\tloff_t pos;\n\tint retval = -EINVAL;\n\n\tinode = file_inode(file);\n\tif (unlikely((ssize_t) count < 0))\n\t\treturn retval;\n\tpos = *ppos;\n\tif (unlikely(pos < 0)) {\n\t\tif (!unsigned_offsets(file))\n\t\t\treturn retval;\n\t\tif (count >= -pos) /* both values are in 0..LLONG_MAX */\n\t\t\treturn -EOVERFLOW;\n\t} else if (unlikely((loff_t) (pos + count) < 0)) {\n\t\tif (!unsigned_offsets(file))\n\t\t\treturn retval;\n\t}\n\n\tif (unlikely(inode->i_flctx && mandatory_lock(inode))) {\n\t\tretval = locks_mandatory_area(\n\t\t\tread_write == READ ? FLOCK_VERIFY_READ : FLOCK_VERIFY_WRITE,\n\t\t\tinode, file, pos, count);\n\t\tif (retval < 0)\n\t\t\treturn retval;\n\t}\n\tretval = security_file_permission(file,\n\t\t\t\tread_write == READ ? MAY_READ : MAY_WRITE);\n\tif (retval)\n\t\treturn retval;\n\treturn count > MAX_RW_COUNT ? MAX_RW_COUNT : count;\n}",
          "includes": [
            "#include <asm/unistd.h>",
            "#include <asm/uaccess.h>",
            "#include \"internal.h\"",
            "#include <linux/compat.h>",
            "#include <linux/splice.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/export.h>",
            "#include <linux/security.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/aio.h>",
            "#include <linux/uio.h>",
            "#include <linux/file.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/stat.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/unistd.h>\n#include <asm/uaccess.h>\n#include \"internal.h\"\n#include <linux/compat.h>\n#include <linux/splice.h>\n#include <linux/pagemap.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/security.h>\n#include <linux/fsnotify.h>\n#include <linux/aio.h>\n#include <linux/uio.h>\n#include <linux/file.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/slab.h>\n\nint rw_verify_area(int read_write, struct file *file, const loff_t *ppos, size_t count)\n{\n\tstruct inode *inode;\n\tloff_t pos;\n\tint retval = -EINVAL;\n\n\tinode = file_inode(file);\n\tif (unlikely((ssize_t) count < 0))\n\t\treturn retval;\n\tpos = *ppos;\n\tif (unlikely(pos < 0)) {\n\t\tif (!unsigned_offsets(file))\n\t\t\treturn retval;\n\t\tif (count >= -pos) /* both values are in 0..LLONG_MAX */\n\t\t\treturn -EOVERFLOW;\n\t} else if (unlikely((loff_t) (pos + count) < 0)) {\n\t\tif (!unsigned_offsets(file))\n\t\t\treturn retval;\n\t}\n\n\tif (unlikely(inode->i_flctx && mandatory_lock(inode))) {\n\t\tretval = locks_mandatory_area(\n\t\t\tread_write == READ ? FLOCK_VERIFY_READ : FLOCK_VERIFY_WRITE,\n\t\t\tinode, file, pos, count);\n\t\tif (retval < 0)\n\t\t\treturn retval;\n\t}\n\tretval = security_file_permission(file,\n\t\t\t\tread_write == READ ? MAY_READ : MAY_WRITE);\n\tif (retval)\n\t\treturn retval;\n\treturn count > MAX_RW_COUNT ? MAX_RW_COUNT : count;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!access_ok(VERIFY_READ, buf, count)"
          ],
          "line": 584
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "access_ok",
          "args": [
            "VERIFY_READ",
            "buf",
            "count"
          ],
          "line": 584
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/unistd.h>\n#include <asm/uaccess.h>\n#include \"internal.h\"\n#include <linux/compat.h>\n#include <linux/splice.h>\n#include <linux/pagemap.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/security.h>\n#include <linux/fsnotify.h>\n#include <linux/aio.h>\n#include <linux/uio.h>\n#include <linux/file.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/slab.h>\n\nssize_t vfs_write(struct file *file, const char __user *buf, size_t count, loff_t *pos)\n{\n\tssize_t ret;\n\n\tif (!(file->f_mode & FMODE_WRITE))\n\t\treturn -EBADF;\n\tif (!(file->f_mode & FMODE_CAN_WRITE))\n\t\treturn -EINVAL;\n\tif (unlikely(!access_ok(VERIFY_READ, buf, count)))\n\t\treturn -EFAULT;\n\n\tret = rw_verify_area(WRITE, file, pos, count);\n\tif (ret >= 0) {\n\t\tcount = ret;\n\t\tfile_start_write(file);\n\t\tif (file->f_op->write)\n\t\t\tret = file->f_op->write(file, buf, count, pos);\n\t\telse if (file->f_op->aio_write)\n\t\t\tret = do_sync_write(file, buf, count, pos);\n\t\telse\n\t\t\tret = new_sync_write(file, buf, count, pos);\n\t\tif (ret > 0) {\n\t\t\tfsnotify_modify(file);\n\t\t\tadd_wchar(current, ret);\n\t\t}\n\t\tinc_syscw(current);\n\t\tfile_end_write(file);\n\t}\n\n\treturn ret;\n}"
  },
  {
    "function_name": "__kernel_write",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/read_write.c",
    "lines": "545-572",
    "snippet": "ssize_t __kernel_write(struct file *file, const char *buf, size_t count, loff_t *pos)\n{\n\tmm_segment_t old_fs;\n\tconst char __user *p;\n\tssize_t ret;\n\n\tif (!(file->f_mode & FMODE_CAN_WRITE))\n\t\treturn -EINVAL;\n\n\told_fs = get_fs();\n\tset_fs(get_ds());\n\tp = (__force const char __user *)buf;\n\tif (count > MAX_RW_COUNT)\n\t\tcount =  MAX_RW_COUNT;\n\tif (file->f_op->write)\n\t\tret = file->f_op->write(file, p, count, pos);\n\telse if (file->f_op->aio_write)\n\t\tret = do_sync_write(file, p, count, pos);\n\telse\n\t\tret = new_sync_write(file, p, count, pos);\n\tset_fs(old_fs);\n\tif (ret > 0) {\n\t\tfsnotify_modify(file);\n\t\tadd_wchar(current, ret);\n\t}\n\tinc_syscw(current);\n\treturn ret;\n}",
    "includes": [
      "#include <asm/unistd.h>",
      "#include <asm/uaccess.h>",
      "#include \"internal.h\"",
      "#include <linux/compat.h>",
      "#include <linux/splice.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/export.h>",
      "#include <linux/security.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/aio.h>",
      "#include <linux/uio.h>",
      "#include <linux/file.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/stat.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "inc_syscw",
          "args": [
            "current"
          ],
          "line": 570
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "add_wchar",
          "args": [
            "current",
            "ret"
          ],
          "line": 568
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fsnotify_modify",
          "args": [
            "file"
          ],
          "line": 567
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_fs",
          "args": [
            "old_fs"
          ],
          "line": 565
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "new_sync_write",
          "args": [
            "file",
            "p",
            "count",
            "pos"
          ],
          "line": 564
        },
        "resolved": true,
        "details": {
          "function_name": "new_sync_write",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/read_write.c",
          "lines": "524-541",
          "snippet": "ssize_t new_sync_write(struct file *filp, const char __user *buf, size_t len, loff_t *ppos)\n{\n\tstruct iovec iov = { .iov_base = (void __user *)buf, .iov_len = len };\n\tstruct kiocb kiocb;\n\tstruct iov_iter iter;\n\tssize_t ret;\n\n\tinit_sync_kiocb(&kiocb, filp);\n\tkiocb.ki_pos = *ppos;\n\tkiocb.ki_nbytes = len;\n\tiov_iter_init(&iter, WRITE, &iov, 1, len);\n\n\tret = filp->f_op->write_iter(&kiocb, &iter);\n\tif (-EIOCBQUEUED == ret)\n\t\tret = wait_on_sync_kiocb(&kiocb);\n\t*ppos = kiocb.ki_pos;\n\treturn ret;\n}",
          "includes": [
            "#include <asm/unistd.h>",
            "#include <asm/uaccess.h>",
            "#include \"internal.h\"",
            "#include <linux/compat.h>",
            "#include <linux/splice.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/export.h>",
            "#include <linux/security.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/aio.h>",
            "#include <linux/uio.h>",
            "#include <linux/file.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/stat.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/unistd.h>\n#include <asm/uaccess.h>\n#include \"internal.h\"\n#include <linux/compat.h>\n#include <linux/splice.h>\n#include <linux/pagemap.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/security.h>\n#include <linux/fsnotify.h>\n#include <linux/aio.h>\n#include <linux/uio.h>\n#include <linux/file.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/slab.h>\n\nssize_t new_sync_write(struct file *filp, const char __user *buf, size_t len, loff_t *ppos)\n{\n\tstruct iovec iov = { .iov_base = (void __user *)buf, .iov_len = len };\n\tstruct kiocb kiocb;\n\tstruct iov_iter iter;\n\tssize_t ret;\n\n\tinit_sync_kiocb(&kiocb, filp);\n\tkiocb.ki_pos = *ppos;\n\tkiocb.ki_nbytes = len;\n\tiov_iter_init(&iter, WRITE, &iov, 1, len);\n\n\tret = filp->f_op->write_iter(&kiocb, &iter);\n\tif (-EIOCBQUEUED == ret)\n\t\tret = wait_on_sync_kiocb(&kiocb);\n\t*ppos = kiocb.ki_pos;\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "do_sync_write",
          "args": [
            "file",
            "p",
            "count",
            "pos"
          ],
          "line": 562
        },
        "resolved": true,
        "details": {
          "function_name": "do_sync_write",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/read_write.c",
          "lines": "505-520",
          "snippet": "ssize_t do_sync_write(struct file *filp, const char __user *buf, size_t len, loff_t *ppos)\n{\n\tstruct iovec iov = { .iov_base = (void __user *)buf, .iov_len = len };\n\tstruct kiocb kiocb;\n\tssize_t ret;\n\n\tinit_sync_kiocb(&kiocb, filp);\n\tkiocb.ki_pos = *ppos;\n\tkiocb.ki_nbytes = len;\n\n\tret = filp->f_op->aio_write(&kiocb, &iov, 1, kiocb.ki_pos);\n\tif (-EIOCBQUEUED == ret)\n\t\tret = wait_on_sync_kiocb(&kiocb);\n\t*ppos = kiocb.ki_pos;\n\treturn ret;\n}",
          "includes": [
            "#include <asm/unistd.h>",
            "#include <asm/uaccess.h>",
            "#include \"internal.h\"",
            "#include <linux/compat.h>",
            "#include <linux/splice.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/export.h>",
            "#include <linux/security.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/aio.h>",
            "#include <linux/uio.h>",
            "#include <linux/file.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/stat.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/unistd.h>\n#include <asm/uaccess.h>\n#include \"internal.h\"\n#include <linux/compat.h>\n#include <linux/splice.h>\n#include <linux/pagemap.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/security.h>\n#include <linux/fsnotify.h>\n#include <linux/aio.h>\n#include <linux/uio.h>\n#include <linux/file.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/slab.h>\n\nssize_t do_sync_write(struct file *filp, const char __user *buf, size_t len, loff_t *ppos)\n{\n\tstruct iovec iov = { .iov_base = (void __user *)buf, .iov_len = len };\n\tstruct kiocb kiocb;\n\tssize_t ret;\n\n\tinit_sync_kiocb(&kiocb, filp);\n\tkiocb.ki_pos = *ppos;\n\tkiocb.ki_nbytes = len;\n\n\tret = filp->f_op->aio_write(&kiocb, &iov, 1, kiocb.ki_pos);\n\tif (-EIOCBQUEUED == ret)\n\t\tret = wait_on_sync_kiocb(&kiocb);\n\t*ppos = kiocb.ki_pos;\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "file->f_op->write",
          "args": [
            "file",
            "p",
            "count",
            "pos"
          ],
          "line": 560
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_fs",
          "args": [
            "get_ds()"
          ],
          "line": 555
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_ds",
          "args": [],
          "line": 555
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_fs",
          "args": [],
          "line": 554
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/unistd.h>\n#include <asm/uaccess.h>\n#include \"internal.h\"\n#include <linux/compat.h>\n#include <linux/splice.h>\n#include <linux/pagemap.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/security.h>\n#include <linux/fsnotify.h>\n#include <linux/aio.h>\n#include <linux/uio.h>\n#include <linux/file.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/slab.h>\n\nssize_t __kernel_write(struct file *file, const char *buf, size_t count, loff_t *pos)\n{\n\tmm_segment_t old_fs;\n\tconst char __user *p;\n\tssize_t ret;\n\n\tif (!(file->f_mode & FMODE_CAN_WRITE))\n\t\treturn -EINVAL;\n\n\told_fs = get_fs();\n\tset_fs(get_ds());\n\tp = (__force const char __user *)buf;\n\tif (count > MAX_RW_COUNT)\n\t\tcount =  MAX_RW_COUNT;\n\tif (file->f_op->write)\n\t\tret = file->f_op->write(file, p, count, pos);\n\telse if (file->f_op->aio_write)\n\t\tret = do_sync_write(file, p, count, pos);\n\telse\n\t\tret = new_sync_write(file, p, count, pos);\n\tset_fs(old_fs);\n\tif (ret > 0) {\n\t\tfsnotify_modify(file);\n\t\tadd_wchar(current, ret);\n\t}\n\tinc_syscw(current);\n\treturn ret;\n}"
  },
  {
    "function_name": "new_sync_write",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/read_write.c",
    "lines": "524-541",
    "snippet": "ssize_t new_sync_write(struct file *filp, const char __user *buf, size_t len, loff_t *ppos)\n{\n\tstruct iovec iov = { .iov_base = (void __user *)buf, .iov_len = len };\n\tstruct kiocb kiocb;\n\tstruct iov_iter iter;\n\tssize_t ret;\n\n\tinit_sync_kiocb(&kiocb, filp);\n\tkiocb.ki_pos = *ppos;\n\tkiocb.ki_nbytes = len;\n\tiov_iter_init(&iter, WRITE, &iov, 1, len);\n\n\tret = filp->f_op->write_iter(&kiocb, &iter);\n\tif (-EIOCBQUEUED == ret)\n\t\tret = wait_on_sync_kiocb(&kiocb);\n\t*ppos = kiocb.ki_pos;\n\treturn ret;\n}",
    "includes": [
      "#include <asm/unistd.h>",
      "#include <asm/uaccess.h>",
      "#include \"internal.h\"",
      "#include <linux/compat.h>",
      "#include <linux/splice.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/export.h>",
      "#include <linux/security.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/aio.h>",
      "#include <linux/uio.h>",
      "#include <linux/file.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/stat.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "wait_on_sync_kiocb",
          "args": [
            "&kiocb"
          ],
          "line": 538
        },
        "resolved": true,
        "details": {
          "function_name": "wait_on_sync_kiocb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/aio.c",
          "lines": "784-794",
          "snippet": "ssize_t wait_on_sync_kiocb(struct kiocb *req)\n{\n\twhile (!req->ki_ctx) {\n\t\tset_current_state(TASK_UNINTERRUPTIBLE);\n\t\tif (req->ki_ctx)\n\t\t\tbreak;\n\t\tio_schedule();\n\t}\n\t__set_current_state(TASK_RUNNING);\n\treturn req->ki_user_data;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <asm/kmap_types.h>",
            "#include <linux/mount.h>",
            "#include <linux/percpu-refcount.h>",
            "#include <linux/ramfs.h>",
            "#include <linux/migrate.h>",
            "#include <linux/compat.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/eventfd.h>",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/highmem.h>",
            "#include <linux/aio.h>",
            "#include <linux/timer.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mmu_context.h>",
            "#include <linux/mman.h>",
            "#include <linux/mm.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/uio.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/export.h>",
            "#include <linux/aio_abi.h>",
            "#include <linux/time.h>",
            "#include <linux/errno.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <asm/kmap_types.h>\n#include <linux/mount.h>\n#include <linux/percpu-refcount.h>\n#include <linux/ramfs.h>\n#include <linux/migrate.h>\n#include <linux/compat.h>\n#include <linux/blkdev.h>\n#include <linux/eventfd.h>\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/highmem.h>\n#include <linux/aio.h>\n#include <linux/timer.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mmu_context.h>\n#include <linux/mman.h>\n#include <linux/mm.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/backing-dev.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/aio_abi.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n\nssize_t wait_on_sync_kiocb(struct kiocb *req)\n{\n\twhile (!req->ki_ctx) {\n\t\tset_current_state(TASK_UNINTERRUPTIBLE);\n\t\tif (req->ki_ctx)\n\t\t\tbreak;\n\t\tio_schedule();\n\t}\n\t__set_current_state(TASK_RUNNING);\n\treturn req->ki_user_data;\n}"
        }
      },
      {
        "call_info": {
          "callee": "filp->f_op->write_iter",
          "args": [
            "&kiocb",
            "&iter"
          ],
          "line": 536
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "iov_iter_init",
          "args": [
            "&iter",
            "WRITE",
            "&iov",
            "1",
            "len"
          ],
          "line": 534
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "init_sync_kiocb",
          "args": [
            "&kiocb",
            "filp"
          ],
          "line": 531
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/unistd.h>\n#include <asm/uaccess.h>\n#include \"internal.h\"\n#include <linux/compat.h>\n#include <linux/splice.h>\n#include <linux/pagemap.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/security.h>\n#include <linux/fsnotify.h>\n#include <linux/aio.h>\n#include <linux/uio.h>\n#include <linux/file.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/slab.h>\n\nssize_t new_sync_write(struct file *filp, const char __user *buf, size_t len, loff_t *ppos)\n{\n\tstruct iovec iov = { .iov_base = (void __user *)buf, .iov_len = len };\n\tstruct kiocb kiocb;\n\tstruct iov_iter iter;\n\tssize_t ret;\n\n\tinit_sync_kiocb(&kiocb, filp);\n\tkiocb.ki_pos = *ppos;\n\tkiocb.ki_nbytes = len;\n\tiov_iter_init(&iter, WRITE, &iov, 1, len);\n\n\tret = filp->f_op->write_iter(&kiocb, &iter);\n\tif (-EIOCBQUEUED == ret)\n\t\tret = wait_on_sync_kiocb(&kiocb);\n\t*ppos = kiocb.ki_pos;\n\treturn ret;\n}"
  },
  {
    "function_name": "do_sync_write",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/read_write.c",
    "lines": "505-520",
    "snippet": "ssize_t do_sync_write(struct file *filp, const char __user *buf, size_t len, loff_t *ppos)\n{\n\tstruct iovec iov = { .iov_base = (void __user *)buf, .iov_len = len };\n\tstruct kiocb kiocb;\n\tssize_t ret;\n\n\tinit_sync_kiocb(&kiocb, filp);\n\tkiocb.ki_pos = *ppos;\n\tkiocb.ki_nbytes = len;\n\n\tret = filp->f_op->aio_write(&kiocb, &iov, 1, kiocb.ki_pos);\n\tif (-EIOCBQUEUED == ret)\n\t\tret = wait_on_sync_kiocb(&kiocb);\n\t*ppos = kiocb.ki_pos;\n\treturn ret;\n}",
    "includes": [
      "#include <asm/unistd.h>",
      "#include <asm/uaccess.h>",
      "#include \"internal.h\"",
      "#include <linux/compat.h>",
      "#include <linux/splice.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/export.h>",
      "#include <linux/security.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/aio.h>",
      "#include <linux/uio.h>",
      "#include <linux/file.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/stat.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "wait_on_sync_kiocb",
          "args": [
            "&kiocb"
          ],
          "line": 517
        },
        "resolved": true,
        "details": {
          "function_name": "wait_on_sync_kiocb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/aio.c",
          "lines": "784-794",
          "snippet": "ssize_t wait_on_sync_kiocb(struct kiocb *req)\n{\n\twhile (!req->ki_ctx) {\n\t\tset_current_state(TASK_UNINTERRUPTIBLE);\n\t\tif (req->ki_ctx)\n\t\t\tbreak;\n\t\tio_schedule();\n\t}\n\t__set_current_state(TASK_RUNNING);\n\treturn req->ki_user_data;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <asm/kmap_types.h>",
            "#include <linux/mount.h>",
            "#include <linux/percpu-refcount.h>",
            "#include <linux/ramfs.h>",
            "#include <linux/migrate.h>",
            "#include <linux/compat.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/eventfd.h>",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/highmem.h>",
            "#include <linux/aio.h>",
            "#include <linux/timer.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mmu_context.h>",
            "#include <linux/mman.h>",
            "#include <linux/mm.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/uio.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/export.h>",
            "#include <linux/aio_abi.h>",
            "#include <linux/time.h>",
            "#include <linux/errno.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <asm/kmap_types.h>\n#include <linux/mount.h>\n#include <linux/percpu-refcount.h>\n#include <linux/ramfs.h>\n#include <linux/migrate.h>\n#include <linux/compat.h>\n#include <linux/blkdev.h>\n#include <linux/eventfd.h>\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/highmem.h>\n#include <linux/aio.h>\n#include <linux/timer.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mmu_context.h>\n#include <linux/mman.h>\n#include <linux/mm.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/backing-dev.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/aio_abi.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n\nssize_t wait_on_sync_kiocb(struct kiocb *req)\n{\n\twhile (!req->ki_ctx) {\n\t\tset_current_state(TASK_UNINTERRUPTIBLE);\n\t\tif (req->ki_ctx)\n\t\t\tbreak;\n\t\tio_schedule();\n\t}\n\t__set_current_state(TASK_RUNNING);\n\treturn req->ki_user_data;\n}"
        }
      },
      {
        "call_info": {
          "callee": "filp->f_op->aio_write",
          "args": [
            "&kiocb",
            "&iov",
            "1",
            "kiocb.ki_pos"
          ],
          "line": 515
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "init_sync_kiocb",
          "args": [
            "&kiocb",
            "filp"
          ],
          "line": 511
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/unistd.h>\n#include <asm/uaccess.h>\n#include \"internal.h\"\n#include <linux/compat.h>\n#include <linux/splice.h>\n#include <linux/pagemap.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/security.h>\n#include <linux/fsnotify.h>\n#include <linux/aio.h>\n#include <linux/uio.h>\n#include <linux/file.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/slab.h>\n\nssize_t do_sync_write(struct file *filp, const char __user *buf, size_t len, loff_t *ppos)\n{\n\tstruct iovec iov = { .iov_base = (void __user *)buf, .iov_len = len };\n\tstruct kiocb kiocb;\n\tssize_t ret;\n\n\tinit_sync_kiocb(&kiocb, filp);\n\tkiocb.ki_pos = *ppos;\n\tkiocb.ki_nbytes = len;\n\n\tret = filp->f_op->aio_write(&kiocb, &iov, 1, kiocb.ki_pos);\n\tif (-EIOCBQUEUED == ret)\n\t\tret = wait_on_sync_kiocb(&kiocb);\n\t*ppos = kiocb.ki_pos;\n\treturn ret;\n}"
  },
  {
    "function_name": "vfs_read",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/read_write.c",
    "lines": "478-501",
    "snippet": "ssize_t vfs_read(struct file *file, char __user *buf, size_t count, loff_t *pos)\n{\n\tssize_t ret;\n\n\tif (!(file->f_mode & FMODE_READ))\n\t\treturn -EBADF;\n\tif (!(file->f_mode & FMODE_CAN_READ))\n\t\treturn -EINVAL;\n\tif (unlikely(!access_ok(VERIFY_WRITE, buf, count)))\n\t\treturn -EFAULT;\n\n\tret = rw_verify_area(READ, file, pos, count);\n\tif (ret >= 0) {\n\t\tcount = ret;\n\t\tret = __vfs_read(file, buf, count, pos);\n\t\tif (ret > 0) {\n\t\t\tfsnotify_access(file);\n\t\t\tadd_rchar(current, ret);\n\t\t}\n\t\tinc_syscr(current);\n\t}\n\n\treturn ret;\n}",
    "includes": [
      "#include <asm/unistd.h>",
      "#include <asm/uaccess.h>",
      "#include \"internal.h\"",
      "#include <linux/compat.h>",
      "#include <linux/splice.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/export.h>",
      "#include <linux/security.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/aio.h>",
      "#include <linux/uio.h>",
      "#include <linux/file.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/stat.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "inc_syscr",
          "args": [
            "current"
          ],
          "line": 497
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "add_rchar",
          "args": [
            "current",
            "ret"
          ],
          "line": 495
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fsnotify_access",
          "args": [
            "file"
          ],
          "line": 494
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__vfs_read",
          "args": [
            "file",
            "buf",
            "count",
            "pos"
          ],
          "line": 492
        },
        "resolved": true,
        "details": {
          "function_name": "__vfs_read",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/read_write.c",
          "lines": "461-476",
          "snippet": "ssize_t __vfs_read(struct file *file, char __user *buf, size_t count,\n\t\t   loff_t *pos)\n{\n\tssize_t ret;\n\n\tif (file->f_op->read)\n\t\tret = file->f_op->read(file, buf, count, pos);\n\telse if (file->f_op->aio_read)\n\t\tret = do_sync_read(file, buf, count, pos);\n\telse if (file->f_op->read_iter)\n\t\tret = new_sync_read(file, buf, count, pos);\n\telse\n\t\tret = -EINVAL;\n\n\treturn ret;\n}",
          "includes": [
            "#include <asm/unistd.h>",
            "#include <asm/uaccess.h>",
            "#include \"internal.h\"",
            "#include <linux/compat.h>",
            "#include <linux/splice.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/export.h>",
            "#include <linux/security.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/aio.h>",
            "#include <linux/uio.h>",
            "#include <linux/file.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/stat.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/unistd.h>\n#include <asm/uaccess.h>\n#include \"internal.h\"\n#include <linux/compat.h>\n#include <linux/splice.h>\n#include <linux/pagemap.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/security.h>\n#include <linux/fsnotify.h>\n#include <linux/aio.h>\n#include <linux/uio.h>\n#include <linux/file.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/slab.h>\n\nssize_t __vfs_read(struct file *file, char __user *buf, size_t count,\n\t\t   loff_t *pos)\n{\n\tssize_t ret;\n\n\tif (file->f_op->read)\n\t\tret = file->f_op->read(file, buf, count, pos);\n\telse if (file->f_op->aio_read)\n\t\tret = do_sync_read(file, buf, count, pos);\n\telse if (file->f_op->read_iter)\n\t\tret = new_sync_read(file, buf, count, pos);\n\telse\n\t\tret = -EINVAL;\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rw_verify_area",
          "args": [
            "READ",
            "file",
            "pos",
            "count"
          ],
          "line": 489
        },
        "resolved": true,
        "details": {
          "function_name": "rw_verify_area",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/read_write.c",
          "lines": "387-419",
          "snippet": "int rw_verify_area(int read_write, struct file *file, const loff_t *ppos, size_t count)\n{\n\tstruct inode *inode;\n\tloff_t pos;\n\tint retval = -EINVAL;\n\n\tinode = file_inode(file);\n\tif (unlikely((ssize_t) count < 0))\n\t\treturn retval;\n\tpos = *ppos;\n\tif (unlikely(pos < 0)) {\n\t\tif (!unsigned_offsets(file))\n\t\t\treturn retval;\n\t\tif (count >= -pos) /* both values are in 0..LLONG_MAX */\n\t\t\treturn -EOVERFLOW;\n\t} else if (unlikely((loff_t) (pos + count) < 0)) {\n\t\tif (!unsigned_offsets(file))\n\t\t\treturn retval;\n\t}\n\n\tif (unlikely(inode->i_flctx && mandatory_lock(inode))) {\n\t\tretval = locks_mandatory_area(\n\t\t\tread_write == READ ? FLOCK_VERIFY_READ : FLOCK_VERIFY_WRITE,\n\t\t\tinode, file, pos, count);\n\t\tif (retval < 0)\n\t\t\treturn retval;\n\t}\n\tretval = security_file_permission(file,\n\t\t\t\tread_write == READ ? MAY_READ : MAY_WRITE);\n\tif (retval)\n\t\treturn retval;\n\treturn count > MAX_RW_COUNT ? MAX_RW_COUNT : count;\n}",
          "includes": [
            "#include <asm/unistd.h>",
            "#include <asm/uaccess.h>",
            "#include \"internal.h\"",
            "#include <linux/compat.h>",
            "#include <linux/splice.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/export.h>",
            "#include <linux/security.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/aio.h>",
            "#include <linux/uio.h>",
            "#include <linux/file.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/stat.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/unistd.h>\n#include <asm/uaccess.h>\n#include \"internal.h\"\n#include <linux/compat.h>\n#include <linux/splice.h>\n#include <linux/pagemap.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/security.h>\n#include <linux/fsnotify.h>\n#include <linux/aio.h>\n#include <linux/uio.h>\n#include <linux/file.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/slab.h>\n\nint rw_verify_area(int read_write, struct file *file, const loff_t *ppos, size_t count)\n{\n\tstruct inode *inode;\n\tloff_t pos;\n\tint retval = -EINVAL;\n\n\tinode = file_inode(file);\n\tif (unlikely((ssize_t) count < 0))\n\t\treturn retval;\n\tpos = *ppos;\n\tif (unlikely(pos < 0)) {\n\t\tif (!unsigned_offsets(file))\n\t\t\treturn retval;\n\t\tif (count >= -pos) /* both values are in 0..LLONG_MAX */\n\t\t\treturn -EOVERFLOW;\n\t} else if (unlikely((loff_t) (pos + count) < 0)) {\n\t\tif (!unsigned_offsets(file))\n\t\t\treturn retval;\n\t}\n\n\tif (unlikely(inode->i_flctx && mandatory_lock(inode))) {\n\t\tretval = locks_mandatory_area(\n\t\t\tread_write == READ ? FLOCK_VERIFY_READ : FLOCK_VERIFY_WRITE,\n\t\t\tinode, file, pos, count);\n\t\tif (retval < 0)\n\t\t\treturn retval;\n\t}\n\tretval = security_file_permission(file,\n\t\t\t\tread_write == READ ? MAY_READ : MAY_WRITE);\n\tif (retval)\n\t\treturn retval;\n\treturn count > MAX_RW_COUNT ? MAX_RW_COUNT : count;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!access_ok(VERIFY_WRITE, buf, count)"
          ],
          "line": 486
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "access_ok",
          "args": [
            "VERIFY_WRITE",
            "buf",
            "count"
          ],
          "line": 486
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/unistd.h>\n#include <asm/uaccess.h>\n#include \"internal.h\"\n#include <linux/compat.h>\n#include <linux/splice.h>\n#include <linux/pagemap.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/security.h>\n#include <linux/fsnotify.h>\n#include <linux/aio.h>\n#include <linux/uio.h>\n#include <linux/file.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/slab.h>\n\nssize_t vfs_read(struct file *file, char __user *buf, size_t count, loff_t *pos)\n{\n\tssize_t ret;\n\n\tif (!(file->f_mode & FMODE_READ))\n\t\treturn -EBADF;\n\tif (!(file->f_mode & FMODE_CAN_READ))\n\t\treturn -EINVAL;\n\tif (unlikely(!access_ok(VERIFY_WRITE, buf, count)))\n\t\treturn -EFAULT;\n\n\tret = rw_verify_area(READ, file, pos, count);\n\tif (ret >= 0) {\n\t\tcount = ret;\n\t\tret = __vfs_read(file, buf, count, pos);\n\t\tif (ret > 0) {\n\t\t\tfsnotify_access(file);\n\t\t\tadd_rchar(current, ret);\n\t\t}\n\t\tinc_syscr(current);\n\t}\n\n\treturn ret;\n}"
  },
  {
    "function_name": "__vfs_read",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/read_write.c",
    "lines": "461-476",
    "snippet": "ssize_t __vfs_read(struct file *file, char __user *buf, size_t count,\n\t\t   loff_t *pos)\n{\n\tssize_t ret;\n\n\tif (file->f_op->read)\n\t\tret = file->f_op->read(file, buf, count, pos);\n\telse if (file->f_op->aio_read)\n\t\tret = do_sync_read(file, buf, count, pos);\n\telse if (file->f_op->read_iter)\n\t\tret = new_sync_read(file, buf, count, pos);\n\telse\n\t\tret = -EINVAL;\n\n\treturn ret;\n}",
    "includes": [
      "#include <asm/unistd.h>",
      "#include <asm/uaccess.h>",
      "#include \"internal.h\"",
      "#include <linux/compat.h>",
      "#include <linux/splice.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/export.h>",
      "#include <linux/security.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/aio.h>",
      "#include <linux/uio.h>",
      "#include <linux/file.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/stat.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "new_sync_read",
          "args": [
            "file",
            "buf",
            "count",
            "pos"
          ],
          "line": 471
        },
        "resolved": true,
        "details": {
          "function_name": "new_sync_read",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/read_write.c",
          "lines": "440-457",
          "snippet": "ssize_t new_sync_read(struct file *filp, char __user *buf, size_t len, loff_t *ppos)\n{\n\tstruct iovec iov = { .iov_base = buf, .iov_len = len };\n\tstruct kiocb kiocb;\n\tstruct iov_iter iter;\n\tssize_t ret;\n\n\tinit_sync_kiocb(&kiocb, filp);\n\tkiocb.ki_pos = *ppos;\n\tkiocb.ki_nbytes = len;\n\tiov_iter_init(&iter, READ, &iov, 1, len);\n\n\tret = filp->f_op->read_iter(&kiocb, &iter);\n\tif (-EIOCBQUEUED == ret)\n\t\tret = wait_on_sync_kiocb(&kiocb);\n\t*ppos = kiocb.ki_pos;\n\treturn ret;\n}",
          "includes": [
            "#include <asm/unistd.h>",
            "#include <asm/uaccess.h>",
            "#include \"internal.h\"",
            "#include <linux/compat.h>",
            "#include <linux/splice.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/export.h>",
            "#include <linux/security.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/aio.h>",
            "#include <linux/uio.h>",
            "#include <linux/file.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/stat.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/unistd.h>\n#include <asm/uaccess.h>\n#include \"internal.h\"\n#include <linux/compat.h>\n#include <linux/splice.h>\n#include <linux/pagemap.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/security.h>\n#include <linux/fsnotify.h>\n#include <linux/aio.h>\n#include <linux/uio.h>\n#include <linux/file.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/slab.h>\n\nssize_t new_sync_read(struct file *filp, char __user *buf, size_t len, loff_t *ppos)\n{\n\tstruct iovec iov = { .iov_base = buf, .iov_len = len };\n\tstruct kiocb kiocb;\n\tstruct iov_iter iter;\n\tssize_t ret;\n\n\tinit_sync_kiocb(&kiocb, filp);\n\tkiocb.ki_pos = *ppos;\n\tkiocb.ki_nbytes = len;\n\tiov_iter_init(&iter, READ, &iov, 1, len);\n\n\tret = filp->f_op->read_iter(&kiocb, &iter);\n\tif (-EIOCBQUEUED == ret)\n\t\tret = wait_on_sync_kiocb(&kiocb);\n\t*ppos = kiocb.ki_pos;\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "do_sync_read",
          "args": [
            "file",
            "buf",
            "count",
            "pos"
          ],
          "line": 469
        },
        "resolved": true,
        "details": {
          "function_name": "do_sync_read",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/read_write.c",
          "lines": "421-436",
          "snippet": "ssize_t do_sync_read(struct file *filp, char __user *buf, size_t len, loff_t *ppos)\n{\n\tstruct iovec iov = { .iov_base = buf, .iov_len = len };\n\tstruct kiocb kiocb;\n\tssize_t ret;\n\n\tinit_sync_kiocb(&kiocb, filp);\n\tkiocb.ki_pos = *ppos;\n\tkiocb.ki_nbytes = len;\n\n\tret = filp->f_op->aio_read(&kiocb, &iov, 1, kiocb.ki_pos);\n\tif (-EIOCBQUEUED == ret)\n\t\tret = wait_on_sync_kiocb(&kiocb);\n\t*ppos = kiocb.ki_pos;\n\treturn ret;\n}",
          "includes": [
            "#include <asm/unistd.h>",
            "#include <asm/uaccess.h>",
            "#include \"internal.h\"",
            "#include <linux/compat.h>",
            "#include <linux/splice.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/export.h>",
            "#include <linux/security.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/aio.h>",
            "#include <linux/uio.h>",
            "#include <linux/file.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/stat.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/unistd.h>\n#include <asm/uaccess.h>\n#include \"internal.h\"\n#include <linux/compat.h>\n#include <linux/splice.h>\n#include <linux/pagemap.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/security.h>\n#include <linux/fsnotify.h>\n#include <linux/aio.h>\n#include <linux/uio.h>\n#include <linux/file.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/slab.h>\n\nssize_t do_sync_read(struct file *filp, char __user *buf, size_t len, loff_t *ppos)\n{\n\tstruct iovec iov = { .iov_base = buf, .iov_len = len };\n\tstruct kiocb kiocb;\n\tssize_t ret;\n\n\tinit_sync_kiocb(&kiocb, filp);\n\tkiocb.ki_pos = *ppos;\n\tkiocb.ki_nbytes = len;\n\n\tret = filp->f_op->aio_read(&kiocb, &iov, 1, kiocb.ki_pos);\n\tif (-EIOCBQUEUED == ret)\n\t\tret = wait_on_sync_kiocb(&kiocb);\n\t*ppos = kiocb.ki_pos;\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "file->f_op->read",
          "args": [
            "file",
            "buf",
            "count",
            "pos"
          ],
          "line": 467
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/unistd.h>\n#include <asm/uaccess.h>\n#include \"internal.h\"\n#include <linux/compat.h>\n#include <linux/splice.h>\n#include <linux/pagemap.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/security.h>\n#include <linux/fsnotify.h>\n#include <linux/aio.h>\n#include <linux/uio.h>\n#include <linux/file.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/slab.h>\n\nssize_t __vfs_read(struct file *file, char __user *buf, size_t count,\n\t\t   loff_t *pos)\n{\n\tssize_t ret;\n\n\tif (file->f_op->read)\n\t\tret = file->f_op->read(file, buf, count, pos);\n\telse if (file->f_op->aio_read)\n\t\tret = do_sync_read(file, buf, count, pos);\n\telse if (file->f_op->read_iter)\n\t\tret = new_sync_read(file, buf, count, pos);\n\telse\n\t\tret = -EINVAL;\n\n\treturn ret;\n}"
  },
  {
    "function_name": "new_sync_read",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/read_write.c",
    "lines": "440-457",
    "snippet": "ssize_t new_sync_read(struct file *filp, char __user *buf, size_t len, loff_t *ppos)\n{\n\tstruct iovec iov = { .iov_base = buf, .iov_len = len };\n\tstruct kiocb kiocb;\n\tstruct iov_iter iter;\n\tssize_t ret;\n\n\tinit_sync_kiocb(&kiocb, filp);\n\tkiocb.ki_pos = *ppos;\n\tkiocb.ki_nbytes = len;\n\tiov_iter_init(&iter, READ, &iov, 1, len);\n\n\tret = filp->f_op->read_iter(&kiocb, &iter);\n\tif (-EIOCBQUEUED == ret)\n\t\tret = wait_on_sync_kiocb(&kiocb);\n\t*ppos = kiocb.ki_pos;\n\treturn ret;\n}",
    "includes": [
      "#include <asm/unistd.h>",
      "#include <asm/uaccess.h>",
      "#include \"internal.h\"",
      "#include <linux/compat.h>",
      "#include <linux/splice.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/export.h>",
      "#include <linux/security.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/aio.h>",
      "#include <linux/uio.h>",
      "#include <linux/file.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/stat.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "wait_on_sync_kiocb",
          "args": [
            "&kiocb"
          ],
          "line": 454
        },
        "resolved": true,
        "details": {
          "function_name": "wait_on_sync_kiocb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/aio.c",
          "lines": "784-794",
          "snippet": "ssize_t wait_on_sync_kiocb(struct kiocb *req)\n{\n\twhile (!req->ki_ctx) {\n\t\tset_current_state(TASK_UNINTERRUPTIBLE);\n\t\tif (req->ki_ctx)\n\t\t\tbreak;\n\t\tio_schedule();\n\t}\n\t__set_current_state(TASK_RUNNING);\n\treturn req->ki_user_data;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <asm/kmap_types.h>",
            "#include <linux/mount.h>",
            "#include <linux/percpu-refcount.h>",
            "#include <linux/ramfs.h>",
            "#include <linux/migrate.h>",
            "#include <linux/compat.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/eventfd.h>",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/highmem.h>",
            "#include <linux/aio.h>",
            "#include <linux/timer.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mmu_context.h>",
            "#include <linux/mman.h>",
            "#include <linux/mm.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/uio.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/export.h>",
            "#include <linux/aio_abi.h>",
            "#include <linux/time.h>",
            "#include <linux/errno.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <asm/kmap_types.h>\n#include <linux/mount.h>\n#include <linux/percpu-refcount.h>\n#include <linux/ramfs.h>\n#include <linux/migrate.h>\n#include <linux/compat.h>\n#include <linux/blkdev.h>\n#include <linux/eventfd.h>\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/highmem.h>\n#include <linux/aio.h>\n#include <linux/timer.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mmu_context.h>\n#include <linux/mman.h>\n#include <linux/mm.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/backing-dev.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/aio_abi.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n\nssize_t wait_on_sync_kiocb(struct kiocb *req)\n{\n\twhile (!req->ki_ctx) {\n\t\tset_current_state(TASK_UNINTERRUPTIBLE);\n\t\tif (req->ki_ctx)\n\t\t\tbreak;\n\t\tio_schedule();\n\t}\n\t__set_current_state(TASK_RUNNING);\n\treturn req->ki_user_data;\n}"
        }
      },
      {
        "call_info": {
          "callee": "filp->f_op->read_iter",
          "args": [
            "&kiocb",
            "&iter"
          ],
          "line": 452
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "iov_iter_init",
          "args": [
            "&iter",
            "READ",
            "&iov",
            "1",
            "len"
          ],
          "line": 450
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "init_sync_kiocb",
          "args": [
            "&kiocb",
            "filp"
          ],
          "line": 447
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/unistd.h>\n#include <asm/uaccess.h>\n#include \"internal.h\"\n#include <linux/compat.h>\n#include <linux/splice.h>\n#include <linux/pagemap.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/security.h>\n#include <linux/fsnotify.h>\n#include <linux/aio.h>\n#include <linux/uio.h>\n#include <linux/file.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/slab.h>\n\nssize_t new_sync_read(struct file *filp, char __user *buf, size_t len, loff_t *ppos)\n{\n\tstruct iovec iov = { .iov_base = buf, .iov_len = len };\n\tstruct kiocb kiocb;\n\tstruct iov_iter iter;\n\tssize_t ret;\n\n\tinit_sync_kiocb(&kiocb, filp);\n\tkiocb.ki_pos = *ppos;\n\tkiocb.ki_nbytes = len;\n\tiov_iter_init(&iter, READ, &iov, 1, len);\n\n\tret = filp->f_op->read_iter(&kiocb, &iter);\n\tif (-EIOCBQUEUED == ret)\n\t\tret = wait_on_sync_kiocb(&kiocb);\n\t*ppos = kiocb.ki_pos;\n\treturn ret;\n}"
  },
  {
    "function_name": "do_sync_read",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/read_write.c",
    "lines": "421-436",
    "snippet": "ssize_t do_sync_read(struct file *filp, char __user *buf, size_t len, loff_t *ppos)\n{\n\tstruct iovec iov = { .iov_base = buf, .iov_len = len };\n\tstruct kiocb kiocb;\n\tssize_t ret;\n\n\tinit_sync_kiocb(&kiocb, filp);\n\tkiocb.ki_pos = *ppos;\n\tkiocb.ki_nbytes = len;\n\n\tret = filp->f_op->aio_read(&kiocb, &iov, 1, kiocb.ki_pos);\n\tif (-EIOCBQUEUED == ret)\n\t\tret = wait_on_sync_kiocb(&kiocb);\n\t*ppos = kiocb.ki_pos;\n\treturn ret;\n}",
    "includes": [
      "#include <asm/unistd.h>",
      "#include <asm/uaccess.h>",
      "#include \"internal.h\"",
      "#include <linux/compat.h>",
      "#include <linux/splice.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/export.h>",
      "#include <linux/security.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/aio.h>",
      "#include <linux/uio.h>",
      "#include <linux/file.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/stat.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "wait_on_sync_kiocb",
          "args": [
            "&kiocb"
          ],
          "line": 433
        },
        "resolved": true,
        "details": {
          "function_name": "wait_on_sync_kiocb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/aio.c",
          "lines": "784-794",
          "snippet": "ssize_t wait_on_sync_kiocb(struct kiocb *req)\n{\n\twhile (!req->ki_ctx) {\n\t\tset_current_state(TASK_UNINTERRUPTIBLE);\n\t\tif (req->ki_ctx)\n\t\t\tbreak;\n\t\tio_schedule();\n\t}\n\t__set_current_state(TASK_RUNNING);\n\treturn req->ki_user_data;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <asm/kmap_types.h>",
            "#include <linux/mount.h>",
            "#include <linux/percpu-refcount.h>",
            "#include <linux/ramfs.h>",
            "#include <linux/migrate.h>",
            "#include <linux/compat.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/eventfd.h>",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/highmem.h>",
            "#include <linux/aio.h>",
            "#include <linux/timer.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mmu_context.h>",
            "#include <linux/mman.h>",
            "#include <linux/mm.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/uio.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/export.h>",
            "#include <linux/aio_abi.h>",
            "#include <linux/time.h>",
            "#include <linux/errno.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <asm/kmap_types.h>\n#include <linux/mount.h>\n#include <linux/percpu-refcount.h>\n#include <linux/ramfs.h>\n#include <linux/migrate.h>\n#include <linux/compat.h>\n#include <linux/blkdev.h>\n#include <linux/eventfd.h>\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/highmem.h>\n#include <linux/aio.h>\n#include <linux/timer.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mmu_context.h>\n#include <linux/mman.h>\n#include <linux/mm.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/backing-dev.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/aio_abi.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n\nssize_t wait_on_sync_kiocb(struct kiocb *req)\n{\n\twhile (!req->ki_ctx) {\n\t\tset_current_state(TASK_UNINTERRUPTIBLE);\n\t\tif (req->ki_ctx)\n\t\t\tbreak;\n\t\tio_schedule();\n\t}\n\t__set_current_state(TASK_RUNNING);\n\treturn req->ki_user_data;\n}"
        }
      },
      {
        "call_info": {
          "callee": "filp->f_op->aio_read",
          "args": [
            "&kiocb",
            "&iov",
            "1",
            "kiocb.ki_pos"
          ],
          "line": 431
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "init_sync_kiocb",
          "args": [
            "&kiocb",
            "filp"
          ],
          "line": 427
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/unistd.h>\n#include <asm/uaccess.h>\n#include \"internal.h\"\n#include <linux/compat.h>\n#include <linux/splice.h>\n#include <linux/pagemap.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/security.h>\n#include <linux/fsnotify.h>\n#include <linux/aio.h>\n#include <linux/uio.h>\n#include <linux/file.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/slab.h>\n\nssize_t do_sync_read(struct file *filp, char __user *buf, size_t len, loff_t *ppos)\n{\n\tstruct iovec iov = { .iov_base = buf, .iov_len = len };\n\tstruct kiocb kiocb;\n\tssize_t ret;\n\n\tinit_sync_kiocb(&kiocb, filp);\n\tkiocb.ki_pos = *ppos;\n\tkiocb.ki_nbytes = len;\n\n\tret = filp->f_op->aio_read(&kiocb, &iov, 1, kiocb.ki_pos);\n\tif (-EIOCBQUEUED == ret)\n\t\tret = wait_on_sync_kiocb(&kiocb);\n\t*ppos = kiocb.ki_pos;\n\treturn ret;\n}"
  },
  {
    "function_name": "rw_verify_area",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/read_write.c",
    "lines": "387-419",
    "snippet": "int rw_verify_area(int read_write, struct file *file, const loff_t *ppos, size_t count)\n{\n\tstruct inode *inode;\n\tloff_t pos;\n\tint retval = -EINVAL;\n\n\tinode = file_inode(file);\n\tif (unlikely((ssize_t) count < 0))\n\t\treturn retval;\n\tpos = *ppos;\n\tif (unlikely(pos < 0)) {\n\t\tif (!unsigned_offsets(file))\n\t\t\treturn retval;\n\t\tif (count >= -pos) /* both values are in 0..LLONG_MAX */\n\t\t\treturn -EOVERFLOW;\n\t} else if (unlikely((loff_t) (pos + count) < 0)) {\n\t\tif (!unsigned_offsets(file))\n\t\t\treturn retval;\n\t}\n\n\tif (unlikely(inode->i_flctx && mandatory_lock(inode))) {\n\t\tretval = locks_mandatory_area(\n\t\t\tread_write == READ ? FLOCK_VERIFY_READ : FLOCK_VERIFY_WRITE,\n\t\t\tinode, file, pos, count);\n\t\tif (retval < 0)\n\t\t\treturn retval;\n\t}\n\tretval = security_file_permission(file,\n\t\t\t\tread_write == READ ? MAY_READ : MAY_WRITE);\n\tif (retval)\n\t\treturn retval;\n\treturn count > MAX_RW_COUNT ? MAX_RW_COUNT : count;\n}",
    "includes": [
      "#include <asm/unistd.h>",
      "#include <asm/uaccess.h>",
      "#include \"internal.h\"",
      "#include <linux/compat.h>",
      "#include <linux/splice.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/export.h>",
      "#include <linux/security.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/aio.h>",
      "#include <linux/uio.h>",
      "#include <linux/file.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/stat.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "security_file_permission",
          "args": [
            "file",
            "read_write == READ ? MAY_READ : MAY_WRITE"
          ],
          "line": 414
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "locks_mandatory_area",
          "args": [
            "read_write == READ ? FLOCK_VERIFY_READ : FLOCK_VERIFY_WRITE",
            "inode",
            "file",
            "pos",
            "count"
          ],
          "line": 408
        },
        "resolved": true,
        "details": {
          "function_name": "locks_mandatory_area",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/locks.c",
          "lines": "1239-1287",
          "snippet": "int locks_mandatory_area(int read_write, struct inode *inode,\n\t\t\t struct file *filp, loff_t offset,\n\t\t\t size_t count)\n{\n\tstruct file_lock fl;\n\tint error;\n\tbool sleep = false;\n\n\tlocks_init_lock(&fl);\n\tfl.fl_pid = current->tgid;\n\tfl.fl_file = filp;\n\tfl.fl_flags = FL_POSIX | FL_ACCESS;\n\tif (filp && !(filp->f_flags & O_NONBLOCK))\n\t\tsleep = true;\n\tfl.fl_type = (read_write == FLOCK_VERIFY_WRITE) ? F_WRLCK : F_RDLCK;\n\tfl.fl_start = offset;\n\tfl.fl_end = offset + count - 1;\n\n\tfor (;;) {\n\t\tif (filp) {\n\t\t\tfl.fl_owner = filp;\n\t\t\tfl.fl_flags &= ~FL_SLEEP;\n\t\t\terror = __posix_lock_file(inode, &fl, NULL);\n\t\t\tif (!error)\n\t\t\t\tbreak;\n\t\t}\n\n\t\tif (sleep)\n\t\t\tfl.fl_flags |= FL_SLEEP;\n\t\tfl.fl_owner = current->files;\n\t\terror = __posix_lock_file(inode, &fl, NULL);\n\t\tif (error != FILE_LOCK_DEFERRED)\n\t\t\tbreak;\n\t\terror = wait_event_interruptible(fl.fl_wait, !fl.fl_next);\n\t\tif (!error) {\n\t\t\t/*\n\t\t\t * If we've been sleeping someone might have\n\t\t\t * changed the permissions behind our back.\n\t\t\t */\n\t\t\tif (__mandatory_lock(inode))\n\t\t\t\tcontinue;\n\t\t}\n\n\t\tlocks_delete_block(&fl);\n\t\tbreak;\n\t}\n\n\treturn error;\n}",
          "includes": [
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <asm/uaccess.h>",
            "#include <trace/events/filelock.h>",
            "#include <linux/lglock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/time.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <asm/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/lglock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nint locks_mandatory_area(int read_write, struct inode *inode,\n\t\t\t struct file *filp, loff_t offset,\n\t\t\t size_t count)\n{\n\tstruct file_lock fl;\n\tint error;\n\tbool sleep = false;\n\n\tlocks_init_lock(&fl);\n\tfl.fl_pid = current->tgid;\n\tfl.fl_file = filp;\n\tfl.fl_flags = FL_POSIX | FL_ACCESS;\n\tif (filp && !(filp->f_flags & O_NONBLOCK))\n\t\tsleep = true;\n\tfl.fl_type = (read_write == FLOCK_VERIFY_WRITE) ? F_WRLCK : F_RDLCK;\n\tfl.fl_start = offset;\n\tfl.fl_end = offset + count - 1;\n\n\tfor (;;) {\n\t\tif (filp) {\n\t\t\tfl.fl_owner = filp;\n\t\t\tfl.fl_flags &= ~FL_SLEEP;\n\t\t\terror = __posix_lock_file(inode, &fl, NULL);\n\t\t\tif (!error)\n\t\t\t\tbreak;\n\t\t}\n\n\t\tif (sleep)\n\t\t\tfl.fl_flags |= FL_SLEEP;\n\t\tfl.fl_owner = current->files;\n\t\terror = __posix_lock_file(inode, &fl, NULL);\n\t\tif (error != FILE_LOCK_DEFERRED)\n\t\t\tbreak;\n\t\terror = wait_event_interruptible(fl.fl_wait, !fl.fl_next);\n\t\tif (!error) {\n\t\t\t/*\n\t\t\t * If we've been sleeping someone might have\n\t\t\t * changed the permissions behind our back.\n\t\t\t */\n\t\t\tif (__mandatory_lock(inode))\n\t\t\t\tcontinue;\n\t\t}\n\n\t\tlocks_delete_block(&fl);\n\t\tbreak;\n\t}\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "inode->i_flctx && mandatory_lock(inode)"
          ],
          "line": 407
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mandatory_lock",
          "args": [
            "inode"
          ],
          "line": 407
        },
        "resolved": true,
        "details": {
          "function_name": "locks_mandatory_locked",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/locks.c",
          "lines": "1199-1224",
          "snippet": "int locks_mandatory_locked(struct file *file)\n{\n\tint ret;\n\tstruct inode *inode = file_inode(file);\n\tstruct file_lock_context *ctx;\n\tstruct file_lock *fl;\n\n\tctx = inode->i_flctx;\n\tif (!ctx || list_empty_careful(&ctx->flc_posix))\n\t\treturn 0;\n\n\t/*\n\t * Search the lock list for this inode for any POSIX locks.\n\t */\n\tspin_lock(&ctx->flc_lock);\n\tret = 0;\n\tlist_for_each_entry(fl, &ctx->flc_posix, fl_list) {\n\t\tif (fl->fl_owner != current->files &&\n\t\t    fl->fl_owner != file) {\n\t\t\tret = -EAGAIN;\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&ctx->flc_lock);\n\treturn ret;\n}",
          "includes": [
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <asm/uaccess.h>",
            "#include <trace/events/filelock.h>",
            "#include <linux/lglock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/time.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <asm/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/lglock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nint locks_mandatory_locked(struct file *file)\n{\n\tint ret;\n\tstruct inode *inode = file_inode(file);\n\tstruct file_lock_context *ctx;\n\tstruct file_lock *fl;\n\n\tctx = inode->i_flctx;\n\tif (!ctx || list_empty_careful(&ctx->flc_posix))\n\t\treturn 0;\n\n\t/*\n\t * Search the lock list for this inode for any POSIX locks.\n\t */\n\tspin_lock(&ctx->flc_lock);\n\tret = 0;\n\tlist_for_each_entry(fl, &ctx->flc_posix, fl_list) {\n\t\tif (fl->fl_owner != current->files &&\n\t\t    fl->fl_owner != file) {\n\t\t\tret = -EAGAIN;\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&ctx->flc_lock);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unsigned_offsets",
          "args": [
            "file"
          ],
          "line": 403
        },
        "resolved": true,
        "details": {
          "function_name": "unsigned_offsets",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/read_write.c",
          "lines": "40-43",
          "snippet": "static inline int unsigned_offsets(struct file *file)\n{\n\treturn file->f_mode & FMODE_UNSIGNED_OFFSET;\n}",
          "includes": [
            "#include <asm/unistd.h>",
            "#include <asm/uaccess.h>",
            "#include \"internal.h\"",
            "#include <linux/compat.h>",
            "#include <linux/splice.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/export.h>",
            "#include <linux/security.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/aio.h>",
            "#include <linux/uio.h>",
            "#include <linux/file.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/stat.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/unistd.h>\n#include <asm/uaccess.h>\n#include \"internal.h\"\n#include <linux/compat.h>\n#include <linux/splice.h>\n#include <linux/pagemap.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/security.h>\n#include <linux/fsnotify.h>\n#include <linux/aio.h>\n#include <linux/uio.h>\n#include <linux/file.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/slab.h>\n\nstatic inline int unsigned_offsets(struct file *file)\n{\n\treturn file->f_mode & FMODE_UNSIGNED_OFFSET;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "(loff_t) (pos + count) < 0"
          ],
          "line": 402
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "pos + count"
          ],
          "line": 402
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "pos < 0"
          ],
          "line": 397
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "(ssize_t) count < 0"
          ],
          "line": 394
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "file_inode",
          "args": [
            "file"
          ],
          "line": 393
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_init_file_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/file.c",
          "lines": "3009-3013",
          "snippet": "void fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}",
          "includes": [
            "#include <linux/falloc.h>",
            "#include <linux/aio.h>",
            "#include <linux/swap.h>",
            "#include <linux/compat.h>",
            "#include <linux/module.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};",
            "static const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/compat.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};\nstatic const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};\n\nvoid fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/unistd.h>\n#include <asm/uaccess.h>\n#include \"internal.h\"\n#include <linux/compat.h>\n#include <linux/splice.h>\n#include <linux/pagemap.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/security.h>\n#include <linux/fsnotify.h>\n#include <linux/aio.h>\n#include <linux/uio.h>\n#include <linux/file.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/slab.h>\n\nint rw_verify_area(int read_write, struct file *file, const loff_t *ppos, size_t count)\n{\n\tstruct inode *inode;\n\tloff_t pos;\n\tint retval = -EINVAL;\n\n\tinode = file_inode(file);\n\tif (unlikely((ssize_t) count < 0))\n\t\treturn retval;\n\tpos = *ppos;\n\tif (unlikely(pos < 0)) {\n\t\tif (!unsigned_offsets(file))\n\t\t\treturn retval;\n\t\tif (count >= -pos) /* both values are in 0..LLONG_MAX */\n\t\t\treturn -EOVERFLOW;\n\t} else if (unlikely((loff_t) (pos + count) < 0)) {\n\t\tif (!unsigned_offsets(file))\n\t\t\treturn retval;\n\t}\n\n\tif (unlikely(inode->i_flctx && mandatory_lock(inode))) {\n\t\tretval = locks_mandatory_area(\n\t\t\tread_write == READ ? FLOCK_VERIFY_READ : FLOCK_VERIFY_WRITE,\n\t\t\tinode, file, pos, count);\n\t\tif (retval < 0)\n\t\t\treturn retval;\n\t}\n\tretval = security_file_permission(file,\n\t\t\t\tread_write == READ ? MAY_READ : MAY_WRITE);\n\tif (retval)\n\t\treturn retval;\n\treturn count > MAX_RW_COUNT ? MAX_RW_COUNT : count;\n}"
  },
  {
    "function_name": "vfs_iter_write",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/read_write.c",
    "lines": "359-379",
    "snippet": "ssize_t vfs_iter_write(struct file *file, struct iov_iter *iter, loff_t *ppos)\n{\n\tstruct kiocb kiocb;\n\tssize_t ret;\n\n\tif (!file->f_op->write_iter)\n\t\treturn -EINVAL;\n\n\tinit_sync_kiocb(&kiocb, file);\n\tkiocb.ki_pos = *ppos;\n\tkiocb.ki_nbytes = iov_iter_count(iter);\n\n\titer->type |= WRITE;\n\tret = file->f_op->write_iter(&kiocb, iter);\n\tif (ret == -EIOCBQUEUED)\n\t\tret = wait_on_sync_kiocb(&kiocb);\n\n\tif (ret > 0)\n\t\t*ppos = kiocb.ki_pos;\n\treturn ret;\n}",
    "includes": [
      "#include <asm/unistd.h>",
      "#include <asm/uaccess.h>",
      "#include \"internal.h\"",
      "#include <linux/compat.h>",
      "#include <linux/splice.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/export.h>",
      "#include <linux/security.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/aio.h>",
      "#include <linux/uio.h>",
      "#include <linux/file.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/stat.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "wait_on_sync_kiocb",
          "args": [
            "&kiocb"
          ],
          "line": 374
        },
        "resolved": true,
        "details": {
          "function_name": "wait_on_sync_kiocb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/aio.c",
          "lines": "784-794",
          "snippet": "ssize_t wait_on_sync_kiocb(struct kiocb *req)\n{\n\twhile (!req->ki_ctx) {\n\t\tset_current_state(TASK_UNINTERRUPTIBLE);\n\t\tif (req->ki_ctx)\n\t\t\tbreak;\n\t\tio_schedule();\n\t}\n\t__set_current_state(TASK_RUNNING);\n\treturn req->ki_user_data;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <asm/kmap_types.h>",
            "#include <linux/mount.h>",
            "#include <linux/percpu-refcount.h>",
            "#include <linux/ramfs.h>",
            "#include <linux/migrate.h>",
            "#include <linux/compat.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/eventfd.h>",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/highmem.h>",
            "#include <linux/aio.h>",
            "#include <linux/timer.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mmu_context.h>",
            "#include <linux/mman.h>",
            "#include <linux/mm.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/uio.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/export.h>",
            "#include <linux/aio_abi.h>",
            "#include <linux/time.h>",
            "#include <linux/errno.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <asm/kmap_types.h>\n#include <linux/mount.h>\n#include <linux/percpu-refcount.h>\n#include <linux/ramfs.h>\n#include <linux/migrate.h>\n#include <linux/compat.h>\n#include <linux/blkdev.h>\n#include <linux/eventfd.h>\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/highmem.h>\n#include <linux/aio.h>\n#include <linux/timer.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mmu_context.h>\n#include <linux/mman.h>\n#include <linux/mm.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/backing-dev.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/aio_abi.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n\nssize_t wait_on_sync_kiocb(struct kiocb *req)\n{\n\twhile (!req->ki_ctx) {\n\t\tset_current_state(TASK_UNINTERRUPTIBLE);\n\t\tif (req->ki_ctx)\n\t\t\tbreak;\n\t\tio_schedule();\n\t}\n\t__set_current_state(TASK_RUNNING);\n\treturn req->ki_user_data;\n}"
        }
      },
      {
        "call_info": {
          "callee": "file->f_op->write_iter",
          "args": [
            "&kiocb",
            "iter"
          ],
          "line": 372
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "iov_iter_count",
          "args": [
            "iter"
          ],
          "line": 369
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "init_sync_kiocb",
          "args": [
            "&kiocb",
            "file"
          ],
          "line": 367
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/unistd.h>\n#include <asm/uaccess.h>\n#include \"internal.h\"\n#include <linux/compat.h>\n#include <linux/splice.h>\n#include <linux/pagemap.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/security.h>\n#include <linux/fsnotify.h>\n#include <linux/aio.h>\n#include <linux/uio.h>\n#include <linux/file.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/slab.h>\n\nssize_t vfs_iter_write(struct file *file, struct iov_iter *iter, loff_t *ppos)\n{\n\tstruct kiocb kiocb;\n\tssize_t ret;\n\n\tif (!file->f_op->write_iter)\n\t\treturn -EINVAL;\n\n\tinit_sync_kiocb(&kiocb, file);\n\tkiocb.ki_pos = *ppos;\n\tkiocb.ki_nbytes = iov_iter_count(iter);\n\n\titer->type |= WRITE;\n\tret = file->f_op->write_iter(&kiocb, iter);\n\tif (ret == -EIOCBQUEUED)\n\t\tret = wait_on_sync_kiocb(&kiocb);\n\n\tif (ret > 0)\n\t\t*ppos = kiocb.ki_pos;\n\treturn ret;\n}"
  },
  {
    "function_name": "vfs_iter_read",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/read_write.c",
    "lines": "336-356",
    "snippet": "ssize_t vfs_iter_read(struct file *file, struct iov_iter *iter, loff_t *ppos)\n{\n\tstruct kiocb kiocb;\n\tssize_t ret;\n\n\tif (!file->f_op->read_iter)\n\t\treturn -EINVAL;\n\n\tinit_sync_kiocb(&kiocb, file);\n\tkiocb.ki_pos = *ppos;\n\tkiocb.ki_nbytes = iov_iter_count(iter);\n\n\titer->type |= READ;\n\tret = file->f_op->read_iter(&kiocb, iter);\n\tif (ret == -EIOCBQUEUED)\n\t\tret = wait_on_sync_kiocb(&kiocb);\n\n\tif (ret > 0)\n\t\t*ppos = kiocb.ki_pos;\n\treturn ret;\n}",
    "includes": [
      "#include <asm/unistd.h>",
      "#include <asm/uaccess.h>",
      "#include \"internal.h\"",
      "#include <linux/compat.h>",
      "#include <linux/splice.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/export.h>",
      "#include <linux/security.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/aio.h>",
      "#include <linux/uio.h>",
      "#include <linux/file.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/stat.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "wait_on_sync_kiocb",
          "args": [
            "&kiocb"
          ],
          "line": 351
        },
        "resolved": true,
        "details": {
          "function_name": "wait_on_sync_kiocb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/aio.c",
          "lines": "784-794",
          "snippet": "ssize_t wait_on_sync_kiocb(struct kiocb *req)\n{\n\twhile (!req->ki_ctx) {\n\t\tset_current_state(TASK_UNINTERRUPTIBLE);\n\t\tif (req->ki_ctx)\n\t\t\tbreak;\n\t\tio_schedule();\n\t}\n\t__set_current_state(TASK_RUNNING);\n\treturn req->ki_user_data;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <asm/kmap_types.h>",
            "#include <linux/mount.h>",
            "#include <linux/percpu-refcount.h>",
            "#include <linux/ramfs.h>",
            "#include <linux/migrate.h>",
            "#include <linux/compat.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/eventfd.h>",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/highmem.h>",
            "#include <linux/aio.h>",
            "#include <linux/timer.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mmu_context.h>",
            "#include <linux/mman.h>",
            "#include <linux/mm.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/uio.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/export.h>",
            "#include <linux/aio_abi.h>",
            "#include <linux/time.h>",
            "#include <linux/errno.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <asm/kmap_types.h>\n#include <linux/mount.h>\n#include <linux/percpu-refcount.h>\n#include <linux/ramfs.h>\n#include <linux/migrate.h>\n#include <linux/compat.h>\n#include <linux/blkdev.h>\n#include <linux/eventfd.h>\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/highmem.h>\n#include <linux/aio.h>\n#include <linux/timer.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mmu_context.h>\n#include <linux/mman.h>\n#include <linux/mm.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/backing-dev.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/aio_abi.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n\nssize_t wait_on_sync_kiocb(struct kiocb *req)\n{\n\twhile (!req->ki_ctx) {\n\t\tset_current_state(TASK_UNINTERRUPTIBLE);\n\t\tif (req->ki_ctx)\n\t\t\tbreak;\n\t\tio_schedule();\n\t}\n\t__set_current_state(TASK_RUNNING);\n\treturn req->ki_user_data;\n}"
        }
      },
      {
        "call_info": {
          "callee": "file->f_op->read_iter",
          "args": [
            "&kiocb",
            "iter"
          ],
          "line": 349
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "iov_iter_count",
          "args": [
            "iter"
          ],
          "line": 346
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "init_sync_kiocb",
          "args": [
            "&kiocb",
            "file"
          ],
          "line": 344
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/unistd.h>\n#include <asm/uaccess.h>\n#include \"internal.h\"\n#include <linux/compat.h>\n#include <linux/splice.h>\n#include <linux/pagemap.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/security.h>\n#include <linux/fsnotify.h>\n#include <linux/aio.h>\n#include <linux/uio.h>\n#include <linux/file.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/slab.h>\n\nssize_t vfs_iter_read(struct file *file, struct iov_iter *iter, loff_t *ppos)\n{\n\tstruct kiocb kiocb;\n\tssize_t ret;\n\n\tif (!file->f_op->read_iter)\n\t\treturn -EINVAL;\n\n\tinit_sync_kiocb(&kiocb, file);\n\tkiocb.ki_pos = *ppos;\n\tkiocb.ki_nbytes = iov_iter_count(iter);\n\n\titer->type |= READ;\n\tret = file->f_op->read_iter(&kiocb, iter);\n\tif (ret == -EIOCBQUEUED)\n\t\tret = wait_on_sync_kiocb(&kiocb);\n\n\tif (ret > 0)\n\t\t*ppos = kiocb.ki_pos;\n\treturn ret;\n}"
  },
  {
    "function_name": "fdput_pos",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/read_write.c",
    "lines": "273-278",
    "snippet": "static inline void fdput_pos(struct fd f)\n{\n\tif (f.flags & FDPUT_POS_UNLOCK)\n\t\tmutex_unlock(&f.file->f_pos_lock);\n\tfdput(f);\n}",
    "includes": [
      "#include <asm/unistd.h>",
      "#include <asm/uaccess.h>",
      "#include \"internal.h\"",
      "#include <linux/compat.h>",
      "#include <linux/splice.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/export.h>",
      "#include <linux/security.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/aio.h>",
      "#include <linux/uio.h>",
      "#include <linux/file.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/stat.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fdput",
          "args": [
            "f"
          ],
          "line": 277
        },
        "resolved": true,
        "details": {
          "function_name": "fdput_pos",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/read_write.c",
          "lines": "273-278",
          "snippet": "static inline void fdput_pos(struct fd f)\n{\n\tif (f.flags & FDPUT_POS_UNLOCK)\n\t\tmutex_unlock(&f.file->f_pos_lock);\n\tfdput(f);\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&f.file->f_pos_lock"
          ],
          "line": 276
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/unistd.h>\n#include <asm/uaccess.h>\n#include \"internal.h\"\n#include <linux/compat.h>\n#include <linux/splice.h>\n#include <linux/pagemap.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/security.h>\n#include <linux/fsnotify.h>\n#include <linux/aio.h>\n#include <linux/uio.h>\n#include <linux/file.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/slab.h>\n\nstatic inline void fdput_pos(struct fd f)\n{\n\tif (f.flags & FDPUT_POS_UNLOCK)\n\t\tmutex_unlock(&f.file->f_pos_lock);\n\tfdput(f);\n}"
  },
  {
    "function_name": "fdget_pos",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/read_write.c",
    "lines": "268-271",
    "snippet": "static inline struct fd fdget_pos(int fd)\n{\n\treturn __to_fd(__fdget_pos(fd));\n}",
    "includes": [
      "#include <asm/unistd.h>",
      "#include <asm/uaccess.h>",
      "#include \"internal.h\"",
      "#include <linux/compat.h>",
      "#include <linux/splice.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/export.h>",
      "#include <linux/security.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/aio.h>",
      "#include <linux/uio.h>",
      "#include <linux/file.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/stat.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__to_fd",
          "args": [
            "__fdget_pos(fd)"
          ],
          "line": 270
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__fdget_pos",
          "args": [
            "fd"
          ],
          "line": 270
        },
        "resolved": true,
        "details": {
          "function_name": "__fdget_pos",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/file.c",
          "lines": "706-718",
          "snippet": "unsigned long __fdget_pos(unsigned int fd)\n{\n\tunsigned long v = __fdget(fd);\n\tstruct file *file = (struct file *)(v & ~3);\n\n\tif (file && (file->f_mode & FMODE_ATOMIC_POS)) {\n\t\tif (file_count(file) > 1) {\n\t\t\tv |= FDPUT_POS_UNLOCK;\n\t\t\tmutex_lock(&file->f_pos_lock);\n\t\t}\n\t}\n\treturn v;\n}",
          "includes": [
            "#include <linux/workqueue.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/bitops.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/time.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/workqueue.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/interrupt.h>\n#include <linux/bitops.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/time.h>\n#include <linux/mmzone.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nunsigned long __fdget_pos(unsigned int fd)\n{\n\tunsigned long v = __fdget(fd);\n\tstruct file *file = (struct file *)(v & ~3);\n\n\tif (file && (file->f_mode & FMODE_ATOMIC_POS)) {\n\t\tif (file_count(file) > 1) {\n\t\t\tv |= FDPUT_POS_UNLOCK;\n\t\t\tmutex_lock(&file->f_pos_lock);\n\t\t}\n\t}\n\treturn v;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/unistd.h>\n#include <asm/uaccess.h>\n#include \"internal.h\"\n#include <linux/compat.h>\n#include <linux/splice.h>\n#include <linux/pagemap.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/security.h>\n#include <linux/fsnotify.h>\n#include <linux/aio.h>\n#include <linux/uio.h>\n#include <linux/file.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/slab.h>\n\nstatic inline struct fd fdget_pos(int fd)\n{\n\treturn __to_fd(__fdget_pos(fd));\n}"
  },
  {
    "function_name": "vfs_llseek",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/read_write.c",
    "lines": "255-265",
    "snippet": "loff_t vfs_llseek(struct file *file, loff_t offset, int whence)\n{\n\tloff_t (*fn)(struct file *, loff_t, int);\n\n\tfn = no_llseek;\n\tif (file->f_mode & FMODE_LSEEK) {\n\t\tif (file->f_op->llseek)\n\t\t\tfn = file->f_op->llseek;\n\t}\n\treturn fn(file, offset, whence);\n}",
    "includes": [
      "#include <asm/unistd.h>",
      "#include <asm/uaccess.h>",
      "#include \"internal.h\"",
      "#include <linux/compat.h>",
      "#include <linux/splice.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/export.h>",
      "#include <linux/security.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/aio.h>",
      "#include <linux/uio.h>",
      "#include <linux/file.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/stat.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fn",
          "args": [
            "file",
            "offset",
            "whence"
          ],
          "line": 264
        },
        "resolved": true,
        "details": {
          "function_name": "hpfs_map_fnode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/map.c",
          "lines": "137-192",
          "snippet": "struct fnode *hpfs_map_fnode(struct super_block *s, ino_t ino, struct buffer_head **bhp)\n{\n\tstruct fnode *fnode;\n\tif (hpfs_sb(s)->sb_chk) if (hpfs_chk_sectors(s, ino, 1, \"fnode\")) {\n\t\treturn NULL;\n\t}\n\tif ((fnode = hpfs_map_sector(s, ino, bhp, FNODE_RD_AHEAD))) {\n\t\tif (hpfs_sb(s)->sb_chk) {\n\t\t\tstruct extended_attribute *ea;\n\t\t\tstruct extended_attribute *ea_end;\n\t\t\tif (le32_to_cpu(fnode->magic) != FNODE_MAGIC) {\n\t\t\t\thpfs_error(s, \"bad magic on fnode %08lx\",\n\t\t\t\t\t(unsigned long)ino);\n\t\t\t\tgoto bail;\n\t\t\t}\n\t\t\tif (!fnode_is_dir(fnode)) {\n\t\t\t\tif ((unsigned)fnode->btree.n_used_nodes + (unsigned)fnode->btree.n_free_nodes !=\n\t\t\t\t    (bp_internal(&fnode->btree) ? 12 : 8)) {\n\t\t\t\t\thpfs_error(s,\n\t\t\t\t\t   \"bad number of nodes in fnode %08lx\",\n\t\t\t\t\t    (unsigned long)ino);\n\t\t\t\t\tgoto bail;\n\t\t\t\t}\n\t\t\t\tif (le16_to_cpu(fnode->btree.first_free) !=\n\t\t\t\t    8 + fnode->btree.n_used_nodes * (bp_internal(&fnode->btree) ? 8 : 12)) {\n\t\t\t\t\thpfs_error(s,\n\t\t\t\t\t    \"bad first_free pointer in fnode %08lx\",\n\t\t\t\t\t    (unsigned long)ino);\n\t\t\t\t\tgoto bail;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (le16_to_cpu(fnode->ea_size_s) && (le16_to_cpu(fnode->ea_offs) < 0xc4 ||\n\t\t\t   le16_to_cpu(fnode->ea_offs) + le16_to_cpu(fnode->acl_size_s) + le16_to_cpu(fnode->ea_size_s) > 0x200)) {\n\t\t\t\thpfs_error(s,\n\t\t\t\t\t\"bad EA info in fnode %08lx: ea_offs == %04x ea_size_s == %04x\",\n\t\t\t\t\t(unsigned long)ino,\n\t\t\t\t\tle16_to_cpu(fnode->ea_offs), le16_to_cpu(fnode->ea_size_s));\n\t\t\t\tgoto bail;\n\t\t\t}\n\t\t\tea = fnode_ea(fnode);\n\t\t\tea_end = fnode_end_ea(fnode);\n\t\t\twhile (ea != ea_end) {\n\t\t\t\tif (ea > ea_end) {\n\t\t\t\t\thpfs_error(s, \"bad EA in fnode %08lx\",\n\t\t\t\t\t\t(unsigned long)ino);\n\t\t\t\t\tgoto bail;\n\t\t\t\t}\n\t\t\t\tea = next_ea(ea);\n\t\t\t}\n\t\t}\n\t}\n\treturn fnode;\n\tbail:\n\tbrelse(*bhp);\n\treturn NULL;\n}",
          "includes": [
            "#include \"hpfs_fn.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hpfs_fn.h\"\n\nstruct fnode *hpfs_map_fnode(struct super_block *s, ino_t ino, struct buffer_head **bhp)\n{\n\tstruct fnode *fnode;\n\tif (hpfs_sb(s)->sb_chk) if (hpfs_chk_sectors(s, ino, 1, \"fnode\")) {\n\t\treturn NULL;\n\t}\n\tif ((fnode = hpfs_map_sector(s, ino, bhp, FNODE_RD_AHEAD))) {\n\t\tif (hpfs_sb(s)->sb_chk) {\n\t\t\tstruct extended_attribute *ea;\n\t\t\tstruct extended_attribute *ea_end;\n\t\t\tif (le32_to_cpu(fnode->magic) != FNODE_MAGIC) {\n\t\t\t\thpfs_error(s, \"bad magic on fnode %08lx\",\n\t\t\t\t\t(unsigned long)ino);\n\t\t\t\tgoto bail;\n\t\t\t}\n\t\t\tif (!fnode_is_dir(fnode)) {\n\t\t\t\tif ((unsigned)fnode->btree.n_used_nodes + (unsigned)fnode->btree.n_free_nodes !=\n\t\t\t\t    (bp_internal(&fnode->btree) ? 12 : 8)) {\n\t\t\t\t\thpfs_error(s,\n\t\t\t\t\t   \"bad number of nodes in fnode %08lx\",\n\t\t\t\t\t    (unsigned long)ino);\n\t\t\t\t\tgoto bail;\n\t\t\t\t}\n\t\t\t\tif (le16_to_cpu(fnode->btree.first_free) !=\n\t\t\t\t    8 + fnode->btree.n_used_nodes * (bp_internal(&fnode->btree) ? 8 : 12)) {\n\t\t\t\t\thpfs_error(s,\n\t\t\t\t\t    \"bad first_free pointer in fnode %08lx\",\n\t\t\t\t\t    (unsigned long)ino);\n\t\t\t\t\tgoto bail;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (le16_to_cpu(fnode->ea_size_s) && (le16_to_cpu(fnode->ea_offs) < 0xc4 ||\n\t\t\t   le16_to_cpu(fnode->ea_offs) + le16_to_cpu(fnode->acl_size_s) + le16_to_cpu(fnode->ea_size_s) > 0x200)) {\n\t\t\t\thpfs_error(s,\n\t\t\t\t\t\"bad EA info in fnode %08lx: ea_offs == %04x ea_size_s == %04x\",\n\t\t\t\t\t(unsigned long)ino,\n\t\t\t\t\tle16_to_cpu(fnode->ea_offs), le16_to_cpu(fnode->ea_size_s));\n\t\t\t\tgoto bail;\n\t\t\t}\n\t\t\tea = fnode_ea(fnode);\n\t\t\tea_end = fnode_end_ea(fnode);\n\t\t\twhile (ea != ea_end) {\n\t\t\t\tif (ea > ea_end) {\n\t\t\t\t\thpfs_error(s, \"bad EA in fnode %08lx\",\n\t\t\t\t\t\t(unsigned long)ino);\n\t\t\t\t\tgoto bail;\n\t\t\t\t}\n\t\t\t\tea = next_ea(ea);\n\t\t\t}\n\t\t}\n\t}\n\treturn fnode;\n\tbail:\n\tbrelse(*bhp);\n\treturn NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/unistd.h>\n#include <asm/uaccess.h>\n#include \"internal.h\"\n#include <linux/compat.h>\n#include <linux/splice.h>\n#include <linux/pagemap.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/security.h>\n#include <linux/fsnotify.h>\n#include <linux/aio.h>\n#include <linux/uio.h>\n#include <linux/file.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/slab.h>\n\nloff_t vfs_llseek(struct file *file, loff_t offset, int whence)\n{\n\tloff_t (*fn)(struct file *, loff_t, int);\n\n\tfn = no_llseek;\n\tif (file->f_mode & FMODE_LSEEK) {\n\t\tif (file->f_op->llseek)\n\t\t\tfn = file->f_op->llseek;\n\t}\n\treturn fn(file, offset, whence);\n}"
  },
  {
    "function_name": "default_llseek",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/read_write.c",
    "lines": "200-252",
    "snippet": "loff_t default_llseek(struct file *file, loff_t offset, int whence)\n{\n\tstruct inode *inode = file_inode(file);\n\tloff_t retval;\n\n\tmutex_lock(&inode->i_mutex);\n\tswitch (whence) {\n\t\tcase SEEK_END:\n\t\t\toffset += i_size_read(inode);\n\t\t\tbreak;\n\t\tcase SEEK_CUR:\n\t\t\tif (offset == 0) {\n\t\t\t\tretval = file->f_pos;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\toffset += file->f_pos;\n\t\t\tbreak;\n\t\tcase SEEK_DATA:\n\t\t\t/*\n\t\t\t * In the generic case the entire file is data, so as\n\t\t\t * long as offset isn't at the end of the file then the\n\t\t\t * offset is data.\n\t\t\t */\n\t\t\tif (offset >= inode->i_size) {\n\t\t\t\tretval = -ENXIO;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase SEEK_HOLE:\n\t\t\t/*\n\t\t\t * There is a virtual hole at the end of the file, so\n\t\t\t * as long as offset isn't i_size or larger, return\n\t\t\t * i_size.\n\t\t\t */\n\t\t\tif (offset >= inode->i_size) {\n\t\t\t\tretval = -ENXIO;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\toffset = inode->i_size;\n\t\t\tbreak;\n\t}\n\tretval = -EINVAL;\n\tif (offset >= 0 || unsigned_offsets(file)) {\n\t\tif (offset != file->f_pos) {\n\t\t\tfile->f_pos = offset;\n\t\t\tfile->f_version = 0;\n\t\t}\n\t\tretval = offset;\n\t}\nout:\n\tmutex_unlock(&inode->i_mutex);\n\treturn retval;\n}",
    "includes": [
      "#include <asm/unistd.h>",
      "#include <asm/uaccess.h>",
      "#include \"internal.h\"",
      "#include <linux/compat.h>",
      "#include <linux/splice.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/export.h>",
      "#include <linux/security.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/aio.h>",
      "#include <linux/uio.h>",
      "#include <linux/file.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/stat.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&inode->i_mutex"
          ],
          "line": 250
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unsigned_offsets",
          "args": [
            "file"
          ],
          "line": 242
        },
        "resolved": true,
        "details": {
          "function_name": "unsigned_offsets",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/read_write.c",
          "lines": "40-43",
          "snippet": "static inline int unsigned_offsets(struct file *file)\n{\n\treturn file->f_mode & FMODE_UNSIGNED_OFFSET;\n}",
          "includes": [
            "#include <asm/unistd.h>",
            "#include <asm/uaccess.h>",
            "#include \"internal.h\"",
            "#include <linux/compat.h>",
            "#include <linux/splice.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/export.h>",
            "#include <linux/security.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/aio.h>",
            "#include <linux/uio.h>",
            "#include <linux/file.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/stat.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/unistd.h>\n#include <asm/uaccess.h>\n#include \"internal.h\"\n#include <linux/compat.h>\n#include <linux/splice.h>\n#include <linux/pagemap.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/security.h>\n#include <linux/fsnotify.h>\n#include <linux/aio.h>\n#include <linux/uio.h>\n#include <linux/file.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/slab.h>\n\nstatic inline int unsigned_offsets(struct file *file)\n{\n\treturn file->f_mode & FMODE_UNSIGNED_OFFSET;\n}"
        }
      },
      {
        "call_info": {
          "callee": "i_size_read",
          "args": [
            "inode"
          ],
          "line": 208
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&inode->i_mutex"
          ],
          "line": 205
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "file_inode",
          "args": [
            "file"
          ],
          "line": 202
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_init_file_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/file.c",
          "lines": "3009-3013",
          "snippet": "void fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}",
          "includes": [
            "#include <linux/falloc.h>",
            "#include <linux/aio.h>",
            "#include <linux/swap.h>",
            "#include <linux/compat.h>",
            "#include <linux/module.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};",
            "static const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/compat.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};\nstatic const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};\n\nvoid fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/unistd.h>\n#include <asm/uaccess.h>\n#include \"internal.h\"\n#include <linux/compat.h>\n#include <linux/splice.h>\n#include <linux/pagemap.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/security.h>\n#include <linux/fsnotify.h>\n#include <linux/aio.h>\n#include <linux/uio.h>\n#include <linux/file.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/slab.h>\n\nloff_t default_llseek(struct file *file, loff_t offset, int whence)\n{\n\tstruct inode *inode = file_inode(file);\n\tloff_t retval;\n\n\tmutex_lock(&inode->i_mutex);\n\tswitch (whence) {\n\t\tcase SEEK_END:\n\t\t\toffset += i_size_read(inode);\n\t\t\tbreak;\n\t\tcase SEEK_CUR:\n\t\t\tif (offset == 0) {\n\t\t\t\tretval = file->f_pos;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\toffset += file->f_pos;\n\t\t\tbreak;\n\t\tcase SEEK_DATA:\n\t\t\t/*\n\t\t\t * In the generic case the entire file is data, so as\n\t\t\t * long as offset isn't at the end of the file then the\n\t\t\t * offset is data.\n\t\t\t */\n\t\t\tif (offset >= inode->i_size) {\n\t\t\t\tretval = -ENXIO;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase SEEK_HOLE:\n\t\t\t/*\n\t\t\t * There is a virtual hole at the end of the file, so\n\t\t\t * as long as offset isn't i_size or larger, return\n\t\t\t * i_size.\n\t\t\t */\n\t\t\tif (offset >= inode->i_size) {\n\t\t\t\tretval = -ENXIO;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\toffset = inode->i_size;\n\t\t\tbreak;\n\t}\n\tretval = -EINVAL;\n\tif (offset >= 0 || unsigned_offsets(file)) {\n\t\tif (offset != file->f_pos) {\n\t\t\tfile->f_pos = offset;\n\t\t\tfile->f_version = 0;\n\t\t}\n\t\tretval = offset;\n\t}\nout:\n\tmutex_unlock(&inode->i_mutex);\n\treturn retval;\n}"
  },
  {
    "function_name": "no_llseek",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/read_write.c",
    "lines": "194-197",
    "snippet": "loff_t no_llseek(struct file *file, loff_t offset, int whence)\n{\n\treturn -ESPIPE;\n}",
    "includes": [
      "#include <asm/unistd.h>",
      "#include <asm/uaccess.h>",
      "#include \"internal.h\"",
      "#include <linux/compat.h>",
      "#include <linux/splice.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/export.h>",
      "#include <linux/security.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/aio.h>",
      "#include <linux/uio.h>",
      "#include <linux/file.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/stat.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <asm/unistd.h>\n#include <asm/uaccess.h>\n#include \"internal.h\"\n#include <linux/compat.h>\n#include <linux/splice.h>\n#include <linux/pagemap.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/security.h>\n#include <linux/fsnotify.h>\n#include <linux/aio.h>\n#include <linux/uio.h>\n#include <linux/file.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/slab.h>\n\nloff_t no_llseek(struct file *file, loff_t offset, int whence)\n{\n\treturn -ESPIPE;\n}"
  },
  {
    "function_name": "noop_llseek",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/read_write.c",
    "lines": "188-191",
    "snippet": "loff_t noop_llseek(struct file *file, loff_t offset, int whence)\n{\n\treturn file->f_pos;\n}",
    "includes": [
      "#include <asm/unistd.h>",
      "#include <asm/uaccess.h>",
      "#include \"internal.h\"",
      "#include <linux/compat.h>",
      "#include <linux/splice.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/export.h>",
      "#include <linux/security.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/aio.h>",
      "#include <linux/uio.h>",
      "#include <linux/file.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/stat.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <asm/unistd.h>\n#include <asm/uaccess.h>\n#include \"internal.h\"\n#include <linux/compat.h>\n#include <linux/splice.h>\n#include <linux/pagemap.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/security.h>\n#include <linux/fsnotify.h>\n#include <linux/aio.h>\n#include <linux/uio.h>\n#include <linux/file.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/slab.h>\n\nloff_t noop_llseek(struct file *file, loff_t offset, int whence)\n{\n\treturn file->f_pos;\n}"
  },
  {
    "function_name": "fixed_size_llseek",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/read_write.c",
    "lines": "165-174",
    "snippet": "loff_t fixed_size_llseek(struct file *file, loff_t offset, int whence, loff_t size)\n{\n\tswitch (whence) {\n\tcase SEEK_SET: case SEEK_CUR: case SEEK_END:\n\t\treturn generic_file_llseek_size(file, offset, whence,\n\t\t\t\t\t\tsize, size);\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}",
    "includes": [
      "#include <asm/unistd.h>",
      "#include <asm/uaccess.h>",
      "#include \"internal.h\"",
      "#include <linux/compat.h>",
      "#include <linux/splice.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/export.h>",
      "#include <linux/security.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/aio.h>",
      "#include <linux/uio.h>",
      "#include <linux/file.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/stat.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "generic_file_llseek_size",
          "args": [
            "file",
            "offset",
            "whence",
            "size",
            "size"
          ],
          "line": 169
        },
        "resolved": true,
        "details": {
          "function_name": "generic_file_llseek_size",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/read_write.c",
          "lines": "88-134",
          "snippet": "loff_t\ngeneric_file_llseek_size(struct file *file, loff_t offset, int whence,\n\t\tloff_t maxsize, loff_t eof)\n{\n\tswitch (whence) {\n\tcase SEEK_END:\n\t\toffset += eof;\n\t\tbreak;\n\tcase SEEK_CUR:\n\t\t/*\n\t\t * Here we special-case the lseek(fd, 0, SEEK_CUR)\n\t\t * position-querying operation.  Avoid rewriting the \"same\"\n\t\t * f_pos value back to the file because a concurrent read(),\n\t\t * write() or lseek() might have altered it\n\t\t */\n\t\tif (offset == 0)\n\t\t\treturn file->f_pos;\n\t\t/*\n\t\t * f_lock protects against read/modify/write race with other\n\t\t * SEEK_CURs. Note that parallel writes and reads behave\n\t\t * like SEEK_SET.\n\t\t */\n\t\tspin_lock(&file->f_lock);\n\t\toffset = vfs_setpos(file, file->f_pos + offset, maxsize);\n\t\tspin_unlock(&file->f_lock);\n\t\treturn offset;\n\tcase SEEK_DATA:\n\t\t/*\n\t\t * In the generic case the entire file is data, so as long as\n\t\t * offset isn't at the end of the file then the offset is data.\n\t\t */\n\t\tif (offset >= eof)\n\t\t\treturn -ENXIO;\n\t\tbreak;\n\tcase SEEK_HOLE:\n\t\t/*\n\t\t * There is a virtual hole at the end of the file, so as long as\n\t\t * offset isn't i_size or larger, return i_size.\n\t\t */\n\t\tif (offset >= eof)\n\t\t\treturn -ENXIO;\n\t\toffset = eof;\n\t\tbreak;\n\t}\n\n\treturn vfs_setpos(file, offset, maxsize);\n}",
          "includes": [
            "#include <asm/unistd.h>",
            "#include <asm/uaccess.h>",
            "#include \"internal.h\"",
            "#include <linux/compat.h>",
            "#include <linux/splice.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/export.h>",
            "#include <linux/security.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/aio.h>",
            "#include <linux/uio.h>",
            "#include <linux/file.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/stat.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/unistd.h>\n#include <asm/uaccess.h>\n#include \"internal.h\"\n#include <linux/compat.h>\n#include <linux/splice.h>\n#include <linux/pagemap.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/security.h>\n#include <linux/fsnotify.h>\n#include <linux/aio.h>\n#include <linux/uio.h>\n#include <linux/file.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/slab.h>\n\nloff_t\ngeneric_file_llseek_size(struct file *file, loff_t offset, int whence,\n\t\tloff_t maxsize, loff_t eof)\n{\n\tswitch (whence) {\n\tcase SEEK_END:\n\t\toffset += eof;\n\t\tbreak;\n\tcase SEEK_CUR:\n\t\t/*\n\t\t * Here we special-case the lseek(fd, 0, SEEK_CUR)\n\t\t * position-querying operation.  Avoid rewriting the \"same\"\n\t\t * f_pos value back to the file because a concurrent read(),\n\t\t * write() or lseek() might have altered it\n\t\t */\n\t\tif (offset == 0)\n\t\t\treturn file->f_pos;\n\t\t/*\n\t\t * f_lock protects against read/modify/write race with other\n\t\t * SEEK_CURs. Note that parallel writes and reads behave\n\t\t * like SEEK_SET.\n\t\t */\n\t\tspin_lock(&file->f_lock);\n\t\toffset = vfs_setpos(file, file->f_pos + offset, maxsize);\n\t\tspin_unlock(&file->f_lock);\n\t\treturn offset;\n\tcase SEEK_DATA:\n\t\t/*\n\t\t * In the generic case the entire file is data, so as long as\n\t\t * offset isn't at the end of the file then the offset is data.\n\t\t */\n\t\tif (offset >= eof)\n\t\t\treturn -ENXIO;\n\t\tbreak;\n\tcase SEEK_HOLE:\n\t\t/*\n\t\t * There is a virtual hole at the end of the file, so as long as\n\t\t * offset isn't i_size or larger, return i_size.\n\t\t */\n\t\tif (offset >= eof)\n\t\t\treturn -ENXIO;\n\t\toffset = eof;\n\t\tbreak;\n\t}\n\n\treturn vfs_setpos(file, offset, maxsize);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/unistd.h>\n#include <asm/uaccess.h>\n#include \"internal.h\"\n#include <linux/compat.h>\n#include <linux/splice.h>\n#include <linux/pagemap.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/security.h>\n#include <linux/fsnotify.h>\n#include <linux/aio.h>\n#include <linux/uio.h>\n#include <linux/file.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/slab.h>\n\nloff_t fixed_size_llseek(struct file *file, loff_t offset, int whence, loff_t size)\n{\n\tswitch (whence) {\n\tcase SEEK_SET: case SEEK_CUR: case SEEK_END:\n\t\treturn generic_file_llseek_size(file, offset, whence,\n\t\t\t\t\t\tsize, size);\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}"
  },
  {
    "function_name": "generic_file_llseek",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/read_write.c",
    "lines": "147-154",
    "snippet": "loff_t generic_file_llseek(struct file *file, loff_t offset, int whence)\n{\n\tstruct inode *inode = file->f_mapping->host;\n\n\treturn generic_file_llseek_size(file, offset, whence,\n\t\t\t\t\tinode->i_sb->s_maxbytes,\n\t\t\t\t\ti_size_read(inode));\n}",
    "includes": [
      "#include <asm/unistd.h>",
      "#include <asm/uaccess.h>",
      "#include \"internal.h\"",
      "#include <linux/compat.h>",
      "#include <linux/splice.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/export.h>",
      "#include <linux/security.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/aio.h>",
      "#include <linux/uio.h>",
      "#include <linux/file.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/stat.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "generic_file_llseek_size",
          "args": [
            "file",
            "offset",
            "whence",
            "inode->i_sb->s_maxbytes",
            "i_size_read(inode)"
          ],
          "line": 151
        },
        "resolved": true,
        "details": {
          "function_name": "generic_file_llseek_size",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/read_write.c",
          "lines": "88-134",
          "snippet": "loff_t\ngeneric_file_llseek_size(struct file *file, loff_t offset, int whence,\n\t\tloff_t maxsize, loff_t eof)\n{\n\tswitch (whence) {\n\tcase SEEK_END:\n\t\toffset += eof;\n\t\tbreak;\n\tcase SEEK_CUR:\n\t\t/*\n\t\t * Here we special-case the lseek(fd, 0, SEEK_CUR)\n\t\t * position-querying operation.  Avoid rewriting the \"same\"\n\t\t * f_pos value back to the file because a concurrent read(),\n\t\t * write() or lseek() might have altered it\n\t\t */\n\t\tif (offset == 0)\n\t\t\treturn file->f_pos;\n\t\t/*\n\t\t * f_lock protects against read/modify/write race with other\n\t\t * SEEK_CURs. Note that parallel writes and reads behave\n\t\t * like SEEK_SET.\n\t\t */\n\t\tspin_lock(&file->f_lock);\n\t\toffset = vfs_setpos(file, file->f_pos + offset, maxsize);\n\t\tspin_unlock(&file->f_lock);\n\t\treturn offset;\n\tcase SEEK_DATA:\n\t\t/*\n\t\t * In the generic case the entire file is data, so as long as\n\t\t * offset isn't at the end of the file then the offset is data.\n\t\t */\n\t\tif (offset >= eof)\n\t\t\treturn -ENXIO;\n\t\tbreak;\n\tcase SEEK_HOLE:\n\t\t/*\n\t\t * There is a virtual hole at the end of the file, so as long as\n\t\t * offset isn't i_size or larger, return i_size.\n\t\t */\n\t\tif (offset >= eof)\n\t\t\treturn -ENXIO;\n\t\toffset = eof;\n\t\tbreak;\n\t}\n\n\treturn vfs_setpos(file, offset, maxsize);\n}",
          "includes": [
            "#include <asm/unistd.h>",
            "#include <asm/uaccess.h>",
            "#include \"internal.h\"",
            "#include <linux/compat.h>",
            "#include <linux/splice.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/export.h>",
            "#include <linux/security.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/aio.h>",
            "#include <linux/uio.h>",
            "#include <linux/file.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/stat.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/unistd.h>\n#include <asm/uaccess.h>\n#include \"internal.h\"\n#include <linux/compat.h>\n#include <linux/splice.h>\n#include <linux/pagemap.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/security.h>\n#include <linux/fsnotify.h>\n#include <linux/aio.h>\n#include <linux/uio.h>\n#include <linux/file.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/slab.h>\n\nloff_t\ngeneric_file_llseek_size(struct file *file, loff_t offset, int whence,\n\t\tloff_t maxsize, loff_t eof)\n{\n\tswitch (whence) {\n\tcase SEEK_END:\n\t\toffset += eof;\n\t\tbreak;\n\tcase SEEK_CUR:\n\t\t/*\n\t\t * Here we special-case the lseek(fd, 0, SEEK_CUR)\n\t\t * position-querying operation.  Avoid rewriting the \"same\"\n\t\t * f_pos value back to the file because a concurrent read(),\n\t\t * write() or lseek() might have altered it\n\t\t */\n\t\tif (offset == 0)\n\t\t\treturn file->f_pos;\n\t\t/*\n\t\t * f_lock protects against read/modify/write race with other\n\t\t * SEEK_CURs. Note that parallel writes and reads behave\n\t\t * like SEEK_SET.\n\t\t */\n\t\tspin_lock(&file->f_lock);\n\t\toffset = vfs_setpos(file, file->f_pos + offset, maxsize);\n\t\tspin_unlock(&file->f_lock);\n\t\treturn offset;\n\tcase SEEK_DATA:\n\t\t/*\n\t\t * In the generic case the entire file is data, so as long as\n\t\t * offset isn't at the end of the file then the offset is data.\n\t\t */\n\t\tif (offset >= eof)\n\t\t\treturn -ENXIO;\n\t\tbreak;\n\tcase SEEK_HOLE:\n\t\t/*\n\t\t * There is a virtual hole at the end of the file, so as long as\n\t\t * offset isn't i_size or larger, return i_size.\n\t\t */\n\t\tif (offset >= eof)\n\t\t\treturn -ENXIO;\n\t\toffset = eof;\n\t\tbreak;\n\t}\n\n\treturn vfs_setpos(file, offset, maxsize);\n}"
        }
      },
      {
        "call_info": {
          "callee": "i_size_read",
          "args": [
            "inode"
          ],
          "line": 153
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/unistd.h>\n#include <asm/uaccess.h>\n#include \"internal.h\"\n#include <linux/compat.h>\n#include <linux/splice.h>\n#include <linux/pagemap.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/security.h>\n#include <linux/fsnotify.h>\n#include <linux/aio.h>\n#include <linux/uio.h>\n#include <linux/file.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/slab.h>\n\nloff_t generic_file_llseek(struct file *file, loff_t offset, int whence)\n{\n\tstruct inode *inode = file->f_mapping->host;\n\n\treturn generic_file_llseek_size(file, offset, whence,\n\t\t\t\t\tinode->i_sb->s_maxbytes,\n\t\t\t\t\ti_size_read(inode));\n}"
  },
  {
    "function_name": "generic_file_llseek_size",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/read_write.c",
    "lines": "88-134",
    "snippet": "loff_t\ngeneric_file_llseek_size(struct file *file, loff_t offset, int whence,\n\t\tloff_t maxsize, loff_t eof)\n{\n\tswitch (whence) {\n\tcase SEEK_END:\n\t\toffset += eof;\n\t\tbreak;\n\tcase SEEK_CUR:\n\t\t/*\n\t\t * Here we special-case the lseek(fd, 0, SEEK_CUR)\n\t\t * position-querying operation.  Avoid rewriting the \"same\"\n\t\t * f_pos value back to the file because a concurrent read(),\n\t\t * write() or lseek() might have altered it\n\t\t */\n\t\tif (offset == 0)\n\t\t\treturn file->f_pos;\n\t\t/*\n\t\t * f_lock protects against read/modify/write race with other\n\t\t * SEEK_CURs. Note that parallel writes and reads behave\n\t\t * like SEEK_SET.\n\t\t */\n\t\tspin_lock(&file->f_lock);\n\t\toffset = vfs_setpos(file, file->f_pos + offset, maxsize);\n\t\tspin_unlock(&file->f_lock);\n\t\treturn offset;\n\tcase SEEK_DATA:\n\t\t/*\n\t\t * In the generic case the entire file is data, so as long as\n\t\t * offset isn't at the end of the file then the offset is data.\n\t\t */\n\t\tif (offset >= eof)\n\t\t\treturn -ENXIO;\n\t\tbreak;\n\tcase SEEK_HOLE:\n\t\t/*\n\t\t * There is a virtual hole at the end of the file, so as long as\n\t\t * offset isn't i_size or larger, return i_size.\n\t\t */\n\t\tif (offset >= eof)\n\t\t\treturn -ENXIO;\n\t\toffset = eof;\n\t\tbreak;\n\t}\n\n\treturn vfs_setpos(file, offset, maxsize);\n}",
    "includes": [
      "#include <asm/unistd.h>",
      "#include <asm/uaccess.h>",
      "#include \"internal.h\"",
      "#include <linux/compat.h>",
      "#include <linux/splice.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/export.h>",
      "#include <linux/security.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/aio.h>",
      "#include <linux/uio.h>",
      "#include <linux/file.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/stat.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "vfs_setpos",
          "args": [
            "file",
            "offset",
            "maxsize"
          ],
          "line": 133
        },
        "resolved": true,
        "details": {
          "function_name": "vfs_setpos",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/read_write.c",
          "lines": "57-69",
          "snippet": "loff_t vfs_setpos(struct file *file, loff_t offset, loff_t maxsize)\n{\n\tif (offset < 0 && !unsigned_offsets(file))\n\t\treturn -EINVAL;\n\tif (offset > maxsize)\n\t\treturn -EINVAL;\n\n\tif (offset != file->f_pos) {\n\t\tfile->f_pos = offset;\n\t\tfile->f_version = 0;\n\t}\n\treturn offset;\n}",
          "includes": [
            "#include <asm/unistd.h>",
            "#include <asm/uaccess.h>",
            "#include \"internal.h\"",
            "#include <linux/compat.h>",
            "#include <linux/splice.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/export.h>",
            "#include <linux/security.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/aio.h>",
            "#include <linux/uio.h>",
            "#include <linux/file.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/stat.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/unistd.h>\n#include <asm/uaccess.h>\n#include \"internal.h\"\n#include <linux/compat.h>\n#include <linux/splice.h>\n#include <linux/pagemap.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/security.h>\n#include <linux/fsnotify.h>\n#include <linux/aio.h>\n#include <linux/uio.h>\n#include <linux/file.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/slab.h>\n\nloff_t vfs_setpos(struct file *file, loff_t offset, loff_t maxsize)\n{\n\tif (offset < 0 && !unsigned_offsets(file))\n\t\treturn -EINVAL;\n\tif (offset > maxsize)\n\t\treturn -EINVAL;\n\n\tif (offset != file->f_pos) {\n\t\tfile->f_pos = offset;\n\t\tfile->f_version = 0;\n\t}\n\treturn offset;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&file->f_lock"
          ],
          "line": 112
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&file->f_lock"
          ],
          "line": 110
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/unistd.h>\n#include <asm/uaccess.h>\n#include \"internal.h\"\n#include <linux/compat.h>\n#include <linux/splice.h>\n#include <linux/pagemap.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/security.h>\n#include <linux/fsnotify.h>\n#include <linux/aio.h>\n#include <linux/uio.h>\n#include <linux/file.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/slab.h>\n\nloff_t\ngeneric_file_llseek_size(struct file *file, loff_t offset, int whence,\n\t\tloff_t maxsize, loff_t eof)\n{\n\tswitch (whence) {\n\tcase SEEK_END:\n\t\toffset += eof;\n\t\tbreak;\n\tcase SEEK_CUR:\n\t\t/*\n\t\t * Here we special-case the lseek(fd, 0, SEEK_CUR)\n\t\t * position-querying operation.  Avoid rewriting the \"same\"\n\t\t * f_pos value back to the file because a concurrent read(),\n\t\t * write() or lseek() might have altered it\n\t\t */\n\t\tif (offset == 0)\n\t\t\treturn file->f_pos;\n\t\t/*\n\t\t * f_lock protects against read/modify/write race with other\n\t\t * SEEK_CURs. Note that parallel writes and reads behave\n\t\t * like SEEK_SET.\n\t\t */\n\t\tspin_lock(&file->f_lock);\n\t\toffset = vfs_setpos(file, file->f_pos + offset, maxsize);\n\t\tspin_unlock(&file->f_lock);\n\t\treturn offset;\n\tcase SEEK_DATA:\n\t\t/*\n\t\t * In the generic case the entire file is data, so as long as\n\t\t * offset isn't at the end of the file then the offset is data.\n\t\t */\n\t\tif (offset >= eof)\n\t\t\treturn -ENXIO;\n\t\tbreak;\n\tcase SEEK_HOLE:\n\t\t/*\n\t\t * There is a virtual hole at the end of the file, so as long as\n\t\t * offset isn't i_size or larger, return i_size.\n\t\t */\n\t\tif (offset >= eof)\n\t\t\treturn -ENXIO;\n\t\toffset = eof;\n\t\tbreak;\n\t}\n\n\treturn vfs_setpos(file, offset, maxsize);\n}"
  },
  {
    "function_name": "vfs_setpos",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/read_write.c",
    "lines": "57-69",
    "snippet": "loff_t vfs_setpos(struct file *file, loff_t offset, loff_t maxsize)\n{\n\tif (offset < 0 && !unsigned_offsets(file))\n\t\treturn -EINVAL;\n\tif (offset > maxsize)\n\t\treturn -EINVAL;\n\n\tif (offset != file->f_pos) {\n\t\tfile->f_pos = offset;\n\t\tfile->f_version = 0;\n\t}\n\treturn offset;\n}",
    "includes": [
      "#include <asm/unistd.h>",
      "#include <asm/uaccess.h>",
      "#include \"internal.h\"",
      "#include <linux/compat.h>",
      "#include <linux/splice.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/export.h>",
      "#include <linux/security.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/aio.h>",
      "#include <linux/uio.h>",
      "#include <linux/file.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/stat.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "unsigned_offsets",
          "args": [
            "file"
          ],
          "line": 59
        },
        "resolved": true,
        "details": {
          "function_name": "unsigned_offsets",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/read_write.c",
          "lines": "40-43",
          "snippet": "static inline int unsigned_offsets(struct file *file)\n{\n\treturn file->f_mode & FMODE_UNSIGNED_OFFSET;\n}",
          "includes": [
            "#include <asm/unistd.h>",
            "#include <asm/uaccess.h>",
            "#include \"internal.h\"",
            "#include <linux/compat.h>",
            "#include <linux/splice.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/export.h>",
            "#include <linux/security.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/aio.h>",
            "#include <linux/uio.h>",
            "#include <linux/file.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/stat.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/unistd.h>\n#include <asm/uaccess.h>\n#include \"internal.h\"\n#include <linux/compat.h>\n#include <linux/splice.h>\n#include <linux/pagemap.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/security.h>\n#include <linux/fsnotify.h>\n#include <linux/aio.h>\n#include <linux/uio.h>\n#include <linux/file.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/slab.h>\n\nstatic inline int unsigned_offsets(struct file *file)\n{\n\treturn file->f_mode & FMODE_UNSIGNED_OFFSET;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/unistd.h>\n#include <asm/uaccess.h>\n#include \"internal.h\"\n#include <linux/compat.h>\n#include <linux/splice.h>\n#include <linux/pagemap.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/security.h>\n#include <linux/fsnotify.h>\n#include <linux/aio.h>\n#include <linux/uio.h>\n#include <linux/file.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/slab.h>\n\nloff_t vfs_setpos(struct file *file, loff_t offset, loff_t maxsize)\n{\n\tif (offset < 0 && !unsigned_offsets(file))\n\t\treturn -EINVAL;\n\tif (offset > maxsize)\n\t\treturn -EINVAL;\n\n\tif (offset != file->f_pos) {\n\t\tfile->f_pos = offset;\n\t\tfile->f_version = 0;\n\t}\n\treturn offset;\n}"
  },
  {
    "function_name": "unsigned_offsets",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/read_write.c",
    "lines": "40-43",
    "snippet": "static inline int unsigned_offsets(struct file *file)\n{\n\treturn file->f_mode & FMODE_UNSIGNED_OFFSET;\n}",
    "includes": [
      "#include <asm/unistd.h>",
      "#include <asm/uaccess.h>",
      "#include \"internal.h\"",
      "#include <linux/compat.h>",
      "#include <linux/splice.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/export.h>",
      "#include <linux/security.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/aio.h>",
      "#include <linux/uio.h>",
      "#include <linux/file.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/stat.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <asm/unistd.h>\n#include <asm/uaccess.h>\n#include \"internal.h\"\n#include <linux/compat.h>\n#include <linux/splice.h>\n#include <linux/pagemap.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/security.h>\n#include <linux/fsnotify.h>\n#include <linux/aio.h>\n#include <linux/uio.h>\n#include <linux/file.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/slab.h>\n\nstatic inline int unsigned_offsets(struct file *file)\n{\n\treturn file->f_mode & FMODE_UNSIGNED_OFFSET;\n}"
  }
]