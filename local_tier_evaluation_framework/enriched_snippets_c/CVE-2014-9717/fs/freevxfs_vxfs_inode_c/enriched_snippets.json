[
  {
    "function_name": "vxfs_evict_inode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/freevxfs/vxfs_inode.c",
    "lines": "354-360",
    "snippet": "void\nvxfs_evict_inode(struct inode *ip)\n{\n\ttruncate_inode_pages_final(&ip->i_data);\n\tclear_inode(ip);\n\tcall_rcu(&ip->i_rcu, vxfs_i_callback);\n}",
    "includes": [
      "#include \"vxfs_extern.h\"",
      "#include \"vxfs_inode.h\"",
      "#include \"vxfs.h\"",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "call_rcu",
          "args": [
            "&ip->i_rcu",
            "vxfs_i_callback"
          ],
          "line": 359
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clear_inode",
          "args": [
            "ip"
          ],
          "line": 358
        },
        "resolved": true,
        "details": {
          "function_name": "clear_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "488-505",
          "snippet": "void clear_inode(struct inode *inode)\n{\n\tmight_sleep();\n\t/*\n\t * We have to cycle tree_lock here because reclaim can be still in the\n\t * process of removing the last page (in __delete_from_page_cache())\n\t * and we must not free mapping under it.\n\t */\n\tspin_lock_irq(&inode->i_data.tree_lock);\n\tBUG_ON(inode->i_data.nrpages);\n\tBUG_ON(inode->i_data.nrshadows);\n\tspin_unlock_irq(&inode->i_data.tree_lock);\n\tBUG_ON(!list_empty(&inode->i_data.private_list));\n\tBUG_ON(!(inode->i_state & I_FREEING));\n\tBUG_ON(inode->i_state & I_CLEAR);\n\t/* don't need i_lock here, no concurrent mods to i_state */\n\tinode->i_state = I_FREEING | I_CLEAR;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid clear_inode(struct inode *inode)\n{\n\tmight_sleep();\n\t/*\n\t * We have to cycle tree_lock here because reclaim can be still in the\n\t * process of removing the last page (in __delete_from_page_cache())\n\t * and we must not free mapping under it.\n\t */\n\tspin_lock_irq(&inode->i_data.tree_lock);\n\tBUG_ON(inode->i_data.nrpages);\n\tBUG_ON(inode->i_data.nrshadows);\n\tspin_unlock_irq(&inode->i_data.tree_lock);\n\tBUG_ON(!list_empty(&inode->i_data.private_list));\n\tBUG_ON(!(inode->i_state & I_FREEING));\n\tBUG_ON(inode->i_state & I_CLEAR);\n\t/* don't need i_lock here, no concurrent mods to i_state */\n\tinode->i_state = I_FREEING | I_CLEAR;\n}"
        }
      },
      {
        "call_info": {
          "callee": "truncate_inode_pages_final",
          "args": [
            "&ip->i_data"
          ],
          "line": 357
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"vxfs_extern.h\"\n#include \"vxfs_inode.h\"\n#include \"vxfs.h\"\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/pagemap.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n\nvoid\nvxfs_evict_inode(struct inode *ip)\n{\n\ttruncate_inode_pages_final(&ip->i_data);\n\tclear_inode(ip);\n\tcall_rcu(&ip->i_rcu, vxfs_i_callback);\n}"
  },
  {
    "function_name": "vxfs_i_callback",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/freevxfs/vxfs_inode.c",
    "lines": "340-344",
    "snippet": "static void vxfs_i_callback(struct rcu_head *head)\n{\n\tstruct inode *inode = container_of(head, struct inode, i_rcu);\n\tkmem_cache_free(vxfs_inode_cachep, inode->i_private);\n}",
    "includes": [
      "#include \"vxfs_extern.h\"",
      "#include \"vxfs_inode.h\"",
      "#include \"vxfs.h\"",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "struct kmem_cache\t\t*vxfs_inode_cachep;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kmem_cache_free",
          "args": [
            "vxfs_inode_cachep",
            "inode->i_private"
          ],
          "line": 343
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "head",
            "structinode",
            "i_rcu"
          ],
          "line": 342
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"vxfs_extern.h\"\n#include \"vxfs_inode.h\"\n#include \"vxfs.h\"\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/pagemap.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n\nstruct kmem_cache\t\t*vxfs_inode_cachep;\n\nstatic void vxfs_i_callback(struct rcu_head *head)\n{\n\tstruct inode *inode = container_of(head, struct inode, i_rcu);\n\tkmem_cache_free(vxfs_inode_cachep, inode->i_private);\n}"
  },
  {
    "function_name": "vxfs_iget",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/freevxfs/vxfs_inode.c",
    "lines": "292-338",
    "snippet": "struct inode *\nvxfs_iget(struct super_block *sbp, ino_t ino)\n{\n\tstruct vxfs_inode_info\t\t*vip;\n\tconst struct address_space_operations\t*aops;\n\tstruct inode *ip;\n\n\tip = iget_locked(sbp, ino);\n\tif (!ip)\n\t\treturn ERR_PTR(-ENOMEM);\n\tif (!(ip->i_state & I_NEW))\n\t\treturn ip;\n\n\tvip = __vxfs_iget(ino, VXFS_SBI(sbp)->vsi_ilist);\n\tif (IS_ERR(vip)) {\n\t\tiget_failed(ip);\n\t\treturn ERR_CAST(vip);\n\t}\n\n\tvxfs_iinit(ip, vip);\n\n\tif (VXFS_ISIMMED(vip))\n\t\taops = &vxfs_immed_aops;\n\telse\n\t\taops = &vxfs_aops;\n\n\tif (S_ISREG(ip->i_mode)) {\n\t\tip->i_fop = &generic_ro_fops;\n\t\tip->i_mapping->a_ops = aops;\n\t} else if (S_ISDIR(ip->i_mode)) {\n\t\tip->i_op = &vxfs_dir_inode_ops;\n\t\tip->i_fop = &vxfs_dir_operations;\n\t\tip->i_mapping->a_ops = aops;\n\t} else if (S_ISLNK(ip->i_mode)) {\n\t\tif (!VXFS_ISIMMED(vip)) {\n\t\t\tip->i_op = &page_symlink_inode_operations;\n\t\t\tip->i_mapping->a_ops = &vxfs_aops;\n\t\t} else {\n\t\t\tip->i_op = &vxfs_immed_symlink_iops;\n\t\t\tvip->vii_immed.vi_immed[ip->i_size] = '\\0';\n\t\t}\n\t} else\n\t\tinit_special_inode(ip, ip->i_mode, old_decode_dev(vip->vii_rdev));\n\n\tunlock_new_inode(ip);\n\treturn ip;\n}",
    "includes": [
      "#include \"vxfs_extern.h\"",
      "#include \"vxfs_inode.h\"",
      "#include \"vxfs.h\"",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "unlock_new_inode",
          "args": [
            "ip"
          ],
          "line": 336
        },
        "resolved": true,
        "details": {
          "function_name": "unlock_new_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "924-933",
          "snippet": "void unlock_new_inode(struct inode *inode)\n{\n\tlockdep_annotate_inode_mutex_key(inode);\n\tspin_lock(&inode->i_lock);\n\tWARN_ON(!(inode->i_state & I_NEW));\n\tinode->i_state &= ~I_NEW;\n\tsmp_mb();\n\twake_up_bit(&inode->i_state, __I_NEW);\n\tspin_unlock(&inode->i_lock);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid unlock_new_inode(struct inode *inode)\n{\n\tlockdep_annotate_inode_mutex_key(inode);\n\tspin_lock(&inode->i_lock);\n\tWARN_ON(!(inode->i_state & I_NEW));\n\tinode->i_state &= ~I_NEW;\n\tsmp_mb();\n\twake_up_bit(&inode->i_state, __I_NEW);\n\tspin_unlock(&inode->i_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "init_special_inode",
          "args": [
            "ip",
            "ip->i_mode",
            "old_decode_dev(vip->vii_rdev)"
          ],
          "line": 334
        },
        "resolved": true,
        "details": {
          "function_name": "init_special_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "1854-1871",
          "snippet": "void init_special_inode(struct inode *inode, umode_t mode, dev_t rdev)\n{\n\tinode->i_mode = mode;\n\tif (S_ISCHR(mode)) {\n\t\tinode->i_fop = &def_chr_fops;\n\t\tinode->i_rdev = rdev;\n\t} else if (S_ISBLK(mode)) {\n\t\tinode->i_fop = &def_blk_fops;\n\t\tinode->i_rdev = rdev;\n\t} else if (S_ISFIFO(mode))\n\t\tinode->i_fop = &pipefifo_fops;\n\telse if (S_ISSOCK(mode))\n\t\t;\t/* leave it no_open_fops */\n\telse\n\t\tprintk(KERN_DEBUG \"init_special_inode: bogus i_mode (%o) for\"\n\t\t\t\t  \" inode %s:%lu\\n\", mode, inode->i_sb->s_id,\n\t\t\t\t  inode->i_ino);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid init_special_inode(struct inode *inode, umode_t mode, dev_t rdev)\n{\n\tinode->i_mode = mode;\n\tif (S_ISCHR(mode)) {\n\t\tinode->i_fop = &def_chr_fops;\n\t\tinode->i_rdev = rdev;\n\t} else if (S_ISBLK(mode)) {\n\t\tinode->i_fop = &def_blk_fops;\n\t\tinode->i_rdev = rdev;\n\t} else if (S_ISFIFO(mode))\n\t\tinode->i_fop = &pipefifo_fops;\n\telse if (S_ISSOCK(mode))\n\t\t;\t/* leave it no_open_fops */\n\telse\n\t\tprintk(KERN_DEBUG \"init_special_inode: bogus i_mode (%o) for\"\n\t\t\t\t  \" inode %s:%lu\\n\", mode, inode->i_sb->s_id,\n\t\t\t\t  inode->i_ino);\n}"
        }
      },
      {
        "call_info": {
          "callee": "old_decode_dev",
          "args": [
            "vip->vii_rdev"
          ],
          "line": 334
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VXFS_ISIMMED",
          "args": [
            "vip"
          ],
          "line": 326
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISLNK",
          "args": [
            "ip->i_mode"
          ],
          "line": 325
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISDIR",
          "args": [
            "ip->i_mode"
          ],
          "line": 321
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISREG",
          "args": [
            "ip->i_mode"
          ],
          "line": 318
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VXFS_ISIMMED",
          "args": [
            "vip"
          ],
          "line": 313
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vxfs_iinit",
          "args": [
            "ip",
            "vip"
          ],
          "line": 311
        },
        "resolved": true,
        "details": {
          "function_name": "vxfs_iinit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/freevxfs/vxfs_inode.c",
          "lines": "222-245",
          "snippet": "static void\nvxfs_iinit(struct inode *ip, struct vxfs_inode_info *vip)\n{\n\n\tip->i_mode = vxfs_transmod(vip);\n\ti_uid_write(ip, (uid_t)vip->vii_uid);\n\ti_gid_write(ip, (gid_t)vip->vii_gid);\n\n\tset_nlink(ip, vip->vii_nlink);\n\tip->i_size = vip->vii_size;\n\n\tip->i_atime.tv_sec = vip->vii_atime;\n\tip->i_ctime.tv_sec = vip->vii_ctime;\n\tip->i_mtime.tv_sec = vip->vii_mtime;\n\tip->i_atime.tv_nsec = 0;\n\tip->i_ctime.tv_nsec = 0;\n\tip->i_mtime.tv_nsec = 0;\n\n\tip->i_blocks = vip->vii_blocks;\n\tip->i_generation = vip->vii_gen;\n\n\tip->i_private = vip;\n\t\n}",
          "includes": [
            "#include \"vxfs_extern.h\"",
            "#include \"vxfs_inode.h\"",
            "#include \"vxfs.h\"",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vxfs_extern.h\"\n#include \"vxfs_inode.h\"\n#include \"vxfs.h\"\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/pagemap.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n\nstatic void\nvxfs_iinit(struct inode *ip, struct vxfs_inode_info *vip)\n{\n\n\tip->i_mode = vxfs_transmod(vip);\n\ti_uid_write(ip, (uid_t)vip->vii_uid);\n\ti_gid_write(ip, (gid_t)vip->vii_gid);\n\n\tset_nlink(ip, vip->vii_nlink);\n\tip->i_size = vip->vii_size;\n\n\tip->i_atime.tv_sec = vip->vii_atime;\n\tip->i_ctime.tv_sec = vip->vii_ctime;\n\tip->i_mtime.tv_sec = vip->vii_mtime;\n\tip->i_atime.tv_nsec = 0;\n\tip->i_ctime.tv_nsec = 0;\n\tip->i_mtime.tv_nsec = 0;\n\n\tip->i_blocks = vip->vii_blocks;\n\tip->i_generation = vip->vii_gen;\n\n\tip->i_private = vip;\n\t\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERR_CAST",
          "args": [
            "vip"
          ],
          "line": 308
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "iget_failed",
          "args": [
            "ip"
          ],
          "line": 307
        },
        "resolved": true,
        "details": {
          "function_name": "iget_failed",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/bad_inode.c",
          "lines": "208-213",
          "snippet": "void iget_failed(struct inode *inode)\n{\n\tmake_bad_inode(inode);\n\tunlock_new_inode(inode);\n\tiput(inode);\n}",
          "includes": [
            "#include <linux/poll.h>",
            "#include <linux/namei.h>",
            "#include <linux/time.h>",
            "#include <linux/stat.h>",
            "#include <linux/export.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/poll.h>\n#include <linux/namei.h>\n#include <linux/time.h>\n#include <linux/stat.h>\n#include <linux/export.h>\n#include <linux/fs.h>\n\nvoid iget_failed(struct inode *inode)\n{\n\tmake_bad_inode(inode);\n\tunlock_new_inode(inode);\n\tiput(inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "vip"
          ],
          "line": 306
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__vxfs_iget",
          "args": [
            "ino",
            "VXFS_SBI(sbp)->vsi_ilist"
          ],
          "line": 305
        },
        "resolved": true,
        "details": {
          "function_name": "__vxfs_iget",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/freevxfs/vxfs_inode.c",
          "lines": "129-161",
          "snippet": "static struct vxfs_inode_info *\n__vxfs_iget(ino_t ino, struct inode *ilistp)\n{\n\tstruct page\t\t\t*pp;\n\tu_long\t\t\t\toffset;\n\n\toffset = (ino % (PAGE_SIZE / VXFS_ISIZE)) * VXFS_ISIZE;\n\tpp = vxfs_get_page(ilistp->i_mapping, ino * VXFS_ISIZE / PAGE_SIZE);\n\n\tif (!IS_ERR(pp)) {\n\t\tstruct vxfs_inode_info\t*vip;\n\t\tstruct vxfs_dinode\t*dip;\n\t\tcaddr_t\t\t\tkaddr = (char *)page_address(pp);\n\n\t\tif (!(vip = kmem_cache_alloc(vxfs_inode_cachep, GFP_KERNEL)))\n\t\t\tgoto fail;\n\t\tdip = (struct vxfs_dinode *)(kaddr + offset);\n\t\tmemcpy(vip, dip, sizeof(*vip));\n#ifdef DIAGNOSTIC\n\t\tvxfs_dumpi(vip, ino);\n#endif\n\t\tvxfs_put_page(pp);\n\t\treturn (vip);\n\t}\n\n\tprintk(KERN_WARNING \"vxfs: error on page %p\\n\", pp);\n\treturn ERR_CAST(pp);\n\nfail:\n\tprintk(KERN_WARNING \"vxfs: unable to read inode %ld\\n\", (unsigned long)ino);\n\tvxfs_put_page(pp);\n\treturn ERR_PTR(-ENOMEM);\n}",
          "includes": [
            "#include \"vxfs_extern.h\"",
            "#include \"vxfs_inode.h\"",
            "#include \"vxfs.h\"",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct kmem_cache\t\t*vxfs_inode_cachep;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"vxfs_extern.h\"\n#include \"vxfs_inode.h\"\n#include \"vxfs.h\"\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/pagemap.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n\nstruct kmem_cache\t\t*vxfs_inode_cachep;\n\nstatic struct vxfs_inode_info *\n__vxfs_iget(ino_t ino, struct inode *ilistp)\n{\n\tstruct page\t\t\t*pp;\n\tu_long\t\t\t\toffset;\n\n\toffset = (ino % (PAGE_SIZE / VXFS_ISIZE)) * VXFS_ISIZE;\n\tpp = vxfs_get_page(ilistp->i_mapping, ino * VXFS_ISIZE / PAGE_SIZE);\n\n\tif (!IS_ERR(pp)) {\n\t\tstruct vxfs_inode_info\t*vip;\n\t\tstruct vxfs_dinode\t*dip;\n\t\tcaddr_t\t\t\tkaddr = (char *)page_address(pp);\n\n\t\tif (!(vip = kmem_cache_alloc(vxfs_inode_cachep, GFP_KERNEL)))\n\t\t\tgoto fail;\n\t\tdip = (struct vxfs_dinode *)(kaddr + offset);\n\t\tmemcpy(vip, dip, sizeof(*vip));\n#ifdef DIAGNOSTIC\n\t\tvxfs_dumpi(vip, ino);\n#endif\n\t\tvxfs_put_page(pp);\n\t\treturn (vip);\n\t}\n\n\tprintk(KERN_WARNING \"vxfs: error on page %p\\n\", pp);\n\treturn ERR_CAST(pp);\n\nfail:\n\tprintk(KERN_WARNING \"vxfs: unable to read inode %ld\\n\", (unsigned long)ino);\n\tvxfs_put_page(pp);\n\treturn ERR_PTR(-ENOMEM);\n}"
        }
      },
      {
        "call_info": {
          "callee": "VXFS_SBI",
          "args": [
            "sbp"
          ],
          "line": 305
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ENOMEM"
          ],
          "line": 301
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "iget_locked",
          "args": [
            "sbp",
            "ino"
          ],
          "line": 299
        },
        "resolved": true,
        "details": {
          "function_name": "iget_locked",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "1063-1109",
          "snippet": "struct inode *iget_locked(struct super_block *sb, unsigned long ino)\n{\n\tstruct hlist_head *head = inode_hashtable + hash(sb, ino);\n\tstruct inode *inode;\n\n\tspin_lock(&inode_hash_lock);\n\tinode = find_inode_fast(sb, head, ino);\n\tspin_unlock(&inode_hash_lock);\n\tif (inode) {\n\t\twait_on_inode(inode);\n\t\treturn inode;\n\t}\n\n\tinode = alloc_inode(sb);\n\tif (inode) {\n\t\tstruct inode *old;\n\n\t\tspin_lock(&inode_hash_lock);\n\t\t/* We released the lock, so.. */\n\t\told = find_inode_fast(sb, head, ino);\n\t\tif (!old) {\n\t\t\tinode->i_ino = ino;\n\t\t\tspin_lock(&inode->i_lock);\n\t\t\tinode->i_state = I_NEW;\n\t\t\thlist_add_head(&inode->i_hash, head);\n\t\t\tspin_unlock(&inode->i_lock);\n\t\t\tinode_sb_list_add(inode);\n\t\t\tspin_unlock(&inode_hash_lock);\n\n\t\t\t/* Return the locked inode with I_NEW set, the\n\t\t\t * caller is responsible for filling in the contents\n\t\t\t */\n\t\t\treturn inode;\n\t\t}\n\n\t\t/*\n\t\t * Uhhuh, somebody else created the same inode under\n\t\t * us. Use the old inode instead of the one we just\n\t\t * allocated.\n\t\t */\n\t\tspin_unlock(&inode_hash_lock);\n\t\tdestroy_inode(inode);\n\t\tinode = old;\n\t\twait_on_inode(inode);\n\t}\n\treturn inode;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct hlist_head *inode_hashtable",
            "static __cacheline_aligned_in_smp DEFINE_SPINLOCK(inode_hash_lock);",
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic struct hlist_head *inode_hashtable;\nstatic __cacheline_aligned_in_smp DEFINE_SPINLOCK(inode_hash_lock);\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nstruct inode *iget_locked(struct super_block *sb, unsigned long ino)\n{\n\tstruct hlist_head *head = inode_hashtable + hash(sb, ino);\n\tstruct inode *inode;\n\n\tspin_lock(&inode_hash_lock);\n\tinode = find_inode_fast(sb, head, ino);\n\tspin_unlock(&inode_hash_lock);\n\tif (inode) {\n\t\twait_on_inode(inode);\n\t\treturn inode;\n\t}\n\n\tinode = alloc_inode(sb);\n\tif (inode) {\n\t\tstruct inode *old;\n\n\t\tspin_lock(&inode_hash_lock);\n\t\t/* We released the lock, so.. */\n\t\told = find_inode_fast(sb, head, ino);\n\t\tif (!old) {\n\t\t\tinode->i_ino = ino;\n\t\t\tspin_lock(&inode->i_lock);\n\t\t\tinode->i_state = I_NEW;\n\t\t\thlist_add_head(&inode->i_hash, head);\n\t\t\tspin_unlock(&inode->i_lock);\n\t\t\tinode_sb_list_add(inode);\n\t\t\tspin_unlock(&inode_hash_lock);\n\n\t\t\t/* Return the locked inode with I_NEW set, the\n\t\t\t * caller is responsible for filling in the contents\n\t\t\t */\n\t\t\treturn inode;\n\t\t}\n\n\t\t/*\n\t\t * Uhhuh, somebody else created the same inode under\n\t\t * us. Use the old inode instead of the one we just\n\t\t * allocated.\n\t\t */\n\t\tspin_unlock(&inode_hash_lock);\n\t\tdestroy_inode(inode);\n\t\tinode = old;\n\t\twait_on_inode(inode);\n\t}\n\treturn inode;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"vxfs_extern.h\"\n#include \"vxfs_inode.h\"\n#include \"vxfs.h\"\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/pagemap.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n\nstruct inode *\nvxfs_iget(struct super_block *sbp, ino_t ino)\n{\n\tstruct vxfs_inode_info\t\t*vip;\n\tconst struct address_space_operations\t*aops;\n\tstruct inode *ip;\n\n\tip = iget_locked(sbp, ino);\n\tif (!ip)\n\t\treturn ERR_PTR(-ENOMEM);\n\tif (!(ip->i_state & I_NEW))\n\t\treturn ip;\n\n\tvip = __vxfs_iget(ino, VXFS_SBI(sbp)->vsi_ilist);\n\tif (IS_ERR(vip)) {\n\t\tiget_failed(ip);\n\t\treturn ERR_CAST(vip);\n\t}\n\n\tvxfs_iinit(ip, vip);\n\n\tif (VXFS_ISIMMED(vip))\n\t\taops = &vxfs_immed_aops;\n\telse\n\t\taops = &vxfs_aops;\n\n\tif (S_ISREG(ip->i_mode)) {\n\t\tip->i_fop = &generic_ro_fops;\n\t\tip->i_mapping->a_ops = aops;\n\t} else if (S_ISDIR(ip->i_mode)) {\n\t\tip->i_op = &vxfs_dir_inode_ops;\n\t\tip->i_fop = &vxfs_dir_operations;\n\t\tip->i_mapping->a_ops = aops;\n\t} else if (S_ISLNK(ip->i_mode)) {\n\t\tif (!VXFS_ISIMMED(vip)) {\n\t\t\tip->i_op = &page_symlink_inode_operations;\n\t\t\tip->i_mapping->a_ops = &vxfs_aops;\n\t\t} else {\n\t\t\tip->i_op = &vxfs_immed_symlink_iops;\n\t\t\tvip->vii_immed.vi_immed[ip->i_size] = '\\0';\n\t\t}\n\t} else\n\t\tinit_special_inode(ip, ip->i_mode, old_decode_dev(vip->vii_rdev));\n\n\tunlock_new_inode(ip);\n\treturn ip;\n}"
  },
  {
    "function_name": "vxfs_put_fake_inode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/freevxfs/vxfs_inode.c",
    "lines": "277-281",
    "snippet": "void\nvxfs_put_fake_inode(struct inode *ip)\n{\n\tiput(ip);\n}",
    "includes": [
      "#include \"vxfs_extern.h\"",
      "#include \"vxfs_inode.h\"",
      "#include \"vxfs.h\"",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "iput",
          "args": [
            "ip"
          ],
          "line": 280
        },
        "resolved": true,
        "details": {
          "function_name": "dentry_iput",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "308-327",
          "snippet": "static void dentry_iput(struct dentry * dentry)\n\t__releases(dentry->d_lock)\n\t__releases(dentry->d_inode->i_lock)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tif (inode) {\n\t\tdentry->d_inode = NULL;\n\t\thlist_del_init(&dentry->d_u.d_alias);\n\t\tspin_unlock(&dentry->d_lock);\n\t\tspin_unlock(&inode->i_lock);\n\t\tif (!inode->i_nlink)\n\t\t\tfsnotify_inoderemove(inode);\n\t\tif (dentry->d_op && dentry->d_op->d_iput)\n\t\t\tdentry->d_op->d_iput(dentry, inode);\n\t\telse\n\t\t\tiput(inode);\n\t} else {\n\t\tspin_unlock(&dentry->d_lock);\n\t}\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nstatic void dentry_iput(struct dentry * dentry)\n\t__releases(dentry->d_lock)\n\t__releases(dentry->d_inode->i_lock)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tif (inode) {\n\t\tdentry->d_inode = NULL;\n\t\thlist_del_init(&dentry->d_u.d_alias);\n\t\tspin_unlock(&dentry->d_lock);\n\t\tspin_unlock(&inode->i_lock);\n\t\tif (!inode->i_nlink)\n\t\t\tfsnotify_inoderemove(inode);\n\t\tif (dentry->d_op && dentry->d_op->d_iput)\n\t\t\tdentry->d_op->d_iput(dentry, inode);\n\t\telse\n\t\t\tiput(inode);\n\t} else {\n\t\tspin_unlock(&dentry->d_lock);\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"vxfs_extern.h\"\n#include \"vxfs_inode.h\"\n#include \"vxfs.h\"\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/pagemap.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n\nvoid\nvxfs_put_fake_inode(struct inode *ip)\n{\n\tiput(ip);\n}"
  },
  {
    "function_name": "vxfs_get_fake_inode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/freevxfs/vxfs_inode.c",
    "lines": "257-268",
    "snippet": "struct inode *\nvxfs_get_fake_inode(struct super_block *sbp, struct vxfs_inode_info *vip)\n{\n\tstruct inode\t\t\t*ip = NULL;\n\n\tif ((ip = new_inode(sbp))) {\n\t\tip->i_ino = get_next_ino();\n\t\tvxfs_iinit(ip, vip);\n\t\tip->i_mapping->a_ops = &vxfs_aops;\n\t}\n\treturn (ip);\n}",
    "includes": [
      "#include \"vxfs_extern.h\"",
      "#include \"vxfs_inode.h\"",
      "#include \"vxfs.h\"",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "vxfs_iinit",
          "args": [
            "ip",
            "vip"
          ],
          "line": 264
        },
        "resolved": true,
        "details": {
          "function_name": "vxfs_iinit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/freevxfs/vxfs_inode.c",
          "lines": "222-245",
          "snippet": "static void\nvxfs_iinit(struct inode *ip, struct vxfs_inode_info *vip)\n{\n\n\tip->i_mode = vxfs_transmod(vip);\n\ti_uid_write(ip, (uid_t)vip->vii_uid);\n\ti_gid_write(ip, (gid_t)vip->vii_gid);\n\n\tset_nlink(ip, vip->vii_nlink);\n\tip->i_size = vip->vii_size;\n\n\tip->i_atime.tv_sec = vip->vii_atime;\n\tip->i_ctime.tv_sec = vip->vii_ctime;\n\tip->i_mtime.tv_sec = vip->vii_mtime;\n\tip->i_atime.tv_nsec = 0;\n\tip->i_ctime.tv_nsec = 0;\n\tip->i_mtime.tv_nsec = 0;\n\n\tip->i_blocks = vip->vii_blocks;\n\tip->i_generation = vip->vii_gen;\n\n\tip->i_private = vip;\n\t\n}",
          "includes": [
            "#include \"vxfs_extern.h\"",
            "#include \"vxfs_inode.h\"",
            "#include \"vxfs.h\"",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vxfs_extern.h\"\n#include \"vxfs_inode.h\"\n#include \"vxfs.h\"\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/pagemap.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n\nstatic void\nvxfs_iinit(struct inode *ip, struct vxfs_inode_info *vip)\n{\n\n\tip->i_mode = vxfs_transmod(vip);\n\ti_uid_write(ip, (uid_t)vip->vii_uid);\n\ti_gid_write(ip, (gid_t)vip->vii_gid);\n\n\tset_nlink(ip, vip->vii_nlink);\n\tip->i_size = vip->vii_size;\n\n\tip->i_atime.tv_sec = vip->vii_atime;\n\tip->i_ctime.tv_sec = vip->vii_ctime;\n\tip->i_mtime.tv_sec = vip->vii_mtime;\n\tip->i_atime.tv_nsec = 0;\n\tip->i_ctime.tv_nsec = 0;\n\tip->i_mtime.tv_nsec = 0;\n\n\tip->i_blocks = vip->vii_blocks;\n\tip->i_generation = vip->vii_gen;\n\n\tip->i_private = vip;\n\t\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_next_ino",
          "args": [],
          "line": 263
        },
        "resolved": true,
        "details": {
          "function_name": "get_next_ino",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "828-845",
          "snippet": "unsigned int get_next_ino(void)\n{\n\tunsigned int *p = &get_cpu_var(last_ino);\n\tunsigned int res = *p;\n\n#ifdef CONFIG_SMP\n\tif (unlikely((res & (LAST_INO_BATCH-1)) == 0)) {\n\t\tstatic atomic_t shared_last_ino;\n\t\tint next = atomic_add_return(LAST_INO_BATCH, &shared_last_ino);\n\n\t\tres = next - LAST_INO_BATCH;\n\t}\n#endif\n\n\t*p = ++res;\n\tput_cpu_var(last_ino);\n\treturn res;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [
            "#define LAST_INO_BATCH 1024"
          ],
          "globals_used": [
            "static DEFINE_PER_CPU(unsigned int, last_ino);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\n#define LAST_INO_BATCH 1024\n\nstatic DEFINE_PER_CPU(unsigned int, last_ino);\n\nunsigned int get_next_ino(void)\n{\n\tunsigned int *p = &get_cpu_var(last_ino);\n\tunsigned int res = *p;\n\n#ifdef CONFIG_SMP\n\tif (unlikely((res & (LAST_INO_BATCH-1)) == 0)) {\n\t\tstatic atomic_t shared_last_ino;\n\t\tint next = atomic_add_return(LAST_INO_BATCH, &shared_last_ino);\n\n\t\tres = next - LAST_INO_BATCH;\n\t}\n#endif\n\n\t*p = ++res;\n\tput_cpu_var(last_ino);\n\treturn res;\n}"
        }
      },
      {
        "call_info": {
          "callee": "new_inode",
          "args": [
            "sbp"
          ],
          "line": 262
        },
        "resolved": true,
        "details": {
          "function_name": "unlock_new_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "924-933",
          "snippet": "void unlock_new_inode(struct inode *inode)\n{\n\tlockdep_annotate_inode_mutex_key(inode);\n\tspin_lock(&inode->i_lock);\n\tWARN_ON(!(inode->i_state & I_NEW));\n\tinode->i_state &= ~I_NEW;\n\tsmp_mb();\n\twake_up_bit(&inode->i_state, __I_NEW);\n\tspin_unlock(&inode->i_lock);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid unlock_new_inode(struct inode *inode)\n{\n\tlockdep_annotate_inode_mutex_key(inode);\n\tspin_lock(&inode->i_lock);\n\tWARN_ON(!(inode->i_state & I_NEW));\n\tinode->i_state &= ~I_NEW;\n\tsmp_mb();\n\twake_up_bit(&inode->i_state, __I_NEW);\n\tspin_unlock(&inode->i_lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"vxfs_extern.h\"\n#include \"vxfs_inode.h\"\n#include \"vxfs.h\"\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/pagemap.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n\nstruct inode *\nvxfs_get_fake_inode(struct super_block *sbp, struct vxfs_inode_info *vip)\n{\n\tstruct inode\t\t\t*ip = NULL;\n\n\tif ((ip = new_inode(sbp))) {\n\t\tip->i_ino = get_next_ino();\n\t\tvxfs_iinit(ip, vip);\n\t\tip->i_mapping->a_ops = &vxfs_aops;\n\t}\n\treturn (ip);\n}"
  },
  {
    "function_name": "vxfs_iinit",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/freevxfs/vxfs_inode.c",
    "lines": "222-245",
    "snippet": "static void\nvxfs_iinit(struct inode *ip, struct vxfs_inode_info *vip)\n{\n\n\tip->i_mode = vxfs_transmod(vip);\n\ti_uid_write(ip, (uid_t)vip->vii_uid);\n\ti_gid_write(ip, (gid_t)vip->vii_gid);\n\n\tset_nlink(ip, vip->vii_nlink);\n\tip->i_size = vip->vii_size;\n\n\tip->i_atime.tv_sec = vip->vii_atime;\n\tip->i_ctime.tv_sec = vip->vii_ctime;\n\tip->i_mtime.tv_sec = vip->vii_mtime;\n\tip->i_atime.tv_nsec = 0;\n\tip->i_ctime.tv_nsec = 0;\n\tip->i_mtime.tv_nsec = 0;\n\n\tip->i_blocks = vip->vii_blocks;\n\tip->i_generation = vip->vii_gen;\n\n\tip->i_private = vip;\n\t\n}",
    "includes": [
      "#include \"vxfs_extern.h\"",
      "#include \"vxfs_inode.h\"",
      "#include \"vxfs.h\"",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "set_nlink",
          "args": [
            "ip",
            "vip->vii_nlink"
          ],
          "line": 230
        },
        "resolved": true,
        "details": {
          "function_name": "set_nlink",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "305-316",
          "snippet": "void set_nlink(struct inode *inode, unsigned int nlink)\n{\n\tif (!nlink) {\n\t\tclear_nlink(inode);\n\t} else {\n\t\t/* Yes, some filesystems do change nlink from zero to one */\n\t\tif (inode->i_nlink == 0)\n\t\t\tatomic_long_dec(&inode->i_sb->s_remove_count);\n\n\t\tinode->__i_nlink = nlink;\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid set_nlink(struct inode *inode, unsigned int nlink)\n{\n\tif (!nlink) {\n\t\tclear_nlink(inode);\n\t} else {\n\t\t/* Yes, some filesystems do change nlink from zero to one */\n\t\tif (inode->i_nlink == 0)\n\t\t\tatomic_long_dec(&inode->i_sb->s_remove_count);\n\n\t\tinode->__i_nlink = nlink;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "i_gid_write",
          "args": [
            "ip",
            "(gid_t)vip->vii_gid"
          ],
          "line": 228
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "i_uid_write",
          "args": [
            "ip",
            "(uid_t)vip->vii_uid"
          ],
          "line": 227
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vxfs_transmod",
          "args": [
            "vip"
          ],
          "line": 226
        },
        "resolved": true,
        "details": {
          "function_name": "vxfs_transmod",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/freevxfs/vxfs_inode.c",
          "lines": "190-211",
          "snippet": "static __inline__ umode_t\nvxfs_transmod(struct vxfs_inode_info *vip)\n{\n\tumode_t\t\t\tret = vip->vii_mode & ~VXFS_TYPE_MASK;\n\n\tif (VXFS_ISFIFO(vip))\n\t\tret |= S_IFIFO;\n\tif (VXFS_ISCHR(vip))\n\t\tret |= S_IFCHR;\n\tif (VXFS_ISDIR(vip))\n\t\tret |= S_IFDIR;\n\tif (VXFS_ISBLK(vip))\n\t\tret |= S_IFBLK;\n\tif (VXFS_ISLNK(vip))\n\t\tret |= S_IFLNK;\n\tif (VXFS_ISREG(vip))\n\t\tret |= S_IFREG;\n\tif (VXFS_ISSOC(vip))\n\t\tret |= S_IFSOCK;\n\n\treturn (ret);\n}",
          "includes": [
            "#include \"vxfs_extern.h\"",
            "#include \"vxfs_inode.h\"",
            "#include \"vxfs.h\"",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vxfs_extern.h\"\n#include \"vxfs_inode.h\"\n#include \"vxfs.h\"\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/pagemap.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n\nstatic __inline__ umode_t\nvxfs_transmod(struct vxfs_inode_info *vip)\n{\n\tumode_t\t\t\tret = vip->vii_mode & ~VXFS_TYPE_MASK;\n\n\tif (VXFS_ISFIFO(vip))\n\t\tret |= S_IFIFO;\n\tif (VXFS_ISCHR(vip))\n\t\tret |= S_IFCHR;\n\tif (VXFS_ISDIR(vip))\n\t\tret |= S_IFDIR;\n\tif (VXFS_ISBLK(vip))\n\t\tret |= S_IFBLK;\n\tif (VXFS_ISLNK(vip))\n\t\tret |= S_IFLNK;\n\tif (VXFS_ISREG(vip))\n\t\tret |= S_IFREG;\n\tif (VXFS_ISSOC(vip))\n\t\tret |= S_IFSOCK;\n\n\treturn (ret);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"vxfs_extern.h\"\n#include \"vxfs_inode.h\"\n#include \"vxfs.h\"\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/pagemap.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n\nstatic void\nvxfs_iinit(struct inode *ip, struct vxfs_inode_info *vip)\n{\n\n\tip->i_mode = vxfs_transmod(vip);\n\ti_uid_write(ip, (uid_t)vip->vii_uid);\n\ti_gid_write(ip, (gid_t)vip->vii_gid);\n\n\tset_nlink(ip, vip->vii_nlink);\n\tip->i_size = vip->vii_size;\n\n\tip->i_atime.tv_sec = vip->vii_atime;\n\tip->i_ctime.tv_sec = vip->vii_ctime;\n\tip->i_mtime.tv_sec = vip->vii_mtime;\n\tip->i_atime.tv_nsec = 0;\n\tip->i_ctime.tv_nsec = 0;\n\tip->i_mtime.tv_nsec = 0;\n\n\tip->i_blocks = vip->vii_blocks;\n\tip->i_generation = vip->vii_gen;\n\n\tip->i_private = vip;\n\t\n}"
  },
  {
    "function_name": "vxfs_transmod",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/freevxfs/vxfs_inode.c",
    "lines": "190-211",
    "snippet": "static __inline__ umode_t\nvxfs_transmod(struct vxfs_inode_info *vip)\n{\n\tumode_t\t\t\tret = vip->vii_mode & ~VXFS_TYPE_MASK;\n\n\tif (VXFS_ISFIFO(vip))\n\t\tret |= S_IFIFO;\n\tif (VXFS_ISCHR(vip))\n\t\tret |= S_IFCHR;\n\tif (VXFS_ISDIR(vip))\n\t\tret |= S_IFDIR;\n\tif (VXFS_ISBLK(vip))\n\t\tret |= S_IFBLK;\n\tif (VXFS_ISLNK(vip))\n\t\tret |= S_IFLNK;\n\tif (VXFS_ISREG(vip))\n\t\tret |= S_IFREG;\n\tif (VXFS_ISSOC(vip))\n\t\tret |= S_IFSOCK;\n\n\treturn (ret);\n}",
    "includes": [
      "#include \"vxfs_extern.h\"",
      "#include \"vxfs_inode.h\"",
      "#include \"vxfs.h\"",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VXFS_ISSOC",
          "args": [
            "vip"
          ],
          "line": 207
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VXFS_ISREG",
          "args": [
            "vip"
          ],
          "line": 205
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VXFS_ISLNK",
          "args": [
            "vip"
          ],
          "line": 203
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VXFS_ISBLK",
          "args": [
            "vip"
          ],
          "line": 201
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VXFS_ISDIR",
          "args": [
            "vip"
          ],
          "line": 199
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VXFS_ISCHR",
          "args": [
            "vip"
          ],
          "line": 197
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VXFS_ISFIFO",
          "args": [
            "vip"
          ],
          "line": 195
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"vxfs_extern.h\"\n#include \"vxfs_inode.h\"\n#include \"vxfs.h\"\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/pagemap.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n\nstatic __inline__ umode_t\nvxfs_transmod(struct vxfs_inode_info *vip)\n{\n\tumode_t\t\t\tret = vip->vii_mode & ~VXFS_TYPE_MASK;\n\n\tif (VXFS_ISFIFO(vip))\n\t\tret |= S_IFIFO;\n\tif (VXFS_ISCHR(vip))\n\t\tret |= S_IFCHR;\n\tif (VXFS_ISDIR(vip))\n\t\tret |= S_IFDIR;\n\tif (VXFS_ISBLK(vip))\n\t\tret |= S_IFBLK;\n\tif (VXFS_ISLNK(vip))\n\t\tret |= S_IFLNK;\n\tif (VXFS_ISREG(vip))\n\t\tret |= S_IFREG;\n\tif (VXFS_ISSOC(vip))\n\t\tret |= S_IFSOCK;\n\n\treturn (ret);\n}"
  },
  {
    "function_name": "vxfs_stiget",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/freevxfs/vxfs_inode.c",
    "lines": "173-180",
    "snippet": "struct vxfs_inode_info *\nvxfs_stiget(struct super_block *sbp, ino_t ino)\n{\n\tstruct vxfs_inode_info *vip;\n\n\tvip = __vxfs_iget(ino, VXFS_SBI(sbp)->vsi_stilist);\n\treturn IS_ERR(vip) ? NULL : vip;\n}",
    "includes": [
      "#include \"vxfs_extern.h\"",
      "#include \"vxfs_inode.h\"",
      "#include \"vxfs.h\"",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "vip"
          ],
          "line": 179
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__vxfs_iget",
          "args": [
            "ino",
            "VXFS_SBI(sbp)->vsi_stilist"
          ],
          "line": 178
        },
        "resolved": true,
        "details": {
          "function_name": "__vxfs_iget",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/freevxfs/vxfs_inode.c",
          "lines": "129-161",
          "snippet": "static struct vxfs_inode_info *\n__vxfs_iget(ino_t ino, struct inode *ilistp)\n{\n\tstruct page\t\t\t*pp;\n\tu_long\t\t\t\toffset;\n\n\toffset = (ino % (PAGE_SIZE / VXFS_ISIZE)) * VXFS_ISIZE;\n\tpp = vxfs_get_page(ilistp->i_mapping, ino * VXFS_ISIZE / PAGE_SIZE);\n\n\tif (!IS_ERR(pp)) {\n\t\tstruct vxfs_inode_info\t*vip;\n\t\tstruct vxfs_dinode\t*dip;\n\t\tcaddr_t\t\t\tkaddr = (char *)page_address(pp);\n\n\t\tif (!(vip = kmem_cache_alloc(vxfs_inode_cachep, GFP_KERNEL)))\n\t\t\tgoto fail;\n\t\tdip = (struct vxfs_dinode *)(kaddr + offset);\n\t\tmemcpy(vip, dip, sizeof(*vip));\n#ifdef DIAGNOSTIC\n\t\tvxfs_dumpi(vip, ino);\n#endif\n\t\tvxfs_put_page(pp);\n\t\treturn (vip);\n\t}\n\n\tprintk(KERN_WARNING \"vxfs: error on page %p\\n\", pp);\n\treturn ERR_CAST(pp);\n\nfail:\n\tprintk(KERN_WARNING \"vxfs: unable to read inode %ld\\n\", (unsigned long)ino);\n\tvxfs_put_page(pp);\n\treturn ERR_PTR(-ENOMEM);\n}",
          "includes": [
            "#include \"vxfs_extern.h\"",
            "#include \"vxfs_inode.h\"",
            "#include \"vxfs.h\"",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct kmem_cache\t\t*vxfs_inode_cachep;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"vxfs_extern.h\"\n#include \"vxfs_inode.h\"\n#include \"vxfs.h\"\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/pagemap.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n\nstruct kmem_cache\t\t*vxfs_inode_cachep;\n\nstatic struct vxfs_inode_info *\n__vxfs_iget(ino_t ino, struct inode *ilistp)\n{\n\tstruct page\t\t\t*pp;\n\tu_long\t\t\t\toffset;\n\n\toffset = (ino % (PAGE_SIZE / VXFS_ISIZE)) * VXFS_ISIZE;\n\tpp = vxfs_get_page(ilistp->i_mapping, ino * VXFS_ISIZE / PAGE_SIZE);\n\n\tif (!IS_ERR(pp)) {\n\t\tstruct vxfs_inode_info\t*vip;\n\t\tstruct vxfs_dinode\t*dip;\n\t\tcaddr_t\t\t\tkaddr = (char *)page_address(pp);\n\n\t\tif (!(vip = kmem_cache_alloc(vxfs_inode_cachep, GFP_KERNEL)))\n\t\t\tgoto fail;\n\t\tdip = (struct vxfs_dinode *)(kaddr + offset);\n\t\tmemcpy(vip, dip, sizeof(*vip));\n#ifdef DIAGNOSTIC\n\t\tvxfs_dumpi(vip, ino);\n#endif\n\t\tvxfs_put_page(pp);\n\t\treturn (vip);\n\t}\n\n\tprintk(KERN_WARNING \"vxfs: error on page %p\\n\", pp);\n\treturn ERR_CAST(pp);\n\nfail:\n\tprintk(KERN_WARNING \"vxfs: unable to read inode %ld\\n\", (unsigned long)ino);\n\tvxfs_put_page(pp);\n\treturn ERR_PTR(-ENOMEM);\n}"
        }
      },
      {
        "call_info": {
          "callee": "VXFS_SBI",
          "args": [
            "sbp"
          ],
          "line": 178
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"vxfs_extern.h\"\n#include \"vxfs_inode.h\"\n#include \"vxfs.h\"\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/pagemap.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n\nstruct vxfs_inode_info *\nvxfs_stiget(struct super_block *sbp, ino_t ino)\n{\n\tstruct vxfs_inode_info *vip;\n\n\tvip = __vxfs_iget(ino, VXFS_SBI(sbp)->vsi_stilist);\n\treturn IS_ERR(vip) ? NULL : vip;\n}"
  },
  {
    "function_name": "__vxfs_iget",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/freevxfs/vxfs_inode.c",
    "lines": "129-161",
    "snippet": "static struct vxfs_inode_info *\n__vxfs_iget(ino_t ino, struct inode *ilistp)\n{\n\tstruct page\t\t\t*pp;\n\tu_long\t\t\t\toffset;\n\n\toffset = (ino % (PAGE_SIZE / VXFS_ISIZE)) * VXFS_ISIZE;\n\tpp = vxfs_get_page(ilistp->i_mapping, ino * VXFS_ISIZE / PAGE_SIZE);\n\n\tif (!IS_ERR(pp)) {\n\t\tstruct vxfs_inode_info\t*vip;\n\t\tstruct vxfs_dinode\t*dip;\n\t\tcaddr_t\t\t\tkaddr = (char *)page_address(pp);\n\n\t\tif (!(vip = kmem_cache_alloc(vxfs_inode_cachep, GFP_KERNEL)))\n\t\t\tgoto fail;\n\t\tdip = (struct vxfs_dinode *)(kaddr + offset);\n\t\tmemcpy(vip, dip, sizeof(*vip));\n#ifdef DIAGNOSTIC\n\t\tvxfs_dumpi(vip, ino);\n#endif\n\t\tvxfs_put_page(pp);\n\t\treturn (vip);\n\t}\n\n\tprintk(KERN_WARNING \"vxfs: error on page %p\\n\", pp);\n\treturn ERR_CAST(pp);\n\nfail:\n\tprintk(KERN_WARNING \"vxfs: unable to read inode %ld\\n\", (unsigned long)ino);\n\tvxfs_put_page(pp);\n\treturn ERR_PTR(-ENOMEM);\n}",
    "includes": [
      "#include \"vxfs_extern.h\"",
      "#include \"vxfs_inode.h\"",
      "#include \"vxfs.h\"",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "struct kmem_cache\t\t*vxfs_inode_cachep;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ENOMEM"
          ],
          "line": 160
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vxfs_put_page",
          "args": [
            "pp"
          ],
          "line": 159
        },
        "resolved": true,
        "details": {
          "function_name": "vxfs_put_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/freevxfs/vxfs_subr.c",
          "lines": "49-54",
          "snippet": "inline void\nvxfs_put_page(struct page *pp)\n{\n\tkunmap(pp);\n\tpage_cache_release(pp);\n}",
          "includes": [
            "#include \"vxfs_extern.h\"",
            "#include <linux/pagemap.h>",
            "#include <linux/kernel.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int\t\tvxfs_readpage(struct file *, struct page *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"vxfs_extern.h\"\n#include <linux/pagemap.h>\n#include <linux/kernel.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n\nstatic int\t\tvxfs_readpage(struct file *, struct page *);\n\ninline void\nvxfs_put_page(struct page *pp)\n{\n\tkunmap(pp);\n\tpage_cache_release(pp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_WARNING \"vxfs: unable to read inode %ld\\n\"",
            "(unsigned long)ino"
          ],
          "line": 158
        },
        "resolved": true,
        "details": {
          "function_name": "compat_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/compat.c",
          "lines": "59-69",
          "snippet": "int compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/ioctls.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/aio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/mm.h>",
            "#include <linux/poll.h>",
            "#include <linux/signal.h>",
            "#include <linux/highmem.h>",
            "#include <linux/security.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/personality.h>",
            "#include <linux/highuid.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/dirent.h>",
            "#include <linux/ctype.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/nfs4_mount.h>",
            "#include <linux/ncp_mount.h>",
            "#include <linux/init.h>",
            "#include <linux/ioctl.h>",
            "#include <linux/vfs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/namei.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/errno.h>",
            "#include <linux/compat.h>",
            "#include <linux/linkage.h>",
            "#include <linux/kernel.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int compat_log = 1;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/ioctls.h>\n#include <asm/mmu_context.h>\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/fs_struct.h>\n#include <linux/mm.h>\n#include <linux/poll.h>\n#include <linux/signal.h>\n#include <linux/highmem.h>\n#include <linux/security.h>\n#include <linux/tsacct_kern.h>\n#include <linux/rwsem.h>\n#include <linux/personality.h>\n#include <linux/highuid.h>\n#include <linux/fsnotify.h>\n#include <linux/dirent.h>\n#include <linux/ctype.h>\n#include <linux/syscalls.h>\n#include <linux/nfs4_mount.h>\n#include <linux/ncp_mount.h>\n#include <linux/init.h>\n#include <linux/ioctl.h>\n#include <linux/vfs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/namei.h>\n#include <linux/fcntl.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <linux/compat.h>\n#include <linux/linkage.h>\n#include <linux/kernel.h>\n#include <linux/stddef.h>\n\nint compat_log = 1;\n\nint compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERR_CAST",
          "args": [
            "pp"
          ],
          "line": 155
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vxfs_dumpi",
          "args": [
            "vip",
            "ino"
          ],
          "line": 148
        },
        "resolved": true,
        "details": {
          "function_name": "vxfs_dumpi",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/freevxfs/vxfs_inode.c",
          "lines": "51-67",
          "snippet": "void\nvxfs_dumpi(struct vxfs_inode_info *vip, ino_t ino)\n{\n\tprintk(KERN_DEBUG \"\\n\\n\");\n\tif (ino)\n\t\tprintk(KERN_DEBUG \"dumping vxfs inode %ld\\n\", ino);\n\telse\n\t\tprintk(KERN_DEBUG \"dumping unknown vxfs inode\\n\");\n\n\tprintk(KERN_DEBUG \"---------------------------\\n\");\n\tprintk(KERN_DEBUG \"mode is %x\\n\", vip->vii_mode);\n\tprintk(KERN_DEBUG \"nlink:%u, uid:%u, gid:%u\\n\",\n\t\t\tvip->vii_nlink, vip->vii_uid, vip->vii_gid);\n\tprintk(KERN_DEBUG \"size:%Lx, blocks:%u\\n\",\n\t\t\tvip->vii_size, vip->vii_blocks);\n\tprintk(KERN_DEBUG \"orgtype:%u\\n\", vip->vii_orgtype);\n}",
          "includes": [
            "#include \"vxfs_extern.h\"",
            "#include \"vxfs_inode.h\"",
            "#include \"vxfs.h\"",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vxfs_extern.h\"\n#include \"vxfs_inode.h\"\n#include \"vxfs.h\"\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/pagemap.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n\nvoid\nvxfs_dumpi(struct vxfs_inode_info *vip, ino_t ino)\n{\n\tprintk(KERN_DEBUG \"\\n\\n\");\n\tif (ino)\n\t\tprintk(KERN_DEBUG \"dumping vxfs inode %ld\\n\", ino);\n\telse\n\t\tprintk(KERN_DEBUG \"dumping unknown vxfs inode\\n\");\n\n\tprintk(KERN_DEBUG \"---------------------------\\n\");\n\tprintk(KERN_DEBUG \"mode is %x\\n\", vip->vii_mode);\n\tprintk(KERN_DEBUG \"nlink:%u, uid:%u, gid:%u\\n\",\n\t\t\tvip->vii_nlink, vip->vii_uid, vip->vii_gid);\n\tprintk(KERN_DEBUG \"size:%Lx, blocks:%u\\n\",\n\t\t\tvip->vii_size, vip->vii_blocks);\n\tprintk(KERN_DEBUG \"orgtype:%u\\n\", vip->vii_orgtype);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "vip",
            "dip",
            "sizeof(*vip)"
          ],
          "line": 146
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmem_cache_alloc",
          "args": [
            "vxfs_inode_cachep",
            "GFP_KERNEL"
          ],
          "line": 143
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_kmem_cache_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "1064-1076",
          "snippet": "static inline void *f2fs_kmem_cache_alloc(struct kmem_cache *cachep,\n\t\t\t\t\t\tgfp_t flags)\n{\n\tvoid *entry;\nretry:\n\tentry = kmem_cache_alloc(cachep, flags);\n\tif (!entry) {\n\t\tcond_resched();\n\t\tgoto retry;\n\t}\n\n\treturn entry;\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline void *f2fs_kmem_cache_alloc(struct kmem_cache *cachep,\n\t\t\t\t\t\tgfp_t flags)\n{\n\tvoid *entry;\nretry:\n\tentry = kmem_cache_alloc(cachep, flags);\n\tif (!entry) {\n\t\tcond_resched();\n\t\tgoto retry;\n\t}\n\n\treturn entry;\n}"
        }
      },
      {
        "call_info": {
          "callee": "page_address",
          "args": [
            "pp"
          ],
          "line": 141
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "pp"
          ],
          "line": 138
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vxfs_get_page",
          "args": [
            "ilistp->i_mapping",
            "ino * VXFS_ISIZE / PAGE_SIZE"
          ],
          "line": 136
        },
        "resolved": true,
        "details": {
          "function_name": "vxfs_get_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/freevxfs/vxfs_subr.c",
          "lines": "67-87",
          "snippet": "struct page *\nvxfs_get_page(struct address_space *mapping, u_long n)\n{\n\tstruct page *\t\t\tpp;\n\n\tpp = read_mapping_page(mapping, n, NULL);\n\n\tif (!IS_ERR(pp)) {\n\t\tkmap(pp);\n\t\t/** if (!PageChecked(pp)) **/\n\t\t\t/** vxfs_check_page(pp); **/\n\t\tif (PageError(pp))\n\t\t\tgoto fail;\n\t}\n\t\n\treturn (pp);\n\t\t \nfail:\n\tvxfs_put_page(pp);\n\treturn ERR_PTR(-EIO);\n}",
          "includes": [
            "#include \"vxfs_extern.h\"",
            "#include <linux/pagemap.h>",
            "#include <linux/kernel.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int\t\tvxfs_readpage(struct file *, struct page *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"vxfs_extern.h\"\n#include <linux/pagemap.h>\n#include <linux/kernel.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n\nstatic int\t\tvxfs_readpage(struct file *, struct page *);\n\nstruct page *\nvxfs_get_page(struct address_space *mapping, u_long n)\n{\n\tstruct page *\t\t\tpp;\n\n\tpp = read_mapping_page(mapping, n, NULL);\n\n\tif (!IS_ERR(pp)) {\n\t\tkmap(pp);\n\t\t/** if (!PageChecked(pp)) **/\n\t\t\t/** vxfs_check_page(pp); **/\n\t\tif (PageError(pp))\n\t\t\tgoto fail;\n\t}\n\t\n\treturn (pp);\n\t\t \nfail:\n\tvxfs_put_page(pp);\n\treturn ERR_PTR(-EIO);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"vxfs_extern.h\"\n#include \"vxfs_inode.h\"\n#include \"vxfs.h\"\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/pagemap.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n\nstruct kmem_cache\t\t*vxfs_inode_cachep;\n\nstatic struct vxfs_inode_info *\n__vxfs_iget(ino_t ino, struct inode *ilistp)\n{\n\tstruct page\t\t\t*pp;\n\tu_long\t\t\t\toffset;\n\n\toffset = (ino % (PAGE_SIZE / VXFS_ISIZE)) * VXFS_ISIZE;\n\tpp = vxfs_get_page(ilistp->i_mapping, ino * VXFS_ISIZE / PAGE_SIZE);\n\n\tif (!IS_ERR(pp)) {\n\t\tstruct vxfs_inode_info\t*vip;\n\t\tstruct vxfs_dinode\t*dip;\n\t\tcaddr_t\t\t\tkaddr = (char *)page_address(pp);\n\n\t\tif (!(vip = kmem_cache_alloc(vxfs_inode_cachep, GFP_KERNEL)))\n\t\t\tgoto fail;\n\t\tdip = (struct vxfs_dinode *)(kaddr + offset);\n\t\tmemcpy(vip, dip, sizeof(*vip));\n#ifdef DIAGNOSTIC\n\t\tvxfs_dumpi(vip, ino);\n#endif\n\t\tvxfs_put_page(pp);\n\t\treturn (vip);\n\t}\n\n\tprintk(KERN_WARNING \"vxfs: error on page %p\\n\", pp);\n\treturn ERR_CAST(pp);\n\nfail:\n\tprintk(KERN_WARNING \"vxfs: unable to read inode %ld\\n\", (unsigned long)ino);\n\tvxfs_put_page(pp);\n\treturn ERR_PTR(-ENOMEM);\n}"
  },
  {
    "function_name": "vxfs_blkiget",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/freevxfs/vxfs_inode.c",
    "lines": "87-116",
    "snippet": "struct vxfs_inode_info *\nvxfs_blkiget(struct super_block *sbp, u_long extent, ino_t ino)\n{\n\tstruct buffer_head\t\t*bp;\n\tu_long\t\t\t\tblock, offset;\n\n\tblock = extent + ((ino * VXFS_ISIZE) / sbp->s_blocksize);\n\toffset = ((ino % (sbp->s_blocksize / VXFS_ISIZE)) * VXFS_ISIZE);\n\tbp = sb_bread(sbp, block);\n\n\tif (bp && buffer_mapped(bp)) {\n\t\tstruct vxfs_inode_info\t*vip;\n\t\tstruct vxfs_dinode\t*dip;\n\n\t\tif (!(vip = kmem_cache_alloc(vxfs_inode_cachep, GFP_KERNEL)))\n\t\t\tgoto fail;\n\t\tdip = (struct vxfs_dinode *)(bp->b_data + offset);\n\t\tmemcpy(vip, dip, sizeof(*vip));\n#ifdef DIAGNOSTIC\n\t\tvxfs_dumpi(vip, ino);\n#endif\n\t\tbrelse(bp);\n\t\treturn (vip);\n\t}\n\nfail:\n\tprintk(KERN_WARNING \"vxfs: unable to read block %ld\\n\", block);\n\tbrelse(bp);\n\treturn NULL;\n}",
    "includes": [
      "#include \"vxfs_extern.h\"",
      "#include \"vxfs_inode.h\"",
      "#include \"vxfs.h\"",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "struct kmem_cache\t\t*vxfs_inode_cachep;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "bp"
          ],
          "line": 114
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_WARNING \"vxfs: unable to read block %ld\\n\"",
            "block"
          ],
          "line": 113
        },
        "resolved": true,
        "details": {
          "function_name": "compat_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/compat.c",
          "lines": "59-69",
          "snippet": "int compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/ioctls.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/aio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/mm.h>",
            "#include <linux/poll.h>",
            "#include <linux/signal.h>",
            "#include <linux/highmem.h>",
            "#include <linux/security.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/personality.h>",
            "#include <linux/highuid.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/dirent.h>",
            "#include <linux/ctype.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/nfs4_mount.h>",
            "#include <linux/ncp_mount.h>",
            "#include <linux/init.h>",
            "#include <linux/ioctl.h>",
            "#include <linux/vfs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/namei.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/errno.h>",
            "#include <linux/compat.h>",
            "#include <linux/linkage.h>",
            "#include <linux/kernel.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int compat_log = 1;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/ioctls.h>\n#include <asm/mmu_context.h>\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/fs_struct.h>\n#include <linux/mm.h>\n#include <linux/poll.h>\n#include <linux/signal.h>\n#include <linux/highmem.h>\n#include <linux/security.h>\n#include <linux/tsacct_kern.h>\n#include <linux/rwsem.h>\n#include <linux/personality.h>\n#include <linux/highuid.h>\n#include <linux/fsnotify.h>\n#include <linux/dirent.h>\n#include <linux/ctype.h>\n#include <linux/syscalls.h>\n#include <linux/nfs4_mount.h>\n#include <linux/ncp_mount.h>\n#include <linux/init.h>\n#include <linux/ioctl.h>\n#include <linux/vfs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/namei.h>\n#include <linux/fcntl.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <linux/compat.h>\n#include <linux/linkage.h>\n#include <linux/kernel.h>\n#include <linux/stddef.h>\n\nint compat_log = 1;\n\nint compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "vxfs_dumpi",
          "args": [
            "vip",
            "ino"
          ],
          "line": 106
        },
        "resolved": true,
        "details": {
          "function_name": "vxfs_dumpi",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/freevxfs/vxfs_inode.c",
          "lines": "51-67",
          "snippet": "void\nvxfs_dumpi(struct vxfs_inode_info *vip, ino_t ino)\n{\n\tprintk(KERN_DEBUG \"\\n\\n\");\n\tif (ino)\n\t\tprintk(KERN_DEBUG \"dumping vxfs inode %ld\\n\", ino);\n\telse\n\t\tprintk(KERN_DEBUG \"dumping unknown vxfs inode\\n\");\n\n\tprintk(KERN_DEBUG \"---------------------------\\n\");\n\tprintk(KERN_DEBUG \"mode is %x\\n\", vip->vii_mode);\n\tprintk(KERN_DEBUG \"nlink:%u, uid:%u, gid:%u\\n\",\n\t\t\tvip->vii_nlink, vip->vii_uid, vip->vii_gid);\n\tprintk(KERN_DEBUG \"size:%Lx, blocks:%u\\n\",\n\t\t\tvip->vii_size, vip->vii_blocks);\n\tprintk(KERN_DEBUG \"orgtype:%u\\n\", vip->vii_orgtype);\n}",
          "includes": [
            "#include \"vxfs_extern.h\"",
            "#include \"vxfs_inode.h\"",
            "#include \"vxfs.h\"",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vxfs_extern.h\"\n#include \"vxfs_inode.h\"\n#include \"vxfs.h\"\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/pagemap.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n\nvoid\nvxfs_dumpi(struct vxfs_inode_info *vip, ino_t ino)\n{\n\tprintk(KERN_DEBUG \"\\n\\n\");\n\tif (ino)\n\t\tprintk(KERN_DEBUG \"dumping vxfs inode %ld\\n\", ino);\n\telse\n\t\tprintk(KERN_DEBUG \"dumping unknown vxfs inode\\n\");\n\n\tprintk(KERN_DEBUG \"---------------------------\\n\");\n\tprintk(KERN_DEBUG \"mode is %x\\n\", vip->vii_mode);\n\tprintk(KERN_DEBUG \"nlink:%u, uid:%u, gid:%u\\n\",\n\t\t\tvip->vii_nlink, vip->vii_uid, vip->vii_gid);\n\tprintk(KERN_DEBUG \"size:%Lx, blocks:%u\\n\",\n\t\t\tvip->vii_size, vip->vii_blocks);\n\tprintk(KERN_DEBUG \"orgtype:%u\\n\", vip->vii_orgtype);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "vip",
            "dip",
            "sizeof(*vip)"
          ],
          "line": 104
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmem_cache_alloc",
          "args": [
            "vxfs_inode_cachep",
            "GFP_KERNEL"
          ],
          "line": 101
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_kmem_cache_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "1064-1076",
          "snippet": "static inline void *f2fs_kmem_cache_alloc(struct kmem_cache *cachep,\n\t\t\t\t\t\tgfp_t flags)\n{\n\tvoid *entry;\nretry:\n\tentry = kmem_cache_alloc(cachep, flags);\n\tif (!entry) {\n\t\tcond_resched();\n\t\tgoto retry;\n\t}\n\n\treturn entry;\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline void *f2fs_kmem_cache_alloc(struct kmem_cache *cachep,\n\t\t\t\t\t\tgfp_t flags)\n{\n\tvoid *entry;\nretry:\n\tentry = kmem_cache_alloc(cachep, flags);\n\tif (!entry) {\n\t\tcond_resched();\n\t\tgoto retry;\n\t}\n\n\treturn entry;\n}"
        }
      },
      {
        "call_info": {
          "callee": "buffer_mapped",
          "args": [
            "bp"
          ],
          "line": 97
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sb_bread",
          "args": [
            "sbp",
            "block"
          ],
          "line": 95
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"vxfs_extern.h\"\n#include \"vxfs_inode.h\"\n#include \"vxfs.h\"\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/pagemap.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n\nstruct kmem_cache\t\t*vxfs_inode_cachep;\n\nstruct vxfs_inode_info *\nvxfs_blkiget(struct super_block *sbp, u_long extent, ino_t ino)\n{\n\tstruct buffer_head\t\t*bp;\n\tu_long\t\t\t\tblock, offset;\n\n\tblock = extent + ((ino * VXFS_ISIZE) / sbp->s_blocksize);\n\toffset = ((ino % (sbp->s_blocksize / VXFS_ISIZE)) * VXFS_ISIZE);\n\tbp = sb_bread(sbp, block);\n\n\tif (bp && buffer_mapped(bp)) {\n\t\tstruct vxfs_inode_info\t*vip;\n\t\tstruct vxfs_dinode\t*dip;\n\n\t\tif (!(vip = kmem_cache_alloc(vxfs_inode_cachep, GFP_KERNEL)))\n\t\t\tgoto fail;\n\t\tdip = (struct vxfs_dinode *)(bp->b_data + offset);\n\t\tmemcpy(vip, dip, sizeof(*vip));\n#ifdef DIAGNOSTIC\n\t\tvxfs_dumpi(vip, ino);\n#endif\n\t\tbrelse(bp);\n\t\treturn (vip);\n\t}\n\nfail:\n\tprintk(KERN_WARNING \"vxfs: unable to read block %ld\\n\", block);\n\tbrelse(bp);\n\treturn NULL;\n}"
  },
  {
    "function_name": "vxfs_dumpi",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/freevxfs/vxfs_inode.c",
    "lines": "51-67",
    "snippet": "void\nvxfs_dumpi(struct vxfs_inode_info *vip, ino_t ino)\n{\n\tprintk(KERN_DEBUG \"\\n\\n\");\n\tif (ino)\n\t\tprintk(KERN_DEBUG \"dumping vxfs inode %ld\\n\", ino);\n\telse\n\t\tprintk(KERN_DEBUG \"dumping unknown vxfs inode\\n\");\n\n\tprintk(KERN_DEBUG \"---------------------------\\n\");\n\tprintk(KERN_DEBUG \"mode is %x\\n\", vip->vii_mode);\n\tprintk(KERN_DEBUG \"nlink:%u, uid:%u, gid:%u\\n\",\n\t\t\tvip->vii_nlink, vip->vii_uid, vip->vii_gid);\n\tprintk(KERN_DEBUG \"size:%Lx, blocks:%u\\n\",\n\t\t\tvip->vii_size, vip->vii_blocks);\n\tprintk(KERN_DEBUG \"orgtype:%u\\n\", vip->vii_orgtype);\n}",
    "includes": [
      "#include \"vxfs_extern.h\"",
      "#include \"vxfs_inode.h\"",
      "#include \"vxfs.h\"",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_DEBUG \"orgtype:%u\\n\"",
            "vip->vii_orgtype"
          ],
          "line": 66
        },
        "resolved": true,
        "details": {
          "function_name": "compat_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/compat.c",
          "lines": "59-69",
          "snippet": "int compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/ioctls.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/aio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/mm.h>",
            "#include <linux/poll.h>",
            "#include <linux/signal.h>",
            "#include <linux/highmem.h>",
            "#include <linux/security.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/personality.h>",
            "#include <linux/highuid.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/dirent.h>",
            "#include <linux/ctype.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/nfs4_mount.h>",
            "#include <linux/ncp_mount.h>",
            "#include <linux/init.h>",
            "#include <linux/ioctl.h>",
            "#include <linux/vfs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/namei.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/errno.h>",
            "#include <linux/compat.h>",
            "#include <linux/linkage.h>",
            "#include <linux/kernel.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int compat_log = 1;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/ioctls.h>\n#include <asm/mmu_context.h>\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/fs_struct.h>\n#include <linux/mm.h>\n#include <linux/poll.h>\n#include <linux/signal.h>\n#include <linux/highmem.h>\n#include <linux/security.h>\n#include <linux/tsacct_kern.h>\n#include <linux/rwsem.h>\n#include <linux/personality.h>\n#include <linux/highuid.h>\n#include <linux/fsnotify.h>\n#include <linux/dirent.h>\n#include <linux/ctype.h>\n#include <linux/syscalls.h>\n#include <linux/nfs4_mount.h>\n#include <linux/ncp_mount.h>\n#include <linux/init.h>\n#include <linux/ioctl.h>\n#include <linux/vfs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/namei.h>\n#include <linux/fcntl.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <linux/compat.h>\n#include <linux/linkage.h>\n#include <linux/kernel.h>\n#include <linux/stddef.h>\n\nint compat_log = 1;\n\nint compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"vxfs_extern.h\"\n#include \"vxfs_inode.h\"\n#include \"vxfs.h\"\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/pagemap.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n\nvoid\nvxfs_dumpi(struct vxfs_inode_info *vip, ino_t ino)\n{\n\tprintk(KERN_DEBUG \"\\n\\n\");\n\tif (ino)\n\t\tprintk(KERN_DEBUG \"dumping vxfs inode %ld\\n\", ino);\n\telse\n\t\tprintk(KERN_DEBUG \"dumping unknown vxfs inode\\n\");\n\n\tprintk(KERN_DEBUG \"---------------------------\\n\");\n\tprintk(KERN_DEBUG \"mode is %x\\n\", vip->vii_mode);\n\tprintk(KERN_DEBUG \"nlink:%u, uid:%u, gid:%u\\n\",\n\t\t\tvip->vii_nlink, vip->vii_uid, vip->vii_gid);\n\tprintk(KERN_DEBUG \"size:%Lx, blocks:%u\\n\",\n\t\t\tvip->vii_size, vip->vii_blocks);\n\tprintk(KERN_DEBUG \"orgtype:%u\\n\", vip->vii_orgtype);\n}"
  }
]