[
  {
    "function_name": "squashfs_readdir",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/squashfs/dir.c",
    "lines": "110-229",
    "snippet": "static int squashfs_readdir(struct file *file, struct dir_context *ctx)\n{\n\tstruct inode *inode = file_inode(file);\n\tstruct squashfs_sb_info *msblk = inode->i_sb->s_fs_info;\n\tu64 block = squashfs_i(inode)->start + msblk->directory_table;\n\tint offset = squashfs_i(inode)->offset, length, err;\n\tunsigned int inode_number, dir_count, size, type;\n\tstruct squashfs_dir_header dirh;\n\tstruct squashfs_dir_entry *dire;\n\n\tTRACE(\"Entered squashfs_readdir [%llx:%x]\\n\", block, offset);\n\n\tdire = kmalloc(sizeof(*dire) + SQUASHFS_NAME_LEN + 1, GFP_KERNEL);\n\tif (dire == NULL) {\n\t\tERROR(\"Failed to allocate squashfs_dir_entry\\n\");\n\t\tgoto finish;\n\t}\n\n\t/*\n\t * Return \".\" and  \"..\" entries as the first two filenames in the\n\t * directory.  To maximise compression these two entries are not\n\t * stored in the directory, and so we invent them here.\n\t *\n\t * It also means that the external f_pos is offset by 3 from the\n\t * on-disk directory f_pos.\n\t */\n\twhile (ctx->pos < 3) {\n\t\tchar *name;\n\t\tint i_ino;\n\n\t\tif (ctx->pos == 0) {\n\t\t\tname = \".\";\n\t\t\tsize = 1;\n\t\t\ti_ino = inode->i_ino;\n\t\t} else {\n\t\t\tname = \"..\";\n\t\t\tsize = 2;\n\t\t\ti_ino = squashfs_i(inode)->parent;\n\t\t}\n\n\t\tif (!dir_emit(ctx, name, size, i_ino,\n\t\t\t\tsquashfs_filetype_table[1]))\n\t\t\tgoto finish;\n\n\t\tctx->pos += size;\n\t}\n\n\tlength = get_dir_index_using_offset(inode->i_sb, &block, &offset,\n\t\t\t\tsquashfs_i(inode)->dir_idx_start,\n\t\t\t\tsquashfs_i(inode)->dir_idx_offset,\n\t\t\t\tsquashfs_i(inode)->dir_idx_cnt,\n\t\t\t\tctx->pos);\n\n\twhile (length < i_size_read(inode)) {\n\t\t/*\n\t\t * Read directory header\n\t\t */\n\t\terr = squashfs_read_metadata(inode->i_sb, &dirh, &block,\n\t\t\t\t\t&offset, sizeof(dirh));\n\t\tif (err < 0)\n\t\t\tgoto failed_read;\n\n\t\tlength += sizeof(dirh);\n\n\t\tdir_count = le32_to_cpu(dirh.count) + 1;\n\n\t\tif (dir_count > SQUASHFS_DIR_COUNT)\n\t\t\tgoto failed_read;\n\n\t\twhile (dir_count--) {\n\t\t\t/*\n\t\t\t * Read directory entry.\n\t\t\t */\n\t\t\terr = squashfs_read_metadata(inode->i_sb, dire, &block,\n\t\t\t\t\t&offset, sizeof(*dire));\n\t\t\tif (err < 0)\n\t\t\t\tgoto failed_read;\n\n\t\t\tsize = le16_to_cpu(dire->size) + 1;\n\n\t\t\t/* size should never be larger than SQUASHFS_NAME_LEN */\n\t\t\tif (size > SQUASHFS_NAME_LEN)\n\t\t\t\tgoto failed_read;\n\n\t\t\terr = squashfs_read_metadata(inode->i_sb, dire->name,\n\t\t\t\t\t&block, &offset, size);\n\t\t\tif (err < 0)\n\t\t\t\tgoto failed_read;\n\n\t\t\tlength += sizeof(*dire) + size;\n\n\t\t\tif (ctx->pos >= length)\n\t\t\t\tcontinue;\n\n\t\t\tdire->name[size] = '\\0';\n\t\t\tinode_number = le32_to_cpu(dirh.inode_number) +\n\t\t\t\t((short) le16_to_cpu(dire->inode_number));\n\t\t\ttype = le16_to_cpu(dire->type);\n\n\t\t\tif (type > SQUASHFS_MAX_DIR_TYPE)\n\t\t\t\tgoto failed_read;\n\n\t\t\tif (!dir_emit(ctx, dire->name, size,\n\t\t\t\t\tinode_number,\n\t\t\t\t\tsquashfs_filetype_table[type]))\n\t\t\t\tgoto finish;\n\n\t\t\tctx->pos = length;\n\t\t}\n\t}\n\nfinish:\n\tkfree(dire);\n\treturn 0;\n\nfailed_read:\n\tERROR(\"Unable to read directory block [%llx:%x]\\n\", block, offset);\n\tkfree(dire);\n\treturn 0;\n}",
    "includes": [
      "#include \"squashfs.h\"",
      "#include \"squashfs_fs_i.h\"",
      "#include \"squashfs_fs_sb.h\"",
      "#include \"squashfs_fs.h\"",
      "#include <linux/slab.h>",
      "#include <linux/vfs.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static const unsigned char squashfs_filetype_table[] = {\n\tDT_UNKNOWN, DT_DIR, DT_REG, DT_LNK, DT_BLK, DT_CHR, DT_FIFO, DT_SOCK\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "dire"
          ],
          "line": 227
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"Unable to read directory block [%llx:%x]\\n\"",
            "block",
            "offset"
          ],
          "line": 226
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "dire"
          ],
          "line": 222
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dir_emit",
          "args": [
            "ctx",
            "dire->name",
            "size",
            "inode_number",
            "squashfs_filetype_table[type]"
          ],
          "line": 212
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le16_to_cpu",
          "args": [
            "dire->type"
          ],
          "line": 207
        },
        "resolved": true,
        "details": {
          "function_name": "sle16_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "48-51",
          "snippet": "static inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "dirh.inode_number"
          ],
          "line": 205
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "squashfs_read_metadata",
          "args": [
            "inode->i_sb",
            "dire->name",
            "&block",
            "&offset",
            "size"
          ],
          "line": 194
        },
        "resolved": true,
        "details": {
          "function_name": "squashfs_read_metadata",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/squashfs/cache.c",
          "lines": "344-382",
          "snippet": "int squashfs_read_metadata(struct super_block *sb, void *buffer,\n\t\tu64 *block, int *offset, int length)\n{\n\tstruct squashfs_sb_info *msblk = sb->s_fs_info;\n\tint bytes, res = length;\n\tstruct squashfs_cache_entry *entry;\n\n\tTRACE(\"Entered squashfs_read_metadata [%llx:%x]\\n\", *block, *offset);\n\n\twhile (length) {\n\t\tentry = squashfs_cache_get(sb, msblk->block_cache, *block, 0);\n\t\tif (entry->error) {\n\t\t\tres = entry->error;\n\t\t\tgoto error;\n\t\t} else if (*offset >= entry->length) {\n\t\t\tres = -EIO;\n\t\t\tgoto error;\n\t\t}\n\n\t\tbytes = squashfs_copy_data(buffer, entry, *offset, length);\n\t\tif (buffer)\n\t\t\tbuffer += bytes;\n\t\tlength -= bytes;\n\t\t*offset += bytes;\n\n\t\tif (*offset == entry->length) {\n\t\t\t*block = entry->next_index;\n\t\t\t*offset = 0;\n\t\t}\n\n\t\tsquashfs_cache_put(entry);\n\t}\n\n\treturn res;\n\nerror:\n\tsquashfs_cache_put(entry);\n\treturn res;\n}",
          "includes": [
            "#include \"page_actor.h\"",
            "#include \"squashfs.h\"",
            "#include \"squashfs_fs_sb.h\"",
            "#include \"squashfs_fs.h\"",
            "#include <linux/pagemap.h>",
            "#include <linux/wait.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/sched.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/vfs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"page_actor.h\"\n#include \"squashfs.h\"\n#include \"squashfs_fs_sb.h\"\n#include \"squashfs_fs.h\"\n#include <linux/pagemap.h>\n#include <linux/wait.h>\n#include <linux/spinlock.h>\n#include <linux/sched.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/vfs.h>\n#include <linux/fs.h>\n\nint squashfs_read_metadata(struct super_block *sb, void *buffer,\n\t\tu64 *block, int *offset, int length)\n{\n\tstruct squashfs_sb_info *msblk = sb->s_fs_info;\n\tint bytes, res = length;\n\tstruct squashfs_cache_entry *entry;\n\n\tTRACE(\"Entered squashfs_read_metadata [%llx:%x]\\n\", *block, *offset);\n\n\twhile (length) {\n\t\tentry = squashfs_cache_get(sb, msblk->block_cache, *block, 0);\n\t\tif (entry->error) {\n\t\t\tres = entry->error;\n\t\t\tgoto error;\n\t\t} else if (*offset >= entry->length) {\n\t\t\tres = -EIO;\n\t\t\tgoto error;\n\t\t}\n\n\t\tbytes = squashfs_copy_data(buffer, entry, *offset, length);\n\t\tif (buffer)\n\t\t\tbuffer += bytes;\n\t\tlength -= bytes;\n\t\t*offset += bytes;\n\n\t\tif (*offset == entry->length) {\n\t\t\t*block = entry->next_index;\n\t\t\t*offset = 0;\n\t\t}\n\n\t\tsquashfs_cache_put(entry);\n\t}\n\n\treturn res;\n\nerror:\n\tsquashfs_cache_put(entry);\n\treturn res;\n}"
        }
      },
      {
        "call_info": {
          "callee": "i_size_read",
          "args": [
            "inode"
          ],
          "line": 163
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_dir_index_using_offset",
          "args": [
            "inode->i_sb",
            "&block",
            "&offset",
            "squashfs_i(inode)->dir_idx_start",
            "squashfs_i(inode)->dir_idx_offset",
            "squashfs_i(inode)->dir_idx_cnt",
            "ctx->pos"
          ],
          "line": 157
        },
        "resolved": true,
        "details": {
          "function_name": "get_dir_index_using_offset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/squashfs/dir.c",
          "lines": "51-107",
          "snippet": "static int get_dir_index_using_offset(struct super_block *sb,\n\tu64 *next_block, int *next_offset, u64 index_start, int index_offset,\n\tint i_count, u64 f_pos)\n{\n\tstruct squashfs_sb_info *msblk = sb->s_fs_info;\n\tint err, i, index, length = 0;\n\tunsigned int size;\n\tstruct squashfs_dir_index dir_index;\n\n\tTRACE(\"Entered get_dir_index_using_offset, i_count %d, f_pos %lld\\n\",\n\t\t\t\t\ti_count, f_pos);\n\n\t/*\n\t * Translate from external f_pos to the internal f_pos.  This\n\t * is offset by 3 because we invent \".\" and \"..\" entries which are\n\t * not actually stored in the directory.\n\t */\n\tif (f_pos <= 3)\n\t\treturn f_pos;\n\tf_pos -= 3;\n\n\tfor (i = 0; i < i_count; i++) {\n\t\terr = squashfs_read_metadata(sb, &dir_index, &index_start,\n\t\t\t\t&index_offset, sizeof(dir_index));\n\t\tif (err < 0)\n\t\t\tbreak;\n\n\t\tindex = le32_to_cpu(dir_index.index);\n\t\tif (index > f_pos)\n\t\t\t/*\n\t\t\t * Found the index we're looking for.\n\t\t\t */\n\t\t\tbreak;\n\n\t\tsize = le32_to_cpu(dir_index.size) + 1;\n\n\t\t/* size should never be larger than SQUASHFS_NAME_LEN */\n\t\tif (size > SQUASHFS_NAME_LEN)\n\t\t\tbreak;\n\n\t\terr = squashfs_read_metadata(sb, NULL, &index_start,\n\t\t\t\t&index_offset, size);\n\t\tif (err < 0)\n\t\t\tbreak;\n\n\t\tlength = index;\n\t\t*next_block = le32_to_cpu(dir_index.start_block) +\n\t\t\t\t\tmsblk->directory_table;\n\t}\n\n\t*next_offset = (length + *next_offset) % SQUASHFS_METADATA_SIZE;\n\n\t/*\n\t * Translate back from internal f_pos to external f_pos.\n\t */\n\treturn length + 3;\n}",
          "includes": [
            "#include \"squashfs.h\"",
            "#include \"squashfs_fs_i.h\"",
            "#include \"squashfs_fs_sb.h\"",
            "#include \"squashfs_fs.h\"",
            "#include <linux/slab.h>",
            "#include <linux/vfs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"squashfs.h\"\n#include \"squashfs_fs_i.h\"\n#include \"squashfs_fs_sb.h\"\n#include \"squashfs_fs.h\"\n#include <linux/slab.h>\n#include <linux/vfs.h>\n#include <linux/fs.h>\n\nstatic int get_dir_index_using_offset(struct super_block *sb,\n\tu64 *next_block, int *next_offset, u64 index_start, int index_offset,\n\tint i_count, u64 f_pos)\n{\n\tstruct squashfs_sb_info *msblk = sb->s_fs_info;\n\tint err, i, index, length = 0;\n\tunsigned int size;\n\tstruct squashfs_dir_index dir_index;\n\n\tTRACE(\"Entered get_dir_index_using_offset, i_count %d, f_pos %lld\\n\",\n\t\t\t\t\ti_count, f_pos);\n\n\t/*\n\t * Translate from external f_pos to the internal f_pos.  This\n\t * is offset by 3 because we invent \".\" and \"..\" entries which are\n\t * not actually stored in the directory.\n\t */\n\tif (f_pos <= 3)\n\t\treturn f_pos;\n\tf_pos -= 3;\n\n\tfor (i = 0; i < i_count; i++) {\n\t\terr = squashfs_read_metadata(sb, &dir_index, &index_start,\n\t\t\t\t&index_offset, sizeof(dir_index));\n\t\tif (err < 0)\n\t\t\tbreak;\n\n\t\tindex = le32_to_cpu(dir_index.index);\n\t\tif (index > f_pos)\n\t\t\t/*\n\t\t\t * Found the index we're looking for.\n\t\t\t */\n\t\t\tbreak;\n\n\t\tsize = le32_to_cpu(dir_index.size) + 1;\n\n\t\t/* size should never be larger than SQUASHFS_NAME_LEN */\n\t\tif (size > SQUASHFS_NAME_LEN)\n\t\t\tbreak;\n\n\t\terr = squashfs_read_metadata(sb, NULL, &index_start,\n\t\t\t\t&index_offset, size);\n\t\tif (err < 0)\n\t\t\tbreak;\n\n\t\tlength = index;\n\t\t*next_block = le32_to_cpu(dir_index.start_block) +\n\t\t\t\t\tmsblk->directory_table;\n\t}\n\n\t*next_offset = (length + *next_offset) % SQUASHFS_METADATA_SIZE;\n\n\t/*\n\t * Translate back from internal f_pos to external f_pos.\n\t */\n\treturn length + 3;\n}"
        }
      },
      {
        "call_info": {
          "callee": "squashfs_i",
          "args": [
            "inode"
          ],
          "line": 160
        },
        "resolved": true,
        "details": {
          "function_name": "squashfs_i",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/squashfs/squashfs_fs_i.h",
          "lines": "50-53",
          "snippet": "static inline struct squashfs_inode_info *squashfs_i(struct inode *inode)\n{\n\treturn list_entry(inode, struct squashfs_inode_info, vfs_inode);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline struct squashfs_inode_info *squashfs_i(struct inode *inode)\n{\n\treturn list_entry(inode, struct squashfs_inode_info, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dir_emit",
          "args": [
            "ctx",
            "name",
            "size",
            "i_ino",
            "squashfs_filetype_table[1]"
          ],
          "line": 150
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"Failed to allocate squashfs_dir_entry\\n\""
          ],
          "line": 124
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "sizeof(*dire) + SQUASHFS_NAME_LEN + 1",
            "GFP_KERNEL"
          ],
          "line": 122
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dx_dir_kmalloc_leaves",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "2534-2546",
          "snippet": "static struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}"
        }
      },
      {
        "call_info": {
          "callee": "TRACE",
          "args": [
            "\"Entered squashfs_readdir [%llx:%x]\\n\"",
            "block",
            "offset"
          ],
          "line": 120
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "file_inode",
          "args": [
            "file"
          ],
          "line": 112
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_init_file_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/file.c",
          "lines": "3009-3013",
          "snippet": "void fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}",
          "includes": [
            "#include <linux/falloc.h>",
            "#include <linux/aio.h>",
            "#include <linux/swap.h>",
            "#include <linux/compat.h>",
            "#include <linux/module.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};",
            "static const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/compat.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};\nstatic const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};\n\nvoid fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"squashfs.h\"\n#include \"squashfs_fs_i.h\"\n#include \"squashfs_fs_sb.h\"\n#include \"squashfs_fs.h\"\n#include <linux/slab.h>\n#include <linux/vfs.h>\n#include <linux/fs.h>\n\nstatic const unsigned char squashfs_filetype_table[] = {\n\tDT_UNKNOWN, DT_DIR, DT_REG, DT_LNK, DT_BLK, DT_CHR, DT_FIFO, DT_SOCK\n};\n\nstatic int squashfs_readdir(struct file *file, struct dir_context *ctx)\n{\n\tstruct inode *inode = file_inode(file);\n\tstruct squashfs_sb_info *msblk = inode->i_sb->s_fs_info;\n\tu64 block = squashfs_i(inode)->start + msblk->directory_table;\n\tint offset = squashfs_i(inode)->offset, length, err;\n\tunsigned int inode_number, dir_count, size, type;\n\tstruct squashfs_dir_header dirh;\n\tstruct squashfs_dir_entry *dire;\n\n\tTRACE(\"Entered squashfs_readdir [%llx:%x]\\n\", block, offset);\n\n\tdire = kmalloc(sizeof(*dire) + SQUASHFS_NAME_LEN + 1, GFP_KERNEL);\n\tif (dire == NULL) {\n\t\tERROR(\"Failed to allocate squashfs_dir_entry\\n\");\n\t\tgoto finish;\n\t}\n\n\t/*\n\t * Return \".\" and  \"..\" entries as the first two filenames in the\n\t * directory.  To maximise compression these two entries are not\n\t * stored in the directory, and so we invent them here.\n\t *\n\t * It also means that the external f_pos is offset by 3 from the\n\t * on-disk directory f_pos.\n\t */\n\twhile (ctx->pos < 3) {\n\t\tchar *name;\n\t\tint i_ino;\n\n\t\tif (ctx->pos == 0) {\n\t\t\tname = \".\";\n\t\t\tsize = 1;\n\t\t\ti_ino = inode->i_ino;\n\t\t} else {\n\t\t\tname = \"..\";\n\t\t\tsize = 2;\n\t\t\ti_ino = squashfs_i(inode)->parent;\n\t\t}\n\n\t\tif (!dir_emit(ctx, name, size, i_ino,\n\t\t\t\tsquashfs_filetype_table[1]))\n\t\t\tgoto finish;\n\n\t\tctx->pos += size;\n\t}\n\n\tlength = get_dir_index_using_offset(inode->i_sb, &block, &offset,\n\t\t\t\tsquashfs_i(inode)->dir_idx_start,\n\t\t\t\tsquashfs_i(inode)->dir_idx_offset,\n\t\t\t\tsquashfs_i(inode)->dir_idx_cnt,\n\t\t\t\tctx->pos);\n\n\twhile (length < i_size_read(inode)) {\n\t\t/*\n\t\t * Read directory header\n\t\t */\n\t\terr = squashfs_read_metadata(inode->i_sb, &dirh, &block,\n\t\t\t\t\t&offset, sizeof(dirh));\n\t\tif (err < 0)\n\t\t\tgoto failed_read;\n\n\t\tlength += sizeof(dirh);\n\n\t\tdir_count = le32_to_cpu(dirh.count) + 1;\n\n\t\tif (dir_count > SQUASHFS_DIR_COUNT)\n\t\t\tgoto failed_read;\n\n\t\twhile (dir_count--) {\n\t\t\t/*\n\t\t\t * Read directory entry.\n\t\t\t */\n\t\t\terr = squashfs_read_metadata(inode->i_sb, dire, &block,\n\t\t\t\t\t&offset, sizeof(*dire));\n\t\t\tif (err < 0)\n\t\t\t\tgoto failed_read;\n\n\t\t\tsize = le16_to_cpu(dire->size) + 1;\n\n\t\t\t/* size should never be larger than SQUASHFS_NAME_LEN */\n\t\t\tif (size > SQUASHFS_NAME_LEN)\n\t\t\t\tgoto failed_read;\n\n\t\t\terr = squashfs_read_metadata(inode->i_sb, dire->name,\n\t\t\t\t\t&block, &offset, size);\n\t\t\tif (err < 0)\n\t\t\t\tgoto failed_read;\n\n\t\t\tlength += sizeof(*dire) + size;\n\n\t\t\tif (ctx->pos >= length)\n\t\t\t\tcontinue;\n\n\t\t\tdire->name[size] = '\\0';\n\t\t\tinode_number = le32_to_cpu(dirh.inode_number) +\n\t\t\t\t((short) le16_to_cpu(dire->inode_number));\n\t\t\ttype = le16_to_cpu(dire->type);\n\n\t\t\tif (type > SQUASHFS_MAX_DIR_TYPE)\n\t\t\t\tgoto failed_read;\n\n\t\t\tif (!dir_emit(ctx, dire->name, size,\n\t\t\t\t\tinode_number,\n\t\t\t\t\tsquashfs_filetype_table[type]))\n\t\t\t\tgoto finish;\n\n\t\t\tctx->pos = length;\n\t\t}\n\t}\n\nfinish:\n\tkfree(dire);\n\treturn 0;\n\nfailed_read:\n\tERROR(\"Unable to read directory block [%llx:%x]\\n\", block, offset);\n\tkfree(dire);\n\treturn 0;\n}"
  },
  {
    "function_name": "get_dir_index_using_offset",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/squashfs/dir.c",
    "lines": "51-107",
    "snippet": "static int get_dir_index_using_offset(struct super_block *sb,\n\tu64 *next_block, int *next_offset, u64 index_start, int index_offset,\n\tint i_count, u64 f_pos)\n{\n\tstruct squashfs_sb_info *msblk = sb->s_fs_info;\n\tint err, i, index, length = 0;\n\tunsigned int size;\n\tstruct squashfs_dir_index dir_index;\n\n\tTRACE(\"Entered get_dir_index_using_offset, i_count %d, f_pos %lld\\n\",\n\t\t\t\t\ti_count, f_pos);\n\n\t/*\n\t * Translate from external f_pos to the internal f_pos.  This\n\t * is offset by 3 because we invent \".\" and \"..\" entries which are\n\t * not actually stored in the directory.\n\t */\n\tif (f_pos <= 3)\n\t\treturn f_pos;\n\tf_pos -= 3;\n\n\tfor (i = 0; i < i_count; i++) {\n\t\terr = squashfs_read_metadata(sb, &dir_index, &index_start,\n\t\t\t\t&index_offset, sizeof(dir_index));\n\t\tif (err < 0)\n\t\t\tbreak;\n\n\t\tindex = le32_to_cpu(dir_index.index);\n\t\tif (index > f_pos)\n\t\t\t/*\n\t\t\t * Found the index we're looking for.\n\t\t\t */\n\t\t\tbreak;\n\n\t\tsize = le32_to_cpu(dir_index.size) + 1;\n\n\t\t/* size should never be larger than SQUASHFS_NAME_LEN */\n\t\tif (size > SQUASHFS_NAME_LEN)\n\t\t\tbreak;\n\n\t\terr = squashfs_read_metadata(sb, NULL, &index_start,\n\t\t\t\t&index_offset, size);\n\t\tif (err < 0)\n\t\t\tbreak;\n\n\t\tlength = index;\n\t\t*next_block = le32_to_cpu(dir_index.start_block) +\n\t\t\t\t\tmsblk->directory_table;\n\t}\n\n\t*next_offset = (length + *next_offset) % SQUASHFS_METADATA_SIZE;\n\n\t/*\n\t * Translate back from internal f_pos to external f_pos.\n\t */\n\treturn length + 3;\n}",
    "includes": [
      "#include \"squashfs.h\"",
      "#include \"squashfs_fs_i.h\"",
      "#include \"squashfs_fs_sb.h\"",
      "#include \"squashfs_fs.h\"",
      "#include <linux/slab.h>",
      "#include <linux/vfs.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "dir_index.start_block"
          ],
          "line": 97
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "squashfs_read_metadata",
          "args": [
            "sb",
            "NULL",
            "&index_start",
            "&index_offset",
            "size"
          ],
          "line": 91
        },
        "resolved": true,
        "details": {
          "function_name": "squashfs_read_metadata",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/squashfs/cache.c",
          "lines": "344-382",
          "snippet": "int squashfs_read_metadata(struct super_block *sb, void *buffer,\n\t\tu64 *block, int *offset, int length)\n{\n\tstruct squashfs_sb_info *msblk = sb->s_fs_info;\n\tint bytes, res = length;\n\tstruct squashfs_cache_entry *entry;\n\n\tTRACE(\"Entered squashfs_read_metadata [%llx:%x]\\n\", *block, *offset);\n\n\twhile (length) {\n\t\tentry = squashfs_cache_get(sb, msblk->block_cache, *block, 0);\n\t\tif (entry->error) {\n\t\t\tres = entry->error;\n\t\t\tgoto error;\n\t\t} else if (*offset >= entry->length) {\n\t\t\tres = -EIO;\n\t\t\tgoto error;\n\t\t}\n\n\t\tbytes = squashfs_copy_data(buffer, entry, *offset, length);\n\t\tif (buffer)\n\t\t\tbuffer += bytes;\n\t\tlength -= bytes;\n\t\t*offset += bytes;\n\n\t\tif (*offset == entry->length) {\n\t\t\t*block = entry->next_index;\n\t\t\t*offset = 0;\n\t\t}\n\n\t\tsquashfs_cache_put(entry);\n\t}\n\n\treturn res;\n\nerror:\n\tsquashfs_cache_put(entry);\n\treturn res;\n}",
          "includes": [
            "#include \"page_actor.h\"",
            "#include \"squashfs.h\"",
            "#include \"squashfs_fs_sb.h\"",
            "#include \"squashfs_fs.h\"",
            "#include <linux/pagemap.h>",
            "#include <linux/wait.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/sched.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/vfs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"page_actor.h\"\n#include \"squashfs.h\"\n#include \"squashfs_fs_sb.h\"\n#include \"squashfs_fs.h\"\n#include <linux/pagemap.h>\n#include <linux/wait.h>\n#include <linux/spinlock.h>\n#include <linux/sched.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/vfs.h>\n#include <linux/fs.h>\n\nint squashfs_read_metadata(struct super_block *sb, void *buffer,\n\t\tu64 *block, int *offset, int length)\n{\n\tstruct squashfs_sb_info *msblk = sb->s_fs_info;\n\tint bytes, res = length;\n\tstruct squashfs_cache_entry *entry;\n\n\tTRACE(\"Entered squashfs_read_metadata [%llx:%x]\\n\", *block, *offset);\n\n\twhile (length) {\n\t\tentry = squashfs_cache_get(sb, msblk->block_cache, *block, 0);\n\t\tif (entry->error) {\n\t\t\tres = entry->error;\n\t\t\tgoto error;\n\t\t} else if (*offset >= entry->length) {\n\t\t\tres = -EIO;\n\t\t\tgoto error;\n\t\t}\n\n\t\tbytes = squashfs_copy_data(buffer, entry, *offset, length);\n\t\tif (buffer)\n\t\t\tbuffer += bytes;\n\t\tlength -= bytes;\n\t\t*offset += bytes;\n\n\t\tif (*offset == entry->length) {\n\t\t\t*block = entry->next_index;\n\t\t\t*offset = 0;\n\t\t}\n\n\t\tsquashfs_cache_put(entry);\n\t}\n\n\treturn res;\n\nerror:\n\tsquashfs_cache_put(entry);\n\treturn res;\n}"
        }
      },
      {
        "call_info": {
          "callee": "TRACE",
          "args": [
            "\"Entered get_dir_index_using_offset, i_count %d, f_pos %lld\\n\"",
            "i_count",
            "f_pos"
          ],
          "line": 60
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"squashfs.h\"\n#include \"squashfs_fs_i.h\"\n#include \"squashfs_fs_sb.h\"\n#include \"squashfs_fs.h\"\n#include <linux/slab.h>\n#include <linux/vfs.h>\n#include <linux/fs.h>\n\nstatic int get_dir_index_using_offset(struct super_block *sb,\n\tu64 *next_block, int *next_offset, u64 index_start, int index_offset,\n\tint i_count, u64 f_pos)\n{\n\tstruct squashfs_sb_info *msblk = sb->s_fs_info;\n\tint err, i, index, length = 0;\n\tunsigned int size;\n\tstruct squashfs_dir_index dir_index;\n\n\tTRACE(\"Entered get_dir_index_using_offset, i_count %d, f_pos %lld\\n\",\n\t\t\t\t\ti_count, f_pos);\n\n\t/*\n\t * Translate from external f_pos to the internal f_pos.  This\n\t * is offset by 3 because we invent \".\" and \"..\" entries which are\n\t * not actually stored in the directory.\n\t */\n\tif (f_pos <= 3)\n\t\treturn f_pos;\n\tf_pos -= 3;\n\n\tfor (i = 0; i < i_count; i++) {\n\t\terr = squashfs_read_metadata(sb, &dir_index, &index_start,\n\t\t\t\t&index_offset, sizeof(dir_index));\n\t\tif (err < 0)\n\t\t\tbreak;\n\n\t\tindex = le32_to_cpu(dir_index.index);\n\t\tif (index > f_pos)\n\t\t\t/*\n\t\t\t * Found the index we're looking for.\n\t\t\t */\n\t\t\tbreak;\n\n\t\tsize = le32_to_cpu(dir_index.size) + 1;\n\n\t\t/* size should never be larger than SQUASHFS_NAME_LEN */\n\t\tif (size > SQUASHFS_NAME_LEN)\n\t\t\tbreak;\n\n\t\terr = squashfs_read_metadata(sb, NULL, &index_start,\n\t\t\t\t&index_offset, size);\n\t\tif (err < 0)\n\t\t\tbreak;\n\n\t\tlength = index;\n\t\t*next_block = le32_to_cpu(dir_index.start_block) +\n\t\t\t\t\tmsblk->directory_table;\n\t}\n\n\t*next_offset = (length + *next_offset) % SQUASHFS_METADATA_SIZE;\n\n\t/*\n\t * Translate back from internal f_pos to external f_pos.\n\t */\n\treturn length + 3;\n}"
  }
]