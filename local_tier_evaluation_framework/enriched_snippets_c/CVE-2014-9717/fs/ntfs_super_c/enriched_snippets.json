[
  {
    "function_name": "exit_ntfs_fs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/super.c",
    "lines": "3190-3208",
    "snippet": "static void __exit exit_ntfs_fs(void)\n{\n\tntfs_debug(\"Unregistering NTFS driver.\");\n\n\tunregister_filesystem(&ntfs_fs_type);\n\n\t/*\n\t * Make sure all delayed rcu free inodes are flushed before we\n\t * destroy cache.\n\t */\n\trcu_barrier();\n\tkmem_cache_destroy(ntfs_big_inode_cache);\n\tkmem_cache_destroy(ntfs_inode_cache);\n\tkmem_cache_destroy(ntfs_name_cache);\n\tkmem_cache_destroy(ntfs_attr_ctx_cache);\n\tkmem_cache_destroy(ntfs_index_ctx_cache);\n\t/* Unregister the ntfs sysctls. */\n\tntfs_sysctl(0);\n}",
    "includes": [
      "#include \"ntfs.h\"",
      "#include \"malloc.h\"",
      "#include \"layout.h\"",
      "#include \"aops.h\"",
      "#include \"inode.h\"",
      "#include \"index.h\"",
      "#include \"debug.h\"",
      "#include \"dir.h\"",
      "#include \"usnjrnl.h\"",
      "#include \"quota.h\"",
      "#include \"logfile.h\"",
      "#include \"sysctl.h\"",
      "#include <linux/bitmap.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/vfs.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/blkdev.h>\t/* For bdev_logical_block_size(). */",
      "#include <linux/spinlock.h>",
      "#include <linux/string.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/stddef.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ntfs_sysctl",
          "args": [
            "0"
          ],
          "line": 3207
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmem_cache_destroy",
          "args": [
            "ntfs_index_ctx_cache"
          ],
          "line": 3205
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmem_cache_destroy",
          "args": [
            "ntfs_attr_ctx_cache"
          ],
          "line": 3204
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmem_cache_destroy",
          "args": [
            "ntfs_name_cache"
          ],
          "line": 3203
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmem_cache_destroy",
          "args": [
            "ntfs_inode_cache"
          ],
          "line": 3202
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmem_cache_destroy",
          "args": [
            "ntfs_big_inode_cache"
          ],
          "line": 3201
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_barrier",
          "args": [],
          "line": 3200
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unregister_filesystem",
          "args": [
            "&ntfs_fs_type"
          ],
          "line": 3194
        },
        "resolved": true,
        "details": {
          "function_name": "unregister_filesystem",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/filesystems.c",
          "lines": "101-120",
          "snippet": "int unregister_filesystem(struct file_system_type * fs)\n{\n\tstruct file_system_type ** tmp;\n\n\twrite_lock(&file_systems_lock);\n\ttmp = &file_systems;\n\twhile (*tmp) {\n\t\tif (fs == *tmp) {\n\t\t\t*tmp = fs->next;\n\t\t\tfs->next = NULL;\n\t\t\twrite_unlock(&file_systems_lock);\n\t\t\tsynchronize_rcu();\n\t\t\treturn 0;\n\t\t}\n\t\ttmp = &(*tmp)->next;\n\t}\n\twrite_unlock(&file_systems_lock);\n\n\treturn -EINVAL;\n}",
          "includes": [
            "#include <asm/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/kmod.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct file_system_type *file_systems;",
            "static DEFINE_RWLOCK(file_systems_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/uaccess.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kmod.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n\nstatic struct file_system_type *file_systems;\nstatic DEFINE_RWLOCK(file_systems_lock);\n\nint unregister_filesystem(struct file_system_type * fs)\n{\n\tstruct file_system_type ** tmp;\n\n\twrite_lock(&file_systems_lock);\n\ttmp = &file_systems;\n\twhile (*tmp) {\n\t\tif (fs == *tmp) {\n\t\t\t*tmp = fs->next;\n\t\t\tfs->next = NULL;\n\t\t\twrite_unlock(&file_systems_lock);\n\t\t\tsynchronize_rcu();\n\t\t\treturn 0;\n\t\t}\n\t\ttmp = &(*tmp)->next;\n\t}\n\twrite_unlock(&file_systems_lock);\n\n\treturn -EINVAL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ntfs_debug",
          "args": [
            "\"Unregistering NTFS driver.\""
          ],
          "line": 3192
        },
        "resolved": true,
        "details": {
          "function_name": "ntfs_debug_dump_runlist",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/debug.c",
          "lines": "134-171",
          "snippet": "void ntfs_debug_dump_runlist(const runlist_element *rl)\n{\n\tint i;\n\tconst char *lcn_str[5] = { \"LCN_HOLE         \", \"LCN_RL_NOT_MAPPED\",\n\t\t\t\t   \"LCN_ENOENT       \", \"LCN_unknown      \" };\n\n\tif (!debug_msgs)\n\t\treturn;\n\tpr_debug(\"Dumping runlist (values in hex):\\n\");\n\tif (!rl) {\n\t\tpr_debug(\"Run list not present.\\n\");\n\t\treturn;\n\t}\n\tpr_debug(\"VCN              LCN               Run length\\n\");\n\tfor (i = 0; ; i++) {\n\t\tLCN lcn = (rl + i)->lcn;\n\n\t\tif (lcn < (LCN)0) {\n\t\t\tint index = -lcn - 1;\n\n\t\t\tif (index > -LCN_ENOENT - 1)\n\t\t\t\tindex = 3;\n\t\t\tpr_debug(\"%-16Lx %s %-16Lx%s\\n\",\n\t\t\t\t\t(long long)(rl + i)->vcn, lcn_str[index],\n\t\t\t\t\t(long long)(rl + i)->length,\n\t\t\t\t\t(rl + i)->length ? \"\" :\n\t\t\t\t\t\t\" (runlist end)\");\n\t\t} else\n\t\t\tpr_debug(\"%-16Lx %-16Lx  %-16Lx%s\\n\",\n\t\t\t\t\t(long long)(rl + i)->vcn,\n\t\t\t\t\t(long long)(rl + i)->lcn,\n\t\t\t\t\t(long long)(rl + i)->length,\n\t\t\t\t\t(rl + i)->length ? \"\" :\n\t\t\t\t\t\t\" (runlist end)\");\n\t\tif (!(rl + i)->length)\n\t\t\tbreak;\n\t}\n}",
          "includes": [
            "#include \"debug.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"debug.h\"\n\nvoid ntfs_debug_dump_runlist(const runlist_element *rl)\n{\n\tint i;\n\tconst char *lcn_str[5] = { \"LCN_HOLE         \", \"LCN_RL_NOT_MAPPED\",\n\t\t\t\t   \"LCN_ENOENT       \", \"LCN_unknown      \" };\n\n\tif (!debug_msgs)\n\t\treturn;\n\tpr_debug(\"Dumping runlist (values in hex):\\n\");\n\tif (!rl) {\n\t\tpr_debug(\"Run list not present.\\n\");\n\t\treturn;\n\t}\n\tpr_debug(\"VCN              LCN               Run length\\n\");\n\tfor (i = 0; ; i++) {\n\t\tLCN lcn = (rl + i)->lcn;\n\n\t\tif (lcn < (LCN)0) {\n\t\t\tint index = -lcn - 1;\n\n\t\t\tif (index > -LCN_ENOENT - 1)\n\t\t\t\tindex = 3;\n\t\t\tpr_debug(\"%-16Lx %s %-16Lx%s\\n\",\n\t\t\t\t\t(long long)(rl + i)->vcn, lcn_str[index],\n\t\t\t\t\t(long long)(rl + i)->length,\n\t\t\t\t\t(rl + i)->length ? \"\" :\n\t\t\t\t\t\t\" (runlist end)\");\n\t\t} else\n\t\t\tpr_debug(\"%-16Lx %-16Lx  %-16Lx%s\\n\",\n\t\t\t\t\t(long long)(rl + i)->vcn,\n\t\t\t\t\t(long long)(rl + i)->lcn,\n\t\t\t\t\t(long long)(rl + i)->length,\n\t\t\t\t\t(rl + i)->length ? \"\" :\n\t\t\t\t\t\t\" (runlist end)\");\n\t\tif (!(rl + i)->length)\n\t\t\tbreak;\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ntfs.h\"\n#include \"malloc.h\"\n#include \"layout.h\"\n#include \"aops.h\"\n#include \"inode.h\"\n#include \"index.h\"\n#include \"debug.h\"\n#include \"dir.h\"\n#include \"usnjrnl.h\"\n#include \"quota.h\"\n#include \"logfile.h\"\n#include \"sysctl.h\"\n#include <linux/bitmap.h>\n#include <linux/moduleparam.h>\n#include <linux/vfs.h>\n#include <linux/buffer_head.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\t/* For bdev_logical_block_size(). */\n#include <linux/spinlock.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/stddef.h>\n\nstatic void __exit exit_ntfs_fs(void)\n{\n\tntfs_debug(\"Unregistering NTFS driver.\");\n\n\tunregister_filesystem(&ntfs_fs_type);\n\n\t/*\n\t * Make sure all delayed rcu free inodes are flushed before we\n\t * destroy cache.\n\t */\n\trcu_barrier();\n\tkmem_cache_destroy(ntfs_big_inode_cache);\n\tkmem_cache_destroy(ntfs_inode_cache);\n\tkmem_cache_destroy(ntfs_name_cache);\n\tkmem_cache_destroy(ntfs_attr_ctx_cache);\n\tkmem_cache_destroy(ntfs_index_ctx_cache);\n\t/* Unregister the ntfs sysctls. */\n\tntfs_sysctl(0);\n}"
  },
  {
    "function_name": "init_ntfs_fs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/super.c",
    "lines": "3094-3188",
    "snippet": "static int __init init_ntfs_fs(void)\n{\n\tint err = 0;\n\n\t/* This may be ugly but it results in pretty output so who cares. (-8 */\n\tpr_info(\"driver \" NTFS_VERSION \" [Flags: R/\"\n#ifdef NTFS_RW\n\t\t\t\"W\"\n#else\n\t\t\t\"O\"\n#endif\n#ifdef DEBUG\n\t\t\t\" DEBUG\"\n#endif\n#ifdef MODULE\n\t\t\t\" MODULE\"\n#endif\n\t\t\t\"].\\n\");\n\n\tntfs_debug(\"Debug messages are enabled.\");\n\n\tntfs_index_ctx_cache = kmem_cache_create(ntfs_index_ctx_cache_name,\n\t\t\tsizeof(ntfs_index_context), 0 /* offset */,\n\t\t\tSLAB_HWCACHE_ALIGN, NULL /* ctor */);\n\tif (!ntfs_index_ctx_cache) {\n\t\tpr_crit(\"Failed to create %s!\\n\", ntfs_index_ctx_cache_name);\n\t\tgoto ictx_err_out;\n\t}\n\tntfs_attr_ctx_cache = kmem_cache_create(ntfs_attr_ctx_cache_name,\n\t\t\tsizeof(ntfs_attr_search_ctx), 0 /* offset */,\n\t\t\tSLAB_HWCACHE_ALIGN, NULL /* ctor */);\n\tif (!ntfs_attr_ctx_cache) {\n\t\tpr_crit(\"NTFS: Failed to create %s!\\n\",\n\t\t\tntfs_attr_ctx_cache_name);\n\t\tgoto actx_err_out;\n\t}\n\n\tntfs_name_cache = kmem_cache_create(ntfs_name_cache_name,\n\t\t\t(NTFS_MAX_NAME_LEN+1) * sizeof(ntfschar), 0,\n\t\t\tSLAB_HWCACHE_ALIGN, NULL);\n\tif (!ntfs_name_cache) {\n\t\tpr_crit(\"Failed to create %s!\\n\", ntfs_name_cache_name);\n\t\tgoto name_err_out;\n\t}\n\n\tntfs_inode_cache = kmem_cache_create(ntfs_inode_cache_name,\n\t\t\tsizeof(ntfs_inode), 0,\n\t\t\tSLAB_RECLAIM_ACCOUNT|SLAB_MEM_SPREAD, NULL);\n\tif (!ntfs_inode_cache) {\n\t\tpr_crit(\"Failed to create %s!\\n\", ntfs_inode_cache_name);\n\t\tgoto inode_err_out;\n\t}\n\n\tntfs_big_inode_cache = kmem_cache_create(ntfs_big_inode_cache_name,\n\t\t\tsizeof(big_ntfs_inode), 0,\n\t\t\tSLAB_HWCACHE_ALIGN|SLAB_RECLAIM_ACCOUNT|SLAB_MEM_SPREAD,\n\t\t\tntfs_big_inode_init_once);\n\tif (!ntfs_big_inode_cache) {\n\t\tpr_crit(\"Failed to create %s!\\n\", ntfs_big_inode_cache_name);\n\t\tgoto big_inode_err_out;\n\t}\n\n\t/* Register the ntfs sysctls. */\n\terr = ntfs_sysctl(1);\n\tif (err) {\n\t\tpr_crit(\"Failed to register NTFS sysctls!\\n\");\n\t\tgoto sysctl_err_out;\n\t}\n\n\terr = register_filesystem(&ntfs_fs_type);\n\tif (!err) {\n\t\tntfs_debug(\"NTFS driver registered successfully.\");\n\t\treturn 0; /* Success! */\n\t}\n\tpr_crit(\"Failed to register NTFS filesystem driver!\\n\");\n\n\t/* Unregister the ntfs sysctls. */\n\tntfs_sysctl(0);\nsysctl_err_out:\n\tkmem_cache_destroy(ntfs_big_inode_cache);\nbig_inode_err_out:\n\tkmem_cache_destroy(ntfs_inode_cache);\ninode_err_out:\n\tkmem_cache_destroy(ntfs_name_cache);\nname_err_out:\n\tkmem_cache_destroy(ntfs_attr_ctx_cache);\nactx_err_out:\n\tkmem_cache_destroy(ntfs_index_ctx_cache);\nictx_err_out:\n\tif (!err) {\n\t\tpr_crit(\"Aborting NTFS filesystem driver registration...\\n\");\n\t\terr = -ENOMEM;\n\t}\n\treturn err;\n}",
    "includes": [
      "#include \"ntfs.h\"",
      "#include \"malloc.h\"",
      "#include \"layout.h\"",
      "#include \"aops.h\"",
      "#include \"inode.h\"",
      "#include \"index.h\"",
      "#include \"debug.h\"",
      "#include \"dir.h\"",
      "#include \"usnjrnl.h\"",
      "#include \"quota.h\"",
      "#include \"logfile.h\"",
      "#include \"sysctl.h\"",
      "#include <linux/bitmap.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/vfs.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/blkdev.h>\t/* For bdev_logical_block_size(). */",
      "#include <linux/spinlock.h>",
      "#include <linux/string.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/stddef.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pr_crit",
          "args": [
            "\"Aborting NTFS filesystem driver registration...\\n\""
          ],
          "line": 3184
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmem_cache_destroy",
          "args": [
            "ntfs_index_ctx_cache"
          ],
          "line": 3181
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmem_cache_destroy",
          "args": [
            "ntfs_attr_ctx_cache"
          ],
          "line": 3179
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmem_cache_destroy",
          "args": [
            "ntfs_name_cache"
          ],
          "line": 3177
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmem_cache_destroy",
          "args": [
            "ntfs_inode_cache"
          ],
          "line": 3175
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmem_cache_destroy",
          "args": [
            "ntfs_big_inode_cache"
          ],
          "line": 3173
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_sysctl",
          "args": [
            "0"
          ],
          "line": 3171
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_crit",
          "args": [
            "\"Failed to register NTFS filesystem driver!\\n\""
          ],
          "line": 3168
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_debug",
          "args": [
            "\"NTFS driver registered successfully.\""
          ],
          "line": 3165
        },
        "resolved": true,
        "details": {
          "function_name": "ntfs_debug_dump_runlist",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/debug.c",
          "lines": "134-171",
          "snippet": "void ntfs_debug_dump_runlist(const runlist_element *rl)\n{\n\tint i;\n\tconst char *lcn_str[5] = { \"LCN_HOLE         \", \"LCN_RL_NOT_MAPPED\",\n\t\t\t\t   \"LCN_ENOENT       \", \"LCN_unknown      \" };\n\n\tif (!debug_msgs)\n\t\treturn;\n\tpr_debug(\"Dumping runlist (values in hex):\\n\");\n\tif (!rl) {\n\t\tpr_debug(\"Run list not present.\\n\");\n\t\treturn;\n\t}\n\tpr_debug(\"VCN              LCN               Run length\\n\");\n\tfor (i = 0; ; i++) {\n\t\tLCN lcn = (rl + i)->lcn;\n\n\t\tif (lcn < (LCN)0) {\n\t\t\tint index = -lcn - 1;\n\n\t\t\tif (index > -LCN_ENOENT - 1)\n\t\t\t\tindex = 3;\n\t\t\tpr_debug(\"%-16Lx %s %-16Lx%s\\n\",\n\t\t\t\t\t(long long)(rl + i)->vcn, lcn_str[index],\n\t\t\t\t\t(long long)(rl + i)->length,\n\t\t\t\t\t(rl + i)->length ? \"\" :\n\t\t\t\t\t\t\" (runlist end)\");\n\t\t} else\n\t\t\tpr_debug(\"%-16Lx %-16Lx  %-16Lx%s\\n\",\n\t\t\t\t\t(long long)(rl + i)->vcn,\n\t\t\t\t\t(long long)(rl + i)->lcn,\n\t\t\t\t\t(long long)(rl + i)->length,\n\t\t\t\t\t(rl + i)->length ? \"\" :\n\t\t\t\t\t\t\" (runlist end)\");\n\t\tif (!(rl + i)->length)\n\t\t\tbreak;\n\t}\n}",
          "includes": [
            "#include \"debug.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"debug.h\"\n\nvoid ntfs_debug_dump_runlist(const runlist_element *rl)\n{\n\tint i;\n\tconst char *lcn_str[5] = { \"LCN_HOLE         \", \"LCN_RL_NOT_MAPPED\",\n\t\t\t\t   \"LCN_ENOENT       \", \"LCN_unknown      \" };\n\n\tif (!debug_msgs)\n\t\treturn;\n\tpr_debug(\"Dumping runlist (values in hex):\\n\");\n\tif (!rl) {\n\t\tpr_debug(\"Run list not present.\\n\");\n\t\treturn;\n\t}\n\tpr_debug(\"VCN              LCN               Run length\\n\");\n\tfor (i = 0; ; i++) {\n\t\tLCN lcn = (rl + i)->lcn;\n\n\t\tif (lcn < (LCN)0) {\n\t\t\tint index = -lcn - 1;\n\n\t\t\tif (index > -LCN_ENOENT - 1)\n\t\t\t\tindex = 3;\n\t\t\tpr_debug(\"%-16Lx %s %-16Lx%s\\n\",\n\t\t\t\t\t(long long)(rl + i)->vcn, lcn_str[index],\n\t\t\t\t\t(long long)(rl + i)->length,\n\t\t\t\t\t(rl + i)->length ? \"\" :\n\t\t\t\t\t\t\" (runlist end)\");\n\t\t} else\n\t\t\tpr_debug(\"%-16Lx %-16Lx  %-16Lx%s\\n\",\n\t\t\t\t\t(long long)(rl + i)->vcn,\n\t\t\t\t\t(long long)(rl + i)->lcn,\n\t\t\t\t\t(long long)(rl + i)->length,\n\t\t\t\t\t(rl + i)->length ? \"\" :\n\t\t\t\t\t\t\" (runlist end)\");\n\t\tif (!(rl + i)->length)\n\t\t\tbreak;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "register_filesystem",
          "args": [
            "&ntfs_fs_type"
          ],
          "line": 3163
        },
        "resolved": true,
        "details": {
          "function_name": "unregister_filesystem",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/filesystems.c",
          "lines": "101-120",
          "snippet": "int unregister_filesystem(struct file_system_type * fs)\n{\n\tstruct file_system_type ** tmp;\n\n\twrite_lock(&file_systems_lock);\n\ttmp = &file_systems;\n\twhile (*tmp) {\n\t\tif (fs == *tmp) {\n\t\t\t*tmp = fs->next;\n\t\t\tfs->next = NULL;\n\t\t\twrite_unlock(&file_systems_lock);\n\t\t\tsynchronize_rcu();\n\t\t\treturn 0;\n\t\t}\n\t\ttmp = &(*tmp)->next;\n\t}\n\twrite_unlock(&file_systems_lock);\n\n\treturn -EINVAL;\n}",
          "includes": [
            "#include <asm/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/kmod.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct file_system_type *file_systems;",
            "static DEFINE_RWLOCK(file_systems_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/uaccess.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kmod.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n\nstatic struct file_system_type *file_systems;\nstatic DEFINE_RWLOCK(file_systems_lock);\n\nint unregister_filesystem(struct file_system_type * fs)\n{\n\tstruct file_system_type ** tmp;\n\n\twrite_lock(&file_systems_lock);\n\ttmp = &file_systems;\n\twhile (*tmp) {\n\t\tif (fs == *tmp) {\n\t\t\t*tmp = fs->next;\n\t\t\tfs->next = NULL;\n\t\t\twrite_unlock(&file_systems_lock);\n\t\t\tsynchronize_rcu();\n\t\t\treturn 0;\n\t\t}\n\t\ttmp = &(*tmp)->next;\n\t}\n\twrite_unlock(&file_systems_lock);\n\n\treturn -EINVAL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_crit",
          "args": [
            "\"Failed to register NTFS sysctls!\\n\""
          ],
          "line": 3159
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_sysctl",
          "args": [
            "1"
          ],
          "line": 3157
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_crit",
          "args": [
            "\"Failed to create %s!\\n\"",
            "ntfs_big_inode_cache_name"
          ],
          "line": 3152
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmem_cache_create",
          "args": [
            "ntfs_big_inode_cache_name",
            "sizeof(big_ntfs_inode)",
            "0",
            "SLAB_HWCACHE_ALIGN|SLAB_RECLAIM_ACCOUNT|SLAB_MEM_SPREAD",
            "ntfs_big_inode_init_once"
          ],
          "line": 3147
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_crit",
          "args": [
            "\"Failed to create %s!\\n\"",
            "ntfs_inode_cache_name"
          ],
          "line": 3143
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmem_cache_create",
          "args": [
            "ntfs_inode_cache_name",
            "sizeof(ntfs_inode)",
            "0",
            "SLAB_RECLAIM_ACCOUNT|SLAB_MEM_SPREAD",
            "NULL"
          ],
          "line": 3139
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_crit",
          "args": [
            "\"Failed to create %s!\\n\"",
            "ntfs_name_cache_name"
          ],
          "line": 3135
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmem_cache_create",
          "args": [
            "ntfs_name_cache_name",
            "(NTFS_MAX_NAME_LEN+1) * sizeof(ntfschar)",
            "0",
            "SLAB_HWCACHE_ALIGN",
            "NULL"
          ],
          "line": 3131
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_crit",
          "args": [
            "\"NTFS: Failed to create %s!\\n\"",
            "ntfs_attr_ctx_cache_name"
          ],
          "line": 3126
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmem_cache_create",
          "args": [
            "ntfs_attr_ctx_cache_name",
            "sizeof(ntfs_attr_search_ctx)",
            "0/* offset */",
            "SLAB_HWCACHE_ALIGN",
            "NULL/* ctor */"
          ],
          "line": 3122
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_crit",
          "args": [
            "\"Failed to create %s!\\n\"",
            "ntfs_index_ctx_cache_name"
          ],
          "line": 3119
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmem_cache_create",
          "args": [
            "ntfs_index_ctx_cache_name",
            "sizeof(ntfs_index_context)",
            "0/* offset */",
            "SLAB_HWCACHE_ALIGN",
            "NULL/* ctor */"
          ],
          "line": 3115
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"driver \" NTFS_VERSION \" [Flags: R/\"\n#ifdef NTFS_RW\n\t\t\t\"W\"\n#else\n\t\t\t\"O\"\n#endif\n#ifdef DEBUG\n\t\t\t\" DEBUG\"\n#endif\n#ifdef MODULE\n\t\t\t\" MODULE\"\n#endif\"].\\n\""
          ],
          "line": 3099
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ntfs.h\"\n#include \"malloc.h\"\n#include \"layout.h\"\n#include \"aops.h\"\n#include \"inode.h\"\n#include \"index.h\"\n#include \"debug.h\"\n#include \"dir.h\"\n#include \"usnjrnl.h\"\n#include \"quota.h\"\n#include \"logfile.h\"\n#include \"sysctl.h\"\n#include <linux/bitmap.h>\n#include <linux/moduleparam.h>\n#include <linux/vfs.h>\n#include <linux/buffer_head.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\t/* For bdev_logical_block_size(). */\n#include <linux/spinlock.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/stddef.h>\n\nstatic int __init init_ntfs_fs(void)\n{\n\tint err = 0;\n\n\t/* This may be ugly but it results in pretty output so who cares. (-8 */\n\tpr_info(\"driver \" NTFS_VERSION \" [Flags: R/\"\n#ifdef NTFS_RW\n\t\t\t\"W\"\n#else\n\t\t\t\"O\"\n#endif\n#ifdef DEBUG\n\t\t\t\" DEBUG\"\n#endif\n#ifdef MODULE\n\t\t\t\" MODULE\"\n#endif\n\t\t\t\"].\\n\");\n\n\tntfs_debug(\"Debug messages are enabled.\");\n\n\tntfs_index_ctx_cache = kmem_cache_create(ntfs_index_ctx_cache_name,\n\t\t\tsizeof(ntfs_index_context), 0 /* offset */,\n\t\t\tSLAB_HWCACHE_ALIGN, NULL /* ctor */);\n\tif (!ntfs_index_ctx_cache) {\n\t\tpr_crit(\"Failed to create %s!\\n\", ntfs_index_ctx_cache_name);\n\t\tgoto ictx_err_out;\n\t}\n\tntfs_attr_ctx_cache = kmem_cache_create(ntfs_attr_ctx_cache_name,\n\t\t\tsizeof(ntfs_attr_search_ctx), 0 /* offset */,\n\t\t\tSLAB_HWCACHE_ALIGN, NULL /* ctor */);\n\tif (!ntfs_attr_ctx_cache) {\n\t\tpr_crit(\"NTFS: Failed to create %s!\\n\",\n\t\t\tntfs_attr_ctx_cache_name);\n\t\tgoto actx_err_out;\n\t}\n\n\tntfs_name_cache = kmem_cache_create(ntfs_name_cache_name,\n\t\t\t(NTFS_MAX_NAME_LEN+1) * sizeof(ntfschar), 0,\n\t\t\tSLAB_HWCACHE_ALIGN, NULL);\n\tif (!ntfs_name_cache) {\n\t\tpr_crit(\"Failed to create %s!\\n\", ntfs_name_cache_name);\n\t\tgoto name_err_out;\n\t}\n\n\tntfs_inode_cache = kmem_cache_create(ntfs_inode_cache_name,\n\t\t\tsizeof(ntfs_inode), 0,\n\t\t\tSLAB_RECLAIM_ACCOUNT|SLAB_MEM_SPREAD, NULL);\n\tif (!ntfs_inode_cache) {\n\t\tpr_crit(\"Failed to create %s!\\n\", ntfs_inode_cache_name);\n\t\tgoto inode_err_out;\n\t}\n\n\tntfs_big_inode_cache = kmem_cache_create(ntfs_big_inode_cache_name,\n\t\t\tsizeof(big_ntfs_inode), 0,\n\t\t\tSLAB_HWCACHE_ALIGN|SLAB_RECLAIM_ACCOUNT|SLAB_MEM_SPREAD,\n\t\t\tntfs_big_inode_init_once);\n\tif (!ntfs_big_inode_cache) {\n\t\tpr_crit(\"Failed to create %s!\\n\", ntfs_big_inode_cache_name);\n\t\tgoto big_inode_err_out;\n\t}\n\n\t/* Register the ntfs sysctls. */\n\terr = ntfs_sysctl(1);\n\tif (err) {\n\t\tpr_crit(\"Failed to register NTFS sysctls!\\n\");\n\t\tgoto sysctl_err_out;\n\t}\n\n\terr = register_filesystem(&ntfs_fs_type);\n\tif (!err) {\n\t\tntfs_debug(\"NTFS driver registered successfully.\");\n\t\treturn 0; /* Success! */\n\t}\n\tpr_crit(\"Failed to register NTFS filesystem driver!\\n\");\n\n\t/* Unregister the ntfs sysctls. */\n\tntfs_sysctl(0);\nsysctl_err_out:\n\tkmem_cache_destroy(ntfs_big_inode_cache);\nbig_inode_err_out:\n\tkmem_cache_destroy(ntfs_inode_cache);\ninode_err_out:\n\tkmem_cache_destroy(ntfs_name_cache);\nname_err_out:\n\tkmem_cache_destroy(ntfs_attr_ctx_cache);\nactx_err_out:\n\tkmem_cache_destroy(ntfs_index_ctx_cache);\nictx_err_out:\n\tif (!err) {\n\t\tpr_crit(\"Aborting NTFS filesystem driver registration...\\n\");\n\t\terr = -ENOMEM;\n\t}\n\treturn err;\n}"
  },
  {
    "function_name": "ntfs_mount",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/super.c",
    "lines": "3072-3076",
    "snippet": "static struct dentry *ntfs_mount(struct file_system_type *fs_type,\n\tint flags, const char *dev_name, void *data)\n{\n\treturn mount_bdev(fs_type, flags, dev_name, data, ntfs_fill_super);\n}",
    "includes": [
      "#include \"ntfs.h\"",
      "#include \"malloc.h\"",
      "#include \"layout.h\"",
      "#include \"aops.h\"",
      "#include \"inode.h\"",
      "#include \"index.h\"",
      "#include \"debug.h\"",
      "#include \"dir.h\"",
      "#include \"usnjrnl.h\"",
      "#include \"quota.h\"",
      "#include \"logfile.h\"",
      "#include \"sysctl.h\"",
      "#include <linux/bitmap.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/vfs.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/blkdev.h>\t/* For bdev_logical_block_size(). */",
      "#include <linux/spinlock.h>",
      "#include <linux/string.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/stddef.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mount_bdev",
          "args": [
            "fs_type",
            "flags",
            "dev_name",
            "data",
            "ntfs_fill_super"
          ],
          "line": 3075
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ntfs.h\"\n#include \"malloc.h\"\n#include \"layout.h\"\n#include \"aops.h\"\n#include \"inode.h\"\n#include \"index.h\"\n#include \"debug.h\"\n#include \"dir.h\"\n#include \"usnjrnl.h\"\n#include \"quota.h\"\n#include \"logfile.h\"\n#include \"sysctl.h\"\n#include <linux/bitmap.h>\n#include <linux/moduleparam.h>\n#include <linux/vfs.h>\n#include <linux/buffer_head.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\t/* For bdev_logical_block_size(). */\n#include <linux/spinlock.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/stddef.h>\n\nstatic struct dentry *ntfs_mount(struct file_system_type *fs_type,\n\tint flags, const char *dev_name, void *data)\n{\n\treturn mount_bdev(fs_type, flags, dev_name, data, ntfs_fill_super);\n}"
  },
  {
    "function_name": "ntfs_big_inode_init_once",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/super.c",
    "lines": "3055-3060",
    "snippet": "static void ntfs_big_inode_init_once(void *foo)\n{\n\tntfs_inode *ni = (ntfs_inode *)foo;\n\n\tinode_init_once(VFS_I(ni));\n}",
    "includes": [
      "#include \"ntfs.h\"",
      "#include \"malloc.h\"",
      "#include \"layout.h\"",
      "#include \"aops.h\"",
      "#include \"inode.h\"",
      "#include \"index.h\"",
      "#include \"debug.h\"",
      "#include \"dir.h\"",
      "#include \"usnjrnl.h\"",
      "#include \"quota.h\"",
      "#include \"logfile.h\"",
      "#include \"sysctl.h\"",
      "#include <linux/bitmap.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/vfs.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/blkdev.h>\t/* For bdev_logical_block_size(). */",
      "#include <linux/spinlock.h>",
      "#include <linux/string.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/stddef.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "inode_init_once",
          "args": [
            "VFS_I(ni)"
          ],
          "line": 3059
        },
        "resolved": true,
        "details": {
          "function_name": "ntfs_big_inode_init_once",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/super.c",
          "lines": "3055-3060",
          "snippet": "static void ntfs_big_inode_init_once(void *foo)\n{\n\tntfs_inode *ni = (ntfs_inode *)foo;\n\n\tinode_init_once(VFS_I(ni));\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "VFS_I",
          "args": [
            "ni"
          ],
          "line": 3059
        },
        "resolved": true,
        "details": {
          "function_name": "VFS_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/inode.h",
          "lines": "245-248",
          "snippet": "static inline struct inode *VFS_I(ntfs_inode *ni)\n{\n\treturn &((big_ntfs_inode *)ni)->vfs_inode;\n}",
          "includes": [
            "#include \"debug.h\"",
            "#include \"runlist.h\"",
            "#include \"types.h\"",
            "#include \"volume.h\"",
            "#include \"layout.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/mutex.h>",
            "#include <linux/mm.h>",
            "#include <linux/list.h>",
            "#include <linux/fs.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"debug.h\"\n#include \"runlist.h\"\n#include \"types.h\"\n#include \"volume.h\"\n#include \"layout.h\"\n#include <linux/seq_file.h>\n#include <linux/mutex.h>\n#include <linux/mm.h>\n#include <linux/list.h>\n#include <linux/fs.h>\n#include <linux/atomic.h>\n\nstatic inline struct inode *VFS_I(ntfs_inode *ni)\n{\n\treturn &((big_ntfs_inode *)ni)->vfs_inode;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ntfs.h\"\n#include \"malloc.h\"\n#include \"layout.h\"\n#include \"aops.h\"\n#include \"inode.h\"\n#include \"index.h\"\n#include \"debug.h\"\n#include \"dir.h\"\n#include \"usnjrnl.h\"\n#include \"quota.h\"\n#include \"logfile.h\"\n#include \"sysctl.h\"\n#include <linux/bitmap.h>\n#include <linux/moduleparam.h>\n#include <linux/vfs.h>\n#include <linux/buffer_head.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\t/* For bdev_logical_block_size(). */\n#include <linux/spinlock.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/stddef.h>\n\nstatic void ntfs_big_inode_init_once(void *foo)\n{\n\tntfs_inode *ni = (ntfs_inode *)foo;\n\n\tinode_init_once(VFS_I(ni));\n}"
  },
  {
    "function_name": "ntfs_fill_super",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/super.c",
    "lines": "2721-3041",
    "snippet": "static int ntfs_fill_super(struct super_block *sb, void *opt, const int silent)\n{\n\tntfs_volume *vol;\n\tstruct buffer_head *bh;\n\tstruct inode *tmp_ino;\n\tint blocksize, result;\n\n\t/*\n\t * We do a pretty difficult piece of bootstrap by reading the\n\t * MFT (and other metadata) from disk into memory. We'll only\n\t * release this metadata during umount, so the locking patterns\n\t * observed during bootstrap do not count. So turn off the\n\t * observation of locking patterns (strictly for this context\n\t * only) while mounting NTFS. [The validator is still active\n\t * otherwise, even for this context: it will for example record\n\t * lock class registrations.]\n\t */\n\tlockdep_off();\n\tntfs_debug(\"Entering.\");\n#ifndef NTFS_RW\n\tsb->s_flags |= MS_RDONLY;\n#endif /* ! NTFS_RW */\n\t/* Allocate a new ntfs_volume and place it in sb->s_fs_info. */\n\tsb->s_fs_info = kmalloc(sizeof(ntfs_volume), GFP_NOFS);\n\tvol = NTFS_SB(sb);\n\tif (!vol) {\n\t\tif (!silent)\n\t\t\tntfs_error(sb, \"Allocation of NTFS volume structure \"\n\t\t\t\t\t\"failed. Aborting mount...\");\n\t\tlockdep_on();\n\t\treturn -ENOMEM;\n\t}\n\t/* Initialize ntfs_volume structure. */\n\t*vol = (ntfs_volume) {\n\t\t.sb = sb,\n\t\t/*\n\t\t * Default is group and other don't have any access to files or\n\t\t * directories while owner has full access. Further, files by\n\t\t * default are not executable but directories are of course\n\t\t * browseable.\n\t\t */\n\t\t.fmask = 0177,\n\t\t.dmask = 0077,\n\t};\n\tinit_rwsem(&vol->mftbmp_lock);\n\tinit_rwsem(&vol->lcnbmp_lock);\n\n\t/* By default, enable sparse support. */\n\tNVolSetSparseEnabled(vol);\n\n\t/* Important to get the mount options dealt with now. */\n\tif (!parse_options(vol, (char*)opt))\n\t\tgoto err_out_now;\n\n\t/* We support sector sizes up to the PAGE_CACHE_SIZE. */\n\tif (bdev_logical_block_size(sb->s_bdev) > PAGE_CACHE_SIZE) {\n\t\tif (!silent)\n\t\t\tntfs_error(sb, \"Device has unsupported sector size \"\n\t\t\t\t\t\"(%i).  The maximum supported sector \"\n\t\t\t\t\t\"size on this architecture is %lu \"\n\t\t\t\t\t\"bytes.\",\n\t\t\t\t\tbdev_logical_block_size(sb->s_bdev),\n\t\t\t\t\tPAGE_CACHE_SIZE);\n\t\tgoto err_out_now;\n\t}\n\t/*\n\t * Setup the device access block size to NTFS_BLOCK_SIZE or the hard\n\t * sector size, whichever is bigger.\n\t */\n\tblocksize = sb_min_blocksize(sb, NTFS_BLOCK_SIZE);\n\tif (blocksize < NTFS_BLOCK_SIZE) {\n\t\tif (!silent)\n\t\t\tntfs_error(sb, \"Unable to set device block size.\");\n\t\tgoto err_out_now;\n\t}\n\tBUG_ON(blocksize != sb->s_blocksize);\n\tntfs_debug(\"Set device block size to %i bytes (block size bits %i).\",\n\t\t\tblocksize, sb->s_blocksize_bits);\n\t/* Determine the size of the device in units of block_size bytes. */\n\tif (!i_size_read(sb->s_bdev->bd_inode)) {\n\t\tif (!silent)\n\t\t\tntfs_error(sb, \"Unable to determine device size.\");\n\t\tgoto err_out_now;\n\t}\n\tvol->nr_blocks = i_size_read(sb->s_bdev->bd_inode) >>\n\t\t\tsb->s_blocksize_bits;\n\t/* Read the boot sector and return unlocked buffer head to it. */\n\tif (!(bh = read_ntfs_boot_sector(sb, silent))) {\n\t\tif (!silent)\n\t\t\tntfs_error(sb, \"Not an NTFS volume.\");\n\t\tgoto err_out_now;\n\t}\n\t/*\n\t * Extract the data from the boot sector and setup the ntfs volume\n\t * using it.\n\t */\n\tresult = parse_ntfs_boot_sector(vol, (NTFS_BOOT_SECTOR*)bh->b_data);\n\tbrelse(bh);\n\tif (!result) {\n\t\tif (!silent)\n\t\t\tntfs_error(sb, \"Unsupported NTFS filesystem.\");\n\t\tgoto err_out_now;\n\t}\n\t/*\n\t * If the boot sector indicates a sector size bigger than the current\n\t * device block size, switch the device block size to the sector size.\n\t * TODO: It may be possible to support this case even when the set\n\t * below fails, we would just be breaking up the i/o for each sector\n\t * into multiple blocks for i/o purposes but otherwise it should just\n\t * work.  However it is safer to leave disabled until someone hits this\n\t * error message and then we can get them to try it without the setting\n\t * so we know for sure that it works.\n\t */\n\tif (vol->sector_size > blocksize) {\n\t\tblocksize = sb_set_blocksize(sb, vol->sector_size);\n\t\tif (blocksize != vol->sector_size) {\n\t\t\tif (!silent)\n\t\t\t\tntfs_error(sb, \"Unable to set device block \"\n\t\t\t\t\t\t\"size to sector size (%i).\",\n\t\t\t\t\t\tvol->sector_size);\n\t\t\tgoto err_out_now;\n\t\t}\n\t\tBUG_ON(blocksize != sb->s_blocksize);\n\t\tvol->nr_blocks = i_size_read(sb->s_bdev->bd_inode) >>\n\t\t\t\tsb->s_blocksize_bits;\n\t\tntfs_debug(\"Changed device block size to %i bytes (block size \"\n\t\t\t\t\"bits %i) to match volume sector size.\",\n\t\t\t\tblocksize, sb->s_blocksize_bits);\n\t}\n\t/* Initialize the cluster and mft allocators. */\n\tntfs_setup_allocators(vol);\n\t/* Setup remaining fields in the super block. */\n\tsb->s_magic = NTFS_SB_MAGIC;\n\t/*\n\t * Ntfs allows 63 bits for the file size, i.e. correct would be:\n\t *\tsb->s_maxbytes = ~0ULL >> 1;\n\t * But the kernel uses a long as the page cache page index which on\n\t * 32-bit architectures is only 32-bits. MAX_LFS_FILESIZE is kernel\n\t * defined to the maximum the page cache page index can cope with\n\t * without overflowing the index or to 2^63 - 1, whichever is smaller.\n\t */\n\tsb->s_maxbytes = MAX_LFS_FILESIZE;\n\t/* Ntfs measures time in 100ns intervals. */\n\tsb->s_time_gran = 100;\n\t/*\n\t * Now load the metadata required for the page cache and our address\n\t * space operations to function. We do this by setting up a specialised\n\t * read_inode method and then just calling the normal iget() to obtain\n\t * the inode for $MFT which is sufficient to allow our normal inode\n\t * operations and associated address space operations to function.\n\t */\n\tsb->s_op = &ntfs_sops;\n\ttmp_ino = new_inode(sb);\n\tif (!tmp_ino) {\n\t\tif (!silent)\n\t\t\tntfs_error(sb, \"Failed to load essential metadata.\");\n\t\tgoto err_out_now;\n\t}\n\ttmp_ino->i_ino = FILE_MFT;\n\tinsert_inode_hash(tmp_ino);\n\tif (ntfs_read_inode_mount(tmp_ino) < 0) {\n\t\tif (!silent)\n\t\t\tntfs_error(sb, \"Failed to load essential metadata.\");\n\t\tgoto iput_tmp_ino_err_out_now;\n\t}\n\tmutex_lock(&ntfs_lock);\n\t/*\n\t * The current mount is a compression user if the cluster size is\n\t * less than or equal 4kiB.\n\t */\n\tif (vol->cluster_size <= 4096 && !ntfs_nr_compression_users++) {\n\t\tresult = allocate_compression_buffers();\n\t\tif (result) {\n\t\t\tntfs_error(NULL, \"Failed to allocate buffers \"\n\t\t\t\t\t\"for compression engine.\");\n\t\t\tntfs_nr_compression_users--;\n\t\t\tmutex_unlock(&ntfs_lock);\n\t\t\tgoto iput_tmp_ino_err_out_now;\n\t\t}\n\t}\n\t/*\n\t * Generate the global default upcase table if necessary.  Also\n\t * temporarily increment the number of upcase users to avoid race\n\t * conditions with concurrent (u)mounts.\n\t */\n\tif (!default_upcase)\n\t\tdefault_upcase = generate_default_upcase();\n\tntfs_nr_upcase_users++;\n\tmutex_unlock(&ntfs_lock);\n\t/*\n\t * From now on, ignore @silent parameter. If we fail below this line,\n\t * it will be due to a corrupt fs or a system error, so we report it.\n\t */\n\t/*\n\t * Open the system files with normal access functions and complete\n\t * setting up the ntfs super block.\n\t */\n\tif (!load_system_files(vol)) {\n\t\tntfs_error(sb, \"Failed to load system files.\");\n\t\tgoto unl_upcase_iput_tmp_ino_err_out_now;\n\t}\n\n\t/* We grab a reference, simulating an ntfs_iget(). */\n\tihold(vol->root_ino);\n\tif ((sb->s_root = d_make_root(vol->root_ino))) {\n\t\tntfs_debug(\"Exiting, status successful.\");\n\t\t/* Release the default upcase if it has no users. */\n\t\tmutex_lock(&ntfs_lock);\n\t\tif (!--ntfs_nr_upcase_users && default_upcase) {\n\t\t\tntfs_free(default_upcase);\n\t\t\tdefault_upcase = NULL;\n\t\t}\n\t\tmutex_unlock(&ntfs_lock);\n\t\tsb->s_export_op = &ntfs_export_ops;\n\t\tlockdep_on();\n\t\treturn 0;\n\t}\n\tntfs_error(sb, \"Failed to allocate root directory.\");\n\t/* Clean up after the successful load_system_files() call from above. */\n\t// TODO: Use ntfs_put_super() instead of repeating all this code...\n\t// FIXME: Should mark the volume clean as the error is most likely\n\t// \t  -ENOMEM.\n\tiput(vol->vol_ino);\n\tvol->vol_ino = NULL;\n\t/* NTFS 3.0+ specific clean up. */\n\tif (vol->major_ver >= 3) {\n#ifdef NTFS_RW\n\t\tif (vol->usnjrnl_j_ino) {\n\t\t\tiput(vol->usnjrnl_j_ino);\n\t\t\tvol->usnjrnl_j_ino = NULL;\n\t\t}\n\t\tif (vol->usnjrnl_max_ino) {\n\t\t\tiput(vol->usnjrnl_max_ino);\n\t\t\tvol->usnjrnl_max_ino = NULL;\n\t\t}\n\t\tif (vol->usnjrnl_ino) {\n\t\t\tiput(vol->usnjrnl_ino);\n\t\t\tvol->usnjrnl_ino = NULL;\n\t\t}\n\t\tif (vol->quota_q_ino) {\n\t\t\tiput(vol->quota_q_ino);\n\t\t\tvol->quota_q_ino = NULL;\n\t\t}\n\t\tif (vol->quota_ino) {\n\t\t\tiput(vol->quota_ino);\n\t\t\tvol->quota_ino = NULL;\n\t\t}\n#endif /* NTFS_RW */\n\t\tif (vol->extend_ino) {\n\t\t\tiput(vol->extend_ino);\n\t\t\tvol->extend_ino = NULL;\n\t\t}\n\t\tif (vol->secure_ino) {\n\t\t\tiput(vol->secure_ino);\n\t\t\tvol->secure_ino = NULL;\n\t\t}\n\t}\n\tiput(vol->root_ino);\n\tvol->root_ino = NULL;\n\tiput(vol->lcnbmp_ino);\n\tvol->lcnbmp_ino = NULL;\n\tiput(vol->mftbmp_ino);\n\tvol->mftbmp_ino = NULL;\n#ifdef NTFS_RW\n\tif (vol->logfile_ino) {\n\t\tiput(vol->logfile_ino);\n\t\tvol->logfile_ino = NULL;\n\t}\n\tif (vol->mftmirr_ino) {\n\t\tiput(vol->mftmirr_ino);\n\t\tvol->mftmirr_ino = NULL;\n\t}\n#endif /* NTFS_RW */\n\t/* Throw away the table of attribute definitions. */\n\tvol->attrdef_size = 0;\n\tif (vol->attrdef) {\n\t\tntfs_free(vol->attrdef);\n\t\tvol->attrdef = NULL;\n\t}\n\tvol->upcase_len = 0;\n\tmutex_lock(&ntfs_lock);\n\tif (vol->upcase == default_upcase) {\n\t\tntfs_nr_upcase_users--;\n\t\tvol->upcase = NULL;\n\t}\n\tmutex_unlock(&ntfs_lock);\n\tif (vol->upcase) {\n\t\tntfs_free(vol->upcase);\n\t\tvol->upcase = NULL;\n\t}\n\tif (vol->nls_map) {\n\t\tunload_nls(vol->nls_map);\n\t\tvol->nls_map = NULL;\n\t}\n\t/* Error exit code path. */\nunl_upcase_iput_tmp_ino_err_out_now:\n\t/*\n\t * Decrease the number of upcase users and destroy the global default\n\t * upcase table if necessary.\n\t */\n\tmutex_lock(&ntfs_lock);\n\tif (!--ntfs_nr_upcase_users && default_upcase) {\n\t\tntfs_free(default_upcase);\n\t\tdefault_upcase = NULL;\n\t}\n\tif (vol->cluster_size <= 4096 && !--ntfs_nr_compression_users)\n\t\tfree_compression_buffers();\n\tmutex_unlock(&ntfs_lock);\niput_tmp_ino_err_out_now:\n\tiput(tmp_ino);\n\tif (vol->mft_ino && vol->mft_ino != tmp_ino)\n\t\tiput(vol->mft_ino);\n\tvol->mft_ino = NULL;\n\t/* Errors at this stage are irrelevant. */\nerr_out_now:\n\tsb->s_fs_info = NULL;\n\tkfree(vol);\n\tntfs_debug(\"Failed, returning -EINVAL.\");\n\tlockdep_on();\n\treturn -EINVAL;\n}",
    "includes": [
      "#include \"ntfs.h\"",
      "#include \"malloc.h\"",
      "#include \"layout.h\"",
      "#include \"aops.h\"",
      "#include \"inode.h\"",
      "#include \"index.h\"",
      "#include \"debug.h\"",
      "#include \"dir.h\"",
      "#include \"usnjrnl.h\"",
      "#include \"quota.h\"",
      "#include \"logfile.h\"",
      "#include \"sysctl.h\"",
      "#include <linux/bitmap.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/vfs.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/blkdev.h>\t/* For bdev_logical_block_size(). */",
      "#include <linux/spinlock.h>",
      "#include <linux/string.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/stddef.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static unsigned long ntfs_nr_compression_users;",
      "static ntfschar *default_upcase;",
      "static unsigned long ntfs_nr_upcase_users;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "lockdep_on",
          "args": [],
          "line": 3039
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_debug",
          "args": [
            "\"Failed, returning -EINVAL.\""
          ],
          "line": 3038
        },
        "resolved": true,
        "details": {
          "function_name": "ntfs_debug_dump_runlist",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/debug.c",
          "lines": "134-171",
          "snippet": "void ntfs_debug_dump_runlist(const runlist_element *rl)\n{\n\tint i;\n\tconst char *lcn_str[5] = { \"LCN_HOLE         \", \"LCN_RL_NOT_MAPPED\",\n\t\t\t\t   \"LCN_ENOENT       \", \"LCN_unknown      \" };\n\n\tif (!debug_msgs)\n\t\treturn;\n\tpr_debug(\"Dumping runlist (values in hex):\\n\");\n\tif (!rl) {\n\t\tpr_debug(\"Run list not present.\\n\");\n\t\treturn;\n\t}\n\tpr_debug(\"VCN              LCN               Run length\\n\");\n\tfor (i = 0; ; i++) {\n\t\tLCN lcn = (rl + i)->lcn;\n\n\t\tif (lcn < (LCN)0) {\n\t\t\tint index = -lcn - 1;\n\n\t\t\tif (index > -LCN_ENOENT - 1)\n\t\t\t\tindex = 3;\n\t\t\tpr_debug(\"%-16Lx %s %-16Lx%s\\n\",\n\t\t\t\t\t(long long)(rl + i)->vcn, lcn_str[index],\n\t\t\t\t\t(long long)(rl + i)->length,\n\t\t\t\t\t(rl + i)->length ? \"\" :\n\t\t\t\t\t\t\" (runlist end)\");\n\t\t} else\n\t\t\tpr_debug(\"%-16Lx %-16Lx  %-16Lx%s\\n\",\n\t\t\t\t\t(long long)(rl + i)->vcn,\n\t\t\t\t\t(long long)(rl + i)->lcn,\n\t\t\t\t\t(long long)(rl + i)->length,\n\t\t\t\t\t(rl + i)->length ? \"\" :\n\t\t\t\t\t\t\" (runlist end)\");\n\t\tif (!(rl + i)->length)\n\t\t\tbreak;\n\t}\n}",
          "includes": [
            "#include \"debug.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"debug.h\"\n\nvoid ntfs_debug_dump_runlist(const runlist_element *rl)\n{\n\tint i;\n\tconst char *lcn_str[5] = { \"LCN_HOLE         \", \"LCN_RL_NOT_MAPPED\",\n\t\t\t\t   \"LCN_ENOENT       \", \"LCN_unknown      \" };\n\n\tif (!debug_msgs)\n\t\treturn;\n\tpr_debug(\"Dumping runlist (values in hex):\\n\");\n\tif (!rl) {\n\t\tpr_debug(\"Run list not present.\\n\");\n\t\treturn;\n\t}\n\tpr_debug(\"VCN              LCN               Run length\\n\");\n\tfor (i = 0; ; i++) {\n\t\tLCN lcn = (rl + i)->lcn;\n\n\t\tif (lcn < (LCN)0) {\n\t\t\tint index = -lcn - 1;\n\n\t\t\tif (index > -LCN_ENOENT - 1)\n\t\t\t\tindex = 3;\n\t\t\tpr_debug(\"%-16Lx %s %-16Lx%s\\n\",\n\t\t\t\t\t(long long)(rl + i)->vcn, lcn_str[index],\n\t\t\t\t\t(long long)(rl + i)->length,\n\t\t\t\t\t(rl + i)->length ? \"\" :\n\t\t\t\t\t\t\" (runlist end)\");\n\t\t} else\n\t\t\tpr_debug(\"%-16Lx %-16Lx  %-16Lx%s\\n\",\n\t\t\t\t\t(long long)(rl + i)->vcn,\n\t\t\t\t\t(long long)(rl + i)->lcn,\n\t\t\t\t\t(long long)(rl + i)->length,\n\t\t\t\t\t(rl + i)->length ? \"\" :\n\t\t\t\t\t\t\" (runlist end)\");\n\t\tif (!(rl + i)->length)\n\t\t\tbreak;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "vol"
          ],
          "line": 3037
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "iput",
          "args": [
            "vol->mft_ino"
          ],
          "line": 3032
        },
        "resolved": true,
        "details": {
          "function_name": "dentry_iput",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "308-327",
          "snippet": "static void dentry_iput(struct dentry * dentry)\n\t__releases(dentry->d_lock)\n\t__releases(dentry->d_inode->i_lock)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tif (inode) {\n\t\tdentry->d_inode = NULL;\n\t\thlist_del_init(&dentry->d_u.d_alias);\n\t\tspin_unlock(&dentry->d_lock);\n\t\tspin_unlock(&inode->i_lock);\n\t\tif (!inode->i_nlink)\n\t\t\tfsnotify_inoderemove(inode);\n\t\tif (dentry->d_op && dentry->d_op->d_iput)\n\t\t\tdentry->d_op->d_iput(dentry, inode);\n\t\telse\n\t\t\tiput(inode);\n\t} else {\n\t\tspin_unlock(&dentry->d_lock);\n\t}\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nstatic void dentry_iput(struct dentry * dentry)\n\t__releases(dentry->d_lock)\n\t__releases(dentry->d_inode->i_lock)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tif (inode) {\n\t\tdentry->d_inode = NULL;\n\t\thlist_del_init(&dentry->d_u.d_alias);\n\t\tspin_unlock(&dentry->d_lock);\n\t\tspin_unlock(&inode->i_lock);\n\t\tif (!inode->i_nlink)\n\t\t\tfsnotify_inoderemove(inode);\n\t\tif (dentry->d_op && dentry->d_op->d_iput)\n\t\t\tdentry->d_op->d_iput(dentry, inode);\n\t\telse\n\t\t\tiput(inode);\n\t} else {\n\t\tspin_unlock(&dentry->d_lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&ntfs_lock"
          ],
          "line": 3028
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free_compression_buffers",
          "args": [],
          "line": 3027
        },
        "resolved": true,
        "details": {
          "function_name": "free_compression_buffers",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/compress.c",
          "lines": "90-95",
          "snippet": "void free_compression_buffers(void)\n{\n\tBUG_ON(!ntfs_compression_buffer);\n\tvfree(ntfs_compression_buffer);\n\tntfs_compression_buffer = NULL;\n}",
          "includes": [
            "#include \"ntfs.h\"",
            "#include \"debug.h\"",
            "#include \"inode.h\"",
            "#include \"attrib.h\"",
            "#include <linux/slab.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static u8 *ntfs_compression_buffer;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ntfs.h\"\n#include \"debug.h\"\n#include \"inode.h\"\n#include \"attrib.h\"\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n\nstatic u8 *ntfs_compression_buffer;\n\nvoid free_compression_buffers(void)\n{\n\tBUG_ON(!ntfs_compression_buffer);\n\tvfree(ntfs_compression_buffer);\n\tntfs_compression_buffer = NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ntfs_free",
          "args": [
            "default_upcase"
          ],
          "line": 3023
        },
        "resolved": true,
        "details": {
          "function_name": "ntfs_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/malloc.h",
          "lines": "86-94",
          "snippet": "static inline void ntfs_free(void *addr)\n{\n\tif (!is_vmalloc_addr(addr)) {\n\t\tkfree(addr);\n\t\t/* free_page((unsigned long)addr); */\n\t\treturn;\n\t}\n\tvfree(addr);\n}",
          "includes": [
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/vmalloc.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n\nstatic inline void ntfs_free(void *addr)\n{\n\tif (!is_vmalloc_addr(addr)) {\n\t\tkfree(addr);\n\t\t/* free_page((unsigned long)addr); */\n\t\treturn;\n\t}\n\tvfree(addr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&ntfs_lock"
          ],
          "line": 3021
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unload_nls",
          "args": [
            "vol->nls_map"
          ],
          "line": 3012
        },
        "resolved": true,
        "details": {
          "function_name": "unload_nls",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nls/nls_base.c",
          "lines": "296-300",
          "snippet": "void unload_nls(struct nls_table *nls)\n{\n\tif (nls)\n\t\tmodule_put(nls->owner);\n}",
          "includes": [
            "#include <asm/byteorder.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/kmod.h>",
            "#include <linux/errno.h>",
            "#include <linux/kernel.h>",
            "#include <linux/nls.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/byteorder.h>\n#include <linux/spinlock.h>\n#include <linux/kmod.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include <linux/nls.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nvoid unload_nls(struct nls_table *nls)\n{\n\tif (nls)\n\t\tmodule_put(nls->owner);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&ntfs_lock"
          ],
          "line": 3006
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&ntfs_lock"
          ],
          "line": 3001
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_error",
          "args": [
            "sb",
            "\"Failed to allocate root directory.\""
          ],
          "line": 2938
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lockdep_on",
          "args": [],
          "line": 2935
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&ntfs_lock"
          ],
          "line": 2933
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&ntfs_lock"
          ],
          "line": 2928
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "d_make_root",
          "args": [
            "vol->root_ino"
          ],
          "line": 2925
        },
        "resolved": true,
        "details": {
          "function_name": "d_make_root",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "1857-1871",
          "snippet": "struct dentry *d_make_root(struct inode *root_inode)\n{\n\tstruct dentry *res = NULL;\n\n\tif (root_inode) {\n\t\tstatic const struct qstr name = QSTR_INIT(\"/\", 1);\n\n\t\tres = __d_alloc(root_inode->i_sb, &name);\n\t\tif (res)\n\t\t\td_instantiate(res, root_inode);\n\t\telse\n\t\t\tiput(root_inode);\n\t}\n\treturn res;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nstruct dentry *d_make_root(struct inode *root_inode)\n{\n\tstruct dentry *res = NULL;\n\n\tif (root_inode) {\n\t\tstatic const struct qstr name = QSTR_INIT(\"/\", 1);\n\n\t\tres = __d_alloc(root_inode->i_sb, &name);\n\t\tif (res)\n\t\t\td_instantiate(res, root_inode);\n\t\telse\n\t\t\tiput(root_inode);\n\t}\n\treturn res;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ihold",
          "args": [
            "vol->root_ino"
          ],
          "line": 2924
        },
        "resolved": true,
        "details": {
          "function_name": "ihold",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "388-391",
          "snippet": "void ihold(struct inode *inode)\n{\n\tWARN_ON(atomic_inc_return(&inode->i_count) < 2);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid ihold(struct inode *inode)\n{\n\tWARN_ON(atomic_inc_return(&inode->i_count) < 2);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ntfs_error",
          "args": [
            "sb",
            "\"Failed to load system files.\""
          ],
          "line": 2919
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "load_system_files",
          "args": [
            "vol"
          ],
          "line": 2918
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&ntfs_lock"
          ],
          "line": 2909
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "generate_default_upcase",
          "args": [],
          "line": 2907
        },
        "resolved": true,
        "details": {
          "function_name": "generate_default_upcase",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/upcase.c",
          "lines": "27-87",
          "snippet": "ntfschar *generate_default_upcase(void)\n{\n\tstatic const int uc_run_table[][3] = { /* Start, End, Add */\n\t{0x0061, 0x007B,  -32}, {0x0451, 0x045D, -80}, {0x1F70, 0x1F72,  74},\n\t{0x00E0, 0x00F7,  -32}, {0x045E, 0x0460, -80}, {0x1F72, 0x1F76,  86},\n\t{0x00F8, 0x00FF,  -32}, {0x0561, 0x0587, -48}, {0x1F76, 0x1F78, 100},\n\t{0x0256, 0x0258, -205}, {0x1F00, 0x1F08,   8}, {0x1F78, 0x1F7A, 128},\n\t{0x028A, 0x028C, -217}, {0x1F10, 0x1F16,   8}, {0x1F7A, 0x1F7C, 112},\n\t{0x03AC, 0x03AD,  -38}, {0x1F20, 0x1F28,   8}, {0x1F7C, 0x1F7E, 126},\n\t{0x03AD, 0x03B0,  -37}, {0x1F30, 0x1F38,   8}, {0x1FB0, 0x1FB2,   8},\n\t{0x03B1, 0x03C2,  -32}, {0x1F40, 0x1F46,   8}, {0x1FD0, 0x1FD2,   8},\n\t{0x03C2, 0x03C3,  -31}, {0x1F51, 0x1F52,   8}, {0x1FE0, 0x1FE2,   8},\n\t{0x03C3, 0x03CC,  -32}, {0x1F53, 0x1F54,   8}, {0x1FE5, 0x1FE6,   7},\n\t{0x03CC, 0x03CD,  -64}, {0x1F55, 0x1F56,   8}, {0x2170, 0x2180, -16},\n\t{0x03CD, 0x03CF,  -63}, {0x1F57, 0x1F58,   8}, {0x24D0, 0x24EA, -26},\n\t{0x0430, 0x0450,  -32}, {0x1F60, 0x1F68,   8}, {0xFF41, 0xFF5B, -32},\n\t{0}\n\t};\n\n\tstatic const int uc_dup_table[][2] = { /* Start, End */\n\t{0x0100, 0x012F}, {0x01A0, 0x01A6}, {0x03E2, 0x03EF}, {0x04CB, 0x04CC},\n\t{0x0132, 0x0137}, {0x01B3, 0x01B7}, {0x0460, 0x0481}, {0x04D0, 0x04EB},\n\t{0x0139, 0x0149}, {0x01CD, 0x01DD}, {0x0490, 0x04BF}, {0x04EE, 0x04F5},\n\t{0x014A, 0x0178}, {0x01DE, 0x01EF}, {0x04BF, 0x04BF}, {0x04F8, 0x04F9},\n\t{0x0179, 0x017E}, {0x01F4, 0x01F5}, {0x04C1, 0x04C4}, {0x1E00, 0x1E95},\n\t{0x018B, 0x018B}, {0x01FA, 0x0218}, {0x04C7, 0x04C8}, {0x1EA0, 0x1EF9},\n\t{0}\n\t};\n\n\tstatic const int uc_word_table[][2] = { /* Offset, Value */\n\t{0x00FF, 0x0178}, {0x01AD, 0x01AC}, {0x01F3, 0x01F1}, {0x0269, 0x0196},\n\t{0x0183, 0x0182}, {0x01B0, 0x01AF}, {0x0253, 0x0181}, {0x026F, 0x019C},\n\t{0x0185, 0x0184}, {0x01B9, 0x01B8}, {0x0254, 0x0186}, {0x0272, 0x019D},\n\t{0x0188, 0x0187}, {0x01BD, 0x01BC}, {0x0259, 0x018F}, {0x0275, 0x019F},\n\t{0x018C, 0x018B}, {0x01C6, 0x01C4}, {0x025B, 0x0190}, {0x0283, 0x01A9},\n\t{0x0192, 0x0191}, {0x01C9, 0x01C7}, {0x0260, 0x0193}, {0x0288, 0x01AE},\n\t{0x0199, 0x0198}, {0x01CC, 0x01CA}, {0x0263, 0x0194}, {0x0292, 0x01B7},\n\t{0x01A8, 0x01A7}, {0x01DD, 0x018E}, {0x0268, 0x0197},\n\t{0}\n\t};\n\n\tint i, r;\n\tntfschar *uc;\n\n\tuc = ntfs_malloc_nofs(default_upcase_len * sizeof(ntfschar));\n\tif (!uc)\n\t\treturn uc;\n\tmemset(uc, 0, default_upcase_len * sizeof(ntfschar));\n\t/* Generate the little endian Unicode upcase table used by ntfs. */\n\tfor (i = 0; i < default_upcase_len; i++)\n\t\tuc[i] = cpu_to_le16(i);\n\tfor (r = 0; uc_run_table[r][0]; r++)\n\t\tfor (i = uc_run_table[r][0]; i < uc_run_table[r][1]; i++)\n\t\t\tle16_add_cpu(&uc[i], uc_run_table[r][2]);\n\tfor (r = 0; uc_dup_table[r][0]; r++)\n\t\tfor (i = uc_dup_table[r][0]; i < uc_dup_table[r][1]; i += 2)\n\t\t\tle16_add_cpu(&uc[i + 1], -1);\n\tfor (r = 0; uc_word_table[r][0]; r++)\n\t\tuc[uc_word_table[r][0]] = cpu_to_le16(uc_word_table[r][1]);\n\treturn uc;\n}",
          "includes": [
            "#include \"ntfs.h\"",
            "#include \"malloc.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ntfs.h\"\n#include \"malloc.h\"\n\nntfschar *generate_default_upcase(void)\n{\n\tstatic const int uc_run_table[][3] = { /* Start, End, Add */\n\t{0x0061, 0x007B,  -32}, {0x0451, 0x045D, -80}, {0x1F70, 0x1F72,  74},\n\t{0x00E0, 0x00F7,  -32}, {0x045E, 0x0460, -80}, {0x1F72, 0x1F76,  86},\n\t{0x00F8, 0x00FF,  -32}, {0x0561, 0x0587, -48}, {0x1F76, 0x1F78, 100},\n\t{0x0256, 0x0258, -205}, {0x1F00, 0x1F08,   8}, {0x1F78, 0x1F7A, 128},\n\t{0x028A, 0x028C, -217}, {0x1F10, 0x1F16,   8}, {0x1F7A, 0x1F7C, 112},\n\t{0x03AC, 0x03AD,  -38}, {0x1F20, 0x1F28,   8}, {0x1F7C, 0x1F7E, 126},\n\t{0x03AD, 0x03B0,  -37}, {0x1F30, 0x1F38,   8}, {0x1FB0, 0x1FB2,   8},\n\t{0x03B1, 0x03C2,  -32}, {0x1F40, 0x1F46,   8}, {0x1FD0, 0x1FD2,   8},\n\t{0x03C2, 0x03C3,  -31}, {0x1F51, 0x1F52,   8}, {0x1FE0, 0x1FE2,   8},\n\t{0x03C3, 0x03CC,  -32}, {0x1F53, 0x1F54,   8}, {0x1FE5, 0x1FE6,   7},\n\t{0x03CC, 0x03CD,  -64}, {0x1F55, 0x1F56,   8}, {0x2170, 0x2180, -16},\n\t{0x03CD, 0x03CF,  -63}, {0x1F57, 0x1F58,   8}, {0x24D0, 0x24EA, -26},\n\t{0x0430, 0x0450,  -32}, {0x1F60, 0x1F68,   8}, {0xFF41, 0xFF5B, -32},\n\t{0}\n\t};\n\n\tstatic const int uc_dup_table[][2] = { /* Start, End */\n\t{0x0100, 0x012F}, {0x01A0, 0x01A6}, {0x03E2, 0x03EF}, {0x04CB, 0x04CC},\n\t{0x0132, 0x0137}, {0x01B3, 0x01B7}, {0x0460, 0x0481}, {0x04D0, 0x04EB},\n\t{0x0139, 0x0149}, {0x01CD, 0x01DD}, {0x0490, 0x04BF}, {0x04EE, 0x04F5},\n\t{0x014A, 0x0178}, {0x01DE, 0x01EF}, {0x04BF, 0x04BF}, {0x04F8, 0x04F9},\n\t{0x0179, 0x017E}, {0x01F4, 0x01F5}, {0x04C1, 0x04C4}, {0x1E00, 0x1E95},\n\t{0x018B, 0x018B}, {0x01FA, 0x0218}, {0x04C7, 0x04C8}, {0x1EA0, 0x1EF9},\n\t{0}\n\t};\n\n\tstatic const int uc_word_table[][2] = { /* Offset, Value */\n\t{0x00FF, 0x0178}, {0x01AD, 0x01AC}, {0x01F3, 0x01F1}, {0x0269, 0x0196},\n\t{0x0183, 0x0182}, {0x01B0, 0x01AF}, {0x0253, 0x0181}, {0x026F, 0x019C},\n\t{0x0185, 0x0184}, {0x01B9, 0x01B8}, {0x0254, 0x0186}, {0x0272, 0x019D},\n\t{0x0188, 0x0187}, {0x01BD, 0x01BC}, {0x0259, 0x018F}, {0x0275, 0x019F},\n\t{0x018C, 0x018B}, {0x01C6, 0x01C4}, {0x025B, 0x0190}, {0x0283, 0x01A9},\n\t{0x0192, 0x0191}, {0x01C9, 0x01C7}, {0x0260, 0x0193}, {0x0288, 0x01AE},\n\t{0x0199, 0x0198}, {0x01CC, 0x01CA}, {0x0263, 0x0194}, {0x0292, 0x01B7},\n\t{0x01A8, 0x01A7}, {0x01DD, 0x018E}, {0x0268, 0x0197},\n\t{0}\n\t};\n\n\tint i, r;\n\tntfschar *uc;\n\n\tuc = ntfs_malloc_nofs(default_upcase_len * sizeof(ntfschar));\n\tif (!uc)\n\t\treturn uc;\n\tmemset(uc, 0, default_upcase_len * sizeof(ntfschar));\n\t/* Generate the little endian Unicode upcase table used by ntfs. */\n\tfor (i = 0; i < default_upcase_len; i++)\n\t\tuc[i] = cpu_to_le16(i);\n\tfor (r = 0; uc_run_table[r][0]; r++)\n\t\tfor (i = uc_run_table[r][0]; i < uc_run_table[r][1]; i++)\n\t\t\tle16_add_cpu(&uc[i], uc_run_table[r][2]);\n\tfor (r = 0; uc_dup_table[r][0]; r++)\n\t\tfor (i = uc_dup_table[r][0]; i < uc_dup_table[r][1]; i += 2)\n\t\t\tle16_add_cpu(&uc[i + 1], -1);\n\tfor (r = 0; uc_word_table[r][0]; r++)\n\t\tuc[uc_word_table[r][0]] = cpu_to_le16(uc_word_table[r][1]);\n\treturn uc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&ntfs_lock"
          ],
          "line": 2897
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_error",
          "args": [
            "NULL",
            "\"Failed to allocate buffers \"\n\t\t\t\t\t\"for compression engine.\""
          ],
          "line": 2894
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "allocate_compression_buffers",
          "args": [],
          "line": 2892
        },
        "resolved": true,
        "details": {
          "function_name": "allocate_compression_buffers",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/compress.c",
          "lines": "75-83",
          "snippet": "int allocate_compression_buffers(void)\n{\n\tBUG_ON(ntfs_compression_buffer);\n\n\tntfs_compression_buffer = vmalloc(NTFS_MAX_CB_SIZE);\n\tif (!ntfs_compression_buffer)\n\t\treturn -ENOMEM;\n\treturn 0;\n}",
          "includes": [
            "#include \"ntfs.h\"",
            "#include \"debug.h\"",
            "#include \"inode.h\"",
            "#include \"attrib.h\"",
            "#include <linux/slab.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static u8 *ntfs_compression_buffer;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ntfs.h\"\n#include \"debug.h\"\n#include \"inode.h\"\n#include \"attrib.h\"\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n\nstatic u8 *ntfs_compression_buffer;\n\nint allocate_compression_buffers(void)\n{\n\tBUG_ON(ntfs_compression_buffer);\n\n\tntfs_compression_buffer = vmalloc(NTFS_MAX_CB_SIZE);\n\tif (!ntfs_compression_buffer)\n\t\treturn -ENOMEM;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&ntfs_lock"
          ],
          "line": 2886
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_error",
          "args": [
            "sb",
            "\"Failed to load essential metadata.\""
          ],
          "line": 2883
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_read_inode_mount",
          "args": [
            "tmp_ino"
          ],
          "line": 2881
        },
        "resolved": true,
        "details": {
          "function_name": "ntfs_read_inode_mount",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/inode.c",
          "lines": "1776-2196",
          "snippet": "int ntfs_read_inode_mount(struct inode *vi)\n{\n\tVCN next_vcn, last_vcn, highest_vcn;\n\ts64 block;\n\tstruct super_block *sb = vi->i_sb;\n\tntfs_volume *vol = NTFS_SB(sb);\n\tstruct buffer_head *bh;\n\tntfs_inode *ni;\n\tMFT_RECORD *m = NULL;\n\tATTR_RECORD *a;\n\tntfs_attr_search_ctx *ctx;\n\tunsigned int i, nr_blocks;\n\tint err;\n\n\tntfs_debug(\"Entering.\");\n\n\t/* Initialize the ntfs specific part of @vi. */\n\tntfs_init_big_inode(vi);\n\n\tni = NTFS_I(vi);\n\n\t/* Setup the data attribute. It is special as it is mst protected. */\n\tNInoSetNonResident(ni);\n\tNInoSetMstProtected(ni);\n\tNInoSetSparseDisabled(ni);\n\tni->type = AT_DATA;\n\tni->name = NULL;\n\tni->name_len = 0;\n\t/*\n\t * This sets up our little cheat allowing us to reuse the async read io\n\t * completion handler for directories.\n\t */\n\tni->itype.index.block_size = vol->mft_record_size;\n\tni->itype.index.block_size_bits = vol->mft_record_size_bits;\n\n\t/* Very important! Needed to be able to call map_mft_record*(). */\n\tvol->mft_ino = vi;\n\n\t/* Allocate enough memory to read the first mft record. */\n\tif (vol->mft_record_size > 64 * 1024) {\n\t\tntfs_error(sb, \"Unsupported mft record size %i (max 64kiB).\",\n\t\t\t\tvol->mft_record_size);\n\t\tgoto err_out;\n\t}\n\ti = vol->mft_record_size;\n\tif (i < sb->s_blocksize)\n\t\ti = sb->s_blocksize;\n\tm = (MFT_RECORD*)ntfs_malloc_nofs(i);\n\tif (!m) {\n\t\tntfs_error(sb, \"Failed to allocate buffer for $MFT record 0.\");\n\t\tgoto err_out;\n\t}\n\n\t/* Determine the first block of the $MFT/$DATA attribute. */\n\tblock = vol->mft_lcn << vol->cluster_size_bits >>\n\t\t\tsb->s_blocksize_bits;\n\tnr_blocks = vol->mft_record_size >> sb->s_blocksize_bits;\n\tif (!nr_blocks)\n\t\tnr_blocks = 1;\n\n\t/* Load $MFT/$DATA's first mft record. */\n\tfor (i = 0; i < nr_blocks; i++) {\n\t\tbh = sb_bread(sb, block++);\n\t\tif (!bh) {\n\t\t\tntfs_error(sb, \"Device read failed.\");\n\t\t\tgoto err_out;\n\t\t}\n\t\tmemcpy((char*)m + (i << sb->s_blocksize_bits), bh->b_data,\n\t\t\t\tsb->s_blocksize);\n\t\tbrelse(bh);\n\t}\n\n\t/* Apply the mst fixups. */\n\tif (post_read_mst_fixup((NTFS_RECORD*)m, vol->mft_record_size)) {\n\t\t/* FIXME: Try to use the $MFTMirr now. */\n\t\tntfs_error(sb, \"MST fixup failed. $MFT is corrupt.\");\n\t\tgoto err_out;\n\t}\n\n\t/* Need this to sanity check attribute list references to $MFT. */\n\tvi->i_generation = ni->seq_no = le16_to_cpu(m->sequence_number);\n\n\t/* Provides readpage() and sync_page() for map_mft_record(). */\n\tvi->i_mapping->a_ops = &ntfs_mst_aops;\n\n\tctx = ntfs_attr_get_search_ctx(ni, m);\n\tif (!ctx) {\n\t\terr = -ENOMEM;\n\t\tgoto err_out;\n\t}\n\n\t/* Find the attribute list attribute if present. */\n\terr = ntfs_attr_lookup(AT_ATTRIBUTE_LIST, NULL, 0, 0, 0, NULL, 0, ctx);\n\tif (err) {\n\t\tif (unlikely(err != -ENOENT)) {\n\t\t\tntfs_error(sb, \"Failed to lookup attribute list \"\n\t\t\t\t\t\"attribute. You should run chkdsk.\");\n\t\t\tgoto put_err_out;\n\t\t}\n\t} else /* if (!err) */ {\n\t\tATTR_LIST_ENTRY *al_entry, *next_al_entry;\n\t\tu8 *al_end;\n\t\tstatic const char *es = \"  Not allowed.  $MFT is corrupt.  \"\n\t\t\t\t\"You should run chkdsk.\";\n\n\t\tntfs_debug(\"Attribute list attribute found in $MFT.\");\n\t\tNInoSetAttrList(ni);\n\t\ta = ctx->attr;\n\t\tif (a->flags & ATTR_COMPRESSION_MASK) {\n\t\t\tntfs_error(sb, \"Attribute list attribute is \"\n\t\t\t\t\t\"compressed.%s\", es);\n\t\t\tgoto put_err_out;\n\t\t}\n\t\tif (a->flags & ATTR_IS_ENCRYPTED ||\n\t\t\t\ta->flags & ATTR_IS_SPARSE) {\n\t\t\tif (a->non_resident) {\n\t\t\t\tntfs_error(sb, \"Non-resident attribute list \"\n\t\t\t\t\t\t\"attribute is encrypted/\"\n\t\t\t\t\t\t\"sparse.%s\", es);\n\t\t\t\tgoto put_err_out;\n\t\t\t}\n\t\t\tntfs_warning(sb, \"Resident attribute list attribute \"\n\t\t\t\t\t\"in $MFT system file is marked \"\n\t\t\t\t\t\"encrypted/sparse which is not true.  \"\n\t\t\t\t\t\"However, Windows allows this and \"\n\t\t\t\t\t\"chkdsk does not detect or correct it \"\n\t\t\t\t\t\"so we will just ignore the invalid \"\n\t\t\t\t\t\"flags and pretend they are not set.\");\n\t\t}\n\t\t/* Now allocate memory for the attribute list. */\n\t\tni->attr_list_size = (u32)ntfs_attr_size(a);\n\t\tni->attr_list = ntfs_malloc_nofs(ni->attr_list_size);\n\t\tif (!ni->attr_list) {\n\t\t\tntfs_error(sb, \"Not enough memory to allocate buffer \"\n\t\t\t\t\t\"for attribute list.\");\n\t\t\tgoto put_err_out;\n\t\t}\n\t\tif (a->non_resident) {\n\t\t\tNInoSetAttrListNonResident(ni);\n\t\t\tif (a->data.non_resident.lowest_vcn) {\n\t\t\t\tntfs_error(sb, \"Attribute list has non zero \"\n\t\t\t\t\t\t\"lowest_vcn. $MFT is corrupt. \"\n\t\t\t\t\t\t\"You should run chkdsk.\");\n\t\t\t\tgoto put_err_out;\n\t\t\t}\n\t\t\t/* Setup the runlist. */\n\t\t\tni->attr_list_rl.rl = ntfs_mapping_pairs_decompress(vol,\n\t\t\t\t\ta, NULL);\n\t\t\tif (IS_ERR(ni->attr_list_rl.rl)) {\n\t\t\t\terr = PTR_ERR(ni->attr_list_rl.rl);\n\t\t\t\tni->attr_list_rl.rl = NULL;\n\t\t\t\tntfs_error(sb, \"Mapping pairs decompression \"\n\t\t\t\t\t\t\"failed with error code %i.\",\n\t\t\t\t\t\t-err);\n\t\t\t\tgoto put_err_out;\n\t\t\t}\n\t\t\t/* Now load the attribute list. */\n\t\t\tif ((err = load_attribute_list(vol, &ni->attr_list_rl,\n\t\t\t\t\tni->attr_list, ni->attr_list_size,\n\t\t\t\t\tsle64_to_cpu(a->data.\n\t\t\t\t\tnon_resident.initialized_size)))) {\n\t\t\t\tntfs_error(sb, \"Failed to load attribute list \"\n\t\t\t\t\t\t\"attribute with error code %i.\",\n\t\t\t\t\t\t-err);\n\t\t\t\tgoto put_err_out;\n\t\t\t}\n\t\t} else /* if (!ctx.attr->non_resident) */ {\n\t\t\tif ((u8*)a + le16_to_cpu(\n\t\t\t\t\ta->data.resident.value_offset) +\n\t\t\t\t\tle32_to_cpu(\n\t\t\t\t\ta->data.resident.value_length) >\n\t\t\t\t\t(u8*)ctx->mrec + vol->mft_record_size) {\n\t\t\t\tntfs_error(sb, \"Corrupt attribute list \"\n\t\t\t\t\t\t\"attribute.\");\n\t\t\t\tgoto put_err_out;\n\t\t\t}\n\t\t\t/* Now copy the attribute list. */\n\t\t\tmemcpy(ni->attr_list, (u8*)a + le16_to_cpu(\n\t\t\t\t\ta->data.resident.value_offset),\n\t\t\t\t\tle32_to_cpu(\n\t\t\t\t\ta->data.resident.value_length));\n\t\t}\n\t\t/* The attribute list is now setup in memory. */\n\t\t/*\n\t\t * FIXME: I don't know if this case is actually possible.\n\t\t * According to logic it is not possible but I have seen too\n\t\t * many weird things in MS software to rely on logic... Thus we\n\t\t * perform a manual search and make sure the first $MFT/$DATA\n\t\t * extent is in the base inode. If it is not we abort with an\n\t\t * error and if we ever see a report of this error we will need\n\t\t * to do some magic in order to have the necessary mft record\n\t\t * loaded and in the right place in the page cache. But\n\t\t * hopefully logic will prevail and this never happens...\n\t\t */\n\t\tal_entry = (ATTR_LIST_ENTRY*)ni->attr_list;\n\t\tal_end = (u8*)al_entry + ni->attr_list_size;\n\t\tfor (;; al_entry = next_al_entry) {\n\t\t\t/* Out of bounds check. */\n\t\t\tif ((u8*)al_entry < ni->attr_list ||\n\t\t\t\t\t(u8*)al_entry > al_end)\n\t\t\t\tgoto em_put_err_out;\n\t\t\t/* Catch the end of the attribute list. */\n\t\t\tif ((u8*)al_entry == al_end)\n\t\t\t\tgoto em_put_err_out;\n\t\t\tif (!al_entry->length)\n\t\t\t\tgoto em_put_err_out;\n\t\t\tif ((u8*)al_entry + 6 > al_end || (u8*)al_entry +\n\t\t\t\t\tle16_to_cpu(al_entry->length) > al_end)\n\t\t\t\tgoto em_put_err_out;\n\t\t\tnext_al_entry = (ATTR_LIST_ENTRY*)((u8*)al_entry +\n\t\t\t\t\tle16_to_cpu(al_entry->length));\n\t\t\tif (le32_to_cpu(al_entry->type) > le32_to_cpu(AT_DATA))\n\t\t\t\tgoto em_put_err_out;\n\t\t\tif (AT_DATA != al_entry->type)\n\t\t\t\tcontinue;\n\t\t\t/* We want an unnamed attribute. */\n\t\t\tif (al_entry->name_length)\n\t\t\t\tgoto em_put_err_out;\n\t\t\t/* Want the first entry, i.e. lowest_vcn == 0. */\n\t\t\tif (al_entry->lowest_vcn)\n\t\t\t\tgoto em_put_err_out;\n\t\t\t/* First entry has to be in the base mft record. */\n\t\t\tif (MREF_LE(al_entry->mft_reference) != vi->i_ino) {\n\t\t\t\t/* MFT references do not match, logic fails. */\n\t\t\t\tntfs_error(sb, \"BUG: The first $DATA extent \"\n\t\t\t\t\t\t\"of $MFT is not in the base \"\n\t\t\t\t\t\t\"mft record. Please report \"\n\t\t\t\t\t\t\"you saw this message to \"\n\t\t\t\t\t\t\"linux-ntfs-dev@lists.\"\n\t\t\t\t\t\t\"sourceforge.net\");\n\t\t\t\tgoto put_err_out;\n\t\t\t} else {\n\t\t\t\t/* Sequence numbers must match. */\n\t\t\t\tif (MSEQNO_LE(al_entry->mft_reference) !=\n\t\t\t\t\t\tni->seq_no)\n\t\t\t\t\tgoto em_put_err_out;\n\t\t\t\t/* Got it. All is ok. We can stop now. */\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tntfs_attr_reinit_search_ctx(ctx);\n\n\t/* Now load all attribute extents. */\n\ta = NULL;\n\tnext_vcn = last_vcn = highest_vcn = 0;\n\twhile (!(err = ntfs_attr_lookup(AT_DATA, NULL, 0, 0, next_vcn, NULL, 0,\n\t\t\tctx))) {\n\t\trunlist_element *nrl;\n\n\t\t/* Cache the current attribute. */\n\t\ta = ctx->attr;\n\t\t/* $MFT must be non-resident. */\n\t\tif (!a->non_resident) {\n\t\t\tntfs_error(sb, \"$MFT must be non-resident but a \"\n\t\t\t\t\t\"resident extent was found. $MFT is \"\n\t\t\t\t\t\"corrupt. Run chkdsk.\");\n\t\t\tgoto put_err_out;\n\t\t}\n\t\t/* $MFT must be uncompressed and unencrypted. */\n\t\tif (a->flags & ATTR_COMPRESSION_MASK ||\n\t\t\t\ta->flags & ATTR_IS_ENCRYPTED ||\n\t\t\t\ta->flags & ATTR_IS_SPARSE) {\n\t\t\tntfs_error(sb, \"$MFT must be uncompressed, \"\n\t\t\t\t\t\"non-sparse, and unencrypted but a \"\n\t\t\t\t\t\"compressed/sparse/encrypted extent \"\n\t\t\t\t\t\"was found. $MFT is corrupt. Run \"\n\t\t\t\t\t\"chkdsk.\");\n\t\t\tgoto put_err_out;\n\t\t}\n\t\t/*\n\t\t * Decompress the mapping pairs array of this extent and merge\n\t\t * the result into the existing runlist. No need for locking\n\t\t * as we have exclusive access to the inode at this time and we\n\t\t * are a mount in progress task, too.\n\t\t */\n\t\tnrl = ntfs_mapping_pairs_decompress(vol, a, ni->runlist.rl);\n\t\tif (IS_ERR(nrl)) {\n\t\t\tntfs_error(sb, \"ntfs_mapping_pairs_decompress() \"\n\t\t\t\t\t\"failed with error code %ld.  $MFT is \"\n\t\t\t\t\t\"corrupt.\", PTR_ERR(nrl));\n\t\t\tgoto put_err_out;\n\t\t}\n\t\tni->runlist.rl = nrl;\n\n\t\t/* Are we in the first extent? */\n\t\tif (!next_vcn) {\n\t\t\tif (a->data.non_resident.lowest_vcn) {\n\t\t\t\tntfs_error(sb, \"First extent of $DATA \"\n\t\t\t\t\t\t\"attribute has non zero \"\n\t\t\t\t\t\t\"lowest_vcn. $MFT is corrupt. \"\n\t\t\t\t\t\t\"You should run chkdsk.\");\n\t\t\t\tgoto put_err_out;\n\t\t\t}\n\t\t\t/* Get the last vcn in the $DATA attribute. */\n\t\t\tlast_vcn = sle64_to_cpu(\n\t\t\t\t\ta->data.non_resident.allocated_size)\n\t\t\t\t\t>> vol->cluster_size_bits;\n\t\t\t/* Fill in the inode size. */\n\t\t\tvi->i_size = sle64_to_cpu(\n\t\t\t\t\ta->data.non_resident.data_size);\n\t\t\tni->initialized_size = sle64_to_cpu(\n\t\t\t\t\ta->data.non_resident.initialized_size);\n\t\t\tni->allocated_size = sle64_to_cpu(\n\t\t\t\t\ta->data.non_resident.allocated_size);\n\t\t\t/*\n\t\t\t * Verify the number of mft records does not exceed\n\t\t\t * 2^32 - 1.\n\t\t\t */\n\t\t\tif ((vi->i_size >> vol->mft_record_size_bits) >=\n\t\t\t\t\t(1ULL << 32)) {\n\t\t\t\tntfs_error(sb, \"$MFT is too big! Aborting.\");\n\t\t\t\tgoto put_err_out;\n\t\t\t}\n\t\t\t/*\n\t\t\t * We have got the first extent of the runlist for\n\t\t\t * $MFT which means it is now relatively safe to call\n\t\t\t * the normal ntfs_read_inode() function.\n\t\t\t * Complete reading the inode, this will actually\n\t\t\t * re-read the mft record for $MFT, this time entering\n\t\t\t * it into the page cache with which we complete the\n\t\t\t * kick start of the volume. It should be safe to do\n\t\t\t * this now as the first extent of $MFT/$DATA is\n\t\t\t * already known and we would hope that we don't need\n\t\t\t * further extents in order to find the other\n\t\t\t * attributes belonging to $MFT. Only time will tell if\n\t\t\t * this is really the case. If not we will have to play\n\t\t\t * magic at this point, possibly duplicating a lot of\n\t\t\t * ntfs_read_inode() at this point. We will need to\n\t\t\t * ensure we do enough of its work to be able to call\n\t\t\t * ntfs_read_inode() on extents of $MFT/$DATA. But lets\n\t\t\t * hope this never happens...\n\t\t\t */\n\t\t\tntfs_read_locked_inode(vi);\n\t\t\tif (is_bad_inode(vi)) {\n\t\t\t\tntfs_error(sb, \"ntfs_read_inode() of $MFT \"\n\t\t\t\t\t\t\"failed. BUG or corrupt $MFT. \"\n\t\t\t\t\t\t\"Run chkdsk and if no errors \"\n\t\t\t\t\t\t\"are found, please report you \"\n\t\t\t\t\t\t\"saw this message to \"\n\t\t\t\t\t\t\"linux-ntfs-dev@lists.\"\n\t\t\t\t\t\t\"sourceforge.net\");\n\t\t\t\tntfs_attr_put_search_ctx(ctx);\n\t\t\t\t/* Revert to the safe super operations. */\n\t\t\t\tntfs_free(m);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\t/*\n\t\t\t * Re-initialize some specifics about $MFT's inode as\n\t\t\t * ntfs_read_inode() will have set up the default ones.\n\t\t\t */\n\t\t\t/* Set uid and gid to root. */\n\t\t\tvi->i_uid = GLOBAL_ROOT_UID;\n\t\t\tvi->i_gid = GLOBAL_ROOT_GID;\n\t\t\t/* Regular file. No access for anyone. */\n\t\t\tvi->i_mode = S_IFREG;\n\t\t\t/* No VFS initiated operations allowed for $MFT. */\n\t\t\tvi->i_op = &ntfs_empty_inode_ops;\n\t\t\tvi->i_fop = &ntfs_empty_file_ops;\n\t\t}\n\n\t\t/* Get the lowest vcn for the next extent. */\n\t\thighest_vcn = sle64_to_cpu(a->data.non_resident.highest_vcn);\n\t\tnext_vcn = highest_vcn + 1;\n\n\t\t/* Only one extent or error, which we catch below. */\n\t\tif (next_vcn <= 0)\n\t\t\tbreak;\n\n\t\t/* Avoid endless loops due to corruption. */\n\t\tif (next_vcn < sle64_to_cpu(\n\t\t\t\ta->data.non_resident.lowest_vcn)) {\n\t\t\tntfs_error(sb, \"$MFT has corrupt attribute list \"\n\t\t\t\t\t\"attribute. Run chkdsk.\");\n\t\t\tgoto put_err_out;\n\t\t}\n\t}\n\tif (err != -ENOENT) {\n\t\tntfs_error(sb, \"Failed to lookup $MFT/$DATA attribute extent. \"\n\t\t\t\t\"$MFT is corrupt. Run chkdsk.\");\n\t\tgoto put_err_out;\n\t}\n\tif (!a) {\n\t\tntfs_error(sb, \"$MFT/$DATA attribute not found. $MFT is \"\n\t\t\t\t\"corrupt. Run chkdsk.\");\n\t\tgoto put_err_out;\n\t}\n\tif (highest_vcn && highest_vcn != last_vcn - 1) {\n\t\tntfs_error(sb, \"Failed to load the complete runlist for \"\n\t\t\t\t\"$MFT/$DATA. Driver bug or corrupt $MFT. \"\n\t\t\t\t\"Run chkdsk.\");\n\t\tntfs_debug(\"highest_vcn = 0x%llx, last_vcn - 1 = 0x%llx\",\n\t\t\t\t(unsigned long long)highest_vcn,\n\t\t\t\t(unsigned long long)last_vcn - 1);\n\t\tgoto put_err_out;\n\t}\n\tntfs_attr_put_search_ctx(ctx);\n\tntfs_debug(\"Done.\");\n\tntfs_free(m);\n\n\t/*\n\t * Split the locking rules of the MFT inode from the\n\t * locking rules of other inodes:\n\t */\n\tlockdep_set_class(&ni->runlist.lock, &mft_ni_runlist_lock_key);\n\tlockdep_set_class(&ni->mrec_lock, &mft_ni_mrec_lock_key);\n\n\treturn 0;\n\nem_put_err_out:\n\tntfs_error(sb, \"Couldn't find first extent of $DATA attribute in \"\n\t\t\t\"attribute list. $MFT is corrupt. Run chkdsk.\");\nput_err_out:\n\tntfs_attr_put_search_ctx(ctx);\nerr_out:\n\tntfs_error(sb, \"Failed. Marking inode as bad.\");\n\tmake_bad_inode(vi);\n\tntfs_free(m);\n\treturn -1;\n}",
          "includes": [
            "#include \"ntfs.h\"",
            "#include \"time.h\"",
            "#include \"mft.h\"",
            "#include \"malloc.h\"",
            "#include \"lcnalloc.h\"",
            "#include \"inode.h\"",
            "#include \"debug.h\"",
            "#include \"dir.h\"",
            "#include \"bitmap.h\"",
            "#include \"attrib.h\"",
            "#include \"aops.h\"",
            "#include <linux/aio.h>",
            "#include <linux/log2.h>",
            "#include <linux/slab.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mutex.h>",
            "#include <linux/mount.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ntfs_read_locked_inode(struct inode *vi);",
            "static int ntfs_read_locked_attr_inode(struct inode *base_vi, struct inode *vi);",
            "static int ntfs_read_locked_index_inode(struct inode *base_vi,\n\t\tstruct inode *vi);",
            "static struct lock_class_key mft_ni_runlist_lock_key, mft_ni_mrec_lock_key;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ntfs.h\"\n#include \"time.h\"\n#include \"mft.h\"\n#include \"malloc.h\"\n#include \"lcnalloc.h\"\n#include \"inode.h\"\n#include \"debug.h\"\n#include \"dir.h\"\n#include \"bitmap.h\"\n#include \"attrib.h\"\n#include \"aops.h\"\n#include <linux/aio.h>\n#include <linux/log2.h>\n#include <linux/slab.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/mutex.h>\n#include <linux/mount.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n\nstatic int ntfs_read_locked_inode(struct inode *vi);\nstatic int ntfs_read_locked_attr_inode(struct inode *base_vi, struct inode *vi);\nstatic int ntfs_read_locked_index_inode(struct inode *base_vi,\n\t\tstruct inode *vi);\nstatic struct lock_class_key mft_ni_runlist_lock_key, mft_ni_mrec_lock_key;\n\nint ntfs_read_inode_mount(struct inode *vi)\n{\n\tVCN next_vcn, last_vcn, highest_vcn;\n\ts64 block;\n\tstruct super_block *sb = vi->i_sb;\n\tntfs_volume *vol = NTFS_SB(sb);\n\tstruct buffer_head *bh;\n\tntfs_inode *ni;\n\tMFT_RECORD *m = NULL;\n\tATTR_RECORD *a;\n\tntfs_attr_search_ctx *ctx;\n\tunsigned int i, nr_blocks;\n\tint err;\n\n\tntfs_debug(\"Entering.\");\n\n\t/* Initialize the ntfs specific part of @vi. */\n\tntfs_init_big_inode(vi);\n\n\tni = NTFS_I(vi);\n\n\t/* Setup the data attribute. It is special as it is mst protected. */\n\tNInoSetNonResident(ni);\n\tNInoSetMstProtected(ni);\n\tNInoSetSparseDisabled(ni);\n\tni->type = AT_DATA;\n\tni->name = NULL;\n\tni->name_len = 0;\n\t/*\n\t * This sets up our little cheat allowing us to reuse the async read io\n\t * completion handler for directories.\n\t */\n\tni->itype.index.block_size = vol->mft_record_size;\n\tni->itype.index.block_size_bits = vol->mft_record_size_bits;\n\n\t/* Very important! Needed to be able to call map_mft_record*(). */\n\tvol->mft_ino = vi;\n\n\t/* Allocate enough memory to read the first mft record. */\n\tif (vol->mft_record_size > 64 * 1024) {\n\t\tntfs_error(sb, \"Unsupported mft record size %i (max 64kiB).\",\n\t\t\t\tvol->mft_record_size);\n\t\tgoto err_out;\n\t}\n\ti = vol->mft_record_size;\n\tif (i < sb->s_blocksize)\n\t\ti = sb->s_blocksize;\n\tm = (MFT_RECORD*)ntfs_malloc_nofs(i);\n\tif (!m) {\n\t\tntfs_error(sb, \"Failed to allocate buffer for $MFT record 0.\");\n\t\tgoto err_out;\n\t}\n\n\t/* Determine the first block of the $MFT/$DATA attribute. */\n\tblock = vol->mft_lcn << vol->cluster_size_bits >>\n\t\t\tsb->s_blocksize_bits;\n\tnr_blocks = vol->mft_record_size >> sb->s_blocksize_bits;\n\tif (!nr_blocks)\n\t\tnr_blocks = 1;\n\n\t/* Load $MFT/$DATA's first mft record. */\n\tfor (i = 0; i < nr_blocks; i++) {\n\t\tbh = sb_bread(sb, block++);\n\t\tif (!bh) {\n\t\t\tntfs_error(sb, \"Device read failed.\");\n\t\t\tgoto err_out;\n\t\t}\n\t\tmemcpy((char*)m + (i << sb->s_blocksize_bits), bh->b_data,\n\t\t\t\tsb->s_blocksize);\n\t\tbrelse(bh);\n\t}\n\n\t/* Apply the mst fixups. */\n\tif (post_read_mst_fixup((NTFS_RECORD*)m, vol->mft_record_size)) {\n\t\t/* FIXME: Try to use the $MFTMirr now. */\n\t\tntfs_error(sb, \"MST fixup failed. $MFT is corrupt.\");\n\t\tgoto err_out;\n\t}\n\n\t/* Need this to sanity check attribute list references to $MFT. */\n\tvi->i_generation = ni->seq_no = le16_to_cpu(m->sequence_number);\n\n\t/* Provides readpage() and sync_page() for map_mft_record(). */\n\tvi->i_mapping->a_ops = &ntfs_mst_aops;\n\n\tctx = ntfs_attr_get_search_ctx(ni, m);\n\tif (!ctx) {\n\t\terr = -ENOMEM;\n\t\tgoto err_out;\n\t}\n\n\t/* Find the attribute list attribute if present. */\n\terr = ntfs_attr_lookup(AT_ATTRIBUTE_LIST, NULL, 0, 0, 0, NULL, 0, ctx);\n\tif (err) {\n\t\tif (unlikely(err != -ENOENT)) {\n\t\t\tntfs_error(sb, \"Failed to lookup attribute list \"\n\t\t\t\t\t\"attribute. You should run chkdsk.\");\n\t\t\tgoto put_err_out;\n\t\t}\n\t} else /* if (!err) */ {\n\t\tATTR_LIST_ENTRY *al_entry, *next_al_entry;\n\t\tu8 *al_end;\n\t\tstatic const char *es = \"  Not allowed.  $MFT is corrupt.  \"\n\t\t\t\t\"You should run chkdsk.\";\n\n\t\tntfs_debug(\"Attribute list attribute found in $MFT.\");\n\t\tNInoSetAttrList(ni);\n\t\ta = ctx->attr;\n\t\tif (a->flags & ATTR_COMPRESSION_MASK) {\n\t\t\tntfs_error(sb, \"Attribute list attribute is \"\n\t\t\t\t\t\"compressed.%s\", es);\n\t\t\tgoto put_err_out;\n\t\t}\n\t\tif (a->flags & ATTR_IS_ENCRYPTED ||\n\t\t\t\ta->flags & ATTR_IS_SPARSE) {\n\t\t\tif (a->non_resident) {\n\t\t\t\tntfs_error(sb, \"Non-resident attribute list \"\n\t\t\t\t\t\t\"attribute is encrypted/\"\n\t\t\t\t\t\t\"sparse.%s\", es);\n\t\t\t\tgoto put_err_out;\n\t\t\t}\n\t\t\tntfs_warning(sb, \"Resident attribute list attribute \"\n\t\t\t\t\t\"in $MFT system file is marked \"\n\t\t\t\t\t\"encrypted/sparse which is not true.  \"\n\t\t\t\t\t\"However, Windows allows this and \"\n\t\t\t\t\t\"chkdsk does not detect or correct it \"\n\t\t\t\t\t\"so we will just ignore the invalid \"\n\t\t\t\t\t\"flags and pretend they are not set.\");\n\t\t}\n\t\t/* Now allocate memory for the attribute list. */\n\t\tni->attr_list_size = (u32)ntfs_attr_size(a);\n\t\tni->attr_list = ntfs_malloc_nofs(ni->attr_list_size);\n\t\tif (!ni->attr_list) {\n\t\t\tntfs_error(sb, \"Not enough memory to allocate buffer \"\n\t\t\t\t\t\"for attribute list.\");\n\t\t\tgoto put_err_out;\n\t\t}\n\t\tif (a->non_resident) {\n\t\t\tNInoSetAttrListNonResident(ni);\n\t\t\tif (a->data.non_resident.lowest_vcn) {\n\t\t\t\tntfs_error(sb, \"Attribute list has non zero \"\n\t\t\t\t\t\t\"lowest_vcn. $MFT is corrupt. \"\n\t\t\t\t\t\t\"You should run chkdsk.\");\n\t\t\t\tgoto put_err_out;\n\t\t\t}\n\t\t\t/* Setup the runlist. */\n\t\t\tni->attr_list_rl.rl = ntfs_mapping_pairs_decompress(vol,\n\t\t\t\t\ta, NULL);\n\t\t\tif (IS_ERR(ni->attr_list_rl.rl)) {\n\t\t\t\terr = PTR_ERR(ni->attr_list_rl.rl);\n\t\t\t\tni->attr_list_rl.rl = NULL;\n\t\t\t\tntfs_error(sb, \"Mapping pairs decompression \"\n\t\t\t\t\t\t\"failed with error code %i.\",\n\t\t\t\t\t\t-err);\n\t\t\t\tgoto put_err_out;\n\t\t\t}\n\t\t\t/* Now load the attribute list. */\n\t\t\tif ((err = load_attribute_list(vol, &ni->attr_list_rl,\n\t\t\t\t\tni->attr_list, ni->attr_list_size,\n\t\t\t\t\tsle64_to_cpu(a->data.\n\t\t\t\t\tnon_resident.initialized_size)))) {\n\t\t\t\tntfs_error(sb, \"Failed to load attribute list \"\n\t\t\t\t\t\t\"attribute with error code %i.\",\n\t\t\t\t\t\t-err);\n\t\t\t\tgoto put_err_out;\n\t\t\t}\n\t\t} else /* if (!ctx.attr->non_resident) */ {\n\t\t\tif ((u8*)a + le16_to_cpu(\n\t\t\t\t\ta->data.resident.value_offset) +\n\t\t\t\t\tle32_to_cpu(\n\t\t\t\t\ta->data.resident.value_length) >\n\t\t\t\t\t(u8*)ctx->mrec + vol->mft_record_size) {\n\t\t\t\tntfs_error(sb, \"Corrupt attribute list \"\n\t\t\t\t\t\t\"attribute.\");\n\t\t\t\tgoto put_err_out;\n\t\t\t}\n\t\t\t/* Now copy the attribute list. */\n\t\t\tmemcpy(ni->attr_list, (u8*)a + le16_to_cpu(\n\t\t\t\t\ta->data.resident.value_offset),\n\t\t\t\t\tle32_to_cpu(\n\t\t\t\t\ta->data.resident.value_length));\n\t\t}\n\t\t/* The attribute list is now setup in memory. */\n\t\t/*\n\t\t * FIXME: I don't know if this case is actually possible.\n\t\t * According to logic it is not possible but I have seen too\n\t\t * many weird things in MS software to rely on logic... Thus we\n\t\t * perform a manual search and make sure the first $MFT/$DATA\n\t\t * extent is in the base inode. If it is not we abort with an\n\t\t * error and if we ever see a report of this error we will need\n\t\t * to do some magic in order to have the necessary mft record\n\t\t * loaded and in the right place in the page cache. But\n\t\t * hopefully logic will prevail and this never happens...\n\t\t */\n\t\tal_entry = (ATTR_LIST_ENTRY*)ni->attr_list;\n\t\tal_end = (u8*)al_entry + ni->attr_list_size;\n\t\tfor (;; al_entry = next_al_entry) {\n\t\t\t/* Out of bounds check. */\n\t\t\tif ((u8*)al_entry < ni->attr_list ||\n\t\t\t\t\t(u8*)al_entry > al_end)\n\t\t\t\tgoto em_put_err_out;\n\t\t\t/* Catch the end of the attribute list. */\n\t\t\tif ((u8*)al_entry == al_end)\n\t\t\t\tgoto em_put_err_out;\n\t\t\tif (!al_entry->length)\n\t\t\t\tgoto em_put_err_out;\n\t\t\tif ((u8*)al_entry + 6 > al_end || (u8*)al_entry +\n\t\t\t\t\tle16_to_cpu(al_entry->length) > al_end)\n\t\t\t\tgoto em_put_err_out;\n\t\t\tnext_al_entry = (ATTR_LIST_ENTRY*)((u8*)al_entry +\n\t\t\t\t\tle16_to_cpu(al_entry->length));\n\t\t\tif (le32_to_cpu(al_entry->type) > le32_to_cpu(AT_DATA))\n\t\t\t\tgoto em_put_err_out;\n\t\t\tif (AT_DATA != al_entry->type)\n\t\t\t\tcontinue;\n\t\t\t/* We want an unnamed attribute. */\n\t\t\tif (al_entry->name_length)\n\t\t\t\tgoto em_put_err_out;\n\t\t\t/* Want the first entry, i.e. lowest_vcn == 0. */\n\t\t\tif (al_entry->lowest_vcn)\n\t\t\t\tgoto em_put_err_out;\n\t\t\t/* First entry has to be in the base mft record. */\n\t\t\tif (MREF_LE(al_entry->mft_reference) != vi->i_ino) {\n\t\t\t\t/* MFT references do not match, logic fails. */\n\t\t\t\tntfs_error(sb, \"BUG: The first $DATA extent \"\n\t\t\t\t\t\t\"of $MFT is not in the base \"\n\t\t\t\t\t\t\"mft record. Please report \"\n\t\t\t\t\t\t\"you saw this message to \"\n\t\t\t\t\t\t\"linux-ntfs-dev@lists.\"\n\t\t\t\t\t\t\"sourceforge.net\");\n\t\t\t\tgoto put_err_out;\n\t\t\t} else {\n\t\t\t\t/* Sequence numbers must match. */\n\t\t\t\tif (MSEQNO_LE(al_entry->mft_reference) !=\n\t\t\t\t\t\tni->seq_no)\n\t\t\t\t\tgoto em_put_err_out;\n\t\t\t\t/* Got it. All is ok. We can stop now. */\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tntfs_attr_reinit_search_ctx(ctx);\n\n\t/* Now load all attribute extents. */\n\ta = NULL;\n\tnext_vcn = last_vcn = highest_vcn = 0;\n\twhile (!(err = ntfs_attr_lookup(AT_DATA, NULL, 0, 0, next_vcn, NULL, 0,\n\t\t\tctx))) {\n\t\trunlist_element *nrl;\n\n\t\t/* Cache the current attribute. */\n\t\ta = ctx->attr;\n\t\t/* $MFT must be non-resident. */\n\t\tif (!a->non_resident) {\n\t\t\tntfs_error(sb, \"$MFT must be non-resident but a \"\n\t\t\t\t\t\"resident extent was found. $MFT is \"\n\t\t\t\t\t\"corrupt. Run chkdsk.\");\n\t\t\tgoto put_err_out;\n\t\t}\n\t\t/* $MFT must be uncompressed and unencrypted. */\n\t\tif (a->flags & ATTR_COMPRESSION_MASK ||\n\t\t\t\ta->flags & ATTR_IS_ENCRYPTED ||\n\t\t\t\ta->flags & ATTR_IS_SPARSE) {\n\t\t\tntfs_error(sb, \"$MFT must be uncompressed, \"\n\t\t\t\t\t\"non-sparse, and unencrypted but a \"\n\t\t\t\t\t\"compressed/sparse/encrypted extent \"\n\t\t\t\t\t\"was found. $MFT is corrupt. Run \"\n\t\t\t\t\t\"chkdsk.\");\n\t\t\tgoto put_err_out;\n\t\t}\n\t\t/*\n\t\t * Decompress the mapping pairs array of this extent and merge\n\t\t * the result into the existing runlist. No need for locking\n\t\t * as we have exclusive access to the inode at this time and we\n\t\t * are a mount in progress task, too.\n\t\t */\n\t\tnrl = ntfs_mapping_pairs_decompress(vol, a, ni->runlist.rl);\n\t\tif (IS_ERR(nrl)) {\n\t\t\tntfs_error(sb, \"ntfs_mapping_pairs_decompress() \"\n\t\t\t\t\t\"failed with error code %ld.  $MFT is \"\n\t\t\t\t\t\"corrupt.\", PTR_ERR(nrl));\n\t\t\tgoto put_err_out;\n\t\t}\n\t\tni->runlist.rl = nrl;\n\n\t\t/* Are we in the first extent? */\n\t\tif (!next_vcn) {\n\t\t\tif (a->data.non_resident.lowest_vcn) {\n\t\t\t\tntfs_error(sb, \"First extent of $DATA \"\n\t\t\t\t\t\t\"attribute has non zero \"\n\t\t\t\t\t\t\"lowest_vcn. $MFT is corrupt. \"\n\t\t\t\t\t\t\"You should run chkdsk.\");\n\t\t\t\tgoto put_err_out;\n\t\t\t}\n\t\t\t/* Get the last vcn in the $DATA attribute. */\n\t\t\tlast_vcn = sle64_to_cpu(\n\t\t\t\t\ta->data.non_resident.allocated_size)\n\t\t\t\t\t>> vol->cluster_size_bits;\n\t\t\t/* Fill in the inode size. */\n\t\t\tvi->i_size = sle64_to_cpu(\n\t\t\t\t\ta->data.non_resident.data_size);\n\t\t\tni->initialized_size = sle64_to_cpu(\n\t\t\t\t\ta->data.non_resident.initialized_size);\n\t\t\tni->allocated_size = sle64_to_cpu(\n\t\t\t\t\ta->data.non_resident.allocated_size);\n\t\t\t/*\n\t\t\t * Verify the number of mft records does not exceed\n\t\t\t * 2^32 - 1.\n\t\t\t */\n\t\t\tif ((vi->i_size >> vol->mft_record_size_bits) >=\n\t\t\t\t\t(1ULL << 32)) {\n\t\t\t\tntfs_error(sb, \"$MFT is too big! Aborting.\");\n\t\t\t\tgoto put_err_out;\n\t\t\t}\n\t\t\t/*\n\t\t\t * We have got the first extent of the runlist for\n\t\t\t * $MFT which means it is now relatively safe to call\n\t\t\t * the normal ntfs_read_inode() function.\n\t\t\t * Complete reading the inode, this will actually\n\t\t\t * re-read the mft record for $MFT, this time entering\n\t\t\t * it into the page cache with which we complete the\n\t\t\t * kick start of the volume. It should be safe to do\n\t\t\t * this now as the first extent of $MFT/$DATA is\n\t\t\t * already known and we would hope that we don't need\n\t\t\t * further extents in order to find the other\n\t\t\t * attributes belonging to $MFT. Only time will tell if\n\t\t\t * this is really the case. If not we will have to play\n\t\t\t * magic at this point, possibly duplicating a lot of\n\t\t\t * ntfs_read_inode() at this point. We will need to\n\t\t\t * ensure we do enough of its work to be able to call\n\t\t\t * ntfs_read_inode() on extents of $MFT/$DATA. But lets\n\t\t\t * hope this never happens...\n\t\t\t */\n\t\t\tntfs_read_locked_inode(vi);\n\t\t\tif (is_bad_inode(vi)) {\n\t\t\t\tntfs_error(sb, \"ntfs_read_inode() of $MFT \"\n\t\t\t\t\t\t\"failed. BUG or corrupt $MFT. \"\n\t\t\t\t\t\t\"Run chkdsk and if no errors \"\n\t\t\t\t\t\t\"are found, please report you \"\n\t\t\t\t\t\t\"saw this message to \"\n\t\t\t\t\t\t\"linux-ntfs-dev@lists.\"\n\t\t\t\t\t\t\"sourceforge.net\");\n\t\t\t\tntfs_attr_put_search_ctx(ctx);\n\t\t\t\t/* Revert to the safe super operations. */\n\t\t\t\tntfs_free(m);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\t/*\n\t\t\t * Re-initialize some specifics about $MFT's inode as\n\t\t\t * ntfs_read_inode() will have set up the default ones.\n\t\t\t */\n\t\t\t/* Set uid and gid to root. */\n\t\t\tvi->i_uid = GLOBAL_ROOT_UID;\n\t\t\tvi->i_gid = GLOBAL_ROOT_GID;\n\t\t\t/* Regular file. No access for anyone. */\n\t\t\tvi->i_mode = S_IFREG;\n\t\t\t/* No VFS initiated operations allowed for $MFT. */\n\t\t\tvi->i_op = &ntfs_empty_inode_ops;\n\t\t\tvi->i_fop = &ntfs_empty_file_ops;\n\t\t}\n\n\t\t/* Get the lowest vcn for the next extent. */\n\t\thighest_vcn = sle64_to_cpu(a->data.non_resident.highest_vcn);\n\t\tnext_vcn = highest_vcn + 1;\n\n\t\t/* Only one extent or error, which we catch below. */\n\t\tif (next_vcn <= 0)\n\t\t\tbreak;\n\n\t\t/* Avoid endless loops due to corruption. */\n\t\tif (next_vcn < sle64_to_cpu(\n\t\t\t\ta->data.non_resident.lowest_vcn)) {\n\t\t\tntfs_error(sb, \"$MFT has corrupt attribute list \"\n\t\t\t\t\t\"attribute. Run chkdsk.\");\n\t\t\tgoto put_err_out;\n\t\t}\n\t}\n\tif (err != -ENOENT) {\n\t\tntfs_error(sb, \"Failed to lookup $MFT/$DATA attribute extent. \"\n\t\t\t\t\"$MFT is corrupt. Run chkdsk.\");\n\t\tgoto put_err_out;\n\t}\n\tif (!a) {\n\t\tntfs_error(sb, \"$MFT/$DATA attribute not found. $MFT is \"\n\t\t\t\t\"corrupt. Run chkdsk.\");\n\t\tgoto put_err_out;\n\t}\n\tif (highest_vcn && highest_vcn != last_vcn - 1) {\n\t\tntfs_error(sb, \"Failed to load the complete runlist for \"\n\t\t\t\t\"$MFT/$DATA. Driver bug or corrupt $MFT. \"\n\t\t\t\t\"Run chkdsk.\");\n\t\tntfs_debug(\"highest_vcn = 0x%llx, last_vcn - 1 = 0x%llx\",\n\t\t\t\t(unsigned long long)highest_vcn,\n\t\t\t\t(unsigned long long)last_vcn - 1);\n\t\tgoto put_err_out;\n\t}\n\tntfs_attr_put_search_ctx(ctx);\n\tntfs_debug(\"Done.\");\n\tntfs_free(m);\n\n\t/*\n\t * Split the locking rules of the MFT inode from the\n\t * locking rules of other inodes:\n\t */\n\tlockdep_set_class(&ni->runlist.lock, &mft_ni_runlist_lock_key);\n\tlockdep_set_class(&ni->mrec_lock, &mft_ni_mrec_lock_key);\n\n\treturn 0;\n\nem_put_err_out:\n\tntfs_error(sb, \"Couldn't find first extent of $DATA attribute in \"\n\t\t\t\"attribute list. $MFT is corrupt. Run chkdsk.\");\nput_err_out:\n\tntfs_attr_put_search_ctx(ctx);\nerr_out:\n\tntfs_error(sb, \"Failed. Marking inode as bad.\");\n\tmake_bad_inode(vi);\n\tntfs_free(m);\n\treturn -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "insert_inode_hash",
          "args": [
            "tmp_ino"
          ],
          "line": 2880
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_insert_inode_hash",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/btrfs_inode.h",
          "lines": "213-218",
          "snippet": "static inline void btrfs_insert_inode_hash(struct inode *inode)\n{\n\tunsigned long h = btrfs_inode_hash(inode->i_ino, BTRFS_I(inode)->root);\n\n\t__insert_inode_hash(inode, h);\n}",
          "includes": [
            "#include \"delayed-inode.h\"",
            "#include \"ordered-data.h\"",
            "#include \"extent_io.h\"",
            "#include \"extent_map.h\"",
            "#include <linux/hash.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"delayed-inode.h\"\n#include \"ordered-data.h\"\n#include \"extent_io.h\"\n#include \"extent_map.h\"\n#include <linux/hash.h>\n\nstatic inline void btrfs_insert_inode_hash(struct inode *inode)\n{\n\tunsigned long h = btrfs_inode_hash(inode->i_ino, BTRFS_I(inode)->root);\n\n\t__insert_inode_hash(inode, h);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ntfs_error",
          "args": [
            "sb",
            "\"Failed to load essential metadata.\""
          ],
          "line": 2876
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "new_inode",
          "args": [
            "sb"
          ],
          "line": 2873
        },
        "resolved": true,
        "details": {
          "function_name": "unlock_new_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "924-933",
          "snippet": "void unlock_new_inode(struct inode *inode)\n{\n\tlockdep_annotate_inode_mutex_key(inode);\n\tspin_lock(&inode->i_lock);\n\tWARN_ON(!(inode->i_state & I_NEW));\n\tinode->i_state &= ~I_NEW;\n\tsmp_mb();\n\twake_up_bit(&inode->i_state, __I_NEW);\n\tspin_unlock(&inode->i_lock);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid unlock_new_inode(struct inode *inode)\n{\n\tlockdep_annotate_inode_mutex_key(inode);\n\tspin_lock(&inode->i_lock);\n\tWARN_ON(!(inode->i_state & I_NEW));\n\tinode->i_state &= ~I_NEW;\n\tsmp_mb();\n\twake_up_bit(&inode->i_state, __I_NEW);\n\tspin_unlock(&inode->i_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ntfs_setup_allocators",
          "args": [
            "vol"
          ],
          "line": 2851
        },
        "resolved": true,
        "details": {
          "function_name": "ntfs_setup_allocators",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/super.c",
          "lines": "948-1024",
          "snippet": "static void ntfs_setup_allocators(ntfs_volume *vol)\n{\n#ifdef NTFS_RW\n\tLCN mft_zone_size, mft_lcn;\n#endif /* NTFS_RW */\n\n\tntfs_debug(\"vol->mft_zone_multiplier = 0x%x\",\n\t\t\tvol->mft_zone_multiplier);\n#ifdef NTFS_RW\n\t/* Determine the size of the MFT zone. */\n\tmft_zone_size = vol->nr_clusters;\n\tswitch (vol->mft_zone_multiplier) {  /* % of volume size in clusters */\n\tcase 4:\n\t\tmft_zone_size >>= 1;\t\t\t/* 50%   */\n\t\tbreak;\n\tcase 3:\n\t\tmft_zone_size = (mft_zone_size +\n\t\t\t\t(mft_zone_size >> 1)) >> 2;\t/* 37.5% */\n\t\tbreak;\n\tcase 2:\n\t\tmft_zone_size >>= 2;\t\t\t/* 25%   */\n\t\tbreak;\n\t/* case 1: */\n\tdefault:\n\t\tmft_zone_size >>= 3;\t\t\t/* 12.5% */\n\t\tbreak;\n\t}\n\t/* Setup the mft zone. */\n\tvol->mft_zone_start = vol->mft_zone_pos = vol->mft_lcn;\n\tntfs_debug(\"vol->mft_zone_pos = 0x%llx\",\n\t\t\t(unsigned long long)vol->mft_zone_pos);\n\t/*\n\t * Calculate the mft_lcn for an unmodified NTFS volume (see mkntfs\n\t * source) and if the actual mft_lcn is in the expected place or even\n\t * further to the front of the volume, extend the mft_zone to cover the\n\t * beginning of the volume as well.  This is in order to protect the\n\t * area reserved for the mft bitmap as well within the mft_zone itself.\n\t * On non-standard volumes we do not protect it as the overhead would\n\t * be higher than the speed increase we would get by doing it.\n\t */\n\tmft_lcn = (8192 + 2 * vol->cluster_size - 1) / vol->cluster_size;\n\tif (mft_lcn * vol->cluster_size < 16 * 1024)\n\t\tmft_lcn = (16 * 1024 + vol->cluster_size - 1) /\n\t\t\t\tvol->cluster_size;\n\tif (vol->mft_zone_start <= mft_lcn)\n\t\tvol->mft_zone_start = 0;\n\tntfs_debug(\"vol->mft_zone_start = 0x%llx\",\n\t\t\t(unsigned long long)vol->mft_zone_start);\n\t/*\n\t * Need to cap the mft zone on non-standard volumes so that it does\n\t * not point outside the boundaries of the volume.  We do this by\n\t * halving the zone size until we are inside the volume.\n\t */\n\tvol->mft_zone_end = vol->mft_lcn + mft_zone_size;\n\twhile (vol->mft_zone_end >= vol->nr_clusters) {\n\t\tmft_zone_size >>= 1;\n\t\tvol->mft_zone_end = vol->mft_lcn + mft_zone_size;\n\t}\n\tntfs_debug(\"vol->mft_zone_end = 0x%llx\",\n\t\t\t(unsigned long long)vol->mft_zone_end);\n\t/*\n\t * Set the current position within each data zone to the start of the\n\t * respective zone.\n\t */\n\tvol->data1_zone_pos = vol->mft_zone_end;\n\tntfs_debug(\"vol->data1_zone_pos = 0x%llx\",\n\t\t\t(unsigned long long)vol->data1_zone_pos);\n\tvol->data2_zone_pos = 0;\n\tntfs_debug(\"vol->data2_zone_pos = 0x%llx\",\n\t\t\t(unsigned long long)vol->data2_zone_pos);\n\n\t/* Set the mft data allocation position to mft record 24. */\n\tvol->mft_data_pos = 24;\n\tntfs_debug(\"vol->mft_data_pos = 0x%llx\",\n\t\t\t(unsigned long long)vol->mft_data_pos);\n#endif /* NTFS_RW */\n}",
          "includes": [
            "#include \"ntfs.h\"",
            "#include \"malloc.h\"",
            "#include \"layout.h\"",
            "#include \"aops.h\"",
            "#include \"inode.h\"",
            "#include \"index.h\"",
            "#include \"debug.h\"",
            "#include \"dir.h\"",
            "#include \"usnjrnl.h\"",
            "#include \"quota.h\"",
            "#include \"logfile.h\"",
            "#include \"sysctl.h\"",
            "#include <linux/bitmap.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/vfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>\t/* For bdev_logical_block_size(). */",
            "#include <linux/spinlock.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ntfs.h\"\n#include \"malloc.h\"\n#include \"layout.h\"\n#include \"aops.h\"\n#include \"inode.h\"\n#include \"index.h\"\n#include \"debug.h\"\n#include \"dir.h\"\n#include \"usnjrnl.h\"\n#include \"quota.h\"\n#include \"logfile.h\"\n#include \"sysctl.h\"\n#include <linux/bitmap.h>\n#include <linux/moduleparam.h>\n#include <linux/vfs.h>\n#include <linux/buffer_head.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\t/* For bdev_logical_block_size(). */\n#include <linux/spinlock.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/stddef.h>\n\nstatic void ntfs_setup_allocators(ntfs_volume *vol)\n{\n#ifdef NTFS_RW\n\tLCN mft_zone_size, mft_lcn;\n#endif /* NTFS_RW */\n\n\tntfs_debug(\"vol->mft_zone_multiplier = 0x%x\",\n\t\t\tvol->mft_zone_multiplier);\n#ifdef NTFS_RW\n\t/* Determine the size of the MFT zone. */\n\tmft_zone_size = vol->nr_clusters;\n\tswitch (vol->mft_zone_multiplier) {  /* % of volume size in clusters */\n\tcase 4:\n\t\tmft_zone_size >>= 1;\t\t\t/* 50%   */\n\t\tbreak;\n\tcase 3:\n\t\tmft_zone_size = (mft_zone_size +\n\t\t\t\t(mft_zone_size >> 1)) >> 2;\t/* 37.5% */\n\t\tbreak;\n\tcase 2:\n\t\tmft_zone_size >>= 2;\t\t\t/* 25%   */\n\t\tbreak;\n\t/* case 1: */\n\tdefault:\n\t\tmft_zone_size >>= 3;\t\t\t/* 12.5% */\n\t\tbreak;\n\t}\n\t/* Setup the mft zone. */\n\tvol->mft_zone_start = vol->mft_zone_pos = vol->mft_lcn;\n\tntfs_debug(\"vol->mft_zone_pos = 0x%llx\",\n\t\t\t(unsigned long long)vol->mft_zone_pos);\n\t/*\n\t * Calculate the mft_lcn for an unmodified NTFS volume (see mkntfs\n\t * source) and if the actual mft_lcn is in the expected place or even\n\t * further to the front of the volume, extend the mft_zone to cover the\n\t * beginning of the volume as well.  This is in order to protect the\n\t * area reserved for the mft bitmap as well within the mft_zone itself.\n\t * On non-standard volumes we do not protect it as the overhead would\n\t * be higher than the speed increase we would get by doing it.\n\t */\n\tmft_lcn = (8192 + 2 * vol->cluster_size - 1) / vol->cluster_size;\n\tif (mft_lcn * vol->cluster_size < 16 * 1024)\n\t\tmft_lcn = (16 * 1024 + vol->cluster_size - 1) /\n\t\t\t\tvol->cluster_size;\n\tif (vol->mft_zone_start <= mft_lcn)\n\t\tvol->mft_zone_start = 0;\n\tntfs_debug(\"vol->mft_zone_start = 0x%llx\",\n\t\t\t(unsigned long long)vol->mft_zone_start);\n\t/*\n\t * Need to cap the mft zone on non-standard volumes so that it does\n\t * not point outside the boundaries of the volume.  We do this by\n\t * halving the zone size until we are inside the volume.\n\t */\n\tvol->mft_zone_end = vol->mft_lcn + mft_zone_size;\n\twhile (vol->mft_zone_end >= vol->nr_clusters) {\n\t\tmft_zone_size >>= 1;\n\t\tvol->mft_zone_end = vol->mft_lcn + mft_zone_size;\n\t}\n\tntfs_debug(\"vol->mft_zone_end = 0x%llx\",\n\t\t\t(unsigned long long)vol->mft_zone_end);\n\t/*\n\t * Set the current position within each data zone to the start of the\n\t * respective zone.\n\t */\n\tvol->data1_zone_pos = vol->mft_zone_end;\n\tntfs_debug(\"vol->data1_zone_pos = 0x%llx\",\n\t\t\t(unsigned long long)vol->data1_zone_pos);\n\tvol->data2_zone_pos = 0;\n\tntfs_debug(\"vol->data2_zone_pos = 0x%llx\",\n\t\t\t(unsigned long long)vol->data2_zone_pos);\n\n\t/* Set the mft data allocation position to mft record 24. */\n\tvol->mft_data_pos = 24;\n\tntfs_debug(\"vol->mft_data_pos = 0x%llx\",\n\t\t\t(unsigned long long)vol->mft_data_pos);\n#endif /* NTFS_RW */\n}"
        }
      },
      {
        "call_info": {
          "callee": "ntfs_debug",
          "args": [
            "\"Changed device block size to %i bytes (block size \"\n\t\t\t\t\"bits %i) to match volume sector size.\"",
            "blocksize",
            "sb->s_blocksize_bits"
          ],
          "line": 2846
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "i_size_read",
          "args": [
            "sb->s_bdev->bd_inode"
          ],
          "line": 2844
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "blocksize != sb->s_blocksize"
          ],
          "line": 2843
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_error",
          "args": [
            "sb",
            "\"Unable to set device block \"\n\t\t\t\t\t\t\"size to sector size (%i).\"",
            "vol->sector_size"
          ],
          "line": 2838
        },
        "resolved": true,
        "details": {
          "function_name": "__ntfs_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/debug.c",
          "lines": "86-108",
          "snippet": "void __ntfs_error(const char *function, const struct super_block *sb,\n\t\tconst char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\tint flen = 0;\n\n#ifndef DEBUG\n\tif (!printk_ratelimit())\n\t\treturn;\n#endif\n\tif (function)\n\t\tflen = strlen(function);\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tif (sb)\n\t\tpr_err(\"(device %s): %s(): %pV\\n\",\n\t\t       sb->s_id, flen ? function : \"\", &vaf);\n\telse\n\t\tpr_err(\"%s(): %pV\\n\", flen ? function : \"\", &vaf);\n\tva_end(args);\n}",
          "includes": [
            "#include \"debug.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"debug.h\"\n\nvoid __ntfs_error(const char *function, const struct super_block *sb,\n\t\tconst char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\tint flen = 0;\n\n#ifndef DEBUG\n\tif (!printk_ratelimit())\n\t\treturn;\n#endif\n\tif (function)\n\t\tflen = strlen(function);\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tif (sb)\n\t\tpr_err(\"(device %s): %s(): %pV\\n\",\n\t\t       sb->s_id, flen ? function : \"\", &vaf);\n\telse\n\t\tpr_err(\"%s(): %pV\\n\", flen ? function : \"\", &vaf);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sb_set_blocksize",
          "args": [
            "sb",
            "vol->sector_size"
          ],
          "line": 2835
        },
        "resolved": true,
        "details": {
          "function_name": "sb_set_blocksize",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/block_dev.c",
          "lines": "116-125",
          "snippet": "int sb_set_blocksize(struct super_block *sb, int size)\n{\n\tif (set_blocksize(sb->s_bdev, size))\n\t\treturn 0;\n\t/* If we get here, we know size is power of two\n\t * and it's value is between 512 and PAGE_SIZE */\n\tsb->s_blocksize = size;\n\tsb->s_blocksize_bits = blksize_bits(size);\n\treturn sb->s_blocksize;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/aio.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/log2.h>",
            "#include <linux/namei.h>",
            "#include <linux/uio.h>",
            "#include <linux/mount.h>",
            "#include <linux/mpage.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/swap.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkpg.h>",
            "#include <linux/module.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/highmem.h>",
            "#include <linux/device_cgroup.h>",
            "#include <linux/major.h>",
            "#include <linux/kmod.h>",
            "#include <linux/slab.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/namei.h>\n#include <linux/uio.h>\n#include <linux/mount.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/swap.h>\n#include <linux/buffer_head.h>\n#include <linux/magic.h>\n#include <linux/blkpg.h>\n#include <linux/module.h>\n#include <linux/blkdev.h>\n#include <linux/highmem.h>\n#include <linux/device_cgroup.h>\n#include <linux/major.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n\nint sb_set_blocksize(struct super_block *sb, int size)\n{\n\tif (set_blocksize(sb->s_bdev, size))\n\t\treturn 0;\n\t/* If we get here, we know size is power of two\n\t * and it's value is between 512 and PAGE_SIZE */\n\tsb->s_blocksize = size;\n\tsb->s_blocksize_bits = blksize_bits(size);\n\treturn sb->s_blocksize;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ntfs_error",
          "args": [
            "sb",
            "\"Unsupported NTFS filesystem.\""
          ],
          "line": 2821
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "bh"
          ],
          "line": 2818
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "parse_ntfs_boot_sector",
          "args": [
            "vol",
            "(NTFS_BOOT_SECTOR*)bh->b_data"
          ],
          "line": 2817
        },
        "resolved": true,
        "details": {
          "function_name": "parse_ntfs_boot_sector",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/super.c",
          "lines": "766-940",
          "snippet": "static bool parse_ntfs_boot_sector(ntfs_volume *vol, const NTFS_BOOT_SECTOR *b)\n{\n\tunsigned int sectors_per_cluster_bits, nr_hidden_sects;\n\tint clusters_per_mft_record, clusters_per_index_record;\n\ts64 ll;\n\n\tvol->sector_size = le16_to_cpu(b->bpb.bytes_per_sector);\n\tvol->sector_size_bits = ffs(vol->sector_size) - 1;\n\tntfs_debug(\"vol->sector_size = %i (0x%x)\", vol->sector_size,\n\t\t\tvol->sector_size);\n\tntfs_debug(\"vol->sector_size_bits = %i (0x%x)\", vol->sector_size_bits,\n\t\t\tvol->sector_size_bits);\n\tif (vol->sector_size < vol->sb->s_blocksize) {\n\t\tntfs_error(vol->sb, \"Sector size (%i) is smaller than the \"\n\t\t\t\t\"device block size (%lu).  This is not \"\n\t\t\t\t\"supported.  Sorry.\", vol->sector_size,\n\t\t\t\tvol->sb->s_blocksize);\n\t\treturn false;\n\t}\n\tntfs_debug(\"sectors_per_cluster = 0x%x\", b->bpb.sectors_per_cluster);\n\tsectors_per_cluster_bits = ffs(b->bpb.sectors_per_cluster) - 1;\n\tntfs_debug(\"sectors_per_cluster_bits = 0x%x\",\n\t\t\tsectors_per_cluster_bits);\n\tnr_hidden_sects = le32_to_cpu(b->bpb.hidden_sectors);\n\tntfs_debug(\"number of hidden sectors = 0x%x\", nr_hidden_sects);\n\tvol->cluster_size = vol->sector_size << sectors_per_cluster_bits;\n\tvol->cluster_size_mask = vol->cluster_size - 1;\n\tvol->cluster_size_bits = ffs(vol->cluster_size) - 1;\n\tntfs_debug(\"vol->cluster_size = %i (0x%x)\", vol->cluster_size,\n\t\t\tvol->cluster_size);\n\tntfs_debug(\"vol->cluster_size_mask = 0x%x\", vol->cluster_size_mask);\n\tntfs_debug(\"vol->cluster_size_bits = %i\", vol->cluster_size_bits);\n\tif (vol->cluster_size < vol->sector_size) {\n\t\tntfs_error(vol->sb, \"Cluster size (%i) is smaller than the \"\n\t\t\t\t\"sector size (%i).  This is not supported.  \"\n\t\t\t\t\"Sorry.\", vol->cluster_size, vol->sector_size);\n\t\treturn false;\n\t}\n\tclusters_per_mft_record = b->clusters_per_mft_record;\n\tntfs_debug(\"clusters_per_mft_record = %i (0x%x)\",\n\t\t\tclusters_per_mft_record, clusters_per_mft_record);\n\tif (clusters_per_mft_record > 0)\n\t\tvol->mft_record_size = vol->cluster_size <<\n\t\t\t\t(ffs(clusters_per_mft_record) - 1);\n\telse\n\t\t/*\n\t\t * When mft_record_size < cluster_size, clusters_per_mft_record\n\t\t * = -log2(mft_record_size) bytes. mft_record_size normaly is\n\t\t * 1024 bytes, which is encoded as 0xF6 (-10 in decimal).\n\t\t */\n\t\tvol->mft_record_size = 1 << -clusters_per_mft_record;\n\tvol->mft_record_size_mask = vol->mft_record_size - 1;\n\tvol->mft_record_size_bits = ffs(vol->mft_record_size) - 1;\n\tntfs_debug(\"vol->mft_record_size = %i (0x%x)\", vol->mft_record_size,\n\t\t\tvol->mft_record_size);\n\tntfs_debug(\"vol->mft_record_size_mask = 0x%x\",\n\t\t\tvol->mft_record_size_mask);\n\tntfs_debug(\"vol->mft_record_size_bits = %i (0x%x)\",\n\t\t\tvol->mft_record_size_bits, vol->mft_record_size_bits);\n\t/*\n\t * We cannot support mft record sizes above the PAGE_CACHE_SIZE since\n\t * we store $MFT/$DATA, the table of mft records in the page cache.\n\t */\n\tif (vol->mft_record_size > PAGE_CACHE_SIZE) {\n\t\tntfs_error(vol->sb, \"Mft record size (%i) exceeds the \"\n\t\t\t\t\"PAGE_CACHE_SIZE on your system (%lu).  \"\n\t\t\t\t\"This is not supported.  Sorry.\",\n\t\t\t\tvol->mft_record_size, PAGE_CACHE_SIZE);\n\t\treturn false;\n\t}\n\t/* We cannot support mft record sizes below the sector size. */\n\tif (vol->mft_record_size < vol->sector_size) {\n\t\tntfs_error(vol->sb, \"Mft record size (%i) is smaller than the \"\n\t\t\t\t\"sector size (%i).  This is not supported.  \"\n\t\t\t\t\"Sorry.\", vol->mft_record_size,\n\t\t\t\tvol->sector_size);\n\t\treturn false;\n\t}\n\tclusters_per_index_record = b->clusters_per_index_record;\n\tntfs_debug(\"clusters_per_index_record = %i (0x%x)\",\n\t\t\tclusters_per_index_record, clusters_per_index_record);\n\tif (clusters_per_index_record > 0)\n\t\tvol->index_record_size = vol->cluster_size <<\n\t\t\t\t(ffs(clusters_per_index_record) - 1);\n\telse\n\t\t/*\n\t\t * When index_record_size < cluster_size,\n\t\t * clusters_per_index_record = -log2(index_record_size) bytes.\n\t\t * index_record_size normaly equals 4096 bytes, which is\n\t\t * encoded as 0xF4 (-12 in decimal).\n\t\t */\n\t\tvol->index_record_size = 1 << -clusters_per_index_record;\n\tvol->index_record_size_mask = vol->index_record_size - 1;\n\tvol->index_record_size_bits = ffs(vol->index_record_size) - 1;\n\tntfs_debug(\"vol->index_record_size = %i (0x%x)\",\n\t\t\tvol->index_record_size, vol->index_record_size);\n\tntfs_debug(\"vol->index_record_size_mask = 0x%x\",\n\t\t\tvol->index_record_size_mask);\n\tntfs_debug(\"vol->index_record_size_bits = %i (0x%x)\",\n\t\t\tvol->index_record_size_bits,\n\t\t\tvol->index_record_size_bits);\n\t/* We cannot support index record sizes below the sector size. */\n\tif (vol->index_record_size < vol->sector_size) {\n\t\tntfs_error(vol->sb, \"Index record size (%i) is smaller than \"\n\t\t\t\t\"the sector size (%i).  This is not \"\n\t\t\t\t\"supported.  Sorry.\", vol->index_record_size,\n\t\t\t\tvol->sector_size);\n\t\treturn false;\n\t}\n\t/*\n\t * Get the size of the volume in clusters and check for 64-bit-ness.\n\t * Windows currently only uses 32 bits to save the clusters so we do\n\t * the same as it is much faster on 32-bit CPUs.\n\t */\n\tll = sle64_to_cpu(b->number_of_sectors) >> sectors_per_cluster_bits;\n\tif ((u64)ll >= 1ULL << 32) {\n\t\tntfs_error(vol->sb, \"Cannot handle 64-bit clusters.  Sorry.\");\n\t\treturn false;\n\t}\n\tvol->nr_clusters = ll;\n\tntfs_debug(\"vol->nr_clusters = 0x%llx\", (long long)vol->nr_clusters);\n\t/*\n\t * On an architecture where unsigned long is 32-bits, we restrict the\n\t * volume size to 2TiB (2^41). On a 64-bit architecture, the compiler\n\t * will hopefully optimize the whole check away.\n\t */\n\tif (sizeof(unsigned long) < 8) {\n\t\tif ((ll << vol->cluster_size_bits) >= (1ULL << 41)) {\n\t\t\tntfs_error(vol->sb, \"Volume size (%lluTiB) is too \"\n\t\t\t\t\t\"large for this architecture.  \"\n\t\t\t\t\t\"Maximum supported is 2TiB.  Sorry.\",\n\t\t\t\t\t(unsigned long long)ll >> (40 -\n\t\t\t\t\tvol->cluster_size_bits));\n\t\t\treturn false;\n\t\t}\n\t}\n\tll = sle64_to_cpu(b->mft_lcn);\n\tif (ll >= vol->nr_clusters) {\n\t\tntfs_error(vol->sb, \"MFT LCN (%lli, 0x%llx) is beyond end of \"\n\t\t\t\t\"volume.  Weird.\", (unsigned long long)ll,\n\t\t\t\t(unsigned long long)ll);\n\t\treturn false;\n\t}\n\tvol->mft_lcn = ll;\n\tntfs_debug(\"vol->mft_lcn = 0x%llx\", (long long)vol->mft_lcn);\n\tll = sle64_to_cpu(b->mftmirr_lcn);\n\tif (ll >= vol->nr_clusters) {\n\t\tntfs_error(vol->sb, \"MFTMirr LCN (%lli, 0x%llx) is beyond end \"\n\t\t\t\t\"of volume.  Weird.\", (unsigned long long)ll,\n\t\t\t\t(unsigned long long)ll);\n\t\treturn false;\n\t}\n\tvol->mftmirr_lcn = ll;\n\tntfs_debug(\"vol->mftmirr_lcn = 0x%llx\", (long long)vol->mftmirr_lcn);\n#ifdef NTFS_RW\n\t/*\n\t * Work out the size of the mft mirror in number of mft records. If the\n\t * cluster size is less than or equal to the size taken by four mft\n\t * records, the mft mirror stores the first four mft records. If the\n\t * cluster size is bigger than the size taken by four mft records, the\n\t * mft mirror contains as many mft records as will fit into one\n\t * cluster.\n\t */\n\tif (vol->cluster_size <= (4 << vol->mft_record_size_bits))\n\t\tvol->mftmirr_size = 4;\n\telse\n\t\tvol->mftmirr_size = vol->cluster_size >>\n\t\t\t\tvol->mft_record_size_bits;\n\tntfs_debug(\"vol->mftmirr_size = %i\", vol->mftmirr_size);\n#endif /* NTFS_RW */\n\tvol->serial_no = le64_to_cpu(b->volume_serial_number);\n\tntfs_debug(\"vol->serial_no = 0x%llx\",\n\t\t\t(unsigned long long)vol->serial_no);\n\treturn true;\n}",
          "includes": [
            "#include \"ntfs.h\"",
            "#include \"malloc.h\"",
            "#include \"layout.h\"",
            "#include \"aops.h\"",
            "#include \"inode.h\"",
            "#include \"index.h\"",
            "#include \"debug.h\"",
            "#include \"dir.h\"",
            "#include \"usnjrnl.h\"",
            "#include \"quota.h\"",
            "#include \"logfile.h\"",
            "#include \"sysctl.h\"",
            "#include <linux/bitmap.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/vfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>\t/* For bdev_logical_block_size(). */",
            "#include <linux/spinlock.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ntfs.h\"\n#include \"malloc.h\"\n#include \"layout.h\"\n#include \"aops.h\"\n#include \"inode.h\"\n#include \"index.h\"\n#include \"debug.h\"\n#include \"dir.h\"\n#include \"usnjrnl.h\"\n#include \"quota.h\"\n#include \"logfile.h\"\n#include \"sysctl.h\"\n#include <linux/bitmap.h>\n#include <linux/moduleparam.h>\n#include <linux/vfs.h>\n#include <linux/buffer_head.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\t/* For bdev_logical_block_size(). */\n#include <linux/spinlock.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/stddef.h>\n\nstatic bool parse_ntfs_boot_sector(ntfs_volume *vol, const NTFS_BOOT_SECTOR *b)\n{\n\tunsigned int sectors_per_cluster_bits, nr_hidden_sects;\n\tint clusters_per_mft_record, clusters_per_index_record;\n\ts64 ll;\n\n\tvol->sector_size = le16_to_cpu(b->bpb.bytes_per_sector);\n\tvol->sector_size_bits = ffs(vol->sector_size) - 1;\n\tntfs_debug(\"vol->sector_size = %i (0x%x)\", vol->sector_size,\n\t\t\tvol->sector_size);\n\tntfs_debug(\"vol->sector_size_bits = %i (0x%x)\", vol->sector_size_bits,\n\t\t\tvol->sector_size_bits);\n\tif (vol->sector_size < vol->sb->s_blocksize) {\n\t\tntfs_error(vol->sb, \"Sector size (%i) is smaller than the \"\n\t\t\t\t\"device block size (%lu).  This is not \"\n\t\t\t\t\"supported.  Sorry.\", vol->sector_size,\n\t\t\t\tvol->sb->s_blocksize);\n\t\treturn false;\n\t}\n\tntfs_debug(\"sectors_per_cluster = 0x%x\", b->bpb.sectors_per_cluster);\n\tsectors_per_cluster_bits = ffs(b->bpb.sectors_per_cluster) - 1;\n\tntfs_debug(\"sectors_per_cluster_bits = 0x%x\",\n\t\t\tsectors_per_cluster_bits);\n\tnr_hidden_sects = le32_to_cpu(b->bpb.hidden_sectors);\n\tntfs_debug(\"number of hidden sectors = 0x%x\", nr_hidden_sects);\n\tvol->cluster_size = vol->sector_size << sectors_per_cluster_bits;\n\tvol->cluster_size_mask = vol->cluster_size - 1;\n\tvol->cluster_size_bits = ffs(vol->cluster_size) - 1;\n\tntfs_debug(\"vol->cluster_size = %i (0x%x)\", vol->cluster_size,\n\t\t\tvol->cluster_size);\n\tntfs_debug(\"vol->cluster_size_mask = 0x%x\", vol->cluster_size_mask);\n\tntfs_debug(\"vol->cluster_size_bits = %i\", vol->cluster_size_bits);\n\tif (vol->cluster_size < vol->sector_size) {\n\t\tntfs_error(vol->sb, \"Cluster size (%i) is smaller than the \"\n\t\t\t\t\"sector size (%i).  This is not supported.  \"\n\t\t\t\t\"Sorry.\", vol->cluster_size, vol->sector_size);\n\t\treturn false;\n\t}\n\tclusters_per_mft_record = b->clusters_per_mft_record;\n\tntfs_debug(\"clusters_per_mft_record = %i (0x%x)\",\n\t\t\tclusters_per_mft_record, clusters_per_mft_record);\n\tif (clusters_per_mft_record > 0)\n\t\tvol->mft_record_size = vol->cluster_size <<\n\t\t\t\t(ffs(clusters_per_mft_record) - 1);\n\telse\n\t\t/*\n\t\t * When mft_record_size < cluster_size, clusters_per_mft_record\n\t\t * = -log2(mft_record_size) bytes. mft_record_size normaly is\n\t\t * 1024 bytes, which is encoded as 0xF6 (-10 in decimal).\n\t\t */\n\t\tvol->mft_record_size = 1 << -clusters_per_mft_record;\n\tvol->mft_record_size_mask = vol->mft_record_size - 1;\n\tvol->mft_record_size_bits = ffs(vol->mft_record_size) - 1;\n\tntfs_debug(\"vol->mft_record_size = %i (0x%x)\", vol->mft_record_size,\n\t\t\tvol->mft_record_size);\n\tntfs_debug(\"vol->mft_record_size_mask = 0x%x\",\n\t\t\tvol->mft_record_size_mask);\n\tntfs_debug(\"vol->mft_record_size_bits = %i (0x%x)\",\n\t\t\tvol->mft_record_size_bits, vol->mft_record_size_bits);\n\t/*\n\t * We cannot support mft record sizes above the PAGE_CACHE_SIZE since\n\t * we store $MFT/$DATA, the table of mft records in the page cache.\n\t */\n\tif (vol->mft_record_size > PAGE_CACHE_SIZE) {\n\t\tntfs_error(vol->sb, \"Mft record size (%i) exceeds the \"\n\t\t\t\t\"PAGE_CACHE_SIZE on your system (%lu).  \"\n\t\t\t\t\"This is not supported.  Sorry.\",\n\t\t\t\tvol->mft_record_size, PAGE_CACHE_SIZE);\n\t\treturn false;\n\t}\n\t/* We cannot support mft record sizes below the sector size. */\n\tif (vol->mft_record_size < vol->sector_size) {\n\t\tntfs_error(vol->sb, \"Mft record size (%i) is smaller than the \"\n\t\t\t\t\"sector size (%i).  This is not supported.  \"\n\t\t\t\t\"Sorry.\", vol->mft_record_size,\n\t\t\t\tvol->sector_size);\n\t\treturn false;\n\t}\n\tclusters_per_index_record = b->clusters_per_index_record;\n\tntfs_debug(\"clusters_per_index_record = %i (0x%x)\",\n\t\t\tclusters_per_index_record, clusters_per_index_record);\n\tif (clusters_per_index_record > 0)\n\t\tvol->index_record_size = vol->cluster_size <<\n\t\t\t\t(ffs(clusters_per_index_record) - 1);\n\telse\n\t\t/*\n\t\t * When index_record_size < cluster_size,\n\t\t * clusters_per_index_record = -log2(index_record_size) bytes.\n\t\t * index_record_size normaly equals 4096 bytes, which is\n\t\t * encoded as 0xF4 (-12 in decimal).\n\t\t */\n\t\tvol->index_record_size = 1 << -clusters_per_index_record;\n\tvol->index_record_size_mask = vol->index_record_size - 1;\n\tvol->index_record_size_bits = ffs(vol->index_record_size) - 1;\n\tntfs_debug(\"vol->index_record_size = %i (0x%x)\",\n\t\t\tvol->index_record_size, vol->index_record_size);\n\tntfs_debug(\"vol->index_record_size_mask = 0x%x\",\n\t\t\tvol->index_record_size_mask);\n\tntfs_debug(\"vol->index_record_size_bits = %i (0x%x)\",\n\t\t\tvol->index_record_size_bits,\n\t\t\tvol->index_record_size_bits);\n\t/* We cannot support index record sizes below the sector size. */\n\tif (vol->index_record_size < vol->sector_size) {\n\t\tntfs_error(vol->sb, \"Index record size (%i) is smaller than \"\n\t\t\t\t\"the sector size (%i).  This is not \"\n\t\t\t\t\"supported.  Sorry.\", vol->index_record_size,\n\t\t\t\tvol->sector_size);\n\t\treturn false;\n\t}\n\t/*\n\t * Get the size of the volume in clusters and check for 64-bit-ness.\n\t * Windows currently only uses 32 bits to save the clusters so we do\n\t * the same as it is much faster on 32-bit CPUs.\n\t */\n\tll = sle64_to_cpu(b->number_of_sectors) >> sectors_per_cluster_bits;\n\tif ((u64)ll >= 1ULL << 32) {\n\t\tntfs_error(vol->sb, \"Cannot handle 64-bit clusters.  Sorry.\");\n\t\treturn false;\n\t}\n\tvol->nr_clusters = ll;\n\tntfs_debug(\"vol->nr_clusters = 0x%llx\", (long long)vol->nr_clusters);\n\t/*\n\t * On an architecture where unsigned long is 32-bits, we restrict the\n\t * volume size to 2TiB (2^41). On a 64-bit architecture, the compiler\n\t * will hopefully optimize the whole check away.\n\t */\n\tif (sizeof(unsigned long) < 8) {\n\t\tif ((ll << vol->cluster_size_bits) >= (1ULL << 41)) {\n\t\t\tntfs_error(vol->sb, \"Volume size (%lluTiB) is too \"\n\t\t\t\t\t\"large for this architecture.  \"\n\t\t\t\t\t\"Maximum supported is 2TiB.  Sorry.\",\n\t\t\t\t\t(unsigned long long)ll >> (40 -\n\t\t\t\t\tvol->cluster_size_bits));\n\t\t\treturn false;\n\t\t}\n\t}\n\tll = sle64_to_cpu(b->mft_lcn);\n\tif (ll >= vol->nr_clusters) {\n\t\tntfs_error(vol->sb, \"MFT LCN (%lli, 0x%llx) is beyond end of \"\n\t\t\t\t\"volume.  Weird.\", (unsigned long long)ll,\n\t\t\t\t(unsigned long long)ll);\n\t\treturn false;\n\t}\n\tvol->mft_lcn = ll;\n\tntfs_debug(\"vol->mft_lcn = 0x%llx\", (long long)vol->mft_lcn);\n\tll = sle64_to_cpu(b->mftmirr_lcn);\n\tif (ll >= vol->nr_clusters) {\n\t\tntfs_error(vol->sb, \"MFTMirr LCN (%lli, 0x%llx) is beyond end \"\n\t\t\t\t\"of volume.  Weird.\", (unsigned long long)ll,\n\t\t\t\t(unsigned long long)ll);\n\t\treturn false;\n\t}\n\tvol->mftmirr_lcn = ll;\n\tntfs_debug(\"vol->mftmirr_lcn = 0x%llx\", (long long)vol->mftmirr_lcn);\n#ifdef NTFS_RW\n\t/*\n\t * Work out the size of the mft mirror in number of mft records. If the\n\t * cluster size is less than or equal to the size taken by four mft\n\t * records, the mft mirror stores the first four mft records. If the\n\t * cluster size is bigger than the size taken by four mft records, the\n\t * mft mirror contains as many mft records as will fit into one\n\t * cluster.\n\t */\n\tif (vol->cluster_size <= (4 << vol->mft_record_size_bits))\n\t\tvol->mftmirr_size = 4;\n\telse\n\t\tvol->mftmirr_size = vol->cluster_size >>\n\t\t\t\tvol->mft_record_size_bits;\n\tntfs_debug(\"vol->mftmirr_size = %i\", vol->mftmirr_size);\n#endif /* NTFS_RW */\n\tvol->serial_no = le64_to_cpu(b->volume_serial_number);\n\tntfs_debug(\"vol->serial_no = 0x%llx\",\n\t\t\t(unsigned long long)vol->serial_no);\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ntfs_error",
          "args": [
            "sb",
            "\"Not an NTFS volume.\""
          ],
          "line": 2810
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "read_ntfs_boot_sector",
          "args": [
            "sb",
            "silent"
          ],
          "line": 2808
        },
        "resolved": true,
        "details": {
          "function_name": "read_ntfs_boot_sector",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/super.c",
          "lines": "676-756",
          "snippet": "static struct buffer_head *read_ntfs_boot_sector(struct super_block *sb,\n\t\tconst int silent)\n{\n\tconst char *read_err_str = \"Unable to read %s boot sector.\";\n\tstruct buffer_head *bh_primary, *bh_backup;\n\tsector_t nr_blocks = NTFS_SB(sb)->nr_blocks;\n\n\t/* Try to read primary boot sector. */\n\tif ((bh_primary = sb_bread(sb, 0))) {\n\t\tif (is_boot_sector_ntfs(sb, (NTFS_BOOT_SECTOR*)\n\t\t\t\tbh_primary->b_data, silent))\n\t\t\treturn bh_primary;\n\t\tif (!silent)\n\t\t\tntfs_error(sb, \"Primary boot sector is invalid.\");\n\t} else if (!silent)\n\t\tntfs_error(sb, read_err_str, \"primary\");\n\tif (!(NTFS_SB(sb)->on_errors & ON_ERRORS_RECOVER)) {\n\t\tif (bh_primary)\n\t\t\tbrelse(bh_primary);\n\t\tif (!silent)\n\t\t\tntfs_error(sb, \"Mount option errors=recover not used. \"\n\t\t\t\t\t\"Aborting without trying to recover.\");\n\t\treturn NULL;\n\t}\n\t/* Try to read NT4+ backup boot sector. */\n\tif ((bh_backup = sb_bread(sb, nr_blocks - 1))) {\n\t\tif (is_boot_sector_ntfs(sb, (NTFS_BOOT_SECTOR*)\n\t\t\t\tbh_backup->b_data, silent))\n\t\t\tgoto hotfix_primary_boot_sector;\n\t\tbrelse(bh_backup);\n\t} else if (!silent)\n\t\tntfs_error(sb, read_err_str, \"backup\");\n\t/* Try to read NT3.51- backup boot sector. */\n\tif ((bh_backup = sb_bread(sb, nr_blocks >> 1))) {\n\t\tif (is_boot_sector_ntfs(sb, (NTFS_BOOT_SECTOR*)\n\t\t\t\tbh_backup->b_data, silent))\n\t\t\tgoto hotfix_primary_boot_sector;\n\t\tif (!silent)\n\t\t\tntfs_error(sb, \"Could not find a valid backup boot \"\n\t\t\t\t\t\"sector.\");\n\t\tbrelse(bh_backup);\n\t} else if (!silent)\n\t\tntfs_error(sb, read_err_str, \"backup\");\n\t/* We failed. Cleanup and return. */\n\tif (bh_primary)\n\t\tbrelse(bh_primary);\n\treturn NULL;\nhotfix_primary_boot_sector:\n\tif (bh_primary) {\n\t\t/*\n\t\t * If we managed to read sector zero and the volume is not\n\t\t * read-only, copy the found, valid backup boot sector to the\n\t\t * primary boot sector.  Note we only copy the actual boot\n\t\t * sector structure, not the actual whole device sector as that\n\t\t * may be bigger and would potentially damage the $Boot system\n\t\t * file (FIXME: Would be nice to know if the backup boot sector\n\t\t * on a large sector device contains the whole boot loader or\n\t\t * just the first 512 bytes).\n\t\t */\n\t\tif (!(sb->s_flags & MS_RDONLY)) {\n\t\t\tntfs_warning(sb, \"Hot-fix: Recovering invalid primary \"\n\t\t\t\t\t\"boot sector from backup copy.\");\n\t\t\tmemcpy(bh_primary->b_data, bh_backup->b_data,\n\t\t\t\t\tNTFS_BLOCK_SIZE);\n\t\t\tmark_buffer_dirty(bh_primary);\n\t\t\tsync_dirty_buffer(bh_primary);\n\t\t\tif (buffer_uptodate(bh_primary)) {\n\t\t\t\tbrelse(bh_backup);\n\t\t\t\treturn bh_primary;\n\t\t\t}\n\t\t\tntfs_error(sb, \"Hot-fix: Device write error while \"\n\t\t\t\t\t\"recovering primary boot sector.\");\n\t\t} else {\n\t\t\tntfs_warning(sb, \"Hot-fix: Recovery of primary boot \"\n\t\t\t\t\t\"sector failed: Read-only mount.\");\n\t\t}\n\t\tbrelse(bh_primary);\n\t}\n\tntfs_warning(sb, \"Using backup boot sector.\");\n\treturn bh_backup;\n}",
          "includes": [
            "#include \"ntfs.h\"",
            "#include \"malloc.h\"",
            "#include \"layout.h\"",
            "#include \"aops.h\"",
            "#include \"inode.h\"",
            "#include \"index.h\"",
            "#include \"debug.h\"",
            "#include \"dir.h\"",
            "#include \"usnjrnl.h\"",
            "#include \"quota.h\"",
            "#include \"logfile.h\"",
            "#include \"sysctl.h\"",
            "#include <linux/bitmap.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/vfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>\t/* For bdev_logical_block_size(). */",
            "#include <linux/spinlock.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ntfs.h\"\n#include \"malloc.h\"\n#include \"layout.h\"\n#include \"aops.h\"\n#include \"inode.h\"\n#include \"index.h\"\n#include \"debug.h\"\n#include \"dir.h\"\n#include \"usnjrnl.h\"\n#include \"quota.h\"\n#include \"logfile.h\"\n#include \"sysctl.h\"\n#include <linux/bitmap.h>\n#include <linux/moduleparam.h>\n#include <linux/vfs.h>\n#include <linux/buffer_head.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\t/* For bdev_logical_block_size(). */\n#include <linux/spinlock.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/stddef.h>\n\nstatic struct buffer_head *read_ntfs_boot_sector(struct super_block *sb,\n\t\tconst int silent)\n{\n\tconst char *read_err_str = \"Unable to read %s boot sector.\";\n\tstruct buffer_head *bh_primary, *bh_backup;\n\tsector_t nr_blocks = NTFS_SB(sb)->nr_blocks;\n\n\t/* Try to read primary boot sector. */\n\tif ((bh_primary = sb_bread(sb, 0))) {\n\t\tif (is_boot_sector_ntfs(sb, (NTFS_BOOT_SECTOR*)\n\t\t\t\tbh_primary->b_data, silent))\n\t\t\treturn bh_primary;\n\t\tif (!silent)\n\t\t\tntfs_error(sb, \"Primary boot sector is invalid.\");\n\t} else if (!silent)\n\t\tntfs_error(sb, read_err_str, \"primary\");\n\tif (!(NTFS_SB(sb)->on_errors & ON_ERRORS_RECOVER)) {\n\t\tif (bh_primary)\n\t\t\tbrelse(bh_primary);\n\t\tif (!silent)\n\t\t\tntfs_error(sb, \"Mount option errors=recover not used. \"\n\t\t\t\t\t\"Aborting without trying to recover.\");\n\t\treturn NULL;\n\t}\n\t/* Try to read NT4+ backup boot sector. */\n\tif ((bh_backup = sb_bread(sb, nr_blocks - 1))) {\n\t\tif (is_boot_sector_ntfs(sb, (NTFS_BOOT_SECTOR*)\n\t\t\t\tbh_backup->b_data, silent))\n\t\t\tgoto hotfix_primary_boot_sector;\n\t\tbrelse(bh_backup);\n\t} else if (!silent)\n\t\tntfs_error(sb, read_err_str, \"backup\");\n\t/* Try to read NT3.51- backup boot sector. */\n\tif ((bh_backup = sb_bread(sb, nr_blocks >> 1))) {\n\t\tif (is_boot_sector_ntfs(sb, (NTFS_BOOT_SECTOR*)\n\t\t\t\tbh_backup->b_data, silent))\n\t\t\tgoto hotfix_primary_boot_sector;\n\t\tif (!silent)\n\t\t\tntfs_error(sb, \"Could not find a valid backup boot \"\n\t\t\t\t\t\"sector.\");\n\t\tbrelse(bh_backup);\n\t} else if (!silent)\n\t\tntfs_error(sb, read_err_str, \"backup\");\n\t/* We failed. Cleanup and return. */\n\tif (bh_primary)\n\t\tbrelse(bh_primary);\n\treturn NULL;\nhotfix_primary_boot_sector:\n\tif (bh_primary) {\n\t\t/*\n\t\t * If we managed to read sector zero and the volume is not\n\t\t * read-only, copy the found, valid backup boot sector to the\n\t\t * primary boot sector.  Note we only copy the actual boot\n\t\t * sector structure, not the actual whole device sector as that\n\t\t * may be bigger and would potentially damage the $Boot system\n\t\t * file (FIXME: Would be nice to know if the backup boot sector\n\t\t * on a large sector device contains the whole boot loader or\n\t\t * just the first 512 bytes).\n\t\t */\n\t\tif (!(sb->s_flags & MS_RDONLY)) {\n\t\t\tntfs_warning(sb, \"Hot-fix: Recovering invalid primary \"\n\t\t\t\t\t\"boot sector from backup copy.\");\n\t\t\tmemcpy(bh_primary->b_data, bh_backup->b_data,\n\t\t\t\t\tNTFS_BLOCK_SIZE);\n\t\t\tmark_buffer_dirty(bh_primary);\n\t\t\tsync_dirty_buffer(bh_primary);\n\t\t\tif (buffer_uptodate(bh_primary)) {\n\t\t\t\tbrelse(bh_backup);\n\t\t\t\treturn bh_primary;\n\t\t\t}\n\t\t\tntfs_error(sb, \"Hot-fix: Device write error while \"\n\t\t\t\t\t\"recovering primary boot sector.\");\n\t\t} else {\n\t\t\tntfs_warning(sb, \"Hot-fix: Recovery of primary boot \"\n\t\t\t\t\t\"sector failed: Read-only mount.\");\n\t\t}\n\t\tbrelse(bh_primary);\n\t}\n\tntfs_warning(sb, \"Using backup boot sector.\");\n\treturn bh_backup;\n}"
        }
      },
      {
        "call_info": {
          "callee": "i_size_read",
          "args": [
            "sb->s_bdev->bd_inode"
          ],
          "line": 2805
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_error",
          "args": [
            "sb",
            "\"Unable to determine device size.\""
          ],
          "line": 2802
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "i_size_read",
          "args": [
            "sb->s_bdev->bd_inode"
          ],
          "line": 2800
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_debug",
          "args": [
            "\"Set device block size to %i bytes (block size bits %i).\"",
            "blocksize",
            "sb->s_blocksize_bits"
          ],
          "line": 2797
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "blocksize != sb->s_blocksize"
          ],
          "line": 2796
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_error",
          "args": [
            "sb",
            "\"Unable to set device block size.\""
          ],
          "line": 2793
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sb_min_blocksize",
          "args": [
            "sb",
            "NTFS_BLOCK_SIZE"
          ],
          "line": 2790
        },
        "resolved": true,
        "details": {
          "function_name": "sb_min_blocksize",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/block_dev.c",
          "lines": "129-135",
          "snippet": "int sb_min_blocksize(struct super_block *sb, int size)\n{\n\tint minsize = bdev_logical_block_size(sb->s_bdev);\n\tif (size < minsize)\n\t\tsize = minsize;\n\treturn sb_set_blocksize(sb, size);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/aio.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/log2.h>",
            "#include <linux/namei.h>",
            "#include <linux/uio.h>",
            "#include <linux/mount.h>",
            "#include <linux/mpage.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/swap.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkpg.h>",
            "#include <linux/module.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/highmem.h>",
            "#include <linux/device_cgroup.h>",
            "#include <linux/major.h>",
            "#include <linux/kmod.h>",
            "#include <linux/slab.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/namei.h>\n#include <linux/uio.h>\n#include <linux/mount.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/swap.h>\n#include <linux/buffer_head.h>\n#include <linux/magic.h>\n#include <linux/blkpg.h>\n#include <linux/module.h>\n#include <linux/blkdev.h>\n#include <linux/highmem.h>\n#include <linux/device_cgroup.h>\n#include <linux/major.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n\nint sb_min_blocksize(struct super_block *sb, int size)\n{\n\tint minsize = bdev_logical_block_size(sb->s_bdev);\n\tif (size < minsize)\n\t\tsize = minsize;\n\treturn sb_set_blocksize(sb, size);\n}"
        }
      },
      {
        "call_info": {
          "callee": "bdev_logical_block_size",
          "args": [
            "sb->s_bdev"
          ],
          "line": 2782
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bdev_logical_block_size",
          "args": [
            "sb->s_bdev"
          ],
          "line": 2776
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "parse_options",
          "args": [
            "vol",
            "(char*)opt"
          ],
          "line": 2772
        },
        "resolved": true,
        "details": {
          "function_name": "parse_options",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/super.c",
          "lines": "101-356",
          "snippet": "static bool parse_options(ntfs_volume *vol, char *opt)\n{\n\tchar *p, *v, *ov;\n\tstatic char *utf8 = \"utf8\";\n\tint errors = 0, sloppy = 0;\n\tkuid_t uid = INVALID_UID;\n\tkgid_t gid = INVALID_GID;\n\tumode_t fmask = (umode_t)-1, dmask = (umode_t)-1;\n\tint mft_zone_multiplier = -1, on_errors = -1;\n\tint show_sys_files = -1, case_sensitive = -1, disable_sparse = -1;\n\tstruct nls_table *nls_map = NULL, *old_nls;\n\n\t/* I am lazy... (-8 */\n#define NTFS_GETOPT_WITH_DEFAULT(option, variable, default_value)\t\\\n\tif (!strcmp(p, option)) {\t\t\t\t\t\\\n\t\tif (!v || !*v)\t\t\t\t\t\t\\\n\t\t\tvariable = default_value;\t\t\t\\\n\t\telse {\t\t\t\t\t\t\t\\\n\t\t\tvariable = simple_strtoul(ov = v, &v, 0);\t\\\n\t\t\tif (*v)\t\t\t\t\t\t\\\n\t\t\t\tgoto needs_val;\t\t\t\t\\\n\t\t}\t\t\t\t\t\t\t\\\n\t}\n#define NTFS_GETOPT(option, variable)\t\t\t\t\t\\\n\tif (!strcmp(p, option)) {\t\t\t\t\t\\\n\t\tif (!v || !*v)\t\t\t\t\t\t\\\n\t\t\tgoto needs_arg;\t\t\t\t\t\\\n\t\tvariable = simple_strtoul(ov = v, &v, 0);\t\t\\\n\t\tif (*v)\t\t\t\t\t\t\t\\\n\t\t\tgoto needs_val;\t\t\t\t\t\\\n\t}\n#define NTFS_GETOPT_UID(option, variable)\t\t\t\t\\\n\tif (!strcmp(p, option)) {\t\t\t\t\t\\\n\t\tuid_t uid_value;\t\t\t\t\t\\\n\t\tif (!v || !*v)\t\t\t\t\t\t\\\n\t\t\tgoto needs_arg;\t\t\t\t\t\\\n\t\tuid_value = simple_strtoul(ov = v, &v, 0);\t\t\\\n\t\tif (*v)\t\t\t\t\t\t\t\\\n\t\t\tgoto needs_val;\t\t\t\t\t\\\n\t\tvariable = make_kuid(current_user_ns(), uid_value);\t\\\n\t\tif (!uid_valid(variable))\t\t\t\t\\\n\t\t\tgoto needs_val;\t\t\t\t\t\\\n\t}\n#define NTFS_GETOPT_GID(option, variable)\t\t\t\t\\\n\tif (!strcmp(p, option)) {\t\t\t\t\t\\\n\t\tgid_t gid_value;\t\t\t\t\t\\\n\t\tif (!v || !*v)\t\t\t\t\t\t\\\n\t\t\tgoto needs_arg;\t\t\t\t\t\\\n\t\tgid_value = simple_strtoul(ov = v, &v, 0);\t\t\\\n\t\tif (*v)\t\t\t\t\t\t\t\\\n\t\t\tgoto needs_val;\t\t\t\t\t\\\n\t\tvariable = make_kgid(current_user_ns(), gid_value);\t\\\n\t\tif (!gid_valid(variable))\t\t\t\t\\\n\t\t\tgoto needs_val;\t\t\t\t\t\\\n\t}\n#define NTFS_GETOPT_OCTAL(option, variable)\t\t\t\t\\\n\tif (!strcmp(p, option)) {\t\t\t\t\t\\\n\t\tif (!v || !*v)\t\t\t\t\t\t\\\n\t\t\tgoto needs_arg;\t\t\t\t\t\\\n\t\tvariable = simple_strtoul(ov = v, &v, 8);\t\t\\\n\t\tif (*v)\t\t\t\t\t\t\t\\\n\t\t\tgoto needs_val;\t\t\t\t\t\\\n\t}\n#define NTFS_GETOPT_BOOL(option, variable)\t\t\t\t\\\n\tif (!strcmp(p, option)) {\t\t\t\t\t\\\n\t\tbool val;\t\t\t\t\t\t\\\n\t\tif (!simple_getbool(v, &val))\t\t\t\t\\\n\t\t\tgoto needs_bool;\t\t\t\t\\\n\t\tvariable = val;\t\t\t\t\t\t\\\n\t}\n#define NTFS_GETOPT_OPTIONS_ARRAY(option, variable, opt_array)\t\t\\\n\tif (!strcmp(p, option)) {\t\t\t\t\t\\\n\t\tint _i;\t\t\t\t\t\t\t\\\n\t\tif (!v || !*v)\t\t\t\t\t\t\\\n\t\t\tgoto needs_arg;\t\t\t\t\t\\\n\t\tov = v;\t\t\t\t\t\t\t\\\n\t\tif (variable == -1)\t\t\t\t\t\\\n\t\t\tvariable = 0;\t\t\t\t\t\\\n\t\tfor (_i = 0; opt_array[_i].str && *opt_array[_i].str; _i++) \\\n\t\t\tif (!strcmp(opt_array[_i].str, v)) {\t\t\\\n\t\t\t\tvariable |= opt_array[_i].val;\t\t\\\n\t\t\t\tbreak;\t\t\t\t\t\\\n\t\t\t}\t\t\t\t\t\t\\\n\t\tif (!opt_array[_i].str || !*opt_array[_i].str)\t\t\\\n\t\t\tgoto needs_val;\t\t\t\t\t\\\n\t}\n\tif (!opt || !*opt)\n\t\tgoto no_mount_options;\n\tntfs_debug(\"Entering with mount options string: %s\", opt);\n\twhile ((p = strsep(&opt, \",\"))) {\n\t\tif ((v = strchr(p, '=')))\n\t\t\t*v++ = 0;\n\t\tNTFS_GETOPT_UID(\"uid\", uid)\n\t\telse NTFS_GETOPT_GID(\"gid\", gid)\n\t\telse NTFS_GETOPT_OCTAL(\"umask\", fmask = dmask)\n\t\telse NTFS_GETOPT_OCTAL(\"fmask\", fmask)\n\t\telse NTFS_GETOPT_OCTAL(\"dmask\", dmask)\n\t\telse NTFS_GETOPT(\"mft_zone_multiplier\", mft_zone_multiplier)\n\t\telse NTFS_GETOPT_WITH_DEFAULT(\"sloppy\", sloppy, true)\n\t\telse NTFS_GETOPT_BOOL(\"show_sys_files\", show_sys_files)\n\t\telse NTFS_GETOPT_BOOL(\"case_sensitive\", case_sensitive)\n\t\telse NTFS_GETOPT_BOOL(\"disable_sparse\", disable_sparse)\n\t\telse NTFS_GETOPT_OPTIONS_ARRAY(\"errors\", on_errors,\n\t\t\t\ton_errors_arr)\n\t\telse if (!strcmp(p, \"posix\") || !strcmp(p, \"show_inodes\"))\n\t\t\tntfs_warning(vol->sb, \"Ignoring obsolete option %s.\",\n\t\t\t\t\tp);\n\t\telse if (!strcmp(p, \"nls\") || !strcmp(p, \"iocharset\")) {\n\t\t\tif (!strcmp(p, \"iocharset\"))\n\t\t\t\tntfs_warning(vol->sb, \"Option iocharset is \"\n\t\t\t\t\t\t\"deprecated. Please use \"\n\t\t\t\t\t\t\"option nls=<charsetname> in \"\n\t\t\t\t\t\t\"the future.\");\n\t\t\tif (!v || !*v)\n\t\t\t\tgoto needs_arg;\nuse_utf8:\n\t\t\told_nls = nls_map;\n\t\t\tnls_map = load_nls(v);\n\t\t\tif (!nls_map) {\n\t\t\t\tif (!old_nls) {\n\t\t\t\t\tntfs_error(vol->sb, \"NLS character set \"\n\t\t\t\t\t\t\t\"%s not found.\", v);\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\tntfs_error(vol->sb, \"NLS character set %s not \"\n\t\t\t\t\t\t\"found. Using previous one %s.\",\n\t\t\t\t\t\tv, old_nls->charset);\n\t\t\t\tnls_map = old_nls;\n\t\t\t} else /* nls_map */ {\n\t\t\t\tunload_nls(old_nls);\n\t\t\t}\n\t\t} else if (!strcmp(p, \"utf8\")) {\n\t\t\tbool val = false;\n\t\t\tntfs_warning(vol->sb, \"Option utf8 is no longer \"\n\t\t\t\t   \"supported, using option nls=utf8. Please \"\n\t\t\t\t   \"use option nls=utf8 in the future and \"\n\t\t\t\t   \"make sure utf8 is compiled either as a \"\n\t\t\t\t   \"module or into the kernel.\");\n\t\t\tif (!v || !*v)\n\t\t\t\tval = true;\n\t\t\telse if (!simple_getbool(v, &val))\n\t\t\t\tgoto needs_bool;\n\t\t\tif (val) {\n\t\t\t\tv = utf8;\n\t\t\t\tgoto use_utf8;\n\t\t\t}\n\t\t} else {\n\t\t\tntfs_error(vol->sb, \"Unrecognized mount option %s.\", p);\n\t\t\tif (errors < INT_MAX)\n\t\t\t\terrors++;\n\t\t}\n#undef NTFS_GETOPT_OPTIONS_ARRAY\n#undef NTFS_GETOPT_BOOL\n#undef NTFS_GETOPT\n#undef NTFS_GETOPT_WITH_DEFAULT\n\t}\nno_mount_options:\n\tif (errors && !sloppy)\n\t\treturn false;\n\tif (sloppy)\n\t\tntfs_warning(vol->sb, \"Sloppy option given. Ignoring \"\n\t\t\t\t\"unrecognized mount option(s) and continuing.\");\n\t/* Keep this first! */\n\tif (on_errors != -1) {\n\t\tif (!on_errors) {\n\t\t\tntfs_error(vol->sb, \"Invalid errors option argument \"\n\t\t\t\t\t\"or bug in options parser.\");\n\t\t\treturn false;\n\t\t}\n\t}\n\tif (nls_map) {\n\t\tif (vol->nls_map && vol->nls_map != nls_map) {\n\t\t\tntfs_error(vol->sb, \"Cannot change NLS character set \"\n\t\t\t\t\t\"on remount.\");\n\t\t\treturn false;\n\t\t} /* else (!vol->nls_map) */\n\t\tntfs_debug(\"Using NLS character set %s.\", nls_map->charset);\n\t\tvol->nls_map = nls_map;\n\t} else /* (!nls_map) */ {\n\t\tif (!vol->nls_map) {\n\t\t\tvol->nls_map = load_nls_default();\n\t\t\tif (!vol->nls_map) {\n\t\t\t\tntfs_error(vol->sb, \"Failed to load default \"\n\t\t\t\t\t\t\"NLS character set.\");\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tntfs_debug(\"Using default NLS character set (%s).\",\n\t\t\t\t\tvol->nls_map->charset);\n\t\t}\n\t}\n\tif (mft_zone_multiplier != -1) {\n\t\tif (vol->mft_zone_multiplier && vol->mft_zone_multiplier !=\n\t\t\t\tmft_zone_multiplier) {\n\t\t\tntfs_error(vol->sb, \"Cannot change mft_zone_multiplier \"\n\t\t\t\t\t\"on remount.\");\n\t\t\treturn false;\n\t\t}\n\t\tif (mft_zone_multiplier < 1 || mft_zone_multiplier > 4) {\n\t\t\tntfs_error(vol->sb, \"Invalid mft_zone_multiplier. \"\n\t\t\t\t\t\"Using default value, i.e. 1.\");\n\t\t\tmft_zone_multiplier = 1;\n\t\t}\n\t\tvol->mft_zone_multiplier = mft_zone_multiplier;\n\t}\n\tif (!vol->mft_zone_multiplier)\n\t\tvol->mft_zone_multiplier = 1;\n\tif (on_errors != -1)\n\t\tvol->on_errors = on_errors;\n\tif (!vol->on_errors || vol->on_errors == ON_ERRORS_RECOVER)\n\t\tvol->on_errors |= ON_ERRORS_CONTINUE;\n\tif (uid_valid(uid))\n\t\tvol->uid = uid;\n\tif (gid_valid(gid))\n\t\tvol->gid = gid;\n\tif (fmask != (umode_t)-1)\n\t\tvol->fmask = fmask;\n\tif (dmask != (umode_t)-1)\n\t\tvol->dmask = dmask;\n\tif (show_sys_files != -1) {\n\t\tif (show_sys_files)\n\t\t\tNVolSetShowSystemFiles(vol);\n\t\telse\n\t\t\tNVolClearShowSystemFiles(vol);\n\t}\n\tif (case_sensitive != -1) {\n\t\tif (case_sensitive)\n\t\t\tNVolSetCaseSensitive(vol);\n\t\telse\n\t\t\tNVolClearCaseSensitive(vol);\n\t}\n\tif (disable_sparse != -1) {\n\t\tif (disable_sparse)\n\t\t\tNVolClearSparseEnabled(vol);\n\t\telse {\n\t\t\tif (!NVolSparseEnabled(vol) &&\n\t\t\t\t\tvol->major_ver && vol->major_ver < 3)\n\t\t\t\tntfs_warning(vol->sb, \"Not enabling sparse \"\n\t\t\t\t\t\t\"support due to NTFS volume \"\n\t\t\t\t\t\t\"version %i.%i (need at least \"\n\t\t\t\t\t\t\"version 3.0).\", vol->major_ver,\n\t\t\t\t\t\tvol->minor_ver);\n\t\t\telse\n\t\t\t\tNVolSetSparseEnabled(vol);\n\t\t}\n\t}\n\treturn true;\nneeds_arg:\n\tntfs_error(vol->sb, \"The %s option requires an argument.\", p);\n\treturn false;\nneeds_bool:\n\tntfs_error(vol->sb, \"The %s option requires a boolean argument.\", p);\n\treturn false;\nneeds_val:\n\tntfs_error(vol->sb, \"Invalid %s option argument: %s\", p, ov);\n\treturn false;\n}",
          "includes": [
            "#include \"ntfs.h\"",
            "#include \"malloc.h\"",
            "#include \"layout.h\"",
            "#include \"aops.h\"",
            "#include \"inode.h\"",
            "#include \"index.h\"",
            "#include \"debug.h\"",
            "#include \"dir.h\"",
            "#include \"usnjrnl.h\"",
            "#include \"quota.h\"",
            "#include \"logfile.h\"",
            "#include \"sysctl.h\"",
            "#include <linux/bitmap.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/vfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>\t/* For bdev_logical_block_size(). */",
            "#include <linux/spinlock.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "const option_t on_errors_arr[] = {\n\t{ ON_ERRORS_PANIC,\t\"panic\" },\n\t{ ON_ERRORS_REMOUNT_RO,\t\"remount-ro\", },\n\t{ ON_ERRORS_CONTINUE,\t\"continue\", },\n\t{ ON_ERRORS_RECOVER,\t\"recover\" },\n\t{ 0,\t\t\tNULL }\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ntfs.h\"\n#include \"malloc.h\"\n#include \"layout.h\"\n#include \"aops.h\"\n#include \"inode.h\"\n#include \"index.h\"\n#include \"debug.h\"\n#include \"dir.h\"\n#include \"usnjrnl.h\"\n#include \"quota.h\"\n#include \"logfile.h\"\n#include \"sysctl.h\"\n#include <linux/bitmap.h>\n#include <linux/moduleparam.h>\n#include <linux/vfs.h>\n#include <linux/buffer_head.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\t/* For bdev_logical_block_size(). */\n#include <linux/spinlock.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/stddef.h>\n\nconst option_t on_errors_arr[] = {\n\t{ ON_ERRORS_PANIC,\t\"panic\" },\n\t{ ON_ERRORS_REMOUNT_RO,\t\"remount-ro\", },\n\t{ ON_ERRORS_CONTINUE,\t\"continue\", },\n\t{ ON_ERRORS_RECOVER,\t\"recover\" },\n\t{ 0,\t\t\tNULL }\n};\n\nstatic bool parse_options(ntfs_volume *vol, char *opt)\n{\n\tchar *p, *v, *ov;\n\tstatic char *utf8 = \"utf8\";\n\tint errors = 0, sloppy = 0;\n\tkuid_t uid = INVALID_UID;\n\tkgid_t gid = INVALID_GID;\n\tumode_t fmask = (umode_t)-1, dmask = (umode_t)-1;\n\tint mft_zone_multiplier = -1, on_errors = -1;\n\tint show_sys_files = -1, case_sensitive = -1, disable_sparse = -1;\n\tstruct nls_table *nls_map = NULL, *old_nls;\n\n\t/* I am lazy... (-8 */\n#define NTFS_GETOPT_WITH_DEFAULT(option, variable, default_value)\t\\\n\tif (!strcmp(p, option)) {\t\t\t\t\t\\\n\t\tif (!v || !*v)\t\t\t\t\t\t\\\n\t\t\tvariable = default_value;\t\t\t\\\n\t\telse {\t\t\t\t\t\t\t\\\n\t\t\tvariable = simple_strtoul(ov = v, &v, 0);\t\\\n\t\t\tif (*v)\t\t\t\t\t\t\\\n\t\t\t\tgoto needs_val;\t\t\t\t\\\n\t\t}\t\t\t\t\t\t\t\\\n\t}\n#define NTFS_GETOPT(option, variable)\t\t\t\t\t\\\n\tif (!strcmp(p, option)) {\t\t\t\t\t\\\n\t\tif (!v || !*v)\t\t\t\t\t\t\\\n\t\t\tgoto needs_arg;\t\t\t\t\t\\\n\t\tvariable = simple_strtoul(ov = v, &v, 0);\t\t\\\n\t\tif (*v)\t\t\t\t\t\t\t\\\n\t\t\tgoto needs_val;\t\t\t\t\t\\\n\t}\n#define NTFS_GETOPT_UID(option, variable)\t\t\t\t\\\n\tif (!strcmp(p, option)) {\t\t\t\t\t\\\n\t\tuid_t uid_value;\t\t\t\t\t\\\n\t\tif (!v || !*v)\t\t\t\t\t\t\\\n\t\t\tgoto needs_arg;\t\t\t\t\t\\\n\t\tuid_value = simple_strtoul(ov = v, &v, 0);\t\t\\\n\t\tif (*v)\t\t\t\t\t\t\t\\\n\t\t\tgoto needs_val;\t\t\t\t\t\\\n\t\tvariable = make_kuid(current_user_ns(), uid_value);\t\\\n\t\tif (!uid_valid(variable))\t\t\t\t\\\n\t\t\tgoto needs_val;\t\t\t\t\t\\\n\t}\n#define NTFS_GETOPT_GID(option, variable)\t\t\t\t\\\n\tif (!strcmp(p, option)) {\t\t\t\t\t\\\n\t\tgid_t gid_value;\t\t\t\t\t\\\n\t\tif (!v || !*v)\t\t\t\t\t\t\\\n\t\t\tgoto needs_arg;\t\t\t\t\t\\\n\t\tgid_value = simple_strtoul(ov = v, &v, 0);\t\t\\\n\t\tif (*v)\t\t\t\t\t\t\t\\\n\t\t\tgoto needs_val;\t\t\t\t\t\\\n\t\tvariable = make_kgid(current_user_ns(), gid_value);\t\\\n\t\tif (!gid_valid(variable))\t\t\t\t\\\n\t\t\tgoto needs_val;\t\t\t\t\t\\\n\t}\n#define NTFS_GETOPT_OCTAL(option, variable)\t\t\t\t\\\n\tif (!strcmp(p, option)) {\t\t\t\t\t\\\n\t\tif (!v || !*v)\t\t\t\t\t\t\\\n\t\t\tgoto needs_arg;\t\t\t\t\t\\\n\t\tvariable = simple_strtoul(ov = v, &v, 8);\t\t\\\n\t\tif (*v)\t\t\t\t\t\t\t\\\n\t\t\tgoto needs_val;\t\t\t\t\t\\\n\t}\n#define NTFS_GETOPT_BOOL(option, variable)\t\t\t\t\\\n\tif (!strcmp(p, option)) {\t\t\t\t\t\\\n\t\tbool val;\t\t\t\t\t\t\\\n\t\tif (!simple_getbool(v, &val))\t\t\t\t\\\n\t\t\tgoto needs_bool;\t\t\t\t\\\n\t\tvariable = val;\t\t\t\t\t\t\\\n\t}\n#define NTFS_GETOPT_OPTIONS_ARRAY(option, variable, opt_array)\t\t\\\n\tif (!strcmp(p, option)) {\t\t\t\t\t\\\n\t\tint _i;\t\t\t\t\t\t\t\\\n\t\tif (!v || !*v)\t\t\t\t\t\t\\\n\t\t\tgoto needs_arg;\t\t\t\t\t\\\n\t\tov = v;\t\t\t\t\t\t\t\\\n\t\tif (variable == -1)\t\t\t\t\t\\\n\t\t\tvariable = 0;\t\t\t\t\t\\\n\t\tfor (_i = 0; opt_array[_i].str && *opt_array[_i].str; _i++) \\\n\t\t\tif (!strcmp(opt_array[_i].str, v)) {\t\t\\\n\t\t\t\tvariable |= opt_array[_i].val;\t\t\\\n\t\t\t\tbreak;\t\t\t\t\t\\\n\t\t\t}\t\t\t\t\t\t\\\n\t\tif (!opt_array[_i].str || !*opt_array[_i].str)\t\t\\\n\t\t\tgoto needs_val;\t\t\t\t\t\\\n\t}\n\tif (!opt || !*opt)\n\t\tgoto no_mount_options;\n\tntfs_debug(\"Entering with mount options string: %s\", opt);\n\twhile ((p = strsep(&opt, \",\"))) {\n\t\tif ((v = strchr(p, '=')))\n\t\t\t*v++ = 0;\n\t\tNTFS_GETOPT_UID(\"uid\", uid)\n\t\telse NTFS_GETOPT_GID(\"gid\", gid)\n\t\telse NTFS_GETOPT_OCTAL(\"umask\", fmask = dmask)\n\t\telse NTFS_GETOPT_OCTAL(\"fmask\", fmask)\n\t\telse NTFS_GETOPT_OCTAL(\"dmask\", dmask)\n\t\telse NTFS_GETOPT(\"mft_zone_multiplier\", mft_zone_multiplier)\n\t\telse NTFS_GETOPT_WITH_DEFAULT(\"sloppy\", sloppy, true)\n\t\telse NTFS_GETOPT_BOOL(\"show_sys_files\", show_sys_files)\n\t\telse NTFS_GETOPT_BOOL(\"case_sensitive\", case_sensitive)\n\t\telse NTFS_GETOPT_BOOL(\"disable_sparse\", disable_sparse)\n\t\telse NTFS_GETOPT_OPTIONS_ARRAY(\"errors\", on_errors,\n\t\t\t\ton_errors_arr)\n\t\telse if (!strcmp(p, \"posix\") || !strcmp(p, \"show_inodes\"))\n\t\t\tntfs_warning(vol->sb, \"Ignoring obsolete option %s.\",\n\t\t\t\t\tp);\n\t\telse if (!strcmp(p, \"nls\") || !strcmp(p, \"iocharset\")) {\n\t\t\tif (!strcmp(p, \"iocharset\"))\n\t\t\t\tntfs_warning(vol->sb, \"Option iocharset is \"\n\t\t\t\t\t\t\"deprecated. Please use \"\n\t\t\t\t\t\t\"option nls=<charsetname> in \"\n\t\t\t\t\t\t\"the future.\");\n\t\t\tif (!v || !*v)\n\t\t\t\tgoto needs_arg;\nuse_utf8:\n\t\t\told_nls = nls_map;\n\t\t\tnls_map = load_nls(v);\n\t\t\tif (!nls_map) {\n\t\t\t\tif (!old_nls) {\n\t\t\t\t\tntfs_error(vol->sb, \"NLS character set \"\n\t\t\t\t\t\t\t\"%s not found.\", v);\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\tntfs_error(vol->sb, \"NLS character set %s not \"\n\t\t\t\t\t\t\"found. Using previous one %s.\",\n\t\t\t\t\t\tv, old_nls->charset);\n\t\t\t\tnls_map = old_nls;\n\t\t\t} else /* nls_map */ {\n\t\t\t\tunload_nls(old_nls);\n\t\t\t}\n\t\t} else if (!strcmp(p, \"utf8\")) {\n\t\t\tbool val = false;\n\t\t\tntfs_warning(vol->sb, \"Option utf8 is no longer \"\n\t\t\t\t   \"supported, using option nls=utf8. Please \"\n\t\t\t\t   \"use option nls=utf8 in the future and \"\n\t\t\t\t   \"make sure utf8 is compiled either as a \"\n\t\t\t\t   \"module or into the kernel.\");\n\t\t\tif (!v || !*v)\n\t\t\t\tval = true;\n\t\t\telse if (!simple_getbool(v, &val))\n\t\t\t\tgoto needs_bool;\n\t\t\tif (val) {\n\t\t\t\tv = utf8;\n\t\t\t\tgoto use_utf8;\n\t\t\t}\n\t\t} else {\n\t\t\tntfs_error(vol->sb, \"Unrecognized mount option %s.\", p);\n\t\t\tif (errors < INT_MAX)\n\t\t\t\terrors++;\n\t\t}\n#undef NTFS_GETOPT_OPTIONS_ARRAY\n#undef NTFS_GETOPT_BOOL\n#undef NTFS_GETOPT\n#undef NTFS_GETOPT_WITH_DEFAULT\n\t}\nno_mount_options:\n\tif (errors && !sloppy)\n\t\treturn false;\n\tif (sloppy)\n\t\tntfs_warning(vol->sb, \"Sloppy option given. Ignoring \"\n\t\t\t\t\"unrecognized mount option(s) and continuing.\");\n\t/* Keep this first! */\n\tif (on_errors != -1) {\n\t\tif (!on_errors) {\n\t\t\tntfs_error(vol->sb, \"Invalid errors option argument \"\n\t\t\t\t\t\"or bug in options parser.\");\n\t\t\treturn false;\n\t\t}\n\t}\n\tif (nls_map) {\n\t\tif (vol->nls_map && vol->nls_map != nls_map) {\n\t\t\tntfs_error(vol->sb, \"Cannot change NLS character set \"\n\t\t\t\t\t\"on remount.\");\n\t\t\treturn false;\n\t\t} /* else (!vol->nls_map) */\n\t\tntfs_debug(\"Using NLS character set %s.\", nls_map->charset);\n\t\tvol->nls_map = nls_map;\n\t} else /* (!nls_map) */ {\n\t\tif (!vol->nls_map) {\n\t\t\tvol->nls_map = load_nls_default();\n\t\t\tif (!vol->nls_map) {\n\t\t\t\tntfs_error(vol->sb, \"Failed to load default \"\n\t\t\t\t\t\t\"NLS character set.\");\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tntfs_debug(\"Using default NLS character set (%s).\",\n\t\t\t\t\tvol->nls_map->charset);\n\t\t}\n\t}\n\tif (mft_zone_multiplier != -1) {\n\t\tif (vol->mft_zone_multiplier && vol->mft_zone_multiplier !=\n\t\t\t\tmft_zone_multiplier) {\n\t\t\tntfs_error(vol->sb, \"Cannot change mft_zone_multiplier \"\n\t\t\t\t\t\"on remount.\");\n\t\t\treturn false;\n\t\t}\n\t\tif (mft_zone_multiplier < 1 || mft_zone_multiplier > 4) {\n\t\t\tntfs_error(vol->sb, \"Invalid mft_zone_multiplier. \"\n\t\t\t\t\t\"Using default value, i.e. 1.\");\n\t\t\tmft_zone_multiplier = 1;\n\t\t}\n\t\tvol->mft_zone_multiplier = mft_zone_multiplier;\n\t}\n\tif (!vol->mft_zone_multiplier)\n\t\tvol->mft_zone_multiplier = 1;\n\tif (on_errors != -1)\n\t\tvol->on_errors = on_errors;\n\tif (!vol->on_errors || vol->on_errors == ON_ERRORS_RECOVER)\n\t\tvol->on_errors |= ON_ERRORS_CONTINUE;\n\tif (uid_valid(uid))\n\t\tvol->uid = uid;\n\tif (gid_valid(gid))\n\t\tvol->gid = gid;\n\tif (fmask != (umode_t)-1)\n\t\tvol->fmask = fmask;\n\tif (dmask != (umode_t)-1)\n\t\tvol->dmask = dmask;\n\tif (show_sys_files != -1) {\n\t\tif (show_sys_files)\n\t\t\tNVolSetShowSystemFiles(vol);\n\t\telse\n\t\t\tNVolClearShowSystemFiles(vol);\n\t}\n\tif (case_sensitive != -1) {\n\t\tif (case_sensitive)\n\t\t\tNVolSetCaseSensitive(vol);\n\t\telse\n\t\t\tNVolClearCaseSensitive(vol);\n\t}\n\tif (disable_sparse != -1) {\n\t\tif (disable_sparse)\n\t\t\tNVolClearSparseEnabled(vol);\n\t\telse {\n\t\t\tif (!NVolSparseEnabled(vol) &&\n\t\t\t\t\tvol->major_ver && vol->major_ver < 3)\n\t\t\t\tntfs_warning(vol->sb, \"Not enabling sparse \"\n\t\t\t\t\t\t\"support due to NTFS volume \"\n\t\t\t\t\t\t\"version %i.%i (need at least \"\n\t\t\t\t\t\t\"version 3.0).\", vol->major_ver,\n\t\t\t\t\t\tvol->minor_ver);\n\t\t\telse\n\t\t\t\tNVolSetSparseEnabled(vol);\n\t\t}\n\t}\n\treturn true;\nneeds_arg:\n\tntfs_error(vol->sb, \"The %s option requires an argument.\", p);\n\treturn false;\nneeds_bool:\n\tntfs_error(vol->sb, \"The %s option requires a boolean argument.\", p);\n\treturn false;\nneeds_val:\n\tntfs_error(vol->sb, \"Invalid %s option argument: %s\", p, ov);\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "NVolSetSparseEnabled",
          "args": [
            "vol"
          ],
          "line": 2769
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "init_rwsem",
          "args": [
            "&vol->lcnbmp_lock"
          ],
          "line": 2766
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "init_rwsem",
          "args": [
            "&vol->mftbmp_lock"
          ],
          "line": 2765
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lockdep_on",
          "args": [],
          "line": 2750
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_error",
          "args": [
            "sb",
            "\"Allocation of NTFS volume structure \"\n\t\t\t\t\t\"failed. Aborting mount...\""
          ],
          "line": 2748
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NTFS_SB",
          "args": [
            "sb"
          ],
          "line": 2745
        },
        "resolved": true,
        "details": {
          "function_name": "NTFS_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/ntfs.h",
          "lines": "80-83",
          "snippet": "static inline ntfs_volume *NTFS_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"layout.h\"",
            "#include \"volume.h\"",
            "#include \"types.h\"",
            "#include <linux/pagemap.h>",
            "#include <linux/smp.h>",
            "#include <linux/nls.h>",
            "#include <linux/fs.h>",
            "#include <linux/compiler.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"layout.h\"\n#include \"volume.h\"\n#include \"types.h\"\n#include <linux/pagemap.h>\n#include <linux/smp.h>\n#include <linux/nls.h>\n#include <linux/fs.h>\n#include <linux/compiler.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/stddef.h>\n\nstatic inline ntfs_volume *NTFS_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "sizeof(ntfs_volume)",
            "GFP_NOFS"
          ],
          "line": 2744
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dx_dir_kmalloc_leaves",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "2534-2546",
          "snippet": "static struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}"
        }
      },
      {
        "call_info": {
          "callee": "lockdep_off",
          "args": [],
          "line": 2738
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ntfs.h\"\n#include \"malloc.h\"\n#include \"layout.h\"\n#include \"aops.h\"\n#include \"inode.h\"\n#include \"index.h\"\n#include \"debug.h\"\n#include \"dir.h\"\n#include \"usnjrnl.h\"\n#include \"quota.h\"\n#include \"logfile.h\"\n#include \"sysctl.h\"\n#include <linux/bitmap.h>\n#include <linux/moduleparam.h>\n#include <linux/vfs.h>\n#include <linux/buffer_head.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\t/* For bdev_logical_block_size(). */\n#include <linux/spinlock.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/stddef.h>\n\nstatic unsigned long ntfs_nr_compression_users;\nstatic ntfschar *default_upcase;\nstatic unsigned long ntfs_nr_upcase_users;\n\nstatic int ntfs_fill_super(struct super_block *sb, void *opt, const int silent)\n{\n\tntfs_volume *vol;\n\tstruct buffer_head *bh;\n\tstruct inode *tmp_ino;\n\tint blocksize, result;\n\n\t/*\n\t * We do a pretty difficult piece of bootstrap by reading the\n\t * MFT (and other metadata) from disk into memory. We'll only\n\t * release this metadata during umount, so the locking patterns\n\t * observed during bootstrap do not count. So turn off the\n\t * observation of locking patterns (strictly for this context\n\t * only) while mounting NTFS. [The validator is still active\n\t * otherwise, even for this context: it will for example record\n\t * lock class registrations.]\n\t */\n\tlockdep_off();\n\tntfs_debug(\"Entering.\");\n#ifndef NTFS_RW\n\tsb->s_flags |= MS_RDONLY;\n#endif /* ! NTFS_RW */\n\t/* Allocate a new ntfs_volume and place it in sb->s_fs_info. */\n\tsb->s_fs_info = kmalloc(sizeof(ntfs_volume), GFP_NOFS);\n\tvol = NTFS_SB(sb);\n\tif (!vol) {\n\t\tif (!silent)\n\t\t\tntfs_error(sb, \"Allocation of NTFS volume structure \"\n\t\t\t\t\t\"failed. Aborting mount...\");\n\t\tlockdep_on();\n\t\treturn -ENOMEM;\n\t}\n\t/* Initialize ntfs_volume structure. */\n\t*vol = (ntfs_volume) {\n\t\t.sb = sb,\n\t\t/*\n\t\t * Default is group and other don't have any access to files or\n\t\t * directories while owner has full access. Further, files by\n\t\t * default are not executable but directories are of course\n\t\t * browseable.\n\t\t */\n\t\t.fmask = 0177,\n\t\t.dmask = 0077,\n\t};\n\tinit_rwsem(&vol->mftbmp_lock);\n\tinit_rwsem(&vol->lcnbmp_lock);\n\n\t/* By default, enable sparse support. */\n\tNVolSetSparseEnabled(vol);\n\n\t/* Important to get the mount options dealt with now. */\n\tif (!parse_options(vol, (char*)opt))\n\t\tgoto err_out_now;\n\n\t/* We support sector sizes up to the PAGE_CACHE_SIZE. */\n\tif (bdev_logical_block_size(sb->s_bdev) > PAGE_CACHE_SIZE) {\n\t\tif (!silent)\n\t\t\tntfs_error(sb, \"Device has unsupported sector size \"\n\t\t\t\t\t\"(%i).  The maximum supported sector \"\n\t\t\t\t\t\"size on this architecture is %lu \"\n\t\t\t\t\t\"bytes.\",\n\t\t\t\t\tbdev_logical_block_size(sb->s_bdev),\n\t\t\t\t\tPAGE_CACHE_SIZE);\n\t\tgoto err_out_now;\n\t}\n\t/*\n\t * Setup the device access block size to NTFS_BLOCK_SIZE or the hard\n\t * sector size, whichever is bigger.\n\t */\n\tblocksize = sb_min_blocksize(sb, NTFS_BLOCK_SIZE);\n\tif (blocksize < NTFS_BLOCK_SIZE) {\n\t\tif (!silent)\n\t\t\tntfs_error(sb, \"Unable to set device block size.\");\n\t\tgoto err_out_now;\n\t}\n\tBUG_ON(blocksize != sb->s_blocksize);\n\tntfs_debug(\"Set device block size to %i bytes (block size bits %i).\",\n\t\t\tblocksize, sb->s_blocksize_bits);\n\t/* Determine the size of the device in units of block_size bytes. */\n\tif (!i_size_read(sb->s_bdev->bd_inode)) {\n\t\tif (!silent)\n\t\t\tntfs_error(sb, \"Unable to determine device size.\");\n\t\tgoto err_out_now;\n\t}\n\tvol->nr_blocks = i_size_read(sb->s_bdev->bd_inode) >>\n\t\t\tsb->s_blocksize_bits;\n\t/* Read the boot sector and return unlocked buffer head to it. */\n\tif (!(bh = read_ntfs_boot_sector(sb, silent))) {\n\t\tif (!silent)\n\t\t\tntfs_error(sb, \"Not an NTFS volume.\");\n\t\tgoto err_out_now;\n\t}\n\t/*\n\t * Extract the data from the boot sector and setup the ntfs volume\n\t * using it.\n\t */\n\tresult = parse_ntfs_boot_sector(vol, (NTFS_BOOT_SECTOR*)bh->b_data);\n\tbrelse(bh);\n\tif (!result) {\n\t\tif (!silent)\n\t\t\tntfs_error(sb, \"Unsupported NTFS filesystem.\");\n\t\tgoto err_out_now;\n\t}\n\t/*\n\t * If the boot sector indicates a sector size bigger than the current\n\t * device block size, switch the device block size to the sector size.\n\t * TODO: It may be possible to support this case even when the set\n\t * below fails, we would just be breaking up the i/o for each sector\n\t * into multiple blocks for i/o purposes but otherwise it should just\n\t * work.  However it is safer to leave disabled until someone hits this\n\t * error message and then we can get them to try it without the setting\n\t * so we know for sure that it works.\n\t */\n\tif (vol->sector_size > blocksize) {\n\t\tblocksize = sb_set_blocksize(sb, vol->sector_size);\n\t\tif (blocksize != vol->sector_size) {\n\t\t\tif (!silent)\n\t\t\t\tntfs_error(sb, \"Unable to set device block \"\n\t\t\t\t\t\t\"size to sector size (%i).\",\n\t\t\t\t\t\tvol->sector_size);\n\t\t\tgoto err_out_now;\n\t\t}\n\t\tBUG_ON(blocksize != sb->s_blocksize);\n\t\tvol->nr_blocks = i_size_read(sb->s_bdev->bd_inode) >>\n\t\t\t\tsb->s_blocksize_bits;\n\t\tntfs_debug(\"Changed device block size to %i bytes (block size \"\n\t\t\t\t\"bits %i) to match volume sector size.\",\n\t\t\t\tblocksize, sb->s_blocksize_bits);\n\t}\n\t/* Initialize the cluster and mft allocators. */\n\tntfs_setup_allocators(vol);\n\t/* Setup remaining fields in the super block. */\n\tsb->s_magic = NTFS_SB_MAGIC;\n\t/*\n\t * Ntfs allows 63 bits for the file size, i.e. correct would be:\n\t *\tsb->s_maxbytes = ~0ULL >> 1;\n\t * But the kernel uses a long as the page cache page index which on\n\t * 32-bit architectures is only 32-bits. MAX_LFS_FILESIZE is kernel\n\t * defined to the maximum the page cache page index can cope with\n\t * without overflowing the index or to 2^63 - 1, whichever is smaller.\n\t */\n\tsb->s_maxbytes = MAX_LFS_FILESIZE;\n\t/* Ntfs measures time in 100ns intervals. */\n\tsb->s_time_gran = 100;\n\t/*\n\t * Now load the metadata required for the page cache and our address\n\t * space operations to function. We do this by setting up a specialised\n\t * read_inode method and then just calling the normal iget() to obtain\n\t * the inode for $MFT which is sufficient to allow our normal inode\n\t * operations and associated address space operations to function.\n\t */\n\tsb->s_op = &ntfs_sops;\n\ttmp_ino = new_inode(sb);\n\tif (!tmp_ino) {\n\t\tif (!silent)\n\t\t\tntfs_error(sb, \"Failed to load essential metadata.\");\n\t\tgoto err_out_now;\n\t}\n\ttmp_ino->i_ino = FILE_MFT;\n\tinsert_inode_hash(tmp_ino);\n\tif (ntfs_read_inode_mount(tmp_ino) < 0) {\n\t\tif (!silent)\n\t\t\tntfs_error(sb, \"Failed to load essential metadata.\");\n\t\tgoto iput_tmp_ino_err_out_now;\n\t}\n\tmutex_lock(&ntfs_lock);\n\t/*\n\t * The current mount is a compression user if the cluster size is\n\t * less than or equal 4kiB.\n\t */\n\tif (vol->cluster_size <= 4096 && !ntfs_nr_compression_users++) {\n\t\tresult = allocate_compression_buffers();\n\t\tif (result) {\n\t\t\tntfs_error(NULL, \"Failed to allocate buffers \"\n\t\t\t\t\t\"for compression engine.\");\n\t\t\tntfs_nr_compression_users--;\n\t\t\tmutex_unlock(&ntfs_lock);\n\t\t\tgoto iput_tmp_ino_err_out_now;\n\t\t}\n\t}\n\t/*\n\t * Generate the global default upcase table if necessary.  Also\n\t * temporarily increment the number of upcase users to avoid race\n\t * conditions with concurrent (u)mounts.\n\t */\n\tif (!default_upcase)\n\t\tdefault_upcase = generate_default_upcase();\n\tntfs_nr_upcase_users++;\n\tmutex_unlock(&ntfs_lock);\n\t/*\n\t * From now on, ignore @silent parameter. If we fail below this line,\n\t * it will be due to a corrupt fs or a system error, so we report it.\n\t */\n\t/*\n\t * Open the system files with normal access functions and complete\n\t * setting up the ntfs super block.\n\t */\n\tif (!load_system_files(vol)) {\n\t\tntfs_error(sb, \"Failed to load system files.\");\n\t\tgoto unl_upcase_iput_tmp_ino_err_out_now;\n\t}\n\n\t/* We grab a reference, simulating an ntfs_iget(). */\n\tihold(vol->root_ino);\n\tif ((sb->s_root = d_make_root(vol->root_ino))) {\n\t\tntfs_debug(\"Exiting, status successful.\");\n\t\t/* Release the default upcase if it has no users. */\n\t\tmutex_lock(&ntfs_lock);\n\t\tif (!--ntfs_nr_upcase_users && default_upcase) {\n\t\t\tntfs_free(default_upcase);\n\t\t\tdefault_upcase = NULL;\n\t\t}\n\t\tmutex_unlock(&ntfs_lock);\n\t\tsb->s_export_op = &ntfs_export_ops;\n\t\tlockdep_on();\n\t\treturn 0;\n\t}\n\tntfs_error(sb, \"Failed to allocate root directory.\");\n\t/* Clean up after the successful load_system_files() call from above. */\n\t// TODO: Use ntfs_put_super() instead of repeating all this code...\n\t// FIXME: Should mark the volume clean as the error is most likely\n\t// \t  -ENOMEM.\n\tiput(vol->vol_ino);\n\tvol->vol_ino = NULL;\n\t/* NTFS 3.0+ specific clean up. */\n\tif (vol->major_ver >= 3) {\n#ifdef NTFS_RW\n\t\tif (vol->usnjrnl_j_ino) {\n\t\t\tiput(vol->usnjrnl_j_ino);\n\t\t\tvol->usnjrnl_j_ino = NULL;\n\t\t}\n\t\tif (vol->usnjrnl_max_ino) {\n\t\t\tiput(vol->usnjrnl_max_ino);\n\t\t\tvol->usnjrnl_max_ino = NULL;\n\t\t}\n\t\tif (vol->usnjrnl_ino) {\n\t\t\tiput(vol->usnjrnl_ino);\n\t\t\tvol->usnjrnl_ino = NULL;\n\t\t}\n\t\tif (vol->quota_q_ino) {\n\t\t\tiput(vol->quota_q_ino);\n\t\t\tvol->quota_q_ino = NULL;\n\t\t}\n\t\tif (vol->quota_ino) {\n\t\t\tiput(vol->quota_ino);\n\t\t\tvol->quota_ino = NULL;\n\t\t}\n#endif /* NTFS_RW */\n\t\tif (vol->extend_ino) {\n\t\t\tiput(vol->extend_ino);\n\t\t\tvol->extend_ino = NULL;\n\t\t}\n\t\tif (vol->secure_ino) {\n\t\t\tiput(vol->secure_ino);\n\t\t\tvol->secure_ino = NULL;\n\t\t}\n\t}\n\tiput(vol->root_ino);\n\tvol->root_ino = NULL;\n\tiput(vol->lcnbmp_ino);\n\tvol->lcnbmp_ino = NULL;\n\tiput(vol->mftbmp_ino);\n\tvol->mftbmp_ino = NULL;\n#ifdef NTFS_RW\n\tif (vol->logfile_ino) {\n\t\tiput(vol->logfile_ino);\n\t\tvol->logfile_ino = NULL;\n\t}\n\tif (vol->mftmirr_ino) {\n\t\tiput(vol->mftmirr_ino);\n\t\tvol->mftmirr_ino = NULL;\n\t}\n#endif /* NTFS_RW */\n\t/* Throw away the table of attribute definitions. */\n\tvol->attrdef_size = 0;\n\tif (vol->attrdef) {\n\t\tntfs_free(vol->attrdef);\n\t\tvol->attrdef = NULL;\n\t}\n\tvol->upcase_len = 0;\n\tmutex_lock(&ntfs_lock);\n\tif (vol->upcase == default_upcase) {\n\t\tntfs_nr_upcase_users--;\n\t\tvol->upcase = NULL;\n\t}\n\tmutex_unlock(&ntfs_lock);\n\tif (vol->upcase) {\n\t\tntfs_free(vol->upcase);\n\t\tvol->upcase = NULL;\n\t}\n\tif (vol->nls_map) {\n\t\tunload_nls(vol->nls_map);\n\t\tvol->nls_map = NULL;\n\t}\n\t/* Error exit code path. */\nunl_upcase_iput_tmp_ino_err_out_now:\n\t/*\n\t * Decrease the number of upcase users and destroy the global default\n\t * upcase table if necessary.\n\t */\n\tmutex_lock(&ntfs_lock);\n\tif (!--ntfs_nr_upcase_users && default_upcase) {\n\t\tntfs_free(default_upcase);\n\t\tdefault_upcase = NULL;\n\t}\n\tif (vol->cluster_size <= 4096 && !--ntfs_nr_compression_users)\n\t\tfree_compression_buffers();\n\tmutex_unlock(&ntfs_lock);\niput_tmp_ino_err_out_now:\n\tiput(tmp_ino);\n\tif (vol->mft_ino && vol->mft_ino != tmp_ino)\n\t\tiput(vol->mft_ino);\n\tvol->mft_ino = NULL;\n\t/* Errors at this stage are irrelevant. */\nerr_out_now:\n\tsb->s_fs_info = NULL;\n\tkfree(vol);\n\tntfs_debug(\"Failed, returning -EINVAL.\");\n\tlockdep_on();\n\treturn -EINVAL;\n}"
  },
  {
    "function_name": "ntfs_write_inode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/super.c",
    "lines": "2678-2681",
    "snippet": "static int ntfs_write_inode(struct inode *vi, struct writeback_control *wbc)\n{\n\treturn __ntfs_write_inode(vi, wbc->sync_mode == WB_SYNC_ALL);\n}",
    "includes": [
      "#include \"ntfs.h\"",
      "#include \"malloc.h\"",
      "#include \"layout.h\"",
      "#include \"aops.h\"",
      "#include \"inode.h\"",
      "#include \"index.h\"",
      "#include \"debug.h\"",
      "#include \"dir.h\"",
      "#include \"usnjrnl.h\"",
      "#include \"quota.h\"",
      "#include \"logfile.h\"",
      "#include \"sysctl.h\"",
      "#include <linux/bitmap.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/vfs.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/blkdev.h>\t/* For bdev_logical_block_size(). */",
      "#include <linux/spinlock.h>",
      "#include <linux/string.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/stddef.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__ntfs_write_inode",
          "args": [
            "vi",
            "wbc->sync_mode == WB_SYNC_ALL"
          ],
          "line": 2680
        },
        "resolved": true,
        "details": {
          "function_name": "__ntfs_write_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/inode.c",
          "lines": "2967-3110",
          "snippet": "int __ntfs_write_inode(struct inode *vi, int sync)\n{\n\tsle64 nt;\n\tntfs_inode *ni = NTFS_I(vi);\n\tntfs_attr_search_ctx *ctx;\n\tMFT_RECORD *m;\n\tSTANDARD_INFORMATION *si;\n\tint err = 0;\n\tbool modified = false;\n\n\tntfs_debug(\"Entering for %sinode 0x%lx.\", NInoAttr(ni) ? \"attr \" : \"\",\n\t\t\tvi->i_ino);\n\t/*\n\t * Dirty attribute inodes are written via their real inodes so just\n\t * clean them here.  Access time updates are taken care off when the\n\t * real inode is written.\n\t */\n\tif (NInoAttr(ni)) {\n\t\tNInoClearDirty(ni);\n\t\tntfs_debug(\"Done.\");\n\t\treturn 0;\n\t}\n\t/* Map, pin, and lock the mft record belonging to the inode. */\n\tm = map_mft_record(ni);\n\tif (IS_ERR(m)) {\n\t\terr = PTR_ERR(m);\n\t\tgoto err_out;\n\t}\n\t/* Update the access times in the standard information attribute. */\n\tctx = ntfs_attr_get_search_ctx(ni, m);\n\tif (unlikely(!ctx)) {\n\t\terr = -ENOMEM;\n\t\tgoto unm_err_out;\n\t}\n\terr = ntfs_attr_lookup(AT_STANDARD_INFORMATION, NULL, 0,\n\t\t\tCASE_SENSITIVE, 0, NULL, 0, ctx);\n\tif (unlikely(err)) {\n\t\tntfs_attr_put_search_ctx(ctx);\n\t\tgoto unm_err_out;\n\t}\n\tsi = (STANDARD_INFORMATION*)((u8*)ctx->attr +\n\t\t\tle16_to_cpu(ctx->attr->data.resident.value_offset));\n\t/* Update the access times if they have changed. */\n\tnt = utc2ntfs(vi->i_mtime);\n\tif (si->last_data_change_time != nt) {\n\t\tntfs_debug(\"Updating mtime for inode 0x%lx: old = 0x%llx, \"\n\t\t\t\t\"new = 0x%llx\", vi->i_ino, (long long)\n\t\t\t\tsle64_to_cpu(si->last_data_change_time),\n\t\t\t\t(long long)sle64_to_cpu(nt));\n\t\tsi->last_data_change_time = nt;\n\t\tmodified = true;\n\t}\n\tnt = utc2ntfs(vi->i_ctime);\n\tif (si->last_mft_change_time != nt) {\n\t\tntfs_debug(\"Updating ctime for inode 0x%lx: old = 0x%llx, \"\n\t\t\t\t\"new = 0x%llx\", vi->i_ino, (long long)\n\t\t\t\tsle64_to_cpu(si->last_mft_change_time),\n\t\t\t\t(long long)sle64_to_cpu(nt));\n\t\tsi->last_mft_change_time = nt;\n\t\tmodified = true;\n\t}\n\tnt = utc2ntfs(vi->i_atime);\n\tif (si->last_access_time != nt) {\n\t\tntfs_debug(\"Updating atime for inode 0x%lx: old = 0x%llx, \"\n\t\t\t\t\"new = 0x%llx\", vi->i_ino,\n\t\t\t\t(long long)sle64_to_cpu(si->last_access_time),\n\t\t\t\t(long long)sle64_to_cpu(nt));\n\t\tsi->last_access_time = nt;\n\t\tmodified = true;\n\t}\n\t/*\n\t * If we just modified the standard information attribute we need to\n\t * mark the mft record it is in dirty.  We do this manually so that\n\t * mark_inode_dirty() is not called which would redirty the inode and\n\t * hence result in an infinite loop of trying to write the inode.\n\t * There is no need to mark the base inode nor the base mft record\n\t * dirty, since we are going to write this mft record below in any case\n\t * and the base mft record may actually not have been modified so it\n\t * might not need to be written out.\n\t * NOTE: It is not a problem when the inode for $MFT itself is being\n\t * written out as mark_ntfs_record_dirty() will only set I_DIRTY_PAGES\n\t * on the $MFT inode and hence ntfs_write_inode() will not be\n\t * re-invoked because of it which in turn is ok since the dirtied mft\n\t * record will be cleaned and written out to disk below, i.e. before\n\t * this function returns.\n\t */\n\tif (modified) {\n\t\tflush_dcache_mft_record_page(ctx->ntfs_ino);\n\t\tif (!NInoTestSetDirty(ctx->ntfs_ino))\n\t\t\tmark_ntfs_record_dirty(ctx->ntfs_ino->page,\n\t\t\t\t\tctx->ntfs_ino->page_ofs);\n\t}\n\tntfs_attr_put_search_ctx(ctx);\n\t/* Now the access times are updated, write the base mft record. */\n\tif (NInoDirty(ni))\n\t\terr = write_mft_record(ni, m, sync);\n\t/* Write all attached extent mft records. */\n\tmutex_lock(&ni->extent_lock);\n\tif (ni->nr_extents > 0) {\n\t\tntfs_inode **extent_nis = ni->ext.extent_ntfs_inos;\n\t\tint i;\n\n\t\tntfs_debug(\"Writing %i extent inodes.\", ni->nr_extents);\n\t\tfor (i = 0; i < ni->nr_extents; i++) {\n\t\t\tntfs_inode *tni = extent_nis[i];\n\n\t\t\tif (NInoDirty(tni)) {\n\t\t\t\tMFT_RECORD *tm = map_mft_record(tni);\n\t\t\t\tint ret;\n\n\t\t\t\tif (IS_ERR(tm)) {\n\t\t\t\t\tif (!err || err == -ENOMEM)\n\t\t\t\t\t\terr = PTR_ERR(tm);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tret = write_mft_record(tni, tm, sync);\n\t\t\t\tunmap_mft_record(tni);\n\t\t\t\tif (unlikely(ret)) {\n\t\t\t\t\tif (!err || err == -ENOMEM)\n\t\t\t\t\t\terr = ret;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tmutex_unlock(&ni->extent_lock);\n\tunmap_mft_record(ni);\n\tif (unlikely(err))\n\t\tgoto err_out;\n\tntfs_debug(\"Done.\");\n\treturn 0;\nunm_err_out:\n\tunmap_mft_record(ni);\nerr_out:\n\tif (err == -ENOMEM) {\n\t\tntfs_warning(vi->i_sb, \"Not enough memory to write inode.  \"\n\t\t\t\t\"Marking the inode dirty again, so the VFS \"\n\t\t\t\t\"retries later.\");\n\t\tmark_inode_dirty(vi);\n\t} else {\n\t\tntfs_error(vi->i_sb, \"Failed (error %i):  Run chkdsk.\", -err);\n\t\tNVolSetErrors(ni->vol);\n\t}\n\treturn err;\n}",
          "includes": [
            "#include \"ntfs.h\"",
            "#include \"time.h\"",
            "#include \"mft.h\"",
            "#include \"malloc.h\"",
            "#include \"lcnalloc.h\"",
            "#include \"inode.h\"",
            "#include \"debug.h\"",
            "#include \"dir.h\"",
            "#include \"bitmap.h\"",
            "#include \"attrib.h\"",
            "#include \"aops.h\"",
            "#include <linux/aio.h>",
            "#include <linux/log2.h>",
            "#include <linux/slab.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mutex.h>",
            "#include <linux/mount.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ntfs_read_locked_inode(struct inode *vi);",
            "static int ntfs_read_locked_attr_inode(struct inode *base_vi, struct inode *vi);",
            "static int ntfs_read_locked_index_inode(struct inode *base_vi,\n\t\tstruct inode *vi);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ntfs.h\"\n#include \"time.h\"\n#include \"mft.h\"\n#include \"malloc.h\"\n#include \"lcnalloc.h\"\n#include \"inode.h\"\n#include \"debug.h\"\n#include \"dir.h\"\n#include \"bitmap.h\"\n#include \"attrib.h\"\n#include \"aops.h\"\n#include <linux/aio.h>\n#include <linux/log2.h>\n#include <linux/slab.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/mutex.h>\n#include <linux/mount.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n\nstatic int ntfs_read_locked_inode(struct inode *vi);\nstatic int ntfs_read_locked_attr_inode(struct inode *base_vi, struct inode *vi);\nstatic int ntfs_read_locked_index_inode(struct inode *base_vi,\n\t\tstruct inode *vi);\n\nint __ntfs_write_inode(struct inode *vi, int sync)\n{\n\tsle64 nt;\n\tntfs_inode *ni = NTFS_I(vi);\n\tntfs_attr_search_ctx *ctx;\n\tMFT_RECORD *m;\n\tSTANDARD_INFORMATION *si;\n\tint err = 0;\n\tbool modified = false;\n\n\tntfs_debug(\"Entering for %sinode 0x%lx.\", NInoAttr(ni) ? \"attr \" : \"\",\n\t\t\tvi->i_ino);\n\t/*\n\t * Dirty attribute inodes are written via their real inodes so just\n\t * clean them here.  Access time updates are taken care off when the\n\t * real inode is written.\n\t */\n\tif (NInoAttr(ni)) {\n\t\tNInoClearDirty(ni);\n\t\tntfs_debug(\"Done.\");\n\t\treturn 0;\n\t}\n\t/* Map, pin, and lock the mft record belonging to the inode. */\n\tm = map_mft_record(ni);\n\tif (IS_ERR(m)) {\n\t\terr = PTR_ERR(m);\n\t\tgoto err_out;\n\t}\n\t/* Update the access times in the standard information attribute. */\n\tctx = ntfs_attr_get_search_ctx(ni, m);\n\tif (unlikely(!ctx)) {\n\t\terr = -ENOMEM;\n\t\tgoto unm_err_out;\n\t}\n\terr = ntfs_attr_lookup(AT_STANDARD_INFORMATION, NULL, 0,\n\t\t\tCASE_SENSITIVE, 0, NULL, 0, ctx);\n\tif (unlikely(err)) {\n\t\tntfs_attr_put_search_ctx(ctx);\n\t\tgoto unm_err_out;\n\t}\n\tsi = (STANDARD_INFORMATION*)((u8*)ctx->attr +\n\t\t\tle16_to_cpu(ctx->attr->data.resident.value_offset));\n\t/* Update the access times if they have changed. */\n\tnt = utc2ntfs(vi->i_mtime);\n\tif (si->last_data_change_time != nt) {\n\t\tntfs_debug(\"Updating mtime for inode 0x%lx: old = 0x%llx, \"\n\t\t\t\t\"new = 0x%llx\", vi->i_ino, (long long)\n\t\t\t\tsle64_to_cpu(si->last_data_change_time),\n\t\t\t\t(long long)sle64_to_cpu(nt));\n\t\tsi->last_data_change_time = nt;\n\t\tmodified = true;\n\t}\n\tnt = utc2ntfs(vi->i_ctime);\n\tif (si->last_mft_change_time != nt) {\n\t\tntfs_debug(\"Updating ctime for inode 0x%lx: old = 0x%llx, \"\n\t\t\t\t\"new = 0x%llx\", vi->i_ino, (long long)\n\t\t\t\tsle64_to_cpu(si->last_mft_change_time),\n\t\t\t\t(long long)sle64_to_cpu(nt));\n\t\tsi->last_mft_change_time = nt;\n\t\tmodified = true;\n\t}\n\tnt = utc2ntfs(vi->i_atime);\n\tif (si->last_access_time != nt) {\n\t\tntfs_debug(\"Updating atime for inode 0x%lx: old = 0x%llx, \"\n\t\t\t\t\"new = 0x%llx\", vi->i_ino,\n\t\t\t\t(long long)sle64_to_cpu(si->last_access_time),\n\t\t\t\t(long long)sle64_to_cpu(nt));\n\t\tsi->last_access_time = nt;\n\t\tmodified = true;\n\t}\n\t/*\n\t * If we just modified the standard information attribute we need to\n\t * mark the mft record it is in dirty.  We do this manually so that\n\t * mark_inode_dirty() is not called which would redirty the inode and\n\t * hence result in an infinite loop of trying to write the inode.\n\t * There is no need to mark the base inode nor the base mft record\n\t * dirty, since we are going to write this mft record below in any case\n\t * and the base mft record may actually not have been modified so it\n\t * might not need to be written out.\n\t * NOTE: It is not a problem when the inode for $MFT itself is being\n\t * written out as mark_ntfs_record_dirty() will only set I_DIRTY_PAGES\n\t * on the $MFT inode and hence ntfs_write_inode() will not be\n\t * re-invoked because of it which in turn is ok since the dirtied mft\n\t * record will be cleaned and written out to disk below, i.e. before\n\t * this function returns.\n\t */\n\tif (modified) {\n\t\tflush_dcache_mft_record_page(ctx->ntfs_ino);\n\t\tif (!NInoTestSetDirty(ctx->ntfs_ino))\n\t\t\tmark_ntfs_record_dirty(ctx->ntfs_ino->page,\n\t\t\t\t\tctx->ntfs_ino->page_ofs);\n\t}\n\tntfs_attr_put_search_ctx(ctx);\n\t/* Now the access times are updated, write the base mft record. */\n\tif (NInoDirty(ni))\n\t\terr = write_mft_record(ni, m, sync);\n\t/* Write all attached extent mft records. */\n\tmutex_lock(&ni->extent_lock);\n\tif (ni->nr_extents > 0) {\n\t\tntfs_inode **extent_nis = ni->ext.extent_ntfs_inos;\n\t\tint i;\n\n\t\tntfs_debug(\"Writing %i extent inodes.\", ni->nr_extents);\n\t\tfor (i = 0; i < ni->nr_extents; i++) {\n\t\t\tntfs_inode *tni = extent_nis[i];\n\n\t\t\tif (NInoDirty(tni)) {\n\t\t\t\tMFT_RECORD *tm = map_mft_record(tni);\n\t\t\t\tint ret;\n\n\t\t\t\tif (IS_ERR(tm)) {\n\t\t\t\t\tif (!err || err == -ENOMEM)\n\t\t\t\t\t\terr = PTR_ERR(tm);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tret = write_mft_record(tni, tm, sync);\n\t\t\t\tunmap_mft_record(tni);\n\t\t\t\tif (unlikely(ret)) {\n\t\t\t\t\tif (!err || err == -ENOMEM)\n\t\t\t\t\t\terr = ret;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tmutex_unlock(&ni->extent_lock);\n\tunmap_mft_record(ni);\n\tif (unlikely(err))\n\t\tgoto err_out;\n\tntfs_debug(\"Done.\");\n\treturn 0;\nunm_err_out:\n\tunmap_mft_record(ni);\nerr_out:\n\tif (err == -ENOMEM) {\n\t\tntfs_warning(vi->i_sb, \"Not enough memory to write inode.  \"\n\t\t\t\t\"Marking the inode dirty again, so the VFS \"\n\t\t\t\t\"retries later.\");\n\t\tmark_inode_dirty(vi);\n\t} else {\n\t\tntfs_error(vi->i_sb, \"Failed (error %i):  Run chkdsk.\", -err);\n\t\tNVolSetErrors(ni->vol);\n\t}\n\treturn err;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ntfs.h\"\n#include \"malloc.h\"\n#include \"layout.h\"\n#include \"aops.h\"\n#include \"inode.h\"\n#include \"index.h\"\n#include \"debug.h\"\n#include \"dir.h\"\n#include \"usnjrnl.h\"\n#include \"quota.h\"\n#include \"logfile.h\"\n#include \"sysctl.h\"\n#include <linux/bitmap.h>\n#include <linux/moduleparam.h>\n#include <linux/vfs.h>\n#include <linux/buffer_head.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\t/* For bdev_logical_block_size(). */\n#include <linux/spinlock.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/stddef.h>\n\nstatic int ntfs_write_inode(struct inode *vi, struct writeback_control *wbc)\n{\n\treturn __ntfs_write_inode(vi, wbc->sync_mode == WB_SYNC_ALL);\n}"
  },
  {
    "function_name": "ntfs_statfs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/super.c",
    "lines": "2615-2675",
    "snippet": "static int ntfs_statfs(struct dentry *dentry, struct kstatfs *sfs)\n{\n\tstruct super_block *sb = dentry->d_sb;\n\ts64 size;\n\tntfs_volume *vol = NTFS_SB(sb);\n\tntfs_inode *mft_ni = NTFS_I(vol->mft_ino);\n\tpgoff_t max_index;\n\tunsigned long flags;\n\n\tntfs_debug(\"Entering.\");\n\t/* Type of filesystem. */\n\tsfs->f_type   = NTFS_SB_MAGIC;\n\t/* Optimal transfer block size. */\n\tsfs->f_bsize  = PAGE_CACHE_SIZE;\n\t/*\n\t * Total data blocks in filesystem in units of f_bsize and since\n\t * inodes are also stored in data blocs ($MFT is a file) this is just\n\t * the total clusters.\n\t */\n\tsfs->f_blocks = vol->nr_clusters << vol->cluster_size_bits >>\n\t\t\t\tPAGE_CACHE_SHIFT;\n\t/* Free data blocks in filesystem in units of f_bsize. */\n\tsize\t      = get_nr_free_clusters(vol) << vol->cluster_size_bits >>\n\t\t\t\tPAGE_CACHE_SHIFT;\n\tif (size < 0LL)\n\t\tsize = 0LL;\n\t/* Free blocks avail to non-superuser, same as above on NTFS. */\n\tsfs->f_bavail = sfs->f_bfree = size;\n\t/* Serialize accesses to the inode bitmap. */\n\tdown_read(&vol->mftbmp_lock);\n\tread_lock_irqsave(&mft_ni->size_lock, flags);\n\tsize = i_size_read(vol->mft_ino) >> vol->mft_record_size_bits;\n\t/*\n\t * Convert the maximum number of set bits into bytes rounded up, then\n\t * convert into multiples of PAGE_CACHE_SIZE, rounding up so that if we\n\t * have one full and one partial page max_index = 2.\n\t */\n\tmax_index = ((((mft_ni->initialized_size >> vol->mft_record_size_bits)\n\t\t\t+ 7) >> 3) + PAGE_CACHE_SIZE - 1) >> PAGE_CACHE_SHIFT;\n\tread_unlock_irqrestore(&mft_ni->size_lock, flags);\n\t/* Number of inodes in filesystem (at this point in time). */\n\tsfs->f_files = size;\n\t/* Free inodes in fs (based on current total count). */\n\tsfs->f_ffree = __get_nr_free_mft_records(vol, size, max_index);\n\tup_read(&vol->mftbmp_lock);\n\t/*\n\t * File system id. This is extremely *nix flavour dependent and even\n\t * within Linux itself all fs do their own thing. I interpret this to\n\t * mean a unique id associated with the mounted fs and not the id\n\t * associated with the filesystem driver, the latter is already given\n\t * by the filesystem type in sfs->f_type. Thus we use the 64-bit\n\t * volume serial number splitting it into two 32-bit parts. We enter\n\t * the least significant 32-bits in f_fsid[0] and the most significant\n\t * 32-bits in f_fsid[1].\n\t */\n\tsfs->f_fsid.val[0] = vol->serial_no & 0xffffffff;\n\tsfs->f_fsid.val[1] = (vol->serial_no >> 32) & 0xffffffff;\n\t/* Maximum length of filenames. */\n\tsfs->f_namelen\t   = NTFS_MAX_NAME_LEN;\n\treturn 0;\n}",
    "includes": [
      "#include \"ntfs.h\"",
      "#include \"malloc.h\"",
      "#include \"layout.h\"",
      "#include \"aops.h\"",
      "#include \"inode.h\"",
      "#include \"index.h\"",
      "#include \"debug.h\"",
      "#include \"dir.h\"",
      "#include \"usnjrnl.h\"",
      "#include \"quota.h\"",
      "#include \"logfile.h\"",
      "#include \"sysctl.h\"",
      "#include <linux/bitmap.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/vfs.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/blkdev.h>\t/* For bdev_logical_block_size(). */",
      "#include <linux/spinlock.h>",
      "#include <linux/string.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/stddef.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "up_read",
          "args": [
            "&vol->mftbmp_lock"
          ],
          "line": 2659
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__get_nr_free_mft_records",
          "args": [
            "vol",
            "size",
            "max_index"
          ],
          "line": 2658
        },
        "resolved": true,
        "details": {
          "function_name": "__get_nr_free_mft_records",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/super.c",
          "lines": "2549-2595",
          "snippet": "static unsigned long __get_nr_free_mft_records(ntfs_volume *vol,\n\t\ts64 nr_free, const pgoff_t max_index)\n{\n\tstruct address_space *mapping = vol->mftbmp_ino->i_mapping;\n\tstruct page *page;\n\tpgoff_t index;\n\n\tntfs_debug(\"Entering.\");\n\t/* Use multiples of 4 bytes, thus max_size is PAGE_CACHE_SIZE / 4. */\n\tntfs_debug(\"Reading $MFT/$BITMAP, max_index = 0x%lx, max_size = \"\n\t\t\t\"0x%lx.\", max_index, PAGE_CACHE_SIZE / 4);\n\tfor (index = 0; index < max_index; index++) {\n\t\tunsigned long *kaddr;\n\n\t\t/*\n\t\t * Read the page from page cache, getting it from backing store\n\t\t * if necessary, and increment the use count.\n\t\t */\n\t\tpage = read_mapping_page(mapping, index, NULL);\n\t\t/* Ignore pages which errored synchronously. */\n\t\tif (IS_ERR(page)) {\n\t\t\tntfs_debug(\"read_mapping_page() error. Skipping \"\n\t\t\t\t\t\"page (index 0x%lx).\", index);\n\t\t\tnr_free -= PAGE_CACHE_SIZE * 8;\n\t\t\tcontinue;\n\t\t}\n\t\tkaddr = kmap_atomic(page);\n\t\t/*\n\t\t * Subtract the number of set bits. If this\n\t\t * is the last page and it is partial we don't really care as\n\t\t * it just means we do a little extra work but it won't affect\n\t\t * the result as all out of range bytes are set to zero by\n\t\t * ntfs_readpage().\n\t\t */\n\t\tnr_free -= bitmap_weight(kaddr,\n\t\t\t\t\tPAGE_CACHE_SIZE * BITS_PER_BYTE);\n\t\tkunmap_atomic(kaddr);\n\t\tpage_cache_release(page);\n\t}\n\tntfs_debug(\"Finished reading $MFT/$BITMAP, last index = 0x%lx.\",\n\t\t\tindex - 1);\n\t/* If errors occurred we may well have gone below zero, fix this. */\n\tif (nr_free < 0)\n\t\tnr_free = 0;\n\tntfs_debug(\"Exiting.\");\n\treturn nr_free;\n}",
          "includes": [
            "#include \"ntfs.h\"",
            "#include \"malloc.h\"",
            "#include \"layout.h\"",
            "#include \"aops.h\"",
            "#include \"inode.h\"",
            "#include \"index.h\"",
            "#include \"debug.h\"",
            "#include \"dir.h\"",
            "#include \"usnjrnl.h\"",
            "#include \"quota.h\"",
            "#include \"logfile.h\"",
            "#include \"sysctl.h\"",
            "#include <linux/bitmap.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/vfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>\t/* For bdev_logical_block_size(). */",
            "#include <linux/spinlock.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ntfs.h\"\n#include \"malloc.h\"\n#include \"layout.h\"\n#include \"aops.h\"\n#include \"inode.h\"\n#include \"index.h\"\n#include \"debug.h\"\n#include \"dir.h\"\n#include \"usnjrnl.h\"\n#include \"quota.h\"\n#include \"logfile.h\"\n#include \"sysctl.h\"\n#include <linux/bitmap.h>\n#include <linux/moduleparam.h>\n#include <linux/vfs.h>\n#include <linux/buffer_head.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\t/* For bdev_logical_block_size(). */\n#include <linux/spinlock.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/stddef.h>\n\nstatic unsigned long __get_nr_free_mft_records(ntfs_volume *vol,\n\t\ts64 nr_free, const pgoff_t max_index)\n{\n\tstruct address_space *mapping = vol->mftbmp_ino->i_mapping;\n\tstruct page *page;\n\tpgoff_t index;\n\n\tntfs_debug(\"Entering.\");\n\t/* Use multiples of 4 bytes, thus max_size is PAGE_CACHE_SIZE / 4. */\n\tntfs_debug(\"Reading $MFT/$BITMAP, max_index = 0x%lx, max_size = \"\n\t\t\t\"0x%lx.\", max_index, PAGE_CACHE_SIZE / 4);\n\tfor (index = 0; index < max_index; index++) {\n\t\tunsigned long *kaddr;\n\n\t\t/*\n\t\t * Read the page from page cache, getting it from backing store\n\t\t * if necessary, and increment the use count.\n\t\t */\n\t\tpage = read_mapping_page(mapping, index, NULL);\n\t\t/* Ignore pages which errored synchronously. */\n\t\tif (IS_ERR(page)) {\n\t\t\tntfs_debug(\"read_mapping_page() error. Skipping \"\n\t\t\t\t\t\"page (index 0x%lx).\", index);\n\t\t\tnr_free -= PAGE_CACHE_SIZE * 8;\n\t\t\tcontinue;\n\t\t}\n\t\tkaddr = kmap_atomic(page);\n\t\t/*\n\t\t * Subtract the number of set bits. If this\n\t\t * is the last page and it is partial we don't really care as\n\t\t * it just means we do a little extra work but it won't affect\n\t\t * the result as all out of range bytes are set to zero by\n\t\t * ntfs_readpage().\n\t\t */\n\t\tnr_free -= bitmap_weight(kaddr,\n\t\t\t\t\tPAGE_CACHE_SIZE * BITS_PER_BYTE);\n\t\tkunmap_atomic(kaddr);\n\t\tpage_cache_release(page);\n\t}\n\tntfs_debug(\"Finished reading $MFT/$BITMAP, last index = 0x%lx.\",\n\t\t\tindex - 1);\n\t/* If errors occurred we may well have gone below zero, fix this. */\n\tif (nr_free < 0)\n\t\tnr_free = 0;\n\tntfs_debug(\"Exiting.\");\n\treturn nr_free;\n}"
        }
      },
      {
        "call_info": {
          "callee": "read_unlock_irqrestore",
          "args": [
            "&mft_ni->size_lock",
            "flags"
          ],
          "line": 2654
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "i_size_read",
          "args": [
            "vol->mft_ino"
          ],
          "line": 2646
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "read_lock_irqsave",
          "args": [
            "&mft_ni->size_lock",
            "flags"
          ],
          "line": 2645
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "down_read",
          "args": [
            "&vol->mftbmp_lock"
          ],
          "line": 2644
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_nr_free_clusters",
          "args": [
            "vol"
          ],
          "line": 2637
        },
        "resolved": true,
        "details": {
          "function_name": "get_nr_free_clusters",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/super.c",
          "lines": "2469-2530",
          "snippet": "static s64 get_nr_free_clusters(ntfs_volume *vol)\n{\n\ts64 nr_free = vol->nr_clusters;\n\tstruct address_space *mapping = vol->lcnbmp_ino->i_mapping;\n\tstruct page *page;\n\tpgoff_t index, max_index;\n\n\tntfs_debug(\"Entering.\");\n\t/* Serialize accesses to the cluster bitmap. */\n\tdown_read(&vol->lcnbmp_lock);\n\t/*\n\t * Convert the number of bits into bytes rounded up, then convert into\n\t * multiples of PAGE_CACHE_SIZE, rounding up so that if we have one\n\t * full and one partial page max_index = 2.\n\t */\n\tmax_index = (((vol->nr_clusters + 7) >> 3) + PAGE_CACHE_SIZE - 1) >>\n\t\t\tPAGE_CACHE_SHIFT;\n\t/* Use multiples of 4 bytes, thus max_size is PAGE_CACHE_SIZE / 4. */\n\tntfs_debug(\"Reading $Bitmap, max_index = 0x%lx, max_size = 0x%lx.\",\n\t\t\tmax_index, PAGE_CACHE_SIZE / 4);\n\tfor (index = 0; index < max_index; index++) {\n\t\tunsigned long *kaddr;\n\n\t\t/*\n\t\t * Read the page from page cache, getting it from backing store\n\t\t * if necessary, and increment the use count.\n\t\t */\n\t\tpage = read_mapping_page(mapping, index, NULL);\n\t\t/* Ignore pages which errored synchronously. */\n\t\tif (IS_ERR(page)) {\n\t\t\tntfs_debug(\"read_mapping_page() error. Skipping \"\n\t\t\t\t\t\"page (index 0x%lx).\", index);\n\t\t\tnr_free -= PAGE_CACHE_SIZE * 8;\n\t\t\tcontinue;\n\t\t}\n\t\tkaddr = kmap_atomic(page);\n\t\t/*\n\t\t * Subtract the number of set bits. If this\n\t\t * is the last page and it is partial we don't really care as\n\t\t * it just means we do a little extra work but it won't affect\n\t\t * the result as all out of range bytes are set to zero by\n\t\t * ntfs_readpage().\n\t\t */\n\t\tnr_free -= bitmap_weight(kaddr,\n\t\t\t\t\tPAGE_CACHE_SIZE * BITS_PER_BYTE);\n\t\tkunmap_atomic(kaddr);\n\t\tpage_cache_release(page);\n\t}\n\tntfs_debug(\"Finished reading $Bitmap, last index = 0x%lx.\", index - 1);\n\t/*\n\t * Fixup for eventual bits outside logical ntfs volume (see function\n\t * description above).\n\t */\n\tif (vol->nr_clusters & 63)\n\t\tnr_free += 64 - (vol->nr_clusters & 63);\n\tup_read(&vol->lcnbmp_lock);\n\t/* If errors occurred we may well have gone below zero, fix this. */\n\tif (nr_free < 0)\n\t\tnr_free = 0;\n\tntfs_debug(\"Exiting.\");\n\treturn nr_free;\n}",
          "includes": [
            "#include \"ntfs.h\"",
            "#include \"malloc.h\"",
            "#include \"layout.h\"",
            "#include \"aops.h\"",
            "#include \"inode.h\"",
            "#include \"index.h\"",
            "#include \"debug.h\"",
            "#include \"dir.h\"",
            "#include \"usnjrnl.h\"",
            "#include \"quota.h\"",
            "#include \"logfile.h\"",
            "#include \"sysctl.h\"",
            "#include <linux/bitmap.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/vfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>\t/* For bdev_logical_block_size(). */",
            "#include <linux/spinlock.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ntfs.h\"\n#include \"malloc.h\"\n#include \"layout.h\"\n#include \"aops.h\"\n#include \"inode.h\"\n#include \"index.h\"\n#include \"debug.h\"\n#include \"dir.h\"\n#include \"usnjrnl.h\"\n#include \"quota.h\"\n#include \"logfile.h\"\n#include \"sysctl.h\"\n#include <linux/bitmap.h>\n#include <linux/moduleparam.h>\n#include <linux/vfs.h>\n#include <linux/buffer_head.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\t/* For bdev_logical_block_size(). */\n#include <linux/spinlock.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/stddef.h>\n\nstatic s64 get_nr_free_clusters(ntfs_volume *vol)\n{\n\ts64 nr_free = vol->nr_clusters;\n\tstruct address_space *mapping = vol->lcnbmp_ino->i_mapping;\n\tstruct page *page;\n\tpgoff_t index, max_index;\n\n\tntfs_debug(\"Entering.\");\n\t/* Serialize accesses to the cluster bitmap. */\n\tdown_read(&vol->lcnbmp_lock);\n\t/*\n\t * Convert the number of bits into bytes rounded up, then convert into\n\t * multiples of PAGE_CACHE_SIZE, rounding up so that if we have one\n\t * full and one partial page max_index = 2.\n\t */\n\tmax_index = (((vol->nr_clusters + 7) >> 3) + PAGE_CACHE_SIZE - 1) >>\n\t\t\tPAGE_CACHE_SHIFT;\n\t/* Use multiples of 4 bytes, thus max_size is PAGE_CACHE_SIZE / 4. */\n\tntfs_debug(\"Reading $Bitmap, max_index = 0x%lx, max_size = 0x%lx.\",\n\t\t\tmax_index, PAGE_CACHE_SIZE / 4);\n\tfor (index = 0; index < max_index; index++) {\n\t\tunsigned long *kaddr;\n\n\t\t/*\n\t\t * Read the page from page cache, getting it from backing store\n\t\t * if necessary, and increment the use count.\n\t\t */\n\t\tpage = read_mapping_page(mapping, index, NULL);\n\t\t/* Ignore pages which errored synchronously. */\n\t\tif (IS_ERR(page)) {\n\t\t\tntfs_debug(\"read_mapping_page() error. Skipping \"\n\t\t\t\t\t\"page (index 0x%lx).\", index);\n\t\t\tnr_free -= PAGE_CACHE_SIZE * 8;\n\t\t\tcontinue;\n\t\t}\n\t\tkaddr = kmap_atomic(page);\n\t\t/*\n\t\t * Subtract the number of set bits. If this\n\t\t * is the last page and it is partial we don't really care as\n\t\t * it just means we do a little extra work but it won't affect\n\t\t * the result as all out of range bytes are set to zero by\n\t\t * ntfs_readpage().\n\t\t */\n\t\tnr_free -= bitmap_weight(kaddr,\n\t\t\t\t\tPAGE_CACHE_SIZE * BITS_PER_BYTE);\n\t\tkunmap_atomic(kaddr);\n\t\tpage_cache_release(page);\n\t}\n\tntfs_debug(\"Finished reading $Bitmap, last index = 0x%lx.\", index - 1);\n\t/*\n\t * Fixup for eventual bits outside logical ntfs volume (see function\n\t * description above).\n\t */\n\tif (vol->nr_clusters & 63)\n\t\tnr_free += 64 - (vol->nr_clusters & 63);\n\tup_read(&vol->lcnbmp_lock);\n\t/* If errors occurred we may well have gone below zero, fix this. */\n\tif (nr_free < 0)\n\t\tnr_free = 0;\n\tntfs_debug(\"Exiting.\");\n\treturn nr_free;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ntfs_debug",
          "args": [
            "\"Entering.\""
          ],
          "line": 2624
        },
        "resolved": true,
        "details": {
          "function_name": "ntfs_debug_dump_runlist",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/debug.c",
          "lines": "134-171",
          "snippet": "void ntfs_debug_dump_runlist(const runlist_element *rl)\n{\n\tint i;\n\tconst char *lcn_str[5] = { \"LCN_HOLE         \", \"LCN_RL_NOT_MAPPED\",\n\t\t\t\t   \"LCN_ENOENT       \", \"LCN_unknown      \" };\n\n\tif (!debug_msgs)\n\t\treturn;\n\tpr_debug(\"Dumping runlist (values in hex):\\n\");\n\tif (!rl) {\n\t\tpr_debug(\"Run list not present.\\n\");\n\t\treturn;\n\t}\n\tpr_debug(\"VCN              LCN               Run length\\n\");\n\tfor (i = 0; ; i++) {\n\t\tLCN lcn = (rl + i)->lcn;\n\n\t\tif (lcn < (LCN)0) {\n\t\t\tint index = -lcn - 1;\n\n\t\t\tif (index > -LCN_ENOENT - 1)\n\t\t\t\tindex = 3;\n\t\t\tpr_debug(\"%-16Lx %s %-16Lx%s\\n\",\n\t\t\t\t\t(long long)(rl + i)->vcn, lcn_str[index],\n\t\t\t\t\t(long long)(rl + i)->length,\n\t\t\t\t\t(rl + i)->length ? \"\" :\n\t\t\t\t\t\t\" (runlist end)\");\n\t\t} else\n\t\t\tpr_debug(\"%-16Lx %-16Lx  %-16Lx%s\\n\",\n\t\t\t\t\t(long long)(rl + i)->vcn,\n\t\t\t\t\t(long long)(rl + i)->lcn,\n\t\t\t\t\t(long long)(rl + i)->length,\n\t\t\t\t\t(rl + i)->length ? \"\" :\n\t\t\t\t\t\t\" (runlist end)\");\n\t\tif (!(rl + i)->length)\n\t\t\tbreak;\n\t}\n}",
          "includes": [
            "#include \"debug.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"debug.h\"\n\nvoid ntfs_debug_dump_runlist(const runlist_element *rl)\n{\n\tint i;\n\tconst char *lcn_str[5] = { \"LCN_HOLE         \", \"LCN_RL_NOT_MAPPED\",\n\t\t\t\t   \"LCN_ENOENT       \", \"LCN_unknown      \" };\n\n\tif (!debug_msgs)\n\t\treturn;\n\tpr_debug(\"Dumping runlist (values in hex):\\n\");\n\tif (!rl) {\n\t\tpr_debug(\"Run list not present.\\n\");\n\t\treturn;\n\t}\n\tpr_debug(\"VCN              LCN               Run length\\n\");\n\tfor (i = 0; ; i++) {\n\t\tLCN lcn = (rl + i)->lcn;\n\n\t\tif (lcn < (LCN)0) {\n\t\t\tint index = -lcn - 1;\n\n\t\t\tif (index > -LCN_ENOENT - 1)\n\t\t\t\tindex = 3;\n\t\t\tpr_debug(\"%-16Lx %s %-16Lx%s\\n\",\n\t\t\t\t\t(long long)(rl + i)->vcn, lcn_str[index],\n\t\t\t\t\t(long long)(rl + i)->length,\n\t\t\t\t\t(rl + i)->length ? \"\" :\n\t\t\t\t\t\t\" (runlist end)\");\n\t\t} else\n\t\t\tpr_debug(\"%-16Lx %-16Lx  %-16Lx%s\\n\",\n\t\t\t\t\t(long long)(rl + i)->vcn,\n\t\t\t\t\t(long long)(rl + i)->lcn,\n\t\t\t\t\t(long long)(rl + i)->length,\n\t\t\t\t\t(rl + i)->length ? \"\" :\n\t\t\t\t\t\t\" (runlist end)\");\n\t\tif (!(rl + i)->length)\n\t\t\tbreak;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "NTFS_I",
          "args": [
            "vol->mft_ino"
          ],
          "line": 2620
        },
        "resolved": true,
        "details": {
          "function_name": "NTFS_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/inode.h",
          "lines": "240-243",
          "snippet": "static inline ntfs_inode *NTFS_I(struct inode *inode)\n{\n\treturn (ntfs_inode *)list_entry(inode, big_ntfs_inode, vfs_inode);\n}",
          "includes": [
            "#include \"debug.h\"",
            "#include \"runlist.h\"",
            "#include \"types.h\"",
            "#include \"volume.h\"",
            "#include \"layout.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/mutex.h>",
            "#include <linux/mm.h>",
            "#include <linux/list.h>",
            "#include <linux/fs.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"debug.h\"\n#include \"runlist.h\"\n#include \"types.h\"\n#include \"volume.h\"\n#include \"layout.h\"\n#include <linux/seq_file.h>\n#include <linux/mutex.h>\n#include <linux/mm.h>\n#include <linux/list.h>\n#include <linux/fs.h>\n#include <linux/atomic.h>\n\nstatic inline ntfs_inode *NTFS_I(struct inode *inode)\n{\n\treturn (ntfs_inode *)list_entry(inode, big_ntfs_inode, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "NTFS_SB",
          "args": [
            "sb"
          ],
          "line": 2619
        },
        "resolved": true,
        "details": {
          "function_name": "NTFS_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/ntfs.h",
          "lines": "80-83",
          "snippet": "static inline ntfs_volume *NTFS_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"layout.h\"",
            "#include \"volume.h\"",
            "#include \"types.h\"",
            "#include <linux/pagemap.h>",
            "#include <linux/smp.h>",
            "#include <linux/nls.h>",
            "#include <linux/fs.h>",
            "#include <linux/compiler.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"layout.h\"\n#include \"volume.h\"\n#include \"types.h\"\n#include <linux/pagemap.h>\n#include <linux/smp.h>\n#include <linux/nls.h>\n#include <linux/fs.h>\n#include <linux/compiler.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/stddef.h>\n\nstatic inline ntfs_volume *NTFS_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ntfs.h\"\n#include \"malloc.h\"\n#include \"layout.h\"\n#include \"aops.h\"\n#include \"inode.h\"\n#include \"index.h\"\n#include \"debug.h\"\n#include \"dir.h\"\n#include \"usnjrnl.h\"\n#include \"quota.h\"\n#include \"logfile.h\"\n#include \"sysctl.h\"\n#include <linux/bitmap.h>\n#include <linux/moduleparam.h>\n#include <linux/vfs.h>\n#include <linux/buffer_head.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\t/* For bdev_logical_block_size(). */\n#include <linux/spinlock.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/stddef.h>\n\nstatic int ntfs_statfs(struct dentry *dentry, struct kstatfs *sfs)\n{\n\tstruct super_block *sb = dentry->d_sb;\n\ts64 size;\n\tntfs_volume *vol = NTFS_SB(sb);\n\tntfs_inode *mft_ni = NTFS_I(vol->mft_ino);\n\tpgoff_t max_index;\n\tunsigned long flags;\n\n\tntfs_debug(\"Entering.\");\n\t/* Type of filesystem. */\n\tsfs->f_type   = NTFS_SB_MAGIC;\n\t/* Optimal transfer block size. */\n\tsfs->f_bsize  = PAGE_CACHE_SIZE;\n\t/*\n\t * Total data blocks in filesystem in units of f_bsize and since\n\t * inodes are also stored in data blocs ($MFT is a file) this is just\n\t * the total clusters.\n\t */\n\tsfs->f_blocks = vol->nr_clusters << vol->cluster_size_bits >>\n\t\t\t\tPAGE_CACHE_SHIFT;\n\t/* Free data blocks in filesystem in units of f_bsize. */\n\tsize\t      = get_nr_free_clusters(vol) << vol->cluster_size_bits >>\n\t\t\t\tPAGE_CACHE_SHIFT;\n\tif (size < 0LL)\n\t\tsize = 0LL;\n\t/* Free blocks avail to non-superuser, same as above on NTFS. */\n\tsfs->f_bavail = sfs->f_bfree = size;\n\t/* Serialize accesses to the inode bitmap. */\n\tdown_read(&vol->mftbmp_lock);\n\tread_lock_irqsave(&mft_ni->size_lock, flags);\n\tsize = i_size_read(vol->mft_ino) >> vol->mft_record_size_bits;\n\t/*\n\t * Convert the maximum number of set bits into bytes rounded up, then\n\t * convert into multiples of PAGE_CACHE_SIZE, rounding up so that if we\n\t * have one full and one partial page max_index = 2.\n\t */\n\tmax_index = ((((mft_ni->initialized_size >> vol->mft_record_size_bits)\n\t\t\t+ 7) >> 3) + PAGE_CACHE_SIZE - 1) >> PAGE_CACHE_SHIFT;\n\tread_unlock_irqrestore(&mft_ni->size_lock, flags);\n\t/* Number of inodes in filesystem (at this point in time). */\n\tsfs->f_files = size;\n\t/* Free inodes in fs (based on current total count). */\n\tsfs->f_ffree = __get_nr_free_mft_records(vol, size, max_index);\n\tup_read(&vol->mftbmp_lock);\n\t/*\n\t * File system id. This is extremely *nix flavour dependent and even\n\t * within Linux itself all fs do their own thing. I interpret this to\n\t * mean a unique id associated with the mounted fs and not the id\n\t * associated with the filesystem driver, the latter is already given\n\t * by the filesystem type in sfs->f_type. Thus we use the 64-bit\n\t * volume serial number splitting it into two 32-bit parts. We enter\n\t * the least significant 32-bits in f_fsid[0] and the most significant\n\t * 32-bits in f_fsid[1].\n\t */\n\tsfs->f_fsid.val[0] = vol->serial_no & 0xffffffff;\n\tsfs->f_fsid.val[1] = (vol->serial_no >> 32) & 0xffffffff;\n\t/* Maximum length of filenames. */\n\tsfs->f_namelen\t   = NTFS_MAX_NAME_LEN;\n\treturn 0;\n}"
  },
  {
    "function_name": "__get_nr_free_mft_records",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/super.c",
    "lines": "2549-2595",
    "snippet": "static unsigned long __get_nr_free_mft_records(ntfs_volume *vol,\n\t\ts64 nr_free, const pgoff_t max_index)\n{\n\tstruct address_space *mapping = vol->mftbmp_ino->i_mapping;\n\tstruct page *page;\n\tpgoff_t index;\n\n\tntfs_debug(\"Entering.\");\n\t/* Use multiples of 4 bytes, thus max_size is PAGE_CACHE_SIZE / 4. */\n\tntfs_debug(\"Reading $MFT/$BITMAP, max_index = 0x%lx, max_size = \"\n\t\t\t\"0x%lx.\", max_index, PAGE_CACHE_SIZE / 4);\n\tfor (index = 0; index < max_index; index++) {\n\t\tunsigned long *kaddr;\n\n\t\t/*\n\t\t * Read the page from page cache, getting it from backing store\n\t\t * if necessary, and increment the use count.\n\t\t */\n\t\tpage = read_mapping_page(mapping, index, NULL);\n\t\t/* Ignore pages which errored synchronously. */\n\t\tif (IS_ERR(page)) {\n\t\t\tntfs_debug(\"read_mapping_page() error. Skipping \"\n\t\t\t\t\t\"page (index 0x%lx).\", index);\n\t\t\tnr_free -= PAGE_CACHE_SIZE * 8;\n\t\t\tcontinue;\n\t\t}\n\t\tkaddr = kmap_atomic(page);\n\t\t/*\n\t\t * Subtract the number of set bits. If this\n\t\t * is the last page and it is partial we don't really care as\n\t\t * it just means we do a little extra work but it won't affect\n\t\t * the result as all out of range bytes are set to zero by\n\t\t * ntfs_readpage().\n\t\t */\n\t\tnr_free -= bitmap_weight(kaddr,\n\t\t\t\t\tPAGE_CACHE_SIZE * BITS_PER_BYTE);\n\t\tkunmap_atomic(kaddr);\n\t\tpage_cache_release(page);\n\t}\n\tntfs_debug(\"Finished reading $MFT/$BITMAP, last index = 0x%lx.\",\n\t\t\tindex - 1);\n\t/* If errors occurred we may well have gone below zero, fix this. */\n\tif (nr_free < 0)\n\t\tnr_free = 0;\n\tntfs_debug(\"Exiting.\");\n\treturn nr_free;\n}",
    "includes": [
      "#include \"ntfs.h\"",
      "#include \"malloc.h\"",
      "#include \"layout.h\"",
      "#include \"aops.h\"",
      "#include \"inode.h\"",
      "#include \"index.h\"",
      "#include \"debug.h\"",
      "#include \"dir.h\"",
      "#include \"usnjrnl.h\"",
      "#include \"quota.h\"",
      "#include \"logfile.h\"",
      "#include \"sysctl.h\"",
      "#include <linux/bitmap.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/vfs.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/blkdev.h>\t/* For bdev_logical_block_size(). */",
      "#include <linux/spinlock.h>",
      "#include <linux/string.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/stddef.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ntfs_debug",
          "args": [
            "\"Exiting.\""
          ],
          "line": 2593
        },
        "resolved": true,
        "details": {
          "function_name": "ntfs_debug_dump_runlist",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/debug.c",
          "lines": "134-171",
          "snippet": "void ntfs_debug_dump_runlist(const runlist_element *rl)\n{\n\tint i;\n\tconst char *lcn_str[5] = { \"LCN_HOLE         \", \"LCN_RL_NOT_MAPPED\",\n\t\t\t\t   \"LCN_ENOENT       \", \"LCN_unknown      \" };\n\n\tif (!debug_msgs)\n\t\treturn;\n\tpr_debug(\"Dumping runlist (values in hex):\\n\");\n\tif (!rl) {\n\t\tpr_debug(\"Run list not present.\\n\");\n\t\treturn;\n\t}\n\tpr_debug(\"VCN              LCN               Run length\\n\");\n\tfor (i = 0; ; i++) {\n\t\tLCN lcn = (rl + i)->lcn;\n\n\t\tif (lcn < (LCN)0) {\n\t\t\tint index = -lcn - 1;\n\n\t\t\tif (index > -LCN_ENOENT - 1)\n\t\t\t\tindex = 3;\n\t\t\tpr_debug(\"%-16Lx %s %-16Lx%s\\n\",\n\t\t\t\t\t(long long)(rl + i)->vcn, lcn_str[index],\n\t\t\t\t\t(long long)(rl + i)->length,\n\t\t\t\t\t(rl + i)->length ? \"\" :\n\t\t\t\t\t\t\" (runlist end)\");\n\t\t} else\n\t\t\tpr_debug(\"%-16Lx %-16Lx  %-16Lx%s\\n\",\n\t\t\t\t\t(long long)(rl + i)->vcn,\n\t\t\t\t\t(long long)(rl + i)->lcn,\n\t\t\t\t\t(long long)(rl + i)->length,\n\t\t\t\t\t(rl + i)->length ? \"\" :\n\t\t\t\t\t\t\" (runlist end)\");\n\t\tif (!(rl + i)->length)\n\t\t\tbreak;\n\t}\n}",
          "includes": [
            "#include \"debug.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"debug.h\"\n\nvoid ntfs_debug_dump_runlist(const runlist_element *rl)\n{\n\tint i;\n\tconst char *lcn_str[5] = { \"LCN_HOLE         \", \"LCN_RL_NOT_MAPPED\",\n\t\t\t\t   \"LCN_ENOENT       \", \"LCN_unknown      \" };\n\n\tif (!debug_msgs)\n\t\treturn;\n\tpr_debug(\"Dumping runlist (values in hex):\\n\");\n\tif (!rl) {\n\t\tpr_debug(\"Run list not present.\\n\");\n\t\treturn;\n\t}\n\tpr_debug(\"VCN              LCN               Run length\\n\");\n\tfor (i = 0; ; i++) {\n\t\tLCN lcn = (rl + i)->lcn;\n\n\t\tif (lcn < (LCN)0) {\n\t\t\tint index = -lcn - 1;\n\n\t\t\tif (index > -LCN_ENOENT - 1)\n\t\t\t\tindex = 3;\n\t\t\tpr_debug(\"%-16Lx %s %-16Lx%s\\n\",\n\t\t\t\t\t(long long)(rl + i)->vcn, lcn_str[index],\n\t\t\t\t\t(long long)(rl + i)->length,\n\t\t\t\t\t(rl + i)->length ? \"\" :\n\t\t\t\t\t\t\" (runlist end)\");\n\t\t} else\n\t\t\tpr_debug(\"%-16Lx %-16Lx  %-16Lx%s\\n\",\n\t\t\t\t\t(long long)(rl + i)->vcn,\n\t\t\t\t\t(long long)(rl + i)->lcn,\n\t\t\t\t\t(long long)(rl + i)->length,\n\t\t\t\t\t(rl + i)->length ? \"\" :\n\t\t\t\t\t\t\" (runlist end)\");\n\t\tif (!(rl + i)->length)\n\t\t\tbreak;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ntfs_debug",
          "args": [
            "\"Finished reading $MFT/$BITMAP, last index = 0x%lx.\"",
            "index - 1"
          ],
          "line": 2588
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_cache_release",
          "args": [
            "page"
          ],
          "line": 2586
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kunmap_atomic",
          "args": [
            "kaddr"
          ],
          "line": 2585
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bitmap_weight",
          "args": [
            "kaddr",
            "PAGE_CACHE_SIZE * BITS_PER_BYTE"
          ],
          "line": 2583
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmap_atomic",
          "args": [
            "page"
          ],
          "line": 2575
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_debug",
          "args": [
            "\"read_mapping_page() error. Skipping \"\n\t\t\t\t\t\"page (index 0x%lx).\"",
            "index"
          ],
          "line": 2570
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "page"
          ],
          "line": 2569
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "read_mapping_page",
          "args": [
            "mapping",
            "index",
            "NULL"
          ],
          "line": 2567
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_debug",
          "args": [
            "\"Reading $MFT/$BITMAP, max_index = 0x%lx, max_size = \"\n\t\t\t\"0x%lx.\"",
            "max_index",
            "PAGE_CACHE_SIZE / 4"
          ],
          "line": 2558
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ntfs.h\"\n#include \"malloc.h\"\n#include \"layout.h\"\n#include \"aops.h\"\n#include \"inode.h\"\n#include \"index.h\"\n#include \"debug.h\"\n#include \"dir.h\"\n#include \"usnjrnl.h\"\n#include \"quota.h\"\n#include \"logfile.h\"\n#include \"sysctl.h\"\n#include <linux/bitmap.h>\n#include <linux/moduleparam.h>\n#include <linux/vfs.h>\n#include <linux/buffer_head.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\t/* For bdev_logical_block_size(). */\n#include <linux/spinlock.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/stddef.h>\n\nstatic unsigned long __get_nr_free_mft_records(ntfs_volume *vol,\n\t\ts64 nr_free, const pgoff_t max_index)\n{\n\tstruct address_space *mapping = vol->mftbmp_ino->i_mapping;\n\tstruct page *page;\n\tpgoff_t index;\n\n\tntfs_debug(\"Entering.\");\n\t/* Use multiples of 4 bytes, thus max_size is PAGE_CACHE_SIZE / 4. */\n\tntfs_debug(\"Reading $MFT/$BITMAP, max_index = 0x%lx, max_size = \"\n\t\t\t\"0x%lx.\", max_index, PAGE_CACHE_SIZE / 4);\n\tfor (index = 0; index < max_index; index++) {\n\t\tunsigned long *kaddr;\n\n\t\t/*\n\t\t * Read the page from page cache, getting it from backing store\n\t\t * if necessary, and increment the use count.\n\t\t */\n\t\tpage = read_mapping_page(mapping, index, NULL);\n\t\t/* Ignore pages which errored synchronously. */\n\t\tif (IS_ERR(page)) {\n\t\t\tntfs_debug(\"read_mapping_page() error. Skipping \"\n\t\t\t\t\t\"page (index 0x%lx).\", index);\n\t\t\tnr_free -= PAGE_CACHE_SIZE * 8;\n\t\t\tcontinue;\n\t\t}\n\t\tkaddr = kmap_atomic(page);\n\t\t/*\n\t\t * Subtract the number of set bits. If this\n\t\t * is the last page and it is partial we don't really care as\n\t\t * it just means we do a little extra work but it won't affect\n\t\t * the result as all out of range bytes are set to zero by\n\t\t * ntfs_readpage().\n\t\t */\n\t\tnr_free -= bitmap_weight(kaddr,\n\t\t\t\t\tPAGE_CACHE_SIZE * BITS_PER_BYTE);\n\t\tkunmap_atomic(kaddr);\n\t\tpage_cache_release(page);\n\t}\n\tntfs_debug(\"Finished reading $MFT/$BITMAP, last index = 0x%lx.\",\n\t\t\tindex - 1);\n\t/* If errors occurred we may well have gone below zero, fix this. */\n\tif (nr_free < 0)\n\t\tnr_free = 0;\n\tntfs_debug(\"Exiting.\");\n\treturn nr_free;\n}"
  },
  {
    "function_name": "get_nr_free_clusters",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/super.c",
    "lines": "2469-2530",
    "snippet": "static s64 get_nr_free_clusters(ntfs_volume *vol)\n{\n\ts64 nr_free = vol->nr_clusters;\n\tstruct address_space *mapping = vol->lcnbmp_ino->i_mapping;\n\tstruct page *page;\n\tpgoff_t index, max_index;\n\n\tntfs_debug(\"Entering.\");\n\t/* Serialize accesses to the cluster bitmap. */\n\tdown_read(&vol->lcnbmp_lock);\n\t/*\n\t * Convert the number of bits into bytes rounded up, then convert into\n\t * multiples of PAGE_CACHE_SIZE, rounding up so that if we have one\n\t * full and one partial page max_index = 2.\n\t */\n\tmax_index = (((vol->nr_clusters + 7) >> 3) + PAGE_CACHE_SIZE - 1) >>\n\t\t\tPAGE_CACHE_SHIFT;\n\t/* Use multiples of 4 bytes, thus max_size is PAGE_CACHE_SIZE / 4. */\n\tntfs_debug(\"Reading $Bitmap, max_index = 0x%lx, max_size = 0x%lx.\",\n\t\t\tmax_index, PAGE_CACHE_SIZE / 4);\n\tfor (index = 0; index < max_index; index++) {\n\t\tunsigned long *kaddr;\n\n\t\t/*\n\t\t * Read the page from page cache, getting it from backing store\n\t\t * if necessary, and increment the use count.\n\t\t */\n\t\tpage = read_mapping_page(mapping, index, NULL);\n\t\t/* Ignore pages which errored synchronously. */\n\t\tif (IS_ERR(page)) {\n\t\t\tntfs_debug(\"read_mapping_page() error. Skipping \"\n\t\t\t\t\t\"page (index 0x%lx).\", index);\n\t\t\tnr_free -= PAGE_CACHE_SIZE * 8;\n\t\t\tcontinue;\n\t\t}\n\t\tkaddr = kmap_atomic(page);\n\t\t/*\n\t\t * Subtract the number of set bits. If this\n\t\t * is the last page and it is partial we don't really care as\n\t\t * it just means we do a little extra work but it won't affect\n\t\t * the result as all out of range bytes are set to zero by\n\t\t * ntfs_readpage().\n\t\t */\n\t\tnr_free -= bitmap_weight(kaddr,\n\t\t\t\t\tPAGE_CACHE_SIZE * BITS_PER_BYTE);\n\t\tkunmap_atomic(kaddr);\n\t\tpage_cache_release(page);\n\t}\n\tntfs_debug(\"Finished reading $Bitmap, last index = 0x%lx.\", index - 1);\n\t/*\n\t * Fixup for eventual bits outside logical ntfs volume (see function\n\t * description above).\n\t */\n\tif (vol->nr_clusters & 63)\n\t\tnr_free += 64 - (vol->nr_clusters & 63);\n\tup_read(&vol->lcnbmp_lock);\n\t/* If errors occurred we may well have gone below zero, fix this. */\n\tif (nr_free < 0)\n\t\tnr_free = 0;\n\tntfs_debug(\"Exiting.\");\n\treturn nr_free;\n}",
    "includes": [
      "#include \"ntfs.h\"",
      "#include \"malloc.h\"",
      "#include \"layout.h\"",
      "#include \"aops.h\"",
      "#include \"inode.h\"",
      "#include \"index.h\"",
      "#include \"debug.h\"",
      "#include \"dir.h\"",
      "#include \"usnjrnl.h\"",
      "#include \"quota.h\"",
      "#include \"logfile.h\"",
      "#include \"sysctl.h\"",
      "#include <linux/bitmap.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/vfs.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/blkdev.h>\t/* For bdev_logical_block_size(). */",
      "#include <linux/spinlock.h>",
      "#include <linux/string.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/stddef.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ntfs_debug",
          "args": [
            "\"Exiting.\""
          ],
          "line": 2528
        },
        "resolved": true,
        "details": {
          "function_name": "ntfs_debug_dump_runlist",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/debug.c",
          "lines": "134-171",
          "snippet": "void ntfs_debug_dump_runlist(const runlist_element *rl)\n{\n\tint i;\n\tconst char *lcn_str[5] = { \"LCN_HOLE         \", \"LCN_RL_NOT_MAPPED\",\n\t\t\t\t   \"LCN_ENOENT       \", \"LCN_unknown      \" };\n\n\tif (!debug_msgs)\n\t\treturn;\n\tpr_debug(\"Dumping runlist (values in hex):\\n\");\n\tif (!rl) {\n\t\tpr_debug(\"Run list not present.\\n\");\n\t\treturn;\n\t}\n\tpr_debug(\"VCN              LCN               Run length\\n\");\n\tfor (i = 0; ; i++) {\n\t\tLCN lcn = (rl + i)->lcn;\n\n\t\tif (lcn < (LCN)0) {\n\t\t\tint index = -lcn - 1;\n\n\t\t\tif (index > -LCN_ENOENT - 1)\n\t\t\t\tindex = 3;\n\t\t\tpr_debug(\"%-16Lx %s %-16Lx%s\\n\",\n\t\t\t\t\t(long long)(rl + i)->vcn, lcn_str[index],\n\t\t\t\t\t(long long)(rl + i)->length,\n\t\t\t\t\t(rl + i)->length ? \"\" :\n\t\t\t\t\t\t\" (runlist end)\");\n\t\t} else\n\t\t\tpr_debug(\"%-16Lx %-16Lx  %-16Lx%s\\n\",\n\t\t\t\t\t(long long)(rl + i)->vcn,\n\t\t\t\t\t(long long)(rl + i)->lcn,\n\t\t\t\t\t(long long)(rl + i)->length,\n\t\t\t\t\t(rl + i)->length ? \"\" :\n\t\t\t\t\t\t\" (runlist end)\");\n\t\tif (!(rl + i)->length)\n\t\t\tbreak;\n\t}\n}",
          "includes": [
            "#include \"debug.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"debug.h\"\n\nvoid ntfs_debug_dump_runlist(const runlist_element *rl)\n{\n\tint i;\n\tconst char *lcn_str[5] = { \"LCN_HOLE         \", \"LCN_RL_NOT_MAPPED\",\n\t\t\t\t   \"LCN_ENOENT       \", \"LCN_unknown      \" };\n\n\tif (!debug_msgs)\n\t\treturn;\n\tpr_debug(\"Dumping runlist (values in hex):\\n\");\n\tif (!rl) {\n\t\tpr_debug(\"Run list not present.\\n\");\n\t\treturn;\n\t}\n\tpr_debug(\"VCN              LCN               Run length\\n\");\n\tfor (i = 0; ; i++) {\n\t\tLCN lcn = (rl + i)->lcn;\n\n\t\tif (lcn < (LCN)0) {\n\t\t\tint index = -lcn - 1;\n\n\t\t\tif (index > -LCN_ENOENT - 1)\n\t\t\t\tindex = 3;\n\t\t\tpr_debug(\"%-16Lx %s %-16Lx%s\\n\",\n\t\t\t\t\t(long long)(rl + i)->vcn, lcn_str[index],\n\t\t\t\t\t(long long)(rl + i)->length,\n\t\t\t\t\t(rl + i)->length ? \"\" :\n\t\t\t\t\t\t\" (runlist end)\");\n\t\t} else\n\t\t\tpr_debug(\"%-16Lx %-16Lx  %-16Lx%s\\n\",\n\t\t\t\t\t(long long)(rl + i)->vcn,\n\t\t\t\t\t(long long)(rl + i)->lcn,\n\t\t\t\t\t(long long)(rl + i)->length,\n\t\t\t\t\t(rl + i)->length ? \"\" :\n\t\t\t\t\t\t\" (runlist end)\");\n\t\tif (!(rl + i)->length)\n\t\t\tbreak;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "up_read",
          "args": [
            "&vol->lcnbmp_lock"
          ],
          "line": 2524
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_debug",
          "args": [
            "\"Finished reading $Bitmap, last index = 0x%lx.\"",
            "index - 1"
          ],
          "line": 2517
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_cache_release",
          "args": [
            "page"
          ],
          "line": 2515
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kunmap_atomic",
          "args": [
            "kaddr"
          ],
          "line": 2514
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bitmap_weight",
          "args": [
            "kaddr",
            "PAGE_CACHE_SIZE * BITS_PER_BYTE"
          ],
          "line": 2512
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmap_atomic",
          "args": [
            "page"
          ],
          "line": 2504
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_debug",
          "args": [
            "\"read_mapping_page() error. Skipping \"\n\t\t\t\t\t\"page (index 0x%lx).\"",
            "index"
          ],
          "line": 2499
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "page"
          ],
          "line": 2498
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "read_mapping_page",
          "args": [
            "mapping",
            "index",
            "NULL"
          ],
          "line": 2496
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_debug",
          "args": [
            "\"Reading $Bitmap, max_index = 0x%lx, max_size = 0x%lx.\"",
            "max_index",
            "PAGE_CACHE_SIZE / 4"
          ],
          "line": 2487
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "down_read",
          "args": [
            "&vol->lcnbmp_lock"
          ],
          "line": 2478
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ntfs.h\"\n#include \"malloc.h\"\n#include \"layout.h\"\n#include \"aops.h\"\n#include \"inode.h\"\n#include \"index.h\"\n#include \"debug.h\"\n#include \"dir.h\"\n#include \"usnjrnl.h\"\n#include \"quota.h\"\n#include \"logfile.h\"\n#include \"sysctl.h\"\n#include <linux/bitmap.h>\n#include <linux/moduleparam.h>\n#include <linux/vfs.h>\n#include <linux/buffer_head.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\t/* For bdev_logical_block_size(). */\n#include <linux/spinlock.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/stddef.h>\n\nstatic s64 get_nr_free_clusters(ntfs_volume *vol)\n{\n\ts64 nr_free = vol->nr_clusters;\n\tstruct address_space *mapping = vol->lcnbmp_ino->i_mapping;\n\tstruct page *page;\n\tpgoff_t index, max_index;\n\n\tntfs_debug(\"Entering.\");\n\t/* Serialize accesses to the cluster bitmap. */\n\tdown_read(&vol->lcnbmp_lock);\n\t/*\n\t * Convert the number of bits into bytes rounded up, then convert into\n\t * multiples of PAGE_CACHE_SIZE, rounding up so that if we have one\n\t * full and one partial page max_index = 2.\n\t */\n\tmax_index = (((vol->nr_clusters + 7) >> 3) + PAGE_CACHE_SIZE - 1) >>\n\t\t\tPAGE_CACHE_SHIFT;\n\t/* Use multiples of 4 bytes, thus max_size is PAGE_CACHE_SIZE / 4. */\n\tntfs_debug(\"Reading $Bitmap, max_index = 0x%lx, max_size = 0x%lx.\",\n\t\t\tmax_index, PAGE_CACHE_SIZE / 4);\n\tfor (index = 0; index < max_index; index++) {\n\t\tunsigned long *kaddr;\n\n\t\t/*\n\t\t * Read the page from page cache, getting it from backing store\n\t\t * if necessary, and increment the use count.\n\t\t */\n\t\tpage = read_mapping_page(mapping, index, NULL);\n\t\t/* Ignore pages which errored synchronously. */\n\t\tif (IS_ERR(page)) {\n\t\t\tntfs_debug(\"read_mapping_page() error. Skipping \"\n\t\t\t\t\t\"page (index 0x%lx).\", index);\n\t\t\tnr_free -= PAGE_CACHE_SIZE * 8;\n\t\t\tcontinue;\n\t\t}\n\t\tkaddr = kmap_atomic(page);\n\t\t/*\n\t\t * Subtract the number of set bits. If this\n\t\t * is the last page and it is partial we don't really care as\n\t\t * it just means we do a little extra work but it won't affect\n\t\t * the result as all out of range bytes are set to zero by\n\t\t * ntfs_readpage().\n\t\t */\n\t\tnr_free -= bitmap_weight(kaddr,\n\t\t\t\t\tPAGE_CACHE_SIZE * BITS_PER_BYTE);\n\t\tkunmap_atomic(kaddr);\n\t\tpage_cache_release(page);\n\t}\n\tntfs_debug(\"Finished reading $Bitmap, last index = 0x%lx.\", index - 1);\n\t/*\n\t * Fixup for eventual bits outside logical ntfs volume (see function\n\t * description above).\n\t */\n\tif (vol->nr_clusters & 63)\n\t\tnr_free += 64 - (vol->nr_clusters & 63);\n\tup_read(&vol->lcnbmp_lock);\n\t/* If errors occurred we may well have gone below zero, fix this. */\n\tif (nr_free < 0)\n\t\tnr_free = 0;\n\tntfs_debug(\"Exiting.\");\n\treturn nr_free;\n}"
  },
  {
    "function_name": "ntfs_put_super",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/super.c",
    "lines": "2272-2448",
    "snippet": "static void ntfs_put_super(struct super_block *sb)\n{\n\tntfs_volume *vol = NTFS_SB(sb);\n\n\tntfs_debug(\"Entering.\");\n\n#ifdef NTFS_RW\n\t/*\n\t * Commit all inodes while they are still open in case some of them\n\t * cause others to be dirtied.\n\t */\n\tntfs_commit_inode(vol->vol_ino);\n\n\t/* NTFS 3.0+ specific. */\n\tif (vol->major_ver >= 3) {\n\t\tif (vol->usnjrnl_j_ino)\n\t\t\tntfs_commit_inode(vol->usnjrnl_j_ino);\n\t\tif (vol->usnjrnl_max_ino)\n\t\t\tntfs_commit_inode(vol->usnjrnl_max_ino);\n\t\tif (vol->usnjrnl_ino)\n\t\t\tntfs_commit_inode(vol->usnjrnl_ino);\n\t\tif (vol->quota_q_ino)\n\t\t\tntfs_commit_inode(vol->quota_q_ino);\n\t\tif (vol->quota_ino)\n\t\t\tntfs_commit_inode(vol->quota_ino);\n\t\tif (vol->extend_ino)\n\t\t\tntfs_commit_inode(vol->extend_ino);\n\t\tif (vol->secure_ino)\n\t\t\tntfs_commit_inode(vol->secure_ino);\n\t}\n\n\tntfs_commit_inode(vol->root_ino);\n\n\tdown_write(&vol->lcnbmp_lock);\n\tntfs_commit_inode(vol->lcnbmp_ino);\n\tup_write(&vol->lcnbmp_lock);\n\n\tdown_write(&vol->mftbmp_lock);\n\tntfs_commit_inode(vol->mftbmp_ino);\n\tup_write(&vol->mftbmp_lock);\n\n\tif (vol->logfile_ino)\n\t\tntfs_commit_inode(vol->logfile_ino);\n\n\tif (vol->mftmirr_ino)\n\t\tntfs_commit_inode(vol->mftmirr_ino);\n\tntfs_commit_inode(vol->mft_ino);\n\n\t/*\n\t * If a read-write mount and no volume errors have occurred, mark the\n\t * volume clean.  Also, re-commit all affected inodes.\n\t */\n\tif (!(sb->s_flags & MS_RDONLY)) {\n\t\tif (!NVolErrors(vol)) {\n\t\t\tif (ntfs_clear_volume_flags(vol, VOLUME_IS_DIRTY))\n\t\t\t\tntfs_warning(sb, \"Failed to clear dirty bit \"\n\t\t\t\t\t\t\"in volume information \"\n\t\t\t\t\t\t\"flags.  Run chkdsk.\");\n\t\t\tntfs_commit_inode(vol->vol_ino);\n\t\t\tntfs_commit_inode(vol->root_ino);\n\t\t\tif (vol->mftmirr_ino)\n\t\t\t\tntfs_commit_inode(vol->mftmirr_ino);\n\t\t\tntfs_commit_inode(vol->mft_ino);\n\t\t} else {\n\t\t\tntfs_warning(sb, \"Volume has errors.  Leaving volume \"\n\t\t\t\t\t\"marked dirty.  Run chkdsk.\");\n\t\t}\n\t}\n#endif /* NTFS_RW */\n\n\tiput(vol->vol_ino);\n\tvol->vol_ino = NULL;\n\n\t/* NTFS 3.0+ specific clean up. */\n\tif (vol->major_ver >= 3) {\n#ifdef NTFS_RW\n\t\tif (vol->usnjrnl_j_ino) {\n\t\t\tiput(vol->usnjrnl_j_ino);\n\t\t\tvol->usnjrnl_j_ino = NULL;\n\t\t}\n\t\tif (vol->usnjrnl_max_ino) {\n\t\t\tiput(vol->usnjrnl_max_ino);\n\t\t\tvol->usnjrnl_max_ino = NULL;\n\t\t}\n\t\tif (vol->usnjrnl_ino) {\n\t\t\tiput(vol->usnjrnl_ino);\n\t\t\tvol->usnjrnl_ino = NULL;\n\t\t}\n\t\tif (vol->quota_q_ino) {\n\t\t\tiput(vol->quota_q_ino);\n\t\t\tvol->quota_q_ino = NULL;\n\t\t}\n\t\tif (vol->quota_ino) {\n\t\t\tiput(vol->quota_ino);\n\t\t\tvol->quota_ino = NULL;\n\t\t}\n#endif /* NTFS_RW */\n\t\tif (vol->extend_ino) {\n\t\t\tiput(vol->extend_ino);\n\t\t\tvol->extend_ino = NULL;\n\t\t}\n\t\tif (vol->secure_ino) {\n\t\t\tiput(vol->secure_ino);\n\t\t\tvol->secure_ino = NULL;\n\t\t}\n\t}\n\n\tiput(vol->root_ino);\n\tvol->root_ino = NULL;\n\n\tdown_write(&vol->lcnbmp_lock);\n\tiput(vol->lcnbmp_ino);\n\tvol->lcnbmp_ino = NULL;\n\tup_write(&vol->lcnbmp_lock);\n\n\tdown_write(&vol->mftbmp_lock);\n\tiput(vol->mftbmp_ino);\n\tvol->mftbmp_ino = NULL;\n\tup_write(&vol->mftbmp_lock);\n\n#ifdef NTFS_RW\n\tif (vol->logfile_ino) {\n\t\tiput(vol->logfile_ino);\n\t\tvol->logfile_ino = NULL;\n\t}\n\tif (vol->mftmirr_ino) {\n\t\t/* Re-commit the mft mirror and mft just in case. */\n\t\tntfs_commit_inode(vol->mftmirr_ino);\n\t\tntfs_commit_inode(vol->mft_ino);\n\t\tiput(vol->mftmirr_ino);\n\t\tvol->mftmirr_ino = NULL;\n\t}\n\t/*\n\t * We should have no dirty inodes left, due to\n\t * mft.c::ntfs_mft_writepage() cleaning all the dirty pages as\n\t * the underlying mft records are written out and cleaned.\n\t */\n\tntfs_commit_inode(vol->mft_ino);\n\twrite_inode_now(vol->mft_ino, 1);\n#endif /* NTFS_RW */\n\n\tiput(vol->mft_ino);\n\tvol->mft_ino = NULL;\n\n\t/* Throw away the table of attribute definitions. */\n\tvol->attrdef_size = 0;\n\tif (vol->attrdef) {\n\t\tntfs_free(vol->attrdef);\n\t\tvol->attrdef = NULL;\n\t}\n\tvol->upcase_len = 0;\n\t/*\n\t * Destroy the global default upcase table if necessary.  Also decrease\n\t * the number of upcase users if we are a user.\n\t */\n\tmutex_lock(&ntfs_lock);\n\tif (vol->upcase == default_upcase) {\n\t\tntfs_nr_upcase_users--;\n\t\tvol->upcase = NULL;\n\t}\n\tif (!ntfs_nr_upcase_users && default_upcase) {\n\t\tntfs_free(default_upcase);\n\t\tdefault_upcase = NULL;\n\t}\n\tif (vol->cluster_size <= 4096 && !--ntfs_nr_compression_users)\n\t\tfree_compression_buffers();\n\tmutex_unlock(&ntfs_lock);\n\tif (vol->upcase) {\n\t\tntfs_free(vol->upcase);\n\t\tvol->upcase = NULL;\n\t}\n\n\tunload_nls(vol->nls_map);\n\n\tsb->s_fs_info = NULL;\n\tkfree(vol);\n}",
    "includes": [
      "#include \"ntfs.h\"",
      "#include \"malloc.h\"",
      "#include \"layout.h\"",
      "#include \"aops.h\"",
      "#include \"inode.h\"",
      "#include \"index.h\"",
      "#include \"debug.h\"",
      "#include \"dir.h\"",
      "#include \"usnjrnl.h\"",
      "#include \"quota.h\"",
      "#include \"logfile.h\"",
      "#include \"sysctl.h\"",
      "#include <linux/bitmap.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/vfs.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/blkdev.h>\t/* For bdev_logical_block_size(). */",
      "#include <linux/spinlock.h>",
      "#include <linux/string.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/stddef.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static unsigned long ntfs_nr_compression_users;",
      "static ntfschar *default_upcase;",
      "static unsigned long ntfs_nr_upcase_users;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "vol"
          ],
          "line": 2447
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unload_nls",
          "args": [
            "vol->nls_map"
          ],
          "line": 2444
        },
        "resolved": true,
        "details": {
          "function_name": "unload_nls",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nls/nls_base.c",
          "lines": "296-300",
          "snippet": "void unload_nls(struct nls_table *nls)\n{\n\tif (nls)\n\t\tmodule_put(nls->owner);\n}",
          "includes": [
            "#include <asm/byteorder.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/kmod.h>",
            "#include <linux/errno.h>",
            "#include <linux/kernel.h>",
            "#include <linux/nls.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/byteorder.h>\n#include <linux/spinlock.h>\n#include <linux/kmod.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include <linux/nls.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nvoid unload_nls(struct nls_table *nls)\n{\n\tif (nls)\n\t\tmodule_put(nls->owner);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ntfs_free",
          "args": [
            "vol->upcase"
          ],
          "line": 2440
        },
        "resolved": true,
        "details": {
          "function_name": "ntfs_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/malloc.h",
          "lines": "86-94",
          "snippet": "static inline void ntfs_free(void *addr)\n{\n\tif (!is_vmalloc_addr(addr)) {\n\t\tkfree(addr);\n\t\t/* free_page((unsigned long)addr); */\n\t\treturn;\n\t}\n\tvfree(addr);\n}",
          "includes": [
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/vmalloc.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n\nstatic inline void ntfs_free(void *addr)\n{\n\tif (!is_vmalloc_addr(addr)) {\n\t\tkfree(addr);\n\t\t/* free_page((unsigned long)addr); */\n\t\treturn;\n\t}\n\tvfree(addr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&ntfs_lock"
          ],
          "line": 2438
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free_compression_buffers",
          "args": [],
          "line": 2437
        },
        "resolved": true,
        "details": {
          "function_name": "free_compression_buffers",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/compress.c",
          "lines": "90-95",
          "snippet": "void free_compression_buffers(void)\n{\n\tBUG_ON(!ntfs_compression_buffer);\n\tvfree(ntfs_compression_buffer);\n\tntfs_compression_buffer = NULL;\n}",
          "includes": [
            "#include \"ntfs.h\"",
            "#include \"debug.h\"",
            "#include \"inode.h\"",
            "#include \"attrib.h\"",
            "#include <linux/slab.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static u8 *ntfs_compression_buffer;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ntfs.h\"\n#include \"debug.h\"\n#include \"inode.h\"\n#include \"attrib.h\"\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n\nstatic u8 *ntfs_compression_buffer;\n\nvoid free_compression_buffers(void)\n{\n\tBUG_ON(!ntfs_compression_buffer);\n\tvfree(ntfs_compression_buffer);\n\tntfs_compression_buffer = NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&ntfs_lock"
          ],
          "line": 2427
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "iput",
          "args": [
            "vol->mft_ino"
          ],
          "line": 2413
        },
        "resolved": true,
        "details": {
          "function_name": "dentry_iput",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "308-327",
          "snippet": "static void dentry_iput(struct dentry * dentry)\n\t__releases(dentry->d_lock)\n\t__releases(dentry->d_inode->i_lock)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tif (inode) {\n\t\tdentry->d_inode = NULL;\n\t\thlist_del_init(&dentry->d_u.d_alias);\n\t\tspin_unlock(&dentry->d_lock);\n\t\tspin_unlock(&inode->i_lock);\n\t\tif (!inode->i_nlink)\n\t\t\tfsnotify_inoderemove(inode);\n\t\tif (dentry->d_op && dentry->d_op->d_iput)\n\t\t\tdentry->d_op->d_iput(dentry, inode);\n\t\telse\n\t\t\tiput(inode);\n\t} else {\n\t\tspin_unlock(&dentry->d_lock);\n\t}\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nstatic void dentry_iput(struct dentry * dentry)\n\t__releases(dentry->d_lock)\n\t__releases(dentry->d_inode->i_lock)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tif (inode) {\n\t\tdentry->d_inode = NULL;\n\t\thlist_del_init(&dentry->d_u.d_alias);\n\t\tspin_unlock(&dentry->d_lock);\n\t\tspin_unlock(&inode->i_lock);\n\t\tif (!inode->i_nlink)\n\t\t\tfsnotify_inoderemove(inode);\n\t\tif (dentry->d_op && dentry->d_op->d_iput)\n\t\t\tdentry->d_op->d_iput(dentry, inode);\n\t\telse\n\t\t\tiput(inode);\n\t} else {\n\t\tspin_unlock(&dentry->d_lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "write_inode_now",
          "args": [
            "vol->mft_ino",
            "1"
          ],
          "line": 2410
        },
        "resolved": true,
        "details": {
          "function_name": "write_inode_now",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fs-writeback.c",
          "lines": "1469-1484",
          "snippet": "int write_inode_now(struct inode *inode, int sync)\n{\n\tstruct bdi_writeback *wb = &inode_to_bdi(inode)->wb;\n\tstruct writeback_control wbc = {\n\t\t.nr_to_write = LONG_MAX,\n\t\t.sync_mode = sync ? WB_SYNC_ALL : WB_SYNC_NONE,\n\t\t.range_start = 0,\n\t\t.range_end = LLONG_MAX,\n\t};\n\n\tif (!mapping_cap_writeback_dirty(inode->i_mapping))\n\t\twbc.nr_to_write = 0;\n\n\tmight_sleep();\n\treturn writeback_single_inode(inode, wb, &wbc);\n}",
          "includes": [
            "#include <trace/events/writeback.h>",
            "#include \"internal.h\"",
            "#include <linux/device.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/writeback.h>\n#include \"internal.h\"\n#include <linux/device.h>\n#include <linux/tracepoint.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nint write_inode_now(struct inode *inode, int sync)\n{\n\tstruct bdi_writeback *wb = &inode_to_bdi(inode)->wb;\n\tstruct writeback_control wbc = {\n\t\t.nr_to_write = LONG_MAX,\n\t\t.sync_mode = sync ? WB_SYNC_ALL : WB_SYNC_NONE,\n\t\t.range_start = 0,\n\t\t.range_end = LLONG_MAX,\n\t};\n\n\tif (!mapping_cap_writeback_dirty(inode->i_mapping))\n\t\twbc.nr_to_write = 0;\n\n\tmight_sleep();\n\treturn writeback_single_inode(inode, wb, &wbc);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ntfs_commit_inode",
          "args": [
            "vol->mft_ino"
          ],
          "line": 2409
        },
        "resolved": true,
        "details": {
          "function_name": "ntfs_commit_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/inode.h",
          "lines": "312-317",
          "snippet": "static inline void ntfs_commit_inode(struct inode *vi)\n{\n\tif (!is_bad_inode(vi))\n\t\t__ntfs_write_inode(vi, 1);\n\treturn;\n}",
          "includes": [
            "#include \"debug.h\"",
            "#include \"runlist.h\"",
            "#include \"types.h\"",
            "#include \"volume.h\"",
            "#include \"layout.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/mutex.h>",
            "#include <linux/mm.h>",
            "#include <linux/list.h>",
            "#include <linux/fs.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"debug.h\"\n#include \"runlist.h\"\n#include \"types.h\"\n#include \"volume.h\"\n#include \"layout.h\"\n#include <linux/seq_file.h>\n#include <linux/mutex.h>\n#include <linux/mm.h>\n#include <linux/list.h>\n#include <linux/fs.h>\n#include <linux/atomic.h>\n\nstatic inline void ntfs_commit_inode(struct inode *vi)\n{\n\tif (!is_bad_inode(vi))\n\t\t__ntfs_write_inode(vi, 1);\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "up_write",
          "args": [
            "&vol->mftbmp_lock"
          ],
          "line": 2390
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "down_write",
          "args": [
            "&vol->mftbmp_lock"
          ],
          "line": 2387
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "up_write",
          "args": [
            "&vol->lcnbmp_lock"
          ],
          "line": 2385
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "down_write",
          "args": [
            "&vol->lcnbmp_lock"
          ],
          "line": 2382
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_warning",
          "args": [
            "sb",
            "\"Volume has errors.  Leaving volume \"\n\t\t\t\t\t\"marked dirty.  Run chkdsk.\""
          ],
          "line": 2336
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_warning",
          "args": [
            "sb",
            "\"Failed to clear dirty bit \"\n\t\t\t\t\t\t\"in volume information \"\n\t\t\t\t\t\t\"flags.  Run chkdsk.\""
          ],
          "line": 2327
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_clear_volume_flags",
          "args": [
            "vol",
            "VOLUME_IS_DIRTY"
          ],
          "line": 2326
        },
        "resolved": true,
        "details": {
          "function_name": "ntfs_clear_volume_flags",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/super.c",
          "lines": "445-450",
          "snippet": "static inline int ntfs_clear_volume_flags(ntfs_volume *vol, VOLUME_FLAGS flags)\n{\n\tflags &= VOLUME_FLAGS_MASK;\n\tflags = vol->vol_flags & cpu_to_le16(~le16_to_cpu(flags));\n\treturn ntfs_write_volume_flags(vol, flags);\n}",
          "includes": [
            "#include \"ntfs.h\"",
            "#include \"malloc.h\"",
            "#include \"layout.h\"",
            "#include \"aops.h\"",
            "#include \"inode.h\"",
            "#include \"index.h\"",
            "#include \"debug.h\"",
            "#include \"dir.h\"",
            "#include \"usnjrnl.h\"",
            "#include \"quota.h\"",
            "#include \"logfile.h\"",
            "#include \"sysctl.h\"",
            "#include <linux/bitmap.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/vfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>\t/* For bdev_logical_block_size(). */",
            "#include <linux/spinlock.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ntfs.h\"\n#include \"malloc.h\"\n#include \"layout.h\"\n#include \"aops.h\"\n#include \"inode.h\"\n#include \"index.h\"\n#include \"debug.h\"\n#include \"dir.h\"\n#include \"usnjrnl.h\"\n#include \"quota.h\"\n#include \"logfile.h\"\n#include \"sysctl.h\"\n#include <linux/bitmap.h>\n#include <linux/moduleparam.h>\n#include <linux/vfs.h>\n#include <linux/buffer_head.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\t/* For bdev_logical_block_size(). */\n#include <linux/spinlock.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/stddef.h>\n\nstatic inline int ntfs_clear_volume_flags(ntfs_volume *vol, VOLUME_FLAGS flags)\n{\n\tflags &= VOLUME_FLAGS_MASK;\n\tflags = vol->vol_flags & cpu_to_le16(~le16_to_cpu(flags));\n\treturn ntfs_write_volume_flags(vol, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "NVolErrors",
          "args": [
            "vol"
          ],
          "line": 2325
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "up_write",
          "args": [
            "&vol->mftbmp_lock"
          ],
          "line": 2311
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "down_write",
          "args": [
            "&vol->mftbmp_lock"
          ],
          "line": 2309
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "up_write",
          "args": [
            "&vol->lcnbmp_lock"
          ],
          "line": 2307
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "down_write",
          "args": [
            "&vol->lcnbmp_lock"
          ],
          "line": 2305
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_debug",
          "args": [
            "\"Entering.\""
          ],
          "line": 2276
        },
        "resolved": true,
        "details": {
          "function_name": "ntfs_debug_dump_runlist",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/debug.c",
          "lines": "134-171",
          "snippet": "void ntfs_debug_dump_runlist(const runlist_element *rl)\n{\n\tint i;\n\tconst char *lcn_str[5] = { \"LCN_HOLE         \", \"LCN_RL_NOT_MAPPED\",\n\t\t\t\t   \"LCN_ENOENT       \", \"LCN_unknown      \" };\n\n\tif (!debug_msgs)\n\t\treturn;\n\tpr_debug(\"Dumping runlist (values in hex):\\n\");\n\tif (!rl) {\n\t\tpr_debug(\"Run list not present.\\n\");\n\t\treturn;\n\t}\n\tpr_debug(\"VCN              LCN               Run length\\n\");\n\tfor (i = 0; ; i++) {\n\t\tLCN lcn = (rl + i)->lcn;\n\n\t\tif (lcn < (LCN)0) {\n\t\t\tint index = -lcn - 1;\n\n\t\t\tif (index > -LCN_ENOENT - 1)\n\t\t\t\tindex = 3;\n\t\t\tpr_debug(\"%-16Lx %s %-16Lx%s\\n\",\n\t\t\t\t\t(long long)(rl + i)->vcn, lcn_str[index],\n\t\t\t\t\t(long long)(rl + i)->length,\n\t\t\t\t\t(rl + i)->length ? \"\" :\n\t\t\t\t\t\t\" (runlist end)\");\n\t\t} else\n\t\t\tpr_debug(\"%-16Lx %-16Lx  %-16Lx%s\\n\",\n\t\t\t\t\t(long long)(rl + i)->vcn,\n\t\t\t\t\t(long long)(rl + i)->lcn,\n\t\t\t\t\t(long long)(rl + i)->length,\n\t\t\t\t\t(rl + i)->length ? \"\" :\n\t\t\t\t\t\t\" (runlist end)\");\n\t\tif (!(rl + i)->length)\n\t\t\tbreak;\n\t}\n}",
          "includes": [
            "#include \"debug.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"debug.h\"\n\nvoid ntfs_debug_dump_runlist(const runlist_element *rl)\n{\n\tint i;\n\tconst char *lcn_str[5] = { \"LCN_HOLE         \", \"LCN_RL_NOT_MAPPED\",\n\t\t\t\t   \"LCN_ENOENT       \", \"LCN_unknown      \" };\n\n\tif (!debug_msgs)\n\t\treturn;\n\tpr_debug(\"Dumping runlist (values in hex):\\n\");\n\tif (!rl) {\n\t\tpr_debug(\"Run list not present.\\n\");\n\t\treturn;\n\t}\n\tpr_debug(\"VCN              LCN               Run length\\n\");\n\tfor (i = 0; ; i++) {\n\t\tLCN lcn = (rl + i)->lcn;\n\n\t\tif (lcn < (LCN)0) {\n\t\t\tint index = -lcn - 1;\n\n\t\t\tif (index > -LCN_ENOENT - 1)\n\t\t\t\tindex = 3;\n\t\t\tpr_debug(\"%-16Lx %s %-16Lx%s\\n\",\n\t\t\t\t\t(long long)(rl + i)->vcn, lcn_str[index],\n\t\t\t\t\t(long long)(rl + i)->length,\n\t\t\t\t\t(rl + i)->length ? \"\" :\n\t\t\t\t\t\t\" (runlist end)\");\n\t\t} else\n\t\t\tpr_debug(\"%-16Lx %-16Lx  %-16Lx%s\\n\",\n\t\t\t\t\t(long long)(rl + i)->vcn,\n\t\t\t\t\t(long long)(rl + i)->lcn,\n\t\t\t\t\t(long long)(rl + i)->length,\n\t\t\t\t\t(rl + i)->length ? \"\" :\n\t\t\t\t\t\t\" (runlist end)\");\n\t\tif (!(rl + i)->length)\n\t\t\tbreak;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "NTFS_SB",
          "args": [
            "sb"
          ],
          "line": 2274
        },
        "resolved": true,
        "details": {
          "function_name": "NTFS_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/ntfs.h",
          "lines": "80-83",
          "snippet": "static inline ntfs_volume *NTFS_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"layout.h\"",
            "#include \"volume.h\"",
            "#include \"types.h\"",
            "#include <linux/pagemap.h>",
            "#include <linux/smp.h>",
            "#include <linux/nls.h>",
            "#include <linux/fs.h>",
            "#include <linux/compiler.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"layout.h\"\n#include \"volume.h\"\n#include \"types.h\"\n#include <linux/pagemap.h>\n#include <linux/smp.h>\n#include <linux/nls.h>\n#include <linux/fs.h>\n#include <linux/compiler.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/stddef.h>\n\nstatic inline ntfs_volume *NTFS_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ntfs.h\"\n#include \"malloc.h\"\n#include \"layout.h\"\n#include \"aops.h\"\n#include \"inode.h\"\n#include \"index.h\"\n#include \"debug.h\"\n#include \"dir.h\"\n#include \"usnjrnl.h\"\n#include \"quota.h\"\n#include \"logfile.h\"\n#include \"sysctl.h\"\n#include <linux/bitmap.h>\n#include <linux/moduleparam.h>\n#include <linux/vfs.h>\n#include <linux/buffer_head.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\t/* For bdev_logical_block_size(). */\n#include <linux/spinlock.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/stddef.h>\n\nstatic unsigned long ntfs_nr_compression_users;\nstatic ntfschar *default_upcase;\nstatic unsigned long ntfs_nr_upcase_users;\n\nstatic void ntfs_put_super(struct super_block *sb)\n{\n\tntfs_volume *vol = NTFS_SB(sb);\n\n\tntfs_debug(\"Entering.\");\n\n#ifdef NTFS_RW\n\t/*\n\t * Commit all inodes while they are still open in case some of them\n\t * cause others to be dirtied.\n\t */\n\tntfs_commit_inode(vol->vol_ino);\n\n\t/* NTFS 3.0+ specific. */\n\tif (vol->major_ver >= 3) {\n\t\tif (vol->usnjrnl_j_ino)\n\t\t\tntfs_commit_inode(vol->usnjrnl_j_ino);\n\t\tif (vol->usnjrnl_max_ino)\n\t\t\tntfs_commit_inode(vol->usnjrnl_max_ino);\n\t\tif (vol->usnjrnl_ino)\n\t\t\tntfs_commit_inode(vol->usnjrnl_ino);\n\t\tif (vol->quota_q_ino)\n\t\t\tntfs_commit_inode(vol->quota_q_ino);\n\t\tif (vol->quota_ino)\n\t\t\tntfs_commit_inode(vol->quota_ino);\n\t\tif (vol->extend_ino)\n\t\t\tntfs_commit_inode(vol->extend_ino);\n\t\tif (vol->secure_ino)\n\t\t\tntfs_commit_inode(vol->secure_ino);\n\t}\n\n\tntfs_commit_inode(vol->root_ino);\n\n\tdown_write(&vol->lcnbmp_lock);\n\tntfs_commit_inode(vol->lcnbmp_ino);\n\tup_write(&vol->lcnbmp_lock);\n\n\tdown_write(&vol->mftbmp_lock);\n\tntfs_commit_inode(vol->mftbmp_ino);\n\tup_write(&vol->mftbmp_lock);\n\n\tif (vol->logfile_ino)\n\t\tntfs_commit_inode(vol->logfile_ino);\n\n\tif (vol->mftmirr_ino)\n\t\tntfs_commit_inode(vol->mftmirr_ino);\n\tntfs_commit_inode(vol->mft_ino);\n\n\t/*\n\t * If a read-write mount and no volume errors have occurred, mark the\n\t * volume clean.  Also, re-commit all affected inodes.\n\t */\n\tif (!(sb->s_flags & MS_RDONLY)) {\n\t\tif (!NVolErrors(vol)) {\n\t\t\tif (ntfs_clear_volume_flags(vol, VOLUME_IS_DIRTY))\n\t\t\t\tntfs_warning(sb, \"Failed to clear dirty bit \"\n\t\t\t\t\t\t\"in volume information \"\n\t\t\t\t\t\t\"flags.  Run chkdsk.\");\n\t\t\tntfs_commit_inode(vol->vol_ino);\n\t\t\tntfs_commit_inode(vol->root_ino);\n\t\t\tif (vol->mftmirr_ino)\n\t\t\t\tntfs_commit_inode(vol->mftmirr_ino);\n\t\t\tntfs_commit_inode(vol->mft_ino);\n\t\t} else {\n\t\t\tntfs_warning(sb, \"Volume has errors.  Leaving volume \"\n\t\t\t\t\t\"marked dirty.  Run chkdsk.\");\n\t\t}\n\t}\n#endif /* NTFS_RW */\n\n\tiput(vol->vol_ino);\n\tvol->vol_ino = NULL;\n\n\t/* NTFS 3.0+ specific clean up. */\n\tif (vol->major_ver >= 3) {\n#ifdef NTFS_RW\n\t\tif (vol->usnjrnl_j_ino) {\n\t\t\tiput(vol->usnjrnl_j_ino);\n\t\t\tvol->usnjrnl_j_ino = NULL;\n\t\t}\n\t\tif (vol->usnjrnl_max_ino) {\n\t\t\tiput(vol->usnjrnl_max_ino);\n\t\t\tvol->usnjrnl_max_ino = NULL;\n\t\t}\n\t\tif (vol->usnjrnl_ino) {\n\t\t\tiput(vol->usnjrnl_ino);\n\t\t\tvol->usnjrnl_ino = NULL;\n\t\t}\n\t\tif (vol->quota_q_ino) {\n\t\t\tiput(vol->quota_q_ino);\n\t\t\tvol->quota_q_ino = NULL;\n\t\t}\n\t\tif (vol->quota_ino) {\n\t\t\tiput(vol->quota_ino);\n\t\t\tvol->quota_ino = NULL;\n\t\t}\n#endif /* NTFS_RW */\n\t\tif (vol->extend_ino) {\n\t\t\tiput(vol->extend_ino);\n\t\t\tvol->extend_ino = NULL;\n\t\t}\n\t\tif (vol->secure_ino) {\n\t\t\tiput(vol->secure_ino);\n\t\t\tvol->secure_ino = NULL;\n\t\t}\n\t}\n\n\tiput(vol->root_ino);\n\tvol->root_ino = NULL;\n\n\tdown_write(&vol->lcnbmp_lock);\n\tiput(vol->lcnbmp_ino);\n\tvol->lcnbmp_ino = NULL;\n\tup_write(&vol->lcnbmp_lock);\n\n\tdown_write(&vol->mftbmp_lock);\n\tiput(vol->mftbmp_ino);\n\tvol->mftbmp_ino = NULL;\n\tup_write(&vol->mftbmp_lock);\n\n#ifdef NTFS_RW\n\tif (vol->logfile_ino) {\n\t\tiput(vol->logfile_ino);\n\t\tvol->logfile_ino = NULL;\n\t}\n\tif (vol->mftmirr_ino) {\n\t\t/* Re-commit the mft mirror and mft just in case. */\n\t\tntfs_commit_inode(vol->mftmirr_ino);\n\t\tntfs_commit_inode(vol->mft_ino);\n\t\tiput(vol->mftmirr_ino);\n\t\tvol->mftmirr_ino = NULL;\n\t}\n\t/*\n\t * We should have no dirty inodes left, due to\n\t * mft.c::ntfs_mft_writepage() cleaning all the dirty pages as\n\t * the underlying mft records are written out and cleaned.\n\t */\n\tntfs_commit_inode(vol->mft_ino);\n\twrite_inode_now(vol->mft_ino, 1);\n#endif /* NTFS_RW */\n\n\tiput(vol->mft_ino);\n\tvol->mft_ino = NULL;\n\n\t/* Throw away the table of attribute definitions. */\n\tvol->attrdef_size = 0;\n\tif (vol->attrdef) {\n\t\tntfs_free(vol->attrdef);\n\t\tvol->attrdef = NULL;\n\t}\n\tvol->upcase_len = 0;\n\t/*\n\t * Destroy the global default upcase table if necessary.  Also decrease\n\t * the number of upcase users if we are a user.\n\t */\n\tmutex_lock(&ntfs_lock);\n\tif (vol->upcase == default_upcase) {\n\t\tntfs_nr_upcase_users--;\n\t\tvol->upcase = NULL;\n\t}\n\tif (!ntfs_nr_upcase_users && default_upcase) {\n\t\tntfs_free(default_upcase);\n\t\tdefault_upcase = NULL;\n\t}\n\tif (vol->cluster_size <= 4096 && !--ntfs_nr_compression_users)\n\t\tfree_compression_buffers();\n\tmutex_unlock(&ntfs_lock);\n\tif (vol->upcase) {\n\t\tntfs_free(vol->upcase);\n\t\tvol->upcase = NULL;\n\t}\n\n\tunload_nls(vol->nls_map);\n\n\tsb->s_fs_info = NULL;\n\tkfree(vol);\n}"
  },
  {
    "function_name": "load_and_init_upcase",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/super.c",
    "lines": "1657-1753",
    "snippet": "static bool load_and_init_upcase(ntfs_volume *vol)\n{\n\tloff_t i_size;\n\tstruct super_block *sb = vol->sb;\n\tstruct inode *ino;\n\tstruct page *page;\n\tpgoff_t index, max_index;\n\tunsigned int size;\n\tint i, max;\n\n\tntfs_debug(\"Entering.\");\n\t/* Read upcase table and setup vol->upcase and vol->upcase_len. */\n\tino = ntfs_iget(sb, FILE_UpCase);\n\tif (IS_ERR(ino) || is_bad_inode(ino)) {\n\t\tif (!IS_ERR(ino))\n\t\t\tiput(ino);\n\t\tgoto upcase_failed;\n\t}\n\t/*\n\t * The upcase size must not be above 64k Unicode characters, must not\n\t * be zero and must be a multiple of sizeof(ntfschar).\n\t */\n\ti_size = i_size_read(ino);\n\tif (!i_size || i_size & (sizeof(ntfschar) - 1) ||\n\t\t\ti_size > 64ULL * 1024 * sizeof(ntfschar))\n\t\tgoto iput_upcase_failed;\n\tvol->upcase = (ntfschar*)ntfs_malloc_nofs(i_size);\n\tif (!vol->upcase)\n\t\tgoto iput_upcase_failed;\n\tindex = 0;\n\tmax_index = i_size >> PAGE_CACHE_SHIFT;\n\tsize = PAGE_CACHE_SIZE;\n\twhile (index < max_index) {\n\t\t/* Read the upcase table and copy it into the linear buffer. */\nread_partial_upcase_page:\n\t\tpage = ntfs_map_page(ino->i_mapping, index);\n\t\tif (IS_ERR(page))\n\t\t\tgoto iput_upcase_failed;\n\t\tmemcpy((char*)vol->upcase + (index++ << PAGE_CACHE_SHIFT),\n\t\t\t\tpage_address(page), size);\n\t\tntfs_unmap_page(page);\n\t};\n\tif (size == PAGE_CACHE_SIZE) {\n\t\tsize = i_size & ~PAGE_CACHE_MASK;\n\t\tif (size)\n\t\t\tgoto read_partial_upcase_page;\n\t}\n\tvol->upcase_len = i_size >> UCHAR_T_SIZE_BITS;\n\tntfs_debug(\"Read %llu bytes from $UpCase (expected %zu bytes).\",\n\t\t\ti_size, 64 * 1024 * sizeof(ntfschar));\n\tiput(ino);\n\tmutex_lock(&ntfs_lock);\n\tif (!default_upcase) {\n\t\tntfs_debug(\"Using volume specified $UpCase since default is \"\n\t\t\t\t\"not present.\");\n\t\tmutex_unlock(&ntfs_lock);\n\t\treturn true;\n\t}\n\tmax = default_upcase_len;\n\tif (max > vol->upcase_len)\n\t\tmax = vol->upcase_len;\n\tfor (i = 0; i < max; i++)\n\t\tif (vol->upcase[i] != default_upcase[i])\n\t\t\tbreak;\n\tif (i == max) {\n\t\tntfs_free(vol->upcase);\n\t\tvol->upcase = default_upcase;\n\t\tvol->upcase_len = max;\n\t\tntfs_nr_upcase_users++;\n\t\tmutex_unlock(&ntfs_lock);\n\t\tntfs_debug(\"Volume specified $UpCase matches default. Using \"\n\t\t\t\t\"default.\");\n\t\treturn true;\n\t}\n\tmutex_unlock(&ntfs_lock);\n\tntfs_debug(\"Using volume specified $UpCase since it does not match \"\n\t\t\t\"the default.\");\n\treturn true;\niput_upcase_failed:\n\tiput(ino);\n\tntfs_free(vol->upcase);\n\tvol->upcase = NULL;\nupcase_failed:\n\tmutex_lock(&ntfs_lock);\n\tif (default_upcase) {\n\t\tvol->upcase = default_upcase;\n\t\tvol->upcase_len = default_upcase_len;\n\t\tntfs_nr_upcase_users++;\n\t\tmutex_unlock(&ntfs_lock);\n\t\tntfs_error(sb, \"Failed to load $UpCase from the volume. Using \"\n\t\t\t\t\"default.\");\n\t\treturn true;\n\t}\n\tmutex_unlock(&ntfs_lock);\n\tntfs_error(sb, \"Failed to initialize upcase table.\");\n\treturn false;\n}",
    "includes": [
      "#include \"ntfs.h\"",
      "#include \"malloc.h\"",
      "#include \"layout.h\"",
      "#include \"aops.h\"",
      "#include \"inode.h\"",
      "#include \"index.h\"",
      "#include \"debug.h\"",
      "#include \"dir.h\"",
      "#include \"usnjrnl.h\"",
      "#include \"quota.h\"",
      "#include \"logfile.h\"",
      "#include \"sysctl.h\"",
      "#include <linux/bitmap.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/vfs.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/blkdev.h>\t/* For bdev_logical_block_size(). */",
      "#include <linux/spinlock.h>",
      "#include <linux/string.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/stddef.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static ntfschar *default_upcase;",
      "static unsigned long ntfs_nr_upcase_users;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ntfs_error",
          "args": [
            "sb",
            "\"Failed to initialize upcase table.\""
          ],
          "line": 1751
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&ntfs_lock"
          ],
          "line": 1750
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_error",
          "args": [
            "sb",
            "\"Failed to load $UpCase from the volume. Using \"\n\t\t\t\t\"default.\""
          ],
          "line": 1746
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&ntfs_lock"
          ],
          "line": 1745
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&ntfs_lock"
          ],
          "line": 1740
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_free",
          "args": [
            "vol->upcase"
          ],
          "line": 1737
        },
        "resolved": true,
        "details": {
          "function_name": "ntfs_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/malloc.h",
          "lines": "86-94",
          "snippet": "static inline void ntfs_free(void *addr)\n{\n\tif (!is_vmalloc_addr(addr)) {\n\t\tkfree(addr);\n\t\t/* free_page((unsigned long)addr); */\n\t\treturn;\n\t}\n\tvfree(addr);\n}",
          "includes": [
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/vmalloc.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n\nstatic inline void ntfs_free(void *addr)\n{\n\tif (!is_vmalloc_addr(addr)) {\n\t\tkfree(addr);\n\t\t/* free_page((unsigned long)addr); */\n\t\treturn;\n\t}\n\tvfree(addr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "iput",
          "args": [
            "ino"
          ],
          "line": 1736
        },
        "resolved": true,
        "details": {
          "function_name": "dentry_iput",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "308-327",
          "snippet": "static void dentry_iput(struct dentry * dentry)\n\t__releases(dentry->d_lock)\n\t__releases(dentry->d_inode->i_lock)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tif (inode) {\n\t\tdentry->d_inode = NULL;\n\t\thlist_del_init(&dentry->d_u.d_alias);\n\t\tspin_unlock(&dentry->d_lock);\n\t\tspin_unlock(&inode->i_lock);\n\t\tif (!inode->i_nlink)\n\t\t\tfsnotify_inoderemove(inode);\n\t\tif (dentry->d_op && dentry->d_op->d_iput)\n\t\t\tdentry->d_op->d_iput(dentry, inode);\n\t\telse\n\t\t\tiput(inode);\n\t} else {\n\t\tspin_unlock(&dentry->d_lock);\n\t}\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nstatic void dentry_iput(struct dentry * dentry)\n\t__releases(dentry->d_lock)\n\t__releases(dentry->d_inode->i_lock)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tif (inode) {\n\t\tdentry->d_inode = NULL;\n\t\thlist_del_init(&dentry->d_u.d_alias);\n\t\tspin_unlock(&dentry->d_lock);\n\t\tspin_unlock(&inode->i_lock);\n\t\tif (!inode->i_nlink)\n\t\t\tfsnotify_inoderemove(inode);\n\t\tif (dentry->d_op && dentry->d_op->d_iput)\n\t\t\tdentry->d_op->d_iput(dentry, inode);\n\t\telse\n\t\t\tiput(inode);\n\t} else {\n\t\tspin_unlock(&dentry->d_lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ntfs_debug",
          "args": [
            "\"Using volume specified $UpCase since it does not match \"\n\t\t\t\"the default.\""
          ],
          "line": 1732
        },
        "resolved": true,
        "details": {
          "function_name": "ntfs_debug_dump_runlist",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/debug.c",
          "lines": "134-171",
          "snippet": "void ntfs_debug_dump_runlist(const runlist_element *rl)\n{\n\tint i;\n\tconst char *lcn_str[5] = { \"LCN_HOLE         \", \"LCN_RL_NOT_MAPPED\",\n\t\t\t\t   \"LCN_ENOENT       \", \"LCN_unknown      \" };\n\n\tif (!debug_msgs)\n\t\treturn;\n\tpr_debug(\"Dumping runlist (values in hex):\\n\");\n\tif (!rl) {\n\t\tpr_debug(\"Run list not present.\\n\");\n\t\treturn;\n\t}\n\tpr_debug(\"VCN              LCN               Run length\\n\");\n\tfor (i = 0; ; i++) {\n\t\tLCN lcn = (rl + i)->lcn;\n\n\t\tif (lcn < (LCN)0) {\n\t\t\tint index = -lcn - 1;\n\n\t\t\tif (index > -LCN_ENOENT - 1)\n\t\t\t\tindex = 3;\n\t\t\tpr_debug(\"%-16Lx %s %-16Lx%s\\n\",\n\t\t\t\t\t(long long)(rl + i)->vcn, lcn_str[index],\n\t\t\t\t\t(long long)(rl + i)->length,\n\t\t\t\t\t(rl + i)->length ? \"\" :\n\t\t\t\t\t\t\" (runlist end)\");\n\t\t} else\n\t\t\tpr_debug(\"%-16Lx %-16Lx  %-16Lx%s\\n\",\n\t\t\t\t\t(long long)(rl + i)->vcn,\n\t\t\t\t\t(long long)(rl + i)->lcn,\n\t\t\t\t\t(long long)(rl + i)->length,\n\t\t\t\t\t(rl + i)->length ? \"\" :\n\t\t\t\t\t\t\" (runlist end)\");\n\t\tif (!(rl + i)->length)\n\t\t\tbreak;\n\t}\n}",
          "includes": [
            "#include \"debug.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"debug.h\"\n\nvoid ntfs_debug_dump_runlist(const runlist_element *rl)\n{\n\tint i;\n\tconst char *lcn_str[5] = { \"LCN_HOLE         \", \"LCN_RL_NOT_MAPPED\",\n\t\t\t\t   \"LCN_ENOENT       \", \"LCN_unknown      \" };\n\n\tif (!debug_msgs)\n\t\treturn;\n\tpr_debug(\"Dumping runlist (values in hex):\\n\");\n\tif (!rl) {\n\t\tpr_debug(\"Run list not present.\\n\");\n\t\treturn;\n\t}\n\tpr_debug(\"VCN              LCN               Run length\\n\");\n\tfor (i = 0; ; i++) {\n\t\tLCN lcn = (rl + i)->lcn;\n\n\t\tif (lcn < (LCN)0) {\n\t\t\tint index = -lcn - 1;\n\n\t\t\tif (index > -LCN_ENOENT - 1)\n\t\t\t\tindex = 3;\n\t\t\tpr_debug(\"%-16Lx %s %-16Lx%s\\n\",\n\t\t\t\t\t(long long)(rl + i)->vcn, lcn_str[index],\n\t\t\t\t\t(long long)(rl + i)->length,\n\t\t\t\t\t(rl + i)->length ? \"\" :\n\t\t\t\t\t\t\" (runlist end)\");\n\t\t} else\n\t\t\tpr_debug(\"%-16Lx %-16Lx  %-16Lx%s\\n\",\n\t\t\t\t\t(long long)(rl + i)->vcn,\n\t\t\t\t\t(long long)(rl + i)->lcn,\n\t\t\t\t\t(long long)(rl + i)->length,\n\t\t\t\t\t(rl + i)->length ? \"\" :\n\t\t\t\t\t\t\" (runlist end)\");\n\t\tif (!(rl + i)->length)\n\t\t\tbreak;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&ntfs_lock"
          ],
          "line": 1731
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&ntfs_lock"
          ],
          "line": 1726
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&ntfs_lock"
          ],
          "line": 1712
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&ntfs_lock"
          ],
          "line": 1708
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_debug",
          "args": [
            "\"Read %llu bytes from $UpCase (expected %zu bytes).\"",
            "i_size",
            "64 * 1024 * sizeof(ntfschar)"
          ],
          "line": 1705
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_unmap_page",
          "args": [
            "page"
          ],
          "line": 1697
        },
        "resolved": true,
        "details": {
          "function_name": "ntfs_unmap_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/aops.h",
          "lines": "40-44",
          "snippet": "static inline void ntfs_unmap_page(struct page *page)\n{\n\tkunmap(page);\n\tpage_cache_release(page);\n}",
          "includes": [
            "#include \"inode.h\"",
            "#include <linux/fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"inode.h\"\n#include <linux/fs.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\nstatic inline void ntfs_unmap_page(struct page *page)\n{\n\tkunmap(page);\n\tpage_cache_release(page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "(char*)vol->upcase + (index++ << PAGE_CACHE_SHIFT)",
            "page_address(page)",
            "size"
          ],
          "line": 1695
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_address",
          "args": [
            "page"
          ],
          "line": 1696
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "page"
          ],
          "line": 1693
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_map_page",
          "args": [
            "ino->i_mapping",
            "index"
          ],
          "line": 1692
        },
        "resolved": true,
        "details": {
          "function_name": "ntfs_map_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/aops.h",
          "lines": "86-99",
          "snippet": "static inline struct page *ntfs_map_page(struct address_space *mapping,\n\t\tunsigned long index)\n{\n\tstruct page *page = read_mapping_page(mapping, index, NULL);\n\n\tif (!IS_ERR(page)) {\n\t\tkmap(page);\n\t\tif (!PageError(page))\n\t\t\treturn page;\n\t\tntfs_unmap_page(page);\n\t\treturn ERR_PTR(-EIO);\n\t}\n\treturn page;\n}",
          "includes": [
            "#include \"inode.h\"",
            "#include <linux/fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"inode.h\"\n#include <linux/fs.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\nstatic inline struct page *ntfs_map_page(struct address_space *mapping,\n\t\tunsigned long index)\n{\n\tstruct page *page = read_mapping_page(mapping, index, NULL);\n\n\tif (!IS_ERR(page)) {\n\t\tkmap(page);\n\t\tif (!PageError(page))\n\t\t\treturn page;\n\t\tntfs_unmap_page(page);\n\t\treturn ERR_PTR(-EIO);\n\t}\n\treturn page;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ntfs_malloc_nofs",
          "args": [
            "i_size"
          ],
          "line": 1683
        },
        "resolved": true,
        "details": {
          "function_name": "ntfs_malloc_nofs_nofail",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/malloc.h",
          "lines": "81-84",
          "snippet": "static inline void *ntfs_malloc_nofs_nofail(unsigned long size)\n{\n\treturn __ntfs_malloc(size, GFP_NOFS | __GFP_HIGHMEM | __GFP_NOFAIL);\n}",
          "includes": [
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/vmalloc.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n\nstatic inline void *ntfs_malloc_nofs_nofail(unsigned long size)\n{\n\treturn __ntfs_malloc(size, GFP_NOFS | __GFP_HIGHMEM | __GFP_NOFAIL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "i_size_read",
          "args": [
            "ino"
          ],
          "line": 1679
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "ino"
          ],
          "line": 1671
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_bad_inode",
          "args": [
            "ino"
          ],
          "line": 1670
        },
        "resolved": true,
        "details": {
          "function_name": "is_bad_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/bad_inode.c",
          "lines": "195-198",
          "snippet": "int is_bad_inode(struct inode *inode)\n{\n\treturn (inode->i_op == &bad_inode_ops);\t\n}",
          "includes": [
            "#include <linux/poll.h>",
            "#include <linux/namei.h>",
            "#include <linux/time.h>",
            "#include <linux/stat.h>",
            "#include <linux/export.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct inode_operations bad_inode_ops =\n{\n\t.create\t\t= bad_inode_create,\n\t.lookup\t\t= bad_inode_lookup,\n\t.link\t\t= bad_inode_link,\n\t.unlink\t\t= bad_inode_unlink,\n\t.symlink\t= bad_inode_symlink,\n\t.mkdir\t\t= bad_inode_mkdir,\n\t.rmdir\t\t= bad_inode_rmdir,\n\t.mknod\t\t= bad_inode_mknod,\n\t.rename2\t= bad_inode_rename2,\n\t.readlink\t= bad_inode_readlink,\n\t/* follow_link must be no-op, otherwise unmounting this inode\n\t   won't work */\n\t/* put_link returns void */\n\t/* truncate returns void */\n\t.permission\t= bad_inode_permission,\n\t.getattr\t= bad_inode_getattr,\n\t.setattr\t= bad_inode_setattr,\n\t.setxattr\t= bad_inode_setxattr,\n\t.getxattr\t= bad_inode_getxattr,\n\t.listxattr\t= bad_inode_listxattr,\n\t.removexattr\t= bad_inode_removexattr,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/poll.h>\n#include <linux/namei.h>\n#include <linux/time.h>\n#include <linux/stat.h>\n#include <linux/export.h>\n#include <linux/fs.h>\n\nstatic const struct inode_operations bad_inode_ops =\n{\n\t.create\t\t= bad_inode_create,\n\t.lookup\t\t= bad_inode_lookup,\n\t.link\t\t= bad_inode_link,\n\t.unlink\t\t= bad_inode_unlink,\n\t.symlink\t= bad_inode_symlink,\n\t.mkdir\t\t= bad_inode_mkdir,\n\t.rmdir\t\t= bad_inode_rmdir,\n\t.mknod\t\t= bad_inode_mknod,\n\t.rename2\t= bad_inode_rename2,\n\t.readlink\t= bad_inode_readlink,\n\t/* follow_link must be no-op, otherwise unmounting this inode\n\t   won't work */\n\t/* put_link returns void */\n\t/* truncate returns void */\n\t.permission\t= bad_inode_permission,\n\t.getattr\t= bad_inode_getattr,\n\t.setattr\t= bad_inode_setattr,\n\t.setxattr\t= bad_inode_setxattr,\n\t.getxattr\t= bad_inode_getxattr,\n\t.listxattr\t= bad_inode_listxattr,\n\t.removexattr\t= bad_inode_removexattr,\n};\n\nint is_bad_inode(struct inode *inode)\n{\n\treturn (inode->i_op == &bad_inode_ops);\t\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "ino"
          ],
          "line": 1670
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_iget",
          "args": [
            "sb",
            "FILE_UpCase"
          ],
          "line": 1669
        },
        "resolved": true,
        "details": {
          "function_name": "ntfs_iget",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/inode.c",
          "lines": "171-203",
          "snippet": "struct inode *ntfs_iget(struct super_block *sb, unsigned long mft_no)\n{\n\tstruct inode *vi;\n\tint err;\n\tntfs_attr na;\n\n\tna.mft_no = mft_no;\n\tna.type = AT_UNUSED;\n\tna.name = NULL;\n\tna.name_len = 0;\n\n\tvi = iget5_locked(sb, mft_no, (test_t)ntfs_test_inode,\n\t\t\t(set_t)ntfs_init_locked_inode, &na);\n\tif (unlikely(!vi))\n\t\treturn ERR_PTR(-ENOMEM);\n\n\terr = 0;\n\n\t/* If this is a freshly allocated inode, need to read it now. */\n\tif (vi->i_state & I_NEW) {\n\t\terr = ntfs_read_locked_inode(vi);\n\t\tunlock_new_inode(vi);\n\t}\n\t/*\n\t * There is no point in keeping bad inodes around if the failure was\n\t * due to ENOMEM. We want to be able to retry again later.\n\t */\n\tif (unlikely(err == -ENOMEM)) {\n\t\tiput(vi);\n\t\tvi = ERR_PTR(err);\n\t}\n\treturn vi;\n}",
          "includes": [
            "#include \"ntfs.h\"",
            "#include \"time.h\"",
            "#include \"mft.h\"",
            "#include \"malloc.h\"",
            "#include \"lcnalloc.h\"",
            "#include \"inode.h\"",
            "#include \"debug.h\"",
            "#include \"dir.h\"",
            "#include \"bitmap.h\"",
            "#include \"attrib.h\"",
            "#include \"aops.h\"",
            "#include <linux/aio.h>",
            "#include <linux/log2.h>",
            "#include <linux/slab.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mutex.h>",
            "#include <linux/mount.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ntfs_read_locked_inode(struct inode *vi);",
            "static int ntfs_read_locked_attr_inode(struct inode *base_vi, struct inode *vi);",
            "static int ntfs_read_locked_index_inode(struct inode *base_vi,\n\t\tstruct inode *vi);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ntfs.h\"\n#include \"time.h\"\n#include \"mft.h\"\n#include \"malloc.h\"\n#include \"lcnalloc.h\"\n#include \"inode.h\"\n#include \"debug.h\"\n#include \"dir.h\"\n#include \"bitmap.h\"\n#include \"attrib.h\"\n#include \"aops.h\"\n#include <linux/aio.h>\n#include <linux/log2.h>\n#include <linux/slab.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/mutex.h>\n#include <linux/mount.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n\nstatic int ntfs_read_locked_inode(struct inode *vi);\nstatic int ntfs_read_locked_attr_inode(struct inode *base_vi, struct inode *vi);\nstatic int ntfs_read_locked_index_inode(struct inode *base_vi,\n\t\tstruct inode *vi);\n\nstruct inode *ntfs_iget(struct super_block *sb, unsigned long mft_no)\n{\n\tstruct inode *vi;\n\tint err;\n\tntfs_attr na;\n\n\tna.mft_no = mft_no;\n\tna.type = AT_UNUSED;\n\tna.name = NULL;\n\tna.name_len = 0;\n\n\tvi = iget5_locked(sb, mft_no, (test_t)ntfs_test_inode,\n\t\t\t(set_t)ntfs_init_locked_inode, &na);\n\tif (unlikely(!vi))\n\t\treturn ERR_PTR(-ENOMEM);\n\n\terr = 0;\n\n\t/* If this is a freshly allocated inode, need to read it now. */\n\tif (vi->i_state & I_NEW) {\n\t\terr = ntfs_read_locked_inode(vi);\n\t\tunlock_new_inode(vi);\n\t}\n\t/*\n\t * There is no point in keeping bad inodes around if the failure was\n\t * due to ENOMEM. We want to be able to retry again later.\n\t */\n\tif (unlikely(err == -ENOMEM)) {\n\t\tiput(vi);\n\t\tvi = ERR_PTR(err);\n\t}\n\treturn vi;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ntfs.h\"\n#include \"malloc.h\"\n#include \"layout.h\"\n#include \"aops.h\"\n#include \"inode.h\"\n#include \"index.h\"\n#include \"debug.h\"\n#include \"dir.h\"\n#include \"usnjrnl.h\"\n#include \"quota.h\"\n#include \"logfile.h\"\n#include \"sysctl.h\"\n#include <linux/bitmap.h>\n#include <linux/moduleparam.h>\n#include <linux/vfs.h>\n#include <linux/buffer_head.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\t/* For bdev_logical_block_size(). */\n#include <linux/spinlock.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/stddef.h>\n\nstatic ntfschar *default_upcase;\nstatic unsigned long ntfs_nr_upcase_users;\n\nstatic bool load_and_init_upcase(ntfs_volume *vol)\n{\n\tloff_t i_size;\n\tstruct super_block *sb = vol->sb;\n\tstruct inode *ino;\n\tstruct page *page;\n\tpgoff_t index, max_index;\n\tunsigned int size;\n\tint i, max;\n\n\tntfs_debug(\"Entering.\");\n\t/* Read upcase table and setup vol->upcase and vol->upcase_len. */\n\tino = ntfs_iget(sb, FILE_UpCase);\n\tif (IS_ERR(ino) || is_bad_inode(ino)) {\n\t\tif (!IS_ERR(ino))\n\t\t\tiput(ino);\n\t\tgoto upcase_failed;\n\t}\n\t/*\n\t * The upcase size must not be above 64k Unicode characters, must not\n\t * be zero and must be a multiple of sizeof(ntfschar).\n\t */\n\ti_size = i_size_read(ino);\n\tif (!i_size || i_size & (sizeof(ntfschar) - 1) ||\n\t\t\ti_size > 64ULL * 1024 * sizeof(ntfschar))\n\t\tgoto iput_upcase_failed;\n\tvol->upcase = (ntfschar*)ntfs_malloc_nofs(i_size);\n\tif (!vol->upcase)\n\t\tgoto iput_upcase_failed;\n\tindex = 0;\n\tmax_index = i_size >> PAGE_CACHE_SHIFT;\n\tsize = PAGE_CACHE_SIZE;\n\twhile (index < max_index) {\n\t\t/* Read the upcase table and copy it into the linear buffer. */\nread_partial_upcase_page:\n\t\tpage = ntfs_map_page(ino->i_mapping, index);\n\t\tif (IS_ERR(page))\n\t\t\tgoto iput_upcase_failed;\n\t\tmemcpy((char*)vol->upcase + (index++ << PAGE_CACHE_SHIFT),\n\t\t\t\tpage_address(page), size);\n\t\tntfs_unmap_page(page);\n\t};\n\tif (size == PAGE_CACHE_SIZE) {\n\t\tsize = i_size & ~PAGE_CACHE_MASK;\n\t\tif (size)\n\t\t\tgoto read_partial_upcase_page;\n\t}\n\tvol->upcase_len = i_size >> UCHAR_T_SIZE_BITS;\n\tntfs_debug(\"Read %llu bytes from $UpCase (expected %zu bytes).\",\n\t\t\ti_size, 64 * 1024 * sizeof(ntfschar));\n\tiput(ino);\n\tmutex_lock(&ntfs_lock);\n\tif (!default_upcase) {\n\t\tntfs_debug(\"Using volume specified $UpCase since default is \"\n\t\t\t\t\"not present.\");\n\t\tmutex_unlock(&ntfs_lock);\n\t\treturn true;\n\t}\n\tmax = default_upcase_len;\n\tif (max > vol->upcase_len)\n\t\tmax = vol->upcase_len;\n\tfor (i = 0; i < max; i++)\n\t\tif (vol->upcase[i] != default_upcase[i])\n\t\t\tbreak;\n\tif (i == max) {\n\t\tntfs_free(vol->upcase);\n\t\tvol->upcase = default_upcase;\n\t\tvol->upcase_len = max;\n\t\tntfs_nr_upcase_users++;\n\t\tmutex_unlock(&ntfs_lock);\n\t\tntfs_debug(\"Volume specified $UpCase matches default. Using \"\n\t\t\t\t\"default.\");\n\t\treturn true;\n\t}\n\tmutex_unlock(&ntfs_lock);\n\tntfs_debug(\"Using volume specified $UpCase since it does not match \"\n\t\t\t\"the default.\");\n\treturn true;\niput_upcase_failed:\n\tiput(ino);\n\tntfs_free(vol->upcase);\n\tvol->upcase = NULL;\nupcase_failed:\n\tmutex_lock(&ntfs_lock);\n\tif (default_upcase) {\n\t\tvol->upcase = default_upcase;\n\t\tvol->upcase_len = default_upcase_len;\n\t\tntfs_nr_upcase_users++;\n\t\tmutex_unlock(&ntfs_lock);\n\t\tntfs_error(sb, \"Failed to load $UpCase from the volume. Using \"\n\t\t\t\t\"default.\");\n\t\treturn true;\n\t}\n\tmutex_unlock(&ntfs_lock);\n\tntfs_error(sb, \"Failed to initialize upcase table.\");\n\treturn false;\n}"
  },
  {
    "function_name": "load_and_init_attrdef",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/super.c",
    "lines": "1592-1647",
    "snippet": "static bool load_and_init_attrdef(ntfs_volume *vol)\n{\n\tloff_t i_size;\n\tstruct super_block *sb = vol->sb;\n\tstruct inode *ino;\n\tstruct page *page;\n\tpgoff_t index, max_index;\n\tunsigned int size;\n\n\tntfs_debug(\"Entering.\");\n\t/* Read attrdef table and setup vol->attrdef and vol->attrdef_size. */\n\tino = ntfs_iget(sb, FILE_AttrDef);\n\tif (IS_ERR(ino) || is_bad_inode(ino)) {\n\t\tif (!IS_ERR(ino))\n\t\t\tiput(ino);\n\t\tgoto failed;\n\t}\n\tNInoSetSparseDisabled(NTFS_I(ino));\n\t/* The size of FILE_AttrDef must be above 0 and fit inside 31 bits. */\n\ti_size = i_size_read(ino);\n\tif (i_size <= 0 || i_size > 0x7fffffff)\n\t\tgoto iput_failed;\n\tvol->attrdef = (ATTR_DEF*)ntfs_malloc_nofs(i_size);\n\tif (!vol->attrdef)\n\t\tgoto iput_failed;\n\tindex = 0;\n\tmax_index = i_size >> PAGE_CACHE_SHIFT;\n\tsize = PAGE_CACHE_SIZE;\n\twhile (index < max_index) {\n\t\t/* Read the attrdef table and copy it into the linear buffer. */\nread_partial_attrdef_page:\n\t\tpage = ntfs_map_page(ino->i_mapping, index);\n\t\tif (IS_ERR(page))\n\t\t\tgoto free_iput_failed;\n\t\tmemcpy((u8*)vol->attrdef + (index++ << PAGE_CACHE_SHIFT),\n\t\t\t\tpage_address(page), size);\n\t\tntfs_unmap_page(page);\n\t};\n\tif (size == PAGE_CACHE_SIZE) {\n\t\tsize = i_size & ~PAGE_CACHE_MASK;\n\t\tif (size)\n\t\t\tgoto read_partial_attrdef_page;\n\t}\n\tvol->attrdef_size = i_size;\n\tntfs_debug(\"Read %llu bytes from $AttrDef.\", i_size);\n\tiput(ino);\n\treturn true;\nfree_iput_failed:\n\tntfs_free(vol->attrdef);\n\tvol->attrdef = NULL;\niput_failed:\n\tiput(ino);\nfailed:\n\tntfs_error(sb, \"Failed to initialize attribute definition table.\");\n\treturn false;\n}",
    "includes": [
      "#include \"ntfs.h\"",
      "#include \"malloc.h\"",
      "#include \"layout.h\"",
      "#include \"aops.h\"",
      "#include \"inode.h\"",
      "#include \"index.h\"",
      "#include \"debug.h\"",
      "#include \"dir.h\"",
      "#include \"usnjrnl.h\"",
      "#include \"quota.h\"",
      "#include \"logfile.h\"",
      "#include \"sysctl.h\"",
      "#include <linux/bitmap.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/vfs.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/blkdev.h>\t/* For bdev_logical_block_size(). */",
      "#include <linux/spinlock.h>",
      "#include <linux/string.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/stddef.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ntfs_error",
          "args": [
            "sb",
            "\"Failed to initialize attribute definition table.\""
          ],
          "line": 1645
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "iput",
          "args": [
            "ino"
          ],
          "line": 1643
        },
        "resolved": true,
        "details": {
          "function_name": "dentry_iput",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "308-327",
          "snippet": "static void dentry_iput(struct dentry * dentry)\n\t__releases(dentry->d_lock)\n\t__releases(dentry->d_inode->i_lock)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tif (inode) {\n\t\tdentry->d_inode = NULL;\n\t\thlist_del_init(&dentry->d_u.d_alias);\n\t\tspin_unlock(&dentry->d_lock);\n\t\tspin_unlock(&inode->i_lock);\n\t\tif (!inode->i_nlink)\n\t\t\tfsnotify_inoderemove(inode);\n\t\tif (dentry->d_op && dentry->d_op->d_iput)\n\t\t\tdentry->d_op->d_iput(dentry, inode);\n\t\telse\n\t\t\tiput(inode);\n\t} else {\n\t\tspin_unlock(&dentry->d_lock);\n\t}\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nstatic void dentry_iput(struct dentry * dentry)\n\t__releases(dentry->d_lock)\n\t__releases(dentry->d_inode->i_lock)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tif (inode) {\n\t\tdentry->d_inode = NULL;\n\t\thlist_del_init(&dentry->d_u.d_alias);\n\t\tspin_unlock(&dentry->d_lock);\n\t\tspin_unlock(&inode->i_lock);\n\t\tif (!inode->i_nlink)\n\t\t\tfsnotify_inoderemove(inode);\n\t\tif (dentry->d_op && dentry->d_op->d_iput)\n\t\t\tdentry->d_op->d_iput(dentry, inode);\n\t\telse\n\t\t\tiput(inode);\n\t} else {\n\t\tspin_unlock(&dentry->d_lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ntfs_free",
          "args": [
            "vol->attrdef"
          ],
          "line": 1640
        },
        "resolved": true,
        "details": {
          "function_name": "ntfs_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/malloc.h",
          "lines": "86-94",
          "snippet": "static inline void ntfs_free(void *addr)\n{\n\tif (!is_vmalloc_addr(addr)) {\n\t\tkfree(addr);\n\t\t/* free_page((unsigned long)addr); */\n\t\treturn;\n\t}\n\tvfree(addr);\n}",
          "includes": [
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/vmalloc.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n\nstatic inline void ntfs_free(void *addr)\n{\n\tif (!is_vmalloc_addr(addr)) {\n\t\tkfree(addr);\n\t\t/* free_page((unsigned long)addr); */\n\t\treturn;\n\t}\n\tvfree(addr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ntfs_debug",
          "args": [
            "\"Read %llu bytes from $AttrDef.\"",
            "i_size"
          ],
          "line": 1636
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_unmap_page",
          "args": [
            "page"
          ],
          "line": 1628
        },
        "resolved": true,
        "details": {
          "function_name": "ntfs_unmap_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/aops.h",
          "lines": "40-44",
          "snippet": "static inline void ntfs_unmap_page(struct page *page)\n{\n\tkunmap(page);\n\tpage_cache_release(page);\n}",
          "includes": [
            "#include \"inode.h\"",
            "#include <linux/fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"inode.h\"\n#include <linux/fs.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\nstatic inline void ntfs_unmap_page(struct page *page)\n{\n\tkunmap(page);\n\tpage_cache_release(page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "(u8*)vol->attrdef + (index++ << PAGE_CACHE_SHIFT)",
            "page_address(page)",
            "size"
          ],
          "line": 1626
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_address",
          "args": [
            "page"
          ],
          "line": 1627
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "page"
          ],
          "line": 1624
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_map_page",
          "args": [
            "ino->i_mapping",
            "index"
          ],
          "line": 1623
        },
        "resolved": true,
        "details": {
          "function_name": "ntfs_map_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/aops.h",
          "lines": "86-99",
          "snippet": "static inline struct page *ntfs_map_page(struct address_space *mapping,\n\t\tunsigned long index)\n{\n\tstruct page *page = read_mapping_page(mapping, index, NULL);\n\n\tif (!IS_ERR(page)) {\n\t\tkmap(page);\n\t\tif (!PageError(page))\n\t\t\treturn page;\n\t\tntfs_unmap_page(page);\n\t\treturn ERR_PTR(-EIO);\n\t}\n\treturn page;\n}",
          "includes": [
            "#include \"inode.h\"",
            "#include <linux/fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"inode.h\"\n#include <linux/fs.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\nstatic inline struct page *ntfs_map_page(struct address_space *mapping,\n\t\tunsigned long index)\n{\n\tstruct page *page = read_mapping_page(mapping, index, NULL);\n\n\tif (!IS_ERR(page)) {\n\t\tkmap(page);\n\t\tif (!PageError(page))\n\t\t\treturn page;\n\t\tntfs_unmap_page(page);\n\t\treturn ERR_PTR(-EIO);\n\t}\n\treturn page;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ntfs_malloc_nofs",
          "args": [
            "i_size"
          ],
          "line": 1614
        },
        "resolved": true,
        "details": {
          "function_name": "ntfs_malloc_nofs_nofail",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/malloc.h",
          "lines": "81-84",
          "snippet": "static inline void *ntfs_malloc_nofs_nofail(unsigned long size)\n{\n\treturn __ntfs_malloc(size, GFP_NOFS | __GFP_HIGHMEM | __GFP_NOFAIL);\n}",
          "includes": [
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/vmalloc.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n\nstatic inline void *ntfs_malloc_nofs_nofail(unsigned long size)\n{\n\treturn __ntfs_malloc(size, GFP_NOFS | __GFP_HIGHMEM | __GFP_NOFAIL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "i_size_read",
          "args": [
            "ino"
          ],
          "line": 1611
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NInoSetSparseDisabled",
          "args": [
            "NTFS_I(ino)"
          ],
          "line": 1609
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NTFS_I",
          "args": [
            "ino"
          ],
          "line": 1609
        },
        "resolved": true,
        "details": {
          "function_name": "NTFS_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/inode.h",
          "lines": "240-243",
          "snippet": "static inline ntfs_inode *NTFS_I(struct inode *inode)\n{\n\treturn (ntfs_inode *)list_entry(inode, big_ntfs_inode, vfs_inode);\n}",
          "includes": [
            "#include \"debug.h\"",
            "#include \"runlist.h\"",
            "#include \"types.h\"",
            "#include \"volume.h\"",
            "#include \"layout.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/mutex.h>",
            "#include <linux/mm.h>",
            "#include <linux/list.h>",
            "#include <linux/fs.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"debug.h\"\n#include \"runlist.h\"\n#include \"types.h\"\n#include \"volume.h\"\n#include \"layout.h\"\n#include <linux/seq_file.h>\n#include <linux/mutex.h>\n#include <linux/mm.h>\n#include <linux/list.h>\n#include <linux/fs.h>\n#include <linux/atomic.h>\n\nstatic inline ntfs_inode *NTFS_I(struct inode *inode)\n{\n\treturn (ntfs_inode *)list_entry(inode, big_ntfs_inode, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "ino"
          ],
          "line": 1605
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_bad_inode",
          "args": [
            "ino"
          ],
          "line": 1604
        },
        "resolved": true,
        "details": {
          "function_name": "is_bad_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/bad_inode.c",
          "lines": "195-198",
          "snippet": "int is_bad_inode(struct inode *inode)\n{\n\treturn (inode->i_op == &bad_inode_ops);\t\n}",
          "includes": [
            "#include <linux/poll.h>",
            "#include <linux/namei.h>",
            "#include <linux/time.h>",
            "#include <linux/stat.h>",
            "#include <linux/export.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct inode_operations bad_inode_ops =\n{\n\t.create\t\t= bad_inode_create,\n\t.lookup\t\t= bad_inode_lookup,\n\t.link\t\t= bad_inode_link,\n\t.unlink\t\t= bad_inode_unlink,\n\t.symlink\t= bad_inode_symlink,\n\t.mkdir\t\t= bad_inode_mkdir,\n\t.rmdir\t\t= bad_inode_rmdir,\n\t.mknod\t\t= bad_inode_mknod,\n\t.rename2\t= bad_inode_rename2,\n\t.readlink\t= bad_inode_readlink,\n\t/* follow_link must be no-op, otherwise unmounting this inode\n\t   won't work */\n\t/* put_link returns void */\n\t/* truncate returns void */\n\t.permission\t= bad_inode_permission,\n\t.getattr\t= bad_inode_getattr,\n\t.setattr\t= bad_inode_setattr,\n\t.setxattr\t= bad_inode_setxattr,\n\t.getxattr\t= bad_inode_getxattr,\n\t.listxattr\t= bad_inode_listxattr,\n\t.removexattr\t= bad_inode_removexattr,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/poll.h>\n#include <linux/namei.h>\n#include <linux/time.h>\n#include <linux/stat.h>\n#include <linux/export.h>\n#include <linux/fs.h>\n\nstatic const struct inode_operations bad_inode_ops =\n{\n\t.create\t\t= bad_inode_create,\n\t.lookup\t\t= bad_inode_lookup,\n\t.link\t\t= bad_inode_link,\n\t.unlink\t\t= bad_inode_unlink,\n\t.symlink\t= bad_inode_symlink,\n\t.mkdir\t\t= bad_inode_mkdir,\n\t.rmdir\t\t= bad_inode_rmdir,\n\t.mknod\t\t= bad_inode_mknod,\n\t.rename2\t= bad_inode_rename2,\n\t.readlink\t= bad_inode_readlink,\n\t/* follow_link must be no-op, otherwise unmounting this inode\n\t   won't work */\n\t/* put_link returns void */\n\t/* truncate returns void */\n\t.permission\t= bad_inode_permission,\n\t.getattr\t= bad_inode_getattr,\n\t.setattr\t= bad_inode_setattr,\n\t.setxattr\t= bad_inode_setxattr,\n\t.getxattr\t= bad_inode_getxattr,\n\t.listxattr\t= bad_inode_listxattr,\n\t.removexattr\t= bad_inode_removexattr,\n};\n\nint is_bad_inode(struct inode *inode)\n{\n\treturn (inode->i_op == &bad_inode_ops);\t\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "ino"
          ],
          "line": 1604
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_iget",
          "args": [
            "sb",
            "FILE_AttrDef"
          ],
          "line": 1603
        },
        "resolved": true,
        "details": {
          "function_name": "ntfs_iget",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/inode.c",
          "lines": "171-203",
          "snippet": "struct inode *ntfs_iget(struct super_block *sb, unsigned long mft_no)\n{\n\tstruct inode *vi;\n\tint err;\n\tntfs_attr na;\n\n\tna.mft_no = mft_no;\n\tna.type = AT_UNUSED;\n\tna.name = NULL;\n\tna.name_len = 0;\n\n\tvi = iget5_locked(sb, mft_no, (test_t)ntfs_test_inode,\n\t\t\t(set_t)ntfs_init_locked_inode, &na);\n\tif (unlikely(!vi))\n\t\treturn ERR_PTR(-ENOMEM);\n\n\terr = 0;\n\n\t/* If this is a freshly allocated inode, need to read it now. */\n\tif (vi->i_state & I_NEW) {\n\t\terr = ntfs_read_locked_inode(vi);\n\t\tunlock_new_inode(vi);\n\t}\n\t/*\n\t * There is no point in keeping bad inodes around if the failure was\n\t * due to ENOMEM. We want to be able to retry again later.\n\t */\n\tif (unlikely(err == -ENOMEM)) {\n\t\tiput(vi);\n\t\tvi = ERR_PTR(err);\n\t}\n\treturn vi;\n}",
          "includes": [
            "#include \"ntfs.h\"",
            "#include \"time.h\"",
            "#include \"mft.h\"",
            "#include \"malloc.h\"",
            "#include \"lcnalloc.h\"",
            "#include \"inode.h\"",
            "#include \"debug.h\"",
            "#include \"dir.h\"",
            "#include \"bitmap.h\"",
            "#include \"attrib.h\"",
            "#include \"aops.h\"",
            "#include <linux/aio.h>",
            "#include <linux/log2.h>",
            "#include <linux/slab.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mutex.h>",
            "#include <linux/mount.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ntfs_read_locked_inode(struct inode *vi);",
            "static int ntfs_read_locked_attr_inode(struct inode *base_vi, struct inode *vi);",
            "static int ntfs_read_locked_index_inode(struct inode *base_vi,\n\t\tstruct inode *vi);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ntfs.h\"\n#include \"time.h\"\n#include \"mft.h\"\n#include \"malloc.h\"\n#include \"lcnalloc.h\"\n#include \"inode.h\"\n#include \"debug.h\"\n#include \"dir.h\"\n#include \"bitmap.h\"\n#include \"attrib.h\"\n#include \"aops.h\"\n#include <linux/aio.h>\n#include <linux/log2.h>\n#include <linux/slab.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/mutex.h>\n#include <linux/mount.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n\nstatic int ntfs_read_locked_inode(struct inode *vi);\nstatic int ntfs_read_locked_attr_inode(struct inode *base_vi, struct inode *vi);\nstatic int ntfs_read_locked_index_inode(struct inode *base_vi,\n\t\tstruct inode *vi);\n\nstruct inode *ntfs_iget(struct super_block *sb, unsigned long mft_no)\n{\n\tstruct inode *vi;\n\tint err;\n\tntfs_attr na;\n\n\tna.mft_no = mft_no;\n\tna.type = AT_UNUSED;\n\tna.name = NULL;\n\tna.name_len = 0;\n\n\tvi = iget5_locked(sb, mft_no, (test_t)ntfs_test_inode,\n\t\t\t(set_t)ntfs_init_locked_inode, &na);\n\tif (unlikely(!vi))\n\t\treturn ERR_PTR(-ENOMEM);\n\n\terr = 0;\n\n\t/* If this is a freshly allocated inode, need to read it now. */\n\tif (vi->i_state & I_NEW) {\n\t\terr = ntfs_read_locked_inode(vi);\n\t\tunlock_new_inode(vi);\n\t}\n\t/*\n\t * There is no point in keeping bad inodes around if the failure was\n\t * due to ENOMEM. We want to be able to retry again later.\n\t */\n\tif (unlikely(err == -ENOMEM)) {\n\t\tiput(vi);\n\t\tvi = ERR_PTR(err);\n\t}\n\treturn vi;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ntfs_debug",
          "args": [
            "\"Entering.\""
          ],
          "line": 1601
        },
        "resolved": true,
        "details": {
          "function_name": "ntfs_debug_dump_runlist",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/debug.c",
          "lines": "134-171",
          "snippet": "void ntfs_debug_dump_runlist(const runlist_element *rl)\n{\n\tint i;\n\tconst char *lcn_str[5] = { \"LCN_HOLE         \", \"LCN_RL_NOT_MAPPED\",\n\t\t\t\t   \"LCN_ENOENT       \", \"LCN_unknown      \" };\n\n\tif (!debug_msgs)\n\t\treturn;\n\tpr_debug(\"Dumping runlist (values in hex):\\n\");\n\tif (!rl) {\n\t\tpr_debug(\"Run list not present.\\n\");\n\t\treturn;\n\t}\n\tpr_debug(\"VCN              LCN               Run length\\n\");\n\tfor (i = 0; ; i++) {\n\t\tLCN lcn = (rl + i)->lcn;\n\n\t\tif (lcn < (LCN)0) {\n\t\t\tint index = -lcn - 1;\n\n\t\t\tif (index > -LCN_ENOENT - 1)\n\t\t\t\tindex = 3;\n\t\t\tpr_debug(\"%-16Lx %s %-16Lx%s\\n\",\n\t\t\t\t\t(long long)(rl + i)->vcn, lcn_str[index],\n\t\t\t\t\t(long long)(rl + i)->length,\n\t\t\t\t\t(rl + i)->length ? \"\" :\n\t\t\t\t\t\t\" (runlist end)\");\n\t\t} else\n\t\t\tpr_debug(\"%-16Lx %-16Lx  %-16Lx%s\\n\",\n\t\t\t\t\t(long long)(rl + i)->vcn,\n\t\t\t\t\t(long long)(rl + i)->lcn,\n\t\t\t\t\t(long long)(rl + i)->length,\n\t\t\t\t\t(rl + i)->length ? \"\" :\n\t\t\t\t\t\t\" (runlist end)\");\n\t\tif (!(rl + i)->length)\n\t\t\tbreak;\n\t}\n}",
          "includes": [
            "#include \"debug.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"debug.h\"\n\nvoid ntfs_debug_dump_runlist(const runlist_element *rl)\n{\n\tint i;\n\tconst char *lcn_str[5] = { \"LCN_HOLE         \", \"LCN_RL_NOT_MAPPED\",\n\t\t\t\t   \"LCN_ENOENT       \", \"LCN_unknown      \" };\n\n\tif (!debug_msgs)\n\t\treturn;\n\tpr_debug(\"Dumping runlist (values in hex):\\n\");\n\tif (!rl) {\n\t\tpr_debug(\"Run list not present.\\n\");\n\t\treturn;\n\t}\n\tpr_debug(\"VCN              LCN               Run length\\n\");\n\tfor (i = 0; ; i++) {\n\t\tLCN lcn = (rl + i)->lcn;\n\n\t\tif (lcn < (LCN)0) {\n\t\t\tint index = -lcn - 1;\n\n\t\t\tif (index > -LCN_ENOENT - 1)\n\t\t\t\tindex = 3;\n\t\t\tpr_debug(\"%-16Lx %s %-16Lx%s\\n\",\n\t\t\t\t\t(long long)(rl + i)->vcn, lcn_str[index],\n\t\t\t\t\t(long long)(rl + i)->length,\n\t\t\t\t\t(rl + i)->length ? \"\" :\n\t\t\t\t\t\t\" (runlist end)\");\n\t\t} else\n\t\t\tpr_debug(\"%-16Lx %-16Lx  %-16Lx%s\\n\",\n\t\t\t\t\t(long long)(rl + i)->vcn,\n\t\t\t\t\t(long long)(rl + i)->lcn,\n\t\t\t\t\t(long long)(rl + i)->length,\n\t\t\t\t\t(rl + i)->length ? \"\" :\n\t\t\t\t\t\t\" (runlist end)\");\n\t\tif (!(rl + i)->length)\n\t\t\tbreak;\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ntfs.h\"\n#include \"malloc.h\"\n#include \"layout.h\"\n#include \"aops.h\"\n#include \"inode.h\"\n#include \"index.h\"\n#include \"debug.h\"\n#include \"dir.h\"\n#include \"usnjrnl.h\"\n#include \"quota.h\"\n#include \"logfile.h\"\n#include \"sysctl.h\"\n#include <linux/bitmap.h>\n#include <linux/moduleparam.h>\n#include <linux/vfs.h>\n#include <linux/buffer_head.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\t/* For bdev_logical_block_size(). */\n#include <linux/spinlock.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/stddef.h>\n\nstatic bool load_and_init_attrdef(ntfs_volume *vol)\n{\n\tloff_t i_size;\n\tstruct super_block *sb = vol->sb;\n\tstruct inode *ino;\n\tstruct page *page;\n\tpgoff_t index, max_index;\n\tunsigned int size;\n\n\tntfs_debug(\"Entering.\");\n\t/* Read attrdef table and setup vol->attrdef and vol->attrdef_size. */\n\tino = ntfs_iget(sb, FILE_AttrDef);\n\tif (IS_ERR(ino) || is_bad_inode(ino)) {\n\t\tif (!IS_ERR(ino))\n\t\t\tiput(ino);\n\t\tgoto failed;\n\t}\n\tNInoSetSparseDisabled(NTFS_I(ino));\n\t/* The size of FILE_AttrDef must be above 0 and fit inside 31 bits. */\n\ti_size = i_size_read(ino);\n\tif (i_size <= 0 || i_size > 0x7fffffff)\n\t\tgoto iput_failed;\n\tvol->attrdef = (ATTR_DEF*)ntfs_malloc_nofs(i_size);\n\tif (!vol->attrdef)\n\t\tgoto iput_failed;\n\tindex = 0;\n\tmax_index = i_size >> PAGE_CACHE_SHIFT;\n\tsize = PAGE_CACHE_SIZE;\n\twhile (index < max_index) {\n\t\t/* Read the attrdef table and copy it into the linear buffer. */\nread_partial_attrdef_page:\n\t\tpage = ntfs_map_page(ino->i_mapping, index);\n\t\tif (IS_ERR(page))\n\t\t\tgoto free_iput_failed;\n\t\tmemcpy((u8*)vol->attrdef + (index++ << PAGE_CACHE_SHIFT),\n\t\t\t\tpage_address(page), size);\n\t\tntfs_unmap_page(page);\n\t};\n\tif (size == PAGE_CACHE_SIZE) {\n\t\tsize = i_size & ~PAGE_CACHE_MASK;\n\t\tif (size)\n\t\t\tgoto read_partial_attrdef_page;\n\t}\n\tvol->attrdef_size = i_size;\n\tntfs_debug(\"Read %llu bytes from $AttrDef.\", i_size);\n\tiput(ino);\n\treturn true;\nfree_iput_failed:\n\tntfs_free(vol->attrdef);\n\tvol->attrdef = NULL;\niput_failed:\n\tiput(ino);\nfailed:\n\tntfs_error(sb, \"Failed to initialize attribute definition table.\");\n\treturn false;\n}"
  },
  {
    "function_name": "load_and_init_usnjrnl",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/super.c",
    "lines": "1439-1584",
    "snippet": "static bool load_and_init_usnjrnl(ntfs_volume *vol)\n{\n\tMFT_REF mref;\n\tstruct inode *tmp_ino;\n\tntfs_inode *tmp_ni;\n\tstruct page *page;\n\tntfs_name *name = NULL;\n\tUSN_HEADER *uh;\n\tstatic const ntfschar UsnJrnl[9] = { cpu_to_le16('$'),\n\t\t\tcpu_to_le16('U'), cpu_to_le16('s'),\n\t\t\tcpu_to_le16('n'), cpu_to_le16('J'),\n\t\t\tcpu_to_le16('r'), cpu_to_le16('n'),\n\t\t\tcpu_to_le16('l'), 0 };\n\tstatic ntfschar Max[5] = { cpu_to_le16('$'),\n\t\t\tcpu_to_le16('M'), cpu_to_le16('a'),\n\t\t\tcpu_to_le16('x'), 0 };\n\tstatic ntfschar J[3] = { cpu_to_le16('$'),\n\t\t\tcpu_to_le16('J'), 0 };\n\n\tntfs_debug(\"Entering.\");\n\t/*\n\t * Find the inode number for the transaction log file by looking up the\n\t * filename $UsnJrnl in the extended system files directory $Extend.\n\t */\n\tmutex_lock(&vol->extend_ino->i_mutex);\n\tmref = ntfs_lookup_inode_by_name(NTFS_I(vol->extend_ino), UsnJrnl, 8,\n\t\t\t&name);\n\tmutex_unlock(&vol->extend_ino->i_mutex);\n\tif (IS_ERR_MREF(mref)) {\n\t\t/*\n\t\t * If the file does not exist, transaction logging is disabled,\n\t\t * just return success.\n\t\t */\n\t\tif (MREF_ERR(mref) == -ENOENT) {\n\t\t\tntfs_debug(\"$UsnJrnl not present.  Volume does not \"\n\t\t\t\t\t\"have transaction logging enabled.\");\nnot_enabled:\n\t\t\t/*\n\t\t\t * No need to try to stamp the transaction log if\n\t\t\t * transaction logging is not enabled.\n\t\t\t */\n\t\t\tNVolSetUsnJrnlStamped(vol);\n\t\t\treturn true;\n\t\t}\n\t\t/* A real error occurred. */\n\t\tntfs_error(vol->sb, \"Failed to find inode number for \"\n\t\t\t\t\"$UsnJrnl.\");\n\t\treturn false;\n\t}\n\t/* We do not care for the type of match that was found. */\n\tkfree(name);\n\t/* Get the inode. */\n\ttmp_ino = ntfs_iget(vol->sb, MREF(mref));\n\tif (unlikely(IS_ERR(tmp_ino) || is_bad_inode(tmp_ino))) {\n\t\tif (!IS_ERR(tmp_ino))\n\t\t\tiput(tmp_ino);\n\t\tntfs_error(vol->sb, \"Failed to load $UsnJrnl.\");\n\t\treturn false;\n\t}\n\tvol->usnjrnl_ino = tmp_ino;\n\t/*\n\t * If the transaction log is in the process of being deleted, we can\n\t * ignore it.\n\t */\n\tif (unlikely(vol->vol_flags & VOLUME_DELETE_USN_UNDERWAY)) {\n\t\tntfs_debug(\"$UsnJrnl in the process of being disabled.  \"\n\t\t\t\t\"Volume does not have transaction logging \"\n\t\t\t\t\"enabled.\");\n\t\tgoto not_enabled;\n\t}\n\t/* Get the $DATA/$Max attribute. */\n\ttmp_ino = ntfs_attr_iget(vol->usnjrnl_ino, AT_DATA, Max, 4);\n\tif (IS_ERR(tmp_ino)) {\n\t\tntfs_error(vol->sb, \"Failed to load $UsnJrnl/$DATA/$Max \"\n\t\t\t\t\"attribute.\");\n\t\treturn false;\n\t}\n\tvol->usnjrnl_max_ino = tmp_ino;\n\tif (unlikely(i_size_read(tmp_ino) < sizeof(USN_HEADER))) {\n\t\tntfs_error(vol->sb, \"Found corrupt $UsnJrnl/$DATA/$Max \"\n\t\t\t\t\"attribute (size is 0x%llx but should be at \"\n\t\t\t\t\"least 0x%zx bytes).\", i_size_read(tmp_ino),\n\t\t\t\tsizeof(USN_HEADER));\n\t\treturn false;\n\t}\n\t/* Get the $DATA/$J attribute. */\n\ttmp_ino = ntfs_attr_iget(vol->usnjrnl_ino, AT_DATA, J, 2);\n\tif (IS_ERR(tmp_ino)) {\n\t\tntfs_error(vol->sb, \"Failed to load $UsnJrnl/$DATA/$J \"\n\t\t\t\t\"attribute.\");\n\t\treturn false;\n\t}\n\tvol->usnjrnl_j_ino = tmp_ino;\n\t/* Verify $J is non-resident and sparse. */\n\ttmp_ni = NTFS_I(vol->usnjrnl_j_ino);\n\tif (unlikely(!NInoNonResident(tmp_ni) || !NInoSparse(tmp_ni))) {\n\t\tntfs_error(vol->sb, \"$UsnJrnl/$DATA/$J attribute is resident \"\n\t\t\t\t\"and/or not sparse.\");\n\t\treturn false;\n\t}\n\t/* Read the USN_HEADER from $DATA/$Max. */\n\tpage = ntfs_map_page(vol->usnjrnl_max_ino->i_mapping, 0);\n\tif (IS_ERR(page)) {\n\t\tntfs_error(vol->sb, \"Failed to read from $UsnJrnl/$DATA/$Max \"\n\t\t\t\t\"attribute.\");\n\t\treturn false;\n\t}\n\tuh = (USN_HEADER*)page_address(page);\n\t/* Sanity check the $Max. */\n\tif (unlikely(sle64_to_cpu(uh->allocation_delta) >\n\t\t\tsle64_to_cpu(uh->maximum_size))) {\n\t\tntfs_error(vol->sb, \"Allocation delta (0x%llx) exceeds \"\n\t\t\t\t\"maximum size (0x%llx).  $UsnJrnl is corrupt.\",\n\t\t\t\t(long long)sle64_to_cpu(uh->allocation_delta),\n\t\t\t\t(long long)sle64_to_cpu(uh->maximum_size));\n\t\tntfs_unmap_page(page);\n\t\treturn false;\n\t}\n\t/*\n\t * If the transaction log has been stamped and nothing has been written\n\t * to it since, we do not need to stamp it.\n\t */\n\tif (unlikely(sle64_to_cpu(uh->lowest_valid_usn) >=\n\t\t\ti_size_read(vol->usnjrnl_j_ino))) {\n\t\tif (likely(sle64_to_cpu(uh->lowest_valid_usn) ==\n\t\t\t\ti_size_read(vol->usnjrnl_j_ino))) {\n\t\t\tntfs_unmap_page(page);\n\t\t\tntfs_debug(\"$UsnJrnl is enabled but nothing has been \"\n\t\t\t\t\t\"logged since it was last stamped.  \"\n\t\t\t\t\t\"Treating this as if the volume does \"\n\t\t\t\t\t\"not have transaction logging \"\n\t\t\t\t\t\"enabled.\");\n\t\t\tgoto not_enabled;\n\t\t}\n\t\tntfs_error(vol->sb, \"$UsnJrnl has lowest valid usn (0x%llx) \"\n\t\t\t\t\"which is out of bounds (0x%llx).  $UsnJrnl \"\n\t\t\t\t\"is corrupt.\",\n\t\t\t\t(long long)sle64_to_cpu(uh->lowest_valid_usn),\n\t\t\t\ti_size_read(vol->usnjrnl_j_ino));\n\t\tntfs_unmap_page(page);\n\t\treturn false;\n\t}\n\tntfs_unmap_page(page);\n\tntfs_debug(\"Done.\");\n\treturn true;\n}",
    "includes": [
      "#include \"ntfs.h\"",
      "#include \"malloc.h\"",
      "#include \"layout.h\"",
      "#include \"aops.h\"",
      "#include \"inode.h\"",
      "#include \"index.h\"",
      "#include \"debug.h\"",
      "#include \"dir.h\"",
      "#include \"usnjrnl.h\"",
      "#include \"quota.h\"",
      "#include \"logfile.h\"",
      "#include \"sysctl.h\"",
      "#include <linux/bitmap.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/vfs.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/blkdev.h>\t/* For bdev_logical_block_size(). */",
      "#include <linux/spinlock.h>",
      "#include <linux/string.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/stddef.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ntfs_debug",
          "args": [
            "\"Done.\""
          ],
          "line": 1582
        },
        "resolved": true,
        "details": {
          "function_name": "ntfs_debug_dump_runlist",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/debug.c",
          "lines": "134-171",
          "snippet": "void ntfs_debug_dump_runlist(const runlist_element *rl)\n{\n\tint i;\n\tconst char *lcn_str[5] = { \"LCN_HOLE         \", \"LCN_RL_NOT_MAPPED\",\n\t\t\t\t   \"LCN_ENOENT       \", \"LCN_unknown      \" };\n\n\tif (!debug_msgs)\n\t\treturn;\n\tpr_debug(\"Dumping runlist (values in hex):\\n\");\n\tif (!rl) {\n\t\tpr_debug(\"Run list not present.\\n\");\n\t\treturn;\n\t}\n\tpr_debug(\"VCN              LCN               Run length\\n\");\n\tfor (i = 0; ; i++) {\n\t\tLCN lcn = (rl + i)->lcn;\n\n\t\tif (lcn < (LCN)0) {\n\t\t\tint index = -lcn - 1;\n\n\t\t\tif (index > -LCN_ENOENT - 1)\n\t\t\t\tindex = 3;\n\t\t\tpr_debug(\"%-16Lx %s %-16Lx%s\\n\",\n\t\t\t\t\t(long long)(rl + i)->vcn, lcn_str[index],\n\t\t\t\t\t(long long)(rl + i)->length,\n\t\t\t\t\t(rl + i)->length ? \"\" :\n\t\t\t\t\t\t\" (runlist end)\");\n\t\t} else\n\t\t\tpr_debug(\"%-16Lx %-16Lx  %-16Lx%s\\n\",\n\t\t\t\t\t(long long)(rl + i)->vcn,\n\t\t\t\t\t(long long)(rl + i)->lcn,\n\t\t\t\t\t(long long)(rl + i)->length,\n\t\t\t\t\t(rl + i)->length ? \"\" :\n\t\t\t\t\t\t\" (runlist end)\");\n\t\tif (!(rl + i)->length)\n\t\t\tbreak;\n\t}\n}",
          "includes": [
            "#include \"debug.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"debug.h\"\n\nvoid ntfs_debug_dump_runlist(const runlist_element *rl)\n{\n\tint i;\n\tconst char *lcn_str[5] = { \"LCN_HOLE         \", \"LCN_RL_NOT_MAPPED\",\n\t\t\t\t   \"LCN_ENOENT       \", \"LCN_unknown      \" };\n\n\tif (!debug_msgs)\n\t\treturn;\n\tpr_debug(\"Dumping runlist (values in hex):\\n\");\n\tif (!rl) {\n\t\tpr_debug(\"Run list not present.\\n\");\n\t\treturn;\n\t}\n\tpr_debug(\"VCN              LCN               Run length\\n\");\n\tfor (i = 0; ; i++) {\n\t\tLCN lcn = (rl + i)->lcn;\n\n\t\tif (lcn < (LCN)0) {\n\t\t\tint index = -lcn - 1;\n\n\t\t\tif (index > -LCN_ENOENT - 1)\n\t\t\t\tindex = 3;\n\t\t\tpr_debug(\"%-16Lx %s %-16Lx%s\\n\",\n\t\t\t\t\t(long long)(rl + i)->vcn, lcn_str[index],\n\t\t\t\t\t(long long)(rl + i)->length,\n\t\t\t\t\t(rl + i)->length ? \"\" :\n\t\t\t\t\t\t\" (runlist end)\");\n\t\t} else\n\t\t\tpr_debug(\"%-16Lx %-16Lx  %-16Lx%s\\n\",\n\t\t\t\t\t(long long)(rl + i)->vcn,\n\t\t\t\t\t(long long)(rl + i)->lcn,\n\t\t\t\t\t(long long)(rl + i)->length,\n\t\t\t\t\t(rl + i)->length ? \"\" :\n\t\t\t\t\t\t\" (runlist end)\");\n\t\tif (!(rl + i)->length)\n\t\t\tbreak;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ntfs_unmap_page",
          "args": [
            "page"
          ],
          "line": 1581
        },
        "resolved": true,
        "details": {
          "function_name": "ntfs_unmap_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/aops.h",
          "lines": "40-44",
          "snippet": "static inline void ntfs_unmap_page(struct page *page)\n{\n\tkunmap(page);\n\tpage_cache_release(page);\n}",
          "includes": [
            "#include \"inode.h\"",
            "#include <linux/fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"inode.h\"\n#include <linux/fs.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\nstatic inline void ntfs_unmap_page(struct page *page)\n{\n\tkunmap(page);\n\tpage_cache_release(page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ntfs_error",
          "args": [
            "vol->sb",
            "\"$UsnJrnl has lowest valid usn (0x%llx) \"\n\t\t\t\t\"which is out of bounds (0x%llx).  $UsnJrnl \"\n\t\t\t\t\"is corrupt.\"",
            "(long long)sle64_to_cpu(uh->lowest_valid_usn)",
            "i_size_read(vol->usnjrnl_j_ino)"
          ],
          "line": 1573
        },
        "resolved": true,
        "details": {
          "function_name": "__ntfs_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/debug.c",
          "lines": "86-108",
          "snippet": "void __ntfs_error(const char *function, const struct super_block *sb,\n\t\tconst char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\tint flen = 0;\n\n#ifndef DEBUG\n\tif (!printk_ratelimit())\n\t\treturn;\n#endif\n\tif (function)\n\t\tflen = strlen(function);\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tif (sb)\n\t\tpr_err(\"(device %s): %s(): %pV\\n\",\n\t\t       sb->s_id, flen ? function : \"\", &vaf);\n\telse\n\t\tpr_err(\"%s(): %pV\\n\", flen ? function : \"\", &vaf);\n\tva_end(args);\n}",
          "includes": [
            "#include \"debug.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"debug.h\"\n\nvoid __ntfs_error(const char *function, const struct super_block *sb,\n\t\tconst char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\tint flen = 0;\n\n#ifndef DEBUG\n\tif (!printk_ratelimit())\n\t\treturn;\n#endif\n\tif (function)\n\t\tflen = strlen(function);\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tif (sb)\n\t\tpr_err(\"(device %s): %s(): %pV\\n\",\n\t\t       sb->s_id, flen ? function : \"\", &vaf);\n\telse\n\t\tpr_err(\"%s(): %pV\\n\", flen ? function : \"\", &vaf);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "i_size_read",
          "args": [
            "vol->usnjrnl_j_ino"
          ],
          "line": 1577
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sle64_to_cpu",
          "args": [
            "uh->lowest_valid_usn"
          ],
          "line": 1576
        },
        "resolved": true,
        "details": {
          "function_name": "sle64_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "58-61",
          "snippet": "static inline s64 sle64_to_cpup(sle64 *x)\n{\n\treturn le64_to_cpu(*(__force le64*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s64 sle64_to_cpup(sle64 *x)\n{\n\treturn le64_to_cpu(*(__force le64*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "likely",
          "args": [
            "sle64_to_cpu(uh->lowest_valid_usn) ==\n\t\t\t\ti_size_read(vol->usnjrnl_j_ino)"
          ],
          "line": 1563
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "i_size_read",
          "args": [
            "vol->usnjrnl_j_ino"
          ],
          "line": 1564
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "sle64_to_cpu(uh->lowest_valid_usn) >=\n\t\t\ti_size_read(vol->usnjrnl_j_ino)"
          ],
          "line": 1561
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "i_size_read",
          "args": [
            "vol->usnjrnl_j_ino"
          ],
          "line": 1562
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "sle64_to_cpu(uh->allocation_delta) >\n\t\t\tsle64_to_cpu(uh->maximum_size)"
          ],
          "line": 1548
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_address",
          "args": [
            "page"
          ],
          "line": 1546
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_error",
          "args": [
            "vol->sb",
            "\"Failed to read from $UsnJrnl/$DATA/$Max \"\n\t\t\t\t\"attribute.\""
          ],
          "line": 1542
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "page"
          ],
          "line": 1541
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_map_page",
          "args": [
            "vol->usnjrnl_max_ino->i_mapping",
            "0"
          ],
          "line": 1540
        },
        "resolved": true,
        "details": {
          "function_name": "ntfs_map_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/aops.h",
          "lines": "86-99",
          "snippet": "static inline struct page *ntfs_map_page(struct address_space *mapping,\n\t\tunsigned long index)\n{\n\tstruct page *page = read_mapping_page(mapping, index, NULL);\n\n\tif (!IS_ERR(page)) {\n\t\tkmap(page);\n\t\tif (!PageError(page))\n\t\t\treturn page;\n\t\tntfs_unmap_page(page);\n\t\treturn ERR_PTR(-EIO);\n\t}\n\treturn page;\n}",
          "includes": [
            "#include \"inode.h\"",
            "#include <linux/fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"inode.h\"\n#include <linux/fs.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\nstatic inline struct page *ntfs_map_page(struct address_space *mapping,\n\t\tunsigned long index)\n{\n\tstruct page *page = read_mapping_page(mapping, index, NULL);\n\n\tif (!IS_ERR(page)) {\n\t\tkmap(page);\n\t\tif (!PageError(page))\n\t\t\treturn page;\n\t\tntfs_unmap_page(page);\n\t\treturn ERR_PTR(-EIO);\n\t}\n\treturn page;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ntfs_error",
          "args": [
            "vol->sb",
            "\"$UsnJrnl/$DATA/$J attribute is resident \"\n\t\t\t\t\"and/or not sparse.\""
          ],
          "line": 1535
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!NInoNonResident(tmp_ni) || !NInoSparse(tmp_ni)"
          ],
          "line": 1534
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NInoSparse",
          "args": [
            "tmp_ni"
          ],
          "line": 1534
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NInoNonResident",
          "args": [
            "tmp_ni"
          ],
          "line": 1534
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NTFS_I",
          "args": [
            "vol->usnjrnl_j_ino"
          ],
          "line": 1533
        },
        "resolved": true,
        "details": {
          "function_name": "NTFS_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/inode.h",
          "lines": "240-243",
          "snippet": "static inline ntfs_inode *NTFS_I(struct inode *inode)\n{\n\treturn (ntfs_inode *)list_entry(inode, big_ntfs_inode, vfs_inode);\n}",
          "includes": [
            "#include \"debug.h\"",
            "#include \"runlist.h\"",
            "#include \"types.h\"",
            "#include \"volume.h\"",
            "#include \"layout.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/mutex.h>",
            "#include <linux/mm.h>",
            "#include <linux/list.h>",
            "#include <linux/fs.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"debug.h\"\n#include \"runlist.h\"\n#include \"types.h\"\n#include \"volume.h\"\n#include \"layout.h\"\n#include <linux/seq_file.h>\n#include <linux/mutex.h>\n#include <linux/mm.h>\n#include <linux/list.h>\n#include <linux/fs.h>\n#include <linux/atomic.h>\n\nstatic inline ntfs_inode *NTFS_I(struct inode *inode)\n{\n\treturn (ntfs_inode *)list_entry(inode, big_ntfs_inode, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ntfs_error",
          "args": [
            "vol->sb",
            "\"Failed to load $UsnJrnl/$DATA/$J \"\n\t\t\t\t\"attribute.\""
          ],
          "line": 1527
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "tmp_ino"
          ],
          "line": 1526
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_attr_iget",
          "args": [
            "vol->usnjrnl_ino",
            "AT_DATA",
            "J",
            "2"
          ],
          "line": 1525
        },
        "resolved": true,
        "details": {
          "function_name": "ntfs_attr_iget",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/inode.c",
          "lines": "228-265",
          "snippet": "struct inode *ntfs_attr_iget(struct inode *base_vi, ATTR_TYPE type,\n\t\tntfschar *name, u32 name_len)\n{\n\tstruct inode *vi;\n\tint err;\n\tntfs_attr na;\n\n\t/* Make sure no one calls ntfs_attr_iget() for indices. */\n\tBUG_ON(type == AT_INDEX_ALLOCATION);\n\n\tna.mft_no = base_vi->i_ino;\n\tna.type = type;\n\tna.name = name;\n\tna.name_len = name_len;\n\n\tvi = iget5_locked(base_vi->i_sb, na.mft_no, (test_t)ntfs_test_inode,\n\t\t\t(set_t)ntfs_init_locked_inode, &na);\n\tif (unlikely(!vi))\n\t\treturn ERR_PTR(-ENOMEM);\n\n\terr = 0;\n\n\t/* If this is a freshly allocated inode, need to read it now. */\n\tif (vi->i_state & I_NEW) {\n\t\terr = ntfs_read_locked_attr_inode(base_vi, vi);\n\t\tunlock_new_inode(vi);\n\t}\n\t/*\n\t * There is no point in keeping bad attribute inodes around. This also\n\t * simplifies things in that we never need to check for bad attribute\n\t * inodes elsewhere.\n\t */\n\tif (unlikely(err)) {\n\t\tiput(vi);\n\t\tvi = ERR_PTR(err);\n\t}\n\treturn vi;\n}",
          "includes": [
            "#include \"ntfs.h\"",
            "#include \"time.h\"",
            "#include \"mft.h\"",
            "#include \"malloc.h\"",
            "#include \"lcnalloc.h\"",
            "#include \"inode.h\"",
            "#include \"debug.h\"",
            "#include \"dir.h\"",
            "#include \"bitmap.h\"",
            "#include \"attrib.h\"",
            "#include \"aops.h\"",
            "#include <linux/aio.h>",
            "#include <linux/log2.h>",
            "#include <linux/slab.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mutex.h>",
            "#include <linux/mount.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ntfs_read_locked_inode(struct inode *vi);",
            "static int ntfs_read_locked_attr_inode(struct inode *base_vi, struct inode *vi);",
            "static int ntfs_read_locked_index_inode(struct inode *base_vi,\n\t\tstruct inode *vi);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ntfs.h\"\n#include \"time.h\"\n#include \"mft.h\"\n#include \"malloc.h\"\n#include \"lcnalloc.h\"\n#include \"inode.h\"\n#include \"debug.h\"\n#include \"dir.h\"\n#include \"bitmap.h\"\n#include \"attrib.h\"\n#include \"aops.h\"\n#include <linux/aio.h>\n#include <linux/log2.h>\n#include <linux/slab.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/mutex.h>\n#include <linux/mount.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n\nstatic int ntfs_read_locked_inode(struct inode *vi);\nstatic int ntfs_read_locked_attr_inode(struct inode *base_vi, struct inode *vi);\nstatic int ntfs_read_locked_index_inode(struct inode *base_vi,\n\t\tstruct inode *vi);\n\nstruct inode *ntfs_attr_iget(struct inode *base_vi, ATTR_TYPE type,\n\t\tntfschar *name, u32 name_len)\n{\n\tstruct inode *vi;\n\tint err;\n\tntfs_attr na;\n\n\t/* Make sure no one calls ntfs_attr_iget() for indices. */\n\tBUG_ON(type == AT_INDEX_ALLOCATION);\n\n\tna.mft_no = base_vi->i_ino;\n\tna.type = type;\n\tna.name = name;\n\tna.name_len = name_len;\n\n\tvi = iget5_locked(base_vi->i_sb, na.mft_no, (test_t)ntfs_test_inode,\n\t\t\t(set_t)ntfs_init_locked_inode, &na);\n\tif (unlikely(!vi))\n\t\treturn ERR_PTR(-ENOMEM);\n\n\terr = 0;\n\n\t/* If this is a freshly allocated inode, need to read it now. */\n\tif (vi->i_state & I_NEW) {\n\t\terr = ntfs_read_locked_attr_inode(base_vi, vi);\n\t\tunlock_new_inode(vi);\n\t}\n\t/*\n\t * There is no point in keeping bad attribute inodes around. This also\n\t * simplifies things in that we never need to check for bad attribute\n\t * inodes elsewhere.\n\t */\n\tif (unlikely(err)) {\n\t\tiput(vi);\n\t\tvi = ERR_PTR(err);\n\t}\n\treturn vi;\n}"
        }
      },
      {
        "call_info": {
          "callee": "i_size_read",
          "args": [
            "tmp_ino"
          ],
          "line": 1520
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "i_size_read(tmp_ino) < sizeof(USN_HEADER)"
          ],
          "line": 1517
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "i_size_read",
          "args": [
            "tmp_ino"
          ],
          "line": 1517
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_error",
          "args": [
            "vol->sb",
            "\"Failed to load $UsnJrnl/$DATA/$Max \"\n\t\t\t\t\"attribute.\""
          ],
          "line": 1512
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "tmp_ino"
          ],
          "line": 1511
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "vol->vol_flags & VOLUME_DELETE_USN_UNDERWAY"
          ],
          "line": 1503
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_error",
          "args": [
            "vol->sb",
            "\"Failed to load $UsnJrnl.\""
          ],
          "line": 1495
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "iput",
          "args": [
            "tmp_ino"
          ],
          "line": 1494
        },
        "resolved": true,
        "details": {
          "function_name": "dentry_iput",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "308-327",
          "snippet": "static void dentry_iput(struct dentry * dentry)\n\t__releases(dentry->d_lock)\n\t__releases(dentry->d_inode->i_lock)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tif (inode) {\n\t\tdentry->d_inode = NULL;\n\t\thlist_del_init(&dentry->d_u.d_alias);\n\t\tspin_unlock(&dentry->d_lock);\n\t\tspin_unlock(&inode->i_lock);\n\t\tif (!inode->i_nlink)\n\t\t\tfsnotify_inoderemove(inode);\n\t\tif (dentry->d_op && dentry->d_op->d_iput)\n\t\t\tdentry->d_op->d_iput(dentry, inode);\n\t\telse\n\t\t\tiput(inode);\n\t} else {\n\t\tspin_unlock(&dentry->d_lock);\n\t}\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nstatic void dentry_iput(struct dentry * dentry)\n\t__releases(dentry->d_lock)\n\t__releases(dentry->d_inode->i_lock)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tif (inode) {\n\t\tdentry->d_inode = NULL;\n\t\thlist_del_init(&dentry->d_u.d_alias);\n\t\tspin_unlock(&dentry->d_lock);\n\t\tspin_unlock(&inode->i_lock);\n\t\tif (!inode->i_nlink)\n\t\t\tfsnotify_inoderemove(inode);\n\t\tif (dentry->d_op && dentry->d_op->d_iput)\n\t\t\tdentry->d_op->d_iput(dentry, inode);\n\t\telse\n\t\t\tiput(inode);\n\t} else {\n\t\tspin_unlock(&dentry->d_lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "tmp_ino"
          ],
          "line": 1493
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "IS_ERR(tmp_ino) || is_bad_inode(tmp_ino)"
          ],
          "line": 1492
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_bad_inode",
          "args": [
            "tmp_ino"
          ],
          "line": 1492
        },
        "resolved": true,
        "details": {
          "function_name": "is_bad_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/bad_inode.c",
          "lines": "195-198",
          "snippet": "int is_bad_inode(struct inode *inode)\n{\n\treturn (inode->i_op == &bad_inode_ops);\t\n}",
          "includes": [
            "#include <linux/poll.h>",
            "#include <linux/namei.h>",
            "#include <linux/time.h>",
            "#include <linux/stat.h>",
            "#include <linux/export.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct inode_operations bad_inode_ops =\n{\n\t.create\t\t= bad_inode_create,\n\t.lookup\t\t= bad_inode_lookup,\n\t.link\t\t= bad_inode_link,\n\t.unlink\t\t= bad_inode_unlink,\n\t.symlink\t= bad_inode_symlink,\n\t.mkdir\t\t= bad_inode_mkdir,\n\t.rmdir\t\t= bad_inode_rmdir,\n\t.mknod\t\t= bad_inode_mknod,\n\t.rename2\t= bad_inode_rename2,\n\t.readlink\t= bad_inode_readlink,\n\t/* follow_link must be no-op, otherwise unmounting this inode\n\t   won't work */\n\t/* put_link returns void */\n\t/* truncate returns void */\n\t.permission\t= bad_inode_permission,\n\t.getattr\t= bad_inode_getattr,\n\t.setattr\t= bad_inode_setattr,\n\t.setxattr\t= bad_inode_setxattr,\n\t.getxattr\t= bad_inode_getxattr,\n\t.listxattr\t= bad_inode_listxattr,\n\t.removexattr\t= bad_inode_removexattr,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/poll.h>\n#include <linux/namei.h>\n#include <linux/time.h>\n#include <linux/stat.h>\n#include <linux/export.h>\n#include <linux/fs.h>\n\nstatic const struct inode_operations bad_inode_ops =\n{\n\t.create\t\t= bad_inode_create,\n\t.lookup\t\t= bad_inode_lookup,\n\t.link\t\t= bad_inode_link,\n\t.unlink\t\t= bad_inode_unlink,\n\t.symlink\t= bad_inode_symlink,\n\t.mkdir\t\t= bad_inode_mkdir,\n\t.rmdir\t\t= bad_inode_rmdir,\n\t.mknod\t\t= bad_inode_mknod,\n\t.rename2\t= bad_inode_rename2,\n\t.readlink\t= bad_inode_readlink,\n\t/* follow_link must be no-op, otherwise unmounting this inode\n\t   won't work */\n\t/* put_link returns void */\n\t/* truncate returns void */\n\t.permission\t= bad_inode_permission,\n\t.getattr\t= bad_inode_getattr,\n\t.setattr\t= bad_inode_setattr,\n\t.setxattr\t= bad_inode_setxattr,\n\t.getxattr\t= bad_inode_getxattr,\n\t.listxattr\t= bad_inode_listxattr,\n\t.removexattr\t= bad_inode_removexattr,\n};\n\nint is_bad_inode(struct inode *inode)\n{\n\treturn (inode->i_op == &bad_inode_ops);\t\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "tmp_ino"
          ],
          "line": 1492
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_iget",
          "args": [
            "vol->sb",
            "MREF(mref)"
          ],
          "line": 1491
        },
        "resolved": true,
        "details": {
          "function_name": "ntfs_iget",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/inode.c",
          "lines": "171-203",
          "snippet": "struct inode *ntfs_iget(struct super_block *sb, unsigned long mft_no)\n{\n\tstruct inode *vi;\n\tint err;\n\tntfs_attr na;\n\n\tna.mft_no = mft_no;\n\tna.type = AT_UNUSED;\n\tna.name = NULL;\n\tna.name_len = 0;\n\n\tvi = iget5_locked(sb, mft_no, (test_t)ntfs_test_inode,\n\t\t\t(set_t)ntfs_init_locked_inode, &na);\n\tif (unlikely(!vi))\n\t\treturn ERR_PTR(-ENOMEM);\n\n\terr = 0;\n\n\t/* If this is a freshly allocated inode, need to read it now. */\n\tif (vi->i_state & I_NEW) {\n\t\terr = ntfs_read_locked_inode(vi);\n\t\tunlock_new_inode(vi);\n\t}\n\t/*\n\t * There is no point in keeping bad inodes around if the failure was\n\t * due to ENOMEM. We want to be able to retry again later.\n\t */\n\tif (unlikely(err == -ENOMEM)) {\n\t\tiput(vi);\n\t\tvi = ERR_PTR(err);\n\t}\n\treturn vi;\n}",
          "includes": [
            "#include \"ntfs.h\"",
            "#include \"time.h\"",
            "#include \"mft.h\"",
            "#include \"malloc.h\"",
            "#include \"lcnalloc.h\"",
            "#include \"inode.h\"",
            "#include \"debug.h\"",
            "#include \"dir.h\"",
            "#include \"bitmap.h\"",
            "#include \"attrib.h\"",
            "#include \"aops.h\"",
            "#include <linux/aio.h>",
            "#include <linux/log2.h>",
            "#include <linux/slab.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mutex.h>",
            "#include <linux/mount.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ntfs_read_locked_inode(struct inode *vi);",
            "static int ntfs_read_locked_attr_inode(struct inode *base_vi, struct inode *vi);",
            "static int ntfs_read_locked_index_inode(struct inode *base_vi,\n\t\tstruct inode *vi);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ntfs.h\"\n#include \"time.h\"\n#include \"mft.h\"\n#include \"malloc.h\"\n#include \"lcnalloc.h\"\n#include \"inode.h\"\n#include \"debug.h\"\n#include \"dir.h\"\n#include \"bitmap.h\"\n#include \"attrib.h\"\n#include \"aops.h\"\n#include <linux/aio.h>\n#include <linux/log2.h>\n#include <linux/slab.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/mutex.h>\n#include <linux/mount.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n\nstatic int ntfs_read_locked_inode(struct inode *vi);\nstatic int ntfs_read_locked_attr_inode(struct inode *base_vi, struct inode *vi);\nstatic int ntfs_read_locked_index_inode(struct inode *base_vi,\n\t\tstruct inode *vi);\n\nstruct inode *ntfs_iget(struct super_block *sb, unsigned long mft_no)\n{\n\tstruct inode *vi;\n\tint err;\n\tntfs_attr na;\n\n\tna.mft_no = mft_no;\n\tna.type = AT_UNUSED;\n\tna.name = NULL;\n\tna.name_len = 0;\n\n\tvi = iget5_locked(sb, mft_no, (test_t)ntfs_test_inode,\n\t\t\t(set_t)ntfs_init_locked_inode, &na);\n\tif (unlikely(!vi))\n\t\treturn ERR_PTR(-ENOMEM);\n\n\terr = 0;\n\n\t/* If this is a freshly allocated inode, need to read it now. */\n\tif (vi->i_state & I_NEW) {\n\t\terr = ntfs_read_locked_inode(vi);\n\t\tunlock_new_inode(vi);\n\t}\n\t/*\n\t * There is no point in keeping bad inodes around if the failure was\n\t * due to ENOMEM. We want to be able to retry again later.\n\t */\n\tif (unlikely(err == -ENOMEM)) {\n\t\tiput(vi);\n\t\tvi = ERR_PTR(err);\n\t}\n\treturn vi;\n}"
        }
      },
      {
        "call_info": {
          "callee": "MREF",
          "args": [
            "mref"
          ],
          "line": 1491
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "name"
          ],
          "line": 1489
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_error",
          "args": [
            "vol->sb",
            "\"Failed to find inode number for \"\n\t\t\t\t\"$UsnJrnl.\""
          ],
          "line": 1484
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NVolSetUsnJrnlStamped",
          "args": [
            "vol"
          ],
          "line": 1480
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MREF_ERR",
          "args": [
            "mref"
          ],
          "line": 1472
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR_MREF",
          "args": [
            "mref"
          ],
          "line": 1467
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&vol->extend_ino->i_mutex"
          ],
          "line": 1466
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_lookup_inode_by_name",
          "args": [
            "NTFS_I(vol->extend_ino)",
            "UsnJrnl",
            "8",
            "&name"
          ],
          "line": 1464
        },
        "resolved": true,
        "details": {
          "function_name": "ntfs_lookup_inode_by_name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/dir.c",
          "lines": "80-604",
          "snippet": "MFT_REF ntfs_lookup_inode_by_name(ntfs_inode *dir_ni, const ntfschar *uname,\n\t\tconst int uname_len, ntfs_name **res)\n{\n\tntfs_volume *vol = dir_ni->vol;\n\tstruct super_block *sb = vol->sb;\n\tMFT_RECORD *m;\n\tINDEX_ROOT *ir;\n\tINDEX_ENTRY *ie;\n\tINDEX_ALLOCATION *ia;\n\tu8 *index_end;\n\tu64 mref;\n\tntfs_attr_search_ctx *ctx;\n\tint err, rc;\n\tVCN vcn, old_vcn;\n\tstruct address_space *ia_mapping;\n\tstruct page *page;\n\tu8 *kaddr;\n\tntfs_name *name = NULL;\n\n\tBUG_ON(!S_ISDIR(VFS_I(dir_ni)->i_mode));\n\tBUG_ON(NInoAttr(dir_ni));\n\t/* Get hold of the mft record for the directory. */\n\tm = map_mft_record(dir_ni);\n\tif (IS_ERR(m)) {\n\t\tntfs_error(sb, \"map_mft_record() failed with error code %ld.\",\n\t\t\t\t-PTR_ERR(m));\n\t\treturn ERR_MREF(PTR_ERR(m));\n\t}\n\tctx = ntfs_attr_get_search_ctx(dir_ni, m);\n\tif (unlikely(!ctx)) {\n\t\terr = -ENOMEM;\n\t\tgoto err_out;\n\t}\n\t/* Find the index root attribute in the mft record. */\n\terr = ntfs_attr_lookup(AT_INDEX_ROOT, I30, 4, CASE_SENSITIVE, 0, NULL,\n\t\t\t0, ctx);\n\tif (unlikely(err)) {\n\t\tif (err == -ENOENT) {\n\t\t\tntfs_error(sb, \"Index root attribute missing in \"\n\t\t\t\t\t\"directory inode 0x%lx.\",\n\t\t\t\t\tdir_ni->mft_no);\n\t\t\terr = -EIO;\n\t\t}\n\t\tgoto err_out;\n\t}\n\t/* Get to the index root value (it's been verified in read_inode). */\n\tir = (INDEX_ROOT*)((u8*)ctx->attr +\n\t\t\tle16_to_cpu(ctx->attr->data.resident.value_offset));\n\tindex_end = (u8*)&ir->index + le32_to_cpu(ir->index.index_length);\n\t/* The first index entry. */\n\tie = (INDEX_ENTRY*)((u8*)&ir->index +\n\t\t\tle32_to_cpu(ir->index.entries_offset));\n\t/*\n\t * Loop until we exceed valid memory (corruption case) or until we\n\t * reach the last entry.\n\t */\n\tfor (;; ie = (INDEX_ENTRY*)((u8*)ie + le16_to_cpu(ie->length))) {\n\t\t/* Bounds checks. */\n\t\tif ((u8*)ie < (u8*)ctx->mrec || (u8*)ie +\n\t\t\t\tsizeof(INDEX_ENTRY_HEADER) > index_end ||\n\t\t\t\t(u8*)ie + le16_to_cpu(ie->key_length) >\n\t\t\t\tindex_end)\n\t\t\tgoto dir_err_out;\n\t\t/*\n\t\t * The last entry cannot contain a name. It can however contain\n\t\t * a pointer to a child node in the B+tree so we just break out.\n\t\t */\n\t\tif (ie->flags & INDEX_ENTRY_END)\n\t\t\tbreak;\n\t\t/*\n\t\t * We perform a case sensitive comparison and if that matches\n\t\t * we are done and return the mft reference of the inode (i.e.\n\t\t * the inode number together with the sequence number for\n\t\t * consistency checking). We convert it to cpu format before\n\t\t * returning.\n\t\t */\n\t\tif (ntfs_are_names_equal(uname, uname_len,\n\t\t\t\t(ntfschar*)&ie->key.file_name.file_name,\n\t\t\t\tie->key.file_name.file_name_length,\n\t\t\t\tCASE_SENSITIVE, vol->upcase, vol->upcase_len)) {\nfound_it:\n\t\t\t/*\n\t\t\t * We have a perfect match, so we don't need to care\n\t\t\t * about having matched imperfectly before, so we can\n\t\t\t * free name and set *res to NULL.\n\t\t\t * However, if the perfect match is a short file name,\n\t\t\t * we need to signal this through *res, so that\n\t\t\t * ntfs_lookup() can fix dcache aliasing issues.\n\t\t\t * As an optimization we just reuse an existing\n\t\t\t * allocation of *res.\n\t\t\t */\n\t\t\tif (ie->key.file_name.file_name_type == FILE_NAME_DOS) {\n\t\t\t\tif (!name) {\n\t\t\t\t\tname = kmalloc(sizeof(ntfs_name),\n\t\t\t\t\t\t\tGFP_NOFS);\n\t\t\t\t\tif (!name) {\n\t\t\t\t\t\terr = -ENOMEM;\n\t\t\t\t\t\tgoto err_out;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tname->mref = le64_to_cpu(\n\t\t\t\t\t\tie->data.dir.indexed_file);\n\t\t\t\tname->type = FILE_NAME_DOS;\n\t\t\t\tname->len = 0;\n\t\t\t\t*res = name;\n\t\t\t} else {\n\t\t\t\tkfree(name);\n\t\t\t\t*res = NULL;\n\t\t\t}\n\t\t\tmref = le64_to_cpu(ie->data.dir.indexed_file);\n\t\t\tntfs_attr_put_search_ctx(ctx);\n\t\t\tunmap_mft_record(dir_ni);\n\t\t\treturn mref;\n\t\t}\n\t\t/*\n\t\t * For a case insensitive mount, we also perform a case\n\t\t * insensitive comparison (provided the file name is not in the\n\t\t * POSIX namespace). If the comparison matches, and the name is\n\t\t * in the WIN32 namespace, we cache the filename in *res so\n\t\t * that the caller, ntfs_lookup(), can work on it. If the\n\t\t * comparison matches, and the name is in the DOS namespace, we\n\t\t * only cache the mft reference and the file name type (we set\n\t\t * the name length to zero for simplicity).\n\t\t */\n\t\tif (!NVolCaseSensitive(vol) &&\n\t\t\t\tie->key.file_name.file_name_type &&\n\t\t\t\tntfs_are_names_equal(uname, uname_len,\n\t\t\t\t(ntfschar*)&ie->key.file_name.file_name,\n\t\t\t\tie->key.file_name.file_name_length,\n\t\t\t\tIGNORE_CASE, vol->upcase, vol->upcase_len)) {\n\t\t\tint name_size = sizeof(ntfs_name);\n\t\t\tu8 type = ie->key.file_name.file_name_type;\n\t\t\tu8 len = ie->key.file_name.file_name_length;\n\n\t\t\t/* Only one case insensitive matching name allowed. */\n\t\t\tif (name) {\n\t\t\t\tntfs_error(sb, \"Found already allocated name \"\n\t\t\t\t\t\t\"in phase 1. Please run chkdsk \"\n\t\t\t\t\t\t\"and if that doesn't find any \"\n\t\t\t\t\t\t\"errors please report you saw \"\n\t\t\t\t\t\t\"this message to \"\n\t\t\t\t\t\t\"linux-ntfs-dev@lists.\"\n\t\t\t\t\t\t\"sourceforge.net.\");\n\t\t\t\tgoto dir_err_out;\n\t\t\t}\n\n\t\t\tif (type != FILE_NAME_DOS)\n\t\t\t\tname_size += len * sizeof(ntfschar);\n\t\t\tname = kmalloc(name_size, GFP_NOFS);\n\t\t\tif (!name) {\n\t\t\t\terr = -ENOMEM;\n\t\t\t\tgoto err_out;\n\t\t\t}\n\t\t\tname->mref = le64_to_cpu(ie->data.dir.indexed_file);\n\t\t\tname->type = type;\n\t\t\tif (type != FILE_NAME_DOS) {\n\t\t\t\tname->len = len;\n\t\t\t\tmemcpy(name->name, ie->key.file_name.file_name,\n\t\t\t\t\t\tlen * sizeof(ntfschar));\n\t\t\t} else\n\t\t\t\tname->len = 0;\n\t\t\t*res = name;\n\t\t}\n\t\t/*\n\t\t * Not a perfect match, need to do full blown collation so we\n\t\t * know which way in the B+tree we have to go.\n\t\t */\n\t\trc = ntfs_collate_names(uname, uname_len,\n\t\t\t\t(ntfschar*)&ie->key.file_name.file_name,\n\t\t\t\tie->key.file_name.file_name_length, 1,\n\t\t\t\tIGNORE_CASE, vol->upcase, vol->upcase_len);\n\t\t/*\n\t\t * If uname collates before the name of the current entry, there\n\t\t * is definitely no such name in this index but we might need to\n\t\t * descend into the B+tree so we just break out of the loop.\n\t\t */\n\t\tif (rc == -1)\n\t\t\tbreak;\n\t\t/* The names are not equal, continue the search. */\n\t\tif (rc)\n\t\t\tcontinue;\n\t\t/*\n\t\t * Names match with case insensitive comparison, now try the\n\t\t * case sensitive comparison, which is required for proper\n\t\t * collation.\n\t\t */\n\t\trc = ntfs_collate_names(uname, uname_len,\n\t\t\t\t(ntfschar*)&ie->key.file_name.file_name,\n\t\t\t\tie->key.file_name.file_name_length, 1,\n\t\t\t\tCASE_SENSITIVE, vol->upcase, vol->upcase_len);\n\t\tif (rc == -1)\n\t\t\tbreak;\n\t\tif (rc)\n\t\t\tcontinue;\n\t\t/*\n\t\t * Perfect match, this will never happen as the\n\t\t * ntfs_are_names_equal() call will have gotten a match but we\n\t\t * still treat it correctly.\n\t\t */\n\t\tgoto found_it;\n\t}\n\t/*\n\t * We have finished with this index without success. Check for the\n\t * presence of a child node and if not present return -ENOENT, unless\n\t * we have got a matching name cached in name in which case return the\n\t * mft reference associated with it.\n\t */\n\tif (!(ie->flags & INDEX_ENTRY_NODE)) {\n\t\tif (name) {\n\t\t\tntfs_attr_put_search_ctx(ctx);\n\t\t\tunmap_mft_record(dir_ni);\n\t\t\treturn name->mref;\n\t\t}\n\t\tntfs_debug(\"Entry not found.\");\n\t\terr = -ENOENT;\n\t\tgoto err_out;\n\t} /* Child node present, descend into it. */\n\t/* Consistency check: Verify that an index allocation exists. */\n\tif (!NInoIndexAllocPresent(dir_ni)) {\n\t\tntfs_error(sb, \"No index allocation attribute but index entry \"\n\t\t\t\t\"requires one. Directory inode 0x%lx is \"\n\t\t\t\t\"corrupt or driver bug.\", dir_ni->mft_no);\n\t\tgoto err_out;\n\t}\n\t/* Get the starting vcn of the index_block holding the child node. */\n\tvcn = sle64_to_cpup((sle64*)((u8*)ie + le16_to_cpu(ie->length) - 8));\n\tia_mapping = VFS_I(dir_ni)->i_mapping;\n\t/*\n\t * We are done with the index root and the mft record. Release them,\n\t * otherwise we deadlock with ntfs_map_page().\n\t */\n\tntfs_attr_put_search_ctx(ctx);\n\tunmap_mft_record(dir_ni);\n\tm = NULL;\n\tctx = NULL;\ndescend_into_child_node:\n\t/*\n\t * Convert vcn to index into the index allocation attribute in units\n\t * of PAGE_CACHE_SIZE and map the page cache page, reading it from\n\t * disk if necessary.\n\t */\n\tpage = ntfs_map_page(ia_mapping, vcn <<\n\t\t\tdir_ni->itype.index.vcn_size_bits >> PAGE_CACHE_SHIFT);\n\tif (IS_ERR(page)) {\n\t\tntfs_error(sb, \"Failed to map directory index page, error %ld.\",\n\t\t\t\t-PTR_ERR(page));\n\t\terr = PTR_ERR(page);\n\t\tgoto err_out;\n\t}\n\tlock_page(page);\n\tkaddr = (u8*)page_address(page);\nfast_descend_into_child_node:\n\t/* Get to the index allocation block. */\n\tia = (INDEX_ALLOCATION*)(kaddr + ((vcn <<\n\t\t\tdir_ni->itype.index.vcn_size_bits) & ~PAGE_CACHE_MASK));\n\t/* Bounds checks. */\n\tif ((u8*)ia < kaddr || (u8*)ia > kaddr + PAGE_CACHE_SIZE) {\n\t\tntfs_error(sb, \"Out of bounds check failed. Corrupt directory \"\n\t\t\t\t\"inode 0x%lx or driver bug.\", dir_ni->mft_no);\n\t\tgoto unm_err_out;\n\t}\n\t/* Catch multi sector transfer fixup errors. */\n\tif (unlikely(!ntfs_is_indx_record(ia->magic))) {\n\t\tntfs_error(sb, \"Directory index record with vcn 0x%llx is \"\n\t\t\t\t\"corrupt.  Corrupt inode 0x%lx.  Run chkdsk.\",\n\t\t\t\t(unsigned long long)vcn, dir_ni->mft_no);\n\t\tgoto unm_err_out;\n\t}\n\tif (sle64_to_cpu(ia->index_block_vcn) != vcn) {\n\t\tntfs_error(sb, \"Actual VCN (0x%llx) of index buffer is \"\n\t\t\t\t\"different from expected VCN (0x%llx). \"\n\t\t\t\t\"Directory inode 0x%lx is corrupt or driver \"\n\t\t\t\t\"bug.\", (unsigned long long)\n\t\t\t\tsle64_to_cpu(ia->index_block_vcn),\n\t\t\t\t(unsigned long long)vcn, dir_ni->mft_no);\n\t\tgoto unm_err_out;\n\t}\n\tif (le32_to_cpu(ia->index.allocated_size) + 0x18 !=\n\t\t\tdir_ni->itype.index.block_size) {\n\t\tntfs_error(sb, \"Index buffer (VCN 0x%llx) of directory inode \"\n\t\t\t\t\"0x%lx has a size (%u) differing from the \"\n\t\t\t\t\"directory specified size (%u). Directory \"\n\t\t\t\t\"inode is corrupt or driver bug.\",\n\t\t\t\t(unsigned long long)vcn, dir_ni->mft_no,\n\t\t\t\tle32_to_cpu(ia->index.allocated_size) + 0x18,\n\t\t\t\tdir_ni->itype.index.block_size);\n\t\tgoto unm_err_out;\n\t}\n\tindex_end = (u8*)ia + dir_ni->itype.index.block_size;\n\tif (index_end > kaddr + PAGE_CACHE_SIZE) {\n\t\tntfs_error(sb, \"Index buffer (VCN 0x%llx) of directory inode \"\n\t\t\t\t\"0x%lx crosses page boundary. Impossible! \"\n\t\t\t\t\"Cannot access! This is probably a bug in the \"\n\t\t\t\t\"driver.\", (unsigned long long)vcn,\n\t\t\t\tdir_ni->mft_no);\n\t\tgoto unm_err_out;\n\t}\n\tindex_end = (u8*)&ia->index + le32_to_cpu(ia->index.index_length);\n\tif (index_end > (u8*)ia + dir_ni->itype.index.block_size) {\n\t\tntfs_error(sb, \"Size of index buffer (VCN 0x%llx) of directory \"\n\t\t\t\t\"inode 0x%lx exceeds maximum size.\",\n\t\t\t\t(unsigned long long)vcn, dir_ni->mft_no);\n\t\tgoto unm_err_out;\n\t}\n\t/* The first index entry. */\n\tie = (INDEX_ENTRY*)((u8*)&ia->index +\n\t\t\tle32_to_cpu(ia->index.entries_offset));\n\t/*\n\t * Iterate similar to above big loop but applied to index buffer, thus\n\t * loop until we exceed valid memory (corruption case) or until we\n\t * reach the last entry.\n\t */\n\tfor (;; ie = (INDEX_ENTRY*)((u8*)ie + le16_to_cpu(ie->length))) {\n\t\t/* Bounds check. */\n\t\tif ((u8*)ie < (u8*)ia || (u8*)ie +\n\t\t\t\tsizeof(INDEX_ENTRY_HEADER) > index_end ||\n\t\t\t\t(u8*)ie + le16_to_cpu(ie->key_length) >\n\t\t\t\tindex_end) {\n\t\t\tntfs_error(sb, \"Index entry out of bounds in \"\n\t\t\t\t\t\"directory inode 0x%lx.\",\n\t\t\t\t\tdir_ni->mft_no);\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\t/*\n\t\t * The last entry cannot contain a name. It can however contain\n\t\t * a pointer to a child node in the B+tree so we just break out.\n\t\t */\n\t\tif (ie->flags & INDEX_ENTRY_END)\n\t\t\tbreak;\n\t\t/*\n\t\t * We perform a case sensitive comparison and if that matches\n\t\t * we are done and return the mft reference of the inode (i.e.\n\t\t * the inode number together with the sequence number for\n\t\t * consistency checking). We convert it to cpu format before\n\t\t * returning.\n\t\t */\n\t\tif (ntfs_are_names_equal(uname, uname_len,\n\t\t\t\t(ntfschar*)&ie->key.file_name.file_name,\n\t\t\t\tie->key.file_name.file_name_length,\n\t\t\t\tCASE_SENSITIVE, vol->upcase, vol->upcase_len)) {\nfound_it2:\n\t\t\t/*\n\t\t\t * We have a perfect match, so we don't need to care\n\t\t\t * about having matched imperfectly before, so we can\n\t\t\t * free name and set *res to NULL.\n\t\t\t * However, if the perfect match is a short file name,\n\t\t\t * we need to signal this through *res, so that\n\t\t\t * ntfs_lookup() can fix dcache aliasing issues.\n\t\t\t * As an optimization we just reuse an existing\n\t\t\t * allocation of *res.\n\t\t\t */\n\t\t\tif (ie->key.file_name.file_name_type == FILE_NAME_DOS) {\n\t\t\t\tif (!name) {\n\t\t\t\t\tname = kmalloc(sizeof(ntfs_name),\n\t\t\t\t\t\t\tGFP_NOFS);\n\t\t\t\t\tif (!name) {\n\t\t\t\t\t\terr = -ENOMEM;\n\t\t\t\t\t\tgoto unm_err_out;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tname->mref = le64_to_cpu(\n\t\t\t\t\t\tie->data.dir.indexed_file);\n\t\t\t\tname->type = FILE_NAME_DOS;\n\t\t\t\tname->len = 0;\n\t\t\t\t*res = name;\n\t\t\t} else {\n\t\t\t\tkfree(name);\n\t\t\t\t*res = NULL;\n\t\t\t}\n\t\t\tmref = le64_to_cpu(ie->data.dir.indexed_file);\n\t\t\tunlock_page(page);\n\t\t\tntfs_unmap_page(page);\n\t\t\treturn mref;\n\t\t}\n\t\t/*\n\t\t * For a case insensitive mount, we also perform a case\n\t\t * insensitive comparison (provided the file name is not in the\n\t\t * POSIX namespace). If the comparison matches, and the name is\n\t\t * in the WIN32 namespace, we cache the filename in *res so\n\t\t * that the caller, ntfs_lookup(), can work on it. If the\n\t\t * comparison matches, and the name is in the DOS namespace, we\n\t\t * only cache the mft reference and the file name type (we set\n\t\t * the name length to zero for simplicity).\n\t\t */\n\t\tif (!NVolCaseSensitive(vol) &&\n\t\t\t\tie->key.file_name.file_name_type &&\n\t\t\t\tntfs_are_names_equal(uname, uname_len,\n\t\t\t\t(ntfschar*)&ie->key.file_name.file_name,\n\t\t\t\tie->key.file_name.file_name_length,\n\t\t\t\tIGNORE_CASE, vol->upcase, vol->upcase_len)) {\n\t\t\tint name_size = sizeof(ntfs_name);\n\t\t\tu8 type = ie->key.file_name.file_name_type;\n\t\t\tu8 len = ie->key.file_name.file_name_length;\n\n\t\t\t/* Only one case insensitive matching name allowed. */\n\t\t\tif (name) {\n\t\t\t\tntfs_error(sb, \"Found already allocated name \"\n\t\t\t\t\t\t\"in phase 2. Please run chkdsk \"\n\t\t\t\t\t\t\"and if that doesn't find any \"\n\t\t\t\t\t\t\"errors please report you saw \"\n\t\t\t\t\t\t\"this message to \"\n\t\t\t\t\t\t\"linux-ntfs-dev@lists.\"\n\t\t\t\t\t\t\"sourceforge.net.\");\n\t\t\t\tunlock_page(page);\n\t\t\t\tntfs_unmap_page(page);\n\t\t\t\tgoto dir_err_out;\n\t\t\t}\n\n\t\t\tif (type != FILE_NAME_DOS)\n\t\t\t\tname_size += len * sizeof(ntfschar);\n\t\t\tname = kmalloc(name_size, GFP_NOFS);\n\t\t\tif (!name) {\n\t\t\t\terr = -ENOMEM;\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t\tname->mref = le64_to_cpu(ie->data.dir.indexed_file);\n\t\t\tname->type = type;\n\t\t\tif (type != FILE_NAME_DOS) {\n\t\t\t\tname->len = len;\n\t\t\t\tmemcpy(name->name, ie->key.file_name.file_name,\n\t\t\t\t\t\tlen * sizeof(ntfschar));\n\t\t\t} else\n\t\t\t\tname->len = 0;\n\t\t\t*res = name;\n\t\t}\n\t\t/*\n\t\t * Not a perfect match, need to do full blown collation so we\n\t\t * know which way in the B+tree we have to go.\n\t\t */\n\t\trc = ntfs_collate_names(uname, uname_len,\n\t\t\t\t(ntfschar*)&ie->key.file_name.file_name,\n\t\t\t\tie->key.file_name.file_name_length, 1,\n\t\t\t\tIGNORE_CASE, vol->upcase, vol->upcase_len);\n\t\t/*\n\t\t * If uname collates before the name of the current entry, there\n\t\t * is definitely no such name in this index but we might need to\n\t\t * descend into the B+tree so we just break out of the loop.\n\t\t */\n\t\tif (rc == -1)\n\t\t\tbreak;\n\t\t/* The names are not equal, continue the search. */\n\t\tif (rc)\n\t\t\tcontinue;\n\t\t/*\n\t\t * Names match with case insensitive comparison, now try the\n\t\t * case sensitive comparison, which is required for proper\n\t\t * collation.\n\t\t */\n\t\trc = ntfs_collate_names(uname, uname_len,\n\t\t\t\t(ntfschar*)&ie->key.file_name.file_name,\n\t\t\t\tie->key.file_name.file_name_length, 1,\n\t\t\t\tCASE_SENSITIVE, vol->upcase, vol->upcase_len);\n\t\tif (rc == -1)\n\t\t\tbreak;\n\t\tif (rc)\n\t\t\tcontinue;\n\t\t/*\n\t\t * Perfect match, this will never happen as the\n\t\t * ntfs_are_names_equal() call will have gotten a match but we\n\t\t * still treat it correctly.\n\t\t */\n\t\tgoto found_it2;\n\t}\n\t/*\n\t * We have finished with this index buffer without success. Check for\n\t * the presence of a child node.\n\t */\n\tif (ie->flags & INDEX_ENTRY_NODE) {\n\t\tif ((ia->index.flags & NODE_MASK) == LEAF_NODE) {\n\t\t\tntfs_error(sb, \"Index entry with child node found in \"\n\t\t\t\t\t\"a leaf node in directory inode 0x%lx.\",\n\t\t\t\t\tdir_ni->mft_no);\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\t/* Child node present, descend into it. */\n\t\told_vcn = vcn;\n\t\tvcn = sle64_to_cpup((sle64*)((u8*)ie +\n\t\t\t\tle16_to_cpu(ie->length) - 8));\n\t\tif (vcn >= 0) {\n\t\t\t/* If vcn is in the same page cache page as old_vcn we\n\t\t\t * recycle the mapped page. */\n\t\t\tif (old_vcn << vol->cluster_size_bits >>\n\t\t\t\t\tPAGE_CACHE_SHIFT == vcn <<\n\t\t\t\t\tvol->cluster_size_bits >>\n\t\t\t\t\tPAGE_CACHE_SHIFT)\n\t\t\t\tgoto fast_descend_into_child_node;\n\t\t\tunlock_page(page);\n\t\t\tntfs_unmap_page(page);\n\t\t\tgoto descend_into_child_node;\n\t\t}\n\t\tntfs_error(sb, \"Negative child node vcn in directory inode \"\n\t\t\t\t\"0x%lx.\", dir_ni->mft_no);\n\t\tgoto unm_err_out;\n\t}\n\t/*\n\t * No child node present, return -ENOENT, unless we have got a matching\n\t * name cached in name in which case return the mft reference\n\t * associated with it.\n\t */\n\tif (name) {\n\t\tunlock_page(page);\n\t\tntfs_unmap_page(page);\n\t\treturn name->mref;\n\t}\n\tntfs_debug(\"Entry not found.\");\n\terr = -ENOENT;\nunm_err_out:\n\tunlock_page(page);\n\tntfs_unmap_page(page);\nerr_out:\n\tif (!err)\n\t\terr = -EIO;\n\tif (ctx)\n\t\tntfs_attr_put_search_ctx(ctx);\n\tif (m)\n\t\tunmap_mft_record(dir_ni);\n\tif (name) {\n\t\tkfree(name);\n\t\t*res = NULL;\n\t}\n\treturn ERR_MREF(err);\ndir_err_out:\n\tntfs_error(sb, \"Corrupt directory.  Aborting lookup.\");\n\tgoto err_out;\n}",
          "includes": [
            "#include \"ntfs.h\"",
            "#include \"debug.h\"",
            "#include \"mft.h\"",
            "#include \"attrib.h\"",
            "#include \"aops.h\"",
            "#include \"dir.h\"",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "ntfschar I30[5] = { cpu_to_le16('$'), cpu_to_le16('I'),\n\t\tcpu_to_le16('3'),\tcpu_to_le16('0'), 0 };"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ntfs.h\"\n#include \"debug.h\"\n#include \"mft.h\"\n#include \"attrib.h\"\n#include \"aops.h\"\n#include \"dir.h\"\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n\nntfschar I30[5] = { cpu_to_le16('$'), cpu_to_le16('I'),\n\t\tcpu_to_le16('3'),\tcpu_to_le16('0'), 0 };\n\nMFT_REF ntfs_lookup_inode_by_name(ntfs_inode *dir_ni, const ntfschar *uname,\n\t\tconst int uname_len, ntfs_name **res)\n{\n\tntfs_volume *vol = dir_ni->vol;\n\tstruct super_block *sb = vol->sb;\n\tMFT_RECORD *m;\n\tINDEX_ROOT *ir;\n\tINDEX_ENTRY *ie;\n\tINDEX_ALLOCATION *ia;\n\tu8 *index_end;\n\tu64 mref;\n\tntfs_attr_search_ctx *ctx;\n\tint err, rc;\n\tVCN vcn, old_vcn;\n\tstruct address_space *ia_mapping;\n\tstruct page *page;\n\tu8 *kaddr;\n\tntfs_name *name = NULL;\n\n\tBUG_ON(!S_ISDIR(VFS_I(dir_ni)->i_mode));\n\tBUG_ON(NInoAttr(dir_ni));\n\t/* Get hold of the mft record for the directory. */\n\tm = map_mft_record(dir_ni);\n\tif (IS_ERR(m)) {\n\t\tntfs_error(sb, \"map_mft_record() failed with error code %ld.\",\n\t\t\t\t-PTR_ERR(m));\n\t\treturn ERR_MREF(PTR_ERR(m));\n\t}\n\tctx = ntfs_attr_get_search_ctx(dir_ni, m);\n\tif (unlikely(!ctx)) {\n\t\terr = -ENOMEM;\n\t\tgoto err_out;\n\t}\n\t/* Find the index root attribute in the mft record. */\n\terr = ntfs_attr_lookup(AT_INDEX_ROOT, I30, 4, CASE_SENSITIVE, 0, NULL,\n\t\t\t0, ctx);\n\tif (unlikely(err)) {\n\t\tif (err == -ENOENT) {\n\t\t\tntfs_error(sb, \"Index root attribute missing in \"\n\t\t\t\t\t\"directory inode 0x%lx.\",\n\t\t\t\t\tdir_ni->mft_no);\n\t\t\terr = -EIO;\n\t\t}\n\t\tgoto err_out;\n\t}\n\t/* Get to the index root value (it's been verified in read_inode). */\n\tir = (INDEX_ROOT*)((u8*)ctx->attr +\n\t\t\tle16_to_cpu(ctx->attr->data.resident.value_offset));\n\tindex_end = (u8*)&ir->index + le32_to_cpu(ir->index.index_length);\n\t/* The first index entry. */\n\tie = (INDEX_ENTRY*)((u8*)&ir->index +\n\t\t\tle32_to_cpu(ir->index.entries_offset));\n\t/*\n\t * Loop until we exceed valid memory (corruption case) or until we\n\t * reach the last entry.\n\t */\n\tfor (;; ie = (INDEX_ENTRY*)((u8*)ie + le16_to_cpu(ie->length))) {\n\t\t/* Bounds checks. */\n\t\tif ((u8*)ie < (u8*)ctx->mrec || (u8*)ie +\n\t\t\t\tsizeof(INDEX_ENTRY_HEADER) > index_end ||\n\t\t\t\t(u8*)ie + le16_to_cpu(ie->key_length) >\n\t\t\t\tindex_end)\n\t\t\tgoto dir_err_out;\n\t\t/*\n\t\t * The last entry cannot contain a name. It can however contain\n\t\t * a pointer to a child node in the B+tree so we just break out.\n\t\t */\n\t\tif (ie->flags & INDEX_ENTRY_END)\n\t\t\tbreak;\n\t\t/*\n\t\t * We perform a case sensitive comparison and if that matches\n\t\t * we are done and return the mft reference of the inode (i.e.\n\t\t * the inode number together with the sequence number for\n\t\t * consistency checking). We convert it to cpu format before\n\t\t * returning.\n\t\t */\n\t\tif (ntfs_are_names_equal(uname, uname_len,\n\t\t\t\t(ntfschar*)&ie->key.file_name.file_name,\n\t\t\t\tie->key.file_name.file_name_length,\n\t\t\t\tCASE_SENSITIVE, vol->upcase, vol->upcase_len)) {\nfound_it:\n\t\t\t/*\n\t\t\t * We have a perfect match, so we don't need to care\n\t\t\t * about having matched imperfectly before, so we can\n\t\t\t * free name and set *res to NULL.\n\t\t\t * However, if the perfect match is a short file name,\n\t\t\t * we need to signal this through *res, so that\n\t\t\t * ntfs_lookup() can fix dcache aliasing issues.\n\t\t\t * As an optimization we just reuse an existing\n\t\t\t * allocation of *res.\n\t\t\t */\n\t\t\tif (ie->key.file_name.file_name_type == FILE_NAME_DOS) {\n\t\t\t\tif (!name) {\n\t\t\t\t\tname = kmalloc(sizeof(ntfs_name),\n\t\t\t\t\t\t\tGFP_NOFS);\n\t\t\t\t\tif (!name) {\n\t\t\t\t\t\terr = -ENOMEM;\n\t\t\t\t\t\tgoto err_out;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tname->mref = le64_to_cpu(\n\t\t\t\t\t\tie->data.dir.indexed_file);\n\t\t\t\tname->type = FILE_NAME_DOS;\n\t\t\t\tname->len = 0;\n\t\t\t\t*res = name;\n\t\t\t} else {\n\t\t\t\tkfree(name);\n\t\t\t\t*res = NULL;\n\t\t\t}\n\t\t\tmref = le64_to_cpu(ie->data.dir.indexed_file);\n\t\t\tntfs_attr_put_search_ctx(ctx);\n\t\t\tunmap_mft_record(dir_ni);\n\t\t\treturn mref;\n\t\t}\n\t\t/*\n\t\t * For a case insensitive mount, we also perform a case\n\t\t * insensitive comparison (provided the file name is not in the\n\t\t * POSIX namespace). If the comparison matches, and the name is\n\t\t * in the WIN32 namespace, we cache the filename in *res so\n\t\t * that the caller, ntfs_lookup(), can work on it. If the\n\t\t * comparison matches, and the name is in the DOS namespace, we\n\t\t * only cache the mft reference and the file name type (we set\n\t\t * the name length to zero for simplicity).\n\t\t */\n\t\tif (!NVolCaseSensitive(vol) &&\n\t\t\t\tie->key.file_name.file_name_type &&\n\t\t\t\tntfs_are_names_equal(uname, uname_len,\n\t\t\t\t(ntfschar*)&ie->key.file_name.file_name,\n\t\t\t\tie->key.file_name.file_name_length,\n\t\t\t\tIGNORE_CASE, vol->upcase, vol->upcase_len)) {\n\t\t\tint name_size = sizeof(ntfs_name);\n\t\t\tu8 type = ie->key.file_name.file_name_type;\n\t\t\tu8 len = ie->key.file_name.file_name_length;\n\n\t\t\t/* Only one case insensitive matching name allowed. */\n\t\t\tif (name) {\n\t\t\t\tntfs_error(sb, \"Found already allocated name \"\n\t\t\t\t\t\t\"in phase 1. Please run chkdsk \"\n\t\t\t\t\t\t\"and if that doesn't find any \"\n\t\t\t\t\t\t\"errors please report you saw \"\n\t\t\t\t\t\t\"this message to \"\n\t\t\t\t\t\t\"linux-ntfs-dev@lists.\"\n\t\t\t\t\t\t\"sourceforge.net.\");\n\t\t\t\tgoto dir_err_out;\n\t\t\t}\n\n\t\t\tif (type != FILE_NAME_DOS)\n\t\t\t\tname_size += len * sizeof(ntfschar);\n\t\t\tname = kmalloc(name_size, GFP_NOFS);\n\t\t\tif (!name) {\n\t\t\t\terr = -ENOMEM;\n\t\t\t\tgoto err_out;\n\t\t\t}\n\t\t\tname->mref = le64_to_cpu(ie->data.dir.indexed_file);\n\t\t\tname->type = type;\n\t\t\tif (type != FILE_NAME_DOS) {\n\t\t\t\tname->len = len;\n\t\t\t\tmemcpy(name->name, ie->key.file_name.file_name,\n\t\t\t\t\t\tlen * sizeof(ntfschar));\n\t\t\t} else\n\t\t\t\tname->len = 0;\n\t\t\t*res = name;\n\t\t}\n\t\t/*\n\t\t * Not a perfect match, need to do full blown collation so we\n\t\t * know which way in the B+tree we have to go.\n\t\t */\n\t\trc = ntfs_collate_names(uname, uname_len,\n\t\t\t\t(ntfschar*)&ie->key.file_name.file_name,\n\t\t\t\tie->key.file_name.file_name_length, 1,\n\t\t\t\tIGNORE_CASE, vol->upcase, vol->upcase_len);\n\t\t/*\n\t\t * If uname collates before the name of the current entry, there\n\t\t * is definitely no such name in this index but we might need to\n\t\t * descend into the B+tree so we just break out of the loop.\n\t\t */\n\t\tif (rc == -1)\n\t\t\tbreak;\n\t\t/* The names are not equal, continue the search. */\n\t\tif (rc)\n\t\t\tcontinue;\n\t\t/*\n\t\t * Names match with case insensitive comparison, now try the\n\t\t * case sensitive comparison, which is required for proper\n\t\t * collation.\n\t\t */\n\t\trc = ntfs_collate_names(uname, uname_len,\n\t\t\t\t(ntfschar*)&ie->key.file_name.file_name,\n\t\t\t\tie->key.file_name.file_name_length, 1,\n\t\t\t\tCASE_SENSITIVE, vol->upcase, vol->upcase_len);\n\t\tif (rc == -1)\n\t\t\tbreak;\n\t\tif (rc)\n\t\t\tcontinue;\n\t\t/*\n\t\t * Perfect match, this will never happen as the\n\t\t * ntfs_are_names_equal() call will have gotten a match but we\n\t\t * still treat it correctly.\n\t\t */\n\t\tgoto found_it;\n\t}\n\t/*\n\t * We have finished with this index without success. Check for the\n\t * presence of a child node and if not present return -ENOENT, unless\n\t * we have got a matching name cached in name in which case return the\n\t * mft reference associated with it.\n\t */\n\tif (!(ie->flags & INDEX_ENTRY_NODE)) {\n\t\tif (name) {\n\t\t\tntfs_attr_put_search_ctx(ctx);\n\t\t\tunmap_mft_record(dir_ni);\n\t\t\treturn name->mref;\n\t\t}\n\t\tntfs_debug(\"Entry not found.\");\n\t\terr = -ENOENT;\n\t\tgoto err_out;\n\t} /* Child node present, descend into it. */\n\t/* Consistency check: Verify that an index allocation exists. */\n\tif (!NInoIndexAllocPresent(dir_ni)) {\n\t\tntfs_error(sb, \"No index allocation attribute but index entry \"\n\t\t\t\t\"requires one. Directory inode 0x%lx is \"\n\t\t\t\t\"corrupt or driver bug.\", dir_ni->mft_no);\n\t\tgoto err_out;\n\t}\n\t/* Get the starting vcn of the index_block holding the child node. */\n\tvcn = sle64_to_cpup((sle64*)((u8*)ie + le16_to_cpu(ie->length) - 8));\n\tia_mapping = VFS_I(dir_ni)->i_mapping;\n\t/*\n\t * We are done with the index root and the mft record. Release them,\n\t * otherwise we deadlock with ntfs_map_page().\n\t */\n\tntfs_attr_put_search_ctx(ctx);\n\tunmap_mft_record(dir_ni);\n\tm = NULL;\n\tctx = NULL;\ndescend_into_child_node:\n\t/*\n\t * Convert vcn to index into the index allocation attribute in units\n\t * of PAGE_CACHE_SIZE and map the page cache page, reading it from\n\t * disk if necessary.\n\t */\n\tpage = ntfs_map_page(ia_mapping, vcn <<\n\t\t\tdir_ni->itype.index.vcn_size_bits >> PAGE_CACHE_SHIFT);\n\tif (IS_ERR(page)) {\n\t\tntfs_error(sb, \"Failed to map directory index page, error %ld.\",\n\t\t\t\t-PTR_ERR(page));\n\t\terr = PTR_ERR(page);\n\t\tgoto err_out;\n\t}\n\tlock_page(page);\n\tkaddr = (u8*)page_address(page);\nfast_descend_into_child_node:\n\t/* Get to the index allocation block. */\n\tia = (INDEX_ALLOCATION*)(kaddr + ((vcn <<\n\t\t\tdir_ni->itype.index.vcn_size_bits) & ~PAGE_CACHE_MASK));\n\t/* Bounds checks. */\n\tif ((u8*)ia < kaddr || (u8*)ia > kaddr + PAGE_CACHE_SIZE) {\n\t\tntfs_error(sb, \"Out of bounds check failed. Corrupt directory \"\n\t\t\t\t\"inode 0x%lx or driver bug.\", dir_ni->mft_no);\n\t\tgoto unm_err_out;\n\t}\n\t/* Catch multi sector transfer fixup errors. */\n\tif (unlikely(!ntfs_is_indx_record(ia->magic))) {\n\t\tntfs_error(sb, \"Directory index record with vcn 0x%llx is \"\n\t\t\t\t\"corrupt.  Corrupt inode 0x%lx.  Run chkdsk.\",\n\t\t\t\t(unsigned long long)vcn, dir_ni->mft_no);\n\t\tgoto unm_err_out;\n\t}\n\tif (sle64_to_cpu(ia->index_block_vcn) != vcn) {\n\t\tntfs_error(sb, \"Actual VCN (0x%llx) of index buffer is \"\n\t\t\t\t\"different from expected VCN (0x%llx). \"\n\t\t\t\t\"Directory inode 0x%lx is corrupt or driver \"\n\t\t\t\t\"bug.\", (unsigned long long)\n\t\t\t\tsle64_to_cpu(ia->index_block_vcn),\n\t\t\t\t(unsigned long long)vcn, dir_ni->mft_no);\n\t\tgoto unm_err_out;\n\t}\n\tif (le32_to_cpu(ia->index.allocated_size) + 0x18 !=\n\t\t\tdir_ni->itype.index.block_size) {\n\t\tntfs_error(sb, \"Index buffer (VCN 0x%llx) of directory inode \"\n\t\t\t\t\"0x%lx has a size (%u) differing from the \"\n\t\t\t\t\"directory specified size (%u). Directory \"\n\t\t\t\t\"inode is corrupt or driver bug.\",\n\t\t\t\t(unsigned long long)vcn, dir_ni->mft_no,\n\t\t\t\tle32_to_cpu(ia->index.allocated_size) + 0x18,\n\t\t\t\tdir_ni->itype.index.block_size);\n\t\tgoto unm_err_out;\n\t}\n\tindex_end = (u8*)ia + dir_ni->itype.index.block_size;\n\tif (index_end > kaddr + PAGE_CACHE_SIZE) {\n\t\tntfs_error(sb, \"Index buffer (VCN 0x%llx) of directory inode \"\n\t\t\t\t\"0x%lx crosses page boundary. Impossible! \"\n\t\t\t\t\"Cannot access! This is probably a bug in the \"\n\t\t\t\t\"driver.\", (unsigned long long)vcn,\n\t\t\t\tdir_ni->mft_no);\n\t\tgoto unm_err_out;\n\t}\n\tindex_end = (u8*)&ia->index + le32_to_cpu(ia->index.index_length);\n\tif (index_end > (u8*)ia + dir_ni->itype.index.block_size) {\n\t\tntfs_error(sb, \"Size of index buffer (VCN 0x%llx) of directory \"\n\t\t\t\t\"inode 0x%lx exceeds maximum size.\",\n\t\t\t\t(unsigned long long)vcn, dir_ni->mft_no);\n\t\tgoto unm_err_out;\n\t}\n\t/* The first index entry. */\n\tie = (INDEX_ENTRY*)((u8*)&ia->index +\n\t\t\tle32_to_cpu(ia->index.entries_offset));\n\t/*\n\t * Iterate similar to above big loop but applied to index buffer, thus\n\t * loop until we exceed valid memory (corruption case) or until we\n\t * reach the last entry.\n\t */\n\tfor (;; ie = (INDEX_ENTRY*)((u8*)ie + le16_to_cpu(ie->length))) {\n\t\t/* Bounds check. */\n\t\tif ((u8*)ie < (u8*)ia || (u8*)ie +\n\t\t\t\tsizeof(INDEX_ENTRY_HEADER) > index_end ||\n\t\t\t\t(u8*)ie + le16_to_cpu(ie->key_length) >\n\t\t\t\tindex_end) {\n\t\t\tntfs_error(sb, \"Index entry out of bounds in \"\n\t\t\t\t\t\"directory inode 0x%lx.\",\n\t\t\t\t\tdir_ni->mft_no);\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\t/*\n\t\t * The last entry cannot contain a name. It can however contain\n\t\t * a pointer to a child node in the B+tree so we just break out.\n\t\t */\n\t\tif (ie->flags & INDEX_ENTRY_END)\n\t\t\tbreak;\n\t\t/*\n\t\t * We perform a case sensitive comparison and if that matches\n\t\t * we are done and return the mft reference of the inode (i.e.\n\t\t * the inode number together with the sequence number for\n\t\t * consistency checking). We convert it to cpu format before\n\t\t * returning.\n\t\t */\n\t\tif (ntfs_are_names_equal(uname, uname_len,\n\t\t\t\t(ntfschar*)&ie->key.file_name.file_name,\n\t\t\t\tie->key.file_name.file_name_length,\n\t\t\t\tCASE_SENSITIVE, vol->upcase, vol->upcase_len)) {\nfound_it2:\n\t\t\t/*\n\t\t\t * We have a perfect match, so we don't need to care\n\t\t\t * about having matched imperfectly before, so we can\n\t\t\t * free name and set *res to NULL.\n\t\t\t * However, if the perfect match is a short file name,\n\t\t\t * we need to signal this through *res, so that\n\t\t\t * ntfs_lookup() can fix dcache aliasing issues.\n\t\t\t * As an optimization we just reuse an existing\n\t\t\t * allocation of *res.\n\t\t\t */\n\t\t\tif (ie->key.file_name.file_name_type == FILE_NAME_DOS) {\n\t\t\t\tif (!name) {\n\t\t\t\t\tname = kmalloc(sizeof(ntfs_name),\n\t\t\t\t\t\t\tGFP_NOFS);\n\t\t\t\t\tif (!name) {\n\t\t\t\t\t\terr = -ENOMEM;\n\t\t\t\t\t\tgoto unm_err_out;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tname->mref = le64_to_cpu(\n\t\t\t\t\t\tie->data.dir.indexed_file);\n\t\t\t\tname->type = FILE_NAME_DOS;\n\t\t\t\tname->len = 0;\n\t\t\t\t*res = name;\n\t\t\t} else {\n\t\t\t\tkfree(name);\n\t\t\t\t*res = NULL;\n\t\t\t}\n\t\t\tmref = le64_to_cpu(ie->data.dir.indexed_file);\n\t\t\tunlock_page(page);\n\t\t\tntfs_unmap_page(page);\n\t\t\treturn mref;\n\t\t}\n\t\t/*\n\t\t * For a case insensitive mount, we also perform a case\n\t\t * insensitive comparison (provided the file name is not in the\n\t\t * POSIX namespace). If the comparison matches, and the name is\n\t\t * in the WIN32 namespace, we cache the filename in *res so\n\t\t * that the caller, ntfs_lookup(), can work on it. If the\n\t\t * comparison matches, and the name is in the DOS namespace, we\n\t\t * only cache the mft reference and the file name type (we set\n\t\t * the name length to zero for simplicity).\n\t\t */\n\t\tif (!NVolCaseSensitive(vol) &&\n\t\t\t\tie->key.file_name.file_name_type &&\n\t\t\t\tntfs_are_names_equal(uname, uname_len,\n\t\t\t\t(ntfschar*)&ie->key.file_name.file_name,\n\t\t\t\tie->key.file_name.file_name_length,\n\t\t\t\tIGNORE_CASE, vol->upcase, vol->upcase_len)) {\n\t\t\tint name_size = sizeof(ntfs_name);\n\t\t\tu8 type = ie->key.file_name.file_name_type;\n\t\t\tu8 len = ie->key.file_name.file_name_length;\n\n\t\t\t/* Only one case insensitive matching name allowed. */\n\t\t\tif (name) {\n\t\t\t\tntfs_error(sb, \"Found already allocated name \"\n\t\t\t\t\t\t\"in phase 2. Please run chkdsk \"\n\t\t\t\t\t\t\"and if that doesn't find any \"\n\t\t\t\t\t\t\"errors please report you saw \"\n\t\t\t\t\t\t\"this message to \"\n\t\t\t\t\t\t\"linux-ntfs-dev@lists.\"\n\t\t\t\t\t\t\"sourceforge.net.\");\n\t\t\t\tunlock_page(page);\n\t\t\t\tntfs_unmap_page(page);\n\t\t\t\tgoto dir_err_out;\n\t\t\t}\n\n\t\t\tif (type != FILE_NAME_DOS)\n\t\t\t\tname_size += len * sizeof(ntfschar);\n\t\t\tname = kmalloc(name_size, GFP_NOFS);\n\t\t\tif (!name) {\n\t\t\t\terr = -ENOMEM;\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t\tname->mref = le64_to_cpu(ie->data.dir.indexed_file);\n\t\t\tname->type = type;\n\t\t\tif (type != FILE_NAME_DOS) {\n\t\t\t\tname->len = len;\n\t\t\t\tmemcpy(name->name, ie->key.file_name.file_name,\n\t\t\t\t\t\tlen * sizeof(ntfschar));\n\t\t\t} else\n\t\t\t\tname->len = 0;\n\t\t\t*res = name;\n\t\t}\n\t\t/*\n\t\t * Not a perfect match, need to do full blown collation so we\n\t\t * know which way in the B+tree we have to go.\n\t\t */\n\t\trc = ntfs_collate_names(uname, uname_len,\n\t\t\t\t(ntfschar*)&ie->key.file_name.file_name,\n\t\t\t\tie->key.file_name.file_name_length, 1,\n\t\t\t\tIGNORE_CASE, vol->upcase, vol->upcase_len);\n\t\t/*\n\t\t * If uname collates before the name of the current entry, there\n\t\t * is definitely no such name in this index but we might need to\n\t\t * descend into the B+tree so we just break out of the loop.\n\t\t */\n\t\tif (rc == -1)\n\t\t\tbreak;\n\t\t/* The names are not equal, continue the search. */\n\t\tif (rc)\n\t\t\tcontinue;\n\t\t/*\n\t\t * Names match with case insensitive comparison, now try the\n\t\t * case sensitive comparison, which is required for proper\n\t\t * collation.\n\t\t */\n\t\trc = ntfs_collate_names(uname, uname_len,\n\t\t\t\t(ntfschar*)&ie->key.file_name.file_name,\n\t\t\t\tie->key.file_name.file_name_length, 1,\n\t\t\t\tCASE_SENSITIVE, vol->upcase, vol->upcase_len);\n\t\tif (rc == -1)\n\t\t\tbreak;\n\t\tif (rc)\n\t\t\tcontinue;\n\t\t/*\n\t\t * Perfect match, this will never happen as the\n\t\t * ntfs_are_names_equal() call will have gotten a match but we\n\t\t * still treat it correctly.\n\t\t */\n\t\tgoto found_it2;\n\t}\n\t/*\n\t * We have finished with this index buffer without success. Check for\n\t * the presence of a child node.\n\t */\n\tif (ie->flags & INDEX_ENTRY_NODE) {\n\t\tif ((ia->index.flags & NODE_MASK) == LEAF_NODE) {\n\t\t\tntfs_error(sb, \"Index entry with child node found in \"\n\t\t\t\t\t\"a leaf node in directory inode 0x%lx.\",\n\t\t\t\t\tdir_ni->mft_no);\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\t/* Child node present, descend into it. */\n\t\told_vcn = vcn;\n\t\tvcn = sle64_to_cpup((sle64*)((u8*)ie +\n\t\t\t\tle16_to_cpu(ie->length) - 8));\n\t\tif (vcn >= 0) {\n\t\t\t/* If vcn is in the same page cache page as old_vcn we\n\t\t\t * recycle the mapped page. */\n\t\t\tif (old_vcn << vol->cluster_size_bits >>\n\t\t\t\t\tPAGE_CACHE_SHIFT == vcn <<\n\t\t\t\t\tvol->cluster_size_bits >>\n\t\t\t\t\tPAGE_CACHE_SHIFT)\n\t\t\t\tgoto fast_descend_into_child_node;\n\t\t\tunlock_page(page);\n\t\t\tntfs_unmap_page(page);\n\t\t\tgoto descend_into_child_node;\n\t\t}\n\t\tntfs_error(sb, \"Negative child node vcn in directory inode \"\n\t\t\t\t\"0x%lx.\", dir_ni->mft_no);\n\t\tgoto unm_err_out;\n\t}\n\t/*\n\t * No child node present, return -ENOENT, unless we have got a matching\n\t * name cached in name in which case return the mft reference\n\t * associated with it.\n\t */\n\tif (name) {\n\t\tunlock_page(page);\n\t\tntfs_unmap_page(page);\n\t\treturn name->mref;\n\t}\n\tntfs_debug(\"Entry not found.\");\n\terr = -ENOENT;\nunm_err_out:\n\tunlock_page(page);\n\tntfs_unmap_page(page);\nerr_out:\n\tif (!err)\n\t\terr = -EIO;\n\tif (ctx)\n\t\tntfs_attr_put_search_ctx(ctx);\n\tif (m)\n\t\tunmap_mft_record(dir_ni);\n\tif (name) {\n\t\tkfree(name);\n\t\t*res = NULL;\n\t}\n\treturn ERR_MREF(err);\ndir_err_out:\n\tntfs_error(sb, \"Corrupt directory.  Aborting lookup.\");\n\tgoto err_out;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&vol->extend_ino->i_mutex"
          ],
          "line": 1463
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "'J'"
          ],
          "line": 1456
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "'$'"
          ],
          "line": 1455
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "'x'"
          ],
          "line": 1454
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "'a'"
          ],
          "line": 1453
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "'M'"
          ],
          "line": 1453
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "'$'"
          ],
          "line": 1452
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "'l'"
          ],
          "line": 1451
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "'n'"
          ],
          "line": 1450
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "'r'"
          ],
          "line": 1450
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "'J'"
          ],
          "line": 1449
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "'n'"
          ],
          "line": 1449
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "'s'"
          ],
          "line": 1448
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "'U'"
          ],
          "line": 1448
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "'$'"
          ],
          "line": 1447
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ntfs.h\"\n#include \"malloc.h\"\n#include \"layout.h\"\n#include \"aops.h\"\n#include \"inode.h\"\n#include \"index.h\"\n#include \"debug.h\"\n#include \"dir.h\"\n#include \"usnjrnl.h\"\n#include \"quota.h\"\n#include \"logfile.h\"\n#include \"sysctl.h\"\n#include <linux/bitmap.h>\n#include <linux/moduleparam.h>\n#include <linux/vfs.h>\n#include <linux/buffer_head.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\t/* For bdev_logical_block_size(). */\n#include <linux/spinlock.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/stddef.h>\n\nstatic bool load_and_init_usnjrnl(ntfs_volume *vol)\n{\n\tMFT_REF mref;\n\tstruct inode *tmp_ino;\n\tntfs_inode *tmp_ni;\n\tstruct page *page;\n\tntfs_name *name = NULL;\n\tUSN_HEADER *uh;\n\tstatic const ntfschar UsnJrnl[9] = { cpu_to_le16('$'),\n\t\t\tcpu_to_le16('U'), cpu_to_le16('s'),\n\t\t\tcpu_to_le16('n'), cpu_to_le16('J'),\n\t\t\tcpu_to_le16('r'), cpu_to_le16('n'),\n\t\t\tcpu_to_le16('l'), 0 };\n\tstatic ntfschar Max[5] = { cpu_to_le16('$'),\n\t\t\tcpu_to_le16('M'), cpu_to_le16('a'),\n\t\t\tcpu_to_le16('x'), 0 };\n\tstatic ntfschar J[3] = { cpu_to_le16('$'),\n\t\t\tcpu_to_le16('J'), 0 };\n\n\tntfs_debug(\"Entering.\");\n\t/*\n\t * Find the inode number for the transaction log file by looking up the\n\t * filename $UsnJrnl in the extended system files directory $Extend.\n\t */\n\tmutex_lock(&vol->extend_ino->i_mutex);\n\tmref = ntfs_lookup_inode_by_name(NTFS_I(vol->extend_ino), UsnJrnl, 8,\n\t\t\t&name);\n\tmutex_unlock(&vol->extend_ino->i_mutex);\n\tif (IS_ERR_MREF(mref)) {\n\t\t/*\n\t\t * If the file does not exist, transaction logging is disabled,\n\t\t * just return success.\n\t\t */\n\t\tif (MREF_ERR(mref) == -ENOENT) {\n\t\t\tntfs_debug(\"$UsnJrnl not present.  Volume does not \"\n\t\t\t\t\t\"have transaction logging enabled.\");\nnot_enabled:\n\t\t\t/*\n\t\t\t * No need to try to stamp the transaction log if\n\t\t\t * transaction logging is not enabled.\n\t\t\t */\n\t\t\tNVolSetUsnJrnlStamped(vol);\n\t\t\treturn true;\n\t\t}\n\t\t/* A real error occurred. */\n\t\tntfs_error(vol->sb, \"Failed to find inode number for \"\n\t\t\t\t\"$UsnJrnl.\");\n\t\treturn false;\n\t}\n\t/* We do not care for the type of match that was found. */\n\tkfree(name);\n\t/* Get the inode. */\n\ttmp_ino = ntfs_iget(vol->sb, MREF(mref));\n\tif (unlikely(IS_ERR(tmp_ino) || is_bad_inode(tmp_ino))) {\n\t\tif (!IS_ERR(tmp_ino))\n\t\t\tiput(tmp_ino);\n\t\tntfs_error(vol->sb, \"Failed to load $UsnJrnl.\");\n\t\treturn false;\n\t}\n\tvol->usnjrnl_ino = tmp_ino;\n\t/*\n\t * If the transaction log is in the process of being deleted, we can\n\t * ignore it.\n\t */\n\tif (unlikely(vol->vol_flags & VOLUME_DELETE_USN_UNDERWAY)) {\n\t\tntfs_debug(\"$UsnJrnl in the process of being disabled.  \"\n\t\t\t\t\"Volume does not have transaction logging \"\n\t\t\t\t\"enabled.\");\n\t\tgoto not_enabled;\n\t}\n\t/* Get the $DATA/$Max attribute. */\n\ttmp_ino = ntfs_attr_iget(vol->usnjrnl_ino, AT_DATA, Max, 4);\n\tif (IS_ERR(tmp_ino)) {\n\t\tntfs_error(vol->sb, \"Failed to load $UsnJrnl/$DATA/$Max \"\n\t\t\t\t\"attribute.\");\n\t\treturn false;\n\t}\n\tvol->usnjrnl_max_ino = tmp_ino;\n\tif (unlikely(i_size_read(tmp_ino) < sizeof(USN_HEADER))) {\n\t\tntfs_error(vol->sb, \"Found corrupt $UsnJrnl/$DATA/$Max \"\n\t\t\t\t\"attribute (size is 0x%llx but should be at \"\n\t\t\t\t\"least 0x%zx bytes).\", i_size_read(tmp_ino),\n\t\t\t\tsizeof(USN_HEADER));\n\t\treturn false;\n\t}\n\t/* Get the $DATA/$J attribute. */\n\ttmp_ino = ntfs_attr_iget(vol->usnjrnl_ino, AT_DATA, J, 2);\n\tif (IS_ERR(tmp_ino)) {\n\t\tntfs_error(vol->sb, \"Failed to load $UsnJrnl/$DATA/$J \"\n\t\t\t\t\"attribute.\");\n\t\treturn false;\n\t}\n\tvol->usnjrnl_j_ino = tmp_ino;\n\t/* Verify $J is non-resident and sparse. */\n\ttmp_ni = NTFS_I(vol->usnjrnl_j_ino);\n\tif (unlikely(!NInoNonResident(tmp_ni) || !NInoSparse(tmp_ni))) {\n\t\tntfs_error(vol->sb, \"$UsnJrnl/$DATA/$J attribute is resident \"\n\t\t\t\t\"and/or not sparse.\");\n\t\treturn false;\n\t}\n\t/* Read the USN_HEADER from $DATA/$Max. */\n\tpage = ntfs_map_page(vol->usnjrnl_max_ino->i_mapping, 0);\n\tif (IS_ERR(page)) {\n\t\tntfs_error(vol->sb, \"Failed to read from $UsnJrnl/$DATA/$Max \"\n\t\t\t\t\"attribute.\");\n\t\treturn false;\n\t}\n\tuh = (USN_HEADER*)page_address(page);\n\t/* Sanity check the $Max. */\n\tif (unlikely(sle64_to_cpu(uh->allocation_delta) >\n\t\t\tsle64_to_cpu(uh->maximum_size))) {\n\t\tntfs_error(vol->sb, \"Allocation delta (0x%llx) exceeds \"\n\t\t\t\t\"maximum size (0x%llx).  $UsnJrnl is corrupt.\",\n\t\t\t\t(long long)sle64_to_cpu(uh->allocation_delta),\n\t\t\t\t(long long)sle64_to_cpu(uh->maximum_size));\n\t\tntfs_unmap_page(page);\n\t\treturn false;\n\t}\n\t/*\n\t * If the transaction log has been stamped and nothing has been written\n\t * to it since, we do not need to stamp it.\n\t */\n\tif (unlikely(sle64_to_cpu(uh->lowest_valid_usn) >=\n\t\t\ti_size_read(vol->usnjrnl_j_ino))) {\n\t\tif (likely(sle64_to_cpu(uh->lowest_valid_usn) ==\n\t\t\t\ti_size_read(vol->usnjrnl_j_ino))) {\n\t\t\tntfs_unmap_page(page);\n\t\t\tntfs_debug(\"$UsnJrnl is enabled but nothing has been \"\n\t\t\t\t\t\"logged since it was last stamped.  \"\n\t\t\t\t\t\"Treating this as if the volume does \"\n\t\t\t\t\t\"not have transaction logging \"\n\t\t\t\t\t\"enabled.\");\n\t\t\tgoto not_enabled;\n\t\t}\n\t\tntfs_error(vol->sb, \"$UsnJrnl has lowest valid usn (0x%llx) \"\n\t\t\t\t\"which is out of bounds (0x%llx).  $UsnJrnl \"\n\t\t\t\t\"is corrupt.\",\n\t\t\t\t(long long)sle64_to_cpu(uh->lowest_valid_usn),\n\t\t\t\ti_size_read(vol->usnjrnl_j_ino));\n\t\tntfs_unmap_page(page);\n\t\treturn false;\n\t}\n\tntfs_unmap_page(page);\n\tntfs_debug(\"Done.\");\n\treturn true;\n}"
  },
  {
    "function_name": "load_and_init_quota",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/super.c",
    "lines": "1363-1423",
    "snippet": "static bool load_and_init_quota(ntfs_volume *vol)\n{\n\tMFT_REF mref;\n\tstruct inode *tmp_ino;\n\tntfs_name *name = NULL;\n\tstatic const ntfschar Quota[7] = { cpu_to_le16('$'),\n\t\t\tcpu_to_le16('Q'), cpu_to_le16('u'),\n\t\t\tcpu_to_le16('o'), cpu_to_le16('t'),\n\t\t\tcpu_to_le16('a'), 0 };\n\tstatic ntfschar Q[3] = { cpu_to_le16('$'),\n\t\t\tcpu_to_le16('Q'), 0 };\n\n\tntfs_debug(\"Entering.\");\n\t/*\n\t * Find the inode number for the quota file by looking up the filename\n\t * $Quota in the extended system files directory $Extend.\n\t */\n\tmutex_lock(&vol->extend_ino->i_mutex);\n\tmref = ntfs_lookup_inode_by_name(NTFS_I(vol->extend_ino), Quota, 6,\n\t\t\t&name);\n\tmutex_unlock(&vol->extend_ino->i_mutex);\n\tif (IS_ERR_MREF(mref)) {\n\t\t/*\n\t\t * If the file does not exist, quotas are disabled and have\n\t\t * never been enabled on this volume, just return success.\n\t\t */\n\t\tif (MREF_ERR(mref) == -ENOENT) {\n\t\t\tntfs_debug(\"$Quota not present.  Volume does not have \"\n\t\t\t\t\t\"quotas enabled.\");\n\t\t\t/*\n\t\t\t * No need to try to set quotas out of date if they are\n\t\t\t * not enabled.\n\t\t\t */\n\t\t\tNVolSetQuotaOutOfDate(vol);\n\t\t\treturn true;\n\t\t}\n\t\t/* A real error occurred. */\n\t\tntfs_error(vol->sb, \"Failed to find inode number for $Quota.\");\n\t\treturn false;\n\t}\n\t/* We do not care for the type of match that was found. */\n\tkfree(name);\n\t/* Get the inode. */\n\ttmp_ino = ntfs_iget(vol->sb, MREF(mref));\n\tif (IS_ERR(tmp_ino) || is_bad_inode(tmp_ino)) {\n\t\tif (!IS_ERR(tmp_ino))\n\t\t\tiput(tmp_ino);\n\t\tntfs_error(vol->sb, \"Failed to load $Quota.\");\n\t\treturn false;\n\t}\n\tvol->quota_ino = tmp_ino;\n\t/* Get the $Q index allocation attribute. */\n\ttmp_ino = ntfs_index_iget(vol->quota_ino, Q, 2);\n\tif (IS_ERR(tmp_ino)) {\n\t\tntfs_error(vol->sb, \"Failed to load $Quota/$Q index.\");\n\t\treturn false;\n\t}\n\tvol->quota_q_ino = tmp_ino;\n\tntfs_debug(\"Done.\");\n\treturn true;\n}",
    "includes": [
      "#include \"ntfs.h\"",
      "#include \"malloc.h\"",
      "#include \"layout.h\"",
      "#include \"aops.h\"",
      "#include \"inode.h\"",
      "#include \"index.h\"",
      "#include \"debug.h\"",
      "#include \"dir.h\"",
      "#include \"usnjrnl.h\"",
      "#include \"quota.h\"",
      "#include \"logfile.h\"",
      "#include \"sysctl.h\"",
      "#include <linux/bitmap.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/vfs.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/blkdev.h>\t/* For bdev_logical_block_size(). */",
      "#include <linux/spinlock.h>",
      "#include <linux/string.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/stddef.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ntfs_debug",
          "args": [
            "\"Done.\""
          ],
          "line": 1421
        },
        "resolved": true,
        "details": {
          "function_name": "ntfs_debug_dump_runlist",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/debug.c",
          "lines": "134-171",
          "snippet": "void ntfs_debug_dump_runlist(const runlist_element *rl)\n{\n\tint i;\n\tconst char *lcn_str[5] = { \"LCN_HOLE         \", \"LCN_RL_NOT_MAPPED\",\n\t\t\t\t   \"LCN_ENOENT       \", \"LCN_unknown      \" };\n\n\tif (!debug_msgs)\n\t\treturn;\n\tpr_debug(\"Dumping runlist (values in hex):\\n\");\n\tif (!rl) {\n\t\tpr_debug(\"Run list not present.\\n\");\n\t\treturn;\n\t}\n\tpr_debug(\"VCN              LCN               Run length\\n\");\n\tfor (i = 0; ; i++) {\n\t\tLCN lcn = (rl + i)->lcn;\n\n\t\tif (lcn < (LCN)0) {\n\t\t\tint index = -lcn - 1;\n\n\t\t\tif (index > -LCN_ENOENT - 1)\n\t\t\t\tindex = 3;\n\t\t\tpr_debug(\"%-16Lx %s %-16Lx%s\\n\",\n\t\t\t\t\t(long long)(rl + i)->vcn, lcn_str[index],\n\t\t\t\t\t(long long)(rl + i)->length,\n\t\t\t\t\t(rl + i)->length ? \"\" :\n\t\t\t\t\t\t\" (runlist end)\");\n\t\t} else\n\t\t\tpr_debug(\"%-16Lx %-16Lx  %-16Lx%s\\n\",\n\t\t\t\t\t(long long)(rl + i)->vcn,\n\t\t\t\t\t(long long)(rl + i)->lcn,\n\t\t\t\t\t(long long)(rl + i)->length,\n\t\t\t\t\t(rl + i)->length ? \"\" :\n\t\t\t\t\t\t\" (runlist end)\");\n\t\tif (!(rl + i)->length)\n\t\t\tbreak;\n\t}\n}",
          "includes": [
            "#include \"debug.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"debug.h\"\n\nvoid ntfs_debug_dump_runlist(const runlist_element *rl)\n{\n\tint i;\n\tconst char *lcn_str[5] = { \"LCN_HOLE         \", \"LCN_RL_NOT_MAPPED\",\n\t\t\t\t   \"LCN_ENOENT       \", \"LCN_unknown      \" };\n\n\tif (!debug_msgs)\n\t\treturn;\n\tpr_debug(\"Dumping runlist (values in hex):\\n\");\n\tif (!rl) {\n\t\tpr_debug(\"Run list not present.\\n\");\n\t\treturn;\n\t}\n\tpr_debug(\"VCN              LCN               Run length\\n\");\n\tfor (i = 0; ; i++) {\n\t\tLCN lcn = (rl + i)->lcn;\n\n\t\tif (lcn < (LCN)0) {\n\t\t\tint index = -lcn - 1;\n\n\t\t\tif (index > -LCN_ENOENT - 1)\n\t\t\t\tindex = 3;\n\t\t\tpr_debug(\"%-16Lx %s %-16Lx%s\\n\",\n\t\t\t\t\t(long long)(rl + i)->vcn, lcn_str[index],\n\t\t\t\t\t(long long)(rl + i)->length,\n\t\t\t\t\t(rl + i)->length ? \"\" :\n\t\t\t\t\t\t\" (runlist end)\");\n\t\t} else\n\t\t\tpr_debug(\"%-16Lx %-16Lx  %-16Lx%s\\n\",\n\t\t\t\t\t(long long)(rl + i)->vcn,\n\t\t\t\t\t(long long)(rl + i)->lcn,\n\t\t\t\t\t(long long)(rl + i)->length,\n\t\t\t\t\t(rl + i)->length ? \"\" :\n\t\t\t\t\t\t\" (runlist end)\");\n\t\tif (!(rl + i)->length)\n\t\t\tbreak;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ntfs_error",
          "args": [
            "vol->sb",
            "\"Failed to load $Quota/$Q index.\""
          ],
          "line": 1417
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "tmp_ino"
          ],
          "line": 1416
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_index_iget",
          "args": [
            "vol->quota_ino",
            "Q",
            "2"
          ],
          "line": 1415
        },
        "resolved": true,
        "details": {
          "function_name": "ntfs_index_iget",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/inode.c",
          "lines": "286-320",
          "snippet": "struct inode *ntfs_index_iget(struct inode *base_vi, ntfschar *name,\n\t\tu32 name_len)\n{\n\tstruct inode *vi;\n\tint err;\n\tntfs_attr na;\n\n\tna.mft_no = base_vi->i_ino;\n\tna.type = AT_INDEX_ALLOCATION;\n\tna.name = name;\n\tna.name_len = name_len;\n\n\tvi = iget5_locked(base_vi->i_sb, na.mft_no, (test_t)ntfs_test_inode,\n\t\t\t(set_t)ntfs_init_locked_inode, &na);\n\tif (unlikely(!vi))\n\t\treturn ERR_PTR(-ENOMEM);\n\n\terr = 0;\n\n\t/* If this is a freshly allocated inode, need to read it now. */\n\tif (vi->i_state & I_NEW) {\n\t\terr = ntfs_read_locked_index_inode(base_vi, vi);\n\t\tunlock_new_inode(vi);\n\t}\n\t/*\n\t * There is no point in keeping bad index inodes around.  This also\n\t * simplifies things in that we never need to check for bad index\n\t * inodes elsewhere.\n\t */\n\tif (unlikely(err)) {\n\t\tiput(vi);\n\t\tvi = ERR_PTR(err);\n\t}\n\treturn vi;\n}",
          "includes": [
            "#include \"ntfs.h\"",
            "#include \"time.h\"",
            "#include \"mft.h\"",
            "#include \"malloc.h\"",
            "#include \"lcnalloc.h\"",
            "#include \"inode.h\"",
            "#include \"debug.h\"",
            "#include \"dir.h\"",
            "#include \"bitmap.h\"",
            "#include \"attrib.h\"",
            "#include \"aops.h\"",
            "#include <linux/aio.h>",
            "#include <linux/log2.h>",
            "#include <linux/slab.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mutex.h>",
            "#include <linux/mount.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ntfs_read_locked_inode(struct inode *vi);",
            "static int ntfs_read_locked_attr_inode(struct inode *base_vi, struct inode *vi);",
            "static int ntfs_read_locked_index_inode(struct inode *base_vi,\n\t\tstruct inode *vi);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ntfs.h\"\n#include \"time.h\"\n#include \"mft.h\"\n#include \"malloc.h\"\n#include \"lcnalloc.h\"\n#include \"inode.h\"\n#include \"debug.h\"\n#include \"dir.h\"\n#include \"bitmap.h\"\n#include \"attrib.h\"\n#include \"aops.h\"\n#include <linux/aio.h>\n#include <linux/log2.h>\n#include <linux/slab.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/mutex.h>\n#include <linux/mount.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n\nstatic int ntfs_read_locked_inode(struct inode *vi);\nstatic int ntfs_read_locked_attr_inode(struct inode *base_vi, struct inode *vi);\nstatic int ntfs_read_locked_index_inode(struct inode *base_vi,\n\t\tstruct inode *vi);\n\nstruct inode *ntfs_index_iget(struct inode *base_vi, ntfschar *name,\n\t\tu32 name_len)\n{\n\tstruct inode *vi;\n\tint err;\n\tntfs_attr na;\n\n\tna.mft_no = base_vi->i_ino;\n\tna.type = AT_INDEX_ALLOCATION;\n\tna.name = name;\n\tna.name_len = name_len;\n\n\tvi = iget5_locked(base_vi->i_sb, na.mft_no, (test_t)ntfs_test_inode,\n\t\t\t(set_t)ntfs_init_locked_inode, &na);\n\tif (unlikely(!vi))\n\t\treturn ERR_PTR(-ENOMEM);\n\n\terr = 0;\n\n\t/* If this is a freshly allocated inode, need to read it now. */\n\tif (vi->i_state & I_NEW) {\n\t\terr = ntfs_read_locked_index_inode(base_vi, vi);\n\t\tunlock_new_inode(vi);\n\t}\n\t/*\n\t * There is no point in keeping bad index inodes around.  This also\n\t * simplifies things in that we never need to check for bad index\n\t * inodes elsewhere.\n\t */\n\tif (unlikely(err)) {\n\t\tiput(vi);\n\t\tvi = ERR_PTR(err);\n\t}\n\treturn vi;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ntfs_error",
          "args": [
            "vol->sb",
            "\"Failed to load $Quota.\""
          ],
          "line": 1410
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "iput",
          "args": [
            "tmp_ino"
          ],
          "line": 1409
        },
        "resolved": true,
        "details": {
          "function_name": "dentry_iput",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "308-327",
          "snippet": "static void dentry_iput(struct dentry * dentry)\n\t__releases(dentry->d_lock)\n\t__releases(dentry->d_inode->i_lock)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tif (inode) {\n\t\tdentry->d_inode = NULL;\n\t\thlist_del_init(&dentry->d_u.d_alias);\n\t\tspin_unlock(&dentry->d_lock);\n\t\tspin_unlock(&inode->i_lock);\n\t\tif (!inode->i_nlink)\n\t\t\tfsnotify_inoderemove(inode);\n\t\tif (dentry->d_op && dentry->d_op->d_iput)\n\t\t\tdentry->d_op->d_iput(dentry, inode);\n\t\telse\n\t\t\tiput(inode);\n\t} else {\n\t\tspin_unlock(&dentry->d_lock);\n\t}\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nstatic void dentry_iput(struct dentry * dentry)\n\t__releases(dentry->d_lock)\n\t__releases(dentry->d_inode->i_lock)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tif (inode) {\n\t\tdentry->d_inode = NULL;\n\t\thlist_del_init(&dentry->d_u.d_alias);\n\t\tspin_unlock(&dentry->d_lock);\n\t\tspin_unlock(&inode->i_lock);\n\t\tif (!inode->i_nlink)\n\t\t\tfsnotify_inoderemove(inode);\n\t\tif (dentry->d_op && dentry->d_op->d_iput)\n\t\t\tdentry->d_op->d_iput(dentry, inode);\n\t\telse\n\t\t\tiput(inode);\n\t} else {\n\t\tspin_unlock(&dentry->d_lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "tmp_ino"
          ],
          "line": 1408
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_bad_inode",
          "args": [
            "tmp_ino"
          ],
          "line": 1407
        },
        "resolved": true,
        "details": {
          "function_name": "is_bad_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/bad_inode.c",
          "lines": "195-198",
          "snippet": "int is_bad_inode(struct inode *inode)\n{\n\treturn (inode->i_op == &bad_inode_ops);\t\n}",
          "includes": [
            "#include <linux/poll.h>",
            "#include <linux/namei.h>",
            "#include <linux/time.h>",
            "#include <linux/stat.h>",
            "#include <linux/export.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct inode_operations bad_inode_ops =\n{\n\t.create\t\t= bad_inode_create,\n\t.lookup\t\t= bad_inode_lookup,\n\t.link\t\t= bad_inode_link,\n\t.unlink\t\t= bad_inode_unlink,\n\t.symlink\t= bad_inode_symlink,\n\t.mkdir\t\t= bad_inode_mkdir,\n\t.rmdir\t\t= bad_inode_rmdir,\n\t.mknod\t\t= bad_inode_mknod,\n\t.rename2\t= bad_inode_rename2,\n\t.readlink\t= bad_inode_readlink,\n\t/* follow_link must be no-op, otherwise unmounting this inode\n\t   won't work */\n\t/* put_link returns void */\n\t/* truncate returns void */\n\t.permission\t= bad_inode_permission,\n\t.getattr\t= bad_inode_getattr,\n\t.setattr\t= bad_inode_setattr,\n\t.setxattr\t= bad_inode_setxattr,\n\t.getxattr\t= bad_inode_getxattr,\n\t.listxattr\t= bad_inode_listxattr,\n\t.removexattr\t= bad_inode_removexattr,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/poll.h>\n#include <linux/namei.h>\n#include <linux/time.h>\n#include <linux/stat.h>\n#include <linux/export.h>\n#include <linux/fs.h>\n\nstatic const struct inode_operations bad_inode_ops =\n{\n\t.create\t\t= bad_inode_create,\n\t.lookup\t\t= bad_inode_lookup,\n\t.link\t\t= bad_inode_link,\n\t.unlink\t\t= bad_inode_unlink,\n\t.symlink\t= bad_inode_symlink,\n\t.mkdir\t\t= bad_inode_mkdir,\n\t.rmdir\t\t= bad_inode_rmdir,\n\t.mknod\t\t= bad_inode_mknod,\n\t.rename2\t= bad_inode_rename2,\n\t.readlink\t= bad_inode_readlink,\n\t/* follow_link must be no-op, otherwise unmounting this inode\n\t   won't work */\n\t/* put_link returns void */\n\t/* truncate returns void */\n\t.permission\t= bad_inode_permission,\n\t.getattr\t= bad_inode_getattr,\n\t.setattr\t= bad_inode_setattr,\n\t.setxattr\t= bad_inode_setxattr,\n\t.getxattr\t= bad_inode_getxattr,\n\t.listxattr\t= bad_inode_listxattr,\n\t.removexattr\t= bad_inode_removexattr,\n};\n\nint is_bad_inode(struct inode *inode)\n{\n\treturn (inode->i_op == &bad_inode_ops);\t\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "tmp_ino"
          ],
          "line": 1407
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_iget",
          "args": [
            "vol->sb",
            "MREF(mref)"
          ],
          "line": 1406
        },
        "resolved": true,
        "details": {
          "function_name": "ntfs_iget",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/inode.c",
          "lines": "171-203",
          "snippet": "struct inode *ntfs_iget(struct super_block *sb, unsigned long mft_no)\n{\n\tstruct inode *vi;\n\tint err;\n\tntfs_attr na;\n\n\tna.mft_no = mft_no;\n\tna.type = AT_UNUSED;\n\tna.name = NULL;\n\tna.name_len = 0;\n\n\tvi = iget5_locked(sb, mft_no, (test_t)ntfs_test_inode,\n\t\t\t(set_t)ntfs_init_locked_inode, &na);\n\tif (unlikely(!vi))\n\t\treturn ERR_PTR(-ENOMEM);\n\n\terr = 0;\n\n\t/* If this is a freshly allocated inode, need to read it now. */\n\tif (vi->i_state & I_NEW) {\n\t\terr = ntfs_read_locked_inode(vi);\n\t\tunlock_new_inode(vi);\n\t}\n\t/*\n\t * There is no point in keeping bad inodes around if the failure was\n\t * due to ENOMEM. We want to be able to retry again later.\n\t */\n\tif (unlikely(err == -ENOMEM)) {\n\t\tiput(vi);\n\t\tvi = ERR_PTR(err);\n\t}\n\treturn vi;\n}",
          "includes": [
            "#include \"ntfs.h\"",
            "#include \"time.h\"",
            "#include \"mft.h\"",
            "#include \"malloc.h\"",
            "#include \"lcnalloc.h\"",
            "#include \"inode.h\"",
            "#include \"debug.h\"",
            "#include \"dir.h\"",
            "#include \"bitmap.h\"",
            "#include \"attrib.h\"",
            "#include \"aops.h\"",
            "#include <linux/aio.h>",
            "#include <linux/log2.h>",
            "#include <linux/slab.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mutex.h>",
            "#include <linux/mount.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ntfs_read_locked_inode(struct inode *vi);",
            "static int ntfs_read_locked_attr_inode(struct inode *base_vi, struct inode *vi);",
            "static int ntfs_read_locked_index_inode(struct inode *base_vi,\n\t\tstruct inode *vi);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ntfs.h\"\n#include \"time.h\"\n#include \"mft.h\"\n#include \"malloc.h\"\n#include \"lcnalloc.h\"\n#include \"inode.h\"\n#include \"debug.h\"\n#include \"dir.h\"\n#include \"bitmap.h\"\n#include \"attrib.h\"\n#include \"aops.h\"\n#include <linux/aio.h>\n#include <linux/log2.h>\n#include <linux/slab.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/mutex.h>\n#include <linux/mount.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n\nstatic int ntfs_read_locked_inode(struct inode *vi);\nstatic int ntfs_read_locked_attr_inode(struct inode *base_vi, struct inode *vi);\nstatic int ntfs_read_locked_index_inode(struct inode *base_vi,\n\t\tstruct inode *vi);\n\nstruct inode *ntfs_iget(struct super_block *sb, unsigned long mft_no)\n{\n\tstruct inode *vi;\n\tint err;\n\tntfs_attr na;\n\n\tna.mft_no = mft_no;\n\tna.type = AT_UNUSED;\n\tna.name = NULL;\n\tna.name_len = 0;\n\n\tvi = iget5_locked(sb, mft_no, (test_t)ntfs_test_inode,\n\t\t\t(set_t)ntfs_init_locked_inode, &na);\n\tif (unlikely(!vi))\n\t\treturn ERR_PTR(-ENOMEM);\n\n\terr = 0;\n\n\t/* If this is a freshly allocated inode, need to read it now. */\n\tif (vi->i_state & I_NEW) {\n\t\terr = ntfs_read_locked_inode(vi);\n\t\tunlock_new_inode(vi);\n\t}\n\t/*\n\t * There is no point in keeping bad inodes around if the failure was\n\t * due to ENOMEM. We want to be able to retry again later.\n\t */\n\tif (unlikely(err == -ENOMEM)) {\n\t\tiput(vi);\n\t\tvi = ERR_PTR(err);\n\t}\n\treturn vi;\n}"
        }
      },
      {
        "call_info": {
          "callee": "MREF",
          "args": [
            "mref"
          ],
          "line": 1406
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "name"
          ],
          "line": 1404
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_error",
          "args": [
            "vol->sb",
            "\"Failed to find inode number for $Quota.\""
          ],
          "line": 1400
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NVolSetQuotaOutOfDate",
          "args": [
            "vol"
          ],
          "line": 1396
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MREF_ERR",
          "args": [
            "mref"
          ],
          "line": 1389
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR_MREF",
          "args": [
            "mref"
          ],
          "line": 1384
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&vol->extend_ino->i_mutex"
          ],
          "line": 1383
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_lookup_inode_by_name",
          "args": [
            "NTFS_I(vol->extend_ino)",
            "Quota",
            "6",
            "&name"
          ],
          "line": 1381
        },
        "resolved": true,
        "details": {
          "function_name": "ntfs_lookup_inode_by_name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/dir.c",
          "lines": "80-604",
          "snippet": "MFT_REF ntfs_lookup_inode_by_name(ntfs_inode *dir_ni, const ntfschar *uname,\n\t\tconst int uname_len, ntfs_name **res)\n{\n\tntfs_volume *vol = dir_ni->vol;\n\tstruct super_block *sb = vol->sb;\n\tMFT_RECORD *m;\n\tINDEX_ROOT *ir;\n\tINDEX_ENTRY *ie;\n\tINDEX_ALLOCATION *ia;\n\tu8 *index_end;\n\tu64 mref;\n\tntfs_attr_search_ctx *ctx;\n\tint err, rc;\n\tVCN vcn, old_vcn;\n\tstruct address_space *ia_mapping;\n\tstruct page *page;\n\tu8 *kaddr;\n\tntfs_name *name = NULL;\n\n\tBUG_ON(!S_ISDIR(VFS_I(dir_ni)->i_mode));\n\tBUG_ON(NInoAttr(dir_ni));\n\t/* Get hold of the mft record for the directory. */\n\tm = map_mft_record(dir_ni);\n\tif (IS_ERR(m)) {\n\t\tntfs_error(sb, \"map_mft_record() failed with error code %ld.\",\n\t\t\t\t-PTR_ERR(m));\n\t\treturn ERR_MREF(PTR_ERR(m));\n\t}\n\tctx = ntfs_attr_get_search_ctx(dir_ni, m);\n\tif (unlikely(!ctx)) {\n\t\terr = -ENOMEM;\n\t\tgoto err_out;\n\t}\n\t/* Find the index root attribute in the mft record. */\n\terr = ntfs_attr_lookup(AT_INDEX_ROOT, I30, 4, CASE_SENSITIVE, 0, NULL,\n\t\t\t0, ctx);\n\tif (unlikely(err)) {\n\t\tif (err == -ENOENT) {\n\t\t\tntfs_error(sb, \"Index root attribute missing in \"\n\t\t\t\t\t\"directory inode 0x%lx.\",\n\t\t\t\t\tdir_ni->mft_no);\n\t\t\terr = -EIO;\n\t\t}\n\t\tgoto err_out;\n\t}\n\t/* Get to the index root value (it's been verified in read_inode). */\n\tir = (INDEX_ROOT*)((u8*)ctx->attr +\n\t\t\tle16_to_cpu(ctx->attr->data.resident.value_offset));\n\tindex_end = (u8*)&ir->index + le32_to_cpu(ir->index.index_length);\n\t/* The first index entry. */\n\tie = (INDEX_ENTRY*)((u8*)&ir->index +\n\t\t\tle32_to_cpu(ir->index.entries_offset));\n\t/*\n\t * Loop until we exceed valid memory (corruption case) or until we\n\t * reach the last entry.\n\t */\n\tfor (;; ie = (INDEX_ENTRY*)((u8*)ie + le16_to_cpu(ie->length))) {\n\t\t/* Bounds checks. */\n\t\tif ((u8*)ie < (u8*)ctx->mrec || (u8*)ie +\n\t\t\t\tsizeof(INDEX_ENTRY_HEADER) > index_end ||\n\t\t\t\t(u8*)ie + le16_to_cpu(ie->key_length) >\n\t\t\t\tindex_end)\n\t\t\tgoto dir_err_out;\n\t\t/*\n\t\t * The last entry cannot contain a name. It can however contain\n\t\t * a pointer to a child node in the B+tree so we just break out.\n\t\t */\n\t\tif (ie->flags & INDEX_ENTRY_END)\n\t\t\tbreak;\n\t\t/*\n\t\t * We perform a case sensitive comparison and if that matches\n\t\t * we are done and return the mft reference of the inode (i.e.\n\t\t * the inode number together with the sequence number for\n\t\t * consistency checking). We convert it to cpu format before\n\t\t * returning.\n\t\t */\n\t\tif (ntfs_are_names_equal(uname, uname_len,\n\t\t\t\t(ntfschar*)&ie->key.file_name.file_name,\n\t\t\t\tie->key.file_name.file_name_length,\n\t\t\t\tCASE_SENSITIVE, vol->upcase, vol->upcase_len)) {\nfound_it:\n\t\t\t/*\n\t\t\t * We have a perfect match, so we don't need to care\n\t\t\t * about having matched imperfectly before, so we can\n\t\t\t * free name and set *res to NULL.\n\t\t\t * However, if the perfect match is a short file name,\n\t\t\t * we need to signal this through *res, so that\n\t\t\t * ntfs_lookup() can fix dcache aliasing issues.\n\t\t\t * As an optimization we just reuse an existing\n\t\t\t * allocation of *res.\n\t\t\t */\n\t\t\tif (ie->key.file_name.file_name_type == FILE_NAME_DOS) {\n\t\t\t\tif (!name) {\n\t\t\t\t\tname = kmalloc(sizeof(ntfs_name),\n\t\t\t\t\t\t\tGFP_NOFS);\n\t\t\t\t\tif (!name) {\n\t\t\t\t\t\terr = -ENOMEM;\n\t\t\t\t\t\tgoto err_out;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tname->mref = le64_to_cpu(\n\t\t\t\t\t\tie->data.dir.indexed_file);\n\t\t\t\tname->type = FILE_NAME_DOS;\n\t\t\t\tname->len = 0;\n\t\t\t\t*res = name;\n\t\t\t} else {\n\t\t\t\tkfree(name);\n\t\t\t\t*res = NULL;\n\t\t\t}\n\t\t\tmref = le64_to_cpu(ie->data.dir.indexed_file);\n\t\t\tntfs_attr_put_search_ctx(ctx);\n\t\t\tunmap_mft_record(dir_ni);\n\t\t\treturn mref;\n\t\t}\n\t\t/*\n\t\t * For a case insensitive mount, we also perform a case\n\t\t * insensitive comparison (provided the file name is not in the\n\t\t * POSIX namespace). If the comparison matches, and the name is\n\t\t * in the WIN32 namespace, we cache the filename in *res so\n\t\t * that the caller, ntfs_lookup(), can work on it. If the\n\t\t * comparison matches, and the name is in the DOS namespace, we\n\t\t * only cache the mft reference and the file name type (we set\n\t\t * the name length to zero for simplicity).\n\t\t */\n\t\tif (!NVolCaseSensitive(vol) &&\n\t\t\t\tie->key.file_name.file_name_type &&\n\t\t\t\tntfs_are_names_equal(uname, uname_len,\n\t\t\t\t(ntfschar*)&ie->key.file_name.file_name,\n\t\t\t\tie->key.file_name.file_name_length,\n\t\t\t\tIGNORE_CASE, vol->upcase, vol->upcase_len)) {\n\t\t\tint name_size = sizeof(ntfs_name);\n\t\t\tu8 type = ie->key.file_name.file_name_type;\n\t\t\tu8 len = ie->key.file_name.file_name_length;\n\n\t\t\t/* Only one case insensitive matching name allowed. */\n\t\t\tif (name) {\n\t\t\t\tntfs_error(sb, \"Found already allocated name \"\n\t\t\t\t\t\t\"in phase 1. Please run chkdsk \"\n\t\t\t\t\t\t\"and if that doesn't find any \"\n\t\t\t\t\t\t\"errors please report you saw \"\n\t\t\t\t\t\t\"this message to \"\n\t\t\t\t\t\t\"linux-ntfs-dev@lists.\"\n\t\t\t\t\t\t\"sourceforge.net.\");\n\t\t\t\tgoto dir_err_out;\n\t\t\t}\n\n\t\t\tif (type != FILE_NAME_DOS)\n\t\t\t\tname_size += len * sizeof(ntfschar);\n\t\t\tname = kmalloc(name_size, GFP_NOFS);\n\t\t\tif (!name) {\n\t\t\t\terr = -ENOMEM;\n\t\t\t\tgoto err_out;\n\t\t\t}\n\t\t\tname->mref = le64_to_cpu(ie->data.dir.indexed_file);\n\t\t\tname->type = type;\n\t\t\tif (type != FILE_NAME_DOS) {\n\t\t\t\tname->len = len;\n\t\t\t\tmemcpy(name->name, ie->key.file_name.file_name,\n\t\t\t\t\t\tlen * sizeof(ntfschar));\n\t\t\t} else\n\t\t\t\tname->len = 0;\n\t\t\t*res = name;\n\t\t}\n\t\t/*\n\t\t * Not a perfect match, need to do full blown collation so we\n\t\t * know which way in the B+tree we have to go.\n\t\t */\n\t\trc = ntfs_collate_names(uname, uname_len,\n\t\t\t\t(ntfschar*)&ie->key.file_name.file_name,\n\t\t\t\tie->key.file_name.file_name_length, 1,\n\t\t\t\tIGNORE_CASE, vol->upcase, vol->upcase_len);\n\t\t/*\n\t\t * If uname collates before the name of the current entry, there\n\t\t * is definitely no such name in this index but we might need to\n\t\t * descend into the B+tree so we just break out of the loop.\n\t\t */\n\t\tif (rc == -1)\n\t\t\tbreak;\n\t\t/* The names are not equal, continue the search. */\n\t\tif (rc)\n\t\t\tcontinue;\n\t\t/*\n\t\t * Names match with case insensitive comparison, now try the\n\t\t * case sensitive comparison, which is required for proper\n\t\t * collation.\n\t\t */\n\t\trc = ntfs_collate_names(uname, uname_len,\n\t\t\t\t(ntfschar*)&ie->key.file_name.file_name,\n\t\t\t\tie->key.file_name.file_name_length, 1,\n\t\t\t\tCASE_SENSITIVE, vol->upcase, vol->upcase_len);\n\t\tif (rc == -1)\n\t\t\tbreak;\n\t\tif (rc)\n\t\t\tcontinue;\n\t\t/*\n\t\t * Perfect match, this will never happen as the\n\t\t * ntfs_are_names_equal() call will have gotten a match but we\n\t\t * still treat it correctly.\n\t\t */\n\t\tgoto found_it;\n\t}\n\t/*\n\t * We have finished with this index without success. Check for the\n\t * presence of a child node and if not present return -ENOENT, unless\n\t * we have got a matching name cached in name in which case return the\n\t * mft reference associated with it.\n\t */\n\tif (!(ie->flags & INDEX_ENTRY_NODE)) {\n\t\tif (name) {\n\t\t\tntfs_attr_put_search_ctx(ctx);\n\t\t\tunmap_mft_record(dir_ni);\n\t\t\treturn name->mref;\n\t\t}\n\t\tntfs_debug(\"Entry not found.\");\n\t\terr = -ENOENT;\n\t\tgoto err_out;\n\t} /* Child node present, descend into it. */\n\t/* Consistency check: Verify that an index allocation exists. */\n\tif (!NInoIndexAllocPresent(dir_ni)) {\n\t\tntfs_error(sb, \"No index allocation attribute but index entry \"\n\t\t\t\t\"requires one. Directory inode 0x%lx is \"\n\t\t\t\t\"corrupt or driver bug.\", dir_ni->mft_no);\n\t\tgoto err_out;\n\t}\n\t/* Get the starting vcn of the index_block holding the child node. */\n\tvcn = sle64_to_cpup((sle64*)((u8*)ie + le16_to_cpu(ie->length) - 8));\n\tia_mapping = VFS_I(dir_ni)->i_mapping;\n\t/*\n\t * We are done with the index root and the mft record. Release them,\n\t * otherwise we deadlock with ntfs_map_page().\n\t */\n\tntfs_attr_put_search_ctx(ctx);\n\tunmap_mft_record(dir_ni);\n\tm = NULL;\n\tctx = NULL;\ndescend_into_child_node:\n\t/*\n\t * Convert vcn to index into the index allocation attribute in units\n\t * of PAGE_CACHE_SIZE and map the page cache page, reading it from\n\t * disk if necessary.\n\t */\n\tpage = ntfs_map_page(ia_mapping, vcn <<\n\t\t\tdir_ni->itype.index.vcn_size_bits >> PAGE_CACHE_SHIFT);\n\tif (IS_ERR(page)) {\n\t\tntfs_error(sb, \"Failed to map directory index page, error %ld.\",\n\t\t\t\t-PTR_ERR(page));\n\t\terr = PTR_ERR(page);\n\t\tgoto err_out;\n\t}\n\tlock_page(page);\n\tkaddr = (u8*)page_address(page);\nfast_descend_into_child_node:\n\t/* Get to the index allocation block. */\n\tia = (INDEX_ALLOCATION*)(kaddr + ((vcn <<\n\t\t\tdir_ni->itype.index.vcn_size_bits) & ~PAGE_CACHE_MASK));\n\t/* Bounds checks. */\n\tif ((u8*)ia < kaddr || (u8*)ia > kaddr + PAGE_CACHE_SIZE) {\n\t\tntfs_error(sb, \"Out of bounds check failed. Corrupt directory \"\n\t\t\t\t\"inode 0x%lx or driver bug.\", dir_ni->mft_no);\n\t\tgoto unm_err_out;\n\t}\n\t/* Catch multi sector transfer fixup errors. */\n\tif (unlikely(!ntfs_is_indx_record(ia->magic))) {\n\t\tntfs_error(sb, \"Directory index record with vcn 0x%llx is \"\n\t\t\t\t\"corrupt.  Corrupt inode 0x%lx.  Run chkdsk.\",\n\t\t\t\t(unsigned long long)vcn, dir_ni->mft_no);\n\t\tgoto unm_err_out;\n\t}\n\tif (sle64_to_cpu(ia->index_block_vcn) != vcn) {\n\t\tntfs_error(sb, \"Actual VCN (0x%llx) of index buffer is \"\n\t\t\t\t\"different from expected VCN (0x%llx). \"\n\t\t\t\t\"Directory inode 0x%lx is corrupt or driver \"\n\t\t\t\t\"bug.\", (unsigned long long)\n\t\t\t\tsle64_to_cpu(ia->index_block_vcn),\n\t\t\t\t(unsigned long long)vcn, dir_ni->mft_no);\n\t\tgoto unm_err_out;\n\t}\n\tif (le32_to_cpu(ia->index.allocated_size) + 0x18 !=\n\t\t\tdir_ni->itype.index.block_size) {\n\t\tntfs_error(sb, \"Index buffer (VCN 0x%llx) of directory inode \"\n\t\t\t\t\"0x%lx has a size (%u) differing from the \"\n\t\t\t\t\"directory specified size (%u). Directory \"\n\t\t\t\t\"inode is corrupt or driver bug.\",\n\t\t\t\t(unsigned long long)vcn, dir_ni->mft_no,\n\t\t\t\tle32_to_cpu(ia->index.allocated_size) + 0x18,\n\t\t\t\tdir_ni->itype.index.block_size);\n\t\tgoto unm_err_out;\n\t}\n\tindex_end = (u8*)ia + dir_ni->itype.index.block_size;\n\tif (index_end > kaddr + PAGE_CACHE_SIZE) {\n\t\tntfs_error(sb, \"Index buffer (VCN 0x%llx) of directory inode \"\n\t\t\t\t\"0x%lx crosses page boundary. Impossible! \"\n\t\t\t\t\"Cannot access! This is probably a bug in the \"\n\t\t\t\t\"driver.\", (unsigned long long)vcn,\n\t\t\t\tdir_ni->mft_no);\n\t\tgoto unm_err_out;\n\t}\n\tindex_end = (u8*)&ia->index + le32_to_cpu(ia->index.index_length);\n\tif (index_end > (u8*)ia + dir_ni->itype.index.block_size) {\n\t\tntfs_error(sb, \"Size of index buffer (VCN 0x%llx) of directory \"\n\t\t\t\t\"inode 0x%lx exceeds maximum size.\",\n\t\t\t\t(unsigned long long)vcn, dir_ni->mft_no);\n\t\tgoto unm_err_out;\n\t}\n\t/* The first index entry. */\n\tie = (INDEX_ENTRY*)((u8*)&ia->index +\n\t\t\tle32_to_cpu(ia->index.entries_offset));\n\t/*\n\t * Iterate similar to above big loop but applied to index buffer, thus\n\t * loop until we exceed valid memory (corruption case) or until we\n\t * reach the last entry.\n\t */\n\tfor (;; ie = (INDEX_ENTRY*)((u8*)ie + le16_to_cpu(ie->length))) {\n\t\t/* Bounds check. */\n\t\tif ((u8*)ie < (u8*)ia || (u8*)ie +\n\t\t\t\tsizeof(INDEX_ENTRY_HEADER) > index_end ||\n\t\t\t\t(u8*)ie + le16_to_cpu(ie->key_length) >\n\t\t\t\tindex_end) {\n\t\t\tntfs_error(sb, \"Index entry out of bounds in \"\n\t\t\t\t\t\"directory inode 0x%lx.\",\n\t\t\t\t\tdir_ni->mft_no);\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\t/*\n\t\t * The last entry cannot contain a name. It can however contain\n\t\t * a pointer to a child node in the B+tree so we just break out.\n\t\t */\n\t\tif (ie->flags & INDEX_ENTRY_END)\n\t\t\tbreak;\n\t\t/*\n\t\t * We perform a case sensitive comparison and if that matches\n\t\t * we are done and return the mft reference of the inode (i.e.\n\t\t * the inode number together with the sequence number for\n\t\t * consistency checking). We convert it to cpu format before\n\t\t * returning.\n\t\t */\n\t\tif (ntfs_are_names_equal(uname, uname_len,\n\t\t\t\t(ntfschar*)&ie->key.file_name.file_name,\n\t\t\t\tie->key.file_name.file_name_length,\n\t\t\t\tCASE_SENSITIVE, vol->upcase, vol->upcase_len)) {\nfound_it2:\n\t\t\t/*\n\t\t\t * We have a perfect match, so we don't need to care\n\t\t\t * about having matched imperfectly before, so we can\n\t\t\t * free name and set *res to NULL.\n\t\t\t * However, if the perfect match is a short file name,\n\t\t\t * we need to signal this through *res, so that\n\t\t\t * ntfs_lookup() can fix dcache aliasing issues.\n\t\t\t * As an optimization we just reuse an existing\n\t\t\t * allocation of *res.\n\t\t\t */\n\t\t\tif (ie->key.file_name.file_name_type == FILE_NAME_DOS) {\n\t\t\t\tif (!name) {\n\t\t\t\t\tname = kmalloc(sizeof(ntfs_name),\n\t\t\t\t\t\t\tGFP_NOFS);\n\t\t\t\t\tif (!name) {\n\t\t\t\t\t\terr = -ENOMEM;\n\t\t\t\t\t\tgoto unm_err_out;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tname->mref = le64_to_cpu(\n\t\t\t\t\t\tie->data.dir.indexed_file);\n\t\t\t\tname->type = FILE_NAME_DOS;\n\t\t\t\tname->len = 0;\n\t\t\t\t*res = name;\n\t\t\t} else {\n\t\t\t\tkfree(name);\n\t\t\t\t*res = NULL;\n\t\t\t}\n\t\t\tmref = le64_to_cpu(ie->data.dir.indexed_file);\n\t\t\tunlock_page(page);\n\t\t\tntfs_unmap_page(page);\n\t\t\treturn mref;\n\t\t}\n\t\t/*\n\t\t * For a case insensitive mount, we also perform a case\n\t\t * insensitive comparison (provided the file name is not in the\n\t\t * POSIX namespace). If the comparison matches, and the name is\n\t\t * in the WIN32 namespace, we cache the filename in *res so\n\t\t * that the caller, ntfs_lookup(), can work on it. If the\n\t\t * comparison matches, and the name is in the DOS namespace, we\n\t\t * only cache the mft reference and the file name type (we set\n\t\t * the name length to zero for simplicity).\n\t\t */\n\t\tif (!NVolCaseSensitive(vol) &&\n\t\t\t\tie->key.file_name.file_name_type &&\n\t\t\t\tntfs_are_names_equal(uname, uname_len,\n\t\t\t\t(ntfschar*)&ie->key.file_name.file_name,\n\t\t\t\tie->key.file_name.file_name_length,\n\t\t\t\tIGNORE_CASE, vol->upcase, vol->upcase_len)) {\n\t\t\tint name_size = sizeof(ntfs_name);\n\t\t\tu8 type = ie->key.file_name.file_name_type;\n\t\t\tu8 len = ie->key.file_name.file_name_length;\n\n\t\t\t/* Only one case insensitive matching name allowed. */\n\t\t\tif (name) {\n\t\t\t\tntfs_error(sb, \"Found already allocated name \"\n\t\t\t\t\t\t\"in phase 2. Please run chkdsk \"\n\t\t\t\t\t\t\"and if that doesn't find any \"\n\t\t\t\t\t\t\"errors please report you saw \"\n\t\t\t\t\t\t\"this message to \"\n\t\t\t\t\t\t\"linux-ntfs-dev@lists.\"\n\t\t\t\t\t\t\"sourceforge.net.\");\n\t\t\t\tunlock_page(page);\n\t\t\t\tntfs_unmap_page(page);\n\t\t\t\tgoto dir_err_out;\n\t\t\t}\n\n\t\t\tif (type != FILE_NAME_DOS)\n\t\t\t\tname_size += len * sizeof(ntfschar);\n\t\t\tname = kmalloc(name_size, GFP_NOFS);\n\t\t\tif (!name) {\n\t\t\t\terr = -ENOMEM;\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t\tname->mref = le64_to_cpu(ie->data.dir.indexed_file);\n\t\t\tname->type = type;\n\t\t\tif (type != FILE_NAME_DOS) {\n\t\t\t\tname->len = len;\n\t\t\t\tmemcpy(name->name, ie->key.file_name.file_name,\n\t\t\t\t\t\tlen * sizeof(ntfschar));\n\t\t\t} else\n\t\t\t\tname->len = 0;\n\t\t\t*res = name;\n\t\t}\n\t\t/*\n\t\t * Not a perfect match, need to do full blown collation so we\n\t\t * know which way in the B+tree we have to go.\n\t\t */\n\t\trc = ntfs_collate_names(uname, uname_len,\n\t\t\t\t(ntfschar*)&ie->key.file_name.file_name,\n\t\t\t\tie->key.file_name.file_name_length, 1,\n\t\t\t\tIGNORE_CASE, vol->upcase, vol->upcase_len);\n\t\t/*\n\t\t * If uname collates before the name of the current entry, there\n\t\t * is definitely no such name in this index but we might need to\n\t\t * descend into the B+tree so we just break out of the loop.\n\t\t */\n\t\tif (rc == -1)\n\t\t\tbreak;\n\t\t/* The names are not equal, continue the search. */\n\t\tif (rc)\n\t\t\tcontinue;\n\t\t/*\n\t\t * Names match with case insensitive comparison, now try the\n\t\t * case sensitive comparison, which is required for proper\n\t\t * collation.\n\t\t */\n\t\trc = ntfs_collate_names(uname, uname_len,\n\t\t\t\t(ntfschar*)&ie->key.file_name.file_name,\n\t\t\t\tie->key.file_name.file_name_length, 1,\n\t\t\t\tCASE_SENSITIVE, vol->upcase, vol->upcase_len);\n\t\tif (rc == -1)\n\t\t\tbreak;\n\t\tif (rc)\n\t\t\tcontinue;\n\t\t/*\n\t\t * Perfect match, this will never happen as the\n\t\t * ntfs_are_names_equal() call will have gotten a match but we\n\t\t * still treat it correctly.\n\t\t */\n\t\tgoto found_it2;\n\t}\n\t/*\n\t * We have finished with this index buffer without success. Check for\n\t * the presence of a child node.\n\t */\n\tif (ie->flags & INDEX_ENTRY_NODE) {\n\t\tif ((ia->index.flags & NODE_MASK) == LEAF_NODE) {\n\t\t\tntfs_error(sb, \"Index entry with child node found in \"\n\t\t\t\t\t\"a leaf node in directory inode 0x%lx.\",\n\t\t\t\t\tdir_ni->mft_no);\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\t/* Child node present, descend into it. */\n\t\told_vcn = vcn;\n\t\tvcn = sle64_to_cpup((sle64*)((u8*)ie +\n\t\t\t\tle16_to_cpu(ie->length) - 8));\n\t\tif (vcn >= 0) {\n\t\t\t/* If vcn is in the same page cache page as old_vcn we\n\t\t\t * recycle the mapped page. */\n\t\t\tif (old_vcn << vol->cluster_size_bits >>\n\t\t\t\t\tPAGE_CACHE_SHIFT == vcn <<\n\t\t\t\t\tvol->cluster_size_bits >>\n\t\t\t\t\tPAGE_CACHE_SHIFT)\n\t\t\t\tgoto fast_descend_into_child_node;\n\t\t\tunlock_page(page);\n\t\t\tntfs_unmap_page(page);\n\t\t\tgoto descend_into_child_node;\n\t\t}\n\t\tntfs_error(sb, \"Negative child node vcn in directory inode \"\n\t\t\t\t\"0x%lx.\", dir_ni->mft_no);\n\t\tgoto unm_err_out;\n\t}\n\t/*\n\t * No child node present, return -ENOENT, unless we have got a matching\n\t * name cached in name in which case return the mft reference\n\t * associated with it.\n\t */\n\tif (name) {\n\t\tunlock_page(page);\n\t\tntfs_unmap_page(page);\n\t\treturn name->mref;\n\t}\n\tntfs_debug(\"Entry not found.\");\n\terr = -ENOENT;\nunm_err_out:\n\tunlock_page(page);\n\tntfs_unmap_page(page);\nerr_out:\n\tif (!err)\n\t\terr = -EIO;\n\tif (ctx)\n\t\tntfs_attr_put_search_ctx(ctx);\n\tif (m)\n\t\tunmap_mft_record(dir_ni);\n\tif (name) {\n\t\tkfree(name);\n\t\t*res = NULL;\n\t}\n\treturn ERR_MREF(err);\ndir_err_out:\n\tntfs_error(sb, \"Corrupt directory.  Aborting lookup.\");\n\tgoto err_out;\n}",
          "includes": [
            "#include \"ntfs.h\"",
            "#include \"debug.h\"",
            "#include \"mft.h\"",
            "#include \"attrib.h\"",
            "#include \"aops.h\"",
            "#include \"dir.h\"",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "ntfschar I30[5] = { cpu_to_le16('$'), cpu_to_le16('I'),\n\t\tcpu_to_le16('3'),\tcpu_to_le16('0'), 0 };"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ntfs.h\"\n#include \"debug.h\"\n#include \"mft.h\"\n#include \"attrib.h\"\n#include \"aops.h\"\n#include \"dir.h\"\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n\nntfschar I30[5] = { cpu_to_le16('$'), cpu_to_le16('I'),\n\t\tcpu_to_le16('3'),\tcpu_to_le16('0'), 0 };\n\nMFT_REF ntfs_lookup_inode_by_name(ntfs_inode *dir_ni, const ntfschar *uname,\n\t\tconst int uname_len, ntfs_name **res)\n{\n\tntfs_volume *vol = dir_ni->vol;\n\tstruct super_block *sb = vol->sb;\n\tMFT_RECORD *m;\n\tINDEX_ROOT *ir;\n\tINDEX_ENTRY *ie;\n\tINDEX_ALLOCATION *ia;\n\tu8 *index_end;\n\tu64 mref;\n\tntfs_attr_search_ctx *ctx;\n\tint err, rc;\n\tVCN vcn, old_vcn;\n\tstruct address_space *ia_mapping;\n\tstruct page *page;\n\tu8 *kaddr;\n\tntfs_name *name = NULL;\n\n\tBUG_ON(!S_ISDIR(VFS_I(dir_ni)->i_mode));\n\tBUG_ON(NInoAttr(dir_ni));\n\t/* Get hold of the mft record for the directory. */\n\tm = map_mft_record(dir_ni);\n\tif (IS_ERR(m)) {\n\t\tntfs_error(sb, \"map_mft_record() failed with error code %ld.\",\n\t\t\t\t-PTR_ERR(m));\n\t\treturn ERR_MREF(PTR_ERR(m));\n\t}\n\tctx = ntfs_attr_get_search_ctx(dir_ni, m);\n\tif (unlikely(!ctx)) {\n\t\terr = -ENOMEM;\n\t\tgoto err_out;\n\t}\n\t/* Find the index root attribute in the mft record. */\n\terr = ntfs_attr_lookup(AT_INDEX_ROOT, I30, 4, CASE_SENSITIVE, 0, NULL,\n\t\t\t0, ctx);\n\tif (unlikely(err)) {\n\t\tif (err == -ENOENT) {\n\t\t\tntfs_error(sb, \"Index root attribute missing in \"\n\t\t\t\t\t\"directory inode 0x%lx.\",\n\t\t\t\t\tdir_ni->mft_no);\n\t\t\terr = -EIO;\n\t\t}\n\t\tgoto err_out;\n\t}\n\t/* Get to the index root value (it's been verified in read_inode). */\n\tir = (INDEX_ROOT*)((u8*)ctx->attr +\n\t\t\tle16_to_cpu(ctx->attr->data.resident.value_offset));\n\tindex_end = (u8*)&ir->index + le32_to_cpu(ir->index.index_length);\n\t/* The first index entry. */\n\tie = (INDEX_ENTRY*)((u8*)&ir->index +\n\t\t\tle32_to_cpu(ir->index.entries_offset));\n\t/*\n\t * Loop until we exceed valid memory (corruption case) or until we\n\t * reach the last entry.\n\t */\n\tfor (;; ie = (INDEX_ENTRY*)((u8*)ie + le16_to_cpu(ie->length))) {\n\t\t/* Bounds checks. */\n\t\tif ((u8*)ie < (u8*)ctx->mrec || (u8*)ie +\n\t\t\t\tsizeof(INDEX_ENTRY_HEADER) > index_end ||\n\t\t\t\t(u8*)ie + le16_to_cpu(ie->key_length) >\n\t\t\t\tindex_end)\n\t\t\tgoto dir_err_out;\n\t\t/*\n\t\t * The last entry cannot contain a name. It can however contain\n\t\t * a pointer to a child node in the B+tree so we just break out.\n\t\t */\n\t\tif (ie->flags & INDEX_ENTRY_END)\n\t\t\tbreak;\n\t\t/*\n\t\t * We perform a case sensitive comparison and if that matches\n\t\t * we are done and return the mft reference of the inode (i.e.\n\t\t * the inode number together with the sequence number for\n\t\t * consistency checking). We convert it to cpu format before\n\t\t * returning.\n\t\t */\n\t\tif (ntfs_are_names_equal(uname, uname_len,\n\t\t\t\t(ntfschar*)&ie->key.file_name.file_name,\n\t\t\t\tie->key.file_name.file_name_length,\n\t\t\t\tCASE_SENSITIVE, vol->upcase, vol->upcase_len)) {\nfound_it:\n\t\t\t/*\n\t\t\t * We have a perfect match, so we don't need to care\n\t\t\t * about having matched imperfectly before, so we can\n\t\t\t * free name and set *res to NULL.\n\t\t\t * However, if the perfect match is a short file name,\n\t\t\t * we need to signal this through *res, so that\n\t\t\t * ntfs_lookup() can fix dcache aliasing issues.\n\t\t\t * As an optimization we just reuse an existing\n\t\t\t * allocation of *res.\n\t\t\t */\n\t\t\tif (ie->key.file_name.file_name_type == FILE_NAME_DOS) {\n\t\t\t\tif (!name) {\n\t\t\t\t\tname = kmalloc(sizeof(ntfs_name),\n\t\t\t\t\t\t\tGFP_NOFS);\n\t\t\t\t\tif (!name) {\n\t\t\t\t\t\terr = -ENOMEM;\n\t\t\t\t\t\tgoto err_out;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tname->mref = le64_to_cpu(\n\t\t\t\t\t\tie->data.dir.indexed_file);\n\t\t\t\tname->type = FILE_NAME_DOS;\n\t\t\t\tname->len = 0;\n\t\t\t\t*res = name;\n\t\t\t} else {\n\t\t\t\tkfree(name);\n\t\t\t\t*res = NULL;\n\t\t\t}\n\t\t\tmref = le64_to_cpu(ie->data.dir.indexed_file);\n\t\t\tntfs_attr_put_search_ctx(ctx);\n\t\t\tunmap_mft_record(dir_ni);\n\t\t\treturn mref;\n\t\t}\n\t\t/*\n\t\t * For a case insensitive mount, we also perform a case\n\t\t * insensitive comparison (provided the file name is not in the\n\t\t * POSIX namespace). If the comparison matches, and the name is\n\t\t * in the WIN32 namespace, we cache the filename in *res so\n\t\t * that the caller, ntfs_lookup(), can work on it. If the\n\t\t * comparison matches, and the name is in the DOS namespace, we\n\t\t * only cache the mft reference and the file name type (we set\n\t\t * the name length to zero for simplicity).\n\t\t */\n\t\tif (!NVolCaseSensitive(vol) &&\n\t\t\t\tie->key.file_name.file_name_type &&\n\t\t\t\tntfs_are_names_equal(uname, uname_len,\n\t\t\t\t(ntfschar*)&ie->key.file_name.file_name,\n\t\t\t\tie->key.file_name.file_name_length,\n\t\t\t\tIGNORE_CASE, vol->upcase, vol->upcase_len)) {\n\t\t\tint name_size = sizeof(ntfs_name);\n\t\t\tu8 type = ie->key.file_name.file_name_type;\n\t\t\tu8 len = ie->key.file_name.file_name_length;\n\n\t\t\t/* Only one case insensitive matching name allowed. */\n\t\t\tif (name) {\n\t\t\t\tntfs_error(sb, \"Found already allocated name \"\n\t\t\t\t\t\t\"in phase 1. Please run chkdsk \"\n\t\t\t\t\t\t\"and if that doesn't find any \"\n\t\t\t\t\t\t\"errors please report you saw \"\n\t\t\t\t\t\t\"this message to \"\n\t\t\t\t\t\t\"linux-ntfs-dev@lists.\"\n\t\t\t\t\t\t\"sourceforge.net.\");\n\t\t\t\tgoto dir_err_out;\n\t\t\t}\n\n\t\t\tif (type != FILE_NAME_DOS)\n\t\t\t\tname_size += len * sizeof(ntfschar);\n\t\t\tname = kmalloc(name_size, GFP_NOFS);\n\t\t\tif (!name) {\n\t\t\t\terr = -ENOMEM;\n\t\t\t\tgoto err_out;\n\t\t\t}\n\t\t\tname->mref = le64_to_cpu(ie->data.dir.indexed_file);\n\t\t\tname->type = type;\n\t\t\tif (type != FILE_NAME_DOS) {\n\t\t\t\tname->len = len;\n\t\t\t\tmemcpy(name->name, ie->key.file_name.file_name,\n\t\t\t\t\t\tlen * sizeof(ntfschar));\n\t\t\t} else\n\t\t\t\tname->len = 0;\n\t\t\t*res = name;\n\t\t}\n\t\t/*\n\t\t * Not a perfect match, need to do full blown collation so we\n\t\t * know which way in the B+tree we have to go.\n\t\t */\n\t\trc = ntfs_collate_names(uname, uname_len,\n\t\t\t\t(ntfschar*)&ie->key.file_name.file_name,\n\t\t\t\tie->key.file_name.file_name_length, 1,\n\t\t\t\tIGNORE_CASE, vol->upcase, vol->upcase_len);\n\t\t/*\n\t\t * If uname collates before the name of the current entry, there\n\t\t * is definitely no such name in this index but we might need to\n\t\t * descend into the B+tree so we just break out of the loop.\n\t\t */\n\t\tif (rc == -1)\n\t\t\tbreak;\n\t\t/* The names are not equal, continue the search. */\n\t\tif (rc)\n\t\t\tcontinue;\n\t\t/*\n\t\t * Names match with case insensitive comparison, now try the\n\t\t * case sensitive comparison, which is required for proper\n\t\t * collation.\n\t\t */\n\t\trc = ntfs_collate_names(uname, uname_len,\n\t\t\t\t(ntfschar*)&ie->key.file_name.file_name,\n\t\t\t\tie->key.file_name.file_name_length, 1,\n\t\t\t\tCASE_SENSITIVE, vol->upcase, vol->upcase_len);\n\t\tif (rc == -1)\n\t\t\tbreak;\n\t\tif (rc)\n\t\t\tcontinue;\n\t\t/*\n\t\t * Perfect match, this will never happen as the\n\t\t * ntfs_are_names_equal() call will have gotten a match but we\n\t\t * still treat it correctly.\n\t\t */\n\t\tgoto found_it;\n\t}\n\t/*\n\t * We have finished with this index without success. Check for the\n\t * presence of a child node and if not present return -ENOENT, unless\n\t * we have got a matching name cached in name in which case return the\n\t * mft reference associated with it.\n\t */\n\tif (!(ie->flags & INDEX_ENTRY_NODE)) {\n\t\tif (name) {\n\t\t\tntfs_attr_put_search_ctx(ctx);\n\t\t\tunmap_mft_record(dir_ni);\n\t\t\treturn name->mref;\n\t\t}\n\t\tntfs_debug(\"Entry not found.\");\n\t\terr = -ENOENT;\n\t\tgoto err_out;\n\t} /* Child node present, descend into it. */\n\t/* Consistency check: Verify that an index allocation exists. */\n\tif (!NInoIndexAllocPresent(dir_ni)) {\n\t\tntfs_error(sb, \"No index allocation attribute but index entry \"\n\t\t\t\t\"requires one. Directory inode 0x%lx is \"\n\t\t\t\t\"corrupt or driver bug.\", dir_ni->mft_no);\n\t\tgoto err_out;\n\t}\n\t/* Get the starting vcn of the index_block holding the child node. */\n\tvcn = sle64_to_cpup((sle64*)((u8*)ie + le16_to_cpu(ie->length) - 8));\n\tia_mapping = VFS_I(dir_ni)->i_mapping;\n\t/*\n\t * We are done with the index root and the mft record. Release them,\n\t * otherwise we deadlock with ntfs_map_page().\n\t */\n\tntfs_attr_put_search_ctx(ctx);\n\tunmap_mft_record(dir_ni);\n\tm = NULL;\n\tctx = NULL;\ndescend_into_child_node:\n\t/*\n\t * Convert vcn to index into the index allocation attribute in units\n\t * of PAGE_CACHE_SIZE and map the page cache page, reading it from\n\t * disk if necessary.\n\t */\n\tpage = ntfs_map_page(ia_mapping, vcn <<\n\t\t\tdir_ni->itype.index.vcn_size_bits >> PAGE_CACHE_SHIFT);\n\tif (IS_ERR(page)) {\n\t\tntfs_error(sb, \"Failed to map directory index page, error %ld.\",\n\t\t\t\t-PTR_ERR(page));\n\t\terr = PTR_ERR(page);\n\t\tgoto err_out;\n\t}\n\tlock_page(page);\n\tkaddr = (u8*)page_address(page);\nfast_descend_into_child_node:\n\t/* Get to the index allocation block. */\n\tia = (INDEX_ALLOCATION*)(kaddr + ((vcn <<\n\t\t\tdir_ni->itype.index.vcn_size_bits) & ~PAGE_CACHE_MASK));\n\t/* Bounds checks. */\n\tif ((u8*)ia < kaddr || (u8*)ia > kaddr + PAGE_CACHE_SIZE) {\n\t\tntfs_error(sb, \"Out of bounds check failed. Corrupt directory \"\n\t\t\t\t\"inode 0x%lx or driver bug.\", dir_ni->mft_no);\n\t\tgoto unm_err_out;\n\t}\n\t/* Catch multi sector transfer fixup errors. */\n\tif (unlikely(!ntfs_is_indx_record(ia->magic))) {\n\t\tntfs_error(sb, \"Directory index record with vcn 0x%llx is \"\n\t\t\t\t\"corrupt.  Corrupt inode 0x%lx.  Run chkdsk.\",\n\t\t\t\t(unsigned long long)vcn, dir_ni->mft_no);\n\t\tgoto unm_err_out;\n\t}\n\tif (sle64_to_cpu(ia->index_block_vcn) != vcn) {\n\t\tntfs_error(sb, \"Actual VCN (0x%llx) of index buffer is \"\n\t\t\t\t\"different from expected VCN (0x%llx). \"\n\t\t\t\t\"Directory inode 0x%lx is corrupt or driver \"\n\t\t\t\t\"bug.\", (unsigned long long)\n\t\t\t\tsle64_to_cpu(ia->index_block_vcn),\n\t\t\t\t(unsigned long long)vcn, dir_ni->mft_no);\n\t\tgoto unm_err_out;\n\t}\n\tif (le32_to_cpu(ia->index.allocated_size) + 0x18 !=\n\t\t\tdir_ni->itype.index.block_size) {\n\t\tntfs_error(sb, \"Index buffer (VCN 0x%llx) of directory inode \"\n\t\t\t\t\"0x%lx has a size (%u) differing from the \"\n\t\t\t\t\"directory specified size (%u). Directory \"\n\t\t\t\t\"inode is corrupt or driver bug.\",\n\t\t\t\t(unsigned long long)vcn, dir_ni->mft_no,\n\t\t\t\tle32_to_cpu(ia->index.allocated_size) + 0x18,\n\t\t\t\tdir_ni->itype.index.block_size);\n\t\tgoto unm_err_out;\n\t}\n\tindex_end = (u8*)ia + dir_ni->itype.index.block_size;\n\tif (index_end > kaddr + PAGE_CACHE_SIZE) {\n\t\tntfs_error(sb, \"Index buffer (VCN 0x%llx) of directory inode \"\n\t\t\t\t\"0x%lx crosses page boundary. Impossible! \"\n\t\t\t\t\"Cannot access! This is probably a bug in the \"\n\t\t\t\t\"driver.\", (unsigned long long)vcn,\n\t\t\t\tdir_ni->mft_no);\n\t\tgoto unm_err_out;\n\t}\n\tindex_end = (u8*)&ia->index + le32_to_cpu(ia->index.index_length);\n\tif (index_end > (u8*)ia + dir_ni->itype.index.block_size) {\n\t\tntfs_error(sb, \"Size of index buffer (VCN 0x%llx) of directory \"\n\t\t\t\t\"inode 0x%lx exceeds maximum size.\",\n\t\t\t\t(unsigned long long)vcn, dir_ni->mft_no);\n\t\tgoto unm_err_out;\n\t}\n\t/* The first index entry. */\n\tie = (INDEX_ENTRY*)((u8*)&ia->index +\n\t\t\tle32_to_cpu(ia->index.entries_offset));\n\t/*\n\t * Iterate similar to above big loop but applied to index buffer, thus\n\t * loop until we exceed valid memory (corruption case) or until we\n\t * reach the last entry.\n\t */\n\tfor (;; ie = (INDEX_ENTRY*)((u8*)ie + le16_to_cpu(ie->length))) {\n\t\t/* Bounds check. */\n\t\tif ((u8*)ie < (u8*)ia || (u8*)ie +\n\t\t\t\tsizeof(INDEX_ENTRY_HEADER) > index_end ||\n\t\t\t\t(u8*)ie + le16_to_cpu(ie->key_length) >\n\t\t\t\tindex_end) {\n\t\t\tntfs_error(sb, \"Index entry out of bounds in \"\n\t\t\t\t\t\"directory inode 0x%lx.\",\n\t\t\t\t\tdir_ni->mft_no);\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\t/*\n\t\t * The last entry cannot contain a name. It can however contain\n\t\t * a pointer to a child node in the B+tree so we just break out.\n\t\t */\n\t\tif (ie->flags & INDEX_ENTRY_END)\n\t\t\tbreak;\n\t\t/*\n\t\t * We perform a case sensitive comparison and if that matches\n\t\t * we are done and return the mft reference of the inode (i.e.\n\t\t * the inode number together with the sequence number for\n\t\t * consistency checking). We convert it to cpu format before\n\t\t * returning.\n\t\t */\n\t\tif (ntfs_are_names_equal(uname, uname_len,\n\t\t\t\t(ntfschar*)&ie->key.file_name.file_name,\n\t\t\t\tie->key.file_name.file_name_length,\n\t\t\t\tCASE_SENSITIVE, vol->upcase, vol->upcase_len)) {\nfound_it2:\n\t\t\t/*\n\t\t\t * We have a perfect match, so we don't need to care\n\t\t\t * about having matched imperfectly before, so we can\n\t\t\t * free name and set *res to NULL.\n\t\t\t * However, if the perfect match is a short file name,\n\t\t\t * we need to signal this through *res, so that\n\t\t\t * ntfs_lookup() can fix dcache aliasing issues.\n\t\t\t * As an optimization we just reuse an existing\n\t\t\t * allocation of *res.\n\t\t\t */\n\t\t\tif (ie->key.file_name.file_name_type == FILE_NAME_DOS) {\n\t\t\t\tif (!name) {\n\t\t\t\t\tname = kmalloc(sizeof(ntfs_name),\n\t\t\t\t\t\t\tGFP_NOFS);\n\t\t\t\t\tif (!name) {\n\t\t\t\t\t\terr = -ENOMEM;\n\t\t\t\t\t\tgoto unm_err_out;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tname->mref = le64_to_cpu(\n\t\t\t\t\t\tie->data.dir.indexed_file);\n\t\t\t\tname->type = FILE_NAME_DOS;\n\t\t\t\tname->len = 0;\n\t\t\t\t*res = name;\n\t\t\t} else {\n\t\t\t\tkfree(name);\n\t\t\t\t*res = NULL;\n\t\t\t}\n\t\t\tmref = le64_to_cpu(ie->data.dir.indexed_file);\n\t\t\tunlock_page(page);\n\t\t\tntfs_unmap_page(page);\n\t\t\treturn mref;\n\t\t}\n\t\t/*\n\t\t * For a case insensitive mount, we also perform a case\n\t\t * insensitive comparison (provided the file name is not in the\n\t\t * POSIX namespace). If the comparison matches, and the name is\n\t\t * in the WIN32 namespace, we cache the filename in *res so\n\t\t * that the caller, ntfs_lookup(), can work on it. If the\n\t\t * comparison matches, and the name is in the DOS namespace, we\n\t\t * only cache the mft reference and the file name type (we set\n\t\t * the name length to zero for simplicity).\n\t\t */\n\t\tif (!NVolCaseSensitive(vol) &&\n\t\t\t\tie->key.file_name.file_name_type &&\n\t\t\t\tntfs_are_names_equal(uname, uname_len,\n\t\t\t\t(ntfschar*)&ie->key.file_name.file_name,\n\t\t\t\tie->key.file_name.file_name_length,\n\t\t\t\tIGNORE_CASE, vol->upcase, vol->upcase_len)) {\n\t\t\tint name_size = sizeof(ntfs_name);\n\t\t\tu8 type = ie->key.file_name.file_name_type;\n\t\t\tu8 len = ie->key.file_name.file_name_length;\n\n\t\t\t/* Only one case insensitive matching name allowed. */\n\t\t\tif (name) {\n\t\t\t\tntfs_error(sb, \"Found already allocated name \"\n\t\t\t\t\t\t\"in phase 2. Please run chkdsk \"\n\t\t\t\t\t\t\"and if that doesn't find any \"\n\t\t\t\t\t\t\"errors please report you saw \"\n\t\t\t\t\t\t\"this message to \"\n\t\t\t\t\t\t\"linux-ntfs-dev@lists.\"\n\t\t\t\t\t\t\"sourceforge.net.\");\n\t\t\t\tunlock_page(page);\n\t\t\t\tntfs_unmap_page(page);\n\t\t\t\tgoto dir_err_out;\n\t\t\t}\n\n\t\t\tif (type != FILE_NAME_DOS)\n\t\t\t\tname_size += len * sizeof(ntfschar);\n\t\t\tname = kmalloc(name_size, GFP_NOFS);\n\t\t\tif (!name) {\n\t\t\t\terr = -ENOMEM;\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t\tname->mref = le64_to_cpu(ie->data.dir.indexed_file);\n\t\t\tname->type = type;\n\t\t\tif (type != FILE_NAME_DOS) {\n\t\t\t\tname->len = len;\n\t\t\t\tmemcpy(name->name, ie->key.file_name.file_name,\n\t\t\t\t\t\tlen * sizeof(ntfschar));\n\t\t\t} else\n\t\t\t\tname->len = 0;\n\t\t\t*res = name;\n\t\t}\n\t\t/*\n\t\t * Not a perfect match, need to do full blown collation so we\n\t\t * know which way in the B+tree we have to go.\n\t\t */\n\t\trc = ntfs_collate_names(uname, uname_len,\n\t\t\t\t(ntfschar*)&ie->key.file_name.file_name,\n\t\t\t\tie->key.file_name.file_name_length, 1,\n\t\t\t\tIGNORE_CASE, vol->upcase, vol->upcase_len);\n\t\t/*\n\t\t * If uname collates before the name of the current entry, there\n\t\t * is definitely no such name in this index but we might need to\n\t\t * descend into the B+tree so we just break out of the loop.\n\t\t */\n\t\tif (rc == -1)\n\t\t\tbreak;\n\t\t/* The names are not equal, continue the search. */\n\t\tif (rc)\n\t\t\tcontinue;\n\t\t/*\n\t\t * Names match with case insensitive comparison, now try the\n\t\t * case sensitive comparison, which is required for proper\n\t\t * collation.\n\t\t */\n\t\trc = ntfs_collate_names(uname, uname_len,\n\t\t\t\t(ntfschar*)&ie->key.file_name.file_name,\n\t\t\t\tie->key.file_name.file_name_length, 1,\n\t\t\t\tCASE_SENSITIVE, vol->upcase, vol->upcase_len);\n\t\tif (rc == -1)\n\t\t\tbreak;\n\t\tif (rc)\n\t\t\tcontinue;\n\t\t/*\n\t\t * Perfect match, this will never happen as the\n\t\t * ntfs_are_names_equal() call will have gotten a match but we\n\t\t * still treat it correctly.\n\t\t */\n\t\tgoto found_it2;\n\t}\n\t/*\n\t * We have finished with this index buffer without success. Check for\n\t * the presence of a child node.\n\t */\n\tif (ie->flags & INDEX_ENTRY_NODE) {\n\t\tif ((ia->index.flags & NODE_MASK) == LEAF_NODE) {\n\t\t\tntfs_error(sb, \"Index entry with child node found in \"\n\t\t\t\t\t\"a leaf node in directory inode 0x%lx.\",\n\t\t\t\t\tdir_ni->mft_no);\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\t/* Child node present, descend into it. */\n\t\told_vcn = vcn;\n\t\tvcn = sle64_to_cpup((sle64*)((u8*)ie +\n\t\t\t\tle16_to_cpu(ie->length) - 8));\n\t\tif (vcn >= 0) {\n\t\t\t/* If vcn is in the same page cache page as old_vcn we\n\t\t\t * recycle the mapped page. */\n\t\t\tif (old_vcn << vol->cluster_size_bits >>\n\t\t\t\t\tPAGE_CACHE_SHIFT == vcn <<\n\t\t\t\t\tvol->cluster_size_bits >>\n\t\t\t\t\tPAGE_CACHE_SHIFT)\n\t\t\t\tgoto fast_descend_into_child_node;\n\t\t\tunlock_page(page);\n\t\t\tntfs_unmap_page(page);\n\t\t\tgoto descend_into_child_node;\n\t\t}\n\t\tntfs_error(sb, \"Negative child node vcn in directory inode \"\n\t\t\t\t\"0x%lx.\", dir_ni->mft_no);\n\t\tgoto unm_err_out;\n\t}\n\t/*\n\t * No child node present, return -ENOENT, unless we have got a matching\n\t * name cached in name in which case return the mft reference\n\t * associated with it.\n\t */\n\tif (name) {\n\t\tunlock_page(page);\n\t\tntfs_unmap_page(page);\n\t\treturn name->mref;\n\t}\n\tntfs_debug(\"Entry not found.\");\n\terr = -ENOENT;\nunm_err_out:\n\tunlock_page(page);\n\tntfs_unmap_page(page);\nerr_out:\n\tif (!err)\n\t\terr = -EIO;\n\tif (ctx)\n\t\tntfs_attr_put_search_ctx(ctx);\n\tif (m)\n\t\tunmap_mft_record(dir_ni);\n\tif (name) {\n\t\tkfree(name);\n\t\t*res = NULL;\n\t}\n\treturn ERR_MREF(err);\ndir_err_out:\n\tntfs_error(sb, \"Corrupt directory.  Aborting lookup.\");\n\tgoto err_out;\n}"
        }
      },
      {
        "call_info": {
          "callee": "NTFS_I",
          "args": [
            "vol->extend_ino"
          ],
          "line": 1381
        },
        "resolved": true,
        "details": {
          "function_name": "NTFS_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/inode.h",
          "lines": "240-243",
          "snippet": "static inline ntfs_inode *NTFS_I(struct inode *inode)\n{\n\treturn (ntfs_inode *)list_entry(inode, big_ntfs_inode, vfs_inode);\n}",
          "includes": [
            "#include \"debug.h\"",
            "#include \"runlist.h\"",
            "#include \"types.h\"",
            "#include \"volume.h\"",
            "#include \"layout.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/mutex.h>",
            "#include <linux/mm.h>",
            "#include <linux/list.h>",
            "#include <linux/fs.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"debug.h\"\n#include \"runlist.h\"\n#include \"types.h\"\n#include \"volume.h\"\n#include \"layout.h\"\n#include <linux/seq_file.h>\n#include <linux/mutex.h>\n#include <linux/mm.h>\n#include <linux/list.h>\n#include <linux/fs.h>\n#include <linux/atomic.h>\n\nstatic inline ntfs_inode *NTFS_I(struct inode *inode)\n{\n\treturn (ntfs_inode *)list_entry(inode, big_ntfs_inode, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&vol->extend_ino->i_mutex"
          ],
          "line": 1380
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "'Q'"
          ],
          "line": 1373
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "'$'"
          ],
          "line": 1372
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "'a'"
          ],
          "line": 1371
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "'t'"
          ],
          "line": 1370
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "'o'"
          ],
          "line": 1370
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "'u'"
          ],
          "line": 1369
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "'Q'"
          ],
          "line": 1369
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "'$'"
          ],
          "line": 1368
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ntfs.h\"\n#include \"malloc.h\"\n#include \"layout.h\"\n#include \"aops.h\"\n#include \"inode.h\"\n#include \"index.h\"\n#include \"debug.h\"\n#include \"dir.h\"\n#include \"usnjrnl.h\"\n#include \"quota.h\"\n#include \"logfile.h\"\n#include \"sysctl.h\"\n#include <linux/bitmap.h>\n#include <linux/moduleparam.h>\n#include <linux/vfs.h>\n#include <linux/buffer_head.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\t/* For bdev_logical_block_size(). */\n#include <linux/spinlock.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/stddef.h>\n\nstatic bool load_and_init_quota(ntfs_volume *vol)\n{\n\tMFT_REF mref;\n\tstruct inode *tmp_ino;\n\tntfs_name *name = NULL;\n\tstatic const ntfschar Quota[7] = { cpu_to_le16('$'),\n\t\t\tcpu_to_le16('Q'), cpu_to_le16('u'),\n\t\t\tcpu_to_le16('o'), cpu_to_le16('t'),\n\t\t\tcpu_to_le16('a'), 0 };\n\tstatic ntfschar Q[3] = { cpu_to_le16('$'),\n\t\t\tcpu_to_le16('Q'), 0 };\n\n\tntfs_debug(\"Entering.\");\n\t/*\n\t * Find the inode number for the quota file by looking up the filename\n\t * $Quota in the extended system files directory $Extend.\n\t */\n\tmutex_lock(&vol->extend_ino->i_mutex);\n\tmref = ntfs_lookup_inode_by_name(NTFS_I(vol->extend_ino), Quota, 6,\n\t\t\t&name);\n\tmutex_unlock(&vol->extend_ino->i_mutex);\n\tif (IS_ERR_MREF(mref)) {\n\t\t/*\n\t\t * If the file does not exist, quotas are disabled and have\n\t\t * never been enabled on this volume, just return success.\n\t\t */\n\t\tif (MREF_ERR(mref) == -ENOENT) {\n\t\t\tntfs_debug(\"$Quota not present.  Volume does not have \"\n\t\t\t\t\t\"quotas enabled.\");\n\t\t\t/*\n\t\t\t * No need to try to set quotas out of date if they are\n\t\t\t * not enabled.\n\t\t\t */\n\t\t\tNVolSetQuotaOutOfDate(vol);\n\t\t\treturn true;\n\t\t}\n\t\t/* A real error occurred. */\n\t\tntfs_error(vol->sb, \"Failed to find inode number for $Quota.\");\n\t\treturn false;\n\t}\n\t/* We do not care for the type of match that was found. */\n\tkfree(name);\n\t/* Get the inode. */\n\ttmp_ino = ntfs_iget(vol->sb, MREF(mref));\n\tif (IS_ERR(tmp_ino) || is_bad_inode(tmp_ino)) {\n\t\tif (!IS_ERR(tmp_ino))\n\t\t\tiput(tmp_ino);\n\t\tntfs_error(vol->sb, \"Failed to load $Quota.\");\n\t\treturn false;\n\t}\n\tvol->quota_ino = tmp_ino;\n\t/* Get the $Q index allocation attribute. */\n\ttmp_ino = ntfs_index_iget(vol->quota_ino, Q, 2);\n\tif (IS_ERR(tmp_ino)) {\n\t\tntfs_error(vol->sb, \"Failed to load $Quota/$Q index.\");\n\t\treturn false;\n\t}\n\tvol->quota_q_ino = tmp_ino;\n\tntfs_debug(\"Done.\");\n\treturn true;\n}"
  },
  {
    "function_name": "check_windows_hibernation_status",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/super.c",
    "lines": "1266-1354",
    "snippet": "static int check_windows_hibernation_status(ntfs_volume *vol)\n{\n\tMFT_REF mref;\n\tstruct inode *vi;\n\tstruct page *page;\n\tu32 *kaddr, *kend;\n\tntfs_name *name = NULL;\n\tint ret = 1;\n\tstatic const ntfschar hiberfil[13] = { cpu_to_le16('h'),\n\t\t\tcpu_to_le16('i'), cpu_to_le16('b'),\n\t\t\tcpu_to_le16('e'), cpu_to_le16('r'),\n\t\t\tcpu_to_le16('f'), cpu_to_le16('i'),\n\t\t\tcpu_to_le16('l'), cpu_to_le16('.'),\n\t\t\tcpu_to_le16('s'), cpu_to_le16('y'),\n\t\t\tcpu_to_le16('s'), 0 };\n\n\tntfs_debug(\"Entering.\");\n\t/*\n\t * Find the inode number for the hibernation file by looking up the\n\t * filename hiberfil.sys in the root directory.\n\t */\n\tmutex_lock(&vol->root_ino->i_mutex);\n\tmref = ntfs_lookup_inode_by_name(NTFS_I(vol->root_ino), hiberfil, 12,\n\t\t\t&name);\n\tmutex_unlock(&vol->root_ino->i_mutex);\n\tif (IS_ERR_MREF(mref)) {\n\t\tret = MREF_ERR(mref);\n\t\t/* If the file does not exist, Windows is not hibernated. */\n\t\tif (ret == -ENOENT) {\n\t\t\tntfs_debug(\"hiberfil.sys not present.  Windows is not \"\n\t\t\t\t\t\"hibernated on the volume.\");\n\t\t\treturn 0;\n\t\t}\n\t\t/* A real error occurred. */\n\t\tntfs_error(vol->sb, \"Failed to find inode number for \"\n\t\t\t\t\"hiberfil.sys.\");\n\t\treturn ret;\n\t}\n\t/* We do not care for the type of match that was found. */\n\tkfree(name);\n\t/* Get the inode. */\n\tvi = ntfs_iget(vol->sb, MREF(mref));\n\tif (IS_ERR(vi) || is_bad_inode(vi)) {\n\t\tif (!IS_ERR(vi))\n\t\t\tiput(vi);\n\t\tntfs_error(vol->sb, \"Failed to load hiberfil.sys.\");\n\t\treturn IS_ERR(vi) ? PTR_ERR(vi) : -EIO;\n\t}\n\tif (unlikely(i_size_read(vi) < NTFS_HIBERFIL_HEADER_SIZE)) {\n\t\tntfs_debug(\"hiberfil.sys is smaller than 4kiB (0x%llx).  \"\n\t\t\t\t\"Windows is hibernated on the volume.  This \"\n\t\t\t\t\"is not the system volume.\", i_size_read(vi));\n\t\tgoto iput_out;\n\t}\n\tpage = ntfs_map_page(vi->i_mapping, 0);\n\tif (IS_ERR(page)) {\n\t\tntfs_error(vol->sb, \"Failed to read from hiberfil.sys.\");\n\t\tret = PTR_ERR(page);\n\t\tgoto iput_out;\n\t}\n\tkaddr = (u32*)page_address(page);\n\tif (*(le32*)kaddr == cpu_to_le32(0x72626968)/*'hibr'*/) {\n\t\tntfs_debug(\"Magic \\\"hibr\\\" found in hiberfil.sys.  Windows is \"\n\t\t\t\t\"hibernated on the volume.  This is the \"\n\t\t\t\t\"system volume.\");\n\t\tgoto unm_iput_out;\n\t}\n\tkend = kaddr + NTFS_HIBERFIL_HEADER_SIZE/sizeof(*kaddr);\n\tdo {\n\t\tif (unlikely(*kaddr)) {\n\t\t\tntfs_debug(\"hiberfil.sys is larger than 4kiB \"\n\t\t\t\t\t\"(0x%llx), does not contain the \"\n\t\t\t\t\t\"\\\"hibr\\\" magic, and does not have a \"\n\t\t\t\t\t\"zero header.  Windows is hibernated \"\n\t\t\t\t\t\"on the volume.  This is not the \"\n\t\t\t\t\t\"system volume.\", i_size_read(vi));\n\t\t\tgoto unm_iput_out;\n\t\t}\n\t} while (++kaddr < kend);\n\tntfs_debug(\"hiberfil.sys contains a zero header.  Windows is not \"\n\t\t\t\"hibernated on the volume.  This is the system \"\n\t\t\t\"volume.\");\n\tret = 0;\nunm_iput_out:\n\tntfs_unmap_page(page);\niput_out:\n\tiput(vi);\n\treturn ret;\n}",
    "includes": [
      "#include \"ntfs.h\"",
      "#include \"malloc.h\"",
      "#include \"layout.h\"",
      "#include \"aops.h\"",
      "#include \"inode.h\"",
      "#include \"index.h\"",
      "#include \"debug.h\"",
      "#include \"dir.h\"",
      "#include \"usnjrnl.h\"",
      "#include \"quota.h\"",
      "#include \"logfile.h\"",
      "#include \"sysctl.h\"",
      "#include <linux/bitmap.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/vfs.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/blkdev.h>\t/* For bdev_logical_block_size(). */",
      "#include <linux/spinlock.h>",
      "#include <linux/string.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/stddef.h>"
    ],
    "macros_used": [
      "#define NTFS_HIBERFIL_HEADER_SIZE\t4096"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "iput",
          "args": [
            "vi"
          ],
          "line": 1352
        },
        "resolved": true,
        "details": {
          "function_name": "dentry_iput",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "308-327",
          "snippet": "static void dentry_iput(struct dentry * dentry)\n\t__releases(dentry->d_lock)\n\t__releases(dentry->d_inode->i_lock)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tif (inode) {\n\t\tdentry->d_inode = NULL;\n\t\thlist_del_init(&dentry->d_u.d_alias);\n\t\tspin_unlock(&dentry->d_lock);\n\t\tspin_unlock(&inode->i_lock);\n\t\tif (!inode->i_nlink)\n\t\t\tfsnotify_inoderemove(inode);\n\t\tif (dentry->d_op && dentry->d_op->d_iput)\n\t\t\tdentry->d_op->d_iput(dentry, inode);\n\t\telse\n\t\t\tiput(inode);\n\t} else {\n\t\tspin_unlock(&dentry->d_lock);\n\t}\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nstatic void dentry_iput(struct dentry * dentry)\n\t__releases(dentry->d_lock)\n\t__releases(dentry->d_inode->i_lock)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tif (inode) {\n\t\tdentry->d_inode = NULL;\n\t\thlist_del_init(&dentry->d_u.d_alias);\n\t\tspin_unlock(&dentry->d_lock);\n\t\tspin_unlock(&inode->i_lock);\n\t\tif (!inode->i_nlink)\n\t\t\tfsnotify_inoderemove(inode);\n\t\tif (dentry->d_op && dentry->d_op->d_iput)\n\t\t\tdentry->d_op->d_iput(dentry, inode);\n\t\telse\n\t\t\tiput(inode);\n\t} else {\n\t\tspin_unlock(&dentry->d_lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ntfs_unmap_page",
          "args": [
            "page"
          ],
          "line": 1350
        },
        "resolved": true,
        "details": {
          "function_name": "ntfs_unmap_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/aops.h",
          "lines": "40-44",
          "snippet": "static inline void ntfs_unmap_page(struct page *page)\n{\n\tkunmap(page);\n\tpage_cache_release(page);\n}",
          "includes": [
            "#include \"inode.h\"",
            "#include <linux/fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"inode.h\"\n#include <linux/fs.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\nstatic inline void ntfs_unmap_page(struct page *page)\n{\n\tkunmap(page);\n\tpage_cache_release(page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ntfs_debug",
          "args": [
            "\"hiberfil.sys contains a zero header.  Windows is not \"\n\t\t\t\"hibernated on the volume.  This is the system \"\n\t\t\t\"volume.\""
          ],
          "line": 1345
        },
        "resolved": true,
        "details": {
          "function_name": "ntfs_debug_dump_runlist",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/debug.c",
          "lines": "134-171",
          "snippet": "void ntfs_debug_dump_runlist(const runlist_element *rl)\n{\n\tint i;\n\tconst char *lcn_str[5] = { \"LCN_HOLE         \", \"LCN_RL_NOT_MAPPED\",\n\t\t\t\t   \"LCN_ENOENT       \", \"LCN_unknown      \" };\n\n\tif (!debug_msgs)\n\t\treturn;\n\tpr_debug(\"Dumping runlist (values in hex):\\n\");\n\tif (!rl) {\n\t\tpr_debug(\"Run list not present.\\n\");\n\t\treturn;\n\t}\n\tpr_debug(\"VCN              LCN               Run length\\n\");\n\tfor (i = 0; ; i++) {\n\t\tLCN lcn = (rl + i)->lcn;\n\n\t\tif (lcn < (LCN)0) {\n\t\t\tint index = -lcn - 1;\n\n\t\t\tif (index > -LCN_ENOENT - 1)\n\t\t\t\tindex = 3;\n\t\t\tpr_debug(\"%-16Lx %s %-16Lx%s\\n\",\n\t\t\t\t\t(long long)(rl + i)->vcn, lcn_str[index],\n\t\t\t\t\t(long long)(rl + i)->length,\n\t\t\t\t\t(rl + i)->length ? \"\" :\n\t\t\t\t\t\t\" (runlist end)\");\n\t\t} else\n\t\t\tpr_debug(\"%-16Lx %-16Lx  %-16Lx%s\\n\",\n\t\t\t\t\t(long long)(rl + i)->vcn,\n\t\t\t\t\t(long long)(rl + i)->lcn,\n\t\t\t\t\t(long long)(rl + i)->length,\n\t\t\t\t\t(rl + i)->length ? \"\" :\n\t\t\t\t\t\t\" (runlist end)\");\n\t\tif (!(rl + i)->length)\n\t\t\tbreak;\n\t}\n}",
          "includes": [
            "#include \"debug.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"debug.h\"\n\nvoid ntfs_debug_dump_runlist(const runlist_element *rl)\n{\n\tint i;\n\tconst char *lcn_str[5] = { \"LCN_HOLE         \", \"LCN_RL_NOT_MAPPED\",\n\t\t\t\t   \"LCN_ENOENT       \", \"LCN_unknown      \" };\n\n\tif (!debug_msgs)\n\t\treturn;\n\tpr_debug(\"Dumping runlist (values in hex):\\n\");\n\tif (!rl) {\n\t\tpr_debug(\"Run list not present.\\n\");\n\t\treturn;\n\t}\n\tpr_debug(\"VCN              LCN               Run length\\n\");\n\tfor (i = 0; ; i++) {\n\t\tLCN lcn = (rl + i)->lcn;\n\n\t\tif (lcn < (LCN)0) {\n\t\t\tint index = -lcn - 1;\n\n\t\t\tif (index > -LCN_ENOENT - 1)\n\t\t\t\tindex = 3;\n\t\t\tpr_debug(\"%-16Lx %s %-16Lx%s\\n\",\n\t\t\t\t\t(long long)(rl + i)->vcn, lcn_str[index],\n\t\t\t\t\t(long long)(rl + i)->length,\n\t\t\t\t\t(rl + i)->length ? \"\" :\n\t\t\t\t\t\t\" (runlist end)\");\n\t\t} else\n\t\t\tpr_debug(\"%-16Lx %-16Lx  %-16Lx%s\\n\",\n\t\t\t\t\t(long long)(rl + i)->vcn,\n\t\t\t\t\t(long long)(rl + i)->lcn,\n\t\t\t\t\t(long long)(rl + i)->length,\n\t\t\t\t\t(rl + i)->length ? \"\" :\n\t\t\t\t\t\t\" (runlist end)\");\n\t\tif (!(rl + i)->length)\n\t\t\tbreak;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ntfs_debug",
          "args": [
            "\"hiberfil.sys is larger than 4kiB \"\n\t\t\t\t\t\"(0x%llx), does not contain the \"\n\t\t\t\t\t\"\\\"hibr\\\" magic, and does not have a \"\n\t\t\t\t\t\"zero header.  Windows is hibernated \"\n\t\t\t\t\t\"on the volume.  This is not the \"\n\t\t\t\t\t\"system volume.\"",
            "i_size_read(vi)"
          ],
          "line": 1336
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "i_size_read",
          "args": [
            "vi"
          ],
          "line": 1341
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "*kaddr"
          ],
          "line": 1335
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "0x72626968"
          ],
          "line": 1327
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_address",
          "args": [
            "page"
          ],
          "line": 1326
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "page"
          ],
          "line": 1323
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_error",
          "args": [
            "vol->sb",
            "\"Failed to read from hiberfil.sys.\""
          ],
          "line": 1322
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "page"
          ],
          "line": 1321
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_map_page",
          "args": [
            "vi->i_mapping",
            "0"
          ],
          "line": 1320
        },
        "resolved": true,
        "details": {
          "function_name": "ntfs_map_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/aops.h",
          "lines": "86-99",
          "snippet": "static inline struct page *ntfs_map_page(struct address_space *mapping,\n\t\tunsigned long index)\n{\n\tstruct page *page = read_mapping_page(mapping, index, NULL);\n\n\tif (!IS_ERR(page)) {\n\t\tkmap(page);\n\t\tif (!PageError(page))\n\t\t\treturn page;\n\t\tntfs_unmap_page(page);\n\t\treturn ERR_PTR(-EIO);\n\t}\n\treturn page;\n}",
          "includes": [
            "#include \"inode.h\"",
            "#include <linux/fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"inode.h\"\n#include <linux/fs.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\nstatic inline struct page *ntfs_map_page(struct address_space *mapping,\n\t\tunsigned long index)\n{\n\tstruct page *page = read_mapping_page(mapping, index, NULL);\n\n\tif (!IS_ERR(page)) {\n\t\tkmap(page);\n\t\tif (!PageError(page))\n\t\t\treturn page;\n\t\tntfs_unmap_page(page);\n\t\treturn ERR_PTR(-EIO);\n\t}\n\treturn page;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ntfs_debug",
          "args": [
            "\"hiberfil.sys is smaller than 4kiB (0x%llx).  \"\n\t\t\t\t\"Windows is hibernated on the volume.  This \"\n\t\t\t\t\"is not the system volume.\"",
            "i_size_read(vi)"
          ],
          "line": 1315
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "i_size_read",
          "args": [
            "vi"
          ],
          "line": 1317
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "i_size_read(vi) < NTFS_HIBERFIL_HEADER_SIZE"
          ],
          "line": 1314
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "i_size_read",
          "args": [
            "vi"
          ],
          "line": 1314
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "vi"
          ],
          "line": 1312
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "vi"
          ],
          "line": 1312
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_error",
          "args": [
            "vol->sb",
            "\"Failed to load hiberfil.sys.\""
          ],
          "line": 1311
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "vi"
          ],
          "line": 1309
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_bad_inode",
          "args": [
            "vi"
          ],
          "line": 1308
        },
        "resolved": true,
        "details": {
          "function_name": "is_bad_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/bad_inode.c",
          "lines": "195-198",
          "snippet": "int is_bad_inode(struct inode *inode)\n{\n\treturn (inode->i_op == &bad_inode_ops);\t\n}",
          "includes": [
            "#include <linux/poll.h>",
            "#include <linux/namei.h>",
            "#include <linux/time.h>",
            "#include <linux/stat.h>",
            "#include <linux/export.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct inode_operations bad_inode_ops =\n{\n\t.create\t\t= bad_inode_create,\n\t.lookup\t\t= bad_inode_lookup,\n\t.link\t\t= bad_inode_link,\n\t.unlink\t\t= bad_inode_unlink,\n\t.symlink\t= bad_inode_symlink,\n\t.mkdir\t\t= bad_inode_mkdir,\n\t.rmdir\t\t= bad_inode_rmdir,\n\t.mknod\t\t= bad_inode_mknod,\n\t.rename2\t= bad_inode_rename2,\n\t.readlink\t= bad_inode_readlink,\n\t/* follow_link must be no-op, otherwise unmounting this inode\n\t   won't work */\n\t/* put_link returns void */\n\t/* truncate returns void */\n\t.permission\t= bad_inode_permission,\n\t.getattr\t= bad_inode_getattr,\n\t.setattr\t= bad_inode_setattr,\n\t.setxattr\t= bad_inode_setxattr,\n\t.getxattr\t= bad_inode_getxattr,\n\t.listxattr\t= bad_inode_listxattr,\n\t.removexattr\t= bad_inode_removexattr,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/poll.h>\n#include <linux/namei.h>\n#include <linux/time.h>\n#include <linux/stat.h>\n#include <linux/export.h>\n#include <linux/fs.h>\n\nstatic const struct inode_operations bad_inode_ops =\n{\n\t.create\t\t= bad_inode_create,\n\t.lookup\t\t= bad_inode_lookup,\n\t.link\t\t= bad_inode_link,\n\t.unlink\t\t= bad_inode_unlink,\n\t.symlink\t= bad_inode_symlink,\n\t.mkdir\t\t= bad_inode_mkdir,\n\t.rmdir\t\t= bad_inode_rmdir,\n\t.mknod\t\t= bad_inode_mknod,\n\t.rename2\t= bad_inode_rename2,\n\t.readlink\t= bad_inode_readlink,\n\t/* follow_link must be no-op, otherwise unmounting this inode\n\t   won't work */\n\t/* put_link returns void */\n\t/* truncate returns void */\n\t.permission\t= bad_inode_permission,\n\t.getattr\t= bad_inode_getattr,\n\t.setattr\t= bad_inode_setattr,\n\t.setxattr\t= bad_inode_setxattr,\n\t.getxattr\t= bad_inode_getxattr,\n\t.listxattr\t= bad_inode_listxattr,\n\t.removexattr\t= bad_inode_removexattr,\n};\n\nint is_bad_inode(struct inode *inode)\n{\n\treturn (inode->i_op == &bad_inode_ops);\t\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "vi"
          ],
          "line": 1308
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_iget",
          "args": [
            "vol->sb",
            "MREF(mref)"
          ],
          "line": 1307
        },
        "resolved": true,
        "details": {
          "function_name": "ntfs_iget",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/inode.c",
          "lines": "171-203",
          "snippet": "struct inode *ntfs_iget(struct super_block *sb, unsigned long mft_no)\n{\n\tstruct inode *vi;\n\tint err;\n\tntfs_attr na;\n\n\tna.mft_no = mft_no;\n\tna.type = AT_UNUSED;\n\tna.name = NULL;\n\tna.name_len = 0;\n\n\tvi = iget5_locked(sb, mft_no, (test_t)ntfs_test_inode,\n\t\t\t(set_t)ntfs_init_locked_inode, &na);\n\tif (unlikely(!vi))\n\t\treturn ERR_PTR(-ENOMEM);\n\n\terr = 0;\n\n\t/* If this is a freshly allocated inode, need to read it now. */\n\tif (vi->i_state & I_NEW) {\n\t\terr = ntfs_read_locked_inode(vi);\n\t\tunlock_new_inode(vi);\n\t}\n\t/*\n\t * There is no point in keeping bad inodes around if the failure was\n\t * due to ENOMEM. We want to be able to retry again later.\n\t */\n\tif (unlikely(err == -ENOMEM)) {\n\t\tiput(vi);\n\t\tvi = ERR_PTR(err);\n\t}\n\treturn vi;\n}",
          "includes": [
            "#include \"ntfs.h\"",
            "#include \"time.h\"",
            "#include \"mft.h\"",
            "#include \"malloc.h\"",
            "#include \"lcnalloc.h\"",
            "#include \"inode.h\"",
            "#include \"debug.h\"",
            "#include \"dir.h\"",
            "#include \"bitmap.h\"",
            "#include \"attrib.h\"",
            "#include \"aops.h\"",
            "#include <linux/aio.h>",
            "#include <linux/log2.h>",
            "#include <linux/slab.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mutex.h>",
            "#include <linux/mount.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ntfs_read_locked_inode(struct inode *vi);",
            "static int ntfs_read_locked_attr_inode(struct inode *base_vi, struct inode *vi);",
            "static int ntfs_read_locked_index_inode(struct inode *base_vi,\n\t\tstruct inode *vi);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ntfs.h\"\n#include \"time.h\"\n#include \"mft.h\"\n#include \"malloc.h\"\n#include \"lcnalloc.h\"\n#include \"inode.h\"\n#include \"debug.h\"\n#include \"dir.h\"\n#include \"bitmap.h\"\n#include \"attrib.h\"\n#include \"aops.h\"\n#include <linux/aio.h>\n#include <linux/log2.h>\n#include <linux/slab.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/mutex.h>\n#include <linux/mount.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n\nstatic int ntfs_read_locked_inode(struct inode *vi);\nstatic int ntfs_read_locked_attr_inode(struct inode *base_vi, struct inode *vi);\nstatic int ntfs_read_locked_index_inode(struct inode *base_vi,\n\t\tstruct inode *vi);\n\nstruct inode *ntfs_iget(struct super_block *sb, unsigned long mft_no)\n{\n\tstruct inode *vi;\n\tint err;\n\tntfs_attr na;\n\n\tna.mft_no = mft_no;\n\tna.type = AT_UNUSED;\n\tna.name = NULL;\n\tna.name_len = 0;\n\n\tvi = iget5_locked(sb, mft_no, (test_t)ntfs_test_inode,\n\t\t\t(set_t)ntfs_init_locked_inode, &na);\n\tif (unlikely(!vi))\n\t\treturn ERR_PTR(-ENOMEM);\n\n\terr = 0;\n\n\t/* If this is a freshly allocated inode, need to read it now. */\n\tif (vi->i_state & I_NEW) {\n\t\terr = ntfs_read_locked_inode(vi);\n\t\tunlock_new_inode(vi);\n\t}\n\t/*\n\t * There is no point in keeping bad inodes around if the failure was\n\t * due to ENOMEM. We want to be able to retry again later.\n\t */\n\tif (unlikely(err == -ENOMEM)) {\n\t\tiput(vi);\n\t\tvi = ERR_PTR(err);\n\t}\n\treturn vi;\n}"
        }
      },
      {
        "call_info": {
          "callee": "MREF",
          "args": [
            "mref"
          ],
          "line": 1307
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "name"
          ],
          "line": 1305
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_error",
          "args": [
            "vol->sb",
            "\"Failed to find inode number for \"\n\t\t\t\t\"hiberfil.sys.\""
          ],
          "line": 1300
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MREF_ERR",
          "args": [
            "mref"
          ],
          "line": 1292
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR_MREF",
          "args": [
            "mref"
          ],
          "line": 1291
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&vol->root_ino->i_mutex"
          ],
          "line": 1290
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_lookup_inode_by_name",
          "args": [
            "NTFS_I(vol->root_ino)",
            "hiberfil",
            "12",
            "&name"
          ],
          "line": 1288
        },
        "resolved": true,
        "details": {
          "function_name": "ntfs_lookup_inode_by_name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/dir.c",
          "lines": "80-604",
          "snippet": "MFT_REF ntfs_lookup_inode_by_name(ntfs_inode *dir_ni, const ntfschar *uname,\n\t\tconst int uname_len, ntfs_name **res)\n{\n\tntfs_volume *vol = dir_ni->vol;\n\tstruct super_block *sb = vol->sb;\n\tMFT_RECORD *m;\n\tINDEX_ROOT *ir;\n\tINDEX_ENTRY *ie;\n\tINDEX_ALLOCATION *ia;\n\tu8 *index_end;\n\tu64 mref;\n\tntfs_attr_search_ctx *ctx;\n\tint err, rc;\n\tVCN vcn, old_vcn;\n\tstruct address_space *ia_mapping;\n\tstruct page *page;\n\tu8 *kaddr;\n\tntfs_name *name = NULL;\n\n\tBUG_ON(!S_ISDIR(VFS_I(dir_ni)->i_mode));\n\tBUG_ON(NInoAttr(dir_ni));\n\t/* Get hold of the mft record for the directory. */\n\tm = map_mft_record(dir_ni);\n\tif (IS_ERR(m)) {\n\t\tntfs_error(sb, \"map_mft_record() failed with error code %ld.\",\n\t\t\t\t-PTR_ERR(m));\n\t\treturn ERR_MREF(PTR_ERR(m));\n\t}\n\tctx = ntfs_attr_get_search_ctx(dir_ni, m);\n\tif (unlikely(!ctx)) {\n\t\terr = -ENOMEM;\n\t\tgoto err_out;\n\t}\n\t/* Find the index root attribute in the mft record. */\n\terr = ntfs_attr_lookup(AT_INDEX_ROOT, I30, 4, CASE_SENSITIVE, 0, NULL,\n\t\t\t0, ctx);\n\tif (unlikely(err)) {\n\t\tif (err == -ENOENT) {\n\t\t\tntfs_error(sb, \"Index root attribute missing in \"\n\t\t\t\t\t\"directory inode 0x%lx.\",\n\t\t\t\t\tdir_ni->mft_no);\n\t\t\terr = -EIO;\n\t\t}\n\t\tgoto err_out;\n\t}\n\t/* Get to the index root value (it's been verified in read_inode). */\n\tir = (INDEX_ROOT*)((u8*)ctx->attr +\n\t\t\tle16_to_cpu(ctx->attr->data.resident.value_offset));\n\tindex_end = (u8*)&ir->index + le32_to_cpu(ir->index.index_length);\n\t/* The first index entry. */\n\tie = (INDEX_ENTRY*)((u8*)&ir->index +\n\t\t\tle32_to_cpu(ir->index.entries_offset));\n\t/*\n\t * Loop until we exceed valid memory (corruption case) or until we\n\t * reach the last entry.\n\t */\n\tfor (;; ie = (INDEX_ENTRY*)((u8*)ie + le16_to_cpu(ie->length))) {\n\t\t/* Bounds checks. */\n\t\tif ((u8*)ie < (u8*)ctx->mrec || (u8*)ie +\n\t\t\t\tsizeof(INDEX_ENTRY_HEADER) > index_end ||\n\t\t\t\t(u8*)ie + le16_to_cpu(ie->key_length) >\n\t\t\t\tindex_end)\n\t\t\tgoto dir_err_out;\n\t\t/*\n\t\t * The last entry cannot contain a name. It can however contain\n\t\t * a pointer to a child node in the B+tree so we just break out.\n\t\t */\n\t\tif (ie->flags & INDEX_ENTRY_END)\n\t\t\tbreak;\n\t\t/*\n\t\t * We perform a case sensitive comparison and if that matches\n\t\t * we are done and return the mft reference of the inode (i.e.\n\t\t * the inode number together with the sequence number for\n\t\t * consistency checking). We convert it to cpu format before\n\t\t * returning.\n\t\t */\n\t\tif (ntfs_are_names_equal(uname, uname_len,\n\t\t\t\t(ntfschar*)&ie->key.file_name.file_name,\n\t\t\t\tie->key.file_name.file_name_length,\n\t\t\t\tCASE_SENSITIVE, vol->upcase, vol->upcase_len)) {\nfound_it:\n\t\t\t/*\n\t\t\t * We have a perfect match, so we don't need to care\n\t\t\t * about having matched imperfectly before, so we can\n\t\t\t * free name and set *res to NULL.\n\t\t\t * However, if the perfect match is a short file name,\n\t\t\t * we need to signal this through *res, so that\n\t\t\t * ntfs_lookup() can fix dcache aliasing issues.\n\t\t\t * As an optimization we just reuse an existing\n\t\t\t * allocation of *res.\n\t\t\t */\n\t\t\tif (ie->key.file_name.file_name_type == FILE_NAME_DOS) {\n\t\t\t\tif (!name) {\n\t\t\t\t\tname = kmalloc(sizeof(ntfs_name),\n\t\t\t\t\t\t\tGFP_NOFS);\n\t\t\t\t\tif (!name) {\n\t\t\t\t\t\terr = -ENOMEM;\n\t\t\t\t\t\tgoto err_out;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tname->mref = le64_to_cpu(\n\t\t\t\t\t\tie->data.dir.indexed_file);\n\t\t\t\tname->type = FILE_NAME_DOS;\n\t\t\t\tname->len = 0;\n\t\t\t\t*res = name;\n\t\t\t} else {\n\t\t\t\tkfree(name);\n\t\t\t\t*res = NULL;\n\t\t\t}\n\t\t\tmref = le64_to_cpu(ie->data.dir.indexed_file);\n\t\t\tntfs_attr_put_search_ctx(ctx);\n\t\t\tunmap_mft_record(dir_ni);\n\t\t\treturn mref;\n\t\t}\n\t\t/*\n\t\t * For a case insensitive mount, we also perform a case\n\t\t * insensitive comparison (provided the file name is not in the\n\t\t * POSIX namespace). If the comparison matches, and the name is\n\t\t * in the WIN32 namespace, we cache the filename in *res so\n\t\t * that the caller, ntfs_lookup(), can work on it. If the\n\t\t * comparison matches, and the name is in the DOS namespace, we\n\t\t * only cache the mft reference and the file name type (we set\n\t\t * the name length to zero for simplicity).\n\t\t */\n\t\tif (!NVolCaseSensitive(vol) &&\n\t\t\t\tie->key.file_name.file_name_type &&\n\t\t\t\tntfs_are_names_equal(uname, uname_len,\n\t\t\t\t(ntfschar*)&ie->key.file_name.file_name,\n\t\t\t\tie->key.file_name.file_name_length,\n\t\t\t\tIGNORE_CASE, vol->upcase, vol->upcase_len)) {\n\t\t\tint name_size = sizeof(ntfs_name);\n\t\t\tu8 type = ie->key.file_name.file_name_type;\n\t\t\tu8 len = ie->key.file_name.file_name_length;\n\n\t\t\t/* Only one case insensitive matching name allowed. */\n\t\t\tif (name) {\n\t\t\t\tntfs_error(sb, \"Found already allocated name \"\n\t\t\t\t\t\t\"in phase 1. Please run chkdsk \"\n\t\t\t\t\t\t\"and if that doesn't find any \"\n\t\t\t\t\t\t\"errors please report you saw \"\n\t\t\t\t\t\t\"this message to \"\n\t\t\t\t\t\t\"linux-ntfs-dev@lists.\"\n\t\t\t\t\t\t\"sourceforge.net.\");\n\t\t\t\tgoto dir_err_out;\n\t\t\t}\n\n\t\t\tif (type != FILE_NAME_DOS)\n\t\t\t\tname_size += len * sizeof(ntfschar);\n\t\t\tname = kmalloc(name_size, GFP_NOFS);\n\t\t\tif (!name) {\n\t\t\t\terr = -ENOMEM;\n\t\t\t\tgoto err_out;\n\t\t\t}\n\t\t\tname->mref = le64_to_cpu(ie->data.dir.indexed_file);\n\t\t\tname->type = type;\n\t\t\tif (type != FILE_NAME_DOS) {\n\t\t\t\tname->len = len;\n\t\t\t\tmemcpy(name->name, ie->key.file_name.file_name,\n\t\t\t\t\t\tlen * sizeof(ntfschar));\n\t\t\t} else\n\t\t\t\tname->len = 0;\n\t\t\t*res = name;\n\t\t}\n\t\t/*\n\t\t * Not a perfect match, need to do full blown collation so we\n\t\t * know which way in the B+tree we have to go.\n\t\t */\n\t\trc = ntfs_collate_names(uname, uname_len,\n\t\t\t\t(ntfschar*)&ie->key.file_name.file_name,\n\t\t\t\tie->key.file_name.file_name_length, 1,\n\t\t\t\tIGNORE_CASE, vol->upcase, vol->upcase_len);\n\t\t/*\n\t\t * If uname collates before the name of the current entry, there\n\t\t * is definitely no such name in this index but we might need to\n\t\t * descend into the B+tree so we just break out of the loop.\n\t\t */\n\t\tif (rc == -1)\n\t\t\tbreak;\n\t\t/* The names are not equal, continue the search. */\n\t\tif (rc)\n\t\t\tcontinue;\n\t\t/*\n\t\t * Names match with case insensitive comparison, now try the\n\t\t * case sensitive comparison, which is required for proper\n\t\t * collation.\n\t\t */\n\t\trc = ntfs_collate_names(uname, uname_len,\n\t\t\t\t(ntfschar*)&ie->key.file_name.file_name,\n\t\t\t\tie->key.file_name.file_name_length, 1,\n\t\t\t\tCASE_SENSITIVE, vol->upcase, vol->upcase_len);\n\t\tif (rc == -1)\n\t\t\tbreak;\n\t\tif (rc)\n\t\t\tcontinue;\n\t\t/*\n\t\t * Perfect match, this will never happen as the\n\t\t * ntfs_are_names_equal() call will have gotten a match but we\n\t\t * still treat it correctly.\n\t\t */\n\t\tgoto found_it;\n\t}\n\t/*\n\t * We have finished with this index without success. Check for the\n\t * presence of a child node and if not present return -ENOENT, unless\n\t * we have got a matching name cached in name in which case return the\n\t * mft reference associated with it.\n\t */\n\tif (!(ie->flags & INDEX_ENTRY_NODE)) {\n\t\tif (name) {\n\t\t\tntfs_attr_put_search_ctx(ctx);\n\t\t\tunmap_mft_record(dir_ni);\n\t\t\treturn name->mref;\n\t\t}\n\t\tntfs_debug(\"Entry not found.\");\n\t\terr = -ENOENT;\n\t\tgoto err_out;\n\t} /* Child node present, descend into it. */\n\t/* Consistency check: Verify that an index allocation exists. */\n\tif (!NInoIndexAllocPresent(dir_ni)) {\n\t\tntfs_error(sb, \"No index allocation attribute but index entry \"\n\t\t\t\t\"requires one. Directory inode 0x%lx is \"\n\t\t\t\t\"corrupt or driver bug.\", dir_ni->mft_no);\n\t\tgoto err_out;\n\t}\n\t/* Get the starting vcn of the index_block holding the child node. */\n\tvcn = sle64_to_cpup((sle64*)((u8*)ie + le16_to_cpu(ie->length) - 8));\n\tia_mapping = VFS_I(dir_ni)->i_mapping;\n\t/*\n\t * We are done with the index root and the mft record. Release them,\n\t * otherwise we deadlock with ntfs_map_page().\n\t */\n\tntfs_attr_put_search_ctx(ctx);\n\tunmap_mft_record(dir_ni);\n\tm = NULL;\n\tctx = NULL;\ndescend_into_child_node:\n\t/*\n\t * Convert vcn to index into the index allocation attribute in units\n\t * of PAGE_CACHE_SIZE and map the page cache page, reading it from\n\t * disk if necessary.\n\t */\n\tpage = ntfs_map_page(ia_mapping, vcn <<\n\t\t\tdir_ni->itype.index.vcn_size_bits >> PAGE_CACHE_SHIFT);\n\tif (IS_ERR(page)) {\n\t\tntfs_error(sb, \"Failed to map directory index page, error %ld.\",\n\t\t\t\t-PTR_ERR(page));\n\t\terr = PTR_ERR(page);\n\t\tgoto err_out;\n\t}\n\tlock_page(page);\n\tkaddr = (u8*)page_address(page);\nfast_descend_into_child_node:\n\t/* Get to the index allocation block. */\n\tia = (INDEX_ALLOCATION*)(kaddr + ((vcn <<\n\t\t\tdir_ni->itype.index.vcn_size_bits) & ~PAGE_CACHE_MASK));\n\t/* Bounds checks. */\n\tif ((u8*)ia < kaddr || (u8*)ia > kaddr + PAGE_CACHE_SIZE) {\n\t\tntfs_error(sb, \"Out of bounds check failed. Corrupt directory \"\n\t\t\t\t\"inode 0x%lx or driver bug.\", dir_ni->mft_no);\n\t\tgoto unm_err_out;\n\t}\n\t/* Catch multi sector transfer fixup errors. */\n\tif (unlikely(!ntfs_is_indx_record(ia->magic))) {\n\t\tntfs_error(sb, \"Directory index record with vcn 0x%llx is \"\n\t\t\t\t\"corrupt.  Corrupt inode 0x%lx.  Run chkdsk.\",\n\t\t\t\t(unsigned long long)vcn, dir_ni->mft_no);\n\t\tgoto unm_err_out;\n\t}\n\tif (sle64_to_cpu(ia->index_block_vcn) != vcn) {\n\t\tntfs_error(sb, \"Actual VCN (0x%llx) of index buffer is \"\n\t\t\t\t\"different from expected VCN (0x%llx). \"\n\t\t\t\t\"Directory inode 0x%lx is corrupt or driver \"\n\t\t\t\t\"bug.\", (unsigned long long)\n\t\t\t\tsle64_to_cpu(ia->index_block_vcn),\n\t\t\t\t(unsigned long long)vcn, dir_ni->mft_no);\n\t\tgoto unm_err_out;\n\t}\n\tif (le32_to_cpu(ia->index.allocated_size) + 0x18 !=\n\t\t\tdir_ni->itype.index.block_size) {\n\t\tntfs_error(sb, \"Index buffer (VCN 0x%llx) of directory inode \"\n\t\t\t\t\"0x%lx has a size (%u) differing from the \"\n\t\t\t\t\"directory specified size (%u). Directory \"\n\t\t\t\t\"inode is corrupt or driver bug.\",\n\t\t\t\t(unsigned long long)vcn, dir_ni->mft_no,\n\t\t\t\tle32_to_cpu(ia->index.allocated_size) + 0x18,\n\t\t\t\tdir_ni->itype.index.block_size);\n\t\tgoto unm_err_out;\n\t}\n\tindex_end = (u8*)ia + dir_ni->itype.index.block_size;\n\tif (index_end > kaddr + PAGE_CACHE_SIZE) {\n\t\tntfs_error(sb, \"Index buffer (VCN 0x%llx) of directory inode \"\n\t\t\t\t\"0x%lx crosses page boundary. Impossible! \"\n\t\t\t\t\"Cannot access! This is probably a bug in the \"\n\t\t\t\t\"driver.\", (unsigned long long)vcn,\n\t\t\t\tdir_ni->mft_no);\n\t\tgoto unm_err_out;\n\t}\n\tindex_end = (u8*)&ia->index + le32_to_cpu(ia->index.index_length);\n\tif (index_end > (u8*)ia + dir_ni->itype.index.block_size) {\n\t\tntfs_error(sb, \"Size of index buffer (VCN 0x%llx) of directory \"\n\t\t\t\t\"inode 0x%lx exceeds maximum size.\",\n\t\t\t\t(unsigned long long)vcn, dir_ni->mft_no);\n\t\tgoto unm_err_out;\n\t}\n\t/* The first index entry. */\n\tie = (INDEX_ENTRY*)((u8*)&ia->index +\n\t\t\tle32_to_cpu(ia->index.entries_offset));\n\t/*\n\t * Iterate similar to above big loop but applied to index buffer, thus\n\t * loop until we exceed valid memory (corruption case) or until we\n\t * reach the last entry.\n\t */\n\tfor (;; ie = (INDEX_ENTRY*)((u8*)ie + le16_to_cpu(ie->length))) {\n\t\t/* Bounds check. */\n\t\tif ((u8*)ie < (u8*)ia || (u8*)ie +\n\t\t\t\tsizeof(INDEX_ENTRY_HEADER) > index_end ||\n\t\t\t\t(u8*)ie + le16_to_cpu(ie->key_length) >\n\t\t\t\tindex_end) {\n\t\t\tntfs_error(sb, \"Index entry out of bounds in \"\n\t\t\t\t\t\"directory inode 0x%lx.\",\n\t\t\t\t\tdir_ni->mft_no);\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\t/*\n\t\t * The last entry cannot contain a name. It can however contain\n\t\t * a pointer to a child node in the B+tree so we just break out.\n\t\t */\n\t\tif (ie->flags & INDEX_ENTRY_END)\n\t\t\tbreak;\n\t\t/*\n\t\t * We perform a case sensitive comparison and if that matches\n\t\t * we are done and return the mft reference of the inode (i.e.\n\t\t * the inode number together with the sequence number for\n\t\t * consistency checking). We convert it to cpu format before\n\t\t * returning.\n\t\t */\n\t\tif (ntfs_are_names_equal(uname, uname_len,\n\t\t\t\t(ntfschar*)&ie->key.file_name.file_name,\n\t\t\t\tie->key.file_name.file_name_length,\n\t\t\t\tCASE_SENSITIVE, vol->upcase, vol->upcase_len)) {\nfound_it2:\n\t\t\t/*\n\t\t\t * We have a perfect match, so we don't need to care\n\t\t\t * about having matched imperfectly before, so we can\n\t\t\t * free name and set *res to NULL.\n\t\t\t * However, if the perfect match is a short file name,\n\t\t\t * we need to signal this through *res, so that\n\t\t\t * ntfs_lookup() can fix dcache aliasing issues.\n\t\t\t * As an optimization we just reuse an existing\n\t\t\t * allocation of *res.\n\t\t\t */\n\t\t\tif (ie->key.file_name.file_name_type == FILE_NAME_DOS) {\n\t\t\t\tif (!name) {\n\t\t\t\t\tname = kmalloc(sizeof(ntfs_name),\n\t\t\t\t\t\t\tGFP_NOFS);\n\t\t\t\t\tif (!name) {\n\t\t\t\t\t\terr = -ENOMEM;\n\t\t\t\t\t\tgoto unm_err_out;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tname->mref = le64_to_cpu(\n\t\t\t\t\t\tie->data.dir.indexed_file);\n\t\t\t\tname->type = FILE_NAME_DOS;\n\t\t\t\tname->len = 0;\n\t\t\t\t*res = name;\n\t\t\t} else {\n\t\t\t\tkfree(name);\n\t\t\t\t*res = NULL;\n\t\t\t}\n\t\t\tmref = le64_to_cpu(ie->data.dir.indexed_file);\n\t\t\tunlock_page(page);\n\t\t\tntfs_unmap_page(page);\n\t\t\treturn mref;\n\t\t}\n\t\t/*\n\t\t * For a case insensitive mount, we also perform a case\n\t\t * insensitive comparison (provided the file name is not in the\n\t\t * POSIX namespace). If the comparison matches, and the name is\n\t\t * in the WIN32 namespace, we cache the filename in *res so\n\t\t * that the caller, ntfs_lookup(), can work on it. If the\n\t\t * comparison matches, and the name is in the DOS namespace, we\n\t\t * only cache the mft reference and the file name type (we set\n\t\t * the name length to zero for simplicity).\n\t\t */\n\t\tif (!NVolCaseSensitive(vol) &&\n\t\t\t\tie->key.file_name.file_name_type &&\n\t\t\t\tntfs_are_names_equal(uname, uname_len,\n\t\t\t\t(ntfschar*)&ie->key.file_name.file_name,\n\t\t\t\tie->key.file_name.file_name_length,\n\t\t\t\tIGNORE_CASE, vol->upcase, vol->upcase_len)) {\n\t\t\tint name_size = sizeof(ntfs_name);\n\t\t\tu8 type = ie->key.file_name.file_name_type;\n\t\t\tu8 len = ie->key.file_name.file_name_length;\n\n\t\t\t/* Only one case insensitive matching name allowed. */\n\t\t\tif (name) {\n\t\t\t\tntfs_error(sb, \"Found already allocated name \"\n\t\t\t\t\t\t\"in phase 2. Please run chkdsk \"\n\t\t\t\t\t\t\"and if that doesn't find any \"\n\t\t\t\t\t\t\"errors please report you saw \"\n\t\t\t\t\t\t\"this message to \"\n\t\t\t\t\t\t\"linux-ntfs-dev@lists.\"\n\t\t\t\t\t\t\"sourceforge.net.\");\n\t\t\t\tunlock_page(page);\n\t\t\t\tntfs_unmap_page(page);\n\t\t\t\tgoto dir_err_out;\n\t\t\t}\n\n\t\t\tif (type != FILE_NAME_DOS)\n\t\t\t\tname_size += len * sizeof(ntfschar);\n\t\t\tname = kmalloc(name_size, GFP_NOFS);\n\t\t\tif (!name) {\n\t\t\t\terr = -ENOMEM;\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t\tname->mref = le64_to_cpu(ie->data.dir.indexed_file);\n\t\t\tname->type = type;\n\t\t\tif (type != FILE_NAME_DOS) {\n\t\t\t\tname->len = len;\n\t\t\t\tmemcpy(name->name, ie->key.file_name.file_name,\n\t\t\t\t\t\tlen * sizeof(ntfschar));\n\t\t\t} else\n\t\t\t\tname->len = 0;\n\t\t\t*res = name;\n\t\t}\n\t\t/*\n\t\t * Not a perfect match, need to do full blown collation so we\n\t\t * know which way in the B+tree we have to go.\n\t\t */\n\t\trc = ntfs_collate_names(uname, uname_len,\n\t\t\t\t(ntfschar*)&ie->key.file_name.file_name,\n\t\t\t\tie->key.file_name.file_name_length, 1,\n\t\t\t\tIGNORE_CASE, vol->upcase, vol->upcase_len);\n\t\t/*\n\t\t * If uname collates before the name of the current entry, there\n\t\t * is definitely no such name in this index but we might need to\n\t\t * descend into the B+tree so we just break out of the loop.\n\t\t */\n\t\tif (rc == -1)\n\t\t\tbreak;\n\t\t/* The names are not equal, continue the search. */\n\t\tif (rc)\n\t\t\tcontinue;\n\t\t/*\n\t\t * Names match with case insensitive comparison, now try the\n\t\t * case sensitive comparison, which is required for proper\n\t\t * collation.\n\t\t */\n\t\trc = ntfs_collate_names(uname, uname_len,\n\t\t\t\t(ntfschar*)&ie->key.file_name.file_name,\n\t\t\t\tie->key.file_name.file_name_length, 1,\n\t\t\t\tCASE_SENSITIVE, vol->upcase, vol->upcase_len);\n\t\tif (rc == -1)\n\t\t\tbreak;\n\t\tif (rc)\n\t\t\tcontinue;\n\t\t/*\n\t\t * Perfect match, this will never happen as the\n\t\t * ntfs_are_names_equal() call will have gotten a match but we\n\t\t * still treat it correctly.\n\t\t */\n\t\tgoto found_it2;\n\t}\n\t/*\n\t * We have finished with this index buffer without success. Check for\n\t * the presence of a child node.\n\t */\n\tif (ie->flags & INDEX_ENTRY_NODE) {\n\t\tif ((ia->index.flags & NODE_MASK) == LEAF_NODE) {\n\t\t\tntfs_error(sb, \"Index entry with child node found in \"\n\t\t\t\t\t\"a leaf node in directory inode 0x%lx.\",\n\t\t\t\t\tdir_ni->mft_no);\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\t/* Child node present, descend into it. */\n\t\told_vcn = vcn;\n\t\tvcn = sle64_to_cpup((sle64*)((u8*)ie +\n\t\t\t\tle16_to_cpu(ie->length) - 8));\n\t\tif (vcn >= 0) {\n\t\t\t/* If vcn is in the same page cache page as old_vcn we\n\t\t\t * recycle the mapped page. */\n\t\t\tif (old_vcn << vol->cluster_size_bits >>\n\t\t\t\t\tPAGE_CACHE_SHIFT == vcn <<\n\t\t\t\t\tvol->cluster_size_bits >>\n\t\t\t\t\tPAGE_CACHE_SHIFT)\n\t\t\t\tgoto fast_descend_into_child_node;\n\t\t\tunlock_page(page);\n\t\t\tntfs_unmap_page(page);\n\t\t\tgoto descend_into_child_node;\n\t\t}\n\t\tntfs_error(sb, \"Negative child node vcn in directory inode \"\n\t\t\t\t\"0x%lx.\", dir_ni->mft_no);\n\t\tgoto unm_err_out;\n\t}\n\t/*\n\t * No child node present, return -ENOENT, unless we have got a matching\n\t * name cached in name in which case return the mft reference\n\t * associated with it.\n\t */\n\tif (name) {\n\t\tunlock_page(page);\n\t\tntfs_unmap_page(page);\n\t\treturn name->mref;\n\t}\n\tntfs_debug(\"Entry not found.\");\n\terr = -ENOENT;\nunm_err_out:\n\tunlock_page(page);\n\tntfs_unmap_page(page);\nerr_out:\n\tif (!err)\n\t\terr = -EIO;\n\tif (ctx)\n\t\tntfs_attr_put_search_ctx(ctx);\n\tif (m)\n\t\tunmap_mft_record(dir_ni);\n\tif (name) {\n\t\tkfree(name);\n\t\t*res = NULL;\n\t}\n\treturn ERR_MREF(err);\ndir_err_out:\n\tntfs_error(sb, \"Corrupt directory.  Aborting lookup.\");\n\tgoto err_out;\n}",
          "includes": [
            "#include \"ntfs.h\"",
            "#include \"debug.h\"",
            "#include \"mft.h\"",
            "#include \"attrib.h\"",
            "#include \"aops.h\"",
            "#include \"dir.h\"",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "ntfschar I30[5] = { cpu_to_le16('$'), cpu_to_le16('I'),\n\t\tcpu_to_le16('3'),\tcpu_to_le16('0'), 0 };"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ntfs.h\"\n#include \"debug.h\"\n#include \"mft.h\"\n#include \"attrib.h\"\n#include \"aops.h\"\n#include \"dir.h\"\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n\nntfschar I30[5] = { cpu_to_le16('$'), cpu_to_le16('I'),\n\t\tcpu_to_le16('3'),\tcpu_to_le16('0'), 0 };\n\nMFT_REF ntfs_lookup_inode_by_name(ntfs_inode *dir_ni, const ntfschar *uname,\n\t\tconst int uname_len, ntfs_name **res)\n{\n\tntfs_volume *vol = dir_ni->vol;\n\tstruct super_block *sb = vol->sb;\n\tMFT_RECORD *m;\n\tINDEX_ROOT *ir;\n\tINDEX_ENTRY *ie;\n\tINDEX_ALLOCATION *ia;\n\tu8 *index_end;\n\tu64 mref;\n\tntfs_attr_search_ctx *ctx;\n\tint err, rc;\n\tVCN vcn, old_vcn;\n\tstruct address_space *ia_mapping;\n\tstruct page *page;\n\tu8 *kaddr;\n\tntfs_name *name = NULL;\n\n\tBUG_ON(!S_ISDIR(VFS_I(dir_ni)->i_mode));\n\tBUG_ON(NInoAttr(dir_ni));\n\t/* Get hold of the mft record for the directory. */\n\tm = map_mft_record(dir_ni);\n\tif (IS_ERR(m)) {\n\t\tntfs_error(sb, \"map_mft_record() failed with error code %ld.\",\n\t\t\t\t-PTR_ERR(m));\n\t\treturn ERR_MREF(PTR_ERR(m));\n\t}\n\tctx = ntfs_attr_get_search_ctx(dir_ni, m);\n\tif (unlikely(!ctx)) {\n\t\terr = -ENOMEM;\n\t\tgoto err_out;\n\t}\n\t/* Find the index root attribute in the mft record. */\n\terr = ntfs_attr_lookup(AT_INDEX_ROOT, I30, 4, CASE_SENSITIVE, 0, NULL,\n\t\t\t0, ctx);\n\tif (unlikely(err)) {\n\t\tif (err == -ENOENT) {\n\t\t\tntfs_error(sb, \"Index root attribute missing in \"\n\t\t\t\t\t\"directory inode 0x%lx.\",\n\t\t\t\t\tdir_ni->mft_no);\n\t\t\terr = -EIO;\n\t\t}\n\t\tgoto err_out;\n\t}\n\t/* Get to the index root value (it's been verified in read_inode). */\n\tir = (INDEX_ROOT*)((u8*)ctx->attr +\n\t\t\tle16_to_cpu(ctx->attr->data.resident.value_offset));\n\tindex_end = (u8*)&ir->index + le32_to_cpu(ir->index.index_length);\n\t/* The first index entry. */\n\tie = (INDEX_ENTRY*)((u8*)&ir->index +\n\t\t\tle32_to_cpu(ir->index.entries_offset));\n\t/*\n\t * Loop until we exceed valid memory (corruption case) or until we\n\t * reach the last entry.\n\t */\n\tfor (;; ie = (INDEX_ENTRY*)((u8*)ie + le16_to_cpu(ie->length))) {\n\t\t/* Bounds checks. */\n\t\tif ((u8*)ie < (u8*)ctx->mrec || (u8*)ie +\n\t\t\t\tsizeof(INDEX_ENTRY_HEADER) > index_end ||\n\t\t\t\t(u8*)ie + le16_to_cpu(ie->key_length) >\n\t\t\t\tindex_end)\n\t\t\tgoto dir_err_out;\n\t\t/*\n\t\t * The last entry cannot contain a name. It can however contain\n\t\t * a pointer to a child node in the B+tree so we just break out.\n\t\t */\n\t\tif (ie->flags & INDEX_ENTRY_END)\n\t\t\tbreak;\n\t\t/*\n\t\t * We perform a case sensitive comparison and if that matches\n\t\t * we are done and return the mft reference of the inode (i.e.\n\t\t * the inode number together with the sequence number for\n\t\t * consistency checking). We convert it to cpu format before\n\t\t * returning.\n\t\t */\n\t\tif (ntfs_are_names_equal(uname, uname_len,\n\t\t\t\t(ntfschar*)&ie->key.file_name.file_name,\n\t\t\t\tie->key.file_name.file_name_length,\n\t\t\t\tCASE_SENSITIVE, vol->upcase, vol->upcase_len)) {\nfound_it:\n\t\t\t/*\n\t\t\t * We have a perfect match, so we don't need to care\n\t\t\t * about having matched imperfectly before, so we can\n\t\t\t * free name and set *res to NULL.\n\t\t\t * However, if the perfect match is a short file name,\n\t\t\t * we need to signal this through *res, so that\n\t\t\t * ntfs_lookup() can fix dcache aliasing issues.\n\t\t\t * As an optimization we just reuse an existing\n\t\t\t * allocation of *res.\n\t\t\t */\n\t\t\tif (ie->key.file_name.file_name_type == FILE_NAME_DOS) {\n\t\t\t\tif (!name) {\n\t\t\t\t\tname = kmalloc(sizeof(ntfs_name),\n\t\t\t\t\t\t\tGFP_NOFS);\n\t\t\t\t\tif (!name) {\n\t\t\t\t\t\terr = -ENOMEM;\n\t\t\t\t\t\tgoto err_out;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tname->mref = le64_to_cpu(\n\t\t\t\t\t\tie->data.dir.indexed_file);\n\t\t\t\tname->type = FILE_NAME_DOS;\n\t\t\t\tname->len = 0;\n\t\t\t\t*res = name;\n\t\t\t} else {\n\t\t\t\tkfree(name);\n\t\t\t\t*res = NULL;\n\t\t\t}\n\t\t\tmref = le64_to_cpu(ie->data.dir.indexed_file);\n\t\t\tntfs_attr_put_search_ctx(ctx);\n\t\t\tunmap_mft_record(dir_ni);\n\t\t\treturn mref;\n\t\t}\n\t\t/*\n\t\t * For a case insensitive mount, we also perform a case\n\t\t * insensitive comparison (provided the file name is not in the\n\t\t * POSIX namespace). If the comparison matches, and the name is\n\t\t * in the WIN32 namespace, we cache the filename in *res so\n\t\t * that the caller, ntfs_lookup(), can work on it. If the\n\t\t * comparison matches, and the name is in the DOS namespace, we\n\t\t * only cache the mft reference and the file name type (we set\n\t\t * the name length to zero for simplicity).\n\t\t */\n\t\tif (!NVolCaseSensitive(vol) &&\n\t\t\t\tie->key.file_name.file_name_type &&\n\t\t\t\tntfs_are_names_equal(uname, uname_len,\n\t\t\t\t(ntfschar*)&ie->key.file_name.file_name,\n\t\t\t\tie->key.file_name.file_name_length,\n\t\t\t\tIGNORE_CASE, vol->upcase, vol->upcase_len)) {\n\t\t\tint name_size = sizeof(ntfs_name);\n\t\t\tu8 type = ie->key.file_name.file_name_type;\n\t\t\tu8 len = ie->key.file_name.file_name_length;\n\n\t\t\t/* Only one case insensitive matching name allowed. */\n\t\t\tif (name) {\n\t\t\t\tntfs_error(sb, \"Found already allocated name \"\n\t\t\t\t\t\t\"in phase 1. Please run chkdsk \"\n\t\t\t\t\t\t\"and if that doesn't find any \"\n\t\t\t\t\t\t\"errors please report you saw \"\n\t\t\t\t\t\t\"this message to \"\n\t\t\t\t\t\t\"linux-ntfs-dev@lists.\"\n\t\t\t\t\t\t\"sourceforge.net.\");\n\t\t\t\tgoto dir_err_out;\n\t\t\t}\n\n\t\t\tif (type != FILE_NAME_DOS)\n\t\t\t\tname_size += len * sizeof(ntfschar);\n\t\t\tname = kmalloc(name_size, GFP_NOFS);\n\t\t\tif (!name) {\n\t\t\t\terr = -ENOMEM;\n\t\t\t\tgoto err_out;\n\t\t\t}\n\t\t\tname->mref = le64_to_cpu(ie->data.dir.indexed_file);\n\t\t\tname->type = type;\n\t\t\tif (type != FILE_NAME_DOS) {\n\t\t\t\tname->len = len;\n\t\t\t\tmemcpy(name->name, ie->key.file_name.file_name,\n\t\t\t\t\t\tlen * sizeof(ntfschar));\n\t\t\t} else\n\t\t\t\tname->len = 0;\n\t\t\t*res = name;\n\t\t}\n\t\t/*\n\t\t * Not a perfect match, need to do full blown collation so we\n\t\t * know which way in the B+tree we have to go.\n\t\t */\n\t\trc = ntfs_collate_names(uname, uname_len,\n\t\t\t\t(ntfschar*)&ie->key.file_name.file_name,\n\t\t\t\tie->key.file_name.file_name_length, 1,\n\t\t\t\tIGNORE_CASE, vol->upcase, vol->upcase_len);\n\t\t/*\n\t\t * If uname collates before the name of the current entry, there\n\t\t * is definitely no such name in this index but we might need to\n\t\t * descend into the B+tree so we just break out of the loop.\n\t\t */\n\t\tif (rc == -1)\n\t\t\tbreak;\n\t\t/* The names are not equal, continue the search. */\n\t\tif (rc)\n\t\t\tcontinue;\n\t\t/*\n\t\t * Names match with case insensitive comparison, now try the\n\t\t * case sensitive comparison, which is required for proper\n\t\t * collation.\n\t\t */\n\t\trc = ntfs_collate_names(uname, uname_len,\n\t\t\t\t(ntfschar*)&ie->key.file_name.file_name,\n\t\t\t\tie->key.file_name.file_name_length, 1,\n\t\t\t\tCASE_SENSITIVE, vol->upcase, vol->upcase_len);\n\t\tif (rc == -1)\n\t\t\tbreak;\n\t\tif (rc)\n\t\t\tcontinue;\n\t\t/*\n\t\t * Perfect match, this will never happen as the\n\t\t * ntfs_are_names_equal() call will have gotten a match but we\n\t\t * still treat it correctly.\n\t\t */\n\t\tgoto found_it;\n\t}\n\t/*\n\t * We have finished with this index without success. Check for the\n\t * presence of a child node and if not present return -ENOENT, unless\n\t * we have got a matching name cached in name in which case return the\n\t * mft reference associated with it.\n\t */\n\tif (!(ie->flags & INDEX_ENTRY_NODE)) {\n\t\tif (name) {\n\t\t\tntfs_attr_put_search_ctx(ctx);\n\t\t\tunmap_mft_record(dir_ni);\n\t\t\treturn name->mref;\n\t\t}\n\t\tntfs_debug(\"Entry not found.\");\n\t\terr = -ENOENT;\n\t\tgoto err_out;\n\t} /* Child node present, descend into it. */\n\t/* Consistency check: Verify that an index allocation exists. */\n\tif (!NInoIndexAllocPresent(dir_ni)) {\n\t\tntfs_error(sb, \"No index allocation attribute but index entry \"\n\t\t\t\t\"requires one. Directory inode 0x%lx is \"\n\t\t\t\t\"corrupt or driver bug.\", dir_ni->mft_no);\n\t\tgoto err_out;\n\t}\n\t/* Get the starting vcn of the index_block holding the child node. */\n\tvcn = sle64_to_cpup((sle64*)((u8*)ie + le16_to_cpu(ie->length) - 8));\n\tia_mapping = VFS_I(dir_ni)->i_mapping;\n\t/*\n\t * We are done with the index root and the mft record. Release them,\n\t * otherwise we deadlock with ntfs_map_page().\n\t */\n\tntfs_attr_put_search_ctx(ctx);\n\tunmap_mft_record(dir_ni);\n\tm = NULL;\n\tctx = NULL;\ndescend_into_child_node:\n\t/*\n\t * Convert vcn to index into the index allocation attribute in units\n\t * of PAGE_CACHE_SIZE and map the page cache page, reading it from\n\t * disk if necessary.\n\t */\n\tpage = ntfs_map_page(ia_mapping, vcn <<\n\t\t\tdir_ni->itype.index.vcn_size_bits >> PAGE_CACHE_SHIFT);\n\tif (IS_ERR(page)) {\n\t\tntfs_error(sb, \"Failed to map directory index page, error %ld.\",\n\t\t\t\t-PTR_ERR(page));\n\t\terr = PTR_ERR(page);\n\t\tgoto err_out;\n\t}\n\tlock_page(page);\n\tkaddr = (u8*)page_address(page);\nfast_descend_into_child_node:\n\t/* Get to the index allocation block. */\n\tia = (INDEX_ALLOCATION*)(kaddr + ((vcn <<\n\t\t\tdir_ni->itype.index.vcn_size_bits) & ~PAGE_CACHE_MASK));\n\t/* Bounds checks. */\n\tif ((u8*)ia < kaddr || (u8*)ia > kaddr + PAGE_CACHE_SIZE) {\n\t\tntfs_error(sb, \"Out of bounds check failed. Corrupt directory \"\n\t\t\t\t\"inode 0x%lx or driver bug.\", dir_ni->mft_no);\n\t\tgoto unm_err_out;\n\t}\n\t/* Catch multi sector transfer fixup errors. */\n\tif (unlikely(!ntfs_is_indx_record(ia->magic))) {\n\t\tntfs_error(sb, \"Directory index record with vcn 0x%llx is \"\n\t\t\t\t\"corrupt.  Corrupt inode 0x%lx.  Run chkdsk.\",\n\t\t\t\t(unsigned long long)vcn, dir_ni->mft_no);\n\t\tgoto unm_err_out;\n\t}\n\tif (sle64_to_cpu(ia->index_block_vcn) != vcn) {\n\t\tntfs_error(sb, \"Actual VCN (0x%llx) of index buffer is \"\n\t\t\t\t\"different from expected VCN (0x%llx). \"\n\t\t\t\t\"Directory inode 0x%lx is corrupt or driver \"\n\t\t\t\t\"bug.\", (unsigned long long)\n\t\t\t\tsle64_to_cpu(ia->index_block_vcn),\n\t\t\t\t(unsigned long long)vcn, dir_ni->mft_no);\n\t\tgoto unm_err_out;\n\t}\n\tif (le32_to_cpu(ia->index.allocated_size) + 0x18 !=\n\t\t\tdir_ni->itype.index.block_size) {\n\t\tntfs_error(sb, \"Index buffer (VCN 0x%llx) of directory inode \"\n\t\t\t\t\"0x%lx has a size (%u) differing from the \"\n\t\t\t\t\"directory specified size (%u). Directory \"\n\t\t\t\t\"inode is corrupt or driver bug.\",\n\t\t\t\t(unsigned long long)vcn, dir_ni->mft_no,\n\t\t\t\tle32_to_cpu(ia->index.allocated_size) + 0x18,\n\t\t\t\tdir_ni->itype.index.block_size);\n\t\tgoto unm_err_out;\n\t}\n\tindex_end = (u8*)ia + dir_ni->itype.index.block_size;\n\tif (index_end > kaddr + PAGE_CACHE_SIZE) {\n\t\tntfs_error(sb, \"Index buffer (VCN 0x%llx) of directory inode \"\n\t\t\t\t\"0x%lx crosses page boundary. Impossible! \"\n\t\t\t\t\"Cannot access! This is probably a bug in the \"\n\t\t\t\t\"driver.\", (unsigned long long)vcn,\n\t\t\t\tdir_ni->mft_no);\n\t\tgoto unm_err_out;\n\t}\n\tindex_end = (u8*)&ia->index + le32_to_cpu(ia->index.index_length);\n\tif (index_end > (u8*)ia + dir_ni->itype.index.block_size) {\n\t\tntfs_error(sb, \"Size of index buffer (VCN 0x%llx) of directory \"\n\t\t\t\t\"inode 0x%lx exceeds maximum size.\",\n\t\t\t\t(unsigned long long)vcn, dir_ni->mft_no);\n\t\tgoto unm_err_out;\n\t}\n\t/* The first index entry. */\n\tie = (INDEX_ENTRY*)((u8*)&ia->index +\n\t\t\tle32_to_cpu(ia->index.entries_offset));\n\t/*\n\t * Iterate similar to above big loop but applied to index buffer, thus\n\t * loop until we exceed valid memory (corruption case) or until we\n\t * reach the last entry.\n\t */\n\tfor (;; ie = (INDEX_ENTRY*)((u8*)ie + le16_to_cpu(ie->length))) {\n\t\t/* Bounds check. */\n\t\tif ((u8*)ie < (u8*)ia || (u8*)ie +\n\t\t\t\tsizeof(INDEX_ENTRY_HEADER) > index_end ||\n\t\t\t\t(u8*)ie + le16_to_cpu(ie->key_length) >\n\t\t\t\tindex_end) {\n\t\t\tntfs_error(sb, \"Index entry out of bounds in \"\n\t\t\t\t\t\"directory inode 0x%lx.\",\n\t\t\t\t\tdir_ni->mft_no);\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\t/*\n\t\t * The last entry cannot contain a name. It can however contain\n\t\t * a pointer to a child node in the B+tree so we just break out.\n\t\t */\n\t\tif (ie->flags & INDEX_ENTRY_END)\n\t\t\tbreak;\n\t\t/*\n\t\t * We perform a case sensitive comparison and if that matches\n\t\t * we are done and return the mft reference of the inode (i.e.\n\t\t * the inode number together with the sequence number for\n\t\t * consistency checking). We convert it to cpu format before\n\t\t * returning.\n\t\t */\n\t\tif (ntfs_are_names_equal(uname, uname_len,\n\t\t\t\t(ntfschar*)&ie->key.file_name.file_name,\n\t\t\t\tie->key.file_name.file_name_length,\n\t\t\t\tCASE_SENSITIVE, vol->upcase, vol->upcase_len)) {\nfound_it2:\n\t\t\t/*\n\t\t\t * We have a perfect match, so we don't need to care\n\t\t\t * about having matched imperfectly before, so we can\n\t\t\t * free name and set *res to NULL.\n\t\t\t * However, if the perfect match is a short file name,\n\t\t\t * we need to signal this through *res, so that\n\t\t\t * ntfs_lookup() can fix dcache aliasing issues.\n\t\t\t * As an optimization we just reuse an existing\n\t\t\t * allocation of *res.\n\t\t\t */\n\t\t\tif (ie->key.file_name.file_name_type == FILE_NAME_DOS) {\n\t\t\t\tif (!name) {\n\t\t\t\t\tname = kmalloc(sizeof(ntfs_name),\n\t\t\t\t\t\t\tGFP_NOFS);\n\t\t\t\t\tif (!name) {\n\t\t\t\t\t\terr = -ENOMEM;\n\t\t\t\t\t\tgoto unm_err_out;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tname->mref = le64_to_cpu(\n\t\t\t\t\t\tie->data.dir.indexed_file);\n\t\t\t\tname->type = FILE_NAME_DOS;\n\t\t\t\tname->len = 0;\n\t\t\t\t*res = name;\n\t\t\t} else {\n\t\t\t\tkfree(name);\n\t\t\t\t*res = NULL;\n\t\t\t}\n\t\t\tmref = le64_to_cpu(ie->data.dir.indexed_file);\n\t\t\tunlock_page(page);\n\t\t\tntfs_unmap_page(page);\n\t\t\treturn mref;\n\t\t}\n\t\t/*\n\t\t * For a case insensitive mount, we also perform a case\n\t\t * insensitive comparison (provided the file name is not in the\n\t\t * POSIX namespace). If the comparison matches, and the name is\n\t\t * in the WIN32 namespace, we cache the filename in *res so\n\t\t * that the caller, ntfs_lookup(), can work on it. If the\n\t\t * comparison matches, and the name is in the DOS namespace, we\n\t\t * only cache the mft reference and the file name type (we set\n\t\t * the name length to zero for simplicity).\n\t\t */\n\t\tif (!NVolCaseSensitive(vol) &&\n\t\t\t\tie->key.file_name.file_name_type &&\n\t\t\t\tntfs_are_names_equal(uname, uname_len,\n\t\t\t\t(ntfschar*)&ie->key.file_name.file_name,\n\t\t\t\tie->key.file_name.file_name_length,\n\t\t\t\tIGNORE_CASE, vol->upcase, vol->upcase_len)) {\n\t\t\tint name_size = sizeof(ntfs_name);\n\t\t\tu8 type = ie->key.file_name.file_name_type;\n\t\t\tu8 len = ie->key.file_name.file_name_length;\n\n\t\t\t/* Only one case insensitive matching name allowed. */\n\t\t\tif (name) {\n\t\t\t\tntfs_error(sb, \"Found already allocated name \"\n\t\t\t\t\t\t\"in phase 2. Please run chkdsk \"\n\t\t\t\t\t\t\"and if that doesn't find any \"\n\t\t\t\t\t\t\"errors please report you saw \"\n\t\t\t\t\t\t\"this message to \"\n\t\t\t\t\t\t\"linux-ntfs-dev@lists.\"\n\t\t\t\t\t\t\"sourceforge.net.\");\n\t\t\t\tunlock_page(page);\n\t\t\t\tntfs_unmap_page(page);\n\t\t\t\tgoto dir_err_out;\n\t\t\t}\n\n\t\t\tif (type != FILE_NAME_DOS)\n\t\t\t\tname_size += len * sizeof(ntfschar);\n\t\t\tname = kmalloc(name_size, GFP_NOFS);\n\t\t\tif (!name) {\n\t\t\t\terr = -ENOMEM;\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t\tname->mref = le64_to_cpu(ie->data.dir.indexed_file);\n\t\t\tname->type = type;\n\t\t\tif (type != FILE_NAME_DOS) {\n\t\t\t\tname->len = len;\n\t\t\t\tmemcpy(name->name, ie->key.file_name.file_name,\n\t\t\t\t\t\tlen * sizeof(ntfschar));\n\t\t\t} else\n\t\t\t\tname->len = 0;\n\t\t\t*res = name;\n\t\t}\n\t\t/*\n\t\t * Not a perfect match, need to do full blown collation so we\n\t\t * know which way in the B+tree we have to go.\n\t\t */\n\t\trc = ntfs_collate_names(uname, uname_len,\n\t\t\t\t(ntfschar*)&ie->key.file_name.file_name,\n\t\t\t\tie->key.file_name.file_name_length, 1,\n\t\t\t\tIGNORE_CASE, vol->upcase, vol->upcase_len);\n\t\t/*\n\t\t * If uname collates before the name of the current entry, there\n\t\t * is definitely no such name in this index but we might need to\n\t\t * descend into the B+tree so we just break out of the loop.\n\t\t */\n\t\tif (rc == -1)\n\t\t\tbreak;\n\t\t/* The names are not equal, continue the search. */\n\t\tif (rc)\n\t\t\tcontinue;\n\t\t/*\n\t\t * Names match with case insensitive comparison, now try the\n\t\t * case sensitive comparison, which is required for proper\n\t\t * collation.\n\t\t */\n\t\trc = ntfs_collate_names(uname, uname_len,\n\t\t\t\t(ntfschar*)&ie->key.file_name.file_name,\n\t\t\t\tie->key.file_name.file_name_length, 1,\n\t\t\t\tCASE_SENSITIVE, vol->upcase, vol->upcase_len);\n\t\tif (rc == -1)\n\t\t\tbreak;\n\t\tif (rc)\n\t\t\tcontinue;\n\t\t/*\n\t\t * Perfect match, this will never happen as the\n\t\t * ntfs_are_names_equal() call will have gotten a match but we\n\t\t * still treat it correctly.\n\t\t */\n\t\tgoto found_it2;\n\t}\n\t/*\n\t * We have finished with this index buffer without success. Check for\n\t * the presence of a child node.\n\t */\n\tif (ie->flags & INDEX_ENTRY_NODE) {\n\t\tif ((ia->index.flags & NODE_MASK) == LEAF_NODE) {\n\t\t\tntfs_error(sb, \"Index entry with child node found in \"\n\t\t\t\t\t\"a leaf node in directory inode 0x%lx.\",\n\t\t\t\t\tdir_ni->mft_no);\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\t/* Child node present, descend into it. */\n\t\told_vcn = vcn;\n\t\tvcn = sle64_to_cpup((sle64*)((u8*)ie +\n\t\t\t\tle16_to_cpu(ie->length) - 8));\n\t\tif (vcn >= 0) {\n\t\t\t/* If vcn is in the same page cache page as old_vcn we\n\t\t\t * recycle the mapped page. */\n\t\t\tif (old_vcn << vol->cluster_size_bits >>\n\t\t\t\t\tPAGE_CACHE_SHIFT == vcn <<\n\t\t\t\t\tvol->cluster_size_bits >>\n\t\t\t\t\tPAGE_CACHE_SHIFT)\n\t\t\t\tgoto fast_descend_into_child_node;\n\t\t\tunlock_page(page);\n\t\t\tntfs_unmap_page(page);\n\t\t\tgoto descend_into_child_node;\n\t\t}\n\t\tntfs_error(sb, \"Negative child node vcn in directory inode \"\n\t\t\t\t\"0x%lx.\", dir_ni->mft_no);\n\t\tgoto unm_err_out;\n\t}\n\t/*\n\t * No child node present, return -ENOENT, unless we have got a matching\n\t * name cached in name in which case return the mft reference\n\t * associated with it.\n\t */\n\tif (name) {\n\t\tunlock_page(page);\n\t\tntfs_unmap_page(page);\n\t\treturn name->mref;\n\t}\n\tntfs_debug(\"Entry not found.\");\n\terr = -ENOENT;\nunm_err_out:\n\tunlock_page(page);\n\tntfs_unmap_page(page);\nerr_out:\n\tif (!err)\n\t\terr = -EIO;\n\tif (ctx)\n\t\tntfs_attr_put_search_ctx(ctx);\n\tif (m)\n\t\tunmap_mft_record(dir_ni);\n\tif (name) {\n\t\tkfree(name);\n\t\t*res = NULL;\n\t}\n\treturn ERR_MREF(err);\ndir_err_out:\n\tntfs_error(sb, \"Corrupt directory.  Aborting lookup.\");\n\tgoto err_out;\n}"
        }
      },
      {
        "call_info": {
          "callee": "NTFS_I",
          "args": [
            "vol->root_ino"
          ],
          "line": 1288
        },
        "resolved": true,
        "details": {
          "function_name": "NTFS_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/inode.h",
          "lines": "240-243",
          "snippet": "static inline ntfs_inode *NTFS_I(struct inode *inode)\n{\n\treturn (ntfs_inode *)list_entry(inode, big_ntfs_inode, vfs_inode);\n}",
          "includes": [
            "#include \"debug.h\"",
            "#include \"runlist.h\"",
            "#include \"types.h\"",
            "#include \"volume.h\"",
            "#include \"layout.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/mutex.h>",
            "#include <linux/mm.h>",
            "#include <linux/list.h>",
            "#include <linux/fs.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"debug.h\"\n#include \"runlist.h\"\n#include \"types.h\"\n#include \"volume.h\"\n#include \"layout.h\"\n#include <linux/seq_file.h>\n#include <linux/mutex.h>\n#include <linux/mm.h>\n#include <linux/list.h>\n#include <linux/fs.h>\n#include <linux/atomic.h>\n\nstatic inline ntfs_inode *NTFS_I(struct inode *inode)\n{\n\treturn (ntfs_inode *)list_entry(inode, big_ntfs_inode, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&vol->root_ino->i_mutex"
          ],
          "line": 1287
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "'s'"
          ],
          "line": 1280
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "'y'"
          ],
          "line": 1279
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "'s'"
          ],
          "line": 1279
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "'.'"
          ],
          "line": 1278
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "'l'"
          ],
          "line": 1278
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "'i'"
          ],
          "line": 1277
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "'f'"
          ],
          "line": 1277
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "'r'"
          ],
          "line": 1276
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "'e'"
          ],
          "line": 1276
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "'b'"
          ],
          "line": 1275
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "'i'"
          ],
          "line": 1275
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "'h'"
          ],
          "line": 1274
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ntfs.h\"\n#include \"malloc.h\"\n#include \"layout.h\"\n#include \"aops.h\"\n#include \"inode.h\"\n#include \"index.h\"\n#include \"debug.h\"\n#include \"dir.h\"\n#include \"usnjrnl.h\"\n#include \"quota.h\"\n#include \"logfile.h\"\n#include \"sysctl.h\"\n#include <linux/bitmap.h>\n#include <linux/moduleparam.h>\n#include <linux/vfs.h>\n#include <linux/buffer_head.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\t/* For bdev_logical_block_size(). */\n#include <linux/spinlock.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/stddef.h>\n\n#define NTFS_HIBERFIL_HEADER_SIZE\t4096\n\nstatic int check_windows_hibernation_status(ntfs_volume *vol)\n{\n\tMFT_REF mref;\n\tstruct inode *vi;\n\tstruct page *page;\n\tu32 *kaddr, *kend;\n\tntfs_name *name = NULL;\n\tint ret = 1;\n\tstatic const ntfschar hiberfil[13] = { cpu_to_le16('h'),\n\t\t\tcpu_to_le16('i'), cpu_to_le16('b'),\n\t\t\tcpu_to_le16('e'), cpu_to_le16('r'),\n\t\t\tcpu_to_le16('f'), cpu_to_le16('i'),\n\t\t\tcpu_to_le16('l'), cpu_to_le16('.'),\n\t\t\tcpu_to_le16('s'), cpu_to_le16('y'),\n\t\t\tcpu_to_le16('s'), 0 };\n\n\tntfs_debug(\"Entering.\");\n\t/*\n\t * Find the inode number for the hibernation file by looking up the\n\t * filename hiberfil.sys in the root directory.\n\t */\n\tmutex_lock(&vol->root_ino->i_mutex);\n\tmref = ntfs_lookup_inode_by_name(NTFS_I(vol->root_ino), hiberfil, 12,\n\t\t\t&name);\n\tmutex_unlock(&vol->root_ino->i_mutex);\n\tif (IS_ERR_MREF(mref)) {\n\t\tret = MREF_ERR(mref);\n\t\t/* If the file does not exist, Windows is not hibernated. */\n\t\tif (ret == -ENOENT) {\n\t\t\tntfs_debug(\"hiberfil.sys not present.  Windows is not \"\n\t\t\t\t\t\"hibernated on the volume.\");\n\t\t\treturn 0;\n\t\t}\n\t\t/* A real error occurred. */\n\t\tntfs_error(vol->sb, \"Failed to find inode number for \"\n\t\t\t\t\"hiberfil.sys.\");\n\t\treturn ret;\n\t}\n\t/* We do not care for the type of match that was found. */\n\tkfree(name);\n\t/* Get the inode. */\n\tvi = ntfs_iget(vol->sb, MREF(mref));\n\tif (IS_ERR(vi) || is_bad_inode(vi)) {\n\t\tif (!IS_ERR(vi))\n\t\t\tiput(vi);\n\t\tntfs_error(vol->sb, \"Failed to load hiberfil.sys.\");\n\t\treturn IS_ERR(vi) ? PTR_ERR(vi) : -EIO;\n\t}\n\tif (unlikely(i_size_read(vi) < NTFS_HIBERFIL_HEADER_SIZE)) {\n\t\tntfs_debug(\"hiberfil.sys is smaller than 4kiB (0x%llx).  \"\n\t\t\t\t\"Windows is hibernated on the volume.  This \"\n\t\t\t\t\"is not the system volume.\", i_size_read(vi));\n\t\tgoto iput_out;\n\t}\n\tpage = ntfs_map_page(vi->i_mapping, 0);\n\tif (IS_ERR(page)) {\n\t\tntfs_error(vol->sb, \"Failed to read from hiberfil.sys.\");\n\t\tret = PTR_ERR(page);\n\t\tgoto iput_out;\n\t}\n\tkaddr = (u32*)page_address(page);\n\tif (*(le32*)kaddr == cpu_to_le32(0x72626968)/*'hibr'*/) {\n\t\tntfs_debug(\"Magic \\\"hibr\\\" found in hiberfil.sys.  Windows is \"\n\t\t\t\t\"hibernated on the volume.  This is the \"\n\t\t\t\t\"system volume.\");\n\t\tgoto unm_iput_out;\n\t}\n\tkend = kaddr + NTFS_HIBERFIL_HEADER_SIZE/sizeof(*kaddr);\n\tdo {\n\t\tif (unlikely(*kaddr)) {\n\t\t\tntfs_debug(\"hiberfil.sys is larger than 4kiB \"\n\t\t\t\t\t\"(0x%llx), does not contain the \"\n\t\t\t\t\t\"\\\"hibr\\\" magic, and does not have a \"\n\t\t\t\t\t\"zero header.  Windows is hibernated \"\n\t\t\t\t\t\"on the volume.  This is not the \"\n\t\t\t\t\t\"system volume.\", i_size_read(vi));\n\t\t\tgoto unm_iput_out;\n\t\t}\n\t} while (++kaddr < kend);\n\tntfs_debug(\"hiberfil.sys contains a zero header.  Windows is not \"\n\t\t\t\"hibernated on the volume.  This is the system \"\n\t\t\t\"volume.\");\n\tret = 0;\nunm_iput_out:\n\tntfs_unmap_page(page);\niput_out:\n\tiput(vi);\n\treturn ret;\n}"
  },
  {
    "function_name": "load_and_check_logfile",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/super.c",
    "lines": "1216-1238",
    "snippet": "static bool load_and_check_logfile(ntfs_volume *vol,\n\t\tRESTART_PAGE_HEADER **rp)\n{\n\tstruct inode *tmp_ino;\n\n\tntfs_debug(\"Entering.\");\n\ttmp_ino = ntfs_iget(vol->sb, FILE_LogFile);\n\tif (IS_ERR(tmp_ino) || is_bad_inode(tmp_ino)) {\n\t\tif (!IS_ERR(tmp_ino))\n\t\t\tiput(tmp_ino);\n\t\t/* Caller will display error message. */\n\t\treturn false;\n\t}\n\tif (!ntfs_check_logfile(tmp_ino, rp)) {\n\t\tiput(tmp_ino);\n\t\t/* ntfs_check_logfile() will have displayed error output. */\n\t\treturn false;\n\t}\n\tNInoSetSparseDisabled(NTFS_I(tmp_ino));\n\tvol->logfile_ino = tmp_ino;\n\tntfs_debug(\"Done.\");\n\treturn true;\n}",
    "includes": [
      "#include \"ntfs.h\"",
      "#include \"malloc.h\"",
      "#include \"layout.h\"",
      "#include \"aops.h\"",
      "#include \"inode.h\"",
      "#include \"index.h\"",
      "#include \"debug.h\"",
      "#include \"dir.h\"",
      "#include \"usnjrnl.h\"",
      "#include \"quota.h\"",
      "#include \"logfile.h\"",
      "#include \"sysctl.h\"",
      "#include <linux/bitmap.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/vfs.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/blkdev.h>\t/* For bdev_logical_block_size(). */",
      "#include <linux/spinlock.h>",
      "#include <linux/string.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/stddef.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ntfs_debug",
          "args": [
            "\"Done.\""
          ],
          "line": 1236
        },
        "resolved": true,
        "details": {
          "function_name": "ntfs_debug_dump_runlist",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/debug.c",
          "lines": "134-171",
          "snippet": "void ntfs_debug_dump_runlist(const runlist_element *rl)\n{\n\tint i;\n\tconst char *lcn_str[5] = { \"LCN_HOLE         \", \"LCN_RL_NOT_MAPPED\",\n\t\t\t\t   \"LCN_ENOENT       \", \"LCN_unknown      \" };\n\n\tif (!debug_msgs)\n\t\treturn;\n\tpr_debug(\"Dumping runlist (values in hex):\\n\");\n\tif (!rl) {\n\t\tpr_debug(\"Run list not present.\\n\");\n\t\treturn;\n\t}\n\tpr_debug(\"VCN              LCN               Run length\\n\");\n\tfor (i = 0; ; i++) {\n\t\tLCN lcn = (rl + i)->lcn;\n\n\t\tif (lcn < (LCN)0) {\n\t\t\tint index = -lcn - 1;\n\n\t\t\tif (index > -LCN_ENOENT - 1)\n\t\t\t\tindex = 3;\n\t\t\tpr_debug(\"%-16Lx %s %-16Lx%s\\n\",\n\t\t\t\t\t(long long)(rl + i)->vcn, lcn_str[index],\n\t\t\t\t\t(long long)(rl + i)->length,\n\t\t\t\t\t(rl + i)->length ? \"\" :\n\t\t\t\t\t\t\" (runlist end)\");\n\t\t} else\n\t\t\tpr_debug(\"%-16Lx %-16Lx  %-16Lx%s\\n\",\n\t\t\t\t\t(long long)(rl + i)->vcn,\n\t\t\t\t\t(long long)(rl + i)->lcn,\n\t\t\t\t\t(long long)(rl + i)->length,\n\t\t\t\t\t(rl + i)->length ? \"\" :\n\t\t\t\t\t\t\" (runlist end)\");\n\t\tif (!(rl + i)->length)\n\t\t\tbreak;\n\t}\n}",
          "includes": [
            "#include \"debug.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"debug.h\"\n\nvoid ntfs_debug_dump_runlist(const runlist_element *rl)\n{\n\tint i;\n\tconst char *lcn_str[5] = { \"LCN_HOLE         \", \"LCN_RL_NOT_MAPPED\",\n\t\t\t\t   \"LCN_ENOENT       \", \"LCN_unknown      \" };\n\n\tif (!debug_msgs)\n\t\treturn;\n\tpr_debug(\"Dumping runlist (values in hex):\\n\");\n\tif (!rl) {\n\t\tpr_debug(\"Run list not present.\\n\");\n\t\treturn;\n\t}\n\tpr_debug(\"VCN              LCN               Run length\\n\");\n\tfor (i = 0; ; i++) {\n\t\tLCN lcn = (rl + i)->lcn;\n\n\t\tif (lcn < (LCN)0) {\n\t\t\tint index = -lcn - 1;\n\n\t\t\tif (index > -LCN_ENOENT - 1)\n\t\t\t\tindex = 3;\n\t\t\tpr_debug(\"%-16Lx %s %-16Lx%s\\n\",\n\t\t\t\t\t(long long)(rl + i)->vcn, lcn_str[index],\n\t\t\t\t\t(long long)(rl + i)->length,\n\t\t\t\t\t(rl + i)->length ? \"\" :\n\t\t\t\t\t\t\" (runlist end)\");\n\t\t} else\n\t\t\tpr_debug(\"%-16Lx %-16Lx  %-16Lx%s\\n\",\n\t\t\t\t\t(long long)(rl + i)->vcn,\n\t\t\t\t\t(long long)(rl + i)->lcn,\n\t\t\t\t\t(long long)(rl + i)->length,\n\t\t\t\t\t(rl + i)->length ? \"\" :\n\t\t\t\t\t\t\" (runlist end)\");\n\t\tif (!(rl + i)->length)\n\t\t\tbreak;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "NInoSetSparseDisabled",
          "args": [
            "NTFS_I(tmp_ino)"
          ],
          "line": 1234
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NTFS_I",
          "args": [
            "tmp_ino"
          ],
          "line": 1234
        },
        "resolved": true,
        "details": {
          "function_name": "NTFS_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/inode.h",
          "lines": "240-243",
          "snippet": "static inline ntfs_inode *NTFS_I(struct inode *inode)\n{\n\treturn (ntfs_inode *)list_entry(inode, big_ntfs_inode, vfs_inode);\n}",
          "includes": [
            "#include \"debug.h\"",
            "#include \"runlist.h\"",
            "#include \"types.h\"",
            "#include \"volume.h\"",
            "#include \"layout.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/mutex.h>",
            "#include <linux/mm.h>",
            "#include <linux/list.h>",
            "#include <linux/fs.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"debug.h\"\n#include \"runlist.h\"\n#include \"types.h\"\n#include \"volume.h\"\n#include \"layout.h\"\n#include <linux/seq_file.h>\n#include <linux/mutex.h>\n#include <linux/mm.h>\n#include <linux/list.h>\n#include <linux/fs.h>\n#include <linux/atomic.h>\n\nstatic inline ntfs_inode *NTFS_I(struct inode *inode)\n{\n\treturn (ntfs_inode *)list_entry(inode, big_ntfs_inode, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "iput",
          "args": [
            "tmp_ino"
          ],
          "line": 1230
        },
        "resolved": true,
        "details": {
          "function_name": "dentry_iput",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "308-327",
          "snippet": "static void dentry_iput(struct dentry * dentry)\n\t__releases(dentry->d_lock)\n\t__releases(dentry->d_inode->i_lock)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tif (inode) {\n\t\tdentry->d_inode = NULL;\n\t\thlist_del_init(&dentry->d_u.d_alias);\n\t\tspin_unlock(&dentry->d_lock);\n\t\tspin_unlock(&inode->i_lock);\n\t\tif (!inode->i_nlink)\n\t\t\tfsnotify_inoderemove(inode);\n\t\tif (dentry->d_op && dentry->d_op->d_iput)\n\t\t\tdentry->d_op->d_iput(dentry, inode);\n\t\telse\n\t\t\tiput(inode);\n\t} else {\n\t\tspin_unlock(&dentry->d_lock);\n\t}\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nstatic void dentry_iput(struct dentry * dentry)\n\t__releases(dentry->d_lock)\n\t__releases(dentry->d_inode->i_lock)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tif (inode) {\n\t\tdentry->d_inode = NULL;\n\t\thlist_del_init(&dentry->d_u.d_alias);\n\t\tspin_unlock(&dentry->d_lock);\n\t\tspin_unlock(&inode->i_lock);\n\t\tif (!inode->i_nlink)\n\t\t\tfsnotify_inoderemove(inode);\n\t\tif (dentry->d_op && dentry->d_op->d_iput)\n\t\t\tdentry->d_op->d_iput(dentry, inode);\n\t\telse\n\t\t\tiput(inode);\n\t} else {\n\t\tspin_unlock(&dentry->d_lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ntfs_check_logfile",
          "args": [
            "tmp_ino",
            "rp"
          ],
          "line": 1229
        },
        "resolved": true,
        "details": {
          "function_name": "ntfs_check_logfile",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/logfile.c",
          "lines": "484-657",
          "snippet": "bool ntfs_check_logfile(struct inode *log_vi, RESTART_PAGE_HEADER **rp)\n{\n\ts64 size, pos;\n\tLSN rstr1_lsn, rstr2_lsn;\n\tntfs_volume *vol = NTFS_SB(log_vi->i_sb);\n\tstruct address_space *mapping = log_vi->i_mapping;\n\tstruct page *page = NULL;\n\tu8 *kaddr = NULL;\n\tRESTART_PAGE_HEADER *rstr1_ph = NULL;\n\tRESTART_PAGE_HEADER *rstr2_ph = NULL;\n\tint log_page_size, log_page_mask, err;\n\tbool logfile_is_empty = true;\n\tu8 log_page_bits;\n\n\tntfs_debug(\"Entering.\");\n\t/* An empty $LogFile must have been clean before it got emptied. */\n\tif (NVolLogFileEmpty(vol))\n\t\tgoto is_empty;\n\tsize = i_size_read(log_vi);\n\t/* Make sure the file doesn't exceed the maximum allowed size. */\n\tif (size > MaxLogFileSize)\n\t\tsize = MaxLogFileSize;\n\t/*\n\t * Truncate size to a multiple of the page cache size or the default\n\t * log page size if the page cache size is between the default log page\n\t * log page size if the page cache size is between the default log page\n\t * size and twice that.\n\t */\n\tif (PAGE_CACHE_SIZE >= DefaultLogPageSize && PAGE_CACHE_SIZE <=\n\t\t\tDefaultLogPageSize * 2)\n\t\tlog_page_size = DefaultLogPageSize;\n\telse\n\t\tlog_page_size = PAGE_CACHE_SIZE;\n\tlog_page_mask = log_page_size - 1;\n\t/*\n\t * Use ntfs_ffs() instead of ffs() to enable the compiler to\n\t * optimize log_page_size and log_page_bits into constants.\n\t */\n\tlog_page_bits = ntfs_ffs(log_page_size) - 1;\n\tsize &= ~(s64)(log_page_size - 1);\n\t/*\n\t * Ensure the log file is big enough to store at least the two restart\n\t * pages and the minimum number of log record pages.\n\t */\n\tif (size < log_page_size * 2 || (size - log_page_size * 2) >>\n\t\t\tlog_page_bits < MinLogRecordPages) {\n\t\tntfs_error(vol->sb, \"$LogFile is too small.\");\n\t\treturn false;\n\t}\n\t/*\n\t * Read through the file looking for a restart page.  Since the restart\n\t * page header is at the beginning of a page we only need to search at\n\t * what could be the beginning of a page (for each page size) rather\n\t * than scanning the whole file byte by byte.  If all potential places\n\t * contain empty and uninitialzed records, the log file can be assumed\n\t * to be empty.\n\t */\n\tfor (pos = 0; pos < size; pos <<= 1) {\n\t\tpgoff_t idx = pos >> PAGE_CACHE_SHIFT;\n\t\tif (!page || page->index != idx) {\n\t\t\tif (page)\n\t\t\t\tntfs_unmap_page(page);\n\t\t\tpage = ntfs_map_page(mapping, idx);\n\t\t\tif (IS_ERR(page)) {\n\t\t\t\tntfs_error(vol->sb, \"Error mapping $LogFile \"\n\t\t\t\t\t\t\"page (index %lu).\", idx);\n\t\t\t\tgoto err_out;\n\t\t\t}\n\t\t}\n\t\tkaddr = (u8*)page_address(page) + (pos & ~PAGE_CACHE_MASK);\n\t\t/*\n\t\t * A non-empty block means the logfile is not empty while an\n\t\t * empty block after a non-empty block has been encountered\n\t\t * means we are done.\n\t\t */\n\t\tif (!ntfs_is_empty_recordp((le32*)kaddr))\n\t\t\tlogfile_is_empty = false;\n\t\telse if (!logfile_is_empty)\n\t\t\tbreak;\n\t\t/*\n\t\t * A log record page means there cannot be a restart page after\n\t\t * this so no need to continue searching.\n\t\t */\n\t\tif (ntfs_is_rcrd_recordp((le32*)kaddr))\n\t\t\tbreak;\n\t\t/* If not a (modified by chkdsk) restart page, continue. */\n\t\tif (!ntfs_is_rstr_recordp((le32*)kaddr) &&\n\t\t\t\t!ntfs_is_chkd_recordp((le32*)kaddr)) {\n\t\t\tif (!pos)\n\t\t\t\tpos = NTFS_BLOCK_SIZE >> 1;\n\t\t\tcontinue;\n\t\t}\n\t\t/*\n\t\t * Check the (modified by chkdsk) restart page for consistency\n\t\t * and get a copy of the complete multi sector transfer\n\t\t * deprotected restart page.\n\t\t */\n\t\terr = ntfs_check_and_load_restart_page(log_vi,\n\t\t\t\t(RESTART_PAGE_HEADER*)kaddr, pos,\n\t\t\t\t!rstr1_ph ? &rstr1_ph : &rstr2_ph,\n\t\t\t\t!rstr1_ph ? &rstr1_lsn : &rstr2_lsn);\n\t\tif (!err) {\n\t\t\t/*\n\t\t\t * If we have now found the first (modified by chkdsk)\n\t\t\t * restart page, continue looking for the second one.\n\t\t\t */\n\t\t\tif (!pos) {\n\t\t\t\tpos = NTFS_BLOCK_SIZE >> 1;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t/*\n\t\t\t * We have now found the second (modified by chkdsk)\n\t\t\t * restart page, so we can stop looking.\n\t\t\t */\n\t\t\tbreak;\n\t\t}\n\t\t/*\n\t\t * Error output already done inside the function.  Note, we do\n\t\t * not abort if the restart page was invalid as we might still\n\t\t * find a valid one further in the file.\n\t\t */\n\t\tif (err != -EINVAL) {\n\t\t\tntfs_unmap_page(page);\n\t\t\tgoto err_out;\n\t\t}\n\t\t/* Continue looking. */\n\t\tif (!pos)\n\t\t\tpos = NTFS_BLOCK_SIZE >> 1;\n\t}\n\tif (page)\n\t\tntfs_unmap_page(page);\n\tif (logfile_is_empty) {\n\t\tNVolSetLogFileEmpty(vol);\nis_empty:\n\t\tntfs_debug(\"Done.  ($LogFile is empty.)\");\n\t\treturn true;\n\t}\n\tif (!rstr1_ph) {\n\t\tBUG_ON(rstr2_ph);\n\t\tntfs_error(vol->sb, \"Did not find any restart pages in \"\n\t\t\t\t\"$LogFile and it was not empty.\");\n\t\treturn false;\n\t}\n\t/* If both restart pages were found, use the more recent one. */\n\tif (rstr2_ph) {\n\t\t/*\n\t\t * If the second restart area is more recent, switch to it.\n\t\t * Otherwise just throw it away.\n\t\t */\n\t\tif (rstr2_lsn > rstr1_lsn) {\n\t\t\tntfs_debug(\"Using second restart page as it is more \"\n\t\t\t\t\t\"recent.\");\n\t\t\tntfs_free(rstr1_ph);\n\t\t\trstr1_ph = rstr2_ph;\n\t\t\t/* rstr1_lsn = rstr2_lsn; */\n\t\t} else {\n\t\t\tntfs_debug(\"Using first restart page as it is more \"\n\t\t\t\t\t\"recent.\");\n\t\t\tntfs_free(rstr2_ph);\n\t\t}\n\t\trstr2_ph = NULL;\n\t}\n\t/* All consistency checks passed. */\n\tif (rp)\n\t\t*rp = rstr1_ph;\n\telse\n\t\tntfs_free(rstr1_ph);\n\tntfs_debug(\"Done.\");\n\treturn true;\nerr_out:\n\tif (rstr1_ph)\n\t\tntfs_free(rstr1_ph);\n\treturn false;\n}",
          "includes": [
            "#include \"ntfs.h\"",
            "#include \"volume.h\"",
            "#include \"malloc.h\"",
            "#include \"logfile.h\"",
            "#include \"debug.h\"",
            "#include \"aops.h\"",
            "#include \"attrib.h\"",
            "#include <linux/log2.h>",
            "#include <linux/bitops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/highmem.h>",
            "#include <linux/fs.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ntfs.h\"\n#include \"volume.h\"\n#include \"malloc.h\"\n#include \"logfile.h\"\n#include \"debug.h\"\n#include \"aops.h\"\n#include \"attrib.h\"\n#include <linux/log2.h>\n#include <linux/bitops.h>\n#include <linux/buffer_head.h>\n#include <linux/highmem.h>\n#include <linux/fs.h>\n#include <linux/types.h>\n\nbool ntfs_check_logfile(struct inode *log_vi, RESTART_PAGE_HEADER **rp)\n{\n\ts64 size, pos;\n\tLSN rstr1_lsn, rstr2_lsn;\n\tntfs_volume *vol = NTFS_SB(log_vi->i_sb);\n\tstruct address_space *mapping = log_vi->i_mapping;\n\tstruct page *page = NULL;\n\tu8 *kaddr = NULL;\n\tRESTART_PAGE_HEADER *rstr1_ph = NULL;\n\tRESTART_PAGE_HEADER *rstr2_ph = NULL;\n\tint log_page_size, log_page_mask, err;\n\tbool logfile_is_empty = true;\n\tu8 log_page_bits;\n\n\tntfs_debug(\"Entering.\");\n\t/* An empty $LogFile must have been clean before it got emptied. */\n\tif (NVolLogFileEmpty(vol))\n\t\tgoto is_empty;\n\tsize = i_size_read(log_vi);\n\t/* Make sure the file doesn't exceed the maximum allowed size. */\n\tif (size > MaxLogFileSize)\n\t\tsize = MaxLogFileSize;\n\t/*\n\t * Truncate size to a multiple of the page cache size or the default\n\t * log page size if the page cache size is between the default log page\n\t * log page size if the page cache size is between the default log page\n\t * size and twice that.\n\t */\n\tif (PAGE_CACHE_SIZE >= DefaultLogPageSize && PAGE_CACHE_SIZE <=\n\t\t\tDefaultLogPageSize * 2)\n\t\tlog_page_size = DefaultLogPageSize;\n\telse\n\t\tlog_page_size = PAGE_CACHE_SIZE;\n\tlog_page_mask = log_page_size - 1;\n\t/*\n\t * Use ntfs_ffs() instead of ffs() to enable the compiler to\n\t * optimize log_page_size and log_page_bits into constants.\n\t */\n\tlog_page_bits = ntfs_ffs(log_page_size) - 1;\n\tsize &= ~(s64)(log_page_size - 1);\n\t/*\n\t * Ensure the log file is big enough to store at least the two restart\n\t * pages and the minimum number of log record pages.\n\t */\n\tif (size < log_page_size * 2 || (size - log_page_size * 2) >>\n\t\t\tlog_page_bits < MinLogRecordPages) {\n\t\tntfs_error(vol->sb, \"$LogFile is too small.\");\n\t\treturn false;\n\t}\n\t/*\n\t * Read through the file looking for a restart page.  Since the restart\n\t * page header is at the beginning of a page we only need to search at\n\t * what could be the beginning of a page (for each page size) rather\n\t * than scanning the whole file byte by byte.  If all potential places\n\t * contain empty and uninitialzed records, the log file can be assumed\n\t * to be empty.\n\t */\n\tfor (pos = 0; pos < size; pos <<= 1) {\n\t\tpgoff_t idx = pos >> PAGE_CACHE_SHIFT;\n\t\tif (!page || page->index != idx) {\n\t\t\tif (page)\n\t\t\t\tntfs_unmap_page(page);\n\t\t\tpage = ntfs_map_page(mapping, idx);\n\t\t\tif (IS_ERR(page)) {\n\t\t\t\tntfs_error(vol->sb, \"Error mapping $LogFile \"\n\t\t\t\t\t\t\"page (index %lu).\", idx);\n\t\t\t\tgoto err_out;\n\t\t\t}\n\t\t}\n\t\tkaddr = (u8*)page_address(page) + (pos & ~PAGE_CACHE_MASK);\n\t\t/*\n\t\t * A non-empty block means the logfile is not empty while an\n\t\t * empty block after a non-empty block has been encountered\n\t\t * means we are done.\n\t\t */\n\t\tif (!ntfs_is_empty_recordp((le32*)kaddr))\n\t\t\tlogfile_is_empty = false;\n\t\telse if (!logfile_is_empty)\n\t\t\tbreak;\n\t\t/*\n\t\t * A log record page means there cannot be a restart page after\n\t\t * this so no need to continue searching.\n\t\t */\n\t\tif (ntfs_is_rcrd_recordp((le32*)kaddr))\n\t\t\tbreak;\n\t\t/* If not a (modified by chkdsk) restart page, continue. */\n\t\tif (!ntfs_is_rstr_recordp((le32*)kaddr) &&\n\t\t\t\t!ntfs_is_chkd_recordp((le32*)kaddr)) {\n\t\t\tif (!pos)\n\t\t\t\tpos = NTFS_BLOCK_SIZE >> 1;\n\t\t\tcontinue;\n\t\t}\n\t\t/*\n\t\t * Check the (modified by chkdsk) restart page for consistency\n\t\t * and get a copy of the complete multi sector transfer\n\t\t * deprotected restart page.\n\t\t */\n\t\terr = ntfs_check_and_load_restart_page(log_vi,\n\t\t\t\t(RESTART_PAGE_HEADER*)kaddr, pos,\n\t\t\t\t!rstr1_ph ? &rstr1_ph : &rstr2_ph,\n\t\t\t\t!rstr1_ph ? &rstr1_lsn : &rstr2_lsn);\n\t\tif (!err) {\n\t\t\t/*\n\t\t\t * If we have now found the first (modified by chkdsk)\n\t\t\t * restart page, continue looking for the second one.\n\t\t\t */\n\t\t\tif (!pos) {\n\t\t\t\tpos = NTFS_BLOCK_SIZE >> 1;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t/*\n\t\t\t * We have now found the second (modified by chkdsk)\n\t\t\t * restart page, so we can stop looking.\n\t\t\t */\n\t\t\tbreak;\n\t\t}\n\t\t/*\n\t\t * Error output already done inside the function.  Note, we do\n\t\t * not abort if the restart page was invalid as we might still\n\t\t * find a valid one further in the file.\n\t\t */\n\t\tif (err != -EINVAL) {\n\t\t\tntfs_unmap_page(page);\n\t\t\tgoto err_out;\n\t\t}\n\t\t/* Continue looking. */\n\t\tif (!pos)\n\t\t\tpos = NTFS_BLOCK_SIZE >> 1;\n\t}\n\tif (page)\n\t\tntfs_unmap_page(page);\n\tif (logfile_is_empty) {\n\t\tNVolSetLogFileEmpty(vol);\nis_empty:\n\t\tntfs_debug(\"Done.  ($LogFile is empty.)\");\n\t\treturn true;\n\t}\n\tif (!rstr1_ph) {\n\t\tBUG_ON(rstr2_ph);\n\t\tntfs_error(vol->sb, \"Did not find any restart pages in \"\n\t\t\t\t\"$LogFile and it was not empty.\");\n\t\treturn false;\n\t}\n\t/* If both restart pages were found, use the more recent one. */\n\tif (rstr2_ph) {\n\t\t/*\n\t\t * If the second restart area is more recent, switch to it.\n\t\t * Otherwise just throw it away.\n\t\t */\n\t\tif (rstr2_lsn > rstr1_lsn) {\n\t\t\tntfs_debug(\"Using second restart page as it is more \"\n\t\t\t\t\t\"recent.\");\n\t\t\tntfs_free(rstr1_ph);\n\t\t\trstr1_ph = rstr2_ph;\n\t\t\t/* rstr1_lsn = rstr2_lsn; */\n\t\t} else {\n\t\t\tntfs_debug(\"Using first restart page as it is more \"\n\t\t\t\t\t\"recent.\");\n\t\t\tntfs_free(rstr2_ph);\n\t\t}\n\t\trstr2_ph = NULL;\n\t}\n\t/* All consistency checks passed. */\n\tif (rp)\n\t\t*rp = rstr1_ph;\n\telse\n\t\tntfs_free(rstr1_ph);\n\tntfs_debug(\"Done.\");\n\treturn true;\nerr_out:\n\tif (rstr1_ph)\n\t\tntfs_free(rstr1_ph);\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "tmp_ino"
          ],
          "line": 1224
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_bad_inode",
          "args": [
            "tmp_ino"
          ],
          "line": 1223
        },
        "resolved": true,
        "details": {
          "function_name": "is_bad_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/bad_inode.c",
          "lines": "195-198",
          "snippet": "int is_bad_inode(struct inode *inode)\n{\n\treturn (inode->i_op == &bad_inode_ops);\t\n}",
          "includes": [
            "#include <linux/poll.h>",
            "#include <linux/namei.h>",
            "#include <linux/time.h>",
            "#include <linux/stat.h>",
            "#include <linux/export.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct inode_operations bad_inode_ops =\n{\n\t.create\t\t= bad_inode_create,\n\t.lookup\t\t= bad_inode_lookup,\n\t.link\t\t= bad_inode_link,\n\t.unlink\t\t= bad_inode_unlink,\n\t.symlink\t= bad_inode_symlink,\n\t.mkdir\t\t= bad_inode_mkdir,\n\t.rmdir\t\t= bad_inode_rmdir,\n\t.mknod\t\t= bad_inode_mknod,\n\t.rename2\t= bad_inode_rename2,\n\t.readlink\t= bad_inode_readlink,\n\t/* follow_link must be no-op, otherwise unmounting this inode\n\t   won't work */\n\t/* put_link returns void */\n\t/* truncate returns void */\n\t.permission\t= bad_inode_permission,\n\t.getattr\t= bad_inode_getattr,\n\t.setattr\t= bad_inode_setattr,\n\t.setxattr\t= bad_inode_setxattr,\n\t.getxattr\t= bad_inode_getxattr,\n\t.listxattr\t= bad_inode_listxattr,\n\t.removexattr\t= bad_inode_removexattr,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/poll.h>\n#include <linux/namei.h>\n#include <linux/time.h>\n#include <linux/stat.h>\n#include <linux/export.h>\n#include <linux/fs.h>\n\nstatic const struct inode_operations bad_inode_ops =\n{\n\t.create\t\t= bad_inode_create,\n\t.lookup\t\t= bad_inode_lookup,\n\t.link\t\t= bad_inode_link,\n\t.unlink\t\t= bad_inode_unlink,\n\t.symlink\t= bad_inode_symlink,\n\t.mkdir\t\t= bad_inode_mkdir,\n\t.rmdir\t\t= bad_inode_rmdir,\n\t.mknod\t\t= bad_inode_mknod,\n\t.rename2\t= bad_inode_rename2,\n\t.readlink\t= bad_inode_readlink,\n\t/* follow_link must be no-op, otherwise unmounting this inode\n\t   won't work */\n\t/* put_link returns void */\n\t/* truncate returns void */\n\t.permission\t= bad_inode_permission,\n\t.getattr\t= bad_inode_getattr,\n\t.setattr\t= bad_inode_setattr,\n\t.setxattr\t= bad_inode_setxattr,\n\t.getxattr\t= bad_inode_getxattr,\n\t.listxattr\t= bad_inode_listxattr,\n\t.removexattr\t= bad_inode_removexattr,\n};\n\nint is_bad_inode(struct inode *inode)\n{\n\treturn (inode->i_op == &bad_inode_ops);\t\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "tmp_ino"
          ],
          "line": 1223
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_iget",
          "args": [
            "vol->sb",
            "FILE_LogFile"
          ],
          "line": 1222
        },
        "resolved": true,
        "details": {
          "function_name": "ntfs_iget",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/inode.c",
          "lines": "171-203",
          "snippet": "struct inode *ntfs_iget(struct super_block *sb, unsigned long mft_no)\n{\n\tstruct inode *vi;\n\tint err;\n\tntfs_attr na;\n\n\tna.mft_no = mft_no;\n\tna.type = AT_UNUSED;\n\tna.name = NULL;\n\tna.name_len = 0;\n\n\tvi = iget5_locked(sb, mft_no, (test_t)ntfs_test_inode,\n\t\t\t(set_t)ntfs_init_locked_inode, &na);\n\tif (unlikely(!vi))\n\t\treturn ERR_PTR(-ENOMEM);\n\n\terr = 0;\n\n\t/* If this is a freshly allocated inode, need to read it now. */\n\tif (vi->i_state & I_NEW) {\n\t\terr = ntfs_read_locked_inode(vi);\n\t\tunlock_new_inode(vi);\n\t}\n\t/*\n\t * There is no point in keeping bad inodes around if the failure was\n\t * due to ENOMEM. We want to be able to retry again later.\n\t */\n\tif (unlikely(err == -ENOMEM)) {\n\t\tiput(vi);\n\t\tvi = ERR_PTR(err);\n\t}\n\treturn vi;\n}",
          "includes": [
            "#include \"ntfs.h\"",
            "#include \"time.h\"",
            "#include \"mft.h\"",
            "#include \"malloc.h\"",
            "#include \"lcnalloc.h\"",
            "#include \"inode.h\"",
            "#include \"debug.h\"",
            "#include \"dir.h\"",
            "#include \"bitmap.h\"",
            "#include \"attrib.h\"",
            "#include \"aops.h\"",
            "#include <linux/aio.h>",
            "#include <linux/log2.h>",
            "#include <linux/slab.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mutex.h>",
            "#include <linux/mount.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ntfs_read_locked_inode(struct inode *vi);",
            "static int ntfs_read_locked_attr_inode(struct inode *base_vi, struct inode *vi);",
            "static int ntfs_read_locked_index_inode(struct inode *base_vi,\n\t\tstruct inode *vi);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ntfs.h\"\n#include \"time.h\"\n#include \"mft.h\"\n#include \"malloc.h\"\n#include \"lcnalloc.h\"\n#include \"inode.h\"\n#include \"debug.h\"\n#include \"dir.h\"\n#include \"bitmap.h\"\n#include \"attrib.h\"\n#include \"aops.h\"\n#include <linux/aio.h>\n#include <linux/log2.h>\n#include <linux/slab.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/mutex.h>\n#include <linux/mount.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n\nstatic int ntfs_read_locked_inode(struct inode *vi);\nstatic int ntfs_read_locked_attr_inode(struct inode *base_vi, struct inode *vi);\nstatic int ntfs_read_locked_index_inode(struct inode *base_vi,\n\t\tstruct inode *vi);\n\nstruct inode *ntfs_iget(struct super_block *sb, unsigned long mft_no)\n{\n\tstruct inode *vi;\n\tint err;\n\tntfs_attr na;\n\n\tna.mft_no = mft_no;\n\tna.type = AT_UNUSED;\n\tna.name = NULL;\n\tna.name_len = 0;\n\n\tvi = iget5_locked(sb, mft_no, (test_t)ntfs_test_inode,\n\t\t\t(set_t)ntfs_init_locked_inode, &na);\n\tif (unlikely(!vi))\n\t\treturn ERR_PTR(-ENOMEM);\n\n\terr = 0;\n\n\t/* If this is a freshly allocated inode, need to read it now. */\n\tif (vi->i_state & I_NEW) {\n\t\terr = ntfs_read_locked_inode(vi);\n\t\tunlock_new_inode(vi);\n\t}\n\t/*\n\t * There is no point in keeping bad inodes around if the failure was\n\t * due to ENOMEM. We want to be able to retry again later.\n\t */\n\tif (unlikely(err == -ENOMEM)) {\n\t\tiput(vi);\n\t\tvi = ERR_PTR(err);\n\t}\n\treturn vi;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ntfs.h\"\n#include \"malloc.h\"\n#include \"layout.h\"\n#include \"aops.h\"\n#include \"inode.h\"\n#include \"index.h\"\n#include \"debug.h\"\n#include \"dir.h\"\n#include \"usnjrnl.h\"\n#include \"quota.h\"\n#include \"logfile.h\"\n#include \"sysctl.h\"\n#include <linux/bitmap.h>\n#include <linux/moduleparam.h>\n#include <linux/vfs.h>\n#include <linux/buffer_head.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\t/* For bdev_logical_block_size(). */\n#include <linux/spinlock.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/stddef.h>\n\nstatic bool load_and_check_logfile(ntfs_volume *vol,\n\t\tRESTART_PAGE_HEADER **rp)\n{\n\tstruct inode *tmp_ino;\n\n\tntfs_debug(\"Entering.\");\n\ttmp_ino = ntfs_iget(vol->sb, FILE_LogFile);\n\tif (IS_ERR(tmp_ino) || is_bad_inode(tmp_ino)) {\n\t\tif (!IS_ERR(tmp_ino))\n\t\t\tiput(tmp_ino);\n\t\t/* Caller will display error message. */\n\t\treturn false;\n\t}\n\tif (!ntfs_check_logfile(tmp_ino, rp)) {\n\t\tiput(tmp_ino);\n\t\t/* ntfs_check_logfile() will have displayed error output. */\n\t\treturn false;\n\t}\n\tNInoSetSparseDisabled(NTFS_I(tmp_ino));\n\tvol->logfile_ino = tmp_ino;\n\tntfs_debug(\"Done.\");\n\treturn true;\n}"
  },
  {
    "function_name": "check_mft_mirror",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/super.c",
    "lines": "1087-1208",
    "snippet": "static bool check_mft_mirror(ntfs_volume *vol)\n{\n\tstruct super_block *sb = vol->sb;\n\tntfs_inode *mirr_ni;\n\tstruct page *mft_page, *mirr_page;\n\tu8 *kmft, *kmirr;\n\trunlist_element *rl, rl2[2];\n\tpgoff_t index;\n\tint mrecs_per_page, i;\n\n\tntfs_debug(\"Entering.\");\n\t/* Compare contents of $MFT and $MFTMirr. */\n\tmrecs_per_page = PAGE_CACHE_SIZE / vol->mft_record_size;\n\tBUG_ON(!mrecs_per_page);\n\tBUG_ON(!vol->mftmirr_size);\n\tmft_page = mirr_page = NULL;\n\tkmft = kmirr = NULL;\n\tindex = i = 0;\n\tdo {\n\t\tu32 bytes;\n\n\t\t/* Switch pages if necessary. */\n\t\tif (!(i % mrecs_per_page)) {\n\t\t\tif (index) {\n\t\t\t\tntfs_unmap_page(mft_page);\n\t\t\t\tntfs_unmap_page(mirr_page);\n\t\t\t}\n\t\t\t/* Get the $MFT page. */\n\t\t\tmft_page = ntfs_map_page(vol->mft_ino->i_mapping,\n\t\t\t\t\tindex);\n\t\t\tif (IS_ERR(mft_page)) {\n\t\t\t\tntfs_error(sb, \"Failed to read $MFT.\");\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tkmft = page_address(mft_page);\n\t\t\t/* Get the $MFTMirr page. */\n\t\t\tmirr_page = ntfs_map_page(vol->mftmirr_ino->i_mapping,\n\t\t\t\t\tindex);\n\t\t\tif (IS_ERR(mirr_page)) {\n\t\t\t\tntfs_error(sb, \"Failed to read $MFTMirr.\");\n\t\t\t\tgoto mft_unmap_out;\n\t\t\t}\n\t\t\tkmirr = page_address(mirr_page);\n\t\t\t++index;\n\t\t}\n\t\t/* Do not check the record if it is not in use. */\n\t\tif (((MFT_RECORD*)kmft)->flags & MFT_RECORD_IN_USE) {\n\t\t\t/* Make sure the record is ok. */\n\t\t\tif (ntfs_is_baad_recordp((le32*)kmft)) {\n\t\t\t\tntfs_error(sb, \"Incomplete multi sector \"\n\t\t\t\t\t\t\"transfer detected in mft \"\n\t\t\t\t\t\t\"record %i.\", i);\nmm_unmap_out:\n\t\t\t\tntfs_unmap_page(mirr_page);\nmft_unmap_out:\n\t\t\t\tntfs_unmap_page(mft_page);\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\t/* Do not check the mirror record if it is not in use. */\n\t\tif (((MFT_RECORD*)kmirr)->flags & MFT_RECORD_IN_USE) {\n\t\t\tif (ntfs_is_baad_recordp((le32*)kmirr)) {\n\t\t\t\tntfs_error(sb, \"Incomplete multi sector \"\n\t\t\t\t\t\t\"transfer detected in mft \"\n\t\t\t\t\t\t\"mirror record %i.\", i);\n\t\t\t\tgoto mm_unmap_out;\n\t\t\t}\n\t\t}\n\t\t/* Get the amount of data in the current record. */\n\t\tbytes = le32_to_cpu(((MFT_RECORD*)kmft)->bytes_in_use);\n\t\tif (bytes < sizeof(MFT_RECORD_OLD) ||\n\t\t\t\tbytes > vol->mft_record_size ||\n\t\t\t\tntfs_is_baad_recordp((le32*)kmft)) {\n\t\t\tbytes = le32_to_cpu(((MFT_RECORD*)kmirr)->bytes_in_use);\n\t\t\tif (bytes < sizeof(MFT_RECORD_OLD) ||\n\t\t\t\t\tbytes > vol->mft_record_size ||\n\t\t\t\t\tntfs_is_baad_recordp((le32*)kmirr))\n\t\t\t\tbytes = vol->mft_record_size;\n\t\t}\n\t\t/* Compare the two records. */\n\t\tif (memcmp(kmft, kmirr, bytes)) {\n\t\t\tntfs_error(sb, \"$MFT and $MFTMirr (record %i) do not \"\n\t\t\t\t\t\"match.  Run ntfsfix or chkdsk.\", i);\n\t\t\tgoto mm_unmap_out;\n\t\t}\n\t\tkmft += vol->mft_record_size;\n\t\tkmirr += vol->mft_record_size;\n\t} while (++i < vol->mftmirr_size);\n\t/* Release the last pages. */\n\tntfs_unmap_page(mft_page);\n\tntfs_unmap_page(mirr_page);\n\n\t/* Construct the mft mirror runlist by hand. */\n\trl2[0].vcn = 0;\n\trl2[0].lcn = vol->mftmirr_lcn;\n\trl2[0].length = (vol->mftmirr_size * vol->mft_record_size +\n\t\t\tvol->cluster_size - 1) / vol->cluster_size;\n\trl2[1].vcn = rl2[0].length;\n\trl2[1].lcn = LCN_ENOENT;\n\trl2[1].length = 0;\n\t/*\n\t * Because we have just read all of the mft mirror, we know we have\n\t * mapped the full runlist for it.\n\t */\n\tmirr_ni = NTFS_I(vol->mftmirr_ino);\n\tdown_read(&mirr_ni->runlist.lock);\n\trl = mirr_ni->runlist.rl;\n\t/* Compare the two runlists.  They must be identical. */\n\ti = 0;\n\tdo {\n\t\tif (rl2[i].vcn != rl[i].vcn || rl2[i].lcn != rl[i].lcn ||\n\t\t\t\trl2[i].length != rl[i].length) {\n\t\t\tntfs_error(sb, \"$MFTMirr location mismatch.  \"\n\t\t\t\t\t\"Run chkdsk.\");\n\t\t\tup_read(&mirr_ni->runlist.lock);\n\t\t\treturn false;\n\t\t}\n\t} while (rl2[i++].length);\n\tup_read(&mirr_ni->runlist.lock);\n\tntfs_debug(\"Done.\");\n\treturn true;\n}",
    "includes": [
      "#include \"ntfs.h\"",
      "#include \"malloc.h\"",
      "#include \"layout.h\"",
      "#include \"aops.h\"",
      "#include \"inode.h\"",
      "#include \"index.h\"",
      "#include \"debug.h\"",
      "#include \"dir.h\"",
      "#include \"usnjrnl.h\"",
      "#include \"quota.h\"",
      "#include \"logfile.h\"",
      "#include \"sysctl.h\"",
      "#include <linux/bitmap.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/vfs.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/blkdev.h>\t/* For bdev_logical_block_size(). */",
      "#include <linux/spinlock.h>",
      "#include <linux/string.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/stddef.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ntfs_debug",
          "args": [
            "\"Done.\""
          ],
          "line": 1206
        },
        "resolved": true,
        "details": {
          "function_name": "ntfs_debug_dump_runlist",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/debug.c",
          "lines": "134-171",
          "snippet": "void ntfs_debug_dump_runlist(const runlist_element *rl)\n{\n\tint i;\n\tconst char *lcn_str[5] = { \"LCN_HOLE         \", \"LCN_RL_NOT_MAPPED\",\n\t\t\t\t   \"LCN_ENOENT       \", \"LCN_unknown      \" };\n\n\tif (!debug_msgs)\n\t\treturn;\n\tpr_debug(\"Dumping runlist (values in hex):\\n\");\n\tif (!rl) {\n\t\tpr_debug(\"Run list not present.\\n\");\n\t\treturn;\n\t}\n\tpr_debug(\"VCN              LCN               Run length\\n\");\n\tfor (i = 0; ; i++) {\n\t\tLCN lcn = (rl + i)->lcn;\n\n\t\tif (lcn < (LCN)0) {\n\t\t\tint index = -lcn - 1;\n\n\t\t\tif (index > -LCN_ENOENT - 1)\n\t\t\t\tindex = 3;\n\t\t\tpr_debug(\"%-16Lx %s %-16Lx%s\\n\",\n\t\t\t\t\t(long long)(rl + i)->vcn, lcn_str[index],\n\t\t\t\t\t(long long)(rl + i)->length,\n\t\t\t\t\t(rl + i)->length ? \"\" :\n\t\t\t\t\t\t\" (runlist end)\");\n\t\t} else\n\t\t\tpr_debug(\"%-16Lx %-16Lx  %-16Lx%s\\n\",\n\t\t\t\t\t(long long)(rl + i)->vcn,\n\t\t\t\t\t(long long)(rl + i)->lcn,\n\t\t\t\t\t(long long)(rl + i)->length,\n\t\t\t\t\t(rl + i)->length ? \"\" :\n\t\t\t\t\t\t\" (runlist end)\");\n\t\tif (!(rl + i)->length)\n\t\t\tbreak;\n\t}\n}",
          "includes": [
            "#include \"debug.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"debug.h\"\n\nvoid ntfs_debug_dump_runlist(const runlist_element *rl)\n{\n\tint i;\n\tconst char *lcn_str[5] = { \"LCN_HOLE         \", \"LCN_RL_NOT_MAPPED\",\n\t\t\t\t   \"LCN_ENOENT       \", \"LCN_unknown      \" };\n\n\tif (!debug_msgs)\n\t\treturn;\n\tpr_debug(\"Dumping runlist (values in hex):\\n\");\n\tif (!rl) {\n\t\tpr_debug(\"Run list not present.\\n\");\n\t\treturn;\n\t}\n\tpr_debug(\"VCN              LCN               Run length\\n\");\n\tfor (i = 0; ; i++) {\n\t\tLCN lcn = (rl + i)->lcn;\n\n\t\tif (lcn < (LCN)0) {\n\t\t\tint index = -lcn - 1;\n\n\t\t\tif (index > -LCN_ENOENT - 1)\n\t\t\t\tindex = 3;\n\t\t\tpr_debug(\"%-16Lx %s %-16Lx%s\\n\",\n\t\t\t\t\t(long long)(rl + i)->vcn, lcn_str[index],\n\t\t\t\t\t(long long)(rl + i)->length,\n\t\t\t\t\t(rl + i)->length ? \"\" :\n\t\t\t\t\t\t\" (runlist end)\");\n\t\t} else\n\t\t\tpr_debug(\"%-16Lx %-16Lx  %-16Lx%s\\n\",\n\t\t\t\t\t(long long)(rl + i)->vcn,\n\t\t\t\t\t(long long)(rl + i)->lcn,\n\t\t\t\t\t(long long)(rl + i)->length,\n\t\t\t\t\t(rl + i)->length ? \"\" :\n\t\t\t\t\t\t\" (runlist end)\");\n\t\tif (!(rl + i)->length)\n\t\t\tbreak;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "up_read",
          "args": [
            "&mirr_ni->runlist.lock"
          ],
          "line": 1205
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "up_read",
          "args": [
            "&mirr_ni->runlist.lock"
          ],
          "line": 1201
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_error",
          "args": [
            "sb",
            "\"$MFTMirr location mismatch.  \"\n\t\t\t\t\t\"Run chkdsk.\""
          ],
          "line": 1199
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "down_read",
          "args": [
            "&mirr_ni->runlist.lock"
          ],
          "line": 1192
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NTFS_I",
          "args": [
            "vol->mftmirr_ino"
          ],
          "line": 1191
        },
        "resolved": true,
        "details": {
          "function_name": "NTFS_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/inode.h",
          "lines": "240-243",
          "snippet": "static inline ntfs_inode *NTFS_I(struct inode *inode)\n{\n\treturn (ntfs_inode *)list_entry(inode, big_ntfs_inode, vfs_inode);\n}",
          "includes": [
            "#include \"debug.h\"",
            "#include \"runlist.h\"",
            "#include \"types.h\"",
            "#include \"volume.h\"",
            "#include \"layout.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/mutex.h>",
            "#include <linux/mm.h>",
            "#include <linux/list.h>",
            "#include <linux/fs.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"debug.h\"\n#include \"runlist.h\"\n#include \"types.h\"\n#include \"volume.h\"\n#include \"layout.h\"\n#include <linux/seq_file.h>\n#include <linux/mutex.h>\n#include <linux/mm.h>\n#include <linux/list.h>\n#include <linux/fs.h>\n#include <linux/atomic.h>\n\nstatic inline ntfs_inode *NTFS_I(struct inode *inode)\n{\n\treturn (ntfs_inode *)list_entry(inode, big_ntfs_inode, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ntfs_unmap_page",
          "args": [
            "mirr_page"
          ],
          "line": 1177
        },
        "resolved": true,
        "details": {
          "function_name": "ntfs_unmap_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/aops.h",
          "lines": "40-44",
          "snippet": "static inline void ntfs_unmap_page(struct page *page)\n{\n\tkunmap(page);\n\tpage_cache_release(page);\n}",
          "includes": [
            "#include \"inode.h\"",
            "#include <linux/fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"inode.h\"\n#include <linux/fs.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\nstatic inline void ntfs_unmap_page(struct page *page)\n{\n\tkunmap(page);\n\tpage_cache_release(page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ntfs_error",
          "args": [
            "sb",
            "\"$MFT and $MFTMirr (record %i) do not \"\n\t\t\t\t\t\"match.  Run ntfsfix or chkdsk.\"",
            "i"
          ],
          "line": 1168
        },
        "resolved": true,
        "details": {
          "function_name": "__ntfs_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/debug.c",
          "lines": "86-108",
          "snippet": "void __ntfs_error(const char *function, const struct super_block *sb,\n\t\tconst char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\tint flen = 0;\n\n#ifndef DEBUG\n\tif (!printk_ratelimit())\n\t\treturn;\n#endif\n\tif (function)\n\t\tflen = strlen(function);\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tif (sb)\n\t\tpr_err(\"(device %s): %s(): %pV\\n\",\n\t\t       sb->s_id, flen ? function : \"\", &vaf);\n\telse\n\t\tpr_err(\"%s(): %pV\\n\", flen ? function : \"\", &vaf);\n\tva_end(args);\n}",
          "includes": [
            "#include \"debug.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"debug.h\"\n\nvoid __ntfs_error(const char *function, const struct super_block *sb,\n\t\tconst char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\tint flen = 0;\n\n#ifndef DEBUG\n\tif (!printk_ratelimit())\n\t\treturn;\n#endif\n\tif (function)\n\t\tflen = strlen(function);\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tif (sb)\n\t\tpr_err(\"(device %s): %s(): %pV\\n\",\n\t\t       sb->s_id, flen ? function : \"\", &vaf);\n\telse\n\t\tpr_err(\"%s(): %pV\\n\", flen ? function : \"\", &vaf);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcmp",
          "args": [
            "kmft",
            "kmirr",
            "bytes"
          ],
          "line": 1167
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_is_baad_recordp",
          "args": [
            "(le32*)kmirr"
          ],
          "line": 1163
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "((MFT_RECORD*)kmirr)->bytes_in_use"
          ],
          "line": 1160
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ntfs_is_baad_recordp",
          "args": [
            "(le32*)kmft"
          ],
          "line": 1159
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_is_baad_recordp",
          "args": [
            "(le32*)kmirr"
          ],
          "line": 1148
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_is_baad_recordp",
          "args": [
            "(le32*)kmft"
          ],
          "line": 1135
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_address",
          "args": [
            "mirr_page"
          ],
          "line": 1129
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_error",
          "args": [
            "sb",
            "\"Failed to read $MFTMirr.\""
          ],
          "line": 1126
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "mirr_page"
          ],
          "line": 1125
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_map_page",
          "args": [
            "vol->mftmirr_ino->i_mapping",
            "index"
          ],
          "line": 1123
        },
        "resolved": true,
        "details": {
          "function_name": "ntfs_map_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/aops.h",
          "lines": "86-99",
          "snippet": "static inline struct page *ntfs_map_page(struct address_space *mapping,\n\t\tunsigned long index)\n{\n\tstruct page *page = read_mapping_page(mapping, index, NULL);\n\n\tif (!IS_ERR(page)) {\n\t\tkmap(page);\n\t\tif (!PageError(page))\n\t\t\treturn page;\n\t\tntfs_unmap_page(page);\n\t\treturn ERR_PTR(-EIO);\n\t}\n\treturn page;\n}",
          "includes": [
            "#include \"inode.h\"",
            "#include <linux/fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"inode.h\"\n#include <linux/fs.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\nstatic inline struct page *ntfs_map_page(struct address_space *mapping,\n\t\tunsigned long index)\n{\n\tstruct page *page = read_mapping_page(mapping, index, NULL);\n\n\tif (!IS_ERR(page)) {\n\t\tkmap(page);\n\t\tif (!PageError(page))\n\t\t\treturn page;\n\t\tntfs_unmap_page(page);\n\t\treturn ERR_PTR(-EIO);\n\t}\n\treturn page;\n}"
        }
      },
      {
        "call_info": {
          "callee": "page_address",
          "args": [
            "mft_page"
          ],
          "line": 1121
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_error",
          "args": [
            "sb",
            "\"Failed to read $MFT.\""
          ],
          "line": 1118
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "mft_page"
          ],
          "line": 1117
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!vol->mftmirr_size"
          ],
          "line": 1101
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!mrecs_per_page"
          ],
          "line": 1100
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ntfs.h\"\n#include \"malloc.h\"\n#include \"layout.h\"\n#include \"aops.h\"\n#include \"inode.h\"\n#include \"index.h\"\n#include \"debug.h\"\n#include \"dir.h\"\n#include \"usnjrnl.h\"\n#include \"quota.h\"\n#include \"logfile.h\"\n#include \"sysctl.h\"\n#include <linux/bitmap.h>\n#include <linux/moduleparam.h>\n#include <linux/vfs.h>\n#include <linux/buffer_head.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\t/* For bdev_logical_block_size(). */\n#include <linux/spinlock.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/stddef.h>\n\nstatic bool check_mft_mirror(ntfs_volume *vol)\n{\n\tstruct super_block *sb = vol->sb;\n\tntfs_inode *mirr_ni;\n\tstruct page *mft_page, *mirr_page;\n\tu8 *kmft, *kmirr;\n\trunlist_element *rl, rl2[2];\n\tpgoff_t index;\n\tint mrecs_per_page, i;\n\n\tntfs_debug(\"Entering.\");\n\t/* Compare contents of $MFT and $MFTMirr. */\n\tmrecs_per_page = PAGE_CACHE_SIZE / vol->mft_record_size;\n\tBUG_ON(!mrecs_per_page);\n\tBUG_ON(!vol->mftmirr_size);\n\tmft_page = mirr_page = NULL;\n\tkmft = kmirr = NULL;\n\tindex = i = 0;\n\tdo {\n\t\tu32 bytes;\n\n\t\t/* Switch pages if necessary. */\n\t\tif (!(i % mrecs_per_page)) {\n\t\t\tif (index) {\n\t\t\t\tntfs_unmap_page(mft_page);\n\t\t\t\tntfs_unmap_page(mirr_page);\n\t\t\t}\n\t\t\t/* Get the $MFT page. */\n\t\t\tmft_page = ntfs_map_page(vol->mft_ino->i_mapping,\n\t\t\t\t\tindex);\n\t\t\tif (IS_ERR(mft_page)) {\n\t\t\t\tntfs_error(sb, \"Failed to read $MFT.\");\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tkmft = page_address(mft_page);\n\t\t\t/* Get the $MFTMirr page. */\n\t\t\tmirr_page = ntfs_map_page(vol->mftmirr_ino->i_mapping,\n\t\t\t\t\tindex);\n\t\t\tif (IS_ERR(mirr_page)) {\n\t\t\t\tntfs_error(sb, \"Failed to read $MFTMirr.\");\n\t\t\t\tgoto mft_unmap_out;\n\t\t\t}\n\t\t\tkmirr = page_address(mirr_page);\n\t\t\t++index;\n\t\t}\n\t\t/* Do not check the record if it is not in use. */\n\t\tif (((MFT_RECORD*)kmft)->flags & MFT_RECORD_IN_USE) {\n\t\t\t/* Make sure the record is ok. */\n\t\t\tif (ntfs_is_baad_recordp((le32*)kmft)) {\n\t\t\t\tntfs_error(sb, \"Incomplete multi sector \"\n\t\t\t\t\t\t\"transfer detected in mft \"\n\t\t\t\t\t\t\"record %i.\", i);\nmm_unmap_out:\n\t\t\t\tntfs_unmap_page(mirr_page);\nmft_unmap_out:\n\t\t\t\tntfs_unmap_page(mft_page);\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\t/* Do not check the mirror record if it is not in use. */\n\t\tif (((MFT_RECORD*)kmirr)->flags & MFT_RECORD_IN_USE) {\n\t\t\tif (ntfs_is_baad_recordp((le32*)kmirr)) {\n\t\t\t\tntfs_error(sb, \"Incomplete multi sector \"\n\t\t\t\t\t\t\"transfer detected in mft \"\n\t\t\t\t\t\t\"mirror record %i.\", i);\n\t\t\t\tgoto mm_unmap_out;\n\t\t\t}\n\t\t}\n\t\t/* Get the amount of data in the current record. */\n\t\tbytes = le32_to_cpu(((MFT_RECORD*)kmft)->bytes_in_use);\n\t\tif (bytes < sizeof(MFT_RECORD_OLD) ||\n\t\t\t\tbytes > vol->mft_record_size ||\n\t\t\t\tntfs_is_baad_recordp((le32*)kmft)) {\n\t\t\tbytes = le32_to_cpu(((MFT_RECORD*)kmirr)->bytes_in_use);\n\t\t\tif (bytes < sizeof(MFT_RECORD_OLD) ||\n\t\t\t\t\tbytes > vol->mft_record_size ||\n\t\t\t\t\tntfs_is_baad_recordp((le32*)kmirr))\n\t\t\t\tbytes = vol->mft_record_size;\n\t\t}\n\t\t/* Compare the two records. */\n\t\tif (memcmp(kmft, kmirr, bytes)) {\n\t\t\tntfs_error(sb, \"$MFT and $MFTMirr (record %i) do not \"\n\t\t\t\t\t\"match.  Run ntfsfix or chkdsk.\", i);\n\t\t\tgoto mm_unmap_out;\n\t\t}\n\t\tkmft += vol->mft_record_size;\n\t\tkmirr += vol->mft_record_size;\n\t} while (++i < vol->mftmirr_size);\n\t/* Release the last pages. */\n\tntfs_unmap_page(mft_page);\n\tntfs_unmap_page(mirr_page);\n\n\t/* Construct the mft mirror runlist by hand. */\n\trl2[0].vcn = 0;\n\trl2[0].lcn = vol->mftmirr_lcn;\n\trl2[0].length = (vol->mftmirr_size * vol->mft_record_size +\n\t\t\tvol->cluster_size - 1) / vol->cluster_size;\n\trl2[1].vcn = rl2[0].length;\n\trl2[1].lcn = LCN_ENOENT;\n\trl2[1].length = 0;\n\t/*\n\t * Because we have just read all of the mft mirror, we know we have\n\t * mapped the full runlist for it.\n\t */\n\tmirr_ni = NTFS_I(vol->mftmirr_ino);\n\tdown_read(&mirr_ni->runlist.lock);\n\trl = mirr_ni->runlist.rl;\n\t/* Compare the two runlists.  They must be identical. */\n\ti = 0;\n\tdo {\n\t\tif (rl2[i].vcn != rl[i].vcn || rl2[i].lcn != rl[i].lcn ||\n\t\t\t\trl2[i].length != rl[i].length) {\n\t\t\tntfs_error(sb, \"$MFTMirr location mismatch.  \"\n\t\t\t\t\t\"Run chkdsk.\");\n\t\t\tup_read(&mirr_ni->runlist.lock);\n\t\t\treturn false;\n\t\t}\n\t} while (rl2[i++].length);\n\tup_read(&mirr_ni->runlist.lock);\n\tntfs_debug(\"Done.\");\n\treturn true;\n}"
  },
  {
    "function_name": "load_and_init_mft_mirror",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/super.c",
    "lines": "1034-1075",
    "snippet": "static bool load_and_init_mft_mirror(ntfs_volume *vol)\n{\n\tstruct inode *tmp_ino;\n\tntfs_inode *tmp_ni;\n\n\tntfs_debug(\"Entering.\");\n\t/* Get mft mirror inode. */\n\ttmp_ino = ntfs_iget(vol->sb, FILE_MFTMirr);\n\tif (IS_ERR(tmp_ino) || is_bad_inode(tmp_ino)) {\n\t\tif (!IS_ERR(tmp_ino))\n\t\t\tiput(tmp_ino);\n\t\t/* Caller will display error message. */\n\t\treturn false;\n\t}\n\t/*\n\t * Re-initialize some specifics about $MFTMirr's inode as\n\t * ntfs_read_inode() will have set up the default ones.\n\t */\n\t/* Set uid and gid to root. */\n\ttmp_ino->i_uid = GLOBAL_ROOT_UID;\n\ttmp_ino->i_gid = GLOBAL_ROOT_GID;\n\t/* Regular file.  No access for anyone. */\n\ttmp_ino->i_mode = S_IFREG;\n\t/* No VFS initiated operations allowed for $MFTMirr. */\n\ttmp_ino->i_op = &ntfs_empty_inode_ops;\n\ttmp_ino->i_fop = &ntfs_empty_file_ops;\n\t/* Put in our special address space operations. */\n\ttmp_ino->i_mapping->a_ops = &ntfs_mst_aops;\n\ttmp_ni = NTFS_I(tmp_ino);\n\t/* The $MFTMirr, like the $MFT is multi sector transfer protected. */\n\tNInoSetMstProtected(tmp_ni);\n\tNInoSetSparseDisabled(tmp_ni);\n\t/*\n\t * Set up our little cheat allowing us to reuse the async read io\n\t * completion handler for directories.\n\t */\n\ttmp_ni->itype.index.block_size = vol->mft_record_size;\n\ttmp_ni->itype.index.block_size_bits = vol->mft_record_size_bits;\n\tvol->mftmirr_ino = tmp_ino;\n\tntfs_debug(\"Done.\");\n\treturn true;\n}",
    "includes": [
      "#include \"ntfs.h\"",
      "#include \"malloc.h\"",
      "#include \"layout.h\"",
      "#include \"aops.h\"",
      "#include \"inode.h\"",
      "#include \"index.h\"",
      "#include \"debug.h\"",
      "#include \"dir.h\"",
      "#include \"usnjrnl.h\"",
      "#include \"quota.h\"",
      "#include \"logfile.h\"",
      "#include \"sysctl.h\"",
      "#include <linux/bitmap.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/vfs.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/blkdev.h>\t/* For bdev_logical_block_size(). */",
      "#include <linux/spinlock.h>",
      "#include <linux/string.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/stddef.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ntfs_debug",
          "args": [
            "\"Done.\""
          ],
          "line": 1073
        },
        "resolved": true,
        "details": {
          "function_name": "ntfs_debug_dump_runlist",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/debug.c",
          "lines": "134-171",
          "snippet": "void ntfs_debug_dump_runlist(const runlist_element *rl)\n{\n\tint i;\n\tconst char *lcn_str[5] = { \"LCN_HOLE         \", \"LCN_RL_NOT_MAPPED\",\n\t\t\t\t   \"LCN_ENOENT       \", \"LCN_unknown      \" };\n\n\tif (!debug_msgs)\n\t\treturn;\n\tpr_debug(\"Dumping runlist (values in hex):\\n\");\n\tif (!rl) {\n\t\tpr_debug(\"Run list not present.\\n\");\n\t\treturn;\n\t}\n\tpr_debug(\"VCN              LCN               Run length\\n\");\n\tfor (i = 0; ; i++) {\n\t\tLCN lcn = (rl + i)->lcn;\n\n\t\tif (lcn < (LCN)0) {\n\t\t\tint index = -lcn - 1;\n\n\t\t\tif (index > -LCN_ENOENT - 1)\n\t\t\t\tindex = 3;\n\t\t\tpr_debug(\"%-16Lx %s %-16Lx%s\\n\",\n\t\t\t\t\t(long long)(rl + i)->vcn, lcn_str[index],\n\t\t\t\t\t(long long)(rl + i)->length,\n\t\t\t\t\t(rl + i)->length ? \"\" :\n\t\t\t\t\t\t\" (runlist end)\");\n\t\t} else\n\t\t\tpr_debug(\"%-16Lx %-16Lx  %-16Lx%s\\n\",\n\t\t\t\t\t(long long)(rl + i)->vcn,\n\t\t\t\t\t(long long)(rl + i)->lcn,\n\t\t\t\t\t(long long)(rl + i)->length,\n\t\t\t\t\t(rl + i)->length ? \"\" :\n\t\t\t\t\t\t\" (runlist end)\");\n\t\tif (!(rl + i)->length)\n\t\t\tbreak;\n\t}\n}",
          "includes": [
            "#include \"debug.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"debug.h\"\n\nvoid ntfs_debug_dump_runlist(const runlist_element *rl)\n{\n\tint i;\n\tconst char *lcn_str[5] = { \"LCN_HOLE         \", \"LCN_RL_NOT_MAPPED\",\n\t\t\t\t   \"LCN_ENOENT       \", \"LCN_unknown      \" };\n\n\tif (!debug_msgs)\n\t\treturn;\n\tpr_debug(\"Dumping runlist (values in hex):\\n\");\n\tif (!rl) {\n\t\tpr_debug(\"Run list not present.\\n\");\n\t\treturn;\n\t}\n\tpr_debug(\"VCN              LCN               Run length\\n\");\n\tfor (i = 0; ; i++) {\n\t\tLCN lcn = (rl + i)->lcn;\n\n\t\tif (lcn < (LCN)0) {\n\t\t\tint index = -lcn - 1;\n\n\t\t\tif (index > -LCN_ENOENT - 1)\n\t\t\t\tindex = 3;\n\t\t\tpr_debug(\"%-16Lx %s %-16Lx%s\\n\",\n\t\t\t\t\t(long long)(rl + i)->vcn, lcn_str[index],\n\t\t\t\t\t(long long)(rl + i)->length,\n\t\t\t\t\t(rl + i)->length ? \"\" :\n\t\t\t\t\t\t\" (runlist end)\");\n\t\t} else\n\t\t\tpr_debug(\"%-16Lx %-16Lx  %-16Lx%s\\n\",\n\t\t\t\t\t(long long)(rl + i)->vcn,\n\t\t\t\t\t(long long)(rl + i)->lcn,\n\t\t\t\t\t(long long)(rl + i)->length,\n\t\t\t\t\t(rl + i)->length ? \"\" :\n\t\t\t\t\t\t\" (runlist end)\");\n\t\tif (!(rl + i)->length)\n\t\t\tbreak;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "NInoSetSparseDisabled",
          "args": [
            "tmp_ni"
          ],
          "line": 1065
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NInoSetMstProtected",
          "args": [
            "tmp_ni"
          ],
          "line": 1064
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NTFS_I",
          "args": [
            "tmp_ino"
          ],
          "line": 1062
        },
        "resolved": true,
        "details": {
          "function_name": "NTFS_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/inode.h",
          "lines": "240-243",
          "snippet": "static inline ntfs_inode *NTFS_I(struct inode *inode)\n{\n\treturn (ntfs_inode *)list_entry(inode, big_ntfs_inode, vfs_inode);\n}",
          "includes": [
            "#include \"debug.h\"",
            "#include \"runlist.h\"",
            "#include \"types.h\"",
            "#include \"volume.h\"",
            "#include \"layout.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/mutex.h>",
            "#include <linux/mm.h>",
            "#include <linux/list.h>",
            "#include <linux/fs.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"debug.h\"\n#include \"runlist.h\"\n#include \"types.h\"\n#include \"volume.h\"\n#include \"layout.h\"\n#include <linux/seq_file.h>\n#include <linux/mutex.h>\n#include <linux/mm.h>\n#include <linux/list.h>\n#include <linux/fs.h>\n#include <linux/atomic.h>\n\nstatic inline ntfs_inode *NTFS_I(struct inode *inode)\n{\n\treturn (ntfs_inode *)list_entry(inode, big_ntfs_inode, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "iput",
          "args": [
            "tmp_ino"
          ],
          "line": 1044
        },
        "resolved": true,
        "details": {
          "function_name": "dentry_iput",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "308-327",
          "snippet": "static void dentry_iput(struct dentry * dentry)\n\t__releases(dentry->d_lock)\n\t__releases(dentry->d_inode->i_lock)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tif (inode) {\n\t\tdentry->d_inode = NULL;\n\t\thlist_del_init(&dentry->d_u.d_alias);\n\t\tspin_unlock(&dentry->d_lock);\n\t\tspin_unlock(&inode->i_lock);\n\t\tif (!inode->i_nlink)\n\t\t\tfsnotify_inoderemove(inode);\n\t\tif (dentry->d_op && dentry->d_op->d_iput)\n\t\t\tdentry->d_op->d_iput(dentry, inode);\n\t\telse\n\t\t\tiput(inode);\n\t} else {\n\t\tspin_unlock(&dentry->d_lock);\n\t}\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nstatic void dentry_iput(struct dentry * dentry)\n\t__releases(dentry->d_lock)\n\t__releases(dentry->d_inode->i_lock)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tif (inode) {\n\t\tdentry->d_inode = NULL;\n\t\thlist_del_init(&dentry->d_u.d_alias);\n\t\tspin_unlock(&dentry->d_lock);\n\t\tspin_unlock(&inode->i_lock);\n\t\tif (!inode->i_nlink)\n\t\t\tfsnotify_inoderemove(inode);\n\t\tif (dentry->d_op && dentry->d_op->d_iput)\n\t\t\tdentry->d_op->d_iput(dentry, inode);\n\t\telse\n\t\t\tiput(inode);\n\t} else {\n\t\tspin_unlock(&dentry->d_lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "tmp_ino"
          ],
          "line": 1043
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_bad_inode",
          "args": [
            "tmp_ino"
          ],
          "line": 1042
        },
        "resolved": true,
        "details": {
          "function_name": "is_bad_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/bad_inode.c",
          "lines": "195-198",
          "snippet": "int is_bad_inode(struct inode *inode)\n{\n\treturn (inode->i_op == &bad_inode_ops);\t\n}",
          "includes": [
            "#include <linux/poll.h>",
            "#include <linux/namei.h>",
            "#include <linux/time.h>",
            "#include <linux/stat.h>",
            "#include <linux/export.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct inode_operations bad_inode_ops =\n{\n\t.create\t\t= bad_inode_create,\n\t.lookup\t\t= bad_inode_lookup,\n\t.link\t\t= bad_inode_link,\n\t.unlink\t\t= bad_inode_unlink,\n\t.symlink\t= bad_inode_symlink,\n\t.mkdir\t\t= bad_inode_mkdir,\n\t.rmdir\t\t= bad_inode_rmdir,\n\t.mknod\t\t= bad_inode_mknod,\n\t.rename2\t= bad_inode_rename2,\n\t.readlink\t= bad_inode_readlink,\n\t/* follow_link must be no-op, otherwise unmounting this inode\n\t   won't work */\n\t/* put_link returns void */\n\t/* truncate returns void */\n\t.permission\t= bad_inode_permission,\n\t.getattr\t= bad_inode_getattr,\n\t.setattr\t= bad_inode_setattr,\n\t.setxattr\t= bad_inode_setxattr,\n\t.getxattr\t= bad_inode_getxattr,\n\t.listxattr\t= bad_inode_listxattr,\n\t.removexattr\t= bad_inode_removexattr,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/poll.h>\n#include <linux/namei.h>\n#include <linux/time.h>\n#include <linux/stat.h>\n#include <linux/export.h>\n#include <linux/fs.h>\n\nstatic const struct inode_operations bad_inode_ops =\n{\n\t.create\t\t= bad_inode_create,\n\t.lookup\t\t= bad_inode_lookup,\n\t.link\t\t= bad_inode_link,\n\t.unlink\t\t= bad_inode_unlink,\n\t.symlink\t= bad_inode_symlink,\n\t.mkdir\t\t= bad_inode_mkdir,\n\t.rmdir\t\t= bad_inode_rmdir,\n\t.mknod\t\t= bad_inode_mknod,\n\t.rename2\t= bad_inode_rename2,\n\t.readlink\t= bad_inode_readlink,\n\t/* follow_link must be no-op, otherwise unmounting this inode\n\t   won't work */\n\t/* put_link returns void */\n\t/* truncate returns void */\n\t.permission\t= bad_inode_permission,\n\t.getattr\t= bad_inode_getattr,\n\t.setattr\t= bad_inode_setattr,\n\t.setxattr\t= bad_inode_setxattr,\n\t.getxattr\t= bad_inode_getxattr,\n\t.listxattr\t= bad_inode_listxattr,\n\t.removexattr\t= bad_inode_removexattr,\n};\n\nint is_bad_inode(struct inode *inode)\n{\n\treturn (inode->i_op == &bad_inode_ops);\t\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "tmp_ino"
          ],
          "line": 1042
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_iget",
          "args": [
            "vol->sb",
            "FILE_MFTMirr"
          ],
          "line": 1041
        },
        "resolved": true,
        "details": {
          "function_name": "ntfs_iget",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/inode.c",
          "lines": "171-203",
          "snippet": "struct inode *ntfs_iget(struct super_block *sb, unsigned long mft_no)\n{\n\tstruct inode *vi;\n\tint err;\n\tntfs_attr na;\n\n\tna.mft_no = mft_no;\n\tna.type = AT_UNUSED;\n\tna.name = NULL;\n\tna.name_len = 0;\n\n\tvi = iget5_locked(sb, mft_no, (test_t)ntfs_test_inode,\n\t\t\t(set_t)ntfs_init_locked_inode, &na);\n\tif (unlikely(!vi))\n\t\treturn ERR_PTR(-ENOMEM);\n\n\terr = 0;\n\n\t/* If this is a freshly allocated inode, need to read it now. */\n\tif (vi->i_state & I_NEW) {\n\t\terr = ntfs_read_locked_inode(vi);\n\t\tunlock_new_inode(vi);\n\t}\n\t/*\n\t * There is no point in keeping bad inodes around if the failure was\n\t * due to ENOMEM. We want to be able to retry again later.\n\t */\n\tif (unlikely(err == -ENOMEM)) {\n\t\tiput(vi);\n\t\tvi = ERR_PTR(err);\n\t}\n\treturn vi;\n}",
          "includes": [
            "#include \"ntfs.h\"",
            "#include \"time.h\"",
            "#include \"mft.h\"",
            "#include \"malloc.h\"",
            "#include \"lcnalloc.h\"",
            "#include \"inode.h\"",
            "#include \"debug.h\"",
            "#include \"dir.h\"",
            "#include \"bitmap.h\"",
            "#include \"attrib.h\"",
            "#include \"aops.h\"",
            "#include <linux/aio.h>",
            "#include <linux/log2.h>",
            "#include <linux/slab.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mutex.h>",
            "#include <linux/mount.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ntfs_read_locked_inode(struct inode *vi);",
            "static int ntfs_read_locked_attr_inode(struct inode *base_vi, struct inode *vi);",
            "static int ntfs_read_locked_index_inode(struct inode *base_vi,\n\t\tstruct inode *vi);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ntfs.h\"\n#include \"time.h\"\n#include \"mft.h\"\n#include \"malloc.h\"\n#include \"lcnalloc.h\"\n#include \"inode.h\"\n#include \"debug.h\"\n#include \"dir.h\"\n#include \"bitmap.h\"\n#include \"attrib.h\"\n#include \"aops.h\"\n#include <linux/aio.h>\n#include <linux/log2.h>\n#include <linux/slab.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/mutex.h>\n#include <linux/mount.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n\nstatic int ntfs_read_locked_inode(struct inode *vi);\nstatic int ntfs_read_locked_attr_inode(struct inode *base_vi, struct inode *vi);\nstatic int ntfs_read_locked_index_inode(struct inode *base_vi,\n\t\tstruct inode *vi);\n\nstruct inode *ntfs_iget(struct super_block *sb, unsigned long mft_no)\n{\n\tstruct inode *vi;\n\tint err;\n\tntfs_attr na;\n\n\tna.mft_no = mft_no;\n\tna.type = AT_UNUSED;\n\tna.name = NULL;\n\tna.name_len = 0;\n\n\tvi = iget5_locked(sb, mft_no, (test_t)ntfs_test_inode,\n\t\t\t(set_t)ntfs_init_locked_inode, &na);\n\tif (unlikely(!vi))\n\t\treturn ERR_PTR(-ENOMEM);\n\n\terr = 0;\n\n\t/* If this is a freshly allocated inode, need to read it now. */\n\tif (vi->i_state & I_NEW) {\n\t\terr = ntfs_read_locked_inode(vi);\n\t\tunlock_new_inode(vi);\n\t}\n\t/*\n\t * There is no point in keeping bad inodes around if the failure was\n\t * due to ENOMEM. We want to be able to retry again later.\n\t */\n\tif (unlikely(err == -ENOMEM)) {\n\t\tiput(vi);\n\t\tvi = ERR_PTR(err);\n\t}\n\treturn vi;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ntfs.h\"\n#include \"malloc.h\"\n#include \"layout.h\"\n#include \"aops.h\"\n#include \"inode.h\"\n#include \"index.h\"\n#include \"debug.h\"\n#include \"dir.h\"\n#include \"usnjrnl.h\"\n#include \"quota.h\"\n#include \"logfile.h\"\n#include \"sysctl.h\"\n#include <linux/bitmap.h>\n#include <linux/moduleparam.h>\n#include <linux/vfs.h>\n#include <linux/buffer_head.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\t/* For bdev_logical_block_size(). */\n#include <linux/spinlock.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/stddef.h>\n\nstatic bool load_and_init_mft_mirror(ntfs_volume *vol)\n{\n\tstruct inode *tmp_ino;\n\tntfs_inode *tmp_ni;\n\n\tntfs_debug(\"Entering.\");\n\t/* Get mft mirror inode. */\n\ttmp_ino = ntfs_iget(vol->sb, FILE_MFTMirr);\n\tif (IS_ERR(tmp_ino) || is_bad_inode(tmp_ino)) {\n\t\tif (!IS_ERR(tmp_ino))\n\t\t\tiput(tmp_ino);\n\t\t/* Caller will display error message. */\n\t\treturn false;\n\t}\n\t/*\n\t * Re-initialize some specifics about $MFTMirr's inode as\n\t * ntfs_read_inode() will have set up the default ones.\n\t */\n\t/* Set uid and gid to root. */\n\ttmp_ino->i_uid = GLOBAL_ROOT_UID;\n\ttmp_ino->i_gid = GLOBAL_ROOT_GID;\n\t/* Regular file.  No access for anyone. */\n\ttmp_ino->i_mode = S_IFREG;\n\t/* No VFS initiated operations allowed for $MFTMirr. */\n\ttmp_ino->i_op = &ntfs_empty_inode_ops;\n\ttmp_ino->i_fop = &ntfs_empty_file_ops;\n\t/* Put in our special address space operations. */\n\ttmp_ino->i_mapping->a_ops = &ntfs_mst_aops;\n\ttmp_ni = NTFS_I(tmp_ino);\n\t/* The $MFTMirr, like the $MFT is multi sector transfer protected. */\n\tNInoSetMstProtected(tmp_ni);\n\tNInoSetSparseDisabled(tmp_ni);\n\t/*\n\t * Set up our little cheat allowing us to reuse the async read io\n\t * completion handler for directories.\n\t */\n\ttmp_ni->itype.index.block_size = vol->mft_record_size;\n\ttmp_ni->itype.index.block_size_bits = vol->mft_record_size_bits;\n\tvol->mftmirr_ino = tmp_ino;\n\tntfs_debug(\"Done.\");\n\treturn true;\n}"
  },
  {
    "function_name": "ntfs_setup_allocators",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/super.c",
    "lines": "948-1024",
    "snippet": "static void ntfs_setup_allocators(ntfs_volume *vol)\n{\n#ifdef NTFS_RW\n\tLCN mft_zone_size, mft_lcn;\n#endif /* NTFS_RW */\n\n\tntfs_debug(\"vol->mft_zone_multiplier = 0x%x\",\n\t\t\tvol->mft_zone_multiplier);\n#ifdef NTFS_RW\n\t/* Determine the size of the MFT zone. */\n\tmft_zone_size = vol->nr_clusters;\n\tswitch (vol->mft_zone_multiplier) {  /* % of volume size in clusters */\n\tcase 4:\n\t\tmft_zone_size >>= 1;\t\t\t/* 50%   */\n\t\tbreak;\n\tcase 3:\n\t\tmft_zone_size = (mft_zone_size +\n\t\t\t\t(mft_zone_size >> 1)) >> 2;\t/* 37.5% */\n\t\tbreak;\n\tcase 2:\n\t\tmft_zone_size >>= 2;\t\t\t/* 25%   */\n\t\tbreak;\n\t/* case 1: */\n\tdefault:\n\t\tmft_zone_size >>= 3;\t\t\t/* 12.5% */\n\t\tbreak;\n\t}\n\t/* Setup the mft zone. */\n\tvol->mft_zone_start = vol->mft_zone_pos = vol->mft_lcn;\n\tntfs_debug(\"vol->mft_zone_pos = 0x%llx\",\n\t\t\t(unsigned long long)vol->mft_zone_pos);\n\t/*\n\t * Calculate the mft_lcn for an unmodified NTFS volume (see mkntfs\n\t * source) and if the actual mft_lcn is in the expected place or even\n\t * further to the front of the volume, extend the mft_zone to cover the\n\t * beginning of the volume as well.  This is in order to protect the\n\t * area reserved for the mft bitmap as well within the mft_zone itself.\n\t * On non-standard volumes we do not protect it as the overhead would\n\t * be higher than the speed increase we would get by doing it.\n\t */\n\tmft_lcn = (8192 + 2 * vol->cluster_size - 1) / vol->cluster_size;\n\tif (mft_lcn * vol->cluster_size < 16 * 1024)\n\t\tmft_lcn = (16 * 1024 + vol->cluster_size - 1) /\n\t\t\t\tvol->cluster_size;\n\tif (vol->mft_zone_start <= mft_lcn)\n\t\tvol->mft_zone_start = 0;\n\tntfs_debug(\"vol->mft_zone_start = 0x%llx\",\n\t\t\t(unsigned long long)vol->mft_zone_start);\n\t/*\n\t * Need to cap the mft zone on non-standard volumes so that it does\n\t * not point outside the boundaries of the volume.  We do this by\n\t * halving the zone size until we are inside the volume.\n\t */\n\tvol->mft_zone_end = vol->mft_lcn + mft_zone_size;\n\twhile (vol->mft_zone_end >= vol->nr_clusters) {\n\t\tmft_zone_size >>= 1;\n\t\tvol->mft_zone_end = vol->mft_lcn + mft_zone_size;\n\t}\n\tntfs_debug(\"vol->mft_zone_end = 0x%llx\",\n\t\t\t(unsigned long long)vol->mft_zone_end);\n\t/*\n\t * Set the current position within each data zone to the start of the\n\t * respective zone.\n\t */\n\tvol->data1_zone_pos = vol->mft_zone_end;\n\tntfs_debug(\"vol->data1_zone_pos = 0x%llx\",\n\t\t\t(unsigned long long)vol->data1_zone_pos);\n\tvol->data2_zone_pos = 0;\n\tntfs_debug(\"vol->data2_zone_pos = 0x%llx\",\n\t\t\t(unsigned long long)vol->data2_zone_pos);\n\n\t/* Set the mft data allocation position to mft record 24. */\n\tvol->mft_data_pos = 24;\n\tntfs_debug(\"vol->mft_data_pos = 0x%llx\",\n\t\t\t(unsigned long long)vol->mft_data_pos);\n#endif /* NTFS_RW */\n}",
    "includes": [
      "#include \"ntfs.h\"",
      "#include \"malloc.h\"",
      "#include \"layout.h\"",
      "#include \"aops.h\"",
      "#include \"inode.h\"",
      "#include \"index.h\"",
      "#include \"debug.h\"",
      "#include \"dir.h\"",
      "#include \"usnjrnl.h\"",
      "#include \"quota.h\"",
      "#include \"logfile.h\"",
      "#include \"sysctl.h\"",
      "#include <linux/bitmap.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/vfs.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/blkdev.h>\t/* For bdev_logical_block_size(). */",
      "#include <linux/spinlock.h>",
      "#include <linux/string.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/stddef.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ntfs_debug",
          "args": [
            "\"vol->mft_data_pos = 0x%llx\"",
            "(unsigned long long)vol->mft_data_pos"
          ],
          "line": 1021
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_debug",
          "args": [
            "\"vol->data2_zone_pos = 0x%llx\"",
            "(unsigned long long)vol->data2_zone_pos"
          ],
          "line": 1016
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_debug",
          "args": [
            "\"vol->data1_zone_pos = 0x%llx\"",
            "(unsigned long long)vol->data1_zone_pos"
          ],
          "line": 1013
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_debug",
          "args": [
            "\"vol->mft_zone_end = 0x%llx\"",
            "(unsigned long long)vol->mft_zone_end"
          ],
          "line": 1006
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_debug",
          "args": [
            "\"vol->mft_zone_start = 0x%llx\"",
            "(unsigned long long)vol->mft_zone_start"
          ],
          "line": 994
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_debug",
          "args": [
            "\"vol->mft_zone_pos = 0x%llx\"",
            "(unsigned long long)vol->mft_zone_pos"
          ],
          "line": 977
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_debug",
          "args": [
            "\"vol->mft_zone_multiplier = 0x%x\"",
            "vol->mft_zone_multiplier"
          ],
          "line": 954
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ntfs.h\"\n#include \"malloc.h\"\n#include \"layout.h\"\n#include \"aops.h\"\n#include \"inode.h\"\n#include \"index.h\"\n#include \"debug.h\"\n#include \"dir.h\"\n#include \"usnjrnl.h\"\n#include \"quota.h\"\n#include \"logfile.h\"\n#include \"sysctl.h\"\n#include <linux/bitmap.h>\n#include <linux/moduleparam.h>\n#include <linux/vfs.h>\n#include <linux/buffer_head.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\t/* For bdev_logical_block_size(). */\n#include <linux/spinlock.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/stddef.h>\n\nstatic void ntfs_setup_allocators(ntfs_volume *vol)\n{\n#ifdef NTFS_RW\n\tLCN mft_zone_size, mft_lcn;\n#endif /* NTFS_RW */\n\n\tntfs_debug(\"vol->mft_zone_multiplier = 0x%x\",\n\t\t\tvol->mft_zone_multiplier);\n#ifdef NTFS_RW\n\t/* Determine the size of the MFT zone. */\n\tmft_zone_size = vol->nr_clusters;\n\tswitch (vol->mft_zone_multiplier) {  /* % of volume size in clusters */\n\tcase 4:\n\t\tmft_zone_size >>= 1;\t\t\t/* 50%   */\n\t\tbreak;\n\tcase 3:\n\t\tmft_zone_size = (mft_zone_size +\n\t\t\t\t(mft_zone_size >> 1)) >> 2;\t/* 37.5% */\n\t\tbreak;\n\tcase 2:\n\t\tmft_zone_size >>= 2;\t\t\t/* 25%   */\n\t\tbreak;\n\t/* case 1: */\n\tdefault:\n\t\tmft_zone_size >>= 3;\t\t\t/* 12.5% */\n\t\tbreak;\n\t}\n\t/* Setup the mft zone. */\n\tvol->mft_zone_start = vol->mft_zone_pos = vol->mft_lcn;\n\tntfs_debug(\"vol->mft_zone_pos = 0x%llx\",\n\t\t\t(unsigned long long)vol->mft_zone_pos);\n\t/*\n\t * Calculate the mft_lcn for an unmodified NTFS volume (see mkntfs\n\t * source) and if the actual mft_lcn is in the expected place or even\n\t * further to the front of the volume, extend the mft_zone to cover the\n\t * beginning of the volume as well.  This is in order to protect the\n\t * area reserved for the mft bitmap as well within the mft_zone itself.\n\t * On non-standard volumes we do not protect it as the overhead would\n\t * be higher than the speed increase we would get by doing it.\n\t */\n\tmft_lcn = (8192 + 2 * vol->cluster_size - 1) / vol->cluster_size;\n\tif (mft_lcn * vol->cluster_size < 16 * 1024)\n\t\tmft_lcn = (16 * 1024 + vol->cluster_size - 1) /\n\t\t\t\tvol->cluster_size;\n\tif (vol->mft_zone_start <= mft_lcn)\n\t\tvol->mft_zone_start = 0;\n\tntfs_debug(\"vol->mft_zone_start = 0x%llx\",\n\t\t\t(unsigned long long)vol->mft_zone_start);\n\t/*\n\t * Need to cap the mft zone on non-standard volumes so that it does\n\t * not point outside the boundaries of the volume.  We do this by\n\t * halving the zone size until we are inside the volume.\n\t */\n\tvol->mft_zone_end = vol->mft_lcn + mft_zone_size;\n\twhile (vol->mft_zone_end >= vol->nr_clusters) {\n\t\tmft_zone_size >>= 1;\n\t\tvol->mft_zone_end = vol->mft_lcn + mft_zone_size;\n\t}\n\tntfs_debug(\"vol->mft_zone_end = 0x%llx\",\n\t\t\t(unsigned long long)vol->mft_zone_end);\n\t/*\n\t * Set the current position within each data zone to the start of the\n\t * respective zone.\n\t */\n\tvol->data1_zone_pos = vol->mft_zone_end;\n\tntfs_debug(\"vol->data1_zone_pos = 0x%llx\",\n\t\t\t(unsigned long long)vol->data1_zone_pos);\n\tvol->data2_zone_pos = 0;\n\tntfs_debug(\"vol->data2_zone_pos = 0x%llx\",\n\t\t\t(unsigned long long)vol->data2_zone_pos);\n\n\t/* Set the mft data allocation position to mft record 24. */\n\tvol->mft_data_pos = 24;\n\tntfs_debug(\"vol->mft_data_pos = 0x%llx\",\n\t\t\t(unsigned long long)vol->mft_data_pos);\n#endif /* NTFS_RW */\n}"
  },
  {
    "function_name": "parse_ntfs_boot_sector",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/super.c",
    "lines": "766-940",
    "snippet": "static bool parse_ntfs_boot_sector(ntfs_volume *vol, const NTFS_BOOT_SECTOR *b)\n{\n\tunsigned int sectors_per_cluster_bits, nr_hidden_sects;\n\tint clusters_per_mft_record, clusters_per_index_record;\n\ts64 ll;\n\n\tvol->sector_size = le16_to_cpu(b->bpb.bytes_per_sector);\n\tvol->sector_size_bits = ffs(vol->sector_size) - 1;\n\tntfs_debug(\"vol->sector_size = %i (0x%x)\", vol->sector_size,\n\t\t\tvol->sector_size);\n\tntfs_debug(\"vol->sector_size_bits = %i (0x%x)\", vol->sector_size_bits,\n\t\t\tvol->sector_size_bits);\n\tif (vol->sector_size < vol->sb->s_blocksize) {\n\t\tntfs_error(vol->sb, \"Sector size (%i) is smaller than the \"\n\t\t\t\t\"device block size (%lu).  This is not \"\n\t\t\t\t\"supported.  Sorry.\", vol->sector_size,\n\t\t\t\tvol->sb->s_blocksize);\n\t\treturn false;\n\t}\n\tntfs_debug(\"sectors_per_cluster = 0x%x\", b->bpb.sectors_per_cluster);\n\tsectors_per_cluster_bits = ffs(b->bpb.sectors_per_cluster) - 1;\n\tntfs_debug(\"sectors_per_cluster_bits = 0x%x\",\n\t\t\tsectors_per_cluster_bits);\n\tnr_hidden_sects = le32_to_cpu(b->bpb.hidden_sectors);\n\tntfs_debug(\"number of hidden sectors = 0x%x\", nr_hidden_sects);\n\tvol->cluster_size = vol->sector_size << sectors_per_cluster_bits;\n\tvol->cluster_size_mask = vol->cluster_size - 1;\n\tvol->cluster_size_bits = ffs(vol->cluster_size) - 1;\n\tntfs_debug(\"vol->cluster_size = %i (0x%x)\", vol->cluster_size,\n\t\t\tvol->cluster_size);\n\tntfs_debug(\"vol->cluster_size_mask = 0x%x\", vol->cluster_size_mask);\n\tntfs_debug(\"vol->cluster_size_bits = %i\", vol->cluster_size_bits);\n\tif (vol->cluster_size < vol->sector_size) {\n\t\tntfs_error(vol->sb, \"Cluster size (%i) is smaller than the \"\n\t\t\t\t\"sector size (%i).  This is not supported.  \"\n\t\t\t\t\"Sorry.\", vol->cluster_size, vol->sector_size);\n\t\treturn false;\n\t}\n\tclusters_per_mft_record = b->clusters_per_mft_record;\n\tntfs_debug(\"clusters_per_mft_record = %i (0x%x)\",\n\t\t\tclusters_per_mft_record, clusters_per_mft_record);\n\tif (clusters_per_mft_record > 0)\n\t\tvol->mft_record_size = vol->cluster_size <<\n\t\t\t\t(ffs(clusters_per_mft_record) - 1);\n\telse\n\t\t/*\n\t\t * When mft_record_size < cluster_size, clusters_per_mft_record\n\t\t * = -log2(mft_record_size) bytes. mft_record_size normaly is\n\t\t * 1024 bytes, which is encoded as 0xF6 (-10 in decimal).\n\t\t */\n\t\tvol->mft_record_size = 1 << -clusters_per_mft_record;\n\tvol->mft_record_size_mask = vol->mft_record_size - 1;\n\tvol->mft_record_size_bits = ffs(vol->mft_record_size) - 1;\n\tntfs_debug(\"vol->mft_record_size = %i (0x%x)\", vol->mft_record_size,\n\t\t\tvol->mft_record_size);\n\tntfs_debug(\"vol->mft_record_size_mask = 0x%x\",\n\t\t\tvol->mft_record_size_mask);\n\tntfs_debug(\"vol->mft_record_size_bits = %i (0x%x)\",\n\t\t\tvol->mft_record_size_bits, vol->mft_record_size_bits);\n\t/*\n\t * We cannot support mft record sizes above the PAGE_CACHE_SIZE since\n\t * we store $MFT/$DATA, the table of mft records in the page cache.\n\t */\n\tif (vol->mft_record_size > PAGE_CACHE_SIZE) {\n\t\tntfs_error(vol->sb, \"Mft record size (%i) exceeds the \"\n\t\t\t\t\"PAGE_CACHE_SIZE on your system (%lu).  \"\n\t\t\t\t\"This is not supported.  Sorry.\",\n\t\t\t\tvol->mft_record_size, PAGE_CACHE_SIZE);\n\t\treturn false;\n\t}\n\t/* We cannot support mft record sizes below the sector size. */\n\tif (vol->mft_record_size < vol->sector_size) {\n\t\tntfs_error(vol->sb, \"Mft record size (%i) is smaller than the \"\n\t\t\t\t\"sector size (%i).  This is not supported.  \"\n\t\t\t\t\"Sorry.\", vol->mft_record_size,\n\t\t\t\tvol->sector_size);\n\t\treturn false;\n\t}\n\tclusters_per_index_record = b->clusters_per_index_record;\n\tntfs_debug(\"clusters_per_index_record = %i (0x%x)\",\n\t\t\tclusters_per_index_record, clusters_per_index_record);\n\tif (clusters_per_index_record > 0)\n\t\tvol->index_record_size = vol->cluster_size <<\n\t\t\t\t(ffs(clusters_per_index_record) - 1);\n\telse\n\t\t/*\n\t\t * When index_record_size < cluster_size,\n\t\t * clusters_per_index_record = -log2(index_record_size) bytes.\n\t\t * index_record_size normaly equals 4096 bytes, which is\n\t\t * encoded as 0xF4 (-12 in decimal).\n\t\t */\n\t\tvol->index_record_size = 1 << -clusters_per_index_record;\n\tvol->index_record_size_mask = vol->index_record_size - 1;\n\tvol->index_record_size_bits = ffs(vol->index_record_size) - 1;\n\tntfs_debug(\"vol->index_record_size = %i (0x%x)\",\n\t\t\tvol->index_record_size, vol->index_record_size);\n\tntfs_debug(\"vol->index_record_size_mask = 0x%x\",\n\t\t\tvol->index_record_size_mask);\n\tntfs_debug(\"vol->index_record_size_bits = %i (0x%x)\",\n\t\t\tvol->index_record_size_bits,\n\t\t\tvol->index_record_size_bits);\n\t/* We cannot support index record sizes below the sector size. */\n\tif (vol->index_record_size < vol->sector_size) {\n\t\tntfs_error(vol->sb, \"Index record size (%i) is smaller than \"\n\t\t\t\t\"the sector size (%i).  This is not \"\n\t\t\t\t\"supported.  Sorry.\", vol->index_record_size,\n\t\t\t\tvol->sector_size);\n\t\treturn false;\n\t}\n\t/*\n\t * Get the size of the volume in clusters and check for 64-bit-ness.\n\t * Windows currently only uses 32 bits to save the clusters so we do\n\t * the same as it is much faster on 32-bit CPUs.\n\t */\n\tll = sle64_to_cpu(b->number_of_sectors) >> sectors_per_cluster_bits;\n\tif ((u64)ll >= 1ULL << 32) {\n\t\tntfs_error(vol->sb, \"Cannot handle 64-bit clusters.  Sorry.\");\n\t\treturn false;\n\t}\n\tvol->nr_clusters = ll;\n\tntfs_debug(\"vol->nr_clusters = 0x%llx\", (long long)vol->nr_clusters);\n\t/*\n\t * On an architecture where unsigned long is 32-bits, we restrict the\n\t * volume size to 2TiB (2^41). On a 64-bit architecture, the compiler\n\t * will hopefully optimize the whole check away.\n\t */\n\tif (sizeof(unsigned long) < 8) {\n\t\tif ((ll << vol->cluster_size_bits) >= (1ULL << 41)) {\n\t\t\tntfs_error(vol->sb, \"Volume size (%lluTiB) is too \"\n\t\t\t\t\t\"large for this architecture.  \"\n\t\t\t\t\t\"Maximum supported is 2TiB.  Sorry.\",\n\t\t\t\t\t(unsigned long long)ll >> (40 -\n\t\t\t\t\tvol->cluster_size_bits));\n\t\t\treturn false;\n\t\t}\n\t}\n\tll = sle64_to_cpu(b->mft_lcn);\n\tif (ll >= vol->nr_clusters) {\n\t\tntfs_error(vol->sb, \"MFT LCN (%lli, 0x%llx) is beyond end of \"\n\t\t\t\t\"volume.  Weird.\", (unsigned long long)ll,\n\t\t\t\t(unsigned long long)ll);\n\t\treturn false;\n\t}\n\tvol->mft_lcn = ll;\n\tntfs_debug(\"vol->mft_lcn = 0x%llx\", (long long)vol->mft_lcn);\n\tll = sle64_to_cpu(b->mftmirr_lcn);\n\tif (ll >= vol->nr_clusters) {\n\t\tntfs_error(vol->sb, \"MFTMirr LCN (%lli, 0x%llx) is beyond end \"\n\t\t\t\t\"of volume.  Weird.\", (unsigned long long)ll,\n\t\t\t\t(unsigned long long)ll);\n\t\treturn false;\n\t}\n\tvol->mftmirr_lcn = ll;\n\tntfs_debug(\"vol->mftmirr_lcn = 0x%llx\", (long long)vol->mftmirr_lcn);\n#ifdef NTFS_RW\n\t/*\n\t * Work out the size of the mft mirror in number of mft records. If the\n\t * cluster size is less than or equal to the size taken by four mft\n\t * records, the mft mirror stores the first four mft records. If the\n\t * cluster size is bigger than the size taken by four mft records, the\n\t * mft mirror contains as many mft records as will fit into one\n\t * cluster.\n\t */\n\tif (vol->cluster_size <= (4 << vol->mft_record_size_bits))\n\t\tvol->mftmirr_size = 4;\n\telse\n\t\tvol->mftmirr_size = vol->cluster_size >>\n\t\t\t\tvol->mft_record_size_bits;\n\tntfs_debug(\"vol->mftmirr_size = %i\", vol->mftmirr_size);\n#endif /* NTFS_RW */\n\tvol->serial_no = le64_to_cpu(b->volume_serial_number);\n\tntfs_debug(\"vol->serial_no = 0x%llx\",\n\t\t\t(unsigned long long)vol->serial_no);\n\treturn true;\n}",
    "includes": [
      "#include \"ntfs.h\"",
      "#include \"malloc.h\"",
      "#include \"layout.h\"",
      "#include \"aops.h\"",
      "#include \"inode.h\"",
      "#include \"index.h\"",
      "#include \"debug.h\"",
      "#include \"dir.h\"",
      "#include \"usnjrnl.h\"",
      "#include \"quota.h\"",
      "#include \"logfile.h\"",
      "#include \"sysctl.h\"",
      "#include <linux/bitmap.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/vfs.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/blkdev.h>\t/* For bdev_logical_block_size(). */",
      "#include <linux/spinlock.h>",
      "#include <linux/string.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/stddef.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ntfs_debug",
          "args": [
            "\"vol->serial_no = 0x%llx\"",
            "(unsigned long long)vol->serial_no"
          ],
          "line": 937
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le64_to_cpu",
          "args": [
            "b->volume_serial_number"
          ],
          "line": 936
        },
        "resolved": true,
        "details": {
          "function_name": "sle64_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "58-61",
          "snippet": "static inline s64 sle64_to_cpup(sle64 *x)\n{\n\treturn le64_to_cpu(*(__force le64*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s64 sle64_to_cpup(sle64 *x)\n{\n\treturn le64_to_cpu(*(__force le64*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ntfs_debug",
          "args": [
            "\"vol->mftmirr_size = %i\"",
            "vol->mftmirr_size"
          ],
          "line": 934
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_debug",
          "args": [
            "\"vol->mftmirr_lcn = 0x%llx\"",
            "(long long)vol->mftmirr_lcn"
          ],
          "line": 919
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_error",
          "args": [
            "vol->sb",
            "\"MFTMirr LCN (%lli, 0x%llx) is beyond end \"\n\t\t\t\t\"of volume.  Weird.\"",
            "(unsigned long long)ll",
            "(unsigned long long)ll"
          ],
          "line": 913
        },
        "resolved": true,
        "details": {
          "function_name": "__ntfs_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/debug.c",
          "lines": "86-108",
          "snippet": "void __ntfs_error(const char *function, const struct super_block *sb,\n\t\tconst char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\tint flen = 0;\n\n#ifndef DEBUG\n\tif (!printk_ratelimit())\n\t\treturn;\n#endif\n\tif (function)\n\t\tflen = strlen(function);\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tif (sb)\n\t\tpr_err(\"(device %s): %s(): %pV\\n\",\n\t\t       sb->s_id, flen ? function : \"\", &vaf);\n\telse\n\t\tpr_err(\"%s(): %pV\\n\", flen ? function : \"\", &vaf);\n\tva_end(args);\n}",
          "includes": [
            "#include \"debug.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"debug.h\"\n\nvoid __ntfs_error(const char *function, const struct super_block *sb,\n\t\tconst char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\tint flen = 0;\n\n#ifndef DEBUG\n\tif (!printk_ratelimit())\n\t\treturn;\n#endif\n\tif (function)\n\t\tflen = strlen(function);\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tif (sb)\n\t\tpr_err(\"(device %s): %s(): %pV\\n\",\n\t\t       sb->s_id, flen ? function : \"\", &vaf);\n\telse\n\t\tpr_err(\"%s(): %pV\\n\", flen ? function : \"\", &vaf);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ntfs_debug",
          "args": [
            "\"vol->mft_lcn = 0x%llx\"",
            "(long long)vol->mft_lcn"
          ],
          "line": 910
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_debug",
          "args": [
            "\"vol->nr_clusters = 0x%llx\"",
            "(long long)vol->nr_clusters"
          ],
          "line": 886
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_error",
          "args": [
            "vol->sb",
            "\"Cannot handle 64-bit clusters.  Sorry.\""
          ],
          "line": 882
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_debug",
          "args": [
            "\"vol->index_record_size_bits = %i (0x%x)\"",
            "vol->index_record_size_bits",
            "vol->index_record_size_bits"
          ],
          "line": 864
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_debug",
          "args": [
            "\"vol->index_record_size_mask = 0x%x\"",
            "vol->index_record_size_mask"
          ],
          "line": 862
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_debug",
          "args": [
            "\"vol->index_record_size = %i (0x%x)\"",
            "vol->index_record_size",
            "vol->index_record_size"
          ],
          "line": 860
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ffs",
          "args": [
            "vol->index_record_size"
          ],
          "line": 859
        },
        "resolved": true,
        "details": {
          "function_name": "affs_kill_sb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/affs/super.c",
          "lines": "597-608",
          "snippet": "static void affs_kill_sb(struct super_block *sb)\n{\n\tstruct affs_sb_info *sbi = AFFS_SB(sb);\n\tkill_block_super(sb);\n\tif (sbi) {\n\t\taffs_free_bitmap(sb);\n\t\taffs_brelse(sbi->s_root_bh);\n\t\tkfree(sbi->s_prefix);\n\t\tmutex_destroy(&sbi->s_bmlock);\n\t\tkfree(sbi);\n\t}\n}",
          "includes": [
            "#include \"affs.h\"",
            "#include <linux/writeback.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/magic.h>",
            "#include <linux/parser.h>",
            "#include <linux/statfs.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"affs.h\"\n#include <linux/writeback.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/magic.h>\n#include <linux/parser.h>\n#include <linux/statfs.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstatic void affs_kill_sb(struct super_block *sb)\n{\n\tstruct affs_sb_info *sbi = AFFS_SB(sb);\n\tkill_block_super(sb);\n\tif (sbi) {\n\t\taffs_free_bitmap(sb);\n\t\taffs_brelse(sbi->s_root_bh);\n\t\tkfree(sbi->s_prefix);\n\t\tmutex_destroy(&sbi->s_bmlock);\n\t\tkfree(sbi);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ntfs_debug",
          "args": [
            "\"clusters_per_index_record = %i (0x%x)\"",
            "clusters_per_index_record",
            "clusters_per_index_record"
          ],
          "line": 845
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_debug",
          "args": [
            "\"vol->mft_record_size_bits = %i (0x%x)\"",
            "vol->mft_record_size_bits",
            "vol->mft_record_size_bits"
          ],
          "line": 823
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_debug",
          "args": [
            "\"vol->mft_record_size_mask = 0x%x\"",
            "vol->mft_record_size_mask"
          ],
          "line": 821
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_debug",
          "args": [
            "\"vol->mft_record_size = %i (0x%x)\"",
            "vol->mft_record_size",
            "vol->mft_record_size"
          ],
          "line": 819
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_debug",
          "args": [
            "\"clusters_per_mft_record = %i (0x%x)\"",
            "clusters_per_mft_record",
            "clusters_per_mft_record"
          ],
          "line": 805
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_debug",
          "args": [
            "\"vol->cluster_size_bits = %i\"",
            "vol->cluster_size_bits"
          ],
          "line": 797
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_debug",
          "args": [
            "\"vol->cluster_size_mask = 0x%x\"",
            "vol->cluster_size_mask"
          ],
          "line": 796
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_debug",
          "args": [
            "\"vol->cluster_size = %i (0x%x)\"",
            "vol->cluster_size",
            "vol->cluster_size"
          ],
          "line": 794
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_debug",
          "args": [
            "\"number of hidden sectors = 0x%x\"",
            "nr_hidden_sects"
          ],
          "line": 790
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "b->bpb.hidden_sectors"
          ],
          "line": 789
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ntfs_debug",
          "args": [
            "\"sectors_per_cluster_bits = 0x%x\"",
            "sectors_per_cluster_bits"
          ],
          "line": 787
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_debug",
          "args": [
            "\"sectors_per_cluster = 0x%x\"",
            "b->bpb.sectors_per_cluster"
          ],
          "line": 785
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_debug",
          "args": [
            "\"vol->sector_size_bits = %i (0x%x)\"",
            "vol->sector_size_bits",
            "vol->sector_size_bits"
          ],
          "line": 776
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_debug",
          "args": [
            "\"vol->sector_size = %i (0x%x)\"",
            "vol->sector_size",
            "vol->sector_size"
          ],
          "line": 774
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le16_to_cpu",
          "args": [
            "b->bpb.bytes_per_sector"
          ],
          "line": 772
        },
        "resolved": true,
        "details": {
          "function_name": "sle16_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "48-51",
          "snippet": "static inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ntfs.h\"\n#include \"malloc.h\"\n#include \"layout.h\"\n#include \"aops.h\"\n#include \"inode.h\"\n#include \"index.h\"\n#include \"debug.h\"\n#include \"dir.h\"\n#include \"usnjrnl.h\"\n#include \"quota.h\"\n#include \"logfile.h\"\n#include \"sysctl.h\"\n#include <linux/bitmap.h>\n#include <linux/moduleparam.h>\n#include <linux/vfs.h>\n#include <linux/buffer_head.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\t/* For bdev_logical_block_size(). */\n#include <linux/spinlock.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/stddef.h>\n\nstatic bool parse_ntfs_boot_sector(ntfs_volume *vol, const NTFS_BOOT_SECTOR *b)\n{\n\tunsigned int sectors_per_cluster_bits, nr_hidden_sects;\n\tint clusters_per_mft_record, clusters_per_index_record;\n\ts64 ll;\n\n\tvol->sector_size = le16_to_cpu(b->bpb.bytes_per_sector);\n\tvol->sector_size_bits = ffs(vol->sector_size) - 1;\n\tntfs_debug(\"vol->sector_size = %i (0x%x)\", vol->sector_size,\n\t\t\tvol->sector_size);\n\tntfs_debug(\"vol->sector_size_bits = %i (0x%x)\", vol->sector_size_bits,\n\t\t\tvol->sector_size_bits);\n\tif (vol->sector_size < vol->sb->s_blocksize) {\n\t\tntfs_error(vol->sb, \"Sector size (%i) is smaller than the \"\n\t\t\t\t\"device block size (%lu).  This is not \"\n\t\t\t\t\"supported.  Sorry.\", vol->sector_size,\n\t\t\t\tvol->sb->s_blocksize);\n\t\treturn false;\n\t}\n\tntfs_debug(\"sectors_per_cluster = 0x%x\", b->bpb.sectors_per_cluster);\n\tsectors_per_cluster_bits = ffs(b->bpb.sectors_per_cluster) - 1;\n\tntfs_debug(\"sectors_per_cluster_bits = 0x%x\",\n\t\t\tsectors_per_cluster_bits);\n\tnr_hidden_sects = le32_to_cpu(b->bpb.hidden_sectors);\n\tntfs_debug(\"number of hidden sectors = 0x%x\", nr_hidden_sects);\n\tvol->cluster_size = vol->sector_size << sectors_per_cluster_bits;\n\tvol->cluster_size_mask = vol->cluster_size - 1;\n\tvol->cluster_size_bits = ffs(vol->cluster_size) - 1;\n\tntfs_debug(\"vol->cluster_size = %i (0x%x)\", vol->cluster_size,\n\t\t\tvol->cluster_size);\n\tntfs_debug(\"vol->cluster_size_mask = 0x%x\", vol->cluster_size_mask);\n\tntfs_debug(\"vol->cluster_size_bits = %i\", vol->cluster_size_bits);\n\tif (vol->cluster_size < vol->sector_size) {\n\t\tntfs_error(vol->sb, \"Cluster size (%i) is smaller than the \"\n\t\t\t\t\"sector size (%i).  This is not supported.  \"\n\t\t\t\t\"Sorry.\", vol->cluster_size, vol->sector_size);\n\t\treturn false;\n\t}\n\tclusters_per_mft_record = b->clusters_per_mft_record;\n\tntfs_debug(\"clusters_per_mft_record = %i (0x%x)\",\n\t\t\tclusters_per_mft_record, clusters_per_mft_record);\n\tif (clusters_per_mft_record > 0)\n\t\tvol->mft_record_size = vol->cluster_size <<\n\t\t\t\t(ffs(clusters_per_mft_record) - 1);\n\telse\n\t\t/*\n\t\t * When mft_record_size < cluster_size, clusters_per_mft_record\n\t\t * = -log2(mft_record_size) bytes. mft_record_size normaly is\n\t\t * 1024 bytes, which is encoded as 0xF6 (-10 in decimal).\n\t\t */\n\t\tvol->mft_record_size = 1 << -clusters_per_mft_record;\n\tvol->mft_record_size_mask = vol->mft_record_size - 1;\n\tvol->mft_record_size_bits = ffs(vol->mft_record_size) - 1;\n\tntfs_debug(\"vol->mft_record_size = %i (0x%x)\", vol->mft_record_size,\n\t\t\tvol->mft_record_size);\n\tntfs_debug(\"vol->mft_record_size_mask = 0x%x\",\n\t\t\tvol->mft_record_size_mask);\n\tntfs_debug(\"vol->mft_record_size_bits = %i (0x%x)\",\n\t\t\tvol->mft_record_size_bits, vol->mft_record_size_bits);\n\t/*\n\t * We cannot support mft record sizes above the PAGE_CACHE_SIZE since\n\t * we store $MFT/$DATA, the table of mft records in the page cache.\n\t */\n\tif (vol->mft_record_size > PAGE_CACHE_SIZE) {\n\t\tntfs_error(vol->sb, \"Mft record size (%i) exceeds the \"\n\t\t\t\t\"PAGE_CACHE_SIZE on your system (%lu).  \"\n\t\t\t\t\"This is not supported.  Sorry.\",\n\t\t\t\tvol->mft_record_size, PAGE_CACHE_SIZE);\n\t\treturn false;\n\t}\n\t/* We cannot support mft record sizes below the sector size. */\n\tif (vol->mft_record_size < vol->sector_size) {\n\t\tntfs_error(vol->sb, \"Mft record size (%i) is smaller than the \"\n\t\t\t\t\"sector size (%i).  This is not supported.  \"\n\t\t\t\t\"Sorry.\", vol->mft_record_size,\n\t\t\t\tvol->sector_size);\n\t\treturn false;\n\t}\n\tclusters_per_index_record = b->clusters_per_index_record;\n\tntfs_debug(\"clusters_per_index_record = %i (0x%x)\",\n\t\t\tclusters_per_index_record, clusters_per_index_record);\n\tif (clusters_per_index_record > 0)\n\t\tvol->index_record_size = vol->cluster_size <<\n\t\t\t\t(ffs(clusters_per_index_record) - 1);\n\telse\n\t\t/*\n\t\t * When index_record_size < cluster_size,\n\t\t * clusters_per_index_record = -log2(index_record_size) bytes.\n\t\t * index_record_size normaly equals 4096 bytes, which is\n\t\t * encoded as 0xF4 (-12 in decimal).\n\t\t */\n\t\tvol->index_record_size = 1 << -clusters_per_index_record;\n\tvol->index_record_size_mask = vol->index_record_size - 1;\n\tvol->index_record_size_bits = ffs(vol->index_record_size) - 1;\n\tntfs_debug(\"vol->index_record_size = %i (0x%x)\",\n\t\t\tvol->index_record_size, vol->index_record_size);\n\tntfs_debug(\"vol->index_record_size_mask = 0x%x\",\n\t\t\tvol->index_record_size_mask);\n\tntfs_debug(\"vol->index_record_size_bits = %i (0x%x)\",\n\t\t\tvol->index_record_size_bits,\n\t\t\tvol->index_record_size_bits);\n\t/* We cannot support index record sizes below the sector size. */\n\tif (vol->index_record_size < vol->sector_size) {\n\t\tntfs_error(vol->sb, \"Index record size (%i) is smaller than \"\n\t\t\t\t\"the sector size (%i).  This is not \"\n\t\t\t\t\"supported.  Sorry.\", vol->index_record_size,\n\t\t\t\tvol->sector_size);\n\t\treturn false;\n\t}\n\t/*\n\t * Get the size of the volume in clusters and check for 64-bit-ness.\n\t * Windows currently only uses 32 bits to save the clusters so we do\n\t * the same as it is much faster on 32-bit CPUs.\n\t */\n\tll = sle64_to_cpu(b->number_of_sectors) >> sectors_per_cluster_bits;\n\tif ((u64)ll >= 1ULL << 32) {\n\t\tntfs_error(vol->sb, \"Cannot handle 64-bit clusters.  Sorry.\");\n\t\treturn false;\n\t}\n\tvol->nr_clusters = ll;\n\tntfs_debug(\"vol->nr_clusters = 0x%llx\", (long long)vol->nr_clusters);\n\t/*\n\t * On an architecture where unsigned long is 32-bits, we restrict the\n\t * volume size to 2TiB (2^41). On a 64-bit architecture, the compiler\n\t * will hopefully optimize the whole check away.\n\t */\n\tif (sizeof(unsigned long) < 8) {\n\t\tif ((ll << vol->cluster_size_bits) >= (1ULL << 41)) {\n\t\t\tntfs_error(vol->sb, \"Volume size (%lluTiB) is too \"\n\t\t\t\t\t\"large for this architecture.  \"\n\t\t\t\t\t\"Maximum supported is 2TiB.  Sorry.\",\n\t\t\t\t\t(unsigned long long)ll >> (40 -\n\t\t\t\t\tvol->cluster_size_bits));\n\t\t\treturn false;\n\t\t}\n\t}\n\tll = sle64_to_cpu(b->mft_lcn);\n\tif (ll >= vol->nr_clusters) {\n\t\tntfs_error(vol->sb, \"MFT LCN (%lli, 0x%llx) is beyond end of \"\n\t\t\t\t\"volume.  Weird.\", (unsigned long long)ll,\n\t\t\t\t(unsigned long long)ll);\n\t\treturn false;\n\t}\n\tvol->mft_lcn = ll;\n\tntfs_debug(\"vol->mft_lcn = 0x%llx\", (long long)vol->mft_lcn);\n\tll = sle64_to_cpu(b->mftmirr_lcn);\n\tif (ll >= vol->nr_clusters) {\n\t\tntfs_error(vol->sb, \"MFTMirr LCN (%lli, 0x%llx) is beyond end \"\n\t\t\t\t\"of volume.  Weird.\", (unsigned long long)ll,\n\t\t\t\t(unsigned long long)ll);\n\t\treturn false;\n\t}\n\tvol->mftmirr_lcn = ll;\n\tntfs_debug(\"vol->mftmirr_lcn = 0x%llx\", (long long)vol->mftmirr_lcn);\n#ifdef NTFS_RW\n\t/*\n\t * Work out the size of the mft mirror in number of mft records. If the\n\t * cluster size is less than or equal to the size taken by four mft\n\t * records, the mft mirror stores the first four mft records. If the\n\t * cluster size is bigger than the size taken by four mft records, the\n\t * mft mirror contains as many mft records as will fit into one\n\t * cluster.\n\t */\n\tif (vol->cluster_size <= (4 << vol->mft_record_size_bits))\n\t\tvol->mftmirr_size = 4;\n\telse\n\t\tvol->mftmirr_size = vol->cluster_size >>\n\t\t\t\tvol->mft_record_size_bits;\n\tntfs_debug(\"vol->mftmirr_size = %i\", vol->mftmirr_size);\n#endif /* NTFS_RW */\n\tvol->serial_no = le64_to_cpu(b->volume_serial_number);\n\tntfs_debug(\"vol->serial_no = 0x%llx\",\n\t\t\t(unsigned long long)vol->serial_no);\n\treturn true;\n}"
  },
  {
    "function_name": "read_ntfs_boot_sector",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/super.c",
    "lines": "676-756",
    "snippet": "static struct buffer_head *read_ntfs_boot_sector(struct super_block *sb,\n\t\tconst int silent)\n{\n\tconst char *read_err_str = \"Unable to read %s boot sector.\";\n\tstruct buffer_head *bh_primary, *bh_backup;\n\tsector_t nr_blocks = NTFS_SB(sb)->nr_blocks;\n\n\t/* Try to read primary boot sector. */\n\tif ((bh_primary = sb_bread(sb, 0))) {\n\t\tif (is_boot_sector_ntfs(sb, (NTFS_BOOT_SECTOR*)\n\t\t\t\tbh_primary->b_data, silent))\n\t\t\treturn bh_primary;\n\t\tif (!silent)\n\t\t\tntfs_error(sb, \"Primary boot sector is invalid.\");\n\t} else if (!silent)\n\t\tntfs_error(sb, read_err_str, \"primary\");\n\tif (!(NTFS_SB(sb)->on_errors & ON_ERRORS_RECOVER)) {\n\t\tif (bh_primary)\n\t\t\tbrelse(bh_primary);\n\t\tif (!silent)\n\t\t\tntfs_error(sb, \"Mount option errors=recover not used. \"\n\t\t\t\t\t\"Aborting without trying to recover.\");\n\t\treturn NULL;\n\t}\n\t/* Try to read NT4+ backup boot sector. */\n\tif ((bh_backup = sb_bread(sb, nr_blocks - 1))) {\n\t\tif (is_boot_sector_ntfs(sb, (NTFS_BOOT_SECTOR*)\n\t\t\t\tbh_backup->b_data, silent))\n\t\t\tgoto hotfix_primary_boot_sector;\n\t\tbrelse(bh_backup);\n\t} else if (!silent)\n\t\tntfs_error(sb, read_err_str, \"backup\");\n\t/* Try to read NT3.51- backup boot sector. */\n\tif ((bh_backup = sb_bread(sb, nr_blocks >> 1))) {\n\t\tif (is_boot_sector_ntfs(sb, (NTFS_BOOT_SECTOR*)\n\t\t\t\tbh_backup->b_data, silent))\n\t\t\tgoto hotfix_primary_boot_sector;\n\t\tif (!silent)\n\t\t\tntfs_error(sb, \"Could not find a valid backup boot \"\n\t\t\t\t\t\"sector.\");\n\t\tbrelse(bh_backup);\n\t} else if (!silent)\n\t\tntfs_error(sb, read_err_str, \"backup\");\n\t/* We failed. Cleanup and return. */\n\tif (bh_primary)\n\t\tbrelse(bh_primary);\n\treturn NULL;\nhotfix_primary_boot_sector:\n\tif (bh_primary) {\n\t\t/*\n\t\t * If we managed to read sector zero and the volume is not\n\t\t * read-only, copy the found, valid backup boot sector to the\n\t\t * primary boot sector.  Note we only copy the actual boot\n\t\t * sector structure, not the actual whole device sector as that\n\t\t * may be bigger and would potentially damage the $Boot system\n\t\t * file (FIXME: Would be nice to know if the backup boot sector\n\t\t * on a large sector device contains the whole boot loader or\n\t\t * just the first 512 bytes).\n\t\t */\n\t\tif (!(sb->s_flags & MS_RDONLY)) {\n\t\t\tntfs_warning(sb, \"Hot-fix: Recovering invalid primary \"\n\t\t\t\t\t\"boot sector from backup copy.\");\n\t\t\tmemcpy(bh_primary->b_data, bh_backup->b_data,\n\t\t\t\t\tNTFS_BLOCK_SIZE);\n\t\t\tmark_buffer_dirty(bh_primary);\n\t\t\tsync_dirty_buffer(bh_primary);\n\t\t\tif (buffer_uptodate(bh_primary)) {\n\t\t\t\tbrelse(bh_backup);\n\t\t\t\treturn bh_primary;\n\t\t\t}\n\t\t\tntfs_error(sb, \"Hot-fix: Device write error while \"\n\t\t\t\t\t\"recovering primary boot sector.\");\n\t\t} else {\n\t\t\tntfs_warning(sb, \"Hot-fix: Recovery of primary boot \"\n\t\t\t\t\t\"sector failed: Read-only mount.\");\n\t\t}\n\t\tbrelse(bh_primary);\n\t}\n\tntfs_warning(sb, \"Using backup boot sector.\");\n\treturn bh_backup;\n}",
    "includes": [
      "#include \"ntfs.h\"",
      "#include \"malloc.h\"",
      "#include \"layout.h\"",
      "#include \"aops.h\"",
      "#include \"inode.h\"",
      "#include \"index.h\"",
      "#include \"debug.h\"",
      "#include \"dir.h\"",
      "#include \"usnjrnl.h\"",
      "#include \"quota.h\"",
      "#include \"logfile.h\"",
      "#include \"sysctl.h\"",
      "#include <linux/bitmap.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/vfs.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/blkdev.h>\t/* For bdev_logical_block_size(). */",
      "#include <linux/spinlock.h>",
      "#include <linux/string.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/stddef.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ntfs_warning",
          "args": [
            "sb",
            "\"Using backup boot sector.\""
          ],
          "line": 754
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "bh_primary"
          ],
          "line": 752
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "ntfs_warning",
          "args": [
            "sb",
            "\"Hot-fix: Recovery of primary boot \"\n\t\t\t\t\t\"sector failed: Read-only mount.\""
          ],
          "line": 749
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_error",
          "args": [
            "sb",
            "\"Hot-fix: Device write error while \"\n\t\t\t\t\t\"recovering primary boot sector.\""
          ],
          "line": 746
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "buffer_uptodate",
          "args": [
            "bh_primary"
          ],
          "line": 742
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_set_buffer_uptodate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/disk-io.c",
          "lines": "3758-3761",
          "snippet": "int btrfs_set_buffer_uptodate(struct extent_buffer *buf)\n{\n\treturn set_extent_buffer_uptodate(buf);\n}",
          "includes": [
            "#include <asm/cpufeature.h>",
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"raid56.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/uuid.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/migrate.h>",
            "#include <linux/slab.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/writeback.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/swap.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/cpufeature.h>\n#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"raid56.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <asm/unaligned.h>\n#include <linux/semaphore.h>\n#include <linux/uuid.h>\n#include <linux/ratelimit.h>\n#include <linux/migrate.h>\n#include <linux/slab.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/radix-tree.h>\n#include <linux/swap.h>\n#include <linux/scatterlist.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nint btrfs_set_buffer_uptodate(struct extent_buffer *buf)\n{\n\treturn set_extent_buffer_uptodate(buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sync_dirty_buffer",
          "args": [
            "bh_primary"
          ],
          "line": 741
        },
        "resolved": true,
        "details": {
          "function_name": "sync_dirty_buffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "3153-3156",
          "snippet": "int sync_dirty_buffer(struct buffer_head *bh)\n{\n\treturn __sync_dirty_buffer(bh, WRITE_SYNC);\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nint sync_dirty_buffer(struct buffer_head *bh)\n{\n\treturn __sync_dirty_buffer(bh, WRITE_SYNC);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mark_buffer_dirty",
          "args": [
            "bh_primary"
          ],
          "line": 740
        },
        "resolved": true,
        "details": {
          "function_name": "mark_buffer_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1141-1167",
          "snippet": "void mark_buffer_dirty(struct buffer_head *bh)\n{\n\tWARN_ON_ONCE(!buffer_uptodate(bh));\n\n\ttrace_block_dirty_buffer(bh);\n\n\t/*\n\t * Very *carefully* optimize the it-is-already-dirty case.\n\t *\n\t * Don't let the final \"is it dirty\" escape to before we\n\t * perhaps modified the buffer.\n\t */\n\tif (buffer_dirty(bh)) {\n\t\tsmp_mb();\n\t\tif (buffer_dirty(bh))\n\t\t\treturn;\n\t}\n\n\tif (!test_set_buffer_dirty(bh)) {\n\t\tstruct page *page = bh->b_page;\n\t\tif (!TestSetPageDirty(page)) {\n\t\t\tstruct address_space *mapping = page_mapping(page);\n\t\t\tif (mapping)\n\t\t\t\t__set_page_dirty(page, mapping, 0);\n\t\t}\n\t}\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid mark_buffer_dirty(struct buffer_head *bh)\n{\n\tWARN_ON_ONCE(!buffer_uptodate(bh));\n\n\ttrace_block_dirty_buffer(bh);\n\n\t/*\n\t * Very *carefully* optimize the it-is-already-dirty case.\n\t *\n\t * Don't let the final \"is it dirty\" escape to before we\n\t * perhaps modified the buffer.\n\t */\n\tif (buffer_dirty(bh)) {\n\t\tsmp_mb();\n\t\tif (buffer_dirty(bh))\n\t\t\treturn;\n\t}\n\n\tif (!test_set_buffer_dirty(bh)) {\n\t\tstruct page *page = bh->b_page;\n\t\tif (!TestSetPageDirty(page)) {\n\t\t\tstruct address_space *mapping = page_mapping(page);\n\t\t\tif (mapping)\n\t\t\t\t__set_page_dirty(page, mapping, 0);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "bh_primary->b_data",
            "bh_backup->b_data",
            "NTFS_BLOCK_SIZE"
          ],
          "line": 738
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_warning",
          "args": [
            "sb",
            "\"Hot-fix: Recovering invalid primary \"\n\t\t\t\t\t\"boot sector from backup copy.\""
          ],
          "line": 736
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_error",
          "args": [
            "sb",
            "read_err_str",
            "\"backup\""
          ],
          "line": 718
        },
        "resolved": true,
        "details": {
          "function_name": "__ntfs_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/debug.c",
          "lines": "86-108",
          "snippet": "void __ntfs_error(const char *function, const struct super_block *sb,\n\t\tconst char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\tint flen = 0;\n\n#ifndef DEBUG\n\tif (!printk_ratelimit())\n\t\treturn;\n#endif\n\tif (function)\n\t\tflen = strlen(function);\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tif (sb)\n\t\tpr_err(\"(device %s): %s(): %pV\\n\",\n\t\t       sb->s_id, flen ? function : \"\", &vaf);\n\telse\n\t\tpr_err(\"%s(): %pV\\n\", flen ? function : \"\", &vaf);\n\tva_end(args);\n}",
          "includes": [
            "#include \"debug.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"debug.h\"\n\nvoid __ntfs_error(const char *function, const struct super_block *sb,\n\t\tconst char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\tint flen = 0;\n\n#ifndef DEBUG\n\tif (!printk_ratelimit())\n\t\treturn;\n#endif\n\tif (function)\n\t\tflen = strlen(function);\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tif (sb)\n\t\tpr_err(\"(device %s): %s(): %pV\\n\",\n\t\t       sb->s_id, flen ? function : \"\", &vaf);\n\telse\n\t\tpr_err(\"%s(): %pV\\n\", flen ? function : \"\", &vaf);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ntfs_error",
          "args": [
            "sb",
            "\"Could not find a valid backup boot \"\n\t\t\t\t\t\"sector.\""
          ],
          "line": 714
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_boot_sector_ntfs",
          "args": [
            "sb",
            "(NTFS_BOOT_SECTOR*)\n\t\t\t\tbh_backup->b_data",
            "silent"
          ],
          "line": 710
        },
        "resolved": true,
        "details": {
          "function_name": "is_boot_sector_ntfs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/super.c",
          "lines": "583-655",
          "snippet": "static bool is_boot_sector_ntfs(const struct super_block *sb,\n\t\tconst NTFS_BOOT_SECTOR *b, const bool silent)\n{\n\t/*\n\t * Check that checksum == sum of u32 values from b to the checksum\n\t * field.  If checksum is zero, no checking is done.  We will work when\n\t * the checksum test fails, since some utilities update the boot sector\n\t * ignoring the checksum which leaves the checksum out-of-date.  We\n\t * report a warning if this is the case.\n\t */\n\tif ((void*)b < (void*)&b->checksum && b->checksum && !silent) {\n\t\tle32 *u;\n\t\tu32 i;\n\n\t\tfor (i = 0, u = (le32*)b; u < (le32*)(&b->checksum); ++u)\n\t\t\ti += le32_to_cpup(u);\n\t\tif (le32_to_cpu(b->checksum) != i)\n\t\t\tntfs_warning(sb, \"Invalid boot sector checksum.\");\n\t}\n\t/* Check OEMidentifier is \"NTFS    \" */\n\tif (b->oem_id != magicNTFS)\n\t\tgoto not_ntfs;\n\t/* Check bytes per sector value is between 256 and 4096. */\n\tif (le16_to_cpu(b->bpb.bytes_per_sector) < 0x100 ||\n\t\t\tle16_to_cpu(b->bpb.bytes_per_sector) > 0x1000)\n\t\tgoto not_ntfs;\n\t/* Check sectors per cluster value is valid. */\n\tswitch (b->bpb.sectors_per_cluster) {\n\tcase 1: case 2: case 4: case 8: case 16: case 32: case 64: case 128:\n\t\tbreak;\n\tdefault:\n\t\tgoto not_ntfs;\n\t}\n\t/* Check the cluster size is not above the maximum (64kiB). */\n\tif ((u32)le16_to_cpu(b->bpb.bytes_per_sector) *\n\t\t\tb->bpb.sectors_per_cluster > NTFS_MAX_CLUSTER_SIZE)\n\t\tgoto not_ntfs;\n\t/* Check reserved/unused fields are really zero. */\n\tif (le16_to_cpu(b->bpb.reserved_sectors) ||\n\t\t\tle16_to_cpu(b->bpb.root_entries) ||\n\t\t\tle16_to_cpu(b->bpb.sectors) ||\n\t\t\tle16_to_cpu(b->bpb.sectors_per_fat) ||\n\t\t\tle32_to_cpu(b->bpb.large_sectors) || b->bpb.fats)\n\t\tgoto not_ntfs;\n\t/* Check clusters per file mft record value is valid. */\n\tif ((u8)b->clusters_per_mft_record < 0xe1 ||\n\t\t\t(u8)b->clusters_per_mft_record > 0xf7)\n\t\tswitch (b->clusters_per_mft_record) {\n\t\tcase 1: case 2: case 4: case 8: case 16: case 32: case 64:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tgoto not_ntfs;\n\t\t}\n\t/* Check clusters per index block value is valid. */\n\tif ((u8)b->clusters_per_index_record < 0xe1 ||\n\t\t\t(u8)b->clusters_per_index_record > 0xf7)\n\t\tswitch (b->clusters_per_index_record) {\n\t\tcase 1: case 2: case 4: case 8: case 16: case 32: case 64:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tgoto not_ntfs;\n\t\t}\n\t/*\n\t * Check for valid end of sector marker. We will work without it, but\n\t * many BIOSes will refuse to boot from a bootsector if the magic is\n\t * incorrect, so we emit a warning.\n\t */\n\tif (!silent && b->end_of_sector_marker != cpu_to_le16(0xaa55))\n\t\tntfs_warning(sb, \"Invalid end of sector marker.\");\n\treturn true;\nnot_ntfs:\n\treturn false;\n}",
          "includes": [
            "#include \"ntfs.h\"",
            "#include \"malloc.h\"",
            "#include \"layout.h\"",
            "#include \"aops.h\"",
            "#include \"inode.h\"",
            "#include \"index.h\"",
            "#include \"debug.h\"",
            "#include \"dir.h\"",
            "#include \"usnjrnl.h\"",
            "#include \"quota.h\"",
            "#include \"logfile.h\"",
            "#include \"sysctl.h\"",
            "#include <linux/bitmap.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/vfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>\t/* For bdev_logical_block_size(). */",
            "#include <linux/spinlock.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ntfs.h\"\n#include \"malloc.h\"\n#include \"layout.h\"\n#include \"aops.h\"\n#include \"inode.h\"\n#include \"index.h\"\n#include \"debug.h\"\n#include \"dir.h\"\n#include \"usnjrnl.h\"\n#include \"quota.h\"\n#include \"logfile.h\"\n#include \"sysctl.h\"\n#include <linux/bitmap.h>\n#include <linux/moduleparam.h>\n#include <linux/vfs.h>\n#include <linux/buffer_head.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\t/* For bdev_logical_block_size(). */\n#include <linux/spinlock.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/stddef.h>\n\nstatic bool is_boot_sector_ntfs(const struct super_block *sb,\n\t\tconst NTFS_BOOT_SECTOR *b, const bool silent)\n{\n\t/*\n\t * Check that checksum == sum of u32 values from b to the checksum\n\t * field.  If checksum is zero, no checking is done.  We will work when\n\t * the checksum test fails, since some utilities update the boot sector\n\t * ignoring the checksum which leaves the checksum out-of-date.  We\n\t * report a warning if this is the case.\n\t */\n\tif ((void*)b < (void*)&b->checksum && b->checksum && !silent) {\n\t\tle32 *u;\n\t\tu32 i;\n\n\t\tfor (i = 0, u = (le32*)b; u < (le32*)(&b->checksum); ++u)\n\t\t\ti += le32_to_cpup(u);\n\t\tif (le32_to_cpu(b->checksum) != i)\n\t\t\tntfs_warning(sb, \"Invalid boot sector checksum.\");\n\t}\n\t/* Check OEMidentifier is \"NTFS    \" */\n\tif (b->oem_id != magicNTFS)\n\t\tgoto not_ntfs;\n\t/* Check bytes per sector value is between 256 and 4096. */\n\tif (le16_to_cpu(b->bpb.bytes_per_sector) < 0x100 ||\n\t\t\tle16_to_cpu(b->bpb.bytes_per_sector) > 0x1000)\n\t\tgoto not_ntfs;\n\t/* Check sectors per cluster value is valid. */\n\tswitch (b->bpb.sectors_per_cluster) {\n\tcase 1: case 2: case 4: case 8: case 16: case 32: case 64: case 128:\n\t\tbreak;\n\tdefault:\n\t\tgoto not_ntfs;\n\t}\n\t/* Check the cluster size is not above the maximum (64kiB). */\n\tif ((u32)le16_to_cpu(b->bpb.bytes_per_sector) *\n\t\t\tb->bpb.sectors_per_cluster > NTFS_MAX_CLUSTER_SIZE)\n\t\tgoto not_ntfs;\n\t/* Check reserved/unused fields are really zero. */\n\tif (le16_to_cpu(b->bpb.reserved_sectors) ||\n\t\t\tle16_to_cpu(b->bpb.root_entries) ||\n\t\t\tle16_to_cpu(b->bpb.sectors) ||\n\t\t\tle16_to_cpu(b->bpb.sectors_per_fat) ||\n\t\t\tle32_to_cpu(b->bpb.large_sectors) || b->bpb.fats)\n\t\tgoto not_ntfs;\n\t/* Check clusters per file mft record value is valid. */\n\tif ((u8)b->clusters_per_mft_record < 0xe1 ||\n\t\t\t(u8)b->clusters_per_mft_record > 0xf7)\n\t\tswitch (b->clusters_per_mft_record) {\n\t\tcase 1: case 2: case 4: case 8: case 16: case 32: case 64:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tgoto not_ntfs;\n\t\t}\n\t/* Check clusters per index block value is valid. */\n\tif ((u8)b->clusters_per_index_record < 0xe1 ||\n\t\t\t(u8)b->clusters_per_index_record > 0xf7)\n\t\tswitch (b->clusters_per_index_record) {\n\t\tcase 1: case 2: case 4: case 8: case 16: case 32: case 64:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tgoto not_ntfs;\n\t\t}\n\t/*\n\t * Check for valid end of sector marker. We will work without it, but\n\t * many BIOSes will refuse to boot from a bootsector if the magic is\n\t * incorrect, so we emit a warning.\n\t */\n\tif (!silent && b->end_of_sector_marker != cpu_to_le16(0xaa55))\n\t\tntfs_warning(sb, \"Invalid end of sector marker.\");\n\treturn true;\nnot_ntfs:\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sb_bread",
          "args": [
            "sb",
            "nr_blocks >> 1"
          ],
          "line": 709
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sb_bread",
          "args": [
            "sb",
            "nr_blocks - 1"
          ],
          "line": 701
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_error",
          "args": [
            "sb",
            "\"Mount option errors=recover not used. \"\n\t\t\t\t\t\"Aborting without trying to recover.\""
          ],
          "line": 696
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NTFS_SB",
          "args": [
            "sb"
          ],
          "line": 692
        },
        "resolved": true,
        "details": {
          "function_name": "NTFS_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/ntfs.h",
          "lines": "80-83",
          "snippet": "static inline ntfs_volume *NTFS_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"layout.h\"",
            "#include \"volume.h\"",
            "#include \"types.h\"",
            "#include <linux/pagemap.h>",
            "#include <linux/smp.h>",
            "#include <linux/nls.h>",
            "#include <linux/fs.h>",
            "#include <linux/compiler.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"layout.h\"\n#include \"volume.h\"\n#include \"types.h\"\n#include <linux/pagemap.h>\n#include <linux/smp.h>\n#include <linux/nls.h>\n#include <linux/fs.h>\n#include <linux/compiler.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/stddef.h>\n\nstatic inline ntfs_volume *NTFS_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ntfs_error",
          "args": [
            "sb",
            "\"Primary boot sector is invalid.\""
          ],
          "line": 689
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sb_bread",
          "args": [
            "sb",
            "0"
          ],
          "line": 684
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ntfs.h\"\n#include \"malloc.h\"\n#include \"layout.h\"\n#include \"aops.h\"\n#include \"inode.h\"\n#include \"index.h\"\n#include \"debug.h\"\n#include \"dir.h\"\n#include \"usnjrnl.h\"\n#include \"quota.h\"\n#include \"logfile.h\"\n#include \"sysctl.h\"\n#include <linux/bitmap.h>\n#include <linux/moduleparam.h>\n#include <linux/vfs.h>\n#include <linux/buffer_head.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\t/* For bdev_logical_block_size(). */\n#include <linux/spinlock.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/stddef.h>\n\nstatic struct buffer_head *read_ntfs_boot_sector(struct super_block *sb,\n\t\tconst int silent)\n{\n\tconst char *read_err_str = \"Unable to read %s boot sector.\";\n\tstruct buffer_head *bh_primary, *bh_backup;\n\tsector_t nr_blocks = NTFS_SB(sb)->nr_blocks;\n\n\t/* Try to read primary boot sector. */\n\tif ((bh_primary = sb_bread(sb, 0))) {\n\t\tif (is_boot_sector_ntfs(sb, (NTFS_BOOT_SECTOR*)\n\t\t\t\tbh_primary->b_data, silent))\n\t\t\treturn bh_primary;\n\t\tif (!silent)\n\t\t\tntfs_error(sb, \"Primary boot sector is invalid.\");\n\t} else if (!silent)\n\t\tntfs_error(sb, read_err_str, \"primary\");\n\tif (!(NTFS_SB(sb)->on_errors & ON_ERRORS_RECOVER)) {\n\t\tif (bh_primary)\n\t\t\tbrelse(bh_primary);\n\t\tif (!silent)\n\t\t\tntfs_error(sb, \"Mount option errors=recover not used. \"\n\t\t\t\t\t\"Aborting without trying to recover.\");\n\t\treturn NULL;\n\t}\n\t/* Try to read NT4+ backup boot sector. */\n\tif ((bh_backup = sb_bread(sb, nr_blocks - 1))) {\n\t\tif (is_boot_sector_ntfs(sb, (NTFS_BOOT_SECTOR*)\n\t\t\t\tbh_backup->b_data, silent))\n\t\t\tgoto hotfix_primary_boot_sector;\n\t\tbrelse(bh_backup);\n\t} else if (!silent)\n\t\tntfs_error(sb, read_err_str, \"backup\");\n\t/* Try to read NT3.51- backup boot sector. */\n\tif ((bh_backup = sb_bread(sb, nr_blocks >> 1))) {\n\t\tif (is_boot_sector_ntfs(sb, (NTFS_BOOT_SECTOR*)\n\t\t\t\tbh_backup->b_data, silent))\n\t\t\tgoto hotfix_primary_boot_sector;\n\t\tif (!silent)\n\t\t\tntfs_error(sb, \"Could not find a valid backup boot \"\n\t\t\t\t\t\"sector.\");\n\t\tbrelse(bh_backup);\n\t} else if (!silent)\n\t\tntfs_error(sb, read_err_str, \"backup\");\n\t/* We failed. Cleanup and return. */\n\tif (bh_primary)\n\t\tbrelse(bh_primary);\n\treturn NULL;\nhotfix_primary_boot_sector:\n\tif (bh_primary) {\n\t\t/*\n\t\t * If we managed to read sector zero and the volume is not\n\t\t * read-only, copy the found, valid backup boot sector to the\n\t\t * primary boot sector.  Note we only copy the actual boot\n\t\t * sector structure, not the actual whole device sector as that\n\t\t * may be bigger and would potentially damage the $Boot system\n\t\t * file (FIXME: Would be nice to know if the backup boot sector\n\t\t * on a large sector device contains the whole boot loader or\n\t\t * just the first 512 bytes).\n\t\t */\n\t\tif (!(sb->s_flags & MS_RDONLY)) {\n\t\t\tntfs_warning(sb, \"Hot-fix: Recovering invalid primary \"\n\t\t\t\t\t\"boot sector from backup copy.\");\n\t\t\tmemcpy(bh_primary->b_data, bh_backup->b_data,\n\t\t\t\t\tNTFS_BLOCK_SIZE);\n\t\t\tmark_buffer_dirty(bh_primary);\n\t\t\tsync_dirty_buffer(bh_primary);\n\t\t\tif (buffer_uptodate(bh_primary)) {\n\t\t\t\tbrelse(bh_backup);\n\t\t\t\treturn bh_primary;\n\t\t\t}\n\t\t\tntfs_error(sb, \"Hot-fix: Device write error while \"\n\t\t\t\t\t\"recovering primary boot sector.\");\n\t\t} else {\n\t\t\tntfs_warning(sb, \"Hot-fix: Recovery of primary boot \"\n\t\t\t\t\t\"sector failed: Read-only mount.\");\n\t\t}\n\t\tbrelse(bh_primary);\n\t}\n\tntfs_warning(sb, \"Using backup boot sector.\");\n\treturn bh_backup;\n}"
  },
  {
    "function_name": "is_boot_sector_ntfs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/super.c",
    "lines": "583-655",
    "snippet": "static bool is_boot_sector_ntfs(const struct super_block *sb,\n\t\tconst NTFS_BOOT_SECTOR *b, const bool silent)\n{\n\t/*\n\t * Check that checksum == sum of u32 values from b to the checksum\n\t * field.  If checksum is zero, no checking is done.  We will work when\n\t * the checksum test fails, since some utilities update the boot sector\n\t * ignoring the checksum which leaves the checksum out-of-date.  We\n\t * report a warning if this is the case.\n\t */\n\tif ((void*)b < (void*)&b->checksum && b->checksum && !silent) {\n\t\tle32 *u;\n\t\tu32 i;\n\n\t\tfor (i = 0, u = (le32*)b; u < (le32*)(&b->checksum); ++u)\n\t\t\ti += le32_to_cpup(u);\n\t\tif (le32_to_cpu(b->checksum) != i)\n\t\t\tntfs_warning(sb, \"Invalid boot sector checksum.\");\n\t}\n\t/* Check OEMidentifier is \"NTFS    \" */\n\tif (b->oem_id != magicNTFS)\n\t\tgoto not_ntfs;\n\t/* Check bytes per sector value is between 256 and 4096. */\n\tif (le16_to_cpu(b->bpb.bytes_per_sector) < 0x100 ||\n\t\t\tle16_to_cpu(b->bpb.bytes_per_sector) > 0x1000)\n\t\tgoto not_ntfs;\n\t/* Check sectors per cluster value is valid. */\n\tswitch (b->bpb.sectors_per_cluster) {\n\tcase 1: case 2: case 4: case 8: case 16: case 32: case 64: case 128:\n\t\tbreak;\n\tdefault:\n\t\tgoto not_ntfs;\n\t}\n\t/* Check the cluster size is not above the maximum (64kiB). */\n\tif ((u32)le16_to_cpu(b->bpb.bytes_per_sector) *\n\t\t\tb->bpb.sectors_per_cluster > NTFS_MAX_CLUSTER_SIZE)\n\t\tgoto not_ntfs;\n\t/* Check reserved/unused fields are really zero. */\n\tif (le16_to_cpu(b->bpb.reserved_sectors) ||\n\t\t\tle16_to_cpu(b->bpb.root_entries) ||\n\t\t\tle16_to_cpu(b->bpb.sectors) ||\n\t\t\tle16_to_cpu(b->bpb.sectors_per_fat) ||\n\t\t\tle32_to_cpu(b->bpb.large_sectors) || b->bpb.fats)\n\t\tgoto not_ntfs;\n\t/* Check clusters per file mft record value is valid. */\n\tif ((u8)b->clusters_per_mft_record < 0xe1 ||\n\t\t\t(u8)b->clusters_per_mft_record > 0xf7)\n\t\tswitch (b->clusters_per_mft_record) {\n\t\tcase 1: case 2: case 4: case 8: case 16: case 32: case 64:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tgoto not_ntfs;\n\t\t}\n\t/* Check clusters per index block value is valid. */\n\tif ((u8)b->clusters_per_index_record < 0xe1 ||\n\t\t\t(u8)b->clusters_per_index_record > 0xf7)\n\t\tswitch (b->clusters_per_index_record) {\n\t\tcase 1: case 2: case 4: case 8: case 16: case 32: case 64:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tgoto not_ntfs;\n\t\t}\n\t/*\n\t * Check for valid end of sector marker. We will work without it, but\n\t * many BIOSes will refuse to boot from a bootsector if the magic is\n\t * incorrect, so we emit a warning.\n\t */\n\tif (!silent && b->end_of_sector_marker != cpu_to_le16(0xaa55))\n\t\tntfs_warning(sb, \"Invalid end of sector marker.\");\n\treturn true;\nnot_ntfs:\n\treturn false;\n}",
    "includes": [
      "#include \"ntfs.h\"",
      "#include \"malloc.h\"",
      "#include \"layout.h\"",
      "#include \"aops.h\"",
      "#include \"inode.h\"",
      "#include \"index.h\"",
      "#include \"debug.h\"",
      "#include \"dir.h\"",
      "#include \"usnjrnl.h\"",
      "#include \"quota.h\"",
      "#include \"logfile.h\"",
      "#include \"sysctl.h\"",
      "#include <linux/bitmap.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/vfs.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/blkdev.h>\t/* For bdev_logical_block_size(). */",
      "#include <linux/spinlock.h>",
      "#include <linux/string.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/stddef.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ntfs_warning",
          "args": [
            "sb",
            "\"Invalid end of sector marker.\""
          ],
          "line": 651
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "0xaa55"
          ],
          "line": 650
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "b->bpb.large_sectors"
          ],
          "line": 625
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "le16_to_cpu",
          "args": [
            "b->bpb.sectors_per_fat"
          ],
          "line": 624
        },
        "resolved": true,
        "details": {
          "function_name": "sle16_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "48-51",
          "snippet": "static inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ntfs_warning",
          "args": [
            "sb",
            "\"Invalid boot sector checksum.\""
          ],
          "line": 600
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ntfs.h\"\n#include \"malloc.h\"\n#include \"layout.h\"\n#include \"aops.h\"\n#include \"inode.h\"\n#include \"index.h\"\n#include \"debug.h\"\n#include \"dir.h\"\n#include \"usnjrnl.h\"\n#include \"quota.h\"\n#include \"logfile.h\"\n#include \"sysctl.h\"\n#include <linux/bitmap.h>\n#include <linux/moduleparam.h>\n#include <linux/vfs.h>\n#include <linux/buffer_head.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\t/* For bdev_logical_block_size(). */\n#include <linux/spinlock.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/stddef.h>\n\nstatic bool is_boot_sector_ntfs(const struct super_block *sb,\n\t\tconst NTFS_BOOT_SECTOR *b, const bool silent)\n{\n\t/*\n\t * Check that checksum == sum of u32 values from b to the checksum\n\t * field.  If checksum is zero, no checking is done.  We will work when\n\t * the checksum test fails, since some utilities update the boot sector\n\t * ignoring the checksum which leaves the checksum out-of-date.  We\n\t * report a warning if this is the case.\n\t */\n\tif ((void*)b < (void*)&b->checksum && b->checksum && !silent) {\n\t\tle32 *u;\n\t\tu32 i;\n\n\t\tfor (i = 0, u = (le32*)b; u < (le32*)(&b->checksum); ++u)\n\t\t\ti += le32_to_cpup(u);\n\t\tif (le32_to_cpu(b->checksum) != i)\n\t\t\tntfs_warning(sb, \"Invalid boot sector checksum.\");\n\t}\n\t/* Check OEMidentifier is \"NTFS    \" */\n\tif (b->oem_id != magicNTFS)\n\t\tgoto not_ntfs;\n\t/* Check bytes per sector value is between 256 and 4096. */\n\tif (le16_to_cpu(b->bpb.bytes_per_sector) < 0x100 ||\n\t\t\tle16_to_cpu(b->bpb.bytes_per_sector) > 0x1000)\n\t\tgoto not_ntfs;\n\t/* Check sectors per cluster value is valid. */\n\tswitch (b->bpb.sectors_per_cluster) {\n\tcase 1: case 2: case 4: case 8: case 16: case 32: case 64: case 128:\n\t\tbreak;\n\tdefault:\n\t\tgoto not_ntfs;\n\t}\n\t/* Check the cluster size is not above the maximum (64kiB). */\n\tif ((u32)le16_to_cpu(b->bpb.bytes_per_sector) *\n\t\t\tb->bpb.sectors_per_cluster > NTFS_MAX_CLUSTER_SIZE)\n\t\tgoto not_ntfs;\n\t/* Check reserved/unused fields are really zero. */\n\tif (le16_to_cpu(b->bpb.reserved_sectors) ||\n\t\t\tle16_to_cpu(b->bpb.root_entries) ||\n\t\t\tle16_to_cpu(b->bpb.sectors) ||\n\t\t\tle16_to_cpu(b->bpb.sectors_per_fat) ||\n\t\t\tle32_to_cpu(b->bpb.large_sectors) || b->bpb.fats)\n\t\tgoto not_ntfs;\n\t/* Check clusters per file mft record value is valid. */\n\tif ((u8)b->clusters_per_mft_record < 0xe1 ||\n\t\t\t(u8)b->clusters_per_mft_record > 0xf7)\n\t\tswitch (b->clusters_per_mft_record) {\n\t\tcase 1: case 2: case 4: case 8: case 16: case 32: case 64:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tgoto not_ntfs;\n\t\t}\n\t/* Check clusters per index block value is valid. */\n\tif ((u8)b->clusters_per_index_record < 0xe1 ||\n\t\t\t(u8)b->clusters_per_index_record > 0xf7)\n\t\tswitch (b->clusters_per_index_record) {\n\t\tcase 1: case 2: case 4: case 8: case 16: case 32: case 64:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tgoto not_ntfs;\n\t\t}\n\t/*\n\t * Check for valid end of sector marker. We will work without it, but\n\t * many BIOSes will refuse to boot from a bootsector if the magic is\n\t * incorrect, so we emit a warning.\n\t */\n\tif (!silent && b->end_of_sector_marker != cpu_to_le16(0xaa55))\n\t\tntfs_warning(sb, \"Invalid end of sector marker.\");\n\treturn true;\nnot_ntfs:\n\treturn false;\n}"
  },
  {
    "function_name": "ntfs_remount",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/super.c",
    "lines": "466-569",
    "snippet": "static int ntfs_remount(struct super_block *sb, int *flags, char *opt)\n{\n\tntfs_volume *vol = NTFS_SB(sb);\n\n\tntfs_debug(\"Entering with remount options string: %s\", opt);\n\n\tsync_filesystem(sb);\n\n#ifndef NTFS_RW\n\t/* For read-only compiled driver, enforce read-only flag. */\n\t*flags |= MS_RDONLY;\n#else /* NTFS_RW */\n\t/*\n\t * For the read-write compiled driver, if we are remounting read-write,\n\t * make sure there are no volume errors and that no unsupported volume\n\t * flags are set.  Also, empty the logfile journal as it would become\n\t * stale as soon as something is written to the volume and mark the\n\t * volume dirty so that chkdsk is run if the volume is not umounted\n\t * cleanly.  Finally, mark the quotas out of date so Windows rescans\n\t * the volume on boot and updates them.\n\t *\n\t * When remounting read-only, mark the volume clean if no volume errors\n\t * have occurred.\n\t */\n\tif ((sb->s_flags & MS_RDONLY) && !(*flags & MS_RDONLY)) {\n\t\tstatic const char *es = \".  Cannot remount read-write.\";\n\n\t\t/* Remounting read-write. */\n\t\tif (NVolErrors(vol)) {\n\t\t\tntfs_error(sb, \"Volume has errors and is read-only%s\",\n\t\t\t\t\tes);\n\t\t\treturn -EROFS;\n\t\t}\n\t\tif (vol->vol_flags & VOLUME_IS_DIRTY) {\n\t\t\tntfs_error(sb, \"Volume is dirty and read-only%s\", es);\n\t\t\treturn -EROFS;\n\t\t}\n\t\tif (vol->vol_flags & VOLUME_MODIFIED_BY_CHKDSK) {\n\t\t\tntfs_error(sb, \"Volume has been modified by chkdsk \"\n\t\t\t\t\t\"and is read-only%s\", es);\n\t\t\treturn -EROFS;\n\t\t}\n\t\tif (vol->vol_flags & VOLUME_MUST_MOUNT_RO_MASK) {\n\t\t\tntfs_error(sb, \"Volume has unsupported flags set \"\n\t\t\t\t\t\"(0x%x) and is read-only%s\",\n\t\t\t\t\t(unsigned)le16_to_cpu(vol->vol_flags),\n\t\t\t\t\tes);\n\t\t\treturn -EROFS;\n\t\t}\n\t\tif (ntfs_set_volume_flags(vol, VOLUME_IS_DIRTY)) {\n\t\t\tntfs_error(sb, \"Failed to set dirty bit in volume \"\n\t\t\t\t\t\"information flags%s\", es);\n\t\t\treturn -EROFS;\n\t\t}\n#if 0\n\t\t// TODO: Enable this code once we start modifying anything that\n\t\t//\t is different between NTFS 1.2 and 3.x...\n\t\t/* Set NT4 compatibility flag on newer NTFS version volumes. */\n\t\tif ((vol->major_ver > 1)) {\n\t\t\tif (ntfs_set_volume_flags(vol, VOLUME_MOUNTED_ON_NT4)) {\n\t\t\t\tntfs_error(sb, \"Failed to set NT4 \"\n\t\t\t\t\t\t\"compatibility flag%s\", es);\n\t\t\t\tNVolSetErrors(vol);\n\t\t\t\treturn -EROFS;\n\t\t\t}\n\t\t}\n#endif\n\t\tif (!ntfs_empty_logfile(vol->logfile_ino)) {\n\t\t\tntfs_error(sb, \"Failed to empty journal $LogFile%s\",\n\t\t\t\t\tes);\n\t\t\tNVolSetErrors(vol);\n\t\t\treturn -EROFS;\n\t\t}\n\t\tif (!ntfs_mark_quotas_out_of_date(vol)) {\n\t\t\tntfs_error(sb, \"Failed to mark quotas out of date%s\",\n\t\t\t\t\tes);\n\t\t\tNVolSetErrors(vol);\n\t\t\treturn -EROFS;\n\t\t}\n\t\tif (!ntfs_stamp_usnjrnl(vol)) {\n\t\t\tntfs_error(sb, \"Failed to stamp transation log \"\n\t\t\t\t\t\"($UsnJrnl)%s\", es);\n\t\t\tNVolSetErrors(vol);\n\t\t\treturn -EROFS;\n\t\t}\n\t} else if (!(sb->s_flags & MS_RDONLY) && (*flags & MS_RDONLY)) {\n\t\t/* Remounting read-only. */\n\t\tif (!NVolErrors(vol)) {\n\t\t\tif (ntfs_clear_volume_flags(vol, VOLUME_IS_DIRTY))\n\t\t\t\tntfs_warning(sb, \"Failed to clear dirty bit \"\n\t\t\t\t\t\t\"in volume information \"\n\t\t\t\t\t\t\"flags.  Run chkdsk.\");\n\t\t}\n\t}\n#endif /* NTFS_RW */\n\n\t// TODO: Deal with *flags.\n\n\tif (!parse_options(vol, opt))\n\t\treturn -EINVAL;\n\n\tntfs_debug(\"Done.\");\n\treturn 0;\n}",
    "includes": [
      "#include \"ntfs.h\"",
      "#include \"malloc.h\"",
      "#include \"layout.h\"",
      "#include \"aops.h\"",
      "#include \"inode.h\"",
      "#include \"index.h\"",
      "#include \"debug.h\"",
      "#include \"dir.h\"",
      "#include \"usnjrnl.h\"",
      "#include \"quota.h\"",
      "#include \"logfile.h\"",
      "#include \"sysctl.h\"",
      "#include <linux/bitmap.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/vfs.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/blkdev.h>\t/* For bdev_logical_block_size(). */",
      "#include <linux/spinlock.h>",
      "#include <linux/string.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/stddef.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ntfs_debug",
          "args": [
            "\"Done.\""
          ],
          "line": 567
        },
        "resolved": true,
        "details": {
          "function_name": "ntfs_debug_dump_runlist",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/debug.c",
          "lines": "134-171",
          "snippet": "void ntfs_debug_dump_runlist(const runlist_element *rl)\n{\n\tint i;\n\tconst char *lcn_str[5] = { \"LCN_HOLE         \", \"LCN_RL_NOT_MAPPED\",\n\t\t\t\t   \"LCN_ENOENT       \", \"LCN_unknown      \" };\n\n\tif (!debug_msgs)\n\t\treturn;\n\tpr_debug(\"Dumping runlist (values in hex):\\n\");\n\tif (!rl) {\n\t\tpr_debug(\"Run list not present.\\n\");\n\t\treturn;\n\t}\n\tpr_debug(\"VCN              LCN               Run length\\n\");\n\tfor (i = 0; ; i++) {\n\t\tLCN lcn = (rl + i)->lcn;\n\n\t\tif (lcn < (LCN)0) {\n\t\t\tint index = -lcn - 1;\n\n\t\t\tif (index > -LCN_ENOENT - 1)\n\t\t\t\tindex = 3;\n\t\t\tpr_debug(\"%-16Lx %s %-16Lx%s\\n\",\n\t\t\t\t\t(long long)(rl + i)->vcn, lcn_str[index],\n\t\t\t\t\t(long long)(rl + i)->length,\n\t\t\t\t\t(rl + i)->length ? \"\" :\n\t\t\t\t\t\t\" (runlist end)\");\n\t\t} else\n\t\t\tpr_debug(\"%-16Lx %-16Lx  %-16Lx%s\\n\",\n\t\t\t\t\t(long long)(rl + i)->vcn,\n\t\t\t\t\t(long long)(rl + i)->lcn,\n\t\t\t\t\t(long long)(rl + i)->length,\n\t\t\t\t\t(rl + i)->length ? \"\" :\n\t\t\t\t\t\t\" (runlist end)\");\n\t\tif (!(rl + i)->length)\n\t\t\tbreak;\n\t}\n}",
          "includes": [
            "#include \"debug.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"debug.h\"\n\nvoid ntfs_debug_dump_runlist(const runlist_element *rl)\n{\n\tint i;\n\tconst char *lcn_str[5] = { \"LCN_HOLE         \", \"LCN_RL_NOT_MAPPED\",\n\t\t\t\t   \"LCN_ENOENT       \", \"LCN_unknown      \" };\n\n\tif (!debug_msgs)\n\t\treturn;\n\tpr_debug(\"Dumping runlist (values in hex):\\n\");\n\tif (!rl) {\n\t\tpr_debug(\"Run list not present.\\n\");\n\t\treturn;\n\t}\n\tpr_debug(\"VCN              LCN               Run length\\n\");\n\tfor (i = 0; ; i++) {\n\t\tLCN lcn = (rl + i)->lcn;\n\n\t\tif (lcn < (LCN)0) {\n\t\t\tint index = -lcn - 1;\n\n\t\t\tif (index > -LCN_ENOENT - 1)\n\t\t\t\tindex = 3;\n\t\t\tpr_debug(\"%-16Lx %s %-16Lx%s\\n\",\n\t\t\t\t\t(long long)(rl + i)->vcn, lcn_str[index],\n\t\t\t\t\t(long long)(rl + i)->length,\n\t\t\t\t\t(rl + i)->length ? \"\" :\n\t\t\t\t\t\t\" (runlist end)\");\n\t\t} else\n\t\t\tpr_debug(\"%-16Lx %-16Lx  %-16Lx%s\\n\",\n\t\t\t\t\t(long long)(rl + i)->vcn,\n\t\t\t\t\t(long long)(rl + i)->lcn,\n\t\t\t\t\t(long long)(rl + i)->length,\n\t\t\t\t\t(rl + i)->length ? \"\" :\n\t\t\t\t\t\t\" (runlist end)\");\n\t\tif (!(rl + i)->length)\n\t\t\tbreak;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "parse_options",
          "args": [
            "vol",
            "opt"
          ],
          "line": 564
        },
        "resolved": true,
        "details": {
          "function_name": "parse_options",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/super.c",
          "lines": "101-356",
          "snippet": "static bool parse_options(ntfs_volume *vol, char *opt)\n{\n\tchar *p, *v, *ov;\n\tstatic char *utf8 = \"utf8\";\n\tint errors = 0, sloppy = 0;\n\tkuid_t uid = INVALID_UID;\n\tkgid_t gid = INVALID_GID;\n\tumode_t fmask = (umode_t)-1, dmask = (umode_t)-1;\n\tint mft_zone_multiplier = -1, on_errors = -1;\n\tint show_sys_files = -1, case_sensitive = -1, disable_sparse = -1;\n\tstruct nls_table *nls_map = NULL, *old_nls;\n\n\t/* I am lazy... (-8 */\n#define NTFS_GETOPT_WITH_DEFAULT(option, variable, default_value)\t\\\n\tif (!strcmp(p, option)) {\t\t\t\t\t\\\n\t\tif (!v || !*v)\t\t\t\t\t\t\\\n\t\t\tvariable = default_value;\t\t\t\\\n\t\telse {\t\t\t\t\t\t\t\\\n\t\t\tvariable = simple_strtoul(ov = v, &v, 0);\t\\\n\t\t\tif (*v)\t\t\t\t\t\t\\\n\t\t\t\tgoto needs_val;\t\t\t\t\\\n\t\t}\t\t\t\t\t\t\t\\\n\t}\n#define NTFS_GETOPT(option, variable)\t\t\t\t\t\\\n\tif (!strcmp(p, option)) {\t\t\t\t\t\\\n\t\tif (!v || !*v)\t\t\t\t\t\t\\\n\t\t\tgoto needs_arg;\t\t\t\t\t\\\n\t\tvariable = simple_strtoul(ov = v, &v, 0);\t\t\\\n\t\tif (*v)\t\t\t\t\t\t\t\\\n\t\t\tgoto needs_val;\t\t\t\t\t\\\n\t}\n#define NTFS_GETOPT_UID(option, variable)\t\t\t\t\\\n\tif (!strcmp(p, option)) {\t\t\t\t\t\\\n\t\tuid_t uid_value;\t\t\t\t\t\\\n\t\tif (!v || !*v)\t\t\t\t\t\t\\\n\t\t\tgoto needs_arg;\t\t\t\t\t\\\n\t\tuid_value = simple_strtoul(ov = v, &v, 0);\t\t\\\n\t\tif (*v)\t\t\t\t\t\t\t\\\n\t\t\tgoto needs_val;\t\t\t\t\t\\\n\t\tvariable = make_kuid(current_user_ns(), uid_value);\t\\\n\t\tif (!uid_valid(variable))\t\t\t\t\\\n\t\t\tgoto needs_val;\t\t\t\t\t\\\n\t}\n#define NTFS_GETOPT_GID(option, variable)\t\t\t\t\\\n\tif (!strcmp(p, option)) {\t\t\t\t\t\\\n\t\tgid_t gid_value;\t\t\t\t\t\\\n\t\tif (!v || !*v)\t\t\t\t\t\t\\\n\t\t\tgoto needs_arg;\t\t\t\t\t\\\n\t\tgid_value = simple_strtoul(ov = v, &v, 0);\t\t\\\n\t\tif (*v)\t\t\t\t\t\t\t\\\n\t\t\tgoto needs_val;\t\t\t\t\t\\\n\t\tvariable = make_kgid(current_user_ns(), gid_value);\t\\\n\t\tif (!gid_valid(variable))\t\t\t\t\\\n\t\t\tgoto needs_val;\t\t\t\t\t\\\n\t}\n#define NTFS_GETOPT_OCTAL(option, variable)\t\t\t\t\\\n\tif (!strcmp(p, option)) {\t\t\t\t\t\\\n\t\tif (!v || !*v)\t\t\t\t\t\t\\\n\t\t\tgoto needs_arg;\t\t\t\t\t\\\n\t\tvariable = simple_strtoul(ov = v, &v, 8);\t\t\\\n\t\tif (*v)\t\t\t\t\t\t\t\\\n\t\t\tgoto needs_val;\t\t\t\t\t\\\n\t}\n#define NTFS_GETOPT_BOOL(option, variable)\t\t\t\t\\\n\tif (!strcmp(p, option)) {\t\t\t\t\t\\\n\t\tbool val;\t\t\t\t\t\t\\\n\t\tif (!simple_getbool(v, &val))\t\t\t\t\\\n\t\t\tgoto needs_bool;\t\t\t\t\\\n\t\tvariable = val;\t\t\t\t\t\t\\\n\t}\n#define NTFS_GETOPT_OPTIONS_ARRAY(option, variable, opt_array)\t\t\\\n\tif (!strcmp(p, option)) {\t\t\t\t\t\\\n\t\tint _i;\t\t\t\t\t\t\t\\\n\t\tif (!v || !*v)\t\t\t\t\t\t\\\n\t\t\tgoto needs_arg;\t\t\t\t\t\\\n\t\tov = v;\t\t\t\t\t\t\t\\\n\t\tif (variable == -1)\t\t\t\t\t\\\n\t\t\tvariable = 0;\t\t\t\t\t\\\n\t\tfor (_i = 0; opt_array[_i].str && *opt_array[_i].str; _i++) \\\n\t\t\tif (!strcmp(opt_array[_i].str, v)) {\t\t\\\n\t\t\t\tvariable |= opt_array[_i].val;\t\t\\\n\t\t\t\tbreak;\t\t\t\t\t\\\n\t\t\t}\t\t\t\t\t\t\\\n\t\tif (!opt_array[_i].str || !*opt_array[_i].str)\t\t\\\n\t\t\tgoto needs_val;\t\t\t\t\t\\\n\t}\n\tif (!opt || !*opt)\n\t\tgoto no_mount_options;\n\tntfs_debug(\"Entering with mount options string: %s\", opt);\n\twhile ((p = strsep(&opt, \",\"))) {\n\t\tif ((v = strchr(p, '=')))\n\t\t\t*v++ = 0;\n\t\tNTFS_GETOPT_UID(\"uid\", uid)\n\t\telse NTFS_GETOPT_GID(\"gid\", gid)\n\t\telse NTFS_GETOPT_OCTAL(\"umask\", fmask = dmask)\n\t\telse NTFS_GETOPT_OCTAL(\"fmask\", fmask)\n\t\telse NTFS_GETOPT_OCTAL(\"dmask\", dmask)\n\t\telse NTFS_GETOPT(\"mft_zone_multiplier\", mft_zone_multiplier)\n\t\telse NTFS_GETOPT_WITH_DEFAULT(\"sloppy\", sloppy, true)\n\t\telse NTFS_GETOPT_BOOL(\"show_sys_files\", show_sys_files)\n\t\telse NTFS_GETOPT_BOOL(\"case_sensitive\", case_sensitive)\n\t\telse NTFS_GETOPT_BOOL(\"disable_sparse\", disable_sparse)\n\t\telse NTFS_GETOPT_OPTIONS_ARRAY(\"errors\", on_errors,\n\t\t\t\ton_errors_arr)\n\t\telse if (!strcmp(p, \"posix\") || !strcmp(p, \"show_inodes\"))\n\t\t\tntfs_warning(vol->sb, \"Ignoring obsolete option %s.\",\n\t\t\t\t\tp);\n\t\telse if (!strcmp(p, \"nls\") || !strcmp(p, \"iocharset\")) {\n\t\t\tif (!strcmp(p, \"iocharset\"))\n\t\t\t\tntfs_warning(vol->sb, \"Option iocharset is \"\n\t\t\t\t\t\t\"deprecated. Please use \"\n\t\t\t\t\t\t\"option nls=<charsetname> in \"\n\t\t\t\t\t\t\"the future.\");\n\t\t\tif (!v || !*v)\n\t\t\t\tgoto needs_arg;\nuse_utf8:\n\t\t\told_nls = nls_map;\n\t\t\tnls_map = load_nls(v);\n\t\t\tif (!nls_map) {\n\t\t\t\tif (!old_nls) {\n\t\t\t\t\tntfs_error(vol->sb, \"NLS character set \"\n\t\t\t\t\t\t\t\"%s not found.\", v);\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\tntfs_error(vol->sb, \"NLS character set %s not \"\n\t\t\t\t\t\t\"found. Using previous one %s.\",\n\t\t\t\t\t\tv, old_nls->charset);\n\t\t\t\tnls_map = old_nls;\n\t\t\t} else /* nls_map */ {\n\t\t\t\tunload_nls(old_nls);\n\t\t\t}\n\t\t} else if (!strcmp(p, \"utf8\")) {\n\t\t\tbool val = false;\n\t\t\tntfs_warning(vol->sb, \"Option utf8 is no longer \"\n\t\t\t\t   \"supported, using option nls=utf8. Please \"\n\t\t\t\t   \"use option nls=utf8 in the future and \"\n\t\t\t\t   \"make sure utf8 is compiled either as a \"\n\t\t\t\t   \"module or into the kernel.\");\n\t\t\tif (!v || !*v)\n\t\t\t\tval = true;\n\t\t\telse if (!simple_getbool(v, &val))\n\t\t\t\tgoto needs_bool;\n\t\t\tif (val) {\n\t\t\t\tv = utf8;\n\t\t\t\tgoto use_utf8;\n\t\t\t}\n\t\t} else {\n\t\t\tntfs_error(vol->sb, \"Unrecognized mount option %s.\", p);\n\t\t\tif (errors < INT_MAX)\n\t\t\t\terrors++;\n\t\t}\n#undef NTFS_GETOPT_OPTIONS_ARRAY\n#undef NTFS_GETOPT_BOOL\n#undef NTFS_GETOPT\n#undef NTFS_GETOPT_WITH_DEFAULT\n\t}\nno_mount_options:\n\tif (errors && !sloppy)\n\t\treturn false;\n\tif (sloppy)\n\t\tntfs_warning(vol->sb, \"Sloppy option given. Ignoring \"\n\t\t\t\t\"unrecognized mount option(s) and continuing.\");\n\t/* Keep this first! */\n\tif (on_errors != -1) {\n\t\tif (!on_errors) {\n\t\t\tntfs_error(vol->sb, \"Invalid errors option argument \"\n\t\t\t\t\t\"or bug in options parser.\");\n\t\t\treturn false;\n\t\t}\n\t}\n\tif (nls_map) {\n\t\tif (vol->nls_map && vol->nls_map != nls_map) {\n\t\t\tntfs_error(vol->sb, \"Cannot change NLS character set \"\n\t\t\t\t\t\"on remount.\");\n\t\t\treturn false;\n\t\t} /* else (!vol->nls_map) */\n\t\tntfs_debug(\"Using NLS character set %s.\", nls_map->charset);\n\t\tvol->nls_map = nls_map;\n\t} else /* (!nls_map) */ {\n\t\tif (!vol->nls_map) {\n\t\t\tvol->nls_map = load_nls_default();\n\t\t\tif (!vol->nls_map) {\n\t\t\t\tntfs_error(vol->sb, \"Failed to load default \"\n\t\t\t\t\t\t\"NLS character set.\");\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tntfs_debug(\"Using default NLS character set (%s).\",\n\t\t\t\t\tvol->nls_map->charset);\n\t\t}\n\t}\n\tif (mft_zone_multiplier != -1) {\n\t\tif (vol->mft_zone_multiplier && vol->mft_zone_multiplier !=\n\t\t\t\tmft_zone_multiplier) {\n\t\t\tntfs_error(vol->sb, \"Cannot change mft_zone_multiplier \"\n\t\t\t\t\t\"on remount.\");\n\t\t\treturn false;\n\t\t}\n\t\tif (mft_zone_multiplier < 1 || mft_zone_multiplier > 4) {\n\t\t\tntfs_error(vol->sb, \"Invalid mft_zone_multiplier. \"\n\t\t\t\t\t\"Using default value, i.e. 1.\");\n\t\t\tmft_zone_multiplier = 1;\n\t\t}\n\t\tvol->mft_zone_multiplier = mft_zone_multiplier;\n\t}\n\tif (!vol->mft_zone_multiplier)\n\t\tvol->mft_zone_multiplier = 1;\n\tif (on_errors != -1)\n\t\tvol->on_errors = on_errors;\n\tif (!vol->on_errors || vol->on_errors == ON_ERRORS_RECOVER)\n\t\tvol->on_errors |= ON_ERRORS_CONTINUE;\n\tif (uid_valid(uid))\n\t\tvol->uid = uid;\n\tif (gid_valid(gid))\n\t\tvol->gid = gid;\n\tif (fmask != (umode_t)-1)\n\t\tvol->fmask = fmask;\n\tif (dmask != (umode_t)-1)\n\t\tvol->dmask = dmask;\n\tif (show_sys_files != -1) {\n\t\tif (show_sys_files)\n\t\t\tNVolSetShowSystemFiles(vol);\n\t\telse\n\t\t\tNVolClearShowSystemFiles(vol);\n\t}\n\tif (case_sensitive != -1) {\n\t\tif (case_sensitive)\n\t\t\tNVolSetCaseSensitive(vol);\n\t\telse\n\t\t\tNVolClearCaseSensitive(vol);\n\t}\n\tif (disable_sparse != -1) {\n\t\tif (disable_sparse)\n\t\t\tNVolClearSparseEnabled(vol);\n\t\telse {\n\t\t\tif (!NVolSparseEnabled(vol) &&\n\t\t\t\t\tvol->major_ver && vol->major_ver < 3)\n\t\t\t\tntfs_warning(vol->sb, \"Not enabling sparse \"\n\t\t\t\t\t\t\"support due to NTFS volume \"\n\t\t\t\t\t\t\"version %i.%i (need at least \"\n\t\t\t\t\t\t\"version 3.0).\", vol->major_ver,\n\t\t\t\t\t\tvol->minor_ver);\n\t\t\telse\n\t\t\t\tNVolSetSparseEnabled(vol);\n\t\t}\n\t}\n\treturn true;\nneeds_arg:\n\tntfs_error(vol->sb, \"The %s option requires an argument.\", p);\n\treturn false;\nneeds_bool:\n\tntfs_error(vol->sb, \"The %s option requires a boolean argument.\", p);\n\treturn false;\nneeds_val:\n\tntfs_error(vol->sb, \"Invalid %s option argument: %s\", p, ov);\n\treturn false;\n}",
          "includes": [
            "#include \"ntfs.h\"",
            "#include \"malloc.h\"",
            "#include \"layout.h\"",
            "#include \"aops.h\"",
            "#include \"inode.h\"",
            "#include \"index.h\"",
            "#include \"debug.h\"",
            "#include \"dir.h\"",
            "#include \"usnjrnl.h\"",
            "#include \"quota.h\"",
            "#include \"logfile.h\"",
            "#include \"sysctl.h\"",
            "#include <linux/bitmap.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/vfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>\t/* For bdev_logical_block_size(). */",
            "#include <linux/spinlock.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "const option_t on_errors_arr[] = {\n\t{ ON_ERRORS_PANIC,\t\"panic\" },\n\t{ ON_ERRORS_REMOUNT_RO,\t\"remount-ro\", },\n\t{ ON_ERRORS_CONTINUE,\t\"continue\", },\n\t{ ON_ERRORS_RECOVER,\t\"recover\" },\n\t{ 0,\t\t\tNULL }\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ntfs.h\"\n#include \"malloc.h\"\n#include \"layout.h\"\n#include \"aops.h\"\n#include \"inode.h\"\n#include \"index.h\"\n#include \"debug.h\"\n#include \"dir.h\"\n#include \"usnjrnl.h\"\n#include \"quota.h\"\n#include \"logfile.h\"\n#include \"sysctl.h\"\n#include <linux/bitmap.h>\n#include <linux/moduleparam.h>\n#include <linux/vfs.h>\n#include <linux/buffer_head.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\t/* For bdev_logical_block_size(). */\n#include <linux/spinlock.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/stddef.h>\n\nconst option_t on_errors_arr[] = {\n\t{ ON_ERRORS_PANIC,\t\"panic\" },\n\t{ ON_ERRORS_REMOUNT_RO,\t\"remount-ro\", },\n\t{ ON_ERRORS_CONTINUE,\t\"continue\", },\n\t{ ON_ERRORS_RECOVER,\t\"recover\" },\n\t{ 0,\t\t\tNULL }\n};\n\nstatic bool parse_options(ntfs_volume *vol, char *opt)\n{\n\tchar *p, *v, *ov;\n\tstatic char *utf8 = \"utf8\";\n\tint errors = 0, sloppy = 0;\n\tkuid_t uid = INVALID_UID;\n\tkgid_t gid = INVALID_GID;\n\tumode_t fmask = (umode_t)-1, dmask = (umode_t)-1;\n\tint mft_zone_multiplier = -1, on_errors = -1;\n\tint show_sys_files = -1, case_sensitive = -1, disable_sparse = -1;\n\tstruct nls_table *nls_map = NULL, *old_nls;\n\n\t/* I am lazy... (-8 */\n#define NTFS_GETOPT_WITH_DEFAULT(option, variable, default_value)\t\\\n\tif (!strcmp(p, option)) {\t\t\t\t\t\\\n\t\tif (!v || !*v)\t\t\t\t\t\t\\\n\t\t\tvariable = default_value;\t\t\t\\\n\t\telse {\t\t\t\t\t\t\t\\\n\t\t\tvariable = simple_strtoul(ov = v, &v, 0);\t\\\n\t\t\tif (*v)\t\t\t\t\t\t\\\n\t\t\t\tgoto needs_val;\t\t\t\t\\\n\t\t}\t\t\t\t\t\t\t\\\n\t}\n#define NTFS_GETOPT(option, variable)\t\t\t\t\t\\\n\tif (!strcmp(p, option)) {\t\t\t\t\t\\\n\t\tif (!v || !*v)\t\t\t\t\t\t\\\n\t\t\tgoto needs_arg;\t\t\t\t\t\\\n\t\tvariable = simple_strtoul(ov = v, &v, 0);\t\t\\\n\t\tif (*v)\t\t\t\t\t\t\t\\\n\t\t\tgoto needs_val;\t\t\t\t\t\\\n\t}\n#define NTFS_GETOPT_UID(option, variable)\t\t\t\t\\\n\tif (!strcmp(p, option)) {\t\t\t\t\t\\\n\t\tuid_t uid_value;\t\t\t\t\t\\\n\t\tif (!v || !*v)\t\t\t\t\t\t\\\n\t\t\tgoto needs_arg;\t\t\t\t\t\\\n\t\tuid_value = simple_strtoul(ov = v, &v, 0);\t\t\\\n\t\tif (*v)\t\t\t\t\t\t\t\\\n\t\t\tgoto needs_val;\t\t\t\t\t\\\n\t\tvariable = make_kuid(current_user_ns(), uid_value);\t\\\n\t\tif (!uid_valid(variable))\t\t\t\t\\\n\t\t\tgoto needs_val;\t\t\t\t\t\\\n\t}\n#define NTFS_GETOPT_GID(option, variable)\t\t\t\t\\\n\tif (!strcmp(p, option)) {\t\t\t\t\t\\\n\t\tgid_t gid_value;\t\t\t\t\t\\\n\t\tif (!v || !*v)\t\t\t\t\t\t\\\n\t\t\tgoto needs_arg;\t\t\t\t\t\\\n\t\tgid_value = simple_strtoul(ov = v, &v, 0);\t\t\\\n\t\tif (*v)\t\t\t\t\t\t\t\\\n\t\t\tgoto needs_val;\t\t\t\t\t\\\n\t\tvariable = make_kgid(current_user_ns(), gid_value);\t\\\n\t\tif (!gid_valid(variable))\t\t\t\t\\\n\t\t\tgoto needs_val;\t\t\t\t\t\\\n\t}\n#define NTFS_GETOPT_OCTAL(option, variable)\t\t\t\t\\\n\tif (!strcmp(p, option)) {\t\t\t\t\t\\\n\t\tif (!v || !*v)\t\t\t\t\t\t\\\n\t\t\tgoto needs_arg;\t\t\t\t\t\\\n\t\tvariable = simple_strtoul(ov = v, &v, 8);\t\t\\\n\t\tif (*v)\t\t\t\t\t\t\t\\\n\t\t\tgoto needs_val;\t\t\t\t\t\\\n\t}\n#define NTFS_GETOPT_BOOL(option, variable)\t\t\t\t\\\n\tif (!strcmp(p, option)) {\t\t\t\t\t\\\n\t\tbool val;\t\t\t\t\t\t\\\n\t\tif (!simple_getbool(v, &val))\t\t\t\t\\\n\t\t\tgoto needs_bool;\t\t\t\t\\\n\t\tvariable = val;\t\t\t\t\t\t\\\n\t}\n#define NTFS_GETOPT_OPTIONS_ARRAY(option, variable, opt_array)\t\t\\\n\tif (!strcmp(p, option)) {\t\t\t\t\t\\\n\t\tint _i;\t\t\t\t\t\t\t\\\n\t\tif (!v || !*v)\t\t\t\t\t\t\\\n\t\t\tgoto needs_arg;\t\t\t\t\t\\\n\t\tov = v;\t\t\t\t\t\t\t\\\n\t\tif (variable == -1)\t\t\t\t\t\\\n\t\t\tvariable = 0;\t\t\t\t\t\\\n\t\tfor (_i = 0; opt_array[_i].str && *opt_array[_i].str; _i++) \\\n\t\t\tif (!strcmp(opt_array[_i].str, v)) {\t\t\\\n\t\t\t\tvariable |= opt_array[_i].val;\t\t\\\n\t\t\t\tbreak;\t\t\t\t\t\\\n\t\t\t}\t\t\t\t\t\t\\\n\t\tif (!opt_array[_i].str || !*opt_array[_i].str)\t\t\\\n\t\t\tgoto needs_val;\t\t\t\t\t\\\n\t}\n\tif (!opt || !*opt)\n\t\tgoto no_mount_options;\n\tntfs_debug(\"Entering with mount options string: %s\", opt);\n\twhile ((p = strsep(&opt, \",\"))) {\n\t\tif ((v = strchr(p, '=')))\n\t\t\t*v++ = 0;\n\t\tNTFS_GETOPT_UID(\"uid\", uid)\n\t\telse NTFS_GETOPT_GID(\"gid\", gid)\n\t\telse NTFS_GETOPT_OCTAL(\"umask\", fmask = dmask)\n\t\telse NTFS_GETOPT_OCTAL(\"fmask\", fmask)\n\t\telse NTFS_GETOPT_OCTAL(\"dmask\", dmask)\n\t\telse NTFS_GETOPT(\"mft_zone_multiplier\", mft_zone_multiplier)\n\t\telse NTFS_GETOPT_WITH_DEFAULT(\"sloppy\", sloppy, true)\n\t\telse NTFS_GETOPT_BOOL(\"show_sys_files\", show_sys_files)\n\t\telse NTFS_GETOPT_BOOL(\"case_sensitive\", case_sensitive)\n\t\telse NTFS_GETOPT_BOOL(\"disable_sparse\", disable_sparse)\n\t\telse NTFS_GETOPT_OPTIONS_ARRAY(\"errors\", on_errors,\n\t\t\t\ton_errors_arr)\n\t\telse if (!strcmp(p, \"posix\") || !strcmp(p, \"show_inodes\"))\n\t\t\tntfs_warning(vol->sb, \"Ignoring obsolete option %s.\",\n\t\t\t\t\tp);\n\t\telse if (!strcmp(p, \"nls\") || !strcmp(p, \"iocharset\")) {\n\t\t\tif (!strcmp(p, \"iocharset\"))\n\t\t\t\tntfs_warning(vol->sb, \"Option iocharset is \"\n\t\t\t\t\t\t\"deprecated. Please use \"\n\t\t\t\t\t\t\"option nls=<charsetname> in \"\n\t\t\t\t\t\t\"the future.\");\n\t\t\tif (!v || !*v)\n\t\t\t\tgoto needs_arg;\nuse_utf8:\n\t\t\told_nls = nls_map;\n\t\t\tnls_map = load_nls(v);\n\t\t\tif (!nls_map) {\n\t\t\t\tif (!old_nls) {\n\t\t\t\t\tntfs_error(vol->sb, \"NLS character set \"\n\t\t\t\t\t\t\t\"%s not found.\", v);\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\tntfs_error(vol->sb, \"NLS character set %s not \"\n\t\t\t\t\t\t\"found. Using previous one %s.\",\n\t\t\t\t\t\tv, old_nls->charset);\n\t\t\t\tnls_map = old_nls;\n\t\t\t} else /* nls_map */ {\n\t\t\t\tunload_nls(old_nls);\n\t\t\t}\n\t\t} else if (!strcmp(p, \"utf8\")) {\n\t\t\tbool val = false;\n\t\t\tntfs_warning(vol->sb, \"Option utf8 is no longer \"\n\t\t\t\t   \"supported, using option nls=utf8. Please \"\n\t\t\t\t   \"use option nls=utf8 in the future and \"\n\t\t\t\t   \"make sure utf8 is compiled either as a \"\n\t\t\t\t   \"module or into the kernel.\");\n\t\t\tif (!v || !*v)\n\t\t\t\tval = true;\n\t\t\telse if (!simple_getbool(v, &val))\n\t\t\t\tgoto needs_bool;\n\t\t\tif (val) {\n\t\t\t\tv = utf8;\n\t\t\t\tgoto use_utf8;\n\t\t\t}\n\t\t} else {\n\t\t\tntfs_error(vol->sb, \"Unrecognized mount option %s.\", p);\n\t\t\tif (errors < INT_MAX)\n\t\t\t\terrors++;\n\t\t}\n#undef NTFS_GETOPT_OPTIONS_ARRAY\n#undef NTFS_GETOPT_BOOL\n#undef NTFS_GETOPT\n#undef NTFS_GETOPT_WITH_DEFAULT\n\t}\nno_mount_options:\n\tif (errors && !sloppy)\n\t\treturn false;\n\tif (sloppy)\n\t\tntfs_warning(vol->sb, \"Sloppy option given. Ignoring \"\n\t\t\t\t\"unrecognized mount option(s) and continuing.\");\n\t/* Keep this first! */\n\tif (on_errors != -1) {\n\t\tif (!on_errors) {\n\t\t\tntfs_error(vol->sb, \"Invalid errors option argument \"\n\t\t\t\t\t\"or bug in options parser.\");\n\t\t\treturn false;\n\t\t}\n\t}\n\tif (nls_map) {\n\t\tif (vol->nls_map && vol->nls_map != nls_map) {\n\t\t\tntfs_error(vol->sb, \"Cannot change NLS character set \"\n\t\t\t\t\t\"on remount.\");\n\t\t\treturn false;\n\t\t} /* else (!vol->nls_map) */\n\t\tntfs_debug(\"Using NLS character set %s.\", nls_map->charset);\n\t\tvol->nls_map = nls_map;\n\t} else /* (!nls_map) */ {\n\t\tif (!vol->nls_map) {\n\t\t\tvol->nls_map = load_nls_default();\n\t\t\tif (!vol->nls_map) {\n\t\t\t\tntfs_error(vol->sb, \"Failed to load default \"\n\t\t\t\t\t\t\"NLS character set.\");\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tntfs_debug(\"Using default NLS character set (%s).\",\n\t\t\t\t\tvol->nls_map->charset);\n\t\t}\n\t}\n\tif (mft_zone_multiplier != -1) {\n\t\tif (vol->mft_zone_multiplier && vol->mft_zone_multiplier !=\n\t\t\t\tmft_zone_multiplier) {\n\t\t\tntfs_error(vol->sb, \"Cannot change mft_zone_multiplier \"\n\t\t\t\t\t\"on remount.\");\n\t\t\treturn false;\n\t\t}\n\t\tif (mft_zone_multiplier < 1 || mft_zone_multiplier > 4) {\n\t\t\tntfs_error(vol->sb, \"Invalid mft_zone_multiplier. \"\n\t\t\t\t\t\"Using default value, i.e. 1.\");\n\t\t\tmft_zone_multiplier = 1;\n\t\t}\n\t\tvol->mft_zone_multiplier = mft_zone_multiplier;\n\t}\n\tif (!vol->mft_zone_multiplier)\n\t\tvol->mft_zone_multiplier = 1;\n\tif (on_errors != -1)\n\t\tvol->on_errors = on_errors;\n\tif (!vol->on_errors || vol->on_errors == ON_ERRORS_RECOVER)\n\t\tvol->on_errors |= ON_ERRORS_CONTINUE;\n\tif (uid_valid(uid))\n\t\tvol->uid = uid;\n\tif (gid_valid(gid))\n\t\tvol->gid = gid;\n\tif (fmask != (umode_t)-1)\n\t\tvol->fmask = fmask;\n\tif (dmask != (umode_t)-1)\n\t\tvol->dmask = dmask;\n\tif (show_sys_files != -1) {\n\t\tif (show_sys_files)\n\t\t\tNVolSetShowSystemFiles(vol);\n\t\telse\n\t\t\tNVolClearShowSystemFiles(vol);\n\t}\n\tif (case_sensitive != -1) {\n\t\tif (case_sensitive)\n\t\t\tNVolSetCaseSensitive(vol);\n\t\telse\n\t\t\tNVolClearCaseSensitive(vol);\n\t}\n\tif (disable_sparse != -1) {\n\t\tif (disable_sparse)\n\t\t\tNVolClearSparseEnabled(vol);\n\t\telse {\n\t\t\tif (!NVolSparseEnabled(vol) &&\n\t\t\t\t\tvol->major_ver && vol->major_ver < 3)\n\t\t\t\tntfs_warning(vol->sb, \"Not enabling sparse \"\n\t\t\t\t\t\t\"support due to NTFS volume \"\n\t\t\t\t\t\t\"version %i.%i (need at least \"\n\t\t\t\t\t\t\"version 3.0).\", vol->major_ver,\n\t\t\t\t\t\tvol->minor_ver);\n\t\t\telse\n\t\t\t\tNVolSetSparseEnabled(vol);\n\t\t}\n\t}\n\treturn true;\nneeds_arg:\n\tntfs_error(vol->sb, \"The %s option requires an argument.\", p);\n\treturn false;\nneeds_bool:\n\tntfs_error(vol->sb, \"The %s option requires a boolean argument.\", p);\n\treturn false;\nneeds_val:\n\tntfs_error(vol->sb, \"Invalid %s option argument: %s\", p, ov);\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ntfs_warning",
          "args": [
            "sb",
            "\"Failed to clear dirty bit \"\n\t\t\t\t\t\t\"in volume information \"\n\t\t\t\t\t\t\"flags.  Run chkdsk.\""
          ],
          "line": 555
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_clear_volume_flags",
          "args": [
            "vol",
            "VOLUME_IS_DIRTY"
          ],
          "line": 554
        },
        "resolved": true,
        "details": {
          "function_name": "ntfs_clear_volume_flags",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/super.c",
          "lines": "445-450",
          "snippet": "static inline int ntfs_clear_volume_flags(ntfs_volume *vol, VOLUME_FLAGS flags)\n{\n\tflags &= VOLUME_FLAGS_MASK;\n\tflags = vol->vol_flags & cpu_to_le16(~le16_to_cpu(flags));\n\treturn ntfs_write_volume_flags(vol, flags);\n}",
          "includes": [
            "#include \"ntfs.h\"",
            "#include \"malloc.h\"",
            "#include \"layout.h\"",
            "#include \"aops.h\"",
            "#include \"inode.h\"",
            "#include \"index.h\"",
            "#include \"debug.h\"",
            "#include \"dir.h\"",
            "#include \"usnjrnl.h\"",
            "#include \"quota.h\"",
            "#include \"logfile.h\"",
            "#include \"sysctl.h\"",
            "#include <linux/bitmap.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/vfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>\t/* For bdev_logical_block_size(). */",
            "#include <linux/spinlock.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ntfs.h\"\n#include \"malloc.h\"\n#include \"layout.h\"\n#include \"aops.h\"\n#include \"inode.h\"\n#include \"index.h\"\n#include \"debug.h\"\n#include \"dir.h\"\n#include \"usnjrnl.h\"\n#include \"quota.h\"\n#include \"logfile.h\"\n#include \"sysctl.h\"\n#include <linux/bitmap.h>\n#include <linux/moduleparam.h>\n#include <linux/vfs.h>\n#include <linux/buffer_head.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\t/* For bdev_logical_block_size(). */\n#include <linux/spinlock.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/stddef.h>\n\nstatic inline int ntfs_clear_volume_flags(ntfs_volume *vol, VOLUME_FLAGS flags)\n{\n\tflags &= VOLUME_FLAGS_MASK;\n\tflags = vol->vol_flags & cpu_to_le16(~le16_to_cpu(flags));\n\treturn ntfs_write_volume_flags(vol, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "NVolErrors",
          "args": [
            "vol"
          ],
          "line": 553
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NVolSetErrors",
          "args": [
            "vol"
          ],
          "line": 548
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_error",
          "args": [
            "sb",
            "\"Failed to stamp transation log \"\n\t\t\t\t\t\"($UsnJrnl)%s\"",
            "es"
          ],
          "line": 546
        },
        "resolved": true,
        "details": {
          "function_name": "__ntfs_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/debug.c",
          "lines": "86-108",
          "snippet": "void __ntfs_error(const char *function, const struct super_block *sb,\n\t\tconst char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\tint flen = 0;\n\n#ifndef DEBUG\n\tif (!printk_ratelimit())\n\t\treturn;\n#endif\n\tif (function)\n\t\tflen = strlen(function);\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tif (sb)\n\t\tpr_err(\"(device %s): %s(): %pV\\n\",\n\t\t       sb->s_id, flen ? function : \"\", &vaf);\n\telse\n\t\tpr_err(\"%s(): %pV\\n\", flen ? function : \"\", &vaf);\n\tva_end(args);\n}",
          "includes": [
            "#include \"debug.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"debug.h\"\n\nvoid __ntfs_error(const char *function, const struct super_block *sb,\n\t\tconst char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\tint flen = 0;\n\n#ifndef DEBUG\n\tif (!printk_ratelimit())\n\t\treturn;\n#endif\n\tif (function)\n\t\tflen = strlen(function);\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tif (sb)\n\t\tpr_err(\"(device %s): %s(): %pV\\n\",\n\t\t       sb->s_id, flen ? function : \"\", &vaf);\n\telse\n\t\tpr_err(\"%s(): %pV\\n\", flen ? function : \"\", &vaf);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ntfs_stamp_usnjrnl",
          "args": [
            "vol"
          ],
          "line": 545
        },
        "resolved": true,
        "details": {
          "function_name": "ntfs_stamp_usnjrnl",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/usnjrnl.c",
          "lines": "47-82",
          "snippet": "bool ntfs_stamp_usnjrnl(ntfs_volume *vol)\n{\n\tntfs_debug(\"Entering.\");\n\tif (likely(!NVolUsnJrnlStamped(vol))) {\n\t\tsle64 stamp;\n\t\tstruct page *page;\n\t\tUSN_HEADER *uh;\n\n\t\tpage = ntfs_map_page(vol->usnjrnl_max_ino->i_mapping, 0);\n\t\tif (IS_ERR(page)) {\n\t\t\tntfs_error(vol->sb, \"Failed to read from \"\n\t\t\t\t\t\"$UsnJrnl/$DATA/$Max attribute.\");\n\t\t\treturn false;\n\t\t}\n\t\tuh = (USN_HEADER*)page_address(page);\n\t\tstamp = get_current_ntfs_time();\n\t\tntfs_debug(\"Stamping transaction log ($UsnJrnl): old \"\n\t\t\t\t\"journal_id 0x%llx, old lowest_valid_usn \"\n\t\t\t\t\"0x%llx, new journal_id 0x%llx, new \"\n\t\t\t\t\"lowest_valid_usn 0x%llx.\",\n\t\t\t\t(long long)sle64_to_cpu(uh->journal_id),\n\t\t\t\t(long long)sle64_to_cpu(uh->lowest_valid_usn),\n\t\t\t\t(long long)sle64_to_cpu(stamp),\n\t\t\t\ti_size_read(vol->usnjrnl_j_ino));\n\t\tuh->lowest_valid_usn =\n\t\t\t\tcpu_to_sle64(i_size_read(vol->usnjrnl_j_ino));\n\t\tuh->journal_id = stamp;\n\t\tflush_dcache_page(page);\n\t\tset_page_dirty(page);\n\t\tntfs_unmap_page(page);\n\t\t/* Set the flag so we do not have to do it again on remount. */\n\t\tNVolSetUsnJrnlStamped(vol);\n\t}\n\tntfs_debug(\"Done.\");\n\treturn true;\n}",
          "includes": [
            "#include \"volume.h\"",
            "#include \"usnjrnl.h\"",
            "#include \"types.h\"",
            "#include \"time.h\"",
            "#include \"endian.h\"",
            "#include \"debug.h\"",
            "#include \"aops.h\"",
            "#include <linux/mm.h>",
            "#include <linux/highmem.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"volume.h\"\n#include \"usnjrnl.h\"\n#include \"types.h\"\n#include \"time.h\"\n#include \"endian.h\"\n#include \"debug.h\"\n#include \"aops.h\"\n#include <linux/mm.h>\n#include <linux/highmem.h>\n#include <linux/fs.h>\n\nbool ntfs_stamp_usnjrnl(ntfs_volume *vol)\n{\n\tntfs_debug(\"Entering.\");\n\tif (likely(!NVolUsnJrnlStamped(vol))) {\n\t\tsle64 stamp;\n\t\tstruct page *page;\n\t\tUSN_HEADER *uh;\n\n\t\tpage = ntfs_map_page(vol->usnjrnl_max_ino->i_mapping, 0);\n\t\tif (IS_ERR(page)) {\n\t\t\tntfs_error(vol->sb, \"Failed to read from \"\n\t\t\t\t\t\"$UsnJrnl/$DATA/$Max attribute.\");\n\t\t\treturn false;\n\t\t}\n\t\tuh = (USN_HEADER*)page_address(page);\n\t\tstamp = get_current_ntfs_time();\n\t\tntfs_debug(\"Stamping transaction log ($UsnJrnl): old \"\n\t\t\t\t\"journal_id 0x%llx, old lowest_valid_usn \"\n\t\t\t\t\"0x%llx, new journal_id 0x%llx, new \"\n\t\t\t\t\"lowest_valid_usn 0x%llx.\",\n\t\t\t\t(long long)sle64_to_cpu(uh->journal_id),\n\t\t\t\t(long long)sle64_to_cpu(uh->lowest_valid_usn),\n\t\t\t\t(long long)sle64_to_cpu(stamp),\n\t\t\t\ti_size_read(vol->usnjrnl_j_ino));\n\t\tuh->lowest_valid_usn =\n\t\t\t\tcpu_to_sle64(i_size_read(vol->usnjrnl_j_ino));\n\t\tuh->journal_id = stamp;\n\t\tflush_dcache_page(page);\n\t\tset_page_dirty(page);\n\t\tntfs_unmap_page(page);\n\t\t/* Set the flag so we do not have to do it again on remount. */\n\t\tNVolSetUsnJrnlStamped(vol);\n\t}\n\tntfs_debug(\"Done.\");\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "NVolSetErrors",
          "args": [
            "vol"
          ],
          "line": 542
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_mark_quotas_out_of_date",
          "args": [
            "vol"
          ],
          "line": 539
        },
        "resolved": true,
        "details": {
          "function_name": "ntfs_mark_quotas_out_of_date",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/quota.c",
          "lines": "37-115",
          "snippet": "bool ntfs_mark_quotas_out_of_date(ntfs_volume *vol)\n{\n\tntfs_index_context *ictx;\n\tQUOTA_CONTROL_ENTRY *qce;\n\tconst le32 qid = QUOTA_DEFAULTS_ID;\n\tint err;\n\n\tntfs_debug(\"Entering.\");\n\tif (NVolQuotaOutOfDate(vol))\n\t\tgoto done;\n\tif (!vol->quota_ino || !vol->quota_q_ino) {\n\t\tntfs_error(vol->sb, \"Quota inodes are not open.\");\n\t\treturn false;\n\t}\n\tmutex_lock(&vol->quota_q_ino->i_mutex);\n\tictx = ntfs_index_ctx_get(NTFS_I(vol->quota_q_ino));\n\tif (!ictx) {\n\t\tntfs_error(vol->sb, \"Failed to get index context.\");\n\t\tgoto err_out;\n\t}\n\terr = ntfs_index_lookup(&qid, sizeof(qid), ictx);\n\tif (err) {\n\t\tif (err == -ENOENT)\n\t\t\tntfs_error(vol->sb, \"Quota defaults entry is not \"\n\t\t\t\t\t\"present.\");\n\t\telse\n\t\t\tntfs_error(vol->sb, \"Lookup of quota defaults entry \"\n\t\t\t\t\t\"failed.\");\n\t\tgoto err_out;\n\t}\n\tif (ictx->data_len < offsetof(QUOTA_CONTROL_ENTRY, sid)) {\n\t\tntfs_error(vol->sb, \"Quota defaults entry size is invalid.  \"\n\t\t\t\t\"Run chkdsk.\");\n\t\tgoto err_out;\n\t}\n\tqce = (QUOTA_CONTROL_ENTRY*)ictx->data;\n\tif (le32_to_cpu(qce->version) != QUOTA_VERSION) {\n\t\tntfs_error(vol->sb, \"Quota defaults entry version 0x%x is not \"\n\t\t\t\t\"supported.\", le32_to_cpu(qce->version));\n\t\tgoto err_out;\n\t}\n\tntfs_debug(\"Quota defaults flags = 0x%x.\", le32_to_cpu(qce->flags));\n\t/* If quotas are already marked out of date, no need to do anything. */\n\tif (qce->flags & QUOTA_FLAG_OUT_OF_DATE)\n\t\tgoto set_done;\n\t/*\n\t * If quota tracking is neither requested, nor enabled and there are no\n\t * pending deletes, no need to mark the quotas out of date.\n\t */\n\tif (!(qce->flags & (QUOTA_FLAG_TRACKING_ENABLED |\n\t\t\tQUOTA_FLAG_TRACKING_REQUESTED |\n\t\t\tQUOTA_FLAG_PENDING_DELETES)))\n\t\tgoto set_done;\n\t/*\n\t * Set the QUOTA_FLAG_OUT_OF_DATE bit thus marking quotas out of date.\n\t * This is verified on WinXP to be sufficient to cause windows to\n\t * rescan the volume on boot and update all quota entries.\n\t */\n\tqce->flags |= QUOTA_FLAG_OUT_OF_DATE;\n\t/* Ensure the modified flags are written to disk. */\n\tntfs_index_entry_flush_dcache_page(ictx);\n\tntfs_index_entry_mark_dirty(ictx);\nset_done:\n\tntfs_index_ctx_put(ictx);\n\tmutex_unlock(&vol->quota_q_ino->i_mutex);\n\t/*\n\t * We set the flag so we do not try to mark the quotas out of date\n\t * again on remount.\n\t */\n\tNVolSetQuotaOutOfDate(vol);\ndone:\n\tntfs_debug(\"Done.\");\n\treturn true;\nerr_out:\n\tif (ictx)\n\t\tntfs_index_ctx_put(ictx);\n\tmutex_unlock(&vol->quota_q_ino->i_mutex);\n\treturn false;\n}",
          "includes": [
            "#include \"ntfs.h\"",
            "#include \"debug.h\"",
            "#include \"quota.h\"",
            "#include \"index.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ntfs.h\"\n#include \"debug.h\"\n#include \"quota.h\"\n#include \"index.h\"\n\nbool ntfs_mark_quotas_out_of_date(ntfs_volume *vol)\n{\n\tntfs_index_context *ictx;\n\tQUOTA_CONTROL_ENTRY *qce;\n\tconst le32 qid = QUOTA_DEFAULTS_ID;\n\tint err;\n\n\tntfs_debug(\"Entering.\");\n\tif (NVolQuotaOutOfDate(vol))\n\t\tgoto done;\n\tif (!vol->quota_ino || !vol->quota_q_ino) {\n\t\tntfs_error(vol->sb, \"Quota inodes are not open.\");\n\t\treturn false;\n\t}\n\tmutex_lock(&vol->quota_q_ino->i_mutex);\n\tictx = ntfs_index_ctx_get(NTFS_I(vol->quota_q_ino));\n\tif (!ictx) {\n\t\tntfs_error(vol->sb, \"Failed to get index context.\");\n\t\tgoto err_out;\n\t}\n\terr = ntfs_index_lookup(&qid, sizeof(qid), ictx);\n\tif (err) {\n\t\tif (err == -ENOENT)\n\t\t\tntfs_error(vol->sb, \"Quota defaults entry is not \"\n\t\t\t\t\t\"present.\");\n\t\telse\n\t\t\tntfs_error(vol->sb, \"Lookup of quota defaults entry \"\n\t\t\t\t\t\"failed.\");\n\t\tgoto err_out;\n\t}\n\tif (ictx->data_len < offsetof(QUOTA_CONTROL_ENTRY, sid)) {\n\t\tntfs_error(vol->sb, \"Quota defaults entry size is invalid.  \"\n\t\t\t\t\"Run chkdsk.\");\n\t\tgoto err_out;\n\t}\n\tqce = (QUOTA_CONTROL_ENTRY*)ictx->data;\n\tif (le32_to_cpu(qce->version) != QUOTA_VERSION) {\n\t\tntfs_error(vol->sb, \"Quota defaults entry version 0x%x is not \"\n\t\t\t\t\"supported.\", le32_to_cpu(qce->version));\n\t\tgoto err_out;\n\t}\n\tntfs_debug(\"Quota defaults flags = 0x%x.\", le32_to_cpu(qce->flags));\n\t/* If quotas are already marked out of date, no need to do anything. */\n\tif (qce->flags & QUOTA_FLAG_OUT_OF_DATE)\n\t\tgoto set_done;\n\t/*\n\t * If quota tracking is neither requested, nor enabled and there are no\n\t * pending deletes, no need to mark the quotas out of date.\n\t */\n\tif (!(qce->flags & (QUOTA_FLAG_TRACKING_ENABLED |\n\t\t\tQUOTA_FLAG_TRACKING_REQUESTED |\n\t\t\tQUOTA_FLAG_PENDING_DELETES)))\n\t\tgoto set_done;\n\t/*\n\t * Set the QUOTA_FLAG_OUT_OF_DATE bit thus marking quotas out of date.\n\t * This is verified on WinXP to be sufficient to cause windows to\n\t * rescan the volume on boot and update all quota entries.\n\t */\n\tqce->flags |= QUOTA_FLAG_OUT_OF_DATE;\n\t/* Ensure the modified flags are written to disk. */\n\tntfs_index_entry_flush_dcache_page(ictx);\n\tntfs_index_entry_mark_dirty(ictx);\nset_done:\n\tntfs_index_ctx_put(ictx);\n\tmutex_unlock(&vol->quota_q_ino->i_mutex);\n\t/*\n\t * We set the flag so we do not try to mark the quotas out of date\n\t * again on remount.\n\t */\n\tNVolSetQuotaOutOfDate(vol);\ndone:\n\tntfs_debug(\"Done.\");\n\treturn true;\nerr_out:\n\tif (ictx)\n\t\tntfs_index_ctx_put(ictx);\n\tmutex_unlock(&vol->quota_q_ino->i_mutex);\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "NVolSetErrors",
          "args": [
            "vol"
          ],
          "line": 536
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_empty_logfile",
          "args": [
            "vol->logfile_ino"
          ],
          "line": 533
        },
        "resolved": true,
        "details": {
          "function_name": "ntfs_empty_logfile",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/logfile.c",
          "lines": "726-861",
          "snippet": "bool ntfs_empty_logfile(struct inode *log_vi)\n{\n\tVCN vcn, end_vcn;\n\tntfs_inode *log_ni = NTFS_I(log_vi);\n\tntfs_volume *vol = log_ni->vol;\n\tstruct super_block *sb = vol->sb;\n\trunlist_element *rl;\n\tunsigned long flags;\n\tunsigned block_size, block_size_bits;\n\tint err;\n\tbool should_wait = true;\n\n\tntfs_debug(\"Entering.\");\n\tif (NVolLogFileEmpty(vol)) {\n\t\tntfs_debug(\"Done.\");\n\t\treturn true;\n\t}\n\t/*\n\t * We cannot use ntfs_attr_set() because we may be still in the middle\n\t * of a mount operation.  Thus we do the emptying by hand by first\n\t * zapping the page cache pages for the $LogFile/$DATA attribute and\n\t * then emptying each of the buffers in each of the clusters specified\n\t * by the runlist by hand.\n\t */\n\tblock_size = sb->s_blocksize;\n\tblock_size_bits = sb->s_blocksize_bits;\n\tvcn = 0;\n\tread_lock_irqsave(&log_ni->size_lock, flags);\n\tend_vcn = (log_ni->initialized_size + vol->cluster_size_mask) >>\n\t\t\tvol->cluster_size_bits;\n\tread_unlock_irqrestore(&log_ni->size_lock, flags);\n\ttruncate_inode_pages(log_vi->i_mapping, 0);\n\tdown_write(&log_ni->runlist.lock);\n\trl = log_ni->runlist.rl;\n\tif (unlikely(!rl || vcn < rl->vcn || !rl->length)) {\nmap_vcn:\n\t\terr = ntfs_map_runlist_nolock(log_ni, vcn, NULL);\n\t\tif (err) {\n\t\t\tntfs_error(sb, \"Failed to map runlist fragment (error \"\n\t\t\t\t\t\"%d).\", -err);\n\t\t\tgoto err;\n\t\t}\n\t\trl = log_ni->runlist.rl;\n\t\tBUG_ON(!rl || vcn < rl->vcn || !rl->length);\n\t}\n\t/* Seek to the runlist element containing @vcn. */\n\twhile (rl->length && vcn >= rl[1].vcn)\n\t\trl++;\n\tdo {\n\t\tLCN lcn;\n\t\tsector_t block, end_block;\n\t\ts64 len;\n\n\t\t/*\n\t\t * If this run is not mapped map it now and start again as the\n\t\t * runlist will have been updated.\n\t\t */\n\t\tlcn = rl->lcn;\n\t\tif (unlikely(lcn == LCN_RL_NOT_MAPPED)) {\n\t\t\tvcn = rl->vcn;\n\t\t\tgoto map_vcn;\n\t\t}\n\t\t/* If this run is not valid abort with an error. */\n\t\tif (unlikely(!rl->length || lcn < LCN_HOLE))\n\t\t\tgoto rl_err;\n\t\t/* Skip holes. */\n\t\tif (lcn == LCN_HOLE)\n\t\t\tcontinue;\n\t\tblock = lcn << vol->cluster_size_bits >> block_size_bits;\n\t\tlen = rl->length;\n\t\tif (rl[1].vcn > end_vcn)\n\t\t\tlen = end_vcn - rl->vcn;\n\t\tend_block = (lcn + len) << vol->cluster_size_bits >>\n\t\t\t\tblock_size_bits;\n\t\t/* Iterate over the blocks in the run and empty them. */\n\t\tdo {\n\t\t\tstruct buffer_head *bh;\n\n\t\t\t/* Obtain the buffer, possibly not uptodate. */\n\t\t\tbh = sb_getblk(sb, block);\n\t\t\tBUG_ON(!bh);\n\t\t\t/* Setup buffer i/o submission. */\n\t\t\tlock_buffer(bh);\n\t\t\tbh->b_end_io = end_buffer_write_sync;\n\t\t\tget_bh(bh);\n\t\t\t/* Set the entire contents of the buffer to 0xff. */\n\t\t\tmemset(bh->b_data, -1, block_size);\n\t\t\tif (!buffer_uptodate(bh))\n\t\t\t\tset_buffer_uptodate(bh);\n\t\t\tif (buffer_dirty(bh))\n\t\t\t\tclear_buffer_dirty(bh);\n\t\t\t/*\n\t\t\t * Submit the buffer and wait for i/o to complete but\n\t\t\t * only for the first buffer so we do not miss really\n\t\t\t * serious i/o errors.  Once the first buffer has\n\t\t\t * completed ignore errors afterwards as we can assume\n\t\t\t * that if one buffer worked all of them will work.\n\t\t\t */\n\t\t\tsubmit_bh(WRITE, bh);\n\t\t\tif (should_wait) {\n\t\t\t\tshould_wait = false;\n\t\t\t\twait_on_buffer(bh);\n\t\t\t\tif (unlikely(!buffer_uptodate(bh)))\n\t\t\t\t\tgoto io_err;\n\t\t\t}\n\t\t\tbrelse(bh);\n\t\t} while (++block < end_block);\n\t} while ((++rl)->vcn < end_vcn);\n\tup_write(&log_ni->runlist.lock);\n\t/*\n\t * Zap the pages again just in case any got instantiated whilst we were\n\t * emptying the blocks by hand.  FIXME: We may not have completed\n\t * writing to all the buffer heads yet so this may happen too early.\n\t * We really should use a kernel thread to do the emptying\n\t * asynchronously and then we can also set the volume dirty and output\n\t * an error message if emptying should fail.\n\t */\n\ttruncate_inode_pages(log_vi->i_mapping, 0);\n\t/* Set the flag so we do not have to do it again on remount. */\n\tNVolSetLogFileEmpty(vol);\n\tntfs_debug(\"Done.\");\n\treturn true;\nio_err:\n\tntfs_error(sb, \"Failed to write buffer.  Unmount and run chkdsk.\");\n\tgoto dirty_err;\nrl_err:\n\tntfs_error(sb, \"Runlist is corrupt.  Unmount and run chkdsk.\");\ndirty_err:\n\tNVolSetErrors(vol);\n\terr = -EIO;\nerr:\n\tup_write(&log_ni->runlist.lock);\n\tntfs_error(sb, \"Failed to fill $LogFile with 0xff bytes (error %d).\",\n\t\t\t-err);\n\treturn false;\n}",
          "includes": [
            "#include \"ntfs.h\"",
            "#include \"volume.h\"",
            "#include \"malloc.h\"",
            "#include \"logfile.h\"",
            "#include \"debug.h\"",
            "#include \"aops.h\"",
            "#include \"attrib.h\"",
            "#include <linux/log2.h>",
            "#include <linux/bitops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/highmem.h>",
            "#include <linux/fs.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ntfs.h\"\n#include \"volume.h\"\n#include \"malloc.h\"\n#include \"logfile.h\"\n#include \"debug.h\"\n#include \"aops.h\"\n#include \"attrib.h\"\n#include <linux/log2.h>\n#include <linux/bitops.h>\n#include <linux/buffer_head.h>\n#include <linux/highmem.h>\n#include <linux/fs.h>\n#include <linux/types.h>\n\nbool ntfs_empty_logfile(struct inode *log_vi)\n{\n\tVCN vcn, end_vcn;\n\tntfs_inode *log_ni = NTFS_I(log_vi);\n\tntfs_volume *vol = log_ni->vol;\n\tstruct super_block *sb = vol->sb;\n\trunlist_element *rl;\n\tunsigned long flags;\n\tunsigned block_size, block_size_bits;\n\tint err;\n\tbool should_wait = true;\n\n\tntfs_debug(\"Entering.\");\n\tif (NVolLogFileEmpty(vol)) {\n\t\tntfs_debug(\"Done.\");\n\t\treturn true;\n\t}\n\t/*\n\t * We cannot use ntfs_attr_set() because we may be still in the middle\n\t * of a mount operation.  Thus we do the emptying by hand by first\n\t * zapping the page cache pages for the $LogFile/$DATA attribute and\n\t * then emptying each of the buffers in each of the clusters specified\n\t * by the runlist by hand.\n\t */\n\tblock_size = sb->s_blocksize;\n\tblock_size_bits = sb->s_blocksize_bits;\n\tvcn = 0;\n\tread_lock_irqsave(&log_ni->size_lock, flags);\n\tend_vcn = (log_ni->initialized_size + vol->cluster_size_mask) >>\n\t\t\tvol->cluster_size_bits;\n\tread_unlock_irqrestore(&log_ni->size_lock, flags);\n\ttruncate_inode_pages(log_vi->i_mapping, 0);\n\tdown_write(&log_ni->runlist.lock);\n\trl = log_ni->runlist.rl;\n\tif (unlikely(!rl || vcn < rl->vcn || !rl->length)) {\nmap_vcn:\n\t\terr = ntfs_map_runlist_nolock(log_ni, vcn, NULL);\n\t\tif (err) {\n\t\t\tntfs_error(sb, \"Failed to map runlist fragment (error \"\n\t\t\t\t\t\"%d).\", -err);\n\t\t\tgoto err;\n\t\t}\n\t\trl = log_ni->runlist.rl;\n\t\tBUG_ON(!rl || vcn < rl->vcn || !rl->length);\n\t}\n\t/* Seek to the runlist element containing @vcn. */\n\twhile (rl->length && vcn >= rl[1].vcn)\n\t\trl++;\n\tdo {\n\t\tLCN lcn;\n\t\tsector_t block, end_block;\n\t\ts64 len;\n\n\t\t/*\n\t\t * If this run is not mapped map it now and start again as the\n\t\t * runlist will have been updated.\n\t\t */\n\t\tlcn = rl->lcn;\n\t\tif (unlikely(lcn == LCN_RL_NOT_MAPPED)) {\n\t\t\tvcn = rl->vcn;\n\t\t\tgoto map_vcn;\n\t\t}\n\t\t/* If this run is not valid abort with an error. */\n\t\tif (unlikely(!rl->length || lcn < LCN_HOLE))\n\t\t\tgoto rl_err;\n\t\t/* Skip holes. */\n\t\tif (lcn == LCN_HOLE)\n\t\t\tcontinue;\n\t\tblock = lcn << vol->cluster_size_bits >> block_size_bits;\n\t\tlen = rl->length;\n\t\tif (rl[1].vcn > end_vcn)\n\t\t\tlen = end_vcn - rl->vcn;\n\t\tend_block = (lcn + len) << vol->cluster_size_bits >>\n\t\t\t\tblock_size_bits;\n\t\t/* Iterate over the blocks in the run and empty them. */\n\t\tdo {\n\t\t\tstruct buffer_head *bh;\n\n\t\t\t/* Obtain the buffer, possibly not uptodate. */\n\t\t\tbh = sb_getblk(sb, block);\n\t\t\tBUG_ON(!bh);\n\t\t\t/* Setup buffer i/o submission. */\n\t\t\tlock_buffer(bh);\n\t\t\tbh->b_end_io = end_buffer_write_sync;\n\t\t\tget_bh(bh);\n\t\t\t/* Set the entire contents of the buffer to 0xff. */\n\t\t\tmemset(bh->b_data, -1, block_size);\n\t\t\tif (!buffer_uptodate(bh))\n\t\t\t\tset_buffer_uptodate(bh);\n\t\t\tif (buffer_dirty(bh))\n\t\t\t\tclear_buffer_dirty(bh);\n\t\t\t/*\n\t\t\t * Submit the buffer and wait for i/o to complete but\n\t\t\t * only for the first buffer so we do not miss really\n\t\t\t * serious i/o errors.  Once the first buffer has\n\t\t\t * completed ignore errors afterwards as we can assume\n\t\t\t * that if one buffer worked all of them will work.\n\t\t\t */\n\t\t\tsubmit_bh(WRITE, bh);\n\t\t\tif (should_wait) {\n\t\t\t\tshould_wait = false;\n\t\t\t\twait_on_buffer(bh);\n\t\t\t\tif (unlikely(!buffer_uptodate(bh)))\n\t\t\t\t\tgoto io_err;\n\t\t\t}\n\t\t\tbrelse(bh);\n\t\t} while (++block < end_block);\n\t} while ((++rl)->vcn < end_vcn);\n\tup_write(&log_ni->runlist.lock);\n\t/*\n\t * Zap the pages again just in case any got instantiated whilst we were\n\t * emptying the blocks by hand.  FIXME: We may not have completed\n\t * writing to all the buffer heads yet so this may happen too early.\n\t * We really should use a kernel thread to do the emptying\n\t * asynchronously and then we can also set the volume dirty and output\n\t * an error message if emptying should fail.\n\t */\n\ttruncate_inode_pages(log_vi->i_mapping, 0);\n\t/* Set the flag so we do not have to do it again on remount. */\n\tNVolSetLogFileEmpty(vol);\n\tntfs_debug(\"Done.\");\n\treturn true;\nio_err:\n\tntfs_error(sb, \"Failed to write buffer.  Unmount and run chkdsk.\");\n\tgoto dirty_err;\nrl_err:\n\tntfs_error(sb, \"Runlist is corrupt.  Unmount and run chkdsk.\");\ndirty_err:\n\tNVolSetErrors(vol);\n\terr = -EIO;\nerr:\n\tup_write(&log_ni->runlist.lock);\n\tntfs_error(sb, \"Failed to fill $LogFile with 0xff bytes (error %d).\",\n\t\t\t-err);\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "NVolSetErrors",
          "args": [
            "vol"
          ],
          "line": 528
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_set_volume_flags",
          "args": [
            "vol",
            "VOLUME_MOUNTED_ON_NT4"
          ],
          "line": 525
        },
        "resolved": true,
        "details": {
          "function_name": "ntfs_set_volume_flags",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/super.c",
          "lines": "430-434",
          "snippet": "static inline int ntfs_set_volume_flags(ntfs_volume *vol, VOLUME_FLAGS flags)\n{\n\tflags &= VOLUME_FLAGS_MASK;\n\treturn ntfs_write_volume_flags(vol, vol->vol_flags | flags);\n}",
          "includes": [
            "#include \"ntfs.h\"",
            "#include \"malloc.h\"",
            "#include \"layout.h\"",
            "#include \"aops.h\"",
            "#include \"inode.h\"",
            "#include \"index.h\"",
            "#include \"debug.h\"",
            "#include \"dir.h\"",
            "#include \"usnjrnl.h\"",
            "#include \"quota.h\"",
            "#include \"logfile.h\"",
            "#include \"sysctl.h\"",
            "#include <linux/bitmap.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/vfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>\t/* For bdev_logical_block_size(). */",
            "#include <linux/spinlock.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ntfs.h\"\n#include \"malloc.h\"\n#include \"layout.h\"\n#include \"aops.h\"\n#include \"inode.h\"\n#include \"index.h\"\n#include \"debug.h\"\n#include \"dir.h\"\n#include \"usnjrnl.h\"\n#include \"quota.h\"\n#include \"logfile.h\"\n#include \"sysctl.h\"\n#include <linux/bitmap.h>\n#include <linux/moduleparam.h>\n#include <linux/vfs.h>\n#include <linux/buffer_head.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\t/* For bdev_logical_block_size(). */\n#include <linux/spinlock.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/stddef.h>\n\nstatic inline int ntfs_set_volume_flags(ntfs_volume *vol, VOLUME_FLAGS flags)\n{\n\tflags &= VOLUME_FLAGS_MASK;\n\treturn ntfs_write_volume_flags(vol, vol->vol_flags | flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "le16_to_cpu",
          "args": [
            "vol->vol_flags"
          ],
          "line": 511
        },
        "resolved": true,
        "details": {
          "function_name": "sle16_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "48-51",
          "snippet": "static inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "NVolErrors",
          "args": [
            "vol"
          ],
          "line": 494
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sync_filesystem",
          "args": [
            "sb"
          ],
          "line": 472
        },
        "resolved": true,
        "details": {
          "function_name": "sync_filesystem",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/sync.c",
          "lines": "47-67",
          "snippet": "int sync_filesystem(struct super_block *sb)\n{\n\tint ret;\n\n\t/*\n\t * We need to be protected against the filesystem going from\n\t * r/o to r/w or vice versa.\n\t */\n\tWARN_ON(!rwsem_is_locked(&sb->s_umount));\n\n\t/*\n\t * No point in syncing out anything if the filesystem is read-only.\n\t */\n\tif (sb->s_flags & MS_RDONLY)\n\t\treturn 0;\n\n\tret = __sync_filesystem(sb, 0);\n\tif (ret < 0)\n\t\treturn ret;\n\treturn __sync_filesystem(sb, 1);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/backing-dev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/linkage.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/writeback.h>",
            "#include <linux/sched.h>",
            "#include <linux/namei.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/backing-dev.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/linkage.h>\n#include <linux/syscalls.h>\n#include <linux/writeback.h>\n#include <linux/sched.h>\n#include <linux/namei.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/kernel.h>\n\nint sync_filesystem(struct super_block *sb)\n{\n\tint ret;\n\n\t/*\n\t * We need to be protected against the filesystem going from\n\t * r/o to r/w or vice versa.\n\t */\n\tWARN_ON(!rwsem_is_locked(&sb->s_umount));\n\n\t/*\n\t * No point in syncing out anything if the filesystem is read-only.\n\t */\n\tif (sb->s_flags & MS_RDONLY)\n\t\treturn 0;\n\n\tret = __sync_filesystem(sb, 0);\n\tif (ret < 0)\n\t\treturn ret;\n\treturn __sync_filesystem(sb, 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ntfs_debug",
          "args": [
            "\"Entering with remount options string: %s\"",
            "opt"
          ],
          "line": 470
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NTFS_SB",
          "args": [
            "sb"
          ],
          "line": 468
        },
        "resolved": true,
        "details": {
          "function_name": "NTFS_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/ntfs.h",
          "lines": "80-83",
          "snippet": "static inline ntfs_volume *NTFS_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"layout.h\"",
            "#include \"volume.h\"",
            "#include \"types.h\"",
            "#include <linux/pagemap.h>",
            "#include <linux/smp.h>",
            "#include <linux/nls.h>",
            "#include <linux/fs.h>",
            "#include <linux/compiler.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"layout.h\"\n#include \"volume.h\"\n#include \"types.h\"\n#include <linux/pagemap.h>\n#include <linux/smp.h>\n#include <linux/nls.h>\n#include <linux/fs.h>\n#include <linux/compiler.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/stddef.h>\n\nstatic inline ntfs_volume *NTFS_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ntfs.h\"\n#include \"malloc.h\"\n#include \"layout.h\"\n#include \"aops.h\"\n#include \"inode.h\"\n#include \"index.h\"\n#include \"debug.h\"\n#include \"dir.h\"\n#include \"usnjrnl.h\"\n#include \"quota.h\"\n#include \"logfile.h\"\n#include \"sysctl.h\"\n#include <linux/bitmap.h>\n#include <linux/moduleparam.h>\n#include <linux/vfs.h>\n#include <linux/buffer_head.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\t/* For bdev_logical_block_size(). */\n#include <linux/spinlock.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/stddef.h>\n\nstatic int ntfs_remount(struct super_block *sb, int *flags, char *opt)\n{\n\tntfs_volume *vol = NTFS_SB(sb);\n\n\tntfs_debug(\"Entering with remount options string: %s\", opt);\n\n\tsync_filesystem(sb);\n\n#ifndef NTFS_RW\n\t/* For read-only compiled driver, enforce read-only flag. */\n\t*flags |= MS_RDONLY;\n#else /* NTFS_RW */\n\t/*\n\t * For the read-write compiled driver, if we are remounting read-write,\n\t * make sure there are no volume errors and that no unsupported volume\n\t * flags are set.  Also, empty the logfile journal as it would become\n\t * stale as soon as something is written to the volume and mark the\n\t * volume dirty so that chkdsk is run if the volume is not umounted\n\t * cleanly.  Finally, mark the quotas out of date so Windows rescans\n\t * the volume on boot and updates them.\n\t *\n\t * When remounting read-only, mark the volume clean if no volume errors\n\t * have occurred.\n\t */\n\tif ((sb->s_flags & MS_RDONLY) && !(*flags & MS_RDONLY)) {\n\t\tstatic const char *es = \".  Cannot remount read-write.\";\n\n\t\t/* Remounting read-write. */\n\t\tif (NVolErrors(vol)) {\n\t\t\tntfs_error(sb, \"Volume has errors and is read-only%s\",\n\t\t\t\t\tes);\n\t\t\treturn -EROFS;\n\t\t}\n\t\tif (vol->vol_flags & VOLUME_IS_DIRTY) {\n\t\t\tntfs_error(sb, \"Volume is dirty and read-only%s\", es);\n\t\t\treturn -EROFS;\n\t\t}\n\t\tif (vol->vol_flags & VOLUME_MODIFIED_BY_CHKDSK) {\n\t\t\tntfs_error(sb, \"Volume has been modified by chkdsk \"\n\t\t\t\t\t\"and is read-only%s\", es);\n\t\t\treturn -EROFS;\n\t\t}\n\t\tif (vol->vol_flags & VOLUME_MUST_MOUNT_RO_MASK) {\n\t\t\tntfs_error(sb, \"Volume has unsupported flags set \"\n\t\t\t\t\t\"(0x%x) and is read-only%s\",\n\t\t\t\t\t(unsigned)le16_to_cpu(vol->vol_flags),\n\t\t\t\t\tes);\n\t\t\treturn -EROFS;\n\t\t}\n\t\tif (ntfs_set_volume_flags(vol, VOLUME_IS_DIRTY)) {\n\t\t\tntfs_error(sb, \"Failed to set dirty bit in volume \"\n\t\t\t\t\t\"information flags%s\", es);\n\t\t\treturn -EROFS;\n\t\t}\n#if 0\n\t\t// TODO: Enable this code once we start modifying anything that\n\t\t//\t is different between NTFS 1.2 and 3.x...\n\t\t/* Set NT4 compatibility flag on newer NTFS version volumes. */\n\t\tif ((vol->major_ver > 1)) {\n\t\t\tif (ntfs_set_volume_flags(vol, VOLUME_MOUNTED_ON_NT4)) {\n\t\t\t\tntfs_error(sb, \"Failed to set NT4 \"\n\t\t\t\t\t\t\"compatibility flag%s\", es);\n\t\t\t\tNVolSetErrors(vol);\n\t\t\t\treturn -EROFS;\n\t\t\t}\n\t\t}\n#endif\n\t\tif (!ntfs_empty_logfile(vol->logfile_ino)) {\n\t\t\tntfs_error(sb, \"Failed to empty journal $LogFile%s\",\n\t\t\t\t\tes);\n\t\t\tNVolSetErrors(vol);\n\t\t\treturn -EROFS;\n\t\t}\n\t\tif (!ntfs_mark_quotas_out_of_date(vol)) {\n\t\t\tntfs_error(sb, \"Failed to mark quotas out of date%s\",\n\t\t\t\t\tes);\n\t\t\tNVolSetErrors(vol);\n\t\t\treturn -EROFS;\n\t\t}\n\t\tif (!ntfs_stamp_usnjrnl(vol)) {\n\t\t\tntfs_error(sb, \"Failed to stamp transation log \"\n\t\t\t\t\t\"($UsnJrnl)%s\", es);\n\t\t\tNVolSetErrors(vol);\n\t\t\treturn -EROFS;\n\t\t}\n\t} else if (!(sb->s_flags & MS_RDONLY) && (*flags & MS_RDONLY)) {\n\t\t/* Remounting read-only. */\n\t\tif (!NVolErrors(vol)) {\n\t\t\tif (ntfs_clear_volume_flags(vol, VOLUME_IS_DIRTY))\n\t\t\t\tntfs_warning(sb, \"Failed to clear dirty bit \"\n\t\t\t\t\t\t\"in volume information \"\n\t\t\t\t\t\t\"flags.  Run chkdsk.\");\n\t\t}\n\t}\n#endif /* NTFS_RW */\n\n\t// TODO: Deal with *flags.\n\n\tif (!parse_options(vol, opt))\n\t\treturn -EINVAL;\n\n\tntfs_debug(\"Done.\");\n\treturn 0;\n}"
  },
  {
    "function_name": "ntfs_clear_volume_flags",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/super.c",
    "lines": "445-450",
    "snippet": "static inline int ntfs_clear_volume_flags(ntfs_volume *vol, VOLUME_FLAGS flags)\n{\n\tflags &= VOLUME_FLAGS_MASK;\n\tflags = vol->vol_flags & cpu_to_le16(~le16_to_cpu(flags));\n\treturn ntfs_write_volume_flags(vol, flags);\n}",
    "includes": [
      "#include \"ntfs.h\"",
      "#include \"malloc.h\"",
      "#include \"layout.h\"",
      "#include \"aops.h\"",
      "#include \"inode.h\"",
      "#include \"index.h\"",
      "#include \"debug.h\"",
      "#include \"dir.h\"",
      "#include \"usnjrnl.h\"",
      "#include \"quota.h\"",
      "#include \"logfile.h\"",
      "#include \"sysctl.h\"",
      "#include <linux/bitmap.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/vfs.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/blkdev.h>\t/* For bdev_logical_block_size(). */",
      "#include <linux/spinlock.h>",
      "#include <linux/string.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/stddef.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ntfs_write_volume_flags",
          "args": [
            "vol",
            "flags"
          ],
          "line": 449
        },
        "resolved": true,
        "details": {
          "function_name": "ntfs_write_volume_flags",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/super.c",
          "lines": "375-419",
          "snippet": "static int ntfs_write_volume_flags(ntfs_volume *vol, const VOLUME_FLAGS flags)\n{\n\tntfs_inode *ni = NTFS_I(vol->vol_ino);\n\tMFT_RECORD *m;\n\tVOLUME_INFORMATION *vi;\n\tntfs_attr_search_ctx *ctx;\n\tint err;\n\n\tntfs_debug(\"Entering, old flags = 0x%x, new flags = 0x%x.\",\n\t\t\tle16_to_cpu(vol->vol_flags), le16_to_cpu(flags));\n\tif (vol->vol_flags == flags)\n\t\tgoto done;\n\tBUG_ON(!ni);\n\tm = map_mft_record(ni);\n\tif (IS_ERR(m)) {\n\t\terr = PTR_ERR(m);\n\t\tgoto err_out;\n\t}\n\tctx = ntfs_attr_get_search_ctx(ni, m);\n\tif (!ctx) {\n\t\terr = -ENOMEM;\n\t\tgoto put_unm_err_out;\n\t}\n\terr = ntfs_attr_lookup(AT_VOLUME_INFORMATION, NULL, 0, 0, 0, NULL, 0,\n\t\t\tctx);\n\tif (err)\n\t\tgoto put_unm_err_out;\n\tvi = (VOLUME_INFORMATION*)((u8*)ctx->attr +\n\t\t\tle16_to_cpu(ctx->attr->data.resident.value_offset));\n\tvol->vol_flags = vi->flags = flags;\n\tflush_dcache_mft_record_page(ctx->ntfs_ino);\n\tmark_mft_record_dirty(ctx->ntfs_ino);\n\tntfs_attr_put_search_ctx(ctx);\n\tunmap_mft_record(ni);\ndone:\n\tntfs_debug(\"Done.\");\n\treturn 0;\nput_unm_err_out:\n\tif (ctx)\n\t\tntfs_attr_put_search_ctx(ctx);\n\tunmap_mft_record(ni);\nerr_out:\n\tntfs_error(vol->sb, \"Failed with error code %i.\", -err);\n\treturn err;\n}",
          "includes": [
            "#include \"ntfs.h\"",
            "#include \"malloc.h\"",
            "#include \"layout.h\"",
            "#include \"aops.h\"",
            "#include \"inode.h\"",
            "#include \"index.h\"",
            "#include \"debug.h\"",
            "#include \"dir.h\"",
            "#include \"usnjrnl.h\"",
            "#include \"quota.h\"",
            "#include \"logfile.h\"",
            "#include \"sysctl.h\"",
            "#include <linux/bitmap.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/vfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>\t/* For bdev_logical_block_size(). */",
            "#include <linux/spinlock.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ntfs.h\"\n#include \"malloc.h\"\n#include \"layout.h\"\n#include \"aops.h\"\n#include \"inode.h\"\n#include \"index.h\"\n#include \"debug.h\"\n#include \"dir.h\"\n#include \"usnjrnl.h\"\n#include \"quota.h\"\n#include \"logfile.h\"\n#include \"sysctl.h\"\n#include <linux/bitmap.h>\n#include <linux/moduleparam.h>\n#include <linux/vfs.h>\n#include <linux/buffer_head.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\t/* For bdev_logical_block_size(). */\n#include <linux/spinlock.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/stddef.h>\n\nstatic int ntfs_write_volume_flags(ntfs_volume *vol, const VOLUME_FLAGS flags)\n{\n\tntfs_inode *ni = NTFS_I(vol->vol_ino);\n\tMFT_RECORD *m;\n\tVOLUME_INFORMATION *vi;\n\tntfs_attr_search_ctx *ctx;\n\tint err;\n\n\tntfs_debug(\"Entering, old flags = 0x%x, new flags = 0x%x.\",\n\t\t\tle16_to_cpu(vol->vol_flags), le16_to_cpu(flags));\n\tif (vol->vol_flags == flags)\n\t\tgoto done;\n\tBUG_ON(!ni);\n\tm = map_mft_record(ni);\n\tif (IS_ERR(m)) {\n\t\terr = PTR_ERR(m);\n\t\tgoto err_out;\n\t}\n\tctx = ntfs_attr_get_search_ctx(ni, m);\n\tif (!ctx) {\n\t\terr = -ENOMEM;\n\t\tgoto put_unm_err_out;\n\t}\n\terr = ntfs_attr_lookup(AT_VOLUME_INFORMATION, NULL, 0, 0, 0, NULL, 0,\n\t\t\tctx);\n\tif (err)\n\t\tgoto put_unm_err_out;\n\tvi = (VOLUME_INFORMATION*)((u8*)ctx->attr +\n\t\t\tle16_to_cpu(ctx->attr->data.resident.value_offset));\n\tvol->vol_flags = vi->flags = flags;\n\tflush_dcache_mft_record_page(ctx->ntfs_ino);\n\tmark_mft_record_dirty(ctx->ntfs_ino);\n\tntfs_attr_put_search_ctx(ctx);\n\tunmap_mft_record(ni);\ndone:\n\tntfs_debug(\"Done.\");\n\treturn 0;\nput_unm_err_out:\n\tif (ctx)\n\t\tntfs_attr_put_search_ctx(ctx);\n\tunmap_mft_record(ni);\nerr_out:\n\tntfs_error(vol->sb, \"Failed with error code %i.\", -err);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "~le16_to_cpu(flags)"
          ],
          "line": 448
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le16_to_cpu",
          "args": [
            "flags"
          ],
          "line": 448
        },
        "resolved": true,
        "details": {
          "function_name": "sle16_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "48-51",
          "snippet": "static inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ntfs.h\"\n#include \"malloc.h\"\n#include \"layout.h\"\n#include \"aops.h\"\n#include \"inode.h\"\n#include \"index.h\"\n#include \"debug.h\"\n#include \"dir.h\"\n#include \"usnjrnl.h\"\n#include \"quota.h\"\n#include \"logfile.h\"\n#include \"sysctl.h\"\n#include <linux/bitmap.h>\n#include <linux/moduleparam.h>\n#include <linux/vfs.h>\n#include <linux/buffer_head.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\t/* For bdev_logical_block_size(). */\n#include <linux/spinlock.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/stddef.h>\n\nstatic inline int ntfs_clear_volume_flags(ntfs_volume *vol, VOLUME_FLAGS flags)\n{\n\tflags &= VOLUME_FLAGS_MASK;\n\tflags = vol->vol_flags & cpu_to_le16(~le16_to_cpu(flags));\n\treturn ntfs_write_volume_flags(vol, flags);\n}"
  },
  {
    "function_name": "ntfs_set_volume_flags",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/super.c",
    "lines": "430-434",
    "snippet": "static inline int ntfs_set_volume_flags(ntfs_volume *vol, VOLUME_FLAGS flags)\n{\n\tflags &= VOLUME_FLAGS_MASK;\n\treturn ntfs_write_volume_flags(vol, vol->vol_flags | flags);\n}",
    "includes": [
      "#include \"ntfs.h\"",
      "#include \"malloc.h\"",
      "#include \"layout.h\"",
      "#include \"aops.h\"",
      "#include \"inode.h\"",
      "#include \"index.h\"",
      "#include \"debug.h\"",
      "#include \"dir.h\"",
      "#include \"usnjrnl.h\"",
      "#include \"quota.h\"",
      "#include \"logfile.h\"",
      "#include \"sysctl.h\"",
      "#include <linux/bitmap.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/vfs.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/blkdev.h>\t/* For bdev_logical_block_size(). */",
      "#include <linux/spinlock.h>",
      "#include <linux/string.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/stddef.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ntfs_write_volume_flags",
          "args": [
            "vol",
            "vol->vol_flags | flags"
          ],
          "line": 433
        },
        "resolved": true,
        "details": {
          "function_name": "ntfs_write_volume_flags",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/super.c",
          "lines": "375-419",
          "snippet": "static int ntfs_write_volume_flags(ntfs_volume *vol, const VOLUME_FLAGS flags)\n{\n\tntfs_inode *ni = NTFS_I(vol->vol_ino);\n\tMFT_RECORD *m;\n\tVOLUME_INFORMATION *vi;\n\tntfs_attr_search_ctx *ctx;\n\tint err;\n\n\tntfs_debug(\"Entering, old flags = 0x%x, new flags = 0x%x.\",\n\t\t\tle16_to_cpu(vol->vol_flags), le16_to_cpu(flags));\n\tif (vol->vol_flags == flags)\n\t\tgoto done;\n\tBUG_ON(!ni);\n\tm = map_mft_record(ni);\n\tif (IS_ERR(m)) {\n\t\terr = PTR_ERR(m);\n\t\tgoto err_out;\n\t}\n\tctx = ntfs_attr_get_search_ctx(ni, m);\n\tif (!ctx) {\n\t\terr = -ENOMEM;\n\t\tgoto put_unm_err_out;\n\t}\n\terr = ntfs_attr_lookup(AT_VOLUME_INFORMATION, NULL, 0, 0, 0, NULL, 0,\n\t\t\tctx);\n\tif (err)\n\t\tgoto put_unm_err_out;\n\tvi = (VOLUME_INFORMATION*)((u8*)ctx->attr +\n\t\t\tle16_to_cpu(ctx->attr->data.resident.value_offset));\n\tvol->vol_flags = vi->flags = flags;\n\tflush_dcache_mft_record_page(ctx->ntfs_ino);\n\tmark_mft_record_dirty(ctx->ntfs_ino);\n\tntfs_attr_put_search_ctx(ctx);\n\tunmap_mft_record(ni);\ndone:\n\tntfs_debug(\"Done.\");\n\treturn 0;\nput_unm_err_out:\n\tif (ctx)\n\t\tntfs_attr_put_search_ctx(ctx);\n\tunmap_mft_record(ni);\nerr_out:\n\tntfs_error(vol->sb, \"Failed with error code %i.\", -err);\n\treturn err;\n}",
          "includes": [
            "#include \"ntfs.h\"",
            "#include \"malloc.h\"",
            "#include \"layout.h\"",
            "#include \"aops.h\"",
            "#include \"inode.h\"",
            "#include \"index.h\"",
            "#include \"debug.h\"",
            "#include \"dir.h\"",
            "#include \"usnjrnl.h\"",
            "#include \"quota.h\"",
            "#include \"logfile.h\"",
            "#include \"sysctl.h\"",
            "#include <linux/bitmap.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/vfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>\t/* For bdev_logical_block_size(). */",
            "#include <linux/spinlock.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ntfs.h\"\n#include \"malloc.h\"\n#include \"layout.h\"\n#include \"aops.h\"\n#include \"inode.h\"\n#include \"index.h\"\n#include \"debug.h\"\n#include \"dir.h\"\n#include \"usnjrnl.h\"\n#include \"quota.h\"\n#include \"logfile.h\"\n#include \"sysctl.h\"\n#include <linux/bitmap.h>\n#include <linux/moduleparam.h>\n#include <linux/vfs.h>\n#include <linux/buffer_head.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\t/* For bdev_logical_block_size(). */\n#include <linux/spinlock.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/stddef.h>\n\nstatic int ntfs_write_volume_flags(ntfs_volume *vol, const VOLUME_FLAGS flags)\n{\n\tntfs_inode *ni = NTFS_I(vol->vol_ino);\n\tMFT_RECORD *m;\n\tVOLUME_INFORMATION *vi;\n\tntfs_attr_search_ctx *ctx;\n\tint err;\n\n\tntfs_debug(\"Entering, old flags = 0x%x, new flags = 0x%x.\",\n\t\t\tle16_to_cpu(vol->vol_flags), le16_to_cpu(flags));\n\tif (vol->vol_flags == flags)\n\t\tgoto done;\n\tBUG_ON(!ni);\n\tm = map_mft_record(ni);\n\tif (IS_ERR(m)) {\n\t\terr = PTR_ERR(m);\n\t\tgoto err_out;\n\t}\n\tctx = ntfs_attr_get_search_ctx(ni, m);\n\tif (!ctx) {\n\t\terr = -ENOMEM;\n\t\tgoto put_unm_err_out;\n\t}\n\terr = ntfs_attr_lookup(AT_VOLUME_INFORMATION, NULL, 0, 0, 0, NULL, 0,\n\t\t\tctx);\n\tif (err)\n\t\tgoto put_unm_err_out;\n\tvi = (VOLUME_INFORMATION*)((u8*)ctx->attr +\n\t\t\tle16_to_cpu(ctx->attr->data.resident.value_offset));\n\tvol->vol_flags = vi->flags = flags;\n\tflush_dcache_mft_record_page(ctx->ntfs_ino);\n\tmark_mft_record_dirty(ctx->ntfs_ino);\n\tntfs_attr_put_search_ctx(ctx);\n\tunmap_mft_record(ni);\ndone:\n\tntfs_debug(\"Done.\");\n\treturn 0;\nput_unm_err_out:\n\tif (ctx)\n\t\tntfs_attr_put_search_ctx(ctx);\n\tunmap_mft_record(ni);\nerr_out:\n\tntfs_error(vol->sb, \"Failed with error code %i.\", -err);\n\treturn err;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ntfs.h\"\n#include \"malloc.h\"\n#include \"layout.h\"\n#include \"aops.h\"\n#include \"inode.h\"\n#include \"index.h\"\n#include \"debug.h\"\n#include \"dir.h\"\n#include \"usnjrnl.h\"\n#include \"quota.h\"\n#include \"logfile.h\"\n#include \"sysctl.h\"\n#include <linux/bitmap.h>\n#include <linux/moduleparam.h>\n#include <linux/vfs.h>\n#include <linux/buffer_head.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\t/* For bdev_logical_block_size(). */\n#include <linux/spinlock.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/stddef.h>\n\nstatic inline int ntfs_set_volume_flags(ntfs_volume *vol, VOLUME_FLAGS flags)\n{\n\tflags &= VOLUME_FLAGS_MASK;\n\treturn ntfs_write_volume_flags(vol, vol->vol_flags | flags);\n}"
  },
  {
    "function_name": "ntfs_write_volume_flags",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/super.c",
    "lines": "375-419",
    "snippet": "static int ntfs_write_volume_flags(ntfs_volume *vol, const VOLUME_FLAGS flags)\n{\n\tntfs_inode *ni = NTFS_I(vol->vol_ino);\n\tMFT_RECORD *m;\n\tVOLUME_INFORMATION *vi;\n\tntfs_attr_search_ctx *ctx;\n\tint err;\n\n\tntfs_debug(\"Entering, old flags = 0x%x, new flags = 0x%x.\",\n\t\t\tle16_to_cpu(vol->vol_flags), le16_to_cpu(flags));\n\tif (vol->vol_flags == flags)\n\t\tgoto done;\n\tBUG_ON(!ni);\n\tm = map_mft_record(ni);\n\tif (IS_ERR(m)) {\n\t\terr = PTR_ERR(m);\n\t\tgoto err_out;\n\t}\n\tctx = ntfs_attr_get_search_ctx(ni, m);\n\tif (!ctx) {\n\t\terr = -ENOMEM;\n\t\tgoto put_unm_err_out;\n\t}\n\terr = ntfs_attr_lookup(AT_VOLUME_INFORMATION, NULL, 0, 0, 0, NULL, 0,\n\t\t\tctx);\n\tif (err)\n\t\tgoto put_unm_err_out;\n\tvi = (VOLUME_INFORMATION*)((u8*)ctx->attr +\n\t\t\tle16_to_cpu(ctx->attr->data.resident.value_offset));\n\tvol->vol_flags = vi->flags = flags;\n\tflush_dcache_mft_record_page(ctx->ntfs_ino);\n\tmark_mft_record_dirty(ctx->ntfs_ino);\n\tntfs_attr_put_search_ctx(ctx);\n\tunmap_mft_record(ni);\ndone:\n\tntfs_debug(\"Done.\");\n\treturn 0;\nput_unm_err_out:\n\tif (ctx)\n\t\tntfs_attr_put_search_ctx(ctx);\n\tunmap_mft_record(ni);\nerr_out:\n\tntfs_error(vol->sb, \"Failed with error code %i.\", -err);\n\treturn err;\n}",
    "includes": [
      "#include \"ntfs.h\"",
      "#include \"malloc.h\"",
      "#include \"layout.h\"",
      "#include \"aops.h\"",
      "#include \"inode.h\"",
      "#include \"index.h\"",
      "#include \"debug.h\"",
      "#include \"dir.h\"",
      "#include \"usnjrnl.h\"",
      "#include \"quota.h\"",
      "#include \"logfile.h\"",
      "#include \"sysctl.h\"",
      "#include <linux/bitmap.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/vfs.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/blkdev.h>\t/* For bdev_logical_block_size(). */",
      "#include <linux/spinlock.h>",
      "#include <linux/string.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/stddef.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ntfs_error",
          "args": [
            "vol->sb",
            "\"Failed with error code %i.\"",
            "-err"
          ],
          "line": 417
        },
        "resolved": true,
        "details": {
          "function_name": "__ntfs_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/debug.c",
          "lines": "86-108",
          "snippet": "void __ntfs_error(const char *function, const struct super_block *sb,\n\t\tconst char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\tint flen = 0;\n\n#ifndef DEBUG\n\tif (!printk_ratelimit())\n\t\treturn;\n#endif\n\tif (function)\n\t\tflen = strlen(function);\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tif (sb)\n\t\tpr_err(\"(device %s): %s(): %pV\\n\",\n\t\t       sb->s_id, flen ? function : \"\", &vaf);\n\telse\n\t\tpr_err(\"%s(): %pV\\n\", flen ? function : \"\", &vaf);\n\tva_end(args);\n}",
          "includes": [
            "#include \"debug.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"debug.h\"\n\nvoid __ntfs_error(const char *function, const struct super_block *sb,\n\t\tconst char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\tint flen = 0;\n\n#ifndef DEBUG\n\tif (!printk_ratelimit())\n\t\treturn;\n#endif\n\tif (function)\n\t\tflen = strlen(function);\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tif (sb)\n\t\tpr_err(\"(device %s): %s(): %pV\\n\",\n\t\t       sb->s_id, flen ? function : \"\", &vaf);\n\telse\n\t\tpr_err(\"%s(): %pV\\n\", flen ? function : \"\", &vaf);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unmap_mft_record",
          "args": [
            "ni"
          ],
          "line": 415
        },
        "resolved": true,
        "details": {
          "function_name": "unmap_mft_record",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/mft.c",
          "lines": "213-231",
          "snippet": "void unmap_mft_record(ntfs_inode *ni)\n{\n\tstruct page *page = ni->page;\n\n\tBUG_ON(!page);\n\n\tntfs_debug(\"Entering for mft_no 0x%lx.\", ni->mft_no);\n\n\tunmap_mft_record_page(ni);\n\tmutex_unlock(&ni->mrec_lock);\n\tatomic_dec(&ni->count);\n\t/*\n\t * If pure ntfs_inode, i.e. no vfs inode attached, we leave it to\n\t * ntfs_clear_extent_inode() in the extent inode case, and to the\n\t * caller in the non-extent, yet pure ntfs inode case, to do the actual\n\t * tear down of all structures and freeing of all allocated memory.\n\t */\n\treturn;\n}",
          "includes": [
            "#include \"ntfs.h\"",
            "#include \"mft.h\"",
            "#include \"malloc.h\"",
            "#include \"lcnalloc.h\"",
            "#include \"dir.h\"",
            "#include \"debug.h\"",
            "#include \"bitmap.h\"",
            "#include \"aops.h\"",
            "#include \"attrib.h\"",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ntfs.h\"\n#include \"mft.h\"\n#include \"malloc.h\"\n#include \"lcnalloc.h\"\n#include \"dir.h\"\n#include \"debug.h\"\n#include \"bitmap.h\"\n#include \"aops.h\"\n#include \"attrib.h\"\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n\nvoid unmap_mft_record(ntfs_inode *ni)\n{\n\tstruct page *page = ni->page;\n\n\tBUG_ON(!page);\n\n\tntfs_debug(\"Entering for mft_no 0x%lx.\", ni->mft_no);\n\n\tunmap_mft_record_page(ni);\n\tmutex_unlock(&ni->mrec_lock);\n\tatomic_dec(&ni->count);\n\t/*\n\t * If pure ntfs_inode, i.e. no vfs inode attached, we leave it to\n\t * ntfs_clear_extent_inode() in the extent inode case, and to the\n\t * caller in the non-extent, yet pure ntfs inode case, to do the actual\n\t * tear down of all structures and freeing of all allocated memory.\n\t */\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ntfs_attr_put_search_ctx",
          "args": [
            "ctx"
          ],
          "line": 414
        },
        "resolved": true,
        "details": {
          "function_name": "ntfs_attr_put_search_ctx",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/attrib.c",
          "lines": "1286-1292",
          "snippet": "void ntfs_attr_put_search_ctx(ntfs_attr_search_ctx *ctx)\n{\n\tif (ctx->base_ntfs_ino && ctx->ntfs_ino != ctx->base_ntfs_ino)\n\t\tunmap_extent_mft_record(ctx->ntfs_ino);\n\tkmem_cache_free(ntfs_attr_ctx_cache, ctx);\n\treturn;\n}",
          "includes": [
            "#include \"types.h\"",
            "#include \"ntfs.h\"",
            "#include \"mft.h\"",
            "#include \"malloc.h\"",
            "#include \"lcnalloc.h\"",
            "#include \"layout.h\"",
            "#include \"debug.h\"",
            "#include \"attrib.h\"",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include \"ntfs.h\"\n#include \"mft.h\"\n#include \"malloc.h\"\n#include \"lcnalloc.h\"\n#include \"layout.h\"\n#include \"debug.h\"\n#include \"attrib.h\"\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/buffer_head.h>\n\nvoid ntfs_attr_put_search_ctx(ntfs_attr_search_ctx *ctx)\n{\n\tif (ctx->base_ntfs_ino && ctx->ntfs_ino != ctx->base_ntfs_ino)\n\t\tunmap_extent_mft_record(ctx->ntfs_ino);\n\tkmem_cache_free(ntfs_attr_ctx_cache, ctx);\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ntfs_debug",
          "args": [
            "\"Done.\""
          ],
          "line": 410
        },
        "resolved": true,
        "details": {
          "function_name": "ntfs_debug_dump_runlist",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/debug.c",
          "lines": "134-171",
          "snippet": "void ntfs_debug_dump_runlist(const runlist_element *rl)\n{\n\tint i;\n\tconst char *lcn_str[5] = { \"LCN_HOLE         \", \"LCN_RL_NOT_MAPPED\",\n\t\t\t\t   \"LCN_ENOENT       \", \"LCN_unknown      \" };\n\n\tif (!debug_msgs)\n\t\treturn;\n\tpr_debug(\"Dumping runlist (values in hex):\\n\");\n\tif (!rl) {\n\t\tpr_debug(\"Run list not present.\\n\");\n\t\treturn;\n\t}\n\tpr_debug(\"VCN              LCN               Run length\\n\");\n\tfor (i = 0; ; i++) {\n\t\tLCN lcn = (rl + i)->lcn;\n\n\t\tif (lcn < (LCN)0) {\n\t\t\tint index = -lcn - 1;\n\n\t\t\tif (index > -LCN_ENOENT - 1)\n\t\t\t\tindex = 3;\n\t\t\tpr_debug(\"%-16Lx %s %-16Lx%s\\n\",\n\t\t\t\t\t(long long)(rl + i)->vcn, lcn_str[index],\n\t\t\t\t\t(long long)(rl + i)->length,\n\t\t\t\t\t(rl + i)->length ? \"\" :\n\t\t\t\t\t\t\" (runlist end)\");\n\t\t} else\n\t\t\tpr_debug(\"%-16Lx %-16Lx  %-16Lx%s\\n\",\n\t\t\t\t\t(long long)(rl + i)->vcn,\n\t\t\t\t\t(long long)(rl + i)->lcn,\n\t\t\t\t\t(long long)(rl + i)->length,\n\t\t\t\t\t(rl + i)->length ? \"\" :\n\t\t\t\t\t\t\" (runlist end)\");\n\t\tif (!(rl + i)->length)\n\t\t\tbreak;\n\t}\n}",
          "includes": [
            "#include \"debug.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"debug.h\"\n\nvoid ntfs_debug_dump_runlist(const runlist_element *rl)\n{\n\tint i;\n\tconst char *lcn_str[5] = { \"LCN_HOLE         \", \"LCN_RL_NOT_MAPPED\",\n\t\t\t\t   \"LCN_ENOENT       \", \"LCN_unknown      \" };\n\n\tif (!debug_msgs)\n\t\treturn;\n\tpr_debug(\"Dumping runlist (values in hex):\\n\");\n\tif (!rl) {\n\t\tpr_debug(\"Run list not present.\\n\");\n\t\treturn;\n\t}\n\tpr_debug(\"VCN              LCN               Run length\\n\");\n\tfor (i = 0; ; i++) {\n\t\tLCN lcn = (rl + i)->lcn;\n\n\t\tif (lcn < (LCN)0) {\n\t\t\tint index = -lcn - 1;\n\n\t\t\tif (index > -LCN_ENOENT - 1)\n\t\t\t\tindex = 3;\n\t\t\tpr_debug(\"%-16Lx %s %-16Lx%s\\n\",\n\t\t\t\t\t(long long)(rl + i)->vcn, lcn_str[index],\n\t\t\t\t\t(long long)(rl + i)->length,\n\t\t\t\t\t(rl + i)->length ? \"\" :\n\t\t\t\t\t\t\" (runlist end)\");\n\t\t} else\n\t\t\tpr_debug(\"%-16Lx %-16Lx  %-16Lx%s\\n\",\n\t\t\t\t\t(long long)(rl + i)->vcn,\n\t\t\t\t\t(long long)(rl + i)->lcn,\n\t\t\t\t\t(long long)(rl + i)->length,\n\t\t\t\t\t(rl + i)->length ? \"\" :\n\t\t\t\t\t\t\" (runlist end)\");\n\t\tif (!(rl + i)->length)\n\t\t\tbreak;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "mark_mft_record_dirty",
          "args": [
            "ctx->ntfs_ino"
          ],
          "line": 406
        },
        "resolved": true,
        "details": {
          "function_name": "__mark_mft_record_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/mft.c",
          "lines": "395-410",
          "snippet": "void __mark_mft_record_dirty(ntfs_inode *ni)\n{\n\tntfs_inode *base_ni;\n\n\tntfs_debug(\"Entering for inode 0x%lx.\", ni->mft_no);\n\tBUG_ON(NInoAttr(ni));\n\tmark_ntfs_record_dirty(ni->page, ni->page_ofs);\n\t/* Determine the base vfs inode and mark it dirty, too. */\n\tmutex_lock(&ni->extent_lock);\n\tif (likely(ni->nr_extents >= 0))\n\t\tbase_ni = ni;\n\telse\n\t\tbase_ni = ni->ext.base_ntfs_ino;\n\tmutex_unlock(&ni->extent_lock);\n\t__mark_inode_dirty(VFS_I(base_ni), I_DIRTY_SYNC | I_DIRTY_DATASYNC);\n}",
          "includes": [
            "#include \"ntfs.h\"",
            "#include \"mft.h\"",
            "#include \"malloc.h\"",
            "#include \"lcnalloc.h\"",
            "#include \"dir.h\"",
            "#include \"debug.h\"",
            "#include \"bitmap.h\"",
            "#include \"aops.h\"",
            "#include \"attrib.h\"",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ntfs.h\"\n#include \"mft.h\"\n#include \"malloc.h\"\n#include \"lcnalloc.h\"\n#include \"dir.h\"\n#include \"debug.h\"\n#include \"bitmap.h\"\n#include \"aops.h\"\n#include \"attrib.h\"\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n\nvoid __mark_mft_record_dirty(ntfs_inode *ni)\n{\n\tntfs_inode *base_ni;\n\n\tntfs_debug(\"Entering for inode 0x%lx.\", ni->mft_no);\n\tBUG_ON(NInoAttr(ni));\n\tmark_ntfs_record_dirty(ni->page, ni->page_ofs);\n\t/* Determine the base vfs inode and mark it dirty, too. */\n\tmutex_lock(&ni->extent_lock);\n\tif (likely(ni->nr_extents >= 0))\n\t\tbase_ni = ni;\n\telse\n\t\tbase_ni = ni->ext.base_ntfs_ino;\n\tmutex_unlock(&ni->extent_lock);\n\t__mark_inode_dirty(VFS_I(base_ni), I_DIRTY_SYNC | I_DIRTY_DATASYNC);\n}"
        }
      },
      {
        "call_info": {
          "callee": "flush_dcache_mft_record_page",
          "args": [
            "ctx->ntfs_ino"
          ],
          "line": 405
        },
        "resolved": true,
        "details": {
          "function_name": "flush_dcache_mft_record_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/mft.h",
          "lines": "55-58",
          "snippet": "static inline void flush_dcache_mft_record_page(ntfs_inode *ni)\n{\n\tflush_dcache_page(ni->page);\n}",
          "includes": [
            "#include \"inode.h\"",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"inode.h\"\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/fs.h>\n\nstatic inline void flush_dcache_mft_record_page(ntfs_inode *ni)\n{\n\tflush_dcache_page(ni->page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "le16_to_cpu",
          "args": [
            "ctx->attr->data.resident.value_offset"
          ],
          "line": 403
        },
        "resolved": true,
        "details": {
          "function_name": "sle16_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "48-51",
          "snippet": "static inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ntfs_attr_lookup",
          "args": [
            "AT_VOLUME_INFORMATION",
            "NULL",
            "0",
            "0",
            "0",
            "NULL",
            "0",
            "ctx"
          ],
          "line": 398
        },
        "resolved": true,
        "details": {
          "function_name": "ntfs_attr_lookup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/attrib.c",
          "lines": "1187-1207",
          "snippet": "int ntfs_attr_lookup(const ATTR_TYPE type, const ntfschar *name,\n\t\tconst u32 name_len, const IGNORE_CASE_BOOL ic,\n\t\tconst VCN lowest_vcn, const u8 *val, const u32 val_len,\n\t\tntfs_attr_search_ctx *ctx)\n{\n\tntfs_inode *base_ni;\n\n\tntfs_debug(\"Entering.\");\n\tBUG_ON(IS_ERR(ctx->mrec));\n\tif (ctx->base_ntfs_ino)\n\t\tbase_ni = ctx->base_ntfs_ino;\n\telse\n\t\tbase_ni = ctx->ntfs_ino;\n\t/* Sanity check, just for debugging really. */\n\tBUG_ON(!base_ni);\n\tif (!NInoAttrList(base_ni) || type == AT_ATTRIBUTE_LIST)\n\t\treturn ntfs_attr_find(type, name, name_len, ic, val, val_len,\n\t\t\t\tctx);\n\treturn ntfs_external_attr_find(type, name, name_len, ic, lowest_vcn,\n\t\t\tval, val_len, ctx);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include \"ntfs.h\"",
            "#include \"mft.h\"",
            "#include \"malloc.h\"",
            "#include \"lcnalloc.h\"",
            "#include \"layout.h\"",
            "#include \"debug.h\"",
            "#include \"attrib.h\"",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include \"ntfs.h\"\n#include \"mft.h\"\n#include \"malloc.h\"\n#include \"lcnalloc.h\"\n#include \"layout.h\"\n#include \"debug.h\"\n#include \"attrib.h\"\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/buffer_head.h>\n\nint ntfs_attr_lookup(const ATTR_TYPE type, const ntfschar *name,\n\t\tconst u32 name_len, const IGNORE_CASE_BOOL ic,\n\t\tconst VCN lowest_vcn, const u8 *val, const u32 val_len,\n\t\tntfs_attr_search_ctx *ctx)\n{\n\tntfs_inode *base_ni;\n\n\tntfs_debug(\"Entering.\");\n\tBUG_ON(IS_ERR(ctx->mrec));\n\tif (ctx->base_ntfs_ino)\n\t\tbase_ni = ctx->base_ntfs_ino;\n\telse\n\t\tbase_ni = ctx->ntfs_ino;\n\t/* Sanity check, just for debugging really. */\n\tBUG_ON(!base_ni);\n\tif (!NInoAttrList(base_ni) || type == AT_ATTRIBUTE_LIST)\n\t\treturn ntfs_attr_find(type, name, name_len, ic, val, val_len,\n\t\t\t\tctx);\n\treturn ntfs_external_attr_find(type, name, name_len, ic, lowest_vcn,\n\t\t\tval, val_len, ctx);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ntfs_attr_get_search_ctx",
          "args": [
            "ni",
            "m"
          ],
          "line": 393
        },
        "resolved": true,
        "details": {
          "function_name": "ntfs_attr_get_search_ctx",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/attrib.c",
          "lines": "1269-1277",
          "snippet": "ntfs_attr_search_ctx *ntfs_attr_get_search_ctx(ntfs_inode *ni, MFT_RECORD *mrec)\n{\n\tntfs_attr_search_ctx *ctx;\n\n\tctx = kmem_cache_alloc(ntfs_attr_ctx_cache, GFP_NOFS);\n\tif (ctx)\n\t\tntfs_attr_init_search_ctx(ctx, ni, mrec);\n\treturn ctx;\n}",
          "includes": [
            "#include \"types.h\"",
            "#include \"ntfs.h\"",
            "#include \"mft.h\"",
            "#include \"malloc.h\"",
            "#include \"lcnalloc.h\"",
            "#include \"layout.h\"",
            "#include \"debug.h\"",
            "#include \"attrib.h\"",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include \"ntfs.h\"\n#include \"mft.h\"\n#include \"malloc.h\"\n#include \"lcnalloc.h\"\n#include \"layout.h\"\n#include \"debug.h\"\n#include \"attrib.h\"\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/buffer_head.h>\n\nntfs_attr_search_ctx *ntfs_attr_get_search_ctx(ntfs_inode *ni, MFT_RECORD *mrec)\n{\n\tntfs_attr_search_ctx *ctx;\n\n\tctx = kmem_cache_alloc(ntfs_attr_ctx_cache, GFP_NOFS);\n\tif (ctx)\n\t\tntfs_attr_init_search_ctx(ctx, ni, mrec);\n\treturn ctx;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "m"
          ],
          "line": 390
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "m"
          ],
          "line": 389
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!ni"
          ],
          "line": 387
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_debug",
          "args": [
            "\"Entering, old flags = 0x%x, new flags = 0x%x.\"",
            "le16_to_cpu(vol->vol_flags)",
            "le16_to_cpu(flags)"
          ],
          "line": 383
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NTFS_I",
          "args": [
            "vol->vol_ino"
          ],
          "line": 377
        },
        "resolved": true,
        "details": {
          "function_name": "NTFS_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/inode.h",
          "lines": "240-243",
          "snippet": "static inline ntfs_inode *NTFS_I(struct inode *inode)\n{\n\treturn (ntfs_inode *)list_entry(inode, big_ntfs_inode, vfs_inode);\n}",
          "includes": [
            "#include \"debug.h\"",
            "#include \"runlist.h\"",
            "#include \"types.h\"",
            "#include \"volume.h\"",
            "#include \"layout.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/mutex.h>",
            "#include <linux/mm.h>",
            "#include <linux/list.h>",
            "#include <linux/fs.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"debug.h\"\n#include \"runlist.h\"\n#include \"types.h\"\n#include \"volume.h\"\n#include \"layout.h\"\n#include <linux/seq_file.h>\n#include <linux/mutex.h>\n#include <linux/mm.h>\n#include <linux/list.h>\n#include <linux/fs.h>\n#include <linux/atomic.h>\n\nstatic inline ntfs_inode *NTFS_I(struct inode *inode)\n{\n\treturn (ntfs_inode *)list_entry(inode, big_ntfs_inode, vfs_inode);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ntfs.h\"\n#include \"malloc.h\"\n#include \"layout.h\"\n#include \"aops.h\"\n#include \"inode.h\"\n#include \"index.h\"\n#include \"debug.h\"\n#include \"dir.h\"\n#include \"usnjrnl.h\"\n#include \"quota.h\"\n#include \"logfile.h\"\n#include \"sysctl.h\"\n#include <linux/bitmap.h>\n#include <linux/moduleparam.h>\n#include <linux/vfs.h>\n#include <linux/buffer_head.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\t/* For bdev_logical_block_size(). */\n#include <linux/spinlock.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/stddef.h>\n\nstatic int ntfs_write_volume_flags(ntfs_volume *vol, const VOLUME_FLAGS flags)\n{\n\tntfs_inode *ni = NTFS_I(vol->vol_ino);\n\tMFT_RECORD *m;\n\tVOLUME_INFORMATION *vi;\n\tntfs_attr_search_ctx *ctx;\n\tint err;\n\n\tntfs_debug(\"Entering, old flags = 0x%x, new flags = 0x%x.\",\n\t\t\tle16_to_cpu(vol->vol_flags), le16_to_cpu(flags));\n\tif (vol->vol_flags == flags)\n\t\tgoto done;\n\tBUG_ON(!ni);\n\tm = map_mft_record(ni);\n\tif (IS_ERR(m)) {\n\t\terr = PTR_ERR(m);\n\t\tgoto err_out;\n\t}\n\tctx = ntfs_attr_get_search_ctx(ni, m);\n\tif (!ctx) {\n\t\terr = -ENOMEM;\n\t\tgoto put_unm_err_out;\n\t}\n\terr = ntfs_attr_lookup(AT_VOLUME_INFORMATION, NULL, 0, 0, 0, NULL, 0,\n\t\t\tctx);\n\tif (err)\n\t\tgoto put_unm_err_out;\n\tvi = (VOLUME_INFORMATION*)((u8*)ctx->attr +\n\t\t\tle16_to_cpu(ctx->attr->data.resident.value_offset));\n\tvol->vol_flags = vi->flags = flags;\n\tflush_dcache_mft_record_page(ctx->ntfs_ino);\n\tmark_mft_record_dirty(ctx->ntfs_ino);\n\tntfs_attr_put_search_ctx(ctx);\n\tunmap_mft_record(ni);\ndone:\n\tntfs_debug(\"Done.\");\n\treturn 0;\nput_unm_err_out:\n\tif (ctx)\n\t\tntfs_attr_put_search_ctx(ctx);\n\tunmap_mft_record(ni);\nerr_out:\n\tntfs_error(vol->sb, \"Failed with error code %i.\", -err);\n\treturn err;\n}"
  },
  {
    "function_name": "parse_options",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/super.c",
    "lines": "101-356",
    "snippet": "static bool parse_options(ntfs_volume *vol, char *opt)\n{\n\tchar *p, *v, *ov;\n\tstatic char *utf8 = \"utf8\";\n\tint errors = 0, sloppy = 0;\n\tkuid_t uid = INVALID_UID;\n\tkgid_t gid = INVALID_GID;\n\tumode_t fmask = (umode_t)-1, dmask = (umode_t)-1;\n\tint mft_zone_multiplier = -1, on_errors = -1;\n\tint show_sys_files = -1, case_sensitive = -1, disable_sparse = -1;\n\tstruct nls_table *nls_map = NULL, *old_nls;\n\n\t/* I am lazy... (-8 */\n#define NTFS_GETOPT_WITH_DEFAULT(option, variable, default_value)\t\\\n\tif (!strcmp(p, option)) {\t\t\t\t\t\\\n\t\tif (!v || !*v)\t\t\t\t\t\t\\\n\t\t\tvariable = default_value;\t\t\t\\\n\t\telse {\t\t\t\t\t\t\t\\\n\t\t\tvariable = simple_strtoul(ov = v, &v, 0);\t\\\n\t\t\tif (*v)\t\t\t\t\t\t\\\n\t\t\t\tgoto needs_val;\t\t\t\t\\\n\t\t}\t\t\t\t\t\t\t\\\n\t}\n#define NTFS_GETOPT(option, variable)\t\t\t\t\t\\\n\tif (!strcmp(p, option)) {\t\t\t\t\t\\\n\t\tif (!v || !*v)\t\t\t\t\t\t\\\n\t\t\tgoto needs_arg;\t\t\t\t\t\\\n\t\tvariable = simple_strtoul(ov = v, &v, 0);\t\t\\\n\t\tif (*v)\t\t\t\t\t\t\t\\\n\t\t\tgoto needs_val;\t\t\t\t\t\\\n\t}\n#define NTFS_GETOPT_UID(option, variable)\t\t\t\t\\\n\tif (!strcmp(p, option)) {\t\t\t\t\t\\\n\t\tuid_t uid_value;\t\t\t\t\t\\\n\t\tif (!v || !*v)\t\t\t\t\t\t\\\n\t\t\tgoto needs_arg;\t\t\t\t\t\\\n\t\tuid_value = simple_strtoul(ov = v, &v, 0);\t\t\\\n\t\tif (*v)\t\t\t\t\t\t\t\\\n\t\t\tgoto needs_val;\t\t\t\t\t\\\n\t\tvariable = make_kuid(current_user_ns(), uid_value);\t\\\n\t\tif (!uid_valid(variable))\t\t\t\t\\\n\t\t\tgoto needs_val;\t\t\t\t\t\\\n\t}\n#define NTFS_GETOPT_GID(option, variable)\t\t\t\t\\\n\tif (!strcmp(p, option)) {\t\t\t\t\t\\\n\t\tgid_t gid_value;\t\t\t\t\t\\\n\t\tif (!v || !*v)\t\t\t\t\t\t\\\n\t\t\tgoto needs_arg;\t\t\t\t\t\\\n\t\tgid_value = simple_strtoul(ov = v, &v, 0);\t\t\\\n\t\tif (*v)\t\t\t\t\t\t\t\\\n\t\t\tgoto needs_val;\t\t\t\t\t\\\n\t\tvariable = make_kgid(current_user_ns(), gid_value);\t\\\n\t\tif (!gid_valid(variable))\t\t\t\t\\\n\t\t\tgoto needs_val;\t\t\t\t\t\\\n\t}\n#define NTFS_GETOPT_OCTAL(option, variable)\t\t\t\t\\\n\tif (!strcmp(p, option)) {\t\t\t\t\t\\\n\t\tif (!v || !*v)\t\t\t\t\t\t\\\n\t\t\tgoto needs_arg;\t\t\t\t\t\\\n\t\tvariable = simple_strtoul(ov = v, &v, 8);\t\t\\\n\t\tif (*v)\t\t\t\t\t\t\t\\\n\t\t\tgoto needs_val;\t\t\t\t\t\\\n\t}\n#define NTFS_GETOPT_BOOL(option, variable)\t\t\t\t\\\n\tif (!strcmp(p, option)) {\t\t\t\t\t\\\n\t\tbool val;\t\t\t\t\t\t\\\n\t\tif (!simple_getbool(v, &val))\t\t\t\t\\\n\t\t\tgoto needs_bool;\t\t\t\t\\\n\t\tvariable = val;\t\t\t\t\t\t\\\n\t}\n#define NTFS_GETOPT_OPTIONS_ARRAY(option, variable, opt_array)\t\t\\\n\tif (!strcmp(p, option)) {\t\t\t\t\t\\\n\t\tint _i;\t\t\t\t\t\t\t\\\n\t\tif (!v || !*v)\t\t\t\t\t\t\\\n\t\t\tgoto needs_arg;\t\t\t\t\t\\\n\t\tov = v;\t\t\t\t\t\t\t\\\n\t\tif (variable == -1)\t\t\t\t\t\\\n\t\t\tvariable = 0;\t\t\t\t\t\\\n\t\tfor (_i = 0; opt_array[_i].str && *opt_array[_i].str; _i++) \\\n\t\t\tif (!strcmp(opt_array[_i].str, v)) {\t\t\\\n\t\t\t\tvariable |= opt_array[_i].val;\t\t\\\n\t\t\t\tbreak;\t\t\t\t\t\\\n\t\t\t}\t\t\t\t\t\t\\\n\t\tif (!opt_array[_i].str || !*opt_array[_i].str)\t\t\\\n\t\t\tgoto needs_val;\t\t\t\t\t\\\n\t}\n\tif (!opt || !*opt)\n\t\tgoto no_mount_options;\n\tntfs_debug(\"Entering with mount options string: %s\", opt);\n\twhile ((p = strsep(&opt, \",\"))) {\n\t\tif ((v = strchr(p, '=')))\n\t\t\t*v++ = 0;\n\t\tNTFS_GETOPT_UID(\"uid\", uid)\n\t\telse NTFS_GETOPT_GID(\"gid\", gid)\n\t\telse NTFS_GETOPT_OCTAL(\"umask\", fmask = dmask)\n\t\telse NTFS_GETOPT_OCTAL(\"fmask\", fmask)\n\t\telse NTFS_GETOPT_OCTAL(\"dmask\", dmask)\n\t\telse NTFS_GETOPT(\"mft_zone_multiplier\", mft_zone_multiplier)\n\t\telse NTFS_GETOPT_WITH_DEFAULT(\"sloppy\", sloppy, true)\n\t\telse NTFS_GETOPT_BOOL(\"show_sys_files\", show_sys_files)\n\t\telse NTFS_GETOPT_BOOL(\"case_sensitive\", case_sensitive)\n\t\telse NTFS_GETOPT_BOOL(\"disable_sparse\", disable_sparse)\n\t\telse NTFS_GETOPT_OPTIONS_ARRAY(\"errors\", on_errors,\n\t\t\t\ton_errors_arr)\n\t\telse if (!strcmp(p, \"posix\") || !strcmp(p, \"show_inodes\"))\n\t\t\tntfs_warning(vol->sb, \"Ignoring obsolete option %s.\",\n\t\t\t\t\tp);\n\t\telse if (!strcmp(p, \"nls\") || !strcmp(p, \"iocharset\")) {\n\t\t\tif (!strcmp(p, \"iocharset\"))\n\t\t\t\tntfs_warning(vol->sb, \"Option iocharset is \"\n\t\t\t\t\t\t\"deprecated. Please use \"\n\t\t\t\t\t\t\"option nls=<charsetname> in \"\n\t\t\t\t\t\t\"the future.\");\n\t\t\tif (!v || !*v)\n\t\t\t\tgoto needs_arg;\nuse_utf8:\n\t\t\told_nls = nls_map;\n\t\t\tnls_map = load_nls(v);\n\t\t\tif (!nls_map) {\n\t\t\t\tif (!old_nls) {\n\t\t\t\t\tntfs_error(vol->sb, \"NLS character set \"\n\t\t\t\t\t\t\t\"%s not found.\", v);\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\tntfs_error(vol->sb, \"NLS character set %s not \"\n\t\t\t\t\t\t\"found. Using previous one %s.\",\n\t\t\t\t\t\tv, old_nls->charset);\n\t\t\t\tnls_map = old_nls;\n\t\t\t} else /* nls_map */ {\n\t\t\t\tunload_nls(old_nls);\n\t\t\t}\n\t\t} else if (!strcmp(p, \"utf8\")) {\n\t\t\tbool val = false;\n\t\t\tntfs_warning(vol->sb, \"Option utf8 is no longer \"\n\t\t\t\t   \"supported, using option nls=utf8. Please \"\n\t\t\t\t   \"use option nls=utf8 in the future and \"\n\t\t\t\t   \"make sure utf8 is compiled either as a \"\n\t\t\t\t   \"module or into the kernel.\");\n\t\t\tif (!v || !*v)\n\t\t\t\tval = true;\n\t\t\telse if (!simple_getbool(v, &val))\n\t\t\t\tgoto needs_bool;\n\t\t\tif (val) {\n\t\t\t\tv = utf8;\n\t\t\t\tgoto use_utf8;\n\t\t\t}\n\t\t} else {\n\t\t\tntfs_error(vol->sb, \"Unrecognized mount option %s.\", p);\n\t\t\tif (errors < INT_MAX)\n\t\t\t\terrors++;\n\t\t}\n#undef NTFS_GETOPT_OPTIONS_ARRAY\n#undef NTFS_GETOPT_BOOL\n#undef NTFS_GETOPT\n#undef NTFS_GETOPT_WITH_DEFAULT\n\t}\nno_mount_options:\n\tif (errors && !sloppy)\n\t\treturn false;\n\tif (sloppy)\n\t\tntfs_warning(vol->sb, \"Sloppy option given. Ignoring \"\n\t\t\t\t\"unrecognized mount option(s) and continuing.\");\n\t/* Keep this first! */\n\tif (on_errors != -1) {\n\t\tif (!on_errors) {\n\t\t\tntfs_error(vol->sb, \"Invalid errors option argument \"\n\t\t\t\t\t\"or bug in options parser.\");\n\t\t\treturn false;\n\t\t}\n\t}\n\tif (nls_map) {\n\t\tif (vol->nls_map && vol->nls_map != nls_map) {\n\t\t\tntfs_error(vol->sb, \"Cannot change NLS character set \"\n\t\t\t\t\t\"on remount.\");\n\t\t\treturn false;\n\t\t} /* else (!vol->nls_map) */\n\t\tntfs_debug(\"Using NLS character set %s.\", nls_map->charset);\n\t\tvol->nls_map = nls_map;\n\t} else /* (!nls_map) */ {\n\t\tif (!vol->nls_map) {\n\t\t\tvol->nls_map = load_nls_default();\n\t\t\tif (!vol->nls_map) {\n\t\t\t\tntfs_error(vol->sb, \"Failed to load default \"\n\t\t\t\t\t\t\"NLS character set.\");\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tntfs_debug(\"Using default NLS character set (%s).\",\n\t\t\t\t\tvol->nls_map->charset);\n\t\t}\n\t}\n\tif (mft_zone_multiplier != -1) {\n\t\tif (vol->mft_zone_multiplier && vol->mft_zone_multiplier !=\n\t\t\t\tmft_zone_multiplier) {\n\t\t\tntfs_error(vol->sb, \"Cannot change mft_zone_multiplier \"\n\t\t\t\t\t\"on remount.\");\n\t\t\treturn false;\n\t\t}\n\t\tif (mft_zone_multiplier < 1 || mft_zone_multiplier > 4) {\n\t\t\tntfs_error(vol->sb, \"Invalid mft_zone_multiplier. \"\n\t\t\t\t\t\"Using default value, i.e. 1.\");\n\t\t\tmft_zone_multiplier = 1;\n\t\t}\n\t\tvol->mft_zone_multiplier = mft_zone_multiplier;\n\t}\n\tif (!vol->mft_zone_multiplier)\n\t\tvol->mft_zone_multiplier = 1;\n\tif (on_errors != -1)\n\t\tvol->on_errors = on_errors;\n\tif (!vol->on_errors || vol->on_errors == ON_ERRORS_RECOVER)\n\t\tvol->on_errors |= ON_ERRORS_CONTINUE;\n\tif (uid_valid(uid))\n\t\tvol->uid = uid;\n\tif (gid_valid(gid))\n\t\tvol->gid = gid;\n\tif (fmask != (umode_t)-1)\n\t\tvol->fmask = fmask;\n\tif (dmask != (umode_t)-1)\n\t\tvol->dmask = dmask;\n\tif (show_sys_files != -1) {\n\t\tif (show_sys_files)\n\t\t\tNVolSetShowSystemFiles(vol);\n\t\telse\n\t\t\tNVolClearShowSystemFiles(vol);\n\t}\n\tif (case_sensitive != -1) {\n\t\tif (case_sensitive)\n\t\t\tNVolSetCaseSensitive(vol);\n\t\telse\n\t\t\tNVolClearCaseSensitive(vol);\n\t}\n\tif (disable_sparse != -1) {\n\t\tif (disable_sparse)\n\t\t\tNVolClearSparseEnabled(vol);\n\t\telse {\n\t\t\tif (!NVolSparseEnabled(vol) &&\n\t\t\t\t\tvol->major_ver && vol->major_ver < 3)\n\t\t\t\tntfs_warning(vol->sb, \"Not enabling sparse \"\n\t\t\t\t\t\t\"support due to NTFS volume \"\n\t\t\t\t\t\t\"version %i.%i (need at least \"\n\t\t\t\t\t\t\"version 3.0).\", vol->major_ver,\n\t\t\t\t\t\tvol->minor_ver);\n\t\t\telse\n\t\t\t\tNVolSetSparseEnabled(vol);\n\t\t}\n\t}\n\treturn true;\nneeds_arg:\n\tntfs_error(vol->sb, \"The %s option requires an argument.\", p);\n\treturn false;\nneeds_bool:\n\tntfs_error(vol->sb, \"The %s option requires a boolean argument.\", p);\n\treturn false;\nneeds_val:\n\tntfs_error(vol->sb, \"Invalid %s option argument: %s\", p, ov);\n\treturn false;\n}",
    "includes": [
      "#include \"ntfs.h\"",
      "#include \"malloc.h\"",
      "#include \"layout.h\"",
      "#include \"aops.h\"",
      "#include \"inode.h\"",
      "#include \"index.h\"",
      "#include \"debug.h\"",
      "#include \"dir.h\"",
      "#include \"usnjrnl.h\"",
      "#include \"quota.h\"",
      "#include \"logfile.h\"",
      "#include \"sysctl.h\"",
      "#include <linux/bitmap.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/vfs.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/blkdev.h>\t/* For bdev_logical_block_size(). */",
      "#include <linux/spinlock.h>",
      "#include <linux/string.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/stddef.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "const option_t on_errors_arr[] = {\n\t{ ON_ERRORS_PANIC,\t\"panic\" },\n\t{ ON_ERRORS_REMOUNT_RO,\t\"remount-ro\", },\n\t{ ON_ERRORS_CONTINUE,\t\"continue\", },\n\t{ ON_ERRORS_RECOVER,\t\"recover\" },\n\t{ 0,\t\t\tNULL }\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ntfs_error",
          "args": [
            "vol->sb",
            "\"Invalid %s option argument: %s\"",
            "p",
            "ov"
          ],
          "line": 354
        },
        "resolved": true,
        "details": {
          "function_name": "__ntfs_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/debug.c",
          "lines": "86-108",
          "snippet": "void __ntfs_error(const char *function, const struct super_block *sb,\n\t\tconst char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\tint flen = 0;\n\n#ifndef DEBUG\n\tif (!printk_ratelimit())\n\t\treturn;\n#endif\n\tif (function)\n\t\tflen = strlen(function);\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tif (sb)\n\t\tpr_err(\"(device %s): %s(): %pV\\n\",\n\t\t       sb->s_id, flen ? function : \"\", &vaf);\n\telse\n\t\tpr_err(\"%s(): %pV\\n\", flen ? function : \"\", &vaf);\n\tva_end(args);\n}",
          "includes": [
            "#include \"debug.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"debug.h\"\n\nvoid __ntfs_error(const char *function, const struct super_block *sb,\n\t\tconst char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\tint flen = 0;\n\n#ifndef DEBUG\n\tif (!printk_ratelimit())\n\t\treturn;\n#endif\n\tif (function)\n\t\tflen = strlen(function);\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tif (sb)\n\t\tpr_err(\"(device %s): %s(): %pV\\n\",\n\t\t       sb->s_id, flen ? function : \"\", &vaf);\n\telse\n\t\tpr_err(\"%s(): %pV\\n\", flen ? function : \"\", &vaf);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "NVolSetSparseEnabled",
          "args": [
            "vol"
          ],
          "line": 343
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_warning",
          "args": [
            "vol->sb",
            "\"Not enabling sparse \"\n\t\t\t\t\t\t\"support due to NTFS volume \"\n\t\t\t\t\t\t\"version %i.%i (need at least \"\n\t\t\t\t\t\t\"version 3.0).\"",
            "vol->major_ver",
            "vol->minor_ver"
          ],
          "line": 337
        },
        "resolved": true,
        "details": {
          "function_name": "__ntfs_warning",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/debug.c",
          "lines": "43-65",
          "snippet": "void __ntfs_warning(const char *function, const struct super_block *sb,\n\t\tconst char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\tint flen = 0;\n\n#ifndef DEBUG\n\tif (!printk_ratelimit())\n\t\treturn;\n#endif\n\tif (function)\n\t\tflen = strlen(function);\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tif (sb)\n\t\tpr_warn(\"(device %s): %s(): %pV\\n\",\n\t\t\tsb->s_id, flen ? function : \"\", &vaf);\n\telse\n\t\tpr_warn(\"%s(): %pV\\n\", flen ? function : \"\", &vaf);\n\tva_end(args);\n}",
          "includes": [
            "#include \"debug.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"debug.h\"\n\nvoid __ntfs_warning(const char *function, const struct super_block *sb,\n\t\tconst char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\tint flen = 0;\n\n#ifndef DEBUG\n\tif (!printk_ratelimit())\n\t\treturn;\n#endif\n\tif (function)\n\t\tflen = strlen(function);\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tif (sb)\n\t\tpr_warn(\"(device %s): %s(): %pV\\n\",\n\t\t\tsb->s_id, flen ? function : \"\", &vaf);\n\telse\n\t\tpr_warn(\"%s(): %pV\\n\", flen ? function : \"\", &vaf);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "NVolSparseEnabled",
          "args": [
            "vol"
          ],
          "line": 335
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NVolClearSparseEnabled",
          "args": [
            "vol"
          ],
          "line": 333
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NVolClearCaseSensitive",
          "args": [
            "vol"
          ],
          "line": 329
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NVolSetCaseSensitive",
          "args": [
            "vol"
          ],
          "line": 327
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NVolClearShowSystemFiles",
          "args": [
            "vol"
          ],
          "line": 323
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NVolSetShowSystemFiles",
          "args": [
            "vol"
          ],
          "line": 321
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gid_valid",
          "args": [
            "gid"
          ],
          "line": 313
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "uid_valid",
          "args": [
            "uid"
          ],
          "line": 311
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_uuid_valid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/sys.c",
          "lines": "73-82",
          "snippet": "static int gfs2_uuid_valid(const u8 *uuid)\n{\n\tint i;\n\n\tfor (i = 0; i < 16; i++) {\n\t\tif (uuid[i])\n\t\t\treturn 1;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"recovery.h\"",
            "#include \"glops.h\"",
            "#include \"util.h\"",
            "#include \"quota.h\"",
            "#include \"glock.h\"",
            "#include \"super.h\"",
            "#include \"sys.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/genhd.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/kobject.h>",
            "#include <linux/module.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"recovery.h\"\n#include \"glops.h\"\n#include \"util.h\"\n#include \"quota.h\"\n#include \"glock.h\"\n#include \"super.h\"\n#include \"sys.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/genhd.h>\n#include <linux/gfs2_ondisk.h>\n#include <asm/uaccess.h>\n#include <linux/kobject.h>\n#include <linux/module.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/sched.h>\n\nstatic int gfs2_uuid_valid(const u8 *uuid)\n{\n\tint i;\n\n\tfor (i = 0; i < 16; i++) {\n\t\tif (uuid[i])\n\t\t\treturn 1;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ntfs_error",
          "args": [
            "vol->sb",
            "\"Invalid mft_zone_multiplier. \"\n\t\t\t\t\t\"Using default value, i.e. 1.\""
          ],
          "line": 299
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_error",
          "args": [
            "vol->sb",
            "\"Cannot change mft_zone_multiplier \"\n\t\t\t\t\t\"on remount.\""
          ],
          "line": 294
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_debug",
          "args": [
            "\"Using default NLS character set (%s).\"",
            "vol->nls_map->charset"
          ],
          "line": 287
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_error",
          "args": [
            "vol->sb",
            "\"Failed to load default \"\n\t\t\t\t\t\t\"NLS character set.\""
          ],
          "line": 283
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "load_nls_default",
          "args": [],
          "line": 281
        },
        "resolved": true,
        "details": {
          "function_name": "load_nls_default",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nls/nls_base.c",
          "lines": "532-541",
          "snippet": "struct nls_table *load_nls_default(void)\n{\n\tstruct nls_table *default_nls;\n\t\n\tdefault_nls = load_nls(CONFIG_NLS_DEFAULT);\n\tif (default_nls != NULL)\n\t\treturn default_nls;\n\telse\n\t\treturn &default_table;\n}",
          "includes": [
            "#include <asm/byteorder.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/kmod.h>",
            "#include <linux/errno.h>",
            "#include <linux/kernel.h>",
            "#include <linux/nls.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct nls_table default_table;",
            "static struct nls_table default_table = {\n\t.charset\t= \"default\",\n\t.uni2char\t= uni2char,\n\t.char2uni\t= char2uni,\n\t.charset2lower\t= charset2lower,\n\t.charset2upper\t= charset2upper,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/byteorder.h>\n#include <linux/spinlock.h>\n#include <linux/kmod.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include <linux/nls.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nstatic struct nls_table default_table;\nstatic struct nls_table default_table = {\n\t.charset\t= \"default\",\n\t.uni2char\t= uni2char,\n\t.char2uni\t= char2uni,\n\t.charset2lower\t= charset2lower,\n\t.charset2upper\t= charset2upper,\n};\n\nstruct nls_table *load_nls_default(void)\n{\n\tstruct nls_table *default_nls;\n\t\n\tdefault_nls = load_nls(CONFIG_NLS_DEFAULT);\n\tif (default_nls != NULL)\n\t\treturn default_nls;\n\telse\n\t\treturn &default_table;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ntfs_debug",
          "args": [
            "\"Using NLS character set %s.\"",
            "nls_map->charset"
          ],
          "line": 277
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_error",
          "args": [
            "vol->sb",
            "\"Cannot change NLS character set \"\n\t\t\t\t\t\"on remount.\""
          ],
          "line": 273
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_error",
          "args": [
            "vol->sb",
            "\"Invalid errors option argument \"\n\t\t\t\t\t\"or bug in options parser.\""
          ],
          "line": 266
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_warning",
          "args": [
            "vol->sb",
            "\"Sloppy option given. Ignoring \"\n\t\t\t\t\"unrecognized mount option(s) and continuing.\""
          ],
          "line": 261
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "simple_getbool",
          "args": [
            "v",
            "&val"
          ],
          "line": 241
        },
        "resolved": true,
        "details": {
          "function_name": "simple_getbool",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/super.c",
          "lines": "79-92",
          "snippet": "static int simple_getbool(char *s, bool *setval)\n{\n\tif (s) {\n\t\tif (!strcmp(s, \"1\") || !strcmp(s, \"yes\") || !strcmp(s, \"true\"))\n\t\t\t*setval = true;\n\t\telse if (!strcmp(s, \"0\") || !strcmp(s, \"no\") ||\n\t\t\t\t\t\t\t!strcmp(s, \"false\"))\n\t\t\t*setval = false;\n\t\telse\n\t\t\treturn 0;\n\t} else\n\t\t*setval = true;\n\treturn 1;\n}",
          "includes": [
            "#include \"ntfs.h\"",
            "#include \"malloc.h\"",
            "#include \"layout.h\"",
            "#include \"aops.h\"",
            "#include \"inode.h\"",
            "#include \"index.h\"",
            "#include \"debug.h\"",
            "#include \"dir.h\"",
            "#include \"usnjrnl.h\"",
            "#include \"quota.h\"",
            "#include \"logfile.h\"",
            "#include \"sysctl.h\"",
            "#include <linux/bitmap.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/vfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>\t/* For bdev_logical_block_size(). */",
            "#include <linux/spinlock.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ntfs.h\"\n#include \"malloc.h\"\n#include \"layout.h\"\n#include \"aops.h\"\n#include \"inode.h\"\n#include \"index.h\"\n#include \"debug.h\"\n#include \"dir.h\"\n#include \"usnjrnl.h\"\n#include \"quota.h\"\n#include \"logfile.h\"\n#include \"sysctl.h\"\n#include <linux/bitmap.h>\n#include <linux/moduleparam.h>\n#include <linux/vfs.h>\n#include <linux/buffer_head.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\t/* For bdev_logical_block_size(). */\n#include <linux/spinlock.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/stddef.h>\n\nstatic int simple_getbool(char *s, bool *setval)\n{\n\tif (s) {\n\t\tif (!strcmp(s, \"1\") || !strcmp(s, \"yes\") || !strcmp(s, \"true\"))\n\t\t\t*setval = true;\n\t\telse if (!strcmp(s, \"0\") || !strcmp(s, \"no\") ||\n\t\t\t\t\t\t\t!strcmp(s, \"false\"))\n\t\t\t*setval = false;\n\t\telse\n\t\t\treturn 0;\n\t} else\n\t\t*setval = true;\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ntfs_warning",
          "args": [
            "vol->sb",
            "\"Option utf8 is no longer \"\n\t\t\t\t   \"supported, using option nls=utf8. Please \"\n\t\t\t\t   \"use option nls=utf8 in the future and \"\n\t\t\t\t   \"make sure utf8 is compiled either as a \"\n\t\t\t\t   \"module or into the kernel.\""
          ],
          "line": 234
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "p",
            "\"utf8\""
          ],
          "line": 232
        },
        "resolved": true,
        "details": {
          "function_name": "strcmp_null",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/super.c",
          "lines": "292-301",
          "snippet": "static int strcmp_null(const char *s1, const char *s2)\n{\n\tif (!s1 && !s2)\n\t\treturn 0;\n\tif (s1 && !s2)\n\t\treturn -1;\n\tif (!s1 && s2)\n\t\treturn 1;\n\treturn strcmp(s1, s2);\n}",
          "includes": [
            "#include <linux/ceph/debugfs.h>",
            "#include <linux/ceph/auth.h>",
            "#include <linux/ceph/mon_client.h>",
            "#include <linux/ceph/decode.h>",
            "#include <linux/ceph/ceph_features.h>",
            "#include \"cache.h\"",
            "#include \"mds_client.h\"",
            "#include \"super.h\"",
            "#include <linux/string.h>",
            "#include <linux/statfs.h>",
            "#include <linux/slab.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/sched.h>",
            "#include <linux/parser.h>",
            "#include <linux/mount.h>",
            "#include <linux/module.h>",
            "#include <linux/in6.h>",
            "#include <linux/inet.h>",
            "#include <linux/fs.h>",
            "#include <linux/ctype.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ceph/debugfs.h>\n#include <linux/ceph/auth.h>\n#include <linux/ceph/mon_client.h>\n#include <linux/ceph/decode.h>\n#include <linux/ceph/ceph_features.h>\n#include \"cache.h\"\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/string.h>\n#include <linux/statfs.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/sched.h>\n#include <linux/parser.h>\n#include <linux/mount.h>\n#include <linux/module.h>\n#include <linux/in6.h>\n#include <linux/inet.h>\n#include <linux/fs.h>\n#include <linux/ctype.h>\n#include <linux/backing-dev.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic int strcmp_null(const char *s1, const char *s2)\n{\n\tif (!s1 && !s2)\n\t\treturn 0;\n\tif (s1 && !s2)\n\t\treturn -1;\n\tif (!s1 && s2)\n\t\treturn 1;\n\treturn strcmp(s1, s2);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unload_nls",
          "args": [
            "old_nls"
          ],
          "line": 230
        },
        "resolved": true,
        "details": {
          "function_name": "unload_nls",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nls/nls_base.c",
          "lines": "296-300",
          "snippet": "void unload_nls(struct nls_table *nls)\n{\n\tif (nls)\n\t\tmodule_put(nls->owner);\n}",
          "includes": [
            "#include <asm/byteorder.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/kmod.h>",
            "#include <linux/errno.h>",
            "#include <linux/kernel.h>",
            "#include <linux/nls.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/byteorder.h>\n#include <linux/spinlock.h>\n#include <linux/kmod.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include <linux/nls.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nvoid unload_nls(struct nls_table *nls)\n{\n\tif (nls)\n\t\tmodule_put(nls->owner);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ntfs_warning",
          "args": [
            "vol->sb",
            "\"Option iocharset is \"\n\t\t\t\t\t\t\"deprecated. Please use \"\n\t\t\t\t\t\t\"option nls=<charsetname> in \"\n\t\t\t\t\t\t\"the future.\""
          ],
          "line": 210
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NTFS_GETOPT_OPTIONS_ARRAY",
          "args": [
            "\"errors\"",
            "on_errors",
            "on_errors_arr"
          ],
          "line": 203
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NTFS_GETOPT_BOOL",
          "args": [
            "\"disable_sparse\"",
            "disable_sparse"
          ],
          "line": 202
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NTFS_GETOPT_BOOL",
          "args": [
            "\"case_sensitive\"",
            "case_sensitive"
          ],
          "line": 201
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NTFS_GETOPT_BOOL",
          "args": [
            "\"show_sys_files\"",
            "show_sys_files"
          ],
          "line": 200
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NTFS_GETOPT_WITH_DEFAULT",
          "args": [
            "\"sloppy\"",
            "sloppy",
            "true"
          ],
          "line": 199
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NTFS_GETOPT",
          "args": [
            "\"mft_zone_multiplier\"",
            "mft_zone_multiplier"
          ],
          "line": 198
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NTFS_GETOPT_OCTAL",
          "args": [
            "\"dmask\"",
            "dmask"
          ],
          "line": 197
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NTFS_GETOPT_OCTAL",
          "args": [
            "\"fmask\"",
            "fmask"
          ],
          "line": 196
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NTFS_GETOPT_OCTAL",
          "args": [
            "\"umask\"",
            "fmask = dmask"
          ],
          "line": 195
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NTFS_GETOPT_GID",
          "args": [
            "\"gid\"",
            "gid"
          ],
          "line": 194
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NTFS_GETOPT_UID",
          "args": [
            "\"uid\"",
            "uid"
          ],
          "line": 193
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "p",
            "'='"
          ],
          "line": 191
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strsep",
          "args": [
            "&opt",
            "\",\""
          ],
          "line": 190
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_debug",
          "args": [
            "\"Entering with mount options string: %s\"",
            "opt"
          ],
          "line": 189
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ntfs.h\"\n#include \"malloc.h\"\n#include \"layout.h\"\n#include \"aops.h\"\n#include \"inode.h\"\n#include \"index.h\"\n#include \"debug.h\"\n#include \"dir.h\"\n#include \"usnjrnl.h\"\n#include \"quota.h\"\n#include \"logfile.h\"\n#include \"sysctl.h\"\n#include <linux/bitmap.h>\n#include <linux/moduleparam.h>\n#include <linux/vfs.h>\n#include <linux/buffer_head.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\t/* For bdev_logical_block_size(). */\n#include <linux/spinlock.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/stddef.h>\n\nconst option_t on_errors_arr[] = {\n\t{ ON_ERRORS_PANIC,\t\"panic\" },\n\t{ ON_ERRORS_REMOUNT_RO,\t\"remount-ro\", },\n\t{ ON_ERRORS_CONTINUE,\t\"continue\", },\n\t{ ON_ERRORS_RECOVER,\t\"recover\" },\n\t{ 0,\t\t\tNULL }\n};\n\nstatic bool parse_options(ntfs_volume *vol, char *opt)\n{\n\tchar *p, *v, *ov;\n\tstatic char *utf8 = \"utf8\";\n\tint errors = 0, sloppy = 0;\n\tkuid_t uid = INVALID_UID;\n\tkgid_t gid = INVALID_GID;\n\tumode_t fmask = (umode_t)-1, dmask = (umode_t)-1;\n\tint mft_zone_multiplier = -1, on_errors = -1;\n\tint show_sys_files = -1, case_sensitive = -1, disable_sparse = -1;\n\tstruct nls_table *nls_map = NULL, *old_nls;\n\n\t/* I am lazy... (-8 */\n#define NTFS_GETOPT_WITH_DEFAULT(option, variable, default_value)\t\\\n\tif (!strcmp(p, option)) {\t\t\t\t\t\\\n\t\tif (!v || !*v)\t\t\t\t\t\t\\\n\t\t\tvariable = default_value;\t\t\t\\\n\t\telse {\t\t\t\t\t\t\t\\\n\t\t\tvariable = simple_strtoul(ov = v, &v, 0);\t\\\n\t\t\tif (*v)\t\t\t\t\t\t\\\n\t\t\t\tgoto needs_val;\t\t\t\t\\\n\t\t}\t\t\t\t\t\t\t\\\n\t}\n#define NTFS_GETOPT(option, variable)\t\t\t\t\t\\\n\tif (!strcmp(p, option)) {\t\t\t\t\t\\\n\t\tif (!v || !*v)\t\t\t\t\t\t\\\n\t\t\tgoto needs_arg;\t\t\t\t\t\\\n\t\tvariable = simple_strtoul(ov = v, &v, 0);\t\t\\\n\t\tif (*v)\t\t\t\t\t\t\t\\\n\t\t\tgoto needs_val;\t\t\t\t\t\\\n\t}\n#define NTFS_GETOPT_UID(option, variable)\t\t\t\t\\\n\tif (!strcmp(p, option)) {\t\t\t\t\t\\\n\t\tuid_t uid_value;\t\t\t\t\t\\\n\t\tif (!v || !*v)\t\t\t\t\t\t\\\n\t\t\tgoto needs_arg;\t\t\t\t\t\\\n\t\tuid_value = simple_strtoul(ov = v, &v, 0);\t\t\\\n\t\tif (*v)\t\t\t\t\t\t\t\\\n\t\t\tgoto needs_val;\t\t\t\t\t\\\n\t\tvariable = make_kuid(current_user_ns(), uid_value);\t\\\n\t\tif (!uid_valid(variable))\t\t\t\t\\\n\t\t\tgoto needs_val;\t\t\t\t\t\\\n\t}\n#define NTFS_GETOPT_GID(option, variable)\t\t\t\t\\\n\tif (!strcmp(p, option)) {\t\t\t\t\t\\\n\t\tgid_t gid_value;\t\t\t\t\t\\\n\t\tif (!v || !*v)\t\t\t\t\t\t\\\n\t\t\tgoto needs_arg;\t\t\t\t\t\\\n\t\tgid_value = simple_strtoul(ov = v, &v, 0);\t\t\\\n\t\tif (*v)\t\t\t\t\t\t\t\\\n\t\t\tgoto needs_val;\t\t\t\t\t\\\n\t\tvariable = make_kgid(current_user_ns(), gid_value);\t\\\n\t\tif (!gid_valid(variable))\t\t\t\t\\\n\t\t\tgoto needs_val;\t\t\t\t\t\\\n\t}\n#define NTFS_GETOPT_OCTAL(option, variable)\t\t\t\t\\\n\tif (!strcmp(p, option)) {\t\t\t\t\t\\\n\t\tif (!v || !*v)\t\t\t\t\t\t\\\n\t\t\tgoto needs_arg;\t\t\t\t\t\\\n\t\tvariable = simple_strtoul(ov = v, &v, 8);\t\t\\\n\t\tif (*v)\t\t\t\t\t\t\t\\\n\t\t\tgoto needs_val;\t\t\t\t\t\\\n\t}\n#define NTFS_GETOPT_BOOL(option, variable)\t\t\t\t\\\n\tif (!strcmp(p, option)) {\t\t\t\t\t\\\n\t\tbool val;\t\t\t\t\t\t\\\n\t\tif (!simple_getbool(v, &val))\t\t\t\t\\\n\t\t\tgoto needs_bool;\t\t\t\t\\\n\t\tvariable = val;\t\t\t\t\t\t\\\n\t}\n#define NTFS_GETOPT_OPTIONS_ARRAY(option, variable, opt_array)\t\t\\\n\tif (!strcmp(p, option)) {\t\t\t\t\t\\\n\t\tint _i;\t\t\t\t\t\t\t\\\n\t\tif (!v || !*v)\t\t\t\t\t\t\\\n\t\t\tgoto needs_arg;\t\t\t\t\t\\\n\t\tov = v;\t\t\t\t\t\t\t\\\n\t\tif (variable == -1)\t\t\t\t\t\\\n\t\t\tvariable = 0;\t\t\t\t\t\\\n\t\tfor (_i = 0; opt_array[_i].str && *opt_array[_i].str; _i++) \\\n\t\t\tif (!strcmp(opt_array[_i].str, v)) {\t\t\\\n\t\t\t\tvariable |= opt_array[_i].val;\t\t\\\n\t\t\t\tbreak;\t\t\t\t\t\\\n\t\t\t}\t\t\t\t\t\t\\\n\t\tif (!opt_array[_i].str || !*opt_array[_i].str)\t\t\\\n\t\t\tgoto needs_val;\t\t\t\t\t\\\n\t}\n\tif (!opt || !*opt)\n\t\tgoto no_mount_options;\n\tntfs_debug(\"Entering with mount options string: %s\", opt);\n\twhile ((p = strsep(&opt, \",\"))) {\n\t\tif ((v = strchr(p, '=')))\n\t\t\t*v++ = 0;\n\t\tNTFS_GETOPT_UID(\"uid\", uid)\n\t\telse NTFS_GETOPT_GID(\"gid\", gid)\n\t\telse NTFS_GETOPT_OCTAL(\"umask\", fmask = dmask)\n\t\telse NTFS_GETOPT_OCTAL(\"fmask\", fmask)\n\t\telse NTFS_GETOPT_OCTAL(\"dmask\", dmask)\n\t\telse NTFS_GETOPT(\"mft_zone_multiplier\", mft_zone_multiplier)\n\t\telse NTFS_GETOPT_WITH_DEFAULT(\"sloppy\", sloppy, true)\n\t\telse NTFS_GETOPT_BOOL(\"show_sys_files\", show_sys_files)\n\t\telse NTFS_GETOPT_BOOL(\"case_sensitive\", case_sensitive)\n\t\telse NTFS_GETOPT_BOOL(\"disable_sparse\", disable_sparse)\n\t\telse NTFS_GETOPT_OPTIONS_ARRAY(\"errors\", on_errors,\n\t\t\t\ton_errors_arr)\n\t\telse if (!strcmp(p, \"posix\") || !strcmp(p, \"show_inodes\"))\n\t\t\tntfs_warning(vol->sb, \"Ignoring obsolete option %s.\",\n\t\t\t\t\tp);\n\t\telse if (!strcmp(p, \"nls\") || !strcmp(p, \"iocharset\")) {\n\t\t\tif (!strcmp(p, \"iocharset\"))\n\t\t\t\tntfs_warning(vol->sb, \"Option iocharset is \"\n\t\t\t\t\t\t\"deprecated. Please use \"\n\t\t\t\t\t\t\"option nls=<charsetname> in \"\n\t\t\t\t\t\t\"the future.\");\n\t\t\tif (!v || !*v)\n\t\t\t\tgoto needs_arg;\nuse_utf8:\n\t\t\told_nls = nls_map;\n\t\t\tnls_map = load_nls(v);\n\t\t\tif (!nls_map) {\n\t\t\t\tif (!old_nls) {\n\t\t\t\t\tntfs_error(vol->sb, \"NLS character set \"\n\t\t\t\t\t\t\t\"%s not found.\", v);\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\tntfs_error(vol->sb, \"NLS character set %s not \"\n\t\t\t\t\t\t\"found. Using previous one %s.\",\n\t\t\t\t\t\tv, old_nls->charset);\n\t\t\t\tnls_map = old_nls;\n\t\t\t} else /* nls_map */ {\n\t\t\t\tunload_nls(old_nls);\n\t\t\t}\n\t\t} else if (!strcmp(p, \"utf8\")) {\n\t\t\tbool val = false;\n\t\t\tntfs_warning(vol->sb, \"Option utf8 is no longer \"\n\t\t\t\t   \"supported, using option nls=utf8. Please \"\n\t\t\t\t   \"use option nls=utf8 in the future and \"\n\t\t\t\t   \"make sure utf8 is compiled either as a \"\n\t\t\t\t   \"module or into the kernel.\");\n\t\t\tif (!v || !*v)\n\t\t\t\tval = true;\n\t\t\telse if (!simple_getbool(v, &val))\n\t\t\t\tgoto needs_bool;\n\t\t\tif (val) {\n\t\t\t\tv = utf8;\n\t\t\t\tgoto use_utf8;\n\t\t\t}\n\t\t} else {\n\t\t\tntfs_error(vol->sb, \"Unrecognized mount option %s.\", p);\n\t\t\tif (errors < INT_MAX)\n\t\t\t\terrors++;\n\t\t}\n#undef NTFS_GETOPT_OPTIONS_ARRAY\n#undef NTFS_GETOPT_BOOL\n#undef NTFS_GETOPT\n#undef NTFS_GETOPT_WITH_DEFAULT\n\t}\nno_mount_options:\n\tif (errors && !sloppy)\n\t\treturn false;\n\tif (sloppy)\n\t\tntfs_warning(vol->sb, \"Sloppy option given. Ignoring \"\n\t\t\t\t\"unrecognized mount option(s) and continuing.\");\n\t/* Keep this first! */\n\tif (on_errors != -1) {\n\t\tif (!on_errors) {\n\t\t\tntfs_error(vol->sb, \"Invalid errors option argument \"\n\t\t\t\t\t\"or bug in options parser.\");\n\t\t\treturn false;\n\t\t}\n\t}\n\tif (nls_map) {\n\t\tif (vol->nls_map && vol->nls_map != nls_map) {\n\t\t\tntfs_error(vol->sb, \"Cannot change NLS character set \"\n\t\t\t\t\t\"on remount.\");\n\t\t\treturn false;\n\t\t} /* else (!vol->nls_map) */\n\t\tntfs_debug(\"Using NLS character set %s.\", nls_map->charset);\n\t\tvol->nls_map = nls_map;\n\t} else /* (!nls_map) */ {\n\t\tif (!vol->nls_map) {\n\t\t\tvol->nls_map = load_nls_default();\n\t\t\tif (!vol->nls_map) {\n\t\t\t\tntfs_error(vol->sb, \"Failed to load default \"\n\t\t\t\t\t\t\"NLS character set.\");\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tntfs_debug(\"Using default NLS character set (%s).\",\n\t\t\t\t\tvol->nls_map->charset);\n\t\t}\n\t}\n\tif (mft_zone_multiplier != -1) {\n\t\tif (vol->mft_zone_multiplier && vol->mft_zone_multiplier !=\n\t\t\t\tmft_zone_multiplier) {\n\t\t\tntfs_error(vol->sb, \"Cannot change mft_zone_multiplier \"\n\t\t\t\t\t\"on remount.\");\n\t\t\treturn false;\n\t\t}\n\t\tif (mft_zone_multiplier < 1 || mft_zone_multiplier > 4) {\n\t\t\tntfs_error(vol->sb, \"Invalid mft_zone_multiplier. \"\n\t\t\t\t\t\"Using default value, i.e. 1.\");\n\t\t\tmft_zone_multiplier = 1;\n\t\t}\n\t\tvol->mft_zone_multiplier = mft_zone_multiplier;\n\t}\n\tif (!vol->mft_zone_multiplier)\n\t\tvol->mft_zone_multiplier = 1;\n\tif (on_errors != -1)\n\t\tvol->on_errors = on_errors;\n\tif (!vol->on_errors || vol->on_errors == ON_ERRORS_RECOVER)\n\t\tvol->on_errors |= ON_ERRORS_CONTINUE;\n\tif (uid_valid(uid))\n\t\tvol->uid = uid;\n\tif (gid_valid(gid))\n\t\tvol->gid = gid;\n\tif (fmask != (umode_t)-1)\n\t\tvol->fmask = fmask;\n\tif (dmask != (umode_t)-1)\n\t\tvol->dmask = dmask;\n\tif (show_sys_files != -1) {\n\t\tif (show_sys_files)\n\t\t\tNVolSetShowSystemFiles(vol);\n\t\telse\n\t\t\tNVolClearShowSystemFiles(vol);\n\t}\n\tif (case_sensitive != -1) {\n\t\tif (case_sensitive)\n\t\t\tNVolSetCaseSensitive(vol);\n\t\telse\n\t\t\tNVolClearCaseSensitive(vol);\n\t}\n\tif (disable_sparse != -1) {\n\t\tif (disable_sparse)\n\t\t\tNVolClearSparseEnabled(vol);\n\t\telse {\n\t\t\tif (!NVolSparseEnabled(vol) &&\n\t\t\t\t\tvol->major_ver && vol->major_ver < 3)\n\t\t\t\tntfs_warning(vol->sb, \"Not enabling sparse \"\n\t\t\t\t\t\t\"support due to NTFS volume \"\n\t\t\t\t\t\t\"version %i.%i (need at least \"\n\t\t\t\t\t\t\"version 3.0).\", vol->major_ver,\n\t\t\t\t\t\tvol->minor_ver);\n\t\t\telse\n\t\t\t\tNVolSetSparseEnabled(vol);\n\t\t}\n\t}\n\treturn true;\nneeds_arg:\n\tntfs_error(vol->sb, \"The %s option requires an argument.\", p);\n\treturn false;\nneeds_bool:\n\tntfs_error(vol->sb, \"The %s option requires a boolean argument.\", p);\n\treturn false;\nneeds_val:\n\tntfs_error(vol->sb, \"Invalid %s option argument: %s\", p, ov);\n\treturn false;\n}"
  },
  {
    "function_name": "simple_getbool",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/super.c",
    "lines": "79-92",
    "snippet": "static int simple_getbool(char *s, bool *setval)\n{\n\tif (s) {\n\t\tif (!strcmp(s, \"1\") || !strcmp(s, \"yes\") || !strcmp(s, \"true\"))\n\t\t\t*setval = true;\n\t\telse if (!strcmp(s, \"0\") || !strcmp(s, \"no\") ||\n\t\t\t\t\t\t\t!strcmp(s, \"false\"))\n\t\t\t*setval = false;\n\t\telse\n\t\t\treturn 0;\n\t} else\n\t\t*setval = true;\n\treturn 1;\n}",
    "includes": [
      "#include \"ntfs.h\"",
      "#include \"malloc.h\"",
      "#include \"layout.h\"",
      "#include \"aops.h\"",
      "#include \"inode.h\"",
      "#include \"index.h\"",
      "#include \"debug.h\"",
      "#include \"dir.h\"",
      "#include \"usnjrnl.h\"",
      "#include \"quota.h\"",
      "#include \"logfile.h\"",
      "#include \"sysctl.h\"",
      "#include <linux/bitmap.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/vfs.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/blkdev.h>\t/* For bdev_logical_block_size(). */",
      "#include <linux/spinlock.h>",
      "#include <linux/string.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/stddef.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "s",
            "\"false\""
          ],
          "line": 85
        },
        "resolved": true,
        "details": {
          "function_name": "strcmp_null",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/super.c",
          "lines": "292-301",
          "snippet": "static int strcmp_null(const char *s1, const char *s2)\n{\n\tif (!s1 && !s2)\n\t\treturn 0;\n\tif (s1 && !s2)\n\t\treturn -1;\n\tif (!s1 && s2)\n\t\treturn 1;\n\treturn strcmp(s1, s2);\n}",
          "includes": [
            "#include <linux/ceph/debugfs.h>",
            "#include <linux/ceph/auth.h>",
            "#include <linux/ceph/mon_client.h>",
            "#include <linux/ceph/decode.h>",
            "#include <linux/ceph/ceph_features.h>",
            "#include \"cache.h\"",
            "#include \"mds_client.h\"",
            "#include \"super.h\"",
            "#include <linux/string.h>",
            "#include <linux/statfs.h>",
            "#include <linux/slab.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/sched.h>",
            "#include <linux/parser.h>",
            "#include <linux/mount.h>",
            "#include <linux/module.h>",
            "#include <linux/in6.h>",
            "#include <linux/inet.h>",
            "#include <linux/fs.h>",
            "#include <linux/ctype.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ceph/debugfs.h>\n#include <linux/ceph/auth.h>\n#include <linux/ceph/mon_client.h>\n#include <linux/ceph/decode.h>\n#include <linux/ceph/ceph_features.h>\n#include \"cache.h\"\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/string.h>\n#include <linux/statfs.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/sched.h>\n#include <linux/parser.h>\n#include <linux/mount.h>\n#include <linux/module.h>\n#include <linux/in6.h>\n#include <linux/inet.h>\n#include <linux/fs.h>\n#include <linux/ctype.h>\n#include <linux/backing-dev.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic int strcmp_null(const char *s1, const char *s2)\n{\n\tif (!s1 && !s2)\n\t\treturn 0;\n\tif (s1 && !s2)\n\t\treturn -1;\n\tif (!s1 && s2)\n\t\treturn 1;\n\treturn strcmp(s1, s2);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ntfs.h\"\n#include \"malloc.h\"\n#include \"layout.h\"\n#include \"aops.h\"\n#include \"inode.h\"\n#include \"index.h\"\n#include \"debug.h\"\n#include \"dir.h\"\n#include \"usnjrnl.h\"\n#include \"quota.h\"\n#include \"logfile.h\"\n#include \"sysctl.h\"\n#include <linux/bitmap.h>\n#include <linux/moduleparam.h>\n#include <linux/vfs.h>\n#include <linux/buffer_head.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\t/* For bdev_logical_block_size(). */\n#include <linux/spinlock.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/stddef.h>\n\nstatic int simple_getbool(char *s, bool *setval)\n{\n\tif (s) {\n\t\tif (!strcmp(s, \"1\") || !strcmp(s, \"yes\") || !strcmp(s, \"true\"))\n\t\t\t*setval = true;\n\t\telse if (!strcmp(s, \"0\") || !strcmp(s, \"no\") ||\n\t\t\t\t\t\t\t!strcmp(s, \"false\"))\n\t\t\t*setval = false;\n\t\telse\n\t\t\treturn 0;\n\t} else\n\t\t*setval = true;\n\treturn 1;\n}"
  }
]