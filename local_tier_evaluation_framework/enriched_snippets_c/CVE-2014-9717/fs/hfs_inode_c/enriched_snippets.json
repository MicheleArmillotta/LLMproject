[
  {
    "function_name": "hfs_file_fsync",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfs/inode.c",
    "lines": "649-673",
    "snippet": "static int hfs_file_fsync(struct file *filp, loff_t start, loff_t end,\n\t\t\t  int datasync)\n{\n\tstruct inode *inode = filp->f_mapping->host;\n\tstruct super_block * sb;\n\tint ret, err;\n\n\tret = filemap_write_and_wait_range(inode->i_mapping, start, end);\n\tif (ret)\n\t\treturn ret;\n\tmutex_lock(&inode->i_mutex);\n\n\t/* sync the inode to buffers */\n\tret = write_inode_now(inode, 0);\n\n\t/* sync the superblock to buffers */\n\tsb = inode->i_sb;\n\tflush_delayed_work(&HFS_SB(sb)->mdb_work);\n\t/* .. finally sync the buffers to disk */\n\terr = sync_blockdev(sb->s_bdev);\n\tif (!ret)\n\t\tret = err;\n\tmutex_unlock(&inode->i_mutex);\n\treturn ret;\n}",
    "includes": [
      "#include \"btree.h\"",
      "#include \"hfs_fs.h\"",
      "#include <linux/aio.h>",
      "#include <linux/sched.h>",
      "#include <linux/mpage.h>",
      "#include <linux/pagemap.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&inode->i_mutex"
          ],
          "line": 671
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sync_blockdev",
          "args": [
            "sb->s_bdev"
          ],
          "line": 668
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_sync_blockdev",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/inode.c",
          "lines": "548-551",
          "snippet": "void ocfs2_sync_blockdev(struct super_block *sb)\n{\n\tsync_blockdev(sb->s_bdev);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"symlink.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"dir.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"symlink.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"dir.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <asm/byteorder.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nvoid ocfs2_sync_blockdev(struct super_block *sb)\n{\n\tsync_blockdev(sb->s_bdev);\n}"
        }
      },
      {
        "call_info": {
          "callee": "flush_delayed_work",
          "args": [
            "&HFS_SB(sb)->mdb_work"
          ],
          "line": 666
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HFS_SB",
          "args": [
            "sb"
          ],
          "line": 666
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "write_inode_now",
          "args": [
            "inode",
            "0"
          ],
          "line": 662
        },
        "resolved": true,
        "details": {
          "function_name": "write_inode_now",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fs-writeback.c",
          "lines": "1469-1484",
          "snippet": "int write_inode_now(struct inode *inode, int sync)\n{\n\tstruct bdi_writeback *wb = &inode_to_bdi(inode)->wb;\n\tstruct writeback_control wbc = {\n\t\t.nr_to_write = LONG_MAX,\n\t\t.sync_mode = sync ? WB_SYNC_ALL : WB_SYNC_NONE,\n\t\t.range_start = 0,\n\t\t.range_end = LLONG_MAX,\n\t};\n\n\tif (!mapping_cap_writeback_dirty(inode->i_mapping))\n\t\twbc.nr_to_write = 0;\n\n\tmight_sleep();\n\treturn writeback_single_inode(inode, wb, &wbc);\n}",
          "includes": [
            "#include <trace/events/writeback.h>",
            "#include \"internal.h\"",
            "#include <linux/device.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/writeback.h>\n#include \"internal.h\"\n#include <linux/device.h>\n#include <linux/tracepoint.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nint write_inode_now(struct inode *inode, int sync)\n{\n\tstruct bdi_writeback *wb = &inode_to_bdi(inode)->wb;\n\tstruct writeback_control wbc = {\n\t\t.nr_to_write = LONG_MAX,\n\t\t.sync_mode = sync ? WB_SYNC_ALL : WB_SYNC_NONE,\n\t\t.range_start = 0,\n\t\t.range_end = LLONG_MAX,\n\t};\n\n\tif (!mapping_cap_writeback_dirty(inode->i_mapping))\n\t\twbc.nr_to_write = 0;\n\n\tmight_sleep();\n\treturn writeback_single_inode(inode, wb, &wbc);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&inode->i_mutex"
          ],
          "line": 659
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "filemap_write_and_wait_range",
          "args": [
            "inode->i_mapping",
            "start",
            "end"
          ],
          "line": 656
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"btree.h\"\n#include \"hfs_fs.h\"\n#include <linux/aio.h>\n#include <linux/sched.h>\n#include <linux/mpage.h>\n#include <linux/pagemap.h>\n\nstatic int hfs_file_fsync(struct file *filp, loff_t start, loff_t end,\n\t\t\t  int datasync)\n{\n\tstruct inode *inode = filp->f_mapping->host;\n\tstruct super_block * sb;\n\tint ret, err;\n\n\tret = filemap_write_and_wait_range(inode->i_mapping, start, end);\n\tif (ret)\n\t\treturn ret;\n\tmutex_lock(&inode->i_mutex);\n\n\t/* sync the inode to buffers */\n\tret = write_inode_now(inode, 0);\n\n\t/* sync the superblock to buffers */\n\tsb = inode->i_sb;\n\tflush_delayed_work(&HFS_SB(sb)->mdb_work);\n\t/* .. finally sync the buffers to disk */\n\terr = sync_blockdev(sb->s_bdev);\n\tif (!ret)\n\t\tret = err;\n\tmutex_unlock(&inode->i_mutex);\n\treturn ret;\n}"
  },
  {
    "function_name": "hfs_inode_setattr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfs/inode.c",
    "lines": "601-647",
    "snippet": "int hfs_inode_setattr(struct dentry *dentry, struct iattr * attr)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tstruct hfs_sb_info *hsb = HFS_SB(inode->i_sb);\n\tint error;\n\n\terror = inode_change_ok(inode, attr); /* basic permission checks */\n\tif (error)\n\t\treturn error;\n\n\t/* no uig/gid changes and limit which mode bits can be set */\n\tif (((attr->ia_valid & ATTR_UID) &&\n\t     (!uid_eq(attr->ia_uid, hsb->s_uid))) ||\n\t    ((attr->ia_valid & ATTR_GID) &&\n\t     (!gid_eq(attr->ia_gid, hsb->s_gid))) ||\n\t    ((attr->ia_valid & ATTR_MODE) &&\n\t     ((S_ISDIR(inode->i_mode) &&\n\t       (attr->ia_mode != inode->i_mode)) ||\n\t      (attr->ia_mode & ~HFS_VALID_MODE_BITS)))) {\n\t\treturn hsb->s_quiet ? 0 : error;\n\t}\n\n\tif (attr->ia_valid & ATTR_MODE) {\n\t\t/* Only the 'w' bits can ever change and only all together. */\n\t\tif (attr->ia_mode & S_IWUSR)\n\t\t\tattr->ia_mode = inode->i_mode | S_IWUGO;\n\t\telse\n\t\t\tattr->ia_mode = inode->i_mode & ~S_IWUGO;\n\t\tattr->ia_mode &= S_ISDIR(inode->i_mode) ? ~hsb->s_dir_umask: ~hsb->s_file_umask;\n\t}\n\n\tif ((attr->ia_valid & ATTR_SIZE) &&\n\t    attr->ia_size != i_size_read(inode)) {\n\t\tinode_dio_wait(inode);\n\n\t\terror = inode_newsize_ok(inode, attr->ia_size);\n\t\tif (error)\n\t\t\treturn error;\n\n\t\ttruncate_setsize(inode, attr->ia_size);\n\t\thfs_file_truncate(inode);\n\t}\n\n\tsetattr_copy(inode, attr);\n\tmark_inode_dirty(inode);\n\treturn 0;\n}",
    "includes": [
      "#include \"btree.h\"",
      "#include \"hfs_fs.h\"",
      "#include <linux/aio.h>",
      "#include <linux/sched.h>",
      "#include <linux/mpage.h>",
      "#include <linux/pagemap.h>"
    ],
    "macros_used": [
      "#define HFS_VALID_MODE_BITS  (S_IFREG | S_IFDIR | S_IRWXUGO)"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mark_inode_dirty",
          "args": [
            "inode"
          ],
          "line": 645
        },
        "resolved": true,
        "details": {
          "function_name": "block_dump___mark_inode_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fs-writeback.c",
          "lines": "1134-1154",
          "snippet": "static noinline void block_dump___mark_inode_dirty(struct inode *inode)\n{\n\tif (inode->i_ino || strcmp(inode->i_sb->s_id, \"bdev\")) {\n\t\tstruct dentry *dentry;\n\t\tconst char *name = \"?\";\n\n\t\tdentry = d_find_alias(inode);\n\t\tif (dentry) {\n\t\t\tspin_lock(&dentry->d_lock);\n\t\t\tname = (const char *) dentry->d_name.name;\n\t\t}\n\t\tprintk(KERN_DEBUG\n\t\t       \"%s(%d): dirtied inode %lu (%s) on %s\\n\",\n\t\t       current->comm, task_pid_nr(current), inode->i_ino,\n\t\t       name, inode->i_sb->s_id);\n\t\tif (dentry) {\n\t\t\tspin_unlock(&dentry->d_lock);\n\t\t\tdput(dentry);\n\t\t}\n\t}\n}",
          "includes": [
            "#include <trace/events/writeback.h>",
            "#include \"internal.h\"",
            "#include <linux/device.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/writeback.h>\n#include \"internal.h\"\n#include <linux/device.h>\n#include <linux/tracepoint.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nstatic noinline void block_dump___mark_inode_dirty(struct inode *inode)\n{\n\tif (inode->i_ino || strcmp(inode->i_sb->s_id, \"bdev\")) {\n\t\tstruct dentry *dentry;\n\t\tconst char *name = \"?\";\n\n\t\tdentry = d_find_alias(inode);\n\t\tif (dentry) {\n\t\t\tspin_lock(&dentry->d_lock);\n\t\t\tname = (const char *) dentry->d_name.name;\n\t\t}\n\t\tprintk(KERN_DEBUG\n\t\t       \"%s(%d): dirtied inode %lu (%s) on %s\\n\",\n\t\t       current->comm, task_pid_nr(current), inode->i_ino,\n\t\t       name, inode->i_sb->s_id);\n\t\tif (dentry) {\n\t\t\tspin_unlock(&dentry->d_lock);\n\t\t\tdput(dentry);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "setattr_copy",
          "args": [
            "inode",
            "attr"
          ],
          "line": 644
        },
        "resolved": true,
        "details": {
          "function_name": "setattr_copy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/attr.c",
          "lines": "142-167",
          "snippet": "void setattr_copy(struct inode *inode, const struct iattr *attr)\n{\n\tunsigned int ia_valid = attr->ia_valid;\n\n\tif (ia_valid & ATTR_UID)\n\t\tinode->i_uid = attr->ia_uid;\n\tif (ia_valid & ATTR_GID)\n\t\tinode->i_gid = attr->ia_gid;\n\tif (ia_valid & ATTR_ATIME)\n\t\tinode->i_atime = timespec_trunc(attr->ia_atime,\n\t\t\t\t\t\tinode->i_sb->s_time_gran);\n\tif (ia_valid & ATTR_MTIME)\n\t\tinode->i_mtime = timespec_trunc(attr->ia_mtime,\n\t\t\t\t\t\tinode->i_sb->s_time_gran);\n\tif (ia_valid & ATTR_CTIME)\n\t\tinode->i_ctime = timespec_trunc(attr->ia_ctime,\n\t\t\t\t\t\tinode->i_sb->s_time_gran);\n\tif (ia_valid & ATTR_MODE) {\n\t\tumode_t mode = attr->ia_mode;\n\n\t\tif (!in_group_p(inode->i_gid) &&\n\t\t    !capable_wrt_inode_uidgid(inode, CAP_FSETID))\n\t\t\tmode &= ~S_ISGID;\n\t\tinode->i_mode = mode;\n\t}\n}",
          "includes": [
            "#include <linux/ima.h>",
            "#include <linux/evm.h>",
            "#include <linux/security.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/capability.h>",
            "#include <linux/string.h>",
            "#include <linux/mm.h>",
            "#include <linux/time.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ima.h>\n#include <linux/evm.h>\n#include <linux/security.h>\n#include <linux/fcntl.h>\n#include <linux/fsnotify.h>\n#include <linux/capability.h>\n#include <linux/string.h>\n#include <linux/mm.h>\n#include <linux/time.h>\n#include <linux/export.h>\n\nvoid setattr_copy(struct inode *inode, const struct iattr *attr)\n{\n\tunsigned int ia_valid = attr->ia_valid;\n\n\tif (ia_valid & ATTR_UID)\n\t\tinode->i_uid = attr->ia_uid;\n\tif (ia_valid & ATTR_GID)\n\t\tinode->i_gid = attr->ia_gid;\n\tif (ia_valid & ATTR_ATIME)\n\t\tinode->i_atime = timespec_trunc(attr->ia_atime,\n\t\t\t\t\t\tinode->i_sb->s_time_gran);\n\tif (ia_valid & ATTR_MTIME)\n\t\tinode->i_mtime = timespec_trunc(attr->ia_mtime,\n\t\t\t\t\t\tinode->i_sb->s_time_gran);\n\tif (ia_valid & ATTR_CTIME)\n\t\tinode->i_ctime = timespec_trunc(attr->ia_ctime,\n\t\t\t\t\t\tinode->i_sb->s_time_gran);\n\tif (ia_valid & ATTR_MODE) {\n\t\tumode_t mode = attr->ia_mode;\n\n\t\tif (!in_group_p(inode->i_gid) &&\n\t\t    !capable_wrt_inode_uidgid(inode, CAP_FSETID))\n\t\t\tmode &= ~S_ISGID;\n\t\tinode->i_mode = mode;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "hfs_file_truncate",
          "args": [
            "inode"
          ],
          "line": 641
        },
        "resolved": true,
        "details": {
          "function_name": "hfs_file_truncate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfs/extent.c",
          "lines": "470-545",
          "snippet": "void hfs_file_truncate(struct inode *inode)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tstruct hfs_find_data fd;\n\tu16 blk_cnt, alloc_cnt, start;\n\tu32 size;\n\tint res;\n\n\thfs_dbg(INODE, \"truncate: %lu, %Lu -> %Lu\\n\",\n\t\tinode->i_ino, (long long)HFS_I(inode)->phys_size,\n\t\tinode->i_size);\n\tif (inode->i_size > HFS_I(inode)->phys_size) {\n\t\tstruct address_space *mapping = inode->i_mapping;\n\t\tvoid *fsdata;\n\t\tstruct page *page;\n\n\t\t/* XXX: Can use generic_cont_expand? */\n\t\tsize = inode->i_size - 1;\n\t\tres = pagecache_write_begin(NULL, mapping, size+1, 0,\n\t\t\t\tAOP_FLAG_UNINTERRUPTIBLE, &page, &fsdata);\n\t\tif (!res) {\n\t\t\tres = pagecache_write_end(NULL, mapping, size+1, 0, 0,\n\t\t\t\t\tpage, fsdata);\n\t\t}\n\t\tif (res)\n\t\t\tinode->i_size = HFS_I(inode)->phys_size;\n\t\treturn;\n\t} else if (inode->i_size == HFS_I(inode)->phys_size)\n\t\treturn;\n\tsize = inode->i_size + HFS_SB(sb)->alloc_blksz - 1;\n\tblk_cnt = size / HFS_SB(sb)->alloc_blksz;\n\talloc_cnt = HFS_I(inode)->alloc_blocks;\n\tif (blk_cnt == alloc_cnt)\n\t\tgoto out;\n\n\tmutex_lock(&HFS_I(inode)->extents_lock);\n\tres = hfs_find_init(HFS_SB(sb)->ext_tree, &fd);\n\tif (res) {\n\t\tmutex_unlock(&HFS_I(inode)->extents_lock);\n\t\t/* XXX: We lack error handling of hfs_file_truncate() */\n\t\treturn;\n\t}\n\twhile (1) {\n\t\tif (alloc_cnt == HFS_I(inode)->first_blocks) {\n\t\t\thfs_free_extents(sb, HFS_I(inode)->first_extents,\n\t\t\t\t\t alloc_cnt, alloc_cnt - blk_cnt);\n\t\t\thfs_dump_extent(HFS_I(inode)->first_extents);\n\t\t\tHFS_I(inode)->first_blocks = blk_cnt;\n\t\t\tbreak;\n\t\t}\n\t\tres = __hfs_ext_cache_extent(&fd, inode, alloc_cnt);\n\t\tif (res)\n\t\t\tbreak;\n\t\tstart = HFS_I(inode)->cached_start;\n\t\thfs_free_extents(sb, HFS_I(inode)->cached_extents,\n\t\t\t\t alloc_cnt - start, alloc_cnt - blk_cnt);\n\t\thfs_dump_extent(HFS_I(inode)->cached_extents);\n\t\tif (blk_cnt > start) {\n\t\t\tHFS_I(inode)->flags |= HFS_FLG_EXT_DIRTY;\n\t\t\tbreak;\n\t\t}\n\t\talloc_cnt = start;\n\t\tHFS_I(inode)->cached_start = HFS_I(inode)->cached_blocks = 0;\n\t\tHFS_I(inode)->flags &= ~(HFS_FLG_EXT_DIRTY|HFS_FLG_EXT_NEW);\n\t\thfs_brec_remove(&fd);\n\t}\n\thfs_find_exit(&fd);\n\tmutex_unlock(&HFS_I(inode)->extents_lock);\n\n\tHFS_I(inode)->alloc_blocks = blk_cnt;\nout:\n\tHFS_I(inode)->phys_size = inode->i_size;\n\tHFS_I(inode)->fs_blocks = (inode->i_size + sb->s_blocksize - 1) >> sb->s_blocksize_bits;\n\tinode_set_bytes(inode, HFS_I(inode)->fs_blocks << sb->s_blocksize_bits);\n\tmark_inode_dirty(inode);\n}",
          "includes": [
            "#include \"btree.h\"",
            "#include \"hfs_fs.h\"",
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"btree.h\"\n#include \"hfs_fs.h\"\n#include <linux/pagemap.h>\n\nvoid hfs_file_truncate(struct inode *inode)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tstruct hfs_find_data fd;\n\tu16 blk_cnt, alloc_cnt, start;\n\tu32 size;\n\tint res;\n\n\thfs_dbg(INODE, \"truncate: %lu, %Lu -> %Lu\\n\",\n\t\tinode->i_ino, (long long)HFS_I(inode)->phys_size,\n\t\tinode->i_size);\n\tif (inode->i_size > HFS_I(inode)->phys_size) {\n\t\tstruct address_space *mapping = inode->i_mapping;\n\t\tvoid *fsdata;\n\t\tstruct page *page;\n\n\t\t/* XXX: Can use generic_cont_expand? */\n\t\tsize = inode->i_size - 1;\n\t\tres = pagecache_write_begin(NULL, mapping, size+1, 0,\n\t\t\t\tAOP_FLAG_UNINTERRUPTIBLE, &page, &fsdata);\n\t\tif (!res) {\n\t\t\tres = pagecache_write_end(NULL, mapping, size+1, 0, 0,\n\t\t\t\t\tpage, fsdata);\n\t\t}\n\t\tif (res)\n\t\t\tinode->i_size = HFS_I(inode)->phys_size;\n\t\treturn;\n\t} else if (inode->i_size == HFS_I(inode)->phys_size)\n\t\treturn;\n\tsize = inode->i_size + HFS_SB(sb)->alloc_blksz - 1;\n\tblk_cnt = size / HFS_SB(sb)->alloc_blksz;\n\talloc_cnt = HFS_I(inode)->alloc_blocks;\n\tif (blk_cnt == alloc_cnt)\n\t\tgoto out;\n\n\tmutex_lock(&HFS_I(inode)->extents_lock);\n\tres = hfs_find_init(HFS_SB(sb)->ext_tree, &fd);\n\tif (res) {\n\t\tmutex_unlock(&HFS_I(inode)->extents_lock);\n\t\t/* XXX: We lack error handling of hfs_file_truncate() */\n\t\treturn;\n\t}\n\twhile (1) {\n\t\tif (alloc_cnt == HFS_I(inode)->first_blocks) {\n\t\t\thfs_free_extents(sb, HFS_I(inode)->first_extents,\n\t\t\t\t\t alloc_cnt, alloc_cnt - blk_cnt);\n\t\t\thfs_dump_extent(HFS_I(inode)->first_extents);\n\t\t\tHFS_I(inode)->first_blocks = blk_cnt;\n\t\t\tbreak;\n\t\t}\n\t\tres = __hfs_ext_cache_extent(&fd, inode, alloc_cnt);\n\t\tif (res)\n\t\t\tbreak;\n\t\tstart = HFS_I(inode)->cached_start;\n\t\thfs_free_extents(sb, HFS_I(inode)->cached_extents,\n\t\t\t\t alloc_cnt - start, alloc_cnt - blk_cnt);\n\t\thfs_dump_extent(HFS_I(inode)->cached_extents);\n\t\tif (blk_cnt > start) {\n\t\t\tHFS_I(inode)->flags |= HFS_FLG_EXT_DIRTY;\n\t\t\tbreak;\n\t\t}\n\t\talloc_cnt = start;\n\t\tHFS_I(inode)->cached_start = HFS_I(inode)->cached_blocks = 0;\n\t\tHFS_I(inode)->flags &= ~(HFS_FLG_EXT_DIRTY|HFS_FLG_EXT_NEW);\n\t\thfs_brec_remove(&fd);\n\t}\n\thfs_find_exit(&fd);\n\tmutex_unlock(&HFS_I(inode)->extents_lock);\n\n\tHFS_I(inode)->alloc_blocks = blk_cnt;\nout:\n\tHFS_I(inode)->phys_size = inode->i_size;\n\tHFS_I(inode)->fs_blocks = (inode->i_size + sb->s_blocksize - 1) >> sb->s_blocksize_bits;\n\tinode_set_bytes(inode, HFS_I(inode)->fs_blocks << sb->s_blocksize_bits);\n\tmark_inode_dirty(inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "truncate_setsize",
          "args": [
            "inode",
            "attr->ia_size"
          ],
          "line": 640
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "inode_newsize_ok",
          "args": [
            "inode",
            "attr->ia_size"
          ],
          "line": 636
        },
        "resolved": true,
        "details": {
          "function_name": "ecryptfs_inode_newsize_ok",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ecryptfs/inode.c",
          "lines": "823-843",
          "snippet": "static int ecryptfs_inode_newsize_ok(struct inode *inode, loff_t offset)\n{\n\tstruct ecryptfs_crypt_stat *crypt_stat;\n\tloff_t lower_oldsize, lower_newsize;\n\n\tcrypt_stat = &ecryptfs_inode_to_private(inode)->crypt_stat;\n\tlower_oldsize = upper_size_to_lower_size(crypt_stat,\n\t\t\t\t\t\t i_size_read(inode));\n\tlower_newsize = upper_size_to_lower_size(crypt_stat, offset);\n\tif (lower_newsize > lower_oldsize) {\n\t\t/*\n\t\t * The eCryptfs inode and the new *lower* size are mixed here\n\t\t * because we may not have the lower i_mutex held and/or it may\n\t\t * not be appropriate to call inode_newsize_ok() with inodes\n\t\t * from other filesystems.\n\t\t */\n\t\treturn inode_newsize_ok(inode, lower_newsize);\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"ecryptfs_kernel.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/xattr.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs_stack.h>",
            "#include <linux/crypto.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/dcache.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ecryptfs_kernel.h\"\n#include <asm/unaligned.h>\n#include <linux/xattr.h>\n#include <linux/slab.h>\n#include <linux/fs_stack.h>\n#include <linux/crypto.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/dcache.h>\n#include <linux/pagemap.h>\n#include <linux/vmalloc.h>\n#include <linux/file.h>\n\nstatic int ecryptfs_inode_newsize_ok(struct inode *inode, loff_t offset)\n{\n\tstruct ecryptfs_crypt_stat *crypt_stat;\n\tloff_t lower_oldsize, lower_newsize;\n\n\tcrypt_stat = &ecryptfs_inode_to_private(inode)->crypt_stat;\n\tlower_oldsize = upper_size_to_lower_size(crypt_stat,\n\t\t\t\t\t\t i_size_read(inode));\n\tlower_newsize = upper_size_to_lower_size(crypt_stat, offset);\n\tif (lower_newsize > lower_oldsize) {\n\t\t/*\n\t\t * The eCryptfs inode and the new *lower* size are mixed here\n\t\t * because we may not have the lower i_mutex held and/or it may\n\t\t * not be appropriate to call inode_newsize_ok() with inodes\n\t\t * from other filesystems.\n\t\t */\n\t\treturn inode_newsize_ok(inode, lower_newsize);\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "inode_dio_wait",
          "args": [
            "inode"
          ],
          "line": 634
        },
        "resolved": true,
        "details": {
          "function_name": "inode_dio_wait",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "1941-1945",
          "snippet": "void inode_dio_wait(struct inode *inode)\n{\n\tif (atomic_read(&inode->i_dio_count))\n\t\t__inode_dio_wait(inode);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid inode_dio_wait(struct inode *inode)\n{\n\tif (atomic_read(&inode->i_dio_count))\n\t\t__inode_dio_wait(inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "i_size_read",
          "args": [
            "inode"
          ],
          "line": 633
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISDIR",
          "args": [
            "inode->i_mode"
          ],
          "line": 629
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISDIR",
          "args": [
            "inode->i_mode"
          ],
          "line": 617
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gid_eq",
          "args": [
            "attr->ia_gid",
            "hsb->s_gid"
          ],
          "line": 615
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "uid_eq",
          "args": [
            "attr->ia_uid",
            "hsb->s_uid"
          ],
          "line": 613
        },
        "resolved": true,
        "details": {
          "function_name": "uuid_equal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/uuid.c",
          "lines": "59-63",
          "snippet": "int\nuuid_equal(uuid_t *uuid1, uuid_t *uuid2)\n{\n\treturn memcmp(uuid1, uuid2, sizeof(uuid_t)) ? 0 : 1;\n}",
          "includes": [
            "#include <xfs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <xfs.h>\n\nint\nuuid_equal(uuid_t *uuid1, uuid_t *uuid2)\n{\n\treturn memcmp(uuid1, uuid2, sizeof(uuid_t)) ? 0 : 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "inode_change_ok",
          "args": [
            "inode",
            "attr"
          ],
          "line": 607
        },
        "resolved": true,
        "details": {
          "function_name": "inode_change_ok",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/attr.c",
          "lines": "31-81",
          "snippet": "int inode_change_ok(const struct inode *inode, struct iattr *attr)\n{\n\tunsigned int ia_valid = attr->ia_valid;\n\n\t/*\n\t * First check size constraints.  These can't be overriden using\n\t * ATTR_FORCE.\n\t */\n\tif (ia_valid & ATTR_SIZE) {\n\t\tint error = inode_newsize_ok(inode, attr->ia_size);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\n\t/* If force is set do it anyway. */\n\tif (ia_valid & ATTR_FORCE)\n\t\treturn 0;\n\n\t/* Make sure a caller can chown. */\n\tif ((ia_valid & ATTR_UID) &&\n\t    (!uid_eq(current_fsuid(), inode->i_uid) ||\n\t     !uid_eq(attr->ia_uid, inode->i_uid)) &&\n\t    !capable_wrt_inode_uidgid(inode, CAP_CHOWN))\n\t\treturn -EPERM;\n\n\t/* Make sure caller can chgrp. */\n\tif ((ia_valid & ATTR_GID) &&\n\t    (!uid_eq(current_fsuid(), inode->i_uid) ||\n\t    (!in_group_p(attr->ia_gid) && !gid_eq(attr->ia_gid, inode->i_gid))) &&\n\t    !capable_wrt_inode_uidgid(inode, CAP_CHOWN))\n\t\treturn -EPERM;\n\n\t/* Make sure a caller can chmod. */\n\tif (ia_valid & ATTR_MODE) {\n\t\tif (!inode_owner_or_capable(inode))\n\t\t\treturn -EPERM;\n\t\t/* Also check the setgid bit! */\n\t\tif (!in_group_p((ia_valid & ATTR_GID) ? attr->ia_gid :\n\t\t\t\tinode->i_gid) &&\n\t\t    !capable_wrt_inode_uidgid(inode, CAP_FSETID))\n\t\t\tattr->ia_mode &= ~S_ISGID;\n\t}\n\n\t/* Check for setting the inode time. */\n\tif (ia_valid & (ATTR_MTIME_SET | ATTR_ATIME_SET | ATTR_TIMES_SET)) {\n\t\tif (!inode_owner_or_capable(inode))\n\t\t\treturn -EPERM;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include <linux/ima.h>",
            "#include <linux/evm.h>",
            "#include <linux/security.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/capability.h>",
            "#include <linux/string.h>",
            "#include <linux/mm.h>",
            "#include <linux/time.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ima.h>\n#include <linux/evm.h>\n#include <linux/security.h>\n#include <linux/fcntl.h>\n#include <linux/fsnotify.h>\n#include <linux/capability.h>\n#include <linux/string.h>\n#include <linux/mm.h>\n#include <linux/time.h>\n#include <linux/export.h>\n\nint inode_change_ok(const struct inode *inode, struct iattr *attr)\n{\n\tunsigned int ia_valid = attr->ia_valid;\n\n\t/*\n\t * First check size constraints.  These can't be overriden using\n\t * ATTR_FORCE.\n\t */\n\tif (ia_valid & ATTR_SIZE) {\n\t\tint error = inode_newsize_ok(inode, attr->ia_size);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\n\t/* If force is set do it anyway. */\n\tif (ia_valid & ATTR_FORCE)\n\t\treturn 0;\n\n\t/* Make sure a caller can chown. */\n\tif ((ia_valid & ATTR_UID) &&\n\t    (!uid_eq(current_fsuid(), inode->i_uid) ||\n\t     !uid_eq(attr->ia_uid, inode->i_uid)) &&\n\t    !capable_wrt_inode_uidgid(inode, CAP_CHOWN))\n\t\treturn -EPERM;\n\n\t/* Make sure caller can chgrp. */\n\tif ((ia_valid & ATTR_GID) &&\n\t    (!uid_eq(current_fsuid(), inode->i_uid) ||\n\t    (!in_group_p(attr->ia_gid) && !gid_eq(attr->ia_gid, inode->i_gid))) &&\n\t    !capable_wrt_inode_uidgid(inode, CAP_CHOWN))\n\t\treturn -EPERM;\n\n\t/* Make sure a caller can chmod. */\n\tif (ia_valid & ATTR_MODE) {\n\t\tif (!inode_owner_or_capable(inode))\n\t\t\treturn -EPERM;\n\t\t/* Also check the setgid bit! */\n\t\tif (!in_group_p((ia_valid & ATTR_GID) ? attr->ia_gid :\n\t\t\t\tinode->i_gid) &&\n\t\t    !capable_wrt_inode_uidgid(inode, CAP_FSETID))\n\t\t\tattr->ia_mode &= ~S_ISGID;\n\t}\n\n\t/* Check for setting the inode time. */\n\tif (ia_valid & (ATTR_MTIME_SET | ATTR_ATIME_SET | ATTR_TIMES_SET)) {\n\t\tif (!inode_owner_or_capable(inode))\n\t\t\treturn -EPERM;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "HFS_SB",
          "args": [
            "inode->i_sb"
          ],
          "line": 604
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"btree.h\"\n#include \"hfs_fs.h\"\n#include <linux/aio.h>\n#include <linux/sched.h>\n#include <linux/mpage.h>\n#include <linux/pagemap.h>\n\n#define HFS_VALID_MODE_BITS  (S_IFREG | S_IFDIR | S_IRWXUGO)\n\nint hfs_inode_setattr(struct dentry *dentry, struct iattr * attr)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tstruct hfs_sb_info *hsb = HFS_SB(inode->i_sb);\n\tint error;\n\n\terror = inode_change_ok(inode, attr); /* basic permission checks */\n\tif (error)\n\t\treturn error;\n\n\t/* no uig/gid changes and limit which mode bits can be set */\n\tif (((attr->ia_valid & ATTR_UID) &&\n\t     (!uid_eq(attr->ia_uid, hsb->s_uid))) ||\n\t    ((attr->ia_valid & ATTR_GID) &&\n\t     (!gid_eq(attr->ia_gid, hsb->s_gid))) ||\n\t    ((attr->ia_valid & ATTR_MODE) &&\n\t     ((S_ISDIR(inode->i_mode) &&\n\t       (attr->ia_mode != inode->i_mode)) ||\n\t      (attr->ia_mode & ~HFS_VALID_MODE_BITS)))) {\n\t\treturn hsb->s_quiet ? 0 : error;\n\t}\n\n\tif (attr->ia_valid & ATTR_MODE) {\n\t\t/* Only the 'w' bits can ever change and only all together. */\n\t\tif (attr->ia_mode & S_IWUSR)\n\t\t\tattr->ia_mode = inode->i_mode | S_IWUGO;\n\t\telse\n\t\t\tattr->ia_mode = inode->i_mode & ~S_IWUGO;\n\t\tattr->ia_mode &= S_ISDIR(inode->i_mode) ? ~hsb->s_dir_umask: ~hsb->s_file_umask;\n\t}\n\n\tif ((attr->ia_valid & ATTR_SIZE) &&\n\t    attr->ia_size != i_size_read(inode)) {\n\t\tinode_dio_wait(inode);\n\n\t\terror = inode_newsize_ok(inode, attr->ia_size);\n\t\tif (error)\n\t\t\treturn error;\n\n\t\ttruncate_setsize(inode, attr->ia_size);\n\t\thfs_file_truncate(inode);\n\t}\n\n\tsetattr_copy(inode, attr);\n\tmark_inode_dirty(inode);\n\treturn 0;\n}"
  },
  {
    "function_name": "hfs_file_release",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfs/inode.c",
    "lines": "566-582",
    "snippet": "static int hfs_file_release(struct inode *inode, struct file *file)\n{\n\t//struct super_block *sb = inode->i_sb;\n\n\tif (HFS_IS_RSRC(inode))\n\t\tinode = HFS_I(inode)->rsrc_inode;\n\tif (atomic_dec_and_test(&HFS_I(inode)->opencnt)) {\n\t\tmutex_lock(&inode->i_mutex);\n\t\thfs_file_truncate(inode);\n\t\t//if (inode->i_flags & S_DEAD) {\n\t\t//\thfs_delete_cat(inode->i_ino, HFSPLUS_SB(sb).hidden_dir, NULL);\n\t\t//\thfs_delete_inode(inode);\n\t\t//}\n\t\tmutex_unlock(&inode->i_mutex);\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include \"btree.h\"",
      "#include \"hfs_fs.h\"",
      "#include <linux/aio.h>",
      "#include <linux/sched.h>",
      "#include <linux/mpage.h>",
      "#include <linux/pagemap.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&inode->i_mutex"
          ],
          "line": 579
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hfs_file_truncate",
          "args": [
            "inode"
          ],
          "line": 574
        },
        "resolved": true,
        "details": {
          "function_name": "hfs_file_truncate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfs/extent.c",
          "lines": "470-545",
          "snippet": "void hfs_file_truncate(struct inode *inode)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tstruct hfs_find_data fd;\n\tu16 blk_cnt, alloc_cnt, start;\n\tu32 size;\n\tint res;\n\n\thfs_dbg(INODE, \"truncate: %lu, %Lu -> %Lu\\n\",\n\t\tinode->i_ino, (long long)HFS_I(inode)->phys_size,\n\t\tinode->i_size);\n\tif (inode->i_size > HFS_I(inode)->phys_size) {\n\t\tstruct address_space *mapping = inode->i_mapping;\n\t\tvoid *fsdata;\n\t\tstruct page *page;\n\n\t\t/* XXX: Can use generic_cont_expand? */\n\t\tsize = inode->i_size - 1;\n\t\tres = pagecache_write_begin(NULL, mapping, size+1, 0,\n\t\t\t\tAOP_FLAG_UNINTERRUPTIBLE, &page, &fsdata);\n\t\tif (!res) {\n\t\t\tres = pagecache_write_end(NULL, mapping, size+1, 0, 0,\n\t\t\t\t\tpage, fsdata);\n\t\t}\n\t\tif (res)\n\t\t\tinode->i_size = HFS_I(inode)->phys_size;\n\t\treturn;\n\t} else if (inode->i_size == HFS_I(inode)->phys_size)\n\t\treturn;\n\tsize = inode->i_size + HFS_SB(sb)->alloc_blksz - 1;\n\tblk_cnt = size / HFS_SB(sb)->alloc_blksz;\n\talloc_cnt = HFS_I(inode)->alloc_blocks;\n\tif (blk_cnt == alloc_cnt)\n\t\tgoto out;\n\n\tmutex_lock(&HFS_I(inode)->extents_lock);\n\tres = hfs_find_init(HFS_SB(sb)->ext_tree, &fd);\n\tif (res) {\n\t\tmutex_unlock(&HFS_I(inode)->extents_lock);\n\t\t/* XXX: We lack error handling of hfs_file_truncate() */\n\t\treturn;\n\t}\n\twhile (1) {\n\t\tif (alloc_cnt == HFS_I(inode)->first_blocks) {\n\t\t\thfs_free_extents(sb, HFS_I(inode)->first_extents,\n\t\t\t\t\t alloc_cnt, alloc_cnt - blk_cnt);\n\t\t\thfs_dump_extent(HFS_I(inode)->first_extents);\n\t\t\tHFS_I(inode)->first_blocks = blk_cnt;\n\t\t\tbreak;\n\t\t}\n\t\tres = __hfs_ext_cache_extent(&fd, inode, alloc_cnt);\n\t\tif (res)\n\t\t\tbreak;\n\t\tstart = HFS_I(inode)->cached_start;\n\t\thfs_free_extents(sb, HFS_I(inode)->cached_extents,\n\t\t\t\t alloc_cnt - start, alloc_cnt - blk_cnt);\n\t\thfs_dump_extent(HFS_I(inode)->cached_extents);\n\t\tif (blk_cnt > start) {\n\t\t\tHFS_I(inode)->flags |= HFS_FLG_EXT_DIRTY;\n\t\t\tbreak;\n\t\t}\n\t\talloc_cnt = start;\n\t\tHFS_I(inode)->cached_start = HFS_I(inode)->cached_blocks = 0;\n\t\tHFS_I(inode)->flags &= ~(HFS_FLG_EXT_DIRTY|HFS_FLG_EXT_NEW);\n\t\thfs_brec_remove(&fd);\n\t}\n\thfs_find_exit(&fd);\n\tmutex_unlock(&HFS_I(inode)->extents_lock);\n\n\tHFS_I(inode)->alloc_blocks = blk_cnt;\nout:\n\tHFS_I(inode)->phys_size = inode->i_size;\n\tHFS_I(inode)->fs_blocks = (inode->i_size + sb->s_blocksize - 1) >> sb->s_blocksize_bits;\n\tinode_set_bytes(inode, HFS_I(inode)->fs_blocks << sb->s_blocksize_bits);\n\tmark_inode_dirty(inode);\n}",
          "includes": [
            "#include \"btree.h\"",
            "#include \"hfs_fs.h\"",
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"btree.h\"\n#include \"hfs_fs.h\"\n#include <linux/pagemap.h>\n\nvoid hfs_file_truncate(struct inode *inode)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tstruct hfs_find_data fd;\n\tu16 blk_cnt, alloc_cnt, start;\n\tu32 size;\n\tint res;\n\n\thfs_dbg(INODE, \"truncate: %lu, %Lu -> %Lu\\n\",\n\t\tinode->i_ino, (long long)HFS_I(inode)->phys_size,\n\t\tinode->i_size);\n\tif (inode->i_size > HFS_I(inode)->phys_size) {\n\t\tstruct address_space *mapping = inode->i_mapping;\n\t\tvoid *fsdata;\n\t\tstruct page *page;\n\n\t\t/* XXX: Can use generic_cont_expand? */\n\t\tsize = inode->i_size - 1;\n\t\tres = pagecache_write_begin(NULL, mapping, size+1, 0,\n\t\t\t\tAOP_FLAG_UNINTERRUPTIBLE, &page, &fsdata);\n\t\tif (!res) {\n\t\t\tres = pagecache_write_end(NULL, mapping, size+1, 0, 0,\n\t\t\t\t\tpage, fsdata);\n\t\t}\n\t\tif (res)\n\t\t\tinode->i_size = HFS_I(inode)->phys_size;\n\t\treturn;\n\t} else if (inode->i_size == HFS_I(inode)->phys_size)\n\t\treturn;\n\tsize = inode->i_size + HFS_SB(sb)->alloc_blksz - 1;\n\tblk_cnt = size / HFS_SB(sb)->alloc_blksz;\n\talloc_cnt = HFS_I(inode)->alloc_blocks;\n\tif (blk_cnt == alloc_cnt)\n\t\tgoto out;\n\n\tmutex_lock(&HFS_I(inode)->extents_lock);\n\tres = hfs_find_init(HFS_SB(sb)->ext_tree, &fd);\n\tif (res) {\n\t\tmutex_unlock(&HFS_I(inode)->extents_lock);\n\t\t/* XXX: We lack error handling of hfs_file_truncate() */\n\t\treturn;\n\t}\n\twhile (1) {\n\t\tif (alloc_cnt == HFS_I(inode)->first_blocks) {\n\t\t\thfs_free_extents(sb, HFS_I(inode)->first_extents,\n\t\t\t\t\t alloc_cnt, alloc_cnt - blk_cnt);\n\t\t\thfs_dump_extent(HFS_I(inode)->first_extents);\n\t\t\tHFS_I(inode)->first_blocks = blk_cnt;\n\t\t\tbreak;\n\t\t}\n\t\tres = __hfs_ext_cache_extent(&fd, inode, alloc_cnt);\n\t\tif (res)\n\t\t\tbreak;\n\t\tstart = HFS_I(inode)->cached_start;\n\t\thfs_free_extents(sb, HFS_I(inode)->cached_extents,\n\t\t\t\t alloc_cnt - start, alloc_cnt - blk_cnt);\n\t\thfs_dump_extent(HFS_I(inode)->cached_extents);\n\t\tif (blk_cnt > start) {\n\t\t\tHFS_I(inode)->flags |= HFS_FLG_EXT_DIRTY;\n\t\t\tbreak;\n\t\t}\n\t\talloc_cnt = start;\n\t\tHFS_I(inode)->cached_start = HFS_I(inode)->cached_blocks = 0;\n\t\tHFS_I(inode)->flags &= ~(HFS_FLG_EXT_DIRTY|HFS_FLG_EXT_NEW);\n\t\thfs_brec_remove(&fd);\n\t}\n\thfs_find_exit(&fd);\n\tmutex_unlock(&HFS_I(inode)->extents_lock);\n\n\tHFS_I(inode)->alloc_blocks = blk_cnt;\nout:\n\tHFS_I(inode)->phys_size = inode->i_size;\n\tHFS_I(inode)->fs_blocks = (inode->i_size + sb->s_blocksize - 1) >> sb->s_blocksize_bits;\n\tinode_set_bytes(inode, HFS_I(inode)->fs_blocks << sb->s_blocksize_bits);\n\tmark_inode_dirty(inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&inode->i_mutex"
          ],
          "line": 573
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_dec_and_test",
          "args": [
            "&HFS_I(inode)->opencnt"
          ],
          "line": 572
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HFS_I",
          "args": [
            "inode"
          ],
          "line": 572
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HFS_I",
          "args": [
            "inode"
          ],
          "line": 571
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HFS_IS_RSRC",
          "args": [
            "inode"
          ],
          "line": 570
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"btree.h\"\n#include \"hfs_fs.h\"\n#include <linux/aio.h>\n#include <linux/sched.h>\n#include <linux/mpage.h>\n#include <linux/pagemap.h>\n\nstatic int hfs_file_release(struct inode *inode, struct file *file)\n{\n\t//struct super_block *sb = inode->i_sb;\n\n\tif (HFS_IS_RSRC(inode))\n\t\tinode = HFS_I(inode)->rsrc_inode;\n\tif (atomic_dec_and_test(&HFS_I(inode)->opencnt)) {\n\t\tmutex_lock(&inode->i_mutex);\n\t\thfs_file_truncate(inode);\n\t\t//if (inode->i_flags & S_DEAD) {\n\t\t//\thfs_delete_cat(inode->i_ino, HFSPLUS_SB(sb).hidden_dir, NULL);\n\t\t//\thfs_delete_inode(inode);\n\t\t//}\n\t\tmutex_unlock(&inode->i_mutex);\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "hfs_file_open",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfs/inode.c",
    "lines": "558-564",
    "snippet": "static int hfs_file_open(struct inode *inode, struct file *file)\n{\n\tif (HFS_IS_RSRC(inode))\n\t\tinode = HFS_I(inode)->rsrc_inode;\n\tatomic_inc(&HFS_I(inode)->opencnt);\n\treturn 0;\n}",
    "includes": [
      "#include \"btree.h\"",
      "#include \"hfs_fs.h\"",
      "#include <linux/aio.h>",
      "#include <linux/sched.h>",
      "#include <linux/mpage.h>",
      "#include <linux/pagemap.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "atomic_inc",
          "args": [
            "&HFS_I(inode)->opencnt"
          ],
          "line": 562
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HFS_I",
          "args": [
            "inode"
          ],
          "line": 562
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HFS_I",
          "args": [
            "inode"
          ],
          "line": 561
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HFS_IS_RSRC",
          "args": [
            "inode"
          ],
          "line": 560
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"btree.h\"\n#include \"hfs_fs.h\"\n#include <linux/aio.h>\n#include <linux/sched.h>\n#include <linux/mpage.h>\n#include <linux/pagemap.h>\n\nstatic int hfs_file_open(struct inode *inode, struct file *file)\n{\n\tif (HFS_IS_RSRC(inode))\n\t\tinode = HFS_I(inode)->rsrc_inode;\n\tatomic_inc(&HFS_I(inode)->opencnt);\n\treturn 0;\n}"
  },
  {
    "function_name": "hfs_evict_inode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfs/inode.c",
    "lines": "548-556",
    "snippet": "void hfs_evict_inode(struct inode *inode)\n{\n\ttruncate_inode_pages_final(&inode->i_data);\n\tclear_inode(inode);\n\tif (HFS_IS_RSRC(inode) && HFS_I(inode)->rsrc_inode) {\n\t\tHFS_I(HFS_I(inode)->rsrc_inode)->rsrc_inode = NULL;\n\t\tiput(HFS_I(inode)->rsrc_inode);\n\t}\n}",
    "includes": [
      "#include \"btree.h\"",
      "#include \"hfs_fs.h\"",
      "#include <linux/aio.h>",
      "#include <linux/sched.h>",
      "#include <linux/mpage.h>",
      "#include <linux/pagemap.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "iput",
          "args": [
            "HFS_I(inode)->rsrc_inode"
          ],
          "line": 554
        },
        "resolved": true,
        "details": {
          "function_name": "iput",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "1471-1488",
          "snippet": "void iput(struct inode *inode)\n{\n\tif (!inode)\n\t\treturn;\n\tBUG_ON(inode->i_state & I_CLEAR);\nretry:\n\tif (atomic_dec_and_lock(&inode->i_count, &inode->i_lock)) {\n\t\tif (inode->i_nlink && (inode->i_state & I_DIRTY_TIME)) {\n\t\t\tatomic_inc(&inode->i_count);\n\t\t\tinode->i_state &= ~I_DIRTY_TIME;\n\t\t\tspin_unlock(&inode->i_lock);\n\t\t\ttrace_writeback_lazytime_iput(inode);\n\t\t\tmark_inode_dirty_sync(inode);\n\t\t\tgoto retry;\n\t\t}\n\t\tiput_final(inode);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid iput(struct inode *inode)\n{\n\tif (!inode)\n\t\treturn;\n\tBUG_ON(inode->i_state & I_CLEAR);\nretry:\n\tif (atomic_dec_and_lock(&inode->i_count, &inode->i_lock)) {\n\t\tif (inode->i_nlink && (inode->i_state & I_DIRTY_TIME)) {\n\t\t\tatomic_inc(&inode->i_count);\n\t\t\tinode->i_state &= ~I_DIRTY_TIME;\n\t\t\tspin_unlock(&inode->i_lock);\n\t\t\ttrace_writeback_lazytime_iput(inode);\n\t\t\tmark_inode_dirty_sync(inode);\n\t\t\tgoto retry;\n\t\t}\n\t\tiput_final(inode);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "HFS_I",
          "args": [
            "inode"
          ],
          "line": 554
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HFS_I",
          "args": [
            "HFS_I(inode)->rsrc_inode"
          ],
          "line": 553
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HFS_I",
          "args": [
            "inode"
          ],
          "line": 553
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HFS_I",
          "args": [
            "inode"
          ],
          "line": 552
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HFS_IS_RSRC",
          "args": [
            "inode"
          ],
          "line": 552
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clear_inode",
          "args": [
            "inode"
          ],
          "line": 551
        },
        "resolved": true,
        "details": {
          "function_name": "clear_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "488-505",
          "snippet": "void clear_inode(struct inode *inode)\n{\n\tmight_sleep();\n\t/*\n\t * We have to cycle tree_lock here because reclaim can be still in the\n\t * process of removing the last page (in __delete_from_page_cache())\n\t * and we must not free mapping under it.\n\t */\n\tspin_lock_irq(&inode->i_data.tree_lock);\n\tBUG_ON(inode->i_data.nrpages);\n\tBUG_ON(inode->i_data.nrshadows);\n\tspin_unlock_irq(&inode->i_data.tree_lock);\n\tBUG_ON(!list_empty(&inode->i_data.private_list));\n\tBUG_ON(!(inode->i_state & I_FREEING));\n\tBUG_ON(inode->i_state & I_CLEAR);\n\t/* don't need i_lock here, no concurrent mods to i_state */\n\tinode->i_state = I_FREEING | I_CLEAR;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid clear_inode(struct inode *inode)\n{\n\tmight_sleep();\n\t/*\n\t * We have to cycle tree_lock here because reclaim can be still in the\n\t * process of removing the last page (in __delete_from_page_cache())\n\t * and we must not free mapping under it.\n\t */\n\tspin_lock_irq(&inode->i_data.tree_lock);\n\tBUG_ON(inode->i_data.nrpages);\n\tBUG_ON(inode->i_data.nrshadows);\n\tspin_unlock_irq(&inode->i_data.tree_lock);\n\tBUG_ON(!list_empty(&inode->i_data.private_list));\n\tBUG_ON(!(inode->i_state & I_FREEING));\n\tBUG_ON(inode->i_state & I_CLEAR);\n\t/* don't need i_lock here, no concurrent mods to i_state */\n\tinode->i_state = I_FREEING | I_CLEAR;\n}"
        }
      },
      {
        "call_info": {
          "callee": "truncate_inode_pages_final",
          "args": [
            "&inode->i_data"
          ],
          "line": 550
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"btree.h\"\n#include \"hfs_fs.h\"\n#include <linux/aio.h>\n#include <linux/sched.h>\n#include <linux/mpage.h>\n#include <linux/pagemap.h>\n\nvoid hfs_evict_inode(struct inode *inode)\n{\n\ttruncate_inode_pages_final(&inode->i_data);\n\tclear_inode(inode);\n\tif (HFS_IS_RSRC(inode) && HFS_I(inode)->rsrc_inode) {\n\t\tHFS_I(HFS_I(inode)->rsrc_inode)->rsrc_inode = NULL;\n\t\tiput(HFS_I(inode)->rsrc_inode);\n\t}\n}"
  },
  {
    "function_name": "hfs_file_lookup",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfs/inode.c",
    "lines": "503-546",
    "snippet": "static struct dentry *hfs_file_lookup(struct inode *dir, struct dentry *dentry,\n\t\t\t\t      unsigned int flags)\n{\n\tstruct inode *inode = NULL;\n\thfs_cat_rec rec;\n\tstruct hfs_find_data fd;\n\tint res;\n\n\tif (HFS_IS_RSRC(dir) || strcmp(dentry->d_name.name, \"rsrc\"))\n\t\tgoto out;\n\n\tinode = HFS_I(dir)->rsrc_inode;\n\tif (inode)\n\t\tgoto out;\n\n\tinode = new_inode(dir->i_sb);\n\tif (!inode)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tres = hfs_find_init(HFS_SB(dir->i_sb)->cat_tree, &fd);\n\tif (res) {\n\t\tiput(inode);\n\t\treturn ERR_PTR(res);\n\t}\n\tfd.search_key->cat = HFS_I(dir)->cat_key;\n\tres = hfs_brec_read(&fd, &rec, sizeof(rec));\n\tif (!res) {\n\t\tstruct hfs_iget_data idata = { NULL, &rec };\n\t\thfs_read_inode(inode, &idata);\n\t}\n\thfs_find_exit(&fd);\n\tif (res) {\n\t\tiput(inode);\n\t\treturn ERR_PTR(res);\n\t}\n\tHFS_I(inode)->rsrc_inode = dir;\n\tHFS_I(dir)->rsrc_inode = inode;\n\tigrab(dir);\n\thlist_add_fake(&inode->i_hash);\n\tmark_inode_dirty(inode);\nout:\n\td_add(dentry, inode);\n\treturn NULL;\n}",
    "includes": [
      "#include \"btree.h\"",
      "#include \"hfs_fs.h\"",
      "#include <linux/aio.h>",
      "#include <linux/sched.h>",
      "#include <linux/mpage.h>",
      "#include <linux/pagemap.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "d_add",
          "args": [
            "dentry",
            "inode"
          ],
          "line": 544
        },
        "resolved": true,
        "details": {
          "function_name": "v9fs_fid_add",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/9p/fid.c",
          "lines": "49-54",
          "snippet": "void v9fs_fid_add(struct dentry *dentry, struct p9_fid *fid)\n{\n\tspin_lock(&dentry->d_lock);\n\t__add_fid(dentry, fid);\n\tspin_unlock(&dentry->d_lock);\n}",
          "includes": [
            "#include \"fid.h\"",
            "#include \"v9fs_vfs.h\"",
            "#include \"v9fs.h\"",
            "#include <net/9p/client.h>",
            "#include <net/9p/9p.h>",
            "#include <linux/idr.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/errno.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fid.h\"\n#include \"v9fs_vfs.h\"\n#include \"v9fs.h\"\n#include <net/9p/client.h>\n#include <net/9p/9p.h>\n#include <linux/idr.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <linux/module.h>\n\nvoid v9fs_fid_add(struct dentry *dentry, struct p9_fid *fid)\n{\n\tspin_lock(&dentry->d_lock);\n\t__add_fid(dentry, fid);\n\tspin_unlock(&dentry->d_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mark_inode_dirty",
          "args": [
            "inode"
          ],
          "line": 542
        },
        "resolved": true,
        "details": {
          "function_name": "block_dump___mark_inode_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fs-writeback.c",
          "lines": "1134-1154",
          "snippet": "static noinline void block_dump___mark_inode_dirty(struct inode *inode)\n{\n\tif (inode->i_ino || strcmp(inode->i_sb->s_id, \"bdev\")) {\n\t\tstruct dentry *dentry;\n\t\tconst char *name = \"?\";\n\n\t\tdentry = d_find_alias(inode);\n\t\tif (dentry) {\n\t\t\tspin_lock(&dentry->d_lock);\n\t\t\tname = (const char *) dentry->d_name.name;\n\t\t}\n\t\tprintk(KERN_DEBUG\n\t\t       \"%s(%d): dirtied inode %lu (%s) on %s\\n\",\n\t\t       current->comm, task_pid_nr(current), inode->i_ino,\n\t\t       name, inode->i_sb->s_id);\n\t\tif (dentry) {\n\t\t\tspin_unlock(&dentry->d_lock);\n\t\t\tdput(dentry);\n\t\t}\n\t}\n}",
          "includes": [
            "#include <trace/events/writeback.h>",
            "#include \"internal.h\"",
            "#include <linux/device.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/writeback.h>\n#include \"internal.h\"\n#include <linux/device.h>\n#include <linux/tracepoint.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nstatic noinline void block_dump___mark_inode_dirty(struct inode *inode)\n{\n\tif (inode->i_ino || strcmp(inode->i_sb->s_id, \"bdev\")) {\n\t\tstruct dentry *dentry;\n\t\tconst char *name = \"?\";\n\n\t\tdentry = d_find_alias(inode);\n\t\tif (dentry) {\n\t\t\tspin_lock(&dentry->d_lock);\n\t\t\tname = (const char *) dentry->d_name.name;\n\t\t}\n\t\tprintk(KERN_DEBUG\n\t\t       \"%s(%d): dirtied inode %lu (%s) on %s\\n\",\n\t\t       current->comm, task_pid_nr(current), inode->i_ino,\n\t\t       name, inode->i_sb->s_id);\n\t\tif (dentry) {\n\t\t\tspin_unlock(&dentry->d_lock);\n\t\t\tdput(dentry);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "hlist_add_fake",
          "args": [
            "&inode->i_hash"
          ],
          "line": 541
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "igrab",
          "args": [
            "dir"
          ],
          "line": 540
        },
        "resolved": true,
        "details": {
          "function_name": "igrab",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "1173-1189",
          "snippet": "struct inode *igrab(struct inode *inode)\n{\n\tspin_lock(&inode->i_lock);\n\tif (!(inode->i_state & (I_FREEING|I_WILL_FREE))) {\n\t\t__iget(inode);\n\t\tspin_unlock(&inode->i_lock);\n\t} else {\n\t\tspin_unlock(&inode->i_lock);\n\t\t/*\n\t\t * Handle the case where s_op->clear_inode is not been\n\t\t * called yet, and somebody is calling igrab\n\t\t * while the inode is getting freed.\n\t\t */\n\t\tinode = NULL;\n\t}\n\treturn inode;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nstruct inode *igrab(struct inode *inode)\n{\n\tspin_lock(&inode->i_lock);\n\tif (!(inode->i_state & (I_FREEING|I_WILL_FREE))) {\n\t\t__iget(inode);\n\t\tspin_unlock(&inode->i_lock);\n\t} else {\n\t\tspin_unlock(&inode->i_lock);\n\t\t/*\n\t\t * Handle the case where s_op->clear_inode is not been\n\t\t * called yet, and somebody is calling igrab\n\t\t * while the inode is getting freed.\n\t\t */\n\t\tinode = NULL;\n\t}\n\treturn inode;\n}"
        }
      },
      {
        "call_info": {
          "callee": "HFS_I",
          "args": [
            "dir"
          ],
          "line": 539
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HFS_I",
          "args": [
            "inode"
          ],
          "line": 538
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "res"
          ],
          "line": 536
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "iput",
          "args": [
            "inode"
          ],
          "line": 535
        },
        "resolved": true,
        "details": {
          "function_name": "iput",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "1471-1488",
          "snippet": "void iput(struct inode *inode)\n{\n\tif (!inode)\n\t\treturn;\n\tBUG_ON(inode->i_state & I_CLEAR);\nretry:\n\tif (atomic_dec_and_lock(&inode->i_count, &inode->i_lock)) {\n\t\tif (inode->i_nlink && (inode->i_state & I_DIRTY_TIME)) {\n\t\t\tatomic_inc(&inode->i_count);\n\t\t\tinode->i_state &= ~I_DIRTY_TIME;\n\t\t\tspin_unlock(&inode->i_lock);\n\t\t\ttrace_writeback_lazytime_iput(inode);\n\t\t\tmark_inode_dirty_sync(inode);\n\t\t\tgoto retry;\n\t\t}\n\t\tiput_final(inode);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid iput(struct inode *inode)\n{\n\tif (!inode)\n\t\treturn;\n\tBUG_ON(inode->i_state & I_CLEAR);\nretry:\n\tif (atomic_dec_and_lock(&inode->i_count, &inode->i_lock)) {\n\t\tif (inode->i_nlink && (inode->i_state & I_DIRTY_TIME)) {\n\t\t\tatomic_inc(&inode->i_count);\n\t\t\tinode->i_state &= ~I_DIRTY_TIME;\n\t\t\tspin_unlock(&inode->i_lock);\n\t\t\ttrace_writeback_lazytime_iput(inode);\n\t\t\tmark_inode_dirty_sync(inode);\n\t\t\tgoto retry;\n\t\t}\n\t\tiput_final(inode);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "hfs_find_exit",
          "args": [
            "&fd"
          ],
          "line": 533
        },
        "resolved": true,
        "details": {
          "function_name": "hfs_find_exit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfs/bfind.c",
          "lines": "31-39",
          "snippet": "void hfs_find_exit(struct hfs_find_data *fd)\n{\n\thfs_bnode_put(fd->bnode);\n\tkfree(fd->search_key);\n\thfs_dbg(BNODE_REFS, \"find_exit: %d (%p)\\n\",\n\t\tfd->tree->cnid, __builtin_return_address(0));\n\tmutex_unlock(&fd->tree->tree_lock);\n\tfd->tree = NULL;\n}",
          "includes": [
            "#include \"btree.h\"",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"btree.h\"\n#include <linux/slab.h>\n\nvoid hfs_find_exit(struct hfs_find_data *fd)\n{\n\thfs_bnode_put(fd->bnode);\n\tkfree(fd->search_key);\n\thfs_dbg(BNODE_REFS, \"find_exit: %d (%p)\\n\",\n\t\tfd->tree->cnid, __builtin_return_address(0));\n\tmutex_unlock(&fd->tree->tree_lock);\n\tfd->tree = NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "hfs_read_inode",
          "args": [
            "inode",
            "&idata"
          ],
          "line": 531
        },
        "resolved": true,
        "details": {
          "function_name": "hfs_read_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfs/inode.c",
          "lines": "311-370",
          "snippet": "static int hfs_read_inode(struct inode *inode, void *data)\n{\n\tstruct hfs_iget_data *idata = data;\n\tstruct hfs_sb_info *hsb = HFS_SB(inode->i_sb);\n\thfs_cat_rec *rec;\n\n\tHFS_I(inode)->flags = 0;\n\tHFS_I(inode)->rsrc_inode = NULL;\n\tmutex_init(&HFS_I(inode)->extents_lock);\n\tINIT_LIST_HEAD(&HFS_I(inode)->open_dir_list);\n\n\t/* Initialize the inode */\n\tinode->i_uid = hsb->s_uid;\n\tinode->i_gid = hsb->s_gid;\n\tset_nlink(inode, 1);\n\n\tif (idata->key)\n\t\tHFS_I(inode)->cat_key = *idata->key;\n\telse\n\t\tHFS_I(inode)->flags |= HFS_FLG_RSRC;\n\tHFS_I(inode)->tz_secondswest = sys_tz.tz_minuteswest * 60;\n\n\trec = idata->rec;\n\tswitch (rec->type) {\n\tcase HFS_CDR_FIL:\n\t\tif (!HFS_IS_RSRC(inode)) {\n\t\t\thfs_inode_read_fork(inode, rec->file.ExtRec, rec->file.LgLen,\n\t\t\t\t\t    rec->file.PyLen, be16_to_cpu(rec->file.ClpSize));\n\t\t} else {\n\t\t\thfs_inode_read_fork(inode, rec->file.RExtRec, rec->file.RLgLen,\n\t\t\t\t\t    rec->file.RPyLen, be16_to_cpu(rec->file.ClpSize));\n\t\t}\n\n\t\tinode->i_ino = be32_to_cpu(rec->file.FlNum);\n\t\tinode->i_mode = S_IRUGO | S_IXUGO;\n\t\tif (!(rec->file.Flags & HFS_FIL_LOCK))\n\t\t\tinode->i_mode |= S_IWUGO;\n\t\tinode->i_mode &= ~hsb->s_file_umask;\n\t\tinode->i_mode |= S_IFREG;\n\t\tinode->i_ctime = inode->i_atime = inode->i_mtime =\n\t\t\t\thfs_m_to_utime(rec->file.MdDat);\n\t\tinode->i_op = &hfs_file_inode_operations;\n\t\tinode->i_fop = &hfs_file_operations;\n\t\tinode->i_mapping->a_ops = &hfs_aops;\n\t\tbreak;\n\tcase HFS_CDR_DIR:\n\t\tinode->i_ino = be32_to_cpu(rec->dir.DirID);\n\t\tinode->i_size = be16_to_cpu(rec->dir.Val) + 2;\n\t\tHFS_I(inode)->fs_blocks = 0;\n\t\tinode->i_mode = S_IFDIR | (S_IRWXUGO & ~hsb->s_dir_umask);\n\t\tinode->i_ctime = inode->i_atime = inode->i_mtime =\n\t\t\t\thfs_m_to_utime(rec->dir.MdDat);\n\t\tinode->i_op = &hfs_dir_inode_operations;\n\t\tinode->i_fop = &hfs_dir_operations;\n\t\tbreak;\n\tdefault:\n\t\tmake_bad_inode(inode);\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"btree.h\"",
            "#include \"hfs_fs.h\"",
            "#include <linux/aio.h>",
            "#include <linux/sched.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct file_operations hfs_file_operations;",
            "static const struct inode_operations hfs_file_inode_operations;",
            "const struct address_space_operations hfs_aops = {\n\t.readpage\t= hfs_readpage,\n\t.writepage\t= hfs_writepage,\n\t.write_begin\t= hfs_write_begin,\n\t.write_end\t= generic_write_end,\n\t.bmap\t\t= hfs_bmap,\n\t.direct_IO\t= hfs_direct_IO,\n\t.writepages\t= hfs_writepages,\n};",
            "static const struct file_operations hfs_file_operations = {\n\t.llseek\t\t= generic_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= generic_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= generic_file_write_iter,\n\t.mmap\t\t= generic_file_mmap,\n\t.splice_read\t= generic_file_splice_read,\n\t.fsync\t\t= hfs_file_fsync,\n\t.open\t\t= hfs_file_open,\n\t.release\t= hfs_file_release,\n};",
            "static const struct inode_operations hfs_file_inode_operations = {\n\t.lookup\t\t= hfs_file_lookup,\n\t.setattr\t= hfs_inode_setattr,\n\t.setxattr\t= hfs_setxattr,\n\t.getxattr\t= hfs_getxattr,\n\t.listxattr\t= hfs_listxattr,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"btree.h\"\n#include \"hfs_fs.h\"\n#include <linux/aio.h>\n#include <linux/sched.h>\n#include <linux/mpage.h>\n#include <linux/pagemap.h>\n\nstatic const struct file_operations hfs_file_operations;\nstatic const struct inode_operations hfs_file_inode_operations;\nconst struct address_space_operations hfs_aops = {\n\t.readpage\t= hfs_readpage,\n\t.writepage\t= hfs_writepage,\n\t.write_begin\t= hfs_write_begin,\n\t.write_end\t= generic_write_end,\n\t.bmap\t\t= hfs_bmap,\n\t.direct_IO\t= hfs_direct_IO,\n\t.writepages\t= hfs_writepages,\n};\nstatic const struct file_operations hfs_file_operations = {\n\t.llseek\t\t= generic_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= generic_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= generic_file_write_iter,\n\t.mmap\t\t= generic_file_mmap,\n\t.splice_read\t= generic_file_splice_read,\n\t.fsync\t\t= hfs_file_fsync,\n\t.open\t\t= hfs_file_open,\n\t.release\t= hfs_file_release,\n};\nstatic const struct inode_operations hfs_file_inode_operations = {\n\t.lookup\t\t= hfs_file_lookup,\n\t.setattr\t= hfs_inode_setattr,\n\t.setxattr\t= hfs_setxattr,\n\t.getxattr\t= hfs_getxattr,\n\t.listxattr\t= hfs_listxattr,\n};\n\nstatic int hfs_read_inode(struct inode *inode, void *data)\n{\n\tstruct hfs_iget_data *idata = data;\n\tstruct hfs_sb_info *hsb = HFS_SB(inode->i_sb);\n\thfs_cat_rec *rec;\n\n\tHFS_I(inode)->flags = 0;\n\tHFS_I(inode)->rsrc_inode = NULL;\n\tmutex_init(&HFS_I(inode)->extents_lock);\n\tINIT_LIST_HEAD(&HFS_I(inode)->open_dir_list);\n\n\t/* Initialize the inode */\n\tinode->i_uid = hsb->s_uid;\n\tinode->i_gid = hsb->s_gid;\n\tset_nlink(inode, 1);\n\n\tif (idata->key)\n\t\tHFS_I(inode)->cat_key = *idata->key;\n\telse\n\t\tHFS_I(inode)->flags |= HFS_FLG_RSRC;\n\tHFS_I(inode)->tz_secondswest = sys_tz.tz_minuteswest * 60;\n\n\trec = idata->rec;\n\tswitch (rec->type) {\n\tcase HFS_CDR_FIL:\n\t\tif (!HFS_IS_RSRC(inode)) {\n\t\t\thfs_inode_read_fork(inode, rec->file.ExtRec, rec->file.LgLen,\n\t\t\t\t\t    rec->file.PyLen, be16_to_cpu(rec->file.ClpSize));\n\t\t} else {\n\t\t\thfs_inode_read_fork(inode, rec->file.RExtRec, rec->file.RLgLen,\n\t\t\t\t\t    rec->file.RPyLen, be16_to_cpu(rec->file.ClpSize));\n\t\t}\n\n\t\tinode->i_ino = be32_to_cpu(rec->file.FlNum);\n\t\tinode->i_mode = S_IRUGO | S_IXUGO;\n\t\tif (!(rec->file.Flags & HFS_FIL_LOCK))\n\t\t\tinode->i_mode |= S_IWUGO;\n\t\tinode->i_mode &= ~hsb->s_file_umask;\n\t\tinode->i_mode |= S_IFREG;\n\t\tinode->i_ctime = inode->i_atime = inode->i_mtime =\n\t\t\t\thfs_m_to_utime(rec->file.MdDat);\n\t\tinode->i_op = &hfs_file_inode_operations;\n\t\tinode->i_fop = &hfs_file_operations;\n\t\tinode->i_mapping->a_ops = &hfs_aops;\n\t\tbreak;\n\tcase HFS_CDR_DIR:\n\t\tinode->i_ino = be32_to_cpu(rec->dir.DirID);\n\t\tinode->i_size = be16_to_cpu(rec->dir.Val) + 2;\n\t\tHFS_I(inode)->fs_blocks = 0;\n\t\tinode->i_mode = S_IFDIR | (S_IRWXUGO & ~hsb->s_dir_umask);\n\t\tinode->i_ctime = inode->i_atime = inode->i_mtime =\n\t\t\t\thfs_m_to_utime(rec->dir.MdDat);\n\t\tinode->i_op = &hfs_dir_inode_operations;\n\t\tinode->i_fop = &hfs_dir_operations;\n\t\tbreak;\n\tdefault:\n\t\tmake_bad_inode(inode);\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "hfs_brec_read",
          "args": [
            "&fd",
            "&rec",
            "sizeof(rec)"
          ],
          "line": 528
        },
        "resolved": true,
        "details": {
          "function_name": "hfs_brec_read",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfs/bfind.c",
          "lines": "148-159",
          "snippet": "int hfs_brec_read(struct hfs_find_data *fd, void *rec, int rec_len)\n{\n\tint res;\n\n\tres = hfs_brec_find(fd);\n\tif (res)\n\t\treturn res;\n\tif (fd->entrylength > rec_len)\n\t\treturn -EINVAL;\n\thfs_bnode_read(fd->bnode, rec, fd->entryoffset, fd->entrylength);\n\treturn 0;\n}",
          "includes": [
            "#include \"btree.h\"",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"btree.h\"\n#include <linux/slab.h>\n\nint hfs_brec_read(struct hfs_find_data *fd, void *rec, int rec_len)\n{\n\tint res;\n\n\tres = hfs_brec_find(fd);\n\tif (res)\n\t\treturn res;\n\tif (fd->entrylength > rec_len)\n\t\treturn -EINVAL;\n\thfs_bnode_read(fd->bnode, rec, fd->entryoffset, fd->entrylength);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "HFS_I",
          "args": [
            "dir"
          ],
          "line": 527
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "res"
          ],
          "line": 525
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hfs_find_init",
          "args": [
            "HFS_SB(dir->i_sb)->cat_tree",
            "&fd"
          ],
          "line": 522
        },
        "resolved": true,
        "details": {
          "function_name": "hfs_find_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfs/bfind.c",
          "lines": "14-29",
          "snippet": "int hfs_find_init(struct hfs_btree *tree, struct hfs_find_data *fd)\n{\n\tvoid *ptr;\n\n\tfd->tree = tree;\n\tfd->bnode = NULL;\n\tptr = kmalloc(tree->max_key_len * 2 + 4, GFP_KERNEL);\n\tif (!ptr)\n\t\treturn -ENOMEM;\n\tfd->search_key = ptr;\n\tfd->key = ptr + tree->max_key_len + 2;\n\thfs_dbg(BNODE_REFS, \"find_init: %d (%p)\\n\",\n\t\ttree->cnid, __builtin_return_address(0));\n\tmutex_lock(&tree->tree_lock);\n\treturn 0;\n}",
          "includes": [
            "#include \"btree.h\"",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"btree.h\"\n#include <linux/slab.h>\n\nint hfs_find_init(struct hfs_btree *tree, struct hfs_find_data *fd)\n{\n\tvoid *ptr;\n\n\tfd->tree = tree;\n\tfd->bnode = NULL;\n\tptr = kmalloc(tree->max_key_len * 2 + 4, GFP_KERNEL);\n\tif (!ptr)\n\t\treturn -ENOMEM;\n\tfd->search_key = ptr;\n\tfd->key = ptr + tree->max_key_len + 2;\n\thfs_dbg(BNODE_REFS, \"find_init: %d (%p)\\n\",\n\t\ttree->cnid, __builtin_return_address(0));\n\tmutex_lock(&tree->tree_lock);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "HFS_SB",
          "args": [
            "dir->i_sb"
          ],
          "line": 522
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ENOMEM"
          ],
          "line": 520
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "new_inode",
          "args": [
            "dir->i_sb"
          ],
          "line": 518
        },
        "resolved": true,
        "details": {
          "function_name": "unlock_new_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "924-933",
          "snippet": "void unlock_new_inode(struct inode *inode)\n{\n\tlockdep_annotate_inode_mutex_key(inode);\n\tspin_lock(&inode->i_lock);\n\tWARN_ON(!(inode->i_state & I_NEW));\n\tinode->i_state &= ~I_NEW;\n\tsmp_mb();\n\twake_up_bit(&inode->i_state, __I_NEW);\n\tspin_unlock(&inode->i_lock);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid unlock_new_inode(struct inode *inode)\n{\n\tlockdep_annotate_inode_mutex_key(inode);\n\tspin_lock(&inode->i_lock);\n\tWARN_ON(!(inode->i_state & I_NEW));\n\tinode->i_state &= ~I_NEW;\n\tsmp_mb();\n\twake_up_bit(&inode->i_state, __I_NEW);\n\tspin_unlock(&inode->i_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "HFS_I",
          "args": [
            "dir"
          ],
          "line": 514
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "dentry->d_name.name",
            "\"rsrc\""
          ],
          "line": 511
        },
        "resolved": true,
        "details": {
          "function_name": "strcmp_prefix",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xattr.c",
          "lines": "667-675",
          "snippet": "static const char *\nstrcmp_prefix(const char *a, const char *a_prefix)\n{\n\twhile (*a_prefix && *a == *a_prefix) {\n\t\ta++;\n\t\ta_prefix++;\n\t}\n\treturn *a_prefix ? NULL : a;\n}",
          "includes": [
            "#include <asm/uaccess.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/audit.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/evm.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/xattr.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/vmalloc.h>\n#include <linux/audit.h>\n#include <linux/fsnotify.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n#include <linux/evm.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/xattr.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic const char *\nstrcmp_prefix(const char *a, const char *a_prefix)\n{\n\twhile (*a_prefix && *a == *a_prefix) {\n\t\ta++;\n\t\ta_prefix++;\n\t}\n\treturn *a_prefix ? NULL : a;\n}"
        }
      },
      {
        "call_info": {
          "callee": "HFS_IS_RSRC",
          "args": [
            "dir"
          ],
          "line": 511
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"btree.h\"\n#include \"hfs_fs.h\"\n#include <linux/aio.h>\n#include <linux/sched.h>\n#include <linux/mpage.h>\n#include <linux/pagemap.h>\n\nstatic struct dentry *hfs_file_lookup(struct inode *dir, struct dentry *dentry,\n\t\t\t\t      unsigned int flags)\n{\n\tstruct inode *inode = NULL;\n\thfs_cat_rec rec;\n\tstruct hfs_find_data fd;\n\tint res;\n\n\tif (HFS_IS_RSRC(dir) || strcmp(dentry->d_name.name, \"rsrc\"))\n\t\tgoto out;\n\n\tinode = HFS_I(dir)->rsrc_inode;\n\tif (inode)\n\t\tgoto out;\n\n\tinode = new_inode(dir->i_sb);\n\tif (!inode)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tres = hfs_find_init(HFS_SB(dir->i_sb)->cat_tree, &fd);\n\tif (res) {\n\t\tiput(inode);\n\t\treturn ERR_PTR(res);\n\t}\n\tfd.search_key->cat = HFS_I(dir)->cat_key;\n\tres = hfs_brec_read(&fd, &rec, sizeof(rec));\n\tif (!res) {\n\t\tstruct hfs_iget_data idata = { NULL, &rec };\n\t\thfs_read_inode(inode, &idata);\n\t}\n\thfs_find_exit(&fd);\n\tif (res) {\n\t\tiput(inode);\n\t\treturn ERR_PTR(res);\n\t}\n\tHFS_I(inode)->rsrc_inode = dir;\n\tHFS_I(dir)->rsrc_inode = inode;\n\tigrab(dir);\n\thlist_add_fake(&inode->i_hash);\n\tmark_inode_dirty(inode);\nout:\n\td_add(dentry, inode);\n\treturn NULL;\n}"
  },
  {
    "function_name": "hfs_write_inode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfs/inode.c",
    "lines": "415-501",
    "snippet": "int hfs_write_inode(struct inode *inode, struct writeback_control *wbc)\n{\n\tstruct inode *main_inode = inode;\n\tstruct hfs_find_data fd;\n\thfs_cat_rec rec;\n\tint res;\n\n\thfs_dbg(INODE, \"hfs_write_inode: %lu\\n\", inode->i_ino);\n\tres = hfs_ext_write_extent(inode);\n\tif (res)\n\t\treturn res;\n\n\tif (inode->i_ino < HFS_FIRSTUSER_CNID) {\n\t\tswitch (inode->i_ino) {\n\t\tcase HFS_ROOT_CNID:\n\t\t\tbreak;\n\t\tcase HFS_EXT_CNID:\n\t\t\thfs_btree_write(HFS_SB(inode->i_sb)->ext_tree);\n\t\t\treturn 0;\n\t\tcase HFS_CAT_CNID:\n\t\t\thfs_btree_write(HFS_SB(inode->i_sb)->cat_tree);\n\t\t\treturn 0;\n\t\tdefault:\n\t\t\tBUG();\n\t\t\treturn -EIO;\n\t\t}\n\t}\n\n\tif (HFS_IS_RSRC(inode))\n\t\tmain_inode = HFS_I(inode)->rsrc_inode;\n\n\tif (!main_inode->i_nlink)\n\t\treturn 0;\n\n\tif (hfs_find_init(HFS_SB(main_inode->i_sb)->cat_tree, &fd))\n\t\t/* panic? */\n\t\treturn -EIO;\n\n\tfd.search_key->cat = HFS_I(main_inode)->cat_key;\n\tif (hfs_brec_find(&fd))\n\t\t/* panic? */\n\t\tgoto out;\n\n\tif (S_ISDIR(main_inode->i_mode)) {\n\t\tif (fd.entrylength < sizeof(struct hfs_cat_dir))\n\t\t\t/* panic? */;\n\t\thfs_bnode_read(fd.bnode, &rec, fd.entryoffset,\n\t\t\t   sizeof(struct hfs_cat_dir));\n\t\tif (rec.type != HFS_CDR_DIR ||\n\t\t    be32_to_cpu(rec.dir.DirID) != inode->i_ino) {\n\t\t}\n\n\t\trec.dir.MdDat = hfs_u_to_mtime(inode->i_mtime);\n\t\trec.dir.Val = cpu_to_be16(inode->i_size - 2);\n\n\t\thfs_bnode_write(fd.bnode, &rec, fd.entryoffset,\n\t\t\t    sizeof(struct hfs_cat_dir));\n\t} else if (HFS_IS_RSRC(inode)) {\n\t\thfs_bnode_read(fd.bnode, &rec, fd.entryoffset,\n\t\t\t       sizeof(struct hfs_cat_file));\n\t\thfs_inode_write_fork(inode, rec.file.RExtRec,\n\t\t\t\t     &rec.file.RLgLen, &rec.file.RPyLen);\n\t\thfs_bnode_write(fd.bnode, &rec, fd.entryoffset,\n\t\t\t\tsizeof(struct hfs_cat_file));\n\t} else {\n\t\tif (fd.entrylength < sizeof(struct hfs_cat_file))\n\t\t\t/* panic? */;\n\t\thfs_bnode_read(fd.bnode, &rec, fd.entryoffset,\n\t\t\t   sizeof(struct hfs_cat_file));\n\t\tif (rec.type != HFS_CDR_FIL ||\n\t\t    be32_to_cpu(rec.file.FlNum) != inode->i_ino) {\n\t\t}\n\n\t\tif (inode->i_mode & S_IWUSR)\n\t\t\trec.file.Flags &= ~HFS_FIL_LOCK;\n\t\telse\n\t\t\trec.file.Flags |= HFS_FIL_LOCK;\n\t\thfs_inode_write_fork(inode, rec.file.ExtRec, &rec.file.LgLen, &rec.file.PyLen);\n\t\trec.file.MdDat = hfs_u_to_mtime(inode->i_mtime);\n\n\t\thfs_bnode_write(fd.bnode, &rec, fd.entryoffset,\n\t\t\t    sizeof(struct hfs_cat_file));\n\t}\nout:\n\thfs_find_exit(&fd);\n\treturn 0;\n}",
    "includes": [
      "#include \"btree.h\"",
      "#include \"hfs_fs.h\"",
      "#include <linux/aio.h>",
      "#include <linux/sched.h>",
      "#include <linux/mpage.h>",
      "#include <linux/pagemap.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "hfs_find_exit",
          "args": [
            "&fd"
          ],
          "line": 499
        },
        "resolved": true,
        "details": {
          "function_name": "hfs_find_exit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfs/bfind.c",
          "lines": "31-39",
          "snippet": "void hfs_find_exit(struct hfs_find_data *fd)\n{\n\thfs_bnode_put(fd->bnode);\n\tkfree(fd->search_key);\n\thfs_dbg(BNODE_REFS, \"find_exit: %d (%p)\\n\",\n\t\tfd->tree->cnid, __builtin_return_address(0));\n\tmutex_unlock(&fd->tree->tree_lock);\n\tfd->tree = NULL;\n}",
          "includes": [
            "#include \"btree.h\"",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"btree.h\"\n#include <linux/slab.h>\n\nvoid hfs_find_exit(struct hfs_find_data *fd)\n{\n\thfs_bnode_put(fd->bnode);\n\tkfree(fd->search_key);\n\thfs_dbg(BNODE_REFS, \"find_exit: %d (%p)\\n\",\n\t\tfd->tree->cnid, __builtin_return_address(0));\n\tmutex_unlock(&fd->tree->tree_lock);\n\tfd->tree = NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "hfs_bnode_write",
          "args": [
            "fd.bnode",
            "&rec",
            "fd.entryoffset",
            "sizeof(struct hfs_cat_file)"
          ],
          "line": 495
        },
        "resolved": true,
        "details": {
          "function_name": "hfs_bnode_write",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfs/bnode.c",
          "lines": "60-70",
          "snippet": "void hfs_bnode_write(struct hfs_bnode *node, void *buf, int off, int len)\n{\n\tstruct page *page;\n\n\toff += node->page_offset;\n\tpage = node->page[0];\n\n\tmemcpy(kmap(page) + off, buf, len);\n\tkunmap(page);\n\tset_page_dirty(page);\n}",
          "includes": [
            "#include \"btree.h\"",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"btree.h\"\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n\nvoid hfs_bnode_write(struct hfs_bnode *node, void *buf, int off, int len)\n{\n\tstruct page *page;\n\n\toff += node->page_offset;\n\tpage = node->page[0];\n\n\tmemcpy(kmap(page) + off, buf, len);\n\tkunmap(page);\n\tset_page_dirty(page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "hfs_u_to_mtime",
          "args": [
            "inode->i_mtime"
          ],
          "line": 493
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hfs_inode_write_fork",
          "args": [
            "inode",
            "rec.file.ExtRec",
            "&rec.file.LgLen",
            "&rec.file.PyLen"
          ],
          "line": 492
        },
        "resolved": true,
        "details": {
          "function_name": "hfs_inode_write_fork",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfs/inode.c",
          "lines": "403-413",
          "snippet": "void hfs_inode_write_fork(struct inode *inode, struct hfs_extent *ext,\n\t\t\t  __be32 *log_size, __be32 *phys_size)\n{\n\tmemcpy(ext, HFS_I(inode)->first_extents, sizeof(hfs_extent_rec));\n\n\tif (log_size)\n\t\t*log_size = cpu_to_be32(inode->i_size);\n\tif (phys_size)\n\t\t*phys_size = cpu_to_be32(HFS_I(inode)->alloc_blocks *\n\t\t\t\t\t HFS_SB(inode->i_sb)->alloc_blksz);\n}",
          "includes": [
            "#include \"btree.h\"",
            "#include \"hfs_fs.h\"",
            "#include <linux/aio.h>",
            "#include <linux/sched.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"btree.h\"\n#include \"hfs_fs.h\"\n#include <linux/aio.h>\n#include <linux/sched.h>\n#include <linux/mpage.h>\n#include <linux/pagemap.h>\n\nvoid hfs_inode_write_fork(struct inode *inode, struct hfs_extent *ext,\n\t\t\t  __be32 *log_size, __be32 *phys_size)\n{\n\tmemcpy(ext, HFS_I(inode)->first_extents, sizeof(hfs_extent_rec));\n\n\tif (log_size)\n\t\t*log_size = cpu_to_be32(inode->i_size);\n\tif (phys_size)\n\t\t*phys_size = cpu_to_be32(HFS_I(inode)->alloc_blocks *\n\t\t\t\t\t HFS_SB(inode->i_sb)->alloc_blksz);\n}"
        }
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "rec.file.FlNum"
          ],
          "line": 485
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hfs_bnode_read",
          "args": [
            "fd.bnode",
            "&rec",
            "fd.entryoffset",
            "sizeof(struct hfs_cat_file)"
          ],
          "line": 482
        },
        "resolved": true,
        "details": {
          "function_name": "hfs_bnode_read",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfs/bnode.c",
          "lines": "17-27",
          "snippet": "void hfs_bnode_read(struct hfs_bnode *node, void *buf,\n\t\tint off, int len)\n{\n\tstruct page *page;\n\n\toff += node->page_offset;\n\tpage = node->page[0];\n\n\tmemcpy(buf, kmap(page) + off, len);\n\tkunmap(page);\n}",
          "includes": [
            "#include \"btree.h\"",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"btree.h\"\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n\nvoid hfs_bnode_read(struct hfs_bnode *node, void *buf,\n\t\tint off, int len)\n{\n\tstruct page *page;\n\n\toff += node->page_offset;\n\tpage = node->page[0];\n\n\tmemcpy(buf, kmap(page) + off, len);\n\tkunmap(page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "HFS_IS_RSRC",
          "args": [
            "inode"
          ],
          "line": 472
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be16",
          "args": [
            "inode->i_size - 2"
          ],
          "line": 468
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hfs_u_to_mtime",
          "args": [
            "inode->i_mtime"
          ],
          "line": 467
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "rec.dir.DirID"
          ],
          "line": 464
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISDIR",
          "args": [
            "main_inode->i_mode"
          ],
          "line": 458
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hfs_brec_find",
          "args": [
            "&fd"
          ],
          "line": 454
        },
        "resolved": true,
        "details": {
          "function_name": "hfs_brec_find",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfs/bfind.c",
          "lines": "94-146",
          "snippet": "int hfs_brec_find(struct hfs_find_data *fd)\n{\n\tstruct hfs_btree *tree;\n\tstruct hfs_bnode *bnode;\n\tu32 nidx, parent;\n\t__be32 data;\n\tint height, res;\n\n\ttree = fd->tree;\n\tif (fd->bnode)\n\t\thfs_bnode_put(fd->bnode);\n\tfd->bnode = NULL;\n\tnidx = tree->root;\n\tif (!nidx)\n\t\treturn -ENOENT;\n\theight = tree->depth;\n\tres = 0;\n\tparent = 0;\n\tfor (;;) {\n\t\tbnode = hfs_bnode_find(tree, nidx);\n\t\tif (IS_ERR(bnode)) {\n\t\t\tres = PTR_ERR(bnode);\n\t\t\tbnode = NULL;\n\t\t\tbreak;\n\t\t}\n\t\tif (bnode->height != height)\n\t\t\tgoto invalid;\n\t\tif (bnode->type != (--height ? HFS_NODE_INDEX : HFS_NODE_LEAF))\n\t\t\tgoto invalid;\n\t\tbnode->parent = parent;\n\n\t\tres = __hfs_brec_find(bnode, fd);\n\t\tif (!height)\n\t\t\tbreak;\n\t\tif (fd->record < 0)\n\t\t\tgoto release;\n\n\t\tparent = nidx;\n\t\thfs_bnode_read(bnode, &data, fd->entryoffset, 4);\n\t\tnidx = be32_to_cpu(data);\n\t\thfs_bnode_put(bnode);\n\t}\n\tfd->bnode = bnode;\n\treturn res;\n\ninvalid:\n\tpr_err(\"inconsistency in B*Tree (%d,%d,%d,%u,%u)\\n\",\n\t       height, bnode->height, bnode->type, nidx, parent);\n\tres = -EIO;\nrelease:\n\thfs_bnode_put(bnode);\n\treturn res;\n}",
          "includes": [
            "#include \"btree.h\"",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"btree.h\"\n#include <linux/slab.h>\n\nint hfs_brec_find(struct hfs_find_data *fd)\n{\n\tstruct hfs_btree *tree;\n\tstruct hfs_bnode *bnode;\n\tu32 nidx, parent;\n\t__be32 data;\n\tint height, res;\n\n\ttree = fd->tree;\n\tif (fd->bnode)\n\t\thfs_bnode_put(fd->bnode);\n\tfd->bnode = NULL;\n\tnidx = tree->root;\n\tif (!nidx)\n\t\treturn -ENOENT;\n\theight = tree->depth;\n\tres = 0;\n\tparent = 0;\n\tfor (;;) {\n\t\tbnode = hfs_bnode_find(tree, nidx);\n\t\tif (IS_ERR(bnode)) {\n\t\t\tres = PTR_ERR(bnode);\n\t\t\tbnode = NULL;\n\t\t\tbreak;\n\t\t}\n\t\tif (bnode->height != height)\n\t\t\tgoto invalid;\n\t\tif (bnode->type != (--height ? HFS_NODE_INDEX : HFS_NODE_LEAF))\n\t\t\tgoto invalid;\n\t\tbnode->parent = parent;\n\n\t\tres = __hfs_brec_find(bnode, fd);\n\t\tif (!height)\n\t\t\tbreak;\n\t\tif (fd->record < 0)\n\t\t\tgoto release;\n\n\t\tparent = nidx;\n\t\thfs_bnode_read(bnode, &data, fd->entryoffset, 4);\n\t\tnidx = be32_to_cpu(data);\n\t\thfs_bnode_put(bnode);\n\t}\n\tfd->bnode = bnode;\n\treturn res;\n\ninvalid:\n\tpr_err(\"inconsistency in B*Tree (%d,%d,%d,%u,%u)\\n\",\n\t       height, bnode->height, bnode->type, nidx, parent);\n\tres = -EIO;\nrelease:\n\thfs_bnode_put(bnode);\n\treturn res;\n}"
        }
      },
      {
        "call_info": {
          "callee": "HFS_I",
          "args": [
            "main_inode"
          ],
          "line": 453
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hfs_find_init",
          "args": [
            "HFS_SB(main_inode->i_sb)->cat_tree",
            "&fd"
          ],
          "line": 449
        },
        "resolved": true,
        "details": {
          "function_name": "hfs_find_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfs/bfind.c",
          "lines": "14-29",
          "snippet": "int hfs_find_init(struct hfs_btree *tree, struct hfs_find_data *fd)\n{\n\tvoid *ptr;\n\n\tfd->tree = tree;\n\tfd->bnode = NULL;\n\tptr = kmalloc(tree->max_key_len * 2 + 4, GFP_KERNEL);\n\tif (!ptr)\n\t\treturn -ENOMEM;\n\tfd->search_key = ptr;\n\tfd->key = ptr + tree->max_key_len + 2;\n\thfs_dbg(BNODE_REFS, \"find_init: %d (%p)\\n\",\n\t\ttree->cnid, __builtin_return_address(0));\n\tmutex_lock(&tree->tree_lock);\n\treturn 0;\n}",
          "includes": [
            "#include \"btree.h\"",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"btree.h\"\n#include <linux/slab.h>\n\nint hfs_find_init(struct hfs_btree *tree, struct hfs_find_data *fd)\n{\n\tvoid *ptr;\n\n\tfd->tree = tree;\n\tfd->bnode = NULL;\n\tptr = kmalloc(tree->max_key_len * 2 + 4, GFP_KERNEL);\n\tif (!ptr)\n\t\treturn -ENOMEM;\n\tfd->search_key = ptr;\n\tfd->key = ptr + tree->max_key_len + 2;\n\thfs_dbg(BNODE_REFS, \"find_init: %d (%p)\\n\",\n\t\ttree->cnid, __builtin_return_address(0));\n\tmutex_lock(&tree->tree_lock);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "HFS_SB",
          "args": [
            "main_inode->i_sb"
          ],
          "line": 449
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HFS_I",
          "args": [
            "inode"
          ],
          "line": 444
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HFS_IS_RSRC",
          "args": [
            "inode"
          ],
          "line": 443
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG",
          "args": [],
          "line": 438
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hfs_btree_write",
          "args": [
            "HFS_SB(inode->i_sb)->cat_tree"
          ],
          "line": 435
        },
        "resolved": true,
        "details": {
          "function_name": "hfs_btree_write",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfs/btree.c",
          "lines": "159-185",
          "snippet": "void hfs_btree_write(struct hfs_btree *tree)\n{\n\tstruct hfs_btree_header_rec *head;\n\tstruct hfs_bnode *node;\n\tstruct page *page;\n\n\tnode = hfs_bnode_find(tree, 0);\n\tif (IS_ERR(node))\n\t\t/* panic? */\n\t\treturn;\n\t/* Load the header */\n\tpage = node->page[0];\n\thead = (struct hfs_btree_header_rec *)(kmap(page) + sizeof(struct hfs_bnode_desc));\n\n\thead->root = cpu_to_be32(tree->root);\n\thead->leaf_count = cpu_to_be32(tree->leaf_count);\n\thead->leaf_head = cpu_to_be32(tree->leaf_head);\n\thead->leaf_tail = cpu_to_be32(tree->leaf_tail);\n\thead->node_count = cpu_to_be32(tree->node_count);\n\thead->free_nodes = cpu_to_be32(tree->free_nodes);\n\thead->attributes = cpu_to_be32(tree->attributes);\n\thead->depth = cpu_to_be16(tree->depth);\n\n\tkunmap(page);\n\tset_page_dirty(page);\n\thfs_bnode_put(node);\n}",
          "includes": [
            "#include \"btree.h\"",
            "#include <linux/log2.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"btree.h\"\n#include <linux/log2.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n\nvoid hfs_btree_write(struct hfs_btree *tree)\n{\n\tstruct hfs_btree_header_rec *head;\n\tstruct hfs_bnode *node;\n\tstruct page *page;\n\n\tnode = hfs_bnode_find(tree, 0);\n\tif (IS_ERR(node))\n\t\t/* panic? */\n\t\treturn;\n\t/* Load the header */\n\tpage = node->page[0];\n\thead = (struct hfs_btree_header_rec *)(kmap(page) + sizeof(struct hfs_bnode_desc));\n\n\thead->root = cpu_to_be32(tree->root);\n\thead->leaf_count = cpu_to_be32(tree->leaf_count);\n\thead->leaf_head = cpu_to_be32(tree->leaf_head);\n\thead->leaf_tail = cpu_to_be32(tree->leaf_tail);\n\thead->node_count = cpu_to_be32(tree->node_count);\n\thead->free_nodes = cpu_to_be32(tree->free_nodes);\n\thead->attributes = cpu_to_be32(tree->attributes);\n\thead->depth = cpu_to_be16(tree->depth);\n\n\tkunmap(page);\n\tset_page_dirty(page);\n\thfs_bnode_put(node);\n}"
        }
      },
      {
        "call_info": {
          "callee": "HFS_SB",
          "args": [
            "inode->i_sb"
          ],
          "line": 435
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HFS_SB",
          "args": [
            "inode->i_sb"
          ],
          "line": 432
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hfs_ext_write_extent",
          "args": [
            "inode"
          ],
          "line": 423
        },
        "resolved": true,
        "details": {
          "function_name": "hfs_ext_write_extent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfs/extent.c",
          "lines": "131-144",
          "snippet": "int hfs_ext_write_extent(struct inode *inode)\n{\n\tstruct hfs_find_data fd;\n\tint res = 0;\n\n\tif (HFS_I(inode)->flags & HFS_FLG_EXT_DIRTY) {\n\t\tres = hfs_find_init(HFS_SB(inode->i_sb)->ext_tree, &fd);\n\t\tif (res)\n\t\t\treturn res;\n\t\tres = __hfs_ext_write_extent(inode, &fd);\n\t\thfs_find_exit(&fd);\n\t}\n\treturn res;\n}",
          "includes": [
            "#include \"btree.h\"",
            "#include \"hfs_fs.h\"",
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"btree.h\"\n#include \"hfs_fs.h\"\n#include <linux/pagemap.h>\n\nint hfs_ext_write_extent(struct inode *inode)\n{\n\tstruct hfs_find_data fd;\n\tint res = 0;\n\n\tif (HFS_I(inode)->flags & HFS_FLG_EXT_DIRTY) {\n\t\tres = hfs_find_init(HFS_SB(inode->i_sb)->ext_tree, &fd);\n\t\tif (res)\n\t\t\treturn res;\n\t\tres = __hfs_ext_write_extent(inode, &fd);\n\t\thfs_find_exit(&fd);\n\t}\n\treturn res;\n}"
        }
      },
      {
        "call_info": {
          "callee": "hfs_dbg",
          "args": [
            "INODE",
            "\"hfs_write_inode: %lu\\n\"",
            "inode->i_ino"
          ],
          "line": 422
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"btree.h\"\n#include \"hfs_fs.h\"\n#include <linux/aio.h>\n#include <linux/sched.h>\n#include <linux/mpage.h>\n#include <linux/pagemap.h>\n\nint hfs_write_inode(struct inode *inode, struct writeback_control *wbc)\n{\n\tstruct inode *main_inode = inode;\n\tstruct hfs_find_data fd;\n\thfs_cat_rec rec;\n\tint res;\n\n\thfs_dbg(INODE, \"hfs_write_inode: %lu\\n\", inode->i_ino);\n\tres = hfs_ext_write_extent(inode);\n\tif (res)\n\t\treturn res;\n\n\tif (inode->i_ino < HFS_FIRSTUSER_CNID) {\n\t\tswitch (inode->i_ino) {\n\t\tcase HFS_ROOT_CNID:\n\t\t\tbreak;\n\t\tcase HFS_EXT_CNID:\n\t\t\thfs_btree_write(HFS_SB(inode->i_sb)->ext_tree);\n\t\t\treturn 0;\n\t\tcase HFS_CAT_CNID:\n\t\t\thfs_btree_write(HFS_SB(inode->i_sb)->cat_tree);\n\t\t\treturn 0;\n\t\tdefault:\n\t\t\tBUG();\n\t\t\treturn -EIO;\n\t\t}\n\t}\n\n\tif (HFS_IS_RSRC(inode))\n\t\tmain_inode = HFS_I(inode)->rsrc_inode;\n\n\tif (!main_inode->i_nlink)\n\t\treturn 0;\n\n\tif (hfs_find_init(HFS_SB(main_inode->i_sb)->cat_tree, &fd))\n\t\t/* panic? */\n\t\treturn -EIO;\n\n\tfd.search_key->cat = HFS_I(main_inode)->cat_key;\n\tif (hfs_brec_find(&fd))\n\t\t/* panic? */\n\t\tgoto out;\n\n\tif (S_ISDIR(main_inode->i_mode)) {\n\t\tif (fd.entrylength < sizeof(struct hfs_cat_dir))\n\t\t\t/* panic? */;\n\t\thfs_bnode_read(fd.bnode, &rec, fd.entryoffset,\n\t\t\t   sizeof(struct hfs_cat_dir));\n\t\tif (rec.type != HFS_CDR_DIR ||\n\t\t    be32_to_cpu(rec.dir.DirID) != inode->i_ino) {\n\t\t}\n\n\t\trec.dir.MdDat = hfs_u_to_mtime(inode->i_mtime);\n\t\trec.dir.Val = cpu_to_be16(inode->i_size - 2);\n\n\t\thfs_bnode_write(fd.bnode, &rec, fd.entryoffset,\n\t\t\t    sizeof(struct hfs_cat_dir));\n\t} else if (HFS_IS_RSRC(inode)) {\n\t\thfs_bnode_read(fd.bnode, &rec, fd.entryoffset,\n\t\t\t       sizeof(struct hfs_cat_file));\n\t\thfs_inode_write_fork(inode, rec.file.RExtRec,\n\t\t\t\t     &rec.file.RLgLen, &rec.file.RPyLen);\n\t\thfs_bnode_write(fd.bnode, &rec, fd.entryoffset,\n\t\t\t\tsizeof(struct hfs_cat_file));\n\t} else {\n\t\tif (fd.entrylength < sizeof(struct hfs_cat_file))\n\t\t\t/* panic? */;\n\t\thfs_bnode_read(fd.bnode, &rec, fd.entryoffset,\n\t\t\t   sizeof(struct hfs_cat_file));\n\t\tif (rec.type != HFS_CDR_FIL ||\n\t\t    be32_to_cpu(rec.file.FlNum) != inode->i_ino) {\n\t\t}\n\n\t\tif (inode->i_mode & S_IWUSR)\n\t\t\trec.file.Flags &= ~HFS_FIL_LOCK;\n\t\telse\n\t\t\trec.file.Flags |= HFS_FIL_LOCK;\n\t\thfs_inode_write_fork(inode, rec.file.ExtRec, &rec.file.LgLen, &rec.file.PyLen);\n\t\trec.file.MdDat = hfs_u_to_mtime(inode->i_mtime);\n\n\t\thfs_bnode_write(fd.bnode, &rec, fd.entryoffset,\n\t\t\t    sizeof(struct hfs_cat_file));\n\t}\nout:\n\thfs_find_exit(&fd);\n\treturn 0;\n}"
  },
  {
    "function_name": "hfs_inode_write_fork",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfs/inode.c",
    "lines": "403-413",
    "snippet": "void hfs_inode_write_fork(struct inode *inode, struct hfs_extent *ext,\n\t\t\t  __be32 *log_size, __be32 *phys_size)\n{\n\tmemcpy(ext, HFS_I(inode)->first_extents, sizeof(hfs_extent_rec));\n\n\tif (log_size)\n\t\t*log_size = cpu_to_be32(inode->i_size);\n\tif (phys_size)\n\t\t*phys_size = cpu_to_be32(HFS_I(inode)->alloc_blocks *\n\t\t\t\t\t HFS_SB(inode->i_sb)->alloc_blksz);\n}",
    "includes": [
      "#include \"btree.h\"",
      "#include \"hfs_fs.h\"",
      "#include <linux/aio.h>",
      "#include <linux/sched.h>",
      "#include <linux/mpage.h>",
      "#include <linux/pagemap.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "HFS_I(inode)->alloc_blocks *\n\t\t\t\t\t HFS_SB(inode->i_sb)->alloc_blksz"
          ],
          "line": 411
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HFS_SB",
          "args": [
            "inode->i_sb"
          ],
          "line": 412
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HFS_I",
          "args": [
            "inode"
          ],
          "line": 411
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "inode->i_size"
          ],
          "line": 409
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "ext",
            "HFS_I(inode)->first_extents",
            "sizeof(hfs_extent_rec)"
          ],
          "line": 406
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HFS_I",
          "args": [
            "inode"
          ],
          "line": 406
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"btree.h\"\n#include \"hfs_fs.h\"\n#include <linux/aio.h>\n#include <linux/sched.h>\n#include <linux/mpage.h>\n#include <linux/pagemap.h>\n\nvoid hfs_inode_write_fork(struct inode *inode, struct hfs_extent *ext,\n\t\t\t  __be32 *log_size, __be32 *phys_size)\n{\n\tmemcpy(ext, HFS_I(inode)->first_extents, sizeof(hfs_extent_rec));\n\n\tif (log_size)\n\t\t*log_size = cpu_to_be32(inode->i_size);\n\tif (phys_size)\n\t\t*phys_size = cpu_to_be32(HFS_I(inode)->alloc_blocks *\n\t\t\t\t\t HFS_SB(inode->i_sb)->alloc_blksz);\n}"
  },
  {
    "function_name": "hfs_iget",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfs/inode.c",
    "lines": "381-401",
    "snippet": "struct inode *hfs_iget(struct super_block *sb, struct hfs_cat_key *key, hfs_cat_rec *rec)\n{\n\tstruct hfs_iget_data data = { key, rec };\n\tstruct inode *inode;\n\tu32 cnid;\n\n\tswitch (rec->type) {\n\tcase HFS_CDR_DIR:\n\t\tcnid = be32_to_cpu(rec->dir.DirID);\n\t\tbreak;\n\tcase HFS_CDR_FIL:\n\t\tcnid = be32_to_cpu(rec->file.FlNum);\n\t\tbreak;\n\tdefault:\n\t\treturn NULL;\n\t}\n\tinode = iget5_locked(sb, cnid, hfs_test_inode, hfs_read_inode, &data);\n\tif (inode && (inode->i_state & I_NEW))\n\t\tunlock_new_inode(inode);\n\treturn inode;\n}",
    "includes": [
      "#include \"btree.h\"",
      "#include \"hfs_fs.h\"",
      "#include <linux/aio.h>",
      "#include <linux/sched.h>",
      "#include <linux/mpage.h>",
      "#include <linux/pagemap.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "unlock_new_inode",
          "args": [
            "inode"
          ],
          "line": 399
        },
        "resolved": true,
        "details": {
          "function_name": "unlock_new_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "924-933",
          "snippet": "void unlock_new_inode(struct inode *inode)\n{\n\tlockdep_annotate_inode_mutex_key(inode);\n\tspin_lock(&inode->i_lock);\n\tWARN_ON(!(inode->i_state & I_NEW));\n\tinode->i_state &= ~I_NEW;\n\tsmp_mb();\n\twake_up_bit(&inode->i_state, __I_NEW);\n\tspin_unlock(&inode->i_lock);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid unlock_new_inode(struct inode *inode)\n{\n\tlockdep_annotate_inode_mutex_key(inode);\n\tspin_lock(&inode->i_lock);\n\tWARN_ON(!(inode->i_state & I_NEW));\n\tinode->i_state &= ~I_NEW;\n\tsmp_mb();\n\twake_up_bit(&inode->i_state, __I_NEW);\n\tspin_unlock(&inode->i_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "iget5_locked",
          "args": [
            "sb",
            "cnid",
            "hfs_test_inode",
            "hfs_read_inode",
            "&data"
          ],
          "line": 397
        },
        "resolved": true,
        "details": {
          "function_name": "iget5_locked",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "991-1047",
          "snippet": "struct inode *iget5_locked(struct super_block *sb, unsigned long hashval,\n\t\tint (*test)(struct inode *, void *),\n\t\tint (*set)(struct inode *, void *), void *data)\n{\n\tstruct hlist_head *head = inode_hashtable + hash(sb, hashval);\n\tstruct inode *inode;\n\n\tspin_lock(&inode_hash_lock);\n\tinode = find_inode(sb, head, test, data);\n\tspin_unlock(&inode_hash_lock);\n\n\tif (inode) {\n\t\twait_on_inode(inode);\n\t\treturn inode;\n\t}\n\n\tinode = alloc_inode(sb);\n\tif (inode) {\n\t\tstruct inode *old;\n\n\t\tspin_lock(&inode_hash_lock);\n\t\t/* We released the lock, so.. */\n\t\told = find_inode(sb, head, test, data);\n\t\tif (!old) {\n\t\t\tif (set(inode, data))\n\t\t\t\tgoto set_failed;\n\n\t\t\tspin_lock(&inode->i_lock);\n\t\t\tinode->i_state = I_NEW;\n\t\t\thlist_add_head(&inode->i_hash, head);\n\t\t\tspin_unlock(&inode->i_lock);\n\t\t\tinode_sb_list_add(inode);\n\t\t\tspin_unlock(&inode_hash_lock);\n\n\t\t\t/* Return the locked inode with I_NEW set, the\n\t\t\t * caller is responsible for filling in the contents\n\t\t\t */\n\t\t\treturn inode;\n\t\t}\n\n\t\t/*\n\t\t * Uhhuh, somebody else created the same inode under\n\t\t * us. Use the old inode instead of the one we just\n\t\t * allocated.\n\t\t */\n\t\tspin_unlock(&inode_hash_lock);\n\t\tdestroy_inode(inode);\n\t\tinode = old;\n\t\twait_on_inode(inode);\n\t}\n\treturn inode;\n\nset_failed:\n\tspin_unlock(&inode_hash_lock);\n\tdestroy_inode(inode);\n\treturn NULL;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct hlist_head *inode_hashtable",
            "static __cacheline_aligned_in_smp DEFINE_SPINLOCK(inode_hash_lock);",
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic struct hlist_head *inode_hashtable;\nstatic __cacheline_aligned_in_smp DEFINE_SPINLOCK(inode_hash_lock);\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nstruct inode *iget5_locked(struct super_block *sb, unsigned long hashval,\n\t\tint (*test)(struct inode *, void *),\n\t\tint (*set)(struct inode *, void *), void *data)\n{\n\tstruct hlist_head *head = inode_hashtable + hash(sb, hashval);\n\tstruct inode *inode;\n\n\tspin_lock(&inode_hash_lock);\n\tinode = find_inode(sb, head, test, data);\n\tspin_unlock(&inode_hash_lock);\n\n\tif (inode) {\n\t\twait_on_inode(inode);\n\t\treturn inode;\n\t}\n\n\tinode = alloc_inode(sb);\n\tif (inode) {\n\t\tstruct inode *old;\n\n\t\tspin_lock(&inode_hash_lock);\n\t\t/* We released the lock, so.. */\n\t\told = find_inode(sb, head, test, data);\n\t\tif (!old) {\n\t\t\tif (set(inode, data))\n\t\t\t\tgoto set_failed;\n\n\t\t\tspin_lock(&inode->i_lock);\n\t\t\tinode->i_state = I_NEW;\n\t\t\thlist_add_head(&inode->i_hash, head);\n\t\t\tspin_unlock(&inode->i_lock);\n\t\t\tinode_sb_list_add(inode);\n\t\t\tspin_unlock(&inode_hash_lock);\n\n\t\t\t/* Return the locked inode with I_NEW set, the\n\t\t\t * caller is responsible for filling in the contents\n\t\t\t */\n\t\t\treturn inode;\n\t\t}\n\n\t\t/*\n\t\t * Uhhuh, somebody else created the same inode under\n\t\t * us. Use the old inode instead of the one we just\n\t\t * allocated.\n\t\t */\n\t\tspin_unlock(&inode_hash_lock);\n\t\tdestroy_inode(inode);\n\t\tinode = old;\n\t\twait_on_inode(inode);\n\t}\n\treturn inode;\n\nset_failed:\n\tspin_unlock(&inode_hash_lock);\n\tdestroy_inode(inode);\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "rec->file.FlNum"
          ],
          "line": 392
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "rec->dir.DirID"
          ],
          "line": 389
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"btree.h\"\n#include \"hfs_fs.h\"\n#include <linux/aio.h>\n#include <linux/sched.h>\n#include <linux/mpage.h>\n#include <linux/pagemap.h>\n\nstruct inode *hfs_iget(struct super_block *sb, struct hfs_cat_key *key, hfs_cat_rec *rec)\n{\n\tstruct hfs_iget_data data = { key, rec };\n\tstruct inode *inode;\n\tu32 cnid;\n\n\tswitch (rec->type) {\n\tcase HFS_CDR_DIR:\n\t\tcnid = be32_to_cpu(rec->dir.DirID);\n\t\tbreak;\n\tcase HFS_CDR_FIL:\n\t\tcnid = be32_to_cpu(rec->file.FlNum);\n\t\tbreak;\n\tdefault:\n\t\treturn NULL;\n\t}\n\tinode = iget5_locked(sb, cnid, hfs_test_inode, hfs_read_inode, &data);\n\tif (inode && (inode->i_state & I_NEW))\n\t\tunlock_new_inode(inode);\n\treturn inode;\n}"
  },
  {
    "function_name": "hfs_read_inode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfs/inode.c",
    "lines": "311-370",
    "snippet": "static int hfs_read_inode(struct inode *inode, void *data)\n{\n\tstruct hfs_iget_data *idata = data;\n\tstruct hfs_sb_info *hsb = HFS_SB(inode->i_sb);\n\thfs_cat_rec *rec;\n\n\tHFS_I(inode)->flags = 0;\n\tHFS_I(inode)->rsrc_inode = NULL;\n\tmutex_init(&HFS_I(inode)->extents_lock);\n\tINIT_LIST_HEAD(&HFS_I(inode)->open_dir_list);\n\n\t/* Initialize the inode */\n\tinode->i_uid = hsb->s_uid;\n\tinode->i_gid = hsb->s_gid;\n\tset_nlink(inode, 1);\n\n\tif (idata->key)\n\t\tHFS_I(inode)->cat_key = *idata->key;\n\telse\n\t\tHFS_I(inode)->flags |= HFS_FLG_RSRC;\n\tHFS_I(inode)->tz_secondswest = sys_tz.tz_minuteswest * 60;\n\n\trec = idata->rec;\n\tswitch (rec->type) {\n\tcase HFS_CDR_FIL:\n\t\tif (!HFS_IS_RSRC(inode)) {\n\t\t\thfs_inode_read_fork(inode, rec->file.ExtRec, rec->file.LgLen,\n\t\t\t\t\t    rec->file.PyLen, be16_to_cpu(rec->file.ClpSize));\n\t\t} else {\n\t\t\thfs_inode_read_fork(inode, rec->file.RExtRec, rec->file.RLgLen,\n\t\t\t\t\t    rec->file.RPyLen, be16_to_cpu(rec->file.ClpSize));\n\t\t}\n\n\t\tinode->i_ino = be32_to_cpu(rec->file.FlNum);\n\t\tinode->i_mode = S_IRUGO | S_IXUGO;\n\t\tif (!(rec->file.Flags & HFS_FIL_LOCK))\n\t\t\tinode->i_mode |= S_IWUGO;\n\t\tinode->i_mode &= ~hsb->s_file_umask;\n\t\tinode->i_mode |= S_IFREG;\n\t\tinode->i_ctime = inode->i_atime = inode->i_mtime =\n\t\t\t\thfs_m_to_utime(rec->file.MdDat);\n\t\tinode->i_op = &hfs_file_inode_operations;\n\t\tinode->i_fop = &hfs_file_operations;\n\t\tinode->i_mapping->a_ops = &hfs_aops;\n\t\tbreak;\n\tcase HFS_CDR_DIR:\n\t\tinode->i_ino = be32_to_cpu(rec->dir.DirID);\n\t\tinode->i_size = be16_to_cpu(rec->dir.Val) + 2;\n\t\tHFS_I(inode)->fs_blocks = 0;\n\t\tinode->i_mode = S_IFDIR | (S_IRWXUGO & ~hsb->s_dir_umask);\n\t\tinode->i_ctime = inode->i_atime = inode->i_mtime =\n\t\t\t\thfs_m_to_utime(rec->dir.MdDat);\n\t\tinode->i_op = &hfs_dir_inode_operations;\n\t\tinode->i_fop = &hfs_dir_operations;\n\t\tbreak;\n\tdefault:\n\t\tmake_bad_inode(inode);\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include \"btree.h\"",
      "#include \"hfs_fs.h\"",
      "#include <linux/aio.h>",
      "#include <linux/sched.h>",
      "#include <linux/mpage.h>",
      "#include <linux/pagemap.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static const struct file_operations hfs_file_operations;",
      "static const struct inode_operations hfs_file_inode_operations;",
      "const struct address_space_operations hfs_aops = {\n\t.readpage\t= hfs_readpage,\n\t.writepage\t= hfs_writepage,\n\t.write_begin\t= hfs_write_begin,\n\t.write_end\t= generic_write_end,\n\t.bmap\t\t= hfs_bmap,\n\t.direct_IO\t= hfs_direct_IO,\n\t.writepages\t= hfs_writepages,\n};",
      "static const struct file_operations hfs_file_operations = {\n\t.llseek\t\t= generic_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= generic_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= generic_file_write_iter,\n\t.mmap\t\t= generic_file_mmap,\n\t.splice_read\t= generic_file_splice_read,\n\t.fsync\t\t= hfs_file_fsync,\n\t.open\t\t= hfs_file_open,\n\t.release\t= hfs_file_release,\n};",
      "static const struct inode_operations hfs_file_inode_operations = {\n\t.lookup\t\t= hfs_file_lookup,\n\t.setattr\t= hfs_inode_setattr,\n\t.setxattr\t= hfs_setxattr,\n\t.getxattr\t= hfs_getxattr,\n\t.listxattr\t= hfs_listxattr,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "make_bad_inode",
          "args": [
            "inode"
          ],
          "line": 367
        },
        "resolved": true,
        "details": {
          "function_name": "reiserfs_make_bad_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/inode.c",
          "lines": "1520-1524",
          "snippet": "static void reiserfs_make_bad_inode(struct inode *inode)\n{\n\tmemset(INODE_PKEY(inode), 0, KEY_SIZE);\n\tmake_bad_inode(inode);\n}",
          "includes": [
            "#include <linux/aio.h>",
            "#include <linux/swap.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mpage.h>",
            "#include <linux/buffer_head.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/exportfs.h>",
            "#include \"xattr.h\"",
            "#include \"acl.h\"",
            "#include \"reiserfs.h\"",
            "#include <linux/fs.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/quotaops.h>\n#include <linux/writeback.h>\n#include <linux/mpage.h>\n#include <linux/buffer_head.h>\n#include <asm/unaligned.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/exportfs.h>\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"reiserfs.h\"\n#include <linux/fs.h>\n#include <linux/time.h>\n\nstatic void reiserfs_make_bad_inode(struct inode *inode)\n{\n\tmemset(INODE_PKEY(inode), 0, KEY_SIZE);\n\tmake_bad_inode(inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "hfs_m_to_utime",
          "args": [
            "rec->dir.MdDat"
          ],
          "line": 362
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HFS_I",
          "args": [
            "inode"
          ],
          "line": 359
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be16_to_cpu",
          "args": [
            "rec->dir.Val"
          ],
          "line": 358
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "rec->dir.DirID"
          ],
          "line": 357
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hfs_m_to_utime",
          "args": [
            "rec->file.MdDat"
          ],
          "line": 351
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "rec->file.FlNum"
          ],
          "line": 344
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hfs_inode_read_fork",
          "args": [
            "inode",
            "rec->file.RExtRec",
            "rec->file.RLgLen",
            "rec->file.RPyLen",
            "be16_to_cpu(rec->file.ClpSize)"
          ],
          "line": 340
        },
        "resolved": true,
        "details": {
          "function_name": "hfs_inode_read_fork",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfs/inode.c",
          "lines": "263-284",
          "snippet": "void hfs_inode_read_fork(struct inode *inode, struct hfs_extent *ext,\n\t\t\t __be32 __log_size, __be32 phys_size, u32 clump_size)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tu32 log_size = be32_to_cpu(__log_size);\n\tu16 count;\n\tint i;\n\n\tmemcpy(HFS_I(inode)->first_extents, ext, sizeof(hfs_extent_rec));\n\tfor (count = 0, i = 0; i < 3; i++)\n\t\tcount += be16_to_cpu(ext[i].count);\n\tHFS_I(inode)->first_blocks = count;\n\n\tinode->i_size = HFS_I(inode)->phys_size = log_size;\n\tHFS_I(inode)->fs_blocks = (log_size + sb->s_blocksize - 1) >> sb->s_blocksize_bits;\n\tinode_set_bytes(inode, HFS_I(inode)->fs_blocks << sb->s_blocksize_bits);\n\tHFS_I(inode)->alloc_blocks = be32_to_cpu(phys_size) /\n\t\t\t\t     HFS_SB(sb)->alloc_blksz;\n\tHFS_I(inode)->clump_blocks = clump_size / HFS_SB(sb)->alloc_blksz;\n\tif (!HFS_I(inode)->clump_blocks)\n\t\tHFS_I(inode)->clump_blocks = HFS_SB(sb)->clumpablks;\n}",
          "includes": [
            "#include \"btree.h\"",
            "#include \"hfs_fs.h\"",
            "#include <linux/aio.h>",
            "#include <linux/sched.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"btree.h\"\n#include \"hfs_fs.h\"\n#include <linux/aio.h>\n#include <linux/sched.h>\n#include <linux/mpage.h>\n#include <linux/pagemap.h>\n\nvoid hfs_inode_read_fork(struct inode *inode, struct hfs_extent *ext,\n\t\t\t __be32 __log_size, __be32 phys_size, u32 clump_size)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tu32 log_size = be32_to_cpu(__log_size);\n\tu16 count;\n\tint i;\n\n\tmemcpy(HFS_I(inode)->first_extents, ext, sizeof(hfs_extent_rec));\n\tfor (count = 0, i = 0; i < 3; i++)\n\t\tcount += be16_to_cpu(ext[i].count);\n\tHFS_I(inode)->first_blocks = count;\n\n\tinode->i_size = HFS_I(inode)->phys_size = log_size;\n\tHFS_I(inode)->fs_blocks = (log_size + sb->s_blocksize - 1) >> sb->s_blocksize_bits;\n\tinode_set_bytes(inode, HFS_I(inode)->fs_blocks << sb->s_blocksize_bits);\n\tHFS_I(inode)->alloc_blocks = be32_to_cpu(phys_size) /\n\t\t\t\t     HFS_SB(sb)->alloc_blksz;\n\tHFS_I(inode)->clump_blocks = clump_size / HFS_SB(sb)->alloc_blksz;\n\tif (!HFS_I(inode)->clump_blocks)\n\t\tHFS_I(inode)->clump_blocks = HFS_SB(sb)->clumpablks;\n}"
        }
      },
      {
        "call_info": {
          "callee": "be16_to_cpu",
          "args": [
            "rec->file.ClpSize"
          ],
          "line": 341
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be16_to_cpu",
          "args": [
            "rec->file.ClpSize"
          ],
          "line": 338
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HFS_IS_RSRC",
          "args": [
            "inode"
          ],
          "line": 336
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HFS_I",
          "args": [
            "inode"
          ],
          "line": 331
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HFS_I",
          "args": [
            "inode"
          ],
          "line": 330
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HFS_I",
          "args": [
            "inode"
          ],
          "line": 328
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_nlink",
          "args": [
            "inode",
            "1"
          ],
          "line": 325
        },
        "resolved": true,
        "details": {
          "function_name": "set_nlink",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "305-316",
          "snippet": "void set_nlink(struct inode *inode, unsigned int nlink)\n{\n\tif (!nlink) {\n\t\tclear_nlink(inode);\n\t} else {\n\t\t/* Yes, some filesystems do change nlink from zero to one */\n\t\tif (inode->i_nlink == 0)\n\t\t\tatomic_long_dec(&inode->i_sb->s_remove_count);\n\n\t\tinode->__i_nlink = nlink;\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid set_nlink(struct inode *inode, unsigned int nlink)\n{\n\tif (!nlink) {\n\t\tclear_nlink(inode);\n\t} else {\n\t\t/* Yes, some filesystems do change nlink from zero to one */\n\t\tif (inode->i_nlink == 0)\n\t\t\tatomic_long_dec(&inode->i_sb->s_remove_count);\n\n\t\tinode->__i_nlink = nlink;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&HFS_I(inode)->open_dir_list"
          ],
          "line": 320
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HFS_I",
          "args": [
            "inode"
          ],
          "line": 320
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_init",
          "args": [
            "&HFS_I(inode)->extents_lock"
          ],
          "line": 319
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HFS_I",
          "args": [
            "inode"
          ],
          "line": 319
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HFS_I",
          "args": [
            "inode"
          ],
          "line": 318
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HFS_I",
          "args": [
            "inode"
          ],
          "line": 317
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HFS_SB",
          "args": [
            "inode->i_sb"
          ],
          "line": 314
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"btree.h\"\n#include \"hfs_fs.h\"\n#include <linux/aio.h>\n#include <linux/sched.h>\n#include <linux/mpage.h>\n#include <linux/pagemap.h>\n\nstatic const struct file_operations hfs_file_operations;\nstatic const struct inode_operations hfs_file_inode_operations;\nconst struct address_space_operations hfs_aops = {\n\t.readpage\t= hfs_readpage,\n\t.writepage\t= hfs_writepage,\n\t.write_begin\t= hfs_write_begin,\n\t.write_end\t= generic_write_end,\n\t.bmap\t\t= hfs_bmap,\n\t.direct_IO\t= hfs_direct_IO,\n\t.writepages\t= hfs_writepages,\n};\nstatic const struct file_operations hfs_file_operations = {\n\t.llseek\t\t= generic_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= generic_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= generic_file_write_iter,\n\t.mmap\t\t= generic_file_mmap,\n\t.splice_read\t= generic_file_splice_read,\n\t.fsync\t\t= hfs_file_fsync,\n\t.open\t\t= hfs_file_open,\n\t.release\t= hfs_file_release,\n};\nstatic const struct inode_operations hfs_file_inode_operations = {\n\t.lookup\t\t= hfs_file_lookup,\n\t.setattr\t= hfs_inode_setattr,\n\t.setxattr\t= hfs_setxattr,\n\t.getxattr\t= hfs_getxattr,\n\t.listxattr\t= hfs_listxattr,\n};\n\nstatic int hfs_read_inode(struct inode *inode, void *data)\n{\n\tstruct hfs_iget_data *idata = data;\n\tstruct hfs_sb_info *hsb = HFS_SB(inode->i_sb);\n\thfs_cat_rec *rec;\n\n\tHFS_I(inode)->flags = 0;\n\tHFS_I(inode)->rsrc_inode = NULL;\n\tmutex_init(&HFS_I(inode)->extents_lock);\n\tINIT_LIST_HEAD(&HFS_I(inode)->open_dir_list);\n\n\t/* Initialize the inode */\n\tinode->i_uid = hsb->s_uid;\n\tinode->i_gid = hsb->s_gid;\n\tset_nlink(inode, 1);\n\n\tif (idata->key)\n\t\tHFS_I(inode)->cat_key = *idata->key;\n\telse\n\t\tHFS_I(inode)->flags |= HFS_FLG_RSRC;\n\tHFS_I(inode)->tz_secondswest = sys_tz.tz_minuteswest * 60;\n\n\trec = idata->rec;\n\tswitch (rec->type) {\n\tcase HFS_CDR_FIL:\n\t\tif (!HFS_IS_RSRC(inode)) {\n\t\t\thfs_inode_read_fork(inode, rec->file.ExtRec, rec->file.LgLen,\n\t\t\t\t\t    rec->file.PyLen, be16_to_cpu(rec->file.ClpSize));\n\t\t} else {\n\t\t\thfs_inode_read_fork(inode, rec->file.RExtRec, rec->file.RLgLen,\n\t\t\t\t\t    rec->file.RPyLen, be16_to_cpu(rec->file.ClpSize));\n\t\t}\n\n\t\tinode->i_ino = be32_to_cpu(rec->file.FlNum);\n\t\tinode->i_mode = S_IRUGO | S_IXUGO;\n\t\tif (!(rec->file.Flags & HFS_FIL_LOCK))\n\t\t\tinode->i_mode |= S_IWUGO;\n\t\tinode->i_mode &= ~hsb->s_file_umask;\n\t\tinode->i_mode |= S_IFREG;\n\t\tinode->i_ctime = inode->i_atime = inode->i_mtime =\n\t\t\t\thfs_m_to_utime(rec->file.MdDat);\n\t\tinode->i_op = &hfs_file_inode_operations;\n\t\tinode->i_fop = &hfs_file_operations;\n\t\tinode->i_mapping->a_ops = &hfs_aops;\n\t\tbreak;\n\tcase HFS_CDR_DIR:\n\t\tinode->i_ino = be32_to_cpu(rec->dir.DirID);\n\t\tinode->i_size = be16_to_cpu(rec->dir.Val) + 2;\n\t\tHFS_I(inode)->fs_blocks = 0;\n\t\tinode->i_mode = S_IFDIR | (S_IRWXUGO & ~hsb->s_dir_umask);\n\t\tinode->i_ctime = inode->i_atime = inode->i_mtime =\n\t\t\t\thfs_m_to_utime(rec->dir.MdDat);\n\t\tinode->i_op = &hfs_dir_inode_operations;\n\t\tinode->i_fop = &hfs_dir_operations;\n\t\tbreak;\n\tdefault:\n\t\tmake_bad_inode(inode);\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "hfs_test_inode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfs/inode.c",
    "lines": "291-306",
    "snippet": "static int hfs_test_inode(struct inode *inode, void *data)\n{\n\tstruct hfs_iget_data *idata = data;\n\thfs_cat_rec *rec;\n\n\trec = idata->rec;\n\tswitch (rec->type) {\n\tcase HFS_CDR_DIR:\n\t\treturn inode->i_ino == be32_to_cpu(rec->dir.DirID);\n\tcase HFS_CDR_FIL:\n\t\treturn inode->i_ino == be32_to_cpu(rec->file.FlNum);\n\tdefault:\n\t\tBUG();\n\t\treturn 1;\n\t}\n}",
    "includes": [
      "#include \"btree.h\"",
      "#include \"hfs_fs.h\"",
      "#include <linux/aio.h>",
      "#include <linux/sched.h>",
      "#include <linux/mpage.h>",
      "#include <linux/pagemap.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "BUG",
          "args": [],
          "line": 303
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "rec->file.FlNum"
          ],
          "line": 301
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "rec->dir.DirID"
          ],
          "line": 299
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"btree.h\"\n#include \"hfs_fs.h\"\n#include <linux/aio.h>\n#include <linux/sched.h>\n#include <linux/mpage.h>\n#include <linux/pagemap.h>\n\nstatic int hfs_test_inode(struct inode *inode, void *data)\n{\n\tstruct hfs_iget_data *idata = data;\n\thfs_cat_rec *rec;\n\n\trec = idata->rec;\n\tswitch (rec->type) {\n\tcase HFS_CDR_DIR:\n\t\treturn inode->i_ino == be32_to_cpu(rec->dir.DirID);\n\tcase HFS_CDR_FIL:\n\t\treturn inode->i_ino == be32_to_cpu(rec->file.FlNum);\n\tdefault:\n\t\tBUG();\n\t\treturn 1;\n\t}\n}"
  },
  {
    "function_name": "hfs_inode_read_fork",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfs/inode.c",
    "lines": "263-284",
    "snippet": "void hfs_inode_read_fork(struct inode *inode, struct hfs_extent *ext,\n\t\t\t __be32 __log_size, __be32 phys_size, u32 clump_size)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tu32 log_size = be32_to_cpu(__log_size);\n\tu16 count;\n\tint i;\n\n\tmemcpy(HFS_I(inode)->first_extents, ext, sizeof(hfs_extent_rec));\n\tfor (count = 0, i = 0; i < 3; i++)\n\t\tcount += be16_to_cpu(ext[i].count);\n\tHFS_I(inode)->first_blocks = count;\n\n\tinode->i_size = HFS_I(inode)->phys_size = log_size;\n\tHFS_I(inode)->fs_blocks = (log_size + sb->s_blocksize - 1) >> sb->s_blocksize_bits;\n\tinode_set_bytes(inode, HFS_I(inode)->fs_blocks << sb->s_blocksize_bits);\n\tHFS_I(inode)->alloc_blocks = be32_to_cpu(phys_size) /\n\t\t\t\t     HFS_SB(sb)->alloc_blksz;\n\tHFS_I(inode)->clump_blocks = clump_size / HFS_SB(sb)->alloc_blksz;\n\tif (!HFS_I(inode)->clump_blocks)\n\t\tHFS_I(inode)->clump_blocks = HFS_SB(sb)->clumpablks;\n}",
    "includes": [
      "#include \"btree.h\"",
      "#include \"hfs_fs.h\"",
      "#include <linux/aio.h>",
      "#include <linux/sched.h>",
      "#include <linux/mpage.h>",
      "#include <linux/pagemap.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "HFS_SB",
          "args": [
            "sb"
          ],
          "line": 283
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HFS_I",
          "args": [
            "inode"
          ],
          "line": 283
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HFS_I",
          "args": [
            "inode"
          ],
          "line": 282
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HFS_SB",
          "args": [
            "sb"
          ],
          "line": 281
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HFS_I",
          "args": [
            "inode"
          ],
          "line": 281
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HFS_SB",
          "args": [
            "sb"
          ],
          "line": 280
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "phys_size"
          ],
          "line": 279
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HFS_I",
          "args": [
            "inode"
          ],
          "line": 279
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "inode_set_bytes",
          "args": [
            "inode",
            "HFS_I(inode)->fs_blocks << sb->s_blocksize_bits"
          ],
          "line": 278
        },
        "resolved": true,
        "details": {
          "function_name": "inode_set_bytes",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/stat.c",
          "lines": "503-509",
          "snippet": "void inode_set_bytes(struct inode *inode, loff_t bytes)\n{\n\t/* Caller is here responsible for sufficient locking\n\t * (ie. inode->i_lock) */\n\tinode->i_blocks = bytes >> 9;\n\tinode->i_bytes = bytes & 511;\n}",
          "includes": [
            "#include <asm/unistd.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/highuid.h>",
            "#include <linux/file.h>",
            "#include <linux/errno.h>",
            "#include <linux/mm.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/unistd.h>\n#include <asm/uaccess.h>\n#include <linux/pagemap.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/highuid.h>\n#include <linux/file.h>\n#include <linux/errno.h>\n#include <linux/mm.h>\n#include <linux/export.h>\n\nvoid inode_set_bytes(struct inode *inode, loff_t bytes)\n{\n\t/* Caller is here responsible for sufficient locking\n\t * (ie. inode->i_lock) */\n\tinode->i_blocks = bytes >> 9;\n\tinode->i_bytes = bytes & 511;\n}"
        }
      },
      {
        "call_info": {
          "callee": "HFS_I",
          "args": [
            "inode"
          ],
          "line": 278
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HFS_I",
          "args": [
            "inode"
          ],
          "line": 277
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HFS_I",
          "args": [
            "inode"
          ],
          "line": 276
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HFS_I",
          "args": [
            "inode"
          ],
          "line": 274
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be16_to_cpu",
          "args": [
            "ext[i].count"
          ],
          "line": 273
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "HFS_I(inode)->first_extents",
            "ext",
            "sizeof(hfs_extent_rec)"
          ],
          "line": 271
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HFS_I",
          "args": [
            "inode"
          ],
          "line": 271
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "__log_size"
          ],
          "line": 267
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"btree.h\"\n#include \"hfs_fs.h\"\n#include <linux/aio.h>\n#include <linux/sched.h>\n#include <linux/mpage.h>\n#include <linux/pagemap.h>\n\nvoid hfs_inode_read_fork(struct inode *inode, struct hfs_extent *ext,\n\t\t\t __be32 __log_size, __be32 phys_size, u32 clump_size)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tu32 log_size = be32_to_cpu(__log_size);\n\tu16 count;\n\tint i;\n\n\tmemcpy(HFS_I(inode)->first_extents, ext, sizeof(hfs_extent_rec));\n\tfor (count = 0, i = 0; i < 3; i++)\n\t\tcount += be16_to_cpu(ext[i].count);\n\tHFS_I(inode)->first_blocks = count;\n\n\tinode->i_size = HFS_I(inode)->phys_size = log_size;\n\tHFS_I(inode)->fs_blocks = (log_size + sb->s_blocksize - 1) >> sb->s_blocksize_bits;\n\tinode_set_bytes(inode, HFS_I(inode)->fs_blocks << sb->s_blocksize_bits);\n\tHFS_I(inode)->alloc_blocks = be32_to_cpu(phys_size) /\n\t\t\t\t     HFS_SB(sb)->alloc_blksz;\n\tHFS_I(inode)->clump_blocks = clump_size / HFS_SB(sb)->alloc_blksz;\n\tif (!HFS_I(inode)->clump_blocks)\n\t\tHFS_I(inode)->clump_blocks = HFS_SB(sb)->clumpablks;\n}"
  },
  {
    "function_name": "hfs_delete_inode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfs/inode.c",
    "lines": "237-261",
    "snippet": "void hfs_delete_inode(struct inode *inode)\n{\n\tstruct super_block *sb = inode->i_sb;\n\n\thfs_dbg(INODE, \"delete_inode: %lu\\n\", inode->i_ino);\n\tif (S_ISDIR(inode->i_mode)) {\n\t\tHFS_SB(sb)->folder_count--;\n\t\tif (HFS_I(inode)->cat_key.ParID == cpu_to_be32(HFS_ROOT_CNID))\n\t\t\tHFS_SB(sb)->root_dirs--;\n\t\tset_bit(HFS_FLG_MDB_DIRTY, &HFS_SB(sb)->flags);\n\t\thfs_mark_mdb_dirty(sb);\n\t\treturn;\n\t}\n\tHFS_SB(sb)->file_count--;\n\tif (HFS_I(inode)->cat_key.ParID == cpu_to_be32(HFS_ROOT_CNID))\n\t\tHFS_SB(sb)->root_files--;\n\tif (S_ISREG(inode->i_mode)) {\n\t\tif (!inode->i_nlink) {\n\t\t\tinode->i_size = 0;\n\t\t\thfs_file_truncate(inode);\n\t\t}\n\t}\n\tset_bit(HFS_FLG_MDB_DIRTY, &HFS_SB(sb)->flags);\n\thfs_mark_mdb_dirty(sb);\n}",
    "includes": [
      "#include \"btree.h\"",
      "#include \"hfs_fs.h\"",
      "#include <linux/aio.h>",
      "#include <linux/sched.h>",
      "#include <linux/mpage.h>",
      "#include <linux/pagemap.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "hfs_mark_mdb_dirty",
          "args": [
            "sb"
          ],
          "line": 260
        },
        "resolved": true,
        "details": {
          "function_name": "hfs_mark_mdb_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfs/super.c",
          "lines": "68-83",
          "snippet": "void hfs_mark_mdb_dirty(struct super_block *sb)\n{\n\tstruct hfs_sb_info *sbi = HFS_SB(sb);\n\tunsigned long delay;\n\n\tif (sb->s_flags & MS_RDONLY)\n\t\treturn;\n\n\tspin_lock(&sbi->work_lock);\n\tif (!sbi->work_queued) {\n\t\tdelay = msecs_to_jiffies(dirty_writeback_interval * 10);\n\t\tqueue_delayed_work(system_long_wq, &sbi->mdb_work, delay);\n\t\tsbi->work_queued = 1;\n\t}\n\tspin_unlock(&sbi->work_lock);\n}",
          "includes": [
            "#include \"btree.h\"",
            "#include \"hfs_fs.h\"",
            "#include <linux/vfs.h>",
            "#include <linux/slab.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/parser.h>",
            "#include <linux/nls.h>",
            "#include <linux/init.h>",
            "#include <linux/mount.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"btree.h\"\n#include \"hfs_fs.h\"\n#include <linux/vfs.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/parser.h>\n#include <linux/nls.h>\n#include <linux/init.h>\n#include <linux/mount.h>\n#include <linux/blkdev.h>\n#include <linux/module.h>\n\nvoid hfs_mark_mdb_dirty(struct super_block *sb)\n{\n\tstruct hfs_sb_info *sbi = HFS_SB(sb);\n\tunsigned long delay;\n\n\tif (sb->s_flags & MS_RDONLY)\n\t\treturn;\n\n\tspin_lock(&sbi->work_lock);\n\tif (!sbi->work_queued) {\n\t\tdelay = msecs_to_jiffies(dirty_writeback_interval * 10);\n\t\tqueue_delayed_work(system_long_wq, &sbi->mdb_work, delay);\n\t\tsbi->work_queued = 1;\n\t}\n\tspin_unlock(&sbi->work_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_bit",
          "args": [
            "HFS_FLG_MDB_DIRTY",
            "&HFS_SB(sb)->flags"
          ],
          "line": 259
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_set_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "886-890",
          "snippet": "static inline void ocfs2_set_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_set_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline void ocfs2_set_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_set_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "HFS_SB",
          "args": [
            "sb"
          ],
          "line": 259
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hfs_file_truncate",
          "args": [
            "inode"
          ],
          "line": 256
        },
        "resolved": true,
        "details": {
          "function_name": "hfs_file_truncate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfs/extent.c",
          "lines": "470-545",
          "snippet": "void hfs_file_truncate(struct inode *inode)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tstruct hfs_find_data fd;\n\tu16 blk_cnt, alloc_cnt, start;\n\tu32 size;\n\tint res;\n\n\thfs_dbg(INODE, \"truncate: %lu, %Lu -> %Lu\\n\",\n\t\tinode->i_ino, (long long)HFS_I(inode)->phys_size,\n\t\tinode->i_size);\n\tif (inode->i_size > HFS_I(inode)->phys_size) {\n\t\tstruct address_space *mapping = inode->i_mapping;\n\t\tvoid *fsdata;\n\t\tstruct page *page;\n\n\t\t/* XXX: Can use generic_cont_expand? */\n\t\tsize = inode->i_size - 1;\n\t\tres = pagecache_write_begin(NULL, mapping, size+1, 0,\n\t\t\t\tAOP_FLAG_UNINTERRUPTIBLE, &page, &fsdata);\n\t\tif (!res) {\n\t\t\tres = pagecache_write_end(NULL, mapping, size+1, 0, 0,\n\t\t\t\t\tpage, fsdata);\n\t\t}\n\t\tif (res)\n\t\t\tinode->i_size = HFS_I(inode)->phys_size;\n\t\treturn;\n\t} else if (inode->i_size == HFS_I(inode)->phys_size)\n\t\treturn;\n\tsize = inode->i_size + HFS_SB(sb)->alloc_blksz - 1;\n\tblk_cnt = size / HFS_SB(sb)->alloc_blksz;\n\talloc_cnt = HFS_I(inode)->alloc_blocks;\n\tif (blk_cnt == alloc_cnt)\n\t\tgoto out;\n\n\tmutex_lock(&HFS_I(inode)->extents_lock);\n\tres = hfs_find_init(HFS_SB(sb)->ext_tree, &fd);\n\tif (res) {\n\t\tmutex_unlock(&HFS_I(inode)->extents_lock);\n\t\t/* XXX: We lack error handling of hfs_file_truncate() */\n\t\treturn;\n\t}\n\twhile (1) {\n\t\tif (alloc_cnt == HFS_I(inode)->first_blocks) {\n\t\t\thfs_free_extents(sb, HFS_I(inode)->first_extents,\n\t\t\t\t\t alloc_cnt, alloc_cnt - blk_cnt);\n\t\t\thfs_dump_extent(HFS_I(inode)->first_extents);\n\t\t\tHFS_I(inode)->first_blocks = blk_cnt;\n\t\t\tbreak;\n\t\t}\n\t\tres = __hfs_ext_cache_extent(&fd, inode, alloc_cnt);\n\t\tif (res)\n\t\t\tbreak;\n\t\tstart = HFS_I(inode)->cached_start;\n\t\thfs_free_extents(sb, HFS_I(inode)->cached_extents,\n\t\t\t\t alloc_cnt - start, alloc_cnt - blk_cnt);\n\t\thfs_dump_extent(HFS_I(inode)->cached_extents);\n\t\tif (blk_cnt > start) {\n\t\t\tHFS_I(inode)->flags |= HFS_FLG_EXT_DIRTY;\n\t\t\tbreak;\n\t\t}\n\t\talloc_cnt = start;\n\t\tHFS_I(inode)->cached_start = HFS_I(inode)->cached_blocks = 0;\n\t\tHFS_I(inode)->flags &= ~(HFS_FLG_EXT_DIRTY|HFS_FLG_EXT_NEW);\n\t\thfs_brec_remove(&fd);\n\t}\n\thfs_find_exit(&fd);\n\tmutex_unlock(&HFS_I(inode)->extents_lock);\n\n\tHFS_I(inode)->alloc_blocks = blk_cnt;\nout:\n\tHFS_I(inode)->phys_size = inode->i_size;\n\tHFS_I(inode)->fs_blocks = (inode->i_size + sb->s_blocksize - 1) >> sb->s_blocksize_bits;\n\tinode_set_bytes(inode, HFS_I(inode)->fs_blocks << sb->s_blocksize_bits);\n\tmark_inode_dirty(inode);\n}",
          "includes": [
            "#include \"btree.h\"",
            "#include \"hfs_fs.h\"",
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"btree.h\"\n#include \"hfs_fs.h\"\n#include <linux/pagemap.h>\n\nvoid hfs_file_truncate(struct inode *inode)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tstruct hfs_find_data fd;\n\tu16 blk_cnt, alloc_cnt, start;\n\tu32 size;\n\tint res;\n\n\thfs_dbg(INODE, \"truncate: %lu, %Lu -> %Lu\\n\",\n\t\tinode->i_ino, (long long)HFS_I(inode)->phys_size,\n\t\tinode->i_size);\n\tif (inode->i_size > HFS_I(inode)->phys_size) {\n\t\tstruct address_space *mapping = inode->i_mapping;\n\t\tvoid *fsdata;\n\t\tstruct page *page;\n\n\t\t/* XXX: Can use generic_cont_expand? */\n\t\tsize = inode->i_size - 1;\n\t\tres = pagecache_write_begin(NULL, mapping, size+1, 0,\n\t\t\t\tAOP_FLAG_UNINTERRUPTIBLE, &page, &fsdata);\n\t\tif (!res) {\n\t\t\tres = pagecache_write_end(NULL, mapping, size+1, 0, 0,\n\t\t\t\t\tpage, fsdata);\n\t\t}\n\t\tif (res)\n\t\t\tinode->i_size = HFS_I(inode)->phys_size;\n\t\treturn;\n\t} else if (inode->i_size == HFS_I(inode)->phys_size)\n\t\treturn;\n\tsize = inode->i_size + HFS_SB(sb)->alloc_blksz - 1;\n\tblk_cnt = size / HFS_SB(sb)->alloc_blksz;\n\talloc_cnt = HFS_I(inode)->alloc_blocks;\n\tif (blk_cnt == alloc_cnt)\n\t\tgoto out;\n\n\tmutex_lock(&HFS_I(inode)->extents_lock);\n\tres = hfs_find_init(HFS_SB(sb)->ext_tree, &fd);\n\tif (res) {\n\t\tmutex_unlock(&HFS_I(inode)->extents_lock);\n\t\t/* XXX: We lack error handling of hfs_file_truncate() */\n\t\treturn;\n\t}\n\twhile (1) {\n\t\tif (alloc_cnt == HFS_I(inode)->first_blocks) {\n\t\t\thfs_free_extents(sb, HFS_I(inode)->first_extents,\n\t\t\t\t\t alloc_cnt, alloc_cnt - blk_cnt);\n\t\t\thfs_dump_extent(HFS_I(inode)->first_extents);\n\t\t\tHFS_I(inode)->first_blocks = blk_cnt;\n\t\t\tbreak;\n\t\t}\n\t\tres = __hfs_ext_cache_extent(&fd, inode, alloc_cnt);\n\t\tif (res)\n\t\t\tbreak;\n\t\tstart = HFS_I(inode)->cached_start;\n\t\thfs_free_extents(sb, HFS_I(inode)->cached_extents,\n\t\t\t\t alloc_cnt - start, alloc_cnt - blk_cnt);\n\t\thfs_dump_extent(HFS_I(inode)->cached_extents);\n\t\tif (blk_cnt > start) {\n\t\t\tHFS_I(inode)->flags |= HFS_FLG_EXT_DIRTY;\n\t\t\tbreak;\n\t\t}\n\t\talloc_cnt = start;\n\t\tHFS_I(inode)->cached_start = HFS_I(inode)->cached_blocks = 0;\n\t\tHFS_I(inode)->flags &= ~(HFS_FLG_EXT_DIRTY|HFS_FLG_EXT_NEW);\n\t\thfs_brec_remove(&fd);\n\t}\n\thfs_find_exit(&fd);\n\tmutex_unlock(&HFS_I(inode)->extents_lock);\n\n\tHFS_I(inode)->alloc_blocks = blk_cnt;\nout:\n\tHFS_I(inode)->phys_size = inode->i_size;\n\tHFS_I(inode)->fs_blocks = (inode->i_size + sb->s_blocksize - 1) >> sb->s_blocksize_bits;\n\tinode_set_bytes(inode, HFS_I(inode)->fs_blocks << sb->s_blocksize_bits);\n\tmark_inode_dirty(inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "S_ISREG",
          "args": [
            "inode->i_mode"
          ],
          "line": 253
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HFS_SB",
          "args": [
            "sb"
          ],
          "line": 252
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "HFS_ROOT_CNID"
          ],
          "line": 251
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HFS_I",
          "args": [
            "inode"
          ],
          "line": 251
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HFS_SB",
          "args": [
            "sb"
          ],
          "line": 250
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HFS_SB",
          "args": [
            "sb"
          ],
          "line": 246
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HFS_SB",
          "args": [
            "sb"
          ],
          "line": 245
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "HFS_ROOT_CNID"
          ],
          "line": 244
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HFS_I",
          "args": [
            "inode"
          ],
          "line": 244
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HFS_SB",
          "args": [
            "sb"
          ],
          "line": 243
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISDIR",
          "args": [
            "inode->i_mode"
          ],
          "line": 242
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hfs_dbg",
          "args": [
            "INODE",
            "\"delete_inode: %lu\\n\"",
            "inode->i_ino"
          ],
          "line": 241
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"btree.h\"\n#include \"hfs_fs.h\"\n#include <linux/aio.h>\n#include <linux/sched.h>\n#include <linux/mpage.h>\n#include <linux/pagemap.h>\n\nvoid hfs_delete_inode(struct inode *inode)\n{\n\tstruct super_block *sb = inode->i_sb;\n\n\thfs_dbg(INODE, \"delete_inode: %lu\\n\", inode->i_ino);\n\tif (S_ISDIR(inode->i_mode)) {\n\t\tHFS_SB(sb)->folder_count--;\n\t\tif (HFS_I(inode)->cat_key.ParID == cpu_to_be32(HFS_ROOT_CNID))\n\t\t\tHFS_SB(sb)->root_dirs--;\n\t\tset_bit(HFS_FLG_MDB_DIRTY, &HFS_SB(sb)->flags);\n\t\thfs_mark_mdb_dirty(sb);\n\t\treturn;\n\t}\n\tHFS_SB(sb)->file_count--;\n\tif (HFS_I(inode)->cat_key.ParID == cpu_to_be32(HFS_ROOT_CNID))\n\t\tHFS_SB(sb)->root_files--;\n\tif (S_ISREG(inode->i_mode)) {\n\t\tif (!inode->i_nlink) {\n\t\t\tinode->i_size = 0;\n\t\t\thfs_file_truncate(inode);\n\t\t}\n\t}\n\tset_bit(HFS_FLG_MDB_DIRTY, &HFS_SB(sb)->flags);\n\thfs_mark_mdb_dirty(sb);\n}"
  },
  {
    "function_name": "hfs_new_inode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfs/inode.c",
    "lines": "181-235",
    "snippet": "struct inode *hfs_new_inode(struct inode *dir, struct qstr *name, umode_t mode)\n{\n\tstruct super_block *sb = dir->i_sb;\n\tstruct inode *inode = new_inode(sb);\n\tif (!inode)\n\t\treturn NULL;\n\n\tmutex_init(&HFS_I(inode)->extents_lock);\n\tINIT_LIST_HEAD(&HFS_I(inode)->open_dir_list);\n\thfs_cat_build_key(sb, (btree_key *)&HFS_I(inode)->cat_key, dir->i_ino, name);\n\tinode->i_ino = HFS_SB(sb)->next_id++;\n\tinode->i_mode = mode;\n\tinode->i_uid = current_fsuid();\n\tinode->i_gid = current_fsgid();\n\tset_nlink(inode, 1);\n\tinode->i_mtime = inode->i_atime = inode->i_ctime = CURRENT_TIME_SEC;\n\tHFS_I(inode)->flags = 0;\n\tHFS_I(inode)->rsrc_inode = NULL;\n\tHFS_I(inode)->fs_blocks = 0;\n\tif (S_ISDIR(mode)) {\n\t\tinode->i_size = 2;\n\t\tHFS_SB(sb)->folder_count++;\n\t\tif (dir->i_ino == HFS_ROOT_CNID)\n\t\t\tHFS_SB(sb)->root_dirs++;\n\t\tinode->i_op = &hfs_dir_inode_operations;\n\t\tinode->i_fop = &hfs_dir_operations;\n\t\tinode->i_mode |= S_IRWXUGO;\n\t\tinode->i_mode &= ~HFS_SB(inode->i_sb)->s_dir_umask;\n\t} else if (S_ISREG(mode)) {\n\t\tHFS_I(inode)->clump_blocks = HFS_SB(sb)->clumpablks;\n\t\tHFS_SB(sb)->file_count++;\n\t\tif (dir->i_ino == HFS_ROOT_CNID)\n\t\t\tHFS_SB(sb)->root_files++;\n\t\tinode->i_op = &hfs_file_inode_operations;\n\t\tinode->i_fop = &hfs_file_operations;\n\t\tinode->i_mapping->a_ops = &hfs_aops;\n\t\tinode->i_mode |= S_IRUGO|S_IXUGO;\n\t\tif (mode & S_IWUSR)\n\t\t\tinode->i_mode |= S_IWUGO;\n\t\tinode->i_mode &= ~HFS_SB(inode->i_sb)->s_file_umask;\n\t\tHFS_I(inode)->phys_size = 0;\n\t\tHFS_I(inode)->alloc_blocks = 0;\n\t\tHFS_I(inode)->first_blocks = 0;\n\t\tHFS_I(inode)->cached_start = 0;\n\t\tHFS_I(inode)->cached_blocks = 0;\n\t\tmemset(HFS_I(inode)->first_extents, 0, sizeof(hfs_extent_rec));\n\t\tmemset(HFS_I(inode)->cached_extents, 0, sizeof(hfs_extent_rec));\n\t}\n\tinsert_inode_hash(inode);\n\tmark_inode_dirty(inode);\n\tset_bit(HFS_FLG_MDB_DIRTY, &HFS_SB(sb)->flags);\n\thfs_mark_mdb_dirty(sb);\n\n\treturn inode;\n}",
    "includes": [
      "#include \"btree.h\"",
      "#include \"hfs_fs.h\"",
      "#include <linux/aio.h>",
      "#include <linux/sched.h>",
      "#include <linux/mpage.h>",
      "#include <linux/pagemap.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static const struct file_operations hfs_file_operations;",
      "static const struct inode_operations hfs_file_inode_operations;",
      "const struct address_space_operations hfs_aops = {\n\t.readpage\t= hfs_readpage,\n\t.writepage\t= hfs_writepage,\n\t.write_begin\t= hfs_write_begin,\n\t.write_end\t= generic_write_end,\n\t.bmap\t\t= hfs_bmap,\n\t.direct_IO\t= hfs_direct_IO,\n\t.writepages\t= hfs_writepages,\n};",
      "static const struct file_operations hfs_file_operations = {\n\t.llseek\t\t= generic_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= generic_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= generic_file_write_iter,\n\t.mmap\t\t= generic_file_mmap,\n\t.splice_read\t= generic_file_splice_read,\n\t.fsync\t\t= hfs_file_fsync,\n\t.open\t\t= hfs_file_open,\n\t.release\t= hfs_file_release,\n};",
      "static const struct inode_operations hfs_file_inode_operations = {\n\t.lookup\t\t= hfs_file_lookup,\n\t.setattr\t= hfs_inode_setattr,\n\t.setxattr\t= hfs_setxattr,\n\t.getxattr\t= hfs_getxattr,\n\t.listxattr\t= hfs_listxattr,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "hfs_mark_mdb_dirty",
          "args": [
            "sb"
          ],
          "line": 232
        },
        "resolved": true,
        "details": {
          "function_name": "hfs_mark_mdb_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfs/super.c",
          "lines": "68-83",
          "snippet": "void hfs_mark_mdb_dirty(struct super_block *sb)\n{\n\tstruct hfs_sb_info *sbi = HFS_SB(sb);\n\tunsigned long delay;\n\n\tif (sb->s_flags & MS_RDONLY)\n\t\treturn;\n\n\tspin_lock(&sbi->work_lock);\n\tif (!sbi->work_queued) {\n\t\tdelay = msecs_to_jiffies(dirty_writeback_interval * 10);\n\t\tqueue_delayed_work(system_long_wq, &sbi->mdb_work, delay);\n\t\tsbi->work_queued = 1;\n\t}\n\tspin_unlock(&sbi->work_lock);\n}",
          "includes": [
            "#include \"btree.h\"",
            "#include \"hfs_fs.h\"",
            "#include <linux/vfs.h>",
            "#include <linux/slab.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/parser.h>",
            "#include <linux/nls.h>",
            "#include <linux/init.h>",
            "#include <linux/mount.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"btree.h\"\n#include \"hfs_fs.h\"\n#include <linux/vfs.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/parser.h>\n#include <linux/nls.h>\n#include <linux/init.h>\n#include <linux/mount.h>\n#include <linux/blkdev.h>\n#include <linux/module.h>\n\nvoid hfs_mark_mdb_dirty(struct super_block *sb)\n{\n\tstruct hfs_sb_info *sbi = HFS_SB(sb);\n\tunsigned long delay;\n\n\tif (sb->s_flags & MS_RDONLY)\n\t\treturn;\n\n\tspin_lock(&sbi->work_lock);\n\tif (!sbi->work_queued) {\n\t\tdelay = msecs_to_jiffies(dirty_writeback_interval * 10);\n\t\tqueue_delayed_work(system_long_wq, &sbi->mdb_work, delay);\n\t\tsbi->work_queued = 1;\n\t}\n\tspin_unlock(&sbi->work_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_bit",
          "args": [
            "HFS_FLG_MDB_DIRTY",
            "&HFS_SB(sb)->flags"
          ],
          "line": 231
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_set_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "886-890",
          "snippet": "static inline void ocfs2_set_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_set_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline void ocfs2_set_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_set_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "HFS_SB",
          "args": [
            "sb"
          ],
          "line": 231
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mark_inode_dirty",
          "args": [
            "inode"
          ],
          "line": 230
        },
        "resolved": true,
        "details": {
          "function_name": "block_dump___mark_inode_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fs-writeback.c",
          "lines": "1134-1154",
          "snippet": "static noinline void block_dump___mark_inode_dirty(struct inode *inode)\n{\n\tif (inode->i_ino || strcmp(inode->i_sb->s_id, \"bdev\")) {\n\t\tstruct dentry *dentry;\n\t\tconst char *name = \"?\";\n\n\t\tdentry = d_find_alias(inode);\n\t\tif (dentry) {\n\t\t\tspin_lock(&dentry->d_lock);\n\t\t\tname = (const char *) dentry->d_name.name;\n\t\t}\n\t\tprintk(KERN_DEBUG\n\t\t       \"%s(%d): dirtied inode %lu (%s) on %s\\n\",\n\t\t       current->comm, task_pid_nr(current), inode->i_ino,\n\t\t       name, inode->i_sb->s_id);\n\t\tif (dentry) {\n\t\t\tspin_unlock(&dentry->d_lock);\n\t\t\tdput(dentry);\n\t\t}\n\t}\n}",
          "includes": [
            "#include <trace/events/writeback.h>",
            "#include \"internal.h\"",
            "#include <linux/device.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/writeback.h>\n#include \"internal.h\"\n#include <linux/device.h>\n#include <linux/tracepoint.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nstatic noinline void block_dump___mark_inode_dirty(struct inode *inode)\n{\n\tif (inode->i_ino || strcmp(inode->i_sb->s_id, \"bdev\")) {\n\t\tstruct dentry *dentry;\n\t\tconst char *name = \"?\";\n\n\t\tdentry = d_find_alias(inode);\n\t\tif (dentry) {\n\t\t\tspin_lock(&dentry->d_lock);\n\t\t\tname = (const char *) dentry->d_name.name;\n\t\t}\n\t\tprintk(KERN_DEBUG\n\t\t       \"%s(%d): dirtied inode %lu (%s) on %s\\n\",\n\t\t       current->comm, task_pid_nr(current), inode->i_ino,\n\t\t       name, inode->i_sb->s_id);\n\t\tif (dentry) {\n\t\t\tspin_unlock(&dentry->d_lock);\n\t\t\tdput(dentry);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "insert_inode_hash",
          "args": [
            "inode"
          ],
          "line": 229
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_insert_inode_hash",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/btrfs_inode.h",
          "lines": "213-218",
          "snippet": "static inline void btrfs_insert_inode_hash(struct inode *inode)\n{\n\tunsigned long h = btrfs_inode_hash(inode->i_ino, BTRFS_I(inode)->root);\n\n\t__insert_inode_hash(inode, h);\n}",
          "includes": [
            "#include \"delayed-inode.h\"",
            "#include \"ordered-data.h\"",
            "#include \"extent_io.h\"",
            "#include \"extent_map.h\"",
            "#include <linux/hash.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"delayed-inode.h\"\n#include \"ordered-data.h\"\n#include \"extent_io.h\"\n#include \"extent_map.h\"\n#include <linux/hash.h>\n\nstatic inline void btrfs_insert_inode_hash(struct inode *inode)\n{\n\tunsigned long h = btrfs_inode_hash(inode->i_ino, BTRFS_I(inode)->root);\n\n\t__insert_inode_hash(inode, h);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "HFS_I(inode)->cached_extents",
            "0",
            "sizeof(hfs_extent_rec)"
          ],
          "line": 227
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HFS_I",
          "args": [
            "inode"
          ],
          "line": 227
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "HFS_I(inode)->first_extents",
            "0",
            "sizeof(hfs_extent_rec)"
          ],
          "line": 226
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HFS_I",
          "args": [
            "inode"
          ],
          "line": 226
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HFS_I",
          "args": [
            "inode"
          ],
          "line": 225
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HFS_I",
          "args": [
            "inode"
          ],
          "line": 224
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HFS_I",
          "args": [
            "inode"
          ],
          "line": 223
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HFS_I",
          "args": [
            "inode"
          ],
          "line": 222
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HFS_I",
          "args": [
            "inode"
          ],
          "line": 221
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HFS_SB",
          "args": [
            "inode->i_sb"
          ],
          "line": 220
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HFS_SB",
          "args": [
            "sb"
          ],
          "line": 213
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HFS_SB",
          "args": [
            "sb"
          ],
          "line": 211
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HFS_SB",
          "args": [
            "sb"
          ],
          "line": 210
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HFS_I",
          "args": [
            "inode"
          ],
          "line": 210
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISREG",
          "args": [
            "mode"
          ],
          "line": 209
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HFS_SB",
          "args": [
            "inode->i_sb"
          ],
          "line": 208
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HFS_SB",
          "args": [
            "sb"
          ],
          "line": 204
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HFS_SB",
          "args": [
            "sb"
          ],
          "line": 202
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISDIR",
          "args": [
            "mode"
          ],
          "line": 200
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HFS_I",
          "args": [
            "inode"
          ],
          "line": 199
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HFS_I",
          "args": [
            "inode"
          ],
          "line": 198
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HFS_I",
          "args": [
            "inode"
          ],
          "line": 197
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_nlink",
          "args": [
            "inode",
            "1"
          ],
          "line": 195
        },
        "resolved": true,
        "details": {
          "function_name": "set_nlink",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "305-316",
          "snippet": "void set_nlink(struct inode *inode, unsigned int nlink)\n{\n\tif (!nlink) {\n\t\tclear_nlink(inode);\n\t} else {\n\t\t/* Yes, some filesystems do change nlink from zero to one */\n\t\tif (inode->i_nlink == 0)\n\t\t\tatomic_long_dec(&inode->i_sb->s_remove_count);\n\n\t\tinode->__i_nlink = nlink;\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid set_nlink(struct inode *inode, unsigned int nlink)\n{\n\tif (!nlink) {\n\t\tclear_nlink(inode);\n\t} else {\n\t\t/* Yes, some filesystems do change nlink from zero to one */\n\t\tif (inode->i_nlink == 0)\n\t\t\tatomic_long_dec(&inode->i_sb->s_remove_count);\n\n\t\tinode->__i_nlink = nlink;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "current_fsgid",
          "args": [],
          "line": 194
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "current_fsuid",
          "args": [],
          "line": 193
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HFS_SB",
          "args": [
            "sb"
          ],
          "line": 191
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hfs_cat_build_key",
          "args": [
            "sb",
            "(btree_key *)&HFS_I(inode)->cat_key",
            "dir->i_ino",
            "name"
          ],
          "line": 190
        },
        "resolved": true,
        "details": {
          "function_name": "hfs_cat_build_key",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfs/catalog.c",
          "lines": "23-34",
          "snippet": "void hfs_cat_build_key(struct super_block *sb, btree_key *key, u32 parent, struct qstr *name)\n{\n\tkey->cat.reserved = 0;\n\tkey->cat.ParID = cpu_to_be32(parent);\n\tif (name) {\n\t\thfs_asc2mac(sb, &key->cat.CName, name);\n\t\tkey->key_len = 6 + key->cat.CName.len;\n\t} else {\n\t\tmemset(&key->cat.CName, 0, sizeof(struct hfs_name));\n\t\tkey->key_len = 6;\n\t}\n}",
          "includes": [
            "#include \"btree.h\"",
            "#include \"hfs_fs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"btree.h\"\n#include \"hfs_fs.h\"\n\nvoid hfs_cat_build_key(struct super_block *sb, btree_key *key, u32 parent, struct qstr *name)\n{\n\tkey->cat.reserved = 0;\n\tkey->cat.ParID = cpu_to_be32(parent);\n\tif (name) {\n\t\thfs_asc2mac(sb, &key->cat.CName, name);\n\t\tkey->key_len = 6 + key->cat.CName.len;\n\t} else {\n\t\tmemset(&key->cat.CName, 0, sizeof(struct hfs_name));\n\t\tkey->key_len = 6;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "HFS_I",
          "args": [
            "inode"
          ],
          "line": 190
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&HFS_I(inode)->open_dir_list"
          ],
          "line": 189
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HFS_I",
          "args": [
            "inode"
          ],
          "line": 189
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_init",
          "args": [
            "&HFS_I(inode)->extents_lock"
          ],
          "line": 188
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HFS_I",
          "args": [
            "inode"
          ],
          "line": 188
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "new_inode",
          "args": [
            "sb"
          ],
          "line": 184
        },
        "resolved": true,
        "details": {
          "function_name": "unlock_new_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "924-933",
          "snippet": "void unlock_new_inode(struct inode *inode)\n{\n\tlockdep_annotate_inode_mutex_key(inode);\n\tspin_lock(&inode->i_lock);\n\tWARN_ON(!(inode->i_state & I_NEW));\n\tinode->i_state &= ~I_NEW;\n\tsmp_mb();\n\twake_up_bit(&inode->i_state, __I_NEW);\n\tspin_unlock(&inode->i_lock);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid unlock_new_inode(struct inode *inode)\n{\n\tlockdep_annotate_inode_mutex_key(inode);\n\tspin_lock(&inode->i_lock);\n\tWARN_ON(!(inode->i_state & I_NEW));\n\tinode->i_state &= ~I_NEW;\n\tsmp_mb();\n\twake_up_bit(&inode->i_state, __I_NEW);\n\tspin_unlock(&inode->i_lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"btree.h\"\n#include \"hfs_fs.h\"\n#include <linux/aio.h>\n#include <linux/sched.h>\n#include <linux/mpage.h>\n#include <linux/pagemap.h>\n\nstatic const struct file_operations hfs_file_operations;\nstatic const struct inode_operations hfs_file_inode_operations;\nconst struct address_space_operations hfs_aops = {\n\t.readpage\t= hfs_readpage,\n\t.writepage\t= hfs_writepage,\n\t.write_begin\t= hfs_write_begin,\n\t.write_end\t= generic_write_end,\n\t.bmap\t\t= hfs_bmap,\n\t.direct_IO\t= hfs_direct_IO,\n\t.writepages\t= hfs_writepages,\n};\nstatic const struct file_operations hfs_file_operations = {\n\t.llseek\t\t= generic_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= generic_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= generic_file_write_iter,\n\t.mmap\t\t= generic_file_mmap,\n\t.splice_read\t= generic_file_splice_read,\n\t.fsync\t\t= hfs_file_fsync,\n\t.open\t\t= hfs_file_open,\n\t.release\t= hfs_file_release,\n};\nstatic const struct inode_operations hfs_file_inode_operations = {\n\t.lookup\t\t= hfs_file_lookup,\n\t.setattr\t= hfs_inode_setattr,\n\t.setxattr\t= hfs_setxattr,\n\t.getxattr\t= hfs_getxattr,\n\t.listxattr\t= hfs_listxattr,\n};\n\nstruct inode *hfs_new_inode(struct inode *dir, struct qstr *name, umode_t mode)\n{\n\tstruct super_block *sb = dir->i_sb;\n\tstruct inode *inode = new_inode(sb);\n\tif (!inode)\n\t\treturn NULL;\n\n\tmutex_init(&HFS_I(inode)->extents_lock);\n\tINIT_LIST_HEAD(&HFS_I(inode)->open_dir_list);\n\thfs_cat_build_key(sb, (btree_key *)&HFS_I(inode)->cat_key, dir->i_ino, name);\n\tinode->i_ino = HFS_SB(sb)->next_id++;\n\tinode->i_mode = mode;\n\tinode->i_uid = current_fsuid();\n\tinode->i_gid = current_fsgid();\n\tset_nlink(inode, 1);\n\tinode->i_mtime = inode->i_atime = inode->i_ctime = CURRENT_TIME_SEC;\n\tHFS_I(inode)->flags = 0;\n\tHFS_I(inode)->rsrc_inode = NULL;\n\tHFS_I(inode)->fs_blocks = 0;\n\tif (S_ISDIR(mode)) {\n\t\tinode->i_size = 2;\n\t\tHFS_SB(sb)->folder_count++;\n\t\tif (dir->i_ino == HFS_ROOT_CNID)\n\t\t\tHFS_SB(sb)->root_dirs++;\n\t\tinode->i_op = &hfs_dir_inode_operations;\n\t\tinode->i_fop = &hfs_dir_operations;\n\t\tinode->i_mode |= S_IRWXUGO;\n\t\tinode->i_mode &= ~HFS_SB(inode->i_sb)->s_dir_umask;\n\t} else if (S_ISREG(mode)) {\n\t\tHFS_I(inode)->clump_blocks = HFS_SB(sb)->clumpablks;\n\t\tHFS_SB(sb)->file_count++;\n\t\tif (dir->i_ino == HFS_ROOT_CNID)\n\t\t\tHFS_SB(sb)->root_files++;\n\t\tinode->i_op = &hfs_file_inode_operations;\n\t\tinode->i_fop = &hfs_file_operations;\n\t\tinode->i_mapping->a_ops = &hfs_aops;\n\t\tinode->i_mode |= S_IRUGO|S_IXUGO;\n\t\tif (mode & S_IWUSR)\n\t\t\tinode->i_mode |= S_IWUGO;\n\t\tinode->i_mode &= ~HFS_SB(inode->i_sb)->s_file_umask;\n\t\tHFS_I(inode)->phys_size = 0;\n\t\tHFS_I(inode)->alloc_blocks = 0;\n\t\tHFS_I(inode)->first_blocks = 0;\n\t\tHFS_I(inode)->cached_start = 0;\n\t\tHFS_I(inode)->cached_blocks = 0;\n\t\tmemset(HFS_I(inode)->first_extents, 0, sizeof(hfs_extent_rec));\n\t\tmemset(HFS_I(inode)->cached_extents, 0, sizeof(hfs_extent_rec));\n\t}\n\tinsert_inode_hash(inode);\n\tmark_inode_dirty(inode);\n\tset_bit(HFS_FLG_MDB_DIRTY, &HFS_SB(sb)->flags);\n\thfs_mark_mdb_dirty(sb);\n\n\treturn inode;\n}"
  },
  {
    "function_name": "hfs_writepages",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfs/inode.c",
    "lines": "153-157",
    "snippet": "static int hfs_writepages(struct address_space *mapping,\n\t\t\t  struct writeback_control *wbc)\n{\n\treturn mpage_writepages(mapping, wbc, hfs_get_block);\n}",
    "includes": [
      "#include \"btree.h\"",
      "#include \"hfs_fs.h\"",
      "#include <linux/aio.h>",
      "#include <linux/sched.h>",
      "#include <linux/mpage.h>",
      "#include <linux/pagemap.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mpage_writepages",
          "args": [
            "mapping",
            "wbc",
            "hfs_get_block"
          ],
          "line": 156
        },
        "resolved": true,
        "details": {
          "function_name": "mpage_writepages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mpage.c",
          "lines": "675-700",
          "snippet": "int\nmpage_writepages(struct address_space *mapping,\n\t\tstruct writeback_control *wbc, get_block_t get_block)\n{\n\tstruct blk_plug plug;\n\tint ret;\n\n\tblk_start_plug(&plug);\n\n\tif (!get_block)\n\t\tret = generic_writepages(mapping, wbc);\n\telse {\n\t\tstruct mpage_data mpd = {\n\t\t\t.bio = NULL,\n\t\t\t.last_block_in_bio = 0,\n\t\t\t.get_block = get_block,\n\t\t\t.use_writepage = 1,\n\t\t};\n\n\t\tret = write_cache_pages(mapping, wbc, __mpage_writepage, &mpd);\n\t\tif (mpd.bio)\n\t\t\tmpage_bio_submit(WRITE, mpd.bio);\n\t}\n\tblk_finish_plug(&plug);\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mpage.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/highmem.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/fs.h>",
            "#include <linux/bio.h>",
            "#include <linux/gfp.h>",
            "#include <linux/kdev_t.h>",
            "#include <linux/mm.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/cleancache.h>\n#include <linux/pagevec.h>\n#include <linux/backing-dev.h>\n#include <linux/writeback.h>\n#include <linux/mpage.h>\n#include <linux/prefetch.h>\n#include <linux/highmem.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n#include <linux/bio.h>\n#include <linux/gfp.h>\n#include <linux/kdev_t.h>\n#include <linux/mm.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nint\nmpage_writepages(struct address_space *mapping,\n\t\tstruct writeback_control *wbc, get_block_t get_block)\n{\n\tstruct blk_plug plug;\n\tint ret;\n\n\tblk_start_plug(&plug);\n\n\tif (!get_block)\n\t\tret = generic_writepages(mapping, wbc);\n\telse {\n\t\tstruct mpage_data mpd = {\n\t\t\t.bio = NULL,\n\t\t\t.last_block_in_bio = 0,\n\t\t\t.get_block = get_block,\n\t\t\t.use_writepage = 1,\n\t\t};\n\n\t\tret = write_cache_pages(mapping, wbc, __mpage_writepage, &mpd);\n\t\tif (mpd.bio)\n\t\t\tmpage_bio_submit(WRITE, mpd.bio);\n\t}\n\tblk_finish_plug(&plug);\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"btree.h\"\n#include \"hfs_fs.h\"\n#include <linux/aio.h>\n#include <linux/sched.h>\n#include <linux/mpage.h>\n#include <linux/pagemap.h>\n\nstatic int hfs_writepages(struct address_space *mapping,\n\t\t\t  struct writeback_control *wbc)\n{\n\treturn mpage_writepages(mapping, wbc, hfs_get_block);\n}"
  },
  {
    "function_name": "hfs_direct_IO",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfs/inode.c",
    "lines": "127-151",
    "snippet": "static ssize_t hfs_direct_IO(int rw, struct kiocb *iocb,\n\t\tstruct iov_iter *iter, loff_t offset)\n{\n\tstruct file *file = iocb->ki_filp;\n\tstruct address_space *mapping = file->f_mapping;\n\tstruct inode *inode = file_inode(file)->i_mapping->host;\n\tsize_t count = iov_iter_count(iter);\n\tssize_t ret;\n\n\tret = blockdev_direct_IO(rw, iocb, inode, iter, offset, hfs_get_block);\n\n\t/*\n\t * In case of error extending write may have instantiated a few\n\t * blocks outside i_size. Trim these off again.\n\t */\n\tif (unlikely((rw & WRITE) && ret < 0)) {\n\t\tloff_t isize = i_size_read(inode);\n\t\tloff_t end = offset + count;\n\n\t\tif (end > isize)\n\t\t\thfs_write_failed(mapping, end);\n\t}\n\n\treturn ret;\n}",
    "includes": [
      "#include \"btree.h\"",
      "#include \"hfs_fs.h\"",
      "#include <linux/aio.h>",
      "#include <linux/sched.h>",
      "#include <linux/mpage.h>",
      "#include <linux/pagemap.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "hfs_write_failed",
          "args": [
            "mapping",
            "end"
          ],
          "line": 147
        },
        "resolved": true,
        "details": {
          "function_name": "hfs_write_failed",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfs/inode.c",
          "lines": "39-47",
          "snippet": "static void hfs_write_failed(struct address_space *mapping, loff_t to)\n{\n\tstruct inode *inode = mapping->host;\n\n\tif (to > inode->i_size) {\n\t\ttruncate_pagecache(inode, inode->i_size);\n\t\thfs_file_truncate(inode);\n\t}\n}",
          "includes": [
            "#include \"btree.h\"",
            "#include \"hfs_fs.h\"",
            "#include <linux/aio.h>",
            "#include <linux/sched.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"btree.h\"\n#include \"hfs_fs.h\"\n#include <linux/aio.h>\n#include <linux/sched.h>\n#include <linux/mpage.h>\n#include <linux/pagemap.h>\n\nstatic void hfs_write_failed(struct address_space *mapping, loff_t to)\n{\n\tstruct inode *inode = mapping->host;\n\n\tif (to > inode->i_size) {\n\t\ttruncate_pagecache(inode, inode->i_size);\n\t\thfs_file_truncate(inode);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "i_size_read",
          "args": [
            "inode"
          ],
          "line": 143
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "(rw & WRITE) && ret < 0"
          ],
          "line": 142
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "blockdev_direct_IO",
          "args": [
            "rw",
            "iocb",
            "inode",
            "iter",
            "offset",
            "hfs_get_block"
          ],
          "line": 136
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "iov_iter_count",
          "args": [
            "iter"
          ],
          "line": 133
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "file_inode",
          "args": [
            "file"
          ],
          "line": 132
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_init_file_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/file.c",
          "lines": "3009-3013",
          "snippet": "void fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}",
          "includes": [
            "#include <linux/falloc.h>",
            "#include <linux/aio.h>",
            "#include <linux/swap.h>",
            "#include <linux/compat.h>",
            "#include <linux/module.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};",
            "static const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/compat.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};\nstatic const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};\n\nvoid fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"btree.h\"\n#include \"hfs_fs.h\"\n#include <linux/aio.h>\n#include <linux/sched.h>\n#include <linux/mpage.h>\n#include <linux/pagemap.h>\n\nstatic ssize_t hfs_direct_IO(int rw, struct kiocb *iocb,\n\t\tstruct iov_iter *iter, loff_t offset)\n{\n\tstruct file *file = iocb->ki_filp;\n\tstruct address_space *mapping = file->f_mapping;\n\tstruct inode *inode = file_inode(file)->i_mapping->host;\n\tsize_t count = iov_iter_count(iter);\n\tssize_t ret;\n\n\tret = blockdev_direct_IO(rw, iocb, inode, iter, offset, hfs_get_block);\n\n\t/*\n\t * In case of error extending write may have instantiated a few\n\t * blocks outside i_size. Trim these off again.\n\t */\n\tif (unlikely((rw & WRITE) && ret < 0)) {\n\t\tloff_t isize = i_size_read(inode);\n\t\tloff_t end = offset + count;\n\n\t\tif (end > isize)\n\t\t\thfs_write_failed(mapping, end);\n\t}\n\n\treturn ret;\n}"
  },
  {
    "function_name": "hfs_releasepage",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfs/inode.c",
    "lines": "70-125",
    "snippet": "static int hfs_releasepage(struct page *page, gfp_t mask)\n{\n\tstruct inode *inode = page->mapping->host;\n\tstruct super_block *sb = inode->i_sb;\n\tstruct hfs_btree *tree;\n\tstruct hfs_bnode *node;\n\tu32 nidx;\n\tint i, res = 1;\n\n\tswitch (inode->i_ino) {\n\tcase HFS_EXT_CNID:\n\t\ttree = HFS_SB(sb)->ext_tree;\n\t\tbreak;\n\tcase HFS_CAT_CNID:\n\t\ttree = HFS_SB(sb)->cat_tree;\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t\treturn 0;\n\t}\n\n\tif (!tree)\n\t\treturn 0;\n\n\tif (tree->node_size >= PAGE_CACHE_SIZE) {\n\t\tnidx = page->index >> (tree->node_size_shift - PAGE_CACHE_SHIFT);\n\t\tspin_lock(&tree->hash_lock);\n\t\tnode = hfs_bnode_findhash(tree, nidx);\n\t\tif (!node)\n\t\t\t;\n\t\telse if (atomic_read(&node->refcnt))\n\t\t\tres = 0;\n\t\tif (res && node) {\n\t\t\thfs_bnode_unhash(node);\n\t\t\thfs_bnode_free(node);\n\t\t}\n\t\tspin_unlock(&tree->hash_lock);\n\t} else {\n\t\tnidx = page->index << (PAGE_CACHE_SHIFT - tree->node_size_shift);\n\t\ti = 1 << (PAGE_CACHE_SHIFT - tree->node_size_shift);\n\t\tspin_lock(&tree->hash_lock);\n\t\tdo {\n\t\t\tnode = hfs_bnode_findhash(tree, nidx++);\n\t\t\tif (!node)\n\t\t\t\tcontinue;\n\t\t\tif (atomic_read(&node->refcnt)) {\n\t\t\t\tres = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\thfs_bnode_unhash(node);\n\t\t\thfs_bnode_free(node);\n\t\t} while (--i && nidx < tree->node_count);\n\t\tspin_unlock(&tree->hash_lock);\n\t}\n\treturn res ? try_to_free_buffers(page) : 0;\n}",
    "includes": [
      "#include \"btree.h\"",
      "#include \"hfs_fs.h\"",
      "#include <linux/aio.h>",
      "#include <linux/sched.h>",
      "#include <linux/mpage.h>",
      "#include <linux/pagemap.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "try_to_free_buffers",
          "args": [
            "page"
          ],
          "line": 124
        },
        "resolved": true,
        "details": {
          "function_name": "try_to_free_buffers",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "3214-3260",
          "snippet": "int try_to_free_buffers(struct page *page)\n{\n\tstruct address_space * const mapping = page->mapping;\n\tstruct buffer_head *buffers_to_free = NULL;\n\tint ret = 0;\n\n\tBUG_ON(!PageLocked(page));\n\tif (PageWriteback(page))\n\t\treturn 0;\n\n\tif (mapping == NULL) {\t\t/* can this still happen? */\n\t\tret = drop_buffers(page, &buffers_to_free);\n\t\tgoto out;\n\t}\n\n\tspin_lock(&mapping->private_lock);\n\tret = drop_buffers(page, &buffers_to_free);\n\n\t/*\n\t * If the filesystem writes its buffers by hand (eg ext3)\n\t * then we can have clean buffers against a dirty page.  We\n\t * clean the page here; otherwise the VM will never notice\n\t * that the filesystem did any IO at all.\n\t *\n\t * Also, during truncate, discard_buffer will have marked all\n\t * the page's buffers clean.  We discover that here and clean\n\t * the page also.\n\t *\n\t * private_lock must be held over this entire operation in order\n\t * to synchronise against __set_page_dirty_buffers and prevent the\n\t * dirty bit from being lost.\n\t */\n\tif (ret)\n\t\tcancel_dirty_page(page, PAGE_CACHE_SIZE);\n\tspin_unlock(&mapping->private_lock);\nout:\n\tif (buffers_to_free) {\n\t\tstruct buffer_head *bh = buffers_to_free;\n\n\t\tdo {\n\t\t\tstruct buffer_head *next = bh->b_this_page;\n\t\t\tfree_buffer_head(bh);\n\t\t\tbh = next;\n\t\t} while (bh != buffers_to_free);\n\t}\n\treturn ret;\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nint try_to_free_buffers(struct page *page)\n{\n\tstruct address_space * const mapping = page->mapping;\n\tstruct buffer_head *buffers_to_free = NULL;\n\tint ret = 0;\n\n\tBUG_ON(!PageLocked(page));\n\tif (PageWriteback(page))\n\t\treturn 0;\n\n\tif (mapping == NULL) {\t\t/* can this still happen? */\n\t\tret = drop_buffers(page, &buffers_to_free);\n\t\tgoto out;\n\t}\n\n\tspin_lock(&mapping->private_lock);\n\tret = drop_buffers(page, &buffers_to_free);\n\n\t/*\n\t * If the filesystem writes its buffers by hand (eg ext3)\n\t * then we can have clean buffers against a dirty page.  We\n\t * clean the page here; otherwise the VM will never notice\n\t * that the filesystem did any IO at all.\n\t *\n\t * Also, during truncate, discard_buffer will have marked all\n\t * the page's buffers clean.  We discover that here and clean\n\t * the page also.\n\t *\n\t * private_lock must be held over this entire operation in order\n\t * to synchronise against __set_page_dirty_buffers and prevent the\n\t * dirty bit from being lost.\n\t */\n\tif (ret)\n\t\tcancel_dirty_page(page, PAGE_CACHE_SIZE);\n\tspin_unlock(&mapping->private_lock);\nout:\n\tif (buffers_to_free) {\n\t\tstruct buffer_head *bh = buffers_to_free;\n\n\t\tdo {\n\t\t\tstruct buffer_head *next = bh->b_this_page;\n\t\t\tfree_buffer_head(bh);\n\t\t\tbh = next;\n\t\t} while (bh != buffers_to_free);\n\t}\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&tree->hash_lock"
          ],
          "line": 122
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "hfs_bnode_free",
          "args": [
            "node"
          ],
          "line": 120
        },
        "resolved": true,
        "details": {
          "function_name": "hfs_bnode_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfs/bnode.c",
          "lines": "399-407",
          "snippet": "void hfs_bnode_free(struct hfs_bnode *node)\n{\n\t//int i;\n\n\t//for (i = 0; i < node->tree->pages_per_bnode; i++)\n\t//\tif (node->page[i])\n\t//\t\tpage_cache_release(node->page[i]);\n\tkfree(node);\n}",
          "includes": [
            "#include \"btree.h\"",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"btree.h\"\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n\nvoid hfs_bnode_free(struct hfs_bnode *node)\n{\n\t//int i;\n\n\t//for (i = 0; i < node->tree->pages_per_bnode; i++)\n\t//\tif (node->page[i])\n\t//\t\tpage_cache_release(node->page[i]);\n\tkfree(node);\n}"
        }
      },
      {
        "call_info": {
          "callee": "hfs_bnode_unhash",
          "args": [
            "node"
          ],
          "line": 119
        },
        "resolved": true,
        "details": {
          "function_name": "hfs_bnode_unhash",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfs/bnode.c",
          "lines": "301-313",
          "snippet": "void hfs_bnode_unhash(struct hfs_bnode *node)\n{\n\tstruct hfs_bnode **p;\n\n\thfs_dbg(BNODE_REFS, \"remove_node(%d:%d): %d\\n\",\n\t\tnode->tree->cnid, node->this, atomic_read(&node->refcnt));\n\tfor (p = &node->tree->node_hash[hfs_bnode_hash(node->this)];\n\t     *p && *p != node; p = &(*p)->next_hash)\n\t\t;\n\tBUG_ON(!*p);\n\t*p = node->next_hash;\n\tnode->tree->node_hash_cnt--;\n}",
          "includes": [
            "#include \"btree.h\"",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"btree.h\"\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n\nvoid hfs_bnode_unhash(struct hfs_bnode *node)\n{\n\tstruct hfs_bnode **p;\n\n\thfs_dbg(BNODE_REFS, \"remove_node(%d:%d): %d\\n\",\n\t\tnode->tree->cnid, node->this, atomic_read(&node->refcnt));\n\tfor (p = &node->tree->node_hash[hfs_bnode_hash(node->this)];\n\t     *p && *p != node; p = &(*p)->next_hash)\n\t\t;\n\tBUG_ON(!*p);\n\t*p = node->next_hash;\n\tnode->tree->node_hash_cnt--;\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&node->refcnt"
          ],
          "line": 115
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hfs_bnode_findhash",
          "args": [
            "tree",
            "nidx++"
          ],
          "line": 112
        },
        "resolved": true,
        "details": {
          "function_name": "hfs_bnode_findhash",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfs/bnode.c",
          "lines": "219-235",
          "snippet": "struct hfs_bnode *hfs_bnode_findhash(struct hfs_btree *tree, u32 cnid)\n{\n\tstruct hfs_bnode *node;\n\n\tif (cnid >= tree->node_count) {\n\t\tpr_err(\"request for non-existent node %d in B*Tree\\n\", cnid);\n\t\treturn NULL;\n\t}\n\n\tfor (node = tree->node_hash[hfs_bnode_hash(cnid)];\n\t     node; node = node->next_hash) {\n\t\tif (node->this == cnid) {\n\t\t\treturn node;\n\t\t}\n\t}\n\treturn NULL;\n}",
          "includes": [
            "#include \"btree.h\"",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"btree.h\"\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n\nstruct hfs_bnode *hfs_bnode_findhash(struct hfs_btree *tree, u32 cnid)\n{\n\tstruct hfs_bnode *node;\n\n\tif (cnid >= tree->node_count) {\n\t\tpr_err(\"request for non-existent node %d in B*Tree\\n\", cnid);\n\t\treturn NULL;\n\t}\n\n\tfor (node = tree->node_hash[hfs_bnode_hash(cnid)];\n\t     node; node = node->next_hash) {\n\t\tif (node->this == cnid) {\n\t\t\treturn node;\n\t\t}\n\t}\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&tree->hash_lock"
          ],
          "line": 110
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&node->refcnt"
          ],
          "line": 100
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG",
          "args": [],
          "line": 87
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HFS_SB",
          "args": [
            "sb"
          ],
          "line": 84
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HFS_SB",
          "args": [
            "sb"
          ],
          "line": 81
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"btree.h\"\n#include \"hfs_fs.h\"\n#include <linux/aio.h>\n#include <linux/sched.h>\n#include <linux/mpage.h>\n#include <linux/pagemap.h>\n\nstatic int hfs_releasepage(struct page *page, gfp_t mask)\n{\n\tstruct inode *inode = page->mapping->host;\n\tstruct super_block *sb = inode->i_sb;\n\tstruct hfs_btree *tree;\n\tstruct hfs_bnode *node;\n\tu32 nidx;\n\tint i, res = 1;\n\n\tswitch (inode->i_ino) {\n\tcase HFS_EXT_CNID:\n\t\ttree = HFS_SB(sb)->ext_tree;\n\t\tbreak;\n\tcase HFS_CAT_CNID:\n\t\ttree = HFS_SB(sb)->cat_tree;\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t\treturn 0;\n\t}\n\n\tif (!tree)\n\t\treturn 0;\n\n\tif (tree->node_size >= PAGE_CACHE_SIZE) {\n\t\tnidx = page->index >> (tree->node_size_shift - PAGE_CACHE_SHIFT);\n\t\tspin_lock(&tree->hash_lock);\n\t\tnode = hfs_bnode_findhash(tree, nidx);\n\t\tif (!node)\n\t\t\t;\n\t\telse if (atomic_read(&node->refcnt))\n\t\t\tres = 0;\n\t\tif (res && node) {\n\t\t\thfs_bnode_unhash(node);\n\t\t\thfs_bnode_free(node);\n\t\t}\n\t\tspin_unlock(&tree->hash_lock);\n\t} else {\n\t\tnidx = page->index << (PAGE_CACHE_SHIFT - tree->node_size_shift);\n\t\ti = 1 << (PAGE_CACHE_SHIFT - tree->node_size_shift);\n\t\tspin_lock(&tree->hash_lock);\n\t\tdo {\n\t\t\tnode = hfs_bnode_findhash(tree, nidx++);\n\t\t\tif (!node)\n\t\t\t\tcontinue;\n\t\t\tif (atomic_read(&node->refcnt)) {\n\t\t\t\tres = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\thfs_bnode_unhash(node);\n\t\t\thfs_bnode_free(node);\n\t\t} while (--i && nidx < tree->node_count);\n\t\tspin_unlock(&tree->hash_lock);\n\t}\n\treturn res ? try_to_free_buffers(page) : 0;\n}"
  },
  {
    "function_name": "hfs_bmap",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfs/inode.c",
    "lines": "65-68",
    "snippet": "static sector_t hfs_bmap(struct address_space *mapping, sector_t block)\n{\n\treturn generic_block_bmap(mapping, block, hfs_get_block);\n}",
    "includes": [
      "#include \"btree.h\"",
      "#include \"hfs_fs.h\"",
      "#include <linux/aio.h>",
      "#include <linux/sched.h>",
      "#include <linux/mpage.h>",
      "#include <linux/pagemap.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "generic_block_bmap",
          "args": [
            "mapping",
            "block",
            "hfs_get_block"
          ],
          "line": 67
        },
        "resolved": true,
        "details": {
          "function_name": "generic_block_bmap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "2924-2934",
          "snippet": "sector_t generic_block_bmap(struct address_space *mapping, sector_t block,\n\t\t\t    get_block_t *get_block)\n{\n\tstruct buffer_head tmp;\n\tstruct inode *inode = mapping->host;\n\ttmp.b_state = 0;\n\ttmp.b_blocknr = 0;\n\ttmp.b_size = 1 << inode->i_blkbits;\n\tget_block(inode, block, &tmp, 0);\n\treturn tmp.b_blocknr;\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nsector_t generic_block_bmap(struct address_space *mapping, sector_t block,\n\t\t\t    get_block_t *get_block)\n{\n\tstruct buffer_head tmp;\n\tstruct inode *inode = mapping->host;\n\ttmp.b_state = 0;\n\ttmp.b_blocknr = 0;\n\ttmp.b_size = 1 << inode->i_blkbits;\n\tget_block(inode, block, &tmp, 0);\n\treturn tmp.b_blocknr;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"btree.h\"\n#include \"hfs_fs.h\"\n#include <linux/aio.h>\n#include <linux/sched.h>\n#include <linux/mpage.h>\n#include <linux/pagemap.h>\n\nstatic sector_t hfs_bmap(struct address_space *mapping, sector_t block)\n{\n\treturn generic_block_bmap(mapping, block, hfs_get_block);\n}"
  },
  {
    "function_name": "hfs_write_begin",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfs/inode.c",
    "lines": "49-63",
    "snippet": "static int hfs_write_begin(struct file *file, struct address_space *mapping,\n\t\t\tloff_t pos, unsigned len, unsigned flags,\n\t\t\tstruct page **pagep, void **fsdata)\n{\n\tint ret;\n\n\t*pagep = NULL;\n\tret = cont_write_begin(file, mapping, pos, len, flags, pagep, fsdata,\n\t\t\t\thfs_get_block,\n\t\t\t\t&HFS_I(mapping->host)->phys_size);\n\tif (unlikely(ret))\n\t\thfs_write_failed(mapping, pos + len);\n\n\treturn ret;\n}",
    "includes": [
      "#include \"btree.h\"",
      "#include \"hfs_fs.h\"",
      "#include <linux/aio.h>",
      "#include <linux/sched.h>",
      "#include <linux/mpage.h>",
      "#include <linux/pagemap.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "hfs_write_failed",
          "args": [
            "mapping",
            "pos + len"
          ],
          "line": 60
        },
        "resolved": true,
        "details": {
          "function_name": "hfs_write_failed",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfs/inode.c",
          "lines": "39-47",
          "snippet": "static void hfs_write_failed(struct address_space *mapping, loff_t to)\n{\n\tstruct inode *inode = mapping->host;\n\n\tif (to > inode->i_size) {\n\t\ttruncate_pagecache(inode, inode->i_size);\n\t\thfs_file_truncate(inode);\n\t}\n}",
          "includes": [
            "#include \"btree.h\"",
            "#include \"hfs_fs.h\"",
            "#include <linux/aio.h>",
            "#include <linux/sched.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"btree.h\"\n#include \"hfs_fs.h\"\n#include <linux/aio.h>\n#include <linux/sched.h>\n#include <linux/mpage.h>\n#include <linux/pagemap.h>\n\nstatic void hfs_write_failed(struct address_space *mapping, loff_t to)\n{\n\tstruct inode *inode = mapping->host;\n\n\tif (to > inode->i_size) {\n\t\ttruncate_pagecache(inode, inode->i_size);\n\t\thfs_file_truncate(inode);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "ret"
          ],
          "line": 59
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cont_write_begin",
          "args": [
            "file",
            "mapping",
            "pos",
            "len",
            "flags",
            "pagep",
            "fsdata",
            "hfs_get_block",
            "&HFS_I(mapping->host)->phys_size"
          ],
          "line": 56
        },
        "resolved": true,
        "details": {
          "function_name": "cont_write_begin",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "2352-2373",
          "snippet": "int cont_write_begin(struct file *file, struct address_space *mapping,\n\t\t\tloff_t pos, unsigned len, unsigned flags,\n\t\t\tstruct page **pagep, void **fsdata,\n\t\t\tget_block_t *get_block, loff_t *bytes)\n{\n\tstruct inode *inode = mapping->host;\n\tunsigned blocksize = 1 << inode->i_blkbits;\n\tunsigned zerofrom;\n\tint err;\n\n\terr = cont_expand_zero(file, mapping, pos, bytes);\n\tif (err)\n\t\treturn err;\n\n\tzerofrom = *bytes & ~PAGE_CACHE_MASK;\n\tif (pos+len > *bytes && zerofrom & (blocksize-1)) {\n\t\t*bytes |= (blocksize-1);\n\t\t(*bytes)++;\n\t}\n\n\treturn block_write_begin(mapping, pos, len, flags, pagep, get_block);\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nint cont_write_begin(struct file *file, struct address_space *mapping,\n\t\t\tloff_t pos, unsigned len, unsigned flags,\n\t\t\tstruct page **pagep, void **fsdata,\n\t\t\tget_block_t *get_block, loff_t *bytes)\n{\n\tstruct inode *inode = mapping->host;\n\tunsigned blocksize = 1 << inode->i_blkbits;\n\tunsigned zerofrom;\n\tint err;\n\n\terr = cont_expand_zero(file, mapping, pos, bytes);\n\tif (err)\n\t\treturn err;\n\n\tzerofrom = *bytes & ~PAGE_CACHE_MASK;\n\tif (pos+len > *bytes && zerofrom & (blocksize-1)) {\n\t\t*bytes |= (blocksize-1);\n\t\t(*bytes)++;\n\t}\n\n\treturn block_write_begin(mapping, pos, len, flags, pagep, get_block);\n}"
        }
      },
      {
        "call_info": {
          "callee": "HFS_I",
          "args": [
            "mapping->host"
          ],
          "line": 58
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"btree.h\"\n#include \"hfs_fs.h\"\n#include <linux/aio.h>\n#include <linux/sched.h>\n#include <linux/mpage.h>\n#include <linux/pagemap.h>\n\nstatic int hfs_write_begin(struct file *file, struct address_space *mapping,\n\t\t\tloff_t pos, unsigned len, unsigned flags,\n\t\t\tstruct page **pagep, void **fsdata)\n{\n\tint ret;\n\n\t*pagep = NULL;\n\tret = cont_write_begin(file, mapping, pos, len, flags, pagep, fsdata,\n\t\t\t\thfs_get_block,\n\t\t\t\t&HFS_I(mapping->host)->phys_size);\n\tif (unlikely(ret))\n\t\thfs_write_failed(mapping, pos + len);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "hfs_write_failed",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfs/inode.c",
    "lines": "39-47",
    "snippet": "static void hfs_write_failed(struct address_space *mapping, loff_t to)\n{\n\tstruct inode *inode = mapping->host;\n\n\tif (to > inode->i_size) {\n\t\ttruncate_pagecache(inode, inode->i_size);\n\t\thfs_file_truncate(inode);\n\t}\n}",
    "includes": [
      "#include \"btree.h\"",
      "#include \"hfs_fs.h\"",
      "#include <linux/aio.h>",
      "#include <linux/sched.h>",
      "#include <linux/mpage.h>",
      "#include <linux/pagemap.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "hfs_file_truncate",
          "args": [
            "inode"
          ],
          "line": 45
        },
        "resolved": true,
        "details": {
          "function_name": "hfs_file_truncate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfs/extent.c",
          "lines": "470-545",
          "snippet": "void hfs_file_truncate(struct inode *inode)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tstruct hfs_find_data fd;\n\tu16 blk_cnt, alloc_cnt, start;\n\tu32 size;\n\tint res;\n\n\thfs_dbg(INODE, \"truncate: %lu, %Lu -> %Lu\\n\",\n\t\tinode->i_ino, (long long)HFS_I(inode)->phys_size,\n\t\tinode->i_size);\n\tif (inode->i_size > HFS_I(inode)->phys_size) {\n\t\tstruct address_space *mapping = inode->i_mapping;\n\t\tvoid *fsdata;\n\t\tstruct page *page;\n\n\t\t/* XXX: Can use generic_cont_expand? */\n\t\tsize = inode->i_size - 1;\n\t\tres = pagecache_write_begin(NULL, mapping, size+1, 0,\n\t\t\t\tAOP_FLAG_UNINTERRUPTIBLE, &page, &fsdata);\n\t\tif (!res) {\n\t\t\tres = pagecache_write_end(NULL, mapping, size+1, 0, 0,\n\t\t\t\t\tpage, fsdata);\n\t\t}\n\t\tif (res)\n\t\t\tinode->i_size = HFS_I(inode)->phys_size;\n\t\treturn;\n\t} else if (inode->i_size == HFS_I(inode)->phys_size)\n\t\treturn;\n\tsize = inode->i_size + HFS_SB(sb)->alloc_blksz - 1;\n\tblk_cnt = size / HFS_SB(sb)->alloc_blksz;\n\talloc_cnt = HFS_I(inode)->alloc_blocks;\n\tif (blk_cnt == alloc_cnt)\n\t\tgoto out;\n\n\tmutex_lock(&HFS_I(inode)->extents_lock);\n\tres = hfs_find_init(HFS_SB(sb)->ext_tree, &fd);\n\tif (res) {\n\t\tmutex_unlock(&HFS_I(inode)->extents_lock);\n\t\t/* XXX: We lack error handling of hfs_file_truncate() */\n\t\treturn;\n\t}\n\twhile (1) {\n\t\tif (alloc_cnt == HFS_I(inode)->first_blocks) {\n\t\t\thfs_free_extents(sb, HFS_I(inode)->first_extents,\n\t\t\t\t\t alloc_cnt, alloc_cnt - blk_cnt);\n\t\t\thfs_dump_extent(HFS_I(inode)->first_extents);\n\t\t\tHFS_I(inode)->first_blocks = blk_cnt;\n\t\t\tbreak;\n\t\t}\n\t\tres = __hfs_ext_cache_extent(&fd, inode, alloc_cnt);\n\t\tif (res)\n\t\t\tbreak;\n\t\tstart = HFS_I(inode)->cached_start;\n\t\thfs_free_extents(sb, HFS_I(inode)->cached_extents,\n\t\t\t\t alloc_cnt - start, alloc_cnt - blk_cnt);\n\t\thfs_dump_extent(HFS_I(inode)->cached_extents);\n\t\tif (blk_cnt > start) {\n\t\t\tHFS_I(inode)->flags |= HFS_FLG_EXT_DIRTY;\n\t\t\tbreak;\n\t\t}\n\t\talloc_cnt = start;\n\t\tHFS_I(inode)->cached_start = HFS_I(inode)->cached_blocks = 0;\n\t\tHFS_I(inode)->flags &= ~(HFS_FLG_EXT_DIRTY|HFS_FLG_EXT_NEW);\n\t\thfs_brec_remove(&fd);\n\t}\n\thfs_find_exit(&fd);\n\tmutex_unlock(&HFS_I(inode)->extents_lock);\n\n\tHFS_I(inode)->alloc_blocks = blk_cnt;\nout:\n\tHFS_I(inode)->phys_size = inode->i_size;\n\tHFS_I(inode)->fs_blocks = (inode->i_size + sb->s_blocksize - 1) >> sb->s_blocksize_bits;\n\tinode_set_bytes(inode, HFS_I(inode)->fs_blocks << sb->s_blocksize_bits);\n\tmark_inode_dirty(inode);\n}",
          "includes": [
            "#include \"btree.h\"",
            "#include \"hfs_fs.h\"",
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"btree.h\"\n#include \"hfs_fs.h\"\n#include <linux/pagemap.h>\n\nvoid hfs_file_truncate(struct inode *inode)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tstruct hfs_find_data fd;\n\tu16 blk_cnt, alloc_cnt, start;\n\tu32 size;\n\tint res;\n\n\thfs_dbg(INODE, \"truncate: %lu, %Lu -> %Lu\\n\",\n\t\tinode->i_ino, (long long)HFS_I(inode)->phys_size,\n\t\tinode->i_size);\n\tif (inode->i_size > HFS_I(inode)->phys_size) {\n\t\tstruct address_space *mapping = inode->i_mapping;\n\t\tvoid *fsdata;\n\t\tstruct page *page;\n\n\t\t/* XXX: Can use generic_cont_expand? */\n\t\tsize = inode->i_size - 1;\n\t\tres = pagecache_write_begin(NULL, mapping, size+1, 0,\n\t\t\t\tAOP_FLAG_UNINTERRUPTIBLE, &page, &fsdata);\n\t\tif (!res) {\n\t\t\tres = pagecache_write_end(NULL, mapping, size+1, 0, 0,\n\t\t\t\t\tpage, fsdata);\n\t\t}\n\t\tif (res)\n\t\t\tinode->i_size = HFS_I(inode)->phys_size;\n\t\treturn;\n\t} else if (inode->i_size == HFS_I(inode)->phys_size)\n\t\treturn;\n\tsize = inode->i_size + HFS_SB(sb)->alloc_blksz - 1;\n\tblk_cnt = size / HFS_SB(sb)->alloc_blksz;\n\talloc_cnt = HFS_I(inode)->alloc_blocks;\n\tif (blk_cnt == alloc_cnt)\n\t\tgoto out;\n\n\tmutex_lock(&HFS_I(inode)->extents_lock);\n\tres = hfs_find_init(HFS_SB(sb)->ext_tree, &fd);\n\tif (res) {\n\t\tmutex_unlock(&HFS_I(inode)->extents_lock);\n\t\t/* XXX: We lack error handling of hfs_file_truncate() */\n\t\treturn;\n\t}\n\twhile (1) {\n\t\tif (alloc_cnt == HFS_I(inode)->first_blocks) {\n\t\t\thfs_free_extents(sb, HFS_I(inode)->first_extents,\n\t\t\t\t\t alloc_cnt, alloc_cnt - blk_cnt);\n\t\t\thfs_dump_extent(HFS_I(inode)->first_extents);\n\t\t\tHFS_I(inode)->first_blocks = blk_cnt;\n\t\t\tbreak;\n\t\t}\n\t\tres = __hfs_ext_cache_extent(&fd, inode, alloc_cnt);\n\t\tif (res)\n\t\t\tbreak;\n\t\tstart = HFS_I(inode)->cached_start;\n\t\thfs_free_extents(sb, HFS_I(inode)->cached_extents,\n\t\t\t\t alloc_cnt - start, alloc_cnt - blk_cnt);\n\t\thfs_dump_extent(HFS_I(inode)->cached_extents);\n\t\tif (blk_cnt > start) {\n\t\t\tHFS_I(inode)->flags |= HFS_FLG_EXT_DIRTY;\n\t\t\tbreak;\n\t\t}\n\t\talloc_cnt = start;\n\t\tHFS_I(inode)->cached_start = HFS_I(inode)->cached_blocks = 0;\n\t\tHFS_I(inode)->flags &= ~(HFS_FLG_EXT_DIRTY|HFS_FLG_EXT_NEW);\n\t\thfs_brec_remove(&fd);\n\t}\n\thfs_find_exit(&fd);\n\tmutex_unlock(&HFS_I(inode)->extents_lock);\n\n\tHFS_I(inode)->alloc_blocks = blk_cnt;\nout:\n\tHFS_I(inode)->phys_size = inode->i_size;\n\tHFS_I(inode)->fs_blocks = (inode->i_size + sb->s_blocksize - 1) >> sb->s_blocksize_bits;\n\tinode_set_bytes(inode, HFS_I(inode)->fs_blocks << sb->s_blocksize_bits);\n\tmark_inode_dirty(inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "truncate_pagecache",
          "args": [
            "inode",
            "inode->i_size"
          ],
          "line": 44
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"btree.h\"\n#include \"hfs_fs.h\"\n#include <linux/aio.h>\n#include <linux/sched.h>\n#include <linux/mpage.h>\n#include <linux/pagemap.h>\n\nstatic void hfs_write_failed(struct address_space *mapping, loff_t to)\n{\n\tstruct inode *inode = mapping->host;\n\n\tif (to > inode->i_size) {\n\t\ttruncate_pagecache(inode, inode->i_size);\n\t\thfs_file_truncate(inode);\n\t}\n}"
  },
  {
    "function_name": "hfs_readpage",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfs/inode.c",
    "lines": "34-37",
    "snippet": "static int hfs_readpage(struct file *file, struct page *page)\n{\n\treturn block_read_full_page(page, hfs_get_block);\n}",
    "includes": [
      "#include \"btree.h\"",
      "#include \"hfs_fs.h\"",
      "#include <linux/aio.h>",
      "#include <linux/sched.h>",
      "#include <linux/mpage.h>",
      "#include <linux/pagemap.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "block_read_full_page",
          "args": [
            "page",
            "hfs_get_block"
          ],
          "line": 36
        },
        "resolved": true,
        "details": {
          "function_name": "block_read_full_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "2159-2242",
          "snippet": "int block_read_full_page(struct page *page, get_block_t *get_block)\n{\n\tstruct inode *inode = page->mapping->host;\n\tsector_t iblock, lblock;\n\tstruct buffer_head *bh, *head, *arr[MAX_BUF_PER_PAGE];\n\tunsigned int blocksize, bbits;\n\tint nr, i;\n\tint fully_mapped = 1;\n\n\thead = create_page_buffers(page, inode, 0);\n\tblocksize = head->b_size;\n\tbbits = block_size_bits(blocksize);\n\n\tiblock = (sector_t)page->index << (PAGE_CACHE_SHIFT - bbits);\n\tlblock = (i_size_read(inode)+blocksize-1) >> bbits;\n\tbh = head;\n\tnr = 0;\n\ti = 0;\n\n\tdo {\n\t\tif (buffer_uptodate(bh))\n\t\t\tcontinue;\n\n\t\tif (!buffer_mapped(bh)) {\n\t\t\tint err = 0;\n\n\t\t\tfully_mapped = 0;\n\t\t\tif (iblock < lblock) {\n\t\t\t\tWARN_ON(bh->b_size != blocksize);\n\t\t\t\terr = get_block(inode, iblock, bh, 0);\n\t\t\t\tif (err)\n\t\t\t\t\tSetPageError(page);\n\t\t\t}\n\t\t\tif (!buffer_mapped(bh)) {\n\t\t\t\tzero_user(page, i * blocksize, blocksize);\n\t\t\t\tif (!err)\n\t\t\t\t\tset_buffer_uptodate(bh);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t/*\n\t\t\t * get_block() might have updated the buffer\n\t\t\t * synchronously\n\t\t\t */\n\t\t\tif (buffer_uptodate(bh))\n\t\t\t\tcontinue;\n\t\t}\n\t\tarr[nr++] = bh;\n\t} while (i++, iblock++, (bh = bh->b_this_page) != head);\n\n\tif (fully_mapped)\n\t\tSetPageMappedToDisk(page);\n\n\tif (!nr) {\n\t\t/*\n\t\t * All buffers are uptodate - we can set the page uptodate\n\t\t * as well. But not if get_block() returned an error.\n\t\t */\n\t\tif (!PageError(page))\n\t\t\tSetPageUptodate(page);\n\t\tunlock_page(page);\n\t\treturn 0;\n\t}\n\n\t/* Stage two: lock the buffers */\n\tfor (i = 0; i < nr; i++) {\n\t\tbh = arr[i];\n\t\tlock_buffer(bh);\n\t\tmark_buffer_async_read(bh);\n\t}\n\n\t/*\n\t * Stage 3: start the IO.  Check for uptodateness\n\t * inside the buffer lock in case another process reading\n\t * the underlying blockdev brought it uptodate (the sct fix).\n\t */\n\tfor (i = 0; i < nr; i++) {\n\t\tbh = arr[i];\n\t\tif (buffer_uptodate(bh))\n\t\t\tend_buffer_async_read(bh, 1);\n\t\telse\n\t\t\tsubmit_bh(READ, bh);\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nint block_read_full_page(struct page *page, get_block_t *get_block)\n{\n\tstruct inode *inode = page->mapping->host;\n\tsector_t iblock, lblock;\n\tstruct buffer_head *bh, *head, *arr[MAX_BUF_PER_PAGE];\n\tunsigned int blocksize, bbits;\n\tint nr, i;\n\tint fully_mapped = 1;\n\n\thead = create_page_buffers(page, inode, 0);\n\tblocksize = head->b_size;\n\tbbits = block_size_bits(blocksize);\n\n\tiblock = (sector_t)page->index << (PAGE_CACHE_SHIFT - bbits);\n\tlblock = (i_size_read(inode)+blocksize-1) >> bbits;\n\tbh = head;\n\tnr = 0;\n\ti = 0;\n\n\tdo {\n\t\tif (buffer_uptodate(bh))\n\t\t\tcontinue;\n\n\t\tif (!buffer_mapped(bh)) {\n\t\t\tint err = 0;\n\n\t\t\tfully_mapped = 0;\n\t\t\tif (iblock < lblock) {\n\t\t\t\tWARN_ON(bh->b_size != blocksize);\n\t\t\t\terr = get_block(inode, iblock, bh, 0);\n\t\t\t\tif (err)\n\t\t\t\t\tSetPageError(page);\n\t\t\t}\n\t\t\tif (!buffer_mapped(bh)) {\n\t\t\t\tzero_user(page, i * blocksize, blocksize);\n\t\t\t\tif (!err)\n\t\t\t\t\tset_buffer_uptodate(bh);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t/*\n\t\t\t * get_block() might have updated the buffer\n\t\t\t * synchronously\n\t\t\t */\n\t\t\tif (buffer_uptodate(bh))\n\t\t\t\tcontinue;\n\t\t}\n\t\tarr[nr++] = bh;\n\t} while (i++, iblock++, (bh = bh->b_this_page) != head);\n\n\tif (fully_mapped)\n\t\tSetPageMappedToDisk(page);\n\n\tif (!nr) {\n\t\t/*\n\t\t * All buffers are uptodate - we can set the page uptodate\n\t\t * as well. But not if get_block() returned an error.\n\t\t */\n\t\tif (!PageError(page))\n\t\t\tSetPageUptodate(page);\n\t\tunlock_page(page);\n\t\treturn 0;\n\t}\n\n\t/* Stage two: lock the buffers */\n\tfor (i = 0; i < nr; i++) {\n\t\tbh = arr[i];\n\t\tlock_buffer(bh);\n\t\tmark_buffer_async_read(bh);\n\t}\n\n\t/*\n\t * Stage 3: start the IO.  Check for uptodateness\n\t * inside the buffer lock in case another process reading\n\t * the underlying blockdev brought it uptodate (the sct fix).\n\t */\n\tfor (i = 0; i < nr; i++) {\n\t\tbh = arr[i];\n\t\tif (buffer_uptodate(bh))\n\t\t\tend_buffer_async_read(bh, 1);\n\t\telse\n\t\t\tsubmit_bh(READ, bh);\n\t}\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"btree.h\"\n#include \"hfs_fs.h\"\n#include <linux/aio.h>\n#include <linux/sched.h>\n#include <linux/mpage.h>\n#include <linux/pagemap.h>\n\nstatic int hfs_readpage(struct file *file, struct page *page)\n{\n\treturn block_read_full_page(page, hfs_get_block);\n}"
  },
  {
    "function_name": "hfs_writepage",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfs/inode.c",
    "lines": "29-32",
    "snippet": "static int hfs_writepage(struct page *page, struct writeback_control *wbc)\n{\n\treturn block_write_full_page(page, hfs_get_block, wbc);\n}",
    "includes": [
      "#include \"btree.h\"",
      "#include \"hfs_fs.h\"",
      "#include <linux/aio.h>",
      "#include <linux/sched.h>",
      "#include <linux/mpage.h>",
      "#include <linux/pagemap.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "block_write_full_page",
          "args": [
            "page",
            "hfs_get_block",
            "wbc"
          ],
          "line": 31
        },
        "resolved": true,
        "details": {
          "function_name": "block_write_full_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "2885-2921",
          "snippet": "int block_write_full_page(struct page *page, get_block_t *get_block,\n\t\t\tstruct writeback_control *wbc)\n{\n\tstruct inode * const inode = page->mapping->host;\n\tloff_t i_size = i_size_read(inode);\n\tconst pgoff_t end_index = i_size >> PAGE_CACHE_SHIFT;\n\tunsigned offset;\n\n\t/* Is the page fully inside i_size? */\n\tif (page->index < end_index)\n\t\treturn __block_write_full_page(inode, page, get_block, wbc,\n\t\t\t\t\t       end_buffer_async_write);\n\n\t/* Is the page fully outside i_size? (truncate in progress) */\n\toffset = i_size & (PAGE_CACHE_SIZE-1);\n\tif (page->index >= end_index+1 || !offset) {\n\t\t/*\n\t\t * The page may have dirty, unmapped buffers.  For example,\n\t\t * they may have been added in ext3_writepage().  Make them\n\t\t * freeable here, so the page does not leak.\n\t\t */\n\t\tdo_invalidatepage(page, 0, PAGE_CACHE_SIZE);\n\t\tunlock_page(page);\n\t\treturn 0; /* don't care */\n\t}\n\n\t/*\n\t * The page straddles i_size.  It must be zeroed out on each and every\n\t * writepage invocation because it may be mmapped.  \"A file is mapped\n\t * in multiples of the page size.  For a file that is not a multiple of\n\t * the  page size, the remaining memory is zeroed when mapped, and\n\t * writes to that region are not written out to the file.\"\n\t */\n\tzero_user_segment(page, offset, PAGE_CACHE_SIZE);\n\treturn __block_write_full_page(inode, page, get_block, wbc,\n\t\t\t\t\t\t\tend_buffer_async_write);\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nint block_write_full_page(struct page *page, get_block_t *get_block,\n\t\t\tstruct writeback_control *wbc)\n{\n\tstruct inode * const inode = page->mapping->host;\n\tloff_t i_size = i_size_read(inode);\n\tconst pgoff_t end_index = i_size >> PAGE_CACHE_SHIFT;\n\tunsigned offset;\n\n\t/* Is the page fully inside i_size? */\n\tif (page->index < end_index)\n\t\treturn __block_write_full_page(inode, page, get_block, wbc,\n\t\t\t\t\t       end_buffer_async_write);\n\n\t/* Is the page fully outside i_size? (truncate in progress) */\n\toffset = i_size & (PAGE_CACHE_SIZE-1);\n\tif (page->index >= end_index+1 || !offset) {\n\t\t/*\n\t\t * The page may have dirty, unmapped buffers.  For example,\n\t\t * they may have been added in ext3_writepage().  Make them\n\t\t * freeable here, so the page does not leak.\n\t\t */\n\t\tdo_invalidatepage(page, 0, PAGE_CACHE_SIZE);\n\t\tunlock_page(page);\n\t\treturn 0; /* don't care */\n\t}\n\n\t/*\n\t * The page straddles i_size.  It must be zeroed out on each and every\n\t * writepage invocation because it may be mmapped.  \"A file is mapped\n\t * in multiples of the page size.  For a file that is not a multiple of\n\t * the  page size, the remaining memory is zeroed when mapped, and\n\t * writes to that region are not written out to the file.\"\n\t */\n\tzero_user_segment(page, offset, PAGE_CACHE_SIZE);\n\treturn __block_write_full_page(inode, page, get_block, wbc,\n\t\t\t\t\t\t\tend_buffer_async_write);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"btree.h\"\n#include \"hfs_fs.h\"\n#include <linux/aio.h>\n#include <linux/sched.h>\n#include <linux/mpage.h>\n#include <linux/pagemap.h>\n\nstatic int hfs_writepage(struct page *page, struct writeback_control *wbc)\n{\n\treturn block_write_full_page(page, hfs_get_block, wbc);\n}"
  }
]