[
  {
    "function_name": "xfs_attr_list",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_attr_list.c",
    "lines": "600-650",
    "snippet": "int\nxfs_attr_list(\n\txfs_inode_t\t*dp,\n\tchar\t\t*buffer,\n\tint\t\tbufsize,\n\tint\t\tflags,\n\tattrlist_cursor_kern_t *cursor)\n{\n\txfs_attr_list_context_t context;\n\tstruct attrlist *alist;\n\tint error;\n\n\t/*\n\t * Validate the cursor.\n\t */\n\tif (cursor->pad1 || cursor->pad2)\n\t\treturn -EINVAL;\n\tif ((cursor->initted == 0) &&\n\t    (cursor->hashval || cursor->blkno || cursor->offset))\n\t\treturn -EINVAL;\n\n\t/*\n\t * Check for a properly aligned buffer.\n\t */\n\tif (((long)buffer) & (sizeof(int)-1))\n\t\treturn -EFAULT;\n\tif (flags & ATTR_KERNOVAL)\n\t\tbufsize = 0;\n\n\t/*\n\t * Initialize the output buffer.\n\t */\n\tmemset(&context, 0, sizeof(context));\n\tcontext.dp = dp;\n\tcontext.cursor = cursor;\n\tcontext.resynch = 1;\n\tcontext.flags = flags;\n\tcontext.alist = buffer;\n\tcontext.bufsize = (bufsize & ~(sizeof(int)-1));  /* align */\n\tcontext.firstu = context.bufsize;\n\tcontext.put_listent = xfs_attr_put_listent;\n\n\talist = (struct attrlist *)context.alist;\n\talist->al_count = 0;\n\talist->al_more = 0;\n\talist->al_offset[0] = context.bufsize;\n\n\terror = xfs_attr_list_int(&context);\n\tASSERT(error <= 0);\n\treturn error;\n}",
    "includes": [
      "#include \"xfs_dir2.h\"",
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_buf_item.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_attr_leaf.h\"",
      "#include \"xfs_attr_remote.h\"",
      "#include \"xfs_attr_sf.h\"",
      "#include \"xfs_attr.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_inode_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_da_btree.h\"",
      "#include \"xfs_da_format.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_bit.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "error <= 0"
          ],
          "line": 648
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_attr_list_int",
          "args": [
            "&context"
          ],
          "line": 647
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_attr_list_int",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_attr_list.c",
          "lines": "503-531",
          "snippet": "int\nxfs_attr_list_int(\n\txfs_attr_list_context_t *context)\n{\n\tint error;\n\txfs_inode_t *dp = context->dp;\n\tuint\t\tlock_mode;\n\n\tXFS_STATS_INC(xs_attr_list);\n\n\tif (XFS_FORCED_SHUTDOWN(dp->i_mount))\n\t\treturn -EIO;\n\n\t/*\n\t * Decide on what work routines to call based on the inode size.\n\t */\n\tlock_mode = xfs_ilock_attr_map_shared(dp);\n\tif (!xfs_inode_hasattr(dp)) {\n\t\terror = 0;\n\t} else if (dp->i_d.di_aformat == XFS_DINODE_FMT_LOCAL) {\n\t\terror = xfs_attr_shortform_list(context);\n\t} else if (xfs_bmap_one_block(dp, XFS_ATTR_FORK)) {\n\t\terror = xfs_attr_leaf_list(context);\n\t} else {\n\t\terror = xfs_attr_node_list(context);\n\t}\n\txfs_iunlock(dp, lock_mode);\n\treturn error;\n}",
          "includes": [
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_attr_leaf.h\"",
            "#include \"xfs_attr_remote.h\"",
            "#include \"xfs_attr_sf.h\"",
            "#include \"xfs_attr.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_dir2.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_attr_leaf.h\"\n#include \"xfs_attr_remote.h\"\n#include \"xfs_attr_sf.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\nxfs_attr_list_int(\n\txfs_attr_list_context_t *context)\n{\n\tint error;\n\txfs_inode_t *dp = context->dp;\n\tuint\t\tlock_mode;\n\n\tXFS_STATS_INC(xs_attr_list);\n\n\tif (XFS_FORCED_SHUTDOWN(dp->i_mount))\n\t\treturn -EIO;\n\n\t/*\n\t * Decide on what work routines to call based on the inode size.\n\t */\n\tlock_mode = xfs_ilock_attr_map_shared(dp);\n\tif (!xfs_inode_hasattr(dp)) {\n\t\terror = 0;\n\t} else if (dp->i_d.di_aformat == XFS_DINODE_FMT_LOCAL) {\n\t\terror = xfs_attr_shortform_list(context);\n\t} else if (xfs_bmap_one_block(dp, XFS_ATTR_FORK)) {\n\t\terror = xfs_attr_leaf_list(context);\n\t} else {\n\t\terror = xfs_attr_node_list(context);\n\t}\n\txfs_iunlock(dp, lock_mode);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&context",
            "0",
            "sizeof(context)"
          ],
          "line": 632
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_dir2.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_attr_leaf.h\"\n#include \"xfs_attr_remote.h\"\n#include \"xfs_attr_sf.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\nxfs_attr_list(\n\txfs_inode_t\t*dp,\n\tchar\t\t*buffer,\n\tint\t\tbufsize,\n\tint\t\tflags,\n\tattrlist_cursor_kern_t *cursor)\n{\n\txfs_attr_list_context_t context;\n\tstruct attrlist *alist;\n\tint error;\n\n\t/*\n\t * Validate the cursor.\n\t */\n\tif (cursor->pad1 || cursor->pad2)\n\t\treturn -EINVAL;\n\tif ((cursor->initted == 0) &&\n\t    (cursor->hashval || cursor->blkno || cursor->offset))\n\t\treturn -EINVAL;\n\n\t/*\n\t * Check for a properly aligned buffer.\n\t */\n\tif (((long)buffer) & (sizeof(int)-1))\n\t\treturn -EFAULT;\n\tif (flags & ATTR_KERNOVAL)\n\t\tbufsize = 0;\n\n\t/*\n\t * Initialize the output buffer.\n\t */\n\tmemset(&context, 0, sizeof(context));\n\tcontext.dp = dp;\n\tcontext.cursor = cursor;\n\tcontext.resynch = 1;\n\tcontext.flags = flags;\n\tcontext.alist = buffer;\n\tcontext.bufsize = (bufsize & ~(sizeof(int)-1));  /* align */\n\tcontext.firstu = context.bufsize;\n\tcontext.put_listent = xfs_attr_put_listent;\n\n\talist = (struct attrlist *)context.alist;\n\talist->al_count = 0;\n\talist->al_more = 0;\n\talist->al_offset[0] = context.bufsize;\n\n\terror = xfs_attr_list_int(&context);\n\tASSERT(error <= 0);\n\treturn error;\n}"
  },
  {
    "function_name": "xfs_attr_put_listent",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_attr_list.c",
    "lines": "544-591",
    "snippet": "STATIC int\nxfs_attr_put_listent(\n\txfs_attr_list_context_t *context,\n\tint\t\tflags,\n\tunsigned char\t*name,\n\tint\t\tnamelen,\n\tint\t\tvaluelen,\n\tunsigned char\t*value)\n{\n\tstruct attrlist *alist = (struct attrlist *)context->alist;\n\tattrlist_ent_t *aep;\n\tint arraytop;\n\n\tASSERT(!(context->flags & ATTR_KERNOVAL));\n\tASSERT(context->count >= 0);\n\tASSERT(context->count < (ATTR_MAX_VALUELEN/8));\n\tASSERT(context->firstu >= sizeof(*alist));\n\tASSERT(context->firstu <= context->bufsize);\n\n\t/*\n\t * Only list entries in the right namespace.\n\t */\n\tif (((context->flags & ATTR_SECURE) == 0) !=\n\t    ((flags & XFS_ATTR_SECURE) == 0))\n\t\treturn 0;\n\tif (((context->flags & ATTR_ROOT) == 0) !=\n\t    ((flags & XFS_ATTR_ROOT) == 0))\n\t\treturn 0;\n\n\tarraytop = sizeof(*alist) +\n\t\t\tcontext->count * sizeof(alist->al_offset[0]);\n\tcontext->firstu -= ATTR_ENTSIZE(namelen);\n\tif (context->firstu < arraytop) {\n\t\ttrace_xfs_attr_list_full(context);\n\t\talist->al_more = 1;\n\t\tcontext->seen_enough = 1;\n\t\treturn 1;\n\t}\n\n\taep = (attrlist_ent_t *)&context->alist[context->firstu];\n\taep->a_valuelen = valuelen;\n\tmemcpy(aep->a_name, name, namelen);\n\taep->a_name[namelen] = 0;\n\talist->al_offset[context->count++] = context->firstu;\n\talist->al_count = context->count;\n\ttrace_xfs_attr_list_add(context);\n\treturn 0;\n}",
    "includes": [
      "#include \"xfs_dir2.h\"",
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_buf_item.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_attr_leaf.h\"",
      "#include \"xfs_attr_remote.h\"",
      "#include \"xfs_attr_sf.h\"",
      "#include \"xfs_attr.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_inode_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_da_btree.h\"",
      "#include \"xfs_da_format.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_bit.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "trace_xfs_attr_list_add",
          "args": [
            "context"
          ],
          "line": 589
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "aep->a_name",
            "name",
            "namelen"
          ],
          "line": 585
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_xfs_attr_list_full",
          "args": [
            "context"
          ],
          "line": 577
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ATTR_ENTSIZE",
          "args": [
            "namelen"
          ],
          "line": 575
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "context->firstu <= context->bufsize"
          ],
          "line": 561
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "context->firstu >= sizeof(*alist)"
          ],
          "line": 560
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "context->count < (ATTR_MAX_VALUELEN/8)"
          ],
          "line": 559
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "context->count >= 0"
          ],
          "line": 558
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "!(context->flags & ATTR_KERNOVAL)"
          ],
          "line": 557
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_dir2.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_attr_leaf.h\"\n#include \"xfs_attr_remote.h\"\n#include \"xfs_attr_sf.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC int\nxfs_attr_put_listent(\n\txfs_attr_list_context_t *context,\n\tint\t\tflags,\n\tunsigned char\t*name,\n\tint\t\tnamelen,\n\tint\t\tvaluelen,\n\tunsigned char\t*value)\n{\n\tstruct attrlist *alist = (struct attrlist *)context->alist;\n\tattrlist_ent_t *aep;\n\tint arraytop;\n\n\tASSERT(!(context->flags & ATTR_KERNOVAL));\n\tASSERT(context->count >= 0);\n\tASSERT(context->count < (ATTR_MAX_VALUELEN/8));\n\tASSERT(context->firstu >= sizeof(*alist));\n\tASSERT(context->firstu <= context->bufsize);\n\n\t/*\n\t * Only list entries in the right namespace.\n\t */\n\tif (((context->flags & ATTR_SECURE) == 0) !=\n\t    ((flags & XFS_ATTR_SECURE) == 0))\n\t\treturn 0;\n\tif (((context->flags & ATTR_ROOT) == 0) !=\n\t    ((flags & XFS_ATTR_ROOT) == 0))\n\t\treturn 0;\n\n\tarraytop = sizeof(*alist) +\n\t\t\tcontext->count * sizeof(alist->al_offset[0]);\n\tcontext->firstu -= ATTR_ENTSIZE(namelen);\n\tif (context->firstu < arraytop) {\n\t\ttrace_xfs_attr_list_full(context);\n\t\talist->al_more = 1;\n\t\tcontext->seen_enough = 1;\n\t\treturn 1;\n\t}\n\n\taep = (attrlist_ent_t *)&context->alist[context->firstu];\n\taep->a_valuelen = valuelen;\n\tmemcpy(aep->a_name, name, namelen);\n\taep->a_name[namelen] = 0;\n\talist->al_offset[context->count++] = context->firstu;\n\talist->al_count = context->count;\n\ttrace_xfs_attr_list_add(context);\n\treturn 0;\n}"
  },
  {
    "function_name": "xfs_attr_list_int",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_attr_list.c",
    "lines": "503-531",
    "snippet": "int\nxfs_attr_list_int(\n\txfs_attr_list_context_t *context)\n{\n\tint error;\n\txfs_inode_t *dp = context->dp;\n\tuint\t\tlock_mode;\n\n\tXFS_STATS_INC(xs_attr_list);\n\n\tif (XFS_FORCED_SHUTDOWN(dp->i_mount))\n\t\treturn -EIO;\n\n\t/*\n\t * Decide on what work routines to call based on the inode size.\n\t */\n\tlock_mode = xfs_ilock_attr_map_shared(dp);\n\tif (!xfs_inode_hasattr(dp)) {\n\t\terror = 0;\n\t} else if (dp->i_d.di_aformat == XFS_DINODE_FMT_LOCAL) {\n\t\terror = xfs_attr_shortform_list(context);\n\t} else if (xfs_bmap_one_block(dp, XFS_ATTR_FORK)) {\n\t\terror = xfs_attr_leaf_list(context);\n\t} else {\n\t\terror = xfs_attr_node_list(context);\n\t}\n\txfs_iunlock(dp, lock_mode);\n\treturn error;\n}",
    "includes": [
      "#include \"xfs_dir2.h\"",
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_buf_item.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_attr_leaf.h\"",
      "#include \"xfs_attr_remote.h\"",
      "#include \"xfs_attr_sf.h\"",
      "#include \"xfs_attr.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_inode_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_da_btree.h\"",
      "#include \"xfs_da_format.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_bit.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_iunlock",
          "args": [
            "dp",
            "lock_mode"
          ],
          "line": 529
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_iunlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_inode.c",
          "lines": "235-263",
          "snippet": "void\nxfs_iunlock(\n\txfs_inode_t\t\t*ip,\n\tuint\t\t\tlock_flags)\n{\n\t/*\n\t * You can't set both SHARED and EXCL for the same lock,\n\t * and only XFS_IOLOCK_SHARED, XFS_IOLOCK_EXCL, XFS_ILOCK_SHARED,\n\t * and XFS_ILOCK_EXCL are valid values to set in lock_flags.\n\t */\n\tASSERT((lock_flags & (XFS_IOLOCK_SHARED | XFS_IOLOCK_EXCL)) !=\n\t       (XFS_IOLOCK_SHARED | XFS_IOLOCK_EXCL));\n\tASSERT((lock_flags & (XFS_ILOCK_SHARED | XFS_ILOCK_EXCL)) !=\n\t       (XFS_ILOCK_SHARED | XFS_ILOCK_EXCL));\n\tASSERT((lock_flags & ~(XFS_LOCK_MASK | XFS_LOCK_DEP_MASK)) == 0);\n\tASSERT(lock_flags != 0);\n\n\tif (lock_flags & XFS_IOLOCK_EXCL)\n\t\tmrunlock_excl(&ip->i_iolock);\n\telse if (lock_flags & XFS_IOLOCK_SHARED)\n\t\tmrunlock_shared(&ip->i_iolock);\n\n\tif (lock_flags & XFS_ILOCK_EXCL)\n\t\tmrunlock_excl(&ip->i_lock);\n\telse if (lock_flags & XFS_ILOCK_SHARED)\n\t\tmrunlock_shared(&ip->i_lock);\n\n\ttrace_xfs_iunlock(ip, lock_flags, _RET_IP_);\n}",
          "includes": [
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_symlink.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_filestream.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_attr.h\"",
            "#include \"xfs_attr_sf.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\"",
            "#include <linux/log2.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC int xfs_iunlink_remove(xfs_trans_t *, xfs_inode_t *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_bmap_btree.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_symlink.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_filestream.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_attr_sf.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n#include <linux/log2.h>\n\nSTATIC int xfs_iunlink_remove(xfs_trans_t *, xfs_inode_t *);\n\nvoid\nxfs_iunlock(\n\txfs_inode_t\t\t*ip,\n\tuint\t\t\tlock_flags)\n{\n\t/*\n\t * You can't set both SHARED and EXCL for the same lock,\n\t * and only XFS_IOLOCK_SHARED, XFS_IOLOCK_EXCL, XFS_ILOCK_SHARED,\n\t * and XFS_ILOCK_EXCL are valid values to set in lock_flags.\n\t */\n\tASSERT((lock_flags & (XFS_IOLOCK_SHARED | XFS_IOLOCK_EXCL)) !=\n\t       (XFS_IOLOCK_SHARED | XFS_IOLOCK_EXCL));\n\tASSERT((lock_flags & (XFS_ILOCK_SHARED | XFS_ILOCK_EXCL)) !=\n\t       (XFS_ILOCK_SHARED | XFS_ILOCK_EXCL));\n\tASSERT((lock_flags & ~(XFS_LOCK_MASK | XFS_LOCK_DEP_MASK)) == 0);\n\tASSERT(lock_flags != 0);\n\n\tif (lock_flags & XFS_IOLOCK_EXCL)\n\t\tmrunlock_excl(&ip->i_iolock);\n\telse if (lock_flags & XFS_IOLOCK_SHARED)\n\t\tmrunlock_shared(&ip->i_iolock);\n\n\tif (lock_flags & XFS_ILOCK_EXCL)\n\t\tmrunlock_excl(&ip->i_lock);\n\telse if (lock_flags & XFS_ILOCK_SHARED)\n\t\tmrunlock_shared(&ip->i_lock);\n\n\ttrace_xfs_iunlock(ip, lock_flags, _RET_IP_);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_attr_node_list",
          "args": [
            "context"
          ],
          "line": 527
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_attr_node_list",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_attr_list.c",
          "lines": "216-354",
          "snippet": "STATIC int\nxfs_attr_node_list(xfs_attr_list_context_t *context)\n{\n\tattrlist_cursor_kern_t *cursor;\n\txfs_attr_leafblock_t *leaf;\n\txfs_da_intnode_t *node;\n\tstruct xfs_attr3_icleaf_hdr leafhdr;\n\tstruct xfs_da3_icnode_hdr nodehdr;\n\tstruct xfs_da_node_entry *btree;\n\tint error, i;\n\tstruct xfs_buf *bp;\n\tstruct xfs_inode\t*dp = context->dp;\n\n\ttrace_xfs_attr_node_list(context);\n\n\tcursor = context->cursor;\n\tcursor->initted = 1;\n\n\t/*\n\t * Do all sorts of validation on the passed-in cursor structure.\n\t * If anything is amiss, ignore the cursor and look up the hashval\n\t * starting from the btree root.\n\t */\n\tbp = NULL;\n\tif (cursor->blkno > 0) {\n\t\terror = xfs_da3_node_read(NULL, dp, cursor->blkno, -1,\n\t\t\t\t\t      &bp, XFS_ATTR_FORK);\n\t\tif ((error != 0) && (error != -EFSCORRUPTED))\n\t\t\treturn error;\n\t\tif (bp) {\n\t\t\tstruct xfs_attr_leaf_entry *entries;\n\n\t\t\tnode = bp->b_addr;\n\t\t\tswitch (be16_to_cpu(node->hdr.info.magic)) {\n\t\t\tcase XFS_DA_NODE_MAGIC:\n\t\t\tcase XFS_DA3_NODE_MAGIC:\n\t\t\t\ttrace_xfs_attr_list_wrong_blk(context);\n\t\t\t\txfs_trans_brelse(NULL, bp);\n\t\t\t\tbp = NULL;\n\t\t\t\tbreak;\n\t\t\tcase XFS_ATTR_LEAF_MAGIC:\n\t\t\tcase XFS_ATTR3_LEAF_MAGIC:\n\t\t\t\tleaf = bp->b_addr;\n\t\t\t\txfs_attr3_leaf_hdr_from_disk(&leafhdr, leaf);\n\t\t\t\tentries = xfs_attr3_leaf_entryp(leaf);\n\t\t\t\tif (cursor->hashval > be32_to_cpu(\n\t\t\t\t\t\tentries[leafhdr.count - 1].hashval)) {\n\t\t\t\t\ttrace_xfs_attr_list_wrong_blk(context);\n\t\t\t\t\txfs_trans_brelse(NULL, bp);\n\t\t\t\t\tbp = NULL;\n\t\t\t\t} else if (cursor->hashval <= be32_to_cpu(\n\t\t\t\t\t\tentries[0].hashval)) {\n\t\t\t\t\ttrace_xfs_attr_list_wrong_blk(context);\n\t\t\t\t\txfs_trans_brelse(NULL, bp);\n\t\t\t\t\tbp = NULL;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\ttrace_xfs_attr_list_wrong_blk(context);\n\t\t\t\txfs_trans_brelse(NULL, bp);\n\t\t\t\tbp = NULL;\n\t\t\t}\n\t\t}\n\t}\n\n\t/*\n\t * We did not find what we expected given the cursor's contents,\n\t * so we start from the top and work down based on the hash value.\n\t * Note that start of node block is same as start of leaf block.\n\t */\n\tif (bp == NULL) {\n\t\tcursor->blkno = 0;\n\t\tfor (;;) {\n\t\t\t__uint16_t magic;\n\n\t\t\terror = xfs_da3_node_read(NULL, dp,\n\t\t\t\t\t\t      cursor->blkno, -1, &bp,\n\t\t\t\t\t\t      XFS_ATTR_FORK);\n\t\t\tif (error)\n\t\t\t\treturn error;\n\t\t\tnode = bp->b_addr;\n\t\t\tmagic = be16_to_cpu(node->hdr.info.magic);\n\t\t\tif (magic == XFS_ATTR_LEAF_MAGIC ||\n\t\t\t    magic == XFS_ATTR3_LEAF_MAGIC)\n\t\t\t\tbreak;\n\t\t\tif (magic != XFS_DA_NODE_MAGIC &&\n\t\t\t    magic != XFS_DA3_NODE_MAGIC) {\n\t\t\t\tXFS_CORRUPTION_ERROR(\"xfs_attr_node_list(3)\",\n\t\t\t\t\t\t     XFS_ERRLEVEL_LOW,\n\t\t\t\t\t\t     context->dp->i_mount,\n\t\t\t\t\t\t     node);\n\t\t\t\txfs_trans_brelse(NULL, bp);\n\t\t\t\treturn -EFSCORRUPTED;\n\t\t\t}\n\n\t\t\tdp->d_ops->node_hdr_from_disk(&nodehdr, node);\n\t\t\tbtree = dp->d_ops->node_tree_p(node);\n\t\t\tfor (i = 0; i < nodehdr.count; btree++, i++) {\n\t\t\t\tif (cursor->hashval\n\t\t\t\t\t\t<= be32_to_cpu(btree->hashval)) {\n\t\t\t\t\tcursor->blkno = be32_to_cpu(btree->before);\n\t\t\t\t\ttrace_xfs_attr_list_node_descend(context,\n\t\t\t\t\t\t\t\t\t btree);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (i == nodehdr.count) {\n\t\t\t\txfs_trans_brelse(NULL, bp);\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\txfs_trans_brelse(NULL, bp);\n\t\t}\n\t}\n\tASSERT(bp != NULL);\n\n\t/*\n\t * Roll upward through the blocks, processing each leaf block in\n\t * order.  As long as there is space in the result buffer, keep\n\t * adding the information.\n\t */\n\tfor (;;) {\n\t\tleaf = bp->b_addr;\n\t\terror = xfs_attr3_leaf_list_int(bp, context);\n\t\tif (error) {\n\t\t\txfs_trans_brelse(NULL, bp);\n\t\t\treturn error;\n\t\t}\n\t\txfs_attr3_leaf_hdr_from_disk(&leafhdr, leaf);\n\t\tif (context->seen_enough || leafhdr.forw == 0)\n\t\t\tbreak;\n\t\tcursor->blkno = leafhdr.forw;\n\t\txfs_trans_brelse(NULL, bp);\n\t\terror = xfs_attr3_leaf_read(NULL, dp, cursor->blkno, -1, &bp);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\txfs_trans_brelse(NULL, bp);\n\treturn 0;\n}",
          "includes": [
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_attr_leaf.h\"",
            "#include \"xfs_attr_remote.h\"",
            "#include \"xfs_attr_sf.h\"",
            "#include \"xfs_attr.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_dir2.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_attr_leaf.h\"\n#include \"xfs_attr_remote.h\"\n#include \"xfs_attr_sf.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC int\nxfs_attr_node_list(xfs_attr_list_context_t *context)\n{\n\tattrlist_cursor_kern_t *cursor;\n\txfs_attr_leafblock_t *leaf;\n\txfs_da_intnode_t *node;\n\tstruct xfs_attr3_icleaf_hdr leafhdr;\n\tstruct xfs_da3_icnode_hdr nodehdr;\n\tstruct xfs_da_node_entry *btree;\n\tint error, i;\n\tstruct xfs_buf *bp;\n\tstruct xfs_inode\t*dp = context->dp;\n\n\ttrace_xfs_attr_node_list(context);\n\n\tcursor = context->cursor;\n\tcursor->initted = 1;\n\n\t/*\n\t * Do all sorts of validation on the passed-in cursor structure.\n\t * If anything is amiss, ignore the cursor and look up the hashval\n\t * starting from the btree root.\n\t */\n\tbp = NULL;\n\tif (cursor->blkno > 0) {\n\t\terror = xfs_da3_node_read(NULL, dp, cursor->blkno, -1,\n\t\t\t\t\t      &bp, XFS_ATTR_FORK);\n\t\tif ((error != 0) && (error != -EFSCORRUPTED))\n\t\t\treturn error;\n\t\tif (bp) {\n\t\t\tstruct xfs_attr_leaf_entry *entries;\n\n\t\t\tnode = bp->b_addr;\n\t\t\tswitch (be16_to_cpu(node->hdr.info.magic)) {\n\t\t\tcase XFS_DA_NODE_MAGIC:\n\t\t\tcase XFS_DA3_NODE_MAGIC:\n\t\t\t\ttrace_xfs_attr_list_wrong_blk(context);\n\t\t\t\txfs_trans_brelse(NULL, bp);\n\t\t\t\tbp = NULL;\n\t\t\t\tbreak;\n\t\t\tcase XFS_ATTR_LEAF_MAGIC:\n\t\t\tcase XFS_ATTR3_LEAF_MAGIC:\n\t\t\t\tleaf = bp->b_addr;\n\t\t\t\txfs_attr3_leaf_hdr_from_disk(&leafhdr, leaf);\n\t\t\t\tentries = xfs_attr3_leaf_entryp(leaf);\n\t\t\t\tif (cursor->hashval > be32_to_cpu(\n\t\t\t\t\t\tentries[leafhdr.count - 1].hashval)) {\n\t\t\t\t\ttrace_xfs_attr_list_wrong_blk(context);\n\t\t\t\t\txfs_trans_brelse(NULL, bp);\n\t\t\t\t\tbp = NULL;\n\t\t\t\t} else if (cursor->hashval <= be32_to_cpu(\n\t\t\t\t\t\tentries[0].hashval)) {\n\t\t\t\t\ttrace_xfs_attr_list_wrong_blk(context);\n\t\t\t\t\txfs_trans_brelse(NULL, bp);\n\t\t\t\t\tbp = NULL;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\ttrace_xfs_attr_list_wrong_blk(context);\n\t\t\t\txfs_trans_brelse(NULL, bp);\n\t\t\t\tbp = NULL;\n\t\t\t}\n\t\t}\n\t}\n\n\t/*\n\t * We did not find what we expected given the cursor's contents,\n\t * so we start from the top and work down based on the hash value.\n\t * Note that start of node block is same as start of leaf block.\n\t */\n\tif (bp == NULL) {\n\t\tcursor->blkno = 0;\n\t\tfor (;;) {\n\t\t\t__uint16_t magic;\n\n\t\t\terror = xfs_da3_node_read(NULL, dp,\n\t\t\t\t\t\t      cursor->blkno, -1, &bp,\n\t\t\t\t\t\t      XFS_ATTR_FORK);\n\t\t\tif (error)\n\t\t\t\treturn error;\n\t\t\tnode = bp->b_addr;\n\t\t\tmagic = be16_to_cpu(node->hdr.info.magic);\n\t\t\tif (magic == XFS_ATTR_LEAF_MAGIC ||\n\t\t\t    magic == XFS_ATTR3_LEAF_MAGIC)\n\t\t\t\tbreak;\n\t\t\tif (magic != XFS_DA_NODE_MAGIC &&\n\t\t\t    magic != XFS_DA3_NODE_MAGIC) {\n\t\t\t\tXFS_CORRUPTION_ERROR(\"xfs_attr_node_list(3)\",\n\t\t\t\t\t\t     XFS_ERRLEVEL_LOW,\n\t\t\t\t\t\t     context->dp->i_mount,\n\t\t\t\t\t\t     node);\n\t\t\t\txfs_trans_brelse(NULL, bp);\n\t\t\t\treturn -EFSCORRUPTED;\n\t\t\t}\n\n\t\t\tdp->d_ops->node_hdr_from_disk(&nodehdr, node);\n\t\t\tbtree = dp->d_ops->node_tree_p(node);\n\t\t\tfor (i = 0; i < nodehdr.count; btree++, i++) {\n\t\t\t\tif (cursor->hashval\n\t\t\t\t\t\t<= be32_to_cpu(btree->hashval)) {\n\t\t\t\t\tcursor->blkno = be32_to_cpu(btree->before);\n\t\t\t\t\ttrace_xfs_attr_list_node_descend(context,\n\t\t\t\t\t\t\t\t\t btree);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (i == nodehdr.count) {\n\t\t\t\txfs_trans_brelse(NULL, bp);\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\txfs_trans_brelse(NULL, bp);\n\t\t}\n\t}\n\tASSERT(bp != NULL);\n\n\t/*\n\t * Roll upward through the blocks, processing each leaf block in\n\t * order.  As long as there is space in the result buffer, keep\n\t * adding the information.\n\t */\n\tfor (;;) {\n\t\tleaf = bp->b_addr;\n\t\terror = xfs_attr3_leaf_list_int(bp, context);\n\t\tif (error) {\n\t\t\txfs_trans_brelse(NULL, bp);\n\t\t\treturn error;\n\t\t}\n\t\txfs_attr3_leaf_hdr_from_disk(&leafhdr, leaf);\n\t\tif (context->seen_enough || leafhdr.forw == 0)\n\t\t\tbreak;\n\t\tcursor->blkno = leafhdr.forw;\n\t\txfs_trans_brelse(NULL, bp);\n\t\terror = xfs_attr3_leaf_read(NULL, dp, cursor->blkno, -1, &bp);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\txfs_trans_brelse(NULL, bp);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_attr_leaf_list",
          "args": [
            "context"
          ],
          "line": 525
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_attr_leaf_list",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_attr_list.c",
          "lines": "485-501",
          "snippet": "STATIC int\nxfs_attr_leaf_list(xfs_attr_list_context_t *context)\n{\n\tint error;\n\tstruct xfs_buf *bp;\n\n\ttrace_xfs_attr_leaf_list(context);\n\n\tcontext->cursor->blkno = 0;\n\terror = xfs_attr3_leaf_read(NULL, context->dp, 0, -1, &bp);\n\tif (error)\n\t\treturn error;\n\n\terror = xfs_attr3_leaf_list_int(bp, context);\n\txfs_trans_brelse(NULL, bp);\n\treturn error;\n}",
          "includes": [
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_attr_leaf.h\"",
            "#include \"xfs_attr_remote.h\"",
            "#include \"xfs_attr_sf.h\"",
            "#include \"xfs_attr.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_dir2.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_attr_leaf.h\"\n#include \"xfs_attr_remote.h\"\n#include \"xfs_attr_sf.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC int\nxfs_attr_leaf_list(xfs_attr_list_context_t *context)\n{\n\tint error;\n\tstruct xfs_buf *bp;\n\n\ttrace_xfs_attr_leaf_list(context);\n\n\tcontext->cursor->blkno = 0;\n\terror = xfs_attr3_leaf_read(NULL, context->dp, 0, -1, &bp);\n\tif (error)\n\t\treturn error;\n\n\terror = xfs_attr3_leaf_list_int(bp, context);\n\txfs_trans_brelse(NULL, bp);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_bmap_one_block",
          "args": [
            "dp",
            "XFS_ATTR_FORK"
          ],
          "line": 524
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_bmap_one_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_bmap.c",
          "lines": "1703-1729",
          "snippet": "int\t\t\t\t\t/* 1=>1 block, 0=>otherwise */\nxfs_bmap_one_block(\n\txfs_inode_t\t*ip,\t\t/* incore inode */\n\tint\t\twhichfork)\t/* data or attr fork */\n{\n\txfs_bmbt_rec_host_t *ep;\t/* ptr to fork's extent */\n\txfs_ifork_t\t*ifp;\t\t/* inode fork pointer */\n\tint\t\trval;\t\t/* return value */\n\txfs_bmbt_irec_t\ts;\t\t/* internal version of extent */\n\n#ifndef DEBUG\n\tif (whichfork == XFS_DATA_FORK)\n\t\treturn XFS_ISIZE(ip) == ip->i_mount->m_sb.sb_blocksize;\n#endif\t/* !DEBUG */\n\tif (XFS_IFORK_NEXTENTS(ip, whichfork) != 1)\n\t\treturn 0;\n\tif (XFS_IFORK_FORMAT(ip, whichfork) != XFS_DINODE_FMT_EXTENTS)\n\t\treturn 0;\n\tifp = XFS_IFORK_PTR(ip, whichfork);\n\tASSERT(ifp->if_flags & XFS_IFEXTENTS);\n\tep = xfs_iext_get_ext(ifp, 0);\n\txfs_bmbt_get_all(ep, &s);\n\trval = s.br_startoff == 0 && s.br_blockcount == 1;\n\tif (rval && whichfork == XFS_DATA_FORK)\n\t\tASSERT(XFS_ISIZE(ip) == ip->i_mount->m_sb.sb_blocksize);\n\treturn rval;\n}",
          "includes": [
            "#include \"xfs_filestream.h\"",
            "#include \"xfs_attr_leaf.h\"",
            "#include \"xfs_symlink.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_rtalloc.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_extfree_item.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_filestream.h\"\n#include \"xfs_attr_leaf.h\"\n#include \"xfs_symlink.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_extfree_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\t\t\t\t\t/* 1=>1 block, 0=>otherwise */\nxfs_bmap_one_block(\n\txfs_inode_t\t*ip,\t\t/* incore inode */\n\tint\t\twhichfork)\t/* data or attr fork */\n{\n\txfs_bmbt_rec_host_t *ep;\t/* ptr to fork's extent */\n\txfs_ifork_t\t*ifp;\t\t/* inode fork pointer */\n\tint\t\trval;\t\t/* return value */\n\txfs_bmbt_irec_t\ts;\t\t/* internal version of extent */\n\n#ifndef DEBUG\n\tif (whichfork == XFS_DATA_FORK)\n\t\treturn XFS_ISIZE(ip) == ip->i_mount->m_sb.sb_blocksize;\n#endif\t/* !DEBUG */\n\tif (XFS_IFORK_NEXTENTS(ip, whichfork) != 1)\n\t\treturn 0;\n\tif (XFS_IFORK_FORMAT(ip, whichfork) != XFS_DINODE_FMT_EXTENTS)\n\t\treturn 0;\n\tifp = XFS_IFORK_PTR(ip, whichfork);\n\tASSERT(ifp->if_flags & XFS_IFEXTENTS);\n\tep = xfs_iext_get_ext(ifp, 0);\n\txfs_bmbt_get_all(ep, &s);\n\trval = s.br_startoff == 0 && s.br_blockcount == 1;\n\tif (rval && whichfork == XFS_DATA_FORK)\n\t\tASSERT(XFS_ISIZE(ip) == ip->i_mount->m_sb.sb_blocksize);\n\treturn rval;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_attr_shortform_list",
          "args": [
            "context"
          ],
          "line": 523
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_attr_shortform_list",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_attr_list.c",
          "lines": "68-214",
          "snippet": "int\nxfs_attr_shortform_list(xfs_attr_list_context_t *context)\n{\n\tattrlist_cursor_kern_t *cursor;\n\txfs_attr_sf_sort_t *sbuf, *sbp;\n\txfs_attr_shortform_t *sf;\n\txfs_attr_sf_entry_t *sfe;\n\txfs_inode_t *dp;\n\tint sbsize, nsbuf, count, i;\n\tint error;\n\n\tASSERT(context != NULL);\n\tdp = context->dp;\n\tASSERT(dp != NULL);\n\tASSERT(dp->i_afp != NULL);\n\tsf = (xfs_attr_shortform_t *)dp->i_afp->if_u1.if_data;\n\tASSERT(sf != NULL);\n\tif (!sf->hdr.count)\n\t\treturn 0;\n\tcursor = context->cursor;\n\tASSERT(cursor != NULL);\n\n\ttrace_xfs_attr_list_sf(context);\n\n\t/*\n\t * If the buffer is large enough and the cursor is at the start,\n\t * do not bother with sorting since we will return everything in\n\t * one buffer and another call using the cursor won't need to be\n\t * made.\n\t * Note the generous fudge factor of 16 overhead bytes per entry.\n\t * If bufsize is zero then put_listent must be a search function\n\t * and can just scan through what we have.\n\t */\n\tif (context->bufsize == 0 ||\n\t    (XFS_ISRESET_CURSOR(cursor) &&\n             (dp->i_afp->if_bytes + sf->hdr.count * 16) < context->bufsize)) {\n\t\tfor (i = 0, sfe = &sf->list[0]; i < sf->hdr.count; i++) {\n\t\t\terror = context->put_listent(context,\n\t\t\t\t\t   sfe->flags,\n\t\t\t\t\t   sfe->nameval,\n\t\t\t\t\t   (int)sfe->namelen,\n\t\t\t\t\t   (int)sfe->valuelen,\n\t\t\t\t\t   &sfe->nameval[sfe->namelen]);\n\n\t\t\t/*\n\t\t\t * Either search callback finished early or\n\t\t\t * didn't fit it all in the buffer after all.\n\t\t\t */\n\t\t\tif (context->seen_enough)\n\t\t\t\tbreak;\n\n\t\t\tif (error)\n\t\t\t\treturn error;\n\t\t\tsfe = XFS_ATTR_SF_NEXTENTRY(sfe);\n\t\t}\n\t\ttrace_xfs_attr_list_sf_all(context);\n\t\treturn 0;\n\t}\n\n\t/* do no more for a search callback */\n\tif (context->bufsize == 0)\n\t\treturn 0;\n\n\t/*\n\t * It didn't all fit, so we have to sort everything on hashval.\n\t */\n\tsbsize = sf->hdr.count * sizeof(*sbuf);\n\tsbp = sbuf = kmem_alloc(sbsize, KM_SLEEP | KM_NOFS);\n\n\t/*\n\t * Scan the attribute list for the rest of the entries, storing\n\t * the relevant info from only those that match into a buffer.\n\t */\n\tnsbuf = 0;\n\tfor (i = 0, sfe = &sf->list[0]; i < sf->hdr.count; i++) {\n\t\tif (unlikely(\n\t\t    ((char *)sfe < (char *)sf) ||\n\t\t    ((char *)sfe >= ((char *)sf + dp->i_afp->if_bytes)))) {\n\t\t\tXFS_CORRUPTION_ERROR(\"xfs_attr_shortform_list\",\n\t\t\t\t\t     XFS_ERRLEVEL_LOW,\n\t\t\t\t\t     context->dp->i_mount, sfe);\n\t\t\tkmem_free(sbuf);\n\t\t\treturn -EFSCORRUPTED;\n\t\t}\n\n\t\tsbp->entno = i;\n\t\tsbp->hash = xfs_da_hashname(sfe->nameval, sfe->namelen);\n\t\tsbp->name = sfe->nameval;\n\t\tsbp->namelen = sfe->namelen;\n\t\t/* These are bytes, and both on-disk, don't endian-flip */\n\t\tsbp->valuelen = sfe->valuelen;\n\t\tsbp->flags = sfe->flags;\n\t\tsfe = XFS_ATTR_SF_NEXTENTRY(sfe);\n\t\tsbp++;\n\t\tnsbuf++;\n\t}\n\n\t/*\n\t * Sort the entries on hash then entno.\n\t */\n\txfs_sort(sbuf, nsbuf, sizeof(*sbuf), xfs_attr_shortform_compare);\n\n\t/*\n\t * Re-find our place IN THE SORTED LIST.\n\t */\n\tcount = 0;\n\tcursor->initted = 1;\n\tcursor->blkno = 0;\n\tfor (sbp = sbuf, i = 0; i < nsbuf; i++, sbp++) {\n\t\tif (sbp->hash == cursor->hashval) {\n\t\t\tif (cursor->offset == count) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcount++;\n\t\t} else if (sbp->hash > cursor->hashval) {\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (i == nsbuf) {\n\t\tkmem_free(sbuf);\n\t\treturn 0;\n\t}\n\n\t/*\n\t * Loop putting entries into the user buffer.\n\t */\n\tfor ( ; i < nsbuf; i++, sbp++) {\n\t\tif (cursor->hashval != sbp->hash) {\n\t\t\tcursor->hashval = sbp->hash;\n\t\t\tcursor->offset = 0;\n\t\t}\n\t\terror = context->put_listent(context,\n\t\t\t\t\tsbp->flags,\n\t\t\t\t\tsbp->name,\n\t\t\t\t\tsbp->namelen,\n\t\t\t\t\tsbp->valuelen,\n\t\t\t\t\t&sbp->name[sbp->namelen]);\n\t\tif (error)\n\t\t\treturn error;\n\t\tif (context->seen_enough)\n\t\t\tbreak;\n\t\tcursor->offset++;\n\t}\n\n\tkmem_free(sbuf);\n\treturn 0;\n}",
          "includes": [
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_attr_leaf.h\"",
            "#include \"xfs_attr_remote.h\"",
            "#include \"xfs_attr_sf.h\"",
            "#include \"xfs_attr.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_dir2.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_attr_leaf.h\"\n#include \"xfs_attr_remote.h\"\n#include \"xfs_attr_sf.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\nxfs_attr_shortform_list(xfs_attr_list_context_t *context)\n{\n\tattrlist_cursor_kern_t *cursor;\n\txfs_attr_sf_sort_t *sbuf, *sbp;\n\txfs_attr_shortform_t *sf;\n\txfs_attr_sf_entry_t *sfe;\n\txfs_inode_t *dp;\n\tint sbsize, nsbuf, count, i;\n\tint error;\n\n\tASSERT(context != NULL);\n\tdp = context->dp;\n\tASSERT(dp != NULL);\n\tASSERT(dp->i_afp != NULL);\n\tsf = (xfs_attr_shortform_t *)dp->i_afp->if_u1.if_data;\n\tASSERT(sf != NULL);\n\tif (!sf->hdr.count)\n\t\treturn 0;\n\tcursor = context->cursor;\n\tASSERT(cursor != NULL);\n\n\ttrace_xfs_attr_list_sf(context);\n\n\t/*\n\t * If the buffer is large enough and the cursor is at the start,\n\t * do not bother with sorting since we will return everything in\n\t * one buffer and another call using the cursor won't need to be\n\t * made.\n\t * Note the generous fudge factor of 16 overhead bytes per entry.\n\t * If bufsize is zero then put_listent must be a search function\n\t * and can just scan through what we have.\n\t */\n\tif (context->bufsize == 0 ||\n\t    (XFS_ISRESET_CURSOR(cursor) &&\n             (dp->i_afp->if_bytes + sf->hdr.count * 16) < context->bufsize)) {\n\t\tfor (i = 0, sfe = &sf->list[0]; i < sf->hdr.count; i++) {\n\t\t\terror = context->put_listent(context,\n\t\t\t\t\t   sfe->flags,\n\t\t\t\t\t   sfe->nameval,\n\t\t\t\t\t   (int)sfe->namelen,\n\t\t\t\t\t   (int)sfe->valuelen,\n\t\t\t\t\t   &sfe->nameval[sfe->namelen]);\n\n\t\t\t/*\n\t\t\t * Either search callback finished early or\n\t\t\t * didn't fit it all in the buffer after all.\n\t\t\t */\n\t\t\tif (context->seen_enough)\n\t\t\t\tbreak;\n\n\t\t\tif (error)\n\t\t\t\treturn error;\n\t\t\tsfe = XFS_ATTR_SF_NEXTENTRY(sfe);\n\t\t}\n\t\ttrace_xfs_attr_list_sf_all(context);\n\t\treturn 0;\n\t}\n\n\t/* do no more for a search callback */\n\tif (context->bufsize == 0)\n\t\treturn 0;\n\n\t/*\n\t * It didn't all fit, so we have to sort everything on hashval.\n\t */\n\tsbsize = sf->hdr.count * sizeof(*sbuf);\n\tsbp = sbuf = kmem_alloc(sbsize, KM_SLEEP | KM_NOFS);\n\n\t/*\n\t * Scan the attribute list for the rest of the entries, storing\n\t * the relevant info from only those that match into a buffer.\n\t */\n\tnsbuf = 0;\n\tfor (i = 0, sfe = &sf->list[0]; i < sf->hdr.count; i++) {\n\t\tif (unlikely(\n\t\t    ((char *)sfe < (char *)sf) ||\n\t\t    ((char *)sfe >= ((char *)sf + dp->i_afp->if_bytes)))) {\n\t\t\tXFS_CORRUPTION_ERROR(\"xfs_attr_shortform_list\",\n\t\t\t\t\t     XFS_ERRLEVEL_LOW,\n\t\t\t\t\t     context->dp->i_mount, sfe);\n\t\t\tkmem_free(sbuf);\n\t\t\treturn -EFSCORRUPTED;\n\t\t}\n\n\t\tsbp->entno = i;\n\t\tsbp->hash = xfs_da_hashname(sfe->nameval, sfe->namelen);\n\t\tsbp->name = sfe->nameval;\n\t\tsbp->namelen = sfe->namelen;\n\t\t/* These are bytes, and both on-disk, don't endian-flip */\n\t\tsbp->valuelen = sfe->valuelen;\n\t\tsbp->flags = sfe->flags;\n\t\tsfe = XFS_ATTR_SF_NEXTENTRY(sfe);\n\t\tsbp++;\n\t\tnsbuf++;\n\t}\n\n\t/*\n\t * Sort the entries on hash then entno.\n\t */\n\txfs_sort(sbuf, nsbuf, sizeof(*sbuf), xfs_attr_shortform_compare);\n\n\t/*\n\t * Re-find our place IN THE SORTED LIST.\n\t */\n\tcount = 0;\n\tcursor->initted = 1;\n\tcursor->blkno = 0;\n\tfor (sbp = sbuf, i = 0; i < nsbuf; i++, sbp++) {\n\t\tif (sbp->hash == cursor->hashval) {\n\t\t\tif (cursor->offset == count) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcount++;\n\t\t} else if (sbp->hash > cursor->hashval) {\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (i == nsbuf) {\n\t\tkmem_free(sbuf);\n\t\treturn 0;\n\t}\n\n\t/*\n\t * Loop putting entries into the user buffer.\n\t */\n\tfor ( ; i < nsbuf; i++, sbp++) {\n\t\tif (cursor->hashval != sbp->hash) {\n\t\t\tcursor->hashval = sbp->hash;\n\t\t\tcursor->offset = 0;\n\t\t}\n\t\terror = context->put_listent(context,\n\t\t\t\t\tsbp->flags,\n\t\t\t\t\tsbp->name,\n\t\t\t\t\tsbp->namelen,\n\t\t\t\t\tsbp->valuelen,\n\t\t\t\t\t&sbp->name[sbp->namelen]);\n\t\tif (error)\n\t\t\treturn error;\n\t\tif (context->seen_enough)\n\t\t\tbreak;\n\t\tcursor->offset++;\n\t}\n\n\tkmem_free(sbuf);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_inode_hasattr",
          "args": [
            "dp"
          ],
          "line": 520
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_inode_hasattr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_attr.c",
          "lines": "101-110",
          "snippet": "int\nxfs_inode_hasattr(\n\tstruct xfs_inode\t*ip)\n{\n\tif (!XFS_IFORK_Q(ip) ||\n\t    (ip->i_d.di_aformat == XFS_DINODE_FMT_EXTENTS &&\n\t     ip->i_d.di_anextents == 0))\n\t\treturn 0;\n\treturn 1;\n}",
          "includes": [
            "#include \"xfs_trace.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_attr_remote.h\"",
            "#include \"xfs_attr_leaf.h\"",
            "#include \"xfs_attr.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_attr_sf.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_trace.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_attr_remote.h\"\n#include \"xfs_attr_leaf.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_attr_sf.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\nxfs_inode_hasattr(\n\tstruct xfs_inode\t*ip)\n{\n\tif (!XFS_IFORK_Q(ip) ||\n\t    (ip->i_d.di_aformat == XFS_DINODE_FMT_EXTENTS &&\n\t     ip->i_d.di_anextents == 0))\n\t\treturn 0;\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_ilock_attr_map_shared",
          "args": [
            "dp"
          ],
          "line": 519
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_ilock_attr_map_shared",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_inode.c",
          "lines": "106-117",
          "snippet": "uint\nxfs_ilock_attr_map_shared(\n\tstruct xfs_inode\t*ip)\n{\n\tuint\t\t\tlock_mode = XFS_ILOCK_SHARED;\n\n\tif (ip->i_d.di_aformat == XFS_DINODE_FMT_BTREE &&\n\t    (ip->i_afp->if_flags & XFS_IFEXTENTS) == 0)\n\t\tlock_mode = XFS_ILOCK_EXCL;\n\txfs_ilock(ip, lock_mode);\n\treturn lock_mode;\n}",
          "includes": [
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_symlink.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_filestream.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_attr.h\"",
            "#include \"xfs_attr_sf.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\"",
            "#include <linux/log2.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_bmap_btree.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_symlink.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_filestream.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_attr_sf.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n#include <linux/log2.h>\n\nuint\nxfs_ilock_attr_map_shared(\n\tstruct xfs_inode\t*ip)\n{\n\tuint\t\t\tlock_mode = XFS_ILOCK_SHARED;\n\n\tif (ip->i_d.di_aformat == XFS_DINODE_FMT_BTREE &&\n\t    (ip->i_afp->if_flags & XFS_IFEXTENTS) == 0)\n\t\tlock_mode = XFS_ILOCK_EXCL;\n\txfs_ilock(ip, lock_mode);\n\treturn lock_mode;\n}"
        }
      },
      {
        "call_info": {
          "callee": "XFS_FORCED_SHUTDOWN",
          "args": [
            "dp->i_mount"
          ],
          "line": 513
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_STATS_INC",
          "args": [
            "xs_attr_list"
          ],
          "line": 511
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_dir2.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_attr_leaf.h\"\n#include \"xfs_attr_remote.h\"\n#include \"xfs_attr_sf.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\nxfs_attr_list_int(\n\txfs_attr_list_context_t *context)\n{\n\tint error;\n\txfs_inode_t *dp = context->dp;\n\tuint\t\tlock_mode;\n\n\tXFS_STATS_INC(xs_attr_list);\n\n\tif (XFS_FORCED_SHUTDOWN(dp->i_mount))\n\t\treturn -EIO;\n\n\t/*\n\t * Decide on what work routines to call based on the inode size.\n\t */\n\tlock_mode = xfs_ilock_attr_map_shared(dp);\n\tif (!xfs_inode_hasattr(dp)) {\n\t\terror = 0;\n\t} else if (dp->i_d.di_aformat == XFS_DINODE_FMT_LOCAL) {\n\t\terror = xfs_attr_shortform_list(context);\n\t} else if (xfs_bmap_one_block(dp, XFS_ATTR_FORK)) {\n\t\terror = xfs_attr_leaf_list(context);\n\t} else {\n\t\terror = xfs_attr_node_list(context);\n\t}\n\txfs_iunlock(dp, lock_mode);\n\treturn error;\n}"
  },
  {
    "function_name": "xfs_attr_leaf_list",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_attr_list.c",
    "lines": "485-501",
    "snippet": "STATIC int\nxfs_attr_leaf_list(xfs_attr_list_context_t *context)\n{\n\tint error;\n\tstruct xfs_buf *bp;\n\n\ttrace_xfs_attr_leaf_list(context);\n\n\tcontext->cursor->blkno = 0;\n\terror = xfs_attr3_leaf_read(NULL, context->dp, 0, -1, &bp);\n\tif (error)\n\t\treturn error;\n\n\terror = xfs_attr3_leaf_list_int(bp, context);\n\txfs_trans_brelse(NULL, bp);\n\treturn error;\n}",
    "includes": [
      "#include \"xfs_dir2.h\"",
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_buf_item.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_attr_leaf.h\"",
      "#include \"xfs_attr_remote.h\"",
      "#include \"xfs_attr_sf.h\"",
      "#include \"xfs_attr.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_inode_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_da_btree.h\"",
      "#include \"xfs_da_format.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_bit.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_trans_brelse",
          "args": [
            "NULL",
            "bp"
          ],
          "line": 499
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_trans_brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans_buf.c",
          "lines": "354-443",
          "snippet": "void\nxfs_trans_brelse(xfs_trans_t\t*tp,\n\t\t xfs_buf_t\t*bp)\n{\n\txfs_buf_log_item_t\t*bip;\n\n\t/*\n\t * Default to a normal brelse() call if the tp is NULL.\n\t */\n\tif (tp == NULL) {\n\t\tASSERT(bp->b_transp == NULL);\n\t\txfs_buf_relse(bp);\n\t\treturn;\n\t}\n\n\tASSERT(bp->b_transp == tp);\n\tbip = bp->b_fspriv;\n\tASSERT(bip->bli_item.li_type == XFS_LI_BUF);\n\tASSERT(!(bip->bli_flags & XFS_BLI_STALE));\n\tASSERT(!(bip->__bli_format.blf_flags & XFS_BLF_CANCEL));\n\tASSERT(atomic_read(&bip->bli_refcount) > 0);\n\n\ttrace_xfs_trans_brelse(bip);\n\n\t/*\n\t * If the release is just for a recursive lock,\n\t * then decrement the count and return.\n\t */\n\tif (bip->bli_recur > 0) {\n\t\tbip->bli_recur--;\n\t\treturn;\n\t}\n\n\t/*\n\t * If the buffer is dirty within this transaction, we can't\n\t * release it until we commit.\n\t */\n\tif (bip->bli_item.li_desc->lid_flags & XFS_LID_DIRTY)\n\t\treturn;\n\n\t/*\n\t * If the buffer has been invalidated, then we can't release\n\t * it until the transaction commits to disk unless it is re-dirtied\n\t * as part of this transaction.  This prevents us from pulling\n\t * the item from the AIL before we should.\n\t */\n\tif (bip->bli_flags & XFS_BLI_STALE)\n\t\treturn;\n\n\tASSERT(!(bip->bli_flags & XFS_BLI_LOGGED));\n\n\t/*\n\t * Free up the log item descriptor tracking the released item.\n\t */\n\txfs_trans_del_item(&bip->bli_item);\n\n\t/*\n\t * Clear the hold flag in the buf log item if it is set.\n\t * We wouldn't want the next user of the buffer to\n\t * get confused.\n\t */\n\tif (bip->bli_flags & XFS_BLI_HOLD) {\n\t\tbip->bli_flags &= ~XFS_BLI_HOLD;\n\t}\n\n\t/*\n\t * Drop our reference to the buf log item.\n\t */\n\tatomic_dec(&bip->bli_refcount);\n\n\t/*\n\t * If the buf item is not tracking data in the log, then\n\t * we must free it before releasing the buffer back to the\n\t * free pool.  Before releasing the buffer to the free pool,\n\t * clear the transaction pointer in b_fsprivate2 to dissolve\n\t * its relation to this transaction.\n\t */\n\tif (!xfs_buf_item_dirty(bip)) {\n/***\n\t\tASSERT(bp->b_pincount == 0);\n***/\n\t\tASSERT(atomic_read(&bip->bli_refcount) == 0);\n\t\tASSERT(!(bip->bli_item.li_flags & XFS_LI_IN_AIL));\n\t\tASSERT(!(bip->bli_flags & XFS_BLI_INODE_ALLOC_BUF));\n\t\txfs_buf_item_relse(bp);\n\t}\n\n\tbp->b_transp = NULL;\n\txfs_buf_relse(bp);\n}",
          "includes": [
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_trans_brelse(xfs_trans_t\t*tp,\n\t\t xfs_buf_t\t*bp)\n{\n\txfs_buf_log_item_t\t*bip;\n\n\t/*\n\t * Default to a normal brelse() call if the tp is NULL.\n\t */\n\tif (tp == NULL) {\n\t\tASSERT(bp->b_transp == NULL);\n\t\txfs_buf_relse(bp);\n\t\treturn;\n\t}\n\n\tASSERT(bp->b_transp == tp);\n\tbip = bp->b_fspriv;\n\tASSERT(bip->bli_item.li_type == XFS_LI_BUF);\n\tASSERT(!(bip->bli_flags & XFS_BLI_STALE));\n\tASSERT(!(bip->__bli_format.blf_flags & XFS_BLF_CANCEL));\n\tASSERT(atomic_read(&bip->bli_refcount) > 0);\n\n\ttrace_xfs_trans_brelse(bip);\n\n\t/*\n\t * If the release is just for a recursive lock,\n\t * then decrement the count and return.\n\t */\n\tif (bip->bli_recur > 0) {\n\t\tbip->bli_recur--;\n\t\treturn;\n\t}\n\n\t/*\n\t * If the buffer is dirty within this transaction, we can't\n\t * release it until we commit.\n\t */\n\tif (bip->bli_item.li_desc->lid_flags & XFS_LID_DIRTY)\n\t\treturn;\n\n\t/*\n\t * If the buffer has been invalidated, then we can't release\n\t * it until the transaction commits to disk unless it is re-dirtied\n\t * as part of this transaction.  This prevents us from pulling\n\t * the item from the AIL before we should.\n\t */\n\tif (bip->bli_flags & XFS_BLI_STALE)\n\t\treturn;\n\n\tASSERT(!(bip->bli_flags & XFS_BLI_LOGGED));\n\n\t/*\n\t * Free up the log item descriptor tracking the released item.\n\t */\n\txfs_trans_del_item(&bip->bli_item);\n\n\t/*\n\t * Clear the hold flag in the buf log item if it is set.\n\t * We wouldn't want the next user of the buffer to\n\t * get confused.\n\t */\n\tif (bip->bli_flags & XFS_BLI_HOLD) {\n\t\tbip->bli_flags &= ~XFS_BLI_HOLD;\n\t}\n\n\t/*\n\t * Drop our reference to the buf log item.\n\t */\n\tatomic_dec(&bip->bli_refcount);\n\n\t/*\n\t * If the buf item is not tracking data in the log, then\n\t * we must free it before releasing the buffer back to the\n\t * free pool.  Before releasing the buffer to the free pool,\n\t * clear the transaction pointer in b_fsprivate2 to dissolve\n\t * its relation to this transaction.\n\t */\n\tif (!xfs_buf_item_dirty(bip)) {\n/***\n\t\tASSERT(bp->b_pincount == 0);\n***/\n\t\tASSERT(atomic_read(&bip->bli_refcount) == 0);\n\t\tASSERT(!(bip->bli_item.li_flags & XFS_LI_IN_AIL));\n\t\tASSERT(!(bip->bli_flags & XFS_BLI_INODE_ALLOC_BUF));\n\t\txfs_buf_item_relse(bp);\n\t}\n\n\tbp->b_transp = NULL;\n\txfs_buf_relse(bp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_attr3_leaf_list_int",
          "args": [
            "bp",
            "context"
          ],
          "line": 498
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_attr3_leaf_list_int",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_attr_list.c",
          "lines": "359-480",
          "snippet": "int\nxfs_attr3_leaf_list_int(\n\tstruct xfs_buf\t\t\t*bp,\n\tstruct xfs_attr_list_context\t*context)\n{\n\tstruct attrlist_cursor_kern\t*cursor;\n\tstruct xfs_attr_leafblock\t*leaf;\n\tstruct xfs_attr3_icleaf_hdr\tichdr;\n\tstruct xfs_attr_leaf_entry\t*entries;\n\tstruct xfs_attr_leaf_entry\t*entry;\n\tint\t\t\t\tretval;\n\tint\t\t\t\ti;\n\n\ttrace_xfs_attr_list_leaf(context);\n\n\tleaf = bp->b_addr;\n\txfs_attr3_leaf_hdr_from_disk(&ichdr, leaf);\n\tentries = xfs_attr3_leaf_entryp(leaf);\n\n\tcursor = context->cursor;\n\tcursor->initted = 1;\n\n\t/*\n\t * Re-find our place in the leaf block if this is a new syscall.\n\t */\n\tif (context->resynch) {\n\t\tentry = &entries[0];\n\t\tfor (i = 0; i < ichdr.count; entry++, i++) {\n\t\t\tif (be32_to_cpu(entry->hashval) == cursor->hashval) {\n\t\t\t\tif (cursor->offset == context->dupcnt) {\n\t\t\t\t\tcontext->dupcnt = 0;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tcontext->dupcnt++;\n\t\t\t} else if (be32_to_cpu(entry->hashval) >\n\t\t\t\t\tcursor->hashval) {\n\t\t\t\tcontext->dupcnt = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (i == ichdr.count) {\n\t\t\ttrace_xfs_attr_list_notfound(context);\n\t\t\treturn 0;\n\t\t}\n\t} else {\n\t\tentry = &entries[0];\n\t\ti = 0;\n\t}\n\tcontext->resynch = 0;\n\n\t/*\n\t * We have found our place, start copying out the new attributes.\n\t */\n\tretval = 0;\n\tfor (; i < ichdr.count; entry++, i++) {\n\t\tif (be32_to_cpu(entry->hashval) != cursor->hashval) {\n\t\t\tcursor->hashval = be32_to_cpu(entry->hashval);\n\t\t\tcursor->offset = 0;\n\t\t}\n\n\t\tif (entry->flags & XFS_ATTR_INCOMPLETE)\n\t\t\tcontinue;\t\t/* skip incomplete entries */\n\n\t\tif (entry->flags & XFS_ATTR_LOCAL) {\n\t\t\txfs_attr_leaf_name_local_t *name_loc =\n\t\t\t\txfs_attr3_leaf_name_local(leaf, i);\n\n\t\t\tretval = context->put_listent(context,\n\t\t\t\t\t\tentry->flags,\n\t\t\t\t\t\tname_loc->nameval,\n\t\t\t\t\t\t(int)name_loc->namelen,\n\t\t\t\t\t\tbe16_to_cpu(name_loc->valuelen),\n\t\t\t\t\t\t&name_loc->nameval[name_loc->namelen]);\n\t\t\tif (retval)\n\t\t\t\treturn retval;\n\t\t} else {\n\t\t\txfs_attr_leaf_name_remote_t *name_rmt =\n\t\t\t\txfs_attr3_leaf_name_remote(leaf, i);\n\n\t\t\tint valuelen = be32_to_cpu(name_rmt->valuelen);\n\n\t\t\tif (context->put_value) {\n\t\t\t\txfs_da_args_t args;\n\n\t\t\t\tmemset((char *)&args, 0, sizeof(args));\n\t\t\t\targs.geo = context->dp->i_mount->m_attr_geo;\n\t\t\t\targs.dp = context->dp;\n\t\t\t\targs.whichfork = XFS_ATTR_FORK;\n\t\t\t\targs.valuelen = valuelen;\n\t\t\t\targs.rmtvaluelen = valuelen;\n\t\t\t\targs.value = kmem_alloc(valuelen, KM_SLEEP | KM_NOFS);\n\t\t\t\targs.rmtblkno = be32_to_cpu(name_rmt->valueblk);\n\t\t\t\targs.rmtblkcnt = xfs_attr3_rmt_blocks(\n\t\t\t\t\t\t\targs.dp->i_mount, valuelen);\n\t\t\t\tretval = xfs_attr_rmtval_get(&args);\n\t\t\t\tif (retval)\n\t\t\t\t\treturn retval;\n\t\t\t\tretval = context->put_listent(context,\n\t\t\t\t\t\tentry->flags,\n\t\t\t\t\t\tname_rmt->name,\n\t\t\t\t\t\t(int)name_rmt->namelen,\n\t\t\t\t\t\tvaluelen,\n\t\t\t\t\t\targs.value);\n\t\t\t\tkmem_free(args.value);\n\t\t\t} else {\n\t\t\t\tretval = context->put_listent(context,\n\t\t\t\t\t\tentry->flags,\n\t\t\t\t\t\tname_rmt->name,\n\t\t\t\t\t\t(int)name_rmt->namelen,\n\t\t\t\t\t\tvaluelen,\n\t\t\t\t\t\tNULL);\n\t\t\t}\n\t\t\tif (retval)\n\t\t\t\treturn retval;\n\t\t}\n\t\tif (context->seen_enough)\n\t\t\tbreak;\n\t\tcursor->offset++;\n\t}\n\ttrace_xfs_attr_list_leaf_end(context);\n\treturn retval;\n}",
          "includes": [
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_attr_leaf.h\"",
            "#include \"xfs_attr_remote.h\"",
            "#include \"xfs_attr_sf.h\"",
            "#include \"xfs_attr.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_dir2.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_attr_leaf.h\"\n#include \"xfs_attr_remote.h\"\n#include \"xfs_attr_sf.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\nxfs_attr3_leaf_list_int(\n\tstruct xfs_buf\t\t\t*bp,\n\tstruct xfs_attr_list_context\t*context)\n{\n\tstruct attrlist_cursor_kern\t*cursor;\n\tstruct xfs_attr_leafblock\t*leaf;\n\tstruct xfs_attr3_icleaf_hdr\tichdr;\n\tstruct xfs_attr_leaf_entry\t*entries;\n\tstruct xfs_attr_leaf_entry\t*entry;\n\tint\t\t\t\tretval;\n\tint\t\t\t\ti;\n\n\ttrace_xfs_attr_list_leaf(context);\n\n\tleaf = bp->b_addr;\n\txfs_attr3_leaf_hdr_from_disk(&ichdr, leaf);\n\tentries = xfs_attr3_leaf_entryp(leaf);\n\n\tcursor = context->cursor;\n\tcursor->initted = 1;\n\n\t/*\n\t * Re-find our place in the leaf block if this is a new syscall.\n\t */\n\tif (context->resynch) {\n\t\tentry = &entries[0];\n\t\tfor (i = 0; i < ichdr.count; entry++, i++) {\n\t\t\tif (be32_to_cpu(entry->hashval) == cursor->hashval) {\n\t\t\t\tif (cursor->offset == context->dupcnt) {\n\t\t\t\t\tcontext->dupcnt = 0;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tcontext->dupcnt++;\n\t\t\t} else if (be32_to_cpu(entry->hashval) >\n\t\t\t\t\tcursor->hashval) {\n\t\t\t\tcontext->dupcnt = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (i == ichdr.count) {\n\t\t\ttrace_xfs_attr_list_notfound(context);\n\t\t\treturn 0;\n\t\t}\n\t} else {\n\t\tentry = &entries[0];\n\t\ti = 0;\n\t}\n\tcontext->resynch = 0;\n\n\t/*\n\t * We have found our place, start copying out the new attributes.\n\t */\n\tretval = 0;\n\tfor (; i < ichdr.count; entry++, i++) {\n\t\tif (be32_to_cpu(entry->hashval) != cursor->hashval) {\n\t\t\tcursor->hashval = be32_to_cpu(entry->hashval);\n\t\t\tcursor->offset = 0;\n\t\t}\n\n\t\tif (entry->flags & XFS_ATTR_INCOMPLETE)\n\t\t\tcontinue;\t\t/* skip incomplete entries */\n\n\t\tif (entry->flags & XFS_ATTR_LOCAL) {\n\t\t\txfs_attr_leaf_name_local_t *name_loc =\n\t\t\t\txfs_attr3_leaf_name_local(leaf, i);\n\n\t\t\tretval = context->put_listent(context,\n\t\t\t\t\t\tentry->flags,\n\t\t\t\t\t\tname_loc->nameval,\n\t\t\t\t\t\t(int)name_loc->namelen,\n\t\t\t\t\t\tbe16_to_cpu(name_loc->valuelen),\n\t\t\t\t\t\t&name_loc->nameval[name_loc->namelen]);\n\t\t\tif (retval)\n\t\t\t\treturn retval;\n\t\t} else {\n\t\t\txfs_attr_leaf_name_remote_t *name_rmt =\n\t\t\t\txfs_attr3_leaf_name_remote(leaf, i);\n\n\t\t\tint valuelen = be32_to_cpu(name_rmt->valuelen);\n\n\t\t\tif (context->put_value) {\n\t\t\t\txfs_da_args_t args;\n\n\t\t\t\tmemset((char *)&args, 0, sizeof(args));\n\t\t\t\targs.geo = context->dp->i_mount->m_attr_geo;\n\t\t\t\targs.dp = context->dp;\n\t\t\t\targs.whichfork = XFS_ATTR_FORK;\n\t\t\t\targs.valuelen = valuelen;\n\t\t\t\targs.rmtvaluelen = valuelen;\n\t\t\t\targs.value = kmem_alloc(valuelen, KM_SLEEP | KM_NOFS);\n\t\t\t\targs.rmtblkno = be32_to_cpu(name_rmt->valueblk);\n\t\t\t\targs.rmtblkcnt = xfs_attr3_rmt_blocks(\n\t\t\t\t\t\t\targs.dp->i_mount, valuelen);\n\t\t\t\tretval = xfs_attr_rmtval_get(&args);\n\t\t\t\tif (retval)\n\t\t\t\t\treturn retval;\n\t\t\t\tretval = context->put_listent(context,\n\t\t\t\t\t\tentry->flags,\n\t\t\t\t\t\tname_rmt->name,\n\t\t\t\t\t\t(int)name_rmt->namelen,\n\t\t\t\t\t\tvaluelen,\n\t\t\t\t\t\targs.value);\n\t\t\t\tkmem_free(args.value);\n\t\t\t} else {\n\t\t\t\tretval = context->put_listent(context,\n\t\t\t\t\t\tentry->flags,\n\t\t\t\t\t\tname_rmt->name,\n\t\t\t\t\t\t(int)name_rmt->namelen,\n\t\t\t\t\t\tvaluelen,\n\t\t\t\t\t\tNULL);\n\t\t\t}\n\t\t\tif (retval)\n\t\t\t\treturn retval;\n\t\t}\n\t\tif (context->seen_enough)\n\t\t\tbreak;\n\t\tcursor->offset++;\n\t}\n\ttrace_xfs_attr_list_leaf_end(context);\n\treturn retval;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_attr3_leaf_read",
          "args": [
            "NULL",
            "context->dp",
            "0",
            "-1",
            "&bp"
          ],
          "line": 494
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_attr3_leaf_read",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_attr_leaf.c",
          "lines": "256-271",
          "snippet": "int\nxfs_attr3_leaf_read(\n\tstruct xfs_trans\t*tp,\n\tstruct xfs_inode\t*dp,\n\txfs_dablk_t\t\tbno,\n\txfs_daddr_t\t\tmappedbno,\n\tstruct xfs_buf\t\t**bpp)\n{\n\tint\t\t\terr;\n\n\terr = xfs_da_read_buf(tp, dp, bno, mappedbno, bpp,\n\t\t\t\tXFS_ATTR_FORK, &xfs_attr3_leaf_buf_ops);\n\tif (!err && tp)\n\t\txfs_trans_buf_set_type(tp, *bpp, XFS_BLFT_ATTR_LEAF_BUF);\n\treturn err;\n}",
          "includes": [
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_attr_leaf.h\"",
            "#include \"xfs_attr.h\"",
            "#include \"xfs_attr_remote.h\"",
            "#include \"xfs_attr_sf.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC int xfs_attr3_leaf_create(struct xfs_da_args *args,\n\t\t\t\t xfs_dablk_t which_block, struct xfs_buf **bpp);",
            "const struct xfs_buf_ops xfs_attr3_leaf_buf_ops = {\n\t.verify_read = xfs_attr3_leaf_read_verify,\n\t.verify_write = xfs_attr3_leaf_write_verify,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_dir2.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_attr_leaf.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_attr_remote.h\"\n#include \"xfs_attr_sf.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC int xfs_attr3_leaf_create(struct xfs_da_args *args,\n\t\t\t\t xfs_dablk_t which_block, struct xfs_buf **bpp);\nconst struct xfs_buf_ops xfs_attr3_leaf_buf_ops = {\n\t.verify_read = xfs_attr3_leaf_read_verify,\n\t.verify_write = xfs_attr3_leaf_write_verify,\n};\n\nint\nxfs_attr3_leaf_read(\n\tstruct xfs_trans\t*tp,\n\tstruct xfs_inode\t*dp,\n\txfs_dablk_t\t\tbno,\n\txfs_daddr_t\t\tmappedbno,\n\tstruct xfs_buf\t\t**bpp)\n{\n\tint\t\t\terr;\n\n\terr = xfs_da_read_buf(tp, dp, bno, mappedbno, bpp,\n\t\t\t\tXFS_ATTR_FORK, &xfs_attr3_leaf_buf_ops);\n\tif (!err && tp)\n\t\txfs_trans_buf_set_type(tp, *bpp, XFS_BLFT_ATTR_LEAF_BUF);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_xfs_attr_leaf_list",
          "args": [
            "context"
          ],
          "line": 491
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_dir2.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_attr_leaf.h\"\n#include \"xfs_attr_remote.h\"\n#include \"xfs_attr_sf.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC int\nxfs_attr_leaf_list(xfs_attr_list_context_t *context)\n{\n\tint error;\n\tstruct xfs_buf *bp;\n\n\ttrace_xfs_attr_leaf_list(context);\n\n\tcontext->cursor->blkno = 0;\n\terror = xfs_attr3_leaf_read(NULL, context->dp, 0, -1, &bp);\n\tif (error)\n\t\treturn error;\n\n\terror = xfs_attr3_leaf_list_int(bp, context);\n\txfs_trans_brelse(NULL, bp);\n\treturn error;\n}"
  },
  {
    "function_name": "xfs_attr3_leaf_list_int",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_attr_list.c",
    "lines": "359-480",
    "snippet": "int\nxfs_attr3_leaf_list_int(\n\tstruct xfs_buf\t\t\t*bp,\n\tstruct xfs_attr_list_context\t*context)\n{\n\tstruct attrlist_cursor_kern\t*cursor;\n\tstruct xfs_attr_leafblock\t*leaf;\n\tstruct xfs_attr3_icleaf_hdr\tichdr;\n\tstruct xfs_attr_leaf_entry\t*entries;\n\tstruct xfs_attr_leaf_entry\t*entry;\n\tint\t\t\t\tretval;\n\tint\t\t\t\ti;\n\n\ttrace_xfs_attr_list_leaf(context);\n\n\tleaf = bp->b_addr;\n\txfs_attr3_leaf_hdr_from_disk(&ichdr, leaf);\n\tentries = xfs_attr3_leaf_entryp(leaf);\n\n\tcursor = context->cursor;\n\tcursor->initted = 1;\n\n\t/*\n\t * Re-find our place in the leaf block if this is a new syscall.\n\t */\n\tif (context->resynch) {\n\t\tentry = &entries[0];\n\t\tfor (i = 0; i < ichdr.count; entry++, i++) {\n\t\t\tif (be32_to_cpu(entry->hashval) == cursor->hashval) {\n\t\t\t\tif (cursor->offset == context->dupcnt) {\n\t\t\t\t\tcontext->dupcnt = 0;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tcontext->dupcnt++;\n\t\t\t} else if (be32_to_cpu(entry->hashval) >\n\t\t\t\t\tcursor->hashval) {\n\t\t\t\tcontext->dupcnt = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (i == ichdr.count) {\n\t\t\ttrace_xfs_attr_list_notfound(context);\n\t\t\treturn 0;\n\t\t}\n\t} else {\n\t\tentry = &entries[0];\n\t\ti = 0;\n\t}\n\tcontext->resynch = 0;\n\n\t/*\n\t * We have found our place, start copying out the new attributes.\n\t */\n\tretval = 0;\n\tfor (; i < ichdr.count; entry++, i++) {\n\t\tif (be32_to_cpu(entry->hashval) != cursor->hashval) {\n\t\t\tcursor->hashval = be32_to_cpu(entry->hashval);\n\t\t\tcursor->offset = 0;\n\t\t}\n\n\t\tif (entry->flags & XFS_ATTR_INCOMPLETE)\n\t\t\tcontinue;\t\t/* skip incomplete entries */\n\n\t\tif (entry->flags & XFS_ATTR_LOCAL) {\n\t\t\txfs_attr_leaf_name_local_t *name_loc =\n\t\t\t\txfs_attr3_leaf_name_local(leaf, i);\n\n\t\t\tretval = context->put_listent(context,\n\t\t\t\t\t\tentry->flags,\n\t\t\t\t\t\tname_loc->nameval,\n\t\t\t\t\t\t(int)name_loc->namelen,\n\t\t\t\t\t\tbe16_to_cpu(name_loc->valuelen),\n\t\t\t\t\t\t&name_loc->nameval[name_loc->namelen]);\n\t\t\tif (retval)\n\t\t\t\treturn retval;\n\t\t} else {\n\t\t\txfs_attr_leaf_name_remote_t *name_rmt =\n\t\t\t\txfs_attr3_leaf_name_remote(leaf, i);\n\n\t\t\tint valuelen = be32_to_cpu(name_rmt->valuelen);\n\n\t\t\tif (context->put_value) {\n\t\t\t\txfs_da_args_t args;\n\n\t\t\t\tmemset((char *)&args, 0, sizeof(args));\n\t\t\t\targs.geo = context->dp->i_mount->m_attr_geo;\n\t\t\t\targs.dp = context->dp;\n\t\t\t\targs.whichfork = XFS_ATTR_FORK;\n\t\t\t\targs.valuelen = valuelen;\n\t\t\t\targs.rmtvaluelen = valuelen;\n\t\t\t\targs.value = kmem_alloc(valuelen, KM_SLEEP | KM_NOFS);\n\t\t\t\targs.rmtblkno = be32_to_cpu(name_rmt->valueblk);\n\t\t\t\targs.rmtblkcnt = xfs_attr3_rmt_blocks(\n\t\t\t\t\t\t\targs.dp->i_mount, valuelen);\n\t\t\t\tretval = xfs_attr_rmtval_get(&args);\n\t\t\t\tif (retval)\n\t\t\t\t\treturn retval;\n\t\t\t\tretval = context->put_listent(context,\n\t\t\t\t\t\tentry->flags,\n\t\t\t\t\t\tname_rmt->name,\n\t\t\t\t\t\t(int)name_rmt->namelen,\n\t\t\t\t\t\tvaluelen,\n\t\t\t\t\t\targs.value);\n\t\t\t\tkmem_free(args.value);\n\t\t\t} else {\n\t\t\t\tretval = context->put_listent(context,\n\t\t\t\t\t\tentry->flags,\n\t\t\t\t\t\tname_rmt->name,\n\t\t\t\t\t\t(int)name_rmt->namelen,\n\t\t\t\t\t\tvaluelen,\n\t\t\t\t\t\tNULL);\n\t\t\t}\n\t\t\tif (retval)\n\t\t\t\treturn retval;\n\t\t}\n\t\tif (context->seen_enough)\n\t\t\tbreak;\n\t\tcursor->offset++;\n\t}\n\ttrace_xfs_attr_list_leaf_end(context);\n\treturn retval;\n}",
    "includes": [
      "#include \"xfs_dir2.h\"",
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_buf_item.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_attr_leaf.h\"",
      "#include \"xfs_attr_remote.h\"",
      "#include \"xfs_attr_sf.h\"",
      "#include \"xfs_attr.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_inode_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_da_btree.h\"",
      "#include \"xfs_da_format.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_bit.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "trace_xfs_attr_list_leaf_end",
          "args": [
            "context"
          ],
          "line": 478
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "context->put_listent",
          "args": [
            "context",
            "entry->flags",
            "name_rmt->name",
            "(int)name_rmt->namelen",
            "valuelen",
            "NULL"
          ],
          "line": 464
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmem_free",
          "args": [
            "args.value"
          ],
          "line": 462
        },
        "resolved": true,
        "details": {
          "function_name": "kmem_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/kmem.h",
          "lines": "66-69",
          "snippet": "static inline void  kmem_free(const void *ptr)\n{\n\tkvfree(ptr);\n}",
          "includes": [
            "#include <linux/vmalloc.h>",
            "#include <linux/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/vmalloc.h>\n#include <linux/mm.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n\nstatic inline void  kmem_free(const void *ptr)\n{\n\tkvfree(ptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "context->put_listent",
          "args": [
            "context",
            "entry->flags",
            "name_rmt->name",
            "(int)name_rmt->namelen",
            "valuelen",
            "args.value"
          ],
          "line": 456
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_attr_rmtval_get",
          "args": [
            "&args"
          ],
          "line": 453
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_attr_rmtval_get",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_attr_remote.c",
          "lines": "331-390",
          "snippet": "int\nxfs_attr_rmtval_get(\n\tstruct xfs_da_args\t*args)\n{\n\tstruct xfs_bmbt_irec\tmap[ATTR_RMTVALUE_MAPSIZE];\n\tstruct xfs_mount\t*mp = args->dp->i_mount;\n\tstruct xfs_buf\t\t*bp;\n\txfs_dablk_t\t\tlblkno = args->rmtblkno;\n\t__uint8_t\t\t*dst = args->value;\n\tint\t\t\tvaluelen;\n\tint\t\t\tnmap;\n\tint\t\t\terror;\n\tint\t\t\tblkcnt = args->rmtblkcnt;\n\tint\t\t\ti;\n\tint\t\t\toffset = 0;\n\n\ttrace_xfs_attr_rmtval_get(args);\n\n\tASSERT(!(args->flags & ATTR_KERNOVAL));\n\tASSERT(args->rmtvaluelen == args->valuelen);\n\n\tvaluelen = args->rmtvaluelen;\n\twhile (valuelen > 0) {\n\t\tnmap = ATTR_RMTVALUE_MAPSIZE;\n\t\terror = xfs_bmapi_read(args->dp, (xfs_fileoff_t)lblkno,\n\t\t\t\t       blkcnt, map, &nmap,\n\t\t\t\t       XFS_BMAPI_ATTRFORK);\n\t\tif (error)\n\t\t\treturn error;\n\t\tASSERT(nmap >= 1);\n\n\t\tfor (i = 0; (i < nmap) && (valuelen > 0); i++) {\n\t\t\txfs_daddr_t\tdblkno;\n\t\t\tint\t\tdblkcnt;\n\n\t\t\tASSERT((map[i].br_startblock != DELAYSTARTBLOCK) &&\n\t\t\t       (map[i].br_startblock != HOLESTARTBLOCK));\n\t\t\tdblkno = XFS_FSB_TO_DADDR(mp, map[i].br_startblock);\n\t\t\tdblkcnt = XFS_FSB_TO_BB(mp, map[i].br_blockcount);\n\t\t\terror = xfs_trans_read_buf(mp, NULL, mp->m_ddev_targp,\n\t\t\t\t\t\t   dblkno, dblkcnt, 0, &bp,\n\t\t\t\t\t\t   &xfs_attr3_rmt_buf_ops);\n\t\t\tif (error)\n\t\t\t\treturn error;\n\n\t\t\terror = xfs_attr_rmtval_copyout(mp, bp, args->dp->i_ino,\n\t\t\t\t\t\t\t&offset, &valuelen,\n\t\t\t\t\t\t\t&dst);\n\t\t\txfs_buf_relse(bp);\n\t\t\tif (error)\n\t\t\t\treturn error;\n\n\t\t\t/* roll attribute extent map forwards */\n\t\t\tlblkno += map[i].br_blockcount;\n\t\t\tblkcnt -= map[i].br_blockcount;\n\t\t}\n\t}\n\tASSERT(valuelen == 0);\n\treturn 0;\n}",
          "includes": [
            "#include \"xfs_error.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_attr_remote.h\"",
            "#include \"xfs_attr_leaf.h\"",
            "#include \"xfs_attr.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [
            "#define ATTR_RMTVALUE_MAPSIZE\t1\t/* # of map entries at once */"
          ],
          "globals_used": [
            "const struct xfs_buf_ops xfs_attr3_rmt_buf_ops = {\n\t.verify_read = xfs_attr3_rmt_read_verify,\n\t.verify_write = xfs_attr3_rmt_write_verify,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_error.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_attr_remote.h\"\n#include \"xfs_attr_leaf.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\n#define ATTR_RMTVALUE_MAPSIZE\t1\t/* # of map entries at once */\n\nconst struct xfs_buf_ops xfs_attr3_rmt_buf_ops = {\n\t.verify_read = xfs_attr3_rmt_read_verify,\n\t.verify_write = xfs_attr3_rmt_write_verify,\n};\n\nint\nxfs_attr_rmtval_get(\n\tstruct xfs_da_args\t*args)\n{\n\tstruct xfs_bmbt_irec\tmap[ATTR_RMTVALUE_MAPSIZE];\n\tstruct xfs_mount\t*mp = args->dp->i_mount;\n\tstruct xfs_buf\t\t*bp;\n\txfs_dablk_t\t\tlblkno = args->rmtblkno;\n\t__uint8_t\t\t*dst = args->value;\n\tint\t\t\tvaluelen;\n\tint\t\t\tnmap;\n\tint\t\t\terror;\n\tint\t\t\tblkcnt = args->rmtblkcnt;\n\tint\t\t\ti;\n\tint\t\t\toffset = 0;\n\n\ttrace_xfs_attr_rmtval_get(args);\n\n\tASSERT(!(args->flags & ATTR_KERNOVAL));\n\tASSERT(args->rmtvaluelen == args->valuelen);\n\n\tvaluelen = args->rmtvaluelen;\n\twhile (valuelen > 0) {\n\t\tnmap = ATTR_RMTVALUE_MAPSIZE;\n\t\terror = xfs_bmapi_read(args->dp, (xfs_fileoff_t)lblkno,\n\t\t\t\t       blkcnt, map, &nmap,\n\t\t\t\t       XFS_BMAPI_ATTRFORK);\n\t\tif (error)\n\t\t\treturn error;\n\t\tASSERT(nmap >= 1);\n\n\t\tfor (i = 0; (i < nmap) && (valuelen > 0); i++) {\n\t\t\txfs_daddr_t\tdblkno;\n\t\t\tint\t\tdblkcnt;\n\n\t\t\tASSERT((map[i].br_startblock != DELAYSTARTBLOCK) &&\n\t\t\t       (map[i].br_startblock != HOLESTARTBLOCK));\n\t\t\tdblkno = XFS_FSB_TO_DADDR(mp, map[i].br_startblock);\n\t\t\tdblkcnt = XFS_FSB_TO_BB(mp, map[i].br_blockcount);\n\t\t\terror = xfs_trans_read_buf(mp, NULL, mp->m_ddev_targp,\n\t\t\t\t\t\t   dblkno, dblkcnt, 0, &bp,\n\t\t\t\t\t\t   &xfs_attr3_rmt_buf_ops);\n\t\t\tif (error)\n\t\t\t\treturn error;\n\n\t\t\terror = xfs_attr_rmtval_copyout(mp, bp, args->dp->i_ino,\n\t\t\t\t\t\t\t&offset, &valuelen,\n\t\t\t\t\t\t\t&dst);\n\t\t\txfs_buf_relse(bp);\n\t\t\tif (error)\n\t\t\t\treturn error;\n\n\t\t\t/* roll attribute extent map forwards */\n\t\t\tlblkno += map[i].br_blockcount;\n\t\t\tblkcnt -= map[i].br_blockcount;\n\t\t}\n\t}\n\tASSERT(valuelen == 0);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_attr3_rmt_blocks",
          "args": [
            "args.dp->i_mount",
            "valuelen"
          ],
          "line": 451
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_attr3_rmt_blocks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_attr_remote.c",
          "lines": "50-60",
          "snippet": "int\nxfs_attr3_rmt_blocks(\n\tstruct xfs_mount *mp,\n\tint\t\tattrlen)\n{\n\tif (xfs_sb_version_hascrc(&mp->m_sb)) {\n\t\tint buflen = XFS_ATTR3_RMT_BUF_SPACE(mp, mp->m_sb.sb_blocksize);\n\t\treturn (attrlen + buflen - 1) / buflen;\n\t}\n\treturn XFS_B_TO_FSB(mp, attrlen);\n}",
          "includes": [
            "#include \"xfs_error.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_attr_remote.h\"",
            "#include \"xfs_attr_leaf.h\"",
            "#include \"xfs_attr.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_error.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_attr_remote.h\"\n#include \"xfs_attr_leaf.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\nxfs_attr3_rmt_blocks(\n\tstruct xfs_mount *mp,\n\tint\t\tattrlen)\n{\n\tif (xfs_sb_version_hascrc(&mp->m_sb)) {\n\t\tint buflen = XFS_ATTR3_RMT_BUF_SPACE(mp, mp->m_sb.sb_blocksize);\n\t\treturn (attrlen + buflen - 1) / buflen;\n\t}\n\treturn XFS_B_TO_FSB(mp, attrlen);\n}"
        }
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "name_rmt->valueblk"
          ],
          "line": 450
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmem_alloc",
          "args": [
            "valuelen",
            "KM_SLEEP | KM_NOFS"
          ],
          "line": 449
        },
        "resolved": true,
        "details": {
          "function_name": "kmem_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/kmem.c",
          "lines": "45-62",
          "snippet": "void *\nkmem_alloc(size_t size, xfs_km_flags_t flags)\n{\n\tint\tretries = 0;\n\tgfp_t\tlflags = kmem_flags_convert(flags);\n\tvoid\t*ptr;\n\n\tdo {\n\t\tptr = kmalloc(size, lflags);\n\t\tif (ptr || (flags & (KM_MAYFAIL|KM_NOSLEEP)))\n\t\t\treturn ptr;\n\t\tif (!(++retries % 100))\n\t\t\txfs_err(NULL,\n\t\t\"possible memory allocation deadlock in %s (mode:0x%x)\",\n\t\t\t\t\t__func__, lflags);\n\t\tcongestion_wait(BLK_RW_ASYNC, HZ/50);\n\t} while (1);\n}",
          "includes": [
            "#include \"xfs_message.h\"",
            "#include \"kmem.h\"",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_message.h\"\n#include \"kmem.h\"\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\nvoid *\nkmem_alloc(size_t size, xfs_km_flags_t flags)\n{\n\tint\tretries = 0;\n\tgfp_t\tlflags = kmem_flags_convert(flags);\n\tvoid\t*ptr;\n\n\tdo {\n\t\tptr = kmalloc(size, lflags);\n\t\tif (ptr || (flags & (KM_MAYFAIL|KM_NOSLEEP)))\n\t\t\treturn ptr;\n\t\tif (!(++retries % 100))\n\t\t\txfs_err(NULL,\n\t\t\"possible memory allocation deadlock in %s (mode:0x%x)\",\n\t\t\t\t\t__func__, lflags);\n\t\tcongestion_wait(BLK_RW_ASYNC, HZ/50);\n\t} while (1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "(char *)&args",
            "0",
            "sizeof(args)"
          ],
          "line": 443
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "name_rmt->valuelen"
          ],
          "line": 438
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_attr3_leaf_name_remote",
          "args": [
            "leaf",
            "i"
          ],
          "line": 436
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_attr3_leaf_name_remote",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_da_format.h",
          "lines": "796-800",
          "snippet": "static inline xfs_attr_leaf_name_remote_t *\nxfs_attr3_leaf_name_remote(xfs_attr_leafblock_t *leafp, int idx)\n{\n\treturn (xfs_attr_leaf_name_remote_t *)xfs_attr3_leaf_name(leafp, idx);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline xfs_attr_leaf_name_remote_t *\nxfs_attr3_leaf_name_remote(xfs_attr_leafblock_t *leafp, int idx)\n{\n\treturn (xfs_attr_leaf_name_remote_t *)xfs_attr3_leaf_name(leafp, idx);\n}"
        }
      },
      {
        "call_info": {
          "callee": "context->put_listent",
          "args": [
            "context",
            "entry->flags",
            "name_loc->nameval",
            "(int)name_loc->namelen",
            "be16_to_cpu(name_loc->valuelen)",
            "&name_loc->nameval[name_loc->namelen]"
          ],
          "line": 426
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be16_to_cpu",
          "args": [
            "name_loc->valuelen"
          ],
          "line": 430
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_attr3_leaf_name_local",
          "args": [
            "leaf",
            "i"
          ],
          "line": 424
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_attr3_leaf_name_local",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_da_format.h",
          "lines": "802-806",
          "snippet": "static inline xfs_attr_leaf_name_local_t *\nxfs_attr3_leaf_name_local(xfs_attr_leafblock_t *leafp, int idx)\n{\n\treturn (xfs_attr_leaf_name_local_t *)xfs_attr3_leaf_name(leafp, idx);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline xfs_attr_leaf_name_local_t *\nxfs_attr3_leaf_name_local(xfs_attr_leafblock_t *leafp, int idx)\n{\n\treturn (xfs_attr_leaf_name_local_t *)xfs_attr3_leaf_name(leafp, idx);\n}"
        }
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "entry->hashval"
          ],
          "line": 415
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "entry->hashval"
          ],
          "line": 414
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_xfs_attr_list_notfound",
          "args": [
            "context"
          ],
          "line": 400
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "entry->hashval"
          ],
          "line": 393
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "entry->hashval"
          ],
          "line": 387
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_attr3_leaf_entryp",
          "args": [
            "leaf"
          ],
          "line": 376
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_attr3_leaf_entryp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_da_format.h",
          "lines": "777-783",
          "snippet": "static inline struct xfs_attr_leaf_entry *\nxfs_attr3_leaf_entryp(xfs_attr_leafblock_t *leafp)\n{\n\tif (leafp->hdr.info.magic == cpu_to_be16(XFS_ATTR3_LEAF_MAGIC))\n\t\treturn &((struct xfs_attr3_leafblock *)leafp)->entries[0];\n\treturn &leafp->entries[0];\n}",
          "includes": [],
          "macros_used": [
            "#define XFS_ATTR3_LEAF_MAGIC\t0x3bee\t/* magic number: attribute leaf blks */"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#define XFS_ATTR3_LEAF_MAGIC\t0x3bee\t/* magic number: attribute leaf blks */\n\nstatic inline struct xfs_attr_leaf_entry *\nxfs_attr3_leaf_entryp(xfs_attr_leafblock_t *leafp)\n{\n\tif (leafp->hdr.info.magic == cpu_to_be16(XFS_ATTR3_LEAF_MAGIC))\n\t\treturn &((struct xfs_attr3_leafblock *)leafp)->entries[0];\n\treturn &leafp->entries[0];\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_attr3_leaf_hdr_from_disk",
          "args": [
            "&ichdr",
            "leaf"
          ],
          "line": 375
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_attr3_leaf_hdr_from_disk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_attr_leaf.c",
          "lines": "89-128",
          "snippet": "void\nxfs_attr3_leaf_hdr_from_disk(\n\tstruct xfs_attr3_icleaf_hdr\t*to,\n\tstruct xfs_attr_leafblock\t*from)\n{\n\tint\ti;\n\n\tASSERT(from->hdr.info.magic == cpu_to_be16(XFS_ATTR_LEAF_MAGIC) ||\n\t       from->hdr.info.magic == cpu_to_be16(XFS_ATTR3_LEAF_MAGIC));\n\n\tif (from->hdr.info.magic == cpu_to_be16(XFS_ATTR3_LEAF_MAGIC)) {\n\t\tstruct xfs_attr3_leaf_hdr *hdr3 = (struct xfs_attr3_leaf_hdr *)from;\n\n\t\tto->forw = be32_to_cpu(hdr3->info.hdr.forw);\n\t\tto->back = be32_to_cpu(hdr3->info.hdr.back);\n\t\tto->magic = be16_to_cpu(hdr3->info.hdr.magic);\n\t\tto->count = be16_to_cpu(hdr3->count);\n\t\tto->usedbytes = be16_to_cpu(hdr3->usedbytes);\n\t\tto->firstused = be16_to_cpu(hdr3->firstused);\n\t\tto->holes = hdr3->holes;\n\n\t\tfor (i = 0; i < XFS_ATTR_LEAF_MAPSIZE; i++) {\n\t\t\tto->freemap[i].base = be16_to_cpu(hdr3->freemap[i].base);\n\t\t\tto->freemap[i].size = be16_to_cpu(hdr3->freemap[i].size);\n\t\t}\n\t\treturn;\n\t}\n\tto->forw = be32_to_cpu(from->hdr.info.forw);\n\tto->back = be32_to_cpu(from->hdr.info.back);\n\tto->magic = be16_to_cpu(from->hdr.info.magic);\n\tto->count = be16_to_cpu(from->hdr.count);\n\tto->usedbytes = be16_to_cpu(from->hdr.usedbytes);\n\tto->firstused = be16_to_cpu(from->hdr.firstused);\n\tto->holes = from->hdr.holes;\n\n\tfor (i = 0; i < XFS_ATTR_LEAF_MAPSIZE; i++) {\n\t\tto->freemap[i].base = be16_to_cpu(from->hdr.freemap[i].base);\n\t\tto->freemap[i].size = be16_to_cpu(from->hdr.freemap[i].size);\n\t}\n}",
          "includes": [
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_attr_leaf.h\"",
            "#include \"xfs_attr.h\"",
            "#include \"xfs_attr_remote.h\"",
            "#include \"xfs_attr_sf.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_dir2.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_attr_leaf.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_attr_remote.h\"\n#include \"xfs_attr_sf.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_attr3_leaf_hdr_from_disk(\n\tstruct xfs_attr3_icleaf_hdr\t*to,\n\tstruct xfs_attr_leafblock\t*from)\n{\n\tint\ti;\n\n\tASSERT(from->hdr.info.magic == cpu_to_be16(XFS_ATTR_LEAF_MAGIC) ||\n\t       from->hdr.info.magic == cpu_to_be16(XFS_ATTR3_LEAF_MAGIC));\n\n\tif (from->hdr.info.magic == cpu_to_be16(XFS_ATTR3_LEAF_MAGIC)) {\n\t\tstruct xfs_attr3_leaf_hdr *hdr3 = (struct xfs_attr3_leaf_hdr *)from;\n\n\t\tto->forw = be32_to_cpu(hdr3->info.hdr.forw);\n\t\tto->back = be32_to_cpu(hdr3->info.hdr.back);\n\t\tto->magic = be16_to_cpu(hdr3->info.hdr.magic);\n\t\tto->count = be16_to_cpu(hdr3->count);\n\t\tto->usedbytes = be16_to_cpu(hdr3->usedbytes);\n\t\tto->firstused = be16_to_cpu(hdr3->firstused);\n\t\tto->holes = hdr3->holes;\n\n\t\tfor (i = 0; i < XFS_ATTR_LEAF_MAPSIZE; i++) {\n\t\t\tto->freemap[i].base = be16_to_cpu(hdr3->freemap[i].base);\n\t\t\tto->freemap[i].size = be16_to_cpu(hdr3->freemap[i].size);\n\t\t}\n\t\treturn;\n\t}\n\tto->forw = be32_to_cpu(from->hdr.info.forw);\n\tto->back = be32_to_cpu(from->hdr.info.back);\n\tto->magic = be16_to_cpu(from->hdr.info.magic);\n\tto->count = be16_to_cpu(from->hdr.count);\n\tto->usedbytes = be16_to_cpu(from->hdr.usedbytes);\n\tto->firstused = be16_to_cpu(from->hdr.firstused);\n\tto->holes = from->hdr.holes;\n\n\tfor (i = 0; i < XFS_ATTR_LEAF_MAPSIZE; i++) {\n\t\tto->freemap[i].base = be16_to_cpu(from->hdr.freemap[i].base);\n\t\tto->freemap[i].size = be16_to_cpu(from->hdr.freemap[i].size);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_xfs_attr_list_leaf",
          "args": [
            "context"
          ],
          "line": 372
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_dir2.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_attr_leaf.h\"\n#include \"xfs_attr_remote.h\"\n#include \"xfs_attr_sf.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\nxfs_attr3_leaf_list_int(\n\tstruct xfs_buf\t\t\t*bp,\n\tstruct xfs_attr_list_context\t*context)\n{\n\tstruct attrlist_cursor_kern\t*cursor;\n\tstruct xfs_attr_leafblock\t*leaf;\n\tstruct xfs_attr3_icleaf_hdr\tichdr;\n\tstruct xfs_attr_leaf_entry\t*entries;\n\tstruct xfs_attr_leaf_entry\t*entry;\n\tint\t\t\t\tretval;\n\tint\t\t\t\ti;\n\n\ttrace_xfs_attr_list_leaf(context);\n\n\tleaf = bp->b_addr;\n\txfs_attr3_leaf_hdr_from_disk(&ichdr, leaf);\n\tentries = xfs_attr3_leaf_entryp(leaf);\n\n\tcursor = context->cursor;\n\tcursor->initted = 1;\n\n\t/*\n\t * Re-find our place in the leaf block if this is a new syscall.\n\t */\n\tif (context->resynch) {\n\t\tentry = &entries[0];\n\t\tfor (i = 0; i < ichdr.count; entry++, i++) {\n\t\t\tif (be32_to_cpu(entry->hashval) == cursor->hashval) {\n\t\t\t\tif (cursor->offset == context->dupcnt) {\n\t\t\t\t\tcontext->dupcnt = 0;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tcontext->dupcnt++;\n\t\t\t} else if (be32_to_cpu(entry->hashval) >\n\t\t\t\t\tcursor->hashval) {\n\t\t\t\tcontext->dupcnt = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (i == ichdr.count) {\n\t\t\ttrace_xfs_attr_list_notfound(context);\n\t\t\treturn 0;\n\t\t}\n\t} else {\n\t\tentry = &entries[0];\n\t\ti = 0;\n\t}\n\tcontext->resynch = 0;\n\n\t/*\n\t * We have found our place, start copying out the new attributes.\n\t */\n\tretval = 0;\n\tfor (; i < ichdr.count; entry++, i++) {\n\t\tif (be32_to_cpu(entry->hashval) != cursor->hashval) {\n\t\t\tcursor->hashval = be32_to_cpu(entry->hashval);\n\t\t\tcursor->offset = 0;\n\t\t}\n\n\t\tif (entry->flags & XFS_ATTR_INCOMPLETE)\n\t\t\tcontinue;\t\t/* skip incomplete entries */\n\n\t\tif (entry->flags & XFS_ATTR_LOCAL) {\n\t\t\txfs_attr_leaf_name_local_t *name_loc =\n\t\t\t\txfs_attr3_leaf_name_local(leaf, i);\n\n\t\t\tretval = context->put_listent(context,\n\t\t\t\t\t\tentry->flags,\n\t\t\t\t\t\tname_loc->nameval,\n\t\t\t\t\t\t(int)name_loc->namelen,\n\t\t\t\t\t\tbe16_to_cpu(name_loc->valuelen),\n\t\t\t\t\t\t&name_loc->nameval[name_loc->namelen]);\n\t\t\tif (retval)\n\t\t\t\treturn retval;\n\t\t} else {\n\t\t\txfs_attr_leaf_name_remote_t *name_rmt =\n\t\t\t\txfs_attr3_leaf_name_remote(leaf, i);\n\n\t\t\tint valuelen = be32_to_cpu(name_rmt->valuelen);\n\n\t\t\tif (context->put_value) {\n\t\t\t\txfs_da_args_t args;\n\n\t\t\t\tmemset((char *)&args, 0, sizeof(args));\n\t\t\t\targs.geo = context->dp->i_mount->m_attr_geo;\n\t\t\t\targs.dp = context->dp;\n\t\t\t\targs.whichfork = XFS_ATTR_FORK;\n\t\t\t\targs.valuelen = valuelen;\n\t\t\t\targs.rmtvaluelen = valuelen;\n\t\t\t\targs.value = kmem_alloc(valuelen, KM_SLEEP | KM_NOFS);\n\t\t\t\targs.rmtblkno = be32_to_cpu(name_rmt->valueblk);\n\t\t\t\targs.rmtblkcnt = xfs_attr3_rmt_blocks(\n\t\t\t\t\t\t\targs.dp->i_mount, valuelen);\n\t\t\t\tretval = xfs_attr_rmtval_get(&args);\n\t\t\t\tif (retval)\n\t\t\t\t\treturn retval;\n\t\t\t\tretval = context->put_listent(context,\n\t\t\t\t\t\tentry->flags,\n\t\t\t\t\t\tname_rmt->name,\n\t\t\t\t\t\t(int)name_rmt->namelen,\n\t\t\t\t\t\tvaluelen,\n\t\t\t\t\t\targs.value);\n\t\t\t\tkmem_free(args.value);\n\t\t\t} else {\n\t\t\t\tretval = context->put_listent(context,\n\t\t\t\t\t\tentry->flags,\n\t\t\t\t\t\tname_rmt->name,\n\t\t\t\t\t\t(int)name_rmt->namelen,\n\t\t\t\t\t\tvaluelen,\n\t\t\t\t\t\tNULL);\n\t\t\t}\n\t\t\tif (retval)\n\t\t\t\treturn retval;\n\t\t}\n\t\tif (context->seen_enough)\n\t\t\tbreak;\n\t\tcursor->offset++;\n\t}\n\ttrace_xfs_attr_list_leaf_end(context);\n\treturn retval;\n}"
  },
  {
    "function_name": "xfs_attr_node_list",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_attr_list.c",
    "lines": "216-354",
    "snippet": "STATIC int\nxfs_attr_node_list(xfs_attr_list_context_t *context)\n{\n\tattrlist_cursor_kern_t *cursor;\n\txfs_attr_leafblock_t *leaf;\n\txfs_da_intnode_t *node;\n\tstruct xfs_attr3_icleaf_hdr leafhdr;\n\tstruct xfs_da3_icnode_hdr nodehdr;\n\tstruct xfs_da_node_entry *btree;\n\tint error, i;\n\tstruct xfs_buf *bp;\n\tstruct xfs_inode\t*dp = context->dp;\n\n\ttrace_xfs_attr_node_list(context);\n\n\tcursor = context->cursor;\n\tcursor->initted = 1;\n\n\t/*\n\t * Do all sorts of validation on the passed-in cursor structure.\n\t * If anything is amiss, ignore the cursor and look up the hashval\n\t * starting from the btree root.\n\t */\n\tbp = NULL;\n\tif (cursor->blkno > 0) {\n\t\terror = xfs_da3_node_read(NULL, dp, cursor->blkno, -1,\n\t\t\t\t\t      &bp, XFS_ATTR_FORK);\n\t\tif ((error != 0) && (error != -EFSCORRUPTED))\n\t\t\treturn error;\n\t\tif (bp) {\n\t\t\tstruct xfs_attr_leaf_entry *entries;\n\n\t\t\tnode = bp->b_addr;\n\t\t\tswitch (be16_to_cpu(node->hdr.info.magic)) {\n\t\t\tcase XFS_DA_NODE_MAGIC:\n\t\t\tcase XFS_DA3_NODE_MAGIC:\n\t\t\t\ttrace_xfs_attr_list_wrong_blk(context);\n\t\t\t\txfs_trans_brelse(NULL, bp);\n\t\t\t\tbp = NULL;\n\t\t\t\tbreak;\n\t\t\tcase XFS_ATTR_LEAF_MAGIC:\n\t\t\tcase XFS_ATTR3_LEAF_MAGIC:\n\t\t\t\tleaf = bp->b_addr;\n\t\t\t\txfs_attr3_leaf_hdr_from_disk(&leafhdr, leaf);\n\t\t\t\tentries = xfs_attr3_leaf_entryp(leaf);\n\t\t\t\tif (cursor->hashval > be32_to_cpu(\n\t\t\t\t\t\tentries[leafhdr.count - 1].hashval)) {\n\t\t\t\t\ttrace_xfs_attr_list_wrong_blk(context);\n\t\t\t\t\txfs_trans_brelse(NULL, bp);\n\t\t\t\t\tbp = NULL;\n\t\t\t\t} else if (cursor->hashval <= be32_to_cpu(\n\t\t\t\t\t\tentries[0].hashval)) {\n\t\t\t\t\ttrace_xfs_attr_list_wrong_blk(context);\n\t\t\t\t\txfs_trans_brelse(NULL, bp);\n\t\t\t\t\tbp = NULL;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\ttrace_xfs_attr_list_wrong_blk(context);\n\t\t\t\txfs_trans_brelse(NULL, bp);\n\t\t\t\tbp = NULL;\n\t\t\t}\n\t\t}\n\t}\n\n\t/*\n\t * We did not find what we expected given the cursor's contents,\n\t * so we start from the top and work down based on the hash value.\n\t * Note that start of node block is same as start of leaf block.\n\t */\n\tif (bp == NULL) {\n\t\tcursor->blkno = 0;\n\t\tfor (;;) {\n\t\t\t__uint16_t magic;\n\n\t\t\terror = xfs_da3_node_read(NULL, dp,\n\t\t\t\t\t\t      cursor->blkno, -1, &bp,\n\t\t\t\t\t\t      XFS_ATTR_FORK);\n\t\t\tif (error)\n\t\t\t\treturn error;\n\t\t\tnode = bp->b_addr;\n\t\t\tmagic = be16_to_cpu(node->hdr.info.magic);\n\t\t\tif (magic == XFS_ATTR_LEAF_MAGIC ||\n\t\t\t    magic == XFS_ATTR3_LEAF_MAGIC)\n\t\t\t\tbreak;\n\t\t\tif (magic != XFS_DA_NODE_MAGIC &&\n\t\t\t    magic != XFS_DA3_NODE_MAGIC) {\n\t\t\t\tXFS_CORRUPTION_ERROR(\"xfs_attr_node_list(3)\",\n\t\t\t\t\t\t     XFS_ERRLEVEL_LOW,\n\t\t\t\t\t\t     context->dp->i_mount,\n\t\t\t\t\t\t     node);\n\t\t\t\txfs_trans_brelse(NULL, bp);\n\t\t\t\treturn -EFSCORRUPTED;\n\t\t\t}\n\n\t\t\tdp->d_ops->node_hdr_from_disk(&nodehdr, node);\n\t\t\tbtree = dp->d_ops->node_tree_p(node);\n\t\t\tfor (i = 0; i < nodehdr.count; btree++, i++) {\n\t\t\t\tif (cursor->hashval\n\t\t\t\t\t\t<= be32_to_cpu(btree->hashval)) {\n\t\t\t\t\tcursor->blkno = be32_to_cpu(btree->before);\n\t\t\t\t\ttrace_xfs_attr_list_node_descend(context,\n\t\t\t\t\t\t\t\t\t btree);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (i == nodehdr.count) {\n\t\t\t\txfs_trans_brelse(NULL, bp);\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\txfs_trans_brelse(NULL, bp);\n\t\t}\n\t}\n\tASSERT(bp != NULL);\n\n\t/*\n\t * Roll upward through the blocks, processing each leaf block in\n\t * order.  As long as there is space in the result buffer, keep\n\t * adding the information.\n\t */\n\tfor (;;) {\n\t\tleaf = bp->b_addr;\n\t\terror = xfs_attr3_leaf_list_int(bp, context);\n\t\tif (error) {\n\t\t\txfs_trans_brelse(NULL, bp);\n\t\t\treturn error;\n\t\t}\n\t\txfs_attr3_leaf_hdr_from_disk(&leafhdr, leaf);\n\t\tif (context->seen_enough || leafhdr.forw == 0)\n\t\t\tbreak;\n\t\tcursor->blkno = leafhdr.forw;\n\t\txfs_trans_brelse(NULL, bp);\n\t\terror = xfs_attr3_leaf_read(NULL, dp, cursor->blkno, -1, &bp);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\txfs_trans_brelse(NULL, bp);\n\treturn 0;\n}",
    "includes": [
      "#include \"xfs_dir2.h\"",
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_buf_item.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_attr_leaf.h\"",
      "#include \"xfs_attr_remote.h\"",
      "#include \"xfs_attr_sf.h\"",
      "#include \"xfs_attr.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_inode_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_da_btree.h\"",
      "#include \"xfs_da_format.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_bit.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_trans_brelse",
          "args": [
            "NULL",
            "bp"
          ],
          "line": 352
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_trans_brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans_buf.c",
          "lines": "354-443",
          "snippet": "void\nxfs_trans_brelse(xfs_trans_t\t*tp,\n\t\t xfs_buf_t\t*bp)\n{\n\txfs_buf_log_item_t\t*bip;\n\n\t/*\n\t * Default to a normal brelse() call if the tp is NULL.\n\t */\n\tif (tp == NULL) {\n\t\tASSERT(bp->b_transp == NULL);\n\t\txfs_buf_relse(bp);\n\t\treturn;\n\t}\n\n\tASSERT(bp->b_transp == tp);\n\tbip = bp->b_fspriv;\n\tASSERT(bip->bli_item.li_type == XFS_LI_BUF);\n\tASSERT(!(bip->bli_flags & XFS_BLI_STALE));\n\tASSERT(!(bip->__bli_format.blf_flags & XFS_BLF_CANCEL));\n\tASSERT(atomic_read(&bip->bli_refcount) > 0);\n\n\ttrace_xfs_trans_brelse(bip);\n\n\t/*\n\t * If the release is just for a recursive lock,\n\t * then decrement the count and return.\n\t */\n\tif (bip->bli_recur > 0) {\n\t\tbip->bli_recur--;\n\t\treturn;\n\t}\n\n\t/*\n\t * If the buffer is dirty within this transaction, we can't\n\t * release it until we commit.\n\t */\n\tif (bip->bli_item.li_desc->lid_flags & XFS_LID_DIRTY)\n\t\treturn;\n\n\t/*\n\t * If the buffer has been invalidated, then we can't release\n\t * it until the transaction commits to disk unless it is re-dirtied\n\t * as part of this transaction.  This prevents us from pulling\n\t * the item from the AIL before we should.\n\t */\n\tif (bip->bli_flags & XFS_BLI_STALE)\n\t\treturn;\n\n\tASSERT(!(bip->bli_flags & XFS_BLI_LOGGED));\n\n\t/*\n\t * Free up the log item descriptor tracking the released item.\n\t */\n\txfs_trans_del_item(&bip->bli_item);\n\n\t/*\n\t * Clear the hold flag in the buf log item if it is set.\n\t * We wouldn't want the next user of the buffer to\n\t * get confused.\n\t */\n\tif (bip->bli_flags & XFS_BLI_HOLD) {\n\t\tbip->bli_flags &= ~XFS_BLI_HOLD;\n\t}\n\n\t/*\n\t * Drop our reference to the buf log item.\n\t */\n\tatomic_dec(&bip->bli_refcount);\n\n\t/*\n\t * If the buf item is not tracking data in the log, then\n\t * we must free it before releasing the buffer back to the\n\t * free pool.  Before releasing the buffer to the free pool,\n\t * clear the transaction pointer in b_fsprivate2 to dissolve\n\t * its relation to this transaction.\n\t */\n\tif (!xfs_buf_item_dirty(bip)) {\n/***\n\t\tASSERT(bp->b_pincount == 0);\n***/\n\t\tASSERT(atomic_read(&bip->bli_refcount) == 0);\n\t\tASSERT(!(bip->bli_item.li_flags & XFS_LI_IN_AIL));\n\t\tASSERT(!(bip->bli_flags & XFS_BLI_INODE_ALLOC_BUF));\n\t\txfs_buf_item_relse(bp);\n\t}\n\n\tbp->b_transp = NULL;\n\txfs_buf_relse(bp);\n}",
          "includes": [
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_trans_brelse(xfs_trans_t\t*tp,\n\t\t xfs_buf_t\t*bp)\n{\n\txfs_buf_log_item_t\t*bip;\n\n\t/*\n\t * Default to a normal brelse() call if the tp is NULL.\n\t */\n\tif (tp == NULL) {\n\t\tASSERT(bp->b_transp == NULL);\n\t\txfs_buf_relse(bp);\n\t\treturn;\n\t}\n\n\tASSERT(bp->b_transp == tp);\n\tbip = bp->b_fspriv;\n\tASSERT(bip->bli_item.li_type == XFS_LI_BUF);\n\tASSERT(!(bip->bli_flags & XFS_BLI_STALE));\n\tASSERT(!(bip->__bli_format.blf_flags & XFS_BLF_CANCEL));\n\tASSERT(atomic_read(&bip->bli_refcount) > 0);\n\n\ttrace_xfs_trans_brelse(bip);\n\n\t/*\n\t * If the release is just for a recursive lock,\n\t * then decrement the count and return.\n\t */\n\tif (bip->bli_recur > 0) {\n\t\tbip->bli_recur--;\n\t\treturn;\n\t}\n\n\t/*\n\t * If the buffer is dirty within this transaction, we can't\n\t * release it until we commit.\n\t */\n\tif (bip->bli_item.li_desc->lid_flags & XFS_LID_DIRTY)\n\t\treturn;\n\n\t/*\n\t * If the buffer has been invalidated, then we can't release\n\t * it until the transaction commits to disk unless it is re-dirtied\n\t * as part of this transaction.  This prevents us from pulling\n\t * the item from the AIL before we should.\n\t */\n\tif (bip->bli_flags & XFS_BLI_STALE)\n\t\treturn;\n\n\tASSERT(!(bip->bli_flags & XFS_BLI_LOGGED));\n\n\t/*\n\t * Free up the log item descriptor tracking the released item.\n\t */\n\txfs_trans_del_item(&bip->bli_item);\n\n\t/*\n\t * Clear the hold flag in the buf log item if it is set.\n\t * We wouldn't want the next user of the buffer to\n\t * get confused.\n\t */\n\tif (bip->bli_flags & XFS_BLI_HOLD) {\n\t\tbip->bli_flags &= ~XFS_BLI_HOLD;\n\t}\n\n\t/*\n\t * Drop our reference to the buf log item.\n\t */\n\tatomic_dec(&bip->bli_refcount);\n\n\t/*\n\t * If the buf item is not tracking data in the log, then\n\t * we must free it before releasing the buffer back to the\n\t * free pool.  Before releasing the buffer to the free pool,\n\t * clear the transaction pointer in b_fsprivate2 to dissolve\n\t * its relation to this transaction.\n\t */\n\tif (!xfs_buf_item_dirty(bip)) {\n/***\n\t\tASSERT(bp->b_pincount == 0);\n***/\n\t\tASSERT(atomic_read(&bip->bli_refcount) == 0);\n\t\tASSERT(!(bip->bli_item.li_flags & XFS_LI_IN_AIL));\n\t\tASSERT(!(bip->bli_flags & XFS_BLI_INODE_ALLOC_BUF));\n\t\txfs_buf_item_relse(bp);\n\t}\n\n\tbp->b_transp = NULL;\n\txfs_buf_relse(bp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_attr3_leaf_read",
          "args": [
            "NULL",
            "dp",
            "cursor->blkno",
            "-1",
            "&bp"
          ],
          "line": 348
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_attr3_leaf_read",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_attr_leaf.c",
          "lines": "256-271",
          "snippet": "int\nxfs_attr3_leaf_read(\n\tstruct xfs_trans\t*tp,\n\tstruct xfs_inode\t*dp,\n\txfs_dablk_t\t\tbno,\n\txfs_daddr_t\t\tmappedbno,\n\tstruct xfs_buf\t\t**bpp)\n{\n\tint\t\t\terr;\n\n\terr = xfs_da_read_buf(tp, dp, bno, mappedbno, bpp,\n\t\t\t\tXFS_ATTR_FORK, &xfs_attr3_leaf_buf_ops);\n\tif (!err && tp)\n\t\txfs_trans_buf_set_type(tp, *bpp, XFS_BLFT_ATTR_LEAF_BUF);\n\treturn err;\n}",
          "includes": [
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_attr_leaf.h\"",
            "#include \"xfs_attr.h\"",
            "#include \"xfs_attr_remote.h\"",
            "#include \"xfs_attr_sf.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC int xfs_attr3_leaf_create(struct xfs_da_args *args,\n\t\t\t\t xfs_dablk_t which_block, struct xfs_buf **bpp);",
            "const struct xfs_buf_ops xfs_attr3_leaf_buf_ops = {\n\t.verify_read = xfs_attr3_leaf_read_verify,\n\t.verify_write = xfs_attr3_leaf_write_verify,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_dir2.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_attr_leaf.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_attr_remote.h\"\n#include \"xfs_attr_sf.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC int xfs_attr3_leaf_create(struct xfs_da_args *args,\n\t\t\t\t xfs_dablk_t which_block, struct xfs_buf **bpp);\nconst struct xfs_buf_ops xfs_attr3_leaf_buf_ops = {\n\t.verify_read = xfs_attr3_leaf_read_verify,\n\t.verify_write = xfs_attr3_leaf_write_verify,\n};\n\nint\nxfs_attr3_leaf_read(\n\tstruct xfs_trans\t*tp,\n\tstruct xfs_inode\t*dp,\n\txfs_dablk_t\t\tbno,\n\txfs_daddr_t\t\tmappedbno,\n\tstruct xfs_buf\t\t**bpp)\n{\n\tint\t\t\terr;\n\n\terr = xfs_da_read_buf(tp, dp, bno, mappedbno, bpp,\n\t\t\t\tXFS_ATTR_FORK, &xfs_attr3_leaf_buf_ops);\n\tif (!err && tp)\n\t\txfs_trans_buf_set_type(tp, *bpp, XFS_BLFT_ATTR_LEAF_BUF);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_attr3_leaf_hdr_from_disk",
          "args": [
            "&leafhdr",
            "leaf"
          ],
          "line": 343
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_attr3_leaf_hdr_from_disk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_attr_leaf.c",
          "lines": "89-128",
          "snippet": "void\nxfs_attr3_leaf_hdr_from_disk(\n\tstruct xfs_attr3_icleaf_hdr\t*to,\n\tstruct xfs_attr_leafblock\t*from)\n{\n\tint\ti;\n\n\tASSERT(from->hdr.info.magic == cpu_to_be16(XFS_ATTR_LEAF_MAGIC) ||\n\t       from->hdr.info.magic == cpu_to_be16(XFS_ATTR3_LEAF_MAGIC));\n\n\tif (from->hdr.info.magic == cpu_to_be16(XFS_ATTR3_LEAF_MAGIC)) {\n\t\tstruct xfs_attr3_leaf_hdr *hdr3 = (struct xfs_attr3_leaf_hdr *)from;\n\n\t\tto->forw = be32_to_cpu(hdr3->info.hdr.forw);\n\t\tto->back = be32_to_cpu(hdr3->info.hdr.back);\n\t\tto->magic = be16_to_cpu(hdr3->info.hdr.magic);\n\t\tto->count = be16_to_cpu(hdr3->count);\n\t\tto->usedbytes = be16_to_cpu(hdr3->usedbytes);\n\t\tto->firstused = be16_to_cpu(hdr3->firstused);\n\t\tto->holes = hdr3->holes;\n\n\t\tfor (i = 0; i < XFS_ATTR_LEAF_MAPSIZE; i++) {\n\t\t\tto->freemap[i].base = be16_to_cpu(hdr3->freemap[i].base);\n\t\t\tto->freemap[i].size = be16_to_cpu(hdr3->freemap[i].size);\n\t\t}\n\t\treturn;\n\t}\n\tto->forw = be32_to_cpu(from->hdr.info.forw);\n\tto->back = be32_to_cpu(from->hdr.info.back);\n\tto->magic = be16_to_cpu(from->hdr.info.magic);\n\tto->count = be16_to_cpu(from->hdr.count);\n\tto->usedbytes = be16_to_cpu(from->hdr.usedbytes);\n\tto->firstused = be16_to_cpu(from->hdr.firstused);\n\tto->holes = from->hdr.holes;\n\n\tfor (i = 0; i < XFS_ATTR_LEAF_MAPSIZE; i++) {\n\t\tto->freemap[i].base = be16_to_cpu(from->hdr.freemap[i].base);\n\t\tto->freemap[i].size = be16_to_cpu(from->hdr.freemap[i].size);\n\t}\n}",
          "includes": [
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_attr_leaf.h\"",
            "#include \"xfs_attr.h\"",
            "#include \"xfs_attr_remote.h\"",
            "#include \"xfs_attr_sf.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_dir2.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_attr_leaf.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_attr_remote.h\"\n#include \"xfs_attr_sf.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_attr3_leaf_hdr_from_disk(\n\tstruct xfs_attr3_icleaf_hdr\t*to,\n\tstruct xfs_attr_leafblock\t*from)\n{\n\tint\ti;\n\n\tASSERT(from->hdr.info.magic == cpu_to_be16(XFS_ATTR_LEAF_MAGIC) ||\n\t       from->hdr.info.magic == cpu_to_be16(XFS_ATTR3_LEAF_MAGIC));\n\n\tif (from->hdr.info.magic == cpu_to_be16(XFS_ATTR3_LEAF_MAGIC)) {\n\t\tstruct xfs_attr3_leaf_hdr *hdr3 = (struct xfs_attr3_leaf_hdr *)from;\n\n\t\tto->forw = be32_to_cpu(hdr3->info.hdr.forw);\n\t\tto->back = be32_to_cpu(hdr3->info.hdr.back);\n\t\tto->magic = be16_to_cpu(hdr3->info.hdr.magic);\n\t\tto->count = be16_to_cpu(hdr3->count);\n\t\tto->usedbytes = be16_to_cpu(hdr3->usedbytes);\n\t\tto->firstused = be16_to_cpu(hdr3->firstused);\n\t\tto->holes = hdr3->holes;\n\n\t\tfor (i = 0; i < XFS_ATTR_LEAF_MAPSIZE; i++) {\n\t\t\tto->freemap[i].base = be16_to_cpu(hdr3->freemap[i].base);\n\t\t\tto->freemap[i].size = be16_to_cpu(hdr3->freemap[i].size);\n\t\t}\n\t\treturn;\n\t}\n\tto->forw = be32_to_cpu(from->hdr.info.forw);\n\tto->back = be32_to_cpu(from->hdr.info.back);\n\tto->magic = be16_to_cpu(from->hdr.info.magic);\n\tto->count = be16_to_cpu(from->hdr.count);\n\tto->usedbytes = be16_to_cpu(from->hdr.usedbytes);\n\tto->firstused = be16_to_cpu(from->hdr.firstused);\n\tto->holes = from->hdr.holes;\n\n\tfor (i = 0; i < XFS_ATTR_LEAF_MAPSIZE; i++) {\n\t\tto->freemap[i].base = be16_to_cpu(from->hdr.freemap[i].base);\n\t\tto->freemap[i].size = be16_to_cpu(from->hdr.freemap[i].size);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_attr3_leaf_list_int",
          "args": [
            "bp",
            "context"
          ],
          "line": 338
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_attr3_leaf_list_int",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_attr_list.c",
          "lines": "359-480",
          "snippet": "int\nxfs_attr3_leaf_list_int(\n\tstruct xfs_buf\t\t\t*bp,\n\tstruct xfs_attr_list_context\t*context)\n{\n\tstruct attrlist_cursor_kern\t*cursor;\n\tstruct xfs_attr_leafblock\t*leaf;\n\tstruct xfs_attr3_icleaf_hdr\tichdr;\n\tstruct xfs_attr_leaf_entry\t*entries;\n\tstruct xfs_attr_leaf_entry\t*entry;\n\tint\t\t\t\tretval;\n\tint\t\t\t\ti;\n\n\ttrace_xfs_attr_list_leaf(context);\n\n\tleaf = bp->b_addr;\n\txfs_attr3_leaf_hdr_from_disk(&ichdr, leaf);\n\tentries = xfs_attr3_leaf_entryp(leaf);\n\n\tcursor = context->cursor;\n\tcursor->initted = 1;\n\n\t/*\n\t * Re-find our place in the leaf block if this is a new syscall.\n\t */\n\tif (context->resynch) {\n\t\tentry = &entries[0];\n\t\tfor (i = 0; i < ichdr.count; entry++, i++) {\n\t\t\tif (be32_to_cpu(entry->hashval) == cursor->hashval) {\n\t\t\t\tif (cursor->offset == context->dupcnt) {\n\t\t\t\t\tcontext->dupcnt = 0;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tcontext->dupcnt++;\n\t\t\t} else if (be32_to_cpu(entry->hashval) >\n\t\t\t\t\tcursor->hashval) {\n\t\t\t\tcontext->dupcnt = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (i == ichdr.count) {\n\t\t\ttrace_xfs_attr_list_notfound(context);\n\t\t\treturn 0;\n\t\t}\n\t} else {\n\t\tentry = &entries[0];\n\t\ti = 0;\n\t}\n\tcontext->resynch = 0;\n\n\t/*\n\t * We have found our place, start copying out the new attributes.\n\t */\n\tretval = 0;\n\tfor (; i < ichdr.count; entry++, i++) {\n\t\tif (be32_to_cpu(entry->hashval) != cursor->hashval) {\n\t\t\tcursor->hashval = be32_to_cpu(entry->hashval);\n\t\t\tcursor->offset = 0;\n\t\t}\n\n\t\tif (entry->flags & XFS_ATTR_INCOMPLETE)\n\t\t\tcontinue;\t\t/* skip incomplete entries */\n\n\t\tif (entry->flags & XFS_ATTR_LOCAL) {\n\t\t\txfs_attr_leaf_name_local_t *name_loc =\n\t\t\t\txfs_attr3_leaf_name_local(leaf, i);\n\n\t\t\tretval = context->put_listent(context,\n\t\t\t\t\t\tentry->flags,\n\t\t\t\t\t\tname_loc->nameval,\n\t\t\t\t\t\t(int)name_loc->namelen,\n\t\t\t\t\t\tbe16_to_cpu(name_loc->valuelen),\n\t\t\t\t\t\t&name_loc->nameval[name_loc->namelen]);\n\t\t\tif (retval)\n\t\t\t\treturn retval;\n\t\t} else {\n\t\t\txfs_attr_leaf_name_remote_t *name_rmt =\n\t\t\t\txfs_attr3_leaf_name_remote(leaf, i);\n\n\t\t\tint valuelen = be32_to_cpu(name_rmt->valuelen);\n\n\t\t\tif (context->put_value) {\n\t\t\t\txfs_da_args_t args;\n\n\t\t\t\tmemset((char *)&args, 0, sizeof(args));\n\t\t\t\targs.geo = context->dp->i_mount->m_attr_geo;\n\t\t\t\targs.dp = context->dp;\n\t\t\t\targs.whichfork = XFS_ATTR_FORK;\n\t\t\t\targs.valuelen = valuelen;\n\t\t\t\targs.rmtvaluelen = valuelen;\n\t\t\t\targs.value = kmem_alloc(valuelen, KM_SLEEP | KM_NOFS);\n\t\t\t\targs.rmtblkno = be32_to_cpu(name_rmt->valueblk);\n\t\t\t\targs.rmtblkcnt = xfs_attr3_rmt_blocks(\n\t\t\t\t\t\t\targs.dp->i_mount, valuelen);\n\t\t\t\tretval = xfs_attr_rmtval_get(&args);\n\t\t\t\tif (retval)\n\t\t\t\t\treturn retval;\n\t\t\t\tretval = context->put_listent(context,\n\t\t\t\t\t\tentry->flags,\n\t\t\t\t\t\tname_rmt->name,\n\t\t\t\t\t\t(int)name_rmt->namelen,\n\t\t\t\t\t\tvaluelen,\n\t\t\t\t\t\targs.value);\n\t\t\t\tkmem_free(args.value);\n\t\t\t} else {\n\t\t\t\tretval = context->put_listent(context,\n\t\t\t\t\t\tentry->flags,\n\t\t\t\t\t\tname_rmt->name,\n\t\t\t\t\t\t(int)name_rmt->namelen,\n\t\t\t\t\t\tvaluelen,\n\t\t\t\t\t\tNULL);\n\t\t\t}\n\t\t\tif (retval)\n\t\t\t\treturn retval;\n\t\t}\n\t\tif (context->seen_enough)\n\t\t\tbreak;\n\t\tcursor->offset++;\n\t}\n\ttrace_xfs_attr_list_leaf_end(context);\n\treturn retval;\n}",
          "includes": [
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_attr_leaf.h\"",
            "#include \"xfs_attr_remote.h\"",
            "#include \"xfs_attr_sf.h\"",
            "#include \"xfs_attr.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_dir2.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_attr_leaf.h\"\n#include \"xfs_attr_remote.h\"\n#include \"xfs_attr_sf.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\nxfs_attr3_leaf_list_int(\n\tstruct xfs_buf\t\t\t*bp,\n\tstruct xfs_attr_list_context\t*context)\n{\n\tstruct attrlist_cursor_kern\t*cursor;\n\tstruct xfs_attr_leafblock\t*leaf;\n\tstruct xfs_attr3_icleaf_hdr\tichdr;\n\tstruct xfs_attr_leaf_entry\t*entries;\n\tstruct xfs_attr_leaf_entry\t*entry;\n\tint\t\t\t\tretval;\n\tint\t\t\t\ti;\n\n\ttrace_xfs_attr_list_leaf(context);\n\n\tleaf = bp->b_addr;\n\txfs_attr3_leaf_hdr_from_disk(&ichdr, leaf);\n\tentries = xfs_attr3_leaf_entryp(leaf);\n\n\tcursor = context->cursor;\n\tcursor->initted = 1;\n\n\t/*\n\t * Re-find our place in the leaf block if this is a new syscall.\n\t */\n\tif (context->resynch) {\n\t\tentry = &entries[0];\n\t\tfor (i = 0; i < ichdr.count; entry++, i++) {\n\t\t\tif (be32_to_cpu(entry->hashval) == cursor->hashval) {\n\t\t\t\tif (cursor->offset == context->dupcnt) {\n\t\t\t\t\tcontext->dupcnt = 0;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tcontext->dupcnt++;\n\t\t\t} else if (be32_to_cpu(entry->hashval) >\n\t\t\t\t\tcursor->hashval) {\n\t\t\t\tcontext->dupcnt = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (i == ichdr.count) {\n\t\t\ttrace_xfs_attr_list_notfound(context);\n\t\t\treturn 0;\n\t\t}\n\t} else {\n\t\tentry = &entries[0];\n\t\ti = 0;\n\t}\n\tcontext->resynch = 0;\n\n\t/*\n\t * We have found our place, start copying out the new attributes.\n\t */\n\tretval = 0;\n\tfor (; i < ichdr.count; entry++, i++) {\n\t\tif (be32_to_cpu(entry->hashval) != cursor->hashval) {\n\t\t\tcursor->hashval = be32_to_cpu(entry->hashval);\n\t\t\tcursor->offset = 0;\n\t\t}\n\n\t\tif (entry->flags & XFS_ATTR_INCOMPLETE)\n\t\t\tcontinue;\t\t/* skip incomplete entries */\n\n\t\tif (entry->flags & XFS_ATTR_LOCAL) {\n\t\t\txfs_attr_leaf_name_local_t *name_loc =\n\t\t\t\txfs_attr3_leaf_name_local(leaf, i);\n\n\t\t\tretval = context->put_listent(context,\n\t\t\t\t\t\tentry->flags,\n\t\t\t\t\t\tname_loc->nameval,\n\t\t\t\t\t\t(int)name_loc->namelen,\n\t\t\t\t\t\tbe16_to_cpu(name_loc->valuelen),\n\t\t\t\t\t\t&name_loc->nameval[name_loc->namelen]);\n\t\t\tif (retval)\n\t\t\t\treturn retval;\n\t\t} else {\n\t\t\txfs_attr_leaf_name_remote_t *name_rmt =\n\t\t\t\txfs_attr3_leaf_name_remote(leaf, i);\n\n\t\t\tint valuelen = be32_to_cpu(name_rmt->valuelen);\n\n\t\t\tif (context->put_value) {\n\t\t\t\txfs_da_args_t args;\n\n\t\t\t\tmemset((char *)&args, 0, sizeof(args));\n\t\t\t\targs.geo = context->dp->i_mount->m_attr_geo;\n\t\t\t\targs.dp = context->dp;\n\t\t\t\targs.whichfork = XFS_ATTR_FORK;\n\t\t\t\targs.valuelen = valuelen;\n\t\t\t\targs.rmtvaluelen = valuelen;\n\t\t\t\targs.value = kmem_alloc(valuelen, KM_SLEEP | KM_NOFS);\n\t\t\t\targs.rmtblkno = be32_to_cpu(name_rmt->valueblk);\n\t\t\t\targs.rmtblkcnt = xfs_attr3_rmt_blocks(\n\t\t\t\t\t\t\targs.dp->i_mount, valuelen);\n\t\t\t\tretval = xfs_attr_rmtval_get(&args);\n\t\t\t\tif (retval)\n\t\t\t\t\treturn retval;\n\t\t\t\tretval = context->put_listent(context,\n\t\t\t\t\t\tentry->flags,\n\t\t\t\t\t\tname_rmt->name,\n\t\t\t\t\t\t(int)name_rmt->namelen,\n\t\t\t\t\t\tvaluelen,\n\t\t\t\t\t\targs.value);\n\t\t\t\tkmem_free(args.value);\n\t\t\t} else {\n\t\t\t\tretval = context->put_listent(context,\n\t\t\t\t\t\tentry->flags,\n\t\t\t\t\t\tname_rmt->name,\n\t\t\t\t\t\t(int)name_rmt->namelen,\n\t\t\t\t\t\tvaluelen,\n\t\t\t\t\t\tNULL);\n\t\t\t}\n\t\t\tif (retval)\n\t\t\t\treturn retval;\n\t\t}\n\t\tif (context->seen_enough)\n\t\t\tbreak;\n\t\tcursor->offset++;\n\t}\n\ttrace_xfs_attr_list_leaf_end(context);\n\treturn retval;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "bp != NULL"
          ],
          "line": 329
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_xfs_attr_list_node_descend",
          "args": [
            "context",
            "btree"
          ],
          "line": 317
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "btree->before"
          ],
          "line": 316
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "btree->hashval"
          ],
          "line": 315
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dp->d_ops->node_tree_p",
          "args": [
            "node"
          ],
          "line": 312
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dp->d_ops->node_hdr_from_disk",
          "args": [
            "&nodehdr",
            "node"
          ],
          "line": 311
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_CORRUPTION_ERROR",
          "args": [
            "\"xfs_attr_node_list(3)\"",
            "XFS_ERRLEVEL_LOW",
            "context->dp->i_mount",
            "node"
          ],
          "line": 303
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be16_to_cpu",
          "args": [
            "node->hdr.info.magic"
          ],
          "line": 297
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_da3_node_read",
          "args": [
            "NULL",
            "dp",
            "cursor->blkno",
            "-1",
            "&bp",
            "XFS_ATTR_FORK"
          ],
          "line": 291
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_da3_node_read",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_da_btree.c",
          "lines": "248-286",
          "snippet": "int\nxfs_da3_node_read(\n\tstruct xfs_trans\t*tp,\n\tstruct xfs_inode\t*dp,\n\txfs_dablk_t\t\tbno,\n\txfs_daddr_t\t\tmappedbno,\n\tstruct xfs_buf\t\t**bpp,\n\tint\t\t\twhich_fork)\n{\n\tint\t\t\terr;\n\n\terr = xfs_da_read_buf(tp, dp, bno, mappedbno, bpp,\n\t\t\t\t\twhich_fork, &xfs_da3_node_buf_ops);\n\tif (!err && tp) {\n\t\tstruct xfs_da_blkinfo\t*info = (*bpp)->b_addr;\n\t\tint\t\t\ttype;\n\n\t\tswitch (be16_to_cpu(info->magic)) {\n\t\tcase XFS_DA_NODE_MAGIC:\n\t\tcase XFS_DA3_NODE_MAGIC:\n\t\t\ttype = XFS_BLFT_DA_NODE_BUF;\n\t\t\tbreak;\n\t\tcase XFS_ATTR_LEAF_MAGIC:\n\t\tcase XFS_ATTR3_LEAF_MAGIC:\n\t\t\ttype = XFS_BLFT_ATTR_LEAF_BUF;\n\t\t\tbreak;\n\t\tcase XFS_DIR2_LEAFN_MAGIC:\n\t\tcase XFS_DIR3_LEAFN_MAGIC:\n\t\t\ttype = XFS_BLFT_DIR_LEAFN_BUF;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\ttype = 0;\n\t\t\tASSERT(0);\n\t\t\tbreak;\n\t\t}\n\t\txfs_trans_buf_set_type(tp, *bpp, type);\n\t}\n\treturn err;\n}",
          "includes": [
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_attr_leaf.h\"",
            "#include \"xfs_attr.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_dir2_priv.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "const struct xfs_buf_ops xfs_da3_node_buf_ops = {\n\t.verify_read = xfs_da3_node_read_verify,\n\t.verify_write = xfs_da3_node_write_verify,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_buf_item.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_attr_leaf.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_dir2_priv.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nconst struct xfs_buf_ops xfs_da3_node_buf_ops = {\n\t.verify_read = xfs_da3_node_read_verify,\n\t.verify_write = xfs_da3_node_write_verify,\n};\n\nint\nxfs_da3_node_read(\n\tstruct xfs_trans\t*tp,\n\tstruct xfs_inode\t*dp,\n\txfs_dablk_t\t\tbno,\n\txfs_daddr_t\t\tmappedbno,\n\tstruct xfs_buf\t\t**bpp,\n\tint\t\t\twhich_fork)\n{\n\tint\t\t\terr;\n\n\terr = xfs_da_read_buf(tp, dp, bno, mappedbno, bpp,\n\t\t\t\t\twhich_fork, &xfs_da3_node_buf_ops);\n\tif (!err && tp) {\n\t\tstruct xfs_da_blkinfo\t*info = (*bpp)->b_addr;\n\t\tint\t\t\ttype;\n\n\t\tswitch (be16_to_cpu(info->magic)) {\n\t\tcase XFS_DA_NODE_MAGIC:\n\t\tcase XFS_DA3_NODE_MAGIC:\n\t\t\ttype = XFS_BLFT_DA_NODE_BUF;\n\t\t\tbreak;\n\t\tcase XFS_ATTR_LEAF_MAGIC:\n\t\tcase XFS_ATTR3_LEAF_MAGIC:\n\t\t\ttype = XFS_BLFT_ATTR_LEAF_BUF;\n\t\t\tbreak;\n\t\tcase XFS_DIR2_LEAFN_MAGIC:\n\t\tcase XFS_DIR3_LEAFN_MAGIC:\n\t\t\ttype = XFS_BLFT_DIR_LEAFN_BUF;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\ttype = 0;\n\t\t\tASSERT(0);\n\t\t\tbreak;\n\t\t}\n\t\txfs_trans_buf_set_type(tp, *bpp, type);\n\t}\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_xfs_attr_list_wrong_blk",
          "args": [
            "context"
          ],
          "line": 274
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_xfs_attr_list_wrong_blk",
          "args": [
            "context"
          ],
          "line": 268
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "entries[0].hashval"
          ],
          "line": 266
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_xfs_attr_list_wrong_blk",
          "args": [
            "context"
          ],
          "line": 263
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "entries[leafhdr.count - 1].hashval"
          ],
          "line": 261
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_attr3_leaf_entryp",
          "args": [
            "leaf"
          ],
          "line": 260
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_attr3_leaf_entryp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_da_format.h",
          "lines": "777-783",
          "snippet": "static inline struct xfs_attr_leaf_entry *\nxfs_attr3_leaf_entryp(xfs_attr_leafblock_t *leafp)\n{\n\tif (leafp->hdr.info.magic == cpu_to_be16(XFS_ATTR3_LEAF_MAGIC))\n\t\treturn &((struct xfs_attr3_leafblock *)leafp)->entries[0];\n\treturn &leafp->entries[0];\n}",
          "includes": [],
          "macros_used": [
            "#define XFS_ATTR3_LEAF_MAGIC\t0x3bee\t/* magic number: attribute leaf blks */"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#define XFS_ATTR3_LEAF_MAGIC\t0x3bee\t/* magic number: attribute leaf blks */\n\nstatic inline struct xfs_attr_leaf_entry *\nxfs_attr3_leaf_entryp(xfs_attr_leafblock_t *leafp)\n{\n\tif (leafp->hdr.info.magic == cpu_to_be16(XFS_ATTR3_LEAF_MAGIC))\n\t\treturn &((struct xfs_attr3_leafblock *)leafp)->entries[0];\n\treturn &leafp->entries[0];\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_xfs_attr_list_wrong_blk",
          "args": [
            "context"
          ],
          "line": 252
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be16_to_cpu",
          "args": [
            "node->hdr.info.magic"
          ],
          "line": 249
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_xfs_attr_node_list",
          "args": [
            "context"
          ],
          "line": 229
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_dir2.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_attr_leaf.h\"\n#include \"xfs_attr_remote.h\"\n#include \"xfs_attr_sf.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC int\nxfs_attr_node_list(xfs_attr_list_context_t *context)\n{\n\tattrlist_cursor_kern_t *cursor;\n\txfs_attr_leafblock_t *leaf;\n\txfs_da_intnode_t *node;\n\tstruct xfs_attr3_icleaf_hdr leafhdr;\n\tstruct xfs_da3_icnode_hdr nodehdr;\n\tstruct xfs_da_node_entry *btree;\n\tint error, i;\n\tstruct xfs_buf *bp;\n\tstruct xfs_inode\t*dp = context->dp;\n\n\ttrace_xfs_attr_node_list(context);\n\n\tcursor = context->cursor;\n\tcursor->initted = 1;\n\n\t/*\n\t * Do all sorts of validation on the passed-in cursor structure.\n\t * If anything is amiss, ignore the cursor and look up the hashval\n\t * starting from the btree root.\n\t */\n\tbp = NULL;\n\tif (cursor->blkno > 0) {\n\t\terror = xfs_da3_node_read(NULL, dp, cursor->blkno, -1,\n\t\t\t\t\t      &bp, XFS_ATTR_FORK);\n\t\tif ((error != 0) && (error != -EFSCORRUPTED))\n\t\t\treturn error;\n\t\tif (bp) {\n\t\t\tstruct xfs_attr_leaf_entry *entries;\n\n\t\t\tnode = bp->b_addr;\n\t\t\tswitch (be16_to_cpu(node->hdr.info.magic)) {\n\t\t\tcase XFS_DA_NODE_MAGIC:\n\t\t\tcase XFS_DA3_NODE_MAGIC:\n\t\t\t\ttrace_xfs_attr_list_wrong_blk(context);\n\t\t\t\txfs_trans_brelse(NULL, bp);\n\t\t\t\tbp = NULL;\n\t\t\t\tbreak;\n\t\t\tcase XFS_ATTR_LEAF_MAGIC:\n\t\t\tcase XFS_ATTR3_LEAF_MAGIC:\n\t\t\t\tleaf = bp->b_addr;\n\t\t\t\txfs_attr3_leaf_hdr_from_disk(&leafhdr, leaf);\n\t\t\t\tentries = xfs_attr3_leaf_entryp(leaf);\n\t\t\t\tif (cursor->hashval > be32_to_cpu(\n\t\t\t\t\t\tentries[leafhdr.count - 1].hashval)) {\n\t\t\t\t\ttrace_xfs_attr_list_wrong_blk(context);\n\t\t\t\t\txfs_trans_brelse(NULL, bp);\n\t\t\t\t\tbp = NULL;\n\t\t\t\t} else if (cursor->hashval <= be32_to_cpu(\n\t\t\t\t\t\tentries[0].hashval)) {\n\t\t\t\t\ttrace_xfs_attr_list_wrong_blk(context);\n\t\t\t\t\txfs_trans_brelse(NULL, bp);\n\t\t\t\t\tbp = NULL;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\ttrace_xfs_attr_list_wrong_blk(context);\n\t\t\t\txfs_trans_brelse(NULL, bp);\n\t\t\t\tbp = NULL;\n\t\t\t}\n\t\t}\n\t}\n\n\t/*\n\t * We did not find what we expected given the cursor's contents,\n\t * so we start from the top and work down based on the hash value.\n\t * Note that start of node block is same as start of leaf block.\n\t */\n\tif (bp == NULL) {\n\t\tcursor->blkno = 0;\n\t\tfor (;;) {\n\t\t\t__uint16_t magic;\n\n\t\t\terror = xfs_da3_node_read(NULL, dp,\n\t\t\t\t\t\t      cursor->blkno, -1, &bp,\n\t\t\t\t\t\t      XFS_ATTR_FORK);\n\t\t\tif (error)\n\t\t\t\treturn error;\n\t\t\tnode = bp->b_addr;\n\t\t\tmagic = be16_to_cpu(node->hdr.info.magic);\n\t\t\tif (magic == XFS_ATTR_LEAF_MAGIC ||\n\t\t\t    magic == XFS_ATTR3_LEAF_MAGIC)\n\t\t\t\tbreak;\n\t\t\tif (magic != XFS_DA_NODE_MAGIC &&\n\t\t\t    magic != XFS_DA3_NODE_MAGIC) {\n\t\t\t\tXFS_CORRUPTION_ERROR(\"xfs_attr_node_list(3)\",\n\t\t\t\t\t\t     XFS_ERRLEVEL_LOW,\n\t\t\t\t\t\t     context->dp->i_mount,\n\t\t\t\t\t\t     node);\n\t\t\t\txfs_trans_brelse(NULL, bp);\n\t\t\t\treturn -EFSCORRUPTED;\n\t\t\t}\n\n\t\t\tdp->d_ops->node_hdr_from_disk(&nodehdr, node);\n\t\t\tbtree = dp->d_ops->node_tree_p(node);\n\t\t\tfor (i = 0; i < nodehdr.count; btree++, i++) {\n\t\t\t\tif (cursor->hashval\n\t\t\t\t\t\t<= be32_to_cpu(btree->hashval)) {\n\t\t\t\t\tcursor->blkno = be32_to_cpu(btree->before);\n\t\t\t\t\ttrace_xfs_attr_list_node_descend(context,\n\t\t\t\t\t\t\t\t\t btree);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (i == nodehdr.count) {\n\t\t\t\txfs_trans_brelse(NULL, bp);\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\txfs_trans_brelse(NULL, bp);\n\t\t}\n\t}\n\tASSERT(bp != NULL);\n\n\t/*\n\t * Roll upward through the blocks, processing each leaf block in\n\t * order.  As long as there is space in the result buffer, keep\n\t * adding the information.\n\t */\n\tfor (;;) {\n\t\tleaf = bp->b_addr;\n\t\terror = xfs_attr3_leaf_list_int(bp, context);\n\t\tif (error) {\n\t\t\txfs_trans_brelse(NULL, bp);\n\t\t\treturn error;\n\t\t}\n\t\txfs_attr3_leaf_hdr_from_disk(&leafhdr, leaf);\n\t\tif (context->seen_enough || leafhdr.forw == 0)\n\t\t\tbreak;\n\t\tcursor->blkno = leafhdr.forw;\n\t\txfs_trans_brelse(NULL, bp);\n\t\terror = xfs_attr3_leaf_read(NULL, dp, cursor->blkno, -1, &bp);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\txfs_trans_brelse(NULL, bp);\n\treturn 0;\n}"
  },
  {
    "function_name": "xfs_attr_shortform_list",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_attr_list.c",
    "lines": "68-214",
    "snippet": "int\nxfs_attr_shortform_list(xfs_attr_list_context_t *context)\n{\n\tattrlist_cursor_kern_t *cursor;\n\txfs_attr_sf_sort_t *sbuf, *sbp;\n\txfs_attr_shortform_t *sf;\n\txfs_attr_sf_entry_t *sfe;\n\txfs_inode_t *dp;\n\tint sbsize, nsbuf, count, i;\n\tint error;\n\n\tASSERT(context != NULL);\n\tdp = context->dp;\n\tASSERT(dp != NULL);\n\tASSERT(dp->i_afp != NULL);\n\tsf = (xfs_attr_shortform_t *)dp->i_afp->if_u1.if_data;\n\tASSERT(sf != NULL);\n\tif (!sf->hdr.count)\n\t\treturn 0;\n\tcursor = context->cursor;\n\tASSERT(cursor != NULL);\n\n\ttrace_xfs_attr_list_sf(context);\n\n\t/*\n\t * If the buffer is large enough and the cursor is at the start,\n\t * do not bother with sorting since we will return everything in\n\t * one buffer and another call using the cursor won't need to be\n\t * made.\n\t * Note the generous fudge factor of 16 overhead bytes per entry.\n\t * If bufsize is zero then put_listent must be a search function\n\t * and can just scan through what we have.\n\t */\n\tif (context->bufsize == 0 ||\n\t    (XFS_ISRESET_CURSOR(cursor) &&\n             (dp->i_afp->if_bytes + sf->hdr.count * 16) < context->bufsize)) {\n\t\tfor (i = 0, sfe = &sf->list[0]; i < sf->hdr.count; i++) {\n\t\t\terror = context->put_listent(context,\n\t\t\t\t\t   sfe->flags,\n\t\t\t\t\t   sfe->nameval,\n\t\t\t\t\t   (int)sfe->namelen,\n\t\t\t\t\t   (int)sfe->valuelen,\n\t\t\t\t\t   &sfe->nameval[sfe->namelen]);\n\n\t\t\t/*\n\t\t\t * Either search callback finished early or\n\t\t\t * didn't fit it all in the buffer after all.\n\t\t\t */\n\t\t\tif (context->seen_enough)\n\t\t\t\tbreak;\n\n\t\t\tif (error)\n\t\t\t\treturn error;\n\t\t\tsfe = XFS_ATTR_SF_NEXTENTRY(sfe);\n\t\t}\n\t\ttrace_xfs_attr_list_sf_all(context);\n\t\treturn 0;\n\t}\n\n\t/* do no more for a search callback */\n\tif (context->bufsize == 0)\n\t\treturn 0;\n\n\t/*\n\t * It didn't all fit, so we have to sort everything on hashval.\n\t */\n\tsbsize = sf->hdr.count * sizeof(*sbuf);\n\tsbp = sbuf = kmem_alloc(sbsize, KM_SLEEP | KM_NOFS);\n\n\t/*\n\t * Scan the attribute list for the rest of the entries, storing\n\t * the relevant info from only those that match into a buffer.\n\t */\n\tnsbuf = 0;\n\tfor (i = 0, sfe = &sf->list[0]; i < sf->hdr.count; i++) {\n\t\tif (unlikely(\n\t\t    ((char *)sfe < (char *)sf) ||\n\t\t    ((char *)sfe >= ((char *)sf + dp->i_afp->if_bytes)))) {\n\t\t\tXFS_CORRUPTION_ERROR(\"xfs_attr_shortform_list\",\n\t\t\t\t\t     XFS_ERRLEVEL_LOW,\n\t\t\t\t\t     context->dp->i_mount, sfe);\n\t\t\tkmem_free(sbuf);\n\t\t\treturn -EFSCORRUPTED;\n\t\t}\n\n\t\tsbp->entno = i;\n\t\tsbp->hash = xfs_da_hashname(sfe->nameval, sfe->namelen);\n\t\tsbp->name = sfe->nameval;\n\t\tsbp->namelen = sfe->namelen;\n\t\t/* These are bytes, and both on-disk, don't endian-flip */\n\t\tsbp->valuelen = sfe->valuelen;\n\t\tsbp->flags = sfe->flags;\n\t\tsfe = XFS_ATTR_SF_NEXTENTRY(sfe);\n\t\tsbp++;\n\t\tnsbuf++;\n\t}\n\n\t/*\n\t * Sort the entries on hash then entno.\n\t */\n\txfs_sort(sbuf, nsbuf, sizeof(*sbuf), xfs_attr_shortform_compare);\n\n\t/*\n\t * Re-find our place IN THE SORTED LIST.\n\t */\n\tcount = 0;\n\tcursor->initted = 1;\n\tcursor->blkno = 0;\n\tfor (sbp = sbuf, i = 0; i < nsbuf; i++, sbp++) {\n\t\tif (sbp->hash == cursor->hashval) {\n\t\t\tif (cursor->offset == count) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcount++;\n\t\t} else if (sbp->hash > cursor->hashval) {\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (i == nsbuf) {\n\t\tkmem_free(sbuf);\n\t\treturn 0;\n\t}\n\n\t/*\n\t * Loop putting entries into the user buffer.\n\t */\n\tfor ( ; i < nsbuf; i++, sbp++) {\n\t\tif (cursor->hashval != sbp->hash) {\n\t\t\tcursor->hashval = sbp->hash;\n\t\t\tcursor->offset = 0;\n\t\t}\n\t\terror = context->put_listent(context,\n\t\t\t\t\tsbp->flags,\n\t\t\t\t\tsbp->name,\n\t\t\t\t\tsbp->namelen,\n\t\t\t\t\tsbp->valuelen,\n\t\t\t\t\t&sbp->name[sbp->namelen]);\n\t\tif (error)\n\t\t\treturn error;\n\t\tif (context->seen_enough)\n\t\t\tbreak;\n\t\tcursor->offset++;\n\t}\n\n\tkmem_free(sbuf);\n\treturn 0;\n}",
    "includes": [
      "#include \"xfs_dir2.h\"",
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_buf_item.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_attr_leaf.h\"",
      "#include \"xfs_attr_remote.h\"",
      "#include \"xfs_attr_sf.h\"",
      "#include \"xfs_attr.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_inode_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_da_btree.h\"",
      "#include \"xfs_da_format.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_bit.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kmem_free",
          "args": [
            "sbuf"
          ],
          "line": 212
        },
        "resolved": true,
        "details": {
          "function_name": "kmem_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/kmem.h",
          "lines": "66-69",
          "snippet": "static inline void  kmem_free(const void *ptr)\n{\n\tkvfree(ptr);\n}",
          "includes": [
            "#include <linux/vmalloc.h>",
            "#include <linux/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/vmalloc.h>\n#include <linux/mm.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n\nstatic inline void  kmem_free(const void *ptr)\n{\n\tkvfree(ptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "context->put_listent",
          "args": [
            "context",
            "sbp->flags",
            "sbp->name",
            "sbp->namelen",
            "sbp->valuelen",
            "&sbp->name[sbp->namelen]"
          ],
          "line": 199
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_sort",
          "args": [
            "sbuf",
            "nsbuf",
            "sizeof(*sbuf)",
            "xfs_attr_shortform_compare"
          ],
          "line": 168
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_ATTR_SF_NEXTENTRY",
          "args": [
            "sfe"
          ],
          "line": 160
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_da_hashname",
          "args": [
            "sfe->nameval",
            "sfe->namelen"
          ],
          "line": 154
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_da_hashname",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_da_btree.c",
          "lines": "1944-1970",
          "snippet": "xfs_dahash_t\nxfs_da_hashname(const __uint8_t *name, int namelen)\n{\n\txfs_dahash_t hash;\n\n\t/*\n\t * Do four characters at a time as long as we can.\n\t */\n\tfor (hash = 0; namelen >= 4; namelen -= 4, name += 4)\n\t\thash = (name[0] << 21) ^ (name[1] << 14) ^ (name[2] << 7) ^\n\t\t       (name[3] << 0) ^ rol32(hash, 7 * 4);\n\n\t/*\n\t * Now do the rest of the characters.\n\t */\n\tswitch (namelen) {\n\tcase 3:\n\t\treturn (name[0] << 14) ^ (name[1] << 7) ^ (name[2] << 0) ^\n\t\t       rol32(hash, 7 * 3);\n\tcase 2:\n\t\treturn (name[0] << 7) ^ (name[1] << 0) ^ rol32(hash, 7 * 2);\n\tcase 1:\n\t\treturn (name[0] << 0) ^ rol32(hash, 7 * 1);\n\tdefault: /* case 0: */\n\t\treturn hash;\n\t}\n}",
          "includes": [
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_attr_leaf.h\"",
            "#include \"xfs_attr.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_dir2_priv.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_buf_item.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_attr_leaf.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_dir2_priv.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nxfs_dahash_t\nxfs_da_hashname(const __uint8_t *name, int namelen)\n{\n\txfs_dahash_t hash;\n\n\t/*\n\t * Do four characters at a time as long as we can.\n\t */\n\tfor (hash = 0; namelen >= 4; namelen -= 4, name += 4)\n\t\thash = (name[0] << 21) ^ (name[1] << 14) ^ (name[2] << 7) ^\n\t\t       (name[3] << 0) ^ rol32(hash, 7 * 4);\n\n\t/*\n\t * Now do the rest of the characters.\n\t */\n\tswitch (namelen) {\n\tcase 3:\n\t\treturn (name[0] << 14) ^ (name[1] << 7) ^ (name[2] << 0) ^\n\t\t       rol32(hash, 7 * 3);\n\tcase 2:\n\t\treturn (name[0] << 7) ^ (name[1] << 0) ^ rol32(hash, 7 * 2);\n\tcase 1:\n\t\treturn (name[0] << 0) ^ rol32(hash, 7 * 1);\n\tdefault: /* case 0: */\n\t\treturn hash;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "XFS_CORRUPTION_ERROR",
          "args": [
            "\"xfs_attr_shortform_list\"",
            "XFS_ERRLEVEL_LOW",
            "context->dp->i_mount",
            "sfe"
          ],
          "line": 146
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "((char *)sfe < (char *)sf) ||\n\t\t    ((char *)sfe >= ((char *)sf + dp->i_afp->if_bytes))"
          ],
          "line": 143
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmem_alloc",
          "args": [
            "sbsize",
            "KM_SLEEP | KM_NOFS"
          ],
          "line": 135
        },
        "resolved": true,
        "details": {
          "function_name": "kmem_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/kmem.c",
          "lines": "45-62",
          "snippet": "void *\nkmem_alloc(size_t size, xfs_km_flags_t flags)\n{\n\tint\tretries = 0;\n\tgfp_t\tlflags = kmem_flags_convert(flags);\n\tvoid\t*ptr;\n\n\tdo {\n\t\tptr = kmalloc(size, lflags);\n\t\tif (ptr || (flags & (KM_MAYFAIL|KM_NOSLEEP)))\n\t\t\treturn ptr;\n\t\tif (!(++retries % 100))\n\t\t\txfs_err(NULL,\n\t\t\"possible memory allocation deadlock in %s (mode:0x%x)\",\n\t\t\t\t\t__func__, lflags);\n\t\tcongestion_wait(BLK_RW_ASYNC, HZ/50);\n\t} while (1);\n}",
          "includes": [
            "#include \"xfs_message.h\"",
            "#include \"kmem.h\"",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_message.h\"\n#include \"kmem.h\"\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\nvoid *\nkmem_alloc(size_t size, xfs_km_flags_t flags)\n{\n\tint\tretries = 0;\n\tgfp_t\tlflags = kmem_flags_convert(flags);\n\tvoid\t*ptr;\n\n\tdo {\n\t\tptr = kmalloc(size, lflags);\n\t\tif (ptr || (flags & (KM_MAYFAIL|KM_NOSLEEP)))\n\t\t\treturn ptr;\n\t\tif (!(++retries % 100))\n\t\t\txfs_err(NULL,\n\t\t\"possible memory allocation deadlock in %s (mode:0x%x)\",\n\t\t\t\t\t__func__, lflags);\n\t\tcongestion_wait(BLK_RW_ASYNC, HZ/50);\n\t} while (1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_xfs_attr_list_sf_all",
          "args": [
            "context"
          ],
          "line": 123
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_ATTR_SF_NEXTENTRY",
          "args": [
            "sfe"
          ],
          "line": 121
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "context->put_listent",
          "args": [
            "context",
            "sfe->flags",
            "sfe->nameval",
            "(int)sfe->namelen",
            "(int)sfe->valuelen",
            "&sfe->nameval[sfe->namelen]"
          ],
          "line": 105
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_ISRESET_CURSOR",
          "args": [
            "cursor"
          ],
          "line": 102
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_xfs_attr_list_sf",
          "args": [
            "context"
          ],
          "line": 90
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "cursor != NULL"
          ],
          "line": 88
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "sf != NULL"
          ],
          "line": 84
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "dp->i_afp != NULL"
          ],
          "line": 82
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "dp != NULL"
          ],
          "line": 81
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "context != NULL"
          ],
          "line": 79
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_dir2.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_attr_leaf.h\"\n#include \"xfs_attr_remote.h\"\n#include \"xfs_attr_sf.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\nxfs_attr_shortform_list(xfs_attr_list_context_t *context)\n{\n\tattrlist_cursor_kern_t *cursor;\n\txfs_attr_sf_sort_t *sbuf, *sbp;\n\txfs_attr_shortform_t *sf;\n\txfs_attr_sf_entry_t *sfe;\n\txfs_inode_t *dp;\n\tint sbsize, nsbuf, count, i;\n\tint error;\n\n\tASSERT(context != NULL);\n\tdp = context->dp;\n\tASSERT(dp != NULL);\n\tASSERT(dp->i_afp != NULL);\n\tsf = (xfs_attr_shortform_t *)dp->i_afp->if_u1.if_data;\n\tASSERT(sf != NULL);\n\tif (!sf->hdr.count)\n\t\treturn 0;\n\tcursor = context->cursor;\n\tASSERT(cursor != NULL);\n\n\ttrace_xfs_attr_list_sf(context);\n\n\t/*\n\t * If the buffer is large enough and the cursor is at the start,\n\t * do not bother with sorting since we will return everything in\n\t * one buffer and another call using the cursor won't need to be\n\t * made.\n\t * Note the generous fudge factor of 16 overhead bytes per entry.\n\t * If bufsize is zero then put_listent must be a search function\n\t * and can just scan through what we have.\n\t */\n\tif (context->bufsize == 0 ||\n\t    (XFS_ISRESET_CURSOR(cursor) &&\n             (dp->i_afp->if_bytes + sf->hdr.count * 16) < context->bufsize)) {\n\t\tfor (i = 0, sfe = &sf->list[0]; i < sf->hdr.count; i++) {\n\t\t\terror = context->put_listent(context,\n\t\t\t\t\t   sfe->flags,\n\t\t\t\t\t   sfe->nameval,\n\t\t\t\t\t   (int)sfe->namelen,\n\t\t\t\t\t   (int)sfe->valuelen,\n\t\t\t\t\t   &sfe->nameval[sfe->namelen]);\n\n\t\t\t/*\n\t\t\t * Either search callback finished early or\n\t\t\t * didn't fit it all in the buffer after all.\n\t\t\t */\n\t\t\tif (context->seen_enough)\n\t\t\t\tbreak;\n\n\t\t\tif (error)\n\t\t\t\treturn error;\n\t\t\tsfe = XFS_ATTR_SF_NEXTENTRY(sfe);\n\t\t}\n\t\ttrace_xfs_attr_list_sf_all(context);\n\t\treturn 0;\n\t}\n\n\t/* do no more for a search callback */\n\tif (context->bufsize == 0)\n\t\treturn 0;\n\n\t/*\n\t * It didn't all fit, so we have to sort everything on hashval.\n\t */\n\tsbsize = sf->hdr.count * sizeof(*sbuf);\n\tsbp = sbuf = kmem_alloc(sbsize, KM_SLEEP | KM_NOFS);\n\n\t/*\n\t * Scan the attribute list for the rest of the entries, storing\n\t * the relevant info from only those that match into a buffer.\n\t */\n\tnsbuf = 0;\n\tfor (i = 0, sfe = &sf->list[0]; i < sf->hdr.count; i++) {\n\t\tif (unlikely(\n\t\t    ((char *)sfe < (char *)sf) ||\n\t\t    ((char *)sfe >= ((char *)sf + dp->i_afp->if_bytes)))) {\n\t\t\tXFS_CORRUPTION_ERROR(\"xfs_attr_shortform_list\",\n\t\t\t\t\t     XFS_ERRLEVEL_LOW,\n\t\t\t\t\t     context->dp->i_mount, sfe);\n\t\t\tkmem_free(sbuf);\n\t\t\treturn -EFSCORRUPTED;\n\t\t}\n\n\t\tsbp->entno = i;\n\t\tsbp->hash = xfs_da_hashname(sfe->nameval, sfe->namelen);\n\t\tsbp->name = sfe->nameval;\n\t\tsbp->namelen = sfe->namelen;\n\t\t/* These are bytes, and both on-disk, don't endian-flip */\n\t\tsbp->valuelen = sfe->valuelen;\n\t\tsbp->flags = sfe->flags;\n\t\tsfe = XFS_ATTR_SF_NEXTENTRY(sfe);\n\t\tsbp++;\n\t\tnsbuf++;\n\t}\n\n\t/*\n\t * Sort the entries on hash then entno.\n\t */\n\txfs_sort(sbuf, nsbuf, sizeof(*sbuf), xfs_attr_shortform_compare);\n\n\t/*\n\t * Re-find our place IN THE SORTED LIST.\n\t */\n\tcount = 0;\n\tcursor->initted = 1;\n\tcursor->blkno = 0;\n\tfor (sbp = sbuf, i = 0; i < nsbuf; i++, sbp++) {\n\t\tif (sbp->hash == cursor->hashval) {\n\t\t\tif (cursor->offset == count) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcount++;\n\t\t} else if (sbp->hash > cursor->hashval) {\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (i == nsbuf) {\n\t\tkmem_free(sbuf);\n\t\treturn 0;\n\t}\n\n\t/*\n\t * Loop putting entries into the user buffer.\n\t */\n\tfor ( ; i < nsbuf; i++, sbp++) {\n\t\tif (cursor->hashval != sbp->hash) {\n\t\t\tcursor->hashval = sbp->hash;\n\t\t\tcursor->offset = 0;\n\t\t}\n\t\terror = context->put_listent(context,\n\t\t\t\t\tsbp->flags,\n\t\t\t\t\tsbp->name,\n\t\t\t\t\tsbp->namelen,\n\t\t\t\t\tsbp->valuelen,\n\t\t\t\t\t&sbp->name[sbp->namelen]);\n\t\tif (error)\n\t\t\treturn error;\n\t\tif (context->seen_enough)\n\t\t\tbreak;\n\t\tcursor->offset++;\n\t}\n\n\tkmem_free(sbuf);\n\treturn 0;\n}"
  },
  {
    "function_name": "xfs_attr_shortform_compare",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_attr_list.c",
    "lines": "42-56",
    "snippet": "STATIC int\nxfs_attr_shortform_compare(const void *a, const void *b)\n{\n\txfs_attr_sf_sort_t *sa, *sb;\n\n\tsa = (xfs_attr_sf_sort_t *)a;\n\tsb = (xfs_attr_sf_sort_t *)b;\n\tif (sa->hash < sb->hash) {\n\t\treturn -1;\n\t} else if (sa->hash > sb->hash) {\n\t\treturn 1;\n\t} else {\n\t\treturn sa->entno - sb->entno;\n\t}\n}",
    "includes": [
      "#include \"xfs_dir2.h\"",
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_buf_item.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_attr_leaf.h\"",
      "#include \"xfs_attr_remote.h\"",
      "#include \"xfs_attr_sf.h\"",
      "#include \"xfs_attr.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_inode_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_da_btree.h\"",
      "#include \"xfs_da_format.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_bit.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"xfs_dir2.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_attr_leaf.h\"\n#include \"xfs_attr_remote.h\"\n#include \"xfs_attr_sf.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC int\nxfs_attr_shortform_compare(const void *a, const void *b)\n{\n\txfs_attr_sf_sort_t *sa, *sb;\n\n\tsa = (xfs_attr_sf_sort_t *)a;\n\tsb = (xfs_attr_sf_sort_t *)b;\n\tif (sa->hash < sb->hash) {\n\t\treturn -1;\n\t} else if (sa->hash > sb->hash) {\n\t\treturn 1;\n\t} else {\n\t\treturn sa->entno - sb->entno;\n\t}\n}"
  }
]