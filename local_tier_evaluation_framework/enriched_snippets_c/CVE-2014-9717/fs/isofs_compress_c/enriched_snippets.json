[
  {
    "function_name": "zisofs_cleanup",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/isofs/compress.c",
    "lines": "377-380",
    "snippet": "void zisofs_cleanup(void)\n{\n\tvfree(zisofs_zlib_workspace);\n}",
    "includes": [
      "#include \"zisofs.h\"",
      "#include \"isofs.h\"",
      "#include <linux/zlib.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void *zisofs_zlib_workspace;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "vfree",
          "args": [
            "zisofs_zlib_workspace"
          ],
          "line": 379
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"zisofs.h\"\n#include \"isofs.h\"\n#include <linux/zlib.h>\n#include <linux/vmalloc.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstatic void *zisofs_zlib_workspace;\n\nvoid zisofs_cleanup(void)\n{\n\tvfree(zisofs_zlib_workspace);\n}"
  },
  {
    "function_name": "zisofs_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/isofs/compress.c",
    "lines": "368-375",
    "snippet": "int __init zisofs_init(void)\n{\n\tzisofs_zlib_workspace = vmalloc(zlib_inflate_workspacesize());\n\tif ( !zisofs_zlib_workspace )\n\t\treturn -ENOMEM;\n\n\treturn 0;\n}",
    "includes": [
      "#include \"zisofs.h\"",
      "#include \"isofs.h\"",
      "#include <linux/zlib.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void *zisofs_zlib_workspace;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "vmalloc",
          "args": [
            "zlib_inflate_workspacesize()"
          ],
          "line": 370
        },
        "resolved": true,
        "details": {
          "function_name": "ffs2_blocks_use_vmalloc(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jffs2/nodelist.h",
          "lines": "292-295",
          "snippet": "tatic inline int jffs2_blocks_use_vmalloc(struct jffs2_sb_info *c)\n{\n\treturn ((c->flash_size / c->sector_size) * sizeof (struct jffs2_eraseblock)) > (128 * 1024);\n}",
          "includes": [
            "include \"debug.h\"",
            "include \"os-linux.h\"\n#",
            "include \"os-ecos.h\"\n#",
            "include \"summary.h\"",
            "include \"acl.h\"\n#",
            "include \"xattr.h\"\n#",
            "include \"jffs2_fs_i.h\"\n#",
            "include \"jffs2_fs_sb.h\"\n#",
            "include <linux/jffs2.h>\n#",
            "include <linux/types.h>\n#",
            "include <linux/fs.h>\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"debug.h\"\ninclude \"os-linux.h\"\n#\ninclude \"os-ecos.h\"\n#\ninclude \"summary.h\"\ninclude \"acl.h\"\n#\ninclude \"xattr.h\"\n#\ninclude \"jffs2_fs_i.h\"\n#\ninclude \"jffs2_fs_sb.h\"\n#\ninclude <linux/jffs2.h>\n#\ninclude <linux/types.h>\n#\ninclude <linux/fs.h>\n#\n\ntatic inline int jffs2_blocks_use_vmalloc(struct jffs2_sb_info *c)\n{\n\treturn ((c->flash_size / c->sector_size) * sizeof (struct jffs2_eraseblock)) > (128 * 1024);\n}"
        }
      },
      {
        "call_info": {
          "callee": "zlib_inflate_workspacesize",
          "args": [],
          "line": 370
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"zisofs.h\"\n#include \"isofs.h\"\n#include <linux/zlib.h>\n#include <linux/vmalloc.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstatic void *zisofs_zlib_workspace;\n\nint __init zisofs_init(void)\n{\n\tzisofs_zlib_workspace = vmalloc(zlib_inflate_workspacesize());\n\tif ( !zisofs_zlib_workspace )\n\t\treturn -ENOMEM;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "zisofs_readpage",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/isofs/compress.c",
    "lines": "297-360",
    "snippet": "static int zisofs_readpage(struct file *file, struct page *page)\n{\n\tstruct inode *inode = file_inode(file);\n\tstruct address_space *mapping = inode->i_mapping;\n\tint err;\n\tint i, pcount, full_page;\n\tunsigned int zisofs_block_shift = ISOFS_I(inode)->i_format_parm[1];\n\tunsigned int zisofs_pages_per_cblock =\n\t\tPAGE_CACHE_SHIFT <= zisofs_block_shift ?\n\t\t(1 << (zisofs_block_shift - PAGE_CACHE_SHIFT)) : 0;\n\tstruct page *pages[max_t(unsigned, zisofs_pages_per_cblock, 1)];\n\tpgoff_t index = page->index, end_index;\n\n\tend_index = (inode->i_size + PAGE_CACHE_SIZE - 1) >> PAGE_CACHE_SHIFT;\n\t/*\n\t * If this page is wholly outside i_size we just return zero;\n\t * do_generic_file_read() will handle this for us\n\t */\n\tif (index >= end_index) {\n\t\tSetPageUptodate(page);\n\t\tunlock_page(page);\n\t\treturn 0;\n\t}\n\n\tif (PAGE_CACHE_SHIFT <= zisofs_block_shift) {\n\t\t/* We have already been given one page, this is the one\n\t\t   we must do. */\n\t\tfull_page = index & (zisofs_pages_per_cblock - 1);\n\t\tpcount = min_t(int, zisofs_pages_per_cblock,\n\t\t\tend_index - (index & ~(zisofs_pages_per_cblock - 1)));\n\t\tindex -= full_page;\n\t} else {\n\t\tfull_page = 0;\n\t\tpcount = 1;\n\t}\n\tpages[full_page] = page;\n\n\tfor (i = 0; i < pcount; i++, index++) {\n\t\tif (i != full_page)\n\t\t\tpages[i] = grab_cache_page_nowait(mapping, index);\n\t\tif (pages[i]) {\n\t\t\tClearPageError(pages[i]);\n\t\t\tkmap(pages[i]);\n\t\t}\n\t}\n\n\terr = zisofs_fill_pages(inode, full_page, pcount, pages);\n\n\t/* Release any residual pages, do not SetPageUptodate */\n\tfor (i = 0; i < pcount; i++) {\n\t\tif (pages[i]) {\n\t\t\tflush_dcache_page(pages[i]);\n\t\t\tif (i == full_page && err)\n\t\t\t\tSetPageError(pages[i]);\n\t\t\tkunmap(pages[i]);\n\t\t\tunlock_page(pages[i]);\n\t\t\tif (i != full_page)\n\t\t\t\tpage_cache_release(pages[i]);\n\t\t}\n\t}\t\t\t\n\n\t/* At this point, err contains 0 or -EIO depending on the \"critical\" page */\n\treturn err;\n}",
    "includes": [
      "#include \"zisofs.h\"",
      "#include \"isofs.h\"",
      "#include <linux/zlib.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "page_cache_release",
          "args": [
            "pages[i]"
          ],
          "line": 354
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlock_page",
          "args": [
            "pages[i]"
          ],
          "line": 352
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_unlock_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/aops.c",
          "lines": "1127-1148",
          "snippet": "static void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tpage_cache_release(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}",
          "includes": [
            "#include \"sysfile.h\"",
            "#include \"namei.h\"",
            "#include \"dir.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"symlink.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/swap.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfile.h\"\n#include \"namei.h\"\n#include \"dir.h\"\n#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"symlink.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/mpage.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/swap.h>\n#include <asm/byteorder.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tpage_cache_release(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kunmap",
          "args": [
            "pages[i]"
          ],
          "line": 351
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SetPageError",
          "args": [
            "pages[i]"
          ],
          "line": 350
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "flush_dcache_page",
          "args": [
            "pages[i]"
          ],
          "line": 348
        },
        "resolved": true,
        "details": {
          "function_name": "ntfs_index_entry_flush_dcache_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/index.h",
          "lines": "111-117",
          "snippet": "static inline void ntfs_index_entry_flush_dcache_page(ntfs_index_context *ictx)\n{\n\tif (ictx->is_in_root)\n\t\tflush_dcache_mft_record_page(ictx->actx->ntfs_ino);\n\telse\n\t\tflush_dcache_page(ictx->page);\n}",
          "includes": [
            "#include \"aops.h\"",
            "#include \"mft.h\"",
            "#include \"attrib.h\"",
            "#include \"inode.h\"",
            "#include \"layout.h\"",
            "#include \"types.h\"",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"aops.h\"\n#include \"mft.h\"\n#include \"attrib.h\"\n#include \"inode.h\"\n#include \"layout.h\"\n#include \"types.h\"\n#include <linux/fs.h>\n\nstatic inline void ntfs_index_entry_flush_dcache_page(ntfs_index_context *ictx)\n{\n\tif (ictx->is_in_root)\n\t\tflush_dcache_mft_record_page(ictx->actx->ntfs_ino);\n\telse\n\t\tflush_dcache_page(ictx->page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "zisofs_fill_pages",
          "args": [
            "inode",
            "full_page",
            "pcount",
            "pages"
          ],
          "line": 343
        },
        "resolved": true,
        "details": {
          "function_name": "zisofs_fill_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/isofs/compress.c",
          "lines": "199-290",
          "snippet": "static int zisofs_fill_pages(struct inode *inode, int full_page, int pcount,\n\t\t\t     struct page **pages)\n{\n\tloff_t start_off, end_off;\n\tloff_t block_start, block_end;\n\tunsigned int header_size = ISOFS_I(inode)->i_format_parm[0];\n\tunsigned int zisofs_block_shift = ISOFS_I(inode)->i_format_parm[1];\n\tunsigned int blockptr;\n\tloff_t poffset = 0;\n\tblkcnt_t cstart_block, cend_block;\n\tstruct buffer_head *bh;\n\tunsigned int blkbits = ISOFS_BUFFER_BITS(inode);\n\tunsigned int blksize = 1 << blkbits;\n\tint err;\n\tloff_t ret;\n\n\tBUG_ON(!pages[full_page]);\n\n\t/*\n\t * We want to read at least 'full_page' page. Because we have to\n\t * uncompress the whole compression block anyway, fill the surrounding\n\t * pages with the data we have anyway...\n\t */\n\tstart_off = page_offset(pages[full_page]);\n\tend_off = min_t(loff_t, start_off + PAGE_CACHE_SIZE, inode->i_size);\n\n\tcstart_block = start_off >> zisofs_block_shift;\n\tcend_block = (end_off + (1 << zisofs_block_shift) - 1)\n\t\t\t>> zisofs_block_shift;\n\n\tWARN_ON(start_off - (full_page << PAGE_CACHE_SHIFT) !=\n\t\t((cstart_block << zisofs_block_shift) & PAGE_CACHE_MASK));\n\n\t/* Find the pointer to this specific chunk */\n\t/* Note: we're not using isonum_731() here because the data is known aligned */\n\t/* Note: header_size is in 32-bit words (4 bytes) */\n\tblockptr = (header_size + cstart_block) << 2;\n\tbh = isofs_bread(inode, blockptr >> blkbits);\n\tif (!bh)\n\t\treturn -EIO;\n\tblock_start = le32_to_cpu(*(__le32 *)\n\t\t\t\t(bh->b_data + (blockptr & (blksize - 1))));\n\n\twhile (cstart_block < cend_block && pcount > 0) {\n\t\t/* Load end of the compressed block in the file */\n\t\tblockptr += 4;\n\t\t/* Traversed to next block? */\n\t\tif (!(blockptr & (blksize - 1))) {\n\t\t\tbrelse(bh);\n\n\t\t\tbh = isofs_bread(inode, blockptr >> blkbits);\n\t\t\tif (!bh)\n\t\t\t\treturn -EIO;\n\t\t}\n\t\tblock_end = le32_to_cpu(*(__le32 *)\n\t\t\t\t(bh->b_data + (blockptr & (blksize - 1))));\n\t\tif (block_start > block_end) {\n\t\t\tbrelse(bh);\n\t\t\treturn -EIO;\n\t\t}\n\t\terr = 0;\n\t\tret = zisofs_uncompress_block(inode, block_start, block_end,\n\t\t\t\t\t      pcount, pages, poffset, &err);\n\t\tpoffset += ret;\n\t\tpages += poffset >> PAGE_CACHE_SHIFT;\n\t\tpcount -= poffset >> PAGE_CACHE_SHIFT;\n\t\tfull_page -= poffset >> PAGE_CACHE_SHIFT;\n\t\tpoffset &= ~PAGE_CACHE_MASK;\n\n\t\tif (err) {\n\t\t\tbrelse(bh);\n\t\t\t/*\n\t\t\t * Did we finish reading the page we really wanted\n\t\t\t * to read?\n\t\t\t */\n\t\t\tif (full_page < 0)\n\t\t\t\treturn 0;\n\t\t\treturn err;\n\t\t}\n\n\t\tblock_start = block_end;\n\t\tcstart_block++;\n\t}\n\n\tif (poffset && *pages) {\n\t\tmemset(page_address(*pages) + poffset, 0,\n\t\t       PAGE_CACHE_SIZE - poffset);\n\t\tflush_dcache_page(*pages);\n\t\tSetPageUptodate(*pages);\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"zisofs.h\"",
            "#include \"isofs.h\"",
            "#include <linux/zlib.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"zisofs.h\"\n#include \"isofs.h\"\n#include <linux/zlib.h>\n#include <linux/vmalloc.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstatic int zisofs_fill_pages(struct inode *inode, int full_page, int pcount,\n\t\t\t     struct page **pages)\n{\n\tloff_t start_off, end_off;\n\tloff_t block_start, block_end;\n\tunsigned int header_size = ISOFS_I(inode)->i_format_parm[0];\n\tunsigned int zisofs_block_shift = ISOFS_I(inode)->i_format_parm[1];\n\tunsigned int blockptr;\n\tloff_t poffset = 0;\n\tblkcnt_t cstart_block, cend_block;\n\tstruct buffer_head *bh;\n\tunsigned int blkbits = ISOFS_BUFFER_BITS(inode);\n\tunsigned int blksize = 1 << blkbits;\n\tint err;\n\tloff_t ret;\n\n\tBUG_ON(!pages[full_page]);\n\n\t/*\n\t * We want to read at least 'full_page' page. Because we have to\n\t * uncompress the whole compression block anyway, fill the surrounding\n\t * pages with the data we have anyway...\n\t */\n\tstart_off = page_offset(pages[full_page]);\n\tend_off = min_t(loff_t, start_off + PAGE_CACHE_SIZE, inode->i_size);\n\n\tcstart_block = start_off >> zisofs_block_shift;\n\tcend_block = (end_off + (1 << zisofs_block_shift) - 1)\n\t\t\t>> zisofs_block_shift;\n\n\tWARN_ON(start_off - (full_page << PAGE_CACHE_SHIFT) !=\n\t\t((cstart_block << zisofs_block_shift) & PAGE_CACHE_MASK));\n\n\t/* Find the pointer to this specific chunk */\n\t/* Note: we're not using isonum_731() here because the data is known aligned */\n\t/* Note: header_size is in 32-bit words (4 bytes) */\n\tblockptr = (header_size + cstart_block) << 2;\n\tbh = isofs_bread(inode, blockptr >> blkbits);\n\tif (!bh)\n\t\treturn -EIO;\n\tblock_start = le32_to_cpu(*(__le32 *)\n\t\t\t\t(bh->b_data + (blockptr & (blksize - 1))));\n\n\twhile (cstart_block < cend_block && pcount > 0) {\n\t\t/* Load end of the compressed block in the file */\n\t\tblockptr += 4;\n\t\t/* Traversed to next block? */\n\t\tif (!(blockptr & (blksize - 1))) {\n\t\t\tbrelse(bh);\n\n\t\t\tbh = isofs_bread(inode, blockptr >> blkbits);\n\t\t\tif (!bh)\n\t\t\t\treturn -EIO;\n\t\t}\n\t\tblock_end = le32_to_cpu(*(__le32 *)\n\t\t\t\t(bh->b_data + (blockptr & (blksize - 1))));\n\t\tif (block_start > block_end) {\n\t\t\tbrelse(bh);\n\t\t\treturn -EIO;\n\t\t}\n\t\terr = 0;\n\t\tret = zisofs_uncompress_block(inode, block_start, block_end,\n\t\t\t\t\t      pcount, pages, poffset, &err);\n\t\tpoffset += ret;\n\t\tpages += poffset >> PAGE_CACHE_SHIFT;\n\t\tpcount -= poffset >> PAGE_CACHE_SHIFT;\n\t\tfull_page -= poffset >> PAGE_CACHE_SHIFT;\n\t\tpoffset &= ~PAGE_CACHE_MASK;\n\n\t\tif (err) {\n\t\t\tbrelse(bh);\n\t\t\t/*\n\t\t\t * Did we finish reading the page we really wanted\n\t\t\t * to read?\n\t\t\t */\n\t\t\tif (full_page < 0)\n\t\t\t\treturn 0;\n\t\t\treturn err;\n\t\t}\n\n\t\tblock_start = block_end;\n\t\tcstart_block++;\n\t}\n\n\tif (poffset && *pages) {\n\t\tmemset(page_address(*pages) + poffset, 0,\n\t\t       PAGE_CACHE_SIZE - poffset);\n\t\tflush_dcache_page(*pages);\n\t\tSetPageUptodate(*pages);\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kmap",
          "args": [
            "pages[i]"
          ],
          "line": 339
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ClearPageError",
          "args": [
            "pages[i]"
          ],
          "line": 338
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "grab_cache_page_nowait",
          "args": [
            "mapping",
            "index"
          ],
          "line": 336
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "min_t",
          "args": [
            "int",
            "zisofs_pages_per_cblock",
            "end_index - (index & ~(zisofs_pages_per_cblock - 1))"
          ],
          "line": 325
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SetPageUptodate",
          "args": [
            "page"
          ],
          "line": 316
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "max_t",
          "args": [
            "unsigned",
            "zisofs_pages_per_cblock",
            "1"
          ],
          "line": 307
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ISOFS_I",
          "args": [
            "inode"
          ],
          "line": 303
        },
        "resolved": true,
        "details": {
          "function_name": "ISOFS_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/isofs/isofs.h",
          "lines": "67-70",
          "snippet": "static inline struct iso_inode_info *ISOFS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct iso_inode_info, vfs_inode);\n}",
          "includes": [
            "#include <asm/unaligned.h>",
            "#include <linux/iso_fs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern int get_rock_ridge_filename(struct iso_directory_record *, char *, struct inode *);",
            "extern int isofs_name_translate(struct iso_directory_record *, char *, struct inode *);",
            "int get_joliet_filename(struct iso_directory_record *, unsigned char *, struct inode *);",
            "int get_acorn_filename(struct iso_directory_record *, char *, struct inode *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/unaligned.h>\n#include <linux/iso_fs.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n\nextern int get_rock_ridge_filename(struct iso_directory_record *, char *, struct inode *);\nextern int isofs_name_translate(struct iso_directory_record *, char *, struct inode *);\nint get_joliet_filename(struct iso_directory_record *, unsigned char *, struct inode *);\nint get_acorn_filename(struct iso_directory_record *, char *, struct inode *);\n\nstatic inline struct iso_inode_info *ISOFS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct iso_inode_info, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "file_inode",
          "args": [
            "file"
          ],
          "line": 299
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_init_file_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/file.c",
          "lines": "3009-3013",
          "snippet": "void fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}",
          "includes": [
            "#include <linux/falloc.h>",
            "#include <linux/aio.h>",
            "#include <linux/swap.h>",
            "#include <linux/compat.h>",
            "#include <linux/module.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};",
            "static const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/compat.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};\nstatic const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};\n\nvoid fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"zisofs.h\"\n#include \"isofs.h\"\n#include <linux/zlib.h>\n#include <linux/vmalloc.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstatic int zisofs_readpage(struct file *file, struct page *page)\n{\n\tstruct inode *inode = file_inode(file);\n\tstruct address_space *mapping = inode->i_mapping;\n\tint err;\n\tint i, pcount, full_page;\n\tunsigned int zisofs_block_shift = ISOFS_I(inode)->i_format_parm[1];\n\tunsigned int zisofs_pages_per_cblock =\n\t\tPAGE_CACHE_SHIFT <= zisofs_block_shift ?\n\t\t(1 << (zisofs_block_shift - PAGE_CACHE_SHIFT)) : 0;\n\tstruct page *pages[max_t(unsigned, zisofs_pages_per_cblock, 1)];\n\tpgoff_t index = page->index, end_index;\n\n\tend_index = (inode->i_size + PAGE_CACHE_SIZE - 1) >> PAGE_CACHE_SHIFT;\n\t/*\n\t * If this page is wholly outside i_size we just return zero;\n\t * do_generic_file_read() will handle this for us\n\t */\n\tif (index >= end_index) {\n\t\tSetPageUptodate(page);\n\t\tunlock_page(page);\n\t\treturn 0;\n\t}\n\n\tif (PAGE_CACHE_SHIFT <= zisofs_block_shift) {\n\t\t/* We have already been given one page, this is the one\n\t\t   we must do. */\n\t\tfull_page = index & (zisofs_pages_per_cblock - 1);\n\t\tpcount = min_t(int, zisofs_pages_per_cblock,\n\t\t\tend_index - (index & ~(zisofs_pages_per_cblock - 1)));\n\t\tindex -= full_page;\n\t} else {\n\t\tfull_page = 0;\n\t\tpcount = 1;\n\t}\n\tpages[full_page] = page;\n\n\tfor (i = 0; i < pcount; i++, index++) {\n\t\tif (i != full_page)\n\t\t\tpages[i] = grab_cache_page_nowait(mapping, index);\n\t\tif (pages[i]) {\n\t\t\tClearPageError(pages[i]);\n\t\t\tkmap(pages[i]);\n\t\t}\n\t}\n\n\terr = zisofs_fill_pages(inode, full_page, pcount, pages);\n\n\t/* Release any residual pages, do not SetPageUptodate */\n\tfor (i = 0; i < pcount; i++) {\n\t\tif (pages[i]) {\n\t\t\tflush_dcache_page(pages[i]);\n\t\t\tif (i == full_page && err)\n\t\t\t\tSetPageError(pages[i]);\n\t\t\tkunmap(pages[i]);\n\t\t\tunlock_page(pages[i]);\n\t\t\tif (i != full_page)\n\t\t\t\tpage_cache_release(pages[i]);\n\t\t}\n\t}\t\t\t\n\n\t/* At this point, err contains 0 or -EIO depending on the \"critical\" page */\n\treturn err;\n}"
  },
  {
    "function_name": "zisofs_fill_pages",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/isofs/compress.c",
    "lines": "199-290",
    "snippet": "static int zisofs_fill_pages(struct inode *inode, int full_page, int pcount,\n\t\t\t     struct page **pages)\n{\n\tloff_t start_off, end_off;\n\tloff_t block_start, block_end;\n\tunsigned int header_size = ISOFS_I(inode)->i_format_parm[0];\n\tunsigned int zisofs_block_shift = ISOFS_I(inode)->i_format_parm[1];\n\tunsigned int blockptr;\n\tloff_t poffset = 0;\n\tblkcnt_t cstart_block, cend_block;\n\tstruct buffer_head *bh;\n\tunsigned int blkbits = ISOFS_BUFFER_BITS(inode);\n\tunsigned int blksize = 1 << blkbits;\n\tint err;\n\tloff_t ret;\n\n\tBUG_ON(!pages[full_page]);\n\n\t/*\n\t * We want to read at least 'full_page' page. Because we have to\n\t * uncompress the whole compression block anyway, fill the surrounding\n\t * pages with the data we have anyway...\n\t */\n\tstart_off = page_offset(pages[full_page]);\n\tend_off = min_t(loff_t, start_off + PAGE_CACHE_SIZE, inode->i_size);\n\n\tcstart_block = start_off >> zisofs_block_shift;\n\tcend_block = (end_off + (1 << zisofs_block_shift) - 1)\n\t\t\t>> zisofs_block_shift;\n\n\tWARN_ON(start_off - (full_page << PAGE_CACHE_SHIFT) !=\n\t\t((cstart_block << zisofs_block_shift) & PAGE_CACHE_MASK));\n\n\t/* Find the pointer to this specific chunk */\n\t/* Note: we're not using isonum_731() here because the data is known aligned */\n\t/* Note: header_size is in 32-bit words (4 bytes) */\n\tblockptr = (header_size + cstart_block) << 2;\n\tbh = isofs_bread(inode, blockptr >> blkbits);\n\tif (!bh)\n\t\treturn -EIO;\n\tblock_start = le32_to_cpu(*(__le32 *)\n\t\t\t\t(bh->b_data + (blockptr & (blksize - 1))));\n\n\twhile (cstart_block < cend_block && pcount > 0) {\n\t\t/* Load end of the compressed block in the file */\n\t\tblockptr += 4;\n\t\t/* Traversed to next block? */\n\t\tif (!(blockptr & (blksize - 1))) {\n\t\t\tbrelse(bh);\n\n\t\t\tbh = isofs_bread(inode, blockptr >> blkbits);\n\t\t\tif (!bh)\n\t\t\t\treturn -EIO;\n\t\t}\n\t\tblock_end = le32_to_cpu(*(__le32 *)\n\t\t\t\t(bh->b_data + (blockptr & (blksize - 1))));\n\t\tif (block_start > block_end) {\n\t\t\tbrelse(bh);\n\t\t\treturn -EIO;\n\t\t}\n\t\terr = 0;\n\t\tret = zisofs_uncompress_block(inode, block_start, block_end,\n\t\t\t\t\t      pcount, pages, poffset, &err);\n\t\tpoffset += ret;\n\t\tpages += poffset >> PAGE_CACHE_SHIFT;\n\t\tpcount -= poffset >> PAGE_CACHE_SHIFT;\n\t\tfull_page -= poffset >> PAGE_CACHE_SHIFT;\n\t\tpoffset &= ~PAGE_CACHE_MASK;\n\n\t\tif (err) {\n\t\t\tbrelse(bh);\n\t\t\t/*\n\t\t\t * Did we finish reading the page we really wanted\n\t\t\t * to read?\n\t\t\t */\n\t\t\tif (full_page < 0)\n\t\t\t\treturn 0;\n\t\t\treturn err;\n\t\t}\n\n\t\tblock_start = block_end;\n\t\tcstart_block++;\n\t}\n\n\tif (poffset && *pages) {\n\t\tmemset(page_address(*pages) + poffset, 0,\n\t\t       PAGE_CACHE_SIZE - poffset);\n\t\tflush_dcache_page(*pages);\n\t\tSetPageUptodate(*pages);\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include \"zisofs.h\"",
      "#include \"isofs.h\"",
      "#include <linux/zlib.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "SetPageUptodate",
          "args": [
            "*pages"
          ],
          "line": 287
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "flush_dcache_page",
          "args": [
            "*pages"
          ],
          "line": 286
        },
        "resolved": true,
        "details": {
          "function_name": "ntfs_index_entry_flush_dcache_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/index.h",
          "lines": "111-117",
          "snippet": "static inline void ntfs_index_entry_flush_dcache_page(ntfs_index_context *ictx)\n{\n\tif (ictx->is_in_root)\n\t\tflush_dcache_mft_record_page(ictx->actx->ntfs_ino);\n\telse\n\t\tflush_dcache_page(ictx->page);\n}",
          "includes": [
            "#include \"aops.h\"",
            "#include \"mft.h\"",
            "#include \"attrib.h\"",
            "#include \"inode.h\"",
            "#include \"layout.h\"",
            "#include \"types.h\"",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"aops.h\"\n#include \"mft.h\"\n#include \"attrib.h\"\n#include \"inode.h\"\n#include \"layout.h\"\n#include \"types.h\"\n#include <linux/fs.h>\n\nstatic inline void ntfs_index_entry_flush_dcache_page(ntfs_index_context *ictx)\n{\n\tif (ictx->is_in_root)\n\t\tflush_dcache_mft_record_page(ictx->actx->ntfs_ino);\n\telse\n\t\tflush_dcache_page(ictx->page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "page_address(*pages) + poffset",
            "0",
            "PAGE_CACHE_SIZE - poffset"
          ],
          "line": 284
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_address",
          "args": [
            "*pages"
          ],
          "line": 284
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "bh"
          ],
          "line": 269
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "zisofs_uncompress_block",
          "args": [
            "inode",
            "block_start",
            "block_end",
            "pcount",
            "pages",
            "poffset",
            "&err"
          ],
          "line": 260
        },
        "resolved": true,
        "details": {
          "function_name": "zisofs_uncompress_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/isofs/compress.c",
          "lines": "43-193",
          "snippet": "static loff_t zisofs_uncompress_block(struct inode *inode, loff_t block_start,\n\t\t\t\t      loff_t block_end, int pcount,\n\t\t\t\t      struct page **pages, unsigned poffset,\n\t\t\t\t      int *errp)\n{\n\tunsigned int zisofs_block_shift = ISOFS_I(inode)->i_format_parm[1];\n\tunsigned int bufsize = ISOFS_BUFFER_SIZE(inode);\n\tunsigned int bufshift = ISOFS_BUFFER_BITS(inode);\n\tunsigned int bufmask = bufsize - 1;\n\tint i, block_size = block_end - block_start;\n\tz_stream stream = { .total_out = 0,\n\t\t\t    .avail_in = 0,\n\t\t\t    .avail_out = 0, };\n\tint zerr;\n\tint needblocks = (block_size + (block_start & bufmask) + bufmask)\n\t\t\t\t>> bufshift;\n\tint haveblocks;\n\tblkcnt_t blocknum;\n\tstruct buffer_head *bhs[needblocks + 1];\n\tint curbh, curpage;\n\n\tif (block_size > deflateBound(1UL << zisofs_block_shift)) {\n\t\t*errp = -EIO;\n\t\treturn 0;\n\t}\n\t/* Empty block? */\n\tif (block_size == 0) {\n\t\tfor ( i = 0 ; i < pcount ; i++ ) {\n\t\t\tif (!pages[i])\n\t\t\t\tcontinue;\n\t\t\tmemset(page_address(pages[i]), 0, PAGE_CACHE_SIZE);\n\t\t\tflush_dcache_page(pages[i]);\n\t\t\tSetPageUptodate(pages[i]);\n\t\t}\n\t\treturn ((loff_t)pcount) << PAGE_CACHE_SHIFT;\n\t}\n\n\t/* Because zlib is not thread-safe, do all the I/O at the top. */\n\tblocknum = block_start >> bufshift;\n\tmemset(bhs, 0, (needblocks + 1) * sizeof(struct buffer_head *));\n\thaveblocks = isofs_get_blocks(inode, blocknum, bhs, needblocks);\n\tll_rw_block(READ, haveblocks, bhs);\n\n\tcurbh = 0;\n\tcurpage = 0;\n\t/*\n\t * First block is special since it may be fractional.  We also wait for\n\t * it before grabbing the zlib mutex; odds are that the subsequent\n\t * blocks are going to come in in short order so we don't hold the zlib\n\t * mutex longer than necessary.\n\t */\n\n\tif (!bhs[0])\n\t\tgoto b_eio;\n\n\twait_on_buffer(bhs[0]);\n\tif (!buffer_uptodate(bhs[0])) {\n\t\t*errp = -EIO;\n\t\tgoto b_eio;\n\t}\n\n\tstream.workspace = zisofs_zlib_workspace;\n\tmutex_lock(&zisofs_zlib_lock);\n\t\t\n\tzerr = zlib_inflateInit(&stream);\n\tif (zerr != Z_OK) {\n\t\tif (zerr == Z_MEM_ERROR)\n\t\t\t*errp = -ENOMEM;\n\t\telse\n\t\t\t*errp = -EIO;\n\t\tprintk(KERN_DEBUG \"zisofs: zisofs_inflateInit returned %d\\n\",\n\t\t\t       zerr);\n\t\tgoto z_eio;\n\t}\n\n\twhile (curpage < pcount && curbh < haveblocks &&\n\t       zerr != Z_STREAM_END) {\n\t\tif (!stream.avail_out) {\n\t\t\tif (pages[curpage]) {\n\t\t\t\tstream.next_out = page_address(pages[curpage])\n\t\t\t\t\t\t+ poffset;\n\t\t\t\tstream.avail_out = PAGE_CACHE_SIZE - poffset;\n\t\t\t\tpoffset = 0;\n\t\t\t} else {\n\t\t\t\tstream.next_out = (void *)&zisofs_sink_page;\n\t\t\t\tstream.avail_out = PAGE_CACHE_SIZE;\n\t\t\t}\n\t\t}\n\t\tif (!stream.avail_in) {\n\t\t\twait_on_buffer(bhs[curbh]);\n\t\t\tif (!buffer_uptodate(bhs[curbh])) {\n\t\t\t\t*errp = -EIO;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tstream.next_in  = bhs[curbh]->b_data +\n\t\t\t\t\t\t(block_start & bufmask);\n\t\t\tstream.avail_in = min_t(unsigned, bufsize -\n\t\t\t\t\t\t(block_start & bufmask),\n\t\t\t\t\t\tblock_size);\n\t\t\tblock_size -= stream.avail_in;\n\t\t\tblock_start = 0;\n\t\t}\n\n\t\twhile (stream.avail_out && stream.avail_in) {\n\t\t\tzerr = zlib_inflate(&stream, Z_SYNC_FLUSH);\n\t\t\tif (zerr == Z_BUF_ERROR && stream.avail_in == 0)\n\t\t\t\tbreak;\n\t\t\tif (zerr == Z_STREAM_END)\n\t\t\t\tbreak;\n\t\t\tif (zerr != Z_OK) {\n\t\t\t\t/* EOF, error, or trying to read beyond end of input */\n\t\t\t\tif (zerr == Z_MEM_ERROR)\n\t\t\t\t\t*errp = -ENOMEM;\n\t\t\t\telse {\n\t\t\t\t\tprintk(KERN_DEBUG\n\t\t\t\t\t       \"zisofs: zisofs_inflate returned\"\n\t\t\t\t\t       \" %d, inode = %lu,\"\n\t\t\t\t\t       \" page idx = %d, bh idx = %d,\"\n\t\t\t\t\t       \" avail_in = %ld,\"\n\t\t\t\t\t       \" avail_out = %ld\\n\",\n\t\t\t\t\t       zerr, inode->i_ino, curpage,\n\t\t\t\t\t       curbh, stream.avail_in,\n\t\t\t\t\t       stream.avail_out);\n\t\t\t\t\t*errp = -EIO;\n\t\t\t\t}\n\t\t\t\tgoto inflate_out;\n\t\t\t}\n\t\t}\n\n\t\tif (!stream.avail_out) {\n\t\t\t/* This page completed */\n\t\t\tif (pages[curpage]) {\n\t\t\t\tflush_dcache_page(pages[curpage]);\n\t\t\t\tSetPageUptodate(pages[curpage]);\n\t\t\t}\n\t\t\tcurpage++;\n\t\t}\n\t\tif (!stream.avail_in)\n\t\t\tcurbh++;\n\t}\ninflate_out:\n\tzlib_inflateEnd(&stream);\n\nz_eio:\n\tmutex_unlock(&zisofs_zlib_lock);\n\nb_eio:\n\tfor (i = 0; i < haveblocks; i++)\n\t\tbrelse(bhs[i]);\n\treturn stream.total_out;\n}",
          "includes": [
            "#include \"zisofs.h\"",
            "#include \"isofs.h\"",
            "#include <linux/zlib.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static char zisofs_sink_page[PAGE_CACHE_SIZE];",
            "static void *zisofs_zlib_workspace;",
            "static DEFINE_MUTEX(zisofs_zlib_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"zisofs.h\"\n#include \"isofs.h\"\n#include <linux/zlib.h>\n#include <linux/vmalloc.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstatic char zisofs_sink_page[PAGE_CACHE_SIZE];\nstatic void *zisofs_zlib_workspace;\nstatic DEFINE_MUTEX(zisofs_zlib_lock);\n\nstatic loff_t zisofs_uncompress_block(struct inode *inode, loff_t block_start,\n\t\t\t\t      loff_t block_end, int pcount,\n\t\t\t\t      struct page **pages, unsigned poffset,\n\t\t\t\t      int *errp)\n{\n\tunsigned int zisofs_block_shift = ISOFS_I(inode)->i_format_parm[1];\n\tunsigned int bufsize = ISOFS_BUFFER_SIZE(inode);\n\tunsigned int bufshift = ISOFS_BUFFER_BITS(inode);\n\tunsigned int bufmask = bufsize - 1;\n\tint i, block_size = block_end - block_start;\n\tz_stream stream = { .total_out = 0,\n\t\t\t    .avail_in = 0,\n\t\t\t    .avail_out = 0, };\n\tint zerr;\n\tint needblocks = (block_size + (block_start & bufmask) + bufmask)\n\t\t\t\t>> bufshift;\n\tint haveblocks;\n\tblkcnt_t blocknum;\n\tstruct buffer_head *bhs[needblocks + 1];\n\tint curbh, curpage;\n\n\tif (block_size > deflateBound(1UL << zisofs_block_shift)) {\n\t\t*errp = -EIO;\n\t\treturn 0;\n\t}\n\t/* Empty block? */\n\tif (block_size == 0) {\n\t\tfor ( i = 0 ; i < pcount ; i++ ) {\n\t\t\tif (!pages[i])\n\t\t\t\tcontinue;\n\t\t\tmemset(page_address(pages[i]), 0, PAGE_CACHE_SIZE);\n\t\t\tflush_dcache_page(pages[i]);\n\t\t\tSetPageUptodate(pages[i]);\n\t\t}\n\t\treturn ((loff_t)pcount) << PAGE_CACHE_SHIFT;\n\t}\n\n\t/* Because zlib is not thread-safe, do all the I/O at the top. */\n\tblocknum = block_start >> bufshift;\n\tmemset(bhs, 0, (needblocks + 1) * sizeof(struct buffer_head *));\n\thaveblocks = isofs_get_blocks(inode, blocknum, bhs, needblocks);\n\tll_rw_block(READ, haveblocks, bhs);\n\n\tcurbh = 0;\n\tcurpage = 0;\n\t/*\n\t * First block is special since it may be fractional.  We also wait for\n\t * it before grabbing the zlib mutex; odds are that the subsequent\n\t * blocks are going to come in in short order so we don't hold the zlib\n\t * mutex longer than necessary.\n\t */\n\n\tif (!bhs[0])\n\t\tgoto b_eio;\n\n\twait_on_buffer(bhs[0]);\n\tif (!buffer_uptodate(bhs[0])) {\n\t\t*errp = -EIO;\n\t\tgoto b_eio;\n\t}\n\n\tstream.workspace = zisofs_zlib_workspace;\n\tmutex_lock(&zisofs_zlib_lock);\n\t\t\n\tzerr = zlib_inflateInit(&stream);\n\tif (zerr != Z_OK) {\n\t\tif (zerr == Z_MEM_ERROR)\n\t\t\t*errp = -ENOMEM;\n\t\telse\n\t\t\t*errp = -EIO;\n\t\tprintk(KERN_DEBUG \"zisofs: zisofs_inflateInit returned %d\\n\",\n\t\t\t       zerr);\n\t\tgoto z_eio;\n\t}\n\n\twhile (curpage < pcount && curbh < haveblocks &&\n\t       zerr != Z_STREAM_END) {\n\t\tif (!stream.avail_out) {\n\t\t\tif (pages[curpage]) {\n\t\t\t\tstream.next_out = page_address(pages[curpage])\n\t\t\t\t\t\t+ poffset;\n\t\t\t\tstream.avail_out = PAGE_CACHE_SIZE - poffset;\n\t\t\t\tpoffset = 0;\n\t\t\t} else {\n\t\t\t\tstream.next_out = (void *)&zisofs_sink_page;\n\t\t\t\tstream.avail_out = PAGE_CACHE_SIZE;\n\t\t\t}\n\t\t}\n\t\tif (!stream.avail_in) {\n\t\t\twait_on_buffer(bhs[curbh]);\n\t\t\tif (!buffer_uptodate(bhs[curbh])) {\n\t\t\t\t*errp = -EIO;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tstream.next_in  = bhs[curbh]->b_data +\n\t\t\t\t\t\t(block_start & bufmask);\n\t\t\tstream.avail_in = min_t(unsigned, bufsize -\n\t\t\t\t\t\t(block_start & bufmask),\n\t\t\t\t\t\tblock_size);\n\t\t\tblock_size -= stream.avail_in;\n\t\t\tblock_start = 0;\n\t\t}\n\n\t\twhile (stream.avail_out && stream.avail_in) {\n\t\t\tzerr = zlib_inflate(&stream, Z_SYNC_FLUSH);\n\t\t\tif (zerr == Z_BUF_ERROR && stream.avail_in == 0)\n\t\t\t\tbreak;\n\t\t\tif (zerr == Z_STREAM_END)\n\t\t\t\tbreak;\n\t\t\tif (zerr != Z_OK) {\n\t\t\t\t/* EOF, error, or trying to read beyond end of input */\n\t\t\t\tif (zerr == Z_MEM_ERROR)\n\t\t\t\t\t*errp = -ENOMEM;\n\t\t\t\telse {\n\t\t\t\t\tprintk(KERN_DEBUG\n\t\t\t\t\t       \"zisofs: zisofs_inflate returned\"\n\t\t\t\t\t       \" %d, inode = %lu,\"\n\t\t\t\t\t       \" page idx = %d, bh idx = %d,\"\n\t\t\t\t\t       \" avail_in = %ld,\"\n\t\t\t\t\t       \" avail_out = %ld\\n\",\n\t\t\t\t\t       zerr, inode->i_ino, curpage,\n\t\t\t\t\t       curbh, stream.avail_in,\n\t\t\t\t\t       stream.avail_out);\n\t\t\t\t\t*errp = -EIO;\n\t\t\t\t}\n\t\t\t\tgoto inflate_out;\n\t\t\t}\n\t\t}\n\n\t\tif (!stream.avail_out) {\n\t\t\t/* This page completed */\n\t\t\tif (pages[curpage]) {\n\t\t\t\tflush_dcache_page(pages[curpage]);\n\t\t\t\tSetPageUptodate(pages[curpage]);\n\t\t\t}\n\t\t\tcurpage++;\n\t\t}\n\t\tif (!stream.avail_in)\n\t\t\tcurbh++;\n\t}\ninflate_out:\n\tzlib_inflateEnd(&stream);\n\nz_eio:\n\tmutex_unlock(&zisofs_zlib_lock);\n\nb_eio:\n\tfor (i = 0; i < haveblocks; i++)\n\t\tbrelse(bhs[i]);\n\treturn stream.total_out;\n}"
        }
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "*(__le32 *)\n\t\t\t\t(bh->b_data + (blockptr & (blksize - 1)))"
          ],
          "line": 253
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "isofs_bread",
          "args": [
            "inode",
            "blockptr >> blkbits"
          ],
          "line": 249
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isofs_bread",
          "args": [
            "inode",
            "blockptr >> blkbits"
          ],
          "line": 236
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "start_off - (full_page << PAGE_CACHE_SHIFT) !=\n\t\t((cstart_block << zisofs_block_shift) & PAGE_CACHE_MASK)"
          ],
          "line": 229
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "min_t",
          "args": [
            "loff_t",
            "start_off + PAGE_CACHE_SIZE",
            "inode->i_size"
          ],
          "line": 223
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_offset",
          "args": [
            "pages[full_page]"
          ],
          "line": 222
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!pages[full_page]"
          ],
          "line": 215
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ISOFS_BUFFER_BITS",
          "args": [
            "inode"
          ],
          "line": 210
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ISOFS_I",
          "args": [
            "inode"
          ],
          "line": 205
        },
        "resolved": true,
        "details": {
          "function_name": "ISOFS_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/isofs/isofs.h",
          "lines": "67-70",
          "snippet": "static inline struct iso_inode_info *ISOFS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct iso_inode_info, vfs_inode);\n}",
          "includes": [
            "#include <asm/unaligned.h>",
            "#include <linux/iso_fs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern int get_rock_ridge_filename(struct iso_directory_record *, char *, struct inode *);",
            "extern int isofs_name_translate(struct iso_directory_record *, char *, struct inode *);",
            "int get_joliet_filename(struct iso_directory_record *, unsigned char *, struct inode *);",
            "int get_acorn_filename(struct iso_directory_record *, char *, struct inode *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/unaligned.h>\n#include <linux/iso_fs.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n\nextern int get_rock_ridge_filename(struct iso_directory_record *, char *, struct inode *);\nextern int isofs_name_translate(struct iso_directory_record *, char *, struct inode *);\nint get_joliet_filename(struct iso_directory_record *, unsigned char *, struct inode *);\nint get_acorn_filename(struct iso_directory_record *, char *, struct inode *);\n\nstatic inline struct iso_inode_info *ISOFS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct iso_inode_info, vfs_inode);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"zisofs.h\"\n#include \"isofs.h\"\n#include <linux/zlib.h>\n#include <linux/vmalloc.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstatic int zisofs_fill_pages(struct inode *inode, int full_page, int pcount,\n\t\t\t     struct page **pages)\n{\n\tloff_t start_off, end_off;\n\tloff_t block_start, block_end;\n\tunsigned int header_size = ISOFS_I(inode)->i_format_parm[0];\n\tunsigned int zisofs_block_shift = ISOFS_I(inode)->i_format_parm[1];\n\tunsigned int blockptr;\n\tloff_t poffset = 0;\n\tblkcnt_t cstart_block, cend_block;\n\tstruct buffer_head *bh;\n\tunsigned int blkbits = ISOFS_BUFFER_BITS(inode);\n\tunsigned int blksize = 1 << blkbits;\n\tint err;\n\tloff_t ret;\n\n\tBUG_ON(!pages[full_page]);\n\n\t/*\n\t * We want to read at least 'full_page' page. Because we have to\n\t * uncompress the whole compression block anyway, fill the surrounding\n\t * pages with the data we have anyway...\n\t */\n\tstart_off = page_offset(pages[full_page]);\n\tend_off = min_t(loff_t, start_off + PAGE_CACHE_SIZE, inode->i_size);\n\n\tcstart_block = start_off >> zisofs_block_shift;\n\tcend_block = (end_off + (1 << zisofs_block_shift) - 1)\n\t\t\t>> zisofs_block_shift;\n\n\tWARN_ON(start_off - (full_page << PAGE_CACHE_SHIFT) !=\n\t\t((cstart_block << zisofs_block_shift) & PAGE_CACHE_MASK));\n\n\t/* Find the pointer to this specific chunk */\n\t/* Note: we're not using isonum_731() here because the data is known aligned */\n\t/* Note: header_size is in 32-bit words (4 bytes) */\n\tblockptr = (header_size + cstart_block) << 2;\n\tbh = isofs_bread(inode, blockptr >> blkbits);\n\tif (!bh)\n\t\treturn -EIO;\n\tblock_start = le32_to_cpu(*(__le32 *)\n\t\t\t\t(bh->b_data + (blockptr & (blksize - 1))));\n\n\twhile (cstart_block < cend_block && pcount > 0) {\n\t\t/* Load end of the compressed block in the file */\n\t\tblockptr += 4;\n\t\t/* Traversed to next block? */\n\t\tif (!(blockptr & (blksize - 1))) {\n\t\t\tbrelse(bh);\n\n\t\t\tbh = isofs_bread(inode, blockptr >> blkbits);\n\t\t\tif (!bh)\n\t\t\t\treturn -EIO;\n\t\t}\n\t\tblock_end = le32_to_cpu(*(__le32 *)\n\t\t\t\t(bh->b_data + (blockptr & (blksize - 1))));\n\t\tif (block_start > block_end) {\n\t\t\tbrelse(bh);\n\t\t\treturn -EIO;\n\t\t}\n\t\terr = 0;\n\t\tret = zisofs_uncompress_block(inode, block_start, block_end,\n\t\t\t\t\t      pcount, pages, poffset, &err);\n\t\tpoffset += ret;\n\t\tpages += poffset >> PAGE_CACHE_SHIFT;\n\t\tpcount -= poffset >> PAGE_CACHE_SHIFT;\n\t\tfull_page -= poffset >> PAGE_CACHE_SHIFT;\n\t\tpoffset &= ~PAGE_CACHE_MASK;\n\n\t\tif (err) {\n\t\t\tbrelse(bh);\n\t\t\t/*\n\t\t\t * Did we finish reading the page we really wanted\n\t\t\t * to read?\n\t\t\t */\n\t\t\tif (full_page < 0)\n\t\t\t\treturn 0;\n\t\t\treturn err;\n\t\t}\n\n\t\tblock_start = block_end;\n\t\tcstart_block++;\n\t}\n\n\tif (poffset && *pages) {\n\t\tmemset(page_address(*pages) + poffset, 0,\n\t\t       PAGE_CACHE_SIZE - poffset);\n\t\tflush_dcache_page(*pages);\n\t\tSetPageUptodate(*pages);\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "zisofs_uncompress_block",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/isofs/compress.c",
    "lines": "43-193",
    "snippet": "static loff_t zisofs_uncompress_block(struct inode *inode, loff_t block_start,\n\t\t\t\t      loff_t block_end, int pcount,\n\t\t\t\t      struct page **pages, unsigned poffset,\n\t\t\t\t      int *errp)\n{\n\tunsigned int zisofs_block_shift = ISOFS_I(inode)->i_format_parm[1];\n\tunsigned int bufsize = ISOFS_BUFFER_SIZE(inode);\n\tunsigned int bufshift = ISOFS_BUFFER_BITS(inode);\n\tunsigned int bufmask = bufsize - 1;\n\tint i, block_size = block_end - block_start;\n\tz_stream stream = { .total_out = 0,\n\t\t\t    .avail_in = 0,\n\t\t\t    .avail_out = 0, };\n\tint zerr;\n\tint needblocks = (block_size + (block_start & bufmask) + bufmask)\n\t\t\t\t>> bufshift;\n\tint haveblocks;\n\tblkcnt_t blocknum;\n\tstruct buffer_head *bhs[needblocks + 1];\n\tint curbh, curpage;\n\n\tif (block_size > deflateBound(1UL << zisofs_block_shift)) {\n\t\t*errp = -EIO;\n\t\treturn 0;\n\t}\n\t/* Empty block? */\n\tif (block_size == 0) {\n\t\tfor ( i = 0 ; i < pcount ; i++ ) {\n\t\t\tif (!pages[i])\n\t\t\t\tcontinue;\n\t\t\tmemset(page_address(pages[i]), 0, PAGE_CACHE_SIZE);\n\t\t\tflush_dcache_page(pages[i]);\n\t\t\tSetPageUptodate(pages[i]);\n\t\t}\n\t\treturn ((loff_t)pcount) << PAGE_CACHE_SHIFT;\n\t}\n\n\t/* Because zlib is not thread-safe, do all the I/O at the top. */\n\tblocknum = block_start >> bufshift;\n\tmemset(bhs, 0, (needblocks + 1) * sizeof(struct buffer_head *));\n\thaveblocks = isofs_get_blocks(inode, blocknum, bhs, needblocks);\n\tll_rw_block(READ, haveblocks, bhs);\n\n\tcurbh = 0;\n\tcurpage = 0;\n\t/*\n\t * First block is special since it may be fractional.  We also wait for\n\t * it before grabbing the zlib mutex; odds are that the subsequent\n\t * blocks are going to come in in short order so we don't hold the zlib\n\t * mutex longer than necessary.\n\t */\n\n\tif (!bhs[0])\n\t\tgoto b_eio;\n\n\twait_on_buffer(bhs[0]);\n\tif (!buffer_uptodate(bhs[0])) {\n\t\t*errp = -EIO;\n\t\tgoto b_eio;\n\t}\n\n\tstream.workspace = zisofs_zlib_workspace;\n\tmutex_lock(&zisofs_zlib_lock);\n\t\t\n\tzerr = zlib_inflateInit(&stream);\n\tif (zerr != Z_OK) {\n\t\tif (zerr == Z_MEM_ERROR)\n\t\t\t*errp = -ENOMEM;\n\t\telse\n\t\t\t*errp = -EIO;\n\t\tprintk(KERN_DEBUG \"zisofs: zisofs_inflateInit returned %d\\n\",\n\t\t\t       zerr);\n\t\tgoto z_eio;\n\t}\n\n\twhile (curpage < pcount && curbh < haveblocks &&\n\t       zerr != Z_STREAM_END) {\n\t\tif (!stream.avail_out) {\n\t\t\tif (pages[curpage]) {\n\t\t\t\tstream.next_out = page_address(pages[curpage])\n\t\t\t\t\t\t+ poffset;\n\t\t\t\tstream.avail_out = PAGE_CACHE_SIZE - poffset;\n\t\t\t\tpoffset = 0;\n\t\t\t} else {\n\t\t\t\tstream.next_out = (void *)&zisofs_sink_page;\n\t\t\t\tstream.avail_out = PAGE_CACHE_SIZE;\n\t\t\t}\n\t\t}\n\t\tif (!stream.avail_in) {\n\t\t\twait_on_buffer(bhs[curbh]);\n\t\t\tif (!buffer_uptodate(bhs[curbh])) {\n\t\t\t\t*errp = -EIO;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tstream.next_in  = bhs[curbh]->b_data +\n\t\t\t\t\t\t(block_start & bufmask);\n\t\t\tstream.avail_in = min_t(unsigned, bufsize -\n\t\t\t\t\t\t(block_start & bufmask),\n\t\t\t\t\t\tblock_size);\n\t\t\tblock_size -= stream.avail_in;\n\t\t\tblock_start = 0;\n\t\t}\n\n\t\twhile (stream.avail_out && stream.avail_in) {\n\t\t\tzerr = zlib_inflate(&stream, Z_SYNC_FLUSH);\n\t\t\tif (zerr == Z_BUF_ERROR && stream.avail_in == 0)\n\t\t\t\tbreak;\n\t\t\tif (zerr == Z_STREAM_END)\n\t\t\t\tbreak;\n\t\t\tif (zerr != Z_OK) {\n\t\t\t\t/* EOF, error, or trying to read beyond end of input */\n\t\t\t\tif (zerr == Z_MEM_ERROR)\n\t\t\t\t\t*errp = -ENOMEM;\n\t\t\t\telse {\n\t\t\t\t\tprintk(KERN_DEBUG\n\t\t\t\t\t       \"zisofs: zisofs_inflate returned\"\n\t\t\t\t\t       \" %d, inode = %lu,\"\n\t\t\t\t\t       \" page idx = %d, bh idx = %d,\"\n\t\t\t\t\t       \" avail_in = %ld,\"\n\t\t\t\t\t       \" avail_out = %ld\\n\",\n\t\t\t\t\t       zerr, inode->i_ino, curpage,\n\t\t\t\t\t       curbh, stream.avail_in,\n\t\t\t\t\t       stream.avail_out);\n\t\t\t\t\t*errp = -EIO;\n\t\t\t\t}\n\t\t\t\tgoto inflate_out;\n\t\t\t}\n\t\t}\n\n\t\tif (!stream.avail_out) {\n\t\t\t/* This page completed */\n\t\t\tif (pages[curpage]) {\n\t\t\t\tflush_dcache_page(pages[curpage]);\n\t\t\t\tSetPageUptodate(pages[curpage]);\n\t\t\t}\n\t\t\tcurpage++;\n\t\t}\n\t\tif (!stream.avail_in)\n\t\t\tcurbh++;\n\t}\ninflate_out:\n\tzlib_inflateEnd(&stream);\n\nz_eio:\n\tmutex_unlock(&zisofs_zlib_lock);\n\nb_eio:\n\tfor (i = 0; i < haveblocks; i++)\n\t\tbrelse(bhs[i]);\n\treturn stream.total_out;\n}",
    "includes": [
      "#include \"zisofs.h\"",
      "#include \"isofs.h\"",
      "#include <linux/zlib.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static char zisofs_sink_page[PAGE_CACHE_SIZE];",
      "static void *zisofs_zlib_workspace;",
      "static DEFINE_MUTEX(zisofs_zlib_lock);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "bhs[i]"
          ],
          "line": 191
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&zisofs_zlib_lock"
          ],
          "line": 187
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "zlib_inflateEnd",
          "args": [
            "&stream"
          ],
          "line": 184
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SetPageUptodate",
          "args": [
            "pages[curpage]"
          ],
          "line": 176
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "flush_dcache_page",
          "args": [
            "pages[curpage]"
          ],
          "line": 175
        },
        "resolved": true,
        "details": {
          "function_name": "ntfs_index_entry_flush_dcache_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/index.h",
          "lines": "111-117",
          "snippet": "static inline void ntfs_index_entry_flush_dcache_page(ntfs_index_context *ictx)\n{\n\tif (ictx->is_in_root)\n\t\tflush_dcache_mft_record_page(ictx->actx->ntfs_ino);\n\telse\n\t\tflush_dcache_page(ictx->page);\n}",
          "includes": [
            "#include \"aops.h\"",
            "#include \"mft.h\"",
            "#include \"attrib.h\"",
            "#include \"inode.h\"",
            "#include \"layout.h\"",
            "#include \"types.h\"",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"aops.h\"\n#include \"mft.h\"\n#include \"attrib.h\"\n#include \"inode.h\"\n#include \"layout.h\"\n#include \"types.h\"\n#include <linux/fs.h>\n\nstatic inline void ntfs_index_entry_flush_dcache_page(ntfs_index_context *ictx)\n{\n\tif (ictx->is_in_root)\n\t\tflush_dcache_mft_record_page(ictx->actx->ntfs_ino);\n\telse\n\t\tflush_dcache_page(ictx->page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_DEBUG\n\t\t\t\t\t       \"zisofs: zisofs_inflate returned\"\n\t\t\t\t\t       \" %d, inode = %lu,\"\n\t\t\t\t\t       \" page idx = %d, bh idx = %d,\"\n\t\t\t\t\t       \" avail_in = %ld,\"\n\t\t\t\t\t       \" avail_out = %ld\\n\"",
            "zerr",
            "inode->i_ino",
            "curpage",
            "curbh",
            "stream.avail_in",
            "stream.avail_out"
          ],
          "line": 157
        },
        "resolved": true,
        "details": {
          "function_name": "compat_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/compat.c",
          "lines": "59-69",
          "snippet": "int compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/ioctls.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/aio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/mm.h>",
            "#include <linux/poll.h>",
            "#include <linux/signal.h>",
            "#include <linux/highmem.h>",
            "#include <linux/security.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/personality.h>",
            "#include <linux/highuid.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/dirent.h>",
            "#include <linux/ctype.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/nfs4_mount.h>",
            "#include <linux/ncp_mount.h>",
            "#include <linux/init.h>",
            "#include <linux/ioctl.h>",
            "#include <linux/vfs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/namei.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/errno.h>",
            "#include <linux/compat.h>",
            "#include <linux/linkage.h>",
            "#include <linux/kernel.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int compat_log = 1;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/ioctls.h>\n#include <asm/mmu_context.h>\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/fs_struct.h>\n#include <linux/mm.h>\n#include <linux/poll.h>\n#include <linux/signal.h>\n#include <linux/highmem.h>\n#include <linux/security.h>\n#include <linux/tsacct_kern.h>\n#include <linux/rwsem.h>\n#include <linux/personality.h>\n#include <linux/highuid.h>\n#include <linux/fsnotify.h>\n#include <linux/dirent.h>\n#include <linux/ctype.h>\n#include <linux/syscalls.h>\n#include <linux/nfs4_mount.h>\n#include <linux/ncp_mount.h>\n#include <linux/init.h>\n#include <linux/ioctl.h>\n#include <linux/vfs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/namei.h>\n#include <linux/fcntl.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <linux/compat.h>\n#include <linux/linkage.h>\n#include <linux/kernel.h>\n#include <linux/stddef.h>\n\nint compat_log = 1;\n\nint compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "zlib_inflate",
          "args": [
            "&stream",
            "Z_SYNC_FLUSH"
          ],
          "line": 147
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "min_t",
          "args": [
            "unsigned",
            "bufsize -\n\t\t\t\t\t\t(block_start & bufmask)",
            "block_size"
          ],
          "line": 139
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "buffer_uptodate",
          "args": [
            "bhs[curbh]"
          ],
          "line": 133
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_set_buffer_uptodate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/disk-io.c",
          "lines": "3758-3761",
          "snippet": "int btrfs_set_buffer_uptodate(struct extent_buffer *buf)\n{\n\treturn set_extent_buffer_uptodate(buf);\n}",
          "includes": [
            "#include <asm/cpufeature.h>",
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"raid56.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/uuid.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/migrate.h>",
            "#include <linux/slab.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/writeback.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/swap.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/cpufeature.h>\n#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"raid56.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <asm/unaligned.h>\n#include <linux/semaphore.h>\n#include <linux/uuid.h>\n#include <linux/ratelimit.h>\n#include <linux/migrate.h>\n#include <linux/slab.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/radix-tree.h>\n#include <linux/swap.h>\n#include <linux/scatterlist.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nint btrfs_set_buffer_uptodate(struct extent_buffer *buf)\n{\n\treturn set_extent_buffer_uptodate(buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "wait_on_buffer",
          "args": [
            "bhs[curbh]"
          ],
          "line": 132
        },
        "resolved": true,
        "details": {
          "function_name": "__wait_on_buffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "117-120",
          "snippet": "void __wait_on_buffer(struct buffer_head * bh)\n{\n\twait_on_bit_io(&bh->b_state, BH_Lock, TASK_UNINTERRUPTIBLE);\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __wait_on_buffer(struct buffer_head * bh)\n{\n\twait_on_bit_io(&bh->b_state, BH_Lock, TASK_UNINTERRUPTIBLE);\n}"
        }
      },
      {
        "call_info": {
          "callee": "page_address",
          "args": [
            "pages[curpage]"
          ],
          "line": 122
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "zlib_inflateInit",
          "args": [
            "&stream"
          ],
          "line": 107
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&zisofs_zlib_lock"
          ],
          "line": 105
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ll_rw_block",
          "args": [
            "READ",
            "haveblocks",
            "bhs"
          ],
          "line": 84
        },
        "resolved": true,
        "details": {
          "function_name": "ll_rw_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "3086-3112",
          "snippet": "void ll_rw_block(int rw, int nr, struct buffer_head *bhs[])\n{\n\tint i;\n\n\tfor (i = 0; i < nr; i++) {\n\t\tstruct buffer_head *bh = bhs[i];\n\n\t\tif (!trylock_buffer(bh))\n\t\t\tcontinue;\n\t\tif (rw == WRITE) {\n\t\t\tif (test_clear_buffer_dirty(bh)) {\n\t\t\t\tbh->b_end_io = end_buffer_write_sync;\n\t\t\t\tget_bh(bh);\n\t\t\t\tsubmit_bh(WRITE, bh);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t} else {\n\t\t\tif (!buffer_uptodate(bh)) {\n\t\t\t\tbh->b_end_io = end_buffer_read_sync;\n\t\t\t\tget_bh(bh);\n\t\t\t\tsubmit_bh(rw, bh);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\tunlock_buffer(bh);\n\t}\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid ll_rw_block(int rw, int nr, struct buffer_head *bhs[])\n{\n\tint i;\n\n\tfor (i = 0; i < nr; i++) {\n\t\tstruct buffer_head *bh = bhs[i];\n\n\t\tif (!trylock_buffer(bh))\n\t\t\tcontinue;\n\t\tif (rw == WRITE) {\n\t\t\tif (test_clear_buffer_dirty(bh)) {\n\t\t\t\tbh->b_end_io = end_buffer_write_sync;\n\t\t\t\tget_bh(bh);\n\t\t\t\tsubmit_bh(WRITE, bh);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t} else {\n\t\t\tif (!buffer_uptodate(bh)) {\n\t\t\t\tbh->b_end_io = end_buffer_read_sync;\n\t\t\t\tget_bh(bh);\n\t\t\t\tsubmit_bh(rw, bh);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\tunlock_buffer(bh);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "isofs_get_blocks",
          "args": [
            "inode",
            "blocknum",
            "bhs",
            "needblocks"
          ],
          "line": 83
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "bhs",
            "0",
            "(needblocks + 1) * sizeof(struct buffer_head *)"
          ],
          "line": 82
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SetPageUptodate",
          "args": [
            "pages[i]"
          ],
          "line": 75
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "page_address(pages[i])",
            "0",
            "PAGE_CACHE_SIZE"
          ],
          "line": 73
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_address",
          "args": [
            "pages[i]"
          ],
          "line": 73
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "deflateBound",
          "args": [
            "1UL << zisofs_block_shift"
          ],
          "line": 64
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ISOFS_BUFFER_BITS",
          "args": [
            "inode"
          ],
          "line": 50
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ISOFS_BUFFER_SIZE",
          "args": [
            "inode"
          ],
          "line": 49
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ISOFS_I",
          "args": [
            "inode"
          ],
          "line": 48
        },
        "resolved": true,
        "details": {
          "function_name": "ISOFS_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/isofs/isofs.h",
          "lines": "67-70",
          "snippet": "static inline struct iso_inode_info *ISOFS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct iso_inode_info, vfs_inode);\n}",
          "includes": [
            "#include <asm/unaligned.h>",
            "#include <linux/iso_fs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern int get_rock_ridge_filename(struct iso_directory_record *, char *, struct inode *);",
            "extern int isofs_name_translate(struct iso_directory_record *, char *, struct inode *);",
            "int get_joliet_filename(struct iso_directory_record *, unsigned char *, struct inode *);",
            "int get_acorn_filename(struct iso_directory_record *, char *, struct inode *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/unaligned.h>\n#include <linux/iso_fs.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n\nextern int get_rock_ridge_filename(struct iso_directory_record *, char *, struct inode *);\nextern int isofs_name_translate(struct iso_directory_record *, char *, struct inode *);\nint get_joliet_filename(struct iso_directory_record *, unsigned char *, struct inode *);\nint get_acorn_filename(struct iso_directory_record *, char *, struct inode *);\n\nstatic inline struct iso_inode_info *ISOFS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct iso_inode_info, vfs_inode);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"zisofs.h\"\n#include \"isofs.h\"\n#include <linux/zlib.h>\n#include <linux/vmalloc.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstatic char zisofs_sink_page[PAGE_CACHE_SIZE];\nstatic void *zisofs_zlib_workspace;\nstatic DEFINE_MUTEX(zisofs_zlib_lock);\n\nstatic loff_t zisofs_uncompress_block(struct inode *inode, loff_t block_start,\n\t\t\t\t      loff_t block_end, int pcount,\n\t\t\t\t      struct page **pages, unsigned poffset,\n\t\t\t\t      int *errp)\n{\n\tunsigned int zisofs_block_shift = ISOFS_I(inode)->i_format_parm[1];\n\tunsigned int bufsize = ISOFS_BUFFER_SIZE(inode);\n\tunsigned int bufshift = ISOFS_BUFFER_BITS(inode);\n\tunsigned int bufmask = bufsize - 1;\n\tint i, block_size = block_end - block_start;\n\tz_stream stream = { .total_out = 0,\n\t\t\t    .avail_in = 0,\n\t\t\t    .avail_out = 0, };\n\tint zerr;\n\tint needblocks = (block_size + (block_start & bufmask) + bufmask)\n\t\t\t\t>> bufshift;\n\tint haveblocks;\n\tblkcnt_t blocknum;\n\tstruct buffer_head *bhs[needblocks + 1];\n\tint curbh, curpage;\n\n\tif (block_size > deflateBound(1UL << zisofs_block_shift)) {\n\t\t*errp = -EIO;\n\t\treturn 0;\n\t}\n\t/* Empty block? */\n\tif (block_size == 0) {\n\t\tfor ( i = 0 ; i < pcount ; i++ ) {\n\t\t\tif (!pages[i])\n\t\t\t\tcontinue;\n\t\t\tmemset(page_address(pages[i]), 0, PAGE_CACHE_SIZE);\n\t\t\tflush_dcache_page(pages[i]);\n\t\t\tSetPageUptodate(pages[i]);\n\t\t}\n\t\treturn ((loff_t)pcount) << PAGE_CACHE_SHIFT;\n\t}\n\n\t/* Because zlib is not thread-safe, do all the I/O at the top. */\n\tblocknum = block_start >> bufshift;\n\tmemset(bhs, 0, (needblocks + 1) * sizeof(struct buffer_head *));\n\thaveblocks = isofs_get_blocks(inode, blocknum, bhs, needblocks);\n\tll_rw_block(READ, haveblocks, bhs);\n\n\tcurbh = 0;\n\tcurpage = 0;\n\t/*\n\t * First block is special since it may be fractional.  We also wait for\n\t * it before grabbing the zlib mutex; odds are that the subsequent\n\t * blocks are going to come in in short order so we don't hold the zlib\n\t * mutex longer than necessary.\n\t */\n\n\tif (!bhs[0])\n\t\tgoto b_eio;\n\n\twait_on_buffer(bhs[0]);\n\tif (!buffer_uptodate(bhs[0])) {\n\t\t*errp = -EIO;\n\t\tgoto b_eio;\n\t}\n\n\tstream.workspace = zisofs_zlib_workspace;\n\tmutex_lock(&zisofs_zlib_lock);\n\t\t\n\tzerr = zlib_inflateInit(&stream);\n\tif (zerr != Z_OK) {\n\t\tif (zerr == Z_MEM_ERROR)\n\t\t\t*errp = -ENOMEM;\n\t\telse\n\t\t\t*errp = -EIO;\n\t\tprintk(KERN_DEBUG \"zisofs: zisofs_inflateInit returned %d\\n\",\n\t\t\t       zerr);\n\t\tgoto z_eio;\n\t}\n\n\twhile (curpage < pcount && curbh < haveblocks &&\n\t       zerr != Z_STREAM_END) {\n\t\tif (!stream.avail_out) {\n\t\t\tif (pages[curpage]) {\n\t\t\t\tstream.next_out = page_address(pages[curpage])\n\t\t\t\t\t\t+ poffset;\n\t\t\t\tstream.avail_out = PAGE_CACHE_SIZE - poffset;\n\t\t\t\tpoffset = 0;\n\t\t\t} else {\n\t\t\t\tstream.next_out = (void *)&zisofs_sink_page;\n\t\t\t\tstream.avail_out = PAGE_CACHE_SIZE;\n\t\t\t}\n\t\t}\n\t\tif (!stream.avail_in) {\n\t\t\twait_on_buffer(bhs[curbh]);\n\t\t\tif (!buffer_uptodate(bhs[curbh])) {\n\t\t\t\t*errp = -EIO;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tstream.next_in  = bhs[curbh]->b_data +\n\t\t\t\t\t\t(block_start & bufmask);\n\t\t\tstream.avail_in = min_t(unsigned, bufsize -\n\t\t\t\t\t\t(block_start & bufmask),\n\t\t\t\t\t\tblock_size);\n\t\t\tblock_size -= stream.avail_in;\n\t\t\tblock_start = 0;\n\t\t}\n\n\t\twhile (stream.avail_out && stream.avail_in) {\n\t\t\tzerr = zlib_inflate(&stream, Z_SYNC_FLUSH);\n\t\t\tif (zerr == Z_BUF_ERROR && stream.avail_in == 0)\n\t\t\t\tbreak;\n\t\t\tif (zerr == Z_STREAM_END)\n\t\t\t\tbreak;\n\t\t\tif (zerr != Z_OK) {\n\t\t\t\t/* EOF, error, or trying to read beyond end of input */\n\t\t\t\tif (zerr == Z_MEM_ERROR)\n\t\t\t\t\t*errp = -ENOMEM;\n\t\t\t\telse {\n\t\t\t\t\tprintk(KERN_DEBUG\n\t\t\t\t\t       \"zisofs: zisofs_inflate returned\"\n\t\t\t\t\t       \" %d, inode = %lu,\"\n\t\t\t\t\t       \" page idx = %d, bh idx = %d,\"\n\t\t\t\t\t       \" avail_in = %ld,\"\n\t\t\t\t\t       \" avail_out = %ld\\n\",\n\t\t\t\t\t       zerr, inode->i_ino, curpage,\n\t\t\t\t\t       curbh, stream.avail_in,\n\t\t\t\t\t       stream.avail_out);\n\t\t\t\t\t*errp = -EIO;\n\t\t\t\t}\n\t\t\t\tgoto inflate_out;\n\t\t\t}\n\t\t}\n\n\t\tif (!stream.avail_out) {\n\t\t\t/* This page completed */\n\t\t\tif (pages[curpage]) {\n\t\t\t\tflush_dcache_page(pages[curpage]);\n\t\t\t\tSetPageUptodate(pages[curpage]);\n\t\t\t}\n\t\t\tcurpage++;\n\t\t}\n\t\tif (!stream.avail_in)\n\t\t\tcurbh++;\n\t}\ninflate_out:\n\tzlib_inflateEnd(&stream);\n\nz_eio:\n\tmutex_unlock(&zisofs_zlib_lock);\n\nb_eio:\n\tfor (i = 0; i < haveblocks; i++)\n\t\tbrelse(bhs[i]);\n\treturn stream.total_out;\n}"
  }
]