[
  {
    "function_name": "journal_refile_buffer",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd/transaction.c",
    "lines": "2225-2237",
    "snippet": "void journal_refile_buffer(journal_t *journal, struct journal_head *jh)\n{\n\tstruct buffer_head *bh = jh2bh(jh);\n\n\t/* Get reference so that buffer cannot be freed before we unlock it */\n\tget_bh(bh);\n\tjbd_lock_bh_state(bh);\n\tspin_lock(&journal->j_list_lock);\n\t__journal_refile_buffer(jh);\n\tjbd_unlock_bh_state(bh);\n\tspin_unlock(&journal->j_list_lock);\n\t__brelse(bh);\n}",
    "includes": [
      "#include <linux/hrtimer.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/timer.h>",
      "#include <linux/slab.h>",
      "#include <linux/errno.h>",
      "#include <linux/jbd.h>",
      "#include <linux/fs.h>",
      "#include <linux/time.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void __journal_temp_unlink_buffer(struct journal_head *jh);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "__brelse",
          "args": [
            "bh"
          ],
          "line": 2236
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&journal->j_list_lock"
          ],
          "line": 2235
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "jbd_unlock_bh_state",
          "args": [
            "bh"
          ],
          "line": 2234
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__journal_refile_buffer",
          "args": [
            "jh"
          ],
          "line": 2233
        },
        "resolved": true,
        "details": {
          "function_name": "__journal_refile_buffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd/transaction.c",
          "lines": "2177-2217",
          "snippet": "void __journal_refile_buffer(struct journal_head *jh)\n{\n\tint was_dirty, jlist;\n\tstruct buffer_head *bh = jh2bh(jh);\n\n\tJ_ASSERT_JH(jh, jbd_is_locked_bh_state(bh));\n\tif (jh->b_transaction)\n\t\tassert_spin_locked(&jh->b_transaction->t_journal->j_list_lock);\n\n\t/* If the buffer is now unused, just drop it. */\n\tif (jh->b_next_transaction == NULL) {\n\t\t__journal_unfile_buffer(jh);\n\t\treturn;\n\t}\n\n\t/*\n\t * It has been modified by a later transaction: add it to the new\n\t * transaction's metadata list.\n\t */\n\n\twas_dirty = test_clear_buffer_jbddirty(bh);\n\t__journal_temp_unlink_buffer(jh);\n\t/*\n\t * We set b_transaction here because b_next_transaction will inherit\n\t * our jh reference and thus __journal_file_buffer() must not take a\n\t * new one.\n\t */\n\tjh->b_transaction = jh->b_next_transaction;\n\tjh->b_next_transaction = NULL;\n\tif (buffer_freed(bh))\n\t\tjlist = BJ_Forget;\n\telse if (jh->b_modified)\n\t\tjlist = BJ_Metadata;\n\telse\n\t\tjlist = BJ_Reserved;\n\t__journal_file_buffer(jh, jh->b_transaction, jlist);\n\tJ_ASSERT_JH(jh, jh->b_transaction->t_state == T_RUNNING);\n\n\tif (was_dirty)\n\t\tset_buffer_jbddirty(bh);\n}",
          "includes": [
            "#include <linux/hrtimer.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/timer.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/jbd.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __journal_temp_unlink_buffer(struct journal_head *jh);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/timer.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n\nstatic void __journal_temp_unlink_buffer(struct journal_head *jh);\n\nvoid __journal_refile_buffer(struct journal_head *jh)\n{\n\tint was_dirty, jlist;\n\tstruct buffer_head *bh = jh2bh(jh);\n\n\tJ_ASSERT_JH(jh, jbd_is_locked_bh_state(bh));\n\tif (jh->b_transaction)\n\t\tassert_spin_locked(&jh->b_transaction->t_journal->j_list_lock);\n\n\t/* If the buffer is now unused, just drop it. */\n\tif (jh->b_next_transaction == NULL) {\n\t\t__journal_unfile_buffer(jh);\n\t\treturn;\n\t}\n\n\t/*\n\t * It has been modified by a later transaction: add it to the new\n\t * transaction's metadata list.\n\t */\n\n\twas_dirty = test_clear_buffer_jbddirty(bh);\n\t__journal_temp_unlink_buffer(jh);\n\t/*\n\t * We set b_transaction here because b_next_transaction will inherit\n\t * our jh reference and thus __journal_file_buffer() must not take a\n\t * new one.\n\t */\n\tjh->b_transaction = jh->b_next_transaction;\n\tjh->b_next_transaction = NULL;\n\tif (buffer_freed(bh))\n\t\tjlist = BJ_Forget;\n\telse if (jh->b_modified)\n\t\tjlist = BJ_Metadata;\n\telse\n\t\tjlist = BJ_Reserved;\n\t__journal_file_buffer(jh, jh->b_transaction, jlist);\n\tJ_ASSERT_JH(jh, jh->b_transaction->t_state == T_RUNNING);\n\n\tif (was_dirty)\n\t\tset_buffer_jbddirty(bh);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&journal->j_list_lock"
          ],
          "line": 2232
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "jbd_lock_bh_state",
          "args": [
            "bh"
          ],
          "line": 2231
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_bh",
          "args": [
            "bh"
          ],
          "line": 2230
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "jh2bh",
          "args": [
            "jh"
          ],
          "line": 2227
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/timer.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n\nstatic void __journal_temp_unlink_buffer(struct journal_head *jh);\n\nvoid journal_refile_buffer(journal_t *journal, struct journal_head *jh)\n{\n\tstruct buffer_head *bh = jh2bh(jh);\n\n\t/* Get reference so that buffer cannot be freed before we unlock it */\n\tget_bh(bh);\n\tjbd_lock_bh_state(bh);\n\tspin_lock(&journal->j_list_lock);\n\t__journal_refile_buffer(jh);\n\tjbd_unlock_bh_state(bh);\n\tspin_unlock(&journal->j_list_lock);\n\t__brelse(bh);\n}"
  },
  {
    "function_name": "__journal_refile_buffer",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd/transaction.c",
    "lines": "2177-2217",
    "snippet": "void __journal_refile_buffer(struct journal_head *jh)\n{\n\tint was_dirty, jlist;\n\tstruct buffer_head *bh = jh2bh(jh);\n\n\tJ_ASSERT_JH(jh, jbd_is_locked_bh_state(bh));\n\tif (jh->b_transaction)\n\t\tassert_spin_locked(&jh->b_transaction->t_journal->j_list_lock);\n\n\t/* If the buffer is now unused, just drop it. */\n\tif (jh->b_next_transaction == NULL) {\n\t\t__journal_unfile_buffer(jh);\n\t\treturn;\n\t}\n\n\t/*\n\t * It has been modified by a later transaction: add it to the new\n\t * transaction's metadata list.\n\t */\n\n\twas_dirty = test_clear_buffer_jbddirty(bh);\n\t__journal_temp_unlink_buffer(jh);\n\t/*\n\t * We set b_transaction here because b_next_transaction will inherit\n\t * our jh reference and thus __journal_file_buffer() must not take a\n\t * new one.\n\t */\n\tjh->b_transaction = jh->b_next_transaction;\n\tjh->b_next_transaction = NULL;\n\tif (buffer_freed(bh))\n\t\tjlist = BJ_Forget;\n\telse if (jh->b_modified)\n\t\tjlist = BJ_Metadata;\n\telse\n\t\tjlist = BJ_Reserved;\n\t__journal_file_buffer(jh, jh->b_transaction, jlist);\n\tJ_ASSERT_JH(jh, jh->b_transaction->t_state == T_RUNNING);\n\n\tif (was_dirty)\n\t\tset_buffer_jbddirty(bh);\n}",
    "includes": [
      "#include <linux/hrtimer.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/timer.h>",
      "#include <linux/slab.h>",
      "#include <linux/errno.h>",
      "#include <linux/jbd.h>",
      "#include <linux/fs.h>",
      "#include <linux/time.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void __journal_temp_unlink_buffer(struct journal_head *jh);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "set_buffer_jbddirty",
          "args": [
            "bh"
          ],
          "line": 2216
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "J_ASSERT_JH",
          "args": [
            "jh",
            "jh->b_transaction->t_state == T_RUNNING"
          ],
          "line": 2213
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__journal_file_buffer",
          "args": [
            "jh",
            "jh->b_transaction",
            "jlist"
          ],
          "line": 2212
        },
        "resolved": true,
        "details": {
          "function_name": "__journal_file_buffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd/transaction.c",
          "lines": "2078-2154",
          "snippet": "void __journal_file_buffer(struct journal_head *jh,\n\t\t\ttransaction_t *transaction, int jlist)\n{\n\tstruct journal_head **list = NULL;\n\tint was_dirty = 0;\n\tstruct buffer_head *bh = jh2bh(jh);\n\n\tJ_ASSERT_JH(jh, jbd_is_locked_bh_state(bh));\n\tassert_spin_locked(&transaction->t_journal->j_list_lock);\n\n\tJ_ASSERT_JH(jh, jh->b_jlist < BJ_Types);\n\tJ_ASSERT_JH(jh, jh->b_transaction == transaction ||\n\t\t\t\tjh->b_transaction == NULL);\n\n\tif (jh->b_transaction && jh->b_jlist == jlist)\n\t\treturn;\n\n\tif (jlist == BJ_Metadata || jlist == BJ_Reserved ||\n\t    jlist == BJ_Shadow || jlist == BJ_Forget) {\n\t\t/*\n\t\t * For metadata buffers, we track dirty bit in buffer_jbddirty\n\t\t * instead of buffer_dirty. We should not see a dirty bit set\n\t\t * here because we clear it in do_get_write_access but e.g.\n\t\t * tune2fs can modify the sb and set the dirty bit at any time\n\t\t * so we try to gracefully handle that.\n\t\t */\n\t\tif (buffer_dirty(bh))\n\t\t\twarn_dirty_buffer(bh);\n\t\tif (test_clear_buffer_dirty(bh) ||\n\t\t    test_clear_buffer_jbddirty(bh))\n\t\t\twas_dirty = 1;\n\t}\n\n\tif (jh->b_transaction)\n\t\t__journal_temp_unlink_buffer(jh);\n\telse\n\t\tjournal_grab_journal_head(bh);\n\tjh->b_transaction = transaction;\n\n\tswitch (jlist) {\n\tcase BJ_None:\n\t\tJ_ASSERT_JH(jh, !jh->b_committed_data);\n\t\tJ_ASSERT_JH(jh, !jh->b_frozen_data);\n\t\treturn;\n\tcase BJ_SyncData:\n\t\tlist = &transaction->t_sync_datalist;\n\t\tbreak;\n\tcase BJ_Metadata:\n\t\ttransaction->t_nr_buffers++;\n\t\tlist = &transaction->t_buffers;\n\t\tbreak;\n\tcase BJ_Forget:\n\t\tlist = &transaction->t_forget;\n\t\tbreak;\n\tcase BJ_IO:\n\t\tlist = &transaction->t_iobuf_list;\n\t\tbreak;\n\tcase BJ_Shadow:\n\t\tlist = &transaction->t_shadow_list;\n\t\tbreak;\n\tcase BJ_LogCtl:\n\t\tlist = &transaction->t_log_list;\n\t\tbreak;\n\tcase BJ_Reserved:\n\t\tlist = &transaction->t_reserved_list;\n\t\tbreak;\n\tcase BJ_Locked:\n\t\tlist =  &transaction->t_locked_list;\n\t\tbreak;\n\t}\n\n\t__blist_add_buffer(list, jh);\n\tjh->b_jlist = jlist;\n\n\tif (was_dirty)\n\t\tset_buffer_jbddirty(bh);\n}",
          "includes": [
            "#include <linux/hrtimer.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/timer.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/jbd.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __journal_temp_unlink_buffer(struct journal_head *jh);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/timer.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n\nstatic void __journal_temp_unlink_buffer(struct journal_head *jh);\n\nvoid __journal_file_buffer(struct journal_head *jh,\n\t\t\ttransaction_t *transaction, int jlist)\n{\n\tstruct journal_head **list = NULL;\n\tint was_dirty = 0;\n\tstruct buffer_head *bh = jh2bh(jh);\n\n\tJ_ASSERT_JH(jh, jbd_is_locked_bh_state(bh));\n\tassert_spin_locked(&transaction->t_journal->j_list_lock);\n\n\tJ_ASSERT_JH(jh, jh->b_jlist < BJ_Types);\n\tJ_ASSERT_JH(jh, jh->b_transaction == transaction ||\n\t\t\t\tjh->b_transaction == NULL);\n\n\tif (jh->b_transaction && jh->b_jlist == jlist)\n\t\treturn;\n\n\tif (jlist == BJ_Metadata || jlist == BJ_Reserved ||\n\t    jlist == BJ_Shadow || jlist == BJ_Forget) {\n\t\t/*\n\t\t * For metadata buffers, we track dirty bit in buffer_jbddirty\n\t\t * instead of buffer_dirty. We should not see a dirty bit set\n\t\t * here because we clear it in do_get_write_access but e.g.\n\t\t * tune2fs can modify the sb and set the dirty bit at any time\n\t\t * so we try to gracefully handle that.\n\t\t */\n\t\tif (buffer_dirty(bh))\n\t\t\twarn_dirty_buffer(bh);\n\t\tif (test_clear_buffer_dirty(bh) ||\n\t\t    test_clear_buffer_jbddirty(bh))\n\t\t\twas_dirty = 1;\n\t}\n\n\tif (jh->b_transaction)\n\t\t__journal_temp_unlink_buffer(jh);\n\telse\n\t\tjournal_grab_journal_head(bh);\n\tjh->b_transaction = transaction;\n\n\tswitch (jlist) {\n\tcase BJ_None:\n\t\tJ_ASSERT_JH(jh, !jh->b_committed_data);\n\t\tJ_ASSERT_JH(jh, !jh->b_frozen_data);\n\t\treturn;\n\tcase BJ_SyncData:\n\t\tlist = &transaction->t_sync_datalist;\n\t\tbreak;\n\tcase BJ_Metadata:\n\t\ttransaction->t_nr_buffers++;\n\t\tlist = &transaction->t_buffers;\n\t\tbreak;\n\tcase BJ_Forget:\n\t\tlist = &transaction->t_forget;\n\t\tbreak;\n\tcase BJ_IO:\n\t\tlist = &transaction->t_iobuf_list;\n\t\tbreak;\n\tcase BJ_Shadow:\n\t\tlist = &transaction->t_shadow_list;\n\t\tbreak;\n\tcase BJ_LogCtl:\n\t\tlist = &transaction->t_log_list;\n\t\tbreak;\n\tcase BJ_Reserved:\n\t\tlist = &transaction->t_reserved_list;\n\t\tbreak;\n\tcase BJ_Locked:\n\t\tlist =  &transaction->t_locked_list;\n\t\tbreak;\n\t}\n\n\t__blist_add_buffer(list, jh);\n\tjh->b_jlist = jlist;\n\n\tif (was_dirty)\n\t\tset_buffer_jbddirty(bh);\n}"
        }
      },
      {
        "call_info": {
          "callee": "buffer_freed",
          "args": [
            "bh"
          ],
          "line": 2206
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__journal_temp_unlink_buffer",
          "args": [
            "jh"
          ],
          "line": 2198
        },
        "resolved": true,
        "details": {
          "function_name": "__journal_temp_unlink_buffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd/transaction.c",
          "lines": "1571-1621",
          "snippet": "static void __journal_temp_unlink_buffer(struct journal_head *jh)\n{\n\tstruct journal_head **list = NULL;\n\ttransaction_t *transaction;\n\tstruct buffer_head *bh = jh2bh(jh);\n\n\tJ_ASSERT_JH(jh, jbd_is_locked_bh_state(bh));\n\ttransaction = jh->b_transaction;\n\tif (transaction)\n\t\tassert_spin_locked(&transaction->t_journal->j_list_lock);\n\n\tJ_ASSERT_JH(jh, jh->b_jlist < BJ_Types);\n\tif (jh->b_jlist != BJ_None)\n\t\tJ_ASSERT_JH(jh, transaction != NULL);\n\n\tswitch (jh->b_jlist) {\n\tcase BJ_None:\n\t\treturn;\n\tcase BJ_SyncData:\n\t\tlist = &transaction->t_sync_datalist;\n\t\tbreak;\n\tcase BJ_Metadata:\n\t\ttransaction->t_nr_buffers--;\n\t\tJ_ASSERT_JH(jh, transaction->t_nr_buffers >= 0);\n\t\tlist = &transaction->t_buffers;\n\t\tbreak;\n\tcase BJ_Forget:\n\t\tlist = &transaction->t_forget;\n\t\tbreak;\n\tcase BJ_IO:\n\t\tlist = &transaction->t_iobuf_list;\n\t\tbreak;\n\tcase BJ_Shadow:\n\t\tlist = &transaction->t_shadow_list;\n\t\tbreak;\n\tcase BJ_LogCtl:\n\t\tlist = &transaction->t_log_list;\n\t\tbreak;\n\tcase BJ_Reserved:\n\t\tlist = &transaction->t_reserved_list;\n\t\tbreak;\n\tcase BJ_Locked:\n\t\tlist = &transaction->t_locked_list;\n\t\tbreak;\n\t}\n\n\t__blist_del_buffer(list, jh);\n\tjh->b_jlist = BJ_None;\n\tif (test_clear_buffer_jbddirty(bh))\n\t\tmark_buffer_dirty(bh);\t/* Expose it to the VM */\n}",
          "includes": [
            "#include <linux/hrtimer.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/timer.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/jbd.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __journal_temp_unlink_buffer(struct journal_head *jh);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/timer.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n\nstatic void __journal_temp_unlink_buffer(struct journal_head *jh);\n\nstatic void __journal_temp_unlink_buffer(struct journal_head *jh)\n{\n\tstruct journal_head **list = NULL;\n\ttransaction_t *transaction;\n\tstruct buffer_head *bh = jh2bh(jh);\n\n\tJ_ASSERT_JH(jh, jbd_is_locked_bh_state(bh));\n\ttransaction = jh->b_transaction;\n\tif (transaction)\n\t\tassert_spin_locked(&transaction->t_journal->j_list_lock);\n\n\tJ_ASSERT_JH(jh, jh->b_jlist < BJ_Types);\n\tif (jh->b_jlist != BJ_None)\n\t\tJ_ASSERT_JH(jh, transaction != NULL);\n\n\tswitch (jh->b_jlist) {\n\tcase BJ_None:\n\t\treturn;\n\tcase BJ_SyncData:\n\t\tlist = &transaction->t_sync_datalist;\n\t\tbreak;\n\tcase BJ_Metadata:\n\t\ttransaction->t_nr_buffers--;\n\t\tJ_ASSERT_JH(jh, transaction->t_nr_buffers >= 0);\n\t\tlist = &transaction->t_buffers;\n\t\tbreak;\n\tcase BJ_Forget:\n\t\tlist = &transaction->t_forget;\n\t\tbreak;\n\tcase BJ_IO:\n\t\tlist = &transaction->t_iobuf_list;\n\t\tbreak;\n\tcase BJ_Shadow:\n\t\tlist = &transaction->t_shadow_list;\n\t\tbreak;\n\tcase BJ_LogCtl:\n\t\tlist = &transaction->t_log_list;\n\t\tbreak;\n\tcase BJ_Reserved:\n\t\tlist = &transaction->t_reserved_list;\n\t\tbreak;\n\tcase BJ_Locked:\n\t\tlist = &transaction->t_locked_list;\n\t\tbreak;\n\t}\n\n\t__blist_del_buffer(list, jh);\n\tjh->b_jlist = BJ_None;\n\tif (test_clear_buffer_jbddirty(bh))\n\t\tmark_buffer_dirty(bh);\t/* Expose it to the VM */\n}"
        }
      },
      {
        "call_info": {
          "callee": "test_clear_buffer_jbddirty",
          "args": [
            "bh"
          ],
          "line": 2197
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__journal_unfile_buffer",
          "args": [
            "jh"
          ],
          "line": 2188
        },
        "resolved": true,
        "details": {
          "function_name": "__journal_unfile_buffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd/transaction.c",
          "lines": "1630-1635",
          "snippet": "void __journal_unfile_buffer(struct journal_head *jh)\n{\n\t__journal_temp_unlink_buffer(jh);\n\tjh->b_transaction = NULL;\n\tjournal_put_journal_head(jh);\n}",
          "includes": [
            "#include <linux/hrtimer.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/timer.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/jbd.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __journal_temp_unlink_buffer(struct journal_head *jh);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/timer.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n\nstatic void __journal_temp_unlink_buffer(struct journal_head *jh);\n\nvoid __journal_unfile_buffer(struct journal_head *jh)\n{\n\t__journal_temp_unlink_buffer(jh);\n\tjh->b_transaction = NULL;\n\tjournal_put_journal_head(jh);\n}"
        }
      },
      {
        "call_info": {
          "callee": "assert_spin_locked",
          "args": [
            "&jh->b_transaction->t_journal->j_list_lock"
          ],
          "line": 2184
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "J_ASSERT_JH",
          "args": [
            "jh",
            "jbd_is_locked_bh_state(bh)"
          ],
          "line": 2182
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "jbd_is_locked_bh_state",
          "args": [
            "bh"
          ],
          "line": 2182
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "jh2bh",
          "args": [
            "jh"
          ],
          "line": 2180
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/timer.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n\nstatic void __journal_temp_unlink_buffer(struct journal_head *jh);\n\nvoid __journal_refile_buffer(struct journal_head *jh)\n{\n\tint was_dirty, jlist;\n\tstruct buffer_head *bh = jh2bh(jh);\n\n\tJ_ASSERT_JH(jh, jbd_is_locked_bh_state(bh));\n\tif (jh->b_transaction)\n\t\tassert_spin_locked(&jh->b_transaction->t_journal->j_list_lock);\n\n\t/* If the buffer is now unused, just drop it. */\n\tif (jh->b_next_transaction == NULL) {\n\t\t__journal_unfile_buffer(jh);\n\t\treturn;\n\t}\n\n\t/*\n\t * It has been modified by a later transaction: add it to the new\n\t * transaction's metadata list.\n\t */\n\n\twas_dirty = test_clear_buffer_jbddirty(bh);\n\t__journal_temp_unlink_buffer(jh);\n\t/*\n\t * We set b_transaction here because b_next_transaction will inherit\n\t * our jh reference and thus __journal_file_buffer() must not take a\n\t * new one.\n\t */\n\tjh->b_transaction = jh->b_next_transaction;\n\tjh->b_next_transaction = NULL;\n\tif (buffer_freed(bh))\n\t\tjlist = BJ_Forget;\n\telse if (jh->b_modified)\n\t\tjlist = BJ_Metadata;\n\telse\n\t\tjlist = BJ_Reserved;\n\t__journal_file_buffer(jh, jh->b_transaction, jlist);\n\tJ_ASSERT_JH(jh, jh->b_transaction->t_state == T_RUNNING);\n\n\tif (was_dirty)\n\t\tset_buffer_jbddirty(bh);\n}"
  },
  {
    "function_name": "journal_file_buffer",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd/transaction.c",
    "lines": "2156-2164",
    "snippet": "void journal_file_buffer(struct journal_head *jh,\n\t\t\t\ttransaction_t *transaction, int jlist)\n{\n\tjbd_lock_bh_state(jh2bh(jh));\n\tspin_lock(&transaction->t_journal->j_list_lock);\n\t__journal_file_buffer(jh, transaction, jlist);\n\tspin_unlock(&transaction->t_journal->j_list_lock);\n\tjbd_unlock_bh_state(jh2bh(jh));\n}",
    "includes": [
      "#include <linux/hrtimer.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/timer.h>",
      "#include <linux/slab.h>",
      "#include <linux/errno.h>",
      "#include <linux/jbd.h>",
      "#include <linux/fs.h>",
      "#include <linux/time.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void __journal_temp_unlink_buffer(struct journal_head *jh);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "jbd_unlock_bh_state",
          "args": [
            "jh2bh(jh)"
          ],
          "line": 2163
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "jh2bh",
          "args": [
            "jh"
          ],
          "line": 2163
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&transaction->t_journal->j_list_lock"
          ],
          "line": 2162
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "__journal_file_buffer",
          "args": [
            "jh",
            "transaction",
            "jlist"
          ],
          "line": 2161
        },
        "resolved": true,
        "details": {
          "function_name": "__journal_file_buffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd/transaction.c",
          "lines": "2078-2154",
          "snippet": "void __journal_file_buffer(struct journal_head *jh,\n\t\t\ttransaction_t *transaction, int jlist)\n{\n\tstruct journal_head **list = NULL;\n\tint was_dirty = 0;\n\tstruct buffer_head *bh = jh2bh(jh);\n\n\tJ_ASSERT_JH(jh, jbd_is_locked_bh_state(bh));\n\tassert_spin_locked(&transaction->t_journal->j_list_lock);\n\n\tJ_ASSERT_JH(jh, jh->b_jlist < BJ_Types);\n\tJ_ASSERT_JH(jh, jh->b_transaction == transaction ||\n\t\t\t\tjh->b_transaction == NULL);\n\n\tif (jh->b_transaction && jh->b_jlist == jlist)\n\t\treturn;\n\n\tif (jlist == BJ_Metadata || jlist == BJ_Reserved ||\n\t    jlist == BJ_Shadow || jlist == BJ_Forget) {\n\t\t/*\n\t\t * For metadata buffers, we track dirty bit in buffer_jbddirty\n\t\t * instead of buffer_dirty. We should not see a dirty bit set\n\t\t * here because we clear it in do_get_write_access but e.g.\n\t\t * tune2fs can modify the sb and set the dirty bit at any time\n\t\t * so we try to gracefully handle that.\n\t\t */\n\t\tif (buffer_dirty(bh))\n\t\t\twarn_dirty_buffer(bh);\n\t\tif (test_clear_buffer_dirty(bh) ||\n\t\t    test_clear_buffer_jbddirty(bh))\n\t\t\twas_dirty = 1;\n\t}\n\n\tif (jh->b_transaction)\n\t\t__journal_temp_unlink_buffer(jh);\n\telse\n\t\tjournal_grab_journal_head(bh);\n\tjh->b_transaction = transaction;\n\n\tswitch (jlist) {\n\tcase BJ_None:\n\t\tJ_ASSERT_JH(jh, !jh->b_committed_data);\n\t\tJ_ASSERT_JH(jh, !jh->b_frozen_data);\n\t\treturn;\n\tcase BJ_SyncData:\n\t\tlist = &transaction->t_sync_datalist;\n\t\tbreak;\n\tcase BJ_Metadata:\n\t\ttransaction->t_nr_buffers++;\n\t\tlist = &transaction->t_buffers;\n\t\tbreak;\n\tcase BJ_Forget:\n\t\tlist = &transaction->t_forget;\n\t\tbreak;\n\tcase BJ_IO:\n\t\tlist = &transaction->t_iobuf_list;\n\t\tbreak;\n\tcase BJ_Shadow:\n\t\tlist = &transaction->t_shadow_list;\n\t\tbreak;\n\tcase BJ_LogCtl:\n\t\tlist = &transaction->t_log_list;\n\t\tbreak;\n\tcase BJ_Reserved:\n\t\tlist = &transaction->t_reserved_list;\n\t\tbreak;\n\tcase BJ_Locked:\n\t\tlist =  &transaction->t_locked_list;\n\t\tbreak;\n\t}\n\n\t__blist_add_buffer(list, jh);\n\tjh->b_jlist = jlist;\n\n\tif (was_dirty)\n\t\tset_buffer_jbddirty(bh);\n}",
          "includes": [
            "#include <linux/hrtimer.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/timer.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/jbd.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __journal_temp_unlink_buffer(struct journal_head *jh);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/timer.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n\nstatic void __journal_temp_unlink_buffer(struct journal_head *jh);\n\nvoid __journal_file_buffer(struct journal_head *jh,\n\t\t\ttransaction_t *transaction, int jlist)\n{\n\tstruct journal_head **list = NULL;\n\tint was_dirty = 0;\n\tstruct buffer_head *bh = jh2bh(jh);\n\n\tJ_ASSERT_JH(jh, jbd_is_locked_bh_state(bh));\n\tassert_spin_locked(&transaction->t_journal->j_list_lock);\n\n\tJ_ASSERT_JH(jh, jh->b_jlist < BJ_Types);\n\tJ_ASSERT_JH(jh, jh->b_transaction == transaction ||\n\t\t\t\tjh->b_transaction == NULL);\n\n\tif (jh->b_transaction && jh->b_jlist == jlist)\n\t\treturn;\n\n\tif (jlist == BJ_Metadata || jlist == BJ_Reserved ||\n\t    jlist == BJ_Shadow || jlist == BJ_Forget) {\n\t\t/*\n\t\t * For metadata buffers, we track dirty bit in buffer_jbddirty\n\t\t * instead of buffer_dirty. We should not see a dirty bit set\n\t\t * here because we clear it in do_get_write_access but e.g.\n\t\t * tune2fs can modify the sb and set the dirty bit at any time\n\t\t * so we try to gracefully handle that.\n\t\t */\n\t\tif (buffer_dirty(bh))\n\t\t\twarn_dirty_buffer(bh);\n\t\tif (test_clear_buffer_dirty(bh) ||\n\t\t    test_clear_buffer_jbddirty(bh))\n\t\t\twas_dirty = 1;\n\t}\n\n\tif (jh->b_transaction)\n\t\t__journal_temp_unlink_buffer(jh);\n\telse\n\t\tjournal_grab_journal_head(bh);\n\tjh->b_transaction = transaction;\n\n\tswitch (jlist) {\n\tcase BJ_None:\n\t\tJ_ASSERT_JH(jh, !jh->b_committed_data);\n\t\tJ_ASSERT_JH(jh, !jh->b_frozen_data);\n\t\treturn;\n\tcase BJ_SyncData:\n\t\tlist = &transaction->t_sync_datalist;\n\t\tbreak;\n\tcase BJ_Metadata:\n\t\ttransaction->t_nr_buffers++;\n\t\tlist = &transaction->t_buffers;\n\t\tbreak;\n\tcase BJ_Forget:\n\t\tlist = &transaction->t_forget;\n\t\tbreak;\n\tcase BJ_IO:\n\t\tlist = &transaction->t_iobuf_list;\n\t\tbreak;\n\tcase BJ_Shadow:\n\t\tlist = &transaction->t_shadow_list;\n\t\tbreak;\n\tcase BJ_LogCtl:\n\t\tlist = &transaction->t_log_list;\n\t\tbreak;\n\tcase BJ_Reserved:\n\t\tlist = &transaction->t_reserved_list;\n\t\tbreak;\n\tcase BJ_Locked:\n\t\tlist =  &transaction->t_locked_list;\n\t\tbreak;\n\t}\n\n\t__blist_add_buffer(list, jh);\n\tjh->b_jlist = jlist;\n\n\tif (was_dirty)\n\t\tset_buffer_jbddirty(bh);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&transaction->t_journal->j_list_lock"
          ],
          "line": 2160
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "jbd_lock_bh_state",
          "args": [
            "jh2bh(jh)"
          ],
          "line": 2159
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "jh2bh",
          "args": [
            "jh"
          ],
          "line": 2159
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/timer.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n\nstatic void __journal_temp_unlink_buffer(struct journal_head *jh);\n\nvoid journal_file_buffer(struct journal_head *jh,\n\t\t\t\ttransaction_t *transaction, int jlist)\n{\n\tjbd_lock_bh_state(jh2bh(jh));\n\tspin_lock(&transaction->t_journal->j_list_lock);\n\t__journal_file_buffer(jh, transaction, jlist);\n\tspin_unlock(&transaction->t_journal->j_list_lock);\n\tjbd_unlock_bh_state(jh2bh(jh));\n}"
  },
  {
    "function_name": "__journal_file_buffer",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd/transaction.c",
    "lines": "2078-2154",
    "snippet": "void __journal_file_buffer(struct journal_head *jh,\n\t\t\ttransaction_t *transaction, int jlist)\n{\n\tstruct journal_head **list = NULL;\n\tint was_dirty = 0;\n\tstruct buffer_head *bh = jh2bh(jh);\n\n\tJ_ASSERT_JH(jh, jbd_is_locked_bh_state(bh));\n\tassert_spin_locked(&transaction->t_journal->j_list_lock);\n\n\tJ_ASSERT_JH(jh, jh->b_jlist < BJ_Types);\n\tJ_ASSERT_JH(jh, jh->b_transaction == transaction ||\n\t\t\t\tjh->b_transaction == NULL);\n\n\tif (jh->b_transaction && jh->b_jlist == jlist)\n\t\treturn;\n\n\tif (jlist == BJ_Metadata || jlist == BJ_Reserved ||\n\t    jlist == BJ_Shadow || jlist == BJ_Forget) {\n\t\t/*\n\t\t * For metadata buffers, we track dirty bit in buffer_jbddirty\n\t\t * instead of buffer_dirty. We should not see a dirty bit set\n\t\t * here because we clear it in do_get_write_access but e.g.\n\t\t * tune2fs can modify the sb and set the dirty bit at any time\n\t\t * so we try to gracefully handle that.\n\t\t */\n\t\tif (buffer_dirty(bh))\n\t\t\twarn_dirty_buffer(bh);\n\t\tif (test_clear_buffer_dirty(bh) ||\n\t\t    test_clear_buffer_jbddirty(bh))\n\t\t\twas_dirty = 1;\n\t}\n\n\tif (jh->b_transaction)\n\t\t__journal_temp_unlink_buffer(jh);\n\telse\n\t\tjournal_grab_journal_head(bh);\n\tjh->b_transaction = transaction;\n\n\tswitch (jlist) {\n\tcase BJ_None:\n\t\tJ_ASSERT_JH(jh, !jh->b_committed_data);\n\t\tJ_ASSERT_JH(jh, !jh->b_frozen_data);\n\t\treturn;\n\tcase BJ_SyncData:\n\t\tlist = &transaction->t_sync_datalist;\n\t\tbreak;\n\tcase BJ_Metadata:\n\t\ttransaction->t_nr_buffers++;\n\t\tlist = &transaction->t_buffers;\n\t\tbreak;\n\tcase BJ_Forget:\n\t\tlist = &transaction->t_forget;\n\t\tbreak;\n\tcase BJ_IO:\n\t\tlist = &transaction->t_iobuf_list;\n\t\tbreak;\n\tcase BJ_Shadow:\n\t\tlist = &transaction->t_shadow_list;\n\t\tbreak;\n\tcase BJ_LogCtl:\n\t\tlist = &transaction->t_log_list;\n\t\tbreak;\n\tcase BJ_Reserved:\n\t\tlist = &transaction->t_reserved_list;\n\t\tbreak;\n\tcase BJ_Locked:\n\t\tlist =  &transaction->t_locked_list;\n\t\tbreak;\n\t}\n\n\t__blist_add_buffer(list, jh);\n\tjh->b_jlist = jlist;\n\n\tif (was_dirty)\n\t\tset_buffer_jbddirty(bh);\n}",
    "includes": [
      "#include <linux/hrtimer.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/timer.h>",
      "#include <linux/slab.h>",
      "#include <linux/errno.h>",
      "#include <linux/jbd.h>",
      "#include <linux/fs.h>",
      "#include <linux/time.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void __journal_temp_unlink_buffer(struct journal_head *jh);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "set_buffer_jbddirty",
          "args": [
            "bh"
          ],
          "line": 2153
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__blist_add_buffer",
          "args": [
            "list",
            "jh"
          ],
          "line": 2149
        },
        "resolved": true,
        "details": {
          "function_name": "__blist_add_buffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd/transaction.c",
          "lines": "1524-1537",
          "snippet": "static inline void\n__blist_add_buffer(struct journal_head **list, struct journal_head *jh)\n{\n\tif (!*list) {\n\t\tjh->b_tnext = jh->b_tprev = jh;\n\t\t*list = jh;\n\t} else {\n\t\t/* Insert at the tail of the list to preserve order */\n\t\tstruct journal_head *first = *list, *last = first->b_tprev;\n\t\tjh->b_tprev = last;\n\t\tjh->b_tnext = first;\n\t\tlast->b_tnext = first->b_tprev = jh;\n\t}\n}",
          "includes": [
            "#include <linux/hrtimer.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/timer.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/jbd.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __journal_temp_unlink_buffer(struct journal_head *jh);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/timer.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n\nstatic void __journal_temp_unlink_buffer(struct journal_head *jh);\n\nstatic inline void\n__blist_add_buffer(struct journal_head **list, struct journal_head *jh)\n{\n\tif (!*list) {\n\t\tjh->b_tnext = jh->b_tprev = jh;\n\t\t*list = jh;\n\t} else {\n\t\t/* Insert at the tail of the list to preserve order */\n\t\tstruct journal_head *first = *list, *last = first->b_tprev;\n\t\tjh->b_tprev = last;\n\t\tjh->b_tnext = first;\n\t\tlast->b_tnext = first->b_tprev = jh;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "J_ASSERT_JH",
          "args": [
            "jh",
            "!jh->b_frozen_data"
          ],
          "line": 2120
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "J_ASSERT_JH",
          "args": [
            "jh",
            "!jh->b_committed_data"
          ],
          "line": 2119
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "journal_grab_journal_head",
          "args": [
            "bh"
          ],
          "line": 2114
        },
        "resolved": true,
        "details": {
          "function_name": "journal_grab_journal_head",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd/journal.c",
          "lines": "1977-1988",
          "snippet": "struct journal_head *journal_grab_journal_head(struct buffer_head *bh)\n{\n\tstruct journal_head *jh = NULL;\n\n\tjbd_lock_bh_journal_head(bh);\n\tif (buffer_jbd(bh)) {\n\t\tjh = bh2jh(bh);\n\t\tjh->b_jcount++;\n\t}\n\tjbd_unlock_bh_journal_head(bh);\n\treturn jh;\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <asm/uaccess.h>",
            "#include <trace/events/jbd.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/poison.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/jbd.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <trace/events/jbd.h>\n#include <linux/ratelimit.h>\n#include <linux/debugfs.h>\n#include <linux/proc_fs.h>\n#include <linux/poison.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/freezer.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nstruct journal_head *journal_grab_journal_head(struct buffer_head *bh)\n{\n\tstruct journal_head *jh = NULL;\n\n\tjbd_lock_bh_journal_head(bh);\n\tif (buffer_jbd(bh)) {\n\t\tjh = bh2jh(bh);\n\t\tjh->b_jcount++;\n\t}\n\tjbd_unlock_bh_journal_head(bh);\n\treturn jh;\n}"
        }
      },
      {
        "call_info": {
          "callee": "__journal_temp_unlink_buffer",
          "args": [
            "jh"
          ],
          "line": 2112
        },
        "resolved": true,
        "details": {
          "function_name": "__journal_temp_unlink_buffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd/transaction.c",
          "lines": "1571-1621",
          "snippet": "static void __journal_temp_unlink_buffer(struct journal_head *jh)\n{\n\tstruct journal_head **list = NULL;\n\ttransaction_t *transaction;\n\tstruct buffer_head *bh = jh2bh(jh);\n\n\tJ_ASSERT_JH(jh, jbd_is_locked_bh_state(bh));\n\ttransaction = jh->b_transaction;\n\tif (transaction)\n\t\tassert_spin_locked(&transaction->t_journal->j_list_lock);\n\n\tJ_ASSERT_JH(jh, jh->b_jlist < BJ_Types);\n\tif (jh->b_jlist != BJ_None)\n\t\tJ_ASSERT_JH(jh, transaction != NULL);\n\n\tswitch (jh->b_jlist) {\n\tcase BJ_None:\n\t\treturn;\n\tcase BJ_SyncData:\n\t\tlist = &transaction->t_sync_datalist;\n\t\tbreak;\n\tcase BJ_Metadata:\n\t\ttransaction->t_nr_buffers--;\n\t\tJ_ASSERT_JH(jh, transaction->t_nr_buffers >= 0);\n\t\tlist = &transaction->t_buffers;\n\t\tbreak;\n\tcase BJ_Forget:\n\t\tlist = &transaction->t_forget;\n\t\tbreak;\n\tcase BJ_IO:\n\t\tlist = &transaction->t_iobuf_list;\n\t\tbreak;\n\tcase BJ_Shadow:\n\t\tlist = &transaction->t_shadow_list;\n\t\tbreak;\n\tcase BJ_LogCtl:\n\t\tlist = &transaction->t_log_list;\n\t\tbreak;\n\tcase BJ_Reserved:\n\t\tlist = &transaction->t_reserved_list;\n\t\tbreak;\n\tcase BJ_Locked:\n\t\tlist = &transaction->t_locked_list;\n\t\tbreak;\n\t}\n\n\t__blist_del_buffer(list, jh);\n\tjh->b_jlist = BJ_None;\n\tif (test_clear_buffer_jbddirty(bh))\n\t\tmark_buffer_dirty(bh);\t/* Expose it to the VM */\n}",
          "includes": [
            "#include <linux/hrtimer.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/timer.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/jbd.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __journal_temp_unlink_buffer(struct journal_head *jh);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/timer.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n\nstatic void __journal_temp_unlink_buffer(struct journal_head *jh);\n\nstatic void __journal_temp_unlink_buffer(struct journal_head *jh)\n{\n\tstruct journal_head **list = NULL;\n\ttransaction_t *transaction;\n\tstruct buffer_head *bh = jh2bh(jh);\n\n\tJ_ASSERT_JH(jh, jbd_is_locked_bh_state(bh));\n\ttransaction = jh->b_transaction;\n\tif (transaction)\n\t\tassert_spin_locked(&transaction->t_journal->j_list_lock);\n\n\tJ_ASSERT_JH(jh, jh->b_jlist < BJ_Types);\n\tif (jh->b_jlist != BJ_None)\n\t\tJ_ASSERT_JH(jh, transaction != NULL);\n\n\tswitch (jh->b_jlist) {\n\tcase BJ_None:\n\t\treturn;\n\tcase BJ_SyncData:\n\t\tlist = &transaction->t_sync_datalist;\n\t\tbreak;\n\tcase BJ_Metadata:\n\t\ttransaction->t_nr_buffers--;\n\t\tJ_ASSERT_JH(jh, transaction->t_nr_buffers >= 0);\n\t\tlist = &transaction->t_buffers;\n\t\tbreak;\n\tcase BJ_Forget:\n\t\tlist = &transaction->t_forget;\n\t\tbreak;\n\tcase BJ_IO:\n\t\tlist = &transaction->t_iobuf_list;\n\t\tbreak;\n\tcase BJ_Shadow:\n\t\tlist = &transaction->t_shadow_list;\n\t\tbreak;\n\tcase BJ_LogCtl:\n\t\tlist = &transaction->t_log_list;\n\t\tbreak;\n\tcase BJ_Reserved:\n\t\tlist = &transaction->t_reserved_list;\n\t\tbreak;\n\tcase BJ_Locked:\n\t\tlist = &transaction->t_locked_list;\n\t\tbreak;\n\t}\n\n\t__blist_del_buffer(list, jh);\n\tjh->b_jlist = BJ_None;\n\tif (test_clear_buffer_jbddirty(bh))\n\t\tmark_buffer_dirty(bh);\t/* Expose it to the VM */\n}"
        }
      },
      {
        "call_info": {
          "callee": "test_clear_buffer_jbddirty",
          "args": [
            "bh"
          ],
          "line": 2107
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_clear_buffer_dirty",
          "args": [
            "bh"
          ],
          "line": 2106
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "warn_dirty_buffer",
          "args": [
            "bh"
          ],
          "line": 2105
        },
        "resolved": true,
        "details": {
          "function_name": "warn_dirty_buffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd/transaction.c",
          "lines": "497-506",
          "snippet": "static void warn_dirty_buffer(struct buffer_head *bh)\n{\n\tchar b[BDEVNAME_SIZE];\n\n\tprintk(KERN_WARNING\n\t       \"JBD: Spotted dirty metadata buffer (dev = %s, blocknr = %llu). \"\n\t       \"There's a risk of filesystem corruption in case of system \"\n\t       \"crash.\\n\",\n\t       bdevname(bh->b_bdev, b), (unsigned long long)bh->b_blocknr);\n}",
          "includes": [
            "#include <linux/hrtimer.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/timer.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/jbd.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/timer.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n\nstatic void warn_dirty_buffer(struct buffer_head *bh)\n{\n\tchar b[BDEVNAME_SIZE];\n\n\tprintk(KERN_WARNING\n\t       \"JBD: Spotted dirty metadata buffer (dev = %s, blocknr = %llu). \"\n\t       \"There's a risk of filesystem corruption in case of system \"\n\t       \"crash.\\n\",\n\t       bdevname(bh->b_bdev, b), (unsigned long long)bh->b_blocknr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "buffer_dirty",
          "args": [
            "bh"
          ],
          "line": 2104
        },
        "resolved": true,
        "details": {
          "function_name": "mark_buffer_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1141-1167",
          "snippet": "void mark_buffer_dirty(struct buffer_head *bh)\n{\n\tWARN_ON_ONCE(!buffer_uptodate(bh));\n\n\ttrace_block_dirty_buffer(bh);\n\n\t/*\n\t * Very *carefully* optimize the it-is-already-dirty case.\n\t *\n\t * Don't let the final \"is it dirty\" escape to before we\n\t * perhaps modified the buffer.\n\t */\n\tif (buffer_dirty(bh)) {\n\t\tsmp_mb();\n\t\tif (buffer_dirty(bh))\n\t\t\treturn;\n\t}\n\n\tif (!test_set_buffer_dirty(bh)) {\n\t\tstruct page *page = bh->b_page;\n\t\tif (!TestSetPageDirty(page)) {\n\t\t\tstruct address_space *mapping = page_mapping(page);\n\t\t\tif (mapping)\n\t\t\t\t__set_page_dirty(page, mapping, 0);\n\t\t}\n\t}\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid mark_buffer_dirty(struct buffer_head *bh)\n{\n\tWARN_ON_ONCE(!buffer_uptodate(bh));\n\n\ttrace_block_dirty_buffer(bh);\n\n\t/*\n\t * Very *carefully* optimize the it-is-already-dirty case.\n\t *\n\t * Don't let the final \"is it dirty\" escape to before we\n\t * perhaps modified the buffer.\n\t */\n\tif (buffer_dirty(bh)) {\n\t\tsmp_mb();\n\t\tif (buffer_dirty(bh))\n\t\t\treturn;\n\t}\n\n\tif (!test_set_buffer_dirty(bh)) {\n\t\tstruct page *page = bh->b_page;\n\t\tif (!TestSetPageDirty(page)) {\n\t\t\tstruct address_space *mapping = page_mapping(page);\n\t\t\tif (mapping)\n\t\t\t\t__set_page_dirty(page, mapping, 0);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "J_ASSERT_JH",
          "args": [
            "jh",
            "jh->b_transaction == transaction ||\n\t\t\t\tjh->b_transaction == NULL"
          ],
          "line": 2089
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "J_ASSERT_JH",
          "args": [
            "jh",
            "jh->b_jlist < BJ_Types"
          ],
          "line": 2088
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert_spin_locked",
          "args": [
            "&transaction->t_journal->j_list_lock"
          ],
          "line": 2086
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "J_ASSERT_JH",
          "args": [
            "jh",
            "jbd_is_locked_bh_state(bh)"
          ],
          "line": 2085
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "jbd_is_locked_bh_state",
          "args": [
            "bh"
          ],
          "line": 2085
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "jh2bh",
          "args": [
            "jh"
          ],
          "line": 2083
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/timer.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n\nstatic void __journal_temp_unlink_buffer(struct journal_head *jh);\n\nvoid __journal_file_buffer(struct journal_head *jh,\n\t\t\ttransaction_t *transaction, int jlist)\n{\n\tstruct journal_head **list = NULL;\n\tint was_dirty = 0;\n\tstruct buffer_head *bh = jh2bh(jh);\n\n\tJ_ASSERT_JH(jh, jbd_is_locked_bh_state(bh));\n\tassert_spin_locked(&transaction->t_journal->j_list_lock);\n\n\tJ_ASSERT_JH(jh, jh->b_jlist < BJ_Types);\n\tJ_ASSERT_JH(jh, jh->b_transaction == transaction ||\n\t\t\t\tjh->b_transaction == NULL);\n\n\tif (jh->b_transaction && jh->b_jlist == jlist)\n\t\treturn;\n\n\tif (jlist == BJ_Metadata || jlist == BJ_Reserved ||\n\t    jlist == BJ_Shadow || jlist == BJ_Forget) {\n\t\t/*\n\t\t * For metadata buffers, we track dirty bit in buffer_jbddirty\n\t\t * instead of buffer_dirty. We should not see a dirty bit set\n\t\t * here because we clear it in do_get_write_access but e.g.\n\t\t * tune2fs can modify the sb and set the dirty bit at any time\n\t\t * so we try to gracefully handle that.\n\t\t */\n\t\tif (buffer_dirty(bh))\n\t\t\twarn_dirty_buffer(bh);\n\t\tif (test_clear_buffer_dirty(bh) ||\n\t\t    test_clear_buffer_jbddirty(bh))\n\t\t\twas_dirty = 1;\n\t}\n\n\tif (jh->b_transaction)\n\t\t__journal_temp_unlink_buffer(jh);\n\telse\n\t\tjournal_grab_journal_head(bh);\n\tjh->b_transaction = transaction;\n\n\tswitch (jlist) {\n\tcase BJ_None:\n\t\tJ_ASSERT_JH(jh, !jh->b_committed_data);\n\t\tJ_ASSERT_JH(jh, !jh->b_frozen_data);\n\t\treturn;\n\tcase BJ_SyncData:\n\t\tlist = &transaction->t_sync_datalist;\n\t\tbreak;\n\tcase BJ_Metadata:\n\t\ttransaction->t_nr_buffers++;\n\t\tlist = &transaction->t_buffers;\n\t\tbreak;\n\tcase BJ_Forget:\n\t\tlist = &transaction->t_forget;\n\t\tbreak;\n\tcase BJ_IO:\n\t\tlist = &transaction->t_iobuf_list;\n\t\tbreak;\n\tcase BJ_Shadow:\n\t\tlist = &transaction->t_shadow_list;\n\t\tbreak;\n\tcase BJ_LogCtl:\n\t\tlist = &transaction->t_log_list;\n\t\tbreak;\n\tcase BJ_Reserved:\n\t\tlist = &transaction->t_reserved_list;\n\t\tbreak;\n\tcase BJ_Locked:\n\t\tlist =  &transaction->t_locked_list;\n\t\tbreak;\n\t}\n\n\t__blist_add_buffer(list, jh);\n\tjh->b_jlist = jlist;\n\n\tif (was_dirty)\n\t\tset_buffer_jbddirty(bh);\n}"
  },
  {
    "function_name": "journal_invalidatepage",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd/transaction.c",
    "lines": "2027-2073",
    "snippet": "void journal_invalidatepage(journal_t *journal,\n\t\t      struct page *page,\n\t\t      unsigned int offset,\n\t\t      unsigned int length)\n{\n\tstruct buffer_head *head, *bh, *next;\n\tunsigned int stop = offset + length;\n\tunsigned int curr_off = 0;\n\tint partial_page = (offset || length < PAGE_CACHE_SIZE);\n\tint may_free = 1;\n\n\tif (!PageLocked(page))\n\t\tBUG();\n\tif (!page_has_buffers(page))\n\t\treturn;\n\n\tBUG_ON(stop > PAGE_CACHE_SIZE || stop < length);\n\n\t/* We will potentially be playing with lists other than just the\n\t * data lists (especially for journaled data mode), so be\n\t * cautious in our locking. */\n\n\thead = bh = page_buffers(page);\n\tdo {\n\t\tunsigned int next_off = curr_off + bh->b_size;\n\t\tnext = bh->b_this_page;\n\n\t\tif (next_off > stop)\n\t\t\treturn;\n\n\t\tif (offset <= curr_off) {\n\t\t\t/* This block is wholly outside the truncation point */\n\t\t\tlock_buffer(bh);\n\t\t\tmay_free &= journal_unmap_buffer(journal, bh,\n\t\t\t\t\t\t\t partial_page);\n\t\t\tunlock_buffer(bh);\n\t\t}\n\t\tcurr_off = next_off;\n\t\tbh = next;\n\n\t} while (bh != head);\n\n\tif (!partial_page) {\n\t\tif (may_free && try_to_free_buffers(page))\n\t\t\tJ_ASSERT(!page_has_buffers(page));\n\t}\n}",
    "includes": [
      "#include <linux/hrtimer.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/timer.h>",
      "#include <linux/slab.h>",
      "#include <linux/errno.h>",
      "#include <linux/jbd.h>",
      "#include <linux/fs.h>",
      "#include <linux/time.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "J_ASSERT",
          "args": [
            "!page_has_buffers(page)"
          ],
          "line": 2071
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_has_buffers",
          "args": [
            "page"
          ],
          "line": 2071
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "try_to_free_buffers",
          "args": [
            "page"
          ],
          "line": 2070
        },
        "resolved": true,
        "details": {
          "function_name": "try_to_free_buffers",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "3214-3260",
          "snippet": "int try_to_free_buffers(struct page *page)\n{\n\tstruct address_space * const mapping = page->mapping;\n\tstruct buffer_head *buffers_to_free = NULL;\n\tint ret = 0;\n\n\tBUG_ON(!PageLocked(page));\n\tif (PageWriteback(page))\n\t\treturn 0;\n\n\tif (mapping == NULL) {\t\t/* can this still happen? */\n\t\tret = drop_buffers(page, &buffers_to_free);\n\t\tgoto out;\n\t}\n\n\tspin_lock(&mapping->private_lock);\n\tret = drop_buffers(page, &buffers_to_free);\n\n\t/*\n\t * If the filesystem writes its buffers by hand (eg ext3)\n\t * then we can have clean buffers against a dirty page.  We\n\t * clean the page here; otherwise the VM will never notice\n\t * that the filesystem did any IO at all.\n\t *\n\t * Also, during truncate, discard_buffer will have marked all\n\t * the page's buffers clean.  We discover that here and clean\n\t * the page also.\n\t *\n\t * private_lock must be held over this entire operation in order\n\t * to synchronise against __set_page_dirty_buffers and prevent the\n\t * dirty bit from being lost.\n\t */\n\tif (ret)\n\t\tcancel_dirty_page(page, PAGE_CACHE_SIZE);\n\tspin_unlock(&mapping->private_lock);\nout:\n\tif (buffers_to_free) {\n\t\tstruct buffer_head *bh = buffers_to_free;\n\n\t\tdo {\n\t\t\tstruct buffer_head *next = bh->b_this_page;\n\t\t\tfree_buffer_head(bh);\n\t\t\tbh = next;\n\t\t} while (bh != buffers_to_free);\n\t}\n\treturn ret;\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nint try_to_free_buffers(struct page *page)\n{\n\tstruct address_space * const mapping = page->mapping;\n\tstruct buffer_head *buffers_to_free = NULL;\n\tint ret = 0;\n\n\tBUG_ON(!PageLocked(page));\n\tif (PageWriteback(page))\n\t\treturn 0;\n\n\tif (mapping == NULL) {\t\t/* can this still happen? */\n\t\tret = drop_buffers(page, &buffers_to_free);\n\t\tgoto out;\n\t}\n\n\tspin_lock(&mapping->private_lock);\n\tret = drop_buffers(page, &buffers_to_free);\n\n\t/*\n\t * If the filesystem writes its buffers by hand (eg ext3)\n\t * then we can have clean buffers against a dirty page.  We\n\t * clean the page here; otherwise the VM will never notice\n\t * that the filesystem did any IO at all.\n\t *\n\t * Also, during truncate, discard_buffer will have marked all\n\t * the page's buffers clean.  We discover that here and clean\n\t * the page also.\n\t *\n\t * private_lock must be held over this entire operation in order\n\t * to synchronise against __set_page_dirty_buffers and prevent the\n\t * dirty bit from being lost.\n\t */\n\tif (ret)\n\t\tcancel_dirty_page(page, PAGE_CACHE_SIZE);\n\tspin_unlock(&mapping->private_lock);\nout:\n\tif (buffers_to_free) {\n\t\tstruct buffer_head *bh = buffers_to_free;\n\n\t\tdo {\n\t\t\tstruct buffer_head *next = bh->b_this_page;\n\t\t\tfree_buffer_head(bh);\n\t\t\tbh = next;\n\t\t} while (bh != buffers_to_free);\n\t}\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlock_buffer",
          "args": [
            "bh"
          ],
          "line": 2062
        },
        "resolved": true,
        "details": {
          "function_name": "unlock_buffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "70-75",
          "snippet": "void unlock_buffer(struct buffer_head *bh)\n{\n\tclear_bit_unlock(BH_Lock, &bh->b_state);\n\tsmp_mb__after_atomic();\n\twake_up_bit(&bh->b_state, BH_Lock);\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid unlock_buffer(struct buffer_head *bh)\n{\n\tclear_bit_unlock(BH_Lock, &bh->b_state);\n\tsmp_mb__after_atomic();\n\twake_up_bit(&bh->b_state, BH_Lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "journal_unmap_buffer",
          "args": [
            "journal",
            "bh",
            "partial_page"
          ],
          "line": 2060
        },
        "resolved": true,
        "details": {
          "function_name": "journal_unmap_buffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd/transaction.c",
          "lines": "1845-2016",
          "snippet": "static int journal_unmap_buffer(journal_t *journal, struct buffer_head *bh,\n\t\t\t\tint partial_page)\n{\n\ttransaction_t *transaction;\n\tstruct journal_head *jh;\n\tint may_free = 1;\n\n\tBUFFER_TRACE(bh, \"entry\");\n\nretry:\n\t/*\n\t * It is safe to proceed here without the j_list_lock because the\n\t * buffers cannot be stolen by try_to_free_buffers as long as we are\n\t * holding the page lock. --sct\n\t */\n\n\tif (!buffer_jbd(bh))\n\t\tgoto zap_buffer_unlocked;\n\n\tspin_lock(&journal->j_state_lock);\n\tjbd_lock_bh_state(bh);\n\tspin_lock(&journal->j_list_lock);\n\n\tjh = journal_grab_journal_head(bh);\n\tif (!jh)\n\t\tgoto zap_buffer_no_jh;\n\n\t/*\n\t * We cannot remove the buffer from checkpoint lists until the\n\t * transaction adding inode to orphan list (let's call it T)\n\t * is committed.  Otherwise if the transaction changing the\n\t * buffer would be cleaned from the journal before T is\n\t * committed, a crash will cause that the correct contents of\n\t * the buffer will be lost.  On the other hand we have to\n\t * clear the buffer dirty bit at latest at the moment when the\n\t * transaction marking the buffer as freed in the filesystem\n\t * structures is committed because from that moment on the\n\t * block can be reallocated and used by a different page.\n\t * Since the block hasn't been freed yet but the inode has\n\t * already been added to orphan list, it is safe for us to add\n\t * the buffer to BJ_Forget list of the newest transaction.\n\t *\n\t * Also we have to clear buffer_mapped flag of a truncated buffer\n\t * because the buffer_head may be attached to the page straddling\n\t * i_size (can happen only when blocksize < pagesize) and thus the\n\t * buffer_head can be reused when the file is extended again. So we end\n\t * up keeping around invalidated buffers attached to transactions'\n\t * BJ_Forget list just to stop checkpointing code from cleaning up\n\t * the transaction this buffer was modified in.\n\t */\n\ttransaction = jh->b_transaction;\n\tif (transaction == NULL) {\n\t\t/* First case: not on any transaction.  If it\n\t\t * has no checkpoint link, then we can zap it:\n\t\t * it's a writeback-mode buffer so we don't care\n\t\t * if it hits disk safely. */\n\t\tif (!jh->b_cp_transaction) {\n\t\t\tJBUFFER_TRACE(jh, \"not on any transaction: zap\");\n\t\t\tgoto zap_buffer;\n\t\t}\n\n\t\tif (!buffer_dirty(bh)) {\n\t\t\t/* bdflush has written it.  We can drop it now */\n\t\t\tgoto zap_buffer;\n\t\t}\n\n\t\t/* OK, it must be in the journal but still not\n\t\t * written fully to disk: it's metadata or\n\t\t * journaled data... */\n\n\t\tif (journal->j_running_transaction) {\n\t\t\t/* ... and once the current transaction has\n\t\t\t * committed, the buffer won't be needed any\n\t\t\t * longer. */\n\t\t\tJBUFFER_TRACE(jh, \"checkpointed: add to BJ_Forget\");\n\t\t\tmay_free = __dispose_buffer(jh,\n\t\t\t\t\tjournal->j_running_transaction);\n\t\t\tgoto zap_buffer;\n\t\t} else {\n\t\t\t/* There is no currently-running transaction. So the\n\t\t\t * orphan record which we wrote for this file must have\n\t\t\t * passed into commit.  We must attach this buffer to\n\t\t\t * the committing transaction, if it exists. */\n\t\t\tif (journal->j_committing_transaction) {\n\t\t\t\tJBUFFER_TRACE(jh, \"give to committing trans\");\n\t\t\t\tmay_free = __dispose_buffer(jh,\n\t\t\t\t\tjournal->j_committing_transaction);\n\t\t\t\tgoto zap_buffer;\n\t\t\t} else {\n\t\t\t\t/* The orphan record's transaction has\n\t\t\t\t * committed.  We can cleanse this buffer */\n\t\t\t\tclear_buffer_jbddirty(bh);\n\t\t\t\tgoto zap_buffer;\n\t\t\t}\n\t\t}\n\t} else if (transaction == journal->j_committing_transaction) {\n\t\tJBUFFER_TRACE(jh, \"on committing transaction\");\n\t\tif (jh->b_jlist == BJ_Locked) {\n\t\t\t/*\n\t\t\t * The buffer is on the committing transaction's locked\n\t\t\t * list.  We have the buffer locked, so I/O has\n\t\t\t * completed.  So we can nail the buffer now.\n\t\t\t */\n\t\t\tmay_free = __dispose_buffer(jh, transaction);\n\t\t\tgoto zap_buffer;\n\t\t}\n\t\t/*\n\t\t * The buffer is committing, we simply cannot touch\n\t\t * it. If the page is straddling i_size we have to wait\n\t\t * for commit and try again.\n\t\t */\n\t\tif (partial_page) {\n\t\t\ttid_t tid = journal->j_committing_transaction->t_tid;\n\n\t\t\tjournal_put_journal_head(jh);\n\t\t\tspin_unlock(&journal->j_list_lock);\n\t\t\tjbd_unlock_bh_state(bh);\n\t\t\tspin_unlock(&journal->j_state_lock);\n\t\t\tunlock_buffer(bh);\n\t\t\tlog_wait_commit(journal, tid);\n\t\t\tlock_buffer(bh);\n\t\t\tgoto retry;\n\t\t}\n\t\t/*\n\t\t * OK, buffer won't be reachable after truncate. We just set\n\t\t * j_next_transaction to the running transaction (if there is\n\t\t * one) and mark buffer as freed so that commit code knows it\n\t\t * should clear dirty bits when it is done with the buffer.\n\t\t */\n\t\tset_buffer_freed(bh);\n\t\tif (journal->j_running_transaction && buffer_jbddirty(bh))\n\t\t\tjh->b_next_transaction = journal->j_running_transaction;\n\t\tjournal_put_journal_head(jh);\n\t\tspin_unlock(&journal->j_list_lock);\n\t\tjbd_unlock_bh_state(bh);\n\t\tspin_unlock(&journal->j_state_lock);\n\t\treturn 0;\n\t} else {\n\t\t/* Good, the buffer belongs to the running transaction.\n\t\t * We are writing our own transaction's data, not any\n\t\t * previous one's, so it is safe to throw it away\n\t\t * (remember that we expect the filesystem to have set\n\t\t * i_size already for this truncate so recovery will not\n\t\t * expose the disk blocks we are discarding here.) */\n\t\tJ_ASSERT_JH(jh, transaction == journal->j_running_transaction);\n\t\tJBUFFER_TRACE(jh, \"on running transaction\");\n\t\tmay_free = __dispose_buffer(jh, transaction);\n\t}\n\nzap_buffer:\n\t/*\n\t * This is tricky. Although the buffer is truncated, it may be reused\n\t * if blocksize < pagesize and it is attached to the page straddling\n\t * EOF. Since the buffer might have been added to BJ_Forget list of the\n\t * running transaction, journal_get_write_access() won't clear\n\t * b_modified and credit accounting gets confused. So clear b_modified\n\t * here. */\n\tjh->b_modified = 0;\n\tjournal_put_journal_head(jh);\nzap_buffer_no_jh:\n\tspin_unlock(&journal->j_list_lock);\n\tjbd_unlock_bh_state(bh);\n\tspin_unlock(&journal->j_state_lock);\nzap_buffer_unlocked:\n\tclear_buffer_dirty(bh);\n\tJ_ASSERT_BH(bh, !buffer_jbddirty(bh));\n\tclear_buffer_mapped(bh);\n\tclear_buffer_req(bh);\n\tclear_buffer_new(bh);\n\tbh->b_bdev = NULL;\n\treturn may_free;\n}",
          "includes": [
            "#include <linux/hrtimer.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/timer.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/jbd.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __journal_temp_unlink_buffer(struct journal_head *jh);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/timer.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n\nstatic void __journal_temp_unlink_buffer(struct journal_head *jh);\n\nstatic int journal_unmap_buffer(journal_t *journal, struct buffer_head *bh,\n\t\t\t\tint partial_page)\n{\n\ttransaction_t *transaction;\n\tstruct journal_head *jh;\n\tint may_free = 1;\n\n\tBUFFER_TRACE(bh, \"entry\");\n\nretry:\n\t/*\n\t * It is safe to proceed here without the j_list_lock because the\n\t * buffers cannot be stolen by try_to_free_buffers as long as we are\n\t * holding the page lock. --sct\n\t */\n\n\tif (!buffer_jbd(bh))\n\t\tgoto zap_buffer_unlocked;\n\n\tspin_lock(&journal->j_state_lock);\n\tjbd_lock_bh_state(bh);\n\tspin_lock(&journal->j_list_lock);\n\n\tjh = journal_grab_journal_head(bh);\n\tif (!jh)\n\t\tgoto zap_buffer_no_jh;\n\n\t/*\n\t * We cannot remove the buffer from checkpoint lists until the\n\t * transaction adding inode to orphan list (let's call it T)\n\t * is committed.  Otherwise if the transaction changing the\n\t * buffer would be cleaned from the journal before T is\n\t * committed, a crash will cause that the correct contents of\n\t * the buffer will be lost.  On the other hand we have to\n\t * clear the buffer dirty bit at latest at the moment when the\n\t * transaction marking the buffer as freed in the filesystem\n\t * structures is committed because from that moment on the\n\t * block can be reallocated and used by a different page.\n\t * Since the block hasn't been freed yet but the inode has\n\t * already been added to orphan list, it is safe for us to add\n\t * the buffer to BJ_Forget list of the newest transaction.\n\t *\n\t * Also we have to clear buffer_mapped flag of a truncated buffer\n\t * because the buffer_head may be attached to the page straddling\n\t * i_size (can happen only when blocksize < pagesize) and thus the\n\t * buffer_head can be reused when the file is extended again. So we end\n\t * up keeping around invalidated buffers attached to transactions'\n\t * BJ_Forget list just to stop checkpointing code from cleaning up\n\t * the transaction this buffer was modified in.\n\t */\n\ttransaction = jh->b_transaction;\n\tif (transaction == NULL) {\n\t\t/* First case: not on any transaction.  If it\n\t\t * has no checkpoint link, then we can zap it:\n\t\t * it's a writeback-mode buffer so we don't care\n\t\t * if it hits disk safely. */\n\t\tif (!jh->b_cp_transaction) {\n\t\t\tJBUFFER_TRACE(jh, \"not on any transaction: zap\");\n\t\t\tgoto zap_buffer;\n\t\t}\n\n\t\tif (!buffer_dirty(bh)) {\n\t\t\t/* bdflush has written it.  We can drop it now */\n\t\t\tgoto zap_buffer;\n\t\t}\n\n\t\t/* OK, it must be in the journal but still not\n\t\t * written fully to disk: it's metadata or\n\t\t * journaled data... */\n\n\t\tif (journal->j_running_transaction) {\n\t\t\t/* ... and once the current transaction has\n\t\t\t * committed, the buffer won't be needed any\n\t\t\t * longer. */\n\t\t\tJBUFFER_TRACE(jh, \"checkpointed: add to BJ_Forget\");\n\t\t\tmay_free = __dispose_buffer(jh,\n\t\t\t\t\tjournal->j_running_transaction);\n\t\t\tgoto zap_buffer;\n\t\t} else {\n\t\t\t/* There is no currently-running transaction. So the\n\t\t\t * orphan record which we wrote for this file must have\n\t\t\t * passed into commit.  We must attach this buffer to\n\t\t\t * the committing transaction, if it exists. */\n\t\t\tif (journal->j_committing_transaction) {\n\t\t\t\tJBUFFER_TRACE(jh, \"give to committing trans\");\n\t\t\t\tmay_free = __dispose_buffer(jh,\n\t\t\t\t\tjournal->j_committing_transaction);\n\t\t\t\tgoto zap_buffer;\n\t\t\t} else {\n\t\t\t\t/* The orphan record's transaction has\n\t\t\t\t * committed.  We can cleanse this buffer */\n\t\t\t\tclear_buffer_jbddirty(bh);\n\t\t\t\tgoto zap_buffer;\n\t\t\t}\n\t\t}\n\t} else if (transaction == journal->j_committing_transaction) {\n\t\tJBUFFER_TRACE(jh, \"on committing transaction\");\n\t\tif (jh->b_jlist == BJ_Locked) {\n\t\t\t/*\n\t\t\t * The buffer is on the committing transaction's locked\n\t\t\t * list.  We have the buffer locked, so I/O has\n\t\t\t * completed.  So we can nail the buffer now.\n\t\t\t */\n\t\t\tmay_free = __dispose_buffer(jh, transaction);\n\t\t\tgoto zap_buffer;\n\t\t}\n\t\t/*\n\t\t * The buffer is committing, we simply cannot touch\n\t\t * it. If the page is straddling i_size we have to wait\n\t\t * for commit and try again.\n\t\t */\n\t\tif (partial_page) {\n\t\t\ttid_t tid = journal->j_committing_transaction->t_tid;\n\n\t\t\tjournal_put_journal_head(jh);\n\t\t\tspin_unlock(&journal->j_list_lock);\n\t\t\tjbd_unlock_bh_state(bh);\n\t\t\tspin_unlock(&journal->j_state_lock);\n\t\t\tunlock_buffer(bh);\n\t\t\tlog_wait_commit(journal, tid);\n\t\t\tlock_buffer(bh);\n\t\t\tgoto retry;\n\t\t}\n\t\t/*\n\t\t * OK, buffer won't be reachable after truncate. We just set\n\t\t * j_next_transaction to the running transaction (if there is\n\t\t * one) and mark buffer as freed so that commit code knows it\n\t\t * should clear dirty bits when it is done with the buffer.\n\t\t */\n\t\tset_buffer_freed(bh);\n\t\tif (journal->j_running_transaction && buffer_jbddirty(bh))\n\t\t\tjh->b_next_transaction = journal->j_running_transaction;\n\t\tjournal_put_journal_head(jh);\n\t\tspin_unlock(&journal->j_list_lock);\n\t\tjbd_unlock_bh_state(bh);\n\t\tspin_unlock(&journal->j_state_lock);\n\t\treturn 0;\n\t} else {\n\t\t/* Good, the buffer belongs to the running transaction.\n\t\t * We are writing our own transaction's data, not any\n\t\t * previous one's, so it is safe to throw it away\n\t\t * (remember that we expect the filesystem to have set\n\t\t * i_size already for this truncate so recovery will not\n\t\t * expose the disk blocks we are discarding here.) */\n\t\tJ_ASSERT_JH(jh, transaction == journal->j_running_transaction);\n\t\tJBUFFER_TRACE(jh, \"on running transaction\");\n\t\tmay_free = __dispose_buffer(jh, transaction);\n\t}\n\nzap_buffer:\n\t/*\n\t * This is tricky. Although the buffer is truncated, it may be reused\n\t * if blocksize < pagesize and it is attached to the page straddling\n\t * EOF. Since the buffer might have been added to BJ_Forget list of the\n\t * running transaction, journal_get_write_access() won't clear\n\t * b_modified and credit accounting gets confused. So clear b_modified\n\t * here. */\n\tjh->b_modified = 0;\n\tjournal_put_journal_head(jh);\nzap_buffer_no_jh:\n\tspin_unlock(&journal->j_list_lock);\n\tjbd_unlock_bh_state(bh);\n\tspin_unlock(&journal->j_state_lock);\nzap_buffer_unlocked:\n\tclear_buffer_dirty(bh);\n\tJ_ASSERT_BH(bh, !buffer_jbddirty(bh));\n\tclear_buffer_mapped(bh);\n\tclear_buffer_req(bh);\n\tclear_buffer_new(bh);\n\tbh->b_bdev = NULL;\n\treturn may_free;\n}"
        }
      },
      {
        "call_info": {
          "callee": "page_buffers",
          "args": [
            "page"
          ],
          "line": 2049
        },
        "resolved": true,
        "details": {
          "function_name": "__clear_page_buffers",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "123-129",
          "snippet": "static void\n__clear_page_buffers(struct page *page)\n{\n\tClearPagePrivate(page);\n\tset_page_private(page, 0);\n\tpage_cache_release(page);\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nstatic void\n__clear_page_buffers(struct page *page)\n{\n\tClearPagePrivate(page);\n\tset_page_private(page, 0);\n\tpage_cache_release(page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "stop > PAGE_CACHE_SIZE || stop < length"
          ],
          "line": 2043
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_has_buffers",
          "args": [
            "page"
          ],
          "line": 2040
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG",
          "args": [],
          "line": 2039
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageLocked",
          "args": [
            "page"
          ],
          "line": 2038
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/timer.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n\nvoid journal_invalidatepage(journal_t *journal,\n\t\t      struct page *page,\n\t\t      unsigned int offset,\n\t\t      unsigned int length)\n{\n\tstruct buffer_head *head, *bh, *next;\n\tunsigned int stop = offset + length;\n\tunsigned int curr_off = 0;\n\tint partial_page = (offset || length < PAGE_CACHE_SIZE);\n\tint may_free = 1;\n\n\tif (!PageLocked(page))\n\t\tBUG();\n\tif (!page_has_buffers(page))\n\t\treturn;\n\n\tBUG_ON(stop > PAGE_CACHE_SIZE || stop < length);\n\n\t/* We will potentially be playing with lists other than just the\n\t * data lists (especially for journaled data mode), so be\n\t * cautious in our locking. */\n\n\thead = bh = page_buffers(page);\n\tdo {\n\t\tunsigned int next_off = curr_off + bh->b_size;\n\t\tnext = bh->b_this_page;\n\n\t\tif (next_off > stop)\n\t\t\treturn;\n\n\t\tif (offset <= curr_off) {\n\t\t\t/* This block is wholly outside the truncation point */\n\t\t\tlock_buffer(bh);\n\t\t\tmay_free &= journal_unmap_buffer(journal, bh,\n\t\t\t\t\t\t\t partial_page);\n\t\t\tunlock_buffer(bh);\n\t\t}\n\t\tcurr_off = next_off;\n\t\tbh = next;\n\n\t} while (bh != head);\n\n\tif (!partial_page) {\n\t\tif (may_free && try_to_free_buffers(page))\n\t\t\tJ_ASSERT(!page_has_buffers(page));\n\t}\n}"
  },
  {
    "function_name": "journal_unmap_buffer",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd/transaction.c",
    "lines": "1845-2016",
    "snippet": "static int journal_unmap_buffer(journal_t *journal, struct buffer_head *bh,\n\t\t\t\tint partial_page)\n{\n\ttransaction_t *transaction;\n\tstruct journal_head *jh;\n\tint may_free = 1;\n\n\tBUFFER_TRACE(bh, \"entry\");\n\nretry:\n\t/*\n\t * It is safe to proceed here without the j_list_lock because the\n\t * buffers cannot be stolen by try_to_free_buffers as long as we are\n\t * holding the page lock. --sct\n\t */\n\n\tif (!buffer_jbd(bh))\n\t\tgoto zap_buffer_unlocked;\n\n\tspin_lock(&journal->j_state_lock);\n\tjbd_lock_bh_state(bh);\n\tspin_lock(&journal->j_list_lock);\n\n\tjh = journal_grab_journal_head(bh);\n\tif (!jh)\n\t\tgoto zap_buffer_no_jh;\n\n\t/*\n\t * We cannot remove the buffer from checkpoint lists until the\n\t * transaction adding inode to orphan list (let's call it T)\n\t * is committed.  Otherwise if the transaction changing the\n\t * buffer would be cleaned from the journal before T is\n\t * committed, a crash will cause that the correct contents of\n\t * the buffer will be lost.  On the other hand we have to\n\t * clear the buffer dirty bit at latest at the moment when the\n\t * transaction marking the buffer as freed in the filesystem\n\t * structures is committed because from that moment on the\n\t * block can be reallocated and used by a different page.\n\t * Since the block hasn't been freed yet but the inode has\n\t * already been added to orphan list, it is safe for us to add\n\t * the buffer to BJ_Forget list of the newest transaction.\n\t *\n\t * Also we have to clear buffer_mapped flag of a truncated buffer\n\t * because the buffer_head may be attached to the page straddling\n\t * i_size (can happen only when blocksize < pagesize) and thus the\n\t * buffer_head can be reused when the file is extended again. So we end\n\t * up keeping around invalidated buffers attached to transactions'\n\t * BJ_Forget list just to stop checkpointing code from cleaning up\n\t * the transaction this buffer was modified in.\n\t */\n\ttransaction = jh->b_transaction;\n\tif (transaction == NULL) {\n\t\t/* First case: not on any transaction.  If it\n\t\t * has no checkpoint link, then we can zap it:\n\t\t * it's a writeback-mode buffer so we don't care\n\t\t * if it hits disk safely. */\n\t\tif (!jh->b_cp_transaction) {\n\t\t\tJBUFFER_TRACE(jh, \"not on any transaction: zap\");\n\t\t\tgoto zap_buffer;\n\t\t}\n\n\t\tif (!buffer_dirty(bh)) {\n\t\t\t/* bdflush has written it.  We can drop it now */\n\t\t\tgoto zap_buffer;\n\t\t}\n\n\t\t/* OK, it must be in the journal but still not\n\t\t * written fully to disk: it's metadata or\n\t\t * journaled data... */\n\n\t\tif (journal->j_running_transaction) {\n\t\t\t/* ... and once the current transaction has\n\t\t\t * committed, the buffer won't be needed any\n\t\t\t * longer. */\n\t\t\tJBUFFER_TRACE(jh, \"checkpointed: add to BJ_Forget\");\n\t\t\tmay_free = __dispose_buffer(jh,\n\t\t\t\t\tjournal->j_running_transaction);\n\t\t\tgoto zap_buffer;\n\t\t} else {\n\t\t\t/* There is no currently-running transaction. So the\n\t\t\t * orphan record which we wrote for this file must have\n\t\t\t * passed into commit.  We must attach this buffer to\n\t\t\t * the committing transaction, if it exists. */\n\t\t\tif (journal->j_committing_transaction) {\n\t\t\t\tJBUFFER_TRACE(jh, \"give to committing trans\");\n\t\t\t\tmay_free = __dispose_buffer(jh,\n\t\t\t\t\tjournal->j_committing_transaction);\n\t\t\t\tgoto zap_buffer;\n\t\t\t} else {\n\t\t\t\t/* The orphan record's transaction has\n\t\t\t\t * committed.  We can cleanse this buffer */\n\t\t\t\tclear_buffer_jbddirty(bh);\n\t\t\t\tgoto zap_buffer;\n\t\t\t}\n\t\t}\n\t} else if (transaction == journal->j_committing_transaction) {\n\t\tJBUFFER_TRACE(jh, \"on committing transaction\");\n\t\tif (jh->b_jlist == BJ_Locked) {\n\t\t\t/*\n\t\t\t * The buffer is on the committing transaction's locked\n\t\t\t * list.  We have the buffer locked, so I/O has\n\t\t\t * completed.  So we can nail the buffer now.\n\t\t\t */\n\t\t\tmay_free = __dispose_buffer(jh, transaction);\n\t\t\tgoto zap_buffer;\n\t\t}\n\t\t/*\n\t\t * The buffer is committing, we simply cannot touch\n\t\t * it. If the page is straddling i_size we have to wait\n\t\t * for commit and try again.\n\t\t */\n\t\tif (partial_page) {\n\t\t\ttid_t tid = journal->j_committing_transaction->t_tid;\n\n\t\t\tjournal_put_journal_head(jh);\n\t\t\tspin_unlock(&journal->j_list_lock);\n\t\t\tjbd_unlock_bh_state(bh);\n\t\t\tspin_unlock(&journal->j_state_lock);\n\t\t\tunlock_buffer(bh);\n\t\t\tlog_wait_commit(journal, tid);\n\t\t\tlock_buffer(bh);\n\t\t\tgoto retry;\n\t\t}\n\t\t/*\n\t\t * OK, buffer won't be reachable after truncate. We just set\n\t\t * j_next_transaction to the running transaction (if there is\n\t\t * one) and mark buffer as freed so that commit code knows it\n\t\t * should clear dirty bits when it is done with the buffer.\n\t\t */\n\t\tset_buffer_freed(bh);\n\t\tif (journal->j_running_transaction && buffer_jbddirty(bh))\n\t\t\tjh->b_next_transaction = journal->j_running_transaction;\n\t\tjournal_put_journal_head(jh);\n\t\tspin_unlock(&journal->j_list_lock);\n\t\tjbd_unlock_bh_state(bh);\n\t\tspin_unlock(&journal->j_state_lock);\n\t\treturn 0;\n\t} else {\n\t\t/* Good, the buffer belongs to the running transaction.\n\t\t * We are writing our own transaction's data, not any\n\t\t * previous one's, so it is safe to throw it away\n\t\t * (remember that we expect the filesystem to have set\n\t\t * i_size already for this truncate so recovery will not\n\t\t * expose the disk blocks we are discarding here.) */\n\t\tJ_ASSERT_JH(jh, transaction == journal->j_running_transaction);\n\t\tJBUFFER_TRACE(jh, \"on running transaction\");\n\t\tmay_free = __dispose_buffer(jh, transaction);\n\t}\n\nzap_buffer:\n\t/*\n\t * This is tricky. Although the buffer is truncated, it may be reused\n\t * if blocksize < pagesize and it is attached to the page straddling\n\t * EOF. Since the buffer might have been added to BJ_Forget list of the\n\t * running transaction, journal_get_write_access() won't clear\n\t * b_modified and credit accounting gets confused. So clear b_modified\n\t * here. */\n\tjh->b_modified = 0;\n\tjournal_put_journal_head(jh);\nzap_buffer_no_jh:\n\tspin_unlock(&journal->j_list_lock);\n\tjbd_unlock_bh_state(bh);\n\tspin_unlock(&journal->j_state_lock);\nzap_buffer_unlocked:\n\tclear_buffer_dirty(bh);\n\tJ_ASSERT_BH(bh, !buffer_jbddirty(bh));\n\tclear_buffer_mapped(bh);\n\tclear_buffer_req(bh);\n\tclear_buffer_new(bh);\n\tbh->b_bdev = NULL;\n\treturn may_free;\n}",
    "includes": [
      "#include <linux/hrtimer.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/timer.h>",
      "#include <linux/slab.h>",
      "#include <linux/errno.h>",
      "#include <linux/jbd.h>",
      "#include <linux/fs.h>",
      "#include <linux/time.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void __journal_temp_unlink_buffer(struct journal_head *jh);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "clear_buffer_new",
          "args": [
            "bh"
          ],
          "line": 2013
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clear_buffer_req",
          "args": [
            "bh"
          ],
          "line": 2012
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clear_buffer_mapped",
          "args": [
            "bh"
          ],
          "line": 2011
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "J_ASSERT_BH",
          "args": [
            "bh",
            "!buffer_jbddirty(bh)"
          ],
          "line": 2010
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "buffer_jbddirty",
          "args": [
            "bh"
          ],
          "line": 2010
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clear_buffer_dirty",
          "args": [
            "bh"
          ],
          "line": 2009
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&journal->j_state_lock"
          ],
          "line": 2007
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "jbd_unlock_bh_state",
          "args": [
            "bh"
          ],
          "line": 2006
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "journal_put_journal_head",
          "args": [
            "jh"
          ],
          "line": 2003
        },
        "resolved": true,
        "details": {
          "function_name": "journal_put_journal_head",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd/journal.c",
          "lines": "2020-2033",
          "snippet": "void journal_put_journal_head(struct journal_head *jh)\n{\n\tstruct buffer_head *bh = jh2bh(jh);\n\n\tjbd_lock_bh_journal_head(bh);\n\tJ_ASSERT_JH(jh, jh->b_jcount > 0);\n\t--jh->b_jcount;\n\tif (!jh->b_jcount) {\n\t\t__journal_remove_journal_head(bh);\n\t\tjbd_unlock_bh_journal_head(bh);\n\t\t__brelse(bh);\n\t} else\n\t\tjbd_unlock_bh_journal_head(bh);\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <asm/uaccess.h>",
            "#include <trace/events/jbd.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/poison.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/jbd.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <trace/events/jbd.h>\n#include <linux/ratelimit.h>\n#include <linux/debugfs.h>\n#include <linux/proc_fs.h>\n#include <linux/poison.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/freezer.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nvoid journal_put_journal_head(struct journal_head *jh)\n{\n\tstruct buffer_head *bh = jh2bh(jh);\n\n\tjbd_lock_bh_journal_head(bh);\n\tJ_ASSERT_JH(jh, jh->b_jcount > 0);\n\t--jh->b_jcount;\n\tif (!jh->b_jcount) {\n\t\t__journal_remove_journal_head(bh);\n\t\tjbd_unlock_bh_journal_head(bh);\n\t\t__brelse(bh);\n\t} else\n\t\tjbd_unlock_bh_journal_head(bh);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__dispose_buffer",
          "args": [
            "jh",
            "transaction"
          ],
          "line": 1991
        },
        "resolved": true,
        "details": {
          "function_name": "__dispose_buffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd/transaction.c",
          "lines": "1775-1796",
          "snippet": "static int __dispose_buffer(struct journal_head *jh, transaction_t *transaction)\n{\n\tint may_free = 1;\n\tstruct buffer_head *bh = jh2bh(jh);\n\n\tif (jh->b_cp_transaction) {\n\t\tJBUFFER_TRACE(jh, \"on running+cp transaction\");\n\t\t__journal_temp_unlink_buffer(jh);\n\t\t/*\n\t\t * We don't want to write the buffer anymore, clear the\n\t\t * bit so that we don't confuse checks in\n\t\t * __journal_file_buffer\n\t\t */\n\t\tclear_buffer_dirty(bh);\n\t\t__journal_file_buffer(jh, transaction, BJ_Forget);\n\t\tmay_free = 0;\n\t} else {\n\t\tJBUFFER_TRACE(jh, \"on running transaction\");\n\t\t__journal_unfile_buffer(jh);\n\t}\n\treturn may_free;\n}",
          "includes": [
            "#include <linux/hrtimer.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/timer.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/jbd.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __journal_temp_unlink_buffer(struct journal_head *jh);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/timer.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n\nstatic void __journal_temp_unlink_buffer(struct journal_head *jh);\n\nstatic int __dispose_buffer(struct journal_head *jh, transaction_t *transaction)\n{\n\tint may_free = 1;\n\tstruct buffer_head *bh = jh2bh(jh);\n\n\tif (jh->b_cp_transaction) {\n\t\tJBUFFER_TRACE(jh, \"on running+cp transaction\");\n\t\t__journal_temp_unlink_buffer(jh);\n\t\t/*\n\t\t * We don't want to write the buffer anymore, clear the\n\t\t * bit so that we don't confuse checks in\n\t\t * __journal_file_buffer\n\t\t */\n\t\tclear_buffer_dirty(bh);\n\t\t__journal_file_buffer(jh, transaction, BJ_Forget);\n\t\tmay_free = 0;\n\t} else {\n\t\tJBUFFER_TRACE(jh, \"on running transaction\");\n\t\t__journal_unfile_buffer(jh);\n\t}\n\treturn may_free;\n}"
        }
      },
      {
        "call_info": {
          "callee": "JBUFFER_TRACE",
          "args": [
            "jh",
            "\"on running transaction\""
          ],
          "line": 1990
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "J_ASSERT_JH",
          "args": [
            "jh",
            "transaction == journal->j_running_transaction"
          ],
          "line": 1989
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "jbd_unlock_bh_state",
          "args": [
            "bh"
          ],
          "line": 1979
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "buffer_jbddirty",
          "args": [
            "bh"
          ],
          "line": 1975
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_buffer_freed",
          "args": [
            "bh"
          ],
          "line": 1974
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lock_buffer",
          "args": [
            "bh"
          ],
          "line": 1965
        },
        "resolved": true,
        "details": {
          "function_name": "unlock_buffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "70-75",
          "snippet": "void unlock_buffer(struct buffer_head *bh)\n{\n\tclear_bit_unlock(BH_Lock, &bh->b_state);\n\tsmp_mb__after_atomic();\n\twake_up_bit(&bh->b_state, BH_Lock);\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid unlock_buffer(struct buffer_head *bh)\n{\n\tclear_bit_unlock(BH_Lock, &bh->b_state);\n\tsmp_mb__after_atomic();\n\twake_up_bit(&bh->b_state, BH_Lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "log_wait_commit",
          "args": [
            "journal",
            "tid"
          ],
          "line": 1964
        },
        "resolved": true,
        "details": {
          "function_name": "log_wait_commit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd/journal.c",
          "lines": "569-610",
          "snippet": "int log_wait_commit(journal_t *journal, tid_t tid)\n{\n\tint err = 0;\n\n#ifdef CONFIG_JBD_DEBUG\n\tspin_lock(&journal->j_state_lock);\n\tif (!tid_geq(journal->j_commit_request, tid)) {\n\t\tprintk(KERN_ERR\n\t\t       \"%s: error: j_commit_request=%d, tid=%d\\n\",\n\t\t       __func__, journal->j_commit_request, tid);\n\t}\n\tspin_unlock(&journal->j_state_lock);\n#endif\n\tspin_lock(&journal->j_state_lock);\n\t/*\n\t * Not running or committing trans? Must be already committed. This\n\t * saves us from waiting for a *long* time when tid overflows.\n\t */\n\tif (!((journal->j_running_transaction &&\n\t       journal->j_running_transaction->t_tid == tid) ||\n\t      (journal->j_committing_transaction &&\n\t       journal->j_committing_transaction->t_tid == tid)))\n\t\tgoto out_unlock;\n\n\tif (!tid_geq(journal->j_commit_waited, tid))\n\t\tjournal->j_commit_waited = tid;\n\twhile (tid_gt(tid, journal->j_commit_sequence)) {\n\t\tjbd_debug(1, \"JBD: want %d, j_commit_sequence=%d\\n\",\n\t\t\t\t  tid, journal->j_commit_sequence);\n\t\twake_up(&journal->j_wait_commit);\n\t\tspin_unlock(&journal->j_state_lock);\n\t\twait_event(journal->j_wait_done_commit,\n\t\t\t\t!tid_gt(tid, journal->j_commit_sequence));\n\t\tspin_lock(&journal->j_state_lock);\n\t}\nout_unlock:\n\tspin_unlock(&journal->j_state_lock);\n\n\tif (unlikely(is_journal_aborted(journal)))\n\t\terr = -EIO;\n\treturn err;\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <asm/uaccess.h>",
            "#include <trace/events/jbd.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/poison.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/jbd.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <trace/events/jbd.h>\n#include <linux/ratelimit.h>\n#include <linux/debugfs.h>\n#include <linux/proc_fs.h>\n#include <linux/poison.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/freezer.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nint log_wait_commit(journal_t *journal, tid_t tid)\n{\n\tint err = 0;\n\n#ifdef CONFIG_JBD_DEBUG\n\tspin_lock(&journal->j_state_lock);\n\tif (!tid_geq(journal->j_commit_request, tid)) {\n\t\tprintk(KERN_ERR\n\t\t       \"%s: error: j_commit_request=%d, tid=%d\\n\",\n\t\t       __func__, journal->j_commit_request, tid);\n\t}\n\tspin_unlock(&journal->j_state_lock);\n#endif\n\tspin_lock(&journal->j_state_lock);\n\t/*\n\t * Not running or committing trans? Must be already committed. This\n\t * saves us from waiting for a *long* time when tid overflows.\n\t */\n\tif (!((journal->j_running_transaction &&\n\t       journal->j_running_transaction->t_tid == tid) ||\n\t      (journal->j_committing_transaction &&\n\t       journal->j_committing_transaction->t_tid == tid)))\n\t\tgoto out_unlock;\n\n\tif (!tid_geq(journal->j_commit_waited, tid))\n\t\tjournal->j_commit_waited = tid;\n\twhile (tid_gt(tid, journal->j_commit_sequence)) {\n\t\tjbd_debug(1, \"JBD: want %d, j_commit_sequence=%d\\n\",\n\t\t\t\t  tid, journal->j_commit_sequence);\n\t\twake_up(&journal->j_wait_commit);\n\t\tspin_unlock(&journal->j_state_lock);\n\t\twait_event(journal->j_wait_done_commit,\n\t\t\t\t!tid_gt(tid, journal->j_commit_sequence));\n\t\tspin_lock(&journal->j_state_lock);\n\t}\nout_unlock:\n\tspin_unlock(&journal->j_state_lock);\n\n\tif (unlikely(is_journal_aborted(journal)))\n\t\terr = -EIO;\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "jbd_unlock_bh_state",
          "args": [
            "bh"
          ],
          "line": 1961
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "JBUFFER_TRACE",
          "args": [
            "jh",
            "\"on committing transaction\""
          ],
          "line": 1941
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clear_buffer_jbddirty",
          "args": [
            "bh"
          ],
          "line": 1936
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "JBUFFER_TRACE",
          "args": [
            "jh",
            "\"give to committing trans\""
          ],
          "line": 1929
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "JBUFFER_TRACE",
          "args": [
            "jh",
            "\"checkpointed: add to BJ_Forget\""
          ],
          "line": 1919
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "buffer_dirty",
          "args": [
            "bh"
          ],
          "line": 1906
        },
        "resolved": true,
        "details": {
          "function_name": "mark_buffer_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1141-1167",
          "snippet": "void mark_buffer_dirty(struct buffer_head *bh)\n{\n\tWARN_ON_ONCE(!buffer_uptodate(bh));\n\n\ttrace_block_dirty_buffer(bh);\n\n\t/*\n\t * Very *carefully* optimize the it-is-already-dirty case.\n\t *\n\t * Don't let the final \"is it dirty\" escape to before we\n\t * perhaps modified the buffer.\n\t */\n\tif (buffer_dirty(bh)) {\n\t\tsmp_mb();\n\t\tif (buffer_dirty(bh))\n\t\t\treturn;\n\t}\n\n\tif (!test_set_buffer_dirty(bh)) {\n\t\tstruct page *page = bh->b_page;\n\t\tif (!TestSetPageDirty(page)) {\n\t\t\tstruct address_space *mapping = page_mapping(page);\n\t\t\tif (mapping)\n\t\t\t\t__set_page_dirty(page, mapping, 0);\n\t\t}\n\t}\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid mark_buffer_dirty(struct buffer_head *bh)\n{\n\tWARN_ON_ONCE(!buffer_uptodate(bh));\n\n\ttrace_block_dirty_buffer(bh);\n\n\t/*\n\t * Very *carefully* optimize the it-is-already-dirty case.\n\t *\n\t * Don't let the final \"is it dirty\" escape to before we\n\t * perhaps modified the buffer.\n\t */\n\tif (buffer_dirty(bh)) {\n\t\tsmp_mb();\n\t\tif (buffer_dirty(bh))\n\t\t\treturn;\n\t}\n\n\tif (!test_set_buffer_dirty(bh)) {\n\t\tstruct page *page = bh->b_page;\n\t\tif (!TestSetPageDirty(page)) {\n\t\t\tstruct address_space *mapping = page_mapping(page);\n\t\t\tif (mapping)\n\t\t\t\t__set_page_dirty(page, mapping, 0);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "JBUFFER_TRACE",
          "args": [
            "jh",
            "\"not on any transaction: zap\""
          ],
          "line": 1902
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "journal_grab_journal_head",
          "args": [
            "bh"
          ],
          "line": 1868
        },
        "resolved": true,
        "details": {
          "function_name": "journal_grab_journal_head",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd/journal.c",
          "lines": "1977-1988",
          "snippet": "struct journal_head *journal_grab_journal_head(struct buffer_head *bh)\n{\n\tstruct journal_head *jh = NULL;\n\n\tjbd_lock_bh_journal_head(bh);\n\tif (buffer_jbd(bh)) {\n\t\tjh = bh2jh(bh);\n\t\tjh->b_jcount++;\n\t}\n\tjbd_unlock_bh_journal_head(bh);\n\treturn jh;\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <asm/uaccess.h>",
            "#include <trace/events/jbd.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/poison.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/jbd.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <trace/events/jbd.h>\n#include <linux/ratelimit.h>\n#include <linux/debugfs.h>\n#include <linux/proc_fs.h>\n#include <linux/poison.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/freezer.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nstruct journal_head *journal_grab_journal_head(struct buffer_head *bh)\n{\n\tstruct journal_head *jh = NULL;\n\n\tjbd_lock_bh_journal_head(bh);\n\tif (buffer_jbd(bh)) {\n\t\tjh = bh2jh(bh);\n\t\tjh->b_jcount++;\n\t}\n\tjbd_unlock_bh_journal_head(bh);\n\treturn jh;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&journal->j_list_lock"
          ],
          "line": 1866
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "jbd_lock_bh_state",
          "args": [
            "bh"
          ],
          "line": 1865
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "buffer_jbd",
          "args": [
            "bh"
          ],
          "line": 1861
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUFFER_TRACE",
          "args": [
            "bh",
            "\"entry\""
          ],
          "line": 1852
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/timer.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n\nstatic void __journal_temp_unlink_buffer(struct journal_head *jh);\n\nstatic int journal_unmap_buffer(journal_t *journal, struct buffer_head *bh,\n\t\t\t\tint partial_page)\n{\n\ttransaction_t *transaction;\n\tstruct journal_head *jh;\n\tint may_free = 1;\n\n\tBUFFER_TRACE(bh, \"entry\");\n\nretry:\n\t/*\n\t * It is safe to proceed here without the j_list_lock because the\n\t * buffers cannot be stolen by try_to_free_buffers as long as we are\n\t * holding the page lock. --sct\n\t */\n\n\tif (!buffer_jbd(bh))\n\t\tgoto zap_buffer_unlocked;\n\n\tspin_lock(&journal->j_state_lock);\n\tjbd_lock_bh_state(bh);\n\tspin_lock(&journal->j_list_lock);\n\n\tjh = journal_grab_journal_head(bh);\n\tif (!jh)\n\t\tgoto zap_buffer_no_jh;\n\n\t/*\n\t * We cannot remove the buffer from checkpoint lists until the\n\t * transaction adding inode to orphan list (let's call it T)\n\t * is committed.  Otherwise if the transaction changing the\n\t * buffer would be cleaned from the journal before T is\n\t * committed, a crash will cause that the correct contents of\n\t * the buffer will be lost.  On the other hand we have to\n\t * clear the buffer dirty bit at latest at the moment when the\n\t * transaction marking the buffer as freed in the filesystem\n\t * structures is committed because from that moment on the\n\t * block can be reallocated and used by a different page.\n\t * Since the block hasn't been freed yet but the inode has\n\t * already been added to orphan list, it is safe for us to add\n\t * the buffer to BJ_Forget list of the newest transaction.\n\t *\n\t * Also we have to clear buffer_mapped flag of a truncated buffer\n\t * because the buffer_head may be attached to the page straddling\n\t * i_size (can happen only when blocksize < pagesize) and thus the\n\t * buffer_head can be reused when the file is extended again. So we end\n\t * up keeping around invalidated buffers attached to transactions'\n\t * BJ_Forget list just to stop checkpointing code from cleaning up\n\t * the transaction this buffer was modified in.\n\t */\n\ttransaction = jh->b_transaction;\n\tif (transaction == NULL) {\n\t\t/* First case: not on any transaction.  If it\n\t\t * has no checkpoint link, then we can zap it:\n\t\t * it's a writeback-mode buffer so we don't care\n\t\t * if it hits disk safely. */\n\t\tif (!jh->b_cp_transaction) {\n\t\t\tJBUFFER_TRACE(jh, \"not on any transaction: zap\");\n\t\t\tgoto zap_buffer;\n\t\t}\n\n\t\tif (!buffer_dirty(bh)) {\n\t\t\t/* bdflush has written it.  We can drop it now */\n\t\t\tgoto zap_buffer;\n\t\t}\n\n\t\t/* OK, it must be in the journal but still not\n\t\t * written fully to disk: it's metadata or\n\t\t * journaled data... */\n\n\t\tif (journal->j_running_transaction) {\n\t\t\t/* ... and once the current transaction has\n\t\t\t * committed, the buffer won't be needed any\n\t\t\t * longer. */\n\t\t\tJBUFFER_TRACE(jh, \"checkpointed: add to BJ_Forget\");\n\t\t\tmay_free = __dispose_buffer(jh,\n\t\t\t\t\tjournal->j_running_transaction);\n\t\t\tgoto zap_buffer;\n\t\t} else {\n\t\t\t/* There is no currently-running transaction. So the\n\t\t\t * orphan record which we wrote for this file must have\n\t\t\t * passed into commit.  We must attach this buffer to\n\t\t\t * the committing transaction, if it exists. */\n\t\t\tif (journal->j_committing_transaction) {\n\t\t\t\tJBUFFER_TRACE(jh, \"give to committing trans\");\n\t\t\t\tmay_free = __dispose_buffer(jh,\n\t\t\t\t\tjournal->j_committing_transaction);\n\t\t\t\tgoto zap_buffer;\n\t\t\t} else {\n\t\t\t\t/* The orphan record's transaction has\n\t\t\t\t * committed.  We can cleanse this buffer */\n\t\t\t\tclear_buffer_jbddirty(bh);\n\t\t\t\tgoto zap_buffer;\n\t\t\t}\n\t\t}\n\t} else if (transaction == journal->j_committing_transaction) {\n\t\tJBUFFER_TRACE(jh, \"on committing transaction\");\n\t\tif (jh->b_jlist == BJ_Locked) {\n\t\t\t/*\n\t\t\t * The buffer is on the committing transaction's locked\n\t\t\t * list.  We have the buffer locked, so I/O has\n\t\t\t * completed.  So we can nail the buffer now.\n\t\t\t */\n\t\t\tmay_free = __dispose_buffer(jh, transaction);\n\t\t\tgoto zap_buffer;\n\t\t}\n\t\t/*\n\t\t * The buffer is committing, we simply cannot touch\n\t\t * it. If the page is straddling i_size we have to wait\n\t\t * for commit and try again.\n\t\t */\n\t\tif (partial_page) {\n\t\t\ttid_t tid = journal->j_committing_transaction->t_tid;\n\n\t\t\tjournal_put_journal_head(jh);\n\t\t\tspin_unlock(&journal->j_list_lock);\n\t\t\tjbd_unlock_bh_state(bh);\n\t\t\tspin_unlock(&journal->j_state_lock);\n\t\t\tunlock_buffer(bh);\n\t\t\tlog_wait_commit(journal, tid);\n\t\t\tlock_buffer(bh);\n\t\t\tgoto retry;\n\t\t}\n\t\t/*\n\t\t * OK, buffer won't be reachable after truncate. We just set\n\t\t * j_next_transaction to the running transaction (if there is\n\t\t * one) and mark buffer as freed so that commit code knows it\n\t\t * should clear dirty bits when it is done with the buffer.\n\t\t */\n\t\tset_buffer_freed(bh);\n\t\tif (journal->j_running_transaction && buffer_jbddirty(bh))\n\t\t\tjh->b_next_transaction = journal->j_running_transaction;\n\t\tjournal_put_journal_head(jh);\n\t\tspin_unlock(&journal->j_list_lock);\n\t\tjbd_unlock_bh_state(bh);\n\t\tspin_unlock(&journal->j_state_lock);\n\t\treturn 0;\n\t} else {\n\t\t/* Good, the buffer belongs to the running transaction.\n\t\t * We are writing our own transaction's data, not any\n\t\t * previous one's, so it is safe to throw it away\n\t\t * (remember that we expect the filesystem to have set\n\t\t * i_size already for this truncate so recovery will not\n\t\t * expose the disk blocks we are discarding here.) */\n\t\tJ_ASSERT_JH(jh, transaction == journal->j_running_transaction);\n\t\tJBUFFER_TRACE(jh, \"on running transaction\");\n\t\tmay_free = __dispose_buffer(jh, transaction);\n\t}\n\nzap_buffer:\n\t/*\n\t * This is tricky. Although the buffer is truncated, it may be reused\n\t * if blocksize < pagesize and it is attached to the page straddling\n\t * EOF. Since the buffer might have been added to BJ_Forget list of the\n\t * running transaction, journal_get_write_access() won't clear\n\t * b_modified and credit accounting gets confused. So clear b_modified\n\t * here. */\n\tjh->b_modified = 0;\n\tjournal_put_journal_head(jh);\nzap_buffer_no_jh:\n\tspin_unlock(&journal->j_list_lock);\n\tjbd_unlock_bh_state(bh);\n\tspin_unlock(&journal->j_state_lock);\nzap_buffer_unlocked:\n\tclear_buffer_dirty(bh);\n\tJ_ASSERT_BH(bh, !buffer_jbddirty(bh));\n\tclear_buffer_mapped(bh);\n\tclear_buffer_req(bh);\n\tclear_buffer_new(bh);\n\tbh->b_bdev = NULL;\n\treturn may_free;\n}"
  },
  {
    "function_name": "__dispose_buffer",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd/transaction.c",
    "lines": "1775-1796",
    "snippet": "static int __dispose_buffer(struct journal_head *jh, transaction_t *transaction)\n{\n\tint may_free = 1;\n\tstruct buffer_head *bh = jh2bh(jh);\n\n\tif (jh->b_cp_transaction) {\n\t\tJBUFFER_TRACE(jh, \"on running+cp transaction\");\n\t\t__journal_temp_unlink_buffer(jh);\n\t\t/*\n\t\t * We don't want to write the buffer anymore, clear the\n\t\t * bit so that we don't confuse checks in\n\t\t * __journal_file_buffer\n\t\t */\n\t\tclear_buffer_dirty(bh);\n\t\t__journal_file_buffer(jh, transaction, BJ_Forget);\n\t\tmay_free = 0;\n\t} else {\n\t\tJBUFFER_TRACE(jh, \"on running transaction\");\n\t\t__journal_unfile_buffer(jh);\n\t}\n\treturn may_free;\n}",
    "includes": [
      "#include <linux/hrtimer.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/timer.h>",
      "#include <linux/slab.h>",
      "#include <linux/errno.h>",
      "#include <linux/jbd.h>",
      "#include <linux/fs.h>",
      "#include <linux/time.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void __journal_temp_unlink_buffer(struct journal_head *jh);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "__journal_unfile_buffer",
          "args": [
            "jh"
          ],
          "line": 1793
        },
        "resolved": true,
        "details": {
          "function_name": "__journal_unfile_buffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd/transaction.c",
          "lines": "1630-1635",
          "snippet": "void __journal_unfile_buffer(struct journal_head *jh)\n{\n\t__journal_temp_unlink_buffer(jh);\n\tjh->b_transaction = NULL;\n\tjournal_put_journal_head(jh);\n}",
          "includes": [
            "#include <linux/hrtimer.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/timer.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/jbd.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __journal_temp_unlink_buffer(struct journal_head *jh);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/timer.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n\nstatic void __journal_temp_unlink_buffer(struct journal_head *jh);\n\nvoid __journal_unfile_buffer(struct journal_head *jh)\n{\n\t__journal_temp_unlink_buffer(jh);\n\tjh->b_transaction = NULL;\n\tjournal_put_journal_head(jh);\n}"
        }
      },
      {
        "call_info": {
          "callee": "JBUFFER_TRACE",
          "args": [
            "jh",
            "\"on running transaction\""
          ],
          "line": 1792
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__journal_file_buffer",
          "args": [
            "jh",
            "transaction",
            "BJ_Forget"
          ],
          "line": 1789
        },
        "resolved": true,
        "details": {
          "function_name": "__journal_file_buffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd/transaction.c",
          "lines": "2078-2154",
          "snippet": "void __journal_file_buffer(struct journal_head *jh,\n\t\t\ttransaction_t *transaction, int jlist)\n{\n\tstruct journal_head **list = NULL;\n\tint was_dirty = 0;\n\tstruct buffer_head *bh = jh2bh(jh);\n\n\tJ_ASSERT_JH(jh, jbd_is_locked_bh_state(bh));\n\tassert_spin_locked(&transaction->t_journal->j_list_lock);\n\n\tJ_ASSERT_JH(jh, jh->b_jlist < BJ_Types);\n\tJ_ASSERT_JH(jh, jh->b_transaction == transaction ||\n\t\t\t\tjh->b_transaction == NULL);\n\n\tif (jh->b_transaction && jh->b_jlist == jlist)\n\t\treturn;\n\n\tif (jlist == BJ_Metadata || jlist == BJ_Reserved ||\n\t    jlist == BJ_Shadow || jlist == BJ_Forget) {\n\t\t/*\n\t\t * For metadata buffers, we track dirty bit in buffer_jbddirty\n\t\t * instead of buffer_dirty. We should not see a dirty bit set\n\t\t * here because we clear it in do_get_write_access but e.g.\n\t\t * tune2fs can modify the sb and set the dirty bit at any time\n\t\t * so we try to gracefully handle that.\n\t\t */\n\t\tif (buffer_dirty(bh))\n\t\t\twarn_dirty_buffer(bh);\n\t\tif (test_clear_buffer_dirty(bh) ||\n\t\t    test_clear_buffer_jbddirty(bh))\n\t\t\twas_dirty = 1;\n\t}\n\n\tif (jh->b_transaction)\n\t\t__journal_temp_unlink_buffer(jh);\n\telse\n\t\tjournal_grab_journal_head(bh);\n\tjh->b_transaction = transaction;\n\n\tswitch (jlist) {\n\tcase BJ_None:\n\t\tJ_ASSERT_JH(jh, !jh->b_committed_data);\n\t\tJ_ASSERT_JH(jh, !jh->b_frozen_data);\n\t\treturn;\n\tcase BJ_SyncData:\n\t\tlist = &transaction->t_sync_datalist;\n\t\tbreak;\n\tcase BJ_Metadata:\n\t\ttransaction->t_nr_buffers++;\n\t\tlist = &transaction->t_buffers;\n\t\tbreak;\n\tcase BJ_Forget:\n\t\tlist = &transaction->t_forget;\n\t\tbreak;\n\tcase BJ_IO:\n\t\tlist = &transaction->t_iobuf_list;\n\t\tbreak;\n\tcase BJ_Shadow:\n\t\tlist = &transaction->t_shadow_list;\n\t\tbreak;\n\tcase BJ_LogCtl:\n\t\tlist = &transaction->t_log_list;\n\t\tbreak;\n\tcase BJ_Reserved:\n\t\tlist = &transaction->t_reserved_list;\n\t\tbreak;\n\tcase BJ_Locked:\n\t\tlist =  &transaction->t_locked_list;\n\t\tbreak;\n\t}\n\n\t__blist_add_buffer(list, jh);\n\tjh->b_jlist = jlist;\n\n\tif (was_dirty)\n\t\tset_buffer_jbddirty(bh);\n}",
          "includes": [
            "#include <linux/hrtimer.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/timer.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/jbd.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __journal_temp_unlink_buffer(struct journal_head *jh);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/timer.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n\nstatic void __journal_temp_unlink_buffer(struct journal_head *jh);\n\nvoid __journal_file_buffer(struct journal_head *jh,\n\t\t\ttransaction_t *transaction, int jlist)\n{\n\tstruct journal_head **list = NULL;\n\tint was_dirty = 0;\n\tstruct buffer_head *bh = jh2bh(jh);\n\n\tJ_ASSERT_JH(jh, jbd_is_locked_bh_state(bh));\n\tassert_spin_locked(&transaction->t_journal->j_list_lock);\n\n\tJ_ASSERT_JH(jh, jh->b_jlist < BJ_Types);\n\tJ_ASSERT_JH(jh, jh->b_transaction == transaction ||\n\t\t\t\tjh->b_transaction == NULL);\n\n\tif (jh->b_transaction && jh->b_jlist == jlist)\n\t\treturn;\n\n\tif (jlist == BJ_Metadata || jlist == BJ_Reserved ||\n\t    jlist == BJ_Shadow || jlist == BJ_Forget) {\n\t\t/*\n\t\t * For metadata buffers, we track dirty bit in buffer_jbddirty\n\t\t * instead of buffer_dirty. We should not see a dirty bit set\n\t\t * here because we clear it in do_get_write_access but e.g.\n\t\t * tune2fs can modify the sb and set the dirty bit at any time\n\t\t * so we try to gracefully handle that.\n\t\t */\n\t\tif (buffer_dirty(bh))\n\t\t\twarn_dirty_buffer(bh);\n\t\tif (test_clear_buffer_dirty(bh) ||\n\t\t    test_clear_buffer_jbddirty(bh))\n\t\t\twas_dirty = 1;\n\t}\n\n\tif (jh->b_transaction)\n\t\t__journal_temp_unlink_buffer(jh);\n\telse\n\t\tjournal_grab_journal_head(bh);\n\tjh->b_transaction = transaction;\n\n\tswitch (jlist) {\n\tcase BJ_None:\n\t\tJ_ASSERT_JH(jh, !jh->b_committed_data);\n\t\tJ_ASSERT_JH(jh, !jh->b_frozen_data);\n\t\treturn;\n\tcase BJ_SyncData:\n\t\tlist = &transaction->t_sync_datalist;\n\t\tbreak;\n\tcase BJ_Metadata:\n\t\ttransaction->t_nr_buffers++;\n\t\tlist = &transaction->t_buffers;\n\t\tbreak;\n\tcase BJ_Forget:\n\t\tlist = &transaction->t_forget;\n\t\tbreak;\n\tcase BJ_IO:\n\t\tlist = &transaction->t_iobuf_list;\n\t\tbreak;\n\tcase BJ_Shadow:\n\t\tlist = &transaction->t_shadow_list;\n\t\tbreak;\n\tcase BJ_LogCtl:\n\t\tlist = &transaction->t_log_list;\n\t\tbreak;\n\tcase BJ_Reserved:\n\t\tlist = &transaction->t_reserved_list;\n\t\tbreak;\n\tcase BJ_Locked:\n\t\tlist =  &transaction->t_locked_list;\n\t\tbreak;\n\t}\n\n\t__blist_add_buffer(list, jh);\n\tjh->b_jlist = jlist;\n\n\tif (was_dirty)\n\t\tset_buffer_jbddirty(bh);\n}"
        }
      },
      {
        "call_info": {
          "callee": "clear_buffer_dirty",
          "args": [
            "bh"
          ],
          "line": 1788
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__journal_temp_unlink_buffer",
          "args": [
            "jh"
          ],
          "line": 1782
        },
        "resolved": true,
        "details": {
          "function_name": "__journal_temp_unlink_buffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd/transaction.c",
          "lines": "1571-1621",
          "snippet": "static void __journal_temp_unlink_buffer(struct journal_head *jh)\n{\n\tstruct journal_head **list = NULL;\n\ttransaction_t *transaction;\n\tstruct buffer_head *bh = jh2bh(jh);\n\n\tJ_ASSERT_JH(jh, jbd_is_locked_bh_state(bh));\n\ttransaction = jh->b_transaction;\n\tif (transaction)\n\t\tassert_spin_locked(&transaction->t_journal->j_list_lock);\n\n\tJ_ASSERT_JH(jh, jh->b_jlist < BJ_Types);\n\tif (jh->b_jlist != BJ_None)\n\t\tJ_ASSERT_JH(jh, transaction != NULL);\n\n\tswitch (jh->b_jlist) {\n\tcase BJ_None:\n\t\treturn;\n\tcase BJ_SyncData:\n\t\tlist = &transaction->t_sync_datalist;\n\t\tbreak;\n\tcase BJ_Metadata:\n\t\ttransaction->t_nr_buffers--;\n\t\tJ_ASSERT_JH(jh, transaction->t_nr_buffers >= 0);\n\t\tlist = &transaction->t_buffers;\n\t\tbreak;\n\tcase BJ_Forget:\n\t\tlist = &transaction->t_forget;\n\t\tbreak;\n\tcase BJ_IO:\n\t\tlist = &transaction->t_iobuf_list;\n\t\tbreak;\n\tcase BJ_Shadow:\n\t\tlist = &transaction->t_shadow_list;\n\t\tbreak;\n\tcase BJ_LogCtl:\n\t\tlist = &transaction->t_log_list;\n\t\tbreak;\n\tcase BJ_Reserved:\n\t\tlist = &transaction->t_reserved_list;\n\t\tbreak;\n\tcase BJ_Locked:\n\t\tlist = &transaction->t_locked_list;\n\t\tbreak;\n\t}\n\n\t__blist_del_buffer(list, jh);\n\tjh->b_jlist = BJ_None;\n\tif (test_clear_buffer_jbddirty(bh))\n\t\tmark_buffer_dirty(bh);\t/* Expose it to the VM */\n}",
          "includes": [
            "#include <linux/hrtimer.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/timer.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/jbd.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __journal_temp_unlink_buffer(struct journal_head *jh);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/timer.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n\nstatic void __journal_temp_unlink_buffer(struct journal_head *jh);\n\nstatic void __journal_temp_unlink_buffer(struct journal_head *jh)\n{\n\tstruct journal_head **list = NULL;\n\ttransaction_t *transaction;\n\tstruct buffer_head *bh = jh2bh(jh);\n\n\tJ_ASSERT_JH(jh, jbd_is_locked_bh_state(bh));\n\ttransaction = jh->b_transaction;\n\tif (transaction)\n\t\tassert_spin_locked(&transaction->t_journal->j_list_lock);\n\n\tJ_ASSERT_JH(jh, jh->b_jlist < BJ_Types);\n\tif (jh->b_jlist != BJ_None)\n\t\tJ_ASSERT_JH(jh, transaction != NULL);\n\n\tswitch (jh->b_jlist) {\n\tcase BJ_None:\n\t\treturn;\n\tcase BJ_SyncData:\n\t\tlist = &transaction->t_sync_datalist;\n\t\tbreak;\n\tcase BJ_Metadata:\n\t\ttransaction->t_nr_buffers--;\n\t\tJ_ASSERT_JH(jh, transaction->t_nr_buffers >= 0);\n\t\tlist = &transaction->t_buffers;\n\t\tbreak;\n\tcase BJ_Forget:\n\t\tlist = &transaction->t_forget;\n\t\tbreak;\n\tcase BJ_IO:\n\t\tlist = &transaction->t_iobuf_list;\n\t\tbreak;\n\tcase BJ_Shadow:\n\t\tlist = &transaction->t_shadow_list;\n\t\tbreak;\n\tcase BJ_LogCtl:\n\t\tlist = &transaction->t_log_list;\n\t\tbreak;\n\tcase BJ_Reserved:\n\t\tlist = &transaction->t_reserved_list;\n\t\tbreak;\n\tcase BJ_Locked:\n\t\tlist = &transaction->t_locked_list;\n\t\tbreak;\n\t}\n\n\t__blist_del_buffer(list, jh);\n\tjh->b_jlist = BJ_None;\n\tif (test_clear_buffer_jbddirty(bh))\n\t\tmark_buffer_dirty(bh);\t/* Expose it to the VM */\n}"
        }
      },
      {
        "call_info": {
          "callee": "JBUFFER_TRACE",
          "args": [
            "jh",
            "\"on running+cp transaction\""
          ],
          "line": 1781
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "jh2bh",
          "args": [
            "jh"
          ],
          "line": 1778
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/timer.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n\nstatic void __journal_temp_unlink_buffer(struct journal_head *jh);\n\nstatic int __dispose_buffer(struct journal_head *jh, transaction_t *transaction)\n{\n\tint may_free = 1;\n\tstruct buffer_head *bh = jh2bh(jh);\n\n\tif (jh->b_cp_transaction) {\n\t\tJBUFFER_TRACE(jh, \"on running+cp transaction\");\n\t\t__journal_temp_unlink_buffer(jh);\n\t\t/*\n\t\t * We don't want to write the buffer anymore, clear the\n\t\t * bit so that we don't confuse checks in\n\t\t * __journal_file_buffer\n\t\t */\n\t\tclear_buffer_dirty(bh);\n\t\t__journal_file_buffer(jh, transaction, BJ_Forget);\n\t\tmay_free = 0;\n\t} else {\n\t\tJBUFFER_TRACE(jh, \"on running transaction\");\n\t\t__journal_unfile_buffer(jh);\n\t}\n\treturn may_free;\n}"
  },
  {
    "function_name": "journal_try_to_free_buffers",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd/transaction.c",
    "lines": "1726-1761",
    "snippet": "int journal_try_to_free_buffers(journal_t *journal,\n\t\t\t\tstruct page *page, gfp_t gfp_mask)\n{\n\tstruct buffer_head *head;\n\tstruct buffer_head *bh;\n\tint ret = 0;\n\n\tJ_ASSERT(PageLocked(page));\n\n\thead = page_buffers(page);\n\tbh = head;\n\tdo {\n\t\tstruct journal_head *jh;\n\n\t\t/*\n\t\t * We take our own ref against the journal_head here to avoid\n\t\t * having to add tons of locking around each instance of\n\t\t * journal_put_journal_head().\n\t\t */\n\t\tjh = journal_grab_journal_head(bh);\n\t\tif (!jh)\n\t\t\tcontinue;\n\n\t\tjbd_lock_bh_state(bh);\n\t\t__journal_try_to_free_buffer(journal, bh);\n\t\tjournal_put_journal_head(jh);\n\t\tjbd_unlock_bh_state(bh);\n\t\tif (buffer_jbd(bh))\n\t\t\tgoto busy;\n\t} while ((bh = bh->b_this_page) != head);\n\n\tret = try_to_free_buffers(page);\n\nbusy:\n\treturn ret;\n}",
    "includes": [
      "#include <linux/hrtimer.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/timer.h>",
      "#include <linux/slab.h>",
      "#include <linux/errno.h>",
      "#include <linux/jbd.h>",
      "#include <linux/fs.h>",
      "#include <linux/time.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void __journal_temp_unlink_buffer(struct journal_head *jh);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "try_to_free_buffers",
          "args": [
            "page"
          ],
          "line": 1757
        },
        "resolved": true,
        "details": {
          "function_name": "try_to_free_buffers",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "3214-3260",
          "snippet": "int try_to_free_buffers(struct page *page)\n{\n\tstruct address_space * const mapping = page->mapping;\n\tstruct buffer_head *buffers_to_free = NULL;\n\tint ret = 0;\n\n\tBUG_ON(!PageLocked(page));\n\tif (PageWriteback(page))\n\t\treturn 0;\n\n\tif (mapping == NULL) {\t\t/* can this still happen? */\n\t\tret = drop_buffers(page, &buffers_to_free);\n\t\tgoto out;\n\t}\n\n\tspin_lock(&mapping->private_lock);\n\tret = drop_buffers(page, &buffers_to_free);\n\n\t/*\n\t * If the filesystem writes its buffers by hand (eg ext3)\n\t * then we can have clean buffers against a dirty page.  We\n\t * clean the page here; otherwise the VM will never notice\n\t * that the filesystem did any IO at all.\n\t *\n\t * Also, during truncate, discard_buffer will have marked all\n\t * the page's buffers clean.  We discover that here and clean\n\t * the page also.\n\t *\n\t * private_lock must be held over this entire operation in order\n\t * to synchronise against __set_page_dirty_buffers and prevent the\n\t * dirty bit from being lost.\n\t */\n\tif (ret)\n\t\tcancel_dirty_page(page, PAGE_CACHE_SIZE);\n\tspin_unlock(&mapping->private_lock);\nout:\n\tif (buffers_to_free) {\n\t\tstruct buffer_head *bh = buffers_to_free;\n\n\t\tdo {\n\t\t\tstruct buffer_head *next = bh->b_this_page;\n\t\t\tfree_buffer_head(bh);\n\t\t\tbh = next;\n\t\t} while (bh != buffers_to_free);\n\t}\n\treturn ret;\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nint try_to_free_buffers(struct page *page)\n{\n\tstruct address_space * const mapping = page->mapping;\n\tstruct buffer_head *buffers_to_free = NULL;\n\tint ret = 0;\n\n\tBUG_ON(!PageLocked(page));\n\tif (PageWriteback(page))\n\t\treturn 0;\n\n\tif (mapping == NULL) {\t\t/* can this still happen? */\n\t\tret = drop_buffers(page, &buffers_to_free);\n\t\tgoto out;\n\t}\n\n\tspin_lock(&mapping->private_lock);\n\tret = drop_buffers(page, &buffers_to_free);\n\n\t/*\n\t * If the filesystem writes its buffers by hand (eg ext3)\n\t * then we can have clean buffers against a dirty page.  We\n\t * clean the page here; otherwise the VM will never notice\n\t * that the filesystem did any IO at all.\n\t *\n\t * Also, during truncate, discard_buffer will have marked all\n\t * the page's buffers clean.  We discover that here and clean\n\t * the page also.\n\t *\n\t * private_lock must be held over this entire operation in order\n\t * to synchronise against __set_page_dirty_buffers and prevent the\n\t * dirty bit from being lost.\n\t */\n\tif (ret)\n\t\tcancel_dirty_page(page, PAGE_CACHE_SIZE);\n\tspin_unlock(&mapping->private_lock);\nout:\n\tif (buffers_to_free) {\n\t\tstruct buffer_head *bh = buffers_to_free;\n\n\t\tdo {\n\t\t\tstruct buffer_head *next = bh->b_this_page;\n\t\t\tfree_buffer_head(bh);\n\t\t\tbh = next;\n\t\t} while (bh != buffers_to_free);\n\t}\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "buffer_jbd",
          "args": [
            "bh"
          ],
          "line": 1753
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "jbd_unlock_bh_state",
          "args": [
            "bh"
          ],
          "line": 1752
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "journal_put_journal_head",
          "args": [
            "jh"
          ],
          "line": 1751
        },
        "resolved": true,
        "details": {
          "function_name": "journal_put_journal_head",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd/journal.c",
          "lines": "2020-2033",
          "snippet": "void journal_put_journal_head(struct journal_head *jh)\n{\n\tstruct buffer_head *bh = jh2bh(jh);\n\n\tjbd_lock_bh_journal_head(bh);\n\tJ_ASSERT_JH(jh, jh->b_jcount > 0);\n\t--jh->b_jcount;\n\tif (!jh->b_jcount) {\n\t\t__journal_remove_journal_head(bh);\n\t\tjbd_unlock_bh_journal_head(bh);\n\t\t__brelse(bh);\n\t} else\n\t\tjbd_unlock_bh_journal_head(bh);\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <asm/uaccess.h>",
            "#include <trace/events/jbd.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/poison.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/jbd.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <trace/events/jbd.h>\n#include <linux/ratelimit.h>\n#include <linux/debugfs.h>\n#include <linux/proc_fs.h>\n#include <linux/poison.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/freezer.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nvoid journal_put_journal_head(struct journal_head *jh)\n{\n\tstruct buffer_head *bh = jh2bh(jh);\n\n\tjbd_lock_bh_journal_head(bh);\n\tJ_ASSERT_JH(jh, jh->b_jcount > 0);\n\t--jh->b_jcount;\n\tif (!jh->b_jcount) {\n\t\t__journal_remove_journal_head(bh);\n\t\tjbd_unlock_bh_journal_head(bh);\n\t\t__brelse(bh);\n\t} else\n\t\tjbd_unlock_bh_journal_head(bh);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__journal_try_to_free_buffer",
          "args": [
            "journal",
            "bh"
          ],
          "line": 1750
        },
        "resolved": true,
        "details": {
          "function_name": "__journal_try_to_free_buffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd/transaction.c",
          "lines": "1656-1686",
          "snippet": "static void\n__journal_try_to_free_buffer(journal_t *journal, struct buffer_head *bh)\n{\n\tstruct journal_head *jh;\n\n\tjh = bh2jh(bh);\n\n\tif (buffer_locked(bh) || buffer_dirty(bh))\n\t\tgoto out;\n\n\tif (jh->b_next_transaction != NULL)\n\t\tgoto out;\n\n\tspin_lock(&journal->j_list_lock);\n\tif (jh->b_transaction != NULL && jh->b_cp_transaction == NULL) {\n\t\tif (jh->b_jlist == BJ_SyncData || jh->b_jlist == BJ_Locked) {\n\t\t\t/* A written-back ordered data buffer */\n\t\t\tJBUFFER_TRACE(jh, \"release data\");\n\t\t\t__journal_unfile_buffer(jh);\n\t\t}\n\t} else if (jh->b_cp_transaction != NULL && jh->b_transaction == NULL) {\n\t\t/* written-back checkpointed metadata buffer */\n\t\tif (jh->b_jlist == BJ_None) {\n\t\t\tJBUFFER_TRACE(jh, \"remove from checkpoint list\");\n\t\t\t__journal_remove_checkpoint(jh);\n\t\t}\n\t}\n\tspin_unlock(&journal->j_list_lock);\nout:\n\treturn;\n}",
          "includes": [
            "#include <linux/hrtimer.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/timer.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/jbd.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __journal_temp_unlink_buffer(struct journal_head *jh);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/timer.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n\nstatic void __journal_temp_unlink_buffer(struct journal_head *jh);\n\nstatic void\n__journal_try_to_free_buffer(journal_t *journal, struct buffer_head *bh)\n{\n\tstruct journal_head *jh;\n\n\tjh = bh2jh(bh);\n\n\tif (buffer_locked(bh) || buffer_dirty(bh))\n\t\tgoto out;\n\n\tif (jh->b_next_transaction != NULL)\n\t\tgoto out;\n\n\tspin_lock(&journal->j_list_lock);\n\tif (jh->b_transaction != NULL && jh->b_cp_transaction == NULL) {\n\t\tif (jh->b_jlist == BJ_SyncData || jh->b_jlist == BJ_Locked) {\n\t\t\t/* A written-back ordered data buffer */\n\t\t\tJBUFFER_TRACE(jh, \"release data\");\n\t\t\t__journal_unfile_buffer(jh);\n\t\t}\n\t} else if (jh->b_cp_transaction != NULL && jh->b_transaction == NULL) {\n\t\t/* written-back checkpointed metadata buffer */\n\t\tif (jh->b_jlist == BJ_None) {\n\t\t\tJBUFFER_TRACE(jh, \"remove from checkpoint list\");\n\t\t\t__journal_remove_checkpoint(jh);\n\t\t}\n\t}\n\tspin_unlock(&journal->j_list_lock);\nout:\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "jbd_lock_bh_state",
          "args": [
            "bh"
          ],
          "line": 1749
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "journal_grab_journal_head",
          "args": [
            "bh"
          ],
          "line": 1745
        },
        "resolved": true,
        "details": {
          "function_name": "journal_grab_journal_head",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd/journal.c",
          "lines": "1977-1988",
          "snippet": "struct journal_head *journal_grab_journal_head(struct buffer_head *bh)\n{\n\tstruct journal_head *jh = NULL;\n\n\tjbd_lock_bh_journal_head(bh);\n\tif (buffer_jbd(bh)) {\n\t\tjh = bh2jh(bh);\n\t\tjh->b_jcount++;\n\t}\n\tjbd_unlock_bh_journal_head(bh);\n\treturn jh;\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <asm/uaccess.h>",
            "#include <trace/events/jbd.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/poison.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/jbd.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <trace/events/jbd.h>\n#include <linux/ratelimit.h>\n#include <linux/debugfs.h>\n#include <linux/proc_fs.h>\n#include <linux/poison.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/freezer.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nstruct journal_head *journal_grab_journal_head(struct buffer_head *bh)\n{\n\tstruct journal_head *jh = NULL;\n\n\tjbd_lock_bh_journal_head(bh);\n\tif (buffer_jbd(bh)) {\n\t\tjh = bh2jh(bh);\n\t\tjh->b_jcount++;\n\t}\n\tjbd_unlock_bh_journal_head(bh);\n\treturn jh;\n}"
        }
      },
      {
        "call_info": {
          "callee": "page_buffers",
          "args": [
            "page"
          ],
          "line": 1735
        },
        "resolved": true,
        "details": {
          "function_name": "__clear_page_buffers",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "123-129",
          "snippet": "static void\n__clear_page_buffers(struct page *page)\n{\n\tClearPagePrivate(page);\n\tset_page_private(page, 0);\n\tpage_cache_release(page);\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nstatic void\n__clear_page_buffers(struct page *page)\n{\n\tClearPagePrivate(page);\n\tset_page_private(page, 0);\n\tpage_cache_release(page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "J_ASSERT",
          "args": [
            "PageLocked(page)"
          ],
          "line": 1733
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageLocked",
          "args": [
            "page"
          ],
          "line": 1733
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/timer.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n\nstatic void __journal_temp_unlink_buffer(struct journal_head *jh);\n\nint journal_try_to_free_buffers(journal_t *journal,\n\t\t\t\tstruct page *page, gfp_t gfp_mask)\n{\n\tstruct buffer_head *head;\n\tstruct buffer_head *bh;\n\tint ret = 0;\n\n\tJ_ASSERT(PageLocked(page));\n\n\thead = page_buffers(page);\n\tbh = head;\n\tdo {\n\t\tstruct journal_head *jh;\n\n\t\t/*\n\t\t * We take our own ref against the journal_head here to avoid\n\t\t * having to add tons of locking around each instance of\n\t\t * journal_put_journal_head().\n\t\t */\n\t\tjh = journal_grab_journal_head(bh);\n\t\tif (!jh)\n\t\t\tcontinue;\n\n\t\tjbd_lock_bh_state(bh);\n\t\t__journal_try_to_free_buffer(journal, bh);\n\t\tjournal_put_journal_head(jh);\n\t\tjbd_unlock_bh_state(bh);\n\t\tif (buffer_jbd(bh))\n\t\t\tgoto busy;\n\t} while ((bh = bh->b_this_page) != head);\n\n\tret = try_to_free_buffers(page);\n\nbusy:\n\treturn ret;\n}"
  },
  {
    "function_name": "__journal_try_to_free_buffer",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd/transaction.c",
    "lines": "1656-1686",
    "snippet": "static void\n__journal_try_to_free_buffer(journal_t *journal, struct buffer_head *bh)\n{\n\tstruct journal_head *jh;\n\n\tjh = bh2jh(bh);\n\n\tif (buffer_locked(bh) || buffer_dirty(bh))\n\t\tgoto out;\n\n\tif (jh->b_next_transaction != NULL)\n\t\tgoto out;\n\n\tspin_lock(&journal->j_list_lock);\n\tif (jh->b_transaction != NULL && jh->b_cp_transaction == NULL) {\n\t\tif (jh->b_jlist == BJ_SyncData || jh->b_jlist == BJ_Locked) {\n\t\t\t/* A written-back ordered data buffer */\n\t\t\tJBUFFER_TRACE(jh, \"release data\");\n\t\t\t__journal_unfile_buffer(jh);\n\t\t}\n\t} else if (jh->b_cp_transaction != NULL && jh->b_transaction == NULL) {\n\t\t/* written-back checkpointed metadata buffer */\n\t\tif (jh->b_jlist == BJ_None) {\n\t\t\tJBUFFER_TRACE(jh, \"remove from checkpoint list\");\n\t\t\t__journal_remove_checkpoint(jh);\n\t\t}\n\t}\n\tspin_unlock(&journal->j_list_lock);\nout:\n\treturn;\n}",
    "includes": [
      "#include <linux/hrtimer.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/timer.h>",
      "#include <linux/slab.h>",
      "#include <linux/errno.h>",
      "#include <linux/jbd.h>",
      "#include <linux/fs.h>",
      "#include <linux/time.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void __journal_temp_unlink_buffer(struct journal_head *jh);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&journal->j_list_lock"
          ],
          "line": 1683
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "__journal_remove_checkpoint",
          "args": [
            "jh"
          ],
          "line": 1680
        },
        "resolved": true,
        "details": {
          "function_name": "__journal_remove_checkpoint",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd/checkpoint.c",
          "lines": "665-711",
          "snippet": "int __journal_remove_checkpoint(struct journal_head *jh)\n{\n\ttransaction_t *transaction;\n\tjournal_t *journal;\n\tint ret = 0;\n\n\tJBUFFER_TRACE(jh, \"entry\");\n\n\tif ((transaction = jh->b_cp_transaction) == NULL) {\n\t\tJBUFFER_TRACE(jh, \"not on transaction\");\n\t\tgoto out;\n\t}\n\tjournal = transaction->t_journal;\n\n\tJBUFFER_TRACE(jh, \"removing from transaction\");\n\t__buffer_unlink(jh);\n\tjh->b_cp_transaction = NULL;\n\tjournal_put_journal_head(jh);\n\n\tif (transaction->t_checkpoint_list != NULL ||\n\t    transaction->t_checkpoint_io_list != NULL)\n\t\tgoto out;\n\n\t/*\n\t * There is one special case to worry about: if we have just pulled the\n\t * buffer off a running or committing transaction's checkpoing list,\n\t * then even if the checkpoint list is empty, the transaction obviously\n\t * cannot be dropped!\n\t *\n\t * The locking here around t_state is a bit sleazy.\n\t * See the comment at the end of journal_commit_transaction().\n\t */\n\tif (transaction->t_state != T_FINISHED)\n\t\tgoto out;\n\n\t/* OK, that was the last buffer for the transaction: we can now\n\t   safely remove this transaction from the log */\n\n\t__journal_drop_transaction(journal, transaction);\n\n\t/* Just in case anybody was waiting for more transactions to be\n           checkpointed... */\n\twake_up(&journal->j_wait_logspace);\n\tret = 1;\nout:\n\treturn ret;\n}",
          "includes": [
            "#include <trace/events/jbd.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/jbd.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/jbd.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n\nint __journal_remove_checkpoint(struct journal_head *jh)\n{\n\ttransaction_t *transaction;\n\tjournal_t *journal;\n\tint ret = 0;\n\n\tJBUFFER_TRACE(jh, \"entry\");\n\n\tif ((transaction = jh->b_cp_transaction) == NULL) {\n\t\tJBUFFER_TRACE(jh, \"not on transaction\");\n\t\tgoto out;\n\t}\n\tjournal = transaction->t_journal;\n\n\tJBUFFER_TRACE(jh, \"removing from transaction\");\n\t__buffer_unlink(jh);\n\tjh->b_cp_transaction = NULL;\n\tjournal_put_journal_head(jh);\n\n\tif (transaction->t_checkpoint_list != NULL ||\n\t    transaction->t_checkpoint_io_list != NULL)\n\t\tgoto out;\n\n\t/*\n\t * There is one special case to worry about: if we have just pulled the\n\t * buffer off a running or committing transaction's checkpoing list,\n\t * then even if the checkpoint list is empty, the transaction obviously\n\t * cannot be dropped!\n\t *\n\t * The locking here around t_state is a bit sleazy.\n\t * See the comment at the end of journal_commit_transaction().\n\t */\n\tif (transaction->t_state != T_FINISHED)\n\t\tgoto out;\n\n\t/* OK, that was the last buffer for the transaction: we can now\n\t   safely remove this transaction from the log */\n\n\t__journal_drop_transaction(journal, transaction);\n\n\t/* Just in case anybody was waiting for more transactions to be\n           checkpointed... */\n\twake_up(&journal->j_wait_logspace);\n\tret = 1;\nout:\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "JBUFFER_TRACE",
          "args": [
            "jh",
            "\"remove from checkpoint list\""
          ],
          "line": 1679
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__journal_unfile_buffer",
          "args": [
            "jh"
          ],
          "line": 1674
        },
        "resolved": true,
        "details": {
          "function_name": "__journal_unfile_buffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd/transaction.c",
          "lines": "1630-1635",
          "snippet": "void __journal_unfile_buffer(struct journal_head *jh)\n{\n\t__journal_temp_unlink_buffer(jh);\n\tjh->b_transaction = NULL;\n\tjournal_put_journal_head(jh);\n}",
          "includes": [
            "#include <linux/hrtimer.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/timer.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/jbd.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __journal_temp_unlink_buffer(struct journal_head *jh);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/timer.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n\nstatic void __journal_temp_unlink_buffer(struct journal_head *jh);\n\nvoid __journal_unfile_buffer(struct journal_head *jh)\n{\n\t__journal_temp_unlink_buffer(jh);\n\tjh->b_transaction = NULL;\n\tjournal_put_journal_head(jh);\n}"
        }
      },
      {
        "call_info": {
          "callee": "JBUFFER_TRACE",
          "args": [
            "jh",
            "\"release data\""
          ],
          "line": 1673
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&journal->j_list_lock"
          ],
          "line": 1669
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "buffer_dirty",
          "args": [
            "bh"
          ],
          "line": 1663
        },
        "resolved": true,
        "details": {
          "function_name": "mark_buffer_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1141-1167",
          "snippet": "void mark_buffer_dirty(struct buffer_head *bh)\n{\n\tWARN_ON_ONCE(!buffer_uptodate(bh));\n\n\ttrace_block_dirty_buffer(bh);\n\n\t/*\n\t * Very *carefully* optimize the it-is-already-dirty case.\n\t *\n\t * Don't let the final \"is it dirty\" escape to before we\n\t * perhaps modified the buffer.\n\t */\n\tif (buffer_dirty(bh)) {\n\t\tsmp_mb();\n\t\tif (buffer_dirty(bh))\n\t\t\treturn;\n\t}\n\n\tif (!test_set_buffer_dirty(bh)) {\n\t\tstruct page *page = bh->b_page;\n\t\tif (!TestSetPageDirty(page)) {\n\t\t\tstruct address_space *mapping = page_mapping(page);\n\t\t\tif (mapping)\n\t\t\t\t__set_page_dirty(page, mapping, 0);\n\t\t}\n\t}\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid mark_buffer_dirty(struct buffer_head *bh)\n{\n\tWARN_ON_ONCE(!buffer_uptodate(bh));\n\n\ttrace_block_dirty_buffer(bh);\n\n\t/*\n\t * Very *carefully* optimize the it-is-already-dirty case.\n\t *\n\t * Don't let the final \"is it dirty\" escape to before we\n\t * perhaps modified the buffer.\n\t */\n\tif (buffer_dirty(bh)) {\n\t\tsmp_mb();\n\t\tif (buffer_dirty(bh))\n\t\t\treturn;\n\t}\n\n\tif (!test_set_buffer_dirty(bh)) {\n\t\tstruct page *page = bh->b_page;\n\t\tif (!TestSetPageDirty(page)) {\n\t\t\tstruct address_space *mapping = page_mapping(page);\n\t\t\tif (mapping)\n\t\t\t\t__set_page_dirty(page, mapping, 0);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "buffer_locked",
          "args": [
            "bh"
          ],
          "line": 1663
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bh2jh",
          "args": [
            "bh"
          ],
          "line": 1661
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/timer.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n\nstatic void __journal_temp_unlink_buffer(struct journal_head *jh);\n\nstatic void\n__journal_try_to_free_buffer(journal_t *journal, struct buffer_head *bh)\n{\n\tstruct journal_head *jh;\n\n\tjh = bh2jh(bh);\n\n\tif (buffer_locked(bh) || buffer_dirty(bh))\n\t\tgoto out;\n\n\tif (jh->b_next_transaction != NULL)\n\t\tgoto out;\n\n\tspin_lock(&journal->j_list_lock);\n\tif (jh->b_transaction != NULL && jh->b_cp_transaction == NULL) {\n\t\tif (jh->b_jlist == BJ_SyncData || jh->b_jlist == BJ_Locked) {\n\t\t\t/* A written-back ordered data buffer */\n\t\t\tJBUFFER_TRACE(jh, \"release data\");\n\t\t\t__journal_unfile_buffer(jh);\n\t\t}\n\t} else if (jh->b_cp_transaction != NULL && jh->b_transaction == NULL) {\n\t\t/* written-back checkpointed metadata buffer */\n\t\tif (jh->b_jlist == BJ_None) {\n\t\t\tJBUFFER_TRACE(jh, \"remove from checkpoint list\");\n\t\t\t__journal_remove_checkpoint(jh);\n\t\t}\n\t}\n\tspin_unlock(&journal->j_list_lock);\nout:\n\treturn;\n}"
  },
  {
    "function_name": "journal_unfile_buffer",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd/transaction.c",
    "lines": "1637-1649",
    "snippet": "void journal_unfile_buffer(journal_t *journal, struct journal_head *jh)\n{\n\tstruct buffer_head *bh = jh2bh(jh);\n\n\t/* Get reference so that buffer cannot be freed before we unlock it */\n\tget_bh(bh);\n\tjbd_lock_bh_state(bh);\n\tspin_lock(&journal->j_list_lock);\n\t__journal_unfile_buffer(jh);\n\tspin_unlock(&journal->j_list_lock);\n\tjbd_unlock_bh_state(bh);\n\t__brelse(bh);\n}",
    "includes": [
      "#include <linux/hrtimer.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/timer.h>",
      "#include <linux/slab.h>",
      "#include <linux/errno.h>",
      "#include <linux/jbd.h>",
      "#include <linux/fs.h>",
      "#include <linux/time.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void __journal_temp_unlink_buffer(struct journal_head *jh);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "__brelse",
          "args": [
            "bh"
          ],
          "line": 1648
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "jbd_unlock_bh_state",
          "args": [
            "bh"
          ],
          "line": 1647
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&journal->j_list_lock"
          ],
          "line": 1646
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "__journal_unfile_buffer",
          "args": [
            "jh"
          ],
          "line": 1645
        },
        "resolved": true,
        "details": {
          "function_name": "__journal_unfile_buffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd/transaction.c",
          "lines": "1630-1635",
          "snippet": "void __journal_unfile_buffer(struct journal_head *jh)\n{\n\t__journal_temp_unlink_buffer(jh);\n\tjh->b_transaction = NULL;\n\tjournal_put_journal_head(jh);\n}",
          "includes": [
            "#include <linux/hrtimer.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/timer.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/jbd.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __journal_temp_unlink_buffer(struct journal_head *jh);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/timer.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n\nstatic void __journal_temp_unlink_buffer(struct journal_head *jh);\n\nvoid __journal_unfile_buffer(struct journal_head *jh)\n{\n\t__journal_temp_unlink_buffer(jh);\n\tjh->b_transaction = NULL;\n\tjournal_put_journal_head(jh);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&journal->j_list_lock"
          ],
          "line": 1644
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "jbd_lock_bh_state",
          "args": [
            "bh"
          ],
          "line": 1643
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_bh",
          "args": [
            "bh"
          ],
          "line": 1642
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "jh2bh",
          "args": [
            "jh"
          ],
          "line": 1639
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/timer.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n\nstatic void __journal_temp_unlink_buffer(struct journal_head *jh);\n\nvoid journal_unfile_buffer(journal_t *journal, struct journal_head *jh)\n{\n\tstruct buffer_head *bh = jh2bh(jh);\n\n\t/* Get reference so that buffer cannot be freed before we unlock it */\n\tget_bh(bh);\n\tjbd_lock_bh_state(bh);\n\tspin_lock(&journal->j_list_lock);\n\t__journal_unfile_buffer(jh);\n\tspin_unlock(&journal->j_list_lock);\n\tjbd_unlock_bh_state(bh);\n\t__brelse(bh);\n}"
  },
  {
    "function_name": "__journal_unfile_buffer",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd/transaction.c",
    "lines": "1630-1635",
    "snippet": "void __journal_unfile_buffer(struct journal_head *jh)\n{\n\t__journal_temp_unlink_buffer(jh);\n\tjh->b_transaction = NULL;\n\tjournal_put_journal_head(jh);\n}",
    "includes": [
      "#include <linux/hrtimer.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/timer.h>",
      "#include <linux/slab.h>",
      "#include <linux/errno.h>",
      "#include <linux/jbd.h>",
      "#include <linux/fs.h>",
      "#include <linux/time.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void __journal_temp_unlink_buffer(struct journal_head *jh);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "journal_put_journal_head",
          "args": [
            "jh"
          ],
          "line": 1634
        },
        "resolved": true,
        "details": {
          "function_name": "journal_put_journal_head",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd/journal.c",
          "lines": "2020-2033",
          "snippet": "void journal_put_journal_head(struct journal_head *jh)\n{\n\tstruct buffer_head *bh = jh2bh(jh);\n\n\tjbd_lock_bh_journal_head(bh);\n\tJ_ASSERT_JH(jh, jh->b_jcount > 0);\n\t--jh->b_jcount;\n\tif (!jh->b_jcount) {\n\t\t__journal_remove_journal_head(bh);\n\t\tjbd_unlock_bh_journal_head(bh);\n\t\t__brelse(bh);\n\t} else\n\t\tjbd_unlock_bh_journal_head(bh);\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <asm/uaccess.h>",
            "#include <trace/events/jbd.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/poison.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/jbd.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <trace/events/jbd.h>\n#include <linux/ratelimit.h>\n#include <linux/debugfs.h>\n#include <linux/proc_fs.h>\n#include <linux/poison.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/freezer.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nvoid journal_put_journal_head(struct journal_head *jh)\n{\n\tstruct buffer_head *bh = jh2bh(jh);\n\n\tjbd_lock_bh_journal_head(bh);\n\tJ_ASSERT_JH(jh, jh->b_jcount > 0);\n\t--jh->b_jcount;\n\tif (!jh->b_jcount) {\n\t\t__journal_remove_journal_head(bh);\n\t\tjbd_unlock_bh_journal_head(bh);\n\t\t__brelse(bh);\n\t} else\n\t\tjbd_unlock_bh_journal_head(bh);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__journal_temp_unlink_buffer",
          "args": [
            "jh"
          ],
          "line": 1632
        },
        "resolved": true,
        "details": {
          "function_name": "__journal_temp_unlink_buffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd/transaction.c",
          "lines": "1571-1621",
          "snippet": "static void __journal_temp_unlink_buffer(struct journal_head *jh)\n{\n\tstruct journal_head **list = NULL;\n\ttransaction_t *transaction;\n\tstruct buffer_head *bh = jh2bh(jh);\n\n\tJ_ASSERT_JH(jh, jbd_is_locked_bh_state(bh));\n\ttransaction = jh->b_transaction;\n\tif (transaction)\n\t\tassert_spin_locked(&transaction->t_journal->j_list_lock);\n\n\tJ_ASSERT_JH(jh, jh->b_jlist < BJ_Types);\n\tif (jh->b_jlist != BJ_None)\n\t\tJ_ASSERT_JH(jh, transaction != NULL);\n\n\tswitch (jh->b_jlist) {\n\tcase BJ_None:\n\t\treturn;\n\tcase BJ_SyncData:\n\t\tlist = &transaction->t_sync_datalist;\n\t\tbreak;\n\tcase BJ_Metadata:\n\t\ttransaction->t_nr_buffers--;\n\t\tJ_ASSERT_JH(jh, transaction->t_nr_buffers >= 0);\n\t\tlist = &transaction->t_buffers;\n\t\tbreak;\n\tcase BJ_Forget:\n\t\tlist = &transaction->t_forget;\n\t\tbreak;\n\tcase BJ_IO:\n\t\tlist = &transaction->t_iobuf_list;\n\t\tbreak;\n\tcase BJ_Shadow:\n\t\tlist = &transaction->t_shadow_list;\n\t\tbreak;\n\tcase BJ_LogCtl:\n\t\tlist = &transaction->t_log_list;\n\t\tbreak;\n\tcase BJ_Reserved:\n\t\tlist = &transaction->t_reserved_list;\n\t\tbreak;\n\tcase BJ_Locked:\n\t\tlist = &transaction->t_locked_list;\n\t\tbreak;\n\t}\n\n\t__blist_del_buffer(list, jh);\n\tjh->b_jlist = BJ_None;\n\tif (test_clear_buffer_jbddirty(bh))\n\t\tmark_buffer_dirty(bh);\t/* Expose it to the VM */\n}",
          "includes": [
            "#include <linux/hrtimer.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/timer.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/jbd.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __journal_temp_unlink_buffer(struct journal_head *jh);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/timer.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n\nstatic void __journal_temp_unlink_buffer(struct journal_head *jh);\n\nstatic void __journal_temp_unlink_buffer(struct journal_head *jh)\n{\n\tstruct journal_head **list = NULL;\n\ttransaction_t *transaction;\n\tstruct buffer_head *bh = jh2bh(jh);\n\n\tJ_ASSERT_JH(jh, jbd_is_locked_bh_state(bh));\n\ttransaction = jh->b_transaction;\n\tif (transaction)\n\t\tassert_spin_locked(&transaction->t_journal->j_list_lock);\n\n\tJ_ASSERT_JH(jh, jh->b_jlist < BJ_Types);\n\tif (jh->b_jlist != BJ_None)\n\t\tJ_ASSERT_JH(jh, transaction != NULL);\n\n\tswitch (jh->b_jlist) {\n\tcase BJ_None:\n\t\treturn;\n\tcase BJ_SyncData:\n\t\tlist = &transaction->t_sync_datalist;\n\t\tbreak;\n\tcase BJ_Metadata:\n\t\ttransaction->t_nr_buffers--;\n\t\tJ_ASSERT_JH(jh, transaction->t_nr_buffers >= 0);\n\t\tlist = &transaction->t_buffers;\n\t\tbreak;\n\tcase BJ_Forget:\n\t\tlist = &transaction->t_forget;\n\t\tbreak;\n\tcase BJ_IO:\n\t\tlist = &transaction->t_iobuf_list;\n\t\tbreak;\n\tcase BJ_Shadow:\n\t\tlist = &transaction->t_shadow_list;\n\t\tbreak;\n\tcase BJ_LogCtl:\n\t\tlist = &transaction->t_log_list;\n\t\tbreak;\n\tcase BJ_Reserved:\n\t\tlist = &transaction->t_reserved_list;\n\t\tbreak;\n\tcase BJ_Locked:\n\t\tlist = &transaction->t_locked_list;\n\t\tbreak;\n\t}\n\n\t__blist_del_buffer(list, jh);\n\tjh->b_jlist = BJ_None;\n\tif (test_clear_buffer_jbddirty(bh))\n\t\tmark_buffer_dirty(bh);\t/* Expose it to the VM */\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/timer.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n\nstatic void __journal_temp_unlink_buffer(struct journal_head *jh);\n\nvoid __journal_unfile_buffer(struct journal_head *jh)\n{\n\t__journal_temp_unlink_buffer(jh);\n\tjh->b_transaction = NULL;\n\tjournal_put_journal_head(jh);\n}"
  },
  {
    "function_name": "__journal_temp_unlink_buffer",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd/transaction.c",
    "lines": "1571-1621",
    "snippet": "static void __journal_temp_unlink_buffer(struct journal_head *jh)\n{\n\tstruct journal_head **list = NULL;\n\ttransaction_t *transaction;\n\tstruct buffer_head *bh = jh2bh(jh);\n\n\tJ_ASSERT_JH(jh, jbd_is_locked_bh_state(bh));\n\ttransaction = jh->b_transaction;\n\tif (transaction)\n\t\tassert_spin_locked(&transaction->t_journal->j_list_lock);\n\n\tJ_ASSERT_JH(jh, jh->b_jlist < BJ_Types);\n\tif (jh->b_jlist != BJ_None)\n\t\tJ_ASSERT_JH(jh, transaction != NULL);\n\n\tswitch (jh->b_jlist) {\n\tcase BJ_None:\n\t\treturn;\n\tcase BJ_SyncData:\n\t\tlist = &transaction->t_sync_datalist;\n\t\tbreak;\n\tcase BJ_Metadata:\n\t\ttransaction->t_nr_buffers--;\n\t\tJ_ASSERT_JH(jh, transaction->t_nr_buffers >= 0);\n\t\tlist = &transaction->t_buffers;\n\t\tbreak;\n\tcase BJ_Forget:\n\t\tlist = &transaction->t_forget;\n\t\tbreak;\n\tcase BJ_IO:\n\t\tlist = &transaction->t_iobuf_list;\n\t\tbreak;\n\tcase BJ_Shadow:\n\t\tlist = &transaction->t_shadow_list;\n\t\tbreak;\n\tcase BJ_LogCtl:\n\t\tlist = &transaction->t_log_list;\n\t\tbreak;\n\tcase BJ_Reserved:\n\t\tlist = &transaction->t_reserved_list;\n\t\tbreak;\n\tcase BJ_Locked:\n\t\tlist = &transaction->t_locked_list;\n\t\tbreak;\n\t}\n\n\t__blist_del_buffer(list, jh);\n\tjh->b_jlist = BJ_None;\n\tif (test_clear_buffer_jbddirty(bh))\n\t\tmark_buffer_dirty(bh);\t/* Expose it to the VM */\n}",
    "includes": [
      "#include <linux/hrtimer.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/timer.h>",
      "#include <linux/slab.h>",
      "#include <linux/errno.h>",
      "#include <linux/jbd.h>",
      "#include <linux/fs.h>",
      "#include <linux/time.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void __journal_temp_unlink_buffer(struct journal_head *jh);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mark_buffer_dirty",
          "args": [
            "bh"
          ],
          "line": 1620
        },
        "resolved": true,
        "details": {
          "function_name": "mark_buffer_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1141-1167",
          "snippet": "void mark_buffer_dirty(struct buffer_head *bh)\n{\n\tWARN_ON_ONCE(!buffer_uptodate(bh));\n\n\ttrace_block_dirty_buffer(bh);\n\n\t/*\n\t * Very *carefully* optimize the it-is-already-dirty case.\n\t *\n\t * Don't let the final \"is it dirty\" escape to before we\n\t * perhaps modified the buffer.\n\t */\n\tif (buffer_dirty(bh)) {\n\t\tsmp_mb();\n\t\tif (buffer_dirty(bh))\n\t\t\treturn;\n\t}\n\n\tif (!test_set_buffer_dirty(bh)) {\n\t\tstruct page *page = bh->b_page;\n\t\tif (!TestSetPageDirty(page)) {\n\t\t\tstruct address_space *mapping = page_mapping(page);\n\t\t\tif (mapping)\n\t\t\t\t__set_page_dirty(page, mapping, 0);\n\t\t}\n\t}\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid mark_buffer_dirty(struct buffer_head *bh)\n{\n\tWARN_ON_ONCE(!buffer_uptodate(bh));\n\n\ttrace_block_dirty_buffer(bh);\n\n\t/*\n\t * Very *carefully* optimize the it-is-already-dirty case.\n\t *\n\t * Don't let the final \"is it dirty\" escape to before we\n\t * perhaps modified the buffer.\n\t */\n\tif (buffer_dirty(bh)) {\n\t\tsmp_mb();\n\t\tif (buffer_dirty(bh))\n\t\t\treturn;\n\t}\n\n\tif (!test_set_buffer_dirty(bh)) {\n\t\tstruct page *page = bh->b_page;\n\t\tif (!TestSetPageDirty(page)) {\n\t\t\tstruct address_space *mapping = page_mapping(page);\n\t\t\tif (mapping)\n\t\t\t\t__set_page_dirty(page, mapping, 0);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "test_clear_buffer_jbddirty",
          "args": [
            "bh"
          ],
          "line": 1619
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__blist_del_buffer",
          "args": [
            "list",
            "jh"
          ],
          "line": 1617
        },
        "resolved": true,
        "details": {
          "function_name": "__blist_del_buffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd/transaction.c",
          "lines": "1548-1558",
          "snippet": "static inline void\n__blist_del_buffer(struct journal_head **list, struct journal_head *jh)\n{\n\tif (*list == jh) {\n\t\t*list = jh->b_tnext;\n\t\tif (*list == jh)\n\t\t\t*list = NULL;\n\t}\n\tjh->b_tprev->b_tnext = jh->b_tnext;\n\tjh->b_tnext->b_tprev = jh->b_tprev;\n}",
          "includes": [
            "#include <linux/hrtimer.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/timer.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/jbd.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __journal_temp_unlink_buffer(struct journal_head *jh);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/timer.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n\nstatic void __journal_temp_unlink_buffer(struct journal_head *jh);\n\nstatic inline void\n__blist_del_buffer(struct journal_head **list, struct journal_head *jh)\n{\n\tif (*list == jh) {\n\t\t*list = jh->b_tnext;\n\t\tif (*list == jh)\n\t\t\t*list = NULL;\n\t}\n\tjh->b_tprev->b_tnext = jh->b_tnext;\n\tjh->b_tnext->b_tprev = jh->b_tprev;\n}"
        }
      },
      {
        "call_info": {
          "callee": "J_ASSERT_JH",
          "args": [
            "jh",
            "transaction->t_nr_buffers >= 0"
          ],
          "line": 1594
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "J_ASSERT_JH",
          "args": [
            "jh",
            "transaction != NULL"
          ],
          "line": 1584
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "J_ASSERT_JH",
          "args": [
            "jh",
            "jh->b_jlist < BJ_Types"
          ],
          "line": 1582
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert_spin_locked",
          "args": [
            "&transaction->t_journal->j_list_lock"
          ],
          "line": 1580
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "J_ASSERT_JH",
          "args": [
            "jh",
            "jbd_is_locked_bh_state(bh)"
          ],
          "line": 1577
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "jbd_is_locked_bh_state",
          "args": [
            "bh"
          ],
          "line": 1577
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "jh2bh",
          "args": [
            "jh"
          ],
          "line": 1575
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/timer.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n\nstatic void __journal_temp_unlink_buffer(struct journal_head *jh);\n\nstatic void __journal_temp_unlink_buffer(struct journal_head *jh)\n{\n\tstruct journal_head **list = NULL;\n\ttransaction_t *transaction;\n\tstruct buffer_head *bh = jh2bh(jh);\n\n\tJ_ASSERT_JH(jh, jbd_is_locked_bh_state(bh));\n\ttransaction = jh->b_transaction;\n\tif (transaction)\n\t\tassert_spin_locked(&transaction->t_journal->j_list_lock);\n\n\tJ_ASSERT_JH(jh, jh->b_jlist < BJ_Types);\n\tif (jh->b_jlist != BJ_None)\n\t\tJ_ASSERT_JH(jh, transaction != NULL);\n\n\tswitch (jh->b_jlist) {\n\tcase BJ_None:\n\t\treturn;\n\tcase BJ_SyncData:\n\t\tlist = &transaction->t_sync_datalist;\n\t\tbreak;\n\tcase BJ_Metadata:\n\t\ttransaction->t_nr_buffers--;\n\t\tJ_ASSERT_JH(jh, transaction->t_nr_buffers >= 0);\n\t\tlist = &transaction->t_buffers;\n\t\tbreak;\n\tcase BJ_Forget:\n\t\tlist = &transaction->t_forget;\n\t\tbreak;\n\tcase BJ_IO:\n\t\tlist = &transaction->t_iobuf_list;\n\t\tbreak;\n\tcase BJ_Shadow:\n\t\tlist = &transaction->t_shadow_list;\n\t\tbreak;\n\tcase BJ_LogCtl:\n\t\tlist = &transaction->t_log_list;\n\t\tbreak;\n\tcase BJ_Reserved:\n\t\tlist = &transaction->t_reserved_list;\n\t\tbreak;\n\tcase BJ_Locked:\n\t\tlist = &transaction->t_locked_list;\n\t\tbreak;\n\t}\n\n\t__blist_del_buffer(list, jh);\n\tjh->b_jlist = BJ_None;\n\tif (test_clear_buffer_jbddirty(bh))\n\t\tmark_buffer_dirty(bh);\t/* Expose it to the VM */\n}"
  },
  {
    "function_name": "__blist_del_buffer",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd/transaction.c",
    "lines": "1548-1558",
    "snippet": "static inline void\n__blist_del_buffer(struct journal_head **list, struct journal_head *jh)\n{\n\tif (*list == jh) {\n\t\t*list = jh->b_tnext;\n\t\tif (*list == jh)\n\t\t\t*list = NULL;\n\t}\n\tjh->b_tprev->b_tnext = jh->b_tnext;\n\tjh->b_tnext->b_tprev = jh->b_tprev;\n}",
    "includes": [
      "#include <linux/hrtimer.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/timer.h>",
      "#include <linux/slab.h>",
      "#include <linux/errno.h>",
      "#include <linux/jbd.h>",
      "#include <linux/fs.h>",
      "#include <linux/time.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void __journal_temp_unlink_buffer(struct journal_head *jh);"
    ],
    "called_functions": [],
    "contextual_snippet": "#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/timer.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n\nstatic void __journal_temp_unlink_buffer(struct journal_head *jh);\n\nstatic inline void\n__blist_del_buffer(struct journal_head **list, struct journal_head *jh)\n{\n\tif (*list == jh) {\n\t\t*list = jh->b_tnext;\n\t\tif (*list == jh)\n\t\t\t*list = NULL;\n\t}\n\tjh->b_tprev->b_tnext = jh->b_tnext;\n\tjh->b_tnext->b_tprev = jh->b_tprev;\n}"
  },
  {
    "function_name": "__blist_add_buffer",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd/transaction.c",
    "lines": "1524-1537",
    "snippet": "static inline void\n__blist_add_buffer(struct journal_head **list, struct journal_head *jh)\n{\n\tif (!*list) {\n\t\tjh->b_tnext = jh->b_tprev = jh;\n\t\t*list = jh;\n\t} else {\n\t\t/* Insert at the tail of the list to preserve order */\n\t\tstruct journal_head *first = *list, *last = first->b_tprev;\n\t\tjh->b_tprev = last;\n\t\tjh->b_tnext = first;\n\t\tlast->b_tnext = first->b_tprev = jh;\n\t}\n}",
    "includes": [
      "#include <linux/hrtimer.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/timer.h>",
      "#include <linux/slab.h>",
      "#include <linux/errno.h>",
      "#include <linux/jbd.h>",
      "#include <linux/fs.h>",
      "#include <linux/time.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void __journal_temp_unlink_buffer(struct journal_head *jh);"
    ],
    "called_functions": [],
    "contextual_snippet": "#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/timer.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n\nstatic void __journal_temp_unlink_buffer(struct journal_head *jh);\n\nstatic inline void\n__blist_add_buffer(struct journal_head **list, struct journal_head *jh)\n{\n\tif (!*list) {\n\t\tjh->b_tnext = jh->b_tprev = jh;\n\t\t*list = jh;\n\t} else {\n\t\t/* Insert at the tail of the list to preserve order */\n\t\tstruct journal_head *first = *list, *last = first->b_tprev;\n\t\tjh->b_tprev = last;\n\t\tjh->b_tnext = first;\n\t\tlast->b_tnext = first->b_tprev = jh;\n\t}\n}"
  },
  {
    "function_name": "journal_force_commit",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd/transaction.c",
    "lines": "1493-1506",
    "snippet": "int journal_force_commit(journal_t *journal)\n{\n\thandle_t *handle;\n\tint ret;\n\n\thandle = journal_start(journal, 1);\n\tif (IS_ERR(handle)) {\n\t\tret = PTR_ERR(handle);\n\t} else {\n\t\thandle->h_sync = 1;\n\t\tret = journal_stop(handle);\n\t}\n\treturn ret;\n}",
    "includes": [
      "#include <linux/hrtimer.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/timer.h>",
      "#include <linux/slab.h>",
      "#include <linux/errno.h>",
      "#include <linux/jbd.h>",
      "#include <linux/fs.h>",
      "#include <linux/time.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "journal_stop",
          "args": [
            "handle"
          ],
          "line": 1503
        },
        "resolved": true,
        "details": {
          "function_name": "journal_stop",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd/transaction.c",
          "lines": "1362-1483",
          "snippet": "int journal_stop(handle_t *handle)\n{\n\ttransaction_t *transaction = handle->h_transaction;\n\tjournal_t *journal = transaction->t_journal;\n\tint err;\n\tpid_t pid;\n\n\tJ_ASSERT(journal_current_handle() == handle);\n\n\tif (is_handle_aborted(handle))\n\t\terr = -EIO;\n\telse {\n\t\tJ_ASSERT(transaction->t_updates > 0);\n\t\terr = 0;\n\t}\n\n\tif (--handle->h_ref > 0) {\n\t\tjbd_debug(4, \"h_ref %d -> %d\\n\", handle->h_ref + 1,\n\t\t\t  handle->h_ref);\n\t\treturn err;\n\t}\n\n\tjbd_debug(4, \"Handle %p going down\\n\", handle);\n\n\t/*\n\t * Implement synchronous transaction batching.  If the handle\n\t * was synchronous, don't force a commit immediately.  Let's\n\t * yield and let another thread piggyback onto this transaction.\n\t * Keep doing that while new threads continue to arrive.\n\t * It doesn't cost much - we're about to run a commit and sleep\n\t * on IO anyway.  Speeds up many-threaded, many-dir operations\n\t * by 30x or more...\n\t *\n\t * We try and optimize the sleep time against what the underlying disk\n\t * can do, instead of having a static sleep time.  This is useful for\n\t * the case where our storage is so fast that it is more optimal to go\n\t * ahead and force a flush and wait for the transaction to be committed\n\t * than it is to wait for an arbitrary amount of time for new writers to\n\t * join the transaction.  We achieve this by measuring how long it takes\n\t * to commit a transaction, and compare it with how long this\n\t * transaction has been running, and if run time < commit time then we\n\t * sleep for the delta and commit.  This greatly helps super fast disks\n\t * that would see slowdowns as more threads started doing fsyncs.\n\t *\n\t * But don't do this if this process was the most recent one to\n\t * perform a synchronous write.  We do this to detect the case where a\n\t * single process is doing a stream of sync writes.  No point in waiting\n\t * for joiners in that case.\n\t */\n\tpid = current->pid;\n\tif (handle->h_sync && journal->j_last_sync_writer != pid) {\n\t\tu64 commit_time, trans_time;\n\n\t\tjournal->j_last_sync_writer = pid;\n\n\t\tspin_lock(&journal->j_state_lock);\n\t\tcommit_time = journal->j_average_commit_time;\n\t\tspin_unlock(&journal->j_state_lock);\n\n\t\ttrans_time = ktime_to_ns(ktime_sub(ktime_get(),\n\t\t\t\t\t\t   transaction->t_start_time));\n\n\t\tcommit_time = min_t(u64, commit_time,\n\t\t\t\t    1000*jiffies_to_usecs(1));\n\n\t\tif (trans_time < commit_time) {\n\t\t\tktime_t expires = ktime_add_ns(ktime_get(),\n\t\t\t\t\t\t       commit_time);\n\t\t\tset_current_state(TASK_UNINTERRUPTIBLE);\n\t\t\tschedule_hrtimeout(&expires, HRTIMER_MODE_ABS);\n\t\t}\n\t}\n\n\tcurrent->journal_info = NULL;\n\tspin_lock(&journal->j_state_lock);\n\tspin_lock(&transaction->t_handle_lock);\n\ttransaction->t_outstanding_credits -= handle->h_buffer_credits;\n\ttransaction->t_updates--;\n\tif (!transaction->t_updates) {\n\t\twake_up(&journal->j_wait_updates);\n\t\tif (journal->j_barrier_count)\n\t\t\twake_up(&journal->j_wait_transaction_locked);\n\t}\n\n\t/*\n\t * If the handle is marked SYNC, we need to set another commit\n\t * going!  We also want to force a commit if the current\n\t * transaction is occupying too much of the log, or if the\n\t * transaction is too old now.\n\t */\n\tif (handle->h_sync ||\n\t\t\ttransaction->t_outstanding_credits >\n\t\t\t\tjournal->j_max_transaction_buffers ||\n\t\t\ttime_after_eq(jiffies, transaction->t_expires)) {\n\t\t/* Do this even for aborted journals: an abort still\n\t\t * completes the commit thread, it just doesn't write\n\t\t * anything to disk. */\n\t\ttid_t tid = transaction->t_tid;\n\n\t\tspin_unlock(&transaction->t_handle_lock);\n\t\tjbd_debug(2, \"transaction too old, requesting commit for \"\n\t\t\t\t\t\"handle %p\\n\", handle);\n\t\t/* This is non-blocking */\n\t\t__log_start_commit(journal, transaction->t_tid);\n\t\tspin_unlock(&journal->j_state_lock);\n\n\t\t/*\n\t\t * Special case: JFS_SYNC synchronous updates require us\n\t\t * to wait for the commit to complete.\n\t\t */\n\t\tif (handle->h_sync && !(current->flags & PF_MEMALLOC))\n\t\t\terr = log_wait_commit(journal, tid);\n\t} else {\n\t\tspin_unlock(&transaction->t_handle_lock);\n\t\tspin_unlock(&journal->j_state_lock);\n\t}\n\n\tlock_map_release(&handle->h_lockdep_map);\n\n\tjbd_free_handle(handle);\n\treturn err;\n}",
          "includes": [
            "#include <linux/hrtimer.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/timer.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/jbd.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/timer.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n\nint journal_stop(handle_t *handle)\n{\n\ttransaction_t *transaction = handle->h_transaction;\n\tjournal_t *journal = transaction->t_journal;\n\tint err;\n\tpid_t pid;\n\n\tJ_ASSERT(journal_current_handle() == handle);\n\n\tif (is_handle_aborted(handle))\n\t\terr = -EIO;\n\telse {\n\t\tJ_ASSERT(transaction->t_updates > 0);\n\t\terr = 0;\n\t}\n\n\tif (--handle->h_ref > 0) {\n\t\tjbd_debug(4, \"h_ref %d -> %d\\n\", handle->h_ref + 1,\n\t\t\t  handle->h_ref);\n\t\treturn err;\n\t}\n\n\tjbd_debug(4, \"Handle %p going down\\n\", handle);\n\n\t/*\n\t * Implement synchronous transaction batching.  If the handle\n\t * was synchronous, don't force a commit immediately.  Let's\n\t * yield and let another thread piggyback onto this transaction.\n\t * Keep doing that while new threads continue to arrive.\n\t * It doesn't cost much - we're about to run a commit and sleep\n\t * on IO anyway.  Speeds up many-threaded, many-dir operations\n\t * by 30x or more...\n\t *\n\t * We try and optimize the sleep time against what the underlying disk\n\t * can do, instead of having a static sleep time.  This is useful for\n\t * the case where our storage is so fast that it is more optimal to go\n\t * ahead and force a flush and wait for the transaction to be committed\n\t * than it is to wait for an arbitrary amount of time for new writers to\n\t * join the transaction.  We achieve this by measuring how long it takes\n\t * to commit a transaction, and compare it with how long this\n\t * transaction has been running, and if run time < commit time then we\n\t * sleep for the delta and commit.  This greatly helps super fast disks\n\t * that would see slowdowns as more threads started doing fsyncs.\n\t *\n\t * But don't do this if this process was the most recent one to\n\t * perform a synchronous write.  We do this to detect the case where a\n\t * single process is doing a stream of sync writes.  No point in waiting\n\t * for joiners in that case.\n\t */\n\tpid = current->pid;\n\tif (handle->h_sync && journal->j_last_sync_writer != pid) {\n\t\tu64 commit_time, trans_time;\n\n\t\tjournal->j_last_sync_writer = pid;\n\n\t\tspin_lock(&journal->j_state_lock);\n\t\tcommit_time = journal->j_average_commit_time;\n\t\tspin_unlock(&journal->j_state_lock);\n\n\t\ttrans_time = ktime_to_ns(ktime_sub(ktime_get(),\n\t\t\t\t\t\t   transaction->t_start_time));\n\n\t\tcommit_time = min_t(u64, commit_time,\n\t\t\t\t    1000*jiffies_to_usecs(1));\n\n\t\tif (trans_time < commit_time) {\n\t\t\tktime_t expires = ktime_add_ns(ktime_get(),\n\t\t\t\t\t\t       commit_time);\n\t\t\tset_current_state(TASK_UNINTERRUPTIBLE);\n\t\t\tschedule_hrtimeout(&expires, HRTIMER_MODE_ABS);\n\t\t}\n\t}\n\n\tcurrent->journal_info = NULL;\n\tspin_lock(&journal->j_state_lock);\n\tspin_lock(&transaction->t_handle_lock);\n\ttransaction->t_outstanding_credits -= handle->h_buffer_credits;\n\ttransaction->t_updates--;\n\tif (!transaction->t_updates) {\n\t\twake_up(&journal->j_wait_updates);\n\t\tif (journal->j_barrier_count)\n\t\t\twake_up(&journal->j_wait_transaction_locked);\n\t}\n\n\t/*\n\t * If the handle is marked SYNC, we need to set another commit\n\t * going!  We also want to force a commit if the current\n\t * transaction is occupying too much of the log, or if the\n\t * transaction is too old now.\n\t */\n\tif (handle->h_sync ||\n\t\t\ttransaction->t_outstanding_credits >\n\t\t\t\tjournal->j_max_transaction_buffers ||\n\t\t\ttime_after_eq(jiffies, transaction->t_expires)) {\n\t\t/* Do this even for aborted journals: an abort still\n\t\t * completes the commit thread, it just doesn't write\n\t\t * anything to disk. */\n\t\ttid_t tid = transaction->t_tid;\n\n\t\tspin_unlock(&transaction->t_handle_lock);\n\t\tjbd_debug(2, \"transaction too old, requesting commit for \"\n\t\t\t\t\t\"handle %p\\n\", handle);\n\t\t/* This is non-blocking */\n\t\t__log_start_commit(journal, transaction->t_tid);\n\t\tspin_unlock(&journal->j_state_lock);\n\n\t\t/*\n\t\t * Special case: JFS_SYNC synchronous updates require us\n\t\t * to wait for the commit to complete.\n\t\t */\n\t\tif (handle->h_sync && !(current->flags & PF_MEMALLOC))\n\t\t\terr = log_wait_commit(journal, tid);\n\t} else {\n\t\tspin_unlock(&transaction->t_handle_lock);\n\t\tspin_unlock(&journal->j_state_lock);\n\t}\n\n\tlock_map_release(&handle->h_lockdep_map);\n\n\tjbd_free_handle(handle);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "handle"
          ],
          "line": 1500
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "handle"
          ],
          "line": 1499
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "journal_start",
          "args": [
            "journal",
            "1"
          ],
          "line": 1498
        },
        "resolved": true,
        "details": {
          "function_name": "journal_start",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd/transaction.c",
          "lines": "271-298",
          "snippet": "handle_t *journal_start(journal_t *journal, int nblocks)\n{\n\thandle_t *handle = journal_current_handle();\n\tint err;\n\n\tif (!journal)\n\t\treturn ERR_PTR(-EROFS);\n\n\tif (handle) {\n\t\tJ_ASSERT(handle->h_transaction->t_journal == journal);\n\t\thandle->h_ref++;\n\t\treturn handle;\n\t}\n\n\thandle = new_handle(nblocks);\n\tif (!handle)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tcurrent->journal_info = handle;\n\n\terr = start_this_handle(journal, handle);\n\tif (err < 0) {\n\t\tjbd_free_handle(handle);\n\t\tcurrent->journal_info = NULL;\n\t\thandle = ERR_PTR(err);\n\t}\n\treturn handle;\n}",
          "includes": [
            "#include <linux/hrtimer.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/timer.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/jbd.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/timer.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n\nhandle_t *journal_start(journal_t *journal, int nblocks)\n{\n\thandle_t *handle = journal_current_handle();\n\tint err;\n\n\tif (!journal)\n\t\treturn ERR_PTR(-EROFS);\n\n\tif (handle) {\n\t\tJ_ASSERT(handle->h_transaction->t_journal == journal);\n\t\thandle->h_ref++;\n\t\treturn handle;\n\t}\n\n\thandle = new_handle(nblocks);\n\tif (!handle)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tcurrent->journal_info = handle;\n\n\terr = start_this_handle(journal, handle);\n\tif (err < 0) {\n\t\tjbd_free_handle(handle);\n\t\tcurrent->journal_info = NULL;\n\t\thandle = ERR_PTR(err);\n\t}\n\treturn handle;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/timer.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n\nint journal_force_commit(journal_t *journal)\n{\n\thandle_t *handle;\n\tint ret;\n\n\thandle = journal_start(journal, 1);\n\tif (IS_ERR(handle)) {\n\t\tret = PTR_ERR(handle);\n\t} else {\n\t\thandle->h_sync = 1;\n\t\tret = journal_stop(handle);\n\t}\n\treturn ret;\n}"
  },
  {
    "function_name": "journal_stop",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd/transaction.c",
    "lines": "1362-1483",
    "snippet": "int journal_stop(handle_t *handle)\n{\n\ttransaction_t *transaction = handle->h_transaction;\n\tjournal_t *journal = transaction->t_journal;\n\tint err;\n\tpid_t pid;\n\n\tJ_ASSERT(journal_current_handle() == handle);\n\n\tif (is_handle_aborted(handle))\n\t\terr = -EIO;\n\telse {\n\t\tJ_ASSERT(transaction->t_updates > 0);\n\t\terr = 0;\n\t}\n\n\tif (--handle->h_ref > 0) {\n\t\tjbd_debug(4, \"h_ref %d -> %d\\n\", handle->h_ref + 1,\n\t\t\t  handle->h_ref);\n\t\treturn err;\n\t}\n\n\tjbd_debug(4, \"Handle %p going down\\n\", handle);\n\n\t/*\n\t * Implement synchronous transaction batching.  If the handle\n\t * was synchronous, don't force a commit immediately.  Let's\n\t * yield and let another thread piggyback onto this transaction.\n\t * Keep doing that while new threads continue to arrive.\n\t * It doesn't cost much - we're about to run a commit and sleep\n\t * on IO anyway.  Speeds up many-threaded, many-dir operations\n\t * by 30x or more...\n\t *\n\t * We try and optimize the sleep time against what the underlying disk\n\t * can do, instead of having a static sleep time.  This is useful for\n\t * the case where our storage is so fast that it is more optimal to go\n\t * ahead and force a flush and wait for the transaction to be committed\n\t * than it is to wait for an arbitrary amount of time for new writers to\n\t * join the transaction.  We achieve this by measuring how long it takes\n\t * to commit a transaction, and compare it with how long this\n\t * transaction has been running, and if run time < commit time then we\n\t * sleep for the delta and commit.  This greatly helps super fast disks\n\t * that would see slowdowns as more threads started doing fsyncs.\n\t *\n\t * But don't do this if this process was the most recent one to\n\t * perform a synchronous write.  We do this to detect the case where a\n\t * single process is doing a stream of sync writes.  No point in waiting\n\t * for joiners in that case.\n\t */\n\tpid = current->pid;\n\tif (handle->h_sync && journal->j_last_sync_writer != pid) {\n\t\tu64 commit_time, trans_time;\n\n\t\tjournal->j_last_sync_writer = pid;\n\n\t\tspin_lock(&journal->j_state_lock);\n\t\tcommit_time = journal->j_average_commit_time;\n\t\tspin_unlock(&journal->j_state_lock);\n\n\t\ttrans_time = ktime_to_ns(ktime_sub(ktime_get(),\n\t\t\t\t\t\t   transaction->t_start_time));\n\n\t\tcommit_time = min_t(u64, commit_time,\n\t\t\t\t    1000*jiffies_to_usecs(1));\n\n\t\tif (trans_time < commit_time) {\n\t\t\tktime_t expires = ktime_add_ns(ktime_get(),\n\t\t\t\t\t\t       commit_time);\n\t\t\tset_current_state(TASK_UNINTERRUPTIBLE);\n\t\t\tschedule_hrtimeout(&expires, HRTIMER_MODE_ABS);\n\t\t}\n\t}\n\n\tcurrent->journal_info = NULL;\n\tspin_lock(&journal->j_state_lock);\n\tspin_lock(&transaction->t_handle_lock);\n\ttransaction->t_outstanding_credits -= handle->h_buffer_credits;\n\ttransaction->t_updates--;\n\tif (!transaction->t_updates) {\n\t\twake_up(&journal->j_wait_updates);\n\t\tif (journal->j_barrier_count)\n\t\t\twake_up(&journal->j_wait_transaction_locked);\n\t}\n\n\t/*\n\t * If the handle is marked SYNC, we need to set another commit\n\t * going!  We also want to force a commit if the current\n\t * transaction is occupying too much of the log, or if the\n\t * transaction is too old now.\n\t */\n\tif (handle->h_sync ||\n\t\t\ttransaction->t_outstanding_credits >\n\t\t\t\tjournal->j_max_transaction_buffers ||\n\t\t\ttime_after_eq(jiffies, transaction->t_expires)) {\n\t\t/* Do this even for aborted journals: an abort still\n\t\t * completes the commit thread, it just doesn't write\n\t\t * anything to disk. */\n\t\ttid_t tid = transaction->t_tid;\n\n\t\tspin_unlock(&transaction->t_handle_lock);\n\t\tjbd_debug(2, \"transaction too old, requesting commit for \"\n\t\t\t\t\t\"handle %p\\n\", handle);\n\t\t/* This is non-blocking */\n\t\t__log_start_commit(journal, transaction->t_tid);\n\t\tspin_unlock(&journal->j_state_lock);\n\n\t\t/*\n\t\t * Special case: JFS_SYNC synchronous updates require us\n\t\t * to wait for the commit to complete.\n\t\t */\n\t\tif (handle->h_sync && !(current->flags & PF_MEMALLOC))\n\t\t\terr = log_wait_commit(journal, tid);\n\t} else {\n\t\tspin_unlock(&transaction->t_handle_lock);\n\t\tspin_unlock(&journal->j_state_lock);\n\t}\n\n\tlock_map_release(&handle->h_lockdep_map);\n\n\tjbd_free_handle(handle);\n\treturn err;\n}",
    "includes": [
      "#include <linux/hrtimer.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/timer.h>",
      "#include <linux/slab.h>",
      "#include <linux/errno.h>",
      "#include <linux/jbd.h>",
      "#include <linux/fs.h>",
      "#include <linux/time.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "jbd_free_handle",
          "args": [
            "handle"
          ],
          "line": 1481
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lock_map_release",
          "args": [
            "&handle->h_lockdep_map"
          ],
          "line": 1479
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&journal->j_state_lock"
          ],
          "line": 1476
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "log_wait_commit",
          "args": [
            "journal",
            "tid"
          ],
          "line": 1473
        },
        "resolved": true,
        "details": {
          "function_name": "log_wait_commit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd/journal.c",
          "lines": "569-610",
          "snippet": "int log_wait_commit(journal_t *journal, tid_t tid)\n{\n\tint err = 0;\n\n#ifdef CONFIG_JBD_DEBUG\n\tspin_lock(&journal->j_state_lock);\n\tif (!tid_geq(journal->j_commit_request, tid)) {\n\t\tprintk(KERN_ERR\n\t\t       \"%s: error: j_commit_request=%d, tid=%d\\n\",\n\t\t       __func__, journal->j_commit_request, tid);\n\t}\n\tspin_unlock(&journal->j_state_lock);\n#endif\n\tspin_lock(&journal->j_state_lock);\n\t/*\n\t * Not running or committing trans? Must be already committed. This\n\t * saves us from waiting for a *long* time when tid overflows.\n\t */\n\tif (!((journal->j_running_transaction &&\n\t       journal->j_running_transaction->t_tid == tid) ||\n\t      (journal->j_committing_transaction &&\n\t       journal->j_committing_transaction->t_tid == tid)))\n\t\tgoto out_unlock;\n\n\tif (!tid_geq(journal->j_commit_waited, tid))\n\t\tjournal->j_commit_waited = tid;\n\twhile (tid_gt(tid, journal->j_commit_sequence)) {\n\t\tjbd_debug(1, \"JBD: want %d, j_commit_sequence=%d\\n\",\n\t\t\t\t  tid, journal->j_commit_sequence);\n\t\twake_up(&journal->j_wait_commit);\n\t\tspin_unlock(&journal->j_state_lock);\n\t\twait_event(journal->j_wait_done_commit,\n\t\t\t\t!tid_gt(tid, journal->j_commit_sequence));\n\t\tspin_lock(&journal->j_state_lock);\n\t}\nout_unlock:\n\tspin_unlock(&journal->j_state_lock);\n\n\tif (unlikely(is_journal_aborted(journal)))\n\t\terr = -EIO;\n\treturn err;\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <asm/uaccess.h>",
            "#include <trace/events/jbd.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/poison.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/jbd.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <trace/events/jbd.h>\n#include <linux/ratelimit.h>\n#include <linux/debugfs.h>\n#include <linux/proc_fs.h>\n#include <linux/poison.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/freezer.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nint log_wait_commit(journal_t *journal, tid_t tid)\n{\n\tint err = 0;\n\n#ifdef CONFIG_JBD_DEBUG\n\tspin_lock(&journal->j_state_lock);\n\tif (!tid_geq(journal->j_commit_request, tid)) {\n\t\tprintk(KERN_ERR\n\t\t       \"%s: error: j_commit_request=%d, tid=%d\\n\",\n\t\t       __func__, journal->j_commit_request, tid);\n\t}\n\tspin_unlock(&journal->j_state_lock);\n#endif\n\tspin_lock(&journal->j_state_lock);\n\t/*\n\t * Not running or committing trans? Must be already committed. This\n\t * saves us from waiting for a *long* time when tid overflows.\n\t */\n\tif (!((journal->j_running_transaction &&\n\t       journal->j_running_transaction->t_tid == tid) ||\n\t      (journal->j_committing_transaction &&\n\t       journal->j_committing_transaction->t_tid == tid)))\n\t\tgoto out_unlock;\n\n\tif (!tid_geq(journal->j_commit_waited, tid))\n\t\tjournal->j_commit_waited = tid;\n\twhile (tid_gt(tid, journal->j_commit_sequence)) {\n\t\tjbd_debug(1, \"JBD: want %d, j_commit_sequence=%d\\n\",\n\t\t\t\t  tid, journal->j_commit_sequence);\n\t\twake_up(&journal->j_wait_commit);\n\t\tspin_unlock(&journal->j_state_lock);\n\t\twait_event(journal->j_wait_done_commit,\n\t\t\t\t!tid_gt(tid, journal->j_commit_sequence));\n\t\tspin_lock(&journal->j_state_lock);\n\t}\nout_unlock:\n\tspin_unlock(&journal->j_state_lock);\n\n\tif (unlikely(is_journal_aborted(journal)))\n\t\terr = -EIO;\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "__log_start_commit",
          "args": [
            "journal",
            "transaction->t_tid"
          ],
          "line": 1465
        },
        "resolved": true,
        "details": {
          "function_name": "__log_start_commit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd/journal.c",
          "lines": "458-488",
          "snippet": "int __log_start_commit(journal_t *journal, tid_t target)\n{\n\t/*\n\t * The only transaction we can possibly wait upon is the\n\t * currently running transaction (if it exists).  Otherwise,\n\t * the target tid must be an old one.\n\t */\n\tif (journal->j_commit_request != target &&\n\t    journal->j_running_transaction &&\n\t    journal->j_running_transaction->t_tid == target) {\n\t\t/*\n\t\t * We want a new commit: OK, mark the request and wakeup the\n\t\t * commit thread.  We do _not_ do the commit ourselves.\n\t\t */\n\n\t\tjournal->j_commit_request = target;\n\t\tjbd_debug(1, \"JBD: requesting commit %d/%d\\n\",\n\t\t\t  journal->j_commit_request,\n\t\t\t  journal->j_commit_sequence);\n\t\twake_up(&journal->j_wait_commit);\n\t\treturn 1;\n\t} else if (!tid_geq(journal->j_commit_request, target))\n\t\t/* This should never happen, but if it does, preserve\n\t\t   the evidence before kjournald goes into a loop and\n\t\t   increments j_commit_sequence beyond all recognition. */\n\t\tWARN_ONCE(1, \"jbd: bad log_start_commit: %u %u %u %u\\n\",\n\t\t    journal->j_commit_request, journal->j_commit_sequence,\n\t\t    target, journal->j_running_transaction ?\n\t\t    journal->j_running_transaction->t_tid : 0);\n\treturn 0;\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <asm/uaccess.h>",
            "#include <trace/events/jbd.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/poison.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/jbd.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <trace/events/jbd.h>\n#include <linux/ratelimit.h>\n#include <linux/debugfs.h>\n#include <linux/proc_fs.h>\n#include <linux/poison.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/freezer.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nint __log_start_commit(journal_t *journal, tid_t target)\n{\n\t/*\n\t * The only transaction we can possibly wait upon is the\n\t * currently running transaction (if it exists).  Otherwise,\n\t * the target tid must be an old one.\n\t */\n\tif (journal->j_commit_request != target &&\n\t    journal->j_running_transaction &&\n\t    journal->j_running_transaction->t_tid == target) {\n\t\t/*\n\t\t * We want a new commit: OK, mark the request and wakeup the\n\t\t * commit thread.  We do _not_ do the commit ourselves.\n\t\t */\n\n\t\tjournal->j_commit_request = target;\n\t\tjbd_debug(1, \"JBD: requesting commit %d/%d\\n\",\n\t\t\t  journal->j_commit_request,\n\t\t\t  journal->j_commit_sequence);\n\t\twake_up(&journal->j_wait_commit);\n\t\treturn 1;\n\t} else if (!tid_geq(journal->j_commit_request, target))\n\t\t/* This should never happen, but if it does, preserve\n\t\t   the evidence before kjournald goes into a loop and\n\t\t   increments j_commit_sequence beyond all recognition. */\n\t\tWARN_ONCE(1, \"jbd: bad log_start_commit: %u %u %u %u\\n\",\n\t\t    journal->j_commit_request, journal->j_commit_sequence,\n\t\t    target, journal->j_running_transaction ?\n\t\t    journal->j_running_transaction->t_tid : 0);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "jbd_debug",
          "args": [
            "2",
            "\"transaction too old, requesting commit for \"\n\t\t\t\t\t\"handle %p\\n\"",
            "handle"
          ],
          "line": 1462
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "time_after_eq",
          "args": [
            "jiffies",
            "transaction->t_expires"
          ],
          "line": 1455
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wake_up",
          "args": [
            "&journal->j_wait_transaction_locked"
          ],
          "line": 1443
        },
        "resolved": true,
        "details": {
          "function_name": "locks_wake_up_blocks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/locks.c",
          "lines": "656-681",
          "snippet": "static void locks_wake_up_blocks(struct file_lock *blocker)\n{\n\t/*\n\t * Avoid taking global lock if list is empty. This is safe since new\n\t * blocked requests are only added to the list under the flc_lock, and\n\t * the flc_lock is always held here. Note that removal from the fl_block\n\t * list does not require the flc_lock, so we must recheck list_empty()\n\t * after acquiring the blocked_lock_lock.\n\t */\n\tif (list_empty(&blocker->fl_block))\n\t\treturn;\n\n\tspin_lock(&blocked_lock_lock);\n\twhile (!list_empty(&blocker->fl_block)) {\n\t\tstruct file_lock *waiter;\n\n\t\twaiter = list_first_entry(&blocker->fl_block,\n\t\t\t\tstruct file_lock, fl_block);\n\t\t__locks_delete_block(waiter);\n\t\tif (waiter->fl_lmops && waiter->fl_lmops->lm_notify)\n\t\t\twaiter->fl_lmops->lm_notify(waiter);\n\t\telse\n\t\t\twake_up(&waiter->fl_wait);\n\t}\n\tspin_unlock(&blocked_lock_lock);\n}",
          "includes": [
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <asm/uaccess.h>",
            "#include <trace/events/filelock.h>",
            "#include <linux/lglock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/time.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_SPINLOCK(blocked_lock_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <asm/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/lglock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nstatic DEFINE_SPINLOCK(blocked_lock_lock);\n\nstatic void locks_wake_up_blocks(struct file_lock *blocker)\n{\n\t/*\n\t * Avoid taking global lock if list is empty. This is safe since new\n\t * blocked requests are only added to the list under the flc_lock, and\n\t * the flc_lock is always held here. Note that removal from the fl_block\n\t * list does not require the flc_lock, so we must recheck list_empty()\n\t * after acquiring the blocked_lock_lock.\n\t */\n\tif (list_empty(&blocker->fl_block))\n\t\treturn;\n\n\tspin_lock(&blocked_lock_lock);\n\twhile (!list_empty(&blocker->fl_block)) {\n\t\tstruct file_lock *waiter;\n\n\t\twaiter = list_first_entry(&blocker->fl_block,\n\t\t\t\tstruct file_lock, fl_block);\n\t\t__locks_delete_block(waiter);\n\t\tif (waiter->fl_lmops && waiter->fl_lmops->lm_notify)\n\t\t\twaiter->fl_lmops->lm_notify(waiter);\n\t\telse\n\t\t\twake_up(&waiter->fl_wait);\n\t}\n\tspin_unlock(&blocked_lock_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&transaction->t_handle_lock"
          ],
          "line": 1437
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "schedule_hrtimeout",
          "args": [
            "&expires",
            "HRTIMER_MODE_ABS"
          ],
          "line": 1431
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_current_state",
          "args": [
            "TASK_UNINTERRUPTIBLE"
          ],
          "line": 1430
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ktime_add_ns",
          "args": [
            "ktime_get()",
            "commit_time"
          ],
          "line": 1428
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ktime_get",
          "args": [],
          "line": 1428
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "min_t",
          "args": [
            "u64",
            "commit_time",
            "1000*jiffies_to_usecs(1)"
          ],
          "line": 1424
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "jiffies_to_usecs",
          "args": [
            "1"
          ],
          "line": 1425
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ktime_to_ns",
          "args": [
            "ktime_sub(ktime_get(),\n\t\t\t\t\t\t   transaction->t_start_time)"
          ],
          "line": 1421
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ktime_sub",
          "args": [
            "ktime_get()",
            "transaction->t_start_time"
          ],
          "line": 1421
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ktime_get",
          "args": [],
          "line": 1421
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "jbd_debug",
          "args": [
            "4",
            "\"Handle %p going down\\n\"",
            "handle"
          ],
          "line": 1384
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "jbd_debug",
          "args": [
            "4",
            "\"h_ref %d -> %d\\n\"",
            "handle->h_ref + 1",
            "handle->h_ref"
          ],
          "line": 1379
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "J_ASSERT",
          "args": [
            "transaction->t_updates > 0"
          ],
          "line": 1374
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_handle_aborted",
          "args": [
            "handle"
          ],
          "line": 1371
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "J_ASSERT",
          "args": [
            "journal_current_handle() == handle"
          ],
          "line": 1369
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "journal_current_handle",
          "args": [],
          "line": 1369
        },
        "resolved": true,
        "details": {
          "function_name": "ext3_journal_current_handle",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/ext3.h",
          "lines": "1271-1274",
          "snippet": "static inline handle_t *ext3_journal_current_handle(void)\n{\n\treturn journal_current_handle();\n}",
          "includes": [
            "#include <trace/events/ext3.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/bug.h>",
            "#include <linux/magic.h>",
            "#include <linux/jbd.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext3.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/bug.h>\n#include <linux/magic.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n\nstatic inline handle_t *ext3_journal_current_handle(void)\n{\n\treturn journal_current_handle();\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/timer.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n\nint journal_stop(handle_t *handle)\n{\n\ttransaction_t *transaction = handle->h_transaction;\n\tjournal_t *journal = transaction->t_journal;\n\tint err;\n\tpid_t pid;\n\n\tJ_ASSERT(journal_current_handle() == handle);\n\n\tif (is_handle_aborted(handle))\n\t\terr = -EIO;\n\telse {\n\t\tJ_ASSERT(transaction->t_updates > 0);\n\t\terr = 0;\n\t}\n\n\tif (--handle->h_ref > 0) {\n\t\tjbd_debug(4, \"h_ref %d -> %d\\n\", handle->h_ref + 1,\n\t\t\t  handle->h_ref);\n\t\treturn err;\n\t}\n\n\tjbd_debug(4, \"Handle %p going down\\n\", handle);\n\n\t/*\n\t * Implement synchronous transaction batching.  If the handle\n\t * was synchronous, don't force a commit immediately.  Let's\n\t * yield and let another thread piggyback onto this transaction.\n\t * Keep doing that while new threads continue to arrive.\n\t * It doesn't cost much - we're about to run a commit and sleep\n\t * on IO anyway.  Speeds up many-threaded, many-dir operations\n\t * by 30x or more...\n\t *\n\t * We try and optimize the sleep time against what the underlying disk\n\t * can do, instead of having a static sleep time.  This is useful for\n\t * the case where our storage is so fast that it is more optimal to go\n\t * ahead and force a flush and wait for the transaction to be committed\n\t * than it is to wait for an arbitrary amount of time for new writers to\n\t * join the transaction.  We achieve this by measuring how long it takes\n\t * to commit a transaction, and compare it with how long this\n\t * transaction has been running, and if run time < commit time then we\n\t * sleep for the delta and commit.  This greatly helps super fast disks\n\t * that would see slowdowns as more threads started doing fsyncs.\n\t *\n\t * But don't do this if this process was the most recent one to\n\t * perform a synchronous write.  We do this to detect the case where a\n\t * single process is doing a stream of sync writes.  No point in waiting\n\t * for joiners in that case.\n\t */\n\tpid = current->pid;\n\tif (handle->h_sync && journal->j_last_sync_writer != pid) {\n\t\tu64 commit_time, trans_time;\n\n\t\tjournal->j_last_sync_writer = pid;\n\n\t\tspin_lock(&journal->j_state_lock);\n\t\tcommit_time = journal->j_average_commit_time;\n\t\tspin_unlock(&journal->j_state_lock);\n\n\t\ttrans_time = ktime_to_ns(ktime_sub(ktime_get(),\n\t\t\t\t\t\t   transaction->t_start_time));\n\n\t\tcommit_time = min_t(u64, commit_time,\n\t\t\t\t    1000*jiffies_to_usecs(1));\n\n\t\tif (trans_time < commit_time) {\n\t\t\tktime_t expires = ktime_add_ns(ktime_get(),\n\t\t\t\t\t\t       commit_time);\n\t\t\tset_current_state(TASK_UNINTERRUPTIBLE);\n\t\t\tschedule_hrtimeout(&expires, HRTIMER_MODE_ABS);\n\t\t}\n\t}\n\n\tcurrent->journal_info = NULL;\n\tspin_lock(&journal->j_state_lock);\n\tspin_lock(&transaction->t_handle_lock);\n\ttransaction->t_outstanding_credits -= handle->h_buffer_credits;\n\ttransaction->t_updates--;\n\tif (!transaction->t_updates) {\n\t\twake_up(&journal->j_wait_updates);\n\t\tif (journal->j_barrier_count)\n\t\t\twake_up(&journal->j_wait_transaction_locked);\n\t}\n\n\t/*\n\t * If the handle is marked SYNC, we need to set another commit\n\t * going!  We also want to force a commit if the current\n\t * transaction is occupying too much of the log, or if the\n\t * transaction is too old now.\n\t */\n\tif (handle->h_sync ||\n\t\t\ttransaction->t_outstanding_credits >\n\t\t\t\tjournal->j_max_transaction_buffers ||\n\t\t\ttime_after_eq(jiffies, transaction->t_expires)) {\n\t\t/* Do this even for aborted journals: an abort still\n\t\t * completes the commit thread, it just doesn't write\n\t\t * anything to disk. */\n\t\ttid_t tid = transaction->t_tid;\n\n\t\tspin_unlock(&transaction->t_handle_lock);\n\t\tjbd_debug(2, \"transaction too old, requesting commit for \"\n\t\t\t\t\t\"handle %p\\n\", handle);\n\t\t/* This is non-blocking */\n\t\t__log_start_commit(journal, transaction->t_tid);\n\t\tspin_unlock(&journal->j_state_lock);\n\n\t\t/*\n\t\t * Special case: JFS_SYNC synchronous updates require us\n\t\t * to wait for the commit to complete.\n\t\t */\n\t\tif (handle->h_sync && !(current->flags & PF_MEMALLOC))\n\t\t\terr = log_wait_commit(journal, tid);\n\t} else {\n\t\tspin_unlock(&transaction->t_handle_lock);\n\t\tspin_unlock(&journal->j_state_lock);\n\t}\n\n\tlock_map_release(&handle->h_lockdep_map);\n\n\tjbd_free_handle(handle);\n\treturn err;\n}"
  },
  {
    "function_name": "journal_forget",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd/transaction.c",
    "lines": "1235-1344",
    "snippet": "int journal_forget (handle_t *handle, struct buffer_head *bh)\n{\n\ttransaction_t *transaction = handle->h_transaction;\n\tjournal_t *journal = transaction->t_journal;\n\tstruct journal_head *jh;\n\tint drop_reserve = 0;\n\tint err = 0;\n\tint was_modified = 0;\n\n\tBUFFER_TRACE(bh, \"entry\");\n\n\tjbd_lock_bh_state(bh);\n\tspin_lock(&journal->j_list_lock);\n\n\tif (!buffer_jbd(bh))\n\t\tgoto not_jbd;\n\tjh = bh2jh(bh);\n\n\t/* Critical error: attempting to delete a bitmap buffer, maybe?\n\t * Don't do any jbd operations, and return an error. */\n\tif (!J_EXPECT_JH(jh, !jh->b_committed_data,\n\t\t\t \"inconsistent data on disk\")) {\n\t\terr = -EIO;\n\t\tgoto not_jbd;\n\t}\n\n\t/* keep track of whether or not this transaction modified us */\n\twas_modified = jh->b_modified;\n\n\t/*\n\t * The buffer's going from the transaction, we must drop\n\t * all references -bzzz\n\t */\n\tjh->b_modified = 0;\n\n\tif (jh->b_transaction == handle->h_transaction) {\n\t\tJ_ASSERT_JH(jh, !jh->b_frozen_data);\n\n\t\t/* If we are forgetting a buffer which is already part\n\t\t * of this transaction, then we can just drop it from\n\t\t * the transaction immediately. */\n\t\tclear_buffer_dirty(bh);\n\t\tclear_buffer_jbddirty(bh);\n\n\t\tJBUFFER_TRACE(jh, \"belongs to current transaction: unfile\");\n\n\t\t/*\n\t\t * we only want to drop a reference if this transaction\n\t\t * modified the buffer\n\t\t */\n\t\tif (was_modified)\n\t\t\tdrop_reserve = 1;\n\n\t\t/*\n\t\t * We are no longer going to journal this buffer.\n\t\t * However, the commit of this transaction is still\n\t\t * important to the buffer: the delete that we are now\n\t\t * processing might obsolete an old log entry, so by\n\t\t * committing, we can satisfy the buffer's checkpoint.\n\t\t *\n\t\t * So, if we have a checkpoint on the buffer, we should\n\t\t * now refile the buffer on our BJ_Forget list so that\n\t\t * we know to remove the checkpoint after we commit.\n\t\t */\n\n\t\tif (jh->b_cp_transaction) {\n\t\t\t__journal_temp_unlink_buffer(jh);\n\t\t\t__journal_file_buffer(jh, transaction, BJ_Forget);\n\t\t} else {\n\t\t\t__journal_unfile_buffer(jh);\n\t\t\tif (!buffer_jbd(bh)) {\n\t\t\t\tspin_unlock(&journal->j_list_lock);\n\t\t\t\tjbd_unlock_bh_state(bh);\n\t\t\t\t__bforget(bh);\n\t\t\t\tgoto drop;\n\t\t\t}\n\t\t}\n\t} else if (jh->b_transaction) {\n\t\tJ_ASSERT_JH(jh, (jh->b_transaction ==\n\t\t\t\t journal->j_committing_transaction));\n\t\t/* However, if the buffer is still owned by a prior\n\t\t * (committing) transaction, we can't drop it yet... */\n\t\tJBUFFER_TRACE(jh, \"belongs to older transaction\");\n\t\t/* ... but we CAN drop it from the new transaction if we\n\t\t * have also modified it since the original commit. */\n\n\t\tif (jh->b_next_transaction) {\n\t\t\tJ_ASSERT(jh->b_next_transaction == transaction);\n\t\t\tjh->b_next_transaction = NULL;\n\n\t\t\t/*\n\t\t\t * only drop a reference if this transaction modified\n\t\t\t * the buffer\n\t\t\t */\n\t\t\tif (was_modified)\n\t\t\t\tdrop_reserve = 1;\n\t\t}\n\t}\n\nnot_jbd:\n\tspin_unlock(&journal->j_list_lock);\n\tjbd_unlock_bh_state(bh);\n\t__brelse(bh);\ndrop:\n\tif (drop_reserve) {\n\t\t/* no need to reserve log space for this block -bzzz */\n\t\thandle->h_buffer_credits++;\n\t}\n\treturn err;\n}",
    "includes": [
      "#include <linux/hrtimer.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/timer.h>",
      "#include <linux/slab.h>",
      "#include <linux/errno.h>",
      "#include <linux/jbd.h>",
      "#include <linux/fs.h>",
      "#include <linux/time.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void __journal_temp_unlink_buffer(struct journal_head *jh);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "__brelse",
          "args": [
            "bh"
          ],
          "line": 1337
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "jbd_unlock_bh_state",
          "args": [
            "bh"
          ],
          "line": 1336
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&journal->j_list_lock"
          ],
          "line": 1335
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "J_ASSERT",
          "args": [
            "jh->b_next_transaction == transaction"
          ],
          "line": 1322
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "JBUFFER_TRACE",
          "args": [
            "jh",
            "\"belongs to older transaction\""
          ],
          "line": 1317
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "J_ASSERT_JH",
          "args": [
            "jh",
            "(jh->b_transaction ==\n\t\t\t\t journal->j_committing_transaction)"
          ],
          "line": 1313
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__bforget",
          "args": [
            "bh"
          ],
          "line": 1308
        },
        "resolved": true,
        "details": {
          "function_name": "__bforget",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1191-1203",
          "snippet": "void __bforget(struct buffer_head *bh)\n{\n\tclear_buffer_dirty(bh);\n\tif (bh->b_assoc_map) {\n\t\tstruct address_space *buffer_mapping = bh->b_page->mapping;\n\n\t\tspin_lock(&buffer_mapping->private_lock);\n\t\tlist_del_init(&bh->b_assoc_buffers);\n\t\tbh->b_assoc_map = NULL;\n\t\tspin_unlock(&buffer_mapping->private_lock);\n\t}\n\t__brelse(bh);\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __bforget(struct buffer_head *bh)\n{\n\tclear_buffer_dirty(bh);\n\tif (bh->b_assoc_map) {\n\t\tstruct address_space *buffer_mapping = bh->b_page->mapping;\n\n\t\tspin_lock(&buffer_mapping->private_lock);\n\t\tlist_del_init(&bh->b_assoc_buffers);\n\t\tbh->b_assoc_map = NULL;\n\t\tspin_unlock(&buffer_mapping->private_lock);\n\t}\n\t__brelse(bh);\n}"
        }
      },
      {
        "call_info": {
          "callee": "jbd_unlock_bh_state",
          "args": [
            "bh"
          ],
          "line": 1307
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "buffer_jbd",
          "args": [
            "bh"
          ],
          "line": 1305
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__journal_unfile_buffer",
          "args": [
            "jh"
          ],
          "line": 1304
        },
        "resolved": true,
        "details": {
          "function_name": "__journal_unfile_buffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd/transaction.c",
          "lines": "1630-1635",
          "snippet": "void __journal_unfile_buffer(struct journal_head *jh)\n{\n\t__journal_temp_unlink_buffer(jh);\n\tjh->b_transaction = NULL;\n\tjournal_put_journal_head(jh);\n}",
          "includes": [
            "#include <linux/hrtimer.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/timer.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/jbd.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __journal_temp_unlink_buffer(struct journal_head *jh);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/timer.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n\nstatic void __journal_temp_unlink_buffer(struct journal_head *jh);\n\nvoid __journal_unfile_buffer(struct journal_head *jh)\n{\n\t__journal_temp_unlink_buffer(jh);\n\tjh->b_transaction = NULL;\n\tjournal_put_journal_head(jh);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__journal_file_buffer",
          "args": [
            "jh",
            "transaction",
            "BJ_Forget"
          ],
          "line": 1302
        },
        "resolved": true,
        "details": {
          "function_name": "__journal_file_buffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd/transaction.c",
          "lines": "2078-2154",
          "snippet": "void __journal_file_buffer(struct journal_head *jh,\n\t\t\ttransaction_t *transaction, int jlist)\n{\n\tstruct journal_head **list = NULL;\n\tint was_dirty = 0;\n\tstruct buffer_head *bh = jh2bh(jh);\n\n\tJ_ASSERT_JH(jh, jbd_is_locked_bh_state(bh));\n\tassert_spin_locked(&transaction->t_journal->j_list_lock);\n\n\tJ_ASSERT_JH(jh, jh->b_jlist < BJ_Types);\n\tJ_ASSERT_JH(jh, jh->b_transaction == transaction ||\n\t\t\t\tjh->b_transaction == NULL);\n\n\tif (jh->b_transaction && jh->b_jlist == jlist)\n\t\treturn;\n\n\tif (jlist == BJ_Metadata || jlist == BJ_Reserved ||\n\t    jlist == BJ_Shadow || jlist == BJ_Forget) {\n\t\t/*\n\t\t * For metadata buffers, we track dirty bit in buffer_jbddirty\n\t\t * instead of buffer_dirty. We should not see a dirty bit set\n\t\t * here because we clear it in do_get_write_access but e.g.\n\t\t * tune2fs can modify the sb and set the dirty bit at any time\n\t\t * so we try to gracefully handle that.\n\t\t */\n\t\tif (buffer_dirty(bh))\n\t\t\twarn_dirty_buffer(bh);\n\t\tif (test_clear_buffer_dirty(bh) ||\n\t\t    test_clear_buffer_jbddirty(bh))\n\t\t\twas_dirty = 1;\n\t}\n\n\tif (jh->b_transaction)\n\t\t__journal_temp_unlink_buffer(jh);\n\telse\n\t\tjournal_grab_journal_head(bh);\n\tjh->b_transaction = transaction;\n\n\tswitch (jlist) {\n\tcase BJ_None:\n\t\tJ_ASSERT_JH(jh, !jh->b_committed_data);\n\t\tJ_ASSERT_JH(jh, !jh->b_frozen_data);\n\t\treturn;\n\tcase BJ_SyncData:\n\t\tlist = &transaction->t_sync_datalist;\n\t\tbreak;\n\tcase BJ_Metadata:\n\t\ttransaction->t_nr_buffers++;\n\t\tlist = &transaction->t_buffers;\n\t\tbreak;\n\tcase BJ_Forget:\n\t\tlist = &transaction->t_forget;\n\t\tbreak;\n\tcase BJ_IO:\n\t\tlist = &transaction->t_iobuf_list;\n\t\tbreak;\n\tcase BJ_Shadow:\n\t\tlist = &transaction->t_shadow_list;\n\t\tbreak;\n\tcase BJ_LogCtl:\n\t\tlist = &transaction->t_log_list;\n\t\tbreak;\n\tcase BJ_Reserved:\n\t\tlist = &transaction->t_reserved_list;\n\t\tbreak;\n\tcase BJ_Locked:\n\t\tlist =  &transaction->t_locked_list;\n\t\tbreak;\n\t}\n\n\t__blist_add_buffer(list, jh);\n\tjh->b_jlist = jlist;\n\n\tif (was_dirty)\n\t\tset_buffer_jbddirty(bh);\n}",
          "includes": [
            "#include <linux/hrtimer.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/timer.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/jbd.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __journal_temp_unlink_buffer(struct journal_head *jh);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/timer.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n\nstatic void __journal_temp_unlink_buffer(struct journal_head *jh);\n\nvoid __journal_file_buffer(struct journal_head *jh,\n\t\t\ttransaction_t *transaction, int jlist)\n{\n\tstruct journal_head **list = NULL;\n\tint was_dirty = 0;\n\tstruct buffer_head *bh = jh2bh(jh);\n\n\tJ_ASSERT_JH(jh, jbd_is_locked_bh_state(bh));\n\tassert_spin_locked(&transaction->t_journal->j_list_lock);\n\n\tJ_ASSERT_JH(jh, jh->b_jlist < BJ_Types);\n\tJ_ASSERT_JH(jh, jh->b_transaction == transaction ||\n\t\t\t\tjh->b_transaction == NULL);\n\n\tif (jh->b_transaction && jh->b_jlist == jlist)\n\t\treturn;\n\n\tif (jlist == BJ_Metadata || jlist == BJ_Reserved ||\n\t    jlist == BJ_Shadow || jlist == BJ_Forget) {\n\t\t/*\n\t\t * For metadata buffers, we track dirty bit in buffer_jbddirty\n\t\t * instead of buffer_dirty. We should not see a dirty bit set\n\t\t * here because we clear it in do_get_write_access but e.g.\n\t\t * tune2fs can modify the sb and set the dirty bit at any time\n\t\t * so we try to gracefully handle that.\n\t\t */\n\t\tif (buffer_dirty(bh))\n\t\t\twarn_dirty_buffer(bh);\n\t\tif (test_clear_buffer_dirty(bh) ||\n\t\t    test_clear_buffer_jbddirty(bh))\n\t\t\twas_dirty = 1;\n\t}\n\n\tif (jh->b_transaction)\n\t\t__journal_temp_unlink_buffer(jh);\n\telse\n\t\tjournal_grab_journal_head(bh);\n\tjh->b_transaction = transaction;\n\n\tswitch (jlist) {\n\tcase BJ_None:\n\t\tJ_ASSERT_JH(jh, !jh->b_committed_data);\n\t\tJ_ASSERT_JH(jh, !jh->b_frozen_data);\n\t\treturn;\n\tcase BJ_SyncData:\n\t\tlist = &transaction->t_sync_datalist;\n\t\tbreak;\n\tcase BJ_Metadata:\n\t\ttransaction->t_nr_buffers++;\n\t\tlist = &transaction->t_buffers;\n\t\tbreak;\n\tcase BJ_Forget:\n\t\tlist = &transaction->t_forget;\n\t\tbreak;\n\tcase BJ_IO:\n\t\tlist = &transaction->t_iobuf_list;\n\t\tbreak;\n\tcase BJ_Shadow:\n\t\tlist = &transaction->t_shadow_list;\n\t\tbreak;\n\tcase BJ_LogCtl:\n\t\tlist = &transaction->t_log_list;\n\t\tbreak;\n\tcase BJ_Reserved:\n\t\tlist = &transaction->t_reserved_list;\n\t\tbreak;\n\tcase BJ_Locked:\n\t\tlist =  &transaction->t_locked_list;\n\t\tbreak;\n\t}\n\n\t__blist_add_buffer(list, jh);\n\tjh->b_jlist = jlist;\n\n\tif (was_dirty)\n\t\tset_buffer_jbddirty(bh);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__journal_temp_unlink_buffer",
          "args": [
            "jh"
          ],
          "line": 1301
        },
        "resolved": true,
        "details": {
          "function_name": "__journal_temp_unlink_buffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd/transaction.c",
          "lines": "1571-1621",
          "snippet": "static void __journal_temp_unlink_buffer(struct journal_head *jh)\n{\n\tstruct journal_head **list = NULL;\n\ttransaction_t *transaction;\n\tstruct buffer_head *bh = jh2bh(jh);\n\n\tJ_ASSERT_JH(jh, jbd_is_locked_bh_state(bh));\n\ttransaction = jh->b_transaction;\n\tif (transaction)\n\t\tassert_spin_locked(&transaction->t_journal->j_list_lock);\n\n\tJ_ASSERT_JH(jh, jh->b_jlist < BJ_Types);\n\tif (jh->b_jlist != BJ_None)\n\t\tJ_ASSERT_JH(jh, transaction != NULL);\n\n\tswitch (jh->b_jlist) {\n\tcase BJ_None:\n\t\treturn;\n\tcase BJ_SyncData:\n\t\tlist = &transaction->t_sync_datalist;\n\t\tbreak;\n\tcase BJ_Metadata:\n\t\ttransaction->t_nr_buffers--;\n\t\tJ_ASSERT_JH(jh, transaction->t_nr_buffers >= 0);\n\t\tlist = &transaction->t_buffers;\n\t\tbreak;\n\tcase BJ_Forget:\n\t\tlist = &transaction->t_forget;\n\t\tbreak;\n\tcase BJ_IO:\n\t\tlist = &transaction->t_iobuf_list;\n\t\tbreak;\n\tcase BJ_Shadow:\n\t\tlist = &transaction->t_shadow_list;\n\t\tbreak;\n\tcase BJ_LogCtl:\n\t\tlist = &transaction->t_log_list;\n\t\tbreak;\n\tcase BJ_Reserved:\n\t\tlist = &transaction->t_reserved_list;\n\t\tbreak;\n\tcase BJ_Locked:\n\t\tlist = &transaction->t_locked_list;\n\t\tbreak;\n\t}\n\n\t__blist_del_buffer(list, jh);\n\tjh->b_jlist = BJ_None;\n\tif (test_clear_buffer_jbddirty(bh))\n\t\tmark_buffer_dirty(bh);\t/* Expose it to the VM */\n}",
          "includes": [
            "#include <linux/hrtimer.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/timer.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/jbd.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __journal_temp_unlink_buffer(struct journal_head *jh);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/timer.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n\nstatic void __journal_temp_unlink_buffer(struct journal_head *jh);\n\nstatic void __journal_temp_unlink_buffer(struct journal_head *jh)\n{\n\tstruct journal_head **list = NULL;\n\ttransaction_t *transaction;\n\tstruct buffer_head *bh = jh2bh(jh);\n\n\tJ_ASSERT_JH(jh, jbd_is_locked_bh_state(bh));\n\ttransaction = jh->b_transaction;\n\tif (transaction)\n\t\tassert_spin_locked(&transaction->t_journal->j_list_lock);\n\n\tJ_ASSERT_JH(jh, jh->b_jlist < BJ_Types);\n\tif (jh->b_jlist != BJ_None)\n\t\tJ_ASSERT_JH(jh, transaction != NULL);\n\n\tswitch (jh->b_jlist) {\n\tcase BJ_None:\n\t\treturn;\n\tcase BJ_SyncData:\n\t\tlist = &transaction->t_sync_datalist;\n\t\tbreak;\n\tcase BJ_Metadata:\n\t\ttransaction->t_nr_buffers--;\n\t\tJ_ASSERT_JH(jh, transaction->t_nr_buffers >= 0);\n\t\tlist = &transaction->t_buffers;\n\t\tbreak;\n\tcase BJ_Forget:\n\t\tlist = &transaction->t_forget;\n\t\tbreak;\n\tcase BJ_IO:\n\t\tlist = &transaction->t_iobuf_list;\n\t\tbreak;\n\tcase BJ_Shadow:\n\t\tlist = &transaction->t_shadow_list;\n\t\tbreak;\n\tcase BJ_LogCtl:\n\t\tlist = &transaction->t_log_list;\n\t\tbreak;\n\tcase BJ_Reserved:\n\t\tlist = &transaction->t_reserved_list;\n\t\tbreak;\n\tcase BJ_Locked:\n\t\tlist = &transaction->t_locked_list;\n\t\tbreak;\n\t}\n\n\t__blist_del_buffer(list, jh);\n\tjh->b_jlist = BJ_None;\n\tif (test_clear_buffer_jbddirty(bh))\n\t\tmark_buffer_dirty(bh);\t/* Expose it to the VM */\n}"
        }
      },
      {
        "call_info": {
          "callee": "JBUFFER_TRACE",
          "args": [
            "jh",
            "\"belongs to current transaction: unfile\""
          ],
          "line": 1279
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clear_buffer_jbddirty",
          "args": [
            "bh"
          ],
          "line": 1277
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clear_buffer_dirty",
          "args": [
            "bh"
          ],
          "line": 1276
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "J_ASSERT_JH",
          "args": [
            "jh",
            "!jh->b_frozen_data"
          ],
          "line": 1271
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "J_EXPECT_JH",
          "args": [
            "jh",
            "!jh->b_committed_data",
            "\"inconsistent data on disk\""
          ],
          "line": 1255
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bh2jh",
          "args": [
            "bh"
          ],
          "line": 1251
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "buffer_jbd",
          "args": [
            "bh"
          ],
          "line": 1249
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&journal->j_list_lock"
          ],
          "line": 1247
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "jbd_lock_bh_state",
          "args": [
            "bh"
          ],
          "line": 1246
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUFFER_TRACE",
          "args": [
            "bh",
            "\"entry\""
          ],
          "line": 1244
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/timer.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n\nstatic void __journal_temp_unlink_buffer(struct journal_head *jh);\n\nint journal_forget (handle_t *handle, struct buffer_head *bh)\n{\n\ttransaction_t *transaction = handle->h_transaction;\n\tjournal_t *journal = transaction->t_journal;\n\tstruct journal_head *jh;\n\tint drop_reserve = 0;\n\tint err = 0;\n\tint was_modified = 0;\n\n\tBUFFER_TRACE(bh, \"entry\");\n\n\tjbd_lock_bh_state(bh);\n\tspin_lock(&journal->j_list_lock);\n\n\tif (!buffer_jbd(bh))\n\t\tgoto not_jbd;\n\tjh = bh2jh(bh);\n\n\t/* Critical error: attempting to delete a bitmap buffer, maybe?\n\t * Don't do any jbd operations, and return an error. */\n\tif (!J_EXPECT_JH(jh, !jh->b_committed_data,\n\t\t\t \"inconsistent data on disk\")) {\n\t\terr = -EIO;\n\t\tgoto not_jbd;\n\t}\n\n\t/* keep track of whether or not this transaction modified us */\n\twas_modified = jh->b_modified;\n\n\t/*\n\t * The buffer's going from the transaction, we must drop\n\t * all references -bzzz\n\t */\n\tjh->b_modified = 0;\n\n\tif (jh->b_transaction == handle->h_transaction) {\n\t\tJ_ASSERT_JH(jh, !jh->b_frozen_data);\n\n\t\t/* If we are forgetting a buffer which is already part\n\t\t * of this transaction, then we can just drop it from\n\t\t * the transaction immediately. */\n\t\tclear_buffer_dirty(bh);\n\t\tclear_buffer_jbddirty(bh);\n\n\t\tJBUFFER_TRACE(jh, \"belongs to current transaction: unfile\");\n\n\t\t/*\n\t\t * we only want to drop a reference if this transaction\n\t\t * modified the buffer\n\t\t */\n\t\tif (was_modified)\n\t\t\tdrop_reserve = 1;\n\n\t\t/*\n\t\t * We are no longer going to journal this buffer.\n\t\t * However, the commit of this transaction is still\n\t\t * important to the buffer: the delete that we are now\n\t\t * processing might obsolete an old log entry, so by\n\t\t * committing, we can satisfy the buffer's checkpoint.\n\t\t *\n\t\t * So, if we have a checkpoint on the buffer, we should\n\t\t * now refile the buffer on our BJ_Forget list so that\n\t\t * we know to remove the checkpoint after we commit.\n\t\t */\n\n\t\tif (jh->b_cp_transaction) {\n\t\t\t__journal_temp_unlink_buffer(jh);\n\t\t\t__journal_file_buffer(jh, transaction, BJ_Forget);\n\t\t} else {\n\t\t\t__journal_unfile_buffer(jh);\n\t\t\tif (!buffer_jbd(bh)) {\n\t\t\t\tspin_unlock(&journal->j_list_lock);\n\t\t\t\tjbd_unlock_bh_state(bh);\n\t\t\t\t__bforget(bh);\n\t\t\t\tgoto drop;\n\t\t\t}\n\t\t}\n\t} else if (jh->b_transaction) {\n\t\tJ_ASSERT_JH(jh, (jh->b_transaction ==\n\t\t\t\t journal->j_committing_transaction));\n\t\t/* However, if the buffer is still owned by a prior\n\t\t * (committing) transaction, we can't drop it yet... */\n\t\tJBUFFER_TRACE(jh, \"belongs to older transaction\");\n\t\t/* ... but we CAN drop it from the new transaction if we\n\t\t * have also modified it since the original commit. */\n\n\t\tif (jh->b_next_transaction) {\n\t\t\tJ_ASSERT(jh->b_next_transaction == transaction);\n\t\t\tjh->b_next_transaction = NULL;\n\n\t\t\t/*\n\t\t\t * only drop a reference if this transaction modified\n\t\t\t * the buffer\n\t\t\t */\n\t\t\tif (was_modified)\n\t\t\t\tdrop_reserve = 1;\n\t\t}\n\t}\n\nnot_jbd:\n\tspin_unlock(&journal->j_list_lock);\n\tjbd_unlock_bh_state(bh);\n\t__brelse(bh);\ndrop:\n\tif (drop_reserve) {\n\t\t/* no need to reserve log space for this block -bzzz */\n\t\thandle->h_buffer_credits++;\n\t}\n\treturn err;\n}"
  },
  {
    "function_name": "journal_release_buffer",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd/transaction.c",
    "lines": "1212-1216",
    "snippet": "void\njournal_release_buffer(handle_t *handle, struct buffer_head *bh)\n{\n\tBUFFER_TRACE(bh, \"entry\");\n}",
    "includes": [
      "#include <linux/hrtimer.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/timer.h>",
      "#include <linux/slab.h>",
      "#include <linux/errno.h>",
      "#include <linux/jbd.h>",
      "#include <linux/fs.h>",
      "#include <linux/time.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "BUFFER_TRACE",
          "args": [
            "bh",
            "\"entry\""
          ],
          "line": 1215
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/timer.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n\nvoid\njournal_release_buffer(handle_t *handle, struct buffer_head *bh)\n{\n\tBUFFER_TRACE(bh, \"entry\");\n}"
  },
  {
    "function_name": "journal_dirty_metadata",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd/transaction.c",
    "lines": "1137-1205",
    "snippet": "int journal_dirty_metadata(handle_t *handle, struct buffer_head *bh)\n{\n\ttransaction_t *transaction = handle->h_transaction;\n\tjournal_t *journal = transaction->t_journal;\n\tstruct journal_head *jh = bh2jh(bh);\n\n\tjbd_debug(5, \"journal_head %p\\n\", jh);\n\tJBUFFER_TRACE(jh, \"entry\");\n\tif (is_handle_aborted(handle))\n\t\tgoto out;\n\n\tjbd_lock_bh_state(bh);\n\n\tif (jh->b_modified == 0) {\n\t\t/*\n\t\t * This buffer's got modified and becoming part\n\t\t * of the transaction. This needs to be done\n\t\t * once a transaction -bzzz\n\t\t */\n\t\tjh->b_modified = 1;\n\t\tJ_ASSERT_JH(jh, handle->h_buffer_credits > 0);\n\t\thandle->h_buffer_credits--;\n\t}\n\n\t/*\n\t * fastpath, to avoid expensive locking.  If this buffer is already\n\t * on the running transaction's metadata list there is nothing to do.\n\t * Nobody can take it off again because there is a handle open.\n\t * I _think_ we're OK here with SMP barriers - a mistaken decision will\n\t * result in this test being false, so we go in and take the locks.\n\t */\n\tif (jh->b_transaction == transaction && jh->b_jlist == BJ_Metadata) {\n\t\tJBUFFER_TRACE(jh, \"fastpath\");\n\t\tJ_ASSERT_JH(jh, jh->b_transaction ==\n\t\t\t\t\tjournal->j_running_transaction);\n\t\tgoto out_unlock_bh;\n\t}\n\n\tset_buffer_jbddirty(bh);\n\n\t/*\n\t * Metadata already on the current transaction list doesn't\n\t * need to be filed.  Metadata on another transaction's list must\n\t * be committing, and will be refiled once the commit completes:\n\t * leave it alone for now.\n\t */\n\tif (jh->b_transaction != transaction) {\n\t\tJBUFFER_TRACE(jh, \"already on other transaction\");\n\t\tJ_ASSERT_JH(jh, jh->b_transaction ==\n\t\t\t\t\tjournal->j_committing_transaction);\n\t\tJ_ASSERT_JH(jh, jh->b_next_transaction == transaction);\n\t\t/* And this case is illegal: we can't reuse another\n\t\t * transaction's data buffer, ever. */\n\t\tgoto out_unlock_bh;\n\t}\n\n\t/* That test should have eliminated the following case: */\n\tJ_ASSERT_JH(jh, jh->b_frozen_data == NULL);\n\n\tJBUFFER_TRACE(jh, \"file as BJ_Metadata\");\n\tspin_lock(&journal->j_list_lock);\n\t__journal_file_buffer(jh, handle->h_transaction, BJ_Metadata);\n\tspin_unlock(&journal->j_list_lock);\nout_unlock_bh:\n\tjbd_unlock_bh_state(bh);\nout:\n\tJBUFFER_TRACE(jh, \"exit\");\n\treturn 0;\n}",
    "includes": [
      "#include <linux/hrtimer.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/timer.h>",
      "#include <linux/slab.h>",
      "#include <linux/errno.h>",
      "#include <linux/jbd.h>",
      "#include <linux/fs.h>",
      "#include <linux/time.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void __journal_temp_unlink_buffer(struct journal_head *jh);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "JBUFFER_TRACE",
          "args": [
            "jh",
            "\"exit\""
          ],
          "line": 1203
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "jbd_unlock_bh_state",
          "args": [
            "bh"
          ],
          "line": 1201
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&journal->j_list_lock"
          ],
          "line": 1199
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "__journal_file_buffer",
          "args": [
            "jh",
            "handle->h_transaction",
            "BJ_Metadata"
          ],
          "line": 1198
        },
        "resolved": true,
        "details": {
          "function_name": "__journal_file_buffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd/transaction.c",
          "lines": "2078-2154",
          "snippet": "void __journal_file_buffer(struct journal_head *jh,\n\t\t\ttransaction_t *transaction, int jlist)\n{\n\tstruct journal_head **list = NULL;\n\tint was_dirty = 0;\n\tstruct buffer_head *bh = jh2bh(jh);\n\n\tJ_ASSERT_JH(jh, jbd_is_locked_bh_state(bh));\n\tassert_spin_locked(&transaction->t_journal->j_list_lock);\n\n\tJ_ASSERT_JH(jh, jh->b_jlist < BJ_Types);\n\tJ_ASSERT_JH(jh, jh->b_transaction == transaction ||\n\t\t\t\tjh->b_transaction == NULL);\n\n\tif (jh->b_transaction && jh->b_jlist == jlist)\n\t\treturn;\n\n\tif (jlist == BJ_Metadata || jlist == BJ_Reserved ||\n\t    jlist == BJ_Shadow || jlist == BJ_Forget) {\n\t\t/*\n\t\t * For metadata buffers, we track dirty bit in buffer_jbddirty\n\t\t * instead of buffer_dirty. We should not see a dirty bit set\n\t\t * here because we clear it in do_get_write_access but e.g.\n\t\t * tune2fs can modify the sb and set the dirty bit at any time\n\t\t * so we try to gracefully handle that.\n\t\t */\n\t\tif (buffer_dirty(bh))\n\t\t\twarn_dirty_buffer(bh);\n\t\tif (test_clear_buffer_dirty(bh) ||\n\t\t    test_clear_buffer_jbddirty(bh))\n\t\t\twas_dirty = 1;\n\t}\n\n\tif (jh->b_transaction)\n\t\t__journal_temp_unlink_buffer(jh);\n\telse\n\t\tjournal_grab_journal_head(bh);\n\tjh->b_transaction = transaction;\n\n\tswitch (jlist) {\n\tcase BJ_None:\n\t\tJ_ASSERT_JH(jh, !jh->b_committed_data);\n\t\tJ_ASSERT_JH(jh, !jh->b_frozen_data);\n\t\treturn;\n\tcase BJ_SyncData:\n\t\tlist = &transaction->t_sync_datalist;\n\t\tbreak;\n\tcase BJ_Metadata:\n\t\ttransaction->t_nr_buffers++;\n\t\tlist = &transaction->t_buffers;\n\t\tbreak;\n\tcase BJ_Forget:\n\t\tlist = &transaction->t_forget;\n\t\tbreak;\n\tcase BJ_IO:\n\t\tlist = &transaction->t_iobuf_list;\n\t\tbreak;\n\tcase BJ_Shadow:\n\t\tlist = &transaction->t_shadow_list;\n\t\tbreak;\n\tcase BJ_LogCtl:\n\t\tlist = &transaction->t_log_list;\n\t\tbreak;\n\tcase BJ_Reserved:\n\t\tlist = &transaction->t_reserved_list;\n\t\tbreak;\n\tcase BJ_Locked:\n\t\tlist =  &transaction->t_locked_list;\n\t\tbreak;\n\t}\n\n\t__blist_add_buffer(list, jh);\n\tjh->b_jlist = jlist;\n\n\tif (was_dirty)\n\t\tset_buffer_jbddirty(bh);\n}",
          "includes": [
            "#include <linux/hrtimer.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/timer.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/jbd.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __journal_temp_unlink_buffer(struct journal_head *jh);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/timer.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n\nstatic void __journal_temp_unlink_buffer(struct journal_head *jh);\n\nvoid __journal_file_buffer(struct journal_head *jh,\n\t\t\ttransaction_t *transaction, int jlist)\n{\n\tstruct journal_head **list = NULL;\n\tint was_dirty = 0;\n\tstruct buffer_head *bh = jh2bh(jh);\n\n\tJ_ASSERT_JH(jh, jbd_is_locked_bh_state(bh));\n\tassert_spin_locked(&transaction->t_journal->j_list_lock);\n\n\tJ_ASSERT_JH(jh, jh->b_jlist < BJ_Types);\n\tJ_ASSERT_JH(jh, jh->b_transaction == transaction ||\n\t\t\t\tjh->b_transaction == NULL);\n\n\tif (jh->b_transaction && jh->b_jlist == jlist)\n\t\treturn;\n\n\tif (jlist == BJ_Metadata || jlist == BJ_Reserved ||\n\t    jlist == BJ_Shadow || jlist == BJ_Forget) {\n\t\t/*\n\t\t * For metadata buffers, we track dirty bit in buffer_jbddirty\n\t\t * instead of buffer_dirty. We should not see a dirty bit set\n\t\t * here because we clear it in do_get_write_access but e.g.\n\t\t * tune2fs can modify the sb and set the dirty bit at any time\n\t\t * so we try to gracefully handle that.\n\t\t */\n\t\tif (buffer_dirty(bh))\n\t\t\twarn_dirty_buffer(bh);\n\t\tif (test_clear_buffer_dirty(bh) ||\n\t\t    test_clear_buffer_jbddirty(bh))\n\t\t\twas_dirty = 1;\n\t}\n\n\tif (jh->b_transaction)\n\t\t__journal_temp_unlink_buffer(jh);\n\telse\n\t\tjournal_grab_journal_head(bh);\n\tjh->b_transaction = transaction;\n\n\tswitch (jlist) {\n\tcase BJ_None:\n\t\tJ_ASSERT_JH(jh, !jh->b_committed_data);\n\t\tJ_ASSERT_JH(jh, !jh->b_frozen_data);\n\t\treturn;\n\tcase BJ_SyncData:\n\t\tlist = &transaction->t_sync_datalist;\n\t\tbreak;\n\tcase BJ_Metadata:\n\t\ttransaction->t_nr_buffers++;\n\t\tlist = &transaction->t_buffers;\n\t\tbreak;\n\tcase BJ_Forget:\n\t\tlist = &transaction->t_forget;\n\t\tbreak;\n\tcase BJ_IO:\n\t\tlist = &transaction->t_iobuf_list;\n\t\tbreak;\n\tcase BJ_Shadow:\n\t\tlist = &transaction->t_shadow_list;\n\t\tbreak;\n\tcase BJ_LogCtl:\n\t\tlist = &transaction->t_log_list;\n\t\tbreak;\n\tcase BJ_Reserved:\n\t\tlist = &transaction->t_reserved_list;\n\t\tbreak;\n\tcase BJ_Locked:\n\t\tlist =  &transaction->t_locked_list;\n\t\tbreak;\n\t}\n\n\t__blist_add_buffer(list, jh);\n\tjh->b_jlist = jlist;\n\n\tif (was_dirty)\n\t\tset_buffer_jbddirty(bh);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&journal->j_list_lock"
          ],
          "line": 1197
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "JBUFFER_TRACE",
          "args": [
            "jh",
            "\"file as BJ_Metadata\""
          ],
          "line": 1196
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "J_ASSERT_JH",
          "args": [
            "jh",
            "jh->b_frozen_data == NULL"
          ],
          "line": 1194
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "J_ASSERT_JH",
          "args": [
            "jh",
            "jh->b_next_transaction == transaction"
          ],
          "line": 1187
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "J_ASSERT_JH",
          "args": [
            "jh",
            "jh->b_transaction ==\n\t\t\t\t\tjournal->j_committing_transaction"
          ],
          "line": 1185
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "JBUFFER_TRACE",
          "args": [
            "jh",
            "\"already on other transaction\""
          ],
          "line": 1184
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_buffer_jbddirty",
          "args": [
            "bh"
          ],
          "line": 1175
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "J_ASSERT_JH",
          "args": [
            "jh",
            "jh->b_transaction ==\n\t\t\t\t\tjournal->j_running_transaction"
          ],
          "line": 1170
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "JBUFFER_TRACE",
          "args": [
            "jh",
            "\"fastpath\""
          ],
          "line": 1169
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "J_ASSERT_JH",
          "args": [
            "jh",
            "handle->h_buffer_credits > 0"
          ],
          "line": 1157
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "jbd_lock_bh_state",
          "args": [
            "bh"
          ],
          "line": 1148
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_handle_aborted",
          "args": [
            "handle"
          ],
          "line": 1145
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "JBUFFER_TRACE",
          "args": [
            "jh",
            "\"entry\""
          ],
          "line": 1144
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "jbd_debug",
          "args": [
            "5",
            "\"journal_head %p\\n\"",
            "jh"
          ],
          "line": 1143
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bh2jh",
          "args": [
            "bh"
          ],
          "line": 1141
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/timer.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n\nstatic void __journal_temp_unlink_buffer(struct journal_head *jh);\n\nint journal_dirty_metadata(handle_t *handle, struct buffer_head *bh)\n{\n\ttransaction_t *transaction = handle->h_transaction;\n\tjournal_t *journal = transaction->t_journal;\n\tstruct journal_head *jh = bh2jh(bh);\n\n\tjbd_debug(5, \"journal_head %p\\n\", jh);\n\tJBUFFER_TRACE(jh, \"entry\");\n\tif (is_handle_aborted(handle))\n\t\tgoto out;\n\n\tjbd_lock_bh_state(bh);\n\n\tif (jh->b_modified == 0) {\n\t\t/*\n\t\t * This buffer's got modified and becoming part\n\t\t * of the transaction. This needs to be done\n\t\t * once a transaction -bzzz\n\t\t */\n\t\tjh->b_modified = 1;\n\t\tJ_ASSERT_JH(jh, handle->h_buffer_credits > 0);\n\t\thandle->h_buffer_credits--;\n\t}\n\n\t/*\n\t * fastpath, to avoid expensive locking.  If this buffer is already\n\t * on the running transaction's metadata list there is nothing to do.\n\t * Nobody can take it off again because there is a handle open.\n\t * I _think_ we're OK here with SMP barriers - a mistaken decision will\n\t * result in this test being false, so we go in and take the locks.\n\t */\n\tif (jh->b_transaction == transaction && jh->b_jlist == BJ_Metadata) {\n\t\tJBUFFER_TRACE(jh, \"fastpath\");\n\t\tJ_ASSERT_JH(jh, jh->b_transaction ==\n\t\t\t\t\tjournal->j_running_transaction);\n\t\tgoto out_unlock_bh;\n\t}\n\n\tset_buffer_jbddirty(bh);\n\n\t/*\n\t * Metadata already on the current transaction list doesn't\n\t * need to be filed.  Metadata on another transaction's list must\n\t * be committing, and will be refiled once the commit completes:\n\t * leave it alone for now.\n\t */\n\tif (jh->b_transaction != transaction) {\n\t\tJBUFFER_TRACE(jh, \"already on other transaction\");\n\t\tJ_ASSERT_JH(jh, jh->b_transaction ==\n\t\t\t\t\tjournal->j_committing_transaction);\n\t\tJ_ASSERT_JH(jh, jh->b_next_transaction == transaction);\n\t\t/* And this case is illegal: we can't reuse another\n\t\t * transaction's data buffer, ever. */\n\t\tgoto out_unlock_bh;\n\t}\n\n\t/* That test should have eliminated the following case: */\n\tJ_ASSERT_JH(jh, jh->b_frozen_data == NULL);\n\n\tJBUFFER_TRACE(jh, \"file as BJ_Metadata\");\n\tspin_lock(&journal->j_list_lock);\n\t__journal_file_buffer(jh, handle->h_transaction, BJ_Metadata);\n\tspin_unlock(&journal->j_list_lock);\nout_unlock_bh:\n\tjbd_unlock_bh_state(bh);\nout:\n\tJBUFFER_TRACE(jh, \"exit\");\n\treturn 0;\n}"
  },
  {
    "function_name": "journal_dirty_data",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd/transaction.c",
    "lines": "947-1116",
    "snippet": "int journal_dirty_data(handle_t *handle, struct buffer_head *bh)\n{\n\tjournal_t *journal = handle->h_transaction->t_journal;\n\tint need_brelse = 0;\n\tstruct journal_head *jh;\n\tint ret = 0;\n\n\tif (is_handle_aborted(handle))\n\t\treturn ret;\n\n\tjh = journal_add_journal_head(bh);\n\tJBUFFER_TRACE(jh, \"entry\");\n\n\t/*\n\t * The buffer could *already* be dirty.  Writeout can start\n\t * at any time.\n\t */\n\tjbd_debug(4, \"jh: %p, tid:%d\\n\", jh, handle->h_transaction->t_tid);\n\n\t/*\n\t * What if the buffer is already part of a running transaction?\n\t *\n\t * There are two cases:\n\t * 1) It is part of the current running transaction.  Refile it,\n\t *    just in case we have allocated it as metadata, deallocated\n\t *    it, then reallocated it as data.\n\t * 2) It is part of the previous, still-committing transaction.\n\t *    If all we want to do is to guarantee that the buffer will be\n\t *    written to disk before this new transaction commits, then\n\t *    being sure that the *previous* transaction has this same\n\t *    property is sufficient for us!  Just leave it on its old\n\t *    transaction.\n\t *\n\t * In case (2), the buffer must not already exist as metadata\n\t * --- that would violate write ordering (a transaction is free\n\t * to write its data at any point, even before the previous\n\t * committing transaction has committed).  The caller must\n\t * never, ever allow this to happen: there's nothing we can do\n\t * about it in this layer.\n\t */\n\tjbd_lock_bh_state(bh);\n\tspin_lock(&journal->j_list_lock);\n\n\t/* Now that we have bh_state locked, are we really still mapped? */\n\tif (!buffer_mapped(bh)) {\n\t\tJBUFFER_TRACE(jh, \"unmapped buffer, bailing out\");\n\t\tgoto no_journal;\n\t}\n\n\tif (jh->b_transaction) {\n\t\tJBUFFER_TRACE(jh, \"has transaction\");\n\t\tif (jh->b_transaction != handle->h_transaction) {\n\t\t\tJBUFFER_TRACE(jh, \"belongs to older transaction\");\n\t\t\tJ_ASSERT_JH(jh, jh->b_transaction ==\n\t\t\t\t\tjournal->j_committing_transaction);\n\n\t\t\t/* @@@ IS THIS TRUE  ? */\n\t\t\t/*\n\t\t\t * Not any more.  Scenario: someone does a write()\n\t\t\t * in data=journal mode.  The buffer's transaction has\n\t\t\t * moved into commit.  Then someone does another\n\t\t\t * write() to the file.  We do the frozen data copyout\n\t\t\t * and set b_next_transaction to point to j_running_t.\n\t\t\t * And while we're in that state, someone does a\n\t\t\t * writepage() in an attempt to pageout the same area\n\t\t\t * of the file via a shared mapping.  At present that\n\t\t\t * calls journal_dirty_data(), and we get right here.\n\t\t\t * It may be too late to journal the data.  Simply\n\t\t\t * falling through to the next test will suffice: the\n\t\t\t * data will be dirty and wil be checkpointed.  The\n\t\t\t * ordering comments in the next comment block still\n\t\t\t * apply.\n\t\t\t */\n\t\t\t//J_ASSERT_JH(jh, jh->b_next_transaction == NULL);\n\n\t\t\t/*\n\t\t\t * If we're journalling data, and this buffer was\n\t\t\t * subject to a write(), it could be metadata, forget\n\t\t\t * or shadow against the committing transaction.  Now,\n\t\t\t * someone has dirtied the same darn page via a mapping\n\t\t\t * and it is being writepage()'d.\n\t\t\t * We *could* just steal the page from commit, with some\n\t\t\t * fancy locking there.  Instead, we just skip it -\n\t\t\t * don't tie the page's buffers to the new transaction\n\t\t\t * at all.\n\t\t\t * Implication: if we crash before the writepage() data\n\t\t\t * is written into the filesystem, recovery will replay\n\t\t\t * the write() data.\n\t\t\t */\n\t\t\tif (jh->b_jlist != BJ_None &&\n\t\t\t\t\tjh->b_jlist != BJ_SyncData &&\n\t\t\t\t\tjh->b_jlist != BJ_Locked) {\n\t\t\t\tJBUFFER_TRACE(jh, \"Not stealing\");\n\t\t\t\tgoto no_journal;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * This buffer may be undergoing writeout in commit.  We\n\t\t\t * can't return from here and let the caller dirty it\n\t\t\t * again because that can cause the write-out loop in\n\t\t\t * commit to never terminate.\n\t\t\t */\n\t\t\tif (buffer_dirty(bh)) {\n\t\t\t\tget_bh(bh);\n\t\t\t\tspin_unlock(&journal->j_list_lock);\n\t\t\t\tjbd_unlock_bh_state(bh);\n\t\t\t\tneed_brelse = 1;\n\t\t\t\tsync_dirty_buffer(bh);\n\t\t\t\tjbd_lock_bh_state(bh);\n\t\t\t\tspin_lock(&journal->j_list_lock);\n\t\t\t\t/* Since we dropped the lock... */\n\t\t\t\tif (!buffer_mapped(bh)) {\n\t\t\t\t\tJBUFFER_TRACE(jh, \"buffer got unmapped\");\n\t\t\t\t\tgoto no_journal;\n\t\t\t\t}\n\t\t\t\t/* The buffer may become locked again at any\n\t\t\t\t   time if it is redirtied */\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * We cannot remove the buffer with io error from the\n\t\t\t * committing transaction, because otherwise it would\n\t\t\t * miss the error and the commit would not abort.\n\t\t\t */\n\t\t\tif (unlikely(!buffer_uptodate(bh))) {\n\t\t\t\tret = -EIO;\n\t\t\t\tgoto no_journal;\n\t\t\t}\n\t\t\t/* We might have slept so buffer could be refiled now */\n\t\t\tif (jh->b_transaction != NULL &&\n\t\t\t    jh->b_transaction != handle->h_transaction) {\n\t\t\t\tJBUFFER_TRACE(jh, \"unfile from commit\");\n\t\t\t\t__journal_temp_unlink_buffer(jh);\n\t\t\t\t/* It still points to the committing\n\t\t\t\t * transaction; move it to this one so\n\t\t\t\t * that the refile assert checks are\n\t\t\t\t * happy. */\n\t\t\t\tjh->b_transaction = handle->h_transaction;\n\t\t\t}\n\t\t\t/* The buffer will be refiled below */\n\n\t\t}\n\t\t/*\n\t\t * Special case --- the buffer might actually have been\n\t\t * allocated and then immediately deallocated in the previous,\n\t\t * committing transaction, so might still be left on that\n\t\t * transaction's metadata lists.\n\t\t */\n\t\tif (jh->b_jlist != BJ_SyncData && jh->b_jlist != BJ_Locked) {\n\t\t\tJBUFFER_TRACE(jh, \"not on correct data list: unfile\");\n\t\t\tJ_ASSERT_JH(jh, jh->b_jlist != BJ_Shadow);\n\t\t\tJBUFFER_TRACE(jh, \"file as data\");\n\t\t\t__journal_file_buffer(jh, handle->h_transaction,\n\t\t\t\t\t\tBJ_SyncData);\n\t\t}\n\t} else {\n\t\tJBUFFER_TRACE(jh, \"not on a transaction\");\n\t\t__journal_file_buffer(jh, handle->h_transaction, BJ_SyncData);\n\t}\nno_journal:\n\tspin_unlock(&journal->j_list_lock);\n\tjbd_unlock_bh_state(bh);\n\tif (need_brelse) {\n\t\tBUFFER_TRACE(bh, \"brelse\");\n\t\t__brelse(bh);\n\t}\n\tJBUFFER_TRACE(jh, \"exit\");\n\tjournal_put_journal_head(jh);\n\treturn ret;\n}",
    "includes": [
      "#include <linux/hrtimer.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/timer.h>",
      "#include <linux/slab.h>",
      "#include <linux/errno.h>",
      "#include <linux/jbd.h>",
      "#include <linux/fs.h>",
      "#include <linux/time.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void __journal_temp_unlink_buffer(struct journal_head *jh);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "journal_put_journal_head",
          "args": [
            "jh"
          ],
          "line": 1114
        },
        "resolved": true,
        "details": {
          "function_name": "journal_put_journal_head",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd/journal.c",
          "lines": "2020-2033",
          "snippet": "void journal_put_journal_head(struct journal_head *jh)\n{\n\tstruct buffer_head *bh = jh2bh(jh);\n\n\tjbd_lock_bh_journal_head(bh);\n\tJ_ASSERT_JH(jh, jh->b_jcount > 0);\n\t--jh->b_jcount;\n\tif (!jh->b_jcount) {\n\t\t__journal_remove_journal_head(bh);\n\t\tjbd_unlock_bh_journal_head(bh);\n\t\t__brelse(bh);\n\t} else\n\t\tjbd_unlock_bh_journal_head(bh);\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <asm/uaccess.h>",
            "#include <trace/events/jbd.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/poison.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/jbd.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <trace/events/jbd.h>\n#include <linux/ratelimit.h>\n#include <linux/debugfs.h>\n#include <linux/proc_fs.h>\n#include <linux/poison.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/freezer.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nvoid journal_put_journal_head(struct journal_head *jh)\n{\n\tstruct buffer_head *bh = jh2bh(jh);\n\n\tjbd_lock_bh_journal_head(bh);\n\tJ_ASSERT_JH(jh, jh->b_jcount > 0);\n\t--jh->b_jcount;\n\tif (!jh->b_jcount) {\n\t\t__journal_remove_journal_head(bh);\n\t\tjbd_unlock_bh_journal_head(bh);\n\t\t__brelse(bh);\n\t} else\n\t\tjbd_unlock_bh_journal_head(bh);\n}"
        }
      },
      {
        "call_info": {
          "callee": "JBUFFER_TRACE",
          "args": [
            "jh",
            "\"exit\""
          ],
          "line": 1113
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__brelse",
          "args": [
            "bh"
          ],
          "line": 1111
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUFFER_TRACE",
          "args": [
            "bh",
            "\"brelse\""
          ],
          "line": 1110
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "jbd_unlock_bh_state",
          "args": [
            "bh"
          ],
          "line": 1108
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&journal->j_list_lock"
          ],
          "line": 1107
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "__journal_file_buffer",
          "args": [
            "jh",
            "handle->h_transaction",
            "BJ_SyncData"
          ],
          "line": 1104
        },
        "resolved": true,
        "details": {
          "function_name": "__journal_file_buffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd/transaction.c",
          "lines": "2078-2154",
          "snippet": "void __journal_file_buffer(struct journal_head *jh,\n\t\t\ttransaction_t *transaction, int jlist)\n{\n\tstruct journal_head **list = NULL;\n\tint was_dirty = 0;\n\tstruct buffer_head *bh = jh2bh(jh);\n\n\tJ_ASSERT_JH(jh, jbd_is_locked_bh_state(bh));\n\tassert_spin_locked(&transaction->t_journal->j_list_lock);\n\n\tJ_ASSERT_JH(jh, jh->b_jlist < BJ_Types);\n\tJ_ASSERT_JH(jh, jh->b_transaction == transaction ||\n\t\t\t\tjh->b_transaction == NULL);\n\n\tif (jh->b_transaction && jh->b_jlist == jlist)\n\t\treturn;\n\n\tif (jlist == BJ_Metadata || jlist == BJ_Reserved ||\n\t    jlist == BJ_Shadow || jlist == BJ_Forget) {\n\t\t/*\n\t\t * For metadata buffers, we track dirty bit in buffer_jbddirty\n\t\t * instead of buffer_dirty. We should not see a dirty bit set\n\t\t * here because we clear it in do_get_write_access but e.g.\n\t\t * tune2fs can modify the sb and set the dirty bit at any time\n\t\t * so we try to gracefully handle that.\n\t\t */\n\t\tif (buffer_dirty(bh))\n\t\t\twarn_dirty_buffer(bh);\n\t\tif (test_clear_buffer_dirty(bh) ||\n\t\t    test_clear_buffer_jbddirty(bh))\n\t\t\twas_dirty = 1;\n\t}\n\n\tif (jh->b_transaction)\n\t\t__journal_temp_unlink_buffer(jh);\n\telse\n\t\tjournal_grab_journal_head(bh);\n\tjh->b_transaction = transaction;\n\n\tswitch (jlist) {\n\tcase BJ_None:\n\t\tJ_ASSERT_JH(jh, !jh->b_committed_data);\n\t\tJ_ASSERT_JH(jh, !jh->b_frozen_data);\n\t\treturn;\n\tcase BJ_SyncData:\n\t\tlist = &transaction->t_sync_datalist;\n\t\tbreak;\n\tcase BJ_Metadata:\n\t\ttransaction->t_nr_buffers++;\n\t\tlist = &transaction->t_buffers;\n\t\tbreak;\n\tcase BJ_Forget:\n\t\tlist = &transaction->t_forget;\n\t\tbreak;\n\tcase BJ_IO:\n\t\tlist = &transaction->t_iobuf_list;\n\t\tbreak;\n\tcase BJ_Shadow:\n\t\tlist = &transaction->t_shadow_list;\n\t\tbreak;\n\tcase BJ_LogCtl:\n\t\tlist = &transaction->t_log_list;\n\t\tbreak;\n\tcase BJ_Reserved:\n\t\tlist = &transaction->t_reserved_list;\n\t\tbreak;\n\tcase BJ_Locked:\n\t\tlist =  &transaction->t_locked_list;\n\t\tbreak;\n\t}\n\n\t__blist_add_buffer(list, jh);\n\tjh->b_jlist = jlist;\n\n\tif (was_dirty)\n\t\tset_buffer_jbddirty(bh);\n}",
          "includes": [
            "#include <linux/hrtimer.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/timer.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/jbd.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __journal_temp_unlink_buffer(struct journal_head *jh);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/timer.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n\nstatic void __journal_temp_unlink_buffer(struct journal_head *jh);\n\nvoid __journal_file_buffer(struct journal_head *jh,\n\t\t\ttransaction_t *transaction, int jlist)\n{\n\tstruct journal_head **list = NULL;\n\tint was_dirty = 0;\n\tstruct buffer_head *bh = jh2bh(jh);\n\n\tJ_ASSERT_JH(jh, jbd_is_locked_bh_state(bh));\n\tassert_spin_locked(&transaction->t_journal->j_list_lock);\n\n\tJ_ASSERT_JH(jh, jh->b_jlist < BJ_Types);\n\tJ_ASSERT_JH(jh, jh->b_transaction == transaction ||\n\t\t\t\tjh->b_transaction == NULL);\n\n\tif (jh->b_transaction && jh->b_jlist == jlist)\n\t\treturn;\n\n\tif (jlist == BJ_Metadata || jlist == BJ_Reserved ||\n\t    jlist == BJ_Shadow || jlist == BJ_Forget) {\n\t\t/*\n\t\t * For metadata buffers, we track dirty bit in buffer_jbddirty\n\t\t * instead of buffer_dirty. We should not see a dirty bit set\n\t\t * here because we clear it in do_get_write_access but e.g.\n\t\t * tune2fs can modify the sb and set the dirty bit at any time\n\t\t * so we try to gracefully handle that.\n\t\t */\n\t\tif (buffer_dirty(bh))\n\t\t\twarn_dirty_buffer(bh);\n\t\tif (test_clear_buffer_dirty(bh) ||\n\t\t    test_clear_buffer_jbddirty(bh))\n\t\t\twas_dirty = 1;\n\t}\n\n\tif (jh->b_transaction)\n\t\t__journal_temp_unlink_buffer(jh);\n\telse\n\t\tjournal_grab_journal_head(bh);\n\tjh->b_transaction = transaction;\n\n\tswitch (jlist) {\n\tcase BJ_None:\n\t\tJ_ASSERT_JH(jh, !jh->b_committed_data);\n\t\tJ_ASSERT_JH(jh, !jh->b_frozen_data);\n\t\treturn;\n\tcase BJ_SyncData:\n\t\tlist = &transaction->t_sync_datalist;\n\t\tbreak;\n\tcase BJ_Metadata:\n\t\ttransaction->t_nr_buffers++;\n\t\tlist = &transaction->t_buffers;\n\t\tbreak;\n\tcase BJ_Forget:\n\t\tlist = &transaction->t_forget;\n\t\tbreak;\n\tcase BJ_IO:\n\t\tlist = &transaction->t_iobuf_list;\n\t\tbreak;\n\tcase BJ_Shadow:\n\t\tlist = &transaction->t_shadow_list;\n\t\tbreak;\n\tcase BJ_LogCtl:\n\t\tlist = &transaction->t_log_list;\n\t\tbreak;\n\tcase BJ_Reserved:\n\t\tlist = &transaction->t_reserved_list;\n\t\tbreak;\n\tcase BJ_Locked:\n\t\tlist =  &transaction->t_locked_list;\n\t\tbreak;\n\t}\n\n\t__blist_add_buffer(list, jh);\n\tjh->b_jlist = jlist;\n\n\tif (was_dirty)\n\t\tset_buffer_jbddirty(bh);\n}"
        }
      },
      {
        "call_info": {
          "callee": "JBUFFER_TRACE",
          "args": [
            "jh",
            "\"not on a transaction\""
          ],
          "line": 1103
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "JBUFFER_TRACE",
          "args": [
            "jh",
            "\"file as data\""
          ],
          "line": 1098
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "J_ASSERT_JH",
          "args": [
            "jh",
            "jh->b_jlist != BJ_Shadow"
          ],
          "line": 1097
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "JBUFFER_TRACE",
          "args": [
            "jh",
            "\"not on correct data list: unfile\""
          ],
          "line": 1096
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__journal_temp_unlink_buffer",
          "args": [
            "jh"
          ],
          "line": 1079
        },
        "resolved": true,
        "details": {
          "function_name": "__journal_temp_unlink_buffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd/transaction.c",
          "lines": "1571-1621",
          "snippet": "static void __journal_temp_unlink_buffer(struct journal_head *jh)\n{\n\tstruct journal_head **list = NULL;\n\ttransaction_t *transaction;\n\tstruct buffer_head *bh = jh2bh(jh);\n\n\tJ_ASSERT_JH(jh, jbd_is_locked_bh_state(bh));\n\ttransaction = jh->b_transaction;\n\tif (transaction)\n\t\tassert_spin_locked(&transaction->t_journal->j_list_lock);\n\n\tJ_ASSERT_JH(jh, jh->b_jlist < BJ_Types);\n\tif (jh->b_jlist != BJ_None)\n\t\tJ_ASSERT_JH(jh, transaction != NULL);\n\n\tswitch (jh->b_jlist) {\n\tcase BJ_None:\n\t\treturn;\n\tcase BJ_SyncData:\n\t\tlist = &transaction->t_sync_datalist;\n\t\tbreak;\n\tcase BJ_Metadata:\n\t\ttransaction->t_nr_buffers--;\n\t\tJ_ASSERT_JH(jh, transaction->t_nr_buffers >= 0);\n\t\tlist = &transaction->t_buffers;\n\t\tbreak;\n\tcase BJ_Forget:\n\t\tlist = &transaction->t_forget;\n\t\tbreak;\n\tcase BJ_IO:\n\t\tlist = &transaction->t_iobuf_list;\n\t\tbreak;\n\tcase BJ_Shadow:\n\t\tlist = &transaction->t_shadow_list;\n\t\tbreak;\n\tcase BJ_LogCtl:\n\t\tlist = &transaction->t_log_list;\n\t\tbreak;\n\tcase BJ_Reserved:\n\t\tlist = &transaction->t_reserved_list;\n\t\tbreak;\n\tcase BJ_Locked:\n\t\tlist = &transaction->t_locked_list;\n\t\tbreak;\n\t}\n\n\t__blist_del_buffer(list, jh);\n\tjh->b_jlist = BJ_None;\n\tif (test_clear_buffer_jbddirty(bh))\n\t\tmark_buffer_dirty(bh);\t/* Expose it to the VM */\n}",
          "includes": [
            "#include <linux/hrtimer.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/timer.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/jbd.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __journal_temp_unlink_buffer(struct journal_head *jh);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/timer.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n\nstatic void __journal_temp_unlink_buffer(struct journal_head *jh);\n\nstatic void __journal_temp_unlink_buffer(struct journal_head *jh)\n{\n\tstruct journal_head **list = NULL;\n\ttransaction_t *transaction;\n\tstruct buffer_head *bh = jh2bh(jh);\n\n\tJ_ASSERT_JH(jh, jbd_is_locked_bh_state(bh));\n\ttransaction = jh->b_transaction;\n\tif (transaction)\n\t\tassert_spin_locked(&transaction->t_journal->j_list_lock);\n\n\tJ_ASSERT_JH(jh, jh->b_jlist < BJ_Types);\n\tif (jh->b_jlist != BJ_None)\n\t\tJ_ASSERT_JH(jh, transaction != NULL);\n\n\tswitch (jh->b_jlist) {\n\tcase BJ_None:\n\t\treturn;\n\tcase BJ_SyncData:\n\t\tlist = &transaction->t_sync_datalist;\n\t\tbreak;\n\tcase BJ_Metadata:\n\t\ttransaction->t_nr_buffers--;\n\t\tJ_ASSERT_JH(jh, transaction->t_nr_buffers >= 0);\n\t\tlist = &transaction->t_buffers;\n\t\tbreak;\n\tcase BJ_Forget:\n\t\tlist = &transaction->t_forget;\n\t\tbreak;\n\tcase BJ_IO:\n\t\tlist = &transaction->t_iobuf_list;\n\t\tbreak;\n\tcase BJ_Shadow:\n\t\tlist = &transaction->t_shadow_list;\n\t\tbreak;\n\tcase BJ_LogCtl:\n\t\tlist = &transaction->t_log_list;\n\t\tbreak;\n\tcase BJ_Reserved:\n\t\tlist = &transaction->t_reserved_list;\n\t\tbreak;\n\tcase BJ_Locked:\n\t\tlist = &transaction->t_locked_list;\n\t\tbreak;\n\t}\n\n\t__blist_del_buffer(list, jh);\n\tjh->b_jlist = BJ_None;\n\tif (test_clear_buffer_jbddirty(bh))\n\t\tmark_buffer_dirty(bh);\t/* Expose it to the VM */\n}"
        }
      },
      {
        "call_info": {
          "callee": "JBUFFER_TRACE",
          "args": [
            "jh",
            "\"unfile from commit\""
          ],
          "line": 1078
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!buffer_uptodate(bh)"
          ],
          "line": 1071
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "buffer_uptodate",
          "args": [
            "bh"
          ],
          "line": 1071
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_set_buffer_uptodate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/disk-io.c",
          "lines": "3758-3761",
          "snippet": "int btrfs_set_buffer_uptodate(struct extent_buffer *buf)\n{\n\treturn set_extent_buffer_uptodate(buf);\n}",
          "includes": [
            "#include <asm/cpufeature.h>",
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"raid56.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/uuid.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/migrate.h>",
            "#include <linux/slab.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/writeback.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/swap.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/cpufeature.h>\n#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"raid56.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <asm/unaligned.h>\n#include <linux/semaphore.h>\n#include <linux/uuid.h>\n#include <linux/ratelimit.h>\n#include <linux/migrate.h>\n#include <linux/slab.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/radix-tree.h>\n#include <linux/swap.h>\n#include <linux/scatterlist.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nint btrfs_set_buffer_uptodate(struct extent_buffer *buf)\n{\n\treturn set_extent_buffer_uptodate(buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "JBUFFER_TRACE",
          "args": [
            "jh",
            "\"buffer got unmapped\""
          ],
          "line": 1059
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "buffer_mapped",
          "args": [
            "bh"
          ],
          "line": 1058
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&journal->j_list_lock"
          ],
          "line": 1056
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "jbd_lock_bh_state",
          "args": [
            "bh"
          ],
          "line": 1055
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sync_dirty_buffer",
          "args": [
            "bh"
          ],
          "line": 1054
        },
        "resolved": true,
        "details": {
          "function_name": "sync_dirty_buffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "3153-3156",
          "snippet": "int sync_dirty_buffer(struct buffer_head *bh)\n{\n\treturn __sync_dirty_buffer(bh, WRITE_SYNC);\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nint sync_dirty_buffer(struct buffer_head *bh)\n{\n\treturn __sync_dirty_buffer(bh, WRITE_SYNC);\n}"
        }
      },
      {
        "call_info": {
          "callee": "jbd_unlock_bh_state",
          "args": [
            "bh"
          ],
          "line": 1052
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_bh",
          "args": [
            "bh"
          ],
          "line": 1050
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "buffer_dirty",
          "args": [
            "bh"
          ],
          "line": 1049
        },
        "resolved": true,
        "details": {
          "function_name": "mark_buffer_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1141-1167",
          "snippet": "void mark_buffer_dirty(struct buffer_head *bh)\n{\n\tWARN_ON_ONCE(!buffer_uptodate(bh));\n\n\ttrace_block_dirty_buffer(bh);\n\n\t/*\n\t * Very *carefully* optimize the it-is-already-dirty case.\n\t *\n\t * Don't let the final \"is it dirty\" escape to before we\n\t * perhaps modified the buffer.\n\t */\n\tif (buffer_dirty(bh)) {\n\t\tsmp_mb();\n\t\tif (buffer_dirty(bh))\n\t\t\treturn;\n\t}\n\n\tif (!test_set_buffer_dirty(bh)) {\n\t\tstruct page *page = bh->b_page;\n\t\tif (!TestSetPageDirty(page)) {\n\t\t\tstruct address_space *mapping = page_mapping(page);\n\t\t\tif (mapping)\n\t\t\t\t__set_page_dirty(page, mapping, 0);\n\t\t}\n\t}\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid mark_buffer_dirty(struct buffer_head *bh)\n{\n\tWARN_ON_ONCE(!buffer_uptodate(bh));\n\n\ttrace_block_dirty_buffer(bh);\n\n\t/*\n\t * Very *carefully* optimize the it-is-already-dirty case.\n\t *\n\t * Don't let the final \"is it dirty\" escape to before we\n\t * perhaps modified the buffer.\n\t */\n\tif (buffer_dirty(bh)) {\n\t\tsmp_mb();\n\t\tif (buffer_dirty(bh))\n\t\t\treturn;\n\t}\n\n\tif (!test_set_buffer_dirty(bh)) {\n\t\tstruct page *page = bh->b_page;\n\t\tif (!TestSetPageDirty(page)) {\n\t\t\tstruct address_space *mapping = page_mapping(page);\n\t\t\tif (mapping)\n\t\t\t\t__set_page_dirty(page, mapping, 0);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "JBUFFER_TRACE",
          "args": [
            "jh",
            "\"Not stealing\""
          ],
          "line": 1039
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "J_ASSERT_JH",
          "args": [
            "jh",
            "jh->b_transaction ==\n\t\t\t\t\tjournal->j_committing_transaction"
          ],
          "line": 1000
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "JBUFFER_TRACE",
          "args": [
            "jh",
            "\"belongs to older transaction\""
          ],
          "line": 999
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "JBUFFER_TRACE",
          "args": [
            "jh",
            "\"has transaction\""
          ],
          "line": 997
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "JBUFFER_TRACE",
          "args": [
            "jh",
            "\"unmapped buffer, bailing out\""
          ],
          "line": 992
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "buffer_mapped",
          "args": [
            "bh"
          ],
          "line": 991
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "jbd_lock_bh_state",
          "args": [
            "bh"
          ],
          "line": 987
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "jbd_debug",
          "args": [
            "4",
            "\"jh: %p, tid:%d\\n\"",
            "jh",
            "handle->h_transaction->t_tid"
          ],
          "line": 964
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "JBUFFER_TRACE",
          "args": [
            "jh",
            "\"entry\""
          ],
          "line": 958
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "journal_add_journal_head",
          "args": [
            "bh"
          ],
          "line": 957
        },
        "resolved": true,
        "details": {
          "function_name": "journal_add_journal_head",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd/journal.c",
          "lines": "1936-1971",
          "snippet": "struct journal_head *journal_add_journal_head(struct buffer_head *bh)\n{\n\tstruct journal_head *jh;\n\tstruct journal_head *new_jh = NULL;\n\nrepeat:\n\tif (!buffer_jbd(bh))\n\t\tnew_jh = journal_alloc_journal_head();\n\n\tjbd_lock_bh_journal_head(bh);\n\tif (buffer_jbd(bh)) {\n\t\tjh = bh2jh(bh);\n\t} else {\n\t\tJ_ASSERT_BH(bh,\n\t\t\t(atomic_read(&bh->b_count) > 0) ||\n\t\t\t(bh->b_page && bh->b_page->mapping));\n\n\t\tif (!new_jh) {\n\t\t\tjbd_unlock_bh_journal_head(bh);\n\t\t\tgoto repeat;\n\t\t}\n\n\t\tjh = new_jh;\n\t\tnew_jh = NULL;\t\t/* We consumed it */\n\t\tset_buffer_jbd(bh);\n\t\tbh->b_private = jh;\n\t\tjh->b_bh = bh;\n\t\tget_bh(bh);\n\t\tBUFFER_TRACE(bh, \"added journal_head\");\n\t}\n\tjh->b_jcount++;\n\tjbd_unlock_bh_journal_head(bh);\n\tif (new_jh)\n\t\tjournal_free_journal_head(new_jh);\n\treturn bh->b_private;\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <asm/uaccess.h>",
            "#include <trace/events/jbd.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/poison.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/jbd.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <trace/events/jbd.h>\n#include <linux/ratelimit.h>\n#include <linux/debugfs.h>\n#include <linux/proc_fs.h>\n#include <linux/poison.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/freezer.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nstruct journal_head *journal_add_journal_head(struct buffer_head *bh)\n{\n\tstruct journal_head *jh;\n\tstruct journal_head *new_jh = NULL;\n\nrepeat:\n\tif (!buffer_jbd(bh))\n\t\tnew_jh = journal_alloc_journal_head();\n\n\tjbd_lock_bh_journal_head(bh);\n\tif (buffer_jbd(bh)) {\n\t\tjh = bh2jh(bh);\n\t} else {\n\t\tJ_ASSERT_BH(bh,\n\t\t\t(atomic_read(&bh->b_count) > 0) ||\n\t\t\t(bh->b_page && bh->b_page->mapping));\n\n\t\tif (!new_jh) {\n\t\t\tjbd_unlock_bh_journal_head(bh);\n\t\t\tgoto repeat;\n\t\t}\n\n\t\tjh = new_jh;\n\t\tnew_jh = NULL;\t\t/* We consumed it */\n\t\tset_buffer_jbd(bh);\n\t\tbh->b_private = jh;\n\t\tjh->b_bh = bh;\n\t\tget_bh(bh);\n\t\tBUFFER_TRACE(bh, \"added journal_head\");\n\t}\n\tjh->b_jcount++;\n\tjbd_unlock_bh_journal_head(bh);\n\tif (new_jh)\n\t\tjournal_free_journal_head(new_jh);\n\treturn bh->b_private;\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_handle_aborted",
          "args": [
            "handle"
          ],
          "line": 954
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/timer.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n\nstatic void __journal_temp_unlink_buffer(struct journal_head *jh);\n\nint journal_dirty_data(handle_t *handle, struct buffer_head *bh)\n{\n\tjournal_t *journal = handle->h_transaction->t_journal;\n\tint need_brelse = 0;\n\tstruct journal_head *jh;\n\tint ret = 0;\n\n\tif (is_handle_aborted(handle))\n\t\treturn ret;\n\n\tjh = journal_add_journal_head(bh);\n\tJBUFFER_TRACE(jh, \"entry\");\n\n\t/*\n\t * The buffer could *already* be dirty.  Writeout can start\n\t * at any time.\n\t */\n\tjbd_debug(4, \"jh: %p, tid:%d\\n\", jh, handle->h_transaction->t_tid);\n\n\t/*\n\t * What if the buffer is already part of a running transaction?\n\t *\n\t * There are two cases:\n\t * 1) It is part of the current running transaction.  Refile it,\n\t *    just in case we have allocated it as metadata, deallocated\n\t *    it, then reallocated it as data.\n\t * 2) It is part of the previous, still-committing transaction.\n\t *    If all we want to do is to guarantee that the buffer will be\n\t *    written to disk before this new transaction commits, then\n\t *    being sure that the *previous* transaction has this same\n\t *    property is sufficient for us!  Just leave it on its old\n\t *    transaction.\n\t *\n\t * In case (2), the buffer must not already exist as metadata\n\t * --- that would violate write ordering (a transaction is free\n\t * to write its data at any point, even before the previous\n\t * committing transaction has committed).  The caller must\n\t * never, ever allow this to happen: there's nothing we can do\n\t * about it in this layer.\n\t */\n\tjbd_lock_bh_state(bh);\n\tspin_lock(&journal->j_list_lock);\n\n\t/* Now that we have bh_state locked, are we really still mapped? */\n\tif (!buffer_mapped(bh)) {\n\t\tJBUFFER_TRACE(jh, \"unmapped buffer, bailing out\");\n\t\tgoto no_journal;\n\t}\n\n\tif (jh->b_transaction) {\n\t\tJBUFFER_TRACE(jh, \"has transaction\");\n\t\tif (jh->b_transaction != handle->h_transaction) {\n\t\t\tJBUFFER_TRACE(jh, \"belongs to older transaction\");\n\t\t\tJ_ASSERT_JH(jh, jh->b_transaction ==\n\t\t\t\t\tjournal->j_committing_transaction);\n\n\t\t\t/* @@@ IS THIS TRUE  ? */\n\t\t\t/*\n\t\t\t * Not any more.  Scenario: someone does a write()\n\t\t\t * in data=journal mode.  The buffer's transaction has\n\t\t\t * moved into commit.  Then someone does another\n\t\t\t * write() to the file.  We do the frozen data copyout\n\t\t\t * and set b_next_transaction to point to j_running_t.\n\t\t\t * And while we're in that state, someone does a\n\t\t\t * writepage() in an attempt to pageout the same area\n\t\t\t * of the file via a shared mapping.  At present that\n\t\t\t * calls journal_dirty_data(), and we get right here.\n\t\t\t * It may be too late to journal the data.  Simply\n\t\t\t * falling through to the next test will suffice: the\n\t\t\t * data will be dirty and wil be checkpointed.  The\n\t\t\t * ordering comments in the next comment block still\n\t\t\t * apply.\n\t\t\t */\n\t\t\t//J_ASSERT_JH(jh, jh->b_next_transaction == NULL);\n\n\t\t\t/*\n\t\t\t * If we're journalling data, and this buffer was\n\t\t\t * subject to a write(), it could be metadata, forget\n\t\t\t * or shadow against the committing transaction.  Now,\n\t\t\t * someone has dirtied the same darn page via a mapping\n\t\t\t * and it is being writepage()'d.\n\t\t\t * We *could* just steal the page from commit, with some\n\t\t\t * fancy locking there.  Instead, we just skip it -\n\t\t\t * don't tie the page's buffers to the new transaction\n\t\t\t * at all.\n\t\t\t * Implication: if we crash before the writepage() data\n\t\t\t * is written into the filesystem, recovery will replay\n\t\t\t * the write() data.\n\t\t\t */\n\t\t\tif (jh->b_jlist != BJ_None &&\n\t\t\t\t\tjh->b_jlist != BJ_SyncData &&\n\t\t\t\t\tjh->b_jlist != BJ_Locked) {\n\t\t\t\tJBUFFER_TRACE(jh, \"Not stealing\");\n\t\t\t\tgoto no_journal;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * This buffer may be undergoing writeout in commit.  We\n\t\t\t * can't return from here and let the caller dirty it\n\t\t\t * again because that can cause the write-out loop in\n\t\t\t * commit to never terminate.\n\t\t\t */\n\t\t\tif (buffer_dirty(bh)) {\n\t\t\t\tget_bh(bh);\n\t\t\t\tspin_unlock(&journal->j_list_lock);\n\t\t\t\tjbd_unlock_bh_state(bh);\n\t\t\t\tneed_brelse = 1;\n\t\t\t\tsync_dirty_buffer(bh);\n\t\t\t\tjbd_lock_bh_state(bh);\n\t\t\t\tspin_lock(&journal->j_list_lock);\n\t\t\t\t/* Since we dropped the lock... */\n\t\t\t\tif (!buffer_mapped(bh)) {\n\t\t\t\t\tJBUFFER_TRACE(jh, \"buffer got unmapped\");\n\t\t\t\t\tgoto no_journal;\n\t\t\t\t}\n\t\t\t\t/* The buffer may become locked again at any\n\t\t\t\t   time if it is redirtied */\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * We cannot remove the buffer with io error from the\n\t\t\t * committing transaction, because otherwise it would\n\t\t\t * miss the error and the commit would not abort.\n\t\t\t */\n\t\t\tif (unlikely(!buffer_uptodate(bh))) {\n\t\t\t\tret = -EIO;\n\t\t\t\tgoto no_journal;\n\t\t\t}\n\t\t\t/* We might have slept so buffer could be refiled now */\n\t\t\tif (jh->b_transaction != NULL &&\n\t\t\t    jh->b_transaction != handle->h_transaction) {\n\t\t\t\tJBUFFER_TRACE(jh, \"unfile from commit\");\n\t\t\t\t__journal_temp_unlink_buffer(jh);\n\t\t\t\t/* It still points to the committing\n\t\t\t\t * transaction; move it to this one so\n\t\t\t\t * that the refile assert checks are\n\t\t\t\t * happy. */\n\t\t\t\tjh->b_transaction = handle->h_transaction;\n\t\t\t}\n\t\t\t/* The buffer will be refiled below */\n\n\t\t}\n\t\t/*\n\t\t * Special case --- the buffer might actually have been\n\t\t * allocated and then immediately deallocated in the previous,\n\t\t * committing transaction, so might still be left on that\n\t\t * transaction's metadata lists.\n\t\t */\n\t\tif (jh->b_jlist != BJ_SyncData && jh->b_jlist != BJ_Locked) {\n\t\t\tJBUFFER_TRACE(jh, \"not on correct data list: unfile\");\n\t\t\tJ_ASSERT_JH(jh, jh->b_jlist != BJ_Shadow);\n\t\t\tJBUFFER_TRACE(jh, \"file as data\");\n\t\t\t__journal_file_buffer(jh, handle->h_transaction,\n\t\t\t\t\t\tBJ_SyncData);\n\t\t}\n\t} else {\n\t\tJBUFFER_TRACE(jh, \"not on a transaction\");\n\t\t__journal_file_buffer(jh, handle->h_transaction, BJ_SyncData);\n\t}\nno_journal:\n\tspin_unlock(&journal->j_list_lock);\n\tjbd_unlock_bh_state(bh);\n\tif (need_brelse) {\n\t\tBUFFER_TRACE(bh, \"brelse\");\n\t\t__brelse(bh);\n\t}\n\tJBUFFER_TRACE(jh, \"exit\");\n\tjournal_put_journal_head(jh);\n\treturn ret;\n}"
  },
  {
    "function_name": "journal_get_undo_access",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd/transaction.c",
    "lines": "880-928",
    "snippet": "int journal_get_undo_access(handle_t *handle, struct buffer_head *bh)\n{\n\tint err;\n\tstruct journal_head *jh = journal_add_journal_head(bh);\n\tchar *committed_data = NULL;\n\n\tJBUFFER_TRACE(jh, \"entry\");\n\n\t/*\n\t * Do this first --- it can drop the journal lock, so we want to\n\t * make sure that obtaining the committed_data is done\n\t * atomically wrt. completion of any outstanding commits.\n\t */\n\terr = do_get_write_access(handle, jh, 1);\n\tif (err)\n\t\tgoto out;\n\nrepeat:\n\tif (!jh->b_committed_data) {\n\t\tcommitted_data = jbd_alloc(jh2bh(jh)->b_size, GFP_NOFS);\n\t\tif (!committed_data) {\n\t\t\tprintk(KERN_ERR \"%s: No memory for committed data\\n\",\n\t\t\t\t__func__);\n\t\t\terr = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tjbd_lock_bh_state(bh);\n\tif (!jh->b_committed_data) {\n\t\t/* Copy out the current buffer contents into the\n\t\t * preserved, committed copy. */\n\t\tJBUFFER_TRACE(jh, \"generate b_committed data\");\n\t\tif (!committed_data) {\n\t\t\tjbd_unlock_bh_state(bh);\n\t\t\tgoto repeat;\n\t\t}\n\n\t\tjh->b_committed_data = committed_data;\n\t\tcommitted_data = NULL;\n\t\tmemcpy(jh->b_committed_data, bh->b_data, bh->b_size);\n\t}\n\tjbd_unlock_bh_state(bh);\nout:\n\tjournal_put_journal_head(jh);\n\tif (unlikely(committed_data))\n\t\tjbd_free(committed_data, bh->b_size);\n\treturn err;\n}",
    "includes": [
      "#include <linux/hrtimer.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/timer.h>",
      "#include <linux/slab.h>",
      "#include <linux/errno.h>",
      "#include <linux/jbd.h>",
      "#include <linux/fs.h>",
      "#include <linux/time.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void __journal_temp_unlink_buffer(struct journal_head *jh);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "jbd_free",
          "args": [
            "committed_data",
            "bh->b_size"
          ],
          "line": 926
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "committed_data"
          ],
          "line": 925
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "journal_put_journal_head",
          "args": [
            "jh"
          ],
          "line": 924
        },
        "resolved": true,
        "details": {
          "function_name": "journal_put_journal_head",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd/journal.c",
          "lines": "2020-2033",
          "snippet": "void journal_put_journal_head(struct journal_head *jh)\n{\n\tstruct buffer_head *bh = jh2bh(jh);\n\n\tjbd_lock_bh_journal_head(bh);\n\tJ_ASSERT_JH(jh, jh->b_jcount > 0);\n\t--jh->b_jcount;\n\tif (!jh->b_jcount) {\n\t\t__journal_remove_journal_head(bh);\n\t\tjbd_unlock_bh_journal_head(bh);\n\t\t__brelse(bh);\n\t} else\n\t\tjbd_unlock_bh_journal_head(bh);\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <asm/uaccess.h>",
            "#include <trace/events/jbd.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/poison.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/jbd.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <trace/events/jbd.h>\n#include <linux/ratelimit.h>\n#include <linux/debugfs.h>\n#include <linux/proc_fs.h>\n#include <linux/poison.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/freezer.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nvoid journal_put_journal_head(struct journal_head *jh)\n{\n\tstruct buffer_head *bh = jh2bh(jh);\n\n\tjbd_lock_bh_journal_head(bh);\n\tJ_ASSERT_JH(jh, jh->b_jcount > 0);\n\t--jh->b_jcount;\n\tif (!jh->b_jcount) {\n\t\t__journal_remove_journal_head(bh);\n\t\tjbd_unlock_bh_journal_head(bh);\n\t\t__brelse(bh);\n\t} else\n\t\tjbd_unlock_bh_journal_head(bh);\n}"
        }
      },
      {
        "call_info": {
          "callee": "jbd_unlock_bh_state",
          "args": [
            "bh"
          ],
          "line": 922
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "jh->b_committed_data",
            "bh->b_data",
            "bh->b_size"
          ],
          "line": 920
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "jbd_unlock_bh_state",
          "args": [
            "bh"
          ],
          "line": 914
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "JBUFFER_TRACE",
          "args": [
            "jh",
            "\"generate b_committed data\""
          ],
          "line": 912
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "jbd_lock_bh_state",
          "args": [
            "bh"
          ],
          "line": 908
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_ERR \"%s: No memory for committed data\\n\"",
            "__func__"
          ],
          "line": 901
        },
        "resolved": true,
        "details": {
          "function_name": "compat_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/compat.c",
          "lines": "59-69",
          "snippet": "int compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/ioctls.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/aio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/mm.h>",
            "#include <linux/poll.h>",
            "#include <linux/signal.h>",
            "#include <linux/highmem.h>",
            "#include <linux/security.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/personality.h>",
            "#include <linux/highuid.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/dirent.h>",
            "#include <linux/ctype.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/nfs4_mount.h>",
            "#include <linux/ncp_mount.h>",
            "#include <linux/init.h>",
            "#include <linux/ioctl.h>",
            "#include <linux/vfs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/namei.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/errno.h>",
            "#include <linux/compat.h>",
            "#include <linux/linkage.h>",
            "#include <linux/kernel.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int compat_log = 1;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/ioctls.h>\n#include <asm/mmu_context.h>\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/fs_struct.h>\n#include <linux/mm.h>\n#include <linux/poll.h>\n#include <linux/signal.h>\n#include <linux/highmem.h>\n#include <linux/security.h>\n#include <linux/tsacct_kern.h>\n#include <linux/rwsem.h>\n#include <linux/personality.h>\n#include <linux/highuid.h>\n#include <linux/fsnotify.h>\n#include <linux/dirent.h>\n#include <linux/ctype.h>\n#include <linux/syscalls.h>\n#include <linux/nfs4_mount.h>\n#include <linux/ncp_mount.h>\n#include <linux/init.h>\n#include <linux/ioctl.h>\n#include <linux/vfs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/namei.h>\n#include <linux/fcntl.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <linux/compat.h>\n#include <linux/linkage.h>\n#include <linux/kernel.h>\n#include <linux/stddef.h>\n\nint compat_log = 1;\n\nint compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "jbd_alloc",
          "args": [
            "jh2bh(jh)->b_size",
            "GFP_NOFS"
          ],
          "line": 899
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "jh2bh",
          "args": [
            "jh"
          ],
          "line": 899
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "do_get_write_access",
          "args": [
            "handle",
            "jh",
            "1"
          ],
          "line": 893
        },
        "resolved": true,
        "details": {
          "function_name": "do_get_write_access",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd/transaction.c",
          "lines": "518-738",
          "snippet": "static int\ndo_get_write_access(handle_t *handle, struct journal_head *jh,\n\t\t\tint force_copy)\n{\n\tstruct buffer_head *bh;\n\ttransaction_t *transaction;\n\tjournal_t *journal;\n\tint error;\n\tchar *frozen_buffer = NULL;\n\tint need_copy = 0;\n\n\tif (is_handle_aborted(handle))\n\t\treturn -EROFS;\n\n\ttransaction = handle->h_transaction;\n\tjournal = transaction->t_journal;\n\n\tjbd_debug(5, \"journal_head %p, force_copy %d\\n\", jh, force_copy);\n\n\tJBUFFER_TRACE(jh, \"entry\");\nrepeat:\n\tbh = jh2bh(jh);\n\n\t/* @@@ Need to check for errors here at some point. */\n\n\tlock_buffer(bh);\n\tjbd_lock_bh_state(bh);\n\n\t/* We now hold the buffer lock so it is safe to query the buffer\n\t * state.  Is the buffer dirty?\n\t *\n\t * If so, there are two possibilities.  The buffer may be\n\t * non-journaled, and undergoing a quite legitimate writeback.\n\t * Otherwise, it is journaled, and we don't expect dirty buffers\n\t * in that state (the buffers should be marked JBD_Dirty\n\t * instead.)  So either the IO is being done under our own\n\t * control and this is a bug, or it's a third party IO such as\n\t * dump(8) (which may leave the buffer scheduled for read ---\n\t * ie. locked but not dirty) or tune2fs (which may actually have\n\t * the buffer dirtied, ugh.)  */\n\n\tif (buffer_dirty(bh)) {\n\t\t/*\n\t\t * First question: is this buffer already part of the current\n\t\t * transaction or the existing committing transaction?\n\t\t */\n\t\tif (jh->b_transaction) {\n\t\t\tJ_ASSERT_JH(jh,\n\t\t\t\tjh->b_transaction == transaction ||\n\t\t\t\tjh->b_transaction ==\n\t\t\t\t\tjournal->j_committing_transaction);\n\t\t\tif (jh->b_next_transaction)\n\t\t\t\tJ_ASSERT_JH(jh, jh->b_next_transaction ==\n\t\t\t\t\t\t\ttransaction);\n\t\t\twarn_dirty_buffer(bh);\n\t\t}\n\t\t/*\n\t\t * In any case we need to clean the dirty flag and we must\n\t\t * do it under the buffer lock to be sure we don't race\n\t\t * with running write-out.\n\t\t */\n\t\tJBUFFER_TRACE(jh, \"Journalling dirty buffer\");\n\t\tclear_buffer_dirty(bh);\n\t\tset_buffer_jbddirty(bh);\n\t}\n\n\tunlock_buffer(bh);\n\n\terror = -EROFS;\n\tif (is_handle_aborted(handle)) {\n\t\tjbd_unlock_bh_state(bh);\n\t\tgoto out;\n\t}\n\terror = 0;\n\n\t/*\n\t * The buffer is already part of this transaction if b_transaction or\n\t * b_next_transaction points to it\n\t */\n\tif (jh->b_transaction == transaction ||\n\t    jh->b_next_transaction == transaction)\n\t\tgoto done;\n\n\t/*\n\t * this is the first time this transaction is touching this buffer,\n\t * reset the modified flag\n\t */\n\tjh->b_modified = 0;\n\n\t/*\n\t * If there is already a copy-out version of this buffer, then we don't\n\t * need to make another one\n\t */\n\tif (jh->b_frozen_data) {\n\t\tJBUFFER_TRACE(jh, \"has frozen data\");\n\t\tJ_ASSERT_JH(jh, jh->b_next_transaction == NULL);\n\t\tjh->b_next_transaction = transaction;\n\t\tgoto done;\n\t}\n\n\t/* Is there data here we need to preserve? */\n\n\tif (jh->b_transaction && jh->b_transaction != transaction) {\n\t\tJBUFFER_TRACE(jh, \"owned by older transaction\");\n\t\tJ_ASSERT_JH(jh, jh->b_next_transaction == NULL);\n\t\tJ_ASSERT_JH(jh, jh->b_transaction ==\n\t\t\t\t\tjournal->j_committing_transaction);\n\n\t\t/* There is one case we have to be very careful about.\n\t\t * If the committing transaction is currently writing\n\t\t * this buffer out to disk and has NOT made a copy-out,\n\t\t * then we cannot modify the buffer contents at all\n\t\t * right now.  The essence of copy-out is that it is the\n\t\t * extra copy, not the primary copy, which gets\n\t\t * journaled.  If the primary copy is already going to\n\t\t * disk then we cannot do copy-out here. */\n\n\t\tif (jh->b_jlist == BJ_Shadow) {\n\t\t\tDEFINE_WAIT_BIT(wait, &bh->b_state, BH_Unshadow);\n\t\t\twait_queue_head_t *wqh;\n\n\t\t\twqh = bit_waitqueue(&bh->b_state, BH_Unshadow);\n\n\t\t\tJBUFFER_TRACE(jh, \"on shadow: sleep\");\n\t\t\tjbd_unlock_bh_state(bh);\n\t\t\t/* commit wakes up all shadow buffers after IO */\n\t\t\tfor ( ; ; ) {\n\t\t\t\tprepare_to_wait(wqh, &wait.wait,\n\t\t\t\t\t\tTASK_UNINTERRUPTIBLE);\n\t\t\t\tif (jh->b_jlist != BJ_Shadow)\n\t\t\t\t\tbreak;\n\t\t\t\tschedule();\n\t\t\t}\n\t\t\tfinish_wait(wqh, &wait.wait);\n\t\t\tgoto repeat;\n\t\t}\n\n\t\t/* Only do the copy if the currently-owning transaction\n\t\t * still needs it.  If it is on the Forget list, the\n\t\t * committing transaction is past that stage.  The\n\t\t * buffer had better remain locked during the kmalloc,\n\t\t * but that should be true --- we hold the journal lock\n\t\t * still and the buffer is already on the BUF_JOURNAL\n\t\t * list so won't be flushed.\n\t\t *\n\t\t * Subtle point, though: if this is a get_undo_access,\n\t\t * then we will be relying on the frozen_data to contain\n\t\t * the new value of the committed_data record after the\n\t\t * transaction, so we HAVE to force the frozen_data copy\n\t\t * in that case. */\n\n\t\tif (jh->b_jlist != BJ_Forget || force_copy) {\n\t\t\tJBUFFER_TRACE(jh, \"generate frozen data\");\n\t\t\tif (!frozen_buffer) {\n\t\t\t\tJBUFFER_TRACE(jh, \"allocate memory for buffer\");\n\t\t\t\tjbd_unlock_bh_state(bh);\n\t\t\t\tfrozen_buffer =\n\t\t\t\t\tjbd_alloc(jh2bh(jh)->b_size,\n\t\t\t\t\t\t\t GFP_NOFS);\n\t\t\t\tif (!frozen_buffer) {\n\t\t\t\t\tprintk(KERN_ERR\n\t\t\t\t\t       \"%s: OOM for frozen_buffer\\n\",\n\t\t\t\t\t       __func__);\n\t\t\t\t\tJBUFFER_TRACE(jh, \"oom!\");\n\t\t\t\t\terror = -ENOMEM;\n\t\t\t\t\tjbd_lock_bh_state(bh);\n\t\t\t\t\tgoto done;\n\t\t\t\t}\n\t\t\t\tgoto repeat;\n\t\t\t}\n\t\t\tjh->b_frozen_data = frozen_buffer;\n\t\t\tfrozen_buffer = NULL;\n\t\t\tneed_copy = 1;\n\t\t}\n\t\tjh->b_next_transaction = transaction;\n\t}\n\n\n\t/*\n\t * Finally, if the buffer is not journaled right now, we need to make\n\t * sure it doesn't get written to disk before the caller actually\n\t * commits the new data\n\t */\n\tif (!jh->b_transaction) {\n\t\tJBUFFER_TRACE(jh, \"no transaction\");\n\t\tJ_ASSERT_JH(jh, !jh->b_next_transaction);\n\t\tJBUFFER_TRACE(jh, \"file as BJ_Reserved\");\n\t\tspin_lock(&journal->j_list_lock);\n\t\t__journal_file_buffer(jh, transaction, BJ_Reserved);\n\t\tspin_unlock(&journal->j_list_lock);\n\t}\n\ndone:\n\tif (need_copy) {\n\t\tstruct page *page;\n\t\tint offset;\n\t\tchar *source;\n\n\t\tJ_EXPECT_JH(jh, buffer_uptodate(jh2bh(jh)),\n\t\t\t    \"Possible IO failure.\\n\");\n\t\tpage = jh2bh(jh)->b_page;\n\t\toffset = offset_in_page(jh2bh(jh)->b_data);\n\t\tsource = kmap_atomic(page);\n\t\tmemcpy(jh->b_frozen_data, source+offset, jh2bh(jh)->b_size);\n\t\tkunmap_atomic(source);\n\t}\n\tjbd_unlock_bh_state(bh);\n\n\t/*\n\t * If we are about to journal a buffer, then any revoke pending on it is\n\t * no longer valid\n\t */\n\tjournal_cancel_revoke(handle, jh);\n\nout:\n\tif (unlikely(frozen_buffer))\t/* It's usually NULL */\n\t\tjbd_free(frozen_buffer, bh->b_size);\n\n\tJBUFFER_TRACE(jh, \"exit\");\n\treturn error;\n}",
          "includes": [
            "#include <linux/hrtimer.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/timer.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/jbd.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __journal_temp_unlink_buffer(struct journal_head *jh);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/timer.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n\nstatic void __journal_temp_unlink_buffer(struct journal_head *jh);\n\nstatic int\ndo_get_write_access(handle_t *handle, struct journal_head *jh,\n\t\t\tint force_copy)\n{\n\tstruct buffer_head *bh;\n\ttransaction_t *transaction;\n\tjournal_t *journal;\n\tint error;\n\tchar *frozen_buffer = NULL;\n\tint need_copy = 0;\n\n\tif (is_handle_aborted(handle))\n\t\treturn -EROFS;\n\n\ttransaction = handle->h_transaction;\n\tjournal = transaction->t_journal;\n\n\tjbd_debug(5, \"journal_head %p, force_copy %d\\n\", jh, force_copy);\n\n\tJBUFFER_TRACE(jh, \"entry\");\nrepeat:\n\tbh = jh2bh(jh);\n\n\t/* @@@ Need to check for errors here at some point. */\n\n\tlock_buffer(bh);\n\tjbd_lock_bh_state(bh);\n\n\t/* We now hold the buffer lock so it is safe to query the buffer\n\t * state.  Is the buffer dirty?\n\t *\n\t * If so, there are two possibilities.  The buffer may be\n\t * non-journaled, and undergoing a quite legitimate writeback.\n\t * Otherwise, it is journaled, and we don't expect dirty buffers\n\t * in that state (the buffers should be marked JBD_Dirty\n\t * instead.)  So either the IO is being done under our own\n\t * control and this is a bug, or it's a third party IO such as\n\t * dump(8) (which may leave the buffer scheduled for read ---\n\t * ie. locked but not dirty) or tune2fs (which may actually have\n\t * the buffer dirtied, ugh.)  */\n\n\tif (buffer_dirty(bh)) {\n\t\t/*\n\t\t * First question: is this buffer already part of the current\n\t\t * transaction or the existing committing transaction?\n\t\t */\n\t\tif (jh->b_transaction) {\n\t\t\tJ_ASSERT_JH(jh,\n\t\t\t\tjh->b_transaction == transaction ||\n\t\t\t\tjh->b_transaction ==\n\t\t\t\t\tjournal->j_committing_transaction);\n\t\t\tif (jh->b_next_transaction)\n\t\t\t\tJ_ASSERT_JH(jh, jh->b_next_transaction ==\n\t\t\t\t\t\t\ttransaction);\n\t\t\twarn_dirty_buffer(bh);\n\t\t}\n\t\t/*\n\t\t * In any case we need to clean the dirty flag and we must\n\t\t * do it under the buffer lock to be sure we don't race\n\t\t * with running write-out.\n\t\t */\n\t\tJBUFFER_TRACE(jh, \"Journalling dirty buffer\");\n\t\tclear_buffer_dirty(bh);\n\t\tset_buffer_jbddirty(bh);\n\t}\n\n\tunlock_buffer(bh);\n\n\terror = -EROFS;\n\tif (is_handle_aborted(handle)) {\n\t\tjbd_unlock_bh_state(bh);\n\t\tgoto out;\n\t}\n\terror = 0;\n\n\t/*\n\t * The buffer is already part of this transaction if b_transaction or\n\t * b_next_transaction points to it\n\t */\n\tif (jh->b_transaction == transaction ||\n\t    jh->b_next_transaction == transaction)\n\t\tgoto done;\n\n\t/*\n\t * this is the first time this transaction is touching this buffer,\n\t * reset the modified flag\n\t */\n\tjh->b_modified = 0;\n\n\t/*\n\t * If there is already a copy-out version of this buffer, then we don't\n\t * need to make another one\n\t */\n\tif (jh->b_frozen_data) {\n\t\tJBUFFER_TRACE(jh, \"has frozen data\");\n\t\tJ_ASSERT_JH(jh, jh->b_next_transaction == NULL);\n\t\tjh->b_next_transaction = transaction;\n\t\tgoto done;\n\t}\n\n\t/* Is there data here we need to preserve? */\n\n\tif (jh->b_transaction && jh->b_transaction != transaction) {\n\t\tJBUFFER_TRACE(jh, \"owned by older transaction\");\n\t\tJ_ASSERT_JH(jh, jh->b_next_transaction == NULL);\n\t\tJ_ASSERT_JH(jh, jh->b_transaction ==\n\t\t\t\t\tjournal->j_committing_transaction);\n\n\t\t/* There is one case we have to be very careful about.\n\t\t * If the committing transaction is currently writing\n\t\t * this buffer out to disk and has NOT made a copy-out,\n\t\t * then we cannot modify the buffer contents at all\n\t\t * right now.  The essence of copy-out is that it is the\n\t\t * extra copy, not the primary copy, which gets\n\t\t * journaled.  If the primary copy is already going to\n\t\t * disk then we cannot do copy-out here. */\n\n\t\tif (jh->b_jlist == BJ_Shadow) {\n\t\t\tDEFINE_WAIT_BIT(wait, &bh->b_state, BH_Unshadow);\n\t\t\twait_queue_head_t *wqh;\n\n\t\t\twqh = bit_waitqueue(&bh->b_state, BH_Unshadow);\n\n\t\t\tJBUFFER_TRACE(jh, \"on shadow: sleep\");\n\t\t\tjbd_unlock_bh_state(bh);\n\t\t\t/* commit wakes up all shadow buffers after IO */\n\t\t\tfor ( ; ; ) {\n\t\t\t\tprepare_to_wait(wqh, &wait.wait,\n\t\t\t\t\t\tTASK_UNINTERRUPTIBLE);\n\t\t\t\tif (jh->b_jlist != BJ_Shadow)\n\t\t\t\t\tbreak;\n\t\t\t\tschedule();\n\t\t\t}\n\t\t\tfinish_wait(wqh, &wait.wait);\n\t\t\tgoto repeat;\n\t\t}\n\n\t\t/* Only do the copy if the currently-owning transaction\n\t\t * still needs it.  If it is on the Forget list, the\n\t\t * committing transaction is past that stage.  The\n\t\t * buffer had better remain locked during the kmalloc,\n\t\t * but that should be true --- we hold the journal lock\n\t\t * still and the buffer is already on the BUF_JOURNAL\n\t\t * list so won't be flushed.\n\t\t *\n\t\t * Subtle point, though: if this is a get_undo_access,\n\t\t * then we will be relying on the frozen_data to contain\n\t\t * the new value of the committed_data record after the\n\t\t * transaction, so we HAVE to force the frozen_data copy\n\t\t * in that case. */\n\n\t\tif (jh->b_jlist != BJ_Forget || force_copy) {\n\t\t\tJBUFFER_TRACE(jh, \"generate frozen data\");\n\t\t\tif (!frozen_buffer) {\n\t\t\t\tJBUFFER_TRACE(jh, \"allocate memory for buffer\");\n\t\t\t\tjbd_unlock_bh_state(bh);\n\t\t\t\tfrozen_buffer =\n\t\t\t\t\tjbd_alloc(jh2bh(jh)->b_size,\n\t\t\t\t\t\t\t GFP_NOFS);\n\t\t\t\tif (!frozen_buffer) {\n\t\t\t\t\tprintk(KERN_ERR\n\t\t\t\t\t       \"%s: OOM for frozen_buffer\\n\",\n\t\t\t\t\t       __func__);\n\t\t\t\t\tJBUFFER_TRACE(jh, \"oom!\");\n\t\t\t\t\terror = -ENOMEM;\n\t\t\t\t\tjbd_lock_bh_state(bh);\n\t\t\t\t\tgoto done;\n\t\t\t\t}\n\t\t\t\tgoto repeat;\n\t\t\t}\n\t\t\tjh->b_frozen_data = frozen_buffer;\n\t\t\tfrozen_buffer = NULL;\n\t\t\tneed_copy = 1;\n\t\t}\n\t\tjh->b_next_transaction = transaction;\n\t}\n\n\n\t/*\n\t * Finally, if the buffer is not journaled right now, we need to make\n\t * sure it doesn't get written to disk before the caller actually\n\t * commits the new data\n\t */\n\tif (!jh->b_transaction) {\n\t\tJBUFFER_TRACE(jh, \"no transaction\");\n\t\tJ_ASSERT_JH(jh, !jh->b_next_transaction);\n\t\tJBUFFER_TRACE(jh, \"file as BJ_Reserved\");\n\t\tspin_lock(&journal->j_list_lock);\n\t\t__journal_file_buffer(jh, transaction, BJ_Reserved);\n\t\tspin_unlock(&journal->j_list_lock);\n\t}\n\ndone:\n\tif (need_copy) {\n\t\tstruct page *page;\n\t\tint offset;\n\t\tchar *source;\n\n\t\tJ_EXPECT_JH(jh, buffer_uptodate(jh2bh(jh)),\n\t\t\t    \"Possible IO failure.\\n\");\n\t\tpage = jh2bh(jh)->b_page;\n\t\toffset = offset_in_page(jh2bh(jh)->b_data);\n\t\tsource = kmap_atomic(page);\n\t\tmemcpy(jh->b_frozen_data, source+offset, jh2bh(jh)->b_size);\n\t\tkunmap_atomic(source);\n\t}\n\tjbd_unlock_bh_state(bh);\n\n\t/*\n\t * If we are about to journal a buffer, then any revoke pending on it is\n\t * no longer valid\n\t */\n\tjournal_cancel_revoke(handle, jh);\n\nout:\n\tif (unlikely(frozen_buffer))\t/* It's usually NULL */\n\t\tjbd_free(frozen_buffer, bh->b_size);\n\n\tJBUFFER_TRACE(jh, \"exit\");\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "JBUFFER_TRACE",
          "args": [
            "jh",
            "\"entry\""
          ],
          "line": 886
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "journal_add_journal_head",
          "args": [
            "bh"
          ],
          "line": 883
        },
        "resolved": true,
        "details": {
          "function_name": "journal_add_journal_head",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd/journal.c",
          "lines": "1936-1971",
          "snippet": "struct journal_head *journal_add_journal_head(struct buffer_head *bh)\n{\n\tstruct journal_head *jh;\n\tstruct journal_head *new_jh = NULL;\n\nrepeat:\n\tif (!buffer_jbd(bh))\n\t\tnew_jh = journal_alloc_journal_head();\n\n\tjbd_lock_bh_journal_head(bh);\n\tif (buffer_jbd(bh)) {\n\t\tjh = bh2jh(bh);\n\t} else {\n\t\tJ_ASSERT_BH(bh,\n\t\t\t(atomic_read(&bh->b_count) > 0) ||\n\t\t\t(bh->b_page && bh->b_page->mapping));\n\n\t\tif (!new_jh) {\n\t\t\tjbd_unlock_bh_journal_head(bh);\n\t\t\tgoto repeat;\n\t\t}\n\n\t\tjh = new_jh;\n\t\tnew_jh = NULL;\t\t/* We consumed it */\n\t\tset_buffer_jbd(bh);\n\t\tbh->b_private = jh;\n\t\tjh->b_bh = bh;\n\t\tget_bh(bh);\n\t\tBUFFER_TRACE(bh, \"added journal_head\");\n\t}\n\tjh->b_jcount++;\n\tjbd_unlock_bh_journal_head(bh);\n\tif (new_jh)\n\t\tjournal_free_journal_head(new_jh);\n\treturn bh->b_private;\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <asm/uaccess.h>",
            "#include <trace/events/jbd.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/poison.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/jbd.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <trace/events/jbd.h>\n#include <linux/ratelimit.h>\n#include <linux/debugfs.h>\n#include <linux/proc_fs.h>\n#include <linux/poison.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/freezer.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nstruct journal_head *journal_add_journal_head(struct buffer_head *bh)\n{\n\tstruct journal_head *jh;\n\tstruct journal_head *new_jh = NULL;\n\nrepeat:\n\tif (!buffer_jbd(bh))\n\t\tnew_jh = journal_alloc_journal_head();\n\n\tjbd_lock_bh_journal_head(bh);\n\tif (buffer_jbd(bh)) {\n\t\tjh = bh2jh(bh);\n\t} else {\n\t\tJ_ASSERT_BH(bh,\n\t\t\t(atomic_read(&bh->b_count) > 0) ||\n\t\t\t(bh->b_page && bh->b_page->mapping));\n\n\t\tif (!new_jh) {\n\t\t\tjbd_unlock_bh_journal_head(bh);\n\t\t\tgoto repeat;\n\t\t}\n\n\t\tjh = new_jh;\n\t\tnew_jh = NULL;\t\t/* We consumed it */\n\t\tset_buffer_jbd(bh);\n\t\tbh->b_private = jh;\n\t\tjh->b_bh = bh;\n\t\tget_bh(bh);\n\t\tBUFFER_TRACE(bh, \"added journal_head\");\n\t}\n\tjh->b_jcount++;\n\tjbd_unlock_bh_journal_head(bh);\n\tif (new_jh)\n\t\tjournal_free_journal_head(new_jh);\n\treturn bh->b_private;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/timer.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n\nstatic void __journal_temp_unlink_buffer(struct journal_head *jh);\n\nint journal_get_undo_access(handle_t *handle, struct buffer_head *bh)\n{\n\tint err;\n\tstruct journal_head *jh = journal_add_journal_head(bh);\n\tchar *committed_data = NULL;\n\n\tJBUFFER_TRACE(jh, \"entry\");\n\n\t/*\n\t * Do this first --- it can drop the journal lock, so we want to\n\t * make sure that obtaining the committed_data is done\n\t * atomically wrt. completion of any outstanding commits.\n\t */\n\terr = do_get_write_access(handle, jh, 1);\n\tif (err)\n\t\tgoto out;\n\nrepeat:\n\tif (!jh->b_committed_data) {\n\t\tcommitted_data = jbd_alloc(jh2bh(jh)->b_size, GFP_NOFS);\n\t\tif (!committed_data) {\n\t\t\tprintk(KERN_ERR \"%s: No memory for committed data\\n\",\n\t\t\t\t__func__);\n\t\t\terr = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tjbd_lock_bh_state(bh);\n\tif (!jh->b_committed_data) {\n\t\t/* Copy out the current buffer contents into the\n\t\t * preserved, committed copy. */\n\t\tJBUFFER_TRACE(jh, \"generate b_committed data\");\n\t\tif (!committed_data) {\n\t\t\tjbd_unlock_bh_state(bh);\n\t\t\tgoto repeat;\n\t\t}\n\n\t\tjh->b_committed_data = committed_data;\n\t\tcommitted_data = NULL;\n\t\tmemcpy(jh->b_committed_data, bh->b_data, bh->b_size);\n\t}\n\tjbd_unlock_bh_state(bh);\nout:\n\tjournal_put_journal_head(jh);\n\tif (unlikely(committed_data))\n\t\tjbd_free(committed_data, bh->b_size);\n\treturn err;\n}"
  },
  {
    "function_name": "journal_get_create_access",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd/transaction.c",
    "lines": "784-853",
    "snippet": "int journal_get_create_access(handle_t *handle, struct buffer_head *bh)\n{\n\ttransaction_t *transaction = handle->h_transaction;\n\tjournal_t *journal = transaction->t_journal;\n\tstruct journal_head *jh = journal_add_journal_head(bh);\n\tint err;\n\n\tjbd_debug(5, \"journal_head %p\\n\", jh);\n\terr = -EROFS;\n\tif (is_handle_aborted(handle))\n\t\tgoto out;\n\terr = 0;\n\n\tJBUFFER_TRACE(jh, \"entry\");\n\t/*\n\t * The buffer may already belong to this transaction due to pre-zeroing\n\t * in the filesystem's new_block code.  It may also be on the previous,\n\t * committing transaction's lists, but it HAS to be in Forget state in\n\t * that case: the transaction must have deleted the buffer for it to be\n\t * reused here.\n\t */\n\tjbd_lock_bh_state(bh);\n\tspin_lock(&journal->j_list_lock);\n\tJ_ASSERT_JH(jh, (jh->b_transaction == transaction ||\n\t\tjh->b_transaction == NULL ||\n\t\t(jh->b_transaction == journal->j_committing_transaction &&\n\t\t\t  jh->b_jlist == BJ_Forget)));\n\n\tJ_ASSERT_JH(jh, jh->b_next_transaction == NULL);\n\tJ_ASSERT_JH(jh, buffer_locked(jh2bh(jh)));\n\n\tif (jh->b_transaction == NULL) {\n\t\t/*\n\t\t * Previous journal_forget() could have left the buffer\n\t\t * with jbddirty bit set because it was being committed. When\n\t\t * the commit finished, we've filed the buffer for\n\t\t * checkpointing and marked it dirty. Now we are reallocating\n\t\t * the buffer so the transaction freeing it must have\n\t\t * committed and so it's safe to clear the dirty bit.\n\t\t */\n\t\tclear_buffer_dirty(jh2bh(jh));\n\n\t\t/* first access by this transaction */\n\t\tjh->b_modified = 0;\n\n\t\tJBUFFER_TRACE(jh, \"file as BJ_Reserved\");\n\t\t__journal_file_buffer(jh, transaction, BJ_Reserved);\n\t} else if (jh->b_transaction == journal->j_committing_transaction) {\n\t\t/* first access by this transaction */\n\t\tjh->b_modified = 0;\n\n\t\tJBUFFER_TRACE(jh, \"set next transaction\");\n\t\tjh->b_next_transaction = transaction;\n\t}\n\tspin_unlock(&journal->j_list_lock);\n\tjbd_unlock_bh_state(bh);\n\n\t/*\n\t * akpm: I added this.  ext3_alloc_branch can pick up new indirect\n\t * blocks which contain freed but then revoked metadata.  We need\n\t * to cancel the revoke in case we end up freeing it yet again\n\t * and the reallocating as data - this would cause a second revoke,\n\t * which hits an assertion error.\n\t */\n\tJBUFFER_TRACE(jh, \"cancelling revoke\");\n\tjournal_cancel_revoke(handle, jh);\nout:\n\tjournal_put_journal_head(jh);\n\treturn err;\n}",
    "includes": [
      "#include <linux/hrtimer.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/timer.h>",
      "#include <linux/slab.h>",
      "#include <linux/errno.h>",
      "#include <linux/jbd.h>",
      "#include <linux/fs.h>",
      "#include <linux/time.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void __journal_temp_unlink_buffer(struct journal_head *jh);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "journal_put_journal_head",
          "args": [
            "jh"
          ],
          "line": 851
        },
        "resolved": true,
        "details": {
          "function_name": "journal_put_journal_head",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd/journal.c",
          "lines": "2020-2033",
          "snippet": "void journal_put_journal_head(struct journal_head *jh)\n{\n\tstruct buffer_head *bh = jh2bh(jh);\n\n\tjbd_lock_bh_journal_head(bh);\n\tJ_ASSERT_JH(jh, jh->b_jcount > 0);\n\t--jh->b_jcount;\n\tif (!jh->b_jcount) {\n\t\t__journal_remove_journal_head(bh);\n\t\tjbd_unlock_bh_journal_head(bh);\n\t\t__brelse(bh);\n\t} else\n\t\tjbd_unlock_bh_journal_head(bh);\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <asm/uaccess.h>",
            "#include <trace/events/jbd.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/poison.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/jbd.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <trace/events/jbd.h>\n#include <linux/ratelimit.h>\n#include <linux/debugfs.h>\n#include <linux/proc_fs.h>\n#include <linux/poison.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/freezer.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nvoid journal_put_journal_head(struct journal_head *jh)\n{\n\tstruct buffer_head *bh = jh2bh(jh);\n\n\tjbd_lock_bh_journal_head(bh);\n\tJ_ASSERT_JH(jh, jh->b_jcount > 0);\n\t--jh->b_jcount;\n\tif (!jh->b_jcount) {\n\t\t__journal_remove_journal_head(bh);\n\t\tjbd_unlock_bh_journal_head(bh);\n\t\t__brelse(bh);\n\t} else\n\t\tjbd_unlock_bh_journal_head(bh);\n}"
        }
      },
      {
        "call_info": {
          "callee": "journal_cancel_revoke",
          "args": [
            "handle",
            "jh"
          ],
          "line": 849
        },
        "resolved": true,
        "details": {
          "function_name": "journal_cancel_revoke",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd/revoke.c",
          "lines": "423-477",
          "snippet": "int journal_cancel_revoke(handle_t *handle, struct journal_head *jh)\n{\n\tstruct jbd_revoke_record_s *record;\n\tjournal_t *journal = handle->h_transaction->t_journal;\n\tint need_cancel;\n\tint did_revoke = 0;\t/* akpm: debug */\n\tstruct buffer_head *bh = jh2bh(jh);\n\n\tjbd_debug(4, \"journal_head %p, cancelling revoke\\n\", jh);\n\n\t/* Is the existing Revoke bit valid?  If so, we trust it, and\n\t * only perform the full cancel if the revoke bit is set.  If\n\t * not, we can't trust the revoke bit, and we need to do the\n\t * full search for a revoke record. */\n\tif (test_set_buffer_revokevalid(bh)) {\n\t\tneed_cancel = test_clear_buffer_revoked(bh);\n\t} else {\n\t\tneed_cancel = 1;\n\t\tclear_buffer_revoked(bh);\n\t}\n\n\tif (need_cancel) {\n\t\trecord = find_revoke_record(journal, bh->b_blocknr);\n\t\tif (record) {\n\t\t\tjbd_debug(4, \"cancelled existing revoke on \"\n\t\t\t\t  \"blocknr %llu\\n\", (unsigned long long)bh->b_blocknr);\n\t\t\tspin_lock(&journal->j_revoke_lock);\n\t\t\tlist_del(&record->hash);\n\t\t\tspin_unlock(&journal->j_revoke_lock);\n\t\t\tkmem_cache_free(revoke_record_cache, record);\n\t\t\tdid_revoke = 1;\n\t\t}\n\t}\n\n#ifdef JBD_EXPENSIVE_CHECKING\n\t/* There better not be one left behind by now! */\n\trecord = find_revoke_record(journal, bh->b_blocknr);\n\tJ_ASSERT_JH(jh, record == NULL);\n#endif\n\n\t/* Finally, have we just cleared revoke on an unhashed\n\t * buffer_head?  If so, we'd better make sure we clear the\n\t * revoked status on any hashed alias too, otherwise the revoke\n\t * state machine will get very upset later on. */\n\tif (need_cancel) {\n\t\tstruct buffer_head *bh2;\n\t\tbh2 = __find_get_block(bh->b_bdev, bh->b_blocknr, bh->b_size);\n\t\tif (bh2) {\n\t\t\tif (bh2 != bh)\n\t\t\t\tclear_buffer_revoked(bh2);\n\t\t\t__brelse(bh2);\n\t\t}\n\t}\n\treturn did_revoke;\n}",
          "includes": [
            "#include <linux/hash.h>",
            "#include <linux/log2.h>",
            "#include <linux/bio.h>",
            "#include <linux/init.h>",
            "#include <linux/list.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/jbd.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include \"jfs_user.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *revoke_record_cache;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/hash.h>\n#include <linux/log2.h>\n#include <linux/bio.h>\n#include <linux/init.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include \"jfs_user.h\"\n\nstatic struct kmem_cache *revoke_record_cache;\n\nint journal_cancel_revoke(handle_t *handle, struct journal_head *jh)\n{\n\tstruct jbd_revoke_record_s *record;\n\tjournal_t *journal = handle->h_transaction->t_journal;\n\tint need_cancel;\n\tint did_revoke = 0;\t/* akpm: debug */\n\tstruct buffer_head *bh = jh2bh(jh);\n\n\tjbd_debug(4, \"journal_head %p, cancelling revoke\\n\", jh);\n\n\t/* Is the existing Revoke bit valid?  If so, we trust it, and\n\t * only perform the full cancel if the revoke bit is set.  If\n\t * not, we can't trust the revoke bit, and we need to do the\n\t * full search for a revoke record. */\n\tif (test_set_buffer_revokevalid(bh)) {\n\t\tneed_cancel = test_clear_buffer_revoked(bh);\n\t} else {\n\t\tneed_cancel = 1;\n\t\tclear_buffer_revoked(bh);\n\t}\n\n\tif (need_cancel) {\n\t\trecord = find_revoke_record(journal, bh->b_blocknr);\n\t\tif (record) {\n\t\t\tjbd_debug(4, \"cancelled existing revoke on \"\n\t\t\t\t  \"blocknr %llu\\n\", (unsigned long long)bh->b_blocknr);\n\t\t\tspin_lock(&journal->j_revoke_lock);\n\t\t\tlist_del(&record->hash);\n\t\t\tspin_unlock(&journal->j_revoke_lock);\n\t\t\tkmem_cache_free(revoke_record_cache, record);\n\t\t\tdid_revoke = 1;\n\t\t}\n\t}\n\n#ifdef JBD_EXPENSIVE_CHECKING\n\t/* There better not be one left behind by now! */\n\trecord = find_revoke_record(journal, bh->b_blocknr);\n\tJ_ASSERT_JH(jh, record == NULL);\n#endif\n\n\t/* Finally, have we just cleared revoke on an unhashed\n\t * buffer_head?  If so, we'd better make sure we clear the\n\t * revoked status on any hashed alias too, otherwise the revoke\n\t * state machine will get very upset later on. */\n\tif (need_cancel) {\n\t\tstruct buffer_head *bh2;\n\t\tbh2 = __find_get_block(bh->b_bdev, bh->b_blocknr, bh->b_size);\n\t\tif (bh2) {\n\t\t\tif (bh2 != bh)\n\t\t\t\tclear_buffer_revoked(bh2);\n\t\t\t__brelse(bh2);\n\t\t}\n\t}\n\treturn did_revoke;\n}"
        }
      },
      {
        "call_info": {
          "callee": "JBUFFER_TRACE",
          "args": [
            "jh",
            "\"cancelling revoke\""
          ],
          "line": 848
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "jbd_unlock_bh_state",
          "args": [
            "bh"
          ],
          "line": 839
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&journal->j_list_lock"
          ],
          "line": 838
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "JBUFFER_TRACE",
          "args": [
            "jh",
            "\"set next transaction\""
          ],
          "line": 835
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__journal_file_buffer",
          "args": [
            "jh",
            "transaction",
            "BJ_Reserved"
          ],
          "line": 830
        },
        "resolved": true,
        "details": {
          "function_name": "__journal_file_buffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd/transaction.c",
          "lines": "2078-2154",
          "snippet": "void __journal_file_buffer(struct journal_head *jh,\n\t\t\ttransaction_t *transaction, int jlist)\n{\n\tstruct journal_head **list = NULL;\n\tint was_dirty = 0;\n\tstruct buffer_head *bh = jh2bh(jh);\n\n\tJ_ASSERT_JH(jh, jbd_is_locked_bh_state(bh));\n\tassert_spin_locked(&transaction->t_journal->j_list_lock);\n\n\tJ_ASSERT_JH(jh, jh->b_jlist < BJ_Types);\n\tJ_ASSERT_JH(jh, jh->b_transaction == transaction ||\n\t\t\t\tjh->b_transaction == NULL);\n\n\tif (jh->b_transaction && jh->b_jlist == jlist)\n\t\treturn;\n\n\tif (jlist == BJ_Metadata || jlist == BJ_Reserved ||\n\t    jlist == BJ_Shadow || jlist == BJ_Forget) {\n\t\t/*\n\t\t * For metadata buffers, we track dirty bit in buffer_jbddirty\n\t\t * instead of buffer_dirty. We should not see a dirty bit set\n\t\t * here because we clear it in do_get_write_access but e.g.\n\t\t * tune2fs can modify the sb and set the dirty bit at any time\n\t\t * so we try to gracefully handle that.\n\t\t */\n\t\tif (buffer_dirty(bh))\n\t\t\twarn_dirty_buffer(bh);\n\t\tif (test_clear_buffer_dirty(bh) ||\n\t\t    test_clear_buffer_jbddirty(bh))\n\t\t\twas_dirty = 1;\n\t}\n\n\tif (jh->b_transaction)\n\t\t__journal_temp_unlink_buffer(jh);\n\telse\n\t\tjournal_grab_journal_head(bh);\n\tjh->b_transaction = transaction;\n\n\tswitch (jlist) {\n\tcase BJ_None:\n\t\tJ_ASSERT_JH(jh, !jh->b_committed_data);\n\t\tJ_ASSERT_JH(jh, !jh->b_frozen_data);\n\t\treturn;\n\tcase BJ_SyncData:\n\t\tlist = &transaction->t_sync_datalist;\n\t\tbreak;\n\tcase BJ_Metadata:\n\t\ttransaction->t_nr_buffers++;\n\t\tlist = &transaction->t_buffers;\n\t\tbreak;\n\tcase BJ_Forget:\n\t\tlist = &transaction->t_forget;\n\t\tbreak;\n\tcase BJ_IO:\n\t\tlist = &transaction->t_iobuf_list;\n\t\tbreak;\n\tcase BJ_Shadow:\n\t\tlist = &transaction->t_shadow_list;\n\t\tbreak;\n\tcase BJ_LogCtl:\n\t\tlist = &transaction->t_log_list;\n\t\tbreak;\n\tcase BJ_Reserved:\n\t\tlist = &transaction->t_reserved_list;\n\t\tbreak;\n\tcase BJ_Locked:\n\t\tlist =  &transaction->t_locked_list;\n\t\tbreak;\n\t}\n\n\t__blist_add_buffer(list, jh);\n\tjh->b_jlist = jlist;\n\n\tif (was_dirty)\n\t\tset_buffer_jbddirty(bh);\n}",
          "includes": [
            "#include <linux/hrtimer.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/timer.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/jbd.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __journal_temp_unlink_buffer(struct journal_head *jh);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/timer.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n\nstatic void __journal_temp_unlink_buffer(struct journal_head *jh);\n\nvoid __journal_file_buffer(struct journal_head *jh,\n\t\t\ttransaction_t *transaction, int jlist)\n{\n\tstruct journal_head **list = NULL;\n\tint was_dirty = 0;\n\tstruct buffer_head *bh = jh2bh(jh);\n\n\tJ_ASSERT_JH(jh, jbd_is_locked_bh_state(bh));\n\tassert_spin_locked(&transaction->t_journal->j_list_lock);\n\n\tJ_ASSERT_JH(jh, jh->b_jlist < BJ_Types);\n\tJ_ASSERT_JH(jh, jh->b_transaction == transaction ||\n\t\t\t\tjh->b_transaction == NULL);\n\n\tif (jh->b_transaction && jh->b_jlist == jlist)\n\t\treturn;\n\n\tif (jlist == BJ_Metadata || jlist == BJ_Reserved ||\n\t    jlist == BJ_Shadow || jlist == BJ_Forget) {\n\t\t/*\n\t\t * For metadata buffers, we track dirty bit in buffer_jbddirty\n\t\t * instead of buffer_dirty. We should not see a dirty bit set\n\t\t * here because we clear it in do_get_write_access but e.g.\n\t\t * tune2fs can modify the sb and set the dirty bit at any time\n\t\t * so we try to gracefully handle that.\n\t\t */\n\t\tif (buffer_dirty(bh))\n\t\t\twarn_dirty_buffer(bh);\n\t\tif (test_clear_buffer_dirty(bh) ||\n\t\t    test_clear_buffer_jbddirty(bh))\n\t\t\twas_dirty = 1;\n\t}\n\n\tif (jh->b_transaction)\n\t\t__journal_temp_unlink_buffer(jh);\n\telse\n\t\tjournal_grab_journal_head(bh);\n\tjh->b_transaction = transaction;\n\n\tswitch (jlist) {\n\tcase BJ_None:\n\t\tJ_ASSERT_JH(jh, !jh->b_committed_data);\n\t\tJ_ASSERT_JH(jh, !jh->b_frozen_data);\n\t\treturn;\n\tcase BJ_SyncData:\n\t\tlist = &transaction->t_sync_datalist;\n\t\tbreak;\n\tcase BJ_Metadata:\n\t\ttransaction->t_nr_buffers++;\n\t\tlist = &transaction->t_buffers;\n\t\tbreak;\n\tcase BJ_Forget:\n\t\tlist = &transaction->t_forget;\n\t\tbreak;\n\tcase BJ_IO:\n\t\tlist = &transaction->t_iobuf_list;\n\t\tbreak;\n\tcase BJ_Shadow:\n\t\tlist = &transaction->t_shadow_list;\n\t\tbreak;\n\tcase BJ_LogCtl:\n\t\tlist = &transaction->t_log_list;\n\t\tbreak;\n\tcase BJ_Reserved:\n\t\tlist = &transaction->t_reserved_list;\n\t\tbreak;\n\tcase BJ_Locked:\n\t\tlist =  &transaction->t_locked_list;\n\t\tbreak;\n\t}\n\n\t__blist_add_buffer(list, jh);\n\tjh->b_jlist = jlist;\n\n\tif (was_dirty)\n\t\tset_buffer_jbddirty(bh);\n}"
        }
      },
      {
        "call_info": {
          "callee": "JBUFFER_TRACE",
          "args": [
            "jh",
            "\"file as BJ_Reserved\""
          ],
          "line": 829
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clear_buffer_dirty",
          "args": [
            "jh2bh(jh)"
          ],
          "line": 824
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "jh2bh",
          "args": [
            "jh"
          ],
          "line": 824
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "J_ASSERT_JH",
          "args": [
            "jh",
            "buffer_locked(jh2bh(jh))"
          ],
          "line": 813
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "buffer_locked",
          "args": [
            "jh2bh(jh)"
          ],
          "line": 813
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "jh2bh",
          "args": [
            "jh"
          ],
          "line": 813
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "J_ASSERT_JH",
          "args": [
            "jh",
            "jh->b_next_transaction == NULL"
          ],
          "line": 812
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "J_ASSERT_JH",
          "args": [
            "jh",
            "(jh->b_transaction == transaction ||\n\t\tjh->b_transaction == NULL ||\n\t\t(jh->b_transaction == journal->j_committing_transaction &&\n\t\t\t  jh->b_jlist == BJ_Forget))"
          ],
          "line": 807
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&journal->j_list_lock"
          ],
          "line": 806
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "jbd_lock_bh_state",
          "args": [
            "bh"
          ],
          "line": 805
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "JBUFFER_TRACE",
          "args": [
            "jh",
            "\"entry\""
          ],
          "line": 797
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_handle_aborted",
          "args": [
            "handle"
          ],
          "line": 793
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "jbd_debug",
          "args": [
            "5",
            "\"journal_head %p\\n\"",
            "jh"
          ],
          "line": 791
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "journal_add_journal_head",
          "args": [
            "bh"
          ],
          "line": 788
        },
        "resolved": true,
        "details": {
          "function_name": "journal_add_journal_head",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd/journal.c",
          "lines": "1936-1971",
          "snippet": "struct journal_head *journal_add_journal_head(struct buffer_head *bh)\n{\n\tstruct journal_head *jh;\n\tstruct journal_head *new_jh = NULL;\n\nrepeat:\n\tif (!buffer_jbd(bh))\n\t\tnew_jh = journal_alloc_journal_head();\n\n\tjbd_lock_bh_journal_head(bh);\n\tif (buffer_jbd(bh)) {\n\t\tjh = bh2jh(bh);\n\t} else {\n\t\tJ_ASSERT_BH(bh,\n\t\t\t(atomic_read(&bh->b_count) > 0) ||\n\t\t\t(bh->b_page && bh->b_page->mapping));\n\n\t\tif (!new_jh) {\n\t\t\tjbd_unlock_bh_journal_head(bh);\n\t\t\tgoto repeat;\n\t\t}\n\n\t\tjh = new_jh;\n\t\tnew_jh = NULL;\t\t/* We consumed it */\n\t\tset_buffer_jbd(bh);\n\t\tbh->b_private = jh;\n\t\tjh->b_bh = bh;\n\t\tget_bh(bh);\n\t\tBUFFER_TRACE(bh, \"added journal_head\");\n\t}\n\tjh->b_jcount++;\n\tjbd_unlock_bh_journal_head(bh);\n\tif (new_jh)\n\t\tjournal_free_journal_head(new_jh);\n\treturn bh->b_private;\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <asm/uaccess.h>",
            "#include <trace/events/jbd.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/poison.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/jbd.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <trace/events/jbd.h>\n#include <linux/ratelimit.h>\n#include <linux/debugfs.h>\n#include <linux/proc_fs.h>\n#include <linux/poison.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/freezer.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nstruct journal_head *journal_add_journal_head(struct buffer_head *bh)\n{\n\tstruct journal_head *jh;\n\tstruct journal_head *new_jh = NULL;\n\nrepeat:\n\tif (!buffer_jbd(bh))\n\t\tnew_jh = journal_alloc_journal_head();\n\n\tjbd_lock_bh_journal_head(bh);\n\tif (buffer_jbd(bh)) {\n\t\tjh = bh2jh(bh);\n\t} else {\n\t\tJ_ASSERT_BH(bh,\n\t\t\t(atomic_read(&bh->b_count) > 0) ||\n\t\t\t(bh->b_page && bh->b_page->mapping));\n\n\t\tif (!new_jh) {\n\t\t\tjbd_unlock_bh_journal_head(bh);\n\t\t\tgoto repeat;\n\t\t}\n\n\t\tjh = new_jh;\n\t\tnew_jh = NULL;\t\t/* We consumed it */\n\t\tset_buffer_jbd(bh);\n\t\tbh->b_private = jh;\n\t\tjh->b_bh = bh;\n\t\tget_bh(bh);\n\t\tBUFFER_TRACE(bh, \"added journal_head\");\n\t}\n\tjh->b_jcount++;\n\tjbd_unlock_bh_journal_head(bh);\n\tif (new_jh)\n\t\tjournal_free_journal_head(new_jh);\n\treturn bh->b_private;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/timer.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n\nstatic void __journal_temp_unlink_buffer(struct journal_head *jh);\n\nint journal_get_create_access(handle_t *handle, struct buffer_head *bh)\n{\n\ttransaction_t *transaction = handle->h_transaction;\n\tjournal_t *journal = transaction->t_journal;\n\tstruct journal_head *jh = journal_add_journal_head(bh);\n\tint err;\n\n\tjbd_debug(5, \"journal_head %p\\n\", jh);\n\terr = -EROFS;\n\tif (is_handle_aborted(handle))\n\t\tgoto out;\n\terr = 0;\n\n\tJBUFFER_TRACE(jh, \"entry\");\n\t/*\n\t * The buffer may already belong to this transaction due to pre-zeroing\n\t * in the filesystem's new_block code.  It may also be on the previous,\n\t * committing transaction's lists, but it HAS to be in Forget state in\n\t * that case: the transaction must have deleted the buffer for it to be\n\t * reused here.\n\t */\n\tjbd_lock_bh_state(bh);\n\tspin_lock(&journal->j_list_lock);\n\tJ_ASSERT_JH(jh, (jh->b_transaction == transaction ||\n\t\tjh->b_transaction == NULL ||\n\t\t(jh->b_transaction == journal->j_committing_transaction &&\n\t\t\t  jh->b_jlist == BJ_Forget)));\n\n\tJ_ASSERT_JH(jh, jh->b_next_transaction == NULL);\n\tJ_ASSERT_JH(jh, buffer_locked(jh2bh(jh)));\n\n\tif (jh->b_transaction == NULL) {\n\t\t/*\n\t\t * Previous journal_forget() could have left the buffer\n\t\t * with jbddirty bit set because it was being committed. When\n\t\t * the commit finished, we've filed the buffer for\n\t\t * checkpointing and marked it dirty. Now we are reallocating\n\t\t * the buffer so the transaction freeing it must have\n\t\t * committed and so it's safe to clear the dirty bit.\n\t\t */\n\t\tclear_buffer_dirty(jh2bh(jh));\n\n\t\t/* first access by this transaction */\n\t\tjh->b_modified = 0;\n\n\t\tJBUFFER_TRACE(jh, \"file as BJ_Reserved\");\n\t\t__journal_file_buffer(jh, transaction, BJ_Reserved);\n\t} else if (jh->b_transaction == journal->j_committing_transaction) {\n\t\t/* first access by this transaction */\n\t\tjh->b_modified = 0;\n\n\t\tJBUFFER_TRACE(jh, \"set next transaction\");\n\t\tjh->b_next_transaction = transaction;\n\t}\n\tspin_unlock(&journal->j_list_lock);\n\tjbd_unlock_bh_state(bh);\n\n\t/*\n\t * akpm: I added this.  ext3_alloc_branch can pick up new indirect\n\t * blocks which contain freed but then revoked metadata.  We need\n\t * to cancel the revoke in case we end up freeing it yet again\n\t * and the reallocating as data - this would cause a second revoke,\n\t * which hits an assertion error.\n\t */\n\tJBUFFER_TRACE(jh, \"cancelling revoke\");\n\tjournal_cancel_revoke(handle, jh);\nout:\n\tjournal_put_journal_head(jh);\n\treturn err;\n}"
  },
  {
    "function_name": "journal_get_write_access",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd/transaction.c",
    "lines": "751-762",
    "snippet": "int journal_get_write_access(handle_t *handle, struct buffer_head *bh)\n{\n\tstruct journal_head *jh = journal_add_journal_head(bh);\n\tint rc;\n\n\t/* We do not want to get caught playing with fields which the\n\t * log thread also manipulates.  Make sure that the buffer\n\t * completes any outstanding IO before proceeding. */\n\trc = do_get_write_access(handle, jh, 0);\n\tjournal_put_journal_head(jh);\n\treturn rc;\n}",
    "includes": [
      "#include <linux/hrtimer.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/timer.h>",
      "#include <linux/slab.h>",
      "#include <linux/errno.h>",
      "#include <linux/jbd.h>",
      "#include <linux/fs.h>",
      "#include <linux/time.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void __journal_temp_unlink_buffer(struct journal_head *jh);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "journal_put_journal_head",
          "args": [
            "jh"
          ],
          "line": 760
        },
        "resolved": true,
        "details": {
          "function_name": "journal_put_journal_head",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd/journal.c",
          "lines": "2020-2033",
          "snippet": "void journal_put_journal_head(struct journal_head *jh)\n{\n\tstruct buffer_head *bh = jh2bh(jh);\n\n\tjbd_lock_bh_journal_head(bh);\n\tJ_ASSERT_JH(jh, jh->b_jcount > 0);\n\t--jh->b_jcount;\n\tif (!jh->b_jcount) {\n\t\t__journal_remove_journal_head(bh);\n\t\tjbd_unlock_bh_journal_head(bh);\n\t\t__brelse(bh);\n\t} else\n\t\tjbd_unlock_bh_journal_head(bh);\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <asm/uaccess.h>",
            "#include <trace/events/jbd.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/poison.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/jbd.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <trace/events/jbd.h>\n#include <linux/ratelimit.h>\n#include <linux/debugfs.h>\n#include <linux/proc_fs.h>\n#include <linux/poison.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/freezer.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nvoid journal_put_journal_head(struct journal_head *jh)\n{\n\tstruct buffer_head *bh = jh2bh(jh);\n\n\tjbd_lock_bh_journal_head(bh);\n\tJ_ASSERT_JH(jh, jh->b_jcount > 0);\n\t--jh->b_jcount;\n\tif (!jh->b_jcount) {\n\t\t__journal_remove_journal_head(bh);\n\t\tjbd_unlock_bh_journal_head(bh);\n\t\t__brelse(bh);\n\t} else\n\t\tjbd_unlock_bh_journal_head(bh);\n}"
        }
      },
      {
        "call_info": {
          "callee": "do_get_write_access",
          "args": [
            "handle",
            "jh",
            "0"
          ],
          "line": 759
        },
        "resolved": true,
        "details": {
          "function_name": "do_get_write_access",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd/transaction.c",
          "lines": "518-738",
          "snippet": "static int\ndo_get_write_access(handle_t *handle, struct journal_head *jh,\n\t\t\tint force_copy)\n{\n\tstruct buffer_head *bh;\n\ttransaction_t *transaction;\n\tjournal_t *journal;\n\tint error;\n\tchar *frozen_buffer = NULL;\n\tint need_copy = 0;\n\n\tif (is_handle_aborted(handle))\n\t\treturn -EROFS;\n\n\ttransaction = handle->h_transaction;\n\tjournal = transaction->t_journal;\n\n\tjbd_debug(5, \"journal_head %p, force_copy %d\\n\", jh, force_copy);\n\n\tJBUFFER_TRACE(jh, \"entry\");\nrepeat:\n\tbh = jh2bh(jh);\n\n\t/* @@@ Need to check for errors here at some point. */\n\n\tlock_buffer(bh);\n\tjbd_lock_bh_state(bh);\n\n\t/* We now hold the buffer lock so it is safe to query the buffer\n\t * state.  Is the buffer dirty?\n\t *\n\t * If so, there are two possibilities.  The buffer may be\n\t * non-journaled, and undergoing a quite legitimate writeback.\n\t * Otherwise, it is journaled, and we don't expect dirty buffers\n\t * in that state (the buffers should be marked JBD_Dirty\n\t * instead.)  So either the IO is being done under our own\n\t * control and this is a bug, or it's a third party IO such as\n\t * dump(8) (which may leave the buffer scheduled for read ---\n\t * ie. locked but not dirty) or tune2fs (which may actually have\n\t * the buffer dirtied, ugh.)  */\n\n\tif (buffer_dirty(bh)) {\n\t\t/*\n\t\t * First question: is this buffer already part of the current\n\t\t * transaction or the existing committing transaction?\n\t\t */\n\t\tif (jh->b_transaction) {\n\t\t\tJ_ASSERT_JH(jh,\n\t\t\t\tjh->b_transaction == transaction ||\n\t\t\t\tjh->b_transaction ==\n\t\t\t\t\tjournal->j_committing_transaction);\n\t\t\tif (jh->b_next_transaction)\n\t\t\t\tJ_ASSERT_JH(jh, jh->b_next_transaction ==\n\t\t\t\t\t\t\ttransaction);\n\t\t\twarn_dirty_buffer(bh);\n\t\t}\n\t\t/*\n\t\t * In any case we need to clean the dirty flag and we must\n\t\t * do it under the buffer lock to be sure we don't race\n\t\t * with running write-out.\n\t\t */\n\t\tJBUFFER_TRACE(jh, \"Journalling dirty buffer\");\n\t\tclear_buffer_dirty(bh);\n\t\tset_buffer_jbddirty(bh);\n\t}\n\n\tunlock_buffer(bh);\n\n\terror = -EROFS;\n\tif (is_handle_aborted(handle)) {\n\t\tjbd_unlock_bh_state(bh);\n\t\tgoto out;\n\t}\n\terror = 0;\n\n\t/*\n\t * The buffer is already part of this transaction if b_transaction or\n\t * b_next_transaction points to it\n\t */\n\tif (jh->b_transaction == transaction ||\n\t    jh->b_next_transaction == transaction)\n\t\tgoto done;\n\n\t/*\n\t * this is the first time this transaction is touching this buffer,\n\t * reset the modified flag\n\t */\n\tjh->b_modified = 0;\n\n\t/*\n\t * If there is already a copy-out version of this buffer, then we don't\n\t * need to make another one\n\t */\n\tif (jh->b_frozen_data) {\n\t\tJBUFFER_TRACE(jh, \"has frozen data\");\n\t\tJ_ASSERT_JH(jh, jh->b_next_transaction == NULL);\n\t\tjh->b_next_transaction = transaction;\n\t\tgoto done;\n\t}\n\n\t/* Is there data here we need to preserve? */\n\n\tif (jh->b_transaction && jh->b_transaction != transaction) {\n\t\tJBUFFER_TRACE(jh, \"owned by older transaction\");\n\t\tJ_ASSERT_JH(jh, jh->b_next_transaction == NULL);\n\t\tJ_ASSERT_JH(jh, jh->b_transaction ==\n\t\t\t\t\tjournal->j_committing_transaction);\n\n\t\t/* There is one case we have to be very careful about.\n\t\t * If the committing transaction is currently writing\n\t\t * this buffer out to disk and has NOT made a copy-out,\n\t\t * then we cannot modify the buffer contents at all\n\t\t * right now.  The essence of copy-out is that it is the\n\t\t * extra copy, not the primary copy, which gets\n\t\t * journaled.  If the primary copy is already going to\n\t\t * disk then we cannot do copy-out here. */\n\n\t\tif (jh->b_jlist == BJ_Shadow) {\n\t\t\tDEFINE_WAIT_BIT(wait, &bh->b_state, BH_Unshadow);\n\t\t\twait_queue_head_t *wqh;\n\n\t\t\twqh = bit_waitqueue(&bh->b_state, BH_Unshadow);\n\n\t\t\tJBUFFER_TRACE(jh, \"on shadow: sleep\");\n\t\t\tjbd_unlock_bh_state(bh);\n\t\t\t/* commit wakes up all shadow buffers after IO */\n\t\t\tfor ( ; ; ) {\n\t\t\t\tprepare_to_wait(wqh, &wait.wait,\n\t\t\t\t\t\tTASK_UNINTERRUPTIBLE);\n\t\t\t\tif (jh->b_jlist != BJ_Shadow)\n\t\t\t\t\tbreak;\n\t\t\t\tschedule();\n\t\t\t}\n\t\t\tfinish_wait(wqh, &wait.wait);\n\t\t\tgoto repeat;\n\t\t}\n\n\t\t/* Only do the copy if the currently-owning transaction\n\t\t * still needs it.  If it is on the Forget list, the\n\t\t * committing transaction is past that stage.  The\n\t\t * buffer had better remain locked during the kmalloc,\n\t\t * but that should be true --- we hold the journal lock\n\t\t * still and the buffer is already on the BUF_JOURNAL\n\t\t * list so won't be flushed.\n\t\t *\n\t\t * Subtle point, though: if this is a get_undo_access,\n\t\t * then we will be relying on the frozen_data to contain\n\t\t * the new value of the committed_data record after the\n\t\t * transaction, so we HAVE to force the frozen_data copy\n\t\t * in that case. */\n\n\t\tif (jh->b_jlist != BJ_Forget || force_copy) {\n\t\t\tJBUFFER_TRACE(jh, \"generate frozen data\");\n\t\t\tif (!frozen_buffer) {\n\t\t\t\tJBUFFER_TRACE(jh, \"allocate memory for buffer\");\n\t\t\t\tjbd_unlock_bh_state(bh);\n\t\t\t\tfrozen_buffer =\n\t\t\t\t\tjbd_alloc(jh2bh(jh)->b_size,\n\t\t\t\t\t\t\t GFP_NOFS);\n\t\t\t\tif (!frozen_buffer) {\n\t\t\t\t\tprintk(KERN_ERR\n\t\t\t\t\t       \"%s: OOM for frozen_buffer\\n\",\n\t\t\t\t\t       __func__);\n\t\t\t\t\tJBUFFER_TRACE(jh, \"oom!\");\n\t\t\t\t\terror = -ENOMEM;\n\t\t\t\t\tjbd_lock_bh_state(bh);\n\t\t\t\t\tgoto done;\n\t\t\t\t}\n\t\t\t\tgoto repeat;\n\t\t\t}\n\t\t\tjh->b_frozen_data = frozen_buffer;\n\t\t\tfrozen_buffer = NULL;\n\t\t\tneed_copy = 1;\n\t\t}\n\t\tjh->b_next_transaction = transaction;\n\t}\n\n\n\t/*\n\t * Finally, if the buffer is not journaled right now, we need to make\n\t * sure it doesn't get written to disk before the caller actually\n\t * commits the new data\n\t */\n\tif (!jh->b_transaction) {\n\t\tJBUFFER_TRACE(jh, \"no transaction\");\n\t\tJ_ASSERT_JH(jh, !jh->b_next_transaction);\n\t\tJBUFFER_TRACE(jh, \"file as BJ_Reserved\");\n\t\tspin_lock(&journal->j_list_lock);\n\t\t__journal_file_buffer(jh, transaction, BJ_Reserved);\n\t\tspin_unlock(&journal->j_list_lock);\n\t}\n\ndone:\n\tif (need_copy) {\n\t\tstruct page *page;\n\t\tint offset;\n\t\tchar *source;\n\n\t\tJ_EXPECT_JH(jh, buffer_uptodate(jh2bh(jh)),\n\t\t\t    \"Possible IO failure.\\n\");\n\t\tpage = jh2bh(jh)->b_page;\n\t\toffset = offset_in_page(jh2bh(jh)->b_data);\n\t\tsource = kmap_atomic(page);\n\t\tmemcpy(jh->b_frozen_data, source+offset, jh2bh(jh)->b_size);\n\t\tkunmap_atomic(source);\n\t}\n\tjbd_unlock_bh_state(bh);\n\n\t/*\n\t * If we are about to journal a buffer, then any revoke pending on it is\n\t * no longer valid\n\t */\n\tjournal_cancel_revoke(handle, jh);\n\nout:\n\tif (unlikely(frozen_buffer))\t/* It's usually NULL */\n\t\tjbd_free(frozen_buffer, bh->b_size);\n\n\tJBUFFER_TRACE(jh, \"exit\");\n\treturn error;\n}",
          "includes": [
            "#include <linux/hrtimer.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/timer.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/jbd.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __journal_temp_unlink_buffer(struct journal_head *jh);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/timer.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n\nstatic void __journal_temp_unlink_buffer(struct journal_head *jh);\n\nstatic int\ndo_get_write_access(handle_t *handle, struct journal_head *jh,\n\t\t\tint force_copy)\n{\n\tstruct buffer_head *bh;\n\ttransaction_t *transaction;\n\tjournal_t *journal;\n\tint error;\n\tchar *frozen_buffer = NULL;\n\tint need_copy = 0;\n\n\tif (is_handle_aborted(handle))\n\t\treturn -EROFS;\n\n\ttransaction = handle->h_transaction;\n\tjournal = transaction->t_journal;\n\n\tjbd_debug(5, \"journal_head %p, force_copy %d\\n\", jh, force_copy);\n\n\tJBUFFER_TRACE(jh, \"entry\");\nrepeat:\n\tbh = jh2bh(jh);\n\n\t/* @@@ Need to check for errors here at some point. */\n\n\tlock_buffer(bh);\n\tjbd_lock_bh_state(bh);\n\n\t/* We now hold the buffer lock so it is safe to query the buffer\n\t * state.  Is the buffer dirty?\n\t *\n\t * If so, there are two possibilities.  The buffer may be\n\t * non-journaled, and undergoing a quite legitimate writeback.\n\t * Otherwise, it is journaled, and we don't expect dirty buffers\n\t * in that state (the buffers should be marked JBD_Dirty\n\t * instead.)  So either the IO is being done under our own\n\t * control and this is a bug, or it's a third party IO such as\n\t * dump(8) (which may leave the buffer scheduled for read ---\n\t * ie. locked but not dirty) or tune2fs (which may actually have\n\t * the buffer dirtied, ugh.)  */\n\n\tif (buffer_dirty(bh)) {\n\t\t/*\n\t\t * First question: is this buffer already part of the current\n\t\t * transaction or the existing committing transaction?\n\t\t */\n\t\tif (jh->b_transaction) {\n\t\t\tJ_ASSERT_JH(jh,\n\t\t\t\tjh->b_transaction == transaction ||\n\t\t\t\tjh->b_transaction ==\n\t\t\t\t\tjournal->j_committing_transaction);\n\t\t\tif (jh->b_next_transaction)\n\t\t\t\tJ_ASSERT_JH(jh, jh->b_next_transaction ==\n\t\t\t\t\t\t\ttransaction);\n\t\t\twarn_dirty_buffer(bh);\n\t\t}\n\t\t/*\n\t\t * In any case we need to clean the dirty flag and we must\n\t\t * do it under the buffer lock to be sure we don't race\n\t\t * with running write-out.\n\t\t */\n\t\tJBUFFER_TRACE(jh, \"Journalling dirty buffer\");\n\t\tclear_buffer_dirty(bh);\n\t\tset_buffer_jbddirty(bh);\n\t}\n\n\tunlock_buffer(bh);\n\n\terror = -EROFS;\n\tif (is_handle_aborted(handle)) {\n\t\tjbd_unlock_bh_state(bh);\n\t\tgoto out;\n\t}\n\terror = 0;\n\n\t/*\n\t * The buffer is already part of this transaction if b_transaction or\n\t * b_next_transaction points to it\n\t */\n\tif (jh->b_transaction == transaction ||\n\t    jh->b_next_transaction == transaction)\n\t\tgoto done;\n\n\t/*\n\t * this is the first time this transaction is touching this buffer,\n\t * reset the modified flag\n\t */\n\tjh->b_modified = 0;\n\n\t/*\n\t * If there is already a copy-out version of this buffer, then we don't\n\t * need to make another one\n\t */\n\tif (jh->b_frozen_data) {\n\t\tJBUFFER_TRACE(jh, \"has frozen data\");\n\t\tJ_ASSERT_JH(jh, jh->b_next_transaction == NULL);\n\t\tjh->b_next_transaction = transaction;\n\t\tgoto done;\n\t}\n\n\t/* Is there data here we need to preserve? */\n\n\tif (jh->b_transaction && jh->b_transaction != transaction) {\n\t\tJBUFFER_TRACE(jh, \"owned by older transaction\");\n\t\tJ_ASSERT_JH(jh, jh->b_next_transaction == NULL);\n\t\tJ_ASSERT_JH(jh, jh->b_transaction ==\n\t\t\t\t\tjournal->j_committing_transaction);\n\n\t\t/* There is one case we have to be very careful about.\n\t\t * If the committing transaction is currently writing\n\t\t * this buffer out to disk and has NOT made a copy-out,\n\t\t * then we cannot modify the buffer contents at all\n\t\t * right now.  The essence of copy-out is that it is the\n\t\t * extra copy, not the primary copy, which gets\n\t\t * journaled.  If the primary copy is already going to\n\t\t * disk then we cannot do copy-out here. */\n\n\t\tif (jh->b_jlist == BJ_Shadow) {\n\t\t\tDEFINE_WAIT_BIT(wait, &bh->b_state, BH_Unshadow);\n\t\t\twait_queue_head_t *wqh;\n\n\t\t\twqh = bit_waitqueue(&bh->b_state, BH_Unshadow);\n\n\t\t\tJBUFFER_TRACE(jh, \"on shadow: sleep\");\n\t\t\tjbd_unlock_bh_state(bh);\n\t\t\t/* commit wakes up all shadow buffers after IO */\n\t\t\tfor ( ; ; ) {\n\t\t\t\tprepare_to_wait(wqh, &wait.wait,\n\t\t\t\t\t\tTASK_UNINTERRUPTIBLE);\n\t\t\t\tif (jh->b_jlist != BJ_Shadow)\n\t\t\t\t\tbreak;\n\t\t\t\tschedule();\n\t\t\t}\n\t\t\tfinish_wait(wqh, &wait.wait);\n\t\t\tgoto repeat;\n\t\t}\n\n\t\t/* Only do the copy if the currently-owning transaction\n\t\t * still needs it.  If it is on the Forget list, the\n\t\t * committing transaction is past that stage.  The\n\t\t * buffer had better remain locked during the kmalloc,\n\t\t * but that should be true --- we hold the journal lock\n\t\t * still and the buffer is already on the BUF_JOURNAL\n\t\t * list so won't be flushed.\n\t\t *\n\t\t * Subtle point, though: if this is a get_undo_access,\n\t\t * then we will be relying on the frozen_data to contain\n\t\t * the new value of the committed_data record after the\n\t\t * transaction, so we HAVE to force the frozen_data copy\n\t\t * in that case. */\n\n\t\tif (jh->b_jlist != BJ_Forget || force_copy) {\n\t\t\tJBUFFER_TRACE(jh, \"generate frozen data\");\n\t\t\tif (!frozen_buffer) {\n\t\t\t\tJBUFFER_TRACE(jh, \"allocate memory for buffer\");\n\t\t\t\tjbd_unlock_bh_state(bh);\n\t\t\t\tfrozen_buffer =\n\t\t\t\t\tjbd_alloc(jh2bh(jh)->b_size,\n\t\t\t\t\t\t\t GFP_NOFS);\n\t\t\t\tif (!frozen_buffer) {\n\t\t\t\t\tprintk(KERN_ERR\n\t\t\t\t\t       \"%s: OOM for frozen_buffer\\n\",\n\t\t\t\t\t       __func__);\n\t\t\t\t\tJBUFFER_TRACE(jh, \"oom!\");\n\t\t\t\t\terror = -ENOMEM;\n\t\t\t\t\tjbd_lock_bh_state(bh);\n\t\t\t\t\tgoto done;\n\t\t\t\t}\n\t\t\t\tgoto repeat;\n\t\t\t}\n\t\t\tjh->b_frozen_data = frozen_buffer;\n\t\t\tfrozen_buffer = NULL;\n\t\t\tneed_copy = 1;\n\t\t}\n\t\tjh->b_next_transaction = transaction;\n\t}\n\n\n\t/*\n\t * Finally, if the buffer is not journaled right now, we need to make\n\t * sure it doesn't get written to disk before the caller actually\n\t * commits the new data\n\t */\n\tif (!jh->b_transaction) {\n\t\tJBUFFER_TRACE(jh, \"no transaction\");\n\t\tJ_ASSERT_JH(jh, !jh->b_next_transaction);\n\t\tJBUFFER_TRACE(jh, \"file as BJ_Reserved\");\n\t\tspin_lock(&journal->j_list_lock);\n\t\t__journal_file_buffer(jh, transaction, BJ_Reserved);\n\t\tspin_unlock(&journal->j_list_lock);\n\t}\n\ndone:\n\tif (need_copy) {\n\t\tstruct page *page;\n\t\tint offset;\n\t\tchar *source;\n\n\t\tJ_EXPECT_JH(jh, buffer_uptodate(jh2bh(jh)),\n\t\t\t    \"Possible IO failure.\\n\");\n\t\tpage = jh2bh(jh)->b_page;\n\t\toffset = offset_in_page(jh2bh(jh)->b_data);\n\t\tsource = kmap_atomic(page);\n\t\tmemcpy(jh->b_frozen_data, source+offset, jh2bh(jh)->b_size);\n\t\tkunmap_atomic(source);\n\t}\n\tjbd_unlock_bh_state(bh);\n\n\t/*\n\t * If we are about to journal a buffer, then any revoke pending on it is\n\t * no longer valid\n\t */\n\tjournal_cancel_revoke(handle, jh);\n\nout:\n\tif (unlikely(frozen_buffer))\t/* It's usually NULL */\n\t\tjbd_free(frozen_buffer, bh->b_size);\n\n\tJBUFFER_TRACE(jh, \"exit\");\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "journal_add_journal_head",
          "args": [
            "bh"
          ],
          "line": 753
        },
        "resolved": true,
        "details": {
          "function_name": "journal_add_journal_head",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd/journal.c",
          "lines": "1936-1971",
          "snippet": "struct journal_head *journal_add_journal_head(struct buffer_head *bh)\n{\n\tstruct journal_head *jh;\n\tstruct journal_head *new_jh = NULL;\n\nrepeat:\n\tif (!buffer_jbd(bh))\n\t\tnew_jh = journal_alloc_journal_head();\n\n\tjbd_lock_bh_journal_head(bh);\n\tif (buffer_jbd(bh)) {\n\t\tjh = bh2jh(bh);\n\t} else {\n\t\tJ_ASSERT_BH(bh,\n\t\t\t(atomic_read(&bh->b_count) > 0) ||\n\t\t\t(bh->b_page && bh->b_page->mapping));\n\n\t\tif (!new_jh) {\n\t\t\tjbd_unlock_bh_journal_head(bh);\n\t\t\tgoto repeat;\n\t\t}\n\n\t\tjh = new_jh;\n\t\tnew_jh = NULL;\t\t/* We consumed it */\n\t\tset_buffer_jbd(bh);\n\t\tbh->b_private = jh;\n\t\tjh->b_bh = bh;\n\t\tget_bh(bh);\n\t\tBUFFER_TRACE(bh, \"added journal_head\");\n\t}\n\tjh->b_jcount++;\n\tjbd_unlock_bh_journal_head(bh);\n\tif (new_jh)\n\t\tjournal_free_journal_head(new_jh);\n\treturn bh->b_private;\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <asm/uaccess.h>",
            "#include <trace/events/jbd.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/poison.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/jbd.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <trace/events/jbd.h>\n#include <linux/ratelimit.h>\n#include <linux/debugfs.h>\n#include <linux/proc_fs.h>\n#include <linux/poison.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/freezer.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nstruct journal_head *journal_add_journal_head(struct buffer_head *bh)\n{\n\tstruct journal_head *jh;\n\tstruct journal_head *new_jh = NULL;\n\nrepeat:\n\tif (!buffer_jbd(bh))\n\t\tnew_jh = journal_alloc_journal_head();\n\n\tjbd_lock_bh_journal_head(bh);\n\tif (buffer_jbd(bh)) {\n\t\tjh = bh2jh(bh);\n\t} else {\n\t\tJ_ASSERT_BH(bh,\n\t\t\t(atomic_read(&bh->b_count) > 0) ||\n\t\t\t(bh->b_page && bh->b_page->mapping));\n\n\t\tif (!new_jh) {\n\t\t\tjbd_unlock_bh_journal_head(bh);\n\t\t\tgoto repeat;\n\t\t}\n\n\t\tjh = new_jh;\n\t\tnew_jh = NULL;\t\t/* We consumed it */\n\t\tset_buffer_jbd(bh);\n\t\tbh->b_private = jh;\n\t\tjh->b_bh = bh;\n\t\tget_bh(bh);\n\t\tBUFFER_TRACE(bh, \"added journal_head\");\n\t}\n\tjh->b_jcount++;\n\tjbd_unlock_bh_journal_head(bh);\n\tif (new_jh)\n\t\tjournal_free_journal_head(new_jh);\n\treturn bh->b_private;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/timer.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n\nstatic void __journal_temp_unlink_buffer(struct journal_head *jh);\n\nint journal_get_write_access(handle_t *handle, struct buffer_head *bh)\n{\n\tstruct journal_head *jh = journal_add_journal_head(bh);\n\tint rc;\n\n\t/* We do not want to get caught playing with fields which the\n\t * log thread also manipulates.  Make sure that the buffer\n\t * completes any outstanding IO before proceeding. */\n\trc = do_get_write_access(handle, jh, 0);\n\tjournal_put_journal_head(jh);\n\treturn rc;\n}"
  },
  {
    "function_name": "do_get_write_access",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd/transaction.c",
    "lines": "518-738",
    "snippet": "static int\ndo_get_write_access(handle_t *handle, struct journal_head *jh,\n\t\t\tint force_copy)\n{\n\tstruct buffer_head *bh;\n\ttransaction_t *transaction;\n\tjournal_t *journal;\n\tint error;\n\tchar *frozen_buffer = NULL;\n\tint need_copy = 0;\n\n\tif (is_handle_aborted(handle))\n\t\treturn -EROFS;\n\n\ttransaction = handle->h_transaction;\n\tjournal = transaction->t_journal;\n\n\tjbd_debug(5, \"journal_head %p, force_copy %d\\n\", jh, force_copy);\n\n\tJBUFFER_TRACE(jh, \"entry\");\nrepeat:\n\tbh = jh2bh(jh);\n\n\t/* @@@ Need to check for errors here at some point. */\n\n\tlock_buffer(bh);\n\tjbd_lock_bh_state(bh);\n\n\t/* We now hold the buffer lock so it is safe to query the buffer\n\t * state.  Is the buffer dirty?\n\t *\n\t * If so, there are two possibilities.  The buffer may be\n\t * non-journaled, and undergoing a quite legitimate writeback.\n\t * Otherwise, it is journaled, and we don't expect dirty buffers\n\t * in that state (the buffers should be marked JBD_Dirty\n\t * instead.)  So either the IO is being done under our own\n\t * control and this is a bug, or it's a third party IO such as\n\t * dump(8) (which may leave the buffer scheduled for read ---\n\t * ie. locked but not dirty) or tune2fs (which may actually have\n\t * the buffer dirtied, ugh.)  */\n\n\tif (buffer_dirty(bh)) {\n\t\t/*\n\t\t * First question: is this buffer already part of the current\n\t\t * transaction or the existing committing transaction?\n\t\t */\n\t\tif (jh->b_transaction) {\n\t\t\tJ_ASSERT_JH(jh,\n\t\t\t\tjh->b_transaction == transaction ||\n\t\t\t\tjh->b_transaction ==\n\t\t\t\t\tjournal->j_committing_transaction);\n\t\t\tif (jh->b_next_transaction)\n\t\t\t\tJ_ASSERT_JH(jh, jh->b_next_transaction ==\n\t\t\t\t\t\t\ttransaction);\n\t\t\twarn_dirty_buffer(bh);\n\t\t}\n\t\t/*\n\t\t * In any case we need to clean the dirty flag and we must\n\t\t * do it under the buffer lock to be sure we don't race\n\t\t * with running write-out.\n\t\t */\n\t\tJBUFFER_TRACE(jh, \"Journalling dirty buffer\");\n\t\tclear_buffer_dirty(bh);\n\t\tset_buffer_jbddirty(bh);\n\t}\n\n\tunlock_buffer(bh);\n\n\terror = -EROFS;\n\tif (is_handle_aborted(handle)) {\n\t\tjbd_unlock_bh_state(bh);\n\t\tgoto out;\n\t}\n\terror = 0;\n\n\t/*\n\t * The buffer is already part of this transaction if b_transaction or\n\t * b_next_transaction points to it\n\t */\n\tif (jh->b_transaction == transaction ||\n\t    jh->b_next_transaction == transaction)\n\t\tgoto done;\n\n\t/*\n\t * this is the first time this transaction is touching this buffer,\n\t * reset the modified flag\n\t */\n\tjh->b_modified = 0;\n\n\t/*\n\t * If there is already a copy-out version of this buffer, then we don't\n\t * need to make another one\n\t */\n\tif (jh->b_frozen_data) {\n\t\tJBUFFER_TRACE(jh, \"has frozen data\");\n\t\tJ_ASSERT_JH(jh, jh->b_next_transaction == NULL);\n\t\tjh->b_next_transaction = transaction;\n\t\tgoto done;\n\t}\n\n\t/* Is there data here we need to preserve? */\n\n\tif (jh->b_transaction && jh->b_transaction != transaction) {\n\t\tJBUFFER_TRACE(jh, \"owned by older transaction\");\n\t\tJ_ASSERT_JH(jh, jh->b_next_transaction == NULL);\n\t\tJ_ASSERT_JH(jh, jh->b_transaction ==\n\t\t\t\t\tjournal->j_committing_transaction);\n\n\t\t/* There is one case we have to be very careful about.\n\t\t * If the committing transaction is currently writing\n\t\t * this buffer out to disk and has NOT made a copy-out,\n\t\t * then we cannot modify the buffer contents at all\n\t\t * right now.  The essence of copy-out is that it is the\n\t\t * extra copy, not the primary copy, which gets\n\t\t * journaled.  If the primary copy is already going to\n\t\t * disk then we cannot do copy-out here. */\n\n\t\tif (jh->b_jlist == BJ_Shadow) {\n\t\t\tDEFINE_WAIT_BIT(wait, &bh->b_state, BH_Unshadow);\n\t\t\twait_queue_head_t *wqh;\n\n\t\t\twqh = bit_waitqueue(&bh->b_state, BH_Unshadow);\n\n\t\t\tJBUFFER_TRACE(jh, \"on shadow: sleep\");\n\t\t\tjbd_unlock_bh_state(bh);\n\t\t\t/* commit wakes up all shadow buffers after IO */\n\t\t\tfor ( ; ; ) {\n\t\t\t\tprepare_to_wait(wqh, &wait.wait,\n\t\t\t\t\t\tTASK_UNINTERRUPTIBLE);\n\t\t\t\tif (jh->b_jlist != BJ_Shadow)\n\t\t\t\t\tbreak;\n\t\t\t\tschedule();\n\t\t\t}\n\t\t\tfinish_wait(wqh, &wait.wait);\n\t\t\tgoto repeat;\n\t\t}\n\n\t\t/* Only do the copy if the currently-owning transaction\n\t\t * still needs it.  If it is on the Forget list, the\n\t\t * committing transaction is past that stage.  The\n\t\t * buffer had better remain locked during the kmalloc,\n\t\t * but that should be true --- we hold the journal lock\n\t\t * still and the buffer is already on the BUF_JOURNAL\n\t\t * list so won't be flushed.\n\t\t *\n\t\t * Subtle point, though: if this is a get_undo_access,\n\t\t * then we will be relying on the frozen_data to contain\n\t\t * the new value of the committed_data record after the\n\t\t * transaction, so we HAVE to force the frozen_data copy\n\t\t * in that case. */\n\n\t\tif (jh->b_jlist != BJ_Forget || force_copy) {\n\t\t\tJBUFFER_TRACE(jh, \"generate frozen data\");\n\t\t\tif (!frozen_buffer) {\n\t\t\t\tJBUFFER_TRACE(jh, \"allocate memory for buffer\");\n\t\t\t\tjbd_unlock_bh_state(bh);\n\t\t\t\tfrozen_buffer =\n\t\t\t\t\tjbd_alloc(jh2bh(jh)->b_size,\n\t\t\t\t\t\t\t GFP_NOFS);\n\t\t\t\tif (!frozen_buffer) {\n\t\t\t\t\tprintk(KERN_ERR\n\t\t\t\t\t       \"%s: OOM for frozen_buffer\\n\",\n\t\t\t\t\t       __func__);\n\t\t\t\t\tJBUFFER_TRACE(jh, \"oom!\");\n\t\t\t\t\terror = -ENOMEM;\n\t\t\t\t\tjbd_lock_bh_state(bh);\n\t\t\t\t\tgoto done;\n\t\t\t\t}\n\t\t\t\tgoto repeat;\n\t\t\t}\n\t\t\tjh->b_frozen_data = frozen_buffer;\n\t\t\tfrozen_buffer = NULL;\n\t\t\tneed_copy = 1;\n\t\t}\n\t\tjh->b_next_transaction = transaction;\n\t}\n\n\n\t/*\n\t * Finally, if the buffer is not journaled right now, we need to make\n\t * sure it doesn't get written to disk before the caller actually\n\t * commits the new data\n\t */\n\tif (!jh->b_transaction) {\n\t\tJBUFFER_TRACE(jh, \"no transaction\");\n\t\tJ_ASSERT_JH(jh, !jh->b_next_transaction);\n\t\tJBUFFER_TRACE(jh, \"file as BJ_Reserved\");\n\t\tspin_lock(&journal->j_list_lock);\n\t\t__journal_file_buffer(jh, transaction, BJ_Reserved);\n\t\tspin_unlock(&journal->j_list_lock);\n\t}\n\ndone:\n\tif (need_copy) {\n\t\tstruct page *page;\n\t\tint offset;\n\t\tchar *source;\n\n\t\tJ_EXPECT_JH(jh, buffer_uptodate(jh2bh(jh)),\n\t\t\t    \"Possible IO failure.\\n\");\n\t\tpage = jh2bh(jh)->b_page;\n\t\toffset = offset_in_page(jh2bh(jh)->b_data);\n\t\tsource = kmap_atomic(page);\n\t\tmemcpy(jh->b_frozen_data, source+offset, jh2bh(jh)->b_size);\n\t\tkunmap_atomic(source);\n\t}\n\tjbd_unlock_bh_state(bh);\n\n\t/*\n\t * If we are about to journal a buffer, then any revoke pending on it is\n\t * no longer valid\n\t */\n\tjournal_cancel_revoke(handle, jh);\n\nout:\n\tif (unlikely(frozen_buffer))\t/* It's usually NULL */\n\t\tjbd_free(frozen_buffer, bh->b_size);\n\n\tJBUFFER_TRACE(jh, \"exit\");\n\treturn error;\n}",
    "includes": [
      "#include <linux/hrtimer.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/timer.h>",
      "#include <linux/slab.h>",
      "#include <linux/errno.h>",
      "#include <linux/jbd.h>",
      "#include <linux/fs.h>",
      "#include <linux/time.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void __journal_temp_unlink_buffer(struct journal_head *jh);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "JBUFFER_TRACE",
          "args": [
            "jh",
            "\"exit\""
          ],
          "line": 736
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "jbd_free",
          "args": [
            "frozen_buffer",
            "bh->b_size"
          ],
          "line": 734
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "frozen_buffer"
          ],
          "line": 733
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "journal_cancel_revoke",
          "args": [
            "handle",
            "jh"
          ],
          "line": 730
        },
        "resolved": true,
        "details": {
          "function_name": "journal_cancel_revoke",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd/revoke.c",
          "lines": "423-477",
          "snippet": "int journal_cancel_revoke(handle_t *handle, struct journal_head *jh)\n{\n\tstruct jbd_revoke_record_s *record;\n\tjournal_t *journal = handle->h_transaction->t_journal;\n\tint need_cancel;\n\tint did_revoke = 0;\t/* akpm: debug */\n\tstruct buffer_head *bh = jh2bh(jh);\n\n\tjbd_debug(4, \"journal_head %p, cancelling revoke\\n\", jh);\n\n\t/* Is the existing Revoke bit valid?  If so, we trust it, and\n\t * only perform the full cancel if the revoke bit is set.  If\n\t * not, we can't trust the revoke bit, and we need to do the\n\t * full search for a revoke record. */\n\tif (test_set_buffer_revokevalid(bh)) {\n\t\tneed_cancel = test_clear_buffer_revoked(bh);\n\t} else {\n\t\tneed_cancel = 1;\n\t\tclear_buffer_revoked(bh);\n\t}\n\n\tif (need_cancel) {\n\t\trecord = find_revoke_record(journal, bh->b_blocknr);\n\t\tif (record) {\n\t\t\tjbd_debug(4, \"cancelled existing revoke on \"\n\t\t\t\t  \"blocknr %llu\\n\", (unsigned long long)bh->b_blocknr);\n\t\t\tspin_lock(&journal->j_revoke_lock);\n\t\t\tlist_del(&record->hash);\n\t\t\tspin_unlock(&journal->j_revoke_lock);\n\t\t\tkmem_cache_free(revoke_record_cache, record);\n\t\t\tdid_revoke = 1;\n\t\t}\n\t}\n\n#ifdef JBD_EXPENSIVE_CHECKING\n\t/* There better not be one left behind by now! */\n\trecord = find_revoke_record(journal, bh->b_blocknr);\n\tJ_ASSERT_JH(jh, record == NULL);\n#endif\n\n\t/* Finally, have we just cleared revoke on an unhashed\n\t * buffer_head?  If so, we'd better make sure we clear the\n\t * revoked status on any hashed alias too, otherwise the revoke\n\t * state machine will get very upset later on. */\n\tif (need_cancel) {\n\t\tstruct buffer_head *bh2;\n\t\tbh2 = __find_get_block(bh->b_bdev, bh->b_blocknr, bh->b_size);\n\t\tif (bh2) {\n\t\t\tif (bh2 != bh)\n\t\t\t\tclear_buffer_revoked(bh2);\n\t\t\t__brelse(bh2);\n\t\t}\n\t}\n\treturn did_revoke;\n}",
          "includes": [
            "#include <linux/hash.h>",
            "#include <linux/log2.h>",
            "#include <linux/bio.h>",
            "#include <linux/init.h>",
            "#include <linux/list.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/jbd.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include \"jfs_user.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *revoke_record_cache;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/hash.h>\n#include <linux/log2.h>\n#include <linux/bio.h>\n#include <linux/init.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include \"jfs_user.h\"\n\nstatic struct kmem_cache *revoke_record_cache;\n\nint journal_cancel_revoke(handle_t *handle, struct journal_head *jh)\n{\n\tstruct jbd_revoke_record_s *record;\n\tjournal_t *journal = handle->h_transaction->t_journal;\n\tint need_cancel;\n\tint did_revoke = 0;\t/* akpm: debug */\n\tstruct buffer_head *bh = jh2bh(jh);\n\n\tjbd_debug(4, \"journal_head %p, cancelling revoke\\n\", jh);\n\n\t/* Is the existing Revoke bit valid?  If so, we trust it, and\n\t * only perform the full cancel if the revoke bit is set.  If\n\t * not, we can't trust the revoke bit, and we need to do the\n\t * full search for a revoke record. */\n\tif (test_set_buffer_revokevalid(bh)) {\n\t\tneed_cancel = test_clear_buffer_revoked(bh);\n\t} else {\n\t\tneed_cancel = 1;\n\t\tclear_buffer_revoked(bh);\n\t}\n\n\tif (need_cancel) {\n\t\trecord = find_revoke_record(journal, bh->b_blocknr);\n\t\tif (record) {\n\t\t\tjbd_debug(4, \"cancelled existing revoke on \"\n\t\t\t\t  \"blocknr %llu\\n\", (unsigned long long)bh->b_blocknr);\n\t\t\tspin_lock(&journal->j_revoke_lock);\n\t\t\tlist_del(&record->hash);\n\t\t\tspin_unlock(&journal->j_revoke_lock);\n\t\t\tkmem_cache_free(revoke_record_cache, record);\n\t\t\tdid_revoke = 1;\n\t\t}\n\t}\n\n#ifdef JBD_EXPENSIVE_CHECKING\n\t/* There better not be one left behind by now! */\n\trecord = find_revoke_record(journal, bh->b_blocknr);\n\tJ_ASSERT_JH(jh, record == NULL);\n#endif\n\n\t/* Finally, have we just cleared revoke on an unhashed\n\t * buffer_head?  If so, we'd better make sure we clear the\n\t * revoked status on any hashed alias too, otherwise the revoke\n\t * state machine will get very upset later on. */\n\tif (need_cancel) {\n\t\tstruct buffer_head *bh2;\n\t\tbh2 = __find_get_block(bh->b_bdev, bh->b_blocknr, bh->b_size);\n\t\tif (bh2) {\n\t\t\tif (bh2 != bh)\n\t\t\t\tclear_buffer_revoked(bh2);\n\t\t\t__brelse(bh2);\n\t\t}\n\t}\n\treturn did_revoke;\n}"
        }
      },
      {
        "call_info": {
          "callee": "jbd_unlock_bh_state",
          "args": [
            "bh"
          ],
          "line": 724
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kunmap_atomic",
          "args": [
            "source"
          ],
          "line": 722
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "jh->b_frozen_data",
            "source+offset",
            "jh2bh(jh)->b_size"
          ],
          "line": 721
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "jh2bh",
          "args": [
            "jh"
          ],
          "line": 721
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmap_atomic",
          "args": [
            "page"
          ],
          "line": 720
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "offset_in_page",
          "args": [
            "jh2bh(jh)->b_data"
          ],
          "line": 719
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "jh2bh",
          "args": [
            "jh"
          ],
          "line": 719
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "jh2bh",
          "args": [
            "jh"
          ],
          "line": 718
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "J_EXPECT_JH",
          "args": [
            "jh",
            "buffer_uptodate(jh2bh(jh))",
            "\"Possible IO failure.\\n\""
          ],
          "line": 716
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "buffer_uptodate",
          "args": [
            "jh2bh(jh)"
          ],
          "line": 716
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_set_buffer_uptodate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/disk-io.c",
          "lines": "3758-3761",
          "snippet": "int btrfs_set_buffer_uptodate(struct extent_buffer *buf)\n{\n\treturn set_extent_buffer_uptodate(buf);\n}",
          "includes": [
            "#include <asm/cpufeature.h>",
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"raid56.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/uuid.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/migrate.h>",
            "#include <linux/slab.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/writeback.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/swap.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/cpufeature.h>\n#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"raid56.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <asm/unaligned.h>\n#include <linux/semaphore.h>\n#include <linux/uuid.h>\n#include <linux/ratelimit.h>\n#include <linux/migrate.h>\n#include <linux/slab.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/radix-tree.h>\n#include <linux/swap.h>\n#include <linux/scatterlist.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nint btrfs_set_buffer_uptodate(struct extent_buffer *buf)\n{\n\treturn set_extent_buffer_uptodate(buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "jh2bh",
          "args": [
            "jh"
          ],
          "line": 716
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&journal->j_list_lock"
          ],
          "line": 707
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "__journal_file_buffer",
          "args": [
            "jh",
            "transaction",
            "BJ_Reserved"
          ],
          "line": 706
        },
        "resolved": true,
        "details": {
          "function_name": "__journal_file_buffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd/transaction.c",
          "lines": "2078-2154",
          "snippet": "void __journal_file_buffer(struct journal_head *jh,\n\t\t\ttransaction_t *transaction, int jlist)\n{\n\tstruct journal_head **list = NULL;\n\tint was_dirty = 0;\n\tstruct buffer_head *bh = jh2bh(jh);\n\n\tJ_ASSERT_JH(jh, jbd_is_locked_bh_state(bh));\n\tassert_spin_locked(&transaction->t_journal->j_list_lock);\n\n\tJ_ASSERT_JH(jh, jh->b_jlist < BJ_Types);\n\tJ_ASSERT_JH(jh, jh->b_transaction == transaction ||\n\t\t\t\tjh->b_transaction == NULL);\n\n\tif (jh->b_transaction && jh->b_jlist == jlist)\n\t\treturn;\n\n\tif (jlist == BJ_Metadata || jlist == BJ_Reserved ||\n\t    jlist == BJ_Shadow || jlist == BJ_Forget) {\n\t\t/*\n\t\t * For metadata buffers, we track dirty bit in buffer_jbddirty\n\t\t * instead of buffer_dirty. We should not see a dirty bit set\n\t\t * here because we clear it in do_get_write_access but e.g.\n\t\t * tune2fs can modify the sb and set the dirty bit at any time\n\t\t * so we try to gracefully handle that.\n\t\t */\n\t\tif (buffer_dirty(bh))\n\t\t\twarn_dirty_buffer(bh);\n\t\tif (test_clear_buffer_dirty(bh) ||\n\t\t    test_clear_buffer_jbddirty(bh))\n\t\t\twas_dirty = 1;\n\t}\n\n\tif (jh->b_transaction)\n\t\t__journal_temp_unlink_buffer(jh);\n\telse\n\t\tjournal_grab_journal_head(bh);\n\tjh->b_transaction = transaction;\n\n\tswitch (jlist) {\n\tcase BJ_None:\n\t\tJ_ASSERT_JH(jh, !jh->b_committed_data);\n\t\tJ_ASSERT_JH(jh, !jh->b_frozen_data);\n\t\treturn;\n\tcase BJ_SyncData:\n\t\tlist = &transaction->t_sync_datalist;\n\t\tbreak;\n\tcase BJ_Metadata:\n\t\ttransaction->t_nr_buffers++;\n\t\tlist = &transaction->t_buffers;\n\t\tbreak;\n\tcase BJ_Forget:\n\t\tlist = &transaction->t_forget;\n\t\tbreak;\n\tcase BJ_IO:\n\t\tlist = &transaction->t_iobuf_list;\n\t\tbreak;\n\tcase BJ_Shadow:\n\t\tlist = &transaction->t_shadow_list;\n\t\tbreak;\n\tcase BJ_LogCtl:\n\t\tlist = &transaction->t_log_list;\n\t\tbreak;\n\tcase BJ_Reserved:\n\t\tlist = &transaction->t_reserved_list;\n\t\tbreak;\n\tcase BJ_Locked:\n\t\tlist =  &transaction->t_locked_list;\n\t\tbreak;\n\t}\n\n\t__blist_add_buffer(list, jh);\n\tjh->b_jlist = jlist;\n\n\tif (was_dirty)\n\t\tset_buffer_jbddirty(bh);\n}",
          "includes": [
            "#include <linux/hrtimer.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/timer.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/jbd.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __journal_temp_unlink_buffer(struct journal_head *jh);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/timer.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n\nstatic void __journal_temp_unlink_buffer(struct journal_head *jh);\n\nvoid __journal_file_buffer(struct journal_head *jh,\n\t\t\ttransaction_t *transaction, int jlist)\n{\n\tstruct journal_head **list = NULL;\n\tint was_dirty = 0;\n\tstruct buffer_head *bh = jh2bh(jh);\n\n\tJ_ASSERT_JH(jh, jbd_is_locked_bh_state(bh));\n\tassert_spin_locked(&transaction->t_journal->j_list_lock);\n\n\tJ_ASSERT_JH(jh, jh->b_jlist < BJ_Types);\n\tJ_ASSERT_JH(jh, jh->b_transaction == transaction ||\n\t\t\t\tjh->b_transaction == NULL);\n\n\tif (jh->b_transaction && jh->b_jlist == jlist)\n\t\treturn;\n\n\tif (jlist == BJ_Metadata || jlist == BJ_Reserved ||\n\t    jlist == BJ_Shadow || jlist == BJ_Forget) {\n\t\t/*\n\t\t * For metadata buffers, we track dirty bit in buffer_jbddirty\n\t\t * instead of buffer_dirty. We should not see a dirty bit set\n\t\t * here because we clear it in do_get_write_access but e.g.\n\t\t * tune2fs can modify the sb and set the dirty bit at any time\n\t\t * so we try to gracefully handle that.\n\t\t */\n\t\tif (buffer_dirty(bh))\n\t\t\twarn_dirty_buffer(bh);\n\t\tif (test_clear_buffer_dirty(bh) ||\n\t\t    test_clear_buffer_jbddirty(bh))\n\t\t\twas_dirty = 1;\n\t}\n\n\tif (jh->b_transaction)\n\t\t__journal_temp_unlink_buffer(jh);\n\telse\n\t\tjournal_grab_journal_head(bh);\n\tjh->b_transaction = transaction;\n\n\tswitch (jlist) {\n\tcase BJ_None:\n\t\tJ_ASSERT_JH(jh, !jh->b_committed_data);\n\t\tJ_ASSERT_JH(jh, !jh->b_frozen_data);\n\t\treturn;\n\tcase BJ_SyncData:\n\t\tlist = &transaction->t_sync_datalist;\n\t\tbreak;\n\tcase BJ_Metadata:\n\t\ttransaction->t_nr_buffers++;\n\t\tlist = &transaction->t_buffers;\n\t\tbreak;\n\tcase BJ_Forget:\n\t\tlist = &transaction->t_forget;\n\t\tbreak;\n\tcase BJ_IO:\n\t\tlist = &transaction->t_iobuf_list;\n\t\tbreak;\n\tcase BJ_Shadow:\n\t\tlist = &transaction->t_shadow_list;\n\t\tbreak;\n\tcase BJ_LogCtl:\n\t\tlist = &transaction->t_log_list;\n\t\tbreak;\n\tcase BJ_Reserved:\n\t\tlist = &transaction->t_reserved_list;\n\t\tbreak;\n\tcase BJ_Locked:\n\t\tlist =  &transaction->t_locked_list;\n\t\tbreak;\n\t}\n\n\t__blist_add_buffer(list, jh);\n\tjh->b_jlist = jlist;\n\n\tif (was_dirty)\n\t\tset_buffer_jbddirty(bh);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&journal->j_list_lock"
          ],
          "line": 705
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "JBUFFER_TRACE",
          "args": [
            "jh",
            "\"file as BJ_Reserved\""
          ],
          "line": 704
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "J_ASSERT_JH",
          "args": [
            "jh",
            "!jh->b_next_transaction"
          ],
          "line": 703
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "JBUFFER_TRACE",
          "args": [
            "jh",
            "\"no transaction\""
          ],
          "line": 702
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "jbd_lock_bh_state",
          "args": [
            "bh"
          ],
          "line": 683
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "JBUFFER_TRACE",
          "args": [
            "jh",
            "\"oom!\""
          ],
          "line": 681
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_ERR\n\t\t\t\t\t       \"%s: OOM for frozen_buffer\\n\"",
            "__func__"
          ],
          "line": 678
        },
        "resolved": true,
        "details": {
          "function_name": "compat_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/compat.c",
          "lines": "59-69",
          "snippet": "int compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/ioctls.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/aio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/mm.h>",
            "#include <linux/poll.h>",
            "#include <linux/signal.h>",
            "#include <linux/highmem.h>",
            "#include <linux/security.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/personality.h>",
            "#include <linux/highuid.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/dirent.h>",
            "#include <linux/ctype.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/nfs4_mount.h>",
            "#include <linux/ncp_mount.h>",
            "#include <linux/init.h>",
            "#include <linux/ioctl.h>",
            "#include <linux/vfs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/namei.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/errno.h>",
            "#include <linux/compat.h>",
            "#include <linux/linkage.h>",
            "#include <linux/kernel.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int compat_log = 1;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/ioctls.h>\n#include <asm/mmu_context.h>\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/fs_struct.h>\n#include <linux/mm.h>\n#include <linux/poll.h>\n#include <linux/signal.h>\n#include <linux/highmem.h>\n#include <linux/security.h>\n#include <linux/tsacct_kern.h>\n#include <linux/rwsem.h>\n#include <linux/personality.h>\n#include <linux/highuid.h>\n#include <linux/fsnotify.h>\n#include <linux/dirent.h>\n#include <linux/ctype.h>\n#include <linux/syscalls.h>\n#include <linux/nfs4_mount.h>\n#include <linux/ncp_mount.h>\n#include <linux/init.h>\n#include <linux/ioctl.h>\n#include <linux/vfs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/namei.h>\n#include <linux/fcntl.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <linux/compat.h>\n#include <linux/linkage.h>\n#include <linux/kernel.h>\n#include <linux/stddef.h>\n\nint compat_log = 1;\n\nint compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "jbd_alloc",
          "args": [
            "jh2bh(jh)->b_size",
            "GFP_NOFS"
          ],
          "line": 675
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "jh2bh",
          "args": [
            "jh"
          ],
          "line": 675
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "jbd_unlock_bh_state",
          "args": [
            "bh"
          ],
          "line": 673
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "JBUFFER_TRACE",
          "args": [
            "jh",
            "\"allocate memory for buffer\""
          ],
          "line": 672
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "JBUFFER_TRACE",
          "args": [
            "jh",
            "\"generate frozen data\""
          ],
          "line": 670
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "finish_wait",
          "args": [
            "wqh",
            "&wait.wait"
          ],
          "line": 651
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "schedule",
          "args": [],
          "line": 649
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "prepare_to_wait",
          "args": [
            "wqh",
            "&wait.wait",
            "TASK_UNINTERRUPTIBLE"
          ],
          "line": 645
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "jbd_unlock_bh_state",
          "args": [
            "bh"
          ],
          "line": 642
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "JBUFFER_TRACE",
          "args": [
            "jh",
            "\"on shadow: sleep\""
          ],
          "line": 641
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bit_waitqueue",
          "args": [
            "&bh->b_state",
            "BH_Unshadow"
          ],
          "line": 639
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DEFINE_WAIT_BIT",
          "args": [
            "wait",
            "&bh->b_state",
            "BH_Unshadow"
          ],
          "line": 636
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "J_ASSERT_JH",
          "args": [
            "jh",
            "jh->b_transaction ==\n\t\t\t\t\tjournal->j_committing_transaction"
          ],
          "line": 623
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "J_ASSERT_JH",
          "args": [
            "jh",
            "jh->b_next_transaction == NULL"
          ],
          "line": 622
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "JBUFFER_TRACE",
          "args": [
            "jh",
            "\"owned by older transaction\""
          ],
          "line": 621
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "J_ASSERT_JH",
          "args": [
            "jh",
            "jh->b_next_transaction == NULL"
          ],
          "line": 613
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "JBUFFER_TRACE",
          "args": [
            "jh",
            "\"has frozen data\""
          ],
          "line": 612
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "jbd_unlock_bh_state",
          "args": [
            "bh"
          ],
          "line": 588
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_handle_aborted",
          "args": [
            "handle"
          ],
          "line": 587
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlock_buffer",
          "args": [
            "bh"
          ],
          "line": 584
        },
        "resolved": true,
        "details": {
          "function_name": "unlock_buffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "70-75",
          "snippet": "void unlock_buffer(struct buffer_head *bh)\n{\n\tclear_bit_unlock(BH_Lock, &bh->b_state);\n\tsmp_mb__after_atomic();\n\twake_up_bit(&bh->b_state, BH_Lock);\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid unlock_buffer(struct buffer_head *bh)\n{\n\tclear_bit_unlock(BH_Lock, &bh->b_state);\n\tsmp_mb__after_atomic();\n\twake_up_bit(&bh->b_state, BH_Lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_buffer_jbddirty",
          "args": [
            "bh"
          ],
          "line": 581
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clear_buffer_dirty",
          "args": [
            "bh"
          ],
          "line": 580
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "JBUFFER_TRACE",
          "args": [
            "jh",
            "\"Journalling dirty buffer\""
          ],
          "line": 579
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "warn_dirty_buffer",
          "args": [
            "bh"
          ],
          "line": 572
        },
        "resolved": true,
        "details": {
          "function_name": "warn_dirty_buffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd/transaction.c",
          "lines": "497-506",
          "snippet": "static void warn_dirty_buffer(struct buffer_head *bh)\n{\n\tchar b[BDEVNAME_SIZE];\n\n\tprintk(KERN_WARNING\n\t       \"JBD: Spotted dirty metadata buffer (dev = %s, blocknr = %llu). \"\n\t       \"There's a risk of filesystem corruption in case of system \"\n\t       \"crash.\\n\",\n\t       bdevname(bh->b_bdev, b), (unsigned long long)bh->b_blocknr);\n}",
          "includes": [
            "#include <linux/hrtimer.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/timer.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/jbd.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/timer.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n\nstatic void warn_dirty_buffer(struct buffer_head *bh)\n{\n\tchar b[BDEVNAME_SIZE];\n\n\tprintk(KERN_WARNING\n\t       \"JBD: Spotted dirty metadata buffer (dev = %s, blocknr = %llu). \"\n\t       \"There's a risk of filesystem corruption in case of system \"\n\t       \"crash.\\n\",\n\t       bdevname(bh->b_bdev, b), (unsigned long long)bh->b_blocknr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "J_ASSERT_JH",
          "args": [
            "jh",
            "jh->b_next_transaction ==\n\t\t\t\t\t\t\ttransaction"
          ],
          "line": 570
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "J_ASSERT_JH",
          "args": [
            "jh",
            "jh->b_transaction == transaction ||\n\t\t\t\tjh->b_transaction ==\n\t\t\t\t\tjournal->j_committing_transaction"
          ],
          "line": 565
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "buffer_dirty",
          "args": [
            "bh"
          ],
          "line": 559
        },
        "resolved": true,
        "details": {
          "function_name": "mark_buffer_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1141-1167",
          "snippet": "void mark_buffer_dirty(struct buffer_head *bh)\n{\n\tWARN_ON_ONCE(!buffer_uptodate(bh));\n\n\ttrace_block_dirty_buffer(bh);\n\n\t/*\n\t * Very *carefully* optimize the it-is-already-dirty case.\n\t *\n\t * Don't let the final \"is it dirty\" escape to before we\n\t * perhaps modified the buffer.\n\t */\n\tif (buffer_dirty(bh)) {\n\t\tsmp_mb();\n\t\tif (buffer_dirty(bh))\n\t\t\treturn;\n\t}\n\n\tif (!test_set_buffer_dirty(bh)) {\n\t\tstruct page *page = bh->b_page;\n\t\tif (!TestSetPageDirty(page)) {\n\t\t\tstruct address_space *mapping = page_mapping(page);\n\t\t\tif (mapping)\n\t\t\t\t__set_page_dirty(page, mapping, 0);\n\t\t}\n\t}\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid mark_buffer_dirty(struct buffer_head *bh)\n{\n\tWARN_ON_ONCE(!buffer_uptodate(bh));\n\n\ttrace_block_dirty_buffer(bh);\n\n\t/*\n\t * Very *carefully* optimize the it-is-already-dirty case.\n\t *\n\t * Don't let the final \"is it dirty\" escape to before we\n\t * perhaps modified the buffer.\n\t */\n\tif (buffer_dirty(bh)) {\n\t\tsmp_mb();\n\t\tif (buffer_dirty(bh))\n\t\t\treturn;\n\t}\n\n\tif (!test_set_buffer_dirty(bh)) {\n\t\tstruct page *page = bh->b_page;\n\t\tif (!TestSetPageDirty(page)) {\n\t\t\tstruct address_space *mapping = page_mapping(page);\n\t\t\tif (mapping)\n\t\t\t\t__set_page_dirty(page, mapping, 0);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "jbd_lock_bh_state",
          "args": [
            "bh"
          ],
          "line": 544
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "jh2bh",
          "args": [
            "jh"
          ],
          "line": 539
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "JBUFFER_TRACE",
          "args": [
            "jh",
            "\"entry\""
          ],
          "line": 537
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "jbd_debug",
          "args": [
            "5",
            "\"journal_head %p, force_copy %d\\n\"",
            "jh",
            "force_copy"
          ],
          "line": 535
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_handle_aborted",
          "args": [
            "handle"
          ],
          "line": 529
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/timer.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n\nstatic void __journal_temp_unlink_buffer(struct journal_head *jh);\n\nstatic int\ndo_get_write_access(handle_t *handle, struct journal_head *jh,\n\t\t\tint force_copy)\n{\n\tstruct buffer_head *bh;\n\ttransaction_t *transaction;\n\tjournal_t *journal;\n\tint error;\n\tchar *frozen_buffer = NULL;\n\tint need_copy = 0;\n\n\tif (is_handle_aborted(handle))\n\t\treturn -EROFS;\n\n\ttransaction = handle->h_transaction;\n\tjournal = transaction->t_journal;\n\n\tjbd_debug(5, \"journal_head %p, force_copy %d\\n\", jh, force_copy);\n\n\tJBUFFER_TRACE(jh, \"entry\");\nrepeat:\n\tbh = jh2bh(jh);\n\n\t/* @@@ Need to check for errors here at some point. */\n\n\tlock_buffer(bh);\n\tjbd_lock_bh_state(bh);\n\n\t/* We now hold the buffer lock so it is safe to query the buffer\n\t * state.  Is the buffer dirty?\n\t *\n\t * If so, there are two possibilities.  The buffer may be\n\t * non-journaled, and undergoing a quite legitimate writeback.\n\t * Otherwise, it is journaled, and we don't expect dirty buffers\n\t * in that state (the buffers should be marked JBD_Dirty\n\t * instead.)  So either the IO is being done under our own\n\t * control and this is a bug, or it's a third party IO such as\n\t * dump(8) (which may leave the buffer scheduled for read ---\n\t * ie. locked but not dirty) or tune2fs (which may actually have\n\t * the buffer dirtied, ugh.)  */\n\n\tif (buffer_dirty(bh)) {\n\t\t/*\n\t\t * First question: is this buffer already part of the current\n\t\t * transaction or the existing committing transaction?\n\t\t */\n\t\tif (jh->b_transaction) {\n\t\t\tJ_ASSERT_JH(jh,\n\t\t\t\tjh->b_transaction == transaction ||\n\t\t\t\tjh->b_transaction ==\n\t\t\t\t\tjournal->j_committing_transaction);\n\t\t\tif (jh->b_next_transaction)\n\t\t\t\tJ_ASSERT_JH(jh, jh->b_next_transaction ==\n\t\t\t\t\t\t\ttransaction);\n\t\t\twarn_dirty_buffer(bh);\n\t\t}\n\t\t/*\n\t\t * In any case we need to clean the dirty flag and we must\n\t\t * do it under the buffer lock to be sure we don't race\n\t\t * with running write-out.\n\t\t */\n\t\tJBUFFER_TRACE(jh, \"Journalling dirty buffer\");\n\t\tclear_buffer_dirty(bh);\n\t\tset_buffer_jbddirty(bh);\n\t}\n\n\tunlock_buffer(bh);\n\n\terror = -EROFS;\n\tif (is_handle_aborted(handle)) {\n\t\tjbd_unlock_bh_state(bh);\n\t\tgoto out;\n\t}\n\terror = 0;\n\n\t/*\n\t * The buffer is already part of this transaction if b_transaction or\n\t * b_next_transaction points to it\n\t */\n\tif (jh->b_transaction == transaction ||\n\t    jh->b_next_transaction == transaction)\n\t\tgoto done;\n\n\t/*\n\t * this is the first time this transaction is touching this buffer,\n\t * reset the modified flag\n\t */\n\tjh->b_modified = 0;\n\n\t/*\n\t * If there is already a copy-out version of this buffer, then we don't\n\t * need to make another one\n\t */\n\tif (jh->b_frozen_data) {\n\t\tJBUFFER_TRACE(jh, \"has frozen data\");\n\t\tJ_ASSERT_JH(jh, jh->b_next_transaction == NULL);\n\t\tjh->b_next_transaction = transaction;\n\t\tgoto done;\n\t}\n\n\t/* Is there data here we need to preserve? */\n\n\tif (jh->b_transaction && jh->b_transaction != transaction) {\n\t\tJBUFFER_TRACE(jh, \"owned by older transaction\");\n\t\tJ_ASSERT_JH(jh, jh->b_next_transaction == NULL);\n\t\tJ_ASSERT_JH(jh, jh->b_transaction ==\n\t\t\t\t\tjournal->j_committing_transaction);\n\n\t\t/* There is one case we have to be very careful about.\n\t\t * If the committing transaction is currently writing\n\t\t * this buffer out to disk and has NOT made a copy-out,\n\t\t * then we cannot modify the buffer contents at all\n\t\t * right now.  The essence of copy-out is that it is the\n\t\t * extra copy, not the primary copy, which gets\n\t\t * journaled.  If the primary copy is already going to\n\t\t * disk then we cannot do copy-out here. */\n\n\t\tif (jh->b_jlist == BJ_Shadow) {\n\t\t\tDEFINE_WAIT_BIT(wait, &bh->b_state, BH_Unshadow);\n\t\t\twait_queue_head_t *wqh;\n\n\t\t\twqh = bit_waitqueue(&bh->b_state, BH_Unshadow);\n\n\t\t\tJBUFFER_TRACE(jh, \"on shadow: sleep\");\n\t\t\tjbd_unlock_bh_state(bh);\n\t\t\t/* commit wakes up all shadow buffers after IO */\n\t\t\tfor ( ; ; ) {\n\t\t\t\tprepare_to_wait(wqh, &wait.wait,\n\t\t\t\t\t\tTASK_UNINTERRUPTIBLE);\n\t\t\t\tif (jh->b_jlist != BJ_Shadow)\n\t\t\t\t\tbreak;\n\t\t\t\tschedule();\n\t\t\t}\n\t\t\tfinish_wait(wqh, &wait.wait);\n\t\t\tgoto repeat;\n\t\t}\n\n\t\t/* Only do the copy if the currently-owning transaction\n\t\t * still needs it.  If it is on the Forget list, the\n\t\t * committing transaction is past that stage.  The\n\t\t * buffer had better remain locked during the kmalloc,\n\t\t * but that should be true --- we hold the journal lock\n\t\t * still and the buffer is already on the BUF_JOURNAL\n\t\t * list so won't be flushed.\n\t\t *\n\t\t * Subtle point, though: if this is a get_undo_access,\n\t\t * then we will be relying on the frozen_data to contain\n\t\t * the new value of the committed_data record after the\n\t\t * transaction, so we HAVE to force the frozen_data copy\n\t\t * in that case. */\n\n\t\tif (jh->b_jlist != BJ_Forget || force_copy) {\n\t\t\tJBUFFER_TRACE(jh, \"generate frozen data\");\n\t\t\tif (!frozen_buffer) {\n\t\t\t\tJBUFFER_TRACE(jh, \"allocate memory for buffer\");\n\t\t\t\tjbd_unlock_bh_state(bh);\n\t\t\t\tfrozen_buffer =\n\t\t\t\t\tjbd_alloc(jh2bh(jh)->b_size,\n\t\t\t\t\t\t\t GFP_NOFS);\n\t\t\t\tif (!frozen_buffer) {\n\t\t\t\t\tprintk(KERN_ERR\n\t\t\t\t\t       \"%s: OOM for frozen_buffer\\n\",\n\t\t\t\t\t       __func__);\n\t\t\t\t\tJBUFFER_TRACE(jh, \"oom!\");\n\t\t\t\t\terror = -ENOMEM;\n\t\t\t\t\tjbd_lock_bh_state(bh);\n\t\t\t\t\tgoto done;\n\t\t\t\t}\n\t\t\t\tgoto repeat;\n\t\t\t}\n\t\t\tjh->b_frozen_data = frozen_buffer;\n\t\t\tfrozen_buffer = NULL;\n\t\t\tneed_copy = 1;\n\t\t}\n\t\tjh->b_next_transaction = transaction;\n\t}\n\n\n\t/*\n\t * Finally, if the buffer is not journaled right now, we need to make\n\t * sure it doesn't get written to disk before the caller actually\n\t * commits the new data\n\t */\n\tif (!jh->b_transaction) {\n\t\tJBUFFER_TRACE(jh, \"no transaction\");\n\t\tJ_ASSERT_JH(jh, !jh->b_next_transaction);\n\t\tJBUFFER_TRACE(jh, \"file as BJ_Reserved\");\n\t\tspin_lock(&journal->j_list_lock);\n\t\t__journal_file_buffer(jh, transaction, BJ_Reserved);\n\t\tspin_unlock(&journal->j_list_lock);\n\t}\n\ndone:\n\tif (need_copy) {\n\t\tstruct page *page;\n\t\tint offset;\n\t\tchar *source;\n\n\t\tJ_EXPECT_JH(jh, buffer_uptodate(jh2bh(jh)),\n\t\t\t    \"Possible IO failure.\\n\");\n\t\tpage = jh2bh(jh)->b_page;\n\t\toffset = offset_in_page(jh2bh(jh)->b_data);\n\t\tsource = kmap_atomic(page);\n\t\tmemcpy(jh->b_frozen_data, source+offset, jh2bh(jh)->b_size);\n\t\tkunmap_atomic(source);\n\t}\n\tjbd_unlock_bh_state(bh);\n\n\t/*\n\t * If we are about to journal a buffer, then any revoke pending on it is\n\t * no longer valid\n\t */\n\tjournal_cancel_revoke(handle, jh);\n\nout:\n\tif (unlikely(frozen_buffer))\t/* It's usually NULL */\n\t\tjbd_free(frozen_buffer, bh->b_size);\n\n\tJBUFFER_TRACE(jh, \"exit\");\n\treturn error;\n}"
  },
  {
    "function_name": "warn_dirty_buffer",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd/transaction.c",
    "lines": "497-506",
    "snippet": "static void warn_dirty_buffer(struct buffer_head *bh)\n{\n\tchar b[BDEVNAME_SIZE];\n\n\tprintk(KERN_WARNING\n\t       \"JBD: Spotted dirty metadata buffer (dev = %s, blocknr = %llu). \"\n\t       \"There's a risk of filesystem corruption in case of system \"\n\t       \"crash.\\n\",\n\t       bdevname(bh->b_bdev, b), (unsigned long long)bh->b_blocknr);\n}",
    "includes": [
      "#include <linux/hrtimer.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/timer.h>",
      "#include <linux/slab.h>",
      "#include <linux/errno.h>",
      "#include <linux/jbd.h>",
      "#include <linux/fs.h>",
      "#include <linux/time.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_WARNING\n\t       \"JBD: Spotted dirty metadata buffer (dev = %s, blocknr = %llu). \"\n\t       \"There's a risk of filesystem corruption in case of system \"\n\t       \"crash.\\n\"",
            "bdevname(bh->b_bdev, b)",
            "(unsigned long long)bh->b_blocknr"
          ],
          "line": 501
        },
        "resolved": true,
        "details": {
          "function_name": "compat_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/compat.c",
          "lines": "59-69",
          "snippet": "int compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/ioctls.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/aio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/mm.h>",
            "#include <linux/poll.h>",
            "#include <linux/signal.h>",
            "#include <linux/highmem.h>",
            "#include <linux/security.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/personality.h>",
            "#include <linux/highuid.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/dirent.h>",
            "#include <linux/ctype.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/nfs4_mount.h>",
            "#include <linux/ncp_mount.h>",
            "#include <linux/init.h>",
            "#include <linux/ioctl.h>",
            "#include <linux/vfs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/namei.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/errno.h>",
            "#include <linux/compat.h>",
            "#include <linux/linkage.h>",
            "#include <linux/kernel.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int compat_log = 1;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/ioctls.h>\n#include <asm/mmu_context.h>\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/fs_struct.h>\n#include <linux/mm.h>\n#include <linux/poll.h>\n#include <linux/signal.h>\n#include <linux/highmem.h>\n#include <linux/security.h>\n#include <linux/tsacct_kern.h>\n#include <linux/rwsem.h>\n#include <linux/personality.h>\n#include <linux/highuid.h>\n#include <linux/fsnotify.h>\n#include <linux/dirent.h>\n#include <linux/ctype.h>\n#include <linux/syscalls.h>\n#include <linux/nfs4_mount.h>\n#include <linux/ncp_mount.h>\n#include <linux/init.h>\n#include <linux/ioctl.h>\n#include <linux/vfs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/namei.h>\n#include <linux/fcntl.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <linux/compat.h>\n#include <linux/linkage.h>\n#include <linux/kernel.h>\n#include <linux/stddef.h>\n\nint compat_log = 1;\n\nint compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "bdevname",
          "args": [
            "bh->b_bdev",
            "b"
          ],
          "line": 505
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/timer.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n\nstatic void warn_dirty_buffer(struct buffer_head *bh)\n{\n\tchar b[BDEVNAME_SIZE];\n\n\tprintk(KERN_WARNING\n\t       \"JBD: Spotted dirty metadata buffer (dev = %s, blocknr = %llu). \"\n\t       \"There's a risk of filesystem corruption in case of system \"\n\t       \"crash.\\n\",\n\t       bdevname(bh->b_bdev, b), (unsigned long long)bh->b_blocknr);\n}"
  },
  {
    "function_name": "journal_unlock_updates",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd/transaction.c",
    "lines": "487-495",
    "snippet": "void journal_unlock_updates (journal_t *journal)\n{\n\tJ_ASSERT(journal->j_barrier_count != 0);\n\n\tspin_lock(&journal->j_state_lock);\n\t--journal->j_barrier_count;\n\tspin_unlock(&journal->j_state_lock);\n\twake_up(&journal->j_wait_transaction_locked);\n}",
    "includes": [
      "#include <linux/hrtimer.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/timer.h>",
      "#include <linux/slab.h>",
      "#include <linux/errno.h>",
      "#include <linux/jbd.h>",
      "#include <linux/fs.h>",
      "#include <linux/time.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "wake_up",
          "args": [
            "&journal->j_wait_transaction_locked"
          ],
          "line": 494
        },
        "resolved": true,
        "details": {
          "function_name": "locks_wake_up_blocks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/locks.c",
          "lines": "656-681",
          "snippet": "static void locks_wake_up_blocks(struct file_lock *blocker)\n{\n\t/*\n\t * Avoid taking global lock if list is empty. This is safe since new\n\t * blocked requests are only added to the list under the flc_lock, and\n\t * the flc_lock is always held here. Note that removal from the fl_block\n\t * list does not require the flc_lock, so we must recheck list_empty()\n\t * after acquiring the blocked_lock_lock.\n\t */\n\tif (list_empty(&blocker->fl_block))\n\t\treturn;\n\n\tspin_lock(&blocked_lock_lock);\n\twhile (!list_empty(&blocker->fl_block)) {\n\t\tstruct file_lock *waiter;\n\n\t\twaiter = list_first_entry(&blocker->fl_block,\n\t\t\t\tstruct file_lock, fl_block);\n\t\t__locks_delete_block(waiter);\n\t\tif (waiter->fl_lmops && waiter->fl_lmops->lm_notify)\n\t\t\twaiter->fl_lmops->lm_notify(waiter);\n\t\telse\n\t\t\twake_up(&waiter->fl_wait);\n\t}\n\tspin_unlock(&blocked_lock_lock);\n}",
          "includes": [
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <asm/uaccess.h>",
            "#include <trace/events/filelock.h>",
            "#include <linux/lglock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/time.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_SPINLOCK(blocked_lock_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <asm/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/lglock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nstatic DEFINE_SPINLOCK(blocked_lock_lock);\n\nstatic void locks_wake_up_blocks(struct file_lock *blocker)\n{\n\t/*\n\t * Avoid taking global lock if list is empty. This is safe since new\n\t * blocked requests are only added to the list under the flc_lock, and\n\t * the flc_lock is always held here. Note that removal from the fl_block\n\t * list does not require the flc_lock, so we must recheck list_empty()\n\t * after acquiring the blocked_lock_lock.\n\t */\n\tif (list_empty(&blocker->fl_block))\n\t\treturn;\n\n\tspin_lock(&blocked_lock_lock);\n\twhile (!list_empty(&blocker->fl_block)) {\n\t\tstruct file_lock *waiter;\n\n\t\twaiter = list_first_entry(&blocker->fl_block,\n\t\t\t\tstruct file_lock, fl_block);\n\t\t__locks_delete_block(waiter);\n\t\tif (waiter->fl_lmops && waiter->fl_lmops->lm_notify)\n\t\t\twaiter->fl_lmops->lm_notify(waiter);\n\t\telse\n\t\t\twake_up(&waiter->fl_wait);\n\t}\n\tspin_unlock(&blocked_lock_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&journal->j_state_lock"
          ],
          "line": 493
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&journal->j_state_lock"
          ],
          "line": 491
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "J_ASSERT",
          "args": [
            "journal->j_barrier_count != 0"
          ],
          "line": 489
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/timer.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n\nvoid journal_unlock_updates (journal_t *journal)\n{\n\tJ_ASSERT(journal->j_barrier_count != 0);\n\n\tspin_lock(&journal->j_state_lock);\n\t--journal->j_barrier_count;\n\tspin_unlock(&journal->j_state_lock);\n\twake_up(&journal->j_wait_transaction_locked);\n}"
  },
  {
    "function_name": "journal_lock_updates",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd/transaction.c",
    "lines": "438-479",
    "snippet": "void journal_lock_updates(journal_t *journal)\n{\n\tDEFINE_WAIT(wait);\n\nwait:\n\t/* Wait for previous locked operation to finish */\n\twait_event(journal->j_wait_transaction_locked,\n\t\t   journal->j_barrier_count == 0);\n\n\tspin_lock(&journal->j_state_lock);\n\t/*\n\t * Check reliably under the lock whether we are the ones winning the race\n\t * and locking the journal\n\t */\n\tif (journal->j_barrier_count > 0) {\n\t\tspin_unlock(&journal->j_state_lock);\n\t\tgoto wait;\n\t}\n\t++journal->j_barrier_count;\n\n\t/* Wait until there are no running updates */\n\twhile (1) {\n\t\ttransaction_t *transaction = journal->j_running_transaction;\n\n\t\tif (!transaction)\n\t\t\tbreak;\n\n\t\tspin_lock(&transaction->t_handle_lock);\n\t\tif (!transaction->t_updates) {\n\t\t\tspin_unlock(&transaction->t_handle_lock);\n\t\t\tbreak;\n\t\t}\n\t\tprepare_to_wait(&journal->j_wait_updates, &wait,\n\t\t\t\tTASK_UNINTERRUPTIBLE);\n\t\tspin_unlock(&transaction->t_handle_lock);\n\t\tspin_unlock(&journal->j_state_lock);\n\t\tschedule();\n\t\tfinish_wait(&journal->j_wait_updates, &wait);\n\t\tspin_lock(&journal->j_state_lock);\n\t}\n\tspin_unlock(&journal->j_state_lock);\n}",
    "includes": [
      "#include <linux/hrtimer.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/timer.h>",
      "#include <linux/slab.h>",
      "#include <linux/errno.h>",
      "#include <linux/jbd.h>",
      "#include <linux/fs.h>",
      "#include <linux/time.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&journal->j_state_lock"
          ],
          "line": 478
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&journal->j_state_lock"
          ],
          "line": 476
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "finish_wait",
          "args": [
            "&journal->j_wait_updates",
            "&wait"
          ],
          "line": 475
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "schedule",
          "args": [],
          "line": 474
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "prepare_to_wait",
          "args": [
            "&journal->j_wait_updates",
            "&wait",
            "TASK_UNINTERRUPTIBLE"
          ],
          "line": 470
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wait_event",
          "args": [
            "journal->j_wait_transaction_locked",
            "journal->j_barrier_count == 0"
          ],
          "line": 444
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DEFINE_WAIT",
          "args": [
            "wait"
          ],
          "line": 440
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/timer.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n\nvoid journal_lock_updates(journal_t *journal)\n{\n\tDEFINE_WAIT(wait);\n\nwait:\n\t/* Wait for previous locked operation to finish */\n\twait_event(journal->j_wait_transaction_locked,\n\t\t   journal->j_barrier_count == 0);\n\n\tspin_lock(&journal->j_state_lock);\n\t/*\n\t * Check reliably under the lock whether we are the ones winning the race\n\t * and locking the journal\n\t */\n\tif (journal->j_barrier_count > 0) {\n\t\tspin_unlock(&journal->j_state_lock);\n\t\tgoto wait;\n\t}\n\t++journal->j_barrier_count;\n\n\t/* Wait until there are no running updates */\n\twhile (1) {\n\t\ttransaction_t *transaction = journal->j_running_transaction;\n\n\t\tif (!transaction)\n\t\t\tbreak;\n\n\t\tspin_lock(&transaction->t_handle_lock);\n\t\tif (!transaction->t_updates) {\n\t\t\tspin_unlock(&transaction->t_handle_lock);\n\t\t\tbreak;\n\t\t}\n\t\tprepare_to_wait(&journal->j_wait_updates, &wait,\n\t\t\t\tTASK_UNINTERRUPTIBLE);\n\t\tspin_unlock(&transaction->t_handle_lock);\n\t\tspin_unlock(&journal->j_state_lock);\n\t\tschedule();\n\t\tfinish_wait(&journal->j_wait_updates, &wait);\n\t\tspin_lock(&journal->j_state_lock);\n\t}\n\tspin_unlock(&journal->j_state_lock);\n}"
  },
  {
    "function_name": "journal_restart",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd/transaction.c",
    "lines": "386-421",
    "snippet": "int journal_restart(handle_t *handle, int nblocks)\n{\n\ttransaction_t *transaction = handle->h_transaction;\n\tjournal_t *journal = transaction->t_journal;\n\tint ret;\n\n\t/* If we've had an abort of any type, don't even think about\n\t * actually doing the restart! */\n\tif (is_handle_aborted(handle))\n\t\treturn 0;\n\n\t/*\n\t * First unlink the handle from its current transaction, and start the\n\t * commit on that.\n\t */\n\tJ_ASSERT(transaction->t_updates > 0);\n\tJ_ASSERT(journal_current_handle() == handle);\n\n\tspin_lock(&journal->j_state_lock);\n\tspin_lock(&transaction->t_handle_lock);\n\ttransaction->t_outstanding_credits -= handle->h_buffer_credits;\n\ttransaction->t_updates--;\n\n\tif (!transaction->t_updates)\n\t\twake_up(&journal->j_wait_updates);\n\tspin_unlock(&transaction->t_handle_lock);\n\n\tjbd_debug(2, \"restarting handle %p\\n\", handle);\n\t__log_start_commit(journal, transaction->t_tid);\n\tspin_unlock(&journal->j_state_lock);\n\n\tlock_map_release(&handle->h_lockdep_map);\n\thandle->h_buffer_credits = nblocks;\n\tret = start_this_handle(journal, handle);\n\treturn ret;\n}",
    "includes": [
      "#include <linux/hrtimer.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/timer.h>",
      "#include <linux/slab.h>",
      "#include <linux/errno.h>",
      "#include <linux/jbd.h>",
      "#include <linux/fs.h>",
      "#include <linux/time.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "start_this_handle",
          "args": [
            "journal",
            "handle"
          ],
          "line": 419
        },
        "resolved": true,
        "details": {
          "function_name": "start_this_handle",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd/transaction.c",
          "lines": "84-238",
          "snippet": "static int start_this_handle(journal_t *journal, handle_t *handle)\n{\n\ttransaction_t *transaction;\n\tint needed;\n\tint nblocks = handle->h_buffer_credits;\n\ttransaction_t *new_transaction = NULL;\n\tint ret = 0;\n\n\tif (nblocks > journal->j_max_transaction_buffers) {\n\t\tprintk(KERN_ERR \"JBD: %s wants too many credits (%d > %d)\\n\",\n\t\t       current->comm, nblocks,\n\t\t       journal->j_max_transaction_buffers);\n\t\tret = -ENOSPC;\n\t\tgoto out;\n\t}\n\nalloc_transaction:\n\tif (!journal->j_running_transaction) {\n\t\tnew_transaction = kzalloc(sizeof(*new_transaction),\n\t\t\t\t\t\tGFP_NOFS|__GFP_NOFAIL);\n\t\tif (!new_transaction) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tjbd_debug(3, \"New handle %p going live.\\n\", handle);\n\nrepeat:\n\n\t/*\n\t * We need to hold j_state_lock until t_updates has been incremented,\n\t * for proper journal barrier handling\n\t */\n\tspin_lock(&journal->j_state_lock);\nrepeat_locked:\n\tif (is_journal_aborted(journal) ||\n\t    (journal->j_errno != 0 && !(journal->j_flags & JFS_ACK_ERR))) {\n\t\tspin_unlock(&journal->j_state_lock);\n\t\tret = -EROFS;\n\t\tgoto out;\n\t}\n\n\t/* Wait on the journal's transaction barrier if necessary */\n\tif (journal->j_barrier_count) {\n\t\tspin_unlock(&journal->j_state_lock);\n\t\twait_event(journal->j_wait_transaction_locked,\n\t\t\t\tjournal->j_barrier_count == 0);\n\t\tgoto repeat;\n\t}\n\n\tif (!journal->j_running_transaction) {\n\t\tif (!new_transaction) {\n\t\t\tspin_unlock(&journal->j_state_lock);\n\t\t\tgoto alloc_transaction;\n\t\t}\n\t\tget_transaction(journal, new_transaction);\n\t\tnew_transaction = NULL;\n\t}\n\n\ttransaction = journal->j_running_transaction;\n\n\t/*\n\t * If the current transaction is locked down for commit, wait for the\n\t * lock to be released.\n\t */\n\tif (transaction->t_state == T_LOCKED) {\n\t\tDEFINE_WAIT(wait);\n\n\t\tprepare_to_wait(&journal->j_wait_transaction_locked,\n\t\t\t\t\t&wait, TASK_UNINTERRUPTIBLE);\n\t\tspin_unlock(&journal->j_state_lock);\n\t\tschedule();\n\t\tfinish_wait(&journal->j_wait_transaction_locked, &wait);\n\t\tgoto repeat;\n\t}\n\n\t/*\n\t * If there is not enough space left in the log to write all potential\n\t * buffers requested by this operation, we need to stall pending a log\n\t * checkpoint to free some more log space.\n\t */\n\tspin_lock(&transaction->t_handle_lock);\n\tneeded = transaction->t_outstanding_credits + nblocks;\n\n\tif (needed > journal->j_max_transaction_buffers) {\n\t\t/*\n\t\t * If the current transaction is already too large, then start\n\t\t * to commit it: we can then go back and attach this handle to\n\t\t * a new transaction.\n\t\t */\n\t\tDEFINE_WAIT(wait);\n\n\t\tjbd_debug(2, \"Handle %p starting new commit...\\n\", handle);\n\t\tspin_unlock(&transaction->t_handle_lock);\n\t\tprepare_to_wait(&journal->j_wait_transaction_locked, &wait,\n\t\t\t\tTASK_UNINTERRUPTIBLE);\n\t\t__log_start_commit(journal, transaction->t_tid);\n\t\tspin_unlock(&journal->j_state_lock);\n\t\tschedule();\n\t\tfinish_wait(&journal->j_wait_transaction_locked, &wait);\n\t\tgoto repeat;\n\t}\n\n\t/*\n\t * The commit code assumes that it can get enough log space\n\t * without forcing a checkpoint.  This is *critical* for\n\t * correctness: a checkpoint of a buffer which is also\n\t * associated with a committing transaction creates a deadlock,\n\t * so commit simply cannot force through checkpoints.\n\t *\n\t * We must therefore ensure the necessary space in the journal\n\t * *before* starting to dirty potentially checkpointed buffers\n\t * in the new transaction.\n\t *\n\t * The worst part is, any transaction currently committing can\n\t * reduce the free space arbitrarily.  Be careful to account for\n\t * those buffers when checkpointing.\n\t */\n\n\t/*\n\t * @@@ AKPM: This seems rather over-defensive.  We're giving commit\n\t * a _lot_ of headroom: 1/4 of the journal plus the size of\n\t * the committing transaction.  Really, we only need to give it\n\t * committing_transaction->t_outstanding_credits plus \"enough\" for\n\t * the log control blocks.\n\t * Also, this test is inconsistent with the matching one in\n\t * journal_extend().\n\t */\n\tif (__log_space_left(journal) < jbd_space_needed(journal)) {\n\t\tjbd_debug(2, \"Handle %p waiting for checkpoint...\\n\", handle);\n\t\tspin_unlock(&transaction->t_handle_lock);\n\t\t__log_wait_for_space(journal);\n\t\tgoto repeat_locked;\n\t}\n\n\t/* OK, account for the buffers that this operation expects to\n\t * use and add the handle to the running transaction. */\n\n\thandle->h_transaction = transaction;\n\ttransaction->t_outstanding_credits += nblocks;\n\ttransaction->t_updates++;\n\ttransaction->t_handle_count++;\n\tjbd_debug(4, \"Handle %p given %d credits (total %d, free %d)\\n\",\n\t\t  handle, nblocks, transaction->t_outstanding_credits,\n\t\t  __log_space_left(journal));\n\tspin_unlock(&transaction->t_handle_lock);\n\tspin_unlock(&journal->j_state_lock);\n\n\tlock_map_acquire(&handle->h_lockdep_map);\nout:\n\tif (unlikely(new_transaction))\t\t/* It's usually NULL */\n\t\tkfree(new_transaction);\n\treturn ret;\n}",
          "includes": [
            "#include <linux/hrtimer.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/timer.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/jbd.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/timer.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n\nstatic int start_this_handle(journal_t *journal, handle_t *handle)\n{\n\ttransaction_t *transaction;\n\tint needed;\n\tint nblocks = handle->h_buffer_credits;\n\ttransaction_t *new_transaction = NULL;\n\tint ret = 0;\n\n\tif (nblocks > journal->j_max_transaction_buffers) {\n\t\tprintk(KERN_ERR \"JBD: %s wants too many credits (%d > %d)\\n\",\n\t\t       current->comm, nblocks,\n\t\t       journal->j_max_transaction_buffers);\n\t\tret = -ENOSPC;\n\t\tgoto out;\n\t}\n\nalloc_transaction:\n\tif (!journal->j_running_transaction) {\n\t\tnew_transaction = kzalloc(sizeof(*new_transaction),\n\t\t\t\t\t\tGFP_NOFS|__GFP_NOFAIL);\n\t\tif (!new_transaction) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tjbd_debug(3, \"New handle %p going live.\\n\", handle);\n\nrepeat:\n\n\t/*\n\t * We need to hold j_state_lock until t_updates has been incremented,\n\t * for proper journal barrier handling\n\t */\n\tspin_lock(&journal->j_state_lock);\nrepeat_locked:\n\tif (is_journal_aborted(journal) ||\n\t    (journal->j_errno != 0 && !(journal->j_flags & JFS_ACK_ERR))) {\n\t\tspin_unlock(&journal->j_state_lock);\n\t\tret = -EROFS;\n\t\tgoto out;\n\t}\n\n\t/* Wait on the journal's transaction barrier if necessary */\n\tif (journal->j_barrier_count) {\n\t\tspin_unlock(&journal->j_state_lock);\n\t\twait_event(journal->j_wait_transaction_locked,\n\t\t\t\tjournal->j_barrier_count == 0);\n\t\tgoto repeat;\n\t}\n\n\tif (!journal->j_running_transaction) {\n\t\tif (!new_transaction) {\n\t\t\tspin_unlock(&journal->j_state_lock);\n\t\t\tgoto alloc_transaction;\n\t\t}\n\t\tget_transaction(journal, new_transaction);\n\t\tnew_transaction = NULL;\n\t}\n\n\ttransaction = journal->j_running_transaction;\n\n\t/*\n\t * If the current transaction is locked down for commit, wait for the\n\t * lock to be released.\n\t */\n\tif (transaction->t_state == T_LOCKED) {\n\t\tDEFINE_WAIT(wait);\n\n\t\tprepare_to_wait(&journal->j_wait_transaction_locked,\n\t\t\t\t\t&wait, TASK_UNINTERRUPTIBLE);\n\t\tspin_unlock(&journal->j_state_lock);\n\t\tschedule();\n\t\tfinish_wait(&journal->j_wait_transaction_locked, &wait);\n\t\tgoto repeat;\n\t}\n\n\t/*\n\t * If there is not enough space left in the log to write all potential\n\t * buffers requested by this operation, we need to stall pending a log\n\t * checkpoint to free some more log space.\n\t */\n\tspin_lock(&transaction->t_handle_lock);\n\tneeded = transaction->t_outstanding_credits + nblocks;\n\n\tif (needed > journal->j_max_transaction_buffers) {\n\t\t/*\n\t\t * If the current transaction is already too large, then start\n\t\t * to commit it: we can then go back and attach this handle to\n\t\t * a new transaction.\n\t\t */\n\t\tDEFINE_WAIT(wait);\n\n\t\tjbd_debug(2, \"Handle %p starting new commit...\\n\", handle);\n\t\tspin_unlock(&transaction->t_handle_lock);\n\t\tprepare_to_wait(&journal->j_wait_transaction_locked, &wait,\n\t\t\t\tTASK_UNINTERRUPTIBLE);\n\t\t__log_start_commit(journal, transaction->t_tid);\n\t\tspin_unlock(&journal->j_state_lock);\n\t\tschedule();\n\t\tfinish_wait(&journal->j_wait_transaction_locked, &wait);\n\t\tgoto repeat;\n\t}\n\n\t/*\n\t * The commit code assumes that it can get enough log space\n\t * without forcing a checkpoint.  This is *critical* for\n\t * correctness: a checkpoint of a buffer which is also\n\t * associated with a committing transaction creates a deadlock,\n\t * so commit simply cannot force through checkpoints.\n\t *\n\t * We must therefore ensure the necessary space in the journal\n\t * *before* starting to dirty potentially checkpointed buffers\n\t * in the new transaction.\n\t *\n\t * The worst part is, any transaction currently committing can\n\t * reduce the free space arbitrarily.  Be careful to account for\n\t * those buffers when checkpointing.\n\t */\n\n\t/*\n\t * @@@ AKPM: This seems rather over-defensive.  We're giving commit\n\t * a _lot_ of headroom: 1/4 of the journal plus the size of\n\t * the committing transaction.  Really, we only need to give it\n\t * committing_transaction->t_outstanding_credits plus \"enough\" for\n\t * the log control blocks.\n\t * Also, this test is inconsistent with the matching one in\n\t * journal_extend().\n\t */\n\tif (__log_space_left(journal) < jbd_space_needed(journal)) {\n\t\tjbd_debug(2, \"Handle %p waiting for checkpoint...\\n\", handle);\n\t\tspin_unlock(&transaction->t_handle_lock);\n\t\t__log_wait_for_space(journal);\n\t\tgoto repeat_locked;\n\t}\n\n\t/* OK, account for the buffers that this operation expects to\n\t * use and add the handle to the running transaction. */\n\n\thandle->h_transaction = transaction;\n\ttransaction->t_outstanding_credits += nblocks;\n\ttransaction->t_updates++;\n\ttransaction->t_handle_count++;\n\tjbd_debug(4, \"Handle %p given %d credits (total %d, free %d)\\n\",\n\t\t  handle, nblocks, transaction->t_outstanding_credits,\n\t\t  __log_space_left(journal));\n\tspin_unlock(&transaction->t_handle_lock);\n\tspin_unlock(&journal->j_state_lock);\n\n\tlock_map_acquire(&handle->h_lockdep_map);\nout:\n\tif (unlikely(new_transaction))\t\t/* It's usually NULL */\n\t\tkfree(new_transaction);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "lock_map_release",
          "args": [
            "&handle->h_lockdep_map"
          ],
          "line": 417
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&journal->j_state_lock"
          ],
          "line": 415
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "__log_start_commit",
          "args": [
            "journal",
            "transaction->t_tid"
          ],
          "line": 414
        },
        "resolved": true,
        "details": {
          "function_name": "__log_start_commit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd/journal.c",
          "lines": "458-488",
          "snippet": "int __log_start_commit(journal_t *journal, tid_t target)\n{\n\t/*\n\t * The only transaction we can possibly wait upon is the\n\t * currently running transaction (if it exists).  Otherwise,\n\t * the target tid must be an old one.\n\t */\n\tif (journal->j_commit_request != target &&\n\t    journal->j_running_transaction &&\n\t    journal->j_running_transaction->t_tid == target) {\n\t\t/*\n\t\t * We want a new commit: OK, mark the request and wakeup the\n\t\t * commit thread.  We do _not_ do the commit ourselves.\n\t\t */\n\n\t\tjournal->j_commit_request = target;\n\t\tjbd_debug(1, \"JBD: requesting commit %d/%d\\n\",\n\t\t\t  journal->j_commit_request,\n\t\t\t  journal->j_commit_sequence);\n\t\twake_up(&journal->j_wait_commit);\n\t\treturn 1;\n\t} else if (!tid_geq(journal->j_commit_request, target))\n\t\t/* This should never happen, but if it does, preserve\n\t\t   the evidence before kjournald goes into a loop and\n\t\t   increments j_commit_sequence beyond all recognition. */\n\t\tWARN_ONCE(1, \"jbd: bad log_start_commit: %u %u %u %u\\n\",\n\t\t    journal->j_commit_request, journal->j_commit_sequence,\n\t\t    target, journal->j_running_transaction ?\n\t\t    journal->j_running_transaction->t_tid : 0);\n\treturn 0;\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <asm/uaccess.h>",
            "#include <trace/events/jbd.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/poison.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/jbd.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <trace/events/jbd.h>\n#include <linux/ratelimit.h>\n#include <linux/debugfs.h>\n#include <linux/proc_fs.h>\n#include <linux/poison.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/freezer.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nint __log_start_commit(journal_t *journal, tid_t target)\n{\n\t/*\n\t * The only transaction we can possibly wait upon is the\n\t * currently running transaction (if it exists).  Otherwise,\n\t * the target tid must be an old one.\n\t */\n\tif (journal->j_commit_request != target &&\n\t    journal->j_running_transaction &&\n\t    journal->j_running_transaction->t_tid == target) {\n\t\t/*\n\t\t * We want a new commit: OK, mark the request and wakeup the\n\t\t * commit thread.  We do _not_ do the commit ourselves.\n\t\t */\n\n\t\tjournal->j_commit_request = target;\n\t\tjbd_debug(1, \"JBD: requesting commit %d/%d\\n\",\n\t\t\t  journal->j_commit_request,\n\t\t\t  journal->j_commit_sequence);\n\t\twake_up(&journal->j_wait_commit);\n\t\treturn 1;\n\t} else if (!tid_geq(journal->j_commit_request, target))\n\t\t/* This should never happen, but if it does, preserve\n\t\t   the evidence before kjournald goes into a loop and\n\t\t   increments j_commit_sequence beyond all recognition. */\n\t\tWARN_ONCE(1, \"jbd: bad log_start_commit: %u %u %u %u\\n\",\n\t\t    journal->j_commit_request, journal->j_commit_sequence,\n\t\t    target, journal->j_running_transaction ?\n\t\t    journal->j_running_transaction->t_tid : 0);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "jbd_debug",
          "args": [
            "2",
            "\"restarting handle %p\\n\"",
            "handle"
          ],
          "line": 413
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wake_up",
          "args": [
            "&journal->j_wait_updates"
          ],
          "line": 410
        },
        "resolved": true,
        "details": {
          "function_name": "locks_wake_up_blocks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/locks.c",
          "lines": "656-681",
          "snippet": "static void locks_wake_up_blocks(struct file_lock *blocker)\n{\n\t/*\n\t * Avoid taking global lock if list is empty. This is safe since new\n\t * blocked requests are only added to the list under the flc_lock, and\n\t * the flc_lock is always held here. Note that removal from the fl_block\n\t * list does not require the flc_lock, so we must recheck list_empty()\n\t * after acquiring the blocked_lock_lock.\n\t */\n\tif (list_empty(&blocker->fl_block))\n\t\treturn;\n\n\tspin_lock(&blocked_lock_lock);\n\twhile (!list_empty(&blocker->fl_block)) {\n\t\tstruct file_lock *waiter;\n\n\t\twaiter = list_first_entry(&blocker->fl_block,\n\t\t\t\tstruct file_lock, fl_block);\n\t\t__locks_delete_block(waiter);\n\t\tif (waiter->fl_lmops && waiter->fl_lmops->lm_notify)\n\t\t\twaiter->fl_lmops->lm_notify(waiter);\n\t\telse\n\t\t\twake_up(&waiter->fl_wait);\n\t}\n\tspin_unlock(&blocked_lock_lock);\n}",
          "includes": [
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <asm/uaccess.h>",
            "#include <trace/events/filelock.h>",
            "#include <linux/lglock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/time.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_SPINLOCK(blocked_lock_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <asm/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/lglock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nstatic DEFINE_SPINLOCK(blocked_lock_lock);\n\nstatic void locks_wake_up_blocks(struct file_lock *blocker)\n{\n\t/*\n\t * Avoid taking global lock if list is empty. This is safe since new\n\t * blocked requests are only added to the list under the flc_lock, and\n\t * the flc_lock is always held here. Note that removal from the fl_block\n\t * list does not require the flc_lock, so we must recheck list_empty()\n\t * after acquiring the blocked_lock_lock.\n\t */\n\tif (list_empty(&blocker->fl_block))\n\t\treturn;\n\n\tspin_lock(&blocked_lock_lock);\n\twhile (!list_empty(&blocker->fl_block)) {\n\t\tstruct file_lock *waiter;\n\n\t\twaiter = list_first_entry(&blocker->fl_block,\n\t\t\t\tstruct file_lock, fl_block);\n\t\t__locks_delete_block(waiter);\n\t\tif (waiter->fl_lmops && waiter->fl_lmops->lm_notify)\n\t\t\twaiter->fl_lmops->lm_notify(waiter);\n\t\telse\n\t\t\twake_up(&waiter->fl_wait);\n\t}\n\tspin_unlock(&blocked_lock_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&transaction->t_handle_lock"
          ],
          "line": 405
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "J_ASSERT",
          "args": [
            "journal_current_handle() == handle"
          ],
          "line": 402
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "journal_current_handle",
          "args": [],
          "line": 402
        },
        "resolved": true,
        "details": {
          "function_name": "ext3_journal_current_handle",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/ext3.h",
          "lines": "1271-1274",
          "snippet": "static inline handle_t *ext3_journal_current_handle(void)\n{\n\treturn journal_current_handle();\n}",
          "includes": [
            "#include <trace/events/ext3.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/bug.h>",
            "#include <linux/magic.h>",
            "#include <linux/jbd.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext3.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/bug.h>\n#include <linux/magic.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n\nstatic inline handle_t *ext3_journal_current_handle(void)\n{\n\treturn journal_current_handle();\n}"
        }
      },
      {
        "call_info": {
          "callee": "J_ASSERT",
          "args": [
            "transaction->t_updates > 0"
          ],
          "line": 401
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_handle_aborted",
          "args": [
            "handle"
          ],
          "line": 394
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/timer.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n\nint journal_restart(handle_t *handle, int nblocks)\n{\n\ttransaction_t *transaction = handle->h_transaction;\n\tjournal_t *journal = transaction->t_journal;\n\tint ret;\n\n\t/* If we've had an abort of any type, don't even think about\n\t * actually doing the restart! */\n\tif (is_handle_aborted(handle))\n\t\treturn 0;\n\n\t/*\n\t * First unlink the handle from its current transaction, and start the\n\t * commit on that.\n\t */\n\tJ_ASSERT(transaction->t_updates > 0);\n\tJ_ASSERT(journal_current_handle() == handle);\n\n\tspin_lock(&journal->j_state_lock);\n\tspin_lock(&transaction->t_handle_lock);\n\ttransaction->t_outstanding_credits -= handle->h_buffer_credits;\n\ttransaction->t_updates--;\n\n\tif (!transaction->t_updates)\n\t\twake_up(&journal->j_wait_updates);\n\tspin_unlock(&transaction->t_handle_lock);\n\n\tjbd_debug(2, \"restarting handle %p\\n\", handle);\n\t__log_start_commit(journal, transaction->t_tid);\n\tspin_unlock(&journal->j_state_lock);\n\n\tlock_map_release(&handle->h_lockdep_map);\n\thandle->h_buffer_credits = nblocks;\n\tret = start_this_handle(journal, handle);\n\treturn ret;\n}"
  },
  {
    "function_name": "journal_extend",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd/transaction.c",
    "lines": "320-368",
    "snippet": "int journal_extend(handle_t *handle, int nblocks)\n{\n\ttransaction_t *transaction = handle->h_transaction;\n\tjournal_t *journal = transaction->t_journal;\n\tint result;\n\tint wanted;\n\n\tresult = -EIO;\n\tif (is_handle_aborted(handle))\n\t\tgoto out;\n\n\tresult = 1;\n\n\tspin_lock(&journal->j_state_lock);\n\n\t/* Don't extend a locked-down transaction! */\n\tif (handle->h_transaction->t_state != T_RUNNING) {\n\t\tjbd_debug(3, \"denied handle %p %d blocks: \"\n\t\t\t  \"transaction not running\\n\", handle, nblocks);\n\t\tgoto error_out;\n\t}\n\n\tspin_lock(&transaction->t_handle_lock);\n\twanted = transaction->t_outstanding_credits + nblocks;\n\n\tif (wanted > journal->j_max_transaction_buffers) {\n\t\tjbd_debug(3, \"denied handle %p %d blocks: \"\n\t\t\t  \"transaction too large\\n\", handle, nblocks);\n\t\tgoto unlock;\n\t}\n\n\tif (wanted > __log_space_left(journal)) {\n\t\tjbd_debug(3, \"denied handle %p %d blocks: \"\n\t\t\t  \"insufficient log space\\n\", handle, nblocks);\n\t\tgoto unlock;\n\t}\n\n\thandle->h_buffer_credits += nblocks;\n\ttransaction->t_outstanding_credits += nblocks;\n\tresult = 0;\n\n\tjbd_debug(3, \"extended handle %p by %d\\n\", handle, nblocks);\nunlock:\n\tspin_unlock(&transaction->t_handle_lock);\nerror_out:\n\tspin_unlock(&journal->j_state_lock);\nout:\n\treturn result;\n}",
    "includes": [
      "#include <linux/hrtimer.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/timer.h>",
      "#include <linux/slab.h>",
      "#include <linux/errno.h>",
      "#include <linux/jbd.h>",
      "#include <linux/fs.h>",
      "#include <linux/time.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&journal->j_state_lock"
          ],
          "line": 365
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "jbd_debug",
          "args": [
            "3",
            "\"extended handle %p by %d\\n\"",
            "handle",
            "nblocks"
          ],
          "line": 361
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "jbd_debug",
          "args": [
            "3",
            "\"denied handle %p %d blocks: \"\n\t\t\t  \"insufficient log space\\n\"",
            "handle",
            "nblocks"
          ],
          "line": 352
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__log_space_left",
          "args": [
            "journal"
          ],
          "line": 351
        },
        "resolved": true,
        "details": {
          "function_name": "__log_space_left",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd/journal.c",
          "lines": "434-453",
          "snippet": "int __log_space_left(journal_t *journal)\n{\n\tint left = journal->j_free;\n\n\tassert_spin_locked(&journal->j_state_lock);\n\n\t/*\n\t * Be pessimistic here about the number of those free blocks which\n\t * might be required for log descriptor control blocks.\n\t */\n\n#define MIN_LOG_RESERVED_BLOCKS 32 /* Allow for rounding errors */\n\n\tleft -= MIN_LOG_RESERVED_BLOCKS;\n\n\tif (left <= 0)\n\t\treturn 0;\n\tleft -= (left >> 3);\n\treturn left;\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <asm/uaccess.h>",
            "#include <trace/events/jbd.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/poison.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/jbd.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [
            "#define MIN_LOG_RESERVED_BLOCKS 32 /* Allow for rounding errors */"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <trace/events/jbd.h>\n#include <linux/ratelimit.h>\n#include <linux/debugfs.h>\n#include <linux/proc_fs.h>\n#include <linux/poison.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/freezer.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\n#define MIN_LOG_RESERVED_BLOCKS 32 /* Allow for rounding errors */\n\nint __log_space_left(journal_t *journal)\n{\n\tint left = journal->j_free;\n\n\tassert_spin_locked(&journal->j_state_lock);\n\n\t/*\n\t * Be pessimistic here about the number of those free blocks which\n\t * might be required for log descriptor control blocks.\n\t */\n\n#define MIN_LOG_RESERVED_BLOCKS 32 /* Allow for rounding errors */\n\n\tleft -= MIN_LOG_RESERVED_BLOCKS;\n\n\tif (left <= 0)\n\t\treturn 0;\n\tleft -= (left >> 3);\n\treturn left;\n}"
        }
      },
      {
        "call_info": {
          "callee": "jbd_debug",
          "args": [
            "3",
            "\"denied handle %p %d blocks: \"\n\t\t\t  \"transaction too large\\n\"",
            "handle",
            "nblocks"
          ],
          "line": 346
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&transaction->t_handle_lock"
          ],
          "line": 342
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "jbd_debug",
          "args": [
            "3",
            "\"denied handle %p %d blocks: \"\n\t\t\t  \"transaction not running\\n\"",
            "handle",
            "nblocks"
          ],
          "line": 337
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_handle_aborted",
          "args": [
            "handle"
          ],
          "line": 328
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/timer.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n\nint journal_extend(handle_t *handle, int nblocks)\n{\n\ttransaction_t *transaction = handle->h_transaction;\n\tjournal_t *journal = transaction->t_journal;\n\tint result;\n\tint wanted;\n\n\tresult = -EIO;\n\tif (is_handle_aborted(handle))\n\t\tgoto out;\n\n\tresult = 1;\n\n\tspin_lock(&journal->j_state_lock);\n\n\t/* Don't extend a locked-down transaction! */\n\tif (handle->h_transaction->t_state != T_RUNNING) {\n\t\tjbd_debug(3, \"denied handle %p %d blocks: \"\n\t\t\t  \"transaction not running\\n\", handle, nblocks);\n\t\tgoto error_out;\n\t}\n\n\tspin_lock(&transaction->t_handle_lock);\n\twanted = transaction->t_outstanding_credits + nblocks;\n\n\tif (wanted > journal->j_max_transaction_buffers) {\n\t\tjbd_debug(3, \"denied handle %p %d blocks: \"\n\t\t\t  \"transaction too large\\n\", handle, nblocks);\n\t\tgoto unlock;\n\t}\n\n\tif (wanted > __log_space_left(journal)) {\n\t\tjbd_debug(3, \"denied handle %p %d blocks: \"\n\t\t\t  \"insufficient log space\\n\", handle, nblocks);\n\t\tgoto unlock;\n\t}\n\n\thandle->h_buffer_credits += nblocks;\n\ttransaction->t_outstanding_credits += nblocks;\n\tresult = 0;\n\n\tjbd_debug(3, \"extended handle %p by %d\\n\", handle, nblocks);\nunlock:\n\tspin_unlock(&transaction->t_handle_lock);\nerror_out:\n\tspin_unlock(&journal->j_state_lock);\nout:\n\treturn result;\n}"
  },
  {
    "function_name": "journal_start",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd/transaction.c",
    "lines": "271-298",
    "snippet": "handle_t *journal_start(journal_t *journal, int nblocks)\n{\n\thandle_t *handle = journal_current_handle();\n\tint err;\n\n\tif (!journal)\n\t\treturn ERR_PTR(-EROFS);\n\n\tif (handle) {\n\t\tJ_ASSERT(handle->h_transaction->t_journal == journal);\n\t\thandle->h_ref++;\n\t\treturn handle;\n\t}\n\n\thandle = new_handle(nblocks);\n\tif (!handle)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tcurrent->journal_info = handle;\n\n\terr = start_this_handle(journal, handle);\n\tif (err < 0) {\n\t\tjbd_free_handle(handle);\n\t\tcurrent->journal_info = NULL;\n\t\thandle = ERR_PTR(err);\n\t}\n\treturn handle;\n}",
    "includes": [
      "#include <linux/hrtimer.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/timer.h>",
      "#include <linux/slab.h>",
      "#include <linux/errno.h>",
      "#include <linux/jbd.h>",
      "#include <linux/fs.h>",
      "#include <linux/time.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "err"
          ],
          "line": 295
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "jbd_free_handle",
          "args": [
            "handle"
          ],
          "line": 293
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "start_this_handle",
          "args": [
            "journal",
            "handle"
          ],
          "line": 291
        },
        "resolved": true,
        "details": {
          "function_name": "start_this_handle",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd/transaction.c",
          "lines": "84-238",
          "snippet": "static int start_this_handle(journal_t *journal, handle_t *handle)\n{\n\ttransaction_t *transaction;\n\tint needed;\n\tint nblocks = handle->h_buffer_credits;\n\ttransaction_t *new_transaction = NULL;\n\tint ret = 0;\n\n\tif (nblocks > journal->j_max_transaction_buffers) {\n\t\tprintk(KERN_ERR \"JBD: %s wants too many credits (%d > %d)\\n\",\n\t\t       current->comm, nblocks,\n\t\t       journal->j_max_transaction_buffers);\n\t\tret = -ENOSPC;\n\t\tgoto out;\n\t}\n\nalloc_transaction:\n\tif (!journal->j_running_transaction) {\n\t\tnew_transaction = kzalloc(sizeof(*new_transaction),\n\t\t\t\t\t\tGFP_NOFS|__GFP_NOFAIL);\n\t\tif (!new_transaction) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tjbd_debug(3, \"New handle %p going live.\\n\", handle);\n\nrepeat:\n\n\t/*\n\t * We need to hold j_state_lock until t_updates has been incremented,\n\t * for proper journal barrier handling\n\t */\n\tspin_lock(&journal->j_state_lock);\nrepeat_locked:\n\tif (is_journal_aborted(journal) ||\n\t    (journal->j_errno != 0 && !(journal->j_flags & JFS_ACK_ERR))) {\n\t\tspin_unlock(&journal->j_state_lock);\n\t\tret = -EROFS;\n\t\tgoto out;\n\t}\n\n\t/* Wait on the journal's transaction barrier if necessary */\n\tif (journal->j_barrier_count) {\n\t\tspin_unlock(&journal->j_state_lock);\n\t\twait_event(journal->j_wait_transaction_locked,\n\t\t\t\tjournal->j_barrier_count == 0);\n\t\tgoto repeat;\n\t}\n\n\tif (!journal->j_running_transaction) {\n\t\tif (!new_transaction) {\n\t\t\tspin_unlock(&journal->j_state_lock);\n\t\t\tgoto alloc_transaction;\n\t\t}\n\t\tget_transaction(journal, new_transaction);\n\t\tnew_transaction = NULL;\n\t}\n\n\ttransaction = journal->j_running_transaction;\n\n\t/*\n\t * If the current transaction is locked down for commit, wait for the\n\t * lock to be released.\n\t */\n\tif (transaction->t_state == T_LOCKED) {\n\t\tDEFINE_WAIT(wait);\n\n\t\tprepare_to_wait(&journal->j_wait_transaction_locked,\n\t\t\t\t\t&wait, TASK_UNINTERRUPTIBLE);\n\t\tspin_unlock(&journal->j_state_lock);\n\t\tschedule();\n\t\tfinish_wait(&journal->j_wait_transaction_locked, &wait);\n\t\tgoto repeat;\n\t}\n\n\t/*\n\t * If there is not enough space left in the log to write all potential\n\t * buffers requested by this operation, we need to stall pending a log\n\t * checkpoint to free some more log space.\n\t */\n\tspin_lock(&transaction->t_handle_lock);\n\tneeded = transaction->t_outstanding_credits + nblocks;\n\n\tif (needed > journal->j_max_transaction_buffers) {\n\t\t/*\n\t\t * If the current transaction is already too large, then start\n\t\t * to commit it: we can then go back and attach this handle to\n\t\t * a new transaction.\n\t\t */\n\t\tDEFINE_WAIT(wait);\n\n\t\tjbd_debug(2, \"Handle %p starting new commit...\\n\", handle);\n\t\tspin_unlock(&transaction->t_handle_lock);\n\t\tprepare_to_wait(&journal->j_wait_transaction_locked, &wait,\n\t\t\t\tTASK_UNINTERRUPTIBLE);\n\t\t__log_start_commit(journal, transaction->t_tid);\n\t\tspin_unlock(&journal->j_state_lock);\n\t\tschedule();\n\t\tfinish_wait(&journal->j_wait_transaction_locked, &wait);\n\t\tgoto repeat;\n\t}\n\n\t/*\n\t * The commit code assumes that it can get enough log space\n\t * without forcing a checkpoint.  This is *critical* for\n\t * correctness: a checkpoint of a buffer which is also\n\t * associated with a committing transaction creates a deadlock,\n\t * so commit simply cannot force through checkpoints.\n\t *\n\t * We must therefore ensure the necessary space in the journal\n\t * *before* starting to dirty potentially checkpointed buffers\n\t * in the new transaction.\n\t *\n\t * The worst part is, any transaction currently committing can\n\t * reduce the free space arbitrarily.  Be careful to account for\n\t * those buffers when checkpointing.\n\t */\n\n\t/*\n\t * @@@ AKPM: This seems rather over-defensive.  We're giving commit\n\t * a _lot_ of headroom: 1/4 of the journal plus the size of\n\t * the committing transaction.  Really, we only need to give it\n\t * committing_transaction->t_outstanding_credits plus \"enough\" for\n\t * the log control blocks.\n\t * Also, this test is inconsistent with the matching one in\n\t * journal_extend().\n\t */\n\tif (__log_space_left(journal) < jbd_space_needed(journal)) {\n\t\tjbd_debug(2, \"Handle %p waiting for checkpoint...\\n\", handle);\n\t\tspin_unlock(&transaction->t_handle_lock);\n\t\t__log_wait_for_space(journal);\n\t\tgoto repeat_locked;\n\t}\n\n\t/* OK, account for the buffers that this operation expects to\n\t * use and add the handle to the running transaction. */\n\n\thandle->h_transaction = transaction;\n\ttransaction->t_outstanding_credits += nblocks;\n\ttransaction->t_updates++;\n\ttransaction->t_handle_count++;\n\tjbd_debug(4, \"Handle %p given %d credits (total %d, free %d)\\n\",\n\t\t  handle, nblocks, transaction->t_outstanding_credits,\n\t\t  __log_space_left(journal));\n\tspin_unlock(&transaction->t_handle_lock);\n\tspin_unlock(&journal->j_state_lock);\n\n\tlock_map_acquire(&handle->h_lockdep_map);\nout:\n\tif (unlikely(new_transaction))\t\t/* It's usually NULL */\n\t\tkfree(new_transaction);\n\treturn ret;\n}",
          "includes": [
            "#include <linux/hrtimer.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/timer.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/jbd.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/timer.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n\nstatic int start_this_handle(journal_t *journal, handle_t *handle)\n{\n\ttransaction_t *transaction;\n\tint needed;\n\tint nblocks = handle->h_buffer_credits;\n\ttransaction_t *new_transaction = NULL;\n\tint ret = 0;\n\n\tif (nblocks > journal->j_max_transaction_buffers) {\n\t\tprintk(KERN_ERR \"JBD: %s wants too many credits (%d > %d)\\n\",\n\t\t       current->comm, nblocks,\n\t\t       journal->j_max_transaction_buffers);\n\t\tret = -ENOSPC;\n\t\tgoto out;\n\t}\n\nalloc_transaction:\n\tif (!journal->j_running_transaction) {\n\t\tnew_transaction = kzalloc(sizeof(*new_transaction),\n\t\t\t\t\t\tGFP_NOFS|__GFP_NOFAIL);\n\t\tif (!new_transaction) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tjbd_debug(3, \"New handle %p going live.\\n\", handle);\n\nrepeat:\n\n\t/*\n\t * We need to hold j_state_lock until t_updates has been incremented,\n\t * for proper journal barrier handling\n\t */\n\tspin_lock(&journal->j_state_lock);\nrepeat_locked:\n\tif (is_journal_aborted(journal) ||\n\t    (journal->j_errno != 0 && !(journal->j_flags & JFS_ACK_ERR))) {\n\t\tspin_unlock(&journal->j_state_lock);\n\t\tret = -EROFS;\n\t\tgoto out;\n\t}\n\n\t/* Wait on the journal's transaction barrier if necessary */\n\tif (journal->j_barrier_count) {\n\t\tspin_unlock(&journal->j_state_lock);\n\t\twait_event(journal->j_wait_transaction_locked,\n\t\t\t\tjournal->j_barrier_count == 0);\n\t\tgoto repeat;\n\t}\n\n\tif (!journal->j_running_transaction) {\n\t\tif (!new_transaction) {\n\t\t\tspin_unlock(&journal->j_state_lock);\n\t\t\tgoto alloc_transaction;\n\t\t}\n\t\tget_transaction(journal, new_transaction);\n\t\tnew_transaction = NULL;\n\t}\n\n\ttransaction = journal->j_running_transaction;\n\n\t/*\n\t * If the current transaction is locked down for commit, wait for the\n\t * lock to be released.\n\t */\n\tif (transaction->t_state == T_LOCKED) {\n\t\tDEFINE_WAIT(wait);\n\n\t\tprepare_to_wait(&journal->j_wait_transaction_locked,\n\t\t\t\t\t&wait, TASK_UNINTERRUPTIBLE);\n\t\tspin_unlock(&journal->j_state_lock);\n\t\tschedule();\n\t\tfinish_wait(&journal->j_wait_transaction_locked, &wait);\n\t\tgoto repeat;\n\t}\n\n\t/*\n\t * If there is not enough space left in the log to write all potential\n\t * buffers requested by this operation, we need to stall pending a log\n\t * checkpoint to free some more log space.\n\t */\n\tspin_lock(&transaction->t_handle_lock);\n\tneeded = transaction->t_outstanding_credits + nblocks;\n\n\tif (needed > journal->j_max_transaction_buffers) {\n\t\t/*\n\t\t * If the current transaction is already too large, then start\n\t\t * to commit it: we can then go back and attach this handle to\n\t\t * a new transaction.\n\t\t */\n\t\tDEFINE_WAIT(wait);\n\n\t\tjbd_debug(2, \"Handle %p starting new commit...\\n\", handle);\n\t\tspin_unlock(&transaction->t_handle_lock);\n\t\tprepare_to_wait(&journal->j_wait_transaction_locked, &wait,\n\t\t\t\tTASK_UNINTERRUPTIBLE);\n\t\t__log_start_commit(journal, transaction->t_tid);\n\t\tspin_unlock(&journal->j_state_lock);\n\t\tschedule();\n\t\tfinish_wait(&journal->j_wait_transaction_locked, &wait);\n\t\tgoto repeat;\n\t}\n\n\t/*\n\t * The commit code assumes that it can get enough log space\n\t * without forcing a checkpoint.  This is *critical* for\n\t * correctness: a checkpoint of a buffer which is also\n\t * associated with a committing transaction creates a deadlock,\n\t * so commit simply cannot force through checkpoints.\n\t *\n\t * We must therefore ensure the necessary space in the journal\n\t * *before* starting to dirty potentially checkpointed buffers\n\t * in the new transaction.\n\t *\n\t * The worst part is, any transaction currently committing can\n\t * reduce the free space arbitrarily.  Be careful to account for\n\t * those buffers when checkpointing.\n\t */\n\n\t/*\n\t * @@@ AKPM: This seems rather over-defensive.  We're giving commit\n\t * a _lot_ of headroom: 1/4 of the journal plus the size of\n\t * the committing transaction.  Really, we only need to give it\n\t * committing_transaction->t_outstanding_credits plus \"enough\" for\n\t * the log control blocks.\n\t * Also, this test is inconsistent with the matching one in\n\t * journal_extend().\n\t */\n\tif (__log_space_left(journal) < jbd_space_needed(journal)) {\n\t\tjbd_debug(2, \"Handle %p waiting for checkpoint...\\n\", handle);\n\t\tspin_unlock(&transaction->t_handle_lock);\n\t\t__log_wait_for_space(journal);\n\t\tgoto repeat_locked;\n\t}\n\n\t/* OK, account for the buffers that this operation expects to\n\t * use and add the handle to the running transaction. */\n\n\thandle->h_transaction = transaction;\n\ttransaction->t_outstanding_credits += nblocks;\n\ttransaction->t_updates++;\n\ttransaction->t_handle_count++;\n\tjbd_debug(4, \"Handle %p given %d credits (total %d, free %d)\\n\",\n\t\t  handle, nblocks, transaction->t_outstanding_credits,\n\t\t  __log_space_left(journal));\n\tspin_unlock(&transaction->t_handle_lock);\n\tspin_unlock(&journal->j_state_lock);\n\n\tlock_map_acquire(&handle->h_lockdep_map);\nout:\n\tif (unlikely(new_transaction))\t\t/* It's usually NULL */\n\t\tkfree(new_transaction);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ENOMEM"
          ],
          "line": 287
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "new_handle",
          "args": [
            "nblocks"
          ],
          "line": 285
        },
        "resolved": true,
        "details": {
          "function_name": "new_handle",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd/transaction.c",
          "lines": "243-254",
          "snippet": "static handle_t *new_handle(int nblocks)\n{\n\thandle_t *handle = jbd_alloc_handle(GFP_NOFS);\n\tif (!handle)\n\t\treturn NULL;\n\thandle->h_buffer_credits = nblocks;\n\thandle->h_ref = 1;\n\n\tlockdep_init_map(&handle->h_lockdep_map, \"jbd_handle\", &jbd_handle_key, 0);\n\n\treturn handle;\n}",
          "includes": [
            "#include <linux/hrtimer.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/timer.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/jbd.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct lock_class_key jbd_handle_key;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/timer.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n\nstatic struct lock_class_key jbd_handle_key;\n\nstatic handle_t *new_handle(int nblocks)\n{\n\thandle_t *handle = jbd_alloc_handle(GFP_NOFS);\n\tif (!handle)\n\t\treturn NULL;\n\thandle->h_buffer_credits = nblocks;\n\thandle->h_ref = 1;\n\n\tlockdep_init_map(&handle->h_lockdep_map, \"jbd_handle\", &jbd_handle_key, 0);\n\n\treturn handle;\n}"
        }
      },
      {
        "call_info": {
          "callee": "J_ASSERT",
          "args": [
            "handle->h_transaction->t_journal == journal"
          ],
          "line": 280
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-EROFS"
          ],
          "line": 277
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "journal_current_handle",
          "args": [],
          "line": 273
        },
        "resolved": true,
        "details": {
          "function_name": "ext3_journal_current_handle",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/ext3.h",
          "lines": "1271-1274",
          "snippet": "static inline handle_t *ext3_journal_current_handle(void)\n{\n\treturn journal_current_handle();\n}",
          "includes": [
            "#include <trace/events/ext3.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/bug.h>",
            "#include <linux/magic.h>",
            "#include <linux/jbd.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext3.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/bug.h>\n#include <linux/magic.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n\nstatic inline handle_t *ext3_journal_current_handle(void)\n{\n\treturn journal_current_handle();\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/timer.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n\nhandle_t *journal_start(journal_t *journal, int nblocks)\n{\n\thandle_t *handle = journal_current_handle();\n\tint err;\n\n\tif (!journal)\n\t\treturn ERR_PTR(-EROFS);\n\n\tif (handle) {\n\t\tJ_ASSERT(handle->h_transaction->t_journal == journal);\n\t\thandle->h_ref++;\n\t\treturn handle;\n\t}\n\n\thandle = new_handle(nblocks);\n\tif (!handle)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tcurrent->journal_info = handle;\n\n\terr = start_this_handle(journal, handle);\n\tif (err < 0) {\n\t\tjbd_free_handle(handle);\n\t\tcurrent->journal_info = NULL;\n\t\thandle = ERR_PTR(err);\n\t}\n\treturn handle;\n}"
  },
  {
    "function_name": "new_handle",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd/transaction.c",
    "lines": "243-254",
    "snippet": "static handle_t *new_handle(int nblocks)\n{\n\thandle_t *handle = jbd_alloc_handle(GFP_NOFS);\n\tif (!handle)\n\t\treturn NULL;\n\thandle->h_buffer_credits = nblocks;\n\thandle->h_ref = 1;\n\n\tlockdep_init_map(&handle->h_lockdep_map, \"jbd_handle\", &jbd_handle_key, 0);\n\n\treturn handle;\n}",
    "includes": [
      "#include <linux/hrtimer.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/timer.h>",
      "#include <linux/slab.h>",
      "#include <linux/errno.h>",
      "#include <linux/jbd.h>",
      "#include <linux/fs.h>",
      "#include <linux/time.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct lock_class_key jbd_handle_key;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "lockdep_init_map",
          "args": [
            "&handle->h_lockdep_map",
            "\"jbd_handle\"",
            "&jbd_handle_key",
            "0"
          ],
          "line": 251
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "jbd_alloc_handle",
          "args": [
            "GFP_NOFS"
          ],
          "line": 245
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/timer.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n\nstatic struct lock_class_key jbd_handle_key;\n\nstatic handle_t *new_handle(int nblocks)\n{\n\thandle_t *handle = jbd_alloc_handle(GFP_NOFS);\n\tif (!handle)\n\t\treturn NULL;\n\thandle->h_buffer_credits = nblocks;\n\thandle->h_ref = 1;\n\n\tlockdep_init_map(&handle->h_lockdep_map, \"jbd_handle\", &jbd_handle_key, 0);\n\n\treturn handle;\n}"
  },
  {
    "function_name": "start_this_handle",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd/transaction.c",
    "lines": "84-238",
    "snippet": "static int start_this_handle(journal_t *journal, handle_t *handle)\n{\n\ttransaction_t *transaction;\n\tint needed;\n\tint nblocks = handle->h_buffer_credits;\n\ttransaction_t *new_transaction = NULL;\n\tint ret = 0;\n\n\tif (nblocks > journal->j_max_transaction_buffers) {\n\t\tprintk(KERN_ERR \"JBD: %s wants too many credits (%d > %d)\\n\",\n\t\t       current->comm, nblocks,\n\t\t       journal->j_max_transaction_buffers);\n\t\tret = -ENOSPC;\n\t\tgoto out;\n\t}\n\nalloc_transaction:\n\tif (!journal->j_running_transaction) {\n\t\tnew_transaction = kzalloc(sizeof(*new_transaction),\n\t\t\t\t\t\tGFP_NOFS|__GFP_NOFAIL);\n\t\tif (!new_transaction) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tjbd_debug(3, \"New handle %p going live.\\n\", handle);\n\nrepeat:\n\n\t/*\n\t * We need to hold j_state_lock until t_updates has been incremented,\n\t * for proper journal barrier handling\n\t */\n\tspin_lock(&journal->j_state_lock);\nrepeat_locked:\n\tif (is_journal_aborted(journal) ||\n\t    (journal->j_errno != 0 && !(journal->j_flags & JFS_ACK_ERR))) {\n\t\tspin_unlock(&journal->j_state_lock);\n\t\tret = -EROFS;\n\t\tgoto out;\n\t}\n\n\t/* Wait on the journal's transaction barrier if necessary */\n\tif (journal->j_barrier_count) {\n\t\tspin_unlock(&journal->j_state_lock);\n\t\twait_event(journal->j_wait_transaction_locked,\n\t\t\t\tjournal->j_barrier_count == 0);\n\t\tgoto repeat;\n\t}\n\n\tif (!journal->j_running_transaction) {\n\t\tif (!new_transaction) {\n\t\t\tspin_unlock(&journal->j_state_lock);\n\t\t\tgoto alloc_transaction;\n\t\t}\n\t\tget_transaction(journal, new_transaction);\n\t\tnew_transaction = NULL;\n\t}\n\n\ttransaction = journal->j_running_transaction;\n\n\t/*\n\t * If the current transaction is locked down for commit, wait for the\n\t * lock to be released.\n\t */\n\tif (transaction->t_state == T_LOCKED) {\n\t\tDEFINE_WAIT(wait);\n\n\t\tprepare_to_wait(&journal->j_wait_transaction_locked,\n\t\t\t\t\t&wait, TASK_UNINTERRUPTIBLE);\n\t\tspin_unlock(&journal->j_state_lock);\n\t\tschedule();\n\t\tfinish_wait(&journal->j_wait_transaction_locked, &wait);\n\t\tgoto repeat;\n\t}\n\n\t/*\n\t * If there is not enough space left in the log to write all potential\n\t * buffers requested by this operation, we need to stall pending a log\n\t * checkpoint to free some more log space.\n\t */\n\tspin_lock(&transaction->t_handle_lock);\n\tneeded = transaction->t_outstanding_credits + nblocks;\n\n\tif (needed > journal->j_max_transaction_buffers) {\n\t\t/*\n\t\t * If the current transaction is already too large, then start\n\t\t * to commit it: we can then go back and attach this handle to\n\t\t * a new transaction.\n\t\t */\n\t\tDEFINE_WAIT(wait);\n\n\t\tjbd_debug(2, \"Handle %p starting new commit...\\n\", handle);\n\t\tspin_unlock(&transaction->t_handle_lock);\n\t\tprepare_to_wait(&journal->j_wait_transaction_locked, &wait,\n\t\t\t\tTASK_UNINTERRUPTIBLE);\n\t\t__log_start_commit(journal, transaction->t_tid);\n\t\tspin_unlock(&journal->j_state_lock);\n\t\tschedule();\n\t\tfinish_wait(&journal->j_wait_transaction_locked, &wait);\n\t\tgoto repeat;\n\t}\n\n\t/*\n\t * The commit code assumes that it can get enough log space\n\t * without forcing a checkpoint.  This is *critical* for\n\t * correctness: a checkpoint of a buffer which is also\n\t * associated with a committing transaction creates a deadlock,\n\t * so commit simply cannot force through checkpoints.\n\t *\n\t * We must therefore ensure the necessary space in the journal\n\t * *before* starting to dirty potentially checkpointed buffers\n\t * in the new transaction.\n\t *\n\t * The worst part is, any transaction currently committing can\n\t * reduce the free space arbitrarily.  Be careful to account for\n\t * those buffers when checkpointing.\n\t */\n\n\t/*\n\t * @@@ AKPM: This seems rather over-defensive.  We're giving commit\n\t * a _lot_ of headroom: 1/4 of the journal plus the size of\n\t * the committing transaction.  Really, we only need to give it\n\t * committing_transaction->t_outstanding_credits plus \"enough\" for\n\t * the log control blocks.\n\t * Also, this test is inconsistent with the matching one in\n\t * journal_extend().\n\t */\n\tif (__log_space_left(journal) < jbd_space_needed(journal)) {\n\t\tjbd_debug(2, \"Handle %p waiting for checkpoint...\\n\", handle);\n\t\tspin_unlock(&transaction->t_handle_lock);\n\t\t__log_wait_for_space(journal);\n\t\tgoto repeat_locked;\n\t}\n\n\t/* OK, account for the buffers that this operation expects to\n\t * use and add the handle to the running transaction. */\n\n\thandle->h_transaction = transaction;\n\ttransaction->t_outstanding_credits += nblocks;\n\ttransaction->t_updates++;\n\ttransaction->t_handle_count++;\n\tjbd_debug(4, \"Handle %p given %d credits (total %d, free %d)\\n\",\n\t\t  handle, nblocks, transaction->t_outstanding_credits,\n\t\t  __log_space_left(journal));\n\tspin_unlock(&transaction->t_handle_lock);\n\tspin_unlock(&journal->j_state_lock);\n\n\tlock_map_acquire(&handle->h_lockdep_map);\nout:\n\tif (unlikely(new_transaction))\t\t/* It's usually NULL */\n\t\tkfree(new_transaction);\n\treturn ret;\n}",
    "includes": [
      "#include <linux/hrtimer.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/timer.h>",
      "#include <linux/slab.h>",
      "#include <linux/errno.h>",
      "#include <linux/jbd.h>",
      "#include <linux/fs.h>",
      "#include <linux/time.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "new_transaction"
          ],
          "line": 236
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "new_transaction"
          ],
          "line": 235
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lock_map_acquire",
          "args": [
            "&handle->h_lockdep_map"
          ],
          "line": 233
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&journal->j_state_lock"
          ],
          "line": 231
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "jbd_debug",
          "args": [
            "4",
            "\"Handle %p given %d credits (total %d, free %d)\\n\"",
            "handle",
            "nblocks",
            "transaction->t_outstanding_credits",
            "__log_space_left(journal)"
          ],
          "line": 227
        },
        "resolved": true,
        "details": {
          "function_name": "__jbd_debug",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd/journal.c",
          "lines": "94-107",
          "snippet": "void __jbd_debug(int level, const char *file, const char *func,\n\t\t unsigned int line, const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tif (level > journal_enable_debug)\n\t\treturn;\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tprintk(KERN_DEBUG \"%s: (%s, %u): %pV\\n\", file, func, line, &vaf);\n\tva_end(args);\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <asm/uaccess.h>",
            "#include <trace/events/jbd.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/poison.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/jbd.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <trace/events/jbd.h>\n#include <linux/ratelimit.h>\n#include <linux/debugfs.h>\n#include <linux/proc_fs.h>\n#include <linux/poison.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/freezer.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nvoid __jbd_debug(int level, const char *file, const char *func,\n\t\t unsigned int line, const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tif (level > journal_enable_debug)\n\t\treturn;\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tprintk(KERN_DEBUG \"%s: (%s, %u): %pV\\n\", file, func, line, &vaf);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__log_space_left",
          "args": [
            "journal"
          ],
          "line": 229
        },
        "resolved": true,
        "details": {
          "function_name": "__log_space_left",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd/journal.c",
          "lines": "434-453",
          "snippet": "int __log_space_left(journal_t *journal)\n{\n\tint left = journal->j_free;\n\n\tassert_spin_locked(&journal->j_state_lock);\n\n\t/*\n\t * Be pessimistic here about the number of those free blocks which\n\t * might be required for log descriptor control blocks.\n\t */\n\n#define MIN_LOG_RESERVED_BLOCKS 32 /* Allow for rounding errors */\n\n\tleft -= MIN_LOG_RESERVED_BLOCKS;\n\n\tif (left <= 0)\n\t\treturn 0;\n\tleft -= (left >> 3);\n\treturn left;\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <asm/uaccess.h>",
            "#include <trace/events/jbd.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/poison.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/jbd.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [
            "#define MIN_LOG_RESERVED_BLOCKS 32 /* Allow for rounding errors */"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <trace/events/jbd.h>\n#include <linux/ratelimit.h>\n#include <linux/debugfs.h>\n#include <linux/proc_fs.h>\n#include <linux/poison.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/freezer.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\n#define MIN_LOG_RESERVED_BLOCKS 32 /* Allow for rounding errors */\n\nint __log_space_left(journal_t *journal)\n{\n\tint left = journal->j_free;\n\n\tassert_spin_locked(&journal->j_state_lock);\n\n\t/*\n\t * Be pessimistic here about the number of those free blocks which\n\t * might be required for log descriptor control blocks.\n\t */\n\n#define MIN_LOG_RESERVED_BLOCKS 32 /* Allow for rounding errors */\n\n\tleft -= MIN_LOG_RESERVED_BLOCKS;\n\n\tif (left <= 0)\n\t\treturn 0;\n\tleft -= (left >> 3);\n\treturn left;\n}"
        }
      },
      {
        "call_info": {
          "callee": "__log_wait_for_space",
          "args": [
            "journal"
          ],
          "line": 216
        },
        "resolved": true,
        "details": {
          "function_name": "__log_wait_for_space",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd/checkpoint.c",
          "lines": "122-179",
          "snippet": "void __log_wait_for_space(journal_t *journal)\n{\n\tint nblocks, space_left;\n\tassert_spin_locked(&journal->j_state_lock);\n\n\tnblocks = jbd_space_needed(journal);\n\twhile (__log_space_left(journal) < nblocks) {\n\t\tif (journal->j_flags & JFS_ABORT)\n\t\t\treturn;\n\t\tspin_unlock(&journal->j_state_lock);\n\t\tmutex_lock(&journal->j_checkpoint_mutex);\n\n\t\t/*\n\t\t * Test again, another process may have checkpointed while we\n\t\t * were waiting for the checkpoint lock. If there are no\n\t\t * transactions ready to be checkpointed, try to recover\n\t\t * journal space by calling cleanup_journal_tail(), and if\n\t\t * that doesn't work, by waiting for the currently committing\n\t\t * transaction to complete.  If there is absolutely no way\n\t\t * to make progress, this is either a BUG or corrupted\n\t\t * filesystem, so abort the journal and leave a stack\n\t\t * trace for forensic evidence.\n\t\t */\n\t\tspin_lock(&journal->j_state_lock);\n\t\tspin_lock(&journal->j_list_lock);\n\t\tnblocks = jbd_space_needed(journal);\n\t\tspace_left = __log_space_left(journal);\n\t\tif (space_left < nblocks) {\n\t\t\tint chkpt = journal->j_checkpoint_transactions != NULL;\n\t\t\ttid_t tid = 0;\n\n\t\t\tif (journal->j_committing_transaction)\n\t\t\t\ttid = journal->j_committing_transaction->t_tid;\n\t\t\tspin_unlock(&journal->j_list_lock);\n\t\t\tspin_unlock(&journal->j_state_lock);\n\t\t\tif (chkpt) {\n\t\t\t\tlog_do_checkpoint(journal);\n\t\t\t} else if (cleanup_journal_tail(journal) == 0) {\n\t\t\t\t/* We were able to recover space; yay! */\n\t\t\t\t;\n\t\t\t} else if (tid) {\n\t\t\t\tlog_wait_commit(journal, tid);\n\t\t\t} else {\n\t\t\t\tprintk(KERN_ERR \"%s: needed %d blocks and \"\n\t\t\t\t       \"only had %d space available\\n\",\n\t\t\t\t       __func__, nblocks, space_left);\n\t\t\t\tprintk(KERN_ERR \"%s: no way to get more \"\n\t\t\t\t       \"journal space\\n\", __func__);\n\t\t\t\tWARN_ON(1);\n\t\t\t\tjournal_abort(journal, 0);\n\t\t\t}\n\t\t\tspin_lock(&journal->j_state_lock);\n\t\t} else {\n\t\t\tspin_unlock(&journal->j_list_lock);\n\t\t}\n\t\tmutex_unlock(&journal->j_checkpoint_mutex);\n\t}\n}",
          "includes": [
            "#include <trace/events/jbd.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/jbd.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/jbd.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n\nvoid __log_wait_for_space(journal_t *journal)\n{\n\tint nblocks, space_left;\n\tassert_spin_locked(&journal->j_state_lock);\n\n\tnblocks = jbd_space_needed(journal);\n\twhile (__log_space_left(journal) < nblocks) {\n\t\tif (journal->j_flags & JFS_ABORT)\n\t\t\treturn;\n\t\tspin_unlock(&journal->j_state_lock);\n\t\tmutex_lock(&journal->j_checkpoint_mutex);\n\n\t\t/*\n\t\t * Test again, another process may have checkpointed while we\n\t\t * were waiting for the checkpoint lock. If there are no\n\t\t * transactions ready to be checkpointed, try to recover\n\t\t * journal space by calling cleanup_journal_tail(), and if\n\t\t * that doesn't work, by waiting for the currently committing\n\t\t * transaction to complete.  If there is absolutely no way\n\t\t * to make progress, this is either a BUG or corrupted\n\t\t * filesystem, so abort the journal and leave a stack\n\t\t * trace for forensic evidence.\n\t\t */\n\t\tspin_lock(&journal->j_state_lock);\n\t\tspin_lock(&journal->j_list_lock);\n\t\tnblocks = jbd_space_needed(journal);\n\t\tspace_left = __log_space_left(journal);\n\t\tif (space_left < nblocks) {\n\t\t\tint chkpt = journal->j_checkpoint_transactions != NULL;\n\t\t\ttid_t tid = 0;\n\n\t\t\tif (journal->j_committing_transaction)\n\t\t\t\ttid = journal->j_committing_transaction->t_tid;\n\t\t\tspin_unlock(&journal->j_list_lock);\n\t\t\tspin_unlock(&journal->j_state_lock);\n\t\t\tif (chkpt) {\n\t\t\t\tlog_do_checkpoint(journal);\n\t\t\t} else if (cleanup_journal_tail(journal) == 0) {\n\t\t\t\t/* We were able to recover space; yay! */\n\t\t\t\t;\n\t\t\t} else if (tid) {\n\t\t\t\tlog_wait_commit(journal, tid);\n\t\t\t} else {\n\t\t\t\tprintk(KERN_ERR \"%s: needed %d blocks and \"\n\t\t\t\t       \"only had %d space available\\n\",\n\t\t\t\t       __func__, nblocks, space_left);\n\t\t\t\tprintk(KERN_ERR \"%s: no way to get more \"\n\t\t\t\t       \"journal space\\n\", __func__);\n\t\t\t\tWARN_ON(1);\n\t\t\t\tjournal_abort(journal, 0);\n\t\t\t}\n\t\t\tspin_lock(&journal->j_state_lock);\n\t\t} else {\n\t\t\tspin_unlock(&journal->j_list_lock);\n\t\t}\n\t\tmutex_unlock(&journal->j_checkpoint_mutex);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "jbd_debug",
          "args": [
            "2",
            "\"Handle %p waiting for checkpoint...\\n\"",
            "handle"
          ],
          "line": 214
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "jbd_space_needed",
          "args": [
            "journal"
          ],
          "line": 213
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "finish_wait",
          "args": [
            "&journal->j_wait_transaction_locked",
            "&wait"
          ],
          "line": 184
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "schedule",
          "args": [],
          "line": 183
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__log_start_commit",
          "args": [
            "journal",
            "transaction->t_tid"
          ],
          "line": 181
        },
        "resolved": true,
        "details": {
          "function_name": "__log_start_commit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd/journal.c",
          "lines": "458-488",
          "snippet": "int __log_start_commit(journal_t *journal, tid_t target)\n{\n\t/*\n\t * The only transaction we can possibly wait upon is the\n\t * currently running transaction (if it exists).  Otherwise,\n\t * the target tid must be an old one.\n\t */\n\tif (journal->j_commit_request != target &&\n\t    journal->j_running_transaction &&\n\t    journal->j_running_transaction->t_tid == target) {\n\t\t/*\n\t\t * We want a new commit: OK, mark the request and wakeup the\n\t\t * commit thread.  We do _not_ do the commit ourselves.\n\t\t */\n\n\t\tjournal->j_commit_request = target;\n\t\tjbd_debug(1, \"JBD: requesting commit %d/%d\\n\",\n\t\t\t  journal->j_commit_request,\n\t\t\t  journal->j_commit_sequence);\n\t\twake_up(&journal->j_wait_commit);\n\t\treturn 1;\n\t} else if (!tid_geq(journal->j_commit_request, target))\n\t\t/* This should never happen, but if it does, preserve\n\t\t   the evidence before kjournald goes into a loop and\n\t\t   increments j_commit_sequence beyond all recognition. */\n\t\tWARN_ONCE(1, \"jbd: bad log_start_commit: %u %u %u %u\\n\",\n\t\t    journal->j_commit_request, journal->j_commit_sequence,\n\t\t    target, journal->j_running_transaction ?\n\t\t    journal->j_running_transaction->t_tid : 0);\n\treturn 0;\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <asm/uaccess.h>",
            "#include <trace/events/jbd.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/poison.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/jbd.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <trace/events/jbd.h>\n#include <linux/ratelimit.h>\n#include <linux/debugfs.h>\n#include <linux/proc_fs.h>\n#include <linux/poison.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/freezer.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nint __log_start_commit(journal_t *journal, tid_t target)\n{\n\t/*\n\t * The only transaction we can possibly wait upon is the\n\t * currently running transaction (if it exists).  Otherwise,\n\t * the target tid must be an old one.\n\t */\n\tif (journal->j_commit_request != target &&\n\t    journal->j_running_transaction &&\n\t    journal->j_running_transaction->t_tid == target) {\n\t\t/*\n\t\t * We want a new commit: OK, mark the request and wakeup the\n\t\t * commit thread.  We do _not_ do the commit ourselves.\n\t\t */\n\n\t\tjournal->j_commit_request = target;\n\t\tjbd_debug(1, \"JBD: requesting commit %d/%d\\n\",\n\t\t\t  journal->j_commit_request,\n\t\t\t  journal->j_commit_sequence);\n\t\twake_up(&journal->j_wait_commit);\n\t\treturn 1;\n\t} else if (!tid_geq(journal->j_commit_request, target))\n\t\t/* This should never happen, but if it does, preserve\n\t\t   the evidence before kjournald goes into a loop and\n\t\t   increments j_commit_sequence beyond all recognition. */\n\t\tWARN_ONCE(1, \"jbd: bad log_start_commit: %u %u %u %u\\n\",\n\t\t    journal->j_commit_request, journal->j_commit_sequence,\n\t\t    target, journal->j_running_transaction ?\n\t\t    journal->j_running_transaction->t_tid : 0);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "prepare_to_wait",
          "args": [
            "&journal->j_wait_transaction_locked",
            "&wait",
            "TASK_UNINTERRUPTIBLE"
          ],
          "line": 179
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "jbd_debug",
          "args": [
            "2",
            "\"Handle %p starting new commit...\\n\"",
            "handle"
          ],
          "line": 177
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DEFINE_WAIT",
          "args": [
            "wait"
          ],
          "line": 175
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&transaction->t_handle_lock"
          ],
          "line": 166
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "finish_wait",
          "args": [
            "&journal->j_wait_transaction_locked",
            "&wait"
          ],
          "line": 157
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "schedule",
          "args": [],
          "line": 156
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "prepare_to_wait",
          "args": [
            "&journal->j_wait_transaction_locked",
            "&wait",
            "TASK_UNINTERRUPTIBLE"
          ],
          "line": 153
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DEFINE_WAIT",
          "args": [
            "wait"
          ],
          "line": 151
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_transaction",
          "args": [
            "journal",
            "new_transaction"
          ],
          "line": 140
        },
        "resolved": true,
        "details": {
          "function_name": "get_transaction",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd/transaction.c",
          "lines": "48-67",
          "snippet": "static transaction_t *\nget_transaction(journal_t *journal, transaction_t *transaction)\n{\n\ttransaction->t_journal = journal;\n\ttransaction->t_state = T_RUNNING;\n\ttransaction->t_start_time = ktime_get();\n\ttransaction->t_tid = journal->j_transaction_sequence++;\n\ttransaction->t_expires = jiffies + journal->j_commit_interval;\n\tspin_lock_init(&transaction->t_handle_lock);\n\n\t/* Set up the commit timer for the new transaction. */\n\tjournal->j_commit_timer.expires =\n\t\t\t\tround_jiffies_up(transaction->t_expires);\n\tadd_timer(&journal->j_commit_timer);\n\n\tJ_ASSERT(journal->j_running_transaction == NULL);\n\tjournal->j_running_transaction = transaction;\n\n\treturn transaction;\n}",
          "includes": [
            "#include <linux/hrtimer.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/timer.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/jbd.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/timer.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n\nstatic transaction_t *\nget_transaction(journal_t *journal, transaction_t *transaction)\n{\n\ttransaction->t_journal = journal;\n\ttransaction->t_state = T_RUNNING;\n\ttransaction->t_start_time = ktime_get();\n\ttransaction->t_tid = journal->j_transaction_sequence++;\n\ttransaction->t_expires = jiffies + journal->j_commit_interval;\n\tspin_lock_init(&transaction->t_handle_lock);\n\n\t/* Set up the commit timer for the new transaction. */\n\tjournal->j_commit_timer.expires =\n\t\t\t\tround_jiffies_up(transaction->t_expires);\n\tadd_timer(&journal->j_commit_timer);\n\n\tJ_ASSERT(journal->j_running_transaction == NULL);\n\tjournal->j_running_transaction = transaction;\n\n\treturn transaction;\n}"
        }
      },
      {
        "call_info": {
          "callee": "wait_event",
          "args": [
            "journal->j_wait_transaction_locked",
            "journal->j_barrier_count == 0"
          ],
          "line": 130
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_journal_aborted",
          "args": [
            "journal"
          ],
          "line": 120
        },
        "resolved": true,
        "details": {
          "function_name": "__reiserfs_is_journal_aborted",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/reiserfs.h",
          "lines": "760-764",
          "snippet": "static inline int __reiserfs_is_journal_aborted(struct reiserfs_journal\n\t\t\t\t\t\t*journal)\n{\n\treturn test_bit(J_ABORTED, &journal->j_state);\n}",
          "includes": [
            "#include <linux/buffer_head.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/bitops.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/slab.h>",
            "#include <linux/reiserfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/buffer_head.h>\n#include <linux/proc_fs.h>\n#include <linux/bitops.h>\n#include <asm/unaligned.h>\n#include <linux/workqueue.h>\n#include <linux/bug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/slab.h>\n#include <linux/reiserfs_fs.h>\n\nstatic inline int __reiserfs_is_journal_aborted(struct reiserfs_journal\n\t\t\t\t\t\t*journal)\n{\n\treturn test_bit(J_ABORTED, &journal->j_state);\n}"
        }
      },
      {
        "call_info": {
          "callee": "jbd_debug",
          "args": [
            "3",
            "\"New handle %p going live.\\n\"",
            "handle"
          ],
          "line": 110
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(*new_transaction)",
            "GFP_NOFS|__GFP_NOFAIL"
          ],
          "line": 102
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_ERR \"JBD: %s wants too many credits (%d > %d)\\n\"",
            "current->comm",
            "nblocks",
            "journal->j_max_transaction_buffers"
          ],
          "line": 93
        },
        "resolved": true,
        "details": {
          "function_name": "compat_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/compat.c",
          "lines": "59-69",
          "snippet": "int compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/ioctls.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/aio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/mm.h>",
            "#include <linux/poll.h>",
            "#include <linux/signal.h>",
            "#include <linux/highmem.h>",
            "#include <linux/security.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/personality.h>",
            "#include <linux/highuid.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/dirent.h>",
            "#include <linux/ctype.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/nfs4_mount.h>",
            "#include <linux/ncp_mount.h>",
            "#include <linux/init.h>",
            "#include <linux/ioctl.h>",
            "#include <linux/vfs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/namei.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/errno.h>",
            "#include <linux/compat.h>",
            "#include <linux/linkage.h>",
            "#include <linux/kernel.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int compat_log = 1;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/ioctls.h>\n#include <asm/mmu_context.h>\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/fs_struct.h>\n#include <linux/mm.h>\n#include <linux/poll.h>\n#include <linux/signal.h>\n#include <linux/highmem.h>\n#include <linux/security.h>\n#include <linux/tsacct_kern.h>\n#include <linux/rwsem.h>\n#include <linux/personality.h>\n#include <linux/highuid.h>\n#include <linux/fsnotify.h>\n#include <linux/dirent.h>\n#include <linux/ctype.h>\n#include <linux/syscalls.h>\n#include <linux/nfs4_mount.h>\n#include <linux/ncp_mount.h>\n#include <linux/init.h>\n#include <linux/ioctl.h>\n#include <linux/vfs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/namei.h>\n#include <linux/fcntl.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <linux/compat.h>\n#include <linux/linkage.h>\n#include <linux/kernel.h>\n#include <linux/stddef.h>\n\nint compat_log = 1;\n\nint compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/timer.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n\nstatic int start_this_handle(journal_t *journal, handle_t *handle)\n{\n\ttransaction_t *transaction;\n\tint needed;\n\tint nblocks = handle->h_buffer_credits;\n\ttransaction_t *new_transaction = NULL;\n\tint ret = 0;\n\n\tif (nblocks > journal->j_max_transaction_buffers) {\n\t\tprintk(KERN_ERR \"JBD: %s wants too many credits (%d > %d)\\n\",\n\t\t       current->comm, nblocks,\n\t\t       journal->j_max_transaction_buffers);\n\t\tret = -ENOSPC;\n\t\tgoto out;\n\t}\n\nalloc_transaction:\n\tif (!journal->j_running_transaction) {\n\t\tnew_transaction = kzalloc(sizeof(*new_transaction),\n\t\t\t\t\t\tGFP_NOFS|__GFP_NOFAIL);\n\t\tif (!new_transaction) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tjbd_debug(3, \"New handle %p going live.\\n\", handle);\n\nrepeat:\n\n\t/*\n\t * We need to hold j_state_lock until t_updates has been incremented,\n\t * for proper journal barrier handling\n\t */\n\tspin_lock(&journal->j_state_lock);\nrepeat_locked:\n\tif (is_journal_aborted(journal) ||\n\t    (journal->j_errno != 0 && !(journal->j_flags & JFS_ACK_ERR))) {\n\t\tspin_unlock(&journal->j_state_lock);\n\t\tret = -EROFS;\n\t\tgoto out;\n\t}\n\n\t/* Wait on the journal's transaction barrier if necessary */\n\tif (journal->j_barrier_count) {\n\t\tspin_unlock(&journal->j_state_lock);\n\t\twait_event(journal->j_wait_transaction_locked,\n\t\t\t\tjournal->j_barrier_count == 0);\n\t\tgoto repeat;\n\t}\n\n\tif (!journal->j_running_transaction) {\n\t\tif (!new_transaction) {\n\t\t\tspin_unlock(&journal->j_state_lock);\n\t\t\tgoto alloc_transaction;\n\t\t}\n\t\tget_transaction(journal, new_transaction);\n\t\tnew_transaction = NULL;\n\t}\n\n\ttransaction = journal->j_running_transaction;\n\n\t/*\n\t * If the current transaction is locked down for commit, wait for the\n\t * lock to be released.\n\t */\n\tif (transaction->t_state == T_LOCKED) {\n\t\tDEFINE_WAIT(wait);\n\n\t\tprepare_to_wait(&journal->j_wait_transaction_locked,\n\t\t\t\t\t&wait, TASK_UNINTERRUPTIBLE);\n\t\tspin_unlock(&journal->j_state_lock);\n\t\tschedule();\n\t\tfinish_wait(&journal->j_wait_transaction_locked, &wait);\n\t\tgoto repeat;\n\t}\n\n\t/*\n\t * If there is not enough space left in the log to write all potential\n\t * buffers requested by this operation, we need to stall pending a log\n\t * checkpoint to free some more log space.\n\t */\n\tspin_lock(&transaction->t_handle_lock);\n\tneeded = transaction->t_outstanding_credits + nblocks;\n\n\tif (needed > journal->j_max_transaction_buffers) {\n\t\t/*\n\t\t * If the current transaction is already too large, then start\n\t\t * to commit it: we can then go back and attach this handle to\n\t\t * a new transaction.\n\t\t */\n\t\tDEFINE_WAIT(wait);\n\n\t\tjbd_debug(2, \"Handle %p starting new commit...\\n\", handle);\n\t\tspin_unlock(&transaction->t_handle_lock);\n\t\tprepare_to_wait(&journal->j_wait_transaction_locked, &wait,\n\t\t\t\tTASK_UNINTERRUPTIBLE);\n\t\t__log_start_commit(journal, transaction->t_tid);\n\t\tspin_unlock(&journal->j_state_lock);\n\t\tschedule();\n\t\tfinish_wait(&journal->j_wait_transaction_locked, &wait);\n\t\tgoto repeat;\n\t}\n\n\t/*\n\t * The commit code assumes that it can get enough log space\n\t * without forcing a checkpoint.  This is *critical* for\n\t * correctness: a checkpoint of a buffer which is also\n\t * associated with a committing transaction creates a deadlock,\n\t * so commit simply cannot force through checkpoints.\n\t *\n\t * We must therefore ensure the necessary space in the journal\n\t * *before* starting to dirty potentially checkpointed buffers\n\t * in the new transaction.\n\t *\n\t * The worst part is, any transaction currently committing can\n\t * reduce the free space arbitrarily.  Be careful to account for\n\t * those buffers when checkpointing.\n\t */\n\n\t/*\n\t * @@@ AKPM: This seems rather over-defensive.  We're giving commit\n\t * a _lot_ of headroom: 1/4 of the journal plus the size of\n\t * the committing transaction.  Really, we only need to give it\n\t * committing_transaction->t_outstanding_credits plus \"enough\" for\n\t * the log control blocks.\n\t * Also, this test is inconsistent with the matching one in\n\t * journal_extend().\n\t */\n\tif (__log_space_left(journal) < jbd_space_needed(journal)) {\n\t\tjbd_debug(2, \"Handle %p waiting for checkpoint...\\n\", handle);\n\t\tspin_unlock(&transaction->t_handle_lock);\n\t\t__log_wait_for_space(journal);\n\t\tgoto repeat_locked;\n\t}\n\n\t/* OK, account for the buffers that this operation expects to\n\t * use and add the handle to the running transaction. */\n\n\thandle->h_transaction = transaction;\n\ttransaction->t_outstanding_credits += nblocks;\n\ttransaction->t_updates++;\n\ttransaction->t_handle_count++;\n\tjbd_debug(4, \"Handle %p given %d credits (total %d, free %d)\\n\",\n\t\t  handle, nblocks, transaction->t_outstanding_credits,\n\t\t  __log_space_left(journal));\n\tspin_unlock(&transaction->t_handle_lock);\n\tspin_unlock(&journal->j_state_lock);\n\n\tlock_map_acquire(&handle->h_lockdep_map);\nout:\n\tif (unlikely(new_transaction))\t\t/* It's usually NULL */\n\t\tkfree(new_transaction);\n\treturn ret;\n}"
  },
  {
    "function_name": "get_transaction",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd/transaction.c",
    "lines": "48-67",
    "snippet": "static transaction_t *\nget_transaction(journal_t *journal, transaction_t *transaction)\n{\n\ttransaction->t_journal = journal;\n\ttransaction->t_state = T_RUNNING;\n\ttransaction->t_start_time = ktime_get();\n\ttransaction->t_tid = journal->j_transaction_sequence++;\n\ttransaction->t_expires = jiffies + journal->j_commit_interval;\n\tspin_lock_init(&transaction->t_handle_lock);\n\n\t/* Set up the commit timer for the new transaction. */\n\tjournal->j_commit_timer.expires =\n\t\t\t\tround_jiffies_up(transaction->t_expires);\n\tadd_timer(&journal->j_commit_timer);\n\n\tJ_ASSERT(journal->j_running_transaction == NULL);\n\tjournal->j_running_transaction = transaction;\n\n\treturn transaction;\n}",
    "includes": [
      "#include <linux/hrtimer.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/timer.h>",
      "#include <linux/slab.h>",
      "#include <linux/errno.h>",
      "#include <linux/jbd.h>",
      "#include <linux/fs.h>",
      "#include <linux/time.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "J_ASSERT",
          "args": [
            "journal->j_running_transaction == NULL"
          ],
          "line": 63
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "add_timer",
          "args": [
            "&journal->j_commit_timer"
          ],
          "line": 61
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "round_jiffies_up",
          "args": [
            "transaction->t_expires"
          ],
          "line": 60
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_init",
          "args": [
            "&transaction->t_handle_lock"
          ],
          "line": 56
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ktime_get",
          "args": [],
          "line": 53
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/timer.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n\nstatic transaction_t *\nget_transaction(journal_t *journal, transaction_t *transaction)\n{\n\ttransaction->t_journal = journal;\n\ttransaction->t_state = T_RUNNING;\n\ttransaction->t_start_time = ktime_get();\n\ttransaction->t_tid = journal->j_transaction_sequence++;\n\ttransaction->t_expires = jiffies + journal->j_commit_interval;\n\tspin_lock_init(&transaction->t_handle_lock);\n\n\t/* Set up the commit timer for the new transaction. */\n\tjournal->j_commit_timer.expires =\n\t\t\t\tround_jiffies_up(transaction->t_expires);\n\tadd_timer(&journal->j_commit_timer);\n\n\tJ_ASSERT(journal->j_running_transaction == NULL);\n\tjournal->j_running_transaction = transaction;\n\n\treturn transaction;\n}"
  }
]