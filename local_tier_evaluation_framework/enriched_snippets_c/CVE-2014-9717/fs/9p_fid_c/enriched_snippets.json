[
  {
    "function_name": "v9fs_writeback_fid",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/9p/fid.c",
    "lines": "284-306",
    "snippet": "struct p9_fid *v9fs_writeback_fid(struct dentry *dentry)\n{\n\tint err;\n\tstruct p9_fid *fid;\n\n\tfid = v9fs_fid_clone_with_uid(dentry, GLOBAL_ROOT_UID);\n\tif (IS_ERR(fid))\n\t\tgoto error_out;\n\t/*\n\t * writeback fid will only be used to write back the\n\t * dirty pages. We always request for the open fid in read-write\n\t * mode so that a partial page write which result in page\n\t * read can work.\n\t */\n\terr = p9_client_open(fid, O_RDWR);\n\tif (err < 0) {\n\t\tp9_client_clunk(fid);\n\t\tfid = ERR_PTR(err);\n\t\tgoto error_out;\n\t}\nerror_out:\n\treturn fid;\n}",
    "includes": [
      "#include \"fid.h\"",
      "#include \"v9fs_vfs.h\"",
      "#include \"v9fs.h\"",
      "#include <net/9p/client.h>",
      "#include <net/9p/9p.h>",
      "#include <linux/idr.h>",
      "#include <linux/sched.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/errno.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "err"
          ],
          "line": 301
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "p9_client_clunk",
          "args": [
            "fid"
          ],
          "line": 300
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "p9_client_open",
          "args": [
            "fid",
            "O_RDWR"
          ],
          "line": 298
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "fid"
          ],
          "line": 290
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "v9fs_fid_clone_with_uid",
          "args": [
            "dentry",
            "GLOBAL_ROOT_UID"
          ],
          "line": 289
        },
        "resolved": true,
        "details": {
          "function_name": "v9fs_fid_clone_with_uid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/9p/fid.c",
          "lines": "272-282",
          "snippet": "static struct p9_fid *v9fs_fid_clone_with_uid(struct dentry *dentry, kuid_t uid)\n{\n\tstruct p9_fid *fid, *ret;\n\n\tfid = v9fs_fid_lookup_with_uid(dentry, uid, 0);\n\tif (IS_ERR(fid))\n\t\treturn fid;\n\n\tret = p9_client_walk(fid, 0, NULL, 1);\n\treturn ret;\n}",
          "includes": [
            "#include \"fid.h\"",
            "#include \"v9fs_vfs.h\"",
            "#include \"v9fs.h\"",
            "#include <net/9p/client.h>",
            "#include <net/9p/9p.h>",
            "#include <linux/idr.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/errno.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fid.h\"\n#include \"v9fs_vfs.h\"\n#include \"v9fs.h\"\n#include <net/9p/client.h>\n#include <net/9p/9p.h>\n#include <linux/idr.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <linux/module.h>\n\nstatic struct p9_fid *v9fs_fid_clone_with_uid(struct dentry *dentry, kuid_t uid)\n{\n\tstruct p9_fid *fid, *ret;\n\n\tfid = v9fs_fid_lookup_with_uid(dentry, uid, 0);\n\tif (IS_ERR(fid))\n\t\treturn fid;\n\n\tret = p9_client_walk(fid, 0, NULL, 1);\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"fid.h\"\n#include \"v9fs_vfs.h\"\n#include \"v9fs.h\"\n#include <net/9p/client.h>\n#include <net/9p/9p.h>\n#include <linux/idr.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <linux/module.h>\n\nstruct p9_fid *v9fs_writeback_fid(struct dentry *dentry)\n{\n\tint err;\n\tstruct p9_fid *fid;\n\n\tfid = v9fs_fid_clone_with_uid(dentry, GLOBAL_ROOT_UID);\n\tif (IS_ERR(fid))\n\t\tgoto error_out;\n\t/*\n\t * writeback fid will only be used to write back the\n\t * dirty pages. We always request for the open fid in read-write\n\t * mode so that a partial page write which result in page\n\t * read can work.\n\t */\n\terr = p9_client_open(fid, O_RDWR);\n\tif (err < 0) {\n\t\tp9_client_clunk(fid);\n\t\tfid = ERR_PTR(err);\n\t\tgoto error_out;\n\t}\nerror_out:\n\treturn fid;\n}"
  },
  {
    "function_name": "v9fs_fid_clone_with_uid",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/9p/fid.c",
    "lines": "272-282",
    "snippet": "static struct p9_fid *v9fs_fid_clone_with_uid(struct dentry *dentry, kuid_t uid)\n{\n\tstruct p9_fid *fid, *ret;\n\n\tfid = v9fs_fid_lookup_with_uid(dentry, uid, 0);\n\tif (IS_ERR(fid))\n\t\treturn fid;\n\n\tret = p9_client_walk(fid, 0, NULL, 1);\n\treturn ret;\n}",
    "includes": [
      "#include \"fid.h\"",
      "#include \"v9fs_vfs.h\"",
      "#include \"v9fs.h\"",
      "#include <net/9p/client.h>",
      "#include <net/9p/9p.h>",
      "#include <linux/idr.h>",
      "#include <linux/sched.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/errno.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "p9_client_walk",
          "args": [
            "fid",
            "0",
            "NULL",
            "1"
          ],
          "line": 280
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "fid"
          ],
          "line": 277
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "v9fs_fid_lookup_with_uid",
          "args": [
            "dentry",
            "uid",
            "0"
          ],
          "line": 276
        },
        "resolved": true,
        "details": {
          "function_name": "v9fs_fid_lookup_with_uid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/9p/fid.c",
          "lines": "116-219",
          "snippet": "static struct p9_fid *v9fs_fid_lookup_with_uid(struct dentry *dentry,\n\t\t\t\t\t       kuid_t uid, int any)\n{\n\tstruct dentry *ds;\n\tchar **wnames, *uname;\n\tint i, n, l, clone, access;\n\tstruct v9fs_session_info *v9ses;\n\tstruct p9_fid *fid, *old_fid = NULL;\n\n\tv9ses = v9fs_dentry2v9ses(dentry);\n\taccess = v9ses->flags & V9FS_ACCESS_MASK;\n\tfid = v9fs_fid_find(dentry, uid, any);\n\tif (fid)\n\t\treturn fid;\n\t/*\n\t * we don't have a matching fid. To do a TWALK we need\n\t * parent fid. We need to prevent rename when we want to\n\t * look at the parent.\n\t */\n\tdown_read(&v9ses->rename_sem);\n\tds = dentry->d_parent;\n\tfid = v9fs_fid_find(ds, uid, any);\n\tif (fid) {\n\t\t/* Found the parent fid do a lookup with that */\n\t\tfid = p9_client_walk(fid, 1, (char **)&dentry->d_name.name, 1);\n\t\tgoto fid_out;\n\t}\n\tup_read(&v9ses->rename_sem);\n\n\t/* start from the root and try to do a lookup */\n\tfid = v9fs_fid_find(dentry->d_sb->s_root, uid, any);\n\tif (!fid) {\n\t\t/* the user is not attached to the fs yet */\n\t\tif (access == V9FS_ACCESS_SINGLE)\n\t\t\treturn ERR_PTR(-EPERM);\n\n\t\tif (v9fs_proto_dotu(v9ses) || v9fs_proto_dotl(v9ses))\n\t\t\t\tuname = NULL;\n\t\telse\n\t\t\tuname = v9ses->uname;\n\n\t\tfid = p9_client_attach(v9ses->clnt, NULL, uname, uid,\n\t\t\t\t       v9ses->aname);\n\t\tif (IS_ERR(fid))\n\t\t\treturn fid;\n\n\t\tv9fs_fid_add(dentry->d_sb->s_root, fid);\n\t}\n\t/* If we are root ourself just return that */\n\tif (dentry->d_sb->s_root == dentry)\n\t\treturn fid;\n\t/*\n\t * Do a multipath walk with attached root.\n\t * When walking parent we need to make sure we\n\t * don't have a parallel rename happening\n\t */\n\tdown_read(&v9ses->rename_sem);\n\tn  = build_path_from_dentry(v9ses, dentry, &wnames);\n\tif (n < 0) {\n\t\tfid = ERR_PTR(n);\n\t\tgoto err_out;\n\t}\n\tclone = 1;\n\ti = 0;\n\twhile (i < n) {\n\t\tl = min(n - i, P9_MAXWELEM);\n\t\t/*\n\t\t * We need to hold rename lock when doing a multipath\n\t\t * walk to ensure none of the patch component change\n\t\t */\n\t\tfid = p9_client_walk(fid, l, &wnames[i], clone);\n\t\tif (IS_ERR(fid)) {\n\t\t\tif (old_fid) {\n\t\t\t\t/*\n\t\t\t\t * If we fail, clunk fid which are mapping\n\t\t\t\t * to path component and not the last component\n\t\t\t\t * of the path.\n\t\t\t\t */\n\t\t\t\tp9_client_clunk(old_fid);\n\t\t\t}\n\t\t\tkfree(wnames);\n\t\t\tgoto err_out;\n\t\t}\n\t\told_fid = fid;\n\t\ti += l;\n\t\tclone = 0;\n\t}\n\tkfree(wnames);\nfid_out:\n\tif (!IS_ERR(fid)) {\n\t\tspin_lock(&dentry->d_lock);\n\t\tif (d_unhashed(dentry)) {\n\t\t\tspin_unlock(&dentry->d_lock);\n\t\t\tp9_client_clunk(fid);\n\t\t\tfid = ERR_PTR(-ENOENT);\n\t\t} else {\n\t\t\t__add_fid(dentry, fid);\n\t\t\tspin_unlock(&dentry->d_lock);\n\t\t}\n\t}\nerr_out:\n\tup_read(&v9ses->rename_sem);\n\treturn fid;\n}",
          "includes": [
            "#include \"fid.h\"",
            "#include \"v9fs_vfs.h\"",
            "#include \"v9fs.h\"",
            "#include <net/9p/client.h>",
            "#include <net/9p/9p.h>",
            "#include <linux/idr.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/errno.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fid.h\"\n#include \"v9fs_vfs.h\"\n#include \"v9fs.h\"\n#include <net/9p/client.h>\n#include <net/9p/9p.h>\n#include <linux/idr.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <linux/module.h>\n\nstatic struct p9_fid *v9fs_fid_lookup_with_uid(struct dentry *dentry,\n\t\t\t\t\t       kuid_t uid, int any)\n{\n\tstruct dentry *ds;\n\tchar **wnames, *uname;\n\tint i, n, l, clone, access;\n\tstruct v9fs_session_info *v9ses;\n\tstruct p9_fid *fid, *old_fid = NULL;\n\n\tv9ses = v9fs_dentry2v9ses(dentry);\n\taccess = v9ses->flags & V9FS_ACCESS_MASK;\n\tfid = v9fs_fid_find(dentry, uid, any);\n\tif (fid)\n\t\treturn fid;\n\t/*\n\t * we don't have a matching fid. To do a TWALK we need\n\t * parent fid. We need to prevent rename when we want to\n\t * look at the parent.\n\t */\n\tdown_read(&v9ses->rename_sem);\n\tds = dentry->d_parent;\n\tfid = v9fs_fid_find(ds, uid, any);\n\tif (fid) {\n\t\t/* Found the parent fid do a lookup with that */\n\t\tfid = p9_client_walk(fid, 1, (char **)&dentry->d_name.name, 1);\n\t\tgoto fid_out;\n\t}\n\tup_read(&v9ses->rename_sem);\n\n\t/* start from the root and try to do a lookup */\n\tfid = v9fs_fid_find(dentry->d_sb->s_root, uid, any);\n\tif (!fid) {\n\t\t/* the user is not attached to the fs yet */\n\t\tif (access == V9FS_ACCESS_SINGLE)\n\t\t\treturn ERR_PTR(-EPERM);\n\n\t\tif (v9fs_proto_dotu(v9ses) || v9fs_proto_dotl(v9ses))\n\t\t\t\tuname = NULL;\n\t\telse\n\t\t\tuname = v9ses->uname;\n\n\t\tfid = p9_client_attach(v9ses->clnt, NULL, uname, uid,\n\t\t\t\t       v9ses->aname);\n\t\tif (IS_ERR(fid))\n\t\t\treturn fid;\n\n\t\tv9fs_fid_add(dentry->d_sb->s_root, fid);\n\t}\n\t/* If we are root ourself just return that */\n\tif (dentry->d_sb->s_root == dentry)\n\t\treturn fid;\n\t/*\n\t * Do a multipath walk with attached root.\n\t * When walking parent we need to make sure we\n\t * don't have a parallel rename happening\n\t */\n\tdown_read(&v9ses->rename_sem);\n\tn  = build_path_from_dentry(v9ses, dentry, &wnames);\n\tif (n < 0) {\n\t\tfid = ERR_PTR(n);\n\t\tgoto err_out;\n\t}\n\tclone = 1;\n\ti = 0;\n\twhile (i < n) {\n\t\tl = min(n - i, P9_MAXWELEM);\n\t\t/*\n\t\t * We need to hold rename lock when doing a multipath\n\t\t * walk to ensure none of the patch component change\n\t\t */\n\t\tfid = p9_client_walk(fid, l, &wnames[i], clone);\n\t\tif (IS_ERR(fid)) {\n\t\t\tif (old_fid) {\n\t\t\t\t/*\n\t\t\t\t * If we fail, clunk fid which are mapping\n\t\t\t\t * to path component and not the last component\n\t\t\t\t * of the path.\n\t\t\t\t */\n\t\t\t\tp9_client_clunk(old_fid);\n\t\t\t}\n\t\t\tkfree(wnames);\n\t\t\tgoto err_out;\n\t\t}\n\t\told_fid = fid;\n\t\ti += l;\n\t\tclone = 0;\n\t}\n\tkfree(wnames);\nfid_out:\n\tif (!IS_ERR(fid)) {\n\t\tspin_lock(&dentry->d_lock);\n\t\tif (d_unhashed(dentry)) {\n\t\t\tspin_unlock(&dentry->d_lock);\n\t\t\tp9_client_clunk(fid);\n\t\t\tfid = ERR_PTR(-ENOENT);\n\t\t} else {\n\t\t\t__add_fid(dentry, fid);\n\t\t\tspin_unlock(&dentry->d_lock);\n\t\t}\n\t}\nerr_out:\n\tup_read(&v9ses->rename_sem);\n\treturn fid;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"fid.h\"\n#include \"v9fs_vfs.h\"\n#include \"v9fs.h\"\n#include <net/9p/client.h>\n#include <net/9p/9p.h>\n#include <linux/idr.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <linux/module.h>\n\nstatic struct p9_fid *v9fs_fid_clone_with_uid(struct dentry *dentry, kuid_t uid)\n{\n\tstruct p9_fid *fid, *ret;\n\n\tfid = v9fs_fid_lookup_with_uid(dentry, uid, 0);\n\tif (IS_ERR(fid))\n\t\treturn fid;\n\n\tret = p9_client_walk(fid, 0, NULL, 1);\n\treturn ret;\n}"
  },
  {
    "function_name": "v9fs_fid_clone",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/9p/fid.c",
    "lines": "260-270",
    "snippet": "struct p9_fid *v9fs_fid_clone(struct dentry *dentry)\n{\n\tstruct p9_fid *fid, *ret;\n\n\tfid = v9fs_fid_lookup(dentry);\n\tif (IS_ERR(fid))\n\t\treturn fid;\n\n\tret = p9_client_walk(fid, 0, NULL, 1);\n\treturn ret;\n}",
    "includes": [
      "#include \"fid.h\"",
      "#include \"v9fs_vfs.h\"",
      "#include \"v9fs.h\"",
      "#include <net/9p/client.h>",
      "#include <net/9p/9p.h>",
      "#include <linux/idr.h>",
      "#include <linux/sched.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/errno.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "p9_client_walk",
          "args": [
            "fid",
            "0",
            "NULL",
            "1"
          ],
          "line": 268
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "fid"
          ],
          "line": 265
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "v9fs_fid_lookup",
          "args": [
            "dentry"
          ],
          "line": 264
        },
        "resolved": true,
        "details": {
          "function_name": "v9fs_fid_lookup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/9p/fid.c",
          "lines": "231-258",
          "snippet": "struct p9_fid *v9fs_fid_lookup(struct dentry *dentry)\n{\n\tkuid_t uid;\n\tint  any, access;\n\tstruct v9fs_session_info *v9ses;\n\n\tv9ses = v9fs_dentry2v9ses(dentry);\n\taccess = v9ses->flags & V9FS_ACCESS_MASK;\n\tswitch (access) {\n\tcase V9FS_ACCESS_SINGLE:\n\tcase V9FS_ACCESS_USER:\n\tcase V9FS_ACCESS_CLIENT:\n\t\tuid = current_fsuid();\n\t\tany = 0;\n\t\tbreak;\n\n\tcase V9FS_ACCESS_ANY:\n\t\tuid = v9ses->uid;\n\t\tany = 1;\n\t\tbreak;\n\n\tdefault:\n\t\tuid = INVALID_UID;\n\t\tany = 0;\n\t\tbreak;\n\t}\n\treturn v9fs_fid_lookup_with_uid(dentry, uid, any);\n}",
          "includes": [
            "#include \"fid.h\"",
            "#include \"v9fs_vfs.h\"",
            "#include \"v9fs.h\"",
            "#include <net/9p/client.h>",
            "#include <net/9p/9p.h>",
            "#include <linux/idr.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/errno.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fid.h\"\n#include \"v9fs_vfs.h\"\n#include \"v9fs.h\"\n#include <net/9p/client.h>\n#include <net/9p/9p.h>\n#include <linux/idr.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <linux/module.h>\n\nstruct p9_fid *v9fs_fid_lookup(struct dentry *dentry)\n{\n\tkuid_t uid;\n\tint  any, access;\n\tstruct v9fs_session_info *v9ses;\n\n\tv9ses = v9fs_dentry2v9ses(dentry);\n\taccess = v9ses->flags & V9FS_ACCESS_MASK;\n\tswitch (access) {\n\tcase V9FS_ACCESS_SINGLE:\n\tcase V9FS_ACCESS_USER:\n\tcase V9FS_ACCESS_CLIENT:\n\t\tuid = current_fsuid();\n\t\tany = 0;\n\t\tbreak;\n\n\tcase V9FS_ACCESS_ANY:\n\t\tuid = v9ses->uid;\n\t\tany = 1;\n\t\tbreak;\n\n\tdefault:\n\t\tuid = INVALID_UID;\n\t\tany = 0;\n\t\tbreak;\n\t}\n\treturn v9fs_fid_lookup_with_uid(dentry, uid, any);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"fid.h\"\n#include \"v9fs_vfs.h\"\n#include \"v9fs.h\"\n#include <net/9p/client.h>\n#include <net/9p/9p.h>\n#include <linux/idr.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <linux/module.h>\n\nstruct p9_fid *v9fs_fid_clone(struct dentry *dentry)\n{\n\tstruct p9_fid *fid, *ret;\n\n\tfid = v9fs_fid_lookup(dentry);\n\tif (IS_ERR(fid))\n\t\treturn fid;\n\n\tret = p9_client_walk(fid, 0, NULL, 1);\n\treturn ret;\n}"
  },
  {
    "function_name": "v9fs_fid_lookup",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/9p/fid.c",
    "lines": "231-258",
    "snippet": "struct p9_fid *v9fs_fid_lookup(struct dentry *dentry)\n{\n\tkuid_t uid;\n\tint  any, access;\n\tstruct v9fs_session_info *v9ses;\n\n\tv9ses = v9fs_dentry2v9ses(dentry);\n\taccess = v9ses->flags & V9FS_ACCESS_MASK;\n\tswitch (access) {\n\tcase V9FS_ACCESS_SINGLE:\n\tcase V9FS_ACCESS_USER:\n\tcase V9FS_ACCESS_CLIENT:\n\t\tuid = current_fsuid();\n\t\tany = 0;\n\t\tbreak;\n\n\tcase V9FS_ACCESS_ANY:\n\t\tuid = v9ses->uid;\n\t\tany = 1;\n\t\tbreak;\n\n\tdefault:\n\t\tuid = INVALID_UID;\n\t\tany = 0;\n\t\tbreak;\n\t}\n\treturn v9fs_fid_lookup_with_uid(dentry, uid, any);\n}",
    "includes": [
      "#include \"fid.h\"",
      "#include \"v9fs_vfs.h\"",
      "#include \"v9fs.h\"",
      "#include <net/9p/client.h>",
      "#include <net/9p/9p.h>",
      "#include <linux/idr.h>",
      "#include <linux/sched.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/errno.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "v9fs_fid_lookup_with_uid",
          "args": [
            "dentry",
            "uid",
            "any"
          ],
          "line": 257
        },
        "resolved": true,
        "details": {
          "function_name": "v9fs_fid_lookup_with_uid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/9p/fid.c",
          "lines": "116-219",
          "snippet": "static struct p9_fid *v9fs_fid_lookup_with_uid(struct dentry *dentry,\n\t\t\t\t\t       kuid_t uid, int any)\n{\n\tstruct dentry *ds;\n\tchar **wnames, *uname;\n\tint i, n, l, clone, access;\n\tstruct v9fs_session_info *v9ses;\n\tstruct p9_fid *fid, *old_fid = NULL;\n\n\tv9ses = v9fs_dentry2v9ses(dentry);\n\taccess = v9ses->flags & V9FS_ACCESS_MASK;\n\tfid = v9fs_fid_find(dentry, uid, any);\n\tif (fid)\n\t\treturn fid;\n\t/*\n\t * we don't have a matching fid. To do a TWALK we need\n\t * parent fid. We need to prevent rename when we want to\n\t * look at the parent.\n\t */\n\tdown_read(&v9ses->rename_sem);\n\tds = dentry->d_parent;\n\tfid = v9fs_fid_find(ds, uid, any);\n\tif (fid) {\n\t\t/* Found the parent fid do a lookup with that */\n\t\tfid = p9_client_walk(fid, 1, (char **)&dentry->d_name.name, 1);\n\t\tgoto fid_out;\n\t}\n\tup_read(&v9ses->rename_sem);\n\n\t/* start from the root and try to do a lookup */\n\tfid = v9fs_fid_find(dentry->d_sb->s_root, uid, any);\n\tif (!fid) {\n\t\t/* the user is not attached to the fs yet */\n\t\tif (access == V9FS_ACCESS_SINGLE)\n\t\t\treturn ERR_PTR(-EPERM);\n\n\t\tif (v9fs_proto_dotu(v9ses) || v9fs_proto_dotl(v9ses))\n\t\t\t\tuname = NULL;\n\t\telse\n\t\t\tuname = v9ses->uname;\n\n\t\tfid = p9_client_attach(v9ses->clnt, NULL, uname, uid,\n\t\t\t\t       v9ses->aname);\n\t\tif (IS_ERR(fid))\n\t\t\treturn fid;\n\n\t\tv9fs_fid_add(dentry->d_sb->s_root, fid);\n\t}\n\t/* If we are root ourself just return that */\n\tif (dentry->d_sb->s_root == dentry)\n\t\treturn fid;\n\t/*\n\t * Do a multipath walk with attached root.\n\t * When walking parent we need to make sure we\n\t * don't have a parallel rename happening\n\t */\n\tdown_read(&v9ses->rename_sem);\n\tn  = build_path_from_dentry(v9ses, dentry, &wnames);\n\tif (n < 0) {\n\t\tfid = ERR_PTR(n);\n\t\tgoto err_out;\n\t}\n\tclone = 1;\n\ti = 0;\n\twhile (i < n) {\n\t\tl = min(n - i, P9_MAXWELEM);\n\t\t/*\n\t\t * We need to hold rename lock when doing a multipath\n\t\t * walk to ensure none of the patch component change\n\t\t */\n\t\tfid = p9_client_walk(fid, l, &wnames[i], clone);\n\t\tif (IS_ERR(fid)) {\n\t\t\tif (old_fid) {\n\t\t\t\t/*\n\t\t\t\t * If we fail, clunk fid which are mapping\n\t\t\t\t * to path component and not the last component\n\t\t\t\t * of the path.\n\t\t\t\t */\n\t\t\t\tp9_client_clunk(old_fid);\n\t\t\t}\n\t\t\tkfree(wnames);\n\t\t\tgoto err_out;\n\t\t}\n\t\told_fid = fid;\n\t\ti += l;\n\t\tclone = 0;\n\t}\n\tkfree(wnames);\nfid_out:\n\tif (!IS_ERR(fid)) {\n\t\tspin_lock(&dentry->d_lock);\n\t\tif (d_unhashed(dentry)) {\n\t\t\tspin_unlock(&dentry->d_lock);\n\t\t\tp9_client_clunk(fid);\n\t\t\tfid = ERR_PTR(-ENOENT);\n\t\t} else {\n\t\t\t__add_fid(dentry, fid);\n\t\t\tspin_unlock(&dentry->d_lock);\n\t\t}\n\t}\nerr_out:\n\tup_read(&v9ses->rename_sem);\n\treturn fid;\n}",
          "includes": [
            "#include \"fid.h\"",
            "#include \"v9fs_vfs.h\"",
            "#include \"v9fs.h\"",
            "#include <net/9p/client.h>",
            "#include <net/9p/9p.h>",
            "#include <linux/idr.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/errno.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fid.h\"\n#include \"v9fs_vfs.h\"\n#include \"v9fs.h\"\n#include <net/9p/client.h>\n#include <net/9p/9p.h>\n#include <linux/idr.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <linux/module.h>\n\nstatic struct p9_fid *v9fs_fid_lookup_with_uid(struct dentry *dentry,\n\t\t\t\t\t       kuid_t uid, int any)\n{\n\tstruct dentry *ds;\n\tchar **wnames, *uname;\n\tint i, n, l, clone, access;\n\tstruct v9fs_session_info *v9ses;\n\tstruct p9_fid *fid, *old_fid = NULL;\n\n\tv9ses = v9fs_dentry2v9ses(dentry);\n\taccess = v9ses->flags & V9FS_ACCESS_MASK;\n\tfid = v9fs_fid_find(dentry, uid, any);\n\tif (fid)\n\t\treturn fid;\n\t/*\n\t * we don't have a matching fid. To do a TWALK we need\n\t * parent fid. We need to prevent rename when we want to\n\t * look at the parent.\n\t */\n\tdown_read(&v9ses->rename_sem);\n\tds = dentry->d_parent;\n\tfid = v9fs_fid_find(ds, uid, any);\n\tif (fid) {\n\t\t/* Found the parent fid do a lookup with that */\n\t\tfid = p9_client_walk(fid, 1, (char **)&dentry->d_name.name, 1);\n\t\tgoto fid_out;\n\t}\n\tup_read(&v9ses->rename_sem);\n\n\t/* start from the root and try to do a lookup */\n\tfid = v9fs_fid_find(dentry->d_sb->s_root, uid, any);\n\tif (!fid) {\n\t\t/* the user is not attached to the fs yet */\n\t\tif (access == V9FS_ACCESS_SINGLE)\n\t\t\treturn ERR_PTR(-EPERM);\n\n\t\tif (v9fs_proto_dotu(v9ses) || v9fs_proto_dotl(v9ses))\n\t\t\t\tuname = NULL;\n\t\telse\n\t\t\tuname = v9ses->uname;\n\n\t\tfid = p9_client_attach(v9ses->clnt, NULL, uname, uid,\n\t\t\t\t       v9ses->aname);\n\t\tif (IS_ERR(fid))\n\t\t\treturn fid;\n\n\t\tv9fs_fid_add(dentry->d_sb->s_root, fid);\n\t}\n\t/* If we are root ourself just return that */\n\tif (dentry->d_sb->s_root == dentry)\n\t\treturn fid;\n\t/*\n\t * Do a multipath walk with attached root.\n\t * When walking parent we need to make sure we\n\t * don't have a parallel rename happening\n\t */\n\tdown_read(&v9ses->rename_sem);\n\tn  = build_path_from_dentry(v9ses, dentry, &wnames);\n\tif (n < 0) {\n\t\tfid = ERR_PTR(n);\n\t\tgoto err_out;\n\t}\n\tclone = 1;\n\ti = 0;\n\twhile (i < n) {\n\t\tl = min(n - i, P9_MAXWELEM);\n\t\t/*\n\t\t * We need to hold rename lock when doing a multipath\n\t\t * walk to ensure none of the patch component change\n\t\t */\n\t\tfid = p9_client_walk(fid, l, &wnames[i], clone);\n\t\tif (IS_ERR(fid)) {\n\t\t\tif (old_fid) {\n\t\t\t\t/*\n\t\t\t\t * If we fail, clunk fid which are mapping\n\t\t\t\t * to path component and not the last component\n\t\t\t\t * of the path.\n\t\t\t\t */\n\t\t\t\tp9_client_clunk(old_fid);\n\t\t\t}\n\t\t\tkfree(wnames);\n\t\t\tgoto err_out;\n\t\t}\n\t\told_fid = fid;\n\t\ti += l;\n\t\tclone = 0;\n\t}\n\tkfree(wnames);\nfid_out:\n\tif (!IS_ERR(fid)) {\n\t\tspin_lock(&dentry->d_lock);\n\t\tif (d_unhashed(dentry)) {\n\t\t\tspin_unlock(&dentry->d_lock);\n\t\t\tp9_client_clunk(fid);\n\t\t\tfid = ERR_PTR(-ENOENT);\n\t\t} else {\n\t\t\t__add_fid(dentry, fid);\n\t\t\tspin_unlock(&dentry->d_lock);\n\t\t}\n\t}\nerr_out:\n\tup_read(&v9ses->rename_sem);\n\treturn fid;\n}"
        }
      },
      {
        "call_info": {
          "callee": "current_fsuid",
          "args": [],
          "line": 243
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "v9fs_dentry2v9ses",
          "args": [
            "dentry"
          ],
          "line": 237
        },
        "resolved": true,
        "details": {
          "function_name": "v9fs_dentry2v9ses",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/9p/v9fs.h",
          "lines": "177-180",
          "snippet": "static inline struct v9fs_session_info *v9fs_dentry2v9ses(struct dentry *dentry)\n{\n\treturn dentry->d_sb->s_fs_info;\n}",
          "includes": [
            "#include <linux/backing-dev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/backing-dev.h>\n\nstatic inline struct v9fs_session_info *v9fs_dentry2v9ses(struct dentry *dentry)\n{\n\treturn dentry->d_sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"fid.h\"\n#include \"v9fs_vfs.h\"\n#include \"v9fs.h\"\n#include <net/9p/client.h>\n#include <net/9p/9p.h>\n#include <linux/idr.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <linux/module.h>\n\nstruct p9_fid *v9fs_fid_lookup(struct dentry *dentry)\n{\n\tkuid_t uid;\n\tint  any, access;\n\tstruct v9fs_session_info *v9ses;\n\n\tv9ses = v9fs_dentry2v9ses(dentry);\n\taccess = v9ses->flags & V9FS_ACCESS_MASK;\n\tswitch (access) {\n\tcase V9FS_ACCESS_SINGLE:\n\tcase V9FS_ACCESS_USER:\n\tcase V9FS_ACCESS_CLIENT:\n\t\tuid = current_fsuid();\n\t\tany = 0;\n\t\tbreak;\n\n\tcase V9FS_ACCESS_ANY:\n\t\tuid = v9ses->uid;\n\t\tany = 1;\n\t\tbreak;\n\n\tdefault:\n\t\tuid = INVALID_UID;\n\t\tany = 0;\n\t\tbreak;\n\t}\n\treturn v9fs_fid_lookup_with_uid(dentry, uid, any);\n}"
  },
  {
    "function_name": "v9fs_fid_lookup_with_uid",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/9p/fid.c",
    "lines": "116-219",
    "snippet": "static struct p9_fid *v9fs_fid_lookup_with_uid(struct dentry *dentry,\n\t\t\t\t\t       kuid_t uid, int any)\n{\n\tstruct dentry *ds;\n\tchar **wnames, *uname;\n\tint i, n, l, clone, access;\n\tstruct v9fs_session_info *v9ses;\n\tstruct p9_fid *fid, *old_fid = NULL;\n\n\tv9ses = v9fs_dentry2v9ses(dentry);\n\taccess = v9ses->flags & V9FS_ACCESS_MASK;\n\tfid = v9fs_fid_find(dentry, uid, any);\n\tif (fid)\n\t\treturn fid;\n\t/*\n\t * we don't have a matching fid. To do a TWALK we need\n\t * parent fid. We need to prevent rename when we want to\n\t * look at the parent.\n\t */\n\tdown_read(&v9ses->rename_sem);\n\tds = dentry->d_parent;\n\tfid = v9fs_fid_find(ds, uid, any);\n\tif (fid) {\n\t\t/* Found the parent fid do a lookup with that */\n\t\tfid = p9_client_walk(fid, 1, (char **)&dentry->d_name.name, 1);\n\t\tgoto fid_out;\n\t}\n\tup_read(&v9ses->rename_sem);\n\n\t/* start from the root and try to do a lookup */\n\tfid = v9fs_fid_find(dentry->d_sb->s_root, uid, any);\n\tif (!fid) {\n\t\t/* the user is not attached to the fs yet */\n\t\tif (access == V9FS_ACCESS_SINGLE)\n\t\t\treturn ERR_PTR(-EPERM);\n\n\t\tif (v9fs_proto_dotu(v9ses) || v9fs_proto_dotl(v9ses))\n\t\t\t\tuname = NULL;\n\t\telse\n\t\t\tuname = v9ses->uname;\n\n\t\tfid = p9_client_attach(v9ses->clnt, NULL, uname, uid,\n\t\t\t\t       v9ses->aname);\n\t\tif (IS_ERR(fid))\n\t\t\treturn fid;\n\n\t\tv9fs_fid_add(dentry->d_sb->s_root, fid);\n\t}\n\t/* If we are root ourself just return that */\n\tif (dentry->d_sb->s_root == dentry)\n\t\treturn fid;\n\t/*\n\t * Do a multipath walk with attached root.\n\t * When walking parent we need to make sure we\n\t * don't have a parallel rename happening\n\t */\n\tdown_read(&v9ses->rename_sem);\n\tn  = build_path_from_dentry(v9ses, dentry, &wnames);\n\tif (n < 0) {\n\t\tfid = ERR_PTR(n);\n\t\tgoto err_out;\n\t}\n\tclone = 1;\n\ti = 0;\n\twhile (i < n) {\n\t\tl = min(n - i, P9_MAXWELEM);\n\t\t/*\n\t\t * We need to hold rename lock when doing a multipath\n\t\t * walk to ensure none of the patch component change\n\t\t */\n\t\tfid = p9_client_walk(fid, l, &wnames[i], clone);\n\t\tif (IS_ERR(fid)) {\n\t\t\tif (old_fid) {\n\t\t\t\t/*\n\t\t\t\t * If we fail, clunk fid which are mapping\n\t\t\t\t * to path component and not the last component\n\t\t\t\t * of the path.\n\t\t\t\t */\n\t\t\t\tp9_client_clunk(old_fid);\n\t\t\t}\n\t\t\tkfree(wnames);\n\t\t\tgoto err_out;\n\t\t}\n\t\told_fid = fid;\n\t\ti += l;\n\t\tclone = 0;\n\t}\n\tkfree(wnames);\nfid_out:\n\tif (!IS_ERR(fid)) {\n\t\tspin_lock(&dentry->d_lock);\n\t\tif (d_unhashed(dentry)) {\n\t\t\tspin_unlock(&dentry->d_lock);\n\t\t\tp9_client_clunk(fid);\n\t\t\tfid = ERR_PTR(-ENOENT);\n\t\t} else {\n\t\t\t__add_fid(dentry, fid);\n\t\t\tspin_unlock(&dentry->d_lock);\n\t\t}\n\t}\nerr_out:\n\tup_read(&v9ses->rename_sem);\n\treturn fid;\n}",
    "includes": [
      "#include \"fid.h\"",
      "#include \"v9fs_vfs.h\"",
      "#include \"v9fs.h\"",
      "#include <net/9p/client.h>",
      "#include <net/9p/9p.h>",
      "#include <linux/idr.h>",
      "#include <linux/sched.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/errno.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "up_read",
          "args": [
            "&v9ses->rename_sem"
          ],
          "line": 217
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&dentry->d_lock"
          ],
          "line": 213
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "__add_fid",
          "args": [
            "dentry",
            "fid"
          ],
          "line": 212
        },
        "resolved": true,
        "details": {
          "function_name": "__add_fid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/9p/fid.c",
          "lines": "44-47",
          "snippet": "static inline void __add_fid(struct dentry *dentry, struct p9_fid *fid)\n{\n\thlist_add_head(&fid->dlist, (struct hlist_head *)&dentry->d_fsdata);\n}",
          "includes": [
            "#include \"fid.h\"",
            "#include \"v9fs_vfs.h\"",
            "#include \"v9fs.h\"",
            "#include <net/9p/client.h>",
            "#include <net/9p/9p.h>",
            "#include <linux/idr.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/errno.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fid.h\"\n#include \"v9fs_vfs.h\"\n#include \"v9fs.h\"\n#include <net/9p/client.h>\n#include <net/9p/9p.h>\n#include <linux/idr.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <linux/module.h>\n\nstatic inline void __add_fid(struct dentry *dentry, struct p9_fid *fid)\n{\n\thlist_add_head(&fid->dlist, (struct hlist_head *)&dentry->d_fsdata);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ENOENT"
          ],
          "line": 210
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "p9_client_clunk",
          "args": [
            "fid"
          ],
          "line": 209
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "d_unhashed",
          "args": [
            "dentry"
          ],
          "line": 207
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&dentry->d_lock"
          ],
          "line": 206
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "fid"
          ],
          "line": 205
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "wnames"
          ],
          "line": 203
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "wnames"
          ],
          "line": 196
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "p9_client_clunk",
          "args": [
            "old_fid"
          ],
          "line": 194
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "fid"
          ],
          "line": 187
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "p9_client_walk",
          "args": [
            "fid",
            "l",
            "&wnames[i]",
            "clone"
          ],
          "line": 186
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "min",
          "args": [
            "n - i",
            "P9_MAXWELEM"
          ],
          "line": 181
        },
        "resolved": true,
        "details": {
          "function_name": "get_dominating_id",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/pnode.c",
          "lines": "55-66",
          "snippet": "int get_dominating_id(struct mount *mnt, const struct path *root)\n{\n\tstruct mount *m;\n\n\tfor (m = mnt->mnt_master; m != NULL; m = m->mnt_master) {\n\t\tstruct mount *d = get_peer_under_root(m, mnt->mnt_ns, root);\n\t\tif (d)\n\t\t\treturn d->mnt_group_id;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"pnode.h\"",
            "#include \"internal.h\"",
            "#include <linux/nsproxy.h>",
            "#include <linux/fs.h>",
            "#include <linux/mount.h>",
            "#include <linux/mnt_namespace.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnode.h\"\n#include \"internal.h\"\n#include <linux/nsproxy.h>\n#include <linux/fs.h>\n#include <linux/mount.h>\n#include <linux/mnt_namespace.h>\n\nint get_dominating_id(struct mount *mnt, const struct path *root)\n{\n\tstruct mount *m;\n\n\tfor (m = mnt->mnt_master; m != NULL; m = m->mnt_master) {\n\t\tstruct mount *d = get_peer_under_root(m, mnt->mnt_ns, root);\n\t\tif (d)\n\t\t\treturn d->mnt_group_id;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "n"
          ],
          "line": 175
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "build_path_from_dentry",
          "args": [
            "v9ses",
            "dentry",
            "&wnames"
          ],
          "line": 173
        },
        "resolved": true,
        "details": {
          "function_name": "build_path_from_dentry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/9p/fid.c",
          "lines": "93-114",
          "snippet": "static int build_path_from_dentry(struct v9fs_session_info *v9ses,\n\t\t\t\t  struct dentry *dentry, char ***names)\n{\n\tint n = 0, i;\n\tchar **wnames;\n\tstruct dentry *ds;\n\n\tfor (ds = dentry; !IS_ROOT(ds); ds = ds->d_parent)\n\t\tn++;\n\n\twnames = kmalloc(sizeof(char *) * n, GFP_KERNEL);\n\tif (!wnames)\n\t\tgoto err_out;\n\n\tfor (ds = dentry, i = (n-1); i >= 0; i--, ds = ds->d_parent)\n\t\twnames[i] = (char  *)ds->d_name.name;\n\n\t*names = wnames;\n\treturn n;\nerr_out:\n\treturn -ENOMEM;\n}",
          "includes": [
            "#include \"fid.h\"",
            "#include \"v9fs_vfs.h\"",
            "#include \"v9fs.h\"",
            "#include <net/9p/client.h>",
            "#include <net/9p/9p.h>",
            "#include <linux/idr.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/errno.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fid.h\"\n#include \"v9fs_vfs.h\"\n#include \"v9fs.h\"\n#include <net/9p/client.h>\n#include <net/9p/9p.h>\n#include <linux/idr.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <linux/module.h>\n\nstatic int build_path_from_dentry(struct v9fs_session_info *v9ses,\n\t\t\t\t  struct dentry *dentry, char ***names)\n{\n\tint n = 0, i;\n\tchar **wnames;\n\tstruct dentry *ds;\n\n\tfor (ds = dentry; !IS_ROOT(ds); ds = ds->d_parent)\n\t\tn++;\n\n\twnames = kmalloc(sizeof(char *) * n, GFP_KERNEL);\n\tif (!wnames)\n\t\tgoto err_out;\n\n\tfor (ds = dentry, i = (n-1); i >= 0; i--, ds = ds->d_parent)\n\t\twnames[i] = (char  *)ds->d_name.name;\n\n\t*names = wnames;\n\treturn n;\nerr_out:\n\treturn -ENOMEM;\n}"
        }
      },
      {
        "call_info": {
          "callee": "down_read",
          "args": [
            "&v9ses->rename_sem"
          ],
          "line": 172
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "v9fs_fid_add",
          "args": [
            "dentry->d_sb->s_root",
            "fid"
          ],
          "line": 162
        },
        "resolved": true,
        "details": {
          "function_name": "v9fs_fid_add",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/9p/fid.c",
          "lines": "49-54",
          "snippet": "void v9fs_fid_add(struct dentry *dentry, struct p9_fid *fid)\n{\n\tspin_lock(&dentry->d_lock);\n\t__add_fid(dentry, fid);\n\tspin_unlock(&dentry->d_lock);\n}",
          "includes": [
            "#include \"fid.h\"",
            "#include \"v9fs_vfs.h\"",
            "#include \"v9fs.h\"",
            "#include <net/9p/client.h>",
            "#include <net/9p/9p.h>",
            "#include <linux/idr.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/errno.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fid.h\"\n#include \"v9fs_vfs.h\"\n#include \"v9fs.h\"\n#include <net/9p/client.h>\n#include <net/9p/9p.h>\n#include <linux/idr.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <linux/module.h>\n\nvoid v9fs_fid_add(struct dentry *dentry, struct p9_fid *fid)\n{\n\tspin_lock(&dentry->d_lock);\n\t__add_fid(dentry, fid);\n\tspin_unlock(&dentry->d_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "fid"
          ],
          "line": 159
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "p9_client_attach",
          "args": [
            "v9ses->clnt",
            "NULL",
            "uname",
            "uid",
            "v9ses->aname"
          ],
          "line": 157
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "v9fs_proto_dotl",
          "args": [
            "v9ses"
          ],
          "line": 152
        },
        "resolved": true,
        "details": {
          "function_name": "v9fs_proto_dotl",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/9p/v9fs.h",
          "lines": "187-190",
          "snippet": "static inline int v9fs_proto_dotl(struct v9fs_session_info *v9ses)\n{\n\treturn v9ses->flags & V9FS_PROTO_2000L;\n}",
          "includes": [
            "#include <linux/backing-dev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/backing-dev.h>\n\nstatic inline int v9fs_proto_dotl(struct v9fs_session_info *v9ses)\n{\n\treturn v9ses->flags & V9FS_PROTO_2000L;\n}"
        }
      },
      {
        "call_info": {
          "callee": "v9fs_proto_dotu",
          "args": [
            "v9ses"
          ],
          "line": 152
        },
        "resolved": true,
        "details": {
          "function_name": "v9fs_proto_dotu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/9p/v9fs.h",
          "lines": "182-185",
          "snippet": "static inline int v9fs_proto_dotu(struct v9fs_session_info *v9ses)\n{\n\treturn v9ses->flags & V9FS_PROTO_2000U;\n}",
          "includes": [
            "#include <linux/backing-dev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/backing-dev.h>\n\nstatic inline int v9fs_proto_dotu(struct v9fs_session_info *v9ses)\n{\n\treturn v9ses->flags & V9FS_PROTO_2000U;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-EPERM"
          ],
          "line": 150
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "v9fs_fid_find",
          "args": [
            "dentry->d_sb->s_root",
            "uid",
            "any"
          ],
          "line": 146
        },
        "resolved": true,
        "details": {
          "function_name": "v9fs_fid_find",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/9p/fid.c",
          "lines": "64-86",
          "snippet": "static struct p9_fid *v9fs_fid_find(struct dentry *dentry, kuid_t uid, int any)\n{\n\tstruct p9_fid *fid, *ret;\n\n\tp9_debug(P9_DEBUG_VFS, \" dentry: %pd (%p) uid %d any %d\\n\",\n\t\t dentry, dentry, from_kuid(&init_user_ns, uid),\n\t\t any);\n\tret = NULL;\n\t/* we'll recheck under lock if there's anything to look in */\n\tif (dentry->d_fsdata) {\n\t\tstruct hlist_head *h = (struct hlist_head *)&dentry->d_fsdata;\n\t\tspin_lock(&dentry->d_lock);\n\t\thlist_for_each_entry(fid, h, dlist) {\n\t\t\tif (any || uid_eq(fid->uid, uid)) {\n\t\t\t\tret = fid;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tspin_unlock(&dentry->d_lock);\n\t}\n\n\treturn ret;\n}",
          "includes": [
            "#include \"fid.h\"",
            "#include \"v9fs_vfs.h\"",
            "#include \"v9fs.h\"",
            "#include <net/9p/client.h>",
            "#include <net/9p/9p.h>",
            "#include <linux/idr.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/errno.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fid.h\"\n#include \"v9fs_vfs.h\"\n#include \"v9fs.h\"\n#include <net/9p/client.h>\n#include <net/9p/9p.h>\n#include <linux/idr.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <linux/module.h>\n\nstatic struct p9_fid *v9fs_fid_find(struct dentry *dentry, kuid_t uid, int any)\n{\n\tstruct p9_fid *fid, *ret;\n\n\tp9_debug(P9_DEBUG_VFS, \" dentry: %pd (%p) uid %d any %d\\n\",\n\t\t dentry, dentry, from_kuid(&init_user_ns, uid),\n\t\t any);\n\tret = NULL;\n\t/* we'll recheck under lock if there's anything to look in */\n\tif (dentry->d_fsdata) {\n\t\tstruct hlist_head *h = (struct hlist_head *)&dentry->d_fsdata;\n\t\tspin_lock(&dentry->d_lock);\n\t\thlist_for_each_entry(fid, h, dlist) {\n\t\t\tif (any || uid_eq(fid->uid, uid)) {\n\t\t\t\tret = fid;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tspin_unlock(&dentry->d_lock);\n\t}\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "up_read",
          "args": [
            "&v9ses->rename_sem"
          ],
          "line": 143
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "p9_client_walk",
          "args": [
            "fid",
            "1",
            "(char **)&dentry->d_name.name",
            "1"
          ],
          "line": 140
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "down_read",
          "args": [
            "&v9ses->rename_sem"
          ],
          "line": 135
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "v9fs_dentry2v9ses",
          "args": [
            "dentry"
          ],
          "line": 125
        },
        "resolved": true,
        "details": {
          "function_name": "v9fs_dentry2v9ses",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/9p/v9fs.h",
          "lines": "177-180",
          "snippet": "static inline struct v9fs_session_info *v9fs_dentry2v9ses(struct dentry *dentry)\n{\n\treturn dentry->d_sb->s_fs_info;\n}",
          "includes": [
            "#include <linux/backing-dev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/backing-dev.h>\n\nstatic inline struct v9fs_session_info *v9fs_dentry2v9ses(struct dentry *dentry)\n{\n\treturn dentry->d_sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"fid.h\"\n#include \"v9fs_vfs.h\"\n#include \"v9fs.h\"\n#include <net/9p/client.h>\n#include <net/9p/9p.h>\n#include <linux/idr.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <linux/module.h>\n\nstatic struct p9_fid *v9fs_fid_lookup_with_uid(struct dentry *dentry,\n\t\t\t\t\t       kuid_t uid, int any)\n{\n\tstruct dentry *ds;\n\tchar **wnames, *uname;\n\tint i, n, l, clone, access;\n\tstruct v9fs_session_info *v9ses;\n\tstruct p9_fid *fid, *old_fid = NULL;\n\n\tv9ses = v9fs_dentry2v9ses(dentry);\n\taccess = v9ses->flags & V9FS_ACCESS_MASK;\n\tfid = v9fs_fid_find(dentry, uid, any);\n\tif (fid)\n\t\treturn fid;\n\t/*\n\t * we don't have a matching fid. To do a TWALK we need\n\t * parent fid. We need to prevent rename when we want to\n\t * look at the parent.\n\t */\n\tdown_read(&v9ses->rename_sem);\n\tds = dentry->d_parent;\n\tfid = v9fs_fid_find(ds, uid, any);\n\tif (fid) {\n\t\t/* Found the parent fid do a lookup with that */\n\t\tfid = p9_client_walk(fid, 1, (char **)&dentry->d_name.name, 1);\n\t\tgoto fid_out;\n\t}\n\tup_read(&v9ses->rename_sem);\n\n\t/* start from the root and try to do a lookup */\n\tfid = v9fs_fid_find(dentry->d_sb->s_root, uid, any);\n\tif (!fid) {\n\t\t/* the user is not attached to the fs yet */\n\t\tif (access == V9FS_ACCESS_SINGLE)\n\t\t\treturn ERR_PTR(-EPERM);\n\n\t\tif (v9fs_proto_dotu(v9ses) || v9fs_proto_dotl(v9ses))\n\t\t\t\tuname = NULL;\n\t\telse\n\t\t\tuname = v9ses->uname;\n\n\t\tfid = p9_client_attach(v9ses->clnt, NULL, uname, uid,\n\t\t\t\t       v9ses->aname);\n\t\tif (IS_ERR(fid))\n\t\t\treturn fid;\n\n\t\tv9fs_fid_add(dentry->d_sb->s_root, fid);\n\t}\n\t/* If we are root ourself just return that */\n\tif (dentry->d_sb->s_root == dentry)\n\t\treturn fid;\n\t/*\n\t * Do a multipath walk with attached root.\n\t * When walking parent we need to make sure we\n\t * don't have a parallel rename happening\n\t */\n\tdown_read(&v9ses->rename_sem);\n\tn  = build_path_from_dentry(v9ses, dentry, &wnames);\n\tif (n < 0) {\n\t\tfid = ERR_PTR(n);\n\t\tgoto err_out;\n\t}\n\tclone = 1;\n\ti = 0;\n\twhile (i < n) {\n\t\tl = min(n - i, P9_MAXWELEM);\n\t\t/*\n\t\t * We need to hold rename lock when doing a multipath\n\t\t * walk to ensure none of the patch component change\n\t\t */\n\t\tfid = p9_client_walk(fid, l, &wnames[i], clone);\n\t\tif (IS_ERR(fid)) {\n\t\t\tif (old_fid) {\n\t\t\t\t/*\n\t\t\t\t * If we fail, clunk fid which are mapping\n\t\t\t\t * to path component and not the last component\n\t\t\t\t * of the path.\n\t\t\t\t */\n\t\t\t\tp9_client_clunk(old_fid);\n\t\t\t}\n\t\t\tkfree(wnames);\n\t\t\tgoto err_out;\n\t\t}\n\t\told_fid = fid;\n\t\ti += l;\n\t\tclone = 0;\n\t}\n\tkfree(wnames);\nfid_out:\n\tif (!IS_ERR(fid)) {\n\t\tspin_lock(&dentry->d_lock);\n\t\tif (d_unhashed(dentry)) {\n\t\t\tspin_unlock(&dentry->d_lock);\n\t\t\tp9_client_clunk(fid);\n\t\t\tfid = ERR_PTR(-ENOENT);\n\t\t} else {\n\t\t\t__add_fid(dentry, fid);\n\t\t\tspin_unlock(&dentry->d_lock);\n\t\t}\n\t}\nerr_out:\n\tup_read(&v9ses->rename_sem);\n\treturn fid;\n}"
  },
  {
    "function_name": "build_path_from_dentry",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/9p/fid.c",
    "lines": "93-114",
    "snippet": "static int build_path_from_dentry(struct v9fs_session_info *v9ses,\n\t\t\t\t  struct dentry *dentry, char ***names)\n{\n\tint n = 0, i;\n\tchar **wnames;\n\tstruct dentry *ds;\n\n\tfor (ds = dentry; !IS_ROOT(ds); ds = ds->d_parent)\n\t\tn++;\n\n\twnames = kmalloc(sizeof(char *) * n, GFP_KERNEL);\n\tif (!wnames)\n\t\tgoto err_out;\n\n\tfor (ds = dentry, i = (n-1); i >= 0; i--, ds = ds->d_parent)\n\t\twnames[i] = (char  *)ds->d_name.name;\n\n\t*names = wnames;\n\treturn n;\nerr_out:\n\treturn -ENOMEM;\n}",
    "includes": [
      "#include \"fid.h\"",
      "#include \"v9fs_vfs.h\"",
      "#include \"v9fs.h\"",
      "#include <net/9p/client.h>",
      "#include <net/9p/9p.h>",
      "#include <linux/idr.h>",
      "#include <linux/sched.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/errno.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "sizeof(char *) * n",
            "GFP_KERNEL"
          ],
          "line": 103
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dx_dir_kmalloc_leaves",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "2534-2546",
          "snippet": "static struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_ROOT",
          "args": [
            "ds"
          ],
          "line": 100
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"fid.h\"\n#include \"v9fs_vfs.h\"\n#include \"v9fs.h\"\n#include <net/9p/client.h>\n#include <net/9p/9p.h>\n#include <linux/idr.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <linux/module.h>\n\nstatic int build_path_from_dentry(struct v9fs_session_info *v9ses,\n\t\t\t\t  struct dentry *dentry, char ***names)\n{\n\tint n = 0, i;\n\tchar **wnames;\n\tstruct dentry *ds;\n\n\tfor (ds = dentry; !IS_ROOT(ds); ds = ds->d_parent)\n\t\tn++;\n\n\twnames = kmalloc(sizeof(char *) * n, GFP_KERNEL);\n\tif (!wnames)\n\t\tgoto err_out;\n\n\tfor (ds = dentry, i = (n-1); i >= 0; i--, ds = ds->d_parent)\n\t\twnames[i] = (char  *)ds->d_name.name;\n\n\t*names = wnames;\n\treturn n;\nerr_out:\n\treturn -ENOMEM;\n}"
  },
  {
    "function_name": "v9fs_fid_find",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/9p/fid.c",
    "lines": "64-86",
    "snippet": "static struct p9_fid *v9fs_fid_find(struct dentry *dentry, kuid_t uid, int any)\n{\n\tstruct p9_fid *fid, *ret;\n\n\tp9_debug(P9_DEBUG_VFS, \" dentry: %pd (%p) uid %d any %d\\n\",\n\t\t dentry, dentry, from_kuid(&init_user_ns, uid),\n\t\t any);\n\tret = NULL;\n\t/* we'll recheck under lock if there's anything to look in */\n\tif (dentry->d_fsdata) {\n\t\tstruct hlist_head *h = (struct hlist_head *)&dentry->d_fsdata;\n\t\tspin_lock(&dentry->d_lock);\n\t\thlist_for_each_entry(fid, h, dlist) {\n\t\t\tif (any || uid_eq(fid->uid, uid)) {\n\t\t\t\tret = fid;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tspin_unlock(&dentry->d_lock);\n\t}\n\n\treturn ret;\n}",
    "includes": [
      "#include \"fid.h\"",
      "#include \"v9fs_vfs.h\"",
      "#include \"v9fs.h\"",
      "#include <net/9p/client.h>",
      "#include <net/9p/9p.h>",
      "#include <linux/idr.h>",
      "#include <linux/sched.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/errno.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&dentry->d_lock"
          ],
          "line": 82
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "uid_eq",
          "args": [
            "fid->uid",
            "uid"
          ],
          "line": 77
        },
        "resolved": true,
        "details": {
          "function_name": "uuid_equal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/uuid.c",
          "lines": "59-63",
          "snippet": "int\nuuid_equal(uuid_t *uuid1, uuid_t *uuid2)\n{\n\treturn memcmp(uuid1, uuid2, sizeof(uuid_t)) ? 0 : 1;\n}",
          "includes": [
            "#include <xfs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <xfs.h>\n\nint\nuuid_equal(uuid_t *uuid1, uuid_t *uuid2)\n{\n\treturn memcmp(uuid1, uuid2, sizeof(uuid_t)) ? 0 : 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "hlist_for_each_entry",
          "args": [
            "fid",
            "h",
            "dlist"
          ],
          "line": 76
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&dentry->d_lock"
          ],
          "line": 75
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "p9_debug",
          "args": [
            "P9_DEBUG_VFS",
            "\" dentry: %pd (%p) uid %d any %d\\n\"",
            "dentry",
            "dentry",
            "from_kuid(&init_user_ns, uid)",
            "any"
          ],
          "line": 68
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "from_kuid",
          "args": [
            "&init_user_ns",
            "uid"
          ],
          "line": 69
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"fid.h\"\n#include \"v9fs_vfs.h\"\n#include \"v9fs.h\"\n#include <net/9p/client.h>\n#include <net/9p/9p.h>\n#include <linux/idr.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <linux/module.h>\n\nstatic struct p9_fid *v9fs_fid_find(struct dentry *dentry, kuid_t uid, int any)\n{\n\tstruct p9_fid *fid, *ret;\n\n\tp9_debug(P9_DEBUG_VFS, \" dentry: %pd (%p) uid %d any %d\\n\",\n\t\t dentry, dentry, from_kuid(&init_user_ns, uid),\n\t\t any);\n\tret = NULL;\n\t/* we'll recheck under lock if there's anything to look in */\n\tif (dentry->d_fsdata) {\n\t\tstruct hlist_head *h = (struct hlist_head *)&dentry->d_fsdata;\n\t\tspin_lock(&dentry->d_lock);\n\t\thlist_for_each_entry(fid, h, dlist) {\n\t\t\tif (any || uid_eq(fid->uid, uid)) {\n\t\t\t\tret = fid;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tspin_unlock(&dentry->d_lock);\n\t}\n\n\treturn ret;\n}"
  },
  {
    "function_name": "v9fs_fid_add",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/9p/fid.c",
    "lines": "49-54",
    "snippet": "void v9fs_fid_add(struct dentry *dentry, struct p9_fid *fid)\n{\n\tspin_lock(&dentry->d_lock);\n\t__add_fid(dentry, fid);\n\tspin_unlock(&dentry->d_lock);\n}",
    "includes": [
      "#include \"fid.h\"",
      "#include \"v9fs_vfs.h\"",
      "#include \"v9fs.h\"",
      "#include <net/9p/client.h>",
      "#include <net/9p/9p.h>",
      "#include <linux/idr.h>",
      "#include <linux/sched.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/errno.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&dentry->d_lock"
          ],
          "line": 53
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "__add_fid",
          "args": [
            "dentry",
            "fid"
          ],
          "line": 52
        },
        "resolved": true,
        "details": {
          "function_name": "__add_fid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/9p/fid.c",
          "lines": "44-47",
          "snippet": "static inline void __add_fid(struct dentry *dentry, struct p9_fid *fid)\n{\n\thlist_add_head(&fid->dlist, (struct hlist_head *)&dentry->d_fsdata);\n}",
          "includes": [
            "#include \"fid.h\"",
            "#include \"v9fs_vfs.h\"",
            "#include \"v9fs.h\"",
            "#include <net/9p/client.h>",
            "#include <net/9p/9p.h>",
            "#include <linux/idr.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/errno.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fid.h\"\n#include \"v9fs_vfs.h\"\n#include \"v9fs.h\"\n#include <net/9p/client.h>\n#include <net/9p/9p.h>\n#include <linux/idr.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <linux/module.h>\n\nstatic inline void __add_fid(struct dentry *dentry, struct p9_fid *fid)\n{\n\thlist_add_head(&fid->dlist, (struct hlist_head *)&dentry->d_fsdata);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&dentry->d_lock"
          ],
          "line": 51
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"fid.h\"\n#include \"v9fs_vfs.h\"\n#include \"v9fs.h\"\n#include <net/9p/client.h>\n#include <net/9p/9p.h>\n#include <linux/idr.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <linux/module.h>\n\nvoid v9fs_fid_add(struct dentry *dentry, struct p9_fid *fid)\n{\n\tspin_lock(&dentry->d_lock);\n\t__add_fid(dentry, fid);\n\tspin_unlock(&dentry->d_lock);\n}"
  },
  {
    "function_name": "__add_fid",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/9p/fid.c",
    "lines": "44-47",
    "snippet": "static inline void __add_fid(struct dentry *dentry, struct p9_fid *fid)\n{\n\thlist_add_head(&fid->dlist, (struct hlist_head *)&dentry->d_fsdata);\n}",
    "includes": [
      "#include \"fid.h\"",
      "#include \"v9fs_vfs.h\"",
      "#include \"v9fs.h\"",
      "#include <net/9p/client.h>",
      "#include <net/9p/9p.h>",
      "#include <linux/idr.h>",
      "#include <linux/sched.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/errno.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "hlist_add_head",
          "args": [
            "&fid->dlist",
            "(struct hlist_head *)&dentry->d_fsdata"
          ],
          "line": 46
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"fid.h\"\n#include \"v9fs_vfs.h\"\n#include \"v9fs.h\"\n#include <net/9p/client.h>\n#include <net/9p/9p.h>\n#include <linux/idr.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <linux/module.h>\n\nstatic inline void __add_fid(struct dentry *dentry, struct p9_fid *fid)\n{\n\thlist_add_head(&fid->dlist, (struct hlist_head *)&dentry->d_fsdata);\n}"
  }
]