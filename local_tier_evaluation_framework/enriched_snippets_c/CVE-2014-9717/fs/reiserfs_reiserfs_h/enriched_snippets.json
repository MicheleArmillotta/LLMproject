[
  {
    "function_name": "reiserfs_new_unf_blocknrs2",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/reiserfs.h",
    "lines": "3363-3378",
    "snippet": "static inline int reiserfs_new_unf_blocknrs2(struct reiserfs_transaction_handle\n\t\t\t\t\t     *th, struct inode *inode,\n\t\t\t\t\t     b_blocknr_t * new_blocknrs,\n\t\t\t\t\t     struct treepath *path,\n\t\t\t\t\t     sector_t block)\n{\n\treiserfs_blocknr_hint_t hint = {\n\t\t.th = th,\n\t\t.path = path,\n\t\t.inode = inode,\n\t\t.block = block,\n\t\t.formatted_node = 0,\n\t\t.preallocate = 1\n\t};\n\treturn reiserfs_allocate_blocknrs(&hint, new_blocknrs, 1, 0);\n}",
    "includes": [
      "#include <linux/buffer_head.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/bitops.h>",
      "#include <asm/unaligned.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/bug.h>",
      "#include <linux/sched.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/slab.h>",
      "#include <linux/reiserfs_fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "int reiserfs_end_persistent_transaction(struct reiserfs_transaction_handle *);",
      "void reiserfs_vfs_truncate_file(struct inode *inode);",
      "int reiserfs_commit_for_inode(struct inode *);",
      "int reiserfs_inode_needs_commit(struct inode *);",
      "void reiserfs_update_inode_transaction(struct inode *);",
      "void reiserfs_block_writes(struct reiserfs_transaction_handle *th);",
      "int journal_end(struct reiserfs_transaction_handle *);",
      "int journal_end_sync(struct reiserfs_transaction_handle *);",
      "int journal_transaction_should_end(struct reiserfs_transaction_handle *, int);",
      "__u32 reiserfs_get_unused_objectid(struct reiserfs_transaction_handle *th);",
      "int comp_items(const struct item_head *stored_ih, const struct treepath *path);",
      "int search_by_key(struct super_block *, const struct cpu_key *,\n\t\t  struct treepath *, int);",
      "int reiserfs_delete_object(struct reiserfs_transaction_handle *th,\n\t\t\t   struct inode *inode);",
      "void reiserfs_evict_inode(struct inode *inode);",
      "void sd_attrs_to_i_attrs(__u16 sd_attrs, struct inode *inode);",
      "int reiserfs_allocate_blocknrs(reiserfs_blocknr_hint_t *, b_blocknr_t *, int,\n\t\t\t       int);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "reiserfs_allocate_blocknrs",
          "args": [
            "&hint",
            "new_blocknrs",
            "1",
            "0"
          ],
          "line": 3377
        },
        "resolved": true,
        "details": {
          "function_name": "reiserfs_allocate_blocknrs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/bitmap.c",
          "lines": "1326-1383",
          "snippet": "int reiserfs_allocate_blocknrs(reiserfs_blocknr_hint_t *hint,\n\t\t\t       b_blocknr_t *new_blocknrs,\n\t\t\t       int amount_needed,\n\t\t\t       /* Amount of blocks we have already reserved */\n\t\t\t       int reserved_by_us)\n{\n\tint initial_amount_needed = amount_needed;\n\tint ret;\n\tstruct super_block *s = hint->th->t_super;\n\n\t/* Check if there is enough space, taking into account reserved space */\n\tif (SB_FREE_BLOCKS(s) - REISERFS_SB(s)->reserved_blocks <\n\t    amount_needed - reserved_by_us)\n\t\treturn NO_DISK_SPACE;\n\t/* should this be if !hint->inode &&  hint->preallocate? */\n\t/* do you mean hint->formatted_node can be removed ? - Zam */\n\t/*\n\t * hint->formatted_node cannot be removed because we try to access\n\t * inode information here, and there is often no inode associated with\n\t * metadata allocations - green\n\t */\n\n\tif (!hint->formatted_node && hint->preallocate) {\n\t\tamount_needed = use_preallocated_list_if_available\n\t\t    (hint, new_blocknrs, amount_needed);\n\n\t\t/*\n\t\t * We have all the block numbers we need from the\n\t\t * prealloc list\n\t\t */\n\t\tif (amount_needed == 0)\n\t\t\treturn CARRY_ON;\n\t\tnew_blocknrs += (initial_amount_needed - amount_needed);\n\t}\n\n\t/* find search start and save it in hint structure */\n\tdetermine_search_start(hint, amount_needed);\n\tif (hint->search_start >= SB_BLOCK_COUNT(s))\n\t\thint->search_start = SB_BLOCK_COUNT(s) - 1;\n\n\t/* allocation itself; fill new_blocknrs and preallocation arrays */\n\tret = blocknrs_and_prealloc_arrays_from_search_start\n\t    (hint, new_blocknrs, amount_needed);\n\n\t/*\n\t * We used prealloc. list to fill (partially) new_blocknrs array.\n\t * If final allocation fails we need to return blocks back to\n\t * prealloc. list or just free them. -- Zam (I chose second\n\t * variant)\n\t */\n\tif (ret != CARRY_ON) {\n\t\twhile (amount_needed++ < initial_amount_needed) {\n\t\t\treiserfs_free_block(hint->th, hint->inode,\n\t\t\t\t\t    *(--new_blocknrs), 1);\n\t\t}\n\t}\n\treturn ret;\n}",
          "includes": [
            "#include <linux/seq_file.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/kernel.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/errno.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/vmalloc.h>\n#include <linux/pagemap.h>\n#include <linux/kernel.h>\n#include <linux/buffer_head.h>\n#include <linux/errno.h>\n#include \"reiserfs.h\"\n#include <linux/time.h>\n\nint reiserfs_allocate_blocknrs(reiserfs_blocknr_hint_t *hint,\n\t\t\t       b_blocknr_t *new_blocknrs,\n\t\t\t       int amount_needed,\n\t\t\t       /* Amount of blocks we have already reserved */\n\t\t\t       int reserved_by_us)\n{\n\tint initial_amount_needed = amount_needed;\n\tint ret;\n\tstruct super_block *s = hint->th->t_super;\n\n\t/* Check if there is enough space, taking into account reserved space */\n\tif (SB_FREE_BLOCKS(s) - REISERFS_SB(s)->reserved_blocks <\n\t    amount_needed - reserved_by_us)\n\t\treturn NO_DISK_SPACE;\n\t/* should this be if !hint->inode &&  hint->preallocate? */\n\t/* do you mean hint->formatted_node can be removed ? - Zam */\n\t/*\n\t * hint->formatted_node cannot be removed because we try to access\n\t * inode information here, and there is often no inode associated with\n\t * metadata allocations - green\n\t */\n\n\tif (!hint->formatted_node && hint->preallocate) {\n\t\tamount_needed = use_preallocated_list_if_available\n\t\t    (hint, new_blocknrs, amount_needed);\n\n\t\t/*\n\t\t * We have all the block numbers we need from the\n\t\t * prealloc list\n\t\t */\n\t\tif (amount_needed == 0)\n\t\t\treturn CARRY_ON;\n\t\tnew_blocknrs += (initial_amount_needed - amount_needed);\n\t}\n\n\t/* find search start and save it in hint structure */\n\tdetermine_search_start(hint, amount_needed);\n\tif (hint->search_start >= SB_BLOCK_COUNT(s))\n\t\thint->search_start = SB_BLOCK_COUNT(s) - 1;\n\n\t/* allocation itself; fill new_blocknrs and preallocation arrays */\n\tret = blocknrs_and_prealloc_arrays_from_search_start\n\t    (hint, new_blocknrs, amount_needed);\n\n\t/*\n\t * We used prealloc. list to fill (partially) new_blocknrs array.\n\t * If final allocation fails we need to return blocks back to\n\t * prealloc. list or just free them. -- Zam (I chose second\n\t * variant)\n\t */\n\tif (ret != CARRY_ON) {\n\t\twhile (amount_needed++ < initial_amount_needed) {\n\t\t\treiserfs_free_block(hint->th, hint->inode,\n\t\t\t\t\t    *(--new_blocknrs), 1);\n\t\t}\n\t}\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/buffer_head.h>\n#include <linux/proc_fs.h>\n#include <linux/bitops.h>\n#include <asm/unaligned.h>\n#include <linux/workqueue.h>\n#include <linux/bug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/slab.h>\n#include <linux/reiserfs_fs.h>\n\nint reiserfs_end_persistent_transaction(struct reiserfs_transaction_handle *);\nvoid reiserfs_vfs_truncate_file(struct inode *inode);\nint reiserfs_commit_for_inode(struct inode *);\nint reiserfs_inode_needs_commit(struct inode *);\nvoid reiserfs_update_inode_transaction(struct inode *);\nvoid reiserfs_block_writes(struct reiserfs_transaction_handle *th);\nint journal_end(struct reiserfs_transaction_handle *);\nint journal_end_sync(struct reiserfs_transaction_handle *);\nint journal_transaction_should_end(struct reiserfs_transaction_handle *, int);\n__u32 reiserfs_get_unused_objectid(struct reiserfs_transaction_handle *th);\nint comp_items(const struct item_head *stored_ih, const struct treepath *path);\nint search_by_key(struct super_block *, const struct cpu_key *,\n\t\t  struct treepath *, int);\nint reiserfs_delete_object(struct reiserfs_transaction_handle *th,\n\t\t\t   struct inode *inode);\nvoid reiserfs_evict_inode(struct inode *inode);\nvoid sd_attrs_to_i_attrs(__u16 sd_attrs, struct inode *inode);\nint reiserfs_allocate_blocknrs(reiserfs_blocknr_hint_t *, b_blocknr_t *, int,\n\t\t\t       int);\n\nstatic inline int reiserfs_new_unf_blocknrs2(struct reiserfs_transaction_handle\n\t\t\t\t\t     *th, struct inode *inode,\n\t\t\t\t\t     b_blocknr_t * new_blocknrs,\n\t\t\t\t\t     struct treepath *path,\n\t\t\t\t\t     sector_t block)\n{\n\treiserfs_blocknr_hint_t hint = {\n\t\t.th = th,\n\t\t.path = path,\n\t\t.inode = inode,\n\t\t.block = block,\n\t\t.formatted_node = 0,\n\t\t.preallocate = 1\n\t};\n\treturn reiserfs_allocate_blocknrs(&hint, new_blocknrs, 1, 0);\n}"
  },
  {
    "function_name": "reiserfs_new_unf_blocknrs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/reiserfs.h",
    "lines": "3345-3360",
    "snippet": "static inline int reiserfs_new_unf_blocknrs(struct reiserfs_transaction_handle\n\t\t\t\t\t    *th, struct inode *inode,\n\t\t\t\t\t    b_blocknr_t * new_blocknrs,\n\t\t\t\t\t    struct treepath *path,\n\t\t\t\t\t    sector_t block)\n{\n\treiserfs_blocknr_hint_t hint = {\n\t\t.th = th,\n\t\t.path = path,\n\t\t.inode = inode,\n\t\t.block = block,\n\t\t.formatted_node = 0,\n\t\t.preallocate = 0\n\t};\n\treturn reiserfs_allocate_blocknrs(&hint, new_blocknrs, 1, 0);\n}",
    "includes": [
      "#include <linux/buffer_head.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/bitops.h>",
      "#include <asm/unaligned.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/bug.h>",
      "#include <linux/sched.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/slab.h>",
      "#include <linux/reiserfs_fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "int reiserfs_end_persistent_transaction(struct reiserfs_transaction_handle *);",
      "void reiserfs_vfs_truncate_file(struct inode *inode);",
      "int reiserfs_commit_for_inode(struct inode *);",
      "int reiserfs_inode_needs_commit(struct inode *);",
      "void reiserfs_update_inode_transaction(struct inode *);",
      "void reiserfs_block_writes(struct reiserfs_transaction_handle *th);",
      "int journal_end(struct reiserfs_transaction_handle *);",
      "int journal_end_sync(struct reiserfs_transaction_handle *);",
      "int journal_transaction_should_end(struct reiserfs_transaction_handle *, int);",
      "__u32 reiserfs_get_unused_objectid(struct reiserfs_transaction_handle *th);",
      "int comp_items(const struct item_head *stored_ih, const struct treepath *path);",
      "int search_by_key(struct super_block *, const struct cpu_key *,\n\t\t  struct treepath *, int);",
      "int reiserfs_delete_object(struct reiserfs_transaction_handle *th,\n\t\t\t   struct inode *inode);",
      "void reiserfs_evict_inode(struct inode *inode);",
      "void sd_attrs_to_i_attrs(__u16 sd_attrs, struct inode *inode);",
      "int reiserfs_allocate_blocknrs(reiserfs_blocknr_hint_t *, b_blocknr_t *, int,\n\t\t\t       int);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "reiserfs_allocate_blocknrs",
          "args": [
            "&hint",
            "new_blocknrs",
            "1",
            "0"
          ],
          "line": 3359
        },
        "resolved": true,
        "details": {
          "function_name": "reiserfs_allocate_blocknrs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/bitmap.c",
          "lines": "1326-1383",
          "snippet": "int reiserfs_allocate_blocknrs(reiserfs_blocknr_hint_t *hint,\n\t\t\t       b_blocknr_t *new_blocknrs,\n\t\t\t       int amount_needed,\n\t\t\t       /* Amount of blocks we have already reserved */\n\t\t\t       int reserved_by_us)\n{\n\tint initial_amount_needed = amount_needed;\n\tint ret;\n\tstruct super_block *s = hint->th->t_super;\n\n\t/* Check if there is enough space, taking into account reserved space */\n\tif (SB_FREE_BLOCKS(s) - REISERFS_SB(s)->reserved_blocks <\n\t    amount_needed - reserved_by_us)\n\t\treturn NO_DISK_SPACE;\n\t/* should this be if !hint->inode &&  hint->preallocate? */\n\t/* do you mean hint->formatted_node can be removed ? - Zam */\n\t/*\n\t * hint->formatted_node cannot be removed because we try to access\n\t * inode information here, and there is often no inode associated with\n\t * metadata allocations - green\n\t */\n\n\tif (!hint->formatted_node && hint->preallocate) {\n\t\tamount_needed = use_preallocated_list_if_available\n\t\t    (hint, new_blocknrs, amount_needed);\n\n\t\t/*\n\t\t * We have all the block numbers we need from the\n\t\t * prealloc list\n\t\t */\n\t\tif (amount_needed == 0)\n\t\t\treturn CARRY_ON;\n\t\tnew_blocknrs += (initial_amount_needed - amount_needed);\n\t}\n\n\t/* find search start and save it in hint structure */\n\tdetermine_search_start(hint, amount_needed);\n\tif (hint->search_start >= SB_BLOCK_COUNT(s))\n\t\thint->search_start = SB_BLOCK_COUNT(s) - 1;\n\n\t/* allocation itself; fill new_blocknrs and preallocation arrays */\n\tret = blocknrs_and_prealloc_arrays_from_search_start\n\t    (hint, new_blocknrs, amount_needed);\n\n\t/*\n\t * We used prealloc. list to fill (partially) new_blocknrs array.\n\t * If final allocation fails we need to return blocks back to\n\t * prealloc. list or just free them. -- Zam (I chose second\n\t * variant)\n\t */\n\tif (ret != CARRY_ON) {\n\t\twhile (amount_needed++ < initial_amount_needed) {\n\t\t\treiserfs_free_block(hint->th, hint->inode,\n\t\t\t\t\t    *(--new_blocknrs), 1);\n\t\t}\n\t}\n\treturn ret;\n}",
          "includes": [
            "#include <linux/seq_file.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/kernel.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/errno.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/vmalloc.h>\n#include <linux/pagemap.h>\n#include <linux/kernel.h>\n#include <linux/buffer_head.h>\n#include <linux/errno.h>\n#include \"reiserfs.h\"\n#include <linux/time.h>\n\nint reiserfs_allocate_blocknrs(reiserfs_blocknr_hint_t *hint,\n\t\t\t       b_blocknr_t *new_blocknrs,\n\t\t\t       int amount_needed,\n\t\t\t       /* Amount of blocks we have already reserved */\n\t\t\t       int reserved_by_us)\n{\n\tint initial_amount_needed = amount_needed;\n\tint ret;\n\tstruct super_block *s = hint->th->t_super;\n\n\t/* Check if there is enough space, taking into account reserved space */\n\tif (SB_FREE_BLOCKS(s) - REISERFS_SB(s)->reserved_blocks <\n\t    amount_needed - reserved_by_us)\n\t\treturn NO_DISK_SPACE;\n\t/* should this be if !hint->inode &&  hint->preallocate? */\n\t/* do you mean hint->formatted_node can be removed ? - Zam */\n\t/*\n\t * hint->formatted_node cannot be removed because we try to access\n\t * inode information here, and there is often no inode associated with\n\t * metadata allocations - green\n\t */\n\n\tif (!hint->formatted_node && hint->preallocate) {\n\t\tamount_needed = use_preallocated_list_if_available\n\t\t    (hint, new_blocknrs, amount_needed);\n\n\t\t/*\n\t\t * We have all the block numbers we need from the\n\t\t * prealloc list\n\t\t */\n\t\tif (amount_needed == 0)\n\t\t\treturn CARRY_ON;\n\t\tnew_blocknrs += (initial_amount_needed - amount_needed);\n\t}\n\n\t/* find search start and save it in hint structure */\n\tdetermine_search_start(hint, amount_needed);\n\tif (hint->search_start >= SB_BLOCK_COUNT(s))\n\t\thint->search_start = SB_BLOCK_COUNT(s) - 1;\n\n\t/* allocation itself; fill new_blocknrs and preallocation arrays */\n\tret = blocknrs_and_prealloc_arrays_from_search_start\n\t    (hint, new_blocknrs, amount_needed);\n\n\t/*\n\t * We used prealloc. list to fill (partially) new_blocknrs array.\n\t * If final allocation fails we need to return blocks back to\n\t * prealloc. list or just free them. -- Zam (I chose second\n\t * variant)\n\t */\n\tif (ret != CARRY_ON) {\n\t\twhile (amount_needed++ < initial_amount_needed) {\n\t\t\treiserfs_free_block(hint->th, hint->inode,\n\t\t\t\t\t    *(--new_blocknrs), 1);\n\t\t}\n\t}\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/buffer_head.h>\n#include <linux/proc_fs.h>\n#include <linux/bitops.h>\n#include <asm/unaligned.h>\n#include <linux/workqueue.h>\n#include <linux/bug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/slab.h>\n#include <linux/reiserfs_fs.h>\n\nint reiserfs_end_persistent_transaction(struct reiserfs_transaction_handle *);\nvoid reiserfs_vfs_truncate_file(struct inode *inode);\nint reiserfs_commit_for_inode(struct inode *);\nint reiserfs_inode_needs_commit(struct inode *);\nvoid reiserfs_update_inode_transaction(struct inode *);\nvoid reiserfs_block_writes(struct reiserfs_transaction_handle *th);\nint journal_end(struct reiserfs_transaction_handle *);\nint journal_end_sync(struct reiserfs_transaction_handle *);\nint journal_transaction_should_end(struct reiserfs_transaction_handle *, int);\n__u32 reiserfs_get_unused_objectid(struct reiserfs_transaction_handle *th);\nint comp_items(const struct item_head *stored_ih, const struct treepath *path);\nint search_by_key(struct super_block *, const struct cpu_key *,\n\t\t  struct treepath *, int);\nint reiserfs_delete_object(struct reiserfs_transaction_handle *th,\n\t\t\t   struct inode *inode);\nvoid reiserfs_evict_inode(struct inode *inode);\nvoid sd_attrs_to_i_attrs(__u16 sd_attrs, struct inode *inode);\nint reiserfs_allocate_blocknrs(reiserfs_blocknr_hint_t *, b_blocknr_t *, int,\n\t\t\t       int);\n\nstatic inline int reiserfs_new_unf_blocknrs(struct reiserfs_transaction_handle\n\t\t\t\t\t    *th, struct inode *inode,\n\t\t\t\t\t    b_blocknr_t * new_blocknrs,\n\t\t\t\t\t    struct treepath *path,\n\t\t\t\t\t    sector_t block)\n{\n\treiserfs_blocknr_hint_t hint = {\n\t\t.th = th,\n\t\t.path = path,\n\t\t.inode = inode,\n\t\t.block = block,\n\t\t.formatted_node = 0,\n\t\t.preallocate = 0\n\t};\n\treturn reiserfs_allocate_blocknrs(&hint, new_blocknrs, 1, 0);\n}"
  },
  {
    "function_name": "reiserfs_new_form_blocknrs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/reiserfs.h",
    "lines": "3329-3343",
    "snippet": "static inline int reiserfs_new_form_blocknrs(struct tree_balance *tb,\n\t\t\t\t\t     b_blocknr_t * new_blocknrs,\n\t\t\t\t\t     int amount_needed)\n{\n\treiserfs_blocknr_hint_t hint = {\n\t\t.th = tb->transaction_handle,\n\t\t.path = tb->tb_path,\n\t\t.inode = NULL,\n\t\t.key = tb->key,\n\t\t.block = 0,\n\t\t.formatted_node = 1\n\t};\n\treturn reiserfs_allocate_blocknrs(&hint, new_blocknrs, amount_needed,\n\t\t\t\t\t  0);\n}",
    "includes": [
      "#include <linux/buffer_head.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/bitops.h>",
      "#include <asm/unaligned.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/bug.h>",
      "#include <linux/sched.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/slab.h>",
      "#include <linux/reiserfs_fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "void reiserfs_vfs_truncate_file(struct inode *inode);",
      "int reiserfs_commit_for_inode(struct inode *);",
      "int reiserfs_inode_needs_commit(struct inode *);",
      "void reiserfs_update_inode_transaction(struct inode *);",
      "void reiserfs_block_writes(struct reiserfs_transaction_handle *th);",
      "__u32 reiserfs_get_unused_objectid(struct reiserfs_transaction_handle *th);",
      "int comp_items(const struct item_head *stored_ih, const struct treepath *path);",
      "void reiserfs_delete_solid_item(struct reiserfs_transaction_handle *th,\n\t\t\t\tstruct inode *inode, struct reiserfs_key *key);",
      "int reiserfs_delete_object(struct reiserfs_transaction_handle *th,\n\t\t\t   struct inode *inode);",
      "void reiserfs_evict_inode(struct inode *inode);",
      "struct inode *reiserfs_iget(struct super_block *s, const struct cpu_key *key);",
      "void sd_attrs_to_i_attrs(__u16 sd_attrs, struct inode *inode);",
      "void unfix_nodes(struct tree_balance *);",
      "void store_print_tb(struct tree_balance *tb);",
      "struct buffer_head *get_FEB(struct tree_balance *);",
      "int reiserfs_allocate_blocknrs(reiserfs_blocknr_hint_t *, b_blocknr_t *, int,\n\t\t\t       int);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "reiserfs_allocate_blocknrs",
          "args": [
            "&hint",
            "new_blocknrs",
            "amount_needed",
            "0"
          ],
          "line": 3341
        },
        "resolved": true,
        "details": {
          "function_name": "reiserfs_allocate_blocknrs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/bitmap.c",
          "lines": "1326-1383",
          "snippet": "int reiserfs_allocate_blocknrs(reiserfs_blocknr_hint_t *hint,\n\t\t\t       b_blocknr_t *new_blocknrs,\n\t\t\t       int amount_needed,\n\t\t\t       /* Amount of blocks we have already reserved */\n\t\t\t       int reserved_by_us)\n{\n\tint initial_amount_needed = amount_needed;\n\tint ret;\n\tstruct super_block *s = hint->th->t_super;\n\n\t/* Check if there is enough space, taking into account reserved space */\n\tif (SB_FREE_BLOCKS(s) - REISERFS_SB(s)->reserved_blocks <\n\t    amount_needed - reserved_by_us)\n\t\treturn NO_DISK_SPACE;\n\t/* should this be if !hint->inode &&  hint->preallocate? */\n\t/* do you mean hint->formatted_node can be removed ? - Zam */\n\t/*\n\t * hint->formatted_node cannot be removed because we try to access\n\t * inode information here, and there is often no inode associated with\n\t * metadata allocations - green\n\t */\n\n\tif (!hint->formatted_node && hint->preallocate) {\n\t\tamount_needed = use_preallocated_list_if_available\n\t\t    (hint, new_blocknrs, amount_needed);\n\n\t\t/*\n\t\t * We have all the block numbers we need from the\n\t\t * prealloc list\n\t\t */\n\t\tif (amount_needed == 0)\n\t\t\treturn CARRY_ON;\n\t\tnew_blocknrs += (initial_amount_needed - amount_needed);\n\t}\n\n\t/* find search start and save it in hint structure */\n\tdetermine_search_start(hint, amount_needed);\n\tif (hint->search_start >= SB_BLOCK_COUNT(s))\n\t\thint->search_start = SB_BLOCK_COUNT(s) - 1;\n\n\t/* allocation itself; fill new_blocknrs and preallocation arrays */\n\tret = blocknrs_and_prealloc_arrays_from_search_start\n\t    (hint, new_blocknrs, amount_needed);\n\n\t/*\n\t * We used prealloc. list to fill (partially) new_blocknrs array.\n\t * If final allocation fails we need to return blocks back to\n\t * prealloc. list or just free them. -- Zam (I chose second\n\t * variant)\n\t */\n\tif (ret != CARRY_ON) {\n\t\twhile (amount_needed++ < initial_amount_needed) {\n\t\t\treiserfs_free_block(hint->th, hint->inode,\n\t\t\t\t\t    *(--new_blocknrs), 1);\n\t\t}\n\t}\n\treturn ret;\n}",
          "includes": [
            "#include <linux/seq_file.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/kernel.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/errno.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/vmalloc.h>\n#include <linux/pagemap.h>\n#include <linux/kernel.h>\n#include <linux/buffer_head.h>\n#include <linux/errno.h>\n#include \"reiserfs.h\"\n#include <linux/time.h>\n\nint reiserfs_allocate_blocknrs(reiserfs_blocknr_hint_t *hint,\n\t\t\t       b_blocknr_t *new_blocknrs,\n\t\t\t       int amount_needed,\n\t\t\t       /* Amount of blocks we have already reserved */\n\t\t\t       int reserved_by_us)\n{\n\tint initial_amount_needed = amount_needed;\n\tint ret;\n\tstruct super_block *s = hint->th->t_super;\n\n\t/* Check if there is enough space, taking into account reserved space */\n\tif (SB_FREE_BLOCKS(s) - REISERFS_SB(s)->reserved_blocks <\n\t    amount_needed - reserved_by_us)\n\t\treturn NO_DISK_SPACE;\n\t/* should this be if !hint->inode &&  hint->preallocate? */\n\t/* do you mean hint->formatted_node can be removed ? - Zam */\n\t/*\n\t * hint->formatted_node cannot be removed because we try to access\n\t * inode information here, and there is often no inode associated with\n\t * metadata allocations - green\n\t */\n\n\tif (!hint->formatted_node && hint->preallocate) {\n\t\tamount_needed = use_preallocated_list_if_available\n\t\t    (hint, new_blocknrs, amount_needed);\n\n\t\t/*\n\t\t * We have all the block numbers we need from the\n\t\t * prealloc list\n\t\t */\n\t\tif (amount_needed == 0)\n\t\t\treturn CARRY_ON;\n\t\tnew_blocknrs += (initial_amount_needed - amount_needed);\n\t}\n\n\t/* find search start and save it in hint structure */\n\tdetermine_search_start(hint, amount_needed);\n\tif (hint->search_start >= SB_BLOCK_COUNT(s))\n\t\thint->search_start = SB_BLOCK_COUNT(s) - 1;\n\n\t/* allocation itself; fill new_blocknrs and preallocation arrays */\n\tret = blocknrs_and_prealloc_arrays_from_search_start\n\t    (hint, new_blocknrs, amount_needed);\n\n\t/*\n\t * We used prealloc. list to fill (partially) new_blocknrs array.\n\t * If final allocation fails we need to return blocks back to\n\t * prealloc. list or just free them. -- Zam (I chose second\n\t * variant)\n\t */\n\tif (ret != CARRY_ON) {\n\t\twhile (amount_needed++ < initial_amount_needed) {\n\t\t\treiserfs_free_block(hint->th, hint->inode,\n\t\t\t\t\t    *(--new_blocknrs), 1);\n\t\t}\n\t}\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/buffer_head.h>\n#include <linux/proc_fs.h>\n#include <linux/bitops.h>\n#include <asm/unaligned.h>\n#include <linux/workqueue.h>\n#include <linux/bug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/slab.h>\n#include <linux/reiserfs_fs.h>\n\nvoid reiserfs_vfs_truncate_file(struct inode *inode);\nint reiserfs_commit_for_inode(struct inode *);\nint reiserfs_inode_needs_commit(struct inode *);\nvoid reiserfs_update_inode_transaction(struct inode *);\nvoid reiserfs_block_writes(struct reiserfs_transaction_handle *th);\n__u32 reiserfs_get_unused_objectid(struct reiserfs_transaction_handle *th);\nint comp_items(const struct item_head *stored_ih, const struct treepath *path);\nvoid reiserfs_delete_solid_item(struct reiserfs_transaction_handle *th,\n\t\t\t\tstruct inode *inode, struct reiserfs_key *key);\nint reiserfs_delete_object(struct reiserfs_transaction_handle *th,\n\t\t\t   struct inode *inode);\nvoid reiserfs_evict_inode(struct inode *inode);\nstruct inode *reiserfs_iget(struct super_block *s, const struct cpu_key *key);\nvoid sd_attrs_to_i_attrs(__u16 sd_attrs, struct inode *inode);\nvoid unfix_nodes(struct tree_balance *);\nvoid store_print_tb(struct tree_balance *tb);\nstruct buffer_head *get_FEB(struct tree_balance *);\nint reiserfs_allocate_blocknrs(reiserfs_blocknr_hint_t *, b_blocknr_t *, int,\n\t\t\t       int);\n\nstatic inline int reiserfs_new_form_blocknrs(struct tree_balance *tb,\n\t\t\t\t\t     b_blocknr_t * new_blocknrs,\n\t\t\t\t\t     int amount_needed)\n{\n\treiserfs_blocknr_hint_t hint = {\n\t\t.th = tb->transaction_handle,\n\t\t.path = tb->tb_path,\n\t\t.inode = NULL,\n\t\t.key = tb->key,\n\t\t.block = 0,\n\t\t.formatted_node = 1\n\t};\n\treturn reiserfs_allocate_blocknrs(&hint, new_blocknrs, amount_needed,\n\t\t\t\t\t  0);\n}"
  },
  {
    "function_name": "reiserfs_proc_info_global_done",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/reiserfs.h",
    "lines": "3148-3151",
    "snippet": "static inline int reiserfs_proc_info_global_done(void)\n{\n\treturn 0;\n}",
    "includes": [
      "#include <linux/buffer_head.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/bitops.h>",
      "#include <asm/unaligned.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/bug.h>",
      "#include <linux/sched.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/slab.h>",
      "#include <linux/reiserfs_fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/buffer_head.h>\n#include <linux/proc_fs.h>\n#include <linux/bitops.h>\n#include <asm/unaligned.h>\n#include <linux/workqueue.h>\n#include <linux/bug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/slab.h>\n#include <linux/reiserfs_fs.h>\n\nstatic inline int reiserfs_proc_info_global_done(void)\n{\n\treturn 0;\n}"
  },
  {
    "function_name": "reiserfs_proc_info_global_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/reiserfs.h",
    "lines": "3143-3146",
    "snippet": "static inline int reiserfs_proc_info_global_init(void)\n{\n\treturn 0;\n}",
    "includes": [
      "#include <linux/buffer_head.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/bitops.h>",
      "#include <asm/unaligned.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/bug.h>",
      "#include <linux/sched.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/slab.h>",
      "#include <linux/reiserfs_fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/buffer_head.h>\n#include <linux/proc_fs.h>\n#include <linux/bitops.h>\n#include <asm/unaligned.h>\n#include <linux/workqueue.h>\n#include <linux/bug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/slab.h>\n#include <linux/reiserfs_fs.h>\n\nstatic inline int reiserfs_proc_info_global_init(void)\n{\n\treturn 0;\n}"
  },
  {
    "function_name": "reiserfs_proc_info_done",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/reiserfs.h",
    "lines": "3138-3141",
    "snippet": "static inline int reiserfs_proc_info_done(struct super_block *sb)\n{\n\treturn 0;\n}",
    "includes": [
      "#include <linux/buffer_head.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/bitops.h>",
      "#include <asm/unaligned.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/bug.h>",
      "#include <linux/sched.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/slab.h>",
      "#include <linux/reiserfs_fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "int reiserfs_resize(struct super_block *, unsigned long);",
      "void reiserfs_flush_old_commits(struct super_block *);",
      "int journal_release(struct reiserfs_transaction_handle *, struct super_block *);",
      "int journal_release_error(struct reiserfs_transaction_handle *,\n\t\t\t  struct super_block *);",
      "int journal_begin(struct reiserfs_transaction_handle *,\n\t\t  struct super_block *sb, unsigned long);",
      "int journal_join_abort(struct reiserfs_transaction_handle *,\n\t\t       struct super_block *sb);",
      "int reiserfs_convert_objectid_map_v1(struct super_block *);",
      "const struct reiserfs_key *get_rkey(const struct treepath *chk_path,\n\t\t\t\t    const struct super_block *sb);",
      "int reiserfs_parse_alloc_options(struct super_block *, char *);",
      "int reiserfs_init_bitmap_cache(struct super_block *sb);",
      "void reiserfs_free_bitmap_cache(struct super_block *sb);"
    ],
    "called_functions": [],
    "contextual_snippet": "#include <linux/buffer_head.h>\n#include <linux/proc_fs.h>\n#include <linux/bitops.h>\n#include <asm/unaligned.h>\n#include <linux/workqueue.h>\n#include <linux/bug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/slab.h>\n#include <linux/reiserfs_fs.h>\n\nint reiserfs_resize(struct super_block *, unsigned long);\nvoid reiserfs_flush_old_commits(struct super_block *);\nint journal_release(struct reiserfs_transaction_handle *, struct super_block *);\nint journal_release_error(struct reiserfs_transaction_handle *,\n\t\t\t  struct super_block *);\nint journal_begin(struct reiserfs_transaction_handle *,\n\t\t  struct super_block *sb, unsigned long);\nint journal_join_abort(struct reiserfs_transaction_handle *,\n\t\t       struct super_block *sb);\nint reiserfs_convert_objectid_map_v1(struct super_block *);\nconst struct reiserfs_key *get_rkey(const struct treepath *chk_path,\n\t\t\t\t    const struct super_block *sb);\nint reiserfs_parse_alloc_options(struct super_block *, char *);\nint reiserfs_init_bitmap_cache(struct super_block *sb);\nvoid reiserfs_free_bitmap_cache(struct super_block *sb);\n\nstatic inline int reiserfs_proc_info_done(struct super_block *sb)\n{\n\treturn 0;\n}"
  },
  {
    "function_name": "reiserfs_proc_info_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/reiserfs.h",
    "lines": "3133-3136",
    "snippet": "static inline int reiserfs_proc_info_init(struct super_block *sb)\n{\n\treturn 0;\n}",
    "includes": [
      "#include <linux/buffer_head.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/bitops.h>",
      "#include <asm/unaligned.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/bug.h>",
      "#include <linux/sched.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/slab.h>",
      "#include <linux/reiserfs_fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "int reiserfs_resize(struct super_block *, unsigned long);",
      "void reiserfs_flush_old_commits(struct super_block *);",
      "int journal_release(struct reiserfs_transaction_handle *, struct super_block *);",
      "int journal_release_error(struct reiserfs_transaction_handle *,\n\t\t\t  struct super_block *);",
      "int journal_begin(struct reiserfs_transaction_handle *,\n\t\t  struct super_block *sb, unsigned long);",
      "int journal_join_abort(struct reiserfs_transaction_handle *,\n\t\t       struct super_block *sb);",
      "int reiserfs_convert_objectid_map_v1(struct super_block *);",
      "const struct reiserfs_key *get_rkey(const struct treepath *chk_path,\n\t\t\t\t    const struct super_block *sb);",
      "int reiserfs_parse_alloc_options(struct super_block *, char *);",
      "int reiserfs_init_bitmap_cache(struct super_block *sb);",
      "void reiserfs_free_bitmap_cache(struct super_block *sb);"
    ],
    "called_functions": [],
    "contextual_snippet": "#include <linux/buffer_head.h>\n#include <linux/proc_fs.h>\n#include <linux/bitops.h>\n#include <asm/unaligned.h>\n#include <linux/workqueue.h>\n#include <linux/bug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/slab.h>\n#include <linux/reiserfs_fs.h>\n\nint reiserfs_resize(struct super_block *, unsigned long);\nvoid reiserfs_flush_old_commits(struct super_block *);\nint journal_release(struct reiserfs_transaction_handle *, struct super_block *);\nint journal_release_error(struct reiserfs_transaction_handle *,\n\t\t\t  struct super_block *);\nint journal_begin(struct reiserfs_transaction_handle *,\n\t\t  struct super_block *sb, unsigned long);\nint journal_join_abort(struct reiserfs_transaction_handle *,\n\t\t       struct super_block *sb);\nint reiserfs_convert_objectid_map_v1(struct super_block *);\nconst struct reiserfs_key *get_rkey(const struct treepath *chk_path,\n\t\t\t\t    const struct super_block *sb);\nint reiserfs_parse_alloc_options(struct super_block *, char *);\nint reiserfs_init_bitmap_cache(struct super_block *sb);\nvoid reiserfs_free_bitmap_cache(struct super_block *sb);\n\nstatic inline int reiserfs_proc_info_init(struct super_block *sb)\n{\n\treturn 0;\n}"
  },
  {
    "function_name": "reiserfs_update_sd",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/reiserfs.h",
    "lines": "3096-3100",
    "snippet": "static inline void reiserfs_update_sd(struct reiserfs_transaction_handle *th,\n\t\t\t\t      struct inode *inode)\n{\n\treiserfs_update_sd_size(th, inode, inode->i_size);\n}",
    "includes": [
      "#include <linux/buffer_head.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/bitops.h>",
      "#include <asm/unaligned.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/bug.h>",
      "#include <linux/sched.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/slab.h>",
      "#include <linux/reiserfs_fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "int reiserfs_end_persistent_transaction(struct reiserfs_transaction_handle *);",
      "void reiserfs_vfs_truncate_file(struct inode *inode);",
      "int reiserfs_commit_for_inode(struct inode *);",
      "int reiserfs_inode_needs_commit(struct inode *);",
      "void reiserfs_update_inode_transaction(struct inode *);",
      "void reiserfs_block_writes(struct reiserfs_transaction_handle *th);",
      "int journal_end(struct reiserfs_transaction_handle *);",
      "int journal_end_sync(struct reiserfs_transaction_handle *);",
      "int journal_transaction_should_end(struct reiserfs_transaction_handle *, int);",
      "__u32 reiserfs_get_unused_objectid(struct reiserfs_transaction_handle *th);",
      "int reiserfs_delete_object(struct reiserfs_transaction_handle *th,\n\t\t\t   struct inode *inode);",
      "void reiserfs_evict_inode(struct inode *inode);",
      "void sd_attrs_to_i_attrs(__u16 sd_attrs, struct inode *inode);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "reiserfs_update_sd_size",
          "args": [
            "th",
            "inode",
            "inode->i_size"
          ],
          "line": 3099
        },
        "resolved": true,
        "details": {
          "function_name": "reiserfs_update_sd_size",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/inode.c",
          "lines": "1447-1511",
          "snippet": "void reiserfs_update_sd_size(struct reiserfs_transaction_handle *th,\n\t\t\t     struct inode *inode, loff_t size)\n{\n\tstruct cpu_key key;\n\tINITIALIZE_PATH(path);\n\tstruct buffer_head *bh;\n\tint fs_gen;\n\tstruct item_head *ih, tmp_ih;\n\tint retval;\n\n\tBUG_ON(!th->t_trans_id);\n\n\t/* key type is unimportant */\n\tmake_cpu_key(&key, inode, SD_OFFSET, TYPE_STAT_DATA, 3);\n\n\tfor (;;) {\n\t\tint pos;\n\t\t/* look for the object's stat data */\n\t\tretval = search_item(inode->i_sb, &key, &path);\n\t\tif (retval == IO_ERROR) {\n\t\t\treiserfs_error(inode->i_sb, \"vs-13050\",\n\t\t\t\t       \"i/o failure occurred trying to \"\n\t\t\t\t       \"update %K stat data\", &key);\n\t\t\treturn;\n\t\t}\n\t\tif (retval == ITEM_NOT_FOUND) {\n\t\t\tpos = PATH_LAST_POSITION(&path);\n\t\t\tpathrelse(&path);\n\t\t\tif (inode->i_nlink == 0) {\n\t\t\t\t/*reiserfs_warning (inode->i_sb, \"vs-13050: reiserfs_update_sd: i_nlink == 0, stat data not found\"); */\n\t\t\t\treturn;\n\t\t\t}\n\t\t\treiserfs_warning(inode->i_sb, \"vs-13060\",\n\t\t\t\t\t \"stat data of object %k (nlink == %d) \"\n\t\t\t\t\t \"not found (pos %d)\",\n\t\t\t\t\t INODE_PKEY(inode), inode->i_nlink,\n\t\t\t\t\t pos);\n\t\t\treiserfs_check_path(&path);\n\t\t\treturn;\n\t\t}\n\n\t\t/*\n\t\t * sigh, prepare_for_journal might schedule.  When it\n\t\t * schedules the FS might change.  We have to detect that,\n\t\t * and loop back to the search if the stat data item has moved\n\t\t */\n\t\tbh = get_last_bh(&path);\n\t\tih = tp_item_head(&path);\n\t\tcopy_item_head(&tmp_ih, ih);\n\t\tfs_gen = get_generation(inode->i_sb);\n\t\treiserfs_prepare_for_journal(inode->i_sb, bh, 1);\n\n\t\t/* Stat_data item has been moved after scheduling. */\n\t\tif (fs_changed(fs_gen, inode->i_sb)\n\t\t    && item_moved(&tmp_ih, &path)) {\n\t\t\treiserfs_restore_prepared_buffer(inode->i_sb, bh);\n\t\t\tcontinue;\n\t\t}\n\t\tbreak;\n\t}\n\tupdate_stat_data(&path, inode, size);\n\tjournal_mark_dirty(th, bh);\n\tpathrelse(&path);\n\treturn;\n}",
          "includes": [
            "#include <linux/aio.h>",
            "#include <linux/swap.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mpage.h>",
            "#include <linux/buffer_head.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/exportfs.h>",
            "#include \"xattr.h\"",
            "#include \"acl.h\"",
            "#include \"reiserfs.h\"",
            "#include <linux/fs.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int reiserfs_commit_write(struct file *f, struct page *page,\n\t\t\t  unsigned from, unsigned to);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/quotaops.h>\n#include <linux/writeback.h>\n#include <linux/mpage.h>\n#include <linux/buffer_head.h>\n#include <asm/unaligned.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/exportfs.h>\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"reiserfs.h\"\n#include <linux/fs.h>\n#include <linux/time.h>\n\nint reiserfs_commit_write(struct file *f, struct page *page,\n\t\t\t  unsigned from, unsigned to);\n\nvoid reiserfs_update_sd_size(struct reiserfs_transaction_handle *th,\n\t\t\t     struct inode *inode, loff_t size)\n{\n\tstruct cpu_key key;\n\tINITIALIZE_PATH(path);\n\tstruct buffer_head *bh;\n\tint fs_gen;\n\tstruct item_head *ih, tmp_ih;\n\tint retval;\n\n\tBUG_ON(!th->t_trans_id);\n\n\t/* key type is unimportant */\n\tmake_cpu_key(&key, inode, SD_OFFSET, TYPE_STAT_DATA, 3);\n\n\tfor (;;) {\n\t\tint pos;\n\t\t/* look for the object's stat data */\n\t\tretval = search_item(inode->i_sb, &key, &path);\n\t\tif (retval == IO_ERROR) {\n\t\t\treiserfs_error(inode->i_sb, \"vs-13050\",\n\t\t\t\t       \"i/o failure occurred trying to \"\n\t\t\t\t       \"update %K stat data\", &key);\n\t\t\treturn;\n\t\t}\n\t\tif (retval == ITEM_NOT_FOUND) {\n\t\t\tpos = PATH_LAST_POSITION(&path);\n\t\t\tpathrelse(&path);\n\t\t\tif (inode->i_nlink == 0) {\n\t\t\t\t/*reiserfs_warning (inode->i_sb, \"vs-13050: reiserfs_update_sd: i_nlink == 0, stat data not found\"); */\n\t\t\t\treturn;\n\t\t\t}\n\t\t\treiserfs_warning(inode->i_sb, \"vs-13060\",\n\t\t\t\t\t \"stat data of object %k (nlink == %d) \"\n\t\t\t\t\t \"not found (pos %d)\",\n\t\t\t\t\t INODE_PKEY(inode), inode->i_nlink,\n\t\t\t\t\t pos);\n\t\t\treiserfs_check_path(&path);\n\t\t\treturn;\n\t\t}\n\n\t\t/*\n\t\t * sigh, prepare_for_journal might schedule.  When it\n\t\t * schedules the FS might change.  We have to detect that,\n\t\t * and loop back to the search if the stat data item has moved\n\t\t */\n\t\tbh = get_last_bh(&path);\n\t\tih = tp_item_head(&path);\n\t\tcopy_item_head(&tmp_ih, ih);\n\t\tfs_gen = get_generation(inode->i_sb);\n\t\treiserfs_prepare_for_journal(inode->i_sb, bh, 1);\n\n\t\t/* Stat_data item has been moved after scheduling. */\n\t\tif (fs_changed(fs_gen, inode->i_sb)\n\t\t    && item_moved(&tmp_ih, &path)) {\n\t\t\treiserfs_restore_prepared_buffer(inode->i_sb, bh);\n\t\t\tcontinue;\n\t\t}\n\t\tbreak;\n\t}\n\tupdate_stat_data(&path, inode, size);\n\tjournal_mark_dirty(th, bh);\n\tpathrelse(&path);\n\treturn;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/buffer_head.h>\n#include <linux/proc_fs.h>\n#include <linux/bitops.h>\n#include <asm/unaligned.h>\n#include <linux/workqueue.h>\n#include <linux/bug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/slab.h>\n#include <linux/reiserfs_fs.h>\n\nint reiserfs_end_persistent_transaction(struct reiserfs_transaction_handle *);\nvoid reiserfs_vfs_truncate_file(struct inode *inode);\nint reiserfs_commit_for_inode(struct inode *);\nint reiserfs_inode_needs_commit(struct inode *);\nvoid reiserfs_update_inode_transaction(struct inode *);\nvoid reiserfs_block_writes(struct reiserfs_transaction_handle *th);\nint journal_end(struct reiserfs_transaction_handle *);\nint journal_end_sync(struct reiserfs_transaction_handle *);\nint journal_transaction_should_end(struct reiserfs_transaction_handle *, int);\n__u32 reiserfs_get_unused_objectid(struct reiserfs_transaction_handle *th);\nint reiserfs_delete_object(struct reiserfs_transaction_handle *th,\n\t\t\t   struct inode *inode);\nvoid reiserfs_evict_inode(struct inode *inode);\nvoid sd_attrs_to_i_attrs(__u16 sd_attrs, struct inode *inode);\n\nstatic inline void reiserfs_update_sd(struct reiserfs_transaction_handle *th,\n\t\t\t\t      struct inode *inode)\n{\n\treiserfs_update_sd_size(th, inode, inode->i_size);\n}"
  },
  {
    "function_name": "copy_key",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/reiserfs.h",
    "lines": "2993-2997",
    "snippet": "static inline void copy_key(struct reiserfs_key *to,\n\t\t\t    const struct reiserfs_key *from)\n{\n\tmemcpy(to, from, KEY_SIZE);\n}",
    "includes": [
      "#include <linux/buffer_head.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/bitops.h>",
      "#include <asm/unaligned.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/bug.h>",
      "#include <linux/sched.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/slab.h>",
      "#include <linux/reiserfs_fs.h>"
    ],
    "macros_used": [
      "#define KEY_SIZE (sizeof(struct reiserfs_key))"
    ],
    "globals_used": [
      "int reiserfs_commit_page(struct inode *inode, struct page *page,\n\t\t\t unsigned from, unsigned to);",
      "extern void copy_item_head(struct item_head *to,\n\t\t\t   const struct item_head *from);",
      "extern void le_key2cpu_key(struct cpu_key *to, const struct reiserfs_key *from);",
      "extern int comp_le_keys(const struct reiserfs_key *,\n\t\t\tconst struct reiserfs_key *);",
      "extern int comp_short_le_keys(const struct reiserfs_key *,\n\t\t\t      const struct reiserfs_key *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "to",
            "from",
            "KEY_SIZE"
          ],
          "line": 2996
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/buffer_head.h>\n#include <linux/proc_fs.h>\n#include <linux/bitops.h>\n#include <asm/unaligned.h>\n#include <linux/workqueue.h>\n#include <linux/bug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/slab.h>\n#include <linux/reiserfs_fs.h>\n\n#define KEY_SIZE (sizeof(struct reiserfs_key))\n\nint reiserfs_commit_page(struct inode *inode, struct page *page,\n\t\t\t unsigned from, unsigned to);\nextern void copy_item_head(struct item_head *to,\n\t\t\t   const struct item_head *from);\nextern void le_key2cpu_key(struct cpu_key *to, const struct reiserfs_key *from);\nextern int comp_le_keys(const struct reiserfs_key *,\n\t\t\tconst struct reiserfs_key *);\nextern int comp_short_le_keys(const struct reiserfs_key *,\n\t\t\t      const struct reiserfs_key *);\n\nstatic inline void copy_key(struct reiserfs_key *to,\n\t\t\t    const struct reiserfs_key *from)\n{\n\tmemcpy(to, from, KEY_SIZE);\n}"
  },
  {
    "function_name": "le_key_version",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/reiserfs.h",
    "lines": "2980-2991",
    "snippet": "static inline int le_key_version(const struct reiserfs_key *key)\n{\n\tint type;\n\n\ttype = offset_v2_k_type(&(key->u.k_offset_v2));\n\tif (type != TYPE_DIRECT && type != TYPE_INDIRECT\n\t    && type != TYPE_DIRENTRY)\n\t\treturn KEY_FORMAT_3_5;\n\n\treturn KEY_FORMAT_3_6;\n\n}",
    "includes": [
      "#include <linux/buffer_head.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/bitops.h>",
      "#include <asm/unaligned.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/bug.h>",
      "#include <linux/sched.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/slab.h>",
      "#include <linux/reiserfs_fs.h>"
    ],
    "macros_used": [
      "#define TYPE_DIRENTRY 3",
      "#define TYPE_DIRECT 2",
      "#define TYPE_INDIRECT 1",
      "#define KEY_FORMAT_3_6 1",
      "#define KEY_FORMAT_3_5 0"
    ],
    "globals_used": [
      "extern int comp_le_keys(const struct reiserfs_key *,\n\t\t\tconst struct reiserfs_key *);",
      "extern int comp_short_le_keys(const struct reiserfs_key *,\n\t\t\t      const struct reiserfs_key *);",
      "void reiserfs_delete_solid_item(struct reiserfs_transaction_handle *th,\n\t\t\t\tstruct inode *inode, struct reiserfs_key *key);",
      "struct inode *reiserfs_iget(struct super_block *s, const struct cpu_key *key);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "offset_v2_k_type",
          "args": [
            "&(key->u.k_offset_v2)"
          ],
          "line": 2984
        },
        "resolved": true,
        "details": {
          "function_name": "offset_v2_k_type",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/reiserfs.h",
          "lines": "1260-1264",
          "snippet": "static inline __u16 offset_v2_k_type(const struct offset_v2 *v2)\n{\n\t__u8 type = le64_to_cpu(v2->v) >> 60;\n\treturn (type <= TYPE_MAXTYPE) ? type : TYPE_ANY;\n}",
          "includes": [
            "#include <linux/buffer_head.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/bitops.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/slab.h>",
            "#include <linux/reiserfs_fs.h>"
          ],
          "macros_used": [
            "#define TYPE_ANY 15\t\t/* FIXME: comment is required */",
            "#define TYPE_MAXTYPE 3"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/buffer_head.h>\n#include <linux/proc_fs.h>\n#include <linux/bitops.h>\n#include <asm/unaligned.h>\n#include <linux/workqueue.h>\n#include <linux/bug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/slab.h>\n#include <linux/reiserfs_fs.h>\n\n#define TYPE_ANY 15\t\t/* FIXME: comment is required */\n#define TYPE_MAXTYPE 3\n\nstatic inline __u16 offset_v2_k_type(const struct offset_v2 *v2)\n{\n\t__u8 type = le64_to_cpu(v2->v) >> 60;\n\treturn (type <= TYPE_MAXTYPE) ? type : TYPE_ANY;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/buffer_head.h>\n#include <linux/proc_fs.h>\n#include <linux/bitops.h>\n#include <asm/unaligned.h>\n#include <linux/workqueue.h>\n#include <linux/bug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/slab.h>\n#include <linux/reiserfs_fs.h>\n\n#define TYPE_DIRENTRY 3\n#define TYPE_DIRECT 2\n#define TYPE_INDIRECT 1\n#define KEY_FORMAT_3_6 1\n#define KEY_FORMAT_3_5 0\n\nextern int comp_le_keys(const struct reiserfs_key *,\n\t\t\tconst struct reiserfs_key *);\nextern int comp_short_le_keys(const struct reiserfs_key *,\n\t\t\t      const struct reiserfs_key *);\nvoid reiserfs_delete_solid_item(struct reiserfs_transaction_handle *th,\n\t\t\t\tstruct inode *inode, struct reiserfs_key *key);\nstruct inode *reiserfs_iget(struct super_block *s, const struct cpu_key *key);\n\nstatic inline int le_key_version(const struct reiserfs_key *key)\n{\n\tint type;\n\n\ttype = offset_v2_k_type(&(key->u.k_offset_v2));\n\tif (type != TYPE_DIRECT && type != TYPE_INDIRECT\n\t    && type != TYPE_DIRENTRY)\n\t\treturn KEY_FORMAT_3_5;\n\n\treturn KEY_FORMAT_3_6;\n\n}"
  },
  {
    "function_name": "reiserfs_transaction_free_space",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/reiserfs.h",
    "lines": "2906-2909",
    "snippet": "static inline int reiserfs_transaction_free_space(struct reiserfs_transaction_handle *th)\n{\n\treturn th->t_blocks_allocated - th->t_blocks_logged;\n}",
    "includes": [
      "#include <linux/buffer_head.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/bitops.h>",
      "#include <asm/unaligned.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/bug.h>",
      "#include <linux/sched.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/slab.h>",
      "#include <linux/reiserfs_fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "int reiserfs_end_persistent_transaction(struct reiserfs_transaction_handle *);",
      "void reiserfs_block_writes(struct reiserfs_transaction_handle *th);",
      "int journal_end(struct reiserfs_transaction_handle *);",
      "int journal_end_sync(struct reiserfs_transaction_handle *);",
      "int journal_transaction_should_end(struct reiserfs_transaction_handle *, int);",
      "__u32 reiserfs_get_unused_objectid(struct reiserfs_transaction_handle *th);"
    ],
    "called_functions": [],
    "contextual_snippet": "#include <linux/buffer_head.h>\n#include <linux/proc_fs.h>\n#include <linux/bitops.h>\n#include <asm/unaligned.h>\n#include <linux/workqueue.h>\n#include <linux/bug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/slab.h>\n#include <linux/reiserfs_fs.h>\n\nint reiserfs_end_persistent_transaction(struct reiserfs_transaction_handle *);\nvoid reiserfs_block_writes(struct reiserfs_transaction_handle *th);\nint journal_end(struct reiserfs_transaction_handle *);\nint journal_end_sync(struct reiserfs_transaction_handle *);\nint journal_transaction_should_end(struct reiserfs_transaction_handle *, int);\n__u32 reiserfs_get_unused_objectid(struct reiserfs_transaction_handle *th);\n\nstatic inline int reiserfs_transaction_free_space(struct reiserfs_transaction_handle *th)\n{\n\treturn th->t_blocks_allocated - th->t_blocks_logged;\n}"
  },
  {
    "function_name": "reiserfs_transaction_running",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/reiserfs.h",
    "lines": "2896-2904",
    "snippet": "static inline int reiserfs_transaction_running(struct super_block *s)\n{\n\tstruct reiserfs_transaction_handle *th = current->journal_info;\n\tif (th && th->t_super == s)\n\t\treturn 1;\n\tif (th && th->t_super == NULL)\n\t\tBUG();\n\treturn 0;\n}",
    "includes": [
      "#include <linux/buffer_head.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/bitops.h>",
      "#include <asm/unaligned.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/bug.h>",
      "#include <linux/sched.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/slab.h>",
      "#include <linux/reiserfs_fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "int reiserfs_resize(struct super_block *, unsigned long);",
      "void reiserfs_write_lock(struct super_block *s);",
      "void reiserfs_write_unlock(struct super_block *s);",
      "int __must_check reiserfs_write_unlock_nested(struct super_block *s);",
      "int reiserfs_end_persistent_transaction(struct reiserfs_transaction_handle *);",
      "void reiserfs_flush_old_commits(struct super_block *);",
      "void reiserfs_wait_on_write_block(struct super_block *s);",
      "void reiserfs_block_writes(struct reiserfs_transaction_handle *th);",
      "void reiserfs_allow_writes(struct super_block *s);",
      "int journal_release(struct reiserfs_transaction_handle *, struct super_block *);",
      "int journal_release_error(struct reiserfs_transaction_handle *,\n\t\t\t  struct super_block *);",
      "int journal_end(struct reiserfs_transaction_handle *);",
      "int journal_end_sync(struct reiserfs_transaction_handle *);",
      "int journal_transaction_should_end(struct reiserfs_transaction_handle *, int);",
      "void reiserfs_schedule_old_flush(struct super_block *s);",
      "__u32 reiserfs_get_unused_objectid(struct reiserfs_transaction_handle *th);",
      "int reiserfs_convert_objectid_map_v1(struct super_block *);",
      "void print_objectid_map(struct super_block *s);",
      "void print_statistics(struct super_block *s);",
      "int reiserfs_parse_alloc_options(struct super_block *, char *);",
      "void reiserfs_init_alloc_options(struct super_block *s);",
      "void show_alloc_options(struct seq_file *seq, struct super_block *s);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "BUG",
          "args": [],
          "line": 2902
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/buffer_head.h>\n#include <linux/proc_fs.h>\n#include <linux/bitops.h>\n#include <asm/unaligned.h>\n#include <linux/workqueue.h>\n#include <linux/bug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/slab.h>\n#include <linux/reiserfs_fs.h>\n\nint reiserfs_resize(struct super_block *, unsigned long);\nvoid reiserfs_write_lock(struct super_block *s);\nvoid reiserfs_write_unlock(struct super_block *s);\nint __must_check reiserfs_write_unlock_nested(struct super_block *s);\nint reiserfs_end_persistent_transaction(struct reiserfs_transaction_handle *);\nvoid reiserfs_flush_old_commits(struct super_block *);\nvoid reiserfs_wait_on_write_block(struct super_block *s);\nvoid reiserfs_block_writes(struct reiserfs_transaction_handle *th);\nvoid reiserfs_allow_writes(struct super_block *s);\nint journal_release(struct reiserfs_transaction_handle *, struct super_block *);\nint journal_release_error(struct reiserfs_transaction_handle *,\n\t\t\t  struct super_block *);\nint journal_end(struct reiserfs_transaction_handle *);\nint journal_end_sync(struct reiserfs_transaction_handle *);\nint journal_transaction_should_end(struct reiserfs_transaction_handle *, int);\nvoid reiserfs_schedule_old_flush(struct super_block *s);\n__u32 reiserfs_get_unused_objectid(struct reiserfs_transaction_handle *th);\nint reiserfs_convert_objectid_map_v1(struct super_block *);\nvoid print_objectid_map(struct super_block *s);\nvoid print_statistics(struct super_block *s);\nint reiserfs_parse_alloc_options(struct super_block *, char *);\nvoid reiserfs_init_alloc_options(struct super_block *s);\nvoid show_alloc_options(struct seq_file *seq, struct super_block *s);\n\nstatic inline int reiserfs_transaction_running(struct super_block *s)\n{\n\tstruct reiserfs_transaction_handle *th = current->journal_info;\n\tif (th && th->t_super == s)\n\t\treturn 1;\n\tif (th && th->t_super == NULL)\n\t\tBUG();\n\treturn 0;\n}"
  },
  {
    "function_name": "reiserfs_file_data_log",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/reiserfs.h",
    "lines": "2888-2894",
    "snippet": "static inline int reiserfs_file_data_log(struct inode *inode)\n{\n\tif (reiserfs_data_log(inode->i_sb) ||\n\t    (REISERFS_I(inode)->i_flags & i_data_log))\n\t\treturn 1;\n\treturn 0;\n}",
    "includes": [
      "#include <linux/buffer_head.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/bitops.h>",
      "#include <asm/unaligned.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/bug.h>",
      "#include <linux/sched.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/slab.h>",
      "#include <linux/reiserfs_fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "void reiserfs_vfs_truncate_file(struct inode *inode);",
      "int reiserfs_commit_for_inode(struct inode *);",
      "int reiserfs_inode_needs_commit(struct inode *);",
      "void reiserfs_update_inode_transaction(struct inode *);",
      "int reiserfs_delete_object(struct reiserfs_transaction_handle *th,\n\t\t\t   struct inode *inode);",
      "void reiserfs_evict_inode(struct inode *inode);",
      "void sd_attrs_to_i_attrs(__u16 sd_attrs, struct inode *inode);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "REISERFS_I",
          "args": [
            "inode"
          ],
          "line": 2891
        },
        "resolved": true,
        "details": {
          "function_name": "REISERFS_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/reiserfs.h",
          "lines": "1147-1150",
          "snippet": "static inline struct reiserfs_inode_info *REISERFS_I(const struct inode *inode)\n{\n\treturn container_of(inode, struct reiserfs_inode_info, vfs_inode);\n}",
          "includes": [
            "#include <linux/buffer_head.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/bitops.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/slab.h>",
            "#include <linux/reiserfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void reiserfs_vfs_truncate_file(struct inode *inode);",
            "int reiserfs_commit_for_inode(struct inode *);",
            "int reiserfs_inode_needs_commit(struct inode *);",
            "void reiserfs_update_inode_transaction(struct inode *);",
            "int reiserfs_delete_object(struct reiserfs_transaction_handle *th,\n\t\t\t   struct inode *inode);",
            "void reiserfs_evict_inode(struct inode *inode);",
            "void sd_attrs_to_i_attrs(__u16 sd_attrs, struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/buffer_head.h>\n#include <linux/proc_fs.h>\n#include <linux/bitops.h>\n#include <asm/unaligned.h>\n#include <linux/workqueue.h>\n#include <linux/bug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/slab.h>\n#include <linux/reiserfs_fs.h>\n\nvoid reiserfs_vfs_truncate_file(struct inode *inode);\nint reiserfs_commit_for_inode(struct inode *);\nint reiserfs_inode_needs_commit(struct inode *);\nvoid reiserfs_update_inode_transaction(struct inode *);\nint reiserfs_delete_object(struct reiserfs_transaction_handle *th,\n\t\t\t   struct inode *inode);\nvoid reiserfs_evict_inode(struct inode *inode);\nvoid sd_attrs_to_i_attrs(__u16 sd_attrs, struct inode *inode);\n\nstatic inline struct reiserfs_inode_info *REISERFS_I(const struct inode *inode)\n{\n\treturn container_of(inode, struct reiserfs_inode_info, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "reiserfs_data_log",
          "args": [
            "inode->i_sb"
          ],
          "line": 2890
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/buffer_head.h>\n#include <linux/proc_fs.h>\n#include <linux/bitops.h>\n#include <asm/unaligned.h>\n#include <linux/workqueue.h>\n#include <linux/bug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/slab.h>\n#include <linux/reiserfs_fs.h>\n\nvoid reiserfs_vfs_truncate_file(struct inode *inode);\nint reiserfs_commit_for_inode(struct inode *);\nint reiserfs_inode_needs_commit(struct inode *);\nvoid reiserfs_update_inode_transaction(struct inode *);\nint reiserfs_delete_object(struct reiserfs_transaction_handle *th,\n\t\t\t   struct inode *inode);\nvoid reiserfs_evict_inode(struct inode *inode);\nvoid sd_attrs_to_i_attrs(__u16 sd_attrs, struct inode *inode);\n\nstatic inline int reiserfs_file_data_log(struct inode *inode)\n{\n\tif (reiserfs_data_log(inode->i_sb) ||\n\t    (REISERFS_I(inode)->i_flags & i_data_log))\n\t\treturn 1;\n\treturn 0;\n}"
  },
  {
    "function_name": "sb_from_bi",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/reiserfs.h",
    "lines": "2602-2605",
    "snippet": "static inline struct super_block *sb_from_bi(struct buffer_info *bi)\n{\n\treturn bi ? sb_from_tb(bi->tb) : NULL;\n}",
    "includes": [
      "#include <linux/buffer_head.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/bitops.h>",
      "#include <asm/unaligned.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/bug.h>",
      "#include <linux/sched.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/slab.h>",
      "#include <linux/reiserfs_fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "int reiserfs_resize(struct super_block *, unsigned long);",
      "void reiserfs_flush_old_commits(struct super_block *);",
      "int journal_release(struct reiserfs_transaction_handle *, struct super_block *);",
      "int journal_release_error(struct reiserfs_transaction_handle *,\n\t\t\t  struct super_block *);",
      "int reiserfs_convert_objectid_map_v1(struct super_block *);",
      "void store_print_tb(struct tree_balance *tb);",
      "void make_empty_node(struct buffer_info *);",
      "int reiserfs_parse_alloc_options(struct super_block *, char *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "sb_from_tb",
          "args": [
            "bi->tb"
          ],
          "line": 2604
        },
        "resolved": true,
        "details": {
          "function_name": "sb_from_tb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/reiserfs.h",
          "lines": "2597-2600",
          "snippet": "static inline struct super_block *sb_from_tb(struct tree_balance *tb)\n{\n\treturn tb ? tb->tb_sb : NULL;\n}",
          "includes": [
            "#include <linux/buffer_head.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/bitops.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/slab.h>",
            "#include <linux/reiserfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int reiserfs_resize(struct super_block *, unsigned long);",
            "void reiserfs_flush_old_commits(struct super_block *);",
            "int journal_release(struct reiserfs_transaction_handle *, struct super_block *);",
            "int journal_release_error(struct reiserfs_transaction_handle *,\n\t\t\t  struct super_block *);",
            "int reiserfs_convert_objectid_map_v1(struct super_block *);",
            "void unfix_nodes(struct tree_balance *);",
            "void store_print_tb(struct tree_balance *tb);",
            "struct buffer_head *get_FEB(struct tree_balance *);",
            "int reiserfs_parse_alloc_options(struct super_block *, char *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/buffer_head.h>\n#include <linux/proc_fs.h>\n#include <linux/bitops.h>\n#include <asm/unaligned.h>\n#include <linux/workqueue.h>\n#include <linux/bug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/slab.h>\n#include <linux/reiserfs_fs.h>\n\nint reiserfs_resize(struct super_block *, unsigned long);\nvoid reiserfs_flush_old_commits(struct super_block *);\nint journal_release(struct reiserfs_transaction_handle *, struct super_block *);\nint journal_release_error(struct reiserfs_transaction_handle *,\n\t\t\t  struct super_block *);\nint reiserfs_convert_objectid_map_v1(struct super_block *);\nvoid unfix_nodes(struct tree_balance *);\nvoid store_print_tb(struct tree_balance *tb);\nstruct buffer_head *get_FEB(struct tree_balance *);\nint reiserfs_parse_alloc_options(struct super_block *, char *);\n\nstatic inline struct super_block *sb_from_tb(struct tree_balance *tb)\n{\n\treturn tb ? tb->tb_sb : NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/buffer_head.h>\n#include <linux/proc_fs.h>\n#include <linux/bitops.h>\n#include <asm/unaligned.h>\n#include <linux/workqueue.h>\n#include <linux/bug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/slab.h>\n#include <linux/reiserfs_fs.h>\n\nint reiserfs_resize(struct super_block *, unsigned long);\nvoid reiserfs_flush_old_commits(struct super_block *);\nint journal_release(struct reiserfs_transaction_handle *, struct super_block *);\nint journal_release_error(struct reiserfs_transaction_handle *,\n\t\t\t  struct super_block *);\nint reiserfs_convert_objectid_map_v1(struct super_block *);\nvoid store_print_tb(struct tree_balance *tb);\nvoid make_empty_node(struct buffer_info *);\nint reiserfs_parse_alloc_options(struct super_block *, char *);\n\nstatic inline struct super_block *sb_from_bi(struct buffer_info *bi)\n{\n\treturn bi ? sb_from_tb(bi->tb) : NULL;\n}"
  },
  {
    "function_name": "sb_from_tb",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/reiserfs.h",
    "lines": "2597-2600",
    "snippet": "static inline struct super_block *sb_from_tb(struct tree_balance *tb)\n{\n\treturn tb ? tb->tb_sb : NULL;\n}",
    "includes": [
      "#include <linux/buffer_head.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/bitops.h>",
      "#include <asm/unaligned.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/bug.h>",
      "#include <linux/sched.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/slab.h>",
      "#include <linux/reiserfs_fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "int reiserfs_resize(struct super_block *, unsigned long);",
      "void reiserfs_flush_old_commits(struct super_block *);",
      "int journal_release(struct reiserfs_transaction_handle *, struct super_block *);",
      "int journal_release_error(struct reiserfs_transaction_handle *,\n\t\t\t  struct super_block *);",
      "int reiserfs_convert_objectid_map_v1(struct super_block *);",
      "void unfix_nodes(struct tree_balance *);",
      "void store_print_tb(struct tree_balance *tb);",
      "struct buffer_head *get_FEB(struct tree_balance *);",
      "int reiserfs_parse_alloc_options(struct super_block *, char *);"
    ],
    "called_functions": [],
    "contextual_snippet": "#include <linux/buffer_head.h>\n#include <linux/proc_fs.h>\n#include <linux/bitops.h>\n#include <asm/unaligned.h>\n#include <linux/workqueue.h>\n#include <linux/bug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/slab.h>\n#include <linux/reiserfs_fs.h>\n\nint reiserfs_resize(struct super_block *, unsigned long);\nvoid reiserfs_flush_old_commits(struct super_block *);\nint journal_release(struct reiserfs_transaction_handle *, struct super_block *);\nint journal_release_error(struct reiserfs_transaction_handle *,\n\t\t\t  struct super_block *);\nint reiserfs_convert_objectid_map_v1(struct super_block *);\nvoid unfix_nodes(struct tree_balance *);\nvoid store_print_tb(struct tree_balance *tb);\nstruct buffer_head *get_FEB(struct tree_balance *);\nint reiserfs_parse_alloc_options(struct super_block *, char *);\n\nstatic inline struct super_block *sb_from_tb(struct tree_balance *tb)\n{\n\treturn tb ? tb->tb_sb : NULL;\n}"
  },
  {
    "function_name": "max_reiserfs_offset",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/reiserfs.h",
    "lines": "2280-2286",
    "snippet": "static inline loff_t max_reiserfs_offset(struct inode *inode)\n{\n\tif (get_inode_item_key_version(inode) == KEY_FORMAT_3_5)\n\t\treturn (loff_t) U32_MAX;\n\n\treturn (loff_t) ((~(__u64) 0) >> 4);\n}",
    "includes": [
      "#include <linux/buffer_head.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/bitops.h>",
      "#include <asm/unaligned.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/bug.h>",
      "#include <linux/sched.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/slab.h>",
      "#include <linux/reiserfs_fs.h>"
    ],
    "macros_used": [
      "#define KEY_FORMAT_3_5 0"
    ],
    "globals_used": [
      "void reiserfs_vfs_truncate_file(struct inode *inode);",
      "int reiserfs_commit_for_inode(struct inode *);",
      "int reiserfs_inode_needs_commit(struct inode *);",
      "void reiserfs_update_inode_transaction(struct inode *);",
      "int reiserfs_delete_object(struct reiserfs_transaction_handle *th,\n\t\t\t   struct inode *inode);",
      "void reiserfs_evict_inode(struct inode *inode);",
      "void sd_attrs_to_i_attrs(__u16 sd_attrs, struct inode *inode);",
      "int direct2indirect(struct reiserfs_transaction_handle *, struct inode *,\n\t\t    struct treepath *, struct buffer_head *, loff_t);",
      "int indirect2direct(struct reiserfs_transaction_handle *, struct inode *,\n\t\t    struct page *, struct treepath *, const struct cpu_key *,\n\t\t    loff_t, char *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "",
          "args": [
            "(~(__u64) 0) >> 4"
          ],
          "line": 2285
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_inode_item_key_version",
          "args": [
            "inode"
          ],
          "line": 2282
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/buffer_head.h>\n#include <linux/proc_fs.h>\n#include <linux/bitops.h>\n#include <asm/unaligned.h>\n#include <linux/workqueue.h>\n#include <linux/bug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/slab.h>\n#include <linux/reiserfs_fs.h>\n\n#define KEY_FORMAT_3_5 0\n\nvoid reiserfs_vfs_truncate_file(struct inode *inode);\nint reiserfs_commit_for_inode(struct inode *);\nint reiserfs_inode_needs_commit(struct inode *);\nvoid reiserfs_update_inode_transaction(struct inode *);\nint reiserfs_delete_object(struct reiserfs_transaction_handle *th,\n\t\t\t   struct inode *inode);\nvoid reiserfs_evict_inode(struct inode *inode);\nvoid sd_attrs_to_i_attrs(__u16 sd_attrs, struct inode *inode);\nint direct2indirect(struct reiserfs_transaction_handle *, struct inode *,\n\t\t    struct treepath *, struct buffer_head *, loff_t);\nint indirect2direct(struct reiserfs_transaction_handle *, struct inode *,\n\t\t    struct page *, struct treepath *, const struct cpu_key *,\n\t\t    loff_t, char *);\n\nstatic inline loff_t max_reiserfs_offset(struct inode *inode)\n{\n\tif (get_inode_item_key_version(inode) == KEY_FORMAT_3_5)\n\t\treturn (loff_t) U32_MAX;\n\n\treturn (loff_t) ((~(__u64) 0) >> 4);\n}"
  },
  {
    "function_name": "entry_length",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/reiserfs.h",
    "lines": "2252-2262",
    "snippet": "static inline int entry_length(const struct buffer_head *bh,\n\t\t\t       const struct item_head *ih, int pos_in_item)\n{\n\tstruct reiserfs_de_head *deh;\n\n\tdeh = B_I_DEH(bh, ih) + pos_in_item;\n\tif (pos_in_item)\n\t\treturn deh_location(deh - 1) - deh_location(deh);\n\n\treturn ih_item_len(ih) - deh_location(deh);\n}",
    "includes": [
      "#include <linux/buffer_head.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/bitops.h>",
      "#include <asm/unaligned.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/bug.h>",
      "#include <linux/sched.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/slab.h>",
      "#include <linux/reiserfs_fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "void reiserfs_free_jh(struct buffer_head *bh);",
      "int reiserfs_add_tail_list(struct inode *inode, struct buffer_head *bh);",
      "int reiserfs_add_ordered_list(struct inode *inode, struct buffer_head *bh);",
      "int journal_mark_dirty(struct reiserfs_transaction_handle *,\n\t\t       struct buffer_head *bh);",
      "void reiserfs_restore_prepared_buffer(struct super_block *,\n\t\t\t\t      struct buffer_head *bh);",
      "int B_IS_IN_TREE(const struct buffer_head *);",
      "extern void decrement_bcount(struct buffer_head *bh);",
      "void reiserfs_unmap_buffer(struct buffer_head *);",
      "void print_block(struct buffer_head *bh, ...);",
      "void check_leaf(struct buffer_head *bh);",
      "void check_internal(struct buffer_head *bh);",
      "int balance_internal(struct tree_balance *, int, int, struct item_head *,\n\t\t     struct buffer_head **);",
      "void reiserfs_invalidate_buffer(struct tree_balance *tb,\n\t\t\t\tstruct buffer_head *bh);",
      "void replace_key(struct tree_balance *tb, struct buffer_head *, int,\n\t\t struct buffer_head *, int);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "deh_location",
          "args": [
            "deh"
          ],
          "line": 2261
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ih_item_len",
          "args": [
            "ih"
          ],
          "line": 2261
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "deh_location",
          "args": [
            "deh"
          ],
          "line": 2259
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "deh_location",
          "args": [
            "deh - 1"
          ],
          "line": 2259
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "B_I_DEH",
          "args": [
            "bh",
            "ih"
          ],
          "line": 2257
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/buffer_head.h>\n#include <linux/proc_fs.h>\n#include <linux/bitops.h>\n#include <asm/unaligned.h>\n#include <linux/workqueue.h>\n#include <linux/bug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/slab.h>\n#include <linux/reiserfs_fs.h>\n\nvoid reiserfs_free_jh(struct buffer_head *bh);\nint reiserfs_add_tail_list(struct inode *inode, struct buffer_head *bh);\nint reiserfs_add_ordered_list(struct inode *inode, struct buffer_head *bh);\nint journal_mark_dirty(struct reiserfs_transaction_handle *,\n\t\t       struct buffer_head *bh);\nvoid reiserfs_restore_prepared_buffer(struct super_block *,\n\t\t\t\t      struct buffer_head *bh);\nint B_IS_IN_TREE(const struct buffer_head *);\nextern void decrement_bcount(struct buffer_head *bh);\nvoid reiserfs_unmap_buffer(struct buffer_head *);\nvoid print_block(struct buffer_head *bh, ...);\nvoid check_leaf(struct buffer_head *bh);\nvoid check_internal(struct buffer_head *bh);\nint balance_internal(struct tree_balance *, int, int, struct item_head *,\n\t\t     struct buffer_head **);\nvoid reiserfs_invalidate_buffer(struct tree_balance *tb,\n\t\t\t\tstruct buffer_head *bh);\nvoid replace_key(struct tree_balance *tb, struct buffer_head *, int,\n\t\t struct buffer_head *, int);\n\nstatic inline int entry_length(const struct buffer_head *bh,\n\t\t\t       const struct item_head *ih, int pos_in_item)\n{\n\tstruct reiserfs_de_head *deh;\n\n\tdeh = B_I_DEH(bh, ih) + pos_in_item;\n\tif (pos_in_item)\n\t\treturn deh_location(deh - 1) - deh_location(deh);\n\n\treturn ih_item_len(ih) - deh_location(deh);\n}"
  },
  {
    "function_name": "tp_item_body",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/reiserfs.h",
    "lines": "2230-2233",
    "snippet": "static inline void *tp_item_body(const struct treepath *path)\n{\n\treturn item_body(PATH_PLAST_BUFFER(path), PATH_LAST_POSITION(path));\n}",
    "includes": [
      "#include <linux/buffer_head.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/bitops.h>",
      "#include <asm/unaligned.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/bug.h>",
      "#include <linux/sched.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/slab.h>",
      "#include <linux/reiserfs_fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "int comp_items(const struct item_head *stored_ih, const struct treepath *path);",
      "int search_by_key(struct super_block *, const struct cpu_key *,\n\t\t  struct treepath *, int);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "item_body",
          "args": [
            "PATH_PLAST_BUFFER(path)",
            "PATH_LAST_POSITION(path)"
          ],
          "line": 2232
        },
        "resolved": true,
        "details": {
          "function_name": "item_body",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/reiserfs.h",
          "lines": "2220-2223",
          "snippet": "static inline void *item_body(const struct buffer_head *bh, int item_num)\n{\n\treturn ih_item_body(bh, item_head(bh, item_num));\n}",
          "includes": [
            "#include <linux/buffer_head.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/bitops.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/slab.h>",
            "#include <linux/reiserfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void reiserfs_free_jh(struct buffer_head *bh);",
            "int reiserfs_add_tail_list(struct inode *inode, struct buffer_head *bh);",
            "int reiserfs_add_ordered_list(struct inode *inode, struct buffer_head *bh);",
            "int journal_mark_dirty(struct reiserfs_transaction_handle *,\n\t\t       struct buffer_head *bh);",
            "void reiserfs_restore_prepared_buffer(struct super_block *,\n\t\t\t\t      struct buffer_head *bh);",
            "int B_IS_IN_TREE(const struct buffer_head *);",
            "extern void decrement_bcount(struct buffer_head *bh);",
            "void reiserfs_unmap_buffer(struct buffer_head *);",
            "void print_indirect_item(struct buffer_head *bh, int item_num);",
            "void print_block(struct buffer_head *bh, ...);",
            "void check_leaf(struct buffer_head *bh);",
            "void check_internal(struct buffer_head *bh);",
            "int balance_internal(struct tree_balance *, int, int, struct item_head *,\n\t\t     struct buffer_head **);",
            "void reiserfs_invalidate_buffer(struct tree_balance *tb,\n\t\t\t\tstruct buffer_head *bh);",
            "void replace_key(struct tree_balance *tb, struct buffer_head *, int,\n\t\t struct buffer_head *, int);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/buffer_head.h>\n#include <linux/proc_fs.h>\n#include <linux/bitops.h>\n#include <asm/unaligned.h>\n#include <linux/workqueue.h>\n#include <linux/bug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/slab.h>\n#include <linux/reiserfs_fs.h>\n\nvoid reiserfs_free_jh(struct buffer_head *bh);\nint reiserfs_add_tail_list(struct inode *inode, struct buffer_head *bh);\nint reiserfs_add_ordered_list(struct inode *inode, struct buffer_head *bh);\nint journal_mark_dirty(struct reiserfs_transaction_handle *,\n\t\t       struct buffer_head *bh);\nvoid reiserfs_restore_prepared_buffer(struct super_block *,\n\t\t\t\t      struct buffer_head *bh);\nint B_IS_IN_TREE(const struct buffer_head *);\nextern void decrement_bcount(struct buffer_head *bh);\nvoid reiserfs_unmap_buffer(struct buffer_head *);\nvoid print_indirect_item(struct buffer_head *bh, int item_num);\nvoid print_block(struct buffer_head *bh, ...);\nvoid check_leaf(struct buffer_head *bh);\nvoid check_internal(struct buffer_head *bh);\nint balance_internal(struct tree_balance *, int, int, struct item_head *,\n\t\t     struct buffer_head **);\nvoid reiserfs_invalidate_buffer(struct tree_balance *tb,\n\t\t\t\tstruct buffer_head *bh);\nvoid replace_key(struct tree_balance *tb, struct buffer_head *, int,\n\t\t struct buffer_head *, int);\n\nstatic inline void *item_body(const struct buffer_head *bh, int item_num)\n{\n\treturn ih_item_body(bh, item_head(bh, item_num));\n}"
        }
      },
      {
        "call_info": {
          "callee": "PATH_LAST_POSITION",
          "args": [
            "path"
          ],
          "line": 2232
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PATH_PLAST_BUFFER",
          "args": [
            "path"
          ],
          "line": 2232
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/buffer_head.h>\n#include <linux/proc_fs.h>\n#include <linux/bitops.h>\n#include <asm/unaligned.h>\n#include <linux/workqueue.h>\n#include <linux/bug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/slab.h>\n#include <linux/reiserfs_fs.h>\n\nint comp_items(const struct item_head *stored_ih, const struct treepath *path);\nint search_by_key(struct super_block *, const struct cpu_key *,\n\t\t  struct treepath *, int);\n\nstatic inline void *tp_item_body(const struct treepath *path)\n{\n\treturn item_body(PATH_PLAST_BUFFER(path), PATH_LAST_POSITION(path));\n}"
  },
  {
    "function_name": "tp_item_head",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/reiserfs.h",
    "lines": "2225-2228",
    "snippet": "static inline struct item_head *tp_item_head(const struct treepath *path)\n{\n\treturn item_head(PATH_PLAST_BUFFER(path), PATH_LAST_POSITION(path));\n}",
    "includes": [
      "#include <linux/buffer_head.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/bitops.h>",
      "#include <asm/unaligned.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/bug.h>",
      "#include <linux/sched.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/slab.h>",
      "#include <linux/reiserfs_fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "int comp_items(const struct item_head *stored_ih, const struct treepath *path);",
      "int search_by_key(struct super_block *, const struct cpu_key *,\n\t\t  struct treepath *, int);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "item_head",
          "args": [
            "PATH_PLAST_BUFFER(path)",
            "PATH_LAST_POSITION(path)"
          ],
          "line": 2227
        },
        "resolved": true,
        "details": {
          "function_name": "item_head",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/reiserfs.h",
          "lines": "2198-2204",
          "snippet": "static inline struct item_head *item_head(const struct buffer_head *bh,\n\t\t\t\t\t  int item_num)\n{\n\tstruct item_head *ih = reiserfs_node_data(bh);\n\n\treturn &ih[item_num];\n}",
          "includes": [
            "#include <linux/buffer_head.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/bitops.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/slab.h>",
            "#include <linux/reiserfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void reiserfs_free_jh(struct buffer_head *bh);",
            "int reiserfs_add_tail_list(struct inode *inode, struct buffer_head *bh);",
            "int reiserfs_add_ordered_list(struct inode *inode, struct buffer_head *bh);",
            "int journal_mark_dirty(struct reiserfs_transaction_handle *,\n\t\t       struct buffer_head *bh);",
            "void reiserfs_restore_prepared_buffer(struct super_block *,\n\t\t\t\t      struct buffer_head *bh);",
            "int B_IS_IN_TREE(const struct buffer_head *);",
            "extern void decrement_bcount(struct buffer_head *bh);",
            "void reiserfs_unmap_buffer(struct buffer_head *);",
            "void print_indirect_item(struct buffer_head *bh, int item_num);",
            "void print_block(struct buffer_head *bh, ...);",
            "void check_leaf(struct buffer_head *bh);",
            "void check_internal(struct buffer_head *bh);",
            "int balance_internal(struct tree_balance *, int, int, struct item_head *,\n\t\t     struct buffer_head **);",
            "void reiserfs_invalidate_buffer(struct tree_balance *tb,\n\t\t\t\tstruct buffer_head *bh);",
            "void replace_key(struct tree_balance *tb, struct buffer_head *, int,\n\t\t struct buffer_head *, int);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/buffer_head.h>\n#include <linux/proc_fs.h>\n#include <linux/bitops.h>\n#include <asm/unaligned.h>\n#include <linux/workqueue.h>\n#include <linux/bug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/slab.h>\n#include <linux/reiserfs_fs.h>\n\nvoid reiserfs_free_jh(struct buffer_head *bh);\nint reiserfs_add_tail_list(struct inode *inode, struct buffer_head *bh);\nint reiserfs_add_ordered_list(struct inode *inode, struct buffer_head *bh);\nint journal_mark_dirty(struct reiserfs_transaction_handle *,\n\t\t       struct buffer_head *bh);\nvoid reiserfs_restore_prepared_buffer(struct super_block *,\n\t\t\t\t      struct buffer_head *bh);\nint B_IS_IN_TREE(const struct buffer_head *);\nextern void decrement_bcount(struct buffer_head *bh);\nvoid reiserfs_unmap_buffer(struct buffer_head *);\nvoid print_indirect_item(struct buffer_head *bh, int item_num);\nvoid print_block(struct buffer_head *bh, ...);\nvoid check_leaf(struct buffer_head *bh);\nvoid check_internal(struct buffer_head *bh);\nint balance_internal(struct tree_balance *, int, int, struct item_head *,\n\t\t     struct buffer_head **);\nvoid reiserfs_invalidate_buffer(struct tree_balance *tb,\n\t\t\t\tstruct buffer_head *bh);\nvoid replace_key(struct tree_balance *tb, struct buffer_head *, int,\n\t\t struct buffer_head *, int);\n\nstatic inline struct item_head *item_head(const struct buffer_head *bh,\n\t\t\t\t\t  int item_num)\n{\n\tstruct item_head *ih = reiserfs_node_data(bh);\n\n\treturn &ih[item_num];\n}"
        }
      },
      {
        "call_info": {
          "callee": "PATH_LAST_POSITION",
          "args": [
            "path"
          ],
          "line": 2227
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PATH_PLAST_BUFFER",
          "args": [
            "path"
          ],
          "line": 2227
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/buffer_head.h>\n#include <linux/proc_fs.h>\n#include <linux/bitops.h>\n#include <asm/unaligned.h>\n#include <linux/workqueue.h>\n#include <linux/bug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/slab.h>\n#include <linux/reiserfs_fs.h>\n\nint comp_items(const struct item_head *stored_ih, const struct treepath *path);\nint search_by_key(struct super_block *, const struct cpu_key *,\n\t\t  struct treepath *, int);\n\nstatic inline struct item_head *tp_item_head(const struct treepath *path)\n{\n\treturn item_head(PATH_PLAST_BUFFER(path), PATH_LAST_POSITION(path));\n}"
  },
  {
    "function_name": "item_body",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/reiserfs.h",
    "lines": "2220-2223",
    "snippet": "static inline void *item_body(const struct buffer_head *bh, int item_num)\n{\n\treturn ih_item_body(bh, item_head(bh, item_num));\n}",
    "includes": [
      "#include <linux/buffer_head.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/bitops.h>",
      "#include <asm/unaligned.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/bug.h>",
      "#include <linux/sched.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/slab.h>",
      "#include <linux/reiserfs_fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "void reiserfs_free_jh(struct buffer_head *bh);",
      "int reiserfs_add_tail_list(struct inode *inode, struct buffer_head *bh);",
      "int reiserfs_add_ordered_list(struct inode *inode, struct buffer_head *bh);",
      "int journal_mark_dirty(struct reiserfs_transaction_handle *,\n\t\t       struct buffer_head *bh);",
      "void reiserfs_restore_prepared_buffer(struct super_block *,\n\t\t\t\t      struct buffer_head *bh);",
      "int B_IS_IN_TREE(const struct buffer_head *);",
      "extern void decrement_bcount(struct buffer_head *bh);",
      "void reiserfs_unmap_buffer(struct buffer_head *);",
      "void print_indirect_item(struct buffer_head *bh, int item_num);",
      "void print_block(struct buffer_head *bh, ...);",
      "void check_leaf(struct buffer_head *bh);",
      "void check_internal(struct buffer_head *bh);",
      "int balance_internal(struct tree_balance *, int, int, struct item_head *,\n\t\t     struct buffer_head **);",
      "void reiserfs_invalidate_buffer(struct tree_balance *tb,\n\t\t\t\tstruct buffer_head *bh);",
      "void replace_key(struct tree_balance *tb, struct buffer_head *, int,\n\t\t struct buffer_head *, int);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ih_item_body",
          "args": [
            "bh",
            "item_head(bh, item_num)"
          ],
          "line": 2222
        },
        "resolved": true,
        "details": {
          "function_name": "ih_item_body",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/reiserfs.h",
          "lines": "2213-2217",
          "snippet": "static inline void *ih_item_body(const struct buffer_head *bh,\n\t\t\t\t const struct item_head *ih)\n{\n\treturn bh->b_data + ih_location(ih);\n}",
          "includes": [
            "#include <linux/buffer_head.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/bitops.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/slab.h>",
            "#include <linux/reiserfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void reiserfs_free_jh(struct buffer_head *bh);",
            "int reiserfs_add_tail_list(struct inode *inode, struct buffer_head *bh);",
            "int reiserfs_add_ordered_list(struct inode *inode, struct buffer_head *bh);",
            "int journal_mark_dirty(struct reiserfs_transaction_handle *,\n\t\t       struct buffer_head *bh);",
            "void reiserfs_restore_prepared_buffer(struct super_block *,\n\t\t\t\t      struct buffer_head *bh);",
            "int B_IS_IN_TREE(const struct buffer_head *);",
            "extern void decrement_bcount(struct buffer_head *bh);",
            "void reiserfs_unmap_buffer(struct buffer_head *);",
            "void print_block(struct buffer_head *bh, ...);",
            "void check_leaf(struct buffer_head *bh);",
            "void check_internal(struct buffer_head *bh);",
            "int balance_internal(struct tree_balance *, int, int, struct item_head *,\n\t\t     struct buffer_head **);",
            "void reiserfs_invalidate_buffer(struct tree_balance *tb,\n\t\t\t\tstruct buffer_head *bh);",
            "void replace_key(struct tree_balance *tb, struct buffer_head *, int,\n\t\t struct buffer_head *, int);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/buffer_head.h>\n#include <linux/proc_fs.h>\n#include <linux/bitops.h>\n#include <asm/unaligned.h>\n#include <linux/workqueue.h>\n#include <linux/bug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/slab.h>\n#include <linux/reiserfs_fs.h>\n\nvoid reiserfs_free_jh(struct buffer_head *bh);\nint reiserfs_add_tail_list(struct inode *inode, struct buffer_head *bh);\nint reiserfs_add_ordered_list(struct inode *inode, struct buffer_head *bh);\nint journal_mark_dirty(struct reiserfs_transaction_handle *,\n\t\t       struct buffer_head *bh);\nvoid reiserfs_restore_prepared_buffer(struct super_block *,\n\t\t\t\t      struct buffer_head *bh);\nint B_IS_IN_TREE(const struct buffer_head *);\nextern void decrement_bcount(struct buffer_head *bh);\nvoid reiserfs_unmap_buffer(struct buffer_head *);\nvoid print_block(struct buffer_head *bh, ...);\nvoid check_leaf(struct buffer_head *bh);\nvoid check_internal(struct buffer_head *bh);\nint balance_internal(struct tree_balance *, int, int, struct item_head *,\n\t\t     struct buffer_head **);\nvoid reiserfs_invalidate_buffer(struct tree_balance *tb,\n\t\t\t\tstruct buffer_head *bh);\nvoid replace_key(struct tree_balance *tb, struct buffer_head *, int,\n\t\t struct buffer_head *, int);\n\nstatic inline void *ih_item_body(const struct buffer_head *bh,\n\t\t\t\t const struct item_head *ih)\n{\n\treturn bh->b_data + ih_location(ih);\n}"
        }
      },
      {
        "call_info": {
          "callee": "item_head",
          "args": [
            "bh",
            "item_num"
          ],
          "line": 2222
        },
        "resolved": true,
        "details": {
          "function_name": "item_head",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/reiserfs.h",
          "lines": "2198-2204",
          "snippet": "static inline struct item_head *item_head(const struct buffer_head *bh,\n\t\t\t\t\t  int item_num)\n{\n\tstruct item_head *ih = reiserfs_node_data(bh);\n\n\treturn &ih[item_num];\n}",
          "includes": [
            "#include <linux/buffer_head.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/bitops.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/slab.h>",
            "#include <linux/reiserfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void reiserfs_free_jh(struct buffer_head *bh);",
            "int reiserfs_add_tail_list(struct inode *inode, struct buffer_head *bh);",
            "int reiserfs_add_ordered_list(struct inode *inode, struct buffer_head *bh);",
            "int journal_mark_dirty(struct reiserfs_transaction_handle *,\n\t\t       struct buffer_head *bh);",
            "void reiserfs_restore_prepared_buffer(struct super_block *,\n\t\t\t\t      struct buffer_head *bh);",
            "int B_IS_IN_TREE(const struct buffer_head *);",
            "extern void decrement_bcount(struct buffer_head *bh);",
            "void reiserfs_unmap_buffer(struct buffer_head *);",
            "void print_indirect_item(struct buffer_head *bh, int item_num);",
            "void print_block(struct buffer_head *bh, ...);",
            "void check_leaf(struct buffer_head *bh);",
            "void check_internal(struct buffer_head *bh);",
            "int balance_internal(struct tree_balance *, int, int, struct item_head *,\n\t\t     struct buffer_head **);",
            "void reiserfs_invalidate_buffer(struct tree_balance *tb,\n\t\t\t\tstruct buffer_head *bh);",
            "void replace_key(struct tree_balance *tb, struct buffer_head *, int,\n\t\t struct buffer_head *, int);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/buffer_head.h>\n#include <linux/proc_fs.h>\n#include <linux/bitops.h>\n#include <asm/unaligned.h>\n#include <linux/workqueue.h>\n#include <linux/bug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/slab.h>\n#include <linux/reiserfs_fs.h>\n\nvoid reiserfs_free_jh(struct buffer_head *bh);\nint reiserfs_add_tail_list(struct inode *inode, struct buffer_head *bh);\nint reiserfs_add_ordered_list(struct inode *inode, struct buffer_head *bh);\nint journal_mark_dirty(struct reiserfs_transaction_handle *,\n\t\t       struct buffer_head *bh);\nvoid reiserfs_restore_prepared_buffer(struct super_block *,\n\t\t\t\t      struct buffer_head *bh);\nint B_IS_IN_TREE(const struct buffer_head *);\nextern void decrement_bcount(struct buffer_head *bh);\nvoid reiserfs_unmap_buffer(struct buffer_head *);\nvoid print_indirect_item(struct buffer_head *bh, int item_num);\nvoid print_block(struct buffer_head *bh, ...);\nvoid check_leaf(struct buffer_head *bh);\nvoid check_internal(struct buffer_head *bh);\nint balance_internal(struct tree_balance *, int, int, struct item_head *,\n\t\t     struct buffer_head **);\nvoid reiserfs_invalidate_buffer(struct tree_balance *tb,\n\t\t\t\tstruct buffer_head *bh);\nvoid replace_key(struct tree_balance *tb, struct buffer_head *, int,\n\t\t struct buffer_head *, int);\n\nstatic inline struct item_head *item_head(const struct buffer_head *bh,\n\t\t\t\t\t  int item_num)\n{\n\tstruct item_head *ih = reiserfs_node_data(bh);\n\n\treturn &ih[item_num];\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/buffer_head.h>\n#include <linux/proc_fs.h>\n#include <linux/bitops.h>\n#include <asm/unaligned.h>\n#include <linux/workqueue.h>\n#include <linux/bug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/slab.h>\n#include <linux/reiserfs_fs.h>\n\nvoid reiserfs_free_jh(struct buffer_head *bh);\nint reiserfs_add_tail_list(struct inode *inode, struct buffer_head *bh);\nint reiserfs_add_ordered_list(struct inode *inode, struct buffer_head *bh);\nint journal_mark_dirty(struct reiserfs_transaction_handle *,\n\t\t       struct buffer_head *bh);\nvoid reiserfs_restore_prepared_buffer(struct super_block *,\n\t\t\t\t      struct buffer_head *bh);\nint B_IS_IN_TREE(const struct buffer_head *);\nextern void decrement_bcount(struct buffer_head *bh);\nvoid reiserfs_unmap_buffer(struct buffer_head *);\nvoid print_indirect_item(struct buffer_head *bh, int item_num);\nvoid print_block(struct buffer_head *bh, ...);\nvoid check_leaf(struct buffer_head *bh);\nvoid check_internal(struct buffer_head *bh);\nint balance_internal(struct tree_balance *, int, int, struct item_head *,\n\t\t     struct buffer_head **);\nvoid reiserfs_invalidate_buffer(struct tree_balance *tb,\n\t\t\t\tstruct buffer_head *bh);\nvoid replace_key(struct tree_balance *tb, struct buffer_head *, int,\n\t\t struct buffer_head *, int);\n\nstatic inline void *item_body(const struct buffer_head *bh, int item_num)\n{\n\treturn ih_item_body(bh, item_head(bh, item_num));\n}"
  },
  {
    "function_name": "ih_item_body",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/reiserfs.h",
    "lines": "2213-2217",
    "snippet": "static inline void *ih_item_body(const struct buffer_head *bh,\n\t\t\t\t const struct item_head *ih)\n{\n\treturn bh->b_data + ih_location(ih);\n}",
    "includes": [
      "#include <linux/buffer_head.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/bitops.h>",
      "#include <asm/unaligned.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/bug.h>",
      "#include <linux/sched.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/slab.h>",
      "#include <linux/reiserfs_fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "void reiserfs_free_jh(struct buffer_head *bh);",
      "int reiserfs_add_tail_list(struct inode *inode, struct buffer_head *bh);",
      "int reiserfs_add_ordered_list(struct inode *inode, struct buffer_head *bh);",
      "int journal_mark_dirty(struct reiserfs_transaction_handle *,\n\t\t       struct buffer_head *bh);",
      "void reiserfs_restore_prepared_buffer(struct super_block *,\n\t\t\t\t      struct buffer_head *bh);",
      "int B_IS_IN_TREE(const struct buffer_head *);",
      "extern void decrement_bcount(struct buffer_head *bh);",
      "void reiserfs_unmap_buffer(struct buffer_head *);",
      "void print_block(struct buffer_head *bh, ...);",
      "void check_leaf(struct buffer_head *bh);",
      "void check_internal(struct buffer_head *bh);",
      "int balance_internal(struct tree_balance *, int, int, struct item_head *,\n\t\t     struct buffer_head **);",
      "void reiserfs_invalidate_buffer(struct tree_balance *tb,\n\t\t\t\tstruct buffer_head *bh);",
      "void replace_key(struct tree_balance *tb, struct buffer_head *, int,\n\t\t struct buffer_head *, int);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ih_location",
          "args": [
            "ih"
          ],
          "line": 2216
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/buffer_head.h>\n#include <linux/proc_fs.h>\n#include <linux/bitops.h>\n#include <asm/unaligned.h>\n#include <linux/workqueue.h>\n#include <linux/bug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/slab.h>\n#include <linux/reiserfs_fs.h>\n\nvoid reiserfs_free_jh(struct buffer_head *bh);\nint reiserfs_add_tail_list(struct inode *inode, struct buffer_head *bh);\nint reiserfs_add_ordered_list(struct inode *inode, struct buffer_head *bh);\nint journal_mark_dirty(struct reiserfs_transaction_handle *,\n\t\t       struct buffer_head *bh);\nvoid reiserfs_restore_prepared_buffer(struct super_block *,\n\t\t\t\t      struct buffer_head *bh);\nint B_IS_IN_TREE(const struct buffer_head *);\nextern void decrement_bcount(struct buffer_head *bh);\nvoid reiserfs_unmap_buffer(struct buffer_head *);\nvoid print_block(struct buffer_head *bh, ...);\nvoid check_leaf(struct buffer_head *bh);\nvoid check_internal(struct buffer_head *bh);\nint balance_internal(struct tree_balance *, int, int, struct item_head *,\n\t\t     struct buffer_head **);\nvoid reiserfs_invalidate_buffer(struct tree_balance *tb,\n\t\t\t\tstruct buffer_head *bh);\nvoid replace_key(struct tree_balance *tb, struct buffer_head *, int,\n\t\t struct buffer_head *, int);\n\nstatic inline void *ih_item_body(const struct buffer_head *bh,\n\t\t\t\t const struct item_head *ih)\n{\n\treturn bh->b_data + ih_location(ih);\n}"
  },
  {
    "function_name": "leaf_key",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/reiserfs.h",
    "lines": "2207-2211",
    "snippet": "static inline struct reiserfs_key *leaf_key(const struct buffer_head *bh,\n\t\t\t\t\t    int item_num)\n{\n\treturn &item_head(bh, item_num)->ih_key;\n}",
    "includes": [
      "#include <linux/buffer_head.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/bitops.h>",
      "#include <asm/unaligned.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/bug.h>",
      "#include <linux/sched.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/slab.h>",
      "#include <linux/reiserfs_fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "void reiserfs_free_jh(struct buffer_head *bh);",
      "int reiserfs_add_tail_list(struct inode *inode, struct buffer_head *bh);",
      "int reiserfs_add_ordered_list(struct inode *inode, struct buffer_head *bh);",
      "int journal_mark_dirty(struct reiserfs_transaction_handle *,\n\t\t       struct buffer_head *bh);",
      "void reiserfs_restore_prepared_buffer(struct super_block *,\n\t\t\t\t      struct buffer_head *bh);",
      "int B_IS_IN_TREE(const struct buffer_head *);",
      "extern int comp_le_keys(const struct reiserfs_key *,\n\t\t\tconst struct reiserfs_key *);",
      "extern int comp_short_le_keys(const struct reiserfs_key *,\n\t\t\t      const struct reiserfs_key *);",
      "extern void decrement_bcount(struct buffer_head *bh);",
      "void reiserfs_unmap_buffer(struct buffer_head *);",
      "void print_indirect_item(struct buffer_head *bh, int item_num);",
      "void print_block(struct buffer_head *bh, ...);",
      "void check_leaf(struct buffer_head *bh);",
      "void check_internal(struct buffer_head *bh);",
      "int balance_internal(struct tree_balance *, int, int, struct item_head *,\n\t\t     struct buffer_head **);",
      "void reiserfs_invalidate_buffer(struct tree_balance *tb,\n\t\t\t\tstruct buffer_head *bh);",
      "void replace_key(struct tree_balance *tb, struct buffer_head *, int,\n\t\t struct buffer_head *, int);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "item_head",
          "args": [
            "bh",
            "item_num"
          ],
          "line": 2210
        },
        "resolved": true,
        "details": {
          "function_name": "item_head",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/reiserfs.h",
          "lines": "2198-2204",
          "snippet": "static inline struct item_head *item_head(const struct buffer_head *bh,\n\t\t\t\t\t  int item_num)\n{\n\tstruct item_head *ih = reiserfs_node_data(bh);\n\n\treturn &ih[item_num];\n}",
          "includes": [
            "#include <linux/buffer_head.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/bitops.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/slab.h>",
            "#include <linux/reiserfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void reiserfs_free_jh(struct buffer_head *bh);",
            "int reiserfs_add_tail_list(struct inode *inode, struct buffer_head *bh);",
            "int reiserfs_add_ordered_list(struct inode *inode, struct buffer_head *bh);",
            "int journal_mark_dirty(struct reiserfs_transaction_handle *,\n\t\t       struct buffer_head *bh);",
            "void reiserfs_restore_prepared_buffer(struct super_block *,\n\t\t\t\t      struct buffer_head *bh);",
            "int B_IS_IN_TREE(const struct buffer_head *);",
            "extern void decrement_bcount(struct buffer_head *bh);",
            "void reiserfs_unmap_buffer(struct buffer_head *);",
            "void print_indirect_item(struct buffer_head *bh, int item_num);",
            "void print_block(struct buffer_head *bh, ...);",
            "void check_leaf(struct buffer_head *bh);",
            "void check_internal(struct buffer_head *bh);",
            "int balance_internal(struct tree_balance *, int, int, struct item_head *,\n\t\t     struct buffer_head **);",
            "void reiserfs_invalidate_buffer(struct tree_balance *tb,\n\t\t\t\tstruct buffer_head *bh);",
            "void replace_key(struct tree_balance *tb, struct buffer_head *, int,\n\t\t struct buffer_head *, int);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/buffer_head.h>\n#include <linux/proc_fs.h>\n#include <linux/bitops.h>\n#include <asm/unaligned.h>\n#include <linux/workqueue.h>\n#include <linux/bug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/slab.h>\n#include <linux/reiserfs_fs.h>\n\nvoid reiserfs_free_jh(struct buffer_head *bh);\nint reiserfs_add_tail_list(struct inode *inode, struct buffer_head *bh);\nint reiserfs_add_ordered_list(struct inode *inode, struct buffer_head *bh);\nint journal_mark_dirty(struct reiserfs_transaction_handle *,\n\t\t       struct buffer_head *bh);\nvoid reiserfs_restore_prepared_buffer(struct super_block *,\n\t\t\t\t      struct buffer_head *bh);\nint B_IS_IN_TREE(const struct buffer_head *);\nextern void decrement_bcount(struct buffer_head *bh);\nvoid reiserfs_unmap_buffer(struct buffer_head *);\nvoid print_indirect_item(struct buffer_head *bh, int item_num);\nvoid print_block(struct buffer_head *bh, ...);\nvoid check_leaf(struct buffer_head *bh);\nvoid check_internal(struct buffer_head *bh);\nint balance_internal(struct tree_balance *, int, int, struct item_head *,\n\t\t     struct buffer_head **);\nvoid reiserfs_invalidate_buffer(struct tree_balance *tb,\n\t\t\t\tstruct buffer_head *bh);\nvoid replace_key(struct tree_balance *tb, struct buffer_head *, int,\n\t\t struct buffer_head *, int);\n\nstatic inline struct item_head *item_head(const struct buffer_head *bh,\n\t\t\t\t\t  int item_num)\n{\n\tstruct item_head *ih = reiserfs_node_data(bh);\n\n\treturn &ih[item_num];\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/buffer_head.h>\n#include <linux/proc_fs.h>\n#include <linux/bitops.h>\n#include <asm/unaligned.h>\n#include <linux/workqueue.h>\n#include <linux/bug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/slab.h>\n#include <linux/reiserfs_fs.h>\n\nvoid reiserfs_free_jh(struct buffer_head *bh);\nint reiserfs_add_tail_list(struct inode *inode, struct buffer_head *bh);\nint reiserfs_add_ordered_list(struct inode *inode, struct buffer_head *bh);\nint journal_mark_dirty(struct reiserfs_transaction_handle *,\n\t\t       struct buffer_head *bh);\nvoid reiserfs_restore_prepared_buffer(struct super_block *,\n\t\t\t\t      struct buffer_head *bh);\nint B_IS_IN_TREE(const struct buffer_head *);\nextern int comp_le_keys(const struct reiserfs_key *,\n\t\t\tconst struct reiserfs_key *);\nextern int comp_short_le_keys(const struct reiserfs_key *,\n\t\t\t      const struct reiserfs_key *);\nextern void decrement_bcount(struct buffer_head *bh);\nvoid reiserfs_unmap_buffer(struct buffer_head *);\nvoid print_indirect_item(struct buffer_head *bh, int item_num);\nvoid print_block(struct buffer_head *bh, ...);\nvoid check_leaf(struct buffer_head *bh);\nvoid check_internal(struct buffer_head *bh);\nint balance_internal(struct tree_balance *, int, int, struct item_head *,\n\t\t     struct buffer_head **);\nvoid reiserfs_invalidate_buffer(struct tree_balance *tb,\n\t\t\t\tstruct buffer_head *bh);\nvoid replace_key(struct tree_balance *tb, struct buffer_head *, int,\n\t\t struct buffer_head *, int);\n\nstatic inline struct reiserfs_key *leaf_key(const struct buffer_head *bh,\n\t\t\t\t\t    int item_num)\n{\n\treturn &item_head(bh, item_num)->ih_key;\n}"
  },
  {
    "function_name": "item_head",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/reiserfs.h",
    "lines": "2198-2204",
    "snippet": "static inline struct item_head *item_head(const struct buffer_head *bh,\n\t\t\t\t\t  int item_num)\n{\n\tstruct item_head *ih = reiserfs_node_data(bh);\n\n\treturn &ih[item_num];\n}",
    "includes": [
      "#include <linux/buffer_head.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/bitops.h>",
      "#include <asm/unaligned.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/bug.h>",
      "#include <linux/sched.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/slab.h>",
      "#include <linux/reiserfs_fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "void reiserfs_free_jh(struct buffer_head *bh);",
      "int reiserfs_add_tail_list(struct inode *inode, struct buffer_head *bh);",
      "int reiserfs_add_ordered_list(struct inode *inode, struct buffer_head *bh);",
      "int journal_mark_dirty(struct reiserfs_transaction_handle *,\n\t\t       struct buffer_head *bh);",
      "void reiserfs_restore_prepared_buffer(struct super_block *,\n\t\t\t\t      struct buffer_head *bh);",
      "int B_IS_IN_TREE(const struct buffer_head *);",
      "extern void decrement_bcount(struct buffer_head *bh);",
      "void reiserfs_unmap_buffer(struct buffer_head *);",
      "void print_indirect_item(struct buffer_head *bh, int item_num);",
      "void print_block(struct buffer_head *bh, ...);",
      "void check_leaf(struct buffer_head *bh);",
      "void check_internal(struct buffer_head *bh);",
      "int balance_internal(struct tree_balance *, int, int, struct item_head *,\n\t\t     struct buffer_head **);",
      "void reiserfs_invalidate_buffer(struct tree_balance *tb,\n\t\t\t\tstruct buffer_head *bh);",
      "void replace_key(struct tree_balance *tb, struct buffer_head *, int,\n\t\t struct buffer_head *, int);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "reiserfs_node_data",
          "args": [
            "bh"
          ],
          "line": 2201
        },
        "resolved": true,
        "details": {
          "function_name": "reiserfs_node_data",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/reiserfs.h",
          "lines": "2183-2186",
          "snippet": "static inline void *reiserfs_node_data(const struct buffer_head *bh)\n{\n\treturn bh->b_data + sizeof(struct block_head);\n}",
          "includes": [
            "#include <linux/buffer_head.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/bitops.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/slab.h>",
            "#include <linux/reiserfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void reiserfs_free_jh(struct buffer_head *bh);",
            "int reiserfs_add_tail_list(struct inode *inode, struct buffer_head *bh);",
            "int reiserfs_add_ordered_list(struct inode *inode, struct buffer_head *bh);",
            "int journal_mark_dirty(struct reiserfs_transaction_handle *,\n\t\t       struct buffer_head *bh);",
            "void reiserfs_restore_prepared_buffer(struct super_block *,\n\t\t\t\t      struct buffer_head *bh);",
            "int B_IS_IN_TREE(const struct buffer_head *);",
            "extern void decrement_bcount(struct buffer_head *bh);",
            "void reiserfs_unmap_buffer(struct buffer_head *);",
            "void print_block(struct buffer_head *bh, ...);",
            "void check_leaf(struct buffer_head *bh);",
            "void check_internal(struct buffer_head *bh);",
            "int balance_internal(struct tree_balance *, int, int, struct item_head *,\n\t\t     struct buffer_head **);",
            "void reiserfs_invalidate_buffer(struct tree_balance *tb,\n\t\t\t\tstruct buffer_head *bh);",
            "void replace_key(struct tree_balance *tb, struct buffer_head *, int,\n\t\t struct buffer_head *, int);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/buffer_head.h>\n#include <linux/proc_fs.h>\n#include <linux/bitops.h>\n#include <asm/unaligned.h>\n#include <linux/workqueue.h>\n#include <linux/bug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/slab.h>\n#include <linux/reiserfs_fs.h>\n\nvoid reiserfs_free_jh(struct buffer_head *bh);\nint reiserfs_add_tail_list(struct inode *inode, struct buffer_head *bh);\nint reiserfs_add_ordered_list(struct inode *inode, struct buffer_head *bh);\nint journal_mark_dirty(struct reiserfs_transaction_handle *,\n\t\t       struct buffer_head *bh);\nvoid reiserfs_restore_prepared_buffer(struct super_block *,\n\t\t\t\t      struct buffer_head *bh);\nint B_IS_IN_TREE(const struct buffer_head *);\nextern void decrement_bcount(struct buffer_head *bh);\nvoid reiserfs_unmap_buffer(struct buffer_head *);\nvoid print_block(struct buffer_head *bh, ...);\nvoid check_leaf(struct buffer_head *bh);\nvoid check_internal(struct buffer_head *bh);\nint balance_internal(struct tree_balance *, int, int, struct item_head *,\n\t\t     struct buffer_head **);\nvoid reiserfs_invalidate_buffer(struct tree_balance *tb,\n\t\t\t\tstruct buffer_head *bh);\nvoid replace_key(struct tree_balance *tb, struct buffer_head *, int,\n\t\t struct buffer_head *, int);\n\nstatic inline void *reiserfs_node_data(const struct buffer_head *bh)\n{\n\treturn bh->b_data + sizeof(struct block_head);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/buffer_head.h>\n#include <linux/proc_fs.h>\n#include <linux/bitops.h>\n#include <asm/unaligned.h>\n#include <linux/workqueue.h>\n#include <linux/bug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/slab.h>\n#include <linux/reiserfs_fs.h>\n\nvoid reiserfs_free_jh(struct buffer_head *bh);\nint reiserfs_add_tail_list(struct inode *inode, struct buffer_head *bh);\nint reiserfs_add_ordered_list(struct inode *inode, struct buffer_head *bh);\nint journal_mark_dirty(struct reiserfs_transaction_handle *,\n\t\t       struct buffer_head *bh);\nvoid reiserfs_restore_prepared_buffer(struct super_block *,\n\t\t\t\t      struct buffer_head *bh);\nint B_IS_IN_TREE(const struct buffer_head *);\nextern void decrement_bcount(struct buffer_head *bh);\nvoid reiserfs_unmap_buffer(struct buffer_head *);\nvoid print_indirect_item(struct buffer_head *bh, int item_num);\nvoid print_block(struct buffer_head *bh, ...);\nvoid check_leaf(struct buffer_head *bh);\nvoid check_internal(struct buffer_head *bh);\nint balance_internal(struct tree_balance *, int, int, struct item_head *,\n\t\t     struct buffer_head **);\nvoid reiserfs_invalidate_buffer(struct tree_balance *tb,\n\t\t\t\tstruct buffer_head *bh);\nvoid replace_key(struct tree_balance *tb, struct buffer_head *, int,\n\t\t struct buffer_head *, int);\n\nstatic inline struct item_head *item_head(const struct buffer_head *bh,\n\t\t\t\t\t  int item_num)\n{\n\tstruct item_head *ih = reiserfs_node_data(bh);\n\n\treturn &ih[item_num];\n}"
  },
  {
    "function_name": "internal_key",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/reiserfs.h",
    "lines": "2189-2195",
    "snippet": "static inline struct reiserfs_key *internal_key(struct buffer_head *bh,\n\t\t\t\t\t\tint item_num)\n{\n\tstruct reiserfs_key *key = reiserfs_node_data(bh);\n\n\treturn &key[item_num];\n}",
    "includes": [
      "#include <linux/buffer_head.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/bitops.h>",
      "#include <asm/unaligned.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/bug.h>",
      "#include <linux/sched.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/slab.h>",
      "#include <linux/reiserfs_fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "void reiserfs_free_jh(struct buffer_head *bh);",
      "int reiserfs_add_tail_list(struct inode *inode, struct buffer_head *bh);",
      "int reiserfs_add_ordered_list(struct inode *inode, struct buffer_head *bh);",
      "int journal_mark_dirty(struct reiserfs_transaction_handle *,\n\t\t       struct buffer_head *bh);",
      "void reiserfs_restore_prepared_buffer(struct super_block *,\n\t\t\t\t      struct buffer_head *bh);",
      "int B_IS_IN_TREE(const struct buffer_head *);",
      "extern int comp_le_keys(const struct reiserfs_key *,\n\t\t\tconst struct reiserfs_key *);",
      "extern int comp_short_le_keys(const struct reiserfs_key *,\n\t\t\t      const struct reiserfs_key *);",
      "extern void decrement_bcount(struct buffer_head *bh);",
      "void reiserfs_delete_solid_item(struct reiserfs_transaction_handle *th,\n\t\t\t\tstruct inode *inode, struct reiserfs_key *key);",
      "struct inode *reiserfs_iget(struct super_block *s, const struct cpu_key *key);",
      "void reiserfs_unmap_buffer(struct buffer_head *);",
      "void print_indirect_item(struct buffer_head *bh, int item_num);",
      "void print_block(struct buffer_head *bh, ...);",
      "void check_leaf(struct buffer_head *bh);",
      "void check_internal(struct buffer_head *bh);",
      "int balance_internal(struct tree_balance *, int, int, struct item_head *,\n\t\t     struct buffer_head **);",
      "void reiserfs_invalidate_buffer(struct tree_balance *tb,\n\t\t\t\tstruct buffer_head *bh);",
      "void replace_key(struct tree_balance *tb, struct buffer_head *, int,\n\t\t struct buffer_head *, int);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "reiserfs_node_data",
          "args": [
            "bh"
          ],
          "line": 2192
        },
        "resolved": true,
        "details": {
          "function_name": "reiserfs_node_data",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/reiserfs.h",
          "lines": "2183-2186",
          "snippet": "static inline void *reiserfs_node_data(const struct buffer_head *bh)\n{\n\treturn bh->b_data + sizeof(struct block_head);\n}",
          "includes": [
            "#include <linux/buffer_head.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/bitops.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/slab.h>",
            "#include <linux/reiserfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void reiserfs_free_jh(struct buffer_head *bh);",
            "int reiserfs_add_tail_list(struct inode *inode, struct buffer_head *bh);",
            "int reiserfs_add_ordered_list(struct inode *inode, struct buffer_head *bh);",
            "int journal_mark_dirty(struct reiserfs_transaction_handle *,\n\t\t       struct buffer_head *bh);",
            "void reiserfs_restore_prepared_buffer(struct super_block *,\n\t\t\t\t      struct buffer_head *bh);",
            "int B_IS_IN_TREE(const struct buffer_head *);",
            "extern void decrement_bcount(struct buffer_head *bh);",
            "void reiserfs_unmap_buffer(struct buffer_head *);",
            "void print_block(struct buffer_head *bh, ...);",
            "void check_leaf(struct buffer_head *bh);",
            "void check_internal(struct buffer_head *bh);",
            "int balance_internal(struct tree_balance *, int, int, struct item_head *,\n\t\t     struct buffer_head **);",
            "void reiserfs_invalidate_buffer(struct tree_balance *tb,\n\t\t\t\tstruct buffer_head *bh);",
            "void replace_key(struct tree_balance *tb, struct buffer_head *, int,\n\t\t struct buffer_head *, int);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/buffer_head.h>\n#include <linux/proc_fs.h>\n#include <linux/bitops.h>\n#include <asm/unaligned.h>\n#include <linux/workqueue.h>\n#include <linux/bug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/slab.h>\n#include <linux/reiserfs_fs.h>\n\nvoid reiserfs_free_jh(struct buffer_head *bh);\nint reiserfs_add_tail_list(struct inode *inode, struct buffer_head *bh);\nint reiserfs_add_ordered_list(struct inode *inode, struct buffer_head *bh);\nint journal_mark_dirty(struct reiserfs_transaction_handle *,\n\t\t       struct buffer_head *bh);\nvoid reiserfs_restore_prepared_buffer(struct super_block *,\n\t\t\t\t      struct buffer_head *bh);\nint B_IS_IN_TREE(const struct buffer_head *);\nextern void decrement_bcount(struct buffer_head *bh);\nvoid reiserfs_unmap_buffer(struct buffer_head *);\nvoid print_block(struct buffer_head *bh, ...);\nvoid check_leaf(struct buffer_head *bh);\nvoid check_internal(struct buffer_head *bh);\nint balance_internal(struct tree_balance *, int, int, struct item_head *,\n\t\t     struct buffer_head **);\nvoid reiserfs_invalidate_buffer(struct tree_balance *tb,\n\t\t\t\tstruct buffer_head *bh);\nvoid replace_key(struct tree_balance *tb, struct buffer_head *, int,\n\t\t struct buffer_head *, int);\n\nstatic inline void *reiserfs_node_data(const struct buffer_head *bh)\n{\n\treturn bh->b_data + sizeof(struct block_head);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/buffer_head.h>\n#include <linux/proc_fs.h>\n#include <linux/bitops.h>\n#include <asm/unaligned.h>\n#include <linux/workqueue.h>\n#include <linux/bug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/slab.h>\n#include <linux/reiserfs_fs.h>\n\nvoid reiserfs_free_jh(struct buffer_head *bh);\nint reiserfs_add_tail_list(struct inode *inode, struct buffer_head *bh);\nint reiserfs_add_ordered_list(struct inode *inode, struct buffer_head *bh);\nint journal_mark_dirty(struct reiserfs_transaction_handle *,\n\t\t       struct buffer_head *bh);\nvoid reiserfs_restore_prepared_buffer(struct super_block *,\n\t\t\t\t      struct buffer_head *bh);\nint B_IS_IN_TREE(const struct buffer_head *);\nextern int comp_le_keys(const struct reiserfs_key *,\n\t\t\tconst struct reiserfs_key *);\nextern int comp_short_le_keys(const struct reiserfs_key *,\n\t\t\t      const struct reiserfs_key *);\nextern void decrement_bcount(struct buffer_head *bh);\nvoid reiserfs_delete_solid_item(struct reiserfs_transaction_handle *th,\n\t\t\t\tstruct inode *inode, struct reiserfs_key *key);\nstruct inode *reiserfs_iget(struct super_block *s, const struct cpu_key *key);\nvoid reiserfs_unmap_buffer(struct buffer_head *);\nvoid print_indirect_item(struct buffer_head *bh, int item_num);\nvoid print_block(struct buffer_head *bh, ...);\nvoid check_leaf(struct buffer_head *bh);\nvoid check_internal(struct buffer_head *bh);\nint balance_internal(struct tree_balance *, int, int, struct item_head *,\n\t\t     struct buffer_head **);\nvoid reiserfs_invalidate_buffer(struct tree_balance *tb,\n\t\t\t\tstruct buffer_head *bh);\nvoid replace_key(struct tree_balance *tb, struct buffer_head *, int,\n\t\t struct buffer_head *, int);\n\nstatic inline struct reiserfs_key *internal_key(struct buffer_head *bh,\n\t\t\t\t\t\tint item_num)\n{\n\tstruct reiserfs_key *key = reiserfs_node_data(bh);\n\n\treturn &key[item_num];\n}"
  },
  {
    "function_name": "reiserfs_node_data",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/reiserfs.h",
    "lines": "2183-2186",
    "snippet": "static inline void *reiserfs_node_data(const struct buffer_head *bh)\n{\n\treturn bh->b_data + sizeof(struct block_head);\n}",
    "includes": [
      "#include <linux/buffer_head.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/bitops.h>",
      "#include <asm/unaligned.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/bug.h>",
      "#include <linux/sched.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/slab.h>",
      "#include <linux/reiserfs_fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "void reiserfs_free_jh(struct buffer_head *bh);",
      "int reiserfs_add_tail_list(struct inode *inode, struct buffer_head *bh);",
      "int reiserfs_add_ordered_list(struct inode *inode, struct buffer_head *bh);",
      "int journal_mark_dirty(struct reiserfs_transaction_handle *,\n\t\t       struct buffer_head *bh);",
      "void reiserfs_restore_prepared_buffer(struct super_block *,\n\t\t\t\t      struct buffer_head *bh);",
      "int B_IS_IN_TREE(const struct buffer_head *);",
      "extern void decrement_bcount(struct buffer_head *bh);",
      "void reiserfs_unmap_buffer(struct buffer_head *);",
      "void print_block(struct buffer_head *bh, ...);",
      "void check_leaf(struct buffer_head *bh);",
      "void check_internal(struct buffer_head *bh);",
      "int balance_internal(struct tree_balance *, int, int, struct item_head *,\n\t\t     struct buffer_head **);",
      "void reiserfs_invalidate_buffer(struct tree_balance *tb,\n\t\t\t\tstruct buffer_head *bh);",
      "void replace_key(struct tree_balance *tb, struct buffer_head *, int,\n\t\t struct buffer_head *, int);"
    ],
    "called_functions": [],
    "contextual_snippet": "#include <linux/buffer_head.h>\n#include <linux/proc_fs.h>\n#include <linux/bitops.h>\n#include <asm/unaligned.h>\n#include <linux/workqueue.h>\n#include <linux/bug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/slab.h>\n#include <linux/reiserfs_fs.h>\n\nvoid reiserfs_free_jh(struct buffer_head *bh);\nint reiserfs_add_tail_list(struct inode *inode, struct buffer_head *bh);\nint reiserfs_add_ordered_list(struct inode *inode, struct buffer_head *bh);\nint journal_mark_dirty(struct reiserfs_transaction_handle *,\n\t\t       struct buffer_head *bh);\nvoid reiserfs_restore_prepared_buffer(struct super_block *,\n\t\t\t\t      struct buffer_head *bh);\nint B_IS_IN_TREE(const struct buffer_head *);\nextern void decrement_bcount(struct buffer_head *bh);\nvoid reiserfs_unmap_buffer(struct buffer_head *);\nvoid print_block(struct buffer_head *bh, ...);\nvoid check_leaf(struct buffer_head *bh);\nvoid check_internal(struct buffer_head *bh);\nint balance_internal(struct tree_balance *, int, int, struct item_head *,\n\t\t     struct buffer_head **);\nvoid reiserfs_invalidate_buffer(struct tree_balance *tb,\n\t\t\t\tstruct buffer_head *bh);\nvoid replace_key(struct tree_balance *tb, struct buffer_head *, int,\n\t\t struct buffer_head *, int);\n\nstatic inline void *reiserfs_node_data(const struct buffer_head *bh)\n{\n\treturn bh->b_data + sizeof(struct block_head);\n}"
  },
  {
    "function_name": "cpu_key_k_offset_dec",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/reiserfs.h",
    "lines": "1603-1606",
    "snippet": "static inline void cpu_key_k_offset_dec(struct cpu_key *key)\n{\n\tkey->on_disk_key.k_offset--;\n}",
    "includes": [
      "#include <linux/buffer_head.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/bitops.h>",
      "#include <asm/unaligned.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/bug.h>",
      "#include <linux/sched.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/slab.h>",
      "#include <linux/reiserfs_fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "extern int comp_short_keys(const struct reiserfs_key *le_key,\n\t\t\t   const struct cpu_key *cpu_key);",
      "void reiserfs_delete_solid_item(struct reiserfs_transaction_handle *th,\n\t\t\t\tstruct inode *inode, struct reiserfs_key *key);",
      "struct inode *reiserfs_iget(struct super_block *s, const struct cpu_key *key);"
    ],
    "called_functions": [],
    "contextual_snippet": "#include <linux/buffer_head.h>\n#include <linux/proc_fs.h>\n#include <linux/bitops.h>\n#include <asm/unaligned.h>\n#include <linux/workqueue.h>\n#include <linux/bug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/slab.h>\n#include <linux/reiserfs_fs.h>\n\nextern int comp_short_keys(const struct reiserfs_key *le_key,\n\t\t\t   const struct cpu_key *cpu_key);\nvoid reiserfs_delete_solid_item(struct reiserfs_transaction_handle *th,\n\t\t\t\tstruct inode *inode, struct reiserfs_key *key);\nstruct inode *reiserfs_iget(struct super_block *s, const struct cpu_key *key);\n\nstatic inline void cpu_key_k_offset_dec(struct cpu_key *key)\n{\n\tkey->on_disk_key.k_offset--;\n}"
  },
  {
    "function_name": "set_cpu_key_k_type",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/reiserfs.h",
    "lines": "1598-1601",
    "snippet": "static inline void set_cpu_key_k_type(struct cpu_key *key, int type)\n{\n\tkey->on_disk_key.k_type = type;\n}",
    "includes": [
      "#include <linux/buffer_head.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/bitops.h>",
      "#include <asm/unaligned.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/bug.h>",
      "#include <linux/sched.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/slab.h>",
      "#include <linux/reiserfs_fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "extern int comp_short_keys(const struct reiserfs_key *le_key,\n\t\t\t   const struct cpu_key *cpu_key);",
      "void reiserfs_delete_solid_item(struct reiserfs_transaction_handle *th,\n\t\t\t\tstruct inode *inode, struct reiserfs_key *key);",
      "struct inode *reiserfs_iget(struct super_block *s, const struct cpu_key *key);"
    ],
    "called_functions": [],
    "contextual_snippet": "#include <linux/buffer_head.h>\n#include <linux/proc_fs.h>\n#include <linux/bitops.h>\n#include <asm/unaligned.h>\n#include <linux/workqueue.h>\n#include <linux/bug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/slab.h>\n#include <linux/reiserfs_fs.h>\n\nextern int comp_short_keys(const struct reiserfs_key *le_key,\n\t\t\t   const struct cpu_key *cpu_key);\nvoid reiserfs_delete_solid_item(struct reiserfs_transaction_handle *th,\n\t\t\t\tstruct inode *inode, struct reiserfs_key *key);\nstruct inode *reiserfs_iget(struct super_block *s, const struct cpu_key *key);\n\nstatic inline void set_cpu_key_k_type(struct cpu_key *key, int type)\n{\n\tkey->on_disk_key.k_type = type;\n}"
  },
  {
    "function_name": "set_cpu_key_k_offset",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/reiserfs.h",
    "lines": "1593-1596",
    "snippet": "static inline void set_cpu_key_k_offset(struct cpu_key *key, loff_t offset)\n{\n\tkey->on_disk_key.k_offset = offset;\n}",
    "includes": [
      "#include <linux/buffer_head.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/bitops.h>",
      "#include <asm/unaligned.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/bug.h>",
      "#include <linux/sched.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/slab.h>",
      "#include <linux/reiserfs_fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "extern int comp_short_keys(const struct reiserfs_key *le_key,\n\t\t\t   const struct cpu_key *cpu_key);",
      "void reiserfs_delete_solid_item(struct reiserfs_transaction_handle *th,\n\t\t\t\tstruct inode *inode, struct reiserfs_key *key);",
      "struct inode *reiserfs_iget(struct super_block *s, const struct cpu_key *key);",
      "int direct2indirect(struct reiserfs_transaction_handle *, struct inode *,\n\t\t    struct treepath *, struct buffer_head *, loff_t);",
      "int indirect2direct(struct reiserfs_transaction_handle *, struct inode *,\n\t\t    struct page *, struct treepath *, const struct cpu_key *,\n\t\t    loff_t, char *);"
    ],
    "called_functions": [],
    "contextual_snippet": "#include <linux/buffer_head.h>\n#include <linux/proc_fs.h>\n#include <linux/bitops.h>\n#include <asm/unaligned.h>\n#include <linux/workqueue.h>\n#include <linux/bug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/slab.h>\n#include <linux/reiserfs_fs.h>\n\nextern int comp_short_keys(const struct reiserfs_key *le_key,\n\t\t\t   const struct cpu_key *cpu_key);\nvoid reiserfs_delete_solid_item(struct reiserfs_transaction_handle *th,\n\t\t\t\tstruct inode *inode, struct reiserfs_key *key);\nstruct inode *reiserfs_iget(struct super_block *s, const struct cpu_key *key);\nint direct2indirect(struct reiserfs_transaction_handle *, struct inode *,\n\t\t    struct treepath *, struct buffer_head *, loff_t);\nint indirect2direct(struct reiserfs_transaction_handle *, struct inode *,\n\t\t    struct page *, struct treepath *, const struct cpu_key *,\n\t\t    loff_t, char *);\n\nstatic inline void set_cpu_key_k_offset(struct cpu_key *key, loff_t offset)\n{\n\tkey->on_disk_key.k_offset = offset;\n}"
  },
  {
    "function_name": "cpu_key_k_type",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/reiserfs.h",
    "lines": "1588-1591",
    "snippet": "static inline loff_t cpu_key_k_type(const struct cpu_key *key)\n{\n\treturn key->on_disk_key.k_type;\n}",
    "includes": [
      "#include <linux/buffer_head.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/bitops.h>",
      "#include <asm/unaligned.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/bug.h>",
      "#include <linux/sched.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/slab.h>",
      "#include <linux/reiserfs_fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "extern int comp_short_keys(const struct reiserfs_key *le_key,\n\t\t\t   const struct cpu_key *cpu_key);",
      "void reiserfs_delete_solid_item(struct reiserfs_transaction_handle *th,\n\t\t\t\tstruct inode *inode, struct reiserfs_key *key);",
      "struct inode *reiserfs_iget(struct super_block *s, const struct cpu_key *key);",
      "int direct2indirect(struct reiserfs_transaction_handle *, struct inode *,\n\t\t    struct treepath *, struct buffer_head *, loff_t);",
      "int indirect2direct(struct reiserfs_transaction_handle *, struct inode *,\n\t\t    struct page *, struct treepath *, const struct cpu_key *,\n\t\t    loff_t, char *);"
    ],
    "called_functions": [],
    "contextual_snippet": "#include <linux/buffer_head.h>\n#include <linux/proc_fs.h>\n#include <linux/bitops.h>\n#include <asm/unaligned.h>\n#include <linux/workqueue.h>\n#include <linux/bug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/slab.h>\n#include <linux/reiserfs_fs.h>\n\nextern int comp_short_keys(const struct reiserfs_key *le_key,\n\t\t\t   const struct cpu_key *cpu_key);\nvoid reiserfs_delete_solid_item(struct reiserfs_transaction_handle *th,\n\t\t\t\tstruct inode *inode, struct reiserfs_key *key);\nstruct inode *reiserfs_iget(struct super_block *s, const struct cpu_key *key);\nint direct2indirect(struct reiserfs_transaction_handle *, struct inode *,\n\t\t    struct treepath *, struct buffer_head *, loff_t);\nint indirect2direct(struct reiserfs_transaction_handle *, struct inode *,\n\t\t    struct page *, struct treepath *, const struct cpu_key *,\n\t\t    loff_t, char *);\n\nstatic inline loff_t cpu_key_k_type(const struct cpu_key *key)\n{\n\treturn key->on_disk_key.k_type;\n}"
  },
  {
    "function_name": "cpu_key_k_offset",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/reiserfs.h",
    "lines": "1583-1586",
    "snippet": "static inline loff_t cpu_key_k_offset(const struct cpu_key *key)\n{\n\treturn key->on_disk_key.k_offset;\n}",
    "includes": [
      "#include <linux/buffer_head.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/bitops.h>",
      "#include <asm/unaligned.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/bug.h>",
      "#include <linux/sched.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/slab.h>",
      "#include <linux/reiserfs_fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "extern int comp_short_keys(const struct reiserfs_key *le_key,\n\t\t\t   const struct cpu_key *cpu_key);",
      "void reiserfs_delete_solid_item(struct reiserfs_transaction_handle *th,\n\t\t\t\tstruct inode *inode, struct reiserfs_key *key);",
      "struct inode *reiserfs_iget(struct super_block *s, const struct cpu_key *key);",
      "int direct2indirect(struct reiserfs_transaction_handle *, struct inode *,\n\t\t    struct treepath *, struct buffer_head *, loff_t);",
      "int indirect2direct(struct reiserfs_transaction_handle *, struct inode *,\n\t\t    struct page *, struct treepath *, const struct cpu_key *,\n\t\t    loff_t, char *);"
    ],
    "called_functions": [],
    "contextual_snippet": "#include <linux/buffer_head.h>\n#include <linux/proc_fs.h>\n#include <linux/bitops.h>\n#include <asm/unaligned.h>\n#include <linux/workqueue.h>\n#include <linux/bug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/slab.h>\n#include <linux/reiserfs_fs.h>\n\nextern int comp_short_keys(const struct reiserfs_key *le_key,\n\t\t\t   const struct cpu_key *cpu_key);\nvoid reiserfs_delete_solid_item(struct reiserfs_transaction_handle *th,\n\t\t\t\tstruct inode *inode, struct reiserfs_key *key);\nstruct inode *reiserfs_iget(struct super_block *s, const struct cpu_key *key);\nint direct2indirect(struct reiserfs_transaction_handle *, struct inode *,\n\t\t    struct treepath *, struct buffer_head *, loff_t);\nint indirect2direct(struct reiserfs_transaction_handle *, struct inode *,\n\t\t    struct page *, struct treepath *, const struct cpu_key *,\n\t\t    loff_t, char *);\n\nstatic inline loff_t cpu_key_k_offset(const struct cpu_key *key)\n{\n\treturn key->on_disk_key.k_offset;\n}"
  },
  {
    "function_name": "is_statdata_le_ih",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/reiserfs.h",
    "lines": "1577-1580",
    "snippet": "static inline int is_statdata_le_ih(struct item_head *ih)\n{\n\treturn is_statdata_le_key(ih_version(ih), &ih->ih_key);\n}",
    "includes": [
      "#include <linux/buffer_head.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/bitops.h>",
      "#include <asm/unaligned.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/bug.h>",
      "#include <linux/sched.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/slab.h>",
      "#include <linux/reiserfs_fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "is_statdata_le_key",
          "args": [
            "ih_version(ih)",
            "&ih->ih_key"
          ],
          "line": 1579
        },
        "resolved": true,
        "details": {
          "function_name": "is_statdata_le_key",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/reiserfs.h",
          "lines": "1556-1559",
          "snippet": "static inline int is_statdata_le_key(int version, struct reiserfs_key *key)\n{\n\treturn le_key_k_type(version, key) == TYPE_STAT_DATA;\n}",
          "includes": [
            "#include <linux/buffer_head.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/bitops.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/slab.h>",
            "#include <linux/reiserfs_fs.h>"
          ],
          "macros_used": [
            "#define TYPE_STAT_DATA 0"
          ],
          "globals_used": [
            "extern int comp_le_keys(const struct reiserfs_key *,\n\t\t\tconst struct reiserfs_key *);",
            "extern int comp_short_le_keys(const struct reiserfs_key *,\n\t\t\t      const struct reiserfs_key *);",
            "void reiserfs_delete_solid_item(struct reiserfs_transaction_handle *th,\n\t\t\t\tstruct inode *inode, struct reiserfs_key *key);",
            "struct inode *reiserfs_iget(struct super_block *s, const struct cpu_key *key);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/buffer_head.h>\n#include <linux/proc_fs.h>\n#include <linux/bitops.h>\n#include <asm/unaligned.h>\n#include <linux/workqueue.h>\n#include <linux/bug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/slab.h>\n#include <linux/reiserfs_fs.h>\n\n#define TYPE_STAT_DATA 0\n\nextern int comp_le_keys(const struct reiserfs_key *,\n\t\t\tconst struct reiserfs_key *);\nextern int comp_short_le_keys(const struct reiserfs_key *,\n\t\t\t      const struct reiserfs_key *);\nvoid reiserfs_delete_solid_item(struct reiserfs_transaction_handle *th,\n\t\t\t\tstruct inode *inode, struct reiserfs_key *key);\nstruct inode *reiserfs_iget(struct super_block *s, const struct cpu_key *key);\n\nstatic inline int is_statdata_le_key(int version, struct reiserfs_key *key)\n{\n\treturn le_key_k_type(version, key) == TYPE_STAT_DATA;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ih_version",
          "args": [
            "ih"
          ],
          "line": 1579
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/buffer_head.h>\n#include <linux/proc_fs.h>\n#include <linux/bitops.h>\n#include <asm/unaligned.h>\n#include <linux/workqueue.h>\n#include <linux/bug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/slab.h>\n#include <linux/reiserfs_fs.h>\n\nstatic inline int is_statdata_le_ih(struct item_head *ih)\n{\n\treturn is_statdata_le_key(ih_version(ih), &ih->ih_key);\n}"
  },
  {
    "function_name": "is_indirect_le_ih",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/reiserfs.h",
    "lines": "1572-1575",
    "snippet": "static inline int is_indirect_le_ih(struct item_head *ih)\n{\n\treturn is_indirect_le_key(ih_version(ih), &ih->ih_key);\n}",
    "includes": [
      "#include <linux/buffer_head.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/bitops.h>",
      "#include <asm/unaligned.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/bug.h>",
      "#include <linux/sched.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/slab.h>",
      "#include <linux/reiserfs_fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "is_indirect_le_key",
          "args": [
            "ih_version(ih)",
            "&ih->ih_key"
          ],
          "line": 1574
        },
        "resolved": true,
        "details": {
          "function_name": "is_indirect_le_key",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/reiserfs.h",
          "lines": "1551-1554",
          "snippet": "static inline int is_indirect_le_key(int version, struct reiserfs_key *key)\n{\n\treturn le_key_k_type(version, key) == TYPE_INDIRECT;\n}",
          "includes": [
            "#include <linux/buffer_head.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/bitops.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/slab.h>",
            "#include <linux/reiserfs_fs.h>"
          ],
          "macros_used": [
            "#define TYPE_INDIRECT 1"
          ],
          "globals_used": [
            "extern int comp_le_keys(const struct reiserfs_key *,\n\t\t\tconst struct reiserfs_key *);",
            "extern int comp_short_le_keys(const struct reiserfs_key *,\n\t\t\t      const struct reiserfs_key *);",
            "void reiserfs_delete_solid_item(struct reiserfs_transaction_handle *th,\n\t\t\t\tstruct inode *inode, struct reiserfs_key *key);",
            "struct inode *reiserfs_iget(struct super_block *s, const struct cpu_key *key);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/buffer_head.h>\n#include <linux/proc_fs.h>\n#include <linux/bitops.h>\n#include <asm/unaligned.h>\n#include <linux/workqueue.h>\n#include <linux/bug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/slab.h>\n#include <linux/reiserfs_fs.h>\n\n#define TYPE_INDIRECT 1\n\nextern int comp_le_keys(const struct reiserfs_key *,\n\t\t\tconst struct reiserfs_key *);\nextern int comp_short_le_keys(const struct reiserfs_key *,\n\t\t\t      const struct reiserfs_key *);\nvoid reiserfs_delete_solid_item(struct reiserfs_transaction_handle *th,\n\t\t\t\tstruct inode *inode, struct reiserfs_key *key);\nstruct inode *reiserfs_iget(struct super_block *s, const struct cpu_key *key);\n\nstatic inline int is_indirect_le_key(int version, struct reiserfs_key *key)\n{\n\treturn le_key_k_type(version, key) == TYPE_INDIRECT;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ih_version",
          "args": [
            "ih"
          ],
          "line": 1574
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/buffer_head.h>\n#include <linux/proc_fs.h>\n#include <linux/bitops.h>\n#include <asm/unaligned.h>\n#include <linux/workqueue.h>\n#include <linux/bug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/slab.h>\n#include <linux/reiserfs_fs.h>\n\nstatic inline int is_indirect_le_ih(struct item_head *ih)\n{\n\treturn is_indirect_le_key(ih_version(ih), &ih->ih_key);\n}"
  },
  {
    "function_name": "is_direct_le_ih",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/reiserfs.h",
    "lines": "1567-1570",
    "snippet": "static inline int is_direct_le_ih(struct item_head *ih)\n{\n\treturn is_direct_le_key(ih_version(ih), &ih->ih_key);\n}",
    "includes": [
      "#include <linux/buffer_head.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/bitops.h>",
      "#include <asm/unaligned.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/bug.h>",
      "#include <linux/sched.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/slab.h>",
      "#include <linux/reiserfs_fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "is_direct_le_key",
          "args": [
            "ih_version(ih)",
            "&ih->ih_key"
          ],
          "line": 1569
        },
        "resolved": true,
        "details": {
          "function_name": "is_direct_le_key",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/reiserfs.h",
          "lines": "1546-1549",
          "snippet": "static inline int is_direct_le_key(int version, struct reiserfs_key *key)\n{\n\treturn le_key_k_type(version, key) == TYPE_DIRECT;\n}",
          "includes": [
            "#include <linux/buffer_head.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/bitops.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/slab.h>",
            "#include <linux/reiserfs_fs.h>"
          ],
          "macros_used": [
            "#define TYPE_DIRECT 2"
          ],
          "globals_used": [
            "extern int comp_le_keys(const struct reiserfs_key *,\n\t\t\tconst struct reiserfs_key *);",
            "extern int comp_short_le_keys(const struct reiserfs_key *,\n\t\t\t      const struct reiserfs_key *);",
            "void reiserfs_delete_solid_item(struct reiserfs_transaction_handle *th,\n\t\t\t\tstruct inode *inode, struct reiserfs_key *key);",
            "struct inode *reiserfs_iget(struct super_block *s, const struct cpu_key *key);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/buffer_head.h>\n#include <linux/proc_fs.h>\n#include <linux/bitops.h>\n#include <asm/unaligned.h>\n#include <linux/workqueue.h>\n#include <linux/bug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/slab.h>\n#include <linux/reiserfs_fs.h>\n\n#define TYPE_DIRECT 2\n\nextern int comp_le_keys(const struct reiserfs_key *,\n\t\t\tconst struct reiserfs_key *);\nextern int comp_short_le_keys(const struct reiserfs_key *,\n\t\t\t      const struct reiserfs_key *);\nvoid reiserfs_delete_solid_item(struct reiserfs_transaction_handle *th,\n\t\t\t\tstruct inode *inode, struct reiserfs_key *key);\nstruct inode *reiserfs_iget(struct super_block *s, const struct cpu_key *key);\n\nstatic inline int is_direct_le_key(int version, struct reiserfs_key *key)\n{\n\treturn le_key_k_type(version, key) == TYPE_DIRECT;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ih_version",
          "args": [
            "ih"
          ],
          "line": 1569
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/buffer_head.h>\n#include <linux/proc_fs.h>\n#include <linux/bitops.h>\n#include <asm/unaligned.h>\n#include <linux/workqueue.h>\n#include <linux/bug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/slab.h>\n#include <linux/reiserfs_fs.h>\n\nstatic inline int is_direct_le_ih(struct item_head *ih)\n{\n\treturn is_direct_le_key(ih_version(ih), &ih->ih_key);\n}"
  },
  {
    "function_name": "is_direntry_le_ih",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/reiserfs.h",
    "lines": "1562-1565",
    "snippet": "static inline int is_direntry_le_ih(struct item_head *ih)\n{\n\treturn is_direntry_le_key(ih_version(ih), &ih->ih_key);\n}",
    "includes": [
      "#include <linux/buffer_head.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/bitops.h>",
      "#include <asm/unaligned.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/bug.h>",
      "#include <linux/sched.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/slab.h>",
      "#include <linux/reiserfs_fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "is_direntry_le_key",
          "args": [
            "ih_version(ih)",
            "&ih->ih_key"
          ],
          "line": 1564
        },
        "resolved": true,
        "details": {
          "function_name": "is_direntry_le_key",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/reiserfs.h",
          "lines": "1541-1544",
          "snippet": "static inline int is_direntry_le_key(int version, struct reiserfs_key *key)\n{\n\treturn le_key_k_type(version, key) == TYPE_DIRENTRY;\n}",
          "includes": [
            "#include <linux/buffer_head.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/bitops.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/slab.h>",
            "#include <linux/reiserfs_fs.h>"
          ],
          "macros_used": [
            "#define TYPE_DIRENTRY 3"
          ],
          "globals_used": [
            "extern int comp_le_keys(const struct reiserfs_key *,\n\t\t\tconst struct reiserfs_key *);",
            "extern int comp_short_le_keys(const struct reiserfs_key *,\n\t\t\t      const struct reiserfs_key *);",
            "void reiserfs_delete_solid_item(struct reiserfs_transaction_handle *th,\n\t\t\t\tstruct inode *inode, struct reiserfs_key *key);",
            "struct inode *reiserfs_iget(struct super_block *s, const struct cpu_key *key);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/buffer_head.h>\n#include <linux/proc_fs.h>\n#include <linux/bitops.h>\n#include <asm/unaligned.h>\n#include <linux/workqueue.h>\n#include <linux/bug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/slab.h>\n#include <linux/reiserfs_fs.h>\n\n#define TYPE_DIRENTRY 3\n\nextern int comp_le_keys(const struct reiserfs_key *,\n\t\t\tconst struct reiserfs_key *);\nextern int comp_short_le_keys(const struct reiserfs_key *,\n\t\t\t      const struct reiserfs_key *);\nvoid reiserfs_delete_solid_item(struct reiserfs_transaction_handle *th,\n\t\t\t\tstruct inode *inode, struct reiserfs_key *key);\nstruct inode *reiserfs_iget(struct super_block *s, const struct cpu_key *key);\n\nstatic inline int is_direntry_le_key(int version, struct reiserfs_key *key)\n{\n\treturn le_key_k_type(version, key) == TYPE_DIRENTRY;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ih_version",
          "args": [
            "ih"
          ],
          "line": 1564
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/buffer_head.h>\n#include <linux/proc_fs.h>\n#include <linux/bitops.h>\n#include <asm/unaligned.h>\n#include <linux/workqueue.h>\n#include <linux/bug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/slab.h>\n#include <linux/reiserfs_fs.h>\n\nstatic inline int is_direntry_le_ih(struct item_head *ih)\n{\n\treturn is_direntry_le_key(ih_version(ih), &ih->ih_key);\n}"
  },
  {
    "function_name": "is_statdata_le_key",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/reiserfs.h",
    "lines": "1556-1559",
    "snippet": "static inline int is_statdata_le_key(int version, struct reiserfs_key *key)\n{\n\treturn le_key_k_type(version, key) == TYPE_STAT_DATA;\n}",
    "includes": [
      "#include <linux/buffer_head.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/bitops.h>",
      "#include <asm/unaligned.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/bug.h>",
      "#include <linux/sched.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/slab.h>",
      "#include <linux/reiserfs_fs.h>"
    ],
    "macros_used": [
      "#define TYPE_STAT_DATA 0"
    ],
    "globals_used": [
      "extern int comp_le_keys(const struct reiserfs_key *,\n\t\t\tconst struct reiserfs_key *);",
      "extern int comp_short_le_keys(const struct reiserfs_key *,\n\t\t\t      const struct reiserfs_key *);",
      "void reiserfs_delete_solid_item(struct reiserfs_transaction_handle *th,\n\t\t\t\tstruct inode *inode, struct reiserfs_key *key);",
      "struct inode *reiserfs_iget(struct super_block *s, const struct cpu_key *key);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "le_key_k_type",
          "args": [
            "version",
            "key"
          ],
          "line": 1558
        },
        "resolved": true,
        "details": {
          "function_name": "le_key_k_type",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/reiserfs.h",
          "lines": "1486-1493",
          "snippet": "static inline loff_t le_key_k_type(int version, const struct reiserfs_key *key)\n{\n\tif (version == KEY_FORMAT_3_5) {\n\t\tloff_t val = le32_to_cpu(key->u.k_offset_v1.k_uniqueness);\n\t\treturn uniqueness2type(val);\n\t} else\n\t\treturn offset_v2_k_type(&(key->u.k_offset_v2));\n}",
          "includes": [
            "#include <linux/buffer_head.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/bitops.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/slab.h>",
            "#include <linux/reiserfs_fs.h>"
          ],
          "macros_used": [
            "#define KEY_FORMAT_3_5 0"
          ],
          "globals_used": [
            "extern int comp_le_keys(const struct reiserfs_key *,\n\t\t\tconst struct reiserfs_key *);",
            "extern int comp_short_le_keys(const struct reiserfs_key *,\n\t\t\t      const struct reiserfs_key *);",
            "void reiserfs_delete_solid_item(struct reiserfs_transaction_handle *th,\n\t\t\t\tstruct inode *inode, struct reiserfs_key *key);",
            "struct inode *reiserfs_iget(struct super_block *s, const struct cpu_key *key);",
            "int direct2indirect(struct reiserfs_transaction_handle *, struct inode *,\n\t\t    struct treepath *, struct buffer_head *, loff_t);",
            "int indirect2direct(struct reiserfs_transaction_handle *, struct inode *,\n\t\t    struct page *, struct treepath *, const struct cpu_key *,\n\t\t    loff_t, char *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/buffer_head.h>\n#include <linux/proc_fs.h>\n#include <linux/bitops.h>\n#include <asm/unaligned.h>\n#include <linux/workqueue.h>\n#include <linux/bug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/slab.h>\n#include <linux/reiserfs_fs.h>\n\n#define KEY_FORMAT_3_5 0\n\nextern int comp_le_keys(const struct reiserfs_key *,\n\t\t\tconst struct reiserfs_key *);\nextern int comp_short_le_keys(const struct reiserfs_key *,\n\t\t\t      const struct reiserfs_key *);\nvoid reiserfs_delete_solid_item(struct reiserfs_transaction_handle *th,\n\t\t\t\tstruct inode *inode, struct reiserfs_key *key);\nstruct inode *reiserfs_iget(struct super_block *s, const struct cpu_key *key);\nint direct2indirect(struct reiserfs_transaction_handle *, struct inode *,\n\t\t    struct treepath *, struct buffer_head *, loff_t);\nint indirect2direct(struct reiserfs_transaction_handle *, struct inode *,\n\t\t    struct page *, struct treepath *, const struct cpu_key *,\n\t\t    loff_t, char *);\n\nstatic inline loff_t le_key_k_type(int version, const struct reiserfs_key *key)\n{\n\tif (version == KEY_FORMAT_3_5) {\n\t\tloff_t val = le32_to_cpu(key->u.k_offset_v1.k_uniqueness);\n\t\treturn uniqueness2type(val);\n\t} else\n\t\treturn offset_v2_k_type(&(key->u.k_offset_v2));\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/buffer_head.h>\n#include <linux/proc_fs.h>\n#include <linux/bitops.h>\n#include <asm/unaligned.h>\n#include <linux/workqueue.h>\n#include <linux/bug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/slab.h>\n#include <linux/reiserfs_fs.h>\n\n#define TYPE_STAT_DATA 0\n\nextern int comp_le_keys(const struct reiserfs_key *,\n\t\t\tconst struct reiserfs_key *);\nextern int comp_short_le_keys(const struct reiserfs_key *,\n\t\t\t      const struct reiserfs_key *);\nvoid reiserfs_delete_solid_item(struct reiserfs_transaction_handle *th,\n\t\t\t\tstruct inode *inode, struct reiserfs_key *key);\nstruct inode *reiserfs_iget(struct super_block *s, const struct cpu_key *key);\n\nstatic inline int is_statdata_le_key(int version, struct reiserfs_key *key)\n{\n\treturn le_key_k_type(version, key) == TYPE_STAT_DATA;\n}"
  },
  {
    "function_name": "is_indirect_le_key",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/reiserfs.h",
    "lines": "1551-1554",
    "snippet": "static inline int is_indirect_le_key(int version, struct reiserfs_key *key)\n{\n\treturn le_key_k_type(version, key) == TYPE_INDIRECT;\n}",
    "includes": [
      "#include <linux/buffer_head.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/bitops.h>",
      "#include <asm/unaligned.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/bug.h>",
      "#include <linux/sched.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/slab.h>",
      "#include <linux/reiserfs_fs.h>"
    ],
    "macros_used": [
      "#define TYPE_INDIRECT 1"
    ],
    "globals_used": [
      "extern int comp_le_keys(const struct reiserfs_key *,\n\t\t\tconst struct reiserfs_key *);",
      "extern int comp_short_le_keys(const struct reiserfs_key *,\n\t\t\t      const struct reiserfs_key *);",
      "void reiserfs_delete_solid_item(struct reiserfs_transaction_handle *th,\n\t\t\t\tstruct inode *inode, struct reiserfs_key *key);",
      "struct inode *reiserfs_iget(struct super_block *s, const struct cpu_key *key);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "le_key_k_type",
          "args": [
            "version",
            "key"
          ],
          "line": 1553
        },
        "resolved": true,
        "details": {
          "function_name": "le_key_k_type",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/reiserfs.h",
          "lines": "1486-1493",
          "snippet": "static inline loff_t le_key_k_type(int version, const struct reiserfs_key *key)\n{\n\tif (version == KEY_FORMAT_3_5) {\n\t\tloff_t val = le32_to_cpu(key->u.k_offset_v1.k_uniqueness);\n\t\treturn uniqueness2type(val);\n\t} else\n\t\treturn offset_v2_k_type(&(key->u.k_offset_v2));\n}",
          "includes": [
            "#include <linux/buffer_head.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/bitops.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/slab.h>",
            "#include <linux/reiserfs_fs.h>"
          ],
          "macros_used": [
            "#define KEY_FORMAT_3_5 0"
          ],
          "globals_used": [
            "extern int comp_le_keys(const struct reiserfs_key *,\n\t\t\tconst struct reiserfs_key *);",
            "extern int comp_short_le_keys(const struct reiserfs_key *,\n\t\t\t      const struct reiserfs_key *);",
            "void reiserfs_delete_solid_item(struct reiserfs_transaction_handle *th,\n\t\t\t\tstruct inode *inode, struct reiserfs_key *key);",
            "struct inode *reiserfs_iget(struct super_block *s, const struct cpu_key *key);",
            "int direct2indirect(struct reiserfs_transaction_handle *, struct inode *,\n\t\t    struct treepath *, struct buffer_head *, loff_t);",
            "int indirect2direct(struct reiserfs_transaction_handle *, struct inode *,\n\t\t    struct page *, struct treepath *, const struct cpu_key *,\n\t\t    loff_t, char *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/buffer_head.h>\n#include <linux/proc_fs.h>\n#include <linux/bitops.h>\n#include <asm/unaligned.h>\n#include <linux/workqueue.h>\n#include <linux/bug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/slab.h>\n#include <linux/reiserfs_fs.h>\n\n#define KEY_FORMAT_3_5 0\n\nextern int comp_le_keys(const struct reiserfs_key *,\n\t\t\tconst struct reiserfs_key *);\nextern int comp_short_le_keys(const struct reiserfs_key *,\n\t\t\t      const struct reiserfs_key *);\nvoid reiserfs_delete_solid_item(struct reiserfs_transaction_handle *th,\n\t\t\t\tstruct inode *inode, struct reiserfs_key *key);\nstruct inode *reiserfs_iget(struct super_block *s, const struct cpu_key *key);\nint direct2indirect(struct reiserfs_transaction_handle *, struct inode *,\n\t\t    struct treepath *, struct buffer_head *, loff_t);\nint indirect2direct(struct reiserfs_transaction_handle *, struct inode *,\n\t\t    struct page *, struct treepath *, const struct cpu_key *,\n\t\t    loff_t, char *);\n\nstatic inline loff_t le_key_k_type(int version, const struct reiserfs_key *key)\n{\n\tif (version == KEY_FORMAT_3_5) {\n\t\tloff_t val = le32_to_cpu(key->u.k_offset_v1.k_uniqueness);\n\t\treturn uniqueness2type(val);\n\t} else\n\t\treturn offset_v2_k_type(&(key->u.k_offset_v2));\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/buffer_head.h>\n#include <linux/proc_fs.h>\n#include <linux/bitops.h>\n#include <asm/unaligned.h>\n#include <linux/workqueue.h>\n#include <linux/bug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/slab.h>\n#include <linux/reiserfs_fs.h>\n\n#define TYPE_INDIRECT 1\n\nextern int comp_le_keys(const struct reiserfs_key *,\n\t\t\tconst struct reiserfs_key *);\nextern int comp_short_le_keys(const struct reiserfs_key *,\n\t\t\t      const struct reiserfs_key *);\nvoid reiserfs_delete_solid_item(struct reiserfs_transaction_handle *th,\n\t\t\t\tstruct inode *inode, struct reiserfs_key *key);\nstruct inode *reiserfs_iget(struct super_block *s, const struct cpu_key *key);\n\nstatic inline int is_indirect_le_key(int version, struct reiserfs_key *key)\n{\n\treturn le_key_k_type(version, key) == TYPE_INDIRECT;\n}"
  },
  {
    "function_name": "is_direct_le_key",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/reiserfs.h",
    "lines": "1546-1549",
    "snippet": "static inline int is_direct_le_key(int version, struct reiserfs_key *key)\n{\n\treturn le_key_k_type(version, key) == TYPE_DIRECT;\n}",
    "includes": [
      "#include <linux/buffer_head.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/bitops.h>",
      "#include <asm/unaligned.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/bug.h>",
      "#include <linux/sched.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/slab.h>",
      "#include <linux/reiserfs_fs.h>"
    ],
    "macros_used": [
      "#define TYPE_DIRECT 2"
    ],
    "globals_used": [
      "extern int comp_le_keys(const struct reiserfs_key *,\n\t\t\tconst struct reiserfs_key *);",
      "extern int comp_short_le_keys(const struct reiserfs_key *,\n\t\t\t      const struct reiserfs_key *);",
      "void reiserfs_delete_solid_item(struct reiserfs_transaction_handle *th,\n\t\t\t\tstruct inode *inode, struct reiserfs_key *key);",
      "struct inode *reiserfs_iget(struct super_block *s, const struct cpu_key *key);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "le_key_k_type",
          "args": [
            "version",
            "key"
          ],
          "line": 1548
        },
        "resolved": true,
        "details": {
          "function_name": "le_key_k_type",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/reiserfs.h",
          "lines": "1486-1493",
          "snippet": "static inline loff_t le_key_k_type(int version, const struct reiserfs_key *key)\n{\n\tif (version == KEY_FORMAT_3_5) {\n\t\tloff_t val = le32_to_cpu(key->u.k_offset_v1.k_uniqueness);\n\t\treturn uniqueness2type(val);\n\t} else\n\t\treturn offset_v2_k_type(&(key->u.k_offset_v2));\n}",
          "includes": [
            "#include <linux/buffer_head.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/bitops.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/slab.h>",
            "#include <linux/reiserfs_fs.h>"
          ],
          "macros_used": [
            "#define KEY_FORMAT_3_5 0"
          ],
          "globals_used": [
            "extern int comp_le_keys(const struct reiserfs_key *,\n\t\t\tconst struct reiserfs_key *);",
            "extern int comp_short_le_keys(const struct reiserfs_key *,\n\t\t\t      const struct reiserfs_key *);",
            "void reiserfs_delete_solid_item(struct reiserfs_transaction_handle *th,\n\t\t\t\tstruct inode *inode, struct reiserfs_key *key);",
            "struct inode *reiserfs_iget(struct super_block *s, const struct cpu_key *key);",
            "int direct2indirect(struct reiserfs_transaction_handle *, struct inode *,\n\t\t    struct treepath *, struct buffer_head *, loff_t);",
            "int indirect2direct(struct reiserfs_transaction_handle *, struct inode *,\n\t\t    struct page *, struct treepath *, const struct cpu_key *,\n\t\t    loff_t, char *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/buffer_head.h>\n#include <linux/proc_fs.h>\n#include <linux/bitops.h>\n#include <asm/unaligned.h>\n#include <linux/workqueue.h>\n#include <linux/bug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/slab.h>\n#include <linux/reiserfs_fs.h>\n\n#define KEY_FORMAT_3_5 0\n\nextern int comp_le_keys(const struct reiserfs_key *,\n\t\t\tconst struct reiserfs_key *);\nextern int comp_short_le_keys(const struct reiserfs_key *,\n\t\t\t      const struct reiserfs_key *);\nvoid reiserfs_delete_solid_item(struct reiserfs_transaction_handle *th,\n\t\t\t\tstruct inode *inode, struct reiserfs_key *key);\nstruct inode *reiserfs_iget(struct super_block *s, const struct cpu_key *key);\nint direct2indirect(struct reiserfs_transaction_handle *, struct inode *,\n\t\t    struct treepath *, struct buffer_head *, loff_t);\nint indirect2direct(struct reiserfs_transaction_handle *, struct inode *,\n\t\t    struct page *, struct treepath *, const struct cpu_key *,\n\t\t    loff_t, char *);\n\nstatic inline loff_t le_key_k_type(int version, const struct reiserfs_key *key)\n{\n\tif (version == KEY_FORMAT_3_5) {\n\t\tloff_t val = le32_to_cpu(key->u.k_offset_v1.k_uniqueness);\n\t\treturn uniqueness2type(val);\n\t} else\n\t\treturn offset_v2_k_type(&(key->u.k_offset_v2));\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/buffer_head.h>\n#include <linux/proc_fs.h>\n#include <linux/bitops.h>\n#include <asm/unaligned.h>\n#include <linux/workqueue.h>\n#include <linux/bug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/slab.h>\n#include <linux/reiserfs_fs.h>\n\n#define TYPE_DIRECT 2\n\nextern int comp_le_keys(const struct reiserfs_key *,\n\t\t\tconst struct reiserfs_key *);\nextern int comp_short_le_keys(const struct reiserfs_key *,\n\t\t\t      const struct reiserfs_key *);\nvoid reiserfs_delete_solid_item(struct reiserfs_transaction_handle *th,\n\t\t\t\tstruct inode *inode, struct reiserfs_key *key);\nstruct inode *reiserfs_iget(struct super_block *s, const struct cpu_key *key);\n\nstatic inline int is_direct_le_key(int version, struct reiserfs_key *key)\n{\n\treturn le_key_k_type(version, key) == TYPE_DIRECT;\n}"
  },
  {
    "function_name": "is_direntry_le_key",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/reiserfs.h",
    "lines": "1541-1544",
    "snippet": "static inline int is_direntry_le_key(int version, struct reiserfs_key *key)\n{\n\treturn le_key_k_type(version, key) == TYPE_DIRENTRY;\n}",
    "includes": [
      "#include <linux/buffer_head.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/bitops.h>",
      "#include <asm/unaligned.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/bug.h>",
      "#include <linux/sched.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/slab.h>",
      "#include <linux/reiserfs_fs.h>"
    ],
    "macros_used": [
      "#define TYPE_DIRENTRY 3"
    ],
    "globals_used": [
      "extern int comp_le_keys(const struct reiserfs_key *,\n\t\t\tconst struct reiserfs_key *);",
      "extern int comp_short_le_keys(const struct reiserfs_key *,\n\t\t\t      const struct reiserfs_key *);",
      "void reiserfs_delete_solid_item(struct reiserfs_transaction_handle *th,\n\t\t\t\tstruct inode *inode, struct reiserfs_key *key);",
      "struct inode *reiserfs_iget(struct super_block *s, const struct cpu_key *key);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "le_key_k_type",
          "args": [
            "version",
            "key"
          ],
          "line": 1543
        },
        "resolved": true,
        "details": {
          "function_name": "le_key_k_type",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/reiserfs.h",
          "lines": "1486-1493",
          "snippet": "static inline loff_t le_key_k_type(int version, const struct reiserfs_key *key)\n{\n\tif (version == KEY_FORMAT_3_5) {\n\t\tloff_t val = le32_to_cpu(key->u.k_offset_v1.k_uniqueness);\n\t\treturn uniqueness2type(val);\n\t} else\n\t\treturn offset_v2_k_type(&(key->u.k_offset_v2));\n}",
          "includes": [
            "#include <linux/buffer_head.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/bitops.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/slab.h>",
            "#include <linux/reiserfs_fs.h>"
          ],
          "macros_used": [
            "#define KEY_FORMAT_3_5 0"
          ],
          "globals_used": [
            "extern int comp_le_keys(const struct reiserfs_key *,\n\t\t\tconst struct reiserfs_key *);",
            "extern int comp_short_le_keys(const struct reiserfs_key *,\n\t\t\t      const struct reiserfs_key *);",
            "void reiserfs_delete_solid_item(struct reiserfs_transaction_handle *th,\n\t\t\t\tstruct inode *inode, struct reiserfs_key *key);",
            "struct inode *reiserfs_iget(struct super_block *s, const struct cpu_key *key);",
            "int direct2indirect(struct reiserfs_transaction_handle *, struct inode *,\n\t\t    struct treepath *, struct buffer_head *, loff_t);",
            "int indirect2direct(struct reiserfs_transaction_handle *, struct inode *,\n\t\t    struct page *, struct treepath *, const struct cpu_key *,\n\t\t    loff_t, char *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/buffer_head.h>\n#include <linux/proc_fs.h>\n#include <linux/bitops.h>\n#include <asm/unaligned.h>\n#include <linux/workqueue.h>\n#include <linux/bug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/slab.h>\n#include <linux/reiserfs_fs.h>\n\n#define KEY_FORMAT_3_5 0\n\nextern int comp_le_keys(const struct reiserfs_key *,\n\t\t\tconst struct reiserfs_key *);\nextern int comp_short_le_keys(const struct reiserfs_key *,\n\t\t\t      const struct reiserfs_key *);\nvoid reiserfs_delete_solid_item(struct reiserfs_transaction_handle *th,\n\t\t\t\tstruct inode *inode, struct reiserfs_key *key);\nstruct inode *reiserfs_iget(struct super_block *s, const struct cpu_key *key);\nint direct2indirect(struct reiserfs_transaction_handle *, struct inode *,\n\t\t    struct treepath *, struct buffer_head *, loff_t);\nint indirect2direct(struct reiserfs_transaction_handle *, struct inode *,\n\t\t    struct page *, struct treepath *, const struct cpu_key *,\n\t\t    loff_t, char *);\n\nstatic inline loff_t le_key_k_type(int version, const struct reiserfs_key *key)\n{\n\tif (version == KEY_FORMAT_3_5) {\n\t\tloff_t val = le32_to_cpu(key->u.k_offset_v1.k_uniqueness);\n\t\treturn uniqueness2type(val);\n\t} else\n\t\treturn offset_v2_k_type(&(key->u.k_offset_v2));\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/buffer_head.h>\n#include <linux/proc_fs.h>\n#include <linux/bitops.h>\n#include <asm/unaligned.h>\n#include <linux/workqueue.h>\n#include <linux/bug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/slab.h>\n#include <linux/reiserfs_fs.h>\n\n#define TYPE_DIRENTRY 3\n\nextern int comp_le_keys(const struct reiserfs_key *,\n\t\t\tconst struct reiserfs_key *);\nextern int comp_short_le_keys(const struct reiserfs_key *,\n\t\t\t      const struct reiserfs_key *);\nvoid reiserfs_delete_solid_item(struct reiserfs_transaction_handle *th,\n\t\t\t\tstruct inode *inode, struct reiserfs_key *key);\nstruct inode *reiserfs_iget(struct super_block *s, const struct cpu_key *key);\n\nstatic inline int is_direntry_le_key(int version, struct reiserfs_key *key)\n{\n\treturn le_key_k_type(version, key) == TYPE_DIRENTRY;\n}"
  },
  {
    "function_name": "set_le_ih_k_type",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/reiserfs.h",
    "lines": "1536-1539",
    "snippet": "static inline void set_le_ih_k_type(struct item_head *ih, int type)\n{\n\tset_le_key_k_type(ih_version(ih), &(ih->ih_key), type);\n}",
    "includes": [
      "#include <linux/buffer_head.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/bitops.h>",
      "#include <asm/unaligned.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/bug.h>",
      "#include <linux/sched.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/slab.h>",
      "#include <linux/reiserfs_fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "set_le_key_k_type",
          "args": [
            "ih_version(ih)",
            "&(ih->ih_key)",
            "type"
          ],
          "line": 1538
        },
        "resolved": true,
        "details": {
          "function_name": "set_le_key_k_type",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/reiserfs.h",
          "lines": "1526-1534",
          "snippet": "static inline void set_le_key_k_type(int version, struct reiserfs_key *key,\n\t\t\t\t     int type)\n{\n\tif (version == KEY_FORMAT_3_5) {\n\t\ttype = type2uniqueness(type);\n\t\tkey->u.k_offset_v1.k_uniqueness = cpu_to_le32(type);\n\t} else\n\t       set_offset_v2_k_type(&key->u.k_offset_v2, type);\n}",
          "includes": [
            "#include <linux/buffer_head.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/bitops.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/slab.h>",
            "#include <linux/reiserfs_fs.h>"
          ],
          "macros_used": [
            "#define KEY_FORMAT_3_5 0"
          ],
          "globals_used": [
            "extern int comp_le_keys(const struct reiserfs_key *,\n\t\t\tconst struct reiserfs_key *);",
            "extern int comp_short_le_keys(const struct reiserfs_key *,\n\t\t\t      const struct reiserfs_key *);",
            "void reiserfs_delete_solid_item(struct reiserfs_transaction_handle *th,\n\t\t\t\tstruct inode *inode, struct reiserfs_key *key);",
            "struct inode *reiserfs_iget(struct super_block *s, const struct cpu_key *key);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/buffer_head.h>\n#include <linux/proc_fs.h>\n#include <linux/bitops.h>\n#include <asm/unaligned.h>\n#include <linux/workqueue.h>\n#include <linux/bug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/slab.h>\n#include <linux/reiserfs_fs.h>\n\n#define KEY_FORMAT_3_5 0\n\nextern int comp_le_keys(const struct reiserfs_key *,\n\t\t\tconst struct reiserfs_key *);\nextern int comp_short_le_keys(const struct reiserfs_key *,\n\t\t\t      const struct reiserfs_key *);\nvoid reiserfs_delete_solid_item(struct reiserfs_transaction_handle *th,\n\t\t\t\tstruct inode *inode, struct reiserfs_key *key);\nstruct inode *reiserfs_iget(struct super_block *s, const struct cpu_key *key);\n\nstatic inline void set_le_key_k_type(int version, struct reiserfs_key *key,\n\t\t\t\t     int type)\n{\n\tif (version == KEY_FORMAT_3_5) {\n\t\ttype = type2uniqueness(type);\n\t\tkey->u.k_offset_v1.k_uniqueness = cpu_to_le32(type);\n\t} else\n\t       set_offset_v2_k_type(&key->u.k_offset_v2, type);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ih_version",
          "args": [
            "ih"
          ],
          "line": 1538
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/buffer_head.h>\n#include <linux/proc_fs.h>\n#include <linux/bitops.h>\n#include <asm/unaligned.h>\n#include <linux/workqueue.h>\n#include <linux/bug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/slab.h>\n#include <linux/reiserfs_fs.h>\n\nstatic inline void set_le_ih_k_type(struct item_head *ih, int type)\n{\n\tset_le_key_k_type(ih_version(ih), &(ih->ih_key), type);\n}"
  },
  {
    "function_name": "set_le_key_k_type",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/reiserfs.h",
    "lines": "1526-1534",
    "snippet": "static inline void set_le_key_k_type(int version, struct reiserfs_key *key,\n\t\t\t\t     int type)\n{\n\tif (version == KEY_FORMAT_3_5) {\n\t\ttype = type2uniqueness(type);\n\t\tkey->u.k_offset_v1.k_uniqueness = cpu_to_le32(type);\n\t} else\n\t       set_offset_v2_k_type(&key->u.k_offset_v2, type);\n}",
    "includes": [
      "#include <linux/buffer_head.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/bitops.h>",
      "#include <asm/unaligned.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/bug.h>",
      "#include <linux/sched.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/slab.h>",
      "#include <linux/reiserfs_fs.h>"
    ],
    "macros_used": [
      "#define KEY_FORMAT_3_5 0"
    ],
    "globals_used": [
      "extern int comp_le_keys(const struct reiserfs_key *,\n\t\t\tconst struct reiserfs_key *);",
      "extern int comp_short_le_keys(const struct reiserfs_key *,\n\t\t\t      const struct reiserfs_key *);",
      "void reiserfs_delete_solid_item(struct reiserfs_transaction_handle *th,\n\t\t\t\tstruct inode *inode, struct reiserfs_key *key);",
      "struct inode *reiserfs_iget(struct super_block *s, const struct cpu_key *key);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "set_offset_v2_k_type",
          "args": [
            "&key->u.k_offset_v2",
            "type"
          ],
          "line": 1533
        },
        "resolved": true,
        "details": {
          "function_name": "set_offset_v2_k_type",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/reiserfs.h",
          "lines": "1266-1270",
          "snippet": "static inline void set_offset_v2_k_type(struct offset_v2 *v2, int type)\n{\n\tv2->v =\n\t    (v2->v & cpu_to_le64(~0ULL >> 4)) | cpu_to_le64((__u64) type << 60);\n}",
          "includes": [
            "#include <linux/buffer_head.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/bitops.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/slab.h>",
            "#include <linux/reiserfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/buffer_head.h>\n#include <linux/proc_fs.h>\n#include <linux/bitops.h>\n#include <asm/unaligned.h>\n#include <linux/workqueue.h>\n#include <linux/bug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/slab.h>\n#include <linux/reiserfs_fs.h>\n\nstatic inline void set_offset_v2_k_type(struct offset_v2 *v2, int type)\n{\n\tv2->v =\n\t    (v2->v & cpu_to_le64(~0ULL >> 4)) | cpu_to_le64((__u64) type << 60);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "type"
          ],
          "line": 1531
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "type2uniqueness",
          "args": [
            "type"
          ],
          "line": 1530
        },
        "resolved": true,
        "details": {
          "function_name": "type2uniqueness",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/reiserfs.h",
          "lines": "1451-1466",
          "snippet": "static inline __u32 type2uniqueness(int type)\n{\n\tswitch (type) {\n\tcase TYPE_STAT_DATA:\n\t\treturn V1_SD_UNIQUENESS;\n\tcase TYPE_INDIRECT:\n\t\treturn V1_INDIRECT_UNIQUENESS;\n\tcase TYPE_DIRECT:\n\t\treturn V1_DIRECT_UNIQUENESS;\n\tcase TYPE_DIRENTRY:\n\t\treturn V1_DIRENTRY_UNIQUENESS;\n\tcase TYPE_ANY:\n\tdefault:\n\t\treturn V1_ANY_UNIQUENESS;\n\t}\n}",
          "includes": [
            "#include <linux/buffer_head.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/bitops.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/slab.h>",
            "#include <linux/reiserfs_fs.h>"
          ],
          "macros_used": [
            "#define V1_ANY_UNIQUENESS 555\t/* FIXME: comment is required */",
            "#define V1_DIRENTRY_UNIQUENESS 500",
            "#define V1_DIRECT_UNIQUENESS 0xffffffff",
            "#define V1_INDIRECT_UNIQUENESS 0xfffffffe",
            "#define V1_SD_UNIQUENESS 0",
            "#define TYPE_ANY 15\t\t/* FIXME: comment is required */",
            "#define TYPE_DIRENTRY 3",
            "#define TYPE_DIRECT 2",
            "#define TYPE_INDIRECT 1",
            "#define TYPE_STAT_DATA 0"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/buffer_head.h>\n#include <linux/proc_fs.h>\n#include <linux/bitops.h>\n#include <asm/unaligned.h>\n#include <linux/workqueue.h>\n#include <linux/bug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/slab.h>\n#include <linux/reiserfs_fs.h>\n\n#define V1_ANY_UNIQUENESS 555\t/* FIXME: comment is required */\n#define V1_DIRENTRY_UNIQUENESS 500\n#define V1_DIRECT_UNIQUENESS 0xffffffff\n#define V1_INDIRECT_UNIQUENESS 0xfffffffe\n#define V1_SD_UNIQUENESS 0\n#define TYPE_ANY 15\t\t/* FIXME: comment is required */\n#define TYPE_DIRENTRY 3\n#define TYPE_DIRECT 2\n#define TYPE_INDIRECT 1\n#define TYPE_STAT_DATA 0\n\nstatic inline __u32 type2uniqueness(int type)\n{\n\tswitch (type) {\n\tcase TYPE_STAT_DATA:\n\t\treturn V1_SD_UNIQUENESS;\n\tcase TYPE_INDIRECT:\n\t\treturn V1_INDIRECT_UNIQUENESS;\n\tcase TYPE_DIRECT:\n\t\treturn V1_DIRECT_UNIQUENESS;\n\tcase TYPE_DIRENTRY:\n\t\treturn V1_DIRENTRY_UNIQUENESS;\n\tcase TYPE_ANY:\n\tdefault:\n\t\treturn V1_ANY_UNIQUENESS;\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/buffer_head.h>\n#include <linux/proc_fs.h>\n#include <linux/bitops.h>\n#include <asm/unaligned.h>\n#include <linux/workqueue.h>\n#include <linux/bug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/slab.h>\n#include <linux/reiserfs_fs.h>\n\n#define KEY_FORMAT_3_5 0\n\nextern int comp_le_keys(const struct reiserfs_key *,\n\t\t\tconst struct reiserfs_key *);\nextern int comp_short_le_keys(const struct reiserfs_key *,\n\t\t\t      const struct reiserfs_key *);\nvoid reiserfs_delete_solid_item(struct reiserfs_transaction_handle *th,\n\t\t\t\tstruct inode *inode, struct reiserfs_key *key);\nstruct inode *reiserfs_iget(struct super_block *s, const struct cpu_key *key);\n\nstatic inline void set_le_key_k_type(int version, struct reiserfs_key *key,\n\t\t\t\t     int type)\n{\n\tif (version == KEY_FORMAT_3_5) {\n\t\ttype = type2uniqueness(type);\n\t\tkey->u.k_offset_v1.k_uniqueness = cpu_to_le32(type);\n\t} else\n\t       set_offset_v2_k_type(&key->u.k_offset_v2, type);\n}"
  },
  {
    "function_name": "set_le_ih_k_offset",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/reiserfs.h",
    "lines": "1521-1524",
    "snippet": "static inline void set_le_ih_k_offset(struct item_head *ih, loff_t offset)\n{\n\tset_le_key_k_offset(ih_version(ih), &(ih->ih_key), offset);\n}",
    "includes": [
      "#include <linux/buffer_head.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/bitops.h>",
      "#include <asm/unaligned.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/bug.h>",
      "#include <linux/sched.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/slab.h>",
      "#include <linux/reiserfs_fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "int direct2indirect(struct reiserfs_transaction_handle *, struct inode *,\n\t\t    struct treepath *, struct buffer_head *, loff_t);",
      "int indirect2direct(struct reiserfs_transaction_handle *, struct inode *,\n\t\t    struct page *, struct treepath *, const struct cpu_key *,\n\t\t    loff_t, char *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "set_le_key_k_offset",
          "args": [
            "ih_version(ih)",
            "&(ih->ih_key)",
            "offset"
          ],
          "line": 1523
        },
        "resolved": true,
        "details": {
          "function_name": "set_le_key_k_offset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/reiserfs.h",
          "lines": "1500-1507",
          "snippet": "static inline void set_le_key_k_offset(int version, struct reiserfs_key *key,\n\t\t\t\t       loff_t offset)\n{\n\tif (version == KEY_FORMAT_3_5)\n\t\tkey->u.k_offset_v1.k_offset = cpu_to_le32(offset);\n\telse\n\t\tset_offset_v2_k_offset(&key->u.k_offset_v2, offset);\n}",
          "includes": [
            "#include <linux/buffer_head.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/bitops.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/slab.h>",
            "#include <linux/reiserfs_fs.h>"
          ],
          "macros_used": [
            "#define KEY_FORMAT_3_5 0"
          ],
          "globals_used": [
            "extern int comp_le_keys(const struct reiserfs_key *,\n\t\t\tconst struct reiserfs_key *);",
            "extern int comp_short_le_keys(const struct reiserfs_key *,\n\t\t\t      const struct reiserfs_key *);",
            "void reiserfs_delete_solid_item(struct reiserfs_transaction_handle *th,\n\t\t\t\tstruct inode *inode, struct reiserfs_key *key);",
            "struct inode *reiserfs_iget(struct super_block *s, const struct cpu_key *key);",
            "int direct2indirect(struct reiserfs_transaction_handle *, struct inode *,\n\t\t    struct treepath *, struct buffer_head *, loff_t);",
            "int indirect2direct(struct reiserfs_transaction_handle *, struct inode *,\n\t\t    struct page *, struct treepath *, const struct cpu_key *,\n\t\t    loff_t, char *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/buffer_head.h>\n#include <linux/proc_fs.h>\n#include <linux/bitops.h>\n#include <asm/unaligned.h>\n#include <linux/workqueue.h>\n#include <linux/bug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/slab.h>\n#include <linux/reiserfs_fs.h>\n\n#define KEY_FORMAT_3_5 0\n\nextern int comp_le_keys(const struct reiserfs_key *,\n\t\t\tconst struct reiserfs_key *);\nextern int comp_short_le_keys(const struct reiserfs_key *,\n\t\t\t      const struct reiserfs_key *);\nvoid reiserfs_delete_solid_item(struct reiserfs_transaction_handle *th,\n\t\t\t\tstruct inode *inode, struct reiserfs_key *key);\nstruct inode *reiserfs_iget(struct super_block *s, const struct cpu_key *key);\nint direct2indirect(struct reiserfs_transaction_handle *, struct inode *,\n\t\t    struct treepath *, struct buffer_head *, loff_t);\nint indirect2direct(struct reiserfs_transaction_handle *, struct inode *,\n\t\t    struct page *, struct treepath *, const struct cpu_key *,\n\t\t    loff_t, char *);\n\nstatic inline void set_le_key_k_offset(int version, struct reiserfs_key *key,\n\t\t\t\t       loff_t offset)\n{\n\tif (version == KEY_FORMAT_3_5)\n\t\tkey->u.k_offset_v1.k_offset = cpu_to_le32(offset);\n\telse\n\t\tset_offset_v2_k_offset(&key->u.k_offset_v2, offset);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ih_version",
          "args": [
            "ih"
          ],
          "line": 1523
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/buffer_head.h>\n#include <linux/proc_fs.h>\n#include <linux/bitops.h>\n#include <asm/unaligned.h>\n#include <linux/workqueue.h>\n#include <linux/bug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/slab.h>\n#include <linux/reiserfs_fs.h>\n\nint direct2indirect(struct reiserfs_transaction_handle *, struct inode *,\n\t\t    struct treepath *, struct buffer_head *, loff_t);\nint indirect2direct(struct reiserfs_transaction_handle *, struct inode *,\n\t\t    struct page *, struct treepath *, const struct cpu_key *,\n\t\t    loff_t, char *);\n\nstatic inline void set_le_ih_k_offset(struct item_head *ih, loff_t offset)\n{\n\tset_le_key_k_offset(ih_version(ih), &(ih->ih_key), offset);\n}"
  },
  {
    "function_name": "add_le_ih_k_offset",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/reiserfs.h",
    "lines": "1516-1519",
    "snippet": "static inline void add_le_ih_k_offset(struct item_head *ih, loff_t offset)\n{\n\tadd_le_key_k_offset(ih_version(ih), &(ih->ih_key), offset);\n}",
    "includes": [
      "#include <linux/buffer_head.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/bitops.h>",
      "#include <asm/unaligned.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/bug.h>",
      "#include <linux/sched.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/slab.h>",
      "#include <linux/reiserfs_fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "int direct2indirect(struct reiserfs_transaction_handle *, struct inode *,\n\t\t    struct treepath *, struct buffer_head *, loff_t);",
      "int indirect2direct(struct reiserfs_transaction_handle *, struct inode *,\n\t\t    struct page *, struct treepath *, const struct cpu_key *,\n\t\t    loff_t, char *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "add_le_key_k_offset",
          "args": [
            "ih_version(ih)",
            "&(ih->ih_key)",
            "offset"
          ],
          "line": 1518
        },
        "resolved": true,
        "details": {
          "function_name": "add_le_key_k_offset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/reiserfs.h",
          "lines": "1509-1514",
          "snippet": "static inline void add_le_key_k_offset(int version, struct reiserfs_key *key,\n\t\t\t\t       loff_t offset)\n{\n\tset_le_key_k_offset(version, key,\n\t\t\t    le_key_k_offset(version, key) + offset);\n}",
          "includes": [
            "#include <linux/buffer_head.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/bitops.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/slab.h>",
            "#include <linux/reiserfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern int comp_le_keys(const struct reiserfs_key *,\n\t\t\tconst struct reiserfs_key *);",
            "extern int comp_short_le_keys(const struct reiserfs_key *,\n\t\t\t      const struct reiserfs_key *);",
            "void reiserfs_delete_solid_item(struct reiserfs_transaction_handle *th,\n\t\t\t\tstruct inode *inode, struct reiserfs_key *key);",
            "struct inode *reiserfs_iget(struct super_block *s, const struct cpu_key *key);",
            "int direct2indirect(struct reiserfs_transaction_handle *, struct inode *,\n\t\t    struct treepath *, struct buffer_head *, loff_t);",
            "int indirect2direct(struct reiserfs_transaction_handle *, struct inode *,\n\t\t    struct page *, struct treepath *, const struct cpu_key *,\n\t\t    loff_t, char *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/buffer_head.h>\n#include <linux/proc_fs.h>\n#include <linux/bitops.h>\n#include <asm/unaligned.h>\n#include <linux/workqueue.h>\n#include <linux/bug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/slab.h>\n#include <linux/reiserfs_fs.h>\n\nextern int comp_le_keys(const struct reiserfs_key *,\n\t\t\tconst struct reiserfs_key *);\nextern int comp_short_le_keys(const struct reiserfs_key *,\n\t\t\t      const struct reiserfs_key *);\nvoid reiserfs_delete_solid_item(struct reiserfs_transaction_handle *th,\n\t\t\t\tstruct inode *inode, struct reiserfs_key *key);\nstruct inode *reiserfs_iget(struct super_block *s, const struct cpu_key *key);\nint direct2indirect(struct reiserfs_transaction_handle *, struct inode *,\n\t\t    struct treepath *, struct buffer_head *, loff_t);\nint indirect2direct(struct reiserfs_transaction_handle *, struct inode *,\n\t\t    struct page *, struct treepath *, const struct cpu_key *,\n\t\t    loff_t, char *);\n\nstatic inline void add_le_key_k_offset(int version, struct reiserfs_key *key,\n\t\t\t\t       loff_t offset)\n{\n\tset_le_key_k_offset(version, key,\n\t\t\t    le_key_k_offset(version, key) + offset);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ih_version",
          "args": [
            "ih"
          ],
          "line": 1518
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/buffer_head.h>\n#include <linux/proc_fs.h>\n#include <linux/bitops.h>\n#include <asm/unaligned.h>\n#include <linux/workqueue.h>\n#include <linux/bug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/slab.h>\n#include <linux/reiserfs_fs.h>\n\nint direct2indirect(struct reiserfs_transaction_handle *, struct inode *,\n\t\t    struct treepath *, struct buffer_head *, loff_t);\nint indirect2direct(struct reiserfs_transaction_handle *, struct inode *,\n\t\t    struct page *, struct treepath *, const struct cpu_key *,\n\t\t    loff_t, char *);\n\nstatic inline void add_le_ih_k_offset(struct item_head *ih, loff_t offset)\n{\n\tadd_le_key_k_offset(ih_version(ih), &(ih->ih_key), offset);\n}"
  },
  {
    "function_name": "add_le_key_k_offset",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/reiserfs.h",
    "lines": "1509-1514",
    "snippet": "static inline void add_le_key_k_offset(int version, struct reiserfs_key *key,\n\t\t\t\t       loff_t offset)\n{\n\tset_le_key_k_offset(version, key,\n\t\t\t    le_key_k_offset(version, key) + offset);\n}",
    "includes": [
      "#include <linux/buffer_head.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/bitops.h>",
      "#include <asm/unaligned.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/bug.h>",
      "#include <linux/sched.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/slab.h>",
      "#include <linux/reiserfs_fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "extern int comp_le_keys(const struct reiserfs_key *,\n\t\t\tconst struct reiserfs_key *);",
      "extern int comp_short_le_keys(const struct reiserfs_key *,\n\t\t\t      const struct reiserfs_key *);",
      "void reiserfs_delete_solid_item(struct reiserfs_transaction_handle *th,\n\t\t\t\tstruct inode *inode, struct reiserfs_key *key);",
      "struct inode *reiserfs_iget(struct super_block *s, const struct cpu_key *key);",
      "int direct2indirect(struct reiserfs_transaction_handle *, struct inode *,\n\t\t    struct treepath *, struct buffer_head *, loff_t);",
      "int indirect2direct(struct reiserfs_transaction_handle *, struct inode *,\n\t\t    struct page *, struct treepath *, const struct cpu_key *,\n\t\t    loff_t, char *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "set_le_key_k_offset",
          "args": [
            "version",
            "key",
            "le_key_k_offset(version, key) + offset"
          ],
          "line": 1512
        },
        "resolved": true,
        "details": {
          "function_name": "set_le_key_k_offset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/reiserfs.h",
          "lines": "1500-1507",
          "snippet": "static inline void set_le_key_k_offset(int version, struct reiserfs_key *key,\n\t\t\t\t       loff_t offset)\n{\n\tif (version == KEY_FORMAT_3_5)\n\t\tkey->u.k_offset_v1.k_offset = cpu_to_le32(offset);\n\telse\n\t\tset_offset_v2_k_offset(&key->u.k_offset_v2, offset);\n}",
          "includes": [
            "#include <linux/buffer_head.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/bitops.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/slab.h>",
            "#include <linux/reiserfs_fs.h>"
          ],
          "macros_used": [
            "#define KEY_FORMAT_3_5 0"
          ],
          "globals_used": [
            "extern int comp_le_keys(const struct reiserfs_key *,\n\t\t\tconst struct reiserfs_key *);",
            "extern int comp_short_le_keys(const struct reiserfs_key *,\n\t\t\t      const struct reiserfs_key *);",
            "void reiserfs_delete_solid_item(struct reiserfs_transaction_handle *th,\n\t\t\t\tstruct inode *inode, struct reiserfs_key *key);",
            "struct inode *reiserfs_iget(struct super_block *s, const struct cpu_key *key);",
            "int direct2indirect(struct reiserfs_transaction_handle *, struct inode *,\n\t\t    struct treepath *, struct buffer_head *, loff_t);",
            "int indirect2direct(struct reiserfs_transaction_handle *, struct inode *,\n\t\t    struct page *, struct treepath *, const struct cpu_key *,\n\t\t    loff_t, char *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/buffer_head.h>\n#include <linux/proc_fs.h>\n#include <linux/bitops.h>\n#include <asm/unaligned.h>\n#include <linux/workqueue.h>\n#include <linux/bug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/slab.h>\n#include <linux/reiserfs_fs.h>\n\n#define KEY_FORMAT_3_5 0\n\nextern int comp_le_keys(const struct reiserfs_key *,\n\t\t\tconst struct reiserfs_key *);\nextern int comp_short_le_keys(const struct reiserfs_key *,\n\t\t\t      const struct reiserfs_key *);\nvoid reiserfs_delete_solid_item(struct reiserfs_transaction_handle *th,\n\t\t\t\tstruct inode *inode, struct reiserfs_key *key);\nstruct inode *reiserfs_iget(struct super_block *s, const struct cpu_key *key);\nint direct2indirect(struct reiserfs_transaction_handle *, struct inode *,\n\t\t    struct treepath *, struct buffer_head *, loff_t);\nint indirect2direct(struct reiserfs_transaction_handle *, struct inode *,\n\t\t    struct page *, struct treepath *, const struct cpu_key *,\n\t\t    loff_t, char *);\n\nstatic inline void set_le_key_k_offset(int version, struct reiserfs_key *key,\n\t\t\t\t       loff_t offset)\n{\n\tif (version == KEY_FORMAT_3_5)\n\t\tkey->u.k_offset_v1.k_offset = cpu_to_le32(offset);\n\telse\n\t\tset_offset_v2_k_offset(&key->u.k_offset_v2, offset);\n}"
        }
      },
      {
        "call_info": {
          "callee": "le_key_k_offset",
          "args": [
            "version",
            "key"
          ],
          "line": 1513
        },
        "resolved": true,
        "details": {
          "function_name": "le_key_k_offset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/reiserfs.h",
          "lines": "1473-1479",
          "snippet": "static inline loff_t le_key_k_offset(int version,\n\t\t\t\t     const struct reiserfs_key *key)\n{\n\treturn (version == KEY_FORMAT_3_5) ?\n\t    le32_to_cpu(key->u.k_offset_v1.k_offset) :\n\t    offset_v2_k_offset(&(key->u.k_offset_v2));\n}",
          "includes": [
            "#include <linux/buffer_head.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/bitops.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/slab.h>",
            "#include <linux/reiserfs_fs.h>"
          ],
          "macros_used": [
            "#define KEY_FORMAT_3_5 0"
          ],
          "globals_used": [
            "extern int comp_le_keys(const struct reiserfs_key *,\n\t\t\tconst struct reiserfs_key *);",
            "extern int comp_short_le_keys(const struct reiserfs_key *,\n\t\t\t      const struct reiserfs_key *);",
            "void reiserfs_delete_solid_item(struct reiserfs_transaction_handle *th,\n\t\t\t\tstruct inode *inode, struct reiserfs_key *key);",
            "struct inode *reiserfs_iget(struct super_block *s, const struct cpu_key *key);",
            "int direct2indirect(struct reiserfs_transaction_handle *, struct inode *,\n\t\t    struct treepath *, struct buffer_head *, loff_t);",
            "int indirect2direct(struct reiserfs_transaction_handle *, struct inode *,\n\t\t    struct page *, struct treepath *, const struct cpu_key *,\n\t\t    loff_t, char *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/buffer_head.h>\n#include <linux/proc_fs.h>\n#include <linux/bitops.h>\n#include <asm/unaligned.h>\n#include <linux/workqueue.h>\n#include <linux/bug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/slab.h>\n#include <linux/reiserfs_fs.h>\n\n#define KEY_FORMAT_3_5 0\n\nextern int comp_le_keys(const struct reiserfs_key *,\n\t\t\tconst struct reiserfs_key *);\nextern int comp_short_le_keys(const struct reiserfs_key *,\n\t\t\t      const struct reiserfs_key *);\nvoid reiserfs_delete_solid_item(struct reiserfs_transaction_handle *th,\n\t\t\t\tstruct inode *inode, struct reiserfs_key *key);\nstruct inode *reiserfs_iget(struct super_block *s, const struct cpu_key *key);\nint direct2indirect(struct reiserfs_transaction_handle *, struct inode *,\n\t\t    struct treepath *, struct buffer_head *, loff_t);\nint indirect2direct(struct reiserfs_transaction_handle *, struct inode *,\n\t\t    struct page *, struct treepath *, const struct cpu_key *,\n\t\t    loff_t, char *);\n\nstatic inline loff_t le_key_k_offset(int version,\n\t\t\t\t     const struct reiserfs_key *key)\n{\n\treturn (version == KEY_FORMAT_3_5) ?\n\t    le32_to_cpu(key->u.k_offset_v1.k_offset) :\n\t    offset_v2_k_offset(&(key->u.k_offset_v2));\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/buffer_head.h>\n#include <linux/proc_fs.h>\n#include <linux/bitops.h>\n#include <asm/unaligned.h>\n#include <linux/workqueue.h>\n#include <linux/bug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/slab.h>\n#include <linux/reiserfs_fs.h>\n\nextern int comp_le_keys(const struct reiserfs_key *,\n\t\t\tconst struct reiserfs_key *);\nextern int comp_short_le_keys(const struct reiserfs_key *,\n\t\t\t      const struct reiserfs_key *);\nvoid reiserfs_delete_solid_item(struct reiserfs_transaction_handle *th,\n\t\t\t\tstruct inode *inode, struct reiserfs_key *key);\nstruct inode *reiserfs_iget(struct super_block *s, const struct cpu_key *key);\nint direct2indirect(struct reiserfs_transaction_handle *, struct inode *,\n\t\t    struct treepath *, struct buffer_head *, loff_t);\nint indirect2direct(struct reiserfs_transaction_handle *, struct inode *,\n\t\t    struct page *, struct treepath *, const struct cpu_key *,\n\t\t    loff_t, char *);\n\nstatic inline void add_le_key_k_offset(int version, struct reiserfs_key *key,\n\t\t\t\t       loff_t offset)\n{\n\tset_le_key_k_offset(version, key,\n\t\t\t    le_key_k_offset(version, key) + offset);\n}"
  },
  {
    "function_name": "set_le_key_k_offset",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/reiserfs.h",
    "lines": "1500-1507",
    "snippet": "static inline void set_le_key_k_offset(int version, struct reiserfs_key *key,\n\t\t\t\t       loff_t offset)\n{\n\tif (version == KEY_FORMAT_3_5)\n\t\tkey->u.k_offset_v1.k_offset = cpu_to_le32(offset);\n\telse\n\t\tset_offset_v2_k_offset(&key->u.k_offset_v2, offset);\n}",
    "includes": [
      "#include <linux/buffer_head.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/bitops.h>",
      "#include <asm/unaligned.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/bug.h>",
      "#include <linux/sched.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/slab.h>",
      "#include <linux/reiserfs_fs.h>"
    ],
    "macros_used": [
      "#define KEY_FORMAT_3_5 0"
    ],
    "globals_used": [
      "extern int comp_le_keys(const struct reiserfs_key *,\n\t\t\tconst struct reiserfs_key *);",
      "extern int comp_short_le_keys(const struct reiserfs_key *,\n\t\t\t      const struct reiserfs_key *);",
      "void reiserfs_delete_solid_item(struct reiserfs_transaction_handle *th,\n\t\t\t\tstruct inode *inode, struct reiserfs_key *key);",
      "struct inode *reiserfs_iget(struct super_block *s, const struct cpu_key *key);",
      "int direct2indirect(struct reiserfs_transaction_handle *, struct inode *,\n\t\t    struct treepath *, struct buffer_head *, loff_t);",
      "int indirect2direct(struct reiserfs_transaction_handle *, struct inode *,\n\t\t    struct page *, struct treepath *, const struct cpu_key *,\n\t\t    loff_t, char *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "set_offset_v2_k_offset",
          "args": [
            "&key->u.k_offset_v2",
            "offset"
          ],
          "line": 1506
        },
        "resolved": true,
        "details": {
          "function_name": "set_offset_v2_k_offset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/reiserfs.h",
          "lines": "1277-1281",
          "snippet": "static inline void set_offset_v2_k_offset(struct offset_v2 *v2, loff_t offset)\n{\n\toffset &= (~0ULL >> 4);\n\tv2->v = (v2->v & cpu_to_le64(15ULL << 60)) | cpu_to_le64(offset);\n}",
          "includes": [
            "#include <linux/buffer_head.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/bitops.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/slab.h>",
            "#include <linux/reiserfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int direct2indirect(struct reiserfs_transaction_handle *, struct inode *,\n\t\t    struct treepath *, struct buffer_head *, loff_t);",
            "int indirect2direct(struct reiserfs_transaction_handle *, struct inode *,\n\t\t    struct page *, struct treepath *, const struct cpu_key *,\n\t\t    loff_t, char *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/buffer_head.h>\n#include <linux/proc_fs.h>\n#include <linux/bitops.h>\n#include <asm/unaligned.h>\n#include <linux/workqueue.h>\n#include <linux/bug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/slab.h>\n#include <linux/reiserfs_fs.h>\n\nint direct2indirect(struct reiserfs_transaction_handle *, struct inode *,\n\t\t    struct treepath *, struct buffer_head *, loff_t);\nint indirect2direct(struct reiserfs_transaction_handle *, struct inode *,\n\t\t    struct page *, struct treepath *, const struct cpu_key *,\n\t\t    loff_t, char *);\n\nstatic inline void set_offset_v2_k_offset(struct offset_v2 *v2, loff_t offset)\n{\n\toffset &= (~0ULL >> 4);\n\tv2->v = (v2->v & cpu_to_le64(15ULL << 60)) | cpu_to_le64(offset);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "offset"
          ],
          "line": 1504
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/buffer_head.h>\n#include <linux/proc_fs.h>\n#include <linux/bitops.h>\n#include <asm/unaligned.h>\n#include <linux/workqueue.h>\n#include <linux/bug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/slab.h>\n#include <linux/reiserfs_fs.h>\n\n#define KEY_FORMAT_3_5 0\n\nextern int comp_le_keys(const struct reiserfs_key *,\n\t\t\tconst struct reiserfs_key *);\nextern int comp_short_le_keys(const struct reiserfs_key *,\n\t\t\t      const struct reiserfs_key *);\nvoid reiserfs_delete_solid_item(struct reiserfs_transaction_handle *th,\n\t\t\t\tstruct inode *inode, struct reiserfs_key *key);\nstruct inode *reiserfs_iget(struct super_block *s, const struct cpu_key *key);\nint direct2indirect(struct reiserfs_transaction_handle *, struct inode *,\n\t\t    struct treepath *, struct buffer_head *, loff_t);\nint indirect2direct(struct reiserfs_transaction_handle *, struct inode *,\n\t\t    struct page *, struct treepath *, const struct cpu_key *,\n\t\t    loff_t, char *);\n\nstatic inline void set_le_key_k_offset(int version, struct reiserfs_key *key,\n\t\t\t\t       loff_t offset)\n{\n\tif (version == KEY_FORMAT_3_5)\n\t\tkey->u.k_offset_v1.k_offset = cpu_to_le32(offset);\n\telse\n\t\tset_offset_v2_k_offset(&key->u.k_offset_v2, offset);\n}"
  },
  {
    "function_name": "le_ih_k_type",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/reiserfs.h",
    "lines": "1495-1498",
    "snippet": "static inline loff_t le_ih_k_type(const struct item_head *ih)\n{\n\treturn le_key_k_type(ih_version(ih), &(ih->ih_key));\n}",
    "includes": [
      "#include <linux/buffer_head.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/bitops.h>",
      "#include <asm/unaligned.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/bug.h>",
      "#include <linux/sched.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/slab.h>",
      "#include <linux/reiserfs_fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "int direct2indirect(struct reiserfs_transaction_handle *, struct inode *,\n\t\t    struct treepath *, struct buffer_head *, loff_t);",
      "int indirect2direct(struct reiserfs_transaction_handle *, struct inode *,\n\t\t    struct page *, struct treepath *, const struct cpu_key *,\n\t\t    loff_t, char *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "le_key_k_type",
          "args": [
            "ih_version(ih)",
            "&(ih->ih_key)"
          ],
          "line": 1497
        },
        "resolved": true,
        "details": {
          "function_name": "le_key_k_type",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/reiserfs.h",
          "lines": "1486-1493",
          "snippet": "static inline loff_t le_key_k_type(int version, const struct reiserfs_key *key)\n{\n\tif (version == KEY_FORMAT_3_5) {\n\t\tloff_t val = le32_to_cpu(key->u.k_offset_v1.k_uniqueness);\n\t\treturn uniqueness2type(val);\n\t} else\n\t\treturn offset_v2_k_type(&(key->u.k_offset_v2));\n}",
          "includes": [
            "#include <linux/buffer_head.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/bitops.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/slab.h>",
            "#include <linux/reiserfs_fs.h>"
          ],
          "macros_used": [
            "#define KEY_FORMAT_3_5 0"
          ],
          "globals_used": [
            "extern int comp_le_keys(const struct reiserfs_key *,\n\t\t\tconst struct reiserfs_key *);",
            "extern int comp_short_le_keys(const struct reiserfs_key *,\n\t\t\t      const struct reiserfs_key *);",
            "void reiserfs_delete_solid_item(struct reiserfs_transaction_handle *th,\n\t\t\t\tstruct inode *inode, struct reiserfs_key *key);",
            "struct inode *reiserfs_iget(struct super_block *s, const struct cpu_key *key);",
            "int direct2indirect(struct reiserfs_transaction_handle *, struct inode *,\n\t\t    struct treepath *, struct buffer_head *, loff_t);",
            "int indirect2direct(struct reiserfs_transaction_handle *, struct inode *,\n\t\t    struct page *, struct treepath *, const struct cpu_key *,\n\t\t    loff_t, char *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/buffer_head.h>\n#include <linux/proc_fs.h>\n#include <linux/bitops.h>\n#include <asm/unaligned.h>\n#include <linux/workqueue.h>\n#include <linux/bug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/slab.h>\n#include <linux/reiserfs_fs.h>\n\n#define KEY_FORMAT_3_5 0\n\nextern int comp_le_keys(const struct reiserfs_key *,\n\t\t\tconst struct reiserfs_key *);\nextern int comp_short_le_keys(const struct reiserfs_key *,\n\t\t\t      const struct reiserfs_key *);\nvoid reiserfs_delete_solid_item(struct reiserfs_transaction_handle *th,\n\t\t\t\tstruct inode *inode, struct reiserfs_key *key);\nstruct inode *reiserfs_iget(struct super_block *s, const struct cpu_key *key);\nint direct2indirect(struct reiserfs_transaction_handle *, struct inode *,\n\t\t    struct treepath *, struct buffer_head *, loff_t);\nint indirect2direct(struct reiserfs_transaction_handle *, struct inode *,\n\t\t    struct page *, struct treepath *, const struct cpu_key *,\n\t\t    loff_t, char *);\n\nstatic inline loff_t le_key_k_type(int version, const struct reiserfs_key *key)\n{\n\tif (version == KEY_FORMAT_3_5) {\n\t\tloff_t val = le32_to_cpu(key->u.k_offset_v1.k_uniqueness);\n\t\treturn uniqueness2type(val);\n\t} else\n\t\treturn offset_v2_k_type(&(key->u.k_offset_v2));\n}"
        }
      },
      {
        "call_info": {
          "callee": "ih_version",
          "args": [
            "ih"
          ],
          "line": 1497
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/buffer_head.h>\n#include <linux/proc_fs.h>\n#include <linux/bitops.h>\n#include <asm/unaligned.h>\n#include <linux/workqueue.h>\n#include <linux/bug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/slab.h>\n#include <linux/reiserfs_fs.h>\n\nint direct2indirect(struct reiserfs_transaction_handle *, struct inode *,\n\t\t    struct treepath *, struct buffer_head *, loff_t);\nint indirect2direct(struct reiserfs_transaction_handle *, struct inode *,\n\t\t    struct page *, struct treepath *, const struct cpu_key *,\n\t\t    loff_t, char *);\n\nstatic inline loff_t le_ih_k_type(const struct item_head *ih)\n{\n\treturn le_key_k_type(ih_version(ih), &(ih->ih_key));\n}"
  },
  {
    "function_name": "le_key_k_type",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/reiserfs.h",
    "lines": "1486-1493",
    "snippet": "static inline loff_t le_key_k_type(int version, const struct reiserfs_key *key)\n{\n\tif (version == KEY_FORMAT_3_5) {\n\t\tloff_t val = le32_to_cpu(key->u.k_offset_v1.k_uniqueness);\n\t\treturn uniqueness2type(val);\n\t} else\n\t\treturn offset_v2_k_type(&(key->u.k_offset_v2));\n}",
    "includes": [
      "#include <linux/buffer_head.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/bitops.h>",
      "#include <asm/unaligned.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/bug.h>",
      "#include <linux/sched.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/slab.h>",
      "#include <linux/reiserfs_fs.h>"
    ],
    "macros_used": [
      "#define KEY_FORMAT_3_5 0"
    ],
    "globals_used": [
      "extern int comp_le_keys(const struct reiserfs_key *,\n\t\t\tconst struct reiserfs_key *);",
      "extern int comp_short_le_keys(const struct reiserfs_key *,\n\t\t\t      const struct reiserfs_key *);",
      "void reiserfs_delete_solid_item(struct reiserfs_transaction_handle *th,\n\t\t\t\tstruct inode *inode, struct reiserfs_key *key);",
      "struct inode *reiserfs_iget(struct super_block *s, const struct cpu_key *key);",
      "int direct2indirect(struct reiserfs_transaction_handle *, struct inode *,\n\t\t    struct treepath *, struct buffer_head *, loff_t);",
      "int indirect2direct(struct reiserfs_transaction_handle *, struct inode *,\n\t\t    struct page *, struct treepath *, const struct cpu_key *,\n\t\t    loff_t, char *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "offset_v2_k_type",
          "args": [
            "&(key->u.k_offset_v2)"
          ],
          "line": 1492
        },
        "resolved": true,
        "details": {
          "function_name": "offset_v2_k_type",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/reiserfs.h",
          "lines": "1260-1264",
          "snippet": "static inline __u16 offset_v2_k_type(const struct offset_v2 *v2)\n{\n\t__u8 type = le64_to_cpu(v2->v) >> 60;\n\treturn (type <= TYPE_MAXTYPE) ? type : TYPE_ANY;\n}",
          "includes": [
            "#include <linux/buffer_head.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/bitops.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/slab.h>",
            "#include <linux/reiserfs_fs.h>"
          ],
          "macros_used": [
            "#define TYPE_ANY 15\t\t/* FIXME: comment is required */",
            "#define TYPE_MAXTYPE 3"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/buffer_head.h>\n#include <linux/proc_fs.h>\n#include <linux/bitops.h>\n#include <asm/unaligned.h>\n#include <linux/workqueue.h>\n#include <linux/bug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/slab.h>\n#include <linux/reiserfs_fs.h>\n\n#define TYPE_ANY 15\t\t/* FIXME: comment is required */\n#define TYPE_MAXTYPE 3\n\nstatic inline __u16 offset_v2_k_type(const struct offset_v2 *v2)\n{\n\t__u8 type = le64_to_cpu(v2->v) >> 60;\n\treturn (type <= TYPE_MAXTYPE) ? type : TYPE_ANY;\n}"
        }
      },
      {
        "call_info": {
          "callee": "uniqueness2type",
          "args": [
            "val"
          ],
          "line": 1490
        },
        "resolved": true,
        "details": {
          "function_name": "uniqueness2type",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/reiserfs.h",
          "lines": "1433-1448",
          "snippet": "static inline int uniqueness2type(__u32 uniqueness)\n{\n\tswitch ((int)uniqueness) {\n\tcase V1_SD_UNIQUENESS:\n\t\treturn TYPE_STAT_DATA;\n\tcase V1_INDIRECT_UNIQUENESS:\n\t\treturn TYPE_INDIRECT;\n\tcase V1_DIRECT_UNIQUENESS:\n\t\treturn TYPE_DIRECT;\n\tcase V1_DIRENTRY_UNIQUENESS:\n\t\treturn TYPE_DIRENTRY;\n\tcase V1_ANY_UNIQUENESS:\n\tdefault:\n\t\treturn TYPE_ANY;\n\t}\n}",
          "includes": [
            "#include <linux/buffer_head.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/bitops.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/slab.h>",
            "#include <linux/reiserfs_fs.h>"
          ],
          "macros_used": [
            "#define V1_ANY_UNIQUENESS 555\t/* FIXME: comment is required */",
            "#define V1_DIRENTRY_UNIQUENESS 500",
            "#define V1_DIRECT_UNIQUENESS 0xffffffff",
            "#define V1_INDIRECT_UNIQUENESS 0xfffffffe",
            "#define V1_SD_UNIQUENESS 0",
            "#define TYPE_ANY 15\t\t/* FIXME: comment is required */",
            "#define TYPE_DIRENTRY 3",
            "#define TYPE_DIRECT 2",
            "#define TYPE_INDIRECT 1",
            "#define TYPE_STAT_DATA 0"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/buffer_head.h>\n#include <linux/proc_fs.h>\n#include <linux/bitops.h>\n#include <asm/unaligned.h>\n#include <linux/workqueue.h>\n#include <linux/bug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/slab.h>\n#include <linux/reiserfs_fs.h>\n\n#define V1_ANY_UNIQUENESS 555\t/* FIXME: comment is required */\n#define V1_DIRENTRY_UNIQUENESS 500\n#define V1_DIRECT_UNIQUENESS 0xffffffff\n#define V1_INDIRECT_UNIQUENESS 0xfffffffe\n#define V1_SD_UNIQUENESS 0\n#define TYPE_ANY 15\t\t/* FIXME: comment is required */\n#define TYPE_DIRENTRY 3\n#define TYPE_DIRECT 2\n#define TYPE_INDIRECT 1\n#define TYPE_STAT_DATA 0\n\nstatic inline int uniqueness2type(__u32 uniqueness)\n{\n\tswitch ((int)uniqueness) {\n\tcase V1_SD_UNIQUENESS:\n\t\treturn TYPE_STAT_DATA;\n\tcase V1_INDIRECT_UNIQUENESS:\n\t\treturn TYPE_INDIRECT;\n\tcase V1_DIRECT_UNIQUENESS:\n\t\treturn TYPE_DIRECT;\n\tcase V1_DIRENTRY_UNIQUENESS:\n\t\treturn TYPE_DIRENTRY;\n\tcase V1_ANY_UNIQUENESS:\n\tdefault:\n\t\treturn TYPE_ANY;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "key->u.k_offset_v1.k_uniqueness"
          ],
          "line": 1489
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/buffer_head.h>\n#include <linux/proc_fs.h>\n#include <linux/bitops.h>\n#include <asm/unaligned.h>\n#include <linux/workqueue.h>\n#include <linux/bug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/slab.h>\n#include <linux/reiserfs_fs.h>\n\n#define KEY_FORMAT_3_5 0\n\nextern int comp_le_keys(const struct reiserfs_key *,\n\t\t\tconst struct reiserfs_key *);\nextern int comp_short_le_keys(const struct reiserfs_key *,\n\t\t\t      const struct reiserfs_key *);\nvoid reiserfs_delete_solid_item(struct reiserfs_transaction_handle *th,\n\t\t\t\tstruct inode *inode, struct reiserfs_key *key);\nstruct inode *reiserfs_iget(struct super_block *s, const struct cpu_key *key);\nint direct2indirect(struct reiserfs_transaction_handle *, struct inode *,\n\t\t    struct treepath *, struct buffer_head *, loff_t);\nint indirect2direct(struct reiserfs_transaction_handle *, struct inode *,\n\t\t    struct page *, struct treepath *, const struct cpu_key *,\n\t\t    loff_t, char *);\n\nstatic inline loff_t le_key_k_type(int version, const struct reiserfs_key *key)\n{\n\tif (version == KEY_FORMAT_3_5) {\n\t\tloff_t val = le32_to_cpu(key->u.k_offset_v1.k_uniqueness);\n\t\treturn uniqueness2type(val);\n\t} else\n\t\treturn offset_v2_k_type(&(key->u.k_offset_v2));\n}"
  },
  {
    "function_name": "le_ih_k_offset",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/reiserfs.h",
    "lines": "1481-1484",
    "snippet": "static inline loff_t le_ih_k_offset(const struct item_head *ih)\n{\n\treturn le_key_k_offset(ih_version(ih), &(ih->ih_key));\n}",
    "includes": [
      "#include <linux/buffer_head.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/bitops.h>",
      "#include <asm/unaligned.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/bug.h>",
      "#include <linux/sched.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/slab.h>",
      "#include <linux/reiserfs_fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "int direct2indirect(struct reiserfs_transaction_handle *, struct inode *,\n\t\t    struct treepath *, struct buffer_head *, loff_t);",
      "int indirect2direct(struct reiserfs_transaction_handle *, struct inode *,\n\t\t    struct page *, struct treepath *, const struct cpu_key *,\n\t\t    loff_t, char *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "le_key_k_offset",
          "args": [
            "ih_version(ih)",
            "&(ih->ih_key)"
          ],
          "line": 1483
        },
        "resolved": true,
        "details": {
          "function_name": "le_key_k_offset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/reiserfs.h",
          "lines": "1473-1479",
          "snippet": "static inline loff_t le_key_k_offset(int version,\n\t\t\t\t     const struct reiserfs_key *key)\n{\n\treturn (version == KEY_FORMAT_3_5) ?\n\t    le32_to_cpu(key->u.k_offset_v1.k_offset) :\n\t    offset_v2_k_offset(&(key->u.k_offset_v2));\n}",
          "includes": [
            "#include <linux/buffer_head.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/bitops.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/slab.h>",
            "#include <linux/reiserfs_fs.h>"
          ],
          "macros_used": [
            "#define KEY_FORMAT_3_5 0"
          ],
          "globals_used": [
            "extern int comp_le_keys(const struct reiserfs_key *,\n\t\t\tconst struct reiserfs_key *);",
            "extern int comp_short_le_keys(const struct reiserfs_key *,\n\t\t\t      const struct reiserfs_key *);",
            "void reiserfs_delete_solid_item(struct reiserfs_transaction_handle *th,\n\t\t\t\tstruct inode *inode, struct reiserfs_key *key);",
            "struct inode *reiserfs_iget(struct super_block *s, const struct cpu_key *key);",
            "int direct2indirect(struct reiserfs_transaction_handle *, struct inode *,\n\t\t    struct treepath *, struct buffer_head *, loff_t);",
            "int indirect2direct(struct reiserfs_transaction_handle *, struct inode *,\n\t\t    struct page *, struct treepath *, const struct cpu_key *,\n\t\t    loff_t, char *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/buffer_head.h>\n#include <linux/proc_fs.h>\n#include <linux/bitops.h>\n#include <asm/unaligned.h>\n#include <linux/workqueue.h>\n#include <linux/bug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/slab.h>\n#include <linux/reiserfs_fs.h>\n\n#define KEY_FORMAT_3_5 0\n\nextern int comp_le_keys(const struct reiserfs_key *,\n\t\t\tconst struct reiserfs_key *);\nextern int comp_short_le_keys(const struct reiserfs_key *,\n\t\t\t      const struct reiserfs_key *);\nvoid reiserfs_delete_solid_item(struct reiserfs_transaction_handle *th,\n\t\t\t\tstruct inode *inode, struct reiserfs_key *key);\nstruct inode *reiserfs_iget(struct super_block *s, const struct cpu_key *key);\nint direct2indirect(struct reiserfs_transaction_handle *, struct inode *,\n\t\t    struct treepath *, struct buffer_head *, loff_t);\nint indirect2direct(struct reiserfs_transaction_handle *, struct inode *,\n\t\t    struct page *, struct treepath *, const struct cpu_key *,\n\t\t    loff_t, char *);\n\nstatic inline loff_t le_key_k_offset(int version,\n\t\t\t\t     const struct reiserfs_key *key)\n{\n\treturn (version == KEY_FORMAT_3_5) ?\n\t    le32_to_cpu(key->u.k_offset_v1.k_offset) :\n\t    offset_v2_k_offset(&(key->u.k_offset_v2));\n}"
        }
      },
      {
        "call_info": {
          "callee": "ih_version",
          "args": [
            "ih"
          ],
          "line": 1483
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/buffer_head.h>\n#include <linux/proc_fs.h>\n#include <linux/bitops.h>\n#include <asm/unaligned.h>\n#include <linux/workqueue.h>\n#include <linux/bug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/slab.h>\n#include <linux/reiserfs_fs.h>\n\nint direct2indirect(struct reiserfs_transaction_handle *, struct inode *,\n\t\t    struct treepath *, struct buffer_head *, loff_t);\nint indirect2direct(struct reiserfs_transaction_handle *, struct inode *,\n\t\t    struct page *, struct treepath *, const struct cpu_key *,\n\t\t    loff_t, char *);\n\nstatic inline loff_t le_ih_k_offset(const struct item_head *ih)\n{\n\treturn le_key_k_offset(ih_version(ih), &(ih->ih_key));\n}"
  },
  {
    "function_name": "le_key_k_offset",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/reiserfs.h",
    "lines": "1473-1479",
    "snippet": "static inline loff_t le_key_k_offset(int version,\n\t\t\t\t     const struct reiserfs_key *key)\n{\n\treturn (version == KEY_FORMAT_3_5) ?\n\t    le32_to_cpu(key->u.k_offset_v1.k_offset) :\n\t    offset_v2_k_offset(&(key->u.k_offset_v2));\n}",
    "includes": [
      "#include <linux/buffer_head.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/bitops.h>",
      "#include <asm/unaligned.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/bug.h>",
      "#include <linux/sched.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/slab.h>",
      "#include <linux/reiserfs_fs.h>"
    ],
    "macros_used": [
      "#define KEY_FORMAT_3_5 0"
    ],
    "globals_used": [
      "extern int comp_le_keys(const struct reiserfs_key *,\n\t\t\tconst struct reiserfs_key *);",
      "extern int comp_short_le_keys(const struct reiserfs_key *,\n\t\t\t      const struct reiserfs_key *);",
      "void reiserfs_delete_solid_item(struct reiserfs_transaction_handle *th,\n\t\t\t\tstruct inode *inode, struct reiserfs_key *key);",
      "struct inode *reiserfs_iget(struct super_block *s, const struct cpu_key *key);",
      "int direct2indirect(struct reiserfs_transaction_handle *, struct inode *,\n\t\t    struct treepath *, struct buffer_head *, loff_t);",
      "int indirect2direct(struct reiserfs_transaction_handle *, struct inode *,\n\t\t    struct page *, struct treepath *, const struct cpu_key *,\n\t\t    loff_t, char *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "offset_v2_k_offset",
          "args": [
            "&(key->u.k_offset_v2)"
          ],
          "line": 1478
        },
        "resolved": true,
        "details": {
          "function_name": "offset_v2_k_offset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/reiserfs.h",
          "lines": "1272-1275",
          "snippet": "static inline loff_t offset_v2_k_offset(const struct offset_v2 *v2)\n{\n\treturn le64_to_cpu(v2->v) & (~0ULL >> 4);\n}",
          "includes": [
            "#include <linux/buffer_head.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/bitops.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/slab.h>",
            "#include <linux/reiserfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int direct2indirect(struct reiserfs_transaction_handle *, struct inode *,\n\t\t    struct treepath *, struct buffer_head *, loff_t);",
            "int indirect2direct(struct reiserfs_transaction_handle *, struct inode *,\n\t\t    struct page *, struct treepath *, const struct cpu_key *,\n\t\t    loff_t, char *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/buffer_head.h>\n#include <linux/proc_fs.h>\n#include <linux/bitops.h>\n#include <asm/unaligned.h>\n#include <linux/workqueue.h>\n#include <linux/bug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/slab.h>\n#include <linux/reiserfs_fs.h>\n\nint direct2indirect(struct reiserfs_transaction_handle *, struct inode *,\n\t\t    struct treepath *, struct buffer_head *, loff_t);\nint indirect2direct(struct reiserfs_transaction_handle *, struct inode *,\n\t\t    struct page *, struct treepath *, const struct cpu_key *,\n\t\t    loff_t, char *);\n\nstatic inline loff_t offset_v2_k_offset(const struct offset_v2 *v2)\n{\n\treturn le64_to_cpu(v2->v) & (~0ULL >> 4);\n}"
        }
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "key->u.k_offset_v1.k_offset"
          ],
          "line": 1477
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/buffer_head.h>\n#include <linux/proc_fs.h>\n#include <linux/bitops.h>\n#include <asm/unaligned.h>\n#include <linux/workqueue.h>\n#include <linux/bug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/slab.h>\n#include <linux/reiserfs_fs.h>\n\n#define KEY_FORMAT_3_5 0\n\nextern int comp_le_keys(const struct reiserfs_key *,\n\t\t\tconst struct reiserfs_key *);\nextern int comp_short_le_keys(const struct reiserfs_key *,\n\t\t\t      const struct reiserfs_key *);\nvoid reiserfs_delete_solid_item(struct reiserfs_transaction_handle *th,\n\t\t\t\tstruct inode *inode, struct reiserfs_key *key);\nstruct inode *reiserfs_iget(struct super_block *s, const struct cpu_key *key);\nint direct2indirect(struct reiserfs_transaction_handle *, struct inode *,\n\t\t    struct treepath *, struct buffer_head *, loff_t);\nint indirect2direct(struct reiserfs_transaction_handle *, struct inode *,\n\t\t    struct page *, struct treepath *, const struct cpu_key *,\n\t\t    loff_t, char *);\n\nstatic inline loff_t le_key_k_offset(int version,\n\t\t\t\t     const struct reiserfs_key *key)\n{\n\treturn (version == KEY_FORMAT_3_5) ?\n\t    le32_to_cpu(key->u.k_offset_v1.k_offset) :\n\t    offset_v2_k_offset(&(key->u.k_offset_v2));\n}"
  },
  {
    "function_name": "type2uniqueness",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/reiserfs.h",
    "lines": "1451-1466",
    "snippet": "static inline __u32 type2uniqueness(int type)\n{\n\tswitch (type) {\n\tcase TYPE_STAT_DATA:\n\t\treturn V1_SD_UNIQUENESS;\n\tcase TYPE_INDIRECT:\n\t\treturn V1_INDIRECT_UNIQUENESS;\n\tcase TYPE_DIRECT:\n\t\treturn V1_DIRECT_UNIQUENESS;\n\tcase TYPE_DIRENTRY:\n\t\treturn V1_DIRENTRY_UNIQUENESS;\n\tcase TYPE_ANY:\n\tdefault:\n\t\treturn V1_ANY_UNIQUENESS;\n\t}\n}",
    "includes": [
      "#include <linux/buffer_head.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/bitops.h>",
      "#include <asm/unaligned.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/bug.h>",
      "#include <linux/sched.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/slab.h>",
      "#include <linux/reiserfs_fs.h>"
    ],
    "macros_used": [
      "#define V1_ANY_UNIQUENESS 555\t/* FIXME: comment is required */",
      "#define V1_DIRENTRY_UNIQUENESS 500",
      "#define V1_DIRECT_UNIQUENESS 0xffffffff",
      "#define V1_INDIRECT_UNIQUENESS 0xfffffffe",
      "#define V1_SD_UNIQUENESS 0",
      "#define TYPE_ANY 15\t\t/* FIXME: comment is required */",
      "#define TYPE_DIRENTRY 3",
      "#define TYPE_DIRECT 2",
      "#define TYPE_INDIRECT 1",
      "#define TYPE_STAT_DATA 0"
    ],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/buffer_head.h>\n#include <linux/proc_fs.h>\n#include <linux/bitops.h>\n#include <asm/unaligned.h>\n#include <linux/workqueue.h>\n#include <linux/bug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/slab.h>\n#include <linux/reiserfs_fs.h>\n\n#define V1_ANY_UNIQUENESS 555\t/* FIXME: comment is required */\n#define V1_DIRENTRY_UNIQUENESS 500\n#define V1_DIRECT_UNIQUENESS 0xffffffff\n#define V1_INDIRECT_UNIQUENESS 0xfffffffe\n#define V1_SD_UNIQUENESS 0\n#define TYPE_ANY 15\t\t/* FIXME: comment is required */\n#define TYPE_DIRENTRY 3\n#define TYPE_DIRECT 2\n#define TYPE_INDIRECT 1\n#define TYPE_STAT_DATA 0\n\nstatic inline __u32 type2uniqueness(int type)\n{\n\tswitch (type) {\n\tcase TYPE_STAT_DATA:\n\t\treturn V1_SD_UNIQUENESS;\n\tcase TYPE_INDIRECT:\n\t\treturn V1_INDIRECT_UNIQUENESS;\n\tcase TYPE_DIRECT:\n\t\treturn V1_DIRECT_UNIQUENESS;\n\tcase TYPE_DIRENTRY:\n\t\treturn V1_DIRENTRY_UNIQUENESS;\n\tcase TYPE_ANY:\n\tdefault:\n\t\treturn V1_ANY_UNIQUENESS;\n\t}\n}"
  },
  {
    "function_name": "uniqueness2type",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/reiserfs.h",
    "lines": "1433-1448",
    "snippet": "static inline int uniqueness2type(__u32 uniqueness)\n{\n\tswitch ((int)uniqueness) {\n\tcase V1_SD_UNIQUENESS:\n\t\treturn TYPE_STAT_DATA;\n\tcase V1_INDIRECT_UNIQUENESS:\n\t\treturn TYPE_INDIRECT;\n\tcase V1_DIRECT_UNIQUENESS:\n\t\treturn TYPE_DIRECT;\n\tcase V1_DIRENTRY_UNIQUENESS:\n\t\treturn TYPE_DIRENTRY;\n\tcase V1_ANY_UNIQUENESS:\n\tdefault:\n\t\treturn TYPE_ANY;\n\t}\n}",
    "includes": [
      "#include <linux/buffer_head.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/bitops.h>",
      "#include <asm/unaligned.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/bug.h>",
      "#include <linux/sched.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/slab.h>",
      "#include <linux/reiserfs_fs.h>"
    ],
    "macros_used": [
      "#define V1_ANY_UNIQUENESS 555\t/* FIXME: comment is required */",
      "#define V1_DIRENTRY_UNIQUENESS 500",
      "#define V1_DIRECT_UNIQUENESS 0xffffffff",
      "#define V1_INDIRECT_UNIQUENESS 0xfffffffe",
      "#define V1_SD_UNIQUENESS 0",
      "#define TYPE_ANY 15\t\t/* FIXME: comment is required */",
      "#define TYPE_DIRENTRY 3",
      "#define TYPE_DIRECT 2",
      "#define TYPE_INDIRECT 1",
      "#define TYPE_STAT_DATA 0"
    ],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/buffer_head.h>\n#include <linux/proc_fs.h>\n#include <linux/bitops.h>\n#include <asm/unaligned.h>\n#include <linux/workqueue.h>\n#include <linux/bug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/slab.h>\n#include <linux/reiserfs_fs.h>\n\n#define V1_ANY_UNIQUENESS 555\t/* FIXME: comment is required */\n#define V1_DIRENTRY_UNIQUENESS 500\n#define V1_DIRECT_UNIQUENESS 0xffffffff\n#define V1_INDIRECT_UNIQUENESS 0xfffffffe\n#define V1_SD_UNIQUENESS 0\n#define TYPE_ANY 15\t\t/* FIXME: comment is required */\n#define TYPE_DIRENTRY 3\n#define TYPE_DIRECT 2\n#define TYPE_INDIRECT 1\n#define TYPE_STAT_DATA 0\n\nstatic inline int uniqueness2type(__u32 uniqueness)\n{\n\tswitch ((int)uniqueness) {\n\tcase V1_SD_UNIQUENESS:\n\t\treturn TYPE_STAT_DATA;\n\tcase V1_INDIRECT_UNIQUENESS:\n\t\treturn TYPE_INDIRECT;\n\tcase V1_DIRECT_UNIQUENESS:\n\t\treturn TYPE_DIRECT;\n\tcase V1_DIRENTRY_UNIQUENESS:\n\t\treturn TYPE_DIRENTRY;\n\tcase V1_ANY_UNIQUENESS:\n\tdefault:\n\t\treturn TYPE_ANY;\n\t}\n}"
  },
  {
    "function_name": "set_offset_v2_k_offset",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/reiserfs.h",
    "lines": "1277-1281",
    "snippet": "static inline void set_offset_v2_k_offset(struct offset_v2 *v2, loff_t offset)\n{\n\toffset &= (~0ULL >> 4);\n\tv2->v = (v2->v & cpu_to_le64(15ULL << 60)) | cpu_to_le64(offset);\n}",
    "includes": [
      "#include <linux/buffer_head.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/bitops.h>",
      "#include <asm/unaligned.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/bug.h>",
      "#include <linux/sched.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/slab.h>",
      "#include <linux/reiserfs_fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "int direct2indirect(struct reiserfs_transaction_handle *, struct inode *,\n\t\t    struct treepath *, struct buffer_head *, loff_t);",
      "int indirect2direct(struct reiserfs_transaction_handle *, struct inode *,\n\t\t    struct page *, struct treepath *, const struct cpu_key *,\n\t\t    loff_t, char *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "cpu_to_le64",
          "args": [
            "offset"
          ],
          "line": 1280
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le64",
          "args": [
            "15ULL << 60"
          ],
          "line": 1280
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/buffer_head.h>\n#include <linux/proc_fs.h>\n#include <linux/bitops.h>\n#include <asm/unaligned.h>\n#include <linux/workqueue.h>\n#include <linux/bug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/slab.h>\n#include <linux/reiserfs_fs.h>\n\nint direct2indirect(struct reiserfs_transaction_handle *, struct inode *,\n\t\t    struct treepath *, struct buffer_head *, loff_t);\nint indirect2direct(struct reiserfs_transaction_handle *, struct inode *,\n\t\t    struct page *, struct treepath *, const struct cpu_key *,\n\t\t    loff_t, char *);\n\nstatic inline void set_offset_v2_k_offset(struct offset_v2 *v2, loff_t offset)\n{\n\toffset &= (~0ULL >> 4);\n\tv2->v = (v2->v & cpu_to_le64(15ULL << 60)) | cpu_to_le64(offset);\n}"
  },
  {
    "function_name": "offset_v2_k_offset",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/reiserfs.h",
    "lines": "1272-1275",
    "snippet": "static inline loff_t offset_v2_k_offset(const struct offset_v2 *v2)\n{\n\treturn le64_to_cpu(v2->v) & (~0ULL >> 4);\n}",
    "includes": [
      "#include <linux/buffer_head.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/bitops.h>",
      "#include <asm/unaligned.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/bug.h>",
      "#include <linux/sched.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/slab.h>",
      "#include <linux/reiserfs_fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "int direct2indirect(struct reiserfs_transaction_handle *, struct inode *,\n\t\t    struct treepath *, struct buffer_head *, loff_t);",
      "int indirect2direct(struct reiserfs_transaction_handle *, struct inode *,\n\t\t    struct page *, struct treepath *, const struct cpu_key *,\n\t\t    loff_t, char *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "le64_to_cpu",
          "args": [
            "v2->v"
          ],
          "line": 1274
        },
        "resolved": true,
        "details": {
          "function_name": "sle64_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "58-61",
          "snippet": "static inline s64 sle64_to_cpup(sle64 *x)\n{\n\treturn le64_to_cpu(*(__force le64*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s64 sle64_to_cpup(sle64 *x)\n{\n\treturn le64_to_cpu(*(__force le64*)x);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/buffer_head.h>\n#include <linux/proc_fs.h>\n#include <linux/bitops.h>\n#include <asm/unaligned.h>\n#include <linux/workqueue.h>\n#include <linux/bug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/slab.h>\n#include <linux/reiserfs_fs.h>\n\nint direct2indirect(struct reiserfs_transaction_handle *, struct inode *,\n\t\t    struct treepath *, struct buffer_head *, loff_t);\nint indirect2direct(struct reiserfs_transaction_handle *, struct inode *,\n\t\t    struct page *, struct treepath *, const struct cpu_key *,\n\t\t    loff_t, char *);\n\nstatic inline loff_t offset_v2_k_offset(const struct offset_v2 *v2)\n{\n\treturn le64_to_cpu(v2->v) & (~0ULL >> 4);\n}"
  },
  {
    "function_name": "set_offset_v2_k_type",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/reiserfs.h",
    "lines": "1266-1270",
    "snippet": "static inline void set_offset_v2_k_type(struct offset_v2 *v2, int type)\n{\n\tv2->v =\n\t    (v2->v & cpu_to_le64(~0ULL >> 4)) | cpu_to_le64((__u64) type << 60);\n}",
    "includes": [
      "#include <linux/buffer_head.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/bitops.h>",
      "#include <asm/unaligned.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/bug.h>",
      "#include <linux/sched.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/slab.h>",
      "#include <linux/reiserfs_fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cpu_to_le64",
          "args": [
            "(__u64) type << 60"
          ],
          "line": 1269
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le64",
          "args": [
            "~0ULL >> 4"
          ],
          "line": 1269
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/buffer_head.h>\n#include <linux/proc_fs.h>\n#include <linux/bitops.h>\n#include <asm/unaligned.h>\n#include <linux/workqueue.h>\n#include <linux/bug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/slab.h>\n#include <linux/reiserfs_fs.h>\n\nstatic inline void set_offset_v2_k_type(struct offset_v2 *v2, int type)\n{\n\tv2->v =\n\t    (v2->v & cpu_to_le64(~0ULL >> 4)) | cpu_to_le64((__u64) type << 60);\n}"
  },
  {
    "function_name": "offset_v2_k_type",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/reiserfs.h",
    "lines": "1260-1264",
    "snippet": "static inline __u16 offset_v2_k_type(const struct offset_v2 *v2)\n{\n\t__u8 type = le64_to_cpu(v2->v) >> 60;\n\treturn (type <= TYPE_MAXTYPE) ? type : TYPE_ANY;\n}",
    "includes": [
      "#include <linux/buffer_head.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/bitops.h>",
      "#include <asm/unaligned.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/bug.h>",
      "#include <linux/sched.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/slab.h>",
      "#include <linux/reiserfs_fs.h>"
    ],
    "macros_used": [
      "#define TYPE_ANY 15\t\t/* FIXME: comment is required */",
      "#define TYPE_MAXTYPE 3"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "le64_to_cpu",
          "args": [
            "v2->v"
          ],
          "line": 1262
        },
        "resolved": true,
        "details": {
          "function_name": "sle64_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "58-61",
          "snippet": "static inline s64 sle64_to_cpup(sle64 *x)\n{\n\treturn le64_to_cpu(*(__force le64*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s64 sle64_to_cpup(sle64 *x)\n{\n\treturn le64_to_cpu(*(__force le64*)x);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/buffer_head.h>\n#include <linux/proc_fs.h>\n#include <linux/bitops.h>\n#include <asm/unaligned.h>\n#include <linux/workqueue.h>\n#include <linux/bug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/slab.h>\n#include <linux/reiserfs_fs.h>\n\n#define TYPE_ANY 15\t\t/* FIXME: comment is required */\n#define TYPE_MAXTYPE 3\n\nstatic inline __u16 offset_v2_k_type(const struct offset_v2 *v2)\n{\n\t__u8 type = le64_to_cpu(v2->v) >> 60;\n\treturn (type <= TYPE_MAXTYPE) ? type : TYPE_ANY;\n}"
  },
  {
    "function_name": "bmap_would_wrap",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/reiserfs.h",
    "lines": "1166-1169",
    "snippet": "static inline int bmap_would_wrap(unsigned bmap_nr)\n{\n\treturn bmap_nr > ((1LL << 16) - 1);\n}",
    "includes": [
      "#include <linux/buffer_head.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/bitops.h>",
      "#include <asm/unaligned.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/bug.h>",
      "#include <linux/sched.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/slab.h>",
      "#include <linux/reiserfs_fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/buffer_head.h>\n#include <linux/proc_fs.h>\n#include <linux/bitops.h>\n#include <asm/unaligned.h>\n#include <linux/workqueue.h>\n#include <linux/bug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/slab.h>\n#include <linux/reiserfs_fs.h>\n\nstatic inline int bmap_would_wrap(unsigned bmap_nr)\n{\n\treturn bmap_nr > ((1LL << 16) - 1);\n}"
  },
  {
    "function_name": "reiserfs_bmap_count",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/reiserfs.h",
    "lines": "1161-1164",
    "snippet": "static inline __u32 reiserfs_bmap_count(struct super_block *sb)\n{\n\treturn (SB_BLOCK_COUNT(sb) - 1) / (sb->s_blocksize * 8) + 1;\n}",
    "includes": [
      "#include <linux/buffer_head.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/bitops.h>",
      "#include <asm/unaligned.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/bug.h>",
      "#include <linux/sched.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/slab.h>",
      "#include <linux/reiserfs_fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "int reiserfs_resize(struct super_block *, unsigned long);",
      "void reiserfs_flush_old_commits(struct super_block *);",
      "int journal_release(struct reiserfs_transaction_handle *, struct super_block *);",
      "int journal_release_error(struct reiserfs_transaction_handle *,\n\t\t\t  struct super_block *);",
      "int journal_begin(struct reiserfs_transaction_handle *,\n\t\t  struct super_block *sb, unsigned long);",
      "int journal_join_abort(struct reiserfs_transaction_handle *,\n\t\t       struct super_block *sb);",
      "int reiserfs_convert_objectid_map_v1(struct super_block *);",
      "const struct reiserfs_key *get_rkey(const struct treepath *chk_path,\n\t\t\t\t    const struct super_block *sb);",
      "int reiserfs_parse_alloc_options(struct super_block *, char *);",
      "int reiserfs_init_bitmap_cache(struct super_block *sb);",
      "void reiserfs_free_bitmap_cache(struct super_block *sb);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "SB_BLOCK_COUNT",
          "args": [
            "sb"
          ],
          "line": 1163
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/buffer_head.h>\n#include <linux/proc_fs.h>\n#include <linux/bitops.h>\n#include <asm/unaligned.h>\n#include <linux/workqueue.h>\n#include <linux/bug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/slab.h>\n#include <linux/reiserfs_fs.h>\n\nint reiserfs_resize(struct super_block *, unsigned long);\nvoid reiserfs_flush_old_commits(struct super_block *);\nint journal_release(struct reiserfs_transaction_handle *, struct super_block *);\nint journal_release_error(struct reiserfs_transaction_handle *,\n\t\t\t  struct super_block *);\nint journal_begin(struct reiserfs_transaction_handle *,\n\t\t  struct super_block *sb, unsigned long);\nint journal_join_abort(struct reiserfs_transaction_handle *,\n\t\t       struct super_block *sb);\nint reiserfs_convert_objectid_map_v1(struct super_block *);\nconst struct reiserfs_key *get_rkey(const struct treepath *chk_path,\n\t\t\t\t    const struct super_block *sb);\nint reiserfs_parse_alloc_options(struct super_block *, char *);\nint reiserfs_init_bitmap_cache(struct super_block *sb);\nvoid reiserfs_free_bitmap_cache(struct super_block *sb);\n\nstatic inline __u32 reiserfs_bmap_count(struct super_block *sb)\n{\n\treturn (SB_BLOCK_COUNT(sb) - 1) / (sb->s_blocksize * 8) + 1;\n}"
  },
  {
    "function_name": "REISERFS_SB",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/reiserfs.h",
    "lines": "1152-1155",
    "snippet": "static inline struct reiserfs_sb_info *REISERFS_SB(const struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
    "includes": [
      "#include <linux/buffer_head.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/bitops.h>",
      "#include <asm/unaligned.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/bug.h>",
      "#include <linux/sched.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/slab.h>",
      "#include <linux/reiserfs_fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "int reiserfs_resize(struct super_block *, unsigned long);",
      "void reiserfs_flush_old_commits(struct super_block *);",
      "int journal_release(struct reiserfs_transaction_handle *, struct super_block *);",
      "int journal_release_error(struct reiserfs_transaction_handle *,\n\t\t\t  struct super_block *);",
      "int journal_begin(struct reiserfs_transaction_handle *,\n\t\t  struct super_block *sb, unsigned long);",
      "int journal_join_abort(struct reiserfs_transaction_handle *,\n\t\t       struct super_block *sb);",
      "int reiserfs_convert_objectid_map_v1(struct super_block *);",
      "const struct reiserfs_key *get_rkey(const struct treepath *chk_path,\n\t\t\t\t    const struct super_block *sb);",
      "int reiserfs_parse_alloc_options(struct super_block *, char *);",
      "int reiserfs_init_bitmap_cache(struct super_block *sb);",
      "void reiserfs_free_bitmap_cache(struct super_block *sb);"
    ],
    "called_functions": [],
    "contextual_snippet": "#include <linux/buffer_head.h>\n#include <linux/proc_fs.h>\n#include <linux/bitops.h>\n#include <asm/unaligned.h>\n#include <linux/workqueue.h>\n#include <linux/bug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/slab.h>\n#include <linux/reiserfs_fs.h>\n\nint reiserfs_resize(struct super_block *, unsigned long);\nvoid reiserfs_flush_old_commits(struct super_block *);\nint journal_release(struct reiserfs_transaction_handle *, struct super_block *);\nint journal_release_error(struct reiserfs_transaction_handle *,\n\t\t\t  struct super_block *);\nint journal_begin(struct reiserfs_transaction_handle *,\n\t\t  struct super_block *sb, unsigned long);\nint journal_join_abort(struct reiserfs_transaction_handle *,\n\t\t       struct super_block *sb);\nint reiserfs_convert_objectid_map_v1(struct super_block *);\nconst struct reiserfs_key *get_rkey(const struct treepath *chk_path,\n\t\t\t\t    const struct super_block *sb);\nint reiserfs_parse_alloc_options(struct super_block *, char *);\nint reiserfs_init_bitmap_cache(struct super_block *sb);\nvoid reiserfs_free_bitmap_cache(struct super_block *sb);\n\nstatic inline struct reiserfs_sb_info *REISERFS_SB(const struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
  },
  {
    "function_name": "REISERFS_I",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/reiserfs.h",
    "lines": "1147-1150",
    "snippet": "static inline struct reiserfs_inode_info *REISERFS_I(const struct inode *inode)\n{\n\treturn container_of(inode, struct reiserfs_inode_info, vfs_inode);\n}",
    "includes": [
      "#include <linux/buffer_head.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/bitops.h>",
      "#include <asm/unaligned.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/bug.h>",
      "#include <linux/sched.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/slab.h>",
      "#include <linux/reiserfs_fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "void reiserfs_vfs_truncate_file(struct inode *inode);",
      "int reiserfs_commit_for_inode(struct inode *);",
      "int reiserfs_inode_needs_commit(struct inode *);",
      "void reiserfs_update_inode_transaction(struct inode *);",
      "int reiserfs_delete_object(struct reiserfs_transaction_handle *th,\n\t\t\t   struct inode *inode);",
      "void reiserfs_evict_inode(struct inode *inode);",
      "void sd_attrs_to_i_attrs(__u16 sd_attrs, struct inode *inode);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "inode",
            "structreiserfs_inode_info",
            "vfs_inode"
          ],
          "line": 1149
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/buffer_head.h>\n#include <linux/proc_fs.h>\n#include <linux/bitops.h>\n#include <asm/unaligned.h>\n#include <linux/workqueue.h>\n#include <linux/bug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/slab.h>\n#include <linux/reiserfs_fs.h>\n\nvoid reiserfs_vfs_truncate_file(struct inode *inode);\nint reiserfs_commit_for_inode(struct inode *);\nint reiserfs_inode_needs_commit(struct inode *);\nvoid reiserfs_update_inode_transaction(struct inode *);\nint reiserfs_delete_object(struct reiserfs_transaction_handle *th,\n\t\t\t   struct inode *inode);\nvoid reiserfs_evict_inode(struct inode *inode);\nvoid sd_attrs_to_i_attrs(__u16 sd_attrs, struct inode *inode);\n\nstatic inline struct reiserfs_inode_info *REISERFS_I(const struct inode *inode)\n{\n\treturn container_of(inode, struct reiserfs_inode_info, vfs_inode);\n}"
  },
  {
    "function_name": "reiserfs_cond_resched",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/reiserfs.h",
    "lines": "843-852",
    "snippet": "static inline void reiserfs_cond_resched(struct super_block *s)\n{\n\tif (need_resched()) {\n\t\tint depth;\n\n\t\tdepth = reiserfs_write_unlock_nested(s);\n\t\tschedule();\n\t\treiserfs_write_lock_nested(s, depth);\n\t}\n}",
    "includes": [
      "#include <linux/buffer_head.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/bitops.h>",
      "#include <asm/unaligned.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/bug.h>",
      "#include <linux/sched.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/slab.h>",
      "#include <linux/reiserfs_fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "int reiserfs_resize(struct super_block *, unsigned long);",
      "void reiserfs_write_lock(struct super_block *s);",
      "void reiserfs_write_unlock(struct super_block *s);",
      "int __must_check reiserfs_write_unlock_nested(struct super_block *s);",
      "void reiserfs_write_lock_nested(struct super_block *s, int depth);",
      "void reiserfs_flush_old_commits(struct super_block *);",
      "void reiserfs_wait_on_write_block(struct super_block *s);",
      "void reiserfs_allow_writes(struct super_block *s);",
      "int journal_release(struct reiserfs_transaction_handle *, struct super_block *);",
      "int journal_release_error(struct reiserfs_transaction_handle *,\n\t\t\t  struct super_block *);",
      "void reiserfs_schedule_old_flush(struct super_block *s);",
      "int reiserfs_convert_objectid_map_v1(struct super_block *);",
      "void print_objectid_map(struct super_block *s);",
      "void print_statistics(struct super_block *s);",
      "int reiserfs_parse_alloc_options(struct super_block *, char *);",
      "void reiserfs_init_alloc_options(struct super_block *s);",
      "void show_alloc_options(struct seq_file *seq, struct super_block *s);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "reiserfs_write_lock_nested",
          "args": [
            "s",
            "depth"
          ],
          "line": 850
        },
        "resolved": true,
        "details": {
          "function_name": "reiserfs_write_lock_nested",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/lock.c",
          "lines": "69-80",
          "snippet": "void reiserfs_write_lock_nested(struct super_block *s, int depth)\n{\n\tstruct reiserfs_sb_info *sb_i = REISERFS_SB(s);\n\n\t/* this can happen when the lock isn't always held */\n\tif (depth == -1)\n\t\treturn;\n\n\tmutex_lock(&sb_i->lock);\n\tsb_i->lock_owner = current;\n\tsb_i->lock_depth = depth;\n}",
          "includes": [
            "#include <linux/mutex.h>",
            "#include \"reiserfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/mutex.h>\n#include \"reiserfs.h\"\n\nvoid reiserfs_write_lock_nested(struct super_block *s, int depth)\n{\n\tstruct reiserfs_sb_info *sb_i = REISERFS_SB(s);\n\n\t/* this can happen when the lock isn't always held */\n\tif (depth == -1)\n\t\treturn;\n\n\tmutex_lock(&sb_i->lock);\n\tsb_i->lock_owner = current;\n\tsb_i->lock_depth = depth;\n}"
        }
      },
      {
        "call_info": {
          "callee": "schedule",
          "args": [],
          "line": 849
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "reiserfs_write_unlock_nested",
          "args": [
            "s"
          ],
          "line": 848
        },
        "resolved": true,
        "details": {
          "function_name": "reiserfs_write_unlock_nested",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/lock.c",
          "lines": "51-67",
          "snippet": "int __must_check reiserfs_write_unlock_nested(struct super_block *s)\n{\n\tstruct reiserfs_sb_info *sb_i = REISERFS_SB(s);\n\tint depth;\n\n\t/* this can happen when the lock isn't always held */\n\tif (sb_i->lock_owner != current)\n\t\treturn -1;\n\n\tdepth = sb_i->lock_depth;\n\n\tsb_i->lock_depth = -1;\n\tsb_i->lock_owner = NULL;\n\tmutex_unlock(&sb_i->lock);\n\n\treturn depth;\n}",
          "includes": [
            "#include <linux/mutex.h>",
            "#include \"reiserfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/mutex.h>\n#include \"reiserfs.h\"\n\nint __must_check reiserfs_write_unlock_nested(struct super_block *s)\n{\n\tstruct reiserfs_sb_info *sb_i = REISERFS_SB(s);\n\tint depth;\n\n\t/* this can happen when the lock isn't always held */\n\tif (sb_i->lock_owner != current)\n\t\treturn -1;\n\n\tdepth = sb_i->lock_depth;\n\n\tsb_i->lock_depth = -1;\n\tsb_i->lock_owner = NULL;\n\tmutex_unlock(&sb_i->lock);\n\n\treturn depth;\n}"
        }
      },
      {
        "call_info": {
          "callee": "need_resched",
          "args": [],
          "line": 845
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/buffer_head.h>\n#include <linux/proc_fs.h>\n#include <linux/bitops.h>\n#include <asm/unaligned.h>\n#include <linux/workqueue.h>\n#include <linux/bug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/slab.h>\n#include <linux/reiserfs_fs.h>\n\nint reiserfs_resize(struct super_block *, unsigned long);\nvoid reiserfs_write_lock(struct super_block *s);\nvoid reiserfs_write_unlock(struct super_block *s);\nint __must_check reiserfs_write_unlock_nested(struct super_block *s);\nvoid reiserfs_write_lock_nested(struct super_block *s, int depth);\nvoid reiserfs_flush_old_commits(struct super_block *);\nvoid reiserfs_wait_on_write_block(struct super_block *s);\nvoid reiserfs_allow_writes(struct super_block *s);\nint journal_release(struct reiserfs_transaction_handle *, struct super_block *);\nint journal_release_error(struct reiserfs_transaction_handle *,\n\t\t\t  struct super_block *);\nvoid reiserfs_schedule_old_flush(struct super_block *s);\nint reiserfs_convert_objectid_map_v1(struct super_block *);\nvoid print_objectid_map(struct super_block *s);\nvoid print_statistics(struct super_block *s);\nint reiserfs_parse_alloc_options(struct super_block *, char *);\nvoid reiserfs_init_alloc_options(struct super_block *s);\nvoid show_alloc_options(struct seq_file *seq, struct super_block *s);\n\nstatic inline void reiserfs_cond_resched(struct super_block *s)\n{\n\tif (need_resched()) {\n\t\tint depth;\n\n\t\tdepth = reiserfs_write_unlock_nested(s);\n\t\tschedule();\n\t\treiserfs_write_lock_nested(s, depth);\n\t}\n}"
  },
  {
    "function_name": "reiserfs_down_read_safe",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/reiserfs.h",
    "lines": "830-837",
    "snippet": "static inline void\nreiserfs_down_read_safe(struct rw_semaphore *sem, struct super_block *s)\n{\n       int depth;\n       depth = reiserfs_write_unlock_nested(s);\n       down_read(sem);\n       reiserfs_write_lock_nested(s, depth);\n}",
    "includes": [
      "#include <linux/buffer_head.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/bitops.h>",
      "#include <asm/unaligned.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/bug.h>",
      "#include <linux/sched.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/slab.h>",
      "#include <linux/reiserfs_fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "int reiserfs_resize(struct super_block *, unsigned long);",
      "void reiserfs_write_lock(struct super_block *s);",
      "void reiserfs_write_unlock(struct super_block *s);",
      "int __must_check reiserfs_write_unlock_nested(struct super_block *s);",
      "void reiserfs_write_lock_nested(struct super_block *s, int depth);",
      "void reiserfs_flush_old_commits(struct super_block *);",
      "void reiserfs_wait_on_write_block(struct super_block *s);",
      "void reiserfs_allow_writes(struct super_block *s);",
      "int journal_release(struct reiserfs_transaction_handle *, struct super_block *);",
      "int journal_release_error(struct reiserfs_transaction_handle *,\n\t\t\t  struct super_block *);",
      "void reiserfs_schedule_old_flush(struct super_block *s);",
      "int reiserfs_convert_objectid_map_v1(struct super_block *);",
      "void print_objectid_map(struct super_block *s);",
      "void print_statistics(struct super_block *s);",
      "int reiserfs_parse_alloc_options(struct super_block *, char *);",
      "void reiserfs_init_alloc_options(struct super_block *s);",
      "void show_alloc_options(struct seq_file *seq, struct super_block *s);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "reiserfs_write_lock_nested",
          "args": [
            "s",
            "depth"
          ],
          "line": 836
        },
        "resolved": true,
        "details": {
          "function_name": "reiserfs_write_lock_nested",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/lock.c",
          "lines": "69-80",
          "snippet": "void reiserfs_write_lock_nested(struct super_block *s, int depth)\n{\n\tstruct reiserfs_sb_info *sb_i = REISERFS_SB(s);\n\n\t/* this can happen when the lock isn't always held */\n\tif (depth == -1)\n\t\treturn;\n\n\tmutex_lock(&sb_i->lock);\n\tsb_i->lock_owner = current;\n\tsb_i->lock_depth = depth;\n}",
          "includes": [
            "#include <linux/mutex.h>",
            "#include \"reiserfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/mutex.h>\n#include \"reiserfs.h\"\n\nvoid reiserfs_write_lock_nested(struct super_block *s, int depth)\n{\n\tstruct reiserfs_sb_info *sb_i = REISERFS_SB(s);\n\n\t/* this can happen when the lock isn't always held */\n\tif (depth == -1)\n\t\treturn;\n\n\tmutex_lock(&sb_i->lock);\n\tsb_i->lock_owner = current;\n\tsb_i->lock_depth = depth;\n}"
        }
      },
      {
        "call_info": {
          "callee": "down_read",
          "args": [
            "sem"
          ],
          "line": 835
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "reiserfs_write_unlock_nested",
          "args": [
            "s"
          ],
          "line": 834
        },
        "resolved": true,
        "details": {
          "function_name": "reiserfs_write_unlock_nested",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/lock.c",
          "lines": "51-67",
          "snippet": "int __must_check reiserfs_write_unlock_nested(struct super_block *s)\n{\n\tstruct reiserfs_sb_info *sb_i = REISERFS_SB(s);\n\tint depth;\n\n\t/* this can happen when the lock isn't always held */\n\tif (sb_i->lock_owner != current)\n\t\treturn -1;\n\n\tdepth = sb_i->lock_depth;\n\n\tsb_i->lock_depth = -1;\n\tsb_i->lock_owner = NULL;\n\tmutex_unlock(&sb_i->lock);\n\n\treturn depth;\n}",
          "includes": [
            "#include <linux/mutex.h>",
            "#include \"reiserfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/mutex.h>\n#include \"reiserfs.h\"\n\nint __must_check reiserfs_write_unlock_nested(struct super_block *s)\n{\n\tstruct reiserfs_sb_info *sb_i = REISERFS_SB(s);\n\tint depth;\n\n\t/* this can happen when the lock isn't always held */\n\tif (sb_i->lock_owner != current)\n\t\treturn -1;\n\n\tdepth = sb_i->lock_depth;\n\n\tsb_i->lock_depth = -1;\n\tsb_i->lock_owner = NULL;\n\tmutex_unlock(&sb_i->lock);\n\n\treturn depth;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/buffer_head.h>\n#include <linux/proc_fs.h>\n#include <linux/bitops.h>\n#include <asm/unaligned.h>\n#include <linux/workqueue.h>\n#include <linux/bug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/slab.h>\n#include <linux/reiserfs_fs.h>\n\nint reiserfs_resize(struct super_block *, unsigned long);\nvoid reiserfs_write_lock(struct super_block *s);\nvoid reiserfs_write_unlock(struct super_block *s);\nint __must_check reiserfs_write_unlock_nested(struct super_block *s);\nvoid reiserfs_write_lock_nested(struct super_block *s, int depth);\nvoid reiserfs_flush_old_commits(struct super_block *);\nvoid reiserfs_wait_on_write_block(struct super_block *s);\nvoid reiserfs_allow_writes(struct super_block *s);\nint journal_release(struct reiserfs_transaction_handle *, struct super_block *);\nint journal_release_error(struct reiserfs_transaction_handle *,\n\t\t\t  struct super_block *);\nvoid reiserfs_schedule_old_flush(struct super_block *s);\nint reiserfs_convert_objectid_map_v1(struct super_block *);\nvoid print_objectid_map(struct super_block *s);\nvoid print_statistics(struct super_block *s);\nint reiserfs_parse_alloc_options(struct super_block *, char *);\nvoid reiserfs_init_alloc_options(struct super_block *s);\nvoid show_alloc_options(struct seq_file *seq, struct super_block *s);\n\nstatic inline void\nreiserfs_down_read_safe(struct rw_semaphore *sem, struct super_block *s)\n{\n       int depth;\n       depth = reiserfs_write_unlock_nested(s);\n       down_read(sem);\n       reiserfs_write_lock_nested(s, depth);\n}"
  },
  {
    "function_name": "reiserfs_mutex_lock_nested_safe",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/reiserfs.h",
    "lines": "819-828",
    "snippet": "static inline void\nreiserfs_mutex_lock_nested_safe(struct mutex *m, unsigned int subclass,\n\t\t\t\tstruct super_block *s)\n{\n\tint depth;\n\n\tdepth = reiserfs_write_unlock_nested(s);\n\tmutex_lock_nested(m, subclass);\n\treiserfs_write_lock_nested(s, depth);\n}",
    "includes": [
      "#include <linux/buffer_head.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/bitops.h>",
      "#include <asm/unaligned.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/bug.h>",
      "#include <linux/sched.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/slab.h>",
      "#include <linux/reiserfs_fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "int reiserfs_resize(struct super_block *, unsigned long);",
      "void reiserfs_write_lock(struct super_block *s);",
      "void reiserfs_write_unlock(struct super_block *s);",
      "int __must_check reiserfs_write_unlock_nested(struct super_block *s);",
      "void reiserfs_write_lock_nested(struct super_block *s, int depth);",
      "void reiserfs_flush_old_commits(struct super_block *);",
      "void reiserfs_wait_on_write_block(struct super_block *s);",
      "void reiserfs_allow_writes(struct super_block *s);",
      "int journal_release(struct reiserfs_transaction_handle *, struct super_block *);",
      "int journal_release_error(struct reiserfs_transaction_handle *,\n\t\t\t  struct super_block *);",
      "void reiserfs_schedule_old_flush(struct super_block *s);",
      "int reiserfs_convert_objectid_map_v1(struct super_block *);",
      "void print_objectid_map(struct super_block *s);",
      "void print_statistics(struct super_block *s);",
      "int reiserfs_parse_alloc_options(struct super_block *, char *);",
      "void reiserfs_init_alloc_options(struct super_block *s);",
      "void show_alloc_options(struct seq_file *seq, struct super_block *s);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "reiserfs_write_lock_nested",
          "args": [
            "s",
            "depth"
          ],
          "line": 827
        },
        "resolved": true,
        "details": {
          "function_name": "reiserfs_write_lock_nested",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/lock.c",
          "lines": "69-80",
          "snippet": "void reiserfs_write_lock_nested(struct super_block *s, int depth)\n{\n\tstruct reiserfs_sb_info *sb_i = REISERFS_SB(s);\n\n\t/* this can happen when the lock isn't always held */\n\tif (depth == -1)\n\t\treturn;\n\n\tmutex_lock(&sb_i->lock);\n\tsb_i->lock_owner = current;\n\tsb_i->lock_depth = depth;\n}",
          "includes": [
            "#include <linux/mutex.h>",
            "#include \"reiserfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/mutex.h>\n#include \"reiserfs.h\"\n\nvoid reiserfs_write_lock_nested(struct super_block *s, int depth)\n{\n\tstruct reiserfs_sb_info *sb_i = REISERFS_SB(s);\n\n\t/* this can happen when the lock isn't always held */\n\tif (depth == -1)\n\t\treturn;\n\n\tmutex_lock(&sb_i->lock);\n\tsb_i->lock_owner = current;\n\tsb_i->lock_depth = depth;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock_nested",
          "args": [
            "m",
            "subclass"
          ],
          "line": 826
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "reiserfs_write_unlock_nested",
          "args": [
            "s"
          ],
          "line": 825
        },
        "resolved": true,
        "details": {
          "function_name": "reiserfs_write_unlock_nested",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/lock.c",
          "lines": "51-67",
          "snippet": "int __must_check reiserfs_write_unlock_nested(struct super_block *s)\n{\n\tstruct reiserfs_sb_info *sb_i = REISERFS_SB(s);\n\tint depth;\n\n\t/* this can happen when the lock isn't always held */\n\tif (sb_i->lock_owner != current)\n\t\treturn -1;\n\n\tdepth = sb_i->lock_depth;\n\n\tsb_i->lock_depth = -1;\n\tsb_i->lock_owner = NULL;\n\tmutex_unlock(&sb_i->lock);\n\n\treturn depth;\n}",
          "includes": [
            "#include <linux/mutex.h>",
            "#include \"reiserfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/mutex.h>\n#include \"reiserfs.h\"\n\nint __must_check reiserfs_write_unlock_nested(struct super_block *s)\n{\n\tstruct reiserfs_sb_info *sb_i = REISERFS_SB(s);\n\tint depth;\n\n\t/* this can happen when the lock isn't always held */\n\tif (sb_i->lock_owner != current)\n\t\treturn -1;\n\n\tdepth = sb_i->lock_depth;\n\n\tsb_i->lock_depth = -1;\n\tsb_i->lock_owner = NULL;\n\tmutex_unlock(&sb_i->lock);\n\n\treturn depth;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/buffer_head.h>\n#include <linux/proc_fs.h>\n#include <linux/bitops.h>\n#include <asm/unaligned.h>\n#include <linux/workqueue.h>\n#include <linux/bug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/slab.h>\n#include <linux/reiserfs_fs.h>\n\nint reiserfs_resize(struct super_block *, unsigned long);\nvoid reiserfs_write_lock(struct super_block *s);\nvoid reiserfs_write_unlock(struct super_block *s);\nint __must_check reiserfs_write_unlock_nested(struct super_block *s);\nvoid reiserfs_write_lock_nested(struct super_block *s, int depth);\nvoid reiserfs_flush_old_commits(struct super_block *);\nvoid reiserfs_wait_on_write_block(struct super_block *s);\nvoid reiserfs_allow_writes(struct super_block *s);\nint journal_release(struct reiserfs_transaction_handle *, struct super_block *);\nint journal_release_error(struct reiserfs_transaction_handle *,\n\t\t\t  struct super_block *);\nvoid reiserfs_schedule_old_flush(struct super_block *s);\nint reiserfs_convert_objectid_map_v1(struct super_block *);\nvoid print_objectid_map(struct super_block *s);\nvoid print_statistics(struct super_block *s);\nint reiserfs_parse_alloc_options(struct super_block *, char *);\nvoid reiserfs_init_alloc_options(struct super_block *s);\nvoid show_alloc_options(struct seq_file *seq, struct super_block *s);\n\nstatic inline void\nreiserfs_mutex_lock_nested_safe(struct mutex *m, unsigned int subclass,\n\t\t\t\tstruct super_block *s)\n{\n\tint depth;\n\n\tdepth = reiserfs_write_unlock_nested(s);\n\tmutex_lock_nested(m, subclass);\n\treiserfs_write_lock_nested(s, depth);\n}"
  },
  {
    "function_name": "reiserfs_mutex_lock_safe",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/reiserfs.h",
    "lines": "809-817",
    "snippet": "static inline void reiserfs_mutex_lock_safe(struct mutex *m,\n\t\t\t\t\t    struct super_block *s)\n{\n\tint depth;\n\n\tdepth = reiserfs_write_unlock_nested(s);\n\tmutex_lock(m);\n\treiserfs_write_lock_nested(s, depth);\n}",
    "includes": [
      "#include <linux/buffer_head.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/bitops.h>",
      "#include <asm/unaligned.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/bug.h>",
      "#include <linux/sched.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/slab.h>",
      "#include <linux/reiserfs_fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "int reiserfs_resize(struct super_block *, unsigned long);",
      "void reiserfs_write_lock(struct super_block *s);",
      "void reiserfs_write_unlock(struct super_block *s);",
      "int __must_check reiserfs_write_unlock_nested(struct super_block *s);",
      "void reiserfs_write_lock_nested(struct super_block *s, int depth);",
      "void reiserfs_flush_old_commits(struct super_block *);",
      "void reiserfs_wait_on_write_block(struct super_block *s);",
      "void reiserfs_allow_writes(struct super_block *s);",
      "int journal_release(struct reiserfs_transaction_handle *, struct super_block *);",
      "int journal_release_error(struct reiserfs_transaction_handle *,\n\t\t\t  struct super_block *);",
      "void reiserfs_schedule_old_flush(struct super_block *s);",
      "int reiserfs_convert_objectid_map_v1(struct super_block *);",
      "void print_objectid_map(struct super_block *s);",
      "void print_statistics(struct super_block *s);",
      "int reiserfs_parse_alloc_options(struct super_block *, char *);",
      "void reiserfs_init_alloc_options(struct super_block *s);",
      "void show_alloc_options(struct seq_file *seq, struct super_block *s);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "reiserfs_write_lock_nested",
          "args": [
            "s",
            "depth"
          ],
          "line": 816
        },
        "resolved": true,
        "details": {
          "function_name": "reiserfs_write_lock_nested",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/lock.c",
          "lines": "69-80",
          "snippet": "void reiserfs_write_lock_nested(struct super_block *s, int depth)\n{\n\tstruct reiserfs_sb_info *sb_i = REISERFS_SB(s);\n\n\t/* this can happen when the lock isn't always held */\n\tif (depth == -1)\n\t\treturn;\n\n\tmutex_lock(&sb_i->lock);\n\tsb_i->lock_owner = current;\n\tsb_i->lock_depth = depth;\n}",
          "includes": [
            "#include <linux/mutex.h>",
            "#include \"reiserfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/mutex.h>\n#include \"reiserfs.h\"\n\nvoid reiserfs_write_lock_nested(struct super_block *s, int depth)\n{\n\tstruct reiserfs_sb_info *sb_i = REISERFS_SB(s);\n\n\t/* this can happen when the lock isn't always held */\n\tif (depth == -1)\n\t\treturn;\n\n\tmutex_lock(&sb_i->lock);\n\tsb_i->lock_owner = current;\n\tsb_i->lock_depth = depth;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "m"
          ],
          "line": 815
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "reiserfs_write_unlock_nested",
          "args": [
            "s"
          ],
          "line": 814
        },
        "resolved": true,
        "details": {
          "function_name": "reiserfs_write_unlock_nested",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/lock.c",
          "lines": "51-67",
          "snippet": "int __must_check reiserfs_write_unlock_nested(struct super_block *s)\n{\n\tstruct reiserfs_sb_info *sb_i = REISERFS_SB(s);\n\tint depth;\n\n\t/* this can happen when the lock isn't always held */\n\tif (sb_i->lock_owner != current)\n\t\treturn -1;\n\n\tdepth = sb_i->lock_depth;\n\n\tsb_i->lock_depth = -1;\n\tsb_i->lock_owner = NULL;\n\tmutex_unlock(&sb_i->lock);\n\n\treturn depth;\n}",
          "includes": [
            "#include <linux/mutex.h>",
            "#include \"reiserfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/mutex.h>\n#include \"reiserfs.h\"\n\nint __must_check reiserfs_write_unlock_nested(struct super_block *s)\n{\n\tstruct reiserfs_sb_info *sb_i = REISERFS_SB(s);\n\tint depth;\n\n\t/* this can happen when the lock isn't always held */\n\tif (sb_i->lock_owner != current)\n\t\treturn -1;\n\n\tdepth = sb_i->lock_depth;\n\n\tsb_i->lock_depth = -1;\n\tsb_i->lock_owner = NULL;\n\tmutex_unlock(&sb_i->lock);\n\n\treturn depth;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/buffer_head.h>\n#include <linux/proc_fs.h>\n#include <linux/bitops.h>\n#include <asm/unaligned.h>\n#include <linux/workqueue.h>\n#include <linux/bug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/slab.h>\n#include <linux/reiserfs_fs.h>\n\nint reiserfs_resize(struct super_block *, unsigned long);\nvoid reiserfs_write_lock(struct super_block *s);\nvoid reiserfs_write_unlock(struct super_block *s);\nint __must_check reiserfs_write_unlock_nested(struct super_block *s);\nvoid reiserfs_write_lock_nested(struct super_block *s, int depth);\nvoid reiserfs_flush_old_commits(struct super_block *);\nvoid reiserfs_wait_on_write_block(struct super_block *s);\nvoid reiserfs_allow_writes(struct super_block *s);\nint journal_release(struct reiserfs_transaction_handle *, struct super_block *);\nint journal_release_error(struct reiserfs_transaction_handle *,\n\t\t\t  struct super_block *);\nvoid reiserfs_schedule_old_flush(struct super_block *s);\nint reiserfs_convert_objectid_map_v1(struct super_block *);\nvoid print_objectid_map(struct super_block *s);\nvoid print_statistics(struct super_block *s);\nint reiserfs_parse_alloc_options(struct super_block *, char *);\nvoid reiserfs_init_alloc_options(struct super_block *s);\nvoid show_alloc_options(struct seq_file *seq, struct super_block *s);\n\nstatic inline void reiserfs_mutex_lock_safe(struct mutex *m,\n\t\t\t\t\t    struct super_block *s)\n{\n\tint depth;\n\n\tdepth = reiserfs_write_unlock_nested(s);\n\tmutex_lock(m);\n\treiserfs_write_lock_nested(s, depth);\n}"
  },
  {
    "function_name": "reiserfs_lock_check_recursive",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/reiserfs.h",
    "lines": "779-779",
    "snippet": "static inline void reiserfs_lock_check_recursive(struct super_block *s) { }",
    "includes": [
      "#include <linux/buffer_head.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/bitops.h>",
      "#include <asm/unaligned.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/bug.h>",
      "#include <linux/sched.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/slab.h>",
      "#include <linux/reiserfs_fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "int reiserfs_resize(struct super_block *, unsigned long);",
      "void reiserfs_write_lock(struct super_block *s);",
      "void reiserfs_write_unlock(struct super_block *s);",
      "int __must_check reiserfs_write_unlock_nested(struct super_block *s);",
      "void reiserfs_flush_old_commits(struct super_block *);",
      "void reiserfs_wait_on_write_block(struct super_block *s);",
      "void reiserfs_allow_writes(struct super_block *s);",
      "int journal_release(struct reiserfs_transaction_handle *, struct super_block *);",
      "int journal_release_error(struct reiserfs_transaction_handle *,\n\t\t\t  struct super_block *);",
      "void reiserfs_schedule_old_flush(struct super_block *s);",
      "int reiserfs_convert_objectid_map_v1(struct super_block *);",
      "void print_objectid_map(struct super_block *s);",
      "void print_statistics(struct super_block *s);",
      "int reiserfs_parse_alloc_options(struct super_block *, char *);",
      "void reiserfs_init_alloc_options(struct super_block *s);",
      "void show_alloc_options(struct seq_file *seq, struct super_block *s);"
    ],
    "called_functions": [],
    "contextual_snippet": "#include <linux/buffer_head.h>\n#include <linux/proc_fs.h>\n#include <linux/bitops.h>\n#include <asm/unaligned.h>\n#include <linux/workqueue.h>\n#include <linux/bug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/slab.h>\n#include <linux/reiserfs_fs.h>\n\nint reiserfs_resize(struct super_block *, unsigned long);\nvoid reiserfs_write_lock(struct super_block *s);\nvoid reiserfs_write_unlock(struct super_block *s);\nint __must_check reiserfs_write_unlock_nested(struct super_block *s);\nvoid reiserfs_flush_old_commits(struct super_block *);\nvoid reiserfs_wait_on_write_block(struct super_block *s);\nvoid reiserfs_allow_writes(struct super_block *s);\nint journal_release(struct reiserfs_transaction_handle *, struct super_block *);\nint journal_release_error(struct reiserfs_transaction_handle *,\n\t\t\t  struct super_block *);\nvoid reiserfs_schedule_old_flush(struct super_block *s);\nint reiserfs_convert_objectid_map_v1(struct super_block *);\nvoid print_objectid_map(struct super_block *s);\nvoid print_statistics(struct super_block *s);\nint reiserfs_parse_alloc_options(struct super_block *, char *);\nvoid reiserfs_init_alloc_options(struct super_block *s);\nvoid show_alloc_options(struct seq_file *seq, struct super_block *s);\n\nstatic inline void reiserfs_lock_check_recursive(struct super_block *s) { }"
  },
  {
    "function_name": "__reiserfs_is_journal_aborted",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/reiserfs.h",
    "lines": "760-764",
    "snippet": "static inline int __reiserfs_is_journal_aborted(struct reiserfs_journal\n\t\t\t\t\t\t*journal)\n{\n\treturn test_bit(J_ABORTED, &journal->j_state);\n}",
    "includes": [
      "#include <linux/buffer_head.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/bitops.h>",
      "#include <asm/unaligned.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/bug.h>",
      "#include <linux/sched.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/slab.h>",
      "#include <linux/reiserfs_fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "test_bit",
          "args": [
            "J_ABORTED",
            "&journal->j_state"
          ],
          "line": 763
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_test_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "898-902",
          "snippet": "static inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [
            "#define ocfs2_test_bit test_bit_le"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\n#define ocfs2_test_bit test_bit_le\n\nstatic inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/buffer_head.h>\n#include <linux/proc_fs.h>\n#include <linux/bitops.h>\n#include <asm/unaligned.h>\n#include <linux/workqueue.h>\n#include <linux/bug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/slab.h>\n#include <linux/reiserfs_fs.h>\n\nstatic inline int __reiserfs_is_journal_aborted(struct reiserfs_journal\n\t\t\t\t\t\t*journal)\n{\n\treturn test_bit(J_ABORTED, &journal->j_state);\n}"
  }
]