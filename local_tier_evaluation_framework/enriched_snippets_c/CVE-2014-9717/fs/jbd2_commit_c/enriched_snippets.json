[
  {
    "function_name": "jbd2_journal_commit_transaction",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd2/commit.c",
    "lines": "370-1164",
    "snippet": "void jbd2_journal_commit_transaction(journal_t *journal)\n{\n\tstruct transaction_stats_s stats;\n\ttransaction_t *commit_transaction;\n\tstruct journal_head *jh;\n\tstruct buffer_head *descriptor;\n\tstruct buffer_head **wbuf = journal->j_wbuf;\n\tint bufs;\n\tint flags;\n\tint err;\n\tunsigned long long blocknr;\n\tktime_t start_time;\n\tu64 commit_time;\n\tchar *tagp = NULL;\n\tjournal_header_t *header;\n\tjournal_block_tag_t *tag = NULL;\n\tint space_left = 0;\n\tint first_tag = 0;\n\tint tag_flag;\n\tint i;\n\tint tag_bytes = journal_tag_bytes(journal);\n\tstruct buffer_head *cbh = NULL; /* For transactional checksums */\n\t__u32 crc32_sum = ~0;\n\tstruct blk_plug plug;\n\t/* Tail of the journal */\n\tunsigned long first_block;\n\ttid_t first_tid;\n\tint update_tail;\n\tint csum_size = 0;\n\tLIST_HEAD(io_bufs);\n\tLIST_HEAD(log_bufs);\n\n\tif (jbd2_journal_has_csum_v2or3(journal))\n\t\tcsum_size = sizeof(struct jbd2_journal_block_tail);\n\n\t/*\n\t * First job: lock down the current transaction and wait for\n\t * all outstanding updates to complete.\n\t */\n\n\t/* Do we need to erase the effects of a prior jbd2_journal_flush? */\n\tif (journal->j_flags & JBD2_FLUSHED) {\n\t\tjbd_debug(3, \"super block updated\\n\");\n\t\tmutex_lock(&journal->j_checkpoint_mutex);\n\t\t/*\n\t\t * We hold j_checkpoint_mutex so tail cannot change under us.\n\t\t * We don't need any special data guarantees for writing sb\n\t\t * since journal is empty and it is ok for write to be\n\t\t * flushed only with transaction commit.\n\t\t */\n\t\tjbd2_journal_update_sb_log_tail(journal,\n\t\t\t\t\t\tjournal->j_tail_sequence,\n\t\t\t\t\t\tjournal->j_tail,\n\t\t\t\t\t\tWRITE_SYNC);\n\t\tmutex_unlock(&journal->j_checkpoint_mutex);\n\t} else {\n\t\tjbd_debug(3, \"superblock not updated\\n\");\n\t}\n\n\tJ_ASSERT(journal->j_running_transaction != NULL);\n\tJ_ASSERT(journal->j_committing_transaction == NULL);\n\n\tcommit_transaction = journal->j_running_transaction;\n\n\ttrace_jbd2_start_commit(journal, commit_transaction);\n\tjbd_debug(1, \"JBD2: starting commit of transaction %d\\n\",\n\t\t\tcommit_transaction->t_tid);\n\n\twrite_lock(&journal->j_state_lock);\n\tJ_ASSERT(commit_transaction->t_state == T_RUNNING);\n\tcommit_transaction->t_state = T_LOCKED;\n\n\ttrace_jbd2_commit_locking(journal, commit_transaction);\n\tstats.run.rs_wait = commit_transaction->t_max_wait;\n\tstats.run.rs_request_delay = 0;\n\tstats.run.rs_locked = jiffies;\n\tif (commit_transaction->t_requested)\n\t\tstats.run.rs_request_delay =\n\t\t\tjbd2_time_diff(commit_transaction->t_requested,\n\t\t\t\t       stats.run.rs_locked);\n\tstats.run.rs_running = jbd2_time_diff(commit_transaction->t_start,\n\t\t\t\t\t      stats.run.rs_locked);\n\n\tspin_lock(&commit_transaction->t_handle_lock);\n\twhile (atomic_read(&commit_transaction->t_updates)) {\n\t\tDEFINE_WAIT(wait);\n\n\t\tprepare_to_wait(&journal->j_wait_updates, &wait,\n\t\t\t\t\tTASK_UNINTERRUPTIBLE);\n\t\tif (atomic_read(&commit_transaction->t_updates)) {\n\t\t\tspin_unlock(&commit_transaction->t_handle_lock);\n\t\t\twrite_unlock(&journal->j_state_lock);\n\t\t\tschedule();\n\t\t\twrite_lock(&journal->j_state_lock);\n\t\t\tspin_lock(&commit_transaction->t_handle_lock);\n\t\t}\n\t\tfinish_wait(&journal->j_wait_updates, &wait);\n\t}\n\tspin_unlock(&commit_transaction->t_handle_lock);\n\n\tJ_ASSERT (atomic_read(&commit_transaction->t_outstanding_credits) <=\n\t\t\tjournal->j_max_transaction_buffers);\n\n\t/*\n\t * First thing we are allowed to do is to discard any remaining\n\t * BJ_Reserved buffers.  Note, it is _not_ permissible to assume\n\t * that there are no such buffers: if a large filesystem\n\t * operation like a truncate needs to split itself over multiple\n\t * transactions, then it may try to do a jbd2_journal_restart() while\n\t * there are still BJ_Reserved buffers outstanding.  These must\n\t * be released cleanly from the current transaction.\n\t *\n\t * In this case, the filesystem must still reserve write access\n\t * again before modifying the buffer in the new transaction, but\n\t * we do not require it to remember exactly which old buffers it\n\t * has reserved.  This is consistent with the existing behaviour\n\t * that multiple jbd2_journal_get_write_access() calls to the same\n\t * buffer are perfectly permissible.\n\t */\n\twhile (commit_transaction->t_reserved_list) {\n\t\tjh = commit_transaction->t_reserved_list;\n\t\tJBUFFER_TRACE(jh, \"reserved, unused: refile\");\n\t\t/*\n\t\t * A jbd2_journal_get_undo_access()+jbd2_journal_release_buffer() may\n\t\t * leave undo-committed data.\n\t\t */\n\t\tif (jh->b_committed_data) {\n\t\t\tstruct buffer_head *bh = jh2bh(jh);\n\n\t\t\tjbd_lock_bh_state(bh);\n\t\t\tjbd2_free(jh->b_committed_data, bh->b_size);\n\t\t\tjh->b_committed_data = NULL;\n\t\t\tjbd_unlock_bh_state(bh);\n\t\t}\n\t\tjbd2_journal_refile_buffer(journal, jh);\n\t}\n\n\t/*\n\t * Now try to drop any written-back buffers from the journal's\n\t * checkpoint lists.  We do this *before* commit because it potentially\n\t * frees some memory\n\t */\n\tspin_lock(&journal->j_list_lock);\n\t__jbd2_journal_clean_checkpoint_list(journal);\n\tspin_unlock(&journal->j_list_lock);\n\n\tjbd_debug(3, \"JBD2: commit phase 1\\n\");\n\n\t/*\n\t * Clear revoked flag to reflect there is no revoked buffers\n\t * in the next transaction which is going to be started.\n\t */\n\tjbd2_clear_buffer_revoked_flags(journal);\n\n\t/*\n\t * Switch to a new revoke table.\n\t */\n\tjbd2_journal_switch_revoke_table(journal);\n\n\t/*\n\t * Reserved credits cannot be claimed anymore, free them\n\t */\n\tatomic_sub(atomic_read(&journal->j_reserved_credits),\n\t\t   &commit_transaction->t_outstanding_credits);\n\n\ttrace_jbd2_commit_flushing(journal, commit_transaction);\n\tstats.run.rs_flushing = jiffies;\n\tstats.run.rs_locked = jbd2_time_diff(stats.run.rs_locked,\n\t\t\t\t\t     stats.run.rs_flushing);\n\n\tcommit_transaction->t_state = T_FLUSH;\n\tjournal->j_committing_transaction = commit_transaction;\n\tjournal->j_running_transaction = NULL;\n\tstart_time = ktime_get();\n\tcommit_transaction->t_log_start = journal->j_head;\n\twake_up(&journal->j_wait_transaction_locked);\n\twrite_unlock(&journal->j_state_lock);\n\n\tjbd_debug(3, \"JBD2: commit phase 2a\\n\");\n\n\t/*\n\t * Now start flushing things to disk, in the order they appear\n\t * on the transaction lists.  Data blocks go first.\n\t */\n\terr = journal_submit_data_buffers(journal, commit_transaction);\n\tif (err)\n\t\tjbd2_journal_abort(journal, err);\n\n\tblk_start_plug(&plug);\n\tjbd2_journal_write_revoke_records(journal, commit_transaction,\n\t\t\t\t\t  &log_bufs, WRITE_SYNC);\n\n\tjbd_debug(3, \"JBD2: commit phase 2b\\n\");\n\n\t/*\n\t * Way to go: we have now written out all of the data for a\n\t * transaction!  Now comes the tricky part: we need to write out\n\t * metadata.  Loop over the transaction's entire buffer list:\n\t */\n\twrite_lock(&journal->j_state_lock);\n\tcommit_transaction->t_state = T_COMMIT;\n\twrite_unlock(&journal->j_state_lock);\n\n\ttrace_jbd2_commit_logging(journal, commit_transaction);\n\tstats.run.rs_logging = jiffies;\n\tstats.run.rs_flushing = jbd2_time_diff(stats.run.rs_flushing,\n\t\t\t\t\t       stats.run.rs_logging);\n\tstats.run.rs_blocks =\n\t\tatomic_read(&commit_transaction->t_outstanding_credits);\n\tstats.run.rs_blocks_logged = 0;\n\n\tJ_ASSERT(commit_transaction->t_nr_buffers <=\n\t\t atomic_read(&commit_transaction->t_outstanding_credits));\n\n\terr = 0;\n\tbufs = 0;\n\tdescriptor = NULL;\n\twhile (commit_transaction->t_buffers) {\n\n\t\t/* Find the next buffer to be journaled... */\n\n\t\tjh = commit_transaction->t_buffers;\n\n\t\t/* If we're in abort mode, we just un-journal the buffer and\n\t\t   release it. */\n\n\t\tif (is_journal_aborted(journal)) {\n\t\t\tclear_buffer_jbddirty(jh2bh(jh));\n\t\t\tJBUFFER_TRACE(jh, \"journal is aborting: refile\");\n\t\t\tjbd2_buffer_abort_trigger(jh,\n\t\t\t\t\t\t  jh->b_frozen_data ?\n\t\t\t\t\t\t  jh->b_frozen_triggers :\n\t\t\t\t\t\t  jh->b_triggers);\n\t\t\tjbd2_journal_refile_buffer(journal, jh);\n\t\t\t/* If that was the last one, we need to clean up\n\t\t\t * any descriptor buffers which may have been\n\t\t\t * already allocated, even if we are now\n\t\t\t * aborting. */\n\t\t\tif (!commit_transaction->t_buffers)\n\t\t\t\tgoto start_journal_io;\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* Make sure we have a descriptor block in which to\n\t\t   record the metadata buffer. */\n\n\t\tif (!descriptor) {\n\t\t\tJ_ASSERT (bufs == 0);\n\n\t\t\tjbd_debug(4, \"JBD2: get descriptor\\n\");\n\n\t\t\tdescriptor = jbd2_journal_get_descriptor_buffer(journal);\n\t\t\tif (!descriptor) {\n\t\t\t\tjbd2_journal_abort(journal, -EIO);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tjbd_debug(4, \"JBD2: got buffer %llu (%p)\\n\",\n\t\t\t\t(unsigned long long)descriptor->b_blocknr,\n\t\t\t\tdescriptor->b_data);\n\t\t\theader = (journal_header_t *)descriptor->b_data;\n\t\t\theader->h_magic     = cpu_to_be32(JBD2_MAGIC_NUMBER);\n\t\t\theader->h_blocktype = cpu_to_be32(JBD2_DESCRIPTOR_BLOCK);\n\t\t\theader->h_sequence  = cpu_to_be32(commit_transaction->t_tid);\n\n\t\t\ttagp = &descriptor->b_data[sizeof(journal_header_t)];\n\t\t\tspace_left = descriptor->b_size -\n\t\t\t\t\t\tsizeof(journal_header_t);\n\t\t\tfirst_tag = 1;\n\t\t\tset_buffer_jwrite(descriptor);\n\t\t\tset_buffer_dirty(descriptor);\n\t\t\twbuf[bufs++] = descriptor;\n\n\t\t\t/* Record it so that we can wait for IO\n                           completion later */\n\t\t\tBUFFER_TRACE(descriptor, \"ph3: file as descriptor\");\n\t\t\tjbd2_file_log_bh(&log_bufs, descriptor);\n\t\t}\n\n\t\t/* Where is the buffer to be written? */\n\n\t\terr = jbd2_journal_next_log_block(journal, &blocknr);\n\t\t/* If the block mapping failed, just abandon the buffer\n\t\t   and repeat this loop: we'll fall into the\n\t\t   refile-on-abort condition above. */\n\t\tif (err) {\n\t\t\tjbd2_journal_abort(journal, err);\n\t\t\tcontinue;\n\t\t}\n\n\t\t/*\n\t\t * start_this_handle() uses t_outstanding_credits to determine\n\t\t * the free space in the log, but this counter is changed\n\t\t * by jbd2_journal_next_log_block() also.\n\t\t */\n\t\tatomic_dec(&commit_transaction->t_outstanding_credits);\n\n\t\t/* Bump b_count to prevent truncate from stumbling over\n                   the shadowed buffer!  @@@ This can go if we ever get\n                   rid of the shadow pairing of buffers. */\n\t\tatomic_inc(&jh2bh(jh)->b_count);\n\n\t\t/*\n\t\t * Make a temporary IO buffer with which to write it out\n\t\t * (this will requeue the metadata buffer to BJ_Shadow).\n\t\t */\n\t\tset_bit(BH_JWrite, &jh2bh(jh)->b_state);\n\t\tJBUFFER_TRACE(jh, \"ph3: write metadata\");\n\t\tflags = jbd2_journal_write_metadata_buffer(commit_transaction,\n\t\t\t\t\t\tjh, &wbuf[bufs], blocknr);\n\t\tif (flags < 0) {\n\t\t\tjbd2_journal_abort(journal, flags);\n\t\t\tcontinue;\n\t\t}\n\t\tjbd2_file_log_bh(&io_bufs, wbuf[bufs]);\n\n\t\t/* Record the new block's tag in the current descriptor\n                   buffer */\n\n\t\ttag_flag = 0;\n\t\tif (flags & 1)\n\t\t\ttag_flag |= JBD2_FLAG_ESCAPE;\n\t\tif (!first_tag)\n\t\t\ttag_flag |= JBD2_FLAG_SAME_UUID;\n\n\t\ttag = (journal_block_tag_t *) tagp;\n\t\twrite_tag_block(journal, tag, jh2bh(jh)->b_blocknr);\n\t\ttag->t_flags = cpu_to_be16(tag_flag);\n\t\tjbd2_block_tag_csum_set(journal, tag, wbuf[bufs],\n\t\t\t\t\tcommit_transaction->t_tid);\n\t\ttagp += tag_bytes;\n\t\tspace_left -= tag_bytes;\n\t\tbufs++;\n\n\t\tif (first_tag) {\n\t\t\tmemcpy (tagp, journal->j_uuid, 16);\n\t\t\ttagp += 16;\n\t\t\tspace_left -= 16;\n\t\t\tfirst_tag = 0;\n\t\t}\n\n\t\t/* If there's no more to do, or if the descriptor is full,\n\t\t   let the IO rip! */\n\n\t\tif (bufs == journal->j_wbufsize ||\n\t\t    commit_transaction->t_buffers == NULL ||\n\t\t    space_left < tag_bytes + 16 + csum_size) {\n\n\t\t\tjbd_debug(4, \"JBD2: Submit %d IOs\\n\", bufs);\n\n\t\t\t/* Write an end-of-descriptor marker before\n                           submitting the IOs.  \"tag\" still points to\n                           the last tag we set up. */\n\n\t\t\ttag->t_flags |= cpu_to_be16(JBD2_FLAG_LAST_TAG);\n\n\t\t\tjbd2_descr_block_csum_set(journal, descriptor);\nstart_journal_io:\n\t\t\tfor (i = 0; i < bufs; i++) {\n\t\t\t\tstruct buffer_head *bh = wbuf[i];\n\t\t\t\t/*\n\t\t\t\t * Compute checksum.\n\t\t\t\t */\n\t\t\t\tif (JBD2_HAS_COMPAT_FEATURE(journal,\n\t\t\t\t\tJBD2_FEATURE_COMPAT_CHECKSUM)) {\n\t\t\t\t\tcrc32_sum =\n\t\t\t\t\t    jbd2_checksum_data(crc32_sum, bh);\n\t\t\t\t}\n\n\t\t\t\tlock_buffer(bh);\n\t\t\t\tclear_buffer_dirty(bh);\n\t\t\t\tset_buffer_uptodate(bh);\n\t\t\t\tbh->b_end_io = journal_end_buffer_io_sync;\n\t\t\t\tsubmit_bh(WRITE_SYNC, bh);\n\t\t\t}\n\t\t\tcond_resched();\n\t\t\tstats.run.rs_blocks_logged += bufs;\n\n\t\t\t/* Force a new descriptor to be generated next\n                           time round the loop. */\n\t\t\tdescriptor = NULL;\n\t\t\tbufs = 0;\n\t\t}\n\t}\n\n\terr = journal_finish_inode_data_buffers(journal, commit_transaction);\n\tif (err) {\n\t\tprintk(KERN_WARNING\n\t\t\t\"JBD2: Detected IO errors while flushing file data \"\n\t\t       \"on %s\\n\", journal->j_devname);\n\t\tif (journal->j_flags & JBD2_ABORT_ON_SYNCDATA_ERR)\n\t\t\tjbd2_journal_abort(journal, err);\n\t\terr = 0;\n\t}\n\n\t/*\n\t * Get current oldest transaction in the log before we issue flush\n\t * to the filesystem device. After the flush we can be sure that\n\t * blocks of all older transactions are checkpointed to persistent\n\t * storage and we will be safe to update journal start in the\n\t * superblock with the numbers we get here.\n\t */\n\tupdate_tail =\n\t\tjbd2_journal_get_log_tail(journal, &first_tid, &first_block);\n\n\twrite_lock(&journal->j_state_lock);\n\tif (update_tail) {\n\t\tlong freed = first_block - journal->j_tail;\n\n\t\tif (first_block < journal->j_tail)\n\t\t\tfreed += journal->j_last - journal->j_first;\n\t\t/* Update tail only if we free significant amount of space */\n\t\tif (freed < journal->j_maxlen / 4)\n\t\t\tupdate_tail = 0;\n\t}\n\tJ_ASSERT(commit_transaction->t_state == T_COMMIT);\n\tcommit_transaction->t_state = T_COMMIT_DFLUSH;\n\twrite_unlock(&journal->j_state_lock);\n\n\t/* \n\t * If the journal is not located on the file system device,\n\t * then we must flush the file system device before we issue\n\t * the commit record\n\t */\n\tif (commit_transaction->t_need_data_flush &&\n\t    (journal->j_fs_dev != journal->j_dev) &&\n\t    (journal->j_flags & JBD2_BARRIER))\n\t\tblkdev_issue_flush(journal->j_fs_dev, GFP_NOFS, NULL);\n\n\t/* Done it all: now write the commit record asynchronously. */\n\tif (JBD2_HAS_INCOMPAT_FEATURE(journal,\n\t\t\t\t      JBD2_FEATURE_INCOMPAT_ASYNC_COMMIT)) {\n\t\terr = journal_submit_commit_record(journal, commit_transaction,\n\t\t\t\t\t\t &cbh, crc32_sum);\n\t\tif (err)\n\t\t\t__jbd2_journal_abort_hard(journal);\n\t}\n\n\tblk_finish_plug(&plug);\n\n\t/* Lo and behold: we have just managed to send a transaction to\n           the log.  Before we can commit it, wait for the IO so far to\n           complete.  Control buffers being written are on the\n           transaction's t_log_list queue, and metadata buffers are on\n           the io_bufs list.\n\n\t   Wait for the buffers in reverse order.  That way we are\n\t   less likely to be woken up until all IOs have completed, and\n\t   so we incur less scheduling load.\n\t*/\n\n\tjbd_debug(3, \"JBD2: commit phase 3\\n\");\n\n\twhile (!list_empty(&io_bufs)) {\n\t\tstruct buffer_head *bh = list_entry(io_bufs.prev,\n\t\t\t\t\t\t    struct buffer_head,\n\t\t\t\t\t\t    b_assoc_buffers);\n\n\t\twait_on_buffer(bh);\n\t\tcond_resched();\n\n\t\tif (unlikely(!buffer_uptodate(bh)))\n\t\t\terr = -EIO;\n\t\tjbd2_unfile_log_bh(bh);\n\n\t\t/*\n\t\t * The list contains temporary buffer heads created by\n\t\t * jbd2_journal_write_metadata_buffer().\n\t\t */\n\t\tBUFFER_TRACE(bh, \"dumping temporary bh\");\n\t\t__brelse(bh);\n\t\tJ_ASSERT_BH(bh, atomic_read(&bh->b_count) == 0);\n\t\tfree_buffer_head(bh);\n\n\t\t/* We also have to refile the corresponding shadowed buffer */\n\t\tjh = commit_transaction->t_shadow_list->b_tprev;\n\t\tbh = jh2bh(jh);\n\t\tclear_buffer_jwrite(bh);\n\t\tJ_ASSERT_BH(bh, buffer_jbddirty(bh));\n\t\tJ_ASSERT_BH(bh, !buffer_shadow(bh));\n\n\t\t/* The metadata is now released for reuse, but we need\n                   to remember it against this transaction so that when\n                   we finally commit, we can do any checkpointing\n                   required. */\n\t\tJBUFFER_TRACE(jh, \"file as BJ_Forget\");\n\t\tjbd2_journal_file_buffer(jh, commit_transaction, BJ_Forget);\n\t\tJBUFFER_TRACE(jh, \"brelse shadowed buffer\");\n\t\t__brelse(bh);\n\t}\n\n\tJ_ASSERT (commit_transaction->t_shadow_list == NULL);\n\n\tjbd_debug(3, \"JBD2: commit phase 4\\n\");\n\n\t/* Here we wait for the revoke record and descriptor record buffers */\n\twhile (!list_empty(&log_bufs)) {\n\t\tstruct buffer_head *bh;\n\n\t\tbh = list_entry(log_bufs.prev, struct buffer_head, b_assoc_buffers);\n\t\twait_on_buffer(bh);\n\t\tcond_resched();\n\n\t\tif (unlikely(!buffer_uptodate(bh)))\n\t\t\terr = -EIO;\n\n\t\tBUFFER_TRACE(bh, \"ph5: control buffer writeout done: unfile\");\n\t\tclear_buffer_jwrite(bh);\n\t\tjbd2_unfile_log_bh(bh);\n\t\t__brelse(bh);\t\t/* One for getblk */\n\t\t/* AKPM: bforget here */\n\t}\n\n\tif (err)\n\t\tjbd2_journal_abort(journal, err);\n\n\tjbd_debug(3, \"JBD2: commit phase 5\\n\");\n\twrite_lock(&journal->j_state_lock);\n\tJ_ASSERT(commit_transaction->t_state == T_COMMIT_DFLUSH);\n\tcommit_transaction->t_state = T_COMMIT_JFLUSH;\n\twrite_unlock(&journal->j_state_lock);\n\n\tif (!JBD2_HAS_INCOMPAT_FEATURE(journal,\n\t\t\t\t       JBD2_FEATURE_INCOMPAT_ASYNC_COMMIT)) {\n\t\terr = journal_submit_commit_record(journal, commit_transaction,\n\t\t\t\t\t\t&cbh, crc32_sum);\n\t\tif (err)\n\t\t\t__jbd2_journal_abort_hard(journal);\n\t}\n\tif (cbh)\n\t\terr = journal_wait_on_commit_record(journal, cbh);\n\tif (JBD2_HAS_INCOMPAT_FEATURE(journal,\n\t\t\t\t      JBD2_FEATURE_INCOMPAT_ASYNC_COMMIT) &&\n\t    journal->j_flags & JBD2_BARRIER) {\n\t\tblkdev_issue_flush(journal->j_dev, GFP_NOFS, NULL);\n\t}\n\n\tif (err)\n\t\tjbd2_journal_abort(journal, err);\n\n\t/*\n\t * Now disk caches for filesystem device are flushed so we are safe to\n\t * erase checkpointed transactions from the log by updating journal\n\t * superblock.\n\t */\n\tif (update_tail)\n\t\tjbd2_update_log_tail(journal, first_tid, first_block);\n\n\t/* End of a transaction!  Finally, we can do checkpoint\n           processing: any buffers committed as a result of this\n           transaction can be removed from any checkpoint list it was on\n           before. */\n\n\tjbd_debug(3, \"JBD2: commit phase 6\\n\");\n\n\tJ_ASSERT(list_empty(&commit_transaction->t_inode_list));\n\tJ_ASSERT(commit_transaction->t_buffers == NULL);\n\tJ_ASSERT(commit_transaction->t_checkpoint_list == NULL);\n\tJ_ASSERT(commit_transaction->t_shadow_list == NULL);\n\nrestart_loop:\n\t/*\n\t * As there are other places (journal_unmap_buffer()) adding buffers\n\t * to this list we have to be careful and hold the j_list_lock.\n\t */\n\tspin_lock(&journal->j_list_lock);\n\twhile (commit_transaction->t_forget) {\n\t\ttransaction_t *cp_transaction;\n\t\tstruct buffer_head *bh;\n\t\tint try_to_free = 0;\n\n\t\tjh = commit_transaction->t_forget;\n\t\tspin_unlock(&journal->j_list_lock);\n\t\tbh = jh2bh(jh);\n\t\t/*\n\t\t * Get a reference so that bh cannot be freed before we are\n\t\t * done with it.\n\t\t */\n\t\tget_bh(bh);\n\t\tjbd_lock_bh_state(bh);\n\t\tJ_ASSERT_JH(jh,\tjh->b_transaction == commit_transaction);\n\n\t\t/*\n\t\t * If there is undo-protected committed data against\n\t\t * this buffer, then we can remove it now.  If it is a\n\t\t * buffer needing such protection, the old frozen_data\n\t\t * field now points to a committed version of the\n\t\t * buffer, so rotate that field to the new committed\n\t\t * data.\n\t\t *\n\t\t * Otherwise, we can just throw away the frozen data now.\n\t\t *\n\t\t * We also know that the frozen data has already fired\n\t\t * its triggers if they exist, so we can clear that too.\n\t\t */\n\t\tif (jh->b_committed_data) {\n\t\t\tjbd2_free(jh->b_committed_data, bh->b_size);\n\t\t\tjh->b_committed_data = NULL;\n\t\t\tif (jh->b_frozen_data) {\n\t\t\t\tjh->b_committed_data = jh->b_frozen_data;\n\t\t\t\tjh->b_frozen_data = NULL;\n\t\t\t\tjh->b_frozen_triggers = NULL;\n\t\t\t}\n\t\t} else if (jh->b_frozen_data) {\n\t\t\tjbd2_free(jh->b_frozen_data, bh->b_size);\n\t\t\tjh->b_frozen_data = NULL;\n\t\t\tjh->b_frozen_triggers = NULL;\n\t\t}\n\n\t\tspin_lock(&journal->j_list_lock);\n\t\tcp_transaction = jh->b_cp_transaction;\n\t\tif (cp_transaction) {\n\t\t\tJBUFFER_TRACE(jh, \"remove from old cp transaction\");\n\t\t\tcp_transaction->t_chp_stats.cs_dropped++;\n\t\t\t__jbd2_journal_remove_checkpoint(jh);\n\t\t}\n\n\t\t/* Only re-checkpoint the buffer_head if it is marked\n\t\t * dirty.  If the buffer was added to the BJ_Forget list\n\t\t * by jbd2_journal_forget, it may no longer be dirty and\n\t\t * there's no point in keeping a checkpoint record for\n\t\t * it. */\n\n\t\t/*\n\t\t* A buffer which has been freed while still being journaled by\n\t\t* a previous transaction.\n\t\t*/\n\t\tif (buffer_freed(bh)) {\n\t\t\t/*\n\t\t\t * If the running transaction is the one containing\n\t\t\t * \"add to orphan\" operation (b_next_transaction !=\n\t\t\t * NULL), we have to wait for that transaction to\n\t\t\t * commit before we can really get rid of the buffer.\n\t\t\t * So just clear b_modified to not confuse transaction\n\t\t\t * credit accounting and refile the buffer to\n\t\t\t * BJ_Forget of the running transaction. If the just\n\t\t\t * committed transaction contains \"add to orphan\"\n\t\t\t * operation, we can completely invalidate the buffer\n\t\t\t * now. We are rather through in that since the\n\t\t\t * buffer may be still accessible when blocksize <\n\t\t\t * pagesize and it is attached to the last partial\n\t\t\t * page.\n\t\t\t */\n\t\t\tjh->b_modified = 0;\n\t\t\tif (!jh->b_next_transaction) {\n\t\t\t\tclear_buffer_freed(bh);\n\t\t\t\tclear_buffer_jbddirty(bh);\n\t\t\t\tclear_buffer_mapped(bh);\n\t\t\t\tclear_buffer_new(bh);\n\t\t\t\tclear_buffer_req(bh);\n\t\t\t\tbh->b_bdev = NULL;\n\t\t\t}\n\t\t}\n\n\t\tif (buffer_jbddirty(bh)) {\n\t\t\tJBUFFER_TRACE(jh, \"add to new checkpointing trans\");\n\t\t\t__jbd2_journal_insert_checkpoint(jh, commit_transaction);\n\t\t\tif (is_journal_aborted(journal))\n\t\t\t\tclear_buffer_jbddirty(bh);\n\t\t} else {\n\t\t\tJ_ASSERT_BH(bh, !buffer_dirty(bh));\n\t\t\t/*\n\t\t\t * The buffer on BJ_Forget list and not jbddirty means\n\t\t\t * it has been freed by this transaction and hence it\n\t\t\t * could not have been reallocated until this\n\t\t\t * transaction has committed. *BUT* it could be\n\t\t\t * reallocated once we have written all the data to\n\t\t\t * disk and before we process the buffer on BJ_Forget\n\t\t\t * list.\n\t\t\t */\n\t\t\tif (!jh->b_next_transaction)\n\t\t\t\ttry_to_free = 1;\n\t\t}\n\t\tJBUFFER_TRACE(jh, \"refile or unfile buffer\");\n\t\t__jbd2_journal_refile_buffer(jh);\n\t\tjbd_unlock_bh_state(bh);\n\t\tif (try_to_free)\n\t\t\trelease_buffer_page(bh);\t/* Drops bh reference */\n\t\telse\n\t\t\t__brelse(bh);\n\t\tcond_resched_lock(&journal->j_list_lock);\n\t}\n\tspin_unlock(&journal->j_list_lock);\n\t/*\n\t * This is a bit sleazy.  We use j_list_lock to protect transition\n\t * of a transaction into T_FINISHED state and calling\n\t * __jbd2_journal_drop_transaction(). Otherwise we could race with\n\t * other checkpointing code processing the transaction...\n\t */\n\twrite_lock(&journal->j_state_lock);\n\tspin_lock(&journal->j_list_lock);\n\t/*\n\t * Now recheck if some buffers did not get attached to the transaction\n\t * while the lock was dropped...\n\t */\n\tif (commit_transaction->t_forget) {\n\t\tspin_unlock(&journal->j_list_lock);\n\t\twrite_unlock(&journal->j_state_lock);\n\t\tgoto restart_loop;\n\t}\n\n\t/* Add the transaction to the checkpoint list\n\t * __journal_remove_checkpoint() can not destroy transaction\n\t * under us because it is not marked as T_FINISHED yet */\n\tif (journal->j_checkpoint_transactions == NULL) {\n\t\tjournal->j_checkpoint_transactions = commit_transaction;\n\t\tcommit_transaction->t_cpnext = commit_transaction;\n\t\tcommit_transaction->t_cpprev = commit_transaction;\n\t} else {\n\t\tcommit_transaction->t_cpnext =\n\t\t\tjournal->j_checkpoint_transactions;\n\t\tcommit_transaction->t_cpprev =\n\t\t\tcommit_transaction->t_cpnext->t_cpprev;\n\t\tcommit_transaction->t_cpnext->t_cpprev =\n\t\t\tcommit_transaction;\n\t\tcommit_transaction->t_cpprev->t_cpnext =\n\t\t\t\tcommit_transaction;\n\t}\n\tspin_unlock(&journal->j_list_lock);\n\n\t/* Done with this transaction! */\n\n\tjbd_debug(3, \"JBD2: commit phase 7\\n\");\n\n\tJ_ASSERT(commit_transaction->t_state == T_COMMIT_JFLUSH);\n\n\tcommit_transaction->t_start = jiffies;\n\tstats.run.rs_logging = jbd2_time_diff(stats.run.rs_logging,\n\t\t\t\t\t      commit_transaction->t_start);\n\n\t/*\n\t * File the transaction statistics\n\t */\n\tstats.ts_tid = commit_transaction->t_tid;\n\tstats.run.rs_handle_count =\n\t\tatomic_read(&commit_transaction->t_handle_count);\n\ttrace_jbd2_run_stats(journal->j_fs_dev->bd_dev,\n\t\t\t     commit_transaction->t_tid, &stats.run);\n\tstats.ts_requested = (commit_transaction->t_requested) ? 1 : 0;\n\n\tcommit_transaction->t_state = T_COMMIT_CALLBACK;\n\tJ_ASSERT(commit_transaction == journal->j_committing_transaction);\n\tjournal->j_commit_sequence = commit_transaction->t_tid;\n\tjournal->j_committing_transaction = NULL;\n\tcommit_time = ktime_to_ns(ktime_sub(ktime_get(), start_time));\n\n\t/*\n\t * weight the commit time higher than the average time so we don't\n\t * react too strongly to vast changes in the commit time\n\t */\n\tif (likely(journal->j_average_commit_time))\n\t\tjournal->j_average_commit_time = (commit_time +\n\t\t\t\tjournal->j_average_commit_time*3) / 4;\n\telse\n\t\tjournal->j_average_commit_time = commit_time;\n\n\twrite_unlock(&journal->j_state_lock);\n\n\tif (journal->j_commit_callback)\n\t\tjournal->j_commit_callback(journal, commit_transaction);\n\n\ttrace_jbd2_end_commit(journal, commit_transaction);\n\tjbd_debug(1, \"JBD2: commit %d complete, head %d\\n\",\n\t\t  journal->j_commit_sequence, journal->j_tail_sequence);\n\n\twrite_lock(&journal->j_state_lock);\n\tspin_lock(&journal->j_list_lock);\n\tcommit_transaction->t_state = T_FINISHED;\n\t/* Check if the transaction can be dropped now that we are finished */\n\tif (commit_transaction->t_checkpoint_list == NULL &&\n\t    commit_transaction->t_checkpoint_io_list == NULL) {\n\t\t__jbd2_journal_drop_transaction(journal, commit_transaction);\n\t\tjbd2_journal_free_transaction(commit_transaction);\n\t}\n\tspin_unlock(&journal->j_list_lock);\n\twrite_unlock(&journal->j_state_lock);\n\twake_up(&journal->j_wait_done_commit);\n\n\t/*\n\t * Calculate overall stats\n\t */\n\tspin_lock(&journal->j_history_lock);\n\tjournal->j_stats.ts_tid++;\n\tjournal->j_stats.ts_requested += stats.ts_requested;\n\tjournal->j_stats.run.rs_wait += stats.run.rs_wait;\n\tjournal->j_stats.run.rs_request_delay += stats.run.rs_request_delay;\n\tjournal->j_stats.run.rs_running += stats.run.rs_running;\n\tjournal->j_stats.run.rs_locked += stats.run.rs_locked;\n\tjournal->j_stats.run.rs_flushing += stats.run.rs_flushing;\n\tjournal->j_stats.run.rs_logging += stats.run.rs_logging;\n\tjournal->j_stats.run.rs_handle_count += stats.run.rs_handle_count;\n\tjournal->j_stats.run.rs_blocks += stats.run.rs_blocks;\n\tjournal->j_stats.run.rs_blocks_logged += stats.run.rs_blocks_logged;\n\tspin_unlock(&journal->j_history_lock);\n}",
    "includes": [
      "#include <trace/events/jbd2.h>",
      "#include <linux/bitops.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/bio.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/crc32.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mm.h>",
      "#include <linux/slab.h>",
      "#include <linux/errno.h>",
      "#include <linux/jbd2.h>",
      "#include <linux/fs.h>",
      "#include <linux/time.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&journal->j_history_lock"
          ],
          "line": 1163
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&journal->j_history_lock"
          ],
          "line": 1151
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "wake_up",
          "args": [
            "&journal->j_wait_done_commit"
          ],
          "line": 1146
        },
        "resolved": true,
        "details": {
          "function_name": "locks_wake_up_blocks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/locks.c",
          "lines": "656-681",
          "snippet": "static void locks_wake_up_blocks(struct file_lock *blocker)\n{\n\t/*\n\t * Avoid taking global lock if list is empty. This is safe since new\n\t * blocked requests are only added to the list under the flc_lock, and\n\t * the flc_lock is always held here. Note that removal from the fl_block\n\t * list does not require the flc_lock, so we must recheck list_empty()\n\t * after acquiring the blocked_lock_lock.\n\t */\n\tif (list_empty(&blocker->fl_block))\n\t\treturn;\n\n\tspin_lock(&blocked_lock_lock);\n\twhile (!list_empty(&blocker->fl_block)) {\n\t\tstruct file_lock *waiter;\n\n\t\twaiter = list_first_entry(&blocker->fl_block,\n\t\t\t\tstruct file_lock, fl_block);\n\t\t__locks_delete_block(waiter);\n\t\tif (waiter->fl_lmops && waiter->fl_lmops->lm_notify)\n\t\t\twaiter->fl_lmops->lm_notify(waiter);\n\t\telse\n\t\t\twake_up(&waiter->fl_wait);\n\t}\n\tspin_unlock(&blocked_lock_lock);\n}",
          "includes": [
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <asm/uaccess.h>",
            "#include <trace/events/filelock.h>",
            "#include <linux/lglock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/time.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_SPINLOCK(blocked_lock_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <asm/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/lglock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nstatic DEFINE_SPINLOCK(blocked_lock_lock);\n\nstatic void locks_wake_up_blocks(struct file_lock *blocker)\n{\n\t/*\n\t * Avoid taking global lock if list is empty. This is safe since new\n\t * blocked requests are only added to the list under the flc_lock, and\n\t * the flc_lock is always held here. Note that removal from the fl_block\n\t * list does not require the flc_lock, so we must recheck list_empty()\n\t * after acquiring the blocked_lock_lock.\n\t */\n\tif (list_empty(&blocker->fl_block))\n\t\treturn;\n\n\tspin_lock(&blocked_lock_lock);\n\twhile (!list_empty(&blocker->fl_block)) {\n\t\tstruct file_lock *waiter;\n\n\t\twaiter = list_first_entry(&blocker->fl_block,\n\t\t\t\tstruct file_lock, fl_block);\n\t\t__locks_delete_block(waiter);\n\t\tif (waiter->fl_lmops && waiter->fl_lmops->lm_notify)\n\t\t\twaiter->fl_lmops->lm_notify(waiter);\n\t\telse\n\t\t\twake_up(&waiter->fl_wait);\n\t}\n\tspin_unlock(&blocked_lock_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "write_unlock",
          "args": [
            "&journal->j_state_lock"
          ],
          "line": 1145
        },
        "resolved": true,
        "details": {
          "function_name": "reiserfs_write_unlock_nested",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/lock.c",
          "lines": "51-67",
          "snippet": "int __must_check reiserfs_write_unlock_nested(struct super_block *s)\n{\n\tstruct reiserfs_sb_info *sb_i = REISERFS_SB(s);\n\tint depth;\n\n\t/* this can happen when the lock isn't always held */\n\tif (sb_i->lock_owner != current)\n\t\treturn -1;\n\n\tdepth = sb_i->lock_depth;\n\n\tsb_i->lock_depth = -1;\n\tsb_i->lock_owner = NULL;\n\tmutex_unlock(&sb_i->lock);\n\n\treturn depth;\n}",
          "includes": [
            "#include <linux/mutex.h>",
            "#include \"reiserfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/mutex.h>\n#include \"reiserfs.h\"\n\nint __must_check reiserfs_write_unlock_nested(struct super_block *s)\n{\n\tstruct reiserfs_sb_info *sb_i = REISERFS_SB(s);\n\tint depth;\n\n\t/* this can happen when the lock isn't always held */\n\tif (sb_i->lock_owner != current)\n\t\treturn -1;\n\n\tdepth = sb_i->lock_depth;\n\n\tsb_i->lock_depth = -1;\n\tsb_i->lock_owner = NULL;\n\tmutex_unlock(&sb_i->lock);\n\n\treturn depth;\n}"
        }
      },
      {
        "call_info": {
          "callee": "jbd2_journal_free_transaction",
          "args": [
            "commit_transaction"
          ],
          "line": 1142
        },
        "resolved": true,
        "details": {
          "function_name": "jbd2_journal_free_transaction",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd2/transaction.c",
          "lines": "60-65",
          "snippet": "void jbd2_journal_free_transaction(transaction_t *transaction)\n{\n\tif (unlikely(ZERO_OR_NULL_PTR(transaction)))\n\t\treturn;\n\tkmem_cache_free(transaction_cache, transaction);\n}",
          "includes": [
            "#include <trace/events/jbd2.h>",
            "#include <linux/module.h>",
            "#include <linux/bug.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/timer.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *transaction_cache;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/jbd2.h>\n#include <linux/module.h>\n#include <linux/bug.h>\n#include <linux/backing-dev.h>\n#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/timer.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n\nstatic struct kmem_cache *transaction_cache;\n\nvoid jbd2_journal_free_transaction(transaction_t *transaction)\n{\n\tif (unlikely(ZERO_OR_NULL_PTR(transaction)))\n\t\treturn;\n\tkmem_cache_free(transaction_cache, transaction);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__jbd2_journal_drop_transaction",
          "args": [
            "journal",
            "commit_transaction"
          ],
          "line": 1141
        },
        "resolved": true,
        "details": {
          "function_name": "__jbd2_journal_drop_transaction",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd2/checkpoint.c",
          "lines": "619-645",
          "snippet": "void __jbd2_journal_drop_transaction(journal_t *journal, transaction_t *transaction)\n{\n\tassert_spin_locked(&journal->j_list_lock);\n\tif (transaction->t_cpnext) {\n\t\ttransaction->t_cpnext->t_cpprev = transaction->t_cpprev;\n\t\ttransaction->t_cpprev->t_cpnext = transaction->t_cpnext;\n\t\tif (journal->j_checkpoint_transactions == transaction)\n\t\t\tjournal->j_checkpoint_transactions =\n\t\t\t\ttransaction->t_cpnext;\n\t\tif (journal->j_checkpoint_transactions == transaction)\n\t\t\tjournal->j_checkpoint_transactions = NULL;\n\t}\n\n\tJ_ASSERT(transaction->t_state == T_FINISHED);\n\tJ_ASSERT(transaction->t_buffers == NULL);\n\tJ_ASSERT(transaction->t_forget == NULL);\n\tJ_ASSERT(transaction->t_shadow_list == NULL);\n\tJ_ASSERT(transaction->t_checkpoint_list == NULL);\n\tJ_ASSERT(transaction->t_checkpoint_io_list == NULL);\n\tJ_ASSERT(atomic_read(&transaction->t_updates) == 0);\n\tJ_ASSERT(journal->j_committing_transaction != transaction);\n\tJ_ASSERT(journal->j_running_transaction != transaction);\n\n\ttrace_jbd2_drop_transaction(journal, transaction);\n\n\tjbd_debug(1, \"Dropping transaction %d, all done\\n\", transaction->t_tid);\n}",
          "includes": [
            "#include <trace/events/jbd2.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/jbd2.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n\nvoid __jbd2_journal_drop_transaction(journal_t *journal, transaction_t *transaction)\n{\n\tassert_spin_locked(&journal->j_list_lock);\n\tif (transaction->t_cpnext) {\n\t\ttransaction->t_cpnext->t_cpprev = transaction->t_cpprev;\n\t\ttransaction->t_cpprev->t_cpnext = transaction->t_cpnext;\n\t\tif (journal->j_checkpoint_transactions == transaction)\n\t\t\tjournal->j_checkpoint_transactions =\n\t\t\t\ttransaction->t_cpnext;\n\t\tif (journal->j_checkpoint_transactions == transaction)\n\t\t\tjournal->j_checkpoint_transactions = NULL;\n\t}\n\n\tJ_ASSERT(transaction->t_state == T_FINISHED);\n\tJ_ASSERT(transaction->t_buffers == NULL);\n\tJ_ASSERT(transaction->t_forget == NULL);\n\tJ_ASSERT(transaction->t_shadow_list == NULL);\n\tJ_ASSERT(transaction->t_checkpoint_list == NULL);\n\tJ_ASSERT(transaction->t_checkpoint_io_list == NULL);\n\tJ_ASSERT(atomic_read(&transaction->t_updates) == 0);\n\tJ_ASSERT(journal->j_committing_transaction != transaction);\n\tJ_ASSERT(journal->j_running_transaction != transaction);\n\n\ttrace_jbd2_drop_transaction(journal, transaction);\n\n\tjbd_debug(1, \"Dropping transaction %d, all done\\n\", transaction->t_tid);\n}"
        }
      },
      {
        "call_info": {
          "callee": "write_lock",
          "args": [
            "&journal->j_state_lock"
          ],
          "line": 1135
        },
        "resolved": true,
        "details": {
          "function_name": "reiserfs_write_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/lock.c",
          "lines": "21-32",
          "snippet": "void reiserfs_write_lock(struct super_block *s)\n{\n\tstruct reiserfs_sb_info *sb_i = REISERFS_SB(s);\n\n\tif (sb_i->lock_owner != current) {\n\t\tmutex_lock(&sb_i->lock);\n\t\tsb_i->lock_owner = current;\n\t}\n\n\t/* No need to protect it, only the current task touches it */\n\tsb_i->lock_depth++;\n}",
          "includes": [
            "#include <linux/mutex.h>",
            "#include \"reiserfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/mutex.h>\n#include \"reiserfs.h\"\n\nvoid reiserfs_write_lock(struct super_block *s)\n{\n\tstruct reiserfs_sb_info *sb_i = REISERFS_SB(s);\n\n\tif (sb_i->lock_owner != current) {\n\t\tmutex_lock(&sb_i->lock);\n\t\tsb_i->lock_owner = current;\n\t}\n\n\t/* No need to protect it, only the current task touches it */\n\tsb_i->lock_depth++;\n}"
        }
      },
      {
        "call_info": {
          "callee": "jbd_debug",
          "args": [
            "1",
            "\"JBD2: commit %d complete, head %d\\n\"",
            "journal->j_commit_sequence",
            "journal->j_tail_sequence"
          ],
          "line": 1132
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_jbd2_end_commit",
          "args": [
            "journal",
            "commit_transaction"
          ],
          "line": 1131
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "journal->j_commit_callback",
          "args": [
            "journal",
            "commit_transaction"
          ],
          "line": 1129
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "likely",
          "args": [
            "journal->j_average_commit_time"
          ],
          "line": 1120
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ktime_to_ns",
          "args": [
            "ktime_sub(ktime_get(), start_time)"
          ],
          "line": 1114
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ktime_sub",
          "args": [
            "ktime_get()",
            "start_time"
          ],
          "line": 1114
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ktime_get",
          "args": [],
          "line": 1114
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "J_ASSERT",
          "args": [
            "commit_transaction == journal->j_committing_transaction"
          ],
          "line": 1111
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_jbd2_run_stats",
          "args": [
            "journal->j_fs_dev->bd_dev",
            "commit_transaction->t_tid",
            "&stats.run"
          ],
          "line": 1106
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&commit_transaction->t_handle_count"
          ],
          "line": 1105
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "jbd2_time_diff",
          "args": [
            "stats.run.rs_logging",
            "commit_transaction->t_start"
          ],
          "line": 1097
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "J_ASSERT",
          "args": [
            "commit_transaction->t_state == T_COMMIT_JFLUSH"
          ],
          "line": 1094
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "jbd_debug",
          "args": [
            "3",
            "\"JBD2: commit phase 7\\n\""
          ],
          "line": 1092
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cond_resched_lock",
          "args": [
            "&journal->j_list_lock"
          ],
          "line": 1050
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__brelse",
          "args": [
            "bh"
          ],
          "line": 1049
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "release_buffer_page",
          "args": [
            "bh"
          ],
          "line": 1047
        },
        "resolved": true,
        "details": {
          "function_name": "release_buffer_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd2/commit.c",
          "lines": "66-93",
          "snippet": "static void release_buffer_page(struct buffer_head *bh)\n{\n\tstruct page *page;\n\n\tif (buffer_dirty(bh))\n\t\tgoto nope;\n\tif (atomic_read(&bh->b_count) != 1)\n\t\tgoto nope;\n\tpage = bh->b_page;\n\tif (!page)\n\t\tgoto nope;\n\tif (page->mapping)\n\t\tgoto nope;\n\n\t/* OK, it's a truncated page */\n\tif (!trylock_page(page))\n\t\tgoto nope;\n\n\tpage_cache_get(page);\n\t__brelse(bh);\n\ttry_to_free_buffers(page);\n\tunlock_page(page);\n\tpage_cache_release(page);\n\treturn;\n\nnope:\n\t__brelse(bh);\n}",
          "includes": [
            "#include <trace/events/jbd2.h>",
            "#include <linux/bitops.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/bio.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/crc32.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/jbd2.h>\n#include <linux/bitops.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include <linux/backing-dev.h>\n#include <linux/writeback.h>\n#include <linux/crc32.h>\n#include <linux/jiffies.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n\nstatic void release_buffer_page(struct buffer_head *bh)\n{\n\tstruct page *page;\n\n\tif (buffer_dirty(bh))\n\t\tgoto nope;\n\tif (atomic_read(&bh->b_count) != 1)\n\t\tgoto nope;\n\tpage = bh->b_page;\n\tif (!page)\n\t\tgoto nope;\n\tif (page->mapping)\n\t\tgoto nope;\n\n\t/* OK, it's a truncated page */\n\tif (!trylock_page(page))\n\t\tgoto nope;\n\n\tpage_cache_get(page);\n\t__brelse(bh);\n\ttry_to_free_buffers(page);\n\tunlock_page(page);\n\tpage_cache_release(page);\n\treturn;\n\nnope:\n\t__brelse(bh);\n}"
        }
      },
      {
        "call_info": {
          "callee": "jbd_unlock_bh_state",
          "args": [
            "bh"
          ],
          "line": 1045
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__jbd2_journal_refile_buffer",
          "args": [
            "jh"
          ],
          "line": 1044
        },
        "resolved": true,
        "details": {
          "function_name": "__jbd2_journal_refile_buffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd2/transaction.c",
          "lines": "2306-2346",
          "snippet": "void __jbd2_journal_refile_buffer(struct journal_head *jh)\n{\n\tint was_dirty, jlist;\n\tstruct buffer_head *bh = jh2bh(jh);\n\n\tJ_ASSERT_JH(jh, jbd_is_locked_bh_state(bh));\n\tif (jh->b_transaction)\n\t\tassert_spin_locked(&jh->b_transaction->t_journal->j_list_lock);\n\n\t/* If the buffer is now unused, just drop it. */\n\tif (jh->b_next_transaction == NULL) {\n\t\t__jbd2_journal_unfile_buffer(jh);\n\t\treturn;\n\t}\n\n\t/*\n\t * It has been modified by a later transaction: add it to the new\n\t * transaction's metadata list.\n\t */\n\n\twas_dirty = test_clear_buffer_jbddirty(bh);\n\t__jbd2_journal_temp_unlink_buffer(jh);\n\t/*\n\t * We set b_transaction here because b_next_transaction will inherit\n\t * our jh reference and thus __jbd2_journal_file_buffer() must not\n\t * take a new one.\n\t */\n\tjh->b_transaction = jh->b_next_transaction;\n\tjh->b_next_transaction = NULL;\n\tif (buffer_freed(bh))\n\t\tjlist = BJ_Forget;\n\telse if (jh->b_modified)\n\t\tjlist = BJ_Metadata;\n\telse\n\t\tjlist = BJ_Reserved;\n\t__jbd2_journal_file_buffer(jh, jh->b_transaction, jlist);\n\tJ_ASSERT_JH(jh, jh->b_transaction->t_state == T_RUNNING);\n\n\tif (was_dirty)\n\t\tset_buffer_jbddirty(bh);\n}",
          "includes": [
            "#include <trace/events/jbd2.h>",
            "#include <linux/module.h>",
            "#include <linux/bug.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/timer.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __jbd2_journal_temp_unlink_buffer(struct journal_head *jh);",
            "static void __jbd2_journal_unfile_buffer(struct journal_head *jh);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/jbd2.h>\n#include <linux/module.h>\n#include <linux/bug.h>\n#include <linux/backing-dev.h>\n#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/timer.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n\nstatic void __jbd2_journal_temp_unlink_buffer(struct journal_head *jh);\nstatic void __jbd2_journal_unfile_buffer(struct journal_head *jh);\n\nvoid __jbd2_journal_refile_buffer(struct journal_head *jh)\n{\n\tint was_dirty, jlist;\n\tstruct buffer_head *bh = jh2bh(jh);\n\n\tJ_ASSERT_JH(jh, jbd_is_locked_bh_state(bh));\n\tif (jh->b_transaction)\n\t\tassert_spin_locked(&jh->b_transaction->t_journal->j_list_lock);\n\n\t/* If the buffer is now unused, just drop it. */\n\tif (jh->b_next_transaction == NULL) {\n\t\t__jbd2_journal_unfile_buffer(jh);\n\t\treturn;\n\t}\n\n\t/*\n\t * It has been modified by a later transaction: add it to the new\n\t * transaction's metadata list.\n\t */\n\n\twas_dirty = test_clear_buffer_jbddirty(bh);\n\t__jbd2_journal_temp_unlink_buffer(jh);\n\t/*\n\t * We set b_transaction here because b_next_transaction will inherit\n\t * our jh reference and thus __jbd2_journal_file_buffer() must not\n\t * take a new one.\n\t */\n\tjh->b_transaction = jh->b_next_transaction;\n\tjh->b_next_transaction = NULL;\n\tif (buffer_freed(bh))\n\t\tjlist = BJ_Forget;\n\telse if (jh->b_modified)\n\t\tjlist = BJ_Metadata;\n\telse\n\t\tjlist = BJ_Reserved;\n\t__jbd2_journal_file_buffer(jh, jh->b_transaction, jlist);\n\tJ_ASSERT_JH(jh, jh->b_transaction->t_state == T_RUNNING);\n\n\tif (was_dirty)\n\t\tset_buffer_jbddirty(bh);\n}"
        }
      },
      {
        "call_info": {
          "callee": "JBUFFER_TRACE",
          "args": [
            "jh",
            "\"refile or unfile buffer\""
          ],
          "line": 1043
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "J_ASSERT_BH",
          "args": [
            "bh",
            "!buffer_dirty(bh)"
          ],
          "line": 1030
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "buffer_dirty",
          "args": [
            "bh"
          ],
          "line": 1030
        },
        "resolved": true,
        "details": {
          "function_name": "mark_buffer_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1141-1167",
          "snippet": "void mark_buffer_dirty(struct buffer_head *bh)\n{\n\tWARN_ON_ONCE(!buffer_uptodate(bh));\n\n\ttrace_block_dirty_buffer(bh);\n\n\t/*\n\t * Very *carefully* optimize the it-is-already-dirty case.\n\t *\n\t * Don't let the final \"is it dirty\" escape to before we\n\t * perhaps modified the buffer.\n\t */\n\tif (buffer_dirty(bh)) {\n\t\tsmp_mb();\n\t\tif (buffer_dirty(bh))\n\t\t\treturn;\n\t}\n\n\tif (!test_set_buffer_dirty(bh)) {\n\t\tstruct page *page = bh->b_page;\n\t\tif (!TestSetPageDirty(page)) {\n\t\t\tstruct address_space *mapping = page_mapping(page);\n\t\t\tif (mapping)\n\t\t\t\t__set_page_dirty(page, mapping, 0);\n\t\t}\n\t}\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid mark_buffer_dirty(struct buffer_head *bh)\n{\n\tWARN_ON_ONCE(!buffer_uptodate(bh));\n\n\ttrace_block_dirty_buffer(bh);\n\n\t/*\n\t * Very *carefully* optimize the it-is-already-dirty case.\n\t *\n\t * Don't let the final \"is it dirty\" escape to before we\n\t * perhaps modified the buffer.\n\t */\n\tif (buffer_dirty(bh)) {\n\t\tsmp_mb();\n\t\tif (buffer_dirty(bh))\n\t\t\treturn;\n\t}\n\n\tif (!test_set_buffer_dirty(bh)) {\n\t\tstruct page *page = bh->b_page;\n\t\tif (!TestSetPageDirty(page)) {\n\t\t\tstruct address_space *mapping = page_mapping(page);\n\t\t\tif (mapping)\n\t\t\t\t__set_page_dirty(page, mapping, 0);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "clear_buffer_jbddirty",
          "args": [
            "bh"
          ],
          "line": 1028
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_journal_aborted",
          "args": [
            "journal"
          ],
          "line": 1027
        },
        "resolved": true,
        "details": {
          "function_name": "__reiserfs_is_journal_aborted",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/reiserfs.h",
          "lines": "760-764",
          "snippet": "static inline int __reiserfs_is_journal_aborted(struct reiserfs_journal\n\t\t\t\t\t\t*journal)\n{\n\treturn test_bit(J_ABORTED, &journal->j_state);\n}",
          "includes": [
            "#include <linux/buffer_head.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/bitops.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/slab.h>",
            "#include <linux/reiserfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/buffer_head.h>\n#include <linux/proc_fs.h>\n#include <linux/bitops.h>\n#include <asm/unaligned.h>\n#include <linux/workqueue.h>\n#include <linux/bug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/slab.h>\n#include <linux/reiserfs_fs.h>\n\nstatic inline int __reiserfs_is_journal_aborted(struct reiserfs_journal\n\t\t\t\t\t\t*journal)\n{\n\treturn test_bit(J_ABORTED, &journal->j_state);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__jbd2_journal_insert_checkpoint",
          "args": [
            "jh",
            "commit_transaction"
          ],
          "line": 1026
        },
        "resolved": true,
        "details": {
          "function_name": "__jbd2_journal_insert_checkpoint",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd2/checkpoint.c",
          "lines": "587-607",
          "snippet": "void __jbd2_journal_insert_checkpoint(struct journal_head *jh,\n\t\t\t       transaction_t *transaction)\n{\n\tJBUFFER_TRACE(jh, \"entry\");\n\tJ_ASSERT_JH(jh, buffer_dirty(jh2bh(jh)) || buffer_jbddirty(jh2bh(jh)));\n\tJ_ASSERT_JH(jh, jh->b_cp_transaction == NULL);\n\n\t/* Get reference for checkpointing transaction */\n\tjbd2_journal_grab_journal_head(jh2bh(jh));\n\tjh->b_cp_transaction = transaction;\n\n\tif (!transaction->t_checkpoint_list) {\n\t\tjh->b_cpnext = jh->b_cpprev = jh;\n\t} else {\n\t\tjh->b_cpnext = transaction->t_checkpoint_list;\n\t\tjh->b_cpprev = transaction->t_checkpoint_list->b_cpprev;\n\t\tjh->b_cpprev->b_cpnext = jh;\n\t\tjh->b_cpnext->b_cpprev = jh;\n\t}\n\ttransaction->t_checkpoint_list = jh;\n}",
          "includes": [
            "#include <trace/events/jbd2.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/jbd2.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n\nvoid __jbd2_journal_insert_checkpoint(struct journal_head *jh,\n\t\t\t       transaction_t *transaction)\n{\n\tJBUFFER_TRACE(jh, \"entry\");\n\tJ_ASSERT_JH(jh, buffer_dirty(jh2bh(jh)) || buffer_jbddirty(jh2bh(jh)));\n\tJ_ASSERT_JH(jh, jh->b_cp_transaction == NULL);\n\n\t/* Get reference for checkpointing transaction */\n\tjbd2_journal_grab_journal_head(jh2bh(jh));\n\tjh->b_cp_transaction = transaction;\n\n\tif (!transaction->t_checkpoint_list) {\n\t\tjh->b_cpnext = jh->b_cpprev = jh;\n\t} else {\n\t\tjh->b_cpnext = transaction->t_checkpoint_list;\n\t\tjh->b_cpprev = transaction->t_checkpoint_list->b_cpprev;\n\t\tjh->b_cpprev->b_cpnext = jh;\n\t\tjh->b_cpnext->b_cpprev = jh;\n\t}\n\ttransaction->t_checkpoint_list = jh;\n}"
        }
      },
      {
        "call_info": {
          "callee": "JBUFFER_TRACE",
          "args": [
            "jh",
            "\"add to new checkpointing trans\""
          ],
          "line": 1025
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "buffer_jbddirty",
          "args": [
            "bh"
          ],
          "line": 1024
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clear_buffer_req",
          "args": [
            "bh"
          ],
          "line": 1019
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clear_buffer_new",
          "args": [
            "bh"
          ],
          "line": 1018
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clear_buffer_mapped",
          "args": [
            "bh"
          ],
          "line": 1017
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clear_buffer_jbddirty",
          "args": [
            "bh"
          ],
          "line": 1016
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clear_buffer_freed",
          "args": [
            "bh"
          ],
          "line": 1015
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "buffer_freed",
          "args": [
            "bh"
          ],
          "line": 997
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__jbd2_journal_remove_checkpoint",
          "args": [
            "jh"
          ],
          "line": 984
        },
        "resolved": true,
        "details": {
          "function_name": "__jbd2_journal_remove_checkpoint",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd2/checkpoint.c",
          "lines": "527-577",
          "snippet": "int __jbd2_journal_remove_checkpoint(struct journal_head *jh)\n{\n\tstruct transaction_chp_stats_s *stats;\n\ttransaction_t *transaction;\n\tjournal_t *journal;\n\tint ret = 0;\n\n\tJBUFFER_TRACE(jh, \"entry\");\n\n\tif ((transaction = jh->b_cp_transaction) == NULL) {\n\t\tJBUFFER_TRACE(jh, \"not on transaction\");\n\t\tgoto out;\n\t}\n\tjournal = transaction->t_journal;\n\n\tJBUFFER_TRACE(jh, \"removing from transaction\");\n\t__buffer_unlink(jh);\n\tjh->b_cp_transaction = NULL;\n\tjbd2_journal_put_journal_head(jh);\n\n\tif (transaction->t_checkpoint_list != NULL ||\n\t    transaction->t_checkpoint_io_list != NULL)\n\t\tgoto out;\n\n\t/*\n\t * There is one special case to worry about: if we have just pulled the\n\t * buffer off a running or committing transaction's checkpoing list,\n\t * then even if the checkpoint list is empty, the transaction obviously\n\t * cannot be dropped!\n\t *\n\t * The locking here around t_state is a bit sleazy.\n\t * See the comment at the end of jbd2_journal_commit_transaction().\n\t */\n\tif (transaction->t_state != T_FINISHED)\n\t\tgoto out;\n\n\t/* OK, that was the last buffer for the transaction: we can now\n\t   safely remove this transaction from the log */\n\tstats = &transaction->t_chp_stats;\n\tif (stats->cs_chp_time)\n\t\tstats->cs_chp_time = jbd2_time_diff(stats->cs_chp_time,\n\t\t\t\t\t\t    jiffies);\n\ttrace_jbd2_checkpoint_stats(journal->j_fs_dev->bd_dev,\n\t\t\t\t    transaction->t_tid, stats);\n\n\t__jbd2_journal_drop_transaction(journal, transaction);\n\tjbd2_journal_free_transaction(transaction);\n\tret = 1;\nout:\n\treturn ret;\n}",
          "includes": [
            "#include <trace/events/jbd2.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/jbd2.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n\nint __jbd2_journal_remove_checkpoint(struct journal_head *jh)\n{\n\tstruct transaction_chp_stats_s *stats;\n\ttransaction_t *transaction;\n\tjournal_t *journal;\n\tint ret = 0;\n\n\tJBUFFER_TRACE(jh, \"entry\");\n\n\tif ((transaction = jh->b_cp_transaction) == NULL) {\n\t\tJBUFFER_TRACE(jh, \"not on transaction\");\n\t\tgoto out;\n\t}\n\tjournal = transaction->t_journal;\n\n\tJBUFFER_TRACE(jh, \"removing from transaction\");\n\t__buffer_unlink(jh);\n\tjh->b_cp_transaction = NULL;\n\tjbd2_journal_put_journal_head(jh);\n\n\tif (transaction->t_checkpoint_list != NULL ||\n\t    transaction->t_checkpoint_io_list != NULL)\n\t\tgoto out;\n\n\t/*\n\t * There is one special case to worry about: if we have just pulled the\n\t * buffer off a running or committing transaction's checkpoing list,\n\t * then even if the checkpoint list is empty, the transaction obviously\n\t * cannot be dropped!\n\t *\n\t * The locking here around t_state is a bit sleazy.\n\t * See the comment at the end of jbd2_journal_commit_transaction().\n\t */\n\tif (transaction->t_state != T_FINISHED)\n\t\tgoto out;\n\n\t/* OK, that was the last buffer for the transaction: we can now\n\t   safely remove this transaction from the log */\n\tstats = &transaction->t_chp_stats;\n\tif (stats->cs_chp_time)\n\t\tstats->cs_chp_time = jbd2_time_diff(stats->cs_chp_time,\n\t\t\t\t\t\t    jiffies);\n\ttrace_jbd2_checkpoint_stats(journal->j_fs_dev->bd_dev,\n\t\t\t\t    transaction->t_tid, stats);\n\n\t__jbd2_journal_drop_transaction(journal, transaction);\n\tjbd2_journal_free_transaction(transaction);\n\tret = 1;\nout:\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "JBUFFER_TRACE",
          "args": [
            "jh",
            "\"remove from old cp transaction\""
          ],
          "line": 982
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "jbd2_free",
          "args": [
            "jh->b_frozen_data",
            "bh->b_size"
          ],
          "line": 974
        },
        "resolved": true,
        "details": {
          "function_name": "jbd2_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd2/journal.c",
          "lines": "2299-2315",
          "snippet": "void jbd2_free(void *ptr, size_t size)\n{\n\tif (size == PAGE_SIZE) {\n\t\tfree_pages((unsigned long)ptr, 0);\n\t\treturn;\n\t}\n\tif (size > PAGE_SIZE) {\n\t\tint order = get_order(size);\n\n\t\tif (order < 3)\n\t\t\tfree_pages((unsigned long)ptr, order);\n\t\telse\n\t\t\tvfree(ptr);\n\t\treturn;\n\t}\n\tkmem_cache_free(get_slab(size), ptr);\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <asm/uaccess.h>",
            "#include <trace/events/jbd2.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/bitops.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/log2.h>",
            "#include <linux/hash.h>",
            "#include <linux/math64.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/poison.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <trace/events/jbd2.h>\n#include <linux/ratelimit.h>\n#include <linux/bitops.h>\n#include <linux/backing-dev.h>\n#include <linux/vmalloc.h>\n#include <linux/log2.h>\n#include <linux/hash.h>\n#include <linux/math64.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/poison.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/freezer.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nvoid jbd2_free(void *ptr, size_t size)\n{\n\tif (size == PAGE_SIZE) {\n\t\tfree_pages((unsigned long)ptr, 0);\n\t\treturn;\n\t}\n\tif (size > PAGE_SIZE) {\n\t\tint order = get_order(size);\n\n\t\tif (order < 3)\n\t\t\tfree_pages((unsigned long)ptr, order);\n\t\telse\n\t\t\tvfree(ptr);\n\t\treturn;\n\t}\n\tkmem_cache_free(get_slab(size), ptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "J_ASSERT_JH",
          "args": [
            "jh",
            "jh->b_transaction == commit_transaction"
          ],
          "line": 950
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "jbd_lock_bh_state",
          "args": [
            "bh"
          ],
          "line": 949
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_bh",
          "args": [
            "bh"
          ],
          "line": 948
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "jh2bh",
          "args": [
            "jh"
          ],
          "line": 943
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "J_ASSERT",
          "args": [
            "commit_transaction->t_shadow_list == NULL"
          ],
          "line": 928
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "J_ASSERT",
          "args": [
            "commit_transaction->t_checkpoint_list == NULL"
          ],
          "line": 927
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "J_ASSERT",
          "args": [
            "commit_transaction->t_buffers == NULL"
          ],
          "line": 926
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "J_ASSERT",
          "args": [
            "list_empty(&commit_transaction->t_inode_list)"
          ],
          "line": 925
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&commit_transaction->t_inode_list"
          ],
          "line": 925
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_dirty_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmthread.c",
          "lines": "505-514",
          "snippet": "static int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_flush_asts(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_flush_asts(struct dlm_ctxt *dlm);\n\nstatic int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}"
        }
      },
      {
        "call_info": {
          "callee": "jbd_debug",
          "args": [
            "3",
            "\"JBD2: commit phase 6\\n\""
          ],
          "line": 923
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "jbd2_update_log_tail",
          "args": [
            "journal",
            "first_tid",
            "first_block"
          ],
          "line": 916
        },
        "resolved": true,
        "details": {
          "function_name": "jbd2_update_log_tail",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd2/journal.c",
          "lines": "923-929",
          "snippet": "void jbd2_update_log_tail(journal_t *journal, tid_t tid, unsigned long block)\n{\n\tmutex_lock(&journal->j_checkpoint_mutex);\n\tif (tid_gt(tid, journal->j_tail_sequence))\n\t\t__jbd2_update_log_tail(journal, tid, block);\n\tmutex_unlock(&journal->j_checkpoint_mutex);\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <asm/uaccess.h>",
            "#include <trace/events/jbd2.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/bitops.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/log2.h>",
            "#include <linux/hash.h>",
            "#include <linux/math64.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/poison.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <trace/events/jbd2.h>\n#include <linux/ratelimit.h>\n#include <linux/bitops.h>\n#include <linux/backing-dev.h>\n#include <linux/vmalloc.h>\n#include <linux/log2.h>\n#include <linux/hash.h>\n#include <linux/math64.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/poison.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/freezer.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nvoid jbd2_update_log_tail(journal_t *journal, tid_t tid, unsigned long block)\n{\n\tmutex_lock(&journal->j_checkpoint_mutex);\n\tif (tid_gt(tid, journal->j_tail_sequence))\n\t\t__jbd2_update_log_tail(journal, tid, block);\n\tmutex_unlock(&journal->j_checkpoint_mutex);\n}"
        }
      },
      {
        "call_info": {
          "callee": "jbd2_journal_abort",
          "args": [
            "journal",
            "err"
          ],
          "line": 908
        },
        "resolved": true,
        "details": {
          "function_name": "jbd2_journal_abort",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd2/journal.c",
          "lines": "2106-2109",
          "snippet": "void jbd2_journal_abort(journal_t *journal, int errno)\n{\n\t__journal_abort_soft(journal, errno);\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <asm/uaccess.h>",
            "#include <trace/events/jbd2.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/bitops.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/log2.h>",
            "#include <linux/hash.h>",
            "#include <linux/math64.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/poison.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __journal_abort_soft (journal_t *journal, int errno);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <trace/events/jbd2.h>\n#include <linux/ratelimit.h>\n#include <linux/bitops.h>\n#include <linux/backing-dev.h>\n#include <linux/vmalloc.h>\n#include <linux/log2.h>\n#include <linux/hash.h>\n#include <linux/math64.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/poison.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/freezer.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nstatic void __journal_abort_soft (journal_t *journal, int errno);\n\nvoid jbd2_journal_abort(journal_t *journal, int errno)\n{\n\t__journal_abort_soft(journal, errno);\n}"
        }
      },
      {
        "call_info": {
          "callee": "blkdev_issue_flush",
          "args": [
            "journal->j_dev",
            "GFP_NOFS",
            "NULL"
          ],
          "line": 904
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "JBD2_HAS_INCOMPAT_FEATURE",
          "args": [
            "journal",
            "JBD2_FEATURE_INCOMPAT_ASYNC_COMMIT"
          ],
          "line": 901
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "journal_wait_on_commit_record",
          "args": [
            "journal",
            "cbh"
          ],
          "line": 900
        },
        "resolved": true,
        "details": {
          "function_name": "journal_wait_on_commit_record",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd2/commit.c",
          "lines": "174-187",
          "snippet": "static int journal_wait_on_commit_record(journal_t *journal,\n\t\t\t\t\t struct buffer_head *bh)\n{\n\tint ret = 0;\n\n\tclear_buffer_dirty(bh);\n\twait_on_buffer(bh);\n\n\tif (unlikely(!buffer_uptodate(bh)))\n\t\tret = -EIO;\n\tput_bh(bh);            /* One for getblk() */\n\n\treturn ret;\n}",
          "includes": [
            "#include <trace/events/jbd2.h>",
            "#include <linux/bitops.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/bio.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/crc32.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/jbd2.h>\n#include <linux/bitops.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include <linux/backing-dev.h>\n#include <linux/writeback.h>\n#include <linux/crc32.h>\n#include <linux/jiffies.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n\nstatic int journal_wait_on_commit_record(journal_t *journal,\n\t\t\t\t\t struct buffer_head *bh)\n{\n\tint ret = 0;\n\n\tclear_buffer_dirty(bh);\n\twait_on_buffer(bh);\n\n\tif (unlikely(!buffer_uptodate(bh)))\n\t\tret = -EIO;\n\tput_bh(bh);            /* One for getblk() */\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "__jbd2_journal_abort_hard",
          "args": [
            "journal"
          ],
          "line": 897
        },
        "resolved": true,
        "details": {
          "function_name": "__jbd2_journal_abort_hard",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd2/journal.c",
          "lines": "2026-2042",
          "snippet": "void __jbd2_journal_abort_hard(journal_t *journal)\n{\n\ttransaction_t *transaction;\n\n\tif (journal->j_flags & JBD2_ABORT)\n\t\treturn;\n\n\tprintk(KERN_ERR \"Aborting journal on device %s.\\n\",\n\t       journal->j_devname);\n\n\twrite_lock(&journal->j_state_lock);\n\tjournal->j_flags |= JBD2_ABORT;\n\ttransaction = journal->j_running_transaction;\n\tif (transaction)\n\t\t__jbd2_log_start_commit(journal, transaction->t_tid);\n\twrite_unlock(&journal->j_state_lock);\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <asm/uaccess.h>",
            "#include <trace/events/jbd2.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/bitops.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/log2.h>",
            "#include <linux/hash.h>",
            "#include <linux/math64.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/poison.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <trace/events/jbd2.h>\n#include <linux/ratelimit.h>\n#include <linux/bitops.h>\n#include <linux/backing-dev.h>\n#include <linux/vmalloc.h>\n#include <linux/log2.h>\n#include <linux/hash.h>\n#include <linux/math64.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/poison.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/freezer.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nvoid __jbd2_journal_abort_hard(journal_t *journal)\n{\n\ttransaction_t *transaction;\n\n\tif (journal->j_flags & JBD2_ABORT)\n\t\treturn;\n\n\tprintk(KERN_ERR \"Aborting journal on device %s.\\n\",\n\t       journal->j_devname);\n\n\twrite_lock(&journal->j_state_lock);\n\tjournal->j_flags |= JBD2_ABORT;\n\ttransaction = journal->j_running_transaction;\n\tif (transaction)\n\t\t__jbd2_log_start_commit(journal, transaction->t_tid);\n\twrite_unlock(&journal->j_state_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "journal_submit_commit_record",
          "args": [
            "journal",
            "commit_transaction",
            "&cbh",
            "crc32_sum"
          ],
          "line": 894
        },
        "resolved": true,
        "details": {
          "function_name": "journal_submit_commit_record",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd2/commit.c",
          "lines": "119-168",
          "snippet": "static int journal_submit_commit_record(journal_t *journal,\n\t\t\t\t\ttransaction_t *commit_transaction,\n\t\t\t\t\tstruct buffer_head **cbh,\n\t\t\t\t\t__u32 crc32_sum)\n{\n\tstruct commit_header *tmp;\n\tstruct buffer_head *bh;\n\tint ret;\n\tstruct timespec now = current_kernel_time();\n\n\t*cbh = NULL;\n\n\tif (is_journal_aborted(journal))\n\t\treturn 0;\n\n\tbh = jbd2_journal_get_descriptor_buffer(journal);\n\tif (!bh)\n\t\treturn 1;\n\n\ttmp = (struct commit_header *)bh->b_data;\n\ttmp->h_magic = cpu_to_be32(JBD2_MAGIC_NUMBER);\n\ttmp->h_blocktype = cpu_to_be32(JBD2_COMMIT_BLOCK);\n\ttmp->h_sequence = cpu_to_be32(commit_transaction->t_tid);\n\ttmp->h_commit_sec = cpu_to_be64(now.tv_sec);\n\ttmp->h_commit_nsec = cpu_to_be32(now.tv_nsec);\n\n\tif (JBD2_HAS_COMPAT_FEATURE(journal,\n\t\t\t\t    JBD2_FEATURE_COMPAT_CHECKSUM)) {\n\t\ttmp->h_chksum_type \t= JBD2_CRC32_CHKSUM;\n\t\ttmp->h_chksum_size \t= JBD2_CRC32_CHKSUM_SIZE;\n\t\ttmp->h_chksum[0] \t= cpu_to_be32(crc32_sum);\n\t}\n\tjbd2_commit_block_csum_set(journal, bh);\n\n\tBUFFER_TRACE(bh, \"submit commit block\");\n\tlock_buffer(bh);\n\tclear_buffer_dirty(bh);\n\tset_buffer_uptodate(bh);\n\tbh->b_end_io = journal_end_buffer_io_sync;\n\n\tif (journal->j_flags & JBD2_BARRIER &&\n\t    !JBD2_HAS_INCOMPAT_FEATURE(journal,\n\t\t\t\t       JBD2_FEATURE_INCOMPAT_ASYNC_COMMIT))\n\t\tret = submit_bh(WRITE_SYNC | WRITE_FLUSH_FUA, bh);\n\telse\n\t\tret = submit_bh(WRITE_SYNC, bh);\n\n\t*cbh = bh;\n\treturn ret;\n}",
          "includes": [
            "#include <trace/events/jbd2.h>",
            "#include <linux/bitops.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/bio.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/crc32.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/jbd2.h>\n#include <linux/bitops.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include <linux/backing-dev.h>\n#include <linux/writeback.h>\n#include <linux/crc32.h>\n#include <linux/jiffies.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n\nstatic int journal_submit_commit_record(journal_t *journal,\n\t\t\t\t\ttransaction_t *commit_transaction,\n\t\t\t\t\tstruct buffer_head **cbh,\n\t\t\t\t\t__u32 crc32_sum)\n{\n\tstruct commit_header *tmp;\n\tstruct buffer_head *bh;\n\tint ret;\n\tstruct timespec now = current_kernel_time();\n\n\t*cbh = NULL;\n\n\tif (is_journal_aborted(journal))\n\t\treturn 0;\n\n\tbh = jbd2_journal_get_descriptor_buffer(journal);\n\tif (!bh)\n\t\treturn 1;\n\n\ttmp = (struct commit_header *)bh->b_data;\n\ttmp->h_magic = cpu_to_be32(JBD2_MAGIC_NUMBER);\n\ttmp->h_blocktype = cpu_to_be32(JBD2_COMMIT_BLOCK);\n\ttmp->h_sequence = cpu_to_be32(commit_transaction->t_tid);\n\ttmp->h_commit_sec = cpu_to_be64(now.tv_sec);\n\ttmp->h_commit_nsec = cpu_to_be32(now.tv_nsec);\n\n\tif (JBD2_HAS_COMPAT_FEATURE(journal,\n\t\t\t\t    JBD2_FEATURE_COMPAT_CHECKSUM)) {\n\t\ttmp->h_chksum_type \t= JBD2_CRC32_CHKSUM;\n\t\ttmp->h_chksum_size \t= JBD2_CRC32_CHKSUM_SIZE;\n\t\ttmp->h_chksum[0] \t= cpu_to_be32(crc32_sum);\n\t}\n\tjbd2_commit_block_csum_set(journal, bh);\n\n\tBUFFER_TRACE(bh, \"submit commit block\");\n\tlock_buffer(bh);\n\tclear_buffer_dirty(bh);\n\tset_buffer_uptodate(bh);\n\tbh->b_end_io = journal_end_buffer_io_sync;\n\n\tif (journal->j_flags & JBD2_BARRIER &&\n\t    !JBD2_HAS_INCOMPAT_FEATURE(journal,\n\t\t\t\t       JBD2_FEATURE_INCOMPAT_ASYNC_COMMIT))\n\t\tret = submit_bh(WRITE_SYNC | WRITE_FLUSH_FUA, bh);\n\telse\n\t\tret = submit_bh(WRITE_SYNC, bh);\n\n\t*cbh = bh;\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "JBD2_HAS_INCOMPAT_FEATURE",
          "args": [
            "journal",
            "JBD2_FEATURE_INCOMPAT_ASYNC_COMMIT"
          ],
          "line": 892
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "J_ASSERT",
          "args": [
            "commit_transaction->t_state == T_COMMIT_DFLUSH"
          ],
          "line": 888
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "jbd_debug",
          "args": [
            "3",
            "\"JBD2: commit phase 5\\n\""
          ],
          "line": 886
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "jbd2_unfile_log_bh",
          "args": [
            "bh"
          ],
          "line": 878
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clear_buffer_jwrite",
          "args": [
            "bh"
          ],
          "line": 877
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUFFER_TRACE",
          "args": [
            "bh",
            "\"ph5: control buffer writeout done: unfile\""
          ],
          "line": 876
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!buffer_uptodate(bh)"
          ],
          "line": 873
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "buffer_uptodate",
          "args": [
            "bh"
          ],
          "line": 873
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_set_buffer_uptodate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/disk-io.c",
          "lines": "3758-3761",
          "snippet": "int btrfs_set_buffer_uptodate(struct extent_buffer *buf)\n{\n\treturn set_extent_buffer_uptodate(buf);\n}",
          "includes": [
            "#include <asm/cpufeature.h>",
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"raid56.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/uuid.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/migrate.h>",
            "#include <linux/slab.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/writeback.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/swap.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/cpufeature.h>\n#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"raid56.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <asm/unaligned.h>\n#include <linux/semaphore.h>\n#include <linux/uuid.h>\n#include <linux/ratelimit.h>\n#include <linux/migrate.h>\n#include <linux/slab.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/radix-tree.h>\n#include <linux/swap.h>\n#include <linux/scatterlist.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nint btrfs_set_buffer_uptodate(struct extent_buffer *buf)\n{\n\treturn set_extent_buffer_uptodate(buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cond_resched",
          "args": [],
          "line": 871
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wait_on_buffer",
          "args": [
            "bh"
          ],
          "line": 870
        },
        "resolved": true,
        "details": {
          "function_name": "__wait_on_buffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "117-120",
          "snippet": "void __wait_on_buffer(struct buffer_head * bh)\n{\n\twait_on_bit_io(&bh->b_state, BH_Lock, TASK_UNINTERRUPTIBLE);\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __wait_on_buffer(struct buffer_head * bh)\n{\n\twait_on_bit_io(&bh->b_state, BH_Lock, TASK_UNINTERRUPTIBLE);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_entry",
          "args": [
            "log_bufs.prev",
            "structbuffer_head",
            "b_assoc_buffers"
          ],
          "line": 869
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "jbd_debug",
          "args": [
            "3",
            "\"JBD2: commit phase 4\\n\""
          ],
          "line": 863
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "J_ASSERT",
          "args": [
            "commit_transaction->t_shadow_list == NULL"
          ],
          "line": 861
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "JBUFFER_TRACE",
          "args": [
            "jh",
            "\"brelse shadowed buffer\""
          ],
          "line": 857
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "jbd2_journal_file_buffer",
          "args": [
            "jh",
            "commit_transaction",
            "BJ_Forget"
          ],
          "line": 856
        },
        "resolved": true,
        "details": {
          "function_name": "jbd2_journal_file_buffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd2/transaction.c",
          "lines": "2285-2293",
          "snippet": "void jbd2_journal_file_buffer(struct journal_head *jh,\n\t\t\t\ttransaction_t *transaction, int jlist)\n{\n\tjbd_lock_bh_state(jh2bh(jh));\n\tspin_lock(&transaction->t_journal->j_list_lock);\n\t__jbd2_journal_file_buffer(jh, transaction, jlist);\n\tspin_unlock(&transaction->t_journal->j_list_lock);\n\tjbd_unlock_bh_state(jh2bh(jh));\n}",
          "includes": [
            "#include <trace/events/jbd2.h>",
            "#include <linux/module.h>",
            "#include <linux/bug.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/timer.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __jbd2_journal_temp_unlink_buffer(struct journal_head *jh);",
            "static void __jbd2_journal_unfile_buffer(struct journal_head *jh);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/jbd2.h>\n#include <linux/module.h>\n#include <linux/bug.h>\n#include <linux/backing-dev.h>\n#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/timer.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n\nstatic void __jbd2_journal_temp_unlink_buffer(struct journal_head *jh);\nstatic void __jbd2_journal_unfile_buffer(struct journal_head *jh);\n\nvoid jbd2_journal_file_buffer(struct journal_head *jh,\n\t\t\t\ttransaction_t *transaction, int jlist)\n{\n\tjbd_lock_bh_state(jh2bh(jh));\n\tspin_lock(&transaction->t_journal->j_list_lock);\n\t__jbd2_journal_file_buffer(jh, transaction, jlist);\n\tspin_unlock(&transaction->t_journal->j_list_lock);\n\tjbd_unlock_bh_state(jh2bh(jh));\n}"
        }
      },
      {
        "call_info": {
          "callee": "JBUFFER_TRACE",
          "args": [
            "jh",
            "\"file as BJ_Forget\""
          ],
          "line": 855
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "J_ASSERT_BH",
          "args": [
            "bh",
            "!buffer_shadow(bh)"
          ],
          "line": 849
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "buffer_shadow",
          "args": [
            "bh"
          ],
          "line": 849
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "J_ASSERT_BH",
          "args": [
            "bh",
            "buffer_jbddirty(bh)"
          ],
          "line": 848
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "buffer_jbddirty",
          "args": [
            "bh"
          ],
          "line": 848
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clear_buffer_jwrite",
          "args": [
            "bh"
          ],
          "line": 847
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "jh2bh",
          "args": [
            "jh"
          ],
          "line": 846
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free_buffer_head",
          "args": [
            "bh"
          ],
          "line": 842
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "J_ASSERT_BH",
          "args": [
            "bh",
            "atomic_read(&bh->b_count) == 0"
          ],
          "line": 841
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&bh->b_count"
          ],
          "line": 841
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUFFER_TRACE",
          "args": [
            "bh",
            "\"dumping temporary bh\""
          ],
          "line": 839
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "jbd2_unfile_log_bh",
          "args": [
            "bh"
          ],
          "line": 833
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!buffer_uptodate(bh)"
          ],
          "line": 831
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cond_resched",
          "args": [],
          "line": 829
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_entry",
          "args": [
            "io_bufs.prev",
            "structbuffer_head",
            "b_assoc_buffers"
          ],
          "line": 824
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "jbd_debug",
          "args": [
            "3",
            "\"JBD2: commit phase 3\\n\""
          ],
          "line": 821
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "blk_finish_plug",
          "args": [
            "&plug"
          ],
          "line": 808
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "JBD2_HAS_INCOMPAT_FEATURE",
          "args": [
            "journal",
            "JBD2_FEATURE_INCOMPAT_ASYNC_COMMIT"
          ],
          "line": 800
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "blkdev_issue_flush",
          "args": [
            "journal->j_fs_dev",
            "GFP_NOFS",
            "NULL"
          ],
          "line": 797
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "J_ASSERT",
          "args": [
            "commit_transaction->t_state == T_COMMIT"
          ],
          "line": 785
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "jbd2_journal_get_log_tail",
          "args": [
            "journal",
            "&first_tid",
            "&first_block"
          ],
          "line": 773
        },
        "resolved": true,
        "details": {
          "function_name": "jbd2_journal_get_log_tail",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd2/journal.c",
          "lines": "849-876",
          "snippet": "int jbd2_journal_get_log_tail(journal_t *journal, tid_t *tid,\n\t\t\t      unsigned long *block)\n{\n\ttransaction_t *transaction;\n\tint ret;\n\n\tread_lock(&journal->j_state_lock);\n\tspin_lock(&journal->j_list_lock);\n\ttransaction = journal->j_checkpoint_transactions;\n\tif (transaction) {\n\t\t*tid = transaction->t_tid;\n\t\t*block = transaction->t_log_start;\n\t} else if ((transaction = journal->j_committing_transaction) != NULL) {\n\t\t*tid = transaction->t_tid;\n\t\t*block = transaction->t_log_start;\n\t} else if ((transaction = journal->j_running_transaction) != NULL) {\n\t\t*tid = transaction->t_tid;\n\t\t*block = journal->j_head;\n\t} else {\n\t\t*tid = journal->j_transaction_sequence;\n\t\t*block = journal->j_head;\n\t}\n\tret = tid_gt(*tid, journal->j_tail_sequence);\n\tspin_unlock(&journal->j_list_lock);\n\tread_unlock(&journal->j_state_lock);\n\n\treturn ret;\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <asm/uaccess.h>",
            "#include <trace/events/jbd2.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/bitops.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/log2.h>",
            "#include <linux/hash.h>",
            "#include <linux/math64.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/poison.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <trace/events/jbd2.h>\n#include <linux/ratelimit.h>\n#include <linux/bitops.h>\n#include <linux/backing-dev.h>\n#include <linux/vmalloc.h>\n#include <linux/log2.h>\n#include <linux/hash.h>\n#include <linux/math64.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/poison.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/freezer.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nint jbd2_journal_get_log_tail(journal_t *journal, tid_t *tid,\n\t\t\t      unsigned long *block)\n{\n\ttransaction_t *transaction;\n\tint ret;\n\n\tread_lock(&journal->j_state_lock);\n\tspin_lock(&journal->j_list_lock);\n\ttransaction = journal->j_checkpoint_transactions;\n\tif (transaction) {\n\t\t*tid = transaction->t_tid;\n\t\t*block = transaction->t_log_start;\n\t} else if ((transaction = journal->j_committing_transaction) != NULL) {\n\t\t*tid = transaction->t_tid;\n\t\t*block = transaction->t_log_start;\n\t} else if ((transaction = journal->j_running_transaction) != NULL) {\n\t\t*tid = transaction->t_tid;\n\t\t*block = journal->j_head;\n\t} else {\n\t\t*tid = journal->j_transaction_sequence;\n\t\t*block = journal->j_head;\n\t}\n\tret = tid_gt(*tid, journal->j_tail_sequence);\n\tspin_unlock(&journal->j_list_lock);\n\tread_unlock(&journal->j_state_lock);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_WARNING\n\t\t\t\"JBD2: Detected IO errors while flushing file data \"\n\t\t       \"on %s\\n\"",
            "journal->j_devname"
          ],
          "line": 757
        },
        "resolved": true,
        "details": {
          "function_name": "compat_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/compat.c",
          "lines": "59-69",
          "snippet": "int compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/ioctls.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/aio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/mm.h>",
            "#include <linux/poll.h>",
            "#include <linux/signal.h>",
            "#include <linux/highmem.h>",
            "#include <linux/security.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/personality.h>",
            "#include <linux/highuid.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/dirent.h>",
            "#include <linux/ctype.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/nfs4_mount.h>",
            "#include <linux/ncp_mount.h>",
            "#include <linux/init.h>",
            "#include <linux/ioctl.h>",
            "#include <linux/vfs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/namei.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/errno.h>",
            "#include <linux/compat.h>",
            "#include <linux/linkage.h>",
            "#include <linux/kernel.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int compat_log = 1;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/ioctls.h>\n#include <asm/mmu_context.h>\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/fs_struct.h>\n#include <linux/mm.h>\n#include <linux/poll.h>\n#include <linux/signal.h>\n#include <linux/highmem.h>\n#include <linux/security.h>\n#include <linux/tsacct_kern.h>\n#include <linux/rwsem.h>\n#include <linux/personality.h>\n#include <linux/highuid.h>\n#include <linux/fsnotify.h>\n#include <linux/dirent.h>\n#include <linux/ctype.h>\n#include <linux/syscalls.h>\n#include <linux/nfs4_mount.h>\n#include <linux/ncp_mount.h>\n#include <linux/init.h>\n#include <linux/ioctl.h>\n#include <linux/vfs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/namei.h>\n#include <linux/fcntl.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <linux/compat.h>\n#include <linux/linkage.h>\n#include <linux/kernel.h>\n#include <linux/stddef.h>\n\nint compat_log = 1;\n\nint compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "journal_finish_inode_data_buffers",
          "args": [
            "journal",
            "commit_transaction"
          ],
          "line": 755
        },
        "resolved": true,
        "details": {
          "function_name": "journal_finish_inode_data_buffers",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd2/commit.c",
          "lines": "254-300",
          "snippet": "static int journal_finish_inode_data_buffers(journal_t *journal,\n\t\ttransaction_t *commit_transaction)\n{\n\tstruct jbd2_inode *jinode, *next_i;\n\tint err, ret = 0;\n\n\t/* For locking, see the comment in journal_submit_data_buffers() */\n\tspin_lock(&journal->j_list_lock);\n\tlist_for_each_entry(jinode, &commit_transaction->t_inode_list, i_list) {\n\t\tset_bit(__JI_COMMIT_RUNNING, &jinode->i_flags);\n\t\tspin_unlock(&journal->j_list_lock);\n\t\terr = filemap_fdatawait(jinode->i_vfs_inode->i_mapping);\n\t\tif (err) {\n\t\t\t/*\n\t\t\t * Because AS_EIO is cleared by\n\t\t\t * filemap_fdatawait_range(), set it again so\n\t\t\t * that user process can get -EIO from fsync().\n\t\t\t */\n\t\t\tset_bit(AS_EIO,\n\t\t\t\t&jinode->i_vfs_inode->i_mapping->flags);\n\n\t\t\tif (!ret)\n\t\t\t\tret = err;\n\t\t}\n\t\tspin_lock(&journal->j_list_lock);\n\t\tclear_bit(__JI_COMMIT_RUNNING, &jinode->i_flags);\n\t\tsmp_mb__after_atomic();\n\t\twake_up_bit(&jinode->i_flags, __JI_COMMIT_RUNNING);\n\t}\n\n\t/* Now refile inode to proper lists */\n\tlist_for_each_entry_safe(jinode, next_i,\n\t\t\t\t &commit_transaction->t_inode_list, i_list) {\n\t\tlist_del(&jinode->i_list);\n\t\tif (jinode->i_next_transaction) {\n\t\t\tjinode->i_transaction = jinode->i_next_transaction;\n\t\t\tjinode->i_next_transaction = NULL;\n\t\t\tlist_add(&jinode->i_list,\n\t\t\t\t&jinode->i_transaction->t_inode_list);\n\t\t} else {\n\t\t\tjinode->i_transaction = NULL;\n\t\t}\n\t}\n\tspin_unlock(&journal->j_list_lock);\n\n\treturn ret;\n}",
          "includes": [
            "#include <trace/events/jbd2.h>",
            "#include <linux/bitops.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/bio.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/crc32.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/jbd2.h>\n#include <linux/bitops.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include <linux/backing-dev.h>\n#include <linux/writeback.h>\n#include <linux/crc32.h>\n#include <linux/jiffies.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n\nstatic int journal_finish_inode_data_buffers(journal_t *journal,\n\t\ttransaction_t *commit_transaction)\n{\n\tstruct jbd2_inode *jinode, *next_i;\n\tint err, ret = 0;\n\n\t/* For locking, see the comment in journal_submit_data_buffers() */\n\tspin_lock(&journal->j_list_lock);\n\tlist_for_each_entry(jinode, &commit_transaction->t_inode_list, i_list) {\n\t\tset_bit(__JI_COMMIT_RUNNING, &jinode->i_flags);\n\t\tspin_unlock(&journal->j_list_lock);\n\t\terr = filemap_fdatawait(jinode->i_vfs_inode->i_mapping);\n\t\tif (err) {\n\t\t\t/*\n\t\t\t * Because AS_EIO is cleared by\n\t\t\t * filemap_fdatawait_range(), set it again so\n\t\t\t * that user process can get -EIO from fsync().\n\t\t\t */\n\t\t\tset_bit(AS_EIO,\n\t\t\t\t&jinode->i_vfs_inode->i_mapping->flags);\n\n\t\t\tif (!ret)\n\t\t\t\tret = err;\n\t\t}\n\t\tspin_lock(&journal->j_list_lock);\n\t\tclear_bit(__JI_COMMIT_RUNNING, &jinode->i_flags);\n\t\tsmp_mb__after_atomic();\n\t\twake_up_bit(&jinode->i_flags, __JI_COMMIT_RUNNING);\n\t}\n\n\t/* Now refile inode to proper lists */\n\tlist_for_each_entry_safe(jinode, next_i,\n\t\t\t\t &commit_transaction->t_inode_list, i_list) {\n\t\tlist_del(&jinode->i_list);\n\t\tif (jinode->i_next_transaction) {\n\t\t\tjinode->i_transaction = jinode->i_next_transaction;\n\t\t\tjinode->i_next_transaction = NULL;\n\t\t\tlist_add(&jinode->i_list,\n\t\t\t\t&jinode->i_transaction->t_inode_list);\n\t\t} else {\n\t\t\tjinode->i_transaction = NULL;\n\t\t}\n\t}\n\tspin_unlock(&journal->j_list_lock);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cond_resched",
          "args": [],
          "line": 745
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "submit_bh",
          "args": [
            "WRITE_SYNC",
            "bh"
          ],
          "line": 743
        },
        "resolved": true,
        "details": {
          "function_name": "submit_bh",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "3055-3058",
          "snippet": "int submit_bh(int rw, struct buffer_head *bh)\n{\n\treturn _submit_bh(rw, bh, 0);\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nint submit_bh(int rw, struct buffer_head *bh)\n{\n\treturn _submit_bh(rw, bh, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "clear_buffer_dirty",
          "args": [
            "bh"
          ],
          "line": 740
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lock_buffer",
          "args": [
            "bh"
          ],
          "line": 739
        },
        "resolved": true,
        "details": {
          "function_name": "unlock_buffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "70-75",
          "snippet": "void unlock_buffer(struct buffer_head *bh)\n{\n\tclear_bit_unlock(BH_Lock, &bh->b_state);\n\tsmp_mb__after_atomic();\n\twake_up_bit(&bh->b_state, BH_Lock);\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid unlock_buffer(struct buffer_head *bh)\n{\n\tclear_bit_unlock(BH_Lock, &bh->b_state);\n\tsmp_mb__after_atomic();\n\twake_up_bit(&bh->b_state, BH_Lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "jbd2_checksum_data",
          "args": [
            "crc32_sum",
            "bh"
          ],
          "line": 736
        },
        "resolved": true,
        "details": {
          "function_name": "jbd2_checksum_data",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd2/commit.c",
          "lines": "302-314",
          "snippet": "static __u32 jbd2_checksum_data(__u32 crc32_sum, struct buffer_head *bh)\n{\n\tstruct page *page = bh->b_page;\n\tchar *addr;\n\t__u32 checksum;\n\n\taddr = kmap_atomic(page);\n\tchecksum = crc32_be(crc32_sum,\n\t\t(void *)(addr + offset_in_page(bh->b_data)), bh->b_size);\n\tkunmap_atomic(addr);\n\n\treturn checksum;\n}",
          "includes": [
            "#include <trace/events/jbd2.h>",
            "#include <linux/bitops.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/bio.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/crc32.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/jbd2.h>\n#include <linux/bitops.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include <linux/backing-dev.h>\n#include <linux/writeback.h>\n#include <linux/crc32.h>\n#include <linux/jiffies.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n\nstatic __u32 jbd2_checksum_data(__u32 crc32_sum, struct buffer_head *bh)\n{\n\tstruct page *page = bh->b_page;\n\tchar *addr;\n\t__u32 checksum;\n\n\taddr = kmap_atomic(page);\n\tchecksum = crc32_be(crc32_sum,\n\t\t(void *)(addr + offset_in_page(bh->b_data)), bh->b_size);\n\tkunmap_atomic(addr);\n\n\treturn checksum;\n}"
        }
      },
      {
        "call_info": {
          "callee": "JBD2_HAS_COMPAT_FEATURE",
          "args": [
            "journal",
            "JBD2_FEATURE_COMPAT_CHECKSUM"
          ],
          "line": 733
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "jbd2_descr_block_csum_set",
          "args": [
            "journal",
            "descriptor"
          ],
          "line": 726
        },
        "resolved": true,
        "details": {
          "function_name": "jbd2_descr_block_csum_set",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd2/commit.c",
          "lines": "324-338",
          "snippet": "static void jbd2_descr_block_csum_set(journal_t *j,\n\t\t\t\t      struct buffer_head *bh)\n{\n\tstruct jbd2_journal_block_tail *tail;\n\t__u32 csum;\n\n\tif (!jbd2_journal_has_csum_v2or3(j))\n\t\treturn;\n\n\ttail = (struct jbd2_journal_block_tail *)(bh->b_data + j->j_blocksize -\n\t\t\tsizeof(struct jbd2_journal_block_tail));\n\ttail->t_checksum = 0;\n\tcsum = jbd2_chksum(j, j->j_csum_seed, bh->b_data, j->j_blocksize);\n\ttail->t_checksum = cpu_to_be32(csum);\n}",
          "includes": [
            "#include <trace/events/jbd2.h>",
            "#include <linux/bitops.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/bio.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/crc32.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/jbd2.h>\n#include <linux/bitops.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include <linux/backing-dev.h>\n#include <linux/writeback.h>\n#include <linux/crc32.h>\n#include <linux/jiffies.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n\nstatic void jbd2_descr_block_csum_set(journal_t *j,\n\t\t\t\t      struct buffer_head *bh)\n{\n\tstruct jbd2_journal_block_tail *tail;\n\t__u32 csum;\n\n\tif (!jbd2_journal_has_csum_v2or3(j))\n\t\treturn;\n\n\ttail = (struct jbd2_journal_block_tail *)(bh->b_data + j->j_blocksize -\n\t\t\tsizeof(struct jbd2_journal_block_tail));\n\ttail->t_checksum = 0;\n\tcsum = jbd2_chksum(j, j->j_csum_seed, bh->b_data, j->j_blocksize);\n\ttail->t_checksum = cpu_to_be32(csum);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_be16",
          "args": [
            "JBD2_FLAG_LAST_TAG"
          ],
          "line": 724
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "jbd_debug",
          "args": [
            "4",
            "\"JBD2: Submit %d IOs\\n\"",
            "bufs"
          ],
          "line": 718
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "tagp",
            "journal->j_uuid",
            "16"
          ],
          "line": 705
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "jbd2_block_tag_csum_set",
          "args": [
            "journal",
            "tag",
            "wbuf[bufs]",
            "commit_transaction->t_tid"
          ],
          "line": 698
        },
        "resolved": true,
        "details": {
          "function_name": "jbd2_block_tag_csum_set",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd2/commit.c",
          "lines": "340-363",
          "snippet": "static void jbd2_block_tag_csum_set(journal_t *j, journal_block_tag_t *tag,\n\t\t\t\t    struct buffer_head *bh, __u32 sequence)\n{\n\tjournal_block_tag3_t *tag3 = (journal_block_tag3_t *)tag;\n\tstruct page *page = bh->b_page;\n\t__u8 *addr;\n\t__u32 csum32;\n\t__be32 seq;\n\n\tif (!jbd2_journal_has_csum_v2or3(j))\n\t\treturn;\n\n\tseq = cpu_to_be32(sequence);\n\taddr = kmap_atomic(page);\n\tcsum32 = jbd2_chksum(j, j->j_csum_seed, (__u8 *)&seq, sizeof(seq));\n\tcsum32 = jbd2_chksum(j, csum32, addr + offset_in_page(bh->b_data),\n\t\t\t     bh->b_size);\n\tkunmap_atomic(addr);\n\n\tif (JBD2_HAS_INCOMPAT_FEATURE(j, JBD2_FEATURE_INCOMPAT_CSUM_V3))\n\t\ttag3->t_checksum = cpu_to_be32(csum32);\n\telse\n\t\ttag->t_checksum = cpu_to_be16(csum32);\n}",
          "includes": [
            "#include <trace/events/jbd2.h>",
            "#include <linux/bitops.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/bio.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/crc32.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/jbd2.h>\n#include <linux/bitops.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include <linux/backing-dev.h>\n#include <linux/writeback.h>\n#include <linux/crc32.h>\n#include <linux/jiffies.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n\nstatic void jbd2_block_tag_csum_set(journal_t *j, journal_block_tag_t *tag,\n\t\t\t\t    struct buffer_head *bh, __u32 sequence)\n{\n\tjournal_block_tag3_t *tag3 = (journal_block_tag3_t *)tag;\n\tstruct page *page = bh->b_page;\n\t__u8 *addr;\n\t__u32 csum32;\n\t__be32 seq;\n\n\tif (!jbd2_journal_has_csum_v2or3(j))\n\t\treturn;\n\n\tseq = cpu_to_be32(sequence);\n\taddr = kmap_atomic(page);\n\tcsum32 = jbd2_chksum(j, j->j_csum_seed, (__u8 *)&seq, sizeof(seq));\n\tcsum32 = jbd2_chksum(j, csum32, addr + offset_in_page(bh->b_data),\n\t\t\t     bh->b_size);\n\tkunmap_atomic(addr);\n\n\tif (JBD2_HAS_INCOMPAT_FEATURE(j, JBD2_FEATURE_INCOMPAT_CSUM_V3))\n\t\ttag3->t_checksum = cpu_to_be32(csum32);\n\telse\n\t\ttag->t_checksum = cpu_to_be16(csum32);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_be16",
          "args": [
            "tag_flag"
          ],
          "line": 697
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "write_tag_block",
          "args": [
            "journal",
            "tag",
            "jh2bh(jh)->b_blocknr"
          ],
          "line": 696
        },
        "resolved": true,
        "details": {
          "function_name": "write_tag_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd2/commit.c",
          "lines": "316-322",
          "snippet": "static void write_tag_block(journal_t *j, journal_block_tag_t *tag,\n\t\t\t\t   unsigned long long block)\n{\n\ttag->t_blocknr = cpu_to_be32(block & (u32)~0);\n\tif (JBD2_HAS_INCOMPAT_FEATURE(j, JBD2_FEATURE_INCOMPAT_64BIT))\n\t\ttag->t_blocknr_high = cpu_to_be32((block >> 31) >> 1);\n}",
          "includes": [
            "#include <trace/events/jbd2.h>",
            "#include <linux/bitops.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/bio.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/crc32.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/jbd2.h>\n#include <linux/bitops.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include <linux/backing-dev.h>\n#include <linux/writeback.h>\n#include <linux/crc32.h>\n#include <linux/jiffies.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n\nstatic void write_tag_block(journal_t *j, journal_block_tag_t *tag,\n\t\t\t\t   unsigned long long block)\n{\n\ttag->t_blocknr = cpu_to_be32(block & (u32)~0);\n\tif (JBD2_HAS_INCOMPAT_FEATURE(j, JBD2_FEATURE_INCOMPAT_64BIT))\n\t\ttag->t_blocknr_high = cpu_to_be32((block >> 31) >> 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "jh2bh",
          "args": [
            "jh"
          ],
          "line": 696
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "jbd2_file_log_bh",
          "args": [
            "&io_bufs",
            "wbuf[bufs]"
          ],
          "line": 684
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "jbd2_journal_write_metadata_buffer",
          "args": [
            "commit_transaction",
            "jh",
            "&wbuf[bufs]",
            "blocknr"
          ],
          "line": 678
        },
        "resolved": true,
        "details": {
          "function_name": "jbd2_journal_write_metadata_buffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd2/journal.c",
          "lines": "348-492",
          "snippet": "int jbd2_journal_write_metadata_buffer(transaction_t *transaction,\n\t\t\t\t  struct journal_head  *jh_in,\n\t\t\t\t  struct buffer_head **bh_out,\n\t\t\t\t  sector_t blocknr)\n{\n\tint need_copy_out = 0;\n\tint done_copy_out = 0;\n\tint do_escape = 0;\n\tchar *mapped_data;\n\tstruct buffer_head *new_bh;\n\tstruct page *new_page;\n\tunsigned int new_offset;\n\tstruct buffer_head *bh_in = jh2bh(jh_in);\n\tjournal_t *journal = transaction->t_journal;\n\n\t/*\n\t * The buffer really shouldn't be locked: only the current committing\n\t * transaction is allowed to write it, so nobody else is allowed\n\t * to do any IO.\n\t *\n\t * akpm: except if we're journalling data, and write() output is\n\t * also part of a shared mapping, and another thread has\n\t * decided to launch a writepage() against this buffer.\n\t */\n\tJ_ASSERT_BH(bh_in, buffer_jbddirty(bh_in));\n\nretry_alloc:\n\tnew_bh = alloc_buffer_head(GFP_NOFS);\n\tif (!new_bh) {\n\t\t/*\n\t\t * Failure is not an option, but __GFP_NOFAIL is going\n\t\t * away; so we retry ourselves here.\n\t\t */\n\t\tcongestion_wait(BLK_RW_ASYNC, HZ/50);\n\t\tgoto retry_alloc;\n\t}\n\n\t/* keep subsequent assertions sane */\n\tatomic_set(&new_bh->b_count, 1);\n\n\tjbd_lock_bh_state(bh_in);\nrepeat:\n\t/*\n\t * If a new transaction has already done a buffer copy-out, then\n\t * we use that version of the data for the commit.\n\t */\n\tif (jh_in->b_frozen_data) {\n\t\tdone_copy_out = 1;\n\t\tnew_page = virt_to_page(jh_in->b_frozen_data);\n\t\tnew_offset = offset_in_page(jh_in->b_frozen_data);\n\t} else {\n\t\tnew_page = jh2bh(jh_in)->b_page;\n\t\tnew_offset = offset_in_page(jh2bh(jh_in)->b_data);\n\t}\n\n\tmapped_data = kmap_atomic(new_page);\n\t/*\n\t * Fire data frozen trigger if data already wasn't frozen.  Do this\n\t * before checking for escaping, as the trigger may modify the magic\n\t * offset.  If a copy-out happens afterwards, it will have the correct\n\t * data in the buffer.\n\t */\n\tif (!done_copy_out)\n\t\tjbd2_buffer_frozen_trigger(jh_in, mapped_data + new_offset,\n\t\t\t\t\t   jh_in->b_triggers);\n\n\t/*\n\t * Check for escaping\n\t */\n\tif (*((__be32 *)(mapped_data + new_offset)) ==\n\t\t\t\tcpu_to_be32(JBD2_MAGIC_NUMBER)) {\n\t\tneed_copy_out = 1;\n\t\tdo_escape = 1;\n\t}\n\tkunmap_atomic(mapped_data);\n\n\t/*\n\t * Do we need to do a data copy?\n\t */\n\tif (need_copy_out && !done_copy_out) {\n\t\tchar *tmp;\n\n\t\tjbd_unlock_bh_state(bh_in);\n\t\ttmp = jbd2_alloc(bh_in->b_size, GFP_NOFS);\n\t\tif (!tmp) {\n\t\t\tbrelse(new_bh);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\tjbd_lock_bh_state(bh_in);\n\t\tif (jh_in->b_frozen_data) {\n\t\t\tjbd2_free(tmp, bh_in->b_size);\n\t\t\tgoto repeat;\n\t\t}\n\n\t\tjh_in->b_frozen_data = tmp;\n\t\tmapped_data = kmap_atomic(new_page);\n\t\tmemcpy(tmp, mapped_data + new_offset, bh_in->b_size);\n\t\tkunmap_atomic(mapped_data);\n\n\t\tnew_page = virt_to_page(tmp);\n\t\tnew_offset = offset_in_page(tmp);\n\t\tdone_copy_out = 1;\n\n\t\t/*\n\t\t * This isn't strictly necessary, as we're using frozen\n\t\t * data for the escaping, but it keeps consistency with\n\t\t * b_frozen_data usage.\n\t\t */\n\t\tjh_in->b_frozen_triggers = jh_in->b_triggers;\n\t}\n\n\t/*\n\t * Did we need to do an escaping?  Now we've done all the\n\t * copying, we can finally do so.\n\t */\n\tif (do_escape) {\n\t\tmapped_data = kmap_atomic(new_page);\n\t\t*((unsigned int *)(mapped_data + new_offset)) = 0;\n\t\tkunmap_atomic(mapped_data);\n\t}\n\n\tset_bh_page(new_bh, new_page, new_offset);\n\tnew_bh->b_size = bh_in->b_size;\n\tnew_bh->b_bdev = journal->j_dev;\n\tnew_bh->b_blocknr = blocknr;\n\tnew_bh->b_private = bh_in;\n\tset_buffer_mapped(new_bh);\n\tset_buffer_dirty(new_bh);\n\n\t*bh_out = new_bh;\n\n\t/*\n\t * The to-be-written buffer needs to get moved to the io queue,\n\t * and the original buffer whose contents we are shadowing or\n\t * copying is moved to the transaction's shadow queue.\n\t */\n\tJBUFFER_TRACE(jh_in, \"file as BJ_Shadow\");\n\tspin_lock(&journal->j_list_lock);\n\t__jbd2_journal_file_buffer(jh_in, transaction, BJ_Shadow);\n\tspin_unlock(&journal->j_list_lock);\n\tset_buffer_shadow(bh_in);\n\tjbd_unlock_bh_state(bh_in);\n\n\treturn do_escape | (done_copy_out << 1);\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <asm/uaccess.h>",
            "#include <trace/events/jbd2.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/bitops.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/log2.h>",
            "#include <linux/hash.h>",
            "#include <linux/math64.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/poison.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <trace/events/jbd2.h>\n#include <linux/ratelimit.h>\n#include <linux/bitops.h>\n#include <linux/backing-dev.h>\n#include <linux/vmalloc.h>\n#include <linux/log2.h>\n#include <linux/hash.h>\n#include <linux/math64.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/poison.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/freezer.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nint jbd2_journal_write_metadata_buffer(transaction_t *transaction,\n\t\t\t\t  struct journal_head  *jh_in,\n\t\t\t\t  struct buffer_head **bh_out,\n\t\t\t\t  sector_t blocknr)\n{\n\tint need_copy_out = 0;\n\tint done_copy_out = 0;\n\tint do_escape = 0;\n\tchar *mapped_data;\n\tstruct buffer_head *new_bh;\n\tstruct page *new_page;\n\tunsigned int new_offset;\n\tstruct buffer_head *bh_in = jh2bh(jh_in);\n\tjournal_t *journal = transaction->t_journal;\n\n\t/*\n\t * The buffer really shouldn't be locked: only the current committing\n\t * transaction is allowed to write it, so nobody else is allowed\n\t * to do any IO.\n\t *\n\t * akpm: except if we're journalling data, and write() output is\n\t * also part of a shared mapping, and another thread has\n\t * decided to launch a writepage() against this buffer.\n\t */\n\tJ_ASSERT_BH(bh_in, buffer_jbddirty(bh_in));\n\nretry_alloc:\n\tnew_bh = alloc_buffer_head(GFP_NOFS);\n\tif (!new_bh) {\n\t\t/*\n\t\t * Failure is not an option, but __GFP_NOFAIL is going\n\t\t * away; so we retry ourselves here.\n\t\t */\n\t\tcongestion_wait(BLK_RW_ASYNC, HZ/50);\n\t\tgoto retry_alloc;\n\t}\n\n\t/* keep subsequent assertions sane */\n\tatomic_set(&new_bh->b_count, 1);\n\n\tjbd_lock_bh_state(bh_in);\nrepeat:\n\t/*\n\t * If a new transaction has already done a buffer copy-out, then\n\t * we use that version of the data for the commit.\n\t */\n\tif (jh_in->b_frozen_data) {\n\t\tdone_copy_out = 1;\n\t\tnew_page = virt_to_page(jh_in->b_frozen_data);\n\t\tnew_offset = offset_in_page(jh_in->b_frozen_data);\n\t} else {\n\t\tnew_page = jh2bh(jh_in)->b_page;\n\t\tnew_offset = offset_in_page(jh2bh(jh_in)->b_data);\n\t}\n\n\tmapped_data = kmap_atomic(new_page);\n\t/*\n\t * Fire data frozen trigger if data already wasn't frozen.  Do this\n\t * before checking for escaping, as the trigger may modify the magic\n\t * offset.  If a copy-out happens afterwards, it will have the correct\n\t * data in the buffer.\n\t */\n\tif (!done_copy_out)\n\t\tjbd2_buffer_frozen_trigger(jh_in, mapped_data + new_offset,\n\t\t\t\t\t   jh_in->b_triggers);\n\n\t/*\n\t * Check for escaping\n\t */\n\tif (*((__be32 *)(mapped_data + new_offset)) ==\n\t\t\t\tcpu_to_be32(JBD2_MAGIC_NUMBER)) {\n\t\tneed_copy_out = 1;\n\t\tdo_escape = 1;\n\t}\n\tkunmap_atomic(mapped_data);\n\n\t/*\n\t * Do we need to do a data copy?\n\t */\n\tif (need_copy_out && !done_copy_out) {\n\t\tchar *tmp;\n\n\t\tjbd_unlock_bh_state(bh_in);\n\t\ttmp = jbd2_alloc(bh_in->b_size, GFP_NOFS);\n\t\tif (!tmp) {\n\t\t\tbrelse(new_bh);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\tjbd_lock_bh_state(bh_in);\n\t\tif (jh_in->b_frozen_data) {\n\t\t\tjbd2_free(tmp, bh_in->b_size);\n\t\t\tgoto repeat;\n\t\t}\n\n\t\tjh_in->b_frozen_data = tmp;\n\t\tmapped_data = kmap_atomic(new_page);\n\t\tmemcpy(tmp, mapped_data + new_offset, bh_in->b_size);\n\t\tkunmap_atomic(mapped_data);\n\n\t\tnew_page = virt_to_page(tmp);\n\t\tnew_offset = offset_in_page(tmp);\n\t\tdone_copy_out = 1;\n\n\t\t/*\n\t\t * This isn't strictly necessary, as we're using frozen\n\t\t * data for the escaping, but it keeps consistency with\n\t\t * b_frozen_data usage.\n\t\t */\n\t\tjh_in->b_frozen_triggers = jh_in->b_triggers;\n\t}\n\n\t/*\n\t * Did we need to do an escaping?  Now we've done all the\n\t * copying, we can finally do so.\n\t */\n\tif (do_escape) {\n\t\tmapped_data = kmap_atomic(new_page);\n\t\t*((unsigned int *)(mapped_data + new_offset)) = 0;\n\t\tkunmap_atomic(mapped_data);\n\t}\n\n\tset_bh_page(new_bh, new_page, new_offset);\n\tnew_bh->b_size = bh_in->b_size;\n\tnew_bh->b_bdev = journal->j_dev;\n\tnew_bh->b_blocknr = blocknr;\n\tnew_bh->b_private = bh_in;\n\tset_buffer_mapped(new_bh);\n\tset_buffer_dirty(new_bh);\n\n\t*bh_out = new_bh;\n\n\t/*\n\t * The to-be-written buffer needs to get moved to the io queue,\n\t * and the original buffer whose contents we are shadowing or\n\t * copying is moved to the transaction's shadow queue.\n\t */\n\tJBUFFER_TRACE(jh_in, \"file as BJ_Shadow\");\n\tspin_lock(&journal->j_list_lock);\n\t__jbd2_journal_file_buffer(jh_in, transaction, BJ_Shadow);\n\tspin_unlock(&journal->j_list_lock);\n\tset_buffer_shadow(bh_in);\n\tjbd_unlock_bh_state(bh_in);\n\n\treturn do_escape | (done_copy_out << 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "JBUFFER_TRACE",
          "args": [
            "jh",
            "\"ph3: write metadata\""
          ],
          "line": 677
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_bit",
          "args": [
            "BH_JWrite",
            "&jh2bh(jh)->b_state"
          ],
          "line": 676
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_set_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "886-890",
          "snippet": "static inline void ocfs2_set_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_set_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline void ocfs2_set_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_set_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "jh2bh",
          "args": [
            "jh"
          ],
          "line": 676
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_inc",
          "args": [
            "&jh2bh(jh)->b_count"
          ],
          "line": 670
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "jh2bh",
          "args": [
            "jh"
          ],
          "line": 670
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_dec",
          "args": [
            "&commit_transaction->t_outstanding_credits"
          ],
          "line": 665
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "jbd2_journal_next_log_block",
          "args": [
            "journal",
            "&blocknr"
          ],
          "line": 651
        },
        "resolved": true,
        "details": {
          "function_name": "jbd2_journal_next_log_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd2/journal.c",
          "lines": "761-775",
          "snippet": "int jbd2_journal_next_log_block(journal_t *journal, unsigned long long *retp)\n{\n\tunsigned long blocknr;\n\n\twrite_lock(&journal->j_state_lock);\n\tJ_ASSERT(journal->j_free > 1);\n\n\tblocknr = journal->j_head;\n\tjournal->j_head++;\n\tjournal->j_free--;\n\tif (journal->j_head == journal->j_last)\n\t\tjournal->j_head = journal->j_first;\n\twrite_unlock(&journal->j_state_lock);\n\treturn jbd2_journal_bmap(journal, blocknr, retp);\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <asm/uaccess.h>",
            "#include <trace/events/jbd2.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/bitops.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/log2.h>",
            "#include <linux/hash.h>",
            "#include <linux/math64.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/poison.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <trace/events/jbd2.h>\n#include <linux/ratelimit.h>\n#include <linux/bitops.h>\n#include <linux/backing-dev.h>\n#include <linux/vmalloc.h>\n#include <linux/log2.h>\n#include <linux/hash.h>\n#include <linux/math64.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/poison.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/freezer.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nint jbd2_journal_next_log_block(journal_t *journal, unsigned long long *retp)\n{\n\tunsigned long blocknr;\n\n\twrite_lock(&journal->j_state_lock);\n\tJ_ASSERT(journal->j_free > 1);\n\n\tblocknr = journal->j_head;\n\tjournal->j_head++;\n\tjournal->j_free--;\n\tif (journal->j_head == journal->j_last)\n\t\tjournal->j_head = journal->j_first;\n\twrite_unlock(&journal->j_state_lock);\n\treturn jbd2_journal_bmap(journal, blocknr, retp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "jbd2_file_log_bh",
          "args": [
            "&log_bufs",
            "descriptor"
          ],
          "line": 646
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUFFER_TRACE",
          "args": [
            "descriptor",
            "\"ph3: file as descriptor\""
          ],
          "line": 645
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_buffer_dirty",
          "args": [
            "descriptor"
          ],
          "line": 640
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_buffer_jwrite",
          "args": [
            "descriptor"
          ],
          "line": 639
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "commit_transaction->t_tid"
          ],
          "line": 633
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "JBD2_DESCRIPTOR_BLOCK"
          ],
          "line": 632
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "JBD2_MAGIC_NUMBER"
          ],
          "line": 631
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "jbd_debug",
          "args": [
            "4",
            "\"JBD2: got buffer %llu (%p)\\n\"",
            "(unsigned long long)descriptor->b_blocknr",
            "descriptor->b_data"
          ],
          "line": 627
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "jbd2_journal_get_descriptor_buffer",
          "args": [
            "journal"
          ],
          "line": 621
        },
        "resolved": true,
        "details": {
          "function_name": "jbd2_journal_get_descriptor_buffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd2/journal.c",
          "lines": "817-837",
          "snippet": "struct buffer_head *jbd2_journal_get_descriptor_buffer(journal_t *journal)\n{\n\tstruct buffer_head *bh;\n\tunsigned long long blocknr;\n\tint err;\n\n\terr = jbd2_journal_next_log_block(journal, &blocknr);\n\n\tif (err)\n\t\treturn NULL;\n\n\tbh = __getblk(journal->j_dev, blocknr, journal->j_blocksize);\n\tif (!bh)\n\t\treturn NULL;\n\tlock_buffer(bh);\n\tmemset(bh->b_data, 0, journal->j_blocksize);\n\tset_buffer_uptodate(bh);\n\tunlock_buffer(bh);\n\tBUFFER_TRACE(bh, \"return this buffer\");\n\treturn bh;\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <asm/uaccess.h>",
            "#include <trace/events/jbd2.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/bitops.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/log2.h>",
            "#include <linux/hash.h>",
            "#include <linux/math64.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/poison.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <trace/events/jbd2.h>\n#include <linux/ratelimit.h>\n#include <linux/bitops.h>\n#include <linux/backing-dev.h>\n#include <linux/vmalloc.h>\n#include <linux/log2.h>\n#include <linux/hash.h>\n#include <linux/math64.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/poison.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/freezer.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nstruct buffer_head *jbd2_journal_get_descriptor_buffer(journal_t *journal)\n{\n\tstruct buffer_head *bh;\n\tunsigned long long blocknr;\n\tint err;\n\n\terr = jbd2_journal_next_log_block(journal, &blocknr);\n\n\tif (err)\n\t\treturn NULL;\n\n\tbh = __getblk(journal->j_dev, blocknr, journal->j_blocksize);\n\tif (!bh)\n\t\treturn NULL;\n\tlock_buffer(bh);\n\tmemset(bh->b_data, 0, journal->j_blocksize);\n\tset_buffer_uptodate(bh);\n\tunlock_buffer(bh);\n\tBUFFER_TRACE(bh, \"return this buffer\");\n\treturn bh;\n}"
        }
      },
      {
        "call_info": {
          "callee": "jbd_debug",
          "args": [
            "4",
            "\"JBD2: get descriptor\\n\""
          ],
          "line": 619
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "J_ASSERT",
          "args": [
            "bufs == 0"
          ],
          "line": 617
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "jbd2_journal_refile_buffer",
          "args": [
            "journal",
            "jh"
          ],
          "line": 603
        },
        "resolved": true,
        "details": {
          "function_name": "jbd2_journal_refile_buffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd2/transaction.c",
          "lines": "2354-2366",
          "snippet": "void jbd2_journal_refile_buffer(journal_t *journal, struct journal_head *jh)\n{\n\tstruct buffer_head *bh = jh2bh(jh);\n\n\t/* Get reference so that buffer cannot be freed before we unlock it */\n\tget_bh(bh);\n\tjbd_lock_bh_state(bh);\n\tspin_lock(&journal->j_list_lock);\n\t__jbd2_journal_refile_buffer(jh);\n\tjbd_unlock_bh_state(bh);\n\tspin_unlock(&journal->j_list_lock);\n\t__brelse(bh);\n}",
          "includes": [
            "#include <trace/events/jbd2.h>",
            "#include <linux/module.h>",
            "#include <linux/bug.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/timer.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __jbd2_journal_temp_unlink_buffer(struct journal_head *jh);",
            "static void __jbd2_journal_unfile_buffer(struct journal_head *jh);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/jbd2.h>\n#include <linux/module.h>\n#include <linux/bug.h>\n#include <linux/backing-dev.h>\n#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/timer.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n\nstatic void __jbd2_journal_temp_unlink_buffer(struct journal_head *jh);\nstatic void __jbd2_journal_unfile_buffer(struct journal_head *jh);\n\nvoid jbd2_journal_refile_buffer(journal_t *journal, struct journal_head *jh)\n{\n\tstruct buffer_head *bh = jh2bh(jh);\n\n\t/* Get reference so that buffer cannot be freed before we unlock it */\n\tget_bh(bh);\n\tjbd_lock_bh_state(bh);\n\tspin_lock(&journal->j_list_lock);\n\t__jbd2_journal_refile_buffer(jh);\n\tjbd_unlock_bh_state(bh);\n\tspin_unlock(&journal->j_list_lock);\n\t__brelse(bh);\n}"
        }
      },
      {
        "call_info": {
          "callee": "jbd2_buffer_abort_trigger",
          "args": [
            "jh",
            "jh->b_frozen_data ?\n\t\t\t\t\t\t  jh->b_frozen_triggers :\n\t\t\t\t\t\t  jh->b_triggers"
          ],
          "line": 599
        },
        "resolved": true,
        "details": {
          "function_name": "jbd2_buffer_abort_trigger",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd2/transaction.c",
          "lines": "1228-1235",
          "snippet": "void jbd2_buffer_abort_trigger(struct journal_head *jh,\n\t\t\t       struct jbd2_buffer_trigger_type *triggers)\n{\n\tif (!triggers || !triggers->t_abort)\n\t\treturn;\n\n\ttriggers->t_abort(triggers, jh2bh(jh));\n}",
          "includes": [
            "#include <trace/events/jbd2.h>",
            "#include <linux/module.h>",
            "#include <linux/bug.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/timer.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __jbd2_journal_temp_unlink_buffer(struct journal_head *jh);",
            "static void __jbd2_journal_unfile_buffer(struct journal_head *jh);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/jbd2.h>\n#include <linux/module.h>\n#include <linux/bug.h>\n#include <linux/backing-dev.h>\n#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/timer.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n\nstatic void __jbd2_journal_temp_unlink_buffer(struct journal_head *jh);\nstatic void __jbd2_journal_unfile_buffer(struct journal_head *jh);\n\nvoid jbd2_buffer_abort_trigger(struct journal_head *jh,\n\t\t\t       struct jbd2_buffer_trigger_type *triggers)\n{\n\tif (!triggers || !triggers->t_abort)\n\t\treturn;\n\n\ttriggers->t_abort(triggers, jh2bh(jh));\n}"
        }
      },
      {
        "call_info": {
          "callee": "JBUFFER_TRACE",
          "args": [
            "jh",
            "\"journal is aborting: refile\""
          ],
          "line": 598
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clear_buffer_jbddirty",
          "args": [
            "jh2bh(jh)"
          ],
          "line": 597
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "jh2bh",
          "args": [
            "jh"
          ],
          "line": 597
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "J_ASSERT",
          "args": [
            "commit_transaction->t_nr_buffers <=\n\t\t atomic_read(&commit_transaction->t_outstanding_credits)"
          ],
          "line": 581
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&commit_transaction->t_outstanding_credits"
          ],
          "line": 582
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&commit_transaction->t_outstanding_credits"
          ],
          "line": 578
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "jbd2_time_diff",
          "args": [
            "stats.run.rs_flushing",
            "stats.run.rs_logging"
          ],
          "line": 575
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_jbd2_commit_logging",
          "args": [
            "journal",
            "commit_transaction"
          ],
          "line": 573
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "jbd_debug",
          "args": [
            "3",
            "\"JBD2: commit phase 2b\\n\""
          ],
          "line": 562
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "jbd2_journal_write_revoke_records",
          "args": [
            "journal",
            "commit_transaction",
            "&log_bufs",
            "WRITE_SYNC"
          ],
          "line": 559
        },
        "resolved": true,
        "details": {
          "function_name": "jbd2_journal_write_revoke_records",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd2/revoke.c",
          "lines": "527-563",
          "snippet": "void jbd2_journal_write_revoke_records(journal_t *journal,\n\t\t\t\t       transaction_t *transaction,\n\t\t\t\t       struct list_head *log_bufs,\n\t\t\t\t       int write_op)\n{\n\tstruct buffer_head *descriptor;\n\tstruct jbd2_revoke_record_s *record;\n\tstruct jbd2_revoke_table_s *revoke;\n\tstruct list_head *hash_list;\n\tint i, offset, count;\n\n\tdescriptor = NULL;\n\toffset = 0;\n\tcount = 0;\n\n\t/* select revoke table for committing transaction */\n\trevoke = journal->j_revoke == journal->j_revoke_table[0] ?\n\t\tjournal->j_revoke_table[1] : journal->j_revoke_table[0];\n\n\tfor (i = 0; i < revoke->hash_size; i++) {\n\t\thash_list = &revoke->hash_table[i];\n\n\t\twhile (!list_empty(hash_list)) {\n\t\t\trecord = (struct jbd2_revoke_record_s *)\n\t\t\t\thash_list->next;\n\t\t\twrite_one_revoke_record(journal, transaction, log_bufs,\n\t\t\t\t\t\t&descriptor, &offset,\n\t\t\t\t\t\trecord, write_op);\n\t\t\tcount++;\n\t\t\tlist_del(&record->hash);\n\t\t\tkmem_cache_free(jbd2_revoke_record_cache, record);\n\t\t}\n\t}\n\tif (descriptor)\n\t\tflush_descriptor(journal, descriptor, offset, write_op);\n\tjbd_debug(1, \"Wrote %d revoke records\\n\", count);\n}",
          "includes": [
            "#include <linux/hash.h>",
            "#include <linux/log2.h>",
            "#include <linux/bio.h>",
            "#include <linux/init.h>",
            "#include <linux/list.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include \"jfs_user.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *jbd2_revoke_record_cache;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/hash.h>\n#include <linux/log2.h>\n#include <linux/bio.h>\n#include <linux/init.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include \"jfs_user.h\"\n\nstatic struct kmem_cache *jbd2_revoke_record_cache;\n\nvoid jbd2_journal_write_revoke_records(journal_t *journal,\n\t\t\t\t       transaction_t *transaction,\n\t\t\t\t       struct list_head *log_bufs,\n\t\t\t\t       int write_op)\n{\n\tstruct buffer_head *descriptor;\n\tstruct jbd2_revoke_record_s *record;\n\tstruct jbd2_revoke_table_s *revoke;\n\tstruct list_head *hash_list;\n\tint i, offset, count;\n\n\tdescriptor = NULL;\n\toffset = 0;\n\tcount = 0;\n\n\t/* select revoke table for committing transaction */\n\trevoke = journal->j_revoke == journal->j_revoke_table[0] ?\n\t\tjournal->j_revoke_table[1] : journal->j_revoke_table[0];\n\n\tfor (i = 0; i < revoke->hash_size; i++) {\n\t\thash_list = &revoke->hash_table[i];\n\n\t\twhile (!list_empty(hash_list)) {\n\t\t\trecord = (struct jbd2_revoke_record_s *)\n\t\t\t\thash_list->next;\n\t\t\twrite_one_revoke_record(journal, transaction, log_bufs,\n\t\t\t\t\t\t&descriptor, &offset,\n\t\t\t\t\t\trecord, write_op);\n\t\t\tcount++;\n\t\t\tlist_del(&record->hash);\n\t\t\tkmem_cache_free(jbd2_revoke_record_cache, record);\n\t\t}\n\t}\n\tif (descriptor)\n\t\tflush_descriptor(journal, descriptor, offset, write_op);\n\tjbd_debug(1, \"Wrote %d revoke records\\n\", count);\n}"
        }
      },
      {
        "call_info": {
          "callee": "blk_start_plug",
          "args": [
            "&plug"
          ],
          "line": 558
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "journal_submit_data_buffers",
          "args": [
            "journal",
            "commit_transaction"
          ],
          "line": 554
        },
        "resolved": true,
        "details": {
          "function_name": "journal_submit_data_buffers",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd2/commit.c",
          "lines": "217-247",
          "snippet": "static int journal_submit_data_buffers(journal_t *journal,\n\t\ttransaction_t *commit_transaction)\n{\n\tstruct jbd2_inode *jinode;\n\tint err, ret = 0;\n\tstruct address_space *mapping;\n\n\tspin_lock(&journal->j_list_lock);\n\tlist_for_each_entry(jinode, &commit_transaction->t_inode_list, i_list) {\n\t\tmapping = jinode->i_vfs_inode->i_mapping;\n\t\tset_bit(__JI_COMMIT_RUNNING, &jinode->i_flags);\n\t\tspin_unlock(&journal->j_list_lock);\n\t\t/*\n\t\t * submit the inode data buffers. We use writepage\n\t\t * instead of writepages. Because writepages can do\n\t\t * block allocation  with delalloc. We need to write\n\t\t * only allocated blocks here.\n\t\t */\n\t\ttrace_jbd2_submit_inode_data(jinode->i_vfs_inode);\n\t\terr = journal_submit_inode_data_buffers(mapping);\n\t\tif (!ret)\n\t\t\tret = err;\n\t\tspin_lock(&journal->j_list_lock);\n\t\tJ_ASSERT(jinode->i_transaction == commit_transaction);\n\t\tclear_bit(__JI_COMMIT_RUNNING, &jinode->i_flags);\n\t\tsmp_mb__after_atomic();\n\t\twake_up_bit(&jinode->i_flags, __JI_COMMIT_RUNNING);\n\t}\n\tspin_unlock(&journal->j_list_lock);\n\treturn ret;\n}",
          "includes": [
            "#include <trace/events/jbd2.h>",
            "#include <linux/bitops.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/bio.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/crc32.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/jbd2.h>\n#include <linux/bitops.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include <linux/backing-dev.h>\n#include <linux/writeback.h>\n#include <linux/crc32.h>\n#include <linux/jiffies.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n\nstatic int journal_submit_data_buffers(journal_t *journal,\n\t\ttransaction_t *commit_transaction)\n{\n\tstruct jbd2_inode *jinode;\n\tint err, ret = 0;\n\tstruct address_space *mapping;\n\n\tspin_lock(&journal->j_list_lock);\n\tlist_for_each_entry(jinode, &commit_transaction->t_inode_list, i_list) {\n\t\tmapping = jinode->i_vfs_inode->i_mapping;\n\t\tset_bit(__JI_COMMIT_RUNNING, &jinode->i_flags);\n\t\tspin_unlock(&journal->j_list_lock);\n\t\t/*\n\t\t * submit the inode data buffers. We use writepage\n\t\t * instead of writepages. Because writepages can do\n\t\t * block allocation  with delalloc. We need to write\n\t\t * only allocated blocks here.\n\t\t */\n\t\ttrace_jbd2_submit_inode_data(jinode->i_vfs_inode);\n\t\terr = journal_submit_inode_data_buffers(mapping);\n\t\tif (!ret)\n\t\t\tret = err;\n\t\tspin_lock(&journal->j_list_lock);\n\t\tJ_ASSERT(jinode->i_transaction == commit_transaction);\n\t\tclear_bit(__JI_COMMIT_RUNNING, &jinode->i_flags);\n\t\tsmp_mb__after_atomic();\n\t\twake_up_bit(&jinode->i_flags, __JI_COMMIT_RUNNING);\n\t}\n\tspin_unlock(&journal->j_list_lock);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "jbd_debug",
          "args": [
            "3",
            "\"JBD2: commit phase 2a\\n\""
          ],
          "line": 548
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ktime_get",
          "args": [],
          "line": 543
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "jbd2_time_diff",
          "args": [
            "stats.run.rs_locked",
            "stats.run.rs_flushing"
          ],
          "line": 537
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_jbd2_commit_flushing",
          "args": [
            "journal",
            "commit_transaction"
          ],
          "line": 535
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_sub",
          "args": [
            "atomic_read(&journal->j_reserved_credits)",
            "&commit_transaction->t_outstanding_credits"
          ],
          "line": 532
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&journal->j_reserved_credits"
          ],
          "line": 532
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "jbd2_journal_switch_revoke_table",
          "args": [
            "journal"
          ],
          "line": 527
        },
        "resolved": true,
        "details": {
          "function_name": "jbd2_journal_switch_revoke_table",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd2/revoke.c",
          "lines": "510-521",
          "snippet": "void jbd2_journal_switch_revoke_table(journal_t *journal)\n{\n\tint i;\n\n\tif (journal->j_revoke == journal->j_revoke_table[0])\n\t\tjournal->j_revoke = journal->j_revoke_table[1];\n\telse\n\t\tjournal->j_revoke = journal->j_revoke_table[0];\n\n\tfor (i = 0; i < journal->j_revoke->hash_size; i++)\n\t\tINIT_LIST_HEAD(&journal->j_revoke->hash_table[i]);\n}",
          "includes": [
            "#include <linux/hash.h>",
            "#include <linux/log2.h>",
            "#include <linux/bio.h>",
            "#include <linux/init.h>",
            "#include <linux/list.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include \"jfs_user.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/hash.h>\n#include <linux/log2.h>\n#include <linux/bio.h>\n#include <linux/init.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include \"jfs_user.h\"\n\nvoid jbd2_journal_switch_revoke_table(journal_t *journal)\n{\n\tint i;\n\n\tif (journal->j_revoke == journal->j_revoke_table[0])\n\t\tjournal->j_revoke = journal->j_revoke_table[1];\n\telse\n\t\tjournal->j_revoke = journal->j_revoke_table[0];\n\n\tfor (i = 0; i < journal->j_revoke->hash_size; i++)\n\t\tINIT_LIST_HEAD(&journal->j_revoke->hash_table[i]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "jbd2_clear_buffer_revoked_flags",
          "args": [
            "journal"
          ],
          "line": 522
        },
        "resolved": true,
        "details": {
          "function_name": "jbd2_clear_buffer_revoked_flags",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd2/revoke.c",
          "lines": "481-504",
          "snippet": "void jbd2_clear_buffer_revoked_flags(journal_t *journal)\n{\n\tstruct jbd2_revoke_table_s *revoke = journal->j_revoke;\n\tint i = 0;\n\n\tfor (i = 0; i < revoke->hash_size; i++) {\n\t\tstruct list_head *hash_list;\n\t\tstruct list_head *list_entry;\n\t\thash_list = &revoke->hash_table[i];\n\n\t\tlist_for_each(list_entry, hash_list) {\n\t\t\tstruct jbd2_revoke_record_s *record;\n\t\t\tstruct buffer_head *bh;\n\t\t\trecord = (struct jbd2_revoke_record_s *)list_entry;\n\t\t\tbh = __find_get_block(journal->j_fs_dev,\n\t\t\t\t\t      record->blocknr,\n\t\t\t\t\t      journal->j_blocksize);\n\t\t\tif (bh) {\n\t\t\t\tclear_buffer_revoked(bh);\n\t\t\t\t__brelse(bh);\n\t\t\t}\n\t\t}\n\t}\n}",
          "includes": [
            "#include <linux/hash.h>",
            "#include <linux/log2.h>",
            "#include <linux/bio.h>",
            "#include <linux/init.h>",
            "#include <linux/list.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include \"jfs_user.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/hash.h>\n#include <linux/log2.h>\n#include <linux/bio.h>\n#include <linux/init.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include \"jfs_user.h\"\n\nvoid jbd2_clear_buffer_revoked_flags(journal_t *journal)\n{\n\tstruct jbd2_revoke_table_s *revoke = journal->j_revoke;\n\tint i = 0;\n\n\tfor (i = 0; i < revoke->hash_size; i++) {\n\t\tstruct list_head *hash_list;\n\t\tstruct list_head *list_entry;\n\t\thash_list = &revoke->hash_table[i];\n\n\t\tlist_for_each(list_entry, hash_list) {\n\t\t\tstruct jbd2_revoke_record_s *record;\n\t\t\tstruct buffer_head *bh;\n\t\t\trecord = (struct jbd2_revoke_record_s *)list_entry;\n\t\t\tbh = __find_get_block(journal->j_fs_dev,\n\t\t\t\t\t      record->blocknr,\n\t\t\t\t\t      journal->j_blocksize);\n\t\t\tif (bh) {\n\t\t\t\tclear_buffer_revoked(bh);\n\t\t\t\t__brelse(bh);\n\t\t\t}\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "jbd_debug",
          "args": [
            "3",
            "\"JBD2: commit phase 1\\n\""
          ],
          "line": 516
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__jbd2_journal_clean_checkpoint_list",
          "args": [
            "journal"
          ],
          "line": 513
        },
        "resolved": true,
        "details": {
          "function_name": "__jbd2_journal_clean_checkpoint_list",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd2/checkpoint.c",
          "lines": "466-507",
          "snippet": "void __jbd2_journal_clean_checkpoint_list(journal_t *journal)\n{\n\ttransaction_t *transaction, *last_transaction, *next_transaction;\n\tint ret;\n\n\ttransaction = journal->j_checkpoint_transactions;\n\tif (!transaction)\n\t\treturn;\n\n\tlast_transaction = transaction->t_cpprev;\n\tnext_transaction = transaction;\n\tdo {\n\t\ttransaction = next_transaction;\n\t\tnext_transaction = transaction->t_cpnext;\n\t\tret = journal_clean_one_cp_list(transaction->t_checkpoint_list);\n\t\t/*\n\t\t * This function only frees up some memory if possible so we\n\t\t * dont have an obligation to finish processing. Bail out if\n\t\t * preemption requested:\n\t\t */\n\t\tif (need_resched())\n\t\t\treturn;\n\t\tif (ret)\n\t\t\tcontinue;\n\t\t/*\n\t\t * It is essential that we are as careful as in the case of\n\t\t * t_checkpoint_list with removing the buffer from the list as\n\t\t * we can possibly see not yet submitted buffers on io_list\n\t\t */\n\t\tret = journal_clean_one_cp_list(transaction->\n\t\t\t\tt_checkpoint_io_list);\n\t\tif (need_resched())\n\t\t\treturn;\n\t\t/*\n\t\t * Stop scanning if we couldn't free the transaction. This\n\t\t * avoids pointless scanning of transactions which still\n\t\t * weren't checkpointed.\n\t\t */\n\t\tif (!ret)\n\t\t\treturn;\n\t} while (transaction != last_transaction);\n}",
          "includes": [
            "#include <trace/events/jbd2.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/jbd2.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n\nvoid __jbd2_journal_clean_checkpoint_list(journal_t *journal)\n{\n\ttransaction_t *transaction, *last_transaction, *next_transaction;\n\tint ret;\n\n\ttransaction = journal->j_checkpoint_transactions;\n\tif (!transaction)\n\t\treturn;\n\n\tlast_transaction = transaction->t_cpprev;\n\tnext_transaction = transaction;\n\tdo {\n\t\ttransaction = next_transaction;\n\t\tnext_transaction = transaction->t_cpnext;\n\t\tret = journal_clean_one_cp_list(transaction->t_checkpoint_list);\n\t\t/*\n\t\t * This function only frees up some memory if possible so we\n\t\t * dont have an obligation to finish processing. Bail out if\n\t\t * preemption requested:\n\t\t */\n\t\tif (need_resched())\n\t\t\treturn;\n\t\tif (ret)\n\t\t\tcontinue;\n\t\t/*\n\t\t * It is essential that we are as careful as in the case of\n\t\t * t_checkpoint_list with removing the buffer from the list as\n\t\t * we can possibly see not yet submitted buffers on io_list\n\t\t */\n\t\tret = journal_clean_one_cp_list(transaction->\n\t\t\t\tt_checkpoint_io_list);\n\t\tif (need_resched())\n\t\t\treturn;\n\t\t/*\n\t\t * Stop scanning if we couldn't free the transaction. This\n\t\t * avoids pointless scanning of transactions which still\n\t\t * weren't checkpointed.\n\t\t */\n\t\tif (!ret)\n\t\t\treturn;\n\t} while (transaction != last_transaction);\n}"
        }
      },
      {
        "call_info": {
          "callee": "jbd_unlock_bh_state",
          "args": [
            "bh"
          ],
          "line": 502
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "jbd_lock_bh_state",
          "args": [
            "bh"
          ],
          "line": 499
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "jh2bh",
          "args": [
            "jh"
          ],
          "line": 497
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "JBUFFER_TRACE",
          "args": [
            "jh",
            "\"reserved, unused: refile\""
          ],
          "line": 491
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "J_ASSERT",
          "args": [
            "atomic_read(&commit_transaction->t_outstanding_credits) <=\n\t\t\tjournal->j_max_transaction_buffers"
          ],
          "line": 470
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&commit_transaction->t_outstanding_credits"
          ],
          "line": 470
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "finish_wait",
          "args": [
            "&journal->j_wait_updates",
            "&wait"
          ],
          "line": 466
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "schedule",
          "args": [],
          "line": 462
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&commit_transaction->t_updates"
          ],
          "line": 459
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "prepare_to_wait",
          "args": [
            "&journal->j_wait_updates",
            "&wait",
            "TASK_UNINTERRUPTIBLE"
          ],
          "line": 457
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DEFINE_WAIT",
          "args": [
            "wait"
          ],
          "line": 455
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&commit_transaction->t_updates"
          ],
          "line": 454
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "jbd2_time_diff",
          "args": [
            "commit_transaction->t_start",
            "stats.run.rs_locked"
          ],
          "line": 450
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "jbd2_time_diff",
          "args": [
            "commit_transaction->t_requested",
            "stats.run.rs_locked"
          ],
          "line": 448
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_jbd2_commit_locking",
          "args": [
            "journal",
            "commit_transaction"
          ],
          "line": 442
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "J_ASSERT",
          "args": [
            "commit_transaction->t_state == T_RUNNING"
          ],
          "line": 439
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "jbd_debug",
          "args": [
            "1",
            "\"JBD2: starting commit of transaction %d\\n\"",
            "commit_transaction->t_tid"
          ],
          "line": 435
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_jbd2_start_commit",
          "args": [
            "journal",
            "commit_transaction"
          ],
          "line": 434
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "J_ASSERT",
          "args": [
            "journal->j_committing_transaction == NULL"
          ],
          "line": 430
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "J_ASSERT",
          "args": [
            "journal->j_running_transaction != NULL"
          ],
          "line": 429
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "jbd_debug",
          "args": [
            "3",
            "\"superblock not updated\\n\""
          ],
          "line": 426
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&journal->j_checkpoint_mutex"
          ],
          "line": 424
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "jbd2_journal_update_sb_log_tail",
          "args": [
            "journal",
            "journal->j_tail_sequence",
            "journal->j_tail",
            "WRITE_SYNC"
          ],
          "line": 420
        },
        "resolved": true,
        "details": {
          "function_name": "jbd2_journal_update_sb_log_tail",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd2/journal.c",
          "lines": "1386-1405",
          "snippet": "void jbd2_journal_update_sb_log_tail(journal_t *journal, tid_t tail_tid,\n\t\t\t\t     unsigned long tail_block, int write_op)\n{\n\tjournal_superblock_t *sb = journal->j_superblock;\n\n\tBUG_ON(!mutex_is_locked(&journal->j_checkpoint_mutex));\n\tjbd_debug(1, \"JBD2: updating superblock (start %lu, seq %u)\\n\",\n\t\t  tail_block, tail_tid);\n\n\tsb->s_sequence = cpu_to_be32(tail_tid);\n\tsb->s_start    = cpu_to_be32(tail_block);\n\n\tjbd2_write_superblock(journal, write_op);\n\n\t/* Log is no longer empty */\n\twrite_lock(&journal->j_state_lock);\n\tWARN_ON(!sb->s_sequence);\n\tjournal->j_flags &= ~JBD2_FLUSHED;\n\twrite_unlock(&journal->j_state_lock);\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <asm/uaccess.h>",
            "#include <trace/events/jbd2.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/bitops.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/log2.h>",
            "#include <linux/hash.h>",
            "#include <linux/math64.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/poison.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <trace/events/jbd2.h>\n#include <linux/ratelimit.h>\n#include <linux/bitops.h>\n#include <linux/backing-dev.h>\n#include <linux/vmalloc.h>\n#include <linux/log2.h>\n#include <linux/hash.h>\n#include <linux/math64.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/poison.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/freezer.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nvoid jbd2_journal_update_sb_log_tail(journal_t *journal, tid_t tail_tid,\n\t\t\t\t     unsigned long tail_block, int write_op)\n{\n\tjournal_superblock_t *sb = journal->j_superblock;\n\n\tBUG_ON(!mutex_is_locked(&journal->j_checkpoint_mutex));\n\tjbd_debug(1, \"JBD2: updating superblock (start %lu, seq %u)\\n\",\n\t\t  tail_block, tail_tid);\n\n\tsb->s_sequence = cpu_to_be32(tail_tid);\n\tsb->s_start    = cpu_to_be32(tail_block);\n\n\tjbd2_write_superblock(journal, write_op);\n\n\t/* Log is no longer empty */\n\twrite_lock(&journal->j_state_lock);\n\tWARN_ON(!sb->s_sequence);\n\tjournal->j_flags &= ~JBD2_FLUSHED;\n\twrite_unlock(&journal->j_state_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&journal->j_checkpoint_mutex"
          ],
          "line": 413
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "jbd_debug",
          "args": [
            "3",
            "\"super block updated\\n\""
          ],
          "line": 412
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "jbd2_journal_has_csum_v2or3",
          "args": [
            "journal"
          ],
          "line": 402
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LIST_HEAD",
          "args": [
            "log_bufs"
          ],
          "line": 400
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LIST_HEAD",
          "args": [
            "io_bufs"
          ],
          "line": 399
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "journal_tag_bytes",
          "args": [
            "journal"
          ],
          "line": 390
        },
        "resolved": true,
        "details": {
          "function_name": "journal_tag_bytes",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd2/journal.c",
          "lines": "2178-2194",
          "snippet": "size_t journal_tag_bytes(journal_t *journal)\n{\n\tsize_t sz;\n\n\tif (JBD2_HAS_INCOMPAT_FEATURE(journal, JBD2_FEATURE_INCOMPAT_CSUM_V3))\n\t\treturn sizeof(journal_block_tag3_t);\n\n\tsz = sizeof(journal_block_tag_t);\n\n\tif (JBD2_HAS_INCOMPAT_FEATURE(journal, JBD2_FEATURE_INCOMPAT_CSUM_V2))\n\t\tsz += sizeof(__u16);\n\n\tif (JBD2_HAS_INCOMPAT_FEATURE(journal, JBD2_FEATURE_INCOMPAT_64BIT))\n\t\treturn sz;\n\telse\n\t\treturn sz - sizeof(__u32);\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <asm/uaccess.h>",
            "#include <trace/events/jbd2.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/bitops.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/log2.h>",
            "#include <linux/hash.h>",
            "#include <linux/math64.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/poison.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <trace/events/jbd2.h>\n#include <linux/ratelimit.h>\n#include <linux/bitops.h>\n#include <linux/backing-dev.h>\n#include <linux/vmalloc.h>\n#include <linux/log2.h>\n#include <linux/hash.h>\n#include <linux/math64.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/poison.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/freezer.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nsize_t journal_tag_bytes(journal_t *journal)\n{\n\tsize_t sz;\n\n\tif (JBD2_HAS_INCOMPAT_FEATURE(journal, JBD2_FEATURE_INCOMPAT_CSUM_V3))\n\t\treturn sizeof(journal_block_tag3_t);\n\n\tsz = sizeof(journal_block_tag_t);\n\n\tif (JBD2_HAS_INCOMPAT_FEATURE(journal, JBD2_FEATURE_INCOMPAT_CSUM_V2))\n\t\tsz += sizeof(__u16);\n\n\tif (JBD2_HAS_INCOMPAT_FEATURE(journal, JBD2_FEATURE_INCOMPAT_64BIT))\n\t\treturn sz;\n\telse\n\t\treturn sz - sizeof(__u32);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/jbd2.h>\n#include <linux/bitops.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include <linux/backing-dev.h>\n#include <linux/writeback.h>\n#include <linux/crc32.h>\n#include <linux/jiffies.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n\nvoid jbd2_journal_commit_transaction(journal_t *journal)\n{\n\tstruct transaction_stats_s stats;\n\ttransaction_t *commit_transaction;\n\tstruct journal_head *jh;\n\tstruct buffer_head *descriptor;\n\tstruct buffer_head **wbuf = journal->j_wbuf;\n\tint bufs;\n\tint flags;\n\tint err;\n\tunsigned long long blocknr;\n\tktime_t start_time;\n\tu64 commit_time;\n\tchar *tagp = NULL;\n\tjournal_header_t *header;\n\tjournal_block_tag_t *tag = NULL;\n\tint space_left = 0;\n\tint first_tag = 0;\n\tint tag_flag;\n\tint i;\n\tint tag_bytes = journal_tag_bytes(journal);\n\tstruct buffer_head *cbh = NULL; /* For transactional checksums */\n\t__u32 crc32_sum = ~0;\n\tstruct blk_plug plug;\n\t/* Tail of the journal */\n\tunsigned long first_block;\n\ttid_t first_tid;\n\tint update_tail;\n\tint csum_size = 0;\n\tLIST_HEAD(io_bufs);\n\tLIST_HEAD(log_bufs);\n\n\tif (jbd2_journal_has_csum_v2or3(journal))\n\t\tcsum_size = sizeof(struct jbd2_journal_block_tail);\n\n\t/*\n\t * First job: lock down the current transaction and wait for\n\t * all outstanding updates to complete.\n\t */\n\n\t/* Do we need to erase the effects of a prior jbd2_journal_flush? */\n\tif (journal->j_flags & JBD2_FLUSHED) {\n\t\tjbd_debug(3, \"super block updated\\n\");\n\t\tmutex_lock(&journal->j_checkpoint_mutex);\n\t\t/*\n\t\t * We hold j_checkpoint_mutex so tail cannot change under us.\n\t\t * We don't need any special data guarantees for writing sb\n\t\t * since journal is empty and it is ok for write to be\n\t\t * flushed only with transaction commit.\n\t\t */\n\t\tjbd2_journal_update_sb_log_tail(journal,\n\t\t\t\t\t\tjournal->j_tail_sequence,\n\t\t\t\t\t\tjournal->j_tail,\n\t\t\t\t\t\tWRITE_SYNC);\n\t\tmutex_unlock(&journal->j_checkpoint_mutex);\n\t} else {\n\t\tjbd_debug(3, \"superblock not updated\\n\");\n\t}\n\n\tJ_ASSERT(journal->j_running_transaction != NULL);\n\tJ_ASSERT(journal->j_committing_transaction == NULL);\n\n\tcommit_transaction = journal->j_running_transaction;\n\n\ttrace_jbd2_start_commit(journal, commit_transaction);\n\tjbd_debug(1, \"JBD2: starting commit of transaction %d\\n\",\n\t\t\tcommit_transaction->t_tid);\n\n\twrite_lock(&journal->j_state_lock);\n\tJ_ASSERT(commit_transaction->t_state == T_RUNNING);\n\tcommit_transaction->t_state = T_LOCKED;\n\n\ttrace_jbd2_commit_locking(journal, commit_transaction);\n\tstats.run.rs_wait = commit_transaction->t_max_wait;\n\tstats.run.rs_request_delay = 0;\n\tstats.run.rs_locked = jiffies;\n\tif (commit_transaction->t_requested)\n\t\tstats.run.rs_request_delay =\n\t\t\tjbd2_time_diff(commit_transaction->t_requested,\n\t\t\t\t       stats.run.rs_locked);\n\tstats.run.rs_running = jbd2_time_diff(commit_transaction->t_start,\n\t\t\t\t\t      stats.run.rs_locked);\n\n\tspin_lock(&commit_transaction->t_handle_lock);\n\twhile (atomic_read(&commit_transaction->t_updates)) {\n\t\tDEFINE_WAIT(wait);\n\n\t\tprepare_to_wait(&journal->j_wait_updates, &wait,\n\t\t\t\t\tTASK_UNINTERRUPTIBLE);\n\t\tif (atomic_read(&commit_transaction->t_updates)) {\n\t\t\tspin_unlock(&commit_transaction->t_handle_lock);\n\t\t\twrite_unlock(&journal->j_state_lock);\n\t\t\tschedule();\n\t\t\twrite_lock(&journal->j_state_lock);\n\t\t\tspin_lock(&commit_transaction->t_handle_lock);\n\t\t}\n\t\tfinish_wait(&journal->j_wait_updates, &wait);\n\t}\n\tspin_unlock(&commit_transaction->t_handle_lock);\n\n\tJ_ASSERT (atomic_read(&commit_transaction->t_outstanding_credits) <=\n\t\t\tjournal->j_max_transaction_buffers);\n\n\t/*\n\t * First thing we are allowed to do is to discard any remaining\n\t * BJ_Reserved buffers.  Note, it is _not_ permissible to assume\n\t * that there are no such buffers: if a large filesystem\n\t * operation like a truncate needs to split itself over multiple\n\t * transactions, then it may try to do a jbd2_journal_restart() while\n\t * there are still BJ_Reserved buffers outstanding.  These must\n\t * be released cleanly from the current transaction.\n\t *\n\t * In this case, the filesystem must still reserve write access\n\t * again before modifying the buffer in the new transaction, but\n\t * we do not require it to remember exactly which old buffers it\n\t * has reserved.  This is consistent with the existing behaviour\n\t * that multiple jbd2_journal_get_write_access() calls to the same\n\t * buffer are perfectly permissible.\n\t */\n\twhile (commit_transaction->t_reserved_list) {\n\t\tjh = commit_transaction->t_reserved_list;\n\t\tJBUFFER_TRACE(jh, \"reserved, unused: refile\");\n\t\t/*\n\t\t * A jbd2_journal_get_undo_access()+jbd2_journal_release_buffer() may\n\t\t * leave undo-committed data.\n\t\t */\n\t\tif (jh->b_committed_data) {\n\t\t\tstruct buffer_head *bh = jh2bh(jh);\n\n\t\t\tjbd_lock_bh_state(bh);\n\t\t\tjbd2_free(jh->b_committed_data, bh->b_size);\n\t\t\tjh->b_committed_data = NULL;\n\t\t\tjbd_unlock_bh_state(bh);\n\t\t}\n\t\tjbd2_journal_refile_buffer(journal, jh);\n\t}\n\n\t/*\n\t * Now try to drop any written-back buffers from the journal's\n\t * checkpoint lists.  We do this *before* commit because it potentially\n\t * frees some memory\n\t */\n\tspin_lock(&journal->j_list_lock);\n\t__jbd2_journal_clean_checkpoint_list(journal);\n\tspin_unlock(&journal->j_list_lock);\n\n\tjbd_debug(3, \"JBD2: commit phase 1\\n\");\n\n\t/*\n\t * Clear revoked flag to reflect there is no revoked buffers\n\t * in the next transaction which is going to be started.\n\t */\n\tjbd2_clear_buffer_revoked_flags(journal);\n\n\t/*\n\t * Switch to a new revoke table.\n\t */\n\tjbd2_journal_switch_revoke_table(journal);\n\n\t/*\n\t * Reserved credits cannot be claimed anymore, free them\n\t */\n\tatomic_sub(atomic_read(&journal->j_reserved_credits),\n\t\t   &commit_transaction->t_outstanding_credits);\n\n\ttrace_jbd2_commit_flushing(journal, commit_transaction);\n\tstats.run.rs_flushing = jiffies;\n\tstats.run.rs_locked = jbd2_time_diff(stats.run.rs_locked,\n\t\t\t\t\t     stats.run.rs_flushing);\n\n\tcommit_transaction->t_state = T_FLUSH;\n\tjournal->j_committing_transaction = commit_transaction;\n\tjournal->j_running_transaction = NULL;\n\tstart_time = ktime_get();\n\tcommit_transaction->t_log_start = journal->j_head;\n\twake_up(&journal->j_wait_transaction_locked);\n\twrite_unlock(&journal->j_state_lock);\n\n\tjbd_debug(3, \"JBD2: commit phase 2a\\n\");\n\n\t/*\n\t * Now start flushing things to disk, in the order they appear\n\t * on the transaction lists.  Data blocks go first.\n\t */\n\terr = journal_submit_data_buffers(journal, commit_transaction);\n\tif (err)\n\t\tjbd2_journal_abort(journal, err);\n\n\tblk_start_plug(&plug);\n\tjbd2_journal_write_revoke_records(journal, commit_transaction,\n\t\t\t\t\t  &log_bufs, WRITE_SYNC);\n\n\tjbd_debug(3, \"JBD2: commit phase 2b\\n\");\n\n\t/*\n\t * Way to go: we have now written out all of the data for a\n\t * transaction!  Now comes the tricky part: we need to write out\n\t * metadata.  Loop over the transaction's entire buffer list:\n\t */\n\twrite_lock(&journal->j_state_lock);\n\tcommit_transaction->t_state = T_COMMIT;\n\twrite_unlock(&journal->j_state_lock);\n\n\ttrace_jbd2_commit_logging(journal, commit_transaction);\n\tstats.run.rs_logging = jiffies;\n\tstats.run.rs_flushing = jbd2_time_diff(stats.run.rs_flushing,\n\t\t\t\t\t       stats.run.rs_logging);\n\tstats.run.rs_blocks =\n\t\tatomic_read(&commit_transaction->t_outstanding_credits);\n\tstats.run.rs_blocks_logged = 0;\n\n\tJ_ASSERT(commit_transaction->t_nr_buffers <=\n\t\t atomic_read(&commit_transaction->t_outstanding_credits));\n\n\terr = 0;\n\tbufs = 0;\n\tdescriptor = NULL;\n\twhile (commit_transaction->t_buffers) {\n\n\t\t/* Find the next buffer to be journaled... */\n\n\t\tjh = commit_transaction->t_buffers;\n\n\t\t/* If we're in abort mode, we just un-journal the buffer and\n\t\t   release it. */\n\n\t\tif (is_journal_aborted(journal)) {\n\t\t\tclear_buffer_jbddirty(jh2bh(jh));\n\t\t\tJBUFFER_TRACE(jh, \"journal is aborting: refile\");\n\t\t\tjbd2_buffer_abort_trigger(jh,\n\t\t\t\t\t\t  jh->b_frozen_data ?\n\t\t\t\t\t\t  jh->b_frozen_triggers :\n\t\t\t\t\t\t  jh->b_triggers);\n\t\t\tjbd2_journal_refile_buffer(journal, jh);\n\t\t\t/* If that was the last one, we need to clean up\n\t\t\t * any descriptor buffers which may have been\n\t\t\t * already allocated, even if we are now\n\t\t\t * aborting. */\n\t\t\tif (!commit_transaction->t_buffers)\n\t\t\t\tgoto start_journal_io;\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* Make sure we have a descriptor block in which to\n\t\t   record the metadata buffer. */\n\n\t\tif (!descriptor) {\n\t\t\tJ_ASSERT (bufs == 0);\n\n\t\t\tjbd_debug(4, \"JBD2: get descriptor\\n\");\n\n\t\t\tdescriptor = jbd2_journal_get_descriptor_buffer(journal);\n\t\t\tif (!descriptor) {\n\t\t\t\tjbd2_journal_abort(journal, -EIO);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tjbd_debug(4, \"JBD2: got buffer %llu (%p)\\n\",\n\t\t\t\t(unsigned long long)descriptor->b_blocknr,\n\t\t\t\tdescriptor->b_data);\n\t\t\theader = (journal_header_t *)descriptor->b_data;\n\t\t\theader->h_magic     = cpu_to_be32(JBD2_MAGIC_NUMBER);\n\t\t\theader->h_blocktype = cpu_to_be32(JBD2_DESCRIPTOR_BLOCK);\n\t\t\theader->h_sequence  = cpu_to_be32(commit_transaction->t_tid);\n\n\t\t\ttagp = &descriptor->b_data[sizeof(journal_header_t)];\n\t\t\tspace_left = descriptor->b_size -\n\t\t\t\t\t\tsizeof(journal_header_t);\n\t\t\tfirst_tag = 1;\n\t\t\tset_buffer_jwrite(descriptor);\n\t\t\tset_buffer_dirty(descriptor);\n\t\t\twbuf[bufs++] = descriptor;\n\n\t\t\t/* Record it so that we can wait for IO\n                           completion later */\n\t\t\tBUFFER_TRACE(descriptor, \"ph3: file as descriptor\");\n\t\t\tjbd2_file_log_bh(&log_bufs, descriptor);\n\t\t}\n\n\t\t/* Where is the buffer to be written? */\n\n\t\terr = jbd2_journal_next_log_block(journal, &blocknr);\n\t\t/* If the block mapping failed, just abandon the buffer\n\t\t   and repeat this loop: we'll fall into the\n\t\t   refile-on-abort condition above. */\n\t\tif (err) {\n\t\t\tjbd2_journal_abort(journal, err);\n\t\t\tcontinue;\n\t\t}\n\n\t\t/*\n\t\t * start_this_handle() uses t_outstanding_credits to determine\n\t\t * the free space in the log, but this counter is changed\n\t\t * by jbd2_journal_next_log_block() also.\n\t\t */\n\t\tatomic_dec(&commit_transaction->t_outstanding_credits);\n\n\t\t/* Bump b_count to prevent truncate from stumbling over\n                   the shadowed buffer!  @@@ This can go if we ever get\n                   rid of the shadow pairing of buffers. */\n\t\tatomic_inc(&jh2bh(jh)->b_count);\n\n\t\t/*\n\t\t * Make a temporary IO buffer with which to write it out\n\t\t * (this will requeue the metadata buffer to BJ_Shadow).\n\t\t */\n\t\tset_bit(BH_JWrite, &jh2bh(jh)->b_state);\n\t\tJBUFFER_TRACE(jh, \"ph3: write metadata\");\n\t\tflags = jbd2_journal_write_metadata_buffer(commit_transaction,\n\t\t\t\t\t\tjh, &wbuf[bufs], blocknr);\n\t\tif (flags < 0) {\n\t\t\tjbd2_journal_abort(journal, flags);\n\t\t\tcontinue;\n\t\t}\n\t\tjbd2_file_log_bh(&io_bufs, wbuf[bufs]);\n\n\t\t/* Record the new block's tag in the current descriptor\n                   buffer */\n\n\t\ttag_flag = 0;\n\t\tif (flags & 1)\n\t\t\ttag_flag |= JBD2_FLAG_ESCAPE;\n\t\tif (!first_tag)\n\t\t\ttag_flag |= JBD2_FLAG_SAME_UUID;\n\n\t\ttag = (journal_block_tag_t *) tagp;\n\t\twrite_tag_block(journal, tag, jh2bh(jh)->b_blocknr);\n\t\ttag->t_flags = cpu_to_be16(tag_flag);\n\t\tjbd2_block_tag_csum_set(journal, tag, wbuf[bufs],\n\t\t\t\t\tcommit_transaction->t_tid);\n\t\ttagp += tag_bytes;\n\t\tspace_left -= tag_bytes;\n\t\tbufs++;\n\n\t\tif (first_tag) {\n\t\t\tmemcpy (tagp, journal->j_uuid, 16);\n\t\t\ttagp += 16;\n\t\t\tspace_left -= 16;\n\t\t\tfirst_tag = 0;\n\t\t}\n\n\t\t/* If there's no more to do, or if the descriptor is full,\n\t\t   let the IO rip! */\n\n\t\tif (bufs == journal->j_wbufsize ||\n\t\t    commit_transaction->t_buffers == NULL ||\n\t\t    space_left < tag_bytes + 16 + csum_size) {\n\n\t\t\tjbd_debug(4, \"JBD2: Submit %d IOs\\n\", bufs);\n\n\t\t\t/* Write an end-of-descriptor marker before\n                           submitting the IOs.  \"tag\" still points to\n                           the last tag we set up. */\n\n\t\t\ttag->t_flags |= cpu_to_be16(JBD2_FLAG_LAST_TAG);\n\n\t\t\tjbd2_descr_block_csum_set(journal, descriptor);\nstart_journal_io:\n\t\t\tfor (i = 0; i < bufs; i++) {\n\t\t\t\tstruct buffer_head *bh = wbuf[i];\n\t\t\t\t/*\n\t\t\t\t * Compute checksum.\n\t\t\t\t */\n\t\t\t\tif (JBD2_HAS_COMPAT_FEATURE(journal,\n\t\t\t\t\tJBD2_FEATURE_COMPAT_CHECKSUM)) {\n\t\t\t\t\tcrc32_sum =\n\t\t\t\t\t    jbd2_checksum_data(crc32_sum, bh);\n\t\t\t\t}\n\n\t\t\t\tlock_buffer(bh);\n\t\t\t\tclear_buffer_dirty(bh);\n\t\t\t\tset_buffer_uptodate(bh);\n\t\t\t\tbh->b_end_io = journal_end_buffer_io_sync;\n\t\t\t\tsubmit_bh(WRITE_SYNC, bh);\n\t\t\t}\n\t\t\tcond_resched();\n\t\t\tstats.run.rs_blocks_logged += bufs;\n\n\t\t\t/* Force a new descriptor to be generated next\n                           time round the loop. */\n\t\t\tdescriptor = NULL;\n\t\t\tbufs = 0;\n\t\t}\n\t}\n\n\terr = journal_finish_inode_data_buffers(journal, commit_transaction);\n\tif (err) {\n\t\tprintk(KERN_WARNING\n\t\t\t\"JBD2: Detected IO errors while flushing file data \"\n\t\t       \"on %s\\n\", journal->j_devname);\n\t\tif (journal->j_flags & JBD2_ABORT_ON_SYNCDATA_ERR)\n\t\t\tjbd2_journal_abort(journal, err);\n\t\terr = 0;\n\t}\n\n\t/*\n\t * Get current oldest transaction in the log before we issue flush\n\t * to the filesystem device. After the flush we can be sure that\n\t * blocks of all older transactions are checkpointed to persistent\n\t * storage and we will be safe to update journal start in the\n\t * superblock with the numbers we get here.\n\t */\n\tupdate_tail =\n\t\tjbd2_journal_get_log_tail(journal, &first_tid, &first_block);\n\n\twrite_lock(&journal->j_state_lock);\n\tif (update_tail) {\n\t\tlong freed = first_block - journal->j_tail;\n\n\t\tif (first_block < journal->j_tail)\n\t\t\tfreed += journal->j_last - journal->j_first;\n\t\t/* Update tail only if we free significant amount of space */\n\t\tif (freed < journal->j_maxlen / 4)\n\t\t\tupdate_tail = 0;\n\t}\n\tJ_ASSERT(commit_transaction->t_state == T_COMMIT);\n\tcommit_transaction->t_state = T_COMMIT_DFLUSH;\n\twrite_unlock(&journal->j_state_lock);\n\n\t/* \n\t * If the journal is not located on the file system device,\n\t * then we must flush the file system device before we issue\n\t * the commit record\n\t */\n\tif (commit_transaction->t_need_data_flush &&\n\t    (journal->j_fs_dev != journal->j_dev) &&\n\t    (journal->j_flags & JBD2_BARRIER))\n\t\tblkdev_issue_flush(journal->j_fs_dev, GFP_NOFS, NULL);\n\n\t/* Done it all: now write the commit record asynchronously. */\n\tif (JBD2_HAS_INCOMPAT_FEATURE(journal,\n\t\t\t\t      JBD2_FEATURE_INCOMPAT_ASYNC_COMMIT)) {\n\t\terr = journal_submit_commit_record(journal, commit_transaction,\n\t\t\t\t\t\t &cbh, crc32_sum);\n\t\tif (err)\n\t\t\t__jbd2_journal_abort_hard(journal);\n\t}\n\n\tblk_finish_plug(&plug);\n\n\t/* Lo and behold: we have just managed to send a transaction to\n           the log.  Before we can commit it, wait for the IO so far to\n           complete.  Control buffers being written are on the\n           transaction's t_log_list queue, and metadata buffers are on\n           the io_bufs list.\n\n\t   Wait for the buffers in reverse order.  That way we are\n\t   less likely to be woken up until all IOs have completed, and\n\t   so we incur less scheduling load.\n\t*/\n\n\tjbd_debug(3, \"JBD2: commit phase 3\\n\");\n\n\twhile (!list_empty(&io_bufs)) {\n\t\tstruct buffer_head *bh = list_entry(io_bufs.prev,\n\t\t\t\t\t\t    struct buffer_head,\n\t\t\t\t\t\t    b_assoc_buffers);\n\n\t\twait_on_buffer(bh);\n\t\tcond_resched();\n\n\t\tif (unlikely(!buffer_uptodate(bh)))\n\t\t\terr = -EIO;\n\t\tjbd2_unfile_log_bh(bh);\n\n\t\t/*\n\t\t * The list contains temporary buffer heads created by\n\t\t * jbd2_journal_write_metadata_buffer().\n\t\t */\n\t\tBUFFER_TRACE(bh, \"dumping temporary bh\");\n\t\t__brelse(bh);\n\t\tJ_ASSERT_BH(bh, atomic_read(&bh->b_count) == 0);\n\t\tfree_buffer_head(bh);\n\n\t\t/* We also have to refile the corresponding shadowed buffer */\n\t\tjh = commit_transaction->t_shadow_list->b_tprev;\n\t\tbh = jh2bh(jh);\n\t\tclear_buffer_jwrite(bh);\n\t\tJ_ASSERT_BH(bh, buffer_jbddirty(bh));\n\t\tJ_ASSERT_BH(bh, !buffer_shadow(bh));\n\n\t\t/* The metadata is now released for reuse, but we need\n                   to remember it against this transaction so that when\n                   we finally commit, we can do any checkpointing\n                   required. */\n\t\tJBUFFER_TRACE(jh, \"file as BJ_Forget\");\n\t\tjbd2_journal_file_buffer(jh, commit_transaction, BJ_Forget);\n\t\tJBUFFER_TRACE(jh, \"brelse shadowed buffer\");\n\t\t__brelse(bh);\n\t}\n\n\tJ_ASSERT (commit_transaction->t_shadow_list == NULL);\n\n\tjbd_debug(3, \"JBD2: commit phase 4\\n\");\n\n\t/* Here we wait for the revoke record and descriptor record buffers */\n\twhile (!list_empty(&log_bufs)) {\n\t\tstruct buffer_head *bh;\n\n\t\tbh = list_entry(log_bufs.prev, struct buffer_head, b_assoc_buffers);\n\t\twait_on_buffer(bh);\n\t\tcond_resched();\n\n\t\tif (unlikely(!buffer_uptodate(bh)))\n\t\t\terr = -EIO;\n\n\t\tBUFFER_TRACE(bh, \"ph5: control buffer writeout done: unfile\");\n\t\tclear_buffer_jwrite(bh);\n\t\tjbd2_unfile_log_bh(bh);\n\t\t__brelse(bh);\t\t/* One for getblk */\n\t\t/* AKPM: bforget here */\n\t}\n\n\tif (err)\n\t\tjbd2_journal_abort(journal, err);\n\n\tjbd_debug(3, \"JBD2: commit phase 5\\n\");\n\twrite_lock(&journal->j_state_lock);\n\tJ_ASSERT(commit_transaction->t_state == T_COMMIT_DFLUSH);\n\tcommit_transaction->t_state = T_COMMIT_JFLUSH;\n\twrite_unlock(&journal->j_state_lock);\n\n\tif (!JBD2_HAS_INCOMPAT_FEATURE(journal,\n\t\t\t\t       JBD2_FEATURE_INCOMPAT_ASYNC_COMMIT)) {\n\t\terr = journal_submit_commit_record(journal, commit_transaction,\n\t\t\t\t\t\t&cbh, crc32_sum);\n\t\tif (err)\n\t\t\t__jbd2_journal_abort_hard(journal);\n\t}\n\tif (cbh)\n\t\terr = journal_wait_on_commit_record(journal, cbh);\n\tif (JBD2_HAS_INCOMPAT_FEATURE(journal,\n\t\t\t\t      JBD2_FEATURE_INCOMPAT_ASYNC_COMMIT) &&\n\t    journal->j_flags & JBD2_BARRIER) {\n\t\tblkdev_issue_flush(journal->j_dev, GFP_NOFS, NULL);\n\t}\n\n\tif (err)\n\t\tjbd2_journal_abort(journal, err);\n\n\t/*\n\t * Now disk caches for filesystem device are flushed so we are safe to\n\t * erase checkpointed transactions from the log by updating journal\n\t * superblock.\n\t */\n\tif (update_tail)\n\t\tjbd2_update_log_tail(journal, first_tid, first_block);\n\n\t/* End of a transaction!  Finally, we can do checkpoint\n           processing: any buffers committed as a result of this\n           transaction can be removed from any checkpoint list it was on\n           before. */\n\n\tjbd_debug(3, \"JBD2: commit phase 6\\n\");\n\n\tJ_ASSERT(list_empty(&commit_transaction->t_inode_list));\n\tJ_ASSERT(commit_transaction->t_buffers == NULL);\n\tJ_ASSERT(commit_transaction->t_checkpoint_list == NULL);\n\tJ_ASSERT(commit_transaction->t_shadow_list == NULL);\n\nrestart_loop:\n\t/*\n\t * As there are other places (journal_unmap_buffer()) adding buffers\n\t * to this list we have to be careful and hold the j_list_lock.\n\t */\n\tspin_lock(&journal->j_list_lock);\n\twhile (commit_transaction->t_forget) {\n\t\ttransaction_t *cp_transaction;\n\t\tstruct buffer_head *bh;\n\t\tint try_to_free = 0;\n\n\t\tjh = commit_transaction->t_forget;\n\t\tspin_unlock(&journal->j_list_lock);\n\t\tbh = jh2bh(jh);\n\t\t/*\n\t\t * Get a reference so that bh cannot be freed before we are\n\t\t * done with it.\n\t\t */\n\t\tget_bh(bh);\n\t\tjbd_lock_bh_state(bh);\n\t\tJ_ASSERT_JH(jh,\tjh->b_transaction == commit_transaction);\n\n\t\t/*\n\t\t * If there is undo-protected committed data against\n\t\t * this buffer, then we can remove it now.  If it is a\n\t\t * buffer needing such protection, the old frozen_data\n\t\t * field now points to a committed version of the\n\t\t * buffer, so rotate that field to the new committed\n\t\t * data.\n\t\t *\n\t\t * Otherwise, we can just throw away the frozen data now.\n\t\t *\n\t\t * We also know that the frozen data has already fired\n\t\t * its triggers if they exist, so we can clear that too.\n\t\t */\n\t\tif (jh->b_committed_data) {\n\t\t\tjbd2_free(jh->b_committed_data, bh->b_size);\n\t\t\tjh->b_committed_data = NULL;\n\t\t\tif (jh->b_frozen_data) {\n\t\t\t\tjh->b_committed_data = jh->b_frozen_data;\n\t\t\t\tjh->b_frozen_data = NULL;\n\t\t\t\tjh->b_frozen_triggers = NULL;\n\t\t\t}\n\t\t} else if (jh->b_frozen_data) {\n\t\t\tjbd2_free(jh->b_frozen_data, bh->b_size);\n\t\t\tjh->b_frozen_data = NULL;\n\t\t\tjh->b_frozen_triggers = NULL;\n\t\t}\n\n\t\tspin_lock(&journal->j_list_lock);\n\t\tcp_transaction = jh->b_cp_transaction;\n\t\tif (cp_transaction) {\n\t\t\tJBUFFER_TRACE(jh, \"remove from old cp transaction\");\n\t\t\tcp_transaction->t_chp_stats.cs_dropped++;\n\t\t\t__jbd2_journal_remove_checkpoint(jh);\n\t\t}\n\n\t\t/* Only re-checkpoint the buffer_head if it is marked\n\t\t * dirty.  If the buffer was added to the BJ_Forget list\n\t\t * by jbd2_journal_forget, it may no longer be dirty and\n\t\t * there's no point in keeping a checkpoint record for\n\t\t * it. */\n\n\t\t/*\n\t\t* A buffer which has been freed while still being journaled by\n\t\t* a previous transaction.\n\t\t*/\n\t\tif (buffer_freed(bh)) {\n\t\t\t/*\n\t\t\t * If the running transaction is the one containing\n\t\t\t * \"add to orphan\" operation (b_next_transaction !=\n\t\t\t * NULL), we have to wait for that transaction to\n\t\t\t * commit before we can really get rid of the buffer.\n\t\t\t * So just clear b_modified to not confuse transaction\n\t\t\t * credit accounting and refile the buffer to\n\t\t\t * BJ_Forget of the running transaction. If the just\n\t\t\t * committed transaction contains \"add to orphan\"\n\t\t\t * operation, we can completely invalidate the buffer\n\t\t\t * now. We are rather through in that since the\n\t\t\t * buffer may be still accessible when blocksize <\n\t\t\t * pagesize and it is attached to the last partial\n\t\t\t * page.\n\t\t\t */\n\t\t\tjh->b_modified = 0;\n\t\t\tif (!jh->b_next_transaction) {\n\t\t\t\tclear_buffer_freed(bh);\n\t\t\t\tclear_buffer_jbddirty(bh);\n\t\t\t\tclear_buffer_mapped(bh);\n\t\t\t\tclear_buffer_new(bh);\n\t\t\t\tclear_buffer_req(bh);\n\t\t\t\tbh->b_bdev = NULL;\n\t\t\t}\n\t\t}\n\n\t\tif (buffer_jbddirty(bh)) {\n\t\t\tJBUFFER_TRACE(jh, \"add to new checkpointing trans\");\n\t\t\t__jbd2_journal_insert_checkpoint(jh, commit_transaction);\n\t\t\tif (is_journal_aborted(journal))\n\t\t\t\tclear_buffer_jbddirty(bh);\n\t\t} else {\n\t\t\tJ_ASSERT_BH(bh, !buffer_dirty(bh));\n\t\t\t/*\n\t\t\t * The buffer on BJ_Forget list and not jbddirty means\n\t\t\t * it has been freed by this transaction and hence it\n\t\t\t * could not have been reallocated until this\n\t\t\t * transaction has committed. *BUT* it could be\n\t\t\t * reallocated once we have written all the data to\n\t\t\t * disk and before we process the buffer on BJ_Forget\n\t\t\t * list.\n\t\t\t */\n\t\t\tif (!jh->b_next_transaction)\n\t\t\t\ttry_to_free = 1;\n\t\t}\n\t\tJBUFFER_TRACE(jh, \"refile or unfile buffer\");\n\t\t__jbd2_journal_refile_buffer(jh);\n\t\tjbd_unlock_bh_state(bh);\n\t\tif (try_to_free)\n\t\t\trelease_buffer_page(bh);\t/* Drops bh reference */\n\t\telse\n\t\t\t__brelse(bh);\n\t\tcond_resched_lock(&journal->j_list_lock);\n\t}\n\tspin_unlock(&journal->j_list_lock);\n\t/*\n\t * This is a bit sleazy.  We use j_list_lock to protect transition\n\t * of a transaction into T_FINISHED state and calling\n\t * __jbd2_journal_drop_transaction(). Otherwise we could race with\n\t * other checkpointing code processing the transaction...\n\t */\n\twrite_lock(&journal->j_state_lock);\n\tspin_lock(&journal->j_list_lock);\n\t/*\n\t * Now recheck if some buffers did not get attached to the transaction\n\t * while the lock was dropped...\n\t */\n\tif (commit_transaction->t_forget) {\n\t\tspin_unlock(&journal->j_list_lock);\n\t\twrite_unlock(&journal->j_state_lock);\n\t\tgoto restart_loop;\n\t}\n\n\t/* Add the transaction to the checkpoint list\n\t * __journal_remove_checkpoint() can not destroy transaction\n\t * under us because it is not marked as T_FINISHED yet */\n\tif (journal->j_checkpoint_transactions == NULL) {\n\t\tjournal->j_checkpoint_transactions = commit_transaction;\n\t\tcommit_transaction->t_cpnext = commit_transaction;\n\t\tcommit_transaction->t_cpprev = commit_transaction;\n\t} else {\n\t\tcommit_transaction->t_cpnext =\n\t\t\tjournal->j_checkpoint_transactions;\n\t\tcommit_transaction->t_cpprev =\n\t\t\tcommit_transaction->t_cpnext->t_cpprev;\n\t\tcommit_transaction->t_cpnext->t_cpprev =\n\t\t\tcommit_transaction;\n\t\tcommit_transaction->t_cpprev->t_cpnext =\n\t\t\t\tcommit_transaction;\n\t}\n\tspin_unlock(&journal->j_list_lock);\n\n\t/* Done with this transaction! */\n\n\tjbd_debug(3, \"JBD2: commit phase 7\\n\");\n\n\tJ_ASSERT(commit_transaction->t_state == T_COMMIT_JFLUSH);\n\n\tcommit_transaction->t_start = jiffies;\n\tstats.run.rs_logging = jbd2_time_diff(stats.run.rs_logging,\n\t\t\t\t\t      commit_transaction->t_start);\n\n\t/*\n\t * File the transaction statistics\n\t */\n\tstats.ts_tid = commit_transaction->t_tid;\n\tstats.run.rs_handle_count =\n\t\tatomic_read(&commit_transaction->t_handle_count);\n\ttrace_jbd2_run_stats(journal->j_fs_dev->bd_dev,\n\t\t\t     commit_transaction->t_tid, &stats.run);\n\tstats.ts_requested = (commit_transaction->t_requested) ? 1 : 0;\n\n\tcommit_transaction->t_state = T_COMMIT_CALLBACK;\n\tJ_ASSERT(commit_transaction == journal->j_committing_transaction);\n\tjournal->j_commit_sequence = commit_transaction->t_tid;\n\tjournal->j_committing_transaction = NULL;\n\tcommit_time = ktime_to_ns(ktime_sub(ktime_get(), start_time));\n\n\t/*\n\t * weight the commit time higher than the average time so we don't\n\t * react too strongly to vast changes in the commit time\n\t */\n\tif (likely(journal->j_average_commit_time))\n\t\tjournal->j_average_commit_time = (commit_time +\n\t\t\t\tjournal->j_average_commit_time*3) / 4;\n\telse\n\t\tjournal->j_average_commit_time = commit_time;\n\n\twrite_unlock(&journal->j_state_lock);\n\n\tif (journal->j_commit_callback)\n\t\tjournal->j_commit_callback(journal, commit_transaction);\n\n\ttrace_jbd2_end_commit(journal, commit_transaction);\n\tjbd_debug(1, \"JBD2: commit %d complete, head %d\\n\",\n\t\t  journal->j_commit_sequence, journal->j_tail_sequence);\n\n\twrite_lock(&journal->j_state_lock);\n\tspin_lock(&journal->j_list_lock);\n\tcommit_transaction->t_state = T_FINISHED;\n\t/* Check if the transaction can be dropped now that we are finished */\n\tif (commit_transaction->t_checkpoint_list == NULL &&\n\t    commit_transaction->t_checkpoint_io_list == NULL) {\n\t\t__jbd2_journal_drop_transaction(journal, commit_transaction);\n\t\tjbd2_journal_free_transaction(commit_transaction);\n\t}\n\tspin_unlock(&journal->j_list_lock);\n\twrite_unlock(&journal->j_state_lock);\n\twake_up(&journal->j_wait_done_commit);\n\n\t/*\n\t * Calculate overall stats\n\t */\n\tspin_lock(&journal->j_history_lock);\n\tjournal->j_stats.ts_tid++;\n\tjournal->j_stats.ts_requested += stats.ts_requested;\n\tjournal->j_stats.run.rs_wait += stats.run.rs_wait;\n\tjournal->j_stats.run.rs_request_delay += stats.run.rs_request_delay;\n\tjournal->j_stats.run.rs_running += stats.run.rs_running;\n\tjournal->j_stats.run.rs_locked += stats.run.rs_locked;\n\tjournal->j_stats.run.rs_flushing += stats.run.rs_flushing;\n\tjournal->j_stats.run.rs_logging += stats.run.rs_logging;\n\tjournal->j_stats.run.rs_handle_count += stats.run.rs_handle_count;\n\tjournal->j_stats.run.rs_blocks += stats.run.rs_blocks;\n\tjournal->j_stats.run.rs_blocks_logged += stats.run.rs_blocks_logged;\n\tspin_unlock(&journal->j_history_lock);\n}"
  },
  {
    "function_name": "jbd2_block_tag_csum_set",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd2/commit.c",
    "lines": "340-363",
    "snippet": "static void jbd2_block_tag_csum_set(journal_t *j, journal_block_tag_t *tag,\n\t\t\t\t    struct buffer_head *bh, __u32 sequence)\n{\n\tjournal_block_tag3_t *tag3 = (journal_block_tag3_t *)tag;\n\tstruct page *page = bh->b_page;\n\t__u8 *addr;\n\t__u32 csum32;\n\t__be32 seq;\n\n\tif (!jbd2_journal_has_csum_v2or3(j))\n\t\treturn;\n\n\tseq = cpu_to_be32(sequence);\n\taddr = kmap_atomic(page);\n\tcsum32 = jbd2_chksum(j, j->j_csum_seed, (__u8 *)&seq, sizeof(seq));\n\tcsum32 = jbd2_chksum(j, csum32, addr + offset_in_page(bh->b_data),\n\t\t\t     bh->b_size);\n\tkunmap_atomic(addr);\n\n\tif (JBD2_HAS_INCOMPAT_FEATURE(j, JBD2_FEATURE_INCOMPAT_CSUM_V3))\n\t\ttag3->t_checksum = cpu_to_be32(csum32);\n\telse\n\t\ttag->t_checksum = cpu_to_be16(csum32);\n}",
    "includes": [
      "#include <trace/events/jbd2.h>",
      "#include <linux/bitops.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/bio.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/crc32.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mm.h>",
      "#include <linux/slab.h>",
      "#include <linux/errno.h>",
      "#include <linux/jbd2.h>",
      "#include <linux/fs.h>",
      "#include <linux/time.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cpu_to_be16",
          "args": [
            "csum32"
          ],
          "line": 362
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "csum32"
          ],
          "line": 360
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "JBD2_HAS_INCOMPAT_FEATURE",
          "args": [
            "j",
            "JBD2_FEATURE_INCOMPAT_CSUM_V3"
          ],
          "line": 359
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kunmap_atomic",
          "args": [
            "addr"
          ],
          "line": 357
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "jbd2_chksum",
          "args": [
            "j",
            "csum32",
            "addr + offset_in_page(bh->b_data)",
            "bh->b_size"
          ],
          "line": 355
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "offset_in_page",
          "args": [
            "bh->b_data"
          ],
          "line": 355
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "jbd2_chksum",
          "args": [
            "j",
            "j->j_csum_seed",
            "(__u8 *)&seq",
            "sizeof(seq)"
          ],
          "line": 354
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmap_atomic",
          "args": [
            "page"
          ],
          "line": 353
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "sequence"
          ],
          "line": 352
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "jbd2_journal_has_csum_v2or3",
          "args": [
            "j"
          ],
          "line": 349
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/jbd2.h>\n#include <linux/bitops.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include <linux/backing-dev.h>\n#include <linux/writeback.h>\n#include <linux/crc32.h>\n#include <linux/jiffies.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n\nstatic void jbd2_block_tag_csum_set(journal_t *j, journal_block_tag_t *tag,\n\t\t\t\t    struct buffer_head *bh, __u32 sequence)\n{\n\tjournal_block_tag3_t *tag3 = (journal_block_tag3_t *)tag;\n\tstruct page *page = bh->b_page;\n\t__u8 *addr;\n\t__u32 csum32;\n\t__be32 seq;\n\n\tif (!jbd2_journal_has_csum_v2or3(j))\n\t\treturn;\n\n\tseq = cpu_to_be32(sequence);\n\taddr = kmap_atomic(page);\n\tcsum32 = jbd2_chksum(j, j->j_csum_seed, (__u8 *)&seq, sizeof(seq));\n\tcsum32 = jbd2_chksum(j, csum32, addr + offset_in_page(bh->b_data),\n\t\t\t     bh->b_size);\n\tkunmap_atomic(addr);\n\n\tif (JBD2_HAS_INCOMPAT_FEATURE(j, JBD2_FEATURE_INCOMPAT_CSUM_V3))\n\t\ttag3->t_checksum = cpu_to_be32(csum32);\n\telse\n\t\ttag->t_checksum = cpu_to_be16(csum32);\n}"
  },
  {
    "function_name": "jbd2_descr_block_csum_set",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd2/commit.c",
    "lines": "324-338",
    "snippet": "static void jbd2_descr_block_csum_set(journal_t *j,\n\t\t\t\t      struct buffer_head *bh)\n{\n\tstruct jbd2_journal_block_tail *tail;\n\t__u32 csum;\n\n\tif (!jbd2_journal_has_csum_v2or3(j))\n\t\treturn;\n\n\ttail = (struct jbd2_journal_block_tail *)(bh->b_data + j->j_blocksize -\n\t\t\tsizeof(struct jbd2_journal_block_tail));\n\ttail->t_checksum = 0;\n\tcsum = jbd2_chksum(j, j->j_csum_seed, bh->b_data, j->j_blocksize);\n\ttail->t_checksum = cpu_to_be32(csum);\n}",
    "includes": [
      "#include <trace/events/jbd2.h>",
      "#include <linux/bitops.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/bio.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/crc32.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mm.h>",
      "#include <linux/slab.h>",
      "#include <linux/errno.h>",
      "#include <linux/jbd2.h>",
      "#include <linux/fs.h>",
      "#include <linux/time.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "csum"
          ],
          "line": 337
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "jbd2_chksum",
          "args": [
            "j",
            "j->j_csum_seed",
            "bh->b_data",
            "j->j_blocksize"
          ],
          "line": 336
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "jbd2_journal_has_csum_v2or3",
          "args": [
            "j"
          ],
          "line": 330
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/jbd2.h>\n#include <linux/bitops.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include <linux/backing-dev.h>\n#include <linux/writeback.h>\n#include <linux/crc32.h>\n#include <linux/jiffies.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n\nstatic void jbd2_descr_block_csum_set(journal_t *j,\n\t\t\t\t      struct buffer_head *bh)\n{\n\tstruct jbd2_journal_block_tail *tail;\n\t__u32 csum;\n\n\tif (!jbd2_journal_has_csum_v2or3(j))\n\t\treturn;\n\n\ttail = (struct jbd2_journal_block_tail *)(bh->b_data + j->j_blocksize -\n\t\t\tsizeof(struct jbd2_journal_block_tail));\n\ttail->t_checksum = 0;\n\tcsum = jbd2_chksum(j, j->j_csum_seed, bh->b_data, j->j_blocksize);\n\ttail->t_checksum = cpu_to_be32(csum);\n}"
  },
  {
    "function_name": "write_tag_block",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd2/commit.c",
    "lines": "316-322",
    "snippet": "static void write_tag_block(journal_t *j, journal_block_tag_t *tag,\n\t\t\t\t   unsigned long long block)\n{\n\ttag->t_blocknr = cpu_to_be32(block & (u32)~0);\n\tif (JBD2_HAS_INCOMPAT_FEATURE(j, JBD2_FEATURE_INCOMPAT_64BIT))\n\t\ttag->t_blocknr_high = cpu_to_be32((block >> 31) >> 1);\n}",
    "includes": [
      "#include <trace/events/jbd2.h>",
      "#include <linux/bitops.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/bio.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/crc32.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mm.h>",
      "#include <linux/slab.h>",
      "#include <linux/errno.h>",
      "#include <linux/jbd2.h>",
      "#include <linux/fs.h>",
      "#include <linux/time.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "(block >> 31) >> 1"
          ],
          "line": 321
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "JBD2_HAS_INCOMPAT_FEATURE",
          "args": [
            "j",
            "JBD2_FEATURE_INCOMPAT_64BIT"
          ],
          "line": 320
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "block & (u32)~0"
          ],
          "line": 319
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/jbd2.h>\n#include <linux/bitops.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include <linux/backing-dev.h>\n#include <linux/writeback.h>\n#include <linux/crc32.h>\n#include <linux/jiffies.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n\nstatic void write_tag_block(journal_t *j, journal_block_tag_t *tag,\n\t\t\t\t   unsigned long long block)\n{\n\ttag->t_blocknr = cpu_to_be32(block & (u32)~0);\n\tif (JBD2_HAS_INCOMPAT_FEATURE(j, JBD2_FEATURE_INCOMPAT_64BIT))\n\t\ttag->t_blocknr_high = cpu_to_be32((block >> 31) >> 1);\n}"
  },
  {
    "function_name": "jbd2_checksum_data",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd2/commit.c",
    "lines": "302-314",
    "snippet": "static __u32 jbd2_checksum_data(__u32 crc32_sum, struct buffer_head *bh)\n{\n\tstruct page *page = bh->b_page;\n\tchar *addr;\n\t__u32 checksum;\n\n\taddr = kmap_atomic(page);\n\tchecksum = crc32_be(crc32_sum,\n\t\t(void *)(addr + offset_in_page(bh->b_data)), bh->b_size);\n\tkunmap_atomic(addr);\n\n\treturn checksum;\n}",
    "includes": [
      "#include <trace/events/jbd2.h>",
      "#include <linux/bitops.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/bio.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/crc32.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mm.h>",
      "#include <linux/slab.h>",
      "#include <linux/errno.h>",
      "#include <linux/jbd2.h>",
      "#include <linux/fs.h>",
      "#include <linux/time.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kunmap_atomic",
          "args": [
            "addr"
          ],
          "line": 311
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "crc32_be",
          "args": [
            "crc32_sum",
            "(void *)(addr + offset_in_page(bh->b_data))",
            "bh->b_size"
          ],
          "line": 309
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "offset_in_page",
          "args": [
            "bh->b_data"
          ],
          "line": 310
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmap_atomic",
          "args": [
            "page"
          ],
          "line": 308
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/jbd2.h>\n#include <linux/bitops.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include <linux/backing-dev.h>\n#include <linux/writeback.h>\n#include <linux/crc32.h>\n#include <linux/jiffies.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n\nstatic __u32 jbd2_checksum_data(__u32 crc32_sum, struct buffer_head *bh)\n{\n\tstruct page *page = bh->b_page;\n\tchar *addr;\n\t__u32 checksum;\n\n\taddr = kmap_atomic(page);\n\tchecksum = crc32_be(crc32_sum,\n\t\t(void *)(addr + offset_in_page(bh->b_data)), bh->b_size);\n\tkunmap_atomic(addr);\n\n\treturn checksum;\n}"
  },
  {
    "function_name": "journal_finish_inode_data_buffers",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd2/commit.c",
    "lines": "254-300",
    "snippet": "static int journal_finish_inode_data_buffers(journal_t *journal,\n\t\ttransaction_t *commit_transaction)\n{\n\tstruct jbd2_inode *jinode, *next_i;\n\tint err, ret = 0;\n\n\t/* For locking, see the comment in journal_submit_data_buffers() */\n\tspin_lock(&journal->j_list_lock);\n\tlist_for_each_entry(jinode, &commit_transaction->t_inode_list, i_list) {\n\t\tset_bit(__JI_COMMIT_RUNNING, &jinode->i_flags);\n\t\tspin_unlock(&journal->j_list_lock);\n\t\terr = filemap_fdatawait(jinode->i_vfs_inode->i_mapping);\n\t\tif (err) {\n\t\t\t/*\n\t\t\t * Because AS_EIO is cleared by\n\t\t\t * filemap_fdatawait_range(), set it again so\n\t\t\t * that user process can get -EIO from fsync().\n\t\t\t */\n\t\t\tset_bit(AS_EIO,\n\t\t\t\t&jinode->i_vfs_inode->i_mapping->flags);\n\n\t\t\tif (!ret)\n\t\t\t\tret = err;\n\t\t}\n\t\tspin_lock(&journal->j_list_lock);\n\t\tclear_bit(__JI_COMMIT_RUNNING, &jinode->i_flags);\n\t\tsmp_mb__after_atomic();\n\t\twake_up_bit(&jinode->i_flags, __JI_COMMIT_RUNNING);\n\t}\n\n\t/* Now refile inode to proper lists */\n\tlist_for_each_entry_safe(jinode, next_i,\n\t\t\t\t &commit_transaction->t_inode_list, i_list) {\n\t\tlist_del(&jinode->i_list);\n\t\tif (jinode->i_next_transaction) {\n\t\t\tjinode->i_transaction = jinode->i_next_transaction;\n\t\t\tjinode->i_next_transaction = NULL;\n\t\t\tlist_add(&jinode->i_list,\n\t\t\t\t&jinode->i_transaction->t_inode_list);\n\t\t} else {\n\t\t\tjinode->i_transaction = NULL;\n\t\t}\n\t}\n\tspin_unlock(&journal->j_list_lock);\n\n\treturn ret;\n}",
    "includes": [
      "#include <trace/events/jbd2.h>",
      "#include <linux/bitops.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/bio.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/crc32.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mm.h>",
      "#include <linux/slab.h>",
      "#include <linux/errno.h>",
      "#include <linux/jbd2.h>",
      "#include <linux/fs.h>",
      "#include <linux/time.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&journal->j_list_lock"
          ],
          "line": 297
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_add",
          "args": [
            "&jinode->i_list",
            "&jinode->i_transaction->t_inode_list"
          ],
          "line": 291
        },
        "resolved": true,
        "details": {
          "function_name": "__blist_add_buffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd2/transaction.c",
          "lines": "1689-1702",
          "snippet": "static inline void\n__blist_add_buffer(struct journal_head **list, struct journal_head *jh)\n{\n\tif (!*list) {\n\t\tjh->b_tnext = jh->b_tprev = jh;\n\t\t*list = jh;\n\t} else {\n\t\t/* Insert at the tail of the list to preserve order */\n\t\tstruct journal_head *first = *list, *last = first->b_tprev;\n\t\tjh->b_tprev = last;\n\t\tjh->b_tnext = first;\n\t\tlast->b_tnext = first->b_tprev = jh;\n\t}\n}",
          "includes": [
            "#include <trace/events/jbd2.h>",
            "#include <linux/module.h>",
            "#include <linux/bug.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/timer.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __jbd2_journal_temp_unlink_buffer(struct journal_head *jh);",
            "static void __jbd2_journal_unfile_buffer(struct journal_head *jh);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/jbd2.h>\n#include <linux/module.h>\n#include <linux/bug.h>\n#include <linux/backing-dev.h>\n#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/timer.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n\nstatic void __jbd2_journal_temp_unlink_buffer(struct journal_head *jh);\nstatic void __jbd2_journal_unfile_buffer(struct journal_head *jh);\n\nstatic inline void\n__blist_add_buffer(struct journal_head **list, struct journal_head *jh)\n{\n\tif (!*list) {\n\t\tjh->b_tnext = jh->b_tprev = jh;\n\t\t*list = jh;\n\t} else {\n\t\t/* Insert at the tail of the list to preserve order */\n\t\tstruct journal_head *first = *list, *last = first->b_tprev;\n\t\tjh->b_tprev = last;\n\t\tjh->b_tnext = first;\n\t\tlast->b_tnext = first->b_tprev = jh;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_del",
          "args": [
            "&jinode->i_list"
          ],
          "line": 287
        },
        "resolved": true,
        "details": {
          "function_name": "inode_sb_list_del",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "433-440",
          "snippet": "static inline void inode_sb_list_del(struct inode *inode)\n{\n\tif (!list_empty(&inode->i_sb_list)) {\n\t\tspin_lock(&inode_sb_list_lock);\n\t\tlist_del_init(&inode->i_sb_list);\n\t\tspin_unlock(&inode_sb_list_lock);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "__cacheline_aligned_in_smp DEFINE_SPINLOCK(inode_sb_list_lock);",
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\n__cacheline_aligned_in_smp DEFINE_SPINLOCK(inode_sb_list_lock);\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nstatic inline void inode_sb_list_del(struct inode *inode)\n{\n\tif (!list_empty(&inode->i_sb_list)) {\n\t\tspin_lock(&inode_sb_list_lock);\n\t\tlist_del_init(&inode->i_sb_list);\n\t\tspin_unlock(&inode_sb_list_lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry_safe",
          "args": [
            "jinode",
            "next_i",
            "&commit_transaction->t_inode_list",
            "i_list"
          ],
          "line": 285
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wake_up_bit",
          "args": [
            "&jinode->i_flags",
            "__JI_COMMIT_RUNNING"
          ],
          "line": 281
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smp_mb__after_atomic",
          "args": [],
          "line": 280
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clear_bit",
          "args": [
            "__JI_COMMIT_RUNNING",
            "&jinode->i_flags"
          ],
          "line": 279
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_clear_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "892-896",
          "snippet": "static inline void ocfs2_clear_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_clear_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline void ocfs2_clear_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_clear_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&journal->j_list_lock"
          ],
          "line": 278
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_bit",
          "args": [
            "AS_EIO",
            "&jinode->i_vfs_inode->i_mapping->flags"
          ],
          "line": 272
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_set_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "886-890",
          "snippet": "static inline void ocfs2_set_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_set_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline void ocfs2_set_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_set_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "filemap_fdatawait",
          "args": [
            "jinode->i_vfs_inode->i_mapping"
          ],
          "line": 265
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "jinode",
            "&commit_transaction->t_inode_list",
            "i_list"
          ],
          "line": 262
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/jbd2.h>\n#include <linux/bitops.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include <linux/backing-dev.h>\n#include <linux/writeback.h>\n#include <linux/crc32.h>\n#include <linux/jiffies.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n\nstatic int journal_finish_inode_data_buffers(journal_t *journal,\n\t\ttransaction_t *commit_transaction)\n{\n\tstruct jbd2_inode *jinode, *next_i;\n\tint err, ret = 0;\n\n\t/* For locking, see the comment in journal_submit_data_buffers() */\n\tspin_lock(&journal->j_list_lock);\n\tlist_for_each_entry(jinode, &commit_transaction->t_inode_list, i_list) {\n\t\tset_bit(__JI_COMMIT_RUNNING, &jinode->i_flags);\n\t\tspin_unlock(&journal->j_list_lock);\n\t\terr = filemap_fdatawait(jinode->i_vfs_inode->i_mapping);\n\t\tif (err) {\n\t\t\t/*\n\t\t\t * Because AS_EIO is cleared by\n\t\t\t * filemap_fdatawait_range(), set it again so\n\t\t\t * that user process can get -EIO from fsync().\n\t\t\t */\n\t\t\tset_bit(AS_EIO,\n\t\t\t\t&jinode->i_vfs_inode->i_mapping->flags);\n\n\t\t\tif (!ret)\n\t\t\t\tret = err;\n\t\t}\n\t\tspin_lock(&journal->j_list_lock);\n\t\tclear_bit(__JI_COMMIT_RUNNING, &jinode->i_flags);\n\t\tsmp_mb__after_atomic();\n\t\twake_up_bit(&jinode->i_flags, __JI_COMMIT_RUNNING);\n\t}\n\n\t/* Now refile inode to proper lists */\n\tlist_for_each_entry_safe(jinode, next_i,\n\t\t\t\t &commit_transaction->t_inode_list, i_list) {\n\t\tlist_del(&jinode->i_list);\n\t\tif (jinode->i_next_transaction) {\n\t\t\tjinode->i_transaction = jinode->i_next_transaction;\n\t\t\tjinode->i_next_transaction = NULL;\n\t\t\tlist_add(&jinode->i_list,\n\t\t\t\t&jinode->i_transaction->t_inode_list);\n\t\t} else {\n\t\t\tjinode->i_transaction = NULL;\n\t\t}\n\t}\n\tspin_unlock(&journal->j_list_lock);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "journal_submit_data_buffers",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd2/commit.c",
    "lines": "217-247",
    "snippet": "static int journal_submit_data_buffers(journal_t *journal,\n\t\ttransaction_t *commit_transaction)\n{\n\tstruct jbd2_inode *jinode;\n\tint err, ret = 0;\n\tstruct address_space *mapping;\n\n\tspin_lock(&journal->j_list_lock);\n\tlist_for_each_entry(jinode, &commit_transaction->t_inode_list, i_list) {\n\t\tmapping = jinode->i_vfs_inode->i_mapping;\n\t\tset_bit(__JI_COMMIT_RUNNING, &jinode->i_flags);\n\t\tspin_unlock(&journal->j_list_lock);\n\t\t/*\n\t\t * submit the inode data buffers. We use writepage\n\t\t * instead of writepages. Because writepages can do\n\t\t * block allocation  with delalloc. We need to write\n\t\t * only allocated blocks here.\n\t\t */\n\t\ttrace_jbd2_submit_inode_data(jinode->i_vfs_inode);\n\t\terr = journal_submit_inode_data_buffers(mapping);\n\t\tif (!ret)\n\t\t\tret = err;\n\t\tspin_lock(&journal->j_list_lock);\n\t\tJ_ASSERT(jinode->i_transaction == commit_transaction);\n\t\tclear_bit(__JI_COMMIT_RUNNING, &jinode->i_flags);\n\t\tsmp_mb__after_atomic();\n\t\twake_up_bit(&jinode->i_flags, __JI_COMMIT_RUNNING);\n\t}\n\tspin_unlock(&journal->j_list_lock);\n\treturn ret;\n}",
    "includes": [
      "#include <trace/events/jbd2.h>",
      "#include <linux/bitops.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/bio.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/crc32.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mm.h>",
      "#include <linux/slab.h>",
      "#include <linux/errno.h>",
      "#include <linux/jbd2.h>",
      "#include <linux/fs.h>",
      "#include <linux/time.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&journal->j_list_lock"
          ],
          "line": 245
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "wake_up_bit",
          "args": [
            "&jinode->i_flags",
            "__JI_COMMIT_RUNNING"
          ],
          "line": 243
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smp_mb__after_atomic",
          "args": [],
          "line": 242
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clear_bit",
          "args": [
            "__JI_COMMIT_RUNNING",
            "&jinode->i_flags"
          ],
          "line": 241
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_clear_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "892-896",
          "snippet": "static inline void ocfs2_clear_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_clear_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline void ocfs2_clear_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_clear_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "J_ASSERT",
          "args": [
            "jinode->i_transaction == commit_transaction"
          ],
          "line": 240
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&journal->j_list_lock"
          ],
          "line": 239
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "journal_submit_inode_data_buffers",
          "args": [
            "mapping"
          ],
          "line": 236
        },
        "resolved": true,
        "details": {
          "function_name": "journal_submit_inode_data_buffers",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd2/commit.c",
          "lines": "195-207",
          "snippet": "static int journal_submit_inode_data_buffers(struct address_space *mapping)\n{\n\tint ret;\n\tstruct writeback_control wbc = {\n\t\t.sync_mode =  WB_SYNC_ALL,\n\t\t.nr_to_write = mapping->nrpages * 2,\n\t\t.range_start = 0,\n\t\t.range_end = i_size_read(mapping->host),\n\t};\n\n\tret = generic_writepages(mapping, &wbc);\n\treturn ret;\n}",
          "includes": [
            "#include <trace/events/jbd2.h>",
            "#include <linux/bitops.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/bio.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/crc32.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/jbd2.h>\n#include <linux/bitops.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include <linux/backing-dev.h>\n#include <linux/writeback.h>\n#include <linux/crc32.h>\n#include <linux/jiffies.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n\nstatic int journal_submit_inode_data_buffers(struct address_space *mapping)\n{\n\tint ret;\n\tstruct writeback_control wbc = {\n\t\t.sync_mode =  WB_SYNC_ALL,\n\t\t.nr_to_write = mapping->nrpages * 2,\n\t\t.range_start = 0,\n\t\t.range_end = i_size_read(mapping->host),\n\t};\n\n\tret = generic_writepages(mapping, &wbc);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_jbd2_submit_inode_data",
          "args": [
            "jinode->i_vfs_inode"
          ],
          "line": 235
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_bit",
          "args": [
            "__JI_COMMIT_RUNNING",
            "&jinode->i_flags"
          ],
          "line": 227
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_set_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "886-890",
          "snippet": "static inline void ocfs2_set_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_set_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline void ocfs2_set_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_set_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "jinode",
            "&commit_transaction->t_inode_list",
            "i_list"
          ],
          "line": 225
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/jbd2.h>\n#include <linux/bitops.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include <linux/backing-dev.h>\n#include <linux/writeback.h>\n#include <linux/crc32.h>\n#include <linux/jiffies.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n\nstatic int journal_submit_data_buffers(journal_t *journal,\n\t\ttransaction_t *commit_transaction)\n{\n\tstruct jbd2_inode *jinode;\n\tint err, ret = 0;\n\tstruct address_space *mapping;\n\n\tspin_lock(&journal->j_list_lock);\n\tlist_for_each_entry(jinode, &commit_transaction->t_inode_list, i_list) {\n\t\tmapping = jinode->i_vfs_inode->i_mapping;\n\t\tset_bit(__JI_COMMIT_RUNNING, &jinode->i_flags);\n\t\tspin_unlock(&journal->j_list_lock);\n\t\t/*\n\t\t * submit the inode data buffers. We use writepage\n\t\t * instead of writepages. Because writepages can do\n\t\t * block allocation  with delalloc. We need to write\n\t\t * only allocated blocks here.\n\t\t */\n\t\ttrace_jbd2_submit_inode_data(jinode->i_vfs_inode);\n\t\terr = journal_submit_inode_data_buffers(mapping);\n\t\tif (!ret)\n\t\t\tret = err;\n\t\tspin_lock(&journal->j_list_lock);\n\t\tJ_ASSERT(jinode->i_transaction == commit_transaction);\n\t\tclear_bit(__JI_COMMIT_RUNNING, &jinode->i_flags);\n\t\tsmp_mb__after_atomic();\n\t\twake_up_bit(&jinode->i_flags, __JI_COMMIT_RUNNING);\n\t}\n\tspin_unlock(&journal->j_list_lock);\n\treturn ret;\n}"
  },
  {
    "function_name": "journal_submit_inode_data_buffers",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd2/commit.c",
    "lines": "195-207",
    "snippet": "static int journal_submit_inode_data_buffers(struct address_space *mapping)\n{\n\tint ret;\n\tstruct writeback_control wbc = {\n\t\t.sync_mode =  WB_SYNC_ALL,\n\t\t.nr_to_write = mapping->nrpages * 2,\n\t\t.range_start = 0,\n\t\t.range_end = i_size_read(mapping->host),\n\t};\n\n\tret = generic_writepages(mapping, &wbc);\n\treturn ret;\n}",
    "includes": [
      "#include <trace/events/jbd2.h>",
      "#include <linux/bitops.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/bio.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/crc32.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mm.h>",
      "#include <linux/slab.h>",
      "#include <linux/errno.h>",
      "#include <linux/jbd2.h>",
      "#include <linux/fs.h>",
      "#include <linux/time.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "generic_writepages",
          "args": [
            "mapping",
            "&wbc"
          ],
          "line": 205
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "i_size_read",
          "args": [
            "mapping->host"
          ],
          "line": 202
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/jbd2.h>\n#include <linux/bitops.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include <linux/backing-dev.h>\n#include <linux/writeback.h>\n#include <linux/crc32.h>\n#include <linux/jiffies.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n\nstatic int journal_submit_inode_data_buffers(struct address_space *mapping)\n{\n\tint ret;\n\tstruct writeback_control wbc = {\n\t\t.sync_mode =  WB_SYNC_ALL,\n\t\t.nr_to_write = mapping->nrpages * 2,\n\t\t.range_start = 0,\n\t\t.range_end = i_size_read(mapping->host),\n\t};\n\n\tret = generic_writepages(mapping, &wbc);\n\treturn ret;\n}"
  },
  {
    "function_name": "journal_wait_on_commit_record",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd2/commit.c",
    "lines": "174-187",
    "snippet": "static int journal_wait_on_commit_record(journal_t *journal,\n\t\t\t\t\t struct buffer_head *bh)\n{\n\tint ret = 0;\n\n\tclear_buffer_dirty(bh);\n\twait_on_buffer(bh);\n\n\tif (unlikely(!buffer_uptodate(bh)))\n\t\tret = -EIO;\n\tput_bh(bh);            /* One for getblk() */\n\n\treturn ret;\n}",
    "includes": [
      "#include <trace/events/jbd2.h>",
      "#include <linux/bitops.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/bio.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/crc32.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mm.h>",
      "#include <linux/slab.h>",
      "#include <linux/errno.h>",
      "#include <linux/jbd2.h>",
      "#include <linux/fs.h>",
      "#include <linux/time.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "put_bh",
          "args": [
            "bh"
          ],
          "line": 184
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!buffer_uptodate(bh)"
          ],
          "line": 182
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "buffer_uptodate",
          "args": [
            "bh"
          ],
          "line": 182
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_set_buffer_uptodate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/disk-io.c",
          "lines": "3758-3761",
          "snippet": "int btrfs_set_buffer_uptodate(struct extent_buffer *buf)\n{\n\treturn set_extent_buffer_uptodate(buf);\n}",
          "includes": [
            "#include <asm/cpufeature.h>",
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"raid56.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/uuid.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/migrate.h>",
            "#include <linux/slab.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/writeback.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/swap.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/cpufeature.h>\n#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"raid56.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <asm/unaligned.h>\n#include <linux/semaphore.h>\n#include <linux/uuid.h>\n#include <linux/ratelimit.h>\n#include <linux/migrate.h>\n#include <linux/slab.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/radix-tree.h>\n#include <linux/swap.h>\n#include <linux/scatterlist.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nint btrfs_set_buffer_uptodate(struct extent_buffer *buf)\n{\n\treturn set_extent_buffer_uptodate(buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "wait_on_buffer",
          "args": [
            "bh"
          ],
          "line": 180
        },
        "resolved": true,
        "details": {
          "function_name": "__wait_on_buffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "117-120",
          "snippet": "void __wait_on_buffer(struct buffer_head * bh)\n{\n\twait_on_bit_io(&bh->b_state, BH_Lock, TASK_UNINTERRUPTIBLE);\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __wait_on_buffer(struct buffer_head * bh)\n{\n\twait_on_bit_io(&bh->b_state, BH_Lock, TASK_UNINTERRUPTIBLE);\n}"
        }
      },
      {
        "call_info": {
          "callee": "clear_buffer_dirty",
          "args": [
            "bh"
          ],
          "line": 179
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/jbd2.h>\n#include <linux/bitops.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include <linux/backing-dev.h>\n#include <linux/writeback.h>\n#include <linux/crc32.h>\n#include <linux/jiffies.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n\nstatic int journal_wait_on_commit_record(journal_t *journal,\n\t\t\t\t\t struct buffer_head *bh)\n{\n\tint ret = 0;\n\n\tclear_buffer_dirty(bh);\n\twait_on_buffer(bh);\n\n\tif (unlikely(!buffer_uptodate(bh)))\n\t\tret = -EIO;\n\tput_bh(bh);            /* One for getblk() */\n\n\treturn ret;\n}"
  },
  {
    "function_name": "journal_submit_commit_record",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd2/commit.c",
    "lines": "119-168",
    "snippet": "static int journal_submit_commit_record(journal_t *journal,\n\t\t\t\t\ttransaction_t *commit_transaction,\n\t\t\t\t\tstruct buffer_head **cbh,\n\t\t\t\t\t__u32 crc32_sum)\n{\n\tstruct commit_header *tmp;\n\tstruct buffer_head *bh;\n\tint ret;\n\tstruct timespec now = current_kernel_time();\n\n\t*cbh = NULL;\n\n\tif (is_journal_aborted(journal))\n\t\treturn 0;\n\n\tbh = jbd2_journal_get_descriptor_buffer(journal);\n\tif (!bh)\n\t\treturn 1;\n\n\ttmp = (struct commit_header *)bh->b_data;\n\ttmp->h_magic = cpu_to_be32(JBD2_MAGIC_NUMBER);\n\ttmp->h_blocktype = cpu_to_be32(JBD2_COMMIT_BLOCK);\n\ttmp->h_sequence = cpu_to_be32(commit_transaction->t_tid);\n\ttmp->h_commit_sec = cpu_to_be64(now.tv_sec);\n\ttmp->h_commit_nsec = cpu_to_be32(now.tv_nsec);\n\n\tif (JBD2_HAS_COMPAT_FEATURE(journal,\n\t\t\t\t    JBD2_FEATURE_COMPAT_CHECKSUM)) {\n\t\ttmp->h_chksum_type \t= JBD2_CRC32_CHKSUM;\n\t\ttmp->h_chksum_size \t= JBD2_CRC32_CHKSUM_SIZE;\n\t\ttmp->h_chksum[0] \t= cpu_to_be32(crc32_sum);\n\t}\n\tjbd2_commit_block_csum_set(journal, bh);\n\n\tBUFFER_TRACE(bh, \"submit commit block\");\n\tlock_buffer(bh);\n\tclear_buffer_dirty(bh);\n\tset_buffer_uptodate(bh);\n\tbh->b_end_io = journal_end_buffer_io_sync;\n\n\tif (journal->j_flags & JBD2_BARRIER &&\n\t    !JBD2_HAS_INCOMPAT_FEATURE(journal,\n\t\t\t\t       JBD2_FEATURE_INCOMPAT_ASYNC_COMMIT))\n\t\tret = submit_bh(WRITE_SYNC | WRITE_FLUSH_FUA, bh);\n\telse\n\t\tret = submit_bh(WRITE_SYNC, bh);\n\n\t*cbh = bh;\n\treturn ret;\n}",
    "includes": [
      "#include <trace/events/jbd2.h>",
      "#include <linux/bitops.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/bio.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/crc32.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mm.h>",
      "#include <linux/slab.h>",
      "#include <linux/errno.h>",
      "#include <linux/jbd2.h>",
      "#include <linux/fs.h>",
      "#include <linux/time.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "submit_bh",
          "args": [
            "WRITE_SYNC",
            "bh"
          ],
          "line": 164
        },
        "resolved": true,
        "details": {
          "function_name": "submit_bh",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "3055-3058",
          "snippet": "int submit_bh(int rw, struct buffer_head *bh)\n{\n\treturn _submit_bh(rw, bh, 0);\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nint submit_bh(int rw, struct buffer_head *bh)\n{\n\treturn _submit_bh(rw, bh, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "JBD2_HAS_INCOMPAT_FEATURE",
          "args": [
            "journal",
            "JBD2_FEATURE_INCOMPAT_ASYNC_COMMIT"
          ],
          "line": 160
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_buffer_uptodate",
          "args": [
            "bh"
          ],
          "line": 156
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_set_buffer_uptodate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/disk-io.c",
          "lines": "3758-3761",
          "snippet": "int btrfs_set_buffer_uptodate(struct extent_buffer *buf)\n{\n\treturn set_extent_buffer_uptodate(buf);\n}",
          "includes": [
            "#include <asm/cpufeature.h>",
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"raid56.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/uuid.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/migrate.h>",
            "#include <linux/slab.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/writeback.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/swap.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/cpufeature.h>\n#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"raid56.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <asm/unaligned.h>\n#include <linux/semaphore.h>\n#include <linux/uuid.h>\n#include <linux/ratelimit.h>\n#include <linux/migrate.h>\n#include <linux/slab.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/radix-tree.h>\n#include <linux/swap.h>\n#include <linux/scatterlist.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nint btrfs_set_buffer_uptodate(struct extent_buffer *buf)\n{\n\treturn set_extent_buffer_uptodate(buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "clear_buffer_dirty",
          "args": [
            "bh"
          ],
          "line": 155
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lock_buffer",
          "args": [
            "bh"
          ],
          "line": 154
        },
        "resolved": true,
        "details": {
          "function_name": "unlock_buffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "70-75",
          "snippet": "void unlock_buffer(struct buffer_head *bh)\n{\n\tclear_bit_unlock(BH_Lock, &bh->b_state);\n\tsmp_mb__after_atomic();\n\twake_up_bit(&bh->b_state, BH_Lock);\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid unlock_buffer(struct buffer_head *bh)\n{\n\tclear_bit_unlock(BH_Lock, &bh->b_state);\n\tsmp_mb__after_atomic();\n\twake_up_bit(&bh->b_state, BH_Lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUFFER_TRACE",
          "args": [
            "bh",
            "\"submit commit block\""
          ],
          "line": 153
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "jbd2_commit_block_csum_set",
          "args": [
            "journal",
            "bh"
          ],
          "line": 151
        },
        "resolved": true,
        "details": {
          "function_name": "jbd2_commit_block_csum_set",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd2/commit.c",
          "lines": "95-109",
          "snippet": "static void jbd2_commit_block_csum_set(journal_t *j, struct buffer_head *bh)\n{\n\tstruct commit_header *h;\n\t__u32 csum;\n\n\tif (!jbd2_journal_has_csum_v2or3(j))\n\t\treturn;\n\n\th = (struct commit_header *)(bh->b_data);\n\th->h_chksum_type = 0;\n\th->h_chksum_size = 0;\n\th->h_chksum[0] = 0;\n\tcsum = jbd2_chksum(j, j->j_csum_seed, bh->b_data, j->j_blocksize);\n\th->h_chksum[0] = cpu_to_be32(csum);\n}",
          "includes": [
            "#include <trace/events/jbd2.h>",
            "#include <linux/bitops.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/bio.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/crc32.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/jbd2.h>\n#include <linux/bitops.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include <linux/backing-dev.h>\n#include <linux/writeback.h>\n#include <linux/crc32.h>\n#include <linux/jiffies.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n\nstatic void jbd2_commit_block_csum_set(journal_t *j, struct buffer_head *bh)\n{\n\tstruct commit_header *h;\n\t__u32 csum;\n\n\tif (!jbd2_journal_has_csum_v2or3(j))\n\t\treturn;\n\n\th = (struct commit_header *)(bh->b_data);\n\th->h_chksum_type = 0;\n\th->h_chksum_size = 0;\n\th->h_chksum[0] = 0;\n\tcsum = jbd2_chksum(j, j->j_csum_seed, bh->b_data, j->j_blocksize);\n\th->h_chksum[0] = cpu_to_be32(csum);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "crc32_sum"
          ],
          "line": 149
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "JBD2_HAS_COMPAT_FEATURE",
          "args": [
            "journal",
            "JBD2_FEATURE_COMPAT_CHECKSUM"
          ],
          "line": 145
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "now.tv_nsec"
          ],
          "line": 143
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be64",
          "args": [
            "now.tv_sec"
          ],
          "line": 142
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "commit_transaction->t_tid"
          ],
          "line": 141
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "JBD2_COMMIT_BLOCK"
          ],
          "line": 140
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "JBD2_MAGIC_NUMBER"
          ],
          "line": 139
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "jbd2_journal_get_descriptor_buffer",
          "args": [
            "journal"
          ],
          "line": 134
        },
        "resolved": true,
        "details": {
          "function_name": "jbd2_journal_get_descriptor_buffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd2/journal.c",
          "lines": "817-837",
          "snippet": "struct buffer_head *jbd2_journal_get_descriptor_buffer(journal_t *journal)\n{\n\tstruct buffer_head *bh;\n\tunsigned long long blocknr;\n\tint err;\n\n\terr = jbd2_journal_next_log_block(journal, &blocknr);\n\n\tif (err)\n\t\treturn NULL;\n\n\tbh = __getblk(journal->j_dev, blocknr, journal->j_blocksize);\n\tif (!bh)\n\t\treturn NULL;\n\tlock_buffer(bh);\n\tmemset(bh->b_data, 0, journal->j_blocksize);\n\tset_buffer_uptodate(bh);\n\tunlock_buffer(bh);\n\tBUFFER_TRACE(bh, \"return this buffer\");\n\treturn bh;\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <asm/uaccess.h>",
            "#include <trace/events/jbd2.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/bitops.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/log2.h>",
            "#include <linux/hash.h>",
            "#include <linux/math64.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/poison.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <trace/events/jbd2.h>\n#include <linux/ratelimit.h>\n#include <linux/bitops.h>\n#include <linux/backing-dev.h>\n#include <linux/vmalloc.h>\n#include <linux/log2.h>\n#include <linux/hash.h>\n#include <linux/math64.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/poison.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/freezer.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nstruct buffer_head *jbd2_journal_get_descriptor_buffer(journal_t *journal)\n{\n\tstruct buffer_head *bh;\n\tunsigned long long blocknr;\n\tint err;\n\n\terr = jbd2_journal_next_log_block(journal, &blocknr);\n\n\tif (err)\n\t\treturn NULL;\n\n\tbh = __getblk(journal->j_dev, blocknr, journal->j_blocksize);\n\tif (!bh)\n\t\treturn NULL;\n\tlock_buffer(bh);\n\tmemset(bh->b_data, 0, journal->j_blocksize);\n\tset_buffer_uptodate(bh);\n\tunlock_buffer(bh);\n\tBUFFER_TRACE(bh, \"return this buffer\");\n\treturn bh;\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_journal_aborted",
          "args": [
            "journal"
          ],
          "line": 131
        },
        "resolved": true,
        "details": {
          "function_name": "__reiserfs_is_journal_aborted",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/reiserfs.h",
          "lines": "760-764",
          "snippet": "static inline int __reiserfs_is_journal_aborted(struct reiserfs_journal\n\t\t\t\t\t\t*journal)\n{\n\treturn test_bit(J_ABORTED, &journal->j_state);\n}",
          "includes": [
            "#include <linux/buffer_head.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/bitops.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/slab.h>",
            "#include <linux/reiserfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/buffer_head.h>\n#include <linux/proc_fs.h>\n#include <linux/bitops.h>\n#include <asm/unaligned.h>\n#include <linux/workqueue.h>\n#include <linux/bug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/slab.h>\n#include <linux/reiserfs_fs.h>\n\nstatic inline int __reiserfs_is_journal_aborted(struct reiserfs_journal\n\t\t\t\t\t\t*journal)\n{\n\treturn test_bit(J_ABORTED, &journal->j_state);\n}"
        }
      },
      {
        "call_info": {
          "callee": "current_kernel_time",
          "args": [],
          "line": 127
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/jbd2.h>\n#include <linux/bitops.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include <linux/backing-dev.h>\n#include <linux/writeback.h>\n#include <linux/crc32.h>\n#include <linux/jiffies.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n\nstatic int journal_submit_commit_record(journal_t *journal,\n\t\t\t\t\ttransaction_t *commit_transaction,\n\t\t\t\t\tstruct buffer_head **cbh,\n\t\t\t\t\t__u32 crc32_sum)\n{\n\tstruct commit_header *tmp;\n\tstruct buffer_head *bh;\n\tint ret;\n\tstruct timespec now = current_kernel_time();\n\n\t*cbh = NULL;\n\n\tif (is_journal_aborted(journal))\n\t\treturn 0;\n\n\tbh = jbd2_journal_get_descriptor_buffer(journal);\n\tif (!bh)\n\t\treturn 1;\n\n\ttmp = (struct commit_header *)bh->b_data;\n\ttmp->h_magic = cpu_to_be32(JBD2_MAGIC_NUMBER);\n\ttmp->h_blocktype = cpu_to_be32(JBD2_COMMIT_BLOCK);\n\ttmp->h_sequence = cpu_to_be32(commit_transaction->t_tid);\n\ttmp->h_commit_sec = cpu_to_be64(now.tv_sec);\n\ttmp->h_commit_nsec = cpu_to_be32(now.tv_nsec);\n\n\tif (JBD2_HAS_COMPAT_FEATURE(journal,\n\t\t\t\t    JBD2_FEATURE_COMPAT_CHECKSUM)) {\n\t\ttmp->h_chksum_type \t= JBD2_CRC32_CHKSUM;\n\t\ttmp->h_chksum_size \t= JBD2_CRC32_CHKSUM_SIZE;\n\t\ttmp->h_chksum[0] \t= cpu_to_be32(crc32_sum);\n\t}\n\tjbd2_commit_block_csum_set(journal, bh);\n\n\tBUFFER_TRACE(bh, \"submit commit block\");\n\tlock_buffer(bh);\n\tclear_buffer_dirty(bh);\n\tset_buffer_uptodate(bh);\n\tbh->b_end_io = journal_end_buffer_io_sync;\n\n\tif (journal->j_flags & JBD2_BARRIER &&\n\t    !JBD2_HAS_INCOMPAT_FEATURE(journal,\n\t\t\t\t       JBD2_FEATURE_INCOMPAT_ASYNC_COMMIT))\n\t\tret = submit_bh(WRITE_SYNC | WRITE_FLUSH_FUA, bh);\n\telse\n\t\tret = submit_bh(WRITE_SYNC, bh);\n\n\t*cbh = bh;\n\treturn ret;\n}"
  },
  {
    "function_name": "jbd2_commit_block_csum_set",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd2/commit.c",
    "lines": "95-109",
    "snippet": "static void jbd2_commit_block_csum_set(journal_t *j, struct buffer_head *bh)\n{\n\tstruct commit_header *h;\n\t__u32 csum;\n\n\tif (!jbd2_journal_has_csum_v2or3(j))\n\t\treturn;\n\n\th = (struct commit_header *)(bh->b_data);\n\th->h_chksum_type = 0;\n\th->h_chksum_size = 0;\n\th->h_chksum[0] = 0;\n\tcsum = jbd2_chksum(j, j->j_csum_seed, bh->b_data, j->j_blocksize);\n\th->h_chksum[0] = cpu_to_be32(csum);\n}",
    "includes": [
      "#include <trace/events/jbd2.h>",
      "#include <linux/bitops.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/bio.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/crc32.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mm.h>",
      "#include <linux/slab.h>",
      "#include <linux/errno.h>",
      "#include <linux/jbd2.h>",
      "#include <linux/fs.h>",
      "#include <linux/time.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "csum"
          ],
          "line": 108
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "jbd2_chksum",
          "args": [
            "j",
            "j->j_csum_seed",
            "bh->b_data",
            "j->j_blocksize"
          ],
          "line": 107
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "jbd2_journal_has_csum_v2or3",
          "args": [
            "j"
          ],
          "line": 100
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/jbd2.h>\n#include <linux/bitops.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include <linux/backing-dev.h>\n#include <linux/writeback.h>\n#include <linux/crc32.h>\n#include <linux/jiffies.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n\nstatic void jbd2_commit_block_csum_set(journal_t *j, struct buffer_head *bh)\n{\n\tstruct commit_header *h;\n\t__u32 csum;\n\n\tif (!jbd2_journal_has_csum_v2or3(j))\n\t\treturn;\n\n\th = (struct commit_header *)(bh->b_data);\n\th->h_chksum_type = 0;\n\th->h_chksum_size = 0;\n\th->h_chksum[0] = 0;\n\tcsum = jbd2_chksum(j, j->j_csum_seed, bh->b_data, j->j_blocksize);\n\th->h_chksum[0] = cpu_to_be32(csum);\n}"
  },
  {
    "function_name": "release_buffer_page",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd2/commit.c",
    "lines": "66-93",
    "snippet": "static void release_buffer_page(struct buffer_head *bh)\n{\n\tstruct page *page;\n\n\tif (buffer_dirty(bh))\n\t\tgoto nope;\n\tif (atomic_read(&bh->b_count) != 1)\n\t\tgoto nope;\n\tpage = bh->b_page;\n\tif (!page)\n\t\tgoto nope;\n\tif (page->mapping)\n\t\tgoto nope;\n\n\t/* OK, it's a truncated page */\n\tif (!trylock_page(page))\n\t\tgoto nope;\n\n\tpage_cache_get(page);\n\t__brelse(bh);\n\ttry_to_free_buffers(page);\n\tunlock_page(page);\n\tpage_cache_release(page);\n\treturn;\n\nnope:\n\t__brelse(bh);\n}",
    "includes": [
      "#include <trace/events/jbd2.h>",
      "#include <linux/bitops.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/bio.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/crc32.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mm.h>",
      "#include <linux/slab.h>",
      "#include <linux/errno.h>",
      "#include <linux/jbd2.h>",
      "#include <linux/fs.h>",
      "#include <linux/time.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__brelse",
          "args": [
            "bh"
          ],
          "line": 92
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "page_cache_release",
          "args": [
            "page"
          ],
          "line": 88
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlock_page",
          "args": [
            "page"
          ],
          "line": 87
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_unlock_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/aops.c",
          "lines": "1127-1148",
          "snippet": "static void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tpage_cache_release(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}",
          "includes": [
            "#include \"sysfile.h\"",
            "#include \"namei.h\"",
            "#include \"dir.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"symlink.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/swap.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfile.h\"\n#include \"namei.h\"\n#include \"dir.h\"\n#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"symlink.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/mpage.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/swap.h>\n#include <asm/byteorder.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tpage_cache_release(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}"
        }
      },
      {
        "call_info": {
          "callee": "try_to_free_buffers",
          "args": [
            "page"
          ],
          "line": 86
        },
        "resolved": true,
        "details": {
          "function_name": "try_to_free_buffers",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "3214-3260",
          "snippet": "int try_to_free_buffers(struct page *page)\n{\n\tstruct address_space * const mapping = page->mapping;\n\tstruct buffer_head *buffers_to_free = NULL;\n\tint ret = 0;\n\n\tBUG_ON(!PageLocked(page));\n\tif (PageWriteback(page))\n\t\treturn 0;\n\n\tif (mapping == NULL) {\t\t/* can this still happen? */\n\t\tret = drop_buffers(page, &buffers_to_free);\n\t\tgoto out;\n\t}\n\n\tspin_lock(&mapping->private_lock);\n\tret = drop_buffers(page, &buffers_to_free);\n\n\t/*\n\t * If the filesystem writes its buffers by hand (eg ext3)\n\t * then we can have clean buffers against a dirty page.  We\n\t * clean the page here; otherwise the VM will never notice\n\t * that the filesystem did any IO at all.\n\t *\n\t * Also, during truncate, discard_buffer will have marked all\n\t * the page's buffers clean.  We discover that here and clean\n\t * the page also.\n\t *\n\t * private_lock must be held over this entire operation in order\n\t * to synchronise against __set_page_dirty_buffers and prevent the\n\t * dirty bit from being lost.\n\t */\n\tif (ret)\n\t\tcancel_dirty_page(page, PAGE_CACHE_SIZE);\n\tspin_unlock(&mapping->private_lock);\nout:\n\tif (buffers_to_free) {\n\t\tstruct buffer_head *bh = buffers_to_free;\n\n\t\tdo {\n\t\t\tstruct buffer_head *next = bh->b_this_page;\n\t\t\tfree_buffer_head(bh);\n\t\t\tbh = next;\n\t\t} while (bh != buffers_to_free);\n\t}\n\treturn ret;\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nint try_to_free_buffers(struct page *page)\n{\n\tstruct address_space * const mapping = page->mapping;\n\tstruct buffer_head *buffers_to_free = NULL;\n\tint ret = 0;\n\n\tBUG_ON(!PageLocked(page));\n\tif (PageWriteback(page))\n\t\treturn 0;\n\n\tif (mapping == NULL) {\t\t/* can this still happen? */\n\t\tret = drop_buffers(page, &buffers_to_free);\n\t\tgoto out;\n\t}\n\n\tspin_lock(&mapping->private_lock);\n\tret = drop_buffers(page, &buffers_to_free);\n\n\t/*\n\t * If the filesystem writes its buffers by hand (eg ext3)\n\t * then we can have clean buffers against a dirty page.  We\n\t * clean the page here; otherwise the VM will never notice\n\t * that the filesystem did any IO at all.\n\t *\n\t * Also, during truncate, discard_buffer will have marked all\n\t * the page's buffers clean.  We discover that here and clean\n\t * the page also.\n\t *\n\t * private_lock must be held over this entire operation in order\n\t * to synchronise against __set_page_dirty_buffers and prevent the\n\t * dirty bit from being lost.\n\t */\n\tif (ret)\n\t\tcancel_dirty_page(page, PAGE_CACHE_SIZE);\n\tspin_unlock(&mapping->private_lock);\nout:\n\tif (buffers_to_free) {\n\t\tstruct buffer_head *bh = buffers_to_free;\n\n\t\tdo {\n\t\t\tstruct buffer_head *next = bh->b_this_page;\n\t\t\tfree_buffer_head(bh);\n\t\t\tbh = next;\n\t\t} while (bh != buffers_to_free);\n\t}\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "page_cache_get",
          "args": [
            "page"
          ],
          "line": 84
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trylock_page",
          "args": [
            "page"
          ],
          "line": 81
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&bh->b_count"
          ],
          "line": 72
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "buffer_dirty",
          "args": [
            "bh"
          ],
          "line": 70
        },
        "resolved": true,
        "details": {
          "function_name": "mark_buffer_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1141-1167",
          "snippet": "void mark_buffer_dirty(struct buffer_head *bh)\n{\n\tWARN_ON_ONCE(!buffer_uptodate(bh));\n\n\ttrace_block_dirty_buffer(bh);\n\n\t/*\n\t * Very *carefully* optimize the it-is-already-dirty case.\n\t *\n\t * Don't let the final \"is it dirty\" escape to before we\n\t * perhaps modified the buffer.\n\t */\n\tif (buffer_dirty(bh)) {\n\t\tsmp_mb();\n\t\tif (buffer_dirty(bh))\n\t\t\treturn;\n\t}\n\n\tif (!test_set_buffer_dirty(bh)) {\n\t\tstruct page *page = bh->b_page;\n\t\tif (!TestSetPageDirty(page)) {\n\t\t\tstruct address_space *mapping = page_mapping(page);\n\t\t\tif (mapping)\n\t\t\t\t__set_page_dirty(page, mapping, 0);\n\t\t}\n\t}\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid mark_buffer_dirty(struct buffer_head *bh)\n{\n\tWARN_ON_ONCE(!buffer_uptodate(bh));\n\n\ttrace_block_dirty_buffer(bh);\n\n\t/*\n\t * Very *carefully* optimize the it-is-already-dirty case.\n\t *\n\t * Don't let the final \"is it dirty\" escape to before we\n\t * perhaps modified the buffer.\n\t */\n\tif (buffer_dirty(bh)) {\n\t\tsmp_mb();\n\t\tif (buffer_dirty(bh))\n\t\t\treturn;\n\t}\n\n\tif (!test_set_buffer_dirty(bh)) {\n\t\tstruct page *page = bh->b_page;\n\t\tif (!TestSetPageDirty(page)) {\n\t\t\tstruct address_space *mapping = page_mapping(page);\n\t\t\tif (mapping)\n\t\t\t\t__set_page_dirty(page, mapping, 0);\n\t\t}\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/jbd2.h>\n#include <linux/bitops.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include <linux/backing-dev.h>\n#include <linux/writeback.h>\n#include <linux/crc32.h>\n#include <linux/jiffies.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n\nstatic void release_buffer_page(struct buffer_head *bh)\n{\n\tstruct page *page;\n\n\tif (buffer_dirty(bh))\n\t\tgoto nope;\n\tif (atomic_read(&bh->b_count) != 1)\n\t\tgoto nope;\n\tpage = bh->b_page;\n\tif (!page)\n\t\tgoto nope;\n\tif (page->mapping)\n\t\tgoto nope;\n\n\t/* OK, it's a truncated page */\n\tif (!trylock_page(page))\n\t\tgoto nope;\n\n\tpage_cache_get(page);\n\t__brelse(bh);\n\ttry_to_free_buffers(page);\n\tunlock_page(page);\n\tpage_cache_release(page);\n\treturn;\n\nnope:\n\t__brelse(bh);\n}"
  },
  {
    "function_name": "journal_end_buffer_io_sync",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd2/commit.c",
    "lines": "35-50",
    "snippet": "static void journal_end_buffer_io_sync(struct buffer_head *bh, int uptodate)\n{\n\tstruct buffer_head *orig_bh = bh->b_private;\n\n\tBUFFER_TRACE(bh, \"\");\n\tif (uptodate)\n\t\tset_buffer_uptodate(bh);\n\telse\n\t\tclear_buffer_uptodate(bh);\n\tif (orig_bh) {\n\t\tclear_bit_unlock(BH_Shadow, &orig_bh->b_state);\n\t\tsmp_mb__after_atomic();\n\t\twake_up_bit(&orig_bh->b_state, BH_Shadow);\n\t}\n\tunlock_buffer(bh);\n}",
    "includes": [
      "#include <trace/events/jbd2.h>",
      "#include <linux/bitops.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/bio.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/crc32.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mm.h>",
      "#include <linux/slab.h>",
      "#include <linux/errno.h>",
      "#include <linux/jbd2.h>",
      "#include <linux/fs.h>",
      "#include <linux/time.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "unlock_buffer",
          "args": [
            "bh"
          ],
          "line": 49
        },
        "resolved": true,
        "details": {
          "function_name": "unlock_buffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "70-75",
          "snippet": "void unlock_buffer(struct buffer_head *bh)\n{\n\tclear_bit_unlock(BH_Lock, &bh->b_state);\n\tsmp_mb__after_atomic();\n\twake_up_bit(&bh->b_state, BH_Lock);\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid unlock_buffer(struct buffer_head *bh)\n{\n\tclear_bit_unlock(BH_Lock, &bh->b_state);\n\tsmp_mb__after_atomic();\n\twake_up_bit(&bh->b_state, BH_Lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "wake_up_bit",
          "args": [
            "&orig_bh->b_state",
            "BH_Shadow"
          ],
          "line": 47
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smp_mb__after_atomic",
          "args": [],
          "line": 46
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clear_bit_unlock",
          "args": [
            "BH_Shadow",
            "&orig_bh->b_state"
          ],
          "line": 45
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clear_buffer_uptodate",
          "args": [
            "bh"
          ],
          "line": 43
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_buffer_uptodate",
          "args": [
            "bh"
          ],
          "line": 41
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_set_buffer_uptodate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/disk-io.c",
          "lines": "3758-3761",
          "snippet": "int btrfs_set_buffer_uptodate(struct extent_buffer *buf)\n{\n\treturn set_extent_buffer_uptodate(buf);\n}",
          "includes": [
            "#include <asm/cpufeature.h>",
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"raid56.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/uuid.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/migrate.h>",
            "#include <linux/slab.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/writeback.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/swap.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/cpufeature.h>\n#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"raid56.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <asm/unaligned.h>\n#include <linux/semaphore.h>\n#include <linux/uuid.h>\n#include <linux/ratelimit.h>\n#include <linux/migrate.h>\n#include <linux/slab.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/radix-tree.h>\n#include <linux/swap.h>\n#include <linux/scatterlist.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nint btrfs_set_buffer_uptodate(struct extent_buffer *buf)\n{\n\treturn set_extent_buffer_uptodate(buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUFFER_TRACE",
          "args": [
            "bh",
            "\"\""
          ],
          "line": 39
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/jbd2.h>\n#include <linux/bitops.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include <linux/backing-dev.h>\n#include <linux/writeback.h>\n#include <linux/crc32.h>\n#include <linux/jiffies.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n\nstatic void journal_end_buffer_io_sync(struct buffer_head *bh, int uptodate)\n{\n\tstruct buffer_head *orig_bh = bh->b_private;\n\n\tBUFFER_TRACE(bh, \"\");\n\tif (uptodate)\n\t\tset_buffer_uptodate(bh);\n\telse\n\t\tclear_buffer_uptodate(bh);\n\tif (orig_bh) {\n\t\tclear_bit_unlock(BH_Shadow, &orig_bh->b_state);\n\t\tsmp_mb__after_atomic();\n\t\twake_up_bit(&orig_bh->b_state, BH_Shadow);\n\t}\n\tunlock_buffer(bh);\n}"
  }
]