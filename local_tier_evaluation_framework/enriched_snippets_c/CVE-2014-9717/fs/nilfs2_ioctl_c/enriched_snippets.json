[
  {
    "function_name": "nilfs_compat_ioctl",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/ioctl.c",
    "lines": "1347-1378",
    "snippet": "long nilfs_compat_ioctl(struct file *filp, unsigned int cmd, unsigned long arg)\n{\n\tswitch (cmd) {\n\tcase FS_IOC32_GETFLAGS:\n\t\tcmd = FS_IOC_GETFLAGS;\n\t\tbreak;\n\tcase FS_IOC32_SETFLAGS:\n\t\tcmd = FS_IOC_SETFLAGS;\n\t\tbreak;\n\tcase FS_IOC32_GETVERSION:\n\t\tcmd = FS_IOC_GETVERSION;\n\t\tbreak;\n\tcase NILFS_IOCTL_CHANGE_CPMODE:\n\tcase NILFS_IOCTL_DELETE_CHECKPOINT:\n\tcase NILFS_IOCTL_GET_CPINFO:\n\tcase NILFS_IOCTL_GET_CPSTAT:\n\tcase NILFS_IOCTL_GET_SUINFO:\n\tcase NILFS_IOCTL_SET_SUINFO:\n\tcase NILFS_IOCTL_GET_SUSTAT:\n\tcase NILFS_IOCTL_GET_VINFO:\n\tcase NILFS_IOCTL_GET_BDESCS:\n\tcase NILFS_IOCTL_CLEAN_SEGMENTS:\n\tcase NILFS_IOCTL_SYNC:\n\tcase NILFS_IOCTL_RESIZE:\n\tcase NILFS_IOCTL_SET_ALLOC_RANGE:\n\tcase FITRIM:\n\t\tbreak;\n\tdefault:\n\t\treturn -ENOIOCTLCMD;\n\t}\n\treturn nilfs_ioctl(filp, cmd, (unsigned long)compat_ptr(arg));\n}",
    "includes": [
      "#include \"dat.h\"",
      "#include \"sufile.h\"",
      "#include \"cpfile.h\"",
      "#include \"bmap.h\"",
      "#include \"segment.h\"",
      "#include \"nilfs.h\"",
      "#include <linux/nilfs2_fs.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/mount.h>\t/* mnt_want_write_file(), mnt_drop_write_file() */",
      "#include <linux/compat.h>\t/* compat_ptr() */",
      "#include <linux/vmalloc.h>",
      "#include <linux/uaccess.h>\t/* copy_from_user(), copy_to_user() */",
      "#include <linux/capability.h>\t/* capable() */",
      "#include <linux/slab.h>",
      "#include <linux/wait.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "nilfs_ioctl",
          "args": [
            "filp",
            "cmd",
            "(unsigned long)compat_ptr(arg)"
          ],
          "line": 1377
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_ioctl",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/ioctl.c",
          "lines": "1295-1344",
          "snippet": "long nilfs_ioctl(struct file *filp, unsigned int cmd, unsigned long arg)\n{\n\tstruct inode *inode = file_inode(filp);\n\tvoid __user *argp = (void __user *)arg;\n\n\tswitch (cmd) {\n\tcase FS_IOC_GETFLAGS:\n\t\treturn nilfs_ioctl_getflags(inode, argp);\n\tcase FS_IOC_SETFLAGS:\n\t\treturn nilfs_ioctl_setflags(inode, filp, argp);\n\tcase FS_IOC_GETVERSION:\n\t\treturn nilfs_ioctl_getversion(inode, argp);\n\tcase NILFS_IOCTL_CHANGE_CPMODE:\n\t\treturn nilfs_ioctl_change_cpmode(inode, filp, cmd, argp);\n\tcase NILFS_IOCTL_DELETE_CHECKPOINT:\n\t\treturn nilfs_ioctl_delete_checkpoint(inode, filp, cmd, argp);\n\tcase NILFS_IOCTL_GET_CPINFO:\n\t\treturn nilfs_ioctl_get_info(inode, filp, cmd, argp,\n\t\t\t\t\t    sizeof(struct nilfs_cpinfo),\n\t\t\t\t\t    nilfs_ioctl_do_get_cpinfo);\n\tcase NILFS_IOCTL_GET_CPSTAT:\n\t\treturn nilfs_ioctl_get_cpstat(inode, filp, cmd, argp);\n\tcase NILFS_IOCTL_GET_SUINFO:\n\t\treturn nilfs_ioctl_get_info(inode, filp, cmd, argp,\n\t\t\t\t\t    sizeof(struct nilfs_suinfo),\n\t\t\t\t\t    nilfs_ioctl_do_get_suinfo);\n\tcase NILFS_IOCTL_SET_SUINFO:\n\t\treturn nilfs_ioctl_set_suinfo(inode, filp, cmd, argp);\n\tcase NILFS_IOCTL_GET_SUSTAT:\n\t\treturn nilfs_ioctl_get_sustat(inode, filp, cmd, argp);\n\tcase NILFS_IOCTL_GET_VINFO:\n\t\treturn nilfs_ioctl_get_info(inode, filp, cmd, argp,\n\t\t\t\t\t    sizeof(struct nilfs_vinfo),\n\t\t\t\t\t    nilfs_ioctl_do_get_vinfo);\n\tcase NILFS_IOCTL_GET_BDESCS:\n\t\treturn nilfs_ioctl_get_bdescs(inode, filp, cmd, argp);\n\tcase NILFS_IOCTL_CLEAN_SEGMENTS:\n\t\treturn nilfs_ioctl_clean_segments(inode, filp, cmd, argp);\n\tcase NILFS_IOCTL_SYNC:\n\t\treturn nilfs_ioctl_sync(inode, filp, cmd, argp);\n\tcase NILFS_IOCTL_RESIZE:\n\t\treturn nilfs_ioctl_resize(inode, filp, argp);\n\tcase NILFS_IOCTL_SET_ALLOC_RANGE:\n\t\treturn nilfs_ioctl_set_alloc_range(inode, argp);\n\tcase FITRIM:\n\t\treturn nilfs_ioctl_trim_fs(inode, argp);\n\tdefault:\n\t\treturn -ENOTTY;\n\t}\n}",
          "includes": [
            "#include \"dat.h\"",
            "#include \"sufile.h\"",
            "#include \"cpfile.h\"",
            "#include \"bmap.h\"",
            "#include \"segment.h\"",
            "#include \"nilfs.h\"",
            "#include <linux/nilfs2_fs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/mount.h>\t/* mnt_want_write_file(), mnt_drop_write_file() */",
            "#include <linux/compat.h>\t/* compat_ptr() */",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>\t/* copy_from_user(), copy_to_user() */",
            "#include <linux/capability.h>\t/* capable() */",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"dat.h\"\n#include \"sufile.h\"\n#include \"cpfile.h\"\n#include \"bmap.h\"\n#include \"segment.h\"\n#include \"nilfs.h\"\n#include <linux/nilfs2_fs.h>\n#include <linux/buffer_head.h>\n#include <linux/mount.h>\t/* mnt_want_write_file(), mnt_drop_write_file() */\n#include <linux/compat.h>\t/* compat_ptr() */\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\t/* copy_from_user(), copy_to_user() */\n#include <linux/capability.h>\t/* capable() */\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/fs.h>\n\nlong nilfs_ioctl(struct file *filp, unsigned int cmd, unsigned long arg)\n{\n\tstruct inode *inode = file_inode(filp);\n\tvoid __user *argp = (void __user *)arg;\n\n\tswitch (cmd) {\n\tcase FS_IOC_GETFLAGS:\n\t\treturn nilfs_ioctl_getflags(inode, argp);\n\tcase FS_IOC_SETFLAGS:\n\t\treturn nilfs_ioctl_setflags(inode, filp, argp);\n\tcase FS_IOC_GETVERSION:\n\t\treturn nilfs_ioctl_getversion(inode, argp);\n\tcase NILFS_IOCTL_CHANGE_CPMODE:\n\t\treturn nilfs_ioctl_change_cpmode(inode, filp, cmd, argp);\n\tcase NILFS_IOCTL_DELETE_CHECKPOINT:\n\t\treturn nilfs_ioctl_delete_checkpoint(inode, filp, cmd, argp);\n\tcase NILFS_IOCTL_GET_CPINFO:\n\t\treturn nilfs_ioctl_get_info(inode, filp, cmd, argp,\n\t\t\t\t\t    sizeof(struct nilfs_cpinfo),\n\t\t\t\t\t    nilfs_ioctl_do_get_cpinfo);\n\tcase NILFS_IOCTL_GET_CPSTAT:\n\t\treturn nilfs_ioctl_get_cpstat(inode, filp, cmd, argp);\n\tcase NILFS_IOCTL_GET_SUINFO:\n\t\treturn nilfs_ioctl_get_info(inode, filp, cmd, argp,\n\t\t\t\t\t    sizeof(struct nilfs_suinfo),\n\t\t\t\t\t    nilfs_ioctl_do_get_suinfo);\n\tcase NILFS_IOCTL_SET_SUINFO:\n\t\treturn nilfs_ioctl_set_suinfo(inode, filp, cmd, argp);\n\tcase NILFS_IOCTL_GET_SUSTAT:\n\t\treturn nilfs_ioctl_get_sustat(inode, filp, cmd, argp);\n\tcase NILFS_IOCTL_GET_VINFO:\n\t\treturn nilfs_ioctl_get_info(inode, filp, cmd, argp,\n\t\t\t\t\t    sizeof(struct nilfs_vinfo),\n\t\t\t\t\t    nilfs_ioctl_do_get_vinfo);\n\tcase NILFS_IOCTL_GET_BDESCS:\n\t\treturn nilfs_ioctl_get_bdescs(inode, filp, cmd, argp);\n\tcase NILFS_IOCTL_CLEAN_SEGMENTS:\n\t\treturn nilfs_ioctl_clean_segments(inode, filp, cmd, argp);\n\tcase NILFS_IOCTL_SYNC:\n\t\treturn nilfs_ioctl_sync(inode, filp, cmd, argp);\n\tcase NILFS_IOCTL_RESIZE:\n\t\treturn nilfs_ioctl_resize(inode, filp, argp);\n\tcase NILFS_IOCTL_SET_ALLOC_RANGE:\n\t\treturn nilfs_ioctl_set_alloc_range(inode, argp);\n\tcase FITRIM:\n\t\treturn nilfs_ioctl_trim_fs(inode, argp);\n\tdefault:\n\t\treturn -ENOTTY;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "compat_ptr",
          "args": [
            "arg"
          ],
          "line": 1377
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"dat.h\"\n#include \"sufile.h\"\n#include \"cpfile.h\"\n#include \"bmap.h\"\n#include \"segment.h\"\n#include \"nilfs.h\"\n#include <linux/nilfs2_fs.h>\n#include <linux/buffer_head.h>\n#include <linux/mount.h>\t/* mnt_want_write_file(), mnt_drop_write_file() */\n#include <linux/compat.h>\t/* compat_ptr() */\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\t/* copy_from_user(), copy_to_user() */\n#include <linux/capability.h>\t/* capable() */\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/fs.h>\n\nlong nilfs_compat_ioctl(struct file *filp, unsigned int cmd, unsigned long arg)\n{\n\tswitch (cmd) {\n\tcase FS_IOC32_GETFLAGS:\n\t\tcmd = FS_IOC_GETFLAGS;\n\t\tbreak;\n\tcase FS_IOC32_SETFLAGS:\n\t\tcmd = FS_IOC_SETFLAGS;\n\t\tbreak;\n\tcase FS_IOC32_GETVERSION:\n\t\tcmd = FS_IOC_GETVERSION;\n\t\tbreak;\n\tcase NILFS_IOCTL_CHANGE_CPMODE:\n\tcase NILFS_IOCTL_DELETE_CHECKPOINT:\n\tcase NILFS_IOCTL_GET_CPINFO:\n\tcase NILFS_IOCTL_GET_CPSTAT:\n\tcase NILFS_IOCTL_GET_SUINFO:\n\tcase NILFS_IOCTL_SET_SUINFO:\n\tcase NILFS_IOCTL_GET_SUSTAT:\n\tcase NILFS_IOCTL_GET_VINFO:\n\tcase NILFS_IOCTL_GET_BDESCS:\n\tcase NILFS_IOCTL_CLEAN_SEGMENTS:\n\tcase NILFS_IOCTL_SYNC:\n\tcase NILFS_IOCTL_RESIZE:\n\tcase NILFS_IOCTL_SET_ALLOC_RANGE:\n\tcase FITRIM:\n\t\tbreak;\n\tdefault:\n\t\treturn -ENOIOCTLCMD;\n\t}\n\treturn nilfs_ioctl(filp, cmd, (unsigned long)compat_ptr(arg));\n}"
  },
  {
    "function_name": "nilfs_ioctl",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/ioctl.c",
    "lines": "1295-1344",
    "snippet": "long nilfs_ioctl(struct file *filp, unsigned int cmd, unsigned long arg)\n{\n\tstruct inode *inode = file_inode(filp);\n\tvoid __user *argp = (void __user *)arg;\n\n\tswitch (cmd) {\n\tcase FS_IOC_GETFLAGS:\n\t\treturn nilfs_ioctl_getflags(inode, argp);\n\tcase FS_IOC_SETFLAGS:\n\t\treturn nilfs_ioctl_setflags(inode, filp, argp);\n\tcase FS_IOC_GETVERSION:\n\t\treturn nilfs_ioctl_getversion(inode, argp);\n\tcase NILFS_IOCTL_CHANGE_CPMODE:\n\t\treturn nilfs_ioctl_change_cpmode(inode, filp, cmd, argp);\n\tcase NILFS_IOCTL_DELETE_CHECKPOINT:\n\t\treturn nilfs_ioctl_delete_checkpoint(inode, filp, cmd, argp);\n\tcase NILFS_IOCTL_GET_CPINFO:\n\t\treturn nilfs_ioctl_get_info(inode, filp, cmd, argp,\n\t\t\t\t\t    sizeof(struct nilfs_cpinfo),\n\t\t\t\t\t    nilfs_ioctl_do_get_cpinfo);\n\tcase NILFS_IOCTL_GET_CPSTAT:\n\t\treturn nilfs_ioctl_get_cpstat(inode, filp, cmd, argp);\n\tcase NILFS_IOCTL_GET_SUINFO:\n\t\treturn nilfs_ioctl_get_info(inode, filp, cmd, argp,\n\t\t\t\t\t    sizeof(struct nilfs_suinfo),\n\t\t\t\t\t    nilfs_ioctl_do_get_suinfo);\n\tcase NILFS_IOCTL_SET_SUINFO:\n\t\treturn nilfs_ioctl_set_suinfo(inode, filp, cmd, argp);\n\tcase NILFS_IOCTL_GET_SUSTAT:\n\t\treturn nilfs_ioctl_get_sustat(inode, filp, cmd, argp);\n\tcase NILFS_IOCTL_GET_VINFO:\n\t\treturn nilfs_ioctl_get_info(inode, filp, cmd, argp,\n\t\t\t\t\t    sizeof(struct nilfs_vinfo),\n\t\t\t\t\t    nilfs_ioctl_do_get_vinfo);\n\tcase NILFS_IOCTL_GET_BDESCS:\n\t\treturn nilfs_ioctl_get_bdescs(inode, filp, cmd, argp);\n\tcase NILFS_IOCTL_CLEAN_SEGMENTS:\n\t\treturn nilfs_ioctl_clean_segments(inode, filp, cmd, argp);\n\tcase NILFS_IOCTL_SYNC:\n\t\treturn nilfs_ioctl_sync(inode, filp, cmd, argp);\n\tcase NILFS_IOCTL_RESIZE:\n\t\treturn nilfs_ioctl_resize(inode, filp, argp);\n\tcase NILFS_IOCTL_SET_ALLOC_RANGE:\n\t\treturn nilfs_ioctl_set_alloc_range(inode, argp);\n\tcase FITRIM:\n\t\treturn nilfs_ioctl_trim_fs(inode, argp);\n\tdefault:\n\t\treturn -ENOTTY;\n\t}\n}",
    "includes": [
      "#include \"dat.h\"",
      "#include \"sufile.h\"",
      "#include \"cpfile.h\"",
      "#include \"bmap.h\"",
      "#include \"segment.h\"",
      "#include \"nilfs.h\"",
      "#include <linux/nilfs2_fs.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/mount.h>\t/* mnt_want_write_file(), mnt_drop_write_file() */",
      "#include <linux/compat.h>\t/* compat_ptr() */",
      "#include <linux/vmalloc.h>",
      "#include <linux/uaccess.h>\t/* copy_from_user(), copy_to_user() */",
      "#include <linux/capability.h>\t/* capable() */",
      "#include <linux/slab.h>",
      "#include <linux/wait.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "nilfs_ioctl_trim_fs",
          "args": [
            "inode",
            "argp"
          ],
          "line": 1340
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_ioctl_trim_fs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/ioctl.c",
          "lines": "1083-1112",
          "snippet": "static int nilfs_ioctl_trim_fs(struct inode *inode, void __user *argp)\n{\n\tstruct the_nilfs *nilfs = inode->i_sb->s_fs_info;\n\tstruct request_queue *q = bdev_get_queue(nilfs->ns_bdev);\n\tstruct fstrim_range range;\n\tint ret;\n\n\tif (!capable(CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\n\tif (!blk_queue_discard(q))\n\t\treturn -EOPNOTSUPP;\n\n\tif (copy_from_user(&range, argp, sizeof(range)))\n\t\treturn -EFAULT;\n\n\trange.minlen = max_t(u64, range.minlen, q->limits.discard_granularity);\n\n\tdown_read(&nilfs->ns_segctor_sem);\n\tret = nilfs_sufile_trim_fs(nilfs->ns_sufile, &range);\n\tup_read(&nilfs->ns_segctor_sem);\n\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (copy_to_user(argp, &range, sizeof(range)))\n\t\treturn -EFAULT;\n\n\treturn 0;\n}",
          "includes": [
            "#include \"dat.h\"",
            "#include \"sufile.h\"",
            "#include \"cpfile.h\"",
            "#include \"bmap.h\"",
            "#include \"segment.h\"",
            "#include \"nilfs.h\"",
            "#include <linux/nilfs2_fs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/mount.h>\t/* mnt_want_write_file(), mnt_drop_write_file() */",
            "#include <linux/compat.h>\t/* compat_ptr() */",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>\t/* copy_from_user(), copy_to_user() */",
            "#include <linux/capability.h>\t/* capable() */",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"dat.h\"\n#include \"sufile.h\"\n#include \"cpfile.h\"\n#include \"bmap.h\"\n#include \"segment.h\"\n#include \"nilfs.h\"\n#include <linux/nilfs2_fs.h>\n#include <linux/buffer_head.h>\n#include <linux/mount.h>\t/* mnt_want_write_file(), mnt_drop_write_file() */\n#include <linux/compat.h>\t/* compat_ptr() */\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\t/* copy_from_user(), copy_to_user() */\n#include <linux/capability.h>\t/* capable() */\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/fs.h>\n\nstatic int nilfs_ioctl_trim_fs(struct inode *inode, void __user *argp)\n{\n\tstruct the_nilfs *nilfs = inode->i_sb->s_fs_info;\n\tstruct request_queue *q = bdev_get_queue(nilfs->ns_bdev);\n\tstruct fstrim_range range;\n\tint ret;\n\n\tif (!capable(CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\n\tif (!blk_queue_discard(q))\n\t\treturn -EOPNOTSUPP;\n\n\tif (copy_from_user(&range, argp, sizeof(range)))\n\t\treturn -EFAULT;\n\n\trange.minlen = max_t(u64, range.minlen, q->limits.discard_granularity);\n\n\tdown_read(&nilfs->ns_segctor_sem);\n\tret = nilfs_sufile_trim_fs(nilfs->ns_sufile, &range);\n\tup_read(&nilfs->ns_segctor_sem);\n\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (copy_to_user(argp, &range, sizeof(range)))\n\t\treturn -EFAULT;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nilfs_ioctl_set_alloc_range",
          "args": [
            "inode",
            "argp"
          ],
          "line": 1338
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_ioctl_set_alloc_range",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/ioctl.c",
          "lines": "1125-1155",
          "snippet": "static int nilfs_ioctl_set_alloc_range(struct inode *inode, void __user *argp)\n{\n\tstruct the_nilfs *nilfs = inode->i_sb->s_fs_info;\n\t__u64 range[2];\n\t__u64 minseg, maxseg;\n\tunsigned long segbytes;\n\tint ret = -EPERM;\n\n\tif (!capable(CAP_SYS_ADMIN))\n\t\tgoto out;\n\n\tret = -EFAULT;\n\tif (copy_from_user(range, argp, sizeof(__u64[2])))\n\t\tgoto out;\n\n\tret = -ERANGE;\n\tif (range[1] > i_size_read(inode->i_sb->s_bdev->bd_inode))\n\t\tgoto out;\n\n\tsegbytes = nilfs->ns_blocks_per_segment * nilfs->ns_blocksize;\n\n\tminseg = range[0] + segbytes - 1;\n\tdo_div(minseg, segbytes);\n\tmaxseg = NILFS_SB2_OFFSET_BYTES(range[1]);\n\tdo_div(maxseg, segbytes);\n\tmaxseg--;\n\n\tret = nilfs_sufile_set_alloc_range(nilfs->ns_sufile, minseg, maxseg);\nout:\n\treturn ret;\n}",
          "includes": [
            "#include \"dat.h\"",
            "#include \"sufile.h\"",
            "#include \"cpfile.h\"",
            "#include \"bmap.h\"",
            "#include \"segment.h\"",
            "#include \"nilfs.h\"",
            "#include <linux/nilfs2_fs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/mount.h>\t/* mnt_want_write_file(), mnt_drop_write_file() */",
            "#include <linux/compat.h>\t/* compat_ptr() */",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>\t/* copy_from_user(), copy_to_user() */",
            "#include <linux/capability.h>\t/* capable() */",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"dat.h\"\n#include \"sufile.h\"\n#include \"cpfile.h\"\n#include \"bmap.h\"\n#include \"segment.h\"\n#include \"nilfs.h\"\n#include <linux/nilfs2_fs.h>\n#include <linux/buffer_head.h>\n#include <linux/mount.h>\t/* mnt_want_write_file(), mnt_drop_write_file() */\n#include <linux/compat.h>\t/* compat_ptr() */\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\t/* copy_from_user(), copy_to_user() */\n#include <linux/capability.h>\t/* capable() */\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/fs.h>\n\nstatic int nilfs_ioctl_set_alloc_range(struct inode *inode, void __user *argp)\n{\n\tstruct the_nilfs *nilfs = inode->i_sb->s_fs_info;\n\t__u64 range[2];\n\t__u64 minseg, maxseg;\n\tunsigned long segbytes;\n\tint ret = -EPERM;\n\n\tif (!capable(CAP_SYS_ADMIN))\n\t\tgoto out;\n\n\tret = -EFAULT;\n\tif (copy_from_user(range, argp, sizeof(__u64[2])))\n\t\tgoto out;\n\n\tret = -ERANGE;\n\tif (range[1] > i_size_read(inode->i_sb->s_bdev->bd_inode))\n\t\tgoto out;\n\n\tsegbytes = nilfs->ns_blocks_per_segment * nilfs->ns_blocksize;\n\n\tminseg = range[0] + segbytes - 1;\n\tdo_div(minseg, segbytes);\n\tmaxseg = NILFS_SB2_OFFSET_BYTES(range[1]);\n\tdo_div(maxseg, segbytes);\n\tmaxseg--;\n\n\tret = nilfs_sufile_set_alloc_range(nilfs->ns_sufile, minseg, maxseg);\nout:\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nilfs_ioctl_resize",
          "args": [
            "inode",
            "filp",
            "argp"
          ],
          "line": 1336
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_ioctl_resize",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/ioctl.c",
          "lines": "1047-1070",
          "snippet": "static int nilfs_ioctl_resize(struct inode *inode, struct file *filp,\n\t\t\t      void __user *argp)\n{\n\t__u64 newsize;\n\tint ret = -EPERM;\n\n\tif (!capable(CAP_SYS_ADMIN))\n\t\tgoto out;\n\n\tret = mnt_want_write_file(filp);\n\tif (ret)\n\t\tgoto out;\n\n\tret = -EFAULT;\n\tif (copy_from_user(&newsize, argp, sizeof(newsize)))\n\t\tgoto out_drop_write;\n\n\tret = nilfs_resize_fs(inode->i_sb, newsize);\n\nout_drop_write:\n\tmnt_drop_write_file(filp);\nout:\n\treturn ret;\n}",
          "includes": [
            "#include \"dat.h\"",
            "#include \"sufile.h\"",
            "#include \"cpfile.h\"",
            "#include \"bmap.h\"",
            "#include \"segment.h\"",
            "#include \"nilfs.h\"",
            "#include <linux/nilfs2_fs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/mount.h>\t/* mnt_want_write_file(), mnt_drop_write_file() */",
            "#include <linux/compat.h>\t/* compat_ptr() */",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>\t/* copy_from_user(), copy_to_user() */",
            "#include <linux/capability.h>\t/* capable() */",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"dat.h\"\n#include \"sufile.h\"\n#include \"cpfile.h\"\n#include \"bmap.h\"\n#include \"segment.h\"\n#include \"nilfs.h\"\n#include <linux/nilfs2_fs.h>\n#include <linux/buffer_head.h>\n#include <linux/mount.h>\t/* mnt_want_write_file(), mnt_drop_write_file() */\n#include <linux/compat.h>\t/* compat_ptr() */\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\t/* copy_from_user(), copy_to_user() */\n#include <linux/capability.h>\t/* capable() */\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/fs.h>\n\nstatic int nilfs_ioctl_resize(struct inode *inode, struct file *filp,\n\t\t\t      void __user *argp)\n{\n\t__u64 newsize;\n\tint ret = -EPERM;\n\n\tif (!capable(CAP_SYS_ADMIN))\n\t\tgoto out;\n\n\tret = mnt_want_write_file(filp);\n\tif (ret)\n\t\tgoto out;\n\n\tret = -EFAULT;\n\tif (copy_from_user(&newsize, argp, sizeof(newsize)))\n\t\tgoto out_drop_write;\n\n\tret = nilfs_resize_fs(inode->i_sb, newsize);\n\nout_drop_write:\n\tmnt_drop_write_file(filp);\nout:\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nilfs_ioctl_sync",
          "args": [
            "inode",
            "filp",
            "cmd",
            "argp"
          ],
          "line": 1334
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_ioctl_sync",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/ioctl.c",
          "lines": "1013-1037",
          "snippet": "static int nilfs_ioctl_sync(struct inode *inode, struct file *filp,\n\t\t\t    unsigned int cmd, void __user *argp)\n{\n\t__u64 cno;\n\tint ret;\n\tstruct the_nilfs *nilfs;\n\n\tret = nilfs_construct_segment(inode->i_sb);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tnilfs = inode->i_sb->s_fs_info;\n\tret = nilfs_flush_device(nilfs);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (argp != NULL) {\n\t\tdown_read(&nilfs->ns_segctor_sem);\n\t\tcno = nilfs->ns_cno - 1;\n\t\tup_read(&nilfs->ns_segctor_sem);\n\t\tif (copy_to_user(argp, &cno, sizeof(cno)))\n\t\t\treturn -EFAULT;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"dat.h\"",
            "#include \"sufile.h\"",
            "#include \"cpfile.h\"",
            "#include \"bmap.h\"",
            "#include \"segment.h\"",
            "#include \"nilfs.h\"",
            "#include <linux/nilfs2_fs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/mount.h>\t/* mnt_want_write_file(), mnt_drop_write_file() */",
            "#include <linux/compat.h>\t/* compat_ptr() */",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>\t/* copy_from_user(), copy_to_user() */",
            "#include <linux/capability.h>\t/* capable() */",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"dat.h\"\n#include \"sufile.h\"\n#include \"cpfile.h\"\n#include \"bmap.h\"\n#include \"segment.h\"\n#include \"nilfs.h\"\n#include <linux/nilfs2_fs.h>\n#include <linux/buffer_head.h>\n#include <linux/mount.h>\t/* mnt_want_write_file(), mnt_drop_write_file() */\n#include <linux/compat.h>\t/* compat_ptr() */\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\t/* copy_from_user(), copy_to_user() */\n#include <linux/capability.h>\t/* capable() */\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/fs.h>\n\nstatic int nilfs_ioctl_sync(struct inode *inode, struct file *filp,\n\t\t\t    unsigned int cmd, void __user *argp)\n{\n\t__u64 cno;\n\tint ret;\n\tstruct the_nilfs *nilfs;\n\n\tret = nilfs_construct_segment(inode->i_sb);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tnilfs = inode->i_sb->s_fs_info;\n\tret = nilfs_flush_device(nilfs);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (argp != NULL) {\n\t\tdown_read(&nilfs->ns_segctor_sem);\n\t\tcno = nilfs->ns_cno - 1;\n\t\tup_read(&nilfs->ns_segctor_sem);\n\t\tif (copy_to_user(argp, &cno, sizeof(cno)))\n\t\t\treturn -EFAULT;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nilfs_ioctl_clean_segments",
          "args": [
            "inode",
            "filp",
            "cmd",
            "argp"
          ],
          "line": 1332
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_ioctl_clean_segments",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/ioctl.c",
          "lines": "875-984",
          "snippet": "static int nilfs_ioctl_clean_segments(struct inode *inode, struct file *filp,\n\t\t\t\t      unsigned int cmd, void __user *argp)\n{\n\tstruct nilfs_argv argv[5];\n\tstatic const size_t argsz[5] = {\n\t\tsizeof(struct nilfs_vdesc),\n\t\tsizeof(struct nilfs_period),\n\t\tsizeof(__u64),\n\t\tsizeof(struct nilfs_bdesc),\n\t\tsizeof(__u64),\n\t};\n\tvoid __user *base;\n\tvoid *kbufs[5];\n\tstruct the_nilfs *nilfs;\n\tsize_t len, nsegs;\n\tint n, ret;\n\n\tif (!capable(CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\n\tret = mnt_want_write_file(filp);\n\tif (ret)\n\t\treturn ret;\n\n\tret = -EFAULT;\n\tif (copy_from_user(argv, argp, sizeof(argv)))\n\t\tgoto out;\n\n\tret = -EINVAL;\n\tnsegs = argv[4].v_nmembs;\n\tif (argv[4].v_size != argsz[4])\n\t\tgoto out;\n\tif (nsegs > UINT_MAX / sizeof(__u64))\n\t\tgoto out;\n\n\t/*\n\t * argv[4] points to segment numbers this ioctl cleans.  We\n\t * use kmalloc() for its buffer because memory used for the\n\t * segment numbers is enough small.\n\t */\n\tkbufs[4] = memdup_user((void __user *)(unsigned long)argv[4].v_base,\n\t\t\t       nsegs * sizeof(__u64));\n\tif (IS_ERR(kbufs[4])) {\n\t\tret = PTR_ERR(kbufs[4]);\n\t\tgoto out;\n\t}\n\tnilfs = inode->i_sb->s_fs_info;\n\n\tfor (n = 0; n < 4; n++) {\n\t\tret = -EINVAL;\n\t\tif (argv[n].v_size != argsz[n])\n\t\t\tgoto out_free;\n\n\t\tif (argv[n].v_nmembs > nsegs * nilfs->ns_blocks_per_segment)\n\t\t\tgoto out_free;\n\n\t\tif (argv[n].v_nmembs >= UINT_MAX / argv[n].v_size)\n\t\t\tgoto out_free;\n\n\t\tlen = argv[n].v_size * argv[n].v_nmembs;\n\t\tbase = (void __user *)(unsigned long)argv[n].v_base;\n\t\tif (len == 0) {\n\t\t\tkbufs[n] = NULL;\n\t\t\tcontinue;\n\t\t}\n\n\t\tkbufs[n] = vmalloc(len);\n\t\tif (!kbufs[n]) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto out_free;\n\t\t}\n\t\tif (copy_from_user(kbufs[n], base, len)) {\n\t\t\tret = -EFAULT;\n\t\t\tvfree(kbufs[n]);\n\t\t\tgoto out_free;\n\t\t}\n\t}\n\n\t/*\n\t * nilfs_ioctl_move_blocks() will call nilfs_iget_for_gc(),\n\t * which will operates an inode list without blocking.\n\t * To protect the list from concurrent operations,\n\t * nilfs_ioctl_move_blocks should be atomic operation.\n\t */\n\tif (test_and_set_bit(THE_NILFS_GC_RUNNING, &nilfs->ns_flags)) {\n\t\tret = -EBUSY;\n\t\tgoto out_free;\n\t}\n\n\tret = nilfs_ioctl_move_blocks(inode->i_sb, &argv[0], kbufs[0]);\n\tif (ret < 0)\n\t\tprintk(KERN_ERR \"NILFS: GC failed during preparation: \"\n\t\t\t\"cannot read source blocks: err=%d\\n\", ret);\n\telse {\n\t\tif (nilfs_sb_need_update(nilfs))\n\t\t\tset_nilfs_discontinued(nilfs);\n\t\tret = nilfs_clean_segments(inode->i_sb, argv, kbufs);\n\t}\n\n\tnilfs_remove_all_gcinodes(nilfs);\n\tclear_nilfs_gc_running(nilfs);\n\nout_free:\n\twhile (--n >= 0)\n\t\tvfree(kbufs[n]);\n\tkfree(kbufs[4]);\nout:\n\tmnt_drop_write_file(filp);\n\treturn ret;\n}",
          "includes": [
            "#include \"dat.h\"",
            "#include \"sufile.h\"",
            "#include \"cpfile.h\"",
            "#include \"bmap.h\"",
            "#include \"segment.h\"",
            "#include \"nilfs.h\"",
            "#include <linux/nilfs2_fs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/mount.h>\t/* mnt_want_write_file(), mnt_drop_write_file() */",
            "#include <linux/compat.h>\t/* compat_ptr() */",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>\t/* copy_from_user(), copy_to_user() */",
            "#include <linux/capability.h>\t/* capable() */",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"dat.h\"\n#include \"sufile.h\"\n#include \"cpfile.h\"\n#include \"bmap.h\"\n#include \"segment.h\"\n#include \"nilfs.h\"\n#include <linux/nilfs2_fs.h>\n#include <linux/buffer_head.h>\n#include <linux/mount.h>\t/* mnt_want_write_file(), mnt_drop_write_file() */\n#include <linux/compat.h>\t/* compat_ptr() */\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\t/* copy_from_user(), copy_to_user() */\n#include <linux/capability.h>\t/* capable() */\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/fs.h>\n\nstatic int nilfs_ioctl_clean_segments(struct inode *inode, struct file *filp,\n\t\t\t\t      unsigned int cmd, void __user *argp)\n{\n\tstruct nilfs_argv argv[5];\n\tstatic const size_t argsz[5] = {\n\t\tsizeof(struct nilfs_vdesc),\n\t\tsizeof(struct nilfs_period),\n\t\tsizeof(__u64),\n\t\tsizeof(struct nilfs_bdesc),\n\t\tsizeof(__u64),\n\t};\n\tvoid __user *base;\n\tvoid *kbufs[5];\n\tstruct the_nilfs *nilfs;\n\tsize_t len, nsegs;\n\tint n, ret;\n\n\tif (!capable(CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\n\tret = mnt_want_write_file(filp);\n\tif (ret)\n\t\treturn ret;\n\n\tret = -EFAULT;\n\tif (copy_from_user(argv, argp, sizeof(argv)))\n\t\tgoto out;\n\n\tret = -EINVAL;\n\tnsegs = argv[4].v_nmembs;\n\tif (argv[4].v_size != argsz[4])\n\t\tgoto out;\n\tif (nsegs > UINT_MAX / sizeof(__u64))\n\t\tgoto out;\n\n\t/*\n\t * argv[4] points to segment numbers this ioctl cleans.  We\n\t * use kmalloc() for its buffer because memory used for the\n\t * segment numbers is enough small.\n\t */\n\tkbufs[4] = memdup_user((void __user *)(unsigned long)argv[4].v_base,\n\t\t\t       nsegs * sizeof(__u64));\n\tif (IS_ERR(kbufs[4])) {\n\t\tret = PTR_ERR(kbufs[4]);\n\t\tgoto out;\n\t}\n\tnilfs = inode->i_sb->s_fs_info;\n\n\tfor (n = 0; n < 4; n++) {\n\t\tret = -EINVAL;\n\t\tif (argv[n].v_size != argsz[n])\n\t\t\tgoto out_free;\n\n\t\tif (argv[n].v_nmembs > nsegs * nilfs->ns_blocks_per_segment)\n\t\t\tgoto out_free;\n\n\t\tif (argv[n].v_nmembs >= UINT_MAX / argv[n].v_size)\n\t\t\tgoto out_free;\n\n\t\tlen = argv[n].v_size * argv[n].v_nmembs;\n\t\tbase = (void __user *)(unsigned long)argv[n].v_base;\n\t\tif (len == 0) {\n\t\t\tkbufs[n] = NULL;\n\t\t\tcontinue;\n\t\t}\n\n\t\tkbufs[n] = vmalloc(len);\n\t\tif (!kbufs[n]) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto out_free;\n\t\t}\n\t\tif (copy_from_user(kbufs[n], base, len)) {\n\t\t\tret = -EFAULT;\n\t\t\tvfree(kbufs[n]);\n\t\t\tgoto out_free;\n\t\t}\n\t}\n\n\t/*\n\t * nilfs_ioctl_move_blocks() will call nilfs_iget_for_gc(),\n\t * which will operates an inode list without blocking.\n\t * To protect the list from concurrent operations,\n\t * nilfs_ioctl_move_blocks should be atomic operation.\n\t */\n\tif (test_and_set_bit(THE_NILFS_GC_RUNNING, &nilfs->ns_flags)) {\n\t\tret = -EBUSY;\n\t\tgoto out_free;\n\t}\n\n\tret = nilfs_ioctl_move_blocks(inode->i_sb, &argv[0], kbufs[0]);\n\tif (ret < 0)\n\t\tprintk(KERN_ERR \"NILFS: GC failed during preparation: \"\n\t\t\t\"cannot read source blocks: err=%d\\n\", ret);\n\telse {\n\t\tif (nilfs_sb_need_update(nilfs))\n\t\t\tset_nilfs_discontinued(nilfs);\n\t\tret = nilfs_clean_segments(inode->i_sb, argv, kbufs);\n\t}\n\n\tnilfs_remove_all_gcinodes(nilfs);\n\tclear_nilfs_gc_running(nilfs);\n\nout_free:\n\twhile (--n >= 0)\n\t\tvfree(kbufs[n]);\n\tkfree(kbufs[4]);\nout:\n\tmnt_drop_write_file(filp);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nilfs_ioctl_get_bdescs",
          "args": [
            "inode",
            "filp",
            "cmd",
            "argp"
          ],
          "line": 1330
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_ioctl_get_bdescs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/ioctl.c",
          "lines": "531-552",
          "snippet": "static int nilfs_ioctl_get_bdescs(struct inode *inode, struct file *filp,\n\t\t\t\t  unsigned int cmd, void __user *argp)\n{\n\tstruct the_nilfs *nilfs = inode->i_sb->s_fs_info;\n\tstruct nilfs_argv argv;\n\tint ret;\n\n\tif (copy_from_user(&argv, argp, sizeof(argv)))\n\t\treturn -EFAULT;\n\n\tif (argv.v_size != sizeof(struct nilfs_bdesc))\n\t\treturn -EINVAL;\n\n\tret = nilfs_ioctl_wrap_copy(nilfs, &argv, _IOC_DIR(cmd),\n\t\t\t\t    nilfs_ioctl_do_get_bdescs);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (copy_to_user(argp, &argv, sizeof(argv)))\n\t\tret = -EFAULT;\n\treturn ret;\n}",
          "includes": [
            "#include \"dat.h\"",
            "#include \"sufile.h\"",
            "#include \"cpfile.h\"",
            "#include \"bmap.h\"",
            "#include \"segment.h\"",
            "#include \"nilfs.h\"",
            "#include <linux/nilfs2_fs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/mount.h>\t/* mnt_want_write_file(), mnt_drop_write_file() */",
            "#include <linux/compat.h>\t/* compat_ptr() */",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>\t/* copy_from_user(), copy_to_user() */",
            "#include <linux/capability.h>\t/* capable() */",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"dat.h\"\n#include \"sufile.h\"\n#include \"cpfile.h\"\n#include \"bmap.h\"\n#include \"segment.h\"\n#include \"nilfs.h\"\n#include <linux/nilfs2_fs.h>\n#include <linux/buffer_head.h>\n#include <linux/mount.h>\t/* mnt_want_write_file(), mnt_drop_write_file() */\n#include <linux/compat.h>\t/* compat_ptr() */\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\t/* copy_from_user(), copy_to_user() */\n#include <linux/capability.h>\t/* capable() */\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/fs.h>\n\nstatic int nilfs_ioctl_get_bdescs(struct inode *inode, struct file *filp,\n\t\t\t\t  unsigned int cmd, void __user *argp)\n{\n\tstruct the_nilfs *nilfs = inode->i_sb->s_fs_info;\n\tstruct nilfs_argv argv;\n\tint ret;\n\n\tif (copy_from_user(&argv, argp, sizeof(argv)))\n\t\treturn -EFAULT;\n\n\tif (argv.v_size != sizeof(struct nilfs_bdesc))\n\t\treturn -EINVAL;\n\n\tret = nilfs_ioctl_wrap_copy(nilfs, &argv, _IOC_DIR(cmd),\n\t\t\t\t    nilfs_ioctl_do_get_bdescs);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (copy_to_user(argp, &argv, sizeof(argv)))\n\t\tret = -EFAULT;\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nilfs_ioctl_get_info",
          "args": [
            "inode",
            "filp",
            "cmd",
            "argp",
            "sizeof(struct nilfs_vinfo)",
            "nilfs_ioctl_do_get_vinfo"
          ],
          "line": 1326
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_ioctl_get_info",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/ioctl.c",
          "lines": "1179-1204",
          "snippet": "static int nilfs_ioctl_get_info(struct inode *inode, struct file *filp,\n\t\t\t\tunsigned int cmd, void __user *argp,\n\t\t\t\tsize_t membsz,\n\t\t\t\tssize_t (*dofunc)(struct the_nilfs *,\n\t\t\t\t\t\t  __u64 *, int,\n\t\t\t\t\t\t  void *, size_t, size_t))\n\n{\n\tstruct the_nilfs *nilfs = inode->i_sb->s_fs_info;\n\tstruct nilfs_argv argv;\n\tint ret;\n\n\tif (copy_from_user(&argv, argp, sizeof(argv)))\n\t\treturn -EFAULT;\n\n\tif (argv.v_size < membsz)\n\t\treturn -EINVAL;\n\n\tret = nilfs_ioctl_wrap_copy(nilfs, &argv, _IOC_DIR(cmd), dofunc);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (copy_to_user(argp, &argv, sizeof(argv)))\n\t\tret = -EFAULT;\n\treturn ret;\n}",
          "includes": [
            "#include \"dat.h\"",
            "#include \"sufile.h\"",
            "#include \"cpfile.h\"",
            "#include \"bmap.h\"",
            "#include \"segment.h\"",
            "#include \"nilfs.h\"",
            "#include <linux/nilfs2_fs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/mount.h>\t/* mnt_want_write_file(), mnt_drop_write_file() */",
            "#include <linux/compat.h>\t/* compat_ptr() */",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>\t/* copy_from_user(), copy_to_user() */",
            "#include <linux/capability.h>\t/* capable() */",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"dat.h\"\n#include \"sufile.h\"\n#include \"cpfile.h\"\n#include \"bmap.h\"\n#include \"segment.h\"\n#include \"nilfs.h\"\n#include <linux/nilfs2_fs.h>\n#include <linux/buffer_head.h>\n#include <linux/mount.h>\t/* mnt_want_write_file(), mnt_drop_write_file() */\n#include <linux/compat.h>\t/* compat_ptr() */\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\t/* copy_from_user(), copy_to_user() */\n#include <linux/capability.h>\t/* capable() */\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/fs.h>\n\nstatic int nilfs_ioctl_get_info(struct inode *inode, struct file *filp,\n\t\t\t\tunsigned int cmd, void __user *argp,\n\t\t\t\tsize_t membsz,\n\t\t\t\tssize_t (*dofunc)(struct the_nilfs *,\n\t\t\t\t\t\t  __u64 *, int,\n\t\t\t\t\t\t  void *, size_t, size_t))\n\n{\n\tstruct the_nilfs *nilfs = inode->i_sb->s_fs_info;\n\tstruct nilfs_argv argv;\n\tint ret;\n\n\tif (copy_from_user(&argv, argp, sizeof(argv)))\n\t\treturn -EFAULT;\n\n\tif (argv.v_size < membsz)\n\t\treturn -EINVAL;\n\n\tret = nilfs_ioctl_wrap_copy(nilfs, &argv, _IOC_DIR(cmd), dofunc);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (copy_to_user(argp, &argv, sizeof(argv)))\n\t\tret = -EFAULT;\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nilfs_ioctl_get_sustat",
          "args": [
            "inode",
            "filp",
            "cmd",
            "argp"
          ],
          "line": 1324
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_ioctl_get_sustat",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/ioctl.c",
          "lines": "422-438",
          "snippet": "static int nilfs_ioctl_get_sustat(struct inode *inode, struct file *filp,\n\t\t\t\t  unsigned int cmd, void __user *argp)\n{\n\tstruct the_nilfs *nilfs = inode->i_sb->s_fs_info;\n\tstruct nilfs_sustat sustat;\n\tint ret;\n\n\tdown_read(&nilfs->ns_segctor_sem);\n\tret = nilfs_sufile_get_stat(nilfs->ns_sufile, &sustat);\n\tup_read(&nilfs->ns_segctor_sem);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (copy_to_user(argp, &sustat, sizeof(sustat)))\n\t\tret = -EFAULT;\n\treturn ret;\n}",
          "includes": [
            "#include \"dat.h\"",
            "#include \"sufile.h\"",
            "#include \"cpfile.h\"",
            "#include \"bmap.h\"",
            "#include \"segment.h\"",
            "#include \"nilfs.h\"",
            "#include <linux/nilfs2_fs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/mount.h>\t/* mnt_want_write_file(), mnt_drop_write_file() */",
            "#include <linux/compat.h>\t/* compat_ptr() */",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>\t/* copy_from_user(), copy_to_user() */",
            "#include <linux/capability.h>\t/* capable() */",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"dat.h\"\n#include \"sufile.h\"\n#include \"cpfile.h\"\n#include \"bmap.h\"\n#include \"segment.h\"\n#include \"nilfs.h\"\n#include <linux/nilfs2_fs.h>\n#include <linux/buffer_head.h>\n#include <linux/mount.h>\t/* mnt_want_write_file(), mnt_drop_write_file() */\n#include <linux/compat.h>\t/* compat_ptr() */\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\t/* copy_from_user(), copy_to_user() */\n#include <linux/capability.h>\t/* capable() */\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/fs.h>\n\nstatic int nilfs_ioctl_get_sustat(struct inode *inode, struct file *filp,\n\t\t\t\t  unsigned int cmd, void __user *argp)\n{\n\tstruct the_nilfs *nilfs = inode->i_sb->s_fs_info;\n\tstruct nilfs_sustat sustat;\n\tint ret;\n\n\tdown_read(&nilfs->ns_segctor_sem);\n\tret = nilfs_sufile_get_stat(nilfs->ns_sufile, &sustat);\n\tup_read(&nilfs->ns_segctor_sem);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (copy_to_user(argp, &sustat, sizeof(sustat)))\n\t\tret = -EFAULT;\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nilfs_ioctl_set_suinfo",
          "args": [
            "inode",
            "filp",
            "cmd",
            "argp"
          ],
          "line": 1322
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_ioctl_set_suinfo",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/ioctl.c",
          "lines": "1230-1293",
          "snippet": "static int nilfs_ioctl_set_suinfo(struct inode *inode, struct file *filp,\n\t\t\t\tunsigned int cmd, void __user *argp)\n{\n\tstruct the_nilfs *nilfs = inode->i_sb->s_fs_info;\n\tstruct nilfs_transaction_info ti;\n\tstruct nilfs_argv argv;\n\tsize_t len;\n\tvoid __user *base;\n\tvoid *kbuf;\n\tint ret;\n\n\tif (!capable(CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\n\tret = mnt_want_write_file(filp);\n\tif (ret)\n\t\treturn ret;\n\n\tret = -EFAULT;\n\tif (copy_from_user(&argv, argp, sizeof(argv)))\n\t\tgoto out;\n\n\tret = -EINVAL;\n\tif (argv.v_size < sizeof(struct nilfs_suinfo_update))\n\t\tgoto out;\n\n\tif (argv.v_nmembs > nilfs->ns_nsegments)\n\t\tgoto out;\n\n\tif (argv.v_nmembs >= UINT_MAX / argv.v_size)\n\t\tgoto out;\n\n\tlen = argv.v_size * argv.v_nmembs;\n\tif (!len) {\n\t\tret = 0;\n\t\tgoto out;\n\t}\n\n\tbase = (void __user *)(unsigned long)argv.v_base;\n\tkbuf = vmalloc(len);\n\tif (!kbuf) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tif (copy_from_user(kbuf, base, len)) {\n\t\tret = -EFAULT;\n\t\tgoto out_free;\n\t}\n\n\tnilfs_transaction_begin(inode->i_sb, &ti, 0);\n\tret = nilfs_sufile_set_suinfo(nilfs->ns_sufile, kbuf, argv.v_size,\n\t\t\targv.v_nmembs);\n\tif (unlikely(ret < 0))\n\t\tnilfs_transaction_abort(inode->i_sb);\n\telse\n\t\tnilfs_transaction_commit(inode->i_sb); /* never fails */\n\nout_free:\n\tvfree(kbuf);\nout:\n\tmnt_drop_write_file(filp);\n\treturn ret;\n}",
          "includes": [
            "#include \"dat.h\"",
            "#include \"sufile.h\"",
            "#include \"cpfile.h\"",
            "#include \"bmap.h\"",
            "#include \"segment.h\"",
            "#include \"nilfs.h\"",
            "#include <linux/nilfs2_fs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/mount.h>\t/* mnt_want_write_file(), mnt_drop_write_file() */",
            "#include <linux/compat.h>\t/* compat_ptr() */",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>\t/* copy_from_user(), copy_to_user() */",
            "#include <linux/capability.h>\t/* capable() */",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"dat.h\"\n#include \"sufile.h\"\n#include \"cpfile.h\"\n#include \"bmap.h\"\n#include \"segment.h\"\n#include \"nilfs.h\"\n#include <linux/nilfs2_fs.h>\n#include <linux/buffer_head.h>\n#include <linux/mount.h>\t/* mnt_want_write_file(), mnt_drop_write_file() */\n#include <linux/compat.h>\t/* compat_ptr() */\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\t/* copy_from_user(), copy_to_user() */\n#include <linux/capability.h>\t/* capable() */\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/fs.h>\n\nstatic int nilfs_ioctl_set_suinfo(struct inode *inode, struct file *filp,\n\t\t\t\tunsigned int cmd, void __user *argp)\n{\n\tstruct the_nilfs *nilfs = inode->i_sb->s_fs_info;\n\tstruct nilfs_transaction_info ti;\n\tstruct nilfs_argv argv;\n\tsize_t len;\n\tvoid __user *base;\n\tvoid *kbuf;\n\tint ret;\n\n\tif (!capable(CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\n\tret = mnt_want_write_file(filp);\n\tif (ret)\n\t\treturn ret;\n\n\tret = -EFAULT;\n\tif (copy_from_user(&argv, argp, sizeof(argv)))\n\t\tgoto out;\n\n\tret = -EINVAL;\n\tif (argv.v_size < sizeof(struct nilfs_suinfo_update))\n\t\tgoto out;\n\n\tif (argv.v_nmembs > nilfs->ns_nsegments)\n\t\tgoto out;\n\n\tif (argv.v_nmembs >= UINT_MAX / argv.v_size)\n\t\tgoto out;\n\n\tlen = argv.v_size * argv.v_nmembs;\n\tif (!len) {\n\t\tret = 0;\n\t\tgoto out;\n\t}\n\n\tbase = (void __user *)(unsigned long)argv.v_base;\n\tkbuf = vmalloc(len);\n\tif (!kbuf) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tif (copy_from_user(kbuf, base, len)) {\n\t\tret = -EFAULT;\n\t\tgoto out_free;\n\t}\n\n\tnilfs_transaction_begin(inode->i_sb, &ti, 0);\n\tret = nilfs_sufile_set_suinfo(nilfs->ns_sufile, kbuf, argv.v_size,\n\t\t\targv.v_nmembs);\n\tif (unlikely(ret < 0))\n\t\tnilfs_transaction_abort(inode->i_sb);\n\telse\n\t\tnilfs_transaction_commit(inode->i_sb); /* never fails */\n\nout_free:\n\tvfree(kbuf);\nout:\n\tmnt_drop_write_file(filp);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nilfs_ioctl_get_cpstat",
          "args": [
            "inode",
            "filp",
            "cmd",
            "argp"
          ],
          "line": 1316
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_ioctl_get_cpstat",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/ioctl.c",
          "lines": "355-371",
          "snippet": "static int nilfs_ioctl_get_cpstat(struct inode *inode, struct file *filp,\n\t\t\t\t  unsigned int cmd, void __user *argp)\n{\n\tstruct the_nilfs *nilfs = inode->i_sb->s_fs_info;\n\tstruct nilfs_cpstat cpstat;\n\tint ret;\n\n\tdown_read(&nilfs->ns_segctor_sem);\n\tret = nilfs_cpfile_get_stat(nilfs->ns_cpfile, &cpstat);\n\tup_read(&nilfs->ns_segctor_sem);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (copy_to_user(argp, &cpstat, sizeof(cpstat)))\n\t\tret = -EFAULT;\n\treturn ret;\n}",
          "includes": [
            "#include \"dat.h\"",
            "#include \"sufile.h\"",
            "#include \"cpfile.h\"",
            "#include \"bmap.h\"",
            "#include \"segment.h\"",
            "#include \"nilfs.h\"",
            "#include <linux/nilfs2_fs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/mount.h>\t/* mnt_want_write_file(), mnt_drop_write_file() */",
            "#include <linux/compat.h>\t/* compat_ptr() */",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>\t/* copy_from_user(), copy_to_user() */",
            "#include <linux/capability.h>\t/* capable() */",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"dat.h\"\n#include \"sufile.h\"\n#include \"cpfile.h\"\n#include \"bmap.h\"\n#include \"segment.h\"\n#include \"nilfs.h\"\n#include <linux/nilfs2_fs.h>\n#include <linux/buffer_head.h>\n#include <linux/mount.h>\t/* mnt_want_write_file(), mnt_drop_write_file() */\n#include <linux/compat.h>\t/* compat_ptr() */\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\t/* copy_from_user(), copy_to_user() */\n#include <linux/capability.h>\t/* capable() */\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/fs.h>\n\nstatic int nilfs_ioctl_get_cpstat(struct inode *inode, struct file *filp,\n\t\t\t\t  unsigned int cmd, void __user *argp)\n{\n\tstruct the_nilfs *nilfs = inode->i_sb->s_fs_info;\n\tstruct nilfs_cpstat cpstat;\n\tint ret;\n\n\tdown_read(&nilfs->ns_segctor_sem);\n\tret = nilfs_cpfile_get_stat(nilfs->ns_cpfile, &cpstat);\n\tup_read(&nilfs->ns_segctor_sem);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (copy_to_user(argp, &cpstat, sizeof(cpstat)))\n\t\tret = -EFAULT;\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nilfs_ioctl_delete_checkpoint",
          "args": [
            "inode",
            "filp",
            "cmd",
            "argp"
          ],
          "line": 1310
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_ioctl_delete_checkpoint",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/ioctl.c",
          "lines": "275-304",
          "snippet": "static int\nnilfs_ioctl_delete_checkpoint(struct inode *inode, struct file *filp,\n\t\t\t      unsigned int cmd, void __user *argp)\n{\n\tstruct the_nilfs *nilfs = inode->i_sb->s_fs_info;\n\tstruct nilfs_transaction_info ti;\n\t__u64 cno;\n\tint ret;\n\n\tif (!capable(CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\n\tret = mnt_want_write_file(filp);\n\tif (ret)\n\t\treturn ret;\n\n\tret = -EFAULT;\n\tif (copy_from_user(&cno, argp, sizeof(cno)))\n\t\tgoto out;\n\n\tnilfs_transaction_begin(inode->i_sb, &ti, 0);\n\tret = nilfs_cpfile_delete_checkpoint(nilfs->ns_cpfile, cno);\n\tif (unlikely(ret < 0))\n\t\tnilfs_transaction_abort(inode->i_sb);\n\telse\n\t\tnilfs_transaction_commit(inode->i_sb); /* never fails */\nout:\n\tmnt_drop_write_file(filp);\n\treturn ret;\n}",
          "includes": [
            "#include \"dat.h\"",
            "#include \"sufile.h\"",
            "#include \"cpfile.h\"",
            "#include \"bmap.h\"",
            "#include \"segment.h\"",
            "#include \"nilfs.h\"",
            "#include <linux/nilfs2_fs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/mount.h>\t/* mnt_want_write_file(), mnt_drop_write_file() */",
            "#include <linux/compat.h>\t/* compat_ptr() */",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>\t/* copy_from_user(), copy_to_user() */",
            "#include <linux/capability.h>\t/* capable() */",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"dat.h\"\n#include \"sufile.h\"\n#include \"cpfile.h\"\n#include \"bmap.h\"\n#include \"segment.h\"\n#include \"nilfs.h\"\n#include <linux/nilfs2_fs.h>\n#include <linux/buffer_head.h>\n#include <linux/mount.h>\t/* mnt_want_write_file(), mnt_drop_write_file() */\n#include <linux/compat.h>\t/* compat_ptr() */\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\t/* copy_from_user(), copy_to_user() */\n#include <linux/capability.h>\t/* capable() */\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/fs.h>\n\nstatic int\nnilfs_ioctl_delete_checkpoint(struct inode *inode, struct file *filp,\n\t\t\t      unsigned int cmd, void __user *argp)\n{\n\tstruct the_nilfs *nilfs = inode->i_sb->s_fs_info;\n\tstruct nilfs_transaction_info ti;\n\t__u64 cno;\n\tint ret;\n\n\tif (!capable(CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\n\tret = mnt_want_write_file(filp);\n\tif (ret)\n\t\treturn ret;\n\n\tret = -EFAULT;\n\tif (copy_from_user(&cno, argp, sizeof(cno)))\n\t\tgoto out;\n\n\tnilfs_transaction_begin(inode->i_sb, &ti, 0);\n\tret = nilfs_cpfile_delete_checkpoint(nilfs->ns_cpfile, cno);\n\tif (unlikely(ret < 0))\n\t\tnilfs_transaction_abort(inode->i_sb);\n\telse\n\t\tnilfs_transaction_commit(inode->i_sb); /* never fails */\nout:\n\tmnt_drop_write_file(filp);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nilfs_ioctl_change_cpmode",
          "args": [
            "inode",
            "filp",
            "cmd",
            "argp"
          ],
          "line": 1308
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_ioctl_change_cpmode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/ioctl.c",
          "lines": "221-254",
          "snippet": "static int nilfs_ioctl_change_cpmode(struct inode *inode, struct file *filp,\n\t\t\t\t     unsigned int cmd, void __user *argp)\n{\n\tstruct the_nilfs *nilfs = inode->i_sb->s_fs_info;\n\tstruct nilfs_transaction_info ti;\n\tstruct nilfs_cpmode cpmode;\n\tint ret;\n\n\tif (!capable(CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\n\tret = mnt_want_write_file(filp);\n\tif (ret)\n\t\treturn ret;\n\n\tret = -EFAULT;\n\tif (copy_from_user(&cpmode, argp, sizeof(cpmode)))\n\t\tgoto out;\n\n\tmutex_lock(&nilfs->ns_snapshot_mount_mutex);\n\n\tnilfs_transaction_begin(inode->i_sb, &ti, 0);\n\tret = nilfs_cpfile_change_cpmode(\n\t\tnilfs->ns_cpfile, cpmode.cm_cno, cpmode.cm_mode);\n\tif (unlikely(ret < 0))\n\t\tnilfs_transaction_abort(inode->i_sb);\n\telse\n\t\tnilfs_transaction_commit(inode->i_sb); /* never fails */\n\n\tmutex_unlock(&nilfs->ns_snapshot_mount_mutex);\nout:\n\tmnt_drop_write_file(filp);\n\treturn ret;\n}",
          "includes": [
            "#include \"dat.h\"",
            "#include \"sufile.h\"",
            "#include \"cpfile.h\"",
            "#include \"bmap.h\"",
            "#include \"segment.h\"",
            "#include \"nilfs.h\"",
            "#include <linux/nilfs2_fs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/mount.h>\t/* mnt_want_write_file(), mnt_drop_write_file() */",
            "#include <linux/compat.h>\t/* compat_ptr() */",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>\t/* copy_from_user(), copy_to_user() */",
            "#include <linux/capability.h>\t/* capable() */",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"dat.h\"\n#include \"sufile.h\"\n#include \"cpfile.h\"\n#include \"bmap.h\"\n#include \"segment.h\"\n#include \"nilfs.h\"\n#include <linux/nilfs2_fs.h>\n#include <linux/buffer_head.h>\n#include <linux/mount.h>\t/* mnt_want_write_file(), mnt_drop_write_file() */\n#include <linux/compat.h>\t/* compat_ptr() */\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\t/* copy_from_user(), copy_to_user() */\n#include <linux/capability.h>\t/* capable() */\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/fs.h>\n\nstatic int nilfs_ioctl_change_cpmode(struct inode *inode, struct file *filp,\n\t\t\t\t     unsigned int cmd, void __user *argp)\n{\n\tstruct the_nilfs *nilfs = inode->i_sb->s_fs_info;\n\tstruct nilfs_transaction_info ti;\n\tstruct nilfs_cpmode cpmode;\n\tint ret;\n\n\tif (!capable(CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\n\tret = mnt_want_write_file(filp);\n\tif (ret)\n\t\treturn ret;\n\n\tret = -EFAULT;\n\tif (copy_from_user(&cpmode, argp, sizeof(cpmode)))\n\t\tgoto out;\n\n\tmutex_lock(&nilfs->ns_snapshot_mount_mutex);\n\n\tnilfs_transaction_begin(inode->i_sb, &ti, 0);\n\tret = nilfs_cpfile_change_cpmode(\n\t\tnilfs->ns_cpfile, cpmode.cm_cno, cpmode.cm_mode);\n\tif (unlikely(ret < 0))\n\t\tnilfs_transaction_abort(inode->i_sb);\n\telse\n\t\tnilfs_transaction_commit(inode->i_sb); /* never fails */\n\n\tmutex_unlock(&nilfs->ns_snapshot_mount_mutex);\nout:\n\tmnt_drop_write_file(filp);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nilfs_ioctl_getversion",
          "args": [
            "inode",
            "argp"
          ],
          "line": 1306
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_ioctl_getversion",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/ioctl.c",
          "lines": "197-200",
          "snippet": "static int nilfs_ioctl_getversion(struct inode *inode, void __user *argp)\n{\n\treturn put_user(inode->i_generation, (int __user *)argp);\n}",
          "includes": [
            "#include \"dat.h\"",
            "#include \"sufile.h\"",
            "#include \"cpfile.h\"",
            "#include \"bmap.h\"",
            "#include \"segment.h\"",
            "#include \"nilfs.h\"",
            "#include <linux/nilfs2_fs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/mount.h>\t/* mnt_want_write_file(), mnt_drop_write_file() */",
            "#include <linux/compat.h>\t/* compat_ptr() */",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>\t/* copy_from_user(), copy_to_user() */",
            "#include <linux/capability.h>\t/* capable() */",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"dat.h\"\n#include \"sufile.h\"\n#include \"cpfile.h\"\n#include \"bmap.h\"\n#include \"segment.h\"\n#include \"nilfs.h\"\n#include <linux/nilfs2_fs.h>\n#include <linux/buffer_head.h>\n#include <linux/mount.h>\t/* mnt_want_write_file(), mnt_drop_write_file() */\n#include <linux/compat.h>\t/* compat_ptr() */\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\t/* copy_from_user(), copy_to_user() */\n#include <linux/capability.h>\t/* capable() */\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/fs.h>\n\nstatic int nilfs_ioctl_getversion(struct inode *inode, void __user *argp)\n{\n\treturn put_user(inode->i_generation, (int __user *)argp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "nilfs_ioctl_setflags",
          "args": [
            "inode",
            "filp",
            "argp"
          ],
          "line": 1304
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_ioctl_setflags",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/ioctl.c",
          "lines": "142-192",
          "snippet": "static int nilfs_ioctl_setflags(struct inode *inode, struct file *filp,\n\t\t\t\tvoid __user *argp)\n{\n\tstruct nilfs_transaction_info ti;\n\tunsigned int flags, oldflags;\n\tint ret;\n\n\tif (!inode_owner_or_capable(inode))\n\t\treturn -EACCES;\n\n\tif (get_user(flags, (int __user *)argp))\n\t\treturn -EFAULT;\n\n\tret = mnt_want_write_file(filp);\n\tif (ret)\n\t\treturn ret;\n\n\tflags = nilfs_mask_flags(inode->i_mode, flags);\n\n\tmutex_lock(&inode->i_mutex);\n\n\toldflags = NILFS_I(inode)->i_flags;\n\n\t/*\n\t * The IMMUTABLE and APPEND_ONLY flags can only be changed by the\n\t * relevant capability.\n\t */\n\tret = -EPERM;\n\tif (((flags ^ oldflags) & (FS_APPEND_FL | FS_IMMUTABLE_FL)) &&\n\t    !capable(CAP_LINUX_IMMUTABLE))\n\t\tgoto out;\n\n\tret = nilfs_transaction_begin(inode->i_sb, &ti, 0);\n\tif (ret)\n\t\tgoto out;\n\n\tNILFS_I(inode)->i_flags = (oldflags & ~FS_FL_USER_MODIFIABLE) |\n\t\t(flags & FS_FL_USER_MODIFIABLE);\n\n\tnilfs_set_inode_flags(inode);\n\tinode->i_ctime = CURRENT_TIME;\n\tif (IS_SYNC(inode))\n\t\tnilfs_set_transaction_flag(NILFS_TI_SYNC);\n\n\tnilfs_mark_inode_dirty(inode);\n\tret = nilfs_transaction_commit(inode->i_sb);\nout:\n\tmutex_unlock(&inode->i_mutex);\n\tmnt_drop_write_file(filp);\n\treturn ret;\n}",
          "includes": [
            "#include \"dat.h\"",
            "#include \"sufile.h\"",
            "#include \"cpfile.h\"",
            "#include \"bmap.h\"",
            "#include \"segment.h\"",
            "#include \"nilfs.h\"",
            "#include <linux/nilfs2_fs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/mount.h>\t/* mnt_want_write_file(), mnt_drop_write_file() */",
            "#include <linux/compat.h>\t/* compat_ptr() */",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>\t/* copy_from_user(), copy_to_user() */",
            "#include <linux/capability.h>\t/* capable() */",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"dat.h\"\n#include \"sufile.h\"\n#include \"cpfile.h\"\n#include \"bmap.h\"\n#include \"segment.h\"\n#include \"nilfs.h\"\n#include <linux/nilfs2_fs.h>\n#include <linux/buffer_head.h>\n#include <linux/mount.h>\t/* mnt_want_write_file(), mnt_drop_write_file() */\n#include <linux/compat.h>\t/* compat_ptr() */\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\t/* copy_from_user(), copy_to_user() */\n#include <linux/capability.h>\t/* capable() */\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/fs.h>\n\nstatic int nilfs_ioctl_setflags(struct inode *inode, struct file *filp,\n\t\t\t\tvoid __user *argp)\n{\n\tstruct nilfs_transaction_info ti;\n\tunsigned int flags, oldflags;\n\tint ret;\n\n\tif (!inode_owner_or_capable(inode))\n\t\treturn -EACCES;\n\n\tif (get_user(flags, (int __user *)argp))\n\t\treturn -EFAULT;\n\n\tret = mnt_want_write_file(filp);\n\tif (ret)\n\t\treturn ret;\n\n\tflags = nilfs_mask_flags(inode->i_mode, flags);\n\n\tmutex_lock(&inode->i_mutex);\n\n\toldflags = NILFS_I(inode)->i_flags;\n\n\t/*\n\t * The IMMUTABLE and APPEND_ONLY flags can only be changed by the\n\t * relevant capability.\n\t */\n\tret = -EPERM;\n\tif (((flags ^ oldflags) & (FS_APPEND_FL | FS_IMMUTABLE_FL)) &&\n\t    !capable(CAP_LINUX_IMMUTABLE))\n\t\tgoto out;\n\n\tret = nilfs_transaction_begin(inode->i_sb, &ti, 0);\n\tif (ret)\n\t\tgoto out;\n\n\tNILFS_I(inode)->i_flags = (oldflags & ~FS_FL_USER_MODIFIABLE) |\n\t\t(flags & FS_FL_USER_MODIFIABLE);\n\n\tnilfs_set_inode_flags(inode);\n\tinode->i_ctime = CURRENT_TIME;\n\tif (IS_SYNC(inode))\n\t\tnilfs_set_transaction_flag(NILFS_TI_SYNC);\n\n\tnilfs_mark_inode_dirty(inode);\n\tret = nilfs_transaction_commit(inode->i_sb);\nout:\n\tmutex_unlock(&inode->i_mutex);\n\tmnt_drop_write_file(filp);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nilfs_ioctl_getflags",
          "args": [
            "inode",
            "argp"
          ],
          "line": 1302
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_ioctl_getflags",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/ioctl.c",
          "lines": "132-137",
          "snippet": "static int nilfs_ioctl_getflags(struct inode *inode, void __user *argp)\n{\n\tunsigned int flags = NILFS_I(inode)->i_flags & FS_FL_USER_VISIBLE;\n\n\treturn put_user(flags, (int __user *)argp);\n}",
          "includes": [
            "#include \"dat.h\"",
            "#include \"sufile.h\"",
            "#include \"cpfile.h\"",
            "#include \"bmap.h\"",
            "#include \"segment.h\"",
            "#include \"nilfs.h\"",
            "#include <linux/nilfs2_fs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/mount.h>\t/* mnt_want_write_file(), mnt_drop_write_file() */",
            "#include <linux/compat.h>\t/* compat_ptr() */",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>\t/* copy_from_user(), copy_to_user() */",
            "#include <linux/capability.h>\t/* capable() */",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"dat.h\"\n#include \"sufile.h\"\n#include \"cpfile.h\"\n#include \"bmap.h\"\n#include \"segment.h\"\n#include \"nilfs.h\"\n#include <linux/nilfs2_fs.h>\n#include <linux/buffer_head.h>\n#include <linux/mount.h>\t/* mnt_want_write_file(), mnt_drop_write_file() */\n#include <linux/compat.h>\t/* compat_ptr() */\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\t/* copy_from_user(), copy_to_user() */\n#include <linux/capability.h>\t/* capable() */\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/fs.h>\n\nstatic int nilfs_ioctl_getflags(struct inode *inode, void __user *argp)\n{\n\tunsigned int flags = NILFS_I(inode)->i_flags & FS_FL_USER_VISIBLE;\n\n\treturn put_user(flags, (int __user *)argp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "file_inode",
          "args": [
            "filp"
          ],
          "line": 1297
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_init_file_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/file.c",
          "lines": "3009-3013",
          "snippet": "void fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}",
          "includes": [
            "#include <linux/falloc.h>",
            "#include <linux/aio.h>",
            "#include <linux/swap.h>",
            "#include <linux/compat.h>",
            "#include <linux/module.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};",
            "static const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/compat.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};\nstatic const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};\n\nvoid fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"dat.h\"\n#include \"sufile.h\"\n#include \"cpfile.h\"\n#include \"bmap.h\"\n#include \"segment.h\"\n#include \"nilfs.h\"\n#include <linux/nilfs2_fs.h>\n#include <linux/buffer_head.h>\n#include <linux/mount.h>\t/* mnt_want_write_file(), mnt_drop_write_file() */\n#include <linux/compat.h>\t/* compat_ptr() */\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\t/* copy_from_user(), copy_to_user() */\n#include <linux/capability.h>\t/* capable() */\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/fs.h>\n\nlong nilfs_ioctl(struct file *filp, unsigned int cmd, unsigned long arg)\n{\n\tstruct inode *inode = file_inode(filp);\n\tvoid __user *argp = (void __user *)arg;\n\n\tswitch (cmd) {\n\tcase FS_IOC_GETFLAGS:\n\t\treturn nilfs_ioctl_getflags(inode, argp);\n\tcase FS_IOC_SETFLAGS:\n\t\treturn nilfs_ioctl_setflags(inode, filp, argp);\n\tcase FS_IOC_GETVERSION:\n\t\treturn nilfs_ioctl_getversion(inode, argp);\n\tcase NILFS_IOCTL_CHANGE_CPMODE:\n\t\treturn nilfs_ioctl_change_cpmode(inode, filp, cmd, argp);\n\tcase NILFS_IOCTL_DELETE_CHECKPOINT:\n\t\treturn nilfs_ioctl_delete_checkpoint(inode, filp, cmd, argp);\n\tcase NILFS_IOCTL_GET_CPINFO:\n\t\treturn nilfs_ioctl_get_info(inode, filp, cmd, argp,\n\t\t\t\t\t    sizeof(struct nilfs_cpinfo),\n\t\t\t\t\t    nilfs_ioctl_do_get_cpinfo);\n\tcase NILFS_IOCTL_GET_CPSTAT:\n\t\treturn nilfs_ioctl_get_cpstat(inode, filp, cmd, argp);\n\tcase NILFS_IOCTL_GET_SUINFO:\n\t\treturn nilfs_ioctl_get_info(inode, filp, cmd, argp,\n\t\t\t\t\t    sizeof(struct nilfs_suinfo),\n\t\t\t\t\t    nilfs_ioctl_do_get_suinfo);\n\tcase NILFS_IOCTL_SET_SUINFO:\n\t\treturn nilfs_ioctl_set_suinfo(inode, filp, cmd, argp);\n\tcase NILFS_IOCTL_GET_SUSTAT:\n\t\treturn nilfs_ioctl_get_sustat(inode, filp, cmd, argp);\n\tcase NILFS_IOCTL_GET_VINFO:\n\t\treturn nilfs_ioctl_get_info(inode, filp, cmd, argp,\n\t\t\t\t\t    sizeof(struct nilfs_vinfo),\n\t\t\t\t\t    nilfs_ioctl_do_get_vinfo);\n\tcase NILFS_IOCTL_GET_BDESCS:\n\t\treturn nilfs_ioctl_get_bdescs(inode, filp, cmd, argp);\n\tcase NILFS_IOCTL_CLEAN_SEGMENTS:\n\t\treturn nilfs_ioctl_clean_segments(inode, filp, cmd, argp);\n\tcase NILFS_IOCTL_SYNC:\n\t\treturn nilfs_ioctl_sync(inode, filp, cmd, argp);\n\tcase NILFS_IOCTL_RESIZE:\n\t\treturn nilfs_ioctl_resize(inode, filp, argp);\n\tcase NILFS_IOCTL_SET_ALLOC_RANGE:\n\t\treturn nilfs_ioctl_set_alloc_range(inode, argp);\n\tcase FITRIM:\n\t\treturn nilfs_ioctl_trim_fs(inode, argp);\n\tdefault:\n\t\treturn -ENOTTY;\n\t}\n}"
  },
  {
    "function_name": "nilfs_ioctl_set_suinfo",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/ioctl.c",
    "lines": "1230-1293",
    "snippet": "static int nilfs_ioctl_set_suinfo(struct inode *inode, struct file *filp,\n\t\t\t\tunsigned int cmd, void __user *argp)\n{\n\tstruct the_nilfs *nilfs = inode->i_sb->s_fs_info;\n\tstruct nilfs_transaction_info ti;\n\tstruct nilfs_argv argv;\n\tsize_t len;\n\tvoid __user *base;\n\tvoid *kbuf;\n\tint ret;\n\n\tif (!capable(CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\n\tret = mnt_want_write_file(filp);\n\tif (ret)\n\t\treturn ret;\n\n\tret = -EFAULT;\n\tif (copy_from_user(&argv, argp, sizeof(argv)))\n\t\tgoto out;\n\n\tret = -EINVAL;\n\tif (argv.v_size < sizeof(struct nilfs_suinfo_update))\n\t\tgoto out;\n\n\tif (argv.v_nmembs > nilfs->ns_nsegments)\n\t\tgoto out;\n\n\tif (argv.v_nmembs >= UINT_MAX / argv.v_size)\n\t\tgoto out;\n\n\tlen = argv.v_size * argv.v_nmembs;\n\tif (!len) {\n\t\tret = 0;\n\t\tgoto out;\n\t}\n\n\tbase = (void __user *)(unsigned long)argv.v_base;\n\tkbuf = vmalloc(len);\n\tif (!kbuf) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tif (copy_from_user(kbuf, base, len)) {\n\t\tret = -EFAULT;\n\t\tgoto out_free;\n\t}\n\n\tnilfs_transaction_begin(inode->i_sb, &ti, 0);\n\tret = nilfs_sufile_set_suinfo(nilfs->ns_sufile, kbuf, argv.v_size,\n\t\t\targv.v_nmembs);\n\tif (unlikely(ret < 0))\n\t\tnilfs_transaction_abort(inode->i_sb);\n\telse\n\t\tnilfs_transaction_commit(inode->i_sb); /* never fails */\n\nout_free:\n\tvfree(kbuf);\nout:\n\tmnt_drop_write_file(filp);\n\treturn ret;\n}",
    "includes": [
      "#include \"dat.h\"",
      "#include \"sufile.h\"",
      "#include \"cpfile.h\"",
      "#include \"bmap.h\"",
      "#include \"segment.h\"",
      "#include \"nilfs.h\"",
      "#include <linux/nilfs2_fs.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/mount.h>\t/* mnt_want_write_file(), mnt_drop_write_file() */",
      "#include <linux/compat.h>\t/* compat_ptr() */",
      "#include <linux/vmalloc.h>",
      "#include <linux/uaccess.h>\t/* copy_from_user(), copy_to_user() */",
      "#include <linux/capability.h>\t/* capable() */",
      "#include <linux/slab.h>",
      "#include <linux/wait.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mnt_drop_write_file",
          "args": [
            "filp"
          ],
          "line": 1291
        },
        "resolved": true,
        "details": {
          "function_name": "mnt_drop_write_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namespace.c",
          "lines": "487-490",
          "snippet": "void mnt_drop_write_file(struct file *file)\n{\n\tmnt_drop_write(file->f_path.mnt);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"pnode.h\"",
            "#include <linux/task_work.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/magic.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
            "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
            "#include <linux/init.h>\t\t/* init_rootfs */",
            "#include <linux/idr.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/mnt_namespace.h>",
            "#include <linux/capability.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void shrink_submounts(struct mount *mnt);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/task_work.h>\n#include <linux/bootmem.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic void shrink_submounts(struct mount *mnt);\n\nvoid mnt_drop_write_file(struct file *file)\n{\n\tmnt_drop_write(file->f_path.mnt);\n}"
        }
      },
      {
        "call_info": {
          "callee": "vfree",
          "args": [
            "kbuf"
          ],
          "line": 1289
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nilfs_transaction_commit",
          "args": [
            "inode->i_sb"
          ],
          "line": 1286
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_transaction_commit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/segment.c",
          "lines": "223-252",
          "snippet": "int nilfs_transaction_commit(struct super_block *sb)\n{\n\tstruct nilfs_transaction_info *ti = current->journal_info;\n\tstruct the_nilfs *nilfs = sb->s_fs_info;\n\tint err = 0;\n\n\tBUG_ON(ti == NULL || ti->ti_magic != NILFS_TI_MAGIC);\n\tti->ti_flags |= NILFS_TI_COMMIT;\n\tif (ti->ti_count > 0) {\n\t\tti->ti_count--;\n\t\treturn 0;\n\t}\n\tif (nilfs->ns_writer) {\n\t\tstruct nilfs_sc_info *sci = nilfs->ns_writer;\n\n\t\tif (ti->ti_flags & NILFS_TI_COMMIT)\n\t\t\tnilfs_segctor_start_timer(sci);\n\t\tif (atomic_read(&nilfs->ns_ndirtyblks) > sci->sc_watermark)\n\t\t\tnilfs_segctor_do_flush(sci, 0);\n\t}\n\tup_read(&nilfs->ns_segctor_sem);\n\tcurrent->journal_info = ti->ti_save;\n\n\tif (ti->ti_flags & NILFS_TI_SYNC)\n\t\terr = nilfs_construct_segment(sb);\n\tif (ti->ti_flags & NILFS_TI_DYNAMIC_ALLOC)\n\t\tkmem_cache_free(nilfs_transaction_cachep, ti);\n\tsb_end_intwrite(sb);\n\treturn err;\n}",
          "includes": [
            "#include \"segbuf.h\"",
            "#include \"ifile.h\"",
            "#include \"cpfile.h\"",
            "#include \"sufile.h\"",
            "#include \"segment.h\"",
            "#include \"page.h\"",
            "#include \"btnode.h\"",
            "#include \"nilfs.h\"",
            "#include <linux/slab.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/crc32.h>",
            "#include <linux/kthread.h>",
            "#include <linux/freezer.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/completion.h>",
            "#include <linux/bio.h>",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void nilfs_segctor_start_timer(struct nilfs_sc_info *);",
            "static void nilfs_segctor_do_flush(struct nilfs_sc_info *, int);",
            "static void nilfs_segctor_do_immediate_flush(struct nilfs_sc_info *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"segbuf.h\"\n#include \"ifile.h\"\n#include \"cpfile.h\"\n#include \"sufile.h\"\n#include \"segment.h\"\n#include \"page.h\"\n#include \"btnode.h\"\n#include \"nilfs.h\"\n#include <linux/slab.h>\n#include <linux/pagevec.h>\n#include <linux/crc32.h>\n#include <linux/kthread.h>\n#include <linux/freezer.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/completion.h>\n#include <linux/bio.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n\nstatic void nilfs_segctor_start_timer(struct nilfs_sc_info *);\nstatic void nilfs_segctor_do_flush(struct nilfs_sc_info *, int);\nstatic void nilfs_segctor_do_immediate_flush(struct nilfs_sc_info *);\n\nint nilfs_transaction_commit(struct super_block *sb)\n{\n\tstruct nilfs_transaction_info *ti = current->journal_info;\n\tstruct the_nilfs *nilfs = sb->s_fs_info;\n\tint err = 0;\n\n\tBUG_ON(ti == NULL || ti->ti_magic != NILFS_TI_MAGIC);\n\tti->ti_flags |= NILFS_TI_COMMIT;\n\tif (ti->ti_count > 0) {\n\t\tti->ti_count--;\n\t\treturn 0;\n\t}\n\tif (nilfs->ns_writer) {\n\t\tstruct nilfs_sc_info *sci = nilfs->ns_writer;\n\n\t\tif (ti->ti_flags & NILFS_TI_COMMIT)\n\t\t\tnilfs_segctor_start_timer(sci);\n\t\tif (atomic_read(&nilfs->ns_ndirtyblks) > sci->sc_watermark)\n\t\t\tnilfs_segctor_do_flush(sci, 0);\n\t}\n\tup_read(&nilfs->ns_segctor_sem);\n\tcurrent->journal_info = ti->ti_save;\n\n\tif (ti->ti_flags & NILFS_TI_SYNC)\n\t\terr = nilfs_construct_segment(sb);\n\tif (ti->ti_flags & NILFS_TI_DYNAMIC_ALLOC)\n\t\tkmem_cache_free(nilfs_transaction_cachep, ti);\n\tsb_end_intwrite(sb);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nilfs_transaction_abort",
          "args": [
            "inode->i_sb"
          ],
          "line": 1284
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_transaction_abort",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/segment.c",
          "lines": "254-270",
          "snippet": "void nilfs_transaction_abort(struct super_block *sb)\n{\n\tstruct nilfs_transaction_info *ti = current->journal_info;\n\tstruct the_nilfs *nilfs = sb->s_fs_info;\n\n\tBUG_ON(ti == NULL || ti->ti_magic != NILFS_TI_MAGIC);\n\tif (ti->ti_count > 0) {\n\t\tti->ti_count--;\n\t\treturn;\n\t}\n\tup_read(&nilfs->ns_segctor_sem);\n\n\tcurrent->journal_info = ti->ti_save;\n\tif (ti->ti_flags & NILFS_TI_DYNAMIC_ALLOC)\n\t\tkmem_cache_free(nilfs_transaction_cachep, ti);\n\tsb_end_intwrite(sb);\n}",
          "includes": [
            "#include \"segbuf.h\"",
            "#include \"ifile.h\"",
            "#include \"cpfile.h\"",
            "#include \"sufile.h\"",
            "#include \"segment.h\"",
            "#include \"page.h\"",
            "#include \"btnode.h\"",
            "#include \"nilfs.h\"",
            "#include <linux/slab.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/crc32.h>",
            "#include <linux/kthread.h>",
            "#include <linux/freezer.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/completion.h>",
            "#include <linux/bio.h>",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"segbuf.h\"\n#include \"ifile.h\"\n#include \"cpfile.h\"\n#include \"sufile.h\"\n#include \"segment.h\"\n#include \"page.h\"\n#include \"btnode.h\"\n#include \"nilfs.h\"\n#include <linux/slab.h>\n#include <linux/pagevec.h>\n#include <linux/crc32.h>\n#include <linux/kthread.h>\n#include <linux/freezer.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/completion.h>\n#include <linux/bio.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n\nvoid nilfs_transaction_abort(struct super_block *sb)\n{\n\tstruct nilfs_transaction_info *ti = current->journal_info;\n\tstruct the_nilfs *nilfs = sb->s_fs_info;\n\n\tBUG_ON(ti == NULL || ti->ti_magic != NILFS_TI_MAGIC);\n\tif (ti->ti_count > 0) {\n\t\tti->ti_count--;\n\t\treturn;\n\t}\n\tup_read(&nilfs->ns_segctor_sem);\n\n\tcurrent->journal_info = ti->ti_save;\n\tif (ti->ti_flags & NILFS_TI_DYNAMIC_ALLOC)\n\t\tkmem_cache_free(nilfs_transaction_cachep, ti);\n\tsb_end_intwrite(sb);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "ret < 0"
          ],
          "line": 1283
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nilfs_sufile_set_suinfo",
          "args": [
            "nilfs->ns_sufile",
            "kbuf",
            "argv.v_size",
            "argv.v_nmembs"
          ],
          "line": 1281
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_sufile_set_suinfo",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/sufile.c",
          "lines": "892-1001",
          "snippet": "ssize_t nilfs_sufile_set_suinfo(struct inode *sufile, void *buf,\n\t\t\t\tunsigned supsz, size_t nsup)\n{\n\tstruct the_nilfs *nilfs = sufile->i_sb->s_fs_info;\n\tstruct buffer_head *header_bh, *bh;\n\tstruct nilfs_suinfo_update *sup, *supend = buf + supsz * nsup;\n\tstruct nilfs_segment_usage *su;\n\tvoid *kaddr;\n\tunsigned long blkoff, prev_blkoff;\n\tint cleansi, cleansu, dirtysi, dirtysu;\n\tlong ncleaned = 0, ndirtied = 0;\n\tint ret = 0;\n\n\tif (unlikely(nsup == 0))\n\t\treturn ret;\n\n\tfor (sup = buf; sup < supend; sup = (void *)sup + supsz) {\n\t\tif (sup->sup_segnum >= nilfs->ns_nsegments\n\t\t\t|| (sup->sup_flags &\n\t\t\t\t(~0UL << __NR_NILFS_SUINFO_UPDATE_FIELDS))\n\t\t\t|| (nilfs_suinfo_update_nblocks(sup) &&\n\t\t\t\tsup->sup_sui.sui_nblocks >\n\t\t\t\tnilfs->ns_blocks_per_segment))\n\t\t\treturn -EINVAL;\n\t}\n\n\tdown_write(&NILFS_MDT(sufile)->mi_sem);\n\n\tret = nilfs_sufile_get_header_block(sufile, &header_bh);\n\tif (ret < 0)\n\t\tgoto out_sem;\n\n\tsup = buf;\n\tblkoff = nilfs_sufile_get_blkoff(sufile, sup->sup_segnum);\n\tret = nilfs_mdt_get_block(sufile, blkoff, 1, NULL, &bh);\n\tif (ret < 0)\n\t\tgoto out_header;\n\n\tfor (;;) {\n\t\tkaddr = kmap_atomic(bh->b_page);\n\t\tsu = nilfs_sufile_block_get_segment_usage(\n\t\t\tsufile, sup->sup_segnum, bh, kaddr);\n\n\t\tif (nilfs_suinfo_update_lastmod(sup))\n\t\t\tsu->su_lastmod = cpu_to_le64(sup->sup_sui.sui_lastmod);\n\n\t\tif (nilfs_suinfo_update_nblocks(sup))\n\t\t\tsu->su_nblocks = cpu_to_le32(sup->sup_sui.sui_nblocks);\n\n\t\tif (nilfs_suinfo_update_flags(sup)) {\n\t\t\t/*\n\t\t\t * Active flag is a virtual flag projected by running\n\t\t\t * nilfs kernel code - drop it not to write it to\n\t\t\t * disk.\n\t\t\t */\n\t\t\tsup->sup_sui.sui_flags &=\n\t\t\t\t\t~(1UL << NILFS_SEGMENT_USAGE_ACTIVE);\n\n\t\t\tcleansi = nilfs_suinfo_clean(&sup->sup_sui);\n\t\t\tcleansu = nilfs_segment_usage_clean(su);\n\t\t\tdirtysi = nilfs_suinfo_dirty(&sup->sup_sui);\n\t\t\tdirtysu = nilfs_segment_usage_dirty(su);\n\n\t\t\tif (cleansi && !cleansu)\n\t\t\t\t++ncleaned;\n\t\t\telse if (!cleansi && cleansu)\n\t\t\t\t--ncleaned;\n\n\t\t\tif (dirtysi && !dirtysu)\n\t\t\t\t++ndirtied;\n\t\t\telse if (!dirtysi && dirtysu)\n\t\t\t\t--ndirtied;\n\n\t\t\tsu->su_flags = cpu_to_le32(sup->sup_sui.sui_flags);\n\t\t}\n\n\t\tkunmap_atomic(kaddr);\n\n\t\tsup = (void *)sup + supsz;\n\t\tif (sup >= supend)\n\t\t\tbreak;\n\n\t\tprev_blkoff = blkoff;\n\t\tblkoff = nilfs_sufile_get_blkoff(sufile, sup->sup_segnum);\n\t\tif (blkoff == prev_blkoff)\n\t\t\tcontinue;\n\n\t\t/* get different block */\n\t\tmark_buffer_dirty(bh);\n\t\tput_bh(bh);\n\t\tret = nilfs_mdt_get_block(sufile, blkoff, 1, NULL, &bh);\n\t\tif (unlikely(ret < 0))\n\t\t\tgoto out_mark;\n\t}\n\tmark_buffer_dirty(bh);\n\tput_bh(bh);\n\n out_mark:\n\tif (ncleaned || ndirtied) {\n\t\tnilfs_sufile_mod_counter(header_bh, (u64)ncleaned,\n\t\t\t\t(u64)ndirtied);\n\t\tNILFS_SUI(sufile)->ncleansegs += ncleaned;\n\t}\n\tnilfs_mdt_mark_dirty(sufile);\n out_header:\n\tput_bh(header_bh);\n out_sem:\n\tup_write(&NILFS_MDT(sufile)->mi_sem);\n\treturn ret;\n}",
          "includes": [
            "#include \"sufile.h\"",
            "#include \"mdt.h\"",
            "#include <linux/nilfs2_fs.h>",
            "#include <linux/errno.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/fs.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sufile.h\"\n#include \"mdt.h\"\n#include <linux/nilfs2_fs.h>\n#include <linux/errno.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/fs.h>\n#include <linux/kernel.h>\n\nssize_t nilfs_sufile_set_suinfo(struct inode *sufile, void *buf,\n\t\t\t\tunsigned supsz, size_t nsup)\n{\n\tstruct the_nilfs *nilfs = sufile->i_sb->s_fs_info;\n\tstruct buffer_head *header_bh, *bh;\n\tstruct nilfs_suinfo_update *sup, *supend = buf + supsz * nsup;\n\tstruct nilfs_segment_usage *su;\n\tvoid *kaddr;\n\tunsigned long blkoff, prev_blkoff;\n\tint cleansi, cleansu, dirtysi, dirtysu;\n\tlong ncleaned = 0, ndirtied = 0;\n\tint ret = 0;\n\n\tif (unlikely(nsup == 0))\n\t\treturn ret;\n\n\tfor (sup = buf; sup < supend; sup = (void *)sup + supsz) {\n\t\tif (sup->sup_segnum >= nilfs->ns_nsegments\n\t\t\t|| (sup->sup_flags &\n\t\t\t\t(~0UL << __NR_NILFS_SUINFO_UPDATE_FIELDS))\n\t\t\t|| (nilfs_suinfo_update_nblocks(sup) &&\n\t\t\t\tsup->sup_sui.sui_nblocks >\n\t\t\t\tnilfs->ns_blocks_per_segment))\n\t\t\treturn -EINVAL;\n\t}\n\n\tdown_write(&NILFS_MDT(sufile)->mi_sem);\n\n\tret = nilfs_sufile_get_header_block(sufile, &header_bh);\n\tif (ret < 0)\n\t\tgoto out_sem;\n\n\tsup = buf;\n\tblkoff = nilfs_sufile_get_blkoff(sufile, sup->sup_segnum);\n\tret = nilfs_mdt_get_block(sufile, blkoff, 1, NULL, &bh);\n\tif (ret < 0)\n\t\tgoto out_header;\n\n\tfor (;;) {\n\t\tkaddr = kmap_atomic(bh->b_page);\n\t\tsu = nilfs_sufile_block_get_segment_usage(\n\t\t\tsufile, sup->sup_segnum, bh, kaddr);\n\n\t\tif (nilfs_suinfo_update_lastmod(sup))\n\t\t\tsu->su_lastmod = cpu_to_le64(sup->sup_sui.sui_lastmod);\n\n\t\tif (nilfs_suinfo_update_nblocks(sup))\n\t\t\tsu->su_nblocks = cpu_to_le32(sup->sup_sui.sui_nblocks);\n\n\t\tif (nilfs_suinfo_update_flags(sup)) {\n\t\t\t/*\n\t\t\t * Active flag is a virtual flag projected by running\n\t\t\t * nilfs kernel code - drop it not to write it to\n\t\t\t * disk.\n\t\t\t */\n\t\t\tsup->sup_sui.sui_flags &=\n\t\t\t\t\t~(1UL << NILFS_SEGMENT_USAGE_ACTIVE);\n\n\t\t\tcleansi = nilfs_suinfo_clean(&sup->sup_sui);\n\t\t\tcleansu = nilfs_segment_usage_clean(su);\n\t\t\tdirtysi = nilfs_suinfo_dirty(&sup->sup_sui);\n\t\t\tdirtysu = nilfs_segment_usage_dirty(su);\n\n\t\t\tif (cleansi && !cleansu)\n\t\t\t\t++ncleaned;\n\t\t\telse if (!cleansi && cleansu)\n\t\t\t\t--ncleaned;\n\n\t\t\tif (dirtysi && !dirtysu)\n\t\t\t\t++ndirtied;\n\t\t\telse if (!dirtysi && dirtysu)\n\t\t\t\t--ndirtied;\n\n\t\t\tsu->su_flags = cpu_to_le32(sup->sup_sui.sui_flags);\n\t\t}\n\n\t\tkunmap_atomic(kaddr);\n\n\t\tsup = (void *)sup + supsz;\n\t\tif (sup >= supend)\n\t\t\tbreak;\n\n\t\tprev_blkoff = blkoff;\n\t\tblkoff = nilfs_sufile_get_blkoff(sufile, sup->sup_segnum);\n\t\tif (blkoff == prev_blkoff)\n\t\t\tcontinue;\n\n\t\t/* get different block */\n\t\tmark_buffer_dirty(bh);\n\t\tput_bh(bh);\n\t\tret = nilfs_mdt_get_block(sufile, blkoff, 1, NULL, &bh);\n\t\tif (unlikely(ret < 0))\n\t\t\tgoto out_mark;\n\t}\n\tmark_buffer_dirty(bh);\n\tput_bh(bh);\n\n out_mark:\n\tif (ncleaned || ndirtied) {\n\t\tnilfs_sufile_mod_counter(header_bh, (u64)ncleaned,\n\t\t\t\t(u64)ndirtied);\n\t\tNILFS_SUI(sufile)->ncleansegs += ncleaned;\n\t}\n\tnilfs_mdt_mark_dirty(sufile);\n out_header:\n\tput_bh(header_bh);\n out_sem:\n\tup_write(&NILFS_MDT(sufile)->mi_sem);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nilfs_transaction_begin",
          "args": [
            "inode->i_sb",
            "&ti",
            "0"
          ],
          "line": 1280
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_transaction_begin",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/segment.c",
          "lines": "180-210",
          "snippet": "int nilfs_transaction_begin(struct super_block *sb,\n\t\t\t    struct nilfs_transaction_info *ti,\n\t\t\t    int vacancy_check)\n{\n\tstruct the_nilfs *nilfs;\n\tint ret = nilfs_prepare_segment_lock(ti);\n\n\tif (unlikely(ret < 0))\n\t\treturn ret;\n\tif (ret > 0)\n\t\treturn 0;\n\n\tsb_start_intwrite(sb);\n\n\tnilfs = sb->s_fs_info;\n\tdown_read(&nilfs->ns_segctor_sem);\n\tif (vacancy_check && nilfs_near_disk_full(nilfs)) {\n\t\tup_read(&nilfs->ns_segctor_sem);\n\t\tret = -ENOSPC;\n\t\tgoto failed;\n\t}\n\treturn 0;\n\n failed:\n\tti = current->journal_info;\n\tcurrent->journal_info = ti->ti_save;\n\tif (ti->ti_flags & NILFS_TI_DYNAMIC_ALLOC)\n\t\tkmem_cache_free(nilfs_transaction_cachep, ti);\n\tsb_end_intwrite(sb);\n\treturn ret;\n}",
          "includes": [
            "#include \"segbuf.h\"",
            "#include \"ifile.h\"",
            "#include \"cpfile.h\"",
            "#include \"sufile.h\"",
            "#include \"segment.h\"",
            "#include \"page.h\"",
            "#include \"btnode.h\"",
            "#include \"nilfs.h\"",
            "#include <linux/slab.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/crc32.h>",
            "#include <linux/kthread.h>",
            "#include <linux/freezer.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/completion.h>",
            "#include <linux/bio.h>",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"segbuf.h\"\n#include \"ifile.h\"\n#include \"cpfile.h\"\n#include \"sufile.h\"\n#include \"segment.h\"\n#include \"page.h\"\n#include \"btnode.h\"\n#include \"nilfs.h\"\n#include <linux/slab.h>\n#include <linux/pagevec.h>\n#include <linux/crc32.h>\n#include <linux/kthread.h>\n#include <linux/freezer.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/completion.h>\n#include <linux/bio.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n\nint nilfs_transaction_begin(struct super_block *sb,\n\t\t\t    struct nilfs_transaction_info *ti,\n\t\t\t    int vacancy_check)\n{\n\tstruct the_nilfs *nilfs;\n\tint ret = nilfs_prepare_segment_lock(ti);\n\n\tif (unlikely(ret < 0))\n\t\treturn ret;\n\tif (ret > 0)\n\t\treturn 0;\n\n\tsb_start_intwrite(sb);\n\n\tnilfs = sb->s_fs_info;\n\tdown_read(&nilfs->ns_segctor_sem);\n\tif (vacancy_check && nilfs_near_disk_full(nilfs)) {\n\t\tup_read(&nilfs->ns_segctor_sem);\n\t\tret = -ENOSPC;\n\t\tgoto failed;\n\t}\n\treturn 0;\n\n failed:\n\tti = current->journal_info;\n\tcurrent->journal_info = ti->ti_save;\n\tif (ti->ti_flags & NILFS_TI_DYNAMIC_ALLOC)\n\t\tkmem_cache_free(nilfs_transaction_cachep, ti);\n\tsb_end_intwrite(sb);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "copy_from_user",
          "args": [
            "kbuf",
            "base",
            "len"
          ],
          "line": 1275
        },
        "resolved": true,
        "details": {
          "function_name": "exact_copy_from_user",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namespace.c",
          "lines": "2514-2534",
          "snippet": "static long exact_copy_from_user(void *to, const void __user * from,\n\t\t\t\t unsigned long n)\n{\n\tchar *t = to;\n\tconst char __user *f = from;\n\tchar c;\n\n\tif (!access_ok(VERIFY_READ, from, n))\n\t\treturn n;\n\n\twhile (n) {\n\t\tif (__get_user(c, f)) {\n\t\t\tmemset(t, 0, n);\n\t\t\tbreak;\n\t\t}\n\t\t*t++ = c;\n\t\tf++;\n\t\tn--;\n\t}\n\treturn n;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"pnode.h\"",
            "#include <linux/task_work.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/magic.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
            "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
            "#include <linux/init.h>\t\t/* init_rootfs */",
            "#include <linux/idr.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/mnt_namespace.h>",
            "#include <linux/capability.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/task_work.h>\n#include <linux/bootmem.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic long exact_copy_from_user(void *to, const void __user * from,\n\t\t\t\t unsigned long n)\n{\n\tchar *t = to;\n\tconst char __user *f = from;\n\tchar c;\n\n\tif (!access_ok(VERIFY_READ, from, n))\n\t\treturn n;\n\n\twhile (n) {\n\t\tif (__get_user(c, f)) {\n\t\t\tmemset(t, 0, n);\n\t\t\tbreak;\n\t\t}\n\t\t*t++ = c;\n\t\tf++;\n\t\tn--;\n\t}\n\treturn n;\n}"
        }
      },
      {
        "call_info": {
          "callee": "vmalloc",
          "args": [
            "len"
          ],
          "line": 1269
        },
        "resolved": true,
        "details": {
          "function_name": "ffs2_blocks_use_vmalloc(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jffs2/nodelist.h",
          "lines": "292-295",
          "snippet": "tatic inline int jffs2_blocks_use_vmalloc(struct jffs2_sb_info *c)\n{\n\treturn ((c->flash_size / c->sector_size) * sizeof (struct jffs2_eraseblock)) > (128 * 1024);\n}",
          "includes": [
            "include \"debug.h\"",
            "include \"os-linux.h\"\n#",
            "include \"os-ecos.h\"\n#",
            "include \"summary.h\"",
            "include \"acl.h\"\n#",
            "include \"xattr.h\"\n#",
            "include \"jffs2_fs_i.h\"\n#",
            "include \"jffs2_fs_sb.h\"\n#",
            "include <linux/jffs2.h>\n#",
            "include <linux/types.h>\n#",
            "include <linux/fs.h>\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"debug.h\"\ninclude \"os-linux.h\"\n#\ninclude \"os-ecos.h\"\n#\ninclude \"summary.h\"\ninclude \"acl.h\"\n#\ninclude \"xattr.h\"\n#\ninclude \"jffs2_fs_i.h\"\n#\ninclude \"jffs2_fs_sb.h\"\n#\ninclude <linux/jffs2.h>\n#\ninclude <linux/types.h>\n#\ninclude <linux/fs.h>\n#\n\ntatic inline int jffs2_blocks_use_vmalloc(struct jffs2_sb_info *c)\n{\n\treturn ((c->flash_size / c->sector_size) * sizeof (struct jffs2_eraseblock)) > (128 * 1024);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mnt_want_write_file",
          "args": [
            "filp"
          ],
          "line": 1244
        },
        "resolved": true,
        "details": {
          "function_name": "mnt_want_write_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namespace.c",
          "lines": "440-449",
          "snippet": "int mnt_want_write_file(struct file *file)\n{\n\tint ret;\n\n\tsb_start_write(file->f_path.mnt->mnt_sb);\n\tret = __mnt_want_write_file(file);\n\tif (ret)\n\t\tsb_end_write(file->f_path.mnt->mnt_sb);\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"pnode.h\"",
            "#include <linux/task_work.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/magic.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
            "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
            "#include <linux/init.h>\t\t/* init_rootfs */",
            "#include <linux/idr.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/mnt_namespace.h>",
            "#include <linux/capability.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void shrink_submounts(struct mount *mnt);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/task_work.h>\n#include <linux/bootmem.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic void shrink_submounts(struct mount *mnt);\n\nint mnt_want_write_file(struct file *file)\n{\n\tint ret;\n\n\tsb_start_write(file->f_path.mnt->mnt_sb);\n\tret = __mnt_want_write_file(file);\n\tif (ret)\n\t\tsb_end_write(file->f_path.mnt->mnt_sb);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "capable",
          "args": [
            "CAP_SYS_ADMIN"
          ],
          "line": 1241
        },
        "resolved": true,
        "details": {
          "function_name": "inode_owner_or_capable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "1901-1912",
          "snippet": "bool inode_owner_or_capable(const struct inode *inode)\n{\n\tstruct user_namespace *ns;\n\n\tif (uid_eq(current_fsuid(), inode->i_uid))\n\t\treturn true;\n\n\tns = current_user_ns();\n\tif (ns_capable(ns, CAP_FOWNER) && kuid_has_mapping(ns, inode->i_uid))\n\t\treturn true;\n\treturn false;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nbool inode_owner_or_capable(const struct inode *inode)\n{\n\tstruct user_namespace *ns;\n\n\tif (uid_eq(current_fsuid(), inode->i_uid))\n\t\treturn true;\n\n\tns = current_user_ns();\n\tif (ns_capable(ns, CAP_FOWNER) && kuid_has_mapping(ns, inode->i_uid))\n\t\treturn true;\n\treturn false;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"dat.h\"\n#include \"sufile.h\"\n#include \"cpfile.h\"\n#include \"bmap.h\"\n#include \"segment.h\"\n#include \"nilfs.h\"\n#include <linux/nilfs2_fs.h>\n#include <linux/buffer_head.h>\n#include <linux/mount.h>\t/* mnt_want_write_file(), mnt_drop_write_file() */\n#include <linux/compat.h>\t/* compat_ptr() */\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\t/* copy_from_user(), copy_to_user() */\n#include <linux/capability.h>\t/* capable() */\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/fs.h>\n\nstatic int nilfs_ioctl_set_suinfo(struct inode *inode, struct file *filp,\n\t\t\t\tunsigned int cmd, void __user *argp)\n{\n\tstruct the_nilfs *nilfs = inode->i_sb->s_fs_info;\n\tstruct nilfs_transaction_info ti;\n\tstruct nilfs_argv argv;\n\tsize_t len;\n\tvoid __user *base;\n\tvoid *kbuf;\n\tint ret;\n\n\tif (!capable(CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\n\tret = mnt_want_write_file(filp);\n\tif (ret)\n\t\treturn ret;\n\n\tret = -EFAULT;\n\tif (copy_from_user(&argv, argp, sizeof(argv)))\n\t\tgoto out;\n\n\tret = -EINVAL;\n\tif (argv.v_size < sizeof(struct nilfs_suinfo_update))\n\t\tgoto out;\n\n\tif (argv.v_nmembs > nilfs->ns_nsegments)\n\t\tgoto out;\n\n\tif (argv.v_nmembs >= UINT_MAX / argv.v_size)\n\t\tgoto out;\n\n\tlen = argv.v_size * argv.v_nmembs;\n\tif (!len) {\n\t\tret = 0;\n\t\tgoto out;\n\t}\n\n\tbase = (void __user *)(unsigned long)argv.v_base;\n\tkbuf = vmalloc(len);\n\tif (!kbuf) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tif (copy_from_user(kbuf, base, len)) {\n\t\tret = -EFAULT;\n\t\tgoto out_free;\n\t}\n\n\tnilfs_transaction_begin(inode->i_sb, &ti, 0);\n\tret = nilfs_sufile_set_suinfo(nilfs->ns_sufile, kbuf, argv.v_size,\n\t\t\targv.v_nmembs);\n\tif (unlikely(ret < 0))\n\t\tnilfs_transaction_abort(inode->i_sb);\n\telse\n\t\tnilfs_transaction_commit(inode->i_sb); /* never fails */\n\nout_free:\n\tvfree(kbuf);\nout:\n\tmnt_drop_write_file(filp);\n\treturn ret;\n}"
  },
  {
    "function_name": "nilfs_ioctl_get_info",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/ioctl.c",
    "lines": "1179-1204",
    "snippet": "static int nilfs_ioctl_get_info(struct inode *inode, struct file *filp,\n\t\t\t\tunsigned int cmd, void __user *argp,\n\t\t\t\tsize_t membsz,\n\t\t\t\tssize_t (*dofunc)(struct the_nilfs *,\n\t\t\t\t\t\t  __u64 *, int,\n\t\t\t\t\t\t  void *, size_t, size_t))\n\n{\n\tstruct the_nilfs *nilfs = inode->i_sb->s_fs_info;\n\tstruct nilfs_argv argv;\n\tint ret;\n\n\tif (copy_from_user(&argv, argp, sizeof(argv)))\n\t\treturn -EFAULT;\n\n\tif (argv.v_size < membsz)\n\t\treturn -EINVAL;\n\n\tret = nilfs_ioctl_wrap_copy(nilfs, &argv, _IOC_DIR(cmd), dofunc);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (copy_to_user(argp, &argv, sizeof(argv)))\n\t\tret = -EFAULT;\n\treturn ret;\n}",
    "includes": [
      "#include \"dat.h\"",
      "#include \"sufile.h\"",
      "#include \"cpfile.h\"",
      "#include \"bmap.h\"",
      "#include \"segment.h\"",
      "#include \"nilfs.h\"",
      "#include <linux/nilfs2_fs.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/mount.h>\t/* mnt_want_write_file(), mnt_drop_write_file() */",
      "#include <linux/compat.h>\t/* compat_ptr() */",
      "#include <linux/vmalloc.h>",
      "#include <linux/uaccess.h>\t/* copy_from_user(), copy_to_user() */",
      "#include <linux/capability.h>\t/* capable() */",
      "#include <linux/slab.h>",
      "#include <linux/wait.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "copy_to_user",
          "args": [
            "argp",
            "&argv",
            "sizeof(argv)"
          ],
          "line": 1201
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nilfs_ioctl_wrap_copy",
          "args": [
            "nilfs",
            "&argv",
            "_IOC_DIR(cmd)",
            "dofunc"
          ],
          "line": 1197
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_ioctl_wrap_copy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/ioctl.c",
          "lines": "60-127",
          "snippet": "static int nilfs_ioctl_wrap_copy(struct the_nilfs *nilfs,\n\t\t\t\t struct nilfs_argv *argv, int dir,\n\t\t\t\t ssize_t (*dofunc)(struct the_nilfs *,\n\t\t\t\t\t\t   __u64 *, int,\n\t\t\t\t\t\t   void *, size_t, size_t))\n{\n\tvoid *buf;\n\tvoid __user *base = (void __user *)(unsigned long)argv->v_base;\n\tsize_t maxmembs, total, n;\n\tssize_t nr;\n\tint ret, i;\n\t__u64 pos, ppos;\n\n\tif (argv->v_nmembs == 0)\n\t\treturn 0;\n\n\tif (argv->v_size > PAGE_SIZE)\n\t\treturn -EINVAL;\n\n\t/*\n\t * Reject pairs of a start item position (argv->v_index) and a\n\t * total count (argv->v_nmembs) which leads position 'pos' to\n\t * overflow by the increment at the end of the loop.\n\t */\n\tif (argv->v_index > ~(__u64)0 - argv->v_nmembs)\n\t\treturn -EINVAL;\n\n\tbuf = (void *)__get_free_pages(GFP_NOFS, 0);\n\tif (unlikely(!buf))\n\t\treturn -ENOMEM;\n\tmaxmembs = PAGE_SIZE / argv->v_size;\n\n\tret = 0;\n\ttotal = 0;\n\tpos = argv->v_index;\n\tfor (i = 0; i < argv->v_nmembs; i += n) {\n\t\tn = (argv->v_nmembs - i < maxmembs) ?\n\t\t\targv->v_nmembs - i : maxmembs;\n\t\tif ((dir & _IOC_WRITE) &&\n\t\t    copy_from_user(buf, base + argv->v_size * i,\n\t\t\t\t   argv->v_size * n)) {\n\t\t\tret = -EFAULT;\n\t\t\tbreak;\n\t\t}\n\t\tppos = pos;\n\t\tnr = dofunc(nilfs, &pos, argv->v_flags, buf, argv->v_size,\n\t\t\t       n);\n\t\tif (nr < 0) {\n\t\t\tret = nr;\n\t\t\tbreak;\n\t\t}\n\t\tif ((dir & _IOC_READ) &&\n\t\t    copy_to_user(base + argv->v_size * i, buf,\n\t\t\t\t argv->v_size * nr)) {\n\t\t\tret = -EFAULT;\n\t\t\tbreak;\n\t\t}\n\t\ttotal += nr;\n\t\tif ((size_t)nr < n)\n\t\t\tbreak;\n\t\tif (pos == ppos)\n\t\t\tpos += n;\n\t}\n\targv->v_nmembs = total;\n\n\tfree_pages((unsigned long)buf, 0);\n\treturn ret;\n}",
          "includes": [
            "#include \"dat.h\"",
            "#include \"sufile.h\"",
            "#include \"cpfile.h\"",
            "#include \"bmap.h\"",
            "#include \"segment.h\"",
            "#include \"nilfs.h\"",
            "#include <linux/nilfs2_fs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/mount.h>\t/* mnt_want_write_file(), mnt_drop_write_file() */",
            "#include <linux/compat.h>\t/* compat_ptr() */",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>\t/* copy_from_user(), copy_to_user() */",
            "#include <linux/capability.h>\t/* capable() */",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"dat.h\"\n#include \"sufile.h\"\n#include \"cpfile.h\"\n#include \"bmap.h\"\n#include \"segment.h\"\n#include \"nilfs.h\"\n#include <linux/nilfs2_fs.h>\n#include <linux/buffer_head.h>\n#include <linux/mount.h>\t/* mnt_want_write_file(), mnt_drop_write_file() */\n#include <linux/compat.h>\t/* compat_ptr() */\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\t/* copy_from_user(), copy_to_user() */\n#include <linux/capability.h>\t/* capable() */\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/fs.h>\n\nstatic int nilfs_ioctl_wrap_copy(struct the_nilfs *nilfs,\n\t\t\t\t struct nilfs_argv *argv, int dir,\n\t\t\t\t ssize_t (*dofunc)(struct the_nilfs *,\n\t\t\t\t\t\t   __u64 *, int,\n\t\t\t\t\t\t   void *, size_t, size_t))\n{\n\tvoid *buf;\n\tvoid __user *base = (void __user *)(unsigned long)argv->v_base;\n\tsize_t maxmembs, total, n;\n\tssize_t nr;\n\tint ret, i;\n\t__u64 pos, ppos;\n\n\tif (argv->v_nmembs == 0)\n\t\treturn 0;\n\n\tif (argv->v_size > PAGE_SIZE)\n\t\treturn -EINVAL;\n\n\t/*\n\t * Reject pairs of a start item position (argv->v_index) and a\n\t * total count (argv->v_nmembs) which leads position 'pos' to\n\t * overflow by the increment at the end of the loop.\n\t */\n\tif (argv->v_index > ~(__u64)0 - argv->v_nmembs)\n\t\treturn -EINVAL;\n\n\tbuf = (void *)__get_free_pages(GFP_NOFS, 0);\n\tif (unlikely(!buf))\n\t\treturn -ENOMEM;\n\tmaxmembs = PAGE_SIZE / argv->v_size;\n\n\tret = 0;\n\ttotal = 0;\n\tpos = argv->v_index;\n\tfor (i = 0; i < argv->v_nmembs; i += n) {\n\t\tn = (argv->v_nmembs - i < maxmembs) ?\n\t\t\targv->v_nmembs - i : maxmembs;\n\t\tif ((dir & _IOC_WRITE) &&\n\t\t    copy_from_user(buf, base + argv->v_size * i,\n\t\t\t\t   argv->v_size * n)) {\n\t\t\tret = -EFAULT;\n\t\t\tbreak;\n\t\t}\n\t\tppos = pos;\n\t\tnr = dofunc(nilfs, &pos, argv->v_flags, buf, argv->v_size,\n\t\t\t       n);\n\t\tif (nr < 0) {\n\t\t\tret = nr;\n\t\t\tbreak;\n\t\t}\n\t\tif ((dir & _IOC_READ) &&\n\t\t    copy_to_user(base + argv->v_size * i, buf,\n\t\t\t\t argv->v_size * nr)) {\n\t\t\tret = -EFAULT;\n\t\t\tbreak;\n\t\t}\n\t\ttotal += nr;\n\t\tif ((size_t)nr < n)\n\t\t\tbreak;\n\t\tif (pos == ppos)\n\t\t\tpos += n;\n\t}\n\targv->v_nmembs = total;\n\n\tfree_pages((unsigned long)buf, 0);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "_IOC_DIR",
          "args": [
            "cmd"
          ],
          "line": 1197
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "copy_from_user",
          "args": [
            "&argv",
            "argp",
            "sizeof(argv)"
          ],
          "line": 1191
        },
        "resolved": true,
        "details": {
          "function_name": "exact_copy_from_user",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namespace.c",
          "lines": "2514-2534",
          "snippet": "static long exact_copy_from_user(void *to, const void __user * from,\n\t\t\t\t unsigned long n)\n{\n\tchar *t = to;\n\tconst char __user *f = from;\n\tchar c;\n\n\tif (!access_ok(VERIFY_READ, from, n))\n\t\treturn n;\n\n\twhile (n) {\n\t\tif (__get_user(c, f)) {\n\t\t\tmemset(t, 0, n);\n\t\t\tbreak;\n\t\t}\n\t\t*t++ = c;\n\t\tf++;\n\t\tn--;\n\t}\n\treturn n;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"pnode.h\"",
            "#include <linux/task_work.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/magic.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
            "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
            "#include <linux/init.h>\t\t/* init_rootfs */",
            "#include <linux/idr.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/mnt_namespace.h>",
            "#include <linux/capability.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/task_work.h>\n#include <linux/bootmem.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic long exact_copy_from_user(void *to, const void __user * from,\n\t\t\t\t unsigned long n)\n{\n\tchar *t = to;\n\tconst char __user *f = from;\n\tchar c;\n\n\tif (!access_ok(VERIFY_READ, from, n))\n\t\treturn n;\n\n\twhile (n) {\n\t\tif (__get_user(c, f)) {\n\t\t\tmemset(t, 0, n);\n\t\t\tbreak;\n\t\t}\n\t\t*t++ = c;\n\t\tf++;\n\t\tn--;\n\t}\n\treturn n;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"dat.h\"\n#include \"sufile.h\"\n#include \"cpfile.h\"\n#include \"bmap.h\"\n#include \"segment.h\"\n#include \"nilfs.h\"\n#include <linux/nilfs2_fs.h>\n#include <linux/buffer_head.h>\n#include <linux/mount.h>\t/* mnt_want_write_file(), mnt_drop_write_file() */\n#include <linux/compat.h>\t/* compat_ptr() */\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\t/* copy_from_user(), copy_to_user() */\n#include <linux/capability.h>\t/* capable() */\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/fs.h>\n\nstatic int nilfs_ioctl_get_info(struct inode *inode, struct file *filp,\n\t\t\t\tunsigned int cmd, void __user *argp,\n\t\t\t\tsize_t membsz,\n\t\t\t\tssize_t (*dofunc)(struct the_nilfs *,\n\t\t\t\t\t\t  __u64 *, int,\n\t\t\t\t\t\t  void *, size_t, size_t))\n\n{\n\tstruct the_nilfs *nilfs = inode->i_sb->s_fs_info;\n\tstruct nilfs_argv argv;\n\tint ret;\n\n\tif (copy_from_user(&argv, argp, sizeof(argv)))\n\t\treturn -EFAULT;\n\n\tif (argv.v_size < membsz)\n\t\treturn -EINVAL;\n\n\tret = nilfs_ioctl_wrap_copy(nilfs, &argv, _IOC_DIR(cmd), dofunc);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (copy_to_user(argp, &argv, sizeof(argv)))\n\t\tret = -EFAULT;\n\treturn ret;\n}"
  },
  {
    "function_name": "nilfs_ioctl_set_alloc_range",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/ioctl.c",
    "lines": "1125-1155",
    "snippet": "static int nilfs_ioctl_set_alloc_range(struct inode *inode, void __user *argp)\n{\n\tstruct the_nilfs *nilfs = inode->i_sb->s_fs_info;\n\t__u64 range[2];\n\t__u64 minseg, maxseg;\n\tunsigned long segbytes;\n\tint ret = -EPERM;\n\n\tif (!capable(CAP_SYS_ADMIN))\n\t\tgoto out;\n\n\tret = -EFAULT;\n\tif (copy_from_user(range, argp, sizeof(__u64[2])))\n\t\tgoto out;\n\n\tret = -ERANGE;\n\tif (range[1] > i_size_read(inode->i_sb->s_bdev->bd_inode))\n\t\tgoto out;\n\n\tsegbytes = nilfs->ns_blocks_per_segment * nilfs->ns_blocksize;\n\n\tminseg = range[0] + segbytes - 1;\n\tdo_div(minseg, segbytes);\n\tmaxseg = NILFS_SB2_OFFSET_BYTES(range[1]);\n\tdo_div(maxseg, segbytes);\n\tmaxseg--;\n\n\tret = nilfs_sufile_set_alloc_range(nilfs->ns_sufile, minseg, maxseg);\nout:\n\treturn ret;\n}",
    "includes": [
      "#include \"dat.h\"",
      "#include \"sufile.h\"",
      "#include \"cpfile.h\"",
      "#include \"bmap.h\"",
      "#include \"segment.h\"",
      "#include \"nilfs.h\"",
      "#include <linux/nilfs2_fs.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/mount.h>\t/* mnt_want_write_file(), mnt_drop_write_file() */",
      "#include <linux/compat.h>\t/* compat_ptr() */",
      "#include <linux/vmalloc.h>",
      "#include <linux/uaccess.h>\t/* copy_from_user(), copy_to_user() */",
      "#include <linux/capability.h>\t/* capable() */",
      "#include <linux/slab.h>",
      "#include <linux/wait.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "nilfs_sufile_set_alloc_range",
          "args": [
            "nilfs->ns_sufile",
            "minseg",
            "maxseg"
          ],
          "line": 1152
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_sufile_set_alloc_range",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/sufile.c",
          "lines": "276-292",
          "snippet": "int nilfs_sufile_set_alloc_range(struct inode *sufile, __u64 start, __u64 end)\n{\n\tstruct nilfs_sufile_info *sui = NILFS_SUI(sufile);\n\t__u64 nsegs;\n\tint ret = -ERANGE;\n\n\tdown_write(&NILFS_MDT(sufile)->mi_sem);\n\tnsegs = nilfs_sufile_get_nsegments(sufile);\n\n\tif (start <= end && end < nsegs) {\n\t\tsui->allocmin = start;\n\t\tsui->allocmax = end;\n\t\tret = 0;\n\t}\n\tup_write(&NILFS_MDT(sufile)->mi_sem);\n\treturn ret;\n}",
          "includes": [
            "#include \"sufile.h\"",
            "#include \"mdt.h\"",
            "#include <linux/nilfs2_fs.h>",
            "#include <linux/errno.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/fs.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sufile.h\"\n#include \"mdt.h\"\n#include <linux/nilfs2_fs.h>\n#include <linux/errno.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/fs.h>\n#include <linux/kernel.h>\n\nint nilfs_sufile_set_alloc_range(struct inode *sufile, __u64 start, __u64 end)\n{\n\tstruct nilfs_sufile_info *sui = NILFS_SUI(sufile);\n\t__u64 nsegs;\n\tint ret = -ERANGE;\n\n\tdown_write(&NILFS_MDT(sufile)->mi_sem);\n\tnsegs = nilfs_sufile_get_nsegments(sufile);\n\n\tif (start <= end && end < nsegs) {\n\t\tsui->allocmin = start;\n\t\tsui->allocmax = end;\n\t\tret = 0;\n\t}\n\tup_write(&NILFS_MDT(sufile)->mi_sem);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "do_div",
          "args": [
            "maxseg",
            "segbytes"
          ],
          "line": 1149
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NILFS_SB2_OFFSET_BYTES",
          "args": [
            "range[1]"
          ],
          "line": 1148
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "do_div",
          "args": [
            "minseg",
            "segbytes"
          ],
          "line": 1147
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "i_size_read",
          "args": [
            "inode->i_sb->s_bdev->bd_inode"
          ],
          "line": 1141
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "copy_from_user",
          "args": [
            "range",
            "argp",
            "sizeof(__u64[2])"
          ],
          "line": 1137
        },
        "resolved": true,
        "details": {
          "function_name": "exact_copy_from_user",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namespace.c",
          "lines": "2514-2534",
          "snippet": "static long exact_copy_from_user(void *to, const void __user * from,\n\t\t\t\t unsigned long n)\n{\n\tchar *t = to;\n\tconst char __user *f = from;\n\tchar c;\n\n\tif (!access_ok(VERIFY_READ, from, n))\n\t\treturn n;\n\n\twhile (n) {\n\t\tif (__get_user(c, f)) {\n\t\t\tmemset(t, 0, n);\n\t\t\tbreak;\n\t\t}\n\t\t*t++ = c;\n\t\tf++;\n\t\tn--;\n\t}\n\treturn n;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"pnode.h\"",
            "#include <linux/task_work.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/magic.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
            "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
            "#include <linux/init.h>\t\t/* init_rootfs */",
            "#include <linux/idr.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/mnt_namespace.h>",
            "#include <linux/capability.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/task_work.h>\n#include <linux/bootmem.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic long exact_copy_from_user(void *to, const void __user * from,\n\t\t\t\t unsigned long n)\n{\n\tchar *t = to;\n\tconst char __user *f = from;\n\tchar c;\n\n\tif (!access_ok(VERIFY_READ, from, n))\n\t\treturn n;\n\n\twhile (n) {\n\t\tif (__get_user(c, f)) {\n\t\t\tmemset(t, 0, n);\n\t\t\tbreak;\n\t\t}\n\t\t*t++ = c;\n\t\tf++;\n\t\tn--;\n\t}\n\treturn n;\n}"
        }
      },
      {
        "call_info": {
          "callee": "capable",
          "args": [
            "CAP_SYS_ADMIN"
          ],
          "line": 1133
        },
        "resolved": true,
        "details": {
          "function_name": "inode_owner_or_capable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "1901-1912",
          "snippet": "bool inode_owner_or_capable(const struct inode *inode)\n{\n\tstruct user_namespace *ns;\n\n\tif (uid_eq(current_fsuid(), inode->i_uid))\n\t\treturn true;\n\n\tns = current_user_ns();\n\tif (ns_capable(ns, CAP_FOWNER) && kuid_has_mapping(ns, inode->i_uid))\n\t\treturn true;\n\treturn false;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nbool inode_owner_or_capable(const struct inode *inode)\n{\n\tstruct user_namespace *ns;\n\n\tif (uid_eq(current_fsuid(), inode->i_uid))\n\t\treturn true;\n\n\tns = current_user_ns();\n\tif (ns_capable(ns, CAP_FOWNER) && kuid_has_mapping(ns, inode->i_uid))\n\t\treturn true;\n\treturn false;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"dat.h\"\n#include \"sufile.h\"\n#include \"cpfile.h\"\n#include \"bmap.h\"\n#include \"segment.h\"\n#include \"nilfs.h\"\n#include <linux/nilfs2_fs.h>\n#include <linux/buffer_head.h>\n#include <linux/mount.h>\t/* mnt_want_write_file(), mnt_drop_write_file() */\n#include <linux/compat.h>\t/* compat_ptr() */\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\t/* copy_from_user(), copy_to_user() */\n#include <linux/capability.h>\t/* capable() */\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/fs.h>\n\nstatic int nilfs_ioctl_set_alloc_range(struct inode *inode, void __user *argp)\n{\n\tstruct the_nilfs *nilfs = inode->i_sb->s_fs_info;\n\t__u64 range[2];\n\t__u64 minseg, maxseg;\n\tunsigned long segbytes;\n\tint ret = -EPERM;\n\n\tif (!capable(CAP_SYS_ADMIN))\n\t\tgoto out;\n\n\tret = -EFAULT;\n\tif (copy_from_user(range, argp, sizeof(__u64[2])))\n\t\tgoto out;\n\n\tret = -ERANGE;\n\tif (range[1] > i_size_read(inode->i_sb->s_bdev->bd_inode))\n\t\tgoto out;\n\n\tsegbytes = nilfs->ns_blocks_per_segment * nilfs->ns_blocksize;\n\n\tminseg = range[0] + segbytes - 1;\n\tdo_div(minseg, segbytes);\n\tmaxseg = NILFS_SB2_OFFSET_BYTES(range[1]);\n\tdo_div(maxseg, segbytes);\n\tmaxseg--;\n\n\tret = nilfs_sufile_set_alloc_range(nilfs->ns_sufile, minseg, maxseg);\nout:\n\treturn ret;\n}"
  },
  {
    "function_name": "nilfs_ioctl_trim_fs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/ioctl.c",
    "lines": "1083-1112",
    "snippet": "static int nilfs_ioctl_trim_fs(struct inode *inode, void __user *argp)\n{\n\tstruct the_nilfs *nilfs = inode->i_sb->s_fs_info;\n\tstruct request_queue *q = bdev_get_queue(nilfs->ns_bdev);\n\tstruct fstrim_range range;\n\tint ret;\n\n\tif (!capable(CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\n\tif (!blk_queue_discard(q))\n\t\treturn -EOPNOTSUPP;\n\n\tif (copy_from_user(&range, argp, sizeof(range)))\n\t\treturn -EFAULT;\n\n\trange.minlen = max_t(u64, range.minlen, q->limits.discard_granularity);\n\n\tdown_read(&nilfs->ns_segctor_sem);\n\tret = nilfs_sufile_trim_fs(nilfs->ns_sufile, &range);\n\tup_read(&nilfs->ns_segctor_sem);\n\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (copy_to_user(argp, &range, sizeof(range)))\n\t\treturn -EFAULT;\n\n\treturn 0;\n}",
    "includes": [
      "#include \"dat.h\"",
      "#include \"sufile.h\"",
      "#include \"cpfile.h\"",
      "#include \"bmap.h\"",
      "#include \"segment.h\"",
      "#include \"nilfs.h\"",
      "#include <linux/nilfs2_fs.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/mount.h>\t/* mnt_want_write_file(), mnt_drop_write_file() */",
      "#include <linux/compat.h>\t/* compat_ptr() */",
      "#include <linux/vmalloc.h>",
      "#include <linux/uaccess.h>\t/* copy_from_user(), copy_to_user() */",
      "#include <linux/capability.h>\t/* capable() */",
      "#include <linux/slab.h>",
      "#include <linux/wait.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "copy_to_user",
          "args": [
            "argp",
            "&range",
            "sizeof(range)"
          ],
          "line": 1108
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "up_read",
          "args": [
            "&nilfs->ns_segctor_sem"
          ],
          "line": 1103
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nilfs_sufile_trim_fs",
          "args": [
            "nilfs->ns_sufile",
            "&range"
          ],
          "line": 1102
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_sufile_trim_fs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/sufile.c",
          "lines": "1019-1153",
          "snippet": "int nilfs_sufile_trim_fs(struct inode *sufile, struct fstrim_range *range)\n{\n\tstruct the_nilfs *nilfs = sufile->i_sb->s_fs_info;\n\tstruct buffer_head *su_bh;\n\tstruct nilfs_segment_usage *su;\n\tvoid *kaddr;\n\tsize_t n, i, susz = NILFS_MDT(sufile)->mi_entry_size;\n\tsector_t seg_start, seg_end, start_block, end_block;\n\tsector_t start = 0, nblocks = 0;\n\tu64 segnum, segnum_end, minlen, len, max_blocks, ndiscarded = 0;\n\tint ret = 0;\n\tunsigned int sects_per_block;\n\n\tsects_per_block = (1 << nilfs->ns_blocksize_bits) /\n\t\t\tbdev_logical_block_size(nilfs->ns_bdev);\n\tlen = range->len >> nilfs->ns_blocksize_bits;\n\tminlen = range->minlen >> nilfs->ns_blocksize_bits;\n\tmax_blocks = ((u64)nilfs->ns_nsegments * nilfs->ns_blocks_per_segment);\n\n\tif (!len || range->start >= max_blocks << nilfs->ns_blocksize_bits)\n\t\treturn -EINVAL;\n\n\tstart_block = (range->start + nilfs->ns_blocksize - 1) >>\n\t\t\tnilfs->ns_blocksize_bits;\n\n\t/*\n\t * range->len can be very large (actually, it is set to\n\t * ULLONG_MAX by default) - truncate upper end of the range\n\t * carefully so as not to overflow.\n\t */\n\tif (max_blocks - start_block < len)\n\t\tend_block = max_blocks - 1;\n\telse\n\t\tend_block = start_block + len - 1;\n\n\tsegnum = nilfs_get_segnum_of_block(nilfs, start_block);\n\tsegnum_end = nilfs_get_segnum_of_block(nilfs, end_block);\n\n\tdown_read(&NILFS_MDT(sufile)->mi_sem);\n\n\twhile (segnum <= segnum_end) {\n\t\tn = nilfs_sufile_segment_usages_in_block(sufile, segnum,\n\t\t\t\tsegnum_end);\n\n\t\tret = nilfs_sufile_get_segment_usage_block(sufile, segnum, 0,\n\t\t\t\t\t\t\t   &su_bh);\n\t\tif (ret < 0) {\n\t\t\tif (ret != -ENOENT)\n\t\t\t\tgoto out_sem;\n\t\t\t/* hole */\n\t\t\tsegnum += n;\n\t\t\tcontinue;\n\t\t}\n\n\t\tkaddr = kmap_atomic(su_bh->b_page);\n\t\tsu = nilfs_sufile_block_get_segment_usage(sufile, segnum,\n\t\t\t\tsu_bh, kaddr);\n\t\tfor (i = 0; i < n; ++i, ++segnum, su = (void *)su + susz) {\n\t\t\tif (!nilfs_segment_usage_clean(su))\n\t\t\t\tcontinue;\n\n\t\t\tnilfs_get_segment_range(nilfs, segnum, &seg_start,\n\t\t\t\t\t\t&seg_end);\n\n\t\t\tif (!nblocks) {\n\t\t\t\t/* start new extent */\n\t\t\t\tstart = seg_start;\n\t\t\t\tnblocks = seg_end - seg_start + 1;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (start + nblocks == seg_start) {\n\t\t\t\t/* add to previous extent */\n\t\t\t\tnblocks += seg_end - seg_start + 1;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t/* discard previous extent */\n\t\t\tif (start < start_block) {\n\t\t\t\tnblocks -= start_block - start;\n\t\t\t\tstart = start_block;\n\t\t\t}\n\n\t\t\tif (nblocks >= minlen) {\n\t\t\t\tkunmap_atomic(kaddr);\n\n\t\t\t\tret = blkdev_issue_discard(nilfs->ns_bdev,\n\t\t\t\t\t\tstart * sects_per_block,\n\t\t\t\t\t\tnblocks * sects_per_block,\n\t\t\t\t\t\tGFP_NOFS, 0);\n\t\t\t\tif (ret < 0) {\n\t\t\t\t\tput_bh(su_bh);\n\t\t\t\t\tgoto out_sem;\n\t\t\t\t}\n\n\t\t\t\tndiscarded += nblocks;\n\t\t\t\tkaddr = kmap_atomic(su_bh->b_page);\n\t\t\t\tsu = nilfs_sufile_block_get_segment_usage(\n\t\t\t\t\tsufile, segnum, su_bh, kaddr);\n\t\t\t}\n\n\t\t\t/* start new extent */\n\t\t\tstart = seg_start;\n\t\t\tnblocks = seg_end - seg_start + 1;\n\t\t}\n\t\tkunmap_atomic(kaddr);\n\t\tput_bh(su_bh);\n\t}\n\n\n\tif (nblocks) {\n\t\t/* discard last extent */\n\t\tif (start < start_block) {\n\t\t\tnblocks -= start_block - start;\n\t\t\tstart = start_block;\n\t\t}\n\t\tif (start + nblocks > end_block + 1)\n\t\t\tnblocks = end_block - start + 1;\n\n\t\tif (nblocks >= minlen) {\n\t\t\tret = blkdev_issue_discard(nilfs->ns_bdev,\n\t\t\t\t\tstart * sects_per_block,\n\t\t\t\t\tnblocks * sects_per_block,\n\t\t\t\t\tGFP_NOFS, 0);\n\t\t\tif (!ret)\n\t\t\t\tndiscarded += nblocks;\n\t\t}\n\t}\n\nout_sem:\n\tup_read(&NILFS_MDT(sufile)->mi_sem);\n\n\trange->len = ndiscarded << nilfs->ns_blocksize_bits;\n\treturn ret;\n}",
          "includes": [
            "#include \"sufile.h\"",
            "#include \"mdt.h\"",
            "#include <linux/nilfs2_fs.h>",
            "#include <linux/errno.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/fs.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sufile.h\"\n#include \"mdt.h\"\n#include <linux/nilfs2_fs.h>\n#include <linux/errno.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/fs.h>\n#include <linux/kernel.h>\n\nint nilfs_sufile_trim_fs(struct inode *sufile, struct fstrim_range *range)\n{\n\tstruct the_nilfs *nilfs = sufile->i_sb->s_fs_info;\n\tstruct buffer_head *su_bh;\n\tstruct nilfs_segment_usage *su;\n\tvoid *kaddr;\n\tsize_t n, i, susz = NILFS_MDT(sufile)->mi_entry_size;\n\tsector_t seg_start, seg_end, start_block, end_block;\n\tsector_t start = 0, nblocks = 0;\n\tu64 segnum, segnum_end, minlen, len, max_blocks, ndiscarded = 0;\n\tint ret = 0;\n\tunsigned int sects_per_block;\n\n\tsects_per_block = (1 << nilfs->ns_blocksize_bits) /\n\t\t\tbdev_logical_block_size(nilfs->ns_bdev);\n\tlen = range->len >> nilfs->ns_blocksize_bits;\n\tminlen = range->minlen >> nilfs->ns_blocksize_bits;\n\tmax_blocks = ((u64)nilfs->ns_nsegments * nilfs->ns_blocks_per_segment);\n\n\tif (!len || range->start >= max_blocks << nilfs->ns_blocksize_bits)\n\t\treturn -EINVAL;\n\n\tstart_block = (range->start + nilfs->ns_blocksize - 1) >>\n\t\t\tnilfs->ns_blocksize_bits;\n\n\t/*\n\t * range->len can be very large (actually, it is set to\n\t * ULLONG_MAX by default) - truncate upper end of the range\n\t * carefully so as not to overflow.\n\t */\n\tif (max_blocks - start_block < len)\n\t\tend_block = max_blocks - 1;\n\telse\n\t\tend_block = start_block + len - 1;\n\n\tsegnum = nilfs_get_segnum_of_block(nilfs, start_block);\n\tsegnum_end = nilfs_get_segnum_of_block(nilfs, end_block);\n\n\tdown_read(&NILFS_MDT(sufile)->mi_sem);\n\n\twhile (segnum <= segnum_end) {\n\t\tn = nilfs_sufile_segment_usages_in_block(sufile, segnum,\n\t\t\t\tsegnum_end);\n\n\t\tret = nilfs_sufile_get_segment_usage_block(sufile, segnum, 0,\n\t\t\t\t\t\t\t   &su_bh);\n\t\tif (ret < 0) {\n\t\t\tif (ret != -ENOENT)\n\t\t\t\tgoto out_sem;\n\t\t\t/* hole */\n\t\t\tsegnum += n;\n\t\t\tcontinue;\n\t\t}\n\n\t\tkaddr = kmap_atomic(su_bh->b_page);\n\t\tsu = nilfs_sufile_block_get_segment_usage(sufile, segnum,\n\t\t\t\tsu_bh, kaddr);\n\t\tfor (i = 0; i < n; ++i, ++segnum, su = (void *)su + susz) {\n\t\t\tif (!nilfs_segment_usage_clean(su))\n\t\t\t\tcontinue;\n\n\t\t\tnilfs_get_segment_range(nilfs, segnum, &seg_start,\n\t\t\t\t\t\t&seg_end);\n\n\t\t\tif (!nblocks) {\n\t\t\t\t/* start new extent */\n\t\t\t\tstart = seg_start;\n\t\t\t\tnblocks = seg_end - seg_start + 1;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (start + nblocks == seg_start) {\n\t\t\t\t/* add to previous extent */\n\t\t\t\tnblocks += seg_end - seg_start + 1;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t/* discard previous extent */\n\t\t\tif (start < start_block) {\n\t\t\t\tnblocks -= start_block - start;\n\t\t\t\tstart = start_block;\n\t\t\t}\n\n\t\t\tif (nblocks >= minlen) {\n\t\t\t\tkunmap_atomic(kaddr);\n\n\t\t\t\tret = blkdev_issue_discard(nilfs->ns_bdev,\n\t\t\t\t\t\tstart * sects_per_block,\n\t\t\t\t\t\tnblocks * sects_per_block,\n\t\t\t\t\t\tGFP_NOFS, 0);\n\t\t\t\tif (ret < 0) {\n\t\t\t\t\tput_bh(su_bh);\n\t\t\t\t\tgoto out_sem;\n\t\t\t\t}\n\n\t\t\t\tndiscarded += nblocks;\n\t\t\t\tkaddr = kmap_atomic(su_bh->b_page);\n\t\t\t\tsu = nilfs_sufile_block_get_segment_usage(\n\t\t\t\t\tsufile, segnum, su_bh, kaddr);\n\t\t\t}\n\n\t\t\t/* start new extent */\n\t\t\tstart = seg_start;\n\t\t\tnblocks = seg_end - seg_start + 1;\n\t\t}\n\t\tkunmap_atomic(kaddr);\n\t\tput_bh(su_bh);\n\t}\n\n\n\tif (nblocks) {\n\t\t/* discard last extent */\n\t\tif (start < start_block) {\n\t\t\tnblocks -= start_block - start;\n\t\t\tstart = start_block;\n\t\t}\n\t\tif (start + nblocks > end_block + 1)\n\t\t\tnblocks = end_block - start + 1;\n\n\t\tif (nblocks >= minlen) {\n\t\t\tret = blkdev_issue_discard(nilfs->ns_bdev,\n\t\t\t\t\tstart * sects_per_block,\n\t\t\t\t\tnblocks * sects_per_block,\n\t\t\t\t\tGFP_NOFS, 0);\n\t\t\tif (!ret)\n\t\t\t\tndiscarded += nblocks;\n\t\t}\n\t}\n\nout_sem:\n\tup_read(&NILFS_MDT(sufile)->mi_sem);\n\n\trange->len = ndiscarded << nilfs->ns_blocksize_bits;\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "down_read",
          "args": [
            "&nilfs->ns_segctor_sem"
          ],
          "line": 1101
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "max_t",
          "args": [
            "u64",
            "range.minlen",
            "q->limits.discard_granularity"
          ],
          "line": 1099
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "copy_from_user",
          "args": [
            "&range",
            "argp",
            "sizeof(range)"
          ],
          "line": 1096
        },
        "resolved": true,
        "details": {
          "function_name": "exact_copy_from_user",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namespace.c",
          "lines": "2514-2534",
          "snippet": "static long exact_copy_from_user(void *to, const void __user * from,\n\t\t\t\t unsigned long n)\n{\n\tchar *t = to;\n\tconst char __user *f = from;\n\tchar c;\n\n\tif (!access_ok(VERIFY_READ, from, n))\n\t\treturn n;\n\n\twhile (n) {\n\t\tif (__get_user(c, f)) {\n\t\t\tmemset(t, 0, n);\n\t\t\tbreak;\n\t\t}\n\t\t*t++ = c;\n\t\tf++;\n\t\tn--;\n\t}\n\treturn n;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"pnode.h\"",
            "#include <linux/task_work.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/magic.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
            "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
            "#include <linux/init.h>\t\t/* init_rootfs */",
            "#include <linux/idr.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/mnt_namespace.h>",
            "#include <linux/capability.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/task_work.h>\n#include <linux/bootmem.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic long exact_copy_from_user(void *to, const void __user * from,\n\t\t\t\t unsigned long n)\n{\n\tchar *t = to;\n\tconst char __user *f = from;\n\tchar c;\n\n\tif (!access_ok(VERIFY_READ, from, n))\n\t\treturn n;\n\n\twhile (n) {\n\t\tif (__get_user(c, f)) {\n\t\t\tmemset(t, 0, n);\n\t\t\tbreak;\n\t\t}\n\t\t*t++ = c;\n\t\tf++;\n\t\tn--;\n\t}\n\treturn n;\n}"
        }
      },
      {
        "call_info": {
          "callee": "blk_queue_discard",
          "args": [
            "q"
          ],
          "line": 1093
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "capable",
          "args": [
            "CAP_SYS_ADMIN"
          ],
          "line": 1090
        },
        "resolved": true,
        "details": {
          "function_name": "inode_owner_or_capable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "1901-1912",
          "snippet": "bool inode_owner_or_capable(const struct inode *inode)\n{\n\tstruct user_namespace *ns;\n\n\tif (uid_eq(current_fsuid(), inode->i_uid))\n\t\treturn true;\n\n\tns = current_user_ns();\n\tif (ns_capable(ns, CAP_FOWNER) && kuid_has_mapping(ns, inode->i_uid))\n\t\treturn true;\n\treturn false;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nbool inode_owner_or_capable(const struct inode *inode)\n{\n\tstruct user_namespace *ns;\n\n\tif (uid_eq(current_fsuid(), inode->i_uid))\n\t\treturn true;\n\n\tns = current_user_ns();\n\tif (ns_capable(ns, CAP_FOWNER) && kuid_has_mapping(ns, inode->i_uid))\n\t\treturn true;\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "bdev_get_queue",
          "args": [
            "nilfs->ns_bdev"
          ],
          "line": 1086
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"dat.h\"\n#include \"sufile.h\"\n#include \"cpfile.h\"\n#include \"bmap.h\"\n#include \"segment.h\"\n#include \"nilfs.h\"\n#include <linux/nilfs2_fs.h>\n#include <linux/buffer_head.h>\n#include <linux/mount.h>\t/* mnt_want_write_file(), mnt_drop_write_file() */\n#include <linux/compat.h>\t/* compat_ptr() */\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\t/* copy_from_user(), copy_to_user() */\n#include <linux/capability.h>\t/* capable() */\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/fs.h>\n\nstatic int nilfs_ioctl_trim_fs(struct inode *inode, void __user *argp)\n{\n\tstruct the_nilfs *nilfs = inode->i_sb->s_fs_info;\n\tstruct request_queue *q = bdev_get_queue(nilfs->ns_bdev);\n\tstruct fstrim_range range;\n\tint ret;\n\n\tif (!capable(CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\n\tif (!blk_queue_discard(q))\n\t\treturn -EOPNOTSUPP;\n\n\tif (copy_from_user(&range, argp, sizeof(range)))\n\t\treturn -EFAULT;\n\n\trange.minlen = max_t(u64, range.minlen, q->limits.discard_granularity);\n\n\tdown_read(&nilfs->ns_segctor_sem);\n\tret = nilfs_sufile_trim_fs(nilfs->ns_sufile, &range);\n\tup_read(&nilfs->ns_segctor_sem);\n\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (copy_to_user(argp, &range, sizeof(range)))\n\t\treturn -EFAULT;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "nilfs_ioctl_resize",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/ioctl.c",
    "lines": "1047-1070",
    "snippet": "static int nilfs_ioctl_resize(struct inode *inode, struct file *filp,\n\t\t\t      void __user *argp)\n{\n\t__u64 newsize;\n\tint ret = -EPERM;\n\n\tif (!capable(CAP_SYS_ADMIN))\n\t\tgoto out;\n\n\tret = mnt_want_write_file(filp);\n\tif (ret)\n\t\tgoto out;\n\n\tret = -EFAULT;\n\tif (copy_from_user(&newsize, argp, sizeof(newsize)))\n\t\tgoto out_drop_write;\n\n\tret = nilfs_resize_fs(inode->i_sb, newsize);\n\nout_drop_write:\n\tmnt_drop_write_file(filp);\nout:\n\treturn ret;\n}",
    "includes": [
      "#include \"dat.h\"",
      "#include \"sufile.h\"",
      "#include \"cpfile.h\"",
      "#include \"bmap.h\"",
      "#include \"segment.h\"",
      "#include \"nilfs.h\"",
      "#include <linux/nilfs2_fs.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/mount.h>\t/* mnt_want_write_file(), mnt_drop_write_file() */",
      "#include <linux/compat.h>\t/* compat_ptr() */",
      "#include <linux/vmalloc.h>",
      "#include <linux/uaccess.h>\t/* copy_from_user(), copy_to_user() */",
      "#include <linux/capability.h>\t/* capable() */",
      "#include <linux/slab.h>",
      "#include <linux/wait.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mnt_drop_write_file",
          "args": [
            "filp"
          ],
          "line": 1067
        },
        "resolved": true,
        "details": {
          "function_name": "mnt_drop_write_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namespace.c",
          "lines": "487-490",
          "snippet": "void mnt_drop_write_file(struct file *file)\n{\n\tmnt_drop_write(file->f_path.mnt);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"pnode.h\"",
            "#include <linux/task_work.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/magic.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
            "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
            "#include <linux/init.h>\t\t/* init_rootfs */",
            "#include <linux/idr.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/mnt_namespace.h>",
            "#include <linux/capability.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void shrink_submounts(struct mount *mnt);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/task_work.h>\n#include <linux/bootmem.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic void shrink_submounts(struct mount *mnt);\n\nvoid mnt_drop_write_file(struct file *file)\n{\n\tmnt_drop_write(file->f_path.mnt);\n}"
        }
      },
      {
        "call_info": {
          "callee": "nilfs_resize_fs",
          "args": [
            "inode->i_sb",
            "newsize"
          ],
          "line": 1064
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_resize_fs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/super.c",
          "lines": "414-478",
          "snippet": "int nilfs_resize_fs(struct super_block *sb, __u64 newsize)\n{\n\tstruct the_nilfs *nilfs = sb->s_fs_info;\n\tstruct nilfs_super_block **sbp;\n\t__u64 devsize, newnsegs;\n\tloff_t sb2off;\n\tint ret;\n\n\tret = -ERANGE;\n\tdevsize = i_size_read(sb->s_bdev->bd_inode);\n\tif (newsize > devsize)\n\t\tgoto out;\n\n\t/*\n\t * Write lock is required to protect some functions depending\n\t * on the number of segments, the number of reserved segments,\n\t * and so forth.\n\t */\n\tdown_write(&nilfs->ns_segctor_sem);\n\n\tsb2off = NILFS_SB2_OFFSET_BYTES(newsize);\n\tnewnsegs = sb2off >> nilfs->ns_blocksize_bits;\n\tdo_div(newnsegs, nilfs->ns_blocks_per_segment);\n\n\tret = nilfs_sufile_resize(nilfs->ns_sufile, newnsegs);\n\tup_write(&nilfs->ns_segctor_sem);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tret = nilfs_construct_segment(sb);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tdown_write(&nilfs->ns_sem);\n\tnilfs_move_2nd_super(sb, sb2off);\n\tret = -EIO;\n\tsbp = nilfs_prepare_super(sb, 0);\n\tif (likely(sbp)) {\n\t\tnilfs_set_log_cursor(sbp[0], nilfs);\n\t\t/*\n\t\t * Drop NILFS_RESIZE_FS flag for compatibility with\n\t\t * mount-time resize which may be implemented in a\n\t\t * future release.\n\t\t */\n\t\tsbp[0]->s_state = cpu_to_le16(le16_to_cpu(sbp[0]->s_state) &\n\t\t\t\t\t      ~NILFS_RESIZE_FS);\n\t\tsbp[0]->s_dev_size = cpu_to_le64(newsize);\n\t\tsbp[0]->s_nsegments = cpu_to_le64(nilfs->ns_nsegments);\n\t\tif (sbp[1])\n\t\t\tmemcpy(sbp[1], sbp[0], nilfs->ns_sbsize);\n\t\tret = nilfs_commit_super(sb, NILFS_SB_COMMIT_ALL);\n\t}\n\tup_write(&nilfs->ns_sem);\n\n\t/*\n\t * Reset the range of allocatable segments last.  This order\n\t * is important in the case of expansion because the secondary\n\t * superblock must be protected from log write until migration\n\t * completes.\n\t */\n\tif (!ret)\n\t\tnilfs_sufile_set_alloc_range(nilfs->ns_sufile, 0, newnsegs - 1);\nout:\n\treturn ret;\n}",
          "includes": [
            "#include \"segbuf.h\"",
            "#include \"segment.h\"",
            "#include \"dat.h\"",
            "#include \"ifile.h\"",
            "#include \"sufile.h\" /* nilfs_sufile_resize(), nilfs_sufile_set_alloc_range() */",
            "#include \"cpfile.h\"",
            "#include \"page.h\"",
            "#include \"btnode.h\"",
            "#include \"btree.h\"",
            "#include \"alloc.h\"",
            "#include \"mdt.h\"",
            "#include \"export.h\"",
            "#include \"nilfs.h\"",
            "#include <linux/mount.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/writeback.h>",
            "#include <linux/vfs.h>",
            "#include <linux/crc32.h>",
            "#include <linux/parser.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"segbuf.h\"\n#include \"segment.h\"\n#include \"dat.h\"\n#include \"ifile.h\"\n#include \"sufile.h\" /* nilfs_sufile_resize(), nilfs_sufile_set_alloc_range() */\n#include \"cpfile.h\"\n#include \"page.h\"\n#include \"btnode.h\"\n#include \"btree.h\"\n#include \"alloc.h\"\n#include \"mdt.h\"\n#include \"export.h\"\n#include \"nilfs.h\"\n#include <linux/mount.h>\n#include <linux/seq_file.h>\n#include <linux/writeback.h>\n#include <linux/vfs.h>\n#include <linux/crc32.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nint nilfs_resize_fs(struct super_block *sb, __u64 newsize)\n{\n\tstruct the_nilfs *nilfs = sb->s_fs_info;\n\tstruct nilfs_super_block **sbp;\n\t__u64 devsize, newnsegs;\n\tloff_t sb2off;\n\tint ret;\n\n\tret = -ERANGE;\n\tdevsize = i_size_read(sb->s_bdev->bd_inode);\n\tif (newsize > devsize)\n\t\tgoto out;\n\n\t/*\n\t * Write lock is required to protect some functions depending\n\t * on the number of segments, the number of reserved segments,\n\t * and so forth.\n\t */\n\tdown_write(&nilfs->ns_segctor_sem);\n\n\tsb2off = NILFS_SB2_OFFSET_BYTES(newsize);\n\tnewnsegs = sb2off >> nilfs->ns_blocksize_bits;\n\tdo_div(newnsegs, nilfs->ns_blocks_per_segment);\n\n\tret = nilfs_sufile_resize(nilfs->ns_sufile, newnsegs);\n\tup_write(&nilfs->ns_segctor_sem);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tret = nilfs_construct_segment(sb);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tdown_write(&nilfs->ns_sem);\n\tnilfs_move_2nd_super(sb, sb2off);\n\tret = -EIO;\n\tsbp = nilfs_prepare_super(sb, 0);\n\tif (likely(sbp)) {\n\t\tnilfs_set_log_cursor(sbp[0], nilfs);\n\t\t/*\n\t\t * Drop NILFS_RESIZE_FS flag for compatibility with\n\t\t * mount-time resize which may be implemented in a\n\t\t * future release.\n\t\t */\n\t\tsbp[0]->s_state = cpu_to_le16(le16_to_cpu(sbp[0]->s_state) &\n\t\t\t\t\t      ~NILFS_RESIZE_FS);\n\t\tsbp[0]->s_dev_size = cpu_to_le64(newsize);\n\t\tsbp[0]->s_nsegments = cpu_to_le64(nilfs->ns_nsegments);\n\t\tif (sbp[1])\n\t\t\tmemcpy(sbp[1], sbp[0], nilfs->ns_sbsize);\n\t\tret = nilfs_commit_super(sb, NILFS_SB_COMMIT_ALL);\n\t}\n\tup_write(&nilfs->ns_sem);\n\n\t/*\n\t * Reset the range of allocatable segments last.  This order\n\t * is important in the case of expansion because the secondary\n\t * superblock must be protected from log write until migration\n\t * completes.\n\t */\n\tif (!ret)\n\t\tnilfs_sufile_set_alloc_range(nilfs->ns_sufile, 0, newnsegs - 1);\nout:\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "copy_from_user",
          "args": [
            "&newsize",
            "argp",
            "sizeof(newsize)"
          ],
          "line": 1061
        },
        "resolved": true,
        "details": {
          "function_name": "exact_copy_from_user",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namespace.c",
          "lines": "2514-2534",
          "snippet": "static long exact_copy_from_user(void *to, const void __user * from,\n\t\t\t\t unsigned long n)\n{\n\tchar *t = to;\n\tconst char __user *f = from;\n\tchar c;\n\n\tif (!access_ok(VERIFY_READ, from, n))\n\t\treturn n;\n\n\twhile (n) {\n\t\tif (__get_user(c, f)) {\n\t\t\tmemset(t, 0, n);\n\t\t\tbreak;\n\t\t}\n\t\t*t++ = c;\n\t\tf++;\n\t\tn--;\n\t}\n\treturn n;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"pnode.h\"",
            "#include <linux/task_work.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/magic.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
            "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
            "#include <linux/init.h>\t\t/* init_rootfs */",
            "#include <linux/idr.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/mnt_namespace.h>",
            "#include <linux/capability.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/task_work.h>\n#include <linux/bootmem.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic long exact_copy_from_user(void *to, const void __user * from,\n\t\t\t\t unsigned long n)\n{\n\tchar *t = to;\n\tconst char __user *f = from;\n\tchar c;\n\n\tif (!access_ok(VERIFY_READ, from, n))\n\t\treturn n;\n\n\twhile (n) {\n\t\tif (__get_user(c, f)) {\n\t\t\tmemset(t, 0, n);\n\t\t\tbreak;\n\t\t}\n\t\t*t++ = c;\n\t\tf++;\n\t\tn--;\n\t}\n\treturn n;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mnt_want_write_file",
          "args": [
            "filp"
          ],
          "line": 1056
        },
        "resolved": true,
        "details": {
          "function_name": "mnt_want_write_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namespace.c",
          "lines": "440-449",
          "snippet": "int mnt_want_write_file(struct file *file)\n{\n\tint ret;\n\n\tsb_start_write(file->f_path.mnt->mnt_sb);\n\tret = __mnt_want_write_file(file);\n\tif (ret)\n\t\tsb_end_write(file->f_path.mnt->mnt_sb);\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"pnode.h\"",
            "#include <linux/task_work.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/magic.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
            "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
            "#include <linux/init.h>\t\t/* init_rootfs */",
            "#include <linux/idr.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/mnt_namespace.h>",
            "#include <linux/capability.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void shrink_submounts(struct mount *mnt);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/task_work.h>\n#include <linux/bootmem.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic void shrink_submounts(struct mount *mnt);\n\nint mnt_want_write_file(struct file *file)\n{\n\tint ret;\n\n\tsb_start_write(file->f_path.mnt->mnt_sb);\n\tret = __mnt_want_write_file(file);\n\tif (ret)\n\t\tsb_end_write(file->f_path.mnt->mnt_sb);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "capable",
          "args": [
            "CAP_SYS_ADMIN"
          ],
          "line": 1053
        },
        "resolved": true,
        "details": {
          "function_name": "inode_owner_or_capable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "1901-1912",
          "snippet": "bool inode_owner_or_capable(const struct inode *inode)\n{\n\tstruct user_namespace *ns;\n\n\tif (uid_eq(current_fsuid(), inode->i_uid))\n\t\treturn true;\n\n\tns = current_user_ns();\n\tif (ns_capable(ns, CAP_FOWNER) && kuid_has_mapping(ns, inode->i_uid))\n\t\treturn true;\n\treturn false;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nbool inode_owner_or_capable(const struct inode *inode)\n{\n\tstruct user_namespace *ns;\n\n\tif (uid_eq(current_fsuid(), inode->i_uid))\n\t\treturn true;\n\n\tns = current_user_ns();\n\tif (ns_capable(ns, CAP_FOWNER) && kuid_has_mapping(ns, inode->i_uid))\n\t\treturn true;\n\treturn false;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"dat.h\"\n#include \"sufile.h\"\n#include \"cpfile.h\"\n#include \"bmap.h\"\n#include \"segment.h\"\n#include \"nilfs.h\"\n#include <linux/nilfs2_fs.h>\n#include <linux/buffer_head.h>\n#include <linux/mount.h>\t/* mnt_want_write_file(), mnt_drop_write_file() */\n#include <linux/compat.h>\t/* compat_ptr() */\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\t/* copy_from_user(), copy_to_user() */\n#include <linux/capability.h>\t/* capable() */\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/fs.h>\n\nstatic int nilfs_ioctl_resize(struct inode *inode, struct file *filp,\n\t\t\t      void __user *argp)\n{\n\t__u64 newsize;\n\tint ret = -EPERM;\n\n\tif (!capable(CAP_SYS_ADMIN))\n\t\tgoto out;\n\n\tret = mnt_want_write_file(filp);\n\tif (ret)\n\t\tgoto out;\n\n\tret = -EFAULT;\n\tif (copy_from_user(&newsize, argp, sizeof(newsize)))\n\t\tgoto out_drop_write;\n\n\tret = nilfs_resize_fs(inode->i_sb, newsize);\n\nout_drop_write:\n\tmnt_drop_write_file(filp);\nout:\n\treturn ret;\n}"
  },
  {
    "function_name": "nilfs_ioctl_sync",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/ioctl.c",
    "lines": "1013-1037",
    "snippet": "static int nilfs_ioctl_sync(struct inode *inode, struct file *filp,\n\t\t\t    unsigned int cmd, void __user *argp)\n{\n\t__u64 cno;\n\tint ret;\n\tstruct the_nilfs *nilfs;\n\n\tret = nilfs_construct_segment(inode->i_sb);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tnilfs = inode->i_sb->s_fs_info;\n\tret = nilfs_flush_device(nilfs);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (argp != NULL) {\n\t\tdown_read(&nilfs->ns_segctor_sem);\n\t\tcno = nilfs->ns_cno - 1;\n\t\tup_read(&nilfs->ns_segctor_sem);\n\t\tif (copy_to_user(argp, &cno, sizeof(cno)))\n\t\t\treturn -EFAULT;\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include \"dat.h\"",
      "#include \"sufile.h\"",
      "#include \"cpfile.h\"",
      "#include \"bmap.h\"",
      "#include \"segment.h\"",
      "#include \"nilfs.h\"",
      "#include <linux/nilfs2_fs.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/mount.h>\t/* mnt_want_write_file(), mnt_drop_write_file() */",
      "#include <linux/compat.h>\t/* compat_ptr() */",
      "#include <linux/vmalloc.h>",
      "#include <linux/uaccess.h>\t/* copy_from_user(), copy_to_user() */",
      "#include <linux/capability.h>\t/* capable() */",
      "#include <linux/slab.h>",
      "#include <linux/wait.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "copy_to_user",
          "args": [
            "argp",
            "&cno",
            "sizeof(cno)"
          ],
          "line": 1033
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "up_read",
          "args": [
            "&nilfs->ns_segctor_sem"
          ],
          "line": 1032
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "down_read",
          "args": [
            "&nilfs->ns_segctor_sem"
          ],
          "line": 1030
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nilfs_flush_device",
          "args": [
            "nilfs"
          ],
          "line": 1025
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_flush_device",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/the_nilfs.h",
          "lines": "376-394",
          "snippet": "static inline int nilfs_flush_device(struct the_nilfs *nilfs)\n{\n\tint err;\n\n\tif (!nilfs_test_opt(nilfs, BARRIER) || nilfs->ns_flushed_device)\n\t\treturn 0;\n\n\tnilfs->ns_flushed_device = 1;\n\t/*\n\t * the store to ns_flushed_device must not be reordered after\n\t * blkdev_issue_flush().\n\t */\n\tsmp_wmb();\n\n\terr = blkdev_issue_flush(nilfs->ns_bdev, GFP_KERNEL, NULL);\n\tif (err != -EIO)\n\t\terr = 0;\n\treturn err;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/fs.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n#include <linux/rbtree.h>\n#include <linux/buffer_head.h>\n#include <linux/types.h>\n\nstatic inline int nilfs_flush_device(struct the_nilfs *nilfs)\n{\n\tint err;\n\n\tif (!nilfs_test_opt(nilfs, BARRIER) || nilfs->ns_flushed_device)\n\t\treturn 0;\n\n\tnilfs->ns_flushed_device = 1;\n\t/*\n\t * the store to ns_flushed_device must not be reordered after\n\t * blkdev_issue_flush().\n\t */\n\tsmp_wmb();\n\n\terr = blkdev_issue_flush(nilfs->ns_bdev, GFP_KERNEL, NULL);\n\tif (err != -EIO)\n\t\terr = 0;\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nilfs_construct_segment",
          "args": [
            "inode->i_sb"
          ],
          "line": 1020
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_construct_segment",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/segment.c",
          "lines": "2168-2183",
          "snippet": "int nilfs_construct_segment(struct super_block *sb)\n{\n\tstruct the_nilfs *nilfs = sb->s_fs_info;\n\tstruct nilfs_sc_info *sci = nilfs->ns_writer;\n\tstruct nilfs_transaction_info *ti;\n\tint err;\n\n\tif (!sci)\n\t\treturn -EROFS;\n\n\t/* A call inside transactions causes a deadlock. */\n\tBUG_ON((ti = current->journal_info) && ti->ti_magic == NILFS_TI_MAGIC);\n\n\terr = nilfs_segctor_sync(sci);\n\treturn err;\n}",
          "includes": [
            "#include \"segbuf.h\"",
            "#include \"ifile.h\"",
            "#include \"cpfile.h\"",
            "#include \"sufile.h\"",
            "#include \"segment.h\"",
            "#include \"page.h\"",
            "#include \"btnode.h\"",
            "#include \"nilfs.h\"",
            "#include <linux/slab.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/crc32.h>",
            "#include <linux/kthread.h>",
            "#include <linux/freezer.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/completion.h>",
            "#include <linux/bio.h>",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void nilfs_segctor_start_timer(struct nilfs_sc_info *);",
            "static void nilfs_segctor_do_flush(struct nilfs_sc_info *, int);",
            "static void nilfs_segctor_do_immediate_flush(struct nilfs_sc_info *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"segbuf.h\"\n#include \"ifile.h\"\n#include \"cpfile.h\"\n#include \"sufile.h\"\n#include \"segment.h\"\n#include \"page.h\"\n#include \"btnode.h\"\n#include \"nilfs.h\"\n#include <linux/slab.h>\n#include <linux/pagevec.h>\n#include <linux/crc32.h>\n#include <linux/kthread.h>\n#include <linux/freezer.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/completion.h>\n#include <linux/bio.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n\nstatic void nilfs_segctor_start_timer(struct nilfs_sc_info *);\nstatic void nilfs_segctor_do_flush(struct nilfs_sc_info *, int);\nstatic void nilfs_segctor_do_immediate_flush(struct nilfs_sc_info *);\n\nint nilfs_construct_segment(struct super_block *sb)\n{\n\tstruct the_nilfs *nilfs = sb->s_fs_info;\n\tstruct nilfs_sc_info *sci = nilfs->ns_writer;\n\tstruct nilfs_transaction_info *ti;\n\tint err;\n\n\tif (!sci)\n\t\treturn -EROFS;\n\n\t/* A call inside transactions causes a deadlock. */\n\tBUG_ON((ti = current->journal_info) && ti->ti_magic == NILFS_TI_MAGIC);\n\n\terr = nilfs_segctor_sync(sci);\n\treturn err;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"dat.h\"\n#include \"sufile.h\"\n#include \"cpfile.h\"\n#include \"bmap.h\"\n#include \"segment.h\"\n#include \"nilfs.h\"\n#include <linux/nilfs2_fs.h>\n#include <linux/buffer_head.h>\n#include <linux/mount.h>\t/* mnt_want_write_file(), mnt_drop_write_file() */\n#include <linux/compat.h>\t/* compat_ptr() */\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\t/* copy_from_user(), copy_to_user() */\n#include <linux/capability.h>\t/* capable() */\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/fs.h>\n\nstatic int nilfs_ioctl_sync(struct inode *inode, struct file *filp,\n\t\t\t    unsigned int cmd, void __user *argp)\n{\n\t__u64 cno;\n\tint ret;\n\tstruct the_nilfs *nilfs;\n\n\tret = nilfs_construct_segment(inode->i_sb);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tnilfs = inode->i_sb->s_fs_info;\n\tret = nilfs_flush_device(nilfs);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (argp != NULL) {\n\t\tdown_read(&nilfs->ns_segctor_sem);\n\t\tcno = nilfs->ns_cno - 1;\n\t\tup_read(&nilfs->ns_segctor_sem);\n\t\tif (copy_to_user(argp, &cno, sizeof(cno)))\n\t\t\treturn -EFAULT;\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "nilfs_ioctl_clean_segments",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/ioctl.c",
    "lines": "875-984",
    "snippet": "static int nilfs_ioctl_clean_segments(struct inode *inode, struct file *filp,\n\t\t\t\t      unsigned int cmd, void __user *argp)\n{\n\tstruct nilfs_argv argv[5];\n\tstatic const size_t argsz[5] = {\n\t\tsizeof(struct nilfs_vdesc),\n\t\tsizeof(struct nilfs_period),\n\t\tsizeof(__u64),\n\t\tsizeof(struct nilfs_bdesc),\n\t\tsizeof(__u64),\n\t};\n\tvoid __user *base;\n\tvoid *kbufs[5];\n\tstruct the_nilfs *nilfs;\n\tsize_t len, nsegs;\n\tint n, ret;\n\n\tif (!capable(CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\n\tret = mnt_want_write_file(filp);\n\tif (ret)\n\t\treturn ret;\n\n\tret = -EFAULT;\n\tif (copy_from_user(argv, argp, sizeof(argv)))\n\t\tgoto out;\n\n\tret = -EINVAL;\n\tnsegs = argv[4].v_nmembs;\n\tif (argv[4].v_size != argsz[4])\n\t\tgoto out;\n\tif (nsegs > UINT_MAX / sizeof(__u64))\n\t\tgoto out;\n\n\t/*\n\t * argv[4] points to segment numbers this ioctl cleans.  We\n\t * use kmalloc() for its buffer because memory used for the\n\t * segment numbers is enough small.\n\t */\n\tkbufs[4] = memdup_user((void __user *)(unsigned long)argv[4].v_base,\n\t\t\t       nsegs * sizeof(__u64));\n\tif (IS_ERR(kbufs[4])) {\n\t\tret = PTR_ERR(kbufs[4]);\n\t\tgoto out;\n\t}\n\tnilfs = inode->i_sb->s_fs_info;\n\n\tfor (n = 0; n < 4; n++) {\n\t\tret = -EINVAL;\n\t\tif (argv[n].v_size != argsz[n])\n\t\t\tgoto out_free;\n\n\t\tif (argv[n].v_nmembs > nsegs * nilfs->ns_blocks_per_segment)\n\t\t\tgoto out_free;\n\n\t\tif (argv[n].v_nmembs >= UINT_MAX / argv[n].v_size)\n\t\t\tgoto out_free;\n\n\t\tlen = argv[n].v_size * argv[n].v_nmembs;\n\t\tbase = (void __user *)(unsigned long)argv[n].v_base;\n\t\tif (len == 0) {\n\t\t\tkbufs[n] = NULL;\n\t\t\tcontinue;\n\t\t}\n\n\t\tkbufs[n] = vmalloc(len);\n\t\tif (!kbufs[n]) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto out_free;\n\t\t}\n\t\tif (copy_from_user(kbufs[n], base, len)) {\n\t\t\tret = -EFAULT;\n\t\t\tvfree(kbufs[n]);\n\t\t\tgoto out_free;\n\t\t}\n\t}\n\n\t/*\n\t * nilfs_ioctl_move_blocks() will call nilfs_iget_for_gc(),\n\t * which will operates an inode list without blocking.\n\t * To protect the list from concurrent operations,\n\t * nilfs_ioctl_move_blocks should be atomic operation.\n\t */\n\tif (test_and_set_bit(THE_NILFS_GC_RUNNING, &nilfs->ns_flags)) {\n\t\tret = -EBUSY;\n\t\tgoto out_free;\n\t}\n\n\tret = nilfs_ioctl_move_blocks(inode->i_sb, &argv[0], kbufs[0]);\n\tif (ret < 0)\n\t\tprintk(KERN_ERR \"NILFS: GC failed during preparation: \"\n\t\t\t\"cannot read source blocks: err=%d\\n\", ret);\n\telse {\n\t\tif (nilfs_sb_need_update(nilfs))\n\t\t\tset_nilfs_discontinued(nilfs);\n\t\tret = nilfs_clean_segments(inode->i_sb, argv, kbufs);\n\t}\n\n\tnilfs_remove_all_gcinodes(nilfs);\n\tclear_nilfs_gc_running(nilfs);\n\nout_free:\n\twhile (--n >= 0)\n\t\tvfree(kbufs[n]);\n\tkfree(kbufs[4]);\nout:\n\tmnt_drop_write_file(filp);\n\treturn ret;\n}",
    "includes": [
      "#include \"dat.h\"",
      "#include \"sufile.h\"",
      "#include \"cpfile.h\"",
      "#include \"bmap.h\"",
      "#include \"segment.h\"",
      "#include \"nilfs.h\"",
      "#include <linux/nilfs2_fs.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/mount.h>\t/* mnt_want_write_file(), mnt_drop_write_file() */",
      "#include <linux/compat.h>\t/* compat_ptr() */",
      "#include <linux/vmalloc.h>",
      "#include <linux/uaccess.h>\t/* copy_from_user(), copy_to_user() */",
      "#include <linux/capability.h>\t/* capable() */",
      "#include <linux/slab.h>",
      "#include <linux/wait.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mnt_drop_write_file",
          "args": [
            "filp"
          ],
          "line": 982
        },
        "resolved": true,
        "details": {
          "function_name": "mnt_drop_write_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namespace.c",
          "lines": "487-490",
          "snippet": "void mnt_drop_write_file(struct file *file)\n{\n\tmnt_drop_write(file->f_path.mnt);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"pnode.h\"",
            "#include <linux/task_work.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/magic.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
            "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
            "#include <linux/init.h>\t\t/* init_rootfs */",
            "#include <linux/idr.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/mnt_namespace.h>",
            "#include <linux/capability.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void shrink_submounts(struct mount *mnt);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/task_work.h>\n#include <linux/bootmem.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic void shrink_submounts(struct mount *mnt);\n\nvoid mnt_drop_write_file(struct file *file)\n{\n\tmnt_drop_write(file->f_path.mnt);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "kbufs[4]"
          ],
          "line": 980
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vfree",
          "args": [
            "kbufs[n]"
          ],
          "line": 979
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clear_nilfs_gc_running",
          "args": [
            "nilfs"
          ],
          "line": 975
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nilfs_remove_all_gcinodes",
          "args": [
            "nilfs"
          ],
          "line": 974
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_remove_all_gcinodes",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/gcinode.c",
          "lines": "185-197",
          "snippet": "void nilfs_remove_all_gcinodes(struct the_nilfs *nilfs)\n{\n\tstruct list_head *head = &nilfs->ns_gc_inodes;\n\tstruct nilfs_inode_info *ii;\n\n\twhile (!list_empty(head)) {\n\t\tii = list_first_entry(head, struct nilfs_inode_info, i_dirty);\n\t\tlist_del_init(&ii->i_dirty);\n\t\ttruncate_inode_pages(&ii->vfs_inode.i_data, 0);\n\t\tnilfs_btnode_cache_clear(&ii->i_btnode_cache);\n\t\tiput(&ii->vfs_inode);\n\t}\n}",
          "includes": [
            "#include \"ifile.h\"",
            "#include \"dat.h\"",
            "#include \"mdt.h\"",
            "#include \"page.h\"",
            "#include \"btnode.h\"",
            "#include \"btree.h\"",
            "#include \"nilfs.h\"",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/hash.h>",
            "#include <linux/mpage.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ifile.h\"\n#include \"dat.h\"\n#include \"mdt.h\"\n#include \"page.h\"\n#include \"btnode.h\"\n#include \"btree.h\"\n#include \"nilfs.h\"\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/hash.h>\n#include <linux/mpage.h>\n#include <linux/buffer_head.h>\n\nvoid nilfs_remove_all_gcinodes(struct the_nilfs *nilfs)\n{\n\tstruct list_head *head = &nilfs->ns_gc_inodes;\n\tstruct nilfs_inode_info *ii;\n\n\twhile (!list_empty(head)) {\n\t\tii = list_first_entry(head, struct nilfs_inode_info, i_dirty);\n\t\tlist_del_init(&ii->i_dirty);\n\t\ttruncate_inode_pages(&ii->vfs_inode.i_data, 0);\n\t\tnilfs_btnode_cache_clear(&ii->i_btnode_cache);\n\t\tiput(&ii->vfs_inode);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "nilfs_clean_segments",
          "args": [
            "inode->i_sb",
            "argv",
            "kbufs"
          ],
          "line": 971
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_clean_segments",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/segment.c",
          "lines": "2355-2411",
          "snippet": "int nilfs_clean_segments(struct super_block *sb, struct nilfs_argv *argv,\n\t\t\t void **kbufs)\n{\n\tstruct the_nilfs *nilfs = sb->s_fs_info;\n\tstruct nilfs_sc_info *sci = nilfs->ns_writer;\n\tstruct nilfs_transaction_info ti;\n\tint err;\n\n\tif (unlikely(!sci))\n\t\treturn -EROFS;\n\n\tnilfs_transaction_lock(sb, &ti, 1);\n\n\terr = nilfs_mdt_save_to_shadow_map(nilfs->ns_dat);\n\tif (unlikely(err))\n\t\tgoto out_unlock;\n\n\terr = nilfs_ioctl_prepare_clean_segments(nilfs, argv, kbufs);\n\tif (unlikely(err)) {\n\t\tnilfs_mdt_restore_from_shadow_map(nilfs->ns_dat);\n\t\tgoto out_unlock;\n\t}\n\n\tsci->sc_freesegs = kbufs[4];\n\tsci->sc_nfreesegs = argv[4].v_nmembs;\n\tlist_splice_tail_init(&nilfs->ns_gc_inodes, &sci->sc_gc_inodes);\n\n\tfor (;;) {\n\t\terr = nilfs_segctor_construct(sci, SC_LSEG_SR);\n\t\tnilfs_remove_written_gcinodes(nilfs, &sci->sc_gc_inodes);\n\n\t\tif (likely(!err))\n\t\t\tbreak;\n\n\t\tnilfs_warning(sb, __func__,\n\t\t\t      \"segment construction failed. (err=%d)\", err);\n\t\tset_current_state(TASK_INTERRUPTIBLE);\n\t\tschedule_timeout(sci->sc_interval);\n\t}\n\tif (nilfs_test_opt(nilfs, DISCARD)) {\n\t\tint ret = nilfs_discard_segments(nilfs, sci->sc_freesegs,\n\t\t\t\t\t\t sci->sc_nfreesegs);\n\t\tif (ret) {\n\t\t\tprintk(KERN_WARNING\n\t\t\t       \"NILFS warning: error %d on discard request, \"\n\t\t\t       \"turning discards off for the device\\n\", ret);\n\t\t\tnilfs_clear_opt(nilfs, DISCARD);\n\t\t}\n\t}\n\n out_unlock:\n\tsci->sc_freesegs = NULL;\n\tsci->sc_nfreesegs = 0;\n\tnilfs_mdt_clear_shadow_map(nilfs->ns_dat);\n\tnilfs_transaction_unlock(sb);\n\treturn err;\n}",
          "includes": [
            "#include \"segbuf.h\"",
            "#include \"ifile.h\"",
            "#include \"cpfile.h\"",
            "#include \"sufile.h\"",
            "#include \"segment.h\"",
            "#include \"page.h\"",
            "#include \"btnode.h\"",
            "#include \"nilfs.h\"",
            "#include <linux/slab.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/crc32.h>",
            "#include <linux/kthread.h>",
            "#include <linux/freezer.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/completion.h>",
            "#include <linux/bio.h>",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void nilfs_segctor_start_timer(struct nilfs_sc_info *);",
            "static void nilfs_segctor_do_flush(struct nilfs_sc_info *, int);",
            "static void nilfs_segctor_do_immediate_flush(struct nilfs_sc_info *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"segbuf.h\"\n#include \"ifile.h\"\n#include \"cpfile.h\"\n#include \"sufile.h\"\n#include \"segment.h\"\n#include \"page.h\"\n#include \"btnode.h\"\n#include \"nilfs.h\"\n#include <linux/slab.h>\n#include <linux/pagevec.h>\n#include <linux/crc32.h>\n#include <linux/kthread.h>\n#include <linux/freezer.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/completion.h>\n#include <linux/bio.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n\nstatic void nilfs_segctor_start_timer(struct nilfs_sc_info *);\nstatic void nilfs_segctor_do_flush(struct nilfs_sc_info *, int);\nstatic void nilfs_segctor_do_immediate_flush(struct nilfs_sc_info *);\n\nint nilfs_clean_segments(struct super_block *sb, struct nilfs_argv *argv,\n\t\t\t void **kbufs)\n{\n\tstruct the_nilfs *nilfs = sb->s_fs_info;\n\tstruct nilfs_sc_info *sci = nilfs->ns_writer;\n\tstruct nilfs_transaction_info ti;\n\tint err;\n\n\tif (unlikely(!sci))\n\t\treturn -EROFS;\n\n\tnilfs_transaction_lock(sb, &ti, 1);\n\n\terr = nilfs_mdt_save_to_shadow_map(nilfs->ns_dat);\n\tif (unlikely(err))\n\t\tgoto out_unlock;\n\n\terr = nilfs_ioctl_prepare_clean_segments(nilfs, argv, kbufs);\n\tif (unlikely(err)) {\n\t\tnilfs_mdt_restore_from_shadow_map(nilfs->ns_dat);\n\t\tgoto out_unlock;\n\t}\n\n\tsci->sc_freesegs = kbufs[4];\n\tsci->sc_nfreesegs = argv[4].v_nmembs;\n\tlist_splice_tail_init(&nilfs->ns_gc_inodes, &sci->sc_gc_inodes);\n\n\tfor (;;) {\n\t\terr = nilfs_segctor_construct(sci, SC_LSEG_SR);\n\t\tnilfs_remove_written_gcinodes(nilfs, &sci->sc_gc_inodes);\n\n\t\tif (likely(!err))\n\t\t\tbreak;\n\n\t\tnilfs_warning(sb, __func__,\n\t\t\t      \"segment construction failed. (err=%d)\", err);\n\t\tset_current_state(TASK_INTERRUPTIBLE);\n\t\tschedule_timeout(sci->sc_interval);\n\t}\n\tif (nilfs_test_opt(nilfs, DISCARD)) {\n\t\tint ret = nilfs_discard_segments(nilfs, sci->sc_freesegs,\n\t\t\t\t\t\t sci->sc_nfreesegs);\n\t\tif (ret) {\n\t\t\tprintk(KERN_WARNING\n\t\t\t       \"NILFS warning: error %d on discard request, \"\n\t\t\t       \"turning discards off for the device\\n\", ret);\n\t\t\tnilfs_clear_opt(nilfs, DISCARD);\n\t\t}\n\t}\n\n out_unlock:\n\tsci->sc_freesegs = NULL;\n\tsci->sc_nfreesegs = 0;\n\tnilfs_mdt_clear_shadow_map(nilfs->ns_dat);\n\tnilfs_transaction_unlock(sb);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_nilfs_discontinued",
          "args": [
            "nilfs"
          ],
          "line": 970
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nilfs_sb_need_update",
          "args": [
            "nilfs"
          ],
          "line": 969
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_sb_need_update",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/the_nilfs.h",
          "lines": "273-278",
          "snippet": "static inline int nilfs_sb_need_update(struct the_nilfs *nilfs)\n{\n\tu64 t = get_seconds();\n\treturn t < nilfs->ns_sbwtime ||\n\t\tt > nilfs->ns_sbwtime + nilfs->ns_sb_update_freq;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/fs.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n#include <linux/rbtree.h>\n#include <linux/buffer_head.h>\n#include <linux/types.h>\n\nstatic inline int nilfs_sb_need_update(struct the_nilfs *nilfs)\n{\n\tu64 t = get_seconds();\n\treturn t < nilfs->ns_sbwtime ||\n\t\tt > nilfs->ns_sbwtime + nilfs->ns_sb_update_freq;\n}"
        }
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_ERR \"NILFS: GC failed during preparation: \"\n\t\t\t\"cannot read source blocks: err=%d\\n\"",
            "ret"
          ],
          "line": 966
        },
        "resolved": true,
        "details": {
          "function_name": "compat_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/compat.c",
          "lines": "59-69",
          "snippet": "int compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/ioctls.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/aio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/mm.h>",
            "#include <linux/poll.h>",
            "#include <linux/signal.h>",
            "#include <linux/highmem.h>",
            "#include <linux/security.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/personality.h>",
            "#include <linux/highuid.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/dirent.h>",
            "#include <linux/ctype.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/nfs4_mount.h>",
            "#include <linux/ncp_mount.h>",
            "#include <linux/init.h>",
            "#include <linux/ioctl.h>",
            "#include <linux/vfs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/namei.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/errno.h>",
            "#include <linux/compat.h>",
            "#include <linux/linkage.h>",
            "#include <linux/kernel.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int compat_log = 1;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/ioctls.h>\n#include <asm/mmu_context.h>\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/fs_struct.h>\n#include <linux/mm.h>\n#include <linux/poll.h>\n#include <linux/signal.h>\n#include <linux/highmem.h>\n#include <linux/security.h>\n#include <linux/tsacct_kern.h>\n#include <linux/rwsem.h>\n#include <linux/personality.h>\n#include <linux/highuid.h>\n#include <linux/fsnotify.h>\n#include <linux/dirent.h>\n#include <linux/ctype.h>\n#include <linux/syscalls.h>\n#include <linux/nfs4_mount.h>\n#include <linux/ncp_mount.h>\n#include <linux/init.h>\n#include <linux/ioctl.h>\n#include <linux/vfs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/namei.h>\n#include <linux/fcntl.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <linux/compat.h>\n#include <linux/linkage.h>\n#include <linux/kernel.h>\n#include <linux/stddef.h>\n\nint compat_log = 1;\n\nint compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nilfs_ioctl_move_blocks",
          "args": [
            "inode->i_sb",
            "&argv[0]",
            "kbufs[0]"
          ],
          "line": 964
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_ioctl_move_blocks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/ioctl.c",
          "lines": "632-695",
          "snippet": "static int nilfs_ioctl_move_blocks(struct super_block *sb,\n\t\t\t\t   struct nilfs_argv *argv, void *buf)\n{\n\tsize_t nmembs = argv->v_nmembs;\n\tstruct the_nilfs *nilfs = sb->s_fs_info;\n\tstruct inode *inode;\n\tstruct nilfs_vdesc *vdesc;\n\tstruct buffer_head *bh, *n;\n\tLIST_HEAD(buffers);\n\tino_t ino;\n\t__u64 cno;\n\tint i, ret;\n\n\tfor (i = 0, vdesc = buf; i < nmembs; ) {\n\t\tino = vdesc->vd_ino;\n\t\tcno = vdesc->vd_cno;\n\t\tinode = nilfs_iget_for_gc(sb, ino, cno);\n\t\tif (IS_ERR(inode)) {\n\t\t\tret = PTR_ERR(inode);\n\t\t\tgoto failed;\n\t\t}\n\t\tif (list_empty(&NILFS_I(inode)->i_dirty)) {\n\t\t\t/*\n\t\t\t * Add the inode to GC inode list. Garbage Collection\n\t\t\t * is serialized and no two processes manipulate the\n\t\t\t * list simultaneously.\n\t\t\t */\n\t\t\tigrab(inode);\n\t\t\tlist_add(&NILFS_I(inode)->i_dirty,\n\t\t\t\t &nilfs->ns_gc_inodes);\n\t\t}\n\n\t\tdo {\n\t\t\tret = nilfs_ioctl_move_inode_block(inode, vdesc,\n\t\t\t\t\t\t\t   &buffers);\n\t\t\tif (unlikely(ret < 0)) {\n\t\t\t\tiput(inode);\n\t\t\t\tgoto failed;\n\t\t\t}\n\t\t\tvdesc++;\n\t\t} while (++i < nmembs &&\n\t\t\t vdesc->vd_ino == ino && vdesc->vd_cno == cno);\n\n\t\tiput(inode); /* The inode still remains in GC inode list */\n\t}\n\n\tlist_for_each_entry_safe(bh, n, &buffers, b_assoc_buffers) {\n\t\tret = nilfs_gccache_wait_and_mark_dirty(bh);\n\t\tif (unlikely(ret < 0)) {\n\t\t\tWARN_ON(ret == -EEXIST);\n\t\t\tgoto failed;\n\t\t}\n\t\tlist_del_init(&bh->b_assoc_buffers);\n\t\tbrelse(bh);\n\t}\n\treturn nmembs;\n\n failed:\n\tlist_for_each_entry_safe(bh, n, &buffers, b_assoc_buffers) {\n\t\tlist_del_init(&bh->b_assoc_buffers);\n\t\tbrelse(bh);\n\t}\n\treturn ret;\n}",
          "includes": [
            "#include \"dat.h\"",
            "#include \"sufile.h\"",
            "#include \"cpfile.h\"",
            "#include \"bmap.h\"",
            "#include \"segment.h\"",
            "#include \"nilfs.h\"",
            "#include <linux/nilfs2_fs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/mount.h>\t/* mnt_want_write_file(), mnt_drop_write_file() */",
            "#include <linux/compat.h>\t/* compat_ptr() */",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>\t/* copy_from_user(), copy_to_user() */",
            "#include <linux/capability.h>\t/* capable() */",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"dat.h\"\n#include \"sufile.h\"\n#include \"cpfile.h\"\n#include \"bmap.h\"\n#include \"segment.h\"\n#include \"nilfs.h\"\n#include <linux/nilfs2_fs.h>\n#include <linux/buffer_head.h>\n#include <linux/mount.h>\t/* mnt_want_write_file(), mnt_drop_write_file() */\n#include <linux/compat.h>\t/* compat_ptr() */\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\t/* copy_from_user(), copy_to_user() */\n#include <linux/capability.h>\t/* capable() */\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/fs.h>\n\nstatic int nilfs_ioctl_move_blocks(struct super_block *sb,\n\t\t\t\t   struct nilfs_argv *argv, void *buf)\n{\n\tsize_t nmembs = argv->v_nmembs;\n\tstruct the_nilfs *nilfs = sb->s_fs_info;\n\tstruct inode *inode;\n\tstruct nilfs_vdesc *vdesc;\n\tstruct buffer_head *bh, *n;\n\tLIST_HEAD(buffers);\n\tino_t ino;\n\t__u64 cno;\n\tint i, ret;\n\n\tfor (i = 0, vdesc = buf; i < nmembs; ) {\n\t\tino = vdesc->vd_ino;\n\t\tcno = vdesc->vd_cno;\n\t\tinode = nilfs_iget_for_gc(sb, ino, cno);\n\t\tif (IS_ERR(inode)) {\n\t\t\tret = PTR_ERR(inode);\n\t\t\tgoto failed;\n\t\t}\n\t\tif (list_empty(&NILFS_I(inode)->i_dirty)) {\n\t\t\t/*\n\t\t\t * Add the inode to GC inode list. Garbage Collection\n\t\t\t * is serialized and no two processes manipulate the\n\t\t\t * list simultaneously.\n\t\t\t */\n\t\t\tigrab(inode);\n\t\t\tlist_add(&NILFS_I(inode)->i_dirty,\n\t\t\t\t &nilfs->ns_gc_inodes);\n\t\t}\n\n\t\tdo {\n\t\t\tret = nilfs_ioctl_move_inode_block(inode, vdesc,\n\t\t\t\t\t\t\t   &buffers);\n\t\t\tif (unlikely(ret < 0)) {\n\t\t\t\tiput(inode);\n\t\t\t\tgoto failed;\n\t\t\t}\n\t\t\tvdesc++;\n\t\t} while (++i < nmembs &&\n\t\t\t vdesc->vd_ino == ino && vdesc->vd_cno == cno);\n\n\t\tiput(inode); /* The inode still remains in GC inode list */\n\t}\n\n\tlist_for_each_entry_safe(bh, n, &buffers, b_assoc_buffers) {\n\t\tret = nilfs_gccache_wait_and_mark_dirty(bh);\n\t\tif (unlikely(ret < 0)) {\n\t\t\tWARN_ON(ret == -EEXIST);\n\t\t\tgoto failed;\n\t\t}\n\t\tlist_del_init(&bh->b_assoc_buffers);\n\t\tbrelse(bh);\n\t}\n\treturn nmembs;\n\n failed:\n\tlist_for_each_entry_safe(bh, n, &buffers, b_assoc_buffers) {\n\t\tlist_del_init(&bh->b_assoc_buffers);\n\t\tbrelse(bh);\n\t}\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "test_and_set_bit",
          "args": [
            "THE_NILFS_GC_RUNNING",
            "&nilfs->ns_flags"
          ],
          "line": 959
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_test_and_set_bit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "1117-1127",
          "snippet": "static inline int f2fs_test_and_set_bit(unsigned int nr, char *addr)\n{\n\tint mask;\n\tint ret;\n\n\taddr += (nr >> 3);\n\tmask = 1 << (7 - (nr & 0x07));\n\tret = mask & *addr;\n\t*addr |= mask;\n\treturn ret;\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline int f2fs_test_and_set_bit(unsigned int nr, char *addr)\n{\n\tint mask;\n\tint ret;\n\n\taddr += (nr >> 3);\n\tmask = 1 << (7 - (nr & 0x07));\n\tret = mask & *addr;\n\t*addr |= mask;\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "vfree",
          "args": [
            "kbufs[n]"
          ],
          "line": 948
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "copy_from_user",
          "args": [
            "kbufs[n]",
            "base",
            "len"
          ],
          "line": 946
        },
        "resolved": true,
        "details": {
          "function_name": "exact_copy_from_user",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namespace.c",
          "lines": "2514-2534",
          "snippet": "static long exact_copy_from_user(void *to, const void __user * from,\n\t\t\t\t unsigned long n)\n{\n\tchar *t = to;\n\tconst char __user *f = from;\n\tchar c;\n\n\tif (!access_ok(VERIFY_READ, from, n))\n\t\treturn n;\n\n\twhile (n) {\n\t\tif (__get_user(c, f)) {\n\t\t\tmemset(t, 0, n);\n\t\t\tbreak;\n\t\t}\n\t\t*t++ = c;\n\t\tf++;\n\t\tn--;\n\t}\n\treturn n;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"pnode.h\"",
            "#include <linux/task_work.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/magic.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
            "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
            "#include <linux/init.h>\t\t/* init_rootfs */",
            "#include <linux/idr.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/mnt_namespace.h>",
            "#include <linux/capability.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/task_work.h>\n#include <linux/bootmem.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic long exact_copy_from_user(void *to, const void __user * from,\n\t\t\t\t unsigned long n)\n{\n\tchar *t = to;\n\tconst char __user *f = from;\n\tchar c;\n\n\tif (!access_ok(VERIFY_READ, from, n))\n\t\treturn n;\n\n\twhile (n) {\n\t\tif (__get_user(c, f)) {\n\t\t\tmemset(t, 0, n);\n\t\t\tbreak;\n\t\t}\n\t\t*t++ = c;\n\t\tf++;\n\t\tn--;\n\t}\n\treturn n;\n}"
        }
      },
      {
        "call_info": {
          "callee": "vmalloc",
          "args": [
            "len"
          ],
          "line": 941
        },
        "resolved": true,
        "details": {
          "function_name": "ffs2_blocks_use_vmalloc(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jffs2/nodelist.h",
          "lines": "292-295",
          "snippet": "tatic inline int jffs2_blocks_use_vmalloc(struct jffs2_sb_info *c)\n{\n\treturn ((c->flash_size / c->sector_size) * sizeof (struct jffs2_eraseblock)) > (128 * 1024);\n}",
          "includes": [
            "include \"debug.h\"",
            "include \"os-linux.h\"\n#",
            "include \"os-ecos.h\"\n#",
            "include \"summary.h\"",
            "include \"acl.h\"\n#",
            "include \"xattr.h\"\n#",
            "include \"jffs2_fs_i.h\"\n#",
            "include \"jffs2_fs_sb.h\"\n#",
            "include <linux/jffs2.h>\n#",
            "include <linux/types.h>\n#",
            "include <linux/fs.h>\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"debug.h\"\ninclude \"os-linux.h\"\n#\ninclude \"os-ecos.h\"\n#\ninclude \"summary.h\"\ninclude \"acl.h\"\n#\ninclude \"xattr.h\"\n#\ninclude \"jffs2_fs_i.h\"\n#\ninclude \"jffs2_fs_sb.h\"\n#\ninclude <linux/jffs2.h>\n#\ninclude <linux/types.h>\n#\ninclude <linux/fs.h>\n#\n\ntatic inline int jffs2_blocks_use_vmalloc(struct jffs2_sb_info *c)\n{\n\treturn ((c->flash_size / c->sector_size) * sizeof (struct jffs2_eraseblock)) > (128 * 1024);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "kbufs[4]"
          ],
          "line": 918
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "kbufs[4]"
          ],
          "line": 917
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memdup_user",
          "args": [
            "(void __user *)(unsigned long)argv[4].v_base",
            "nsegs * sizeof(__u64)"
          ],
          "line": 915
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mnt_want_write_file",
          "args": [
            "filp"
          ],
          "line": 895
        },
        "resolved": true,
        "details": {
          "function_name": "mnt_want_write_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namespace.c",
          "lines": "440-449",
          "snippet": "int mnt_want_write_file(struct file *file)\n{\n\tint ret;\n\n\tsb_start_write(file->f_path.mnt->mnt_sb);\n\tret = __mnt_want_write_file(file);\n\tif (ret)\n\t\tsb_end_write(file->f_path.mnt->mnt_sb);\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"pnode.h\"",
            "#include <linux/task_work.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/magic.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
            "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
            "#include <linux/init.h>\t\t/* init_rootfs */",
            "#include <linux/idr.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/mnt_namespace.h>",
            "#include <linux/capability.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void shrink_submounts(struct mount *mnt);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/task_work.h>\n#include <linux/bootmem.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic void shrink_submounts(struct mount *mnt);\n\nint mnt_want_write_file(struct file *file)\n{\n\tint ret;\n\n\tsb_start_write(file->f_path.mnt->mnt_sb);\n\tret = __mnt_want_write_file(file);\n\tif (ret)\n\t\tsb_end_write(file->f_path.mnt->mnt_sb);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "capable",
          "args": [
            "CAP_SYS_ADMIN"
          ],
          "line": 892
        },
        "resolved": true,
        "details": {
          "function_name": "inode_owner_or_capable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "1901-1912",
          "snippet": "bool inode_owner_or_capable(const struct inode *inode)\n{\n\tstruct user_namespace *ns;\n\n\tif (uid_eq(current_fsuid(), inode->i_uid))\n\t\treturn true;\n\n\tns = current_user_ns();\n\tif (ns_capable(ns, CAP_FOWNER) && kuid_has_mapping(ns, inode->i_uid))\n\t\treturn true;\n\treturn false;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nbool inode_owner_or_capable(const struct inode *inode)\n{\n\tstruct user_namespace *ns;\n\n\tif (uid_eq(current_fsuid(), inode->i_uid))\n\t\treturn true;\n\n\tns = current_user_ns();\n\tif (ns_capable(ns, CAP_FOWNER) && kuid_has_mapping(ns, inode->i_uid))\n\t\treturn true;\n\treturn false;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"dat.h\"\n#include \"sufile.h\"\n#include \"cpfile.h\"\n#include \"bmap.h\"\n#include \"segment.h\"\n#include \"nilfs.h\"\n#include <linux/nilfs2_fs.h>\n#include <linux/buffer_head.h>\n#include <linux/mount.h>\t/* mnt_want_write_file(), mnt_drop_write_file() */\n#include <linux/compat.h>\t/* compat_ptr() */\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\t/* copy_from_user(), copy_to_user() */\n#include <linux/capability.h>\t/* capable() */\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/fs.h>\n\nstatic int nilfs_ioctl_clean_segments(struct inode *inode, struct file *filp,\n\t\t\t\t      unsigned int cmd, void __user *argp)\n{\n\tstruct nilfs_argv argv[5];\n\tstatic const size_t argsz[5] = {\n\t\tsizeof(struct nilfs_vdesc),\n\t\tsizeof(struct nilfs_period),\n\t\tsizeof(__u64),\n\t\tsizeof(struct nilfs_bdesc),\n\t\tsizeof(__u64),\n\t};\n\tvoid __user *base;\n\tvoid *kbufs[5];\n\tstruct the_nilfs *nilfs;\n\tsize_t len, nsegs;\n\tint n, ret;\n\n\tif (!capable(CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\n\tret = mnt_want_write_file(filp);\n\tif (ret)\n\t\treturn ret;\n\n\tret = -EFAULT;\n\tif (copy_from_user(argv, argp, sizeof(argv)))\n\t\tgoto out;\n\n\tret = -EINVAL;\n\tnsegs = argv[4].v_nmembs;\n\tif (argv[4].v_size != argsz[4])\n\t\tgoto out;\n\tif (nsegs > UINT_MAX / sizeof(__u64))\n\t\tgoto out;\n\n\t/*\n\t * argv[4] points to segment numbers this ioctl cleans.  We\n\t * use kmalloc() for its buffer because memory used for the\n\t * segment numbers is enough small.\n\t */\n\tkbufs[4] = memdup_user((void __user *)(unsigned long)argv[4].v_base,\n\t\t\t       nsegs * sizeof(__u64));\n\tif (IS_ERR(kbufs[4])) {\n\t\tret = PTR_ERR(kbufs[4]);\n\t\tgoto out;\n\t}\n\tnilfs = inode->i_sb->s_fs_info;\n\n\tfor (n = 0; n < 4; n++) {\n\t\tret = -EINVAL;\n\t\tif (argv[n].v_size != argsz[n])\n\t\t\tgoto out_free;\n\n\t\tif (argv[n].v_nmembs > nsegs * nilfs->ns_blocks_per_segment)\n\t\t\tgoto out_free;\n\n\t\tif (argv[n].v_nmembs >= UINT_MAX / argv[n].v_size)\n\t\t\tgoto out_free;\n\n\t\tlen = argv[n].v_size * argv[n].v_nmembs;\n\t\tbase = (void __user *)(unsigned long)argv[n].v_base;\n\t\tif (len == 0) {\n\t\t\tkbufs[n] = NULL;\n\t\t\tcontinue;\n\t\t}\n\n\t\tkbufs[n] = vmalloc(len);\n\t\tif (!kbufs[n]) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto out_free;\n\t\t}\n\t\tif (copy_from_user(kbufs[n], base, len)) {\n\t\t\tret = -EFAULT;\n\t\t\tvfree(kbufs[n]);\n\t\t\tgoto out_free;\n\t\t}\n\t}\n\n\t/*\n\t * nilfs_ioctl_move_blocks() will call nilfs_iget_for_gc(),\n\t * which will operates an inode list without blocking.\n\t * To protect the list from concurrent operations,\n\t * nilfs_ioctl_move_blocks should be atomic operation.\n\t */\n\tif (test_and_set_bit(THE_NILFS_GC_RUNNING, &nilfs->ns_flags)) {\n\t\tret = -EBUSY;\n\t\tgoto out_free;\n\t}\n\n\tret = nilfs_ioctl_move_blocks(inode->i_sb, &argv[0], kbufs[0]);\n\tif (ret < 0)\n\t\tprintk(KERN_ERR \"NILFS: GC failed during preparation: \"\n\t\t\t\"cannot read source blocks: err=%d\\n\", ret);\n\telse {\n\t\tif (nilfs_sb_need_update(nilfs))\n\t\t\tset_nilfs_discontinued(nilfs);\n\t\tret = nilfs_clean_segments(inode->i_sb, argv, kbufs);\n\t}\n\n\tnilfs_remove_all_gcinodes(nilfs);\n\tclear_nilfs_gc_running(nilfs);\n\nout_free:\n\twhile (--n >= 0)\n\t\tvfree(kbufs[n]);\n\tkfree(kbufs[4]);\nout:\n\tmnt_drop_write_file(filp);\n\treturn ret;\n}"
  },
  {
    "function_name": "nilfs_ioctl_prepare_clean_segments",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/ioctl.c",
    "lines": "821-859",
    "snippet": "int nilfs_ioctl_prepare_clean_segments(struct the_nilfs *nilfs,\n\t\t\t\t       struct nilfs_argv *argv, void **kbufs)\n{\n\tconst char *msg;\n\tint ret;\n\n\tret = nilfs_ioctl_delete_checkpoints(nilfs, &argv[1], kbufs[1]);\n\tif (ret < 0) {\n\t\t/*\n\t\t * can safely abort because checkpoints can be removed\n\t\t * independently.\n\t\t */\n\t\tmsg = \"cannot delete checkpoints\";\n\t\tgoto failed;\n\t}\n\tret = nilfs_ioctl_free_vblocknrs(nilfs, &argv[2], kbufs[2]);\n\tif (ret < 0) {\n\t\t/*\n\t\t * can safely abort because DAT file is updated atomically\n\t\t * using a copy-on-write technique.\n\t\t */\n\t\tmsg = \"cannot delete virtual blocks from DAT file\";\n\t\tgoto failed;\n\t}\n\tret = nilfs_ioctl_mark_blocks_dirty(nilfs, &argv[3], kbufs[3]);\n\tif (ret < 0) {\n\t\t/*\n\t\t * can safely abort because the operation is nondestructive.\n\t\t */\n\t\tmsg = \"cannot mark copying blocks dirty\";\n\t\tgoto failed;\n\t}\n\treturn 0;\n\n failed:\n\tprintk(KERN_ERR \"NILFS: GC failed during preparation: %s: err=%d\\n\",\n\t       msg, ret);\n\treturn ret;\n}",
    "includes": [
      "#include \"dat.h\"",
      "#include \"sufile.h\"",
      "#include \"cpfile.h\"",
      "#include \"bmap.h\"",
      "#include \"segment.h\"",
      "#include \"nilfs.h\"",
      "#include <linux/nilfs2_fs.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/mount.h>\t/* mnt_want_write_file(), mnt_drop_write_file() */",
      "#include <linux/compat.h>\t/* compat_ptr() */",
      "#include <linux/vmalloc.h>",
      "#include <linux/uaccess.h>\t/* copy_from_user(), copy_to_user() */",
      "#include <linux/capability.h>\t/* capable() */",
      "#include <linux/slab.h>",
      "#include <linux/wait.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_ERR \"NILFS: GC failed during preparation: %s: err=%d\\n\"",
            "msg",
            "ret"
          ],
          "line": 856
        },
        "resolved": true,
        "details": {
          "function_name": "compat_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/compat.c",
          "lines": "59-69",
          "snippet": "int compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/ioctls.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/aio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/mm.h>",
            "#include <linux/poll.h>",
            "#include <linux/signal.h>",
            "#include <linux/highmem.h>",
            "#include <linux/security.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/personality.h>",
            "#include <linux/highuid.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/dirent.h>",
            "#include <linux/ctype.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/nfs4_mount.h>",
            "#include <linux/ncp_mount.h>",
            "#include <linux/init.h>",
            "#include <linux/ioctl.h>",
            "#include <linux/vfs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/namei.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/errno.h>",
            "#include <linux/compat.h>",
            "#include <linux/linkage.h>",
            "#include <linux/kernel.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int compat_log = 1;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/ioctls.h>\n#include <asm/mmu_context.h>\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/fs_struct.h>\n#include <linux/mm.h>\n#include <linux/poll.h>\n#include <linux/signal.h>\n#include <linux/highmem.h>\n#include <linux/security.h>\n#include <linux/tsacct_kern.h>\n#include <linux/rwsem.h>\n#include <linux/personality.h>\n#include <linux/highuid.h>\n#include <linux/fsnotify.h>\n#include <linux/dirent.h>\n#include <linux/ctype.h>\n#include <linux/syscalls.h>\n#include <linux/nfs4_mount.h>\n#include <linux/ncp_mount.h>\n#include <linux/init.h>\n#include <linux/ioctl.h>\n#include <linux/vfs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/namei.h>\n#include <linux/fcntl.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <linux/compat.h>\n#include <linux/linkage.h>\n#include <linux/kernel.h>\n#include <linux/stddef.h>\n\nint compat_log = 1;\n\nint compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nilfs_ioctl_mark_blocks_dirty",
          "args": [
            "nilfs",
            "&argv[3]",
            "kbufs[3]"
          ],
          "line": 845
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_ioctl_mark_blocks_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/ioctl.c",
          "lines": "780-819",
          "snippet": "static int nilfs_ioctl_mark_blocks_dirty(struct the_nilfs *nilfs,\n\t\t\t\t\t struct nilfs_argv *argv, void *buf)\n{\n\tsize_t nmembs = argv->v_nmembs;\n\tstruct nilfs_bmap *bmap = NILFS_I(nilfs->ns_dat)->i_bmap;\n\tstruct nilfs_bdesc *bdescs = buf;\n\tint ret, i;\n\n\tfor (i = 0; i < nmembs; i++) {\n\t\t/* XXX: use macro or inline func to check liveness */\n\t\tret = nilfs_bmap_lookup_at_level(bmap,\n\t\t\t\t\t\t bdescs[i].bd_offset,\n\t\t\t\t\t\t bdescs[i].bd_level + 1,\n\t\t\t\t\t\t &bdescs[i].bd_blocknr);\n\t\tif (ret < 0) {\n\t\t\tif (ret != -ENOENT)\n\t\t\t\treturn ret;\n\t\t\tbdescs[i].bd_blocknr = 0;\n\t\t}\n\t\tif (bdescs[i].bd_blocknr != bdescs[i].bd_oblocknr)\n\t\t\t/* skip dead block */\n\t\t\tcontinue;\n\t\tif (bdescs[i].bd_level == 0) {\n\t\t\tret = nilfs_mdt_mark_block_dirty(nilfs->ns_dat,\n\t\t\t\t\t\t\t bdescs[i].bd_offset);\n\t\t\tif (ret < 0) {\n\t\t\t\tWARN_ON(ret == -ENOENT);\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t} else {\n\t\t\tret = nilfs_bmap_mark(bmap, bdescs[i].bd_offset,\n\t\t\t\t\t      bdescs[i].bd_level);\n\t\t\tif (ret < 0) {\n\t\t\t\tWARN_ON(ret == -ENOENT);\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t}\n\t}\n\treturn nmembs;\n}",
          "includes": [
            "#include \"dat.h\"",
            "#include \"sufile.h\"",
            "#include \"cpfile.h\"",
            "#include \"bmap.h\"",
            "#include \"segment.h\"",
            "#include \"nilfs.h\"",
            "#include <linux/nilfs2_fs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/mount.h>\t/* mnt_want_write_file(), mnt_drop_write_file() */",
            "#include <linux/compat.h>\t/* compat_ptr() */",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>\t/* copy_from_user(), copy_to_user() */",
            "#include <linux/capability.h>\t/* capable() */",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"dat.h\"\n#include \"sufile.h\"\n#include \"cpfile.h\"\n#include \"bmap.h\"\n#include \"segment.h\"\n#include \"nilfs.h\"\n#include <linux/nilfs2_fs.h>\n#include <linux/buffer_head.h>\n#include <linux/mount.h>\t/* mnt_want_write_file(), mnt_drop_write_file() */\n#include <linux/compat.h>\t/* compat_ptr() */\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\t/* copy_from_user(), copy_to_user() */\n#include <linux/capability.h>\t/* capable() */\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/fs.h>\n\nstatic int nilfs_ioctl_mark_blocks_dirty(struct the_nilfs *nilfs,\n\t\t\t\t\t struct nilfs_argv *argv, void *buf)\n{\n\tsize_t nmembs = argv->v_nmembs;\n\tstruct nilfs_bmap *bmap = NILFS_I(nilfs->ns_dat)->i_bmap;\n\tstruct nilfs_bdesc *bdescs = buf;\n\tint ret, i;\n\n\tfor (i = 0; i < nmembs; i++) {\n\t\t/* XXX: use macro or inline func to check liveness */\n\t\tret = nilfs_bmap_lookup_at_level(bmap,\n\t\t\t\t\t\t bdescs[i].bd_offset,\n\t\t\t\t\t\t bdescs[i].bd_level + 1,\n\t\t\t\t\t\t &bdescs[i].bd_blocknr);\n\t\tif (ret < 0) {\n\t\t\tif (ret != -ENOENT)\n\t\t\t\treturn ret;\n\t\t\tbdescs[i].bd_blocknr = 0;\n\t\t}\n\t\tif (bdescs[i].bd_blocknr != bdescs[i].bd_oblocknr)\n\t\t\t/* skip dead block */\n\t\t\tcontinue;\n\t\tif (bdescs[i].bd_level == 0) {\n\t\t\tret = nilfs_mdt_mark_block_dirty(nilfs->ns_dat,\n\t\t\t\t\t\t\t bdescs[i].bd_offset);\n\t\t\tif (ret < 0) {\n\t\t\t\tWARN_ON(ret == -ENOENT);\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t} else {\n\t\t\tret = nilfs_bmap_mark(bmap, bdescs[i].bd_offset,\n\t\t\t\t\t      bdescs[i].bd_level);\n\t\t\tif (ret < 0) {\n\t\t\t\tWARN_ON(ret == -ENOENT);\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t}\n\t}\n\treturn nmembs;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nilfs_ioctl_free_vblocknrs",
          "args": [
            "nilfs",
            "&argv[2]",
            "kbufs[2]"
          ],
          "line": 836
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_ioctl_free_vblocknrs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/ioctl.c",
          "lines": "751-760",
          "snippet": "static int nilfs_ioctl_free_vblocknrs(struct the_nilfs *nilfs,\n\t\t\t\t      struct nilfs_argv *argv, void *buf)\n{\n\tsize_t nmembs = argv->v_nmembs;\n\tint ret;\n\n\tret = nilfs_dat_freev(nilfs->ns_dat, buf, nmembs);\n\n\treturn (ret < 0) ? ret : nmembs;\n}",
          "includes": [
            "#include \"dat.h\"",
            "#include \"sufile.h\"",
            "#include \"cpfile.h\"",
            "#include \"bmap.h\"",
            "#include \"segment.h\"",
            "#include \"nilfs.h\"",
            "#include <linux/nilfs2_fs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/mount.h>\t/* mnt_want_write_file(), mnt_drop_write_file() */",
            "#include <linux/compat.h>\t/* compat_ptr() */",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>\t/* copy_from_user(), copy_to_user() */",
            "#include <linux/capability.h>\t/* capable() */",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"dat.h\"\n#include \"sufile.h\"\n#include \"cpfile.h\"\n#include \"bmap.h\"\n#include \"segment.h\"\n#include \"nilfs.h\"\n#include <linux/nilfs2_fs.h>\n#include <linux/buffer_head.h>\n#include <linux/mount.h>\t/* mnt_want_write_file(), mnt_drop_write_file() */\n#include <linux/compat.h>\t/* compat_ptr() */\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\t/* copy_from_user(), copy_to_user() */\n#include <linux/capability.h>\t/* capable() */\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/fs.h>\n\nstatic int nilfs_ioctl_free_vblocknrs(struct the_nilfs *nilfs,\n\t\t\t\t      struct nilfs_argv *argv, void *buf)\n{\n\tsize_t nmembs = argv->v_nmembs;\n\tint ret;\n\n\tret = nilfs_dat_freev(nilfs->ns_dat, buf, nmembs);\n\n\treturn (ret < 0) ? ret : nmembs;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nilfs_ioctl_delete_checkpoints",
          "args": [
            "nilfs",
            "&argv[1]",
            "kbufs[1]"
          ],
          "line": 827
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_ioctl_delete_checkpoints",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/ioctl.c",
          "lines": "716-731",
          "snippet": "static int nilfs_ioctl_delete_checkpoints(struct the_nilfs *nilfs,\n\t\t\t\t\t  struct nilfs_argv *argv, void *buf)\n{\n\tsize_t nmembs = argv->v_nmembs;\n\tstruct inode *cpfile = nilfs->ns_cpfile;\n\tstruct nilfs_period *periods = buf;\n\tint ret, i;\n\n\tfor (i = 0; i < nmembs; i++) {\n\t\tret = nilfs_cpfile_delete_checkpoints(\n\t\t\tcpfile, periods[i].p_start, periods[i].p_end);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\treturn nmembs;\n}",
          "includes": [
            "#include \"dat.h\"",
            "#include \"sufile.h\"",
            "#include \"cpfile.h\"",
            "#include \"bmap.h\"",
            "#include \"segment.h\"",
            "#include \"nilfs.h\"",
            "#include <linux/nilfs2_fs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/mount.h>\t/* mnt_want_write_file(), mnt_drop_write_file() */",
            "#include <linux/compat.h>\t/* compat_ptr() */",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>\t/* copy_from_user(), copy_to_user() */",
            "#include <linux/capability.h>\t/* capable() */",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"dat.h\"\n#include \"sufile.h\"\n#include \"cpfile.h\"\n#include \"bmap.h\"\n#include \"segment.h\"\n#include \"nilfs.h\"\n#include <linux/nilfs2_fs.h>\n#include <linux/buffer_head.h>\n#include <linux/mount.h>\t/* mnt_want_write_file(), mnt_drop_write_file() */\n#include <linux/compat.h>\t/* compat_ptr() */\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\t/* copy_from_user(), copy_to_user() */\n#include <linux/capability.h>\t/* capable() */\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/fs.h>\n\nstatic int nilfs_ioctl_delete_checkpoints(struct the_nilfs *nilfs,\n\t\t\t\t\t  struct nilfs_argv *argv, void *buf)\n{\n\tsize_t nmembs = argv->v_nmembs;\n\tstruct inode *cpfile = nilfs->ns_cpfile;\n\tstruct nilfs_period *periods = buf;\n\tint ret, i;\n\n\tfor (i = 0; i < nmembs; i++) {\n\t\tret = nilfs_cpfile_delete_checkpoints(\n\t\t\tcpfile, periods[i].p_start, periods[i].p_end);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\treturn nmembs;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"dat.h\"\n#include \"sufile.h\"\n#include \"cpfile.h\"\n#include \"bmap.h\"\n#include \"segment.h\"\n#include \"nilfs.h\"\n#include <linux/nilfs2_fs.h>\n#include <linux/buffer_head.h>\n#include <linux/mount.h>\t/* mnt_want_write_file(), mnt_drop_write_file() */\n#include <linux/compat.h>\t/* compat_ptr() */\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\t/* copy_from_user(), copy_to_user() */\n#include <linux/capability.h>\t/* capable() */\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/fs.h>\n\nint nilfs_ioctl_prepare_clean_segments(struct the_nilfs *nilfs,\n\t\t\t\t       struct nilfs_argv *argv, void **kbufs)\n{\n\tconst char *msg;\n\tint ret;\n\n\tret = nilfs_ioctl_delete_checkpoints(nilfs, &argv[1], kbufs[1]);\n\tif (ret < 0) {\n\t\t/*\n\t\t * can safely abort because checkpoints can be removed\n\t\t * independently.\n\t\t */\n\t\tmsg = \"cannot delete checkpoints\";\n\t\tgoto failed;\n\t}\n\tret = nilfs_ioctl_free_vblocknrs(nilfs, &argv[2], kbufs[2]);\n\tif (ret < 0) {\n\t\t/*\n\t\t * can safely abort because DAT file is updated atomically\n\t\t * using a copy-on-write technique.\n\t\t */\n\t\tmsg = \"cannot delete virtual blocks from DAT file\";\n\t\tgoto failed;\n\t}\n\tret = nilfs_ioctl_mark_blocks_dirty(nilfs, &argv[3], kbufs[3]);\n\tif (ret < 0) {\n\t\t/*\n\t\t * can safely abort because the operation is nondestructive.\n\t\t */\n\t\tmsg = \"cannot mark copying blocks dirty\";\n\t\tgoto failed;\n\t}\n\treturn 0;\n\n failed:\n\tprintk(KERN_ERR \"NILFS: GC failed during preparation: %s: err=%d\\n\",\n\t       msg, ret);\n\treturn ret;\n}"
  },
  {
    "function_name": "nilfs_ioctl_mark_blocks_dirty",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/ioctl.c",
    "lines": "780-819",
    "snippet": "static int nilfs_ioctl_mark_blocks_dirty(struct the_nilfs *nilfs,\n\t\t\t\t\t struct nilfs_argv *argv, void *buf)\n{\n\tsize_t nmembs = argv->v_nmembs;\n\tstruct nilfs_bmap *bmap = NILFS_I(nilfs->ns_dat)->i_bmap;\n\tstruct nilfs_bdesc *bdescs = buf;\n\tint ret, i;\n\n\tfor (i = 0; i < nmembs; i++) {\n\t\t/* XXX: use macro or inline func to check liveness */\n\t\tret = nilfs_bmap_lookup_at_level(bmap,\n\t\t\t\t\t\t bdescs[i].bd_offset,\n\t\t\t\t\t\t bdescs[i].bd_level + 1,\n\t\t\t\t\t\t &bdescs[i].bd_blocknr);\n\t\tif (ret < 0) {\n\t\t\tif (ret != -ENOENT)\n\t\t\t\treturn ret;\n\t\t\tbdescs[i].bd_blocknr = 0;\n\t\t}\n\t\tif (bdescs[i].bd_blocknr != bdescs[i].bd_oblocknr)\n\t\t\t/* skip dead block */\n\t\t\tcontinue;\n\t\tif (bdescs[i].bd_level == 0) {\n\t\t\tret = nilfs_mdt_mark_block_dirty(nilfs->ns_dat,\n\t\t\t\t\t\t\t bdescs[i].bd_offset);\n\t\t\tif (ret < 0) {\n\t\t\t\tWARN_ON(ret == -ENOENT);\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t} else {\n\t\t\tret = nilfs_bmap_mark(bmap, bdescs[i].bd_offset,\n\t\t\t\t\t      bdescs[i].bd_level);\n\t\t\tif (ret < 0) {\n\t\t\t\tWARN_ON(ret == -ENOENT);\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t}\n\t}\n\treturn nmembs;\n}",
    "includes": [
      "#include \"dat.h\"",
      "#include \"sufile.h\"",
      "#include \"cpfile.h\"",
      "#include \"bmap.h\"",
      "#include \"segment.h\"",
      "#include \"nilfs.h\"",
      "#include <linux/nilfs2_fs.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/mount.h>\t/* mnt_want_write_file(), mnt_drop_write_file() */",
      "#include <linux/compat.h>\t/* compat_ptr() */",
      "#include <linux/vmalloc.h>",
      "#include <linux/uaccess.h>\t/* copy_from_user(), copy_to_user() */",
      "#include <linux/capability.h>\t/* capable() */",
      "#include <linux/slab.h>",
      "#include <linux/wait.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "ret == -ENOENT"
          ],
          "line": 813
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nilfs_bmap_mark",
          "args": [
            "bmap",
            "bdescs[i].bd_offset",
            "bdescs[i].bd_level"
          ],
          "line": 810
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_bmap_mark",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/bmap.c",
          "lines": "391-403",
          "snippet": "int nilfs_bmap_mark(struct nilfs_bmap *bmap, __u64 key, int level)\n{\n\tint ret;\n\n\tif (bmap->b_ops->bop_mark == NULL)\n\t\treturn 0;\n\n\tdown_write(&bmap->b_sem);\n\tret = bmap->b_ops->bop_mark(bmap, key, level);\n\tup_write(&bmap->b_sem);\n\n\treturn nilfs_bmap_convert_error(bmap, __func__, ret);\n}",
          "includes": [
            "#include \"alloc.h\"",
            "#include \"dat.h\"",
            "#include \"mdt.h\"",
            "#include \"btnode.h\"",
            "#include \"direct.h\"",
            "#include \"btree.h\"",
            "#include \"bmap.h\"",
            "#include \"nilfs.h\"",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"alloc.h\"\n#include \"dat.h\"\n#include \"mdt.h\"\n#include \"btnode.h\"\n#include \"direct.h\"\n#include \"btree.h\"\n#include \"bmap.h\"\n#include \"nilfs.h\"\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/fs.h>\n\nint nilfs_bmap_mark(struct nilfs_bmap *bmap, __u64 key, int level)\n{\n\tint ret;\n\n\tif (bmap->b_ops->bop_mark == NULL)\n\t\treturn 0;\n\n\tdown_write(&bmap->b_sem);\n\tret = bmap->b_ops->bop_mark(bmap, key, level);\n\tup_write(&bmap->b_sem);\n\n\treturn nilfs_bmap_convert_error(bmap, __func__, ret);\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "ret == -ENOENT"
          ],
          "line": 806
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nilfs_mdt_mark_block_dirty",
          "args": [
            "nilfs->ns_dat",
            "bdescs[i].bd_offset"
          ],
          "line": 803
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_mdt_mark_block_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/mdt.c",
          "lines": "350-362",
          "snippet": "int nilfs_mdt_mark_block_dirty(struct inode *inode, unsigned long block)\n{\n\tstruct buffer_head *bh;\n\tint err;\n\n\terr = nilfs_mdt_read_block(inode, block, 0, &bh);\n\tif (unlikely(err))\n\t\treturn err;\n\tmark_buffer_dirty(bh);\n\tnilfs_mdt_mark_dirty(inode);\n\tbrelse(bh);\n\treturn 0;\n}",
          "includes": [
            "#include \"mdt.h\"",
            "#include \"page.h\"",
            "#include \"segment.h\"",
            "#include \"btnode.h\"",
            "#include \"nilfs.h\"",
            "#include <linux/slab.h>",
            "#include <linux/swap.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mm.h>",
            "#include <linux/mpage.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"mdt.h\"\n#include \"page.h\"\n#include \"segment.h\"\n#include \"btnode.h\"\n#include \"nilfs.h\"\n#include <linux/slab.h>\n#include <linux/swap.h>\n#include <linux/backing-dev.h>\n#include <linux/writeback.h>\n#include <linux/mm.h>\n#include <linux/mpage.h>\n#include <linux/buffer_head.h>\n\nint nilfs_mdt_mark_block_dirty(struct inode *inode, unsigned long block)\n{\n\tstruct buffer_head *bh;\n\tint err;\n\n\terr = nilfs_mdt_read_block(inode, block, 0, &bh);\n\tif (unlikely(err))\n\t\treturn err;\n\tmark_buffer_dirty(bh);\n\tnilfs_mdt_mark_dirty(inode);\n\tbrelse(bh);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nilfs_bmap_lookup_at_level",
          "args": [
            "bmap",
            "bdescs[i].bd_offset",
            "bdescs[i].bd_level + 1",
            "&bdescs[i].bd_blocknr"
          ],
          "line": 790
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_bmap_lookup_at_level",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/bmap.c",
          "lines": "75-97",
          "snippet": "int nilfs_bmap_lookup_at_level(struct nilfs_bmap *bmap, __u64 key, int level,\n\t\t\t       __u64 *ptrp)\n{\n\tsector_t blocknr;\n\tint ret;\n\n\tdown_read(&bmap->b_sem);\n\tret = bmap->b_ops->bop_lookup(bmap, key, level, ptrp);\n\tif (ret < 0) {\n\t\tret = nilfs_bmap_convert_error(bmap, __func__, ret);\n\t\tgoto out;\n\t}\n\tif (NILFS_BMAP_USE_VBN(bmap)) {\n\t\tret = nilfs_dat_translate(nilfs_bmap_get_dat(bmap), *ptrp,\n\t\t\t\t\t  &blocknr);\n\t\tif (!ret)\n\t\t\t*ptrp = blocknr;\n\t}\n\n out:\n\tup_read(&bmap->b_sem);\n\treturn ret;\n}",
          "includes": [
            "#include \"alloc.h\"",
            "#include \"dat.h\"",
            "#include \"mdt.h\"",
            "#include \"btnode.h\"",
            "#include \"direct.h\"",
            "#include \"btree.h\"",
            "#include \"bmap.h\"",
            "#include \"nilfs.h\"",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"alloc.h\"\n#include \"dat.h\"\n#include \"mdt.h\"\n#include \"btnode.h\"\n#include \"direct.h\"\n#include \"btree.h\"\n#include \"bmap.h\"\n#include \"nilfs.h\"\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/fs.h>\n\nint nilfs_bmap_lookup_at_level(struct nilfs_bmap *bmap, __u64 key, int level,\n\t\t\t       __u64 *ptrp)\n{\n\tsector_t blocknr;\n\tint ret;\n\n\tdown_read(&bmap->b_sem);\n\tret = bmap->b_ops->bop_lookup(bmap, key, level, ptrp);\n\tif (ret < 0) {\n\t\tret = nilfs_bmap_convert_error(bmap, __func__, ret);\n\t\tgoto out;\n\t}\n\tif (NILFS_BMAP_USE_VBN(bmap)) {\n\t\tret = nilfs_dat_translate(nilfs_bmap_get_dat(bmap), *ptrp,\n\t\t\t\t\t  &blocknr);\n\t\tif (!ret)\n\t\t\t*ptrp = blocknr;\n\t}\n\n out:\n\tup_read(&bmap->b_sem);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "NILFS_I",
          "args": [
            "nilfs->ns_dat"
          ],
          "line": 784
        },
        "resolved": true,
        "details": {
          "function_name": "NILFS_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/nilfs.h",
          "lines": "78-81",
          "snippet": "static inline struct nilfs_inode_info *NILFS_I(const struct inode *inode)\n{\n\treturn container_of(inode, struct nilfs_inode_info, vfs_inode);\n}",
          "includes": [
            "#include \"bmap.h\"",
            "#include \"the_nilfs.h\"",
            "#include <linux/nilfs2_fs.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"bmap.h\"\n#include \"the_nilfs.h\"\n#include <linux/nilfs2_fs.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/buffer_head.h>\n#include <linux/kernel.h>\n\nstatic inline struct nilfs_inode_info *NILFS_I(const struct inode *inode)\n{\n\treturn container_of(inode, struct nilfs_inode_info, vfs_inode);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"dat.h\"\n#include \"sufile.h\"\n#include \"cpfile.h\"\n#include \"bmap.h\"\n#include \"segment.h\"\n#include \"nilfs.h\"\n#include <linux/nilfs2_fs.h>\n#include <linux/buffer_head.h>\n#include <linux/mount.h>\t/* mnt_want_write_file(), mnt_drop_write_file() */\n#include <linux/compat.h>\t/* compat_ptr() */\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\t/* copy_from_user(), copy_to_user() */\n#include <linux/capability.h>\t/* capable() */\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/fs.h>\n\nstatic int nilfs_ioctl_mark_blocks_dirty(struct the_nilfs *nilfs,\n\t\t\t\t\t struct nilfs_argv *argv, void *buf)\n{\n\tsize_t nmembs = argv->v_nmembs;\n\tstruct nilfs_bmap *bmap = NILFS_I(nilfs->ns_dat)->i_bmap;\n\tstruct nilfs_bdesc *bdescs = buf;\n\tint ret, i;\n\n\tfor (i = 0; i < nmembs; i++) {\n\t\t/* XXX: use macro or inline func to check liveness */\n\t\tret = nilfs_bmap_lookup_at_level(bmap,\n\t\t\t\t\t\t bdescs[i].bd_offset,\n\t\t\t\t\t\t bdescs[i].bd_level + 1,\n\t\t\t\t\t\t &bdescs[i].bd_blocknr);\n\t\tif (ret < 0) {\n\t\t\tif (ret != -ENOENT)\n\t\t\t\treturn ret;\n\t\t\tbdescs[i].bd_blocknr = 0;\n\t\t}\n\t\tif (bdescs[i].bd_blocknr != bdescs[i].bd_oblocknr)\n\t\t\t/* skip dead block */\n\t\t\tcontinue;\n\t\tif (bdescs[i].bd_level == 0) {\n\t\t\tret = nilfs_mdt_mark_block_dirty(nilfs->ns_dat,\n\t\t\t\t\t\t\t bdescs[i].bd_offset);\n\t\t\tif (ret < 0) {\n\t\t\t\tWARN_ON(ret == -ENOENT);\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t} else {\n\t\t\tret = nilfs_bmap_mark(bmap, bdescs[i].bd_offset,\n\t\t\t\t\t      bdescs[i].bd_level);\n\t\t\tif (ret < 0) {\n\t\t\t\tWARN_ON(ret == -ENOENT);\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t}\n\t}\n\treturn nmembs;\n}"
  },
  {
    "function_name": "nilfs_ioctl_free_vblocknrs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/ioctl.c",
    "lines": "751-760",
    "snippet": "static int nilfs_ioctl_free_vblocknrs(struct the_nilfs *nilfs,\n\t\t\t\t      struct nilfs_argv *argv, void *buf)\n{\n\tsize_t nmembs = argv->v_nmembs;\n\tint ret;\n\n\tret = nilfs_dat_freev(nilfs->ns_dat, buf, nmembs);\n\n\treturn (ret < 0) ? ret : nmembs;\n}",
    "includes": [
      "#include \"dat.h\"",
      "#include \"sufile.h\"",
      "#include \"cpfile.h\"",
      "#include \"bmap.h\"",
      "#include \"segment.h\"",
      "#include \"nilfs.h\"",
      "#include <linux/nilfs2_fs.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/mount.h>\t/* mnt_want_write_file(), mnt_drop_write_file() */",
      "#include <linux/compat.h>\t/* compat_ptr() */",
      "#include <linux/vmalloc.h>",
      "#include <linux/uaccess.h>\t/* copy_from_user(), copy_to_user() */",
      "#include <linux/capability.h>\t/* capable() */",
      "#include <linux/slab.h>",
      "#include <linux/wait.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "nilfs_dat_freev",
          "args": [
            "nilfs->ns_dat",
            "buf",
            "nmembs"
          ],
          "line": 757
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_dat_freev",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/dat.c",
          "lines": "307-310",
          "snippet": "int nilfs_dat_freev(struct inode *dat, __u64 *vblocknrs, size_t nitems)\n{\n\treturn nilfs_palloc_freev(dat, vblocknrs, nitems);\n}",
          "includes": [
            "#include \"dat.h\"",
            "#include \"alloc.h\"",
            "#include \"mdt.h\"",
            "#include \"nilfs.h\"",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"dat.h\"\n#include \"alloc.h\"\n#include \"mdt.h\"\n#include \"nilfs.h\"\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/buffer_head.h>\n#include <linux/types.h>\n\nint nilfs_dat_freev(struct inode *dat, __u64 *vblocknrs, size_t nitems)\n{\n\treturn nilfs_palloc_freev(dat, vblocknrs, nitems);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"dat.h\"\n#include \"sufile.h\"\n#include \"cpfile.h\"\n#include \"bmap.h\"\n#include \"segment.h\"\n#include \"nilfs.h\"\n#include <linux/nilfs2_fs.h>\n#include <linux/buffer_head.h>\n#include <linux/mount.h>\t/* mnt_want_write_file(), mnt_drop_write_file() */\n#include <linux/compat.h>\t/* compat_ptr() */\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\t/* copy_from_user(), copy_to_user() */\n#include <linux/capability.h>\t/* capable() */\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/fs.h>\n\nstatic int nilfs_ioctl_free_vblocknrs(struct the_nilfs *nilfs,\n\t\t\t\t      struct nilfs_argv *argv, void *buf)\n{\n\tsize_t nmembs = argv->v_nmembs;\n\tint ret;\n\n\tret = nilfs_dat_freev(nilfs->ns_dat, buf, nmembs);\n\n\treturn (ret < 0) ? ret : nmembs;\n}"
  },
  {
    "function_name": "nilfs_ioctl_delete_checkpoints",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/ioctl.c",
    "lines": "716-731",
    "snippet": "static int nilfs_ioctl_delete_checkpoints(struct the_nilfs *nilfs,\n\t\t\t\t\t  struct nilfs_argv *argv, void *buf)\n{\n\tsize_t nmembs = argv->v_nmembs;\n\tstruct inode *cpfile = nilfs->ns_cpfile;\n\tstruct nilfs_period *periods = buf;\n\tint ret, i;\n\n\tfor (i = 0; i < nmembs; i++) {\n\t\tret = nilfs_cpfile_delete_checkpoints(\n\t\t\tcpfile, periods[i].p_start, periods[i].p_end);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\treturn nmembs;\n}",
    "includes": [
      "#include \"dat.h\"",
      "#include \"sufile.h\"",
      "#include \"cpfile.h\"",
      "#include \"bmap.h\"",
      "#include \"segment.h\"",
      "#include \"nilfs.h\"",
      "#include <linux/nilfs2_fs.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/mount.h>\t/* mnt_want_write_file(), mnt_drop_write_file() */",
      "#include <linux/compat.h>\t/* compat_ptr() */",
      "#include <linux/vmalloc.h>",
      "#include <linux/uaccess.h>\t/* copy_from_user(), copy_to_user() */",
      "#include <linux/capability.h>\t/* capable() */",
      "#include <linux/slab.h>",
      "#include <linux/wait.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "nilfs_cpfile_delete_checkpoints",
          "args": [
            "cpfile",
            "periods[i].p_start",
            "periods[i].p_end"
          ],
          "line": 725
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_cpfile_delete_checkpoints",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/cpfile.c",
          "lines": "278-375",
          "snippet": "int nilfs_cpfile_delete_checkpoints(struct inode *cpfile,\n\t\t\t\t    __u64 start,\n\t\t\t\t    __u64 end)\n{\n\tstruct buffer_head *header_bh, *cp_bh;\n\tstruct nilfs_cpfile_header *header;\n\tstruct nilfs_checkpoint *cp;\n\tsize_t cpsz = NILFS_MDT(cpfile)->mi_entry_size;\n\t__u64 cno;\n\tvoid *kaddr;\n\tunsigned long tnicps;\n\tint ret, ncps, nicps, nss, count, i;\n\n\tif (unlikely(start == 0 || start > end)) {\n\t\tprintk(KERN_ERR \"%s: invalid range of checkpoint numbers: \"\n\t\t       \"[%llu, %llu)\\n\", __func__,\n\t\t       (unsigned long long)start, (unsigned long long)end);\n\t\treturn -EINVAL;\n\t}\n\n\tdown_write(&NILFS_MDT(cpfile)->mi_sem);\n\n\tret = nilfs_cpfile_get_header_block(cpfile, &header_bh);\n\tif (ret < 0)\n\t\tgoto out_sem;\n\ttnicps = 0;\n\tnss = 0;\n\n\tfor (cno = start; cno < end; cno += ncps) {\n\t\tncps = nilfs_cpfile_checkpoints_in_block(cpfile, cno, end);\n\t\tret = nilfs_cpfile_get_checkpoint_block(cpfile, cno, 0, &cp_bh);\n\t\tif (ret < 0) {\n\t\t\tif (ret != -ENOENT)\n\t\t\t\tbreak;\n\t\t\t/* skip hole */\n\t\t\tret = 0;\n\t\t\tcontinue;\n\t\t}\n\n\t\tkaddr = kmap_atomic(cp_bh->b_page);\n\t\tcp = nilfs_cpfile_block_get_checkpoint(\n\t\t\tcpfile, cno, cp_bh, kaddr);\n\t\tnicps = 0;\n\t\tfor (i = 0; i < ncps; i++, cp = (void *)cp + cpsz) {\n\t\t\tif (nilfs_checkpoint_snapshot(cp)) {\n\t\t\t\tnss++;\n\t\t\t} else if (!nilfs_checkpoint_invalid(cp)) {\n\t\t\t\tnilfs_checkpoint_set_invalid(cp);\n\t\t\t\tnicps++;\n\t\t\t}\n\t\t}\n\t\tif (nicps > 0) {\n\t\t\ttnicps += nicps;\n\t\t\tmark_buffer_dirty(cp_bh);\n\t\t\tnilfs_mdt_mark_dirty(cpfile);\n\t\t\tif (!nilfs_cpfile_is_in_first(cpfile, cno)) {\n\t\t\t\tcount =\n\t\t\t\t  nilfs_cpfile_block_sub_valid_checkpoints(\n\t\t\t\t\t\tcpfile, cp_bh, kaddr, nicps);\n\t\t\t\tif (count == 0) {\n\t\t\t\t\t/* make hole */\n\t\t\t\t\tkunmap_atomic(kaddr);\n\t\t\t\t\tbrelse(cp_bh);\n\t\t\t\t\tret =\n\t\t\t\t\t  nilfs_cpfile_delete_checkpoint_block(\n\t\t\t\t\t\t\t\t   cpfile, cno);\n\t\t\t\t\tif (ret == 0)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tprintk(KERN_ERR\n\t\t\t\t\t       \"%s: cannot delete block\\n\",\n\t\t\t\t\t       __func__);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tkunmap_atomic(kaddr);\n\t\tbrelse(cp_bh);\n\t}\n\n\tif (tnicps > 0) {\n\t\tkaddr = kmap_atomic(header_bh->b_page);\n\t\theader = nilfs_cpfile_block_get_header(cpfile, header_bh,\n\t\t\t\t\t\t       kaddr);\n\t\tle64_add_cpu(&header->ch_ncheckpoints, -(u64)tnicps);\n\t\tmark_buffer_dirty(header_bh);\n\t\tnilfs_mdt_mark_dirty(cpfile);\n\t\tkunmap_atomic(kaddr);\n\t}\n\n\tbrelse(header_bh);\n\tif (nss > 0)\n\t\tret = -EBUSY;\n\n out_sem:\n\tup_write(&NILFS_MDT(cpfile)->mi_sem);\n\treturn ret;\n}",
          "includes": [
            "#include \"cpfile.h\"",
            "#include \"mdt.h\"",
            "#include <linux/nilfs2_fs.h>",
            "#include <linux/errno.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/fs.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cpfile.h\"\n#include \"mdt.h\"\n#include <linux/nilfs2_fs.h>\n#include <linux/errno.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/fs.h>\n#include <linux/kernel.h>\n\nint nilfs_cpfile_delete_checkpoints(struct inode *cpfile,\n\t\t\t\t    __u64 start,\n\t\t\t\t    __u64 end)\n{\n\tstruct buffer_head *header_bh, *cp_bh;\n\tstruct nilfs_cpfile_header *header;\n\tstruct nilfs_checkpoint *cp;\n\tsize_t cpsz = NILFS_MDT(cpfile)->mi_entry_size;\n\t__u64 cno;\n\tvoid *kaddr;\n\tunsigned long tnicps;\n\tint ret, ncps, nicps, nss, count, i;\n\n\tif (unlikely(start == 0 || start > end)) {\n\t\tprintk(KERN_ERR \"%s: invalid range of checkpoint numbers: \"\n\t\t       \"[%llu, %llu)\\n\", __func__,\n\t\t       (unsigned long long)start, (unsigned long long)end);\n\t\treturn -EINVAL;\n\t}\n\n\tdown_write(&NILFS_MDT(cpfile)->mi_sem);\n\n\tret = nilfs_cpfile_get_header_block(cpfile, &header_bh);\n\tif (ret < 0)\n\t\tgoto out_sem;\n\ttnicps = 0;\n\tnss = 0;\n\n\tfor (cno = start; cno < end; cno += ncps) {\n\t\tncps = nilfs_cpfile_checkpoints_in_block(cpfile, cno, end);\n\t\tret = nilfs_cpfile_get_checkpoint_block(cpfile, cno, 0, &cp_bh);\n\t\tif (ret < 0) {\n\t\t\tif (ret != -ENOENT)\n\t\t\t\tbreak;\n\t\t\t/* skip hole */\n\t\t\tret = 0;\n\t\t\tcontinue;\n\t\t}\n\n\t\tkaddr = kmap_atomic(cp_bh->b_page);\n\t\tcp = nilfs_cpfile_block_get_checkpoint(\n\t\t\tcpfile, cno, cp_bh, kaddr);\n\t\tnicps = 0;\n\t\tfor (i = 0; i < ncps; i++, cp = (void *)cp + cpsz) {\n\t\t\tif (nilfs_checkpoint_snapshot(cp)) {\n\t\t\t\tnss++;\n\t\t\t} else if (!nilfs_checkpoint_invalid(cp)) {\n\t\t\t\tnilfs_checkpoint_set_invalid(cp);\n\t\t\t\tnicps++;\n\t\t\t}\n\t\t}\n\t\tif (nicps > 0) {\n\t\t\ttnicps += nicps;\n\t\t\tmark_buffer_dirty(cp_bh);\n\t\t\tnilfs_mdt_mark_dirty(cpfile);\n\t\t\tif (!nilfs_cpfile_is_in_first(cpfile, cno)) {\n\t\t\t\tcount =\n\t\t\t\t  nilfs_cpfile_block_sub_valid_checkpoints(\n\t\t\t\t\t\tcpfile, cp_bh, kaddr, nicps);\n\t\t\t\tif (count == 0) {\n\t\t\t\t\t/* make hole */\n\t\t\t\t\tkunmap_atomic(kaddr);\n\t\t\t\t\tbrelse(cp_bh);\n\t\t\t\t\tret =\n\t\t\t\t\t  nilfs_cpfile_delete_checkpoint_block(\n\t\t\t\t\t\t\t\t   cpfile, cno);\n\t\t\t\t\tif (ret == 0)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tprintk(KERN_ERR\n\t\t\t\t\t       \"%s: cannot delete block\\n\",\n\t\t\t\t\t       __func__);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tkunmap_atomic(kaddr);\n\t\tbrelse(cp_bh);\n\t}\n\n\tif (tnicps > 0) {\n\t\tkaddr = kmap_atomic(header_bh->b_page);\n\t\theader = nilfs_cpfile_block_get_header(cpfile, header_bh,\n\t\t\t\t\t\t       kaddr);\n\t\tle64_add_cpu(&header->ch_ncheckpoints, -(u64)tnicps);\n\t\tmark_buffer_dirty(header_bh);\n\t\tnilfs_mdt_mark_dirty(cpfile);\n\t\tkunmap_atomic(kaddr);\n\t}\n\n\tbrelse(header_bh);\n\tif (nss > 0)\n\t\tret = -EBUSY;\n\n out_sem:\n\tup_write(&NILFS_MDT(cpfile)->mi_sem);\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"dat.h\"\n#include \"sufile.h\"\n#include \"cpfile.h\"\n#include \"bmap.h\"\n#include \"segment.h\"\n#include \"nilfs.h\"\n#include <linux/nilfs2_fs.h>\n#include <linux/buffer_head.h>\n#include <linux/mount.h>\t/* mnt_want_write_file(), mnt_drop_write_file() */\n#include <linux/compat.h>\t/* compat_ptr() */\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\t/* copy_from_user(), copy_to_user() */\n#include <linux/capability.h>\t/* capable() */\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/fs.h>\n\nstatic int nilfs_ioctl_delete_checkpoints(struct the_nilfs *nilfs,\n\t\t\t\t\t  struct nilfs_argv *argv, void *buf)\n{\n\tsize_t nmembs = argv->v_nmembs;\n\tstruct inode *cpfile = nilfs->ns_cpfile;\n\tstruct nilfs_period *periods = buf;\n\tint ret, i;\n\n\tfor (i = 0; i < nmembs; i++) {\n\t\tret = nilfs_cpfile_delete_checkpoints(\n\t\t\tcpfile, periods[i].p_start, periods[i].p_end);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\treturn nmembs;\n}"
  },
  {
    "function_name": "nilfs_ioctl_move_blocks",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/ioctl.c",
    "lines": "632-695",
    "snippet": "static int nilfs_ioctl_move_blocks(struct super_block *sb,\n\t\t\t\t   struct nilfs_argv *argv, void *buf)\n{\n\tsize_t nmembs = argv->v_nmembs;\n\tstruct the_nilfs *nilfs = sb->s_fs_info;\n\tstruct inode *inode;\n\tstruct nilfs_vdesc *vdesc;\n\tstruct buffer_head *bh, *n;\n\tLIST_HEAD(buffers);\n\tino_t ino;\n\t__u64 cno;\n\tint i, ret;\n\n\tfor (i = 0, vdesc = buf; i < nmembs; ) {\n\t\tino = vdesc->vd_ino;\n\t\tcno = vdesc->vd_cno;\n\t\tinode = nilfs_iget_for_gc(sb, ino, cno);\n\t\tif (IS_ERR(inode)) {\n\t\t\tret = PTR_ERR(inode);\n\t\t\tgoto failed;\n\t\t}\n\t\tif (list_empty(&NILFS_I(inode)->i_dirty)) {\n\t\t\t/*\n\t\t\t * Add the inode to GC inode list. Garbage Collection\n\t\t\t * is serialized and no two processes manipulate the\n\t\t\t * list simultaneously.\n\t\t\t */\n\t\t\tigrab(inode);\n\t\t\tlist_add(&NILFS_I(inode)->i_dirty,\n\t\t\t\t &nilfs->ns_gc_inodes);\n\t\t}\n\n\t\tdo {\n\t\t\tret = nilfs_ioctl_move_inode_block(inode, vdesc,\n\t\t\t\t\t\t\t   &buffers);\n\t\t\tif (unlikely(ret < 0)) {\n\t\t\t\tiput(inode);\n\t\t\t\tgoto failed;\n\t\t\t}\n\t\t\tvdesc++;\n\t\t} while (++i < nmembs &&\n\t\t\t vdesc->vd_ino == ino && vdesc->vd_cno == cno);\n\n\t\tiput(inode); /* The inode still remains in GC inode list */\n\t}\n\n\tlist_for_each_entry_safe(bh, n, &buffers, b_assoc_buffers) {\n\t\tret = nilfs_gccache_wait_and_mark_dirty(bh);\n\t\tif (unlikely(ret < 0)) {\n\t\t\tWARN_ON(ret == -EEXIST);\n\t\t\tgoto failed;\n\t\t}\n\t\tlist_del_init(&bh->b_assoc_buffers);\n\t\tbrelse(bh);\n\t}\n\treturn nmembs;\n\n failed:\n\tlist_for_each_entry_safe(bh, n, &buffers, b_assoc_buffers) {\n\t\tlist_del_init(&bh->b_assoc_buffers);\n\t\tbrelse(bh);\n\t}\n\treturn ret;\n}",
    "includes": [
      "#include \"dat.h\"",
      "#include \"sufile.h\"",
      "#include \"cpfile.h\"",
      "#include \"bmap.h\"",
      "#include \"segment.h\"",
      "#include \"nilfs.h\"",
      "#include <linux/nilfs2_fs.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/mount.h>\t/* mnt_want_write_file(), mnt_drop_write_file() */",
      "#include <linux/compat.h>\t/* compat_ptr() */",
      "#include <linux/vmalloc.h>",
      "#include <linux/uaccess.h>\t/* copy_from_user(), copy_to_user() */",
      "#include <linux/capability.h>\t/* capable() */",
      "#include <linux/slab.h>",
      "#include <linux/wait.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "bh"
          ],
          "line": 692
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_del_init",
          "args": [
            "&bh->b_assoc_buffers"
          ],
          "line": 691
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry_safe",
          "args": [
            "bh",
            "n",
            "&buffers",
            "b_assoc_buffers"
          ],
          "line": 690
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_del_init",
          "args": [
            "&bh->b_assoc_buffers"
          ],
          "line": 684
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "ret == -EEXIST"
          ],
          "line": 681
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "ret < 0"
          ],
          "line": 680
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nilfs_gccache_wait_and_mark_dirty",
          "args": [
            "bh"
          ],
          "line": 679
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_gccache_wait_and_mark_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/gcinode.c",
          "lines": "152-166",
          "snippet": "int nilfs_gccache_wait_and_mark_dirty(struct buffer_head *bh)\n{\n\twait_on_buffer(bh);\n\tif (!buffer_uptodate(bh))\n\t\treturn -EIO;\n\tif (buffer_dirty(bh))\n\t\treturn -EEXIST;\n\n\tif (buffer_nilfs_node(bh) && nilfs_btree_broken_node_block(bh)) {\n\t\tclear_buffer_uptodate(bh);\n\t\treturn -EIO;\n\t}\n\tmark_buffer_dirty(bh);\n\treturn 0;\n}",
          "includes": [
            "#include \"ifile.h\"",
            "#include \"dat.h\"",
            "#include \"mdt.h\"",
            "#include \"page.h\"",
            "#include \"btnode.h\"",
            "#include \"btree.h\"",
            "#include \"nilfs.h\"",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/hash.h>",
            "#include <linux/mpage.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ifile.h\"\n#include \"dat.h\"\n#include \"mdt.h\"\n#include \"page.h\"\n#include \"btnode.h\"\n#include \"btree.h\"\n#include \"nilfs.h\"\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/hash.h>\n#include <linux/mpage.h>\n#include <linux/buffer_head.h>\n\nint nilfs_gccache_wait_and_mark_dirty(struct buffer_head *bh)\n{\n\twait_on_buffer(bh);\n\tif (!buffer_uptodate(bh))\n\t\treturn -EIO;\n\tif (buffer_dirty(bh))\n\t\treturn -EEXIST;\n\n\tif (buffer_nilfs_node(bh) && nilfs_btree_broken_node_block(bh)) {\n\t\tclear_buffer_uptodate(bh);\n\t\treturn -EIO;\n\t}\n\tmark_buffer_dirty(bh);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry_safe",
          "args": [
            "bh",
            "n",
            "&buffers",
            "b_assoc_buffers"
          ],
          "line": 678
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "iput",
          "args": [
            "inode"
          ],
          "line": 675
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_iput_work_func",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/segment.c",
          "lines": "746-753",
          "snippet": "static void nilfs_iput_work_func(struct work_struct *work)\n{\n\tstruct nilfs_sc_info *sci = container_of(work, struct nilfs_sc_info,\n\t\t\t\t\t\t sc_iput_work);\n\tstruct the_nilfs *nilfs = sci->sc_super->s_fs_info;\n\n\tnilfs_dispose_list(nilfs, &sci->sc_iput_queue, 0);\n}",
          "includes": [
            "#include \"segbuf.h\"",
            "#include \"ifile.h\"",
            "#include \"cpfile.h\"",
            "#include \"sufile.h\"",
            "#include \"segment.h\"",
            "#include \"page.h\"",
            "#include \"btnode.h\"",
            "#include \"nilfs.h\"",
            "#include <linux/slab.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/crc32.h>",
            "#include <linux/kthread.h>",
            "#include <linux/freezer.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/completion.h>",
            "#include <linux/bio.h>",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void nilfs_segctor_start_timer(struct nilfs_sc_info *);",
            "static void nilfs_segctor_do_flush(struct nilfs_sc_info *, int);",
            "static void nilfs_segctor_do_immediate_flush(struct nilfs_sc_info *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"segbuf.h\"\n#include \"ifile.h\"\n#include \"cpfile.h\"\n#include \"sufile.h\"\n#include \"segment.h\"\n#include \"page.h\"\n#include \"btnode.h\"\n#include \"nilfs.h\"\n#include <linux/slab.h>\n#include <linux/pagevec.h>\n#include <linux/crc32.h>\n#include <linux/kthread.h>\n#include <linux/freezer.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/completion.h>\n#include <linux/bio.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n\nstatic void nilfs_segctor_start_timer(struct nilfs_sc_info *);\nstatic void nilfs_segctor_do_flush(struct nilfs_sc_info *, int);\nstatic void nilfs_segctor_do_immediate_flush(struct nilfs_sc_info *);\n\nstatic void nilfs_iput_work_func(struct work_struct *work)\n{\n\tstruct nilfs_sc_info *sci = container_of(work, struct nilfs_sc_info,\n\t\t\t\t\t\t sc_iput_work);\n\tstruct the_nilfs *nilfs = sci->sc_super->s_fs_info;\n\n\tnilfs_dispose_list(nilfs, &sci->sc_iput_queue, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "ret < 0"
          ],
          "line": 667
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nilfs_ioctl_move_inode_block",
          "args": [
            "inode",
            "vdesc",
            "&buffers"
          ],
          "line": 665
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_ioctl_move_inode_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/ioctl.c",
          "lines": "574-617",
          "snippet": "static int nilfs_ioctl_move_inode_block(struct inode *inode,\n\t\t\t\t\tstruct nilfs_vdesc *vdesc,\n\t\t\t\t\tstruct list_head *buffers)\n{\n\tstruct buffer_head *bh;\n\tint ret;\n\n\tif (vdesc->vd_flags == 0)\n\t\tret = nilfs_gccache_submit_read_data(\n\t\t\tinode, vdesc->vd_offset, vdesc->vd_blocknr,\n\t\t\tvdesc->vd_vblocknr, &bh);\n\telse\n\t\tret = nilfs_gccache_submit_read_node(\n\t\t\tinode, vdesc->vd_blocknr, vdesc->vd_vblocknr, &bh);\n\n\tif (unlikely(ret < 0)) {\n\t\tif (ret == -ENOENT)\n\t\t\tprintk(KERN_CRIT\n\t\t\t       \"%s: invalid virtual block address (%s): \"\n\t\t\t       \"ino=%llu, cno=%llu, offset=%llu, \"\n\t\t\t       \"blocknr=%llu, vblocknr=%llu\\n\",\n\t\t\t       __func__, vdesc->vd_flags ? \"node\" : \"data\",\n\t\t\t       (unsigned long long)vdesc->vd_ino,\n\t\t\t       (unsigned long long)vdesc->vd_cno,\n\t\t\t       (unsigned long long)vdesc->vd_offset,\n\t\t\t       (unsigned long long)vdesc->vd_blocknr,\n\t\t\t       (unsigned long long)vdesc->vd_vblocknr);\n\t\treturn ret;\n\t}\n\tif (unlikely(!list_empty(&bh->b_assoc_buffers))) {\n\t\tprintk(KERN_CRIT \"%s: conflicting %s buffer: ino=%llu, \"\n\t\t       \"cno=%llu, offset=%llu, blocknr=%llu, vblocknr=%llu\\n\",\n\t\t       __func__, vdesc->vd_flags ? \"node\" : \"data\",\n\t\t       (unsigned long long)vdesc->vd_ino,\n\t\t       (unsigned long long)vdesc->vd_cno,\n\t\t       (unsigned long long)vdesc->vd_offset,\n\t\t       (unsigned long long)vdesc->vd_blocknr,\n\t\t       (unsigned long long)vdesc->vd_vblocknr);\n\t\tbrelse(bh);\n\t\treturn -EEXIST;\n\t}\n\tlist_add_tail(&bh->b_assoc_buffers, buffers);\n\treturn 0;\n}",
          "includes": [
            "#include \"dat.h\"",
            "#include \"sufile.h\"",
            "#include \"cpfile.h\"",
            "#include \"bmap.h\"",
            "#include \"segment.h\"",
            "#include \"nilfs.h\"",
            "#include <linux/nilfs2_fs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/mount.h>\t/* mnt_want_write_file(), mnt_drop_write_file() */",
            "#include <linux/compat.h>\t/* compat_ptr() */",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>\t/* copy_from_user(), copy_to_user() */",
            "#include <linux/capability.h>\t/* capable() */",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"dat.h\"\n#include \"sufile.h\"\n#include \"cpfile.h\"\n#include \"bmap.h\"\n#include \"segment.h\"\n#include \"nilfs.h\"\n#include <linux/nilfs2_fs.h>\n#include <linux/buffer_head.h>\n#include <linux/mount.h>\t/* mnt_want_write_file(), mnt_drop_write_file() */\n#include <linux/compat.h>\t/* compat_ptr() */\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\t/* copy_from_user(), copy_to_user() */\n#include <linux/capability.h>\t/* capable() */\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/fs.h>\n\nstatic int nilfs_ioctl_move_inode_block(struct inode *inode,\n\t\t\t\t\tstruct nilfs_vdesc *vdesc,\n\t\t\t\t\tstruct list_head *buffers)\n{\n\tstruct buffer_head *bh;\n\tint ret;\n\n\tif (vdesc->vd_flags == 0)\n\t\tret = nilfs_gccache_submit_read_data(\n\t\t\tinode, vdesc->vd_offset, vdesc->vd_blocknr,\n\t\t\tvdesc->vd_vblocknr, &bh);\n\telse\n\t\tret = nilfs_gccache_submit_read_node(\n\t\t\tinode, vdesc->vd_blocknr, vdesc->vd_vblocknr, &bh);\n\n\tif (unlikely(ret < 0)) {\n\t\tif (ret == -ENOENT)\n\t\t\tprintk(KERN_CRIT\n\t\t\t       \"%s: invalid virtual block address (%s): \"\n\t\t\t       \"ino=%llu, cno=%llu, offset=%llu, \"\n\t\t\t       \"blocknr=%llu, vblocknr=%llu\\n\",\n\t\t\t       __func__, vdesc->vd_flags ? \"node\" : \"data\",\n\t\t\t       (unsigned long long)vdesc->vd_ino,\n\t\t\t       (unsigned long long)vdesc->vd_cno,\n\t\t\t       (unsigned long long)vdesc->vd_offset,\n\t\t\t       (unsigned long long)vdesc->vd_blocknr,\n\t\t\t       (unsigned long long)vdesc->vd_vblocknr);\n\t\treturn ret;\n\t}\n\tif (unlikely(!list_empty(&bh->b_assoc_buffers))) {\n\t\tprintk(KERN_CRIT \"%s: conflicting %s buffer: ino=%llu, \"\n\t\t       \"cno=%llu, offset=%llu, blocknr=%llu, vblocknr=%llu\\n\",\n\t\t       __func__, vdesc->vd_flags ? \"node\" : \"data\",\n\t\t       (unsigned long long)vdesc->vd_ino,\n\t\t       (unsigned long long)vdesc->vd_cno,\n\t\t       (unsigned long long)vdesc->vd_offset,\n\t\t       (unsigned long long)vdesc->vd_blocknr,\n\t\t       (unsigned long long)vdesc->vd_vblocknr);\n\t\tbrelse(bh);\n\t\treturn -EEXIST;\n\t}\n\tlist_add_tail(&bh->b_assoc_buffers, buffers);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_add",
          "args": [
            "&NILFS_I(inode)->i_dirty",
            "&nilfs->ns_gc_inodes"
          ],
          "line": 660
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_segment_list_add",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/recovery.c",
          "lines": "403-414",
          "snippet": "static int nilfs_segment_list_add(struct list_head *head, __u64 segnum)\n{\n\tstruct nilfs_segment_entry *ent = kmalloc(sizeof(*ent), GFP_NOFS);\n\n\tif (unlikely(!ent))\n\t\treturn -ENOMEM;\n\n\tent->segnum = segnum;\n\tINIT_LIST_HEAD(&ent->list);\n\tlist_add_tail(&ent->list, head);\n\treturn 0;\n}",
          "includes": [
            "#include \"segbuf.h\"",
            "#include \"page.h\"",
            "#include \"sufile.h\"",
            "#include \"segment.h\"",
            "#include \"nilfs.h\"",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"segbuf.h\"\n#include \"page.h\"\n#include \"sufile.h\"\n#include \"segment.h\"\n#include \"nilfs.h\"\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n\nstatic int nilfs_segment_list_add(struct list_head *head, __u64 segnum)\n{\n\tstruct nilfs_segment_entry *ent = kmalloc(sizeof(*ent), GFP_NOFS);\n\n\tif (unlikely(!ent))\n\t\treturn -ENOMEM;\n\n\tent->segnum = segnum;\n\tINIT_LIST_HEAD(&ent->list);\n\tlist_add_tail(&ent->list, head);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "NILFS_I",
          "args": [
            "inode"
          ],
          "line": 660
        },
        "resolved": true,
        "details": {
          "function_name": "NILFS_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/nilfs.h",
          "lines": "78-81",
          "snippet": "static inline struct nilfs_inode_info *NILFS_I(const struct inode *inode)\n{\n\treturn container_of(inode, struct nilfs_inode_info, vfs_inode);\n}",
          "includes": [
            "#include \"bmap.h\"",
            "#include \"the_nilfs.h\"",
            "#include <linux/nilfs2_fs.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"bmap.h\"\n#include \"the_nilfs.h\"\n#include <linux/nilfs2_fs.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/buffer_head.h>\n#include <linux/kernel.h>\n\nstatic inline struct nilfs_inode_info *NILFS_I(const struct inode *inode)\n{\n\treturn container_of(inode, struct nilfs_inode_info, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "igrab",
          "args": [
            "inode"
          ],
          "line": 659
        },
        "resolved": true,
        "details": {
          "function_name": "igrab",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "1173-1189",
          "snippet": "struct inode *igrab(struct inode *inode)\n{\n\tspin_lock(&inode->i_lock);\n\tif (!(inode->i_state & (I_FREEING|I_WILL_FREE))) {\n\t\t__iget(inode);\n\t\tspin_unlock(&inode->i_lock);\n\t} else {\n\t\tspin_unlock(&inode->i_lock);\n\t\t/*\n\t\t * Handle the case where s_op->clear_inode is not been\n\t\t * called yet, and somebody is calling igrab\n\t\t * while the inode is getting freed.\n\t\t */\n\t\tinode = NULL;\n\t}\n\treturn inode;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nstruct inode *igrab(struct inode *inode)\n{\n\tspin_lock(&inode->i_lock);\n\tif (!(inode->i_state & (I_FREEING|I_WILL_FREE))) {\n\t\t__iget(inode);\n\t\tspin_unlock(&inode->i_lock);\n\t} else {\n\t\tspin_unlock(&inode->i_lock);\n\t\t/*\n\t\t * Handle the case where s_op->clear_inode is not been\n\t\t * called yet, and somebody is calling igrab\n\t\t * while the inode is getting freed.\n\t\t */\n\t\tinode = NULL;\n\t}\n\treturn inode;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&NILFS_I(inode)->i_dirty"
          ],
          "line": 653
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_dirty_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmthread.c",
          "lines": "505-514",
          "snippet": "static int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_flush_asts(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_flush_asts(struct dlm_ctxt *dlm);\n\nstatic int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "inode"
          ],
          "line": 650
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "inode"
          ],
          "line": 649
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nilfs_iget_for_gc",
          "args": [
            "sb",
            "ino",
            "cno"
          ],
          "line": 648
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_iget_for_gc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/inode.c",
          "lines": "629-651",
          "snippet": "struct inode *nilfs_iget_for_gc(struct super_block *sb, unsigned long ino,\n\t\t\t\t__u64 cno)\n{\n\tstruct nilfs_iget_args args = {\n\t\t.ino = ino, .root = NULL, .cno = cno, .for_gc = 1\n\t};\n\tstruct inode *inode;\n\tint err;\n\n\tinode = iget5_locked(sb, ino, nilfs_iget_test, nilfs_iget_set, &args);\n\tif (unlikely(!inode))\n\t\treturn ERR_PTR(-ENOMEM);\n\tif (!(inode->i_state & I_NEW))\n\t\treturn inode;\n\n\terr = nilfs_init_gcinode(inode);\n\tif (unlikely(err)) {\n\t\tiget_failed(inode);\n\t\treturn ERR_PTR(err);\n\t}\n\tunlock_new_inode(inode);\n\treturn inode;\n}",
          "includes": [
            "#include \"ifile.h\"",
            "#include \"cpfile.h\"",
            "#include \"mdt.h\"",
            "#include \"page.h\"",
            "#include \"segment.h\"",
            "#include \"btnode.h\"",
            "#include \"nilfs.h\"",
            "#include <linux/aio.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mpage.h>",
            "#include <linux/gfp.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ifile.h\"\n#include \"cpfile.h\"\n#include \"mdt.h\"\n#include \"page.h\"\n#include \"segment.h\"\n#include \"btnode.h\"\n#include \"nilfs.h\"\n#include <linux/aio.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/mpage.h>\n#include <linux/gfp.h>\n#include <linux/buffer_head.h>\n\nstruct inode *nilfs_iget_for_gc(struct super_block *sb, unsigned long ino,\n\t\t\t\t__u64 cno)\n{\n\tstruct nilfs_iget_args args = {\n\t\t.ino = ino, .root = NULL, .cno = cno, .for_gc = 1\n\t};\n\tstruct inode *inode;\n\tint err;\n\n\tinode = iget5_locked(sb, ino, nilfs_iget_test, nilfs_iget_set, &args);\n\tif (unlikely(!inode))\n\t\treturn ERR_PTR(-ENOMEM);\n\tif (!(inode->i_state & I_NEW))\n\t\treturn inode;\n\n\terr = nilfs_init_gcinode(inode);\n\tif (unlikely(err)) {\n\t\tiget_failed(inode);\n\t\treturn ERR_PTR(err);\n\t}\n\tunlock_new_inode(inode);\n\treturn inode;\n}"
        }
      },
      {
        "call_info": {
          "callee": "LIST_HEAD",
          "args": [
            "buffers"
          ],
          "line": 640
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"dat.h\"\n#include \"sufile.h\"\n#include \"cpfile.h\"\n#include \"bmap.h\"\n#include \"segment.h\"\n#include \"nilfs.h\"\n#include <linux/nilfs2_fs.h>\n#include <linux/buffer_head.h>\n#include <linux/mount.h>\t/* mnt_want_write_file(), mnt_drop_write_file() */\n#include <linux/compat.h>\t/* compat_ptr() */\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\t/* copy_from_user(), copy_to_user() */\n#include <linux/capability.h>\t/* capable() */\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/fs.h>\n\nstatic int nilfs_ioctl_move_blocks(struct super_block *sb,\n\t\t\t\t   struct nilfs_argv *argv, void *buf)\n{\n\tsize_t nmembs = argv->v_nmembs;\n\tstruct the_nilfs *nilfs = sb->s_fs_info;\n\tstruct inode *inode;\n\tstruct nilfs_vdesc *vdesc;\n\tstruct buffer_head *bh, *n;\n\tLIST_HEAD(buffers);\n\tino_t ino;\n\t__u64 cno;\n\tint i, ret;\n\n\tfor (i = 0, vdesc = buf; i < nmembs; ) {\n\t\tino = vdesc->vd_ino;\n\t\tcno = vdesc->vd_cno;\n\t\tinode = nilfs_iget_for_gc(sb, ino, cno);\n\t\tif (IS_ERR(inode)) {\n\t\t\tret = PTR_ERR(inode);\n\t\t\tgoto failed;\n\t\t}\n\t\tif (list_empty(&NILFS_I(inode)->i_dirty)) {\n\t\t\t/*\n\t\t\t * Add the inode to GC inode list. Garbage Collection\n\t\t\t * is serialized and no two processes manipulate the\n\t\t\t * list simultaneously.\n\t\t\t */\n\t\t\tigrab(inode);\n\t\t\tlist_add(&NILFS_I(inode)->i_dirty,\n\t\t\t\t &nilfs->ns_gc_inodes);\n\t\t}\n\n\t\tdo {\n\t\t\tret = nilfs_ioctl_move_inode_block(inode, vdesc,\n\t\t\t\t\t\t\t   &buffers);\n\t\t\tif (unlikely(ret < 0)) {\n\t\t\t\tiput(inode);\n\t\t\t\tgoto failed;\n\t\t\t}\n\t\t\tvdesc++;\n\t\t} while (++i < nmembs &&\n\t\t\t vdesc->vd_ino == ino && vdesc->vd_cno == cno);\n\n\t\tiput(inode); /* The inode still remains in GC inode list */\n\t}\n\n\tlist_for_each_entry_safe(bh, n, &buffers, b_assoc_buffers) {\n\t\tret = nilfs_gccache_wait_and_mark_dirty(bh);\n\t\tif (unlikely(ret < 0)) {\n\t\t\tWARN_ON(ret == -EEXIST);\n\t\t\tgoto failed;\n\t\t}\n\t\tlist_del_init(&bh->b_assoc_buffers);\n\t\tbrelse(bh);\n\t}\n\treturn nmembs;\n\n failed:\n\tlist_for_each_entry_safe(bh, n, &buffers, b_assoc_buffers) {\n\t\tlist_del_init(&bh->b_assoc_buffers);\n\t\tbrelse(bh);\n\t}\n\treturn ret;\n}"
  },
  {
    "function_name": "nilfs_ioctl_move_inode_block",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/ioctl.c",
    "lines": "574-617",
    "snippet": "static int nilfs_ioctl_move_inode_block(struct inode *inode,\n\t\t\t\t\tstruct nilfs_vdesc *vdesc,\n\t\t\t\t\tstruct list_head *buffers)\n{\n\tstruct buffer_head *bh;\n\tint ret;\n\n\tif (vdesc->vd_flags == 0)\n\t\tret = nilfs_gccache_submit_read_data(\n\t\t\tinode, vdesc->vd_offset, vdesc->vd_blocknr,\n\t\t\tvdesc->vd_vblocknr, &bh);\n\telse\n\t\tret = nilfs_gccache_submit_read_node(\n\t\t\tinode, vdesc->vd_blocknr, vdesc->vd_vblocknr, &bh);\n\n\tif (unlikely(ret < 0)) {\n\t\tif (ret == -ENOENT)\n\t\t\tprintk(KERN_CRIT\n\t\t\t       \"%s: invalid virtual block address (%s): \"\n\t\t\t       \"ino=%llu, cno=%llu, offset=%llu, \"\n\t\t\t       \"blocknr=%llu, vblocknr=%llu\\n\",\n\t\t\t       __func__, vdesc->vd_flags ? \"node\" : \"data\",\n\t\t\t       (unsigned long long)vdesc->vd_ino,\n\t\t\t       (unsigned long long)vdesc->vd_cno,\n\t\t\t       (unsigned long long)vdesc->vd_offset,\n\t\t\t       (unsigned long long)vdesc->vd_blocknr,\n\t\t\t       (unsigned long long)vdesc->vd_vblocknr);\n\t\treturn ret;\n\t}\n\tif (unlikely(!list_empty(&bh->b_assoc_buffers))) {\n\t\tprintk(KERN_CRIT \"%s: conflicting %s buffer: ino=%llu, \"\n\t\t       \"cno=%llu, offset=%llu, blocknr=%llu, vblocknr=%llu\\n\",\n\t\t       __func__, vdesc->vd_flags ? \"node\" : \"data\",\n\t\t       (unsigned long long)vdesc->vd_ino,\n\t\t       (unsigned long long)vdesc->vd_cno,\n\t\t       (unsigned long long)vdesc->vd_offset,\n\t\t       (unsigned long long)vdesc->vd_blocknr,\n\t\t       (unsigned long long)vdesc->vd_vblocknr);\n\t\tbrelse(bh);\n\t\treturn -EEXIST;\n\t}\n\tlist_add_tail(&bh->b_assoc_buffers, buffers);\n\treturn 0;\n}",
    "includes": [
      "#include \"dat.h\"",
      "#include \"sufile.h\"",
      "#include \"cpfile.h\"",
      "#include \"bmap.h\"",
      "#include \"segment.h\"",
      "#include \"nilfs.h\"",
      "#include <linux/nilfs2_fs.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/mount.h>\t/* mnt_want_write_file(), mnt_drop_write_file() */",
      "#include <linux/compat.h>\t/* compat_ptr() */",
      "#include <linux/vmalloc.h>",
      "#include <linux/uaccess.h>\t/* copy_from_user(), copy_to_user() */",
      "#include <linux/capability.h>\t/* capable() */",
      "#include <linux/slab.h>",
      "#include <linux/wait.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "list_add_tail",
          "args": [
            "&bh->b_assoc_buffers",
            "buffers"
          ],
          "line": 615
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "bh"
          ],
          "line": 612
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_CRIT \"%s: conflicting %s buffer: ino=%llu, \"\n\t\t       \"cno=%llu, offset=%llu, blocknr=%llu, vblocknr=%llu\\n\"",
            "__func__",
            "vdesc->vd_flags ? \"node\" : \"data\"",
            "(unsigned long long)vdesc->vd_ino",
            "(unsigned long long)vdesc->vd_cno",
            "(unsigned long long)vdesc->vd_offset",
            "(unsigned long long)vdesc->vd_blocknr",
            "(unsigned long long)vdesc->vd_vblocknr"
          ],
          "line": 604
        },
        "resolved": true,
        "details": {
          "function_name": "compat_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/compat.c",
          "lines": "59-69",
          "snippet": "int compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/ioctls.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/aio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/mm.h>",
            "#include <linux/poll.h>",
            "#include <linux/signal.h>",
            "#include <linux/highmem.h>",
            "#include <linux/security.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/personality.h>",
            "#include <linux/highuid.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/dirent.h>",
            "#include <linux/ctype.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/nfs4_mount.h>",
            "#include <linux/ncp_mount.h>",
            "#include <linux/init.h>",
            "#include <linux/ioctl.h>",
            "#include <linux/vfs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/namei.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/errno.h>",
            "#include <linux/compat.h>",
            "#include <linux/linkage.h>",
            "#include <linux/kernel.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int compat_log = 1;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/ioctls.h>\n#include <asm/mmu_context.h>\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/fs_struct.h>\n#include <linux/mm.h>\n#include <linux/poll.h>\n#include <linux/signal.h>\n#include <linux/highmem.h>\n#include <linux/security.h>\n#include <linux/tsacct_kern.h>\n#include <linux/rwsem.h>\n#include <linux/personality.h>\n#include <linux/highuid.h>\n#include <linux/fsnotify.h>\n#include <linux/dirent.h>\n#include <linux/ctype.h>\n#include <linux/syscalls.h>\n#include <linux/nfs4_mount.h>\n#include <linux/ncp_mount.h>\n#include <linux/init.h>\n#include <linux/ioctl.h>\n#include <linux/vfs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/namei.h>\n#include <linux/fcntl.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <linux/compat.h>\n#include <linux/linkage.h>\n#include <linux/kernel.h>\n#include <linux/stddef.h>\n\nint compat_log = 1;\n\nint compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!list_empty(&bh->b_assoc_buffers)"
          ],
          "line": 603
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&bh->b_assoc_buffers"
          ],
          "line": 603
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_dirty_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmthread.c",
          "lines": "505-514",
          "snippet": "static int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_flush_asts(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_flush_asts(struct dlm_ctxt *dlm);\n\nstatic int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "ret < 0"
          ],
          "line": 589
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nilfs_gccache_submit_read_node",
          "args": [
            "inode",
            "vdesc->vd_blocknr",
            "vdesc->vd_vblocknr",
            "&bh"
          ],
          "line": 586
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_gccache_submit_read_node",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/gcinode.c",
          "lines": "140-150",
          "snippet": "int nilfs_gccache_submit_read_node(struct inode *inode, sector_t pbn,\n\t\t\t\t   __u64 vbn, struct buffer_head **out_bh)\n{\n\tint ret;\n\n\tret = nilfs_btnode_submit_block(&NILFS_I(inode)->i_btnode_cache,\n\t\t\t\t\tvbn ? : pbn, pbn, READ, out_bh, &pbn);\n\tif (ret == -EEXIST) /* internal code (cache hit) */\n\t\tret = 0;\n\treturn ret;\n}",
          "includes": [
            "#include \"ifile.h\"",
            "#include \"dat.h\"",
            "#include \"mdt.h\"",
            "#include \"page.h\"",
            "#include \"btnode.h\"",
            "#include \"btree.h\"",
            "#include \"nilfs.h\"",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/hash.h>",
            "#include <linux/mpage.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ifile.h\"\n#include \"dat.h\"\n#include \"mdt.h\"\n#include \"page.h\"\n#include \"btnode.h\"\n#include \"btree.h\"\n#include \"nilfs.h\"\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/hash.h>\n#include <linux/mpage.h>\n#include <linux/buffer_head.h>\n\nint nilfs_gccache_submit_read_node(struct inode *inode, sector_t pbn,\n\t\t\t\t   __u64 vbn, struct buffer_head **out_bh)\n{\n\tint ret;\n\n\tret = nilfs_btnode_submit_block(&NILFS_I(inode)->i_btnode_cache,\n\t\t\t\t\tvbn ? : pbn, pbn, READ, out_bh, &pbn);\n\tif (ret == -EEXIST) /* internal code (cache hit) */\n\t\tret = 0;\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nilfs_gccache_submit_read_data",
          "args": [
            "inode",
            "vdesc->vd_offset",
            "vdesc->vd_blocknr",
            "vdesc->vd_vblocknr",
            "&bh"
          ],
          "line": 582
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_gccache_submit_read_data",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/gcinode.c",
          "lines": "72-120",
          "snippet": "int nilfs_gccache_submit_read_data(struct inode *inode, sector_t blkoff,\n\t\t\t\t   sector_t pbn, __u64 vbn,\n\t\t\t\t   struct buffer_head **out_bh)\n{\n\tstruct buffer_head *bh;\n\tint err;\n\n\tbh = nilfs_grab_buffer(inode, inode->i_mapping, blkoff, 0);\n\tif (unlikely(!bh))\n\t\treturn -ENOMEM;\n\n\tif (buffer_uptodate(bh))\n\t\tgoto out;\n\n\tif (pbn == 0) {\n\t\tstruct the_nilfs *nilfs = inode->i_sb->s_fs_info;\n\n\t\terr = nilfs_dat_translate(nilfs->ns_dat, vbn, &pbn);\n\t\tif (unlikely(err)) { /* -EIO, -ENOMEM, -ENOENT */\n\t\t\tbrelse(bh);\n\t\t\tgoto failed;\n\t\t}\n\t}\n\n\tlock_buffer(bh);\n\tif (buffer_uptodate(bh)) {\n\t\tunlock_buffer(bh);\n\t\tgoto out;\n\t}\n\n\tif (!buffer_mapped(bh)) {\n\t\tbh->b_bdev = inode->i_sb->s_bdev;\n\t\tset_buffer_mapped(bh);\n\t}\n\tbh->b_blocknr = pbn;\n\tbh->b_end_io = end_buffer_read_sync;\n\tget_bh(bh);\n\tsubmit_bh(READ, bh);\n\tif (vbn)\n\t\tbh->b_blocknr = vbn;\n out:\n\terr = 0;\n\t*out_bh = bh;\n\n failed:\n\tunlock_page(bh->b_page);\n\tpage_cache_release(bh->b_page);\n\treturn err;\n}",
          "includes": [
            "#include \"ifile.h\"",
            "#include \"dat.h\"",
            "#include \"mdt.h\"",
            "#include \"page.h\"",
            "#include \"btnode.h\"",
            "#include \"btree.h\"",
            "#include \"nilfs.h\"",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/hash.h>",
            "#include <linux/mpage.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ifile.h\"\n#include \"dat.h\"\n#include \"mdt.h\"\n#include \"page.h\"\n#include \"btnode.h\"\n#include \"btree.h\"\n#include \"nilfs.h\"\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/hash.h>\n#include <linux/mpage.h>\n#include <linux/buffer_head.h>\n\nint nilfs_gccache_submit_read_data(struct inode *inode, sector_t blkoff,\n\t\t\t\t   sector_t pbn, __u64 vbn,\n\t\t\t\t   struct buffer_head **out_bh)\n{\n\tstruct buffer_head *bh;\n\tint err;\n\n\tbh = nilfs_grab_buffer(inode, inode->i_mapping, blkoff, 0);\n\tif (unlikely(!bh))\n\t\treturn -ENOMEM;\n\n\tif (buffer_uptodate(bh))\n\t\tgoto out;\n\n\tif (pbn == 0) {\n\t\tstruct the_nilfs *nilfs = inode->i_sb->s_fs_info;\n\n\t\terr = nilfs_dat_translate(nilfs->ns_dat, vbn, &pbn);\n\t\tif (unlikely(err)) { /* -EIO, -ENOMEM, -ENOENT */\n\t\t\tbrelse(bh);\n\t\t\tgoto failed;\n\t\t}\n\t}\n\n\tlock_buffer(bh);\n\tif (buffer_uptodate(bh)) {\n\t\tunlock_buffer(bh);\n\t\tgoto out;\n\t}\n\n\tif (!buffer_mapped(bh)) {\n\t\tbh->b_bdev = inode->i_sb->s_bdev;\n\t\tset_buffer_mapped(bh);\n\t}\n\tbh->b_blocknr = pbn;\n\tbh->b_end_io = end_buffer_read_sync;\n\tget_bh(bh);\n\tsubmit_bh(READ, bh);\n\tif (vbn)\n\t\tbh->b_blocknr = vbn;\n out:\n\terr = 0;\n\t*out_bh = bh;\n\n failed:\n\tunlock_page(bh->b_page);\n\tpage_cache_release(bh->b_page);\n\treturn err;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"dat.h\"\n#include \"sufile.h\"\n#include \"cpfile.h\"\n#include \"bmap.h\"\n#include \"segment.h\"\n#include \"nilfs.h\"\n#include <linux/nilfs2_fs.h>\n#include <linux/buffer_head.h>\n#include <linux/mount.h>\t/* mnt_want_write_file(), mnt_drop_write_file() */\n#include <linux/compat.h>\t/* compat_ptr() */\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\t/* copy_from_user(), copy_to_user() */\n#include <linux/capability.h>\t/* capable() */\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/fs.h>\n\nstatic int nilfs_ioctl_move_inode_block(struct inode *inode,\n\t\t\t\t\tstruct nilfs_vdesc *vdesc,\n\t\t\t\t\tstruct list_head *buffers)\n{\n\tstruct buffer_head *bh;\n\tint ret;\n\n\tif (vdesc->vd_flags == 0)\n\t\tret = nilfs_gccache_submit_read_data(\n\t\t\tinode, vdesc->vd_offset, vdesc->vd_blocknr,\n\t\t\tvdesc->vd_vblocknr, &bh);\n\telse\n\t\tret = nilfs_gccache_submit_read_node(\n\t\t\tinode, vdesc->vd_blocknr, vdesc->vd_vblocknr, &bh);\n\n\tif (unlikely(ret < 0)) {\n\t\tif (ret == -ENOENT)\n\t\t\tprintk(KERN_CRIT\n\t\t\t       \"%s: invalid virtual block address (%s): \"\n\t\t\t       \"ino=%llu, cno=%llu, offset=%llu, \"\n\t\t\t       \"blocknr=%llu, vblocknr=%llu\\n\",\n\t\t\t       __func__, vdesc->vd_flags ? \"node\" : \"data\",\n\t\t\t       (unsigned long long)vdesc->vd_ino,\n\t\t\t       (unsigned long long)vdesc->vd_cno,\n\t\t\t       (unsigned long long)vdesc->vd_offset,\n\t\t\t       (unsigned long long)vdesc->vd_blocknr,\n\t\t\t       (unsigned long long)vdesc->vd_vblocknr);\n\t\treturn ret;\n\t}\n\tif (unlikely(!list_empty(&bh->b_assoc_buffers))) {\n\t\tprintk(KERN_CRIT \"%s: conflicting %s buffer: ino=%llu, \"\n\t\t       \"cno=%llu, offset=%llu, blocknr=%llu, vblocknr=%llu\\n\",\n\t\t       __func__, vdesc->vd_flags ? \"node\" : \"data\",\n\t\t       (unsigned long long)vdesc->vd_ino,\n\t\t       (unsigned long long)vdesc->vd_cno,\n\t\t       (unsigned long long)vdesc->vd_offset,\n\t\t       (unsigned long long)vdesc->vd_blocknr,\n\t\t       (unsigned long long)vdesc->vd_vblocknr);\n\t\tbrelse(bh);\n\t\treturn -EEXIST;\n\t}\n\tlist_add_tail(&bh->b_assoc_buffers, buffers);\n\treturn 0;\n}"
  },
  {
    "function_name": "nilfs_ioctl_get_bdescs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/ioctl.c",
    "lines": "531-552",
    "snippet": "static int nilfs_ioctl_get_bdescs(struct inode *inode, struct file *filp,\n\t\t\t\t  unsigned int cmd, void __user *argp)\n{\n\tstruct the_nilfs *nilfs = inode->i_sb->s_fs_info;\n\tstruct nilfs_argv argv;\n\tint ret;\n\n\tif (copy_from_user(&argv, argp, sizeof(argv)))\n\t\treturn -EFAULT;\n\n\tif (argv.v_size != sizeof(struct nilfs_bdesc))\n\t\treturn -EINVAL;\n\n\tret = nilfs_ioctl_wrap_copy(nilfs, &argv, _IOC_DIR(cmd),\n\t\t\t\t    nilfs_ioctl_do_get_bdescs);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (copy_to_user(argp, &argv, sizeof(argv)))\n\t\tret = -EFAULT;\n\treturn ret;\n}",
    "includes": [
      "#include \"dat.h\"",
      "#include \"sufile.h\"",
      "#include \"cpfile.h\"",
      "#include \"bmap.h\"",
      "#include \"segment.h\"",
      "#include \"nilfs.h\"",
      "#include <linux/nilfs2_fs.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/mount.h>\t/* mnt_want_write_file(), mnt_drop_write_file() */",
      "#include <linux/compat.h>\t/* compat_ptr() */",
      "#include <linux/vmalloc.h>",
      "#include <linux/uaccess.h>\t/* copy_from_user(), copy_to_user() */",
      "#include <linux/capability.h>\t/* capable() */",
      "#include <linux/slab.h>",
      "#include <linux/wait.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "copy_to_user",
          "args": [
            "argp",
            "&argv",
            "sizeof(argv)"
          ],
          "line": 549
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nilfs_ioctl_wrap_copy",
          "args": [
            "nilfs",
            "&argv",
            "_IOC_DIR(cmd)",
            "nilfs_ioctl_do_get_bdescs"
          ],
          "line": 544
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_ioctl_wrap_copy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/ioctl.c",
          "lines": "60-127",
          "snippet": "static int nilfs_ioctl_wrap_copy(struct the_nilfs *nilfs,\n\t\t\t\t struct nilfs_argv *argv, int dir,\n\t\t\t\t ssize_t (*dofunc)(struct the_nilfs *,\n\t\t\t\t\t\t   __u64 *, int,\n\t\t\t\t\t\t   void *, size_t, size_t))\n{\n\tvoid *buf;\n\tvoid __user *base = (void __user *)(unsigned long)argv->v_base;\n\tsize_t maxmembs, total, n;\n\tssize_t nr;\n\tint ret, i;\n\t__u64 pos, ppos;\n\n\tif (argv->v_nmembs == 0)\n\t\treturn 0;\n\n\tif (argv->v_size > PAGE_SIZE)\n\t\treturn -EINVAL;\n\n\t/*\n\t * Reject pairs of a start item position (argv->v_index) and a\n\t * total count (argv->v_nmembs) which leads position 'pos' to\n\t * overflow by the increment at the end of the loop.\n\t */\n\tif (argv->v_index > ~(__u64)0 - argv->v_nmembs)\n\t\treturn -EINVAL;\n\n\tbuf = (void *)__get_free_pages(GFP_NOFS, 0);\n\tif (unlikely(!buf))\n\t\treturn -ENOMEM;\n\tmaxmembs = PAGE_SIZE / argv->v_size;\n\n\tret = 0;\n\ttotal = 0;\n\tpos = argv->v_index;\n\tfor (i = 0; i < argv->v_nmembs; i += n) {\n\t\tn = (argv->v_nmembs - i < maxmembs) ?\n\t\t\targv->v_nmembs - i : maxmembs;\n\t\tif ((dir & _IOC_WRITE) &&\n\t\t    copy_from_user(buf, base + argv->v_size * i,\n\t\t\t\t   argv->v_size * n)) {\n\t\t\tret = -EFAULT;\n\t\t\tbreak;\n\t\t}\n\t\tppos = pos;\n\t\tnr = dofunc(nilfs, &pos, argv->v_flags, buf, argv->v_size,\n\t\t\t       n);\n\t\tif (nr < 0) {\n\t\t\tret = nr;\n\t\t\tbreak;\n\t\t}\n\t\tif ((dir & _IOC_READ) &&\n\t\t    copy_to_user(base + argv->v_size * i, buf,\n\t\t\t\t argv->v_size * nr)) {\n\t\t\tret = -EFAULT;\n\t\t\tbreak;\n\t\t}\n\t\ttotal += nr;\n\t\tif ((size_t)nr < n)\n\t\t\tbreak;\n\t\tif (pos == ppos)\n\t\t\tpos += n;\n\t}\n\targv->v_nmembs = total;\n\n\tfree_pages((unsigned long)buf, 0);\n\treturn ret;\n}",
          "includes": [
            "#include \"dat.h\"",
            "#include \"sufile.h\"",
            "#include \"cpfile.h\"",
            "#include \"bmap.h\"",
            "#include \"segment.h\"",
            "#include \"nilfs.h\"",
            "#include <linux/nilfs2_fs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/mount.h>\t/* mnt_want_write_file(), mnt_drop_write_file() */",
            "#include <linux/compat.h>\t/* compat_ptr() */",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>\t/* copy_from_user(), copy_to_user() */",
            "#include <linux/capability.h>\t/* capable() */",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"dat.h\"\n#include \"sufile.h\"\n#include \"cpfile.h\"\n#include \"bmap.h\"\n#include \"segment.h\"\n#include \"nilfs.h\"\n#include <linux/nilfs2_fs.h>\n#include <linux/buffer_head.h>\n#include <linux/mount.h>\t/* mnt_want_write_file(), mnt_drop_write_file() */\n#include <linux/compat.h>\t/* compat_ptr() */\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\t/* copy_from_user(), copy_to_user() */\n#include <linux/capability.h>\t/* capable() */\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/fs.h>\n\nstatic int nilfs_ioctl_wrap_copy(struct the_nilfs *nilfs,\n\t\t\t\t struct nilfs_argv *argv, int dir,\n\t\t\t\t ssize_t (*dofunc)(struct the_nilfs *,\n\t\t\t\t\t\t   __u64 *, int,\n\t\t\t\t\t\t   void *, size_t, size_t))\n{\n\tvoid *buf;\n\tvoid __user *base = (void __user *)(unsigned long)argv->v_base;\n\tsize_t maxmembs, total, n;\n\tssize_t nr;\n\tint ret, i;\n\t__u64 pos, ppos;\n\n\tif (argv->v_nmembs == 0)\n\t\treturn 0;\n\n\tif (argv->v_size > PAGE_SIZE)\n\t\treturn -EINVAL;\n\n\t/*\n\t * Reject pairs of a start item position (argv->v_index) and a\n\t * total count (argv->v_nmembs) which leads position 'pos' to\n\t * overflow by the increment at the end of the loop.\n\t */\n\tif (argv->v_index > ~(__u64)0 - argv->v_nmembs)\n\t\treturn -EINVAL;\n\n\tbuf = (void *)__get_free_pages(GFP_NOFS, 0);\n\tif (unlikely(!buf))\n\t\treturn -ENOMEM;\n\tmaxmembs = PAGE_SIZE / argv->v_size;\n\n\tret = 0;\n\ttotal = 0;\n\tpos = argv->v_index;\n\tfor (i = 0; i < argv->v_nmembs; i += n) {\n\t\tn = (argv->v_nmembs - i < maxmembs) ?\n\t\t\targv->v_nmembs - i : maxmembs;\n\t\tif ((dir & _IOC_WRITE) &&\n\t\t    copy_from_user(buf, base + argv->v_size * i,\n\t\t\t\t   argv->v_size * n)) {\n\t\t\tret = -EFAULT;\n\t\t\tbreak;\n\t\t}\n\t\tppos = pos;\n\t\tnr = dofunc(nilfs, &pos, argv->v_flags, buf, argv->v_size,\n\t\t\t       n);\n\t\tif (nr < 0) {\n\t\t\tret = nr;\n\t\t\tbreak;\n\t\t}\n\t\tif ((dir & _IOC_READ) &&\n\t\t    copy_to_user(base + argv->v_size * i, buf,\n\t\t\t\t argv->v_size * nr)) {\n\t\t\tret = -EFAULT;\n\t\t\tbreak;\n\t\t}\n\t\ttotal += nr;\n\t\tif ((size_t)nr < n)\n\t\t\tbreak;\n\t\tif (pos == ppos)\n\t\t\tpos += n;\n\t}\n\targv->v_nmembs = total;\n\n\tfree_pages((unsigned long)buf, 0);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "_IOC_DIR",
          "args": [
            "cmd"
          ],
          "line": 544
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "copy_from_user",
          "args": [
            "&argv",
            "argp",
            "sizeof(argv)"
          ],
          "line": 538
        },
        "resolved": true,
        "details": {
          "function_name": "exact_copy_from_user",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namespace.c",
          "lines": "2514-2534",
          "snippet": "static long exact_copy_from_user(void *to, const void __user * from,\n\t\t\t\t unsigned long n)\n{\n\tchar *t = to;\n\tconst char __user *f = from;\n\tchar c;\n\n\tif (!access_ok(VERIFY_READ, from, n))\n\t\treturn n;\n\n\twhile (n) {\n\t\tif (__get_user(c, f)) {\n\t\t\tmemset(t, 0, n);\n\t\t\tbreak;\n\t\t}\n\t\t*t++ = c;\n\t\tf++;\n\t\tn--;\n\t}\n\treturn n;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"pnode.h\"",
            "#include <linux/task_work.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/magic.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
            "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
            "#include <linux/init.h>\t\t/* init_rootfs */",
            "#include <linux/idr.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/mnt_namespace.h>",
            "#include <linux/capability.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/task_work.h>\n#include <linux/bootmem.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic long exact_copy_from_user(void *to, const void __user * from,\n\t\t\t\t unsigned long n)\n{\n\tchar *t = to;\n\tconst char __user *f = from;\n\tchar c;\n\n\tif (!access_ok(VERIFY_READ, from, n))\n\t\treturn n;\n\n\twhile (n) {\n\t\tif (__get_user(c, f)) {\n\t\t\tmemset(t, 0, n);\n\t\t\tbreak;\n\t\t}\n\t\t*t++ = c;\n\t\tf++;\n\t\tn--;\n\t}\n\treturn n;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"dat.h\"\n#include \"sufile.h\"\n#include \"cpfile.h\"\n#include \"bmap.h\"\n#include \"segment.h\"\n#include \"nilfs.h\"\n#include <linux/nilfs2_fs.h>\n#include <linux/buffer_head.h>\n#include <linux/mount.h>\t/* mnt_want_write_file(), mnt_drop_write_file() */\n#include <linux/compat.h>\t/* compat_ptr() */\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\t/* copy_from_user(), copy_to_user() */\n#include <linux/capability.h>\t/* capable() */\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/fs.h>\n\nstatic int nilfs_ioctl_get_bdescs(struct inode *inode, struct file *filp,\n\t\t\t\t  unsigned int cmd, void __user *argp)\n{\n\tstruct the_nilfs *nilfs = inode->i_sb->s_fs_info;\n\tstruct nilfs_argv argv;\n\tint ret;\n\n\tif (copy_from_user(&argv, argp, sizeof(argv)))\n\t\treturn -EFAULT;\n\n\tif (argv.v_size != sizeof(struct nilfs_bdesc))\n\t\treturn -EINVAL;\n\n\tret = nilfs_ioctl_wrap_copy(nilfs, &argv, _IOC_DIR(cmd),\n\t\t\t\t    nilfs_ioctl_do_get_bdescs);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (copy_to_user(argp, &argv, sizeof(argv)))\n\t\tret = -EFAULT;\n\treturn ret;\n}"
  },
  {
    "function_name": "nilfs_ioctl_do_get_bdescs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/ioctl.c",
    "lines": "482-506",
    "snippet": "static ssize_t\nnilfs_ioctl_do_get_bdescs(struct the_nilfs *nilfs, __u64 *posp, int flags,\n\t\t\t  void *buf, size_t size, size_t nmembs)\n{\n\tstruct nilfs_bmap *bmap = NILFS_I(nilfs->ns_dat)->i_bmap;\n\tstruct nilfs_bdesc *bdescs = buf;\n\tint ret, i;\n\n\tdown_read(&nilfs->ns_segctor_sem);\n\tfor (i = 0; i < nmembs; i++) {\n\t\tret = nilfs_bmap_lookup_at_level(bmap,\n\t\t\t\t\t\t bdescs[i].bd_offset,\n\t\t\t\t\t\t bdescs[i].bd_level + 1,\n\t\t\t\t\t\t &bdescs[i].bd_blocknr);\n\t\tif (ret < 0) {\n\t\t\tif (ret != -ENOENT) {\n\t\t\t\tup_read(&nilfs->ns_segctor_sem);\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t\tbdescs[i].bd_blocknr = 0;\n\t\t}\n\t}\n\tup_read(&nilfs->ns_segctor_sem);\n\treturn nmembs;\n}",
    "includes": [
      "#include \"dat.h\"",
      "#include \"sufile.h\"",
      "#include \"cpfile.h\"",
      "#include \"bmap.h\"",
      "#include \"segment.h\"",
      "#include \"nilfs.h\"",
      "#include <linux/nilfs2_fs.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/mount.h>\t/* mnt_want_write_file(), mnt_drop_write_file() */",
      "#include <linux/compat.h>\t/* compat_ptr() */",
      "#include <linux/vmalloc.h>",
      "#include <linux/uaccess.h>\t/* copy_from_user(), copy_to_user() */",
      "#include <linux/capability.h>\t/* capable() */",
      "#include <linux/slab.h>",
      "#include <linux/wait.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "up_read",
          "args": [
            "&nilfs->ns_segctor_sem"
          ],
          "line": 504
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "up_read",
          "args": [
            "&nilfs->ns_segctor_sem"
          ],
          "line": 498
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nilfs_bmap_lookup_at_level",
          "args": [
            "bmap",
            "bdescs[i].bd_offset",
            "bdescs[i].bd_level + 1",
            "&bdescs[i].bd_blocknr"
          ],
          "line": 492
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_bmap_lookup_at_level",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/bmap.c",
          "lines": "75-97",
          "snippet": "int nilfs_bmap_lookup_at_level(struct nilfs_bmap *bmap, __u64 key, int level,\n\t\t\t       __u64 *ptrp)\n{\n\tsector_t blocknr;\n\tint ret;\n\n\tdown_read(&bmap->b_sem);\n\tret = bmap->b_ops->bop_lookup(bmap, key, level, ptrp);\n\tif (ret < 0) {\n\t\tret = nilfs_bmap_convert_error(bmap, __func__, ret);\n\t\tgoto out;\n\t}\n\tif (NILFS_BMAP_USE_VBN(bmap)) {\n\t\tret = nilfs_dat_translate(nilfs_bmap_get_dat(bmap), *ptrp,\n\t\t\t\t\t  &blocknr);\n\t\tif (!ret)\n\t\t\t*ptrp = blocknr;\n\t}\n\n out:\n\tup_read(&bmap->b_sem);\n\treturn ret;\n}",
          "includes": [
            "#include \"alloc.h\"",
            "#include \"dat.h\"",
            "#include \"mdt.h\"",
            "#include \"btnode.h\"",
            "#include \"direct.h\"",
            "#include \"btree.h\"",
            "#include \"bmap.h\"",
            "#include \"nilfs.h\"",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"alloc.h\"\n#include \"dat.h\"\n#include \"mdt.h\"\n#include \"btnode.h\"\n#include \"direct.h\"\n#include \"btree.h\"\n#include \"bmap.h\"\n#include \"nilfs.h\"\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/fs.h>\n\nint nilfs_bmap_lookup_at_level(struct nilfs_bmap *bmap, __u64 key, int level,\n\t\t\t       __u64 *ptrp)\n{\n\tsector_t blocknr;\n\tint ret;\n\n\tdown_read(&bmap->b_sem);\n\tret = bmap->b_ops->bop_lookup(bmap, key, level, ptrp);\n\tif (ret < 0) {\n\t\tret = nilfs_bmap_convert_error(bmap, __func__, ret);\n\t\tgoto out;\n\t}\n\tif (NILFS_BMAP_USE_VBN(bmap)) {\n\t\tret = nilfs_dat_translate(nilfs_bmap_get_dat(bmap), *ptrp,\n\t\t\t\t\t  &blocknr);\n\t\tif (!ret)\n\t\t\t*ptrp = blocknr;\n\t}\n\n out:\n\tup_read(&bmap->b_sem);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "down_read",
          "args": [
            "&nilfs->ns_segctor_sem"
          ],
          "line": 490
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NILFS_I",
          "args": [
            "nilfs->ns_dat"
          ],
          "line": 486
        },
        "resolved": true,
        "details": {
          "function_name": "NILFS_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/nilfs.h",
          "lines": "78-81",
          "snippet": "static inline struct nilfs_inode_info *NILFS_I(const struct inode *inode)\n{\n\treturn container_of(inode, struct nilfs_inode_info, vfs_inode);\n}",
          "includes": [
            "#include \"bmap.h\"",
            "#include \"the_nilfs.h\"",
            "#include <linux/nilfs2_fs.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"bmap.h\"\n#include \"the_nilfs.h\"\n#include <linux/nilfs2_fs.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/buffer_head.h>\n#include <linux/kernel.h>\n\nstatic inline struct nilfs_inode_info *NILFS_I(const struct inode *inode)\n{\n\treturn container_of(inode, struct nilfs_inode_info, vfs_inode);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"dat.h\"\n#include \"sufile.h\"\n#include \"cpfile.h\"\n#include \"bmap.h\"\n#include \"segment.h\"\n#include \"nilfs.h\"\n#include <linux/nilfs2_fs.h>\n#include <linux/buffer_head.h>\n#include <linux/mount.h>\t/* mnt_want_write_file(), mnt_drop_write_file() */\n#include <linux/compat.h>\t/* compat_ptr() */\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\t/* copy_from_user(), copy_to_user() */\n#include <linux/capability.h>\t/* capable() */\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/fs.h>\n\nstatic ssize_t\nnilfs_ioctl_do_get_bdescs(struct the_nilfs *nilfs, __u64 *posp, int flags,\n\t\t\t  void *buf, size_t size, size_t nmembs)\n{\n\tstruct nilfs_bmap *bmap = NILFS_I(nilfs->ns_dat)->i_bmap;\n\tstruct nilfs_bdesc *bdescs = buf;\n\tint ret, i;\n\n\tdown_read(&nilfs->ns_segctor_sem);\n\tfor (i = 0; i < nmembs; i++) {\n\t\tret = nilfs_bmap_lookup_at_level(bmap,\n\t\t\t\t\t\t bdescs[i].bd_offset,\n\t\t\t\t\t\t bdescs[i].bd_level + 1,\n\t\t\t\t\t\t &bdescs[i].bd_blocknr);\n\t\tif (ret < 0) {\n\t\t\tif (ret != -ENOENT) {\n\t\t\t\tup_read(&nilfs->ns_segctor_sem);\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t\tbdescs[i].bd_blocknr = 0;\n\t\t}\n\t}\n\tup_read(&nilfs->ns_segctor_sem);\n\treturn nmembs;\n}"
  },
  {
    "function_name": "nilfs_ioctl_do_get_vinfo",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/ioctl.c",
    "lines": "455-465",
    "snippet": "static ssize_t\nnilfs_ioctl_do_get_vinfo(struct the_nilfs *nilfs, __u64 *posp, int flags,\n\t\t\t void *buf, size_t size, size_t nmembs)\n{\n\tint ret;\n\n\tdown_read(&nilfs->ns_segctor_sem);\n\tret = nilfs_dat_get_vinfo(nilfs->ns_dat, buf, size, nmembs);\n\tup_read(&nilfs->ns_segctor_sem);\n\treturn ret;\n}",
    "includes": [
      "#include \"dat.h\"",
      "#include \"sufile.h\"",
      "#include \"cpfile.h\"",
      "#include \"bmap.h\"",
      "#include \"segment.h\"",
      "#include \"nilfs.h\"",
      "#include <linux/nilfs2_fs.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/mount.h>\t/* mnt_want_write_file(), mnt_drop_write_file() */",
      "#include <linux/compat.h>\t/* compat_ptr() */",
      "#include <linux/vmalloc.h>",
      "#include <linux/uaccess.h>\t/* copy_from_user(), copy_to_user() */",
      "#include <linux/capability.h>\t/* capable() */",
      "#include <linux/slab.h>",
      "#include <linux/wait.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "up_read",
          "args": [
            "&nilfs->ns_segctor_sem"
          ],
          "line": 463
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nilfs_dat_get_vinfo",
          "args": [
            "nilfs->ns_dat",
            "buf",
            "size",
            "nmembs"
          ],
          "line": 462
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_dat_get_vinfo",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/dat.c",
          "lines": "433-470",
          "snippet": "ssize_t nilfs_dat_get_vinfo(struct inode *dat, void *buf, unsigned visz,\n\t\t\t    size_t nvi)\n{\n\tstruct buffer_head *entry_bh;\n\tstruct nilfs_dat_entry *entry;\n\tstruct nilfs_vinfo *vinfo = buf;\n\t__u64 first, last;\n\tvoid *kaddr;\n\tunsigned long entries_per_block = NILFS_MDT(dat)->mi_entries_per_block;\n\tint i, j, n, ret;\n\n\tfor (i = 0; i < nvi; i += n) {\n\t\tret = nilfs_palloc_get_entry_block(dat, vinfo->vi_vblocknr,\n\t\t\t\t\t\t   0, &entry_bh);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\tkaddr = kmap_atomic(entry_bh->b_page);\n\t\t/* last virtual block number in this block */\n\t\tfirst = vinfo->vi_vblocknr;\n\t\tdo_div(first, entries_per_block);\n\t\tfirst *= entries_per_block;\n\t\tlast = first + entries_per_block - 1;\n\t\tfor (j = i, n = 0;\n\t\t     j < nvi && vinfo->vi_vblocknr >= first &&\n\t\t\t     vinfo->vi_vblocknr <= last;\n\t\t     j++, n++, vinfo = (void *)vinfo + visz) {\n\t\t\tentry = nilfs_palloc_block_get_entry(\n\t\t\t\tdat, vinfo->vi_vblocknr, entry_bh, kaddr);\n\t\t\tvinfo->vi_start = le64_to_cpu(entry->de_start);\n\t\t\tvinfo->vi_end = le64_to_cpu(entry->de_end);\n\t\t\tvinfo->vi_blocknr = le64_to_cpu(entry->de_blocknr);\n\t\t}\n\t\tkunmap_atomic(kaddr);\n\t\tbrelse(entry_bh);\n\t}\n\n\treturn nvi;\n}",
          "includes": [
            "#include \"dat.h\"",
            "#include \"alloc.h\"",
            "#include \"mdt.h\"",
            "#include \"nilfs.h\"",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"dat.h\"\n#include \"alloc.h\"\n#include \"mdt.h\"\n#include \"nilfs.h\"\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/buffer_head.h>\n#include <linux/types.h>\n\nssize_t nilfs_dat_get_vinfo(struct inode *dat, void *buf, unsigned visz,\n\t\t\t    size_t nvi)\n{\n\tstruct buffer_head *entry_bh;\n\tstruct nilfs_dat_entry *entry;\n\tstruct nilfs_vinfo *vinfo = buf;\n\t__u64 first, last;\n\tvoid *kaddr;\n\tunsigned long entries_per_block = NILFS_MDT(dat)->mi_entries_per_block;\n\tint i, j, n, ret;\n\n\tfor (i = 0; i < nvi; i += n) {\n\t\tret = nilfs_palloc_get_entry_block(dat, vinfo->vi_vblocknr,\n\t\t\t\t\t\t   0, &entry_bh);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\tkaddr = kmap_atomic(entry_bh->b_page);\n\t\t/* last virtual block number in this block */\n\t\tfirst = vinfo->vi_vblocknr;\n\t\tdo_div(first, entries_per_block);\n\t\tfirst *= entries_per_block;\n\t\tlast = first + entries_per_block - 1;\n\t\tfor (j = i, n = 0;\n\t\t     j < nvi && vinfo->vi_vblocknr >= first &&\n\t\t\t     vinfo->vi_vblocknr <= last;\n\t\t     j++, n++, vinfo = (void *)vinfo + visz) {\n\t\t\tentry = nilfs_palloc_block_get_entry(\n\t\t\t\tdat, vinfo->vi_vblocknr, entry_bh, kaddr);\n\t\t\tvinfo->vi_start = le64_to_cpu(entry->de_start);\n\t\t\tvinfo->vi_end = le64_to_cpu(entry->de_end);\n\t\t\tvinfo->vi_blocknr = le64_to_cpu(entry->de_blocknr);\n\t\t}\n\t\tkunmap_atomic(kaddr);\n\t\tbrelse(entry_bh);\n\t}\n\n\treturn nvi;\n}"
        }
      },
      {
        "call_info": {
          "callee": "down_read",
          "args": [
            "&nilfs->ns_segctor_sem"
          ],
          "line": 461
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"dat.h\"\n#include \"sufile.h\"\n#include \"cpfile.h\"\n#include \"bmap.h\"\n#include \"segment.h\"\n#include \"nilfs.h\"\n#include <linux/nilfs2_fs.h>\n#include <linux/buffer_head.h>\n#include <linux/mount.h>\t/* mnt_want_write_file(), mnt_drop_write_file() */\n#include <linux/compat.h>\t/* compat_ptr() */\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\t/* copy_from_user(), copy_to_user() */\n#include <linux/capability.h>\t/* capable() */\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/fs.h>\n\nstatic ssize_t\nnilfs_ioctl_do_get_vinfo(struct the_nilfs *nilfs, __u64 *posp, int flags,\n\t\t\t void *buf, size_t size, size_t nmembs)\n{\n\tint ret;\n\n\tdown_read(&nilfs->ns_segctor_sem);\n\tret = nilfs_dat_get_vinfo(nilfs->ns_dat, buf, size, nmembs);\n\tup_read(&nilfs->ns_segctor_sem);\n\treturn ret;\n}"
  },
  {
    "function_name": "nilfs_ioctl_get_sustat",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/ioctl.c",
    "lines": "422-438",
    "snippet": "static int nilfs_ioctl_get_sustat(struct inode *inode, struct file *filp,\n\t\t\t\t  unsigned int cmd, void __user *argp)\n{\n\tstruct the_nilfs *nilfs = inode->i_sb->s_fs_info;\n\tstruct nilfs_sustat sustat;\n\tint ret;\n\n\tdown_read(&nilfs->ns_segctor_sem);\n\tret = nilfs_sufile_get_stat(nilfs->ns_sufile, &sustat);\n\tup_read(&nilfs->ns_segctor_sem);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (copy_to_user(argp, &sustat, sizeof(sustat)))\n\t\tret = -EFAULT;\n\treturn ret;\n}",
    "includes": [
      "#include \"dat.h\"",
      "#include \"sufile.h\"",
      "#include \"cpfile.h\"",
      "#include \"bmap.h\"",
      "#include \"segment.h\"",
      "#include \"nilfs.h\"",
      "#include <linux/nilfs2_fs.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/mount.h>\t/* mnt_want_write_file(), mnt_drop_write_file() */",
      "#include <linux/compat.h>\t/* compat_ptr() */",
      "#include <linux/vmalloc.h>",
      "#include <linux/uaccess.h>\t/* copy_from_user(), copy_to_user() */",
      "#include <linux/capability.h>\t/* capable() */",
      "#include <linux/slab.h>",
      "#include <linux/wait.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "copy_to_user",
          "args": [
            "argp",
            "&sustat",
            "sizeof(sustat)"
          ],
          "line": 435
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "up_read",
          "args": [
            "&nilfs->ns_segctor_sem"
          ],
          "line": 431
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nilfs_sufile_get_stat",
          "args": [
            "nilfs->ns_sufile",
            "&sustat"
          ],
          "line": 430
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_sufile_get_stat",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/sufile.c",
          "lines": "567-597",
          "snippet": "int nilfs_sufile_get_stat(struct inode *sufile, struct nilfs_sustat *sustat)\n{\n\tstruct buffer_head *header_bh;\n\tstruct nilfs_sufile_header *header;\n\tstruct the_nilfs *nilfs = sufile->i_sb->s_fs_info;\n\tvoid *kaddr;\n\tint ret;\n\n\tdown_read(&NILFS_MDT(sufile)->mi_sem);\n\n\tret = nilfs_sufile_get_header_block(sufile, &header_bh);\n\tif (ret < 0)\n\t\tgoto out_sem;\n\n\tkaddr = kmap_atomic(header_bh->b_page);\n\theader = kaddr + bh_offset(header_bh);\n\tsustat->ss_nsegs = nilfs_sufile_get_nsegments(sufile);\n\tsustat->ss_ncleansegs = le64_to_cpu(header->sh_ncleansegs);\n\tsustat->ss_ndirtysegs = le64_to_cpu(header->sh_ndirtysegs);\n\tsustat->ss_ctime = nilfs->ns_ctime;\n\tsustat->ss_nongc_ctime = nilfs->ns_nongc_ctime;\n\tspin_lock(&nilfs->ns_last_segment_lock);\n\tsustat->ss_prot_seq = nilfs->ns_prot_seq;\n\tspin_unlock(&nilfs->ns_last_segment_lock);\n\tkunmap_atomic(kaddr);\n\tbrelse(header_bh);\n\n out_sem:\n\tup_read(&NILFS_MDT(sufile)->mi_sem);\n\treturn ret;\n}",
          "includes": [
            "#include \"sufile.h\"",
            "#include \"mdt.h\"",
            "#include <linux/nilfs2_fs.h>",
            "#include <linux/errno.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/fs.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sufile.h\"\n#include \"mdt.h\"\n#include <linux/nilfs2_fs.h>\n#include <linux/errno.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/fs.h>\n#include <linux/kernel.h>\n\nint nilfs_sufile_get_stat(struct inode *sufile, struct nilfs_sustat *sustat)\n{\n\tstruct buffer_head *header_bh;\n\tstruct nilfs_sufile_header *header;\n\tstruct the_nilfs *nilfs = sufile->i_sb->s_fs_info;\n\tvoid *kaddr;\n\tint ret;\n\n\tdown_read(&NILFS_MDT(sufile)->mi_sem);\n\n\tret = nilfs_sufile_get_header_block(sufile, &header_bh);\n\tif (ret < 0)\n\t\tgoto out_sem;\n\n\tkaddr = kmap_atomic(header_bh->b_page);\n\theader = kaddr + bh_offset(header_bh);\n\tsustat->ss_nsegs = nilfs_sufile_get_nsegments(sufile);\n\tsustat->ss_ncleansegs = le64_to_cpu(header->sh_ncleansegs);\n\tsustat->ss_ndirtysegs = le64_to_cpu(header->sh_ndirtysegs);\n\tsustat->ss_ctime = nilfs->ns_ctime;\n\tsustat->ss_nongc_ctime = nilfs->ns_nongc_ctime;\n\tspin_lock(&nilfs->ns_last_segment_lock);\n\tsustat->ss_prot_seq = nilfs->ns_prot_seq;\n\tspin_unlock(&nilfs->ns_last_segment_lock);\n\tkunmap_atomic(kaddr);\n\tbrelse(header_bh);\n\n out_sem:\n\tup_read(&NILFS_MDT(sufile)->mi_sem);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "down_read",
          "args": [
            "&nilfs->ns_segctor_sem"
          ],
          "line": 429
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"dat.h\"\n#include \"sufile.h\"\n#include \"cpfile.h\"\n#include \"bmap.h\"\n#include \"segment.h\"\n#include \"nilfs.h\"\n#include <linux/nilfs2_fs.h>\n#include <linux/buffer_head.h>\n#include <linux/mount.h>\t/* mnt_want_write_file(), mnt_drop_write_file() */\n#include <linux/compat.h>\t/* compat_ptr() */\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\t/* copy_from_user(), copy_to_user() */\n#include <linux/capability.h>\t/* capable() */\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/fs.h>\n\nstatic int nilfs_ioctl_get_sustat(struct inode *inode, struct file *filp,\n\t\t\t\t  unsigned int cmd, void __user *argp)\n{\n\tstruct the_nilfs *nilfs = inode->i_sb->s_fs_info;\n\tstruct nilfs_sustat sustat;\n\tint ret;\n\n\tdown_read(&nilfs->ns_segctor_sem);\n\tret = nilfs_sufile_get_stat(nilfs->ns_sufile, &sustat);\n\tup_read(&nilfs->ns_segctor_sem);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (copy_to_user(argp, &sustat, sizeof(sustat)))\n\t\tret = -EFAULT;\n\treturn ret;\n}"
  },
  {
    "function_name": "nilfs_ioctl_do_get_suinfo",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/ioctl.c",
    "lines": "388-399",
    "snippet": "static ssize_t\nnilfs_ioctl_do_get_suinfo(struct the_nilfs *nilfs, __u64 *posp, int flags,\n\t\t\t  void *buf, size_t size, size_t nmembs)\n{\n\tint ret;\n\n\tdown_read(&nilfs->ns_segctor_sem);\n\tret = nilfs_sufile_get_suinfo(nilfs->ns_sufile, *posp, buf, size,\n\t\t\t\t      nmembs);\n\tup_read(&nilfs->ns_segctor_sem);\n\treturn ret;\n}",
    "includes": [
      "#include \"dat.h\"",
      "#include \"sufile.h\"",
      "#include \"cpfile.h\"",
      "#include \"bmap.h\"",
      "#include \"segment.h\"",
      "#include \"nilfs.h\"",
      "#include <linux/nilfs2_fs.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/mount.h>\t/* mnt_want_write_file(), mnt_drop_write_file() */",
      "#include <linux/compat.h>\t/* compat_ptr() */",
      "#include <linux/vmalloc.h>",
      "#include <linux/uaccess.h>\t/* copy_from_user(), copy_to_user() */",
      "#include <linux/capability.h>\t/* capable() */",
      "#include <linux/slab.h>",
      "#include <linux/wait.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "up_read",
          "args": [
            "&nilfs->ns_segctor_sem"
          ],
          "line": 397
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nilfs_sufile_get_suinfo",
          "args": [
            "nilfs->ns_sufile",
            "*posp",
            "buf",
            "size",
            "nmembs"
          ],
          "line": 395
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_sufile_get_suinfo",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/sufile.c",
          "lines": "814-870",
          "snippet": "ssize_t nilfs_sufile_get_suinfo(struct inode *sufile, __u64 segnum, void *buf,\n\t\t\t\tunsigned sisz, size_t nsi)\n{\n\tstruct buffer_head *su_bh;\n\tstruct nilfs_segment_usage *su;\n\tstruct nilfs_suinfo *si = buf;\n\tsize_t susz = NILFS_MDT(sufile)->mi_entry_size;\n\tstruct the_nilfs *nilfs = sufile->i_sb->s_fs_info;\n\tvoid *kaddr;\n\tunsigned long nsegs, segusages_per_block;\n\tssize_t n;\n\tint ret, i, j;\n\n\tdown_read(&NILFS_MDT(sufile)->mi_sem);\n\n\tsegusages_per_block = nilfs_sufile_segment_usages_per_block(sufile);\n\tnsegs = min_t(unsigned long,\n\t\t      nilfs_sufile_get_nsegments(sufile) - segnum,\n\t\t      nsi);\n\tfor (i = 0; i < nsegs; i += n, segnum += n) {\n\t\tn = min_t(unsigned long,\n\t\t\t  segusages_per_block -\n\t\t\t\t  nilfs_sufile_get_offset(sufile, segnum),\n\t\t\t  nsegs - i);\n\t\tret = nilfs_sufile_get_segment_usage_block(sufile, segnum, 0,\n\t\t\t\t\t\t\t   &su_bh);\n\t\tif (ret < 0) {\n\t\t\tif (ret != -ENOENT)\n\t\t\t\tgoto out;\n\t\t\t/* hole */\n\t\t\tmemset(si, 0, sisz * n);\n\t\t\tsi = (void *)si + sisz * n;\n\t\t\tcontinue;\n\t\t}\n\n\t\tkaddr = kmap_atomic(su_bh->b_page);\n\t\tsu = nilfs_sufile_block_get_segment_usage(\n\t\t\tsufile, segnum, su_bh, kaddr);\n\t\tfor (j = 0; j < n;\n\t\t     j++, su = (void *)su + susz, si = (void *)si + sisz) {\n\t\t\tsi->sui_lastmod = le64_to_cpu(su->su_lastmod);\n\t\t\tsi->sui_nblocks = le32_to_cpu(su->su_nblocks);\n\t\t\tsi->sui_flags = le32_to_cpu(su->su_flags) &\n\t\t\t\t~(1UL << NILFS_SEGMENT_USAGE_ACTIVE);\n\t\t\tif (nilfs_segment_is_active(nilfs, segnum + j))\n\t\t\t\tsi->sui_flags |=\n\t\t\t\t\t(1UL << NILFS_SEGMENT_USAGE_ACTIVE);\n\t\t}\n\t\tkunmap_atomic(kaddr);\n\t\tbrelse(su_bh);\n\t}\n\tret = nsegs;\n\n out:\n\tup_read(&NILFS_MDT(sufile)->mi_sem);\n\treturn ret;\n}",
          "includes": [
            "#include \"sufile.h\"",
            "#include \"mdt.h\"",
            "#include <linux/nilfs2_fs.h>",
            "#include <linux/errno.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/fs.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sufile.h\"\n#include \"mdt.h\"\n#include <linux/nilfs2_fs.h>\n#include <linux/errno.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/fs.h>\n#include <linux/kernel.h>\n\nssize_t nilfs_sufile_get_suinfo(struct inode *sufile, __u64 segnum, void *buf,\n\t\t\t\tunsigned sisz, size_t nsi)\n{\n\tstruct buffer_head *su_bh;\n\tstruct nilfs_segment_usage *su;\n\tstruct nilfs_suinfo *si = buf;\n\tsize_t susz = NILFS_MDT(sufile)->mi_entry_size;\n\tstruct the_nilfs *nilfs = sufile->i_sb->s_fs_info;\n\tvoid *kaddr;\n\tunsigned long nsegs, segusages_per_block;\n\tssize_t n;\n\tint ret, i, j;\n\n\tdown_read(&NILFS_MDT(sufile)->mi_sem);\n\n\tsegusages_per_block = nilfs_sufile_segment_usages_per_block(sufile);\n\tnsegs = min_t(unsigned long,\n\t\t      nilfs_sufile_get_nsegments(sufile) - segnum,\n\t\t      nsi);\n\tfor (i = 0; i < nsegs; i += n, segnum += n) {\n\t\tn = min_t(unsigned long,\n\t\t\t  segusages_per_block -\n\t\t\t\t  nilfs_sufile_get_offset(sufile, segnum),\n\t\t\t  nsegs - i);\n\t\tret = nilfs_sufile_get_segment_usage_block(sufile, segnum, 0,\n\t\t\t\t\t\t\t   &su_bh);\n\t\tif (ret < 0) {\n\t\t\tif (ret != -ENOENT)\n\t\t\t\tgoto out;\n\t\t\t/* hole */\n\t\t\tmemset(si, 0, sisz * n);\n\t\t\tsi = (void *)si + sisz * n;\n\t\t\tcontinue;\n\t\t}\n\n\t\tkaddr = kmap_atomic(su_bh->b_page);\n\t\tsu = nilfs_sufile_block_get_segment_usage(\n\t\t\tsufile, segnum, su_bh, kaddr);\n\t\tfor (j = 0; j < n;\n\t\t     j++, su = (void *)su + susz, si = (void *)si + sisz) {\n\t\t\tsi->sui_lastmod = le64_to_cpu(su->su_lastmod);\n\t\t\tsi->sui_nblocks = le32_to_cpu(su->su_nblocks);\n\t\t\tsi->sui_flags = le32_to_cpu(su->su_flags) &\n\t\t\t\t~(1UL << NILFS_SEGMENT_USAGE_ACTIVE);\n\t\t\tif (nilfs_segment_is_active(nilfs, segnum + j))\n\t\t\t\tsi->sui_flags |=\n\t\t\t\t\t(1UL << NILFS_SEGMENT_USAGE_ACTIVE);\n\t\t}\n\t\tkunmap_atomic(kaddr);\n\t\tbrelse(su_bh);\n\t}\n\tret = nsegs;\n\n out:\n\tup_read(&NILFS_MDT(sufile)->mi_sem);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "down_read",
          "args": [
            "&nilfs->ns_segctor_sem"
          ],
          "line": 394
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"dat.h\"\n#include \"sufile.h\"\n#include \"cpfile.h\"\n#include \"bmap.h\"\n#include \"segment.h\"\n#include \"nilfs.h\"\n#include <linux/nilfs2_fs.h>\n#include <linux/buffer_head.h>\n#include <linux/mount.h>\t/* mnt_want_write_file(), mnt_drop_write_file() */\n#include <linux/compat.h>\t/* compat_ptr() */\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\t/* copy_from_user(), copy_to_user() */\n#include <linux/capability.h>\t/* capable() */\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/fs.h>\n\nstatic ssize_t\nnilfs_ioctl_do_get_suinfo(struct the_nilfs *nilfs, __u64 *posp, int flags,\n\t\t\t  void *buf, size_t size, size_t nmembs)\n{\n\tint ret;\n\n\tdown_read(&nilfs->ns_segctor_sem);\n\tret = nilfs_sufile_get_suinfo(nilfs->ns_sufile, *posp, buf, size,\n\t\t\t\t      nmembs);\n\tup_read(&nilfs->ns_segctor_sem);\n\treturn ret;\n}"
  },
  {
    "function_name": "nilfs_ioctl_get_cpstat",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/ioctl.c",
    "lines": "355-371",
    "snippet": "static int nilfs_ioctl_get_cpstat(struct inode *inode, struct file *filp,\n\t\t\t\t  unsigned int cmd, void __user *argp)\n{\n\tstruct the_nilfs *nilfs = inode->i_sb->s_fs_info;\n\tstruct nilfs_cpstat cpstat;\n\tint ret;\n\n\tdown_read(&nilfs->ns_segctor_sem);\n\tret = nilfs_cpfile_get_stat(nilfs->ns_cpfile, &cpstat);\n\tup_read(&nilfs->ns_segctor_sem);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (copy_to_user(argp, &cpstat, sizeof(cpstat)))\n\t\tret = -EFAULT;\n\treturn ret;\n}",
    "includes": [
      "#include \"dat.h\"",
      "#include \"sufile.h\"",
      "#include \"cpfile.h\"",
      "#include \"bmap.h\"",
      "#include \"segment.h\"",
      "#include \"nilfs.h\"",
      "#include <linux/nilfs2_fs.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/mount.h>\t/* mnt_want_write_file(), mnt_drop_write_file() */",
      "#include <linux/compat.h>\t/* compat_ptr() */",
      "#include <linux/vmalloc.h>",
      "#include <linux/uaccess.h>\t/* copy_from_user(), copy_to_user() */",
      "#include <linux/capability.h>\t/* capable() */",
      "#include <linux/slab.h>",
      "#include <linux/wait.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "copy_to_user",
          "args": [
            "argp",
            "&cpstat",
            "sizeof(cpstat)"
          ],
          "line": 368
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "up_read",
          "args": [
            "&nilfs->ns_segctor_sem"
          ],
          "line": 364
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nilfs_cpfile_get_stat",
          "args": [
            "nilfs->ns_cpfile",
            "&cpstat"
          ],
          "line": 363
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_cpfile_get_stat",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/cpfile.c",
          "lines": "907-930",
          "snippet": "int nilfs_cpfile_get_stat(struct inode *cpfile, struct nilfs_cpstat *cpstat)\n{\n\tstruct buffer_head *bh;\n\tstruct nilfs_cpfile_header *header;\n\tvoid *kaddr;\n\tint ret;\n\n\tdown_read(&NILFS_MDT(cpfile)->mi_sem);\n\n\tret = nilfs_cpfile_get_header_block(cpfile, &bh);\n\tif (ret < 0)\n\t\tgoto out_sem;\n\tkaddr = kmap_atomic(bh->b_page);\n\theader = nilfs_cpfile_block_get_header(cpfile, bh, kaddr);\n\tcpstat->cs_cno = nilfs_mdt_cno(cpfile);\n\tcpstat->cs_ncps = le64_to_cpu(header->ch_ncheckpoints);\n\tcpstat->cs_nsss = le64_to_cpu(header->ch_nsnapshots);\n\tkunmap_atomic(kaddr);\n\tbrelse(bh);\n\n out_sem:\n\tup_read(&NILFS_MDT(cpfile)->mi_sem);\n\treturn ret;\n}",
          "includes": [
            "#include \"cpfile.h\"",
            "#include \"mdt.h\"",
            "#include <linux/nilfs2_fs.h>",
            "#include <linux/errno.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/fs.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cpfile.h\"\n#include \"mdt.h\"\n#include <linux/nilfs2_fs.h>\n#include <linux/errno.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/fs.h>\n#include <linux/kernel.h>\n\nint nilfs_cpfile_get_stat(struct inode *cpfile, struct nilfs_cpstat *cpstat)\n{\n\tstruct buffer_head *bh;\n\tstruct nilfs_cpfile_header *header;\n\tvoid *kaddr;\n\tint ret;\n\n\tdown_read(&NILFS_MDT(cpfile)->mi_sem);\n\n\tret = nilfs_cpfile_get_header_block(cpfile, &bh);\n\tif (ret < 0)\n\t\tgoto out_sem;\n\tkaddr = kmap_atomic(bh->b_page);\n\theader = nilfs_cpfile_block_get_header(cpfile, bh, kaddr);\n\tcpstat->cs_cno = nilfs_mdt_cno(cpfile);\n\tcpstat->cs_ncps = le64_to_cpu(header->ch_ncheckpoints);\n\tcpstat->cs_nsss = le64_to_cpu(header->ch_nsnapshots);\n\tkunmap_atomic(kaddr);\n\tbrelse(bh);\n\n out_sem:\n\tup_read(&NILFS_MDT(cpfile)->mi_sem);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "down_read",
          "args": [
            "&nilfs->ns_segctor_sem"
          ],
          "line": 362
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"dat.h\"\n#include \"sufile.h\"\n#include \"cpfile.h\"\n#include \"bmap.h\"\n#include \"segment.h\"\n#include \"nilfs.h\"\n#include <linux/nilfs2_fs.h>\n#include <linux/buffer_head.h>\n#include <linux/mount.h>\t/* mnt_want_write_file(), mnt_drop_write_file() */\n#include <linux/compat.h>\t/* compat_ptr() */\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\t/* copy_from_user(), copy_to_user() */\n#include <linux/capability.h>\t/* capable() */\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/fs.h>\n\nstatic int nilfs_ioctl_get_cpstat(struct inode *inode, struct file *filp,\n\t\t\t\t  unsigned int cmd, void __user *argp)\n{\n\tstruct the_nilfs *nilfs = inode->i_sb->s_fs_info;\n\tstruct nilfs_cpstat cpstat;\n\tint ret;\n\n\tdown_read(&nilfs->ns_segctor_sem);\n\tret = nilfs_cpfile_get_stat(nilfs->ns_cpfile, &cpstat);\n\tup_read(&nilfs->ns_segctor_sem);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (copy_to_user(argp, &cpstat, sizeof(cpstat)))\n\t\tret = -EFAULT;\n\treturn ret;\n}"
  },
  {
    "function_name": "nilfs_ioctl_do_get_cpinfo",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/ioctl.c",
    "lines": "321-332",
    "snippet": "static ssize_t\nnilfs_ioctl_do_get_cpinfo(struct the_nilfs *nilfs, __u64 *posp, int flags,\n\t\t\t  void *buf, size_t size, size_t nmembs)\n{\n\tint ret;\n\n\tdown_read(&nilfs->ns_segctor_sem);\n\tret = nilfs_cpfile_get_cpinfo(nilfs->ns_cpfile, posp, flags, buf,\n\t\t\t\t      size, nmembs);\n\tup_read(&nilfs->ns_segctor_sem);\n\treturn ret;\n}",
    "includes": [
      "#include \"dat.h\"",
      "#include \"sufile.h\"",
      "#include \"cpfile.h\"",
      "#include \"bmap.h\"",
      "#include \"segment.h\"",
      "#include \"nilfs.h\"",
      "#include <linux/nilfs2_fs.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/mount.h>\t/* mnt_want_write_file(), mnt_drop_write_file() */",
      "#include <linux/compat.h>\t/* compat_ptr() */",
      "#include <linux/vmalloc.h>",
      "#include <linux/uaccess.h>\t/* copy_from_user(), copy_to_user() */",
      "#include <linux/capability.h>\t/* capable() */",
      "#include <linux/slab.h>",
      "#include <linux/wait.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "up_read",
          "args": [
            "&nilfs->ns_segctor_sem"
          ],
          "line": 330
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nilfs_cpfile_get_cpinfo",
          "args": [
            "nilfs->ns_cpfile",
            "posp",
            "flags",
            "buf",
            "size",
            "nmembs"
          ],
          "line": 328
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_cpfile_get_cpinfo",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/cpfile.c",
          "lines": "526-537",
          "snippet": "ssize_t nilfs_cpfile_get_cpinfo(struct inode *cpfile, __u64 *cnop, int mode,\n\t\t\t\tvoid *buf, unsigned cisz, size_t nci)\n{\n\tswitch (mode) {\n\tcase NILFS_CHECKPOINT:\n\t\treturn nilfs_cpfile_do_get_cpinfo(cpfile, cnop, buf, cisz, nci);\n\tcase NILFS_SNAPSHOT:\n\t\treturn nilfs_cpfile_do_get_ssinfo(cpfile, cnop, buf, cisz, nci);\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}",
          "includes": [
            "#include \"cpfile.h\"",
            "#include \"mdt.h\"",
            "#include <linux/nilfs2_fs.h>",
            "#include <linux/errno.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/fs.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cpfile.h\"\n#include \"mdt.h\"\n#include <linux/nilfs2_fs.h>\n#include <linux/errno.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/fs.h>\n#include <linux/kernel.h>\n\nssize_t nilfs_cpfile_get_cpinfo(struct inode *cpfile, __u64 *cnop, int mode,\n\t\t\t\tvoid *buf, unsigned cisz, size_t nci)\n{\n\tswitch (mode) {\n\tcase NILFS_CHECKPOINT:\n\t\treturn nilfs_cpfile_do_get_cpinfo(cpfile, cnop, buf, cisz, nci);\n\tcase NILFS_SNAPSHOT:\n\t\treturn nilfs_cpfile_do_get_ssinfo(cpfile, cnop, buf, cisz, nci);\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "down_read",
          "args": [
            "&nilfs->ns_segctor_sem"
          ],
          "line": 327
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"dat.h\"\n#include \"sufile.h\"\n#include \"cpfile.h\"\n#include \"bmap.h\"\n#include \"segment.h\"\n#include \"nilfs.h\"\n#include <linux/nilfs2_fs.h>\n#include <linux/buffer_head.h>\n#include <linux/mount.h>\t/* mnt_want_write_file(), mnt_drop_write_file() */\n#include <linux/compat.h>\t/* compat_ptr() */\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\t/* copy_from_user(), copy_to_user() */\n#include <linux/capability.h>\t/* capable() */\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/fs.h>\n\nstatic ssize_t\nnilfs_ioctl_do_get_cpinfo(struct the_nilfs *nilfs, __u64 *posp, int flags,\n\t\t\t  void *buf, size_t size, size_t nmembs)\n{\n\tint ret;\n\n\tdown_read(&nilfs->ns_segctor_sem);\n\tret = nilfs_cpfile_get_cpinfo(nilfs->ns_cpfile, posp, flags, buf,\n\t\t\t\t      size, nmembs);\n\tup_read(&nilfs->ns_segctor_sem);\n\treturn ret;\n}"
  },
  {
    "function_name": "nilfs_ioctl_delete_checkpoint",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/ioctl.c",
    "lines": "275-304",
    "snippet": "static int\nnilfs_ioctl_delete_checkpoint(struct inode *inode, struct file *filp,\n\t\t\t      unsigned int cmd, void __user *argp)\n{\n\tstruct the_nilfs *nilfs = inode->i_sb->s_fs_info;\n\tstruct nilfs_transaction_info ti;\n\t__u64 cno;\n\tint ret;\n\n\tif (!capable(CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\n\tret = mnt_want_write_file(filp);\n\tif (ret)\n\t\treturn ret;\n\n\tret = -EFAULT;\n\tif (copy_from_user(&cno, argp, sizeof(cno)))\n\t\tgoto out;\n\n\tnilfs_transaction_begin(inode->i_sb, &ti, 0);\n\tret = nilfs_cpfile_delete_checkpoint(nilfs->ns_cpfile, cno);\n\tif (unlikely(ret < 0))\n\t\tnilfs_transaction_abort(inode->i_sb);\n\telse\n\t\tnilfs_transaction_commit(inode->i_sb); /* never fails */\nout:\n\tmnt_drop_write_file(filp);\n\treturn ret;\n}",
    "includes": [
      "#include \"dat.h\"",
      "#include \"sufile.h\"",
      "#include \"cpfile.h\"",
      "#include \"bmap.h\"",
      "#include \"segment.h\"",
      "#include \"nilfs.h\"",
      "#include <linux/nilfs2_fs.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/mount.h>\t/* mnt_want_write_file(), mnt_drop_write_file() */",
      "#include <linux/compat.h>\t/* compat_ptr() */",
      "#include <linux/vmalloc.h>",
      "#include <linux/uaccess.h>\t/* copy_from_user(), copy_to_user() */",
      "#include <linux/capability.h>\t/* capable() */",
      "#include <linux/slab.h>",
      "#include <linux/wait.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mnt_drop_write_file",
          "args": [
            "filp"
          ],
          "line": 302
        },
        "resolved": true,
        "details": {
          "function_name": "mnt_drop_write_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namespace.c",
          "lines": "487-490",
          "snippet": "void mnt_drop_write_file(struct file *file)\n{\n\tmnt_drop_write(file->f_path.mnt);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"pnode.h\"",
            "#include <linux/task_work.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/magic.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
            "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
            "#include <linux/init.h>\t\t/* init_rootfs */",
            "#include <linux/idr.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/mnt_namespace.h>",
            "#include <linux/capability.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void shrink_submounts(struct mount *mnt);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/task_work.h>\n#include <linux/bootmem.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic void shrink_submounts(struct mount *mnt);\n\nvoid mnt_drop_write_file(struct file *file)\n{\n\tmnt_drop_write(file->f_path.mnt);\n}"
        }
      },
      {
        "call_info": {
          "callee": "nilfs_transaction_commit",
          "args": [
            "inode->i_sb"
          ],
          "line": 300
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_transaction_commit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/segment.c",
          "lines": "223-252",
          "snippet": "int nilfs_transaction_commit(struct super_block *sb)\n{\n\tstruct nilfs_transaction_info *ti = current->journal_info;\n\tstruct the_nilfs *nilfs = sb->s_fs_info;\n\tint err = 0;\n\n\tBUG_ON(ti == NULL || ti->ti_magic != NILFS_TI_MAGIC);\n\tti->ti_flags |= NILFS_TI_COMMIT;\n\tif (ti->ti_count > 0) {\n\t\tti->ti_count--;\n\t\treturn 0;\n\t}\n\tif (nilfs->ns_writer) {\n\t\tstruct nilfs_sc_info *sci = nilfs->ns_writer;\n\n\t\tif (ti->ti_flags & NILFS_TI_COMMIT)\n\t\t\tnilfs_segctor_start_timer(sci);\n\t\tif (atomic_read(&nilfs->ns_ndirtyblks) > sci->sc_watermark)\n\t\t\tnilfs_segctor_do_flush(sci, 0);\n\t}\n\tup_read(&nilfs->ns_segctor_sem);\n\tcurrent->journal_info = ti->ti_save;\n\n\tif (ti->ti_flags & NILFS_TI_SYNC)\n\t\terr = nilfs_construct_segment(sb);\n\tif (ti->ti_flags & NILFS_TI_DYNAMIC_ALLOC)\n\t\tkmem_cache_free(nilfs_transaction_cachep, ti);\n\tsb_end_intwrite(sb);\n\treturn err;\n}",
          "includes": [
            "#include \"segbuf.h\"",
            "#include \"ifile.h\"",
            "#include \"cpfile.h\"",
            "#include \"sufile.h\"",
            "#include \"segment.h\"",
            "#include \"page.h\"",
            "#include \"btnode.h\"",
            "#include \"nilfs.h\"",
            "#include <linux/slab.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/crc32.h>",
            "#include <linux/kthread.h>",
            "#include <linux/freezer.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/completion.h>",
            "#include <linux/bio.h>",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void nilfs_segctor_start_timer(struct nilfs_sc_info *);",
            "static void nilfs_segctor_do_flush(struct nilfs_sc_info *, int);",
            "static void nilfs_segctor_do_immediate_flush(struct nilfs_sc_info *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"segbuf.h\"\n#include \"ifile.h\"\n#include \"cpfile.h\"\n#include \"sufile.h\"\n#include \"segment.h\"\n#include \"page.h\"\n#include \"btnode.h\"\n#include \"nilfs.h\"\n#include <linux/slab.h>\n#include <linux/pagevec.h>\n#include <linux/crc32.h>\n#include <linux/kthread.h>\n#include <linux/freezer.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/completion.h>\n#include <linux/bio.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n\nstatic void nilfs_segctor_start_timer(struct nilfs_sc_info *);\nstatic void nilfs_segctor_do_flush(struct nilfs_sc_info *, int);\nstatic void nilfs_segctor_do_immediate_flush(struct nilfs_sc_info *);\n\nint nilfs_transaction_commit(struct super_block *sb)\n{\n\tstruct nilfs_transaction_info *ti = current->journal_info;\n\tstruct the_nilfs *nilfs = sb->s_fs_info;\n\tint err = 0;\n\n\tBUG_ON(ti == NULL || ti->ti_magic != NILFS_TI_MAGIC);\n\tti->ti_flags |= NILFS_TI_COMMIT;\n\tif (ti->ti_count > 0) {\n\t\tti->ti_count--;\n\t\treturn 0;\n\t}\n\tif (nilfs->ns_writer) {\n\t\tstruct nilfs_sc_info *sci = nilfs->ns_writer;\n\n\t\tif (ti->ti_flags & NILFS_TI_COMMIT)\n\t\t\tnilfs_segctor_start_timer(sci);\n\t\tif (atomic_read(&nilfs->ns_ndirtyblks) > sci->sc_watermark)\n\t\t\tnilfs_segctor_do_flush(sci, 0);\n\t}\n\tup_read(&nilfs->ns_segctor_sem);\n\tcurrent->journal_info = ti->ti_save;\n\n\tif (ti->ti_flags & NILFS_TI_SYNC)\n\t\terr = nilfs_construct_segment(sb);\n\tif (ti->ti_flags & NILFS_TI_DYNAMIC_ALLOC)\n\t\tkmem_cache_free(nilfs_transaction_cachep, ti);\n\tsb_end_intwrite(sb);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nilfs_transaction_abort",
          "args": [
            "inode->i_sb"
          ],
          "line": 298
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_transaction_abort",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/segment.c",
          "lines": "254-270",
          "snippet": "void nilfs_transaction_abort(struct super_block *sb)\n{\n\tstruct nilfs_transaction_info *ti = current->journal_info;\n\tstruct the_nilfs *nilfs = sb->s_fs_info;\n\n\tBUG_ON(ti == NULL || ti->ti_magic != NILFS_TI_MAGIC);\n\tif (ti->ti_count > 0) {\n\t\tti->ti_count--;\n\t\treturn;\n\t}\n\tup_read(&nilfs->ns_segctor_sem);\n\n\tcurrent->journal_info = ti->ti_save;\n\tif (ti->ti_flags & NILFS_TI_DYNAMIC_ALLOC)\n\t\tkmem_cache_free(nilfs_transaction_cachep, ti);\n\tsb_end_intwrite(sb);\n}",
          "includes": [
            "#include \"segbuf.h\"",
            "#include \"ifile.h\"",
            "#include \"cpfile.h\"",
            "#include \"sufile.h\"",
            "#include \"segment.h\"",
            "#include \"page.h\"",
            "#include \"btnode.h\"",
            "#include \"nilfs.h\"",
            "#include <linux/slab.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/crc32.h>",
            "#include <linux/kthread.h>",
            "#include <linux/freezer.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/completion.h>",
            "#include <linux/bio.h>",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"segbuf.h\"\n#include \"ifile.h\"\n#include \"cpfile.h\"\n#include \"sufile.h\"\n#include \"segment.h\"\n#include \"page.h\"\n#include \"btnode.h\"\n#include \"nilfs.h\"\n#include <linux/slab.h>\n#include <linux/pagevec.h>\n#include <linux/crc32.h>\n#include <linux/kthread.h>\n#include <linux/freezer.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/completion.h>\n#include <linux/bio.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n\nvoid nilfs_transaction_abort(struct super_block *sb)\n{\n\tstruct nilfs_transaction_info *ti = current->journal_info;\n\tstruct the_nilfs *nilfs = sb->s_fs_info;\n\n\tBUG_ON(ti == NULL || ti->ti_magic != NILFS_TI_MAGIC);\n\tif (ti->ti_count > 0) {\n\t\tti->ti_count--;\n\t\treturn;\n\t}\n\tup_read(&nilfs->ns_segctor_sem);\n\n\tcurrent->journal_info = ti->ti_save;\n\tif (ti->ti_flags & NILFS_TI_DYNAMIC_ALLOC)\n\t\tkmem_cache_free(nilfs_transaction_cachep, ti);\n\tsb_end_intwrite(sb);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "ret < 0"
          ],
          "line": 297
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nilfs_cpfile_delete_checkpoint",
          "args": [
            "nilfs->ns_cpfile",
            "cno"
          ],
          "line": 296
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_cpfile_delete_checkpoint",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/cpfile.c",
          "lines": "544-559",
          "snippet": "int nilfs_cpfile_delete_checkpoint(struct inode *cpfile, __u64 cno)\n{\n\tstruct nilfs_cpinfo ci;\n\t__u64 tcno = cno;\n\tssize_t nci;\n\n\tnci = nilfs_cpfile_do_get_cpinfo(cpfile, &tcno, &ci, sizeof(ci), 1);\n\tif (nci < 0)\n\t\treturn nci;\n\telse if (nci == 0 || ci.ci_cno != cno)\n\t\treturn -ENOENT;\n\telse if (nilfs_cpinfo_snapshot(&ci))\n\t\treturn -EBUSY;\n\n\treturn nilfs_cpfile_delete_checkpoints(cpfile, cno, cno + 1);\n}",
          "includes": [
            "#include \"cpfile.h\"",
            "#include \"mdt.h\"",
            "#include <linux/nilfs2_fs.h>",
            "#include <linux/errno.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/fs.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cpfile.h\"\n#include \"mdt.h\"\n#include <linux/nilfs2_fs.h>\n#include <linux/errno.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/fs.h>\n#include <linux/kernel.h>\n\nint nilfs_cpfile_delete_checkpoint(struct inode *cpfile, __u64 cno)\n{\n\tstruct nilfs_cpinfo ci;\n\t__u64 tcno = cno;\n\tssize_t nci;\n\n\tnci = nilfs_cpfile_do_get_cpinfo(cpfile, &tcno, &ci, sizeof(ci), 1);\n\tif (nci < 0)\n\t\treturn nci;\n\telse if (nci == 0 || ci.ci_cno != cno)\n\t\treturn -ENOENT;\n\telse if (nilfs_cpinfo_snapshot(&ci))\n\t\treturn -EBUSY;\n\n\treturn nilfs_cpfile_delete_checkpoints(cpfile, cno, cno + 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "nilfs_transaction_begin",
          "args": [
            "inode->i_sb",
            "&ti",
            "0"
          ],
          "line": 295
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_transaction_begin",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/segment.c",
          "lines": "180-210",
          "snippet": "int nilfs_transaction_begin(struct super_block *sb,\n\t\t\t    struct nilfs_transaction_info *ti,\n\t\t\t    int vacancy_check)\n{\n\tstruct the_nilfs *nilfs;\n\tint ret = nilfs_prepare_segment_lock(ti);\n\n\tif (unlikely(ret < 0))\n\t\treturn ret;\n\tif (ret > 0)\n\t\treturn 0;\n\n\tsb_start_intwrite(sb);\n\n\tnilfs = sb->s_fs_info;\n\tdown_read(&nilfs->ns_segctor_sem);\n\tif (vacancy_check && nilfs_near_disk_full(nilfs)) {\n\t\tup_read(&nilfs->ns_segctor_sem);\n\t\tret = -ENOSPC;\n\t\tgoto failed;\n\t}\n\treturn 0;\n\n failed:\n\tti = current->journal_info;\n\tcurrent->journal_info = ti->ti_save;\n\tif (ti->ti_flags & NILFS_TI_DYNAMIC_ALLOC)\n\t\tkmem_cache_free(nilfs_transaction_cachep, ti);\n\tsb_end_intwrite(sb);\n\treturn ret;\n}",
          "includes": [
            "#include \"segbuf.h\"",
            "#include \"ifile.h\"",
            "#include \"cpfile.h\"",
            "#include \"sufile.h\"",
            "#include \"segment.h\"",
            "#include \"page.h\"",
            "#include \"btnode.h\"",
            "#include \"nilfs.h\"",
            "#include <linux/slab.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/crc32.h>",
            "#include <linux/kthread.h>",
            "#include <linux/freezer.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/completion.h>",
            "#include <linux/bio.h>",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"segbuf.h\"\n#include \"ifile.h\"\n#include \"cpfile.h\"\n#include \"sufile.h\"\n#include \"segment.h\"\n#include \"page.h\"\n#include \"btnode.h\"\n#include \"nilfs.h\"\n#include <linux/slab.h>\n#include <linux/pagevec.h>\n#include <linux/crc32.h>\n#include <linux/kthread.h>\n#include <linux/freezer.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/completion.h>\n#include <linux/bio.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n\nint nilfs_transaction_begin(struct super_block *sb,\n\t\t\t    struct nilfs_transaction_info *ti,\n\t\t\t    int vacancy_check)\n{\n\tstruct the_nilfs *nilfs;\n\tint ret = nilfs_prepare_segment_lock(ti);\n\n\tif (unlikely(ret < 0))\n\t\treturn ret;\n\tif (ret > 0)\n\t\treturn 0;\n\n\tsb_start_intwrite(sb);\n\n\tnilfs = sb->s_fs_info;\n\tdown_read(&nilfs->ns_segctor_sem);\n\tif (vacancy_check && nilfs_near_disk_full(nilfs)) {\n\t\tup_read(&nilfs->ns_segctor_sem);\n\t\tret = -ENOSPC;\n\t\tgoto failed;\n\t}\n\treturn 0;\n\n failed:\n\tti = current->journal_info;\n\tcurrent->journal_info = ti->ti_save;\n\tif (ti->ti_flags & NILFS_TI_DYNAMIC_ALLOC)\n\t\tkmem_cache_free(nilfs_transaction_cachep, ti);\n\tsb_end_intwrite(sb);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "copy_from_user",
          "args": [
            "&cno",
            "argp",
            "sizeof(cno)"
          ],
          "line": 292
        },
        "resolved": true,
        "details": {
          "function_name": "exact_copy_from_user",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namespace.c",
          "lines": "2514-2534",
          "snippet": "static long exact_copy_from_user(void *to, const void __user * from,\n\t\t\t\t unsigned long n)\n{\n\tchar *t = to;\n\tconst char __user *f = from;\n\tchar c;\n\n\tif (!access_ok(VERIFY_READ, from, n))\n\t\treturn n;\n\n\twhile (n) {\n\t\tif (__get_user(c, f)) {\n\t\t\tmemset(t, 0, n);\n\t\t\tbreak;\n\t\t}\n\t\t*t++ = c;\n\t\tf++;\n\t\tn--;\n\t}\n\treturn n;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"pnode.h\"",
            "#include <linux/task_work.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/magic.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
            "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
            "#include <linux/init.h>\t\t/* init_rootfs */",
            "#include <linux/idr.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/mnt_namespace.h>",
            "#include <linux/capability.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/task_work.h>\n#include <linux/bootmem.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic long exact_copy_from_user(void *to, const void __user * from,\n\t\t\t\t unsigned long n)\n{\n\tchar *t = to;\n\tconst char __user *f = from;\n\tchar c;\n\n\tif (!access_ok(VERIFY_READ, from, n))\n\t\treturn n;\n\n\twhile (n) {\n\t\tif (__get_user(c, f)) {\n\t\t\tmemset(t, 0, n);\n\t\t\tbreak;\n\t\t}\n\t\t*t++ = c;\n\t\tf++;\n\t\tn--;\n\t}\n\treturn n;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mnt_want_write_file",
          "args": [
            "filp"
          ],
          "line": 287
        },
        "resolved": true,
        "details": {
          "function_name": "mnt_want_write_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namespace.c",
          "lines": "440-449",
          "snippet": "int mnt_want_write_file(struct file *file)\n{\n\tint ret;\n\n\tsb_start_write(file->f_path.mnt->mnt_sb);\n\tret = __mnt_want_write_file(file);\n\tif (ret)\n\t\tsb_end_write(file->f_path.mnt->mnt_sb);\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"pnode.h\"",
            "#include <linux/task_work.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/magic.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
            "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
            "#include <linux/init.h>\t\t/* init_rootfs */",
            "#include <linux/idr.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/mnt_namespace.h>",
            "#include <linux/capability.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void shrink_submounts(struct mount *mnt);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/task_work.h>\n#include <linux/bootmem.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic void shrink_submounts(struct mount *mnt);\n\nint mnt_want_write_file(struct file *file)\n{\n\tint ret;\n\n\tsb_start_write(file->f_path.mnt->mnt_sb);\n\tret = __mnt_want_write_file(file);\n\tif (ret)\n\t\tsb_end_write(file->f_path.mnt->mnt_sb);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "capable",
          "args": [
            "CAP_SYS_ADMIN"
          ],
          "line": 284
        },
        "resolved": true,
        "details": {
          "function_name": "inode_owner_or_capable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "1901-1912",
          "snippet": "bool inode_owner_or_capable(const struct inode *inode)\n{\n\tstruct user_namespace *ns;\n\n\tif (uid_eq(current_fsuid(), inode->i_uid))\n\t\treturn true;\n\n\tns = current_user_ns();\n\tif (ns_capable(ns, CAP_FOWNER) && kuid_has_mapping(ns, inode->i_uid))\n\t\treturn true;\n\treturn false;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nbool inode_owner_or_capable(const struct inode *inode)\n{\n\tstruct user_namespace *ns;\n\n\tif (uid_eq(current_fsuid(), inode->i_uid))\n\t\treturn true;\n\n\tns = current_user_ns();\n\tif (ns_capable(ns, CAP_FOWNER) && kuid_has_mapping(ns, inode->i_uid))\n\t\treturn true;\n\treturn false;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"dat.h\"\n#include \"sufile.h\"\n#include \"cpfile.h\"\n#include \"bmap.h\"\n#include \"segment.h\"\n#include \"nilfs.h\"\n#include <linux/nilfs2_fs.h>\n#include <linux/buffer_head.h>\n#include <linux/mount.h>\t/* mnt_want_write_file(), mnt_drop_write_file() */\n#include <linux/compat.h>\t/* compat_ptr() */\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\t/* copy_from_user(), copy_to_user() */\n#include <linux/capability.h>\t/* capable() */\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/fs.h>\n\nstatic int\nnilfs_ioctl_delete_checkpoint(struct inode *inode, struct file *filp,\n\t\t\t      unsigned int cmd, void __user *argp)\n{\n\tstruct the_nilfs *nilfs = inode->i_sb->s_fs_info;\n\tstruct nilfs_transaction_info ti;\n\t__u64 cno;\n\tint ret;\n\n\tif (!capable(CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\n\tret = mnt_want_write_file(filp);\n\tif (ret)\n\t\treturn ret;\n\n\tret = -EFAULT;\n\tif (copy_from_user(&cno, argp, sizeof(cno)))\n\t\tgoto out;\n\n\tnilfs_transaction_begin(inode->i_sb, &ti, 0);\n\tret = nilfs_cpfile_delete_checkpoint(nilfs->ns_cpfile, cno);\n\tif (unlikely(ret < 0))\n\t\tnilfs_transaction_abort(inode->i_sb);\n\telse\n\t\tnilfs_transaction_commit(inode->i_sb); /* never fails */\nout:\n\tmnt_drop_write_file(filp);\n\treturn ret;\n}"
  },
  {
    "function_name": "nilfs_ioctl_change_cpmode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/ioctl.c",
    "lines": "221-254",
    "snippet": "static int nilfs_ioctl_change_cpmode(struct inode *inode, struct file *filp,\n\t\t\t\t     unsigned int cmd, void __user *argp)\n{\n\tstruct the_nilfs *nilfs = inode->i_sb->s_fs_info;\n\tstruct nilfs_transaction_info ti;\n\tstruct nilfs_cpmode cpmode;\n\tint ret;\n\n\tif (!capable(CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\n\tret = mnt_want_write_file(filp);\n\tif (ret)\n\t\treturn ret;\n\n\tret = -EFAULT;\n\tif (copy_from_user(&cpmode, argp, sizeof(cpmode)))\n\t\tgoto out;\n\n\tmutex_lock(&nilfs->ns_snapshot_mount_mutex);\n\n\tnilfs_transaction_begin(inode->i_sb, &ti, 0);\n\tret = nilfs_cpfile_change_cpmode(\n\t\tnilfs->ns_cpfile, cpmode.cm_cno, cpmode.cm_mode);\n\tif (unlikely(ret < 0))\n\t\tnilfs_transaction_abort(inode->i_sb);\n\telse\n\t\tnilfs_transaction_commit(inode->i_sb); /* never fails */\n\n\tmutex_unlock(&nilfs->ns_snapshot_mount_mutex);\nout:\n\tmnt_drop_write_file(filp);\n\treturn ret;\n}",
    "includes": [
      "#include \"dat.h\"",
      "#include \"sufile.h\"",
      "#include \"cpfile.h\"",
      "#include \"bmap.h\"",
      "#include \"segment.h\"",
      "#include \"nilfs.h\"",
      "#include <linux/nilfs2_fs.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/mount.h>\t/* mnt_want_write_file(), mnt_drop_write_file() */",
      "#include <linux/compat.h>\t/* compat_ptr() */",
      "#include <linux/vmalloc.h>",
      "#include <linux/uaccess.h>\t/* copy_from_user(), copy_to_user() */",
      "#include <linux/capability.h>\t/* capable() */",
      "#include <linux/slab.h>",
      "#include <linux/wait.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mnt_drop_write_file",
          "args": [
            "filp"
          ],
          "line": 252
        },
        "resolved": true,
        "details": {
          "function_name": "mnt_drop_write_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namespace.c",
          "lines": "487-490",
          "snippet": "void mnt_drop_write_file(struct file *file)\n{\n\tmnt_drop_write(file->f_path.mnt);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"pnode.h\"",
            "#include <linux/task_work.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/magic.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
            "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
            "#include <linux/init.h>\t\t/* init_rootfs */",
            "#include <linux/idr.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/mnt_namespace.h>",
            "#include <linux/capability.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void shrink_submounts(struct mount *mnt);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/task_work.h>\n#include <linux/bootmem.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic void shrink_submounts(struct mount *mnt);\n\nvoid mnt_drop_write_file(struct file *file)\n{\n\tmnt_drop_write(file->f_path.mnt);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&nilfs->ns_snapshot_mount_mutex"
          ],
          "line": 250
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nilfs_transaction_commit",
          "args": [
            "inode->i_sb"
          ],
          "line": 248
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_transaction_commit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/segment.c",
          "lines": "223-252",
          "snippet": "int nilfs_transaction_commit(struct super_block *sb)\n{\n\tstruct nilfs_transaction_info *ti = current->journal_info;\n\tstruct the_nilfs *nilfs = sb->s_fs_info;\n\tint err = 0;\n\n\tBUG_ON(ti == NULL || ti->ti_magic != NILFS_TI_MAGIC);\n\tti->ti_flags |= NILFS_TI_COMMIT;\n\tif (ti->ti_count > 0) {\n\t\tti->ti_count--;\n\t\treturn 0;\n\t}\n\tif (nilfs->ns_writer) {\n\t\tstruct nilfs_sc_info *sci = nilfs->ns_writer;\n\n\t\tif (ti->ti_flags & NILFS_TI_COMMIT)\n\t\t\tnilfs_segctor_start_timer(sci);\n\t\tif (atomic_read(&nilfs->ns_ndirtyblks) > sci->sc_watermark)\n\t\t\tnilfs_segctor_do_flush(sci, 0);\n\t}\n\tup_read(&nilfs->ns_segctor_sem);\n\tcurrent->journal_info = ti->ti_save;\n\n\tif (ti->ti_flags & NILFS_TI_SYNC)\n\t\terr = nilfs_construct_segment(sb);\n\tif (ti->ti_flags & NILFS_TI_DYNAMIC_ALLOC)\n\t\tkmem_cache_free(nilfs_transaction_cachep, ti);\n\tsb_end_intwrite(sb);\n\treturn err;\n}",
          "includes": [
            "#include \"segbuf.h\"",
            "#include \"ifile.h\"",
            "#include \"cpfile.h\"",
            "#include \"sufile.h\"",
            "#include \"segment.h\"",
            "#include \"page.h\"",
            "#include \"btnode.h\"",
            "#include \"nilfs.h\"",
            "#include <linux/slab.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/crc32.h>",
            "#include <linux/kthread.h>",
            "#include <linux/freezer.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/completion.h>",
            "#include <linux/bio.h>",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void nilfs_segctor_start_timer(struct nilfs_sc_info *);",
            "static void nilfs_segctor_do_flush(struct nilfs_sc_info *, int);",
            "static void nilfs_segctor_do_immediate_flush(struct nilfs_sc_info *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"segbuf.h\"\n#include \"ifile.h\"\n#include \"cpfile.h\"\n#include \"sufile.h\"\n#include \"segment.h\"\n#include \"page.h\"\n#include \"btnode.h\"\n#include \"nilfs.h\"\n#include <linux/slab.h>\n#include <linux/pagevec.h>\n#include <linux/crc32.h>\n#include <linux/kthread.h>\n#include <linux/freezer.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/completion.h>\n#include <linux/bio.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n\nstatic void nilfs_segctor_start_timer(struct nilfs_sc_info *);\nstatic void nilfs_segctor_do_flush(struct nilfs_sc_info *, int);\nstatic void nilfs_segctor_do_immediate_flush(struct nilfs_sc_info *);\n\nint nilfs_transaction_commit(struct super_block *sb)\n{\n\tstruct nilfs_transaction_info *ti = current->journal_info;\n\tstruct the_nilfs *nilfs = sb->s_fs_info;\n\tint err = 0;\n\n\tBUG_ON(ti == NULL || ti->ti_magic != NILFS_TI_MAGIC);\n\tti->ti_flags |= NILFS_TI_COMMIT;\n\tif (ti->ti_count > 0) {\n\t\tti->ti_count--;\n\t\treturn 0;\n\t}\n\tif (nilfs->ns_writer) {\n\t\tstruct nilfs_sc_info *sci = nilfs->ns_writer;\n\n\t\tif (ti->ti_flags & NILFS_TI_COMMIT)\n\t\t\tnilfs_segctor_start_timer(sci);\n\t\tif (atomic_read(&nilfs->ns_ndirtyblks) > sci->sc_watermark)\n\t\t\tnilfs_segctor_do_flush(sci, 0);\n\t}\n\tup_read(&nilfs->ns_segctor_sem);\n\tcurrent->journal_info = ti->ti_save;\n\n\tif (ti->ti_flags & NILFS_TI_SYNC)\n\t\terr = nilfs_construct_segment(sb);\n\tif (ti->ti_flags & NILFS_TI_DYNAMIC_ALLOC)\n\t\tkmem_cache_free(nilfs_transaction_cachep, ti);\n\tsb_end_intwrite(sb);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nilfs_transaction_abort",
          "args": [
            "inode->i_sb"
          ],
          "line": 246
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_transaction_abort",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/segment.c",
          "lines": "254-270",
          "snippet": "void nilfs_transaction_abort(struct super_block *sb)\n{\n\tstruct nilfs_transaction_info *ti = current->journal_info;\n\tstruct the_nilfs *nilfs = sb->s_fs_info;\n\n\tBUG_ON(ti == NULL || ti->ti_magic != NILFS_TI_MAGIC);\n\tif (ti->ti_count > 0) {\n\t\tti->ti_count--;\n\t\treturn;\n\t}\n\tup_read(&nilfs->ns_segctor_sem);\n\n\tcurrent->journal_info = ti->ti_save;\n\tif (ti->ti_flags & NILFS_TI_DYNAMIC_ALLOC)\n\t\tkmem_cache_free(nilfs_transaction_cachep, ti);\n\tsb_end_intwrite(sb);\n}",
          "includes": [
            "#include \"segbuf.h\"",
            "#include \"ifile.h\"",
            "#include \"cpfile.h\"",
            "#include \"sufile.h\"",
            "#include \"segment.h\"",
            "#include \"page.h\"",
            "#include \"btnode.h\"",
            "#include \"nilfs.h\"",
            "#include <linux/slab.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/crc32.h>",
            "#include <linux/kthread.h>",
            "#include <linux/freezer.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/completion.h>",
            "#include <linux/bio.h>",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"segbuf.h\"\n#include \"ifile.h\"\n#include \"cpfile.h\"\n#include \"sufile.h\"\n#include \"segment.h\"\n#include \"page.h\"\n#include \"btnode.h\"\n#include \"nilfs.h\"\n#include <linux/slab.h>\n#include <linux/pagevec.h>\n#include <linux/crc32.h>\n#include <linux/kthread.h>\n#include <linux/freezer.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/completion.h>\n#include <linux/bio.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n\nvoid nilfs_transaction_abort(struct super_block *sb)\n{\n\tstruct nilfs_transaction_info *ti = current->journal_info;\n\tstruct the_nilfs *nilfs = sb->s_fs_info;\n\n\tBUG_ON(ti == NULL || ti->ti_magic != NILFS_TI_MAGIC);\n\tif (ti->ti_count > 0) {\n\t\tti->ti_count--;\n\t\treturn;\n\t}\n\tup_read(&nilfs->ns_segctor_sem);\n\n\tcurrent->journal_info = ti->ti_save;\n\tif (ti->ti_flags & NILFS_TI_DYNAMIC_ALLOC)\n\t\tkmem_cache_free(nilfs_transaction_cachep, ti);\n\tsb_end_intwrite(sb);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "ret < 0"
          ],
          "line": 245
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nilfs_cpfile_change_cpmode",
          "args": [
            "nilfs->ns_cpfile",
            "cpmode.cm_cno",
            "cpmode.cm_mode"
          ],
          "line": 243
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_cpfile_change_cpmode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/cpfile.c",
          "lines": "868-890",
          "snippet": "int nilfs_cpfile_change_cpmode(struct inode *cpfile, __u64 cno, int mode)\n{\n\tint ret;\n\n\tswitch (mode) {\n\tcase NILFS_CHECKPOINT:\n\t\tif (nilfs_checkpoint_is_mounted(cpfile->i_sb, cno))\n\t\t\t/*\n\t\t\t * Current implementation does not have to protect\n\t\t\t * plain read-only mounts since they are exclusive\n\t\t\t * with a read/write mount and are protected from the\n\t\t\t * cleaner.\n\t\t\t */\n\t\t\tret = -EBUSY;\n\t\telse\n\t\t\tret = nilfs_cpfile_clear_snapshot(cpfile, cno);\n\t\treturn ret;\n\tcase NILFS_SNAPSHOT:\n\t\treturn nilfs_cpfile_set_snapshot(cpfile, cno);\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}",
          "includes": [
            "#include \"cpfile.h\"",
            "#include \"mdt.h\"",
            "#include <linux/nilfs2_fs.h>",
            "#include <linux/errno.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/fs.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cpfile.h\"\n#include \"mdt.h\"\n#include <linux/nilfs2_fs.h>\n#include <linux/errno.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/fs.h>\n#include <linux/kernel.h>\n\nint nilfs_cpfile_change_cpmode(struct inode *cpfile, __u64 cno, int mode)\n{\n\tint ret;\n\n\tswitch (mode) {\n\tcase NILFS_CHECKPOINT:\n\t\tif (nilfs_checkpoint_is_mounted(cpfile->i_sb, cno))\n\t\t\t/*\n\t\t\t * Current implementation does not have to protect\n\t\t\t * plain read-only mounts since they are exclusive\n\t\t\t * with a read/write mount and are protected from the\n\t\t\t * cleaner.\n\t\t\t */\n\t\t\tret = -EBUSY;\n\t\telse\n\t\t\tret = nilfs_cpfile_clear_snapshot(cpfile, cno);\n\t\treturn ret;\n\tcase NILFS_SNAPSHOT:\n\t\treturn nilfs_cpfile_set_snapshot(cpfile, cno);\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "nilfs_transaction_begin",
          "args": [
            "inode->i_sb",
            "&ti",
            "0"
          ],
          "line": 242
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_transaction_begin",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/segment.c",
          "lines": "180-210",
          "snippet": "int nilfs_transaction_begin(struct super_block *sb,\n\t\t\t    struct nilfs_transaction_info *ti,\n\t\t\t    int vacancy_check)\n{\n\tstruct the_nilfs *nilfs;\n\tint ret = nilfs_prepare_segment_lock(ti);\n\n\tif (unlikely(ret < 0))\n\t\treturn ret;\n\tif (ret > 0)\n\t\treturn 0;\n\n\tsb_start_intwrite(sb);\n\n\tnilfs = sb->s_fs_info;\n\tdown_read(&nilfs->ns_segctor_sem);\n\tif (vacancy_check && nilfs_near_disk_full(nilfs)) {\n\t\tup_read(&nilfs->ns_segctor_sem);\n\t\tret = -ENOSPC;\n\t\tgoto failed;\n\t}\n\treturn 0;\n\n failed:\n\tti = current->journal_info;\n\tcurrent->journal_info = ti->ti_save;\n\tif (ti->ti_flags & NILFS_TI_DYNAMIC_ALLOC)\n\t\tkmem_cache_free(nilfs_transaction_cachep, ti);\n\tsb_end_intwrite(sb);\n\treturn ret;\n}",
          "includes": [
            "#include \"segbuf.h\"",
            "#include \"ifile.h\"",
            "#include \"cpfile.h\"",
            "#include \"sufile.h\"",
            "#include \"segment.h\"",
            "#include \"page.h\"",
            "#include \"btnode.h\"",
            "#include \"nilfs.h\"",
            "#include <linux/slab.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/crc32.h>",
            "#include <linux/kthread.h>",
            "#include <linux/freezer.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/completion.h>",
            "#include <linux/bio.h>",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"segbuf.h\"\n#include \"ifile.h\"\n#include \"cpfile.h\"\n#include \"sufile.h\"\n#include \"segment.h\"\n#include \"page.h\"\n#include \"btnode.h\"\n#include \"nilfs.h\"\n#include <linux/slab.h>\n#include <linux/pagevec.h>\n#include <linux/crc32.h>\n#include <linux/kthread.h>\n#include <linux/freezer.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/completion.h>\n#include <linux/bio.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n\nint nilfs_transaction_begin(struct super_block *sb,\n\t\t\t    struct nilfs_transaction_info *ti,\n\t\t\t    int vacancy_check)\n{\n\tstruct the_nilfs *nilfs;\n\tint ret = nilfs_prepare_segment_lock(ti);\n\n\tif (unlikely(ret < 0))\n\t\treturn ret;\n\tif (ret > 0)\n\t\treturn 0;\n\n\tsb_start_intwrite(sb);\n\n\tnilfs = sb->s_fs_info;\n\tdown_read(&nilfs->ns_segctor_sem);\n\tif (vacancy_check && nilfs_near_disk_full(nilfs)) {\n\t\tup_read(&nilfs->ns_segctor_sem);\n\t\tret = -ENOSPC;\n\t\tgoto failed;\n\t}\n\treturn 0;\n\n failed:\n\tti = current->journal_info;\n\tcurrent->journal_info = ti->ti_save;\n\tif (ti->ti_flags & NILFS_TI_DYNAMIC_ALLOC)\n\t\tkmem_cache_free(nilfs_transaction_cachep, ti);\n\tsb_end_intwrite(sb);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&nilfs->ns_snapshot_mount_mutex"
          ],
          "line": 240
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "copy_from_user",
          "args": [
            "&cpmode",
            "argp",
            "sizeof(cpmode)"
          ],
          "line": 237
        },
        "resolved": true,
        "details": {
          "function_name": "exact_copy_from_user",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namespace.c",
          "lines": "2514-2534",
          "snippet": "static long exact_copy_from_user(void *to, const void __user * from,\n\t\t\t\t unsigned long n)\n{\n\tchar *t = to;\n\tconst char __user *f = from;\n\tchar c;\n\n\tif (!access_ok(VERIFY_READ, from, n))\n\t\treturn n;\n\n\twhile (n) {\n\t\tif (__get_user(c, f)) {\n\t\t\tmemset(t, 0, n);\n\t\t\tbreak;\n\t\t}\n\t\t*t++ = c;\n\t\tf++;\n\t\tn--;\n\t}\n\treturn n;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"pnode.h\"",
            "#include <linux/task_work.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/magic.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
            "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
            "#include <linux/init.h>\t\t/* init_rootfs */",
            "#include <linux/idr.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/mnt_namespace.h>",
            "#include <linux/capability.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/task_work.h>\n#include <linux/bootmem.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic long exact_copy_from_user(void *to, const void __user * from,\n\t\t\t\t unsigned long n)\n{\n\tchar *t = to;\n\tconst char __user *f = from;\n\tchar c;\n\n\tif (!access_ok(VERIFY_READ, from, n))\n\t\treturn n;\n\n\twhile (n) {\n\t\tif (__get_user(c, f)) {\n\t\t\tmemset(t, 0, n);\n\t\t\tbreak;\n\t\t}\n\t\t*t++ = c;\n\t\tf++;\n\t\tn--;\n\t}\n\treturn n;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mnt_want_write_file",
          "args": [
            "filp"
          ],
          "line": 232
        },
        "resolved": true,
        "details": {
          "function_name": "mnt_want_write_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namespace.c",
          "lines": "440-449",
          "snippet": "int mnt_want_write_file(struct file *file)\n{\n\tint ret;\n\n\tsb_start_write(file->f_path.mnt->mnt_sb);\n\tret = __mnt_want_write_file(file);\n\tif (ret)\n\t\tsb_end_write(file->f_path.mnt->mnt_sb);\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"pnode.h\"",
            "#include <linux/task_work.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/magic.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
            "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
            "#include <linux/init.h>\t\t/* init_rootfs */",
            "#include <linux/idr.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/mnt_namespace.h>",
            "#include <linux/capability.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void shrink_submounts(struct mount *mnt);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/task_work.h>\n#include <linux/bootmem.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic void shrink_submounts(struct mount *mnt);\n\nint mnt_want_write_file(struct file *file)\n{\n\tint ret;\n\n\tsb_start_write(file->f_path.mnt->mnt_sb);\n\tret = __mnt_want_write_file(file);\n\tif (ret)\n\t\tsb_end_write(file->f_path.mnt->mnt_sb);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "capable",
          "args": [
            "CAP_SYS_ADMIN"
          ],
          "line": 229
        },
        "resolved": true,
        "details": {
          "function_name": "inode_owner_or_capable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "1901-1912",
          "snippet": "bool inode_owner_or_capable(const struct inode *inode)\n{\n\tstruct user_namespace *ns;\n\n\tif (uid_eq(current_fsuid(), inode->i_uid))\n\t\treturn true;\n\n\tns = current_user_ns();\n\tif (ns_capable(ns, CAP_FOWNER) && kuid_has_mapping(ns, inode->i_uid))\n\t\treturn true;\n\treturn false;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nbool inode_owner_or_capable(const struct inode *inode)\n{\n\tstruct user_namespace *ns;\n\n\tif (uid_eq(current_fsuid(), inode->i_uid))\n\t\treturn true;\n\n\tns = current_user_ns();\n\tif (ns_capable(ns, CAP_FOWNER) && kuid_has_mapping(ns, inode->i_uid))\n\t\treturn true;\n\treturn false;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"dat.h\"\n#include \"sufile.h\"\n#include \"cpfile.h\"\n#include \"bmap.h\"\n#include \"segment.h\"\n#include \"nilfs.h\"\n#include <linux/nilfs2_fs.h>\n#include <linux/buffer_head.h>\n#include <linux/mount.h>\t/* mnt_want_write_file(), mnt_drop_write_file() */\n#include <linux/compat.h>\t/* compat_ptr() */\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\t/* copy_from_user(), copy_to_user() */\n#include <linux/capability.h>\t/* capable() */\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/fs.h>\n\nstatic int nilfs_ioctl_change_cpmode(struct inode *inode, struct file *filp,\n\t\t\t\t     unsigned int cmd, void __user *argp)\n{\n\tstruct the_nilfs *nilfs = inode->i_sb->s_fs_info;\n\tstruct nilfs_transaction_info ti;\n\tstruct nilfs_cpmode cpmode;\n\tint ret;\n\n\tif (!capable(CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\n\tret = mnt_want_write_file(filp);\n\tif (ret)\n\t\treturn ret;\n\n\tret = -EFAULT;\n\tif (copy_from_user(&cpmode, argp, sizeof(cpmode)))\n\t\tgoto out;\n\n\tmutex_lock(&nilfs->ns_snapshot_mount_mutex);\n\n\tnilfs_transaction_begin(inode->i_sb, &ti, 0);\n\tret = nilfs_cpfile_change_cpmode(\n\t\tnilfs->ns_cpfile, cpmode.cm_cno, cpmode.cm_mode);\n\tif (unlikely(ret < 0))\n\t\tnilfs_transaction_abort(inode->i_sb);\n\telse\n\t\tnilfs_transaction_commit(inode->i_sb); /* never fails */\n\n\tmutex_unlock(&nilfs->ns_snapshot_mount_mutex);\nout:\n\tmnt_drop_write_file(filp);\n\treturn ret;\n}"
  },
  {
    "function_name": "nilfs_ioctl_getversion",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/ioctl.c",
    "lines": "197-200",
    "snippet": "static int nilfs_ioctl_getversion(struct inode *inode, void __user *argp)\n{\n\treturn put_user(inode->i_generation, (int __user *)argp);\n}",
    "includes": [
      "#include \"dat.h\"",
      "#include \"sufile.h\"",
      "#include \"cpfile.h\"",
      "#include \"bmap.h\"",
      "#include \"segment.h\"",
      "#include \"nilfs.h\"",
      "#include <linux/nilfs2_fs.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/mount.h>\t/* mnt_want_write_file(), mnt_drop_write_file() */",
      "#include <linux/compat.h>\t/* compat_ptr() */",
      "#include <linux/vmalloc.h>",
      "#include <linux/uaccess.h>\t/* copy_from_user(), copy_to_user() */",
      "#include <linux/capability.h>\t/* capable() */",
      "#include <linux/slab.h>",
      "#include <linux/wait.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "put_user",
          "args": [
            "inode->i_generation",
            "(int __user *)argp"
          ],
          "line": 199
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"dat.h\"\n#include \"sufile.h\"\n#include \"cpfile.h\"\n#include \"bmap.h\"\n#include \"segment.h\"\n#include \"nilfs.h\"\n#include <linux/nilfs2_fs.h>\n#include <linux/buffer_head.h>\n#include <linux/mount.h>\t/* mnt_want_write_file(), mnt_drop_write_file() */\n#include <linux/compat.h>\t/* compat_ptr() */\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\t/* copy_from_user(), copy_to_user() */\n#include <linux/capability.h>\t/* capable() */\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/fs.h>\n\nstatic int nilfs_ioctl_getversion(struct inode *inode, void __user *argp)\n{\n\treturn put_user(inode->i_generation, (int __user *)argp);\n}"
  },
  {
    "function_name": "nilfs_ioctl_setflags",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/ioctl.c",
    "lines": "142-192",
    "snippet": "static int nilfs_ioctl_setflags(struct inode *inode, struct file *filp,\n\t\t\t\tvoid __user *argp)\n{\n\tstruct nilfs_transaction_info ti;\n\tunsigned int flags, oldflags;\n\tint ret;\n\n\tif (!inode_owner_or_capable(inode))\n\t\treturn -EACCES;\n\n\tif (get_user(flags, (int __user *)argp))\n\t\treturn -EFAULT;\n\n\tret = mnt_want_write_file(filp);\n\tif (ret)\n\t\treturn ret;\n\n\tflags = nilfs_mask_flags(inode->i_mode, flags);\n\n\tmutex_lock(&inode->i_mutex);\n\n\toldflags = NILFS_I(inode)->i_flags;\n\n\t/*\n\t * The IMMUTABLE and APPEND_ONLY flags can only be changed by the\n\t * relevant capability.\n\t */\n\tret = -EPERM;\n\tif (((flags ^ oldflags) & (FS_APPEND_FL | FS_IMMUTABLE_FL)) &&\n\t    !capable(CAP_LINUX_IMMUTABLE))\n\t\tgoto out;\n\n\tret = nilfs_transaction_begin(inode->i_sb, &ti, 0);\n\tif (ret)\n\t\tgoto out;\n\n\tNILFS_I(inode)->i_flags = (oldflags & ~FS_FL_USER_MODIFIABLE) |\n\t\t(flags & FS_FL_USER_MODIFIABLE);\n\n\tnilfs_set_inode_flags(inode);\n\tinode->i_ctime = CURRENT_TIME;\n\tif (IS_SYNC(inode))\n\t\tnilfs_set_transaction_flag(NILFS_TI_SYNC);\n\n\tnilfs_mark_inode_dirty(inode);\n\tret = nilfs_transaction_commit(inode->i_sb);\nout:\n\tmutex_unlock(&inode->i_mutex);\n\tmnt_drop_write_file(filp);\n\treturn ret;\n}",
    "includes": [
      "#include \"dat.h\"",
      "#include \"sufile.h\"",
      "#include \"cpfile.h\"",
      "#include \"bmap.h\"",
      "#include \"segment.h\"",
      "#include \"nilfs.h\"",
      "#include <linux/nilfs2_fs.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/mount.h>\t/* mnt_want_write_file(), mnt_drop_write_file() */",
      "#include <linux/compat.h>\t/* compat_ptr() */",
      "#include <linux/vmalloc.h>",
      "#include <linux/uaccess.h>\t/* copy_from_user(), copy_to_user() */",
      "#include <linux/capability.h>\t/* capable() */",
      "#include <linux/slab.h>",
      "#include <linux/wait.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mnt_drop_write_file",
          "args": [
            "filp"
          ],
          "line": 190
        },
        "resolved": true,
        "details": {
          "function_name": "mnt_drop_write_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namespace.c",
          "lines": "487-490",
          "snippet": "void mnt_drop_write_file(struct file *file)\n{\n\tmnt_drop_write(file->f_path.mnt);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"pnode.h\"",
            "#include <linux/task_work.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/magic.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
            "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
            "#include <linux/init.h>\t\t/* init_rootfs */",
            "#include <linux/idr.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/mnt_namespace.h>",
            "#include <linux/capability.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void shrink_submounts(struct mount *mnt);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/task_work.h>\n#include <linux/bootmem.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic void shrink_submounts(struct mount *mnt);\n\nvoid mnt_drop_write_file(struct file *file)\n{\n\tmnt_drop_write(file->f_path.mnt);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&inode->i_mutex"
          ],
          "line": 189
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nilfs_transaction_commit",
          "args": [
            "inode->i_sb"
          ],
          "line": 187
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_transaction_commit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/segment.c",
          "lines": "223-252",
          "snippet": "int nilfs_transaction_commit(struct super_block *sb)\n{\n\tstruct nilfs_transaction_info *ti = current->journal_info;\n\tstruct the_nilfs *nilfs = sb->s_fs_info;\n\tint err = 0;\n\n\tBUG_ON(ti == NULL || ti->ti_magic != NILFS_TI_MAGIC);\n\tti->ti_flags |= NILFS_TI_COMMIT;\n\tif (ti->ti_count > 0) {\n\t\tti->ti_count--;\n\t\treturn 0;\n\t}\n\tif (nilfs->ns_writer) {\n\t\tstruct nilfs_sc_info *sci = nilfs->ns_writer;\n\n\t\tif (ti->ti_flags & NILFS_TI_COMMIT)\n\t\t\tnilfs_segctor_start_timer(sci);\n\t\tif (atomic_read(&nilfs->ns_ndirtyblks) > sci->sc_watermark)\n\t\t\tnilfs_segctor_do_flush(sci, 0);\n\t}\n\tup_read(&nilfs->ns_segctor_sem);\n\tcurrent->journal_info = ti->ti_save;\n\n\tif (ti->ti_flags & NILFS_TI_SYNC)\n\t\terr = nilfs_construct_segment(sb);\n\tif (ti->ti_flags & NILFS_TI_DYNAMIC_ALLOC)\n\t\tkmem_cache_free(nilfs_transaction_cachep, ti);\n\tsb_end_intwrite(sb);\n\treturn err;\n}",
          "includes": [
            "#include \"segbuf.h\"",
            "#include \"ifile.h\"",
            "#include \"cpfile.h\"",
            "#include \"sufile.h\"",
            "#include \"segment.h\"",
            "#include \"page.h\"",
            "#include \"btnode.h\"",
            "#include \"nilfs.h\"",
            "#include <linux/slab.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/crc32.h>",
            "#include <linux/kthread.h>",
            "#include <linux/freezer.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/completion.h>",
            "#include <linux/bio.h>",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void nilfs_segctor_start_timer(struct nilfs_sc_info *);",
            "static void nilfs_segctor_do_flush(struct nilfs_sc_info *, int);",
            "static void nilfs_segctor_do_immediate_flush(struct nilfs_sc_info *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"segbuf.h\"\n#include \"ifile.h\"\n#include \"cpfile.h\"\n#include \"sufile.h\"\n#include \"segment.h\"\n#include \"page.h\"\n#include \"btnode.h\"\n#include \"nilfs.h\"\n#include <linux/slab.h>\n#include <linux/pagevec.h>\n#include <linux/crc32.h>\n#include <linux/kthread.h>\n#include <linux/freezer.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/completion.h>\n#include <linux/bio.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n\nstatic void nilfs_segctor_start_timer(struct nilfs_sc_info *);\nstatic void nilfs_segctor_do_flush(struct nilfs_sc_info *, int);\nstatic void nilfs_segctor_do_immediate_flush(struct nilfs_sc_info *);\n\nint nilfs_transaction_commit(struct super_block *sb)\n{\n\tstruct nilfs_transaction_info *ti = current->journal_info;\n\tstruct the_nilfs *nilfs = sb->s_fs_info;\n\tint err = 0;\n\n\tBUG_ON(ti == NULL || ti->ti_magic != NILFS_TI_MAGIC);\n\tti->ti_flags |= NILFS_TI_COMMIT;\n\tif (ti->ti_count > 0) {\n\t\tti->ti_count--;\n\t\treturn 0;\n\t}\n\tif (nilfs->ns_writer) {\n\t\tstruct nilfs_sc_info *sci = nilfs->ns_writer;\n\n\t\tif (ti->ti_flags & NILFS_TI_COMMIT)\n\t\t\tnilfs_segctor_start_timer(sci);\n\t\tif (atomic_read(&nilfs->ns_ndirtyblks) > sci->sc_watermark)\n\t\t\tnilfs_segctor_do_flush(sci, 0);\n\t}\n\tup_read(&nilfs->ns_segctor_sem);\n\tcurrent->journal_info = ti->ti_save;\n\n\tif (ti->ti_flags & NILFS_TI_SYNC)\n\t\terr = nilfs_construct_segment(sb);\n\tif (ti->ti_flags & NILFS_TI_DYNAMIC_ALLOC)\n\t\tkmem_cache_free(nilfs_transaction_cachep, ti);\n\tsb_end_intwrite(sb);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nilfs_mark_inode_dirty",
          "args": [
            "inode"
          ],
          "line": 186
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_mark_inode_dirty_sync",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/nilfs.h",
          "lines": "291-294",
          "snippet": "static inline int nilfs_mark_inode_dirty_sync(struct inode *inode)\n{\n\treturn __nilfs_mark_inode_dirty(inode, I_DIRTY_SYNC);\n}",
          "includes": [
            "#include \"bmap.h\"",
            "#include \"the_nilfs.h\"",
            "#include <linux/nilfs2_fs.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"bmap.h\"\n#include \"the_nilfs.h\"\n#include <linux/nilfs2_fs.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/buffer_head.h>\n#include <linux/kernel.h>\n\nstatic inline int nilfs_mark_inode_dirty_sync(struct inode *inode)\n{\n\treturn __nilfs_mark_inode_dirty(inode, I_DIRTY_SYNC);\n}"
        }
      },
      {
        "call_info": {
          "callee": "nilfs_set_transaction_flag",
          "args": [
            "NILFS_TI_SYNC"
          ],
          "line": 184
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_set_transaction_flag",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/nilfs.h",
          "lines": "171-176",
          "snippet": "static inline void nilfs_set_transaction_flag(unsigned int flag)\n{\n\tstruct nilfs_transaction_info *ti = current->journal_info;\n\n\tti->ti_flags |= flag;\n}",
          "includes": [
            "#include \"bmap.h\"",
            "#include \"the_nilfs.h\"",
            "#include <linux/nilfs2_fs.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"bmap.h\"\n#include \"the_nilfs.h\"\n#include <linux/nilfs2_fs.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/buffer_head.h>\n#include <linux/kernel.h>\n\nstatic inline void nilfs_set_transaction_flag(unsigned int flag)\n{\n\tstruct nilfs_transaction_info *ti = current->journal_info;\n\n\tti->ti_flags |= flag;\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_SYNC",
          "args": [
            "inode"
          ],
          "line": 183
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nilfs_set_inode_flags",
          "args": [
            "inode"
          ],
          "line": 181
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_set_inode_flags",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/inode.c",
          "lines": "443-461",
          "snippet": "void nilfs_set_inode_flags(struct inode *inode)\n{\n\tunsigned int flags = NILFS_I(inode)->i_flags;\n\n\tinode->i_flags &= ~(S_SYNC | S_APPEND | S_IMMUTABLE | S_NOATIME |\n\t\t\t    S_DIRSYNC);\n\tif (flags & FS_SYNC_FL)\n\t\tinode->i_flags |= S_SYNC;\n\tif (flags & FS_APPEND_FL)\n\t\tinode->i_flags |= S_APPEND;\n\tif (flags & FS_IMMUTABLE_FL)\n\t\tinode->i_flags |= S_IMMUTABLE;\n\tif (flags & FS_NOATIME_FL)\n\t\tinode->i_flags |= S_NOATIME;\n\tif (flags & FS_DIRSYNC_FL)\n\t\tinode->i_flags |= S_DIRSYNC;\n\tmapping_set_gfp_mask(inode->i_mapping,\n\t\t\t     mapping_gfp_mask(inode->i_mapping) & ~__GFP_FS);\n}",
          "includes": [
            "#include \"ifile.h\"",
            "#include \"cpfile.h\"",
            "#include \"mdt.h\"",
            "#include \"page.h\"",
            "#include \"segment.h\"",
            "#include \"btnode.h\"",
            "#include \"nilfs.h\"",
            "#include <linux/aio.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mpage.h>",
            "#include <linux/gfp.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ifile.h\"\n#include \"cpfile.h\"\n#include \"mdt.h\"\n#include \"page.h\"\n#include \"segment.h\"\n#include \"btnode.h\"\n#include \"nilfs.h\"\n#include <linux/aio.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/mpage.h>\n#include <linux/gfp.h>\n#include <linux/buffer_head.h>\n\nvoid nilfs_set_inode_flags(struct inode *inode)\n{\n\tunsigned int flags = NILFS_I(inode)->i_flags;\n\n\tinode->i_flags &= ~(S_SYNC | S_APPEND | S_IMMUTABLE | S_NOATIME |\n\t\t\t    S_DIRSYNC);\n\tif (flags & FS_SYNC_FL)\n\t\tinode->i_flags |= S_SYNC;\n\tif (flags & FS_APPEND_FL)\n\t\tinode->i_flags |= S_APPEND;\n\tif (flags & FS_IMMUTABLE_FL)\n\t\tinode->i_flags |= S_IMMUTABLE;\n\tif (flags & FS_NOATIME_FL)\n\t\tinode->i_flags |= S_NOATIME;\n\tif (flags & FS_DIRSYNC_FL)\n\t\tinode->i_flags |= S_DIRSYNC;\n\tmapping_set_gfp_mask(inode->i_mapping,\n\t\t\t     mapping_gfp_mask(inode->i_mapping) & ~__GFP_FS);\n}"
        }
      },
      {
        "call_info": {
          "callee": "NILFS_I",
          "args": [
            "inode"
          ],
          "line": 178
        },
        "resolved": true,
        "details": {
          "function_name": "NILFS_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/nilfs.h",
          "lines": "78-81",
          "snippet": "static inline struct nilfs_inode_info *NILFS_I(const struct inode *inode)\n{\n\treturn container_of(inode, struct nilfs_inode_info, vfs_inode);\n}",
          "includes": [
            "#include \"bmap.h\"",
            "#include \"the_nilfs.h\"",
            "#include <linux/nilfs2_fs.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"bmap.h\"\n#include \"the_nilfs.h\"\n#include <linux/nilfs2_fs.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/buffer_head.h>\n#include <linux/kernel.h>\n\nstatic inline struct nilfs_inode_info *NILFS_I(const struct inode *inode)\n{\n\treturn container_of(inode, struct nilfs_inode_info, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "nilfs_transaction_begin",
          "args": [
            "inode->i_sb",
            "&ti",
            "0"
          ],
          "line": 174
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_transaction_begin",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/segment.c",
          "lines": "180-210",
          "snippet": "int nilfs_transaction_begin(struct super_block *sb,\n\t\t\t    struct nilfs_transaction_info *ti,\n\t\t\t    int vacancy_check)\n{\n\tstruct the_nilfs *nilfs;\n\tint ret = nilfs_prepare_segment_lock(ti);\n\n\tif (unlikely(ret < 0))\n\t\treturn ret;\n\tif (ret > 0)\n\t\treturn 0;\n\n\tsb_start_intwrite(sb);\n\n\tnilfs = sb->s_fs_info;\n\tdown_read(&nilfs->ns_segctor_sem);\n\tif (vacancy_check && nilfs_near_disk_full(nilfs)) {\n\t\tup_read(&nilfs->ns_segctor_sem);\n\t\tret = -ENOSPC;\n\t\tgoto failed;\n\t}\n\treturn 0;\n\n failed:\n\tti = current->journal_info;\n\tcurrent->journal_info = ti->ti_save;\n\tif (ti->ti_flags & NILFS_TI_DYNAMIC_ALLOC)\n\t\tkmem_cache_free(nilfs_transaction_cachep, ti);\n\tsb_end_intwrite(sb);\n\treturn ret;\n}",
          "includes": [
            "#include \"segbuf.h\"",
            "#include \"ifile.h\"",
            "#include \"cpfile.h\"",
            "#include \"sufile.h\"",
            "#include \"segment.h\"",
            "#include \"page.h\"",
            "#include \"btnode.h\"",
            "#include \"nilfs.h\"",
            "#include <linux/slab.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/crc32.h>",
            "#include <linux/kthread.h>",
            "#include <linux/freezer.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/completion.h>",
            "#include <linux/bio.h>",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"segbuf.h\"\n#include \"ifile.h\"\n#include \"cpfile.h\"\n#include \"sufile.h\"\n#include \"segment.h\"\n#include \"page.h\"\n#include \"btnode.h\"\n#include \"nilfs.h\"\n#include <linux/slab.h>\n#include <linux/pagevec.h>\n#include <linux/crc32.h>\n#include <linux/kthread.h>\n#include <linux/freezer.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/completion.h>\n#include <linux/bio.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n\nint nilfs_transaction_begin(struct super_block *sb,\n\t\t\t    struct nilfs_transaction_info *ti,\n\t\t\t    int vacancy_check)\n{\n\tstruct the_nilfs *nilfs;\n\tint ret = nilfs_prepare_segment_lock(ti);\n\n\tif (unlikely(ret < 0))\n\t\treturn ret;\n\tif (ret > 0)\n\t\treturn 0;\n\n\tsb_start_intwrite(sb);\n\n\tnilfs = sb->s_fs_info;\n\tdown_read(&nilfs->ns_segctor_sem);\n\tif (vacancy_check && nilfs_near_disk_full(nilfs)) {\n\t\tup_read(&nilfs->ns_segctor_sem);\n\t\tret = -ENOSPC;\n\t\tgoto failed;\n\t}\n\treturn 0;\n\n failed:\n\tti = current->journal_info;\n\tcurrent->journal_info = ti->ti_save;\n\tif (ti->ti_flags & NILFS_TI_DYNAMIC_ALLOC)\n\t\tkmem_cache_free(nilfs_transaction_cachep, ti);\n\tsb_end_intwrite(sb);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "capable",
          "args": [
            "CAP_LINUX_IMMUTABLE"
          ],
          "line": 171
        },
        "resolved": true,
        "details": {
          "function_name": "inode_owner_or_capable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "1901-1912",
          "snippet": "bool inode_owner_or_capable(const struct inode *inode)\n{\n\tstruct user_namespace *ns;\n\n\tif (uid_eq(current_fsuid(), inode->i_uid))\n\t\treturn true;\n\n\tns = current_user_ns();\n\tif (ns_capable(ns, CAP_FOWNER) && kuid_has_mapping(ns, inode->i_uid))\n\t\treturn true;\n\treturn false;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nbool inode_owner_or_capable(const struct inode *inode)\n{\n\tstruct user_namespace *ns;\n\n\tif (uid_eq(current_fsuid(), inode->i_uid))\n\t\treturn true;\n\n\tns = current_user_ns();\n\tif (ns_capable(ns, CAP_FOWNER) && kuid_has_mapping(ns, inode->i_uid))\n\t\treturn true;\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&inode->i_mutex"
          ],
          "line": 161
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nilfs_mask_flags",
          "args": [
            "inode->i_mode",
            "flags"
          ],
          "line": 159
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_mask_flags",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/nilfs.h",
          "lines": "226-234",
          "snippet": "static inline __u32 nilfs_mask_flags(umode_t mode, __u32 flags)\n{\n\tif (S_ISDIR(mode))\n\t\treturn flags;\n\telse if (S_ISREG(mode))\n\t\treturn flags & ~(FS_DIRSYNC_FL | FS_TOPDIR_FL);\n\telse\n\t\treturn flags & (FS_NODUMP_FL | FS_NOATIME_FL);\n}",
          "includes": [
            "#include \"bmap.h\"",
            "#include \"the_nilfs.h\"",
            "#include <linux/nilfs2_fs.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"bmap.h\"\n#include \"the_nilfs.h\"\n#include <linux/nilfs2_fs.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/buffer_head.h>\n#include <linux/kernel.h>\n\nstatic inline __u32 nilfs_mask_flags(umode_t mode, __u32 flags)\n{\n\tif (S_ISDIR(mode))\n\t\treturn flags;\n\telse if (S_ISREG(mode))\n\t\treturn flags & ~(FS_DIRSYNC_FL | FS_TOPDIR_FL);\n\telse\n\t\treturn flags & (FS_NODUMP_FL | FS_NOATIME_FL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mnt_want_write_file",
          "args": [
            "filp"
          ],
          "line": 155
        },
        "resolved": true,
        "details": {
          "function_name": "mnt_want_write_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namespace.c",
          "lines": "440-449",
          "snippet": "int mnt_want_write_file(struct file *file)\n{\n\tint ret;\n\n\tsb_start_write(file->f_path.mnt->mnt_sb);\n\tret = __mnt_want_write_file(file);\n\tif (ret)\n\t\tsb_end_write(file->f_path.mnt->mnt_sb);\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"pnode.h\"",
            "#include <linux/task_work.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/magic.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
            "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
            "#include <linux/init.h>\t\t/* init_rootfs */",
            "#include <linux/idr.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/mnt_namespace.h>",
            "#include <linux/capability.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void shrink_submounts(struct mount *mnt);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/task_work.h>\n#include <linux/bootmem.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic void shrink_submounts(struct mount *mnt);\n\nint mnt_want_write_file(struct file *file)\n{\n\tint ret;\n\n\tsb_start_write(file->f_path.mnt->mnt_sb);\n\tret = __mnt_want_write_file(file);\n\tif (ret)\n\t\tsb_end_write(file->f_path.mnt->mnt_sb);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_user",
          "args": [
            "flags",
            "(int __user *)argp"
          ],
          "line": 152
        },
        "resolved": true,
        "details": {
          "function_name": "get_user_arg_ptr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/exec.c",
          "lines": "399-418",
          "snippet": "static const char __user *get_user_arg_ptr(struct user_arg_ptr argv, int nr)\n{\n\tconst char __user *native;\n\n#ifdef CONFIG_COMPAT\n\tif (unlikely(argv.is_compat)) {\n\t\tcompat_uptr_t compat;\n\n\t\tif (get_user(compat, argv.ptr.compat + nr))\n\t\t\treturn ERR_PTR(-EFAULT);\n\n\t\treturn compat_ptr(compat);\n\t}\n#endif\n\n\tif (get_user(native, argv.ptr.native + nr))\n\t\treturn ERR_PTR(-EFAULT);\n\n\treturn native;\n}",
          "includes": [
            "#include <trace/events/sched.h>",
            "#include \"internal.h\"",
            "#include <trace/events/task.h>",
            "#include <asm/tlb.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/oom.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/kmod.h>",
            "#include <linux/tracehook.h>",
            "#include <linux/audit.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/module.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/utsname.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/personality.h>",
            "#include <linux/key.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/highmem.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/init.h>",
            "#include <linux/string.h>",
            "#include <linux/swap.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/stat.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/mm.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/sched.h>\n#include \"internal.h\"\n#include <trace/events/task.h>\n#include <asm/tlb.h>\n#include <asm/mmu_context.h>\n#include <asm/uaccess.h>\n#include <linux/compat.h>\n#include <linux/oom.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/fs_struct.h>\n#include <linux/fsnotify.h>\n#include <linux/kmod.h>\n#include <linux/tracehook.h>\n#include <linux/audit.h>\n#include <linux/cn_proc.h>\n#include <linux/tsacct_kern.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/module.h>\n#include <linux/pid_namespace.h>\n#include <linux/utsname.h>\n#include <linux/binfmts.h>\n#include <linux/personality.h>\n#include <linux/key.h>\n#include <linux/spinlock.h>\n#include <linux/highmem.h>\n#include <linux/perf_event.h>\n#include <linux/pagemap.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/swap.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n\nstatic const char __user *get_user_arg_ptr(struct user_arg_ptr argv, int nr)\n{\n\tconst char __user *native;\n\n#ifdef CONFIG_COMPAT\n\tif (unlikely(argv.is_compat)) {\n\t\tcompat_uptr_t compat;\n\n\t\tif (get_user(compat, argv.ptr.compat + nr))\n\t\t\treturn ERR_PTR(-EFAULT);\n\n\t\treturn compat_ptr(compat);\n\t}\n#endif\n\n\tif (get_user(native, argv.ptr.native + nr))\n\t\treturn ERR_PTR(-EFAULT);\n\n\treturn native;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"dat.h\"\n#include \"sufile.h\"\n#include \"cpfile.h\"\n#include \"bmap.h\"\n#include \"segment.h\"\n#include \"nilfs.h\"\n#include <linux/nilfs2_fs.h>\n#include <linux/buffer_head.h>\n#include <linux/mount.h>\t/* mnt_want_write_file(), mnt_drop_write_file() */\n#include <linux/compat.h>\t/* compat_ptr() */\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\t/* copy_from_user(), copy_to_user() */\n#include <linux/capability.h>\t/* capable() */\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/fs.h>\n\nstatic int nilfs_ioctl_setflags(struct inode *inode, struct file *filp,\n\t\t\t\tvoid __user *argp)\n{\n\tstruct nilfs_transaction_info ti;\n\tunsigned int flags, oldflags;\n\tint ret;\n\n\tif (!inode_owner_or_capable(inode))\n\t\treturn -EACCES;\n\n\tif (get_user(flags, (int __user *)argp))\n\t\treturn -EFAULT;\n\n\tret = mnt_want_write_file(filp);\n\tif (ret)\n\t\treturn ret;\n\n\tflags = nilfs_mask_flags(inode->i_mode, flags);\n\n\tmutex_lock(&inode->i_mutex);\n\n\toldflags = NILFS_I(inode)->i_flags;\n\n\t/*\n\t * The IMMUTABLE and APPEND_ONLY flags can only be changed by the\n\t * relevant capability.\n\t */\n\tret = -EPERM;\n\tif (((flags ^ oldflags) & (FS_APPEND_FL | FS_IMMUTABLE_FL)) &&\n\t    !capable(CAP_LINUX_IMMUTABLE))\n\t\tgoto out;\n\n\tret = nilfs_transaction_begin(inode->i_sb, &ti, 0);\n\tif (ret)\n\t\tgoto out;\n\n\tNILFS_I(inode)->i_flags = (oldflags & ~FS_FL_USER_MODIFIABLE) |\n\t\t(flags & FS_FL_USER_MODIFIABLE);\n\n\tnilfs_set_inode_flags(inode);\n\tinode->i_ctime = CURRENT_TIME;\n\tif (IS_SYNC(inode))\n\t\tnilfs_set_transaction_flag(NILFS_TI_SYNC);\n\n\tnilfs_mark_inode_dirty(inode);\n\tret = nilfs_transaction_commit(inode->i_sb);\nout:\n\tmutex_unlock(&inode->i_mutex);\n\tmnt_drop_write_file(filp);\n\treturn ret;\n}"
  },
  {
    "function_name": "nilfs_ioctl_getflags",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/ioctl.c",
    "lines": "132-137",
    "snippet": "static int nilfs_ioctl_getflags(struct inode *inode, void __user *argp)\n{\n\tunsigned int flags = NILFS_I(inode)->i_flags & FS_FL_USER_VISIBLE;\n\n\treturn put_user(flags, (int __user *)argp);\n}",
    "includes": [
      "#include \"dat.h\"",
      "#include \"sufile.h\"",
      "#include \"cpfile.h\"",
      "#include \"bmap.h\"",
      "#include \"segment.h\"",
      "#include \"nilfs.h\"",
      "#include <linux/nilfs2_fs.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/mount.h>\t/* mnt_want_write_file(), mnt_drop_write_file() */",
      "#include <linux/compat.h>\t/* compat_ptr() */",
      "#include <linux/vmalloc.h>",
      "#include <linux/uaccess.h>\t/* copy_from_user(), copy_to_user() */",
      "#include <linux/capability.h>\t/* capable() */",
      "#include <linux/slab.h>",
      "#include <linux/wait.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "put_user",
          "args": [
            "flags",
            "(int __user *)argp"
          ],
          "line": 136
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NILFS_I",
          "args": [
            "inode"
          ],
          "line": 134
        },
        "resolved": true,
        "details": {
          "function_name": "NILFS_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/nilfs.h",
          "lines": "78-81",
          "snippet": "static inline struct nilfs_inode_info *NILFS_I(const struct inode *inode)\n{\n\treturn container_of(inode, struct nilfs_inode_info, vfs_inode);\n}",
          "includes": [
            "#include \"bmap.h\"",
            "#include \"the_nilfs.h\"",
            "#include <linux/nilfs2_fs.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"bmap.h\"\n#include \"the_nilfs.h\"\n#include <linux/nilfs2_fs.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/buffer_head.h>\n#include <linux/kernel.h>\n\nstatic inline struct nilfs_inode_info *NILFS_I(const struct inode *inode)\n{\n\treturn container_of(inode, struct nilfs_inode_info, vfs_inode);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"dat.h\"\n#include \"sufile.h\"\n#include \"cpfile.h\"\n#include \"bmap.h\"\n#include \"segment.h\"\n#include \"nilfs.h\"\n#include <linux/nilfs2_fs.h>\n#include <linux/buffer_head.h>\n#include <linux/mount.h>\t/* mnt_want_write_file(), mnt_drop_write_file() */\n#include <linux/compat.h>\t/* compat_ptr() */\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\t/* copy_from_user(), copy_to_user() */\n#include <linux/capability.h>\t/* capable() */\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/fs.h>\n\nstatic int nilfs_ioctl_getflags(struct inode *inode, void __user *argp)\n{\n\tunsigned int flags = NILFS_I(inode)->i_flags & FS_FL_USER_VISIBLE;\n\n\treturn put_user(flags, (int __user *)argp);\n}"
  },
  {
    "function_name": "nilfs_ioctl_wrap_copy",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/ioctl.c",
    "lines": "60-127",
    "snippet": "static int nilfs_ioctl_wrap_copy(struct the_nilfs *nilfs,\n\t\t\t\t struct nilfs_argv *argv, int dir,\n\t\t\t\t ssize_t (*dofunc)(struct the_nilfs *,\n\t\t\t\t\t\t   __u64 *, int,\n\t\t\t\t\t\t   void *, size_t, size_t))\n{\n\tvoid *buf;\n\tvoid __user *base = (void __user *)(unsigned long)argv->v_base;\n\tsize_t maxmembs, total, n;\n\tssize_t nr;\n\tint ret, i;\n\t__u64 pos, ppos;\n\n\tif (argv->v_nmembs == 0)\n\t\treturn 0;\n\n\tif (argv->v_size > PAGE_SIZE)\n\t\treturn -EINVAL;\n\n\t/*\n\t * Reject pairs of a start item position (argv->v_index) and a\n\t * total count (argv->v_nmembs) which leads position 'pos' to\n\t * overflow by the increment at the end of the loop.\n\t */\n\tif (argv->v_index > ~(__u64)0 - argv->v_nmembs)\n\t\treturn -EINVAL;\n\n\tbuf = (void *)__get_free_pages(GFP_NOFS, 0);\n\tif (unlikely(!buf))\n\t\treturn -ENOMEM;\n\tmaxmembs = PAGE_SIZE / argv->v_size;\n\n\tret = 0;\n\ttotal = 0;\n\tpos = argv->v_index;\n\tfor (i = 0; i < argv->v_nmembs; i += n) {\n\t\tn = (argv->v_nmembs - i < maxmembs) ?\n\t\t\targv->v_nmembs - i : maxmembs;\n\t\tif ((dir & _IOC_WRITE) &&\n\t\t    copy_from_user(buf, base + argv->v_size * i,\n\t\t\t\t   argv->v_size * n)) {\n\t\t\tret = -EFAULT;\n\t\t\tbreak;\n\t\t}\n\t\tppos = pos;\n\t\tnr = dofunc(nilfs, &pos, argv->v_flags, buf, argv->v_size,\n\t\t\t       n);\n\t\tif (nr < 0) {\n\t\t\tret = nr;\n\t\t\tbreak;\n\t\t}\n\t\tif ((dir & _IOC_READ) &&\n\t\t    copy_to_user(base + argv->v_size * i, buf,\n\t\t\t\t argv->v_size * nr)) {\n\t\t\tret = -EFAULT;\n\t\t\tbreak;\n\t\t}\n\t\ttotal += nr;\n\t\tif ((size_t)nr < n)\n\t\t\tbreak;\n\t\tif (pos == ppos)\n\t\t\tpos += n;\n\t}\n\targv->v_nmembs = total;\n\n\tfree_pages((unsigned long)buf, 0);\n\treturn ret;\n}",
    "includes": [
      "#include \"dat.h\"",
      "#include \"sufile.h\"",
      "#include \"cpfile.h\"",
      "#include \"bmap.h\"",
      "#include \"segment.h\"",
      "#include \"nilfs.h\"",
      "#include <linux/nilfs2_fs.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/mount.h>\t/* mnt_want_write_file(), mnt_drop_write_file() */",
      "#include <linux/compat.h>\t/* compat_ptr() */",
      "#include <linux/vmalloc.h>",
      "#include <linux/uaccess.h>\t/* copy_from_user(), copy_to_user() */",
      "#include <linux/capability.h>\t/* capable() */",
      "#include <linux/slab.h>",
      "#include <linux/wait.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "free_pages",
          "args": [
            "(unsigned long)buf",
            "0"
          ],
          "line": 125
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_unlock_and_free_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/aops.c",
          "lines": "1114-1125",
          "snippet": "void ocfs2_unlock_and_free_pages(struct page **pages, int num_pages)\n{\n\tint i;\n\n\tfor(i = 0; i < num_pages; i++) {\n\t\tif (pages[i]) {\n\t\t\tunlock_page(pages[i]);\n\t\t\tmark_page_accessed(pages[i]);\n\t\t\tpage_cache_release(pages[i]);\n\t\t}\n\t}\n}",
          "includes": [
            "#include \"sysfile.h\"",
            "#include \"namei.h\"",
            "#include \"dir.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"symlink.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/swap.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfile.h\"\n#include \"namei.h\"\n#include \"dir.h\"\n#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"symlink.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/mpage.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/swap.h>\n#include <asm/byteorder.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nvoid ocfs2_unlock_and_free_pages(struct page **pages, int num_pages)\n{\n\tint i;\n\n\tfor(i = 0; i < num_pages; i++) {\n\t\tif (pages[i]) {\n\t\t\tunlock_page(pages[i]);\n\t\t\tmark_page_accessed(pages[i]);\n\t\t\tpage_cache_release(pages[i]);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "copy_to_user",
          "args": [
            "base + argv->v_size * i",
            "buf",
            "argv->v_size * nr"
          ],
          "line": 112
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dofunc",
          "args": [
            "nilfs",
            "&pos",
            "argv->v_flags",
            "buf",
            "argv->v_size",
            "n"
          ],
          "line": 105
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "copy_from_user",
          "args": [
            "buf",
            "base + argv->v_size * i",
            "argv->v_size * n"
          ],
          "line": 99
        },
        "resolved": true,
        "details": {
          "function_name": "exact_copy_from_user",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namespace.c",
          "lines": "2514-2534",
          "snippet": "static long exact_copy_from_user(void *to, const void __user * from,\n\t\t\t\t unsigned long n)\n{\n\tchar *t = to;\n\tconst char __user *f = from;\n\tchar c;\n\n\tif (!access_ok(VERIFY_READ, from, n))\n\t\treturn n;\n\n\twhile (n) {\n\t\tif (__get_user(c, f)) {\n\t\t\tmemset(t, 0, n);\n\t\t\tbreak;\n\t\t}\n\t\t*t++ = c;\n\t\tf++;\n\t\tn--;\n\t}\n\treturn n;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"pnode.h\"",
            "#include <linux/task_work.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/magic.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
            "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
            "#include <linux/init.h>\t\t/* init_rootfs */",
            "#include <linux/idr.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/mnt_namespace.h>",
            "#include <linux/capability.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/task_work.h>\n#include <linux/bootmem.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic long exact_copy_from_user(void *to, const void __user * from,\n\t\t\t\t unsigned long n)\n{\n\tchar *t = to;\n\tconst char __user *f = from;\n\tchar c;\n\n\tif (!access_ok(VERIFY_READ, from, n))\n\t\treturn n;\n\n\twhile (n) {\n\t\tif (__get_user(c, f)) {\n\t\t\tmemset(t, 0, n);\n\t\t\tbreak;\n\t\t}\n\t\t*t++ = c;\n\t\tf++;\n\t\tn--;\n\t}\n\treturn n;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!buf"
          ],
          "line": 88
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__get_free_pages",
          "args": [
            "GFP_NOFS",
            "0"
          ],
          "line": 87
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"dat.h\"\n#include \"sufile.h\"\n#include \"cpfile.h\"\n#include \"bmap.h\"\n#include \"segment.h\"\n#include \"nilfs.h\"\n#include <linux/nilfs2_fs.h>\n#include <linux/buffer_head.h>\n#include <linux/mount.h>\t/* mnt_want_write_file(), mnt_drop_write_file() */\n#include <linux/compat.h>\t/* compat_ptr() */\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\t/* copy_from_user(), copy_to_user() */\n#include <linux/capability.h>\t/* capable() */\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/fs.h>\n\nstatic int nilfs_ioctl_wrap_copy(struct the_nilfs *nilfs,\n\t\t\t\t struct nilfs_argv *argv, int dir,\n\t\t\t\t ssize_t (*dofunc)(struct the_nilfs *,\n\t\t\t\t\t\t   __u64 *, int,\n\t\t\t\t\t\t   void *, size_t, size_t))\n{\n\tvoid *buf;\n\tvoid __user *base = (void __user *)(unsigned long)argv->v_base;\n\tsize_t maxmembs, total, n;\n\tssize_t nr;\n\tint ret, i;\n\t__u64 pos, ppos;\n\n\tif (argv->v_nmembs == 0)\n\t\treturn 0;\n\n\tif (argv->v_size > PAGE_SIZE)\n\t\treturn -EINVAL;\n\n\t/*\n\t * Reject pairs of a start item position (argv->v_index) and a\n\t * total count (argv->v_nmembs) which leads position 'pos' to\n\t * overflow by the increment at the end of the loop.\n\t */\n\tif (argv->v_index > ~(__u64)0 - argv->v_nmembs)\n\t\treturn -EINVAL;\n\n\tbuf = (void *)__get_free_pages(GFP_NOFS, 0);\n\tif (unlikely(!buf))\n\t\treturn -ENOMEM;\n\tmaxmembs = PAGE_SIZE / argv->v_size;\n\n\tret = 0;\n\ttotal = 0;\n\tpos = argv->v_index;\n\tfor (i = 0; i < argv->v_nmembs; i += n) {\n\t\tn = (argv->v_nmembs - i < maxmembs) ?\n\t\t\targv->v_nmembs - i : maxmembs;\n\t\tif ((dir & _IOC_WRITE) &&\n\t\t    copy_from_user(buf, base + argv->v_size * i,\n\t\t\t\t   argv->v_size * n)) {\n\t\t\tret = -EFAULT;\n\t\t\tbreak;\n\t\t}\n\t\tppos = pos;\n\t\tnr = dofunc(nilfs, &pos, argv->v_flags, buf, argv->v_size,\n\t\t\t       n);\n\t\tif (nr < 0) {\n\t\t\tret = nr;\n\t\t\tbreak;\n\t\t}\n\t\tif ((dir & _IOC_READ) &&\n\t\t    copy_to_user(base + argv->v_size * i, buf,\n\t\t\t\t argv->v_size * nr)) {\n\t\t\tret = -EFAULT;\n\t\t\tbreak;\n\t\t}\n\t\ttotal += nr;\n\t\tif ((size_t)nr < n)\n\t\t\tbreak;\n\t\tif (pos == ppos)\n\t\t\tpos += n;\n\t}\n\targv->v_nmembs = total;\n\n\tfree_pages((unsigned long)buf, 0);\n\treturn ret;\n}"
  }
]