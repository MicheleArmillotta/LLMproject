[
  {
    "function_name": "copy_to_dinode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_imap.c",
    "lines": "3130-3178",
    "snippet": "static void copy_to_dinode(struct dinode * dip, struct inode *ip)\n{\n\tstruct jfs_inode_info *jfs_ip = JFS_IP(ip);\n\tstruct jfs_sb_info *sbi = JFS_SBI(ip->i_sb);\n\n\tdip->di_fileset = cpu_to_le32(jfs_ip->fileset);\n\tdip->di_inostamp = cpu_to_le32(sbi->inostamp);\n\tdip->di_number = cpu_to_le32(ip->i_ino);\n\tdip->di_gen = cpu_to_le32(ip->i_generation);\n\tdip->di_size = cpu_to_le64(ip->i_size);\n\tdip->di_nblocks = cpu_to_le64(PBLK2LBLK(ip->i_sb, ip->i_blocks));\n\tdip->di_nlink = cpu_to_le32(ip->i_nlink);\n\tif (!uid_valid(sbi->uid))\n\t\tdip->di_uid = cpu_to_le32(i_uid_read(ip));\n\telse\n\t\tdip->di_uid =cpu_to_le32(from_kuid(&init_user_ns,\n\t\t\t\t\t\t   jfs_ip->saved_uid));\n\tif (!gid_valid(sbi->gid))\n\t\tdip->di_gid = cpu_to_le32(i_gid_read(ip));\n\telse\n\t\tdip->di_gid = cpu_to_le32(from_kgid(&init_user_ns,\n\t\t\t\t\t\t    jfs_ip->saved_gid));\n\tjfs_get_inode_flags(jfs_ip);\n\t/*\n\t * mode2 is only needed for storing the higher order bits.\n\t * Trust i_mode for the lower order ones\n\t */\n\tif (sbi->umask == -1)\n\t\tdip->di_mode = cpu_to_le32((jfs_ip->mode2 & 0xffff0000) |\n\t\t\t\t\t   ip->i_mode);\n\telse /* Leave the original permissions alone */\n\t\tdip->di_mode = cpu_to_le32(jfs_ip->mode2);\n\n\tdip->di_atime.tv_sec = cpu_to_le32(ip->i_atime.tv_sec);\n\tdip->di_atime.tv_nsec = cpu_to_le32(ip->i_atime.tv_nsec);\n\tdip->di_ctime.tv_sec = cpu_to_le32(ip->i_ctime.tv_sec);\n\tdip->di_ctime.tv_nsec = cpu_to_le32(ip->i_ctime.tv_nsec);\n\tdip->di_mtime.tv_sec = cpu_to_le32(ip->i_mtime.tv_sec);\n\tdip->di_mtime.tv_nsec = cpu_to_le32(ip->i_mtime.tv_nsec);\n\tdip->di_ixpxd = jfs_ip->ixpxd;\t/* in-memory pxd's are little-endian */\n\tdip->di_acl = jfs_ip->acl;\t/* as are dxd's */\n\tdip->di_ea = jfs_ip->ea;\n\tdip->di_next_index = cpu_to_le32(jfs_ip->next_index);\n\tdip->di_otime.tv_sec = cpu_to_le32(jfs_ip->otime);\n\tdip->di_otime.tv_nsec = 0;\n\tdip->di_acltype = cpu_to_le32(jfs_ip->acltype);\n\tif (S_ISCHR(ip->i_mode) || S_ISBLK(ip->i_mode))\n\t\tdip->di_rdev = cpu_to_le32(jfs_ip->dev);\n}",
    "includes": [
      "#include \"jfs_debug.h\"",
      "#include \"jfs_superblock.h\"",
      "#include \"jfs_metapage.h\"",
      "#include \"jfs_imap.h\"",
      "#include \"jfs_dmap.h\"",
      "#include \"jfs_dinode.h\"",
      "#include \"jfs_filsys.h\"",
      "#include \"jfs_inode.h\"",
      "#include \"jfs_incore.h\"",
      "#include <linux/slab.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int diAllocAG(struct inomap *, int, bool, struct inode *);",
      "static int diAllocAny(struct inomap *, int, bool, struct inode *);",
      "static int diAllocExt(struct inomap *, int, struct inode *);",
      "static int diAllocIno(struct inomap *, int, struct inode *);",
      "static int copy_from_dinode(struct dinode *, struct inode *);",
      "static void copy_to_dinode(struct dinode *, struct inode *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "jfs_ip->dev"
          ],
          "line": 3177
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISBLK",
          "args": [
            "ip->i_mode"
          ],
          "line": 3176
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISCHR",
          "args": [
            "ip->i_mode"
          ],
          "line": 3176
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "jfs_ip->acltype"
          ],
          "line": 3175
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "jfs_ip->otime"
          ],
          "line": 3173
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "jfs_ip->next_index"
          ],
          "line": 3172
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "ip->i_mtime.tv_nsec"
          ],
          "line": 3168
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "ip->i_mtime.tv_sec"
          ],
          "line": 3167
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "ip->i_ctime.tv_nsec"
          ],
          "line": 3166
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "ip->i_ctime.tv_sec"
          ],
          "line": 3165
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "ip->i_atime.tv_nsec"
          ],
          "line": 3164
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "ip->i_atime.tv_sec"
          ],
          "line": 3163
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "jfs_ip->mode2"
          ],
          "line": 3161
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "(jfs_ip->mode2 & 0xffff0000) |\n\t\t\t\t\t   ip->i_mode"
          ],
          "line": 3158
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "jfs_get_inode_flags",
          "args": [
            "jfs_ip"
          ],
          "line": 3152
        },
        "resolved": true,
        "details": {
          "function_name": "jfs_get_inode_flags",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_inode.c",
          "lines": "48-64",
          "snippet": "void jfs_get_inode_flags(struct jfs_inode_info *jfs_ip)\n{\n\tunsigned int flags = jfs_ip->vfs_inode.i_flags;\n\n\tjfs_ip->mode2 &= ~(JFS_IMMUTABLE_FL | JFS_APPEND_FL | JFS_NOATIME_FL |\n\t\t\t   JFS_DIRSYNC_FL | JFS_SYNC_FL);\n\tif (flags & S_IMMUTABLE)\n\t\tjfs_ip->mode2 |= JFS_IMMUTABLE_FL;\n\tif (flags & S_APPEND)\n\t\tjfs_ip->mode2 |= JFS_APPEND_FL;\n\tif (flags & S_NOATIME)\n\t\tjfs_ip->mode2 |= JFS_NOATIME_FL;\n\tif (flags & S_DIRSYNC)\n\t\tjfs_ip->mode2 |= JFS_DIRSYNC_FL;\n\tif (flags & S_SYNC)\n\t\tjfs_ip->mode2 |= JFS_SYNC_FL;\n}",
          "includes": [
            "#include \"jfs_debug.h\"",
            "#include \"jfs_dinode.h\"",
            "#include \"jfs_imap.h\"",
            "#include \"jfs_filsys.h\"",
            "#include \"jfs_inode.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/quotaops.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_dinode.h\"\n#include \"jfs_imap.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_inode.h\"\n#include \"jfs_incore.h\"\n#include <linux/quotaops.h>\n#include <linux/fs.h>\n\nvoid jfs_get_inode_flags(struct jfs_inode_info *jfs_ip)\n{\n\tunsigned int flags = jfs_ip->vfs_inode.i_flags;\n\n\tjfs_ip->mode2 &= ~(JFS_IMMUTABLE_FL | JFS_APPEND_FL | JFS_NOATIME_FL |\n\t\t\t   JFS_DIRSYNC_FL | JFS_SYNC_FL);\n\tif (flags & S_IMMUTABLE)\n\t\tjfs_ip->mode2 |= JFS_IMMUTABLE_FL;\n\tif (flags & S_APPEND)\n\t\tjfs_ip->mode2 |= JFS_APPEND_FL;\n\tif (flags & S_NOATIME)\n\t\tjfs_ip->mode2 |= JFS_NOATIME_FL;\n\tif (flags & S_DIRSYNC)\n\t\tjfs_ip->mode2 |= JFS_DIRSYNC_FL;\n\tif (flags & S_SYNC)\n\t\tjfs_ip->mode2 |= JFS_SYNC_FL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "from_kgid(&init_user_ns,\n\t\t\t\t\t\t    jfs_ip->saved_gid)"
          ],
          "line": 3150
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "from_kgid",
          "args": [
            "&init_user_ns",
            "jfs_ip->saved_gid"
          ],
          "line": 3150
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "i_gid_read(ip)"
          ],
          "line": 3148
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "i_gid_read",
          "args": [
            "ip"
          ],
          "line": 3148
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gid_valid",
          "args": [
            "sbi->gid"
          ],
          "line": 3147
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "from_kuid(&init_user_ns,\n\t\t\t\t\t\t   jfs_ip->saved_uid)"
          ],
          "line": 3145
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "from_kuid",
          "args": [
            "&init_user_ns",
            "jfs_ip->saved_uid"
          ],
          "line": 3145
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "i_uid_read(ip)"
          ],
          "line": 3143
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "i_uid_read",
          "args": [
            "ip"
          ],
          "line": 3143
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "uid_valid",
          "args": [
            "sbi->uid"
          ],
          "line": 3142
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_uuid_valid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/sys.c",
          "lines": "73-82",
          "snippet": "static int gfs2_uuid_valid(const u8 *uuid)\n{\n\tint i;\n\n\tfor (i = 0; i < 16; i++) {\n\t\tif (uuid[i])\n\t\t\treturn 1;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"recovery.h\"",
            "#include \"glops.h\"",
            "#include \"util.h\"",
            "#include \"quota.h\"",
            "#include \"glock.h\"",
            "#include \"super.h\"",
            "#include \"sys.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/genhd.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/kobject.h>",
            "#include <linux/module.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"recovery.h\"\n#include \"glops.h\"\n#include \"util.h\"\n#include \"quota.h\"\n#include \"glock.h\"\n#include \"super.h\"\n#include \"sys.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/genhd.h>\n#include <linux/gfs2_ondisk.h>\n#include <asm/uaccess.h>\n#include <linux/kobject.h>\n#include <linux/module.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/sched.h>\n\nstatic int gfs2_uuid_valid(const u8 *uuid)\n{\n\tint i;\n\n\tfor (i = 0; i < 16; i++) {\n\t\tif (uuid[i])\n\t\t\treturn 1;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "ip->i_nlink"
          ],
          "line": 3141
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le64",
          "args": [
            "PBLK2LBLK(ip->i_sb, ip->i_blocks)"
          ],
          "line": 3140
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PBLK2LBLK",
          "args": [
            "ip->i_sb",
            "ip->i_blocks"
          ],
          "line": 3140
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le64",
          "args": [
            "ip->i_size"
          ],
          "line": 3139
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "ip->i_generation"
          ],
          "line": 3138
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "ip->i_ino"
          ],
          "line": 3137
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "sbi->inostamp"
          ],
          "line": 3136
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "jfs_ip->fileset"
          ],
          "line": 3135
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "JFS_SBI",
          "args": [
            "ip->i_sb"
          ],
          "line": 3133
        },
        "resolved": true,
        "details": {
          "function_name": "JFS_SBI",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_incore.h",
          "lines": "217-220",
          "snippet": "static inline struct jfs_sb_info *JFS_SBI(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"jfs_dtree.h\"",
            "#include \"jfs_xtree.h\"",
            "#include \"jfs_types.h\"",
            "#include <linux/bitops.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_dtree.h\"\n#include \"jfs_xtree.h\"\n#include \"jfs_types.h\"\n#include <linux/bitops.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mutex.h>\n\nstatic inline struct jfs_sb_info *JFS_SBI(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      },
      {
        "call_info": {
          "callee": "JFS_IP",
          "args": [
            "ip"
          ],
          "line": 3132
        },
        "resolved": true,
        "details": {
          "function_name": "JFS_IP",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_incore.h",
          "lines": "207-210",
          "snippet": "static inline struct jfs_inode_info *JFS_IP(struct inode *inode)\n{\n\treturn list_entry(inode, struct jfs_inode_info, vfs_inode);\n}",
          "includes": [
            "#include \"jfs_dtree.h\"",
            "#include \"jfs_xtree.h\"",
            "#include \"jfs_types.h\"",
            "#include <linux/bitops.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_dtree.h\"\n#include \"jfs_xtree.h\"\n#include \"jfs_types.h\"\n#include <linux/bitops.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mutex.h>\n\nstatic inline struct jfs_inode_info *JFS_IP(struct inode *inode)\n{\n\treturn list_entry(inode, struct jfs_inode_info, vfs_inode);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_imap.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_dinode.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_inode.h\"\n#include \"jfs_incore.h\"\n#include <linux/slab.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n\nstatic int diAllocAG(struct inomap *, int, bool, struct inode *);\nstatic int diAllocAny(struct inomap *, int, bool, struct inode *);\nstatic int diAllocExt(struct inomap *, int, struct inode *);\nstatic int diAllocIno(struct inomap *, int, struct inode *);\nstatic int copy_from_dinode(struct dinode *, struct inode *);\nstatic void copy_to_dinode(struct dinode *, struct inode *);\n\nstatic void copy_to_dinode(struct dinode * dip, struct inode *ip)\n{\n\tstruct jfs_inode_info *jfs_ip = JFS_IP(ip);\n\tstruct jfs_sb_info *sbi = JFS_SBI(ip->i_sb);\n\n\tdip->di_fileset = cpu_to_le32(jfs_ip->fileset);\n\tdip->di_inostamp = cpu_to_le32(sbi->inostamp);\n\tdip->di_number = cpu_to_le32(ip->i_ino);\n\tdip->di_gen = cpu_to_le32(ip->i_generation);\n\tdip->di_size = cpu_to_le64(ip->i_size);\n\tdip->di_nblocks = cpu_to_le64(PBLK2LBLK(ip->i_sb, ip->i_blocks));\n\tdip->di_nlink = cpu_to_le32(ip->i_nlink);\n\tif (!uid_valid(sbi->uid))\n\t\tdip->di_uid = cpu_to_le32(i_uid_read(ip));\n\telse\n\t\tdip->di_uid =cpu_to_le32(from_kuid(&init_user_ns,\n\t\t\t\t\t\t   jfs_ip->saved_uid));\n\tif (!gid_valid(sbi->gid))\n\t\tdip->di_gid = cpu_to_le32(i_gid_read(ip));\n\telse\n\t\tdip->di_gid = cpu_to_le32(from_kgid(&init_user_ns,\n\t\t\t\t\t\t    jfs_ip->saved_gid));\n\tjfs_get_inode_flags(jfs_ip);\n\t/*\n\t * mode2 is only needed for storing the higher order bits.\n\t * Trust i_mode for the lower order ones\n\t */\n\tif (sbi->umask == -1)\n\t\tdip->di_mode = cpu_to_le32((jfs_ip->mode2 & 0xffff0000) |\n\t\t\t\t\t   ip->i_mode);\n\telse /* Leave the original permissions alone */\n\t\tdip->di_mode = cpu_to_le32(jfs_ip->mode2);\n\n\tdip->di_atime.tv_sec = cpu_to_le32(ip->i_atime.tv_sec);\n\tdip->di_atime.tv_nsec = cpu_to_le32(ip->i_atime.tv_nsec);\n\tdip->di_ctime.tv_sec = cpu_to_le32(ip->i_ctime.tv_sec);\n\tdip->di_ctime.tv_nsec = cpu_to_le32(ip->i_ctime.tv_nsec);\n\tdip->di_mtime.tv_sec = cpu_to_le32(ip->i_mtime.tv_sec);\n\tdip->di_mtime.tv_nsec = cpu_to_le32(ip->i_mtime.tv_nsec);\n\tdip->di_ixpxd = jfs_ip->ixpxd;\t/* in-memory pxd's are little-endian */\n\tdip->di_acl = jfs_ip->acl;\t/* as are dxd's */\n\tdip->di_ea = jfs_ip->ea;\n\tdip->di_next_index = cpu_to_le32(jfs_ip->next_index);\n\tdip->di_otime.tv_sec = cpu_to_le32(jfs_ip->otime);\n\tdip->di_otime.tv_nsec = 0;\n\tdip->di_acltype = cpu_to_le32(jfs_ip->acltype);\n\tif (S_ISCHR(ip->i_mode) || S_ISBLK(ip->i_mode))\n\t\tdip->di_rdev = cpu_to_le32(jfs_ip->dev);\n}"
  },
  {
    "function_name": "copy_from_dinode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_imap.c",
    "lines": "3046-3123",
    "snippet": "static int copy_from_dinode(struct dinode * dip, struct inode *ip)\n{\n\tstruct jfs_inode_info *jfs_ip = JFS_IP(ip);\n\tstruct jfs_sb_info *sbi = JFS_SBI(ip->i_sb);\n\n\tjfs_ip->fileset = le32_to_cpu(dip->di_fileset);\n\tjfs_ip->mode2 = le32_to_cpu(dip->di_mode);\n\tjfs_set_inode_flags(ip);\n\n\tip->i_mode = le32_to_cpu(dip->di_mode) & 0xffff;\n\tif (sbi->umask != -1) {\n\t\tip->i_mode = (ip->i_mode & ~0777) | (0777 & ~sbi->umask);\n\t\t/* For directories, add x permission if r is allowed by umask */\n\t\tif (S_ISDIR(ip->i_mode)) {\n\t\t\tif (ip->i_mode & 0400)\n\t\t\t\tip->i_mode |= 0100;\n\t\t\tif (ip->i_mode & 0040)\n\t\t\t\tip->i_mode |= 0010;\n\t\t\tif (ip->i_mode & 0004)\n\t\t\t\tip->i_mode |= 0001;\n\t\t}\n\t}\n\tset_nlink(ip, le32_to_cpu(dip->di_nlink));\n\n\tjfs_ip->saved_uid = make_kuid(&init_user_ns, le32_to_cpu(dip->di_uid));\n\tif (!uid_valid(sbi->uid))\n\t\tip->i_uid = jfs_ip->saved_uid;\n\telse {\n\t\tip->i_uid = sbi->uid;\n\t}\n\n\tjfs_ip->saved_gid = make_kgid(&init_user_ns, le32_to_cpu(dip->di_gid));\n\tif (!gid_valid(sbi->gid))\n\t\tip->i_gid = jfs_ip->saved_gid;\n\telse {\n\t\tip->i_gid = sbi->gid;\n\t}\n\n\tip->i_size = le64_to_cpu(dip->di_size);\n\tip->i_atime.tv_sec = le32_to_cpu(dip->di_atime.tv_sec);\n\tip->i_atime.tv_nsec = le32_to_cpu(dip->di_atime.tv_nsec);\n\tip->i_mtime.tv_sec = le32_to_cpu(dip->di_mtime.tv_sec);\n\tip->i_mtime.tv_nsec = le32_to_cpu(dip->di_mtime.tv_nsec);\n\tip->i_ctime.tv_sec = le32_to_cpu(dip->di_ctime.tv_sec);\n\tip->i_ctime.tv_nsec = le32_to_cpu(dip->di_ctime.tv_nsec);\n\tip->i_blocks = LBLK2PBLK(ip->i_sb, le64_to_cpu(dip->di_nblocks));\n\tip->i_generation = le32_to_cpu(dip->di_gen);\n\n\tjfs_ip->ixpxd = dip->di_ixpxd;\t/* in-memory pxd's are little-endian */\n\tjfs_ip->acl = dip->di_acl;\t/* as are dxd's */\n\tjfs_ip->ea = dip->di_ea;\n\tjfs_ip->next_index = le32_to_cpu(dip->di_next_index);\n\tjfs_ip->otime = le32_to_cpu(dip->di_otime.tv_sec);\n\tjfs_ip->acltype = le32_to_cpu(dip->di_acltype);\n\n\tif (S_ISCHR(ip->i_mode) || S_ISBLK(ip->i_mode)) {\n\t\tjfs_ip->dev = le32_to_cpu(dip->di_rdev);\n\t\tip->i_rdev = new_decode_dev(jfs_ip->dev);\n\t}\n\n\tif (S_ISDIR(ip->i_mode)) {\n\t\tmemcpy(&jfs_ip->i_dirtable, &dip->di_dirtable, 384);\n\t} else if (S_ISREG(ip->i_mode) || S_ISLNK(ip->i_mode)) {\n\t\tmemcpy(&jfs_ip->i_xtroot, &dip->di_xtroot, 288);\n\t} else\n\t\tmemcpy(&jfs_ip->i_inline_ea, &dip->di_inlineea, 128);\n\n\t/* Zero the in-memory-only stuff */\n\tjfs_ip->cflag = 0;\n\tjfs_ip->btindex = 0;\n\tjfs_ip->btorder = 0;\n\tjfs_ip->bxflag = 0;\n\tjfs_ip->blid = 0;\n\tjfs_ip->atlhead = 0;\n\tjfs_ip->atltail = 0;\n\tjfs_ip->xtlid = 0;\n\treturn (0);\n}",
    "includes": [
      "#include \"jfs_debug.h\"",
      "#include \"jfs_superblock.h\"",
      "#include \"jfs_metapage.h\"",
      "#include \"jfs_imap.h\"",
      "#include \"jfs_dmap.h\"",
      "#include \"jfs_dinode.h\"",
      "#include \"jfs_filsys.h\"",
      "#include \"jfs_inode.h\"",
      "#include \"jfs_incore.h\"",
      "#include <linux/slab.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int diAllocAG(struct inomap *, int, bool, struct inode *);",
      "static int diAllocAny(struct inomap *, int, bool, struct inode *);",
      "static int diAllocExt(struct inomap *, int, struct inode *);",
      "static int diAllocIno(struct inomap *, int, struct inode *);",
      "static int copy_from_dinode(struct dinode *, struct inode *);",
      "static void copy_to_dinode(struct dinode *, struct inode *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "&jfs_ip->i_inline_ea",
            "&dip->di_inlineea",
            "128"
          ],
          "line": 3111
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "&jfs_ip->i_xtroot",
            "&dip->di_xtroot",
            "288"
          ],
          "line": 3109
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISLNK",
          "args": [
            "ip->i_mode"
          ],
          "line": 3108
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISREG",
          "args": [
            "ip->i_mode"
          ],
          "line": 3108
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "&jfs_ip->i_dirtable",
            "&dip->di_dirtable",
            "384"
          ],
          "line": 3107
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISDIR",
          "args": [
            "ip->i_mode"
          ],
          "line": 3106
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "new_decode_dev",
          "args": [
            "jfs_ip->dev"
          ],
          "line": 3103
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "dip->di_rdev"
          ],
          "line": 3102
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "S_ISBLK",
          "args": [
            "ip->i_mode"
          ],
          "line": 3101
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISCHR",
          "args": [
            "ip->i_mode"
          ],
          "line": 3101
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LBLK2PBLK",
          "args": [
            "ip->i_sb",
            "le64_to_cpu(dip->di_nblocks)"
          ],
          "line": 3091
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le64_to_cpu",
          "args": [
            "dip->di_nblocks"
          ],
          "line": 3091
        },
        "resolved": true,
        "details": {
          "function_name": "sle64_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "58-61",
          "snippet": "static inline s64 sle64_to_cpup(sle64 *x)\n{\n\treturn le64_to_cpu(*(__force le64*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s64 sle64_to_cpup(sle64 *x)\n{\n\treturn le64_to_cpu(*(__force le64*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "gid_valid",
          "args": [
            "sbi->gid"
          ],
          "line": 3078
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "make_kgid",
          "args": [
            "&init_user_ns",
            "le32_to_cpu(dip->di_gid)"
          ],
          "line": 3077
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "uid_valid",
          "args": [
            "sbi->uid"
          ],
          "line": 3071
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_uuid_valid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/sys.c",
          "lines": "73-82",
          "snippet": "static int gfs2_uuid_valid(const u8 *uuid)\n{\n\tint i;\n\n\tfor (i = 0; i < 16; i++) {\n\t\tif (uuid[i])\n\t\t\treturn 1;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"recovery.h\"",
            "#include \"glops.h\"",
            "#include \"util.h\"",
            "#include \"quota.h\"",
            "#include \"glock.h\"",
            "#include \"super.h\"",
            "#include \"sys.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/genhd.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/kobject.h>",
            "#include <linux/module.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"recovery.h\"\n#include \"glops.h\"\n#include \"util.h\"\n#include \"quota.h\"\n#include \"glock.h\"\n#include \"super.h\"\n#include \"sys.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/genhd.h>\n#include <linux/gfs2_ondisk.h>\n#include <asm/uaccess.h>\n#include <linux/kobject.h>\n#include <linux/module.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/sched.h>\n\nstatic int gfs2_uuid_valid(const u8 *uuid)\n{\n\tint i;\n\n\tfor (i = 0; i < 16; i++) {\n\t\tif (uuid[i])\n\t\t\treturn 1;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "make_kuid",
          "args": [
            "&init_user_ns",
            "le32_to_cpu(dip->di_uid)"
          ],
          "line": 3070
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_nlink",
          "args": [
            "ip",
            "le32_to_cpu(dip->di_nlink)"
          ],
          "line": 3068
        },
        "resolved": true,
        "details": {
          "function_name": "set_nlink",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "305-316",
          "snippet": "void set_nlink(struct inode *inode, unsigned int nlink)\n{\n\tif (!nlink) {\n\t\tclear_nlink(inode);\n\t} else {\n\t\t/* Yes, some filesystems do change nlink from zero to one */\n\t\tif (inode->i_nlink == 0)\n\t\t\tatomic_long_dec(&inode->i_sb->s_remove_count);\n\n\t\tinode->__i_nlink = nlink;\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid set_nlink(struct inode *inode, unsigned int nlink)\n{\n\tif (!nlink) {\n\t\tclear_nlink(inode);\n\t} else {\n\t\t/* Yes, some filesystems do change nlink from zero to one */\n\t\tif (inode->i_nlink == 0)\n\t\t\tatomic_long_dec(&inode->i_sb->s_remove_count);\n\n\t\tinode->__i_nlink = nlink;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "S_ISDIR",
          "args": [
            "ip->i_mode"
          ],
          "line": 3059
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "jfs_set_inode_flags",
          "args": [
            "ip"
          ],
          "line": 3053
        },
        "resolved": true,
        "details": {
          "function_name": "jfs_set_inode_flags",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_inode.c",
          "lines": "29-46",
          "snippet": "void jfs_set_inode_flags(struct inode *inode)\n{\n\tunsigned int flags = JFS_IP(inode)->mode2;\n\tunsigned int new_fl = 0;\n\n\tif (flags & JFS_IMMUTABLE_FL)\n\t\tnew_fl |= S_IMMUTABLE;\n\tif (flags & JFS_APPEND_FL)\n\t\tnew_fl |= S_APPEND;\n\tif (flags & JFS_NOATIME_FL)\n\t\tnew_fl |= S_NOATIME;\n\tif (flags & JFS_DIRSYNC_FL)\n\t\tnew_fl |= S_DIRSYNC;\n\tif (flags & JFS_SYNC_FL)\n\t\tnew_fl |= S_SYNC;\n\tinode_set_flags(inode, new_fl, S_IMMUTABLE | S_APPEND | S_NOATIME |\n\t\t\tS_DIRSYNC | S_SYNC);\n}",
          "includes": [
            "#include \"jfs_debug.h\"",
            "#include \"jfs_dinode.h\"",
            "#include \"jfs_imap.h\"",
            "#include \"jfs_filsys.h\"",
            "#include \"jfs_inode.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/quotaops.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_dinode.h\"\n#include \"jfs_imap.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_inode.h\"\n#include \"jfs_incore.h\"\n#include <linux/quotaops.h>\n#include <linux/fs.h>\n\nvoid jfs_set_inode_flags(struct inode *inode)\n{\n\tunsigned int flags = JFS_IP(inode)->mode2;\n\tunsigned int new_fl = 0;\n\n\tif (flags & JFS_IMMUTABLE_FL)\n\t\tnew_fl |= S_IMMUTABLE;\n\tif (flags & JFS_APPEND_FL)\n\t\tnew_fl |= S_APPEND;\n\tif (flags & JFS_NOATIME_FL)\n\t\tnew_fl |= S_NOATIME;\n\tif (flags & JFS_DIRSYNC_FL)\n\t\tnew_fl |= S_DIRSYNC;\n\tif (flags & JFS_SYNC_FL)\n\t\tnew_fl |= S_SYNC;\n\tinode_set_flags(inode, new_fl, S_IMMUTABLE | S_APPEND | S_NOATIME |\n\t\t\tS_DIRSYNC | S_SYNC);\n}"
        }
      },
      {
        "call_info": {
          "callee": "JFS_SBI",
          "args": [
            "ip->i_sb"
          ],
          "line": 3049
        },
        "resolved": true,
        "details": {
          "function_name": "JFS_SBI",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_incore.h",
          "lines": "217-220",
          "snippet": "static inline struct jfs_sb_info *JFS_SBI(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"jfs_dtree.h\"",
            "#include \"jfs_xtree.h\"",
            "#include \"jfs_types.h\"",
            "#include <linux/bitops.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_dtree.h\"\n#include \"jfs_xtree.h\"\n#include \"jfs_types.h\"\n#include <linux/bitops.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mutex.h>\n\nstatic inline struct jfs_sb_info *JFS_SBI(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      },
      {
        "call_info": {
          "callee": "JFS_IP",
          "args": [
            "ip"
          ],
          "line": 3048
        },
        "resolved": true,
        "details": {
          "function_name": "JFS_IP",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_incore.h",
          "lines": "207-210",
          "snippet": "static inline struct jfs_inode_info *JFS_IP(struct inode *inode)\n{\n\treturn list_entry(inode, struct jfs_inode_info, vfs_inode);\n}",
          "includes": [
            "#include \"jfs_dtree.h\"",
            "#include \"jfs_xtree.h\"",
            "#include \"jfs_types.h\"",
            "#include <linux/bitops.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_dtree.h\"\n#include \"jfs_xtree.h\"\n#include \"jfs_types.h\"\n#include <linux/bitops.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mutex.h>\n\nstatic inline struct jfs_inode_info *JFS_IP(struct inode *inode)\n{\n\treturn list_entry(inode, struct jfs_inode_info, vfs_inode);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_imap.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_dinode.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_inode.h\"\n#include \"jfs_incore.h\"\n#include <linux/slab.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n\nstatic int diAllocAG(struct inomap *, int, bool, struct inode *);\nstatic int diAllocAny(struct inomap *, int, bool, struct inode *);\nstatic int diAllocExt(struct inomap *, int, struct inode *);\nstatic int diAllocIno(struct inomap *, int, struct inode *);\nstatic int copy_from_dinode(struct dinode *, struct inode *);\nstatic void copy_to_dinode(struct dinode *, struct inode *);\n\nstatic int copy_from_dinode(struct dinode * dip, struct inode *ip)\n{\n\tstruct jfs_inode_info *jfs_ip = JFS_IP(ip);\n\tstruct jfs_sb_info *sbi = JFS_SBI(ip->i_sb);\n\n\tjfs_ip->fileset = le32_to_cpu(dip->di_fileset);\n\tjfs_ip->mode2 = le32_to_cpu(dip->di_mode);\n\tjfs_set_inode_flags(ip);\n\n\tip->i_mode = le32_to_cpu(dip->di_mode) & 0xffff;\n\tif (sbi->umask != -1) {\n\t\tip->i_mode = (ip->i_mode & ~0777) | (0777 & ~sbi->umask);\n\t\t/* For directories, add x permission if r is allowed by umask */\n\t\tif (S_ISDIR(ip->i_mode)) {\n\t\t\tif (ip->i_mode & 0400)\n\t\t\t\tip->i_mode |= 0100;\n\t\t\tif (ip->i_mode & 0040)\n\t\t\t\tip->i_mode |= 0010;\n\t\t\tif (ip->i_mode & 0004)\n\t\t\t\tip->i_mode |= 0001;\n\t\t}\n\t}\n\tset_nlink(ip, le32_to_cpu(dip->di_nlink));\n\n\tjfs_ip->saved_uid = make_kuid(&init_user_ns, le32_to_cpu(dip->di_uid));\n\tif (!uid_valid(sbi->uid))\n\t\tip->i_uid = jfs_ip->saved_uid;\n\telse {\n\t\tip->i_uid = sbi->uid;\n\t}\n\n\tjfs_ip->saved_gid = make_kgid(&init_user_ns, le32_to_cpu(dip->di_gid));\n\tif (!gid_valid(sbi->gid))\n\t\tip->i_gid = jfs_ip->saved_gid;\n\telse {\n\t\tip->i_gid = sbi->gid;\n\t}\n\n\tip->i_size = le64_to_cpu(dip->di_size);\n\tip->i_atime.tv_sec = le32_to_cpu(dip->di_atime.tv_sec);\n\tip->i_atime.tv_nsec = le32_to_cpu(dip->di_atime.tv_nsec);\n\tip->i_mtime.tv_sec = le32_to_cpu(dip->di_mtime.tv_sec);\n\tip->i_mtime.tv_nsec = le32_to_cpu(dip->di_mtime.tv_nsec);\n\tip->i_ctime.tv_sec = le32_to_cpu(dip->di_ctime.tv_sec);\n\tip->i_ctime.tv_nsec = le32_to_cpu(dip->di_ctime.tv_nsec);\n\tip->i_blocks = LBLK2PBLK(ip->i_sb, le64_to_cpu(dip->di_nblocks));\n\tip->i_generation = le32_to_cpu(dip->di_gen);\n\n\tjfs_ip->ixpxd = dip->di_ixpxd;\t/* in-memory pxd's are little-endian */\n\tjfs_ip->acl = dip->di_acl;\t/* as are dxd's */\n\tjfs_ip->ea = dip->di_ea;\n\tjfs_ip->next_index = le32_to_cpu(dip->di_next_index);\n\tjfs_ip->otime = le32_to_cpu(dip->di_otime.tv_sec);\n\tjfs_ip->acltype = le32_to_cpu(dip->di_acltype);\n\n\tif (S_ISCHR(ip->i_mode) || S_ISBLK(ip->i_mode)) {\n\t\tjfs_ip->dev = le32_to_cpu(dip->di_rdev);\n\t\tip->i_rdev = new_decode_dev(jfs_ip->dev);\n\t}\n\n\tif (S_ISDIR(ip->i_mode)) {\n\t\tmemcpy(&jfs_ip->i_dirtable, &dip->di_dirtable, 384);\n\t} else if (S_ISREG(ip->i_mode) || S_ISLNK(ip->i_mode)) {\n\t\tmemcpy(&jfs_ip->i_xtroot, &dip->di_xtroot, 288);\n\t} else\n\t\tmemcpy(&jfs_ip->i_inline_ea, &dip->di_inlineea, 128);\n\n\t/* Zero the in-memory-only stuff */\n\tjfs_ip->cflag = 0;\n\tjfs_ip->btindex = 0;\n\tjfs_ip->btorder = 0;\n\tjfs_ip->bxflag = 0;\n\tjfs_ip->blid = 0;\n\tjfs_ip->atlhead = 0;\n\tjfs_ip->atltail = 0;\n\tjfs_ip->xtlid = 0;\n\treturn (0);\n}"
  },
  {
    "function_name": "duplicateIXtree",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_imap.c",
    "lines": "2994-3035",
    "snippet": "static void duplicateIXtree(struct super_block *sb, s64 blkno,\n\t\t\t    int xlen, s64 *xaddr)\n{\n\tstruct jfs_superblock *j_sb;\n\tstruct buffer_head *bh;\n\tstruct inode *ip;\n\ttid_t tid;\n\n\t/* if AIT2 ipmap2 is bad, do not try to update it */\n\tif (JFS_SBI(sb)->mntflag & JFS_BAD_SAIT)\t/* s_flag */\n\t\treturn;\n\tip = diReadSpecial(sb, FILESYSTEM_I, 1);\n\tif (ip == NULL) {\n\t\tJFS_SBI(sb)->mntflag |= JFS_BAD_SAIT;\n\t\tif (readSuper(sb, &bh))\n\t\t\treturn;\n\t\tj_sb = (struct jfs_superblock *)bh->b_data;\n\t\tj_sb->s_flag |= cpu_to_le32(JFS_BAD_SAIT);\n\n\t\tmark_buffer_dirty(bh);\n\t\tsync_dirty_buffer(bh);\n\t\tbrelse(bh);\n\t\treturn;\n\t}\n\n\t/* start transaction */\n\ttid = txBegin(sb, COMMIT_FORCE);\n\t/* update the inode map addressing structure to point to it */\n\tif (xtInsert(tid, ip, 0, blkno, xlen, xaddr, 0)) {\n\t\tJFS_SBI(sb)->mntflag |= JFS_BAD_SAIT;\n\t\ttxAbort(tid, 1);\n\t\tgoto cleanup;\n\n\t}\n\t/* update the inode map's inode to reflect the extension */\n\tip->i_size += PSIZE;\n\tinode_add_bytes(ip, PSIZE);\n\ttxCommit(tid, 1, &ip, COMMIT_FORCE);\n      cleanup:\n\ttxEnd(tid);\n\tdiFreeSpecial(ip);\n}",
    "includes": [
      "#include \"jfs_debug.h\"",
      "#include \"jfs_superblock.h\"",
      "#include \"jfs_metapage.h\"",
      "#include \"jfs_imap.h\"",
      "#include \"jfs_dmap.h\"",
      "#include \"jfs_dinode.h\"",
      "#include \"jfs_filsys.h\"",
      "#include \"jfs_inode.h\"",
      "#include \"jfs_incore.h\"",
      "#include <linux/slab.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int diAllocAG(struct inomap *, int, bool, struct inode *);",
      "static int diAllocAny(struct inomap *, int, bool, struct inode *);",
      "static int diAllocExt(struct inomap *, int, struct inode *);",
      "static int diAllocIno(struct inomap *, int, struct inode *);",
      "static void duplicateIXtree(struct super_block *, s64, int, s64 *);",
      "static int copy_from_dinode(struct dinode *, struct inode *);",
      "static void copy_to_dinode(struct dinode *, struct inode *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "diFreeSpecial",
          "args": [
            "ip"
          ],
          "line": 3034
        },
        "resolved": true,
        "details": {
          "function_name": "diFreeSpecial",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_imap.c",
          "lines": "562-571",
          "snippet": "void diFreeSpecial(struct inode *ip)\n{\n\tif (ip == NULL) {\n\t\tjfs_err(\"diFreeSpecial called with NULL ip!\");\n\t\treturn;\n\t}\n\tfilemap_write_and_wait(ip->i_mapping);\n\ttruncate_inode_pages(ip->i_mapping, 0);\n\tiput(ip);\n}",
          "includes": [
            "#include \"jfs_debug.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_imap.h\"",
            "#include \"jfs_dmap.h\"",
            "#include \"jfs_dinode.h\"",
            "#include \"jfs_filsys.h\"",
            "#include \"jfs_inode.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/slab.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int diAllocAG(struct inomap *, int, bool, struct inode *);",
            "static int diAllocAny(struct inomap *, int, bool, struct inode *);",
            "static int diAllocExt(struct inomap *, int, struct inode *);",
            "static int diAllocIno(struct inomap *, int, struct inode *);",
            "static int copy_from_dinode(struct dinode *, struct inode *);",
            "static void copy_to_dinode(struct dinode *, struct inode *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_imap.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_dinode.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_inode.h\"\n#include \"jfs_incore.h\"\n#include <linux/slab.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n\nstatic int diAllocAG(struct inomap *, int, bool, struct inode *);\nstatic int diAllocAny(struct inomap *, int, bool, struct inode *);\nstatic int diAllocExt(struct inomap *, int, struct inode *);\nstatic int diAllocIno(struct inomap *, int, struct inode *);\nstatic int copy_from_dinode(struct dinode *, struct inode *);\nstatic void copy_to_dinode(struct dinode *, struct inode *);\n\nvoid diFreeSpecial(struct inode *ip)\n{\n\tif (ip == NULL) {\n\t\tjfs_err(\"diFreeSpecial called with NULL ip!\");\n\t\treturn;\n\t}\n\tfilemap_write_and_wait(ip->i_mapping);\n\ttruncate_inode_pages(ip->i_mapping, 0);\n\tiput(ip);\n}"
        }
      },
      {
        "call_info": {
          "callee": "txEnd",
          "args": [
            "tid"
          ],
          "line": 3033
        },
        "resolved": true,
        "details": {
          "function_name": "txEnd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_txnmgr.c",
          "lines": "500-577",
          "snippet": "void txEnd(tid_t tid)\n{\n\tstruct tblock *tblk = tid_to_tblock(tid);\n\tstruct jfs_log *log;\n\n\tjfs_info(\"txEnd: tid = %d\", tid);\n\tTXN_LOCK();\n\n\t/*\n\t * wakeup transactions waiting on the page locked\n\t * by the current transaction\n\t */\n\tTXN_WAKEUP(&tblk->waitor);\n\n\tlog = JFS_SBI(tblk->sb)->log;\n\n\t/*\n\t * Lazy commit thread can't free this guy until we mark it UNLOCKED,\n\t * otherwise, we would be left with a transaction that may have been\n\t * reused.\n\t *\n\t * Lazy commit thread will turn off tblkGC_LAZY before calling this\n\t * routine.\n\t */\n\tif (tblk->flag & tblkGC_LAZY) {\n\t\tjfs_info(\"txEnd called w/lazy tid: %d, tblk = 0x%p\", tid, tblk);\n\t\tTXN_UNLOCK();\n\n\t\tspin_lock_irq(&log->gclock);\t// LOGGC_LOCK\n\t\ttblk->flag |= tblkGC_UNLOCKED;\n\t\tspin_unlock_irq(&log->gclock);\t// LOGGC_UNLOCK\n\t\treturn;\n\t}\n\n\tjfs_info(\"txEnd: tid: %d, tblk = 0x%p\", tid, tblk);\n\n\tassert(tblk->next == 0);\n\n\t/*\n\t * insert tblock back on freelist\n\t */\n\ttblk->next = TxAnchor.freetid;\n\tTxAnchor.freetid = tid;\n\n\t/*\n\t * mark the tblock not active\n\t */\n\tif (--log->active == 0) {\n\t\tclear_bit(log_FLUSH, &log->flag);\n\n\t\t/*\n\t\t * synchronize with logsync barrier\n\t\t */\n\t\tif (test_bit(log_SYNCBARRIER, &log->flag)) {\n\t\t\tTXN_UNLOCK();\n\n\t\t\t/* write dirty metadata & forward log syncpt */\n\t\t\tjfs_syncpt(log, 1);\n\n\t\t\tjfs_info(\"log barrier off: 0x%x\", log->lsn);\n\n\t\t\t/* enable new transactions start */\n\t\t\tclear_bit(log_SYNCBARRIER, &log->flag);\n\n\t\t\t/* wakeup all waitors for logsync barrier */\n\t\t\tTXN_WAKEUP(&log->syncwait);\n\n\t\t\tgoto wakeup;\n\t\t}\n\t}\n\n\tTXN_UNLOCK();\nwakeup:\n\t/*\n\t * wakeup all waitors for a free tblock\n\t */\n\tTXN_WAKEUP(&TxAnchor.freewait);\n}",
          "includes": [
            "#include \"jfs_debug.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_dmap.h\"",
            "#include \"jfs_imap.h\"",
            "#include \"jfs_dinode.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_filsys.h\"",
            "#include \"jfs_inode.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/freezer.h>",
            "#include <linux/completion.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct {\n\tint freetid;\t\t/* index of a free tid structure */\n\tint freelock;\t\t/* index first free lock word */\n\twait_queue_head_t freewait;\t/* eventlist of free tblock */\n\twait_queue_head_t freelockwait;\t/* eventlist of free tlock */\n\twait_queue_head_t lowlockwait;\t/* eventlist of ample tlocks */\n\tint tlocksInUse;\t/* Number of tlocks in use */\n\tspinlock_t LazyLock;\t/* synchronize sync_queue & unlock_queue */\n/*\tstruct tblock *sync_queue; * Transactions waiting for data sync */\n\tstruct list_head unlock_queue;\t/* Txns waiting to be released */\n\tstruct list_head anon_list;\t/* inodes having anonymous txns */\n\tstruct list_head anon_list2;\t/* inodes having anonymous txns\n\t\t\t\t\t   that couldn't be sync'ed */\n} TxAnchor;",
            "static void txAllocPMap(struct inode *ip, struct maplock * maplock,\n\t\tstruct tblock * tblk);",
            "static void txForce(struct tblock * tblk);",
            "static void txUpdateMap(struct tblock * tblk);",
            "static void txRelease(struct tblock * tblk);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_imap.h\"\n#include \"jfs_dinode.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_inode.h\"\n#include \"jfs_incore.h\"\n#include <linux/seq_file.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/freezer.h>\n#include <linux/completion.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n\nstatic struct {\n\tint freetid;\t\t/* index of a free tid structure */\n\tint freelock;\t\t/* index first free lock word */\n\twait_queue_head_t freewait;\t/* eventlist of free tblock */\n\twait_queue_head_t freelockwait;\t/* eventlist of free tlock */\n\twait_queue_head_t lowlockwait;\t/* eventlist of ample tlocks */\n\tint tlocksInUse;\t/* Number of tlocks in use */\n\tspinlock_t LazyLock;\t/* synchronize sync_queue & unlock_queue */\n/*\tstruct tblock *sync_queue; * Transactions waiting for data sync */\n\tstruct list_head unlock_queue;\t/* Txns waiting to be released */\n\tstruct list_head anon_list;\t/* inodes having anonymous txns */\n\tstruct list_head anon_list2;\t/* inodes having anonymous txns\n\t\t\t\t\t   that couldn't be sync'ed */\n} TxAnchor;\nstatic void txAllocPMap(struct inode *ip, struct maplock * maplock,\n\t\tstruct tblock * tblk);\nstatic void txForce(struct tblock * tblk);\nstatic void txUpdateMap(struct tblock * tblk);\nstatic void txRelease(struct tblock * tblk);\n\nvoid txEnd(tid_t tid)\n{\n\tstruct tblock *tblk = tid_to_tblock(tid);\n\tstruct jfs_log *log;\n\n\tjfs_info(\"txEnd: tid = %d\", tid);\n\tTXN_LOCK();\n\n\t/*\n\t * wakeup transactions waiting on the page locked\n\t * by the current transaction\n\t */\n\tTXN_WAKEUP(&tblk->waitor);\n\n\tlog = JFS_SBI(tblk->sb)->log;\n\n\t/*\n\t * Lazy commit thread can't free this guy until we mark it UNLOCKED,\n\t * otherwise, we would be left with a transaction that may have been\n\t * reused.\n\t *\n\t * Lazy commit thread will turn off tblkGC_LAZY before calling this\n\t * routine.\n\t */\n\tif (tblk->flag & tblkGC_LAZY) {\n\t\tjfs_info(\"txEnd called w/lazy tid: %d, tblk = 0x%p\", tid, tblk);\n\t\tTXN_UNLOCK();\n\n\t\tspin_lock_irq(&log->gclock);\t// LOGGC_LOCK\n\t\ttblk->flag |= tblkGC_UNLOCKED;\n\t\tspin_unlock_irq(&log->gclock);\t// LOGGC_UNLOCK\n\t\treturn;\n\t}\n\n\tjfs_info(\"txEnd: tid: %d, tblk = 0x%p\", tid, tblk);\n\n\tassert(tblk->next == 0);\n\n\t/*\n\t * insert tblock back on freelist\n\t */\n\ttblk->next = TxAnchor.freetid;\n\tTxAnchor.freetid = tid;\n\n\t/*\n\t * mark the tblock not active\n\t */\n\tif (--log->active == 0) {\n\t\tclear_bit(log_FLUSH, &log->flag);\n\n\t\t/*\n\t\t * synchronize with logsync barrier\n\t\t */\n\t\tif (test_bit(log_SYNCBARRIER, &log->flag)) {\n\t\t\tTXN_UNLOCK();\n\n\t\t\t/* write dirty metadata & forward log syncpt */\n\t\t\tjfs_syncpt(log, 1);\n\n\t\t\tjfs_info(\"log barrier off: 0x%x\", log->lsn);\n\n\t\t\t/* enable new transactions start */\n\t\t\tclear_bit(log_SYNCBARRIER, &log->flag);\n\n\t\t\t/* wakeup all waitors for logsync barrier */\n\t\t\tTXN_WAKEUP(&log->syncwait);\n\n\t\t\tgoto wakeup;\n\t\t}\n\t}\n\n\tTXN_UNLOCK();\nwakeup:\n\t/*\n\t * wakeup all waitors for a free tblock\n\t */\n\tTXN_WAKEUP(&TxAnchor.freewait);\n}"
        }
      },
      {
        "call_info": {
          "callee": "txCommit",
          "args": [
            "tid",
            "1",
            "&ip",
            "COMMIT_FORCE"
          ],
          "line": 3031
        },
        "resolved": true,
        "details": {
          "function_name": "txCommit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_txnmgr.c",
          "lines": "1135-1368",
          "snippet": "int txCommit(tid_t tid,\t\t/* transaction identifier */\n\t     int nip,\t\t/* number of inodes to commit */\n\t     struct inode **iplist,\t/* list of inode to commit */\n\t     int flag)\n{\n\tint rc = 0;\n\tstruct commit cd;\n\tstruct jfs_log *log;\n\tstruct tblock *tblk;\n\tstruct lrd *lrd;\n\tstruct inode *ip;\n\tstruct jfs_inode_info *jfs_ip;\n\tint k, n;\n\tino_t top;\n\tstruct super_block *sb;\n\n\tjfs_info(\"txCommit, tid = %d, flag = %d\", tid, flag);\n\t/* is read-only file system ? */\n\tif (isReadOnly(iplist[0])) {\n\t\trc = -EROFS;\n\t\tgoto TheEnd;\n\t}\n\n\tsb = cd.sb = iplist[0]->i_sb;\n\tcd.tid = tid;\n\n\tif (tid == 0)\n\t\ttid = txBegin(sb, 0);\n\ttblk = tid_to_tblock(tid);\n\n\t/*\n\t * initialize commit structure\n\t */\n\tlog = JFS_SBI(sb)->log;\n\tcd.log = log;\n\n\t/* initialize log record descriptor in commit */\n\tlrd = &cd.lrd;\n\tlrd->logtid = cpu_to_le32(tblk->logtid);\n\tlrd->backchain = 0;\n\n\ttblk->xflag |= flag;\n\n\tif ((flag & (COMMIT_FORCE | COMMIT_SYNC)) == 0)\n\t\ttblk->xflag |= COMMIT_LAZY;\n\t/*\n\t *\tprepare non-journaled objects for commit\n\t *\n\t * flush data pages of non-journaled file\n\t * to prevent the file getting non-initialized disk blocks\n\t * in case of crash.\n\t * (new blocks - )\n\t */\n\tcd.iplist = iplist;\n\tcd.nip = nip;\n\n\t/*\n\t *\tacquire transaction lock on (on-disk) inodes\n\t *\n\t * update on-disk inode from in-memory inode\n\t * acquiring transaction locks for AFTER records\n\t * on the on-disk inode of file object\n\t *\n\t * sort the inodes array by inode number in descending order\n\t * to prevent deadlock when acquiring transaction lock\n\t * of on-disk inodes on multiple on-disk inode pages by\n\t * multiple concurrent transactions\n\t */\n\tfor (k = 0; k < cd.nip; k++) {\n\t\ttop = (cd.iplist[k])->i_ino;\n\t\tfor (n = k + 1; n < cd.nip; n++) {\n\t\t\tip = cd.iplist[n];\n\t\t\tif (ip->i_ino > top) {\n\t\t\t\ttop = ip->i_ino;\n\t\t\t\tcd.iplist[n] = cd.iplist[k];\n\t\t\t\tcd.iplist[k] = ip;\n\t\t\t}\n\t\t}\n\n\t\tip = cd.iplist[k];\n\t\tjfs_ip = JFS_IP(ip);\n\n\t\t/*\n\t\t * BUGBUG - This code has temporarily been removed.  The\n\t\t * intent is to ensure that any file data is written before\n\t\t * the metadata is committed to the journal.  This prevents\n\t\t * uninitialized data from appearing in a file after the\n\t\t * journal has been replayed.  (The uninitialized data\n\t\t * could be sensitive data removed by another user.)\n\t\t *\n\t\t * The problem now is that we are holding the IWRITELOCK\n\t\t * on the inode, and calling filemap_fdatawrite on an\n\t\t * unmapped page will cause a deadlock in jfs_get_block.\n\t\t *\n\t\t * The long term solution is to pare down the use of\n\t\t * IWRITELOCK.  We are currently holding it too long.\n\t\t * We could also be smarter about which data pages need\n\t\t * to be written before the transaction is committed and\n\t\t * when we don't need to worry about it at all.\n\t\t *\n\t\t * if ((!S_ISDIR(ip->i_mode))\n\t\t *    && (tblk->flag & COMMIT_DELETE) == 0)\n\t\t *\tfilemap_write_and_wait(ip->i_mapping);\n\t\t */\n\n\t\t/*\n\t\t * Mark inode as not dirty.  It will still be on the dirty\n\t\t * inode list, but we'll know not to commit it again unless\n\t\t * it gets marked dirty again\n\t\t */\n\t\tclear_cflag(COMMIT_Dirty, ip);\n\n\t\t/* inherit anonymous tlock(s) of inode */\n\t\tif (jfs_ip->atlhead) {\n\t\t\tlid_to_tlock(jfs_ip->atltail)->next = tblk->next;\n\t\t\ttblk->next = jfs_ip->atlhead;\n\t\t\tif (!tblk->last)\n\t\t\t\ttblk->last = jfs_ip->atltail;\n\t\t\tjfs_ip->atlhead = jfs_ip->atltail = 0;\n\t\t\tTXN_LOCK();\n\t\t\tlist_del_init(&jfs_ip->anon_inode_list);\n\t\t\tTXN_UNLOCK();\n\t\t}\n\n\t\t/*\n\t\t * acquire transaction lock on on-disk inode page\n\t\t * (become first tlock of the tblk's tlock list)\n\t\t */\n\t\tif (((rc = diWrite(tid, ip))))\n\t\t\tgoto out;\n\t}\n\n\t/*\n\t *\twrite log records from transaction locks\n\t *\n\t * txUpdateMap() resets XAD_NEW in XAD.\n\t */\n\tif ((rc = txLog(log, tblk, &cd)))\n\t\tgoto TheEnd;\n\n\t/*\n\t * Ensure that inode isn't reused before\n\t * lazy commit thread finishes processing\n\t */\n\tif (tblk->xflag & COMMIT_DELETE) {\n\t\tihold(tblk->u.ip);\n\t\t/*\n\t\t * Avoid a rare deadlock\n\t\t *\n\t\t * If the inode is locked, we may be blocked in\n\t\t * jfs_commit_inode.  If so, we don't want the\n\t\t * lazy_commit thread doing the last iput() on the inode\n\t\t * since that may block on the locked inode.  Instead,\n\t\t * commit the transaction synchronously, so the last iput\n\t\t * will be done by the calling thread (or later)\n\t\t */\n\t\t/*\n\t\t * I believe this code is no longer needed.  Splitting I_LOCK\n\t\t * into two bits, I_NEW and I_SYNC should prevent this\n\t\t * deadlock as well.  But since I don't have a JFS testload\n\t\t * to verify this, only a trivial s/I_LOCK/I_SYNC/ was done.\n\t\t * Joern\n\t\t */\n\t\tif (tblk->u.ip->i_state & I_SYNC)\n\t\t\ttblk->xflag &= ~COMMIT_LAZY;\n\t}\n\n\tASSERT((!(tblk->xflag & COMMIT_DELETE)) ||\n\t       ((tblk->u.ip->i_nlink == 0) &&\n\t\t!test_cflag(COMMIT_Nolink, tblk->u.ip)));\n\n\t/*\n\t *\twrite COMMIT log record\n\t */\n\tlrd->type = cpu_to_le16(LOG_COMMIT);\n\tlrd->length = 0;\n\tlmLog(log, tblk, lrd, NULL);\n\n\tlmGroupCommit(log, tblk);\n\n\t/*\n\t *\t- transaction is now committed -\n\t */\n\n\t/*\n\t * force pages in careful update\n\t * (imap addressing structure update)\n\t */\n\tif (flag & COMMIT_FORCE)\n\t\ttxForce(tblk);\n\n\t/*\n\t *\tupdate allocation map.\n\t *\n\t * update inode allocation map and inode:\n\t * free pager lock on memory object of inode if any.\n\t * update block allocation map.\n\t *\n\t * txUpdateMap() resets XAD_NEW in XAD.\n\t */\n\tif (tblk->xflag & COMMIT_FORCE)\n\t\ttxUpdateMap(tblk);\n\n\t/*\n\t *\tfree transaction locks and pageout/free pages\n\t */\n\ttxRelease(tblk);\n\n\tif ((tblk->flag & tblkGC_LAZY) == 0)\n\t\ttxUnlock(tblk);\n\n\n\t/*\n\t *\treset in-memory object state\n\t */\n\tfor (k = 0; k < cd.nip; k++) {\n\t\tip = cd.iplist[k];\n\t\tjfs_ip = JFS_IP(ip);\n\n\t\t/*\n\t\t * reset in-memory inode state\n\t\t */\n\t\tjfs_ip->bxflag = 0;\n\t\tjfs_ip->blid = 0;\n\t}\n\n      out:\n\tif (rc != 0)\n\t\ttxAbort(tid, 1);\n\n      TheEnd:\n\tjfs_info(\"txCommit: tid = %d, returning %d\", tid, rc);\n\treturn rc;\n}",
          "includes": [
            "#include \"jfs_debug.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_dmap.h\"",
            "#include \"jfs_imap.h\"",
            "#include \"jfs_dinode.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_filsys.h\"",
            "#include \"jfs_inode.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/freezer.h>",
            "#include <linux/completion.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int diLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t\tstruct tlock * tlck, struct commit * cd);",
            "static void txAllocPMap(struct inode *ip, struct maplock * maplock,\n\t\tstruct tblock * tblk);",
            "static void txForce(struct tblock * tblk);",
            "static int txLog(struct jfs_log * log, struct tblock * tblk,\n\t\tstruct commit * cd);",
            "static void txUpdateMap(struct tblock * tblk);",
            "static void txRelease(struct tblock * tblk);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_imap.h\"\n#include \"jfs_dinode.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_inode.h\"\n#include \"jfs_incore.h\"\n#include <linux/seq_file.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/freezer.h>\n#include <linux/completion.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n\nstatic int diLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t\tstruct tlock * tlck, struct commit * cd);\nstatic void txAllocPMap(struct inode *ip, struct maplock * maplock,\n\t\tstruct tblock * tblk);\nstatic void txForce(struct tblock * tblk);\nstatic int txLog(struct jfs_log * log, struct tblock * tblk,\n\t\tstruct commit * cd);\nstatic void txUpdateMap(struct tblock * tblk);\nstatic void txRelease(struct tblock * tblk);\n\nint txCommit(tid_t tid,\t\t/* transaction identifier */\n\t     int nip,\t\t/* number of inodes to commit */\n\t     struct inode **iplist,\t/* list of inode to commit */\n\t     int flag)\n{\n\tint rc = 0;\n\tstruct commit cd;\n\tstruct jfs_log *log;\n\tstruct tblock *tblk;\n\tstruct lrd *lrd;\n\tstruct inode *ip;\n\tstruct jfs_inode_info *jfs_ip;\n\tint k, n;\n\tino_t top;\n\tstruct super_block *sb;\n\n\tjfs_info(\"txCommit, tid = %d, flag = %d\", tid, flag);\n\t/* is read-only file system ? */\n\tif (isReadOnly(iplist[0])) {\n\t\trc = -EROFS;\n\t\tgoto TheEnd;\n\t}\n\n\tsb = cd.sb = iplist[0]->i_sb;\n\tcd.tid = tid;\n\n\tif (tid == 0)\n\t\ttid = txBegin(sb, 0);\n\ttblk = tid_to_tblock(tid);\n\n\t/*\n\t * initialize commit structure\n\t */\n\tlog = JFS_SBI(sb)->log;\n\tcd.log = log;\n\n\t/* initialize log record descriptor in commit */\n\tlrd = &cd.lrd;\n\tlrd->logtid = cpu_to_le32(tblk->logtid);\n\tlrd->backchain = 0;\n\n\ttblk->xflag |= flag;\n\n\tif ((flag & (COMMIT_FORCE | COMMIT_SYNC)) == 0)\n\t\ttblk->xflag |= COMMIT_LAZY;\n\t/*\n\t *\tprepare non-journaled objects for commit\n\t *\n\t * flush data pages of non-journaled file\n\t * to prevent the file getting non-initialized disk blocks\n\t * in case of crash.\n\t * (new blocks - )\n\t */\n\tcd.iplist = iplist;\n\tcd.nip = nip;\n\n\t/*\n\t *\tacquire transaction lock on (on-disk) inodes\n\t *\n\t * update on-disk inode from in-memory inode\n\t * acquiring transaction locks for AFTER records\n\t * on the on-disk inode of file object\n\t *\n\t * sort the inodes array by inode number in descending order\n\t * to prevent deadlock when acquiring transaction lock\n\t * of on-disk inodes on multiple on-disk inode pages by\n\t * multiple concurrent transactions\n\t */\n\tfor (k = 0; k < cd.nip; k++) {\n\t\ttop = (cd.iplist[k])->i_ino;\n\t\tfor (n = k + 1; n < cd.nip; n++) {\n\t\t\tip = cd.iplist[n];\n\t\t\tif (ip->i_ino > top) {\n\t\t\t\ttop = ip->i_ino;\n\t\t\t\tcd.iplist[n] = cd.iplist[k];\n\t\t\t\tcd.iplist[k] = ip;\n\t\t\t}\n\t\t}\n\n\t\tip = cd.iplist[k];\n\t\tjfs_ip = JFS_IP(ip);\n\n\t\t/*\n\t\t * BUGBUG - This code has temporarily been removed.  The\n\t\t * intent is to ensure that any file data is written before\n\t\t * the metadata is committed to the journal.  This prevents\n\t\t * uninitialized data from appearing in a file after the\n\t\t * journal has been replayed.  (The uninitialized data\n\t\t * could be sensitive data removed by another user.)\n\t\t *\n\t\t * The problem now is that we are holding the IWRITELOCK\n\t\t * on the inode, and calling filemap_fdatawrite on an\n\t\t * unmapped page will cause a deadlock in jfs_get_block.\n\t\t *\n\t\t * The long term solution is to pare down the use of\n\t\t * IWRITELOCK.  We are currently holding it too long.\n\t\t * We could also be smarter about which data pages need\n\t\t * to be written before the transaction is committed and\n\t\t * when we don't need to worry about it at all.\n\t\t *\n\t\t * if ((!S_ISDIR(ip->i_mode))\n\t\t *    && (tblk->flag & COMMIT_DELETE) == 0)\n\t\t *\tfilemap_write_and_wait(ip->i_mapping);\n\t\t */\n\n\t\t/*\n\t\t * Mark inode as not dirty.  It will still be on the dirty\n\t\t * inode list, but we'll know not to commit it again unless\n\t\t * it gets marked dirty again\n\t\t */\n\t\tclear_cflag(COMMIT_Dirty, ip);\n\n\t\t/* inherit anonymous tlock(s) of inode */\n\t\tif (jfs_ip->atlhead) {\n\t\t\tlid_to_tlock(jfs_ip->atltail)->next = tblk->next;\n\t\t\ttblk->next = jfs_ip->atlhead;\n\t\t\tif (!tblk->last)\n\t\t\t\ttblk->last = jfs_ip->atltail;\n\t\t\tjfs_ip->atlhead = jfs_ip->atltail = 0;\n\t\t\tTXN_LOCK();\n\t\t\tlist_del_init(&jfs_ip->anon_inode_list);\n\t\t\tTXN_UNLOCK();\n\t\t}\n\n\t\t/*\n\t\t * acquire transaction lock on on-disk inode page\n\t\t * (become first tlock of the tblk's tlock list)\n\t\t */\n\t\tif (((rc = diWrite(tid, ip))))\n\t\t\tgoto out;\n\t}\n\n\t/*\n\t *\twrite log records from transaction locks\n\t *\n\t * txUpdateMap() resets XAD_NEW in XAD.\n\t */\n\tif ((rc = txLog(log, tblk, &cd)))\n\t\tgoto TheEnd;\n\n\t/*\n\t * Ensure that inode isn't reused before\n\t * lazy commit thread finishes processing\n\t */\n\tif (tblk->xflag & COMMIT_DELETE) {\n\t\tihold(tblk->u.ip);\n\t\t/*\n\t\t * Avoid a rare deadlock\n\t\t *\n\t\t * If the inode is locked, we may be blocked in\n\t\t * jfs_commit_inode.  If so, we don't want the\n\t\t * lazy_commit thread doing the last iput() on the inode\n\t\t * since that may block on the locked inode.  Instead,\n\t\t * commit the transaction synchronously, so the last iput\n\t\t * will be done by the calling thread (or later)\n\t\t */\n\t\t/*\n\t\t * I believe this code is no longer needed.  Splitting I_LOCK\n\t\t * into two bits, I_NEW and I_SYNC should prevent this\n\t\t * deadlock as well.  But since I don't have a JFS testload\n\t\t * to verify this, only a trivial s/I_LOCK/I_SYNC/ was done.\n\t\t * Joern\n\t\t */\n\t\tif (tblk->u.ip->i_state & I_SYNC)\n\t\t\ttblk->xflag &= ~COMMIT_LAZY;\n\t}\n\n\tASSERT((!(tblk->xflag & COMMIT_DELETE)) ||\n\t       ((tblk->u.ip->i_nlink == 0) &&\n\t\t!test_cflag(COMMIT_Nolink, tblk->u.ip)));\n\n\t/*\n\t *\twrite COMMIT log record\n\t */\n\tlrd->type = cpu_to_le16(LOG_COMMIT);\n\tlrd->length = 0;\n\tlmLog(log, tblk, lrd, NULL);\n\n\tlmGroupCommit(log, tblk);\n\n\t/*\n\t *\t- transaction is now committed -\n\t */\n\n\t/*\n\t * force pages in careful update\n\t * (imap addressing structure update)\n\t */\n\tif (flag & COMMIT_FORCE)\n\t\ttxForce(tblk);\n\n\t/*\n\t *\tupdate allocation map.\n\t *\n\t * update inode allocation map and inode:\n\t * free pager lock on memory object of inode if any.\n\t * update block allocation map.\n\t *\n\t * txUpdateMap() resets XAD_NEW in XAD.\n\t */\n\tif (tblk->xflag & COMMIT_FORCE)\n\t\ttxUpdateMap(tblk);\n\n\t/*\n\t *\tfree transaction locks and pageout/free pages\n\t */\n\ttxRelease(tblk);\n\n\tif ((tblk->flag & tblkGC_LAZY) == 0)\n\t\ttxUnlock(tblk);\n\n\n\t/*\n\t *\treset in-memory object state\n\t */\n\tfor (k = 0; k < cd.nip; k++) {\n\t\tip = cd.iplist[k];\n\t\tjfs_ip = JFS_IP(ip);\n\n\t\t/*\n\t\t * reset in-memory inode state\n\t\t */\n\t\tjfs_ip->bxflag = 0;\n\t\tjfs_ip->blid = 0;\n\t}\n\n      out:\n\tif (rc != 0)\n\t\ttxAbort(tid, 1);\n\n      TheEnd:\n\tjfs_info(\"txCommit: tid = %d, returning %d\", tid, rc);\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "inode_add_bytes",
          "args": [
            "ip",
            "PSIZE"
          ],
          "line": 3030
        },
        "resolved": true,
        "details": {
          "function_name": "inode_add_bytes",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/stat.c",
          "lines": "460-465",
          "snippet": "void inode_add_bytes(struct inode *inode, loff_t bytes)\n{\n\tspin_lock(&inode->i_lock);\n\t__inode_add_bytes(inode, bytes);\n\tspin_unlock(&inode->i_lock);\n}",
          "includes": [
            "#include <asm/unistd.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/highuid.h>",
            "#include <linux/file.h>",
            "#include <linux/errno.h>",
            "#include <linux/mm.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/unistd.h>\n#include <asm/uaccess.h>\n#include <linux/pagemap.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/highuid.h>\n#include <linux/file.h>\n#include <linux/errno.h>\n#include <linux/mm.h>\n#include <linux/export.h>\n\nvoid inode_add_bytes(struct inode *inode, loff_t bytes)\n{\n\tspin_lock(&inode->i_lock);\n\t__inode_add_bytes(inode, bytes);\n\tspin_unlock(&inode->i_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "txAbort",
          "args": [
            "tid",
            "1"
          ],
          "line": 3024
        },
        "resolved": true,
        "details": {
          "function_name": "txAbort",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_txnmgr.c",
          "lines": "2642-2689",
          "snippet": "void txAbort(tid_t tid, int dirty)\n{\n\tlid_t lid, next;\n\tstruct metapage *mp;\n\tstruct tblock *tblk = tid_to_tblock(tid);\n\tstruct tlock *tlck;\n\n\t/*\n\t * free tlocks of the transaction\n\t */\n\tfor (lid = tblk->next; lid; lid = next) {\n\t\ttlck = lid_to_tlock(lid);\n\t\tnext = tlck->next;\n\t\tmp = tlck->mp;\n\t\tJFS_IP(tlck->ip)->xtlid = 0;\n\n\t\tif (mp) {\n\t\t\tmp->lid = 0;\n\n\t\t\t/*\n\t\t\t * reset lsn of page to avoid logwarap:\n\t\t\t *\n\t\t\t * (page may have been previously committed by another\n\t\t\t * transaction(s) but has not been paged, i.e.,\n\t\t\t * it may be on logsync list even though it has not\n\t\t\t * been logged for the current tx.)\n\t\t\t */\n\t\t\tif (mp->xflag & COMMIT_PAGE && mp->lsn)\n\t\t\t\tLogSyncRelease(mp);\n\t\t}\n\t\t/* insert tlock at head of freelist */\n\t\tTXN_LOCK();\n\t\ttxLockFree(lid);\n\t\tTXN_UNLOCK();\n\t}\n\n\t/* caller will free the transaction block */\n\n\ttblk->next = tblk->last = 0;\n\n\t/*\n\t * mark filesystem dirty\n\t */\n\tif (dirty)\n\t\tjfs_error(tblk->sb, \"\\n\");\n\n\treturn;\n}",
          "includes": [
            "#include \"jfs_debug.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_dmap.h\"",
            "#include \"jfs_imap.h\"",
            "#include \"jfs_dinode.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_filsys.h\"",
            "#include \"jfs_inode.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/freezer.h>",
            "#include <linux/completion.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int dataLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t\tstruct tlock * tlck);",
            "static void dtLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t\tstruct tlock * tlck);",
            "static void mapLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t\tstruct tlock * tlck);",
            "static void txAllocPMap(struct inode *ip, struct maplock * maplock,\n\t\tstruct tblock * tblk);",
            "static void txForce(struct tblock * tblk);",
            "static void txUpdateMap(struct tblock * tblk);",
            "static void txRelease(struct tblock * tblk);",
            "static void xtLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t   struct tlock * tlck);",
            "static void LogSyncRelease(struct metapage * mp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_imap.h\"\n#include \"jfs_dinode.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_inode.h\"\n#include \"jfs_incore.h\"\n#include <linux/seq_file.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/freezer.h>\n#include <linux/completion.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n\nstatic int dataLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t\tstruct tlock * tlck);\nstatic void dtLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t\tstruct tlock * tlck);\nstatic void mapLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t\tstruct tlock * tlck);\nstatic void txAllocPMap(struct inode *ip, struct maplock * maplock,\n\t\tstruct tblock * tblk);\nstatic void txForce(struct tblock * tblk);\nstatic void txUpdateMap(struct tblock * tblk);\nstatic void txRelease(struct tblock * tblk);\nstatic void xtLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t   struct tlock * tlck);\nstatic void LogSyncRelease(struct metapage * mp);\n\nvoid txAbort(tid_t tid, int dirty)\n{\n\tlid_t lid, next;\n\tstruct metapage *mp;\n\tstruct tblock *tblk = tid_to_tblock(tid);\n\tstruct tlock *tlck;\n\n\t/*\n\t * free tlocks of the transaction\n\t */\n\tfor (lid = tblk->next; lid; lid = next) {\n\t\ttlck = lid_to_tlock(lid);\n\t\tnext = tlck->next;\n\t\tmp = tlck->mp;\n\t\tJFS_IP(tlck->ip)->xtlid = 0;\n\n\t\tif (mp) {\n\t\t\tmp->lid = 0;\n\n\t\t\t/*\n\t\t\t * reset lsn of page to avoid logwarap:\n\t\t\t *\n\t\t\t * (page may have been previously committed by another\n\t\t\t * transaction(s) but has not been paged, i.e.,\n\t\t\t * it may be on logsync list even though it has not\n\t\t\t * been logged for the current tx.)\n\t\t\t */\n\t\t\tif (mp->xflag & COMMIT_PAGE && mp->lsn)\n\t\t\t\tLogSyncRelease(mp);\n\t\t}\n\t\t/* insert tlock at head of freelist */\n\t\tTXN_LOCK();\n\t\ttxLockFree(lid);\n\t\tTXN_UNLOCK();\n\t}\n\n\t/* caller will free the transaction block */\n\n\ttblk->next = tblk->last = 0;\n\n\t/*\n\t * mark filesystem dirty\n\t */\n\tif (dirty)\n\t\tjfs_error(tblk->sb, \"\\n\");\n\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "JFS_SBI",
          "args": [
            "sb"
          ],
          "line": 3023
        },
        "resolved": true,
        "details": {
          "function_name": "JFS_SBI",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_incore.h",
          "lines": "217-220",
          "snippet": "static inline struct jfs_sb_info *JFS_SBI(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"jfs_dtree.h\"",
            "#include \"jfs_xtree.h\"",
            "#include \"jfs_types.h\"",
            "#include <linux/bitops.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_dtree.h\"\n#include \"jfs_xtree.h\"\n#include \"jfs_types.h\"\n#include <linux/bitops.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mutex.h>\n\nstatic inline struct jfs_sb_info *JFS_SBI(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xtInsert",
          "args": [
            "tid",
            "ip",
            "0",
            "blkno",
            "xlen",
            "xaddr",
            "0"
          ],
          "line": 3022
        },
        "resolved": true,
        "details": {
          "function_name": "xtInsert",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_xtree.c",
          "lines": "537-670",
          "snippet": "int xtInsert(tid_t tid,\t\t/* transaction id */\n\t     struct inode *ip, int xflag, s64 xoff, s32 xlen, s64 * xaddrp,\n\t     int flag)\n{\n\tint rc = 0;\n\ts64 xaddr, hint;\n\tstruct metapage *mp;\t/* meta-page buffer */\n\txtpage_t *p;\t\t/* base B+-tree index page */\n\ts64 bn;\n\tint index, nextindex;\n\tstruct btstack btstack;\t/* traverse stack */\n\tstruct xtsplit split;\t/* split information */\n\txad_t *xad;\n\tint cmp;\n\ts64 next;\n\tstruct tlock *tlck;\n\tstruct xtlock *xtlck;\n\n\tjfs_info(\"xtInsert: nxoff:0x%lx nxlen:0x%x\", (ulong) xoff, xlen);\n\n\t/*\n\t *\tsearch for the entry location at which to insert:\n\t *\n\t * xtFastSearch() and xtSearch() both returns (leaf page\n\t * pinned, index at which to insert).\n\t * n.b. xtSearch() may return index of maxentry of\n\t * the full page.\n\t */\n\tif ((rc = xtSearch(ip, xoff, &next, &cmp, &btstack, XT_INSERT)))\n\t\treturn rc;\n\n\t/* retrieve search result */\n\tXT_GETSEARCH(ip, btstack.top, bn, mp, p, index);\n\n\t/* This test must follow XT_GETSEARCH since mp must be valid if\n\t * we branch to out: */\n\tif ((cmp == 0) || (next && (xlen > next - xoff))) {\n\t\trc = -EEXIST;\n\t\tgoto out;\n\t}\n\n\t/*\n\t * allocate data extent requested\n\t *\n\t * allocation hint: last xad\n\t */\n\tif ((xaddr = *xaddrp) == 0) {\n\t\tif (index > XTENTRYSTART) {\n\t\t\txad = &p->xad[index - 1];\n\t\t\thint = addressXAD(xad) + lengthXAD(xad) - 1;\n\t\t} else\n\t\t\thint = 0;\n\t\tif ((rc = dquot_alloc_block(ip, xlen)))\n\t\t\tgoto out;\n\t\tif ((rc = dbAlloc(ip, hint, (s64) xlen, &xaddr))) {\n\t\t\tdquot_free_block(ip, xlen);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\t/*\n\t *\tinsert entry for new extent\n\t */\n\txflag |= XAD_NEW;\n\n\t/*\n\t *\tif the leaf page is full, split the page and\n\t *\tpropagate up the router entry for the new page from split\n\t *\n\t * The xtSplitUp() will insert the entry and unpin the leaf page.\n\t */\n\tnextindex = le16_to_cpu(p->header.nextindex);\n\tif (nextindex == le16_to_cpu(p->header.maxentry)) {\n\t\tsplit.mp = mp;\n\t\tsplit.index = index;\n\t\tsplit.flag = xflag;\n\t\tsplit.off = xoff;\n\t\tsplit.len = xlen;\n\t\tsplit.addr = xaddr;\n\t\tsplit.pxdlist = NULL;\n\t\tif ((rc = xtSplitUp(tid, ip, &split, &btstack))) {\n\t\t\t/* undo data extent allocation */\n\t\t\tif (*xaddrp == 0) {\n\t\t\t\tdbFree(ip, xaddr, (s64) xlen);\n\t\t\t\tdquot_free_block(ip, xlen);\n\t\t\t}\n\t\t\treturn rc;\n\t\t}\n\n\t\t*xaddrp = xaddr;\n\t\treturn 0;\n\t}\n\n\t/*\n\t *\tinsert the new entry into the leaf page\n\t */\n\t/*\n\t * acquire a transaction lock on the leaf page;\n\t *\n\t * action: xad insertion/extension;\n\t */\n\tBT_MARK_DIRTY(mp, ip);\n\n\t/* if insert into middle, shift right remaining entries. */\n\tif (index < nextindex)\n\t\tmemmove(&p->xad[index + 1], &p->xad[index],\n\t\t\t(nextindex - index) * sizeof(xad_t));\n\n\t/* insert the new entry: mark the entry NEW */\n\txad = &p->xad[index];\n\tXT_PUTENTRY(xad, xflag, xoff, xlen, xaddr);\n\n\t/* advance next available entry index */\n\tle16_add_cpu(&p->header.nextindex, 1);\n\n\t/* Don't log it if there are no links to the file */\n\tif (!test_cflag(COMMIT_Nolink, ip)) {\n\t\ttlck = txLock(tid, ip, mp, tlckXTREE | tlckGROW);\n\t\txtlck = (struct xtlock *) & tlck->lock;\n\t\txtlck->lwm.offset =\n\t\t    (xtlck->lwm.offset) ? min(index,\n\t\t\t\t\t      (int)xtlck->lwm.offset) : index;\n\t\txtlck->lwm.length =\n\t\t    le16_to_cpu(p->header.nextindex) - xtlck->lwm.offset;\n\t}\n\n\t*xaddrp = xaddr;\n\n      out:\n\t/* unpin the leaf page */\n\tXT_PUTPAGE(mp);\n\n\treturn rc;\n}",
          "includes": [
            "#include \"jfs_debug.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_dinode.h\"",
            "#include \"jfs_dmap.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_filsys.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/module.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [
            "#define XT_INSERT\t0x00000001"
          ],
          "globals_used": [
            "static int xtSearch(struct inode *ip, s64 xoff, s64 *next, int *cmpp,\n\t\t    struct btstack * btstack, int flag);",
            "static int xtSplitUp(tid_t tid,\n\t\t     struct inode *ip,\n\t\t     struct xtsplit * split, struct btstack * btstack);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_dinode.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_incore.h\"\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/module.h>\n#include <linux/fs.h>\n\n#define XT_INSERT\t0x00000001\n\nstatic int xtSearch(struct inode *ip, s64 xoff, s64 *next, int *cmpp,\n\t\t    struct btstack * btstack, int flag);\nstatic int xtSplitUp(tid_t tid,\n\t\t     struct inode *ip,\n\t\t     struct xtsplit * split, struct btstack * btstack);\n\nint xtInsert(tid_t tid,\t\t/* transaction id */\n\t     struct inode *ip, int xflag, s64 xoff, s32 xlen, s64 * xaddrp,\n\t     int flag)\n{\n\tint rc = 0;\n\ts64 xaddr, hint;\n\tstruct metapage *mp;\t/* meta-page buffer */\n\txtpage_t *p;\t\t/* base B+-tree index page */\n\ts64 bn;\n\tint index, nextindex;\n\tstruct btstack btstack;\t/* traverse stack */\n\tstruct xtsplit split;\t/* split information */\n\txad_t *xad;\n\tint cmp;\n\ts64 next;\n\tstruct tlock *tlck;\n\tstruct xtlock *xtlck;\n\n\tjfs_info(\"xtInsert: nxoff:0x%lx nxlen:0x%x\", (ulong) xoff, xlen);\n\n\t/*\n\t *\tsearch for the entry location at which to insert:\n\t *\n\t * xtFastSearch() and xtSearch() both returns (leaf page\n\t * pinned, index at which to insert).\n\t * n.b. xtSearch() may return index of maxentry of\n\t * the full page.\n\t */\n\tif ((rc = xtSearch(ip, xoff, &next, &cmp, &btstack, XT_INSERT)))\n\t\treturn rc;\n\n\t/* retrieve search result */\n\tXT_GETSEARCH(ip, btstack.top, bn, mp, p, index);\n\n\t/* This test must follow XT_GETSEARCH since mp must be valid if\n\t * we branch to out: */\n\tif ((cmp == 0) || (next && (xlen > next - xoff))) {\n\t\trc = -EEXIST;\n\t\tgoto out;\n\t}\n\n\t/*\n\t * allocate data extent requested\n\t *\n\t * allocation hint: last xad\n\t */\n\tif ((xaddr = *xaddrp) == 0) {\n\t\tif (index > XTENTRYSTART) {\n\t\t\txad = &p->xad[index - 1];\n\t\t\thint = addressXAD(xad) + lengthXAD(xad) - 1;\n\t\t} else\n\t\t\thint = 0;\n\t\tif ((rc = dquot_alloc_block(ip, xlen)))\n\t\t\tgoto out;\n\t\tif ((rc = dbAlloc(ip, hint, (s64) xlen, &xaddr))) {\n\t\t\tdquot_free_block(ip, xlen);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\t/*\n\t *\tinsert entry for new extent\n\t */\n\txflag |= XAD_NEW;\n\n\t/*\n\t *\tif the leaf page is full, split the page and\n\t *\tpropagate up the router entry for the new page from split\n\t *\n\t * The xtSplitUp() will insert the entry and unpin the leaf page.\n\t */\n\tnextindex = le16_to_cpu(p->header.nextindex);\n\tif (nextindex == le16_to_cpu(p->header.maxentry)) {\n\t\tsplit.mp = mp;\n\t\tsplit.index = index;\n\t\tsplit.flag = xflag;\n\t\tsplit.off = xoff;\n\t\tsplit.len = xlen;\n\t\tsplit.addr = xaddr;\n\t\tsplit.pxdlist = NULL;\n\t\tif ((rc = xtSplitUp(tid, ip, &split, &btstack))) {\n\t\t\t/* undo data extent allocation */\n\t\t\tif (*xaddrp == 0) {\n\t\t\t\tdbFree(ip, xaddr, (s64) xlen);\n\t\t\t\tdquot_free_block(ip, xlen);\n\t\t\t}\n\t\t\treturn rc;\n\t\t}\n\n\t\t*xaddrp = xaddr;\n\t\treturn 0;\n\t}\n\n\t/*\n\t *\tinsert the new entry into the leaf page\n\t */\n\t/*\n\t * acquire a transaction lock on the leaf page;\n\t *\n\t * action: xad insertion/extension;\n\t */\n\tBT_MARK_DIRTY(mp, ip);\n\n\t/* if insert into middle, shift right remaining entries. */\n\tif (index < nextindex)\n\t\tmemmove(&p->xad[index + 1], &p->xad[index],\n\t\t\t(nextindex - index) * sizeof(xad_t));\n\n\t/* insert the new entry: mark the entry NEW */\n\txad = &p->xad[index];\n\tXT_PUTENTRY(xad, xflag, xoff, xlen, xaddr);\n\n\t/* advance next available entry index */\n\tle16_add_cpu(&p->header.nextindex, 1);\n\n\t/* Don't log it if there are no links to the file */\n\tif (!test_cflag(COMMIT_Nolink, ip)) {\n\t\ttlck = txLock(tid, ip, mp, tlckXTREE | tlckGROW);\n\t\txtlck = (struct xtlock *) & tlck->lock;\n\t\txtlck->lwm.offset =\n\t\t    (xtlck->lwm.offset) ? min(index,\n\t\t\t\t\t      (int)xtlck->lwm.offset) : index;\n\t\txtlck->lwm.length =\n\t\t    le16_to_cpu(p->header.nextindex) - xtlck->lwm.offset;\n\t}\n\n\t*xaddrp = xaddr;\n\n      out:\n\t/* unpin the leaf page */\n\tXT_PUTPAGE(mp);\n\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "txBegin",
          "args": [
            "sb",
            "COMMIT_FORCE"
          ],
          "line": 3020
        },
        "resolved": true,
        "details": {
          "function_name": "txBegin",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_txnmgr.c",
          "lines": "361-447",
          "snippet": "tid_t txBegin(struct super_block *sb, int flag)\n{\n\ttid_t t;\n\tstruct tblock *tblk;\n\tstruct jfs_log *log;\n\n\tjfs_info(\"txBegin: flag = 0x%x\", flag);\n\tlog = JFS_SBI(sb)->log;\n\n\tTXN_LOCK();\n\n\tINCREMENT(TxStat.txBegin);\n\n      retry:\n\tif (!(flag & COMMIT_FORCE)) {\n\t\t/*\n\t\t * synchronize with logsync barrier\n\t\t */\n\t\tif (test_bit(log_SYNCBARRIER, &log->flag) ||\n\t\t    test_bit(log_QUIESCE, &log->flag)) {\n\t\t\tINCREMENT(TxStat.txBegin_barrier);\n\t\t\tTXN_SLEEP(&log->syncwait);\n\t\t\tgoto retry;\n\t\t}\n\t}\n\tif (flag == 0) {\n\t\t/*\n\t\t * Don't begin transaction if we're getting starved for tlocks\n\t\t * unless COMMIT_FORCE or COMMIT_INODE (which may ultimately\n\t\t * free tlocks)\n\t\t */\n\t\tif (TxAnchor.tlocksInUse > TxLockVHWM) {\n\t\t\tINCREMENT(TxStat.txBegin_lockslow);\n\t\t\tTXN_SLEEP(&TxAnchor.lowlockwait);\n\t\t\tgoto retry;\n\t\t}\n\t}\n\n\t/*\n\t * allocate transaction id/block\n\t */\n\tif ((t = TxAnchor.freetid) == 0) {\n\t\tjfs_info(\"txBegin: waiting for free tid\");\n\t\tINCREMENT(TxStat.txBegin_freetid);\n\t\tTXN_SLEEP(&TxAnchor.freewait);\n\t\tgoto retry;\n\t}\n\n\ttblk = tid_to_tblock(t);\n\n\tif ((tblk->next == 0) && !(flag & COMMIT_FORCE)) {\n\t\t/* Don't let a non-forced transaction take the last tblk */\n\t\tjfs_info(\"txBegin: waiting for free tid\");\n\t\tINCREMENT(TxStat.txBegin_freetid);\n\t\tTXN_SLEEP(&TxAnchor.freewait);\n\t\tgoto retry;\n\t}\n\n\tTxAnchor.freetid = tblk->next;\n\n\t/*\n\t * initialize transaction\n\t */\n\n\t/*\n\t * We can't zero the whole thing or we screw up another thread being\n\t * awakened after sleeping on tblk->waitor\n\t *\n\t * memset(tblk, 0, sizeof(struct tblock));\n\t */\n\ttblk->next = tblk->last = tblk->xflag = tblk->flag = tblk->lsn = 0;\n\n\ttblk->sb = sb;\n\t++log->logtid;\n\ttblk->logtid = log->logtid;\n\n\t++log->active;\n\n\tHIGHWATERMARK(stattx.maxtid, t);\t/* statistics */\n\tINCREMENT(stattx.ntid);\t/* statistics */\n\n\tTXN_UNLOCK();\n\n\tjfs_info(\"txBegin: returning tid = %d\", t);\n\n\treturn t;\n}",
          "includes": [
            "#include \"jfs_debug.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_dmap.h\"",
            "#include \"jfs_imap.h\"",
            "#include \"jfs_dinode.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_filsys.h\"",
            "#include \"jfs_inode.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/freezer.h>",
            "#include <linux/completion.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct {\n\tint freetid;\t\t/* index of a free tid structure */\n\tint freelock;\t\t/* index first free lock word */\n\twait_queue_head_t freewait;\t/* eventlist of free tblock */\n\twait_queue_head_t freelockwait;\t/* eventlist of free tlock */\n\twait_queue_head_t lowlockwait;\t/* eventlist of ample tlocks */\n\tint tlocksInUse;\t/* Number of tlocks in use */\n\tspinlock_t LazyLock;\t/* synchronize sync_queue & unlock_queue */\n/*\tstruct tblock *sync_queue; * Transactions waiting for data sync */\n\tstruct list_head unlock_queue;\t/* Txns waiting to be released */\n\tstruct list_head anon_list;\t/* inodes having anonymous txns */\n\tstruct list_head anon_list2;\t/* inodes having anonymous txns\n\t\t\t\t\t   that couldn't be sync'ed */\n} TxAnchor;",
            "static int TxLockVHWM;",
            "static struct {\n\ttid_t maxtid;\t\t/* 4: biggest tid ever used */\n\tlid_t maxlid;\t\t/* 4: biggest lid ever used */\n\tint ntid;\t\t/* 4: # of transactions performed */\n\tint nlid;\t\t/* 4: # of tlocks acquired */\n\tint waitlock;\t\t/* 4: # of tlock wait */\n} stattx;",
            "static void txAllocPMap(struct inode *ip, struct maplock * maplock,\n\t\tstruct tblock * tblk);",
            "static void txForce(struct tblock * tblk);",
            "static void txUpdateMap(struct tblock * tblk);",
            "static void txRelease(struct tblock * tblk);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_imap.h\"\n#include \"jfs_dinode.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_inode.h\"\n#include \"jfs_incore.h\"\n#include <linux/seq_file.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/freezer.h>\n#include <linux/completion.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n\nstatic struct {\n\tint freetid;\t\t/* index of a free tid structure */\n\tint freelock;\t\t/* index first free lock word */\n\twait_queue_head_t freewait;\t/* eventlist of free tblock */\n\twait_queue_head_t freelockwait;\t/* eventlist of free tlock */\n\twait_queue_head_t lowlockwait;\t/* eventlist of ample tlocks */\n\tint tlocksInUse;\t/* Number of tlocks in use */\n\tspinlock_t LazyLock;\t/* synchronize sync_queue & unlock_queue */\n/*\tstruct tblock *sync_queue; * Transactions waiting for data sync */\n\tstruct list_head unlock_queue;\t/* Txns waiting to be released */\n\tstruct list_head anon_list;\t/* inodes having anonymous txns */\n\tstruct list_head anon_list2;\t/* inodes having anonymous txns\n\t\t\t\t\t   that couldn't be sync'ed */\n} TxAnchor;\nstatic int TxLockVHWM;\nstatic struct {\n\ttid_t maxtid;\t\t/* 4: biggest tid ever used */\n\tlid_t maxlid;\t\t/* 4: biggest lid ever used */\n\tint ntid;\t\t/* 4: # of transactions performed */\n\tint nlid;\t\t/* 4: # of tlocks acquired */\n\tint waitlock;\t\t/* 4: # of tlock wait */\n} stattx;\nstatic void txAllocPMap(struct inode *ip, struct maplock * maplock,\n\t\tstruct tblock * tblk);\nstatic void txForce(struct tblock * tblk);\nstatic void txUpdateMap(struct tblock * tblk);\nstatic void txRelease(struct tblock * tblk);\n\ntid_t txBegin(struct super_block *sb, int flag)\n{\n\ttid_t t;\n\tstruct tblock *tblk;\n\tstruct jfs_log *log;\n\n\tjfs_info(\"txBegin: flag = 0x%x\", flag);\n\tlog = JFS_SBI(sb)->log;\n\n\tTXN_LOCK();\n\n\tINCREMENT(TxStat.txBegin);\n\n      retry:\n\tif (!(flag & COMMIT_FORCE)) {\n\t\t/*\n\t\t * synchronize with logsync barrier\n\t\t */\n\t\tif (test_bit(log_SYNCBARRIER, &log->flag) ||\n\t\t    test_bit(log_QUIESCE, &log->flag)) {\n\t\t\tINCREMENT(TxStat.txBegin_barrier);\n\t\t\tTXN_SLEEP(&log->syncwait);\n\t\t\tgoto retry;\n\t\t}\n\t}\n\tif (flag == 0) {\n\t\t/*\n\t\t * Don't begin transaction if we're getting starved for tlocks\n\t\t * unless COMMIT_FORCE or COMMIT_INODE (which may ultimately\n\t\t * free tlocks)\n\t\t */\n\t\tif (TxAnchor.tlocksInUse > TxLockVHWM) {\n\t\t\tINCREMENT(TxStat.txBegin_lockslow);\n\t\t\tTXN_SLEEP(&TxAnchor.lowlockwait);\n\t\t\tgoto retry;\n\t\t}\n\t}\n\n\t/*\n\t * allocate transaction id/block\n\t */\n\tif ((t = TxAnchor.freetid) == 0) {\n\t\tjfs_info(\"txBegin: waiting for free tid\");\n\t\tINCREMENT(TxStat.txBegin_freetid);\n\t\tTXN_SLEEP(&TxAnchor.freewait);\n\t\tgoto retry;\n\t}\n\n\ttblk = tid_to_tblock(t);\n\n\tif ((tblk->next == 0) && !(flag & COMMIT_FORCE)) {\n\t\t/* Don't let a non-forced transaction take the last tblk */\n\t\tjfs_info(\"txBegin: waiting for free tid\");\n\t\tINCREMENT(TxStat.txBegin_freetid);\n\t\tTXN_SLEEP(&TxAnchor.freewait);\n\t\tgoto retry;\n\t}\n\n\tTxAnchor.freetid = tblk->next;\n\n\t/*\n\t * initialize transaction\n\t */\n\n\t/*\n\t * We can't zero the whole thing or we screw up another thread being\n\t * awakened after sleeping on tblk->waitor\n\t *\n\t * memset(tblk, 0, sizeof(struct tblock));\n\t */\n\ttblk->next = tblk->last = tblk->xflag = tblk->flag = tblk->lsn = 0;\n\n\ttblk->sb = sb;\n\t++log->logtid;\n\ttblk->logtid = log->logtid;\n\n\t++log->active;\n\n\tHIGHWATERMARK(stattx.maxtid, t);\t/* statistics */\n\tINCREMENT(stattx.ntid);\t/* statistics */\n\n\tTXN_UNLOCK();\n\n\tjfs_info(\"txBegin: returning tid = %d\", t);\n\n\treturn t;\n}"
        }
      },
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "bh"
          ],
          "line": 3015
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "sync_dirty_buffer",
          "args": [
            "bh"
          ],
          "line": 3014
        },
        "resolved": true,
        "details": {
          "function_name": "sync_dirty_buffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "3153-3156",
          "snippet": "int sync_dirty_buffer(struct buffer_head *bh)\n{\n\treturn __sync_dirty_buffer(bh, WRITE_SYNC);\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nint sync_dirty_buffer(struct buffer_head *bh)\n{\n\treturn __sync_dirty_buffer(bh, WRITE_SYNC);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mark_buffer_dirty",
          "args": [
            "bh"
          ],
          "line": 3013
        },
        "resolved": true,
        "details": {
          "function_name": "mark_buffer_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1141-1167",
          "snippet": "void mark_buffer_dirty(struct buffer_head *bh)\n{\n\tWARN_ON_ONCE(!buffer_uptodate(bh));\n\n\ttrace_block_dirty_buffer(bh);\n\n\t/*\n\t * Very *carefully* optimize the it-is-already-dirty case.\n\t *\n\t * Don't let the final \"is it dirty\" escape to before we\n\t * perhaps modified the buffer.\n\t */\n\tif (buffer_dirty(bh)) {\n\t\tsmp_mb();\n\t\tif (buffer_dirty(bh))\n\t\t\treturn;\n\t}\n\n\tif (!test_set_buffer_dirty(bh)) {\n\t\tstruct page *page = bh->b_page;\n\t\tif (!TestSetPageDirty(page)) {\n\t\t\tstruct address_space *mapping = page_mapping(page);\n\t\t\tif (mapping)\n\t\t\t\t__set_page_dirty(page, mapping, 0);\n\t\t}\n\t}\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid mark_buffer_dirty(struct buffer_head *bh)\n{\n\tWARN_ON_ONCE(!buffer_uptodate(bh));\n\n\ttrace_block_dirty_buffer(bh);\n\n\t/*\n\t * Very *carefully* optimize the it-is-already-dirty case.\n\t *\n\t * Don't let the final \"is it dirty\" escape to before we\n\t * perhaps modified the buffer.\n\t */\n\tif (buffer_dirty(bh)) {\n\t\tsmp_mb();\n\t\tif (buffer_dirty(bh))\n\t\t\treturn;\n\t}\n\n\tif (!test_set_buffer_dirty(bh)) {\n\t\tstruct page *page = bh->b_page;\n\t\tif (!TestSetPageDirty(page)) {\n\t\t\tstruct address_space *mapping = page_mapping(page);\n\t\t\tif (mapping)\n\t\t\t\t__set_page_dirty(page, mapping, 0);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "JFS_BAD_SAIT"
          ],
          "line": 3011
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "readSuper",
          "args": [
            "sb",
            "&bh"
          ],
          "line": 3008
        },
        "resolved": true,
        "details": {
          "function_name": "readSuper",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_mount.c",
          "lines": "464-477",
          "snippet": "int readSuper(struct super_block *sb, struct buffer_head **bpp)\n{\n\t/* read in primary superblock */\n\t*bpp = sb_bread(sb, SUPER1_OFF >> sb->s_blocksize_bits);\n\tif (*bpp)\n\t\treturn 0;\n\n\t/* read in secondary/replicated superblock */\n\t*bpp = sb_bread(sb, SUPER2_OFF >> sb->s_blocksize_bits);\n\tif (*bpp)\n\t\treturn 0;\n\n\treturn -EIO;\n}",
          "includes": [
            "#include \"jfs_debug.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_imap.h\"",
            "#include \"jfs_dmap.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_filsys.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/buffer_head.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int chkSuper(struct super_block *);",
            "static int logMOUNT(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_imap.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_incore.h\"\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n\nstatic int chkSuper(struct super_block *);\nstatic int logMOUNT(struct super_block *sb);\n\nint readSuper(struct super_block *sb, struct buffer_head **bpp)\n{\n\t/* read in primary superblock */\n\t*bpp = sb_bread(sb, SUPER1_OFF >> sb->s_blocksize_bits);\n\tif (*bpp)\n\t\treturn 0;\n\n\t/* read in secondary/replicated superblock */\n\t*bpp = sb_bread(sb, SUPER2_OFF >> sb->s_blocksize_bits);\n\tif (*bpp)\n\t\treturn 0;\n\n\treturn -EIO;\n}"
        }
      },
      {
        "call_info": {
          "callee": "diReadSpecial",
          "args": [
            "sb",
            "FILESYSTEM_I",
            "1"
          ],
          "line": 3005
        },
        "resolved": true,
        "details": {
          "function_name": "diReadSpecial",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_imap.c",
          "lines": "429-503",
          "snippet": "struct inode *diReadSpecial(struct super_block *sb, ino_t inum, int secondary)\n{\n\tstruct jfs_sb_info *sbi = JFS_SBI(sb);\n\tuint address;\n\tstruct dinode *dp;\n\tstruct inode *ip;\n\tstruct metapage *mp;\n\n\tip = new_inode(sb);\n\tif (ip == NULL) {\n\t\tjfs_err(\"diReadSpecial: new_inode returned NULL!\");\n\t\treturn ip;\n\t}\n\n\tif (secondary) {\n\t\taddress = addressPXD(&sbi->ait2) >> sbi->l2nbperpage;\n\t\tJFS_IP(ip)->ipimap = sbi->ipaimap2;\n\t} else {\n\t\taddress = AITBL_OFF >> L2PSIZE;\n\t\tJFS_IP(ip)->ipimap = sbi->ipaimap;\n\t}\n\n\tASSERT(inum < INOSPEREXT);\n\n\tip->i_ino = inum;\n\n\taddress += inum >> 3;\t/* 8 inodes per 4K page */\n\n\t/* read the page of fixed disk inode (AIT) in raw mode */\n\tmp = read_metapage(ip, address << sbi->l2nbperpage, PSIZE, 1);\n\tif (mp == NULL) {\n\t\tset_nlink(ip, 1);\t/* Don't want iput() deleting it */\n\t\tiput(ip);\n\t\treturn (NULL);\n\t}\n\n\t/* get the pointer to the disk inode of interest */\n\tdp = (struct dinode *) (mp->data);\n\tdp += inum % 8;\t\t/* 8 inodes per 4K page */\n\n\t/* copy on-disk inode to in-memory inode */\n\tif ((copy_from_dinode(dp, ip)) != 0) {\n\t\t/* handle bad return by returning NULL for ip */\n\t\tset_nlink(ip, 1);\t/* Don't want iput() deleting it */\n\t\tiput(ip);\n\t\t/* release the page */\n\t\trelease_metapage(mp);\n\t\treturn (NULL);\n\n\t}\n\n\tip->i_mapping->a_ops = &jfs_metapage_aops;\n\tmapping_set_gfp_mask(ip->i_mapping, GFP_NOFS);\n\n\t/* Allocations to metadata inodes should not affect quotas */\n\tip->i_flags |= S_NOQUOTA;\n\n\tif ((inum == FILESYSTEM_I) && (JFS_IP(ip)->ipimap == sbi->ipaimap)) {\n\t\tsbi->gengen = le32_to_cpu(dp->di_gengen);\n\t\tsbi->inostamp = le32_to_cpu(dp->di_inostamp);\n\t}\n\n\t/* release the page */\n\trelease_metapage(mp);\n\n\t/*\n\t * __mark_inode_dirty expects inodes to be hashed.  Since we don't\n\t * want special inodes in the fileset inode space, we make them\n\t * appear hashed, but do not put on any lists.  hlist_del()\n\t * will work fine and require no locking.\n\t */\n\thlist_add_fake(&ip->i_hash);\n\n\treturn (ip);\n}",
          "includes": [
            "#include \"jfs_debug.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_imap.h\"",
            "#include \"jfs_dmap.h\"",
            "#include \"jfs_dinode.h\"",
            "#include \"jfs_filsys.h\"",
            "#include \"jfs_inode.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/slab.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int diAllocAG(struct inomap *, int, bool, struct inode *);",
            "static int diAllocAny(struct inomap *, int, bool, struct inode *);",
            "static int diAllocExt(struct inomap *, int, struct inode *);",
            "static int diAllocIno(struct inomap *, int, struct inode *);",
            "static int diNewIAG(struct inomap *, int *, int, struct metapage **);",
            "static int diIAGRead(struct inomap * imap, int, struct metapage **);",
            "static int copy_from_dinode(struct dinode *, struct inode *);",
            "static void copy_to_dinode(struct dinode *, struct inode *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_imap.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_dinode.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_inode.h\"\n#include \"jfs_incore.h\"\n#include <linux/slab.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n\nstatic int diAllocAG(struct inomap *, int, bool, struct inode *);\nstatic int diAllocAny(struct inomap *, int, bool, struct inode *);\nstatic int diAllocExt(struct inomap *, int, struct inode *);\nstatic int diAllocIno(struct inomap *, int, struct inode *);\nstatic int diNewIAG(struct inomap *, int *, int, struct metapage **);\nstatic int diIAGRead(struct inomap * imap, int, struct metapage **);\nstatic int copy_from_dinode(struct dinode *, struct inode *);\nstatic void copy_to_dinode(struct dinode *, struct inode *);\n\nstruct inode *diReadSpecial(struct super_block *sb, ino_t inum, int secondary)\n{\n\tstruct jfs_sb_info *sbi = JFS_SBI(sb);\n\tuint address;\n\tstruct dinode *dp;\n\tstruct inode *ip;\n\tstruct metapage *mp;\n\n\tip = new_inode(sb);\n\tif (ip == NULL) {\n\t\tjfs_err(\"diReadSpecial: new_inode returned NULL!\");\n\t\treturn ip;\n\t}\n\n\tif (secondary) {\n\t\taddress = addressPXD(&sbi->ait2) >> sbi->l2nbperpage;\n\t\tJFS_IP(ip)->ipimap = sbi->ipaimap2;\n\t} else {\n\t\taddress = AITBL_OFF >> L2PSIZE;\n\t\tJFS_IP(ip)->ipimap = sbi->ipaimap;\n\t}\n\n\tASSERT(inum < INOSPEREXT);\n\n\tip->i_ino = inum;\n\n\taddress += inum >> 3;\t/* 8 inodes per 4K page */\n\n\t/* read the page of fixed disk inode (AIT) in raw mode */\n\tmp = read_metapage(ip, address << sbi->l2nbperpage, PSIZE, 1);\n\tif (mp == NULL) {\n\t\tset_nlink(ip, 1);\t/* Don't want iput() deleting it */\n\t\tiput(ip);\n\t\treturn (NULL);\n\t}\n\n\t/* get the pointer to the disk inode of interest */\n\tdp = (struct dinode *) (mp->data);\n\tdp += inum % 8;\t\t/* 8 inodes per 4K page */\n\n\t/* copy on-disk inode to in-memory inode */\n\tif ((copy_from_dinode(dp, ip)) != 0) {\n\t\t/* handle bad return by returning NULL for ip */\n\t\tset_nlink(ip, 1);\t/* Don't want iput() deleting it */\n\t\tiput(ip);\n\t\t/* release the page */\n\t\trelease_metapage(mp);\n\t\treturn (NULL);\n\n\t}\n\n\tip->i_mapping->a_ops = &jfs_metapage_aops;\n\tmapping_set_gfp_mask(ip->i_mapping, GFP_NOFS);\n\n\t/* Allocations to metadata inodes should not affect quotas */\n\tip->i_flags |= S_NOQUOTA;\n\n\tif ((inum == FILESYSTEM_I) && (JFS_IP(ip)->ipimap == sbi->ipaimap)) {\n\t\tsbi->gengen = le32_to_cpu(dp->di_gengen);\n\t\tsbi->inostamp = le32_to_cpu(dp->di_inostamp);\n\t}\n\n\t/* release the page */\n\trelease_metapage(mp);\n\n\t/*\n\t * __mark_inode_dirty expects inodes to be hashed.  Since we don't\n\t * want special inodes in the fileset inode space, we make them\n\t * appear hashed, but do not put on any lists.  hlist_del()\n\t * will work fine and require no locking.\n\t */\n\thlist_add_fake(&ip->i_hash);\n\n\treturn (ip);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_imap.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_dinode.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_inode.h\"\n#include \"jfs_incore.h\"\n#include <linux/slab.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n\nstatic int diAllocAG(struct inomap *, int, bool, struct inode *);\nstatic int diAllocAny(struct inomap *, int, bool, struct inode *);\nstatic int diAllocExt(struct inomap *, int, struct inode *);\nstatic int diAllocIno(struct inomap *, int, struct inode *);\nstatic void duplicateIXtree(struct super_block *, s64, int, s64 *);\nstatic int copy_from_dinode(struct dinode *, struct inode *);\nstatic void copy_to_dinode(struct dinode *, struct inode *);\n\nstatic void duplicateIXtree(struct super_block *sb, s64 blkno,\n\t\t\t    int xlen, s64 *xaddr)\n{\n\tstruct jfs_superblock *j_sb;\n\tstruct buffer_head *bh;\n\tstruct inode *ip;\n\ttid_t tid;\n\n\t/* if AIT2 ipmap2 is bad, do not try to update it */\n\tif (JFS_SBI(sb)->mntflag & JFS_BAD_SAIT)\t/* s_flag */\n\t\treturn;\n\tip = diReadSpecial(sb, FILESYSTEM_I, 1);\n\tif (ip == NULL) {\n\t\tJFS_SBI(sb)->mntflag |= JFS_BAD_SAIT;\n\t\tif (readSuper(sb, &bh))\n\t\t\treturn;\n\t\tj_sb = (struct jfs_superblock *)bh->b_data;\n\t\tj_sb->s_flag |= cpu_to_le32(JFS_BAD_SAIT);\n\n\t\tmark_buffer_dirty(bh);\n\t\tsync_dirty_buffer(bh);\n\t\tbrelse(bh);\n\t\treturn;\n\t}\n\n\t/* start transaction */\n\ttid = txBegin(sb, COMMIT_FORCE);\n\t/* update the inode map addressing structure to point to it */\n\tif (xtInsert(tid, ip, 0, blkno, xlen, xaddr, 0)) {\n\t\tJFS_SBI(sb)->mntflag |= JFS_BAD_SAIT;\n\t\ttxAbort(tid, 1);\n\t\tgoto cleanup;\n\n\t}\n\t/* update the inode map's inode to reflect the extension */\n\tip->i_size += PSIZE;\n\tinode_add_bytes(ip, PSIZE);\n\ttxCommit(tid, 1, &ip, COMMIT_FORCE);\n      cleanup:\n\ttxEnd(tid);\n\tdiFreeSpecial(ip);\n}"
  },
  {
    "function_name": "diExtendFS",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_imap.c",
    "lines": "2859-2984",
    "snippet": "int diExtendFS(struct inode *ipimap, struct inode *ipbmap)\n{\n\tint rc, rcx = 0;\n\tstruct inomap *imap = JFS_IP(ipimap)->i_imap;\n\tstruct iag *iagp = NULL, *hiagp = NULL;\n\tstruct bmap *mp = JFS_SBI(ipbmap->i_sb)->bmap;\n\tstruct metapage *bp, *hbp;\n\tint i, n, head;\n\tint numinos, xnuminos = 0, xnumfree = 0;\n\ts64 agstart;\n\n\tjfs_info(\"diExtendFS: nextiag:%d numinos:%d numfree:%d\",\n\t\t   imap->im_nextiag, atomic_read(&imap->im_numinos),\n\t\t   atomic_read(&imap->im_numfree));\n\n\t/*\n\t *\treconstruct imap\n\t *\n\t * coalesce contiguous k (newAGSize/oldAGSize) AGs;\n\t * i.e., (AGi, ..., AGj) where i = k*n and j = k*(n+1) - 1 to AGn;\n\t * note: new AG size = old AG size * (2**x).\n\t */\n\n\t/* init per AG control information im_agctl[] */\n\tfor (i = 0; i < MAXAG; i++) {\n\t\timap->im_agctl[i].inofree = -1;\n\t\timap->im_agctl[i].extfree = -1;\n\t\timap->im_agctl[i].numinos = 0;\t/* number of backed inodes */\n\t\timap->im_agctl[i].numfree = 0;\t/* number of free backed inodes */\n\t}\n\n\t/*\n\t *\tprocess each iag page of the map.\n\t *\n\t * rebuild AG Free Inode List, AG Free Inode Extent List;\n\t */\n\tfor (i = 0; i < imap->im_nextiag; i++) {\n\t\tif ((rc = diIAGRead(imap, i, &bp))) {\n\t\t\trcx = rc;\n\t\t\tcontinue;\n\t\t}\n\t\tiagp = (struct iag *) bp->data;\n\t\tif (le32_to_cpu(iagp->iagnum) != i) {\n\t\t\trelease_metapage(bp);\n\t\t\tjfs_error(ipimap->i_sb, \"unexpected value of iagnum\\n\");\n\t\t\treturn -EIO;\n\t\t}\n\n\t\t/* leave free iag in the free iag list */\n\t\tif (iagp->nfreeexts == cpu_to_le32(EXTSPERIAG)) {\n\t\t\trelease_metapage(bp);\n\t\t\tcontinue;\n\t\t}\n\n\t\tagstart = le64_to_cpu(iagp->agstart);\n\t\tn = agstart >> mp->db_agl2size;\n\t\tiagp->agstart = cpu_to_le64((s64)n << mp->db_agl2size);\n\n\t\t/* compute backed inodes */\n\t\tnuminos = (EXTSPERIAG - le32_to_cpu(iagp->nfreeexts))\n\t\t    << L2INOSPEREXT;\n\t\tif (numinos > 0) {\n\t\t\t/* merge AG backed inodes */\n\t\t\timap->im_agctl[n].numinos += numinos;\n\t\t\txnuminos += numinos;\n\t\t}\n\n\t\t/* if any backed free inodes, insert at AG free inode list */\n\t\tif ((int) le32_to_cpu(iagp->nfreeinos) > 0) {\n\t\t\tif ((head = imap->im_agctl[n].inofree) == -1) {\n\t\t\t\tiagp->inofreefwd = cpu_to_le32(-1);\n\t\t\t\tiagp->inofreeback = cpu_to_le32(-1);\n\t\t\t} else {\n\t\t\t\tif ((rc = diIAGRead(imap, head, &hbp))) {\n\t\t\t\t\trcx = rc;\n\t\t\t\t\tgoto nextiag;\n\t\t\t\t}\n\t\t\t\thiagp = (struct iag *) hbp->data;\n\t\t\t\thiagp->inofreeback = iagp->iagnum;\n\t\t\t\tiagp->inofreefwd = cpu_to_le32(head);\n\t\t\t\tiagp->inofreeback = cpu_to_le32(-1);\n\t\t\t\twrite_metapage(hbp);\n\t\t\t}\n\n\t\t\timap->im_agctl[n].inofree =\n\t\t\t    le32_to_cpu(iagp->iagnum);\n\n\t\t\t/* merge AG backed free inodes */\n\t\t\timap->im_agctl[n].numfree +=\n\t\t\t    le32_to_cpu(iagp->nfreeinos);\n\t\t\txnumfree += le32_to_cpu(iagp->nfreeinos);\n\t\t}\n\n\t\t/* if any free extents, insert at AG free extent list */\n\t\tif (le32_to_cpu(iagp->nfreeexts) > 0) {\n\t\t\tif ((head = imap->im_agctl[n].extfree) == -1) {\n\t\t\t\tiagp->extfreefwd = cpu_to_le32(-1);\n\t\t\t\tiagp->extfreeback = cpu_to_le32(-1);\n\t\t\t} else {\n\t\t\t\tif ((rc = diIAGRead(imap, head, &hbp))) {\n\t\t\t\t\trcx = rc;\n\t\t\t\t\tgoto nextiag;\n\t\t\t\t}\n\t\t\t\thiagp = (struct iag *) hbp->data;\n\t\t\t\thiagp->extfreeback = iagp->iagnum;\n\t\t\t\tiagp->extfreefwd = cpu_to_le32(head);\n\t\t\t\tiagp->extfreeback = cpu_to_le32(-1);\n\t\t\t\twrite_metapage(hbp);\n\t\t\t}\n\n\t\t\timap->im_agctl[n].extfree =\n\t\t\t    le32_to_cpu(iagp->iagnum);\n\t\t}\n\n\t      nextiag:\n\t\twrite_metapage(bp);\n\t}\n\n\tif (xnuminos != atomic_read(&imap->im_numinos) ||\n\t    xnumfree != atomic_read(&imap->im_numfree)) {\n\t\tjfs_error(ipimap->i_sb, \"numinos or numfree incorrect\\n\");\n\t\treturn -EIO;\n\t}\n\n\treturn rcx;\n}",
    "includes": [
      "#include \"jfs_debug.h\"",
      "#include \"jfs_superblock.h\"",
      "#include \"jfs_metapage.h\"",
      "#include \"jfs_imap.h\"",
      "#include \"jfs_dmap.h\"",
      "#include \"jfs_dinode.h\"",
      "#include \"jfs_filsys.h\"",
      "#include \"jfs_inode.h\"",
      "#include \"jfs_incore.h\"",
      "#include <linux/slab.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int diAllocAG(struct inomap *, int, bool, struct inode *);",
      "static int diAllocAny(struct inomap *, int, bool, struct inode *);",
      "static int diAllocBit(struct inomap *, struct iag *, int);",
      "static int diAllocExt(struct inomap *, int, struct inode *);",
      "static int diAllocIno(struct inomap *, int, struct inode *);",
      "static int diNewExt(struct inomap *, struct iag *, int);",
      "static int diNewIAG(struct inomap *, int *, int, struct metapage **);",
      "static void duplicateIXtree(struct super_block *, s64, int, s64 *);",
      "static int diIAGRead(struct inomap * imap, int, struct metapage **);",
      "static int copy_from_dinode(struct dinode *, struct inode *);",
      "static void copy_to_dinode(struct dinode *, struct inode *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "jfs_error",
          "args": [
            "ipimap->i_sb",
            "\"numinos or numfree incorrect\\n\""
          ],
          "line": 2979
        },
        "resolved": true,
        "details": {
          "function_name": "jfs_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/super.c",
          "lines": "95-111",
          "snippet": "void jfs_error(struct super_block *sb, const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tva_start(args, fmt);\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tpr_err(\"ERROR: (device %s): %pf: %pV\\n\",\n\t       sb->s_id, __builtin_return_address(0), &vaf);\n\n\tva_end(args);\n\n\tjfs_handle_error(sb);\n}",
          "includes": [
            "#include \"jfs_xattr.h\"",
            "#include \"jfs_debug.h\"",
            "#include \"jfs_acl.h\"",
            "#include \"jfs_imap.h\"",
            "#include \"jfs_dmap.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_inode.h\"",
            "#include \"jfs_filsys.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/blkdev.h>",
            "#include <linux/seq_file.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/crc32.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/mount.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/vfs.h>",
            "#include <linux/completion.h>",
            "#include <linux/parser.h>",
            "#include <linux/module.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_xattr.h\"\n#include \"jfs_debug.h\"\n#include \"jfs_acl.h\"\n#include \"jfs_imap.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_inode.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_incore.h\"\n#include <linux/blkdev.h>\n#include <linux/seq_file.h>\n#include <asm/uaccess.h>\n#include <linux/slab.h>\n#include <linux/crc32.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/posix_acl.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/mount.h>\n#include <linux/quotaops.h>\n#include <linux/vfs.h>\n#include <linux/completion.h>\n#include <linux/parser.h>\n#include <linux/module.h>\n#include <linux/fs.h>\n\nvoid jfs_error(struct super_block *sb, const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tva_start(args, fmt);\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tpr_err(\"ERROR: (device %s): %pf: %pV\\n\",\n\t       sb->s_id, __builtin_return_address(0), &vaf);\n\n\tva_end(args);\n\n\tjfs_handle_error(sb);\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&imap->im_numfree"
          ],
          "line": 2978
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&imap->im_numinos"
          ],
          "line": 2977
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "write_metapage",
          "args": [
            "bp"
          ],
          "line": 2974
        },
        "resolved": true,
        "details": {
          "function_name": "write_metapage",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_metapage.h",
          "lines": "85-89",
          "snippet": "static inline void write_metapage(struct metapage *mp)\n{\n\tset_bit(META_dirty, &mp->flag);\n\trelease_metapage(mp);\n}",
          "includes": [
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [
            "#define META_dirty\t2"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/pagemap.h>\n\n#define META_dirty\t2\n\nstatic inline void write_metapage(struct metapage *mp)\n{\n\tset_bit(META_dirty, &mp->flag);\n\trelease_metapage(mp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "iagp->iagnum"
          ],
          "line": 2970
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "-1"
          ],
          "line": 2965
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "head"
          ],
          "line": 2964
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "diIAGRead",
          "args": [
            "imap",
            "head",
            "&hbp"
          ],
          "line": 2958
        },
        "resolved": true,
        "details": {
          "function_name": "diIAGRead",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_imap.c",
          "lines": "2675-2690",
          "snippet": "static int diIAGRead(struct inomap * imap, int iagno, struct metapage ** mpp)\n{\n\tstruct inode *ipimap = imap->im_ipimap;\n\ts64 blkno;\n\n\t/* compute the logical block number of the iag. */\n\tblkno = IAGTOLBLK(iagno, JFS_SBI(ipimap->i_sb)->l2nbperpage);\n\n\t/* read the iag. */\n\t*mpp = read_metapage(ipimap, blkno, PSIZE, 0);\n\tif (*mpp == NULL) {\n\t\treturn -EIO;\n\t}\n\n\treturn (0);\n}",
          "includes": [
            "#include \"jfs_debug.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_imap.h\"",
            "#include \"jfs_dmap.h\"",
            "#include \"jfs_dinode.h\"",
            "#include \"jfs_filsys.h\"",
            "#include \"jfs_inode.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/slab.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int diAllocAG(struct inomap *, int, bool, struct inode *);",
            "static int diAllocAny(struct inomap *, int, bool, struct inode *);",
            "static int diAllocBit(struct inomap *, struct iag *, int);",
            "static int diAllocExt(struct inomap *, int, struct inode *);",
            "static int diAllocIno(struct inomap *, int, struct inode *);",
            "static int diNewExt(struct inomap *, struct iag *, int);",
            "static int diNewIAG(struct inomap *, int *, int, struct metapage **);",
            "static void duplicateIXtree(struct super_block *, s64, int, s64 *);",
            "static int diIAGRead(struct inomap * imap, int, struct metapage **);",
            "static int copy_from_dinode(struct dinode *, struct inode *);",
            "static void copy_to_dinode(struct dinode *, struct inode *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_imap.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_dinode.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_inode.h\"\n#include \"jfs_incore.h\"\n#include <linux/slab.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n\nstatic int diAllocAG(struct inomap *, int, bool, struct inode *);\nstatic int diAllocAny(struct inomap *, int, bool, struct inode *);\nstatic int diAllocBit(struct inomap *, struct iag *, int);\nstatic int diAllocExt(struct inomap *, int, struct inode *);\nstatic int diAllocIno(struct inomap *, int, struct inode *);\nstatic int diNewExt(struct inomap *, struct iag *, int);\nstatic int diNewIAG(struct inomap *, int *, int, struct metapage **);\nstatic void duplicateIXtree(struct super_block *, s64, int, s64 *);\nstatic int diIAGRead(struct inomap * imap, int, struct metapage **);\nstatic int copy_from_dinode(struct dinode *, struct inode *);\nstatic void copy_to_dinode(struct dinode *, struct inode *);\n\nstatic int diIAGRead(struct inomap * imap, int iagno, struct metapage ** mpp)\n{\n\tstruct inode *ipimap = imap->im_ipimap;\n\ts64 blkno;\n\n\t/* compute the logical block number of the iag. */\n\tblkno = IAGTOLBLK(iagno, JFS_SBI(ipimap->i_sb)->l2nbperpage);\n\n\t/* read the iag. */\n\t*mpp = read_metapage(ipimap, blkno, PSIZE, 0);\n\tif (*mpp == NULL) {\n\t\treturn -EIO;\n\t}\n\n\treturn (0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "-1"
          ],
          "line": 2956
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "-1"
          ],
          "line": 2955
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "-1"
          ],
          "line": 2939
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "head"
          ],
          "line": 2938
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "-1"
          ],
          "line": 2930
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "-1"
          ],
          "line": 2929
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le64",
          "args": [
            "(s64)n << mp->db_agl2size"
          ],
          "line": 2915
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le64_to_cpu",
          "args": [
            "iagp->agstart"
          ],
          "line": 2913
        },
        "resolved": true,
        "details": {
          "function_name": "sle64_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "58-61",
          "snippet": "static inline s64 sle64_to_cpup(sle64 *x)\n{\n\treturn le64_to_cpu(*(__force le64*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s64 sle64_to_cpup(sle64 *x)\n{\n\treturn le64_to_cpu(*(__force le64*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "release_metapage",
          "args": [
            "bp"
          ],
          "line": 2909
        },
        "resolved": true,
        "details": {
          "function_name": "release_metapage",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_metapage.c",
          "lines": "743-775",
          "snippet": "void release_metapage(struct metapage * mp)\n{\n\tstruct page *page = mp->page;\n\tjfs_info(\"release_metapage: mp = 0x%p, flag = 0x%lx\", mp, mp->flag);\n\n\tBUG_ON(!page);\n\n\tlock_page(page);\n\tunlock_metapage(mp);\n\n\tassert(mp->count);\n\tif (--mp->count || mp->nohomeok) {\n\t\tunlock_page(page);\n\t\tpage_cache_release(page);\n\t\treturn;\n\t}\n\n\tif (test_bit(META_dirty, &mp->flag)) {\n\t\tset_page_dirty(page);\n\t\tif (test_bit(META_sync, &mp->flag)) {\n\t\t\tclear_bit(META_sync, &mp->flag);\n\t\t\twrite_one_page(page, 1);\n\t\t\tlock_page(page); /* write_one_page unlocks the page */\n\t\t}\n\t} else if (mp->lsn)\t/* discard_metapage doesn't remove it */\n\t\tremove_from_logsync(mp);\n\n\t/* Try to keep metapages from using up too much memory */\n\tdrop_metapage(page, mp);\n\n\tunlock_page(page);\n\tpage_cache_release(page);\n}",
          "includes": [
            "#include \"jfs_debug.h\"",
            "#include \"jfs_txnmgr.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_filsys.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/mempool.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/bio.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_txnmgr.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_incore.h\"\n#include <linux/seq_file.h>\n#include <linux/mempool.h>\n#include <linux/buffer_head.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n\nvoid release_metapage(struct metapage * mp)\n{\n\tstruct page *page = mp->page;\n\tjfs_info(\"release_metapage: mp = 0x%p, flag = 0x%lx\", mp, mp->flag);\n\n\tBUG_ON(!page);\n\n\tlock_page(page);\n\tunlock_metapage(mp);\n\n\tassert(mp->count);\n\tif (--mp->count || mp->nohomeok) {\n\t\tunlock_page(page);\n\t\tpage_cache_release(page);\n\t\treturn;\n\t}\n\n\tif (test_bit(META_dirty, &mp->flag)) {\n\t\tset_page_dirty(page);\n\t\tif (test_bit(META_sync, &mp->flag)) {\n\t\t\tclear_bit(META_sync, &mp->flag);\n\t\t\twrite_one_page(page, 1);\n\t\t\tlock_page(page); /* write_one_page unlocks the page */\n\t\t}\n\t} else if (mp->lsn)\t/* discard_metapage doesn't remove it */\n\t\tremove_from_logsync(mp);\n\n\t/* Try to keep metapages from using up too much memory */\n\tdrop_metapage(page, mp);\n\n\tunlock_page(page);\n\tpage_cache_release(page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "EXTSPERIAG"
          ],
          "line": 2908
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "jfs_info",
          "args": [
            "\"diExtendFS: nextiag:%d numinos:%d numfree:%d\"",
            "imap->im_nextiag",
            "atomic_read(&imap->im_numinos)",
            "atomic_read(&imap->im_numfree)"
          ],
          "line": 2870
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&imap->im_numfree"
          ],
          "line": 2872
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&imap->im_numinos"
          ],
          "line": 2871
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "JFS_SBI",
          "args": [
            "ipbmap->i_sb"
          ],
          "line": 2864
        },
        "resolved": true,
        "details": {
          "function_name": "JFS_SBI",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_incore.h",
          "lines": "217-220",
          "snippet": "static inline struct jfs_sb_info *JFS_SBI(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"jfs_dtree.h\"",
            "#include \"jfs_xtree.h\"",
            "#include \"jfs_types.h\"",
            "#include <linux/bitops.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_dtree.h\"\n#include \"jfs_xtree.h\"\n#include \"jfs_types.h\"\n#include <linux/bitops.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mutex.h>\n\nstatic inline struct jfs_sb_info *JFS_SBI(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      },
      {
        "call_info": {
          "callee": "JFS_IP",
          "args": [
            "ipimap"
          ],
          "line": 2862
        },
        "resolved": true,
        "details": {
          "function_name": "JFS_IP",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_incore.h",
          "lines": "207-210",
          "snippet": "static inline struct jfs_inode_info *JFS_IP(struct inode *inode)\n{\n\treturn list_entry(inode, struct jfs_inode_info, vfs_inode);\n}",
          "includes": [
            "#include \"jfs_dtree.h\"",
            "#include \"jfs_xtree.h\"",
            "#include \"jfs_types.h\"",
            "#include <linux/bitops.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_dtree.h\"\n#include \"jfs_xtree.h\"\n#include \"jfs_types.h\"\n#include <linux/bitops.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mutex.h>\n\nstatic inline struct jfs_inode_info *JFS_IP(struct inode *inode)\n{\n\treturn list_entry(inode, struct jfs_inode_info, vfs_inode);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_imap.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_dinode.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_inode.h\"\n#include \"jfs_incore.h\"\n#include <linux/slab.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n\nstatic int diAllocAG(struct inomap *, int, bool, struct inode *);\nstatic int diAllocAny(struct inomap *, int, bool, struct inode *);\nstatic int diAllocBit(struct inomap *, struct iag *, int);\nstatic int diAllocExt(struct inomap *, int, struct inode *);\nstatic int diAllocIno(struct inomap *, int, struct inode *);\nstatic int diNewExt(struct inomap *, struct iag *, int);\nstatic int diNewIAG(struct inomap *, int *, int, struct metapage **);\nstatic void duplicateIXtree(struct super_block *, s64, int, s64 *);\nstatic int diIAGRead(struct inomap * imap, int, struct metapage **);\nstatic int copy_from_dinode(struct dinode *, struct inode *);\nstatic void copy_to_dinode(struct dinode *, struct inode *);\n\nint diExtendFS(struct inode *ipimap, struct inode *ipbmap)\n{\n\tint rc, rcx = 0;\n\tstruct inomap *imap = JFS_IP(ipimap)->i_imap;\n\tstruct iag *iagp = NULL, *hiagp = NULL;\n\tstruct bmap *mp = JFS_SBI(ipbmap->i_sb)->bmap;\n\tstruct metapage *bp, *hbp;\n\tint i, n, head;\n\tint numinos, xnuminos = 0, xnumfree = 0;\n\ts64 agstart;\n\n\tjfs_info(\"diExtendFS: nextiag:%d numinos:%d numfree:%d\",\n\t\t   imap->im_nextiag, atomic_read(&imap->im_numinos),\n\t\t   atomic_read(&imap->im_numfree));\n\n\t/*\n\t *\treconstruct imap\n\t *\n\t * coalesce contiguous k (newAGSize/oldAGSize) AGs;\n\t * i.e., (AGi, ..., AGj) where i = k*n and j = k*(n+1) - 1 to AGn;\n\t * note: new AG size = old AG size * (2**x).\n\t */\n\n\t/* init per AG control information im_agctl[] */\n\tfor (i = 0; i < MAXAG; i++) {\n\t\timap->im_agctl[i].inofree = -1;\n\t\timap->im_agctl[i].extfree = -1;\n\t\timap->im_agctl[i].numinos = 0;\t/* number of backed inodes */\n\t\timap->im_agctl[i].numfree = 0;\t/* number of free backed inodes */\n\t}\n\n\t/*\n\t *\tprocess each iag page of the map.\n\t *\n\t * rebuild AG Free Inode List, AG Free Inode Extent List;\n\t */\n\tfor (i = 0; i < imap->im_nextiag; i++) {\n\t\tif ((rc = diIAGRead(imap, i, &bp))) {\n\t\t\trcx = rc;\n\t\t\tcontinue;\n\t\t}\n\t\tiagp = (struct iag *) bp->data;\n\t\tif (le32_to_cpu(iagp->iagnum) != i) {\n\t\t\trelease_metapage(bp);\n\t\t\tjfs_error(ipimap->i_sb, \"unexpected value of iagnum\\n\");\n\t\t\treturn -EIO;\n\t\t}\n\n\t\t/* leave free iag in the free iag list */\n\t\tif (iagp->nfreeexts == cpu_to_le32(EXTSPERIAG)) {\n\t\t\trelease_metapage(bp);\n\t\t\tcontinue;\n\t\t}\n\n\t\tagstart = le64_to_cpu(iagp->agstart);\n\t\tn = agstart >> mp->db_agl2size;\n\t\tiagp->agstart = cpu_to_le64((s64)n << mp->db_agl2size);\n\n\t\t/* compute backed inodes */\n\t\tnuminos = (EXTSPERIAG - le32_to_cpu(iagp->nfreeexts))\n\t\t    << L2INOSPEREXT;\n\t\tif (numinos > 0) {\n\t\t\t/* merge AG backed inodes */\n\t\t\timap->im_agctl[n].numinos += numinos;\n\t\t\txnuminos += numinos;\n\t\t}\n\n\t\t/* if any backed free inodes, insert at AG free inode list */\n\t\tif ((int) le32_to_cpu(iagp->nfreeinos) > 0) {\n\t\t\tif ((head = imap->im_agctl[n].inofree) == -1) {\n\t\t\t\tiagp->inofreefwd = cpu_to_le32(-1);\n\t\t\t\tiagp->inofreeback = cpu_to_le32(-1);\n\t\t\t} else {\n\t\t\t\tif ((rc = diIAGRead(imap, head, &hbp))) {\n\t\t\t\t\trcx = rc;\n\t\t\t\t\tgoto nextiag;\n\t\t\t\t}\n\t\t\t\thiagp = (struct iag *) hbp->data;\n\t\t\t\thiagp->inofreeback = iagp->iagnum;\n\t\t\t\tiagp->inofreefwd = cpu_to_le32(head);\n\t\t\t\tiagp->inofreeback = cpu_to_le32(-1);\n\t\t\t\twrite_metapage(hbp);\n\t\t\t}\n\n\t\t\timap->im_agctl[n].inofree =\n\t\t\t    le32_to_cpu(iagp->iagnum);\n\n\t\t\t/* merge AG backed free inodes */\n\t\t\timap->im_agctl[n].numfree +=\n\t\t\t    le32_to_cpu(iagp->nfreeinos);\n\t\t\txnumfree += le32_to_cpu(iagp->nfreeinos);\n\t\t}\n\n\t\t/* if any free extents, insert at AG free extent list */\n\t\tif (le32_to_cpu(iagp->nfreeexts) > 0) {\n\t\t\tif ((head = imap->im_agctl[n].extfree) == -1) {\n\t\t\t\tiagp->extfreefwd = cpu_to_le32(-1);\n\t\t\t\tiagp->extfreeback = cpu_to_le32(-1);\n\t\t\t} else {\n\t\t\t\tif ((rc = diIAGRead(imap, head, &hbp))) {\n\t\t\t\t\trcx = rc;\n\t\t\t\t\tgoto nextiag;\n\t\t\t\t}\n\t\t\t\thiagp = (struct iag *) hbp->data;\n\t\t\t\thiagp->extfreeback = iagp->iagnum;\n\t\t\t\tiagp->extfreefwd = cpu_to_le32(head);\n\t\t\t\tiagp->extfreeback = cpu_to_le32(-1);\n\t\t\t\twrite_metapage(hbp);\n\t\t\t}\n\n\t\t\timap->im_agctl[n].extfree =\n\t\t\t    le32_to_cpu(iagp->iagnum);\n\t\t}\n\n\t      nextiag:\n\t\twrite_metapage(bp);\n\t}\n\n\tif (xnuminos != atomic_read(&imap->im_numinos) ||\n\t    xnumfree != atomic_read(&imap->im_numfree)) {\n\t\tjfs_error(ipimap->i_sb, \"numinos or numfree incorrect\\n\");\n\t\treturn -EIO;\n\t}\n\n\treturn rcx;\n}"
  },
  {
    "function_name": "diUpdatePMap",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_imap.c",
    "lines": "2736-2849",
    "snippet": "int\ndiUpdatePMap(struct inode *ipimap,\n\t     unsigned long inum, bool is_free, struct tblock * tblk)\n{\n\tint rc;\n\tstruct iag *iagp;\n\tstruct metapage *mp;\n\tint iagno, ino, extno, bitno;\n\tstruct inomap *imap;\n\tu32 mask;\n\tstruct jfs_log *log;\n\tint lsn, difft, diffp;\n\tunsigned long flags;\n\n\timap = JFS_IP(ipimap)->i_imap;\n\t/* get the iag number containing the inode */\n\tiagno = INOTOIAG(inum);\n\t/* make sure that the iag is contained within the map */\n\tif (iagno >= imap->im_nextiag) {\n\t\tjfs_error(ipimap->i_sb, \"the iag is outside the map\\n\");\n\t\treturn -EIO;\n\t}\n\t/* read the iag */\n\tIREAD_LOCK(ipimap, RDWRLOCK_IMAP);\n\trc = diIAGRead(imap, iagno, &mp);\n\tIREAD_UNLOCK(ipimap);\n\tif (rc)\n\t\treturn (rc);\n\tmetapage_wait_for_io(mp);\n\tiagp = (struct iag *) mp->data;\n\t/* get the inode number and extent number of the inode within\n\t * the iag and the inode number within the extent.\n\t */\n\tino = inum & (INOSPERIAG - 1);\n\textno = ino >> L2INOSPEREXT;\n\tbitno = ino & (INOSPEREXT - 1);\n\tmask = HIGHORDER >> bitno;\n\t/*\n\t * mark the inode free in persistent map:\n\t */\n\tif (is_free) {\n\t\t/* The inode should have been allocated both in working\n\t\t * map and in persistent map;\n\t\t * the inode will be freed from working map at the release\n\t\t * of last reference release;\n\t\t */\n\t\tif (!(le32_to_cpu(iagp->wmap[extno]) & mask)) {\n\t\t\tjfs_error(ipimap->i_sb,\n\t\t\t\t  \"inode %ld not marked as allocated in wmap!\\n\",\n\t\t\t\t  inum);\n\t\t}\n\t\tif (!(le32_to_cpu(iagp->pmap[extno]) & mask)) {\n\t\t\tjfs_error(ipimap->i_sb,\n\t\t\t\t  \"inode %ld not marked as allocated in pmap!\\n\",\n\t\t\t\t  inum);\n\t\t}\n\t\t/* update the bitmap for the extent of the freed inode */\n\t\tiagp->pmap[extno] &= cpu_to_le32(~mask);\n\t}\n\t/*\n\t * mark the inode allocated in persistent map:\n\t */\n\telse {\n\t\t/* The inode should be already allocated in the working map\n\t\t * and should be free in persistent map;\n\t\t */\n\t\tif (!(le32_to_cpu(iagp->wmap[extno]) & mask)) {\n\t\t\trelease_metapage(mp);\n\t\t\tjfs_error(ipimap->i_sb,\n\t\t\t\t  \"the inode is not allocated in the working map\\n\");\n\t\t\treturn -EIO;\n\t\t}\n\t\tif ((le32_to_cpu(iagp->pmap[extno]) & mask) != 0) {\n\t\t\trelease_metapage(mp);\n\t\t\tjfs_error(ipimap->i_sb,\n\t\t\t\t  \"the inode is not free in the persistent map\\n\");\n\t\t\treturn -EIO;\n\t\t}\n\t\t/* update the bitmap for the extent of the allocated inode */\n\t\tiagp->pmap[extno] |= cpu_to_le32(mask);\n\t}\n\t/*\n\t * update iag lsn\n\t */\n\tlsn = tblk->lsn;\n\tlog = JFS_SBI(tblk->sb)->log;\n\tLOGSYNC_LOCK(log, flags);\n\tif (mp->lsn != 0) {\n\t\t/* inherit older/smaller lsn */\n\t\tlogdiff(difft, lsn, log);\n\t\tlogdiff(diffp, mp->lsn, log);\n\t\tif (difft < diffp) {\n\t\t\tmp->lsn = lsn;\n\t\t\t/* move mp after tblock in logsync list */\n\t\t\tlist_move(&mp->synclist, &tblk->synclist);\n\t\t}\n\t\t/* inherit younger/larger clsn */\n\t\tassert(mp->clsn);\n\t\tlogdiff(difft, tblk->clsn, log);\n\t\tlogdiff(diffp, mp->clsn, log);\n\t\tif (difft > diffp)\n\t\t\tmp->clsn = tblk->clsn;\n\t} else {\n\t\tmp->log = log;\n\t\tmp->lsn = lsn;\n\t\t/* insert mp after tblock in logsync list */\n\t\tlog->count++;\n\t\tlist_add(&mp->synclist, &tblk->synclist);\n\t\tmp->clsn = tblk->clsn;\n\t}\n\tLOGSYNC_UNLOCK(log, flags);\n\twrite_metapage(mp);\n\treturn (0);\n}",
    "includes": [
      "#include \"jfs_debug.h\"",
      "#include \"jfs_superblock.h\"",
      "#include \"jfs_metapage.h\"",
      "#include \"jfs_imap.h\"",
      "#include \"jfs_dmap.h\"",
      "#include \"jfs_dinode.h\"",
      "#include \"jfs_filsys.h\"",
      "#include \"jfs_inode.h\"",
      "#include \"jfs_incore.h\"",
      "#include <linux/slab.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int diAllocAG(struct inomap *, int, bool, struct inode *);",
      "static int diAllocAny(struct inomap *, int, bool, struct inode *);",
      "static int diAllocBit(struct inomap *, struct iag *, int);",
      "static int diAllocExt(struct inomap *, int, struct inode *);",
      "static int diAllocIno(struct inomap *, int, struct inode *);",
      "static int diFindFree(u32, int);",
      "static int diNewExt(struct inomap *, struct iag *, int);",
      "static int diNewIAG(struct inomap *, int *, int, struct metapage **);",
      "static int diIAGRead(struct inomap * imap, int, struct metapage **);",
      "static int copy_from_dinode(struct dinode *, struct inode *);",
      "static void copy_to_dinode(struct dinode *, struct inode *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "write_metapage",
          "args": [
            "mp"
          ],
          "line": 2847
        },
        "resolved": true,
        "details": {
          "function_name": "write_metapage",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_metapage.h",
          "lines": "85-89",
          "snippet": "static inline void write_metapage(struct metapage *mp)\n{\n\tset_bit(META_dirty, &mp->flag);\n\trelease_metapage(mp);\n}",
          "includes": [
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [
            "#define META_dirty\t2"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/pagemap.h>\n\n#define META_dirty\t2\n\nstatic inline void write_metapage(struct metapage *mp)\n{\n\tset_bit(META_dirty, &mp->flag);\n\trelease_metapage(mp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "LOGSYNC_UNLOCK",
          "args": [
            "log",
            "flags"
          ],
          "line": 2846
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_add",
          "args": [
            "&mp->synclist",
            "&tblk->synclist"
          ],
          "line": 2843
        },
        "resolved": true,
        "details": {
          "function_name": "simple_xattr_list_add",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xattr.c",
          "lines": "966-972",
          "snippet": "void simple_xattr_list_add(struct simple_xattrs *xattrs,\n\t\t\t   struct simple_xattr *new_xattr)\n{\n\tspin_lock(&xattrs->lock);\n\tlist_add(&new_xattr->list, &xattrs->head);\n\tspin_unlock(&xattrs->lock);\n}",
          "includes": [
            "#include <asm/uaccess.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/audit.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/evm.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/xattr.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/vmalloc.h>\n#include <linux/audit.h>\n#include <linux/fsnotify.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n#include <linux/evm.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/xattr.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nvoid simple_xattr_list_add(struct simple_xattrs *xattrs,\n\t\t\t   struct simple_xattr *new_xattr)\n{\n\tspin_lock(&xattrs->lock);\n\tlist_add(&new_xattr->list, &xattrs->head);\n\tspin_unlock(&xattrs->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "logdiff",
          "args": [
            "diffp",
            "mp->clsn",
            "log"
          ],
          "line": 2835
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "logdiff",
          "args": [
            "difft",
            "tblk->clsn",
            "log"
          ],
          "line": 2834
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "mp->clsn"
          ],
          "line": 2833
        },
        "resolved": true,
        "details": {
          "function_name": "hpfs_lock_assert",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/hpfs_fn.h",
          "lines": "359-363",
          "snippet": "static inline void hpfs_lock_assert(struct super_block *s)\n{\n\tstruct hpfs_sb_info *sbi = hpfs_sb(s);\n\tWARN_ON(!mutex_is_locked(&sbi->hpfs_mutex));\n}",
          "includes": [
            "#include \"hpfs.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int hpfs_check_free_dnodes(struct super_block *, int);",
            "void hpfs_prefetch_sectors(struct super_block *, unsigned, int);",
            "void hpfs_prefetch_bitmap(struct super_block *, unsigned);",
            "unsigned char *hpfs_translate_name(struct super_block *, unsigned char *, unsigned, int, int);",
            "int hpfs_compare_names(struct super_block *, const unsigned char *, unsigned,\n\t\t       const unsigned char *, unsigned, int);",
            "void hpfs_error(struct super_block *, const char *, ...);",
            "int hpfs_stop_cycles(struct super_block *, int, int *, int *, char *);",
            "unsigned hpfs_get_free_dnodes(struct super_block *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"hpfs.h\"\n#include <asm/unaligned.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n#include <linux/mutex.h>\n\nint hpfs_check_free_dnodes(struct super_block *, int);\nvoid hpfs_prefetch_sectors(struct super_block *, unsigned, int);\nvoid hpfs_prefetch_bitmap(struct super_block *, unsigned);\nunsigned char *hpfs_translate_name(struct super_block *, unsigned char *, unsigned, int, int);\nint hpfs_compare_names(struct super_block *, const unsigned char *, unsigned,\n\t\t       const unsigned char *, unsigned, int);\nvoid hpfs_error(struct super_block *, const char *, ...);\nint hpfs_stop_cycles(struct super_block *, int, int *, int *, char *);\nunsigned hpfs_get_free_dnodes(struct super_block *);\n\nstatic inline void hpfs_lock_assert(struct super_block *s)\n{\n\tstruct hpfs_sb_info *sbi = hpfs_sb(s);\n\tWARN_ON(!mutex_is_locked(&sbi->hpfs_mutex));\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_move",
          "args": [
            "&mp->synclist",
            "&tblk->synclist"
          ],
          "line": 2830
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "logdiff",
          "args": [
            "diffp",
            "mp->lsn",
            "log"
          ],
          "line": 2826
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "logdiff",
          "args": [
            "difft",
            "lsn",
            "log"
          ],
          "line": 2825
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LOGSYNC_LOCK",
          "args": [
            "log",
            "flags"
          ],
          "line": 2822
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "JFS_SBI",
          "args": [
            "tblk->sb"
          ],
          "line": 2821
        },
        "resolved": true,
        "details": {
          "function_name": "JFS_SBI",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_incore.h",
          "lines": "217-220",
          "snippet": "static inline struct jfs_sb_info *JFS_SBI(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"jfs_dtree.h\"",
            "#include \"jfs_xtree.h\"",
            "#include \"jfs_types.h\"",
            "#include <linux/bitops.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_dtree.h\"\n#include \"jfs_xtree.h\"\n#include \"jfs_types.h\"\n#include <linux/bitops.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mutex.h>\n\nstatic inline struct jfs_sb_info *JFS_SBI(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "mask"
          ],
          "line": 2815
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "jfs_error",
          "args": [
            "ipimap->i_sb",
            "\"the inode is not free in the persistent map\\n\""
          ],
          "line": 2810
        },
        "resolved": true,
        "details": {
          "function_name": "jfs_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/super.c",
          "lines": "95-111",
          "snippet": "void jfs_error(struct super_block *sb, const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tva_start(args, fmt);\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tpr_err(\"ERROR: (device %s): %pf: %pV\\n\",\n\t       sb->s_id, __builtin_return_address(0), &vaf);\n\n\tva_end(args);\n\n\tjfs_handle_error(sb);\n}",
          "includes": [
            "#include \"jfs_xattr.h\"",
            "#include \"jfs_debug.h\"",
            "#include \"jfs_acl.h\"",
            "#include \"jfs_imap.h\"",
            "#include \"jfs_dmap.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_inode.h\"",
            "#include \"jfs_filsys.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/blkdev.h>",
            "#include <linux/seq_file.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/crc32.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/mount.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/vfs.h>",
            "#include <linux/completion.h>",
            "#include <linux/parser.h>",
            "#include <linux/module.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_xattr.h\"\n#include \"jfs_debug.h\"\n#include \"jfs_acl.h\"\n#include \"jfs_imap.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_inode.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_incore.h\"\n#include <linux/blkdev.h>\n#include <linux/seq_file.h>\n#include <asm/uaccess.h>\n#include <linux/slab.h>\n#include <linux/crc32.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/posix_acl.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/mount.h>\n#include <linux/quotaops.h>\n#include <linux/vfs.h>\n#include <linux/completion.h>\n#include <linux/parser.h>\n#include <linux/module.h>\n#include <linux/fs.h>\n\nvoid jfs_error(struct super_block *sb, const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tva_start(args, fmt);\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tpr_err(\"ERROR: (device %s): %pf: %pV\\n\",\n\t       sb->s_id, __builtin_return_address(0), &vaf);\n\n\tva_end(args);\n\n\tjfs_handle_error(sb);\n}"
        }
      },
      {
        "call_info": {
          "callee": "release_metapage",
          "args": [
            "mp"
          ],
          "line": 2809
        },
        "resolved": true,
        "details": {
          "function_name": "release_metapage",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_metapage.c",
          "lines": "743-775",
          "snippet": "void release_metapage(struct metapage * mp)\n{\n\tstruct page *page = mp->page;\n\tjfs_info(\"release_metapage: mp = 0x%p, flag = 0x%lx\", mp, mp->flag);\n\n\tBUG_ON(!page);\n\n\tlock_page(page);\n\tunlock_metapage(mp);\n\n\tassert(mp->count);\n\tif (--mp->count || mp->nohomeok) {\n\t\tunlock_page(page);\n\t\tpage_cache_release(page);\n\t\treturn;\n\t}\n\n\tif (test_bit(META_dirty, &mp->flag)) {\n\t\tset_page_dirty(page);\n\t\tif (test_bit(META_sync, &mp->flag)) {\n\t\t\tclear_bit(META_sync, &mp->flag);\n\t\t\twrite_one_page(page, 1);\n\t\t\tlock_page(page); /* write_one_page unlocks the page */\n\t\t}\n\t} else if (mp->lsn)\t/* discard_metapage doesn't remove it */\n\t\tremove_from_logsync(mp);\n\n\t/* Try to keep metapages from using up too much memory */\n\tdrop_metapage(page, mp);\n\n\tunlock_page(page);\n\tpage_cache_release(page);\n}",
          "includes": [
            "#include \"jfs_debug.h\"",
            "#include \"jfs_txnmgr.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_filsys.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/mempool.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/bio.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_txnmgr.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_incore.h\"\n#include <linux/seq_file.h>\n#include <linux/mempool.h>\n#include <linux/buffer_head.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n\nvoid release_metapage(struct metapage * mp)\n{\n\tstruct page *page = mp->page;\n\tjfs_info(\"release_metapage: mp = 0x%p, flag = 0x%lx\", mp, mp->flag);\n\n\tBUG_ON(!page);\n\n\tlock_page(page);\n\tunlock_metapage(mp);\n\n\tassert(mp->count);\n\tif (--mp->count || mp->nohomeok) {\n\t\tunlock_page(page);\n\t\tpage_cache_release(page);\n\t\treturn;\n\t}\n\n\tif (test_bit(META_dirty, &mp->flag)) {\n\t\tset_page_dirty(page);\n\t\tif (test_bit(META_sync, &mp->flag)) {\n\t\t\tclear_bit(META_sync, &mp->flag);\n\t\t\twrite_one_page(page, 1);\n\t\t\tlock_page(page); /* write_one_page unlocks the page */\n\t\t}\n\t} else if (mp->lsn)\t/* discard_metapage doesn't remove it */\n\t\tremove_from_logsync(mp);\n\n\t/* Try to keep metapages from using up too much memory */\n\tdrop_metapage(page, mp);\n\n\tunlock_page(page);\n\tpage_cache_release(page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "iagp->pmap[extno]"
          ],
          "line": 2808
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "~mask"
          ],
          "line": 2793
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "metapage_wait_for_io",
          "args": [
            "mp"
          ],
          "line": 2764
        },
        "resolved": true,
        "details": {
          "function_name": "metapage_wait_for_io",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_metapage.h",
          "lines": "120-124",
          "snippet": "static inline void metapage_wait_for_io(struct metapage *mp)\n{\n\tif (test_bit(META_io, &mp->flag))\n\t\twait_on_page_writeback(mp->page);\n}",
          "includes": [
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [
            "#define META_io\t\t6"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/pagemap.h>\n\n#define META_io\t\t6\n\nstatic inline void metapage_wait_for_io(struct metapage *mp)\n{\n\tif (test_bit(META_io, &mp->flag))\n\t\twait_on_page_writeback(mp->page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "IREAD_UNLOCK",
          "args": [
            "ipimap"
          ],
          "line": 2761
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "diIAGRead",
          "args": [
            "imap",
            "iagno",
            "&mp"
          ],
          "line": 2760
        },
        "resolved": true,
        "details": {
          "function_name": "diIAGRead",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_imap.c",
          "lines": "2675-2690",
          "snippet": "static int diIAGRead(struct inomap * imap, int iagno, struct metapage ** mpp)\n{\n\tstruct inode *ipimap = imap->im_ipimap;\n\ts64 blkno;\n\n\t/* compute the logical block number of the iag. */\n\tblkno = IAGTOLBLK(iagno, JFS_SBI(ipimap->i_sb)->l2nbperpage);\n\n\t/* read the iag. */\n\t*mpp = read_metapage(ipimap, blkno, PSIZE, 0);\n\tif (*mpp == NULL) {\n\t\treturn -EIO;\n\t}\n\n\treturn (0);\n}",
          "includes": [
            "#include \"jfs_debug.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_imap.h\"",
            "#include \"jfs_dmap.h\"",
            "#include \"jfs_dinode.h\"",
            "#include \"jfs_filsys.h\"",
            "#include \"jfs_inode.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/slab.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int diAllocAG(struct inomap *, int, bool, struct inode *);",
            "static int diAllocAny(struct inomap *, int, bool, struct inode *);",
            "static int diAllocBit(struct inomap *, struct iag *, int);",
            "static int diAllocExt(struct inomap *, int, struct inode *);",
            "static int diAllocIno(struct inomap *, int, struct inode *);",
            "static int diNewExt(struct inomap *, struct iag *, int);",
            "static int diNewIAG(struct inomap *, int *, int, struct metapage **);",
            "static void duplicateIXtree(struct super_block *, s64, int, s64 *);",
            "static int diIAGRead(struct inomap * imap, int, struct metapage **);",
            "static int copy_from_dinode(struct dinode *, struct inode *);",
            "static void copy_to_dinode(struct dinode *, struct inode *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_imap.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_dinode.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_inode.h\"\n#include \"jfs_incore.h\"\n#include <linux/slab.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n\nstatic int diAllocAG(struct inomap *, int, bool, struct inode *);\nstatic int diAllocAny(struct inomap *, int, bool, struct inode *);\nstatic int diAllocBit(struct inomap *, struct iag *, int);\nstatic int diAllocExt(struct inomap *, int, struct inode *);\nstatic int diAllocIno(struct inomap *, int, struct inode *);\nstatic int diNewExt(struct inomap *, struct iag *, int);\nstatic int diNewIAG(struct inomap *, int *, int, struct metapage **);\nstatic void duplicateIXtree(struct super_block *, s64, int, s64 *);\nstatic int diIAGRead(struct inomap * imap, int, struct metapage **);\nstatic int copy_from_dinode(struct dinode *, struct inode *);\nstatic void copy_to_dinode(struct dinode *, struct inode *);\n\nstatic int diIAGRead(struct inomap * imap, int iagno, struct metapage ** mpp)\n{\n\tstruct inode *ipimap = imap->im_ipimap;\n\ts64 blkno;\n\n\t/* compute the logical block number of the iag. */\n\tblkno = IAGTOLBLK(iagno, JFS_SBI(ipimap->i_sb)->l2nbperpage);\n\n\t/* read the iag. */\n\t*mpp = read_metapage(ipimap, blkno, PSIZE, 0);\n\tif (*mpp == NULL) {\n\t\treturn -EIO;\n\t}\n\n\treturn (0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "IREAD_LOCK",
          "args": [
            "ipimap",
            "RDWRLOCK_IMAP"
          ],
          "line": 2759
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INOTOIAG",
          "args": [
            "inum"
          ],
          "line": 2752
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "JFS_IP",
          "args": [
            "ipimap"
          ],
          "line": 2750
        },
        "resolved": true,
        "details": {
          "function_name": "JFS_IP",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_incore.h",
          "lines": "207-210",
          "snippet": "static inline struct jfs_inode_info *JFS_IP(struct inode *inode)\n{\n\treturn list_entry(inode, struct jfs_inode_info, vfs_inode);\n}",
          "includes": [
            "#include \"jfs_dtree.h\"",
            "#include \"jfs_xtree.h\"",
            "#include \"jfs_types.h\"",
            "#include <linux/bitops.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_dtree.h\"\n#include \"jfs_xtree.h\"\n#include \"jfs_types.h\"\n#include <linux/bitops.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mutex.h>\n\nstatic inline struct jfs_inode_info *JFS_IP(struct inode *inode)\n{\n\treturn list_entry(inode, struct jfs_inode_info, vfs_inode);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_imap.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_dinode.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_inode.h\"\n#include \"jfs_incore.h\"\n#include <linux/slab.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n\nstatic int diAllocAG(struct inomap *, int, bool, struct inode *);\nstatic int diAllocAny(struct inomap *, int, bool, struct inode *);\nstatic int diAllocBit(struct inomap *, struct iag *, int);\nstatic int diAllocExt(struct inomap *, int, struct inode *);\nstatic int diAllocIno(struct inomap *, int, struct inode *);\nstatic int diFindFree(u32, int);\nstatic int diNewExt(struct inomap *, struct iag *, int);\nstatic int diNewIAG(struct inomap *, int *, int, struct metapage **);\nstatic int diIAGRead(struct inomap * imap, int, struct metapage **);\nstatic int copy_from_dinode(struct dinode *, struct inode *);\nstatic void copy_to_dinode(struct dinode *, struct inode *);\n\nint\ndiUpdatePMap(struct inode *ipimap,\n\t     unsigned long inum, bool is_free, struct tblock * tblk)\n{\n\tint rc;\n\tstruct iag *iagp;\n\tstruct metapage *mp;\n\tint iagno, ino, extno, bitno;\n\tstruct inomap *imap;\n\tu32 mask;\n\tstruct jfs_log *log;\n\tint lsn, difft, diffp;\n\tunsigned long flags;\n\n\timap = JFS_IP(ipimap)->i_imap;\n\t/* get the iag number containing the inode */\n\tiagno = INOTOIAG(inum);\n\t/* make sure that the iag is contained within the map */\n\tif (iagno >= imap->im_nextiag) {\n\t\tjfs_error(ipimap->i_sb, \"the iag is outside the map\\n\");\n\t\treturn -EIO;\n\t}\n\t/* read the iag */\n\tIREAD_LOCK(ipimap, RDWRLOCK_IMAP);\n\trc = diIAGRead(imap, iagno, &mp);\n\tIREAD_UNLOCK(ipimap);\n\tif (rc)\n\t\treturn (rc);\n\tmetapage_wait_for_io(mp);\n\tiagp = (struct iag *) mp->data;\n\t/* get the inode number and extent number of the inode within\n\t * the iag and the inode number within the extent.\n\t */\n\tino = inum & (INOSPERIAG - 1);\n\textno = ino >> L2INOSPEREXT;\n\tbitno = ino & (INOSPEREXT - 1);\n\tmask = HIGHORDER >> bitno;\n\t/*\n\t * mark the inode free in persistent map:\n\t */\n\tif (is_free) {\n\t\t/* The inode should have been allocated both in working\n\t\t * map and in persistent map;\n\t\t * the inode will be freed from working map at the release\n\t\t * of last reference release;\n\t\t */\n\t\tif (!(le32_to_cpu(iagp->wmap[extno]) & mask)) {\n\t\t\tjfs_error(ipimap->i_sb,\n\t\t\t\t  \"inode %ld not marked as allocated in wmap!\\n\",\n\t\t\t\t  inum);\n\t\t}\n\t\tif (!(le32_to_cpu(iagp->pmap[extno]) & mask)) {\n\t\t\tjfs_error(ipimap->i_sb,\n\t\t\t\t  \"inode %ld not marked as allocated in pmap!\\n\",\n\t\t\t\t  inum);\n\t\t}\n\t\t/* update the bitmap for the extent of the freed inode */\n\t\tiagp->pmap[extno] &= cpu_to_le32(~mask);\n\t}\n\t/*\n\t * mark the inode allocated in persistent map:\n\t */\n\telse {\n\t\t/* The inode should be already allocated in the working map\n\t\t * and should be free in persistent map;\n\t\t */\n\t\tif (!(le32_to_cpu(iagp->wmap[extno]) & mask)) {\n\t\t\trelease_metapage(mp);\n\t\t\tjfs_error(ipimap->i_sb,\n\t\t\t\t  \"the inode is not allocated in the working map\\n\");\n\t\t\treturn -EIO;\n\t\t}\n\t\tif ((le32_to_cpu(iagp->pmap[extno]) & mask) != 0) {\n\t\t\trelease_metapage(mp);\n\t\t\tjfs_error(ipimap->i_sb,\n\t\t\t\t  \"the inode is not free in the persistent map\\n\");\n\t\t\treturn -EIO;\n\t\t}\n\t\t/* update the bitmap for the extent of the allocated inode */\n\t\tiagp->pmap[extno] |= cpu_to_le32(mask);\n\t}\n\t/*\n\t * update iag lsn\n\t */\n\tlsn = tblk->lsn;\n\tlog = JFS_SBI(tblk->sb)->log;\n\tLOGSYNC_LOCK(log, flags);\n\tif (mp->lsn != 0) {\n\t\t/* inherit older/smaller lsn */\n\t\tlogdiff(difft, lsn, log);\n\t\tlogdiff(diffp, mp->lsn, log);\n\t\tif (difft < diffp) {\n\t\t\tmp->lsn = lsn;\n\t\t\t/* move mp after tblock in logsync list */\n\t\t\tlist_move(&mp->synclist, &tblk->synclist);\n\t\t}\n\t\t/* inherit younger/larger clsn */\n\t\tassert(mp->clsn);\n\t\tlogdiff(difft, tblk->clsn, log);\n\t\tlogdiff(diffp, mp->clsn, log);\n\t\tif (difft > diffp)\n\t\t\tmp->clsn = tblk->clsn;\n\t} else {\n\t\tmp->log = log;\n\t\tmp->lsn = lsn;\n\t\t/* insert mp after tblock in logsync list */\n\t\tlog->count++;\n\t\tlist_add(&mp->synclist, &tblk->synclist);\n\t\tmp->clsn = tblk->clsn;\n\t}\n\tLOGSYNC_UNLOCK(log, flags);\n\twrite_metapage(mp);\n\treturn (0);\n}"
  },
  {
    "function_name": "diFindFree",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_imap.c",
    "lines": "2706-2717",
    "snippet": "static int diFindFree(u32 word, int start)\n{\n\tint bitno;\n\tassert(start < 32);\n\t/* scan the word for the first free bit. */\n\tfor (word <<= start, bitno = start; bitno < 32;\n\t     bitno++, word <<= 1) {\n\t\tif ((word & HIGHORDER) == 0)\n\t\t\tbreak;\n\t}\n\treturn (bitno);\n}",
    "includes": [
      "#include \"jfs_debug.h\"",
      "#include \"jfs_superblock.h\"",
      "#include \"jfs_metapage.h\"",
      "#include \"jfs_imap.h\"",
      "#include \"jfs_dmap.h\"",
      "#include \"jfs_dinode.h\"",
      "#include \"jfs_filsys.h\"",
      "#include \"jfs_inode.h\"",
      "#include \"jfs_incore.h\"",
      "#include <linux/slab.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int diFindFree(u32, int);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "start < 32"
          ],
          "line": 2709
        },
        "resolved": true,
        "details": {
          "function_name": "hpfs_lock_assert",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/hpfs_fn.h",
          "lines": "359-363",
          "snippet": "static inline void hpfs_lock_assert(struct super_block *s)\n{\n\tstruct hpfs_sb_info *sbi = hpfs_sb(s);\n\tWARN_ON(!mutex_is_locked(&sbi->hpfs_mutex));\n}",
          "includes": [
            "#include \"hpfs.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int hpfs_check_free_dnodes(struct super_block *, int);",
            "void hpfs_prefetch_sectors(struct super_block *, unsigned, int);",
            "void hpfs_prefetch_bitmap(struct super_block *, unsigned);",
            "unsigned char *hpfs_translate_name(struct super_block *, unsigned char *, unsigned, int, int);",
            "int hpfs_compare_names(struct super_block *, const unsigned char *, unsigned,\n\t\t       const unsigned char *, unsigned, int);",
            "void hpfs_error(struct super_block *, const char *, ...);",
            "int hpfs_stop_cycles(struct super_block *, int, int *, int *, char *);",
            "unsigned hpfs_get_free_dnodes(struct super_block *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"hpfs.h\"\n#include <asm/unaligned.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n#include <linux/mutex.h>\n\nint hpfs_check_free_dnodes(struct super_block *, int);\nvoid hpfs_prefetch_sectors(struct super_block *, unsigned, int);\nvoid hpfs_prefetch_bitmap(struct super_block *, unsigned);\nunsigned char *hpfs_translate_name(struct super_block *, unsigned char *, unsigned, int, int);\nint hpfs_compare_names(struct super_block *, const unsigned char *, unsigned,\n\t\t       const unsigned char *, unsigned, int);\nvoid hpfs_error(struct super_block *, const char *, ...);\nint hpfs_stop_cycles(struct super_block *, int, int *, int *, char *);\nunsigned hpfs_get_free_dnodes(struct super_block *);\n\nstatic inline void hpfs_lock_assert(struct super_block *s)\n{\n\tstruct hpfs_sb_info *sbi = hpfs_sb(s);\n\tWARN_ON(!mutex_is_locked(&sbi->hpfs_mutex));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_imap.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_dinode.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_inode.h\"\n#include \"jfs_incore.h\"\n#include <linux/slab.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n\nstatic int diFindFree(u32, int);\n\nstatic int diFindFree(u32 word, int start)\n{\n\tint bitno;\n\tassert(start < 32);\n\t/* scan the word for the first free bit. */\n\tfor (word <<= start, bitno = start; bitno < 32;\n\t     bitno++, word <<= 1) {\n\t\tif ((word & HIGHORDER) == 0)\n\t\t\tbreak;\n\t}\n\treturn (bitno);\n}"
  },
  {
    "function_name": "diIAGRead",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_imap.c",
    "lines": "2675-2690",
    "snippet": "static int diIAGRead(struct inomap * imap, int iagno, struct metapage ** mpp)\n{\n\tstruct inode *ipimap = imap->im_ipimap;\n\ts64 blkno;\n\n\t/* compute the logical block number of the iag. */\n\tblkno = IAGTOLBLK(iagno, JFS_SBI(ipimap->i_sb)->l2nbperpage);\n\n\t/* read the iag. */\n\t*mpp = read_metapage(ipimap, blkno, PSIZE, 0);\n\tif (*mpp == NULL) {\n\t\treturn -EIO;\n\t}\n\n\treturn (0);\n}",
    "includes": [
      "#include \"jfs_debug.h\"",
      "#include \"jfs_superblock.h\"",
      "#include \"jfs_metapage.h\"",
      "#include \"jfs_imap.h\"",
      "#include \"jfs_dmap.h\"",
      "#include \"jfs_dinode.h\"",
      "#include \"jfs_filsys.h\"",
      "#include \"jfs_inode.h\"",
      "#include \"jfs_incore.h\"",
      "#include <linux/slab.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int diAllocAG(struct inomap *, int, bool, struct inode *);",
      "static int diAllocAny(struct inomap *, int, bool, struct inode *);",
      "static int diAllocBit(struct inomap *, struct iag *, int);",
      "static int diAllocExt(struct inomap *, int, struct inode *);",
      "static int diAllocIno(struct inomap *, int, struct inode *);",
      "static int diNewExt(struct inomap *, struct iag *, int);",
      "static int diNewIAG(struct inomap *, int *, int, struct metapage **);",
      "static void duplicateIXtree(struct super_block *, s64, int, s64 *);",
      "static int diIAGRead(struct inomap * imap, int, struct metapage **);",
      "static int copy_from_dinode(struct dinode *, struct inode *);",
      "static void copy_to_dinode(struct dinode *, struct inode *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "read_metapage",
          "args": [
            "ipimap",
            "blkno",
            "PSIZE",
            "0"
          ],
          "line": 2684
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IAGTOLBLK",
          "args": [
            "iagno",
            "JFS_SBI(ipimap->i_sb)->l2nbperpage"
          ],
          "line": 2681
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "JFS_SBI",
          "args": [
            "ipimap->i_sb"
          ],
          "line": 2681
        },
        "resolved": true,
        "details": {
          "function_name": "JFS_SBI",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_incore.h",
          "lines": "217-220",
          "snippet": "static inline struct jfs_sb_info *JFS_SBI(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"jfs_dtree.h\"",
            "#include \"jfs_xtree.h\"",
            "#include \"jfs_types.h\"",
            "#include <linux/bitops.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_dtree.h\"\n#include \"jfs_xtree.h\"\n#include \"jfs_types.h\"\n#include <linux/bitops.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mutex.h>\n\nstatic inline struct jfs_sb_info *JFS_SBI(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_imap.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_dinode.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_inode.h\"\n#include \"jfs_incore.h\"\n#include <linux/slab.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n\nstatic int diAllocAG(struct inomap *, int, bool, struct inode *);\nstatic int diAllocAny(struct inomap *, int, bool, struct inode *);\nstatic int diAllocBit(struct inomap *, struct iag *, int);\nstatic int diAllocExt(struct inomap *, int, struct inode *);\nstatic int diAllocIno(struct inomap *, int, struct inode *);\nstatic int diNewExt(struct inomap *, struct iag *, int);\nstatic int diNewIAG(struct inomap *, int *, int, struct metapage **);\nstatic void duplicateIXtree(struct super_block *, s64, int, s64 *);\nstatic int diIAGRead(struct inomap * imap, int, struct metapage **);\nstatic int copy_from_dinode(struct dinode *, struct inode *);\nstatic void copy_to_dinode(struct dinode *, struct inode *);\n\nstatic int diIAGRead(struct inomap * imap, int iagno, struct metapage ** mpp)\n{\n\tstruct inode *ipimap = imap->im_ipimap;\n\ts64 blkno;\n\n\t/* compute the logical block number of the iag. */\n\tblkno = IAGTOLBLK(iagno, JFS_SBI(ipimap->i_sb)->l2nbperpage);\n\n\t/* read the iag. */\n\t*mpp = read_metapage(ipimap, blkno, PSIZE, 0);\n\tif (*mpp == NULL) {\n\t\treturn -EIO;\n\t}\n\n\treturn (0);\n}"
  },
  {
    "function_name": "diNewIAG",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_imap.c",
    "lines": "2451-2652",
    "snippet": "static int\ndiNewIAG(struct inomap * imap, int *iagnop, int agno, struct metapage ** mpp)\n{\n\tint rc;\n\tint iagno, i, xlen;\n\tstruct inode *ipimap;\n\tstruct super_block *sb;\n\tstruct jfs_sb_info *sbi;\n\tstruct metapage *mp;\n\tstruct iag *iagp;\n\ts64 xaddr = 0;\n\ts64 blkno;\n\ttid_t tid;\n\tstruct inode *iplist[1];\n\n\t/* pick up pointers to the inode map and mount inodes */\n\tipimap = imap->im_ipimap;\n\tsb = ipimap->i_sb;\n\tsbi = JFS_SBI(sb);\n\n\t/* acquire the free iag lock */\n\tIAGFREE_LOCK(imap);\n\n\t/* if there are any iags on the inode map free iag list,\n\t * allocate the iag from the head of the list.\n\t */\n\tif (imap->im_freeiag >= 0) {\n\t\t/* pick up the iag number at the head of the list */\n\t\tiagno = imap->im_freeiag;\n\n\t\t/* determine the logical block number of the iag */\n\t\tblkno = IAGTOLBLK(iagno, sbi->l2nbperpage);\n\t} else {\n\t\t/* no free iags. the inode map will have to be extented\n\t\t * to include a new iag.\n\t\t */\n\n\t\t/* acquire inode map lock */\n\t\tIWRITE_LOCK(ipimap, RDWRLOCK_IMAP);\n\n\t\tif (ipimap->i_size >> L2PSIZE != imap->im_nextiag + 1) {\n\t\t\tIWRITE_UNLOCK(ipimap);\n\t\t\tIAGFREE_UNLOCK(imap);\n\t\t\tjfs_error(imap->im_ipimap->i_sb,\n\t\t\t\t  \"ipimap->i_size is wrong\\n\");\n\t\t\treturn -EIO;\n\t\t}\n\n\n\t\t/* get the next available iag number */\n\t\tiagno = imap->im_nextiag;\n\n\t\t/* make sure that we have not exceeded the maximum inode\n\t\t * number limit.\n\t\t */\n\t\tif (iagno > (MAXIAGS - 1)) {\n\t\t\t/* release the inode map lock */\n\t\t\tIWRITE_UNLOCK(ipimap);\n\n\t\t\trc = -ENOSPC;\n\t\t\tgoto out;\n\t\t}\n\n\t\t/*\n\t\t * synchronously append new iag page.\n\t\t */\n\t\t/* determine the logical address of iag page to append */\n\t\tblkno = IAGTOLBLK(iagno, sbi->l2nbperpage);\n\n\t\t/* Allocate extent for new iag page */\n\t\txlen = sbi->nbperpage;\n\t\tif ((rc = dbAlloc(ipimap, 0, (s64) xlen, &xaddr))) {\n\t\t\t/* release the inode map lock */\n\t\t\tIWRITE_UNLOCK(ipimap);\n\n\t\t\tgoto out;\n\t\t}\n\n\t\t/*\n\t\t * start transaction of update of the inode map\n\t\t * addressing structure pointing to the new iag page;\n\t\t */\n\t\ttid = txBegin(sb, COMMIT_FORCE);\n\t\tmutex_lock(&JFS_IP(ipimap)->commit_mutex);\n\n\t\t/* update the inode map addressing structure to point to it */\n\t\tif ((rc =\n\t\t     xtInsert(tid, ipimap, 0, blkno, xlen, &xaddr, 0))) {\n\t\t\ttxEnd(tid);\n\t\t\tmutex_unlock(&JFS_IP(ipimap)->commit_mutex);\n\t\t\t/* Free the blocks allocated for the iag since it was\n\t\t\t * not successfully added to the inode map\n\t\t\t */\n\t\t\tdbFree(ipimap, xaddr, (s64) xlen);\n\n\t\t\t/* release the inode map lock */\n\t\t\tIWRITE_UNLOCK(ipimap);\n\n\t\t\tgoto out;\n\t\t}\n\n\t\t/* update the inode map's inode to reflect the extension */\n\t\tipimap->i_size += PSIZE;\n\t\tinode_add_bytes(ipimap, PSIZE);\n\n\t\t/* assign a buffer for the page */\n\t\tmp = get_metapage(ipimap, blkno, PSIZE, 0);\n\t\tif (!mp) {\n\t\t\t/*\n\t\t\t * This is very unlikely since we just created the\n\t\t\t * extent, but let's try to handle it correctly\n\t\t\t */\n\t\t\txtTruncate(tid, ipimap, ipimap->i_size - PSIZE,\n\t\t\t\t   COMMIT_PWMAP);\n\n\t\t\ttxAbort(tid, 0);\n\t\t\ttxEnd(tid);\n\t\t\tmutex_unlock(&JFS_IP(ipimap)->commit_mutex);\n\n\t\t\t/* release the inode map lock */\n\t\t\tIWRITE_UNLOCK(ipimap);\n\n\t\t\trc = -EIO;\n\t\t\tgoto out;\n\t\t}\n\t\tiagp = (struct iag *) mp->data;\n\n\t\t/* init the iag */\n\t\tmemset(iagp, 0, sizeof(struct iag));\n\t\tiagp->iagnum = cpu_to_le32(iagno);\n\t\tiagp->inofreefwd = iagp->inofreeback = cpu_to_le32(-1);\n\t\tiagp->extfreefwd = iagp->extfreeback = cpu_to_le32(-1);\n\t\tiagp->iagfree = cpu_to_le32(-1);\n\t\tiagp->nfreeinos = 0;\n\t\tiagp->nfreeexts = cpu_to_le32(EXTSPERIAG);\n\n\t\t/* initialize the free inode summary map (free extent\n\t\t * summary map initialization handled by bzero).\n\t\t */\n\t\tfor (i = 0; i < SMAPSZ; i++)\n\t\t\tiagp->inosmap[i] = cpu_to_le32(ONES);\n\n\t\t/*\n\t\t * Write and sync the metapage\n\t\t */\n\t\tflush_metapage(mp);\n\n\t\t/*\n\t\t * txCommit(COMMIT_FORCE) will synchronously write address\n\t\t * index pages and inode after commit in careful update order\n\t\t * of address index pages (right to left, bottom up);\n\t\t */\n\t\tiplist[0] = ipimap;\n\t\trc = txCommit(tid, 1, &iplist[0], COMMIT_FORCE);\n\n\t\ttxEnd(tid);\n\t\tmutex_unlock(&JFS_IP(ipimap)->commit_mutex);\n\n\t\tduplicateIXtree(sb, blkno, xlen, &xaddr);\n\n\t\t/* update the next available iag number */\n\t\timap->im_nextiag += 1;\n\n\t\t/* Add the iag to the iag free list so we don't lose the iag\n\t\t * if a failure happens now.\n\t\t */\n\t\timap->im_freeiag = iagno;\n\n\t\t/* Until we have logredo working, we want the imap inode &\n\t\t * control page to be up to date.\n\t\t */\n\t\tdiSync(ipimap);\n\n\t\t/* release the inode map lock */\n\t\tIWRITE_UNLOCK(ipimap);\n\t}\n\n\t/* obtain read lock on map */\n\tIREAD_LOCK(ipimap, RDWRLOCK_IMAP);\n\n\t/* read the iag */\n\tif ((rc = diIAGRead(imap, iagno, &mp))) {\n\t\tIREAD_UNLOCK(ipimap);\n\t\trc = -EIO;\n\t\tgoto out;\n\t}\n\tiagp = (struct iag *) mp->data;\n\n\t/* remove the iag from the iag free list */\n\timap->im_freeiag = le32_to_cpu(iagp->iagfree);\n\tiagp->iagfree = cpu_to_le32(-1);\n\n\t/* set the return iag number and buffer pointer */\n\t*iagnop = iagno;\n\t*mpp = mp;\n\n      out:\n\t/* release the iag free lock */\n\tIAGFREE_UNLOCK(imap);\n\n\treturn (rc);\n}",
    "includes": [
      "#include \"jfs_debug.h\"",
      "#include \"jfs_superblock.h\"",
      "#include \"jfs_metapage.h\"",
      "#include \"jfs_imap.h\"",
      "#include \"jfs_dmap.h\"",
      "#include \"jfs_dinode.h\"",
      "#include \"jfs_filsys.h\"",
      "#include \"jfs_inode.h\"",
      "#include \"jfs_incore.h\"",
      "#include <linux/slab.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int diAllocAG(struct inomap *, int, bool, struct inode *);",
      "static int diAllocAny(struct inomap *, int, bool, struct inode *);",
      "static int diAllocBit(struct inomap *, struct iag *, int);",
      "static int diAllocExt(struct inomap *, int, struct inode *);",
      "static int diAllocIno(struct inomap *, int, struct inode *);",
      "static int diNewExt(struct inomap *, struct iag *, int);",
      "static int diNewIAG(struct inomap *, int *, int, struct metapage **);",
      "static void duplicateIXtree(struct super_block *, s64, int, s64 *);",
      "static int diIAGRead(struct inomap * imap, int, struct metapage **);",
      "static int copy_from_dinode(struct dinode *, struct inode *);",
      "static void copy_to_dinode(struct dinode *, struct inode *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "IAGFREE_UNLOCK",
          "args": [
            "imap"
          ],
          "line": 2649
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "-1"
          ],
          "line": 2641
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "iagp->iagfree"
          ],
          "line": 2640
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "IREAD_UNLOCK",
          "args": [
            "ipimap"
          ],
          "line": 2633
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "diIAGRead",
          "args": [
            "imap",
            "iagno",
            "&mp"
          ],
          "line": 2632
        },
        "resolved": true,
        "details": {
          "function_name": "diIAGRead",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_imap.c",
          "lines": "2675-2690",
          "snippet": "static int diIAGRead(struct inomap * imap, int iagno, struct metapage ** mpp)\n{\n\tstruct inode *ipimap = imap->im_ipimap;\n\ts64 blkno;\n\n\t/* compute the logical block number of the iag. */\n\tblkno = IAGTOLBLK(iagno, JFS_SBI(ipimap->i_sb)->l2nbperpage);\n\n\t/* read the iag. */\n\t*mpp = read_metapage(ipimap, blkno, PSIZE, 0);\n\tif (*mpp == NULL) {\n\t\treturn -EIO;\n\t}\n\n\treturn (0);\n}",
          "includes": [
            "#include \"jfs_debug.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_imap.h\"",
            "#include \"jfs_dmap.h\"",
            "#include \"jfs_dinode.h\"",
            "#include \"jfs_filsys.h\"",
            "#include \"jfs_inode.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/slab.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int diAllocAG(struct inomap *, int, bool, struct inode *);",
            "static int diAllocAny(struct inomap *, int, bool, struct inode *);",
            "static int diAllocBit(struct inomap *, struct iag *, int);",
            "static int diAllocExt(struct inomap *, int, struct inode *);",
            "static int diAllocIno(struct inomap *, int, struct inode *);",
            "static int diNewExt(struct inomap *, struct iag *, int);",
            "static int diNewIAG(struct inomap *, int *, int, struct metapage **);",
            "static void duplicateIXtree(struct super_block *, s64, int, s64 *);",
            "static int diIAGRead(struct inomap * imap, int, struct metapage **);",
            "static int copy_from_dinode(struct dinode *, struct inode *);",
            "static void copy_to_dinode(struct dinode *, struct inode *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_imap.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_dinode.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_inode.h\"\n#include \"jfs_incore.h\"\n#include <linux/slab.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n\nstatic int diAllocAG(struct inomap *, int, bool, struct inode *);\nstatic int diAllocAny(struct inomap *, int, bool, struct inode *);\nstatic int diAllocBit(struct inomap *, struct iag *, int);\nstatic int diAllocExt(struct inomap *, int, struct inode *);\nstatic int diAllocIno(struct inomap *, int, struct inode *);\nstatic int diNewExt(struct inomap *, struct iag *, int);\nstatic int diNewIAG(struct inomap *, int *, int, struct metapage **);\nstatic void duplicateIXtree(struct super_block *, s64, int, s64 *);\nstatic int diIAGRead(struct inomap * imap, int, struct metapage **);\nstatic int copy_from_dinode(struct dinode *, struct inode *);\nstatic void copy_to_dinode(struct dinode *, struct inode *);\n\nstatic int diIAGRead(struct inomap * imap, int iagno, struct metapage ** mpp)\n{\n\tstruct inode *ipimap = imap->im_ipimap;\n\ts64 blkno;\n\n\t/* compute the logical block number of the iag. */\n\tblkno = IAGTOLBLK(iagno, JFS_SBI(ipimap->i_sb)->l2nbperpage);\n\n\t/* read the iag. */\n\t*mpp = read_metapage(ipimap, blkno, PSIZE, 0);\n\tif (*mpp == NULL) {\n\t\treturn -EIO;\n\t}\n\n\treturn (0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "IREAD_LOCK",
          "args": [
            "ipimap",
            "RDWRLOCK_IMAP"
          ],
          "line": 2629
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IWRITE_UNLOCK",
          "args": [
            "ipimap"
          ],
          "line": 2625
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "diSync",
          "args": [
            "ipimap"
          ],
          "line": 2622
        },
        "resolved": true,
        "details": {
          "function_name": "diSync",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_imap.c",
          "lines": "219-268",
          "snippet": "int diSync(struct inode *ipimap)\n{\n\tstruct dinomap_disk *dinom_le;\n\tstruct inomap *imp = JFS_IP(ipimap)->i_imap;\n\tstruct metapage *mp;\n\tint index;\n\n\t/*\n\t * write imap global conrol page\n\t */\n\t/* read the on-disk inode map control structure */\n\tmp = get_metapage(ipimap,\n\t\t\t  IMAPBLKNO << JFS_SBI(ipimap->i_sb)->l2nbperpage,\n\t\t\t  PSIZE, 0);\n\tif (mp == NULL) {\n\t\tjfs_err(\"diSync: get_metapage failed!\");\n\t\treturn -EIO;\n\t}\n\n\t/* copy the in-memory version to the on-disk version */\n\tdinom_le = (struct dinomap_disk *) mp->data;\n\tdinom_le->in_freeiag = cpu_to_le32(imp->im_freeiag);\n\tdinom_le->in_nextiag = cpu_to_le32(imp->im_nextiag);\n\tdinom_le->in_numinos = cpu_to_le32(atomic_read(&imp->im_numinos));\n\tdinom_le->in_numfree = cpu_to_le32(atomic_read(&imp->im_numfree));\n\tdinom_le->in_nbperiext = cpu_to_le32(imp->im_nbperiext);\n\tdinom_le->in_l2nbperiext = cpu_to_le32(imp->im_l2nbperiext);\n\tfor (index = 0; index < MAXAG; index++) {\n\t\tdinom_le->in_agctl[index].inofree =\n\t\t    cpu_to_le32(imp->im_agctl[index].inofree);\n\t\tdinom_le->in_agctl[index].extfree =\n\t\t    cpu_to_le32(imp->im_agctl[index].extfree);\n\t\tdinom_le->in_agctl[index].numinos =\n\t\t    cpu_to_le32(imp->im_agctl[index].numinos);\n\t\tdinom_le->in_agctl[index].numfree =\n\t\t    cpu_to_le32(imp->im_agctl[index].numfree);\n\t}\n\n\t/* write out the control structure */\n\twrite_metapage(mp);\n\n\t/*\n\t * write out dirty pages of imap\n\t */\n\tfilemap_write_and_wait(ipimap->i_mapping);\n\n\tdiWriteSpecial(ipimap, 0);\n\n\treturn (0);\n}",
          "includes": [
            "#include \"jfs_debug.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_imap.h\"",
            "#include \"jfs_dmap.h\"",
            "#include \"jfs_dinode.h\"",
            "#include \"jfs_filsys.h\"",
            "#include \"jfs_inode.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/slab.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int diAllocAG(struct inomap *, int, bool, struct inode *);",
            "static int diAllocAny(struct inomap *, int, bool, struct inode *);",
            "static int diAllocExt(struct inomap *, int, struct inode *);",
            "static int diAllocIno(struct inomap *, int, struct inode *);",
            "static int diNewIAG(struct inomap *, int *, int, struct metapage **);",
            "static int diIAGRead(struct inomap * imap, int, struct metapage **);",
            "static int copy_from_dinode(struct dinode *, struct inode *);",
            "static void copy_to_dinode(struct dinode *, struct inode *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_imap.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_dinode.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_inode.h\"\n#include \"jfs_incore.h\"\n#include <linux/slab.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n\nstatic int diAllocAG(struct inomap *, int, bool, struct inode *);\nstatic int diAllocAny(struct inomap *, int, bool, struct inode *);\nstatic int diAllocExt(struct inomap *, int, struct inode *);\nstatic int diAllocIno(struct inomap *, int, struct inode *);\nstatic int diNewIAG(struct inomap *, int *, int, struct metapage **);\nstatic int diIAGRead(struct inomap * imap, int, struct metapage **);\nstatic int copy_from_dinode(struct dinode *, struct inode *);\nstatic void copy_to_dinode(struct dinode *, struct inode *);\n\nint diSync(struct inode *ipimap)\n{\n\tstruct dinomap_disk *dinom_le;\n\tstruct inomap *imp = JFS_IP(ipimap)->i_imap;\n\tstruct metapage *mp;\n\tint index;\n\n\t/*\n\t * write imap global conrol page\n\t */\n\t/* read the on-disk inode map control structure */\n\tmp = get_metapage(ipimap,\n\t\t\t  IMAPBLKNO << JFS_SBI(ipimap->i_sb)->l2nbperpage,\n\t\t\t  PSIZE, 0);\n\tif (mp == NULL) {\n\t\tjfs_err(\"diSync: get_metapage failed!\");\n\t\treturn -EIO;\n\t}\n\n\t/* copy the in-memory version to the on-disk version */\n\tdinom_le = (struct dinomap_disk *) mp->data;\n\tdinom_le->in_freeiag = cpu_to_le32(imp->im_freeiag);\n\tdinom_le->in_nextiag = cpu_to_le32(imp->im_nextiag);\n\tdinom_le->in_numinos = cpu_to_le32(atomic_read(&imp->im_numinos));\n\tdinom_le->in_numfree = cpu_to_le32(atomic_read(&imp->im_numfree));\n\tdinom_le->in_nbperiext = cpu_to_le32(imp->im_nbperiext);\n\tdinom_le->in_l2nbperiext = cpu_to_le32(imp->im_l2nbperiext);\n\tfor (index = 0; index < MAXAG; index++) {\n\t\tdinom_le->in_agctl[index].inofree =\n\t\t    cpu_to_le32(imp->im_agctl[index].inofree);\n\t\tdinom_le->in_agctl[index].extfree =\n\t\t    cpu_to_le32(imp->im_agctl[index].extfree);\n\t\tdinom_le->in_agctl[index].numinos =\n\t\t    cpu_to_le32(imp->im_agctl[index].numinos);\n\t\tdinom_le->in_agctl[index].numfree =\n\t\t    cpu_to_le32(imp->im_agctl[index].numfree);\n\t}\n\n\t/* write out the control structure */\n\twrite_metapage(mp);\n\n\t/*\n\t * write out dirty pages of imap\n\t */\n\tfilemap_write_and_wait(ipimap->i_mapping);\n\n\tdiWriteSpecial(ipimap, 0);\n\n\treturn (0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "duplicateIXtree",
          "args": [
            "sb",
            "blkno",
            "xlen",
            "&xaddr"
          ],
          "line": 2609
        },
        "resolved": true,
        "details": {
          "function_name": "duplicateIXtree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_imap.c",
          "lines": "2994-3035",
          "snippet": "static void duplicateIXtree(struct super_block *sb, s64 blkno,\n\t\t\t    int xlen, s64 *xaddr)\n{\n\tstruct jfs_superblock *j_sb;\n\tstruct buffer_head *bh;\n\tstruct inode *ip;\n\ttid_t tid;\n\n\t/* if AIT2 ipmap2 is bad, do not try to update it */\n\tif (JFS_SBI(sb)->mntflag & JFS_BAD_SAIT)\t/* s_flag */\n\t\treturn;\n\tip = diReadSpecial(sb, FILESYSTEM_I, 1);\n\tif (ip == NULL) {\n\t\tJFS_SBI(sb)->mntflag |= JFS_BAD_SAIT;\n\t\tif (readSuper(sb, &bh))\n\t\t\treturn;\n\t\tj_sb = (struct jfs_superblock *)bh->b_data;\n\t\tj_sb->s_flag |= cpu_to_le32(JFS_BAD_SAIT);\n\n\t\tmark_buffer_dirty(bh);\n\t\tsync_dirty_buffer(bh);\n\t\tbrelse(bh);\n\t\treturn;\n\t}\n\n\t/* start transaction */\n\ttid = txBegin(sb, COMMIT_FORCE);\n\t/* update the inode map addressing structure to point to it */\n\tif (xtInsert(tid, ip, 0, blkno, xlen, xaddr, 0)) {\n\t\tJFS_SBI(sb)->mntflag |= JFS_BAD_SAIT;\n\t\ttxAbort(tid, 1);\n\t\tgoto cleanup;\n\n\t}\n\t/* update the inode map's inode to reflect the extension */\n\tip->i_size += PSIZE;\n\tinode_add_bytes(ip, PSIZE);\n\ttxCommit(tid, 1, &ip, COMMIT_FORCE);\n      cleanup:\n\ttxEnd(tid);\n\tdiFreeSpecial(ip);\n}",
          "includes": [
            "#include \"jfs_debug.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_imap.h\"",
            "#include \"jfs_dmap.h\"",
            "#include \"jfs_dinode.h\"",
            "#include \"jfs_filsys.h\"",
            "#include \"jfs_inode.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/slab.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int diAllocAG(struct inomap *, int, bool, struct inode *);",
            "static int diAllocAny(struct inomap *, int, bool, struct inode *);",
            "static int diAllocExt(struct inomap *, int, struct inode *);",
            "static int diAllocIno(struct inomap *, int, struct inode *);",
            "static void duplicateIXtree(struct super_block *, s64, int, s64 *);",
            "static int copy_from_dinode(struct dinode *, struct inode *);",
            "static void copy_to_dinode(struct dinode *, struct inode *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_imap.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_dinode.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_inode.h\"\n#include \"jfs_incore.h\"\n#include <linux/slab.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n\nstatic int diAllocAG(struct inomap *, int, bool, struct inode *);\nstatic int diAllocAny(struct inomap *, int, bool, struct inode *);\nstatic int diAllocExt(struct inomap *, int, struct inode *);\nstatic int diAllocIno(struct inomap *, int, struct inode *);\nstatic void duplicateIXtree(struct super_block *, s64, int, s64 *);\nstatic int copy_from_dinode(struct dinode *, struct inode *);\nstatic void copy_to_dinode(struct dinode *, struct inode *);\n\nstatic void duplicateIXtree(struct super_block *sb, s64 blkno,\n\t\t\t    int xlen, s64 *xaddr)\n{\n\tstruct jfs_superblock *j_sb;\n\tstruct buffer_head *bh;\n\tstruct inode *ip;\n\ttid_t tid;\n\n\t/* if AIT2 ipmap2 is bad, do not try to update it */\n\tif (JFS_SBI(sb)->mntflag & JFS_BAD_SAIT)\t/* s_flag */\n\t\treturn;\n\tip = diReadSpecial(sb, FILESYSTEM_I, 1);\n\tif (ip == NULL) {\n\t\tJFS_SBI(sb)->mntflag |= JFS_BAD_SAIT;\n\t\tif (readSuper(sb, &bh))\n\t\t\treturn;\n\t\tj_sb = (struct jfs_superblock *)bh->b_data;\n\t\tj_sb->s_flag |= cpu_to_le32(JFS_BAD_SAIT);\n\n\t\tmark_buffer_dirty(bh);\n\t\tsync_dirty_buffer(bh);\n\t\tbrelse(bh);\n\t\treturn;\n\t}\n\n\t/* start transaction */\n\ttid = txBegin(sb, COMMIT_FORCE);\n\t/* update the inode map addressing structure to point to it */\n\tif (xtInsert(tid, ip, 0, blkno, xlen, xaddr, 0)) {\n\t\tJFS_SBI(sb)->mntflag |= JFS_BAD_SAIT;\n\t\ttxAbort(tid, 1);\n\t\tgoto cleanup;\n\n\t}\n\t/* update the inode map's inode to reflect the extension */\n\tip->i_size += PSIZE;\n\tinode_add_bytes(ip, PSIZE);\n\ttxCommit(tid, 1, &ip, COMMIT_FORCE);\n      cleanup:\n\ttxEnd(tid);\n\tdiFreeSpecial(ip);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&JFS_IP(ipimap)->commit_mutex"
          ],
          "line": 2607
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "JFS_IP",
          "args": [
            "ipimap"
          ],
          "line": 2607
        },
        "resolved": true,
        "details": {
          "function_name": "JFS_IP",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_incore.h",
          "lines": "207-210",
          "snippet": "static inline struct jfs_inode_info *JFS_IP(struct inode *inode)\n{\n\treturn list_entry(inode, struct jfs_inode_info, vfs_inode);\n}",
          "includes": [
            "#include \"jfs_dtree.h\"",
            "#include \"jfs_xtree.h\"",
            "#include \"jfs_types.h\"",
            "#include <linux/bitops.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_dtree.h\"\n#include \"jfs_xtree.h\"\n#include \"jfs_types.h\"\n#include <linux/bitops.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mutex.h>\n\nstatic inline struct jfs_inode_info *JFS_IP(struct inode *inode)\n{\n\treturn list_entry(inode, struct jfs_inode_info, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "txEnd",
          "args": [
            "tid"
          ],
          "line": 2606
        },
        "resolved": true,
        "details": {
          "function_name": "txEnd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_txnmgr.c",
          "lines": "500-577",
          "snippet": "void txEnd(tid_t tid)\n{\n\tstruct tblock *tblk = tid_to_tblock(tid);\n\tstruct jfs_log *log;\n\n\tjfs_info(\"txEnd: tid = %d\", tid);\n\tTXN_LOCK();\n\n\t/*\n\t * wakeup transactions waiting on the page locked\n\t * by the current transaction\n\t */\n\tTXN_WAKEUP(&tblk->waitor);\n\n\tlog = JFS_SBI(tblk->sb)->log;\n\n\t/*\n\t * Lazy commit thread can't free this guy until we mark it UNLOCKED,\n\t * otherwise, we would be left with a transaction that may have been\n\t * reused.\n\t *\n\t * Lazy commit thread will turn off tblkGC_LAZY before calling this\n\t * routine.\n\t */\n\tif (tblk->flag & tblkGC_LAZY) {\n\t\tjfs_info(\"txEnd called w/lazy tid: %d, tblk = 0x%p\", tid, tblk);\n\t\tTXN_UNLOCK();\n\n\t\tspin_lock_irq(&log->gclock);\t// LOGGC_LOCK\n\t\ttblk->flag |= tblkGC_UNLOCKED;\n\t\tspin_unlock_irq(&log->gclock);\t// LOGGC_UNLOCK\n\t\treturn;\n\t}\n\n\tjfs_info(\"txEnd: tid: %d, tblk = 0x%p\", tid, tblk);\n\n\tassert(tblk->next == 0);\n\n\t/*\n\t * insert tblock back on freelist\n\t */\n\ttblk->next = TxAnchor.freetid;\n\tTxAnchor.freetid = tid;\n\n\t/*\n\t * mark the tblock not active\n\t */\n\tif (--log->active == 0) {\n\t\tclear_bit(log_FLUSH, &log->flag);\n\n\t\t/*\n\t\t * synchronize with logsync barrier\n\t\t */\n\t\tif (test_bit(log_SYNCBARRIER, &log->flag)) {\n\t\t\tTXN_UNLOCK();\n\n\t\t\t/* write dirty metadata & forward log syncpt */\n\t\t\tjfs_syncpt(log, 1);\n\n\t\t\tjfs_info(\"log barrier off: 0x%x\", log->lsn);\n\n\t\t\t/* enable new transactions start */\n\t\t\tclear_bit(log_SYNCBARRIER, &log->flag);\n\n\t\t\t/* wakeup all waitors for logsync barrier */\n\t\t\tTXN_WAKEUP(&log->syncwait);\n\n\t\t\tgoto wakeup;\n\t\t}\n\t}\n\n\tTXN_UNLOCK();\nwakeup:\n\t/*\n\t * wakeup all waitors for a free tblock\n\t */\n\tTXN_WAKEUP(&TxAnchor.freewait);\n}",
          "includes": [
            "#include \"jfs_debug.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_dmap.h\"",
            "#include \"jfs_imap.h\"",
            "#include \"jfs_dinode.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_filsys.h\"",
            "#include \"jfs_inode.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/freezer.h>",
            "#include <linux/completion.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct {\n\tint freetid;\t\t/* index of a free tid structure */\n\tint freelock;\t\t/* index first free lock word */\n\twait_queue_head_t freewait;\t/* eventlist of free tblock */\n\twait_queue_head_t freelockwait;\t/* eventlist of free tlock */\n\twait_queue_head_t lowlockwait;\t/* eventlist of ample tlocks */\n\tint tlocksInUse;\t/* Number of tlocks in use */\n\tspinlock_t LazyLock;\t/* synchronize sync_queue & unlock_queue */\n/*\tstruct tblock *sync_queue; * Transactions waiting for data sync */\n\tstruct list_head unlock_queue;\t/* Txns waiting to be released */\n\tstruct list_head anon_list;\t/* inodes having anonymous txns */\n\tstruct list_head anon_list2;\t/* inodes having anonymous txns\n\t\t\t\t\t   that couldn't be sync'ed */\n} TxAnchor;",
            "static void txAllocPMap(struct inode *ip, struct maplock * maplock,\n\t\tstruct tblock * tblk);",
            "static void txForce(struct tblock * tblk);",
            "static void txUpdateMap(struct tblock * tblk);",
            "static void txRelease(struct tblock * tblk);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_imap.h\"\n#include \"jfs_dinode.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_inode.h\"\n#include \"jfs_incore.h\"\n#include <linux/seq_file.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/freezer.h>\n#include <linux/completion.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n\nstatic struct {\n\tint freetid;\t\t/* index of a free tid structure */\n\tint freelock;\t\t/* index first free lock word */\n\twait_queue_head_t freewait;\t/* eventlist of free tblock */\n\twait_queue_head_t freelockwait;\t/* eventlist of free tlock */\n\twait_queue_head_t lowlockwait;\t/* eventlist of ample tlocks */\n\tint tlocksInUse;\t/* Number of tlocks in use */\n\tspinlock_t LazyLock;\t/* synchronize sync_queue & unlock_queue */\n/*\tstruct tblock *sync_queue; * Transactions waiting for data sync */\n\tstruct list_head unlock_queue;\t/* Txns waiting to be released */\n\tstruct list_head anon_list;\t/* inodes having anonymous txns */\n\tstruct list_head anon_list2;\t/* inodes having anonymous txns\n\t\t\t\t\t   that couldn't be sync'ed */\n} TxAnchor;\nstatic void txAllocPMap(struct inode *ip, struct maplock * maplock,\n\t\tstruct tblock * tblk);\nstatic void txForce(struct tblock * tblk);\nstatic void txUpdateMap(struct tblock * tblk);\nstatic void txRelease(struct tblock * tblk);\n\nvoid txEnd(tid_t tid)\n{\n\tstruct tblock *tblk = tid_to_tblock(tid);\n\tstruct jfs_log *log;\n\n\tjfs_info(\"txEnd: tid = %d\", tid);\n\tTXN_LOCK();\n\n\t/*\n\t * wakeup transactions waiting on the page locked\n\t * by the current transaction\n\t */\n\tTXN_WAKEUP(&tblk->waitor);\n\n\tlog = JFS_SBI(tblk->sb)->log;\n\n\t/*\n\t * Lazy commit thread can't free this guy until we mark it UNLOCKED,\n\t * otherwise, we would be left with a transaction that may have been\n\t * reused.\n\t *\n\t * Lazy commit thread will turn off tblkGC_LAZY before calling this\n\t * routine.\n\t */\n\tif (tblk->flag & tblkGC_LAZY) {\n\t\tjfs_info(\"txEnd called w/lazy tid: %d, tblk = 0x%p\", tid, tblk);\n\t\tTXN_UNLOCK();\n\n\t\tspin_lock_irq(&log->gclock);\t// LOGGC_LOCK\n\t\ttblk->flag |= tblkGC_UNLOCKED;\n\t\tspin_unlock_irq(&log->gclock);\t// LOGGC_UNLOCK\n\t\treturn;\n\t}\n\n\tjfs_info(\"txEnd: tid: %d, tblk = 0x%p\", tid, tblk);\n\n\tassert(tblk->next == 0);\n\n\t/*\n\t * insert tblock back on freelist\n\t */\n\ttblk->next = TxAnchor.freetid;\n\tTxAnchor.freetid = tid;\n\n\t/*\n\t * mark the tblock not active\n\t */\n\tif (--log->active == 0) {\n\t\tclear_bit(log_FLUSH, &log->flag);\n\n\t\t/*\n\t\t * synchronize with logsync barrier\n\t\t */\n\t\tif (test_bit(log_SYNCBARRIER, &log->flag)) {\n\t\t\tTXN_UNLOCK();\n\n\t\t\t/* write dirty metadata & forward log syncpt */\n\t\t\tjfs_syncpt(log, 1);\n\n\t\t\tjfs_info(\"log barrier off: 0x%x\", log->lsn);\n\n\t\t\t/* enable new transactions start */\n\t\t\tclear_bit(log_SYNCBARRIER, &log->flag);\n\n\t\t\t/* wakeup all waitors for logsync barrier */\n\t\t\tTXN_WAKEUP(&log->syncwait);\n\n\t\t\tgoto wakeup;\n\t\t}\n\t}\n\n\tTXN_UNLOCK();\nwakeup:\n\t/*\n\t * wakeup all waitors for a free tblock\n\t */\n\tTXN_WAKEUP(&TxAnchor.freewait);\n}"
        }
      },
      {
        "call_info": {
          "callee": "txCommit",
          "args": [
            "tid",
            "1",
            "&iplist[0]",
            "COMMIT_FORCE"
          ],
          "line": 2604
        },
        "resolved": true,
        "details": {
          "function_name": "txCommit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_txnmgr.c",
          "lines": "1135-1368",
          "snippet": "int txCommit(tid_t tid,\t\t/* transaction identifier */\n\t     int nip,\t\t/* number of inodes to commit */\n\t     struct inode **iplist,\t/* list of inode to commit */\n\t     int flag)\n{\n\tint rc = 0;\n\tstruct commit cd;\n\tstruct jfs_log *log;\n\tstruct tblock *tblk;\n\tstruct lrd *lrd;\n\tstruct inode *ip;\n\tstruct jfs_inode_info *jfs_ip;\n\tint k, n;\n\tino_t top;\n\tstruct super_block *sb;\n\n\tjfs_info(\"txCommit, tid = %d, flag = %d\", tid, flag);\n\t/* is read-only file system ? */\n\tif (isReadOnly(iplist[0])) {\n\t\trc = -EROFS;\n\t\tgoto TheEnd;\n\t}\n\n\tsb = cd.sb = iplist[0]->i_sb;\n\tcd.tid = tid;\n\n\tif (tid == 0)\n\t\ttid = txBegin(sb, 0);\n\ttblk = tid_to_tblock(tid);\n\n\t/*\n\t * initialize commit structure\n\t */\n\tlog = JFS_SBI(sb)->log;\n\tcd.log = log;\n\n\t/* initialize log record descriptor in commit */\n\tlrd = &cd.lrd;\n\tlrd->logtid = cpu_to_le32(tblk->logtid);\n\tlrd->backchain = 0;\n\n\ttblk->xflag |= flag;\n\n\tif ((flag & (COMMIT_FORCE | COMMIT_SYNC)) == 0)\n\t\ttblk->xflag |= COMMIT_LAZY;\n\t/*\n\t *\tprepare non-journaled objects for commit\n\t *\n\t * flush data pages of non-journaled file\n\t * to prevent the file getting non-initialized disk blocks\n\t * in case of crash.\n\t * (new blocks - )\n\t */\n\tcd.iplist = iplist;\n\tcd.nip = nip;\n\n\t/*\n\t *\tacquire transaction lock on (on-disk) inodes\n\t *\n\t * update on-disk inode from in-memory inode\n\t * acquiring transaction locks for AFTER records\n\t * on the on-disk inode of file object\n\t *\n\t * sort the inodes array by inode number in descending order\n\t * to prevent deadlock when acquiring transaction lock\n\t * of on-disk inodes on multiple on-disk inode pages by\n\t * multiple concurrent transactions\n\t */\n\tfor (k = 0; k < cd.nip; k++) {\n\t\ttop = (cd.iplist[k])->i_ino;\n\t\tfor (n = k + 1; n < cd.nip; n++) {\n\t\t\tip = cd.iplist[n];\n\t\t\tif (ip->i_ino > top) {\n\t\t\t\ttop = ip->i_ino;\n\t\t\t\tcd.iplist[n] = cd.iplist[k];\n\t\t\t\tcd.iplist[k] = ip;\n\t\t\t}\n\t\t}\n\n\t\tip = cd.iplist[k];\n\t\tjfs_ip = JFS_IP(ip);\n\n\t\t/*\n\t\t * BUGBUG - This code has temporarily been removed.  The\n\t\t * intent is to ensure that any file data is written before\n\t\t * the metadata is committed to the journal.  This prevents\n\t\t * uninitialized data from appearing in a file after the\n\t\t * journal has been replayed.  (The uninitialized data\n\t\t * could be sensitive data removed by another user.)\n\t\t *\n\t\t * The problem now is that we are holding the IWRITELOCK\n\t\t * on the inode, and calling filemap_fdatawrite on an\n\t\t * unmapped page will cause a deadlock in jfs_get_block.\n\t\t *\n\t\t * The long term solution is to pare down the use of\n\t\t * IWRITELOCK.  We are currently holding it too long.\n\t\t * We could also be smarter about which data pages need\n\t\t * to be written before the transaction is committed and\n\t\t * when we don't need to worry about it at all.\n\t\t *\n\t\t * if ((!S_ISDIR(ip->i_mode))\n\t\t *    && (tblk->flag & COMMIT_DELETE) == 0)\n\t\t *\tfilemap_write_and_wait(ip->i_mapping);\n\t\t */\n\n\t\t/*\n\t\t * Mark inode as not dirty.  It will still be on the dirty\n\t\t * inode list, but we'll know not to commit it again unless\n\t\t * it gets marked dirty again\n\t\t */\n\t\tclear_cflag(COMMIT_Dirty, ip);\n\n\t\t/* inherit anonymous tlock(s) of inode */\n\t\tif (jfs_ip->atlhead) {\n\t\t\tlid_to_tlock(jfs_ip->atltail)->next = tblk->next;\n\t\t\ttblk->next = jfs_ip->atlhead;\n\t\t\tif (!tblk->last)\n\t\t\t\ttblk->last = jfs_ip->atltail;\n\t\t\tjfs_ip->atlhead = jfs_ip->atltail = 0;\n\t\t\tTXN_LOCK();\n\t\t\tlist_del_init(&jfs_ip->anon_inode_list);\n\t\t\tTXN_UNLOCK();\n\t\t}\n\n\t\t/*\n\t\t * acquire transaction lock on on-disk inode page\n\t\t * (become first tlock of the tblk's tlock list)\n\t\t */\n\t\tif (((rc = diWrite(tid, ip))))\n\t\t\tgoto out;\n\t}\n\n\t/*\n\t *\twrite log records from transaction locks\n\t *\n\t * txUpdateMap() resets XAD_NEW in XAD.\n\t */\n\tif ((rc = txLog(log, tblk, &cd)))\n\t\tgoto TheEnd;\n\n\t/*\n\t * Ensure that inode isn't reused before\n\t * lazy commit thread finishes processing\n\t */\n\tif (tblk->xflag & COMMIT_DELETE) {\n\t\tihold(tblk->u.ip);\n\t\t/*\n\t\t * Avoid a rare deadlock\n\t\t *\n\t\t * If the inode is locked, we may be blocked in\n\t\t * jfs_commit_inode.  If so, we don't want the\n\t\t * lazy_commit thread doing the last iput() on the inode\n\t\t * since that may block on the locked inode.  Instead,\n\t\t * commit the transaction synchronously, so the last iput\n\t\t * will be done by the calling thread (or later)\n\t\t */\n\t\t/*\n\t\t * I believe this code is no longer needed.  Splitting I_LOCK\n\t\t * into two bits, I_NEW and I_SYNC should prevent this\n\t\t * deadlock as well.  But since I don't have a JFS testload\n\t\t * to verify this, only a trivial s/I_LOCK/I_SYNC/ was done.\n\t\t * Joern\n\t\t */\n\t\tif (tblk->u.ip->i_state & I_SYNC)\n\t\t\ttblk->xflag &= ~COMMIT_LAZY;\n\t}\n\n\tASSERT((!(tblk->xflag & COMMIT_DELETE)) ||\n\t       ((tblk->u.ip->i_nlink == 0) &&\n\t\t!test_cflag(COMMIT_Nolink, tblk->u.ip)));\n\n\t/*\n\t *\twrite COMMIT log record\n\t */\n\tlrd->type = cpu_to_le16(LOG_COMMIT);\n\tlrd->length = 0;\n\tlmLog(log, tblk, lrd, NULL);\n\n\tlmGroupCommit(log, tblk);\n\n\t/*\n\t *\t- transaction is now committed -\n\t */\n\n\t/*\n\t * force pages in careful update\n\t * (imap addressing structure update)\n\t */\n\tif (flag & COMMIT_FORCE)\n\t\ttxForce(tblk);\n\n\t/*\n\t *\tupdate allocation map.\n\t *\n\t * update inode allocation map and inode:\n\t * free pager lock on memory object of inode if any.\n\t * update block allocation map.\n\t *\n\t * txUpdateMap() resets XAD_NEW in XAD.\n\t */\n\tif (tblk->xflag & COMMIT_FORCE)\n\t\ttxUpdateMap(tblk);\n\n\t/*\n\t *\tfree transaction locks and pageout/free pages\n\t */\n\ttxRelease(tblk);\n\n\tif ((tblk->flag & tblkGC_LAZY) == 0)\n\t\ttxUnlock(tblk);\n\n\n\t/*\n\t *\treset in-memory object state\n\t */\n\tfor (k = 0; k < cd.nip; k++) {\n\t\tip = cd.iplist[k];\n\t\tjfs_ip = JFS_IP(ip);\n\n\t\t/*\n\t\t * reset in-memory inode state\n\t\t */\n\t\tjfs_ip->bxflag = 0;\n\t\tjfs_ip->blid = 0;\n\t}\n\n      out:\n\tif (rc != 0)\n\t\ttxAbort(tid, 1);\n\n      TheEnd:\n\tjfs_info(\"txCommit: tid = %d, returning %d\", tid, rc);\n\treturn rc;\n}",
          "includes": [
            "#include \"jfs_debug.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_dmap.h\"",
            "#include \"jfs_imap.h\"",
            "#include \"jfs_dinode.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_filsys.h\"",
            "#include \"jfs_inode.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/freezer.h>",
            "#include <linux/completion.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int diLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t\tstruct tlock * tlck, struct commit * cd);",
            "static void txAllocPMap(struct inode *ip, struct maplock * maplock,\n\t\tstruct tblock * tblk);",
            "static void txForce(struct tblock * tblk);",
            "static int txLog(struct jfs_log * log, struct tblock * tblk,\n\t\tstruct commit * cd);",
            "static void txUpdateMap(struct tblock * tblk);",
            "static void txRelease(struct tblock * tblk);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_imap.h\"\n#include \"jfs_dinode.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_inode.h\"\n#include \"jfs_incore.h\"\n#include <linux/seq_file.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/freezer.h>\n#include <linux/completion.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n\nstatic int diLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t\tstruct tlock * tlck, struct commit * cd);\nstatic void txAllocPMap(struct inode *ip, struct maplock * maplock,\n\t\tstruct tblock * tblk);\nstatic void txForce(struct tblock * tblk);\nstatic int txLog(struct jfs_log * log, struct tblock * tblk,\n\t\tstruct commit * cd);\nstatic void txUpdateMap(struct tblock * tblk);\nstatic void txRelease(struct tblock * tblk);\n\nint txCommit(tid_t tid,\t\t/* transaction identifier */\n\t     int nip,\t\t/* number of inodes to commit */\n\t     struct inode **iplist,\t/* list of inode to commit */\n\t     int flag)\n{\n\tint rc = 0;\n\tstruct commit cd;\n\tstruct jfs_log *log;\n\tstruct tblock *tblk;\n\tstruct lrd *lrd;\n\tstruct inode *ip;\n\tstruct jfs_inode_info *jfs_ip;\n\tint k, n;\n\tino_t top;\n\tstruct super_block *sb;\n\n\tjfs_info(\"txCommit, tid = %d, flag = %d\", tid, flag);\n\t/* is read-only file system ? */\n\tif (isReadOnly(iplist[0])) {\n\t\trc = -EROFS;\n\t\tgoto TheEnd;\n\t}\n\n\tsb = cd.sb = iplist[0]->i_sb;\n\tcd.tid = tid;\n\n\tif (tid == 0)\n\t\ttid = txBegin(sb, 0);\n\ttblk = tid_to_tblock(tid);\n\n\t/*\n\t * initialize commit structure\n\t */\n\tlog = JFS_SBI(sb)->log;\n\tcd.log = log;\n\n\t/* initialize log record descriptor in commit */\n\tlrd = &cd.lrd;\n\tlrd->logtid = cpu_to_le32(tblk->logtid);\n\tlrd->backchain = 0;\n\n\ttblk->xflag |= flag;\n\n\tif ((flag & (COMMIT_FORCE | COMMIT_SYNC)) == 0)\n\t\ttblk->xflag |= COMMIT_LAZY;\n\t/*\n\t *\tprepare non-journaled objects for commit\n\t *\n\t * flush data pages of non-journaled file\n\t * to prevent the file getting non-initialized disk blocks\n\t * in case of crash.\n\t * (new blocks - )\n\t */\n\tcd.iplist = iplist;\n\tcd.nip = nip;\n\n\t/*\n\t *\tacquire transaction lock on (on-disk) inodes\n\t *\n\t * update on-disk inode from in-memory inode\n\t * acquiring transaction locks for AFTER records\n\t * on the on-disk inode of file object\n\t *\n\t * sort the inodes array by inode number in descending order\n\t * to prevent deadlock when acquiring transaction lock\n\t * of on-disk inodes on multiple on-disk inode pages by\n\t * multiple concurrent transactions\n\t */\n\tfor (k = 0; k < cd.nip; k++) {\n\t\ttop = (cd.iplist[k])->i_ino;\n\t\tfor (n = k + 1; n < cd.nip; n++) {\n\t\t\tip = cd.iplist[n];\n\t\t\tif (ip->i_ino > top) {\n\t\t\t\ttop = ip->i_ino;\n\t\t\t\tcd.iplist[n] = cd.iplist[k];\n\t\t\t\tcd.iplist[k] = ip;\n\t\t\t}\n\t\t}\n\n\t\tip = cd.iplist[k];\n\t\tjfs_ip = JFS_IP(ip);\n\n\t\t/*\n\t\t * BUGBUG - This code has temporarily been removed.  The\n\t\t * intent is to ensure that any file data is written before\n\t\t * the metadata is committed to the journal.  This prevents\n\t\t * uninitialized data from appearing in a file after the\n\t\t * journal has been replayed.  (The uninitialized data\n\t\t * could be sensitive data removed by another user.)\n\t\t *\n\t\t * The problem now is that we are holding the IWRITELOCK\n\t\t * on the inode, and calling filemap_fdatawrite on an\n\t\t * unmapped page will cause a deadlock in jfs_get_block.\n\t\t *\n\t\t * The long term solution is to pare down the use of\n\t\t * IWRITELOCK.  We are currently holding it too long.\n\t\t * We could also be smarter about which data pages need\n\t\t * to be written before the transaction is committed and\n\t\t * when we don't need to worry about it at all.\n\t\t *\n\t\t * if ((!S_ISDIR(ip->i_mode))\n\t\t *    && (tblk->flag & COMMIT_DELETE) == 0)\n\t\t *\tfilemap_write_and_wait(ip->i_mapping);\n\t\t */\n\n\t\t/*\n\t\t * Mark inode as not dirty.  It will still be on the dirty\n\t\t * inode list, but we'll know not to commit it again unless\n\t\t * it gets marked dirty again\n\t\t */\n\t\tclear_cflag(COMMIT_Dirty, ip);\n\n\t\t/* inherit anonymous tlock(s) of inode */\n\t\tif (jfs_ip->atlhead) {\n\t\t\tlid_to_tlock(jfs_ip->atltail)->next = tblk->next;\n\t\t\ttblk->next = jfs_ip->atlhead;\n\t\t\tif (!tblk->last)\n\t\t\t\ttblk->last = jfs_ip->atltail;\n\t\t\tjfs_ip->atlhead = jfs_ip->atltail = 0;\n\t\t\tTXN_LOCK();\n\t\t\tlist_del_init(&jfs_ip->anon_inode_list);\n\t\t\tTXN_UNLOCK();\n\t\t}\n\n\t\t/*\n\t\t * acquire transaction lock on on-disk inode page\n\t\t * (become first tlock of the tblk's tlock list)\n\t\t */\n\t\tif (((rc = diWrite(tid, ip))))\n\t\t\tgoto out;\n\t}\n\n\t/*\n\t *\twrite log records from transaction locks\n\t *\n\t * txUpdateMap() resets XAD_NEW in XAD.\n\t */\n\tif ((rc = txLog(log, tblk, &cd)))\n\t\tgoto TheEnd;\n\n\t/*\n\t * Ensure that inode isn't reused before\n\t * lazy commit thread finishes processing\n\t */\n\tif (tblk->xflag & COMMIT_DELETE) {\n\t\tihold(tblk->u.ip);\n\t\t/*\n\t\t * Avoid a rare deadlock\n\t\t *\n\t\t * If the inode is locked, we may be blocked in\n\t\t * jfs_commit_inode.  If so, we don't want the\n\t\t * lazy_commit thread doing the last iput() on the inode\n\t\t * since that may block on the locked inode.  Instead,\n\t\t * commit the transaction synchronously, so the last iput\n\t\t * will be done by the calling thread (or later)\n\t\t */\n\t\t/*\n\t\t * I believe this code is no longer needed.  Splitting I_LOCK\n\t\t * into two bits, I_NEW and I_SYNC should prevent this\n\t\t * deadlock as well.  But since I don't have a JFS testload\n\t\t * to verify this, only a trivial s/I_LOCK/I_SYNC/ was done.\n\t\t * Joern\n\t\t */\n\t\tif (tblk->u.ip->i_state & I_SYNC)\n\t\t\ttblk->xflag &= ~COMMIT_LAZY;\n\t}\n\n\tASSERT((!(tblk->xflag & COMMIT_DELETE)) ||\n\t       ((tblk->u.ip->i_nlink == 0) &&\n\t\t!test_cflag(COMMIT_Nolink, tblk->u.ip)));\n\n\t/*\n\t *\twrite COMMIT log record\n\t */\n\tlrd->type = cpu_to_le16(LOG_COMMIT);\n\tlrd->length = 0;\n\tlmLog(log, tblk, lrd, NULL);\n\n\tlmGroupCommit(log, tblk);\n\n\t/*\n\t *\t- transaction is now committed -\n\t */\n\n\t/*\n\t * force pages in careful update\n\t * (imap addressing structure update)\n\t */\n\tif (flag & COMMIT_FORCE)\n\t\ttxForce(tblk);\n\n\t/*\n\t *\tupdate allocation map.\n\t *\n\t * update inode allocation map and inode:\n\t * free pager lock on memory object of inode if any.\n\t * update block allocation map.\n\t *\n\t * txUpdateMap() resets XAD_NEW in XAD.\n\t */\n\tif (tblk->xflag & COMMIT_FORCE)\n\t\ttxUpdateMap(tblk);\n\n\t/*\n\t *\tfree transaction locks and pageout/free pages\n\t */\n\ttxRelease(tblk);\n\n\tif ((tblk->flag & tblkGC_LAZY) == 0)\n\t\ttxUnlock(tblk);\n\n\n\t/*\n\t *\treset in-memory object state\n\t */\n\tfor (k = 0; k < cd.nip; k++) {\n\t\tip = cd.iplist[k];\n\t\tjfs_ip = JFS_IP(ip);\n\n\t\t/*\n\t\t * reset in-memory inode state\n\t\t */\n\t\tjfs_ip->bxflag = 0;\n\t\tjfs_ip->blid = 0;\n\t}\n\n      out:\n\tif (rc != 0)\n\t\ttxAbort(tid, 1);\n\n      TheEnd:\n\tjfs_info(\"txCommit: tid = %d, returning %d\", tid, rc);\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "flush_metapage",
          "args": [
            "mp"
          ],
          "line": 2596
        },
        "resolved": true,
        "details": {
          "function_name": "flush_metapage",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_metapage.h",
          "lines": "91-95",
          "snippet": "static inline void flush_metapage(struct metapage *mp)\n{\n\tset_bit(META_sync, &mp->flag);\n\twrite_metapage(mp);\n}",
          "includes": [
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [
            "#define META_sync\t3"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/pagemap.h>\n\n#define META_sync\t3\n\nstatic inline void flush_metapage(struct metapage *mp)\n{\n\tset_bit(META_sync, &mp->flag);\n\twrite_metapage(mp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "ONES"
          ],
          "line": 2591
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "EXTSPERIAG"
          ],
          "line": 2585
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "-1"
          ],
          "line": 2583
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "-1"
          ],
          "line": 2582
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "-1"
          ],
          "line": 2581
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "iagno"
          ],
          "line": 2580
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "iagp",
            "0",
            "sizeof(struct iag)"
          ],
          "line": 2579
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IWRITE_UNLOCK",
          "args": [
            "ipimap"
          ],
          "line": 2571
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&JFS_IP(ipimap)->commit_mutex"
          ],
          "line": 2568
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "txAbort",
          "args": [
            "tid",
            "0"
          ],
          "line": 2566
        },
        "resolved": true,
        "details": {
          "function_name": "txAbort",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_txnmgr.c",
          "lines": "2642-2689",
          "snippet": "void txAbort(tid_t tid, int dirty)\n{\n\tlid_t lid, next;\n\tstruct metapage *mp;\n\tstruct tblock *tblk = tid_to_tblock(tid);\n\tstruct tlock *tlck;\n\n\t/*\n\t * free tlocks of the transaction\n\t */\n\tfor (lid = tblk->next; lid; lid = next) {\n\t\ttlck = lid_to_tlock(lid);\n\t\tnext = tlck->next;\n\t\tmp = tlck->mp;\n\t\tJFS_IP(tlck->ip)->xtlid = 0;\n\n\t\tif (mp) {\n\t\t\tmp->lid = 0;\n\n\t\t\t/*\n\t\t\t * reset lsn of page to avoid logwarap:\n\t\t\t *\n\t\t\t * (page may have been previously committed by another\n\t\t\t * transaction(s) but has not been paged, i.e.,\n\t\t\t * it may be on logsync list even though it has not\n\t\t\t * been logged for the current tx.)\n\t\t\t */\n\t\t\tif (mp->xflag & COMMIT_PAGE && mp->lsn)\n\t\t\t\tLogSyncRelease(mp);\n\t\t}\n\t\t/* insert tlock at head of freelist */\n\t\tTXN_LOCK();\n\t\ttxLockFree(lid);\n\t\tTXN_UNLOCK();\n\t}\n\n\t/* caller will free the transaction block */\n\n\ttblk->next = tblk->last = 0;\n\n\t/*\n\t * mark filesystem dirty\n\t */\n\tif (dirty)\n\t\tjfs_error(tblk->sb, \"\\n\");\n\n\treturn;\n}",
          "includes": [
            "#include \"jfs_debug.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_dmap.h\"",
            "#include \"jfs_imap.h\"",
            "#include \"jfs_dinode.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_filsys.h\"",
            "#include \"jfs_inode.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/freezer.h>",
            "#include <linux/completion.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int dataLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t\tstruct tlock * tlck);",
            "static void dtLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t\tstruct tlock * tlck);",
            "static void mapLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t\tstruct tlock * tlck);",
            "static void txAllocPMap(struct inode *ip, struct maplock * maplock,\n\t\tstruct tblock * tblk);",
            "static void txForce(struct tblock * tblk);",
            "static void txUpdateMap(struct tblock * tblk);",
            "static void txRelease(struct tblock * tblk);",
            "static void xtLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t   struct tlock * tlck);",
            "static void LogSyncRelease(struct metapage * mp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_imap.h\"\n#include \"jfs_dinode.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_inode.h\"\n#include \"jfs_incore.h\"\n#include <linux/seq_file.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/freezer.h>\n#include <linux/completion.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n\nstatic int dataLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t\tstruct tlock * tlck);\nstatic void dtLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t\tstruct tlock * tlck);\nstatic void mapLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t\tstruct tlock * tlck);\nstatic void txAllocPMap(struct inode *ip, struct maplock * maplock,\n\t\tstruct tblock * tblk);\nstatic void txForce(struct tblock * tblk);\nstatic void txUpdateMap(struct tblock * tblk);\nstatic void txRelease(struct tblock * tblk);\nstatic void xtLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t   struct tlock * tlck);\nstatic void LogSyncRelease(struct metapage * mp);\n\nvoid txAbort(tid_t tid, int dirty)\n{\n\tlid_t lid, next;\n\tstruct metapage *mp;\n\tstruct tblock *tblk = tid_to_tblock(tid);\n\tstruct tlock *tlck;\n\n\t/*\n\t * free tlocks of the transaction\n\t */\n\tfor (lid = tblk->next; lid; lid = next) {\n\t\ttlck = lid_to_tlock(lid);\n\t\tnext = tlck->next;\n\t\tmp = tlck->mp;\n\t\tJFS_IP(tlck->ip)->xtlid = 0;\n\n\t\tif (mp) {\n\t\t\tmp->lid = 0;\n\n\t\t\t/*\n\t\t\t * reset lsn of page to avoid logwarap:\n\t\t\t *\n\t\t\t * (page may have been previously committed by another\n\t\t\t * transaction(s) but has not been paged, i.e.,\n\t\t\t * it may be on logsync list even though it has not\n\t\t\t * been logged for the current tx.)\n\t\t\t */\n\t\t\tif (mp->xflag & COMMIT_PAGE && mp->lsn)\n\t\t\t\tLogSyncRelease(mp);\n\t\t}\n\t\t/* insert tlock at head of freelist */\n\t\tTXN_LOCK();\n\t\ttxLockFree(lid);\n\t\tTXN_UNLOCK();\n\t}\n\n\t/* caller will free the transaction block */\n\n\ttblk->next = tblk->last = 0;\n\n\t/*\n\t * mark filesystem dirty\n\t */\n\tif (dirty)\n\t\tjfs_error(tblk->sb, \"\\n\");\n\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xtTruncate",
          "args": [
            "tid",
            "ipimap",
            "ipimap->i_size - PSIZE",
            "COMMIT_PWMAP"
          ],
          "line": 2563
        },
        "resolved": true,
        "details": {
          "function_name": "xtTruncate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_xtree.c",
          "lines": "3162-3692",
          "snippet": "s64 xtTruncate(tid_t tid, struct inode *ip, s64 newsize, int flag)\n{\n\tint rc = 0;\n\ts64 teof;\n\tstruct metapage *mp;\n\txtpage_t *p;\n\ts64 bn;\n\tint index, nextindex;\n\txad_t *xad;\n\ts64 xoff, xaddr;\n\tint xlen, len, freexlen;\n\tstruct btstack btstack;\n\tstruct btframe *parent;\n\tstruct tblock *tblk = NULL;\n\tstruct tlock *tlck = NULL;\n\tstruct xtlock *xtlck = NULL;\n\tstruct xdlistlock xadlock;\t/* maplock for COMMIT_WMAP */\n\tstruct pxd_lock *pxdlock;\t\t/* maplock for COMMIT_WMAP */\n\ts64 nfreed;\n\tint freed, log;\n\tint locked_leaves = 0;\n\n\t/* save object truncation type */\n\tif (tid) {\n\t\ttblk = tid_to_tblock(tid);\n\t\ttblk->xflag |= flag;\n\t}\n\n\tnfreed = 0;\n\n\tflag &= COMMIT_MAP;\n\tassert(flag != COMMIT_PMAP);\n\n\tif (flag == COMMIT_PWMAP)\n\t\tlog = 1;\n\telse {\n\t\tlog = 0;\n\t\txadlock.flag = mlckFREEXADLIST;\n\t\txadlock.index = 1;\n\t}\n\n\t/*\n\t * if the newsize is not an integral number of pages,\n\t * the file between newsize and next page boundary will\n\t * be cleared.\n\t * if truncating into a file hole, it will cause\n\t * a full block to be allocated for the logical block.\n\t */\n\n\t/*\n\t * release page blocks of truncated region <teof, eof>\n\t *\n\t * free the data blocks from the leaf index blocks.\n\t * delete the parent index entries corresponding to\n\t * the freed child data/index blocks.\n\t * free the index blocks themselves which aren't needed\n\t * in new sized file.\n\t *\n\t * index blocks are updated only if the blocks are to be\n\t * retained in the new sized file.\n\t * if type is PMAP, the data and index pages are NOT\n\t * freed, and the data and index blocks are NOT freed\n\t * from working map.\n\t * (this will allow continued access of data/index of\n\t * temporary file (zerolink count file truncated to zero-length)).\n\t */\n\tteof = (newsize + (JFS_SBI(ip->i_sb)->bsize - 1)) >>\n\t    JFS_SBI(ip->i_sb)->l2bsize;\n\n\t/* clear stack */\n\tBT_CLR(&btstack);\n\n\t/*\n\t * start with root\n\t *\n\t * root resides in the inode\n\t */\n\tbn = 0;\n\n\t/*\n\t * first access of each page:\n\t */\n      getPage:\n\tXT_GETPAGE(ip, bn, mp, PSIZE, p, rc);\n\tif (rc)\n\t\treturn rc;\n\n\t/* process entries backward from last index */\n\tindex = le16_to_cpu(p->header.nextindex) - 1;\n\n\n\t/* Since this is the rightmost page at this level, and we may have\n\t * already freed a page that was formerly to the right, let's make\n\t * sure that the next pointer is zero.\n\t */\n\tif (p->header.next) {\n\t\tif (log)\n\t\t\t/*\n\t\t\t * Make sure this change to the header is logged.\n\t\t\t * If we really truncate this leaf, the flag\n\t\t\t * will be changed to tlckTRUNCATE\n\t\t\t */\n\t\t\ttlck = txLock(tid, ip, mp, tlckXTREE|tlckGROW);\n\t\tBT_MARK_DIRTY(mp, ip);\n\t\tp->header.next = 0;\n\t}\n\n\tif (p->header.flag & BT_INTERNAL)\n\t\tgoto getChild;\n\n\t/*\n\t *\tleaf page\n\t */\n\tfreed = 0;\n\n\t/* does region covered by leaf page precede Teof ? */\n\txad = &p->xad[index];\n\txoff = offsetXAD(xad);\n\txlen = lengthXAD(xad);\n\tif (teof >= xoff + xlen) {\n\t\tXT_PUTPAGE(mp);\n\t\tgoto getParent;\n\t}\n\n\t/* (re)acquire tlock of the leaf page */\n\tif (log) {\n\t\tif (++locked_leaves > MAX_TRUNCATE_LEAVES) {\n\t\t\t/*\n\t\t\t * We need to limit the size of the transaction\n\t\t\t * to avoid exhausting pagecache & tlocks\n\t\t\t */\n\t\t\tXT_PUTPAGE(mp);\n\t\t\tnewsize = (xoff + xlen) << JFS_SBI(ip->i_sb)->l2bsize;\n\t\t\tgoto getParent;\n\t\t}\n\t\ttlck = txLock(tid, ip, mp, tlckXTREE);\n\t\ttlck->type = tlckXTREE | tlckTRUNCATE;\n\t\txtlck = (struct xtlock *) & tlck->lock;\n\t\txtlck->hwm.offset = le16_to_cpu(p->header.nextindex) - 1;\n\t}\n\tBT_MARK_DIRTY(mp, ip);\n\n\t/*\n\t * scan backward leaf page entries\n\t */\n\tfor (; index >= XTENTRYSTART; index--) {\n\t\txad = &p->xad[index];\n\t\txoff = offsetXAD(xad);\n\t\txlen = lengthXAD(xad);\n\t\txaddr = addressXAD(xad);\n\n\t\t/*\n\t\t * The \"data\" for a directory is indexed by the block\n\t\t * device's address space.  This metadata must be invalidated\n\t\t * here\n\t\t */\n\t\tif (S_ISDIR(ip->i_mode) && (teof == 0))\n\t\t\tinvalidate_xad_metapages(ip, *xad);\n\t\t/*\n\t\t * entry beyond eof: continue scan of current page\n\t\t *          xad\n\t\t * ---|---=======------->\n\t\t *   eof\n\t\t */\n\t\tif (teof < xoff) {\n\t\t\tnfreed += xlen;\n\t\t\tcontinue;\n\t\t}\n\n\t\t/*\n\t\t * (xoff <= teof): last entry to be deleted from page;\n\t\t * If other entries remain in page: keep and update the page.\n\t\t */\n\n\t\t/*\n\t\t * eof == entry_start: delete the entry\n\t\t *           xad\n\t\t * -------|=======------->\n\t\t *       eof\n\t\t *\n\t\t */\n\t\tif (teof == xoff) {\n\t\t\tnfreed += xlen;\n\n\t\t\tif (index == XTENTRYSTART)\n\t\t\t\tbreak;\n\n\t\t\tnextindex = index;\n\t\t}\n\t\t/*\n\t\t * eof within the entry: truncate the entry.\n\t\t *          xad\n\t\t * -------===|===------->\n\t\t *          eof\n\t\t */\n\t\telse if (teof < xoff + xlen) {\n\t\t\t/* update truncated entry */\n\t\t\tlen = teof - xoff;\n\t\t\tfreexlen = xlen - len;\n\t\t\tXADlength(xad, len);\n\n\t\t\t/* save pxd of truncated extent in tlck */\n\t\t\txaddr += len;\n\t\t\tif (log) {\t/* COMMIT_PWMAP */\n\t\t\t\txtlck->lwm.offset = (xtlck->lwm.offset) ?\n\t\t\t\t    min(index, (int)xtlck->lwm.offset) : index;\n\t\t\t\txtlck->lwm.length = index + 1 -\n\t\t\t\t    xtlck->lwm.offset;\n\t\t\t\txtlck->twm.offset = index;\n\t\t\t\tpxdlock = (struct pxd_lock *) & xtlck->pxdlock;\n\t\t\t\tpxdlock->flag = mlckFREEPXD;\n\t\t\t\tPXDaddress(&pxdlock->pxd, xaddr);\n\t\t\t\tPXDlength(&pxdlock->pxd, freexlen);\n\t\t\t}\n\t\t\t/* free truncated extent */\n\t\t\telse {\t/* COMMIT_WMAP */\n\n\t\t\t\tpxdlock = (struct pxd_lock *) & xadlock;\n\t\t\t\tpxdlock->flag = mlckFREEPXD;\n\t\t\t\tPXDaddress(&pxdlock->pxd, xaddr);\n\t\t\t\tPXDlength(&pxdlock->pxd, freexlen);\n\t\t\t\ttxFreeMap(ip, pxdlock, NULL, COMMIT_WMAP);\n\n\t\t\t\t/* reset map lock */\n\t\t\t\txadlock.flag = mlckFREEXADLIST;\n\t\t\t}\n\n\t\t\t/* current entry is new last entry; */\n\t\t\tnextindex = index + 1;\n\n\t\t\tnfreed += freexlen;\n\t\t}\n\t\t/*\n\t\t * eof beyond the entry:\n\t\t *          xad\n\t\t * -------=======---|--->\n\t\t *                 eof\n\t\t */\n\t\telse {\t\t/* (xoff + xlen < teof) */\n\n\t\t\tnextindex = index + 1;\n\t\t}\n\n\t\tif (nextindex < le16_to_cpu(p->header.nextindex)) {\n\t\t\tif (!log) {\t/* COMMIT_WAMP */\n\t\t\t\txadlock.xdlist = &p->xad[nextindex];\n\t\t\t\txadlock.count =\n\t\t\t\t    le16_to_cpu(p->header.nextindex) -\n\t\t\t\t    nextindex;\n\t\t\t\ttxFreeMap(ip, (struct maplock *) & xadlock,\n\t\t\t\t\t  NULL, COMMIT_WMAP);\n\t\t\t}\n\t\t\tp->header.nextindex = cpu_to_le16(nextindex);\n\t\t}\n\n\t\tXT_PUTPAGE(mp);\n\n\t\t/* assert(freed == 0); */\n\t\tgoto getParent;\n\t}\t\t\t/* end scan of leaf page entries */\n\n\tfreed = 1;\n\n\t/*\n\t * leaf page become empty: free the page if type != PMAP\n\t */\n\tif (log) {\t\t/* COMMIT_PWMAP */\n\t\t/* txCommit() with tlckFREE:\n\t\t * free data extents covered by leaf [XTENTRYSTART:hwm);\n\t\t * invalidate leaf if COMMIT_PWMAP;\n\t\t * if (TRUNCATE), will write LOG_NOREDOPAGE;\n\t\t */\n\t\ttlck->type = tlckXTREE | tlckFREE;\n\t} else {\t\t/* COMMIT_WAMP */\n\n\t\t/* free data extents covered by leaf */\n\t\txadlock.xdlist = &p->xad[XTENTRYSTART];\n\t\txadlock.count =\n\t\t    le16_to_cpu(p->header.nextindex) - XTENTRYSTART;\n\t\ttxFreeMap(ip, (struct maplock *) & xadlock, NULL, COMMIT_WMAP);\n\t}\n\n\tif (p->header.flag & BT_ROOT) {\n\t\tp->header.flag &= ~BT_INTERNAL;\n\t\tp->header.flag |= BT_LEAF;\n\t\tp->header.nextindex = cpu_to_le16(XTENTRYSTART);\n\n\t\tXT_PUTPAGE(mp);\t/* debug */\n\t\tgoto out;\n\t} else {\n\t\tif (log) {\t/* COMMIT_PWMAP */\n\t\t\t/* page will be invalidated at tx completion\n\t\t\t */\n\t\t\tXT_PUTPAGE(mp);\n\t\t} else {\t/* COMMIT_WMAP */\n\n\t\t\tif (mp->lid)\n\t\t\t\tlid_to_tlock(mp->lid)->flag |= tlckFREELOCK;\n\n\t\t\t/* invalidate empty leaf page */\n\t\t\tdiscard_metapage(mp);\n\t\t}\n\t}\n\n\t/*\n\t * the leaf page become empty: delete the parent entry\n\t * for the leaf page if the parent page is to be kept\n\t * in the new sized file.\n\t */\n\n\t/*\n\t * go back up to the parent page\n\t */\n      getParent:\n\t/* pop/restore parent entry for the current child page */\n\tif ((parent = BT_POP(&btstack)) == NULL)\n\t\t/* current page must have been root */\n\t\tgoto out;\n\n\t/* get back the parent page */\n\tbn = parent->bn;\n\tXT_GETPAGE(ip, bn, mp, PSIZE, p, rc);\n\tif (rc)\n\t\treturn rc;\n\n\tindex = parent->index;\n\n\t/*\n\t * child page was not empty:\n\t */\n\tif (freed == 0) {\n\t\t/* has any entry deleted from parent ? */\n\t\tif (index < le16_to_cpu(p->header.nextindex) - 1) {\n\t\t\t/* (re)acquire tlock on the parent page */\n\t\t\tif (log) {\t/* COMMIT_PWMAP */\n\t\t\t\t/* txCommit() with tlckTRUNCATE:\n\t\t\t\t * free child extents covered by parent [);\n\t\t\t\t */\n\t\t\t\ttlck = txLock(tid, ip, mp, tlckXTREE);\n\t\t\t\txtlck = (struct xtlock *) & tlck->lock;\n\t\t\t\tif (!(tlck->type & tlckTRUNCATE)) {\n\t\t\t\t\txtlck->hwm.offset =\n\t\t\t\t\t    le16_to_cpu(p->header.\n\t\t\t\t\t\t\tnextindex) - 1;\n\t\t\t\t\ttlck->type =\n\t\t\t\t\t    tlckXTREE | tlckTRUNCATE;\n\t\t\t\t}\n\t\t\t} else {\t/* COMMIT_WMAP */\n\n\t\t\t\t/* free child extents covered by parent */\n\t\t\t\txadlock.xdlist = &p->xad[index + 1];\n\t\t\t\txadlock.count =\n\t\t\t\t    le16_to_cpu(p->header.nextindex) -\n\t\t\t\t    index - 1;\n\t\t\t\ttxFreeMap(ip, (struct maplock *) & xadlock,\n\t\t\t\t\t  NULL, COMMIT_WMAP);\n\t\t\t}\n\t\t\tBT_MARK_DIRTY(mp, ip);\n\n\t\t\tp->header.nextindex = cpu_to_le16(index + 1);\n\t\t}\n\t\tXT_PUTPAGE(mp);\n\t\tgoto getParent;\n\t}\n\n\t/*\n\t * child page was empty:\n\t */\n\tnfreed += lengthXAD(&p->xad[index]);\n\n\t/*\n\t * During working map update, child page's tlock must be handled\n\t * before parent's.  This is because the parent's tlock will cause\n\t * the child's disk space to be marked available in the wmap, so\n\t * it's important that the child page be released by that time.\n\t *\n\t * ToDo:  tlocks should be on doubly-linked list, so we can\n\t * quickly remove it and add it to the end.\n\t */\n\n\t/*\n\t * Move parent page's tlock to the end of the tid's tlock list\n\t */\n\tif (log && mp->lid && (tblk->last != mp->lid) &&\n\t    lid_to_tlock(mp->lid)->tid) {\n\t\tlid_t lid = mp->lid;\n\t\tstruct tlock *prev;\n\n\t\ttlck = lid_to_tlock(lid);\n\n\t\tif (tblk->next == lid)\n\t\t\ttblk->next = tlck->next;\n\t\telse {\n\t\t\tfor (prev = lid_to_tlock(tblk->next);\n\t\t\t     prev->next != lid;\n\t\t\t     prev = lid_to_tlock(prev->next)) {\n\t\t\t\tassert(prev->next);\n\t\t\t}\n\t\t\tprev->next = tlck->next;\n\t\t}\n\t\tlid_to_tlock(tblk->last)->next = lid;\n\t\ttlck->next = 0;\n\t\ttblk->last = lid;\n\t}\n\n\t/*\n\t * parent page become empty: free the page\n\t */\n\tif (index == XTENTRYSTART) {\n\t\tif (log) {\t/* COMMIT_PWMAP */\n\t\t\t/* txCommit() with tlckFREE:\n\t\t\t * free child extents covered by parent;\n\t\t\t * invalidate parent if COMMIT_PWMAP;\n\t\t\t */\n\t\t\ttlck = txLock(tid, ip, mp, tlckXTREE);\n\t\t\txtlck = (struct xtlock *) & tlck->lock;\n\t\t\txtlck->hwm.offset =\n\t\t\t    le16_to_cpu(p->header.nextindex) - 1;\n\t\t\ttlck->type = tlckXTREE | tlckFREE;\n\t\t} else {\t/* COMMIT_WMAP */\n\n\t\t\t/* free child extents covered by parent */\n\t\t\txadlock.xdlist = &p->xad[XTENTRYSTART];\n\t\t\txadlock.count =\n\t\t\t    le16_to_cpu(p->header.nextindex) -\n\t\t\t    XTENTRYSTART;\n\t\t\ttxFreeMap(ip, (struct maplock *) & xadlock, NULL,\n\t\t\t\t  COMMIT_WMAP);\n\t\t}\n\t\tBT_MARK_DIRTY(mp, ip);\n\n\t\tif (p->header.flag & BT_ROOT) {\n\t\t\tp->header.flag &= ~BT_INTERNAL;\n\t\t\tp->header.flag |= BT_LEAF;\n\t\t\tp->header.nextindex = cpu_to_le16(XTENTRYSTART);\n\t\t\tif (le16_to_cpu(p->header.maxentry) == XTROOTMAXSLOT) {\n\t\t\t\t/*\n\t\t\t\t * Shrink root down to allow inline\n\t\t\t\t * EA (otherwise fsck complains)\n\t\t\t\t */\n\t\t\t\tp->header.maxentry =\n\t\t\t\t    cpu_to_le16(XTROOTINITSLOT);\n\t\t\t\tJFS_IP(ip)->mode2 |= INLINEEA;\n\t\t\t}\n\n\t\t\tXT_PUTPAGE(mp);\t/* debug */\n\t\t\tgoto out;\n\t\t} else {\n\t\t\tif (log) {\t/* COMMIT_PWMAP */\n\t\t\t\t/* page will be invalidated at tx completion\n\t\t\t\t */\n\t\t\t\tXT_PUTPAGE(mp);\n\t\t\t} else {\t/* COMMIT_WMAP */\n\n\t\t\t\tif (mp->lid)\n\t\t\t\t\tlid_to_tlock(mp->lid)->flag |=\n\t\t\t\t\t\ttlckFREELOCK;\n\n\t\t\t\t/* invalidate parent page */\n\t\t\t\tdiscard_metapage(mp);\n\t\t\t}\n\n\t\t\t/* parent has become empty and freed:\n\t\t\t * go back up to its parent page\n\t\t\t */\n\t\t\t/* freed = 1; */\n\t\t\tgoto getParent;\n\t\t}\n\t}\n\t/*\n\t * parent page still has entries for front region;\n\t */\n\telse {\n\t\t/* try truncate region covered by preceding entry\n\t\t * (process backward)\n\t\t */\n\t\tindex--;\n\n\t\t/* go back down to the child page corresponding\n\t\t * to the entry\n\t\t */\n\t\tgoto getChild;\n\t}\n\n\t/*\n\t *\tinternal page: go down to child page of current entry\n\t */\n      getChild:\n\t/* save current parent entry for the child page */\n\tif (BT_STACK_FULL(&btstack)) {\n\t\tjfs_error(ip->i_sb, \"stack overrun!\\n\");\n\t\tXT_PUTPAGE(mp);\n\t\treturn -EIO;\n\t}\n\tBT_PUSH(&btstack, bn, index);\n\n\t/* get child page */\n\txad = &p->xad[index];\n\tbn = addressXAD(xad);\n\n\t/*\n\t * first access of each internal entry:\n\t */\n\t/* release parent page */\n\tXT_PUTPAGE(mp);\n\n\t/* process the child page */\n\tgoto getPage;\n\n      out:\n\t/*\n\t * update file resource stat\n\t */\n\t/* set size\n\t */\n\tif (S_ISDIR(ip->i_mode) && !newsize)\n\t\tip->i_size = 1;\t/* fsck hates zero-length directories */\n\telse\n\t\tip->i_size = newsize;\n\n\t/* update quota allocation to reflect freed blocks */\n\tdquot_free_block(ip, nfreed);\n\n\t/*\n\t * free tlock of invalidated pages\n\t */\n\tif (flag == COMMIT_WMAP)\n\t\ttxFreelock(ip);\n\n\treturn newsize;\n}",
          "includes": [
            "#include \"jfs_debug.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_dinode.h\"",
            "#include \"jfs_dmap.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_filsys.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/module.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [
            "#define MAX_TRUNCATE_LEAVES 50"
          ],
          "globals_used": [
            "static int xtSearch(struct inode *ip, s64 xoff, s64 *next, int *cmpp,\n\t\t    struct btstack * btstack, int flag);",
            "static int xtSplitUp(tid_t tid,\n\t\t     struct inode *ip,\n\t\t     struct xtsplit * split, struct btstack * btstack);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_dinode.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_incore.h\"\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/module.h>\n#include <linux/fs.h>\n\n#define MAX_TRUNCATE_LEAVES 50\n\nstatic int xtSearch(struct inode *ip, s64 xoff, s64 *next, int *cmpp,\n\t\t    struct btstack * btstack, int flag);\nstatic int xtSplitUp(tid_t tid,\n\t\t     struct inode *ip,\n\t\t     struct xtsplit * split, struct btstack * btstack);\n\ns64 xtTruncate(tid_t tid, struct inode *ip, s64 newsize, int flag)\n{\n\tint rc = 0;\n\ts64 teof;\n\tstruct metapage *mp;\n\txtpage_t *p;\n\ts64 bn;\n\tint index, nextindex;\n\txad_t *xad;\n\ts64 xoff, xaddr;\n\tint xlen, len, freexlen;\n\tstruct btstack btstack;\n\tstruct btframe *parent;\n\tstruct tblock *tblk = NULL;\n\tstruct tlock *tlck = NULL;\n\tstruct xtlock *xtlck = NULL;\n\tstruct xdlistlock xadlock;\t/* maplock for COMMIT_WMAP */\n\tstruct pxd_lock *pxdlock;\t\t/* maplock for COMMIT_WMAP */\n\ts64 nfreed;\n\tint freed, log;\n\tint locked_leaves = 0;\n\n\t/* save object truncation type */\n\tif (tid) {\n\t\ttblk = tid_to_tblock(tid);\n\t\ttblk->xflag |= flag;\n\t}\n\n\tnfreed = 0;\n\n\tflag &= COMMIT_MAP;\n\tassert(flag != COMMIT_PMAP);\n\n\tif (flag == COMMIT_PWMAP)\n\t\tlog = 1;\n\telse {\n\t\tlog = 0;\n\t\txadlock.flag = mlckFREEXADLIST;\n\t\txadlock.index = 1;\n\t}\n\n\t/*\n\t * if the newsize is not an integral number of pages,\n\t * the file between newsize and next page boundary will\n\t * be cleared.\n\t * if truncating into a file hole, it will cause\n\t * a full block to be allocated for the logical block.\n\t */\n\n\t/*\n\t * release page blocks of truncated region <teof, eof>\n\t *\n\t * free the data blocks from the leaf index blocks.\n\t * delete the parent index entries corresponding to\n\t * the freed child data/index blocks.\n\t * free the index blocks themselves which aren't needed\n\t * in new sized file.\n\t *\n\t * index blocks are updated only if the blocks are to be\n\t * retained in the new sized file.\n\t * if type is PMAP, the data and index pages are NOT\n\t * freed, and the data and index blocks are NOT freed\n\t * from working map.\n\t * (this will allow continued access of data/index of\n\t * temporary file (zerolink count file truncated to zero-length)).\n\t */\n\tteof = (newsize + (JFS_SBI(ip->i_sb)->bsize - 1)) >>\n\t    JFS_SBI(ip->i_sb)->l2bsize;\n\n\t/* clear stack */\n\tBT_CLR(&btstack);\n\n\t/*\n\t * start with root\n\t *\n\t * root resides in the inode\n\t */\n\tbn = 0;\n\n\t/*\n\t * first access of each page:\n\t */\n      getPage:\n\tXT_GETPAGE(ip, bn, mp, PSIZE, p, rc);\n\tif (rc)\n\t\treturn rc;\n\n\t/* process entries backward from last index */\n\tindex = le16_to_cpu(p->header.nextindex) - 1;\n\n\n\t/* Since this is the rightmost page at this level, and we may have\n\t * already freed a page that was formerly to the right, let's make\n\t * sure that the next pointer is zero.\n\t */\n\tif (p->header.next) {\n\t\tif (log)\n\t\t\t/*\n\t\t\t * Make sure this change to the header is logged.\n\t\t\t * If we really truncate this leaf, the flag\n\t\t\t * will be changed to tlckTRUNCATE\n\t\t\t */\n\t\t\ttlck = txLock(tid, ip, mp, tlckXTREE|tlckGROW);\n\t\tBT_MARK_DIRTY(mp, ip);\n\t\tp->header.next = 0;\n\t}\n\n\tif (p->header.flag & BT_INTERNAL)\n\t\tgoto getChild;\n\n\t/*\n\t *\tleaf page\n\t */\n\tfreed = 0;\n\n\t/* does region covered by leaf page precede Teof ? */\n\txad = &p->xad[index];\n\txoff = offsetXAD(xad);\n\txlen = lengthXAD(xad);\n\tif (teof >= xoff + xlen) {\n\t\tXT_PUTPAGE(mp);\n\t\tgoto getParent;\n\t}\n\n\t/* (re)acquire tlock of the leaf page */\n\tif (log) {\n\t\tif (++locked_leaves > MAX_TRUNCATE_LEAVES) {\n\t\t\t/*\n\t\t\t * We need to limit the size of the transaction\n\t\t\t * to avoid exhausting pagecache & tlocks\n\t\t\t */\n\t\t\tXT_PUTPAGE(mp);\n\t\t\tnewsize = (xoff + xlen) << JFS_SBI(ip->i_sb)->l2bsize;\n\t\t\tgoto getParent;\n\t\t}\n\t\ttlck = txLock(tid, ip, mp, tlckXTREE);\n\t\ttlck->type = tlckXTREE | tlckTRUNCATE;\n\t\txtlck = (struct xtlock *) & tlck->lock;\n\t\txtlck->hwm.offset = le16_to_cpu(p->header.nextindex) - 1;\n\t}\n\tBT_MARK_DIRTY(mp, ip);\n\n\t/*\n\t * scan backward leaf page entries\n\t */\n\tfor (; index >= XTENTRYSTART; index--) {\n\t\txad = &p->xad[index];\n\t\txoff = offsetXAD(xad);\n\t\txlen = lengthXAD(xad);\n\t\txaddr = addressXAD(xad);\n\n\t\t/*\n\t\t * The \"data\" for a directory is indexed by the block\n\t\t * device's address space.  This metadata must be invalidated\n\t\t * here\n\t\t */\n\t\tif (S_ISDIR(ip->i_mode) && (teof == 0))\n\t\t\tinvalidate_xad_metapages(ip, *xad);\n\t\t/*\n\t\t * entry beyond eof: continue scan of current page\n\t\t *          xad\n\t\t * ---|---=======------->\n\t\t *   eof\n\t\t */\n\t\tif (teof < xoff) {\n\t\t\tnfreed += xlen;\n\t\t\tcontinue;\n\t\t}\n\n\t\t/*\n\t\t * (xoff <= teof): last entry to be deleted from page;\n\t\t * If other entries remain in page: keep and update the page.\n\t\t */\n\n\t\t/*\n\t\t * eof == entry_start: delete the entry\n\t\t *           xad\n\t\t * -------|=======------->\n\t\t *       eof\n\t\t *\n\t\t */\n\t\tif (teof == xoff) {\n\t\t\tnfreed += xlen;\n\n\t\t\tif (index == XTENTRYSTART)\n\t\t\t\tbreak;\n\n\t\t\tnextindex = index;\n\t\t}\n\t\t/*\n\t\t * eof within the entry: truncate the entry.\n\t\t *          xad\n\t\t * -------===|===------->\n\t\t *          eof\n\t\t */\n\t\telse if (teof < xoff + xlen) {\n\t\t\t/* update truncated entry */\n\t\t\tlen = teof - xoff;\n\t\t\tfreexlen = xlen - len;\n\t\t\tXADlength(xad, len);\n\n\t\t\t/* save pxd of truncated extent in tlck */\n\t\t\txaddr += len;\n\t\t\tif (log) {\t/* COMMIT_PWMAP */\n\t\t\t\txtlck->lwm.offset = (xtlck->lwm.offset) ?\n\t\t\t\t    min(index, (int)xtlck->lwm.offset) : index;\n\t\t\t\txtlck->lwm.length = index + 1 -\n\t\t\t\t    xtlck->lwm.offset;\n\t\t\t\txtlck->twm.offset = index;\n\t\t\t\tpxdlock = (struct pxd_lock *) & xtlck->pxdlock;\n\t\t\t\tpxdlock->flag = mlckFREEPXD;\n\t\t\t\tPXDaddress(&pxdlock->pxd, xaddr);\n\t\t\t\tPXDlength(&pxdlock->pxd, freexlen);\n\t\t\t}\n\t\t\t/* free truncated extent */\n\t\t\telse {\t/* COMMIT_WMAP */\n\n\t\t\t\tpxdlock = (struct pxd_lock *) & xadlock;\n\t\t\t\tpxdlock->flag = mlckFREEPXD;\n\t\t\t\tPXDaddress(&pxdlock->pxd, xaddr);\n\t\t\t\tPXDlength(&pxdlock->pxd, freexlen);\n\t\t\t\ttxFreeMap(ip, pxdlock, NULL, COMMIT_WMAP);\n\n\t\t\t\t/* reset map lock */\n\t\t\t\txadlock.flag = mlckFREEXADLIST;\n\t\t\t}\n\n\t\t\t/* current entry is new last entry; */\n\t\t\tnextindex = index + 1;\n\n\t\t\tnfreed += freexlen;\n\t\t}\n\t\t/*\n\t\t * eof beyond the entry:\n\t\t *          xad\n\t\t * -------=======---|--->\n\t\t *                 eof\n\t\t */\n\t\telse {\t\t/* (xoff + xlen < teof) */\n\n\t\t\tnextindex = index + 1;\n\t\t}\n\n\t\tif (nextindex < le16_to_cpu(p->header.nextindex)) {\n\t\t\tif (!log) {\t/* COMMIT_WAMP */\n\t\t\t\txadlock.xdlist = &p->xad[nextindex];\n\t\t\t\txadlock.count =\n\t\t\t\t    le16_to_cpu(p->header.nextindex) -\n\t\t\t\t    nextindex;\n\t\t\t\ttxFreeMap(ip, (struct maplock *) & xadlock,\n\t\t\t\t\t  NULL, COMMIT_WMAP);\n\t\t\t}\n\t\t\tp->header.nextindex = cpu_to_le16(nextindex);\n\t\t}\n\n\t\tXT_PUTPAGE(mp);\n\n\t\t/* assert(freed == 0); */\n\t\tgoto getParent;\n\t}\t\t\t/* end scan of leaf page entries */\n\n\tfreed = 1;\n\n\t/*\n\t * leaf page become empty: free the page if type != PMAP\n\t */\n\tif (log) {\t\t/* COMMIT_PWMAP */\n\t\t/* txCommit() with tlckFREE:\n\t\t * free data extents covered by leaf [XTENTRYSTART:hwm);\n\t\t * invalidate leaf if COMMIT_PWMAP;\n\t\t * if (TRUNCATE), will write LOG_NOREDOPAGE;\n\t\t */\n\t\ttlck->type = tlckXTREE | tlckFREE;\n\t} else {\t\t/* COMMIT_WAMP */\n\n\t\t/* free data extents covered by leaf */\n\t\txadlock.xdlist = &p->xad[XTENTRYSTART];\n\t\txadlock.count =\n\t\t    le16_to_cpu(p->header.nextindex) - XTENTRYSTART;\n\t\ttxFreeMap(ip, (struct maplock *) & xadlock, NULL, COMMIT_WMAP);\n\t}\n\n\tif (p->header.flag & BT_ROOT) {\n\t\tp->header.flag &= ~BT_INTERNAL;\n\t\tp->header.flag |= BT_LEAF;\n\t\tp->header.nextindex = cpu_to_le16(XTENTRYSTART);\n\n\t\tXT_PUTPAGE(mp);\t/* debug */\n\t\tgoto out;\n\t} else {\n\t\tif (log) {\t/* COMMIT_PWMAP */\n\t\t\t/* page will be invalidated at tx completion\n\t\t\t */\n\t\t\tXT_PUTPAGE(mp);\n\t\t} else {\t/* COMMIT_WMAP */\n\n\t\t\tif (mp->lid)\n\t\t\t\tlid_to_tlock(mp->lid)->flag |= tlckFREELOCK;\n\n\t\t\t/* invalidate empty leaf page */\n\t\t\tdiscard_metapage(mp);\n\t\t}\n\t}\n\n\t/*\n\t * the leaf page become empty: delete the parent entry\n\t * for the leaf page if the parent page is to be kept\n\t * in the new sized file.\n\t */\n\n\t/*\n\t * go back up to the parent page\n\t */\n      getParent:\n\t/* pop/restore parent entry for the current child page */\n\tif ((parent = BT_POP(&btstack)) == NULL)\n\t\t/* current page must have been root */\n\t\tgoto out;\n\n\t/* get back the parent page */\n\tbn = parent->bn;\n\tXT_GETPAGE(ip, bn, mp, PSIZE, p, rc);\n\tif (rc)\n\t\treturn rc;\n\n\tindex = parent->index;\n\n\t/*\n\t * child page was not empty:\n\t */\n\tif (freed == 0) {\n\t\t/* has any entry deleted from parent ? */\n\t\tif (index < le16_to_cpu(p->header.nextindex) - 1) {\n\t\t\t/* (re)acquire tlock on the parent page */\n\t\t\tif (log) {\t/* COMMIT_PWMAP */\n\t\t\t\t/* txCommit() with tlckTRUNCATE:\n\t\t\t\t * free child extents covered by parent [);\n\t\t\t\t */\n\t\t\t\ttlck = txLock(tid, ip, mp, tlckXTREE);\n\t\t\t\txtlck = (struct xtlock *) & tlck->lock;\n\t\t\t\tif (!(tlck->type & tlckTRUNCATE)) {\n\t\t\t\t\txtlck->hwm.offset =\n\t\t\t\t\t    le16_to_cpu(p->header.\n\t\t\t\t\t\t\tnextindex) - 1;\n\t\t\t\t\ttlck->type =\n\t\t\t\t\t    tlckXTREE | tlckTRUNCATE;\n\t\t\t\t}\n\t\t\t} else {\t/* COMMIT_WMAP */\n\n\t\t\t\t/* free child extents covered by parent */\n\t\t\t\txadlock.xdlist = &p->xad[index + 1];\n\t\t\t\txadlock.count =\n\t\t\t\t    le16_to_cpu(p->header.nextindex) -\n\t\t\t\t    index - 1;\n\t\t\t\ttxFreeMap(ip, (struct maplock *) & xadlock,\n\t\t\t\t\t  NULL, COMMIT_WMAP);\n\t\t\t}\n\t\t\tBT_MARK_DIRTY(mp, ip);\n\n\t\t\tp->header.nextindex = cpu_to_le16(index + 1);\n\t\t}\n\t\tXT_PUTPAGE(mp);\n\t\tgoto getParent;\n\t}\n\n\t/*\n\t * child page was empty:\n\t */\n\tnfreed += lengthXAD(&p->xad[index]);\n\n\t/*\n\t * During working map update, child page's tlock must be handled\n\t * before parent's.  This is because the parent's tlock will cause\n\t * the child's disk space to be marked available in the wmap, so\n\t * it's important that the child page be released by that time.\n\t *\n\t * ToDo:  tlocks should be on doubly-linked list, so we can\n\t * quickly remove it and add it to the end.\n\t */\n\n\t/*\n\t * Move parent page's tlock to the end of the tid's tlock list\n\t */\n\tif (log && mp->lid && (tblk->last != mp->lid) &&\n\t    lid_to_tlock(mp->lid)->tid) {\n\t\tlid_t lid = mp->lid;\n\t\tstruct tlock *prev;\n\n\t\ttlck = lid_to_tlock(lid);\n\n\t\tif (tblk->next == lid)\n\t\t\ttblk->next = tlck->next;\n\t\telse {\n\t\t\tfor (prev = lid_to_tlock(tblk->next);\n\t\t\t     prev->next != lid;\n\t\t\t     prev = lid_to_tlock(prev->next)) {\n\t\t\t\tassert(prev->next);\n\t\t\t}\n\t\t\tprev->next = tlck->next;\n\t\t}\n\t\tlid_to_tlock(tblk->last)->next = lid;\n\t\ttlck->next = 0;\n\t\ttblk->last = lid;\n\t}\n\n\t/*\n\t * parent page become empty: free the page\n\t */\n\tif (index == XTENTRYSTART) {\n\t\tif (log) {\t/* COMMIT_PWMAP */\n\t\t\t/* txCommit() with tlckFREE:\n\t\t\t * free child extents covered by parent;\n\t\t\t * invalidate parent if COMMIT_PWMAP;\n\t\t\t */\n\t\t\ttlck = txLock(tid, ip, mp, tlckXTREE);\n\t\t\txtlck = (struct xtlock *) & tlck->lock;\n\t\t\txtlck->hwm.offset =\n\t\t\t    le16_to_cpu(p->header.nextindex) - 1;\n\t\t\ttlck->type = tlckXTREE | tlckFREE;\n\t\t} else {\t/* COMMIT_WMAP */\n\n\t\t\t/* free child extents covered by parent */\n\t\t\txadlock.xdlist = &p->xad[XTENTRYSTART];\n\t\t\txadlock.count =\n\t\t\t    le16_to_cpu(p->header.nextindex) -\n\t\t\t    XTENTRYSTART;\n\t\t\ttxFreeMap(ip, (struct maplock *) & xadlock, NULL,\n\t\t\t\t  COMMIT_WMAP);\n\t\t}\n\t\tBT_MARK_DIRTY(mp, ip);\n\n\t\tif (p->header.flag & BT_ROOT) {\n\t\t\tp->header.flag &= ~BT_INTERNAL;\n\t\t\tp->header.flag |= BT_LEAF;\n\t\t\tp->header.nextindex = cpu_to_le16(XTENTRYSTART);\n\t\t\tif (le16_to_cpu(p->header.maxentry) == XTROOTMAXSLOT) {\n\t\t\t\t/*\n\t\t\t\t * Shrink root down to allow inline\n\t\t\t\t * EA (otherwise fsck complains)\n\t\t\t\t */\n\t\t\t\tp->header.maxentry =\n\t\t\t\t    cpu_to_le16(XTROOTINITSLOT);\n\t\t\t\tJFS_IP(ip)->mode2 |= INLINEEA;\n\t\t\t}\n\n\t\t\tXT_PUTPAGE(mp);\t/* debug */\n\t\t\tgoto out;\n\t\t} else {\n\t\t\tif (log) {\t/* COMMIT_PWMAP */\n\t\t\t\t/* page will be invalidated at tx completion\n\t\t\t\t */\n\t\t\t\tXT_PUTPAGE(mp);\n\t\t\t} else {\t/* COMMIT_WMAP */\n\n\t\t\t\tif (mp->lid)\n\t\t\t\t\tlid_to_tlock(mp->lid)->flag |=\n\t\t\t\t\t\ttlckFREELOCK;\n\n\t\t\t\t/* invalidate parent page */\n\t\t\t\tdiscard_metapage(mp);\n\t\t\t}\n\n\t\t\t/* parent has become empty and freed:\n\t\t\t * go back up to its parent page\n\t\t\t */\n\t\t\t/* freed = 1; */\n\t\t\tgoto getParent;\n\t\t}\n\t}\n\t/*\n\t * parent page still has entries for front region;\n\t */\n\telse {\n\t\t/* try truncate region covered by preceding entry\n\t\t * (process backward)\n\t\t */\n\t\tindex--;\n\n\t\t/* go back down to the child page corresponding\n\t\t * to the entry\n\t\t */\n\t\tgoto getChild;\n\t}\n\n\t/*\n\t *\tinternal page: go down to child page of current entry\n\t */\n      getChild:\n\t/* save current parent entry for the child page */\n\tif (BT_STACK_FULL(&btstack)) {\n\t\tjfs_error(ip->i_sb, \"stack overrun!\\n\");\n\t\tXT_PUTPAGE(mp);\n\t\treturn -EIO;\n\t}\n\tBT_PUSH(&btstack, bn, index);\n\n\t/* get child page */\n\txad = &p->xad[index];\n\tbn = addressXAD(xad);\n\n\t/*\n\t * first access of each internal entry:\n\t */\n\t/* release parent page */\n\tXT_PUTPAGE(mp);\n\n\t/* process the child page */\n\tgoto getPage;\n\n      out:\n\t/*\n\t * update file resource stat\n\t */\n\t/* set size\n\t */\n\tif (S_ISDIR(ip->i_mode) && !newsize)\n\t\tip->i_size = 1;\t/* fsck hates zero-length directories */\n\telse\n\t\tip->i_size = newsize;\n\n\t/* update quota allocation to reflect freed blocks */\n\tdquot_free_block(ip, nfreed);\n\n\t/*\n\t * free tlock of invalidated pages\n\t */\n\tif (flag == COMMIT_WMAP)\n\t\ttxFreelock(ip);\n\n\treturn newsize;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_metapage",
          "args": [
            "ipimap",
            "blkno",
            "PSIZE",
            "0"
          ],
          "line": 2557
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "inode_add_bytes",
          "args": [
            "ipimap",
            "PSIZE"
          ],
          "line": 2554
        },
        "resolved": true,
        "details": {
          "function_name": "inode_add_bytes",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/stat.c",
          "lines": "460-465",
          "snippet": "void inode_add_bytes(struct inode *inode, loff_t bytes)\n{\n\tspin_lock(&inode->i_lock);\n\t__inode_add_bytes(inode, bytes);\n\tspin_unlock(&inode->i_lock);\n}",
          "includes": [
            "#include <asm/unistd.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/highuid.h>",
            "#include <linux/file.h>",
            "#include <linux/errno.h>",
            "#include <linux/mm.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/unistd.h>\n#include <asm/uaccess.h>\n#include <linux/pagemap.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/highuid.h>\n#include <linux/file.h>\n#include <linux/errno.h>\n#include <linux/mm.h>\n#include <linux/export.h>\n\nvoid inode_add_bytes(struct inode *inode, loff_t bytes)\n{\n\tspin_lock(&inode->i_lock);\n\t__inode_add_bytes(inode, bytes);\n\tspin_unlock(&inode->i_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "IWRITE_UNLOCK",
          "args": [
            "ipimap"
          ],
          "line": 2547
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dbFree",
          "args": [
            "ipimap",
            "xaddr",
            "(s64) xlen"
          ],
          "line": 2544
        },
        "resolved": true,
        "details": {
          "function_name": "dbFree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_dmap.c",
          "lines": "331-399",
          "snippet": "int dbFree(struct inode *ip, s64 blkno, s64 nblocks)\n{\n\tstruct metapage *mp;\n\tstruct dmap *dp;\n\tint nb, rc;\n\ts64 lblkno, rem;\n\tstruct inode *ipbmap = JFS_SBI(ip->i_sb)->ipbmap;\n\tstruct bmap *bmp = JFS_SBI(ip->i_sb)->bmap;\n\tstruct super_block *sb = ipbmap->i_sb;\n\n\tIREAD_LOCK(ipbmap, RDWRLOCK_DMAP);\n\n\t/* block to be freed better be within the mapsize. */\n\tif (unlikely((blkno == 0) || (blkno + nblocks > bmp->db_mapsize))) {\n\t\tIREAD_UNLOCK(ipbmap);\n\t\tprintk(KERN_ERR \"blkno = %Lx, nblocks = %Lx\\n\",\n\t\t       (unsigned long long) blkno,\n\t\t       (unsigned long long) nblocks);\n\t\tjfs_error(ip->i_sb, \"block to be freed is outside the map\\n\");\n\t\treturn -EIO;\n\t}\n\n\t/**\n\t * TRIM the blocks, when mounted with discard option\n\t */\n\tif (JFS_SBI(sb)->flag & JFS_DISCARD)\n\t\tif (JFS_SBI(sb)->minblks_trim <= nblocks)\n\t\t\tjfs_issue_discard(ipbmap, blkno, nblocks);\n\n\t/*\n\t * free the blocks a dmap at a time.\n\t */\n\tmp = NULL;\n\tfor (rem = nblocks; rem > 0; rem -= nb, blkno += nb) {\n\t\t/* release previous dmap if any */\n\t\tif (mp) {\n\t\t\twrite_metapage(mp);\n\t\t}\n\n\t\t/* get the buffer for the current dmap. */\n\t\tlblkno = BLKTODMAP(blkno, bmp->db_l2nbperpage);\n\t\tmp = read_metapage(ipbmap, lblkno, PSIZE, 0);\n\t\tif (mp == NULL) {\n\t\t\tIREAD_UNLOCK(ipbmap);\n\t\t\treturn -EIO;\n\t\t}\n\t\tdp = (struct dmap *) mp->data;\n\n\t\t/* determine the number of blocks to be freed from\n\t\t * this dmap.\n\t\t */\n\t\tnb = min(rem, BPERDMAP - (blkno & (BPERDMAP - 1)));\n\n\t\t/* free the blocks. */\n\t\tif ((rc = dbFreeDmap(bmp, dp, blkno, nb))) {\n\t\t\tjfs_error(ip->i_sb, \"error in block map\\n\");\n\t\t\trelease_metapage(mp);\n\t\t\tIREAD_UNLOCK(ipbmap);\n\t\t\treturn (rc);\n\t\t}\n\t}\n\n\t/* write the last buffer. */\n\twrite_metapage(mp);\n\n\tIREAD_UNLOCK(ipbmap);\n\n\treturn (0);\n}",
          "includes": [
            "#include \"jfs_discard.h\"",
            "#include \"jfs_debug.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_lock.h\"",
            "#include \"jfs_imap.h\"",
            "#include \"jfs_dmap.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dbAllocBits(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t\tint nblocks);",
            "static int dbAllocNext(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t       int nblocks);",
            "static int dbAllocDmap(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t       int nblocks);",
            "static int dbFindCtl(struct bmap * bmp, int l2nb, int level, s64 * blkno);",
            "static int dbFreeBits(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t      int nblocks);",
            "static int dbFreeDmap(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t      int nblocks);",
            "static int blkstol2(s64 nb);",
            "static int dbAllocDmapBU(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t\t int nblocks);",
            "static int dbInitDmap(struct dmap * dp, s64 blkno, int nblocks);",
            "static int dbInitDmapTree(struct dmap * dp);",
            "static int dbGetL2AGSize(s64 nblocks);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_discard.h\"\n#include \"jfs_debug.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_lock.h\"\n#include \"jfs_imap.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_incore.h\"\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic void dbAllocBits(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t\tint nblocks);\nstatic int dbAllocNext(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t       int nblocks);\nstatic int dbAllocDmap(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t       int nblocks);\nstatic int dbFindCtl(struct bmap * bmp, int l2nb, int level, s64 * blkno);\nstatic int dbFreeBits(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t      int nblocks);\nstatic int dbFreeDmap(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t      int nblocks);\nstatic int blkstol2(s64 nb);\nstatic int dbAllocDmapBU(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t\t int nblocks);\nstatic int dbInitDmap(struct dmap * dp, s64 blkno, int nblocks);\nstatic int dbInitDmapTree(struct dmap * dp);\nstatic int dbGetL2AGSize(s64 nblocks);\n\nint dbFree(struct inode *ip, s64 blkno, s64 nblocks)\n{\n\tstruct metapage *mp;\n\tstruct dmap *dp;\n\tint nb, rc;\n\ts64 lblkno, rem;\n\tstruct inode *ipbmap = JFS_SBI(ip->i_sb)->ipbmap;\n\tstruct bmap *bmp = JFS_SBI(ip->i_sb)->bmap;\n\tstruct super_block *sb = ipbmap->i_sb;\n\n\tIREAD_LOCK(ipbmap, RDWRLOCK_DMAP);\n\n\t/* block to be freed better be within the mapsize. */\n\tif (unlikely((blkno == 0) || (blkno + nblocks > bmp->db_mapsize))) {\n\t\tIREAD_UNLOCK(ipbmap);\n\t\tprintk(KERN_ERR \"blkno = %Lx, nblocks = %Lx\\n\",\n\t\t       (unsigned long long) blkno,\n\t\t       (unsigned long long) nblocks);\n\t\tjfs_error(ip->i_sb, \"block to be freed is outside the map\\n\");\n\t\treturn -EIO;\n\t}\n\n\t/**\n\t * TRIM the blocks, when mounted with discard option\n\t */\n\tif (JFS_SBI(sb)->flag & JFS_DISCARD)\n\t\tif (JFS_SBI(sb)->minblks_trim <= nblocks)\n\t\t\tjfs_issue_discard(ipbmap, blkno, nblocks);\n\n\t/*\n\t * free the blocks a dmap at a time.\n\t */\n\tmp = NULL;\n\tfor (rem = nblocks; rem > 0; rem -= nb, blkno += nb) {\n\t\t/* release previous dmap if any */\n\t\tif (mp) {\n\t\t\twrite_metapage(mp);\n\t\t}\n\n\t\t/* get the buffer for the current dmap. */\n\t\tlblkno = BLKTODMAP(blkno, bmp->db_l2nbperpage);\n\t\tmp = read_metapage(ipbmap, lblkno, PSIZE, 0);\n\t\tif (mp == NULL) {\n\t\t\tIREAD_UNLOCK(ipbmap);\n\t\t\treturn -EIO;\n\t\t}\n\t\tdp = (struct dmap *) mp->data;\n\n\t\t/* determine the number of blocks to be freed from\n\t\t * this dmap.\n\t\t */\n\t\tnb = min(rem, BPERDMAP - (blkno & (BPERDMAP - 1)));\n\n\t\t/* free the blocks. */\n\t\tif ((rc = dbFreeDmap(bmp, dp, blkno, nb))) {\n\t\t\tjfs_error(ip->i_sb, \"error in block map\\n\");\n\t\t\trelease_metapage(mp);\n\t\t\tIREAD_UNLOCK(ipbmap);\n\t\t\treturn (rc);\n\t\t}\n\t}\n\n\t/* write the last buffer. */\n\twrite_metapage(mp);\n\n\tIREAD_UNLOCK(ipbmap);\n\n\treturn (0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&JFS_IP(ipimap)->commit_mutex"
          ],
          "line": 2540
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xtInsert",
          "args": [
            "tid",
            "ipimap",
            "0",
            "blkno",
            "xlen",
            "&xaddr",
            "0"
          ],
          "line": 2538
        },
        "resolved": true,
        "details": {
          "function_name": "xtInsert",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_xtree.c",
          "lines": "537-670",
          "snippet": "int xtInsert(tid_t tid,\t\t/* transaction id */\n\t     struct inode *ip, int xflag, s64 xoff, s32 xlen, s64 * xaddrp,\n\t     int flag)\n{\n\tint rc = 0;\n\ts64 xaddr, hint;\n\tstruct metapage *mp;\t/* meta-page buffer */\n\txtpage_t *p;\t\t/* base B+-tree index page */\n\ts64 bn;\n\tint index, nextindex;\n\tstruct btstack btstack;\t/* traverse stack */\n\tstruct xtsplit split;\t/* split information */\n\txad_t *xad;\n\tint cmp;\n\ts64 next;\n\tstruct tlock *tlck;\n\tstruct xtlock *xtlck;\n\n\tjfs_info(\"xtInsert: nxoff:0x%lx nxlen:0x%x\", (ulong) xoff, xlen);\n\n\t/*\n\t *\tsearch for the entry location at which to insert:\n\t *\n\t * xtFastSearch() and xtSearch() both returns (leaf page\n\t * pinned, index at which to insert).\n\t * n.b. xtSearch() may return index of maxentry of\n\t * the full page.\n\t */\n\tif ((rc = xtSearch(ip, xoff, &next, &cmp, &btstack, XT_INSERT)))\n\t\treturn rc;\n\n\t/* retrieve search result */\n\tXT_GETSEARCH(ip, btstack.top, bn, mp, p, index);\n\n\t/* This test must follow XT_GETSEARCH since mp must be valid if\n\t * we branch to out: */\n\tif ((cmp == 0) || (next && (xlen > next - xoff))) {\n\t\trc = -EEXIST;\n\t\tgoto out;\n\t}\n\n\t/*\n\t * allocate data extent requested\n\t *\n\t * allocation hint: last xad\n\t */\n\tif ((xaddr = *xaddrp) == 0) {\n\t\tif (index > XTENTRYSTART) {\n\t\t\txad = &p->xad[index - 1];\n\t\t\thint = addressXAD(xad) + lengthXAD(xad) - 1;\n\t\t} else\n\t\t\thint = 0;\n\t\tif ((rc = dquot_alloc_block(ip, xlen)))\n\t\t\tgoto out;\n\t\tif ((rc = dbAlloc(ip, hint, (s64) xlen, &xaddr))) {\n\t\t\tdquot_free_block(ip, xlen);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\t/*\n\t *\tinsert entry for new extent\n\t */\n\txflag |= XAD_NEW;\n\n\t/*\n\t *\tif the leaf page is full, split the page and\n\t *\tpropagate up the router entry for the new page from split\n\t *\n\t * The xtSplitUp() will insert the entry and unpin the leaf page.\n\t */\n\tnextindex = le16_to_cpu(p->header.nextindex);\n\tif (nextindex == le16_to_cpu(p->header.maxentry)) {\n\t\tsplit.mp = mp;\n\t\tsplit.index = index;\n\t\tsplit.flag = xflag;\n\t\tsplit.off = xoff;\n\t\tsplit.len = xlen;\n\t\tsplit.addr = xaddr;\n\t\tsplit.pxdlist = NULL;\n\t\tif ((rc = xtSplitUp(tid, ip, &split, &btstack))) {\n\t\t\t/* undo data extent allocation */\n\t\t\tif (*xaddrp == 0) {\n\t\t\t\tdbFree(ip, xaddr, (s64) xlen);\n\t\t\t\tdquot_free_block(ip, xlen);\n\t\t\t}\n\t\t\treturn rc;\n\t\t}\n\n\t\t*xaddrp = xaddr;\n\t\treturn 0;\n\t}\n\n\t/*\n\t *\tinsert the new entry into the leaf page\n\t */\n\t/*\n\t * acquire a transaction lock on the leaf page;\n\t *\n\t * action: xad insertion/extension;\n\t */\n\tBT_MARK_DIRTY(mp, ip);\n\n\t/* if insert into middle, shift right remaining entries. */\n\tif (index < nextindex)\n\t\tmemmove(&p->xad[index + 1], &p->xad[index],\n\t\t\t(nextindex - index) * sizeof(xad_t));\n\n\t/* insert the new entry: mark the entry NEW */\n\txad = &p->xad[index];\n\tXT_PUTENTRY(xad, xflag, xoff, xlen, xaddr);\n\n\t/* advance next available entry index */\n\tle16_add_cpu(&p->header.nextindex, 1);\n\n\t/* Don't log it if there are no links to the file */\n\tif (!test_cflag(COMMIT_Nolink, ip)) {\n\t\ttlck = txLock(tid, ip, mp, tlckXTREE | tlckGROW);\n\t\txtlck = (struct xtlock *) & tlck->lock;\n\t\txtlck->lwm.offset =\n\t\t    (xtlck->lwm.offset) ? min(index,\n\t\t\t\t\t      (int)xtlck->lwm.offset) : index;\n\t\txtlck->lwm.length =\n\t\t    le16_to_cpu(p->header.nextindex) - xtlck->lwm.offset;\n\t}\n\n\t*xaddrp = xaddr;\n\n      out:\n\t/* unpin the leaf page */\n\tXT_PUTPAGE(mp);\n\n\treturn rc;\n}",
          "includes": [
            "#include \"jfs_debug.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_dinode.h\"",
            "#include \"jfs_dmap.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_filsys.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/module.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [
            "#define XT_INSERT\t0x00000001"
          ],
          "globals_used": [
            "static int xtSearch(struct inode *ip, s64 xoff, s64 *next, int *cmpp,\n\t\t    struct btstack * btstack, int flag);",
            "static int xtSplitUp(tid_t tid,\n\t\t     struct inode *ip,\n\t\t     struct xtsplit * split, struct btstack * btstack);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_dinode.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_incore.h\"\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/module.h>\n#include <linux/fs.h>\n\n#define XT_INSERT\t0x00000001\n\nstatic int xtSearch(struct inode *ip, s64 xoff, s64 *next, int *cmpp,\n\t\t    struct btstack * btstack, int flag);\nstatic int xtSplitUp(tid_t tid,\n\t\t     struct inode *ip,\n\t\t     struct xtsplit * split, struct btstack * btstack);\n\nint xtInsert(tid_t tid,\t\t/* transaction id */\n\t     struct inode *ip, int xflag, s64 xoff, s32 xlen, s64 * xaddrp,\n\t     int flag)\n{\n\tint rc = 0;\n\ts64 xaddr, hint;\n\tstruct metapage *mp;\t/* meta-page buffer */\n\txtpage_t *p;\t\t/* base B+-tree index page */\n\ts64 bn;\n\tint index, nextindex;\n\tstruct btstack btstack;\t/* traverse stack */\n\tstruct xtsplit split;\t/* split information */\n\txad_t *xad;\n\tint cmp;\n\ts64 next;\n\tstruct tlock *tlck;\n\tstruct xtlock *xtlck;\n\n\tjfs_info(\"xtInsert: nxoff:0x%lx nxlen:0x%x\", (ulong) xoff, xlen);\n\n\t/*\n\t *\tsearch for the entry location at which to insert:\n\t *\n\t * xtFastSearch() and xtSearch() both returns (leaf page\n\t * pinned, index at which to insert).\n\t * n.b. xtSearch() may return index of maxentry of\n\t * the full page.\n\t */\n\tif ((rc = xtSearch(ip, xoff, &next, &cmp, &btstack, XT_INSERT)))\n\t\treturn rc;\n\n\t/* retrieve search result */\n\tXT_GETSEARCH(ip, btstack.top, bn, mp, p, index);\n\n\t/* This test must follow XT_GETSEARCH since mp must be valid if\n\t * we branch to out: */\n\tif ((cmp == 0) || (next && (xlen > next - xoff))) {\n\t\trc = -EEXIST;\n\t\tgoto out;\n\t}\n\n\t/*\n\t * allocate data extent requested\n\t *\n\t * allocation hint: last xad\n\t */\n\tif ((xaddr = *xaddrp) == 0) {\n\t\tif (index > XTENTRYSTART) {\n\t\t\txad = &p->xad[index - 1];\n\t\t\thint = addressXAD(xad) + lengthXAD(xad) - 1;\n\t\t} else\n\t\t\thint = 0;\n\t\tif ((rc = dquot_alloc_block(ip, xlen)))\n\t\t\tgoto out;\n\t\tif ((rc = dbAlloc(ip, hint, (s64) xlen, &xaddr))) {\n\t\t\tdquot_free_block(ip, xlen);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\t/*\n\t *\tinsert entry for new extent\n\t */\n\txflag |= XAD_NEW;\n\n\t/*\n\t *\tif the leaf page is full, split the page and\n\t *\tpropagate up the router entry for the new page from split\n\t *\n\t * The xtSplitUp() will insert the entry and unpin the leaf page.\n\t */\n\tnextindex = le16_to_cpu(p->header.nextindex);\n\tif (nextindex == le16_to_cpu(p->header.maxentry)) {\n\t\tsplit.mp = mp;\n\t\tsplit.index = index;\n\t\tsplit.flag = xflag;\n\t\tsplit.off = xoff;\n\t\tsplit.len = xlen;\n\t\tsplit.addr = xaddr;\n\t\tsplit.pxdlist = NULL;\n\t\tif ((rc = xtSplitUp(tid, ip, &split, &btstack))) {\n\t\t\t/* undo data extent allocation */\n\t\t\tif (*xaddrp == 0) {\n\t\t\t\tdbFree(ip, xaddr, (s64) xlen);\n\t\t\t\tdquot_free_block(ip, xlen);\n\t\t\t}\n\t\t\treturn rc;\n\t\t}\n\n\t\t*xaddrp = xaddr;\n\t\treturn 0;\n\t}\n\n\t/*\n\t *\tinsert the new entry into the leaf page\n\t */\n\t/*\n\t * acquire a transaction lock on the leaf page;\n\t *\n\t * action: xad insertion/extension;\n\t */\n\tBT_MARK_DIRTY(mp, ip);\n\n\t/* if insert into middle, shift right remaining entries. */\n\tif (index < nextindex)\n\t\tmemmove(&p->xad[index + 1], &p->xad[index],\n\t\t\t(nextindex - index) * sizeof(xad_t));\n\n\t/* insert the new entry: mark the entry NEW */\n\txad = &p->xad[index];\n\tXT_PUTENTRY(xad, xflag, xoff, xlen, xaddr);\n\n\t/* advance next available entry index */\n\tle16_add_cpu(&p->header.nextindex, 1);\n\n\t/* Don't log it if there are no links to the file */\n\tif (!test_cflag(COMMIT_Nolink, ip)) {\n\t\ttlck = txLock(tid, ip, mp, tlckXTREE | tlckGROW);\n\t\txtlck = (struct xtlock *) & tlck->lock;\n\t\txtlck->lwm.offset =\n\t\t    (xtlck->lwm.offset) ? min(index,\n\t\t\t\t\t      (int)xtlck->lwm.offset) : index;\n\t\txtlck->lwm.length =\n\t\t    le16_to_cpu(p->header.nextindex) - xtlck->lwm.offset;\n\t}\n\n\t*xaddrp = xaddr;\n\n      out:\n\t/* unpin the leaf page */\n\tXT_PUTPAGE(mp);\n\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&JFS_IP(ipimap)->commit_mutex"
          ],
          "line": 2534
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "txBegin",
          "args": [
            "sb",
            "COMMIT_FORCE"
          ],
          "line": 2533
        },
        "resolved": true,
        "details": {
          "function_name": "txBegin",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_txnmgr.c",
          "lines": "361-447",
          "snippet": "tid_t txBegin(struct super_block *sb, int flag)\n{\n\ttid_t t;\n\tstruct tblock *tblk;\n\tstruct jfs_log *log;\n\n\tjfs_info(\"txBegin: flag = 0x%x\", flag);\n\tlog = JFS_SBI(sb)->log;\n\n\tTXN_LOCK();\n\n\tINCREMENT(TxStat.txBegin);\n\n      retry:\n\tif (!(flag & COMMIT_FORCE)) {\n\t\t/*\n\t\t * synchronize with logsync barrier\n\t\t */\n\t\tif (test_bit(log_SYNCBARRIER, &log->flag) ||\n\t\t    test_bit(log_QUIESCE, &log->flag)) {\n\t\t\tINCREMENT(TxStat.txBegin_barrier);\n\t\t\tTXN_SLEEP(&log->syncwait);\n\t\t\tgoto retry;\n\t\t}\n\t}\n\tif (flag == 0) {\n\t\t/*\n\t\t * Don't begin transaction if we're getting starved for tlocks\n\t\t * unless COMMIT_FORCE or COMMIT_INODE (which may ultimately\n\t\t * free tlocks)\n\t\t */\n\t\tif (TxAnchor.tlocksInUse > TxLockVHWM) {\n\t\t\tINCREMENT(TxStat.txBegin_lockslow);\n\t\t\tTXN_SLEEP(&TxAnchor.lowlockwait);\n\t\t\tgoto retry;\n\t\t}\n\t}\n\n\t/*\n\t * allocate transaction id/block\n\t */\n\tif ((t = TxAnchor.freetid) == 0) {\n\t\tjfs_info(\"txBegin: waiting for free tid\");\n\t\tINCREMENT(TxStat.txBegin_freetid);\n\t\tTXN_SLEEP(&TxAnchor.freewait);\n\t\tgoto retry;\n\t}\n\n\ttblk = tid_to_tblock(t);\n\n\tif ((tblk->next == 0) && !(flag & COMMIT_FORCE)) {\n\t\t/* Don't let a non-forced transaction take the last tblk */\n\t\tjfs_info(\"txBegin: waiting for free tid\");\n\t\tINCREMENT(TxStat.txBegin_freetid);\n\t\tTXN_SLEEP(&TxAnchor.freewait);\n\t\tgoto retry;\n\t}\n\n\tTxAnchor.freetid = tblk->next;\n\n\t/*\n\t * initialize transaction\n\t */\n\n\t/*\n\t * We can't zero the whole thing or we screw up another thread being\n\t * awakened after sleeping on tblk->waitor\n\t *\n\t * memset(tblk, 0, sizeof(struct tblock));\n\t */\n\ttblk->next = tblk->last = tblk->xflag = tblk->flag = tblk->lsn = 0;\n\n\ttblk->sb = sb;\n\t++log->logtid;\n\ttblk->logtid = log->logtid;\n\n\t++log->active;\n\n\tHIGHWATERMARK(stattx.maxtid, t);\t/* statistics */\n\tINCREMENT(stattx.ntid);\t/* statistics */\n\n\tTXN_UNLOCK();\n\n\tjfs_info(\"txBegin: returning tid = %d\", t);\n\n\treturn t;\n}",
          "includes": [
            "#include \"jfs_debug.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_dmap.h\"",
            "#include \"jfs_imap.h\"",
            "#include \"jfs_dinode.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_filsys.h\"",
            "#include \"jfs_inode.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/freezer.h>",
            "#include <linux/completion.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct {\n\tint freetid;\t\t/* index of a free tid structure */\n\tint freelock;\t\t/* index first free lock word */\n\twait_queue_head_t freewait;\t/* eventlist of free tblock */\n\twait_queue_head_t freelockwait;\t/* eventlist of free tlock */\n\twait_queue_head_t lowlockwait;\t/* eventlist of ample tlocks */\n\tint tlocksInUse;\t/* Number of tlocks in use */\n\tspinlock_t LazyLock;\t/* synchronize sync_queue & unlock_queue */\n/*\tstruct tblock *sync_queue; * Transactions waiting for data sync */\n\tstruct list_head unlock_queue;\t/* Txns waiting to be released */\n\tstruct list_head anon_list;\t/* inodes having anonymous txns */\n\tstruct list_head anon_list2;\t/* inodes having anonymous txns\n\t\t\t\t\t   that couldn't be sync'ed */\n} TxAnchor;",
            "static int TxLockVHWM;",
            "static struct {\n\ttid_t maxtid;\t\t/* 4: biggest tid ever used */\n\tlid_t maxlid;\t\t/* 4: biggest lid ever used */\n\tint ntid;\t\t/* 4: # of transactions performed */\n\tint nlid;\t\t/* 4: # of tlocks acquired */\n\tint waitlock;\t\t/* 4: # of tlock wait */\n} stattx;",
            "static void txAllocPMap(struct inode *ip, struct maplock * maplock,\n\t\tstruct tblock * tblk);",
            "static void txForce(struct tblock * tblk);",
            "static void txUpdateMap(struct tblock * tblk);",
            "static void txRelease(struct tblock * tblk);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_imap.h\"\n#include \"jfs_dinode.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_inode.h\"\n#include \"jfs_incore.h\"\n#include <linux/seq_file.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/freezer.h>\n#include <linux/completion.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n\nstatic struct {\n\tint freetid;\t\t/* index of a free tid structure */\n\tint freelock;\t\t/* index first free lock word */\n\twait_queue_head_t freewait;\t/* eventlist of free tblock */\n\twait_queue_head_t freelockwait;\t/* eventlist of free tlock */\n\twait_queue_head_t lowlockwait;\t/* eventlist of ample tlocks */\n\tint tlocksInUse;\t/* Number of tlocks in use */\n\tspinlock_t LazyLock;\t/* synchronize sync_queue & unlock_queue */\n/*\tstruct tblock *sync_queue; * Transactions waiting for data sync */\n\tstruct list_head unlock_queue;\t/* Txns waiting to be released */\n\tstruct list_head anon_list;\t/* inodes having anonymous txns */\n\tstruct list_head anon_list2;\t/* inodes having anonymous txns\n\t\t\t\t\t   that couldn't be sync'ed */\n} TxAnchor;\nstatic int TxLockVHWM;\nstatic struct {\n\ttid_t maxtid;\t\t/* 4: biggest tid ever used */\n\tlid_t maxlid;\t\t/* 4: biggest lid ever used */\n\tint ntid;\t\t/* 4: # of transactions performed */\n\tint nlid;\t\t/* 4: # of tlocks acquired */\n\tint waitlock;\t\t/* 4: # of tlock wait */\n} stattx;\nstatic void txAllocPMap(struct inode *ip, struct maplock * maplock,\n\t\tstruct tblock * tblk);\nstatic void txForce(struct tblock * tblk);\nstatic void txUpdateMap(struct tblock * tblk);\nstatic void txRelease(struct tblock * tblk);\n\ntid_t txBegin(struct super_block *sb, int flag)\n{\n\ttid_t t;\n\tstruct tblock *tblk;\n\tstruct jfs_log *log;\n\n\tjfs_info(\"txBegin: flag = 0x%x\", flag);\n\tlog = JFS_SBI(sb)->log;\n\n\tTXN_LOCK();\n\n\tINCREMENT(TxStat.txBegin);\n\n      retry:\n\tif (!(flag & COMMIT_FORCE)) {\n\t\t/*\n\t\t * synchronize with logsync barrier\n\t\t */\n\t\tif (test_bit(log_SYNCBARRIER, &log->flag) ||\n\t\t    test_bit(log_QUIESCE, &log->flag)) {\n\t\t\tINCREMENT(TxStat.txBegin_barrier);\n\t\t\tTXN_SLEEP(&log->syncwait);\n\t\t\tgoto retry;\n\t\t}\n\t}\n\tif (flag == 0) {\n\t\t/*\n\t\t * Don't begin transaction if we're getting starved for tlocks\n\t\t * unless COMMIT_FORCE or COMMIT_INODE (which may ultimately\n\t\t * free tlocks)\n\t\t */\n\t\tif (TxAnchor.tlocksInUse > TxLockVHWM) {\n\t\t\tINCREMENT(TxStat.txBegin_lockslow);\n\t\t\tTXN_SLEEP(&TxAnchor.lowlockwait);\n\t\t\tgoto retry;\n\t\t}\n\t}\n\n\t/*\n\t * allocate transaction id/block\n\t */\n\tif ((t = TxAnchor.freetid) == 0) {\n\t\tjfs_info(\"txBegin: waiting for free tid\");\n\t\tINCREMENT(TxStat.txBegin_freetid);\n\t\tTXN_SLEEP(&TxAnchor.freewait);\n\t\tgoto retry;\n\t}\n\n\ttblk = tid_to_tblock(t);\n\n\tif ((tblk->next == 0) && !(flag & COMMIT_FORCE)) {\n\t\t/* Don't let a non-forced transaction take the last tblk */\n\t\tjfs_info(\"txBegin: waiting for free tid\");\n\t\tINCREMENT(TxStat.txBegin_freetid);\n\t\tTXN_SLEEP(&TxAnchor.freewait);\n\t\tgoto retry;\n\t}\n\n\tTxAnchor.freetid = tblk->next;\n\n\t/*\n\t * initialize transaction\n\t */\n\n\t/*\n\t * We can't zero the whole thing or we screw up another thread being\n\t * awakened after sleeping on tblk->waitor\n\t *\n\t * memset(tblk, 0, sizeof(struct tblock));\n\t */\n\ttblk->next = tblk->last = tblk->xflag = tblk->flag = tblk->lsn = 0;\n\n\ttblk->sb = sb;\n\t++log->logtid;\n\ttblk->logtid = log->logtid;\n\n\t++log->active;\n\n\tHIGHWATERMARK(stattx.maxtid, t);\t/* statistics */\n\tINCREMENT(stattx.ntid);\t/* statistics */\n\n\tTXN_UNLOCK();\n\n\tjfs_info(\"txBegin: returning tid = %d\", t);\n\n\treturn t;\n}"
        }
      },
      {
        "call_info": {
          "callee": "IWRITE_UNLOCK",
          "args": [
            "ipimap"
          ],
          "line": 2524
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dbAlloc",
          "args": [
            "ipimap",
            "0",
            "(s64) xlen",
            "&xaddr"
          ],
          "line": 2522
        },
        "resolved": true,
        "details": {
          "function_name": "dbAllocDmapBU",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_dmap.c",
          "lines": "3263-3364",
          "snippet": "static int dbAllocDmapBU(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t\t int nblocks)\n{\n\tint rc;\n\tint dbitno, word, rembits, nb, nwords, wbitno, agno;\n\ts8 oldroot;\n\tstruct dmaptree *tp = (struct dmaptree *) & dp->tree;\n\n\t/* save the current value of the root (i.e. maximum free string)\n\t * of the dmap tree.\n\t */\n\toldroot = tp->stree[ROOT];\n\n\t/* determine the bit number and word within the dmap of the\n\t * starting block.\n\t */\n\tdbitno = blkno & (BPERDMAP - 1);\n\tword = dbitno >> L2DBWORD;\n\n\t/* block range better be within the dmap */\n\tassert(dbitno + nblocks <= BPERDMAP);\n\n\t/* allocate the bits of the dmap's words corresponding to the block\n\t * range. not all bits of the first and last words may be contained\n\t * within the block range.  if this is the case, we'll work against\n\t * those words (i.e. partial first and/or last) on an individual basis\n\t * (a single pass), allocating the bits of interest by hand and\n\t * updating the leaf corresponding to the dmap word. a single pass\n\t * will be used for all dmap words fully contained within the\n\t * specified range.  within this pass, the bits of all fully contained\n\t * dmap words will be marked as free in a single shot and the leaves\n\t * will be updated. a single leaf may describe the free space of\n\t * multiple dmap words, so we may update only a subset of the actual\n\t * leaves corresponding to the dmap words of the block range.\n\t */\n\tfor (rembits = nblocks; rembits > 0; rembits -= nb, dbitno += nb) {\n\t\t/* determine the bit number within the word and\n\t\t * the number of bits within the word.\n\t\t */\n\t\twbitno = dbitno & (DBWORD - 1);\n\t\tnb = min(rembits, DBWORD - wbitno);\n\n\t\t/* check if only part of a word is to be allocated.\n\t\t */\n\t\tif (nb < DBWORD) {\n\t\t\t/* allocate (set to 1) the appropriate bits within\n\t\t\t * this dmap word.\n\t\t\t */\n\t\t\tdp->wmap[word] |= cpu_to_le32(ONES << (DBWORD - nb)\n\t\t\t\t\t\t      >> wbitno);\n\n\t\t\tword++;\n\t\t} else {\n\t\t\t/* one or more dmap words are fully contained\n\t\t\t * within the block range.  determine how many\n\t\t\t * words and allocate (set to 1) the bits of these\n\t\t\t * words.\n\t\t\t */\n\t\t\tnwords = rembits >> L2DBWORD;\n\t\t\tmemset(&dp->wmap[word], (int) ONES, nwords * 4);\n\n\t\t\t/* determine how many bits */\n\t\t\tnb = nwords << L2DBWORD;\n\t\t\tword += nwords;\n\t\t}\n\t}\n\n\t/* update the free count for this dmap */\n\tle32_add_cpu(&dp->nfree, -nblocks);\n\n\t/* reconstruct summary tree */\n\tdbInitDmapTree(dp);\n\n\tBMAP_LOCK(bmp);\n\n\t/* if this allocation group is completely free,\n\t * update the highest active allocation group number\n\t * if this allocation group is the new max.\n\t */\n\tagno = blkno >> bmp->db_agl2size;\n\tif (agno > bmp->db_maxag)\n\t\tbmp->db_maxag = agno;\n\n\t/* update the free count for the allocation group and map */\n\tbmp->db_agfree[agno] -= nblocks;\n\tbmp->db_nfree -= nblocks;\n\n\tBMAP_UNLOCK(bmp);\n\n\t/* if the root has not changed, done. */\n\tif (tp->stree[ROOT] == oldroot)\n\t\treturn (0);\n\n\t/* root changed. bubble the change up to the dmap control pages.\n\t * if the adjustment of the upper level control pages fails,\n\t * backout the bit allocation (thus making everything consistent).\n\t */\n\tif ((rc = dbAdjCtl(bmp, blkno, tp->stree[ROOT], 1, 0)))\n\t\tdbFreeBits(bmp, dp, blkno, nblocks);\n\n\treturn (rc);\n}",
          "includes": [
            "#include \"jfs_discard.h\"",
            "#include \"jfs_debug.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_lock.h\"",
            "#include \"jfs_imap.h\"",
            "#include \"jfs_dmap.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dbAllocBits(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t\tint nblocks);",
            "static int dbAdjCtl(struct bmap * bmp, s64 blkno, int newval, int alloc,\n\t\t    int level);",
            "static int dbAllocNext(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t       int nblocks);",
            "static int dbAllocDmap(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t       int nblocks);",
            "static int dbFindCtl(struct bmap * bmp, int l2nb, int level, s64 * blkno);",
            "static int dbFreeBits(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t      int nblocks);",
            "static int dbFreeDmap(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t      int nblocks);",
            "static int blkstol2(s64 nb);",
            "static int cntlz(u32 value);",
            "static int cnttz(u32 word);",
            "static int dbAllocDmapBU(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t\t int nblocks);",
            "static int dbInitDmap(struct dmap * dp, s64 blkno, int nblocks);",
            "static int dbInitDmapTree(struct dmap * dp);",
            "static int dbInitDmapCtl(struct dmapctl * dcp, int level, int i);",
            "static int dbGetL2AGSize(s64 nblocks);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_discard.h\"\n#include \"jfs_debug.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_lock.h\"\n#include \"jfs_imap.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_incore.h\"\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic void dbAllocBits(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t\tint nblocks);\nstatic int dbAdjCtl(struct bmap * bmp, s64 blkno, int newval, int alloc,\n\t\t    int level);\nstatic int dbAllocNext(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t       int nblocks);\nstatic int dbAllocDmap(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t       int nblocks);\nstatic int dbFindCtl(struct bmap * bmp, int l2nb, int level, s64 * blkno);\nstatic int dbFreeBits(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t      int nblocks);\nstatic int dbFreeDmap(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t      int nblocks);\nstatic int blkstol2(s64 nb);\nstatic int cntlz(u32 value);\nstatic int cnttz(u32 word);\nstatic int dbAllocDmapBU(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t\t int nblocks);\nstatic int dbInitDmap(struct dmap * dp, s64 blkno, int nblocks);\nstatic int dbInitDmapTree(struct dmap * dp);\nstatic int dbInitDmapCtl(struct dmapctl * dcp, int level, int i);\nstatic int dbGetL2AGSize(s64 nblocks);\n\nstatic int dbAllocDmapBU(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t\t int nblocks)\n{\n\tint rc;\n\tint dbitno, word, rembits, nb, nwords, wbitno, agno;\n\ts8 oldroot;\n\tstruct dmaptree *tp = (struct dmaptree *) & dp->tree;\n\n\t/* save the current value of the root (i.e. maximum free string)\n\t * of the dmap tree.\n\t */\n\toldroot = tp->stree[ROOT];\n\n\t/* determine the bit number and word within the dmap of the\n\t * starting block.\n\t */\n\tdbitno = blkno & (BPERDMAP - 1);\n\tword = dbitno >> L2DBWORD;\n\n\t/* block range better be within the dmap */\n\tassert(dbitno + nblocks <= BPERDMAP);\n\n\t/* allocate the bits of the dmap's words corresponding to the block\n\t * range. not all bits of the first and last words may be contained\n\t * within the block range.  if this is the case, we'll work against\n\t * those words (i.e. partial first and/or last) on an individual basis\n\t * (a single pass), allocating the bits of interest by hand and\n\t * updating the leaf corresponding to the dmap word. a single pass\n\t * will be used for all dmap words fully contained within the\n\t * specified range.  within this pass, the bits of all fully contained\n\t * dmap words will be marked as free in a single shot and the leaves\n\t * will be updated. a single leaf may describe the free space of\n\t * multiple dmap words, so we may update only a subset of the actual\n\t * leaves corresponding to the dmap words of the block range.\n\t */\n\tfor (rembits = nblocks; rembits > 0; rembits -= nb, dbitno += nb) {\n\t\t/* determine the bit number within the word and\n\t\t * the number of bits within the word.\n\t\t */\n\t\twbitno = dbitno & (DBWORD - 1);\n\t\tnb = min(rembits, DBWORD - wbitno);\n\n\t\t/* check if only part of a word is to be allocated.\n\t\t */\n\t\tif (nb < DBWORD) {\n\t\t\t/* allocate (set to 1) the appropriate bits within\n\t\t\t * this dmap word.\n\t\t\t */\n\t\t\tdp->wmap[word] |= cpu_to_le32(ONES << (DBWORD - nb)\n\t\t\t\t\t\t      >> wbitno);\n\n\t\t\tword++;\n\t\t} else {\n\t\t\t/* one or more dmap words are fully contained\n\t\t\t * within the block range.  determine how many\n\t\t\t * words and allocate (set to 1) the bits of these\n\t\t\t * words.\n\t\t\t */\n\t\t\tnwords = rembits >> L2DBWORD;\n\t\t\tmemset(&dp->wmap[word], (int) ONES, nwords * 4);\n\n\t\t\t/* determine how many bits */\n\t\t\tnb = nwords << L2DBWORD;\n\t\t\tword += nwords;\n\t\t}\n\t}\n\n\t/* update the free count for this dmap */\n\tle32_add_cpu(&dp->nfree, -nblocks);\n\n\t/* reconstruct summary tree */\n\tdbInitDmapTree(dp);\n\n\tBMAP_LOCK(bmp);\n\n\t/* if this allocation group is completely free,\n\t * update the highest active allocation group number\n\t * if this allocation group is the new max.\n\t */\n\tagno = blkno >> bmp->db_agl2size;\n\tif (agno > bmp->db_maxag)\n\t\tbmp->db_maxag = agno;\n\n\t/* update the free count for the allocation group and map */\n\tbmp->db_agfree[agno] -= nblocks;\n\tbmp->db_nfree -= nblocks;\n\n\tBMAP_UNLOCK(bmp);\n\n\t/* if the root has not changed, done. */\n\tif (tp->stree[ROOT] == oldroot)\n\t\treturn (0);\n\n\t/* root changed. bubble the change up to the dmap control pages.\n\t * if the adjustment of the upper level control pages fails,\n\t * backout the bit allocation (thus making everything consistent).\n\t */\n\tif ((rc = dbAdjCtl(bmp, blkno, tp->stree[ROOT], 1, 0)))\n\t\tdbFreeBits(bmp, dp, blkno, nblocks);\n\n\treturn (rc);\n}"
        }
      },
      {
        "call_info": {
          "callee": "IAGTOLBLK",
          "args": [
            "iagno",
            "sbi->l2nbperpage"
          ],
          "line": 2518
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IWRITE_UNLOCK",
          "args": [
            "ipimap"
          ],
          "line": 2508
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "jfs_error",
          "args": [
            "imap->im_ipimap->i_sb",
            "\"ipimap->i_size is wrong\\n\""
          ],
          "line": 2494
        },
        "resolved": true,
        "details": {
          "function_name": "jfs_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/super.c",
          "lines": "95-111",
          "snippet": "void jfs_error(struct super_block *sb, const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tva_start(args, fmt);\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tpr_err(\"ERROR: (device %s): %pf: %pV\\n\",\n\t       sb->s_id, __builtin_return_address(0), &vaf);\n\n\tva_end(args);\n\n\tjfs_handle_error(sb);\n}",
          "includes": [
            "#include \"jfs_xattr.h\"",
            "#include \"jfs_debug.h\"",
            "#include \"jfs_acl.h\"",
            "#include \"jfs_imap.h\"",
            "#include \"jfs_dmap.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_inode.h\"",
            "#include \"jfs_filsys.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/blkdev.h>",
            "#include <linux/seq_file.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/crc32.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/mount.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/vfs.h>",
            "#include <linux/completion.h>",
            "#include <linux/parser.h>",
            "#include <linux/module.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_xattr.h\"\n#include \"jfs_debug.h\"\n#include \"jfs_acl.h\"\n#include \"jfs_imap.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_inode.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_incore.h\"\n#include <linux/blkdev.h>\n#include <linux/seq_file.h>\n#include <asm/uaccess.h>\n#include <linux/slab.h>\n#include <linux/crc32.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/posix_acl.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/mount.h>\n#include <linux/quotaops.h>\n#include <linux/vfs.h>\n#include <linux/completion.h>\n#include <linux/parser.h>\n#include <linux/module.h>\n#include <linux/fs.h>\n\nvoid jfs_error(struct super_block *sb, const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tva_start(args, fmt);\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tpr_err(\"ERROR: (device %s): %pf: %pV\\n\",\n\t       sb->s_id, __builtin_return_address(0), &vaf);\n\n\tva_end(args);\n\n\tjfs_handle_error(sb);\n}"
        }
      },
      {
        "call_info": {
          "callee": "IAGFREE_UNLOCK",
          "args": [
            "imap"
          ],
          "line": 2493
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IWRITE_UNLOCK",
          "args": [
            "ipimap"
          ],
          "line": 2492
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IWRITE_LOCK",
          "args": [
            "ipimap",
            "RDWRLOCK_IMAP"
          ],
          "line": 2489
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IAGTOLBLK",
          "args": [
            "iagno",
            "sbi->l2nbperpage"
          ],
          "line": 2482
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IAGFREE_LOCK",
          "args": [
            "imap"
          ],
          "line": 2472
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "JFS_SBI",
          "args": [
            "sb"
          ],
          "line": 2469
        },
        "resolved": true,
        "details": {
          "function_name": "JFS_SBI",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_incore.h",
          "lines": "217-220",
          "snippet": "static inline struct jfs_sb_info *JFS_SBI(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"jfs_dtree.h\"",
            "#include \"jfs_xtree.h\"",
            "#include \"jfs_types.h\"",
            "#include <linux/bitops.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_dtree.h\"\n#include \"jfs_xtree.h\"\n#include \"jfs_types.h\"\n#include <linux/bitops.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mutex.h>\n\nstatic inline struct jfs_sb_info *JFS_SBI(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_imap.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_dinode.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_inode.h\"\n#include \"jfs_incore.h\"\n#include <linux/slab.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n\nstatic int diAllocAG(struct inomap *, int, bool, struct inode *);\nstatic int diAllocAny(struct inomap *, int, bool, struct inode *);\nstatic int diAllocBit(struct inomap *, struct iag *, int);\nstatic int diAllocExt(struct inomap *, int, struct inode *);\nstatic int diAllocIno(struct inomap *, int, struct inode *);\nstatic int diNewExt(struct inomap *, struct iag *, int);\nstatic int diNewIAG(struct inomap *, int *, int, struct metapage **);\nstatic void duplicateIXtree(struct super_block *, s64, int, s64 *);\nstatic int diIAGRead(struct inomap * imap, int, struct metapage **);\nstatic int copy_from_dinode(struct dinode *, struct inode *);\nstatic void copy_to_dinode(struct dinode *, struct inode *);\n\nstatic int\ndiNewIAG(struct inomap * imap, int *iagnop, int agno, struct metapage ** mpp)\n{\n\tint rc;\n\tint iagno, i, xlen;\n\tstruct inode *ipimap;\n\tstruct super_block *sb;\n\tstruct jfs_sb_info *sbi;\n\tstruct metapage *mp;\n\tstruct iag *iagp;\n\ts64 xaddr = 0;\n\ts64 blkno;\n\ttid_t tid;\n\tstruct inode *iplist[1];\n\n\t/* pick up pointers to the inode map and mount inodes */\n\tipimap = imap->im_ipimap;\n\tsb = ipimap->i_sb;\n\tsbi = JFS_SBI(sb);\n\n\t/* acquire the free iag lock */\n\tIAGFREE_LOCK(imap);\n\n\t/* if there are any iags on the inode map free iag list,\n\t * allocate the iag from the head of the list.\n\t */\n\tif (imap->im_freeiag >= 0) {\n\t\t/* pick up the iag number at the head of the list */\n\t\tiagno = imap->im_freeiag;\n\n\t\t/* determine the logical block number of the iag */\n\t\tblkno = IAGTOLBLK(iagno, sbi->l2nbperpage);\n\t} else {\n\t\t/* no free iags. the inode map will have to be extented\n\t\t * to include a new iag.\n\t\t */\n\n\t\t/* acquire inode map lock */\n\t\tIWRITE_LOCK(ipimap, RDWRLOCK_IMAP);\n\n\t\tif (ipimap->i_size >> L2PSIZE != imap->im_nextiag + 1) {\n\t\t\tIWRITE_UNLOCK(ipimap);\n\t\t\tIAGFREE_UNLOCK(imap);\n\t\t\tjfs_error(imap->im_ipimap->i_sb,\n\t\t\t\t  \"ipimap->i_size is wrong\\n\");\n\t\t\treturn -EIO;\n\t\t}\n\n\n\t\t/* get the next available iag number */\n\t\tiagno = imap->im_nextiag;\n\n\t\t/* make sure that we have not exceeded the maximum inode\n\t\t * number limit.\n\t\t */\n\t\tif (iagno > (MAXIAGS - 1)) {\n\t\t\t/* release the inode map lock */\n\t\t\tIWRITE_UNLOCK(ipimap);\n\n\t\t\trc = -ENOSPC;\n\t\t\tgoto out;\n\t\t}\n\n\t\t/*\n\t\t * synchronously append new iag page.\n\t\t */\n\t\t/* determine the logical address of iag page to append */\n\t\tblkno = IAGTOLBLK(iagno, sbi->l2nbperpage);\n\n\t\t/* Allocate extent for new iag page */\n\t\txlen = sbi->nbperpage;\n\t\tif ((rc = dbAlloc(ipimap, 0, (s64) xlen, &xaddr))) {\n\t\t\t/* release the inode map lock */\n\t\t\tIWRITE_UNLOCK(ipimap);\n\n\t\t\tgoto out;\n\t\t}\n\n\t\t/*\n\t\t * start transaction of update of the inode map\n\t\t * addressing structure pointing to the new iag page;\n\t\t */\n\t\ttid = txBegin(sb, COMMIT_FORCE);\n\t\tmutex_lock(&JFS_IP(ipimap)->commit_mutex);\n\n\t\t/* update the inode map addressing structure to point to it */\n\t\tif ((rc =\n\t\t     xtInsert(tid, ipimap, 0, blkno, xlen, &xaddr, 0))) {\n\t\t\ttxEnd(tid);\n\t\t\tmutex_unlock(&JFS_IP(ipimap)->commit_mutex);\n\t\t\t/* Free the blocks allocated for the iag since it was\n\t\t\t * not successfully added to the inode map\n\t\t\t */\n\t\t\tdbFree(ipimap, xaddr, (s64) xlen);\n\n\t\t\t/* release the inode map lock */\n\t\t\tIWRITE_UNLOCK(ipimap);\n\n\t\t\tgoto out;\n\t\t}\n\n\t\t/* update the inode map's inode to reflect the extension */\n\t\tipimap->i_size += PSIZE;\n\t\tinode_add_bytes(ipimap, PSIZE);\n\n\t\t/* assign a buffer for the page */\n\t\tmp = get_metapage(ipimap, blkno, PSIZE, 0);\n\t\tif (!mp) {\n\t\t\t/*\n\t\t\t * This is very unlikely since we just created the\n\t\t\t * extent, but let's try to handle it correctly\n\t\t\t */\n\t\t\txtTruncate(tid, ipimap, ipimap->i_size - PSIZE,\n\t\t\t\t   COMMIT_PWMAP);\n\n\t\t\ttxAbort(tid, 0);\n\t\t\ttxEnd(tid);\n\t\t\tmutex_unlock(&JFS_IP(ipimap)->commit_mutex);\n\n\t\t\t/* release the inode map lock */\n\t\t\tIWRITE_UNLOCK(ipimap);\n\n\t\t\trc = -EIO;\n\t\t\tgoto out;\n\t\t}\n\t\tiagp = (struct iag *) mp->data;\n\n\t\t/* init the iag */\n\t\tmemset(iagp, 0, sizeof(struct iag));\n\t\tiagp->iagnum = cpu_to_le32(iagno);\n\t\tiagp->inofreefwd = iagp->inofreeback = cpu_to_le32(-1);\n\t\tiagp->extfreefwd = iagp->extfreeback = cpu_to_le32(-1);\n\t\tiagp->iagfree = cpu_to_le32(-1);\n\t\tiagp->nfreeinos = 0;\n\t\tiagp->nfreeexts = cpu_to_le32(EXTSPERIAG);\n\n\t\t/* initialize the free inode summary map (free extent\n\t\t * summary map initialization handled by bzero).\n\t\t */\n\t\tfor (i = 0; i < SMAPSZ; i++)\n\t\t\tiagp->inosmap[i] = cpu_to_le32(ONES);\n\n\t\t/*\n\t\t * Write and sync the metapage\n\t\t */\n\t\tflush_metapage(mp);\n\n\t\t/*\n\t\t * txCommit(COMMIT_FORCE) will synchronously write address\n\t\t * index pages and inode after commit in careful update order\n\t\t * of address index pages (right to left, bottom up);\n\t\t */\n\t\tiplist[0] = ipimap;\n\t\trc = txCommit(tid, 1, &iplist[0], COMMIT_FORCE);\n\n\t\ttxEnd(tid);\n\t\tmutex_unlock(&JFS_IP(ipimap)->commit_mutex);\n\n\t\tduplicateIXtree(sb, blkno, xlen, &xaddr);\n\n\t\t/* update the next available iag number */\n\t\timap->im_nextiag += 1;\n\n\t\t/* Add the iag to the iag free list so we don't lose the iag\n\t\t * if a failure happens now.\n\t\t */\n\t\timap->im_freeiag = iagno;\n\n\t\t/* Until we have logredo working, we want the imap inode &\n\t\t * control page to be up to date.\n\t\t */\n\t\tdiSync(ipimap);\n\n\t\t/* release the inode map lock */\n\t\tIWRITE_UNLOCK(ipimap);\n\t}\n\n\t/* obtain read lock on map */\n\tIREAD_LOCK(ipimap, RDWRLOCK_IMAP);\n\n\t/* read the iag */\n\tif ((rc = diIAGRead(imap, iagno, &mp))) {\n\t\tIREAD_UNLOCK(ipimap);\n\t\trc = -EIO;\n\t\tgoto out;\n\t}\n\tiagp = (struct iag *) mp->data;\n\n\t/* remove the iag from the iag free list */\n\timap->im_freeiag = le32_to_cpu(iagp->iagfree);\n\tiagp->iagfree = cpu_to_le32(-1);\n\n\t/* set the return iag number and buffer pointer */\n\t*iagnop = iagno;\n\t*mpp = mp;\n\n      out:\n\t/* release the iag free lock */\n\tIAGFREE_UNLOCK(imap);\n\n\treturn (rc);\n}"
  },
  {
    "function_name": "diNewExt",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_imap.c",
    "lines": "2170-2409",
    "snippet": "static int diNewExt(struct inomap * imap, struct iag * iagp, int extno)\n{\n\tint agno, iagno, fwd, back, freei = 0, sword, rc;\n\tstruct iag *aiagp = NULL, *biagp = NULL, *ciagp = NULL;\n\tstruct metapage *amp, *bmp, *cmp, *dmp;\n\tstruct inode *ipimap;\n\ts64 blkno, hint;\n\tint i, j;\n\tu32 mask;\n\tino_t ino;\n\tstruct dinode *dp;\n\tstruct jfs_sb_info *sbi;\n\n\t/* better have free extents.\n\t */\n\tif (!iagp->nfreeexts) {\n\t\tjfs_error(imap->im_ipimap->i_sb, \"no free extents\\n\");\n\t\treturn -EIO;\n\t}\n\n\t/* get the inode map inode.\n\t */\n\tipimap = imap->im_ipimap;\n\tsbi = JFS_SBI(ipimap->i_sb);\n\n\tamp = bmp = cmp = NULL;\n\n\t/* get the ag and iag numbers for this iag.\n\t */\n\tagno = BLKTOAG(le64_to_cpu(iagp->agstart), sbi);\n\tiagno = le32_to_cpu(iagp->iagnum);\n\n\t/* check if this is the last free extent within the\n\t * iag.  if so, the iag must be removed from the ag\n\t * free extent list, so get the iags preceding and\n\t * following the iag on this list.\n\t */\n\tif (iagp->nfreeexts == cpu_to_le32(1)) {\n\t\tif ((fwd = le32_to_cpu(iagp->extfreefwd)) >= 0) {\n\t\t\tif ((rc = diIAGRead(imap, fwd, &amp)))\n\t\t\t\treturn (rc);\n\t\t\taiagp = (struct iag *) amp->data;\n\t\t}\n\n\t\tif ((back = le32_to_cpu(iagp->extfreeback)) >= 0) {\n\t\t\tif ((rc = diIAGRead(imap, back, &bmp)))\n\t\t\t\tgoto error_out;\n\t\t\tbiagp = (struct iag *) bmp->data;\n\t\t}\n\t} else {\n\t\t/* the iag has free extents.  if all extents are free\n\t\t * (as is the case for a newly allocated iag), the iag\n\t\t * must be added to the ag free extent list, so get\n\t\t * the iag at the head of the list in preparation for\n\t\t * adding this iag to this list.\n\t\t */\n\t\tfwd = back = -1;\n\t\tif (iagp->nfreeexts == cpu_to_le32(EXTSPERIAG)) {\n\t\t\tif ((fwd = imap->im_agctl[agno].extfree) >= 0) {\n\t\t\t\tif ((rc = diIAGRead(imap, fwd, &amp)))\n\t\t\t\t\tgoto error_out;\n\t\t\t\taiagp = (struct iag *) amp->data;\n\t\t\t}\n\t\t}\n\t}\n\n\t/* check if the iag has no free inodes.  if so, the iag\n\t * will have to be added to the ag free inode list, so get\n\t * the iag at the head of the list in preparation for\n\t * adding this iag to this list.  in doing this, we must\n\t * check if we already have the iag at the head of\n\t * the list in hand.\n\t */\n\tif (iagp->nfreeinos == 0) {\n\t\tfreei = imap->im_agctl[agno].inofree;\n\n\t\tif (freei >= 0) {\n\t\t\tif (freei == fwd) {\n\t\t\t\tciagp = aiagp;\n\t\t\t} else if (freei == back) {\n\t\t\t\tciagp = biagp;\n\t\t\t} else {\n\t\t\t\tif ((rc = diIAGRead(imap, freei, &cmp)))\n\t\t\t\t\tgoto error_out;\n\t\t\t\tciagp = (struct iag *) cmp->data;\n\t\t\t}\n\t\t\tif (ciagp == NULL) {\n\t\t\t\tjfs_error(imap->im_ipimap->i_sb,\n\t\t\t\t\t  \"ciagp == NULL\\n\");\n\t\t\t\trc = -EIO;\n\t\t\t\tgoto error_out;\n\t\t\t}\n\t\t}\n\t}\n\n\t/* allocate disk space for the inode extent.\n\t */\n\tif ((extno == 0) || (addressPXD(&iagp->inoext[extno - 1]) == 0))\n\t\thint = ((s64) agno << sbi->bmap->db_agl2size) - 1;\n\telse\n\t\thint = addressPXD(&iagp->inoext[extno - 1]) +\n\t\t    lengthPXD(&iagp->inoext[extno - 1]) - 1;\n\n\tif ((rc = dbAlloc(ipimap, hint, (s64) imap->im_nbperiext, &blkno)))\n\t\tgoto error_out;\n\n\t/* compute the inode number of the first inode within the\n\t * extent.\n\t */\n\tino = (iagno << L2INOSPERIAG) + (extno << L2INOSPEREXT);\n\n\t/* initialize the inodes within the newly allocated extent a\n\t * page at a time.\n\t */\n\tfor (i = 0; i < imap->im_nbperiext; i += sbi->nbperpage) {\n\t\t/* get a buffer for this page of disk inodes.\n\t\t */\n\t\tdmp = get_metapage(ipimap, blkno + i, PSIZE, 1);\n\t\tif (dmp == NULL) {\n\t\t\trc = -EIO;\n\t\t\tgoto error_out;\n\t\t}\n\t\tdp = (struct dinode *) dmp->data;\n\n\t\t/* initialize the inode number, mode, link count and\n\t\t * inode extent address.\n\t\t */\n\t\tfor (j = 0; j < INOSPERPAGE; j++, dp++, ino++) {\n\t\t\tdp->di_inostamp = cpu_to_le32(sbi->inostamp);\n\t\t\tdp->di_number = cpu_to_le32(ino);\n\t\t\tdp->di_fileset = cpu_to_le32(FILESYSTEM_I);\n\t\t\tdp->di_mode = 0;\n\t\t\tdp->di_nlink = 0;\n\t\t\tPXDaddress(&(dp->di_ixpxd), blkno);\n\t\t\tPXDlength(&(dp->di_ixpxd), imap->im_nbperiext);\n\t\t}\n\t\twrite_metapage(dmp);\n\t}\n\n\t/* if this is the last free extent within the iag, remove the\n\t * iag from the ag free extent list.\n\t */\n\tif (iagp->nfreeexts == cpu_to_le32(1)) {\n\t\tif (fwd >= 0)\n\t\t\taiagp->extfreeback = iagp->extfreeback;\n\n\t\tif (back >= 0)\n\t\t\tbiagp->extfreefwd = iagp->extfreefwd;\n\t\telse\n\t\t\timap->im_agctl[agno].extfree =\n\t\t\t    le32_to_cpu(iagp->extfreefwd);\n\n\t\tiagp->extfreefwd = iagp->extfreeback = cpu_to_le32(-1);\n\t} else {\n\t\t/* if the iag has all free extents (newly allocated iag),\n\t\t * add the iag to the ag free extent list.\n\t\t */\n\t\tif (iagp->nfreeexts == cpu_to_le32(EXTSPERIAG)) {\n\t\t\tif (fwd >= 0)\n\t\t\t\taiagp->extfreeback = cpu_to_le32(iagno);\n\n\t\t\tiagp->extfreefwd = cpu_to_le32(fwd);\n\t\t\tiagp->extfreeback = cpu_to_le32(-1);\n\t\t\timap->im_agctl[agno].extfree = iagno;\n\t\t}\n\t}\n\n\t/* if the iag has no free inodes, add the iag to the\n\t * ag free inode list.\n\t */\n\tif (iagp->nfreeinos == 0) {\n\t\tif (freei >= 0)\n\t\t\tciagp->inofreeback = cpu_to_le32(iagno);\n\n\t\tiagp->inofreefwd =\n\t\t    cpu_to_le32(imap->im_agctl[agno].inofree);\n\t\tiagp->inofreeback = cpu_to_le32(-1);\n\t\timap->im_agctl[agno].inofree = iagno;\n\t}\n\n\t/* initialize the extent descriptor of the extent. */\n\tPXDlength(&iagp->inoext[extno], imap->im_nbperiext);\n\tPXDaddress(&iagp->inoext[extno], blkno);\n\n\t/* initialize the working and persistent map of the extent.\n\t * the working map will be initialized such that\n\t * it indicates the first inode of the extent is allocated.\n\t */\n\tiagp->wmap[extno] = cpu_to_le32(HIGHORDER);\n\tiagp->pmap[extno] = 0;\n\n\t/* update the free inode and free extent summary maps\n\t * for the extent to indicate the extent has free inodes\n\t * and no longer represents a free extent.\n\t */\n\tsword = extno >> L2EXTSPERSUM;\n\tmask = HIGHORDER >> (extno & (EXTSPERSUM - 1));\n\tiagp->extsmap[sword] |= cpu_to_le32(mask);\n\tiagp->inosmap[sword] &= cpu_to_le32(~mask);\n\n\t/* update the free inode and free extent counts for the\n\t * iag.\n\t */\n\tle32_add_cpu(&iagp->nfreeinos, (INOSPEREXT - 1));\n\tle32_add_cpu(&iagp->nfreeexts, -1);\n\n\t/* update the free and backed inode counts for the ag.\n\t */\n\timap->im_agctl[agno].numfree += (INOSPEREXT - 1);\n\timap->im_agctl[agno].numinos += INOSPEREXT;\n\n\t/* update the free and backed inode counts for the inode map.\n\t */\n\tatomic_add(INOSPEREXT - 1, &imap->im_numfree);\n\tatomic_add(INOSPEREXT, &imap->im_numinos);\n\n\t/* write the iags.\n\t */\n\tif (amp)\n\t\twrite_metapage(amp);\n\tif (bmp)\n\t\twrite_metapage(bmp);\n\tif (cmp)\n\t\twrite_metapage(cmp);\n\n\treturn (0);\n\n      error_out:\n\n\t/* release the iags.\n\t */\n\tif (amp)\n\t\trelease_metapage(amp);\n\tif (bmp)\n\t\trelease_metapage(bmp);\n\tif (cmp)\n\t\trelease_metapage(cmp);\n\n\treturn (rc);\n}",
    "includes": [
      "#include \"jfs_debug.h\"",
      "#include \"jfs_superblock.h\"",
      "#include \"jfs_metapage.h\"",
      "#include \"jfs_imap.h\"",
      "#include \"jfs_dmap.h\"",
      "#include \"jfs_dinode.h\"",
      "#include \"jfs_filsys.h\"",
      "#include \"jfs_inode.h\"",
      "#include \"jfs_incore.h\"",
      "#include <linux/slab.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int diAllocAG(struct inomap *, int, bool, struct inode *);",
      "static int diAllocAny(struct inomap *, int, bool, struct inode *);",
      "static int diAllocBit(struct inomap *, struct iag *, int);",
      "static int diAllocExt(struct inomap *, int, struct inode *);",
      "static int diAllocIno(struct inomap *, int, struct inode *);",
      "static int diFindFree(u32, int);",
      "static int diNewExt(struct inomap *, struct iag *, int);",
      "static int diNewIAG(struct inomap *, int *, int, struct metapage **);",
      "static void duplicateIXtree(struct super_block *, s64, int, s64 *);",
      "static int diIAGRead(struct inomap * imap, int, struct metapage **);",
      "static int copy_from_dinode(struct dinode *, struct inode *);",
      "static void copy_to_dinode(struct dinode *, struct inode *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "release_metapage",
          "args": [
            "cmp"
          ],
          "line": 2406
        },
        "resolved": true,
        "details": {
          "function_name": "release_metapage",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_metapage.c",
          "lines": "743-775",
          "snippet": "void release_metapage(struct metapage * mp)\n{\n\tstruct page *page = mp->page;\n\tjfs_info(\"release_metapage: mp = 0x%p, flag = 0x%lx\", mp, mp->flag);\n\n\tBUG_ON(!page);\n\n\tlock_page(page);\n\tunlock_metapage(mp);\n\n\tassert(mp->count);\n\tif (--mp->count || mp->nohomeok) {\n\t\tunlock_page(page);\n\t\tpage_cache_release(page);\n\t\treturn;\n\t}\n\n\tif (test_bit(META_dirty, &mp->flag)) {\n\t\tset_page_dirty(page);\n\t\tif (test_bit(META_sync, &mp->flag)) {\n\t\t\tclear_bit(META_sync, &mp->flag);\n\t\t\twrite_one_page(page, 1);\n\t\t\tlock_page(page); /* write_one_page unlocks the page */\n\t\t}\n\t} else if (mp->lsn)\t/* discard_metapage doesn't remove it */\n\t\tremove_from_logsync(mp);\n\n\t/* Try to keep metapages from using up too much memory */\n\tdrop_metapage(page, mp);\n\n\tunlock_page(page);\n\tpage_cache_release(page);\n}",
          "includes": [
            "#include \"jfs_debug.h\"",
            "#include \"jfs_txnmgr.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_filsys.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/mempool.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/bio.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_txnmgr.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_incore.h\"\n#include <linux/seq_file.h>\n#include <linux/mempool.h>\n#include <linux/buffer_head.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n\nvoid release_metapage(struct metapage * mp)\n{\n\tstruct page *page = mp->page;\n\tjfs_info(\"release_metapage: mp = 0x%p, flag = 0x%lx\", mp, mp->flag);\n\n\tBUG_ON(!page);\n\n\tlock_page(page);\n\tunlock_metapage(mp);\n\n\tassert(mp->count);\n\tif (--mp->count || mp->nohomeok) {\n\t\tunlock_page(page);\n\t\tpage_cache_release(page);\n\t\treturn;\n\t}\n\n\tif (test_bit(META_dirty, &mp->flag)) {\n\t\tset_page_dirty(page);\n\t\tif (test_bit(META_sync, &mp->flag)) {\n\t\t\tclear_bit(META_sync, &mp->flag);\n\t\t\twrite_one_page(page, 1);\n\t\t\tlock_page(page); /* write_one_page unlocks the page */\n\t\t}\n\t} else if (mp->lsn)\t/* discard_metapage doesn't remove it */\n\t\tremove_from_logsync(mp);\n\n\t/* Try to keep metapages from using up too much memory */\n\tdrop_metapage(page, mp);\n\n\tunlock_page(page);\n\tpage_cache_release(page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "write_metapage",
          "args": [
            "cmp"
          ],
          "line": 2393
        },
        "resolved": true,
        "details": {
          "function_name": "write_metapage",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_metapage.h",
          "lines": "85-89",
          "snippet": "static inline void write_metapage(struct metapage *mp)\n{\n\tset_bit(META_dirty, &mp->flag);\n\trelease_metapage(mp);\n}",
          "includes": [
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [
            "#define META_dirty\t2"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/pagemap.h>\n\n#define META_dirty\t2\n\nstatic inline void write_metapage(struct metapage *mp)\n{\n\tset_bit(META_dirty, &mp->flag);\n\trelease_metapage(mp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_add",
          "args": [
            "INOSPEREXT",
            "&imap->im_numinos"
          ],
          "line": 2384
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_add",
          "args": [
            "INOSPEREXT - 1",
            "&imap->im_numfree"
          ],
          "line": 2383
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le32_add_cpu",
          "args": [
            "&iagp->nfreeexts",
            "-1"
          ],
          "line": 2374
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le32_add_cpu",
          "args": [
            "&iagp->nfreeinos",
            "(INOSPEREXT - 1)"
          ],
          "line": 2373
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "~mask"
          ],
          "line": 2368
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "mask"
          ],
          "line": 2367
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "HIGHORDER"
          ],
          "line": 2358
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PXDaddress",
          "args": [
            "&iagp->inoext[extno]",
            "blkno"
          ],
          "line": 2352
        },
        "resolved": true,
        "details": {
          "function_name": "PXDaddress",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_types.h",
          "lines": "78-83",
          "snippet": "static inline void PXDaddress(pxd_t *pxd, __u64 addr)\n{\n\tpxd->len_addr = (pxd->len_addr & cpu_to_le32(0xffffff)) |\n\t\t\tcpu_to_le32((addr >> 32)<<24);\n\tpxd->addr2 = cpu_to_le32(addr & 0xffffffff);\n}",
          "includes": [
            "#include <linux/nls.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/nls.h>\n#include <linux/types.h>\n\nstatic inline void PXDaddress(pxd_t *pxd, __u64 addr)\n{\n\tpxd->len_addr = (pxd->len_addr & cpu_to_le32(0xffffff)) |\n\t\t\tcpu_to_le32((addr >> 32)<<24);\n\tpxd->addr2 = cpu_to_le32(addr & 0xffffffff);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PXDlength",
          "args": [
            "&iagp->inoext[extno]",
            "imap->im_nbperiext"
          ],
          "line": 2351
        },
        "resolved": true,
        "details": {
          "function_name": "PXDlength",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_types.h",
          "lines": "72-76",
          "snippet": "static inline void PXDlength(pxd_t *pxd, __u32 len)\n{\n\tpxd->len_addr = (pxd->len_addr & cpu_to_le32(~0xffffff)) |\n\t\t\tcpu_to_le32(len & 0xffffff);\n}",
          "includes": [
            "#include <linux/nls.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/nls.h>\n#include <linux/types.h>\n\nstatic inline void PXDlength(pxd_t *pxd, __u32 len)\n{\n\tpxd->len_addr = (pxd->len_addr & cpu_to_le32(~0xffffff)) |\n\t\t\tcpu_to_le32(len & 0xffffff);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "-1"
          ],
          "line": 2346
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "imap->im_agctl[agno].inofree"
          ],
          "line": 2345
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "iagno"
          ],
          "line": 2342
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "-1"
          ],
          "line": 2332
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "fwd"
          ],
          "line": 2331
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "iagno"
          ],
          "line": 2329
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "EXTSPERIAG"
          ],
          "line": 2327
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "-1"
          ],
          "line": 2322
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "iagp->extfreefwd"
          ],
          "line": 2320
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "1"
          ],
          "line": 2312
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "FILESYSTEM_I"
          ],
          "line": 2300
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "ino"
          ],
          "line": 2299
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "sbi->inostamp"
          ],
          "line": 2298
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_metapage",
          "args": [
            "ipimap",
            "blkno + i",
            "PSIZE",
            "1"
          ],
          "line": 2287
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dbAlloc",
          "args": [
            "ipimap",
            "hint",
            "(s64) imap->im_nbperiext",
            "&blkno"
          ],
          "line": 2273
        },
        "resolved": true,
        "details": {
          "function_name": "dbAllocDmapBU",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_dmap.c",
          "lines": "3263-3364",
          "snippet": "static int dbAllocDmapBU(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t\t int nblocks)\n{\n\tint rc;\n\tint dbitno, word, rembits, nb, nwords, wbitno, agno;\n\ts8 oldroot;\n\tstruct dmaptree *tp = (struct dmaptree *) & dp->tree;\n\n\t/* save the current value of the root (i.e. maximum free string)\n\t * of the dmap tree.\n\t */\n\toldroot = tp->stree[ROOT];\n\n\t/* determine the bit number and word within the dmap of the\n\t * starting block.\n\t */\n\tdbitno = blkno & (BPERDMAP - 1);\n\tword = dbitno >> L2DBWORD;\n\n\t/* block range better be within the dmap */\n\tassert(dbitno + nblocks <= BPERDMAP);\n\n\t/* allocate the bits of the dmap's words corresponding to the block\n\t * range. not all bits of the first and last words may be contained\n\t * within the block range.  if this is the case, we'll work against\n\t * those words (i.e. partial first and/or last) on an individual basis\n\t * (a single pass), allocating the bits of interest by hand and\n\t * updating the leaf corresponding to the dmap word. a single pass\n\t * will be used for all dmap words fully contained within the\n\t * specified range.  within this pass, the bits of all fully contained\n\t * dmap words will be marked as free in a single shot and the leaves\n\t * will be updated. a single leaf may describe the free space of\n\t * multiple dmap words, so we may update only a subset of the actual\n\t * leaves corresponding to the dmap words of the block range.\n\t */\n\tfor (rembits = nblocks; rembits > 0; rembits -= nb, dbitno += nb) {\n\t\t/* determine the bit number within the word and\n\t\t * the number of bits within the word.\n\t\t */\n\t\twbitno = dbitno & (DBWORD - 1);\n\t\tnb = min(rembits, DBWORD - wbitno);\n\n\t\t/* check if only part of a word is to be allocated.\n\t\t */\n\t\tif (nb < DBWORD) {\n\t\t\t/* allocate (set to 1) the appropriate bits within\n\t\t\t * this dmap word.\n\t\t\t */\n\t\t\tdp->wmap[word] |= cpu_to_le32(ONES << (DBWORD - nb)\n\t\t\t\t\t\t      >> wbitno);\n\n\t\t\tword++;\n\t\t} else {\n\t\t\t/* one or more dmap words are fully contained\n\t\t\t * within the block range.  determine how many\n\t\t\t * words and allocate (set to 1) the bits of these\n\t\t\t * words.\n\t\t\t */\n\t\t\tnwords = rembits >> L2DBWORD;\n\t\t\tmemset(&dp->wmap[word], (int) ONES, nwords * 4);\n\n\t\t\t/* determine how many bits */\n\t\t\tnb = nwords << L2DBWORD;\n\t\t\tword += nwords;\n\t\t}\n\t}\n\n\t/* update the free count for this dmap */\n\tle32_add_cpu(&dp->nfree, -nblocks);\n\n\t/* reconstruct summary tree */\n\tdbInitDmapTree(dp);\n\n\tBMAP_LOCK(bmp);\n\n\t/* if this allocation group is completely free,\n\t * update the highest active allocation group number\n\t * if this allocation group is the new max.\n\t */\n\tagno = blkno >> bmp->db_agl2size;\n\tif (agno > bmp->db_maxag)\n\t\tbmp->db_maxag = agno;\n\n\t/* update the free count for the allocation group and map */\n\tbmp->db_agfree[agno] -= nblocks;\n\tbmp->db_nfree -= nblocks;\n\n\tBMAP_UNLOCK(bmp);\n\n\t/* if the root has not changed, done. */\n\tif (tp->stree[ROOT] == oldroot)\n\t\treturn (0);\n\n\t/* root changed. bubble the change up to the dmap control pages.\n\t * if the adjustment of the upper level control pages fails,\n\t * backout the bit allocation (thus making everything consistent).\n\t */\n\tif ((rc = dbAdjCtl(bmp, blkno, tp->stree[ROOT], 1, 0)))\n\t\tdbFreeBits(bmp, dp, blkno, nblocks);\n\n\treturn (rc);\n}",
          "includes": [
            "#include \"jfs_discard.h\"",
            "#include \"jfs_debug.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_lock.h\"",
            "#include \"jfs_imap.h\"",
            "#include \"jfs_dmap.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dbAllocBits(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t\tint nblocks);",
            "static int dbAdjCtl(struct bmap * bmp, s64 blkno, int newval, int alloc,\n\t\t    int level);",
            "static int dbAllocNext(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t       int nblocks);",
            "static int dbAllocDmap(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t       int nblocks);",
            "static int dbFindCtl(struct bmap * bmp, int l2nb, int level, s64 * blkno);",
            "static int dbFreeBits(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t      int nblocks);",
            "static int dbFreeDmap(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t      int nblocks);",
            "static int blkstol2(s64 nb);",
            "static int cntlz(u32 value);",
            "static int cnttz(u32 word);",
            "static int dbAllocDmapBU(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t\t int nblocks);",
            "static int dbInitDmap(struct dmap * dp, s64 blkno, int nblocks);",
            "static int dbInitDmapTree(struct dmap * dp);",
            "static int dbInitDmapCtl(struct dmapctl * dcp, int level, int i);",
            "static int dbGetL2AGSize(s64 nblocks);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_discard.h\"\n#include \"jfs_debug.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_lock.h\"\n#include \"jfs_imap.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_incore.h\"\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic void dbAllocBits(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t\tint nblocks);\nstatic int dbAdjCtl(struct bmap * bmp, s64 blkno, int newval, int alloc,\n\t\t    int level);\nstatic int dbAllocNext(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t       int nblocks);\nstatic int dbAllocDmap(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t       int nblocks);\nstatic int dbFindCtl(struct bmap * bmp, int l2nb, int level, s64 * blkno);\nstatic int dbFreeBits(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t      int nblocks);\nstatic int dbFreeDmap(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t      int nblocks);\nstatic int blkstol2(s64 nb);\nstatic int cntlz(u32 value);\nstatic int cnttz(u32 word);\nstatic int dbAllocDmapBU(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t\t int nblocks);\nstatic int dbInitDmap(struct dmap * dp, s64 blkno, int nblocks);\nstatic int dbInitDmapTree(struct dmap * dp);\nstatic int dbInitDmapCtl(struct dmapctl * dcp, int level, int i);\nstatic int dbGetL2AGSize(s64 nblocks);\n\nstatic int dbAllocDmapBU(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t\t int nblocks)\n{\n\tint rc;\n\tint dbitno, word, rembits, nb, nwords, wbitno, agno;\n\ts8 oldroot;\n\tstruct dmaptree *tp = (struct dmaptree *) & dp->tree;\n\n\t/* save the current value of the root (i.e. maximum free string)\n\t * of the dmap tree.\n\t */\n\toldroot = tp->stree[ROOT];\n\n\t/* determine the bit number and word within the dmap of the\n\t * starting block.\n\t */\n\tdbitno = blkno & (BPERDMAP - 1);\n\tword = dbitno >> L2DBWORD;\n\n\t/* block range better be within the dmap */\n\tassert(dbitno + nblocks <= BPERDMAP);\n\n\t/* allocate the bits of the dmap's words corresponding to the block\n\t * range. not all bits of the first and last words may be contained\n\t * within the block range.  if this is the case, we'll work against\n\t * those words (i.e. partial first and/or last) on an individual basis\n\t * (a single pass), allocating the bits of interest by hand and\n\t * updating the leaf corresponding to the dmap word. a single pass\n\t * will be used for all dmap words fully contained within the\n\t * specified range.  within this pass, the bits of all fully contained\n\t * dmap words will be marked as free in a single shot and the leaves\n\t * will be updated. a single leaf may describe the free space of\n\t * multiple dmap words, so we may update only a subset of the actual\n\t * leaves corresponding to the dmap words of the block range.\n\t */\n\tfor (rembits = nblocks; rembits > 0; rembits -= nb, dbitno += nb) {\n\t\t/* determine the bit number within the word and\n\t\t * the number of bits within the word.\n\t\t */\n\t\twbitno = dbitno & (DBWORD - 1);\n\t\tnb = min(rembits, DBWORD - wbitno);\n\n\t\t/* check if only part of a word is to be allocated.\n\t\t */\n\t\tif (nb < DBWORD) {\n\t\t\t/* allocate (set to 1) the appropriate bits within\n\t\t\t * this dmap word.\n\t\t\t */\n\t\t\tdp->wmap[word] |= cpu_to_le32(ONES << (DBWORD - nb)\n\t\t\t\t\t\t      >> wbitno);\n\n\t\t\tword++;\n\t\t} else {\n\t\t\t/* one or more dmap words are fully contained\n\t\t\t * within the block range.  determine how many\n\t\t\t * words and allocate (set to 1) the bits of these\n\t\t\t * words.\n\t\t\t */\n\t\t\tnwords = rembits >> L2DBWORD;\n\t\t\tmemset(&dp->wmap[word], (int) ONES, nwords * 4);\n\n\t\t\t/* determine how many bits */\n\t\t\tnb = nwords << L2DBWORD;\n\t\t\tword += nwords;\n\t\t}\n\t}\n\n\t/* update the free count for this dmap */\n\tle32_add_cpu(&dp->nfree, -nblocks);\n\n\t/* reconstruct summary tree */\n\tdbInitDmapTree(dp);\n\n\tBMAP_LOCK(bmp);\n\n\t/* if this allocation group is completely free,\n\t * update the highest active allocation group number\n\t * if this allocation group is the new max.\n\t */\n\tagno = blkno >> bmp->db_agl2size;\n\tif (agno > bmp->db_maxag)\n\t\tbmp->db_maxag = agno;\n\n\t/* update the free count for the allocation group and map */\n\tbmp->db_agfree[agno] -= nblocks;\n\tbmp->db_nfree -= nblocks;\n\n\tBMAP_UNLOCK(bmp);\n\n\t/* if the root has not changed, done. */\n\tif (tp->stree[ROOT] == oldroot)\n\t\treturn (0);\n\n\t/* root changed. bubble the change up to the dmap control pages.\n\t * if the adjustment of the upper level control pages fails,\n\t * backout the bit allocation (thus making everything consistent).\n\t */\n\tif ((rc = dbAdjCtl(bmp, blkno, tp->stree[ROOT], 1, 0)))\n\t\tdbFreeBits(bmp, dp, blkno, nblocks);\n\n\treturn (rc);\n}"
        }
      },
      {
        "call_info": {
          "callee": "lengthPXD",
          "args": [
            "&iagp->inoext[extno - 1]"
          ],
          "line": 2271
        },
        "resolved": true,
        "details": {
          "function_name": "lengthPXD",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_types.h",
          "lines": "86-89",
          "snippet": "static inline __u32 lengthPXD(pxd_t *pxd)\n{\n\treturn le32_to_cpu((pxd)->len_addr) & 0xffffff;\n}",
          "includes": [
            "#include <linux/nls.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/nls.h>\n#include <linux/types.h>\n\nstatic inline __u32 lengthPXD(pxd_t *pxd)\n{\n\treturn le32_to_cpu((pxd)->len_addr) & 0xffffff;\n}"
        }
      },
      {
        "call_info": {
          "callee": "addressPXD",
          "args": [
            "&iagp->inoext[extno - 1]"
          ],
          "line": 2270
        },
        "resolved": true,
        "details": {
          "function_name": "addressPXD",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_types.h",
          "lines": "91-95",
          "snippet": "static inline __u64 addressPXD(pxd_t *pxd)\n{\n\t__u64 n = le32_to_cpu(pxd->len_addr) & ~0xffffff;\n\treturn (n << 8) + le32_to_cpu(pxd->addr2);\n}",
          "includes": [
            "#include <linux/nls.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/nls.h>\n#include <linux/types.h>\n\nstatic inline __u64 addressPXD(pxd_t *pxd)\n{\n\t__u64 n = le32_to_cpu(pxd->len_addr) & ~0xffffff;\n\treturn (n << 8) + le32_to_cpu(pxd->addr2);\n}"
        }
      },
      {
        "call_info": {
          "callee": "jfs_error",
          "args": [
            "imap->im_ipimap->i_sb",
            "\"ciagp == NULL\\n\""
          ],
          "line": 2257
        },
        "resolved": true,
        "details": {
          "function_name": "jfs_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/super.c",
          "lines": "95-111",
          "snippet": "void jfs_error(struct super_block *sb, const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tva_start(args, fmt);\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tpr_err(\"ERROR: (device %s): %pf: %pV\\n\",\n\t       sb->s_id, __builtin_return_address(0), &vaf);\n\n\tva_end(args);\n\n\tjfs_handle_error(sb);\n}",
          "includes": [
            "#include \"jfs_xattr.h\"",
            "#include \"jfs_debug.h\"",
            "#include \"jfs_acl.h\"",
            "#include \"jfs_imap.h\"",
            "#include \"jfs_dmap.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_inode.h\"",
            "#include \"jfs_filsys.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/blkdev.h>",
            "#include <linux/seq_file.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/crc32.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/mount.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/vfs.h>",
            "#include <linux/completion.h>",
            "#include <linux/parser.h>",
            "#include <linux/module.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_xattr.h\"\n#include \"jfs_debug.h\"\n#include \"jfs_acl.h\"\n#include \"jfs_imap.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_inode.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_incore.h\"\n#include <linux/blkdev.h>\n#include <linux/seq_file.h>\n#include <asm/uaccess.h>\n#include <linux/slab.h>\n#include <linux/crc32.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/posix_acl.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/mount.h>\n#include <linux/quotaops.h>\n#include <linux/vfs.h>\n#include <linux/completion.h>\n#include <linux/parser.h>\n#include <linux/module.h>\n#include <linux/fs.h>\n\nvoid jfs_error(struct super_block *sb, const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tva_start(args, fmt);\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tpr_err(\"ERROR: (device %s): %pf: %pV\\n\",\n\t       sb->s_id, __builtin_return_address(0), &vaf);\n\n\tva_end(args);\n\n\tjfs_handle_error(sb);\n}"
        }
      },
      {
        "call_info": {
          "callee": "diIAGRead",
          "args": [
            "imap",
            "freei",
            "&cmp"
          ],
          "line": 2252
        },
        "resolved": true,
        "details": {
          "function_name": "diIAGRead",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_imap.c",
          "lines": "2675-2690",
          "snippet": "static int diIAGRead(struct inomap * imap, int iagno, struct metapage ** mpp)\n{\n\tstruct inode *ipimap = imap->im_ipimap;\n\ts64 blkno;\n\n\t/* compute the logical block number of the iag. */\n\tblkno = IAGTOLBLK(iagno, JFS_SBI(ipimap->i_sb)->l2nbperpage);\n\n\t/* read the iag. */\n\t*mpp = read_metapage(ipimap, blkno, PSIZE, 0);\n\tif (*mpp == NULL) {\n\t\treturn -EIO;\n\t}\n\n\treturn (0);\n}",
          "includes": [
            "#include \"jfs_debug.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_imap.h\"",
            "#include \"jfs_dmap.h\"",
            "#include \"jfs_dinode.h\"",
            "#include \"jfs_filsys.h\"",
            "#include \"jfs_inode.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/slab.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int diAllocAG(struct inomap *, int, bool, struct inode *);",
            "static int diAllocAny(struct inomap *, int, bool, struct inode *);",
            "static int diAllocBit(struct inomap *, struct iag *, int);",
            "static int diAllocExt(struct inomap *, int, struct inode *);",
            "static int diAllocIno(struct inomap *, int, struct inode *);",
            "static int diNewExt(struct inomap *, struct iag *, int);",
            "static int diNewIAG(struct inomap *, int *, int, struct metapage **);",
            "static void duplicateIXtree(struct super_block *, s64, int, s64 *);",
            "static int diIAGRead(struct inomap * imap, int, struct metapage **);",
            "static int copy_from_dinode(struct dinode *, struct inode *);",
            "static void copy_to_dinode(struct dinode *, struct inode *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_imap.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_dinode.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_inode.h\"\n#include \"jfs_incore.h\"\n#include <linux/slab.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n\nstatic int diAllocAG(struct inomap *, int, bool, struct inode *);\nstatic int diAllocAny(struct inomap *, int, bool, struct inode *);\nstatic int diAllocBit(struct inomap *, struct iag *, int);\nstatic int diAllocExt(struct inomap *, int, struct inode *);\nstatic int diAllocIno(struct inomap *, int, struct inode *);\nstatic int diNewExt(struct inomap *, struct iag *, int);\nstatic int diNewIAG(struct inomap *, int *, int, struct metapage **);\nstatic void duplicateIXtree(struct super_block *, s64, int, s64 *);\nstatic int diIAGRead(struct inomap * imap, int, struct metapage **);\nstatic int copy_from_dinode(struct dinode *, struct inode *);\nstatic void copy_to_dinode(struct dinode *, struct inode *);\n\nstatic int diIAGRead(struct inomap * imap, int iagno, struct metapage ** mpp)\n{\n\tstruct inode *ipimap = imap->im_ipimap;\n\ts64 blkno;\n\n\t/* compute the logical block number of the iag. */\n\tblkno = IAGTOLBLK(iagno, JFS_SBI(ipimap->i_sb)->l2nbperpage);\n\n\t/* read the iag. */\n\t*mpp = read_metapage(ipimap, blkno, PSIZE, 0);\n\tif (*mpp == NULL) {\n\t\treturn -EIO;\n\t}\n\n\treturn (0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "EXTSPERIAG"
          ],
          "line": 2227
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "1"
          ],
          "line": 2207
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BLKTOAG",
          "args": [
            "le64_to_cpu(iagp->agstart)",
            "sbi"
          ],
          "line": 2199
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le64_to_cpu",
          "args": [
            "iagp->agstart"
          ],
          "line": 2199
        },
        "resolved": true,
        "details": {
          "function_name": "sle64_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "58-61",
          "snippet": "static inline s64 sle64_to_cpup(sle64 *x)\n{\n\treturn le64_to_cpu(*(__force le64*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s64 sle64_to_cpup(sle64 *x)\n{\n\treturn le64_to_cpu(*(__force le64*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "JFS_SBI",
          "args": [
            "ipimap->i_sb"
          ],
          "line": 2193
        },
        "resolved": true,
        "details": {
          "function_name": "JFS_SBI",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_incore.h",
          "lines": "217-220",
          "snippet": "static inline struct jfs_sb_info *JFS_SBI(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"jfs_dtree.h\"",
            "#include \"jfs_xtree.h\"",
            "#include \"jfs_types.h\"",
            "#include <linux/bitops.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_dtree.h\"\n#include \"jfs_xtree.h\"\n#include \"jfs_types.h\"\n#include <linux/bitops.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mutex.h>\n\nstatic inline struct jfs_sb_info *JFS_SBI(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_imap.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_dinode.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_inode.h\"\n#include \"jfs_incore.h\"\n#include <linux/slab.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n\nstatic int diAllocAG(struct inomap *, int, bool, struct inode *);\nstatic int diAllocAny(struct inomap *, int, bool, struct inode *);\nstatic int diAllocBit(struct inomap *, struct iag *, int);\nstatic int diAllocExt(struct inomap *, int, struct inode *);\nstatic int diAllocIno(struct inomap *, int, struct inode *);\nstatic int diFindFree(u32, int);\nstatic int diNewExt(struct inomap *, struct iag *, int);\nstatic int diNewIAG(struct inomap *, int *, int, struct metapage **);\nstatic void duplicateIXtree(struct super_block *, s64, int, s64 *);\nstatic int diIAGRead(struct inomap * imap, int, struct metapage **);\nstatic int copy_from_dinode(struct dinode *, struct inode *);\nstatic void copy_to_dinode(struct dinode *, struct inode *);\n\nstatic int diNewExt(struct inomap * imap, struct iag * iagp, int extno)\n{\n\tint agno, iagno, fwd, back, freei = 0, sword, rc;\n\tstruct iag *aiagp = NULL, *biagp = NULL, *ciagp = NULL;\n\tstruct metapage *amp, *bmp, *cmp, *dmp;\n\tstruct inode *ipimap;\n\ts64 blkno, hint;\n\tint i, j;\n\tu32 mask;\n\tino_t ino;\n\tstruct dinode *dp;\n\tstruct jfs_sb_info *sbi;\n\n\t/* better have free extents.\n\t */\n\tif (!iagp->nfreeexts) {\n\t\tjfs_error(imap->im_ipimap->i_sb, \"no free extents\\n\");\n\t\treturn -EIO;\n\t}\n\n\t/* get the inode map inode.\n\t */\n\tipimap = imap->im_ipimap;\n\tsbi = JFS_SBI(ipimap->i_sb);\n\n\tamp = bmp = cmp = NULL;\n\n\t/* get the ag and iag numbers for this iag.\n\t */\n\tagno = BLKTOAG(le64_to_cpu(iagp->agstart), sbi);\n\tiagno = le32_to_cpu(iagp->iagnum);\n\n\t/* check if this is the last free extent within the\n\t * iag.  if so, the iag must be removed from the ag\n\t * free extent list, so get the iags preceding and\n\t * following the iag on this list.\n\t */\n\tif (iagp->nfreeexts == cpu_to_le32(1)) {\n\t\tif ((fwd = le32_to_cpu(iagp->extfreefwd)) >= 0) {\n\t\t\tif ((rc = diIAGRead(imap, fwd, &amp)))\n\t\t\t\treturn (rc);\n\t\t\taiagp = (struct iag *) amp->data;\n\t\t}\n\n\t\tif ((back = le32_to_cpu(iagp->extfreeback)) >= 0) {\n\t\t\tif ((rc = diIAGRead(imap, back, &bmp)))\n\t\t\t\tgoto error_out;\n\t\t\tbiagp = (struct iag *) bmp->data;\n\t\t}\n\t} else {\n\t\t/* the iag has free extents.  if all extents are free\n\t\t * (as is the case for a newly allocated iag), the iag\n\t\t * must be added to the ag free extent list, so get\n\t\t * the iag at the head of the list in preparation for\n\t\t * adding this iag to this list.\n\t\t */\n\t\tfwd = back = -1;\n\t\tif (iagp->nfreeexts == cpu_to_le32(EXTSPERIAG)) {\n\t\t\tif ((fwd = imap->im_agctl[agno].extfree) >= 0) {\n\t\t\t\tif ((rc = diIAGRead(imap, fwd, &amp)))\n\t\t\t\t\tgoto error_out;\n\t\t\t\taiagp = (struct iag *) amp->data;\n\t\t\t}\n\t\t}\n\t}\n\n\t/* check if the iag has no free inodes.  if so, the iag\n\t * will have to be added to the ag free inode list, so get\n\t * the iag at the head of the list in preparation for\n\t * adding this iag to this list.  in doing this, we must\n\t * check if we already have the iag at the head of\n\t * the list in hand.\n\t */\n\tif (iagp->nfreeinos == 0) {\n\t\tfreei = imap->im_agctl[agno].inofree;\n\n\t\tif (freei >= 0) {\n\t\t\tif (freei == fwd) {\n\t\t\t\tciagp = aiagp;\n\t\t\t} else if (freei == back) {\n\t\t\t\tciagp = biagp;\n\t\t\t} else {\n\t\t\t\tif ((rc = diIAGRead(imap, freei, &cmp)))\n\t\t\t\t\tgoto error_out;\n\t\t\t\tciagp = (struct iag *) cmp->data;\n\t\t\t}\n\t\t\tif (ciagp == NULL) {\n\t\t\t\tjfs_error(imap->im_ipimap->i_sb,\n\t\t\t\t\t  \"ciagp == NULL\\n\");\n\t\t\t\trc = -EIO;\n\t\t\t\tgoto error_out;\n\t\t\t}\n\t\t}\n\t}\n\n\t/* allocate disk space for the inode extent.\n\t */\n\tif ((extno == 0) || (addressPXD(&iagp->inoext[extno - 1]) == 0))\n\t\thint = ((s64) agno << sbi->bmap->db_agl2size) - 1;\n\telse\n\t\thint = addressPXD(&iagp->inoext[extno - 1]) +\n\t\t    lengthPXD(&iagp->inoext[extno - 1]) - 1;\n\n\tif ((rc = dbAlloc(ipimap, hint, (s64) imap->im_nbperiext, &blkno)))\n\t\tgoto error_out;\n\n\t/* compute the inode number of the first inode within the\n\t * extent.\n\t */\n\tino = (iagno << L2INOSPERIAG) + (extno << L2INOSPEREXT);\n\n\t/* initialize the inodes within the newly allocated extent a\n\t * page at a time.\n\t */\n\tfor (i = 0; i < imap->im_nbperiext; i += sbi->nbperpage) {\n\t\t/* get a buffer for this page of disk inodes.\n\t\t */\n\t\tdmp = get_metapage(ipimap, blkno + i, PSIZE, 1);\n\t\tif (dmp == NULL) {\n\t\t\trc = -EIO;\n\t\t\tgoto error_out;\n\t\t}\n\t\tdp = (struct dinode *) dmp->data;\n\n\t\t/* initialize the inode number, mode, link count and\n\t\t * inode extent address.\n\t\t */\n\t\tfor (j = 0; j < INOSPERPAGE; j++, dp++, ino++) {\n\t\t\tdp->di_inostamp = cpu_to_le32(sbi->inostamp);\n\t\t\tdp->di_number = cpu_to_le32(ino);\n\t\t\tdp->di_fileset = cpu_to_le32(FILESYSTEM_I);\n\t\t\tdp->di_mode = 0;\n\t\t\tdp->di_nlink = 0;\n\t\t\tPXDaddress(&(dp->di_ixpxd), blkno);\n\t\t\tPXDlength(&(dp->di_ixpxd), imap->im_nbperiext);\n\t\t}\n\t\twrite_metapage(dmp);\n\t}\n\n\t/* if this is the last free extent within the iag, remove the\n\t * iag from the ag free extent list.\n\t */\n\tif (iagp->nfreeexts == cpu_to_le32(1)) {\n\t\tif (fwd >= 0)\n\t\t\taiagp->extfreeback = iagp->extfreeback;\n\n\t\tif (back >= 0)\n\t\t\tbiagp->extfreefwd = iagp->extfreefwd;\n\t\telse\n\t\t\timap->im_agctl[agno].extfree =\n\t\t\t    le32_to_cpu(iagp->extfreefwd);\n\n\t\tiagp->extfreefwd = iagp->extfreeback = cpu_to_le32(-1);\n\t} else {\n\t\t/* if the iag has all free extents (newly allocated iag),\n\t\t * add the iag to the ag free extent list.\n\t\t */\n\t\tif (iagp->nfreeexts == cpu_to_le32(EXTSPERIAG)) {\n\t\t\tif (fwd >= 0)\n\t\t\t\taiagp->extfreeback = cpu_to_le32(iagno);\n\n\t\t\tiagp->extfreefwd = cpu_to_le32(fwd);\n\t\t\tiagp->extfreeback = cpu_to_le32(-1);\n\t\t\timap->im_agctl[agno].extfree = iagno;\n\t\t}\n\t}\n\n\t/* if the iag has no free inodes, add the iag to the\n\t * ag free inode list.\n\t */\n\tif (iagp->nfreeinos == 0) {\n\t\tif (freei >= 0)\n\t\t\tciagp->inofreeback = cpu_to_le32(iagno);\n\n\t\tiagp->inofreefwd =\n\t\t    cpu_to_le32(imap->im_agctl[agno].inofree);\n\t\tiagp->inofreeback = cpu_to_le32(-1);\n\t\timap->im_agctl[agno].inofree = iagno;\n\t}\n\n\t/* initialize the extent descriptor of the extent. */\n\tPXDlength(&iagp->inoext[extno], imap->im_nbperiext);\n\tPXDaddress(&iagp->inoext[extno], blkno);\n\n\t/* initialize the working and persistent map of the extent.\n\t * the working map will be initialized such that\n\t * it indicates the first inode of the extent is allocated.\n\t */\n\tiagp->wmap[extno] = cpu_to_le32(HIGHORDER);\n\tiagp->pmap[extno] = 0;\n\n\t/* update the free inode and free extent summary maps\n\t * for the extent to indicate the extent has free inodes\n\t * and no longer represents a free extent.\n\t */\n\tsword = extno >> L2EXTSPERSUM;\n\tmask = HIGHORDER >> (extno & (EXTSPERSUM - 1));\n\tiagp->extsmap[sword] |= cpu_to_le32(mask);\n\tiagp->inosmap[sword] &= cpu_to_le32(~mask);\n\n\t/* update the free inode and free extent counts for the\n\t * iag.\n\t */\n\tle32_add_cpu(&iagp->nfreeinos, (INOSPEREXT - 1));\n\tle32_add_cpu(&iagp->nfreeexts, -1);\n\n\t/* update the free and backed inode counts for the ag.\n\t */\n\timap->im_agctl[agno].numfree += (INOSPEREXT - 1);\n\timap->im_agctl[agno].numinos += INOSPEREXT;\n\n\t/* update the free and backed inode counts for the inode map.\n\t */\n\tatomic_add(INOSPEREXT - 1, &imap->im_numfree);\n\tatomic_add(INOSPEREXT, &imap->im_numinos);\n\n\t/* write the iags.\n\t */\n\tif (amp)\n\t\twrite_metapage(amp);\n\tif (bmp)\n\t\twrite_metapage(bmp);\n\tif (cmp)\n\t\twrite_metapage(cmp);\n\n\treturn (0);\n\n      error_out:\n\n\t/* release the iags.\n\t */\n\tif (amp)\n\t\trelease_metapage(amp);\n\tif (bmp)\n\t\trelease_metapage(bmp);\n\tif (cmp)\n\t\trelease_metapage(cmp);\n\n\treturn (rc);\n}"
  },
  {
    "function_name": "diAllocBit",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_imap.c",
    "lines": "2024-2124",
    "snippet": "static int diAllocBit(struct inomap * imap, struct iag * iagp, int ino)\n{\n\tint extno, bitno, agno, sword, rc;\n\tstruct metapage *amp = NULL, *bmp = NULL;\n\tstruct iag *aiagp = NULL, *biagp = NULL;\n\tu32 mask;\n\n\t/* check if this is the last free inode within the iag.\n\t * if so, it will have to be removed from the ag free\n\t * inode list, so get the iags preceding and following\n\t * it on the list.\n\t */\n\tif (iagp->nfreeinos == cpu_to_le32(1)) {\n\t\tif ((int) le32_to_cpu(iagp->inofreefwd) >= 0) {\n\t\t\tif ((rc =\n\t\t\t     diIAGRead(imap, le32_to_cpu(iagp->inofreefwd),\n\t\t\t\t       &amp)))\n\t\t\t\treturn (rc);\n\t\t\taiagp = (struct iag *) amp->data;\n\t\t}\n\n\t\tif ((int) le32_to_cpu(iagp->inofreeback) >= 0) {\n\t\t\tif ((rc =\n\t\t\t     diIAGRead(imap,\n\t\t\t\t       le32_to_cpu(iagp->inofreeback),\n\t\t\t\t       &bmp))) {\n\t\t\t\tif (amp)\n\t\t\t\t\trelease_metapage(amp);\n\t\t\t\treturn (rc);\n\t\t\t}\n\t\t\tbiagp = (struct iag *) bmp->data;\n\t\t}\n\t}\n\n\t/* get the ag number, extent number, inode number within\n\t * the extent.\n\t */\n\tagno = BLKTOAG(le64_to_cpu(iagp->agstart), JFS_SBI(imap->im_ipimap->i_sb));\n\textno = ino >> L2INOSPEREXT;\n\tbitno = ino & (INOSPEREXT - 1);\n\n\t/* compute the mask for setting the map.\n\t */\n\tmask = HIGHORDER >> bitno;\n\n\t/* the inode should be free and backed.\n\t */\n\tif (((le32_to_cpu(iagp->pmap[extno]) & mask) != 0) ||\n\t    ((le32_to_cpu(iagp->wmap[extno]) & mask) != 0) ||\n\t    (addressPXD(&iagp->inoext[extno]) == 0)) {\n\t\tif (amp)\n\t\t\trelease_metapage(amp);\n\t\tif (bmp)\n\t\t\trelease_metapage(bmp);\n\n\t\tjfs_error(imap->im_ipimap->i_sb, \"iag inconsistent\\n\");\n\t\treturn -EIO;\n\t}\n\n\t/* mark the inode as allocated in the working map.\n\t */\n\tiagp->wmap[extno] |= cpu_to_le32(mask);\n\n\t/* check if all inodes within the extent are now\n\t * allocated.  if so, update the free inode summary\n\t * map to reflect this.\n\t */\n\tif (iagp->wmap[extno] == cpu_to_le32(ONES)) {\n\t\tsword = extno >> L2EXTSPERSUM;\n\t\tbitno = extno & (EXTSPERSUM - 1);\n\t\tiagp->inosmap[sword] |= cpu_to_le32(HIGHORDER >> bitno);\n\t}\n\n\t/* if this was the last free inode in the iag, remove the\n\t * iag from the ag free inode list.\n\t */\n\tif (iagp->nfreeinos == cpu_to_le32(1)) {\n\t\tif (amp) {\n\t\t\taiagp->inofreeback = iagp->inofreeback;\n\t\t\twrite_metapage(amp);\n\t\t}\n\n\t\tif (bmp) {\n\t\t\tbiagp->inofreefwd = iagp->inofreefwd;\n\t\t\twrite_metapage(bmp);\n\t\t} else {\n\t\t\timap->im_agctl[agno].inofree =\n\t\t\t    le32_to_cpu(iagp->inofreefwd);\n\t\t}\n\t\tiagp->inofreefwd = iagp->inofreeback = cpu_to_le32(-1);\n\t}\n\n\t/* update the free inode count at the iag, ag, inode\n\t * map levels.\n\t */\n\tle32_add_cpu(&iagp->nfreeinos, -1);\n\timap->im_agctl[agno].numfree -= 1;\n\tatomic_dec(&imap->im_numfree);\n\n\treturn (0);\n}",
    "includes": [
      "#include \"jfs_debug.h\"",
      "#include \"jfs_superblock.h\"",
      "#include \"jfs_metapage.h\"",
      "#include \"jfs_imap.h\"",
      "#include \"jfs_dmap.h\"",
      "#include \"jfs_dinode.h\"",
      "#include \"jfs_filsys.h\"",
      "#include \"jfs_inode.h\"",
      "#include \"jfs_incore.h\"",
      "#include <linux/slab.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int diAllocAG(struct inomap *, int, bool, struct inode *);",
      "static int diAllocAny(struct inomap *, int, bool, struct inode *);",
      "static int diAllocBit(struct inomap *, struct iag *, int);",
      "static int diAllocExt(struct inomap *, int, struct inode *);",
      "static int diAllocIno(struct inomap *, int, struct inode *);",
      "static int diFindFree(u32, int);",
      "static int diNewExt(struct inomap *, struct iag *, int);",
      "static int diNewIAG(struct inomap *, int *, int, struct metapage **);",
      "static int diIAGRead(struct inomap * imap, int, struct metapage **);",
      "static int copy_from_dinode(struct dinode *, struct inode *);",
      "static void copy_to_dinode(struct dinode *, struct inode *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "atomic_dec",
          "args": [
            "&imap->im_numfree"
          ],
          "line": 2121
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le32_add_cpu",
          "args": [
            "&iagp->nfreeinos",
            "-1"
          ],
          "line": 2119
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "-1"
          ],
          "line": 2113
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "iagp->inofreefwd"
          ],
          "line": 2111
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "write_metapage",
          "args": [
            "bmp"
          ],
          "line": 2108
        },
        "resolved": true,
        "details": {
          "function_name": "write_metapage",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_metapage.h",
          "lines": "85-89",
          "snippet": "static inline void write_metapage(struct metapage *mp)\n{\n\tset_bit(META_dirty, &mp->flag);\n\trelease_metapage(mp);\n}",
          "includes": [
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [
            "#define META_dirty\t2"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/pagemap.h>\n\n#define META_dirty\t2\n\nstatic inline void write_metapage(struct metapage *mp)\n{\n\tset_bit(META_dirty, &mp->flag);\n\trelease_metapage(mp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "1"
          ],
          "line": 2100
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "HIGHORDER >> bitno"
          ],
          "line": 2094
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "ONES"
          ],
          "line": 2091
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "mask"
          ],
          "line": 2085
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "jfs_error",
          "args": [
            "imap->im_ipimap->i_sb",
            "\"iag inconsistent\\n\""
          ],
          "line": 2079
        },
        "resolved": true,
        "details": {
          "function_name": "jfs_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/super.c",
          "lines": "95-111",
          "snippet": "void jfs_error(struct super_block *sb, const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tva_start(args, fmt);\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tpr_err(\"ERROR: (device %s): %pf: %pV\\n\",\n\t       sb->s_id, __builtin_return_address(0), &vaf);\n\n\tva_end(args);\n\n\tjfs_handle_error(sb);\n}",
          "includes": [
            "#include \"jfs_xattr.h\"",
            "#include \"jfs_debug.h\"",
            "#include \"jfs_acl.h\"",
            "#include \"jfs_imap.h\"",
            "#include \"jfs_dmap.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_inode.h\"",
            "#include \"jfs_filsys.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/blkdev.h>",
            "#include <linux/seq_file.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/crc32.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/mount.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/vfs.h>",
            "#include <linux/completion.h>",
            "#include <linux/parser.h>",
            "#include <linux/module.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_xattr.h\"\n#include \"jfs_debug.h\"\n#include \"jfs_acl.h\"\n#include \"jfs_imap.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_inode.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_incore.h\"\n#include <linux/blkdev.h>\n#include <linux/seq_file.h>\n#include <asm/uaccess.h>\n#include <linux/slab.h>\n#include <linux/crc32.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/posix_acl.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/mount.h>\n#include <linux/quotaops.h>\n#include <linux/vfs.h>\n#include <linux/completion.h>\n#include <linux/parser.h>\n#include <linux/module.h>\n#include <linux/fs.h>\n\nvoid jfs_error(struct super_block *sb, const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tva_start(args, fmt);\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tpr_err(\"ERROR: (device %s): %pf: %pV\\n\",\n\t       sb->s_id, __builtin_return_address(0), &vaf);\n\n\tva_end(args);\n\n\tjfs_handle_error(sb);\n}"
        }
      },
      {
        "call_info": {
          "callee": "release_metapage",
          "args": [
            "bmp"
          ],
          "line": 2077
        },
        "resolved": true,
        "details": {
          "function_name": "release_metapage",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_metapage.c",
          "lines": "743-775",
          "snippet": "void release_metapage(struct metapage * mp)\n{\n\tstruct page *page = mp->page;\n\tjfs_info(\"release_metapage: mp = 0x%p, flag = 0x%lx\", mp, mp->flag);\n\n\tBUG_ON(!page);\n\n\tlock_page(page);\n\tunlock_metapage(mp);\n\n\tassert(mp->count);\n\tif (--mp->count || mp->nohomeok) {\n\t\tunlock_page(page);\n\t\tpage_cache_release(page);\n\t\treturn;\n\t}\n\n\tif (test_bit(META_dirty, &mp->flag)) {\n\t\tset_page_dirty(page);\n\t\tif (test_bit(META_sync, &mp->flag)) {\n\t\t\tclear_bit(META_sync, &mp->flag);\n\t\t\twrite_one_page(page, 1);\n\t\t\tlock_page(page); /* write_one_page unlocks the page */\n\t\t}\n\t} else if (mp->lsn)\t/* discard_metapage doesn't remove it */\n\t\tremove_from_logsync(mp);\n\n\t/* Try to keep metapages from using up too much memory */\n\tdrop_metapage(page, mp);\n\n\tunlock_page(page);\n\tpage_cache_release(page);\n}",
          "includes": [
            "#include \"jfs_debug.h\"",
            "#include \"jfs_txnmgr.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_filsys.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/mempool.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/bio.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_txnmgr.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_incore.h\"\n#include <linux/seq_file.h>\n#include <linux/mempool.h>\n#include <linux/buffer_head.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n\nvoid release_metapage(struct metapage * mp)\n{\n\tstruct page *page = mp->page;\n\tjfs_info(\"release_metapage: mp = 0x%p, flag = 0x%lx\", mp, mp->flag);\n\n\tBUG_ON(!page);\n\n\tlock_page(page);\n\tunlock_metapage(mp);\n\n\tassert(mp->count);\n\tif (--mp->count || mp->nohomeok) {\n\t\tunlock_page(page);\n\t\tpage_cache_release(page);\n\t\treturn;\n\t}\n\n\tif (test_bit(META_dirty, &mp->flag)) {\n\t\tset_page_dirty(page);\n\t\tif (test_bit(META_sync, &mp->flag)) {\n\t\t\tclear_bit(META_sync, &mp->flag);\n\t\t\twrite_one_page(page, 1);\n\t\t\tlock_page(page); /* write_one_page unlocks the page */\n\t\t}\n\t} else if (mp->lsn)\t/* discard_metapage doesn't remove it */\n\t\tremove_from_logsync(mp);\n\n\t/* Try to keep metapages from using up too much memory */\n\tdrop_metapage(page, mp);\n\n\tunlock_page(page);\n\tpage_cache_release(page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "addressPXD",
          "args": [
            "&iagp->inoext[extno]"
          ],
          "line": 2073
        },
        "resolved": true,
        "details": {
          "function_name": "addressPXD",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_types.h",
          "lines": "91-95",
          "snippet": "static inline __u64 addressPXD(pxd_t *pxd)\n{\n\t__u64 n = le32_to_cpu(pxd->len_addr) & ~0xffffff;\n\treturn (n << 8) + le32_to_cpu(pxd->addr2);\n}",
          "includes": [
            "#include <linux/nls.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/nls.h>\n#include <linux/types.h>\n\nstatic inline __u64 addressPXD(pxd_t *pxd)\n{\n\t__u64 n = le32_to_cpu(pxd->len_addr) & ~0xffffff;\n\treturn (n << 8) + le32_to_cpu(pxd->addr2);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BLKTOAG",
          "args": [
            "le64_to_cpu(iagp->agstart)",
            "JFS_SBI(imap->im_ipimap->i_sb)"
          ],
          "line": 2061
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "JFS_SBI",
          "args": [
            "imap->im_ipimap->i_sb"
          ],
          "line": 2061
        },
        "resolved": true,
        "details": {
          "function_name": "JFS_SBI",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_incore.h",
          "lines": "217-220",
          "snippet": "static inline struct jfs_sb_info *JFS_SBI(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"jfs_dtree.h\"",
            "#include \"jfs_xtree.h\"",
            "#include \"jfs_types.h\"",
            "#include <linux/bitops.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_dtree.h\"\n#include \"jfs_xtree.h\"\n#include \"jfs_types.h\"\n#include <linux/bitops.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mutex.h>\n\nstatic inline struct jfs_sb_info *JFS_SBI(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      },
      {
        "call_info": {
          "callee": "le64_to_cpu",
          "args": [
            "iagp->agstart"
          ],
          "line": 2061
        },
        "resolved": true,
        "details": {
          "function_name": "sle64_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "58-61",
          "snippet": "static inline s64 sle64_to_cpup(sle64 *x)\n{\n\treturn le64_to_cpu(*(__force le64*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s64 sle64_to_cpup(sle64 *x)\n{\n\treturn le64_to_cpu(*(__force le64*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "diIAGRead",
          "args": [
            "imap",
            "le32_to_cpu(iagp->inofreeback)",
            "&bmp"
          ],
          "line": 2047
        },
        "resolved": true,
        "details": {
          "function_name": "diIAGRead",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_imap.c",
          "lines": "2675-2690",
          "snippet": "static int diIAGRead(struct inomap * imap, int iagno, struct metapage ** mpp)\n{\n\tstruct inode *ipimap = imap->im_ipimap;\n\ts64 blkno;\n\n\t/* compute the logical block number of the iag. */\n\tblkno = IAGTOLBLK(iagno, JFS_SBI(ipimap->i_sb)->l2nbperpage);\n\n\t/* read the iag. */\n\t*mpp = read_metapage(ipimap, blkno, PSIZE, 0);\n\tif (*mpp == NULL) {\n\t\treturn -EIO;\n\t}\n\n\treturn (0);\n}",
          "includes": [
            "#include \"jfs_debug.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_imap.h\"",
            "#include \"jfs_dmap.h\"",
            "#include \"jfs_dinode.h\"",
            "#include \"jfs_filsys.h\"",
            "#include \"jfs_inode.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/slab.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int diAllocAG(struct inomap *, int, bool, struct inode *);",
            "static int diAllocAny(struct inomap *, int, bool, struct inode *);",
            "static int diAllocBit(struct inomap *, struct iag *, int);",
            "static int diAllocExt(struct inomap *, int, struct inode *);",
            "static int diAllocIno(struct inomap *, int, struct inode *);",
            "static int diNewExt(struct inomap *, struct iag *, int);",
            "static int diNewIAG(struct inomap *, int *, int, struct metapage **);",
            "static void duplicateIXtree(struct super_block *, s64, int, s64 *);",
            "static int diIAGRead(struct inomap * imap, int, struct metapage **);",
            "static int copy_from_dinode(struct dinode *, struct inode *);",
            "static void copy_to_dinode(struct dinode *, struct inode *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_imap.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_dinode.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_inode.h\"\n#include \"jfs_incore.h\"\n#include <linux/slab.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n\nstatic int diAllocAG(struct inomap *, int, bool, struct inode *);\nstatic int diAllocAny(struct inomap *, int, bool, struct inode *);\nstatic int diAllocBit(struct inomap *, struct iag *, int);\nstatic int diAllocExt(struct inomap *, int, struct inode *);\nstatic int diAllocIno(struct inomap *, int, struct inode *);\nstatic int diNewExt(struct inomap *, struct iag *, int);\nstatic int diNewIAG(struct inomap *, int *, int, struct metapage **);\nstatic void duplicateIXtree(struct super_block *, s64, int, s64 *);\nstatic int diIAGRead(struct inomap * imap, int, struct metapage **);\nstatic int copy_from_dinode(struct dinode *, struct inode *);\nstatic void copy_to_dinode(struct dinode *, struct inode *);\n\nstatic int diIAGRead(struct inomap * imap, int iagno, struct metapage ** mpp)\n{\n\tstruct inode *ipimap = imap->im_ipimap;\n\ts64 blkno;\n\n\t/* compute the logical block number of the iag. */\n\tblkno = IAGTOLBLK(iagno, JFS_SBI(ipimap->i_sb)->l2nbperpage);\n\n\t/* read the iag. */\n\t*mpp = read_metapage(ipimap, blkno, PSIZE, 0);\n\tif (*mpp == NULL) {\n\t\treturn -EIO;\n\t}\n\n\treturn (0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "1"
          ],
          "line": 2036
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_imap.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_dinode.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_inode.h\"\n#include \"jfs_incore.h\"\n#include <linux/slab.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n\nstatic int diAllocAG(struct inomap *, int, bool, struct inode *);\nstatic int diAllocAny(struct inomap *, int, bool, struct inode *);\nstatic int diAllocBit(struct inomap *, struct iag *, int);\nstatic int diAllocExt(struct inomap *, int, struct inode *);\nstatic int diAllocIno(struct inomap *, int, struct inode *);\nstatic int diFindFree(u32, int);\nstatic int diNewExt(struct inomap *, struct iag *, int);\nstatic int diNewIAG(struct inomap *, int *, int, struct metapage **);\nstatic int diIAGRead(struct inomap * imap, int, struct metapage **);\nstatic int copy_from_dinode(struct dinode *, struct inode *);\nstatic void copy_to_dinode(struct dinode *, struct inode *);\n\nstatic int diAllocBit(struct inomap * imap, struct iag * iagp, int ino)\n{\n\tint extno, bitno, agno, sword, rc;\n\tstruct metapage *amp = NULL, *bmp = NULL;\n\tstruct iag *aiagp = NULL, *biagp = NULL;\n\tu32 mask;\n\n\t/* check if this is the last free inode within the iag.\n\t * if so, it will have to be removed from the ag free\n\t * inode list, so get the iags preceding and following\n\t * it on the list.\n\t */\n\tif (iagp->nfreeinos == cpu_to_le32(1)) {\n\t\tif ((int) le32_to_cpu(iagp->inofreefwd) >= 0) {\n\t\t\tif ((rc =\n\t\t\t     diIAGRead(imap, le32_to_cpu(iagp->inofreefwd),\n\t\t\t\t       &amp)))\n\t\t\t\treturn (rc);\n\t\t\taiagp = (struct iag *) amp->data;\n\t\t}\n\n\t\tif ((int) le32_to_cpu(iagp->inofreeback) >= 0) {\n\t\t\tif ((rc =\n\t\t\t     diIAGRead(imap,\n\t\t\t\t       le32_to_cpu(iagp->inofreeback),\n\t\t\t\t       &bmp))) {\n\t\t\t\tif (amp)\n\t\t\t\t\trelease_metapage(amp);\n\t\t\t\treturn (rc);\n\t\t\t}\n\t\t\tbiagp = (struct iag *) bmp->data;\n\t\t}\n\t}\n\n\t/* get the ag number, extent number, inode number within\n\t * the extent.\n\t */\n\tagno = BLKTOAG(le64_to_cpu(iagp->agstart), JFS_SBI(imap->im_ipimap->i_sb));\n\textno = ino >> L2INOSPEREXT;\n\tbitno = ino & (INOSPEREXT - 1);\n\n\t/* compute the mask for setting the map.\n\t */\n\tmask = HIGHORDER >> bitno;\n\n\t/* the inode should be free and backed.\n\t */\n\tif (((le32_to_cpu(iagp->pmap[extno]) & mask) != 0) ||\n\t    ((le32_to_cpu(iagp->wmap[extno]) & mask) != 0) ||\n\t    (addressPXD(&iagp->inoext[extno]) == 0)) {\n\t\tif (amp)\n\t\t\trelease_metapage(amp);\n\t\tif (bmp)\n\t\t\trelease_metapage(bmp);\n\n\t\tjfs_error(imap->im_ipimap->i_sb, \"iag inconsistent\\n\");\n\t\treturn -EIO;\n\t}\n\n\t/* mark the inode as allocated in the working map.\n\t */\n\tiagp->wmap[extno] |= cpu_to_le32(mask);\n\n\t/* check if all inodes within the extent are now\n\t * allocated.  if so, update the free inode summary\n\t * map to reflect this.\n\t */\n\tif (iagp->wmap[extno] == cpu_to_le32(ONES)) {\n\t\tsword = extno >> L2EXTSPERSUM;\n\t\tbitno = extno & (EXTSPERSUM - 1);\n\t\tiagp->inosmap[sword] |= cpu_to_le32(HIGHORDER >> bitno);\n\t}\n\n\t/* if this was the last free inode in the iag, remove the\n\t * iag from the ag free inode list.\n\t */\n\tif (iagp->nfreeinos == cpu_to_le32(1)) {\n\t\tif (amp) {\n\t\t\taiagp->inofreeback = iagp->inofreeback;\n\t\t\twrite_metapage(amp);\n\t\t}\n\n\t\tif (bmp) {\n\t\t\tbiagp->inofreefwd = iagp->inofreefwd;\n\t\t\twrite_metapage(bmp);\n\t\t} else {\n\t\t\timap->im_agctl[agno].inofree =\n\t\t\t    le32_to_cpu(iagp->inofreefwd);\n\t\t}\n\t\tiagp->inofreefwd = iagp->inofreeback = cpu_to_le32(-1);\n\t}\n\n\t/* update the free inode count at the iag, ag, inode\n\t * map levels.\n\t */\n\tle32_add_cpu(&iagp->nfreeinos, -1);\n\timap->im_agctl[agno].numfree -= 1;\n\tatomic_dec(&imap->im_numfree);\n\n\treturn (0);\n}"
  },
  {
    "function_name": "diAllocExt",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_imap.c",
    "lines": "1907-1991",
    "snippet": "static int diAllocExt(struct inomap * imap, int agno, struct inode *ip)\n{\n\tint rem, iagno, sword, extno, rc;\n\tstruct metapage *mp;\n\tstruct iag *iagp;\n\n\t/* check if the ag has any iags with free extents.  if not,\n\t * allocate a new iag for the ag.\n\t */\n\tif ((iagno = imap->im_agctl[agno].extfree) < 0) {\n\t\t/* If successful, diNewIAG will obtain the read lock on the\n\t\t * imap inode.\n\t\t */\n\t\tif ((rc = diNewIAG(imap, &iagno, agno, &mp))) {\n\t\t\treturn (rc);\n\t\t}\n\t\tiagp = (struct iag *) mp->data;\n\n\t\t/* set the ag number if this a brand new iag\n\t\t */\n\t\tiagp->agstart =\n\t\t    cpu_to_le64(AGTOBLK(agno, imap->im_ipimap));\n\t} else {\n\t\t/* read the iag.\n\t\t */\n\t\tIREAD_LOCK(imap->im_ipimap, RDWRLOCK_IMAP);\n\t\tif ((rc = diIAGRead(imap, iagno, &mp))) {\n\t\t\tIREAD_UNLOCK(imap->im_ipimap);\n\t\t\tjfs_error(ip->i_sb, \"error reading iag\\n\");\n\t\t\treturn rc;\n\t\t}\n\t\tiagp = (struct iag *) mp->data;\n\t}\n\n\t/* using the free extent summary map, find a free extent.\n\t */\n\tfor (sword = 0;; sword++) {\n\t\tif (sword >= SMAPSZ) {\n\t\t\trelease_metapage(mp);\n\t\t\tIREAD_UNLOCK(imap->im_ipimap);\n\t\t\tjfs_error(ip->i_sb, \"free ext summary map not found\\n\");\n\t\t\treturn -EIO;\n\t\t}\n\t\tif (~iagp->extsmap[sword])\n\t\t\tbreak;\n\t}\n\n\t/* determine the extent number of the free extent.\n\t */\n\trem = diFindFree(le32_to_cpu(iagp->extsmap[sword]), 0);\n\tif (rem >= EXTSPERSUM) {\n\t\trelease_metapage(mp);\n\t\tIREAD_UNLOCK(imap->im_ipimap);\n\t\tjfs_error(ip->i_sb, \"free extent not found\\n\");\n\t\treturn -EIO;\n\t}\n\textno = (sword << L2EXTSPERSUM) + rem;\n\n\t/* initialize the new extent.\n\t */\n\trc = diNewExt(imap, iagp, extno);\n\tIREAD_UNLOCK(imap->im_ipimap);\n\tif (rc) {\n\t\t/* something bad happened.  if a new iag was allocated,\n\t\t * place it back on the inode map's iag free list, and\n\t\t * clear the ag number information.\n\t\t */\n\t\tif (iagp->nfreeexts == cpu_to_le32(EXTSPERIAG)) {\n\t\t\tIAGFREE_LOCK(imap);\n\t\t\tiagp->iagfree = cpu_to_le32(imap->im_freeiag);\n\t\t\timap->im_freeiag = iagno;\n\t\t\tIAGFREE_UNLOCK(imap);\n\t\t}\n\t\twrite_metapage(mp);\n\t\treturn (rc);\n\t}\n\n\t/* set the results of the allocation and write the iag.\n\t */\n\tdiInitInode(ip, iagno, extno << L2INOSPEREXT, extno, iagp);\n\n\twrite_metapage(mp);\n\n\treturn (0);\n}",
    "includes": [
      "#include \"jfs_debug.h\"",
      "#include \"jfs_superblock.h\"",
      "#include \"jfs_metapage.h\"",
      "#include \"jfs_imap.h\"",
      "#include \"jfs_dmap.h\"",
      "#include \"jfs_dinode.h\"",
      "#include \"jfs_filsys.h\"",
      "#include \"jfs_inode.h\"",
      "#include \"jfs_incore.h\"",
      "#include <linux/slab.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int diAllocAG(struct inomap *, int, bool, struct inode *);",
      "static int diAllocAny(struct inomap *, int, bool, struct inode *);",
      "static int diAllocBit(struct inomap *, struct iag *, int);",
      "static int diAllocExt(struct inomap *, int, struct inode *);",
      "static int diAllocIno(struct inomap *, int, struct inode *);",
      "static int diNewExt(struct inomap *, struct iag *, int);",
      "static int diNewIAG(struct inomap *, int *, int, struct metapage **);",
      "static int diIAGRead(struct inomap * imap, int, struct metapage **);",
      "static int copy_from_dinode(struct dinode *, struct inode *);",
      "static void copy_to_dinode(struct dinode *, struct inode *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "write_metapage",
          "args": [
            "mp"
          ],
          "line": 1988
        },
        "resolved": true,
        "details": {
          "function_name": "write_metapage",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_metapage.h",
          "lines": "85-89",
          "snippet": "static inline void write_metapage(struct metapage *mp)\n{\n\tset_bit(META_dirty, &mp->flag);\n\trelease_metapage(mp);\n}",
          "includes": [
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [
            "#define META_dirty\t2"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/pagemap.h>\n\n#define META_dirty\t2\n\nstatic inline void write_metapage(struct metapage *mp)\n{\n\tset_bit(META_dirty, &mp->flag);\n\trelease_metapage(mp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "diInitInode",
          "args": [
            "ip",
            "iagno",
            "extno << L2INOSPEREXT",
            "extno",
            "iagp"
          ],
          "line": 1986
        },
        "resolved": true,
        "details": {
          "function_name": "diInitInode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_imap.c",
          "lines": "1313-1322",
          "snippet": "static inline void\ndiInitInode(struct inode *ip, int iagno, int ino, int extno, struct iag * iagp)\n{\n\tstruct jfs_inode_info *jfs_ip = JFS_IP(ip);\n\n\tip->i_ino = (iagno << L2INOSPERIAG) + ino;\n\tjfs_ip->ixpxd = iagp->inoext[extno];\n\tjfs_ip->agstart = le64_to_cpu(iagp->agstart);\n\tjfs_ip->active_ag = -1;\n}",
          "includes": [
            "#include \"jfs_debug.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_imap.h\"",
            "#include \"jfs_dmap.h\"",
            "#include \"jfs_dinode.h\"",
            "#include \"jfs_filsys.h\"",
            "#include \"jfs_inode.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/slab.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int diAllocAG(struct inomap *, int, bool, struct inode *);",
            "static int diAllocAny(struct inomap *, int, bool, struct inode *);",
            "static int diAllocBit(struct inomap *, struct iag *, int);",
            "static int diAllocExt(struct inomap *, int, struct inode *);",
            "static int diAllocIno(struct inomap *, int, struct inode *);",
            "static int diNewExt(struct inomap *, struct iag *, int);",
            "static int copy_from_dinode(struct dinode *, struct inode *);",
            "static void copy_to_dinode(struct dinode *, struct inode *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_imap.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_dinode.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_inode.h\"\n#include \"jfs_incore.h\"\n#include <linux/slab.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n\nstatic int diAllocAG(struct inomap *, int, bool, struct inode *);\nstatic int diAllocAny(struct inomap *, int, bool, struct inode *);\nstatic int diAllocBit(struct inomap *, struct iag *, int);\nstatic int diAllocExt(struct inomap *, int, struct inode *);\nstatic int diAllocIno(struct inomap *, int, struct inode *);\nstatic int diNewExt(struct inomap *, struct iag *, int);\nstatic int copy_from_dinode(struct dinode *, struct inode *);\nstatic void copy_to_dinode(struct dinode *, struct inode *);\n\nstatic inline void\ndiInitInode(struct inode *ip, int iagno, int ino, int extno, struct iag * iagp)\n{\n\tstruct jfs_inode_info *jfs_ip = JFS_IP(ip);\n\n\tip->i_ino = (iagno << L2INOSPERIAG) + ino;\n\tjfs_ip->ixpxd = iagp->inoext[extno];\n\tjfs_ip->agstart = le64_to_cpu(iagp->agstart);\n\tjfs_ip->active_ag = -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "IAGFREE_UNLOCK",
          "args": [
            "imap"
          ],
          "line": 1978
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "imap->im_freeiag"
          ],
          "line": 1976
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IAGFREE_LOCK",
          "args": [
            "imap"
          ],
          "line": 1975
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "EXTSPERIAG"
          ],
          "line": 1974
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IREAD_UNLOCK",
          "args": [
            "imap->im_ipimap"
          ],
          "line": 1968
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "diNewExt",
          "args": [
            "imap",
            "iagp",
            "extno"
          ],
          "line": 1967
        },
        "resolved": true,
        "details": {
          "function_name": "diNewExt",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_imap.c",
          "lines": "2170-2409",
          "snippet": "static int diNewExt(struct inomap * imap, struct iag * iagp, int extno)\n{\n\tint agno, iagno, fwd, back, freei = 0, sword, rc;\n\tstruct iag *aiagp = NULL, *biagp = NULL, *ciagp = NULL;\n\tstruct metapage *amp, *bmp, *cmp, *dmp;\n\tstruct inode *ipimap;\n\ts64 blkno, hint;\n\tint i, j;\n\tu32 mask;\n\tino_t ino;\n\tstruct dinode *dp;\n\tstruct jfs_sb_info *sbi;\n\n\t/* better have free extents.\n\t */\n\tif (!iagp->nfreeexts) {\n\t\tjfs_error(imap->im_ipimap->i_sb, \"no free extents\\n\");\n\t\treturn -EIO;\n\t}\n\n\t/* get the inode map inode.\n\t */\n\tipimap = imap->im_ipimap;\n\tsbi = JFS_SBI(ipimap->i_sb);\n\n\tamp = bmp = cmp = NULL;\n\n\t/* get the ag and iag numbers for this iag.\n\t */\n\tagno = BLKTOAG(le64_to_cpu(iagp->agstart), sbi);\n\tiagno = le32_to_cpu(iagp->iagnum);\n\n\t/* check if this is the last free extent within the\n\t * iag.  if so, the iag must be removed from the ag\n\t * free extent list, so get the iags preceding and\n\t * following the iag on this list.\n\t */\n\tif (iagp->nfreeexts == cpu_to_le32(1)) {\n\t\tif ((fwd = le32_to_cpu(iagp->extfreefwd)) >= 0) {\n\t\t\tif ((rc = diIAGRead(imap, fwd, &amp)))\n\t\t\t\treturn (rc);\n\t\t\taiagp = (struct iag *) amp->data;\n\t\t}\n\n\t\tif ((back = le32_to_cpu(iagp->extfreeback)) >= 0) {\n\t\t\tif ((rc = diIAGRead(imap, back, &bmp)))\n\t\t\t\tgoto error_out;\n\t\t\tbiagp = (struct iag *) bmp->data;\n\t\t}\n\t} else {\n\t\t/* the iag has free extents.  if all extents are free\n\t\t * (as is the case for a newly allocated iag), the iag\n\t\t * must be added to the ag free extent list, so get\n\t\t * the iag at the head of the list in preparation for\n\t\t * adding this iag to this list.\n\t\t */\n\t\tfwd = back = -1;\n\t\tif (iagp->nfreeexts == cpu_to_le32(EXTSPERIAG)) {\n\t\t\tif ((fwd = imap->im_agctl[agno].extfree) >= 0) {\n\t\t\t\tif ((rc = diIAGRead(imap, fwd, &amp)))\n\t\t\t\t\tgoto error_out;\n\t\t\t\taiagp = (struct iag *) amp->data;\n\t\t\t}\n\t\t}\n\t}\n\n\t/* check if the iag has no free inodes.  if so, the iag\n\t * will have to be added to the ag free inode list, so get\n\t * the iag at the head of the list in preparation for\n\t * adding this iag to this list.  in doing this, we must\n\t * check if we already have the iag at the head of\n\t * the list in hand.\n\t */\n\tif (iagp->nfreeinos == 0) {\n\t\tfreei = imap->im_agctl[agno].inofree;\n\n\t\tif (freei >= 0) {\n\t\t\tif (freei == fwd) {\n\t\t\t\tciagp = aiagp;\n\t\t\t} else if (freei == back) {\n\t\t\t\tciagp = biagp;\n\t\t\t} else {\n\t\t\t\tif ((rc = diIAGRead(imap, freei, &cmp)))\n\t\t\t\t\tgoto error_out;\n\t\t\t\tciagp = (struct iag *) cmp->data;\n\t\t\t}\n\t\t\tif (ciagp == NULL) {\n\t\t\t\tjfs_error(imap->im_ipimap->i_sb,\n\t\t\t\t\t  \"ciagp == NULL\\n\");\n\t\t\t\trc = -EIO;\n\t\t\t\tgoto error_out;\n\t\t\t}\n\t\t}\n\t}\n\n\t/* allocate disk space for the inode extent.\n\t */\n\tif ((extno == 0) || (addressPXD(&iagp->inoext[extno - 1]) == 0))\n\t\thint = ((s64) agno << sbi->bmap->db_agl2size) - 1;\n\telse\n\t\thint = addressPXD(&iagp->inoext[extno - 1]) +\n\t\t    lengthPXD(&iagp->inoext[extno - 1]) - 1;\n\n\tif ((rc = dbAlloc(ipimap, hint, (s64) imap->im_nbperiext, &blkno)))\n\t\tgoto error_out;\n\n\t/* compute the inode number of the first inode within the\n\t * extent.\n\t */\n\tino = (iagno << L2INOSPERIAG) + (extno << L2INOSPEREXT);\n\n\t/* initialize the inodes within the newly allocated extent a\n\t * page at a time.\n\t */\n\tfor (i = 0; i < imap->im_nbperiext; i += sbi->nbperpage) {\n\t\t/* get a buffer for this page of disk inodes.\n\t\t */\n\t\tdmp = get_metapage(ipimap, blkno + i, PSIZE, 1);\n\t\tif (dmp == NULL) {\n\t\t\trc = -EIO;\n\t\t\tgoto error_out;\n\t\t}\n\t\tdp = (struct dinode *) dmp->data;\n\n\t\t/* initialize the inode number, mode, link count and\n\t\t * inode extent address.\n\t\t */\n\t\tfor (j = 0; j < INOSPERPAGE; j++, dp++, ino++) {\n\t\t\tdp->di_inostamp = cpu_to_le32(sbi->inostamp);\n\t\t\tdp->di_number = cpu_to_le32(ino);\n\t\t\tdp->di_fileset = cpu_to_le32(FILESYSTEM_I);\n\t\t\tdp->di_mode = 0;\n\t\t\tdp->di_nlink = 0;\n\t\t\tPXDaddress(&(dp->di_ixpxd), blkno);\n\t\t\tPXDlength(&(dp->di_ixpxd), imap->im_nbperiext);\n\t\t}\n\t\twrite_metapage(dmp);\n\t}\n\n\t/* if this is the last free extent within the iag, remove the\n\t * iag from the ag free extent list.\n\t */\n\tif (iagp->nfreeexts == cpu_to_le32(1)) {\n\t\tif (fwd >= 0)\n\t\t\taiagp->extfreeback = iagp->extfreeback;\n\n\t\tif (back >= 0)\n\t\t\tbiagp->extfreefwd = iagp->extfreefwd;\n\t\telse\n\t\t\timap->im_agctl[agno].extfree =\n\t\t\t    le32_to_cpu(iagp->extfreefwd);\n\n\t\tiagp->extfreefwd = iagp->extfreeback = cpu_to_le32(-1);\n\t} else {\n\t\t/* if the iag has all free extents (newly allocated iag),\n\t\t * add the iag to the ag free extent list.\n\t\t */\n\t\tif (iagp->nfreeexts == cpu_to_le32(EXTSPERIAG)) {\n\t\t\tif (fwd >= 0)\n\t\t\t\taiagp->extfreeback = cpu_to_le32(iagno);\n\n\t\t\tiagp->extfreefwd = cpu_to_le32(fwd);\n\t\t\tiagp->extfreeback = cpu_to_le32(-1);\n\t\t\timap->im_agctl[agno].extfree = iagno;\n\t\t}\n\t}\n\n\t/* if the iag has no free inodes, add the iag to the\n\t * ag free inode list.\n\t */\n\tif (iagp->nfreeinos == 0) {\n\t\tif (freei >= 0)\n\t\t\tciagp->inofreeback = cpu_to_le32(iagno);\n\n\t\tiagp->inofreefwd =\n\t\t    cpu_to_le32(imap->im_agctl[agno].inofree);\n\t\tiagp->inofreeback = cpu_to_le32(-1);\n\t\timap->im_agctl[agno].inofree = iagno;\n\t}\n\n\t/* initialize the extent descriptor of the extent. */\n\tPXDlength(&iagp->inoext[extno], imap->im_nbperiext);\n\tPXDaddress(&iagp->inoext[extno], blkno);\n\n\t/* initialize the working and persistent map of the extent.\n\t * the working map will be initialized such that\n\t * it indicates the first inode of the extent is allocated.\n\t */\n\tiagp->wmap[extno] = cpu_to_le32(HIGHORDER);\n\tiagp->pmap[extno] = 0;\n\n\t/* update the free inode and free extent summary maps\n\t * for the extent to indicate the extent has free inodes\n\t * and no longer represents a free extent.\n\t */\n\tsword = extno >> L2EXTSPERSUM;\n\tmask = HIGHORDER >> (extno & (EXTSPERSUM - 1));\n\tiagp->extsmap[sword] |= cpu_to_le32(mask);\n\tiagp->inosmap[sword] &= cpu_to_le32(~mask);\n\n\t/* update the free inode and free extent counts for the\n\t * iag.\n\t */\n\tle32_add_cpu(&iagp->nfreeinos, (INOSPEREXT - 1));\n\tle32_add_cpu(&iagp->nfreeexts, -1);\n\n\t/* update the free and backed inode counts for the ag.\n\t */\n\timap->im_agctl[agno].numfree += (INOSPEREXT - 1);\n\timap->im_agctl[agno].numinos += INOSPEREXT;\n\n\t/* update the free and backed inode counts for the inode map.\n\t */\n\tatomic_add(INOSPEREXT - 1, &imap->im_numfree);\n\tatomic_add(INOSPEREXT, &imap->im_numinos);\n\n\t/* write the iags.\n\t */\n\tif (amp)\n\t\twrite_metapage(amp);\n\tif (bmp)\n\t\twrite_metapage(bmp);\n\tif (cmp)\n\t\twrite_metapage(cmp);\n\n\treturn (0);\n\n      error_out:\n\n\t/* release the iags.\n\t */\n\tif (amp)\n\t\trelease_metapage(amp);\n\tif (bmp)\n\t\trelease_metapage(bmp);\n\tif (cmp)\n\t\trelease_metapage(cmp);\n\n\treturn (rc);\n}",
          "includes": [
            "#include \"jfs_debug.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_imap.h\"",
            "#include \"jfs_dmap.h\"",
            "#include \"jfs_dinode.h\"",
            "#include \"jfs_filsys.h\"",
            "#include \"jfs_inode.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/slab.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int diAllocAG(struct inomap *, int, bool, struct inode *);",
            "static int diAllocAny(struct inomap *, int, bool, struct inode *);",
            "static int diAllocBit(struct inomap *, struct iag *, int);",
            "static int diAllocExt(struct inomap *, int, struct inode *);",
            "static int diAllocIno(struct inomap *, int, struct inode *);",
            "static int diFindFree(u32, int);",
            "static int diNewExt(struct inomap *, struct iag *, int);",
            "static int diNewIAG(struct inomap *, int *, int, struct metapage **);",
            "static void duplicateIXtree(struct super_block *, s64, int, s64 *);",
            "static int diIAGRead(struct inomap * imap, int, struct metapage **);",
            "static int copy_from_dinode(struct dinode *, struct inode *);",
            "static void copy_to_dinode(struct dinode *, struct inode *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_imap.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_dinode.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_inode.h\"\n#include \"jfs_incore.h\"\n#include <linux/slab.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n\nstatic int diAllocAG(struct inomap *, int, bool, struct inode *);\nstatic int diAllocAny(struct inomap *, int, bool, struct inode *);\nstatic int diAllocBit(struct inomap *, struct iag *, int);\nstatic int diAllocExt(struct inomap *, int, struct inode *);\nstatic int diAllocIno(struct inomap *, int, struct inode *);\nstatic int diFindFree(u32, int);\nstatic int diNewExt(struct inomap *, struct iag *, int);\nstatic int diNewIAG(struct inomap *, int *, int, struct metapage **);\nstatic void duplicateIXtree(struct super_block *, s64, int, s64 *);\nstatic int diIAGRead(struct inomap * imap, int, struct metapage **);\nstatic int copy_from_dinode(struct dinode *, struct inode *);\nstatic void copy_to_dinode(struct dinode *, struct inode *);\n\nstatic int diNewExt(struct inomap * imap, struct iag * iagp, int extno)\n{\n\tint agno, iagno, fwd, back, freei = 0, sword, rc;\n\tstruct iag *aiagp = NULL, *biagp = NULL, *ciagp = NULL;\n\tstruct metapage *amp, *bmp, *cmp, *dmp;\n\tstruct inode *ipimap;\n\ts64 blkno, hint;\n\tint i, j;\n\tu32 mask;\n\tino_t ino;\n\tstruct dinode *dp;\n\tstruct jfs_sb_info *sbi;\n\n\t/* better have free extents.\n\t */\n\tif (!iagp->nfreeexts) {\n\t\tjfs_error(imap->im_ipimap->i_sb, \"no free extents\\n\");\n\t\treturn -EIO;\n\t}\n\n\t/* get the inode map inode.\n\t */\n\tipimap = imap->im_ipimap;\n\tsbi = JFS_SBI(ipimap->i_sb);\n\n\tamp = bmp = cmp = NULL;\n\n\t/* get the ag and iag numbers for this iag.\n\t */\n\tagno = BLKTOAG(le64_to_cpu(iagp->agstart), sbi);\n\tiagno = le32_to_cpu(iagp->iagnum);\n\n\t/* check if this is the last free extent within the\n\t * iag.  if so, the iag must be removed from the ag\n\t * free extent list, so get the iags preceding and\n\t * following the iag on this list.\n\t */\n\tif (iagp->nfreeexts == cpu_to_le32(1)) {\n\t\tif ((fwd = le32_to_cpu(iagp->extfreefwd)) >= 0) {\n\t\t\tif ((rc = diIAGRead(imap, fwd, &amp)))\n\t\t\t\treturn (rc);\n\t\t\taiagp = (struct iag *) amp->data;\n\t\t}\n\n\t\tif ((back = le32_to_cpu(iagp->extfreeback)) >= 0) {\n\t\t\tif ((rc = diIAGRead(imap, back, &bmp)))\n\t\t\t\tgoto error_out;\n\t\t\tbiagp = (struct iag *) bmp->data;\n\t\t}\n\t} else {\n\t\t/* the iag has free extents.  if all extents are free\n\t\t * (as is the case for a newly allocated iag), the iag\n\t\t * must be added to the ag free extent list, so get\n\t\t * the iag at the head of the list in preparation for\n\t\t * adding this iag to this list.\n\t\t */\n\t\tfwd = back = -1;\n\t\tif (iagp->nfreeexts == cpu_to_le32(EXTSPERIAG)) {\n\t\t\tif ((fwd = imap->im_agctl[agno].extfree) >= 0) {\n\t\t\t\tif ((rc = diIAGRead(imap, fwd, &amp)))\n\t\t\t\t\tgoto error_out;\n\t\t\t\taiagp = (struct iag *) amp->data;\n\t\t\t}\n\t\t}\n\t}\n\n\t/* check if the iag has no free inodes.  if so, the iag\n\t * will have to be added to the ag free inode list, so get\n\t * the iag at the head of the list in preparation for\n\t * adding this iag to this list.  in doing this, we must\n\t * check if we already have the iag at the head of\n\t * the list in hand.\n\t */\n\tif (iagp->nfreeinos == 0) {\n\t\tfreei = imap->im_agctl[agno].inofree;\n\n\t\tif (freei >= 0) {\n\t\t\tif (freei == fwd) {\n\t\t\t\tciagp = aiagp;\n\t\t\t} else if (freei == back) {\n\t\t\t\tciagp = biagp;\n\t\t\t} else {\n\t\t\t\tif ((rc = diIAGRead(imap, freei, &cmp)))\n\t\t\t\t\tgoto error_out;\n\t\t\t\tciagp = (struct iag *) cmp->data;\n\t\t\t}\n\t\t\tif (ciagp == NULL) {\n\t\t\t\tjfs_error(imap->im_ipimap->i_sb,\n\t\t\t\t\t  \"ciagp == NULL\\n\");\n\t\t\t\trc = -EIO;\n\t\t\t\tgoto error_out;\n\t\t\t}\n\t\t}\n\t}\n\n\t/* allocate disk space for the inode extent.\n\t */\n\tif ((extno == 0) || (addressPXD(&iagp->inoext[extno - 1]) == 0))\n\t\thint = ((s64) agno << sbi->bmap->db_agl2size) - 1;\n\telse\n\t\thint = addressPXD(&iagp->inoext[extno - 1]) +\n\t\t    lengthPXD(&iagp->inoext[extno - 1]) - 1;\n\n\tif ((rc = dbAlloc(ipimap, hint, (s64) imap->im_nbperiext, &blkno)))\n\t\tgoto error_out;\n\n\t/* compute the inode number of the first inode within the\n\t * extent.\n\t */\n\tino = (iagno << L2INOSPERIAG) + (extno << L2INOSPEREXT);\n\n\t/* initialize the inodes within the newly allocated extent a\n\t * page at a time.\n\t */\n\tfor (i = 0; i < imap->im_nbperiext; i += sbi->nbperpage) {\n\t\t/* get a buffer for this page of disk inodes.\n\t\t */\n\t\tdmp = get_metapage(ipimap, blkno + i, PSIZE, 1);\n\t\tif (dmp == NULL) {\n\t\t\trc = -EIO;\n\t\t\tgoto error_out;\n\t\t}\n\t\tdp = (struct dinode *) dmp->data;\n\n\t\t/* initialize the inode number, mode, link count and\n\t\t * inode extent address.\n\t\t */\n\t\tfor (j = 0; j < INOSPERPAGE; j++, dp++, ino++) {\n\t\t\tdp->di_inostamp = cpu_to_le32(sbi->inostamp);\n\t\t\tdp->di_number = cpu_to_le32(ino);\n\t\t\tdp->di_fileset = cpu_to_le32(FILESYSTEM_I);\n\t\t\tdp->di_mode = 0;\n\t\t\tdp->di_nlink = 0;\n\t\t\tPXDaddress(&(dp->di_ixpxd), blkno);\n\t\t\tPXDlength(&(dp->di_ixpxd), imap->im_nbperiext);\n\t\t}\n\t\twrite_metapage(dmp);\n\t}\n\n\t/* if this is the last free extent within the iag, remove the\n\t * iag from the ag free extent list.\n\t */\n\tif (iagp->nfreeexts == cpu_to_le32(1)) {\n\t\tif (fwd >= 0)\n\t\t\taiagp->extfreeback = iagp->extfreeback;\n\n\t\tif (back >= 0)\n\t\t\tbiagp->extfreefwd = iagp->extfreefwd;\n\t\telse\n\t\t\timap->im_agctl[agno].extfree =\n\t\t\t    le32_to_cpu(iagp->extfreefwd);\n\n\t\tiagp->extfreefwd = iagp->extfreeback = cpu_to_le32(-1);\n\t} else {\n\t\t/* if the iag has all free extents (newly allocated iag),\n\t\t * add the iag to the ag free extent list.\n\t\t */\n\t\tif (iagp->nfreeexts == cpu_to_le32(EXTSPERIAG)) {\n\t\t\tif (fwd >= 0)\n\t\t\t\taiagp->extfreeback = cpu_to_le32(iagno);\n\n\t\t\tiagp->extfreefwd = cpu_to_le32(fwd);\n\t\t\tiagp->extfreeback = cpu_to_le32(-1);\n\t\t\timap->im_agctl[agno].extfree = iagno;\n\t\t}\n\t}\n\n\t/* if the iag has no free inodes, add the iag to the\n\t * ag free inode list.\n\t */\n\tif (iagp->nfreeinos == 0) {\n\t\tif (freei >= 0)\n\t\t\tciagp->inofreeback = cpu_to_le32(iagno);\n\n\t\tiagp->inofreefwd =\n\t\t    cpu_to_le32(imap->im_agctl[agno].inofree);\n\t\tiagp->inofreeback = cpu_to_le32(-1);\n\t\timap->im_agctl[agno].inofree = iagno;\n\t}\n\n\t/* initialize the extent descriptor of the extent. */\n\tPXDlength(&iagp->inoext[extno], imap->im_nbperiext);\n\tPXDaddress(&iagp->inoext[extno], blkno);\n\n\t/* initialize the working and persistent map of the extent.\n\t * the working map will be initialized such that\n\t * it indicates the first inode of the extent is allocated.\n\t */\n\tiagp->wmap[extno] = cpu_to_le32(HIGHORDER);\n\tiagp->pmap[extno] = 0;\n\n\t/* update the free inode and free extent summary maps\n\t * for the extent to indicate the extent has free inodes\n\t * and no longer represents a free extent.\n\t */\n\tsword = extno >> L2EXTSPERSUM;\n\tmask = HIGHORDER >> (extno & (EXTSPERSUM - 1));\n\tiagp->extsmap[sword] |= cpu_to_le32(mask);\n\tiagp->inosmap[sword] &= cpu_to_le32(~mask);\n\n\t/* update the free inode and free extent counts for the\n\t * iag.\n\t */\n\tle32_add_cpu(&iagp->nfreeinos, (INOSPEREXT - 1));\n\tle32_add_cpu(&iagp->nfreeexts, -1);\n\n\t/* update the free and backed inode counts for the ag.\n\t */\n\timap->im_agctl[agno].numfree += (INOSPEREXT - 1);\n\timap->im_agctl[agno].numinos += INOSPEREXT;\n\n\t/* update the free and backed inode counts for the inode map.\n\t */\n\tatomic_add(INOSPEREXT - 1, &imap->im_numfree);\n\tatomic_add(INOSPEREXT, &imap->im_numinos);\n\n\t/* write the iags.\n\t */\n\tif (amp)\n\t\twrite_metapage(amp);\n\tif (bmp)\n\t\twrite_metapage(bmp);\n\tif (cmp)\n\t\twrite_metapage(cmp);\n\n\treturn (0);\n\n      error_out:\n\n\t/* release the iags.\n\t */\n\tif (amp)\n\t\trelease_metapage(amp);\n\tif (bmp)\n\t\trelease_metapage(bmp);\n\tif (cmp)\n\t\trelease_metapage(cmp);\n\n\treturn (rc);\n}"
        }
      },
      {
        "call_info": {
          "callee": "jfs_error",
          "args": [
            "ip->i_sb",
            "\"free extent not found\\n\""
          ],
          "line": 1960
        },
        "resolved": true,
        "details": {
          "function_name": "jfs_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/super.c",
          "lines": "95-111",
          "snippet": "void jfs_error(struct super_block *sb, const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tva_start(args, fmt);\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tpr_err(\"ERROR: (device %s): %pf: %pV\\n\",\n\t       sb->s_id, __builtin_return_address(0), &vaf);\n\n\tva_end(args);\n\n\tjfs_handle_error(sb);\n}",
          "includes": [
            "#include \"jfs_xattr.h\"",
            "#include \"jfs_debug.h\"",
            "#include \"jfs_acl.h\"",
            "#include \"jfs_imap.h\"",
            "#include \"jfs_dmap.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_inode.h\"",
            "#include \"jfs_filsys.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/blkdev.h>",
            "#include <linux/seq_file.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/crc32.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/mount.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/vfs.h>",
            "#include <linux/completion.h>",
            "#include <linux/parser.h>",
            "#include <linux/module.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_xattr.h\"\n#include \"jfs_debug.h\"\n#include \"jfs_acl.h\"\n#include \"jfs_imap.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_inode.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_incore.h\"\n#include <linux/blkdev.h>\n#include <linux/seq_file.h>\n#include <asm/uaccess.h>\n#include <linux/slab.h>\n#include <linux/crc32.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/posix_acl.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/mount.h>\n#include <linux/quotaops.h>\n#include <linux/vfs.h>\n#include <linux/completion.h>\n#include <linux/parser.h>\n#include <linux/module.h>\n#include <linux/fs.h>\n\nvoid jfs_error(struct super_block *sb, const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tva_start(args, fmt);\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tpr_err(\"ERROR: (device %s): %pf: %pV\\n\",\n\t       sb->s_id, __builtin_return_address(0), &vaf);\n\n\tva_end(args);\n\n\tjfs_handle_error(sb);\n}"
        }
      },
      {
        "call_info": {
          "callee": "IREAD_UNLOCK",
          "args": [
            "imap->im_ipimap"
          ],
          "line": 1959
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "release_metapage",
          "args": [
            "mp"
          ],
          "line": 1958
        },
        "resolved": true,
        "details": {
          "function_name": "release_metapage",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_metapage.c",
          "lines": "743-775",
          "snippet": "void release_metapage(struct metapage * mp)\n{\n\tstruct page *page = mp->page;\n\tjfs_info(\"release_metapage: mp = 0x%p, flag = 0x%lx\", mp, mp->flag);\n\n\tBUG_ON(!page);\n\n\tlock_page(page);\n\tunlock_metapage(mp);\n\n\tassert(mp->count);\n\tif (--mp->count || mp->nohomeok) {\n\t\tunlock_page(page);\n\t\tpage_cache_release(page);\n\t\treturn;\n\t}\n\n\tif (test_bit(META_dirty, &mp->flag)) {\n\t\tset_page_dirty(page);\n\t\tif (test_bit(META_sync, &mp->flag)) {\n\t\t\tclear_bit(META_sync, &mp->flag);\n\t\t\twrite_one_page(page, 1);\n\t\t\tlock_page(page); /* write_one_page unlocks the page */\n\t\t}\n\t} else if (mp->lsn)\t/* discard_metapage doesn't remove it */\n\t\tremove_from_logsync(mp);\n\n\t/* Try to keep metapages from using up too much memory */\n\tdrop_metapage(page, mp);\n\n\tunlock_page(page);\n\tpage_cache_release(page);\n}",
          "includes": [
            "#include \"jfs_debug.h\"",
            "#include \"jfs_txnmgr.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_filsys.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/mempool.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/bio.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_txnmgr.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_incore.h\"\n#include <linux/seq_file.h>\n#include <linux/mempool.h>\n#include <linux/buffer_head.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n\nvoid release_metapage(struct metapage * mp)\n{\n\tstruct page *page = mp->page;\n\tjfs_info(\"release_metapage: mp = 0x%p, flag = 0x%lx\", mp, mp->flag);\n\n\tBUG_ON(!page);\n\n\tlock_page(page);\n\tunlock_metapage(mp);\n\n\tassert(mp->count);\n\tif (--mp->count || mp->nohomeok) {\n\t\tunlock_page(page);\n\t\tpage_cache_release(page);\n\t\treturn;\n\t}\n\n\tif (test_bit(META_dirty, &mp->flag)) {\n\t\tset_page_dirty(page);\n\t\tif (test_bit(META_sync, &mp->flag)) {\n\t\t\tclear_bit(META_sync, &mp->flag);\n\t\t\twrite_one_page(page, 1);\n\t\t\tlock_page(page); /* write_one_page unlocks the page */\n\t\t}\n\t} else if (mp->lsn)\t/* discard_metapage doesn't remove it */\n\t\tremove_from_logsync(mp);\n\n\t/* Try to keep metapages from using up too much memory */\n\tdrop_metapage(page, mp);\n\n\tunlock_page(page);\n\tpage_cache_release(page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "diFindFree",
          "args": [
            "le32_to_cpu(iagp->extsmap[sword])",
            "0"
          ],
          "line": 1956
        },
        "resolved": true,
        "details": {
          "function_name": "diFindFree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_imap.c",
          "lines": "2706-2717",
          "snippet": "static int diFindFree(u32 word, int start)\n{\n\tint bitno;\n\tassert(start < 32);\n\t/* scan the word for the first free bit. */\n\tfor (word <<= start, bitno = start; bitno < 32;\n\t     bitno++, word <<= 1) {\n\t\tif ((word & HIGHORDER) == 0)\n\t\t\tbreak;\n\t}\n\treturn (bitno);\n}",
          "includes": [
            "#include \"jfs_debug.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_imap.h\"",
            "#include \"jfs_dmap.h\"",
            "#include \"jfs_dinode.h\"",
            "#include \"jfs_filsys.h\"",
            "#include \"jfs_inode.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/slab.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int diFindFree(u32, int);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_imap.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_dinode.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_inode.h\"\n#include \"jfs_incore.h\"\n#include <linux/slab.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n\nstatic int diFindFree(u32, int);\n\nstatic int diFindFree(u32 word, int start)\n{\n\tint bitno;\n\tassert(start < 32);\n\t/* scan the word for the first free bit. */\n\tfor (word <<= start, bitno = start; bitno < 32;\n\t     bitno++, word <<= 1) {\n\t\tif ((word & HIGHORDER) == 0)\n\t\t\tbreak;\n\t}\n\treturn (bitno);\n}"
        }
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "iagp->extsmap[sword]"
          ],
          "line": 1956
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "IREAD_UNLOCK",
          "args": [
            "imap->im_ipimap"
          ],
          "line": 1946
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IREAD_UNLOCK",
          "args": [
            "imap->im_ipimap"
          ],
          "line": 1934
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "diIAGRead",
          "args": [
            "imap",
            "iagno",
            "&mp"
          ],
          "line": 1933
        },
        "resolved": true,
        "details": {
          "function_name": "diIAGRead",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_imap.c",
          "lines": "2675-2690",
          "snippet": "static int diIAGRead(struct inomap * imap, int iagno, struct metapage ** mpp)\n{\n\tstruct inode *ipimap = imap->im_ipimap;\n\ts64 blkno;\n\n\t/* compute the logical block number of the iag. */\n\tblkno = IAGTOLBLK(iagno, JFS_SBI(ipimap->i_sb)->l2nbperpage);\n\n\t/* read the iag. */\n\t*mpp = read_metapage(ipimap, blkno, PSIZE, 0);\n\tif (*mpp == NULL) {\n\t\treturn -EIO;\n\t}\n\n\treturn (0);\n}",
          "includes": [
            "#include \"jfs_debug.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_imap.h\"",
            "#include \"jfs_dmap.h\"",
            "#include \"jfs_dinode.h\"",
            "#include \"jfs_filsys.h\"",
            "#include \"jfs_inode.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/slab.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int diAllocAG(struct inomap *, int, bool, struct inode *);",
            "static int diAllocAny(struct inomap *, int, bool, struct inode *);",
            "static int diAllocBit(struct inomap *, struct iag *, int);",
            "static int diAllocExt(struct inomap *, int, struct inode *);",
            "static int diAllocIno(struct inomap *, int, struct inode *);",
            "static int diNewExt(struct inomap *, struct iag *, int);",
            "static int diNewIAG(struct inomap *, int *, int, struct metapage **);",
            "static void duplicateIXtree(struct super_block *, s64, int, s64 *);",
            "static int diIAGRead(struct inomap * imap, int, struct metapage **);",
            "static int copy_from_dinode(struct dinode *, struct inode *);",
            "static void copy_to_dinode(struct dinode *, struct inode *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_imap.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_dinode.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_inode.h\"\n#include \"jfs_incore.h\"\n#include <linux/slab.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n\nstatic int diAllocAG(struct inomap *, int, bool, struct inode *);\nstatic int diAllocAny(struct inomap *, int, bool, struct inode *);\nstatic int diAllocBit(struct inomap *, struct iag *, int);\nstatic int diAllocExt(struct inomap *, int, struct inode *);\nstatic int diAllocIno(struct inomap *, int, struct inode *);\nstatic int diNewExt(struct inomap *, struct iag *, int);\nstatic int diNewIAG(struct inomap *, int *, int, struct metapage **);\nstatic void duplicateIXtree(struct super_block *, s64, int, s64 *);\nstatic int diIAGRead(struct inomap * imap, int, struct metapage **);\nstatic int copy_from_dinode(struct dinode *, struct inode *);\nstatic void copy_to_dinode(struct dinode *, struct inode *);\n\nstatic int diIAGRead(struct inomap * imap, int iagno, struct metapage ** mpp)\n{\n\tstruct inode *ipimap = imap->im_ipimap;\n\ts64 blkno;\n\n\t/* compute the logical block number of the iag. */\n\tblkno = IAGTOLBLK(iagno, JFS_SBI(ipimap->i_sb)->l2nbperpage);\n\n\t/* read the iag. */\n\t*mpp = read_metapage(ipimap, blkno, PSIZE, 0);\n\tif (*mpp == NULL) {\n\t\treturn -EIO;\n\t}\n\n\treturn (0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "IREAD_LOCK",
          "args": [
            "imap->im_ipimap",
            "RDWRLOCK_IMAP"
          ],
          "line": 1932
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le64",
          "args": [
            "AGTOBLK(agno, imap->im_ipimap)"
          ],
          "line": 1928
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AGTOBLK",
          "args": [
            "agno",
            "imap->im_ipimap"
          ],
          "line": 1928
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "diNewIAG",
          "args": [
            "imap",
            "&iagno",
            "agno",
            "&mp"
          ],
          "line": 1920
        },
        "resolved": true,
        "details": {
          "function_name": "diNewIAG",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_imap.c",
          "lines": "2451-2652",
          "snippet": "static int\ndiNewIAG(struct inomap * imap, int *iagnop, int agno, struct metapage ** mpp)\n{\n\tint rc;\n\tint iagno, i, xlen;\n\tstruct inode *ipimap;\n\tstruct super_block *sb;\n\tstruct jfs_sb_info *sbi;\n\tstruct metapage *mp;\n\tstruct iag *iagp;\n\ts64 xaddr = 0;\n\ts64 blkno;\n\ttid_t tid;\n\tstruct inode *iplist[1];\n\n\t/* pick up pointers to the inode map and mount inodes */\n\tipimap = imap->im_ipimap;\n\tsb = ipimap->i_sb;\n\tsbi = JFS_SBI(sb);\n\n\t/* acquire the free iag lock */\n\tIAGFREE_LOCK(imap);\n\n\t/* if there are any iags on the inode map free iag list,\n\t * allocate the iag from the head of the list.\n\t */\n\tif (imap->im_freeiag >= 0) {\n\t\t/* pick up the iag number at the head of the list */\n\t\tiagno = imap->im_freeiag;\n\n\t\t/* determine the logical block number of the iag */\n\t\tblkno = IAGTOLBLK(iagno, sbi->l2nbperpage);\n\t} else {\n\t\t/* no free iags. the inode map will have to be extented\n\t\t * to include a new iag.\n\t\t */\n\n\t\t/* acquire inode map lock */\n\t\tIWRITE_LOCK(ipimap, RDWRLOCK_IMAP);\n\n\t\tif (ipimap->i_size >> L2PSIZE != imap->im_nextiag + 1) {\n\t\t\tIWRITE_UNLOCK(ipimap);\n\t\t\tIAGFREE_UNLOCK(imap);\n\t\t\tjfs_error(imap->im_ipimap->i_sb,\n\t\t\t\t  \"ipimap->i_size is wrong\\n\");\n\t\t\treturn -EIO;\n\t\t}\n\n\n\t\t/* get the next available iag number */\n\t\tiagno = imap->im_nextiag;\n\n\t\t/* make sure that we have not exceeded the maximum inode\n\t\t * number limit.\n\t\t */\n\t\tif (iagno > (MAXIAGS - 1)) {\n\t\t\t/* release the inode map lock */\n\t\t\tIWRITE_UNLOCK(ipimap);\n\n\t\t\trc = -ENOSPC;\n\t\t\tgoto out;\n\t\t}\n\n\t\t/*\n\t\t * synchronously append new iag page.\n\t\t */\n\t\t/* determine the logical address of iag page to append */\n\t\tblkno = IAGTOLBLK(iagno, sbi->l2nbperpage);\n\n\t\t/* Allocate extent for new iag page */\n\t\txlen = sbi->nbperpage;\n\t\tif ((rc = dbAlloc(ipimap, 0, (s64) xlen, &xaddr))) {\n\t\t\t/* release the inode map lock */\n\t\t\tIWRITE_UNLOCK(ipimap);\n\n\t\t\tgoto out;\n\t\t}\n\n\t\t/*\n\t\t * start transaction of update of the inode map\n\t\t * addressing structure pointing to the new iag page;\n\t\t */\n\t\ttid = txBegin(sb, COMMIT_FORCE);\n\t\tmutex_lock(&JFS_IP(ipimap)->commit_mutex);\n\n\t\t/* update the inode map addressing structure to point to it */\n\t\tif ((rc =\n\t\t     xtInsert(tid, ipimap, 0, blkno, xlen, &xaddr, 0))) {\n\t\t\ttxEnd(tid);\n\t\t\tmutex_unlock(&JFS_IP(ipimap)->commit_mutex);\n\t\t\t/* Free the blocks allocated for the iag since it was\n\t\t\t * not successfully added to the inode map\n\t\t\t */\n\t\t\tdbFree(ipimap, xaddr, (s64) xlen);\n\n\t\t\t/* release the inode map lock */\n\t\t\tIWRITE_UNLOCK(ipimap);\n\n\t\t\tgoto out;\n\t\t}\n\n\t\t/* update the inode map's inode to reflect the extension */\n\t\tipimap->i_size += PSIZE;\n\t\tinode_add_bytes(ipimap, PSIZE);\n\n\t\t/* assign a buffer for the page */\n\t\tmp = get_metapage(ipimap, blkno, PSIZE, 0);\n\t\tif (!mp) {\n\t\t\t/*\n\t\t\t * This is very unlikely since we just created the\n\t\t\t * extent, but let's try to handle it correctly\n\t\t\t */\n\t\t\txtTruncate(tid, ipimap, ipimap->i_size - PSIZE,\n\t\t\t\t   COMMIT_PWMAP);\n\n\t\t\ttxAbort(tid, 0);\n\t\t\ttxEnd(tid);\n\t\t\tmutex_unlock(&JFS_IP(ipimap)->commit_mutex);\n\n\t\t\t/* release the inode map lock */\n\t\t\tIWRITE_UNLOCK(ipimap);\n\n\t\t\trc = -EIO;\n\t\t\tgoto out;\n\t\t}\n\t\tiagp = (struct iag *) mp->data;\n\n\t\t/* init the iag */\n\t\tmemset(iagp, 0, sizeof(struct iag));\n\t\tiagp->iagnum = cpu_to_le32(iagno);\n\t\tiagp->inofreefwd = iagp->inofreeback = cpu_to_le32(-1);\n\t\tiagp->extfreefwd = iagp->extfreeback = cpu_to_le32(-1);\n\t\tiagp->iagfree = cpu_to_le32(-1);\n\t\tiagp->nfreeinos = 0;\n\t\tiagp->nfreeexts = cpu_to_le32(EXTSPERIAG);\n\n\t\t/* initialize the free inode summary map (free extent\n\t\t * summary map initialization handled by bzero).\n\t\t */\n\t\tfor (i = 0; i < SMAPSZ; i++)\n\t\t\tiagp->inosmap[i] = cpu_to_le32(ONES);\n\n\t\t/*\n\t\t * Write and sync the metapage\n\t\t */\n\t\tflush_metapage(mp);\n\n\t\t/*\n\t\t * txCommit(COMMIT_FORCE) will synchronously write address\n\t\t * index pages and inode after commit in careful update order\n\t\t * of address index pages (right to left, bottom up);\n\t\t */\n\t\tiplist[0] = ipimap;\n\t\trc = txCommit(tid, 1, &iplist[0], COMMIT_FORCE);\n\n\t\ttxEnd(tid);\n\t\tmutex_unlock(&JFS_IP(ipimap)->commit_mutex);\n\n\t\tduplicateIXtree(sb, blkno, xlen, &xaddr);\n\n\t\t/* update the next available iag number */\n\t\timap->im_nextiag += 1;\n\n\t\t/* Add the iag to the iag free list so we don't lose the iag\n\t\t * if a failure happens now.\n\t\t */\n\t\timap->im_freeiag = iagno;\n\n\t\t/* Until we have logredo working, we want the imap inode &\n\t\t * control page to be up to date.\n\t\t */\n\t\tdiSync(ipimap);\n\n\t\t/* release the inode map lock */\n\t\tIWRITE_UNLOCK(ipimap);\n\t}\n\n\t/* obtain read lock on map */\n\tIREAD_LOCK(ipimap, RDWRLOCK_IMAP);\n\n\t/* read the iag */\n\tif ((rc = diIAGRead(imap, iagno, &mp))) {\n\t\tIREAD_UNLOCK(ipimap);\n\t\trc = -EIO;\n\t\tgoto out;\n\t}\n\tiagp = (struct iag *) mp->data;\n\n\t/* remove the iag from the iag free list */\n\timap->im_freeiag = le32_to_cpu(iagp->iagfree);\n\tiagp->iagfree = cpu_to_le32(-1);\n\n\t/* set the return iag number and buffer pointer */\n\t*iagnop = iagno;\n\t*mpp = mp;\n\n      out:\n\t/* release the iag free lock */\n\tIAGFREE_UNLOCK(imap);\n\n\treturn (rc);\n}",
          "includes": [
            "#include \"jfs_debug.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_imap.h\"",
            "#include \"jfs_dmap.h\"",
            "#include \"jfs_dinode.h\"",
            "#include \"jfs_filsys.h\"",
            "#include \"jfs_inode.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/slab.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int diAllocAG(struct inomap *, int, bool, struct inode *);",
            "static int diAllocAny(struct inomap *, int, bool, struct inode *);",
            "static int diAllocBit(struct inomap *, struct iag *, int);",
            "static int diAllocExt(struct inomap *, int, struct inode *);",
            "static int diAllocIno(struct inomap *, int, struct inode *);",
            "static int diNewExt(struct inomap *, struct iag *, int);",
            "static int diNewIAG(struct inomap *, int *, int, struct metapage **);",
            "static void duplicateIXtree(struct super_block *, s64, int, s64 *);",
            "static int diIAGRead(struct inomap * imap, int, struct metapage **);",
            "static int copy_from_dinode(struct dinode *, struct inode *);",
            "static void copy_to_dinode(struct dinode *, struct inode *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_imap.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_dinode.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_inode.h\"\n#include \"jfs_incore.h\"\n#include <linux/slab.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n\nstatic int diAllocAG(struct inomap *, int, bool, struct inode *);\nstatic int diAllocAny(struct inomap *, int, bool, struct inode *);\nstatic int diAllocBit(struct inomap *, struct iag *, int);\nstatic int diAllocExt(struct inomap *, int, struct inode *);\nstatic int diAllocIno(struct inomap *, int, struct inode *);\nstatic int diNewExt(struct inomap *, struct iag *, int);\nstatic int diNewIAG(struct inomap *, int *, int, struct metapage **);\nstatic void duplicateIXtree(struct super_block *, s64, int, s64 *);\nstatic int diIAGRead(struct inomap * imap, int, struct metapage **);\nstatic int copy_from_dinode(struct dinode *, struct inode *);\nstatic void copy_to_dinode(struct dinode *, struct inode *);\n\nstatic int\ndiNewIAG(struct inomap * imap, int *iagnop, int agno, struct metapage ** mpp)\n{\n\tint rc;\n\tint iagno, i, xlen;\n\tstruct inode *ipimap;\n\tstruct super_block *sb;\n\tstruct jfs_sb_info *sbi;\n\tstruct metapage *mp;\n\tstruct iag *iagp;\n\ts64 xaddr = 0;\n\ts64 blkno;\n\ttid_t tid;\n\tstruct inode *iplist[1];\n\n\t/* pick up pointers to the inode map and mount inodes */\n\tipimap = imap->im_ipimap;\n\tsb = ipimap->i_sb;\n\tsbi = JFS_SBI(sb);\n\n\t/* acquire the free iag lock */\n\tIAGFREE_LOCK(imap);\n\n\t/* if there are any iags on the inode map free iag list,\n\t * allocate the iag from the head of the list.\n\t */\n\tif (imap->im_freeiag >= 0) {\n\t\t/* pick up the iag number at the head of the list */\n\t\tiagno = imap->im_freeiag;\n\n\t\t/* determine the logical block number of the iag */\n\t\tblkno = IAGTOLBLK(iagno, sbi->l2nbperpage);\n\t} else {\n\t\t/* no free iags. the inode map will have to be extented\n\t\t * to include a new iag.\n\t\t */\n\n\t\t/* acquire inode map lock */\n\t\tIWRITE_LOCK(ipimap, RDWRLOCK_IMAP);\n\n\t\tif (ipimap->i_size >> L2PSIZE != imap->im_nextiag + 1) {\n\t\t\tIWRITE_UNLOCK(ipimap);\n\t\t\tIAGFREE_UNLOCK(imap);\n\t\t\tjfs_error(imap->im_ipimap->i_sb,\n\t\t\t\t  \"ipimap->i_size is wrong\\n\");\n\t\t\treturn -EIO;\n\t\t}\n\n\n\t\t/* get the next available iag number */\n\t\tiagno = imap->im_nextiag;\n\n\t\t/* make sure that we have not exceeded the maximum inode\n\t\t * number limit.\n\t\t */\n\t\tif (iagno > (MAXIAGS - 1)) {\n\t\t\t/* release the inode map lock */\n\t\t\tIWRITE_UNLOCK(ipimap);\n\n\t\t\trc = -ENOSPC;\n\t\t\tgoto out;\n\t\t}\n\n\t\t/*\n\t\t * synchronously append new iag page.\n\t\t */\n\t\t/* determine the logical address of iag page to append */\n\t\tblkno = IAGTOLBLK(iagno, sbi->l2nbperpage);\n\n\t\t/* Allocate extent for new iag page */\n\t\txlen = sbi->nbperpage;\n\t\tif ((rc = dbAlloc(ipimap, 0, (s64) xlen, &xaddr))) {\n\t\t\t/* release the inode map lock */\n\t\t\tIWRITE_UNLOCK(ipimap);\n\n\t\t\tgoto out;\n\t\t}\n\n\t\t/*\n\t\t * start transaction of update of the inode map\n\t\t * addressing structure pointing to the new iag page;\n\t\t */\n\t\ttid = txBegin(sb, COMMIT_FORCE);\n\t\tmutex_lock(&JFS_IP(ipimap)->commit_mutex);\n\n\t\t/* update the inode map addressing structure to point to it */\n\t\tif ((rc =\n\t\t     xtInsert(tid, ipimap, 0, blkno, xlen, &xaddr, 0))) {\n\t\t\ttxEnd(tid);\n\t\t\tmutex_unlock(&JFS_IP(ipimap)->commit_mutex);\n\t\t\t/* Free the blocks allocated for the iag since it was\n\t\t\t * not successfully added to the inode map\n\t\t\t */\n\t\t\tdbFree(ipimap, xaddr, (s64) xlen);\n\n\t\t\t/* release the inode map lock */\n\t\t\tIWRITE_UNLOCK(ipimap);\n\n\t\t\tgoto out;\n\t\t}\n\n\t\t/* update the inode map's inode to reflect the extension */\n\t\tipimap->i_size += PSIZE;\n\t\tinode_add_bytes(ipimap, PSIZE);\n\n\t\t/* assign a buffer for the page */\n\t\tmp = get_metapage(ipimap, blkno, PSIZE, 0);\n\t\tif (!mp) {\n\t\t\t/*\n\t\t\t * This is very unlikely since we just created the\n\t\t\t * extent, but let's try to handle it correctly\n\t\t\t */\n\t\t\txtTruncate(tid, ipimap, ipimap->i_size - PSIZE,\n\t\t\t\t   COMMIT_PWMAP);\n\n\t\t\ttxAbort(tid, 0);\n\t\t\ttxEnd(tid);\n\t\t\tmutex_unlock(&JFS_IP(ipimap)->commit_mutex);\n\n\t\t\t/* release the inode map lock */\n\t\t\tIWRITE_UNLOCK(ipimap);\n\n\t\t\trc = -EIO;\n\t\t\tgoto out;\n\t\t}\n\t\tiagp = (struct iag *) mp->data;\n\n\t\t/* init the iag */\n\t\tmemset(iagp, 0, sizeof(struct iag));\n\t\tiagp->iagnum = cpu_to_le32(iagno);\n\t\tiagp->inofreefwd = iagp->inofreeback = cpu_to_le32(-1);\n\t\tiagp->extfreefwd = iagp->extfreeback = cpu_to_le32(-1);\n\t\tiagp->iagfree = cpu_to_le32(-1);\n\t\tiagp->nfreeinos = 0;\n\t\tiagp->nfreeexts = cpu_to_le32(EXTSPERIAG);\n\n\t\t/* initialize the free inode summary map (free extent\n\t\t * summary map initialization handled by bzero).\n\t\t */\n\t\tfor (i = 0; i < SMAPSZ; i++)\n\t\t\tiagp->inosmap[i] = cpu_to_le32(ONES);\n\n\t\t/*\n\t\t * Write and sync the metapage\n\t\t */\n\t\tflush_metapage(mp);\n\n\t\t/*\n\t\t * txCommit(COMMIT_FORCE) will synchronously write address\n\t\t * index pages and inode after commit in careful update order\n\t\t * of address index pages (right to left, bottom up);\n\t\t */\n\t\tiplist[0] = ipimap;\n\t\trc = txCommit(tid, 1, &iplist[0], COMMIT_FORCE);\n\n\t\ttxEnd(tid);\n\t\tmutex_unlock(&JFS_IP(ipimap)->commit_mutex);\n\n\t\tduplicateIXtree(sb, blkno, xlen, &xaddr);\n\n\t\t/* update the next available iag number */\n\t\timap->im_nextiag += 1;\n\n\t\t/* Add the iag to the iag free list so we don't lose the iag\n\t\t * if a failure happens now.\n\t\t */\n\t\timap->im_freeiag = iagno;\n\n\t\t/* Until we have logredo working, we want the imap inode &\n\t\t * control page to be up to date.\n\t\t */\n\t\tdiSync(ipimap);\n\n\t\t/* release the inode map lock */\n\t\tIWRITE_UNLOCK(ipimap);\n\t}\n\n\t/* obtain read lock on map */\n\tIREAD_LOCK(ipimap, RDWRLOCK_IMAP);\n\n\t/* read the iag */\n\tif ((rc = diIAGRead(imap, iagno, &mp))) {\n\t\tIREAD_UNLOCK(ipimap);\n\t\trc = -EIO;\n\t\tgoto out;\n\t}\n\tiagp = (struct iag *) mp->data;\n\n\t/* remove the iag from the iag free list */\n\timap->im_freeiag = le32_to_cpu(iagp->iagfree);\n\tiagp->iagfree = cpu_to_le32(-1);\n\n\t/* set the return iag number and buffer pointer */\n\t*iagnop = iagno;\n\t*mpp = mp;\n\n      out:\n\t/* release the iag free lock */\n\tIAGFREE_UNLOCK(imap);\n\n\treturn (rc);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_imap.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_dinode.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_inode.h\"\n#include \"jfs_incore.h\"\n#include <linux/slab.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n\nstatic int diAllocAG(struct inomap *, int, bool, struct inode *);\nstatic int diAllocAny(struct inomap *, int, bool, struct inode *);\nstatic int diAllocBit(struct inomap *, struct iag *, int);\nstatic int diAllocExt(struct inomap *, int, struct inode *);\nstatic int diAllocIno(struct inomap *, int, struct inode *);\nstatic int diNewExt(struct inomap *, struct iag *, int);\nstatic int diNewIAG(struct inomap *, int *, int, struct metapage **);\nstatic int diIAGRead(struct inomap * imap, int, struct metapage **);\nstatic int copy_from_dinode(struct dinode *, struct inode *);\nstatic void copy_to_dinode(struct dinode *, struct inode *);\n\nstatic int diAllocExt(struct inomap * imap, int agno, struct inode *ip)\n{\n\tint rem, iagno, sword, extno, rc;\n\tstruct metapage *mp;\n\tstruct iag *iagp;\n\n\t/* check if the ag has any iags with free extents.  if not,\n\t * allocate a new iag for the ag.\n\t */\n\tif ((iagno = imap->im_agctl[agno].extfree) < 0) {\n\t\t/* If successful, diNewIAG will obtain the read lock on the\n\t\t * imap inode.\n\t\t */\n\t\tif ((rc = diNewIAG(imap, &iagno, agno, &mp))) {\n\t\t\treturn (rc);\n\t\t}\n\t\tiagp = (struct iag *) mp->data;\n\n\t\t/* set the ag number if this a brand new iag\n\t\t */\n\t\tiagp->agstart =\n\t\t    cpu_to_le64(AGTOBLK(agno, imap->im_ipimap));\n\t} else {\n\t\t/* read the iag.\n\t\t */\n\t\tIREAD_LOCK(imap->im_ipimap, RDWRLOCK_IMAP);\n\t\tif ((rc = diIAGRead(imap, iagno, &mp))) {\n\t\t\tIREAD_UNLOCK(imap->im_ipimap);\n\t\t\tjfs_error(ip->i_sb, \"error reading iag\\n\");\n\t\t\treturn rc;\n\t\t}\n\t\tiagp = (struct iag *) mp->data;\n\t}\n\n\t/* using the free extent summary map, find a free extent.\n\t */\n\tfor (sword = 0;; sword++) {\n\t\tif (sword >= SMAPSZ) {\n\t\t\trelease_metapage(mp);\n\t\t\tIREAD_UNLOCK(imap->im_ipimap);\n\t\t\tjfs_error(ip->i_sb, \"free ext summary map not found\\n\");\n\t\t\treturn -EIO;\n\t\t}\n\t\tif (~iagp->extsmap[sword])\n\t\t\tbreak;\n\t}\n\n\t/* determine the extent number of the free extent.\n\t */\n\trem = diFindFree(le32_to_cpu(iagp->extsmap[sword]), 0);\n\tif (rem >= EXTSPERSUM) {\n\t\trelease_metapage(mp);\n\t\tIREAD_UNLOCK(imap->im_ipimap);\n\t\tjfs_error(ip->i_sb, \"free extent not found\\n\");\n\t\treturn -EIO;\n\t}\n\textno = (sword << L2EXTSPERSUM) + rem;\n\n\t/* initialize the new extent.\n\t */\n\trc = diNewExt(imap, iagp, extno);\n\tIREAD_UNLOCK(imap->im_ipimap);\n\tif (rc) {\n\t\t/* something bad happened.  if a new iag was allocated,\n\t\t * place it back on the inode map's iag free list, and\n\t\t * clear the ag number information.\n\t\t */\n\t\tif (iagp->nfreeexts == cpu_to_le32(EXTSPERIAG)) {\n\t\t\tIAGFREE_LOCK(imap);\n\t\t\tiagp->iagfree = cpu_to_le32(imap->im_freeiag);\n\t\t\timap->im_freeiag = iagno;\n\t\t\tIAGFREE_UNLOCK(imap);\n\t\t}\n\t\twrite_metapage(mp);\n\t\treturn (rc);\n\t}\n\n\t/* set the results of the allocation and write the iag.\n\t */\n\tdiInitInode(ip, iagno, extno << L2INOSPEREXT, extno, iagp);\n\n\twrite_metapage(mp);\n\n\treturn (0);\n}"
  },
  {
    "function_name": "diAllocIno",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_imap.c",
    "lines": "1783-1872",
    "snippet": "static int diAllocIno(struct inomap * imap, int agno, struct inode *ip)\n{\n\tint iagno, ino, rc, rem, extno, sword;\n\tstruct metapage *mp;\n\tstruct iag *iagp;\n\n\t/* check if there are iags on the ag's free inode list.\n\t */\n\tif ((iagno = imap->im_agctl[agno].inofree) < 0)\n\t\treturn -ENOSPC;\n\n\t/* obtain read lock on imap inode */\n\tIREAD_LOCK(imap->im_ipimap, RDWRLOCK_IMAP);\n\n\t/* read the iag at the head of the list.\n\t */\n\tif ((rc = diIAGRead(imap, iagno, &mp))) {\n\t\tIREAD_UNLOCK(imap->im_ipimap);\n\t\treturn (rc);\n\t}\n\tiagp = (struct iag *) mp->data;\n\n\t/* better be free inodes in this iag if it is on the\n\t * list.\n\t */\n\tif (!iagp->nfreeinos) {\n\t\tIREAD_UNLOCK(imap->im_ipimap);\n\t\trelease_metapage(mp);\n\t\tjfs_error(ip->i_sb, \"nfreeinos = 0, but iag on freelist\\n\");\n\t\treturn -EIO;\n\t}\n\n\t/* scan the free inode summary map to find an extent\n\t * with free inodes.\n\t */\n\tfor (sword = 0;; sword++) {\n\t\tif (sword >= SMAPSZ) {\n\t\t\tIREAD_UNLOCK(imap->im_ipimap);\n\t\t\trelease_metapage(mp);\n\t\t\tjfs_error(ip->i_sb,\n\t\t\t\t  \"free inode not found in summary map\\n\");\n\t\t\treturn -EIO;\n\t\t}\n\n\t\tif (~iagp->inosmap[sword])\n\t\t\tbreak;\n\t}\n\n\t/* found a extent with free inodes. determine\n\t * the extent number.\n\t */\n\trem = diFindFree(le32_to_cpu(iagp->inosmap[sword]), 0);\n\tif (rem >= EXTSPERSUM) {\n\t\tIREAD_UNLOCK(imap->im_ipimap);\n\t\trelease_metapage(mp);\n\t\tjfs_error(ip->i_sb, \"no free extent found\\n\");\n\t\treturn -EIO;\n\t}\n\textno = (sword << L2EXTSPERSUM) + rem;\n\n\t/* find the first free inode in the extent.\n\t */\n\trem = diFindFree(le32_to_cpu(iagp->wmap[extno]), 0);\n\tif (rem >= INOSPEREXT) {\n\t\tIREAD_UNLOCK(imap->im_ipimap);\n\t\trelease_metapage(mp);\n\t\tjfs_error(ip->i_sb, \"free inode not found\\n\");\n\t\treturn -EIO;\n\t}\n\n\t/* compute the inode number within the iag.\n\t */\n\tino = (extno << L2INOSPEREXT) + rem;\n\n\t/* allocate the inode.\n\t */\n\trc = diAllocBit(imap, iagp, ino);\n\tIREAD_UNLOCK(imap->im_ipimap);\n\tif (rc) {\n\t\trelease_metapage(mp);\n\t\treturn (rc);\n\t}\n\n\t/* set the results of the allocation and write the iag.\n\t */\n\tdiInitInode(ip, iagno, ino, extno, iagp);\n\twrite_metapage(mp);\n\n\treturn (0);\n}",
    "includes": [
      "#include \"jfs_debug.h\"",
      "#include \"jfs_superblock.h\"",
      "#include \"jfs_metapage.h\"",
      "#include \"jfs_imap.h\"",
      "#include \"jfs_dmap.h\"",
      "#include \"jfs_dinode.h\"",
      "#include \"jfs_filsys.h\"",
      "#include \"jfs_inode.h\"",
      "#include \"jfs_incore.h\"",
      "#include <linux/slab.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int diAllocAG(struct inomap *, int, bool, struct inode *);",
      "static int diAllocAny(struct inomap *, int, bool, struct inode *);",
      "static int diAllocBit(struct inomap *, struct iag *, int);",
      "static int diAllocExt(struct inomap *, int, struct inode *);",
      "static int diAllocIno(struct inomap *, int, struct inode *);",
      "static int diNewExt(struct inomap *, struct iag *, int);",
      "static int diNewIAG(struct inomap *, int *, int, struct metapage **);",
      "static int diIAGRead(struct inomap * imap, int, struct metapage **);",
      "static int copy_from_dinode(struct dinode *, struct inode *);",
      "static void copy_to_dinode(struct dinode *, struct inode *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "write_metapage",
          "args": [
            "mp"
          ],
          "line": 1869
        },
        "resolved": true,
        "details": {
          "function_name": "write_metapage",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_metapage.h",
          "lines": "85-89",
          "snippet": "static inline void write_metapage(struct metapage *mp)\n{\n\tset_bit(META_dirty, &mp->flag);\n\trelease_metapage(mp);\n}",
          "includes": [
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [
            "#define META_dirty\t2"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/pagemap.h>\n\n#define META_dirty\t2\n\nstatic inline void write_metapage(struct metapage *mp)\n{\n\tset_bit(META_dirty, &mp->flag);\n\trelease_metapage(mp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "diInitInode",
          "args": [
            "ip",
            "iagno",
            "ino",
            "extno",
            "iagp"
          ],
          "line": 1868
        },
        "resolved": true,
        "details": {
          "function_name": "diInitInode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_imap.c",
          "lines": "1313-1322",
          "snippet": "static inline void\ndiInitInode(struct inode *ip, int iagno, int ino, int extno, struct iag * iagp)\n{\n\tstruct jfs_inode_info *jfs_ip = JFS_IP(ip);\n\n\tip->i_ino = (iagno << L2INOSPERIAG) + ino;\n\tjfs_ip->ixpxd = iagp->inoext[extno];\n\tjfs_ip->agstart = le64_to_cpu(iagp->agstart);\n\tjfs_ip->active_ag = -1;\n}",
          "includes": [
            "#include \"jfs_debug.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_imap.h\"",
            "#include \"jfs_dmap.h\"",
            "#include \"jfs_dinode.h\"",
            "#include \"jfs_filsys.h\"",
            "#include \"jfs_inode.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/slab.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int diAllocAG(struct inomap *, int, bool, struct inode *);",
            "static int diAllocAny(struct inomap *, int, bool, struct inode *);",
            "static int diAllocBit(struct inomap *, struct iag *, int);",
            "static int diAllocExt(struct inomap *, int, struct inode *);",
            "static int diAllocIno(struct inomap *, int, struct inode *);",
            "static int diNewExt(struct inomap *, struct iag *, int);",
            "static int copy_from_dinode(struct dinode *, struct inode *);",
            "static void copy_to_dinode(struct dinode *, struct inode *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_imap.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_dinode.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_inode.h\"\n#include \"jfs_incore.h\"\n#include <linux/slab.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n\nstatic int diAllocAG(struct inomap *, int, bool, struct inode *);\nstatic int diAllocAny(struct inomap *, int, bool, struct inode *);\nstatic int diAllocBit(struct inomap *, struct iag *, int);\nstatic int diAllocExt(struct inomap *, int, struct inode *);\nstatic int diAllocIno(struct inomap *, int, struct inode *);\nstatic int diNewExt(struct inomap *, struct iag *, int);\nstatic int copy_from_dinode(struct dinode *, struct inode *);\nstatic void copy_to_dinode(struct dinode *, struct inode *);\n\nstatic inline void\ndiInitInode(struct inode *ip, int iagno, int ino, int extno, struct iag * iagp)\n{\n\tstruct jfs_inode_info *jfs_ip = JFS_IP(ip);\n\n\tip->i_ino = (iagno << L2INOSPERIAG) + ino;\n\tjfs_ip->ixpxd = iagp->inoext[extno];\n\tjfs_ip->agstart = le64_to_cpu(iagp->agstart);\n\tjfs_ip->active_ag = -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "release_metapage",
          "args": [
            "mp"
          ],
          "line": 1862
        },
        "resolved": true,
        "details": {
          "function_name": "release_metapage",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_metapage.c",
          "lines": "743-775",
          "snippet": "void release_metapage(struct metapage * mp)\n{\n\tstruct page *page = mp->page;\n\tjfs_info(\"release_metapage: mp = 0x%p, flag = 0x%lx\", mp, mp->flag);\n\n\tBUG_ON(!page);\n\n\tlock_page(page);\n\tunlock_metapage(mp);\n\n\tassert(mp->count);\n\tif (--mp->count || mp->nohomeok) {\n\t\tunlock_page(page);\n\t\tpage_cache_release(page);\n\t\treturn;\n\t}\n\n\tif (test_bit(META_dirty, &mp->flag)) {\n\t\tset_page_dirty(page);\n\t\tif (test_bit(META_sync, &mp->flag)) {\n\t\t\tclear_bit(META_sync, &mp->flag);\n\t\t\twrite_one_page(page, 1);\n\t\t\tlock_page(page); /* write_one_page unlocks the page */\n\t\t}\n\t} else if (mp->lsn)\t/* discard_metapage doesn't remove it */\n\t\tremove_from_logsync(mp);\n\n\t/* Try to keep metapages from using up too much memory */\n\tdrop_metapage(page, mp);\n\n\tunlock_page(page);\n\tpage_cache_release(page);\n}",
          "includes": [
            "#include \"jfs_debug.h\"",
            "#include \"jfs_txnmgr.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_filsys.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/mempool.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/bio.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_txnmgr.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_incore.h\"\n#include <linux/seq_file.h>\n#include <linux/mempool.h>\n#include <linux/buffer_head.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n\nvoid release_metapage(struct metapage * mp)\n{\n\tstruct page *page = mp->page;\n\tjfs_info(\"release_metapage: mp = 0x%p, flag = 0x%lx\", mp, mp->flag);\n\n\tBUG_ON(!page);\n\n\tlock_page(page);\n\tunlock_metapage(mp);\n\n\tassert(mp->count);\n\tif (--mp->count || mp->nohomeok) {\n\t\tunlock_page(page);\n\t\tpage_cache_release(page);\n\t\treturn;\n\t}\n\n\tif (test_bit(META_dirty, &mp->flag)) {\n\t\tset_page_dirty(page);\n\t\tif (test_bit(META_sync, &mp->flag)) {\n\t\t\tclear_bit(META_sync, &mp->flag);\n\t\t\twrite_one_page(page, 1);\n\t\t\tlock_page(page); /* write_one_page unlocks the page */\n\t\t}\n\t} else if (mp->lsn)\t/* discard_metapage doesn't remove it */\n\t\tremove_from_logsync(mp);\n\n\t/* Try to keep metapages from using up too much memory */\n\tdrop_metapage(page, mp);\n\n\tunlock_page(page);\n\tpage_cache_release(page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "IREAD_UNLOCK",
          "args": [
            "imap->im_ipimap"
          ],
          "line": 1860
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "diAllocBit",
          "args": [
            "imap",
            "iagp",
            "ino"
          ],
          "line": 1859
        },
        "resolved": true,
        "details": {
          "function_name": "diAllocBit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_imap.c",
          "lines": "2024-2124",
          "snippet": "static int diAllocBit(struct inomap * imap, struct iag * iagp, int ino)\n{\n\tint extno, bitno, agno, sword, rc;\n\tstruct metapage *amp = NULL, *bmp = NULL;\n\tstruct iag *aiagp = NULL, *biagp = NULL;\n\tu32 mask;\n\n\t/* check if this is the last free inode within the iag.\n\t * if so, it will have to be removed from the ag free\n\t * inode list, so get the iags preceding and following\n\t * it on the list.\n\t */\n\tif (iagp->nfreeinos == cpu_to_le32(1)) {\n\t\tif ((int) le32_to_cpu(iagp->inofreefwd) >= 0) {\n\t\t\tif ((rc =\n\t\t\t     diIAGRead(imap, le32_to_cpu(iagp->inofreefwd),\n\t\t\t\t       &amp)))\n\t\t\t\treturn (rc);\n\t\t\taiagp = (struct iag *) amp->data;\n\t\t}\n\n\t\tif ((int) le32_to_cpu(iagp->inofreeback) >= 0) {\n\t\t\tif ((rc =\n\t\t\t     diIAGRead(imap,\n\t\t\t\t       le32_to_cpu(iagp->inofreeback),\n\t\t\t\t       &bmp))) {\n\t\t\t\tif (amp)\n\t\t\t\t\trelease_metapage(amp);\n\t\t\t\treturn (rc);\n\t\t\t}\n\t\t\tbiagp = (struct iag *) bmp->data;\n\t\t}\n\t}\n\n\t/* get the ag number, extent number, inode number within\n\t * the extent.\n\t */\n\tagno = BLKTOAG(le64_to_cpu(iagp->agstart), JFS_SBI(imap->im_ipimap->i_sb));\n\textno = ino >> L2INOSPEREXT;\n\tbitno = ino & (INOSPEREXT - 1);\n\n\t/* compute the mask for setting the map.\n\t */\n\tmask = HIGHORDER >> bitno;\n\n\t/* the inode should be free and backed.\n\t */\n\tif (((le32_to_cpu(iagp->pmap[extno]) & mask) != 0) ||\n\t    ((le32_to_cpu(iagp->wmap[extno]) & mask) != 0) ||\n\t    (addressPXD(&iagp->inoext[extno]) == 0)) {\n\t\tif (amp)\n\t\t\trelease_metapage(amp);\n\t\tif (bmp)\n\t\t\trelease_metapage(bmp);\n\n\t\tjfs_error(imap->im_ipimap->i_sb, \"iag inconsistent\\n\");\n\t\treturn -EIO;\n\t}\n\n\t/* mark the inode as allocated in the working map.\n\t */\n\tiagp->wmap[extno] |= cpu_to_le32(mask);\n\n\t/* check if all inodes within the extent are now\n\t * allocated.  if so, update the free inode summary\n\t * map to reflect this.\n\t */\n\tif (iagp->wmap[extno] == cpu_to_le32(ONES)) {\n\t\tsword = extno >> L2EXTSPERSUM;\n\t\tbitno = extno & (EXTSPERSUM - 1);\n\t\tiagp->inosmap[sword] |= cpu_to_le32(HIGHORDER >> bitno);\n\t}\n\n\t/* if this was the last free inode in the iag, remove the\n\t * iag from the ag free inode list.\n\t */\n\tif (iagp->nfreeinos == cpu_to_le32(1)) {\n\t\tif (amp) {\n\t\t\taiagp->inofreeback = iagp->inofreeback;\n\t\t\twrite_metapage(amp);\n\t\t}\n\n\t\tif (bmp) {\n\t\t\tbiagp->inofreefwd = iagp->inofreefwd;\n\t\t\twrite_metapage(bmp);\n\t\t} else {\n\t\t\timap->im_agctl[agno].inofree =\n\t\t\t    le32_to_cpu(iagp->inofreefwd);\n\t\t}\n\t\tiagp->inofreefwd = iagp->inofreeback = cpu_to_le32(-1);\n\t}\n\n\t/* update the free inode count at the iag, ag, inode\n\t * map levels.\n\t */\n\tle32_add_cpu(&iagp->nfreeinos, -1);\n\timap->im_agctl[agno].numfree -= 1;\n\tatomic_dec(&imap->im_numfree);\n\n\treturn (0);\n}",
          "includes": [
            "#include \"jfs_debug.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_imap.h\"",
            "#include \"jfs_dmap.h\"",
            "#include \"jfs_dinode.h\"",
            "#include \"jfs_filsys.h\"",
            "#include \"jfs_inode.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/slab.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int diAllocAG(struct inomap *, int, bool, struct inode *);",
            "static int diAllocAny(struct inomap *, int, bool, struct inode *);",
            "static int diAllocBit(struct inomap *, struct iag *, int);",
            "static int diAllocExt(struct inomap *, int, struct inode *);",
            "static int diAllocIno(struct inomap *, int, struct inode *);",
            "static int diFindFree(u32, int);",
            "static int diNewExt(struct inomap *, struct iag *, int);",
            "static int diNewIAG(struct inomap *, int *, int, struct metapage **);",
            "static int diIAGRead(struct inomap * imap, int, struct metapage **);",
            "static int copy_from_dinode(struct dinode *, struct inode *);",
            "static void copy_to_dinode(struct dinode *, struct inode *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_imap.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_dinode.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_inode.h\"\n#include \"jfs_incore.h\"\n#include <linux/slab.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n\nstatic int diAllocAG(struct inomap *, int, bool, struct inode *);\nstatic int diAllocAny(struct inomap *, int, bool, struct inode *);\nstatic int diAllocBit(struct inomap *, struct iag *, int);\nstatic int diAllocExt(struct inomap *, int, struct inode *);\nstatic int diAllocIno(struct inomap *, int, struct inode *);\nstatic int diFindFree(u32, int);\nstatic int diNewExt(struct inomap *, struct iag *, int);\nstatic int diNewIAG(struct inomap *, int *, int, struct metapage **);\nstatic int diIAGRead(struct inomap * imap, int, struct metapage **);\nstatic int copy_from_dinode(struct dinode *, struct inode *);\nstatic void copy_to_dinode(struct dinode *, struct inode *);\n\nstatic int diAllocBit(struct inomap * imap, struct iag * iagp, int ino)\n{\n\tint extno, bitno, agno, sword, rc;\n\tstruct metapage *amp = NULL, *bmp = NULL;\n\tstruct iag *aiagp = NULL, *biagp = NULL;\n\tu32 mask;\n\n\t/* check if this is the last free inode within the iag.\n\t * if so, it will have to be removed from the ag free\n\t * inode list, so get the iags preceding and following\n\t * it on the list.\n\t */\n\tif (iagp->nfreeinos == cpu_to_le32(1)) {\n\t\tif ((int) le32_to_cpu(iagp->inofreefwd) >= 0) {\n\t\t\tif ((rc =\n\t\t\t     diIAGRead(imap, le32_to_cpu(iagp->inofreefwd),\n\t\t\t\t       &amp)))\n\t\t\t\treturn (rc);\n\t\t\taiagp = (struct iag *) amp->data;\n\t\t}\n\n\t\tif ((int) le32_to_cpu(iagp->inofreeback) >= 0) {\n\t\t\tif ((rc =\n\t\t\t     diIAGRead(imap,\n\t\t\t\t       le32_to_cpu(iagp->inofreeback),\n\t\t\t\t       &bmp))) {\n\t\t\t\tif (amp)\n\t\t\t\t\trelease_metapage(amp);\n\t\t\t\treturn (rc);\n\t\t\t}\n\t\t\tbiagp = (struct iag *) bmp->data;\n\t\t}\n\t}\n\n\t/* get the ag number, extent number, inode number within\n\t * the extent.\n\t */\n\tagno = BLKTOAG(le64_to_cpu(iagp->agstart), JFS_SBI(imap->im_ipimap->i_sb));\n\textno = ino >> L2INOSPEREXT;\n\tbitno = ino & (INOSPEREXT - 1);\n\n\t/* compute the mask for setting the map.\n\t */\n\tmask = HIGHORDER >> bitno;\n\n\t/* the inode should be free and backed.\n\t */\n\tif (((le32_to_cpu(iagp->pmap[extno]) & mask) != 0) ||\n\t    ((le32_to_cpu(iagp->wmap[extno]) & mask) != 0) ||\n\t    (addressPXD(&iagp->inoext[extno]) == 0)) {\n\t\tif (amp)\n\t\t\trelease_metapage(amp);\n\t\tif (bmp)\n\t\t\trelease_metapage(bmp);\n\n\t\tjfs_error(imap->im_ipimap->i_sb, \"iag inconsistent\\n\");\n\t\treturn -EIO;\n\t}\n\n\t/* mark the inode as allocated in the working map.\n\t */\n\tiagp->wmap[extno] |= cpu_to_le32(mask);\n\n\t/* check if all inodes within the extent are now\n\t * allocated.  if so, update the free inode summary\n\t * map to reflect this.\n\t */\n\tif (iagp->wmap[extno] == cpu_to_le32(ONES)) {\n\t\tsword = extno >> L2EXTSPERSUM;\n\t\tbitno = extno & (EXTSPERSUM - 1);\n\t\tiagp->inosmap[sword] |= cpu_to_le32(HIGHORDER >> bitno);\n\t}\n\n\t/* if this was the last free inode in the iag, remove the\n\t * iag from the ag free inode list.\n\t */\n\tif (iagp->nfreeinos == cpu_to_le32(1)) {\n\t\tif (amp) {\n\t\t\taiagp->inofreeback = iagp->inofreeback;\n\t\t\twrite_metapage(amp);\n\t\t}\n\n\t\tif (bmp) {\n\t\t\tbiagp->inofreefwd = iagp->inofreefwd;\n\t\t\twrite_metapage(bmp);\n\t\t} else {\n\t\t\timap->im_agctl[agno].inofree =\n\t\t\t    le32_to_cpu(iagp->inofreefwd);\n\t\t}\n\t\tiagp->inofreefwd = iagp->inofreeback = cpu_to_le32(-1);\n\t}\n\n\t/* update the free inode count at the iag, ag, inode\n\t * map levels.\n\t */\n\tle32_add_cpu(&iagp->nfreeinos, -1);\n\timap->im_agctl[agno].numfree -= 1;\n\tatomic_dec(&imap->im_numfree);\n\n\treturn (0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "jfs_error",
          "args": [
            "ip->i_sb",
            "\"free inode not found\\n\""
          ],
          "line": 1849
        },
        "resolved": true,
        "details": {
          "function_name": "jfs_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/super.c",
          "lines": "95-111",
          "snippet": "void jfs_error(struct super_block *sb, const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tva_start(args, fmt);\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tpr_err(\"ERROR: (device %s): %pf: %pV\\n\",\n\t       sb->s_id, __builtin_return_address(0), &vaf);\n\n\tva_end(args);\n\n\tjfs_handle_error(sb);\n}",
          "includes": [
            "#include \"jfs_xattr.h\"",
            "#include \"jfs_debug.h\"",
            "#include \"jfs_acl.h\"",
            "#include \"jfs_imap.h\"",
            "#include \"jfs_dmap.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_inode.h\"",
            "#include \"jfs_filsys.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/blkdev.h>",
            "#include <linux/seq_file.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/crc32.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/mount.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/vfs.h>",
            "#include <linux/completion.h>",
            "#include <linux/parser.h>",
            "#include <linux/module.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_xattr.h\"\n#include \"jfs_debug.h\"\n#include \"jfs_acl.h\"\n#include \"jfs_imap.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_inode.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_incore.h\"\n#include <linux/blkdev.h>\n#include <linux/seq_file.h>\n#include <asm/uaccess.h>\n#include <linux/slab.h>\n#include <linux/crc32.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/posix_acl.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/mount.h>\n#include <linux/quotaops.h>\n#include <linux/vfs.h>\n#include <linux/completion.h>\n#include <linux/parser.h>\n#include <linux/module.h>\n#include <linux/fs.h>\n\nvoid jfs_error(struct super_block *sb, const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tva_start(args, fmt);\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tpr_err(\"ERROR: (device %s): %pf: %pV\\n\",\n\t       sb->s_id, __builtin_return_address(0), &vaf);\n\n\tva_end(args);\n\n\tjfs_handle_error(sb);\n}"
        }
      },
      {
        "call_info": {
          "callee": "IREAD_UNLOCK",
          "args": [
            "imap->im_ipimap"
          ],
          "line": 1847
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "diFindFree",
          "args": [
            "le32_to_cpu(iagp->wmap[extno])",
            "0"
          ],
          "line": 1845
        },
        "resolved": true,
        "details": {
          "function_name": "diFindFree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_imap.c",
          "lines": "2706-2717",
          "snippet": "static int diFindFree(u32 word, int start)\n{\n\tint bitno;\n\tassert(start < 32);\n\t/* scan the word for the first free bit. */\n\tfor (word <<= start, bitno = start; bitno < 32;\n\t     bitno++, word <<= 1) {\n\t\tif ((word & HIGHORDER) == 0)\n\t\t\tbreak;\n\t}\n\treturn (bitno);\n}",
          "includes": [
            "#include \"jfs_debug.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_imap.h\"",
            "#include \"jfs_dmap.h\"",
            "#include \"jfs_dinode.h\"",
            "#include \"jfs_filsys.h\"",
            "#include \"jfs_inode.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/slab.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int diFindFree(u32, int);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_imap.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_dinode.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_inode.h\"\n#include \"jfs_incore.h\"\n#include <linux/slab.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n\nstatic int diFindFree(u32, int);\n\nstatic int diFindFree(u32 word, int start)\n{\n\tint bitno;\n\tassert(start < 32);\n\t/* scan the word for the first free bit. */\n\tfor (word <<= start, bitno = start; bitno < 32;\n\t     bitno++, word <<= 1) {\n\t\tif ((word & HIGHORDER) == 0)\n\t\t\tbreak;\n\t}\n\treturn (bitno);\n}"
        }
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "iagp->wmap[extno]"
          ],
          "line": 1845
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "IREAD_UNLOCK",
          "args": [
            "imap->im_ipimap"
          ],
          "line": 1836
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IREAD_UNLOCK",
          "args": [
            "imap->im_ipimap"
          ],
          "line": 1820
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IREAD_UNLOCK",
          "args": [
            "imap->im_ipimap"
          ],
          "line": 1809
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IREAD_UNLOCK",
          "args": [
            "imap->im_ipimap"
          ],
          "line": 1800
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "diIAGRead",
          "args": [
            "imap",
            "iagno",
            "&mp"
          ],
          "line": 1799
        },
        "resolved": true,
        "details": {
          "function_name": "diIAGRead",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_imap.c",
          "lines": "2675-2690",
          "snippet": "static int diIAGRead(struct inomap * imap, int iagno, struct metapage ** mpp)\n{\n\tstruct inode *ipimap = imap->im_ipimap;\n\ts64 blkno;\n\n\t/* compute the logical block number of the iag. */\n\tblkno = IAGTOLBLK(iagno, JFS_SBI(ipimap->i_sb)->l2nbperpage);\n\n\t/* read the iag. */\n\t*mpp = read_metapage(ipimap, blkno, PSIZE, 0);\n\tif (*mpp == NULL) {\n\t\treturn -EIO;\n\t}\n\n\treturn (0);\n}",
          "includes": [
            "#include \"jfs_debug.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_imap.h\"",
            "#include \"jfs_dmap.h\"",
            "#include \"jfs_dinode.h\"",
            "#include \"jfs_filsys.h\"",
            "#include \"jfs_inode.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/slab.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int diAllocAG(struct inomap *, int, bool, struct inode *);",
            "static int diAllocAny(struct inomap *, int, bool, struct inode *);",
            "static int diAllocBit(struct inomap *, struct iag *, int);",
            "static int diAllocExt(struct inomap *, int, struct inode *);",
            "static int diAllocIno(struct inomap *, int, struct inode *);",
            "static int diNewExt(struct inomap *, struct iag *, int);",
            "static int diNewIAG(struct inomap *, int *, int, struct metapage **);",
            "static void duplicateIXtree(struct super_block *, s64, int, s64 *);",
            "static int diIAGRead(struct inomap * imap, int, struct metapage **);",
            "static int copy_from_dinode(struct dinode *, struct inode *);",
            "static void copy_to_dinode(struct dinode *, struct inode *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_imap.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_dinode.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_inode.h\"\n#include \"jfs_incore.h\"\n#include <linux/slab.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n\nstatic int diAllocAG(struct inomap *, int, bool, struct inode *);\nstatic int diAllocAny(struct inomap *, int, bool, struct inode *);\nstatic int diAllocBit(struct inomap *, struct iag *, int);\nstatic int diAllocExt(struct inomap *, int, struct inode *);\nstatic int diAllocIno(struct inomap *, int, struct inode *);\nstatic int diNewExt(struct inomap *, struct iag *, int);\nstatic int diNewIAG(struct inomap *, int *, int, struct metapage **);\nstatic void duplicateIXtree(struct super_block *, s64, int, s64 *);\nstatic int diIAGRead(struct inomap * imap, int, struct metapage **);\nstatic int copy_from_dinode(struct dinode *, struct inode *);\nstatic void copy_to_dinode(struct dinode *, struct inode *);\n\nstatic int diIAGRead(struct inomap * imap, int iagno, struct metapage ** mpp)\n{\n\tstruct inode *ipimap = imap->im_ipimap;\n\ts64 blkno;\n\n\t/* compute the logical block number of the iag. */\n\tblkno = IAGTOLBLK(iagno, JFS_SBI(ipimap->i_sb)->l2nbperpage);\n\n\t/* read the iag. */\n\t*mpp = read_metapage(ipimap, blkno, PSIZE, 0);\n\tif (*mpp == NULL) {\n\t\treturn -EIO;\n\t}\n\n\treturn (0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "IREAD_LOCK",
          "args": [
            "imap->im_ipimap",
            "RDWRLOCK_IMAP"
          ],
          "line": 1795
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_imap.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_dinode.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_inode.h\"\n#include \"jfs_incore.h\"\n#include <linux/slab.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n\nstatic int diAllocAG(struct inomap *, int, bool, struct inode *);\nstatic int diAllocAny(struct inomap *, int, bool, struct inode *);\nstatic int diAllocBit(struct inomap *, struct iag *, int);\nstatic int diAllocExt(struct inomap *, int, struct inode *);\nstatic int diAllocIno(struct inomap *, int, struct inode *);\nstatic int diNewExt(struct inomap *, struct iag *, int);\nstatic int diNewIAG(struct inomap *, int *, int, struct metapage **);\nstatic int diIAGRead(struct inomap * imap, int, struct metapage **);\nstatic int copy_from_dinode(struct dinode *, struct inode *);\nstatic void copy_to_dinode(struct dinode *, struct inode *);\n\nstatic int diAllocIno(struct inomap * imap, int agno, struct inode *ip)\n{\n\tint iagno, ino, rc, rem, extno, sword;\n\tstruct metapage *mp;\n\tstruct iag *iagp;\n\n\t/* check if there are iags on the ag's free inode list.\n\t */\n\tif ((iagno = imap->im_agctl[agno].inofree) < 0)\n\t\treturn -ENOSPC;\n\n\t/* obtain read lock on imap inode */\n\tIREAD_LOCK(imap->im_ipimap, RDWRLOCK_IMAP);\n\n\t/* read the iag at the head of the list.\n\t */\n\tif ((rc = diIAGRead(imap, iagno, &mp))) {\n\t\tIREAD_UNLOCK(imap->im_ipimap);\n\t\treturn (rc);\n\t}\n\tiagp = (struct iag *) mp->data;\n\n\t/* better be free inodes in this iag if it is on the\n\t * list.\n\t */\n\tif (!iagp->nfreeinos) {\n\t\tIREAD_UNLOCK(imap->im_ipimap);\n\t\trelease_metapage(mp);\n\t\tjfs_error(ip->i_sb, \"nfreeinos = 0, but iag on freelist\\n\");\n\t\treturn -EIO;\n\t}\n\n\t/* scan the free inode summary map to find an extent\n\t * with free inodes.\n\t */\n\tfor (sword = 0;; sword++) {\n\t\tif (sword >= SMAPSZ) {\n\t\t\tIREAD_UNLOCK(imap->im_ipimap);\n\t\t\trelease_metapage(mp);\n\t\t\tjfs_error(ip->i_sb,\n\t\t\t\t  \"free inode not found in summary map\\n\");\n\t\t\treturn -EIO;\n\t\t}\n\n\t\tif (~iagp->inosmap[sword])\n\t\t\tbreak;\n\t}\n\n\t/* found a extent with free inodes. determine\n\t * the extent number.\n\t */\n\trem = diFindFree(le32_to_cpu(iagp->inosmap[sword]), 0);\n\tif (rem >= EXTSPERSUM) {\n\t\tIREAD_UNLOCK(imap->im_ipimap);\n\t\trelease_metapage(mp);\n\t\tjfs_error(ip->i_sb, \"no free extent found\\n\");\n\t\treturn -EIO;\n\t}\n\textno = (sword << L2EXTSPERSUM) + rem;\n\n\t/* find the first free inode in the extent.\n\t */\n\trem = diFindFree(le32_to_cpu(iagp->wmap[extno]), 0);\n\tif (rem >= INOSPEREXT) {\n\t\tIREAD_UNLOCK(imap->im_ipimap);\n\t\trelease_metapage(mp);\n\t\tjfs_error(ip->i_sb, \"free inode not found\\n\");\n\t\treturn -EIO;\n\t}\n\n\t/* compute the inode number within the iag.\n\t */\n\tino = (extno << L2INOSPEREXT) + rem;\n\n\t/* allocate the inode.\n\t */\n\trc = diAllocBit(imap, iagp, ino);\n\tIREAD_UNLOCK(imap->im_ipimap);\n\tif (rc) {\n\t\trelease_metapage(mp);\n\t\treturn (rc);\n\t}\n\n\t/* set the results of the allocation and write the iag.\n\t */\n\tdiInitInode(ip, iagno, ino, extno, iagp);\n\twrite_metapage(mp);\n\n\treturn (0);\n}"
  },
  {
    "function_name": "diAllocAny",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_imap.c",
    "lines": "1718-1755",
    "snippet": "static int\ndiAllocAny(struct inomap * imap, int agno, bool dir, struct inode *ip)\n{\n\tint ag, rc;\n\tint maxag = JFS_SBI(imap->im_ipimap->i_sb)->bmap->db_maxag;\n\n\n\t/* try to allocate from the ags following agno up to\n\t * the maximum ag number.\n\t */\n\tfor (ag = agno + 1; ag <= maxag; ag++) {\n\t\tAG_LOCK(imap, ag);\n\n\t\trc = diAllocAG(imap, ag, dir, ip);\n\n\t\tAG_UNLOCK(imap, ag);\n\n\t\tif (rc != -ENOSPC)\n\t\t\treturn (rc);\n\t}\n\n\t/* try to allocate from the ags in front of agno.\n\t */\n\tfor (ag = 0; ag < agno; ag++) {\n\t\tAG_LOCK(imap, ag);\n\n\t\trc = diAllocAG(imap, ag, dir, ip);\n\n\t\tAG_UNLOCK(imap, ag);\n\n\t\tif (rc != -ENOSPC)\n\t\t\treturn (rc);\n\t}\n\n\t/* no free disk inodes.\n\t */\n\treturn -ENOSPC;\n}",
    "includes": [
      "#include \"jfs_debug.h\"",
      "#include \"jfs_superblock.h\"",
      "#include \"jfs_metapage.h\"",
      "#include \"jfs_imap.h\"",
      "#include \"jfs_dmap.h\"",
      "#include \"jfs_dinode.h\"",
      "#include \"jfs_filsys.h\"",
      "#include \"jfs_inode.h\"",
      "#include \"jfs_incore.h\"",
      "#include <linux/slab.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int diAllocAG(struct inomap *, int, bool, struct inode *);",
      "static int diAllocAny(struct inomap *, int, bool, struct inode *);",
      "static int diAllocExt(struct inomap *, int, struct inode *);",
      "static int diAllocIno(struct inomap *, int, struct inode *);",
      "static int copy_from_dinode(struct dinode *, struct inode *);",
      "static void copy_to_dinode(struct dinode *, struct inode *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "AG_UNLOCK",
          "args": [
            "imap",
            "ag"
          ],
          "line": 1746
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "diAllocAG",
          "args": [
            "imap",
            "ag",
            "dir",
            "ip"
          ],
          "line": 1744
        },
        "resolved": true,
        "details": {
          "function_name": "diAllocAG",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_imap.c",
          "lines": "1648-1692",
          "snippet": "static int\ndiAllocAG(struct inomap * imap, int agno, bool dir, struct inode *ip)\n{\n\tint rc, addext, numfree, numinos;\n\n\t/* get the number of free and the number of backed disk\n\t * inodes currently within the ag.\n\t */\n\tnumfree = imap->im_agctl[agno].numfree;\n\tnuminos = imap->im_agctl[agno].numinos;\n\n\tif (numfree > numinos) {\n\t\tjfs_error(ip->i_sb, \"numfree > numinos\\n\");\n\t\treturn -EIO;\n\t}\n\n\t/* determine if we should allocate a new extent of free inodes\n\t * within the ag: for directory inodes, add a new extent\n\t * if there are a small number of free inodes or number of free\n\t * inodes is a small percentage of the number of backed inodes.\n\t */\n\tif (dir)\n\t\taddext = (numfree < 64 ||\n\t\t\t  (numfree < 256\n\t\t\t   && ((numfree * 100) / numinos) <= 20));\n\telse\n\t\taddext = (numfree == 0);\n\n\t/*\n\t * try to allocate a new extent of free inodes.\n\t */\n\tif (addext) {\n\t\t/* if free space is not available for this new extent, try\n\t\t * below to allocate a free and existing (already backed)\n\t\t * inode from the ag.\n\t\t */\n\t\tif ((rc = diAllocExt(imap, agno, ip)) != -ENOSPC)\n\t\t\treturn (rc);\n\t}\n\n\t/*\n\t * try to allocate an existing free inode from the ag.\n\t */\n\treturn (diAllocIno(imap, agno, ip));\n}",
          "includes": [
            "#include \"jfs_debug.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_imap.h\"",
            "#include \"jfs_dmap.h\"",
            "#include \"jfs_dinode.h\"",
            "#include \"jfs_filsys.h\"",
            "#include \"jfs_inode.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/slab.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int diAllocAG(struct inomap *, int, bool, struct inode *);",
            "static int diAllocAny(struct inomap *, int, bool, struct inode *);",
            "static int diAllocExt(struct inomap *, int, struct inode *);",
            "static int diAllocIno(struct inomap *, int, struct inode *);",
            "static int copy_from_dinode(struct dinode *, struct inode *);",
            "static void copy_to_dinode(struct dinode *, struct inode *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_imap.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_dinode.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_inode.h\"\n#include \"jfs_incore.h\"\n#include <linux/slab.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n\nstatic int diAllocAG(struct inomap *, int, bool, struct inode *);\nstatic int diAllocAny(struct inomap *, int, bool, struct inode *);\nstatic int diAllocExt(struct inomap *, int, struct inode *);\nstatic int diAllocIno(struct inomap *, int, struct inode *);\nstatic int copy_from_dinode(struct dinode *, struct inode *);\nstatic void copy_to_dinode(struct dinode *, struct inode *);\n\nstatic int\ndiAllocAG(struct inomap * imap, int agno, bool dir, struct inode *ip)\n{\n\tint rc, addext, numfree, numinos;\n\n\t/* get the number of free and the number of backed disk\n\t * inodes currently within the ag.\n\t */\n\tnumfree = imap->im_agctl[agno].numfree;\n\tnuminos = imap->im_agctl[agno].numinos;\n\n\tif (numfree > numinos) {\n\t\tjfs_error(ip->i_sb, \"numfree > numinos\\n\");\n\t\treturn -EIO;\n\t}\n\n\t/* determine if we should allocate a new extent of free inodes\n\t * within the ag: for directory inodes, add a new extent\n\t * if there are a small number of free inodes or number of free\n\t * inodes is a small percentage of the number of backed inodes.\n\t */\n\tif (dir)\n\t\taddext = (numfree < 64 ||\n\t\t\t  (numfree < 256\n\t\t\t   && ((numfree * 100) / numinos) <= 20));\n\telse\n\t\taddext = (numfree == 0);\n\n\t/*\n\t * try to allocate a new extent of free inodes.\n\t */\n\tif (addext) {\n\t\t/* if free space is not available for this new extent, try\n\t\t * below to allocate a free and existing (already backed)\n\t\t * inode from the ag.\n\t\t */\n\t\tif ((rc = diAllocExt(imap, agno, ip)) != -ENOSPC)\n\t\t\treturn (rc);\n\t}\n\n\t/*\n\t * try to allocate an existing free inode from the ag.\n\t */\n\treturn (diAllocIno(imap, agno, ip));\n}"
        }
      },
      {
        "call_info": {
          "callee": "AG_LOCK",
          "args": [
            "imap",
            "ag"
          ],
          "line": 1742
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AG_UNLOCK",
          "args": [
            "imap",
            "ag"
          ],
          "line": 1733
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AG_LOCK",
          "args": [
            "imap",
            "ag"
          ],
          "line": 1729
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "JFS_SBI",
          "args": [
            "imap->im_ipimap->i_sb"
          ],
          "line": 1722
        },
        "resolved": true,
        "details": {
          "function_name": "JFS_SBI",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_incore.h",
          "lines": "217-220",
          "snippet": "static inline struct jfs_sb_info *JFS_SBI(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"jfs_dtree.h\"",
            "#include \"jfs_xtree.h\"",
            "#include \"jfs_types.h\"",
            "#include <linux/bitops.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_dtree.h\"\n#include \"jfs_xtree.h\"\n#include \"jfs_types.h\"\n#include <linux/bitops.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mutex.h>\n\nstatic inline struct jfs_sb_info *JFS_SBI(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_imap.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_dinode.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_inode.h\"\n#include \"jfs_incore.h\"\n#include <linux/slab.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n\nstatic int diAllocAG(struct inomap *, int, bool, struct inode *);\nstatic int diAllocAny(struct inomap *, int, bool, struct inode *);\nstatic int diAllocExt(struct inomap *, int, struct inode *);\nstatic int diAllocIno(struct inomap *, int, struct inode *);\nstatic int copy_from_dinode(struct dinode *, struct inode *);\nstatic void copy_to_dinode(struct dinode *, struct inode *);\n\nstatic int\ndiAllocAny(struct inomap * imap, int agno, bool dir, struct inode *ip)\n{\n\tint ag, rc;\n\tint maxag = JFS_SBI(imap->im_ipimap->i_sb)->bmap->db_maxag;\n\n\n\t/* try to allocate from the ags following agno up to\n\t * the maximum ag number.\n\t */\n\tfor (ag = agno + 1; ag <= maxag; ag++) {\n\t\tAG_LOCK(imap, ag);\n\n\t\trc = diAllocAG(imap, ag, dir, ip);\n\n\t\tAG_UNLOCK(imap, ag);\n\n\t\tif (rc != -ENOSPC)\n\t\t\treturn (rc);\n\t}\n\n\t/* try to allocate from the ags in front of agno.\n\t */\n\tfor (ag = 0; ag < agno; ag++) {\n\t\tAG_LOCK(imap, ag);\n\n\t\trc = diAllocAG(imap, ag, dir, ip);\n\n\t\tAG_UNLOCK(imap, ag);\n\n\t\tif (rc != -ENOSPC)\n\t\t\treturn (rc);\n\t}\n\n\t/* no free disk inodes.\n\t */\n\treturn -ENOSPC;\n}"
  },
  {
    "function_name": "diAllocAG",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_imap.c",
    "lines": "1648-1692",
    "snippet": "static int\ndiAllocAG(struct inomap * imap, int agno, bool dir, struct inode *ip)\n{\n\tint rc, addext, numfree, numinos;\n\n\t/* get the number of free and the number of backed disk\n\t * inodes currently within the ag.\n\t */\n\tnumfree = imap->im_agctl[agno].numfree;\n\tnuminos = imap->im_agctl[agno].numinos;\n\n\tif (numfree > numinos) {\n\t\tjfs_error(ip->i_sb, \"numfree > numinos\\n\");\n\t\treturn -EIO;\n\t}\n\n\t/* determine if we should allocate a new extent of free inodes\n\t * within the ag: for directory inodes, add a new extent\n\t * if there are a small number of free inodes or number of free\n\t * inodes is a small percentage of the number of backed inodes.\n\t */\n\tif (dir)\n\t\taddext = (numfree < 64 ||\n\t\t\t  (numfree < 256\n\t\t\t   && ((numfree * 100) / numinos) <= 20));\n\telse\n\t\taddext = (numfree == 0);\n\n\t/*\n\t * try to allocate a new extent of free inodes.\n\t */\n\tif (addext) {\n\t\t/* if free space is not available for this new extent, try\n\t\t * below to allocate a free and existing (already backed)\n\t\t * inode from the ag.\n\t\t */\n\t\tif ((rc = diAllocExt(imap, agno, ip)) != -ENOSPC)\n\t\t\treturn (rc);\n\t}\n\n\t/*\n\t * try to allocate an existing free inode from the ag.\n\t */\n\treturn (diAllocIno(imap, agno, ip));\n}",
    "includes": [
      "#include \"jfs_debug.h\"",
      "#include \"jfs_superblock.h\"",
      "#include \"jfs_metapage.h\"",
      "#include \"jfs_imap.h\"",
      "#include \"jfs_dmap.h\"",
      "#include \"jfs_dinode.h\"",
      "#include \"jfs_filsys.h\"",
      "#include \"jfs_inode.h\"",
      "#include \"jfs_incore.h\"",
      "#include <linux/slab.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int diAllocAG(struct inomap *, int, bool, struct inode *);",
      "static int diAllocAny(struct inomap *, int, bool, struct inode *);",
      "static int diAllocExt(struct inomap *, int, struct inode *);",
      "static int diAllocIno(struct inomap *, int, struct inode *);",
      "static int copy_from_dinode(struct dinode *, struct inode *);",
      "static void copy_to_dinode(struct dinode *, struct inode *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "diAllocIno",
          "args": [
            "imap",
            "agno",
            "ip"
          ],
          "line": 1691
        },
        "resolved": true,
        "details": {
          "function_name": "diAllocIno",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_imap.c",
          "lines": "1783-1872",
          "snippet": "static int diAllocIno(struct inomap * imap, int agno, struct inode *ip)\n{\n\tint iagno, ino, rc, rem, extno, sword;\n\tstruct metapage *mp;\n\tstruct iag *iagp;\n\n\t/* check if there are iags on the ag's free inode list.\n\t */\n\tif ((iagno = imap->im_agctl[agno].inofree) < 0)\n\t\treturn -ENOSPC;\n\n\t/* obtain read lock on imap inode */\n\tIREAD_LOCK(imap->im_ipimap, RDWRLOCK_IMAP);\n\n\t/* read the iag at the head of the list.\n\t */\n\tif ((rc = diIAGRead(imap, iagno, &mp))) {\n\t\tIREAD_UNLOCK(imap->im_ipimap);\n\t\treturn (rc);\n\t}\n\tiagp = (struct iag *) mp->data;\n\n\t/* better be free inodes in this iag if it is on the\n\t * list.\n\t */\n\tif (!iagp->nfreeinos) {\n\t\tIREAD_UNLOCK(imap->im_ipimap);\n\t\trelease_metapage(mp);\n\t\tjfs_error(ip->i_sb, \"nfreeinos = 0, but iag on freelist\\n\");\n\t\treturn -EIO;\n\t}\n\n\t/* scan the free inode summary map to find an extent\n\t * with free inodes.\n\t */\n\tfor (sword = 0;; sword++) {\n\t\tif (sword >= SMAPSZ) {\n\t\t\tIREAD_UNLOCK(imap->im_ipimap);\n\t\t\trelease_metapage(mp);\n\t\t\tjfs_error(ip->i_sb,\n\t\t\t\t  \"free inode not found in summary map\\n\");\n\t\t\treturn -EIO;\n\t\t}\n\n\t\tif (~iagp->inosmap[sword])\n\t\t\tbreak;\n\t}\n\n\t/* found a extent with free inodes. determine\n\t * the extent number.\n\t */\n\trem = diFindFree(le32_to_cpu(iagp->inosmap[sword]), 0);\n\tif (rem >= EXTSPERSUM) {\n\t\tIREAD_UNLOCK(imap->im_ipimap);\n\t\trelease_metapage(mp);\n\t\tjfs_error(ip->i_sb, \"no free extent found\\n\");\n\t\treturn -EIO;\n\t}\n\textno = (sword << L2EXTSPERSUM) + rem;\n\n\t/* find the first free inode in the extent.\n\t */\n\trem = diFindFree(le32_to_cpu(iagp->wmap[extno]), 0);\n\tif (rem >= INOSPEREXT) {\n\t\tIREAD_UNLOCK(imap->im_ipimap);\n\t\trelease_metapage(mp);\n\t\tjfs_error(ip->i_sb, \"free inode not found\\n\");\n\t\treturn -EIO;\n\t}\n\n\t/* compute the inode number within the iag.\n\t */\n\tino = (extno << L2INOSPEREXT) + rem;\n\n\t/* allocate the inode.\n\t */\n\trc = diAllocBit(imap, iagp, ino);\n\tIREAD_UNLOCK(imap->im_ipimap);\n\tif (rc) {\n\t\trelease_metapage(mp);\n\t\treturn (rc);\n\t}\n\n\t/* set the results of the allocation and write the iag.\n\t */\n\tdiInitInode(ip, iagno, ino, extno, iagp);\n\twrite_metapage(mp);\n\n\treturn (0);\n}",
          "includes": [
            "#include \"jfs_debug.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_imap.h\"",
            "#include \"jfs_dmap.h\"",
            "#include \"jfs_dinode.h\"",
            "#include \"jfs_filsys.h\"",
            "#include \"jfs_inode.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/slab.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int diAllocAG(struct inomap *, int, bool, struct inode *);",
            "static int diAllocAny(struct inomap *, int, bool, struct inode *);",
            "static int diAllocBit(struct inomap *, struct iag *, int);",
            "static int diAllocExt(struct inomap *, int, struct inode *);",
            "static int diAllocIno(struct inomap *, int, struct inode *);",
            "static int diNewExt(struct inomap *, struct iag *, int);",
            "static int diNewIAG(struct inomap *, int *, int, struct metapage **);",
            "static int diIAGRead(struct inomap * imap, int, struct metapage **);",
            "static int copy_from_dinode(struct dinode *, struct inode *);",
            "static void copy_to_dinode(struct dinode *, struct inode *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_imap.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_dinode.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_inode.h\"\n#include \"jfs_incore.h\"\n#include <linux/slab.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n\nstatic int diAllocAG(struct inomap *, int, bool, struct inode *);\nstatic int diAllocAny(struct inomap *, int, bool, struct inode *);\nstatic int diAllocBit(struct inomap *, struct iag *, int);\nstatic int diAllocExt(struct inomap *, int, struct inode *);\nstatic int diAllocIno(struct inomap *, int, struct inode *);\nstatic int diNewExt(struct inomap *, struct iag *, int);\nstatic int diNewIAG(struct inomap *, int *, int, struct metapage **);\nstatic int diIAGRead(struct inomap * imap, int, struct metapage **);\nstatic int copy_from_dinode(struct dinode *, struct inode *);\nstatic void copy_to_dinode(struct dinode *, struct inode *);\n\nstatic int diAllocIno(struct inomap * imap, int agno, struct inode *ip)\n{\n\tint iagno, ino, rc, rem, extno, sword;\n\tstruct metapage *mp;\n\tstruct iag *iagp;\n\n\t/* check if there are iags on the ag's free inode list.\n\t */\n\tif ((iagno = imap->im_agctl[agno].inofree) < 0)\n\t\treturn -ENOSPC;\n\n\t/* obtain read lock on imap inode */\n\tIREAD_LOCK(imap->im_ipimap, RDWRLOCK_IMAP);\n\n\t/* read the iag at the head of the list.\n\t */\n\tif ((rc = diIAGRead(imap, iagno, &mp))) {\n\t\tIREAD_UNLOCK(imap->im_ipimap);\n\t\treturn (rc);\n\t}\n\tiagp = (struct iag *) mp->data;\n\n\t/* better be free inodes in this iag if it is on the\n\t * list.\n\t */\n\tif (!iagp->nfreeinos) {\n\t\tIREAD_UNLOCK(imap->im_ipimap);\n\t\trelease_metapage(mp);\n\t\tjfs_error(ip->i_sb, \"nfreeinos = 0, but iag on freelist\\n\");\n\t\treturn -EIO;\n\t}\n\n\t/* scan the free inode summary map to find an extent\n\t * with free inodes.\n\t */\n\tfor (sword = 0;; sword++) {\n\t\tif (sword >= SMAPSZ) {\n\t\t\tIREAD_UNLOCK(imap->im_ipimap);\n\t\t\trelease_metapage(mp);\n\t\t\tjfs_error(ip->i_sb,\n\t\t\t\t  \"free inode not found in summary map\\n\");\n\t\t\treturn -EIO;\n\t\t}\n\n\t\tif (~iagp->inosmap[sword])\n\t\t\tbreak;\n\t}\n\n\t/* found a extent with free inodes. determine\n\t * the extent number.\n\t */\n\trem = diFindFree(le32_to_cpu(iagp->inosmap[sword]), 0);\n\tif (rem >= EXTSPERSUM) {\n\t\tIREAD_UNLOCK(imap->im_ipimap);\n\t\trelease_metapage(mp);\n\t\tjfs_error(ip->i_sb, \"no free extent found\\n\");\n\t\treturn -EIO;\n\t}\n\textno = (sword << L2EXTSPERSUM) + rem;\n\n\t/* find the first free inode in the extent.\n\t */\n\trem = diFindFree(le32_to_cpu(iagp->wmap[extno]), 0);\n\tif (rem >= INOSPEREXT) {\n\t\tIREAD_UNLOCK(imap->im_ipimap);\n\t\trelease_metapage(mp);\n\t\tjfs_error(ip->i_sb, \"free inode not found\\n\");\n\t\treturn -EIO;\n\t}\n\n\t/* compute the inode number within the iag.\n\t */\n\tino = (extno << L2INOSPEREXT) + rem;\n\n\t/* allocate the inode.\n\t */\n\trc = diAllocBit(imap, iagp, ino);\n\tIREAD_UNLOCK(imap->im_ipimap);\n\tif (rc) {\n\t\trelease_metapage(mp);\n\t\treturn (rc);\n\t}\n\n\t/* set the results of the allocation and write the iag.\n\t */\n\tdiInitInode(ip, iagno, ino, extno, iagp);\n\twrite_metapage(mp);\n\n\treturn (0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "diAllocExt",
          "args": [
            "imap",
            "agno",
            "ip"
          ],
          "line": 1684
        },
        "resolved": true,
        "details": {
          "function_name": "diAllocExt",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_imap.c",
          "lines": "1907-1991",
          "snippet": "static int diAllocExt(struct inomap * imap, int agno, struct inode *ip)\n{\n\tint rem, iagno, sword, extno, rc;\n\tstruct metapage *mp;\n\tstruct iag *iagp;\n\n\t/* check if the ag has any iags with free extents.  if not,\n\t * allocate a new iag for the ag.\n\t */\n\tif ((iagno = imap->im_agctl[agno].extfree) < 0) {\n\t\t/* If successful, diNewIAG will obtain the read lock on the\n\t\t * imap inode.\n\t\t */\n\t\tif ((rc = diNewIAG(imap, &iagno, agno, &mp))) {\n\t\t\treturn (rc);\n\t\t}\n\t\tiagp = (struct iag *) mp->data;\n\n\t\t/* set the ag number if this a brand new iag\n\t\t */\n\t\tiagp->agstart =\n\t\t    cpu_to_le64(AGTOBLK(agno, imap->im_ipimap));\n\t} else {\n\t\t/* read the iag.\n\t\t */\n\t\tIREAD_LOCK(imap->im_ipimap, RDWRLOCK_IMAP);\n\t\tif ((rc = diIAGRead(imap, iagno, &mp))) {\n\t\t\tIREAD_UNLOCK(imap->im_ipimap);\n\t\t\tjfs_error(ip->i_sb, \"error reading iag\\n\");\n\t\t\treturn rc;\n\t\t}\n\t\tiagp = (struct iag *) mp->data;\n\t}\n\n\t/* using the free extent summary map, find a free extent.\n\t */\n\tfor (sword = 0;; sword++) {\n\t\tif (sword >= SMAPSZ) {\n\t\t\trelease_metapage(mp);\n\t\t\tIREAD_UNLOCK(imap->im_ipimap);\n\t\t\tjfs_error(ip->i_sb, \"free ext summary map not found\\n\");\n\t\t\treturn -EIO;\n\t\t}\n\t\tif (~iagp->extsmap[sword])\n\t\t\tbreak;\n\t}\n\n\t/* determine the extent number of the free extent.\n\t */\n\trem = diFindFree(le32_to_cpu(iagp->extsmap[sword]), 0);\n\tif (rem >= EXTSPERSUM) {\n\t\trelease_metapage(mp);\n\t\tIREAD_UNLOCK(imap->im_ipimap);\n\t\tjfs_error(ip->i_sb, \"free extent not found\\n\");\n\t\treturn -EIO;\n\t}\n\textno = (sword << L2EXTSPERSUM) + rem;\n\n\t/* initialize the new extent.\n\t */\n\trc = diNewExt(imap, iagp, extno);\n\tIREAD_UNLOCK(imap->im_ipimap);\n\tif (rc) {\n\t\t/* something bad happened.  if a new iag was allocated,\n\t\t * place it back on the inode map's iag free list, and\n\t\t * clear the ag number information.\n\t\t */\n\t\tif (iagp->nfreeexts == cpu_to_le32(EXTSPERIAG)) {\n\t\t\tIAGFREE_LOCK(imap);\n\t\t\tiagp->iagfree = cpu_to_le32(imap->im_freeiag);\n\t\t\timap->im_freeiag = iagno;\n\t\t\tIAGFREE_UNLOCK(imap);\n\t\t}\n\t\twrite_metapage(mp);\n\t\treturn (rc);\n\t}\n\n\t/* set the results of the allocation and write the iag.\n\t */\n\tdiInitInode(ip, iagno, extno << L2INOSPEREXT, extno, iagp);\n\n\twrite_metapage(mp);\n\n\treturn (0);\n}",
          "includes": [
            "#include \"jfs_debug.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_imap.h\"",
            "#include \"jfs_dmap.h\"",
            "#include \"jfs_dinode.h\"",
            "#include \"jfs_filsys.h\"",
            "#include \"jfs_inode.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/slab.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int diAllocAG(struct inomap *, int, bool, struct inode *);",
            "static int diAllocAny(struct inomap *, int, bool, struct inode *);",
            "static int diAllocBit(struct inomap *, struct iag *, int);",
            "static int diAllocExt(struct inomap *, int, struct inode *);",
            "static int diAllocIno(struct inomap *, int, struct inode *);",
            "static int diNewExt(struct inomap *, struct iag *, int);",
            "static int diNewIAG(struct inomap *, int *, int, struct metapage **);",
            "static int diIAGRead(struct inomap * imap, int, struct metapage **);",
            "static int copy_from_dinode(struct dinode *, struct inode *);",
            "static void copy_to_dinode(struct dinode *, struct inode *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_imap.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_dinode.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_inode.h\"\n#include \"jfs_incore.h\"\n#include <linux/slab.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n\nstatic int diAllocAG(struct inomap *, int, bool, struct inode *);\nstatic int diAllocAny(struct inomap *, int, bool, struct inode *);\nstatic int diAllocBit(struct inomap *, struct iag *, int);\nstatic int diAllocExt(struct inomap *, int, struct inode *);\nstatic int diAllocIno(struct inomap *, int, struct inode *);\nstatic int diNewExt(struct inomap *, struct iag *, int);\nstatic int diNewIAG(struct inomap *, int *, int, struct metapage **);\nstatic int diIAGRead(struct inomap * imap, int, struct metapage **);\nstatic int copy_from_dinode(struct dinode *, struct inode *);\nstatic void copy_to_dinode(struct dinode *, struct inode *);\n\nstatic int diAllocExt(struct inomap * imap, int agno, struct inode *ip)\n{\n\tint rem, iagno, sword, extno, rc;\n\tstruct metapage *mp;\n\tstruct iag *iagp;\n\n\t/* check if the ag has any iags with free extents.  if not,\n\t * allocate a new iag for the ag.\n\t */\n\tif ((iagno = imap->im_agctl[agno].extfree) < 0) {\n\t\t/* If successful, diNewIAG will obtain the read lock on the\n\t\t * imap inode.\n\t\t */\n\t\tif ((rc = diNewIAG(imap, &iagno, agno, &mp))) {\n\t\t\treturn (rc);\n\t\t}\n\t\tiagp = (struct iag *) mp->data;\n\n\t\t/* set the ag number if this a brand new iag\n\t\t */\n\t\tiagp->agstart =\n\t\t    cpu_to_le64(AGTOBLK(agno, imap->im_ipimap));\n\t} else {\n\t\t/* read the iag.\n\t\t */\n\t\tIREAD_LOCK(imap->im_ipimap, RDWRLOCK_IMAP);\n\t\tif ((rc = diIAGRead(imap, iagno, &mp))) {\n\t\t\tIREAD_UNLOCK(imap->im_ipimap);\n\t\t\tjfs_error(ip->i_sb, \"error reading iag\\n\");\n\t\t\treturn rc;\n\t\t}\n\t\tiagp = (struct iag *) mp->data;\n\t}\n\n\t/* using the free extent summary map, find a free extent.\n\t */\n\tfor (sword = 0;; sword++) {\n\t\tif (sword >= SMAPSZ) {\n\t\t\trelease_metapage(mp);\n\t\t\tIREAD_UNLOCK(imap->im_ipimap);\n\t\t\tjfs_error(ip->i_sb, \"free ext summary map not found\\n\");\n\t\t\treturn -EIO;\n\t\t}\n\t\tif (~iagp->extsmap[sword])\n\t\t\tbreak;\n\t}\n\n\t/* determine the extent number of the free extent.\n\t */\n\trem = diFindFree(le32_to_cpu(iagp->extsmap[sword]), 0);\n\tif (rem >= EXTSPERSUM) {\n\t\trelease_metapage(mp);\n\t\tIREAD_UNLOCK(imap->im_ipimap);\n\t\tjfs_error(ip->i_sb, \"free extent not found\\n\");\n\t\treturn -EIO;\n\t}\n\textno = (sword << L2EXTSPERSUM) + rem;\n\n\t/* initialize the new extent.\n\t */\n\trc = diNewExt(imap, iagp, extno);\n\tIREAD_UNLOCK(imap->im_ipimap);\n\tif (rc) {\n\t\t/* something bad happened.  if a new iag was allocated,\n\t\t * place it back on the inode map's iag free list, and\n\t\t * clear the ag number information.\n\t\t */\n\t\tif (iagp->nfreeexts == cpu_to_le32(EXTSPERIAG)) {\n\t\t\tIAGFREE_LOCK(imap);\n\t\t\tiagp->iagfree = cpu_to_le32(imap->im_freeiag);\n\t\t\timap->im_freeiag = iagno;\n\t\t\tIAGFREE_UNLOCK(imap);\n\t\t}\n\t\twrite_metapage(mp);\n\t\treturn (rc);\n\t}\n\n\t/* set the results of the allocation and write the iag.\n\t */\n\tdiInitInode(ip, iagno, extno << L2INOSPEREXT, extno, iagp);\n\n\twrite_metapage(mp);\n\n\treturn (0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "jfs_error",
          "args": [
            "ip->i_sb",
            "\"numfree > numinos\\n\""
          ],
          "line": 1660
        },
        "resolved": true,
        "details": {
          "function_name": "jfs_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/super.c",
          "lines": "95-111",
          "snippet": "void jfs_error(struct super_block *sb, const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tva_start(args, fmt);\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tpr_err(\"ERROR: (device %s): %pf: %pV\\n\",\n\t       sb->s_id, __builtin_return_address(0), &vaf);\n\n\tva_end(args);\n\n\tjfs_handle_error(sb);\n}",
          "includes": [
            "#include \"jfs_xattr.h\"",
            "#include \"jfs_debug.h\"",
            "#include \"jfs_acl.h\"",
            "#include \"jfs_imap.h\"",
            "#include \"jfs_dmap.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_inode.h\"",
            "#include \"jfs_filsys.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/blkdev.h>",
            "#include <linux/seq_file.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/crc32.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/mount.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/vfs.h>",
            "#include <linux/completion.h>",
            "#include <linux/parser.h>",
            "#include <linux/module.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_xattr.h\"\n#include \"jfs_debug.h\"\n#include \"jfs_acl.h\"\n#include \"jfs_imap.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_inode.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_incore.h\"\n#include <linux/blkdev.h>\n#include <linux/seq_file.h>\n#include <asm/uaccess.h>\n#include <linux/slab.h>\n#include <linux/crc32.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/posix_acl.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/mount.h>\n#include <linux/quotaops.h>\n#include <linux/vfs.h>\n#include <linux/completion.h>\n#include <linux/parser.h>\n#include <linux/module.h>\n#include <linux/fs.h>\n\nvoid jfs_error(struct super_block *sb, const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tva_start(args, fmt);\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tpr_err(\"ERROR: (device %s): %pf: %pV\\n\",\n\t       sb->s_id, __builtin_return_address(0), &vaf);\n\n\tva_end(args);\n\n\tjfs_handle_error(sb);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_imap.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_dinode.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_inode.h\"\n#include \"jfs_incore.h\"\n#include <linux/slab.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n\nstatic int diAllocAG(struct inomap *, int, bool, struct inode *);\nstatic int diAllocAny(struct inomap *, int, bool, struct inode *);\nstatic int diAllocExt(struct inomap *, int, struct inode *);\nstatic int diAllocIno(struct inomap *, int, struct inode *);\nstatic int copy_from_dinode(struct dinode *, struct inode *);\nstatic void copy_to_dinode(struct dinode *, struct inode *);\n\nstatic int\ndiAllocAG(struct inomap * imap, int agno, bool dir, struct inode *ip)\n{\n\tint rc, addext, numfree, numinos;\n\n\t/* get the number of free and the number of backed disk\n\t * inodes currently within the ag.\n\t */\n\tnumfree = imap->im_agctl[agno].numfree;\n\tnuminos = imap->im_agctl[agno].numinos;\n\n\tif (numfree > numinos) {\n\t\tjfs_error(ip->i_sb, \"numfree > numinos\\n\");\n\t\treturn -EIO;\n\t}\n\n\t/* determine if we should allocate a new extent of free inodes\n\t * within the ag: for directory inodes, add a new extent\n\t * if there are a small number of free inodes or number of free\n\t * inodes is a small percentage of the number of backed inodes.\n\t */\n\tif (dir)\n\t\taddext = (numfree < 64 ||\n\t\t\t  (numfree < 256\n\t\t\t   && ((numfree * 100) / numinos) <= 20));\n\telse\n\t\taddext = (numfree == 0);\n\n\t/*\n\t * try to allocate a new extent of free inodes.\n\t */\n\tif (addext) {\n\t\t/* if free space is not available for this new extent, try\n\t\t * below to allocate a free and existing (already backed)\n\t\t * inode from the ag.\n\t\t */\n\t\tif ((rc = diAllocExt(imap, agno, ip)) != -ENOSPC)\n\t\t\treturn (rc);\n\t}\n\n\t/*\n\t * try to allocate an existing free inode from the ag.\n\t */\n\treturn (diAllocIno(imap, agno, ip));\n}"
  },
  {
    "function_name": "diAlloc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_imap.c",
    "lines": "1341-1616",
    "snippet": "int diAlloc(struct inode *pip, bool dir, struct inode *ip)\n{\n\tint rc, ino, iagno, addext, extno, bitno, sword;\n\tint nwords, rem, i, agno;\n\tu32 mask, inosmap, extsmap;\n\tstruct inode *ipimap;\n\tstruct metapage *mp;\n\tino_t inum;\n\tstruct iag *iagp;\n\tstruct inomap *imap;\n\n\t/* get the pointers to the inode map inode and the\n\t * corresponding imap control structure.\n\t */\n\tipimap = JFS_SBI(pip->i_sb)->ipimap;\n\timap = JFS_IP(ipimap)->i_imap;\n\tJFS_IP(ip)->ipimap = ipimap;\n\tJFS_IP(ip)->fileset = FILESYSTEM_I;\n\n\t/* for a directory, the allocation policy is to start\n\t * at the ag level using the preferred ag.\n\t */\n\tif (dir) {\n\t\tagno = dbNextAG(JFS_SBI(pip->i_sb)->ipbmap);\n\t\tAG_LOCK(imap, agno);\n\t\tgoto tryag;\n\t}\n\n\t/* for files, the policy starts off by trying to allocate from\n\t * the same iag containing the parent disk inode:\n\t * try to allocate the new disk inode close to the parent disk\n\t * inode, using parent disk inode number + 1 as the allocation\n\t * hint.  (we use a left-to-right policy to attempt to avoid\n\t * moving backward on the disk.)  compute the hint within the\n\t * file system and the iag.\n\t */\n\n\t/* get the ag number of this iag */\n\tagno = BLKTOAG(JFS_IP(pip)->agstart, JFS_SBI(pip->i_sb));\n\n\tif (atomic_read(&JFS_SBI(pip->i_sb)->bmap->db_active[agno])) {\n\t\t/*\n\t\t * There is an open file actively growing.  We want to\n\t\t * allocate new inodes from a different ag to avoid\n\t\t * fragmentation problems.\n\t\t */\n\t\tagno = dbNextAG(JFS_SBI(pip->i_sb)->ipbmap);\n\t\tAG_LOCK(imap, agno);\n\t\tgoto tryag;\n\t}\n\n\tinum = pip->i_ino + 1;\n\tino = inum & (INOSPERIAG - 1);\n\n\t/* back off the hint if it is outside of the iag */\n\tif (ino == 0)\n\t\tinum = pip->i_ino;\n\n\t/* lock the AG inode map information */\n\tAG_LOCK(imap, agno);\n\n\t/* Get read lock on imap inode */\n\tIREAD_LOCK(ipimap, RDWRLOCK_IMAP);\n\n\t/* get the iag number and read the iag */\n\tiagno = INOTOIAG(inum);\n\tif ((rc = diIAGRead(imap, iagno, &mp))) {\n\t\tIREAD_UNLOCK(ipimap);\n\t\tAG_UNLOCK(imap, agno);\n\t\treturn (rc);\n\t}\n\tiagp = (struct iag *) mp->data;\n\n\t/* determine if new inode extent is allowed to be added to the iag.\n\t * new inode extent can be added to the iag if the ag\n\t * has less than 32 free disk inodes and the iag has free extents.\n\t */\n\taddext = (imap->im_agctl[agno].numfree < 32 && iagp->nfreeexts);\n\n\t/*\n\t *\ttry to allocate from the IAG\n\t */\n\t/* check if the inode may be allocated from the iag\n\t * (i.e. the inode has free inodes or new extent can be added).\n\t */\n\tif (iagp->nfreeinos || addext) {\n\t\t/* determine the extent number of the hint.\n\t\t */\n\t\textno = ino >> L2INOSPEREXT;\n\n\t\t/* check if the extent containing the hint has backed\n\t\t * inodes.  if so, try to allocate within this extent.\n\t\t */\n\t\tif (addressPXD(&iagp->inoext[extno])) {\n\t\t\tbitno = ino & (INOSPEREXT - 1);\n\t\t\tif ((bitno =\n\t\t\t     diFindFree(le32_to_cpu(iagp->wmap[extno]),\n\t\t\t\t\tbitno))\n\t\t\t    < INOSPEREXT) {\n\t\t\t\tino = (extno << L2INOSPEREXT) + bitno;\n\n\t\t\t\t/* a free inode (bit) was found within this\n\t\t\t\t * extent, so allocate it.\n\t\t\t\t */\n\t\t\t\trc = diAllocBit(imap, iagp, ino);\n\t\t\t\tIREAD_UNLOCK(ipimap);\n\t\t\t\tif (rc) {\n\t\t\t\t\tassert(rc == -EIO);\n\t\t\t\t} else {\n\t\t\t\t\t/* set the results of the allocation\n\t\t\t\t\t * and write the iag.\n\t\t\t\t\t */\n\t\t\t\t\tdiInitInode(ip, iagno, ino, extno,\n\t\t\t\t\t\t    iagp);\n\t\t\t\t\tmark_metapage_dirty(mp);\n\t\t\t\t}\n\t\t\t\trelease_metapage(mp);\n\n\t\t\t\t/* free the AG lock and return.\n\t\t\t\t */\n\t\t\t\tAG_UNLOCK(imap, agno);\n\t\t\t\treturn (rc);\n\t\t\t}\n\n\t\t\tif (!addext)\n\t\t\t\textno =\n\t\t\t\t    (extno ==\n\t\t\t\t     EXTSPERIAG - 1) ? 0 : extno + 1;\n\t\t}\n\n\t\t/*\n\t\t * no free inodes within the extent containing the hint.\n\t\t *\n\t\t * try to allocate from the backed extents following\n\t\t * hint or, if appropriate (i.e. addext is true), allocate\n\t\t * an extent of free inodes at or following the extent\n\t\t * containing the hint.\n\t\t *\n\t\t * the free inode and free extent summary maps are used\n\t\t * here, so determine the starting summary map position\n\t\t * and the number of words we'll have to examine.  again,\n\t\t * the approach is to allocate following the hint, so we\n\t\t * might have to initially ignore prior bits of the summary\n\t\t * map that represent extents prior to the extent containing\n\t\t * the hint and later revisit these bits.\n\t\t */\n\t\tbitno = extno & (EXTSPERSUM - 1);\n\t\tnwords = (bitno == 0) ? SMAPSZ : SMAPSZ + 1;\n\t\tsword = extno >> L2EXTSPERSUM;\n\n\t\t/* mask any prior bits for the starting words of the\n\t\t * summary map.\n\t\t */\n\t\tmask = (bitno == 0) ? 0 : (ONES << (EXTSPERSUM - bitno));\n\t\tinosmap = le32_to_cpu(iagp->inosmap[sword]) | mask;\n\t\textsmap = le32_to_cpu(iagp->extsmap[sword]) | mask;\n\n\t\t/* scan the free inode and free extent summary maps for\n\t\t * free resources.\n\t\t */\n\t\tfor (i = 0; i < nwords; i++) {\n\t\t\t/* check if this word of the free inode summary\n\t\t\t * map describes an extent with free inodes.\n\t\t\t */\n\t\t\tif (~inosmap) {\n\t\t\t\t/* an extent with free inodes has been\n\t\t\t\t * found. determine the extent number\n\t\t\t\t * and the inode number within the extent.\n\t\t\t\t */\n\t\t\t\trem = diFindFree(inosmap, 0);\n\t\t\t\textno = (sword << L2EXTSPERSUM) + rem;\n\t\t\t\trem = diFindFree(le32_to_cpu(iagp->wmap[extno]),\n\t\t\t\t\t\t 0);\n\t\t\t\tif (rem >= INOSPEREXT) {\n\t\t\t\t\tIREAD_UNLOCK(ipimap);\n\t\t\t\t\trelease_metapage(mp);\n\t\t\t\t\tAG_UNLOCK(imap, agno);\n\t\t\t\t\tjfs_error(ip->i_sb,\n\t\t\t\t\t\t  \"can't find free bit in wmap\\n\");\n\t\t\t\t\treturn -EIO;\n\t\t\t\t}\n\n\t\t\t\t/* determine the inode number within the\n\t\t\t\t * iag and allocate the inode from the\n\t\t\t\t * map.\n\t\t\t\t */\n\t\t\t\tino = (extno << L2INOSPEREXT) + rem;\n\t\t\t\trc = diAllocBit(imap, iagp, ino);\n\t\t\t\tIREAD_UNLOCK(ipimap);\n\t\t\t\tif (rc)\n\t\t\t\t\tassert(rc == -EIO);\n\t\t\t\telse {\n\t\t\t\t\t/* set the results of the allocation\n\t\t\t\t\t * and write the iag.\n\t\t\t\t\t */\n\t\t\t\t\tdiInitInode(ip, iagno, ino, extno,\n\t\t\t\t\t\t    iagp);\n\t\t\t\t\tmark_metapage_dirty(mp);\n\t\t\t\t}\n\t\t\t\trelease_metapage(mp);\n\n\t\t\t\t/* free the AG lock and return.\n\t\t\t\t */\n\t\t\t\tAG_UNLOCK(imap, agno);\n\t\t\t\treturn (rc);\n\n\t\t\t}\n\n\t\t\t/* check if we may allocate an extent of free\n\t\t\t * inodes and whether this word of the free\n\t\t\t * extents summary map describes a free extent.\n\t\t\t */\n\t\t\tif (addext && ~extsmap) {\n\t\t\t\t/* a free extent has been found.  determine\n\t\t\t\t * the extent number.\n\t\t\t\t */\n\t\t\t\trem = diFindFree(extsmap, 0);\n\t\t\t\textno = (sword << L2EXTSPERSUM) + rem;\n\n\t\t\t\t/* allocate an extent of free inodes.\n\t\t\t\t */\n\t\t\t\tif ((rc = diNewExt(imap, iagp, extno))) {\n\t\t\t\t\t/* if there is no disk space for a\n\t\t\t\t\t * new extent, try to allocate the\n\t\t\t\t\t * disk inode from somewhere else.\n\t\t\t\t\t */\n\t\t\t\t\tif (rc == -ENOSPC)\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tassert(rc == -EIO);\n\t\t\t\t} else {\n\t\t\t\t\t/* set the results of the allocation\n\t\t\t\t\t * and write the iag.\n\t\t\t\t\t */\n\t\t\t\t\tdiInitInode(ip, iagno,\n\t\t\t\t\t\t    extno << L2INOSPEREXT,\n\t\t\t\t\t\t    extno, iagp);\n\t\t\t\t\tmark_metapage_dirty(mp);\n\t\t\t\t}\n\t\t\t\trelease_metapage(mp);\n\t\t\t\t/* free the imap inode & the AG lock & return.\n\t\t\t\t */\n\t\t\t\tIREAD_UNLOCK(ipimap);\n\t\t\t\tAG_UNLOCK(imap, agno);\n\t\t\t\treturn (rc);\n\t\t\t}\n\n\t\t\t/* move on to the next set of summary map words.\n\t\t\t */\n\t\t\tsword = (sword == SMAPSZ - 1) ? 0 : sword + 1;\n\t\t\tinosmap = le32_to_cpu(iagp->inosmap[sword]);\n\t\t\textsmap = le32_to_cpu(iagp->extsmap[sword]);\n\t\t}\n\t}\n\t/* unlock imap inode */\n\tIREAD_UNLOCK(ipimap);\n\n\t/* nothing doing in this iag, so release it. */\n\trelease_metapage(mp);\n\n      tryag:\n\t/*\n\t * try to allocate anywhere within the same AG as the parent inode.\n\t */\n\trc = diAllocAG(imap, agno, dir, ip);\n\n\tAG_UNLOCK(imap, agno);\n\n\tif (rc != -ENOSPC)\n\t\treturn (rc);\n\n\t/*\n\t * try to allocate in any AG.\n\t */\n\treturn (diAllocAny(imap, agno, dir, ip));\n}",
    "includes": [
      "#include \"jfs_debug.h\"",
      "#include \"jfs_superblock.h\"",
      "#include \"jfs_metapage.h\"",
      "#include \"jfs_imap.h\"",
      "#include \"jfs_dmap.h\"",
      "#include \"jfs_dinode.h\"",
      "#include \"jfs_filsys.h\"",
      "#include \"jfs_inode.h\"",
      "#include \"jfs_incore.h\"",
      "#include <linux/slab.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int diAllocAG(struct inomap *, int, bool, struct inode *);",
      "static int diAllocAny(struct inomap *, int, bool, struct inode *);",
      "static int diAllocBit(struct inomap *, struct iag *, int);",
      "static int diAllocExt(struct inomap *, int, struct inode *);",
      "static int diAllocIno(struct inomap *, int, struct inode *);",
      "static int diFindFree(u32, int);",
      "static int diNewExt(struct inomap *, struct iag *, int);",
      "static int diNewIAG(struct inomap *, int *, int, struct metapage **);",
      "static int diIAGRead(struct inomap * imap, int, struct metapage **);",
      "static int copy_from_dinode(struct dinode *, struct inode *);",
      "static void copy_to_dinode(struct dinode *, struct inode *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "diAllocAny",
          "args": [
            "imap",
            "agno",
            "dir",
            "ip"
          ],
          "line": 1615
        },
        "resolved": true,
        "details": {
          "function_name": "diAllocAny",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_imap.c",
          "lines": "1718-1755",
          "snippet": "static int\ndiAllocAny(struct inomap * imap, int agno, bool dir, struct inode *ip)\n{\n\tint ag, rc;\n\tint maxag = JFS_SBI(imap->im_ipimap->i_sb)->bmap->db_maxag;\n\n\n\t/* try to allocate from the ags following agno up to\n\t * the maximum ag number.\n\t */\n\tfor (ag = agno + 1; ag <= maxag; ag++) {\n\t\tAG_LOCK(imap, ag);\n\n\t\trc = diAllocAG(imap, ag, dir, ip);\n\n\t\tAG_UNLOCK(imap, ag);\n\n\t\tif (rc != -ENOSPC)\n\t\t\treturn (rc);\n\t}\n\n\t/* try to allocate from the ags in front of agno.\n\t */\n\tfor (ag = 0; ag < agno; ag++) {\n\t\tAG_LOCK(imap, ag);\n\n\t\trc = diAllocAG(imap, ag, dir, ip);\n\n\t\tAG_UNLOCK(imap, ag);\n\n\t\tif (rc != -ENOSPC)\n\t\t\treturn (rc);\n\t}\n\n\t/* no free disk inodes.\n\t */\n\treturn -ENOSPC;\n}",
          "includes": [
            "#include \"jfs_debug.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_imap.h\"",
            "#include \"jfs_dmap.h\"",
            "#include \"jfs_dinode.h\"",
            "#include \"jfs_filsys.h\"",
            "#include \"jfs_inode.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/slab.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int diAllocAG(struct inomap *, int, bool, struct inode *);",
            "static int diAllocAny(struct inomap *, int, bool, struct inode *);",
            "static int diAllocExt(struct inomap *, int, struct inode *);",
            "static int diAllocIno(struct inomap *, int, struct inode *);",
            "static int copy_from_dinode(struct dinode *, struct inode *);",
            "static void copy_to_dinode(struct dinode *, struct inode *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_imap.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_dinode.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_inode.h\"\n#include \"jfs_incore.h\"\n#include <linux/slab.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n\nstatic int diAllocAG(struct inomap *, int, bool, struct inode *);\nstatic int diAllocAny(struct inomap *, int, bool, struct inode *);\nstatic int diAllocExt(struct inomap *, int, struct inode *);\nstatic int diAllocIno(struct inomap *, int, struct inode *);\nstatic int copy_from_dinode(struct dinode *, struct inode *);\nstatic void copy_to_dinode(struct dinode *, struct inode *);\n\nstatic int\ndiAllocAny(struct inomap * imap, int agno, bool dir, struct inode *ip)\n{\n\tint ag, rc;\n\tint maxag = JFS_SBI(imap->im_ipimap->i_sb)->bmap->db_maxag;\n\n\n\t/* try to allocate from the ags following agno up to\n\t * the maximum ag number.\n\t */\n\tfor (ag = agno + 1; ag <= maxag; ag++) {\n\t\tAG_LOCK(imap, ag);\n\n\t\trc = diAllocAG(imap, ag, dir, ip);\n\n\t\tAG_UNLOCK(imap, ag);\n\n\t\tif (rc != -ENOSPC)\n\t\t\treturn (rc);\n\t}\n\n\t/* try to allocate from the ags in front of agno.\n\t */\n\tfor (ag = 0; ag < agno; ag++) {\n\t\tAG_LOCK(imap, ag);\n\n\t\trc = diAllocAG(imap, ag, dir, ip);\n\n\t\tAG_UNLOCK(imap, ag);\n\n\t\tif (rc != -ENOSPC)\n\t\t\treturn (rc);\n\t}\n\n\t/* no free disk inodes.\n\t */\n\treturn -ENOSPC;\n}"
        }
      },
      {
        "call_info": {
          "callee": "AG_UNLOCK",
          "args": [
            "imap",
            "agno"
          ],
          "line": 1607
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "diAllocAG",
          "args": [
            "imap",
            "agno",
            "dir",
            "ip"
          ],
          "line": 1605
        },
        "resolved": true,
        "details": {
          "function_name": "diAllocAG",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_imap.c",
          "lines": "1648-1692",
          "snippet": "static int\ndiAllocAG(struct inomap * imap, int agno, bool dir, struct inode *ip)\n{\n\tint rc, addext, numfree, numinos;\n\n\t/* get the number of free and the number of backed disk\n\t * inodes currently within the ag.\n\t */\n\tnumfree = imap->im_agctl[agno].numfree;\n\tnuminos = imap->im_agctl[agno].numinos;\n\n\tif (numfree > numinos) {\n\t\tjfs_error(ip->i_sb, \"numfree > numinos\\n\");\n\t\treturn -EIO;\n\t}\n\n\t/* determine if we should allocate a new extent of free inodes\n\t * within the ag: for directory inodes, add a new extent\n\t * if there are a small number of free inodes or number of free\n\t * inodes is a small percentage of the number of backed inodes.\n\t */\n\tif (dir)\n\t\taddext = (numfree < 64 ||\n\t\t\t  (numfree < 256\n\t\t\t   && ((numfree * 100) / numinos) <= 20));\n\telse\n\t\taddext = (numfree == 0);\n\n\t/*\n\t * try to allocate a new extent of free inodes.\n\t */\n\tif (addext) {\n\t\t/* if free space is not available for this new extent, try\n\t\t * below to allocate a free and existing (already backed)\n\t\t * inode from the ag.\n\t\t */\n\t\tif ((rc = diAllocExt(imap, agno, ip)) != -ENOSPC)\n\t\t\treturn (rc);\n\t}\n\n\t/*\n\t * try to allocate an existing free inode from the ag.\n\t */\n\treturn (diAllocIno(imap, agno, ip));\n}",
          "includes": [
            "#include \"jfs_debug.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_imap.h\"",
            "#include \"jfs_dmap.h\"",
            "#include \"jfs_dinode.h\"",
            "#include \"jfs_filsys.h\"",
            "#include \"jfs_inode.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/slab.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int diAllocAG(struct inomap *, int, bool, struct inode *);",
            "static int diAllocAny(struct inomap *, int, bool, struct inode *);",
            "static int diAllocExt(struct inomap *, int, struct inode *);",
            "static int diAllocIno(struct inomap *, int, struct inode *);",
            "static int copy_from_dinode(struct dinode *, struct inode *);",
            "static void copy_to_dinode(struct dinode *, struct inode *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_imap.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_dinode.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_inode.h\"\n#include \"jfs_incore.h\"\n#include <linux/slab.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n\nstatic int diAllocAG(struct inomap *, int, bool, struct inode *);\nstatic int diAllocAny(struct inomap *, int, bool, struct inode *);\nstatic int diAllocExt(struct inomap *, int, struct inode *);\nstatic int diAllocIno(struct inomap *, int, struct inode *);\nstatic int copy_from_dinode(struct dinode *, struct inode *);\nstatic void copy_to_dinode(struct dinode *, struct inode *);\n\nstatic int\ndiAllocAG(struct inomap * imap, int agno, bool dir, struct inode *ip)\n{\n\tint rc, addext, numfree, numinos;\n\n\t/* get the number of free and the number of backed disk\n\t * inodes currently within the ag.\n\t */\n\tnumfree = imap->im_agctl[agno].numfree;\n\tnuminos = imap->im_agctl[agno].numinos;\n\n\tif (numfree > numinos) {\n\t\tjfs_error(ip->i_sb, \"numfree > numinos\\n\");\n\t\treturn -EIO;\n\t}\n\n\t/* determine if we should allocate a new extent of free inodes\n\t * within the ag: for directory inodes, add a new extent\n\t * if there are a small number of free inodes or number of free\n\t * inodes is a small percentage of the number of backed inodes.\n\t */\n\tif (dir)\n\t\taddext = (numfree < 64 ||\n\t\t\t  (numfree < 256\n\t\t\t   && ((numfree * 100) / numinos) <= 20));\n\telse\n\t\taddext = (numfree == 0);\n\n\t/*\n\t * try to allocate a new extent of free inodes.\n\t */\n\tif (addext) {\n\t\t/* if free space is not available for this new extent, try\n\t\t * below to allocate a free and existing (already backed)\n\t\t * inode from the ag.\n\t\t */\n\t\tif ((rc = diAllocExt(imap, agno, ip)) != -ENOSPC)\n\t\t\treturn (rc);\n\t}\n\n\t/*\n\t * try to allocate an existing free inode from the ag.\n\t */\n\treturn (diAllocIno(imap, agno, ip));\n}"
        }
      },
      {
        "call_info": {
          "callee": "release_metapage",
          "args": [
            "mp"
          ],
          "line": 1599
        },
        "resolved": true,
        "details": {
          "function_name": "release_metapage",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_metapage.c",
          "lines": "743-775",
          "snippet": "void release_metapage(struct metapage * mp)\n{\n\tstruct page *page = mp->page;\n\tjfs_info(\"release_metapage: mp = 0x%p, flag = 0x%lx\", mp, mp->flag);\n\n\tBUG_ON(!page);\n\n\tlock_page(page);\n\tunlock_metapage(mp);\n\n\tassert(mp->count);\n\tif (--mp->count || mp->nohomeok) {\n\t\tunlock_page(page);\n\t\tpage_cache_release(page);\n\t\treturn;\n\t}\n\n\tif (test_bit(META_dirty, &mp->flag)) {\n\t\tset_page_dirty(page);\n\t\tif (test_bit(META_sync, &mp->flag)) {\n\t\t\tclear_bit(META_sync, &mp->flag);\n\t\t\twrite_one_page(page, 1);\n\t\t\tlock_page(page); /* write_one_page unlocks the page */\n\t\t}\n\t} else if (mp->lsn)\t/* discard_metapage doesn't remove it */\n\t\tremove_from_logsync(mp);\n\n\t/* Try to keep metapages from using up too much memory */\n\tdrop_metapage(page, mp);\n\n\tunlock_page(page);\n\tpage_cache_release(page);\n}",
          "includes": [
            "#include \"jfs_debug.h\"",
            "#include \"jfs_txnmgr.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_filsys.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/mempool.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/bio.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_txnmgr.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_incore.h\"\n#include <linux/seq_file.h>\n#include <linux/mempool.h>\n#include <linux/buffer_head.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n\nvoid release_metapage(struct metapage * mp)\n{\n\tstruct page *page = mp->page;\n\tjfs_info(\"release_metapage: mp = 0x%p, flag = 0x%lx\", mp, mp->flag);\n\n\tBUG_ON(!page);\n\n\tlock_page(page);\n\tunlock_metapage(mp);\n\n\tassert(mp->count);\n\tif (--mp->count || mp->nohomeok) {\n\t\tunlock_page(page);\n\t\tpage_cache_release(page);\n\t\treturn;\n\t}\n\n\tif (test_bit(META_dirty, &mp->flag)) {\n\t\tset_page_dirty(page);\n\t\tif (test_bit(META_sync, &mp->flag)) {\n\t\t\tclear_bit(META_sync, &mp->flag);\n\t\t\twrite_one_page(page, 1);\n\t\t\tlock_page(page); /* write_one_page unlocks the page */\n\t\t}\n\t} else if (mp->lsn)\t/* discard_metapage doesn't remove it */\n\t\tremove_from_logsync(mp);\n\n\t/* Try to keep metapages from using up too much memory */\n\tdrop_metapage(page, mp);\n\n\tunlock_page(page);\n\tpage_cache_release(page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "IREAD_UNLOCK",
          "args": [
            "ipimap"
          ],
          "line": 1596
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "iagp->extsmap[sword]"
          ],
          "line": 1592
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "AG_UNLOCK",
          "args": [
            "imap",
            "agno"
          ],
          "line": 1584
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IREAD_UNLOCK",
          "args": [
            "ipimap"
          ],
          "line": 1583
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mark_metapage_dirty",
          "args": [
            "mp"
          ],
          "line": 1578
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "diInitInode",
          "args": [
            "ip",
            "iagno",
            "extno << L2INOSPEREXT",
            "extno",
            "iagp"
          ],
          "line": 1575
        },
        "resolved": true,
        "details": {
          "function_name": "diInitInode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_imap.c",
          "lines": "1313-1322",
          "snippet": "static inline void\ndiInitInode(struct inode *ip, int iagno, int ino, int extno, struct iag * iagp)\n{\n\tstruct jfs_inode_info *jfs_ip = JFS_IP(ip);\n\n\tip->i_ino = (iagno << L2INOSPERIAG) + ino;\n\tjfs_ip->ixpxd = iagp->inoext[extno];\n\tjfs_ip->agstart = le64_to_cpu(iagp->agstart);\n\tjfs_ip->active_ag = -1;\n}",
          "includes": [
            "#include \"jfs_debug.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_imap.h\"",
            "#include \"jfs_dmap.h\"",
            "#include \"jfs_dinode.h\"",
            "#include \"jfs_filsys.h\"",
            "#include \"jfs_inode.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/slab.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int diAllocAG(struct inomap *, int, bool, struct inode *);",
            "static int diAllocAny(struct inomap *, int, bool, struct inode *);",
            "static int diAllocBit(struct inomap *, struct iag *, int);",
            "static int diAllocExt(struct inomap *, int, struct inode *);",
            "static int diAllocIno(struct inomap *, int, struct inode *);",
            "static int diNewExt(struct inomap *, struct iag *, int);",
            "static int copy_from_dinode(struct dinode *, struct inode *);",
            "static void copy_to_dinode(struct dinode *, struct inode *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_imap.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_dinode.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_inode.h\"\n#include \"jfs_incore.h\"\n#include <linux/slab.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n\nstatic int diAllocAG(struct inomap *, int, bool, struct inode *);\nstatic int diAllocAny(struct inomap *, int, bool, struct inode *);\nstatic int diAllocBit(struct inomap *, struct iag *, int);\nstatic int diAllocExt(struct inomap *, int, struct inode *);\nstatic int diAllocIno(struct inomap *, int, struct inode *);\nstatic int diNewExt(struct inomap *, struct iag *, int);\nstatic int copy_from_dinode(struct dinode *, struct inode *);\nstatic void copy_to_dinode(struct dinode *, struct inode *);\n\nstatic inline void\ndiInitInode(struct inode *ip, int iagno, int ino, int extno, struct iag * iagp)\n{\n\tstruct jfs_inode_info *jfs_ip = JFS_IP(ip);\n\n\tip->i_ino = (iagno << L2INOSPERIAG) + ino;\n\tjfs_ip->ixpxd = iagp->inoext[extno];\n\tjfs_ip->agstart = le64_to_cpu(iagp->agstart);\n\tjfs_ip->active_ag = -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "rc == -EIO"
          ],
          "line": 1570
        },
        "resolved": true,
        "details": {
          "function_name": "hpfs_lock_assert",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/hpfs_fn.h",
          "lines": "359-363",
          "snippet": "static inline void hpfs_lock_assert(struct super_block *s)\n{\n\tstruct hpfs_sb_info *sbi = hpfs_sb(s);\n\tWARN_ON(!mutex_is_locked(&sbi->hpfs_mutex));\n}",
          "includes": [
            "#include \"hpfs.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int hpfs_check_free_dnodes(struct super_block *, int);",
            "void hpfs_prefetch_sectors(struct super_block *, unsigned, int);",
            "void hpfs_prefetch_bitmap(struct super_block *, unsigned);",
            "unsigned char *hpfs_translate_name(struct super_block *, unsigned char *, unsigned, int, int);",
            "int hpfs_compare_names(struct super_block *, const unsigned char *, unsigned,\n\t\t       const unsigned char *, unsigned, int);",
            "void hpfs_error(struct super_block *, const char *, ...);",
            "int hpfs_stop_cycles(struct super_block *, int, int *, int *, char *);",
            "unsigned hpfs_get_free_dnodes(struct super_block *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"hpfs.h\"\n#include <asm/unaligned.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n#include <linux/mutex.h>\n\nint hpfs_check_free_dnodes(struct super_block *, int);\nvoid hpfs_prefetch_sectors(struct super_block *, unsigned, int);\nvoid hpfs_prefetch_bitmap(struct super_block *, unsigned);\nunsigned char *hpfs_translate_name(struct super_block *, unsigned char *, unsigned, int, int);\nint hpfs_compare_names(struct super_block *, const unsigned char *, unsigned,\n\t\t       const unsigned char *, unsigned, int);\nvoid hpfs_error(struct super_block *, const char *, ...);\nint hpfs_stop_cycles(struct super_block *, int, int *, int *, char *);\nunsigned hpfs_get_free_dnodes(struct super_block *);\n\nstatic inline void hpfs_lock_assert(struct super_block *s)\n{\n\tstruct hpfs_sb_info *sbi = hpfs_sb(s);\n\tWARN_ON(!mutex_is_locked(&sbi->hpfs_mutex));\n}"
        }
      },
      {
        "call_info": {
          "callee": "diNewExt",
          "args": [
            "imap",
            "iagp",
            "extno"
          ],
          "line": 1562
        },
        "resolved": true,
        "details": {
          "function_name": "diNewExt",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_imap.c",
          "lines": "2170-2409",
          "snippet": "static int diNewExt(struct inomap * imap, struct iag * iagp, int extno)\n{\n\tint agno, iagno, fwd, back, freei = 0, sword, rc;\n\tstruct iag *aiagp = NULL, *biagp = NULL, *ciagp = NULL;\n\tstruct metapage *amp, *bmp, *cmp, *dmp;\n\tstruct inode *ipimap;\n\ts64 blkno, hint;\n\tint i, j;\n\tu32 mask;\n\tino_t ino;\n\tstruct dinode *dp;\n\tstruct jfs_sb_info *sbi;\n\n\t/* better have free extents.\n\t */\n\tif (!iagp->nfreeexts) {\n\t\tjfs_error(imap->im_ipimap->i_sb, \"no free extents\\n\");\n\t\treturn -EIO;\n\t}\n\n\t/* get the inode map inode.\n\t */\n\tipimap = imap->im_ipimap;\n\tsbi = JFS_SBI(ipimap->i_sb);\n\n\tamp = bmp = cmp = NULL;\n\n\t/* get the ag and iag numbers for this iag.\n\t */\n\tagno = BLKTOAG(le64_to_cpu(iagp->agstart), sbi);\n\tiagno = le32_to_cpu(iagp->iagnum);\n\n\t/* check if this is the last free extent within the\n\t * iag.  if so, the iag must be removed from the ag\n\t * free extent list, so get the iags preceding and\n\t * following the iag on this list.\n\t */\n\tif (iagp->nfreeexts == cpu_to_le32(1)) {\n\t\tif ((fwd = le32_to_cpu(iagp->extfreefwd)) >= 0) {\n\t\t\tif ((rc = diIAGRead(imap, fwd, &amp)))\n\t\t\t\treturn (rc);\n\t\t\taiagp = (struct iag *) amp->data;\n\t\t}\n\n\t\tif ((back = le32_to_cpu(iagp->extfreeback)) >= 0) {\n\t\t\tif ((rc = diIAGRead(imap, back, &bmp)))\n\t\t\t\tgoto error_out;\n\t\t\tbiagp = (struct iag *) bmp->data;\n\t\t}\n\t} else {\n\t\t/* the iag has free extents.  if all extents are free\n\t\t * (as is the case for a newly allocated iag), the iag\n\t\t * must be added to the ag free extent list, so get\n\t\t * the iag at the head of the list in preparation for\n\t\t * adding this iag to this list.\n\t\t */\n\t\tfwd = back = -1;\n\t\tif (iagp->nfreeexts == cpu_to_le32(EXTSPERIAG)) {\n\t\t\tif ((fwd = imap->im_agctl[agno].extfree) >= 0) {\n\t\t\t\tif ((rc = diIAGRead(imap, fwd, &amp)))\n\t\t\t\t\tgoto error_out;\n\t\t\t\taiagp = (struct iag *) amp->data;\n\t\t\t}\n\t\t}\n\t}\n\n\t/* check if the iag has no free inodes.  if so, the iag\n\t * will have to be added to the ag free inode list, so get\n\t * the iag at the head of the list in preparation for\n\t * adding this iag to this list.  in doing this, we must\n\t * check if we already have the iag at the head of\n\t * the list in hand.\n\t */\n\tif (iagp->nfreeinos == 0) {\n\t\tfreei = imap->im_agctl[agno].inofree;\n\n\t\tif (freei >= 0) {\n\t\t\tif (freei == fwd) {\n\t\t\t\tciagp = aiagp;\n\t\t\t} else if (freei == back) {\n\t\t\t\tciagp = biagp;\n\t\t\t} else {\n\t\t\t\tif ((rc = diIAGRead(imap, freei, &cmp)))\n\t\t\t\t\tgoto error_out;\n\t\t\t\tciagp = (struct iag *) cmp->data;\n\t\t\t}\n\t\t\tif (ciagp == NULL) {\n\t\t\t\tjfs_error(imap->im_ipimap->i_sb,\n\t\t\t\t\t  \"ciagp == NULL\\n\");\n\t\t\t\trc = -EIO;\n\t\t\t\tgoto error_out;\n\t\t\t}\n\t\t}\n\t}\n\n\t/* allocate disk space for the inode extent.\n\t */\n\tif ((extno == 0) || (addressPXD(&iagp->inoext[extno - 1]) == 0))\n\t\thint = ((s64) agno << sbi->bmap->db_agl2size) - 1;\n\telse\n\t\thint = addressPXD(&iagp->inoext[extno - 1]) +\n\t\t    lengthPXD(&iagp->inoext[extno - 1]) - 1;\n\n\tif ((rc = dbAlloc(ipimap, hint, (s64) imap->im_nbperiext, &blkno)))\n\t\tgoto error_out;\n\n\t/* compute the inode number of the first inode within the\n\t * extent.\n\t */\n\tino = (iagno << L2INOSPERIAG) + (extno << L2INOSPEREXT);\n\n\t/* initialize the inodes within the newly allocated extent a\n\t * page at a time.\n\t */\n\tfor (i = 0; i < imap->im_nbperiext; i += sbi->nbperpage) {\n\t\t/* get a buffer for this page of disk inodes.\n\t\t */\n\t\tdmp = get_metapage(ipimap, blkno + i, PSIZE, 1);\n\t\tif (dmp == NULL) {\n\t\t\trc = -EIO;\n\t\t\tgoto error_out;\n\t\t}\n\t\tdp = (struct dinode *) dmp->data;\n\n\t\t/* initialize the inode number, mode, link count and\n\t\t * inode extent address.\n\t\t */\n\t\tfor (j = 0; j < INOSPERPAGE; j++, dp++, ino++) {\n\t\t\tdp->di_inostamp = cpu_to_le32(sbi->inostamp);\n\t\t\tdp->di_number = cpu_to_le32(ino);\n\t\t\tdp->di_fileset = cpu_to_le32(FILESYSTEM_I);\n\t\t\tdp->di_mode = 0;\n\t\t\tdp->di_nlink = 0;\n\t\t\tPXDaddress(&(dp->di_ixpxd), blkno);\n\t\t\tPXDlength(&(dp->di_ixpxd), imap->im_nbperiext);\n\t\t}\n\t\twrite_metapage(dmp);\n\t}\n\n\t/* if this is the last free extent within the iag, remove the\n\t * iag from the ag free extent list.\n\t */\n\tif (iagp->nfreeexts == cpu_to_le32(1)) {\n\t\tif (fwd >= 0)\n\t\t\taiagp->extfreeback = iagp->extfreeback;\n\n\t\tif (back >= 0)\n\t\t\tbiagp->extfreefwd = iagp->extfreefwd;\n\t\telse\n\t\t\timap->im_agctl[agno].extfree =\n\t\t\t    le32_to_cpu(iagp->extfreefwd);\n\n\t\tiagp->extfreefwd = iagp->extfreeback = cpu_to_le32(-1);\n\t} else {\n\t\t/* if the iag has all free extents (newly allocated iag),\n\t\t * add the iag to the ag free extent list.\n\t\t */\n\t\tif (iagp->nfreeexts == cpu_to_le32(EXTSPERIAG)) {\n\t\t\tif (fwd >= 0)\n\t\t\t\taiagp->extfreeback = cpu_to_le32(iagno);\n\n\t\t\tiagp->extfreefwd = cpu_to_le32(fwd);\n\t\t\tiagp->extfreeback = cpu_to_le32(-1);\n\t\t\timap->im_agctl[agno].extfree = iagno;\n\t\t}\n\t}\n\n\t/* if the iag has no free inodes, add the iag to the\n\t * ag free inode list.\n\t */\n\tif (iagp->nfreeinos == 0) {\n\t\tif (freei >= 0)\n\t\t\tciagp->inofreeback = cpu_to_le32(iagno);\n\n\t\tiagp->inofreefwd =\n\t\t    cpu_to_le32(imap->im_agctl[agno].inofree);\n\t\tiagp->inofreeback = cpu_to_le32(-1);\n\t\timap->im_agctl[agno].inofree = iagno;\n\t}\n\n\t/* initialize the extent descriptor of the extent. */\n\tPXDlength(&iagp->inoext[extno], imap->im_nbperiext);\n\tPXDaddress(&iagp->inoext[extno], blkno);\n\n\t/* initialize the working and persistent map of the extent.\n\t * the working map will be initialized such that\n\t * it indicates the first inode of the extent is allocated.\n\t */\n\tiagp->wmap[extno] = cpu_to_le32(HIGHORDER);\n\tiagp->pmap[extno] = 0;\n\n\t/* update the free inode and free extent summary maps\n\t * for the extent to indicate the extent has free inodes\n\t * and no longer represents a free extent.\n\t */\n\tsword = extno >> L2EXTSPERSUM;\n\tmask = HIGHORDER >> (extno & (EXTSPERSUM - 1));\n\tiagp->extsmap[sword] |= cpu_to_le32(mask);\n\tiagp->inosmap[sword] &= cpu_to_le32(~mask);\n\n\t/* update the free inode and free extent counts for the\n\t * iag.\n\t */\n\tle32_add_cpu(&iagp->nfreeinos, (INOSPEREXT - 1));\n\tle32_add_cpu(&iagp->nfreeexts, -1);\n\n\t/* update the free and backed inode counts for the ag.\n\t */\n\timap->im_agctl[agno].numfree += (INOSPEREXT - 1);\n\timap->im_agctl[agno].numinos += INOSPEREXT;\n\n\t/* update the free and backed inode counts for the inode map.\n\t */\n\tatomic_add(INOSPEREXT - 1, &imap->im_numfree);\n\tatomic_add(INOSPEREXT, &imap->im_numinos);\n\n\t/* write the iags.\n\t */\n\tif (amp)\n\t\twrite_metapage(amp);\n\tif (bmp)\n\t\twrite_metapage(bmp);\n\tif (cmp)\n\t\twrite_metapage(cmp);\n\n\treturn (0);\n\n      error_out:\n\n\t/* release the iags.\n\t */\n\tif (amp)\n\t\trelease_metapage(amp);\n\tif (bmp)\n\t\trelease_metapage(bmp);\n\tif (cmp)\n\t\trelease_metapage(cmp);\n\n\treturn (rc);\n}",
          "includes": [
            "#include \"jfs_debug.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_imap.h\"",
            "#include \"jfs_dmap.h\"",
            "#include \"jfs_dinode.h\"",
            "#include \"jfs_filsys.h\"",
            "#include \"jfs_inode.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/slab.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int diAllocAG(struct inomap *, int, bool, struct inode *);",
            "static int diAllocAny(struct inomap *, int, bool, struct inode *);",
            "static int diAllocBit(struct inomap *, struct iag *, int);",
            "static int diAllocExt(struct inomap *, int, struct inode *);",
            "static int diAllocIno(struct inomap *, int, struct inode *);",
            "static int diFindFree(u32, int);",
            "static int diNewExt(struct inomap *, struct iag *, int);",
            "static int diNewIAG(struct inomap *, int *, int, struct metapage **);",
            "static void duplicateIXtree(struct super_block *, s64, int, s64 *);",
            "static int diIAGRead(struct inomap * imap, int, struct metapage **);",
            "static int copy_from_dinode(struct dinode *, struct inode *);",
            "static void copy_to_dinode(struct dinode *, struct inode *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_imap.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_dinode.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_inode.h\"\n#include \"jfs_incore.h\"\n#include <linux/slab.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n\nstatic int diAllocAG(struct inomap *, int, bool, struct inode *);\nstatic int diAllocAny(struct inomap *, int, bool, struct inode *);\nstatic int diAllocBit(struct inomap *, struct iag *, int);\nstatic int diAllocExt(struct inomap *, int, struct inode *);\nstatic int diAllocIno(struct inomap *, int, struct inode *);\nstatic int diFindFree(u32, int);\nstatic int diNewExt(struct inomap *, struct iag *, int);\nstatic int diNewIAG(struct inomap *, int *, int, struct metapage **);\nstatic void duplicateIXtree(struct super_block *, s64, int, s64 *);\nstatic int diIAGRead(struct inomap * imap, int, struct metapage **);\nstatic int copy_from_dinode(struct dinode *, struct inode *);\nstatic void copy_to_dinode(struct dinode *, struct inode *);\n\nstatic int diNewExt(struct inomap * imap, struct iag * iagp, int extno)\n{\n\tint agno, iagno, fwd, back, freei = 0, sword, rc;\n\tstruct iag *aiagp = NULL, *biagp = NULL, *ciagp = NULL;\n\tstruct metapage *amp, *bmp, *cmp, *dmp;\n\tstruct inode *ipimap;\n\ts64 blkno, hint;\n\tint i, j;\n\tu32 mask;\n\tino_t ino;\n\tstruct dinode *dp;\n\tstruct jfs_sb_info *sbi;\n\n\t/* better have free extents.\n\t */\n\tif (!iagp->nfreeexts) {\n\t\tjfs_error(imap->im_ipimap->i_sb, \"no free extents\\n\");\n\t\treturn -EIO;\n\t}\n\n\t/* get the inode map inode.\n\t */\n\tipimap = imap->im_ipimap;\n\tsbi = JFS_SBI(ipimap->i_sb);\n\n\tamp = bmp = cmp = NULL;\n\n\t/* get the ag and iag numbers for this iag.\n\t */\n\tagno = BLKTOAG(le64_to_cpu(iagp->agstart), sbi);\n\tiagno = le32_to_cpu(iagp->iagnum);\n\n\t/* check if this is the last free extent within the\n\t * iag.  if so, the iag must be removed from the ag\n\t * free extent list, so get the iags preceding and\n\t * following the iag on this list.\n\t */\n\tif (iagp->nfreeexts == cpu_to_le32(1)) {\n\t\tif ((fwd = le32_to_cpu(iagp->extfreefwd)) >= 0) {\n\t\t\tif ((rc = diIAGRead(imap, fwd, &amp)))\n\t\t\t\treturn (rc);\n\t\t\taiagp = (struct iag *) amp->data;\n\t\t}\n\n\t\tif ((back = le32_to_cpu(iagp->extfreeback)) >= 0) {\n\t\t\tif ((rc = diIAGRead(imap, back, &bmp)))\n\t\t\t\tgoto error_out;\n\t\t\tbiagp = (struct iag *) bmp->data;\n\t\t}\n\t} else {\n\t\t/* the iag has free extents.  if all extents are free\n\t\t * (as is the case for a newly allocated iag), the iag\n\t\t * must be added to the ag free extent list, so get\n\t\t * the iag at the head of the list in preparation for\n\t\t * adding this iag to this list.\n\t\t */\n\t\tfwd = back = -1;\n\t\tif (iagp->nfreeexts == cpu_to_le32(EXTSPERIAG)) {\n\t\t\tif ((fwd = imap->im_agctl[agno].extfree) >= 0) {\n\t\t\t\tif ((rc = diIAGRead(imap, fwd, &amp)))\n\t\t\t\t\tgoto error_out;\n\t\t\t\taiagp = (struct iag *) amp->data;\n\t\t\t}\n\t\t}\n\t}\n\n\t/* check if the iag has no free inodes.  if so, the iag\n\t * will have to be added to the ag free inode list, so get\n\t * the iag at the head of the list in preparation for\n\t * adding this iag to this list.  in doing this, we must\n\t * check if we already have the iag at the head of\n\t * the list in hand.\n\t */\n\tif (iagp->nfreeinos == 0) {\n\t\tfreei = imap->im_agctl[agno].inofree;\n\n\t\tif (freei >= 0) {\n\t\t\tif (freei == fwd) {\n\t\t\t\tciagp = aiagp;\n\t\t\t} else if (freei == back) {\n\t\t\t\tciagp = biagp;\n\t\t\t} else {\n\t\t\t\tif ((rc = diIAGRead(imap, freei, &cmp)))\n\t\t\t\t\tgoto error_out;\n\t\t\t\tciagp = (struct iag *) cmp->data;\n\t\t\t}\n\t\t\tif (ciagp == NULL) {\n\t\t\t\tjfs_error(imap->im_ipimap->i_sb,\n\t\t\t\t\t  \"ciagp == NULL\\n\");\n\t\t\t\trc = -EIO;\n\t\t\t\tgoto error_out;\n\t\t\t}\n\t\t}\n\t}\n\n\t/* allocate disk space for the inode extent.\n\t */\n\tif ((extno == 0) || (addressPXD(&iagp->inoext[extno - 1]) == 0))\n\t\thint = ((s64) agno << sbi->bmap->db_agl2size) - 1;\n\telse\n\t\thint = addressPXD(&iagp->inoext[extno - 1]) +\n\t\t    lengthPXD(&iagp->inoext[extno - 1]) - 1;\n\n\tif ((rc = dbAlloc(ipimap, hint, (s64) imap->im_nbperiext, &blkno)))\n\t\tgoto error_out;\n\n\t/* compute the inode number of the first inode within the\n\t * extent.\n\t */\n\tino = (iagno << L2INOSPERIAG) + (extno << L2INOSPEREXT);\n\n\t/* initialize the inodes within the newly allocated extent a\n\t * page at a time.\n\t */\n\tfor (i = 0; i < imap->im_nbperiext; i += sbi->nbperpage) {\n\t\t/* get a buffer for this page of disk inodes.\n\t\t */\n\t\tdmp = get_metapage(ipimap, blkno + i, PSIZE, 1);\n\t\tif (dmp == NULL) {\n\t\t\trc = -EIO;\n\t\t\tgoto error_out;\n\t\t}\n\t\tdp = (struct dinode *) dmp->data;\n\n\t\t/* initialize the inode number, mode, link count and\n\t\t * inode extent address.\n\t\t */\n\t\tfor (j = 0; j < INOSPERPAGE; j++, dp++, ino++) {\n\t\t\tdp->di_inostamp = cpu_to_le32(sbi->inostamp);\n\t\t\tdp->di_number = cpu_to_le32(ino);\n\t\t\tdp->di_fileset = cpu_to_le32(FILESYSTEM_I);\n\t\t\tdp->di_mode = 0;\n\t\t\tdp->di_nlink = 0;\n\t\t\tPXDaddress(&(dp->di_ixpxd), blkno);\n\t\t\tPXDlength(&(dp->di_ixpxd), imap->im_nbperiext);\n\t\t}\n\t\twrite_metapage(dmp);\n\t}\n\n\t/* if this is the last free extent within the iag, remove the\n\t * iag from the ag free extent list.\n\t */\n\tif (iagp->nfreeexts == cpu_to_le32(1)) {\n\t\tif (fwd >= 0)\n\t\t\taiagp->extfreeback = iagp->extfreeback;\n\n\t\tif (back >= 0)\n\t\t\tbiagp->extfreefwd = iagp->extfreefwd;\n\t\telse\n\t\t\timap->im_agctl[agno].extfree =\n\t\t\t    le32_to_cpu(iagp->extfreefwd);\n\n\t\tiagp->extfreefwd = iagp->extfreeback = cpu_to_le32(-1);\n\t} else {\n\t\t/* if the iag has all free extents (newly allocated iag),\n\t\t * add the iag to the ag free extent list.\n\t\t */\n\t\tif (iagp->nfreeexts == cpu_to_le32(EXTSPERIAG)) {\n\t\t\tif (fwd >= 0)\n\t\t\t\taiagp->extfreeback = cpu_to_le32(iagno);\n\n\t\t\tiagp->extfreefwd = cpu_to_le32(fwd);\n\t\t\tiagp->extfreeback = cpu_to_le32(-1);\n\t\t\timap->im_agctl[agno].extfree = iagno;\n\t\t}\n\t}\n\n\t/* if the iag has no free inodes, add the iag to the\n\t * ag free inode list.\n\t */\n\tif (iagp->nfreeinos == 0) {\n\t\tif (freei >= 0)\n\t\t\tciagp->inofreeback = cpu_to_le32(iagno);\n\n\t\tiagp->inofreefwd =\n\t\t    cpu_to_le32(imap->im_agctl[agno].inofree);\n\t\tiagp->inofreeback = cpu_to_le32(-1);\n\t\timap->im_agctl[agno].inofree = iagno;\n\t}\n\n\t/* initialize the extent descriptor of the extent. */\n\tPXDlength(&iagp->inoext[extno], imap->im_nbperiext);\n\tPXDaddress(&iagp->inoext[extno], blkno);\n\n\t/* initialize the working and persistent map of the extent.\n\t * the working map will be initialized such that\n\t * it indicates the first inode of the extent is allocated.\n\t */\n\tiagp->wmap[extno] = cpu_to_le32(HIGHORDER);\n\tiagp->pmap[extno] = 0;\n\n\t/* update the free inode and free extent summary maps\n\t * for the extent to indicate the extent has free inodes\n\t * and no longer represents a free extent.\n\t */\n\tsword = extno >> L2EXTSPERSUM;\n\tmask = HIGHORDER >> (extno & (EXTSPERSUM - 1));\n\tiagp->extsmap[sword] |= cpu_to_le32(mask);\n\tiagp->inosmap[sword] &= cpu_to_le32(~mask);\n\n\t/* update the free inode and free extent counts for the\n\t * iag.\n\t */\n\tle32_add_cpu(&iagp->nfreeinos, (INOSPEREXT - 1));\n\tle32_add_cpu(&iagp->nfreeexts, -1);\n\n\t/* update the free and backed inode counts for the ag.\n\t */\n\timap->im_agctl[agno].numfree += (INOSPEREXT - 1);\n\timap->im_agctl[agno].numinos += INOSPEREXT;\n\n\t/* update the free and backed inode counts for the inode map.\n\t */\n\tatomic_add(INOSPEREXT - 1, &imap->im_numfree);\n\tatomic_add(INOSPEREXT, &imap->im_numinos);\n\n\t/* write the iags.\n\t */\n\tif (amp)\n\t\twrite_metapage(amp);\n\tif (bmp)\n\t\twrite_metapage(bmp);\n\tif (cmp)\n\t\twrite_metapage(cmp);\n\n\treturn (0);\n\n      error_out:\n\n\t/* release the iags.\n\t */\n\tif (amp)\n\t\trelease_metapage(amp);\n\tif (bmp)\n\t\trelease_metapage(bmp);\n\tif (cmp)\n\t\trelease_metapage(cmp);\n\n\treturn (rc);\n}"
        }
      },
      {
        "call_info": {
          "callee": "diFindFree",
          "args": [
            "extsmap",
            "0"
          ],
          "line": 1557
        },
        "resolved": true,
        "details": {
          "function_name": "diFindFree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_imap.c",
          "lines": "2706-2717",
          "snippet": "static int diFindFree(u32 word, int start)\n{\n\tint bitno;\n\tassert(start < 32);\n\t/* scan the word for the first free bit. */\n\tfor (word <<= start, bitno = start; bitno < 32;\n\t     bitno++, word <<= 1) {\n\t\tif ((word & HIGHORDER) == 0)\n\t\t\tbreak;\n\t}\n\treturn (bitno);\n}",
          "includes": [
            "#include \"jfs_debug.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_imap.h\"",
            "#include \"jfs_dmap.h\"",
            "#include \"jfs_dinode.h\"",
            "#include \"jfs_filsys.h\"",
            "#include \"jfs_inode.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/slab.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int diFindFree(u32, int);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_imap.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_dinode.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_inode.h\"\n#include \"jfs_incore.h\"\n#include <linux/slab.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n\nstatic int diFindFree(u32, int);\n\nstatic int diFindFree(u32 word, int start)\n{\n\tint bitno;\n\tassert(start < 32);\n\t/* scan the word for the first free bit. */\n\tfor (word <<= start, bitno = start; bitno < 32;\n\t     bitno++, word <<= 1) {\n\t\tif ((word & HIGHORDER) == 0)\n\t\t\tbreak;\n\t}\n\treturn (bitno);\n}"
        }
      },
      {
        "call_info": {
          "callee": "AG_UNLOCK",
          "args": [
            "imap",
            "agno"
          ],
          "line": 1544
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mark_metapage_dirty",
          "args": [
            "mp"
          ],
          "line": 1538
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IREAD_UNLOCK",
          "args": [
            "ipimap"
          ],
          "line": 1529
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "diAllocBit",
          "args": [
            "imap",
            "iagp",
            "ino"
          ],
          "line": 1528
        },
        "resolved": true,
        "details": {
          "function_name": "diAllocBit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_imap.c",
          "lines": "2024-2124",
          "snippet": "static int diAllocBit(struct inomap * imap, struct iag * iagp, int ino)\n{\n\tint extno, bitno, agno, sword, rc;\n\tstruct metapage *amp = NULL, *bmp = NULL;\n\tstruct iag *aiagp = NULL, *biagp = NULL;\n\tu32 mask;\n\n\t/* check if this is the last free inode within the iag.\n\t * if so, it will have to be removed from the ag free\n\t * inode list, so get the iags preceding and following\n\t * it on the list.\n\t */\n\tif (iagp->nfreeinos == cpu_to_le32(1)) {\n\t\tif ((int) le32_to_cpu(iagp->inofreefwd) >= 0) {\n\t\t\tif ((rc =\n\t\t\t     diIAGRead(imap, le32_to_cpu(iagp->inofreefwd),\n\t\t\t\t       &amp)))\n\t\t\t\treturn (rc);\n\t\t\taiagp = (struct iag *) amp->data;\n\t\t}\n\n\t\tif ((int) le32_to_cpu(iagp->inofreeback) >= 0) {\n\t\t\tif ((rc =\n\t\t\t     diIAGRead(imap,\n\t\t\t\t       le32_to_cpu(iagp->inofreeback),\n\t\t\t\t       &bmp))) {\n\t\t\t\tif (amp)\n\t\t\t\t\trelease_metapage(amp);\n\t\t\t\treturn (rc);\n\t\t\t}\n\t\t\tbiagp = (struct iag *) bmp->data;\n\t\t}\n\t}\n\n\t/* get the ag number, extent number, inode number within\n\t * the extent.\n\t */\n\tagno = BLKTOAG(le64_to_cpu(iagp->agstart), JFS_SBI(imap->im_ipimap->i_sb));\n\textno = ino >> L2INOSPEREXT;\n\tbitno = ino & (INOSPEREXT - 1);\n\n\t/* compute the mask for setting the map.\n\t */\n\tmask = HIGHORDER >> bitno;\n\n\t/* the inode should be free and backed.\n\t */\n\tif (((le32_to_cpu(iagp->pmap[extno]) & mask) != 0) ||\n\t    ((le32_to_cpu(iagp->wmap[extno]) & mask) != 0) ||\n\t    (addressPXD(&iagp->inoext[extno]) == 0)) {\n\t\tif (amp)\n\t\t\trelease_metapage(amp);\n\t\tif (bmp)\n\t\t\trelease_metapage(bmp);\n\n\t\tjfs_error(imap->im_ipimap->i_sb, \"iag inconsistent\\n\");\n\t\treturn -EIO;\n\t}\n\n\t/* mark the inode as allocated in the working map.\n\t */\n\tiagp->wmap[extno] |= cpu_to_le32(mask);\n\n\t/* check if all inodes within the extent are now\n\t * allocated.  if so, update the free inode summary\n\t * map to reflect this.\n\t */\n\tif (iagp->wmap[extno] == cpu_to_le32(ONES)) {\n\t\tsword = extno >> L2EXTSPERSUM;\n\t\tbitno = extno & (EXTSPERSUM - 1);\n\t\tiagp->inosmap[sword] |= cpu_to_le32(HIGHORDER >> bitno);\n\t}\n\n\t/* if this was the last free inode in the iag, remove the\n\t * iag from the ag free inode list.\n\t */\n\tif (iagp->nfreeinos == cpu_to_le32(1)) {\n\t\tif (amp) {\n\t\t\taiagp->inofreeback = iagp->inofreeback;\n\t\t\twrite_metapage(amp);\n\t\t}\n\n\t\tif (bmp) {\n\t\t\tbiagp->inofreefwd = iagp->inofreefwd;\n\t\t\twrite_metapage(bmp);\n\t\t} else {\n\t\t\timap->im_agctl[agno].inofree =\n\t\t\t    le32_to_cpu(iagp->inofreefwd);\n\t\t}\n\t\tiagp->inofreefwd = iagp->inofreeback = cpu_to_le32(-1);\n\t}\n\n\t/* update the free inode count at the iag, ag, inode\n\t * map levels.\n\t */\n\tle32_add_cpu(&iagp->nfreeinos, -1);\n\timap->im_agctl[agno].numfree -= 1;\n\tatomic_dec(&imap->im_numfree);\n\n\treturn (0);\n}",
          "includes": [
            "#include \"jfs_debug.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_imap.h\"",
            "#include \"jfs_dmap.h\"",
            "#include \"jfs_dinode.h\"",
            "#include \"jfs_filsys.h\"",
            "#include \"jfs_inode.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/slab.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int diAllocAG(struct inomap *, int, bool, struct inode *);",
            "static int diAllocAny(struct inomap *, int, bool, struct inode *);",
            "static int diAllocBit(struct inomap *, struct iag *, int);",
            "static int diAllocExt(struct inomap *, int, struct inode *);",
            "static int diAllocIno(struct inomap *, int, struct inode *);",
            "static int diFindFree(u32, int);",
            "static int diNewExt(struct inomap *, struct iag *, int);",
            "static int diNewIAG(struct inomap *, int *, int, struct metapage **);",
            "static int diIAGRead(struct inomap * imap, int, struct metapage **);",
            "static int copy_from_dinode(struct dinode *, struct inode *);",
            "static void copy_to_dinode(struct dinode *, struct inode *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_imap.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_dinode.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_inode.h\"\n#include \"jfs_incore.h\"\n#include <linux/slab.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n\nstatic int diAllocAG(struct inomap *, int, bool, struct inode *);\nstatic int diAllocAny(struct inomap *, int, bool, struct inode *);\nstatic int diAllocBit(struct inomap *, struct iag *, int);\nstatic int diAllocExt(struct inomap *, int, struct inode *);\nstatic int diAllocIno(struct inomap *, int, struct inode *);\nstatic int diFindFree(u32, int);\nstatic int diNewExt(struct inomap *, struct iag *, int);\nstatic int diNewIAG(struct inomap *, int *, int, struct metapage **);\nstatic int diIAGRead(struct inomap * imap, int, struct metapage **);\nstatic int copy_from_dinode(struct dinode *, struct inode *);\nstatic void copy_to_dinode(struct dinode *, struct inode *);\n\nstatic int diAllocBit(struct inomap * imap, struct iag * iagp, int ino)\n{\n\tint extno, bitno, agno, sword, rc;\n\tstruct metapage *amp = NULL, *bmp = NULL;\n\tstruct iag *aiagp = NULL, *biagp = NULL;\n\tu32 mask;\n\n\t/* check if this is the last free inode within the iag.\n\t * if so, it will have to be removed from the ag free\n\t * inode list, so get the iags preceding and following\n\t * it on the list.\n\t */\n\tif (iagp->nfreeinos == cpu_to_le32(1)) {\n\t\tif ((int) le32_to_cpu(iagp->inofreefwd) >= 0) {\n\t\t\tif ((rc =\n\t\t\t     diIAGRead(imap, le32_to_cpu(iagp->inofreefwd),\n\t\t\t\t       &amp)))\n\t\t\t\treturn (rc);\n\t\t\taiagp = (struct iag *) amp->data;\n\t\t}\n\n\t\tif ((int) le32_to_cpu(iagp->inofreeback) >= 0) {\n\t\t\tif ((rc =\n\t\t\t     diIAGRead(imap,\n\t\t\t\t       le32_to_cpu(iagp->inofreeback),\n\t\t\t\t       &bmp))) {\n\t\t\t\tif (amp)\n\t\t\t\t\trelease_metapage(amp);\n\t\t\t\treturn (rc);\n\t\t\t}\n\t\t\tbiagp = (struct iag *) bmp->data;\n\t\t}\n\t}\n\n\t/* get the ag number, extent number, inode number within\n\t * the extent.\n\t */\n\tagno = BLKTOAG(le64_to_cpu(iagp->agstart), JFS_SBI(imap->im_ipimap->i_sb));\n\textno = ino >> L2INOSPEREXT;\n\tbitno = ino & (INOSPEREXT - 1);\n\n\t/* compute the mask for setting the map.\n\t */\n\tmask = HIGHORDER >> bitno;\n\n\t/* the inode should be free and backed.\n\t */\n\tif (((le32_to_cpu(iagp->pmap[extno]) & mask) != 0) ||\n\t    ((le32_to_cpu(iagp->wmap[extno]) & mask) != 0) ||\n\t    (addressPXD(&iagp->inoext[extno]) == 0)) {\n\t\tif (amp)\n\t\t\trelease_metapage(amp);\n\t\tif (bmp)\n\t\t\trelease_metapage(bmp);\n\n\t\tjfs_error(imap->im_ipimap->i_sb, \"iag inconsistent\\n\");\n\t\treturn -EIO;\n\t}\n\n\t/* mark the inode as allocated in the working map.\n\t */\n\tiagp->wmap[extno] |= cpu_to_le32(mask);\n\n\t/* check if all inodes within the extent are now\n\t * allocated.  if so, update the free inode summary\n\t * map to reflect this.\n\t */\n\tif (iagp->wmap[extno] == cpu_to_le32(ONES)) {\n\t\tsword = extno >> L2EXTSPERSUM;\n\t\tbitno = extno & (EXTSPERSUM - 1);\n\t\tiagp->inosmap[sword] |= cpu_to_le32(HIGHORDER >> bitno);\n\t}\n\n\t/* if this was the last free inode in the iag, remove the\n\t * iag from the ag free inode list.\n\t */\n\tif (iagp->nfreeinos == cpu_to_le32(1)) {\n\t\tif (amp) {\n\t\t\taiagp->inofreeback = iagp->inofreeback;\n\t\t\twrite_metapage(amp);\n\t\t}\n\n\t\tif (bmp) {\n\t\t\tbiagp->inofreefwd = iagp->inofreefwd;\n\t\t\twrite_metapage(bmp);\n\t\t} else {\n\t\t\timap->im_agctl[agno].inofree =\n\t\t\t    le32_to_cpu(iagp->inofreefwd);\n\t\t}\n\t\tiagp->inofreefwd = iagp->inofreeback = cpu_to_le32(-1);\n\t}\n\n\t/* update the free inode count at the iag, ag, inode\n\t * map levels.\n\t */\n\tle32_add_cpu(&iagp->nfreeinos, -1);\n\timap->im_agctl[agno].numfree -= 1;\n\tatomic_dec(&imap->im_numfree);\n\n\treturn (0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "jfs_error",
          "args": [
            "ip->i_sb",
            "\"can't find free bit in wmap\\n\""
          ],
          "line": 1518
        },
        "resolved": true,
        "details": {
          "function_name": "jfs_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/super.c",
          "lines": "95-111",
          "snippet": "void jfs_error(struct super_block *sb, const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tva_start(args, fmt);\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tpr_err(\"ERROR: (device %s): %pf: %pV\\n\",\n\t       sb->s_id, __builtin_return_address(0), &vaf);\n\n\tva_end(args);\n\n\tjfs_handle_error(sb);\n}",
          "includes": [
            "#include \"jfs_xattr.h\"",
            "#include \"jfs_debug.h\"",
            "#include \"jfs_acl.h\"",
            "#include \"jfs_imap.h\"",
            "#include \"jfs_dmap.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_inode.h\"",
            "#include \"jfs_filsys.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/blkdev.h>",
            "#include <linux/seq_file.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/crc32.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/mount.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/vfs.h>",
            "#include <linux/completion.h>",
            "#include <linux/parser.h>",
            "#include <linux/module.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_xattr.h\"\n#include \"jfs_debug.h\"\n#include \"jfs_acl.h\"\n#include \"jfs_imap.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_inode.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_incore.h\"\n#include <linux/blkdev.h>\n#include <linux/seq_file.h>\n#include <asm/uaccess.h>\n#include <linux/slab.h>\n#include <linux/crc32.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/posix_acl.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/mount.h>\n#include <linux/quotaops.h>\n#include <linux/vfs.h>\n#include <linux/completion.h>\n#include <linux/parser.h>\n#include <linux/module.h>\n#include <linux/fs.h>\n\nvoid jfs_error(struct super_block *sb, const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tva_start(args, fmt);\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tpr_err(\"ERROR: (device %s): %pf: %pV\\n\",\n\t       sb->s_id, __builtin_return_address(0), &vaf);\n\n\tva_end(args);\n\n\tjfs_handle_error(sb);\n}"
        }
      },
      {
        "call_info": {
          "callee": "AG_UNLOCK",
          "args": [
            "imap",
            "agno"
          ],
          "line": 1517
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IREAD_UNLOCK",
          "args": [
            "ipimap"
          ],
          "line": 1515
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AG_UNLOCK",
          "args": [
            "imap",
            "agno"
          ],
          "line": 1461
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mark_metapage_dirty",
          "args": [
            "mp"
          ],
          "line": 1455
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IREAD_UNLOCK",
          "args": [
            "ipimap"
          ],
          "line": 1446
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "addressPXD",
          "args": [
            "&iagp->inoext[extno]"
          ],
          "line": 1434
        },
        "resolved": true,
        "details": {
          "function_name": "addressPXD",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_types.h",
          "lines": "91-95",
          "snippet": "static inline __u64 addressPXD(pxd_t *pxd)\n{\n\t__u64 n = le32_to_cpu(pxd->len_addr) & ~0xffffff;\n\treturn (n << 8) + le32_to_cpu(pxd->addr2);\n}",
          "includes": [
            "#include <linux/nls.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/nls.h>\n#include <linux/types.h>\n\nstatic inline __u64 addressPXD(pxd_t *pxd)\n{\n\t__u64 n = le32_to_cpu(pxd->len_addr) & ~0xffffff;\n\treturn (n << 8) + le32_to_cpu(pxd->addr2);\n}"
        }
      },
      {
        "call_info": {
          "callee": "AG_UNLOCK",
          "args": [
            "imap",
            "agno"
          ],
          "line": 1409
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IREAD_UNLOCK",
          "args": [
            "ipimap"
          ],
          "line": 1408
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "diIAGRead",
          "args": [
            "imap",
            "iagno",
            "&mp"
          ],
          "line": 1407
        },
        "resolved": true,
        "details": {
          "function_name": "diIAGRead",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_imap.c",
          "lines": "2675-2690",
          "snippet": "static int diIAGRead(struct inomap * imap, int iagno, struct metapage ** mpp)\n{\n\tstruct inode *ipimap = imap->im_ipimap;\n\ts64 blkno;\n\n\t/* compute the logical block number of the iag. */\n\tblkno = IAGTOLBLK(iagno, JFS_SBI(ipimap->i_sb)->l2nbperpage);\n\n\t/* read the iag. */\n\t*mpp = read_metapage(ipimap, blkno, PSIZE, 0);\n\tif (*mpp == NULL) {\n\t\treturn -EIO;\n\t}\n\n\treturn (0);\n}",
          "includes": [
            "#include \"jfs_debug.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_imap.h\"",
            "#include \"jfs_dmap.h\"",
            "#include \"jfs_dinode.h\"",
            "#include \"jfs_filsys.h\"",
            "#include \"jfs_inode.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/slab.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int diAllocAG(struct inomap *, int, bool, struct inode *);",
            "static int diAllocAny(struct inomap *, int, bool, struct inode *);",
            "static int diAllocBit(struct inomap *, struct iag *, int);",
            "static int diAllocExt(struct inomap *, int, struct inode *);",
            "static int diAllocIno(struct inomap *, int, struct inode *);",
            "static int diNewExt(struct inomap *, struct iag *, int);",
            "static int diNewIAG(struct inomap *, int *, int, struct metapage **);",
            "static void duplicateIXtree(struct super_block *, s64, int, s64 *);",
            "static int diIAGRead(struct inomap * imap, int, struct metapage **);",
            "static int copy_from_dinode(struct dinode *, struct inode *);",
            "static void copy_to_dinode(struct dinode *, struct inode *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_imap.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_dinode.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_inode.h\"\n#include \"jfs_incore.h\"\n#include <linux/slab.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n\nstatic int diAllocAG(struct inomap *, int, bool, struct inode *);\nstatic int diAllocAny(struct inomap *, int, bool, struct inode *);\nstatic int diAllocBit(struct inomap *, struct iag *, int);\nstatic int diAllocExt(struct inomap *, int, struct inode *);\nstatic int diAllocIno(struct inomap *, int, struct inode *);\nstatic int diNewExt(struct inomap *, struct iag *, int);\nstatic int diNewIAG(struct inomap *, int *, int, struct metapage **);\nstatic void duplicateIXtree(struct super_block *, s64, int, s64 *);\nstatic int diIAGRead(struct inomap * imap, int, struct metapage **);\nstatic int copy_from_dinode(struct dinode *, struct inode *);\nstatic void copy_to_dinode(struct dinode *, struct inode *);\n\nstatic int diIAGRead(struct inomap * imap, int iagno, struct metapage ** mpp)\n{\n\tstruct inode *ipimap = imap->im_ipimap;\n\ts64 blkno;\n\n\t/* compute the logical block number of the iag. */\n\tblkno = IAGTOLBLK(iagno, JFS_SBI(ipimap->i_sb)->l2nbperpage);\n\n\t/* read the iag. */\n\t*mpp = read_metapage(ipimap, blkno, PSIZE, 0);\n\tif (*mpp == NULL) {\n\t\treturn -EIO;\n\t}\n\n\treturn (0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "INOTOIAG",
          "args": [
            "inum"
          ],
          "line": 1406
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IREAD_LOCK",
          "args": [
            "ipimap",
            "RDWRLOCK_IMAP"
          ],
          "line": 1403
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AG_LOCK",
          "args": [
            "imap",
            "agno"
          ],
          "line": 1400
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AG_LOCK",
          "args": [
            "imap",
            "agno"
          ],
          "line": 1388
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dbNextAG",
          "args": [
            "JFS_SBI(pip->i_sb)->ipbmap"
          ],
          "line": 1387
        },
        "resolved": true,
        "details": {
          "function_name": "dbNextAG",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_dmap.c",
          "lines": "603-660",
          "snippet": "int dbNextAG(struct inode *ipbmap)\n{\n\ts64 avgfree;\n\tint agpref;\n\ts64 hwm = 0;\n\tint i;\n\tint next_best = -1;\n\tstruct bmap *bmp = JFS_SBI(ipbmap->i_sb)->bmap;\n\n\tBMAP_LOCK(bmp);\n\n\t/* determine the average number of free blocks within the ags. */\n\tavgfree = (u32)bmp->db_nfree / bmp->db_numag;\n\n\t/*\n\t * if the current preferred ag does not have an active allocator\n\t * and has at least average freespace, return it\n\t */\n\tagpref = bmp->db_agpref;\n\tif ((atomic_read(&bmp->db_active[agpref]) == 0) &&\n\t    (bmp->db_agfree[agpref] >= avgfree))\n\t\tgoto unlock;\n\n\t/* From the last preferred ag, find the next one with at least\n\t * average free space.\n\t */\n\tfor (i = 0 ; i < bmp->db_numag; i++, agpref++) {\n\t\tif (agpref == bmp->db_numag)\n\t\t\tagpref = 0;\n\n\t\tif (atomic_read(&bmp->db_active[agpref]))\n\t\t\t/* open file is currently growing in this ag */\n\t\t\tcontinue;\n\t\tif (bmp->db_agfree[agpref] >= avgfree) {\n\t\t\t/* Return this one */\n\t\t\tbmp->db_agpref = agpref;\n\t\t\tgoto unlock;\n\t\t} else if (bmp->db_agfree[agpref] > hwm) {\n\t\t\t/* Less than avg. freespace, but best so far */\n\t\t\thwm = bmp->db_agfree[agpref];\n\t\t\tnext_best = agpref;\n\t\t}\n\t}\n\n\t/*\n\t * If no inactive ag was found with average freespace, use the\n\t * next best\n\t */\n\tif (next_best != -1)\n\t\tbmp->db_agpref = next_best;\n\t/* else leave db_agpref unchanged */\nunlock:\n\tBMAP_UNLOCK(bmp);\n\n\t/* return the preferred group.\n\t */\n\treturn (bmp->db_agpref);\n}",
          "includes": [
            "#include \"jfs_discard.h\"",
            "#include \"jfs_debug.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_lock.h\"",
            "#include \"jfs_imap.h\"",
            "#include \"jfs_dmap.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int dbInitDmapCtl(struct dmapctl * dcp, int level, int i);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_discard.h\"\n#include \"jfs_debug.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_lock.h\"\n#include \"jfs_imap.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_incore.h\"\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic int dbInitDmapCtl(struct dmapctl * dcp, int level, int i);\n\nint dbNextAG(struct inode *ipbmap)\n{\n\ts64 avgfree;\n\tint agpref;\n\ts64 hwm = 0;\n\tint i;\n\tint next_best = -1;\n\tstruct bmap *bmp = JFS_SBI(ipbmap->i_sb)->bmap;\n\n\tBMAP_LOCK(bmp);\n\n\t/* determine the average number of free blocks within the ags. */\n\tavgfree = (u32)bmp->db_nfree / bmp->db_numag;\n\n\t/*\n\t * if the current preferred ag does not have an active allocator\n\t * and has at least average freespace, return it\n\t */\n\tagpref = bmp->db_agpref;\n\tif ((atomic_read(&bmp->db_active[agpref]) == 0) &&\n\t    (bmp->db_agfree[agpref] >= avgfree))\n\t\tgoto unlock;\n\n\t/* From the last preferred ag, find the next one with at least\n\t * average free space.\n\t */\n\tfor (i = 0 ; i < bmp->db_numag; i++, agpref++) {\n\t\tif (agpref == bmp->db_numag)\n\t\t\tagpref = 0;\n\n\t\tif (atomic_read(&bmp->db_active[agpref]))\n\t\t\t/* open file is currently growing in this ag */\n\t\t\tcontinue;\n\t\tif (bmp->db_agfree[agpref] >= avgfree) {\n\t\t\t/* Return this one */\n\t\t\tbmp->db_agpref = agpref;\n\t\t\tgoto unlock;\n\t\t} else if (bmp->db_agfree[agpref] > hwm) {\n\t\t\t/* Less than avg. freespace, but best so far */\n\t\t\thwm = bmp->db_agfree[agpref];\n\t\t\tnext_best = agpref;\n\t\t}\n\t}\n\n\t/*\n\t * If no inactive ag was found with average freespace, use the\n\t * next best\n\t */\n\tif (next_best != -1)\n\t\tbmp->db_agpref = next_best;\n\t/* else leave db_agpref unchanged */\nunlock:\n\tBMAP_UNLOCK(bmp);\n\n\t/* return the preferred group.\n\t */\n\treturn (bmp->db_agpref);\n}"
        }
      },
      {
        "call_info": {
          "callee": "JFS_SBI",
          "args": [
            "pip->i_sb"
          ],
          "line": 1387
        },
        "resolved": true,
        "details": {
          "function_name": "JFS_SBI",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_incore.h",
          "lines": "217-220",
          "snippet": "static inline struct jfs_sb_info *JFS_SBI(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"jfs_dtree.h\"",
            "#include \"jfs_xtree.h\"",
            "#include \"jfs_types.h\"",
            "#include <linux/bitops.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_dtree.h\"\n#include \"jfs_xtree.h\"\n#include \"jfs_types.h\"\n#include <linux/bitops.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mutex.h>\n\nstatic inline struct jfs_sb_info *JFS_SBI(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&JFS_SBI(pip->i_sb)->bmap->db_active[agno]"
          ],
          "line": 1381
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BLKTOAG",
          "args": [
            "JFS_IP(pip)->agstart",
            "JFS_SBI(pip->i_sb)"
          ],
          "line": 1379
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "JFS_IP",
          "args": [
            "pip"
          ],
          "line": 1379
        },
        "resolved": true,
        "details": {
          "function_name": "JFS_IP",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_incore.h",
          "lines": "207-210",
          "snippet": "static inline struct jfs_inode_info *JFS_IP(struct inode *inode)\n{\n\treturn list_entry(inode, struct jfs_inode_info, vfs_inode);\n}",
          "includes": [
            "#include \"jfs_dtree.h\"",
            "#include \"jfs_xtree.h\"",
            "#include \"jfs_types.h\"",
            "#include <linux/bitops.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_dtree.h\"\n#include \"jfs_xtree.h\"\n#include \"jfs_types.h\"\n#include <linux/bitops.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mutex.h>\n\nstatic inline struct jfs_inode_info *JFS_IP(struct inode *inode)\n{\n\treturn list_entry(inode, struct jfs_inode_info, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "AG_LOCK",
          "args": [
            "imap",
            "agno"
          ],
          "line": 1365
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_imap.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_dinode.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_inode.h\"\n#include \"jfs_incore.h\"\n#include <linux/slab.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n\nstatic int diAllocAG(struct inomap *, int, bool, struct inode *);\nstatic int diAllocAny(struct inomap *, int, bool, struct inode *);\nstatic int diAllocBit(struct inomap *, struct iag *, int);\nstatic int diAllocExt(struct inomap *, int, struct inode *);\nstatic int diAllocIno(struct inomap *, int, struct inode *);\nstatic int diFindFree(u32, int);\nstatic int diNewExt(struct inomap *, struct iag *, int);\nstatic int diNewIAG(struct inomap *, int *, int, struct metapage **);\nstatic int diIAGRead(struct inomap * imap, int, struct metapage **);\nstatic int copy_from_dinode(struct dinode *, struct inode *);\nstatic void copy_to_dinode(struct dinode *, struct inode *);\n\nint diAlloc(struct inode *pip, bool dir, struct inode *ip)\n{\n\tint rc, ino, iagno, addext, extno, bitno, sword;\n\tint nwords, rem, i, agno;\n\tu32 mask, inosmap, extsmap;\n\tstruct inode *ipimap;\n\tstruct metapage *mp;\n\tino_t inum;\n\tstruct iag *iagp;\n\tstruct inomap *imap;\n\n\t/* get the pointers to the inode map inode and the\n\t * corresponding imap control structure.\n\t */\n\tipimap = JFS_SBI(pip->i_sb)->ipimap;\n\timap = JFS_IP(ipimap)->i_imap;\n\tJFS_IP(ip)->ipimap = ipimap;\n\tJFS_IP(ip)->fileset = FILESYSTEM_I;\n\n\t/* for a directory, the allocation policy is to start\n\t * at the ag level using the preferred ag.\n\t */\n\tif (dir) {\n\t\tagno = dbNextAG(JFS_SBI(pip->i_sb)->ipbmap);\n\t\tAG_LOCK(imap, agno);\n\t\tgoto tryag;\n\t}\n\n\t/* for files, the policy starts off by trying to allocate from\n\t * the same iag containing the parent disk inode:\n\t * try to allocate the new disk inode close to the parent disk\n\t * inode, using parent disk inode number + 1 as the allocation\n\t * hint.  (we use a left-to-right policy to attempt to avoid\n\t * moving backward on the disk.)  compute the hint within the\n\t * file system and the iag.\n\t */\n\n\t/* get the ag number of this iag */\n\tagno = BLKTOAG(JFS_IP(pip)->agstart, JFS_SBI(pip->i_sb));\n\n\tif (atomic_read(&JFS_SBI(pip->i_sb)->bmap->db_active[agno])) {\n\t\t/*\n\t\t * There is an open file actively growing.  We want to\n\t\t * allocate new inodes from a different ag to avoid\n\t\t * fragmentation problems.\n\t\t */\n\t\tagno = dbNextAG(JFS_SBI(pip->i_sb)->ipbmap);\n\t\tAG_LOCK(imap, agno);\n\t\tgoto tryag;\n\t}\n\n\tinum = pip->i_ino + 1;\n\tino = inum & (INOSPERIAG - 1);\n\n\t/* back off the hint if it is outside of the iag */\n\tif (ino == 0)\n\t\tinum = pip->i_ino;\n\n\t/* lock the AG inode map information */\n\tAG_LOCK(imap, agno);\n\n\t/* Get read lock on imap inode */\n\tIREAD_LOCK(ipimap, RDWRLOCK_IMAP);\n\n\t/* get the iag number and read the iag */\n\tiagno = INOTOIAG(inum);\n\tif ((rc = diIAGRead(imap, iagno, &mp))) {\n\t\tIREAD_UNLOCK(ipimap);\n\t\tAG_UNLOCK(imap, agno);\n\t\treturn (rc);\n\t}\n\tiagp = (struct iag *) mp->data;\n\n\t/* determine if new inode extent is allowed to be added to the iag.\n\t * new inode extent can be added to the iag if the ag\n\t * has less than 32 free disk inodes and the iag has free extents.\n\t */\n\taddext = (imap->im_agctl[agno].numfree < 32 && iagp->nfreeexts);\n\n\t/*\n\t *\ttry to allocate from the IAG\n\t */\n\t/* check if the inode may be allocated from the iag\n\t * (i.e. the inode has free inodes or new extent can be added).\n\t */\n\tif (iagp->nfreeinos || addext) {\n\t\t/* determine the extent number of the hint.\n\t\t */\n\t\textno = ino >> L2INOSPEREXT;\n\n\t\t/* check if the extent containing the hint has backed\n\t\t * inodes.  if so, try to allocate within this extent.\n\t\t */\n\t\tif (addressPXD(&iagp->inoext[extno])) {\n\t\t\tbitno = ino & (INOSPEREXT - 1);\n\t\t\tif ((bitno =\n\t\t\t     diFindFree(le32_to_cpu(iagp->wmap[extno]),\n\t\t\t\t\tbitno))\n\t\t\t    < INOSPEREXT) {\n\t\t\t\tino = (extno << L2INOSPEREXT) + bitno;\n\n\t\t\t\t/* a free inode (bit) was found within this\n\t\t\t\t * extent, so allocate it.\n\t\t\t\t */\n\t\t\t\trc = diAllocBit(imap, iagp, ino);\n\t\t\t\tIREAD_UNLOCK(ipimap);\n\t\t\t\tif (rc) {\n\t\t\t\t\tassert(rc == -EIO);\n\t\t\t\t} else {\n\t\t\t\t\t/* set the results of the allocation\n\t\t\t\t\t * and write the iag.\n\t\t\t\t\t */\n\t\t\t\t\tdiInitInode(ip, iagno, ino, extno,\n\t\t\t\t\t\t    iagp);\n\t\t\t\t\tmark_metapage_dirty(mp);\n\t\t\t\t}\n\t\t\t\trelease_metapage(mp);\n\n\t\t\t\t/* free the AG lock and return.\n\t\t\t\t */\n\t\t\t\tAG_UNLOCK(imap, agno);\n\t\t\t\treturn (rc);\n\t\t\t}\n\n\t\t\tif (!addext)\n\t\t\t\textno =\n\t\t\t\t    (extno ==\n\t\t\t\t     EXTSPERIAG - 1) ? 0 : extno + 1;\n\t\t}\n\n\t\t/*\n\t\t * no free inodes within the extent containing the hint.\n\t\t *\n\t\t * try to allocate from the backed extents following\n\t\t * hint or, if appropriate (i.e. addext is true), allocate\n\t\t * an extent of free inodes at or following the extent\n\t\t * containing the hint.\n\t\t *\n\t\t * the free inode and free extent summary maps are used\n\t\t * here, so determine the starting summary map position\n\t\t * and the number of words we'll have to examine.  again,\n\t\t * the approach is to allocate following the hint, so we\n\t\t * might have to initially ignore prior bits of the summary\n\t\t * map that represent extents prior to the extent containing\n\t\t * the hint and later revisit these bits.\n\t\t */\n\t\tbitno = extno & (EXTSPERSUM - 1);\n\t\tnwords = (bitno == 0) ? SMAPSZ : SMAPSZ + 1;\n\t\tsword = extno >> L2EXTSPERSUM;\n\n\t\t/* mask any prior bits for the starting words of the\n\t\t * summary map.\n\t\t */\n\t\tmask = (bitno == 0) ? 0 : (ONES << (EXTSPERSUM - bitno));\n\t\tinosmap = le32_to_cpu(iagp->inosmap[sword]) | mask;\n\t\textsmap = le32_to_cpu(iagp->extsmap[sword]) | mask;\n\n\t\t/* scan the free inode and free extent summary maps for\n\t\t * free resources.\n\t\t */\n\t\tfor (i = 0; i < nwords; i++) {\n\t\t\t/* check if this word of the free inode summary\n\t\t\t * map describes an extent with free inodes.\n\t\t\t */\n\t\t\tif (~inosmap) {\n\t\t\t\t/* an extent with free inodes has been\n\t\t\t\t * found. determine the extent number\n\t\t\t\t * and the inode number within the extent.\n\t\t\t\t */\n\t\t\t\trem = diFindFree(inosmap, 0);\n\t\t\t\textno = (sword << L2EXTSPERSUM) + rem;\n\t\t\t\trem = diFindFree(le32_to_cpu(iagp->wmap[extno]),\n\t\t\t\t\t\t 0);\n\t\t\t\tif (rem >= INOSPEREXT) {\n\t\t\t\t\tIREAD_UNLOCK(ipimap);\n\t\t\t\t\trelease_metapage(mp);\n\t\t\t\t\tAG_UNLOCK(imap, agno);\n\t\t\t\t\tjfs_error(ip->i_sb,\n\t\t\t\t\t\t  \"can't find free bit in wmap\\n\");\n\t\t\t\t\treturn -EIO;\n\t\t\t\t}\n\n\t\t\t\t/* determine the inode number within the\n\t\t\t\t * iag and allocate the inode from the\n\t\t\t\t * map.\n\t\t\t\t */\n\t\t\t\tino = (extno << L2INOSPEREXT) + rem;\n\t\t\t\trc = diAllocBit(imap, iagp, ino);\n\t\t\t\tIREAD_UNLOCK(ipimap);\n\t\t\t\tif (rc)\n\t\t\t\t\tassert(rc == -EIO);\n\t\t\t\telse {\n\t\t\t\t\t/* set the results of the allocation\n\t\t\t\t\t * and write the iag.\n\t\t\t\t\t */\n\t\t\t\t\tdiInitInode(ip, iagno, ino, extno,\n\t\t\t\t\t\t    iagp);\n\t\t\t\t\tmark_metapage_dirty(mp);\n\t\t\t\t}\n\t\t\t\trelease_metapage(mp);\n\n\t\t\t\t/* free the AG lock and return.\n\t\t\t\t */\n\t\t\t\tAG_UNLOCK(imap, agno);\n\t\t\t\treturn (rc);\n\n\t\t\t}\n\n\t\t\t/* check if we may allocate an extent of free\n\t\t\t * inodes and whether this word of the free\n\t\t\t * extents summary map describes a free extent.\n\t\t\t */\n\t\t\tif (addext && ~extsmap) {\n\t\t\t\t/* a free extent has been found.  determine\n\t\t\t\t * the extent number.\n\t\t\t\t */\n\t\t\t\trem = diFindFree(extsmap, 0);\n\t\t\t\textno = (sword << L2EXTSPERSUM) + rem;\n\n\t\t\t\t/* allocate an extent of free inodes.\n\t\t\t\t */\n\t\t\t\tif ((rc = diNewExt(imap, iagp, extno))) {\n\t\t\t\t\t/* if there is no disk space for a\n\t\t\t\t\t * new extent, try to allocate the\n\t\t\t\t\t * disk inode from somewhere else.\n\t\t\t\t\t */\n\t\t\t\t\tif (rc == -ENOSPC)\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tassert(rc == -EIO);\n\t\t\t\t} else {\n\t\t\t\t\t/* set the results of the allocation\n\t\t\t\t\t * and write the iag.\n\t\t\t\t\t */\n\t\t\t\t\tdiInitInode(ip, iagno,\n\t\t\t\t\t\t    extno << L2INOSPEREXT,\n\t\t\t\t\t\t    extno, iagp);\n\t\t\t\t\tmark_metapage_dirty(mp);\n\t\t\t\t}\n\t\t\t\trelease_metapage(mp);\n\t\t\t\t/* free the imap inode & the AG lock & return.\n\t\t\t\t */\n\t\t\t\tIREAD_UNLOCK(ipimap);\n\t\t\t\tAG_UNLOCK(imap, agno);\n\t\t\t\treturn (rc);\n\t\t\t}\n\n\t\t\t/* move on to the next set of summary map words.\n\t\t\t */\n\t\t\tsword = (sword == SMAPSZ - 1) ? 0 : sword + 1;\n\t\t\tinosmap = le32_to_cpu(iagp->inosmap[sword]);\n\t\t\textsmap = le32_to_cpu(iagp->extsmap[sword]);\n\t\t}\n\t}\n\t/* unlock imap inode */\n\tIREAD_UNLOCK(ipimap);\n\n\t/* nothing doing in this iag, so release it. */\n\trelease_metapage(mp);\n\n      tryag:\n\t/*\n\t * try to allocate anywhere within the same AG as the parent inode.\n\t */\n\trc = diAllocAG(imap, agno, dir, ip);\n\n\tAG_UNLOCK(imap, agno);\n\n\tif (rc != -ENOSPC)\n\t\treturn (rc);\n\n\t/*\n\t * try to allocate in any AG.\n\t */\n\treturn (diAllocAny(imap, agno, dir, ip));\n}"
  },
  {
    "function_name": "diInitInode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_imap.c",
    "lines": "1313-1322",
    "snippet": "static inline void\ndiInitInode(struct inode *ip, int iagno, int ino, int extno, struct iag * iagp)\n{\n\tstruct jfs_inode_info *jfs_ip = JFS_IP(ip);\n\n\tip->i_ino = (iagno << L2INOSPERIAG) + ino;\n\tjfs_ip->ixpxd = iagp->inoext[extno];\n\tjfs_ip->agstart = le64_to_cpu(iagp->agstart);\n\tjfs_ip->active_ag = -1;\n}",
    "includes": [
      "#include \"jfs_debug.h\"",
      "#include \"jfs_superblock.h\"",
      "#include \"jfs_metapage.h\"",
      "#include \"jfs_imap.h\"",
      "#include \"jfs_dmap.h\"",
      "#include \"jfs_dinode.h\"",
      "#include \"jfs_filsys.h\"",
      "#include \"jfs_inode.h\"",
      "#include \"jfs_incore.h\"",
      "#include <linux/slab.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int diAllocAG(struct inomap *, int, bool, struct inode *);",
      "static int diAllocAny(struct inomap *, int, bool, struct inode *);",
      "static int diAllocBit(struct inomap *, struct iag *, int);",
      "static int diAllocExt(struct inomap *, int, struct inode *);",
      "static int diAllocIno(struct inomap *, int, struct inode *);",
      "static int diNewExt(struct inomap *, struct iag *, int);",
      "static int copy_from_dinode(struct dinode *, struct inode *);",
      "static void copy_to_dinode(struct dinode *, struct inode *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "le64_to_cpu",
          "args": [
            "iagp->agstart"
          ],
          "line": 1320
        },
        "resolved": true,
        "details": {
          "function_name": "sle64_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "58-61",
          "snippet": "static inline s64 sle64_to_cpup(sle64 *x)\n{\n\treturn le64_to_cpu(*(__force le64*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s64 sle64_to_cpup(sle64 *x)\n{\n\treturn le64_to_cpu(*(__force le64*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "JFS_IP",
          "args": [
            "ip"
          ],
          "line": 1316
        },
        "resolved": true,
        "details": {
          "function_name": "JFS_IP",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_incore.h",
          "lines": "207-210",
          "snippet": "static inline struct jfs_inode_info *JFS_IP(struct inode *inode)\n{\n\treturn list_entry(inode, struct jfs_inode_info, vfs_inode);\n}",
          "includes": [
            "#include \"jfs_dtree.h\"",
            "#include \"jfs_xtree.h\"",
            "#include \"jfs_types.h\"",
            "#include <linux/bitops.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_dtree.h\"\n#include \"jfs_xtree.h\"\n#include \"jfs_types.h\"\n#include <linux/bitops.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mutex.h>\n\nstatic inline struct jfs_inode_info *JFS_IP(struct inode *inode)\n{\n\treturn list_entry(inode, struct jfs_inode_info, vfs_inode);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_imap.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_dinode.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_inode.h\"\n#include \"jfs_incore.h\"\n#include <linux/slab.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n\nstatic int diAllocAG(struct inomap *, int, bool, struct inode *);\nstatic int diAllocAny(struct inomap *, int, bool, struct inode *);\nstatic int diAllocBit(struct inomap *, struct iag *, int);\nstatic int diAllocExt(struct inomap *, int, struct inode *);\nstatic int diAllocIno(struct inomap *, int, struct inode *);\nstatic int diNewExt(struct inomap *, struct iag *, int);\nstatic int copy_from_dinode(struct dinode *, struct inode *);\nstatic void copy_to_dinode(struct dinode *, struct inode *);\n\nstatic inline void\ndiInitInode(struct inode *ip, int iagno, int ino, int extno, struct iag * iagp)\n{\n\tstruct jfs_inode_info *jfs_ip = JFS_IP(ip);\n\n\tip->i_ino = (iagno << L2INOSPERIAG) + ino;\n\tjfs_ip->ixpxd = iagp->inoext[extno];\n\tjfs_ip->agstart = le64_to_cpu(iagp->agstart);\n\tjfs_ip->active_ag = -1;\n}"
  },
  {
    "function_name": "diFree",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_imap.c",
    "lines": "863-1307",
    "snippet": "int diFree(struct inode *ip)\n{\n\tint rc;\n\tino_t inum = ip->i_ino;\n\tstruct iag *iagp, *aiagp, *biagp, *ciagp, *diagp;\n\tstruct metapage *mp, *amp, *bmp, *cmp, *dmp;\n\tint iagno, ino, extno, bitno, sword, agno;\n\tint back, fwd;\n\tu32 bitmap, mask;\n\tstruct inode *ipimap = JFS_SBI(ip->i_sb)->ipimap;\n\tstruct inomap *imap = JFS_IP(ipimap)->i_imap;\n\tpxd_t freepxd;\n\ttid_t tid;\n\tstruct inode *iplist[3];\n\tstruct tlock *tlck;\n\tstruct pxd_lock *pxdlock;\n\n\t/*\n\t * This is just to suppress compiler warnings.  The same logic that\n\t * references these variables is used to initialize them.\n\t */\n\taiagp = biagp = ciagp = diagp = NULL;\n\n\t/* get the iag number containing the inode.\n\t */\n\tiagno = INOTOIAG(inum);\n\n\t/* make sure that the iag is contained within\n\t * the map.\n\t */\n\tif (iagno >= imap->im_nextiag) {\n\t\tprint_hex_dump(KERN_ERR, \"imap: \", DUMP_PREFIX_ADDRESS, 16, 4,\n\t\t\t       imap, 32, 0);\n\t\tjfs_error(ip->i_sb, \"inum = %d, iagno = %d, nextiag = %d\\n\",\n\t\t\t  (uint) inum, iagno, imap->im_nextiag);\n\t\treturn -EIO;\n\t}\n\n\t/* get the allocation group for this ino.\n\t */\n\tagno = BLKTOAG(JFS_IP(ip)->agstart, JFS_SBI(ip->i_sb));\n\n\t/* Lock the AG specific inode map information\n\t */\n\tAG_LOCK(imap, agno);\n\n\t/* Obtain read lock in imap inode.  Don't release it until we have\n\t * read all of the IAG's that we are going to.\n\t */\n\tIREAD_LOCK(ipimap, RDWRLOCK_IMAP);\n\n\t/* read the iag.\n\t */\n\tif ((rc = diIAGRead(imap, iagno, &mp))) {\n\t\tIREAD_UNLOCK(ipimap);\n\t\tAG_UNLOCK(imap, agno);\n\t\treturn (rc);\n\t}\n\tiagp = (struct iag *) mp->data;\n\n\t/* get the inode number and extent number of the inode within\n\t * the iag and the inode number within the extent.\n\t */\n\tino = inum & (INOSPERIAG - 1);\n\textno = ino >> L2INOSPEREXT;\n\tbitno = ino & (INOSPEREXT - 1);\n\tmask = HIGHORDER >> bitno;\n\n\tif (!(le32_to_cpu(iagp->wmap[extno]) & mask)) {\n\t\tjfs_error(ip->i_sb, \"wmap shows inode already free\\n\");\n\t}\n\n\tif (!addressPXD(&iagp->inoext[extno])) {\n\t\trelease_metapage(mp);\n\t\tIREAD_UNLOCK(ipimap);\n\t\tAG_UNLOCK(imap, agno);\n\t\tjfs_error(ip->i_sb, \"invalid inoext\\n\");\n\t\treturn -EIO;\n\t}\n\n\t/* compute the bitmap for the extent reflecting the freed inode.\n\t */\n\tbitmap = le32_to_cpu(iagp->wmap[extno]) & ~mask;\n\n\tif (imap->im_agctl[agno].numfree > imap->im_agctl[agno].numinos) {\n\t\trelease_metapage(mp);\n\t\tIREAD_UNLOCK(ipimap);\n\t\tAG_UNLOCK(imap, agno);\n\t\tjfs_error(ip->i_sb, \"numfree > numinos\\n\");\n\t\treturn -EIO;\n\t}\n\t/*\n\t *\tinode extent still has some inodes or below low water mark:\n\t *\tkeep the inode extent;\n\t */\n\tif (bitmap ||\n\t    imap->im_agctl[agno].numfree < 96 ||\n\t    (imap->im_agctl[agno].numfree < 288 &&\n\t     (((imap->im_agctl[agno].numfree * 100) /\n\t       imap->im_agctl[agno].numinos) <= 25))) {\n\t\t/* if the iag currently has no free inodes (i.e.,\n\t\t * the inode being freed is the first free inode of iag),\n\t\t * insert the iag at head of the inode free list for the ag.\n\t\t */\n\t\tif (iagp->nfreeinos == 0) {\n\t\t\t/* check if there are any iags on the ag inode\n\t\t\t * free list.  if so, read the first one so that\n\t\t\t * we can link the current iag onto the list at\n\t\t\t * the head.\n\t\t\t */\n\t\t\tif ((fwd = imap->im_agctl[agno].inofree) >= 0) {\n\t\t\t\t/* read the iag that currently is the head\n\t\t\t\t * of the list.\n\t\t\t\t */\n\t\t\t\tif ((rc = diIAGRead(imap, fwd, &amp))) {\n\t\t\t\t\tIREAD_UNLOCK(ipimap);\n\t\t\t\t\tAG_UNLOCK(imap, agno);\n\t\t\t\t\trelease_metapage(mp);\n\t\t\t\t\treturn (rc);\n\t\t\t\t}\n\t\t\t\taiagp = (struct iag *) amp->data;\n\n\t\t\t\t/* make current head point back to the iag.\n\t\t\t\t */\n\t\t\t\taiagp->inofreeback = cpu_to_le32(iagno);\n\n\t\t\t\twrite_metapage(amp);\n\t\t\t}\n\n\t\t\t/* iag points forward to current head and iag\n\t\t\t * becomes the new head of the list.\n\t\t\t */\n\t\t\tiagp->inofreefwd =\n\t\t\t    cpu_to_le32(imap->im_agctl[agno].inofree);\n\t\t\tiagp->inofreeback = cpu_to_le32(-1);\n\t\t\timap->im_agctl[agno].inofree = iagno;\n\t\t}\n\t\tIREAD_UNLOCK(ipimap);\n\n\t\t/* update the free inode summary map for the extent if\n\t\t * freeing the inode means the extent will now have free\n\t\t * inodes (i.e., the inode being freed is the first free\n\t\t * inode of extent),\n\t\t */\n\t\tif (iagp->wmap[extno] == cpu_to_le32(ONES)) {\n\t\t\tsword = extno >> L2EXTSPERSUM;\n\t\t\tbitno = extno & (EXTSPERSUM - 1);\n\t\t\tiagp->inosmap[sword] &=\n\t\t\t    cpu_to_le32(~(HIGHORDER >> bitno));\n\t\t}\n\n\t\t/* update the bitmap.\n\t\t */\n\t\tiagp->wmap[extno] = cpu_to_le32(bitmap);\n\n\t\t/* update the free inode counts at the iag, ag and\n\t\t * map level.\n\t\t */\n\t\tle32_add_cpu(&iagp->nfreeinos, 1);\n\t\timap->im_agctl[agno].numfree += 1;\n\t\tatomic_inc(&imap->im_numfree);\n\n\t\t/* release the AG inode map lock\n\t\t */\n\t\tAG_UNLOCK(imap, agno);\n\n\t\t/* write the iag */\n\t\twrite_metapage(mp);\n\n\t\treturn (0);\n\t}\n\n\n\t/*\n\t *\tinode extent has become free and above low water mark:\n\t *\tfree the inode extent;\n\t */\n\n\t/*\n\t *\tprepare to update iag list(s) (careful update step 1)\n\t */\n\tamp = bmp = cmp = dmp = NULL;\n\tfwd = back = -1;\n\n\t/* check if the iag currently has no free extents.  if so,\n\t * it will be placed on the head of the ag extent free list.\n\t */\n\tif (iagp->nfreeexts == 0) {\n\t\t/* check if the ag extent free list has any iags.\n\t\t * if so, read the iag at the head of the list now.\n\t\t * this (head) iag will be updated later to reflect\n\t\t * the addition of the current iag at the head of\n\t\t * the list.\n\t\t */\n\t\tif ((fwd = imap->im_agctl[agno].extfree) >= 0) {\n\t\t\tif ((rc = diIAGRead(imap, fwd, &amp)))\n\t\t\t\tgoto error_out;\n\t\t\taiagp = (struct iag *) amp->data;\n\t\t}\n\t} else {\n\t\t/* iag has free extents. check if the addition of a free\n\t\t * extent will cause all extents to be free within this\n\t\t * iag.  if so, the iag will be removed from the ag extent\n\t\t * free list and placed on the inode map's free iag list.\n\t\t */\n\t\tif (iagp->nfreeexts == cpu_to_le32(EXTSPERIAG - 1)) {\n\t\t\t/* in preparation for removing the iag from the\n\t\t\t * ag extent free list, read the iags preceding\n\t\t\t * and following the iag on the ag extent free\n\t\t\t * list.\n\t\t\t */\n\t\t\tif ((fwd = le32_to_cpu(iagp->extfreefwd)) >= 0) {\n\t\t\t\tif ((rc = diIAGRead(imap, fwd, &amp)))\n\t\t\t\t\tgoto error_out;\n\t\t\t\taiagp = (struct iag *) amp->data;\n\t\t\t}\n\n\t\t\tif ((back = le32_to_cpu(iagp->extfreeback)) >= 0) {\n\t\t\t\tif ((rc = diIAGRead(imap, back, &bmp)))\n\t\t\t\t\tgoto error_out;\n\t\t\t\tbiagp = (struct iag *) bmp->data;\n\t\t\t}\n\t\t}\n\t}\n\n\t/* remove the iag from the ag inode free list if freeing\n\t * this extent cause the iag to have no free inodes.\n\t */\n\tif (iagp->nfreeinos == cpu_to_le32(INOSPEREXT - 1)) {\n\t\tint inofreeback = le32_to_cpu(iagp->inofreeback);\n\t\tint inofreefwd = le32_to_cpu(iagp->inofreefwd);\n\n\t\t/* in preparation for removing the iag from the\n\t\t * ag inode free list, read the iags preceding\n\t\t * and following the iag on the ag inode free\n\t\t * list.  before reading these iags, we must make\n\t\t * sure that we already don't have them in hand\n\t\t * from up above, since re-reading an iag (buffer)\n\t\t * we are currently holding would cause a deadlock.\n\t\t */\n\t\tif (inofreefwd >= 0) {\n\n\t\t\tif (inofreefwd == fwd)\n\t\t\t\tciagp = (struct iag *) amp->data;\n\t\t\telse if (inofreefwd == back)\n\t\t\t\tciagp = (struct iag *) bmp->data;\n\t\t\telse {\n\t\t\t\tif ((rc =\n\t\t\t\t     diIAGRead(imap, inofreefwd, &cmp)))\n\t\t\t\t\tgoto error_out;\n\t\t\t\tciagp = (struct iag *) cmp->data;\n\t\t\t}\n\t\t\tassert(ciagp != NULL);\n\t\t}\n\n\t\tif (inofreeback >= 0) {\n\t\t\tif (inofreeback == fwd)\n\t\t\t\tdiagp = (struct iag *) amp->data;\n\t\t\telse if (inofreeback == back)\n\t\t\t\tdiagp = (struct iag *) bmp->data;\n\t\t\telse {\n\t\t\t\tif ((rc =\n\t\t\t\t     diIAGRead(imap, inofreeback, &dmp)))\n\t\t\t\t\tgoto error_out;\n\t\t\t\tdiagp = (struct iag *) dmp->data;\n\t\t\t}\n\t\t\tassert(diagp != NULL);\n\t\t}\n\t}\n\n\tIREAD_UNLOCK(ipimap);\n\n\t/*\n\t * invalidate any page of the inode extent freed from buffer cache;\n\t */\n\tfreepxd = iagp->inoext[extno];\n\tinvalidate_pxd_metapages(ip, freepxd);\n\n\t/*\n\t *\tupdate iag list(s) (careful update step 2)\n\t */\n\t/* add the iag to the ag extent free list if this is the\n\t * first free extent for the iag.\n\t */\n\tif (iagp->nfreeexts == 0) {\n\t\tif (fwd >= 0)\n\t\t\taiagp->extfreeback = cpu_to_le32(iagno);\n\n\t\tiagp->extfreefwd =\n\t\t    cpu_to_le32(imap->im_agctl[agno].extfree);\n\t\tiagp->extfreeback = cpu_to_le32(-1);\n\t\timap->im_agctl[agno].extfree = iagno;\n\t} else {\n\t\t/* remove the iag from the ag extent list if all extents\n\t\t * are now free and place it on the inode map iag free list.\n\t\t */\n\t\tif (iagp->nfreeexts == cpu_to_le32(EXTSPERIAG - 1)) {\n\t\t\tif (fwd >= 0)\n\t\t\t\taiagp->extfreeback = iagp->extfreeback;\n\n\t\t\tif (back >= 0)\n\t\t\t\tbiagp->extfreefwd = iagp->extfreefwd;\n\t\t\telse\n\t\t\t\timap->im_agctl[agno].extfree =\n\t\t\t\t    le32_to_cpu(iagp->extfreefwd);\n\n\t\t\tiagp->extfreefwd = iagp->extfreeback = cpu_to_le32(-1);\n\n\t\t\tIAGFREE_LOCK(imap);\n\t\t\tiagp->iagfree = cpu_to_le32(imap->im_freeiag);\n\t\t\timap->im_freeiag = iagno;\n\t\t\tIAGFREE_UNLOCK(imap);\n\t\t}\n\t}\n\n\t/* remove the iag from the ag inode free list if freeing\n\t * this extent causes the iag to have no free inodes.\n\t */\n\tif (iagp->nfreeinos == cpu_to_le32(INOSPEREXT - 1)) {\n\t\tif ((int) le32_to_cpu(iagp->inofreefwd) >= 0)\n\t\t\tciagp->inofreeback = iagp->inofreeback;\n\n\t\tif ((int) le32_to_cpu(iagp->inofreeback) >= 0)\n\t\t\tdiagp->inofreefwd = iagp->inofreefwd;\n\t\telse\n\t\t\timap->im_agctl[agno].inofree =\n\t\t\t    le32_to_cpu(iagp->inofreefwd);\n\n\t\tiagp->inofreefwd = iagp->inofreeback = cpu_to_le32(-1);\n\t}\n\n\t/* update the inode extent address and working map\n\t * to reflect the free extent.\n\t * the permanent map should have been updated already\n\t * for the inode being freed.\n\t */\n\tif (iagp->pmap[extno] != 0) {\n\t\tjfs_error(ip->i_sb, \"the pmap does not show inode free\\n\");\n\t}\n\tiagp->wmap[extno] = 0;\n\tPXDlength(&iagp->inoext[extno], 0);\n\tPXDaddress(&iagp->inoext[extno], 0);\n\n\t/* update the free extent and free inode summary maps\n\t * to reflect the freed extent.\n\t * the inode summary map is marked to indicate no inodes\n\t * available for the freed extent.\n\t */\n\tsword = extno >> L2EXTSPERSUM;\n\tbitno = extno & (EXTSPERSUM - 1);\n\tmask = HIGHORDER >> bitno;\n\tiagp->inosmap[sword] |= cpu_to_le32(mask);\n\tiagp->extsmap[sword] &= cpu_to_le32(~mask);\n\n\t/* update the number of free inodes and number of free extents\n\t * for the iag.\n\t */\n\tle32_add_cpu(&iagp->nfreeinos, -(INOSPEREXT - 1));\n\tle32_add_cpu(&iagp->nfreeexts, 1);\n\n\t/* update the number of free inodes and backed inodes\n\t * at the ag and inode map level.\n\t */\n\timap->im_agctl[agno].numfree -= (INOSPEREXT - 1);\n\timap->im_agctl[agno].numinos -= INOSPEREXT;\n\tatomic_sub(INOSPEREXT - 1, &imap->im_numfree);\n\tatomic_sub(INOSPEREXT, &imap->im_numinos);\n\n\tif (amp)\n\t\twrite_metapage(amp);\n\tif (bmp)\n\t\twrite_metapage(bmp);\n\tif (cmp)\n\t\twrite_metapage(cmp);\n\tif (dmp)\n\t\twrite_metapage(dmp);\n\n\t/*\n\t * start transaction to update block allocation map\n\t * for the inode extent freed;\n\t *\n\t * N.B. AG_LOCK is released and iag will be released below, and\n\t * other thread may allocate inode from/reusing the ixad freed\n\t * BUT with new/different backing inode extent from the extent\n\t * to be freed by the transaction;\n\t */\n\ttid = txBegin(ipimap->i_sb, COMMIT_FORCE);\n\tmutex_lock(&JFS_IP(ipimap)->commit_mutex);\n\n\t/* acquire tlock of the iag page of the freed ixad\n\t * to force the page NOHOMEOK (even though no data is\n\t * logged from the iag page) until NOREDOPAGE|FREEXTENT log\n\t * for the free of the extent is committed;\n\t * write FREEXTENT|NOREDOPAGE log record\n\t * N.B. linelock is overlaid as freed extent descriptor;\n\t */\n\ttlck = txLock(tid, ipimap, mp, tlckINODE | tlckFREE);\n\tpxdlock = (struct pxd_lock *) & tlck->lock;\n\tpxdlock->flag = mlckFREEPXD;\n\tpxdlock->pxd = freepxd;\n\tpxdlock->index = 1;\n\n\twrite_metapage(mp);\n\n\tiplist[0] = ipimap;\n\n\t/*\n\t * logredo needs the IAG number and IAG extent index in order\n\t * to ensure that the IMap is consistent.  The least disruptive\n\t * way to pass these values through  to the transaction manager\n\t * is in the iplist array.\n\t *\n\t * It's not pretty, but it works.\n\t */\n\tiplist[1] = (struct inode *) (size_t)iagno;\n\tiplist[2] = (struct inode *) (size_t)extno;\n\n\trc = txCommit(tid, 1, &iplist[0], COMMIT_FORCE);\n\n\ttxEnd(tid);\n\tmutex_unlock(&JFS_IP(ipimap)->commit_mutex);\n\n\t/* unlock the AG inode map information */\n\tAG_UNLOCK(imap, agno);\n\n\treturn (0);\n\n      error_out:\n\tIREAD_UNLOCK(ipimap);\n\n\tif (amp)\n\t\trelease_metapage(amp);\n\tif (bmp)\n\t\trelease_metapage(bmp);\n\tif (cmp)\n\t\trelease_metapage(cmp);\n\tif (dmp)\n\t\trelease_metapage(dmp);\n\n\tAG_UNLOCK(imap, agno);\n\n\trelease_metapage(mp);\n\n\treturn (rc);\n}",
    "includes": [
      "#include \"jfs_debug.h\"",
      "#include \"jfs_superblock.h\"",
      "#include \"jfs_metapage.h\"",
      "#include \"jfs_imap.h\"",
      "#include \"jfs_dmap.h\"",
      "#include \"jfs_dinode.h\"",
      "#include \"jfs_filsys.h\"",
      "#include \"jfs_inode.h\"",
      "#include \"jfs_incore.h\"",
      "#include <linux/slab.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int diAllocAG(struct inomap *, int, bool, struct inode *);",
      "static int diAllocAny(struct inomap *, int, bool, struct inode *);",
      "static int diAllocBit(struct inomap *, struct iag *, int);",
      "static int diAllocExt(struct inomap *, int, struct inode *);",
      "static int diAllocIno(struct inomap *, int, struct inode *);",
      "static int diFindFree(u32, int);",
      "static int diNewExt(struct inomap *, struct iag *, int);",
      "static int diNewIAG(struct inomap *, int *, int, struct metapage **);",
      "static int diIAGRead(struct inomap * imap, int, struct metapage **);",
      "static int copy_from_dinode(struct dinode *, struct inode *);",
      "static void copy_to_dinode(struct dinode *, struct inode *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "release_metapage",
          "args": [
            "mp"
          ],
          "line": 1304
        },
        "resolved": true,
        "details": {
          "function_name": "release_metapage",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_metapage.c",
          "lines": "743-775",
          "snippet": "void release_metapage(struct metapage * mp)\n{\n\tstruct page *page = mp->page;\n\tjfs_info(\"release_metapage: mp = 0x%p, flag = 0x%lx\", mp, mp->flag);\n\n\tBUG_ON(!page);\n\n\tlock_page(page);\n\tunlock_metapage(mp);\n\n\tassert(mp->count);\n\tif (--mp->count || mp->nohomeok) {\n\t\tunlock_page(page);\n\t\tpage_cache_release(page);\n\t\treturn;\n\t}\n\n\tif (test_bit(META_dirty, &mp->flag)) {\n\t\tset_page_dirty(page);\n\t\tif (test_bit(META_sync, &mp->flag)) {\n\t\t\tclear_bit(META_sync, &mp->flag);\n\t\t\twrite_one_page(page, 1);\n\t\t\tlock_page(page); /* write_one_page unlocks the page */\n\t\t}\n\t} else if (mp->lsn)\t/* discard_metapage doesn't remove it */\n\t\tremove_from_logsync(mp);\n\n\t/* Try to keep metapages from using up too much memory */\n\tdrop_metapage(page, mp);\n\n\tunlock_page(page);\n\tpage_cache_release(page);\n}",
          "includes": [
            "#include \"jfs_debug.h\"",
            "#include \"jfs_txnmgr.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_filsys.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/mempool.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/bio.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_txnmgr.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_incore.h\"\n#include <linux/seq_file.h>\n#include <linux/mempool.h>\n#include <linux/buffer_head.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n\nvoid release_metapage(struct metapage * mp)\n{\n\tstruct page *page = mp->page;\n\tjfs_info(\"release_metapage: mp = 0x%p, flag = 0x%lx\", mp, mp->flag);\n\n\tBUG_ON(!page);\n\n\tlock_page(page);\n\tunlock_metapage(mp);\n\n\tassert(mp->count);\n\tif (--mp->count || mp->nohomeok) {\n\t\tunlock_page(page);\n\t\tpage_cache_release(page);\n\t\treturn;\n\t}\n\n\tif (test_bit(META_dirty, &mp->flag)) {\n\t\tset_page_dirty(page);\n\t\tif (test_bit(META_sync, &mp->flag)) {\n\t\t\tclear_bit(META_sync, &mp->flag);\n\t\t\twrite_one_page(page, 1);\n\t\t\tlock_page(page); /* write_one_page unlocks the page */\n\t\t}\n\t} else if (mp->lsn)\t/* discard_metapage doesn't remove it */\n\t\tremove_from_logsync(mp);\n\n\t/* Try to keep metapages from using up too much memory */\n\tdrop_metapage(page, mp);\n\n\tunlock_page(page);\n\tpage_cache_release(page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "AG_UNLOCK",
          "args": [
            "imap",
            "agno"
          ],
          "line": 1302
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IREAD_UNLOCK",
          "args": [
            "ipimap"
          ],
          "line": 1291
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AG_UNLOCK",
          "args": [
            "imap",
            "agno"
          ],
          "line": 1286
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&JFS_IP(ipimap)->commit_mutex"
          ],
          "line": 1283
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "JFS_IP",
          "args": [
            "ipimap"
          ],
          "line": 1283
        },
        "resolved": true,
        "details": {
          "function_name": "JFS_IP",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_incore.h",
          "lines": "207-210",
          "snippet": "static inline struct jfs_inode_info *JFS_IP(struct inode *inode)\n{\n\treturn list_entry(inode, struct jfs_inode_info, vfs_inode);\n}",
          "includes": [
            "#include \"jfs_dtree.h\"",
            "#include \"jfs_xtree.h\"",
            "#include \"jfs_types.h\"",
            "#include <linux/bitops.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_dtree.h\"\n#include \"jfs_xtree.h\"\n#include \"jfs_types.h\"\n#include <linux/bitops.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mutex.h>\n\nstatic inline struct jfs_inode_info *JFS_IP(struct inode *inode)\n{\n\treturn list_entry(inode, struct jfs_inode_info, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "txEnd",
          "args": [
            "tid"
          ],
          "line": 1282
        },
        "resolved": true,
        "details": {
          "function_name": "txEnd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_txnmgr.c",
          "lines": "500-577",
          "snippet": "void txEnd(tid_t tid)\n{\n\tstruct tblock *tblk = tid_to_tblock(tid);\n\tstruct jfs_log *log;\n\n\tjfs_info(\"txEnd: tid = %d\", tid);\n\tTXN_LOCK();\n\n\t/*\n\t * wakeup transactions waiting on the page locked\n\t * by the current transaction\n\t */\n\tTXN_WAKEUP(&tblk->waitor);\n\n\tlog = JFS_SBI(tblk->sb)->log;\n\n\t/*\n\t * Lazy commit thread can't free this guy until we mark it UNLOCKED,\n\t * otherwise, we would be left with a transaction that may have been\n\t * reused.\n\t *\n\t * Lazy commit thread will turn off tblkGC_LAZY before calling this\n\t * routine.\n\t */\n\tif (tblk->flag & tblkGC_LAZY) {\n\t\tjfs_info(\"txEnd called w/lazy tid: %d, tblk = 0x%p\", tid, tblk);\n\t\tTXN_UNLOCK();\n\n\t\tspin_lock_irq(&log->gclock);\t// LOGGC_LOCK\n\t\ttblk->flag |= tblkGC_UNLOCKED;\n\t\tspin_unlock_irq(&log->gclock);\t// LOGGC_UNLOCK\n\t\treturn;\n\t}\n\n\tjfs_info(\"txEnd: tid: %d, tblk = 0x%p\", tid, tblk);\n\n\tassert(tblk->next == 0);\n\n\t/*\n\t * insert tblock back on freelist\n\t */\n\ttblk->next = TxAnchor.freetid;\n\tTxAnchor.freetid = tid;\n\n\t/*\n\t * mark the tblock not active\n\t */\n\tif (--log->active == 0) {\n\t\tclear_bit(log_FLUSH, &log->flag);\n\n\t\t/*\n\t\t * synchronize with logsync barrier\n\t\t */\n\t\tif (test_bit(log_SYNCBARRIER, &log->flag)) {\n\t\t\tTXN_UNLOCK();\n\n\t\t\t/* write dirty metadata & forward log syncpt */\n\t\t\tjfs_syncpt(log, 1);\n\n\t\t\tjfs_info(\"log barrier off: 0x%x\", log->lsn);\n\n\t\t\t/* enable new transactions start */\n\t\t\tclear_bit(log_SYNCBARRIER, &log->flag);\n\n\t\t\t/* wakeup all waitors for logsync barrier */\n\t\t\tTXN_WAKEUP(&log->syncwait);\n\n\t\t\tgoto wakeup;\n\t\t}\n\t}\n\n\tTXN_UNLOCK();\nwakeup:\n\t/*\n\t * wakeup all waitors for a free tblock\n\t */\n\tTXN_WAKEUP(&TxAnchor.freewait);\n}",
          "includes": [
            "#include \"jfs_debug.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_dmap.h\"",
            "#include \"jfs_imap.h\"",
            "#include \"jfs_dinode.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_filsys.h\"",
            "#include \"jfs_inode.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/freezer.h>",
            "#include <linux/completion.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct {\n\tint freetid;\t\t/* index of a free tid structure */\n\tint freelock;\t\t/* index first free lock word */\n\twait_queue_head_t freewait;\t/* eventlist of free tblock */\n\twait_queue_head_t freelockwait;\t/* eventlist of free tlock */\n\twait_queue_head_t lowlockwait;\t/* eventlist of ample tlocks */\n\tint tlocksInUse;\t/* Number of tlocks in use */\n\tspinlock_t LazyLock;\t/* synchronize sync_queue & unlock_queue */\n/*\tstruct tblock *sync_queue; * Transactions waiting for data sync */\n\tstruct list_head unlock_queue;\t/* Txns waiting to be released */\n\tstruct list_head anon_list;\t/* inodes having anonymous txns */\n\tstruct list_head anon_list2;\t/* inodes having anonymous txns\n\t\t\t\t\t   that couldn't be sync'ed */\n} TxAnchor;",
            "static void txAllocPMap(struct inode *ip, struct maplock * maplock,\n\t\tstruct tblock * tblk);",
            "static void txForce(struct tblock * tblk);",
            "static void txUpdateMap(struct tblock * tblk);",
            "static void txRelease(struct tblock * tblk);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_imap.h\"\n#include \"jfs_dinode.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_inode.h\"\n#include \"jfs_incore.h\"\n#include <linux/seq_file.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/freezer.h>\n#include <linux/completion.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n\nstatic struct {\n\tint freetid;\t\t/* index of a free tid structure */\n\tint freelock;\t\t/* index first free lock word */\n\twait_queue_head_t freewait;\t/* eventlist of free tblock */\n\twait_queue_head_t freelockwait;\t/* eventlist of free tlock */\n\twait_queue_head_t lowlockwait;\t/* eventlist of ample tlocks */\n\tint tlocksInUse;\t/* Number of tlocks in use */\n\tspinlock_t LazyLock;\t/* synchronize sync_queue & unlock_queue */\n/*\tstruct tblock *sync_queue; * Transactions waiting for data sync */\n\tstruct list_head unlock_queue;\t/* Txns waiting to be released */\n\tstruct list_head anon_list;\t/* inodes having anonymous txns */\n\tstruct list_head anon_list2;\t/* inodes having anonymous txns\n\t\t\t\t\t   that couldn't be sync'ed */\n} TxAnchor;\nstatic void txAllocPMap(struct inode *ip, struct maplock * maplock,\n\t\tstruct tblock * tblk);\nstatic void txForce(struct tblock * tblk);\nstatic void txUpdateMap(struct tblock * tblk);\nstatic void txRelease(struct tblock * tblk);\n\nvoid txEnd(tid_t tid)\n{\n\tstruct tblock *tblk = tid_to_tblock(tid);\n\tstruct jfs_log *log;\n\n\tjfs_info(\"txEnd: tid = %d\", tid);\n\tTXN_LOCK();\n\n\t/*\n\t * wakeup transactions waiting on the page locked\n\t * by the current transaction\n\t */\n\tTXN_WAKEUP(&tblk->waitor);\n\n\tlog = JFS_SBI(tblk->sb)->log;\n\n\t/*\n\t * Lazy commit thread can't free this guy until we mark it UNLOCKED,\n\t * otherwise, we would be left with a transaction that may have been\n\t * reused.\n\t *\n\t * Lazy commit thread will turn off tblkGC_LAZY before calling this\n\t * routine.\n\t */\n\tif (tblk->flag & tblkGC_LAZY) {\n\t\tjfs_info(\"txEnd called w/lazy tid: %d, tblk = 0x%p\", tid, tblk);\n\t\tTXN_UNLOCK();\n\n\t\tspin_lock_irq(&log->gclock);\t// LOGGC_LOCK\n\t\ttblk->flag |= tblkGC_UNLOCKED;\n\t\tspin_unlock_irq(&log->gclock);\t// LOGGC_UNLOCK\n\t\treturn;\n\t}\n\n\tjfs_info(\"txEnd: tid: %d, tblk = 0x%p\", tid, tblk);\n\n\tassert(tblk->next == 0);\n\n\t/*\n\t * insert tblock back on freelist\n\t */\n\ttblk->next = TxAnchor.freetid;\n\tTxAnchor.freetid = tid;\n\n\t/*\n\t * mark the tblock not active\n\t */\n\tif (--log->active == 0) {\n\t\tclear_bit(log_FLUSH, &log->flag);\n\n\t\t/*\n\t\t * synchronize with logsync barrier\n\t\t */\n\t\tif (test_bit(log_SYNCBARRIER, &log->flag)) {\n\t\t\tTXN_UNLOCK();\n\n\t\t\t/* write dirty metadata & forward log syncpt */\n\t\t\tjfs_syncpt(log, 1);\n\n\t\t\tjfs_info(\"log barrier off: 0x%x\", log->lsn);\n\n\t\t\t/* enable new transactions start */\n\t\t\tclear_bit(log_SYNCBARRIER, &log->flag);\n\n\t\t\t/* wakeup all waitors for logsync barrier */\n\t\t\tTXN_WAKEUP(&log->syncwait);\n\n\t\t\tgoto wakeup;\n\t\t}\n\t}\n\n\tTXN_UNLOCK();\nwakeup:\n\t/*\n\t * wakeup all waitors for a free tblock\n\t */\n\tTXN_WAKEUP(&TxAnchor.freewait);\n}"
        }
      },
      {
        "call_info": {
          "callee": "txCommit",
          "args": [
            "tid",
            "1",
            "&iplist[0]",
            "COMMIT_FORCE"
          ],
          "line": 1280
        },
        "resolved": true,
        "details": {
          "function_name": "txCommit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_txnmgr.c",
          "lines": "1135-1368",
          "snippet": "int txCommit(tid_t tid,\t\t/* transaction identifier */\n\t     int nip,\t\t/* number of inodes to commit */\n\t     struct inode **iplist,\t/* list of inode to commit */\n\t     int flag)\n{\n\tint rc = 0;\n\tstruct commit cd;\n\tstruct jfs_log *log;\n\tstruct tblock *tblk;\n\tstruct lrd *lrd;\n\tstruct inode *ip;\n\tstruct jfs_inode_info *jfs_ip;\n\tint k, n;\n\tino_t top;\n\tstruct super_block *sb;\n\n\tjfs_info(\"txCommit, tid = %d, flag = %d\", tid, flag);\n\t/* is read-only file system ? */\n\tif (isReadOnly(iplist[0])) {\n\t\trc = -EROFS;\n\t\tgoto TheEnd;\n\t}\n\n\tsb = cd.sb = iplist[0]->i_sb;\n\tcd.tid = tid;\n\n\tif (tid == 0)\n\t\ttid = txBegin(sb, 0);\n\ttblk = tid_to_tblock(tid);\n\n\t/*\n\t * initialize commit structure\n\t */\n\tlog = JFS_SBI(sb)->log;\n\tcd.log = log;\n\n\t/* initialize log record descriptor in commit */\n\tlrd = &cd.lrd;\n\tlrd->logtid = cpu_to_le32(tblk->logtid);\n\tlrd->backchain = 0;\n\n\ttblk->xflag |= flag;\n\n\tif ((flag & (COMMIT_FORCE | COMMIT_SYNC)) == 0)\n\t\ttblk->xflag |= COMMIT_LAZY;\n\t/*\n\t *\tprepare non-journaled objects for commit\n\t *\n\t * flush data pages of non-journaled file\n\t * to prevent the file getting non-initialized disk blocks\n\t * in case of crash.\n\t * (new blocks - )\n\t */\n\tcd.iplist = iplist;\n\tcd.nip = nip;\n\n\t/*\n\t *\tacquire transaction lock on (on-disk) inodes\n\t *\n\t * update on-disk inode from in-memory inode\n\t * acquiring transaction locks for AFTER records\n\t * on the on-disk inode of file object\n\t *\n\t * sort the inodes array by inode number in descending order\n\t * to prevent deadlock when acquiring transaction lock\n\t * of on-disk inodes on multiple on-disk inode pages by\n\t * multiple concurrent transactions\n\t */\n\tfor (k = 0; k < cd.nip; k++) {\n\t\ttop = (cd.iplist[k])->i_ino;\n\t\tfor (n = k + 1; n < cd.nip; n++) {\n\t\t\tip = cd.iplist[n];\n\t\t\tif (ip->i_ino > top) {\n\t\t\t\ttop = ip->i_ino;\n\t\t\t\tcd.iplist[n] = cd.iplist[k];\n\t\t\t\tcd.iplist[k] = ip;\n\t\t\t}\n\t\t}\n\n\t\tip = cd.iplist[k];\n\t\tjfs_ip = JFS_IP(ip);\n\n\t\t/*\n\t\t * BUGBUG - This code has temporarily been removed.  The\n\t\t * intent is to ensure that any file data is written before\n\t\t * the metadata is committed to the journal.  This prevents\n\t\t * uninitialized data from appearing in a file after the\n\t\t * journal has been replayed.  (The uninitialized data\n\t\t * could be sensitive data removed by another user.)\n\t\t *\n\t\t * The problem now is that we are holding the IWRITELOCK\n\t\t * on the inode, and calling filemap_fdatawrite on an\n\t\t * unmapped page will cause a deadlock in jfs_get_block.\n\t\t *\n\t\t * The long term solution is to pare down the use of\n\t\t * IWRITELOCK.  We are currently holding it too long.\n\t\t * We could also be smarter about which data pages need\n\t\t * to be written before the transaction is committed and\n\t\t * when we don't need to worry about it at all.\n\t\t *\n\t\t * if ((!S_ISDIR(ip->i_mode))\n\t\t *    && (tblk->flag & COMMIT_DELETE) == 0)\n\t\t *\tfilemap_write_and_wait(ip->i_mapping);\n\t\t */\n\n\t\t/*\n\t\t * Mark inode as not dirty.  It will still be on the dirty\n\t\t * inode list, but we'll know not to commit it again unless\n\t\t * it gets marked dirty again\n\t\t */\n\t\tclear_cflag(COMMIT_Dirty, ip);\n\n\t\t/* inherit anonymous tlock(s) of inode */\n\t\tif (jfs_ip->atlhead) {\n\t\t\tlid_to_tlock(jfs_ip->atltail)->next = tblk->next;\n\t\t\ttblk->next = jfs_ip->atlhead;\n\t\t\tif (!tblk->last)\n\t\t\t\ttblk->last = jfs_ip->atltail;\n\t\t\tjfs_ip->atlhead = jfs_ip->atltail = 0;\n\t\t\tTXN_LOCK();\n\t\t\tlist_del_init(&jfs_ip->anon_inode_list);\n\t\t\tTXN_UNLOCK();\n\t\t}\n\n\t\t/*\n\t\t * acquire transaction lock on on-disk inode page\n\t\t * (become first tlock of the tblk's tlock list)\n\t\t */\n\t\tif (((rc = diWrite(tid, ip))))\n\t\t\tgoto out;\n\t}\n\n\t/*\n\t *\twrite log records from transaction locks\n\t *\n\t * txUpdateMap() resets XAD_NEW in XAD.\n\t */\n\tif ((rc = txLog(log, tblk, &cd)))\n\t\tgoto TheEnd;\n\n\t/*\n\t * Ensure that inode isn't reused before\n\t * lazy commit thread finishes processing\n\t */\n\tif (tblk->xflag & COMMIT_DELETE) {\n\t\tihold(tblk->u.ip);\n\t\t/*\n\t\t * Avoid a rare deadlock\n\t\t *\n\t\t * If the inode is locked, we may be blocked in\n\t\t * jfs_commit_inode.  If so, we don't want the\n\t\t * lazy_commit thread doing the last iput() on the inode\n\t\t * since that may block on the locked inode.  Instead,\n\t\t * commit the transaction synchronously, so the last iput\n\t\t * will be done by the calling thread (or later)\n\t\t */\n\t\t/*\n\t\t * I believe this code is no longer needed.  Splitting I_LOCK\n\t\t * into two bits, I_NEW and I_SYNC should prevent this\n\t\t * deadlock as well.  But since I don't have a JFS testload\n\t\t * to verify this, only a trivial s/I_LOCK/I_SYNC/ was done.\n\t\t * Joern\n\t\t */\n\t\tif (tblk->u.ip->i_state & I_SYNC)\n\t\t\ttblk->xflag &= ~COMMIT_LAZY;\n\t}\n\n\tASSERT((!(tblk->xflag & COMMIT_DELETE)) ||\n\t       ((tblk->u.ip->i_nlink == 0) &&\n\t\t!test_cflag(COMMIT_Nolink, tblk->u.ip)));\n\n\t/*\n\t *\twrite COMMIT log record\n\t */\n\tlrd->type = cpu_to_le16(LOG_COMMIT);\n\tlrd->length = 0;\n\tlmLog(log, tblk, lrd, NULL);\n\n\tlmGroupCommit(log, tblk);\n\n\t/*\n\t *\t- transaction is now committed -\n\t */\n\n\t/*\n\t * force pages in careful update\n\t * (imap addressing structure update)\n\t */\n\tif (flag & COMMIT_FORCE)\n\t\ttxForce(tblk);\n\n\t/*\n\t *\tupdate allocation map.\n\t *\n\t * update inode allocation map and inode:\n\t * free pager lock on memory object of inode if any.\n\t * update block allocation map.\n\t *\n\t * txUpdateMap() resets XAD_NEW in XAD.\n\t */\n\tif (tblk->xflag & COMMIT_FORCE)\n\t\ttxUpdateMap(tblk);\n\n\t/*\n\t *\tfree transaction locks and pageout/free pages\n\t */\n\ttxRelease(tblk);\n\n\tif ((tblk->flag & tblkGC_LAZY) == 0)\n\t\ttxUnlock(tblk);\n\n\n\t/*\n\t *\treset in-memory object state\n\t */\n\tfor (k = 0; k < cd.nip; k++) {\n\t\tip = cd.iplist[k];\n\t\tjfs_ip = JFS_IP(ip);\n\n\t\t/*\n\t\t * reset in-memory inode state\n\t\t */\n\t\tjfs_ip->bxflag = 0;\n\t\tjfs_ip->blid = 0;\n\t}\n\n      out:\n\tif (rc != 0)\n\t\ttxAbort(tid, 1);\n\n      TheEnd:\n\tjfs_info(\"txCommit: tid = %d, returning %d\", tid, rc);\n\treturn rc;\n}",
          "includes": [
            "#include \"jfs_debug.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_dmap.h\"",
            "#include \"jfs_imap.h\"",
            "#include \"jfs_dinode.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_filsys.h\"",
            "#include \"jfs_inode.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/freezer.h>",
            "#include <linux/completion.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int diLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t\tstruct tlock * tlck, struct commit * cd);",
            "static void txAllocPMap(struct inode *ip, struct maplock * maplock,\n\t\tstruct tblock * tblk);",
            "static void txForce(struct tblock * tblk);",
            "static int txLog(struct jfs_log * log, struct tblock * tblk,\n\t\tstruct commit * cd);",
            "static void txUpdateMap(struct tblock * tblk);",
            "static void txRelease(struct tblock * tblk);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_imap.h\"\n#include \"jfs_dinode.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_inode.h\"\n#include \"jfs_incore.h\"\n#include <linux/seq_file.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/freezer.h>\n#include <linux/completion.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n\nstatic int diLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t\tstruct tlock * tlck, struct commit * cd);\nstatic void txAllocPMap(struct inode *ip, struct maplock * maplock,\n\t\tstruct tblock * tblk);\nstatic void txForce(struct tblock * tblk);\nstatic int txLog(struct jfs_log * log, struct tblock * tblk,\n\t\tstruct commit * cd);\nstatic void txUpdateMap(struct tblock * tblk);\nstatic void txRelease(struct tblock * tblk);\n\nint txCommit(tid_t tid,\t\t/* transaction identifier */\n\t     int nip,\t\t/* number of inodes to commit */\n\t     struct inode **iplist,\t/* list of inode to commit */\n\t     int flag)\n{\n\tint rc = 0;\n\tstruct commit cd;\n\tstruct jfs_log *log;\n\tstruct tblock *tblk;\n\tstruct lrd *lrd;\n\tstruct inode *ip;\n\tstruct jfs_inode_info *jfs_ip;\n\tint k, n;\n\tino_t top;\n\tstruct super_block *sb;\n\n\tjfs_info(\"txCommit, tid = %d, flag = %d\", tid, flag);\n\t/* is read-only file system ? */\n\tif (isReadOnly(iplist[0])) {\n\t\trc = -EROFS;\n\t\tgoto TheEnd;\n\t}\n\n\tsb = cd.sb = iplist[0]->i_sb;\n\tcd.tid = tid;\n\n\tif (tid == 0)\n\t\ttid = txBegin(sb, 0);\n\ttblk = tid_to_tblock(tid);\n\n\t/*\n\t * initialize commit structure\n\t */\n\tlog = JFS_SBI(sb)->log;\n\tcd.log = log;\n\n\t/* initialize log record descriptor in commit */\n\tlrd = &cd.lrd;\n\tlrd->logtid = cpu_to_le32(tblk->logtid);\n\tlrd->backchain = 0;\n\n\ttblk->xflag |= flag;\n\n\tif ((flag & (COMMIT_FORCE | COMMIT_SYNC)) == 0)\n\t\ttblk->xflag |= COMMIT_LAZY;\n\t/*\n\t *\tprepare non-journaled objects for commit\n\t *\n\t * flush data pages of non-journaled file\n\t * to prevent the file getting non-initialized disk blocks\n\t * in case of crash.\n\t * (new blocks - )\n\t */\n\tcd.iplist = iplist;\n\tcd.nip = nip;\n\n\t/*\n\t *\tacquire transaction lock on (on-disk) inodes\n\t *\n\t * update on-disk inode from in-memory inode\n\t * acquiring transaction locks for AFTER records\n\t * on the on-disk inode of file object\n\t *\n\t * sort the inodes array by inode number in descending order\n\t * to prevent deadlock when acquiring transaction lock\n\t * of on-disk inodes on multiple on-disk inode pages by\n\t * multiple concurrent transactions\n\t */\n\tfor (k = 0; k < cd.nip; k++) {\n\t\ttop = (cd.iplist[k])->i_ino;\n\t\tfor (n = k + 1; n < cd.nip; n++) {\n\t\t\tip = cd.iplist[n];\n\t\t\tif (ip->i_ino > top) {\n\t\t\t\ttop = ip->i_ino;\n\t\t\t\tcd.iplist[n] = cd.iplist[k];\n\t\t\t\tcd.iplist[k] = ip;\n\t\t\t}\n\t\t}\n\n\t\tip = cd.iplist[k];\n\t\tjfs_ip = JFS_IP(ip);\n\n\t\t/*\n\t\t * BUGBUG - This code has temporarily been removed.  The\n\t\t * intent is to ensure that any file data is written before\n\t\t * the metadata is committed to the journal.  This prevents\n\t\t * uninitialized data from appearing in a file after the\n\t\t * journal has been replayed.  (The uninitialized data\n\t\t * could be sensitive data removed by another user.)\n\t\t *\n\t\t * The problem now is that we are holding the IWRITELOCK\n\t\t * on the inode, and calling filemap_fdatawrite on an\n\t\t * unmapped page will cause a deadlock in jfs_get_block.\n\t\t *\n\t\t * The long term solution is to pare down the use of\n\t\t * IWRITELOCK.  We are currently holding it too long.\n\t\t * We could also be smarter about which data pages need\n\t\t * to be written before the transaction is committed and\n\t\t * when we don't need to worry about it at all.\n\t\t *\n\t\t * if ((!S_ISDIR(ip->i_mode))\n\t\t *    && (tblk->flag & COMMIT_DELETE) == 0)\n\t\t *\tfilemap_write_and_wait(ip->i_mapping);\n\t\t */\n\n\t\t/*\n\t\t * Mark inode as not dirty.  It will still be on the dirty\n\t\t * inode list, but we'll know not to commit it again unless\n\t\t * it gets marked dirty again\n\t\t */\n\t\tclear_cflag(COMMIT_Dirty, ip);\n\n\t\t/* inherit anonymous tlock(s) of inode */\n\t\tif (jfs_ip->atlhead) {\n\t\t\tlid_to_tlock(jfs_ip->atltail)->next = tblk->next;\n\t\t\ttblk->next = jfs_ip->atlhead;\n\t\t\tif (!tblk->last)\n\t\t\t\ttblk->last = jfs_ip->atltail;\n\t\t\tjfs_ip->atlhead = jfs_ip->atltail = 0;\n\t\t\tTXN_LOCK();\n\t\t\tlist_del_init(&jfs_ip->anon_inode_list);\n\t\t\tTXN_UNLOCK();\n\t\t}\n\n\t\t/*\n\t\t * acquire transaction lock on on-disk inode page\n\t\t * (become first tlock of the tblk's tlock list)\n\t\t */\n\t\tif (((rc = diWrite(tid, ip))))\n\t\t\tgoto out;\n\t}\n\n\t/*\n\t *\twrite log records from transaction locks\n\t *\n\t * txUpdateMap() resets XAD_NEW in XAD.\n\t */\n\tif ((rc = txLog(log, tblk, &cd)))\n\t\tgoto TheEnd;\n\n\t/*\n\t * Ensure that inode isn't reused before\n\t * lazy commit thread finishes processing\n\t */\n\tif (tblk->xflag & COMMIT_DELETE) {\n\t\tihold(tblk->u.ip);\n\t\t/*\n\t\t * Avoid a rare deadlock\n\t\t *\n\t\t * If the inode is locked, we may be blocked in\n\t\t * jfs_commit_inode.  If so, we don't want the\n\t\t * lazy_commit thread doing the last iput() on the inode\n\t\t * since that may block on the locked inode.  Instead,\n\t\t * commit the transaction synchronously, so the last iput\n\t\t * will be done by the calling thread (or later)\n\t\t */\n\t\t/*\n\t\t * I believe this code is no longer needed.  Splitting I_LOCK\n\t\t * into two bits, I_NEW and I_SYNC should prevent this\n\t\t * deadlock as well.  But since I don't have a JFS testload\n\t\t * to verify this, only a trivial s/I_LOCK/I_SYNC/ was done.\n\t\t * Joern\n\t\t */\n\t\tif (tblk->u.ip->i_state & I_SYNC)\n\t\t\ttblk->xflag &= ~COMMIT_LAZY;\n\t}\n\n\tASSERT((!(tblk->xflag & COMMIT_DELETE)) ||\n\t       ((tblk->u.ip->i_nlink == 0) &&\n\t\t!test_cflag(COMMIT_Nolink, tblk->u.ip)));\n\n\t/*\n\t *\twrite COMMIT log record\n\t */\n\tlrd->type = cpu_to_le16(LOG_COMMIT);\n\tlrd->length = 0;\n\tlmLog(log, tblk, lrd, NULL);\n\n\tlmGroupCommit(log, tblk);\n\n\t/*\n\t *\t- transaction is now committed -\n\t */\n\n\t/*\n\t * force pages in careful update\n\t * (imap addressing structure update)\n\t */\n\tif (flag & COMMIT_FORCE)\n\t\ttxForce(tblk);\n\n\t/*\n\t *\tupdate allocation map.\n\t *\n\t * update inode allocation map and inode:\n\t * free pager lock on memory object of inode if any.\n\t * update block allocation map.\n\t *\n\t * txUpdateMap() resets XAD_NEW in XAD.\n\t */\n\tif (tblk->xflag & COMMIT_FORCE)\n\t\ttxUpdateMap(tblk);\n\n\t/*\n\t *\tfree transaction locks and pageout/free pages\n\t */\n\ttxRelease(tblk);\n\n\tif ((tblk->flag & tblkGC_LAZY) == 0)\n\t\ttxUnlock(tblk);\n\n\n\t/*\n\t *\treset in-memory object state\n\t */\n\tfor (k = 0; k < cd.nip; k++) {\n\t\tip = cd.iplist[k];\n\t\tjfs_ip = JFS_IP(ip);\n\n\t\t/*\n\t\t * reset in-memory inode state\n\t\t */\n\t\tjfs_ip->bxflag = 0;\n\t\tjfs_ip->blid = 0;\n\t}\n\n      out:\n\tif (rc != 0)\n\t\ttxAbort(tid, 1);\n\n      TheEnd:\n\tjfs_info(\"txCommit: tid = %d, returning %d\", tid, rc);\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "write_metapage",
          "args": [
            "mp"
          ],
          "line": 1265
        },
        "resolved": true,
        "details": {
          "function_name": "write_metapage",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_metapage.h",
          "lines": "85-89",
          "snippet": "static inline void write_metapage(struct metapage *mp)\n{\n\tset_bit(META_dirty, &mp->flag);\n\trelease_metapage(mp);\n}",
          "includes": [
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [
            "#define META_dirty\t2"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/pagemap.h>\n\n#define META_dirty\t2\n\nstatic inline void write_metapage(struct metapage *mp)\n{\n\tset_bit(META_dirty, &mp->flag);\n\trelease_metapage(mp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "txLock",
          "args": [
            "tid",
            "ipimap",
            "mp",
            "tlckINODE | tlckFREE"
          ],
          "line": 1259
        },
        "resolved": true,
        "details": {
          "function_name": "txLock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_txnmgr.c",
          "lines": "590-861",
          "snippet": "struct tlock *txLock(tid_t tid, struct inode *ip, struct metapage * mp,\n\t\t     int type)\n{\n\tstruct jfs_inode_info *jfs_ip = JFS_IP(ip);\n\tint dir_xtree = 0;\n\tlid_t lid;\n\ttid_t xtid;\n\tstruct tlock *tlck;\n\tstruct xtlock *xtlck;\n\tstruct linelock *linelock;\n\txtpage_t *p;\n\tstruct tblock *tblk;\n\n\tTXN_LOCK();\n\n\tif (S_ISDIR(ip->i_mode) && (type & tlckXTREE) &&\n\t    !(mp->xflag & COMMIT_PAGE)) {\n\t\t/*\n\t\t * Directory inode is special.  It can have both an xtree tlock\n\t\t * and a dtree tlock associated with it.\n\t\t */\n\t\tdir_xtree = 1;\n\t\tlid = jfs_ip->xtlid;\n\t} else\n\t\tlid = mp->lid;\n\n\t/* is page not locked by a transaction ? */\n\tif (lid == 0)\n\t\tgoto allocateLock;\n\n\tjfs_info(\"txLock: tid:%d ip:0x%p mp:0x%p lid:%d\", tid, ip, mp, lid);\n\n\t/* is page locked by the requester transaction ? */\n\ttlck = lid_to_tlock(lid);\n\tif ((xtid = tlck->tid) == tid) {\n\t\tTXN_UNLOCK();\n\t\tgoto grantLock;\n\t}\n\n\t/*\n\t * is page locked by anonymous transaction/lock ?\n\t *\n\t * (page update without transaction (i.e., file write) is\n\t * locked under anonymous transaction tid = 0:\n\t * anonymous tlocks maintained on anonymous tlock list of\n\t * the inode of the page and available to all anonymous\n\t * transactions until txCommit() time at which point\n\t * they are transferred to the transaction tlock list of\n\t * the committing transaction of the inode)\n\t */\n\tif (xtid == 0) {\n\t\ttlck->tid = tid;\n\t\tTXN_UNLOCK();\n\t\ttblk = tid_to_tblock(tid);\n\t\t/*\n\t\t * The order of the tlocks in the transaction is important\n\t\t * (during truncate, child xtree pages must be freed before\n\t\t * parent's tlocks change the working map).\n\t\t * Take tlock off anonymous list and add to tail of\n\t\t * transaction list\n\t\t *\n\t\t * Note:  We really need to get rid of the tid & lid and\n\t\t * use list_head's.  This code is getting UGLY!\n\t\t */\n\t\tif (jfs_ip->atlhead == lid) {\n\t\t\tif (jfs_ip->atltail == lid) {\n\t\t\t\t/* only anonymous txn.\n\t\t\t\t * Remove from anon_list\n\t\t\t\t */\n\t\t\t\tTXN_LOCK();\n\t\t\t\tlist_del_init(&jfs_ip->anon_inode_list);\n\t\t\t\tTXN_UNLOCK();\n\t\t\t}\n\t\t\tjfs_ip->atlhead = tlck->next;\n\t\t} else {\n\t\t\tlid_t last;\n\t\t\tfor (last = jfs_ip->atlhead;\n\t\t\t     lid_to_tlock(last)->next != lid;\n\t\t\t     last = lid_to_tlock(last)->next) {\n\t\t\t\tassert(last);\n\t\t\t}\n\t\t\tlid_to_tlock(last)->next = tlck->next;\n\t\t\tif (jfs_ip->atltail == lid)\n\t\t\t\tjfs_ip->atltail = last;\n\t\t}\n\n\t\t/* insert the tlock at tail of transaction tlock list */\n\n\t\tif (tblk->next)\n\t\t\tlid_to_tlock(tblk->last)->next = lid;\n\t\telse\n\t\t\ttblk->next = lid;\n\t\ttlck->next = 0;\n\t\ttblk->last = lid;\n\n\t\tgoto grantLock;\n\t}\n\n\tgoto waitLock;\n\n\t/*\n\t * allocate a tlock\n\t */\n      allocateLock:\n\tlid = txLockAlloc();\n\ttlck = lid_to_tlock(lid);\n\n\t/*\n\t * initialize tlock\n\t */\n\ttlck->tid = tid;\n\n\tTXN_UNLOCK();\n\n\t/* mark tlock for meta-data page */\n\tif (mp->xflag & COMMIT_PAGE) {\n\n\t\ttlck->flag = tlckPAGELOCK;\n\n\t\t/* mark the page dirty and nohomeok */\n\t\tmetapage_nohomeok(mp);\n\n\t\tjfs_info(\"locking mp = 0x%p, nohomeok = %d tid = %d tlck = 0x%p\",\n\t\t\t mp, mp->nohomeok, tid, tlck);\n\n\t\t/* if anonymous transaction, and buffer is on the group\n\t\t * commit synclist, mark inode to show this.  This will\n\t\t * prevent the buffer from being marked nohomeok for too\n\t\t * long a time.\n\t\t */\n\t\tif ((tid == 0) && mp->lsn)\n\t\t\tset_cflag(COMMIT_Synclist, ip);\n\t}\n\t/* mark tlock for in-memory inode */\n\telse\n\t\ttlck->flag = tlckINODELOCK;\n\n\tif (S_ISDIR(ip->i_mode))\n\t\ttlck->flag |= tlckDIRECTORY;\n\n\ttlck->type = 0;\n\n\t/* bind the tlock and the page */\n\ttlck->ip = ip;\n\ttlck->mp = mp;\n\tif (dir_xtree)\n\t\tjfs_ip->xtlid = lid;\n\telse\n\t\tmp->lid = lid;\n\n\t/*\n\t * enqueue transaction lock to transaction/inode\n\t */\n\t/* insert the tlock at tail of transaction tlock list */\n\tif (tid) {\n\t\ttblk = tid_to_tblock(tid);\n\t\tif (tblk->next)\n\t\t\tlid_to_tlock(tblk->last)->next = lid;\n\t\telse\n\t\t\ttblk->next = lid;\n\t\ttlck->next = 0;\n\t\ttblk->last = lid;\n\t}\n\t/* anonymous transaction:\n\t * insert the tlock at head of inode anonymous tlock list\n\t */\n\telse {\n\t\ttlck->next = jfs_ip->atlhead;\n\t\tjfs_ip->atlhead = lid;\n\t\tif (tlck->next == 0) {\n\t\t\t/* This inode's first anonymous transaction */\n\t\t\tjfs_ip->atltail = lid;\n\t\t\tTXN_LOCK();\n\t\t\tlist_add_tail(&jfs_ip->anon_inode_list,\n\t\t\t\t      &TxAnchor.anon_list);\n\t\t\tTXN_UNLOCK();\n\t\t}\n\t}\n\n\t/* initialize type dependent area for linelock */\n\tlinelock = (struct linelock *) & tlck->lock;\n\tlinelock->next = 0;\n\tlinelock->flag = tlckLINELOCK;\n\tlinelock->maxcnt = TLOCKSHORT;\n\tlinelock->index = 0;\n\n\tswitch (type & tlckTYPE) {\n\tcase tlckDTREE:\n\t\tlinelock->l2linesize = L2DTSLOTSIZE;\n\t\tbreak;\n\n\tcase tlckXTREE:\n\t\tlinelock->l2linesize = L2XTSLOTSIZE;\n\n\t\txtlck = (struct xtlock *) linelock;\n\t\txtlck->header.offset = 0;\n\t\txtlck->header.length = 2;\n\n\t\tif (type & tlckNEW) {\n\t\t\txtlck->lwm.offset = XTENTRYSTART;\n\t\t} else {\n\t\t\tif (mp->xflag & COMMIT_PAGE)\n\t\t\t\tp = (xtpage_t *) mp->data;\n\t\t\telse\n\t\t\t\tp = &jfs_ip->i_xtroot;\n\t\t\txtlck->lwm.offset =\n\t\t\t    le16_to_cpu(p->header.nextindex);\n\t\t}\n\t\txtlck->lwm.length = 0;\t/* ! */\n\t\txtlck->twm.offset = 0;\n\t\txtlck->hwm.offset = 0;\n\n\t\txtlck->index = 2;\n\t\tbreak;\n\n\tcase tlckINODE:\n\t\tlinelock->l2linesize = L2INODESLOTSIZE;\n\t\tbreak;\n\n\tcase tlckDATA:\n\t\tlinelock->l2linesize = L2DATASLOTSIZE;\n\t\tbreak;\n\n\tdefault:\n\t\tjfs_err(\"UFO tlock:0x%p\", tlck);\n\t}\n\n\t/*\n\t * update tlock vector\n\t */\n      grantLock:\n\ttlck->type |= type;\n\n\treturn tlck;\n\n\t/*\n\t * page is being locked by another transaction:\n\t */\n      waitLock:\n\t/* Only locks on ipimap or ipaimap should reach here */\n\t/* assert(jfs_ip->fileset == AGGREGATE_I); */\n\tif (jfs_ip->fileset != AGGREGATE_I) {\n\t\tprintk(KERN_ERR \"txLock: trying to lock locked page!\");\n\t\tprint_hex_dump(KERN_ERR, \"ip: \", DUMP_PREFIX_ADDRESS, 16, 4,\n\t\t\t       ip, sizeof(*ip), 0);\n\t\tprint_hex_dump(KERN_ERR, \"mp: \", DUMP_PREFIX_ADDRESS, 16, 4,\n\t\t\t       mp, sizeof(*mp), 0);\n\t\tprint_hex_dump(KERN_ERR, \"Locker's tblock: \",\n\t\t\t       DUMP_PREFIX_ADDRESS, 16, 4, tid_to_tblock(tid),\n\t\t\t       sizeof(struct tblock), 0);\n\t\tprint_hex_dump(KERN_ERR, \"Tlock: \", DUMP_PREFIX_ADDRESS, 16, 4,\n\t\t\t       tlck, sizeof(*tlck), 0);\n\t\tBUG();\n\t}\n\tINCREMENT(stattx.waitlock);\t/* statistics */\n\tTXN_UNLOCK();\n\trelease_metapage(mp);\n\tTXN_LOCK();\n\txtid = tlck->tid;\t/* reacquire after dropping TXN_LOCK */\n\n\tjfs_info(\"txLock: in waitLock, tid = %d, xtid = %d, lid = %d\",\n\t\t tid, xtid, lid);\n\n\t/* Recheck everything since dropping TXN_LOCK */\n\tif (xtid && (tlck->mp == mp) && (mp->lid == lid))\n\t\tTXN_SLEEP_DROP_LOCK(&tid_to_tblock(xtid)->waitor);\n\telse\n\t\tTXN_UNLOCK();\n\tjfs_info(\"txLock: awakened     tid = %d, lid = %d\", tid, lid);\n\n\treturn NULL;\n}",
          "includes": [
            "#include \"jfs_debug.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_dmap.h\"",
            "#include \"jfs_imap.h\"",
            "#include \"jfs_dinode.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_filsys.h\"",
            "#include \"jfs_inode.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/freezer.h>",
            "#include <linux/completion.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct {\n\tint freetid;\t\t/* index of a free tid structure */\n\tint freelock;\t\t/* index first free lock word */\n\twait_queue_head_t freewait;\t/* eventlist of free tblock */\n\twait_queue_head_t freelockwait;\t/* eventlist of free tlock */\n\twait_queue_head_t lowlockwait;\t/* eventlist of ample tlocks */\n\tint tlocksInUse;\t/* Number of tlocks in use */\n\tspinlock_t LazyLock;\t/* synchronize sync_queue & unlock_queue */\n/*\tstruct tblock *sync_queue; * Transactions waiting for data sync */\n\tstruct list_head unlock_queue;\t/* Txns waiting to be released */\n\tstruct list_head anon_list;\t/* inodes having anonymous txns */\n\tstruct list_head anon_list2;\t/* inodes having anonymous txns\n\t\t\t\t\t   that couldn't be sync'ed */\n} TxAnchor;",
            "static struct {\n\ttid_t maxtid;\t\t/* 4: biggest tid ever used */\n\tlid_t maxlid;\t\t/* 4: biggest lid ever used */\n\tint ntid;\t\t/* 4: # of transactions performed */\n\tint nlid;\t\t/* 4: # of tlocks acquired */\n\tint waitlock;\t\t/* 4: # of tlock wait */\n} stattx;",
            "static int dataLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t\tstruct tlock * tlck);",
            "static void dtLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t\tstruct tlock * tlck);",
            "static void mapLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t\tstruct tlock * tlck);",
            "static void txAllocPMap(struct inode *ip, struct maplock * maplock,\n\t\tstruct tblock * tblk);",
            "static void txForce(struct tblock * tblk);",
            "static void txUpdateMap(struct tblock * tblk);",
            "static void txRelease(struct tblock * tblk);",
            "static void xtLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t   struct tlock * tlck);",
            "static void LogSyncRelease(struct metapage * mp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_imap.h\"\n#include \"jfs_dinode.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_inode.h\"\n#include \"jfs_incore.h\"\n#include <linux/seq_file.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/freezer.h>\n#include <linux/completion.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n\nstatic struct {\n\tint freetid;\t\t/* index of a free tid structure */\n\tint freelock;\t\t/* index first free lock word */\n\twait_queue_head_t freewait;\t/* eventlist of free tblock */\n\twait_queue_head_t freelockwait;\t/* eventlist of free tlock */\n\twait_queue_head_t lowlockwait;\t/* eventlist of ample tlocks */\n\tint tlocksInUse;\t/* Number of tlocks in use */\n\tspinlock_t LazyLock;\t/* synchronize sync_queue & unlock_queue */\n/*\tstruct tblock *sync_queue; * Transactions waiting for data sync */\n\tstruct list_head unlock_queue;\t/* Txns waiting to be released */\n\tstruct list_head anon_list;\t/* inodes having anonymous txns */\n\tstruct list_head anon_list2;\t/* inodes having anonymous txns\n\t\t\t\t\t   that couldn't be sync'ed */\n} TxAnchor;\nstatic struct {\n\ttid_t maxtid;\t\t/* 4: biggest tid ever used */\n\tlid_t maxlid;\t\t/* 4: biggest lid ever used */\n\tint ntid;\t\t/* 4: # of transactions performed */\n\tint nlid;\t\t/* 4: # of tlocks acquired */\n\tint waitlock;\t\t/* 4: # of tlock wait */\n} stattx;\nstatic int dataLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t\tstruct tlock * tlck);\nstatic void dtLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t\tstruct tlock * tlck);\nstatic void mapLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t\tstruct tlock * tlck);\nstatic void txAllocPMap(struct inode *ip, struct maplock * maplock,\n\t\tstruct tblock * tblk);\nstatic void txForce(struct tblock * tblk);\nstatic void txUpdateMap(struct tblock * tblk);\nstatic void txRelease(struct tblock * tblk);\nstatic void xtLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t   struct tlock * tlck);\nstatic void LogSyncRelease(struct metapage * mp);\n\nstruct tlock *txLock(tid_t tid, struct inode *ip, struct metapage * mp,\n\t\t     int type)\n{\n\tstruct jfs_inode_info *jfs_ip = JFS_IP(ip);\n\tint dir_xtree = 0;\n\tlid_t lid;\n\ttid_t xtid;\n\tstruct tlock *tlck;\n\tstruct xtlock *xtlck;\n\tstruct linelock *linelock;\n\txtpage_t *p;\n\tstruct tblock *tblk;\n\n\tTXN_LOCK();\n\n\tif (S_ISDIR(ip->i_mode) && (type & tlckXTREE) &&\n\t    !(mp->xflag & COMMIT_PAGE)) {\n\t\t/*\n\t\t * Directory inode is special.  It can have both an xtree tlock\n\t\t * and a dtree tlock associated with it.\n\t\t */\n\t\tdir_xtree = 1;\n\t\tlid = jfs_ip->xtlid;\n\t} else\n\t\tlid = mp->lid;\n\n\t/* is page not locked by a transaction ? */\n\tif (lid == 0)\n\t\tgoto allocateLock;\n\n\tjfs_info(\"txLock: tid:%d ip:0x%p mp:0x%p lid:%d\", tid, ip, mp, lid);\n\n\t/* is page locked by the requester transaction ? */\n\ttlck = lid_to_tlock(lid);\n\tif ((xtid = tlck->tid) == tid) {\n\t\tTXN_UNLOCK();\n\t\tgoto grantLock;\n\t}\n\n\t/*\n\t * is page locked by anonymous transaction/lock ?\n\t *\n\t * (page update without transaction (i.e., file write) is\n\t * locked under anonymous transaction tid = 0:\n\t * anonymous tlocks maintained on anonymous tlock list of\n\t * the inode of the page and available to all anonymous\n\t * transactions until txCommit() time at which point\n\t * they are transferred to the transaction tlock list of\n\t * the committing transaction of the inode)\n\t */\n\tif (xtid == 0) {\n\t\ttlck->tid = tid;\n\t\tTXN_UNLOCK();\n\t\ttblk = tid_to_tblock(tid);\n\t\t/*\n\t\t * The order of the tlocks in the transaction is important\n\t\t * (during truncate, child xtree pages must be freed before\n\t\t * parent's tlocks change the working map).\n\t\t * Take tlock off anonymous list and add to tail of\n\t\t * transaction list\n\t\t *\n\t\t * Note:  We really need to get rid of the tid & lid and\n\t\t * use list_head's.  This code is getting UGLY!\n\t\t */\n\t\tif (jfs_ip->atlhead == lid) {\n\t\t\tif (jfs_ip->atltail == lid) {\n\t\t\t\t/* only anonymous txn.\n\t\t\t\t * Remove from anon_list\n\t\t\t\t */\n\t\t\t\tTXN_LOCK();\n\t\t\t\tlist_del_init(&jfs_ip->anon_inode_list);\n\t\t\t\tTXN_UNLOCK();\n\t\t\t}\n\t\t\tjfs_ip->atlhead = tlck->next;\n\t\t} else {\n\t\t\tlid_t last;\n\t\t\tfor (last = jfs_ip->atlhead;\n\t\t\t     lid_to_tlock(last)->next != lid;\n\t\t\t     last = lid_to_tlock(last)->next) {\n\t\t\t\tassert(last);\n\t\t\t}\n\t\t\tlid_to_tlock(last)->next = tlck->next;\n\t\t\tif (jfs_ip->atltail == lid)\n\t\t\t\tjfs_ip->atltail = last;\n\t\t}\n\n\t\t/* insert the tlock at tail of transaction tlock list */\n\n\t\tif (tblk->next)\n\t\t\tlid_to_tlock(tblk->last)->next = lid;\n\t\telse\n\t\t\ttblk->next = lid;\n\t\ttlck->next = 0;\n\t\ttblk->last = lid;\n\n\t\tgoto grantLock;\n\t}\n\n\tgoto waitLock;\n\n\t/*\n\t * allocate a tlock\n\t */\n      allocateLock:\n\tlid = txLockAlloc();\n\ttlck = lid_to_tlock(lid);\n\n\t/*\n\t * initialize tlock\n\t */\n\ttlck->tid = tid;\n\n\tTXN_UNLOCK();\n\n\t/* mark tlock for meta-data page */\n\tif (mp->xflag & COMMIT_PAGE) {\n\n\t\ttlck->flag = tlckPAGELOCK;\n\n\t\t/* mark the page dirty and nohomeok */\n\t\tmetapage_nohomeok(mp);\n\n\t\tjfs_info(\"locking mp = 0x%p, nohomeok = %d tid = %d tlck = 0x%p\",\n\t\t\t mp, mp->nohomeok, tid, tlck);\n\n\t\t/* if anonymous transaction, and buffer is on the group\n\t\t * commit synclist, mark inode to show this.  This will\n\t\t * prevent the buffer from being marked nohomeok for too\n\t\t * long a time.\n\t\t */\n\t\tif ((tid == 0) && mp->lsn)\n\t\t\tset_cflag(COMMIT_Synclist, ip);\n\t}\n\t/* mark tlock for in-memory inode */\n\telse\n\t\ttlck->flag = tlckINODELOCK;\n\n\tif (S_ISDIR(ip->i_mode))\n\t\ttlck->flag |= tlckDIRECTORY;\n\n\ttlck->type = 0;\n\n\t/* bind the tlock and the page */\n\ttlck->ip = ip;\n\ttlck->mp = mp;\n\tif (dir_xtree)\n\t\tjfs_ip->xtlid = lid;\n\telse\n\t\tmp->lid = lid;\n\n\t/*\n\t * enqueue transaction lock to transaction/inode\n\t */\n\t/* insert the tlock at tail of transaction tlock list */\n\tif (tid) {\n\t\ttblk = tid_to_tblock(tid);\n\t\tif (tblk->next)\n\t\t\tlid_to_tlock(tblk->last)->next = lid;\n\t\telse\n\t\t\ttblk->next = lid;\n\t\ttlck->next = 0;\n\t\ttblk->last = lid;\n\t}\n\t/* anonymous transaction:\n\t * insert the tlock at head of inode anonymous tlock list\n\t */\n\telse {\n\t\ttlck->next = jfs_ip->atlhead;\n\t\tjfs_ip->atlhead = lid;\n\t\tif (tlck->next == 0) {\n\t\t\t/* This inode's first anonymous transaction */\n\t\t\tjfs_ip->atltail = lid;\n\t\t\tTXN_LOCK();\n\t\t\tlist_add_tail(&jfs_ip->anon_inode_list,\n\t\t\t\t      &TxAnchor.anon_list);\n\t\t\tTXN_UNLOCK();\n\t\t}\n\t}\n\n\t/* initialize type dependent area for linelock */\n\tlinelock = (struct linelock *) & tlck->lock;\n\tlinelock->next = 0;\n\tlinelock->flag = tlckLINELOCK;\n\tlinelock->maxcnt = TLOCKSHORT;\n\tlinelock->index = 0;\n\n\tswitch (type & tlckTYPE) {\n\tcase tlckDTREE:\n\t\tlinelock->l2linesize = L2DTSLOTSIZE;\n\t\tbreak;\n\n\tcase tlckXTREE:\n\t\tlinelock->l2linesize = L2XTSLOTSIZE;\n\n\t\txtlck = (struct xtlock *) linelock;\n\t\txtlck->header.offset = 0;\n\t\txtlck->header.length = 2;\n\n\t\tif (type & tlckNEW) {\n\t\t\txtlck->lwm.offset = XTENTRYSTART;\n\t\t} else {\n\t\t\tif (mp->xflag & COMMIT_PAGE)\n\t\t\t\tp = (xtpage_t *) mp->data;\n\t\t\telse\n\t\t\t\tp = &jfs_ip->i_xtroot;\n\t\t\txtlck->lwm.offset =\n\t\t\t    le16_to_cpu(p->header.nextindex);\n\t\t}\n\t\txtlck->lwm.length = 0;\t/* ! */\n\t\txtlck->twm.offset = 0;\n\t\txtlck->hwm.offset = 0;\n\n\t\txtlck->index = 2;\n\t\tbreak;\n\n\tcase tlckINODE:\n\t\tlinelock->l2linesize = L2INODESLOTSIZE;\n\t\tbreak;\n\n\tcase tlckDATA:\n\t\tlinelock->l2linesize = L2DATASLOTSIZE;\n\t\tbreak;\n\n\tdefault:\n\t\tjfs_err(\"UFO tlock:0x%p\", tlck);\n\t}\n\n\t/*\n\t * update tlock vector\n\t */\n      grantLock:\n\ttlck->type |= type;\n\n\treturn tlck;\n\n\t/*\n\t * page is being locked by another transaction:\n\t */\n      waitLock:\n\t/* Only locks on ipimap or ipaimap should reach here */\n\t/* assert(jfs_ip->fileset == AGGREGATE_I); */\n\tif (jfs_ip->fileset != AGGREGATE_I) {\n\t\tprintk(KERN_ERR \"txLock: trying to lock locked page!\");\n\t\tprint_hex_dump(KERN_ERR, \"ip: \", DUMP_PREFIX_ADDRESS, 16, 4,\n\t\t\t       ip, sizeof(*ip), 0);\n\t\tprint_hex_dump(KERN_ERR, \"mp: \", DUMP_PREFIX_ADDRESS, 16, 4,\n\t\t\t       mp, sizeof(*mp), 0);\n\t\tprint_hex_dump(KERN_ERR, \"Locker's tblock: \",\n\t\t\t       DUMP_PREFIX_ADDRESS, 16, 4, tid_to_tblock(tid),\n\t\t\t       sizeof(struct tblock), 0);\n\t\tprint_hex_dump(KERN_ERR, \"Tlock: \", DUMP_PREFIX_ADDRESS, 16, 4,\n\t\t\t       tlck, sizeof(*tlck), 0);\n\t\tBUG();\n\t}\n\tINCREMENT(stattx.waitlock);\t/* statistics */\n\tTXN_UNLOCK();\n\trelease_metapage(mp);\n\tTXN_LOCK();\n\txtid = tlck->tid;\t/* reacquire after dropping TXN_LOCK */\n\n\tjfs_info(\"txLock: in waitLock, tid = %d, xtid = %d, lid = %d\",\n\t\t tid, xtid, lid);\n\n\t/* Recheck everything since dropping TXN_LOCK */\n\tif (xtid && (tlck->mp == mp) && (mp->lid == lid))\n\t\tTXN_SLEEP_DROP_LOCK(&tid_to_tblock(xtid)->waitor);\n\telse\n\t\tTXN_UNLOCK();\n\tjfs_info(\"txLock: awakened     tid = %d, lid = %d\", tid, lid);\n\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&JFS_IP(ipimap)->commit_mutex"
          ],
          "line": 1250
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "txBegin",
          "args": [
            "ipimap->i_sb",
            "COMMIT_FORCE"
          ],
          "line": 1249
        },
        "resolved": true,
        "details": {
          "function_name": "txBegin",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_txnmgr.c",
          "lines": "361-447",
          "snippet": "tid_t txBegin(struct super_block *sb, int flag)\n{\n\ttid_t t;\n\tstruct tblock *tblk;\n\tstruct jfs_log *log;\n\n\tjfs_info(\"txBegin: flag = 0x%x\", flag);\n\tlog = JFS_SBI(sb)->log;\n\n\tTXN_LOCK();\n\n\tINCREMENT(TxStat.txBegin);\n\n      retry:\n\tif (!(flag & COMMIT_FORCE)) {\n\t\t/*\n\t\t * synchronize with logsync barrier\n\t\t */\n\t\tif (test_bit(log_SYNCBARRIER, &log->flag) ||\n\t\t    test_bit(log_QUIESCE, &log->flag)) {\n\t\t\tINCREMENT(TxStat.txBegin_barrier);\n\t\t\tTXN_SLEEP(&log->syncwait);\n\t\t\tgoto retry;\n\t\t}\n\t}\n\tif (flag == 0) {\n\t\t/*\n\t\t * Don't begin transaction if we're getting starved for tlocks\n\t\t * unless COMMIT_FORCE or COMMIT_INODE (which may ultimately\n\t\t * free tlocks)\n\t\t */\n\t\tif (TxAnchor.tlocksInUse > TxLockVHWM) {\n\t\t\tINCREMENT(TxStat.txBegin_lockslow);\n\t\t\tTXN_SLEEP(&TxAnchor.lowlockwait);\n\t\t\tgoto retry;\n\t\t}\n\t}\n\n\t/*\n\t * allocate transaction id/block\n\t */\n\tif ((t = TxAnchor.freetid) == 0) {\n\t\tjfs_info(\"txBegin: waiting for free tid\");\n\t\tINCREMENT(TxStat.txBegin_freetid);\n\t\tTXN_SLEEP(&TxAnchor.freewait);\n\t\tgoto retry;\n\t}\n\n\ttblk = tid_to_tblock(t);\n\n\tif ((tblk->next == 0) && !(flag & COMMIT_FORCE)) {\n\t\t/* Don't let a non-forced transaction take the last tblk */\n\t\tjfs_info(\"txBegin: waiting for free tid\");\n\t\tINCREMENT(TxStat.txBegin_freetid);\n\t\tTXN_SLEEP(&TxAnchor.freewait);\n\t\tgoto retry;\n\t}\n\n\tTxAnchor.freetid = tblk->next;\n\n\t/*\n\t * initialize transaction\n\t */\n\n\t/*\n\t * We can't zero the whole thing or we screw up another thread being\n\t * awakened after sleeping on tblk->waitor\n\t *\n\t * memset(tblk, 0, sizeof(struct tblock));\n\t */\n\ttblk->next = tblk->last = tblk->xflag = tblk->flag = tblk->lsn = 0;\n\n\ttblk->sb = sb;\n\t++log->logtid;\n\ttblk->logtid = log->logtid;\n\n\t++log->active;\n\n\tHIGHWATERMARK(stattx.maxtid, t);\t/* statistics */\n\tINCREMENT(stattx.ntid);\t/* statistics */\n\n\tTXN_UNLOCK();\n\n\tjfs_info(\"txBegin: returning tid = %d\", t);\n\n\treturn t;\n}",
          "includes": [
            "#include \"jfs_debug.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_dmap.h\"",
            "#include \"jfs_imap.h\"",
            "#include \"jfs_dinode.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_filsys.h\"",
            "#include \"jfs_inode.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/freezer.h>",
            "#include <linux/completion.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct {\n\tint freetid;\t\t/* index of a free tid structure */\n\tint freelock;\t\t/* index first free lock word */\n\twait_queue_head_t freewait;\t/* eventlist of free tblock */\n\twait_queue_head_t freelockwait;\t/* eventlist of free tlock */\n\twait_queue_head_t lowlockwait;\t/* eventlist of ample tlocks */\n\tint tlocksInUse;\t/* Number of tlocks in use */\n\tspinlock_t LazyLock;\t/* synchronize sync_queue & unlock_queue */\n/*\tstruct tblock *sync_queue; * Transactions waiting for data sync */\n\tstruct list_head unlock_queue;\t/* Txns waiting to be released */\n\tstruct list_head anon_list;\t/* inodes having anonymous txns */\n\tstruct list_head anon_list2;\t/* inodes having anonymous txns\n\t\t\t\t\t   that couldn't be sync'ed */\n} TxAnchor;",
            "static int TxLockVHWM;",
            "static struct {\n\ttid_t maxtid;\t\t/* 4: biggest tid ever used */\n\tlid_t maxlid;\t\t/* 4: biggest lid ever used */\n\tint ntid;\t\t/* 4: # of transactions performed */\n\tint nlid;\t\t/* 4: # of tlocks acquired */\n\tint waitlock;\t\t/* 4: # of tlock wait */\n} stattx;",
            "static void txAllocPMap(struct inode *ip, struct maplock * maplock,\n\t\tstruct tblock * tblk);",
            "static void txForce(struct tblock * tblk);",
            "static void txUpdateMap(struct tblock * tblk);",
            "static void txRelease(struct tblock * tblk);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_imap.h\"\n#include \"jfs_dinode.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_inode.h\"\n#include \"jfs_incore.h\"\n#include <linux/seq_file.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/freezer.h>\n#include <linux/completion.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n\nstatic struct {\n\tint freetid;\t\t/* index of a free tid structure */\n\tint freelock;\t\t/* index first free lock word */\n\twait_queue_head_t freewait;\t/* eventlist of free tblock */\n\twait_queue_head_t freelockwait;\t/* eventlist of free tlock */\n\twait_queue_head_t lowlockwait;\t/* eventlist of ample tlocks */\n\tint tlocksInUse;\t/* Number of tlocks in use */\n\tspinlock_t LazyLock;\t/* synchronize sync_queue & unlock_queue */\n/*\tstruct tblock *sync_queue; * Transactions waiting for data sync */\n\tstruct list_head unlock_queue;\t/* Txns waiting to be released */\n\tstruct list_head anon_list;\t/* inodes having anonymous txns */\n\tstruct list_head anon_list2;\t/* inodes having anonymous txns\n\t\t\t\t\t   that couldn't be sync'ed */\n} TxAnchor;\nstatic int TxLockVHWM;\nstatic struct {\n\ttid_t maxtid;\t\t/* 4: biggest tid ever used */\n\tlid_t maxlid;\t\t/* 4: biggest lid ever used */\n\tint ntid;\t\t/* 4: # of transactions performed */\n\tint nlid;\t\t/* 4: # of tlocks acquired */\n\tint waitlock;\t\t/* 4: # of tlock wait */\n} stattx;\nstatic void txAllocPMap(struct inode *ip, struct maplock * maplock,\n\t\tstruct tblock * tblk);\nstatic void txForce(struct tblock * tblk);\nstatic void txUpdateMap(struct tblock * tblk);\nstatic void txRelease(struct tblock * tblk);\n\ntid_t txBegin(struct super_block *sb, int flag)\n{\n\ttid_t t;\n\tstruct tblock *tblk;\n\tstruct jfs_log *log;\n\n\tjfs_info(\"txBegin: flag = 0x%x\", flag);\n\tlog = JFS_SBI(sb)->log;\n\n\tTXN_LOCK();\n\n\tINCREMENT(TxStat.txBegin);\n\n      retry:\n\tif (!(flag & COMMIT_FORCE)) {\n\t\t/*\n\t\t * synchronize with logsync barrier\n\t\t */\n\t\tif (test_bit(log_SYNCBARRIER, &log->flag) ||\n\t\t    test_bit(log_QUIESCE, &log->flag)) {\n\t\t\tINCREMENT(TxStat.txBegin_barrier);\n\t\t\tTXN_SLEEP(&log->syncwait);\n\t\t\tgoto retry;\n\t\t}\n\t}\n\tif (flag == 0) {\n\t\t/*\n\t\t * Don't begin transaction if we're getting starved for tlocks\n\t\t * unless COMMIT_FORCE or COMMIT_INODE (which may ultimately\n\t\t * free tlocks)\n\t\t */\n\t\tif (TxAnchor.tlocksInUse > TxLockVHWM) {\n\t\t\tINCREMENT(TxStat.txBegin_lockslow);\n\t\t\tTXN_SLEEP(&TxAnchor.lowlockwait);\n\t\t\tgoto retry;\n\t\t}\n\t}\n\n\t/*\n\t * allocate transaction id/block\n\t */\n\tif ((t = TxAnchor.freetid) == 0) {\n\t\tjfs_info(\"txBegin: waiting for free tid\");\n\t\tINCREMENT(TxStat.txBegin_freetid);\n\t\tTXN_SLEEP(&TxAnchor.freewait);\n\t\tgoto retry;\n\t}\n\n\ttblk = tid_to_tblock(t);\n\n\tif ((tblk->next == 0) && !(flag & COMMIT_FORCE)) {\n\t\t/* Don't let a non-forced transaction take the last tblk */\n\t\tjfs_info(\"txBegin: waiting for free tid\");\n\t\tINCREMENT(TxStat.txBegin_freetid);\n\t\tTXN_SLEEP(&TxAnchor.freewait);\n\t\tgoto retry;\n\t}\n\n\tTxAnchor.freetid = tblk->next;\n\n\t/*\n\t * initialize transaction\n\t */\n\n\t/*\n\t * We can't zero the whole thing or we screw up another thread being\n\t * awakened after sleeping on tblk->waitor\n\t *\n\t * memset(tblk, 0, sizeof(struct tblock));\n\t */\n\ttblk->next = tblk->last = tblk->xflag = tblk->flag = tblk->lsn = 0;\n\n\ttblk->sb = sb;\n\t++log->logtid;\n\ttblk->logtid = log->logtid;\n\n\t++log->active;\n\n\tHIGHWATERMARK(stattx.maxtid, t);\t/* statistics */\n\tINCREMENT(stattx.ntid);\t/* statistics */\n\n\tTXN_UNLOCK();\n\n\tjfs_info(\"txBegin: returning tid = %d\", t);\n\n\treturn t;\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_sub",
          "args": [
            "INOSPEREXT",
            "&imap->im_numinos"
          ],
          "line": 1229
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_sub",
          "args": [
            "INOSPEREXT - 1",
            "&imap->im_numfree"
          ],
          "line": 1228
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le32_add_cpu",
          "args": [
            "&iagp->nfreeexts",
            "1"
          ],
          "line": 1221
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le32_add_cpu",
          "args": [
            "&iagp->nfreeinos",
            "-(INOSPEREXT - 1)"
          ],
          "line": 1220
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "~mask"
          ],
          "line": 1215
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "mask"
          ],
          "line": 1214
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PXDaddress",
          "args": [
            "&iagp->inoext[extno]",
            "0"
          ],
          "line": 1204
        },
        "resolved": true,
        "details": {
          "function_name": "PXDaddress",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_types.h",
          "lines": "78-83",
          "snippet": "static inline void PXDaddress(pxd_t *pxd, __u64 addr)\n{\n\tpxd->len_addr = (pxd->len_addr & cpu_to_le32(0xffffff)) |\n\t\t\tcpu_to_le32((addr >> 32)<<24);\n\tpxd->addr2 = cpu_to_le32(addr & 0xffffffff);\n}",
          "includes": [
            "#include <linux/nls.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/nls.h>\n#include <linux/types.h>\n\nstatic inline void PXDaddress(pxd_t *pxd, __u64 addr)\n{\n\tpxd->len_addr = (pxd->len_addr & cpu_to_le32(0xffffff)) |\n\t\t\tcpu_to_le32((addr >> 32)<<24);\n\tpxd->addr2 = cpu_to_le32(addr & 0xffffffff);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PXDlength",
          "args": [
            "&iagp->inoext[extno]",
            "0"
          ],
          "line": 1203
        },
        "resolved": true,
        "details": {
          "function_name": "PXDlength",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_types.h",
          "lines": "72-76",
          "snippet": "static inline void PXDlength(pxd_t *pxd, __u32 len)\n{\n\tpxd->len_addr = (pxd->len_addr & cpu_to_le32(~0xffffff)) |\n\t\t\tcpu_to_le32(len & 0xffffff);\n}",
          "includes": [
            "#include <linux/nls.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/nls.h>\n#include <linux/types.h>\n\nstatic inline void PXDlength(pxd_t *pxd, __u32 len)\n{\n\tpxd->len_addr = (pxd->len_addr & cpu_to_le32(~0xffffff)) |\n\t\t\tcpu_to_le32(len & 0xffffff);\n}"
        }
      },
      {
        "call_info": {
          "callee": "jfs_error",
          "args": [
            "ip->i_sb",
            "\"the pmap does not show inode free\\n\""
          ],
          "line": 1200
        },
        "resolved": true,
        "details": {
          "function_name": "jfs_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/super.c",
          "lines": "95-111",
          "snippet": "void jfs_error(struct super_block *sb, const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tva_start(args, fmt);\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tpr_err(\"ERROR: (device %s): %pf: %pV\\n\",\n\t       sb->s_id, __builtin_return_address(0), &vaf);\n\n\tva_end(args);\n\n\tjfs_handle_error(sb);\n}",
          "includes": [
            "#include \"jfs_xattr.h\"",
            "#include \"jfs_debug.h\"",
            "#include \"jfs_acl.h\"",
            "#include \"jfs_imap.h\"",
            "#include \"jfs_dmap.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_inode.h\"",
            "#include \"jfs_filsys.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/blkdev.h>",
            "#include <linux/seq_file.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/crc32.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/mount.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/vfs.h>",
            "#include <linux/completion.h>",
            "#include <linux/parser.h>",
            "#include <linux/module.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_xattr.h\"\n#include \"jfs_debug.h\"\n#include \"jfs_acl.h\"\n#include \"jfs_imap.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_inode.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_incore.h\"\n#include <linux/blkdev.h>\n#include <linux/seq_file.h>\n#include <asm/uaccess.h>\n#include <linux/slab.h>\n#include <linux/crc32.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/posix_acl.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/mount.h>\n#include <linux/quotaops.h>\n#include <linux/vfs.h>\n#include <linux/completion.h>\n#include <linux/parser.h>\n#include <linux/module.h>\n#include <linux/fs.h>\n\nvoid jfs_error(struct super_block *sb, const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tva_start(args, fmt);\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tpr_err(\"ERROR: (device %s): %pf: %pV\\n\",\n\t       sb->s_id, __builtin_return_address(0), &vaf);\n\n\tva_end(args);\n\n\tjfs_handle_error(sb);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "-1"
          ],
          "line": 1191
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "iagp->inofreefwd"
          ],
          "line": 1189
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "INOSPEREXT - 1"
          ],
          "line": 1181
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IAGFREE_UNLOCK",
          "args": [
            "imap"
          ],
          "line": 1174
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "imap->im_freeiag"
          ],
          "line": 1172
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IAGFREE_LOCK",
          "args": [
            "imap"
          ],
          "line": 1171
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "-1"
          ],
          "line": 1169
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "EXTSPERIAG - 1"
          ],
          "line": 1159
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "-1"
          ],
          "line": 1153
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "imap->im_agctl[agno].extfree"
          ],
          "line": 1152
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "iagno"
          ],
          "line": 1149
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "invalidate_pxd_metapages",
          "args": [
            "ip",
            "freepxd"
          ],
          "line": 1139
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IREAD_UNLOCK",
          "args": [
            "ipimap"
          ],
          "line": 1133
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "diagp != NULL"
          ],
          "line": 1129
        },
        "resolved": true,
        "details": {
          "function_name": "hpfs_lock_assert",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/hpfs_fn.h",
          "lines": "359-363",
          "snippet": "static inline void hpfs_lock_assert(struct super_block *s)\n{\n\tstruct hpfs_sb_info *sbi = hpfs_sb(s);\n\tWARN_ON(!mutex_is_locked(&sbi->hpfs_mutex));\n}",
          "includes": [
            "#include \"hpfs.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int hpfs_check_free_dnodes(struct super_block *, int);",
            "void hpfs_prefetch_sectors(struct super_block *, unsigned, int);",
            "void hpfs_prefetch_bitmap(struct super_block *, unsigned);",
            "unsigned char *hpfs_translate_name(struct super_block *, unsigned char *, unsigned, int, int);",
            "int hpfs_compare_names(struct super_block *, const unsigned char *, unsigned,\n\t\t       const unsigned char *, unsigned, int);",
            "void hpfs_error(struct super_block *, const char *, ...);",
            "int hpfs_stop_cycles(struct super_block *, int, int *, int *, char *);",
            "unsigned hpfs_get_free_dnodes(struct super_block *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"hpfs.h\"\n#include <asm/unaligned.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n#include <linux/mutex.h>\n\nint hpfs_check_free_dnodes(struct super_block *, int);\nvoid hpfs_prefetch_sectors(struct super_block *, unsigned, int);\nvoid hpfs_prefetch_bitmap(struct super_block *, unsigned);\nunsigned char *hpfs_translate_name(struct super_block *, unsigned char *, unsigned, int, int);\nint hpfs_compare_names(struct super_block *, const unsigned char *, unsigned,\n\t\t       const unsigned char *, unsigned, int);\nvoid hpfs_error(struct super_block *, const char *, ...);\nint hpfs_stop_cycles(struct super_block *, int, int *, int *, char *);\nunsigned hpfs_get_free_dnodes(struct super_block *);\n\nstatic inline void hpfs_lock_assert(struct super_block *s)\n{\n\tstruct hpfs_sb_info *sbi = hpfs_sb(s);\n\tWARN_ON(!mutex_is_locked(&sbi->hpfs_mutex));\n}"
        }
      },
      {
        "call_info": {
          "callee": "diIAGRead",
          "args": [
            "imap",
            "inofreeback",
            "&dmp"
          ],
          "line": 1125
        },
        "resolved": true,
        "details": {
          "function_name": "diIAGRead",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_imap.c",
          "lines": "2675-2690",
          "snippet": "static int diIAGRead(struct inomap * imap, int iagno, struct metapage ** mpp)\n{\n\tstruct inode *ipimap = imap->im_ipimap;\n\ts64 blkno;\n\n\t/* compute the logical block number of the iag. */\n\tblkno = IAGTOLBLK(iagno, JFS_SBI(ipimap->i_sb)->l2nbperpage);\n\n\t/* read the iag. */\n\t*mpp = read_metapage(ipimap, blkno, PSIZE, 0);\n\tif (*mpp == NULL) {\n\t\treturn -EIO;\n\t}\n\n\treturn (0);\n}",
          "includes": [
            "#include \"jfs_debug.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_imap.h\"",
            "#include \"jfs_dmap.h\"",
            "#include \"jfs_dinode.h\"",
            "#include \"jfs_filsys.h\"",
            "#include \"jfs_inode.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/slab.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int diAllocAG(struct inomap *, int, bool, struct inode *);",
            "static int diAllocAny(struct inomap *, int, bool, struct inode *);",
            "static int diAllocBit(struct inomap *, struct iag *, int);",
            "static int diAllocExt(struct inomap *, int, struct inode *);",
            "static int diAllocIno(struct inomap *, int, struct inode *);",
            "static int diNewExt(struct inomap *, struct iag *, int);",
            "static int diNewIAG(struct inomap *, int *, int, struct metapage **);",
            "static void duplicateIXtree(struct super_block *, s64, int, s64 *);",
            "static int diIAGRead(struct inomap * imap, int, struct metapage **);",
            "static int copy_from_dinode(struct dinode *, struct inode *);",
            "static void copy_to_dinode(struct dinode *, struct inode *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_imap.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_dinode.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_inode.h\"\n#include \"jfs_incore.h\"\n#include <linux/slab.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n\nstatic int diAllocAG(struct inomap *, int, bool, struct inode *);\nstatic int diAllocAny(struct inomap *, int, bool, struct inode *);\nstatic int diAllocBit(struct inomap *, struct iag *, int);\nstatic int diAllocExt(struct inomap *, int, struct inode *);\nstatic int diAllocIno(struct inomap *, int, struct inode *);\nstatic int diNewExt(struct inomap *, struct iag *, int);\nstatic int diNewIAG(struct inomap *, int *, int, struct metapage **);\nstatic void duplicateIXtree(struct super_block *, s64, int, s64 *);\nstatic int diIAGRead(struct inomap * imap, int, struct metapage **);\nstatic int copy_from_dinode(struct dinode *, struct inode *);\nstatic void copy_to_dinode(struct dinode *, struct inode *);\n\nstatic int diIAGRead(struct inomap * imap, int iagno, struct metapage ** mpp)\n{\n\tstruct inode *ipimap = imap->im_ipimap;\n\ts64 blkno;\n\n\t/* compute the logical block number of the iag. */\n\tblkno = IAGTOLBLK(iagno, JFS_SBI(ipimap->i_sb)->l2nbperpage);\n\n\t/* read the iag. */\n\t*mpp = read_metapage(ipimap, blkno, PSIZE, 0);\n\tif (*mpp == NULL) {\n\t\treturn -EIO;\n\t}\n\n\treturn (0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "INOSPEREXT - 1"
          ],
          "line": 1091
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "EXTSPERIAG - 1"
          ],
          "line": 1068
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AG_UNLOCK",
          "args": [
            "imap",
            "agno"
          ],
          "line": 1027
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_inc",
          "args": [
            "&imap->im_numfree"
          ],
          "line": 1023
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le32_add_cpu",
          "args": [
            "&iagp->nfreeinos",
            "1"
          ],
          "line": 1021
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "bitmap"
          ],
          "line": 1016
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "~(HIGHORDER >> bitno)"
          ],
          "line": 1011
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "ONES"
          ],
          "line": 1007
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IREAD_UNLOCK",
          "args": [
            "ipimap"
          ],
          "line": 1000
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "-1"
          ],
          "line": 997
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "imap->im_agctl[agno].inofree"
          ],
          "line": 996
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "iagno"
          ],
          "line": 987
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AG_UNLOCK",
          "args": [
            "imap",
            "agno"
          ],
          "line": 979
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IREAD_UNLOCK",
          "args": [
            "ipimap"
          ],
          "line": 978
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AG_UNLOCK",
          "args": [
            "imap",
            "agno"
          ],
          "line": 950
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IREAD_UNLOCK",
          "args": [
            "ipimap"
          ],
          "line": 949
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AG_UNLOCK",
          "args": [
            "imap",
            "agno"
          ],
          "line": 938
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IREAD_UNLOCK",
          "args": [
            "ipimap"
          ],
          "line": 937
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "addressPXD",
          "args": [
            "&iagp->inoext[extno]"
          ],
          "line": 935
        },
        "resolved": true,
        "details": {
          "function_name": "addressPXD",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_types.h",
          "lines": "91-95",
          "snippet": "static inline __u64 addressPXD(pxd_t *pxd)\n{\n\t__u64 n = le32_to_cpu(pxd->len_addr) & ~0xffffff;\n\treturn (n << 8) + le32_to_cpu(pxd->addr2);\n}",
          "includes": [
            "#include <linux/nls.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/nls.h>\n#include <linux/types.h>\n\nstatic inline __u64 addressPXD(pxd_t *pxd)\n{\n\t__u64 n = le32_to_cpu(pxd->len_addr) & ~0xffffff;\n\treturn (n << 8) + le32_to_cpu(pxd->addr2);\n}"
        }
      },
      {
        "call_info": {
          "callee": "AG_UNLOCK",
          "args": [
            "imap",
            "agno"
          ],
          "line": 918
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IREAD_UNLOCK",
          "args": [
            "ipimap"
          ],
          "line": 917
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IREAD_LOCK",
          "args": [
            "ipimap",
            "RDWRLOCK_IMAP"
          ],
          "line": 912
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AG_LOCK",
          "args": [
            "imap",
            "agno"
          ],
          "line": 907
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BLKTOAG",
          "args": [
            "JFS_IP(ip)->agstart",
            "JFS_SBI(ip->i_sb)"
          ],
          "line": 903
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "JFS_SBI",
          "args": [
            "ip->i_sb"
          ],
          "line": 903
        },
        "resolved": true,
        "details": {
          "function_name": "JFS_SBI",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_incore.h",
          "lines": "217-220",
          "snippet": "static inline struct jfs_sb_info *JFS_SBI(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"jfs_dtree.h\"",
            "#include \"jfs_xtree.h\"",
            "#include \"jfs_types.h\"",
            "#include <linux/bitops.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_dtree.h\"\n#include \"jfs_xtree.h\"\n#include \"jfs_types.h\"\n#include <linux/bitops.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mutex.h>\n\nstatic inline struct jfs_sb_info *JFS_SBI(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      },
      {
        "call_info": {
          "callee": "print_hex_dump",
          "args": [
            "KERN_ERR",
            "\"imap: \"",
            "DUMP_PREFIX_ADDRESS",
            "16",
            "4",
            "imap",
            "32",
            "0"
          ],
          "line": 894
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INOTOIAG",
          "args": [
            "inum"
          ],
          "line": 888
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_imap.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_dinode.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_inode.h\"\n#include \"jfs_incore.h\"\n#include <linux/slab.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n\nstatic int diAllocAG(struct inomap *, int, bool, struct inode *);\nstatic int diAllocAny(struct inomap *, int, bool, struct inode *);\nstatic int diAllocBit(struct inomap *, struct iag *, int);\nstatic int diAllocExt(struct inomap *, int, struct inode *);\nstatic int diAllocIno(struct inomap *, int, struct inode *);\nstatic int diFindFree(u32, int);\nstatic int diNewExt(struct inomap *, struct iag *, int);\nstatic int diNewIAG(struct inomap *, int *, int, struct metapage **);\nstatic int diIAGRead(struct inomap * imap, int, struct metapage **);\nstatic int copy_from_dinode(struct dinode *, struct inode *);\nstatic void copy_to_dinode(struct dinode *, struct inode *);\n\nint diFree(struct inode *ip)\n{\n\tint rc;\n\tino_t inum = ip->i_ino;\n\tstruct iag *iagp, *aiagp, *biagp, *ciagp, *diagp;\n\tstruct metapage *mp, *amp, *bmp, *cmp, *dmp;\n\tint iagno, ino, extno, bitno, sword, agno;\n\tint back, fwd;\n\tu32 bitmap, mask;\n\tstruct inode *ipimap = JFS_SBI(ip->i_sb)->ipimap;\n\tstruct inomap *imap = JFS_IP(ipimap)->i_imap;\n\tpxd_t freepxd;\n\ttid_t tid;\n\tstruct inode *iplist[3];\n\tstruct tlock *tlck;\n\tstruct pxd_lock *pxdlock;\n\n\t/*\n\t * This is just to suppress compiler warnings.  The same logic that\n\t * references these variables is used to initialize them.\n\t */\n\taiagp = biagp = ciagp = diagp = NULL;\n\n\t/* get the iag number containing the inode.\n\t */\n\tiagno = INOTOIAG(inum);\n\n\t/* make sure that the iag is contained within\n\t * the map.\n\t */\n\tif (iagno >= imap->im_nextiag) {\n\t\tprint_hex_dump(KERN_ERR, \"imap: \", DUMP_PREFIX_ADDRESS, 16, 4,\n\t\t\t       imap, 32, 0);\n\t\tjfs_error(ip->i_sb, \"inum = %d, iagno = %d, nextiag = %d\\n\",\n\t\t\t  (uint) inum, iagno, imap->im_nextiag);\n\t\treturn -EIO;\n\t}\n\n\t/* get the allocation group for this ino.\n\t */\n\tagno = BLKTOAG(JFS_IP(ip)->agstart, JFS_SBI(ip->i_sb));\n\n\t/* Lock the AG specific inode map information\n\t */\n\tAG_LOCK(imap, agno);\n\n\t/* Obtain read lock in imap inode.  Don't release it until we have\n\t * read all of the IAG's that we are going to.\n\t */\n\tIREAD_LOCK(ipimap, RDWRLOCK_IMAP);\n\n\t/* read the iag.\n\t */\n\tif ((rc = diIAGRead(imap, iagno, &mp))) {\n\t\tIREAD_UNLOCK(ipimap);\n\t\tAG_UNLOCK(imap, agno);\n\t\treturn (rc);\n\t}\n\tiagp = (struct iag *) mp->data;\n\n\t/* get the inode number and extent number of the inode within\n\t * the iag and the inode number within the extent.\n\t */\n\tino = inum & (INOSPERIAG - 1);\n\textno = ino >> L2INOSPEREXT;\n\tbitno = ino & (INOSPEREXT - 1);\n\tmask = HIGHORDER >> bitno;\n\n\tif (!(le32_to_cpu(iagp->wmap[extno]) & mask)) {\n\t\tjfs_error(ip->i_sb, \"wmap shows inode already free\\n\");\n\t}\n\n\tif (!addressPXD(&iagp->inoext[extno])) {\n\t\trelease_metapage(mp);\n\t\tIREAD_UNLOCK(ipimap);\n\t\tAG_UNLOCK(imap, agno);\n\t\tjfs_error(ip->i_sb, \"invalid inoext\\n\");\n\t\treturn -EIO;\n\t}\n\n\t/* compute the bitmap for the extent reflecting the freed inode.\n\t */\n\tbitmap = le32_to_cpu(iagp->wmap[extno]) & ~mask;\n\n\tif (imap->im_agctl[agno].numfree > imap->im_agctl[agno].numinos) {\n\t\trelease_metapage(mp);\n\t\tIREAD_UNLOCK(ipimap);\n\t\tAG_UNLOCK(imap, agno);\n\t\tjfs_error(ip->i_sb, \"numfree > numinos\\n\");\n\t\treturn -EIO;\n\t}\n\t/*\n\t *\tinode extent still has some inodes or below low water mark:\n\t *\tkeep the inode extent;\n\t */\n\tif (bitmap ||\n\t    imap->im_agctl[agno].numfree < 96 ||\n\t    (imap->im_agctl[agno].numfree < 288 &&\n\t     (((imap->im_agctl[agno].numfree * 100) /\n\t       imap->im_agctl[agno].numinos) <= 25))) {\n\t\t/* if the iag currently has no free inodes (i.e.,\n\t\t * the inode being freed is the first free inode of iag),\n\t\t * insert the iag at head of the inode free list for the ag.\n\t\t */\n\t\tif (iagp->nfreeinos == 0) {\n\t\t\t/* check if there are any iags on the ag inode\n\t\t\t * free list.  if so, read the first one so that\n\t\t\t * we can link the current iag onto the list at\n\t\t\t * the head.\n\t\t\t */\n\t\t\tif ((fwd = imap->im_agctl[agno].inofree) >= 0) {\n\t\t\t\t/* read the iag that currently is the head\n\t\t\t\t * of the list.\n\t\t\t\t */\n\t\t\t\tif ((rc = diIAGRead(imap, fwd, &amp))) {\n\t\t\t\t\tIREAD_UNLOCK(ipimap);\n\t\t\t\t\tAG_UNLOCK(imap, agno);\n\t\t\t\t\trelease_metapage(mp);\n\t\t\t\t\treturn (rc);\n\t\t\t\t}\n\t\t\t\taiagp = (struct iag *) amp->data;\n\n\t\t\t\t/* make current head point back to the iag.\n\t\t\t\t */\n\t\t\t\taiagp->inofreeback = cpu_to_le32(iagno);\n\n\t\t\t\twrite_metapage(amp);\n\t\t\t}\n\n\t\t\t/* iag points forward to current head and iag\n\t\t\t * becomes the new head of the list.\n\t\t\t */\n\t\t\tiagp->inofreefwd =\n\t\t\t    cpu_to_le32(imap->im_agctl[agno].inofree);\n\t\t\tiagp->inofreeback = cpu_to_le32(-1);\n\t\t\timap->im_agctl[agno].inofree = iagno;\n\t\t}\n\t\tIREAD_UNLOCK(ipimap);\n\n\t\t/* update the free inode summary map for the extent if\n\t\t * freeing the inode means the extent will now have free\n\t\t * inodes (i.e., the inode being freed is the first free\n\t\t * inode of extent),\n\t\t */\n\t\tif (iagp->wmap[extno] == cpu_to_le32(ONES)) {\n\t\t\tsword = extno >> L2EXTSPERSUM;\n\t\t\tbitno = extno & (EXTSPERSUM - 1);\n\t\t\tiagp->inosmap[sword] &=\n\t\t\t    cpu_to_le32(~(HIGHORDER >> bitno));\n\t\t}\n\n\t\t/* update the bitmap.\n\t\t */\n\t\tiagp->wmap[extno] = cpu_to_le32(bitmap);\n\n\t\t/* update the free inode counts at the iag, ag and\n\t\t * map level.\n\t\t */\n\t\tle32_add_cpu(&iagp->nfreeinos, 1);\n\t\timap->im_agctl[agno].numfree += 1;\n\t\tatomic_inc(&imap->im_numfree);\n\n\t\t/* release the AG inode map lock\n\t\t */\n\t\tAG_UNLOCK(imap, agno);\n\n\t\t/* write the iag */\n\t\twrite_metapage(mp);\n\n\t\treturn (0);\n\t}\n\n\n\t/*\n\t *\tinode extent has become free and above low water mark:\n\t *\tfree the inode extent;\n\t */\n\n\t/*\n\t *\tprepare to update iag list(s) (careful update step 1)\n\t */\n\tamp = bmp = cmp = dmp = NULL;\n\tfwd = back = -1;\n\n\t/* check if the iag currently has no free extents.  if so,\n\t * it will be placed on the head of the ag extent free list.\n\t */\n\tif (iagp->nfreeexts == 0) {\n\t\t/* check if the ag extent free list has any iags.\n\t\t * if so, read the iag at the head of the list now.\n\t\t * this (head) iag will be updated later to reflect\n\t\t * the addition of the current iag at the head of\n\t\t * the list.\n\t\t */\n\t\tif ((fwd = imap->im_agctl[agno].extfree) >= 0) {\n\t\t\tif ((rc = diIAGRead(imap, fwd, &amp)))\n\t\t\t\tgoto error_out;\n\t\t\taiagp = (struct iag *) amp->data;\n\t\t}\n\t} else {\n\t\t/* iag has free extents. check if the addition of a free\n\t\t * extent will cause all extents to be free within this\n\t\t * iag.  if so, the iag will be removed from the ag extent\n\t\t * free list and placed on the inode map's free iag list.\n\t\t */\n\t\tif (iagp->nfreeexts == cpu_to_le32(EXTSPERIAG - 1)) {\n\t\t\t/* in preparation for removing the iag from the\n\t\t\t * ag extent free list, read the iags preceding\n\t\t\t * and following the iag on the ag extent free\n\t\t\t * list.\n\t\t\t */\n\t\t\tif ((fwd = le32_to_cpu(iagp->extfreefwd)) >= 0) {\n\t\t\t\tif ((rc = diIAGRead(imap, fwd, &amp)))\n\t\t\t\t\tgoto error_out;\n\t\t\t\taiagp = (struct iag *) amp->data;\n\t\t\t}\n\n\t\t\tif ((back = le32_to_cpu(iagp->extfreeback)) >= 0) {\n\t\t\t\tif ((rc = diIAGRead(imap, back, &bmp)))\n\t\t\t\t\tgoto error_out;\n\t\t\t\tbiagp = (struct iag *) bmp->data;\n\t\t\t}\n\t\t}\n\t}\n\n\t/* remove the iag from the ag inode free list if freeing\n\t * this extent cause the iag to have no free inodes.\n\t */\n\tif (iagp->nfreeinos == cpu_to_le32(INOSPEREXT - 1)) {\n\t\tint inofreeback = le32_to_cpu(iagp->inofreeback);\n\t\tint inofreefwd = le32_to_cpu(iagp->inofreefwd);\n\n\t\t/* in preparation for removing the iag from the\n\t\t * ag inode free list, read the iags preceding\n\t\t * and following the iag on the ag inode free\n\t\t * list.  before reading these iags, we must make\n\t\t * sure that we already don't have them in hand\n\t\t * from up above, since re-reading an iag (buffer)\n\t\t * we are currently holding would cause a deadlock.\n\t\t */\n\t\tif (inofreefwd >= 0) {\n\n\t\t\tif (inofreefwd == fwd)\n\t\t\t\tciagp = (struct iag *) amp->data;\n\t\t\telse if (inofreefwd == back)\n\t\t\t\tciagp = (struct iag *) bmp->data;\n\t\t\telse {\n\t\t\t\tif ((rc =\n\t\t\t\t     diIAGRead(imap, inofreefwd, &cmp)))\n\t\t\t\t\tgoto error_out;\n\t\t\t\tciagp = (struct iag *) cmp->data;\n\t\t\t}\n\t\t\tassert(ciagp != NULL);\n\t\t}\n\n\t\tif (inofreeback >= 0) {\n\t\t\tif (inofreeback == fwd)\n\t\t\t\tdiagp = (struct iag *) amp->data;\n\t\t\telse if (inofreeback == back)\n\t\t\t\tdiagp = (struct iag *) bmp->data;\n\t\t\telse {\n\t\t\t\tif ((rc =\n\t\t\t\t     diIAGRead(imap, inofreeback, &dmp)))\n\t\t\t\t\tgoto error_out;\n\t\t\t\tdiagp = (struct iag *) dmp->data;\n\t\t\t}\n\t\t\tassert(diagp != NULL);\n\t\t}\n\t}\n\n\tIREAD_UNLOCK(ipimap);\n\n\t/*\n\t * invalidate any page of the inode extent freed from buffer cache;\n\t */\n\tfreepxd = iagp->inoext[extno];\n\tinvalidate_pxd_metapages(ip, freepxd);\n\n\t/*\n\t *\tupdate iag list(s) (careful update step 2)\n\t */\n\t/* add the iag to the ag extent free list if this is the\n\t * first free extent for the iag.\n\t */\n\tif (iagp->nfreeexts == 0) {\n\t\tif (fwd >= 0)\n\t\t\taiagp->extfreeback = cpu_to_le32(iagno);\n\n\t\tiagp->extfreefwd =\n\t\t    cpu_to_le32(imap->im_agctl[agno].extfree);\n\t\tiagp->extfreeback = cpu_to_le32(-1);\n\t\timap->im_agctl[agno].extfree = iagno;\n\t} else {\n\t\t/* remove the iag from the ag extent list if all extents\n\t\t * are now free and place it on the inode map iag free list.\n\t\t */\n\t\tif (iagp->nfreeexts == cpu_to_le32(EXTSPERIAG - 1)) {\n\t\t\tif (fwd >= 0)\n\t\t\t\taiagp->extfreeback = iagp->extfreeback;\n\n\t\t\tif (back >= 0)\n\t\t\t\tbiagp->extfreefwd = iagp->extfreefwd;\n\t\t\telse\n\t\t\t\timap->im_agctl[agno].extfree =\n\t\t\t\t    le32_to_cpu(iagp->extfreefwd);\n\n\t\t\tiagp->extfreefwd = iagp->extfreeback = cpu_to_le32(-1);\n\n\t\t\tIAGFREE_LOCK(imap);\n\t\t\tiagp->iagfree = cpu_to_le32(imap->im_freeiag);\n\t\t\timap->im_freeiag = iagno;\n\t\t\tIAGFREE_UNLOCK(imap);\n\t\t}\n\t}\n\n\t/* remove the iag from the ag inode free list if freeing\n\t * this extent causes the iag to have no free inodes.\n\t */\n\tif (iagp->nfreeinos == cpu_to_le32(INOSPEREXT - 1)) {\n\t\tif ((int) le32_to_cpu(iagp->inofreefwd) >= 0)\n\t\t\tciagp->inofreeback = iagp->inofreeback;\n\n\t\tif ((int) le32_to_cpu(iagp->inofreeback) >= 0)\n\t\t\tdiagp->inofreefwd = iagp->inofreefwd;\n\t\telse\n\t\t\timap->im_agctl[agno].inofree =\n\t\t\t    le32_to_cpu(iagp->inofreefwd);\n\n\t\tiagp->inofreefwd = iagp->inofreeback = cpu_to_le32(-1);\n\t}\n\n\t/* update the inode extent address and working map\n\t * to reflect the free extent.\n\t * the permanent map should have been updated already\n\t * for the inode being freed.\n\t */\n\tif (iagp->pmap[extno] != 0) {\n\t\tjfs_error(ip->i_sb, \"the pmap does not show inode free\\n\");\n\t}\n\tiagp->wmap[extno] = 0;\n\tPXDlength(&iagp->inoext[extno], 0);\n\tPXDaddress(&iagp->inoext[extno], 0);\n\n\t/* update the free extent and free inode summary maps\n\t * to reflect the freed extent.\n\t * the inode summary map is marked to indicate no inodes\n\t * available for the freed extent.\n\t */\n\tsword = extno >> L2EXTSPERSUM;\n\tbitno = extno & (EXTSPERSUM - 1);\n\tmask = HIGHORDER >> bitno;\n\tiagp->inosmap[sword] |= cpu_to_le32(mask);\n\tiagp->extsmap[sword] &= cpu_to_le32(~mask);\n\n\t/* update the number of free inodes and number of free extents\n\t * for the iag.\n\t */\n\tle32_add_cpu(&iagp->nfreeinos, -(INOSPEREXT - 1));\n\tle32_add_cpu(&iagp->nfreeexts, 1);\n\n\t/* update the number of free inodes and backed inodes\n\t * at the ag and inode map level.\n\t */\n\timap->im_agctl[agno].numfree -= (INOSPEREXT - 1);\n\timap->im_agctl[agno].numinos -= INOSPEREXT;\n\tatomic_sub(INOSPEREXT - 1, &imap->im_numfree);\n\tatomic_sub(INOSPEREXT, &imap->im_numinos);\n\n\tif (amp)\n\t\twrite_metapage(amp);\n\tif (bmp)\n\t\twrite_metapage(bmp);\n\tif (cmp)\n\t\twrite_metapage(cmp);\n\tif (dmp)\n\t\twrite_metapage(dmp);\n\n\t/*\n\t * start transaction to update block allocation map\n\t * for the inode extent freed;\n\t *\n\t * N.B. AG_LOCK is released and iag will be released below, and\n\t * other thread may allocate inode from/reusing the ixad freed\n\t * BUT with new/different backing inode extent from the extent\n\t * to be freed by the transaction;\n\t */\n\ttid = txBegin(ipimap->i_sb, COMMIT_FORCE);\n\tmutex_lock(&JFS_IP(ipimap)->commit_mutex);\n\n\t/* acquire tlock of the iag page of the freed ixad\n\t * to force the page NOHOMEOK (even though no data is\n\t * logged from the iag page) until NOREDOPAGE|FREEXTENT log\n\t * for the free of the extent is committed;\n\t * write FREEXTENT|NOREDOPAGE log record\n\t * N.B. linelock is overlaid as freed extent descriptor;\n\t */\n\ttlck = txLock(tid, ipimap, mp, tlckINODE | tlckFREE);\n\tpxdlock = (struct pxd_lock *) & tlck->lock;\n\tpxdlock->flag = mlckFREEPXD;\n\tpxdlock->pxd = freepxd;\n\tpxdlock->index = 1;\n\n\twrite_metapage(mp);\n\n\tiplist[0] = ipimap;\n\n\t/*\n\t * logredo needs the IAG number and IAG extent index in order\n\t * to ensure that the IMap is consistent.  The least disruptive\n\t * way to pass these values through  to the transaction manager\n\t * is in the iplist array.\n\t *\n\t * It's not pretty, but it works.\n\t */\n\tiplist[1] = (struct inode *) (size_t)iagno;\n\tiplist[2] = (struct inode *) (size_t)extno;\n\n\trc = txCommit(tid, 1, &iplist[0], COMMIT_FORCE);\n\n\ttxEnd(tid);\n\tmutex_unlock(&JFS_IP(ipimap)->commit_mutex);\n\n\t/* unlock the AG inode map information */\n\tAG_UNLOCK(imap, agno);\n\n\treturn (0);\n\n      error_out:\n\tIREAD_UNLOCK(ipimap);\n\n\tif (amp)\n\t\trelease_metapage(amp);\n\tif (bmp)\n\t\trelease_metapage(bmp);\n\tif (cmp)\n\t\trelease_metapage(cmp);\n\tif (dmp)\n\t\trelease_metapage(dmp);\n\n\tAG_UNLOCK(imap, agno);\n\n\trelease_metapage(mp);\n\n\treturn (rc);\n}"
  },
  {
    "function_name": "diWrite",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_imap.c",
    "lines": "599-822",
    "snippet": "int diWrite(tid_t tid, struct inode *ip)\n{\n\tstruct jfs_sb_info *sbi = JFS_SBI(ip->i_sb);\n\tstruct jfs_inode_info *jfs_ip = JFS_IP(ip);\n\tint rc = 0;\n\ts32 ino;\n\tstruct dinode *dp;\n\ts64 blkno;\n\tint block_offset;\n\tint inodes_left;\n\tstruct metapage *mp;\n\tunsigned long pageno;\n\tint rel_inode;\n\tint dioffset;\n\tstruct inode *ipimap;\n\tuint type;\n\tlid_t lid;\n\tstruct tlock *ditlck, *tlck;\n\tstruct linelock *dilinelock, *ilinelock;\n\tstruct lv *lv;\n\tint n;\n\n\tipimap = jfs_ip->ipimap;\n\n\tino = ip->i_ino & (INOSPERIAG - 1);\n\n\tif (!addressPXD(&(jfs_ip->ixpxd)) ||\n\t    (lengthPXD(&(jfs_ip->ixpxd)) !=\n\t     JFS_IP(ipimap)->i_imap->im_nbperiext)) {\n\t\tjfs_error(ip->i_sb, \"ixpxd invalid\\n\");\n\t\treturn -EIO;\n\t}\n\n\t/*\n\t * read the page of disk inode containing the specified inode:\n\t */\n\t/* compute the block address of the page */\n\tblkno = INOPBLK(&(jfs_ip->ixpxd), ino, sbi->l2nbperpage);\n\n\trel_inode = (ino & (INOSPERPAGE - 1));\n\tpageno = blkno >> sbi->l2nbperpage;\n\n\tif ((block_offset = ((u32) blkno & (sbi->nbperpage - 1)))) {\n\t\t/*\n\t\t * OS/2 didn't always align inode extents on page boundaries\n\t\t */\n\t\tinodes_left =\n\t\t    (sbi->nbperpage - block_offset) << sbi->l2niperblk;\n\n\t\tif (rel_inode < inodes_left)\n\t\t\trel_inode += block_offset << sbi->l2niperblk;\n\t\telse {\n\t\t\tpageno += 1;\n\t\t\trel_inode -= inodes_left;\n\t\t}\n\t}\n\t/* read the page of disk inode */\n      retry:\n\tmp = read_metapage(ipimap, pageno << sbi->l2nbperpage, PSIZE, 1);\n\tif (!mp)\n\t\treturn -EIO;\n\n\t/* get the pointer to the disk inode */\n\tdp = (struct dinode *) mp->data;\n\tdp += rel_inode;\n\n\tdioffset = (ino & (INOSPERPAGE - 1)) << L2DISIZE;\n\n\t/*\n\t * acquire transaction lock on the on-disk inode;\n\t * N.B. tlock is acquired on ipimap not ip;\n\t */\n\tif ((ditlck =\n\t     txLock(tid, ipimap, mp, tlckINODE | tlckENTRY)) == NULL)\n\t\tgoto retry;\n\tdilinelock = (struct linelock *) & ditlck->lock;\n\n\t/*\n\t * copy btree root from in-memory inode to on-disk inode\n\t *\n\t * (tlock is taken from inline B+-tree root in in-memory\n\t * inode when the B+-tree root is updated, which is pointed\n\t * by jfs_ip->blid as well as being on tx tlock list)\n\t *\n\t * further processing of btree root is based on the copy\n\t * in in-memory inode, where txLog() will log from, and,\n\t * for xtree root, txUpdateMap() will update map and reset\n\t * XAD_NEW bit;\n\t */\n\n\tif (S_ISDIR(ip->i_mode) && (lid = jfs_ip->xtlid)) {\n\t\t/*\n\t\t * This is the special xtree inside the directory for storing\n\t\t * the directory table\n\t\t */\n\t\txtpage_t *p, *xp;\n\t\txad_t *xad;\n\n\t\tjfs_ip->xtlid = 0;\n\t\ttlck = lid_to_tlock(lid);\n\t\tassert(tlck->type & tlckXTREE);\n\t\ttlck->type |= tlckBTROOT;\n\t\ttlck->mp = mp;\n\t\tilinelock = (struct linelock *) & tlck->lock;\n\n\t\t/*\n\t\t * copy xtree root from inode to dinode:\n\t\t */\n\t\tp = &jfs_ip->i_xtroot;\n\t\txp = (xtpage_t *) &dp->di_dirtable;\n\t\tlv = ilinelock->lv;\n\t\tfor (n = 0; n < ilinelock->index; n++, lv++) {\n\t\t\tmemcpy(&xp->xad[lv->offset], &p->xad[lv->offset],\n\t\t\t       lv->length << L2XTSLOTSIZE);\n\t\t}\n\n\t\t/* reset on-disk (metadata page) xtree XAD_NEW bit */\n\t\txad = &xp->xad[XTENTRYSTART];\n\t\tfor (n = XTENTRYSTART;\n\t\t     n < le16_to_cpu(xp->header.nextindex); n++, xad++)\n\t\t\tif (xad->flag & (XAD_NEW | XAD_EXTENDED))\n\t\t\t\txad->flag &= ~(XAD_NEW | XAD_EXTENDED);\n\t}\n\n\tif ((lid = jfs_ip->blid) == 0)\n\t\tgoto inlineData;\n\tjfs_ip->blid = 0;\n\n\ttlck = lid_to_tlock(lid);\n\ttype = tlck->type;\n\ttlck->type |= tlckBTROOT;\n\ttlck->mp = mp;\n\tilinelock = (struct linelock *) & tlck->lock;\n\n\t/*\n\t *\tregular file: 16 byte (XAD slot) granularity\n\t */\n\tif (type & tlckXTREE) {\n\t\txtpage_t *p, *xp;\n\t\txad_t *xad;\n\n\t\t/*\n\t\t * copy xtree root from inode to dinode:\n\t\t */\n\t\tp = &jfs_ip->i_xtroot;\n\t\txp = &dp->di_xtroot;\n\t\tlv = ilinelock->lv;\n\t\tfor (n = 0; n < ilinelock->index; n++, lv++) {\n\t\t\tmemcpy(&xp->xad[lv->offset], &p->xad[lv->offset],\n\t\t\t       lv->length << L2XTSLOTSIZE);\n\t\t}\n\n\t\t/* reset on-disk (metadata page) xtree XAD_NEW bit */\n\t\txad = &xp->xad[XTENTRYSTART];\n\t\tfor (n = XTENTRYSTART;\n\t\t     n < le16_to_cpu(xp->header.nextindex); n++, xad++)\n\t\t\tif (xad->flag & (XAD_NEW | XAD_EXTENDED))\n\t\t\t\txad->flag &= ~(XAD_NEW | XAD_EXTENDED);\n\t}\n\t/*\n\t *\tdirectory: 32 byte (directory entry slot) granularity\n\t */\n\telse if (type & tlckDTREE) {\n\t\tdtpage_t *p, *xp;\n\n\t\t/*\n\t\t * copy dtree root from inode to dinode:\n\t\t */\n\t\tp = (dtpage_t *) &jfs_ip->i_dtroot;\n\t\txp = (dtpage_t *) & dp->di_dtroot;\n\t\tlv = ilinelock->lv;\n\t\tfor (n = 0; n < ilinelock->index; n++, lv++) {\n\t\t\tmemcpy(&xp->slot[lv->offset], &p->slot[lv->offset],\n\t\t\t       lv->length << L2DTSLOTSIZE);\n\t\t}\n\t} else {\n\t\tjfs_err(\"diWrite: UFO tlock\");\n\t}\n\n      inlineData:\n\t/*\n\t * copy inline symlink from in-memory inode to on-disk inode\n\t */\n\tif (S_ISLNK(ip->i_mode) && ip->i_size < IDATASIZE) {\n\t\tlv = & dilinelock->lv[dilinelock->index];\n\t\tlv->offset = (dioffset + 2 * 128) >> L2INODESLOTSIZE;\n\t\tlv->length = 2;\n\t\tmemcpy(&dp->di_fastsymlink, jfs_ip->i_inline, IDATASIZE);\n\t\tdilinelock->index++;\n\t}\n\t/*\n\t * copy inline data from in-memory inode to on-disk inode:\n\t * 128 byte slot granularity\n\t */\n\tif (test_cflag(COMMIT_Inlineea, ip)) {\n\t\tlv = & dilinelock->lv[dilinelock->index];\n\t\tlv->offset = (dioffset + 3 * 128) >> L2INODESLOTSIZE;\n\t\tlv->length = 1;\n\t\tmemcpy(&dp->di_inlineea, jfs_ip->i_inline_ea, INODESLOTSIZE);\n\t\tdilinelock->index++;\n\n\t\tclear_cflag(COMMIT_Inlineea, ip);\n\t}\n\n\t/*\n\t *\tlock/copy inode base: 128 byte slot granularity\n\t */\n\tlv = & dilinelock->lv[dilinelock->index];\n\tlv->offset = dioffset >> L2INODESLOTSIZE;\n\tcopy_to_dinode(dp, ip);\n\tif (test_and_clear_cflag(COMMIT_Dirtable, ip)) {\n\t\tlv->length = 2;\n\t\tmemcpy(&dp->di_dirtable, &jfs_ip->i_dirtable, 96);\n\t} else\n\t\tlv->length = 1;\n\tdilinelock->index++;\n\n\t/* release the buffer holding the updated on-disk inode.\n\t * the buffer will be later written by commit processing.\n\t */\n\twrite_metapage(mp);\n\n\treturn (rc);\n}",
    "includes": [
      "#include \"jfs_debug.h\"",
      "#include \"jfs_superblock.h\"",
      "#include \"jfs_metapage.h\"",
      "#include \"jfs_imap.h\"",
      "#include \"jfs_dmap.h\"",
      "#include \"jfs_dinode.h\"",
      "#include \"jfs_filsys.h\"",
      "#include \"jfs_inode.h\"",
      "#include \"jfs_incore.h\"",
      "#include <linux/slab.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int diAllocAG(struct inomap *, int, bool, struct inode *);",
      "static int diAllocAny(struct inomap *, int, bool, struct inode *);",
      "static int diAllocExt(struct inomap *, int, struct inode *);",
      "static int diAllocIno(struct inomap *, int, struct inode *);",
      "static int diFindFree(u32, int);",
      "static int diNewIAG(struct inomap *, int *, int, struct metapage **);",
      "static void duplicateIXtree(struct super_block *, s64, int, s64 *);",
      "static int diIAGRead(struct inomap * imap, int, struct metapage **);",
      "static int copy_from_dinode(struct dinode *, struct inode *);",
      "static void copy_to_dinode(struct dinode *, struct inode *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "write_metapage",
          "args": [
            "mp"
          ],
          "line": 819
        },
        "resolved": true,
        "details": {
          "function_name": "write_metapage",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_metapage.h",
          "lines": "85-89",
          "snippet": "static inline void write_metapage(struct metapage *mp)\n{\n\tset_bit(META_dirty, &mp->flag);\n\trelease_metapage(mp);\n}",
          "includes": [
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [
            "#define META_dirty\t2"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/pagemap.h>\n\n#define META_dirty\t2\n\nstatic inline void write_metapage(struct metapage *mp)\n{\n\tset_bit(META_dirty, &mp->flag);\n\trelease_metapage(mp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "&dp->di_dirtable",
            "&jfs_ip->i_dirtable",
            "96"
          ],
          "line": 811
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_and_clear_cflag",
          "args": [
            "COMMIT_Dirtable",
            "ip"
          ],
          "line": 809
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "copy_to_dinode",
          "args": [
            "dp",
            "ip"
          ],
          "line": 808
        },
        "resolved": true,
        "details": {
          "function_name": "copy_to_dinode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_imap.c",
          "lines": "3130-3178",
          "snippet": "static void copy_to_dinode(struct dinode * dip, struct inode *ip)\n{\n\tstruct jfs_inode_info *jfs_ip = JFS_IP(ip);\n\tstruct jfs_sb_info *sbi = JFS_SBI(ip->i_sb);\n\n\tdip->di_fileset = cpu_to_le32(jfs_ip->fileset);\n\tdip->di_inostamp = cpu_to_le32(sbi->inostamp);\n\tdip->di_number = cpu_to_le32(ip->i_ino);\n\tdip->di_gen = cpu_to_le32(ip->i_generation);\n\tdip->di_size = cpu_to_le64(ip->i_size);\n\tdip->di_nblocks = cpu_to_le64(PBLK2LBLK(ip->i_sb, ip->i_blocks));\n\tdip->di_nlink = cpu_to_le32(ip->i_nlink);\n\tif (!uid_valid(sbi->uid))\n\t\tdip->di_uid = cpu_to_le32(i_uid_read(ip));\n\telse\n\t\tdip->di_uid =cpu_to_le32(from_kuid(&init_user_ns,\n\t\t\t\t\t\t   jfs_ip->saved_uid));\n\tif (!gid_valid(sbi->gid))\n\t\tdip->di_gid = cpu_to_le32(i_gid_read(ip));\n\telse\n\t\tdip->di_gid = cpu_to_le32(from_kgid(&init_user_ns,\n\t\t\t\t\t\t    jfs_ip->saved_gid));\n\tjfs_get_inode_flags(jfs_ip);\n\t/*\n\t * mode2 is only needed for storing the higher order bits.\n\t * Trust i_mode for the lower order ones\n\t */\n\tif (sbi->umask == -1)\n\t\tdip->di_mode = cpu_to_le32((jfs_ip->mode2 & 0xffff0000) |\n\t\t\t\t\t   ip->i_mode);\n\telse /* Leave the original permissions alone */\n\t\tdip->di_mode = cpu_to_le32(jfs_ip->mode2);\n\n\tdip->di_atime.tv_sec = cpu_to_le32(ip->i_atime.tv_sec);\n\tdip->di_atime.tv_nsec = cpu_to_le32(ip->i_atime.tv_nsec);\n\tdip->di_ctime.tv_sec = cpu_to_le32(ip->i_ctime.tv_sec);\n\tdip->di_ctime.tv_nsec = cpu_to_le32(ip->i_ctime.tv_nsec);\n\tdip->di_mtime.tv_sec = cpu_to_le32(ip->i_mtime.tv_sec);\n\tdip->di_mtime.tv_nsec = cpu_to_le32(ip->i_mtime.tv_nsec);\n\tdip->di_ixpxd = jfs_ip->ixpxd;\t/* in-memory pxd's are little-endian */\n\tdip->di_acl = jfs_ip->acl;\t/* as are dxd's */\n\tdip->di_ea = jfs_ip->ea;\n\tdip->di_next_index = cpu_to_le32(jfs_ip->next_index);\n\tdip->di_otime.tv_sec = cpu_to_le32(jfs_ip->otime);\n\tdip->di_otime.tv_nsec = 0;\n\tdip->di_acltype = cpu_to_le32(jfs_ip->acltype);\n\tif (S_ISCHR(ip->i_mode) || S_ISBLK(ip->i_mode))\n\t\tdip->di_rdev = cpu_to_le32(jfs_ip->dev);\n}",
          "includes": [
            "#include \"jfs_debug.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_imap.h\"",
            "#include \"jfs_dmap.h\"",
            "#include \"jfs_dinode.h\"",
            "#include \"jfs_filsys.h\"",
            "#include \"jfs_inode.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/slab.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int diAllocAG(struct inomap *, int, bool, struct inode *);",
            "static int diAllocAny(struct inomap *, int, bool, struct inode *);",
            "static int diAllocExt(struct inomap *, int, struct inode *);",
            "static int diAllocIno(struct inomap *, int, struct inode *);",
            "static int copy_from_dinode(struct dinode *, struct inode *);",
            "static void copy_to_dinode(struct dinode *, struct inode *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_imap.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_dinode.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_inode.h\"\n#include \"jfs_incore.h\"\n#include <linux/slab.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n\nstatic int diAllocAG(struct inomap *, int, bool, struct inode *);\nstatic int diAllocAny(struct inomap *, int, bool, struct inode *);\nstatic int diAllocExt(struct inomap *, int, struct inode *);\nstatic int diAllocIno(struct inomap *, int, struct inode *);\nstatic int copy_from_dinode(struct dinode *, struct inode *);\nstatic void copy_to_dinode(struct dinode *, struct inode *);\n\nstatic void copy_to_dinode(struct dinode * dip, struct inode *ip)\n{\n\tstruct jfs_inode_info *jfs_ip = JFS_IP(ip);\n\tstruct jfs_sb_info *sbi = JFS_SBI(ip->i_sb);\n\n\tdip->di_fileset = cpu_to_le32(jfs_ip->fileset);\n\tdip->di_inostamp = cpu_to_le32(sbi->inostamp);\n\tdip->di_number = cpu_to_le32(ip->i_ino);\n\tdip->di_gen = cpu_to_le32(ip->i_generation);\n\tdip->di_size = cpu_to_le64(ip->i_size);\n\tdip->di_nblocks = cpu_to_le64(PBLK2LBLK(ip->i_sb, ip->i_blocks));\n\tdip->di_nlink = cpu_to_le32(ip->i_nlink);\n\tif (!uid_valid(sbi->uid))\n\t\tdip->di_uid = cpu_to_le32(i_uid_read(ip));\n\telse\n\t\tdip->di_uid =cpu_to_le32(from_kuid(&init_user_ns,\n\t\t\t\t\t\t   jfs_ip->saved_uid));\n\tif (!gid_valid(sbi->gid))\n\t\tdip->di_gid = cpu_to_le32(i_gid_read(ip));\n\telse\n\t\tdip->di_gid = cpu_to_le32(from_kgid(&init_user_ns,\n\t\t\t\t\t\t    jfs_ip->saved_gid));\n\tjfs_get_inode_flags(jfs_ip);\n\t/*\n\t * mode2 is only needed for storing the higher order bits.\n\t * Trust i_mode for the lower order ones\n\t */\n\tif (sbi->umask == -1)\n\t\tdip->di_mode = cpu_to_le32((jfs_ip->mode2 & 0xffff0000) |\n\t\t\t\t\t   ip->i_mode);\n\telse /* Leave the original permissions alone */\n\t\tdip->di_mode = cpu_to_le32(jfs_ip->mode2);\n\n\tdip->di_atime.tv_sec = cpu_to_le32(ip->i_atime.tv_sec);\n\tdip->di_atime.tv_nsec = cpu_to_le32(ip->i_atime.tv_nsec);\n\tdip->di_ctime.tv_sec = cpu_to_le32(ip->i_ctime.tv_sec);\n\tdip->di_ctime.tv_nsec = cpu_to_le32(ip->i_ctime.tv_nsec);\n\tdip->di_mtime.tv_sec = cpu_to_le32(ip->i_mtime.tv_sec);\n\tdip->di_mtime.tv_nsec = cpu_to_le32(ip->i_mtime.tv_nsec);\n\tdip->di_ixpxd = jfs_ip->ixpxd;\t/* in-memory pxd's are little-endian */\n\tdip->di_acl = jfs_ip->acl;\t/* as are dxd's */\n\tdip->di_ea = jfs_ip->ea;\n\tdip->di_next_index = cpu_to_le32(jfs_ip->next_index);\n\tdip->di_otime.tv_sec = cpu_to_le32(jfs_ip->otime);\n\tdip->di_otime.tv_nsec = 0;\n\tdip->di_acltype = cpu_to_le32(jfs_ip->acltype);\n\tif (S_ISCHR(ip->i_mode) || S_ISBLK(ip->i_mode))\n\t\tdip->di_rdev = cpu_to_le32(jfs_ip->dev);\n}"
        }
      },
      {
        "call_info": {
          "callee": "clear_cflag",
          "args": [
            "COMMIT_Inlineea",
            "ip"
          ],
          "line": 800
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "&dp->di_inlineea",
            "jfs_ip->i_inline_ea",
            "INODESLOTSIZE"
          ],
          "line": 797
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_cflag",
          "args": [
            "COMMIT_Inlineea",
            "ip"
          ],
          "line": 793
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "&dp->di_fastsymlink",
            "jfs_ip->i_inline",
            "IDATASIZE"
          ],
          "line": 786
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISLNK",
          "args": [
            "ip->i_mode"
          ],
          "line": 782
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "jfs_err",
          "args": [
            "\"diWrite: UFO tlock\""
          ],
          "line": 775
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "&xp->slot[lv->offset]",
            "&p->slot[lv->offset]",
            "lv->length << L2DTSLOTSIZE"
          ],
          "line": 771
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le16_to_cpu",
          "args": [
            "xp->header.nextindex"
          ],
          "line": 754
        },
        "resolved": true,
        "details": {
          "function_name": "sle16_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "48-51",
          "snippet": "static inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "&xp->xad[lv->offset]",
            "&p->xad[lv->offset]",
            "lv->length << L2XTSLOTSIZE"
          ],
          "line": 747
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lid_to_tlock",
          "args": [
            "lid"
          ],
          "line": 727
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "&xp->xad[lv->offset]",
            "&p->xad[lv->offset]",
            "lv->length << L2XTSLOTSIZE"
          ],
          "line": 711
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "tlck->type & tlckXTREE"
          ],
          "line": 699
        },
        "resolved": true,
        "details": {
          "function_name": "hpfs_lock_assert",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/hpfs_fn.h",
          "lines": "359-363",
          "snippet": "static inline void hpfs_lock_assert(struct super_block *s)\n{\n\tstruct hpfs_sb_info *sbi = hpfs_sb(s);\n\tWARN_ON(!mutex_is_locked(&sbi->hpfs_mutex));\n}",
          "includes": [
            "#include \"hpfs.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int hpfs_check_free_dnodes(struct super_block *, int);",
            "void hpfs_prefetch_sectors(struct super_block *, unsigned, int);",
            "void hpfs_prefetch_bitmap(struct super_block *, unsigned);",
            "unsigned char *hpfs_translate_name(struct super_block *, unsigned char *, unsigned, int, int);",
            "int hpfs_compare_names(struct super_block *, const unsigned char *, unsigned,\n\t\t       const unsigned char *, unsigned, int);",
            "void hpfs_error(struct super_block *, const char *, ...);",
            "int hpfs_stop_cycles(struct super_block *, int, int *, int *, char *);",
            "unsigned hpfs_get_free_dnodes(struct super_block *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"hpfs.h\"\n#include <asm/unaligned.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n#include <linux/mutex.h>\n\nint hpfs_check_free_dnodes(struct super_block *, int);\nvoid hpfs_prefetch_sectors(struct super_block *, unsigned, int);\nvoid hpfs_prefetch_bitmap(struct super_block *, unsigned);\nunsigned char *hpfs_translate_name(struct super_block *, unsigned char *, unsigned, int, int);\nint hpfs_compare_names(struct super_block *, const unsigned char *, unsigned,\n\t\t       const unsigned char *, unsigned, int);\nvoid hpfs_error(struct super_block *, const char *, ...);\nint hpfs_stop_cycles(struct super_block *, int, int *, int *, char *);\nunsigned hpfs_get_free_dnodes(struct super_block *);\n\nstatic inline void hpfs_lock_assert(struct super_block *s)\n{\n\tstruct hpfs_sb_info *sbi = hpfs_sb(s);\n\tWARN_ON(!mutex_is_locked(&sbi->hpfs_mutex));\n}"
        }
      },
      {
        "call_info": {
          "callee": "lid_to_tlock",
          "args": [
            "lid"
          ],
          "line": 698
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISDIR",
          "args": [
            "ip->i_mode"
          ],
          "line": 689
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "txLock",
          "args": [
            "tid",
            "ipimap",
            "mp",
            "tlckINODE | tlckENTRY"
          ],
          "line": 672
        },
        "resolved": true,
        "details": {
          "function_name": "txLock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_txnmgr.c",
          "lines": "590-861",
          "snippet": "struct tlock *txLock(tid_t tid, struct inode *ip, struct metapage * mp,\n\t\t     int type)\n{\n\tstruct jfs_inode_info *jfs_ip = JFS_IP(ip);\n\tint dir_xtree = 0;\n\tlid_t lid;\n\ttid_t xtid;\n\tstruct tlock *tlck;\n\tstruct xtlock *xtlck;\n\tstruct linelock *linelock;\n\txtpage_t *p;\n\tstruct tblock *tblk;\n\n\tTXN_LOCK();\n\n\tif (S_ISDIR(ip->i_mode) && (type & tlckXTREE) &&\n\t    !(mp->xflag & COMMIT_PAGE)) {\n\t\t/*\n\t\t * Directory inode is special.  It can have both an xtree tlock\n\t\t * and a dtree tlock associated with it.\n\t\t */\n\t\tdir_xtree = 1;\n\t\tlid = jfs_ip->xtlid;\n\t} else\n\t\tlid = mp->lid;\n\n\t/* is page not locked by a transaction ? */\n\tif (lid == 0)\n\t\tgoto allocateLock;\n\n\tjfs_info(\"txLock: tid:%d ip:0x%p mp:0x%p lid:%d\", tid, ip, mp, lid);\n\n\t/* is page locked by the requester transaction ? */\n\ttlck = lid_to_tlock(lid);\n\tif ((xtid = tlck->tid) == tid) {\n\t\tTXN_UNLOCK();\n\t\tgoto grantLock;\n\t}\n\n\t/*\n\t * is page locked by anonymous transaction/lock ?\n\t *\n\t * (page update without transaction (i.e., file write) is\n\t * locked under anonymous transaction tid = 0:\n\t * anonymous tlocks maintained on anonymous tlock list of\n\t * the inode of the page and available to all anonymous\n\t * transactions until txCommit() time at which point\n\t * they are transferred to the transaction tlock list of\n\t * the committing transaction of the inode)\n\t */\n\tif (xtid == 0) {\n\t\ttlck->tid = tid;\n\t\tTXN_UNLOCK();\n\t\ttblk = tid_to_tblock(tid);\n\t\t/*\n\t\t * The order of the tlocks in the transaction is important\n\t\t * (during truncate, child xtree pages must be freed before\n\t\t * parent's tlocks change the working map).\n\t\t * Take tlock off anonymous list and add to tail of\n\t\t * transaction list\n\t\t *\n\t\t * Note:  We really need to get rid of the tid & lid and\n\t\t * use list_head's.  This code is getting UGLY!\n\t\t */\n\t\tif (jfs_ip->atlhead == lid) {\n\t\t\tif (jfs_ip->atltail == lid) {\n\t\t\t\t/* only anonymous txn.\n\t\t\t\t * Remove from anon_list\n\t\t\t\t */\n\t\t\t\tTXN_LOCK();\n\t\t\t\tlist_del_init(&jfs_ip->anon_inode_list);\n\t\t\t\tTXN_UNLOCK();\n\t\t\t}\n\t\t\tjfs_ip->atlhead = tlck->next;\n\t\t} else {\n\t\t\tlid_t last;\n\t\t\tfor (last = jfs_ip->atlhead;\n\t\t\t     lid_to_tlock(last)->next != lid;\n\t\t\t     last = lid_to_tlock(last)->next) {\n\t\t\t\tassert(last);\n\t\t\t}\n\t\t\tlid_to_tlock(last)->next = tlck->next;\n\t\t\tif (jfs_ip->atltail == lid)\n\t\t\t\tjfs_ip->atltail = last;\n\t\t}\n\n\t\t/* insert the tlock at tail of transaction tlock list */\n\n\t\tif (tblk->next)\n\t\t\tlid_to_tlock(tblk->last)->next = lid;\n\t\telse\n\t\t\ttblk->next = lid;\n\t\ttlck->next = 0;\n\t\ttblk->last = lid;\n\n\t\tgoto grantLock;\n\t}\n\n\tgoto waitLock;\n\n\t/*\n\t * allocate a tlock\n\t */\n      allocateLock:\n\tlid = txLockAlloc();\n\ttlck = lid_to_tlock(lid);\n\n\t/*\n\t * initialize tlock\n\t */\n\ttlck->tid = tid;\n\n\tTXN_UNLOCK();\n\n\t/* mark tlock for meta-data page */\n\tif (mp->xflag & COMMIT_PAGE) {\n\n\t\ttlck->flag = tlckPAGELOCK;\n\n\t\t/* mark the page dirty and nohomeok */\n\t\tmetapage_nohomeok(mp);\n\n\t\tjfs_info(\"locking mp = 0x%p, nohomeok = %d tid = %d tlck = 0x%p\",\n\t\t\t mp, mp->nohomeok, tid, tlck);\n\n\t\t/* if anonymous transaction, and buffer is on the group\n\t\t * commit synclist, mark inode to show this.  This will\n\t\t * prevent the buffer from being marked nohomeok for too\n\t\t * long a time.\n\t\t */\n\t\tif ((tid == 0) && mp->lsn)\n\t\t\tset_cflag(COMMIT_Synclist, ip);\n\t}\n\t/* mark tlock for in-memory inode */\n\telse\n\t\ttlck->flag = tlckINODELOCK;\n\n\tif (S_ISDIR(ip->i_mode))\n\t\ttlck->flag |= tlckDIRECTORY;\n\n\ttlck->type = 0;\n\n\t/* bind the tlock and the page */\n\ttlck->ip = ip;\n\ttlck->mp = mp;\n\tif (dir_xtree)\n\t\tjfs_ip->xtlid = lid;\n\telse\n\t\tmp->lid = lid;\n\n\t/*\n\t * enqueue transaction lock to transaction/inode\n\t */\n\t/* insert the tlock at tail of transaction tlock list */\n\tif (tid) {\n\t\ttblk = tid_to_tblock(tid);\n\t\tif (tblk->next)\n\t\t\tlid_to_tlock(tblk->last)->next = lid;\n\t\telse\n\t\t\ttblk->next = lid;\n\t\ttlck->next = 0;\n\t\ttblk->last = lid;\n\t}\n\t/* anonymous transaction:\n\t * insert the tlock at head of inode anonymous tlock list\n\t */\n\telse {\n\t\ttlck->next = jfs_ip->atlhead;\n\t\tjfs_ip->atlhead = lid;\n\t\tif (tlck->next == 0) {\n\t\t\t/* This inode's first anonymous transaction */\n\t\t\tjfs_ip->atltail = lid;\n\t\t\tTXN_LOCK();\n\t\t\tlist_add_tail(&jfs_ip->anon_inode_list,\n\t\t\t\t      &TxAnchor.anon_list);\n\t\t\tTXN_UNLOCK();\n\t\t}\n\t}\n\n\t/* initialize type dependent area for linelock */\n\tlinelock = (struct linelock *) & tlck->lock;\n\tlinelock->next = 0;\n\tlinelock->flag = tlckLINELOCK;\n\tlinelock->maxcnt = TLOCKSHORT;\n\tlinelock->index = 0;\n\n\tswitch (type & tlckTYPE) {\n\tcase tlckDTREE:\n\t\tlinelock->l2linesize = L2DTSLOTSIZE;\n\t\tbreak;\n\n\tcase tlckXTREE:\n\t\tlinelock->l2linesize = L2XTSLOTSIZE;\n\n\t\txtlck = (struct xtlock *) linelock;\n\t\txtlck->header.offset = 0;\n\t\txtlck->header.length = 2;\n\n\t\tif (type & tlckNEW) {\n\t\t\txtlck->lwm.offset = XTENTRYSTART;\n\t\t} else {\n\t\t\tif (mp->xflag & COMMIT_PAGE)\n\t\t\t\tp = (xtpage_t *) mp->data;\n\t\t\telse\n\t\t\t\tp = &jfs_ip->i_xtroot;\n\t\t\txtlck->lwm.offset =\n\t\t\t    le16_to_cpu(p->header.nextindex);\n\t\t}\n\t\txtlck->lwm.length = 0;\t/* ! */\n\t\txtlck->twm.offset = 0;\n\t\txtlck->hwm.offset = 0;\n\n\t\txtlck->index = 2;\n\t\tbreak;\n\n\tcase tlckINODE:\n\t\tlinelock->l2linesize = L2INODESLOTSIZE;\n\t\tbreak;\n\n\tcase tlckDATA:\n\t\tlinelock->l2linesize = L2DATASLOTSIZE;\n\t\tbreak;\n\n\tdefault:\n\t\tjfs_err(\"UFO tlock:0x%p\", tlck);\n\t}\n\n\t/*\n\t * update tlock vector\n\t */\n      grantLock:\n\ttlck->type |= type;\n\n\treturn tlck;\n\n\t/*\n\t * page is being locked by another transaction:\n\t */\n      waitLock:\n\t/* Only locks on ipimap or ipaimap should reach here */\n\t/* assert(jfs_ip->fileset == AGGREGATE_I); */\n\tif (jfs_ip->fileset != AGGREGATE_I) {\n\t\tprintk(KERN_ERR \"txLock: trying to lock locked page!\");\n\t\tprint_hex_dump(KERN_ERR, \"ip: \", DUMP_PREFIX_ADDRESS, 16, 4,\n\t\t\t       ip, sizeof(*ip), 0);\n\t\tprint_hex_dump(KERN_ERR, \"mp: \", DUMP_PREFIX_ADDRESS, 16, 4,\n\t\t\t       mp, sizeof(*mp), 0);\n\t\tprint_hex_dump(KERN_ERR, \"Locker's tblock: \",\n\t\t\t       DUMP_PREFIX_ADDRESS, 16, 4, tid_to_tblock(tid),\n\t\t\t       sizeof(struct tblock), 0);\n\t\tprint_hex_dump(KERN_ERR, \"Tlock: \", DUMP_PREFIX_ADDRESS, 16, 4,\n\t\t\t       tlck, sizeof(*tlck), 0);\n\t\tBUG();\n\t}\n\tINCREMENT(stattx.waitlock);\t/* statistics */\n\tTXN_UNLOCK();\n\trelease_metapage(mp);\n\tTXN_LOCK();\n\txtid = tlck->tid;\t/* reacquire after dropping TXN_LOCK */\n\n\tjfs_info(\"txLock: in waitLock, tid = %d, xtid = %d, lid = %d\",\n\t\t tid, xtid, lid);\n\n\t/* Recheck everything since dropping TXN_LOCK */\n\tif (xtid && (tlck->mp == mp) && (mp->lid == lid))\n\t\tTXN_SLEEP_DROP_LOCK(&tid_to_tblock(xtid)->waitor);\n\telse\n\t\tTXN_UNLOCK();\n\tjfs_info(\"txLock: awakened     tid = %d, lid = %d\", tid, lid);\n\n\treturn NULL;\n}",
          "includes": [
            "#include \"jfs_debug.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_dmap.h\"",
            "#include \"jfs_imap.h\"",
            "#include \"jfs_dinode.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_filsys.h\"",
            "#include \"jfs_inode.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/freezer.h>",
            "#include <linux/completion.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct {\n\tint freetid;\t\t/* index of a free tid structure */\n\tint freelock;\t\t/* index first free lock word */\n\twait_queue_head_t freewait;\t/* eventlist of free tblock */\n\twait_queue_head_t freelockwait;\t/* eventlist of free tlock */\n\twait_queue_head_t lowlockwait;\t/* eventlist of ample tlocks */\n\tint tlocksInUse;\t/* Number of tlocks in use */\n\tspinlock_t LazyLock;\t/* synchronize sync_queue & unlock_queue */\n/*\tstruct tblock *sync_queue; * Transactions waiting for data sync */\n\tstruct list_head unlock_queue;\t/* Txns waiting to be released */\n\tstruct list_head anon_list;\t/* inodes having anonymous txns */\n\tstruct list_head anon_list2;\t/* inodes having anonymous txns\n\t\t\t\t\t   that couldn't be sync'ed */\n} TxAnchor;",
            "static struct {\n\ttid_t maxtid;\t\t/* 4: biggest tid ever used */\n\tlid_t maxlid;\t\t/* 4: biggest lid ever used */\n\tint ntid;\t\t/* 4: # of transactions performed */\n\tint nlid;\t\t/* 4: # of tlocks acquired */\n\tint waitlock;\t\t/* 4: # of tlock wait */\n} stattx;",
            "static int dataLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t\tstruct tlock * tlck);",
            "static void dtLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t\tstruct tlock * tlck);",
            "static void mapLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t\tstruct tlock * tlck);",
            "static void txAllocPMap(struct inode *ip, struct maplock * maplock,\n\t\tstruct tblock * tblk);",
            "static void txForce(struct tblock * tblk);",
            "static void txUpdateMap(struct tblock * tblk);",
            "static void txRelease(struct tblock * tblk);",
            "static void xtLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t   struct tlock * tlck);",
            "static void LogSyncRelease(struct metapage * mp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_imap.h\"\n#include \"jfs_dinode.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_inode.h\"\n#include \"jfs_incore.h\"\n#include <linux/seq_file.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/freezer.h>\n#include <linux/completion.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n\nstatic struct {\n\tint freetid;\t\t/* index of a free tid structure */\n\tint freelock;\t\t/* index first free lock word */\n\twait_queue_head_t freewait;\t/* eventlist of free tblock */\n\twait_queue_head_t freelockwait;\t/* eventlist of free tlock */\n\twait_queue_head_t lowlockwait;\t/* eventlist of ample tlocks */\n\tint tlocksInUse;\t/* Number of tlocks in use */\n\tspinlock_t LazyLock;\t/* synchronize sync_queue & unlock_queue */\n/*\tstruct tblock *sync_queue; * Transactions waiting for data sync */\n\tstruct list_head unlock_queue;\t/* Txns waiting to be released */\n\tstruct list_head anon_list;\t/* inodes having anonymous txns */\n\tstruct list_head anon_list2;\t/* inodes having anonymous txns\n\t\t\t\t\t   that couldn't be sync'ed */\n} TxAnchor;\nstatic struct {\n\ttid_t maxtid;\t\t/* 4: biggest tid ever used */\n\tlid_t maxlid;\t\t/* 4: biggest lid ever used */\n\tint ntid;\t\t/* 4: # of transactions performed */\n\tint nlid;\t\t/* 4: # of tlocks acquired */\n\tint waitlock;\t\t/* 4: # of tlock wait */\n} stattx;\nstatic int dataLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t\tstruct tlock * tlck);\nstatic void dtLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t\tstruct tlock * tlck);\nstatic void mapLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t\tstruct tlock * tlck);\nstatic void txAllocPMap(struct inode *ip, struct maplock * maplock,\n\t\tstruct tblock * tblk);\nstatic void txForce(struct tblock * tblk);\nstatic void txUpdateMap(struct tblock * tblk);\nstatic void txRelease(struct tblock * tblk);\nstatic void xtLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t   struct tlock * tlck);\nstatic void LogSyncRelease(struct metapage * mp);\n\nstruct tlock *txLock(tid_t tid, struct inode *ip, struct metapage * mp,\n\t\t     int type)\n{\n\tstruct jfs_inode_info *jfs_ip = JFS_IP(ip);\n\tint dir_xtree = 0;\n\tlid_t lid;\n\ttid_t xtid;\n\tstruct tlock *tlck;\n\tstruct xtlock *xtlck;\n\tstruct linelock *linelock;\n\txtpage_t *p;\n\tstruct tblock *tblk;\n\n\tTXN_LOCK();\n\n\tif (S_ISDIR(ip->i_mode) && (type & tlckXTREE) &&\n\t    !(mp->xflag & COMMIT_PAGE)) {\n\t\t/*\n\t\t * Directory inode is special.  It can have both an xtree tlock\n\t\t * and a dtree tlock associated with it.\n\t\t */\n\t\tdir_xtree = 1;\n\t\tlid = jfs_ip->xtlid;\n\t} else\n\t\tlid = mp->lid;\n\n\t/* is page not locked by a transaction ? */\n\tif (lid == 0)\n\t\tgoto allocateLock;\n\n\tjfs_info(\"txLock: tid:%d ip:0x%p mp:0x%p lid:%d\", tid, ip, mp, lid);\n\n\t/* is page locked by the requester transaction ? */\n\ttlck = lid_to_tlock(lid);\n\tif ((xtid = tlck->tid) == tid) {\n\t\tTXN_UNLOCK();\n\t\tgoto grantLock;\n\t}\n\n\t/*\n\t * is page locked by anonymous transaction/lock ?\n\t *\n\t * (page update without transaction (i.e., file write) is\n\t * locked under anonymous transaction tid = 0:\n\t * anonymous tlocks maintained on anonymous tlock list of\n\t * the inode of the page and available to all anonymous\n\t * transactions until txCommit() time at which point\n\t * they are transferred to the transaction tlock list of\n\t * the committing transaction of the inode)\n\t */\n\tif (xtid == 0) {\n\t\ttlck->tid = tid;\n\t\tTXN_UNLOCK();\n\t\ttblk = tid_to_tblock(tid);\n\t\t/*\n\t\t * The order of the tlocks in the transaction is important\n\t\t * (during truncate, child xtree pages must be freed before\n\t\t * parent's tlocks change the working map).\n\t\t * Take tlock off anonymous list and add to tail of\n\t\t * transaction list\n\t\t *\n\t\t * Note:  We really need to get rid of the tid & lid and\n\t\t * use list_head's.  This code is getting UGLY!\n\t\t */\n\t\tif (jfs_ip->atlhead == lid) {\n\t\t\tif (jfs_ip->atltail == lid) {\n\t\t\t\t/* only anonymous txn.\n\t\t\t\t * Remove from anon_list\n\t\t\t\t */\n\t\t\t\tTXN_LOCK();\n\t\t\t\tlist_del_init(&jfs_ip->anon_inode_list);\n\t\t\t\tTXN_UNLOCK();\n\t\t\t}\n\t\t\tjfs_ip->atlhead = tlck->next;\n\t\t} else {\n\t\t\tlid_t last;\n\t\t\tfor (last = jfs_ip->atlhead;\n\t\t\t     lid_to_tlock(last)->next != lid;\n\t\t\t     last = lid_to_tlock(last)->next) {\n\t\t\t\tassert(last);\n\t\t\t}\n\t\t\tlid_to_tlock(last)->next = tlck->next;\n\t\t\tif (jfs_ip->atltail == lid)\n\t\t\t\tjfs_ip->atltail = last;\n\t\t}\n\n\t\t/* insert the tlock at tail of transaction tlock list */\n\n\t\tif (tblk->next)\n\t\t\tlid_to_tlock(tblk->last)->next = lid;\n\t\telse\n\t\t\ttblk->next = lid;\n\t\ttlck->next = 0;\n\t\ttblk->last = lid;\n\n\t\tgoto grantLock;\n\t}\n\n\tgoto waitLock;\n\n\t/*\n\t * allocate a tlock\n\t */\n      allocateLock:\n\tlid = txLockAlloc();\n\ttlck = lid_to_tlock(lid);\n\n\t/*\n\t * initialize tlock\n\t */\n\ttlck->tid = tid;\n\n\tTXN_UNLOCK();\n\n\t/* mark tlock for meta-data page */\n\tif (mp->xflag & COMMIT_PAGE) {\n\n\t\ttlck->flag = tlckPAGELOCK;\n\n\t\t/* mark the page dirty and nohomeok */\n\t\tmetapage_nohomeok(mp);\n\n\t\tjfs_info(\"locking mp = 0x%p, nohomeok = %d tid = %d tlck = 0x%p\",\n\t\t\t mp, mp->nohomeok, tid, tlck);\n\n\t\t/* if anonymous transaction, and buffer is on the group\n\t\t * commit synclist, mark inode to show this.  This will\n\t\t * prevent the buffer from being marked nohomeok for too\n\t\t * long a time.\n\t\t */\n\t\tif ((tid == 0) && mp->lsn)\n\t\t\tset_cflag(COMMIT_Synclist, ip);\n\t}\n\t/* mark tlock for in-memory inode */\n\telse\n\t\ttlck->flag = tlckINODELOCK;\n\n\tif (S_ISDIR(ip->i_mode))\n\t\ttlck->flag |= tlckDIRECTORY;\n\n\ttlck->type = 0;\n\n\t/* bind the tlock and the page */\n\ttlck->ip = ip;\n\ttlck->mp = mp;\n\tif (dir_xtree)\n\t\tjfs_ip->xtlid = lid;\n\telse\n\t\tmp->lid = lid;\n\n\t/*\n\t * enqueue transaction lock to transaction/inode\n\t */\n\t/* insert the tlock at tail of transaction tlock list */\n\tif (tid) {\n\t\ttblk = tid_to_tblock(tid);\n\t\tif (tblk->next)\n\t\t\tlid_to_tlock(tblk->last)->next = lid;\n\t\telse\n\t\t\ttblk->next = lid;\n\t\ttlck->next = 0;\n\t\ttblk->last = lid;\n\t}\n\t/* anonymous transaction:\n\t * insert the tlock at head of inode anonymous tlock list\n\t */\n\telse {\n\t\ttlck->next = jfs_ip->atlhead;\n\t\tjfs_ip->atlhead = lid;\n\t\tif (tlck->next == 0) {\n\t\t\t/* This inode's first anonymous transaction */\n\t\t\tjfs_ip->atltail = lid;\n\t\t\tTXN_LOCK();\n\t\t\tlist_add_tail(&jfs_ip->anon_inode_list,\n\t\t\t\t      &TxAnchor.anon_list);\n\t\t\tTXN_UNLOCK();\n\t\t}\n\t}\n\n\t/* initialize type dependent area for linelock */\n\tlinelock = (struct linelock *) & tlck->lock;\n\tlinelock->next = 0;\n\tlinelock->flag = tlckLINELOCK;\n\tlinelock->maxcnt = TLOCKSHORT;\n\tlinelock->index = 0;\n\n\tswitch (type & tlckTYPE) {\n\tcase tlckDTREE:\n\t\tlinelock->l2linesize = L2DTSLOTSIZE;\n\t\tbreak;\n\n\tcase tlckXTREE:\n\t\tlinelock->l2linesize = L2XTSLOTSIZE;\n\n\t\txtlck = (struct xtlock *) linelock;\n\t\txtlck->header.offset = 0;\n\t\txtlck->header.length = 2;\n\n\t\tif (type & tlckNEW) {\n\t\t\txtlck->lwm.offset = XTENTRYSTART;\n\t\t} else {\n\t\t\tif (mp->xflag & COMMIT_PAGE)\n\t\t\t\tp = (xtpage_t *) mp->data;\n\t\t\telse\n\t\t\t\tp = &jfs_ip->i_xtroot;\n\t\t\txtlck->lwm.offset =\n\t\t\t    le16_to_cpu(p->header.nextindex);\n\t\t}\n\t\txtlck->lwm.length = 0;\t/* ! */\n\t\txtlck->twm.offset = 0;\n\t\txtlck->hwm.offset = 0;\n\n\t\txtlck->index = 2;\n\t\tbreak;\n\n\tcase tlckINODE:\n\t\tlinelock->l2linesize = L2INODESLOTSIZE;\n\t\tbreak;\n\n\tcase tlckDATA:\n\t\tlinelock->l2linesize = L2DATASLOTSIZE;\n\t\tbreak;\n\n\tdefault:\n\t\tjfs_err(\"UFO tlock:0x%p\", tlck);\n\t}\n\n\t/*\n\t * update tlock vector\n\t */\n      grantLock:\n\ttlck->type |= type;\n\n\treturn tlck;\n\n\t/*\n\t * page is being locked by another transaction:\n\t */\n      waitLock:\n\t/* Only locks on ipimap or ipaimap should reach here */\n\t/* assert(jfs_ip->fileset == AGGREGATE_I); */\n\tif (jfs_ip->fileset != AGGREGATE_I) {\n\t\tprintk(KERN_ERR \"txLock: trying to lock locked page!\");\n\t\tprint_hex_dump(KERN_ERR, \"ip: \", DUMP_PREFIX_ADDRESS, 16, 4,\n\t\t\t       ip, sizeof(*ip), 0);\n\t\tprint_hex_dump(KERN_ERR, \"mp: \", DUMP_PREFIX_ADDRESS, 16, 4,\n\t\t\t       mp, sizeof(*mp), 0);\n\t\tprint_hex_dump(KERN_ERR, \"Locker's tblock: \",\n\t\t\t       DUMP_PREFIX_ADDRESS, 16, 4, tid_to_tblock(tid),\n\t\t\t       sizeof(struct tblock), 0);\n\t\tprint_hex_dump(KERN_ERR, \"Tlock: \", DUMP_PREFIX_ADDRESS, 16, 4,\n\t\t\t       tlck, sizeof(*tlck), 0);\n\t\tBUG();\n\t}\n\tINCREMENT(stattx.waitlock);\t/* statistics */\n\tTXN_UNLOCK();\n\trelease_metapage(mp);\n\tTXN_LOCK();\n\txtid = tlck->tid;\t/* reacquire after dropping TXN_LOCK */\n\n\tjfs_info(\"txLock: in waitLock, tid = %d, xtid = %d, lid = %d\",\n\t\t tid, xtid, lid);\n\n\t/* Recheck everything since dropping TXN_LOCK */\n\tif (xtid && (tlck->mp == mp) && (mp->lid == lid))\n\t\tTXN_SLEEP_DROP_LOCK(&tid_to_tblock(xtid)->waitor);\n\telse\n\t\tTXN_UNLOCK();\n\tjfs_info(\"txLock: awakened     tid = %d, lid = %d\", tid, lid);\n\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "read_metapage",
          "args": [
            "ipimap",
            "pageno << sbi->l2nbperpage",
            "PSIZE",
            "1"
          ],
          "line": 657
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INOPBLK",
          "args": [
            "&(jfs_ip->ixpxd)",
            "ino",
            "sbi->l2nbperpage"
          ],
          "line": 636
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "jfs_error",
          "args": [
            "ip->i_sb",
            "\"ixpxd invalid\\n\""
          ],
          "line": 628
        },
        "resolved": true,
        "details": {
          "function_name": "jfs_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/super.c",
          "lines": "95-111",
          "snippet": "void jfs_error(struct super_block *sb, const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tva_start(args, fmt);\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tpr_err(\"ERROR: (device %s): %pf: %pV\\n\",\n\t       sb->s_id, __builtin_return_address(0), &vaf);\n\n\tva_end(args);\n\n\tjfs_handle_error(sb);\n}",
          "includes": [
            "#include \"jfs_xattr.h\"",
            "#include \"jfs_debug.h\"",
            "#include \"jfs_acl.h\"",
            "#include \"jfs_imap.h\"",
            "#include \"jfs_dmap.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_inode.h\"",
            "#include \"jfs_filsys.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/blkdev.h>",
            "#include <linux/seq_file.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/crc32.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/mount.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/vfs.h>",
            "#include <linux/completion.h>",
            "#include <linux/parser.h>",
            "#include <linux/module.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_xattr.h\"\n#include \"jfs_debug.h\"\n#include \"jfs_acl.h\"\n#include \"jfs_imap.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_inode.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_incore.h\"\n#include <linux/blkdev.h>\n#include <linux/seq_file.h>\n#include <asm/uaccess.h>\n#include <linux/slab.h>\n#include <linux/crc32.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/posix_acl.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/mount.h>\n#include <linux/quotaops.h>\n#include <linux/vfs.h>\n#include <linux/completion.h>\n#include <linux/parser.h>\n#include <linux/module.h>\n#include <linux/fs.h>\n\nvoid jfs_error(struct super_block *sb, const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tva_start(args, fmt);\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tpr_err(\"ERROR: (device %s): %pf: %pV\\n\",\n\t       sb->s_id, __builtin_return_address(0), &vaf);\n\n\tva_end(args);\n\n\tjfs_handle_error(sb);\n}"
        }
      },
      {
        "call_info": {
          "callee": "JFS_IP",
          "args": [
            "ipimap"
          ],
          "line": 627
        },
        "resolved": true,
        "details": {
          "function_name": "JFS_IP",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_incore.h",
          "lines": "207-210",
          "snippet": "static inline struct jfs_inode_info *JFS_IP(struct inode *inode)\n{\n\treturn list_entry(inode, struct jfs_inode_info, vfs_inode);\n}",
          "includes": [
            "#include \"jfs_dtree.h\"",
            "#include \"jfs_xtree.h\"",
            "#include \"jfs_types.h\"",
            "#include <linux/bitops.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_dtree.h\"\n#include \"jfs_xtree.h\"\n#include \"jfs_types.h\"\n#include <linux/bitops.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mutex.h>\n\nstatic inline struct jfs_inode_info *JFS_IP(struct inode *inode)\n{\n\treturn list_entry(inode, struct jfs_inode_info, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "lengthPXD",
          "args": [
            "&(jfs_ip->ixpxd)"
          ],
          "line": 626
        },
        "resolved": true,
        "details": {
          "function_name": "lengthPXD",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_types.h",
          "lines": "86-89",
          "snippet": "static inline __u32 lengthPXD(pxd_t *pxd)\n{\n\treturn le32_to_cpu((pxd)->len_addr) & 0xffffff;\n}",
          "includes": [
            "#include <linux/nls.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/nls.h>\n#include <linux/types.h>\n\nstatic inline __u32 lengthPXD(pxd_t *pxd)\n{\n\treturn le32_to_cpu((pxd)->len_addr) & 0xffffff;\n}"
        }
      },
      {
        "call_info": {
          "callee": "addressPXD",
          "args": [
            "&(jfs_ip->ixpxd)"
          ],
          "line": 625
        },
        "resolved": true,
        "details": {
          "function_name": "addressPXD",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_types.h",
          "lines": "91-95",
          "snippet": "static inline __u64 addressPXD(pxd_t *pxd)\n{\n\t__u64 n = le32_to_cpu(pxd->len_addr) & ~0xffffff;\n\treturn (n << 8) + le32_to_cpu(pxd->addr2);\n}",
          "includes": [
            "#include <linux/nls.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/nls.h>\n#include <linux/types.h>\n\nstatic inline __u64 addressPXD(pxd_t *pxd)\n{\n\t__u64 n = le32_to_cpu(pxd->len_addr) & ~0xffffff;\n\treturn (n << 8) + le32_to_cpu(pxd->addr2);\n}"
        }
      },
      {
        "call_info": {
          "callee": "JFS_SBI",
          "args": [
            "ip->i_sb"
          ],
          "line": 601
        },
        "resolved": true,
        "details": {
          "function_name": "JFS_SBI",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_incore.h",
          "lines": "217-220",
          "snippet": "static inline struct jfs_sb_info *JFS_SBI(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"jfs_dtree.h\"",
            "#include \"jfs_xtree.h\"",
            "#include \"jfs_types.h\"",
            "#include <linux/bitops.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_dtree.h\"\n#include \"jfs_xtree.h\"\n#include \"jfs_types.h\"\n#include <linux/bitops.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mutex.h>\n\nstatic inline struct jfs_sb_info *JFS_SBI(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_imap.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_dinode.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_inode.h\"\n#include \"jfs_incore.h\"\n#include <linux/slab.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n\nstatic int diAllocAG(struct inomap *, int, bool, struct inode *);\nstatic int diAllocAny(struct inomap *, int, bool, struct inode *);\nstatic int diAllocExt(struct inomap *, int, struct inode *);\nstatic int diAllocIno(struct inomap *, int, struct inode *);\nstatic int diFindFree(u32, int);\nstatic int diNewIAG(struct inomap *, int *, int, struct metapage **);\nstatic void duplicateIXtree(struct super_block *, s64, int, s64 *);\nstatic int diIAGRead(struct inomap * imap, int, struct metapage **);\nstatic int copy_from_dinode(struct dinode *, struct inode *);\nstatic void copy_to_dinode(struct dinode *, struct inode *);\n\nint diWrite(tid_t tid, struct inode *ip)\n{\n\tstruct jfs_sb_info *sbi = JFS_SBI(ip->i_sb);\n\tstruct jfs_inode_info *jfs_ip = JFS_IP(ip);\n\tint rc = 0;\n\ts32 ino;\n\tstruct dinode *dp;\n\ts64 blkno;\n\tint block_offset;\n\tint inodes_left;\n\tstruct metapage *mp;\n\tunsigned long pageno;\n\tint rel_inode;\n\tint dioffset;\n\tstruct inode *ipimap;\n\tuint type;\n\tlid_t lid;\n\tstruct tlock *ditlck, *tlck;\n\tstruct linelock *dilinelock, *ilinelock;\n\tstruct lv *lv;\n\tint n;\n\n\tipimap = jfs_ip->ipimap;\n\n\tino = ip->i_ino & (INOSPERIAG - 1);\n\n\tif (!addressPXD(&(jfs_ip->ixpxd)) ||\n\t    (lengthPXD(&(jfs_ip->ixpxd)) !=\n\t     JFS_IP(ipimap)->i_imap->im_nbperiext)) {\n\t\tjfs_error(ip->i_sb, \"ixpxd invalid\\n\");\n\t\treturn -EIO;\n\t}\n\n\t/*\n\t * read the page of disk inode containing the specified inode:\n\t */\n\t/* compute the block address of the page */\n\tblkno = INOPBLK(&(jfs_ip->ixpxd), ino, sbi->l2nbperpage);\n\n\trel_inode = (ino & (INOSPERPAGE - 1));\n\tpageno = blkno >> sbi->l2nbperpage;\n\n\tif ((block_offset = ((u32) blkno & (sbi->nbperpage - 1)))) {\n\t\t/*\n\t\t * OS/2 didn't always align inode extents on page boundaries\n\t\t */\n\t\tinodes_left =\n\t\t    (sbi->nbperpage - block_offset) << sbi->l2niperblk;\n\n\t\tif (rel_inode < inodes_left)\n\t\t\trel_inode += block_offset << sbi->l2niperblk;\n\t\telse {\n\t\t\tpageno += 1;\n\t\t\trel_inode -= inodes_left;\n\t\t}\n\t}\n\t/* read the page of disk inode */\n      retry:\n\tmp = read_metapage(ipimap, pageno << sbi->l2nbperpage, PSIZE, 1);\n\tif (!mp)\n\t\treturn -EIO;\n\n\t/* get the pointer to the disk inode */\n\tdp = (struct dinode *) mp->data;\n\tdp += rel_inode;\n\n\tdioffset = (ino & (INOSPERPAGE - 1)) << L2DISIZE;\n\n\t/*\n\t * acquire transaction lock on the on-disk inode;\n\t * N.B. tlock is acquired on ipimap not ip;\n\t */\n\tif ((ditlck =\n\t     txLock(tid, ipimap, mp, tlckINODE | tlckENTRY)) == NULL)\n\t\tgoto retry;\n\tdilinelock = (struct linelock *) & ditlck->lock;\n\n\t/*\n\t * copy btree root from in-memory inode to on-disk inode\n\t *\n\t * (tlock is taken from inline B+-tree root in in-memory\n\t * inode when the B+-tree root is updated, which is pointed\n\t * by jfs_ip->blid as well as being on tx tlock list)\n\t *\n\t * further processing of btree root is based on the copy\n\t * in in-memory inode, where txLog() will log from, and,\n\t * for xtree root, txUpdateMap() will update map and reset\n\t * XAD_NEW bit;\n\t */\n\n\tif (S_ISDIR(ip->i_mode) && (lid = jfs_ip->xtlid)) {\n\t\t/*\n\t\t * This is the special xtree inside the directory for storing\n\t\t * the directory table\n\t\t */\n\t\txtpage_t *p, *xp;\n\t\txad_t *xad;\n\n\t\tjfs_ip->xtlid = 0;\n\t\ttlck = lid_to_tlock(lid);\n\t\tassert(tlck->type & tlckXTREE);\n\t\ttlck->type |= tlckBTROOT;\n\t\ttlck->mp = mp;\n\t\tilinelock = (struct linelock *) & tlck->lock;\n\n\t\t/*\n\t\t * copy xtree root from inode to dinode:\n\t\t */\n\t\tp = &jfs_ip->i_xtroot;\n\t\txp = (xtpage_t *) &dp->di_dirtable;\n\t\tlv = ilinelock->lv;\n\t\tfor (n = 0; n < ilinelock->index; n++, lv++) {\n\t\t\tmemcpy(&xp->xad[lv->offset], &p->xad[lv->offset],\n\t\t\t       lv->length << L2XTSLOTSIZE);\n\t\t}\n\n\t\t/* reset on-disk (metadata page) xtree XAD_NEW bit */\n\t\txad = &xp->xad[XTENTRYSTART];\n\t\tfor (n = XTENTRYSTART;\n\t\t     n < le16_to_cpu(xp->header.nextindex); n++, xad++)\n\t\t\tif (xad->flag & (XAD_NEW | XAD_EXTENDED))\n\t\t\t\txad->flag &= ~(XAD_NEW | XAD_EXTENDED);\n\t}\n\n\tif ((lid = jfs_ip->blid) == 0)\n\t\tgoto inlineData;\n\tjfs_ip->blid = 0;\n\n\ttlck = lid_to_tlock(lid);\n\ttype = tlck->type;\n\ttlck->type |= tlckBTROOT;\n\ttlck->mp = mp;\n\tilinelock = (struct linelock *) & tlck->lock;\n\n\t/*\n\t *\tregular file: 16 byte (XAD slot) granularity\n\t */\n\tif (type & tlckXTREE) {\n\t\txtpage_t *p, *xp;\n\t\txad_t *xad;\n\n\t\t/*\n\t\t * copy xtree root from inode to dinode:\n\t\t */\n\t\tp = &jfs_ip->i_xtroot;\n\t\txp = &dp->di_xtroot;\n\t\tlv = ilinelock->lv;\n\t\tfor (n = 0; n < ilinelock->index; n++, lv++) {\n\t\t\tmemcpy(&xp->xad[lv->offset], &p->xad[lv->offset],\n\t\t\t       lv->length << L2XTSLOTSIZE);\n\t\t}\n\n\t\t/* reset on-disk (metadata page) xtree XAD_NEW bit */\n\t\txad = &xp->xad[XTENTRYSTART];\n\t\tfor (n = XTENTRYSTART;\n\t\t     n < le16_to_cpu(xp->header.nextindex); n++, xad++)\n\t\t\tif (xad->flag & (XAD_NEW | XAD_EXTENDED))\n\t\t\t\txad->flag &= ~(XAD_NEW | XAD_EXTENDED);\n\t}\n\t/*\n\t *\tdirectory: 32 byte (directory entry slot) granularity\n\t */\n\telse if (type & tlckDTREE) {\n\t\tdtpage_t *p, *xp;\n\n\t\t/*\n\t\t * copy dtree root from inode to dinode:\n\t\t */\n\t\tp = (dtpage_t *) &jfs_ip->i_dtroot;\n\t\txp = (dtpage_t *) & dp->di_dtroot;\n\t\tlv = ilinelock->lv;\n\t\tfor (n = 0; n < ilinelock->index; n++, lv++) {\n\t\t\tmemcpy(&xp->slot[lv->offset], &p->slot[lv->offset],\n\t\t\t       lv->length << L2DTSLOTSIZE);\n\t\t}\n\t} else {\n\t\tjfs_err(\"diWrite: UFO tlock\");\n\t}\n\n      inlineData:\n\t/*\n\t * copy inline symlink from in-memory inode to on-disk inode\n\t */\n\tif (S_ISLNK(ip->i_mode) && ip->i_size < IDATASIZE) {\n\t\tlv = & dilinelock->lv[dilinelock->index];\n\t\tlv->offset = (dioffset + 2 * 128) >> L2INODESLOTSIZE;\n\t\tlv->length = 2;\n\t\tmemcpy(&dp->di_fastsymlink, jfs_ip->i_inline, IDATASIZE);\n\t\tdilinelock->index++;\n\t}\n\t/*\n\t * copy inline data from in-memory inode to on-disk inode:\n\t * 128 byte slot granularity\n\t */\n\tif (test_cflag(COMMIT_Inlineea, ip)) {\n\t\tlv = & dilinelock->lv[dilinelock->index];\n\t\tlv->offset = (dioffset + 3 * 128) >> L2INODESLOTSIZE;\n\t\tlv->length = 1;\n\t\tmemcpy(&dp->di_inlineea, jfs_ip->i_inline_ea, INODESLOTSIZE);\n\t\tdilinelock->index++;\n\n\t\tclear_cflag(COMMIT_Inlineea, ip);\n\t}\n\n\t/*\n\t *\tlock/copy inode base: 128 byte slot granularity\n\t */\n\tlv = & dilinelock->lv[dilinelock->index];\n\tlv->offset = dioffset >> L2INODESLOTSIZE;\n\tcopy_to_dinode(dp, ip);\n\tif (test_and_clear_cflag(COMMIT_Dirtable, ip)) {\n\t\tlv->length = 2;\n\t\tmemcpy(&dp->di_dirtable, &jfs_ip->i_dirtable, 96);\n\t} else\n\t\tlv->length = 1;\n\tdilinelock->index++;\n\n\t/* release the buffer holding the updated on-disk inode.\n\t * the buffer will be later written by commit processing.\n\t */\n\twrite_metapage(mp);\n\n\treturn (rc);\n}"
  },
  {
    "function_name": "diFreeSpecial",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_imap.c",
    "lines": "562-571",
    "snippet": "void diFreeSpecial(struct inode *ip)\n{\n\tif (ip == NULL) {\n\t\tjfs_err(\"diFreeSpecial called with NULL ip!\");\n\t\treturn;\n\t}\n\tfilemap_write_and_wait(ip->i_mapping);\n\ttruncate_inode_pages(ip->i_mapping, 0);\n\tiput(ip);\n}",
    "includes": [
      "#include \"jfs_debug.h\"",
      "#include \"jfs_superblock.h\"",
      "#include \"jfs_metapage.h\"",
      "#include \"jfs_imap.h\"",
      "#include \"jfs_dmap.h\"",
      "#include \"jfs_dinode.h\"",
      "#include \"jfs_filsys.h\"",
      "#include \"jfs_inode.h\"",
      "#include \"jfs_incore.h\"",
      "#include <linux/slab.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int diAllocAG(struct inomap *, int, bool, struct inode *);",
      "static int diAllocAny(struct inomap *, int, bool, struct inode *);",
      "static int diAllocExt(struct inomap *, int, struct inode *);",
      "static int diAllocIno(struct inomap *, int, struct inode *);",
      "static int copy_from_dinode(struct dinode *, struct inode *);",
      "static void copy_to_dinode(struct dinode *, struct inode *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "iput",
          "args": [
            "ip"
          ],
          "line": 570
        },
        "resolved": true,
        "details": {
          "function_name": "dentry_iput",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "308-327",
          "snippet": "static void dentry_iput(struct dentry * dentry)\n\t__releases(dentry->d_lock)\n\t__releases(dentry->d_inode->i_lock)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tif (inode) {\n\t\tdentry->d_inode = NULL;\n\t\thlist_del_init(&dentry->d_u.d_alias);\n\t\tspin_unlock(&dentry->d_lock);\n\t\tspin_unlock(&inode->i_lock);\n\t\tif (!inode->i_nlink)\n\t\t\tfsnotify_inoderemove(inode);\n\t\tif (dentry->d_op && dentry->d_op->d_iput)\n\t\t\tdentry->d_op->d_iput(dentry, inode);\n\t\telse\n\t\t\tiput(inode);\n\t} else {\n\t\tspin_unlock(&dentry->d_lock);\n\t}\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nstatic void dentry_iput(struct dentry * dentry)\n\t__releases(dentry->d_lock)\n\t__releases(dentry->d_inode->i_lock)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tif (inode) {\n\t\tdentry->d_inode = NULL;\n\t\thlist_del_init(&dentry->d_u.d_alias);\n\t\tspin_unlock(&dentry->d_lock);\n\t\tspin_unlock(&inode->i_lock);\n\t\tif (!inode->i_nlink)\n\t\t\tfsnotify_inoderemove(inode);\n\t\tif (dentry->d_op && dentry->d_op->d_iput)\n\t\t\tdentry->d_op->d_iput(dentry, inode);\n\t\telse\n\t\t\tiput(inode);\n\t} else {\n\t\tspin_unlock(&dentry->d_lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "truncate_inode_pages",
          "args": [
            "ip->i_mapping",
            "0"
          ],
          "line": 569
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "filemap_write_and_wait",
          "args": [
            "ip->i_mapping"
          ],
          "line": 568
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "jfs_err",
          "args": [
            "\"diFreeSpecial called with NULL ip!\""
          ],
          "line": 565
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_imap.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_dinode.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_inode.h\"\n#include \"jfs_incore.h\"\n#include <linux/slab.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n\nstatic int diAllocAG(struct inomap *, int, bool, struct inode *);\nstatic int diAllocAny(struct inomap *, int, bool, struct inode *);\nstatic int diAllocExt(struct inomap *, int, struct inode *);\nstatic int diAllocIno(struct inomap *, int, struct inode *);\nstatic int copy_from_dinode(struct dinode *, struct inode *);\nstatic void copy_to_dinode(struct dinode *, struct inode *);\n\nvoid diFreeSpecial(struct inode *ip)\n{\n\tif (ip == NULL) {\n\t\tjfs_err(\"diFreeSpecial called with NULL ip!\");\n\t\treturn;\n\t}\n\tfilemap_write_and_wait(ip->i_mapping);\n\ttruncate_inode_pages(ip->i_mapping, 0);\n\tiput(ip);\n}"
  },
  {
    "function_name": "diWriteSpecial",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_imap.c",
    "lines": "517-555",
    "snippet": "void diWriteSpecial(struct inode *ip, int secondary)\n{\n\tstruct jfs_sb_info *sbi = JFS_SBI(ip->i_sb);\n\tuint address;\n\tstruct dinode *dp;\n\tino_t inum = ip->i_ino;\n\tstruct metapage *mp;\n\n\tif (secondary)\n\t\taddress = addressPXD(&sbi->ait2) >> sbi->l2nbperpage;\n\telse\n\t\taddress = AITBL_OFF >> L2PSIZE;\n\n\tASSERT(inum < INOSPEREXT);\n\n\taddress += inum >> 3;\t/* 8 inodes per 4K page */\n\n\t/* read the page of fixed disk inode (AIT) in raw mode */\n\tmp = read_metapage(ip, address << sbi->l2nbperpage, PSIZE, 1);\n\tif (mp == NULL) {\n\t\tjfs_err(\"diWriteSpecial: failed to read aggregate inode \"\n\t\t\t\"extent!\");\n\t\treturn;\n\t}\n\n\t/* get the pointer to the disk inode of interest */\n\tdp = (struct dinode *) (mp->data);\n\tdp += inum % 8;\t\t/* 8 inodes per 4K page */\n\n\t/* copy on-disk inode to in-memory inode */\n\tcopy_to_dinode(dp, ip);\n\tmemcpy(&dp->di_xtroot, &JFS_IP(ip)->i_xtroot, 288);\n\n\tif (inum == FILESYSTEM_I)\n\t\tdp->di_gengen = cpu_to_le32(sbi->gengen);\n\n\t/* write the page */\n\twrite_metapage(mp);\n}",
    "includes": [
      "#include \"jfs_debug.h\"",
      "#include \"jfs_superblock.h\"",
      "#include \"jfs_metapage.h\"",
      "#include \"jfs_imap.h\"",
      "#include \"jfs_dmap.h\"",
      "#include \"jfs_dinode.h\"",
      "#include \"jfs_filsys.h\"",
      "#include \"jfs_inode.h\"",
      "#include \"jfs_incore.h\"",
      "#include <linux/slab.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int diAllocAG(struct inomap *, int, bool, struct inode *);",
      "static int diAllocAny(struct inomap *, int, bool, struct inode *);",
      "static int diAllocExt(struct inomap *, int, struct inode *);",
      "static int diAllocIno(struct inomap *, int, struct inode *);",
      "static int diNewIAG(struct inomap *, int *, int, struct metapage **);",
      "static int diIAGRead(struct inomap * imap, int, struct metapage **);",
      "static int copy_from_dinode(struct dinode *, struct inode *);",
      "static void copy_to_dinode(struct dinode *, struct inode *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "write_metapage",
          "args": [
            "mp"
          ],
          "line": 554
        },
        "resolved": true,
        "details": {
          "function_name": "write_metapage",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_metapage.h",
          "lines": "85-89",
          "snippet": "static inline void write_metapage(struct metapage *mp)\n{\n\tset_bit(META_dirty, &mp->flag);\n\trelease_metapage(mp);\n}",
          "includes": [
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [
            "#define META_dirty\t2"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/pagemap.h>\n\n#define META_dirty\t2\n\nstatic inline void write_metapage(struct metapage *mp)\n{\n\tset_bit(META_dirty, &mp->flag);\n\trelease_metapage(mp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "sbi->gengen"
          ],
          "line": 551
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "&dp->di_xtroot",
            "&JFS_IP(ip)->i_xtroot",
            "288"
          ],
          "line": 548
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "JFS_IP",
          "args": [
            "ip"
          ],
          "line": 548
        },
        "resolved": true,
        "details": {
          "function_name": "JFS_IP",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_incore.h",
          "lines": "207-210",
          "snippet": "static inline struct jfs_inode_info *JFS_IP(struct inode *inode)\n{\n\treturn list_entry(inode, struct jfs_inode_info, vfs_inode);\n}",
          "includes": [
            "#include \"jfs_dtree.h\"",
            "#include \"jfs_xtree.h\"",
            "#include \"jfs_types.h\"",
            "#include <linux/bitops.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_dtree.h\"\n#include \"jfs_xtree.h\"\n#include \"jfs_types.h\"\n#include <linux/bitops.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mutex.h>\n\nstatic inline struct jfs_inode_info *JFS_IP(struct inode *inode)\n{\n\treturn list_entry(inode, struct jfs_inode_info, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "copy_to_dinode",
          "args": [
            "dp",
            "ip"
          ],
          "line": 547
        },
        "resolved": true,
        "details": {
          "function_name": "copy_to_dinode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_imap.c",
          "lines": "3130-3178",
          "snippet": "static void copy_to_dinode(struct dinode * dip, struct inode *ip)\n{\n\tstruct jfs_inode_info *jfs_ip = JFS_IP(ip);\n\tstruct jfs_sb_info *sbi = JFS_SBI(ip->i_sb);\n\n\tdip->di_fileset = cpu_to_le32(jfs_ip->fileset);\n\tdip->di_inostamp = cpu_to_le32(sbi->inostamp);\n\tdip->di_number = cpu_to_le32(ip->i_ino);\n\tdip->di_gen = cpu_to_le32(ip->i_generation);\n\tdip->di_size = cpu_to_le64(ip->i_size);\n\tdip->di_nblocks = cpu_to_le64(PBLK2LBLK(ip->i_sb, ip->i_blocks));\n\tdip->di_nlink = cpu_to_le32(ip->i_nlink);\n\tif (!uid_valid(sbi->uid))\n\t\tdip->di_uid = cpu_to_le32(i_uid_read(ip));\n\telse\n\t\tdip->di_uid =cpu_to_le32(from_kuid(&init_user_ns,\n\t\t\t\t\t\t   jfs_ip->saved_uid));\n\tif (!gid_valid(sbi->gid))\n\t\tdip->di_gid = cpu_to_le32(i_gid_read(ip));\n\telse\n\t\tdip->di_gid = cpu_to_le32(from_kgid(&init_user_ns,\n\t\t\t\t\t\t    jfs_ip->saved_gid));\n\tjfs_get_inode_flags(jfs_ip);\n\t/*\n\t * mode2 is only needed for storing the higher order bits.\n\t * Trust i_mode for the lower order ones\n\t */\n\tif (sbi->umask == -1)\n\t\tdip->di_mode = cpu_to_le32((jfs_ip->mode2 & 0xffff0000) |\n\t\t\t\t\t   ip->i_mode);\n\telse /* Leave the original permissions alone */\n\t\tdip->di_mode = cpu_to_le32(jfs_ip->mode2);\n\n\tdip->di_atime.tv_sec = cpu_to_le32(ip->i_atime.tv_sec);\n\tdip->di_atime.tv_nsec = cpu_to_le32(ip->i_atime.tv_nsec);\n\tdip->di_ctime.tv_sec = cpu_to_le32(ip->i_ctime.tv_sec);\n\tdip->di_ctime.tv_nsec = cpu_to_le32(ip->i_ctime.tv_nsec);\n\tdip->di_mtime.tv_sec = cpu_to_le32(ip->i_mtime.tv_sec);\n\tdip->di_mtime.tv_nsec = cpu_to_le32(ip->i_mtime.tv_nsec);\n\tdip->di_ixpxd = jfs_ip->ixpxd;\t/* in-memory pxd's are little-endian */\n\tdip->di_acl = jfs_ip->acl;\t/* as are dxd's */\n\tdip->di_ea = jfs_ip->ea;\n\tdip->di_next_index = cpu_to_le32(jfs_ip->next_index);\n\tdip->di_otime.tv_sec = cpu_to_le32(jfs_ip->otime);\n\tdip->di_otime.tv_nsec = 0;\n\tdip->di_acltype = cpu_to_le32(jfs_ip->acltype);\n\tif (S_ISCHR(ip->i_mode) || S_ISBLK(ip->i_mode))\n\t\tdip->di_rdev = cpu_to_le32(jfs_ip->dev);\n}",
          "includes": [
            "#include \"jfs_debug.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_imap.h\"",
            "#include \"jfs_dmap.h\"",
            "#include \"jfs_dinode.h\"",
            "#include \"jfs_filsys.h\"",
            "#include \"jfs_inode.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/slab.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int diAllocAG(struct inomap *, int, bool, struct inode *);",
            "static int diAllocAny(struct inomap *, int, bool, struct inode *);",
            "static int diAllocExt(struct inomap *, int, struct inode *);",
            "static int diAllocIno(struct inomap *, int, struct inode *);",
            "static int copy_from_dinode(struct dinode *, struct inode *);",
            "static void copy_to_dinode(struct dinode *, struct inode *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_imap.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_dinode.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_inode.h\"\n#include \"jfs_incore.h\"\n#include <linux/slab.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n\nstatic int diAllocAG(struct inomap *, int, bool, struct inode *);\nstatic int diAllocAny(struct inomap *, int, bool, struct inode *);\nstatic int diAllocExt(struct inomap *, int, struct inode *);\nstatic int diAllocIno(struct inomap *, int, struct inode *);\nstatic int copy_from_dinode(struct dinode *, struct inode *);\nstatic void copy_to_dinode(struct dinode *, struct inode *);\n\nstatic void copy_to_dinode(struct dinode * dip, struct inode *ip)\n{\n\tstruct jfs_inode_info *jfs_ip = JFS_IP(ip);\n\tstruct jfs_sb_info *sbi = JFS_SBI(ip->i_sb);\n\n\tdip->di_fileset = cpu_to_le32(jfs_ip->fileset);\n\tdip->di_inostamp = cpu_to_le32(sbi->inostamp);\n\tdip->di_number = cpu_to_le32(ip->i_ino);\n\tdip->di_gen = cpu_to_le32(ip->i_generation);\n\tdip->di_size = cpu_to_le64(ip->i_size);\n\tdip->di_nblocks = cpu_to_le64(PBLK2LBLK(ip->i_sb, ip->i_blocks));\n\tdip->di_nlink = cpu_to_le32(ip->i_nlink);\n\tif (!uid_valid(sbi->uid))\n\t\tdip->di_uid = cpu_to_le32(i_uid_read(ip));\n\telse\n\t\tdip->di_uid =cpu_to_le32(from_kuid(&init_user_ns,\n\t\t\t\t\t\t   jfs_ip->saved_uid));\n\tif (!gid_valid(sbi->gid))\n\t\tdip->di_gid = cpu_to_le32(i_gid_read(ip));\n\telse\n\t\tdip->di_gid = cpu_to_le32(from_kgid(&init_user_ns,\n\t\t\t\t\t\t    jfs_ip->saved_gid));\n\tjfs_get_inode_flags(jfs_ip);\n\t/*\n\t * mode2 is only needed for storing the higher order bits.\n\t * Trust i_mode for the lower order ones\n\t */\n\tif (sbi->umask == -1)\n\t\tdip->di_mode = cpu_to_le32((jfs_ip->mode2 & 0xffff0000) |\n\t\t\t\t\t   ip->i_mode);\n\telse /* Leave the original permissions alone */\n\t\tdip->di_mode = cpu_to_le32(jfs_ip->mode2);\n\n\tdip->di_atime.tv_sec = cpu_to_le32(ip->i_atime.tv_sec);\n\tdip->di_atime.tv_nsec = cpu_to_le32(ip->i_atime.tv_nsec);\n\tdip->di_ctime.tv_sec = cpu_to_le32(ip->i_ctime.tv_sec);\n\tdip->di_ctime.tv_nsec = cpu_to_le32(ip->i_ctime.tv_nsec);\n\tdip->di_mtime.tv_sec = cpu_to_le32(ip->i_mtime.tv_sec);\n\tdip->di_mtime.tv_nsec = cpu_to_le32(ip->i_mtime.tv_nsec);\n\tdip->di_ixpxd = jfs_ip->ixpxd;\t/* in-memory pxd's are little-endian */\n\tdip->di_acl = jfs_ip->acl;\t/* as are dxd's */\n\tdip->di_ea = jfs_ip->ea;\n\tdip->di_next_index = cpu_to_le32(jfs_ip->next_index);\n\tdip->di_otime.tv_sec = cpu_to_le32(jfs_ip->otime);\n\tdip->di_otime.tv_nsec = 0;\n\tdip->di_acltype = cpu_to_le32(jfs_ip->acltype);\n\tif (S_ISCHR(ip->i_mode) || S_ISBLK(ip->i_mode))\n\t\tdip->di_rdev = cpu_to_le32(jfs_ip->dev);\n}"
        }
      },
      {
        "call_info": {
          "callee": "jfs_err",
          "args": [
            "\"diWriteSpecial: failed to read aggregate inode \"\n\t\t\t\"extent!\""
          ],
          "line": 537
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "read_metapage",
          "args": [
            "ip",
            "address << sbi->l2nbperpage",
            "PSIZE",
            "1"
          ],
          "line": 535
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "inum < INOSPEREXT"
          ],
          "line": 530
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "addressPXD",
          "args": [
            "&sbi->ait2"
          ],
          "line": 526
        },
        "resolved": true,
        "details": {
          "function_name": "addressPXD",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_types.h",
          "lines": "91-95",
          "snippet": "static inline __u64 addressPXD(pxd_t *pxd)\n{\n\t__u64 n = le32_to_cpu(pxd->len_addr) & ~0xffffff;\n\treturn (n << 8) + le32_to_cpu(pxd->addr2);\n}",
          "includes": [
            "#include <linux/nls.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/nls.h>\n#include <linux/types.h>\n\nstatic inline __u64 addressPXD(pxd_t *pxd)\n{\n\t__u64 n = le32_to_cpu(pxd->len_addr) & ~0xffffff;\n\treturn (n << 8) + le32_to_cpu(pxd->addr2);\n}"
        }
      },
      {
        "call_info": {
          "callee": "JFS_SBI",
          "args": [
            "ip->i_sb"
          ],
          "line": 519
        },
        "resolved": true,
        "details": {
          "function_name": "JFS_SBI",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_incore.h",
          "lines": "217-220",
          "snippet": "static inline struct jfs_sb_info *JFS_SBI(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"jfs_dtree.h\"",
            "#include \"jfs_xtree.h\"",
            "#include \"jfs_types.h\"",
            "#include <linux/bitops.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_dtree.h\"\n#include \"jfs_xtree.h\"\n#include \"jfs_types.h\"\n#include <linux/bitops.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mutex.h>\n\nstatic inline struct jfs_sb_info *JFS_SBI(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_imap.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_dinode.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_inode.h\"\n#include \"jfs_incore.h\"\n#include <linux/slab.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n\nstatic int diAllocAG(struct inomap *, int, bool, struct inode *);\nstatic int diAllocAny(struct inomap *, int, bool, struct inode *);\nstatic int diAllocExt(struct inomap *, int, struct inode *);\nstatic int diAllocIno(struct inomap *, int, struct inode *);\nstatic int diNewIAG(struct inomap *, int *, int, struct metapage **);\nstatic int diIAGRead(struct inomap * imap, int, struct metapage **);\nstatic int copy_from_dinode(struct dinode *, struct inode *);\nstatic void copy_to_dinode(struct dinode *, struct inode *);\n\nvoid diWriteSpecial(struct inode *ip, int secondary)\n{\n\tstruct jfs_sb_info *sbi = JFS_SBI(ip->i_sb);\n\tuint address;\n\tstruct dinode *dp;\n\tino_t inum = ip->i_ino;\n\tstruct metapage *mp;\n\n\tif (secondary)\n\t\taddress = addressPXD(&sbi->ait2) >> sbi->l2nbperpage;\n\telse\n\t\taddress = AITBL_OFF >> L2PSIZE;\n\n\tASSERT(inum < INOSPEREXT);\n\n\taddress += inum >> 3;\t/* 8 inodes per 4K page */\n\n\t/* read the page of fixed disk inode (AIT) in raw mode */\n\tmp = read_metapage(ip, address << sbi->l2nbperpage, PSIZE, 1);\n\tif (mp == NULL) {\n\t\tjfs_err(\"diWriteSpecial: failed to read aggregate inode \"\n\t\t\t\"extent!\");\n\t\treturn;\n\t}\n\n\t/* get the pointer to the disk inode of interest */\n\tdp = (struct dinode *) (mp->data);\n\tdp += inum % 8;\t\t/* 8 inodes per 4K page */\n\n\t/* copy on-disk inode to in-memory inode */\n\tcopy_to_dinode(dp, ip);\n\tmemcpy(&dp->di_xtroot, &JFS_IP(ip)->i_xtroot, 288);\n\n\tif (inum == FILESYSTEM_I)\n\t\tdp->di_gengen = cpu_to_le32(sbi->gengen);\n\n\t/* write the page */\n\twrite_metapage(mp);\n}"
  },
  {
    "function_name": "diReadSpecial",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_imap.c",
    "lines": "429-503",
    "snippet": "struct inode *diReadSpecial(struct super_block *sb, ino_t inum, int secondary)\n{\n\tstruct jfs_sb_info *sbi = JFS_SBI(sb);\n\tuint address;\n\tstruct dinode *dp;\n\tstruct inode *ip;\n\tstruct metapage *mp;\n\n\tip = new_inode(sb);\n\tif (ip == NULL) {\n\t\tjfs_err(\"diReadSpecial: new_inode returned NULL!\");\n\t\treturn ip;\n\t}\n\n\tif (secondary) {\n\t\taddress = addressPXD(&sbi->ait2) >> sbi->l2nbperpage;\n\t\tJFS_IP(ip)->ipimap = sbi->ipaimap2;\n\t} else {\n\t\taddress = AITBL_OFF >> L2PSIZE;\n\t\tJFS_IP(ip)->ipimap = sbi->ipaimap;\n\t}\n\n\tASSERT(inum < INOSPEREXT);\n\n\tip->i_ino = inum;\n\n\taddress += inum >> 3;\t/* 8 inodes per 4K page */\n\n\t/* read the page of fixed disk inode (AIT) in raw mode */\n\tmp = read_metapage(ip, address << sbi->l2nbperpage, PSIZE, 1);\n\tif (mp == NULL) {\n\t\tset_nlink(ip, 1);\t/* Don't want iput() deleting it */\n\t\tiput(ip);\n\t\treturn (NULL);\n\t}\n\n\t/* get the pointer to the disk inode of interest */\n\tdp = (struct dinode *) (mp->data);\n\tdp += inum % 8;\t\t/* 8 inodes per 4K page */\n\n\t/* copy on-disk inode to in-memory inode */\n\tif ((copy_from_dinode(dp, ip)) != 0) {\n\t\t/* handle bad return by returning NULL for ip */\n\t\tset_nlink(ip, 1);\t/* Don't want iput() deleting it */\n\t\tiput(ip);\n\t\t/* release the page */\n\t\trelease_metapage(mp);\n\t\treturn (NULL);\n\n\t}\n\n\tip->i_mapping->a_ops = &jfs_metapage_aops;\n\tmapping_set_gfp_mask(ip->i_mapping, GFP_NOFS);\n\n\t/* Allocations to metadata inodes should not affect quotas */\n\tip->i_flags |= S_NOQUOTA;\n\n\tif ((inum == FILESYSTEM_I) && (JFS_IP(ip)->ipimap == sbi->ipaimap)) {\n\t\tsbi->gengen = le32_to_cpu(dp->di_gengen);\n\t\tsbi->inostamp = le32_to_cpu(dp->di_inostamp);\n\t}\n\n\t/* release the page */\n\trelease_metapage(mp);\n\n\t/*\n\t * __mark_inode_dirty expects inodes to be hashed.  Since we don't\n\t * want special inodes in the fileset inode space, we make them\n\t * appear hashed, but do not put on any lists.  hlist_del()\n\t * will work fine and require no locking.\n\t */\n\thlist_add_fake(&ip->i_hash);\n\n\treturn (ip);\n}",
    "includes": [
      "#include \"jfs_debug.h\"",
      "#include \"jfs_superblock.h\"",
      "#include \"jfs_metapage.h\"",
      "#include \"jfs_imap.h\"",
      "#include \"jfs_dmap.h\"",
      "#include \"jfs_dinode.h\"",
      "#include \"jfs_filsys.h\"",
      "#include \"jfs_inode.h\"",
      "#include \"jfs_incore.h\"",
      "#include <linux/slab.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int diAllocAG(struct inomap *, int, bool, struct inode *);",
      "static int diAllocAny(struct inomap *, int, bool, struct inode *);",
      "static int diAllocExt(struct inomap *, int, struct inode *);",
      "static int diAllocIno(struct inomap *, int, struct inode *);",
      "static int diNewIAG(struct inomap *, int *, int, struct metapage **);",
      "static int diIAGRead(struct inomap * imap, int, struct metapage **);",
      "static int copy_from_dinode(struct dinode *, struct inode *);",
      "static void copy_to_dinode(struct dinode *, struct inode *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "hlist_add_fake",
          "args": [
            "&ip->i_hash"
          ],
          "line": 500
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "release_metapage",
          "args": [
            "mp"
          ],
          "line": 492
        },
        "resolved": true,
        "details": {
          "function_name": "release_metapage",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_metapage.c",
          "lines": "743-775",
          "snippet": "void release_metapage(struct metapage * mp)\n{\n\tstruct page *page = mp->page;\n\tjfs_info(\"release_metapage: mp = 0x%p, flag = 0x%lx\", mp, mp->flag);\n\n\tBUG_ON(!page);\n\n\tlock_page(page);\n\tunlock_metapage(mp);\n\n\tassert(mp->count);\n\tif (--mp->count || mp->nohomeok) {\n\t\tunlock_page(page);\n\t\tpage_cache_release(page);\n\t\treturn;\n\t}\n\n\tif (test_bit(META_dirty, &mp->flag)) {\n\t\tset_page_dirty(page);\n\t\tif (test_bit(META_sync, &mp->flag)) {\n\t\t\tclear_bit(META_sync, &mp->flag);\n\t\t\twrite_one_page(page, 1);\n\t\t\tlock_page(page); /* write_one_page unlocks the page */\n\t\t}\n\t} else if (mp->lsn)\t/* discard_metapage doesn't remove it */\n\t\tremove_from_logsync(mp);\n\n\t/* Try to keep metapages from using up too much memory */\n\tdrop_metapage(page, mp);\n\n\tunlock_page(page);\n\tpage_cache_release(page);\n}",
          "includes": [
            "#include \"jfs_debug.h\"",
            "#include \"jfs_txnmgr.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_filsys.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/mempool.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/bio.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_txnmgr.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_incore.h\"\n#include <linux/seq_file.h>\n#include <linux/mempool.h>\n#include <linux/buffer_head.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n\nvoid release_metapage(struct metapage * mp)\n{\n\tstruct page *page = mp->page;\n\tjfs_info(\"release_metapage: mp = 0x%p, flag = 0x%lx\", mp, mp->flag);\n\n\tBUG_ON(!page);\n\n\tlock_page(page);\n\tunlock_metapage(mp);\n\n\tassert(mp->count);\n\tif (--mp->count || mp->nohomeok) {\n\t\tunlock_page(page);\n\t\tpage_cache_release(page);\n\t\treturn;\n\t}\n\n\tif (test_bit(META_dirty, &mp->flag)) {\n\t\tset_page_dirty(page);\n\t\tif (test_bit(META_sync, &mp->flag)) {\n\t\t\tclear_bit(META_sync, &mp->flag);\n\t\t\twrite_one_page(page, 1);\n\t\t\tlock_page(page); /* write_one_page unlocks the page */\n\t\t}\n\t} else if (mp->lsn)\t/* discard_metapage doesn't remove it */\n\t\tremove_from_logsync(mp);\n\n\t/* Try to keep metapages from using up too much memory */\n\tdrop_metapage(page, mp);\n\n\tunlock_page(page);\n\tpage_cache_release(page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "dp->di_inostamp"
          ],
          "line": 488
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "JFS_IP",
          "args": [
            "ip"
          ],
          "line": 486
        },
        "resolved": true,
        "details": {
          "function_name": "JFS_IP",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_incore.h",
          "lines": "207-210",
          "snippet": "static inline struct jfs_inode_info *JFS_IP(struct inode *inode)\n{\n\treturn list_entry(inode, struct jfs_inode_info, vfs_inode);\n}",
          "includes": [
            "#include \"jfs_dtree.h\"",
            "#include \"jfs_xtree.h\"",
            "#include \"jfs_types.h\"",
            "#include <linux/bitops.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_dtree.h\"\n#include \"jfs_xtree.h\"\n#include \"jfs_types.h\"\n#include <linux/bitops.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mutex.h>\n\nstatic inline struct jfs_inode_info *JFS_IP(struct inode *inode)\n{\n\treturn list_entry(inode, struct jfs_inode_info, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mapping_set_gfp_mask",
          "args": [
            "ip->i_mapping",
            "GFP_NOFS"
          ],
          "line": 481
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "iput",
          "args": [
            "ip"
          ],
          "line": 473
        },
        "resolved": true,
        "details": {
          "function_name": "dentry_iput",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "308-327",
          "snippet": "static void dentry_iput(struct dentry * dentry)\n\t__releases(dentry->d_lock)\n\t__releases(dentry->d_inode->i_lock)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tif (inode) {\n\t\tdentry->d_inode = NULL;\n\t\thlist_del_init(&dentry->d_u.d_alias);\n\t\tspin_unlock(&dentry->d_lock);\n\t\tspin_unlock(&inode->i_lock);\n\t\tif (!inode->i_nlink)\n\t\t\tfsnotify_inoderemove(inode);\n\t\tif (dentry->d_op && dentry->d_op->d_iput)\n\t\t\tdentry->d_op->d_iput(dentry, inode);\n\t\telse\n\t\t\tiput(inode);\n\t} else {\n\t\tspin_unlock(&dentry->d_lock);\n\t}\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nstatic void dentry_iput(struct dentry * dentry)\n\t__releases(dentry->d_lock)\n\t__releases(dentry->d_inode->i_lock)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tif (inode) {\n\t\tdentry->d_inode = NULL;\n\t\thlist_del_init(&dentry->d_u.d_alias);\n\t\tspin_unlock(&dentry->d_lock);\n\t\tspin_unlock(&inode->i_lock);\n\t\tif (!inode->i_nlink)\n\t\t\tfsnotify_inoderemove(inode);\n\t\tif (dentry->d_op && dentry->d_op->d_iput)\n\t\t\tdentry->d_op->d_iput(dentry, inode);\n\t\telse\n\t\t\tiput(inode);\n\t} else {\n\t\tspin_unlock(&dentry->d_lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_nlink",
          "args": [
            "ip",
            "1"
          ],
          "line": 472
        },
        "resolved": true,
        "details": {
          "function_name": "set_nlink",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "305-316",
          "snippet": "void set_nlink(struct inode *inode, unsigned int nlink)\n{\n\tif (!nlink) {\n\t\tclear_nlink(inode);\n\t} else {\n\t\t/* Yes, some filesystems do change nlink from zero to one */\n\t\tif (inode->i_nlink == 0)\n\t\t\tatomic_long_dec(&inode->i_sb->s_remove_count);\n\n\t\tinode->__i_nlink = nlink;\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid set_nlink(struct inode *inode, unsigned int nlink)\n{\n\tif (!nlink) {\n\t\tclear_nlink(inode);\n\t} else {\n\t\t/* Yes, some filesystems do change nlink from zero to one */\n\t\tif (inode->i_nlink == 0)\n\t\t\tatomic_long_dec(&inode->i_sb->s_remove_count);\n\n\t\tinode->__i_nlink = nlink;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "copy_from_dinode",
          "args": [
            "dp",
            "ip"
          ],
          "line": 470
        },
        "resolved": true,
        "details": {
          "function_name": "copy_from_dinode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_imap.c",
          "lines": "3046-3123",
          "snippet": "static int copy_from_dinode(struct dinode * dip, struct inode *ip)\n{\n\tstruct jfs_inode_info *jfs_ip = JFS_IP(ip);\n\tstruct jfs_sb_info *sbi = JFS_SBI(ip->i_sb);\n\n\tjfs_ip->fileset = le32_to_cpu(dip->di_fileset);\n\tjfs_ip->mode2 = le32_to_cpu(dip->di_mode);\n\tjfs_set_inode_flags(ip);\n\n\tip->i_mode = le32_to_cpu(dip->di_mode) & 0xffff;\n\tif (sbi->umask != -1) {\n\t\tip->i_mode = (ip->i_mode & ~0777) | (0777 & ~sbi->umask);\n\t\t/* For directories, add x permission if r is allowed by umask */\n\t\tif (S_ISDIR(ip->i_mode)) {\n\t\t\tif (ip->i_mode & 0400)\n\t\t\t\tip->i_mode |= 0100;\n\t\t\tif (ip->i_mode & 0040)\n\t\t\t\tip->i_mode |= 0010;\n\t\t\tif (ip->i_mode & 0004)\n\t\t\t\tip->i_mode |= 0001;\n\t\t}\n\t}\n\tset_nlink(ip, le32_to_cpu(dip->di_nlink));\n\n\tjfs_ip->saved_uid = make_kuid(&init_user_ns, le32_to_cpu(dip->di_uid));\n\tif (!uid_valid(sbi->uid))\n\t\tip->i_uid = jfs_ip->saved_uid;\n\telse {\n\t\tip->i_uid = sbi->uid;\n\t}\n\n\tjfs_ip->saved_gid = make_kgid(&init_user_ns, le32_to_cpu(dip->di_gid));\n\tif (!gid_valid(sbi->gid))\n\t\tip->i_gid = jfs_ip->saved_gid;\n\telse {\n\t\tip->i_gid = sbi->gid;\n\t}\n\n\tip->i_size = le64_to_cpu(dip->di_size);\n\tip->i_atime.tv_sec = le32_to_cpu(dip->di_atime.tv_sec);\n\tip->i_atime.tv_nsec = le32_to_cpu(dip->di_atime.tv_nsec);\n\tip->i_mtime.tv_sec = le32_to_cpu(dip->di_mtime.tv_sec);\n\tip->i_mtime.tv_nsec = le32_to_cpu(dip->di_mtime.tv_nsec);\n\tip->i_ctime.tv_sec = le32_to_cpu(dip->di_ctime.tv_sec);\n\tip->i_ctime.tv_nsec = le32_to_cpu(dip->di_ctime.tv_nsec);\n\tip->i_blocks = LBLK2PBLK(ip->i_sb, le64_to_cpu(dip->di_nblocks));\n\tip->i_generation = le32_to_cpu(dip->di_gen);\n\n\tjfs_ip->ixpxd = dip->di_ixpxd;\t/* in-memory pxd's are little-endian */\n\tjfs_ip->acl = dip->di_acl;\t/* as are dxd's */\n\tjfs_ip->ea = dip->di_ea;\n\tjfs_ip->next_index = le32_to_cpu(dip->di_next_index);\n\tjfs_ip->otime = le32_to_cpu(dip->di_otime.tv_sec);\n\tjfs_ip->acltype = le32_to_cpu(dip->di_acltype);\n\n\tif (S_ISCHR(ip->i_mode) || S_ISBLK(ip->i_mode)) {\n\t\tjfs_ip->dev = le32_to_cpu(dip->di_rdev);\n\t\tip->i_rdev = new_decode_dev(jfs_ip->dev);\n\t}\n\n\tif (S_ISDIR(ip->i_mode)) {\n\t\tmemcpy(&jfs_ip->i_dirtable, &dip->di_dirtable, 384);\n\t} else if (S_ISREG(ip->i_mode) || S_ISLNK(ip->i_mode)) {\n\t\tmemcpy(&jfs_ip->i_xtroot, &dip->di_xtroot, 288);\n\t} else\n\t\tmemcpy(&jfs_ip->i_inline_ea, &dip->di_inlineea, 128);\n\n\t/* Zero the in-memory-only stuff */\n\tjfs_ip->cflag = 0;\n\tjfs_ip->btindex = 0;\n\tjfs_ip->btorder = 0;\n\tjfs_ip->bxflag = 0;\n\tjfs_ip->blid = 0;\n\tjfs_ip->atlhead = 0;\n\tjfs_ip->atltail = 0;\n\tjfs_ip->xtlid = 0;\n\treturn (0);\n}",
          "includes": [
            "#include \"jfs_debug.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_imap.h\"",
            "#include \"jfs_dmap.h\"",
            "#include \"jfs_dinode.h\"",
            "#include \"jfs_filsys.h\"",
            "#include \"jfs_inode.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/slab.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int diAllocAG(struct inomap *, int, bool, struct inode *);",
            "static int diAllocAny(struct inomap *, int, bool, struct inode *);",
            "static int diAllocExt(struct inomap *, int, struct inode *);",
            "static int diAllocIno(struct inomap *, int, struct inode *);",
            "static int copy_from_dinode(struct dinode *, struct inode *);",
            "static void copy_to_dinode(struct dinode *, struct inode *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_imap.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_dinode.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_inode.h\"\n#include \"jfs_incore.h\"\n#include <linux/slab.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n\nstatic int diAllocAG(struct inomap *, int, bool, struct inode *);\nstatic int diAllocAny(struct inomap *, int, bool, struct inode *);\nstatic int diAllocExt(struct inomap *, int, struct inode *);\nstatic int diAllocIno(struct inomap *, int, struct inode *);\nstatic int copy_from_dinode(struct dinode *, struct inode *);\nstatic void copy_to_dinode(struct dinode *, struct inode *);\n\nstatic int copy_from_dinode(struct dinode * dip, struct inode *ip)\n{\n\tstruct jfs_inode_info *jfs_ip = JFS_IP(ip);\n\tstruct jfs_sb_info *sbi = JFS_SBI(ip->i_sb);\n\n\tjfs_ip->fileset = le32_to_cpu(dip->di_fileset);\n\tjfs_ip->mode2 = le32_to_cpu(dip->di_mode);\n\tjfs_set_inode_flags(ip);\n\n\tip->i_mode = le32_to_cpu(dip->di_mode) & 0xffff;\n\tif (sbi->umask != -1) {\n\t\tip->i_mode = (ip->i_mode & ~0777) | (0777 & ~sbi->umask);\n\t\t/* For directories, add x permission if r is allowed by umask */\n\t\tif (S_ISDIR(ip->i_mode)) {\n\t\t\tif (ip->i_mode & 0400)\n\t\t\t\tip->i_mode |= 0100;\n\t\t\tif (ip->i_mode & 0040)\n\t\t\t\tip->i_mode |= 0010;\n\t\t\tif (ip->i_mode & 0004)\n\t\t\t\tip->i_mode |= 0001;\n\t\t}\n\t}\n\tset_nlink(ip, le32_to_cpu(dip->di_nlink));\n\n\tjfs_ip->saved_uid = make_kuid(&init_user_ns, le32_to_cpu(dip->di_uid));\n\tif (!uid_valid(sbi->uid))\n\t\tip->i_uid = jfs_ip->saved_uid;\n\telse {\n\t\tip->i_uid = sbi->uid;\n\t}\n\n\tjfs_ip->saved_gid = make_kgid(&init_user_ns, le32_to_cpu(dip->di_gid));\n\tif (!gid_valid(sbi->gid))\n\t\tip->i_gid = jfs_ip->saved_gid;\n\telse {\n\t\tip->i_gid = sbi->gid;\n\t}\n\n\tip->i_size = le64_to_cpu(dip->di_size);\n\tip->i_atime.tv_sec = le32_to_cpu(dip->di_atime.tv_sec);\n\tip->i_atime.tv_nsec = le32_to_cpu(dip->di_atime.tv_nsec);\n\tip->i_mtime.tv_sec = le32_to_cpu(dip->di_mtime.tv_sec);\n\tip->i_mtime.tv_nsec = le32_to_cpu(dip->di_mtime.tv_nsec);\n\tip->i_ctime.tv_sec = le32_to_cpu(dip->di_ctime.tv_sec);\n\tip->i_ctime.tv_nsec = le32_to_cpu(dip->di_ctime.tv_nsec);\n\tip->i_blocks = LBLK2PBLK(ip->i_sb, le64_to_cpu(dip->di_nblocks));\n\tip->i_generation = le32_to_cpu(dip->di_gen);\n\n\tjfs_ip->ixpxd = dip->di_ixpxd;\t/* in-memory pxd's are little-endian */\n\tjfs_ip->acl = dip->di_acl;\t/* as are dxd's */\n\tjfs_ip->ea = dip->di_ea;\n\tjfs_ip->next_index = le32_to_cpu(dip->di_next_index);\n\tjfs_ip->otime = le32_to_cpu(dip->di_otime.tv_sec);\n\tjfs_ip->acltype = le32_to_cpu(dip->di_acltype);\n\n\tif (S_ISCHR(ip->i_mode) || S_ISBLK(ip->i_mode)) {\n\t\tjfs_ip->dev = le32_to_cpu(dip->di_rdev);\n\t\tip->i_rdev = new_decode_dev(jfs_ip->dev);\n\t}\n\n\tif (S_ISDIR(ip->i_mode)) {\n\t\tmemcpy(&jfs_ip->i_dirtable, &dip->di_dirtable, 384);\n\t} else if (S_ISREG(ip->i_mode) || S_ISLNK(ip->i_mode)) {\n\t\tmemcpy(&jfs_ip->i_xtroot, &dip->di_xtroot, 288);\n\t} else\n\t\tmemcpy(&jfs_ip->i_inline_ea, &dip->di_inlineea, 128);\n\n\t/* Zero the in-memory-only stuff */\n\tjfs_ip->cflag = 0;\n\tjfs_ip->btindex = 0;\n\tjfs_ip->btorder = 0;\n\tjfs_ip->bxflag = 0;\n\tjfs_ip->blid = 0;\n\tjfs_ip->atlhead = 0;\n\tjfs_ip->atltail = 0;\n\tjfs_ip->xtlid = 0;\n\treturn (0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "read_metapage",
          "args": [
            "ip",
            "address << sbi->l2nbperpage",
            "PSIZE",
            "1"
          ],
          "line": 458
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "inum < INOSPEREXT"
          ],
          "line": 451
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "addressPXD",
          "args": [
            "&sbi->ait2"
          ],
          "line": 444
        },
        "resolved": true,
        "details": {
          "function_name": "addressPXD",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_types.h",
          "lines": "91-95",
          "snippet": "static inline __u64 addressPXD(pxd_t *pxd)\n{\n\t__u64 n = le32_to_cpu(pxd->len_addr) & ~0xffffff;\n\treturn (n << 8) + le32_to_cpu(pxd->addr2);\n}",
          "includes": [
            "#include <linux/nls.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/nls.h>\n#include <linux/types.h>\n\nstatic inline __u64 addressPXD(pxd_t *pxd)\n{\n\t__u64 n = le32_to_cpu(pxd->len_addr) & ~0xffffff;\n\treturn (n << 8) + le32_to_cpu(pxd->addr2);\n}"
        }
      },
      {
        "call_info": {
          "callee": "jfs_err",
          "args": [
            "\"diReadSpecial: new_inode returned NULL!\""
          ],
          "line": 439
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "new_inode",
          "args": [
            "sb"
          ],
          "line": 437
        },
        "resolved": true,
        "details": {
          "function_name": "unlock_new_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "924-933",
          "snippet": "void unlock_new_inode(struct inode *inode)\n{\n\tlockdep_annotate_inode_mutex_key(inode);\n\tspin_lock(&inode->i_lock);\n\tWARN_ON(!(inode->i_state & I_NEW));\n\tinode->i_state &= ~I_NEW;\n\tsmp_mb();\n\twake_up_bit(&inode->i_state, __I_NEW);\n\tspin_unlock(&inode->i_lock);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid unlock_new_inode(struct inode *inode)\n{\n\tlockdep_annotate_inode_mutex_key(inode);\n\tspin_lock(&inode->i_lock);\n\tWARN_ON(!(inode->i_state & I_NEW));\n\tinode->i_state &= ~I_NEW;\n\tsmp_mb();\n\twake_up_bit(&inode->i_state, __I_NEW);\n\tspin_unlock(&inode->i_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "JFS_SBI",
          "args": [
            "sb"
          ],
          "line": 431
        },
        "resolved": true,
        "details": {
          "function_name": "JFS_SBI",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_incore.h",
          "lines": "217-220",
          "snippet": "static inline struct jfs_sb_info *JFS_SBI(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"jfs_dtree.h\"",
            "#include \"jfs_xtree.h\"",
            "#include \"jfs_types.h\"",
            "#include <linux/bitops.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_dtree.h\"\n#include \"jfs_xtree.h\"\n#include \"jfs_types.h\"\n#include <linux/bitops.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mutex.h>\n\nstatic inline struct jfs_sb_info *JFS_SBI(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_imap.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_dinode.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_inode.h\"\n#include \"jfs_incore.h\"\n#include <linux/slab.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n\nstatic int diAllocAG(struct inomap *, int, bool, struct inode *);\nstatic int diAllocAny(struct inomap *, int, bool, struct inode *);\nstatic int diAllocExt(struct inomap *, int, struct inode *);\nstatic int diAllocIno(struct inomap *, int, struct inode *);\nstatic int diNewIAG(struct inomap *, int *, int, struct metapage **);\nstatic int diIAGRead(struct inomap * imap, int, struct metapage **);\nstatic int copy_from_dinode(struct dinode *, struct inode *);\nstatic void copy_to_dinode(struct dinode *, struct inode *);\n\nstruct inode *diReadSpecial(struct super_block *sb, ino_t inum, int secondary)\n{\n\tstruct jfs_sb_info *sbi = JFS_SBI(sb);\n\tuint address;\n\tstruct dinode *dp;\n\tstruct inode *ip;\n\tstruct metapage *mp;\n\n\tip = new_inode(sb);\n\tif (ip == NULL) {\n\t\tjfs_err(\"diReadSpecial: new_inode returned NULL!\");\n\t\treturn ip;\n\t}\n\n\tif (secondary) {\n\t\taddress = addressPXD(&sbi->ait2) >> sbi->l2nbperpage;\n\t\tJFS_IP(ip)->ipimap = sbi->ipaimap2;\n\t} else {\n\t\taddress = AITBL_OFF >> L2PSIZE;\n\t\tJFS_IP(ip)->ipimap = sbi->ipaimap;\n\t}\n\n\tASSERT(inum < INOSPEREXT);\n\n\tip->i_ino = inum;\n\n\taddress += inum >> 3;\t/* 8 inodes per 4K page */\n\n\t/* read the page of fixed disk inode (AIT) in raw mode */\n\tmp = read_metapage(ip, address << sbi->l2nbperpage, PSIZE, 1);\n\tif (mp == NULL) {\n\t\tset_nlink(ip, 1);\t/* Don't want iput() deleting it */\n\t\tiput(ip);\n\t\treturn (NULL);\n\t}\n\n\t/* get the pointer to the disk inode of interest */\n\tdp = (struct dinode *) (mp->data);\n\tdp += inum % 8;\t\t/* 8 inodes per 4K page */\n\n\t/* copy on-disk inode to in-memory inode */\n\tif ((copy_from_dinode(dp, ip)) != 0) {\n\t\t/* handle bad return by returning NULL for ip */\n\t\tset_nlink(ip, 1);\t/* Don't want iput() deleting it */\n\t\tiput(ip);\n\t\t/* release the page */\n\t\trelease_metapage(mp);\n\t\treturn (NULL);\n\n\t}\n\n\tip->i_mapping->a_ops = &jfs_metapage_aops;\n\tmapping_set_gfp_mask(ip->i_mapping, GFP_NOFS);\n\n\t/* Allocations to metadata inodes should not affect quotas */\n\tip->i_flags |= S_NOQUOTA;\n\n\tif ((inum == FILESYSTEM_I) && (JFS_IP(ip)->ipimap == sbi->ipaimap)) {\n\t\tsbi->gengen = le32_to_cpu(dp->di_gengen);\n\t\tsbi->inostamp = le32_to_cpu(dp->di_inostamp);\n\t}\n\n\t/* release the page */\n\trelease_metapage(mp);\n\n\t/*\n\t * __mark_inode_dirty expects inodes to be hashed.  Since we don't\n\t * want special inodes in the fileset inode space, we make them\n\t * appear hashed, but do not put on any lists.  hlist_del()\n\t * will work fine and require no locking.\n\t */\n\thlist_add_fake(&ip->i_hash);\n\n\treturn (ip);\n}"
  },
  {
    "function_name": "diRead",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_imap.c",
    "lines": "304-404",
    "snippet": "int diRead(struct inode *ip)\n{\n\tstruct jfs_sb_info *sbi = JFS_SBI(ip->i_sb);\n\tint iagno, ino, extno, rc;\n\tstruct inode *ipimap;\n\tstruct dinode *dp;\n\tstruct iag *iagp;\n\tstruct metapage *mp;\n\ts64 blkno, agstart;\n\tstruct inomap *imap;\n\tint block_offset;\n\tint inodes_left;\n\tunsigned long pageno;\n\tint rel_inode;\n\n\tjfs_info(\"diRead: ino = %ld\", ip->i_ino);\n\n\tipimap = sbi->ipimap;\n\tJFS_IP(ip)->ipimap = ipimap;\n\n\t/* determine the iag number for this inode (number) */\n\tiagno = INOTOIAG(ip->i_ino);\n\n\t/* read the iag */\n\timap = JFS_IP(ipimap)->i_imap;\n\tIREAD_LOCK(ipimap, RDWRLOCK_IMAP);\n\trc = diIAGRead(imap, iagno, &mp);\n\tIREAD_UNLOCK(ipimap);\n\tif (rc) {\n\t\tjfs_err(\"diRead: diIAGRead returned %d\", rc);\n\t\treturn (rc);\n\t}\n\n\tiagp = (struct iag *) mp->data;\n\n\t/* determine inode extent that holds the disk inode */\n\tino = ip->i_ino & (INOSPERIAG - 1);\n\textno = ino >> L2INOSPEREXT;\n\n\tif ((lengthPXD(&iagp->inoext[extno]) != imap->im_nbperiext) ||\n\t    (addressPXD(&iagp->inoext[extno]) == 0)) {\n\t\trelease_metapage(mp);\n\t\treturn -ESTALE;\n\t}\n\n\t/* get disk block number of the page within the inode extent\n\t * that holds the disk inode.\n\t */\n\tblkno = INOPBLK(&iagp->inoext[extno], ino, sbi->l2nbperpage);\n\n\t/* get the ag for the iag */\n\tagstart = le64_to_cpu(iagp->agstart);\n\n\trelease_metapage(mp);\n\n\trel_inode = (ino & (INOSPERPAGE - 1));\n\tpageno = blkno >> sbi->l2nbperpage;\n\n\tif ((block_offset = ((u32) blkno & (sbi->nbperpage - 1)))) {\n\t\t/*\n\t\t * OS/2 didn't always align inode extents on page boundaries\n\t\t */\n\t\tinodes_left =\n\t\t     (sbi->nbperpage - block_offset) << sbi->l2niperblk;\n\n\t\tif (rel_inode < inodes_left)\n\t\t\trel_inode += block_offset << sbi->l2niperblk;\n\t\telse {\n\t\t\tpageno += 1;\n\t\t\trel_inode -= inodes_left;\n\t\t}\n\t}\n\n\t/* read the page of disk inode */\n\tmp = read_metapage(ipimap, pageno << sbi->l2nbperpage, PSIZE, 1);\n\tif (!mp) {\n\t\tjfs_err(\"diRead: read_metapage failed\");\n\t\treturn -EIO;\n\t}\n\n\t/* locate the disk inode requested */\n\tdp = (struct dinode *) mp->data;\n\tdp += rel_inode;\n\n\tif (ip->i_ino != le32_to_cpu(dp->di_number)) {\n\t\tjfs_error(ip->i_sb, \"i_ino != di_number\\n\");\n\t\trc = -EIO;\n\t} else if (le32_to_cpu(dp->di_nlink) == 0)\n\t\trc = -ESTALE;\n\telse\n\t\t/* copy the disk inode to the in-memory inode */\n\t\trc = copy_from_dinode(dp, ip);\n\n\trelease_metapage(mp);\n\n\t/* set the ag for the inode */\n\tJFS_IP(ip)->agstart = agstart;\n\tJFS_IP(ip)->active_ag = -1;\n\n\treturn (rc);\n}",
    "includes": [
      "#include \"jfs_debug.h\"",
      "#include \"jfs_superblock.h\"",
      "#include \"jfs_metapage.h\"",
      "#include \"jfs_imap.h\"",
      "#include \"jfs_dmap.h\"",
      "#include \"jfs_dinode.h\"",
      "#include \"jfs_filsys.h\"",
      "#include \"jfs_inode.h\"",
      "#include \"jfs_incore.h\"",
      "#include <linux/slab.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int diAllocAG(struct inomap *, int, bool, struct inode *);",
      "static int diAllocAny(struct inomap *, int, bool, struct inode *);",
      "static int diAllocBit(struct inomap *, struct iag *, int);",
      "static int diAllocExt(struct inomap *, int, struct inode *);",
      "static int diAllocIno(struct inomap *, int, struct inode *);",
      "static int diFindFree(u32, int);",
      "static int diNewExt(struct inomap *, struct iag *, int);",
      "static int diNewIAG(struct inomap *, int *, int, struct metapage **);",
      "static void duplicateIXtree(struct super_block *, s64, int, s64 *);",
      "static int diIAGRead(struct inomap * imap, int, struct metapage **);",
      "static int copy_from_dinode(struct dinode *, struct inode *);",
      "static void copy_to_dinode(struct dinode *, struct inode *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "JFS_IP",
          "args": [
            "ip"
          ],
          "line": 401
        },
        "resolved": true,
        "details": {
          "function_name": "JFS_IP",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_incore.h",
          "lines": "207-210",
          "snippet": "static inline struct jfs_inode_info *JFS_IP(struct inode *inode)\n{\n\treturn list_entry(inode, struct jfs_inode_info, vfs_inode);\n}",
          "includes": [
            "#include \"jfs_dtree.h\"",
            "#include \"jfs_xtree.h\"",
            "#include \"jfs_types.h\"",
            "#include <linux/bitops.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_dtree.h\"\n#include \"jfs_xtree.h\"\n#include \"jfs_types.h\"\n#include <linux/bitops.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mutex.h>\n\nstatic inline struct jfs_inode_info *JFS_IP(struct inode *inode)\n{\n\treturn list_entry(inode, struct jfs_inode_info, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "release_metapage",
          "args": [
            "mp"
          ],
          "line": 397
        },
        "resolved": true,
        "details": {
          "function_name": "release_metapage",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_metapage.c",
          "lines": "743-775",
          "snippet": "void release_metapage(struct metapage * mp)\n{\n\tstruct page *page = mp->page;\n\tjfs_info(\"release_metapage: mp = 0x%p, flag = 0x%lx\", mp, mp->flag);\n\n\tBUG_ON(!page);\n\n\tlock_page(page);\n\tunlock_metapage(mp);\n\n\tassert(mp->count);\n\tif (--mp->count || mp->nohomeok) {\n\t\tunlock_page(page);\n\t\tpage_cache_release(page);\n\t\treturn;\n\t}\n\n\tif (test_bit(META_dirty, &mp->flag)) {\n\t\tset_page_dirty(page);\n\t\tif (test_bit(META_sync, &mp->flag)) {\n\t\t\tclear_bit(META_sync, &mp->flag);\n\t\t\twrite_one_page(page, 1);\n\t\t\tlock_page(page); /* write_one_page unlocks the page */\n\t\t}\n\t} else if (mp->lsn)\t/* discard_metapage doesn't remove it */\n\t\tremove_from_logsync(mp);\n\n\t/* Try to keep metapages from using up too much memory */\n\tdrop_metapage(page, mp);\n\n\tunlock_page(page);\n\tpage_cache_release(page);\n}",
          "includes": [
            "#include \"jfs_debug.h\"",
            "#include \"jfs_txnmgr.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_filsys.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/mempool.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/bio.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_txnmgr.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_incore.h\"\n#include <linux/seq_file.h>\n#include <linux/mempool.h>\n#include <linux/buffer_head.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n\nvoid release_metapage(struct metapage * mp)\n{\n\tstruct page *page = mp->page;\n\tjfs_info(\"release_metapage: mp = 0x%p, flag = 0x%lx\", mp, mp->flag);\n\n\tBUG_ON(!page);\n\n\tlock_page(page);\n\tunlock_metapage(mp);\n\n\tassert(mp->count);\n\tif (--mp->count || mp->nohomeok) {\n\t\tunlock_page(page);\n\t\tpage_cache_release(page);\n\t\treturn;\n\t}\n\n\tif (test_bit(META_dirty, &mp->flag)) {\n\t\tset_page_dirty(page);\n\t\tif (test_bit(META_sync, &mp->flag)) {\n\t\t\tclear_bit(META_sync, &mp->flag);\n\t\t\twrite_one_page(page, 1);\n\t\t\tlock_page(page); /* write_one_page unlocks the page */\n\t\t}\n\t} else if (mp->lsn)\t/* discard_metapage doesn't remove it */\n\t\tremove_from_logsync(mp);\n\n\t/* Try to keep metapages from using up too much memory */\n\tdrop_metapage(page, mp);\n\n\tunlock_page(page);\n\tpage_cache_release(page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "copy_from_dinode",
          "args": [
            "dp",
            "ip"
          ],
          "line": 395
        },
        "resolved": true,
        "details": {
          "function_name": "copy_from_dinode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_imap.c",
          "lines": "3046-3123",
          "snippet": "static int copy_from_dinode(struct dinode * dip, struct inode *ip)\n{\n\tstruct jfs_inode_info *jfs_ip = JFS_IP(ip);\n\tstruct jfs_sb_info *sbi = JFS_SBI(ip->i_sb);\n\n\tjfs_ip->fileset = le32_to_cpu(dip->di_fileset);\n\tjfs_ip->mode2 = le32_to_cpu(dip->di_mode);\n\tjfs_set_inode_flags(ip);\n\n\tip->i_mode = le32_to_cpu(dip->di_mode) & 0xffff;\n\tif (sbi->umask != -1) {\n\t\tip->i_mode = (ip->i_mode & ~0777) | (0777 & ~sbi->umask);\n\t\t/* For directories, add x permission if r is allowed by umask */\n\t\tif (S_ISDIR(ip->i_mode)) {\n\t\t\tif (ip->i_mode & 0400)\n\t\t\t\tip->i_mode |= 0100;\n\t\t\tif (ip->i_mode & 0040)\n\t\t\t\tip->i_mode |= 0010;\n\t\t\tif (ip->i_mode & 0004)\n\t\t\t\tip->i_mode |= 0001;\n\t\t}\n\t}\n\tset_nlink(ip, le32_to_cpu(dip->di_nlink));\n\n\tjfs_ip->saved_uid = make_kuid(&init_user_ns, le32_to_cpu(dip->di_uid));\n\tif (!uid_valid(sbi->uid))\n\t\tip->i_uid = jfs_ip->saved_uid;\n\telse {\n\t\tip->i_uid = sbi->uid;\n\t}\n\n\tjfs_ip->saved_gid = make_kgid(&init_user_ns, le32_to_cpu(dip->di_gid));\n\tif (!gid_valid(sbi->gid))\n\t\tip->i_gid = jfs_ip->saved_gid;\n\telse {\n\t\tip->i_gid = sbi->gid;\n\t}\n\n\tip->i_size = le64_to_cpu(dip->di_size);\n\tip->i_atime.tv_sec = le32_to_cpu(dip->di_atime.tv_sec);\n\tip->i_atime.tv_nsec = le32_to_cpu(dip->di_atime.tv_nsec);\n\tip->i_mtime.tv_sec = le32_to_cpu(dip->di_mtime.tv_sec);\n\tip->i_mtime.tv_nsec = le32_to_cpu(dip->di_mtime.tv_nsec);\n\tip->i_ctime.tv_sec = le32_to_cpu(dip->di_ctime.tv_sec);\n\tip->i_ctime.tv_nsec = le32_to_cpu(dip->di_ctime.tv_nsec);\n\tip->i_blocks = LBLK2PBLK(ip->i_sb, le64_to_cpu(dip->di_nblocks));\n\tip->i_generation = le32_to_cpu(dip->di_gen);\n\n\tjfs_ip->ixpxd = dip->di_ixpxd;\t/* in-memory pxd's are little-endian */\n\tjfs_ip->acl = dip->di_acl;\t/* as are dxd's */\n\tjfs_ip->ea = dip->di_ea;\n\tjfs_ip->next_index = le32_to_cpu(dip->di_next_index);\n\tjfs_ip->otime = le32_to_cpu(dip->di_otime.tv_sec);\n\tjfs_ip->acltype = le32_to_cpu(dip->di_acltype);\n\n\tif (S_ISCHR(ip->i_mode) || S_ISBLK(ip->i_mode)) {\n\t\tjfs_ip->dev = le32_to_cpu(dip->di_rdev);\n\t\tip->i_rdev = new_decode_dev(jfs_ip->dev);\n\t}\n\n\tif (S_ISDIR(ip->i_mode)) {\n\t\tmemcpy(&jfs_ip->i_dirtable, &dip->di_dirtable, 384);\n\t} else if (S_ISREG(ip->i_mode) || S_ISLNK(ip->i_mode)) {\n\t\tmemcpy(&jfs_ip->i_xtroot, &dip->di_xtroot, 288);\n\t} else\n\t\tmemcpy(&jfs_ip->i_inline_ea, &dip->di_inlineea, 128);\n\n\t/* Zero the in-memory-only stuff */\n\tjfs_ip->cflag = 0;\n\tjfs_ip->btindex = 0;\n\tjfs_ip->btorder = 0;\n\tjfs_ip->bxflag = 0;\n\tjfs_ip->blid = 0;\n\tjfs_ip->atlhead = 0;\n\tjfs_ip->atltail = 0;\n\tjfs_ip->xtlid = 0;\n\treturn (0);\n}",
          "includes": [
            "#include \"jfs_debug.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_imap.h\"",
            "#include \"jfs_dmap.h\"",
            "#include \"jfs_dinode.h\"",
            "#include \"jfs_filsys.h\"",
            "#include \"jfs_inode.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/slab.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int diAllocAG(struct inomap *, int, bool, struct inode *);",
            "static int diAllocAny(struct inomap *, int, bool, struct inode *);",
            "static int diAllocExt(struct inomap *, int, struct inode *);",
            "static int diAllocIno(struct inomap *, int, struct inode *);",
            "static int copy_from_dinode(struct dinode *, struct inode *);",
            "static void copy_to_dinode(struct dinode *, struct inode *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_imap.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_dinode.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_inode.h\"\n#include \"jfs_incore.h\"\n#include <linux/slab.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n\nstatic int diAllocAG(struct inomap *, int, bool, struct inode *);\nstatic int diAllocAny(struct inomap *, int, bool, struct inode *);\nstatic int diAllocExt(struct inomap *, int, struct inode *);\nstatic int diAllocIno(struct inomap *, int, struct inode *);\nstatic int copy_from_dinode(struct dinode *, struct inode *);\nstatic void copy_to_dinode(struct dinode *, struct inode *);\n\nstatic int copy_from_dinode(struct dinode * dip, struct inode *ip)\n{\n\tstruct jfs_inode_info *jfs_ip = JFS_IP(ip);\n\tstruct jfs_sb_info *sbi = JFS_SBI(ip->i_sb);\n\n\tjfs_ip->fileset = le32_to_cpu(dip->di_fileset);\n\tjfs_ip->mode2 = le32_to_cpu(dip->di_mode);\n\tjfs_set_inode_flags(ip);\n\n\tip->i_mode = le32_to_cpu(dip->di_mode) & 0xffff;\n\tif (sbi->umask != -1) {\n\t\tip->i_mode = (ip->i_mode & ~0777) | (0777 & ~sbi->umask);\n\t\t/* For directories, add x permission if r is allowed by umask */\n\t\tif (S_ISDIR(ip->i_mode)) {\n\t\t\tif (ip->i_mode & 0400)\n\t\t\t\tip->i_mode |= 0100;\n\t\t\tif (ip->i_mode & 0040)\n\t\t\t\tip->i_mode |= 0010;\n\t\t\tif (ip->i_mode & 0004)\n\t\t\t\tip->i_mode |= 0001;\n\t\t}\n\t}\n\tset_nlink(ip, le32_to_cpu(dip->di_nlink));\n\n\tjfs_ip->saved_uid = make_kuid(&init_user_ns, le32_to_cpu(dip->di_uid));\n\tif (!uid_valid(sbi->uid))\n\t\tip->i_uid = jfs_ip->saved_uid;\n\telse {\n\t\tip->i_uid = sbi->uid;\n\t}\n\n\tjfs_ip->saved_gid = make_kgid(&init_user_ns, le32_to_cpu(dip->di_gid));\n\tif (!gid_valid(sbi->gid))\n\t\tip->i_gid = jfs_ip->saved_gid;\n\telse {\n\t\tip->i_gid = sbi->gid;\n\t}\n\n\tip->i_size = le64_to_cpu(dip->di_size);\n\tip->i_atime.tv_sec = le32_to_cpu(dip->di_atime.tv_sec);\n\tip->i_atime.tv_nsec = le32_to_cpu(dip->di_atime.tv_nsec);\n\tip->i_mtime.tv_sec = le32_to_cpu(dip->di_mtime.tv_sec);\n\tip->i_mtime.tv_nsec = le32_to_cpu(dip->di_mtime.tv_nsec);\n\tip->i_ctime.tv_sec = le32_to_cpu(dip->di_ctime.tv_sec);\n\tip->i_ctime.tv_nsec = le32_to_cpu(dip->di_ctime.tv_nsec);\n\tip->i_blocks = LBLK2PBLK(ip->i_sb, le64_to_cpu(dip->di_nblocks));\n\tip->i_generation = le32_to_cpu(dip->di_gen);\n\n\tjfs_ip->ixpxd = dip->di_ixpxd;\t/* in-memory pxd's are little-endian */\n\tjfs_ip->acl = dip->di_acl;\t/* as are dxd's */\n\tjfs_ip->ea = dip->di_ea;\n\tjfs_ip->next_index = le32_to_cpu(dip->di_next_index);\n\tjfs_ip->otime = le32_to_cpu(dip->di_otime.tv_sec);\n\tjfs_ip->acltype = le32_to_cpu(dip->di_acltype);\n\n\tif (S_ISCHR(ip->i_mode) || S_ISBLK(ip->i_mode)) {\n\t\tjfs_ip->dev = le32_to_cpu(dip->di_rdev);\n\t\tip->i_rdev = new_decode_dev(jfs_ip->dev);\n\t}\n\n\tif (S_ISDIR(ip->i_mode)) {\n\t\tmemcpy(&jfs_ip->i_dirtable, &dip->di_dirtable, 384);\n\t} else if (S_ISREG(ip->i_mode) || S_ISLNK(ip->i_mode)) {\n\t\tmemcpy(&jfs_ip->i_xtroot, &dip->di_xtroot, 288);\n\t} else\n\t\tmemcpy(&jfs_ip->i_inline_ea, &dip->di_inlineea, 128);\n\n\t/* Zero the in-memory-only stuff */\n\tjfs_ip->cflag = 0;\n\tjfs_ip->btindex = 0;\n\tjfs_ip->btorder = 0;\n\tjfs_ip->bxflag = 0;\n\tjfs_ip->blid = 0;\n\tjfs_ip->atlhead = 0;\n\tjfs_ip->atltail = 0;\n\tjfs_ip->xtlid = 0;\n\treturn (0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "dp->di_nlink"
          ],
          "line": 391
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "jfs_error",
          "args": [
            "ip->i_sb",
            "\"i_ino != di_number\\n\""
          ],
          "line": 389
        },
        "resolved": true,
        "details": {
          "function_name": "jfs_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/super.c",
          "lines": "95-111",
          "snippet": "void jfs_error(struct super_block *sb, const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tva_start(args, fmt);\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tpr_err(\"ERROR: (device %s): %pf: %pV\\n\",\n\t       sb->s_id, __builtin_return_address(0), &vaf);\n\n\tva_end(args);\n\n\tjfs_handle_error(sb);\n}",
          "includes": [
            "#include \"jfs_xattr.h\"",
            "#include \"jfs_debug.h\"",
            "#include \"jfs_acl.h\"",
            "#include \"jfs_imap.h\"",
            "#include \"jfs_dmap.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_inode.h\"",
            "#include \"jfs_filsys.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/blkdev.h>",
            "#include <linux/seq_file.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/crc32.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/mount.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/vfs.h>",
            "#include <linux/completion.h>",
            "#include <linux/parser.h>",
            "#include <linux/module.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_xattr.h\"\n#include \"jfs_debug.h\"\n#include \"jfs_acl.h\"\n#include \"jfs_imap.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_inode.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_incore.h\"\n#include <linux/blkdev.h>\n#include <linux/seq_file.h>\n#include <asm/uaccess.h>\n#include <linux/slab.h>\n#include <linux/crc32.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/posix_acl.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/mount.h>\n#include <linux/quotaops.h>\n#include <linux/vfs.h>\n#include <linux/completion.h>\n#include <linux/parser.h>\n#include <linux/module.h>\n#include <linux/fs.h>\n\nvoid jfs_error(struct super_block *sb, const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tva_start(args, fmt);\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tpr_err(\"ERROR: (device %s): %pf: %pV\\n\",\n\t       sb->s_id, __builtin_return_address(0), &vaf);\n\n\tva_end(args);\n\n\tjfs_handle_error(sb);\n}"
        }
      },
      {
        "call_info": {
          "callee": "jfs_err",
          "args": [
            "\"diRead: read_metapage failed\""
          ],
          "line": 380
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "read_metapage",
          "args": [
            "ipimap",
            "pageno << sbi->l2nbperpage",
            "PSIZE",
            "1"
          ],
          "line": 378
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le64_to_cpu",
          "args": [
            "iagp->agstart"
          ],
          "line": 355
        },
        "resolved": true,
        "details": {
          "function_name": "sle64_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "58-61",
          "snippet": "static inline s64 sle64_to_cpup(sle64 *x)\n{\n\treturn le64_to_cpu(*(__force le64*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s64 sle64_to_cpup(sle64 *x)\n{\n\treturn le64_to_cpu(*(__force le64*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "INOPBLK",
          "args": [
            "&iagp->inoext[extno]",
            "ino",
            "sbi->l2nbperpage"
          ],
          "line": 352
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "addressPXD",
          "args": [
            "&iagp->inoext[extno]"
          ],
          "line": 344
        },
        "resolved": true,
        "details": {
          "function_name": "addressPXD",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_types.h",
          "lines": "91-95",
          "snippet": "static inline __u64 addressPXD(pxd_t *pxd)\n{\n\t__u64 n = le32_to_cpu(pxd->len_addr) & ~0xffffff;\n\treturn (n << 8) + le32_to_cpu(pxd->addr2);\n}",
          "includes": [
            "#include <linux/nls.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/nls.h>\n#include <linux/types.h>\n\nstatic inline __u64 addressPXD(pxd_t *pxd)\n{\n\t__u64 n = le32_to_cpu(pxd->len_addr) & ~0xffffff;\n\treturn (n << 8) + le32_to_cpu(pxd->addr2);\n}"
        }
      },
      {
        "call_info": {
          "callee": "lengthPXD",
          "args": [
            "&iagp->inoext[extno]"
          ],
          "line": 343
        },
        "resolved": true,
        "details": {
          "function_name": "lengthPXD",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_types.h",
          "lines": "86-89",
          "snippet": "static inline __u32 lengthPXD(pxd_t *pxd)\n{\n\treturn le32_to_cpu((pxd)->len_addr) & 0xffffff;\n}",
          "includes": [
            "#include <linux/nls.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/nls.h>\n#include <linux/types.h>\n\nstatic inline __u32 lengthPXD(pxd_t *pxd)\n{\n\treturn le32_to_cpu((pxd)->len_addr) & 0xffffff;\n}"
        }
      },
      {
        "call_info": {
          "callee": "IREAD_UNLOCK",
          "args": [
            "ipimap"
          ],
          "line": 331
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "diIAGRead",
          "args": [
            "imap",
            "iagno",
            "&mp"
          ],
          "line": 330
        },
        "resolved": true,
        "details": {
          "function_name": "diIAGRead",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_imap.c",
          "lines": "2675-2690",
          "snippet": "static int diIAGRead(struct inomap * imap, int iagno, struct metapage ** mpp)\n{\n\tstruct inode *ipimap = imap->im_ipimap;\n\ts64 blkno;\n\n\t/* compute the logical block number of the iag. */\n\tblkno = IAGTOLBLK(iagno, JFS_SBI(ipimap->i_sb)->l2nbperpage);\n\n\t/* read the iag. */\n\t*mpp = read_metapage(ipimap, blkno, PSIZE, 0);\n\tif (*mpp == NULL) {\n\t\treturn -EIO;\n\t}\n\n\treturn (0);\n}",
          "includes": [
            "#include \"jfs_debug.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_imap.h\"",
            "#include \"jfs_dmap.h\"",
            "#include \"jfs_dinode.h\"",
            "#include \"jfs_filsys.h\"",
            "#include \"jfs_inode.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/slab.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int diAllocAG(struct inomap *, int, bool, struct inode *);",
            "static int diAllocAny(struct inomap *, int, bool, struct inode *);",
            "static int diAllocBit(struct inomap *, struct iag *, int);",
            "static int diAllocExt(struct inomap *, int, struct inode *);",
            "static int diAllocIno(struct inomap *, int, struct inode *);",
            "static int diNewExt(struct inomap *, struct iag *, int);",
            "static int diNewIAG(struct inomap *, int *, int, struct metapage **);",
            "static void duplicateIXtree(struct super_block *, s64, int, s64 *);",
            "static int diIAGRead(struct inomap * imap, int, struct metapage **);",
            "static int copy_from_dinode(struct dinode *, struct inode *);",
            "static void copy_to_dinode(struct dinode *, struct inode *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_imap.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_dinode.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_inode.h\"\n#include \"jfs_incore.h\"\n#include <linux/slab.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n\nstatic int diAllocAG(struct inomap *, int, bool, struct inode *);\nstatic int diAllocAny(struct inomap *, int, bool, struct inode *);\nstatic int diAllocBit(struct inomap *, struct iag *, int);\nstatic int diAllocExt(struct inomap *, int, struct inode *);\nstatic int diAllocIno(struct inomap *, int, struct inode *);\nstatic int diNewExt(struct inomap *, struct iag *, int);\nstatic int diNewIAG(struct inomap *, int *, int, struct metapage **);\nstatic void duplicateIXtree(struct super_block *, s64, int, s64 *);\nstatic int diIAGRead(struct inomap * imap, int, struct metapage **);\nstatic int copy_from_dinode(struct dinode *, struct inode *);\nstatic void copy_to_dinode(struct dinode *, struct inode *);\n\nstatic int diIAGRead(struct inomap * imap, int iagno, struct metapage ** mpp)\n{\n\tstruct inode *ipimap = imap->im_ipimap;\n\ts64 blkno;\n\n\t/* compute the logical block number of the iag. */\n\tblkno = IAGTOLBLK(iagno, JFS_SBI(ipimap->i_sb)->l2nbperpage);\n\n\t/* read the iag. */\n\t*mpp = read_metapage(ipimap, blkno, PSIZE, 0);\n\tif (*mpp == NULL) {\n\t\treturn -EIO;\n\t}\n\n\treturn (0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "IREAD_LOCK",
          "args": [
            "ipimap",
            "RDWRLOCK_IMAP"
          ],
          "line": 329
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INOTOIAG",
          "args": [
            "ip->i_ino"
          ],
          "line": 325
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "jfs_info",
          "args": [
            "\"diRead: ino = %ld\"",
            "ip->i_ino"
          ],
          "line": 319
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "JFS_SBI",
          "args": [
            "ip->i_sb"
          ],
          "line": 306
        },
        "resolved": true,
        "details": {
          "function_name": "JFS_SBI",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_incore.h",
          "lines": "217-220",
          "snippet": "static inline struct jfs_sb_info *JFS_SBI(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"jfs_dtree.h\"",
            "#include \"jfs_xtree.h\"",
            "#include \"jfs_types.h\"",
            "#include <linux/bitops.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_dtree.h\"\n#include \"jfs_xtree.h\"\n#include \"jfs_types.h\"\n#include <linux/bitops.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mutex.h>\n\nstatic inline struct jfs_sb_info *JFS_SBI(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_imap.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_dinode.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_inode.h\"\n#include \"jfs_incore.h\"\n#include <linux/slab.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n\nstatic int diAllocAG(struct inomap *, int, bool, struct inode *);\nstatic int diAllocAny(struct inomap *, int, bool, struct inode *);\nstatic int diAllocBit(struct inomap *, struct iag *, int);\nstatic int diAllocExt(struct inomap *, int, struct inode *);\nstatic int diAllocIno(struct inomap *, int, struct inode *);\nstatic int diFindFree(u32, int);\nstatic int diNewExt(struct inomap *, struct iag *, int);\nstatic int diNewIAG(struct inomap *, int *, int, struct metapage **);\nstatic void duplicateIXtree(struct super_block *, s64, int, s64 *);\nstatic int diIAGRead(struct inomap * imap, int, struct metapage **);\nstatic int copy_from_dinode(struct dinode *, struct inode *);\nstatic void copy_to_dinode(struct dinode *, struct inode *);\n\nint diRead(struct inode *ip)\n{\n\tstruct jfs_sb_info *sbi = JFS_SBI(ip->i_sb);\n\tint iagno, ino, extno, rc;\n\tstruct inode *ipimap;\n\tstruct dinode *dp;\n\tstruct iag *iagp;\n\tstruct metapage *mp;\n\ts64 blkno, agstart;\n\tstruct inomap *imap;\n\tint block_offset;\n\tint inodes_left;\n\tunsigned long pageno;\n\tint rel_inode;\n\n\tjfs_info(\"diRead: ino = %ld\", ip->i_ino);\n\n\tipimap = sbi->ipimap;\n\tJFS_IP(ip)->ipimap = ipimap;\n\n\t/* determine the iag number for this inode (number) */\n\tiagno = INOTOIAG(ip->i_ino);\n\n\t/* read the iag */\n\timap = JFS_IP(ipimap)->i_imap;\n\tIREAD_LOCK(ipimap, RDWRLOCK_IMAP);\n\trc = diIAGRead(imap, iagno, &mp);\n\tIREAD_UNLOCK(ipimap);\n\tif (rc) {\n\t\tjfs_err(\"diRead: diIAGRead returned %d\", rc);\n\t\treturn (rc);\n\t}\n\n\tiagp = (struct iag *) mp->data;\n\n\t/* determine inode extent that holds the disk inode */\n\tino = ip->i_ino & (INOSPERIAG - 1);\n\textno = ino >> L2INOSPEREXT;\n\n\tif ((lengthPXD(&iagp->inoext[extno]) != imap->im_nbperiext) ||\n\t    (addressPXD(&iagp->inoext[extno]) == 0)) {\n\t\trelease_metapage(mp);\n\t\treturn -ESTALE;\n\t}\n\n\t/* get disk block number of the page within the inode extent\n\t * that holds the disk inode.\n\t */\n\tblkno = INOPBLK(&iagp->inoext[extno], ino, sbi->l2nbperpage);\n\n\t/* get the ag for the iag */\n\tagstart = le64_to_cpu(iagp->agstart);\n\n\trelease_metapage(mp);\n\n\trel_inode = (ino & (INOSPERPAGE - 1));\n\tpageno = blkno >> sbi->l2nbperpage;\n\n\tif ((block_offset = ((u32) blkno & (sbi->nbperpage - 1)))) {\n\t\t/*\n\t\t * OS/2 didn't always align inode extents on page boundaries\n\t\t */\n\t\tinodes_left =\n\t\t     (sbi->nbperpage - block_offset) << sbi->l2niperblk;\n\n\t\tif (rel_inode < inodes_left)\n\t\t\trel_inode += block_offset << sbi->l2niperblk;\n\t\telse {\n\t\t\tpageno += 1;\n\t\t\trel_inode -= inodes_left;\n\t\t}\n\t}\n\n\t/* read the page of disk inode */\n\tmp = read_metapage(ipimap, pageno << sbi->l2nbperpage, PSIZE, 1);\n\tif (!mp) {\n\t\tjfs_err(\"diRead: read_metapage failed\");\n\t\treturn -EIO;\n\t}\n\n\t/* locate the disk inode requested */\n\tdp = (struct dinode *) mp->data;\n\tdp += rel_inode;\n\n\tif (ip->i_ino != le32_to_cpu(dp->di_number)) {\n\t\tjfs_error(ip->i_sb, \"i_ino != di_number\\n\");\n\t\trc = -EIO;\n\t} else if (le32_to_cpu(dp->di_nlink) == 0)\n\t\trc = -ESTALE;\n\telse\n\t\t/* copy the disk inode to the in-memory inode */\n\t\trc = copy_from_dinode(dp, ip);\n\n\trelease_metapage(mp);\n\n\t/* set the ag for the inode */\n\tJFS_IP(ip)->agstart = agstart;\n\tJFS_IP(ip)->active_ag = -1;\n\n\treturn (rc);\n}"
  },
  {
    "function_name": "diSync",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_imap.c",
    "lines": "219-268",
    "snippet": "int diSync(struct inode *ipimap)\n{\n\tstruct dinomap_disk *dinom_le;\n\tstruct inomap *imp = JFS_IP(ipimap)->i_imap;\n\tstruct metapage *mp;\n\tint index;\n\n\t/*\n\t * write imap global conrol page\n\t */\n\t/* read the on-disk inode map control structure */\n\tmp = get_metapage(ipimap,\n\t\t\t  IMAPBLKNO << JFS_SBI(ipimap->i_sb)->l2nbperpage,\n\t\t\t  PSIZE, 0);\n\tif (mp == NULL) {\n\t\tjfs_err(\"diSync: get_metapage failed!\");\n\t\treturn -EIO;\n\t}\n\n\t/* copy the in-memory version to the on-disk version */\n\tdinom_le = (struct dinomap_disk *) mp->data;\n\tdinom_le->in_freeiag = cpu_to_le32(imp->im_freeiag);\n\tdinom_le->in_nextiag = cpu_to_le32(imp->im_nextiag);\n\tdinom_le->in_numinos = cpu_to_le32(atomic_read(&imp->im_numinos));\n\tdinom_le->in_numfree = cpu_to_le32(atomic_read(&imp->im_numfree));\n\tdinom_le->in_nbperiext = cpu_to_le32(imp->im_nbperiext);\n\tdinom_le->in_l2nbperiext = cpu_to_le32(imp->im_l2nbperiext);\n\tfor (index = 0; index < MAXAG; index++) {\n\t\tdinom_le->in_agctl[index].inofree =\n\t\t    cpu_to_le32(imp->im_agctl[index].inofree);\n\t\tdinom_le->in_agctl[index].extfree =\n\t\t    cpu_to_le32(imp->im_agctl[index].extfree);\n\t\tdinom_le->in_agctl[index].numinos =\n\t\t    cpu_to_le32(imp->im_agctl[index].numinos);\n\t\tdinom_le->in_agctl[index].numfree =\n\t\t    cpu_to_le32(imp->im_agctl[index].numfree);\n\t}\n\n\t/* write out the control structure */\n\twrite_metapage(mp);\n\n\t/*\n\t * write out dirty pages of imap\n\t */\n\tfilemap_write_and_wait(ipimap->i_mapping);\n\n\tdiWriteSpecial(ipimap, 0);\n\n\treturn (0);\n}",
    "includes": [
      "#include \"jfs_debug.h\"",
      "#include \"jfs_superblock.h\"",
      "#include \"jfs_metapage.h\"",
      "#include \"jfs_imap.h\"",
      "#include \"jfs_dmap.h\"",
      "#include \"jfs_dinode.h\"",
      "#include \"jfs_filsys.h\"",
      "#include \"jfs_inode.h\"",
      "#include \"jfs_incore.h\"",
      "#include <linux/slab.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int diAllocAG(struct inomap *, int, bool, struct inode *);",
      "static int diAllocAny(struct inomap *, int, bool, struct inode *);",
      "static int diAllocExt(struct inomap *, int, struct inode *);",
      "static int diAllocIno(struct inomap *, int, struct inode *);",
      "static int diNewIAG(struct inomap *, int *, int, struct metapage **);",
      "static int diIAGRead(struct inomap * imap, int, struct metapage **);",
      "static int copy_from_dinode(struct dinode *, struct inode *);",
      "static void copy_to_dinode(struct dinode *, struct inode *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "diWriteSpecial",
          "args": [
            "ipimap",
            "0"
          ],
          "line": 265
        },
        "resolved": true,
        "details": {
          "function_name": "diWriteSpecial",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_imap.c",
          "lines": "517-555",
          "snippet": "void diWriteSpecial(struct inode *ip, int secondary)\n{\n\tstruct jfs_sb_info *sbi = JFS_SBI(ip->i_sb);\n\tuint address;\n\tstruct dinode *dp;\n\tino_t inum = ip->i_ino;\n\tstruct metapage *mp;\n\n\tif (secondary)\n\t\taddress = addressPXD(&sbi->ait2) >> sbi->l2nbperpage;\n\telse\n\t\taddress = AITBL_OFF >> L2PSIZE;\n\n\tASSERT(inum < INOSPEREXT);\n\n\taddress += inum >> 3;\t/* 8 inodes per 4K page */\n\n\t/* read the page of fixed disk inode (AIT) in raw mode */\n\tmp = read_metapage(ip, address << sbi->l2nbperpage, PSIZE, 1);\n\tif (mp == NULL) {\n\t\tjfs_err(\"diWriteSpecial: failed to read aggregate inode \"\n\t\t\t\"extent!\");\n\t\treturn;\n\t}\n\n\t/* get the pointer to the disk inode of interest */\n\tdp = (struct dinode *) (mp->data);\n\tdp += inum % 8;\t\t/* 8 inodes per 4K page */\n\n\t/* copy on-disk inode to in-memory inode */\n\tcopy_to_dinode(dp, ip);\n\tmemcpy(&dp->di_xtroot, &JFS_IP(ip)->i_xtroot, 288);\n\n\tif (inum == FILESYSTEM_I)\n\t\tdp->di_gengen = cpu_to_le32(sbi->gengen);\n\n\t/* write the page */\n\twrite_metapage(mp);\n}",
          "includes": [
            "#include \"jfs_debug.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_imap.h\"",
            "#include \"jfs_dmap.h\"",
            "#include \"jfs_dinode.h\"",
            "#include \"jfs_filsys.h\"",
            "#include \"jfs_inode.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/slab.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int diAllocAG(struct inomap *, int, bool, struct inode *);",
            "static int diAllocAny(struct inomap *, int, bool, struct inode *);",
            "static int diAllocExt(struct inomap *, int, struct inode *);",
            "static int diAllocIno(struct inomap *, int, struct inode *);",
            "static int diNewIAG(struct inomap *, int *, int, struct metapage **);",
            "static int diIAGRead(struct inomap * imap, int, struct metapage **);",
            "static int copy_from_dinode(struct dinode *, struct inode *);",
            "static void copy_to_dinode(struct dinode *, struct inode *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_imap.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_dinode.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_inode.h\"\n#include \"jfs_incore.h\"\n#include <linux/slab.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n\nstatic int diAllocAG(struct inomap *, int, bool, struct inode *);\nstatic int diAllocAny(struct inomap *, int, bool, struct inode *);\nstatic int diAllocExt(struct inomap *, int, struct inode *);\nstatic int diAllocIno(struct inomap *, int, struct inode *);\nstatic int diNewIAG(struct inomap *, int *, int, struct metapage **);\nstatic int diIAGRead(struct inomap * imap, int, struct metapage **);\nstatic int copy_from_dinode(struct dinode *, struct inode *);\nstatic void copy_to_dinode(struct dinode *, struct inode *);\n\nvoid diWriteSpecial(struct inode *ip, int secondary)\n{\n\tstruct jfs_sb_info *sbi = JFS_SBI(ip->i_sb);\n\tuint address;\n\tstruct dinode *dp;\n\tino_t inum = ip->i_ino;\n\tstruct metapage *mp;\n\n\tif (secondary)\n\t\taddress = addressPXD(&sbi->ait2) >> sbi->l2nbperpage;\n\telse\n\t\taddress = AITBL_OFF >> L2PSIZE;\n\n\tASSERT(inum < INOSPEREXT);\n\n\taddress += inum >> 3;\t/* 8 inodes per 4K page */\n\n\t/* read the page of fixed disk inode (AIT) in raw mode */\n\tmp = read_metapage(ip, address << sbi->l2nbperpage, PSIZE, 1);\n\tif (mp == NULL) {\n\t\tjfs_err(\"diWriteSpecial: failed to read aggregate inode \"\n\t\t\t\"extent!\");\n\t\treturn;\n\t}\n\n\t/* get the pointer to the disk inode of interest */\n\tdp = (struct dinode *) (mp->data);\n\tdp += inum % 8;\t\t/* 8 inodes per 4K page */\n\n\t/* copy on-disk inode to in-memory inode */\n\tcopy_to_dinode(dp, ip);\n\tmemcpy(&dp->di_xtroot, &JFS_IP(ip)->i_xtroot, 288);\n\n\tif (inum == FILESYSTEM_I)\n\t\tdp->di_gengen = cpu_to_le32(sbi->gengen);\n\n\t/* write the page */\n\twrite_metapage(mp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "filemap_write_and_wait",
          "args": [
            "ipimap->i_mapping"
          ],
          "line": 263
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "write_metapage",
          "args": [
            "mp"
          ],
          "line": 258
        },
        "resolved": true,
        "details": {
          "function_name": "write_metapage",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_metapage.h",
          "lines": "85-89",
          "snippet": "static inline void write_metapage(struct metapage *mp)\n{\n\tset_bit(META_dirty, &mp->flag);\n\trelease_metapage(mp);\n}",
          "includes": [
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [
            "#define META_dirty\t2"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/pagemap.h>\n\n#define META_dirty\t2\n\nstatic inline void write_metapage(struct metapage *mp)\n{\n\tset_bit(META_dirty, &mp->flag);\n\trelease_metapage(mp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "imp->im_agctl[index].numfree"
          ],
          "line": 254
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "imp->im_agctl[index].numinos"
          ],
          "line": 252
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "imp->im_agctl[index].extfree"
          ],
          "line": 250
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "imp->im_agctl[index].inofree"
          ],
          "line": 248
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "imp->im_l2nbperiext"
          ],
          "line": 245
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "imp->im_nbperiext"
          ],
          "line": 244
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "atomic_read(&imp->im_numfree)"
          ],
          "line": 243
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&imp->im_numfree"
          ],
          "line": 243
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "atomic_read(&imp->im_numinos)"
          ],
          "line": 242
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&imp->im_numinos"
          ],
          "line": 242
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "imp->im_nextiag"
          ],
          "line": 241
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "imp->im_freeiag"
          ],
          "line": 240
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "jfs_err",
          "args": [
            "\"diSync: get_metapage failed!\""
          ],
          "line": 234
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_metapage",
          "args": [
            "ipimap",
            "IMAPBLKNO << JFS_SBI(ipimap->i_sb)->l2nbperpage",
            "PSIZE",
            "0"
          ],
          "line": 230
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "JFS_SBI",
          "args": [
            "ipimap->i_sb"
          ],
          "line": 231
        },
        "resolved": true,
        "details": {
          "function_name": "JFS_SBI",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_incore.h",
          "lines": "217-220",
          "snippet": "static inline struct jfs_sb_info *JFS_SBI(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"jfs_dtree.h\"",
            "#include \"jfs_xtree.h\"",
            "#include \"jfs_types.h\"",
            "#include <linux/bitops.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_dtree.h\"\n#include \"jfs_xtree.h\"\n#include \"jfs_types.h\"\n#include <linux/bitops.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mutex.h>\n\nstatic inline struct jfs_sb_info *JFS_SBI(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      },
      {
        "call_info": {
          "callee": "JFS_IP",
          "args": [
            "ipimap"
          ],
          "line": 222
        },
        "resolved": true,
        "details": {
          "function_name": "JFS_IP",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_incore.h",
          "lines": "207-210",
          "snippet": "static inline struct jfs_inode_info *JFS_IP(struct inode *inode)\n{\n\treturn list_entry(inode, struct jfs_inode_info, vfs_inode);\n}",
          "includes": [
            "#include \"jfs_dtree.h\"",
            "#include \"jfs_xtree.h\"",
            "#include \"jfs_types.h\"",
            "#include <linux/bitops.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_dtree.h\"\n#include \"jfs_xtree.h\"\n#include \"jfs_types.h\"\n#include <linux/bitops.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mutex.h>\n\nstatic inline struct jfs_inode_info *JFS_IP(struct inode *inode)\n{\n\treturn list_entry(inode, struct jfs_inode_info, vfs_inode);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_imap.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_dinode.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_inode.h\"\n#include \"jfs_incore.h\"\n#include <linux/slab.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n\nstatic int diAllocAG(struct inomap *, int, bool, struct inode *);\nstatic int diAllocAny(struct inomap *, int, bool, struct inode *);\nstatic int diAllocExt(struct inomap *, int, struct inode *);\nstatic int diAllocIno(struct inomap *, int, struct inode *);\nstatic int diNewIAG(struct inomap *, int *, int, struct metapage **);\nstatic int diIAGRead(struct inomap * imap, int, struct metapage **);\nstatic int copy_from_dinode(struct dinode *, struct inode *);\nstatic void copy_to_dinode(struct dinode *, struct inode *);\n\nint diSync(struct inode *ipimap)\n{\n\tstruct dinomap_disk *dinom_le;\n\tstruct inomap *imp = JFS_IP(ipimap)->i_imap;\n\tstruct metapage *mp;\n\tint index;\n\n\t/*\n\t * write imap global conrol page\n\t */\n\t/* read the on-disk inode map control structure */\n\tmp = get_metapage(ipimap,\n\t\t\t  IMAPBLKNO << JFS_SBI(ipimap->i_sb)->l2nbperpage,\n\t\t\t  PSIZE, 0);\n\tif (mp == NULL) {\n\t\tjfs_err(\"diSync: get_metapage failed!\");\n\t\treturn -EIO;\n\t}\n\n\t/* copy the in-memory version to the on-disk version */\n\tdinom_le = (struct dinomap_disk *) mp->data;\n\tdinom_le->in_freeiag = cpu_to_le32(imp->im_freeiag);\n\tdinom_le->in_nextiag = cpu_to_le32(imp->im_nextiag);\n\tdinom_le->in_numinos = cpu_to_le32(atomic_read(&imp->im_numinos));\n\tdinom_le->in_numfree = cpu_to_le32(atomic_read(&imp->im_numfree));\n\tdinom_le->in_nbperiext = cpu_to_le32(imp->im_nbperiext);\n\tdinom_le->in_l2nbperiext = cpu_to_le32(imp->im_l2nbperiext);\n\tfor (index = 0; index < MAXAG; index++) {\n\t\tdinom_le->in_agctl[index].inofree =\n\t\t    cpu_to_le32(imp->im_agctl[index].inofree);\n\t\tdinom_le->in_agctl[index].extfree =\n\t\t    cpu_to_le32(imp->im_agctl[index].extfree);\n\t\tdinom_le->in_agctl[index].numinos =\n\t\t    cpu_to_le32(imp->im_agctl[index].numinos);\n\t\tdinom_le->in_agctl[index].numfree =\n\t\t    cpu_to_le32(imp->im_agctl[index].numfree);\n\t}\n\n\t/* write out the control structure */\n\twrite_metapage(mp);\n\n\t/*\n\t * write out dirty pages of imap\n\t */\n\tfilemap_write_and_wait(ipimap->i_mapping);\n\n\tdiWriteSpecial(ipimap, 0);\n\n\treturn (0);\n}"
  },
  {
    "function_name": "diUnmount",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_imap.c",
    "lines": "191-213",
    "snippet": "int diUnmount(struct inode *ipimap, int mounterror)\n{\n\tstruct inomap *imap = JFS_IP(ipimap)->i_imap;\n\n\t/*\n\t * update the on-disk inode map control structure\n\t */\n\n\tif (!(mounterror || isReadOnly(ipimap)))\n\t\tdiSync(ipimap);\n\n\t/*\n\t * Invalidate the page cache buffers\n\t */\n\ttruncate_inode_pages(ipimap->i_mapping, 0);\n\n\t/*\n\t * free in-memory control structure\n\t */\n\tkfree(imap);\n\n\treturn (0);\n}",
    "includes": [
      "#include \"jfs_debug.h\"",
      "#include \"jfs_superblock.h\"",
      "#include \"jfs_metapage.h\"",
      "#include \"jfs_imap.h\"",
      "#include \"jfs_dmap.h\"",
      "#include \"jfs_dinode.h\"",
      "#include \"jfs_filsys.h\"",
      "#include \"jfs_inode.h\"",
      "#include \"jfs_incore.h\"",
      "#include <linux/slab.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int diAllocAG(struct inomap *, int, bool, struct inode *);",
      "static int diAllocAny(struct inomap *, int, bool, struct inode *);",
      "static int diAllocExt(struct inomap *, int, struct inode *);",
      "static int diAllocIno(struct inomap *, int, struct inode *);",
      "static int copy_from_dinode(struct dinode *, struct inode *);",
      "static void copy_to_dinode(struct dinode *, struct inode *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "imap"
          ],
          "line": 210
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "truncate_inode_pages",
          "args": [
            "ipimap->i_mapping",
            "0"
          ],
          "line": 205
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "diSync",
          "args": [
            "ipimap"
          ],
          "line": 200
        },
        "resolved": true,
        "details": {
          "function_name": "diSync",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_imap.c",
          "lines": "219-268",
          "snippet": "int diSync(struct inode *ipimap)\n{\n\tstruct dinomap_disk *dinom_le;\n\tstruct inomap *imp = JFS_IP(ipimap)->i_imap;\n\tstruct metapage *mp;\n\tint index;\n\n\t/*\n\t * write imap global conrol page\n\t */\n\t/* read the on-disk inode map control structure */\n\tmp = get_metapage(ipimap,\n\t\t\t  IMAPBLKNO << JFS_SBI(ipimap->i_sb)->l2nbperpage,\n\t\t\t  PSIZE, 0);\n\tif (mp == NULL) {\n\t\tjfs_err(\"diSync: get_metapage failed!\");\n\t\treturn -EIO;\n\t}\n\n\t/* copy the in-memory version to the on-disk version */\n\tdinom_le = (struct dinomap_disk *) mp->data;\n\tdinom_le->in_freeiag = cpu_to_le32(imp->im_freeiag);\n\tdinom_le->in_nextiag = cpu_to_le32(imp->im_nextiag);\n\tdinom_le->in_numinos = cpu_to_le32(atomic_read(&imp->im_numinos));\n\tdinom_le->in_numfree = cpu_to_le32(atomic_read(&imp->im_numfree));\n\tdinom_le->in_nbperiext = cpu_to_le32(imp->im_nbperiext);\n\tdinom_le->in_l2nbperiext = cpu_to_le32(imp->im_l2nbperiext);\n\tfor (index = 0; index < MAXAG; index++) {\n\t\tdinom_le->in_agctl[index].inofree =\n\t\t    cpu_to_le32(imp->im_agctl[index].inofree);\n\t\tdinom_le->in_agctl[index].extfree =\n\t\t    cpu_to_le32(imp->im_agctl[index].extfree);\n\t\tdinom_le->in_agctl[index].numinos =\n\t\t    cpu_to_le32(imp->im_agctl[index].numinos);\n\t\tdinom_le->in_agctl[index].numfree =\n\t\t    cpu_to_le32(imp->im_agctl[index].numfree);\n\t}\n\n\t/* write out the control structure */\n\twrite_metapage(mp);\n\n\t/*\n\t * write out dirty pages of imap\n\t */\n\tfilemap_write_and_wait(ipimap->i_mapping);\n\n\tdiWriteSpecial(ipimap, 0);\n\n\treturn (0);\n}",
          "includes": [
            "#include \"jfs_debug.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_imap.h\"",
            "#include \"jfs_dmap.h\"",
            "#include \"jfs_dinode.h\"",
            "#include \"jfs_filsys.h\"",
            "#include \"jfs_inode.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/slab.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int diAllocAG(struct inomap *, int, bool, struct inode *);",
            "static int diAllocAny(struct inomap *, int, bool, struct inode *);",
            "static int diAllocExt(struct inomap *, int, struct inode *);",
            "static int diAllocIno(struct inomap *, int, struct inode *);",
            "static int diNewIAG(struct inomap *, int *, int, struct metapage **);",
            "static int diIAGRead(struct inomap * imap, int, struct metapage **);",
            "static int copy_from_dinode(struct dinode *, struct inode *);",
            "static void copy_to_dinode(struct dinode *, struct inode *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_imap.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_dinode.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_inode.h\"\n#include \"jfs_incore.h\"\n#include <linux/slab.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n\nstatic int diAllocAG(struct inomap *, int, bool, struct inode *);\nstatic int diAllocAny(struct inomap *, int, bool, struct inode *);\nstatic int diAllocExt(struct inomap *, int, struct inode *);\nstatic int diAllocIno(struct inomap *, int, struct inode *);\nstatic int diNewIAG(struct inomap *, int *, int, struct metapage **);\nstatic int diIAGRead(struct inomap * imap, int, struct metapage **);\nstatic int copy_from_dinode(struct dinode *, struct inode *);\nstatic void copy_to_dinode(struct dinode *, struct inode *);\n\nint diSync(struct inode *ipimap)\n{\n\tstruct dinomap_disk *dinom_le;\n\tstruct inomap *imp = JFS_IP(ipimap)->i_imap;\n\tstruct metapage *mp;\n\tint index;\n\n\t/*\n\t * write imap global conrol page\n\t */\n\t/* read the on-disk inode map control structure */\n\tmp = get_metapage(ipimap,\n\t\t\t  IMAPBLKNO << JFS_SBI(ipimap->i_sb)->l2nbperpage,\n\t\t\t  PSIZE, 0);\n\tif (mp == NULL) {\n\t\tjfs_err(\"diSync: get_metapage failed!\");\n\t\treturn -EIO;\n\t}\n\n\t/* copy the in-memory version to the on-disk version */\n\tdinom_le = (struct dinomap_disk *) mp->data;\n\tdinom_le->in_freeiag = cpu_to_le32(imp->im_freeiag);\n\tdinom_le->in_nextiag = cpu_to_le32(imp->im_nextiag);\n\tdinom_le->in_numinos = cpu_to_le32(atomic_read(&imp->im_numinos));\n\tdinom_le->in_numfree = cpu_to_le32(atomic_read(&imp->im_numfree));\n\tdinom_le->in_nbperiext = cpu_to_le32(imp->im_nbperiext);\n\tdinom_le->in_l2nbperiext = cpu_to_le32(imp->im_l2nbperiext);\n\tfor (index = 0; index < MAXAG; index++) {\n\t\tdinom_le->in_agctl[index].inofree =\n\t\t    cpu_to_le32(imp->im_agctl[index].inofree);\n\t\tdinom_le->in_agctl[index].extfree =\n\t\t    cpu_to_le32(imp->im_agctl[index].extfree);\n\t\tdinom_le->in_agctl[index].numinos =\n\t\t    cpu_to_le32(imp->im_agctl[index].numinos);\n\t\tdinom_le->in_agctl[index].numfree =\n\t\t    cpu_to_le32(imp->im_agctl[index].numfree);\n\t}\n\n\t/* write out the control structure */\n\twrite_metapage(mp);\n\n\t/*\n\t * write out dirty pages of imap\n\t */\n\tfilemap_write_and_wait(ipimap->i_mapping);\n\n\tdiWriteSpecial(ipimap, 0);\n\n\treturn (0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "isReadOnly",
          "args": [
            "ipimap"
          ],
          "line": 199
        },
        "resolved": true,
        "details": {
          "function_name": "isReadOnly",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_incore.h",
          "lines": "222-227",
          "snippet": "static inline int isReadOnly(struct inode *inode)\n{\n\tif (JFS_SBI(inode->i_sb)->log)\n\t\treturn 0;\n\treturn 1;\n}",
          "includes": [
            "#include \"jfs_dtree.h\"",
            "#include \"jfs_xtree.h\"",
            "#include \"jfs_types.h\"",
            "#include <linux/bitops.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_dtree.h\"\n#include \"jfs_xtree.h\"\n#include \"jfs_types.h\"\n#include <linux/bitops.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mutex.h>\n\nstatic inline int isReadOnly(struct inode *inode)\n{\n\tif (JFS_SBI(inode->i_sb)->log)\n\t\treturn 0;\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "JFS_IP",
          "args": [
            "ipimap"
          ],
          "line": 193
        },
        "resolved": true,
        "details": {
          "function_name": "JFS_IP",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_incore.h",
          "lines": "207-210",
          "snippet": "static inline struct jfs_inode_info *JFS_IP(struct inode *inode)\n{\n\treturn list_entry(inode, struct jfs_inode_info, vfs_inode);\n}",
          "includes": [
            "#include \"jfs_dtree.h\"",
            "#include \"jfs_xtree.h\"",
            "#include \"jfs_types.h\"",
            "#include <linux/bitops.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_dtree.h\"\n#include \"jfs_xtree.h\"\n#include \"jfs_types.h\"\n#include <linux/bitops.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mutex.h>\n\nstatic inline struct jfs_inode_info *JFS_IP(struct inode *inode)\n{\n\treturn list_entry(inode, struct jfs_inode_info, vfs_inode);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_imap.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_dinode.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_inode.h\"\n#include \"jfs_incore.h\"\n#include <linux/slab.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n\nstatic int diAllocAG(struct inomap *, int, bool, struct inode *);\nstatic int diAllocAny(struct inomap *, int, bool, struct inode *);\nstatic int diAllocExt(struct inomap *, int, struct inode *);\nstatic int diAllocIno(struct inomap *, int, struct inode *);\nstatic int copy_from_dinode(struct dinode *, struct inode *);\nstatic void copy_to_dinode(struct dinode *, struct inode *);\n\nint diUnmount(struct inode *ipimap, int mounterror)\n{\n\tstruct inomap *imap = JFS_IP(ipimap)->i_imap;\n\n\t/*\n\t * update the on-disk inode map control structure\n\t */\n\n\tif (!(mounterror || isReadOnly(ipimap)))\n\t\tdiSync(ipimap);\n\n\t/*\n\t * Invalidate the page cache buffers\n\t */\n\ttruncate_inode_pages(ipimap->i_mapping, 0);\n\n\t/*\n\t * free in-memory control structure\n\t */\n\tkfree(imap);\n\n\treturn (0);\n}"
  },
  {
    "function_name": "diMount",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_imap.c",
    "lines": "107-174",
    "snippet": "int diMount(struct inode *ipimap)\n{\n\tstruct inomap *imap;\n\tstruct metapage *mp;\n\tint index;\n\tstruct dinomap_disk *dinom_le;\n\n\t/*\n\t * allocate/initialize the in-memory inode map control structure\n\t */\n\t/* allocate the in-memory inode map control structure. */\n\timap = kmalloc(sizeof(struct inomap), GFP_KERNEL);\n\tif (imap == NULL) {\n\t\tjfs_err(\"diMount: kmalloc returned NULL!\");\n\t\treturn -ENOMEM;\n\t}\n\n\t/* read the on-disk inode map control structure. */\n\n\tmp = read_metapage(ipimap,\n\t\t\t   IMAPBLKNO << JFS_SBI(ipimap->i_sb)->l2nbperpage,\n\t\t\t   PSIZE, 0);\n\tif (mp == NULL) {\n\t\tkfree(imap);\n\t\treturn -EIO;\n\t}\n\n\t/* copy the on-disk version to the in-memory version. */\n\tdinom_le = (struct dinomap_disk *) mp->data;\n\timap->im_freeiag = le32_to_cpu(dinom_le->in_freeiag);\n\timap->im_nextiag = le32_to_cpu(dinom_le->in_nextiag);\n\tatomic_set(&imap->im_numinos, le32_to_cpu(dinom_le->in_numinos));\n\tatomic_set(&imap->im_numfree, le32_to_cpu(dinom_le->in_numfree));\n\timap->im_nbperiext = le32_to_cpu(dinom_le->in_nbperiext);\n\timap->im_l2nbperiext = le32_to_cpu(dinom_le->in_l2nbperiext);\n\tfor (index = 0; index < MAXAG; index++) {\n\t\timap->im_agctl[index].inofree =\n\t\t    le32_to_cpu(dinom_le->in_agctl[index].inofree);\n\t\timap->im_agctl[index].extfree =\n\t\t    le32_to_cpu(dinom_le->in_agctl[index].extfree);\n\t\timap->im_agctl[index].numinos =\n\t\t    le32_to_cpu(dinom_le->in_agctl[index].numinos);\n\t\timap->im_agctl[index].numfree =\n\t\t    le32_to_cpu(dinom_le->in_agctl[index].numfree);\n\t}\n\n\t/* release the buffer. */\n\trelease_metapage(mp);\n\n\t/*\n\t * allocate/initialize inode allocation map locks\n\t */\n\t/* allocate and init iag free list lock */\n\tIAGFREE_LOCK_INIT(imap);\n\n\t/* allocate and init ag list locks */\n\tfor (index = 0; index < MAXAG; index++) {\n\t\tAG_LOCK_INIT(imap, index);\n\t}\n\n\t/* bind the inode map inode and inode map control structure\n\t * to each other.\n\t */\n\timap->im_ipimap = ipimap;\n\tJFS_IP(ipimap)->i_imap = imap;\n\n\treturn (0);\n}",
    "includes": [
      "#include \"jfs_debug.h\"",
      "#include \"jfs_superblock.h\"",
      "#include \"jfs_metapage.h\"",
      "#include \"jfs_imap.h\"",
      "#include \"jfs_dmap.h\"",
      "#include \"jfs_dinode.h\"",
      "#include \"jfs_filsys.h\"",
      "#include \"jfs_inode.h\"",
      "#include \"jfs_incore.h\"",
      "#include <linux/slab.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int diAllocAG(struct inomap *, int, bool, struct inode *);",
      "static int diAllocAny(struct inomap *, int, bool, struct inode *);",
      "static int diAllocBit(struct inomap *, struct iag *, int);",
      "static int diAllocExt(struct inomap *, int, struct inode *);",
      "static int diAllocIno(struct inomap *, int, struct inode *);",
      "static int diNewExt(struct inomap *, struct iag *, int);",
      "static int diNewIAG(struct inomap *, int *, int, struct metapage **);",
      "static int diIAGRead(struct inomap * imap, int, struct metapage **);",
      "static int copy_from_dinode(struct dinode *, struct inode *);",
      "static void copy_to_dinode(struct dinode *, struct inode *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "JFS_IP",
          "args": [
            "ipimap"
          ],
          "line": 171
        },
        "resolved": true,
        "details": {
          "function_name": "JFS_IP",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_incore.h",
          "lines": "207-210",
          "snippet": "static inline struct jfs_inode_info *JFS_IP(struct inode *inode)\n{\n\treturn list_entry(inode, struct jfs_inode_info, vfs_inode);\n}",
          "includes": [
            "#include \"jfs_dtree.h\"",
            "#include \"jfs_xtree.h\"",
            "#include \"jfs_types.h\"",
            "#include <linux/bitops.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_dtree.h\"\n#include \"jfs_xtree.h\"\n#include \"jfs_types.h\"\n#include <linux/bitops.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mutex.h>\n\nstatic inline struct jfs_inode_info *JFS_IP(struct inode *inode)\n{\n\treturn list_entry(inode, struct jfs_inode_info, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "AG_LOCK_INIT",
          "args": [
            "imap",
            "index"
          ],
          "line": 164
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IAGFREE_LOCK_INIT",
          "args": [
            "imap"
          ],
          "line": 160
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "release_metapage",
          "args": [
            "mp"
          ],
          "line": 154
        },
        "resolved": true,
        "details": {
          "function_name": "release_metapage",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_metapage.c",
          "lines": "743-775",
          "snippet": "void release_metapage(struct metapage * mp)\n{\n\tstruct page *page = mp->page;\n\tjfs_info(\"release_metapage: mp = 0x%p, flag = 0x%lx\", mp, mp->flag);\n\n\tBUG_ON(!page);\n\n\tlock_page(page);\n\tunlock_metapage(mp);\n\n\tassert(mp->count);\n\tif (--mp->count || mp->nohomeok) {\n\t\tunlock_page(page);\n\t\tpage_cache_release(page);\n\t\treturn;\n\t}\n\n\tif (test_bit(META_dirty, &mp->flag)) {\n\t\tset_page_dirty(page);\n\t\tif (test_bit(META_sync, &mp->flag)) {\n\t\t\tclear_bit(META_sync, &mp->flag);\n\t\t\twrite_one_page(page, 1);\n\t\t\tlock_page(page); /* write_one_page unlocks the page */\n\t\t}\n\t} else if (mp->lsn)\t/* discard_metapage doesn't remove it */\n\t\tremove_from_logsync(mp);\n\n\t/* Try to keep metapages from using up too much memory */\n\tdrop_metapage(page, mp);\n\n\tunlock_page(page);\n\tpage_cache_release(page);\n}",
          "includes": [
            "#include \"jfs_debug.h\"",
            "#include \"jfs_txnmgr.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_filsys.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/mempool.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/bio.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_txnmgr.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_incore.h\"\n#include <linux/seq_file.h>\n#include <linux/mempool.h>\n#include <linux/buffer_head.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n\nvoid release_metapage(struct metapage * mp)\n{\n\tstruct page *page = mp->page;\n\tjfs_info(\"release_metapage: mp = 0x%p, flag = 0x%lx\", mp, mp->flag);\n\n\tBUG_ON(!page);\n\n\tlock_page(page);\n\tunlock_metapage(mp);\n\n\tassert(mp->count);\n\tif (--mp->count || mp->nohomeok) {\n\t\tunlock_page(page);\n\t\tpage_cache_release(page);\n\t\treturn;\n\t}\n\n\tif (test_bit(META_dirty, &mp->flag)) {\n\t\tset_page_dirty(page);\n\t\tif (test_bit(META_sync, &mp->flag)) {\n\t\t\tclear_bit(META_sync, &mp->flag);\n\t\t\twrite_one_page(page, 1);\n\t\t\tlock_page(page); /* write_one_page unlocks the page */\n\t\t}\n\t} else if (mp->lsn)\t/* discard_metapage doesn't remove it */\n\t\tremove_from_logsync(mp);\n\n\t/* Try to keep metapages from using up too much memory */\n\tdrop_metapage(page, mp);\n\n\tunlock_page(page);\n\tpage_cache_release(page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "dinom_le->in_agctl[index].numfree"
          ],
          "line": 150
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_set",
          "args": [
            "&imap->im_numfree",
            "le32_to_cpu(dinom_le->in_numfree)"
          ],
          "line": 139
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_set",
          "args": [
            "&imap->im_numinos",
            "le32_to_cpu(dinom_le->in_numinos)"
          ],
          "line": 138
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "imap"
          ],
          "line": 130
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "read_metapage",
          "args": [
            "ipimap",
            "IMAPBLKNO << JFS_SBI(ipimap->i_sb)->l2nbperpage",
            "PSIZE",
            "0"
          ],
          "line": 126
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "JFS_SBI",
          "args": [
            "ipimap->i_sb"
          ],
          "line": 127
        },
        "resolved": true,
        "details": {
          "function_name": "JFS_SBI",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_incore.h",
          "lines": "217-220",
          "snippet": "static inline struct jfs_sb_info *JFS_SBI(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"jfs_dtree.h\"",
            "#include \"jfs_xtree.h\"",
            "#include \"jfs_types.h\"",
            "#include <linux/bitops.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_dtree.h\"\n#include \"jfs_xtree.h\"\n#include \"jfs_types.h\"\n#include <linux/bitops.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mutex.h>\n\nstatic inline struct jfs_sb_info *JFS_SBI(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      },
      {
        "call_info": {
          "callee": "jfs_err",
          "args": [
            "\"diMount: kmalloc returned NULL!\""
          ],
          "line": 120
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "sizeof(struct inomap)",
            "GFP_KERNEL"
          ],
          "line": 118
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dx_dir_kmalloc_leaves",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "2534-2546",
          "snippet": "static struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_imap.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_dinode.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_inode.h\"\n#include \"jfs_incore.h\"\n#include <linux/slab.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n\nstatic int diAllocAG(struct inomap *, int, bool, struct inode *);\nstatic int diAllocAny(struct inomap *, int, bool, struct inode *);\nstatic int diAllocBit(struct inomap *, struct iag *, int);\nstatic int diAllocExt(struct inomap *, int, struct inode *);\nstatic int diAllocIno(struct inomap *, int, struct inode *);\nstatic int diNewExt(struct inomap *, struct iag *, int);\nstatic int diNewIAG(struct inomap *, int *, int, struct metapage **);\nstatic int diIAGRead(struct inomap * imap, int, struct metapage **);\nstatic int copy_from_dinode(struct dinode *, struct inode *);\nstatic void copy_to_dinode(struct dinode *, struct inode *);\n\nint diMount(struct inode *ipimap)\n{\n\tstruct inomap *imap;\n\tstruct metapage *mp;\n\tint index;\n\tstruct dinomap_disk *dinom_le;\n\n\t/*\n\t * allocate/initialize the in-memory inode map control structure\n\t */\n\t/* allocate the in-memory inode map control structure. */\n\timap = kmalloc(sizeof(struct inomap), GFP_KERNEL);\n\tif (imap == NULL) {\n\t\tjfs_err(\"diMount: kmalloc returned NULL!\");\n\t\treturn -ENOMEM;\n\t}\n\n\t/* read the on-disk inode map control structure. */\n\n\tmp = read_metapage(ipimap,\n\t\t\t   IMAPBLKNO << JFS_SBI(ipimap->i_sb)->l2nbperpage,\n\t\t\t   PSIZE, 0);\n\tif (mp == NULL) {\n\t\tkfree(imap);\n\t\treturn -EIO;\n\t}\n\n\t/* copy the on-disk version to the in-memory version. */\n\tdinom_le = (struct dinomap_disk *) mp->data;\n\timap->im_freeiag = le32_to_cpu(dinom_le->in_freeiag);\n\timap->im_nextiag = le32_to_cpu(dinom_le->in_nextiag);\n\tatomic_set(&imap->im_numinos, le32_to_cpu(dinom_le->in_numinos));\n\tatomic_set(&imap->im_numfree, le32_to_cpu(dinom_le->in_numfree));\n\timap->im_nbperiext = le32_to_cpu(dinom_le->in_nbperiext);\n\timap->im_l2nbperiext = le32_to_cpu(dinom_le->in_l2nbperiext);\n\tfor (index = 0; index < MAXAG; index++) {\n\t\timap->im_agctl[index].inofree =\n\t\t    le32_to_cpu(dinom_le->in_agctl[index].inofree);\n\t\timap->im_agctl[index].extfree =\n\t\t    le32_to_cpu(dinom_le->in_agctl[index].extfree);\n\t\timap->im_agctl[index].numinos =\n\t\t    le32_to_cpu(dinom_le->in_agctl[index].numinos);\n\t\timap->im_agctl[index].numfree =\n\t\t    le32_to_cpu(dinom_le->in_agctl[index].numfree);\n\t}\n\n\t/* release the buffer. */\n\trelease_metapage(mp);\n\n\t/*\n\t * allocate/initialize inode allocation map locks\n\t */\n\t/* allocate and init iag free list lock */\n\tIAGFREE_LOCK_INIT(imap);\n\n\t/* allocate and init ag list locks */\n\tfor (index = 0; index < MAXAG; index++) {\n\t\tAG_LOCK_INIT(imap, index);\n\t}\n\n\t/* bind the inode map inode and inode map control structure\n\t * to each other.\n\t */\n\timap->im_ipimap = ipimap;\n\tJFS_IP(ipimap)->i_imap = imap;\n\n\treturn (0);\n}"
  }
]