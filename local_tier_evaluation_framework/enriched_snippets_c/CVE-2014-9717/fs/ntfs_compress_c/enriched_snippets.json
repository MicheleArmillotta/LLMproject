[
  {
    "function_name": "ntfs_read_compressed_block",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/compress.c",
    "lines": "482-969",
    "snippet": "int ntfs_read_compressed_block(struct page *page)\n{\n\tloff_t i_size;\n\ts64 initialized_size;\n\tstruct address_space *mapping = page->mapping;\n\tntfs_inode *ni = NTFS_I(mapping->host);\n\tntfs_volume *vol = ni->vol;\n\tstruct super_block *sb = vol->sb;\n\trunlist_element *rl;\n\tunsigned long flags, block_size = sb->s_blocksize;\n\tunsigned char block_size_bits = sb->s_blocksize_bits;\n\tu8 *cb, *cb_pos, *cb_end;\n\tstruct buffer_head **bhs;\n\tunsigned long offset, index = page->index;\n\tu32 cb_size = ni->itype.compressed.block_size;\n\tu64 cb_size_mask = cb_size - 1UL;\n\tVCN vcn;\n\tLCN lcn;\n\t/* The first wanted vcn (minimum alignment is PAGE_CACHE_SIZE). */\n\tVCN start_vcn = (((s64)index << PAGE_CACHE_SHIFT) & ~cb_size_mask) >>\n\t\t\tvol->cluster_size_bits;\n\t/*\n\t * The first vcn after the last wanted vcn (minimum alignment is again\n\t * PAGE_CACHE_SIZE.\n\t */\n\tVCN end_vcn = ((((s64)(index + 1UL) << PAGE_CACHE_SHIFT) + cb_size - 1)\n\t\t\t& ~cb_size_mask) >> vol->cluster_size_bits;\n\t/* Number of compression blocks (cbs) in the wanted vcn range. */\n\tunsigned int nr_cbs = (end_vcn - start_vcn) << vol->cluster_size_bits\n\t\t\t>> ni->itype.compressed.block_size_bits;\n\t/*\n\t * Number of pages required to store the uncompressed data from all\n\t * compression blocks (cbs) overlapping @page. Due to alignment\n\t * guarantees of start_vcn and end_vcn, no need to round up here.\n\t */\n\tunsigned int nr_pages = (end_vcn - start_vcn) <<\n\t\t\tvol->cluster_size_bits >> PAGE_CACHE_SHIFT;\n\tunsigned int xpage, max_page, cur_page, cur_ofs, i;\n\tunsigned int cb_clusters, cb_max_ofs;\n\tint block, max_block, cb_max_page, bhs_size, nr_bhs, err = 0;\n\tstruct page **pages;\n\tunsigned char xpage_done = 0;\n\n\tntfs_debug(\"Entering, page->index = 0x%lx, cb_size = 0x%x, nr_pages = \"\n\t\t\t\"%i.\", index, cb_size, nr_pages);\n\t/*\n\t * Bad things happen if we get here for anything that is not an\n\t * unnamed $DATA attribute.\n\t */\n\tBUG_ON(ni->type != AT_DATA);\n\tBUG_ON(ni->name_len);\n\n\tpages = kmalloc(nr_pages * sizeof(struct page *), GFP_NOFS);\n\n\t/* Allocate memory to store the buffer heads we need. */\n\tbhs_size = cb_size / block_size * sizeof(struct buffer_head *);\n\tbhs = kmalloc(bhs_size, GFP_NOFS);\n\n\tif (unlikely(!pages || !bhs)) {\n\t\tkfree(bhs);\n\t\tkfree(pages);\n\t\tunlock_page(page);\n\t\tntfs_error(vol->sb, \"Failed to allocate internal buffers.\");\n\t\treturn -ENOMEM;\n\t}\n\n\t/*\n\t * We have already been given one page, this is the one we must do.\n\t * Once again, the alignment guarantees keep it simple.\n\t */\n\toffset = start_vcn << vol->cluster_size_bits >> PAGE_CACHE_SHIFT;\n\txpage = index - offset;\n\tpages[xpage] = page;\n\t/*\n\t * The remaining pages need to be allocated and inserted into the page\n\t * cache, alignment guarantees keep all the below much simpler. (-8\n\t */\n\tread_lock_irqsave(&ni->size_lock, flags);\n\ti_size = i_size_read(VFS_I(ni));\n\tinitialized_size = ni->initialized_size;\n\tread_unlock_irqrestore(&ni->size_lock, flags);\n\tmax_page = ((i_size + PAGE_CACHE_SIZE - 1) >> PAGE_CACHE_SHIFT) -\n\t\t\toffset;\n\t/* Is the page fully outside i_size? (truncate in progress) */\n\tif (xpage >= max_page) {\n\t\tkfree(bhs);\n\t\tkfree(pages);\n\t\tzero_user(page, 0, PAGE_CACHE_SIZE);\n\t\tntfs_debug(\"Compressed read outside i_size - truncated?\");\n\t\tSetPageUptodate(page);\n\t\tunlock_page(page);\n\t\treturn 0;\n\t}\n\tif (nr_pages < max_page)\n\t\tmax_page = nr_pages;\n\tfor (i = 0; i < max_page; i++, offset++) {\n\t\tif (i != xpage)\n\t\t\tpages[i] = grab_cache_page_nowait(mapping, offset);\n\t\tpage = pages[i];\n\t\tif (page) {\n\t\t\t/*\n\t\t\t * We only (re)read the page if it isn't already read\n\t\t\t * in and/or dirty or we would be losing data or at\n\t\t\t * least wasting our time.\n\t\t\t */\n\t\t\tif (!PageDirty(page) && (!PageUptodate(page) ||\n\t\t\t\t\tPageError(page))) {\n\t\t\t\tClearPageError(page);\n\t\t\t\tkmap(page);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tunlock_page(page);\n\t\t\tpage_cache_release(page);\n\t\t\tpages[i] = NULL;\n\t\t}\n\t}\n\n\t/*\n\t * We have the runlist, and all the destination pages we need to fill.\n\t * Now read the first compression block.\n\t */\n\tcur_page = 0;\n\tcur_ofs = 0;\n\tcb_clusters = ni->itype.compressed.block_clusters;\ndo_next_cb:\n\tnr_cbs--;\n\tnr_bhs = 0;\n\n\t/* Read all cb buffer heads one cluster at a time. */\n\trl = NULL;\n\tfor (vcn = start_vcn, start_vcn += cb_clusters; vcn < start_vcn;\n\t\t\tvcn++) {\n\t\tbool is_retry = false;\n\n\t\tif (!rl) {\nlock_retry_remap:\n\t\t\tdown_read(&ni->runlist.lock);\n\t\t\trl = ni->runlist.rl;\n\t\t}\n\t\tif (likely(rl != NULL)) {\n\t\t\t/* Seek to element containing target vcn. */\n\t\t\twhile (rl->length && rl[1].vcn <= vcn)\n\t\t\t\trl++;\n\t\t\tlcn = ntfs_rl_vcn_to_lcn(rl, vcn);\n\t\t} else\n\t\t\tlcn = LCN_RL_NOT_MAPPED;\n\t\tntfs_debug(\"Reading vcn = 0x%llx, lcn = 0x%llx.\",\n\t\t\t\t(unsigned long long)vcn,\n\t\t\t\t(unsigned long long)lcn);\n\t\tif (lcn < 0) {\n\t\t\t/*\n\t\t\t * When we reach the first sparse cluster we have\n\t\t\t * finished with the cb.\n\t\t\t */\n\t\t\tif (lcn == LCN_HOLE)\n\t\t\t\tbreak;\n\t\t\tif (is_retry || lcn != LCN_RL_NOT_MAPPED)\n\t\t\t\tgoto rl_err;\n\t\t\tis_retry = true;\n\t\t\t/*\n\t\t\t * Attempt to map runlist, dropping lock for the\n\t\t\t * duration.\n\t\t\t */\n\t\t\tup_read(&ni->runlist.lock);\n\t\t\tif (!ntfs_map_runlist(ni, vcn))\n\t\t\t\tgoto lock_retry_remap;\n\t\t\tgoto map_rl_err;\n\t\t}\n\t\tblock = lcn << vol->cluster_size_bits >> block_size_bits;\n\t\t/* Read the lcn from device in chunks of block_size bytes. */\n\t\tmax_block = block + (vol->cluster_size >> block_size_bits);\n\t\tdo {\n\t\t\tntfs_debug(\"block = 0x%x.\", block);\n\t\t\tif (unlikely(!(bhs[nr_bhs] = sb_getblk(sb, block))))\n\t\t\t\tgoto getblk_err;\n\t\t\tnr_bhs++;\n\t\t} while (++block < max_block);\n\t}\n\n\t/* Release the lock if we took it. */\n\tif (rl)\n\t\tup_read(&ni->runlist.lock);\n\n\t/* Setup and initiate io on all buffer heads. */\n\tfor (i = 0; i < nr_bhs; i++) {\n\t\tstruct buffer_head *tbh = bhs[i];\n\n\t\tif (!trylock_buffer(tbh))\n\t\t\tcontinue;\n\t\tif (unlikely(buffer_uptodate(tbh))) {\n\t\t\tunlock_buffer(tbh);\n\t\t\tcontinue;\n\t\t}\n\t\tget_bh(tbh);\n\t\ttbh->b_end_io = end_buffer_read_sync;\n\t\tsubmit_bh(READ, tbh);\n\t}\n\n\t/* Wait for io completion on all buffer heads. */\n\tfor (i = 0; i < nr_bhs; i++) {\n\t\tstruct buffer_head *tbh = bhs[i];\n\n\t\tif (buffer_uptodate(tbh))\n\t\t\tcontinue;\n\t\twait_on_buffer(tbh);\n\t\t/*\n\t\t * We need an optimization barrier here, otherwise we start\n\t\t * hitting the below fixup code when accessing a loopback\n\t\t * mounted ntfs partition. This indicates either there is a\n\t\t * race condition in the loop driver or, more likely, gcc\n\t\t * overoptimises the code without the barrier and it doesn't\n\t\t * do the Right Thing(TM).\n\t\t */\n\t\tbarrier();\n\t\tif (unlikely(!buffer_uptodate(tbh))) {\n\t\t\tntfs_warning(vol->sb, \"Buffer is unlocked but not \"\n\t\t\t\t\t\"uptodate! Unplugging the disk queue \"\n\t\t\t\t\t\"and rescheduling.\");\n\t\t\tget_bh(tbh);\n\t\t\tio_schedule();\n\t\t\tput_bh(tbh);\n\t\t\tif (unlikely(!buffer_uptodate(tbh)))\n\t\t\t\tgoto read_err;\n\t\t\tntfs_warning(vol->sb, \"Buffer is now uptodate. Good.\");\n\t\t}\n\t}\n\n\t/*\n\t * Get the compression buffer. We must not sleep any more\n\t * until we are finished with it.\n\t */\n\tspin_lock(&ntfs_cb_lock);\n\tcb = ntfs_compression_buffer;\n\n\tBUG_ON(!cb);\n\n\tcb_pos = cb;\n\tcb_end = cb + cb_size;\n\n\t/* Copy the buffer heads into the contiguous buffer. */\n\tfor (i = 0; i < nr_bhs; i++) {\n\t\tmemcpy(cb_pos, bhs[i]->b_data, block_size);\n\t\tcb_pos += block_size;\n\t}\n\n\t/* Just a precaution. */\n\tif (cb_pos + 2 <= cb + cb_size)\n\t\t*(u16*)cb_pos = 0;\n\n\t/* Reset cb_pos back to the beginning. */\n\tcb_pos = cb;\n\n\t/* We now have both source (if present) and destination. */\n\tntfs_debug(\"Successfully read the compression block.\");\n\n\t/* The last page and maximum offset within it for the current cb. */\n\tcb_max_page = (cur_page << PAGE_CACHE_SHIFT) + cur_ofs + cb_size;\n\tcb_max_ofs = cb_max_page & ~PAGE_CACHE_MASK;\n\tcb_max_page >>= PAGE_CACHE_SHIFT;\n\n\t/* Catch end of file inside a compression block. */\n\tif (cb_max_page > max_page)\n\t\tcb_max_page = max_page;\n\n\tif (vcn == start_vcn - cb_clusters) {\n\t\t/* Sparse cb, zero out page range overlapping the cb. */\n\t\tntfs_debug(\"Found sparse compression block.\");\n\t\t/* We can sleep from now on, so we drop lock. */\n\t\tspin_unlock(&ntfs_cb_lock);\n\t\tif (cb_max_ofs)\n\t\t\tcb_max_page--;\n\t\tfor (; cur_page < cb_max_page; cur_page++) {\n\t\t\tpage = pages[cur_page];\n\t\t\tif (page) {\n\t\t\t\t/*\n\t\t\t\t * FIXME: Using clear_page() will become wrong\n\t\t\t\t * when we get PAGE_CACHE_SIZE != PAGE_SIZE but\n\t\t\t\t * for now there is no problem.\n\t\t\t\t */\n\t\t\t\tif (likely(!cur_ofs))\n\t\t\t\t\tclear_page(page_address(page));\n\t\t\t\telse\n\t\t\t\t\tmemset(page_address(page) + cur_ofs, 0,\n\t\t\t\t\t\t\tPAGE_CACHE_SIZE -\n\t\t\t\t\t\t\tcur_ofs);\n\t\t\t\tflush_dcache_page(page);\n\t\t\t\tkunmap(page);\n\t\t\t\tSetPageUptodate(page);\n\t\t\t\tunlock_page(page);\n\t\t\t\tif (cur_page == xpage)\n\t\t\t\t\txpage_done = 1;\n\t\t\t\telse\n\t\t\t\t\tpage_cache_release(page);\n\t\t\t\tpages[cur_page] = NULL;\n\t\t\t}\n\t\t\tcb_pos += PAGE_CACHE_SIZE - cur_ofs;\n\t\t\tcur_ofs = 0;\n\t\t\tif (cb_pos >= cb_end)\n\t\t\t\tbreak;\n\t\t}\n\t\t/* If we have a partial final page, deal with it now. */\n\t\tif (cb_max_ofs && cb_pos < cb_end) {\n\t\t\tpage = pages[cur_page];\n\t\t\tif (page)\n\t\t\t\tmemset(page_address(page) + cur_ofs, 0,\n\t\t\t\t\t\tcb_max_ofs - cur_ofs);\n\t\t\t/*\n\t\t\t * No need to update cb_pos at this stage:\n\t\t\t *\tcb_pos += cb_max_ofs - cur_ofs;\n\t\t\t */\n\t\t\tcur_ofs = cb_max_ofs;\n\t\t}\n\t} else if (vcn == start_vcn) {\n\t\t/* We can't sleep so we need two stages. */\n\t\tunsigned int cur2_page = cur_page;\n\t\tunsigned int cur_ofs2 = cur_ofs;\n\t\tu8 *cb_pos2 = cb_pos;\n\n\t\tntfs_debug(\"Found uncompressed compression block.\");\n\t\t/* Uncompressed cb, copy it to the destination pages. */\n\t\t/*\n\t\t * TODO: As a big optimization, we could detect this case\n\t\t * before we read all the pages and use block_read_full_page()\n\t\t * on all full pages instead (we still have to treat partial\n\t\t * pages especially but at least we are getting rid of the\n\t\t * synchronous io for the majority of pages.\n\t\t * Or if we choose not to do the read-ahead/-behind stuff, we\n\t\t * could just return block_read_full_page(pages[xpage]) as long\n\t\t * as PAGE_CACHE_SIZE <= cb_size.\n\t\t */\n\t\tif (cb_max_ofs)\n\t\t\tcb_max_page--;\n\t\t/* First stage: copy data into destination pages. */\n\t\tfor (; cur_page < cb_max_page; cur_page++) {\n\t\t\tpage = pages[cur_page];\n\t\t\tif (page)\n\t\t\t\tmemcpy(page_address(page) + cur_ofs, cb_pos,\n\t\t\t\t\t\tPAGE_CACHE_SIZE - cur_ofs);\n\t\t\tcb_pos += PAGE_CACHE_SIZE - cur_ofs;\n\t\t\tcur_ofs = 0;\n\t\t\tif (cb_pos >= cb_end)\n\t\t\t\tbreak;\n\t\t}\n\t\t/* If we have a partial final page, deal with it now. */\n\t\tif (cb_max_ofs && cb_pos < cb_end) {\n\t\t\tpage = pages[cur_page];\n\t\t\tif (page)\n\t\t\t\tmemcpy(page_address(page) + cur_ofs, cb_pos,\n\t\t\t\t\t\tcb_max_ofs - cur_ofs);\n\t\t\tcb_pos += cb_max_ofs - cur_ofs;\n\t\t\tcur_ofs = cb_max_ofs;\n\t\t}\n\t\t/* We can sleep from now on, so drop lock. */\n\t\tspin_unlock(&ntfs_cb_lock);\n\t\t/* Second stage: finalize pages. */\n\t\tfor (; cur2_page < cb_max_page; cur2_page++) {\n\t\t\tpage = pages[cur2_page];\n\t\t\tif (page) {\n\t\t\t\t/*\n\t\t\t\t * If we are outside the initialized size, zero\n\t\t\t\t * the out of bounds page range.\n\t\t\t\t */\n\t\t\t\thandle_bounds_compressed_page(page, i_size,\n\t\t\t\t\t\tinitialized_size);\n\t\t\t\tflush_dcache_page(page);\n\t\t\t\tkunmap(page);\n\t\t\t\tSetPageUptodate(page);\n\t\t\t\tunlock_page(page);\n\t\t\t\tif (cur2_page == xpage)\n\t\t\t\t\txpage_done = 1;\n\t\t\t\telse\n\t\t\t\t\tpage_cache_release(page);\n\t\t\t\tpages[cur2_page] = NULL;\n\t\t\t}\n\t\t\tcb_pos2 += PAGE_CACHE_SIZE - cur_ofs2;\n\t\t\tcur_ofs2 = 0;\n\t\t\tif (cb_pos2 >= cb_end)\n\t\t\t\tbreak;\n\t\t}\n\t} else {\n\t\t/* Compressed cb, decompress it into the destination page(s). */\n\t\tunsigned int prev_cur_page = cur_page;\n\n\t\tntfs_debug(\"Found compressed compression block.\");\n\t\terr = ntfs_decompress(pages, &cur_page, &cur_ofs,\n\t\t\t\tcb_max_page, cb_max_ofs, xpage, &xpage_done,\n\t\t\t\tcb_pos,\tcb_size - (cb_pos - cb), i_size,\n\t\t\t\tinitialized_size);\n\t\t/*\n\t\t * We can sleep from now on, lock already dropped by\n\t\t * ntfs_decompress().\n\t\t */\n\t\tif (err) {\n\t\t\tntfs_error(vol->sb, \"ntfs_decompress() failed in inode \"\n\t\t\t\t\t\"0x%lx with error code %i. Skipping \"\n\t\t\t\t\t\"this compression block.\",\n\t\t\t\t\tni->mft_no, -err);\n\t\t\t/* Release the unfinished pages. */\n\t\t\tfor (; prev_cur_page < cur_page; prev_cur_page++) {\n\t\t\t\tpage = pages[prev_cur_page];\n\t\t\t\tif (page) {\n\t\t\t\t\tflush_dcache_page(page);\n\t\t\t\t\tkunmap(page);\n\t\t\t\t\tunlock_page(page);\n\t\t\t\t\tif (prev_cur_page != xpage)\n\t\t\t\t\t\tpage_cache_release(page);\n\t\t\t\t\tpages[prev_cur_page] = NULL;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t/* Release the buffer heads. */\n\tfor (i = 0; i < nr_bhs; i++)\n\t\tbrelse(bhs[i]);\n\n\t/* Do we have more work to do? */\n\tif (nr_cbs)\n\t\tgoto do_next_cb;\n\n\t/* We no longer need the list of buffer heads. */\n\tkfree(bhs);\n\n\t/* Clean up if we have any pages left. Should never happen. */\n\tfor (cur_page = 0; cur_page < max_page; cur_page++) {\n\t\tpage = pages[cur_page];\n\t\tif (page) {\n\t\t\tntfs_error(vol->sb, \"Still have pages left! \"\n\t\t\t\t\t\"Terminating them with extreme \"\n\t\t\t\t\t\"prejudice.  Inode 0x%lx, page index \"\n\t\t\t\t\t\"0x%lx.\", ni->mft_no, page->index);\n\t\t\tflush_dcache_page(page);\n\t\t\tkunmap(page);\n\t\t\tunlock_page(page);\n\t\t\tif (cur_page != xpage)\n\t\t\t\tpage_cache_release(page);\n\t\t\tpages[cur_page] = NULL;\n\t\t}\n\t}\n\n\t/* We no longer need the list of pages. */\n\tkfree(pages);\n\n\t/* If we have completed the requested page, we return success. */\n\tif (likely(xpage_done))\n\t\treturn 0;\n\n\tntfs_debug(\"Failed. Returning error code %s.\", err == -EOVERFLOW ?\n\t\t\t\"EOVERFLOW\" : (!err ? \"EIO\" : \"unknown error\"));\n\treturn err < 0 ? err : -EIO;\n\nread_err:\n\tntfs_error(vol->sb, \"IO error while reading compressed data.\");\n\t/* Release the buffer heads. */\n\tfor (i = 0; i < nr_bhs; i++)\n\t\tbrelse(bhs[i]);\n\tgoto err_out;\n\nmap_rl_err:\n\tntfs_error(vol->sb, \"ntfs_map_runlist() failed. Cannot read \"\n\t\t\t\"compression block.\");\n\tgoto err_out;\n\nrl_err:\n\tup_read(&ni->runlist.lock);\n\tntfs_error(vol->sb, \"ntfs_rl_vcn_to_lcn() failed. Cannot read \"\n\t\t\t\"compression block.\");\n\tgoto err_out;\n\ngetblk_err:\n\tup_read(&ni->runlist.lock);\n\tntfs_error(vol->sb, \"getblk() failed. Cannot read compression block.\");\n\nerr_out:\n\tkfree(bhs);\n\tfor (i = cur_page; i < max_page; i++) {\n\t\tpage = pages[i];\n\t\tif (page) {\n\t\t\tflush_dcache_page(page);\n\t\t\tkunmap(page);\n\t\t\tunlock_page(page);\n\t\t\tif (i != xpage)\n\t\t\t\tpage_cache_release(page);\n\t\t}\n\t}\n\tkfree(pages);\n\treturn -EIO;\n}",
    "includes": [
      "#include \"ntfs.h\"",
      "#include \"debug.h\"",
      "#include \"inode.h\"",
      "#include \"attrib.h\"",
      "#include <linux/slab.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static u8 *ntfs_compression_buffer;",
      "static DEFINE_SPINLOCK(ntfs_cb_lock);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "pages"
          ],
          "line": 967
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_cache_release",
          "args": [
            "page"
          ],
          "line": 964
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlock_page",
          "args": [
            "page"
          ],
          "line": 962
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_unlock_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/aops.c",
          "lines": "1127-1148",
          "snippet": "static void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tpage_cache_release(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}",
          "includes": [
            "#include \"sysfile.h\"",
            "#include \"namei.h\"",
            "#include \"dir.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"symlink.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/swap.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfile.h\"\n#include \"namei.h\"\n#include \"dir.h\"\n#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"symlink.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/mpage.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/swap.h>\n#include <asm/byteorder.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tpage_cache_release(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kunmap",
          "args": [
            "page"
          ],
          "line": 961
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "flush_dcache_page",
          "args": [
            "page"
          ],
          "line": 960
        },
        "resolved": true,
        "details": {
          "function_name": "ntfs_index_entry_flush_dcache_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/index.h",
          "lines": "111-117",
          "snippet": "static inline void ntfs_index_entry_flush_dcache_page(ntfs_index_context *ictx)\n{\n\tif (ictx->is_in_root)\n\t\tflush_dcache_mft_record_page(ictx->actx->ntfs_ino);\n\telse\n\t\tflush_dcache_page(ictx->page);\n}",
          "includes": [
            "#include \"aops.h\"",
            "#include \"mft.h\"",
            "#include \"attrib.h\"",
            "#include \"inode.h\"",
            "#include \"layout.h\"",
            "#include \"types.h\"",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"aops.h\"\n#include \"mft.h\"\n#include \"attrib.h\"\n#include \"inode.h\"\n#include \"layout.h\"\n#include \"types.h\"\n#include <linux/fs.h>\n\nstatic inline void ntfs_index_entry_flush_dcache_page(ntfs_index_context *ictx)\n{\n\tif (ictx->is_in_root)\n\t\tflush_dcache_mft_record_page(ictx->actx->ntfs_ino);\n\telse\n\t\tflush_dcache_page(ictx->page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "bhs"
          ],
          "line": 956
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_error",
          "args": [
            "vol->sb",
            "\"getblk() failed. Cannot read compression block.\""
          ],
          "line": 953
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "up_read",
          "args": [
            "&ni->runlist.lock"
          ],
          "line": 952
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_error",
          "args": [
            "vol->sb",
            "\"ntfs_rl_vcn_to_lcn() failed. Cannot read \"\n\t\t\t\"compression block.\""
          ],
          "line": 947
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "up_read",
          "args": [
            "&ni->runlist.lock"
          ],
          "line": 946
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_error",
          "args": [
            "vol->sb",
            "\"ntfs_map_runlist() failed. Cannot read \"\n\t\t\t\"compression block.\""
          ],
          "line": 941
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "bhs[i]"
          ],
          "line": 937
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "ntfs_error",
          "args": [
            "vol->sb",
            "\"IO error while reading compressed data.\""
          ],
          "line": 934
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_debug",
          "args": [
            "\"Failed. Returning error code %s.\"",
            "err == -EOVERFLOW ?\n\t\t\t\"EOVERFLOW\" : (!err ? \"EIO\" : \"unknown error\")"
          ],
          "line": 929
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "likely",
          "args": [
            "xpage_done"
          ],
          "line": 926
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "pages"
          ],
          "line": 923
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_cache_release",
          "args": [
            "page"
          ],
          "line": 917
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kunmap",
          "args": [
            "page"
          ],
          "line": 914
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_error",
          "args": [
            "vol->sb",
            "\"Still have pages left! \"\n\t\t\t\t\t\"Terminating them with extreme \"\n\t\t\t\t\t\"prejudice.  Inode 0x%lx, page index \"\n\t\t\t\t\t\"0x%lx.\"",
            "ni->mft_no",
            "page->index"
          ],
          "line": 909
        },
        "resolved": true,
        "details": {
          "function_name": "__ntfs_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/debug.c",
          "lines": "86-108",
          "snippet": "void __ntfs_error(const char *function, const struct super_block *sb,\n\t\tconst char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\tint flen = 0;\n\n#ifndef DEBUG\n\tif (!printk_ratelimit())\n\t\treturn;\n#endif\n\tif (function)\n\t\tflen = strlen(function);\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tif (sb)\n\t\tpr_err(\"(device %s): %s(): %pV\\n\",\n\t\t       sb->s_id, flen ? function : \"\", &vaf);\n\telse\n\t\tpr_err(\"%s(): %pV\\n\", flen ? function : \"\", &vaf);\n\tva_end(args);\n}",
          "includes": [
            "#include \"debug.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"debug.h\"\n\nvoid __ntfs_error(const char *function, const struct super_block *sb,\n\t\tconst char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\tint flen = 0;\n\n#ifndef DEBUG\n\tif (!printk_ratelimit())\n\t\treturn;\n#endif\n\tif (function)\n\t\tflen = strlen(function);\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tif (sb)\n\t\tpr_err(\"(device %s): %s(): %pV\\n\",\n\t\t       sb->s_id, flen ? function : \"\", &vaf);\n\telse\n\t\tpr_err(\"%s(): %pV\\n\", flen ? function : \"\", &vaf);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "bhs"
          ],
          "line": 903
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_cache_release",
          "args": [
            "page"
          ],
          "line": 887
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kunmap",
          "args": [
            "page"
          ],
          "line": 884
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_decompress",
          "args": [
            "pages",
            "&cur_page",
            "&cur_ofs",
            "cb_max_page",
            "cb_max_ofs",
            "xpage",
            "&xpage_done",
            "cb_pos",
            "cb_size - (cb_pos - cb)",
            "i_size",
            "initialized_size"
          ],
          "line": 866
        },
        "resolved": true,
        "details": {
          "function_name": "ntfs_decompress",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/compress.c",
          "lines": "169-445",
          "snippet": "static int ntfs_decompress(struct page *dest_pages[], int *dest_index,\n\t\tint *dest_ofs, const int dest_max_index, const int dest_max_ofs,\n\t\tconst int xpage, char *xpage_done, u8 *const cb_start,\n\t\tconst u32 cb_size, const loff_t i_size,\n\t\tconst s64 initialized_size)\n{\n\t/*\n\t * Pointers into the compressed data, i.e. the compression block (cb),\n\t * and the therein contained sub-blocks (sb).\n\t */\n\tu8 *cb_end = cb_start + cb_size; /* End of cb. */\n\tu8 *cb = cb_start;\t/* Current position in cb. */\n\tu8 *cb_sb_start = cb;\t/* Beginning of the current sb in the cb. */\n\tu8 *cb_sb_end;\t\t/* End of current sb / beginning of next sb. */\n\n\t/* Variables for uncompressed data / destination. */\n\tstruct page *dp;\t/* Current destination page being worked on. */\n\tu8 *dp_addr;\t\t/* Current pointer into dp. */\n\tu8 *dp_sb_start;\t/* Start of current sub-block in dp. */\n\tu8 *dp_sb_end;\t\t/* End of current sb in dp (dp_sb_start +\n\t\t\t\t   NTFS_SB_SIZE). */\n\tu16 do_sb_start;\t/* @dest_ofs when starting this sub-block. */\n\tu16 do_sb_end;\t\t/* @dest_ofs of end of this sb (do_sb_start +\n\t\t\t\t   NTFS_SB_SIZE). */\n\n\t/* Variables for tag and token parsing. */\n\tu8 tag;\t\t\t/* Current tag. */\n\tint token;\t\t/* Loop counter for the eight tokens in tag. */\n\n\t/* Need this because we can't sleep, so need two stages. */\n\tint completed_pages[dest_max_index - *dest_index + 1];\n\tint nr_completed_pages = 0;\n\n\t/* Default error code. */\n\tint err = -EOVERFLOW;\n\n\tntfs_debug(\"Entering, cb_size = 0x%x.\", cb_size);\ndo_next_sb:\n\tntfs_debug(\"Beginning sub-block at offset = 0x%zx in the cb.\",\n\t\t\tcb - cb_start);\n\t/*\n\t * Have we reached the end of the compression block or the end of the\n\t * decompressed data?  The latter can happen for example if the current\n\t * position in the compression block is one byte before its end so the\n\t * first two checks do not detect it.\n\t */\n\tif (cb == cb_end || !le16_to_cpup((le16*)cb) ||\n\t\t\t(*dest_index == dest_max_index &&\n\t\t\t*dest_ofs == dest_max_ofs)) {\n\t\tint i;\n\n\t\tntfs_debug(\"Completed. Returning success (0).\");\n\t\terr = 0;\nreturn_error:\n\t\t/* We can sleep from now on, so we drop lock. */\n\t\tspin_unlock(&ntfs_cb_lock);\n\t\t/* Second stage: finalize completed pages. */\n\t\tif (nr_completed_pages > 0) {\n\t\t\tfor (i = 0; i < nr_completed_pages; i++) {\n\t\t\t\tint di = completed_pages[i];\n\n\t\t\t\tdp = dest_pages[di];\n\t\t\t\t/*\n\t\t\t\t * If we are outside the initialized size, zero\n\t\t\t\t * the out of bounds page range.\n\t\t\t\t */\n\t\t\t\thandle_bounds_compressed_page(dp, i_size,\n\t\t\t\t\t\tinitialized_size);\n\t\t\t\tflush_dcache_page(dp);\n\t\t\t\tkunmap(dp);\n\t\t\t\tSetPageUptodate(dp);\n\t\t\t\tunlock_page(dp);\n\t\t\t\tif (di == xpage)\n\t\t\t\t\t*xpage_done = 1;\n\t\t\t\telse\n\t\t\t\t\tpage_cache_release(dp);\n\t\t\t\tdest_pages[di] = NULL;\n\t\t\t}\n\t\t}\n\t\treturn err;\n\t}\n\n\t/* Setup offsets for the current sub-block destination. */\n\tdo_sb_start = *dest_ofs;\n\tdo_sb_end = do_sb_start + NTFS_SB_SIZE;\n\n\t/* Check that we are still within allowed boundaries. */\n\tif (*dest_index == dest_max_index && do_sb_end > dest_max_ofs)\n\t\tgoto return_overflow;\n\n\t/* Does the minimum size of a compressed sb overflow valid range? */\n\tif (cb + 6 > cb_end)\n\t\tgoto return_overflow;\n\n\t/* Setup the current sub-block source pointers and validate range. */\n\tcb_sb_start = cb;\n\tcb_sb_end = cb_sb_start + (le16_to_cpup((le16*)cb) & NTFS_SB_SIZE_MASK)\n\t\t\t+ 3;\n\tif (cb_sb_end > cb_end)\n\t\tgoto return_overflow;\n\n\t/* Get the current destination page. */\n\tdp = dest_pages[*dest_index];\n\tif (!dp) {\n\t\t/* No page present. Skip decompression of this sub-block. */\n\t\tcb = cb_sb_end;\n\n\t\t/* Advance destination position to next sub-block. */\n\t\t*dest_ofs = (*dest_ofs + NTFS_SB_SIZE) & ~PAGE_CACHE_MASK;\n\t\tif (!*dest_ofs && (++*dest_index > dest_max_index))\n\t\t\tgoto return_overflow;\n\t\tgoto do_next_sb;\n\t}\n\n\t/* We have a valid destination page. Setup the destination pointers. */\n\tdp_addr = (u8*)page_address(dp) + do_sb_start;\n\n\t/* Now, we are ready to process the current sub-block (sb). */\n\tif (!(le16_to_cpup((le16*)cb) & NTFS_SB_IS_COMPRESSED)) {\n\t\tntfs_debug(\"Found uncompressed sub-block.\");\n\t\t/* This sb is not compressed, just copy it into destination. */\n\n\t\t/* Advance source position to first data byte. */\n\t\tcb += 2;\n\n\t\t/* An uncompressed sb must be full size. */\n\t\tif (cb_sb_end - cb != NTFS_SB_SIZE)\n\t\t\tgoto return_overflow;\n\n\t\t/* Copy the block and advance the source position. */\n\t\tmemcpy(dp_addr, cb, NTFS_SB_SIZE);\n\t\tcb += NTFS_SB_SIZE;\n\n\t\t/* Advance destination position to next sub-block. */\n\t\t*dest_ofs += NTFS_SB_SIZE;\n\t\tif (!(*dest_ofs &= ~PAGE_CACHE_MASK)) {\nfinalize_page:\n\t\t\t/*\n\t\t\t * First stage: add current page index to array of\n\t\t\t * completed pages.\n\t\t\t */\n\t\t\tcompleted_pages[nr_completed_pages++] = *dest_index;\n\t\t\tif (++*dest_index > dest_max_index)\n\t\t\t\tgoto return_overflow;\n\t\t}\n\t\tgoto do_next_sb;\n\t}\n\tntfs_debug(\"Found compressed sub-block.\");\n\t/* This sb is compressed, decompress it into destination. */\n\n\t/* Setup destination pointers. */\n\tdp_sb_start = dp_addr;\n\tdp_sb_end = dp_sb_start + NTFS_SB_SIZE;\n\n\t/* Forward to the first tag in the sub-block. */\n\tcb += 2;\ndo_next_tag:\n\tif (cb == cb_sb_end) {\n\t\t/* Check if the decompressed sub-block was not full-length. */\n\t\tif (dp_addr < dp_sb_end) {\n\t\t\tint nr_bytes = do_sb_end - *dest_ofs;\n\n\t\t\tntfs_debug(\"Filling incomplete sub-block with \"\n\t\t\t\t\t\"zeroes.\");\n\t\t\t/* Zero remainder and update destination position. */\n\t\t\tmemset(dp_addr, 0, nr_bytes);\n\t\t\t*dest_ofs += nr_bytes;\n\t\t}\n\t\t/* We have finished the current sub-block. */\n\t\tif (!(*dest_ofs &= ~PAGE_CACHE_MASK))\n\t\t\tgoto finalize_page;\n\t\tgoto do_next_sb;\n\t}\n\n\t/* Check we are still in range. */\n\tif (cb > cb_sb_end || dp_addr > dp_sb_end)\n\t\tgoto return_overflow;\n\n\t/* Get the next tag and advance to first token. */\n\ttag = *cb++;\n\n\t/* Parse the eight tokens described by the tag. */\n\tfor (token = 0; token < 8; token++, tag >>= 1) {\n\t\tu16 lg, pt, length, max_non_overlap;\n\t\tregister u16 i;\n\t\tu8 *dp_back_addr;\n\n\t\t/* Check if we are done / still in range. */\n\t\tif (cb >= cb_sb_end || dp_addr > dp_sb_end)\n\t\t\tbreak;\n\n\t\t/* Determine token type and parse appropriately.*/\n\t\tif ((tag & NTFS_TOKEN_MASK) == NTFS_SYMBOL_TOKEN) {\n\t\t\t/*\n\t\t\t * We have a symbol token, copy the symbol across, and\n\t\t\t * advance the source and destination positions.\n\t\t\t */\n\t\t\t*dp_addr++ = *cb++;\n\t\t\t++*dest_ofs;\n\n\t\t\t/* Continue with the next token. */\n\t\t\tcontinue;\n\t\t}\n\n\t\t/*\n\t\t * We have a phrase token. Make sure it is not the first tag in\n\t\t * the sb as this is illegal and would confuse the code below.\n\t\t */\n\t\tif (dp_addr == dp_sb_start)\n\t\t\tgoto return_overflow;\n\n\t\t/*\n\t\t * Determine the number of bytes to go back (p) and the number\n\t\t * of bytes to copy (l). We use an optimized algorithm in which\n\t\t * we first calculate log2(current destination position in sb),\n\t\t * which allows determination of l and p in O(1) rather than\n\t\t * O(n). We just need an arch-optimized log2() function now.\n\t\t */\n\t\tlg = 0;\n\t\tfor (i = *dest_ofs - do_sb_start - 1; i >= 0x10; i >>= 1)\n\t\t\tlg++;\n\n\t\t/* Get the phrase token into i. */\n\t\tpt = le16_to_cpup((le16*)cb);\n\n\t\t/*\n\t\t * Calculate starting position of the byte sequence in\n\t\t * the destination using the fact that p = (pt >> (12 - lg)) + 1\n\t\t * and make sure we don't go too far back.\n\t\t */\n\t\tdp_back_addr = dp_addr - (pt >> (12 - lg)) - 1;\n\t\tif (dp_back_addr < dp_sb_start)\n\t\t\tgoto return_overflow;\n\n\t\t/* Now calculate the length of the byte sequence. */\n\t\tlength = (pt & (0xfff >> lg)) + 3;\n\n\t\t/* Advance destination position and verify it is in range. */\n\t\t*dest_ofs += length;\n\t\tif (*dest_ofs > do_sb_end)\n\t\t\tgoto return_overflow;\n\n\t\t/* The number of non-overlapping bytes. */\n\t\tmax_non_overlap = dp_addr - dp_back_addr;\n\n\t\tif (length <= max_non_overlap) {\n\t\t\t/* The byte sequence doesn't overlap, just copy it. */\n\t\t\tmemcpy(dp_addr, dp_back_addr, length);\n\n\t\t\t/* Advance destination pointer. */\n\t\t\tdp_addr += length;\n\t\t} else {\n\t\t\t/*\n\t\t\t * The byte sequence does overlap, copy non-overlapping\n\t\t\t * part and then do a slow byte by byte copy for the\n\t\t\t * overlapping part. Also, advance the destination\n\t\t\t * pointer.\n\t\t\t */\n\t\t\tmemcpy(dp_addr, dp_back_addr, max_non_overlap);\n\t\t\tdp_addr += max_non_overlap;\n\t\t\tdp_back_addr += max_non_overlap;\n\t\t\tlength -= max_non_overlap;\n\t\t\twhile (length--)\n\t\t\t\t*dp_addr++ = *dp_back_addr++;\n\t\t}\n\n\t\t/* Advance source position and continue with the next token. */\n\t\tcb += 2;\n\t}\n\n\t/* No tokens left in the current tag. Continue with the next tag. */\n\tgoto do_next_tag;\n\nreturn_overflow:\n\tntfs_error(NULL, \"Failed. Returning -EOVERFLOW.\");\n\tgoto return_error;\n}",
          "includes": [
            "#include \"ntfs.h\"",
            "#include \"debug.h\"",
            "#include \"inode.h\"",
            "#include \"attrib.h\"",
            "#include <linux/slab.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_SPINLOCK(ntfs_cb_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ntfs.h\"\n#include \"debug.h\"\n#include \"inode.h\"\n#include \"attrib.h\"\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n\nstatic DEFINE_SPINLOCK(ntfs_cb_lock);\n\nstatic int ntfs_decompress(struct page *dest_pages[], int *dest_index,\n\t\tint *dest_ofs, const int dest_max_index, const int dest_max_ofs,\n\t\tconst int xpage, char *xpage_done, u8 *const cb_start,\n\t\tconst u32 cb_size, const loff_t i_size,\n\t\tconst s64 initialized_size)\n{\n\t/*\n\t * Pointers into the compressed data, i.e. the compression block (cb),\n\t * and the therein contained sub-blocks (sb).\n\t */\n\tu8 *cb_end = cb_start + cb_size; /* End of cb. */\n\tu8 *cb = cb_start;\t/* Current position in cb. */\n\tu8 *cb_sb_start = cb;\t/* Beginning of the current sb in the cb. */\n\tu8 *cb_sb_end;\t\t/* End of current sb / beginning of next sb. */\n\n\t/* Variables for uncompressed data / destination. */\n\tstruct page *dp;\t/* Current destination page being worked on. */\n\tu8 *dp_addr;\t\t/* Current pointer into dp. */\n\tu8 *dp_sb_start;\t/* Start of current sub-block in dp. */\n\tu8 *dp_sb_end;\t\t/* End of current sb in dp (dp_sb_start +\n\t\t\t\t   NTFS_SB_SIZE). */\n\tu16 do_sb_start;\t/* @dest_ofs when starting this sub-block. */\n\tu16 do_sb_end;\t\t/* @dest_ofs of end of this sb (do_sb_start +\n\t\t\t\t   NTFS_SB_SIZE). */\n\n\t/* Variables for tag and token parsing. */\n\tu8 tag;\t\t\t/* Current tag. */\n\tint token;\t\t/* Loop counter for the eight tokens in tag. */\n\n\t/* Need this because we can't sleep, so need two stages. */\n\tint completed_pages[dest_max_index - *dest_index + 1];\n\tint nr_completed_pages = 0;\n\n\t/* Default error code. */\n\tint err = -EOVERFLOW;\n\n\tntfs_debug(\"Entering, cb_size = 0x%x.\", cb_size);\ndo_next_sb:\n\tntfs_debug(\"Beginning sub-block at offset = 0x%zx in the cb.\",\n\t\t\tcb - cb_start);\n\t/*\n\t * Have we reached the end of the compression block or the end of the\n\t * decompressed data?  The latter can happen for example if the current\n\t * position in the compression block is one byte before its end so the\n\t * first two checks do not detect it.\n\t */\n\tif (cb == cb_end || !le16_to_cpup((le16*)cb) ||\n\t\t\t(*dest_index == dest_max_index &&\n\t\t\t*dest_ofs == dest_max_ofs)) {\n\t\tint i;\n\n\t\tntfs_debug(\"Completed. Returning success (0).\");\n\t\terr = 0;\nreturn_error:\n\t\t/* We can sleep from now on, so we drop lock. */\n\t\tspin_unlock(&ntfs_cb_lock);\n\t\t/* Second stage: finalize completed pages. */\n\t\tif (nr_completed_pages > 0) {\n\t\t\tfor (i = 0; i < nr_completed_pages; i++) {\n\t\t\t\tint di = completed_pages[i];\n\n\t\t\t\tdp = dest_pages[di];\n\t\t\t\t/*\n\t\t\t\t * If we are outside the initialized size, zero\n\t\t\t\t * the out of bounds page range.\n\t\t\t\t */\n\t\t\t\thandle_bounds_compressed_page(dp, i_size,\n\t\t\t\t\t\tinitialized_size);\n\t\t\t\tflush_dcache_page(dp);\n\t\t\t\tkunmap(dp);\n\t\t\t\tSetPageUptodate(dp);\n\t\t\t\tunlock_page(dp);\n\t\t\t\tif (di == xpage)\n\t\t\t\t\t*xpage_done = 1;\n\t\t\t\telse\n\t\t\t\t\tpage_cache_release(dp);\n\t\t\t\tdest_pages[di] = NULL;\n\t\t\t}\n\t\t}\n\t\treturn err;\n\t}\n\n\t/* Setup offsets for the current sub-block destination. */\n\tdo_sb_start = *dest_ofs;\n\tdo_sb_end = do_sb_start + NTFS_SB_SIZE;\n\n\t/* Check that we are still within allowed boundaries. */\n\tif (*dest_index == dest_max_index && do_sb_end > dest_max_ofs)\n\t\tgoto return_overflow;\n\n\t/* Does the minimum size of a compressed sb overflow valid range? */\n\tif (cb + 6 > cb_end)\n\t\tgoto return_overflow;\n\n\t/* Setup the current sub-block source pointers and validate range. */\n\tcb_sb_start = cb;\n\tcb_sb_end = cb_sb_start + (le16_to_cpup((le16*)cb) & NTFS_SB_SIZE_MASK)\n\t\t\t+ 3;\n\tif (cb_sb_end > cb_end)\n\t\tgoto return_overflow;\n\n\t/* Get the current destination page. */\n\tdp = dest_pages[*dest_index];\n\tif (!dp) {\n\t\t/* No page present. Skip decompression of this sub-block. */\n\t\tcb = cb_sb_end;\n\n\t\t/* Advance destination position to next sub-block. */\n\t\t*dest_ofs = (*dest_ofs + NTFS_SB_SIZE) & ~PAGE_CACHE_MASK;\n\t\tif (!*dest_ofs && (++*dest_index > dest_max_index))\n\t\t\tgoto return_overflow;\n\t\tgoto do_next_sb;\n\t}\n\n\t/* We have a valid destination page. Setup the destination pointers. */\n\tdp_addr = (u8*)page_address(dp) + do_sb_start;\n\n\t/* Now, we are ready to process the current sub-block (sb). */\n\tif (!(le16_to_cpup((le16*)cb) & NTFS_SB_IS_COMPRESSED)) {\n\t\tntfs_debug(\"Found uncompressed sub-block.\");\n\t\t/* This sb is not compressed, just copy it into destination. */\n\n\t\t/* Advance source position to first data byte. */\n\t\tcb += 2;\n\n\t\t/* An uncompressed sb must be full size. */\n\t\tif (cb_sb_end - cb != NTFS_SB_SIZE)\n\t\t\tgoto return_overflow;\n\n\t\t/* Copy the block and advance the source position. */\n\t\tmemcpy(dp_addr, cb, NTFS_SB_SIZE);\n\t\tcb += NTFS_SB_SIZE;\n\n\t\t/* Advance destination position to next sub-block. */\n\t\t*dest_ofs += NTFS_SB_SIZE;\n\t\tif (!(*dest_ofs &= ~PAGE_CACHE_MASK)) {\nfinalize_page:\n\t\t\t/*\n\t\t\t * First stage: add current page index to array of\n\t\t\t * completed pages.\n\t\t\t */\n\t\t\tcompleted_pages[nr_completed_pages++] = *dest_index;\n\t\t\tif (++*dest_index > dest_max_index)\n\t\t\t\tgoto return_overflow;\n\t\t}\n\t\tgoto do_next_sb;\n\t}\n\tntfs_debug(\"Found compressed sub-block.\");\n\t/* This sb is compressed, decompress it into destination. */\n\n\t/* Setup destination pointers. */\n\tdp_sb_start = dp_addr;\n\tdp_sb_end = dp_sb_start + NTFS_SB_SIZE;\n\n\t/* Forward to the first tag in the sub-block. */\n\tcb += 2;\ndo_next_tag:\n\tif (cb == cb_sb_end) {\n\t\t/* Check if the decompressed sub-block was not full-length. */\n\t\tif (dp_addr < dp_sb_end) {\n\t\t\tint nr_bytes = do_sb_end - *dest_ofs;\n\n\t\t\tntfs_debug(\"Filling incomplete sub-block with \"\n\t\t\t\t\t\"zeroes.\");\n\t\t\t/* Zero remainder and update destination position. */\n\t\t\tmemset(dp_addr, 0, nr_bytes);\n\t\t\t*dest_ofs += nr_bytes;\n\t\t}\n\t\t/* We have finished the current sub-block. */\n\t\tif (!(*dest_ofs &= ~PAGE_CACHE_MASK))\n\t\t\tgoto finalize_page;\n\t\tgoto do_next_sb;\n\t}\n\n\t/* Check we are still in range. */\n\tif (cb > cb_sb_end || dp_addr > dp_sb_end)\n\t\tgoto return_overflow;\n\n\t/* Get the next tag and advance to first token. */\n\ttag = *cb++;\n\n\t/* Parse the eight tokens described by the tag. */\n\tfor (token = 0; token < 8; token++, tag >>= 1) {\n\t\tu16 lg, pt, length, max_non_overlap;\n\t\tregister u16 i;\n\t\tu8 *dp_back_addr;\n\n\t\t/* Check if we are done / still in range. */\n\t\tif (cb >= cb_sb_end || dp_addr > dp_sb_end)\n\t\t\tbreak;\n\n\t\t/* Determine token type and parse appropriately.*/\n\t\tif ((tag & NTFS_TOKEN_MASK) == NTFS_SYMBOL_TOKEN) {\n\t\t\t/*\n\t\t\t * We have a symbol token, copy the symbol across, and\n\t\t\t * advance the source and destination positions.\n\t\t\t */\n\t\t\t*dp_addr++ = *cb++;\n\t\t\t++*dest_ofs;\n\n\t\t\t/* Continue with the next token. */\n\t\t\tcontinue;\n\t\t}\n\n\t\t/*\n\t\t * We have a phrase token. Make sure it is not the first tag in\n\t\t * the sb as this is illegal and would confuse the code below.\n\t\t */\n\t\tif (dp_addr == dp_sb_start)\n\t\t\tgoto return_overflow;\n\n\t\t/*\n\t\t * Determine the number of bytes to go back (p) and the number\n\t\t * of bytes to copy (l). We use an optimized algorithm in which\n\t\t * we first calculate log2(current destination position in sb),\n\t\t * which allows determination of l and p in O(1) rather than\n\t\t * O(n). We just need an arch-optimized log2() function now.\n\t\t */\n\t\tlg = 0;\n\t\tfor (i = *dest_ofs - do_sb_start - 1; i >= 0x10; i >>= 1)\n\t\t\tlg++;\n\n\t\t/* Get the phrase token into i. */\n\t\tpt = le16_to_cpup((le16*)cb);\n\n\t\t/*\n\t\t * Calculate starting position of the byte sequence in\n\t\t * the destination using the fact that p = (pt >> (12 - lg)) + 1\n\t\t * and make sure we don't go too far back.\n\t\t */\n\t\tdp_back_addr = dp_addr - (pt >> (12 - lg)) - 1;\n\t\tif (dp_back_addr < dp_sb_start)\n\t\t\tgoto return_overflow;\n\n\t\t/* Now calculate the length of the byte sequence. */\n\t\tlength = (pt & (0xfff >> lg)) + 3;\n\n\t\t/* Advance destination position and verify it is in range. */\n\t\t*dest_ofs += length;\n\t\tif (*dest_ofs > do_sb_end)\n\t\t\tgoto return_overflow;\n\n\t\t/* The number of non-overlapping bytes. */\n\t\tmax_non_overlap = dp_addr - dp_back_addr;\n\n\t\tif (length <= max_non_overlap) {\n\t\t\t/* The byte sequence doesn't overlap, just copy it. */\n\t\t\tmemcpy(dp_addr, dp_back_addr, length);\n\n\t\t\t/* Advance destination pointer. */\n\t\t\tdp_addr += length;\n\t\t} else {\n\t\t\t/*\n\t\t\t * The byte sequence does overlap, copy non-overlapping\n\t\t\t * part and then do a slow byte by byte copy for the\n\t\t\t * overlapping part. Also, advance the destination\n\t\t\t * pointer.\n\t\t\t */\n\t\t\tmemcpy(dp_addr, dp_back_addr, max_non_overlap);\n\t\t\tdp_addr += max_non_overlap;\n\t\t\tdp_back_addr += max_non_overlap;\n\t\t\tlength -= max_non_overlap;\n\t\t\twhile (length--)\n\t\t\t\t*dp_addr++ = *dp_back_addr++;\n\t\t}\n\n\t\t/* Advance source position and continue with the next token. */\n\t\tcb += 2;\n\t}\n\n\t/* No tokens left in the current tag. Continue with the next tag. */\n\tgoto do_next_tag;\n\nreturn_overflow:\n\tntfs_error(NULL, \"Failed. Returning -EOVERFLOW.\");\n\tgoto return_error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ntfs_debug",
          "args": [
            "\"Found compressed compression block.\""
          ],
          "line": 865
        },
        "resolved": true,
        "details": {
          "function_name": "ntfs_debug_dump_runlist",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/debug.c",
          "lines": "134-171",
          "snippet": "void ntfs_debug_dump_runlist(const runlist_element *rl)\n{\n\tint i;\n\tconst char *lcn_str[5] = { \"LCN_HOLE         \", \"LCN_RL_NOT_MAPPED\",\n\t\t\t\t   \"LCN_ENOENT       \", \"LCN_unknown      \" };\n\n\tif (!debug_msgs)\n\t\treturn;\n\tpr_debug(\"Dumping runlist (values in hex):\\n\");\n\tif (!rl) {\n\t\tpr_debug(\"Run list not present.\\n\");\n\t\treturn;\n\t}\n\tpr_debug(\"VCN              LCN               Run length\\n\");\n\tfor (i = 0; ; i++) {\n\t\tLCN lcn = (rl + i)->lcn;\n\n\t\tif (lcn < (LCN)0) {\n\t\t\tint index = -lcn - 1;\n\n\t\t\tif (index > -LCN_ENOENT - 1)\n\t\t\t\tindex = 3;\n\t\t\tpr_debug(\"%-16Lx %s %-16Lx%s\\n\",\n\t\t\t\t\t(long long)(rl + i)->vcn, lcn_str[index],\n\t\t\t\t\t(long long)(rl + i)->length,\n\t\t\t\t\t(rl + i)->length ? \"\" :\n\t\t\t\t\t\t\" (runlist end)\");\n\t\t} else\n\t\t\tpr_debug(\"%-16Lx %-16Lx  %-16Lx%s\\n\",\n\t\t\t\t\t(long long)(rl + i)->vcn,\n\t\t\t\t\t(long long)(rl + i)->lcn,\n\t\t\t\t\t(long long)(rl + i)->length,\n\t\t\t\t\t(rl + i)->length ? \"\" :\n\t\t\t\t\t\t\" (runlist end)\");\n\t\tif (!(rl + i)->length)\n\t\t\tbreak;\n\t}\n}",
          "includes": [
            "#include \"debug.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"debug.h\"\n\nvoid ntfs_debug_dump_runlist(const runlist_element *rl)\n{\n\tint i;\n\tconst char *lcn_str[5] = { \"LCN_HOLE         \", \"LCN_RL_NOT_MAPPED\",\n\t\t\t\t   \"LCN_ENOENT       \", \"LCN_unknown      \" };\n\n\tif (!debug_msgs)\n\t\treturn;\n\tpr_debug(\"Dumping runlist (values in hex):\\n\");\n\tif (!rl) {\n\t\tpr_debug(\"Run list not present.\\n\");\n\t\treturn;\n\t}\n\tpr_debug(\"VCN              LCN               Run length\\n\");\n\tfor (i = 0; ; i++) {\n\t\tLCN lcn = (rl + i)->lcn;\n\n\t\tif (lcn < (LCN)0) {\n\t\t\tint index = -lcn - 1;\n\n\t\t\tif (index > -LCN_ENOENT - 1)\n\t\t\t\tindex = 3;\n\t\t\tpr_debug(\"%-16Lx %s %-16Lx%s\\n\",\n\t\t\t\t\t(long long)(rl + i)->vcn, lcn_str[index],\n\t\t\t\t\t(long long)(rl + i)->length,\n\t\t\t\t\t(rl + i)->length ? \"\" :\n\t\t\t\t\t\t\" (runlist end)\");\n\t\t} else\n\t\t\tpr_debug(\"%-16Lx %-16Lx  %-16Lx%s\\n\",\n\t\t\t\t\t(long long)(rl + i)->vcn,\n\t\t\t\t\t(long long)(rl + i)->lcn,\n\t\t\t\t\t(long long)(rl + i)->length,\n\t\t\t\t\t(rl + i)->length ? \"\" :\n\t\t\t\t\t\t\" (runlist end)\");\n\t\tif (!(rl + i)->length)\n\t\t\tbreak;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "page_cache_release",
          "args": [
            "page"
          ],
          "line": 853
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SetPageUptodate",
          "args": [
            "page"
          ],
          "line": 848
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kunmap",
          "args": [
            "page"
          ],
          "line": 847
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "handle_bounds_compressed_page",
          "args": [
            "page",
            "i_size",
            "initialized_size"
          ],
          "line": 844
        },
        "resolved": true,
        "details": {
          "function_name": "handle_bounds_compressed_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/compress.c",
          "lines": "123-130",
          "snippet": "static inline void handle_bounds_compressed_page(struct page *page,\n\t\tconst loff_t i_size, const s64 initialized_size)\n{\n\tif ((page->index >= (initialized_size >> PAGE_CACHE_SHIFT)) &&\n\t\t\t(initialized_size < i_size))\n\t\tzero_partial_compressed_page(page, initialized_size);\n\treturn;\n}",
          "includes": [
            "#include \"ntfs.h\"",
            "#include \"debug.h\"",
            "#include \"inode.h\"",
            "#include \"attrib.h\"",
            "#include <linux/slab.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ntfs.h\"\n#include \"debug.h\"\n#include \"inode.h\"\n#include \"attrib.h\"\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n\nstatic inline void handle_bounds_compressed_page(struct page *page,\n\t\tconst loff_t i_size, const s64 initialized_size)\n{\n\tif ((page->index >= (initialized_size >> PAGE_CACHE_SHIFT)) &&\n\t\t\t(initialized_size < i_size))\n\t\tzero_partial_compressed_page(page, initialized_size);\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&ntfs_cb_lock"
          ],
          "line": 835
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "page_address(page) + cur_ofs",
            "cb_pos",
            "cb_max_ofs - cur_ofs"
          ],
          "line": 829
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_address",
          "args": [
            "page"
          ],
          "line": 829
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "page_address(page) + cur_ofs",
            "cb_pos",
            "PAGE_CACHE_SIZE - cur_ofs"
          ],
          "line": 818
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_address",
          "args": [
            "page"
          ],
          "line": 818
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "page_address(page) + cur_ofs",
            "0",
            "cb_max_ofs - cur_ofs"
          ],
          "line": 786
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_address",
          "args": [
            "page"
          ],
          "line": 786
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_cache_release",
          "args": [
            "page"
          ],
          "line": 774
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SetPageUptodate",
          "args": [
            "page"
          ],
          "line": 769
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kunmap",
          "args": [
            "page"
          ],
          "line": 768
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "page_address(page) + cur_ofs",
            "0",
            "PAGE_CACHE_SIZE -\n\t\t\t\t\t\t\tcur_ofs"
          ],
          "line": 764
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_address",
          "args": [
            "page"
          ],
          "line": 764
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clear_page",
          "args": [
            "page_address(page)"
          ],
          "line": 762
        },
        "resolved": true,
        "details": {
          "function_name": "__clear_page_buffers",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "123-129",
          "snippet": "static void\n__clear_page_buffers(struct page *page)\n{\n\tClearPagePrivate(page);\n\tset_page_private(page, 0);\n\tpage_cache_release(page);\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nstatic void\n__clear_page_buffers(struct page *page)\n{\n\tClearPagePrivate(page);\n\tset_page_private(page, 0);\n\tpage_cache_release(page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "page_address",
          "args": [
            "page"
          ],
          "line": 762
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "likely",
          "args": [
            "!cur_ofs"
          ],
          "line": 761
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "cb_pos",
            "bhs[i]->b_data",
            "block_size"
          ],
          "line": 723
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!cb"
          ],
          "line": 716
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&ntfs_cb_lock"
          ],
          "line": 713
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "ntfs_warning",
          "args": [
            "vol->sb",
            "\"Buffer is now uptodate. Good.\""
          ],
          "line": 705
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!buffer_uptodate(tbh)"
          ],
          "line": 703
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "buffer_uptodate",
          "args": [
            "tbh"
          ],
          "line": 703
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_set_buffer_uptodate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/disk-io.c",
          "lines": "3758-3761",
          "snippet": "int btrfs_set_buffer_uptodate(struct extent_buffer *buf)\n{\n\treturn set_extent_buffer_uptodate(buf);\n}",
          "includes": [
            "#include <asm/cpufeature.h>",
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"raid56.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/uuid.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/migrate.h>",
            "#include <linux/slab.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/writeback.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/swap.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/cpufeature.h>\n#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"raid56.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <asm/unaligned.h>\n#include <linux/semaphore.h>\n#include <linux/uuid.h>\n#include <linux/ratelimit.h>\n#include <linux/migrate.h>\n#include <linux/slab.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/radix-tree.h>\n#include <linux/swap.h>\n#include <linux/scatterlist.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nint btrfs_set_buffer_uptodate(struct extent_buffer *buf)\n{\n\treturn set_extent_buffer_uptodate(buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "put_bh",
          "args": [
            "tbh"
          ],
          "line": 702
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "io_schedule",
          "args": [],
          "line": 701
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_bh",
          "args": [
            "tbh"
          ],
          "line": 700
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_warning",
          "args": [
            "vol->sb",
            "\"Buffer is unlocked but not \"\n\t\t\t\t\t\"uptodate! Unplugging the disk queue \"\n\t\t\t\t\t\"and rescheduling.\""
          ],
          "line": 697
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!buffer_uptodate(tbh)"
          ],
          "line": 696
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "barrier",
          "args": [],
          "line": 695
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wait_on_buffer",
          "args": [
            "tbh"
          ],
          "line": 686
        },
        "resolved": true,
        "details": {
          "function_name": "__wait_on_buffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "117-120",
          "snippet": "void __wait_on_buffer(struct buffer_head * bh)\n{\n\twait_on_bit_io(&bh->b_state, BH_Lock, TASK_UNINTERRUPTIBLE);\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __wait_on_buffer(struct buffer_head * bh)\n{\n\twait_on_bit_io(&bh->b_state, BH_Lock, TASK_UNINTERRUPTIBLE);\n}"
        }
      },
      {
        "call_info": {
          "callee": "submit_bh",
          "args": [
            "READ",
            "tbh"
          ],
          "line": 677
        },
        "resolved": true,
        "details": {
          "function_name": "submit_bh",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "3055-3058",
          "snippet": "int submit_bh(int rw, struct buffer_head *bh)\n{\n\treturn _submit_bh(rw, bh, 0);\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nint submit_bh(int rw, struct buffer_head *bh)\n{\n\treturn _submit_bh(rw, bh, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_bh",
          "args": [
            "tbh"
          ],
          "line": 675
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlock_buffer",
          "args": [
            "tbh"
          ],
          "line": 672
        },
        "resolved": true,
        "details": {
          "function_name": "unlock_buffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "70-75",
          "snippet": "void unlock_buffer(struct buffer_head *bh)\n{\n\tclear_bit_unlock(BH_Lock, &bh->b_state);\n\tsmp_mb__after_atomic();\n\twake_up_bit(&bh->b_state, BH_Lock);\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid unlock_buffer(struct buffer_head *bh)\n{\n\tclear_bit_unlock(BH_Lock, &bh->b_state);\n\tsmp_mb__after_atomic();\n\twake_up_bit(&bh->b_state, BH_Lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "buffer_uptodate(tbh)"
          ],
          "line": 671
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trylock_buffer",
          "args": [
            "tbh"
          ],
          "line": 669
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "up_read",
          "args": [
            "&ni->runlist.lock"
          ],
          "line": 663
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!(bhs[nr_bhs] = sb_getblk(sb, block))"
          ],
          "line": 655
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sb_getblk",
          "args": [
            "sb",
            "block"
          ],
          "line": 655
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_debug",
          "args": [
            "\"block = 0x%x.\"",
            "block"
          ],
          "line": 654
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_map_runlist",
          "args": [
            "ni",
            "vcn"
          ],
          "line": 646
        },
        "resolved": true,
        "details": {
          "function_name": "ntfs_map_runlist",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/attrib.c",
          "lines": "298-309",
          "snippet": "int ntfs_map_runlist(ntfs_inode *ni, VCN vcn)\n{\n\tint err = 0;\n\n\tdown_write(&ni->runlist.lock);\n\t/* Make sure someone else didn't do the work while we were sleeping. */\n\tif (likely(ntfs_rl_vcn_to_lcn(ni->runlist.rl, vcn) <=\n\t\t\tLCN_RL_NOT_MAPPED))\n\t\terr = ntfs_map_runlist_nolock(ni, vcn, NULL);\n\tup_write(&ni->runlist.lock);\n\treturn err;\n}",
          "includes": [
            "#include \"types.h\"",
            "#include \"ntfs.h\"",
            "#include \"mft.h\"",
            "#include \"malloc.h\"",
            "#include \"lcnalloc.h\"",
            "#include \"layout.h\"",
            "#include \"debug.h\"",
            "#include \"attrib.h\"",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include \"ntfs.h\"\n#include \"mft.h\"\n#include \"malloc.h\"\n#include \"lcnalloc.h\"\n#include \"layout.h\"\n#include \"debug.h\"\n#include \"attrib.h\"\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/buffer_head.h>\n\nint ntfs_map_runlist(ntfs_inode *ni, VCN vcn)\n{\n\tint err = 0;\n\n\tdown_write(&ni->runlist.lock);\n\t/* Make sure someone else didn't do the work while we were sleeping. */\n\tif (likely(ntfs_rl_vcn_to_lcn(ni->runlist.rl, vcn) <=\n\t\t\tLCN_RL_NOT_MAPPED))\n\t\terr = ntfs_map_runlist_nolock(ni, vcn, NULL);\n\tup_write(&ni->runlist.lock);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "up_read",
          "args": [
            "&ni->runlist.lock"
          ],
          "line": 645
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_debug",
          "args": [
            "\"Reading vcn = 0x%llx, lcn = 0x%llx.\"",
            "(unsigned long long)vcn",
            "(unsigned long long)lcn"
          ],
          "line": 628
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_rl_vcn_to_lcn",
          "args": [
            "rl",
            "vcn"
          ],
          "line": 625
        },
        "resolved": true,
        "details": {
          "function_name": "ntfs_rl_vcn_to_lcn",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/runlist.c",
          "lines": "1004-1036",
          "snippet": "LCN ntfs_rl_vcn_to_lcn(const runlist_element *rl, const VCN vcn)\n{\n\tint i;\n\n\tBUG_ON(vcn < 0);\n\t/*\n\t * If rl is NULL, assume that we have found an unmapped runlist. The\n\t * caller can then attempt to map it and fail appropriately if\n\t * necessary.\n\t */\n\tif (unlikely(!rl))\n\t\treturn LCN_RL_NOT_MAPPED;\n\n\t/* Catch out of lower bounds vcn. */\n\tif (unlikely(vcn < rl[0].vcn))\n\t\treturn LCN_ENOENT;\n\n\tfor (i = 0; likely(rl[i].length); i++) {\n\t\tif (unlikely(vcn < rl[i+1].vcn)) {\n\t\t\tif (likely(rl[i].lcn >= (LCN)0))\n\t\t\t\treturn rl[i].lcn + (vcn - rl[i].vcn);\n\t\t\treturn rl[i].lcn;\n\t\t}\n\t}\n\t/*\n\t * The terminator element is setup to the correct value, i.e. one of\n\t * LCN_HOLE, LCN_RL_NOT_MAPPED, or LCN_ENOENT.\n\t */\n\tif (likely(rl[i].lcn < (LCN)0))\n\t\treturn rl[i].lcn;\n\t/* Just in case... We could replace this with BUG() some day. */\n\treturn LCN_ENOENT;\n}",
          "includes": [
            "#include \"ntfs.h\"",
            "#include \"malloc.h\"",
            "#include \"endian.h\"",
            "#include \"dir.h\"",
            "#include \"debug.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ntfs.h\"\n#include \"malloc.h\"\n#include \"endian.h\"\n#include \"dir.h\"\n#include \"debug.h\"\n\nLCN ntfs_rl_vcn_to_lcn(const runlist_element *rl, const VCN vcn)\n{\n\tint i;\n\n\tBUG_ON(vcn < 0);\n\t/*\n\t * If rl is NULL, assume that we have found an unmapped runlist. The\n\t * caller can then attempt to map it and fail appropriately if\n\t * necessary.\n\t */\n\tif (unlikely(!rl))\n\t\treturn LCN_RL_NOT_MAPPED;\n\n\t/* Catch out of lower bounds vcn. */\n\tif (unlikely(vcn < rl[0].vcn))\n\t\treturn LCN_ENOENT;\n\n\tfor (i = 0; likely(rl[i].length); i++) {\n\t\tif (unlikely(vcn < rl[i+1].vcn)) {\n\t\t\tif (likely(rl[i].lcn >= (LCN)0))\n\t\t\t\treturn rl[i].lcn + (vcn - rl[i].vcn);\n\t\t\treturn rl[i].lcn;\n\t\t}\n\t}\n\t/*\n\t * The terminator element is setup to the correct value, i.e. one of\n\t * LCN_HOLE, LCN_RL_NOT_MAPPED, or LCN_ENOENT.\n\t */\n\tif (likely(rl[i].lcn < (LCN)0))\n\t\treturn rl[i].lcn;\n\t/* Just in case... We could replace this with BUG() some day. */\n\treturn LCN_ENOENT;\n}"
        }
      },
      {
        "call_info": {
          "callee": "likely",
          "args": [
            "rl != NULL"
          ],
          "line": 621
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "down_read",
          "args": [
            "&ni->runlist.lock"
          ],
          "line": 618
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_cache_release",
          "args": [
            "page"
          ],
          "line": 594
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmap",
          "args": [
            "page"
          ],
          "line": 590
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ClearPageError",
          "args": [
            "page"
          ],
          "line": 589
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageError",
          "args": [
            "page"
          ],
          "line": 588
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageUptodate",
          "args": [
            "page"
          ],
          "line": 587
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageDirty",
          "args": [
            "page"
          ],
          "line": 587
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "grab_cache_page_nowait",
          "args": [
            "mapping",
            "offset"
          ],
          "line": 579
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SetPageUptodate",
          "args": [
            "page"
          ],
          "line": 571
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "zero_user",
          "args": [
            "page",
            "0",
            "PAGE_CACHE_SIZE"
          ],
          "line": 569
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "pages"
          ],
          "line": 568
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "bhs"
          ],
          "line": 567
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "read_unlock_irqrestore",
          "args": [
            "&ni->size_lock",
            "flags"
          ],
          "line": 562
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "i_size_read",
          "args": [
            "VFS_I(ni)"
          ],
          "line": 560
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VFS_I",
          "args": [
            "ni"
          ],
          "line": 560
        },
        "resolved": true,
        "details": {
          "function_name": "VFS_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/inode.h",
          "lines": "245-248",
          "snippet": "static inline struct inode *VFS_I(ntfs_inode *ni)\n{\n\treturn &((big_ntfs_inode *)ni)->vfs_inode;\n}",
          "includes": [
            "#include \"debug.h\"",
            "#include \"runlist.h\"",
            "#include \"types.h\"",
            "#include \"volume.h\"",
            "#include \"layout.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/mutex.h>",
            "#include <linux/mm.h>",
            "#include <linux/list.h>",
            "#include <linux/fs.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"debug.h\"\n#include \"runlist.h\"\n#include \"types.h\"\n#include \"volume.h\"\n#include \"layout.h\"\n#include <linux/seq_file.h>\n#include <linux/mutex.h>\n#include <linux/mm.h>\n#include <linux/list.h>\n#include <linux/fs.h>\n#include <linux/atomic.h>\n\nstatic inline struct inode *VFS_I(ntfs_inode *ni)\n{\n\treturn &((big_ntfs_inode *)ni)->vfs_inode;\n}"
        }
      },
      {
        "call_info": {
          "callee": "read_lock_irqsave",
          "args": [
            "&ni->size_lock",
            "flags"
          ],
          "line": 559
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_error",
          "args": [
            "vol->sb",
            "\"Failed to allocate internal buffers.\""
          ],
          "line": 544
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "pages"
          ],
          "line": 542
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "bhs"
          ],
          "line": 541
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!pages || !bhs"
          ],
          "line": 540
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "bhs_size",
            "GFP_NOFS"
          ],
          "line": 538
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dx_dir_kmalloc_leaves",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "2534-2546",
          "snippet": "static struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "ni->name_len"
          ],
          "line": 532
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "ni->type != AT_DATA"
          ],
          "line": 531
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_debug",
          "args": [
            "\"Entering, page->index = 0x%lx, cb_size = 0x%x, nr_pages = \"\n\t\t\t\"%i.\"",
            "index",
            "cb_size",
            "nr_pages"
          ],
          "line": 525
        },
        "resolved": true,
        "details": {
          "function_name": "__ntfs_debug",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/debug.c",
          "lines": "115-131",
          "snippet": "void __ntfs_debug(const char *file, int line, const char *function,\n\t\tconst char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\tint flen = 0;\n\n\tif (!debug_msgs)\n\t\treturn;\n\tif (function)\n\t\tflen = strlen(function);\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tpr_debug(\"(%s, %d): %s(): %pV\", file, line, flen ? function : \"\", &vaf);\n\tva_end(args);\n}",
          "includes": [
            "#include \"debug.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"debug.h\"\n\nvoid __ntfs_debug(const char *file, int line, const char *function,\n\t\tconst char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\tint flen = 0;\n\n\tif (!debug_msgs)\n\t\treturn;\n\tif (function)\n\t\tflen = strlen(function);\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tpr_debug(\"(%s, %d): %s(): %pV\", file, line, flen ? function : \"\", &vaf);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "index + 1UL"
          ],
          "line": 507
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NTFS_I",
          "args": [
            "mapping->host"
          ],
          "line": 487
        },
        "resolved": true,
        "details": {
          "function_name": "NTFS_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/inode.h",
          "lines": "240-243",
          "snippet": "static inline ntfs_inode *NTFS_I(struct inode *inode)\n{\n\treturn (ntfs_inode *)list_entry(inode, big_ntfs_inode, vfs_inode);\n}",
          "includes": [
            "#include \"debug.h\"",
            "#include \"runlist.h\"",
            "#include \"types.h\"",
            "#include \"volume.h\"",
            "#include \"layout.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/mutex.h>",
            "#include <linux/mm.h>",
            "#include <linux/list.h>",
            "#include <linux/fs.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"debug.h\"\n#include \"runlist.h\"\n#include \"types.h\"\n#include \"volume.h\"\n#include \"layout.h\"\n#include <linux/seq_file.h>\n#include <linux/mutex.h>\n#include <linux/mm.h>\n#include <linux/list.h>\n#include <linux/fs.h>\n#include <linux/atomic.h>\n\nstatic inline ntfs_inode *NTFS_I(struct inode *inode)\n{\n\treturn (ntfs_inode *)list_entry(inode, big_ntfs_inode, vfs_inode);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ntfs.h\"\n#include \"debug.h\"\n#include \"inode.h\"\n#include \"attrib.h\"\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n\nstatic u8 *ntfs_compression_buffer;\nstatic DEFINE_SPINLOCK(ntfs_cb_lock);\n\nint ntfs_read_compressed_block(struct page *page)\n{\n\tloff_t i_size;\n\ts64 initialized_size;\n\tstruct address_space *mapping = page->mapping;\n\tntfs_inode *ni = NTFS_I(mapping->host);\n\tntfs_volume *vol = ni->vol;\n\tstruct super_block *sb = vol->sb;\n\trunlist_element *rl;\n\tunsigned long flags, block_size = sb->s_blocksize;\n\tunsigned char block_size_bits = sb->s_blocksize_bits;\n\tu8 *cb, *cb_pos, *cb_end;\n\tstruct buffer_head **bhs;\n\tunsigned long offset, index = page->index;\n\tu32 cb_size = ni->itype.compressed.block_size;\n\tu64 cb_size_mask = cb_size - 1UL;\n\tVCN vcn;\n\tLCN lcn;\n\t/* The first wanted vcn (minimum alignment is PAGE_CACHE_SIZE). */\n\tVCN start_vcn = (((s64)index << PAGE_CACHE_SHIFT) & ~cb_size_mask) >>\n\t\t\tvol->cluster_size_bits;\n\t/*\n\t * The first vcn after the last wanted vcn (minimum alignment is again\n\t * PAGE_CACHE_SIZE.\n\t */\n\tVCN end_vcn = ((((s64)(index + 1UL) << PAGE_CACHE_SHIFT) + cb_size - 1)\n\t\t\t& ~cb_size_mask) >> vol->cluster_size_bits;\n\t/* Number of compression blocks (cbs) in the wanted vcn range. */\n\tunsigned int nr_cbs = (end_vcn - start_vcn) << vol->cluster_size_bits\n\t\t\t>> ni->itype.compressed.block_size_bits;\n\t/*\n\t * Number of pages required to store the uncompressed data from all\n\t * compression blocks (cbs) overlapping @page. Due to alignment\n\t * guarantees of start_vcn and end_vcn, no need to round up here.\n\t */\n\tunsigned int nr_pages = (end_vcn - start_vcn) <<\n\t\t\tvol->cluster_size_bits >> PAGE_CACHE_SHIFT;\n\tunsigned int xpage, max_page, cur_page, cur_ofs, i;\n\tunsigned int cb_clusters, cb_max_ofs;\n\tint block, max_block, cb_max_page, bhs_size, nr_bhs, err = 0;\n\tstruct page **pages;\n\tunsigned char xpage_done = 0;\n\n\tntfs_debug(\"Entering, page->index = 0x%lx, cb_size = 0x%x, nr_pages = \"\n\t\t\t\"%i.\", index, cb_size, nr_pages);\n\t/*\n\t * Bad things happen if we get here for anything that is not an\n\t * unnamed $DATA attribute.\n\t */\n\tBUG_ON(ni->type != AT_DATA);\n\tBUG_ON(ni->name_len);\n\n\tpages = kmalloc(nr_pages * sizeof(struct page *), GFP_NOFS);\n\n\t/* Allocate memory to store the buffer heads we need. */\n\tbhs_size = cb_size / block_size * sizeof(struct buffer_head *);\n\tbhs = kmalloc(bhs_size, GFP_NOFS);\n\n\tif (unlikely(!pages || !bhs)) {\n\t\tkfree(bhs);\n\t\tkfree(pages);\n\t\tunlock_page(page);\n\t\tntfs_error(vol->sb, \"Failed to allocate internal buffers.\");\n\t\treturn -ENOMEM;\n\t}\n\n\t/*\n\t * We have already been given one page, this is the one we must do.\n\t * Once again, the alignment guarantees keep it simple.\n\t */\n\toffset = start_vcn << vol->cluster_size_bits >> PAGE_CACHE_SHIFT;\n\txpage = index - offset;\n\tpages[xpage] = page;\n\t/*\n\t * The remaining pages need to be allocated and inserted into the page\n\t * cache, alignment guarantees keep all the below much simpler. (-8\n\t */\n\tread_lock_irqsave(&ni->size_lock, flags);\n\ti_size = i_size_read(VFS_I(ni));\n\tinitialized_size = ni->initialized_size;\n\tread_unlock_irqrestore(&ni->size_lock, flags);\n\tmax_page = ((i_size + PAGE_CACHE_SIZE - 1) >> PAGE_CACHE_SHIFT) -\n\t\t\toffset;\n\t/* Is the page fully outside i_size? (truncate in progress) */\n\tif (xpage >= max_page) {\n\t\tkfree(bhs);\n\t\tkfree(pages);\n\t\tzero_user(page, 0, PAGE_CACHE_SIZE);\n\t\tntfs_debug(\"Compressed read outside i_size - truncated?\");\n\t\tSetPageUptodate(page);\n\t\tunlock_page(page);\n\t\treturn 0;\n\t}\n\tif (nr_pages < max_page)\n\t\tmax_page = nr_pages;\n\tfor (i = 0; i < max_page; i++, offset++) {\n\t\tif (i != xpage)\n\t\t\tpages[i] = grab_cache_page_nowait(mapping, offset);\n\t\tpage = pages[i];\n\t\tif (page) {\n\t\t\t/*\n\t\t\t * We only (re)read the page if it isn't already read\n\t\t\t * in and/or dirty or we would be losing data or at\n\t\t\t * least wasting our time.\n\t\t\t */\n\t\t\tif (!PageDirty(page) && (!PageUptodate(page) ||\n\t\t\t\t\tPageError(page))) {\n\t\t\t\tClearPageError(page);\n\t\t\t\tkmap(page);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tunlock_page(page);\n\t\t\tpage_cache_release(page);\n\t\t\tpages[i] = NULL;\n\t\t}\n\t}\n\n\t/*\n\t * We have the runlist, and all the destination pages we need to fill.\n\t * Now read the first compression block.\n\t */\n\tcur_page = 0;\n\tcur_ofs = 0;\n\tcb_clusters = ni->itype.compressed.block_clusters;\ndo_next_cb:\n\tnr_cbs--;\n\tnr_bhs = 0;\n\n\t/* Read all cb buffer heads one cluster at a time. */\n\trl = NULL;\n\tfor (vcn = start_vcn, start_vcn += cb_clusters; vcn < start_vcn;\n\t\t\tvcn++) {\n\t\tbool is_retry = false;\n\n\t\tif (!rl) {\nlock_retry_remap:\n\t\t\tdown_read(&ni->runlist.lock);\n\t\t\trl = ni->runlist.rl;\n\t\t}\n\t\tif (likely(rl != NULL)) {\n\t\t\t/* Seek to element containing target vcn. */\n\t\t\twhile (rl->length && rl[1].vcn <= vcn)\n\t\t\t\trl++;\n\t\t\tlcn = ntfs_rl_vcn_to_lcn(rl, vcn);\n\t\t} else\n\t\t\tlcn = LCN_RL_NOT_MAPPED;\n\t\tntfs_debug(\"Reading vcn = 0x%llx, lcn = 0x%llx.\",\n\t\t\t\t(unsigned long long)vcn,\n\t\t\t\t(unsigned long long)lcn);\n\t\tif (lcn < 0) {\n\t\t\t/*\n\t\t\t * When we reach the first sparse cluster we have\n\t\t\t * finished with the cb.\n\t\t\t */\n\t\t\tif (lcn == LCN_HOLE)\n\t\t\t\tbreak;\n\t\t\tif (is_retry || lcn != LCN_RL_NOT_MAPPED)\n\t\t\t\tgoto rl_err;\n\t\t\tis_retry = true;\n\t\t\t/*\n\t\t\t * Attempt to map runlist, dropping lock for the\n\t\t\t * duration.\n\t\t\t */\n\t\t\tup_read(&ni->runlist.lock);\n\t\t\tif (!ntfs_map_runlist(ni, vcn))\n\t\t\t\tgoto lock_retry_remap;\n\t\t\tgoto map_rl_err;\n\t\t}\n\t\tblock = lcn << vol->cluster_size_bits >> block_size_bits;\n\t\t/* Read the lcn from device in chunks of block_size bytes. */\n\t\tmax_block = block + (vol->cluster_size >> block_size_bits);\n\t\tdo {\n\t\t\tntfs_debug(\"block = 0x%x.\", block);\n\t\t\tif (unlikely(!(bhs[nr_bhs] = sb_getblk(sb, block))))\n\t\t\t\tgoto getblk_err;\n\t\t\tnr_bhs++;\n\t\t} while (++block < max_block);\n\t}\n\n\t/* Release the lock if we took it. */\n\tif (rl)\n\t\tup_read(&ni->runlist.lock);\n\n\t/* Setup and initiate io on all buffer heads. */\n\tfor (i = 0; i < nr_bhs; i++) {\n\t\tstruct buffer_head *tbh = bhs[i];\n\n\t\tif (!trylock_buffer(tbh))\n\t\t\tcontinue;\n\t\tif (unlikely(buffer_uptodate(tbh))) {\n\t\t\tunlock_buffer(tbh);\n\t\t\tcontinue;\n\t\t}\n\t\tget_bh(tbh);\n\t\ttbh->b_end_io = end_buffer_read_sync;\n\t\tsubmit_bh(READ, tbh);\n\t}\n\n\t/* Wait for io completion on all buffer heads. */\n\tfor (i = 0; i < nr_bhs; i++) {\n\t\tstruct buffer_head *tbh = bhs[i];\n\n\t\tif (buffer_uptodate(tbh))\n\t\t\tcontinue;\n\t\twait_on_buffer(tbh);\n\t\t/*\n\t\t * We need an optimization barrier here, otherwise we start\n\t\t * hitting the below fixup code when accessing a loopback\n\t\t * mounted ntfs partition. This indicates either there is a\n\t\t * race condition in the loop driver or, more likely, gcc\n\t\t * overoptimises the code without the barrier and it doesn't\n\t\t * do the Right Thing(TM).\n\t\t */\n\t\tbarrier();\n\t\tif (unlikely(!buffer_uptodate(tbh))) {\n\t\t\tntfs_warning(vol->sb, \"Buffer is unlocked but not \"\n\t\t\t\t\t\"uptodate! Unplugging the disk queue \"\n\t\t\t\t\t\"and rescheduling.\");\n\t\t\tget_bh(tbh);\n\t\t\tio_schedule();\n\t\t\tput_bh(tbh);\n\t\t\tif (unlikely(!buffer_uptodate(tbh)))\n\t\t\t\tgoto read_err;\n\t\t\tntfs_warning(vol->sb, \"Buffer is now uptodate. Good.\");\n\t\t}\n\t}\n\n\t/*\n\t * Get the compression buffer. We must not sleep any more\n\t * until we are finished with it.\n\t */\n\tspin_lock(&ntfs_cb_lock);\n\tcb = ntfs_compression_buffer;\n\n\tBUG_ON(!cb);\n\n\tcb_pos = cb;\n\tcb_end = cb + cb_size;\n\n\t/* Copy the buffer heads into the contiguous buffer. */\n\tfor (i = 0; i < nr_bhs; i++) {\n\t\tmemcpy(cb_pos, bhs[i]->b_data, block_size);\n\t\tcb_pos += block_size;\n\t}\n\n\t/* Just a precaution. */\n\tif (cb_pos + 2 <= cb + cb_size)\n\t\t*(u16*)cb_pos = 0;\n\n\t/* Reset cb_pos back to the beginning. */\n\tcb_pos = cb;\n\n\t/* We now have both source (if present) and destination. */\n\tntfs_debug(\"Successfully read the compression block.\");\n\n\t/* The last page and maximum offset within it for the current cb. */\n\tcb_max_page = (cur_page << PAGE_CACHE_SHIFT) + cur_ofs + cb_size;\n\tcb_max_ofs = cb_max_page & ~PAGE_CACHE_MASK;\n\tcb_max_page >>= PAGE_CACHE_SHIFT;\n\n\t/* Catch end of file inside a compression block. */\n\tif (cb_max_page > max_page)\n\t\tcb_max_page = max_page;\n\n\tif (vcn == start_vcn - cb_clusters) {\n\t\t/* Sparse cb, zero out page range overlapping the cb. */\n\t\tntfs_debug(\"Found sparse compression block.\");\n\t\t/* We can sleep from now on, so we drop lock. */\n\t\tspin_unlock(&ntfs_cb_lock);\n\t\tif (cb_max_ofs)\n\t\t\tcb_max_page--;\n\t\tfor (; cur_page < cb_max_page; cur_page++) {\n\t\t\tpage = pages[cur_page];\n\t\t\tif (page) {\n\t\t\t\t/*\n\t\t\t\t * FIXME: Using clear_page() will become wrong\n\t\t\t\t * when we get PAGE_CACHE_SIZE != PAGE_SIZE but\n\t\t\t\t * for now there is no problem.\n\t\t\t\t */\n\t\t\t\tif (likely(!cur_ofs))\n\t\t\t\t\tclear_page(page_address(page));\n\t\t\t\telse\n\t\t\t\t\tmemset(page_address(page) + cur_ofs, 0,\n\t\t\t\t\t\t\tPAGE_CACHE_SIZE -\n\t\t\t\t\t\t\tcur_ofs);\n\t\t\t\tflush_dcache_page(page);\n\t\t\t\tkunmap(page);\n\t\t\t\tSetPageUptodate(page);\n\t\t\t\tunlock_page(page);\n\t\t\t\tif (cur_page == xpage)\n\t\t\t\t\txpage_done = 1;\n\t\t\t\telse\n\t\t\t\t\tpage_cache_release(page);\n\t\t\t\tpages[cur_page] = NULL;\n\t\t\t}\n\t\t\tcb_pos += PAGE_CACHE_SIZE - cur_ofs;\n\t\t\tcur_ofs = 0;\n\t\t\tif (cb_pos >= cb_end)\n\t\t\t\tbreak;\n\t\t}\n\t\t/* If we have a partial final page, deal with it now. */\n\t\tif (cb_max_ofs && cb_pos < cb_end) {\n\t\t\tpage = pages[cur_page];\n\t\t\tif (page)\n\t\t\t\tmemset(page_address(page) + cur_ofs, 0,\n\t\t\t\t\t\tcb_max_ofs - cur_ofs);\n\t\t\t/*\n\t\t\t * No need to update cb_pos at this stage:\n\t\t\t *\tcb_pos += cb_max_ofs - cur_ofs;\n\t\t\t */\n\t\t\tcur_ofs = cb_max_ofs;\n\t\t}\n\t} else if (vcn == start_vcn) {\n\t\t/* We can't sleep so we need two stages. */\n\t\tunsigned int cur2_page = cur_page;\n\t\tunsigned int cur_ofs2 = cur_ofs;\n\t\tu8 *cb_pos2 = cb_pos;\n\n\t\tntfs_debug(\"Found uncompressed compression block.\");\n\t\t/* Uncompressed cb, copy it to the destination pages. */\n\t\t/*\n\t\t * TODO: As a big optimization, we could detect this case\n\t\t * before we read all the pages and use block_read_full_page()\n\t\t * on all full pages instead (we still have to treat partial\n\t\t * pages especially but at least we are getting rid of the\n\t\t * synchronous io for the majority of pages.\n\t\t * Or if we choose not to do the read-ahead/-behind stuff, we\n\t\t * could just return block_read_full_page(pages[xpage]) as long\n\t\t * as PAGE_CACHE_SIZE <= cb_size.\n\t\t */\n\t\tif (cb_max_ofs)\n\t\t\tcb_max_page--;\n\t\t/* First stage: copy data into destination pages. */\n\t\tfor (; cur_page < cb_max_page; cur_page++) {\n\t\t\tpage = pages[cur_page];\n\t\t\tif (page)\n\t\t\t\tmemcpy(page_address(page) + cur_ofs, cb_pos,\n\t\t\t\t\t\tPAGE_CACHE_SIZE - cur_ofs);\n\t\t\tcb_pos += PAGE_CACHE_SIZE - cur_ofs;\n\t\t\tcur_ofs = 0;\n\t\t\tif (cb_pos >= cb_end)\n\t\t\t\tbreak;\n\t\t}\n\t\t/* If we have a partial final page, deal with it now. */\n\t\tif (cb_max_ofs && cb_pos < cb_end) {\n\t\t\tpage = pages[cur_page];\n\t\t\tif (page)\n\t\t\t\tmemcpy(page_address(page) + cur_ofs, cb_pos,\n\t\t\t\t\t\tcb_max_ofs - cur_ofs);\n\t\t\tcb_pos += cb_max_ofs - cur_ofs;\n\t\t\tcur_ofs = cb_max_ofs;\n\t\t}\n\t\t/* We can sleep from now on, so drop lock. */\n\t\tspin_unlock(&ntfs_cb_lock);\n\t\t/* Second stage: finalize pages. */\n\t\tfor (; cur2_page < cb_max_page; cur2_page++) {\n\t\t\tpage = pages[cur2_page];\n\t\t\tif (page) {\n\t\t\t\t/*\n\t\t\t\t * If we are outside the initialized size, zero\n\t\t\t\t * the out of bounds page range.\n\t\t\t\t */\n\t\t\t\thandle_bounds_compressed_page(page, i_size,\n\t\t\t\t\t\tinitialized_size);\n\t\t\t\tflush_dcache_page(page);\n\t\t\t\tkunmap(page);\n\t\t\t\tSetPageUptodate(page);\n\t\t\t\tunlock_page(page);\n\t\t\t\tif (cur2_page == xpage)\n\t\t\t\t\txpage_done = 1;\n\t\t\t\telse\n\t\t\t\t\tpage_cache_release(page);\n\t\t\t\tpages[cur2_page] = NULL;\n\t\t\t}\n\t\t\tcb_pos2 += PAGE_CACHE_SIZE - cur_ofs2;\n\t\t\tcur_ofs2 = 0;\n\t\t\tif (cb_pos2 >= cb_end)\n\t\t\t\tbreak;\n\t\t}\n\t} else {\n\t\t/* Compressed cb, decompress it into the destination page(s). */\n\t\tunsigned int prev_cur_page = cur_page;\n\n\t\tntfs_debug(\"Found compressed compression block.\");\n\t\terr = ntfs_decompress(pages, &cur_page, &cur_ofs,\n\t\t\t\tcb_max_page, cb_max_ofs, xpage, &xpage_done,\n\t\t\t\tcb_pos,\tcb_size - (cb_pos - cb), i_size,\n\t\t\t\tinitialized_size);\n\t\t/*\n\t\t * We can sleep from now on, lock already dropped by\n\t\t * ntfs_decompress().\n\t\t */\n\t\tif (err) {\n\t\t\tntfs_error(vol->sb, \"ntfs_decompress() failed in inode \"\n\t\t\t\t\t\"0x%lx with error code %i. Skipping \"\n\t\t\t\t\t\"this compression block.\",\n\t\t\t\t\tni->mft_no, -err);\n\t\t\t/* Release the unfinished pages. */\n\t\t\tfor (; prev_cur_page < cur_page; prev_cur_page++) {\n\t\t\t\tpage = pages[prev_cur_page];\n\t\t\t\tif (page) {\n\t\t\t\t\tflush_dcache_page(page);\n\t\t\t\t\tkunmap(page);\n\t\t\t\t\tunlock_page(page);\n\t\t\t\t\tif (prev_cur_page != xpage)\n\t\t\t\t\t\tpage_cache_release(page);\n\t\t\t\t\tpages[prev_cur_page] = NULL;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t/* Release the buffer heads. */\n\tfor (i = 0; i < nr_bhs; i++)\n\t\tbrelse(bhs[i]);\n\n\t/* Do we have more work to do? */\n\tif (nr_cbs)\n\t\tgoto do_next_cb;\n\n\t/* We no longer need the list of buffer heads. */\n\tkfree(bhs);\n\n\t/* Clean up if we have any pages left. Should never happen. */\n\tfor (cur_page = 0; cur_page < max_page; cur_page++) {\n\t\tpage = pages[cur_page];\n\t\tif (page) {\n\t\t\tntfs_error(vol->sb, \"Still have pages left! \"\n\t\t\t\t\t\"Terminating them with extreme \"\n\t\t\t\t\t\"prejudice.  Inode 0x%lx, page index \"\n\t\t\t\t\t\"0x%lx.\", ni->mft_no, page->index);\n\t\t\tflush_dcache_page(page);\n\t\t\tkunmap(page);\n\t\t\tunlock_page(page);\n\t\t\tif (cur_page != xpage)\n\t\t\t\tpage_cache_release(page);\n\t\t\tpages[cur_page] = NULL;\n\t\t}\n\t}\n\n\t/* We no longer need the list of pages. */\n\tkfree(pages);\n\n\t/* If we have completed the requested page, we return success. */\n\tif (likely(xpage_done))\n\t\treturn 0;\n\n\tntfs_debug(\"Failed. Returning error code %s.\", err == -EOVERFLOW ?\n\t\t\t\"EOVERFLOW\" : (!err ? \"EIO\" : \"unknown error\"));\n\treturn err < 0 ? err : -EIO;\n\nread_err:\n\tntfs_error(vol->sb, \"IO error while reading compressed data.\");\n\t/* Release the buffer heads. */\n\tfor (i = 0; i < nr_bhs; i++)\n\t\tbrelse(bhs[i]);\n\tgoto err_out;\n\nmap_rl_err:\n\tntfs_error(vol->sb, \"ntfs_map_runlist() failed. Cannot read \"\n\t\t\t\"compression block.\");\n\tgoto err_out;\n\nrl_err:\n\tup_read(&ni->runlist.lock);\n\tntfs_error(vol->sb, \"ntfs_rl_vcn_to_lcn() failed. Cannot read \"\n\t\t\t\"compression block.\");\n\tgoto err_out;\n\ngetblk_err:\n\tup_read(&ni->runlist.lock);\n\tntfs_error(vol->sb, \"getblk() failed. Cannot read compression block.\");\n\nerr_out:\n\tkfree(bhs);\n\tfor (i = cur_page; i < max_page; i++) {\n\t\tpage = pages[i];\n\t\tif (page) {\n\t\t\tflush_dcache_page(page);\n\t\t\tkunmap(page);\n\t\t\tunlock_page(page);\n\t\t\tif (i != xpage)\n\t\t\t\tpage_cache_release(page);\n\t\t}\n\t}\n\tkfree(pages);\n\treturn -EIO;\n}"
  },
  {
    "function_name": "ntfs_decompress",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/compress.c",
    "lines": "169-445",
    "snippet": "static int ntfs_decompress(struct page *dest_pages[], int *dest_index,\n\t\tint *dest_ofs, const int dest_max_index, const int dest_max_ofs,\n\t\tconst int xpage, char *xpage_done, u8 *const cb_start,\n\t\tconst u32 cb_size, const loff_t i_size,\n\t\tconst s64 initialized_size)\n{\n\t/*\n\t * Pointers into the compressed data, i.e. the compression block (cb),\n\t * and the therein contained sub-blocks (sb).\n\t */\n\tu8 *cb_end = cb_start + cb_size; /* End of cb. */\n\tu8 *cb = cb_start;\t/* Current position in cb. */\n\tu8 *cb_sb_start = cb;\t/* Beginning of the current sb in the cb. */\n\tu8 *cb_sb_end;\t\t/* End of current sb / beginning of next sb. */\n\n\t/* Variables for uncompressed data / destination. */\n\tstruct page *dp;\t/* Current destination page being worked on. */\n\tu8 *dp_addr;\t\t/* Current pointer into dp. */\n\tu8 *dp_sb_start;\t/* Start of current sub-block in dp. */\n\tu8 *dp_sb_end;\t\t/* End of current sb in dp (dp_sb_start +\n\t\t\t\t   NTFS_SB_SIZE). */\n\tu16 do_sb_start;\t/* @dest_ofs when starting this sub-block. */\n\tu16 do_sb_end;\t\t/* @dest_ofs of end of this sb (do_sb_start +\n\t\t\t\t   NTFS_SB_SIZE). */\n\n\t/* Variables for tag and token parsing. */\n\tu8 tag;\t\t\t/* Current tag. */\n\tint token;\t\t/* Loop counter for the eight tokens in tag. */\n\n\t/* Need this because we can't sleep, so need two stages. */\n\tint completed_pages[dest_max_index - *dest_index + 1];\n\tint nr_completed_pages = 0;\n\n\t/* Default error code. */\n\tint err = -EOVERFLOW;\n\n\tntfs_debug(\"Entering, cb_size = 0x%x.\", cb_size);\ndo_next_sb:\n\tntfs_debug(\"Beginning sub-block at offset = 0x%zx in the cb.\",\n\t\t\tcb - cb_start);\n\t/*\n\t * Have we reached the end of the compression block or the end of the\n\t * decompressed data?  The latter can happen for example if the current\n\t * position in the compression block is one byte before its end so the\n\t * first two checks do not detect it.\n\t */\n\tif (cb == cb_end || !le16_to_cpup((le16*)cb) ||\n\t\t\t(*dest_index == dest_max_index &&\n\t\t\t*dest_ofs == dest_max_ofs)) {\n\t\tint i;\n\n\t\tntfs_debug(\"Completed. Returning success (0).\");\n\t\terr = 0;\nreturn_error:\n\t\t/* We can sleep from now on, so we drop lock. */\n\t\tspin_unlock(&ntfs_cb_lock);\n\t\t/* Second stage: finalize completed pages. */\n\t\tif (nr_completed_pages > 0) {\n\t\t\tfor (i = 0; i < nr_completed_pages; i++) {\n\t\t\t\tint di = completed_pages[i];\n\n\t\t\t\tdp = dest_pages[di];\n\t\t\t\t/*\n\t\t\t\t * If we are outside the initialized size, zero\n\t\t\t\t * the out of bounds page range.\n\t\t\t\t */\n\t\t\t\thandle_bounds_compressed_page(dp, i_size,\n\t\t\t\t\t\tinitialized_size);\n\t\t\t\tflush_dcache_page(dp);\n\t\t\t\tkunmap(dp);\n\t\t\t\tSetPageUptodate(dp);\n\t\t\t\tunlock_page(dp);\n\t\t\t\tif (di == xpage)\n\t\t\t\t\t*xpage_done = 1;\n\t\t\t\telse\n\t\t\t\t\tpage_cache_release(dp);\n\t\t\t\tdest_pages[di] = NULL;\n\t\t\t}\n\t\t}\n\t\treturn err;\n\t}\n\n\t/* Setup offsets for the current sub-block destination. */\n\tdo_sb_start = *dest_ofs;\n\tdo_sb_end = do_sb_start + NTFS_SB_SIZE;\n\n\t/* Check that we are still within allowed boundaries. */\n\tif (*dest_index == dest_max_index && do_sb_end > dest_max_ofs)\n\t\tgoto return_overflow;\n\n\t/* Does the minimum size of a compressed sb overflow valid range? */\n\tif (cb + 6 > cb_end)\n\t\tgoto return_overflow;\n\n\t/* Setup the current sub-block source pointers and validate range. */\n\tcb_sb_start = cb;\n\tcb_sb_end = cb_sb_start + (le16_to_cpup((le16*)cb) & NTFS_SB_SIZE_MASK)\n\t\t\t+ 3;\n\tif (cb_sb_end > cb_end)\n\t\tgoto return_overflow;\n\n\t/* Get the current destination page. */\n\tdp = dest_pages[*dest_index];\n\tif (!dp) {\n\t\t/* No page present. Skip decompression of this sub-block. */\n\t\tcb = cb_sb_end;\n\n\t\t/* Advance destination position to next sub-block. */\n\t\t*dest_ofs = (*dest_ofs + NTFS_SB_SIZE) & ~PAGE_CACHE_MASK;\n\t\tif (!*dest_ofs && (++*dest_index > dest_max_index))\n\t\t\tgoto return_overflow;\n\t\tgoto do_next_sb;\n\t}\n\n\t/* We have a valid destination page. Setup the destination pointers. */\n\tdp_addr = (u8*)page_address(dp) + do_sb_start;\n\n\t/* Now, we are ready to process the current sub-block (sb). */\n\tif (!(le16_to_cpup((le16*)cb) & NTFS_SB_IS_COMPRESSED)) {\n\t\tntfs_debug(\"Found uncompressed sub-block.\");\n\t\t/* This sb is not compressed, just copy it into destination. */\n\n\t\t/* Advance source position to first data byte. */\n\t\tcb += 2;\n\n\t\t/* An uncompressed sb must be full size. */\n\t\tif (cb_sb_end - cb != NTFS_SB_SIZE)\n\t\t\tgoto return_overflow;\n\n\t\t/* Copy the block and advance the source position. */\n\t\tmemcpy(dp_addr, cb, NTFS_SB_SIZE);\n\t\tcb += NTFS_SB_SIZE;\n\n\t\t/* Advance destination position to next sub-block. */\n\t\t*dest_ofs += NTFS_SB_SIZE;\n\t\tif (!(*dest_ofs &= ~PAGE_CACHE_MASK)) {\nfinalize_page:\n\t\t\t/*\n\t\t\t * First stage: add current page index to array of\n\t\t\t * completed pages.\n\t\t\t */\n\t\t\tcompleted_pages[nr_completed_pages++] = *dest_index;\n\t\t\tif (++*dest_index > dest_max_index)\n\t\t\t\tgoto return_overflow;\n\t\t}\n\t\tgoto do_next_sb;\n\t}\n\tntfs_debug(\"Found compressed sub-block.\");\n\t/* This sb is compressed, decompress it into destination. */\n\n\t/* Setup destination pointers. */\n\tdp_sb_start = dp_addr;\n\tdp_sb_end = dp_sb_start + NTFS_SB_SIZE;\n\n\t/* Forward to the first tag in the sub-block. */\n\tcb += 2;\ndo_next_tag:\n\tif (cb == cb_sb_end) {\n\t\t/* Check if the decompressed sub-block was not full-length. */\n\t\tif (dp_addr < dp_sb_end) {\n\t\t\tint nr_bytes = do_sb_end - *dest_ofs;\n\n\t\t\tntfs_debug(\"Filling incomplete sub-block with \"\n\t\t\t\t\t\"zeroes.\");\n\t\t\t/* Zero remainder and update destination position. */\n\t\t\tmemset(dp_addr, 0, nr_bytes);\n\t\t\t*dest_ofs += nr_bytes;\n\t\t}\n\t\t/* We have finished the current sub-block. */\n\t\tif (!(*dest_ofs &= ~PAGE_CACHE_MASK))\n\t\t\tgoto finalize_page;\n\t\tgoto do_next_sb;\n\t}\n\n\t/* Check we are still in range. */\n\tif (cb > cb_sb_end || dp_addr > dp_sb_end)\n\t\tgoto return_overflow;\n\n\t/* Get the next tag and advance to first token. */\n\ttag = *cb++;\n\n\t/* Parse the eight tokens described by the tag. */\n\tfor (token = 0; token < 8; token++, tag >>= 1) {\n\t\tu16 lg, pt, length, max_non_overlap;\n\t\tregister u16 i;\n\t\tu8 *dp_back_addr;\n\n\t\t/* Check if we are done / still in range. */\n\t\tif (cb >= cb_sb_end || dp_addr > dp_sb_end)\n\t\t\tbreak;\n\n\t\t/* Determine token type and parse appropriately.*/\n\t\tif ((tag & NTFS_TOKEN_MASK) == NTFS_SYMBOL_TOKEN) {\n\t\t\t/*\n\t\t\t * We have a symbol token, copy the symbol across, and\n\t\t\t * advance the source and destination positions.\n\t\t\t */\n\t\t\t*dp_addr++ = *cb++;\n\t\t\t++*dest_ofs;\n\n\t\t\t/* Continue with the next token. */\n\t\t\tcontinue;\n\t\t}\n\n\t\t/*\n\t\t * We have a phrase token. Make sure it is not the first tag in\n\t\t * the sb as this is illegal and would confuse the code below.\n\t\t */\n\t\tif (dp_addr == dp_sb_start)\n\t\t\tgoto return_overflow;\n\n\t\t/*\n\t\t * Determine the number of bytes to go back (p) and the number\n\t\t * of bytes to copy (l). We use an optimized algorithm in which\n\t\t * we first calculate log2(current destination position in sb),\n\t\t * which allows determination of l and p in O(1) rather than\n\t\t * O(n). We just need an arch-optimized log2() function now.\n\t\t */\n\t\tlg = 0;\n\t\tfor (i = *dest_ofs - do_sb_start - 1; i >= 0x10; i >>= 1)\n\t\t\tlg++;\n\n\t\t/* Get the phrase token into i. */\n\t\tpt = le16_to_cpup((le16*)cb);\n\n\t\t/*\n\t\t * Calculate starting position of the byte sequence in\n\t\t * the destination using the fact that p = (pt >> (12 - lg)) + 1\n\t\t * and make sure we don't go too far back.\n\t\t */\n\t\tdp_back_addr = dp_addr - (pt >> (12 - lg)) - 1;\n\t\tif (dp_back_addr < dp_sb_start)\n\t\t\tgoto return_overflow;\n\n\t\t/* Now calculate the length of the byte sequence. */\n\t\tlength = (pt & (0xfff >> lg)) + 3;\n\n\t\t/* Advance destination position and verify it is in range. */\n\t\t*dest_ofs += length;\n\t\tif (*dest_ofs > do_sb_end)\n\t\t\tgoto return_overflow;\n\n\t\t/* The number of non-overlapping bytes. */\n\t\tmax_non_overlap = dp_addr - dp_back_addr;\n\n\t\tif (length <= max_non_overlap) {\n\t\t\t/* The byte sequence doesn't overlap, just copy it. */\n\t\t\tmemcpy(dp_addr, dp_back_addr, length);\n\n\t\t\t/* Advance destination pointer. */\n\t\t\tdp_addr += length;\n\t\t} else {\n\t\t\t/*\n\t\t\t * The byte sequence does overlap, copy non-overlapping\n\t\t\t * part and then do a slow byte by byte copy for the\n\t\t\t * overlapping part. Also, advance the destination\n\t\t\t * pointer.\n\t\t\t */\n\t\t\tmemcpy(dp_addr, dp_back_addr, max_non_overlap);\n\t\t\tdp_addr += max_non_overlap;\n\t\t\tdp_back_addr += max_non_overlap;\n\t\t\tlength -= max_non_overlap;\n\t\t\twhile (length--)\n\t\t\t\t*dp_addr++ = *dp_back_addr++;\n\t\t}\n\n\t\t/* Advance source position and continue with the next token. */\n\t\tcb += 2;\n\t}\n\n\t/* No tokens left in the current tag. Continue with the next tag. */\n\tgoto do_next_tag;\n\nreturn_overflow:\n\tntfs_error(NULL, \"Failed. Returning -EOVERFLOW.\");\n\tgoto return_error;\n}",
    "includes": [
      "#include \"ntfs.h\"",
      "#include \"debug.h\"",
      "#include \"inode.h\"",
      "#include \"attrib.h\"",
      "#include <linux/slab.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_SPINLOCK(ntfs_cb_lock);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ntfs_error",
          "args": [
            "NULL",
            "\"Failed. Returning -EOVERFLOW.\""
          ],
          "line": 443
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "dp_addr",
            "dp_back_addr",
            "max_non_overlap"
          ],
          "line": 427
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "dp_addr",
            "dp_back_addr",
            "length"
          ],
          "line": 416
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le16_to_cpup",
          "args": [
            "(le16*)cb"
          ],
          "line": 392
        },
        "resolved": true,
        "details": {
          "function_name": "sle16_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "48-51",
          "snippet": "static inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "dp_addr",
            "0",
            "nr_bytes"
          ],
          "line": 334
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_debug",
          "args": [
            "\"Filling incomplete sub-block with \"\n\t\t\t\t\t\"zeroes.\""
          ],
          "line": 331
        },
        "resolved": true,
        "details": {
          "function_name": "ntfs_debug_dump_runlist",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/debug.c",
          "lines": "134-171",
          "snippet": "void ntfs_debug_dump_runlist(const runlist_element *rl)\n{\n\tint i;\n\tconst char *lcn_str[5] = { \"LCN_HOLE         \", \"LCN_RL_NOT_MAPPED\",\n\t\t\t\t   \"LCN_ENOENT       \", \"LCN_unknown      \" };\n\n\tif (!debug_msgs)\n\t\treturn;\n\tpr_debug(\"Dumping runlist (values in hex):\\n\");\n\tif (!rl) {\n\t\tpr_debug(\"Run list not present.\\n\");\n\t\treturn;\n\t}\n\tpr_debug(\"VCN              LCN               Run length\\n\");\n\tfor (i = 0; ; i++) {\n\t\tLCN lcn = (rl + i)->lcn;\n\n\t\tif (lcn < (LCN)0) {\n\t\t\tint index = -lcn - 1;\n\n\t\t\tif (index > -LCN_ENOENT - 1)\n\t\t\t\tindex = 3;\n\t\t\tpr_debug(\"%-16Lx %s %-16Lx%s\\n\",\n\t\t\t\t\t(long long)(rl + i)->vcn, lcn_str[index],\n\t\t\t\t\t(long long)(rl + i)->length,\n\t\t\t\t\t(rl + i)->length ? \"\" :\n\t\t\t\t\t\t\" (runlist end)\");\n\t\t} else\n\t\t\tpr_debug(\"%-16Lx %-16Lx  %-16Lx%s\\n\",\n\t\t\t\t\t(long long)(rl + i)->vcn,\n\t\t\t\t\t(long long)(rl + i)->lcn,\n\t\t\t\t\t(long long)(rl + i)->length,\n\t\t\t\t\t(rl + i)->length ? \"\" :\n\t\t\t\t\t\t\" (runlist end)\");\n\t\tif (!(rl + i)->length)\n\t\t\tbreak;\n\t}\n}",
          "includes": [
            "#include \"debug.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"debug.h\"\n\nvoid ntfs_debug_dump_runlist(const runlist_element *rl)\n{\n\tint i;\n\tconst char *lcn_str[5] = { \"LCN_HOLE         \", \"LCN_RL_NOT_MAPPED\",\n\t\t\t\t   \"LCN_ENOENT       \", \"LCN_unknown      \" };\n\n\tif (!debug_msgs)\n\t\treturn;\n\tpr_debug(\"Dumping runlist (values in hex):\\n\");\n\tif (!rl) {\n\t\tpr_debug(\"Run list not present.\\n\");\n\t\treturn;\n\t}\n\tpr_debug(\"VCN              LCN               Run length\\n\");\n\tfor (i = 0; ; i++) {\n\t\tLCN lcn = (rl + i)->lcn;\n\n\t\tif (lcn < (LCN)0) {\n\t\t\tint index = -lcn - 1;\n\n\t\t\tif (index > -LCN_ENOENT - 1)\n\t\t\t\tindex = 3;\n\t\t\tpr_debug(\"%-16Lx %s %-16Lx%s\\n\",\n\t\t\t\t\t(long long)(rl + i)->vcn, lcn_str[index],\n\t\t\t\t\t(long long)(rl + i)->length,\n\t\t\t\t\t(rl + i)->length ? \"\" :\n\t\t\t\t\t\t\" (runlist end)\");\n\t\t} else\n\t\t\tpr_debug(\"%-16Lx %-16Lx  %-16Lx%s\\n\",\n\t\t\t\t\t(long long)(rl + i)->vcn,\n\t\t\t\t\t(long long)(rl + i)->lcn,\n\t\t\t\t\t(long long)(rl + i)->length,\n\t\t\t\t\t(rl + i)->length ? \"\" :\n\t\t\t\t\t\t\" (runlist end)\");\n\t\tif (!(rl + i)->length)\n\t\t\tbreak;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "dp_addr",
            "cb",
            "NTFS_SB_SIZE"
          ],
          "line": 299
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_address",
          "args": [
            "dp"
          ],
          "line": 284
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_cache_release",
          "args": [
            "dp"
          ],
          "line": 244
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlock_page",
          "args": [
            "dp"
          ],
          "line": 240
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_unlock_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/aops.c",
          "lines": "1127-1148",
          "snippet": "static void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tpage_cache_release(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}",
          "includes": [
            "#include \"sysfile.h\"",
            "#include \"namei.h\"",
            "#include \"dir.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"symlink.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/swap.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfile.h\"\n#include \"namei.h\"\n#include \"dir.h\"\n#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"symlink.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/mpage.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/swap.h>\n#include <asm/byteorder.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tpage_cache_release(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}"
        }
      },
      {
        "call_info": {
          "callee": "SetPageUptodate",
          "args": [
            "dp"
          ],
          "line": 239
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kunmap",
          "args": [
            "dp"
          ],
          "line": 238
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "flush_dcache_page",
          "args": [
            "dp"
          ],
          "line": 237
        },
        "resolved": true,
        "details": {
          "function_name": "ntfs_index_entry_flush_dcache_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/index.h",
          "lines": "111-117",
          "snippet": "static inline void ntfs_index_entry_flush_dcache_page(ntfs_index_context *ictx)\n{\n\tif (ictx->is_in_root)\n\t\tflush_dcache_mft_record_page(ictx->actx->ntfs_ino);\n\telse\n\t\tflush_dcache_page(ictx->page);\n}",
          "includes": [
            "#include \"aops.h\"",
            "#include \"mft.h\"",
            "#include \"attrib.h\"",
            "#include \"inode.h\"",
            "#include \"layout.h\"",
            "#include \"types.h\"",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"aops.h\"\n#include \"mft.h\"\n#include \"attrib.h\"\n#include \"inode.h\"\n#include \"layout.h\"\n#include \"types.h\"\n#include <linux/fs.h>\n\nstatic inline void ntfs_index_entry_flush_dcache_page(ntfs_index_context *ictx)\n{\n\tif (ictx->is_in_root)\n\t\tflush_dcache_mft_record_page(ictx->actx->ntfs_ino);\n\telse\n\t\tflush_dcache_page(ictx->page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "handle_bounds_compressed_page",
          "args": [
            "dp",
            "i_size",
            "initialized_size"
          ],
          "line": 235
        },
        "resolved": true,
        "details": {
          "function_name": "handle_bounds_compressed_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/compress.c",
          "lines": "123-130",
          "snippet": "static inline void handle_bounds_compressed_page(struct page *page,\n\t\tconst loff_t i_size, const s64 initialized_size)\n{\n\tif ((page->index >= (initialized_size >> PAGE_CACHE_SHIFT)) &&\n\t\t\t(initialized_size < i_size))\n\t\tzero_partial_compressed_page(page, initialized_size);\n\treturn;\n}",
          "includes": [
            "#include \"ntfs.h\"",
            "#include \"debug.h\"",
            "#include \"inode.h\"",
            "#include \"attrib.h\"",
            "#include <linux/slab.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ntfs.h\"\n#include \"debug.h\"\n#include \"inode.h\"\n#include \"attrib.h\"\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n\nstatic inline void handle_bounds_compressed_page(struct page *page,\n\t\tconst loff_t i_size, const s64 initialized_size)\n{\n\tif ((page->index >= (initialized_size >> PAGE_CACHE_SHIFT)) &&\n\t\t\t(initialized_size < i_size))\n\t\tzero_partial_compressed_page(page, initialized_size);\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&ntfs_cb_lock"
          ],
          "line": 224
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "ntfs_debug",
          "args": [
            "\"Beginning sub-block at offset = 0x%zx in the cb.\"",
            "cb - cb_start"
          ],
          "line": 207
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_debug",
          "args": [
            "\"Entering, cb_size = 0x%x.\"",
            "cb_size"
          ],
          "line": 205
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ntfs.h\"\n#include \"debug.h\"\n#include \"inode.h\"\n#include \"attrib.h\"\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n\nstatic DEFINE_SPINLOCK(ntfs_cb_lock);\n\nstatic int ntfs_decompress(struct page *dest_pages[], int *dest_index,\n\t\tint *dest_ofs, const int dest_max_index, const int dest_max_ofs,\n\t\tconst int xpage, char *xpage_done, u8 *const cb_start,\n\t\tconst u32 cb_size, const loff_t i_size,\n\t\tconst s64 initialized_size)\n{\n\t/*\n\t * Pointers into the compressed data, i.e. the compression block (cb),\n\t * and the therein contained sub-blocks (sb).\n\t */\n\tu8 *cb_end = cb_start + cb_size; /* End of cb. */\n\tu8 *cb = cb_start;\t/* Current position in cb. */\n\tu8 *cb_sb_start = cb;\t/* Beginning of the current sb in the cb. */\n\tu8 *cb_sb_end;\t\t/* End of current sb / beginning of next sb. */\n\n\t/* Variables for uncompressed data / destination. */\n\tstruct page *dp;\t/* Current destination page being worked on. */\n\tu8 *dp_addr;\t\t/* Current pointer into dp. */\n\tu8 *dp_sb_start;\t/* Start of current sub-block in dp. */\n\tu8 *dp_sb_end;\t\t/* End of current sb in dp (dp_sb_start +\n\t\t\t\t   NTFS_SB_SIZE). */\n\tu16 do_sb_start;\t/* @dest_ofs when starting this sub-block. */\n\tu16 do_sb_end;\t\t/* @dest_ofs of end of this sb (do_sb_start +\n\t\t\t\t   NTFS_SB_SIZE). */\n\n\t/* Variables for tag and token parsing. */\n\tu8 tag;\t\t\t/* Current tag. */\n\tint token;\t\t/* Loop counter for the eight tokens in tag. */\n\n\t/* Need this because we can't sleep, so need two stages. */\n\tint completed_pages[dest_max_index - *dest_index + 1];\n\tint nr_completed_pages = 0;\n\n\t/* Default error code. */\n\tint err = -EOVERFLOW;\n\n\tntfs_debug(\"Entering, cb_size = 0x%x.\", cb_size);\ndo_next_sb:\n\tntfs_debug(\"Beginning sub-block at offset = 0x%zx in the cb.\",\n\t\t\tcb - cb_start);\n\t/*\n\t * Have we reached the end of the compression block or the end of the\n\t * decompressed data?  The latter can happen for example if the current\n\t * position in the compression block is one byte before its end so the\n\t * first two checks do not detect it.\n\t */\n\tif (cb == cb_end || !le16_to_cpup((le16*)cb) ||\n\t\t\t(*dest_index == dest_max_index &&\n\t\t\t*dest_ofs == dest_max_ofs)) {\n\t\tint i;\n\n\t\tntfs_debug(\"Completed. Returning success (0).\");\n\t\terr = 0;\nreturn_error:\n\t\t/* We can sleep from now on, so we drop lock. */\n\t\tspin_unlock(&ntfs_cb_lock);\n\t\t/* Second stage: finalize completed pages. */\n\t\tif (nr_completed_pages > 0) {\n\t\t\tfor (i = 0; i < nr_completed_pages; i++) {\n\t\t\t\tint di = completed_pages[i];\n\n\t\t\t\tdp = dest_pages[di];\n\t\t\t\t/*\n\t\t\t\t * If we are outside the initialized size, zero\n\t\t\t\t * the out of bounds page range.\n\t\t\t\t */\n\t\t\t\thandle_bounds_compressed_page(dp, i_size,\n\t\t\t\t\t\tinitialized_size);\n\t\t\t\tflush_dcache_page(dp);\n\t\t\t\tkunmap(dp);\n\t\t\t\tSetPageUptodate(dp);\n\t\t\t\tunlock_page(dp);\n\t\t\t\tif (di == xpage)\n\t\t\t\t\t*xpage_done = 1;\n\t\t\t\telse\n\t\t\t\t\tpage_cache_release(dp);\n\t\t\t\tdest_pages[di] = NULL;\n\t\t\t}\n\t\t}\n\t\treturn err;\n\t}\n\n\t/* Setup offsets for the current sub-block destination. */\n\tdo_sb_start = *dest_ofs;\n\tdo_sb_end = do_sb_start + NTFS_SB_SIZE;\n\n\t/* Check that we are still within allowed boundaries. */\n\tif (*dest_index == dest_max_index && do_sb_end > dest_max_ofs)\n\t\tgoto return_overflow;\n\n\t/* Does the minimum size of a compressed sb overflow valid range? */\n\tif (cb + 6 > cb_end)\n\t\tgoto return_overflow;\n\n\t/* Setup the current sub-block source pointers and validate range. */\n\tcb_sb_start = cb;\n\tcb_sb_end = cb_sb_start + (le16_to_cpup((le16*)cb) & NTFS_SB_SIZE_MASK)\n\t\t\t+ 3;\n\tif (cb_sb_end > cb_end)\n\t\tgoto return_overflow;\n\n\t/* Get the current destination page. */\n\tdp = dest_pages[*dest_index];\n\tif (!dp) {\n\t\t/* No page present. Skip decompression of this sub-block. */\n\t\tcb = cb_sb_end;\n\n\t\t/* Advance destination position to next sub-block. */\n\t\t*dest_ofs = (*dest_ofs + NTFS_SB_SIZE) & ~PAGE_CACHE_MASK;\n\t\tif (!*dest_ofs && (++*dest_index > dest_max_index))\n\t\t\tgoto return_overflow;\n\t\tgoto do_next_sb;\n\t}\n\n\t/* We have a valid destination page. Setup the destination pointers. */\n\tdp_addr = (u8*)page_address(dp) + do_sb_start;\n\n\t/* Now, we are ready to process the current sub-block (sb). */\n\tif (!(le16_to_cpup((le16*)cb) & NTFS_SB_IS_COMPRESSED)) {\n\t\tntfs_debug(\"Found uncompressed sub-block.\");\n\t\t/* This sb is not compressed, just copy it into destination. */\n\n\t\t/* Advance source position to first data byte. */\n\t\tcb += 2;\n\n\t\t/* An uncompressed sb must be full size. */\n\t\tif (cb_sb_end - cb != NTFS_SB_SIZE)\n\t\t\tgoto return_overflow;\n\n\t\t/* Copy the block and advance the source position. */\n\t\tmemcpy(dp_addr, cb, NTFS_SB_SIZE);\n\t\tcb += NTFS_SB_SIZE;\n\n\t\t/* Advance destination position to next sub-block. */\n\t\t*dest_ofs += NTFS_SB_SIZE;\n\t\tif (!(*dest_ofs &= ~PAGE_CACHE_MASK)) {\nfinalize_page:\n\t\t\t/*\n\t\t\t * First stage: add current page index to array of\n\t\t\t * completed pages.\n\t\t\t */\n\t\t\tcompleted_pages[nr_completed_pages++] = *dest_index;\n\t\t\tif (++*dest_index > dest_max_index)\n\t\t\t\tgoto return_overflow;\n\t\t}\n\t\tgoto do_next_sb;\n\t}\n\tntfs_debug(\"Found compressed sub-block.\");\n\t/* This sb is compressed, decompress it into destination. */\n\n\t/* Setup destination pointers. */\n\tdp_sb_start = dp_addr;\n\tdp_sb_end = dp_sb_start + NTFS_SB_SIZE;\n\n\t/* Forward to the first tag in the sub-block. */\n\tcb += 2;\ndo_next_tag:\n\tif (cb == cb_sb_end) {\n\t\t/* Check if the decompressed sub-block was not full-length. */\n\t\tif (dp_addr < dp_sb_end) {\n\t\t\tint nr_bytes = do_sb_end - *dest_ofs;\n\n\t\t\tntfs_debug(\"Filling incomplete sub-block with \"\n\t\t\t\t\t\"zeroes.\");\n\t\t\t/* Zero remainder and update destination position. */\n\t\t\tmemset(dp_addr, 0, nr_bytes);\n\t\t\t*dest_ofs += nr_bytes;\n\t\t}\n\t\t/* We have finished the current sub-block. */\n\t\tif (!(*dest_ofs &= ~PAGE_CACHE_MASK))\n\t\t\tgoto finalize_page;\n\t\tgoto do_next_sb;\n\t}\n\n\t/* Check we are still in range. */\n\tif (cb > cb_sb_end || dp_addr > dp_sb_end)\n\t\tgoto return_overflow;\n\n\t/* Get the next tag and advance to first token. */\n\ttag = *cb++;\n\n\t/* Parse the eight tokens described by the tag. */\n\tfor (token = 0; token < 8; token++, tag >>= 1) {\n\t\tu16 lg, pt, length, max_non_overlap;\n\t\tregister u16 i;\n\t\tu8 *dp_back_addr;\n\n\t\t/* Check if we are done / still in range. */\n\t\tif (cb >= cb_sb_end || dp_addr > dp_sb_end)\n\t\t\tbreak;\n\n\t\t/* Determine token type and parse appropriately.*/\n\t\tif ((tag & NTFS_TOKEN_MASK) == NTFS_SYMBOL_TOKEN) {\n\t\t\t/*\n\t\t\t * We have a symbol token, copy the symbol across, and\n\t\t\t * advance the source and destination positions.\n\t\t\t */\n\t\t\t*dp_addr++ = *cb++;\n\t\t\t++*dest_ofs;\n\n\t\t\t/* Continue with the next token. */\n\t\t\tcontinue;\n\t\t}\n\n\t\t/*\n\t\t * We have a phrase token. Make sure it is not the first tag in\n\t\t * the sb as this is illegal and would confuse the code below.\n\t\t */\n\t\tif (dp_addr == dp_sb_start)\n\t\t\tgoto return_overflow;\n\n\t\t/*\n\t\t * Determine the number of bytes to go back (p) and the number\n\t\t * of bytes to copy (l). We use an optimized algorithm in which\n\t\t * we first calculate log2(current destination position in sb),\n\t\t * which allows determination of l and p in O(1) rather than\n\t\t * O(n). We just need an arch-optimized log2() function now.\n\t\t */\n\t\tlg = 0;\n\t\tfor (i = *dest_ofs - do_sb_start - 1; i >= 0x10; i >>= 1)\n\t\t\tlg++;\n\n\t\t/* Get the phrase token into i. */\n\t\tpt = le16_to_cpup((le16*)cb);\n\n\t\t/*\n\t\t * Calculate starting position of the byte sequence in\n\t\t * the destination using the fact that p = (pt >> (12 - lg)) + 1\n\t\t * and make sure we don't go too far back.\n\t\t */\n\t\tdp_back_addr = dp_addr - (pt >> (12 - lg)) - 1;\n\t\tif (dp_back_addr < dp_sb_start)\n\t\t\tgoto return_overflow;\n\n\t\t/* Now calculate the length of the byte sequence. */\n\t\tlength = (pt & (0xfff >> lg)) + 3;\n\n\t\t/* Advance destination position and verify it is in range. */\n\t\t*dest_ofs += length;\n\t\tif (*dest_ofs > do_sb_end)\n\t\t\tgoto return_overflow;\n\n\t\t/* The number of non-overlapping bytes. */\n\t\tmax_non_overlap = dp_addr - dp_back_addr;\n\n\t\tif (length <= max_non_overlap) {\n\t\t\t/* The byte sequence doesn't overlap, just copy it. */\n\t\t\tmemcpy(dp_addr, dp_back_addr, length);\n\n\t\t\t/* Advance destination pointer. */\n\t\t\tdp_addr += length;\n\t\t} else {\n\t\t\t/*\n\t\t\t * The byte sequence does overlap, copy non-overlapping\n\t\t\t * part and then do a slow byte by byte copy for the\n\t\t\t * overlapping part. Also, advance the destination\n\t\t\t * pointer.\n\t\t\t */\n\t\t\tmemcpy(dp_addr, dp_back_addr, max_non_overlap);\n\t\t\tdp_addr += max_non_overlap;\n\t\t\tdp_back_addr += max_non_overlap;\n\t\t\tlength -= max_non_overlap;\n\t\t\twhile (length--)\n\t\t\t\t*dp_addr++ = *dp_back_addr++;\n\t\t}\n\n\t\t/* Advance source position and continue with the next token. */\n\t\tcb += 2;\n\t}\n\n\t/* No tokens left in the current tag. Continue with the next tag. */\n\tgoto do_next_tag;\n\nreturn_overflow:\n\tntfs_error(NULL, \"Failed. Returning -EOVERFLOW.\");\n\tgoto return_error;\n}"
  },
  {
    "function_name": "handle_bounds_compressed_page",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/compress.c",
    "lines": "123-130",
    "snippet": "static inline void handle_bounds_compressed_page(struct page *page,\n\t\tconst loff_t i_size, const s64 initialized_size)\n{\n\tif ((page->index >= (initialized_size >> PAGE_CACHE_SHIFT)) &&\n\t\t\t(initialized_size < i_size))\n\t\tzero_partial_compressed_page(page, initialized_size);\n\treturn;\n}",
    "includes": [
      "#include \"ntfs.h\"",
      "#include \"debug.h\"",
      "#include \"inode.h\"",
      "#include \"attrib.h\"",
      "#include <linux/slab.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "zero_partial_compressed_page",
          "args": [
            "page",
            "initialized_size"
          ],
          "line": 128
        },
        "resolved": true,
        "details": {
          "function_name": "zero_partial_compressed_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/compress.c",
          "lines": "100-118",
          "snippet": "static void zero_partial_compressed_page(struct page *page,\n\t\tconst s64 initialized_size)\n{\n\tu8 *kp = page_address(page);\n\tunsigned int kp_ofs;\n\n\tntfs_debug(\"Zeroing page region outside initialized size.\");\n\tif (((s64)page->index << PAGE_CACHE_SHIFT) >= initialized_size) {\n\t\t/*\n\t\t * FIXME: Using clear_page() will become wrong when we get\n\t\t * PAGE_CACHE_SIZE != PAGE_SIZE but for now there is no problem.\n\t\t */\n\t\tclear_page(kp);\n\t\treturn;\n\t}\n\tkp_ofs = initialized_size & ~PAGE_CACHE_MASK;\n\tmemset(kp + kp_ofs, 0, PAGE_CACHE_SIZE - kp_ofs);\n\treturn;\n}",
          "includes": [
            "#include \"ntfs.h\"",
            "#include \"debug.h\"",
            "#include \"inode.h\"",
            "#include \"attrib.h\"",
            "#include <linux/slab.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ntfs.h\"\n#include \"debug.h\"\n#include \"inode.h\"\n#include \"attrib.h\"\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n\nstatic void zero_partial_compressed_page(struct page *page,\n\t\tconst s64 initialized_size)\n{\n\tu8 *kp = page_address(page);\n\tunsigned int kp_ofs;\n\n\tntfs_debug(\"Zeroing page region outside initialized size.\");\n\tif (((s64)page->index << PAGE_CACHE_SHIFT) >= initialized_size) {\n\t\t/*\n\t\t * FIXME: Using clear_page() will become wrong when we get\n\t\t * PAGE_CACHE_SIZE != PAGE_SIZE but for now there is no problem.\n\t\t */\n\t\tclear_page(kp);\n\t\treturn;\n\t}\n\tkp_ofs = initialized_size & ~PAGE_CACHE_MASK;\n\tmemset(kp + kp_ofs, 0, PAGE_CACHE_SIZE - kp_ofs);\n\treturn;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ntfs.h\"\n#include \"debug.h\"\n#include \"inode.h\"\n#include \"attrib.h\"\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n\nstatic inline void handle_bounds_compressed_page(struct page *page,\n\t\tconst loff_t i_size, const s64 initialized_size)\n{\n\tif ((page->index >= (initialized_size >> PAGE_CACHE_SHIFT)) &&\n\t\t\t(initialized_size < i_size))\n\t\tzero_partial_compressed_page(page, initialized_size);\n\treturn;\n}"
  },
  {
    "function_name": "zero_partial_compressed_page",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/compress.c",
    "lines": "100-118",
    "snippet": "static void zero_partial_compressed_page(struct page *page,\n\t\tconst s64 initialized_size)\n{\n\tu8 *kp = page_address(page);\n\tunsigned int kp_ofs;\n\n\tntfs_debug(\"Zeroing page region outside initialized size.\");\n\tif (((s64)page->index << PAGE_CACHE_SHIFT) >= initialized_size) {\n\t\t/*\n\t\t * FIXME: Using clear_page() will become wrong when we get\n\t\t * PAGE_CACHE_SIZE != PAGE_SIZE but for now there is no problem.\n\t\t */\n\t\tclear_page(kp);\n\t\treturn;\n\t}\n\tkp_ofs = initialized_size & ~PAGE_CACHE_MASK;\n\tmemset(kp + kp_ofs, 0, PAGE_CACHE_SIZE - kp_ofs);\n\treturn;\n}",
    "includes": [
      "#include \"ntfs.h\"",
      "#include \"debug.h\"",
      "#include \"inode.h\"",
      "#include \"attrib.h\"",
      "#include <linux/slab.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "kp + kp_ofs",
            "0",
            "PAGE_CACHE_SIZE - kp_ofs"
          ],
          "line": 116
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clear_page",
          "args": [
            "kp"
          ],
          "line": 112
        },
        "resolved": true,
        "details": {
          "function_name": "__clear_page_buffers",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "123-129",
          "snippet": "static void\n__clear_page_buffers(struct page *page)\n{\n\tClearPagePrivate(page);\n\tset_page_private(page, 0);\n\tpage_cache_release(page);\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nstatic void\n__clear_page_buffers(struct page *page)\n{\n\tClearPagePrivate(page);\n\tset_page_private(page, 0);\n\tpage_cache_release(page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ntfs_debug",
          "args": [
            "\"Zeroing page region outside initialized size.\""
          ],
          "line": 106
        },
        "resolved": true,
        "details": {
          "function_name": "ntfs_debug_dump_runlist",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/debug.c",
          "lines": "134-171",
          "snippet": "void ntfs_debug_dump_runlist(const runlist_element *rl)\n{\n\tint i;\n\tconst char *lcn_str[5] = { \"LCN_HOLE         \", \"LCN_RL_NOT_MAPPED\",\n\t\t\t\t   \"LCN_ENOENT       \", \"LCN_unknown      \" };\n\n\tif (!debug_msgs)\n\t\treturn;\n\tpr_debug(\"Dumping runlist (values in hex):\\n\");\n\tif (!rl) {\n\t\tpr_debug(\"Run list not present.\\n\");\n\t\treturn;\n\t}\n\tpr_debug(\"VCN              LCN               Run length\\n\");\n\tfor (i = 0; ; i++) {\n\t\tLCN lcn = (rl + i)->lcn;\n\n\t\tif (lcn < (LCN)0) {\n\t\t\tint index = -lcn - 1;\n\n\t\t\tif (index > -LCN_ENOENT - 1)\n\t\t\t\tindex = 3;\n\t\t\tpr_debug(\"%-16Lx %s %-16Lx%s\\n\",\n\t\t\t\t\t(long long)(rl + i)->vcn, lcn_str[index],\n\t\t\t\t\t(long long)(rl + i)->length,\n\t\t\t\t\t(rl + i)->length ? \"\" :\n\t\t\t\t\t\t\" (runlist end)\");\n\t\t} else\n\t\t\tpr_debug(\"%-16Lx %-16Lx  %-16Lx%s\\n\",\n\t\t\t\t\t(long long)(rl + i)->vcn,\n\t\t\t\t\t(long long)(rl + i)->lcn,\n\t\t\t\t\t(long long)(rl + i)->length,\n\t\t\t\t\t(rl + i)->length ? \"\" :\n\t\t\t\t\t\t\" (runlist end)\");\n\t\tif (!(rl + i)->length)\n\t\t\tbreak;\n\t}\n}",
          "includes": [
            "#include \"debug.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"debug.h\"\n\nvoid ntfs_debug_dump_runlist(const runlist_element *rl)\n{\n\tint i;\n\tconst char *lcn_str[5] = { \"LCN_HOLE         \", \"LCN_RL_NOT_MAPPED\",\n\t\t\t\t   \"LCN_ENOENT       \", \"LCN_unknown      \" };\n\n\tif (!debug_msgs)\n\t\treturn;\n\tpr_debug(\"Dumping runlist (values in hex):\\n\");\n\tif (!rl) {\n\t\tpr_debug(\"Run list not present.\\n\");\n\t\treturn;\n\t}\n\tpr_debug(\"VCN              LCN               Run length\\n\");\n\tfor (i = 0; ; i++) {\n\t\tLCN lcn = (rl + i)->lcn;\n\n\t\tif (lcn < (LCN)0) {\n\t\t\tint index = -lcn - 1;\n\n\t\t\tif (index > -LCN_ENOENT - 1)\n\t\t\t\tindex = 3;\n\t\t\tpr_debug(\"%-16Lx %s %-16Lx%s\\n\",\n\t\t\t\t\t(long long)(rl + i)->vcn, lcn_str[index],\n\t\t\t\t\t(long long)(rl + i)->length,\n\t\t\t\t\t(rl + i)->length ? \"\" :\n\t\t\t\t\t\t\" (runlist end)\");\n\t\t} else\n\t\t\tpr_debug(\"%-16Lx %-16Lx  %-16Lx%s\\n\",\n\t\t\t\t\t(long long)(rl + i)->vcn,\n\t\t\t\t\t(long long)(rl + i)->lcn,\n\t\t\t\t\t(long long)(rl + i)->length,\n\t\t\t\t\t(rl + i)->length ? \"\" :\n\t\t\t\t\t\t\" (runlist end)\");\n\t\tif (!(rl + i)->length)\n\t\t\tbreak;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "page_address",
          "args": [
            "page"
          ],
          "line": 103
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ntfs.h\"\n#include \"debug.h\"\n#include \"inode.h\"\n#include \"attrib.h\"\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n\nstatic void zero_partial_compressed_page(struct page *page,\n\t\tconst s64 initialized_size)\n{\n\tu8 *kp = page_address(page);\n\tunsigned int kp_ofs;\n\n\tntfs_debug(\"Zeroing page region outside initialized size.\");\n\tif (((s64)page->index << PAGE_CACHE_SHIFT) >= initialized_size) {\n\t\t/*\n\t\t * FIXME: Using clear_page() will become wrong when we get\n\t\t * PAGE_CACHE_SIZE != PAGE_SIZE but for now there is no problem.\n\t\t */\n\t\tclear_page(kp);\n\t\treturn;\n\t}\n\tkp_ofs = initialized_size & ~PAGE_CACHE_MASK;\n\tmemset(kp + kp_ofs, 0, PAGE_CACHE_SIZE - kp_ofs);\n\treturn;\n}"
  },
  {
    "function_name": "free_compression_buffers",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/compress.c",
    "lines": "90-95",
    "snippet": "void free_compression_buffers(void)\n{\n\tBUG_ON(!ntfs_compression_buffer);\n\tvfree(ntfs_compression_buffer);\n\tntfs_compression_buffer = NULL;\n}",
    "includes": [
      "#include \"ntfs.h\"",
      "#include \"debug.h\"",
      "#include \"inode.h\"",
      "#include \"attrib.h\"",
      "#include <linux/slab.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static u8 *ntfs_compression_buffer;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "vfree",
          "args": [
            "ntfs_compression_buffer"
          ],
          "line": 93
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!ntfs_compression_buffer"
          ],
          "line": 92
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ntfs.h\"\n#include \"debug.h\"\n#include \"inode.h\"\n#include \"attrib.h\"\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n\nstatic u8 *ntfs_compression_buffer;\n\nvoid free_compression_buffers(void)\n{\n\tBUG_ON(!ntfs_compression_buffer);\n\tvfree(ntfs_compression_buffer);\n\tntfs_compression_buffer = NULL;\n}"
  },
  {
    "function_name": "allocate_compression_buffers",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/compress.c",
    "lines": "75-83",
    "snippet": "int allocate_compression_buffers(void)\n{\n\tBUG_ON(ntfs_compression_buffer);\n\n\tntfs_compression_buffer = vmalloc(NTFS_MAX_CB_SIZE);\n\tif (!ntfs_compression_buffer)\n\t\treturn -ENOMEM;\n\treturn 0;\n}",
    "includes": [
      "#include \"ntfs.h\"",
      "#include \"debug.h\"",
      "#include \"inode.h\"",
      "#include \"attrib.h\"",
      "#include <linux/slab.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static u8 *ntfs_compression_buffer;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "vmalloc",
          "args": [
            "NTFS_MAX_CB_SIZE"
          ],
          "line": 79
        },
        "resolved": true,
        "details": {
          "function_name": "ffs2_blocks_use_vmalloc(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jffs2/nodelist.h",
          "lines": "292-295",
          "snippet": "tatic inline int jffs2_blocks_use_vmalloc(struct jffs2_sb_info *c)\n{\n\treturn ((c->flash_size / c->sector_size) * sizeof (struct jffs2_eraseblock)) > (128 * 1024);\n}",
          "includes": [
            "include \"debug.h\"",
            "include \"os-linux.h\"\n#",
            "include \"os-ecos.h\"\n#",
            "include \"summary.h\"",
            "include \"acl.h\"\n#",
            "include \"xattr.h\"\n#",
            "include \"jffs2_fs_i.h\"\n#",
            "include \"jffs2_fs_sb.h\"\n#",
            "include <linux/jffs2.h>\n#",
            "include <linux/types.h>\n#",
            "include <linux/fs.h>\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"debug.h\"\ninclude \"os-linux.h\"\n#\ninclude \"os-ecos.h\"\n#\ninclude \"summary.h\"\ninclude \"acl.h\"\n#\ninclude \"xattr.h\"\n#\ninclude \"jffs2_fs_i.h\"\n#\ninclude \"jffs2_fs_sb.h\"\n#\ninclude <linux/jffs2.h>\n#\ninclude <linux/types.h>\n#\ninclude <linux/fs.h>\n#\n\ntatic inline int jffs2_blocks_use_vmalloc(struct jffs2_sb_info *c)\n{\n\treturn ((c->flash_size / c->sector_size) * sizeof (struct jffs2_eraseblock)) > (128 * 1024);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "ntfs_compression_buffer"
          ],
          "line": 77
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ntfs.h\"\n#include \"debug.h\"\n#include \"inode.h\"\n#include \"attrib.h\"\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n\nstatic u8 *ntfs_compression_buffer;\n\nint allocate_compression_buffers(void)\n{\n\tBUG_ON(ntfs_compression_buffer);\n\n\tntfs_compression_buffer = vmalloc(NTFS_MAX_CB_SIZE);\n\tif (!ntfs_compression_buffer)\n\t\treturn -ENOMEM;\n\treturn 0;\n}"
  }
]