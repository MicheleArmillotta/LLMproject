[
  {
    "function_name": "efivarfs_unlink",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/efivarfs/inode.c",
    "lines": "146-156",
    "snippet": "static int efivarfs_unlink(struct inode *dir, struct dentry *dentry)\n{\n\tstruct efivar_entry *var = dentry->d_inode->i_private;\n\n\tif (efivar_entry_delete(var))\n\t\treturn -EINVAL;\n\n\tdrop_nlink(dentry->d_inode);\n\tdput(dentry);\n\treturn 0;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/slab.h>",
      "#include <linux/ctype.h>",
      "#include <linux/fs.h>",
      "#include <linux/efi.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "dput",
          "args": [
            "dentry"
          ],
          "line": 154
        },
        "resolved": true,
        "details": {
          "function_name": "dput",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "726-762",
          "snippet": "void dput(struct dentry *dentry)\n{\n\tif (unlikely(!dentry))\n\t\treturn;\n\nrepeat:\n\trcu_read_lock();\n\tif (likely(fast_dput(dentry))) {\n\t\trcu_read_unlock();\n\t\treturn;\n\t}\n\n\t/* Slow case: now with the dentry lock held */\n\trcu_read_unlock();\n\n\t/* Unreachable? Get rid of it */\n\tif (unlikely(d_unhashed(dentry)))\n\t\tgoto kill_it;\n\n\tif (unlikely(dentry->d_flags & DCACHE_OP_DELETE)) {\n\t\tif (dentry->d_op->d_delete(dentry))\n\t\t\tgoto kill_it;\n\t}\n\n\tif (!(dentry->d_flags & DCACHE_REFERENCED))\n\t\tdentry->d_flags |= DCACHE_REFERENCED;\n\tdentry_lru_add(dentry);\n\n\tdentry->d_lockref.count--;\n\tspin_unlock(&dentry->d_lock);\n\treturn;\n\nkill_it:\n\tdentry = dentry_kill(dentry);\n\tif (dentry)\n\t\tgoto repeat;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nvoid dput(struct dentry *dentry)\n{\n\tif (unlikely(!dentry))\n\t\treturn;\n\nrepeat:\n\trcu_read_lock();\n\tif (likely(fast_dput(dentry))) {\n\t\trcu_read_unlock();\n\t\treturn;\n\t}\n\n\t/* Slow case: now with the dentry lock held */\n\trcu_read_unlock();\n\n\t/* Unreachable? Get rid of it */\n\tif (unlikely(d_unhashed(dentry)))\n\t\tgoto kill_it;\n\n\tif (unlikely(dentry->d_flags & DCACHE_OP_DELETE)) {\n\t\tif (dentry->d_op->d_delete(dentry))\n\t\t\tgoto kill_it;\n\t}\n\n\tif (!(dentry->d_flags & DCACHE_REFERENCED))\n\t\tdentry->d_flags |= DCACHE_REFERENCED;\n\tdentry_lru_add(dentry);\n\n\tdentry->d_lockref.count--;\n\tspin_unlock(&dentry->d_lock);\n\treturn;\n\nkill_it:\n\tdentry = dentry_kill(dentry);\n\tif (dentry)\n\t\tgoto repeat;\n}"
        }
      },
      {
        "call_info": {
          "callee": "drop_nlink",
          "args": [
            "dentry->d_inode"
          ],
          "line": 153
        },
        "resolved": true,
        "details": {
          "function_name": "drop_nlink",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "271-277",
          "snippet": "void drop_nlink(struct inode *inode)\n{\n\tWARN_ON(inode->i_nlink == 0);\n\tinode->__i_nlink--;\n\tif (!inode->i_nlink)\n\t\tatomic_long_inc(&inode->i_sb->s_remove_count);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid drop_nlink(struct inode *inode)\n{\n\tWARN_ON(inode->i_nlink == 0);\n\tinode->__i_nlink--;\n\tif (!inode->i_nlink)\n\t\tatomic_long_inc(&inode->i_sb->s_remove_count);\n}"
        }
      },
      {
        "call_info": {
          "callee": "efivar_entry_delete",
          "args": [
            "var"
          ],
          "line": 150
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/slab.h>\n#include <linux/ctype.h>\n#include <linux/fs.h>\n#include <linux/efi.h>\n\nstatic int efivarfs_unlink(struct inode *dir, struct dentry *dentry)\n{\n\tstruct efivar_entry *var = dentry->d_inode->i_private;\n\n\tif (efivar_entry_delete(var))\n\t\treturn -EINVAL;\n\n\tdrop_nlink(dentry->d_inode);\n\tdput(dentry);\n\treturn 0;\n}"
  },
  {
    "function_name": "efivarfs_create",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/efivarfs/inode.c",
    "lines": "102-144",
    "snippet": "static int efivarfs_create(struct inode *dir, struct dentry *dentry,\n\t\t\t  umode_t mode, bool excl)\n{\n\tstruct inode *inode;\n\tstruct efivar_entry *var;\n\tint namelen, i = 0, err = 0;\n\n\tif (!efivarfs_valid_name(dentry->d_name.name, dentry->d_name.len))\n\t\treturn -EINVAL;\n\n\tinode = efivarfs_get_inode(dir->i_sb, dir, mode, 0);\n\tif (!inode)\n\t\treturn -ENOMEM;\n\n\tvar = kzalloc(sizeof(struct efivar_entry), GFP_KERNEL);\n\tif (!var) {\n\t\terr = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\t/* length of the variable name itself: remove GUID and separator */\n\tnamelen = dentry->d_name.len - EFI_VARIABLE_GUID_LEN - 1;\n\n\tefivarfs_hex_to_guid(dentry->d_name.name + namelen + 1,\n\t\t\t&var->var.VendorGuid);\n\n\tfor (i = 0; i < namelen; i++)\n\t\tvar->var.VariableName[i] = dentry->d_name.name[i];\n\n\tvar->var.VariableName[i] = '\\0';\n\n\tinode->i_private = var;\n\n\tefivar_entry_add(var, &efivarfs_list);\n\td_instantiate(dentry, inode);\n\tdget(dentry);\nout:\n\tif (err) {\n\t\tkfree(var);\n\t\tiput(inode);\n\t}\n\treturn err;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/slab.h>",
      "#include <linux/ctype.h>",
      "#include <linux/fs.h>",
      "#include <linux/efi.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "iput",
          "args": [
            "inode"
          ],
          "line": 141
        },
        "resolved": true,
        "details": {
          "function_name": "iput",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "1471-1488",
          "snippet": "void iput(struct inode *inode)\n{\n\tif (!inode)\n\t\treturn;\n\tBUG_ON(inode->i_state & I_CLEAR);\nretry:\n\tif (atomic_dec_and_lock(&inode->i_count, &inode->i_lock)) {\n\t\tif (inode->i_nlink && (inode->i_state & I_DIRTY_TIME)) {\n\t\t\tatomic_inc(&inode->i_count);\n\t\t\tinode->i_state &= ~I_DIRTY_TIME;\n\t\t\tspin_unlock(&inode->i_lock);\n\t\t\ttrace_writeback_lazytime_iput(inode);\n\t\t\tmark_inode_dirty_sync(inode);\n\t\t\tgoto retry;\n\t\t}\n\t\tiput_final(inode);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid iput(struct inode *inode)\n{\n\tif (!inode)\n\t\treturn;\n\tBUG_ON(inode->i_state & I_CLEAR);\nretry:\n\tif (atomic_dec_and_lock(&inode->i_count, &inode->i_lock)) {\n\t\tif (inode->i_nlink && (inode->i_state & I_DIRTY_TIME)) {\n\t\t\tatomic_inc(&inode->i_count);\n\t\t\tinode->i_state &= ~I_DIRTY_TIME;\n\t\t\tspin_unlock(&inode->i_lock);\n\t\t\ttrace_writeback_lazytime_iput(inode);\n\t\t\tmark_inode_dirty_sync(inode);\n\t\t\tgoto retry;\n\t\t}\n\t\tiput_final(inode);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "var"
          ],
          "line": 140
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dget",
          "args": [
            "dentry"
          ],
          "line": 137
        },
        "resolved": true,
        "details": {
          "function_name": "dget_parent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "777-814",
          "snippet": "struct dentry *dget_parent(struct dentry *dentry)\n{\n\tint gotref;\n\tstruct dentry *ret;\n\n\t/*\n\t * Do optimistic parent lookup without any\n\t * locking.\n\t */\n\trcu_read_lock();\n\tret = ACCESS_ONCE(dentry->d_parent);\n\tgotref = lockref_get_not_zero(&ret->d_lockref);\n\trcu_read_unlock();\n\tif (likely(gotref)) {\n\t\tif (likely(ret == ACCESS_ONCE(dentry->d_parent)))\n\t\t\treturn ret;\n\t\tdput(ret);\n\t}\n\nrepeat:\n\t/*\n\t * Don't need rcu_dereference because we re-check it was correct under\n\t * the lock.\n\t */\n\trcu_read_lock();\n\tret = dentry->d_parent;\n\tspin_lock(&ret->d_lock);\n\tif (unlikely(ret != dentry->d_parent)) {\n\t\tspin_unlock(&ret->d_lock);\n\t\trcu_read_unlock();\n\t\tgoto repeat;\n\t}\n\trcu_read_unlock();\n\tBUG_ON(!ret->d_lockref.count);\n\tret->d_lockref.count++;\n\tspin_unlock(&ret->d_lock);\n\treturn ret;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nstruct dentry *dget_parent(struct dentry *dentry)\n{\n\tint gotref;\n\tstruct dentry *ret;\n\n\t/*\n\t * Do optimistic parent lookup without any\n\t * locking.\n\t */\n\trcu_read_lock();\n\tret = ACCESS_ONCE(dentry->d_parent);\n\tgotref = lockref_get_not_zero(&ret->d_lockref);\n\trcu_read_unlock();\n\tif (likely(gotref)) {\n\t\tif (likely(ret == ACCESS_ONCE(dentry->d_parent)))\n\t\t\treturn ret;\n\t\tdput(ret);\n\t}\n\nrepeat:\n\t/*\n\t * Don't need rcu_dereference because we re-check it was correct under\n\t * the lock.\n\t */\n\trcu_read_lock();\n\tret = dentry->d_parent;\n\tspin_lock(&ret->d_lock);\n\tif (unlikely(ret != dentry->d_parent)) {\n\t\tspin_unlock(&ret->d_lock);\n\t\trcu_read_unlock();\n\t\tgoto repeat;\n\t}\n\trcu_read_unlock();\n\tBUG_ON(!ret->d_lockref.count);\n\tret->d_lockref.count++;\n\tspin_unlock(&ret->d_lock);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "d_instantiate",
          "args": [
            "dentry",
            "inode"
          ],
          "line": 136
        },
        "resolved": true,
        "details": {
          "function_name": "d_instantiate_no_diralias",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "1839-1854",
          "snippet": "int d_instantiate_no_diralias(struct dentry *entry, struct inode *inode)\n{\n\tBUG_ON(!hlist_unhashed(&entry->d_u.d_alias));\n\n\tspin_lock(&inode->i_lock);\n\tif (S_ISDIR(inode->i_mode) && !hlist_empty(&inode->i_dentry)) {\n\t\tspin_unlock(&inode->i_lock);\n\t\tiput(inode);\n\t\treturn -EBUSY;\n\t}\n\t__d_instantiate(entry, inode);\n\tspin_unlock(&inode->i_lock);\n\tsecurity_d_instantiate(entry, inode);\n\n\treturn 0;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nint d_instantiate_no_diralias(struct dentry *entry, struct inode *inode)\n{\n\tBUG_ON(!hlist_unhashed(&entry->d_u.d_alias));\n\n\tspin_lock(&inode->i_lock);\n\tif (S_ISDIR(inode->i_mode) && !hlist_empty(&inode->i_dentry)) {\n\t\tspin_unlock(&inode->i_lock);\n\t\tiput(inode);\n\t\treturn -EBUSY;\n\t}\n\t__d_instantiate(entry, inode);\n\tspin_unlock(&inode->i_lock);\n\tsecurity_d_instantiate(entry, inode);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "efivar_entry_add",
          "args": [
            "var",
            "&efivarfs_list"
          ],
          "line": 135
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "efivarfs_hex_to_guid",
          "args": [
            "dentry->d_name.name + namelen + 1",
            "&var->var.VendorGuid"
          ],
          "line": 125
        },
        "resolved": true,
        "details": {
          "function_name": "efivarfs_hex_to_guid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/efivarfs/inode.c",
          "lines": "82-100",
          "snippet": "static void efivarfs_hex_to_guid(const char *str, efi_guid_t *guid)\n{\n\tguid->b[0] = hex_to_bin(str[6]) << 4 | hex_to_bin(str[7]);\n\tguid->b[1] = hex_to_bin(str[4]) << 4 | hex_to_bin(str[5]);\n\tguid->b[2] = hex_to_bin(str[2]) << 4 | hex_to_bin(str[3]);\n\tguid->b[3] = hex_to_bin(str[0]) << 4 | hex_to_bin(str[1]);\n\tguid->b[4] = hex_to_bin(str[11]) << 4 | hex_to_bin(str[12]);\n\tguid->b[5] = hex_to_bin(str[9]) << 4 | hex_to_bin(str[10]);\n\tguid->b[6] = hex_to_bin(str[16]) << 4 | hex_to_bin(str[17]);\n\tguid->b[7] = hex_to_bin(str[14]) << 4 | hex_to_bin(str[15]);\n\tguid->b[8] = hex_to_bin(str[19]) << 4 | hex_to_bin(str[20]);\n\tguid->b[9] = hex_to_bin(str[21]) << 4 | hex_to_bin(str[22]);\n\tguid->b[10] = hex_to_bin(str[24]) << 4 | hex_to_bin(str[25]);\n\tguid->b[11] = hex_to_bin(str[26]) << 4 | hex_to_bin(str[27]);\n\tguid->b[12] = hex_to_bin(str[28]) << 4 | hex_to_bin(str[29]);\n\tguid->b[13] = hex_to_bin(str[30]) << 4 | hex_to_bin(str[31]);\n\tguid->b[14] = hex_to_bin(str[32]) << 4 | hex_to_bin(str[33]);\n\tguid->b[15] = hex_to_bin(str[34]) << 4 | hex_to_bin(str[35]);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/ctype.h>",
            "#include <linux/fs.h>",
            "#include <linux/efi.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/slab.h>\n#include <linux/ctype.h>\n#include <linux/fs.h>\n#include <linux/efi.h>\n\nstatic void efivarfs_hex_to_guid(const char *str, efi_guid_t *guid)\n{\n\tguid->b[0] = hex_to_bin(str[6]) << 4 | hex_to_bin(str[7]);\n\tguid->b[1] = hex_to_bin(str[4]) << 4 | hex_to_bin(str[5]);\n\tguid->b[2] = hex_to_bin(str[2]) << 4 | hex_to_bin(str[3]);\n\tguid->b[3] = hex_to_bin(str[0]) << 4 | hex_to_bin(str[1]);\n\tguid->b[4] = hex_to_bin(str[11]) << 4 | hex_to_bin(str[12]);\n\tguid->b[5] = hex_to_bin(str[9]) << 4 | hex_to_bin(str[10]);\n\tguid->b[6] = hex_to_bin(str[16]) << 4 | hex_to_bin(str[17]);\n\tguid->b[7] = hex_to_bin(str[14]) << 4 | hex_to_bin(str[15]);\n\tguid->b[8] = hex_to_bin(str[19]) << 4 | hex_to_bin(str[20]);\n\tguid->b[9] = hex_to_bin(str[21]) << 4 | hex_to_bin(str[22]);\n\tguid->b[10] = hex_to_bin(str[24]) << 4 | hex_to_bin(str[25]);\n\tguid->b[11] = hex_to_bin(str[26]) << 4 | hex_to_bin(str[27]);\n\tguid->b[12] = hex_to_bin(str[28]) << 4 | hex_to_bin(str[29]);\n\tguid->b[13] = hex_to_bin(str[30]) << 4 | hex_to_bin(str[31]);\n\tguid->b[14] = hex_to_bin(str[32]) << 4 | hex_to_bin(str[33]);\n\tguid->b[15] = hex_to_bin(str[34]) << 4 | hex_to_bin(str[35]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(struct efivar_entry)",
            "GFP_KERNEL"
          ],
          "line": 116
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "efivarfs_get_inode",
          "args": [
            "dir->i_sb",
            "dir",
            "mode",
            "0"
          ],
          "line": 112
        },
        "resolved": true,
        "details": {
          "function_name": "efivarfs_get_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/efivarfs/inode.c",
          "lines": "17-38",
          "snippet": "struct inode *efivarfs_get_inode(struct super_block *sb,\n\t\t\t\tconst struct inode *dir, int mode, dev_t dev)\n{\n\tstruct inode *inode = new_inode(sb);\n\n\tif (inode) {\n\t\tinode->i_ino = get_next_ino();\n\t\tinode->i_mode = mode;\n\t\tinode->i_atime = inode->i_mtime = inode->i_ctime = CURRENT_TIME;\n\t\tswitch (mode & S_IFMT) {\n\t\tcase S_IFREG:\n\t\t\tinode->i_fop = &efivarfs_file_operations;\n\t\t\tbreak;\n\t\tcase S_IFDIR:\n\t\t\tinode->i_op = &efivarfs_dir_inode_operations;\n\t\t\tinode->i_fop = &simple_dir_operations;\n\t\t\tinc_nlink(inode);\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn inode;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/ctype.h>",
            "#include <linux/fs.h>",
            "#include <linux/efi.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "const struct inode_operations efivarfs_dir_inode_operations = {\n\t.lookup = simple_lookup,\n\t.unlink = efivarfs_unlink,\n\t.create = efivarfs_create,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/slab.h>\n#include <linux/ctype.h>\n#include <linux/fs.h>\n#include <linux/efi.h>\n\nconst struct inode_operations efivarfs_dir_inode_operations = {\n\t.lookup = simple_lookup,\n\t.unlink = efivarfs_unlink,\n\t.create = efivarfs_create,\n};\n\nstruct inode *efivarfs_get_inode(struct super_block *sb,\n\t\t\t\tconst struct inode *dir, int mode, dev_t dev)\n{\n\tstruct inode *inode = new_inode(sb);\n\n\tif (inode) {\n\t\tinode->i_ino = get_next_ino();\n\t\tinode->i_mode = mode;\n\t\tinode->i_atime = inode->i_mtime = inode->i_ctime = CURRENT_TIME;\n\t\tswitch (mode & S_IFMT) {\n\t\tcase S_IFREG:\n\t\t\tinode->i_fop = &efivarfs_file_operations;\n\t\t\tbreak;\n\t\tcase S_IFDIR:\n\t\t\tinode->i_op = &efivarfs_dir_inode_operations;\n\t\t\tinode->i_fop = &simple_dir_operations;\n\t\t\tinc_nlink(inode);\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn inode;\n}"
        }
      },
      {
        "call_info": {
          "callee": "efivarfs_valid_name",
          "args": [
            "dentry->d_name.name",
            "dentry->d_name.len"
          ],
          "line": 109
        },
        "resolved": true,
        "details": {
          "function_name": "efivarfs_valid_name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/efivarfs/inode.c",
          "lines": "45-80",
          "snippet": "bool efivarfs_valid_name(const char *str, int len)\n{\n\tstatic const char dashes[EFI_VARIABLE_GUID_LEN] = {\n\t\t[8] = 1, [13] = 1, [18] = 1, [23] = 1\n\t};\n\tconst char *s = str + len - EFI_VARIABLE_GUID_LEN;\n\tint i;\n\n\t/*\n\t * We need a GUID, plus at least one letter for the variable name,\n\t * plus the '-' separator\n\t */\n\tif (len < EFI_VARIABLE_GUID_LEN + 2)\n\t\treturn false;\n\n\t/* GUID must be preceded by a '-' */\n\tif (*(s - 1) != '-')\n\t\treturn false;\n\n\t/*\n\t * Validate that 's' is of the correct format, e.g.\n\t *\n\t *\t12345678-1234-1234-1234-123456789abc\n\t */\n\tfor (i = 0; i < EFI_VARIABLE_GUID_LEN; i++) {\n\t\tif (dashes[i]) {\n\t\t\tif (*s++ != '-')\n\t\t\t\treturn false;\n\t\t} else {\n\t\t\tif (!isxdigit(*s++))\n\t\t\t\treturn false;\n\t\t}\n\t}\n\n\treturn true;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/ctype.h>",
            "#include <linux/fs.h>",
            "#include <linux/efi.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/slab.h>\n#include <linux/ctype.h>\n#include <linux/fs.h>\n#include <linux/efi.h>\n\nbool efivarfs_valid_name(const char *str, int len)\n{\n\tstatic const char dashes[EFI_VARIABLE_GUID_LEN] = {\n\t\t[8] = 1, [13] = 1, [18] = 1, [23] = 1\n\t};\n\tconst char *s = str + len - EFI_VARIABLE_GUID_LEN;\n\tint i;\n\n\t/*\n\t * We need a GUID, plus at least one letter for the variable name,\n\t * plus the '-' separator\n\t */\n\tif (len < EFI_VARIABLE_GUID_LEN + 2)\n\t\treturn false;\n\n\t/* GUID must be preceded by a '-' */\n\tif (*(s - 1) != '-')\n\t\treturn false;\n\n\t/*\n\t * Validate that 's' is of the correct format, e.g.\n\t *\n\t *\t12345678-1234-1234-1234-123456789abc\n\t */\n\tfor (i = 0; i < EFI_VARIABLE_GUID_LEN; i++) {\n\t\tif (dashes[i]) {\n\t\t\tif (*s++ != '-')\n\t\t\t\treturn false;\n\t\t} else {\n\t\t\tif (!isxdigit(*s++))\n\t\t\t\treturn false;\n\t\t}\n\t}\n\n\treturn true;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/slab.h>\n#include <linux/ctype.h>\n#include <linux/fs.h>\n#include <linux/efi.h>\n\nstatic int efivarfs_create(struct inode *dir, struct dentry *dentry,\n\t\t\t  umode_t mode, bool excl)\n{\n\tstruct inode *inode;\n\tstruct efivar_entry *var;\n\tint namelen, i = 0, err = 0;\n\n\tif (!efivarfs_valid_name(dentry->d_name.name, dentry->d_name.len))\n\t\treturn -EINVAL;\n\n\tinode = efivarfs_get_inode(dir->i_sb, dir, mode, 0);\n\tif (!inode)\n\t\treturn -ENOMEM;\n\n\tvar = kzalloc(sizeof(struct efivar_entry), GFP_KERNEL);\n\tif (!var) {\n\t\terr = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\t/* length of the variable name itself: remove GUID and separator */\n\tnamelen = dentry->d_name.len - EFI_VARIABLE_GUID_LEN - 1;\n\n\tefivarfs_hex_to_guid(dentry->d_name.name + namelen + 1,\n\t\t\t&var->var.VendorGuid);\n\n\tfor (i = 0; i < namelen; i++)\n\t\tvar->var.VariableName[i] = dentry->d_name.name[i];\n\n\tvar->var.VariableName[i] = '\\0';\n\n\tinode->i_private = var;\n\n\tefivar_entry_add(var, &efivarfs_list);\n\td_instantiate(dentry, inode);\n\tdget(dentry);\nout:\n\tif (err) {\n\t\tkfree(var);\n\t\tiput(inode);\n\t}\n\treturn err;\n}"
  },
  {
    "function_name": "efivarfs_hex_to_guid",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/efivarfs/inode.c",
    "lines": "82-100",
    "snippet": "static void efivarfs_hex_to_guid(const char *str, efi_guid_t *guid)\n{\n\tguid->b[0] = hex_to_bin(str[6]) << 4 | hex_to_bin(str[7]);\n\tguid->b[1] = hex_to_bin(str[4]) << 4 | hex_to_bin(str[5]);\n\tguid->b[2] = hex_to_bin(str[2]) << 4 | hex_to_bin(str[3]);\n\tguid->b[3] = hex_to_bin(str[0]) << 4 | hex_to_bin(str[1]);\n\tguid->b[4] = hex_to_bin(str[11]) << 4 | hex_to_bin(str[12]);\n\tguid->b[5] = hex_to_bin(str[9]) << 4 | hex_to_bin(str[10]);\n\tguid->b[6] = hex_to_bin(str[16]) << 4 | hex_to_bin(str[17]);\n\tguid->b[7] = hex_to_bin(str[14]) << 4 | hex_to_bin(str[15]);\n\tguid->b[8] = hex_to_bin(str[19]) << 4 | hex_to_bin(str[20]);\n\tguid->b[9] = hex_to_bin(str[21]) << 4 | hex_to_bin(str[22]);\n\tguid->b[10] = hex_to_bin(str[24]) << 4 | hex_to_bin(str[25]);\n\tguid->b[11] = hex_to_bin(str[26]) << 4 | hex_to_bin(str[27]);\n\tguid->b[12] = hex_to_bin(str[28]) << 4 | hex_to_bin(str[29]);\n\tguid->b[13] = hex_to_bin(str[30]) << 4 | hex_to_bin(str[31]);\n\tguid->b[14] = hex_to_bin(str[32]) << 4 | hex_to_bin(str[33]);\n\tguid->b[15] = hex_to_bin(str[34]) << 4 | hex_to_bin(str[35]);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/slab.h>",
      "#include <linux/ctype.h>",
      "#include <linux/fs.h>",
      "#include <linux/efi.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "hex_to_bin",
          "args": [
            "str[35]"
          ],
          "line": 99
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hex_to_bin",
          "args": [
            "str[34]"
          ],
          "line": 99
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hex_to_bin",
          "args": [
            "str[33]"
          ],
          "line": 98
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hex_to_bin",
          "args": [
            "str[32]"
          ],
          "line": 98
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hex_to_bin",
          "args": [
            "str[31]"
          ],
          "line": 97
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hex_to_bin",
          "args": [
            "str[30]"
          ],
          "line": 97
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hex_to_bin",
          "args": [
            "str[29]"
          ],
          "line": 96
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hex_to_bin",
          "args": [
            "str[28]"
          ],
          "line": 96
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hex_to_bin",
          "args": [
            "str[27]"
          ],
          "line": 95
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hex_to_bin",
          "args": [
            "str[26]"
          ],
          "line": 95
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hex_to_bin",
          "args": [
            "str[25]"
          ],
          "line": 94
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hex_to_bin",
          "args": [
            "str[24]"
          ],
          "line": 94
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hex_to_bin",
          "args": [
            "str[22]"
          ],
          "line": 93
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hex_to_bin",
          "args": [
            "str[21]"
          ],
          "line": 93
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hex_to_bin",
          "args": [
            "str[20]"
          ],
          "line": 92
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hex_to_bin",
          "args": [
            "str[19]"
          ],
          "line": 92
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hex_to_bin",
          "args": [
            "str[15]"
          ],
          "line": 91
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hex_to_bin",
          "args": [
            "str[14]"
          ],
          "line": 91
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hex_to_bin",
          "args": [
            "str[17]"
          ],
          "line": 90
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hex_to_bin",
          "args": [
            "str[16]"
          ],
          "line": 90
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hex_to_bin",
          "args": [
            "str[10]"
          ],
          "line": 89
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hex_to_bin",
          "args": [
            "str[9]"
          ],
          "line": 89
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hex_to_bin",
          "args": [
            "str[12]"
          ],
          "line": 88
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hex_to_bin",
          "args": [
            "str[11]"
          ],
          "line": 88
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hex_to_bin",
          "args": [
            "str[1]"
          ],
          "line": 87
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hex_to_bin",
          "args": [
            "str[0]"
          ],
          "line": 87
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hex_to_bin",
          "args": [
            "str[3]"
          ],
          "line": 86
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hex_to_bin",
          "args": [
            "str[2]"
          ],
          "line": 86
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hex_to_bin",
          "args": [
            "str[5]"
          ],
          "line": 85
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hex_to_bin",
          "args": [
            "str[4]"
          ],
          "line": 85
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hex_to_bin",
          "args": [
            "str[7]"
          ],
          "line": 84
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hex_to_bin",
          "args": [
            "str[6]"
          ],
          "line": 84
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/slab.h>\n#include <linux/ctype.h>\n#include <linux/fs.h>\n#include <linux/efi.h>\n\nstatic void efivarfs_hex_to_guid(const char *str, efi_guid_t *guid)\n{\n\tguid->b[0] = hex_to_bin(str[6]) << 4 | hex_to_bin(str[7]);\n\tguid->b[1] = hex_to_bin(str[4]) << 4 | hex_to_bin(str[5]);\n\tguid->b[2] = hex_to_bin(str[2]) << 4 | hex_to_bin(str[3]);\n\tguid->b[3] = hex_to_bin(str[0]) << 4 | hex_to_bin(str[1]);\n\tguid->b[4] = hex_to_bin(str[11]) << 4 | hex_to_bin(str[12]);\n\tguid->b[5] = hex_to_bin(str[9]) << 4 | hex_to_bin(str[10]);\n\tguid->b[6] = hex_to_bin(str[16]) << 4 | hex_to_bin(str[17]);\n\tguid->b[7] = hex_to_bin(str[14]) << 4 | hex_to_bin(str[15]);\n\tguid->b[8] = hex_to_bin(str[19]) << 4 | hex_to_bin(str[20]);\n\tguid->b[9] = hex_to_bin(str[21]) << 4 | hex_to_bin(str[22]);\n\tguid->b[10] = hex_to_bin(str[24]) << 4 | hex_to_bin(str[25]);\n\tguid->b[11] = hex_to_bin(str[26]) << 4 | hex_to_bin(str[27]);\n\tguid->b[12] = hex_to_bin(str[28]) << 4 | hex_to_bin(str[29]);\n\tguid->b[13] = hex_to_bin(str[30]) << 4 | hex_to_bin(str[31]);\n\tguid->b[14] = hex_to_bin(str[32]) << 4 | hex_to_bin(str[33]);\n\tguid->b[15] = hex_to_bin(str[34]) << 4 | hex_to_bin(str[35]);\n}"
  },
  {
    "function_name": "efivarfs_valid_name",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/efivarfs/inode.c",
    "lines": "45-80",
    "snippet": "bool efivarfs_valid_name(const char *str, int len)\n{\n\tstatic const char dashes[EFI_VARIABLE_GUID_LEN] = {\n\t\t[8] = 1, [13] = 1, [18] = 1, [23] = 1\n\t};\n\tconst char *s = str + len - EFI_VARIABLE_GUID_LEN;\n\tint i;\n\n\t/*\n\t * We need a GUID, plus at least one letter for the variable name,\n\t * plus the '-' separator\n\t */\n\tif (len < EFI_VARIABLE_GUID_LEN + 2)\n\t\treturn false;\n\n\t/* GUID must be preceded by a '-' */\n\tif (*(s - 1) != '-')\n\t\treturn false;\n\n\t/*\n\t * Validate that 's' is of the correct format, e.g.\n\t *\n\t *\t12345678-1234-1234-1234-123456789abc\n\t */\n\tfor (i = 0; i < EFI_VARIABLE_GUID_LEN; i++) {\n\t\tif (dashes[i]) {\n\t\t\tif (*s++ != '-')\n\t\t\t\treturn false;\n\t\t} else {\n\t\t\tif (!isxdigit(*s++))\n\t\t\t\treturn false;\n\t\t}\n\t}\n\n\treturn true;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/slab.h>",
      "#include <linux/ctype.h>",
      "#include <linux/fs.h>",
      "#include <linux/efi.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "isxdigit",
          "args": [
            "*s++"
          ],
          "line": 74
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/slab.h>\n#include <linux/ctype.h>\n#include <linux/fs.h>\n#include <linux/efi.h>\n\nbool efivarfs_valid_name(const char *str, int len)\n{\n\tstatic const char dashes[EFI_VARIABLE_GUID_LEN] = {\n\t\t[8] = 1, [13] = 1, [18] = 1, [23] = 1\n\t};\n\tconst char *s = str + len - EFI_VARIABLE_GUID_LEN;\n\tint i;\n\n\t/*\n\t * We need a GUID, plus at least one letter for the variable name,\n\t * plus the '-' separator\n\t */\n\tif (len < EFI_VARIABLE_GUID_LEN + 2)\n\t\treturn false;\n\n\t/* GUID must be preceded by a '-' */\n\tif (*(s - 1) != '-')\n\t\treturn false;\n\n\t/*\n\t * Validate that 's' is of the correct format, e.g.\n\t *\n\t *\t12345678-1234-1234-1234-123456789abc\n\t */\n\tfor (i = 0; i < EFI_VARIABLE_GUID_LEN; i++) {\n\t\tif (dashes[i]) {\n\t\t\tif (*s++ != '-')\n\t\t\t\treturn false;\n\t\t} else {\n\t\t\tif (!isxdigit(*s++))\n\t\t\t\treturn false;\n\t\t}\n\t}\n\n\treturn true;\n}"
  },
  {
    "function_name": "efivarfs_get_inode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/efivarfs/inode.c",
    "lines": "17-38",
    "snippet": "struct inode *efivarfs_get_inode(struct super_block *sb,\n\t\t\t\tconst struct inode *dir, int mode, dev_t dev)\n{\n\tstruct inode *inode = new_inode(sb);\n\n\tif (inode) {\n\t\tinode->i_ino = get_next_ino();\n\t\tinode->i_mode = mode;\n\t\tinode->i_atime = inode->i_mtime = inode->i_ctime = CURRENT_TIME;\n\t\tswitch (mode & S_IFMT) {\n\t\tcase S_IFREG:\n\t\t\tinode->i_fop = &efivarfs_file_operations;\n\t\t\tbreak;\n\t\tcase S_IFDIR:\n\t\t\tinode->i_op = &efivarfs_dir_inode_operations;\n\t\t\tinode->i_fop = &simple_dir_operations;\n\t\t\tinc_nlink(inode);\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn inode;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/slab.h>",
      "#include <linux/ctype.h>",
      "#include <linux/fs.h>",
      "#include <linux/efi.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "const struct inode_operations efivarfs_dir_inode_operations = {\n\t.lookup = simple_lookup,\n\t.unlink = efivarfs_unlink,\n\t.create = efivarfs_create,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "inc_nlink",
          "args": [
            "inode"
          ],
          "line": 33
        },
        "resolved": true,
        "details": {
          "function_name": "inc_nlink",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "327-335",
          "snippet": "void inc_nlink(struct inode *inode)\n{\n\tif (unlikely(inode->i_nlink == 0)) {\n\t\tWARN_ON(!(inode->i_state & I_LINKABLE));\n\t\tatomic_long_dec(&inode->i_sb->s_remove_count);\n\t}\n\n\tinode->__i_nlink++;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid inc_nlink(struct inode *inode)\n{\n\tif (unlikely(inode->i_nlink == 0)) {\n\t\tWARN_ON(!(inode->i_state & I_LINKABLE));\n\t\tatomic_long_dec(&inode->i_sb->s_remove_count);\n\t}\n\n\tinode->__i_nlink++;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_next_ino",
          "args": [],
          "line": 23
        },
        "resolved": true,
        "details": {
          "function_name": "get_next_ino",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "828-845",
          "snippet": "unsigned int get_next_ino(void)\n{\n\tunsigned int *p = &get_cpu_var(last_ino);\n\tunsigned int res = *p;\n\n#ifdef CONFIG_SMP\n\tif (unlikely((res & (LAST_INO_BATCH-1)) == 0)) {\n\t\tstatic atomic_t shared_last_ino;\n\t\tint next = atomic_add_return(LAST_INO_BATCH, &shared_last_ino);\n\n\t\tres = next - LAST_INO_BATCH;\n\t}\n#endif\n\n\t*p = ++res;\n\tput_cpu_var(last_ino);\n\treturn res;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [
            "#define LAST_INO_BATCH 1024"
          ],
          "globals_used": [
            "static DEFINE_PER_CPU(unsigned int, last_ino);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\n#define LAST_INO_BATCH 1024\n\nstatic DEFINE_PER_CPU(unsigned int, last_ino);\n\nunsigned int get_next_ino(void)\n{\n\tunsigned int *p = &get_cpu_var(last_ino);\n\tunsigned int res = *p;\n\n#ifdef CONFIG_SMP\n\tif (unlikely((res & (LAST_INO_BATCH-1)) == 0)) {\n\t\tstatic atomic_t shared_last_ino;\n\t\tint next = atomic_add_return(LAST_INO_BATCH, &shared_last_ino);\n\n\t\tres = next - LAST_INO_BATCH;\n\t}\n#endif\n\n\t*p = ++res;\n\tput_cpu_var(last_ino);\n\treturn res;\n}"
        }
      },
      {
        "call_info": {
          "callee": "new_inode",
          "args": [
            "sb"
          ],
          "line": 20
        },
        "resolved": true,
        "details": {
          "function_name": "unlock_new_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "924-933",
          "snippet": "void unlock_new_inode(struct inode *inode)\n{\n\tlockdep_annotate_inode_mutex_key(inode);\n\tspin_lock(&inode->i_lock);\n\tWARN_ON(!(inode->i_state & I_NEW));\n\tinode->i_state &= ~I_NEW;\n\tsmp_mb();\n\twake_up_bit(&inode->i_state, __I_NEW);\n\tspin_unlock(&inode->i_lock);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid unlock_new_inode(struct inode *inode)\n{\n\tlockdep_annotate_inode_mutex_key(inode);\n\tspin_lock(&inode->i_lock);\n\tWARN_ON(!(inode->i_state & I_NEW));\n\tinode->i_state &= ~I_NEW;\n\tsmp_mb();\n\twake_up_bit(&inode->i_state, __I_NEW);\n\tspin_unlock(&inode->i_lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/slab.h>\n#include <linux/ctype.h>\n#include <linux/fs.h>\n#include <linux/efi.h>\n\nconst struct inode_operations efivarfs_dir_inode_operations = {\n\t.lookup = simple_lookup,\n\t.unlink = efivarfs_unlink,\n\t.create = efivarfs_create,\n};\n\nstruct inode *efivarfs_get_inode(struct super_block *sb,\n\t\t\t\tconst struct inode *dir, int mode, dev_t dev)\n{\n\tstruct inode *inode = new_inode(sb);\n\n\tif (inode) {\n\t\tinode->i_ino = get_next_ino();\n\t\tinode->i_mode = mode;\n\t\tinode->i_atime = inode->i_mtime = inode->i_ctime = CURRENT_TIME;\n\t\tswitch (mode & S_IFMT) {\n\t\tcase S_IFREG:\n\t\t\tinode->i_fop = &efivarfs_file_operations;\n\t\t\tbreak;\n\t\tcase S_IFDIR:\n\t\t\tinode->i_op = &efivarfs_dir_inode_operations;\n\t\t\tinode->i_fop = &simple_dir_operations;\n\t\t\tinc_nlink(inode);\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn inode;\n}"
  }
]