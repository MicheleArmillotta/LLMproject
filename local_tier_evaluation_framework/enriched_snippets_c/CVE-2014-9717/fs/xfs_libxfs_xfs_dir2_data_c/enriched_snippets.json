[
  {
    "function_name": "xfs_dir2_data_use_free",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_dir2_data.c",
    "lines": "899-1048",
    "snippet": "void\nxfs_dir2_data_use_free(\n\tstruct xfs_da_args\t*args,\n\tstruct xfs_buf\t\t*bp,\n\txfs_dir2_data_unused_t\t*dup,\t\t/* unused entry */\n\txfs_dir2_data_aoff_t\toffset,\t\t/* starting offset to use */\n\txfs_dir2_data_aoff_t\tlen,\t\t/* length to use */\n\tint\t\t\t*needlogp,\t/* out: need to log header */\n\tint\t\t\t*needscanp)\t/* out: need regen bestfree */\n{\n\txfs_dir2_data_hdr_t\t*hdr;\t\t/* data block header */\n\txfs_dir2_data_free_t\t*dfp;\t\t/* bestfree pointer */\n\tint\t\t\tmatchback;\t/* matches end of freespace */\n\tint\t\t\tmatchfront;\t/* matches start of freespace */\n\tint\t\t\tneedscan;\t/* need to regen bestfree */\n\txfs_dir2_data_unused_t\t*newdup;\t/* new unused entry */\n\txfs_dir2_data_unused_t\t*newdup2;\t/* another new unused entry */\n\tint\t\t\toldlen;\t\t/* old unused entry's length */\n\tstruct xfs_dir2_data_free *bf;\n\n\thdr = bp->b_addr;\n\tASSERT(hdr->magic == cpu_to_be32(XFS_DIR2_DATA_MAGIC) ||\n\t       hdr->magic == cpu_to_be32(XFS_DIR3_DATA_MAGIC) ||\n\t       hdr->magic == cpu_to_be32(XFS_DIR2_BLOCK_MAGIC) ||\n\t       hdr->magic == cpu_to_be32(XFS_DIR3_BLOCK_MAGIC));\n\tASSERT(be16_to_cpu(dup->freetag) == XFS_DIR2_DATA_FREE_TAG);\n\tASSERT(offset >= (char *)dup - (char *)hdr);\n\tASSERT(offset + len <= (char *)dup + be16_to_cpu(dup->length) - (char *)hdr);\n\tASSERT((char *)dup - (char *)hdr == be16_to_cpu(*xfs_dir2_data_unused_tag_p(dup)));\n\t/*\n\t * Look up the entry in the bestfree table.\n\t */\n\toldlen = be16_to_cpu(dup->length);\n\tbf = args->dp->d_ops->data_bestfree_p(hdr);\n\tdfp = xfs_dir2_data_freefind(hdr, bf, dup);\n\tASSERT(dfp || oldlen <= be16_to_cpu(bf[2].length));\n\t/*\n\t * Check for alignment with front and back of the entry.\n\t */\n\tmatchfront = (char *)dup - (char *)hdr == offset;\n\tmatchback = (char *)dup + oldlen - (char *)hdr == offset + len;\n\tASSERT(*needscanp == 0);\n\tneedscan = 0;\n\t/*\n\t * If we matched it exactly we just need to get rid of it from\n\t * the bestfree table.\n\t */\n\tif (matchfront && matchback) {\n\t\tif (dfp) {\n\t\t\tneedscan = (bf[2].offset != 0);\n\t\t\tif (!needscan)\n\t\t\t\txfs_dir2_data_freeremove(hdr, bf, dfp,\n\t\t\t\t\t\t\t needlogp);\n\t\t}\n\t}\n\t/*\n\t * We match the first part of the entry.\n\t * Make a new entry with the remaining freespace.\n\t */\n\telse if (matchfront) {\n\t\tnewdup = (xfs_dir2_data_unused_t *)((char *)hdr + offset + len);\n\t\tnewdup->freetag = cpu_to_be16(XFS_DIR2_DATA_FREE_TAG);\n\t\tnewdup->length = cpu_to_be16(oldlen - len);\n\t\t*xfs_dir2_data_unused_tag_p(newdup) =\n\t\t\tcpu_to_be16((char *)newdup - (char *)hdr);\n\t\txfs_dir2_data_log_unused(args, bp, newdup);\n\t\t/*\n\t\t * If it was in the table, remove it and add the new one.\n\t\t */\n\t\tif (dfp) {\n\t\t\txfs_dir2_data_freeremove(hdr, bf, dfp, needlogp);\n\t\t\tdfp = xfs_dir2_data_freeinsert(hdr, bf, newdup,\n\t\t\t\t\t\t       needlogp);\n\t\t\tASSERT(dfp != NULL);\n\t\t\tASSERT(dfp->length == newdup->length);\n\t\t\tASSERT(be16_to_cpu(dfp->offset) == (char *)newdup - (char *)hdr);\n\t\t\t/*\n\t\t\t * If we got inserted at the last slot,\n\t\t\t * that means we don't know if there was a better\n\t\t\t * choice for the last slot, or not.  Rescan.\n\t\t\t */\n\t\t\tneedscan = dfp == &bf[2];\n\t\t}\n\t}\n\t/*\n\t * We match the last part of the entry.\n\t * Trim the allocated space off the tail of the entry.\n\t */\n\telse if (matchback) {\n\t\tnewdup = dup;\n\t\tnewdup->length = cpu_to_be16(((char *)hdr + offset) - (char *)newdup);\n\t\t*xfs_dir2_data_unused_tag_p(newdup) =\n\t\t\tcpu_to_be16((char *)newdup - (char *)hdr);\n\t\txfs_dir2_data_log_unused(args, bp, newdup);\n\t\t/*\n\t\t * If it was in the table, remove it and add the new one.\n\t\t */\n\t\tif (dfp) {\n\t\t\txfs_dir2_data_freeremove(hdr, bf, dfp, needlogp);\n\t\t\tdfp = xfs_dir2_data_freeinsert(hdr, bf, newdup,\n\t\t\t\t\t\t       needlogp);\n\t\t\tASSERT(dfp != NULL);\n\t\t\tASSERT(dfp->length == newdup->length);\n\t\t\tASSERT(be16_to_cpu(dfp->offset) == (char *)newdup - (char *)hdr);\n\t\t\t/*\n\t\t\t * If we got inserted at the last slot,\n\t\t\t * that means we don't know if there was a better\n\t\t\t * choice for the last slot, or not.  Rescan.\n\t\t\t */\n\t\t\tneedscan = dfp == &bf[2];\n\t\t}\n\t}\n\t/*\n\t * Poking out the middle of an entry.\n\t * Make two new entries.\n\t */\n\telse {\n\t\tnewdup = dup;\n\t\tnewdup->length = cpu_to_be16(((char *)hdr + offset) - (char *)newdup);\n\t\t*xfs_dir2_data_unused_tag_p(newdup) =\n\t\t\tcpu_to_be16((char *)newdup - (char *)hdr);\n\t\txfs_dir2_data_log_unused(args, bp, newdup);\n\t\tnewdup2 = (xfs_dir2_data_unused_t *)((char *)hdr + offset + len);\n\t\tnewdup2->freetag = cpu_to_be16(XFS_DIR2_DATA_FREE_TAG);\n\t\tnewdup2->length = cpu_to_be16(oldlen - len - be16_to_cpu(newdup->length));\n\t\t*xfs_dir2_data_unused_tag_p(newdup2) =\n\t\t\tcpu_to_be16((char *)newdup2 - (char *)hdr);\n\t\txfs_dir2_data_log_unused(args, bp, newdup2);\n\t\t/*\n\t\t * If the old entry was in the table, we need to scan\n\t\t * if the 3rd entry was valid, since these entries\n\t\t * are smaller than the old one.\n\t\t * If we don't need to scan that means there were 1 or 2\n\t\t * entries in the table, and removing the old and adding\n\t\t * the 2 new will work.\n\t\t */\n\t\tif (dfp) {\n\t\t\tneedscan = (bf[2].length != 0);\n\t\t\tif (!needscan) {\n\t\t\t\txfs_dir2_data_freeremove(hdr, bf, dfp,\n\t\t\t\t\t\t\t needlogp);\n\t\t\t\txfs_dir2_data_freeinsert(hdr, bf, newdup,\n\t\t\t\t\t\t\t needlogp);\n\t\t\t\txfs_dir2_data_freeinsert(hdr, bf, newdup2,\n\t\t\t\t\t\t\t needlogp);\n\t\t\t}\n\t\t}\n\t}\n\t*needscanp = needscan;\n}",
    "includes": [
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_buf_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_dir2_priv.h\"",
      "#include \"xfs_dir2.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_da_btree.h\"",
      "#include \"xfs_da_format.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_dir2_data_freeinsert",
          "args": [
            "hdr",
            "bf",
            "newdup2",
            "needlogp"
          ],
          "line": 1042
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_dir2_data_freeinsert",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_dir2_data.c",
          "lines": "415-454",
          "snippet": "xfs_dir2_data_free_t *\t\t\t\t/* entry inserted */\nxfs_dir2_data_freeinsert(\n\tstruct xfs_dir2_data_hdr *hdr,\t\t/* data block pointer */\n\tstruct xfs_dir2_data_free *dfp,\t\t/* bestfree table pointer */\n\tstruct xfs_dir2_data_unused *dup,\t/* unused space */\n\tint\t\t\t*loghead)\t/* log the data header (out) */\n{\n\txfs_dir2_data_free_t\tnew;\t\t/* new bestfree entry */\n\n\tASSERT(hdr->magic == cpu_to_be32(XFS_DIR2_DATA_MAGIC) ||\n\t       hdr->magic == cpu_to_be32(XFS_DIR2_BLOCK_MAGIC) ||\n\t       hdr->magic == cpu_to_be32(XFS_DIR3_DATA_MAGIC) ||\n\t       hdr->magic == cpu_to_be32(XFS_DIR3_BLOCK_MAGIC));\n\n\tnew.length = dup->length;\n\tnew.offset = cpu_to_be16((char *)dup - (char *)hdr);\n\n\t/*\n\t * Insert at position 0, 1, or 2; or not at all.\n\t */\n\tif (be16_to_cpu(new.length) > be16_to_cpu(dfp[0].length)) {\n\t\tdfp[2] = dfp[1];\n\t\tdfp[1] = dfp[0];\n\t\tdfp[0] = new;\n\t\t*loghead = 1;\n\t\treturn &dfp[0];\n\t}\n\tif (be16_to_cpu(new.length) > be16_to_cpu(dfp[1].length)) {\n\t\tdfp[2] = dfp[1];\n\t\tdfp[1] = new;\n\t\t*loghead = 1;\n\t\treturn &dfp[1];\n\t}\n\tif (be16_to_cpu(new.length) > be16_to_cpu(dfp[2].length)) {\n\t\tdfp[2] = new;\n\t\t*loghead = 1;\n\t\treturn &dfp[2];\n\t}\n\treturn NULL;\n}",
          "includes": [
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_dir2_priv.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_cksum.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_error.h\"\n#include \"xfs_dir2_priv.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nxfs_dir2_data_free_t *\t\t\t\t/* entry inserted */\nxfs_dir2_data_freeinsert(\n\tstruct xfs_dir2_data_hdr *hdr,\t\t/* data block pointer */\n\tstruct xfs_dir2_data_free *dfp,\t\t/* bestfree table pointer */\n\tstruct xfs_dir2_data_unused *dup,\t/* unused space */\n\tint\t\t\t*loghead)\t/* log the data header (out) */\n{\n\txfs_dir2_data_free_t\tnew;\t\t/* new bestfree entry */\n\n\tASSERT(hdr->magic == cpu_to_be32(XFS_DIR2_DATA_MAGIC) ||\n\t       hdr->magic == cpu_to_be32(XFS_DIR2_BLOCK_MAGIC) ||\n\t       hdr->magic == cpu_to_be32(XFS_DIR3_DATA_MAGIC) ||\n\t       hdr->magic == cpu_to_be32(XFS_DIR3_BLOCK_MAGIC));\n\n\tnew.length = dup->length;\n\tnew.offset = cpu_to_be16((char *)dup - (char *)hdr);\n\n\t/*\n\t * Insert at position 0, 1, or 2; or not at all.\n\t */\n\tif (be16_to_cpu(new.length) > be16_to_cpu(dfp[0].length)) {\n\t\tdfp[2] = dfp[1];\n\t\tdfp[1] = dfp[0];\n\t\tdfp[0] = new;\n\t\t*loghead = 1;\n\t\treturn &dfp[0];\n\t}\n\tif (be16_to_cpu(new.length) > be16_to_cpu(dfp[1].length)) {\n\t\tdfp[2] = dfp[1];\n\t\tdfp[1] = new;\n\t\t*loghead = 1;\n\t\treturn &dfp[1];\n\t}\n\tif (be16_to_cpu(new.length) > be16_to_cpu(dfp[2].length)) {\n\t\tdfp[2] = new;\n\t\t*loghead = 1;\n\t\treturn &dfp[2];\n\t}\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_dir2_data_freeremove",
          "args": [
            "hdr",
            "bf",
            "dfp",
            "needlogp"
          ],
          "line": 1038
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_dir2_data_freeremove",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_dir2_data.c",
          "lines": "459-495",
          "snippet": "STATIC void\nxfs_dir2_data_freeremove(\n\tstruct xfs_dir2_data_hdr *hdr,\t\t/* data block header */\n\tstruct xfs_dir2_data_free *bf,\t\t/* bestfree table pointer */\n\tstruct xfs_dir2_data_free *dfp,\t\t/* bestfree entry pointer */\n\tint\t\t\t*loghead)\t/* out: log data header */\n{\n\n\tASSERT(hdr->magic == cpu_to_be32(XFS_DIR2_DATA_MAGIC) ||\n\t       hdr->magic == cpu_to_be32(XFS_DIR2_BLOCK_MAGIC) ||\n\t       hdr->magic == cpu_to_be32(XFS_DIR3_DATA_MAGIC) ||\n\t       hdr->magic == cpu_to_be32(XFS_DIR3_BLOCK_MAGIC));\n\n\t/*\n\t * It's the first entry, slide the next 2 up.\n\t */\n\tif (dfp == &bf[0]) {\n\t\tbf[0] = bf[1];\n\t\tbf[1] = bf[2];\n\t}\n\t/*\n\t * It's the second entry, slide the 3rd entry up.\n\t */\n\telse if (dfp == &bf[1])\n\t\tbf[1] = bf[2];\n\t/*\n\t * Must be the last entry.\n\t */\n\telse\n\t\tASSERT(dfp == &bf[2]);\n\t/*\n\t * Clear the 3rd entry, must be zero now.\n\t */\n\tbf[2].length = 0;\n\tbf[2].offset = 0;\n\t*loghead = 1;\n}",
          "includes": [
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_dir2_priv.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_cksum.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_error.h\"\n#include \"xfs_dir2_priv.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC void\nxfs_dir2_data_freeremove(\n\tstruct xfs_dir2_data_hdr *hdr,\t\t/* data block header */\n\tstruct xfs_dir2_data_free *bf,\t\t/* bestfree table pointer */\n\tstruct xfs_dir2_data_free *dfp,\t\t/* bestfree entry pointer */\n\tint\t\t\t*loghead)\t/* out: log data header */\n{\n\n\tASSERT(hdr->magic == cpu_to_be32(XFS_DIR2_DATA_MAGIC) ||\n\t       hdr->magic == cpu_to_be32(XFS_DIR2_BLOCK_MAGIC) ||\n\t       hdr->magic == cpu_to_be32(XFS_DIR3_DATA_MAGIC) ||\n\t       hdr->magic == cpu_to_be32(XFS_DIR3_BLOCK_MAGIC));\n\n\t/*\n\t * It's the first entry, slide the next 2 up.\n\t */\n\tif (dfp == &bf[0]) {\n\t\tbf[0] = bf[1];\n\t\tbf[1] = bf[2];\n\t}\n\t/*\n\t * It's the second entry, slide the 3rd entry up.\n\t */\n\telse if (dfp == &bf[1])\n\t\tbf[1] = bf[2];\n\t/*\n\t * Must be the last entry.\n\t */\n\telse\n\t\tASSERT(dfp == &bf[2]);\n\t/*\n\t * Clear the 3rd entry, must be zero now.\n\t */\n\tbf[2].length = 0;\n\tbf[2].offset = 0;\n\t*loghead = 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_dir2_data_log_unused",
          "args": [
            "args",
            "bp",
            "newdup2"
          ],
          "line": 1026
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_dir2_data_log_unused",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_dir2_data.c",
          "lines": "682-708",
          "snippet": "void\nxfs_dir2_data_log_unused(\n\tstruct xfs_da_args\t*args,\n\tstruct xfs_buf\t\t*bp,\n\txfs_dir2_data_unused_t\t*dup)\t\t/* data unused pointer */\n{\n\txfs_dir2_data_hdr_t\t*hdr = bp->b_addr;\n\n\tASSERT(hdr->magic == cpu_to_be32(XFS_DIR2_DATA_MAGIC) ||\n\t       hdr->magic == cpu_to_be32(XFS_DIR3_DATA_MAGIC) ||\n\t       hdr->magic == cpu_to_be32(XFS_DIR2_BLOCK_MAGIC) ||\n\t       hdr->magic == cpu_to_be32(XFS_DIR3_BLOCK_MAGIC));\n\n\t/*\n\t * Log the first part of the unused entry.\n\t */\n\txfs_trans_log_buf(args->trans, bp, (uint)((char *)dup - (char *)hdr),\n\t\t(uint)((char *)&dup->length + sizeof(dup->length) -\n\t\t       1 - (char *)hdr));\n\t/*\n\t * Log the end (tag) of the unused entry.\n\t */\n\txfs_trans_log_buf(args->trans, bp,\n\t\t(uint)((char *)xfs_dir2_data_unused_tag_p(dup) - (char *)hdr),\n\t\t(uint)((char *)xfs_dir2_data_unused_tag_p(dup) - (char *)hdr +\n\t\t       sizeof(xfs_dir2_data_off_t) - 1));\n}",
          "includes": [
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_dir2_priv.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_cksum.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_error.h\"\n#include \"xfs_dir2_priv.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_dir2_data_log_unused(\n\tstruct xfs_da_args\t*args,\n\tstruct xfs_buf\t\t*bp,\n\txfs_dir2_data_unused_t\t*dup)\t\t/* data unused pointer */\n{\n\txfs_dir2_data_hdr_t\t*hdr = bp->b_addr;\n\n\tASSERT(hdr->magic == cpu_to_be32(XFS_DIR2_DATA_MAGIC) ||\n\t       hdr->magic == cpu_to_be32(XFS_DIR3_DATA_MAGIC) ||\n\t       hdr->magic == cpu_to_be32(XFS_DIR2_BLOCK_MAGIC) ||\n\t       hdr->magic == cpu_to_be32(XFS_DIR3_BLOCK_MAGIC));\n\n\t/*\n\t * Log the first part of the unused entry.\n\t */\n\txfs_trans_log_buf(args->trans, bp, (uint)((char *)dup - (char *)hdr),\n\t\t(uint)((char *)&dup->length + sizeof(dup->length) -\n\t\t       1 - (char *)hdr));\n\t/*\n\t * Log the end (tag) of the unused entry.\n\t */\n\txfs_trans_log_buf(args->trans, bp,\n\t\t(uint)((char *)xfs_dir2_data_unused_tag_p(dup) - (char *)hdr),\n\t\t(uint)((char *)xfs_dir2_data_unused_tag_p(dup) - (char *)hdr +\n\t\t       sizeof(xfs_dir2_data_off_t) - 1));\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_be16",
          "args": [
            "(char *)newdup2 - (char *)hdr"
          ],
          "line": 1025
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_dir2_data_unused_tag_p",
          "args": [
            "newdup2"
          ],
          "line": 1024
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_dir2_data_unused_tag_p",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_da_format.h",
          "lines": "407-412",
          "snippet": "static inline __be16 *\nxfs_dir2_data_unused_tag_p(struct xfs_dir2_data_unused *dup)\n{\n\treturn (__be16 *)((char *)dup +\n\t\t\tbe16_to_cpu(dup->length) - sizeof(__be16));\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline __be16 *\nxfs_dir2_data_unused_tag_p(struct xfs_dir2_data_unused *dup)\n{\n\treturn (__be16 *)((char *)dup +\n\t\t\tbe16_to_cpu(dup->length) - sizeof(__be16));\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_be16",
          "args": [
            "oldlen - len - be16_to_cpu(newdup->length)"
          ],
          "line": 1023
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be16_to_cpu",
          "args": [
            "newdup->length"
          ],
          "line": 1023
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be16",
          "args": [
            "XFS_DIR2_DATA_FREE_TAG"
          ],
          "line": 1022
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be16",
          "args": [
            "(char *)newdup - (char *)hdr"
          ],
          "line": 1019
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be16",
          "args": [
            "((char *)hdr + offset) - (char *)newdup"
          ],
          "line": 1017
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "be16_to_cpu(dfp->offset) == (char *)newdup - (char *)hdr"
          ],
          "line": 1002
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be16_to_cpu",
          "args": [
            "dfp->offset"
          ],
          "line": 1002
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "dfp->length == newdup->length"
          ],
          "line": 1001
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "dfp != NULL"
          ],
          "line": 1000
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be16",
          "args": [
            "(char *)newdup - (char *)hdr"
          ],
          "line": 991
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be16",
          "args": [
            "((char *)hdr + offset) - (char *)newdup"
          ],
          "line": 989
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "be16_to_cpu(dfp->offset) == (char *)newdup - (char *)hdr"
          ],
          "line": 974
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be16_to_cpu",
          "args": [
            "dfp->offset"
          ],
          "line": 974
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "dfp->length == newdup->length"
          ],
          "line": 973
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "dfp != NULL"
          ],
          "line": 972
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be16",
          "args": [
            "(char *)newdup - (char *)hdr"
          ],
          "line": 963
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be16",
          "args": [
            "oldlen - len"
          ],
          "line": 961
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be16",
          "args": [
            "XFS_DIR2_DATA_FREE_TAG"
          ],
          "line": 960
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "*needscanp == 0"
          ],
          "line": 940
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "dfp || oldlen <= be16_to_cpu(bf[2].length)"
          ],
          "line": 934
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be16_to_cpu",
          "args": [
            "bf[2].length"
          ],
          "line": 934
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_dir2_data_freefind",
          "args": [
            "hdr",
            "bf",
            "dup"
          ],
          "line": 933
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_dir2_data_freefind",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_dir2_data.c",
          "lines": "344-410",
          "snippet": "xfs_dir2_data_free_t *\nxfs_dir2_data_freefind(\n\tstruct xfs_dir2_data_hdr *hdr,\t\t/* data block header */\n\tstruct xfs_dir2_data_free *bf,\t\t/* bestfree table pointer */\n\tstruct xfs_dir2_data_unused *dup)\t/* unused space */\n{\n\txfs_dir2_data_free_t\t*dfp;\t\t/* bestfree entry */\n\txfs_dir2_data_aoff_t\toff;\t\t/* offset value needed */\n#ifdef DEBUG\n\tint\t\t\tmatched;\t/* matched the value */\n\tint\t\t\tseenzero;\t/* saw a 0 bestfree entry */\n#endif\n\n\toff = (xfs_dir2_data_aoff_t)((char *)dup - (char *)hdr);\n\n#ifdef DEBUG\n\t/*\n\t * Validate some consistency in the bestfree table.\n\t * Check order, non-overlapping entries, and if we find the\n\t * one we're looking for it has to be exact.\n\t */\n\tASSERT(hdr->magic == cpu_to_be32(XFS_DIR2_DATA_MAGIC) ||\n\t       hdr->magic == cpu_to_be32(XFS_DIR3_DATA_MAGIC) ||\n\t       hdr->magic == cpu_to_be32(XFS_DIR2_BLOCK_MAGIC) ||\n\t       hdr->magic == cpu_to_be32(XFS_DIR3_BLOCK_MAGIC));\n\tfor (dfp = &bf[0], seenzero = matched = 0;\n\t     dfp < &bf[XFS_DIR2_DATA_FD_COUNT];\n\t     dfp++) {\n\t\tif (!dfp->offset) {\n\t\t\tASSERT(!dfp->length);\n\t\t\tseenzero = 1;\n\t\t\tcontinue;\n\t\t}\n\t\tASSERT(seenzero == 0);\n\t\tif (be16_to_cpu(dfp->offset) == off) {\n\t\t\tmatched = 1;\n\t\t\tASSERT(dfp->length == dup->length);\n\t\t} else if (off < be16_to_cpu(dfp->offset))\n\t\t\tASSERT(off + be16_to_cpu(dup->length) <= be16_to_cpu(dfp->offset));\n\t\telse\n\t\t\tASSERT(be16_to_cpu(dfp->offset) + be16_to_cpu(dfp->length) <= off);\n\t\tASSERT(matched || be16_to_cpu(dfp->length) >= be16_to_cpu(dup->length));\n\t\tif (dfp > &bf[0])\n\t\t\tASSERT(be16_to_cpu(dfp[-1].length) >= be16_to_cpu(dfp[0].length));\n\t}\n#endif\n\t/*\n\t * If this is smaller than the smallest bestfree entry,\n\t * it can't be there since they're sorted.\n\t */\n\tif (be16_to_cpu(dup->length) <\n\t    be16_to_cpu(bf[XFS_DIR2_DATA_FD_COUNT - 1].length))\n\t\treturn NULL;\n\t/*\n\t * Look at the three bestfree entries for our guy.\n\t */\n\tfor (dfp = &bf[0]; dfp < &bf[XFS_DIR2_DATA_FD_COUNT]; dfp++) {\n\t\tif (!dfp->offset)\n\t\t\treturn NULL;\n\t\tif (be16_to_cpu(dfp->offset) == off)\n\t\t\treturn dfp;\n\t}\n\t/*\n\t * Didn't find it.  This only happens if there are duplicate lengths.\n\t */\n\treturn NULL;\n}",
          "includes": [
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_dir2_priv.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_cksum.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_error.h\"\n#include \"xfs_dir2_priv.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nxfs_dir2_data_free_t *\nxfs_dir2_data_freefind(\n\tstruct xfs_dir2_data_hdr *hdr,\t\t/* data block header */\n\tstruct xfs_dir2_data_free *bf,\t\t/* bestfree table pointer */\n\tstruct xfs_dir2_data_unused *dup)\t/* unused space */\n{\n\txfs_dir2_data_free_t\t*dfp;\t\t/* bestfree entry */\n\txfs_dir2_data_aoff_t\toff;\t\t/* offset value needed */\n#ifdef DEBUG\n\tint\t\t\tmatched;\t/* matched the value */\n\tint\t\t\tseenzero;\t/* saw a 0 bestfree entry */\n#endif\n\n\toff = (xfs_dir2_data_aoff_t)((char *)dup - (char *)hdr);\n\n#ifdef DEBUG\n\t/*\n\t * Validate some consistency in the bestfree table.\n\t * Check order, non-overlapping entries, and if we find the\n\t * one we're looking for it has to be exact.\n\t */\n\tASSERT(hdr->magic == cpu_to_be32(XFS_DIR2_DATA_MAGIC) ||\n\t       hdr->magic == cpu_to_be32(XFS_DIR3_DATA_MAGIC) ||\n\t       hdr->magic == cpu_to_be32(XFS_DIR2_BLOCK_MAGIC) ||\n\t       hdr->magic == cpu_to_be32(XFS_DIR3_BLOCK_MAGIC));\n\tfor (dfp = &bf[0], seenzero = matched = 0;\n\t     dfp < &bf[XFS_DIR2_DATA_FD_COUNT];\n\t     dfp++) {\n\t\tif (!dfp->offset) {\n\t\t\tASSERT(!dfp->length);\n\t\t\tseenzero = 1;\n\t\t\tcontinue;\n\t\t}\n\t\tASSERT(seenzero == 0);\n\t\tif (be16_to_cpu(dfp->offset) == off) {\n\t\t\tmatched = 1;\n\t\t\tASSERT(dfp->length == dup->length);\n\t\t} else if (off < be16_to_cpu(dfp->offset))\n\t\t\tASSERT(off + be16_to_cpu(dup->length) <= be16_to_cpu(dfp->offset));\n\t\telse\n\t\t\tASSERT(be16_to_cpu(dfp->offset) + be16_to_cpu(dfp->length) <= off);\n\t\tASSERT(matched || be16_to_cpu(dfp->length) >= be16_to_cpu(dup->length));\n\t\tif (dfp > &bf[0])\n\t\t\tASSERT(be16_to_cpu(dfp[-1].length) >= be16_to_cpu(dfp[0].length));\n\t}\n#endif\n\t/*\n\t * If this is smaller than the smallest bestfree entry,\n\t * it can't be there since they're sorted.\n\t */\n\tif (be16_to_cpu(dup->length) <\n\t    be16_to_cpu(bf[XFS_DIR2_DATA_FD_COUNT - 1].length))\n\t\treturn NULL;\n\t/*\n\t * Look at the three bestfree entries for our guy.\n\t */\n\tfor (dfp = &bf[0]; dfp < &bf[XFS_DIR2_DATA_FD_COUNT]; dfp++) {\n\t\tif (!dfp->offset)\n\t\t\treturn NULL;\n\t\tif (be16_to_cpu(dfp->offset) == off)\n\t\t\treturn dfp;\n\t}\n\t/*\n\t * Didn't find it.  This only happens if there are duplicate lengths.\n\t */\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "args->dp->d_ops->data_bestfree_p",
          "args": [
            "hdr"
          ],
          "line": 932
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be16_to_cpu",
          "args": [
            "dup->length"
          ],
          "line": 931
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "(char *)dup - (char *)hdr == be16_to_cpu(*xfs_dir2_data_unused_tag_p(dup))"
          ],
          "line": 927
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be16_to_cpu",
          "args": [
            "*xfs_dir2_data_unused_tag_p(dup)"
          ],
          "line": 927
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "offset + len <= (char *)dup + be16_to_cpu(dup->length) - (char *)hdr"
          ],
          "line": 926
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be16_to_cpu",
          "args": [
            "dup->length"
          ],
          "line": 926
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "offset >= (char *)dup - (char *)hdr"
          ],
          "line": 925
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "be16_to_cpu(dup->freetag) == XFS_DIR2_DATA_FREE_TAG"
          ],
          "line": 924
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be16_to_cpu",
          "args": [
            "dup->freetag"
          ],
          "line": 924
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "hdr->magic == cpu_to_be32(XFS_DIR2_DATA_MAGIC) ||\n\t       hdr->magic == cpu_to_be32(XFS_DIR3_DATA_MAGIC) ||\n\t       hdr->magic == cpu_to_be32(XFS_DIR2_BLOCK_MAGIC) ||\n\t       hdr->magic == cpu_to_be32(XFS_DIR3_BLOCK_MAGIC)"
          ],
          "line": 920
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "XFS_DIR3_BLOCK_MAGIC"
          ],
          "line": 923
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "XFS_DIR2_BLOCK_MAGIC"
          ],
          "line": 922
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "XFS_DIR3_DATA_MAGIC"
          ],
          "line": 921
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "XFS_DIR2_DATA_MAGIC"
          ],
          "line": 920
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_cksum.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_error.h\"\n#include \"xfs_dir2_priv.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_dir2_data_use_free(\n\tstruct xfs_da_args\t*args,\n\tstruct xfs_buf\t\t*bp,\n\txfs_dir2_data_unused_t\t*dup,\t\t/* unused entry */\n\txfs_dir2_data_aoff_t\toffset,\t\t/* starting offset to use */\n\txfs_dir2_data_aoff_t\tlen,\t\t/* length to use */\n\tint\t\t\t*needlogp,\t/* out: need to log header */\n\tint\t\t\t*needscanp)\t/* out: need regen bestfree */\n{\n\txfs_dir2_data_hdr_t\t*hdr;\t\t/* data block header */\n\txfs_dir2_data_free_t\t*dfp;\t\t/* bestfree pointer */\n\tint\t\t\tmatchback;\t/* matches end of freespace */\n\tint\t\t\tmatchfront;\t/* matches start of freespace */\n\tint\t\t\tneedscan;\t/* need to regen bestfree */\n\txfs_dir2_data_unused_t\t*newdup;\t/* new unused entry */\n\txfs_dir2_data_unused_t\t*newdup2;\t/* another new unused entry */\n\tint\t\t\toldlen;\t\t/* old unused entry's length */\n\tstruct xfs_dir2_data_free *bf;\n\n\thdr = bp->b_addr;\n\tASSERT(hdr->magic == cpu_to_be32(XFS_DIR2_DATA_MAGIC) ||\n\t       hdr->magic == cpu_to_be32(XFS_DIR3_DATA_MAGIC) ||\n\t       hdr->magic == cpu_to_be32(XFS_DIR2_BLOCK_MAGIC) ||\n\t       hdr->magic == cpu_to_be32(XFS_DIR3_BLOCK_MAGIC));\n\tASSERT(be16_to_cpu(dup->freetag) == XFS_DIR2_DATA_FREE_TAG);\n\tASSERT(offset >= (char *)dup - (char *)hdr);\n\tASSERT(offset + len <= (char *)dup + be16_to_cpu(dup->length) - (char *)hdr);\n\tASSERT((char *)dup - (char *)hdr == be16_to_cpu(*xfs_dir2_data_unused_tag_p(dup)));\n\t/*\n\t * Look up the entry in the bestfree table.\n\t */\n\toldlen = be16_to_cpu(dup->length);\n\tbf = args->dp->d_ops->data_bestfree_p(hdr);\n\tdfp = xfs_dir2_data_freefind(hdr, bf, dup);\n\tASSERT(dfp || oldlen <= be16_to_cpu(bf[2].length));\n\t/*\n\t * Check for alignment with front and back of the entry.\n\t */\n\tmatchfront = (char *)dup - (char *)hdr == offset;\n\tmatchback = (char *)dup + oldlen - (char *)hdr == offset + len;\n\tASSERT(*needscanp == 0);\n\tneedscan = 0;\n\t/*\n\t * If we matched it exactly we just need to get rid of it from\n\t * the bestfree table.\n\t */\n\tif (matchfront && matchback) {\n\t\tif (dfp) {\n\t\t\tneedscan = (bf[2].offset != 0);\n\t\t\tif (!needscan)\n\t\t\t\txfs_dir2_data_freeremove(hdr, bf, dfp,\n\t\t\t\t\t\t\t needlogp);\n\t\t}\n\t}\n\t/*\n\t * We match the first part of the entry.\n\t * Make a new entry with the remaining freespace.\n\t */\n\telse if (matchfront) {\n\t\tnewdup = (xfs_dir2_data_unused_t *)((char *)hdr + offset + len);\n\t\tnewdup->freetag = cpu_to_be16(XFS_DIR2_DATA_FREE_TAG);\n\t\tnewdup->length = cpu_to_be16(oldlen - len);\n\t\t*xfs_dir2_data_unused_tag_p(newdup) =\n\t\t\tcpu_to_be16((char *)newdup - (char *)hdr);\n\t\txfs_dir2_data_log_unused(args, bp, newdup);\n\t\t/*\n\t\t * If it was in the table, remove it and add the new one.\n\t\t */\n\t\tif (dfp) {\n\t\t\txfs_dir2_data_freeremove(hdr, bf, dfp, needlogp);\n\t\t\tdfp = xfs_dir2_data_freeinsert(hdr, bf, newdup,\n\t\t\t\t\t\t       needlogp);\n\t\t\tASSERT(dfp != NULL);\n\t\t\tASSERT(dfp->length == newdup->length);\n\t\t\tASSERT(be16_to_cpu(dfp->offset) == (char *)newdup - (char *)hdr);\n\t\t\t/*\n\t\t\t * If we got inserted at the last slot,\n\t\t\t * that means we don't know if there was a better\n\t\t\t * choice for the last slot, or not.  Rescan.\n\t\t\t */\n\t\t\tneedscan = dfp == &bf[2];\n\t\t}\n\t}\n\t/*\n\t * We match the last part of the entry.\n\t * Trim the allocated space off the tail of the entry.\n\t */\n\telse if (matchback) {\n\t\tnewdup = dup;\n\t\tnewdup->length = cpu_to_be16(((char *)hdr + offset) - (char *)newdup);\n\t\t*xfs_dir2_data_unused_tag_p(newdup) =\n\t\t\tcpu_to_be16((char *)newdup - (char *)hdr);\n\t\txfs_dir2_data_log_unused(args, bp, newdup);\n\t\t/*\n\t\t * If it was in the table, remove it and add the new one.\n\t\t */\n\t\tif (dfp) {\n\t\t\txfs_dir2_data_freeremove(hdr, bf, dfp, needlogp);\n\t\t\tdfp = xfs_dir2_data_freeinsert(hdr, bf, newdup,\n\t\t\t\t\t\t       needlogp);\n\t\t\tASSERT(dfp != NULL);\n\t\t\tASSERT(dfp->length == newdup->length);\n\t\t\tASSERT(be16_to_cpu(dfp->offset) == (char *)newdup - (char *)hdr);\n\t\t\t/*\n\t\t\t * If we got inserted at the last slot,\n\t\t\t * that means we don't know if there was a better\n\t\t\t * choice for the last slot, or not.  Rescan.\n\t\t\t */\n\t\t\tneedscan = dfp == &bf[2];\n\t\t}\n\t}\n\t/*\n\t * Poking out the middle of an entry.\n\t * Make two new entries.\n\t */\n\telse {\n\t\tnewdup = dup;\n\t\tnewdup->length = cpu_to_be16(((char *)hdr + offset) - (char *)newdup);\n\t\t*xfs_dir2_data_unused_tag_p(newdup) =\n\t\t\tcpu_to_be16((char *)newdup - (char *)hdr);\n\t\txfs_dir2_data_log_unused(args, bp, newdup);\n\t\tnewdup2 = (xfs_dir2_data_unused_t *)((char *)hdr + offset + len);\n\t\tnewdup2->freetag = cpu_to_be16(XFS_DIR2_DATA_FREE_TAG);\n\t\tnewdup2->length = cpu_to_be16(oldlen - len - be16_to_cpu(newdup->length));\n\t\t*xfs_dir2_data_unused_tag_p(newdup2) =\n\t\t\tcpu_to_be16((char *)newdup2 - (char *)hdr);\n\t\txfs_dir2_data_log_unused(args, bp, newdup2);\n\t\t/*\n\t\t * If the old entry was in the table, we need to scan\n\t\t * if the 3rd entry was valid, since these entries\n\t\t * are smaller than the old one.\n\t\t * If we don't need to scan that means there were 1 or 2\n\t\t * entries in the table, and removing the old and adding\n\t\t * the 2 new will work.\n\t\t */\n\t\tif (dfp) {\n\t\t\tneedscan = (bf[2].length != 0);\n\t\t\tif (!needscan) {\n\t\t\t\txfs_dir2_data_freeremove(hdr, bf, dfp,\n\t\t\t\t\t\t\t needlogp);\n\t\t\t\txfs_dir2_data_freeinsert(hdr, bf, newdup,\n\t\t\t\t\t\t\t needlogp);\n\t\t\t\txfs_dir2_data_freeinsert(hdr, bf, newdup2,\n\t\t\t\t\t\t\t needlogp);\n\t\t\t}\n\t\t}\n\t}\n\t*needscanp = needscan;\n}"
  },
  {
    "function_name": "xfs_dir2_data_make_free",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_dir2_data.c",
    "lines": "714-894",
    "snippet": "void\nxfs_dir2_data_make_free(\n\tstruct xfs_da_args\t*args,\n\tstruct xfs_buf\t\t*bp,\n\txfs_dir2_data_aoff_t\toffset,\t\t/* starting byte offset */\n\txfs_dir2_data_aoff_t\tlen,\t\t/* length in bytes */\n\tint\t\t\t*needlogp,\t/* out: log header */\n\tint\t\t\t*needscanp)\t/* out: regen bestfree */\n{\n\txfs_dir2_data_hdr_t\t*hdr;\t\t/* data block pointer */\n\txfs_dir2_data_free_t\t*dfp;\t\t/* bestfree pointer */\n\tchar\t\t\t*endptr;\t/* end of data area */\n\tint\t\t\tneedscan;\t/* need to regen bestfree */\n\txfs_dir2_data_unused_t\t*newdup;\t/* new unused entry */\n\txfs_dir2_data_unused_t\t*postdup;\t/* unused entry after us */\n\txfs_dir2_data_unused_t\t*prevdup;\t/* unused entry before us */\n\tstruct xfs_dir2_data_free *bf;\n\n\thdr = bp->b_addr;\n\n\t/*\n\t * Figure out where the end of the data area is.\n\t */\n\tif (hdr->magic == cpu_to_be32(XFS_DIR2_DATA_MAGIC) ||\n\t    hdr->magic == cpu_to_be32(XFS_DIR3_DATA_MAGIC))\n\t\tendptr = (char *)hdr + args->geo->blksize;\n\telse {\n\t\txfs_dir2_block_tail_t\t*btp;\t/* block tail */\n\n\t\tASSERT(hdr->magic == cpu_to_be32(XFS_DIR2_BLOCK_MAGIC) ||\n\t\t\thdr->magic == cpu_to_be32(XFS_DIR3_BLOCK_MAGIC));\n\t\tbtp = xfs_dir2_block_tail_p(args->geo, hdr);\n\t\tendptr = (char *)xfs_dir2_block_leaf_p(btp);\n\t}\n\t/*\n\t * If this isn't the start of the block, then back up to\n\t * the previous entry and see if it's free.\n\t */\n\tif (offset > args->dp->d_ops->data_entry_offset) {\n\t\t__be16\t\t\t*tagp;\t/* tag just before us */\n\n\t\ttagp = (__be16 *)((char *)hdr + offset) - 1;\n\t\tprevdup = (xfs_dir2_data_unused_t *)((char *)hdr + be16_to_cpu(*tagp));\n\t\tif (be16_to_cpu(prevdup->freetag) != XFS_DIR2_DATA_FREE_TAG)\n\t\t\tprevdup = NULL;\n\t} else\n\t\tprevdup = NULL;\n\t/*\n\t * If this isn't the end of the block, see if the entry after\n\t * us is free.\n\t */\n\tif ((char *)hdr + offset + len < endptr) {\n\t\tpostdup =\n\t\t\t(xfs_dir2_data_unused_t *)((char *)hdr + offset + len);\n\t\tif (be16_to_cpu(postdup->freetag) != XFS_DIR2_DATA_FREE_TAG)\n\t\t\tpostdup = NULL;\n\t} else\n\t\tpostdup = NULL;\n\tASSERT(*needscanp == 0);\n\tneedscan = 0;\n\t/*\n\t * Previous and following entries are both free,\n\t * merge everything into a single free entry.\n\t */\n\tbf = args->dp->d_ops->data_bestfree_p(hdr);\n\tif (prevdup && postdup) {\n\t\txfs_dir2_data_free_t\t*dfp2;\t/* another bestfree pointer */\n\n\t\t/*\n\t\t * See if prevdup and/or postdup are in bestfree table.\n\t\t */\n\t\tdfp = xfs_dir2_data_freefind(hdr, bf, prevdup);\n\t\tdfp2 = xfs_dir2_data_freefind(hdr, bf, postdup);\n\t\t/*\n\t\t * We need a rescan unless there are exactly 2 free entries\n\t\t * namely our two.  Then we know what's happening, otherwise\n\t\t * since the third bestfree is there, there might be more\n\t\t * entries.\n\t\t */\n\t\tneedscan = (bf[2].length != 0);\n\t\t/*\n\t\t * Fix up the new big freespace.\n\t\t */\n\t\tbe16_add_cpu(&prevdup->length, len + be16_to_cpu(postdup->length));\n\t\t*xfs_dir2_data_unused_tag_p(prevdup) =\n\t\t\tcpu_to_be16((char *)prevdup - (char *)hdr);\n\t\txfs_dir2_data_log_unused(args, bp, prevdup);\n\t\tif (!needscan) {\n\t\t\t/*\n\t\t\t * Has to be the case that entries 0 and 1 are\n\t\t\t * dfp and dfp2 (don't know which is which), and\n\t\t\t * entry 2 is empty.\n\t\t\t * Remove entry 1 first then entry 0.\n\t\t\t */\n\t\t\tASSERT(dfp && dfp2);\n\t\t\tif (dfp == &bf[1]) {\n\t\t\t\tdfp = &bf[0];\n\t\t\t\tASSERT(dfp2 == dfp);\n\t\t\t\tdfp2 = &bf[1];\n\t\t\t}\n\t\t\txfs_dir2_data_freeremove(hdr, bf, dfp2, needlogp);\n\t\t\txfs_dir2_data_freeremove(hdr, bf, dfp, needlogp);\n\t\t\t/*\n\t\t\t * Now insert the new entry.\n\t\t\t */\n\t\t\tdfp = xfs_dir2_data_freeinsert(hdr, bf, prevdup,\n\t\t\t\t\t\t       needlogp);\n\t\t\tASSERT(dfp == &bf[0]);\n\t\t\tASSERT(dfp->length == prevdup->length);\n\t\t\tASSERT(!dfp[1].length);\n\t\t\tASSERT(!dfp[2].length);\n\t\t}\n\t}\n\t/*\n\t * The entry before us is free, merge with it.\n\t */\n\telse if (prevdup) {\n\t\tdfp = xfs_dir2_data_freefind(hdr, bf, prevdup);\n\t\tbe16_add_cpu(&prevdup->length, len);\n\t\t*xfs_dir2_data_unused_tag_p(prevdup) =\n\t\t\tcpu_to_be16((char *)prevdup - (char *)hdr);\n\t\txfs_dir2_data_log_unused(args, bp, prevdup);\n\t\t/*\n\t\t * If the previous entry was in the table, the new entry\n\t\t * is longer, so it will be in the table too.  Remove\n\t\t * the old one and add the new one.\n\t\t */\n\t\tif (dfp) {\n\t\t\txfs_dir2_data_freeremove(hdr, bf, dfp, needlogp);\n\t\t\txfs_dir2_data_freeinsert(hdr, bf, prevdup, needlogp);\n\t\t}\n\t\t/*\n\t\t * Otherwise we need a scan if the new entry is big enough.\n\t\t */\n\t\telse {\n\t\t\tneedscan = be16_to_cpu(prevdup->length) >\n\t\t\t\t   be16_to_cpu(bf[2].length);\n\t\t}\n\t}\n\t/*\n\t * The following entry is free, merge with it.\n\t */\n\telse if (postdup) {\n\t\tdfp = xfs_dir2_data_freefind(hdr, bf, postdup);\n\t\tnewdup = (xfs_dir2_data_unused_t *)((char *)hdr + offset);\n\t\tnewdup->freetag = cpu_to_be16(XFS_DIR2_DATA_FREE_TAG);\n\t\tnewdup->length = cpu_to_be16(len + be16_to_cpu(postdup->length));\n\t\t*xfs_dir2_data_unused_tag_p(newdup) =\n\t\t\tcpu_to_be16((char *)newdup - (char *)hdr);\n\t\txfs_dir2_data_log_unused(args, bp, newdup);\n\t\t/*\n\t\t * If the following entry was in the table, the new entry\n\t\t * is longer, so it will be in the table too.  Remove\n\t\t * the old one and add the new one.\n\t\t */\n\t\tif (dfp) {\n\t\t\txfs_dir2_data_freeremove(hdr, bf, dfp, needlogp);\n\t\t\txfs_dir2_data_freeinsert(hdr, bf, newdup, needlogp);\n\t\t}\n\t\t/*\n\t\t * Otherwise we need a scan if the new entry is big enough.\n\t\t */\n\t\telse {\n\t\t\tneedscan = be16_to_cpu(newdup->length) >\n\t\t\t\t   be16_to_cpu(bf[2].length);\n\t\t}\n\t}\n\t/*\n\t * Neither neighbor is free.  Make a new entry.\n\t */\n\telse {\n\t\tnewdup = (xfs_dir2_data_unused_t *)((char *)hdr + offset);\n\t\tnewdup->freetag = cpu_to_be16(XFS_DIR2_DATA_FREE_TAG);\n\t\tnewdup->length = cpu_to_be16(len);\n\t\t*xfs_dir2_data_unused_tag_p(newdup) =\n\t\t\tcpu_to_be16((char *)newdup - (char *)hdr);\n\t\txfs_dir2_data_log_unused(args, bp, newdup);\n\t\txfs_dir2_data_freeinsert(hdr, bf, newdup, needlogp);\n\t}\n\t*needscanp = needscan;\n}",
    "includes": [
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_buf_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_dir2_priv.h\"",
      "#include \"xfs_dir2.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_da_btree.h\"",
      "#include \"xfs_da_format.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_dir2_data_freeinsert",
          "args": [
            "hdr",
            "bf",
            "newdup",
            "needlogp"
          ],
          "line": 891
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_dir2_data_freeinsert",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_dir2_data.c",
          "lines": "415-454",
          "snippet": "xfs_dir2_data_free_t *\t\t\t\t/* entry inserted */\nxfs_dir2_data_freeinsert(\n\tstruct xfs_dir2_data_hdr *hdr,\t\t/* data block pointer */\n\tstruct xfs_dir2_data_free *dfp,\t\t/* bestfree table pointer */\n\tstruct xfs_dir2_data_unused *dup,\t/* unused space */\n\tint\t\t\t*loghead)\t/* log the data header (out) */\n{\n\txfs_dir2_data_free_t\tnew;\t\t/* new bestfree entry */\n\n\tASSERT(hdr->magic == cpu_to_be32(XFS_DIR2_DATA_MAGIC) ||\n\t       hdr->magic == cpu_to_be32(XFS_DIR2_BLOCK_MAGIC) ||\n\t       hdr->magic == cpu_to_be32(XFS_DIR3_DATA_MAGIC) ||\n\t       hdr->magic == cpu_to_be32(XFS_DIR3_BLOCK_MAGIC));\n\n\tnew.length = dup->length;\n\tnew.offset = cpu_to_be16((char *)dup - (char *)hdr);\n\n\t/*\n\t * Insert at position 0, 1, or 2; or not at all.\n\t */\n\tif (be16_to_cpu(new.length) > be16_to_cpu(dfp[0].length)) {\n\t\tdfp[2] = dfp[1];\n\t\tdfp[1] = dfp[0];\n\t\tdfp[0] = new;\n\t\t*loghead = 1;\n\t\treturn &dfp[0];\n\t}\n\tif (be16_to_cpu(new.length) > be16_to_cpu(dfp[1].length)) {\n\t\tdfp[2] = dfp[1];\n\t\tdfp[1] = new;\n\t\t*loghead = 1;\n\t\treturn &dfp[1];\n\t}\n\tif (be16_to_cpu(new.length) > be16_to_cpu(dfp[2].length)) {\n\t\tdfp[2] = new;\n\t\t*loghead = 1;\n\t\treturn &dfp[2];\n\t}\n\treturn NULL;\n}",
          "includes": [
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_dir2_priv.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_cksum.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_error.h\"\n#include \"xfs_dir2_priv.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nxfs_dir2_data_free_t *\t\t\t\t/* entry inserted */\nxfs_dir2_data_freeinsert(\n\tstruct xfs_dir2_data_hdr *hdr,\t\t/* data block pointer */\n\tstruct xfs_dir2_data_free *dfp,\t\t/* bestfree table pointer */\n\tstruct xfs_dir2_data_unused *dup,\t/* unused space */\n\tint\t\t\t*loghead)\t/* log the data header (out) */\n{\n\txfs_dir2_data_free_t\tnew;\t\t/* new bestfree entry */\n\n\tASSERT(hdr->magic == cpu_to_be32(XFS_DIR2_DATA_MAGIC) ||\n\t       hdr->magic == cpu_to_be32(XFS_DIR2_BLOCK_MAGIC) ||\n\t       hdr->magic == cpu_to_be32(XFS_DIR3_DATA_MAGIC) ||\n\t       hdr->magic == cpu_to_be32(XFS_DIR3_BLOCK_MAGIC));\n\n\tnew.length = dup->length;\n\tnew.offset = cpu_to_be16((char *)dup - (char *)hdr);\n\n\t/*\n\t * Insert at position 0, 1, or 2; or not at all.\n\t */\n\tif (be16_to_cpu(new.length) > be16_to_cpu(dfp[0].length)) {\n\t\tdfp[2] = dfp[1];\n\t\tdfp[1] = dfp[0];\n\t\tdfp[0] = new;\n\t\t*loghead = 1;\n\t\treturn &dfp[0];\n\t}\n\tif (be16_to_cpu(new.length) > be16_to_cpu(dfp[1].length)) {\n\t\tdfp[2] = dfp[1];\n\t\tdfp[1] = new;\n\t\t*loghead = 1;\n\t\treturn &dfp[1];\n\t}\n\tif (be16_to_cpu(new.length) > be16_to_cpu(dfp[2].length)) {\n\t\tdfp[2] = new;\n\t\t*loghead = 1;\n\t\treturn &dfp[2];\n\t}\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_dir2_data_log_unused",
          "args": [
            "args",
            "bp",
            "newdup"
          ],
          "line": 890
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_dir2_data_log_unused",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_dir2_data.c",
          "lines": "682-708",
          "snippet": "void\nxfs_dir2_data_log_unused(\n\tstruct xfs_da_args\t*args,\n\tstruct xfs_buf\t\t*bp,\n\txfs_dir2_data_unused_t\t*dup)\t\t/* data unused pointer */\n{\n\txfs_dir2_data_hdr_t\t*hdr = bp->b_addr;\n\n\tASSERT(hdr->magic == cpu_to_be32(XFS_DIR2_DATA_MAGIC) ||\n\t       hdr->magic == cpu_to_be32(XFS_DIR3_DATA_MAGIC) ||\n\t       hdr->magic == cpu_to_be32(XFS_DIR2_BLOCK_MAGIC) ||\n\t       hdr->magic == cpu_to_be32(XFS_DIR3_BLOCK_MAGIC));\n\n\t/*\n\t * Log the first part of the unused entry.\n\t */\n\txfs_trans_log_buf(args->trans, bp, (uint)((char *)dup - (char *)hdr),\n\t\t(uint)((char *)&dup->length + sizeof(dup->length) -\n\t\t       1 - (char *)hdr));\n\t/*\n\t * Log the end (tag) of the unused entry.\n\t */\n\txfs_trans_log_buf(args->trans, bp,\n\t\t(uint)((char *)xfs_dir2_data_unused_tag_p(dup) - (char *)hdr),\n\t\t(uint)((char *)xfs_dir2_data_unused_tag_p(dup) - (char *)hdr +\n\t\t       sizeof(xfs_dir2_data_off_t) - 1));\n}",
          "includes": [
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_dir2_priv.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_cksum.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_error.h\"\n#include \"xfs_dir2_priv.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_dir2_data_log_unused(\n\tstruct xfs_da_args\t*args,\n\tstruct xfs_buf\t\t*bp,\n\txfs_dir2_data_unused_t\t*dup)\t\t/* data unused pointer */\n{\n\txfs_dir2_data_hdr_t\t*hdr = bp->b_addr;\n\n\tASSERT(hdr->magic == cpu_to_be32(XFS_DIR2_DATA_MAGIC) ||\n\t       hdr->magic == cpu_to_be32(XFS_DIR3_DATA_MAGIC) ||\n\t       hdr->magic == cpu_to_be32(XFS_DIR2_BLOCK_MAGIC) ||\n\t       hdr->magic == cpu_to_be32(XFS_DIR3_BLOCK_MAGIC));\n\n\t/*\n\t * Log the first part of the unused entry.\n\t */\n\txfs_trans_log_buf(args->trans, bp, (uint)((char *)dup - (char *)hdr),\n\t\t(uint)((char *)&dup->length + sizeof(dup->length) -\n\t\t       1 - (char *)hdr));\n\t/*\n\t * Log the end (tag) of the unused entry.\n\t */\n\txfs_trans_log_buf(args->trans, bp,\n\t\t(uint)((char *)xfs_dir2_data_unused_tag_p(dup) - (char *)hdr),\n\t\t(uint)((char *)xfs_dir2_data_unused_tag_p(dup) - (char *)hdr +\n\t\t       sizeof(xfs_dir2_data_off_t) - 1));\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_be16",
          "args": [
            "(char *)newdup - (char *)hdr"
          ],
          "line": 889
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_dir2_data_unused_tag_p",
          "args": [
            "newdup"
          ],
          "line": 888
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_dir2_data_unused_tag_p",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_da_format.h",
          "lines": "407-412",
          "snippet": "static inline __be16 *\nxfs_dir2_data_unused_tag_p(struct xfs_dir2_data_unused *dup)\n{\n\treturn (__be16 *)((char *)dup +\n\t\t\tbe16_to_cpu(dup->length) - sizeof(__be16));\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline __be16 *\nxfs_dir2_data_unused_tag_p(struct xfs_dir2_data_unused *dup)\n{\n\treturn (__be16 *)((char *)dup +\n\t\t\tbe16_to_cpu(dup->length) - sizeof(__be16));\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_be16",
          "args": [
            "len"
          ],
          "line": 887
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be16",
          "args": [
            "XFS_DIR2_DATA_FREE_TAG"
          ],
          "line": 886
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be16_to_cpu",
          "args": [
            "bf[2].length"
          ],
          "line": 878
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be16_to_cpu",
          "args": [
            "newdup->length"
          ],
          "line": 877
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_dir2_data_freeremove",
          "args": [
            "hdr",
            "bf",
            "dfp",
            "needlogp"
          ],
          "line": 870
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_dir2_data_freeremove",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_dir2_data.c",
          "lines": "459-495",
          "snippet": "STATIC void\nxfs_dir2_data_freeremove(\n\tstruct xfs_dir2_data_hdr *hdr,\t\t/* data block header */\n\tstruct xfs_dir2_data_free *bf,\t\t/* bestfree table pointer */\n\tstruct xfs_dir2_data_free *dfp,\t\t/* bestfree entry pointer */\n\tint\t\t\t*loghead)\t/* out: log data header */\n{\n\n\tASSERT(hdr->magic == cpu_to_be32(XFS_DIR2_DATA_MAGIC) ||\n\t       hdr->magic == cpu_to_be32(XFS_DIR2_BLOCK_MAGIC) ||\n\t       hdr->magic == cpu_to_be32(XFS_DIR3_DATA_MAGIC) ||\n\t       hdr->magic == cpu_to_be32(XFS_DIR3_BLOCK_MAGIC));\n\n\t/*\n\t * It's the first entry, slide the next 2 up.\n\t */\n\tif (dfp == &bf[0]) {\n\t\tbf[0] = bf[1];\n\t\tbf[1] = bf[2];\n\t}\n\t/*\n\t * It's the second entry, slide the 3rd entry up.\n\t */\n\telse if (dfp == &bf[1])\n\t\tbf[1] = bf[2];\n\t/*\n\t * Must be the last entry.\n\t */\n\telse\n\t\tASSERT(dfp == &bf[2]);\n\t/*\n\t * Clear the 3rd entry, must be zero now.\n\t */\n\tbf[2].length = 0;\n\tbf[2].offset = 0;\n\t*loghead = 1;\n}",
          "includes": [
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_dir2_priv.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_cksum.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_error.h\"\n#include \"xfs_dir2_priv.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC void\nxfs_dir2_data_freeremove(\n\tstruct xfs_dir2_data_hdr *hdr,\t\t/* data block header */\n\tstruct xfs_dir2_data_free *bf,\t\t/* bestfree table pointer */\n\tstruct xfs_dir2_data_free *dfp,\t\t/* bestfree entry pointer */\n\tint\t\t\t*loghead)\t/* out: log data header */\n{\n\n\tASSERT(hdr->magic == cpu_to_be32(XFS_DIR2_DATA_MAGIC) ||\n\t       hdr->magic == cpu_to_be32(XFS_DIR2_BLOCK_MAGIC) ||\n\t       hdr->magic == cpu_to_be32(XFS_DIR3_DATA_MAGIC) ||\n\t       hdr->magic == cpu_to_be32(XFS_DIR3_BLOCK_MAGIC));\n\n\t/*\n\t * It's the first entry, slide the next 2 up.\n\t */\n\tif (dfp == &bf[0]) {\n\t\tbf[0] = bf[1];\n\t\tbf[1] = bf[2];\n\t}\n\t/*\n\t * It's the second entry, slide the 3rd entry up.\n\t */\n\telse if (dfp == &bf[1])\n\t\tbf[1] = bf[2];\n\t/*\n\t * Must be the last entry.\n\t */\n\telse\n\t\tASSERT(dfp == &bf[2]);\n\t/*\n\t * Clear the 3rd entry, must be zero now.\n\t */\n\tbf[2].length = 0;\n\tbf[2].offset = 0;\n\t*loghead = 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_be16",
          "args": [
            "(char *)newdup - (char *)hdr"
          ],
          "line": 862
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be16",
          "args": [
            "len + be16_to_cpu(postdup->length)"
          ],
          "line": 860
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be16_to_cpu",
          "args": [
            "postdup->length"
          ],
          "line": 860
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be16",
          "args": [
            "XFS_DIR2_DATA_FREE_TAG"
          ],
          "line": 859
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_dir2_data_freefind",
          "args": [
            "hdr",
            "bf",
            "postdup"
          ],
          "line": 857
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_dir2_data_freefind",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_dir2_data.c",
          "lines": "344-410",
          "snippet": "xfs_dir2_data_free_t *\nxfs_dir2_data_freefind(\n\tstruct xfs_dir2_data_hdr *hdr,\t\t/* data block header */\n\tstruct xfs_dir2_data_free *bf,\t\t/* bestfree table pointer */\n\tstruct xfs_dir2_data_unused *dup)\t/* unused space */\n{\n\txfs_dir2_data_free_t\t*dfp;\t\t/* bestfree entry */\n\txfs_dir2_data_aoff_t\toff;\t\t/* offset value needed */\n#ifdef DEBUG\n\tint\t\t\tmatched;\t/* matched the value */\n\tint\t\t\tseenzero;\t/* saw a 0 bestfree entry */\n#endif\n\n\toff = (xfs_dir2_data_aoff_t)((char *)dup - (char *)hdr);\n\n#ifdef DEBUG\n\t/*\n\t * Validate some consistency in the bestfree table.\n\t * Check order, non-overlapping entries, and if we find the\n\t * one we're looking for it has to be exact.\n\t */\n\tASSERT(hdr->magic == cpu_to_be32(XFS_DIR2_DATA_MAGIC) ||\n\t       hdr->magic == cpu_to_be32(XFS_DIR3_DATA_MAGIC) ||\n\t       hdr->magic == cpu_to_be32(XFS_DIR2_BLOCK_MAGIC) ||\n\t       hdr->magic == cpu_to_be32(XFS_DIR3_BLOCK_MAGIC));\n\tfor (dfp = &bf[0], seenzero = matched = 0;\n\t     dfp < &bf[XFS_DIR2_DATA_FD_COUNT];\n\t     dfp++) {\n\t\tif (!dfp->offset) {\n\t\t\tASSERT(!dfp->length);\n\t\t\tseenzero = 1;\n\t\t\tcontinue;\n\t\t}\n\t\tASSERT(seenzero == 0);\n\t\tif (be16_to_cpu(dfp->offset) == off) {\n\t\t\tmatched = 1;\n\t\t\tASSERT(dfp->length == dup->length);\n\t\t} else if (off < be16_to_cpu(dfp->offset))\n\t\t\tASSERT(off + be16_to_cpu(dup->length) <= be16_to_cpu(dfp->offset));\n\t\telse\n\t\t\tASSERT(be16_to_cpu(dfp->offset) + be16_to_cpu(dfp->length) <= off);\n\t\tASSERT(matched || be16_to_cpu(dfp->length) >= be16_to_cpu(dup->length));\n\t\tif (dfp > &bf[0])\n\t\t\tASSERT(be16_to_cpu(dfp[-1].length) >= be16_to_cpu(dfp[0].length));\n\t}\n#endif\n\t/*\n\t * If this is smaller than the smallest bestfree entry,\n\t * it can't be there since they're sorted.\n\t */\n\tif (be16_to_cpu(dup->length) <\n\t    be16_to_cpu(bf[XFS_DIR2_DATA_FD_COUNT - 1].length))\n\t\treturn NULL;\n\t/*\n\t * Look at the three bestfree entries for our guy.\n\t */\n\tfor (dfp = &bf[0]; dfp < &bf[XFS_DIR2_DATA_FD_COUNT]; dfp++) {\n\t\tif (!dfp->offset)\n\t\t\treturn NULL;\n\t\tif (be16_to_cpu(dfp->offset) == off)\n\t\t\treturn dfp;\n\t}\n\t/*\n\t * Didn't find it.  This only happens if there are duplicate lengths.\n\t */\n\treturn NULL;\n}",
          "includes": [
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_dir2_priv.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_cksum.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_error.h\"\n#include \"xfs_dir2_priv.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nxfs_dir2_data_free_t *\nxfs_dir2_data_freefind(\n\tstruct xfs_dir2_data_hdr *hdr,\t\t/* data block header */\n\tstruct xfs_dir2_data_free *bf,\t\t/* bestfree table pointer */\n\tstruct xfs_dir2_data_unused *dup)\t/* unused space */\n{\n\txfs_dir2_data_free_t\t*dfp;\t\t/* bestfree entry */\n\txfs_dir2_data_aoff_t\toff;\t\t/* offset value needed */\n#ifdef DEBUG\n\tint\t\t\tmatched;\t/* matched the value */\n\tint\t\t\tseenzero;\t/* saw a 0 bestfree entry */\n#endif\n\n\toff = (xfs_dir2_data_aoff_t)((char *)dup - (char *)hdr);\n\n#ifdef DEBUG\n\t/*\n\t * Validate some consistency in the bestfree table.\n\t * Check order, non-overlapping entries, and if we find the\n\t * one we're looking for it has to be exact.\n\t */\n\tASSERT(hdr->magic == cpu_to_be32(XFS_DIR2_DATA_MAGIC) ||\n\t       hdr->magic == cpu_to_be32(XFS_DIR3_DATA_MAGIC) ||\n\t       hdr->magic == cpu_to_be32(XFS_DIR2_BLOCK_MAGIC) ||\n\t       hdr->magic == cpu_to_be32(XFS_DIR3_BLOCK_MAGIC));\n\tfor (dfp = &bf[0], seenzero = matched = 0;\n\t     dfp < &bf[XFS_DIR2_DATA_FD_COUNT];\n\t     dfp++) {\n\t\tif (!dfp->offset) {\n\t\t\tASSERT(!dfp->length);\n\t\t\tseenzero = 1;\n\t\t\tcontinue;\n\t\t}\n\t\tASSERT(seenzero == 0);\n\t\tif (be16_to_cpu(dfp->offset) == off) {\n\t\t\tmatched = 1;\n\t\t\tASSERT(dfp->length == dup->length);\n\t\t} else if (off < be16_to_cpu(dfp->offset))\n\t\t\tASSERT(off + be16_to_cpu(dup->length) <= be16_to_cpu(dfp->offset));\n\t\telse\n\t\t\tASSERT(be16_to_cpu(dfp->offset) + be16_to_cpu(dfp->length) <= off);\n\t\tASSERT(matched || be16_to_cpu(dfp->length) >= be16_to_cpu(dup->length));\n\t\tif (dfp > &bf[0])\n\t\t\tASSERT(be16_to_cpu(dfp[-1].length) >= be16_to_cpu(dfp[0].length));\n\t}\n#endif\n\t/*\n\t * If this is smaller than the smallest bestfree entry,\n\t * it can't be there since they're sorted.\n\t */\n\tif (be16_to_cpu(dup->length) <\n\t    be16_to_cpu(bf[XFS_DIR2_DATA_FD_COUNT - 1].length))\n\t\treturn NULL;\n\t/*\n\t * Look at the three bestfree entries for our guy.\n\t */\n\tfor (dfp = &bf[0]; dfp < &bf[XFS_DIR2_DATA_FD_COUNT]; dfp++) {\n\t\tif (!dfp->offset)\n\t\t\treturn NULL;\n\t\tif (be16_to_cpu(dfp->offset) == off)\n\t\t\treturn dfp;\n\t}\n\t/*\n\t * Didn't find it.  This only happens if there are duplicate lengths.\n\t */\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "be16_to_cpu",
          "args": [
            "bf[2].length"
          ],
          "line": 850
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be16_to_cpu",
          "args": [
            "prevdup->length"
          ],
          "line": 849
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be16",
          "args": [
            "(char *)prevdup - (char *)hdr"
          ],
          "line": 834
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be16_add_cpu",
          "args": [
            "&prevdup->length",
            "len"
          ],
          "line": 832
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "!dfp[2].length"
          ],
          "line": 824
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "!dfp[1].length"
          ],
          "line": 823
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "dfp->length == prevdup->length"
          ],
          "line": 822
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "dfp == &bf[0]"
          ],
          "line": 821
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "dfp2 == dfp"
          ],
          "line": 811
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "dfp && dfp2"
          ],
          "line": 808
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be16",
          "args": [
            "(char *)prevdup - (char *)hdr"
          ],
          "line": 799
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be16_add_cpu",
          "args": [
            "&prevdup->length",
            "len + be16_to_cpu(postdup->length)"
          ],
          "line": 797
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be16_to_cpu",
          "args": [
            "postdup->length"
          ],
          "line": 797
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "args->dp->d_ops->data_bestfree_p",
          "args": [
            "hdr"
          ],
          "line": 778
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "*needscanp == 0"
          ],
          "line": 772
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be16_to_cpu",
          "args": [
            "postdup->freetag"
          ],
          "line": 768
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be16_to_cpu",
          "args": [
            "prevdup->freetag"
          ],
          "line": 757
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be16_to_cpu",
          "args": [
            "*tagp"
          ],
          "line": 756
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_dir2_block_leaf_p",
          "args": [
            "btp"
          ],
          "line": 746
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_dir2_block_leaf_p",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_da_format.h",
          "lines": "601-605",
          "snippet": "static inline struct xfs_dir2_leaf_entry *\nxfs_dir2_block_leaf_p(struct xfs_dir2_block_tail *btp)\n{\n\treturn ((struct xfs_dir2_leaf_entry *)btp) - be32_to_cpu(btp->count);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline struct xfs_dir2_leaf_entry *\nxfs_dir2_block_leaf_p(struct xfs_dir2_block_tail *btp)\n{\n\treturn ((struct xfs_dir2_leaf_entry *)btp) - be32_to_cpu(btp->count);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_dir2_block_tail_p",
          "args": [
            "args->geo",
            "hdr"
          ],
          "line": 745
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_dir2_block_tail_p",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_dir2.h",
          "lines": "305-310",
          "snippet": "static inline struct xfs_dir2_block_tail *\nxfs_dir2_block_tail_p(struct xfs_da_geometry *geo, struct xfs_dir2_data_hdr *hdr)\n{\n\treturn ((struct xfs_dir2_block_tail *)\n\t\t((char *)hdr + geo->blksize)) - 1;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline struct xfs_dir2_block_tail *\nxfs_dir2_block_tail_p(struct xfs_da_geometry *geo, struct xfs_dir2_data_hdr *hdr)\n{\n\treturn ((struct xfs_dir2_block_tail *)\n\t\t((char *)hdr + geo->blksize)) - 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "hdr->magic == cpu_to_be32(XFS_DIR2_BLOCK_MAGIC) ||\n\t\t\thdr->magic == cpu_to_be32(XFS_DIR3_BLOCK_MAGIC)"
          ],
          "line": 743
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "XFS_DIR3_BLOCK_MAGIC"
          ],
          "line": 744
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "XFS_DIR2_BLOCK_MAGIC"
          ],
          "line": 743
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "XFS_DIR3_DATA_MAGIC"
          ],
          "line": 738
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "XFS_DIR2_DATA_MAGIC"
          ],
          "line": 737
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_cksum.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_error.h\"\n#include \"xfs_dir2_priv.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_dir2_data_make_free(\n\tstruct xfs_da_args\t*args,\n\tstruct xfs_buf\t\t*bp,\n\txfs_dir2_data_aoff_t\toffset,\t\t/* starting byte offset */\n\txfs_dir2_data_aoff_t\tlen,\t\t/* length in bytes */\n\tint\t\t\t*needlogp,\t/* out: log header */\n\tint\t\t\t*needscanp)\t/* out: regen bestfree */\n{\n\txfs_dir2_data_hdr_t\t*hdr;\t\t/* data block pointer */\n\txfs_dir2_data_free_t\t*dfp;\t\t/* bestfree pointer */\n\tchar\t\t\t*endptr;\t/* end of data area */\n\tint\t\t\tneedscan;\t/* need to regen bestfree */\n\txfs_dir2_data_unused_t\t*newdup;\t/* new unused entry */\n\txfs_dir2_data_unused_t\t*postdup;\t/* unused entry after us */\n\txfs_dir2_data_unused_t\t*prevdup;\t/* unused entry before us */\n\tstruct xfs_dir2_data_free *bf;\n\n\thdr = bp->b_addr;\n\n\t/*\n\t * Figure out where the end of the data area is.\n\t */\n\tif (hdr->magic == cpu_to_be32(XFS_DIR2_DATA_MAGIC) ||\n\t    hdr->magic == cpu_to_be32(XFS_DIR3_DATA_MAGIC))\n\t\tendptr = (char *)hdr + args->geo->blksize;\n\telse {\n\t\txfs_dir2_block_tail_t\t*btp;\t/* block tail */\n\n\t\tASSERT(hdr->magic == cpu_to_be32(XFS_DIR2_BLOCK_MAGIC) ||\n\t\t\thdr->magic == cpu_to_be32(XFS_DIR3_BLOCK_MAGIC));\n\t\tbtp = xfs_dir2_block_tail_p(args->geo, hdr);\n\t\tendptr = (char *)xfs_dir2_block_leaf_p(btp);\n\t}\n\t/*\n\t * If this isn't the start of the block, then back up to\n\t * the previous entry and see if it's free.\n\t */\n\tif (offset > args->dp->d_ops->data_entry_offset) {\n\t\t__be16\t\t\t*tagp;\t/* tag just before us */\n\n\t\ttagp = (__be16 *)((char *)hdr + offset) - 1;\n\t\tprevdup = (xfs_dir2_data_unused_t *)((char *)hdr + be16_to_cpu(*tagp));\n\t\tif (be16_to_cpu(prevdup->freetag) != XFS_DIR2_DATA_FREE_TAG)\n\t\t\tprevdup = NULL;\n\t} else\n\t\tprevdup = NULL;\n\t/*\n\t * If this isn't the end of the block, see if the entry after\n\t * us is free.\n\t */\n\tif ((char *)hdr + offset + len < endptr) {\n\t\tpostdup =\n\t\t\t(xfs_dir2_data_unused_t *)((char *)hdr + offset + len);\n\t\tif (be16_to_cpu(postdup->freetag) != XFS_DIR2_DATA_FREE_TAG)\n\t\t\tpostdup = NULL;\n\t} else\n\t\tpostdup = NULL;\n\tASSERT(*needscanp == 0);\n\tneedscan = 0;\n\t/*\n\t * Previous and following entries are both free,\n\t * merge everything into a single free entry.\n\t */\n\tbf = args->dp->d_ops->data_bestfree_p(hdr);\n\tif (prevdup && postdup) {\n\t\txfs_dir2_data_free_t\t*dfp2;\t/* another bestfree pointer */\n\n\t\t/*\n\t\t * See if prevdup and/or postdup are in bestfree table.\n\t\t */\n\t\tdfp = xfs_dir2_data_freefind(hdr, bf, prevdup);\n\t\tdfp2 = xfs_dir2_data_freefind(hdr, bf, postdup);\n\t\t/*\n\t\t * We need a rescan unless there are exactly 2 free entries\n\t\t * namely our two.  Then we know what's happening, otherwise\n\t\t * since the third bestfree is there, there might be more\n\t\t * entries.\n\t\t */\n\t\tneedscan = (bf[2].length != 0);\n\t\t/*\n\t\t * Fix up the new big freespace.\n\t\t */\n\t\tbe16_add_cpu(&prevdup->length, len + be16_to_cpu(postdup->length));\n\t\t*xfs_dir2_data_unused_tag_p(prevdup) =\n\t\t\tcpu_to_be16((char *)prevdup - (char *)hdr);\n\t\txfs_dir2_data_log_unused(args, bp, prevdup);\n\t\tif (!needscan) {\n\t\t\t/*\n\t\t\t * Has to be the case that entries 0 and 1 are\n\t\t\t * dfp and dfp2 (don't know which is which), and\n\t\t\t * entry 2 is empty.\n\t\t\t * Remove entry 1 first then entry 0.\n\t\t\t */\n\t\t\tASSERT(dfp && dfp2);\n\t\t\tif (dfp == &bf[1]) {\n\t\t\t\tdfp = &bf[0];\n\t\t\t\tASSERT(dfp2 == dfp);\n\t\t\t\tdfp2 = &bf[1];\n\t\t\t}\n\t\t\txfs_dir2_data_freeremove(hdr, bf, dfp2, needlogp);\n\t\t\txfs_dir2_data_freeremove(hdr, bf, dfp, needlogp);\n\t\t\t/*\n\t\t\t * Now insert the new entry.\n\t\t\t */\n\t\t\tdfp = xfs_dir2_data_freeinsert(hdr, bf, prevdup,\n\t\t\t\t\t\t       needlogp);\n\t\t\tASSERT(dfp == &bf[0]);\n\t\t\tASSERT(dfp->length == prevdup->length);\n\t\t\tASSERT(!dfp[1].length);\n\t\t\tASSERT(!dfp[2].length);\n\t\t}\n\t}\n\t/*\n\t * The entry before us is free, merge with it.\n\t */\n\telse if (prevdup) {\n\t\tdfp = xfs_dir2_data_freefind(hdr, bf, prevdup);\n\t\tbe16_add_cpu(&prevdup->length, len);\n\t\t*xfs_dir2_data_unused_tag_p(prevdup) =\n\t\t\tcpu_to_be16((char *)prevdup - (char *)hdr);\n\t\txfs_dir2_data_log_unused(args, bp, prevdup);\n\t\t/*\n\t\t * If the previous entry was in the table, the new entry\n\t\t * is longer, so it will be in the table too.  Remove\n\t\t * the old one and add the new one.\n\t\t */\n\t\tif (dfp) {\n\t\t\txfs_dir2_data_freeremove(hdr, bf, dfp, needlogp);\n\t\t\txfs_dir2_data_freeinsert(hdr, bf, prevdup, needlogp);\n\t\t}\n\t\t/*\n\t\t * Otherwise we need a scan if the new entry is big enough.\n\t\t */\n\t\telse {\n\t\t\tneedscan = be16_to_cpu(prevdup->length) >\n\t\t\t\t   be16_to_cpu(bf[2].length);\n\t\t}\n\t}\n\t/*\n\t * The following entry is free, merge with it.\n\t */\n\telse if (postdup) {\n\t\tdfp = xfs_dir2_data_freefind(hdr, bf, postdup);\n\t\tnewdup = (xfs_dir2_data_unused_t *)((char *)hdr + offset);\n\t\tnewdup->freetag = cpu_to_be16(XFS_DIR2_DATA_FREE_TAG);\n\t\tnewdup->length = cpu_to_be16(len + be16_to_cpu(postdup->length));\n\t\t*xfs_dir2_data_unused_tag_p(newdup) =\n\t\t\tcpu_to_be16((char *)newdup - (char *)hdr);\n\t\txfs_dir2_data_log_unused(args, bp, newdup);\n\t\t/*\n\t\t * If the following entry was in the table, the new entry\n\t\t * is longer, so it will be in the table too.  Remove\n\t\t * the old one and add the new one.\n\t\t */\n\t\tif (dfp) {\n\t\t\txfs_dir2_data_freeremove(hdr, bf, dfp, needlogp);\n\t\t\txfs_dir2_data_freeinsert(hdr, bf, newdup, needlogp);\n\t\t}\n\t\t/*\n\t\t * Otherwise we need a scan if the new entry is big enough.\n\t\t */\n\t\telse {\n\t\t\tneedscan = be16_to_cpu(newdup->length) >\n\t\t\t\t   be16_to_cpu(bf[2].length);\n\t\t}\n\t}\n\t/*\n\t * Neither neighbor is free.  Make a new entry.\n\t */\n\telse {\n\t\tnewdup = (xfs_dir2_data_unused_t *)((char *)hdr + offset);\n\t\tnewdup->freetag = cpu_to_be16(XFS_DIR2_DATA_FREE_TAG);\n\t\tnewdup->length = cpu_to_be16(len);\n\t\t*xfs_dir2_data_unused_tag_p(newdup) =\n\t\t\tcpu_to_be16((char *)newdup - (char *)hdr);\n\t\txfs_dir2_data_log_unused(args, bp, newdup);\n\t\txfs_dir2_data_freeinsert(hdr, bf, newdup, needlogp);\n\t}\n\t*needscanp = needscan;\n}"
  },
  {
    "function_name": "xfs_dir2_data_log_unused",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_dir2_data.c",
    "lines": "682-708",
    "snippet": "void\nxfs_dir2_data_log_unused(\n\tstruct xfs_da_args\t*args,\n\tstruct xfs_buf\t\t*bp,\n\txfs_dir2_data_unused_t\t*dup)\t\t/* data unused pointer */\n{\n\txfs_dir2_data_hdr_t\t*hdr = bp->b_addr;\n\n\tASSERT(hdr->magic == cpu_to_be32(XFS_DIR2_DATA_MAGIC) ||\n\t       hdr->magic == cpu_to_be32(XFS_DIR3_DATA_MAGIC) ||\n\t       hdr->magic == cpu_to_be32(XFS_DIR2_BLOCK_MAGIC) ||\n\t       hdr->magic == cpu_to_be32(XFS_DIR3_BLOCK_MAGIC));\n\n\t/*\n\t * Log the first part of the unused entry.\n\t */\n\txfs_trans_log_buf(args->trans, bp, (uint)((char *)dup - (char *)hdr),\n\t\t(uint)((char *)&dup->length + sizeof(dup->length) -\n\t\t       1 - (char *)hdr));\n\t/*\n\t * Log the end (tag) of the unused entry.\n\t */\n\txfs_trans_log_buf(args->trans, bp,\n\t\t(uint)((char *)xfs_dir2_data_unused_tag_p(dup) - (char *)hdr),\n\t\t(uint)((char *)xfs_dir2_data_unused_tag_p(dup) - (char *)hdr +\n\t\t       sizeof(xfs_dir2_data_off_t) - 1));\n}",
    "includes": [
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_buf_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_dir2_priv.h\"",
      "#include \"xfs_dir2.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_da_btree.h\"",
      "#include \"xfs_da_format.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_trans_log_buf",
          "args": [
            "args->trans",
            "bp",
            "(uint)((char *)xfs_dir2_data_unused_tag_p(dup) - (char *)hdr)",
            "(uint)((char *)xfs_dir2_data_unused_tag_p(dup) - (char *)hdr +\n\t\t       sizeof(xfs_dir2_data_off_t) - 1)"
          ],
          "line": 704
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_trans_log_buf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans_buf.c",
          "lines": "497-552",
          "snippet": "void\nxfs_trans_log_buf(xfs_trans_t\t*tp,\n\t\t  xfs_buf_t\t*bp,\n\t\t  uint\t\tfirst,\n\t\t  uint\t\tlast)\n{\n\txfs_buf_log_item_t\t*bip = bp->b_fspriv;\n\n\tASSERT(bp->b_transp == tp);\n\tASSERT(bip != NULL);\n\tASSERT(first <= last && last < BBTOB(bp->b_length));\n\tASSERT(bp->b_iodone == NULL ||\n\t       bp->b_iodone == xfs_buf_iodone_callbacks);\n\n\t/*\n\t * Mark the buffer as needing to be written out eventually,\n\t * and set its iodone function to remove the buffer's buf log\n\t * item from the AIL and free it when the buffer is flushed\n\t * to disk.  See xfs_buf_attach_iodone() for more details\n\t * on li_cb and xfs_buf_iodone_callbacks().\n\t * If we end up aborting this transaction, we trap this buffer\n\t * inside the b_bdstrat callback so that this won't get written to\n\t * disk.\n\t */\n\tXFS_BUF_DONE(bp);\n\n\tASSERT(atomic_read(&bip->bli_refcount) > 0);\n\tbp->b_iodone = xfs_buf_iodone_callbacks;\n\tbip->bli_item.li_cb = xfs_buf_iodone;\n\n\ttrace_xfs_trans_log_buf(bip);\n\n\t/*\n\t * If we invalidated the buffer within this transaction, then\n\t * cancel the invalidation now that we're dirtying the buffer\n\t * again.  There are no races with the code in xfs_buf_item_unpin(),\n\t * because we have a reference to the buffer this entire time.\n\t */\n\tif (bip->bli_flags & XFS_BLI_STALE) {\n\t\tbip->bli_flags &= ~XFS_BLI_STALE;\n\t\tASSERT(XFS_BUF_ISSTALE(bp));\n\t\tXFS_BUF_UNSTALE(bp);\n\t\tbip->__bli_format.blf_flags &= ~XFS_BLF_CANCEL;\n\t}\n\n\ttp->t_flags |= XFS_TRANS_DIRTY;\n\tbip->bli_item.li_desc->lid_flags |= XFS_LID_DIRTY;\n\n\t/*\n\t * If we have an ordered buffer we are not logging any dirty range but\n\t * it still needs to be marked dirty and that it has been logged.\n\t */\n\tbip->bli_flags |= XFS_BLI_DIRTY | XFS_BLI_LOGGED;\n\tif (!(bip->bli_flags & XFS_BLI_ORDERED))\n\t\txfs_buf_item_log(bip, first, last);\n}",
          "includes": [
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_trans_log_buf(xfs_trans_t\t*tp,\n\t\t  xfs_buf_t\t*bp,\n\t\t  uint\t\tfirst,\n\t\t  uint\t\tlast)\n{\n\txfs_buf_log_item_t\t*bip = bp->b_fspriv;\n\n\tASSERT(bp->b_transp == tp);\n\tASSERT(bip != NULL);\n\tASSERT(first <= last && last < BBTOB(bp->b_length));\n\tASSERT(bp->b_iodone == NULL ||\n\t       bp->b_iodone == xfs_buf_iodone_callbacks);\n\n\t/*\n\t * Mark the buffer as needing to be written out eventually,\n\t * and set its iodone function to remove the buffer's buf log\n\t * item from the AIL and free it when the buffer is flushed\n\t * to disk.  See xfs_buf_attach_iodone() for more details\n\t * on li_cb and xfs_buf_iodone_callbacks().\n\t * If we end up aborting this transaction, we trap this buffer\n\t * inside the b_bdstrat callback so that this won't get written to\n\t * disk.\n\t */\n\tXFS_BUF_DONE(bp);\n\n\tASSERT(atomic_read(&bip->bli_refcount) > 0);\n\tbp->b_iodone = xfs_buf_iodone_callbacks;\n\tbip->bli_item.li_cb = xfs_buf_iodone;\n\n\ttrace_xfs_trans_log_buf(bip);\n\n\t/*\n\t * If we invalidated the buffer within this transaction, then\n\t * cancel the invalidation now that we're dirtying the buffer\n\t * again.  There are no races with the code in xfs_buf_item_unpin(),\n\t * because we have a reference to the buffer this entire time.\n\t */\n\tif (bip->bli_flags & XFS_BLI_STALE) {\n\t\tbip->bli_flags &= ~XFS_BLI_STALE;\n\t\tASSERT(XFS_BUF_ISSTALE(bp));\n\t\tXFS_BUF_UNSTALE(bp);\n\t\tbip->__bli_format.blf_flags &= ~XFS_BLF_CANCEL;\n\t}\n\n\ttp->t_flags |= XFS_TRANS_DIRTY;\n\tbip->bli_item.li_desc->lid_flags |= XFS_LID_DIRTY;\n\n\t/*\n\t * If we have an ordered buffer we are not logging any dirty range but\n\t * it still needs to be marked dirty and that it has been logged.\n\t */\n\tbip->bli_flags |= XFS_BLI_DIRTY | XFS_BLI_LOGGED;\n\tif (!(bip->bli_flags & XFS_BLI_ORDERED))\n\t\txfs_buf_item_log(bip, first, last);\n}"
        }
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "(char *)xfs_dir2_data_unused_tag_p(dup) - (char *)hdr +\n\t\t       sizeof(xfs_dir2_data_off_t) - 1"
          ],
          "line": 706
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_dir2_data_unused_tag_p",
          "args": [
            "dup"
          ],
          "line": 706
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_dir2_data_unused_tag_p",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_da_format.h",
          "lines": "407-412",
          "snippet": "static inline __be16 *\nxfs_dir2_data_unused_tag_p(struct xfs_dir2_data_unused *dup)\n{\n\treturn (__be16 *)((char *)dup +\n\t\t\tbe16_to_cpu(dup->length) - sizeof(__be16));\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline __be16 *\nxfs_dir2_data_unused_tag_p(struct xfs_dir2_data_unused *dup)\n{\n\treturn (__be16 *)((char *)dup +\n\t\t\tbe16_to_cpu(dup->length) - sizeof(__be16));\n}"
        }
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "(char *)xfs_dir2_data_unused_tag_p(dup) - (char *)hdr"
          ],
          "line": 705
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "(char *)&dup->length + sizeof(dup->length) -\n\t\t       1 - (char *)hdr"
          ],
          "line": 699
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "(char *)dup - (char *)hdr"
          ],
          "line": 698
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "hdr->magic == cpu_to_be32(XFS_DIR2_DATA_MAGIC) ||\n\t       hdr->magic == cpu_to_be32(XFS_DIR3_DATA_MAGIC) ||\n\t       hdr->magic == cpu_to_be32(XFS_DIR2_BLOCK_MAGIC) ||\n\t       hdr->magic == cpu_to_be32(XFS_DIR3_BLOCK_MAGIC)"
          ],
          "line": 690
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "XFS_DIR3_BLOCK_MAGIC"
          ],
          "line": 693
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "XFS_DIR2_BLOCK_MAGIC"
          ],
          "line": 692
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "XFS_DIR3_DATA_MAGIC"
          ],
          "line": 691
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "XFS_DIR2_DATA_MAGIC"
          ],
          "line": 690
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_cksum.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_error.h\"\n#include \"xfs_dir2_priv.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_dir2_data_log_unused(\n\tstruct xfs_da_args\t*args,\n\tstruct xfs_buf\t\t*bp,\n\txfs_dir2_data_unused_t\t*dup)\t\t/* data unused pointer */\n{\n\txfs_dir2_data_hdr_t\t*hdr = bp->b_addr;\n\n\tASSERT(hdr->magic == cpu_to_be32(XFS_DIR2_DATA_MAGIC) ||\n\t       hdr->magic == cpu_to_be32(XFS_DIR3_DATA_MAGIC) ||\n\t       hdr->magic == cpu_to_be32(XFS_DIR2_BLOCK_MAGIC) ||\n\t       hdr->magic == cpu_to_be32(XFS_DIR3_BLOCK_MAGIC));\n\n\t/*\n\t * Log the first part of the unused entry.\n\t */\n\txfs_trans_log_buf(args->trans, bp, (uint)((char *)dup - (char *)hdr),\n\t\t(uint)((char *)&dup->length + sizeof(dup->length) -\n\t\t       1 - (char *)hdr));\n\t/*\n\t * Log the end (tag) of the unused entry.\n\t */\n\txfs_trans_log_buf(args->trans, bp,\n\t\t(uint)((char *)xfs_dir2_data_unused_tag_p(dup) - (char *)hdr),\n\t\t(uint)((char *)xfs_dir2_data_unused_tag_p(dup) - (char *)hdr +\n\t\t       sizeof(xfs_dir2_data_off_t) - 1));\n}"
  },
  {
    "function_name": "xfs_dir2_data_log_header",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_dir2_data.c",
    "lines": "661-677",
    "snippet": "void\nxfs_dir2_data_log_header(\n\tstruct xfs_da_args\t*args,\n\tstruct xfs_buf\t\t*bp)\n{\n#ifdef DEBUG\n\tstruct xfs_dir2_data_hdr *hdr = bp->b_addr;\n\n\tASSERT(hdr->magic == cpu_to_be32(XFS_DIR2_DATA_MAGIC) ||\n\t       hdr->magic == cpu_to_be32(XFS_DIR3_DATA_MAGIC) ||\n\t       hdr->magic == cpu_to_be32(XFS_DIR2_BLOCK_MAGIC) ||\n\t       hdr->magic == cpu_to_be32(XFS_DIR3_BLOCK_MAGIC));\n#endif\n\n\txfs_trans_log_buf(args->trans, bp, 0,\n\t\t\t  args->dp->d_ops->data_entry_offset - 1);\n}",
    "includes": [
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_buf_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_dir2_priv.h\"",
      "#include \"xfs_dir2.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_da_btree.h\"",
      "#include \"xfs_da_format.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_trans_log_buf",
          "args": [
            "args->trans",
            "bp",
            "0",
            "args->dp->d_ops->data_entry_offset - 1"
          ],
          "line": 675
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_trans_log_buf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans_buf.c",
          "lines": "497-552",
          "snippet": "void\nxfs_trans_log_buf(xfs_trans_t\t*tp,\n\t\t  xfs_buf_t\t*bp,\n\t\t  uint\t\tfirst,\n\t\t  uint\t\tlast)\n{\n\txfs_buf_log_item_t\t*bip = bp->b_fspriv;\n\n\tASSERT(bp->b_transp == tp);\n\tASSERT(bip != NULL);\n\tASSERT(first <= last && last < BBTOB(bp->b_length));\n\tASSERT(bp->b_iodone == NULL ||\n\t       bp->b_iodone == xfs_buf_iodone_callbacks);\n\n\t/*\n\t * Mark the buffer as needing to be written out eventually,\n\t * and set its iodone function to remove the buffer's buf log\n\t * item from the AIL and free it when the buffer is flushed\n\t * to disk.  See xfs_buf_attach_iodone() for more details\n\t * on li_cb and xfs_buf_iodone_callbacks().\n\t * If we end up aborting this transaction, we trap this buffer\n\t * inside the b_bdstrat callback so that this won't get written to\n\t * disk.\n\t */\n\tXFS_BUF_DONE(bp);\n\n\tASSERT(atomic_read(&bip->bli_refcount) > 0);\n\tbp->b_iodone = xfs_buf_iodone_callbacks;\n\tbip->bli_item.li_cb = xfs_buf_iodone;\n\n\ttrace_xfs_trans_log_buf(bip);\n\n\t/*\n\t * If we invalidated the buffer within this transaction, then\n\t * cancel the invalidation now that we're dirtying the buffer\n\t * again.  There are no races with the code in xfs_buf_item_unpin(),\n\t * because we have a reference to the buffer this entire time.\n\t */\n\tif (bip->bli_flags & XFS_BLI_STALE) {\n\t\tbip->bli_flags &= ~XFS_BLI_STALE;\n\t\tASSERT(XFS_BUF_ISSTALE(bp));\n\t\tXFS_BUF_UNSTALE(bp);\n\t\tbip->__bli_format.blf_flags &= ~XFS_BLF_CANCEL;\n\t}\n\n\ttp->t_flags |= XFS_TRANS_DIRTY;\n\tbip->bli_item.li_desc->lid_flags |= XFS_LID_DIRTY;\n\n\t/*\n\t * If we have an ordered buffer we are not logging any dirty range but\n\t * it still needs to be marked dirty and that it has been logged.\n\t */\n\tbip->bli_flags |= XFS_BLI_DIRTY | XFS_BLI_LOGGED;\n\tif (!(bip->bli_flags & XFS_BLI_ORDERED))\n\t\txfs_buf_item_log(bip, first, last);\n}",
          "includes": [
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_trans_log_buf(xfs_trans_t\t*tp,\n\t\t  xfs_buf_t\t*bp,\n\t\t  uint\t\tfirst,\n\t\t  uint\t\tlast)\n{\n\txfs_buf_log_item_t\t*bip = bp->b_fspriv;\n\n\tASSERT(bp->b_transp == tp);\n\tASSERT(bip != NULL);\n\tASSERT(first <= last && last < BBTOB(bp->b_length));\n\tASSERT(bp->b_iodone == NULL ||\n\t       bp->b_iodone == xfs_buf_iodone_callbacks);\n\n\t/*\n\t * Mark the buffer as needing to be written out eventually,\n\t * and set its iodone function to remove the buffer's buf log\n\t * item from the AIL and free it when the buffer is flushed\n\t * to disk.  See xfs_buf_attach_iodone() for more details\n\t * on li_cb and xfs_buf_iodone_callbacks().\n\t * If we end up aborting this transaction, we trap this buffer\n\t * inside the b_bdstrat callback so that this won't get written to\n\t * disk.\n\t */\n\tXFS_BUF_DONE(bp);\n\n\tASSERT(atomic_read(&bip->bli_refcount) > 0);\n\tbp->b_iodone = xfs_buf_iodone_callbacks;\n\tbip->bli_item.li_cb = xfs_buf_iodone;\n\n\ttrace_xfs_trans_log_buf(bip);\n\n\t/*\n\t * If we invalidated the buffer within this transaction, then\n\t * cancel the invalidation now that we're dirtying the buffer\n\t * again.  There are no races with the code in xfs_buf_item_unpin(),\n\t * because we have a reference to the buffer this entire time.\n\t */\n\tif (bip->bli_flags & XFS_BLI_STALE) {\n\t\tbip->bli_flags &= ~XFS_BLI_STALE;\n\t\tASSERT(XFS_BUF_ISSTALE(bp));\n\t\tXFS_BUF_UNSTALE(bp);\n\t\tbip->__bli_format.blf_flags &= ~XFS_BLF_CANCEL;\n\t}\n\n\ttp->t_flags |= XFS_TRANS_DIRTY;\n\tbip->bli_item.li_desc->lid_flags |= XFS_LID_DIRTY;\n\n\t/*\n\t * If we have an ordered buffer we are not logging any dirty range but\n\t * it still needs to be marked dirty and that it has been logged.\n\t */\n\tbip->bli_flags |= XFS_BLI_DIRTY | XFS_BLI_LOGGED;\n\tif (!(bip->bli_flags & XFS_BLI_ORDERED))\n\t\txfs_buf_item_log(bip, first, last);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "hdr->magic == cpu_to_be32(XFS_DIR2_DATA_MAGIC) ||\n\t       hdr->magic == cpu_to_be32(XFS_DIR3_DATA_MAGIC) ||\n\t       hdr->magic == cpu_to_be32(XFS_DIR2_BLOCK_MAGIC) ||\n\t       hdr->magic == cpu_to_be32(XFS_DIR3_BLOCK_MAGIC)"
          ],
          "line": 669
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "XFS_DIR3_BLOCK_MAGIC"
          ],
          "line": 672
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "XFS_DIR2_BLOCK_MAGIC"
          ],
          "line": 671
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "XFS_DIR3_DATA_MAGIC"
          ],
          "line": 670
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "XFS_DIR2_DATA_MAGIC"
          ],
          "line": 669
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_cksum.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_error.h\"\n#include \"xfs_dir2_priv.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_dir2_data_log_header(\n\tstruct xfs_da_args\t*args,\n\tstruct xfs_buf\t\t*bp)\n{\n#ifdef DEBUG\n\tstruct xfs_dir2_data_hdr *hdr = bp->b_addr;\n\n\tASSERT(hdr->magic == cpu_to_be32(XFS_DIR2_DATA_MAGIC) ||\n\t       hdr->magic == cpu_to_be32(XFS_DIR3_DATA_MAGIC) ||\n\t       hdr->magic == cpu_to_be32(XFS_DIR2_BLOCK_MAGIC) ||\n\t       hdr->magic == cpu_to_be32(XFS_DIR3_BLOCK_MAGIC));\n#endif\n\n\txfs_trans_log_buf(args->trans, bp, 0,\n\t\t\t  args->dp->d_ops->data_entry_offset - 1);\n}"
  },
  {
    "function_name": "xfs_dir2_data_log_entry",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_dir2_data.c",
    "lines": "640-656",
    "snippet": "void\nxfs_dir2_data_log_entry(\n\tstruct xfs_da_args\t*args,\n\tstruct xfs_buf\t\t*bp,\n\txfs_dir2_data_entry_t\t*dep)\t\t/* data entry pointer */\n{\n\tstruct xfs_dir2_data_hdr *hdr = bp->b_addr;\n\n\tASSERT(hdr->magic == cpu_to_be32(XFS_DIR2_DATA_MAGIC) ||\n\t       hdr->magic == cpu_to_be32(XFS_DIR3_DATA_MAGIC) ||\n\t       hdr->magic == cpu_to_be32(XFS_DIR2_BLOCK_MAGIC) ||\n\t       hdr->magic == cpu_to_be32(XFS_DIR3_BLOCK_MAGIC));\n\n\txfs_trans_log_buf(args->trans, bp, (uint)((char *)dep - (char *)hdr),\n\t\t(uint)((char *)(args->dp->d_ops->data_entry_tag_p(dep) + 1) -\n\t\t       (char *)hdr - 1));\n}",
    "includes": [
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_buf_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_dir2_priv.h\"",
      "#include \"xfs_dir2.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_da_btree.h\"",
      "#include \"xfs_da_format.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_trans_log_buf",
          "args": [
            "args->trans",
            "bp",
            "(uint)((char *)dep - (char *)hdr)",
            "(uint)((char *)(args->dp->d_ops->data_entry_tag_p(dep) + 1) -\n\t\t       (char *)hdr - 1)"
          ],
          "line": 653
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_trans_log_buf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans_buf.c",
          "lines": "497-552",
          "snippet": "void\nxfs_trans_log_buf(xfs_trans_t\t*tp,\n\t\t  xfs_buf_t\t*bp,\n\t\t  uint\t\tfirst,\n\t\t  uint\t\tlast)\n{\n\txfs_buf_log_item_t\t*bip = bp->b_fspriv;\n\n\tASSERT(bp->b_transp == tp);\n\tASSERT(bip != NULL);\n\tASSERT(first <= last && last < BBTOB(bp->b_length));\n\tASSERT(bp->b_iodone == NULL ||\n\t       bp->b_iodone == xfs_buf_iodone_callbacks);\n\n\t/*\n\t * Mark the buffer as needing to be written out eventually,\n\t * and set its iodone function to remove the buffer's buf log\n\t * item from the AIL and free it when the buffer is flushed\n\t * to disk.  See xfs_buf_attach_iodone() for more details\n\t * on li_cb and xfs_buf_iodone_callbacks().\n\t * If we end up aborting this transaction, we trap this buffer\n\t * inside the b_bdstrat callback so that this won't get written to\n\t * disk.\n\t */\n\tXFS_BUF_DONE(bp);\n\n\tASSERT(atomic_read(&bip->bli_refcount) > 0);\n\tbp->b_iodone = xfs_buf_iodone_callbacks;\n\tbip->bli_item.li_cb = xfs_buf_iodone;\n\n\ttrace_xfs_trans_log_buf(bip);\n\n\t/*\n\t * If we invalidated the buffer within this transaction, then\n\t * cancel the invalidation now that we're dirtying the buffer\n\t * again.  There are no races with the code in xfs_buf_item_unpin(),\n\t * because we have a reference to the buffer this entire time.\n\t */\n\tif (bip->bli_flags & XFS_BLI_STALE) {\n\t\tbip->bli_flags &= ~XFS_BLI_STALE;\n\t\tASSERT(XFS_BUF_ISSTALE(bp));\n\t\tXFS_BUF_UNSTALE(bp);\n\t\tbip->__bli_format.blf_flags &= ~XFS_BLF_CANCEL;\n\t}\n\n\ttp->t_flags |= XFS_TRANS_DIRTY;\n\tbip->bli_item.li_desc->lid_flags |= XFS_LID_DIRTY;\n\n\t/*\n\t * If we have an ordered buffer we are not logging any dirty range but\n\t * it still needs to be marked dirty and that it has been logged.\n\t */\n\tbip->bli_flags |= XFS_BLI_DIRTY | XFS_BLI_LOGGED;\n\tif (!(bip->bli_flags & XFS_BLI_ORDERED))\n\t\txfs_buf_item_log(bip, first, last);\n}",
          "includes": [
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_trans_log_buf(xfs_trans_t\t*tp,\n\t\t  xfs_buf_t\t*bp,\n\t\t  uint\t\tfirst,\n\t\t  uint\t\tlast)\n{\n\txfs_buf_log_item_t\t*bip = bp->b_fspriv;\n\n\tASSERT(bp->b_transp == tp);\n\tASSERT(bip != NULL);\n\tASSERT(first <= last && last < BBTOB(bp->b_length));\n\tASSERT(bp->b_iodone == NULL ||\n\t       bp->b_iodone == xfs_buf_iodone_callbacks);\n\n\t/*\n\t * Mark the buffer as needing to be written out eventually,\n\t * and set its iodone function to remove the buffer's buf log\n\t * item from the AIL and free it when the buffer is flushed\n\t * to disk.  See xfs_buf_attach_iodone() for more details\n\t * on li_cb and xfs_buf_iodone_callbacks().\n\t * If we end up aborting this transaction, we trap this buffer\n\t * inside the b_bdstrat callback so that this won't get written to\n\t * disk.\n\t */\n\tXFS_BUF_DONE(bp);\n\n\tASSERT(atomic_read(&bip->bli_refcount) > 0);\n\tbp->b_iodone = xfs_buf_iodone_callbacks;\n\tbip->bli_item.li_cb = xfs_buf_iodone;\n\n\ttrace_xfs_trans_log_buf(bip);\n\n\t/*\n\t * If we invalidated the buffer within this transaction, then\n\t * cancel the invalidation now that we're dirtying the buffer\n\t * again.  There are no races with the code in xfs_buf_item_unpin(),\n\t * because we have a reference to the buffer this entire time.\n\t */\n\tif (bip->bli_flags & XFS_BLI_STALE) {\n\t\tbip->bli_flags &= ~XFS_BLI_STALE;\n\t\tASSERT(XFS_BUF_ISSTALE(bp));\n\t\tXFS_BUF_UNSTALE(bp);\n\t\tbip->__bli_format.blf_flags &= ~XFS_BLF_CANCEL;\n\t}\n\n\ttp->t_flags |= XFS_TRANS_DIRTY;\n\tbip->bli_item.li_desc->lid_flags |= XFS_LID_DIRTY;\n\n\t/*\n\t * If we have an ordered buffer we are not logging any dirty range but\n\t * it still needs to be marked dirty and that it has been logged.\n\t */\n\tbip->bli_flags |= XFS_BLI_DIRTY | XFS_BLI_LOGGED;\n\tif (!(bip->bli_flags & XFS_BLI_ORDERED))\n\t\txfs_buf_item_log(bip, first, last);\n}"
        }
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "(char *)(args->dp->d_ops->data_entry_tag_p(dep) + 1) -\n\t\t       (char *)hdr - 1"
          ],
          "line": 654
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "args->dp->d_ops->data_entry_tag_p",
          "args": [
            "dep"
          ],
          "line": 654
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "(char *)dep - (char *)hdr"
          ],
          "line": 653
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "hdr->magic == cpu_to_be32(XFS_DIR2_DATA_MAGIC) ||\n\t       hdr->magic == cpu_to_be32(XFS_DIR3_DATA_MAGIC) ||\n\t       hdr->magic == cpu_to_be32(XFS_DIR2_BLOCK_MAGIC) ||\n\t       hdr->magic == cpu_to_be32(XFS_DIR3_BLOCK_MAGIC)"
          ],
          "line": 648
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "XFS_DIR3_BLOCK_MAGIC"
          ],
          "line": 651
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "XFS_DIR2_BLOCK_MAGIC"
          ],
          "line": 650
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "XFS_DIR3_DATA_MAGIC"
          ],
          "line": 649
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "XFS_DIR2_DATA_MAGIC"
          ],
          "line": 648
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_cksum.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_error.h\"\n#include \"xfs_dir2_priv.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_dir2_data_log_entry(\n\tstruct xfs_da_args\t*args,\n\tstruct xfs_buf\t\t*bp,\n\txfs_dir2_data_entry_t\t*dep)\t\t/* data entry pointer */\n{\n\tstruct xfs_dir2_data_hdr *hdr = bp->b_addr;\n\n\tASSERT(hdr->magic == cpu_to_be32(XFS_DIR2_DATA_MAGIC) ||\n\t       hdr->magic == cpu_to_be32(XFS_DIR3_DATA_MAGIC) ||\n\t       hdr->magic == cpu_to_be32(XFS_DIR2_BLOCK_MAGIC) ||\n\t       hdr->magic == cpu_to_be32(XFS_DIR3_BLOCK_MAGIC));\n\n\txfs_trans_log_buf(args->trans, bp, (uint)((char *)dep - (char *)hdr),\n\t\t(uint)((char *)(args->dp->d_ops->data_entry_tag_p(dep) + 1) -\n\t\t       (char *)hdr - 1));\n}"
  },
  {
    "function_name": "xfs_dir3_data_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_dir2_data.c",
    "lines": "565-635",
    "snippet": "int\t\t\t\t\t\t/* error */\nxfs_dir3_data_init(\n\txfs_da_args_t\t\t*args,\t\t/* directory operation args */\n\txfs_dir2_db_t\t\tblkno,\t\t/* logical dir block number */\n\tstruct xfs_buf\t\t**bpp)\t\t/* output block buffer */\n{\n\tstruct xfs_buf\t\t*bp;\t\t/* block buffer */\n\txfs_dir2_data_hdr_t\t*hdr;\t\t/* data block header */\n\txfs_inode_t\t\t*dp;\t\t/* incore directory inode */\n\txfs_dir2_data_unused_t\t*dup;\t\t/* unused entry pointer */\n\tstruct xfs_dir2_data_free *bf;\n\tint\t\t\terror;\t\t/* error return value */\n\tint\t\t\ti;\t\t/* bestfree index */\n\txfs_mount_t\t\t*mp;\t\t/* filesystem mount point */\n\txfs_trans_t\t\t*tp;\t\t/* transaction pointer */\n\tint                     t;              /* temp */\n\n\tdp = args->dp;\n\tmp = dp->i_mount;\n\ttp = args->trans;\n\t/*\n\t * Get the buffer set up for the block.\n\t */\n\terror = xfs_da_get_buf(tp, dp, xfs_dir2_db_to_da(args->geo, blkno),\n\t\t\t       -1, &bp, XFS_DATA_FORK);\n\tif (error)\n\t\treturn error;\n\tbp->b_ops = &xfs_dir3_data_buf_ops;\n\txfs_trans_buf_set_type(tp, bp, XFS_BLFT_DIR_DATA_BUF);\n\n\t/*\n\t * Initialize the header.\n\t */\n\thdr = bp->b_addr;\n\tif (xfs_sb_version_hascrc(&mp->m_sb)) {\n\t\tstruct xfs_dir3_blk_hdr *hdr3 = bp->b_addr;\n\n\t\tmemset(hdr3, 0, sizeof(*hdr3));\n\t\thdr3->magic = cpu_to_be32(XFS_DIR3_DATA_MAGIC);\n\t\thdr3->blkno = cpu_to_be64(bp->b_bn);\n\t\thdr3->owner = cpu_to_be64(dp->i_ino);\n\t\tuuid_copy(&hdr3->uuid, &mp->m_sb.sb_uuid);\n\n\t} else\n\t\thdr->magic = cpu_to_be32(XFS_DIR2_DATA_MAGIC);\n\n\tbf = dp->d_ops->data_bestfree_p(hdr);\n\tbf[0].offset = cpu_to_be16(dp->d_ops->data_entry_offset);\n\tfor (i = 1; i < XFS_DIR2_DATA_FD_COUNT; i++) {\n\t\tbf[i].length = 0;\n\t\tbf[i].offset = 0;\n\t}\n\n\t/*\n\t * Set up an unused entry for the block's body.\n\t */\n\tdup = dp->d_ops->data_unused_p(hdr);\n\tdup->freetag = cpu_to_be16(XFS_DIR2_DATA_FREE_TAG);\n\n\tt = args->geo->blksize - (uint)dp->d_ops->data_entry_offset;\n\tbf[0].length = cpu_to_be16(t);\n\tdup->length = cpu_to_be16(t);\n\t*xfs_dir2_data_unused_tag_p(dup) = cpu_to_be16((char *)dup - (char *)hdr);\n\t/*\n\t * Log it and return it.\n\t */\n\txfs_dir2_data_log_header(args, bp);\n\txfs_dir2_data_log_unused(args, bp, dup);\n\t*bpp = bp;\n\treturn 0;\n}",
    "includes": [
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_buf_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_dir2_priv.h\"",
      "#include \"xfs_dir2.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_da_btree.h\"",
      "#include \"xfs_da_format.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "const struct xfs_buf_ops xfs_dir3_data_buf_ops = {\n\t.verify_read = xfs_dir3_data_read_verify,\n\t.verify_write = xfs_dir3_data_write_verify,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_dir2_data_log_unused",
          "args": [
            "args",
            "bp",
            "dup"
          ],
          "line": 632
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_dir2_data_log_unused",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_dir2_data.c",
          "lines": "682-708",
          "snippet": "void\nxfs_dir2_data_log_unused(\n\tstruct xfs_da_args\t*args,\n\tstruct xfs_buf\t\t*bp,\n\txfs_dir2_data_unused_t\t*dup)\t\t/* data unused pointer */\n{\n\txfs_dir2_data_hdr_t\t*hdr = bp->b_addr;\n\n\tASSERT(hdr->magic == cpu_to_be32(XFS_DIR2_DATA_MAGIC) ||\n\t       hdr->magic == cpu_to_be32(XFS_DIR3_DATA_MAGIC) ||\n\t       hdr->magic == cpu_to_be32(XFS_DIR2_BLOCK_MAGIC) ||\n\t       hdr->magic == cpu_to_be32(XFS_DIR3_BLOCK_MAGIC));\n\n\t/*\n\t * Log the first part of the unused entry.\n\t */\n\txfs_trans_log_buf(args->trans, bp, (uint)((char *)dup - (char *)hdr),\n\t\t(uint)((char *)&dup->length + sizeof(dup->length) -\n\t\t       1 - (char *)hdr));\n\t/*\n\t * Log the end (tag) of the unused entry.\n\t */\n\txfs_trans_log_buf(args->trans, bp,\n\t\t(uint)((char *)xfs_dir2_data_unused_tag_p(dup) - (char *)hdr),\n\t\t(uint)((char *)xfs_dir2_data_unused_tag_p(dup) - (char *)hdr +\n\t\t       sizeof(xfs_dir2_data_off_t) - 1));\n}",
          "includes": [
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_dir2_priv.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_cksum.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_error.h\"\n#include \"xfs_dir2_priv.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_dir2_data_log_unused(\n\tstruct xfs_da_args\t*args,\n\tstruct xfs_buf\t\t*bp,\n\txfs_dir2_data_unused_t\t*dup)\t\t/* data unused pointer */\n{\n\txfs_dir2_data_hdr_t\t*hdr = bp->b_addr;\n\n\tASSERT(hdr->magic == cpu_to_be32(XFS_DIR2_DATA_MAGIC) ||\n\t       hdr->magic == cpu_to_be32(XFS_DIR3_DATA_MAGIC) ||\n\t       hdr->magic == cpu_to_be32(XFS_DIR2_BLOCK_MAGIC) ||\n\t       hdr->magic == cpu_to_be32(XFS_DIR3_BLOCK_MAGIC));\n\n\t/*\n\t * Log the first part of the unused entry.\n\t */\n\txfs_trans_log_buf(args->trans, bp, (uint)((char *)dup - (char *)hdr),\n\t\t(uint)((char *)&dup->length + sizeof(dup->length) -\n\t\t       1 - (char *)hdr));\n\t/*\n\t * Log the end (tag) of the unused entry.\n\t */\n\txfs_trans_log_buf(args->trans, bp,\n\t\t(uint)((char *)xfs_dir2_data_unused_tag_p(dup) - (char *)hdr),\n\t\t(uint)((char *)xfs_dir2_data_unused_tag_p(dup) - (char *)hdr +\n\t\t       sizeof(xfs_dir2_data_off_t) - 1));\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_dir2_data_log_header",
          "args": [
            "args",
            "bp"
          ],
          "line": 631
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_dir2_data_log_header",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_dir2_data.c",
          "lines": "661-677",
          "snippet": "void\nxfs_dir2_data_log_header(\n\tstruct xfs_da_args\t*args,\n\tstruct xfs_buf\t\t*bp)\n{\n#ifdef DEBUG\n\tstruct xfs_dir2_data_hdr *hdr = bp->b_addr;\n\n\tASSERT(hdr->magic == cpu_to_be32(XFS_DIR2_DATA_MAGIC) ||\n\t       hdr->magic == cpu_to_be32(XFS_DIR3_DATA_MAGIC) ||\n\t       hdr->magic == cpu_to_be32(XFS_DIR2_BLOCK_MAGIC) ||\n\t       hdr->magic == cpu_to_be32(XFS_DIR3_BLOCK_MAGIC));\n#endif\n\n\txfs_trans_log_buf(args->trans, bp, 0,\n\t\t\t  args->dp->d_ops->data_entry_offset - 1);\n}",
          "includes": [
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_dir2_priv.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_cksum.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_error.h\"\n#include \"xfs_dir2_priv.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_dir2_data_log_header(\n\tstruct xfs_da_args\t*args,\n\tstruct xfs_buf\t\t*bp)\n{\n#ifdef DEBUG\n\tstruct xfs_dir2_data_hdr *hdr = bp->b_addr;\n\n\tASSERT(hdr->magic == cpu_to_be32(XFS_DIR2_DATA_MAGIC) ||\n\t       hdr->magic == cpu_to_be32(XFS_DIR3_DATA_MAGIC) ||\n\t       hdr->magic == cpu_to_be32(XFS_DIR2_BLOCK_MAGIC) ||\n\t       hdr->magic == cpu_to_be32(XFS_DIR3_BLOCK_MAGIC));\n#endif\n\n\txfs_trans_log_buf(args->trans, bp, 0,\n\t\t\t  args->dp->d_ops->data_entry_offset - 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_be16",
          "args": [
            "(char *)dup - (char *)hdr"
          ],
          "line": 627
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_dir2_data_unused_tag_p",
          "args": [
            "dup"
          ],
          "line": 627
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_dir2_data_unused_tag_p",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_da_format.h",
          "lines": "407-412",
          "snippet": "static inline __be16 *\nxfs_dir2_data_unused_tag_p(struct xfs_dir2_data_unused *dup)\n{\n\treturn (__be16 *)((char *)dup +\n\t\t\tbe16_to_cpu(dup->length) - sizeof(__be16));\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline __be16 *\nxfs_dir2_data_unused_tag_p(struct xfs_dir2_data_unused *dup)\n{\n\treturn (__be16 *)((char *)dup +\n\t\t\tbe16_to_cpu(dup->length) - sizeof(__be16));\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_be16",
          "args": [
            "t"
          ],
          "line": 626
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be16",
          "args": [
            "t"
          ],
          "line": 625
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be16",
          "args": [
            "XFS_DIR2_DATA_FREE_TAG"
          ],
          "line": 622
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dp->d_ops->data_unused_p",
          "args": [
            "hdr"
          ],
          "line": 621
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be16",
          "args": [
            "dp->d_ops->data_entry_offset"
          ],
          "line": 612
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dp->d_ops->data_bestfree_p",
          "args": [
            "hdr"
          ],
          "line": 611
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "XFS_DIR2_DATA_MAGIC"
          ],
          "line": 609
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "uuid_copy",
          "args": [
            "&hdr3->uuid",
            "&mp->m_sb.sb_uuid"
          ],
          "line": 606
        },
        "resolved": true,
        "details": {
          "function_name": "uuid_copy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/uuid.h",
          "lines": "29-33",
          "snippet": "static inline void\nuuid_copy(uuid_t *dst, uuid_t *src)\n{\n\tmemcpy(dst, src, sizeof(uuid_t));\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline void\nuuid_copy(uuid_t *dst, uuid_t *src)\n{\n\tmemcpy(dst, src, sizeof(uuid_t));\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_be64",
          "args": [
            "dp->i_ino"
          ],
          "line": 605
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be64",
          "args": [
            "bp->b_bn"
          ],
          "line": 604
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "XFS_DIR3_DATA_MAGIC"
          ],
          "line": 603
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "hdr3",
            "0",
            "sizeof(*hdr3)"
          ],
          "line": 602
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_sb_version_hascrc",
          "args": [
            "&mp->m_sb"
          ],
          "line": 599
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_sb_version_hascrc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_format.h",
          "lines": "547-550",
          "snippet": "static inline int xfs_sb_version_hascrc(struct xfs_sb *sbp)\n{\n\treturn XFS_SB_VERSION_NUM(sbp) == XFS_SB_VERSION_5;\n}",
          "includes": [],
          "macros_used": [
            "#define\tXFS_SB_VERSION_5\t5\t\t/* CRC enabled filesystem */"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#define\tXFS_SB_VERSION_5\t5\t\t/* CRC enabled filesystem */\n\nstatic inline int xfs_sb_version_hascrc(struct xfs_sb *sbp)\n{\n\treturn XFS_SB_VERSION_NUM(sbp) == XFS_SB_VERSION_5;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_trans_buf_set_type",
          "args": [
            "tp",
            "bp",
            "XFS_BLFT_DIR_DATA_BUF"
          ],
          "line": 593
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_trans_buf_set_type",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans_buf.c",
          "lines": "730-746",
          "snippet": "void\nxfs_trans_buf_set_type(\n\tstruct xfs_trans\t*tp,\n\tstruct xfs_buf\t\t*bp,\n\tenum xfs_blft\t\ttype)\n{\n\tstruct xfs_buf_log_item\t*bip = bp->b_fspriv;\n\n\tif (!tp)\n\t\treturn;\n\n\tASSERT(bp->b_transp == tp);\n\tASSERT(bip != NULL);\n\tASSERT(atomic_read(&bip->bli_refcount) > 0);\n\n\txfs_blft_to_flags(&bip->__bli_format, type);\n}",
          "includes": [
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\n\nvoid\nxfs_trans_buf_set_type(\n\tstruct xfs_trans\t*tp,\n\tstruct xfs_buf\t\t*bp,\n\tenum xfs_blft\t\ttype)\n{\n\tstruct xfs_buf_log_item\t*bip = bp->b_fspriv;\n\n\tif (!tp)\n\t\treturn;\n\n\tASSERT(bp->b_transp == tp);\n\tASSERT(bip != NULL);\n\tASSERT(atomic_read(&bip->bli_refcount) > 0);\n\n\txfs_blft_to_flags(&bip->__bli_format, type);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_da_get_buf",
          "args": [
            "tp",
            "dp",
            "xfs_dir2_db_to_da(args->geo, blkno)",
            "-1",
            "&bp",
            "XFS_DATA_FORK"
          ],
          "line": 588
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_da_get_buf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_da_btree.c",
          "lines": "2529-2572",
          "snippet": "int\nxfs_da_get_buf(\n\tstruct xfs_trans\t*trans,\n\tstruct xfs_inode\t*dp,\n\txfs_dablk_t\t\tbno,\n\txfs_daddr_t\t\tmappedbno,\n\tstruct xfs_buf\t\t**bpp,\n\tint\t\t\twhichfork)\n{\n\tstruct xfs_buf\t\t*bp;\n\tstruct xfs_buf_map\tmap;\n\tstruct xfs_buf_map\t*mapp;\n\tint\t\t\tnmap;\n\tint\t\t\terror;\n\n\t*bpp = NULL;\n\tmapp = &map;\n\tnmap = 1;\n\terror = xfs_dabuf_map(dp, bno, mappedbno, whichfork,\n\t\t\t\t&mapp, &nmap);\n\tif (error) {\n\t\t/* mapping a hole is not an error, but we don't continue */\n\t\tif (error == -1)\n\t\t\terror = 0;\n\t\tgoto out_free;\n\t}\n\n\tbp = xfs_trans_get_buf_map(trans, dp->i_mount->m_ddev_targp,\n\t\t\t\t    mapp, nmap, 0);\n\terror = bp ? bp->b_error : -EIO;\n\tif (error) {\n\t\tif (bp)\n\t\t\txfs_trans_brelse(trans, bp);\n\t\tgoto out_free;\n\t}\n\n\t*bpp = bp;\n\nout_free:\n\tif (mapp != &map)\n\t\tkmem_free(mapp);\n\n\treturn error;\n}",
          "includes": [
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_attr_leaf.h\"",
            "#include \"xfs_attr.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_dir2_priv.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_buf_item.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_attr_leaf.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_dir2_priv.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\nxfs_da_get_buf(\n\tstruct xfs_trans\t*trans,\n\tstruct xfs_inode\t*dp,\n\txfs_dablk_t\t\tbno,\n\txfs_daddr_t\t\tmappedbno,\n\tstruct xfs_buf\t\t**bpp,\n\tint\t\t\twhichfork)\n{\n\tstruct xfs_buf\t\t*bp;\n\tstruct xfs_buf_map\tmap;\n\tstruct xfs_buf_map\t*mapp;\n\tint\t\t\tnmap;\n\tint\t\t\terror;\n\n\t*bpp = NULL;\n\tmapp = &map;\n\tnmap = 1;\n\terror = xfs_dabuf_map(dp, bno, mappedbno, whichfork,\n\t\t\t\t&mapp, &nmap);\n\tif (error) {\n\t\t/* mapping a hole is not an error, but we don't continue */\n\t\tif (error == -1)\n\t\t\terror = 0;\n\t\tgoto out_free;\n\t}\n\n\tbp = xfs_trans_get_buf_map(trans, dp->i_mount->m_ddev_targp,\n\t\t\t\t    mapp, nmap, 0);\n\terror = bp ? bp->b_error : -EIO;\n\tif (error) {\n\t\tif (bp)\n\t\t\txfs_trans_brelse(trans, bp);\n\t\tgoto out_free;\n\t}\n\n\t*bpp = bp;\n\nout_free:\n\tif (mapp != &map)\n\t\tkmem_free(mapp);\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_dir2_db_to_da",
          "args": [
            "args->geo",
            "blkno"
          ],
          "line": 588
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_dir2_db_to_da",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_dir2.h",
          "lines": "259-263",
          "snippet": "static inline xfs_dablk_t\nxfs_dir2_db_to_da(struct xfs_da_geometry *geo, xfs_dir2_db_t db)\n{\n\treturn (xfs_dablk_t)(db << (geo->blklog - geo->fsblog));\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline xfs_dablk_t\nxfs_dir2_db_to_da(struct xfs_da_geometry *geo, xfs_dir2_db_t db)\n{\n\treturn (xfs_dablk_t)(db << (geo->blklog - geo->fsblog));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xfs_cksum.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_error.h\"\n#include \"xfs_dir2_priv.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nconst struct xfs_buf_ops xfs_dir3_data_buf_ops = {\n\t.verify_read = xfs_dir3_data_read_verify,\n\t.verify_write = xfs_dir3_data_write_verify,\n};\n\nint\t\t\t\t\t\t/* error */\nxfs_dir3_data_init(\n\txfs_da_args_t\t\t*args,\t\t/* directory operation args */\n\txfs_dir2_db_t\t\tblkno,\t\t/* logical dir block number */\n\tstruct xfs_buf\t\t**bpp)\t\t/* output block buffer */\n{\n\tstruct xfs_buf\t\t*bp;\t\t/* block buffer */\n\txfs_dir2_data_hdr_t\t*hdr;\t\t/* data block header */\n\txfs_inode_t\t\t*dp;\t\t/* incore directory inode */\n\txfs_dir2_data_unused_t\t*dup;\t\t/* unused entry pointer */\n\tstruct xfs_dir2_data_free *bf;\n\tint\t\t\terror;\t\t/* error return value */\n\tint\t\t\ti;\t\t/* bestfree index */\n\txfs_mount_t\t\t*mp;\t\t/* filesystem mount point */\n\txfs_trans_t\t\t*tp;\t\t/* transaction pointer */\n\tint                     t;              /* temp */\n\n\tdp = args->dp;\n\tmp = dp->i_mount;\n\ttp = args->trans;\n\t/*\n\t * Get the buffer set up for the block.\n\t */\n\terror = xfs_da_get_buf(tp, dp, xfs_dir2_db_to_da(args->geo, blkno),\n\t\t\t       -1, &bp, XFS_DATA_FORK);\n\tif (error)\n\t\treturn error;\n\tbp->b_ops = &xfs_dir3_data_buf_ops;\n\txfs_trans_buf_set_type(tp, bp, XFS_BLFT_DIR_DATA_BUF);\n\n\t/*\n\t * Initialize the header.\n\t */\n\thdr = bp->b_addr;\n\tif (xfs_sb_version_hascrc(&mp->m_sb)) {\n\t\tstruct xfs_dir3_blk_hdr *hdr3 = bp->b_addr;\n\n\t\tmemset(hdr3, 0, sizeof(*hdr3));\n\t\thdr3->magic = cpu_to_be32(XFS_DIR3_DATA_MAGIC);\n\t\thdr3->blkno = cpu_to_be64(bp->b_bn);\n\t\thdr3->owner = cpu_to_be64(dp->i_ino);\n\t\tuuid_copy(&hdr3->uuid, &mp->m_sb.sb_uuid);\n\n\t} else\n\t\thdr->magic = cpu_to_be32(XFS_DIR2_DATA_MAGIC);\n\n\tbf = dp->d_ops->data_bestfree_p(hdr);\n\tbf[0].offset = cpu_to_be16(dp->d_ops->data_entry_offset);\n\tfor (i = 1; i < XFS_DIR2_DATA_FD_COUNT; i++) {\n\t\tbf[i].length = 0;\n\t\tbf[i].offset = 0;\n\t}\n\n\t/*\n\t * Set up an unused entry for the block's body.\n\t */\n\tdup = dp->d_ops->data_unused_p(hdr);\n\tdup->freetag = cpu_to_be16(XFS_DIR2_DATA_FREE_TAG);\n\n\tt = args->geo->blksize - (uint)dp->d_ops->data_entry_offset;\n\tbf[0].length = cpu_to_be16(t);\n\tdup->length = cpu_to_be16(t);\n\t*xfs_dir2_data_unused_tag_p(dup) = cpu_to_be16((char *)dup - (char *)hdr);\n\t/*\n\t * Log it and return it.\n\t */\n\txfs_dir2_data_log_header(args, bp);\n\txfs_dir2_data_log_unused(args, bp, dup);\n\t*bpp = bp;\n\treturn 0;\n}"
  },
  {
    "function_name": "xfs_dir2_data_freescan",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_dir2_data.c",
    "lines": "500-559",
    "snippet": "void\nxfs_dir2_data_freescan(\n\tstruct xfs_inode\t*dp,\n\tstruct xfs_dir2_data_hdr *hdr,\n\tint\t\t\t*loghead)\n{\n\txfs_dir2_block_tail_t\t*btp;\t\t/* block tail */\n\txfs_dir2_data_entry_t\t*dep;\t\t/* active data entry */\n\txfs_dir2_data_unused_t\t*dup;\t\t/* unused data entry */\n\tstruct xfs_dir2_data_free *bf;\n\tchar\t\t\t*endp;\t\t/* end of block's data */\n\tchar\t\t\t*p;\t\t/* current entry pointer */\n\tstruct xfs_da_geometry\t*geo = dp->i_mount->m_dir_geo;\n\n\tASSERT(hdr->magic == cpu_to_be32(XFS_DIR2_DATA_MAGIC) ||\n\t       hdr->magic == cpu_to_be32(XFS_DIR3_DATA_MAGIC) ||\n\t       hdr->magic == cpu_to_be32(XFS_DIR2_BLOCK_MAGIC) ||\n\t       hdr->magic == cpu_to_be32(XFS_DIR3_BLOCK_MAGIC));\n\n\t/*\n\t * Start by clearing the table.\n\t */\n\tbf = dp->d_ops->data_bestfree_p(hdr);\n\tmemset(bf, 0, sizeof(*bf) * XFS_DIR2_DATA_FD_COUNT);\n\t*loghead = 1;\n\t/*\n\t * Set up pointers.\n\t */\n\tp = (char *)dp->d_ops->data_entry_p(hdr);\n\tif (hdr->magic == cpu_to_be32(XFS_DIR2_BLOCK_MAGIC) ||\n\t    hdr->magic == cpu_to_be32(XFS_DIR3_BLOCK_MAGIC)) {\n\t\tbtp = xfs_dir2_block_tail_p(geo, hdr);\n\t\tendp = (char *)xfs_dir2_block_leaf_p(btp);\n\t} else\n\t\tendp = (char *)hdr + geo->blksize;\n\t/*\n\t * Loop over the block's entries.\n\t */\n\twhile (p < endp) {\n\t\tdup = (xfs_dir2_data_unused_t *)p;\n\t\t/*\n\t\t * If it's a free entry, insert it.\n\t\t */\n\t\tif (be16_to_cpu(dup->freetag) == XFS_DIR2_DATA_FREE_TAG) {\n\t\t\tASSERT((char *)dup - (char *)hdr ==\n\t\t\t       be16_to_cpu(*xfs_dir2_data_unused_tag_p(dup)));\n\t\t\txfs_dir2_data_freeinsert(hdr, bf, dup, loghead);\n\t\t\tp += be16_to_cpu(dup->length);\n\t\t}\n\t\t/*\n\t\t * For active entries, check their tags and skip them.\n\t\t */\n\t\telse {\n\t\t\tdep = (xfs_dir2_data_entry_t *)p;\n\t\t\tASSERT((char *)dep - (char *)hdr ==\n\t\t\t       be16_to_cpu(*dp->d_ops->data_entry_tag_p(dep)));\n\t\t\tp += dp->d_ops->data_entsize(dep->namelen);\n\t\t}\n\t}\n}",
    "includes": [
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_buf_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_dir2_priv.h\"",
      "#include \"xfs_dir2.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_da_btree.h\"",
      "#include \"xfs_da_format.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "dp->d_ops->data_entsize",
          "args": [
            "dep->namelen"
          ],
          "line": 556
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "(char *)dep - (char *)hdr ==\n\t\t\t       be16_to_cpu(*dp->d_ops->data_entry_tag_p(dep))"
          ],
          "line": 554
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be16_to_cpu",
          "args": [
            "*dp->d_ops->data_entry_tag_p(dep)"
          ],
          "line": 555
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dp->d_ops->data_entry_tag_p",
          "args": [
            "dep"
          ],
          "line": 555
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be16_to_cpu",
          "args": [
            "dup->length"
          ],
          "line": 547
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_dir2_data_freeinsert",
          "args": [
            "hdr",
            "bf",
            "dup",
            "loghead"
          ],
          "line": 546
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_dir2_data_freeinsert",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_dir2_data.c",
          "lines": "415-454",
          "snippet": "xfs_dir2_data_free_t *\t\t\t\t/* entry inserted */\nxfs_dir2_data_freeinsert(\n\tstruct xfs_dir2_data_hdr *hdr,\t\t/* data block pointer */\n\tstruct xfs_dir2_data_free *dfp,\t\t/* bestfree table pointer */\n\tstruct xfs_dir2_data_unused *dup,\t/* unused space */\n\tint\t\t\t*loghead)\t/* log the data header (out) */\n{\n\txfs_dir2_data_free_t\tnew;\t\t/* new bestfree entry */\n\n\tASSERT(hdr->magic == cpu_to_be32(XFS_DIR2_DATA_MAGIC) ||\n\t       hdr->magic == cpu_to_be32(XFS_DIR2_BLOCK_MAGIC) ||\n\t       hdr->magic == cpu_to_be32(XFS_DIR3_DATA_MAGIC) ||\n\t       hdr->magic == cpu_to_be32(XFS_DIR3_BLOCK_MAGIC));\n\n\tnew.length = dup->length;\n\tnew.offset = cpu_to_be16((char *)dup - (char *)hdr);\n\n\t/*\n\t * Insert at position 0, 1, or 2; or not at all.\n\t */\n\tif (be16_to_cpu(new.length) > be16_to_cpu(dfp[0].length)) {\n\t\tdfp[2] = dfp[1];\n\t\tdfp[1] = dfp[0];\n\t\tdfp[0] = new;\n\t\t*loghead = 1;\n\t\treturn &dfp[0];\n\t}\n\tif (be16_to_cpu(new.length) > be16_to_cpu(dfp[1].length)) {\n\t\tdfp[2] = dfp[1];\n\t\tdfp[1] = new;\n\t\t*loghead = 1;\n\t\treturn &dfp[1];\n\t}\n\tif (be16_to_cpu(new.length) > be16_to_cpu(dfp[2].length)) {\n\t\tdfp[2] = new;\n\t\t*loghead = 1;\n\t\treturn &dfp[2];\n\t}\n\treturn NULL;\n}",
          "includes": [
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_dir2_priv.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_cksum.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_error.h\"\n#include \"xfs_dir2_priv.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nxfs_dir2_data_free_t *\t\t\t\t/* entry inserted */\nxfs_dir2_data_freeinsert(\n\tstruct xfs_dir2_data_hdr *hdr,\t\t/* data block pointer */\n\tstruct xfs_dir2_data_free *dfp,\t\t/* bestfree table pointer */\n\tstruct xfs_dir2_data_unused *dup,\t/* unused space */\n\tint\t\t\t*loghead)\t/* log the data header (out) */\n{\n\txfs_dir2_data_free_t\tnew;\t\t/* new bestfree entry */\n\n\tASSERT(hdr->magic == cpu_to_be32(XFS_DIR2_DATA_MAGIC) ||\n\t       hdr->magic == cpu_to_be32(XFS_DIR2_BLOCK_MAGIC) ||\n\t       hdr->magic == cpu_to_be32(XFS_DIR3_DATA_MAGIC) ||\n\t       hdr->magic == cpu_to_be32(XFS_DIR3_BLOCK_MAGIC));\n\n\tnew.length = dup->length;\n\tnew.offset = cpu_to_be16((char *)dup - (char *)hdr);\n\n\t/*\n\t * Insert at position 0, 1, or 2; or not at all.\n\t */\n\tif (be16_to_cpu(new.length) > be16_to_cpu(dfp[0].length)) {\n\t\tdfp[2] = dfp[1];\n\t\tdfp[1] = dfp[0];\n\t\tdfp[0] = new;\n\t\t*loghead = 1;\n\t\treturn &dfp[0];\n\t}\n\tif (be16_to_cpu(new.length) > be16_to_cpu(dfp[1].length)) {\n\t\tdfp[2] = dfp[1];\n\t\tdfp[1] = new;\n\t\t*loghead = 1;\n\t\treturn &dfp[1];\n\t}\n\tif (be16_to_cpu(new.length) > be16_to_cpu(dfp[2].length)) {\n\t\tdfp[2] = new;\n\t\t*loghead = 1;\n\t\treturn &dfp[2];\n\t}\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "(char *)dup - (char *)hdr ==\n\t\t\t       be16_to_cpu(*xfs_dir2_data_unused_tag_p(dup))"
          ],
          "line": 544
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be16_to_cpu",
          "args": [
            "*xfs_dir2_data_unused_tag_p(dup)"
          ],
          "line": 545
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_dir2_data_unused_tag_p",
          "args": [
            "dup"
          ],
          "line": 545
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_dir2_data_unused_tag_p",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_da_format.h",
          "lines": "407-412",
          "snippet": "static inline __be16 *\nxfs_dir2_data_unused_tag_p(struct xfs_dir2_data_unused *dup)\n{\n\treturn (__be16 *)((char *)dup +\n\t\t\tbe16_to_cpu(dup->length) - sizeof(__be16));\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline __be16 *\nxfs_dir2_data_unused_tag_p(struct xfs_dir2_data_unused *dup)\n{\n\treturn (__be16 *)((char *)dup +\n\t\t\tbe16_to_cpu(dup->length) - sizeof(__be16));\n}"
        }
      },
      {
        "call_info": {
          "callee": "be16_to_cpu",
          "args": [
            "dup->freetag"
          ],
          "line": 543
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_dir2_block_leaf_p",
          "args": [
            "btp"
          ],
          "line": 532
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_dir2_block_leaf_p",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_da_format.h",
          "lines": "601-605",
          "snippet": "static inline struct xfs_dir2_leaf_entry *\nxfs_dir2_block_leaf_p(struct xfs_dir2_block_tail *btp)\n{\n\treturn ((struct xfs_dir2_leaf_entry *)btp) - be32_to_cpu(btp->count);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline struct xfs_dir2_leaf_entry *\nxfs_dir2_block_leaf_p(struct xfs_dir2_block_tail *btp)\n{\n\treturn ((struct xfs_dir2_leaf_entry *)btp) - be32_to_cpu(btp->count);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_dir2_block_tail_p",
          "args": [
            "geo",
            "hdr"
          ],
          "line": 531
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_dir2_block_tail_p",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_dir2.h",
          "lines": "305-310",
          "snippet": "static inline struct xfs_dir2_block_tail *\nxfs_dir2_block_tail_p(struct xfs_da_geometry *geo, struct xfs_dir2_data_hdr *hdr)\n{\n\treturn ((struct xfs_dir2_block_tail *)\n\t\t((char *)hdr + geo->blksize)) - 1;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline struct xfs_dir2_block_tail *\nxfs_dir2_block_tail_p(struct xfs_da_geometry *geo, struct xfs_dir2_data_hdr *hdr)\n{\n\treturn ((struct xfs_dir2_block_tail *)\n\t\t((char *)hdr + geo->blksize)) - 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "XFS_DIR3_BLOCK_MAGIC"
          ],
          "line": 530
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "XFS_DIR2_BLOCK_MAGIC"
          ],
          "line": 529
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dp->d_ops->data_entry_p",
          "args": [
            "hdr"
          ],
          "line": 528
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "bf",
            "0",
            "sizeof(*bf) * XFS_DIR2_DATA_FD_COUNT"
          ],
          "line": 523
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dp->d_ops->data_bestfree_p",
          "args": [
            "hdr"
          ],
          "line": 522
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "hdr->magic == cpu_to_be32(XFS_DIR2_DATA_MAGIC) ||\n\t       hdr->magic == cpu_to_be32(XFS_DIR3_DATA_MAGIC) ||\n\t       hdr->magic == cpu_to_be32(XFS_DIR2_BLOCK_MAGIC) ||\n\t       hdr->magic == cpu_to_be32(XFS_DIR3_BLOCK_MAGIC)"
          ],
          "line": 514
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "XFS_DIR3_BLOCK_MAGIC"
          ],
          "line": 517
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "XFS_DIR2_BLOCK_MAGIC"
          ],
          "line": 516
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "XFS_DIR3_DATA_MAGIC"
          ],
          "line": 515
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "XFS_DIR2_DATA_MAGIC"
          ],
          "line": 514
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_cksum.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_error.h\"\n#include \"xfs_dir2_priv.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_dir2_data_freescan(\n\tstruct xfs_inode\t*dp,\n\tstruct xfs_dir2_data_hdr *hdr,\n\tint\t\t\t*loghead)\n{\n\txfs_dir2_block_tail_t\t*btp;\t\t/* block tail */\n\txfs_dir2_data_entry_t\t*dep;\t\t/* active data entry */\n\txfs_dir2_data_unused_t\t*dup;\t\t/* unused data entry */\n\tstruct xfs_dir2_data_free *bf;\n\tchar\t\t\t*endp;\t\t/* end of block's data */\n\tchar\t\t\t*p;\t\t/* current entry pointer */\n\tstruct xfs_da_geometry\t*geo = dp->i_mount->m_dir_geo;\n\n\tASSERT(hdr->magic == cpu_to_be32(XFS_DIR2_DATA_MAGIC) ||\n\t       hdr->magic == cpu_to_be32(XFS_DIR3_DATA_MAGIC) ||\n\t       hdr->magic == cpu_to_be32(XFS_DIR2_BLOCK_MAGIC) ||\n\t       hdr->magic == cpu_to_be32(XFS_DIR3_BLOCK_MAGIC));\n\n\t/*\n\t * Start by clearing the table.\n\t */\n\tbf = dp->d_ops->data_bestfree_p(hdr);\n\tmemset(bf, 0, sizeof(*bf) * XFS_DIR2_DATA_FD_COUNT);\n\t*loghead = 1;\n\t/*\n\t * Set up pointers.\n\t */\n\tp = (char *)dp->d_ops->data_entry_p(hdr);\n\tif (hdr->magic == cpu_to_be32(XFS_DIR2_BLOCK_MAGIC) ||\n\t    hdr->magic == cpu_to_be32(XFS_DIR3_BLOCK_MAGIC)) {\n\t\tbtp = xfs_dir2_block_tail_p(geo, hdr);\n\t\tendp = (char *)xfs_dir2_block_leaf_p(btp);\n\t} else\n\t\tendp = (char *)hdr + geo->blksize;\n\t/*\n\t * Loop over the block's entries.\n\t */\n\twhile (p < endp) {\n\t\tdup = (xfs_dir2_data_unused_t *)p;\n\t\t/*\n\t\t * If it's a free entry, insert it.\n\t\t */\n\t\tif (be16_to_cpu(dup->freetag) == XFS_DIR2_DATA_FREE_TAG) {\n\t\t\tASSERT((char *)dup - (char *)hdr ==\n\t\t\t       be16_to_cpu(*xfs_dir2_data_unused_tag_p(dup)));\n\t\t\txfs_dir2_data_freeinsert(hdr, bf, dup, loghead);\n\t\t\tp += be16_to_cpu(dup->length);\n\t\t}\n\t\t/*\n\t\t * For active entries, check their tags and skip them.\n\t\t */\n\t\telse {\n\t\t\tdep = (xfs_dir2_data_entry_t *)p;\n\t\t\tASSERT((char *)dep - (char *)hdr ==\n\t\t\t       be16_to_cpu(*dp->d_ops->data_entry_tag_p(dep)));\n\t\t\tp += dp->d_ops->data_entsize(dep->namelen);\n\t\t}\n\t}\n}"
  },
  {
    "function_name": "xfs_dir2_data_freeremove",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_dir2_data.c",
    "lines": "459-495",
    "snippet": "STATIC void\nxfs_dir2_data_freeremove(\n\tstruct xfs_dir2_data_hdr *hdr,\t\t/* data block header */\n\tstruct xfs_dir2_data_free *bf,\t\t/* bestfree table pointer */\n\tstruct xfs_dir2_data_free *dfp,\t\t/* bestfree entry pointer */\n\tint\t\t\t*loghead)\t/* out: log data header */\n{\n\n\tASSERT(hdr->magic == cpu_to_be32(XFS_DIR2_DATA_MAGIC) ||\n\t       hdr->magic == cpu_to_be32(XFS_DIR2_BLOCK_MAGIC) ||\n\t       hdr->magic == cpu_to_be32(XFS_DIR3_DATA_MAGIC) ||\n\t       hdr->magic == cpu_to_be32(XFS_DIR3_BLOCK_MAGIC));\n\n\t/*\n\t * It's the first entry, slide the next 2 up.\n\t */\n\tif (dfp == &bf[0]) {\n\t\tbf[0] = bf[1];\n\t\tbf[1] = bf[2];\n\t}\n\t/*\n\t * It's the second entry, slide the 3rd entry up.\n\t */\n\telse if (dfp == &bf[1])\n\t\tbf[1] = bf[2];\n\t/*\n\t * Must be the last entry.\n\t */\n\telse\n\t\tASSERT(dfp == &bf[2]);\n\t/*\n\t * Clear the 3rd entry, must be zero now.\n\t */\n\tbf[2].length = 0;\n\tbf[2].offset = 0;\n\t*loghead = 1;\n}",
    "includes": [
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_buf_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_dir2_priv.h\"",
      "#include \"xfs_dir2.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_da_btree.h\"",
      "#include \"xfs_da_format.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "dfp == &bf[2]"
          ],
          "line": 488
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "hdr->magic == cpu_to_be32(XFS_DIR2_DATA_MAGIC) ||\n\t       hdr->magic == cpu_to_be32(XFS_DIR2_BLOCK_MAGIC) ||\n\t       hdr->magic == cpu_to_be32(XFS_DIR3_DATA_MAGIC) ||\n\t       hdr->magic == cpu_to_be32(XFS_DIR3_BLOCK_MAGIC)"
          ],
          "line": 467
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "XFS_DIR3_BLOCK_MAGIC"
          ],
          "line": 470
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "XFS_DIR3_DATA_MAGIC"
          ],
          "line": 469
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "XFS_DIR2_BLOCK_MAGIC"
          ],
          "line": 468
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "XFS_DIR2_DATA_MAGIC"
          ],
          "line": 467
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_cksum.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_error.h\"\n#include \"xfs_dir2_priv.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC void\nxfs_dir2_data_freeremove(\n\tstruct xfs_dir2_data_hdr *hdr,\t\t/* data block header */\n\tstruct xfs_dir2_data_free *bf,\t\t/* bestfree table pointer */\n\tstruct xfs_dir2_data_free *dfp,\t\t/* bestfree entry pointer */\n\tint\t\t\t*loghead)\t/* out: log data header */\n{\n\n\tASSERT(hdr->magic == cpu_to_be32(XFS_DIR2_DATA_MAGIC) ||\n\t       hdr->magic == cpu_to_be32(XFS_DIR2_BLOCK_MAGIC) ||\n\t       hdr->magic == cpu_to_be32(XFS_DIR3_DATA_MAGIC) ||\n\t       hdr->magic == cpu_to_be32(XFS_DIR3_BLOCK_MAGIC));\n\n\t/*\n\t * It's the first entry, slide the next 2 up.\n\t */\n\tif (dfp == &bf[0]) {\n\t\tbf[0] = bf[1];\n\t\tbf[1] = bf[2];\n\t}\n\t/*\n\t * It's the second entry, slide the 3rd entry up.\n\t */\n\telse if (dfp == &bf[1])\n\t\tbf[1] = bf[2];\n\t/*\n\t * Must be the last entry.\n\t */\n\telse\n\t\tASSERT(dfp == &bf[2]);\n\t/*\n\t * Clear the 3rd entry, must be zero now.\n\t */\n\tbf[2].length = 0;\n\tbf[2].offset = 0;\n\t*loghead = 1;\n}"
  },
  {
    "function_name": "xfs_dir2_data_freeinsert",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_dir2_data.c",
    "lines": "415-454",
    "snippet": "xfs_dir2_data_free_t *\t\t\t\t/* entry inserted */\nxfs_dir2_data_freeinsert(\n\tstruct xfs_dir2_data_hdr *hdr,\t\t/* data block pointer */\n\tstruct xfs_dir2_data_free *dfp,\t\t/* bestfree table pointer */\n\tstruct xfs_dir2_data_unused *dup,\t/* unused space */\n\tint\t\t\t*loghead)\t/* log the data header (out) */\n{\n\txfs_dir2_data_free_t\tnew;\t\t/* new bestfree entry */\n\n\tASSERT(hdr->magic == cpu_to_be32(XFS_DIR2_DATA_MAGIC) ||\n\t       hdr->magic == cpu_to_be32(XFS_DIR2_BLOCK_MAGIC) ||\n\t       hdr->magic == cpu_to_be32(XFS_DIR3_DATA_MAGIC) ||\n\t       hdr->magic == cpu_to_be32(XFS_DIR3_BLOCK_MAGIC));\n\n\tnew.length = dup->length;\n\tnew.offset = cpu_to_be16((char *)dup - (char *)hdr);\n\n\t/*\n\t * Insert at position 0, 1, or 2; or not at all.\n\t */\n\tif (be16_to_cpu(new.length) > be16_to_cpu(dfp[0].length)) {\n\t\tdfp[2] = dfp[1];\n\t\tdfp[1] = dfp[0];\n\t\tdfp[0] = new;\n\t\t*loghead = 1;\n\t\treturn &dfp[0];\n\t}\n\tif (be16_to_cpu(new.length) > be16_to_cpu(dfp[1].length)) {\n\t\tdfp[2] = dfp[1];\n\t\tdfp[1] = new;\n\t\t*loghead = 1;\n\t\treturn &dfp[1];\n\t}\n\tif (be16_to_cpu(new.length) > be16_to_cpu(dfp[2].length)) {\n\t\tdfp[2] = new;\n\t\t*loghead = 1;\n\t\treturn &dfp[2];\n\t}\n\treturn NULL;\n}",
    "includes": [
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_buf_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_dir2_priv.h\"",
      "#include \"xfs_dir2.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_da_btree.h\"",
      "#include \"xfs_da_format.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "be16_to_cpu",
          "args": [
            "dfp[2].length"
          ],
          "line": 448
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be16_to_cpu",
          "args": [
            "new.length"
          ],
          "line": 448
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be16_to_cpu",
          "args": [
            "dfp[1].length"
          ],
          "line": 442
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be16_to_cpu",
          "args": [
            "new.length"
          ],
          "line": 442
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be16_to_cpu",
          "args": [
            "dfp[0].length"
          ],
          "line": 435
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be16_to_cpu",
          "args": [
            "new.length"
          ],
          "line": 435
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be16",
          "args": [
            "(char *)dup - (char *)hdr"
          ],
          "line": 430
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "hdr->magic == cpu_to_be32(XFS_DIR2_DATA_MAGIC) ||\n\t       hdr->magic == cpu_to_be32(XFS_DIR2_BLOCK_MAGIC) ||\n\t       hdr->magic == cpu_to_be32(XFS_DIR3_DATA_MAGIC) ||\n\t       hdr->magic == cpu_to_be32(XFS_DIR3_BLOCK_MAGIC)"
          ],
          "line": 424
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "XFS_DIR3_BLOCK_MAGIC"
          ],
          "line": 427
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "XFS_DIR3_DATA_MAGIC"
          ],
          "line": 426
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "XFS_DIR2_BLOCK_MAGIC"
          ],
          "line": 425
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "XFS_DIR2_DATA_MAGIC"
          ],
          "line": 424
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_cksum.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_error.h\"\n#include \"xfs_dir2_priv.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nxfs_dir2_data_free_t *\t\t\t\t/* entry inserted */\nxfs_dir2_data_freeinsert(\n\tstruct xfs_dir2_data_hdr *hdr,\t\t/* data block pointer */\n\tstruct xfs_dir2_data_free *dfp,\t\t/* bestfree table pointer */\n\tstruct xfs_dir2_data_unused *dup,\t/* unused space */\n\tint\t\t\t*loghead)\t/* log the data header (out) */\n{\n\txfs_dir2_data_free_t\tnew;\t\t/* new bestfree entry */\n\n\tASSERT(hdr->magic == cpu_to_be32(XFS_DIR2_DATA_MAGIC) ||\n\t       hdr->magic == cpu_to_be32(XFS_DIR2_BLOCK_MAGIC) ||\n\t       hdr->magic == cpu_to_be32(XFS_DIR3_DATA_MAGIC) ||\n\t       hdr->magic == cpu_to_be32(XFS_DIR3_BLOCK_MAGIC));\n\n\tnew.length = dup->length;\n\tnew.offset = cpu_to_be16((char *)dup - (char *)hdr);\n\n\t/*\n\t * Insert at position 0, 1, or 2; or not at all.\n\t */\n\tif (be16_to_cpu(new.length) > be16_to_cpu(dfp[0].length)) {\n\t\tdfp[2] = dfp[1];\n\t\tdfp[1] = dfp[0];\n\t\tdfp[0] = new;\n\t\t*loghead = 1;\n\t\treturn &dfp[0];\n\t}\n\tif (be16_to_cpu(new.length) > be16_to_cpu(dfp[1].length)) {\n\t\tdfp[2] = dfp[1];\n\t\tdfp[1] = new;\n\t\t*loghead = 1;\n\t\treturn &dfp[1];\n\t}\n\tif (be16_to_cpu(new.length) > be16_to_cpu(dfp[2].length)) {\n\t\tdfp[2] = new;\n\t\t*loghead = 1;\n\t\treturn &dfp[2];\n\t}\n\treturn NULL;\n}"
  },
  {
    "function_name": "xfs_dir2_data_freefind",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_dir2_data.c",
    "lines": "344-410",
    "snippet": "xfs_dir2_data_free_t *\nxfs_dir2_data_freefind(\n\tstruct xfs_dir2_data_hdr *hdr,\t\t/* data block header */\n\tstruct xfs_dir2_data_free *bf,\t\t/* bestfree table pointer */\n\tstruct xfs_dir2_data_unused *dup)\t/* unused space */\n{\n\txfs_dir2_data_free_t\t*dfp;\t\t/* bestfree entry */\n\txfs_dir2_data_aoff_t\toff;\t\t/* offset value needed */\n#ifdef DEBUG\n\tint\t\t\tmatched;\t/* matched the value */\n\tint\t\t\tseenzero;\t/* saw a 0 bestfree entry */\n#endif\n\n\toff = (xfs_dir2_data_aoff_t)((char *)dup - (char *)hdr);\n\n#ifdef DEBUG\n\t/*\n\t * Validate some consistency in the bestfree table.\n\t * Check order, non-overlapping entries, and if we find the\n\t * one we're looking for it has to be exact.\n\t */\n\tASSERT(hdr->magic == cpu_to_be32(XFS_DIR2_DATA_MAGIC) ||\n\t       hdr->magic == cpu_to_be32(XFS_DIR3_DATA_MAGIC) ||\n\t       hdr->magic == cpu_to_be32(XFS_DIR2_BLOCK_MAGIC) ||\n\t       hdr->magic == cpu_to_be32(XFS_DIR3_BLOCK_MAGIC));\n\tfor (dfp = &bf[0], seenzero = matched = 0;\n\t     dfp < &bf[XFS_DIR2_DATA_FD_COUNT];\n\t     dfp++) {\n\t\tif (!dfp->offset) {\n\t\t\tASSERT(!dfp->length);\n\t\t\tseenzero = 1;\n\t\t\tcontinue;\n\t\t}\n\t\tASSERT(seenzero == 0);\n\t\tif (be16_to_cpu(dfp->offset) == off) {\n\t\t\tmatched = 1;\n\t\t\tASSERT(dfp->length == dup->length);\n\t\t} else if (off < be16_to_cpu(dfp->offset))\n\t\t\tASSERT(off + be16_to_cpu(dup->length) <= be16_to_cpu(dfp->offset));\n\t\telse\n\t\t\tASSERT(be16_to_cpu(dfp->offset) + be16_to_cpu(dfp->length) <= off);\n\t\tASSERT(matched || be16_to_cpu(dfp->length) >= be16_to_cpu(dup->length));\n\t\tif (dfp > &bf[0])\n\t\t\tASSERT(be16_to_cpu(dfp[-1].length) >= be16_to_cpu(dfp[0].length));\n\t}\n#endif\n\t/*\n\t * If this is smaller than the smallest bestfree entry,\n\t * it can't be there since they're sorted.\n\t */\n\tif (be16_to_cpu(dup->length) <\n\t    be16_to_cpu(bf[XFS_DIR2_DATA_FD_COUNT - 1].length))\n\t\treturn NULL;\n\t/*\n\t * Look at the three bestfree entries for our guy.\n\t */\n\tfor (dfp = &bf[0]; dfp < &bf[XFS_DIR2_DATA_FD_COUNT]; dfp++) {\n\t\tif (!dfp->offset)\n\t\t\treturn NULL;\n\t\tif (be16_to_cpu(dfp->offset) == off)\n\t\t\treturn dfp;\n\t}\n\t/*\n\t * Didn't find it.  This only happens if there are duplicate lengths.\n\t */\n\treturn NULL;\n}",
    "includes": [
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_buf_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_dir2_priv.h\"",
      "#include \"xfs_dir2.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_da_btree.h\"",
      "#include \"xfs_da_format.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "be16_to_cpu",
          "args": [
            "dfp->offset"
          ],
          "line": 403
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be16_to_cpu",
          "args": [
            "bf[XFS_DIR2_DATA_FD_COUNT - 1].length"
          ],
          "line": 395
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be16_to_cpu",
          "args": [
            "dup->length"
          ],
          "line": 394
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "be16_to_cpu(dfp[-1].length) >= be16_to_cpu(dfp[0].length)"
          ],
          "line": 387
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be16_to_cpu",
          "args": [
            "dfp[0].length"
          ],
          "line": 387
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be16_to_cpu",
          "args": [
            "dfp[-1].length"
          ],
          "line": 387
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "matched || be16_to_cpu(dfp->length) >= be16_to_cpu(dup->length)"
          ],
          "line": 385
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be16_to_cpu",
          "args": [
            "dup->length"
          ],
          "line": 385
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be16_to_cpu",
          "args": [
            "dfp->length"
          ],
          "line": 385
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "be16_to_cpu(dfp->offset) + be16_to_cpu(dfp->length) <= off"
          ],
          "line": 384
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be16_to_cpu",
          "args": [
            "dfp->length"
          ],
          "line": 384
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be16_to_cpu",
          "args": [
            "dfp->offset"
          ],
          "line": 384
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "off + be16_to_cpu(dup->length) <= be16_to_cpu(dfp->offset)"
          ],
          "line": 382
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be16_to_cpu",
          "args": [
            "dfp->offset"
          ],
          "line": 382
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be16_to_cpu",
          "args": [
            "dup->length"
          ],
          "line": 382
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be16_to_cpu",
          "args": [
            "dfp->offset"
          ],
          "line": 381
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "dfp->length == dup->length"
          ],
          "line": 380
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be16_to_cpu",
          "args": [
            "dfp->offset"
          ],
          "line": 378
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "seenzero == 0"
          ],
          "line": 377
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "!dfp->length"
          ],
          "line": 373
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "hdr->magic == cpu_to_be32(XFS_DIR2_DATA_MAGIC) ||\n\t       hdr->magic == cpu_to_be32(XFS_DIR3_DATA_MAGIC) ||\n\t       hdr->magic == cpu_to_be32(XFS_DIR2_BLOCK_MAGIC) ||\n\t       hdr->magic == cpu_to_be32(XFS_DIR3_BLOCK_MAGIC)"
          ],
          "line": 365
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "XFS_DIR3_BLOCK_MAGIC"
          ],
          "line": 368
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "XFS_DIR2_BLOCK_MAGIC"
          ],
          "line": 367
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "XFS_DIR3_DATA_MAGIC"
          ],
          "line": 366
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "XFS_DIR2_DATA_MAGIC"
          ],
          "line": 365
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "(char *)dup - (char *)hdr"
          ],
          "line": 357
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_cksum.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_error.h\"\n#include \"xfs_dir2_priv.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nxfs_dir2_data_free_t *\nxfs_dir2_data_freefind(\n\tstruct xfs_dir2_data_hdr *hdr,\t\t/* data block header */\n\tstruct xfs_dir2_data_free *bf,\t\t/* bestfree table pointer */\n\tstruct xfs_dir2_data_unused *dup)\t/* unused space */\n{\n\txfs_dir2_data_free_t\t*dfp;\t\t/* bestfree entry */\n\txfs_dir2_data_aoff_t\toff;\t\t/* offset value needed */\n#ifdef DEBUG\n\tint\t\t\tmatched;\t/* matched the value */\n\tint\t\t\tseenzero;\t/* saw a 0 bestfree entry */\n#endif\n\n\toff = (xfs_dir2_data_aoff_t)((char *)dup - (char *)hdr);\n\n#ifdef DEBUG\n\t/*\n\t * Validate some consistency in the bestfree table.\n\t * Check order, non-overlapping entries, and if we find the\n\t * one we're looking for it has to be exact.\n\t */\n\tASSERT(hdr->magic == cpu_to_be32(XFS_DIR2_DATA_MAGIC) ||\n\t       hdr->magic == cpu_to_be32(XFS_DIR3_DATA_MAGIC) ||\n\t       hdr->magic == cpu_to_be32(XFS_DIR2_BLOCK_MAGIC) ||\n\t       hdr->magic == cpu_to_be32(XFS_DIR3_BLOCK_MAGIC));\n\tfor (dfp = &bf[0], seenzero = matched = 0;\n\t     dfp < &bf[XFS_DIR2_DATA_FD_COUNT];\n\t     dfp++) {\n\t\tif (!dfp->offset) {\n\t\t\tASSERT(!dfp->length);\n\t\t\tseenzero = 1;\n\t\t\tcontinue;\n\t\t}\n\t\tASSERT(seenzero == 0);\n\t\tif (be16_to_cpu(dfp->offset) == off) {\n\t\t\tmatched = 1;\n\t\t\tASSERT(dfp->length == dup->length);\n\t\t} else if (off < be16_to_cpu(dfp->offset))\n\t\t\tASSERT(off + be16_to_cpu(dup->length) <= be16_to_cpu(dfp->offset));\n\t\telse\n\t\t\tASSERT(be16_to_cpu(dfp->offset) + be16_to_cpu(dfp->length) <= off);\n\t\tASSERT(matched || be16_to_cpu(dfp->length) >= be16_to_cpu(dup->length));\n\t\tif (dfp > &bf[0])\n\t\t\tASSERT(be16_to_cpu(dfp[-1].length) >= be16_to_cpu(dfp[0].length));\n\t}\n#endif\n\t/*\n\t * If this is smaller than the smallest bestfree entry,\n\t * it can't be there since they're sorted.\n\t */\n\tif (be16_to_cpu(dup->length) <\n\t    be16_to_cpu(bf[XFS_DIR2_DATA_FD_COUNT - 1].length))\n\t\treturn NULL;\n\t/*\n\t * Look at the three bestfree entries for our guy.\n\t */\n\tfor (dfp = &bf[0]; dfp < &bf[XFS_DIR2_DATA_FD_COUNT]; dfp++) {\n\t\tif (!dfp->offset)\n\t\t\treturn NULL;\n\t\tif (be16_to_cpu(dfp->offset) == off)\n\t\t\treturn dfp;\n\t}\n\t/*\n\t * Didn't find it.  This only happens if there are duplicate lengths.\n\t */\n\treturn NULL;\n}"
  },
  {
    "function_name": "xfs_dir3_data_readahead",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_dir2_data.c",
    "lines": "330-338",
    "snippet": "int\nxfs_dir3_data_readahead(\n\tstruct xfs_inode\t*dp,\n\txfs_dablk_t\t\tbno,\n\txfs_daddr_t\t\tmapped_bno)\n{\n\treturn xfs_da_reada_buf(dp, bno, mapped_bno,\n\t\t\t\tXFS_DATA_FORK, &xfs_dir3_data_reada_buf_ops);\n}",
    "includes": [
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_buf_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_dir2_priv.h\"",
      "#include \"xfs_dir2.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_da_btree.h\"",
      "#include \"xfs_da_format.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static const struct xfs_buf_ops xfs_dir3_data_reada_buf_ops = {\n\t.verify_read = xfs_dir3_data_reada_verify,\n\t.verify_write = xfs_dir3_data_write_verify,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_da_reada_buf",
          "args": [
            "dp",
            "bno",
            "mapped_bno",
            "XFS_DATA_FORK",
            "&xfs_dir3_data_reada_buf_ops"
          ],
          "line": 336
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_da_reada_buf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_da_btree.c",
          "lines": "2626-2660",
          "snippet": "xfs_daddr_t\nxfs_da_reada_buf(\n\tstruct xfs_inode\t*dp,\n\txfs_dablk_t\t\tbno,\n\txfs_daddr_t\t\tmappedbno,\n\tint\t\t\twhichfork,\n\tconst struct xfs_buf_ops *ops)\n{\n\tstruct xfs_buf_map\tmap;\n\tstruct xfs_buf_map\t*mapp;\n\tint\t\t\tnmap;\n\tint\t\t\terror;\n\n\tmapp = &map;\n\tnmap = 1;\n\terror = xfs_dabuf_map(dp, bno, mappedbno, whichfork,\n\t\t\t\t&mapp, &nmap);\n\tif (error) {\n\t\t/* mapping a hole is not an error, but we don't continue */\n\t\tif (error == -1)\n\t\t\terror = 0;\n\t\tgoto out_free;\n\t}\n\n\tmappedbno = mapp[0].bm_bn;\n\txfs_buf_readahead_map(dp->i_mount->m_ddev_targp, mapp, nmap, ops);\n\nout_free:\n\tif (mapp != &map)\n\t\tkmem_free(mapp);\n\n\tif (error)\n\t\treturn -1;\n\treturn mappedbno;\n}",
          "includes": [
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_attr_leaf.h\"",
            "#include \"xfs_attr.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_dir2_priv.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_buf_item.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_attr_leaf.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_dir2_priv.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nxfs_daddr_t\nxfs_da_reada_buf(\n\tstruct xfs_inode\t*dp,\n\txfs_dablk_t\t\tbno,\n\txfs_daddr_t\t\tmappedbno,\n\tint\t\t\twhichfork,\n\tconst struct xfs_buf_ops *ops)\n{\n\tstruct xfs_buf_map\tmap;\n\tstruct xfs_buf_map\t*mapp;\n\tint\t\t\tnmap;\n\tint\t\t\terror;\n\n\tmapp = &map;\n\tnmap = 1;\n\terror = xfs_dabuf_map(dp, bno, mappedbno, whichfork,\n\t\t\t\t&mapp, &nmap);\n\tif (error) {\n\t\t/* mapping a hole is not an error, but we don't continue */\n\t\tif (error == -1)\n\t\t\terror = 0;\n\t\tgoto out_free;\n\t}\n\n\tmappedbno = mapp[0].bm_bn;\n\txfs_buf_readahead_map(dp->i_mount->m_ddev_targp, mapp, nmap, ops);\n\nout_free:\n\tif (mapp != &map)\n\t\tkmem_free(mapp);\n\n\tif (error)\n\t\treturn -1;\n\treturn mappedbno;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xfs_cksum.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_error.h\"\n#include \"xfs_dir2_priv.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nstatic const struct xfs_buf_ops xfs_dir3_data_reada_buf_ops = {\n\t.verify_read = xfs_dir3_data_reada_verify,\n\t.verify_write = xfs_dir3_data_write_verify,\n};\n\nint\nxfs_dir3_data_readahead(\n\tstruct xfs_inode\t*dp,\n\txfs_dablk_t\t\tbno,\n\txfs_daddr_t\t\tmapped_bno)\n{\n\treturn xfs_da_reada_buf(dp, bno, mapped_bno,\n\t\t\t\tXFS_DATA_FORK, &xfs_dir3_data_reada_buf_ops);\n}"
  },
  {
    "function_name": "xfs_dir3_data_read",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_dir2_data.c",
    "lines": "313-328",
    "snippet": "int\nxfs_dir3_data_read(\n\tstruct xfs_trans\t*tp,\n\tstruct xfs_inode\t*dp,\n\txfs_dablk_t\t\tbno,\n\txfs_daddr_t\t\tmapped_bno,\n\tstruct xfs_buf\t\t**bpp)\n{\n\tint\t\t\terr;\n\n\terr = xfs_da_read_buf(tp, dp, bno, mapped_bno, bpp,\n\t\t\t\tXFS_DATA_FORK, &xfs_dir3_data_buf_ops);\n\tif (!err && tp)\n\t\txfs_trans_buf_set_type(tp, *bpp, XFS_BLFT_DIR_DATA_BUF);\n\treturn err;\n}",
    "includes": [
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_buf_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_dir2_priv.h\"",
      "#include \"xfs_dir2.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_da_btree.h\"",
      "#include \"xfs_da_format.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "const struct xfs_buf_ops xfs_dir3_data_buf_ops = {\n\t.verify_read = xfs_dir3_data_read_verify,\n\t.verify_write = xfs_dir3_data_write_verify,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_trans_buf_set_type",
          "args": [
            "tp",
            "*bpp",
            "XFS_BLFT_DIR_DATA_BUF"
          ],
          "line": 326
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_trans_buf_set_type",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans_buf.c",
          "lines": "730-746",
          "snippet": "void\nxfs_trans_buf_set_type(\n\tstruct xfs_trans\t*tp,\n\tstruct xfs_buf\t\t*bp,\n\tenum xfs_blft\t\ttype)\n{\n\tstruct xfs_buf_log_item\t*bip = bp->b_fspriv;\n\n\tif (!tp)\n\t\treturn;\n\n\tASSERT(bp->b_transp == tp);\n\tASSERT(bip != NULL);\n\tASSERT(atomic_read(&bip->bli_refcount) > 0);\n\n\txfs_blft_to_flags(&bip->__bli_format, type);\n}",
          "includes": [
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\n\nvoid\nxfs_trans_buf_set_type(\n\tstruct xfs_trans\t*tp,\n\tstruct xfs_buf\t\t*bp,\n\tenum xfs_blft\t\ttype)\n{\n\tstruct xfs_buf_log_item\t*bip = bp->b_fspriv;\n\n\tif (!tp)\n\t\treturn;\n\n\tASSERT(bp->b_transp == tp);\n\tASSERT(bip != NULL);\n\tASSERT(atomic_read(&bip->bli_refcount) > 0);\n\n\txfs_blft_to_flags(&bip->__bli_format, type);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_da_read_buf",
          "args": [
            "tp",
            "dp",
            "bno",
            "mapped_bno",
            "bpp",
            "XFS_DATA_FORK",
            "&xfs_dir3_data_buf_ops"
          ],
          "line": 323
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_da_read_buf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_da_btree.c",
          "lines": "2577-2621",
          "snippet": "int\nxfs_da_read_buf(\n\tstruct xfs_trans\t*trans,\n\tstruct xfs_inode\t*dp,\n\txfs_dablk_t\t\tbno,\n\txfs_daddr_t\t\tmappedbno,\n\tstruct xfs_buf\t\t**bpp,\n\tint\t\t\twhichfork,\n\tconst struct xfs_buf_ops *ops)\n{\n\tstruct xfs_buf\t\t*bp;\n\tstruct xfs_buf_map\tmap;\n\tstruct xfs_buf_map\t*mapp;\n\tint\t\t\tnmap;\n\tint\t\t\terror;\n\n\t*bpp = NULL;\n\tmapp = &map;\n\tnmap = 1;\n\terror = xfs_dabuf_map(dp, bno, mappedbno, whichfork,\n\t\t\t\t&mapp, &nmap);\n\tif (error) {\n\t\t/* mapping a hole is not an error, but we don't continue */\n\t\tif (error == -1)\n\t\t\terror = 0;\n\t\tgoto out_free;\n\t}\n\n\terror = xfs_trans_read_buf_map(dp->i_mount, trans,\n\t\t\t\t\tdp->i_mount->m_ddev_targp,\n\t\t\t\t\tmapp, nmap, 0, &bp, ops);\n\tif (error)\n\t\tgoto out_free;\n\n\tif (whichfork == XFS_ATTR_FORK)\n\t\txfs_buf_set_ref(bp, XFS_ATTR_BTREE_REF);\n\telse\n\t\txfs_buf_set_ref(bp, XFS_DIR_BTREE_REF);\n\t*bpp = bp;\nout_free:\n\tif (mapp != &map)\n\t\tkmem_free(mapp);\n\n\treturn error;\n}",
          "includes": [
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_attr_leaf.h\"",
            "#include \"xfs_attr.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_dir2_priv.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_buf_item.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_attr_leaf.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_dir2_priv.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\nxfs_da_read_buf(\n\tstruct xfs_trans\t*trans,\n\tstruct xfs_inode\t*dp,\n\txfs_dablk_t\t\tbno,\n\txfs_daddr_t\t\tmappedbno,\n\tstruct xfs_buf\t\t**bpp,\n\tint\t\t\twhichfork,\n\tconst struct xfs_buf_ops *ops)\n{\n\tstruct xfs_buf\t\t*bp;\n\tstruct xfs_buf_map\tmap;\n\tstruct xfs_buf_map\t*mapp;\n\tint\t\t\tnmap;\n\tint\t\t\terror;\n\n\t*bpp = NULL;\n\tmapp = &map;\n\tnmap = 1;\n\terror = xfs_dabuf_map(dp, bno, mappedbno, whichfork,\n\t\t\t\t&mapp, &nmap);\n\tif (error) {\n\t\t/* mapping a hole is not an error, but we don't continue */\n\t\tif (error == -1)\n\t\t\terror = 0;\n\t\tgoto out_free;\n\t}\n\n\terror = xfs_trans_read_buf_map(dp->i_mount, trans,\n\t\t\t\t\tdp->i_mount->m_ddev_targp,\n\t\t\t\t\tmapp, nmap, 0, &bp, ops);\n\tif (error)\n\t\tgoto out_free;\n\n\tif (whichfork == XFS_ATTR_FORK)\n\t\txfs_buf_set_ref(bp, XFS_ATTR_BTREE_REF);\n\telse\n\t\txfs_buf_set_ref(bp, XFS_DIR_BTREE_REF);\n\t*bpp = bp;\nout_free:\n\tif (mapp != &map)\n\t\tkmem_free(mapp);\n\n\treturn error;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xfs_cksum.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_error.h\"\n#include \"xfs_dir2_priv.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nconst struct xfs_buf_ops xfs_dir3_data_buf_ops = {\n\t.verify_read = xfs_dir3_data_read_verify,\n\t.verify_write = xfs_dir3_data_write_verify,\n};\n\nint\nxfs_dir3_data_read(\n\tstruct xfs_trans\t*tp,\n\tstruct xfs_inode\t*dp,\n\txfs_dablk_t\t\tbno,\n\txfs_daddr_t\t\tmapped_bno,\n\tstruct xfs_buf\t\t**bpp)\n{\n\tint\t\t\terr;\n\n\terr = xfs_da_read_buf(tp, dp, bno, mapped_bno, bpp,\n\t\t\t\tXFS_DATA_FORK, &xfs_dir3_data_buf_ops);\n\tif (!err && tp)\n\t\txfs_trans_buf_set_type(tp, *bpp, XFS_BLFT_DIR_DATA_BUF);\n\treturn err;\n}"
  },
  {
    "function_name": "xfs_dir3_data_write_verify",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_dir2_data.c",
    "lines": "279-300",
    "snippet": "static void\nxfs_dir3_data_write_verify(\n\tstruct xfs_buf\t*bp)\n{\n\tstruct xfs_mount\t*mp = bp->b_target->bt_mount;\n\tstruct xfs_buf_log_item\t*bip = bp->b_fspriv;\n\tstruct xfs_dir3_blk_hdr\t*hdr3 = bp->b_addr;\n\n\tif (!xfs_dir3_data_verify(bp)) {\n\t\txfs_buf_ioerror(bp, -EFSCORRUPTED);\n\t\txfs_verifier_error(bp);\n\t\treturn;\n\t}\n\n\tif (!xfs_sb_version_hascrc(&mp->m_sb))\n\t\treturn;\n\n\tif (bip)\n\t\thdr3->lsn = cpu_to_be64(bip->bli_item.li_lsn);\n\n\txfs_buf_update_cksum(bp, XFS_DIR3_DATA_CRC_OFF);\n}",
    "includes": [
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_buf_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_dir2_priv.h\"",
      "#include \"xfs_dir2.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_da_btree.h\"",
      "#include \"xfs_da_format.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_buf_update_cksum",
          "args": [
            "bp",
            "XFS_DIR3_DATA_CRC_OFF"
          ],
          "line": 299
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_buf_update_cksum",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_buf.h",
          "lines": "374-379",
          "snippet": "static inline void\nxfs_buf_update_cksum(struct xfs_buf *bp, unsigned long cksum_offset)\n{\n\txfs_update_cksum(bp->b_addr, BBTOB(bp->b_length),\n\t\t\t cksum_offset);\n}",
          "includes": [
            "#include <linux/list_lru.h>",
            "#include <linux/uio.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/types.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/list_lru.h>\n#include <linux/uio.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/spinlock.h>\n#include <linux/types.h>\n#include <linux/list.h>\n\nstatic inline void\nxfs_buf_update_cksum(struct xfs_buf *bp, unsigned long cksum_offset)\n{\n\txfs_update_cksum(bp->b_addr, BBTOB(bp->b_length),\n\t\t\t cksum_offset);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_be64",
          "args": [
            "bip->bli_item.li_lsn"
          ],
          "line": 297
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_sb_version_hascrc",
          "args": [
            "&mp->m_sb"
          ],
          "line": 293
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_sb_version_hascrc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_format.h",
          "lines": "547-550",
          "snippet": "static inline int xfs_sb_version_hascrc(struct xfs_sb *sbp)\n{\n\treturn XFS_SB_VERSION_NUM(sbp) == XFS_SB_VERSION_5;\n}",
          "includes": [],
          "macros_used": [
            "#define\tXFS_SB_VERSION_5\t5\t\t/* CRC enabled filesystem */"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#define\tXFS_SB_VERSION_5\t5\t\t/* CRC enabled filesystem */\n\nstatic inline int xfs_sb_version_hascrc(struct xfs_sb *sbp)\n{\n\treturn XFS_SB_VERSION_NUM(sbp) == XFS_SB_VERSION_5;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_verifier_error",
          "args": [
            "bp"
          ],
          "line": 289
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_verifier_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_error.c",
          "lines": "161-180",
          "snippet": "void\nxfs_verifier_error(\n\tstruct xfs_buf\t\t*bp)\n{\n\tstruct xfs_mount *mp = bp->b_target->bt_mount;\n\n\txfs_alert(mp, \"Metadata %s detected at %pF, block 0x%llx\",\n\t\t  bp->b_error == -EFSBADCRC ? \"CRC error\" : \"corruption\",\n\t\t  __return_address, bp->b_bn);\n\n\txfs_alert(mp, \"Unmount and run xfs_repair\");\n\n\tif (xfs_error_level >= XFS_ERRLEVEL_LOW) {\n\t\txfs_alert(mp, \"First 64 bytes of corrupted metadata buffer:\");\n\t\txfs_hex_dump(xfs_buf_offset(bp, 0), 64);\n\t}\n\n\tif (xfs_error_level >= XFS_ERRLEVEL_HIGH)\n\t\txfs_stack_trace();\n}",
          "includes": [
            "#include \"xfs_error.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_error.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs_format.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_verifier_error(\n\tstruct xfs_buf\t\t*bp)\n{\n\tstruct xfs_mount *mp = bp->b_target->bt_mount;\n\n\txfs_alert(mp, \"Metadata %s detected at %pF, block 0x%llx\",\n\t\t  bp->b_error == -EFSBADCRC ? \"CRC error\" : \"corruption\",\n\t\t  __return_address, bp->b_bn);\n\n\txfs_alert(mp, \"Unmount and run xfs_repair\");\n\n\tif (xfs_error_level >= XFS_ERRLEVEL_LOW) {\n\t\txfs_alert(mp, \"First 64 bytes of corrupted metadata buffer:\");\n\t\txfs_hex_dump(xfs_buf_offset(bp, 0), 64);\n\t}\n\n\tif (xfs_error_level >= XFS_ERRLEVEL_HIGH)\n\t\txfs_stack_trace();\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_buf_ioerror",
          "args": [
            "bp",
            "-EFSCORRUPTED"
          ],
          "line": 288
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_buf_ioerror_alert",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_buf.c",
          "lines": "1067-1075",
          "snippet": "void\nxfs_buf_ioerror_alert(\n\tstruct xfs_buf\t\t*bp,\n\tconst char\t\t*func)\n{\n\txfs_alert(bp->b_target->bt_mount,\n\"metadata I/O error: block 0x%llx (\\\"%s\\\") error %d numblks %d\",\n\t\t(__uint64_t)XFS_BUF_ADDR(bp), func, -bp->b_error, bp->b_length);\n}",
          "includes": [
            "#include \"xfs_log.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/migrate.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hash.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/percpu.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/bio.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/init.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/gfp.h>",
            "#include <linux/errno.h>",
            "#include <linux/stddef.h>",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include <linux/freezer.h>\n#include <linux/backing-dev.h>\n#include <linux/migrate.h>\n#include <linux/kthread.h>\n#include <linux/hash.h>\n#include <linux/blkdev.h>\n#include <linux/percpu.h>\n#include <linux/workqueue.h>\n#include <linux/proc_fs.h>\n#include <linux/sysctl.h>\n#include <linux/bio.h>\n#include <linux/vmalloc.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/gfp.h>\n#include <linux/errno.h>\n#include <linux/stddef.h>\n#include \"xfs.h\"\n\nvoid\nxfs_buf_ioerror_alert(\n\tstruct xfs_buf\t\t*bp,\n\tconst char\t\t*func)\n{\n\txfs_alert(bp->b_target->bt_mount,\n\"metadata I/O error: block 0x%llx (\\\"%s\\\") error %d numblks %d\",\n\t\t(__uint64_t)XFS_BUF_ADDR(bp), func, -bp->b_error, bp->b_length);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_dir3_data_verify",
          "args": [
            "bp"
          ],
          "line": 287
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_dir3_data_verify",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_dir2_data.c",
          "lines": "212-233",
          "snippet": "static bool\nxfs_dir3_data_verify(\n\tstruct xfs_buf\t\t*bp)\n{\n\tstruct xfs_mount\t*mp = bp->b_target->bt_mount;\n\tstruct xfs_dir3_blk_hdr\t*hdr3 = bp->b_addr;\n\n\tif (xfs_sb_version_hascrc(&mp->m_sb)) {\n\t\tif (hdr3->magic != cpu_to_be32(XFS_DIR3_DATA_MAGIC))\n\t\t\treturn false;\n\t\tif (!uuid_equal(&hdr3->uuid, &mp->m_sb.sb_uuid))\n\t\t\treturn false;\n\t\tif (be64_to_cpu(hdr3->blkno) != bp->b_bn)\n\t\t\treturn false;\n\t} else {\n\t\tif (hdr3->magic != cpu_to_be32(XFS_DIR2_DATA_MAGIC))\n\t\t\treturn false;\n\t}\n\tif (__xfs_dir3_data_check(NULL, bp))\n\t\treturn false;\n\treturn true;\n}",
          "includes": [
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_dir2_priv.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_cksum.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_error.h\"\n#include \"xfs_dir2_priv.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nstatic bool\nxfs_dir3_data_verify(\n\tstruct xfs_buf\t\t*bp)\n{\n\tstruct xfs_mount\t*mp = bp->b_target->bt_mount;\n\tstruct xfs_dir3_blk_hdr\t*hdr3 = bp->b_addr;\n\n\tif (xfs_sb_version_hascrc(&mp->m_sb)) {\n\t\tif (hdr3->magic != cpu_to_be32(XFS_DIR3_DATA_MAGIC))\n\t\t\treturn false;\n\t\tif (!uuid_equal(&hdr3->uuid, &mp->m_sb.sb_uuid))\n\t\t\treturn false;\n\t\tif (be64_to_cpu(hdr3->blkno) != bp->b_bn)\n\t\t\treturn false;\n\t} else {\n\t\tif (hdr3->magic != cpu_to_be32(XFS_DIR2_DATA_MAGIC))\n\t\t\treturn false;\n\t}\n\tif (__xfs_dir3_data_check(NULL, bp))\n\t\treturn false;\n\treturn true;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xfs_cksum.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_error.h\"\n#include \"xfs_dir2_priv.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nstatic void\nxfs_dir3_data_write_verify(\n\tstruct xfs_buf\t*bp)\n{\n\tstruct xfs_mount\t*mp = bp->b_target->bt_mount;\n\tstruct xfs_buf_log_item\t*bip = bp->b_fspriv;\n\tstruct xfs_dir3_blk_hdr\t*hdr3 = bp->b_addr;\n\n\tif (!xfs_dir3_data_verify(bp)) {\n\t\txfs_buf_ioerror(bp, -EFSCORRUPTED);\n\t\txfs_verifier_error(bp);\n\t\treturn;\n\t}\n\n\tif (!xfs_sb_version_hascrc(&mp->m_sb))\n\t\treturn;\n\n\tif (bip)\n\t\thdr3->lsn = cpu_to_be64(bip->bli_item.li_lsn);\n\n\txfs_buf_update_cksum(bp, XFS_DIR3_DATA_CRC_OFF);\n}"
  },
  {
    "function_name": "xfs_dir3_data_read_verify",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_dir2_data.c",
    "lines": "263-277",
    "snippet": "static void\nxfs_dir3_data_read_verify(\n\tstruct xfs_buf\t*bp)\n{\n\tstruct xfs_mount\t*mp = bp->b_target->bt_mount;\n\n\tif (xfs_sb_version_hascrc(&mp->m_sb) &&\n\t     !xfs_buf_verify_cksum(bp, XFS_DIR3_DATA_CRC_OFF))\n\t\t xfs_buf_ioerror(bp, -EFSBADCRC);\n\telse if (!xfs_dir3_data_verify(bp))\n\t\txfs_buf_ioerror(bp, -EFSCORRUPTED);\n\n\tif (bp->b_error)\n\t\txfs_verifier_error(bp);\n}",
    "includes": [
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_buf_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_dir2_priv.h\"",
      "#include \"xfs_dir2.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_da_btree.h\"",
      "#include \"xfs_da_format.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_verifier_error",
          "args": [
            "bp"
          ],
          "line": 276
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_verifier_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_error.c",
          "lines": "161-180",
          "snippet": "void\nxfs_verifier_error(\n\tstruct xfs_buf\t\t*bp)\n{\n\tstruct xfs_mount *mp = bp->b_target->bt_mount;\n\n\txfs_alert(mp, \"Metadata %s detected at %pF, block 0x%llx\",\n\t\t  bp->b_error == -EFSBADCRC ? \"CRC error\" : \"corruption\",\n\t\t  __return_address, bp->b_bn);\n\n\txfs_alert(mp, \"Unmount and run xfs_repair\");\n\n\tif (xfs_error_level >= XFS_ERRLEVEL_LOW) {\n\t\txfs_alert(mp, \"First 64 bytes of corrupted metadata buffer:\");\n\t\txfs_hex_dump(xfs_buf_offset(bp, 0), 64);\n\t}\n\n\tif (xfs_error_level >= XFS_ERRLEVEL_HIGH)\n\t\txfs_stack_trace();\n}",
          "includes": [
            "#include \"xfs_error.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_error.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs_format.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_verifier_error(\n\tstruct xfs_buf\t\t*bp)\n{\n\tstruct xfs_mount *mp = bp->b_target->bt_mount;\n\n\txfs_alert(mp, \"Metadata %s detected at %pF, block 0x%llx\",\n\t\t  bp->b_error == -EFSBADCRC ? \"CRC error\" : \"corruption\",\n\t\t  __return_address, bp->b_bn);\n\n\txfs_alert(mp, \"Unmount and run xfs_repair\");\n\n\tif (xfs_error_level >= XFS_ERRLEVEL_LOW) {\n\t\txfs_alert(mp, \"First 64 bytes of corrupted metadata buffer:\");\n\t\txfs_hex_dump(xfs_buf_offset(bp, 0), 64);\n\t}\n\n\tif (xfs_error_level >= XFS_ERRLEVEL_HIGH)\n\t\txfs_stack_trace();\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_buf_ioerror",
          "args": [
            "bp",
            "-EFSCORRUPTED"
          ],
          "line": 273
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_buf_ioerror_alert",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_buf.c",
          "lines": "1067-1075",
          "snippet": "void\nxfs_buf_ioerror_alert(\n\tstruct xfs_buf\t\t*bp,\n\tconst char\t\t*func)\n{\n\txfs_alert(bp->b_target->bt_mount,\n\"metadata I/O error: block 0x%llx (\\\"%s\\\") error %d numblks %d\",\n\t\t(__uint64_t)XFS_BUF_ADDR(bp), func, -bp->b_error, bp->b_length);\n}",
          "includes": [
            "#include \"xfs_log.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/migrate.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hash.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/percpu.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/bio.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/init.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/gfp.h>",
            "#include <linux/errno.h>",
            "#include <linux/stddef.h>",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include <linux/freezer.h>\n#include <linux/backing-dev.h>\n#include <linux/migrate.h>\n#include <linux/kthread.h>\n#include <linux/hash.h>\n#include <linux/blkdev.h>\n#include <linux/percpu.h>\n#include <linux/workqueue.h>\n#include <linux/proc_fs.h>\n#include <linux/sysctl.h>\n#include <linux/bio.h>\n#include <linux/vmalloc.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/gfp.h>\n#include <linux/errno.h>\n#include <linux/stddef.h>\n#include \"xfs.h\"\n\nvoid\nxfs_buf_ioerror_alert(\n\tstruct xfs_buf\t\t*bp,\n\tconst char\t\t*func)\n{\n\txfs_alert(bp->b_target->bt_mount,\n\"metadata I/O error: block 0x%llx (\\\"%s\\\") error %d numblks %d\",\n\t\t(__uint64_t)XFS_BUF_ADDR(bp), func, -bp->b_error, bp->b_length);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_dir3_data_verify",
          "args": [
            "bp"
          ],
          "line": 272
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_dir3_data_verify",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_dir2_data.c",
          "lines": "212-233",
          "snippet": "static bool\nxfs_dir3_data_verify(\n\tstruct xfs_buf\t\t*bp)\n{\n\tstruct xfs_mount\t*mp = bp->b_target->bt_mount;\n\tstruct xfs_dir3_blk_hdr\t*hdr3 = bp->b_addr;\n\n\tif (xfs_sb_version_hascrc(&mp->m_sb)) {\n\t\tif (hdr3->magic != cpu_to_be32(XFS_DIR3_DATA_MAGIC))\n\t\t\treturn false;\n\t\tif (!uuid_equal(&hdr3->uuid, &mp->m_sb.sb_uuid))\n\t\t\treturn false;\n\t\tif (be64_to_cpu(hdr3->blkno) != bp->b_bn)\n\t\t\treturn false;\n\t} else {\n\t\tif (hdr3->magic != cpu_to_be32(XFS_DIR2_DATA_MAGIC))\n\t\t\treturn false;\n\t}\n\tif (__xfs_dir3_data_check(NULL, bp))\n\t\treturn false;\n\treturn true;\n}",
          "includes": [
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_dir2_priv.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_cksum.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_error.h\"\n#include \"xfs_dir2_priv.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nstatic bool\nxfs_dir3_data_verify(\n\tstruct xfs_buf\t\t*bp)\n{\n\tstruct xfs_mount\t*mp = bp->b_target->bt_mount;\n\tstruct xfs_dir3_blk_hdr\t*hdr3 = bp->b_addr;\n\n\tif (xfs_sb_version_hascrc(&mp->m_sb)) {\n\t\tif (hdr3->magic != cpu_to_be32(XFS_DIR3_DATA_MAGIC))\n\t\t\treturn false;\n\t\tif (!uuid_equal(&hdr3->uuid, &mp->m_sb.sb_uuid))\n\t\t\treturn false;\n\t\tif (be64_to_cpu(hdr3->blkno) != bp->b_bn)\n\t\t\treturn false;\n\t} else {\n\t\tif (hdr3->magic != cpu_to_be32(XFS_DIR2_DATA_MAGIC))\n\t\t\treturn false;\n\t}\n\tif (__xfs_dir3_data_check(NULL, bp))\n\t\treturn false;\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_buf_verify_cksum",
          "args": [
            "bp",
            "XFS_DIR3_DATA_CRC_OFF"
          ],
          "line": 270
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_buf_verify_cksum",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_buf.h",
          "lines": "367-372",
          "snippet": "static inline int\nxfs_buf_verify_cksum(struct xfs_buf *bp, unsigned long cksum_offset)\n{\n\treturn xfs_verify_cksum(bp->b_addr, BBTOB(bp->b_length),\n\t\t\t\tcksum_offset);\n}",
          "includes": [
            "#include <linux/list_lru.h>",
            "#include <linux/uio.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/types.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/list_lru.h>\n#include <linux/uio.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/spinlock.h>\n#include <linux/types.h>\n#include <linux/list.h>\n\nstatic inline int\nxfs_buf_verify_cksum(struct xfs_buf *bp, unsigned long cksum_offset)\n{\n\treturn xfs_verify_cksum(bp->b_addr, BBTOB(bp->b_length),\n\t\t\t\tcksum_offset);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_sb_version_hascrc",
          "args": [
            "&mp->m_sb"
          ],
          "line": 269
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_sb_version_hascrc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_format.h",
          "lines": "547-550",
          "snippet": "static inline int xfs_sb_version_hascrc(struct xfs_sb *sbp)\n{\n\treturn XFS_SB_VERSION_NUM(sbp) == XFS_SB_VERSION_5;\n}",
          "includes": [],
          "macros_used": [
            "#define\tXFS_SB_VERSION_5\t5\t\t/* CRC enabled filesystem */"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#define\tXFS_SB_VERSION_5\t5\t\t/* CRC enabled filesystem */\n\nstatic inline int xfs_sb_version_hascrc(struct xfs_sb *sbp)\n{\n\treturn XFS_SB_VERSION_NUM(sbp) == XFS_SB_VERSION_5;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xfs_cksum.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_error.h\"\n#include \"xfs_dir2_priv.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nstatic void\nxfs_dir3_data_read_verify(\n\tstruct xfs_buf\t*bp)\n{\n\tstruct xfs_mount\t*mp = bp->b_target->bt_mount;\n\n\tif (xfs_sb_version_hascrc(&mp->m_sb) &&\n\t     !xfs_buf_verify_cksum(bp, XFS_DIR3_DATA_CRC_OFF))\n\t\t xfs_buf_ioerror(bp, -EFSBADCRC);\n\telse if (!xfs_dir3_data_verify(bp))\n\t\txfs_buf_ioerror(bp, -EFSCORRUPTED);\n\n\tif (bp->b_error)\n\t\txfs_verifier_error(bp);\n}"
  },
  {
    "function_name": "xfs_dir3_data_reada_verify",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_dir2_data.c",
    "lines": "240-261",
    "snippet": "static void\nxfs_dir3_data_reada_verify(\n\tstruct xfs_buf\t\t*bp)\n{\n\tstruct xfs_dir2_data_hdr *hdr = bp->b_addr;\n\n\tswitch (hdr->magic) {\n\tcase cpu_to_be32(XFS_DIR2_BLOCK_MAGIC):\n\tcase cpu_to_be32(XFS_DIR3_BLOCK_MAGIC):\n\t\tbp->b_ops = &xfs_dir3_block_buf_ops;\n\t\tbp->b_ops->verify_read(bp);\n\t\treturn;\n\tcase cpu_to_be32(XFS_DIR2_DATA_MAGIC):\n\tcase cpu_to_be32(XFS_DIR3_DATA_MAGIC):\n\t\txfs_dir3_data_verify(bp);\n\t\treturn;\n\tdefault:\n\t\txfs_buf_ioerror(bp, -EFSCORRUPTED);\n\t\txfs_verifier_error(bp);\n\t\tbreak;\n\t}\n}",
    "includes": [
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_buf_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_dir2_priv.h\"",
      "#include \"xfs_dir2.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_da_btree.h\"",
      "#include \"xfs_da_format.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_verifier_error",
          "args": [
            "bp"
          ],
          "line": 258
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_verifier_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_error.c",
          "lines": "161-180",
          "snippet": "void\nxfs_verifier_error(\n\tstruct xfs_buf\t\t*bp)\n{\n\tstruct xfs_mount *mp = bp->b_target->bt_mount;\n\n\txfs_alert(mp, \"Metadata %s detected at %pF, block 0x%llx\",\n\t\t  bp->b_error == -EFSBADCRC ? \"CRC error\" : \"corruption\",\n\t\t  __return_address, bp->b_bn);\n\n\txfs_alert(mp, \"Unmount and run xfs_repair\");\n\n\tif (xfs_error_level >= XFS_ERRLEVEL_LOW) {\n\t\txfs_alert(mp, \"First 64 bytes of corrupted metadata buffer:\");\n\t\txfs_hex_dump(xfs_buf_offset(bp, 0), 64);\n\t}\n\n\tif (xfs_error_level >= XFS_ERRLEVEL_HIGH)\n\t\txfs_stack_trace();\n}",
          "includes": [
            "#include \"xfs_error.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_error.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs_format.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_verifier_error(\n\tstruct xfs_buf\t\t*bp)\n{\n\tstruct xfs_mount *mp = bp->b_target->bt_mount;\n\n\txfs_alert(mp, \"Metadata %s detected at %pF, block 0x%llx\",\n\t\t  bp->b_error == -EFSBADCRC ? \"CRC error\" : \"corruption\",\n\t\t  __return_address, bp->b_bn);\n\n\txfs_alert(mp, \"Unmount and run xfs_repair\");\n\n\tif (xfs_error_level >= XFS_ERRLEVEL_LOW) {\n\t\txfs_alert(mp, \"First 64 bytes of corrupted metadata buffer:\");\n\t\txfs_hex_dump(xfs_buf_offset(bp, 0), 64);\n\t}\n\n\tif (xfs_error_level >= XFS_ERRLEVEL_HIGH)\n\t\txfs_stack_trace();\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_buf_ioerror",
          "args": [
            "bp",
            "-EFSCORRUPTED"
          ],
          "line": 257
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_buf_ioerror_alert",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_buf.c",
          "lines": "1067-1075",
          "snippet": "void\nxfs_buf_ioerror_alert(\n\tstruct xfs_buf\t\t*bp,\n\tconst char\t\t*func)\n{\n\txfs_alert(bp->b_target->bt_mount,\n\"metadata I/O error: block 0x%llx (\\\"%s\\\") error %d numblks %d\",\n\t\t(__uint64_t)XFS_BUF_ADDR(bp), func, -bp->b_error, bp->b_length);\n}",
          "includes": [
            "#include \"xfs_log.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/migrate.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hash.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/percpu.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/bio.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/init.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/gfp.h>",
            "#include <linux/errno.h>",
            "#include <linux/stddef.h>",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include <linux/freezer.h>\n#include <linux/backing-dev.h>\n#include <linux/migrate.h>\n#include <linux/kthread.h>\n#include <linux/hash.h>\n#include <linux/blkdev.h>\n#include <linux/percpu.h>\n#include <linux/workqueue.h>\n#include <linux/proc_fs.h>\n#include <linux/sysctl.h>\n#include <linux/bio.h>\n#include <linux/vmalloc.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/gfp.h>\n#include <linux/errno.h>\n#include <linux/stddef.h>\n#include \"xfs.h\"\n\nvoid\nxfs_buf_ioerror_alert(\n\tstruct xfs_buf\t\t*bp,\n\tconst char\t\t*func)\n{\n\txfs_alert(bp->b_target->bt_mount,\n\"metadata I/O error: block 0x%llx (\\\"%s\\\") error %d numblks %d\",\n\t\t(__uint64_t)XFS_BUF_ADDR(bp), func, -bp->b_error, bp->b_length);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_dir3_data_verify",
          "args": [
            "bp"
          ],
          "line": 254
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_dir3_data_verify",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_dir2_data.c",
          "lines": "212-233",
          "snippet": "static bool\nxfs_dir3_data_verify(\n\tstruct xfs_buf\t\t*bp)\n{\n\tstruct xfs_mount\t*mp = bp->b_target->bt_mount;\n\tstruct xfs_dir3_blk_hdr\t*hdr3 = bp->b_addr;\n\n\tif (xfs_sb_version_hascrc(&mp->m_sb)) {\n\t\tif (hdr3->magic != cpu_to_be32(XFS_DIR3_DATA_MAGIC))\n\t\t\treturn false;\n\t\tif (!uuid_equal(&hdr3->uuid, &mp->m_sb.sb_uuid))\n\t\t\treturn false;\n\t\tif (be64_to_cpu(hdr3->blkno) != bp->b_bn)\n\t\t\treturn false;\n\t} else {\n\t\tif (hdr3->magic != cpu_to_be32(XFS_DIR2_DATA_MAGIC))\n\t\t\treturn false;\n\t}\n\tif (__xfs_dir3_data_check(NULL, bp))\n\t\treturn false;\n\treturn true;\n}",
          "includes": [
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_dir2_priv.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_cksum.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_error.h\"\n#include \"xfs_dir2_priv.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nstatic bool\nxfs_dir3_data_verify(\n\tstruct xfs_buf\t\t*bp)\n{\n\tstruct xfs_mount\t*mp = bp->b_target->bt_mount;\n\tstruct xfs_dir3_blk_hdr\t*hdr3 = bp->b_addr;\n\n\tif (xfs_sb_version_hascrc(&mp->m_sb)) {\n\t\tif (hdr3->magic != cpu_to_be32(XFS_DIR3_DATA_MAGIC))\n\t\t\treturn false;\n\t\tif (!uuid_equal(&hdr3->uuid, &mp->m_sb.sb_uuid))\n\t\t\treturn false;\n\t\tif (be64_to_cpu(hdr3->blkno) != bp->b_bn)\n\t\t\treturn false;\n\t} else {\n\t\tif (hdr3->magic != cpu_to_be32(XFS_DIR2_DATA_MAGIC))\n\t\t\treturn false;\n\t}\n\tif (__xfs_dir3_data_check(NULL, bp))\n\t\treturn false;\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "XFS_DIR3_DATA_MAGIC"
          ],
          "line": 253
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "XFS_DIR2_DATA_MAGIC"
          ],
          "line": 252
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bp->b_ops->verify_read",
          "args": [
            "bp"
          ],
          "line": 250
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "XFS_DIR3_BLOCK_MAGIC"
          ],
          "line": 248
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "XFS_DIR2_BLOCK_MAGIC"
          ],
          "line": 247
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_cksum.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_error.h\"\n#include \"xfs_dir2_priv.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nstatic void\nxfs_dir3_data_reada_verify(\n\tstruct xfs_buf\t\t*bp)\n{\n\tstruct xfs_dir2_data_hdr *hdr = bp->b_addr;\n\n\tswitch (hdr->magic) {\n\tcase cpu_to_be32(XFS_DIR2_BLOCK_MAGIC):\n\tcase cpu_to_be32(XFS_DIR3_BLOCK_MAGIC):\n\t\tbp->b_ops = &xfs_dir3_block_buf_ops;\n\t\tbp->b_ops->verify_read(bp);\n\t\treturn;\n\tcase cpu_to_be32(XFS_DIR2_DATA_MAGIC):\n\tcase cpu_to_be32(XFS_DIR3_DATA_MAGIC):\n\t\txfs_dir3_data_verify(bp);\n\t\treturn;\n\tdefault:\n\t\txfs_buf_ioerror(bp, -EFSCORRUPTED);\n\t\txfs_verifier_error(bp);\n\t\tbreak;\n\t}\n}"
  },
  {
    "function_name": "xfs_dir3_data_verify",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_dir2_data.c",
    "lines": "212-233",
    "snippet": "static bool\nxfs_dir3_data_verify(\n\tstruct xfs_buf\t\t*bp)\n{\n\tstruct xfs_mount\t*mp = bp->b_target->bt_mount;\n\tstruct xfs_dir3_blk_hdr\t*hdr3 = bp->b_addr;\n\n\tif (xfs_sb_version_hascrc(&mp->m_sb)) {\n\t\tif (hdr3->magic != cpu_to_be32(XFS_DIR3_DATA_MAGIC))\n\t\t\treturn false;\n\t\tif (!uuid_equal(&hdr3->uuid, &mp->m_sb.sb_uuid))\n\t\t\treturn false;\n\t\tif (be64_to_cpu(hdr3->blkno) != bp->b_bn)\n\t\t\treturn false;\n\t} else {\n\t\tif (hdr3->magic != cpu_to_be32(XFS_DIR2_DATA_MAGIC))\n\t\t\treturn false;\n\t}\n\tif (__xfs_dir3_data_check(NULL, bp))\n\t\treturn false;\n\treturn true;\n}",
    "includes": [
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_buf_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_dir2_priv.h\"",
      "#include \"xfs_dir2.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_da_btree.h\"",
      "#include \"xfs_da_format.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__xfs_dir3_data_check",
          "args": [
            "NULL",
            "bp"
          ],
          "line": 230
        },
        "resolved": true,
        "details": {
          "function_name": "__xfs_dir3_data_check",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_dir2_data.c",
          "lines": "40-210",
          "snippet": "int\n__xfs_dir3_data_check(\n\tstruct xfs_inode\t*dp,\t\t/* incore inode pointer */\n\tstruct xfs_buf\t\t*bp)\t\t/* data block's buffer */\n{\n\txfs_dir2_dataptr_t\taddr;\t\t/* addr for leaf lookup */\n\txfs_dir2_data_free_t\t*bf;\t\t/* bestfree table */\n\txfs_dir2_block_tail_t\t*btp=NULL;\t/* block tail */\n\tint\t\t\tcount;\t\t/* count of entries found */\n\txfs_dir2_data_hdr_t\t*hdr;\t\t/* data block header */\n\txfs_dir2_data_entry_t\t*dep;\t\t/* data entry */\n\txfs_dir2_data_free_t\t*dfp;\t\t/* bestfree entry */\n\txfs_dir2_data_unused_t\t*dup;\t\t/* unused entry */\n\tchar\t\t\t*endp;\t\t/* end of useful data */\n\tint\t\t\tfreeseen;\t/* mask of bestfrees seen */\n\txfs_dahash_t\t\thash;\t\t/* hash of current name */\n\tint\t\t\ti;\t\t/* leaf index */\n\tint\t\t\tlastfree;\t/* last entry was unused */\n\txfs_dir2_leaf_entry_t\t*lep=NULL;\t/* block leaf entries */\n\txfs_mount_t\t\t*mp;\t\t/* filesystem mount point */\n\tchar\t\t\t*p;\t\t/* current data position */\n\tint\t\t\tstale;\t\t/* count of stale leaves */\n\tstruct xfs_name\t\tname;\n\tconst struct xfs_dir_ops *ops;\n\tstruct xfs_da_geometry\t*geo;\n\n\tmp = bp->b_target->bt_mount;\n\tgeo = mp->m_dir_geo;\n\n\t/*\n\t * We can be passed a null dp here from a verifier, so we need to go the\n\t * hard way to get them.\n\t */\n\tops = xfs_dir_get_ops(mp, dp);\n\n\thdr = bp->b_addr;\n\tp = (char *)ops->data_entry_p(hdr);\n\n\tswitch (hdr->magic) {\n\tcase cpu_to_be32(XFS_DIR3_BLOCK_MAGIC):\n\tcase cpu_to_be32(XFS_DIR2_BLOCK_MAGIC):\n\t\tbtp = xfs_dir2_block_tail_p(geo, hdr);\n\t\tlep = xfs_dir2_block_leaf_p(btp);\n\t\tendp = (char *)lep;\n\n\t\t/*\n\t\t * The number of leaf entries is limited by the size of the\n\t\t * block and the amount of space used by the data entries.\n\t\t * We don't know how much space is used by the data entries yet,\n\t\t * so just ensure that the count falls somewhere inside the\n\t\t * block right now.\n\t\t */\n\t\tXFS_WANT_CORRUPTED_RETURN(be32_to_cpu(btp->count) <\n\t\t\t((char *)btp - p) / sizeof(struct xfs_dir2_leaf_entry));\n\t\tbreak;\n\tcase cpu_to_be32(XFS_DIR3_DATA_MAGIC):\n\tcase cpu_to_be32(XFS_DIR2_DATA_MAGIC):\n\t\tendp = (char *)hdr + geo->blksize;\n\t\tbreak;\n\tdefault:\n\t\tXFS_ERROR_REPORT(\"Bad Magic\", XFS_ERRLEVEL_LOW, mp);\n\t\treturn -EFSCORRUPTED;\n\t}\n\n\t/*\n\t * Account for zero bestfree entries.\n\t */\n\tbf = ops->data_bestfree_p(hdr);\n\tcount = lastfree = freeseen = 0;\n\tif (!bf[0].length) {\n\t\tXFS_WANT_CORRUPTED_RETURN(!bf[0].offset);\n\t\tfreeseen |= 1 << 0;\n\t}\n\tif (!bf[1].length) {\n\t\tXFS_WANT_CORRUPTED_RETURN(!bf[1].offset);\n\t\tfreeseen |= 1 << 1;\n\t}\n\tif (!bf[2].length) {\n\t\tXFS_WANT_CORRUPTED_RETURN(!bf[2].offset);\n\t\tfreeseen |= 1 << 2;\n\t}\n\n\tXFS_WANT_CORRUPTED_RETURN(be16_to_cpu(bf[0].length) >=\n\t\t\t\t\t\tbe16_to_cpu(bf[1].length));\n\tXFS_WANT_CORRUPTED_RETURN(be16_to_cpu(bf[1].length) >=\n\t\t\t\t\t\tbe16_to_cpu(bf[2].length));\n\t/*\n\t * Loop over the data/unused entries.\n\t */\n\twhile (p < endp) {\n\t\tdup = (xfs_dir2_data_unused_t *)p;\n\t\t/*\n\t\t * If it's unused, look for the space in the bestfree table.\n\t\t * If we find it, account for that, else make sure it\n\t\t * doesn't need to be there.\n\t\t */\n\t\tif (be16_to_cpu(dup->freetag) == XFS_DIR2_DATA_FREE_TAG) {\n\t\t\tXFS_WANT_CORRUPTED_RETURN(lastfree == 0);\n\t\t\tXFS_WANT_CORRUPTED_RETURN(\n\t\t\t\tbe16_to_cpu(*xfs_dir2_data_unused_tag_p(dup)) ==\n\t\t\t\t\t       (char *)dup - (char *)hdr);\n\t\t\tdfp = xfs_dir2_data_freefind(hdr, bf, dup);\n\t\t\tif (dfp) {\n\t\t\t\ti = (int)(dfp - bf);\n\t\t\t\tXFS_WANT_CORRUPTED_RETURN(\n\t\t\t\t\t(freeseen & (1 << i)) == 0);\n\t\t\t\tfreeseen |= 1 << i;\n\t\t\t} else {\n\t\t\t\tXFS_WANT_CORRUPTED_RETURN(\n\t\t\t\t\tbe16_to_cpu(dup->length) <=\n\t\t\t\t\t\tbe16_to_cpu(bf[2].length));\n\t\t\t}\n\t\t\tp += be16_to_cpu(dup->length);\n\t\t\tlastfree = 1;\n\t\t\tcontinue;\n\t\t}\n\t\t/*\n\t\t * It's a real entry.  Validate the fields.\n\t\t * If this is a block directory then make sure it's\n\t\t * in the leaf section of the block.\n\t\t * The linear search is crude but this is DEBUG code.\n\t\t */\n\t\tdep = (xfs_dir2_data_entry_t *)p;\n\t\tXFS_WANT_CORRUPTED_RETURN(dep->namelen != 0);\n\t\tXFS_WANT_CORRUPTED_RETURN(\n\t\t\t!xfs_dir_ino_validate(mp, be64_to_cpu(dep->inumber)));\n\t\tXFS_WANT_CORRUPTED_RETURN(\n\t\t\tbe16_to_cpu(*ops->data_entry_tag_p(dep)) ==\n\t\t\t\t\t       (char *)dep - (char *)hdr);\n\t\tXFS_WANT_CORRUPTED_RETURN(\n\t\t\t\tops->data_get_ftype(dep) < XFS_DIR3_FT_MAX);\n\t\tcount++;\n\t\tlastfree = 0;\n\t\tif (hdr->magic == cpu_to_be32(XFS_DIR2_BLOCK_MAGIC) ||\n\t\t    hdr->magic == cpu_to_be32(XFS_DIR3_BLOCK_MAGIC)) {\n\t\t\taddr = xfs_dir2_db_off_to_dataptr(geo, geo->datablk,\n\t\t\t\t\t\t(xfs_dir2_data_aoff_t)\n\t\t\t\t\t\t((char *)dep - (char *)hdr));\n\t\t\tname.name = dep->name;\n\t\t\tname.len = dep->namelen;\n\t\t\thash = mp->m_dirnameops->hashname(&name);\n\t\t\tfor (i = 0; i < be32_to_cpu(btp->count); i++) {\n\t\t\t\tif (be32_to_cpu(lep[i].address) == addr &&\n\t\t\t\t    be32_to_cpu(lep[i].hashval) == hash)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tXFS_WANT_CORRUPTED_RETURN(i < be32_to_cpu(btp->count));\n\t\t}\n\t\tp += ops->data_entsize(dep->namelen);\n\t}\n\t/*\n\t * Need to have seen all the entries and all the bestfree slots.\n\t */\n\tXFS_WANT_CORRUPTED_RETURN(freeseen == 7);\n\tif (hdr->magic == cpu_to_be32(XFS_DIR2_BLOCK_MAGIC) ||\n\t    hdr->magic == cpu_to_be32(XFS_DIR3_BLOCK_MAGIC)) {\n\t\tfor (i = stale = 0; i < be32_to_cpu(btp->count); i++) {\n\t\t\tif (lep[i].address ==\n\t\t\t    cpu_to_be32(XFS_DIR2_NULL_DATAPTR))\n\t\t\t\tstale++;\n\t\t\tif (i > 0)\n\t\t\t\tXFS_WANT_CORRUPTED_RETURN(\n\t\t\t\t\tbe32_to_cpu(lep[i].hashval) >=\n\t\t\t\t\t\tbe32_to_cpu(lep[i - 1].hashval));\n\t\t}\n\t\tXFS_WANT_CORRUPTED_RETURN(count ==\n\t\t\tbe32_to_cpu(btp->count) - be32_to_cpu(btp->stale));\n\t\tXFS_WANT_CORRUPTED_RETURN(stale == be32_to_cpu(btp->stale));\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_dir2_priv.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_cksum.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_error.h\"\n#include \"xfs_dir2_priv.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\n__xfs_dir3_data_check(\n\tstruct xfs_inode\t*dp,\t\t/* incore inode pointer */\n\tstruct xfs_buf\t\t*bp)\t\t/* data block's buffer */\n{\n\txfs_dir2_dataptr_t\taddr;\t\t/* addr for leaf lookup */\n\txfs_dir2_data_free_t\t*bf;\t\t/* bestfree table */\n\txfs_dir2_block_tail_t\t*btp=NULL;\t/* block tail */\n\tint\t\t\tcount;\t\t/* count of entries found */\n\txfs_dir2_data_hdr_t\t*hdr;\t\t/* data block header */\n\txfs_dir2_data_entry_t\t*dep;\t\t/* data entry */\n\txfs_dir2_data_free_t\t*dfp;\t\t/* bestfree entry */\n\txfs_dir2_data_unused_t\t*dup;\t\t/* unused entry */\n\tchar\t\t\t*endp;\t\t/* end of useful data */\n\tint\t\t\tfreeseen;\t/* mask of bestfrees seen */\n\txfs_dahash_t\t\thash;\t\t/* hash of current name */\n\tint\t\t\ti;\t\t/* leaf index */\n\tint\t\t\tlastfree;\t/* last entry was unused */\n\txfs_dir2_leaf_entry_t\t*lep=NULL;\t/* block leaf entries */\n\txfs_mount_t\t\t*mp;\t\t/* filesystem mount point */\n\tchar\t\t\t*p;\t\t/* current data position */\n\tint\t\t\tstale;\t\t/* count of stale leaves */\n\tstruct xfs_name\t\tname;\n\tconst struct xfs_dir_ops *ops;\n\tstruct xfs_da_geometry\t*geo;\n\n\tmp = bp->b_target->bt_mount;\n\tgeo = mp->m_dir_geo;\n\n\t/*\n\t * We can be passed a null dp here from a verifier, so we need to go the\n\t * hard way to get them.\n\t */\n\tops = xfs_dir_get_ops(mp, dp);\n\n\thdr = bp->b_addr;\n\tp = (char *)ops->data_entry_p(hdr);\n\n\tswitch (hdr->magic) {\n\tcase cpu_to_be32(XFS_DIR3_BLOCK_MAGIC):\n\tcase cpu_to_be32(XFS_DIR2_BLOCK_MAGIC):\n\t\tbtp = xfs_dir2_block_tail_p(geo, hdr);\n\t\tlep = xfs_dir2_block_leaf_p(btp);\n\t\tendp = (char *)lep;\n\n\t\t/*\n\t\t * The number of leaf entries is limited by the size of the\n\t\t * block and the amount of space used by the data entries.\n\t\t * We don't know how much space is used by the data entries yet,\n\t\t * so just ensure that the count falls somewhere inside the\n\t\t * block right now.\n\t\t */\n\t\tXFS_WANT_CORRUPTED_RETURN(be32_to_cpu(btp->count) <\n\t\t\t((char *)btp - p) / sizeof(struct xfs_dir2_leaf_entry));\n\t\tbreak;\n\tcase cpu_to_be32(XFS_DIR3_DATA_MAGIC):\n\tcase cpu_to_be32(XFS_DIR2_DATA_MAGIC):\n\t\tendp = (char *)hdr + geo->blksize;\n\t\tbreak;\n\tdefault:\n\t\tXFS_ERROR_REPORT(\"Bad Magic\", XFS_ERRLEVEL_LOW, mp);\n\t\treturn -EFSCORRUPTED;\n\t}\n\n\t/*\n\t * Account for zero bestfree entries.\n\t */\n\tbf = ops->data_bestfree_p(hdr);\n\tcount = lastfree = freeseen = 0;\n\tif (!bf[0].length) {\n\t\tXFS_WANT_CORRUPTED_RETURN(!bf[0].offset);\n\t\tfreeseen |= 1 << 0;\n\t}\n\tif (!bf[1].length) {\n\t\tXFS_WANT_CORRUPTED_RETURN(!bf[1].offset);\n\t\tfreeseen |= 1 << 1;\n\t}\n\tif (!bf[2].length) {\n\t\tXFS_WANT_CORRUPTED_RETURN(!bf[2].offset);\n\t\tfreeseen |= 1 << 2;\n\t}\n\n\tXFS_WANT_CORRUPTED_RETURN(be16_to_cpu(bf[0].length) >=\n\t\t\t\t\t\tbe16_to_cpu(bf[1].length));\n\tXFS_WANT_CORRUPTED_RETURN(be16_to_cpu(bf[1].length) >=\n\t\t\t\t\t\tbe16_to_cpu(bf[2].length));\n\t/*\n\t * Loop over the data/unused entries.\n\t */\n\twhile (p < endp) {\n\t\tdup = (xfs_dir2_data_unused_t *)p;\n\t\t/*\n\t\t * If it's unused, look for the space in the bestfree table.\n\t\t * If we find it, account for that, else make sure it\n\t\t * doesn't need to be there.\n\t\t */\n\t\tif (be16_to_cpu(dup->freetag) == XFS_DIR2_DATA_FREE_TAG) {\n\t\t\tXFS_WANT_CORRUPTED_RETURN(lastfree == 0);\n\t\t\tXFS_WANT_CORRUPTED_RETURN(\n\t\t\t\tbe16_to_cpu(*xfs_dir2_data_unused_tag_p(dup)) ==\n\t\t\t\t\t       (char *)dup - (char *)hdr);\n\t\t\tdfp = xfs_dir2_data_freefind(hdr, bf, dup);\n\t\t\tif (dfp) {\n\t\t\t\ti = (int)(dfp - bf);\n\t\t\t\tXFS_WANT_CORRUPTED_RETURN(\n\t\t\t\t\t(freeseen & (1 << i)) == 0);\n\t\t\t\tfreeseen |= 1 << i;\n\t\t\t} else {\n\t\t\t\tXFS_WANT_CORRUPTED_RETURN(\n\t\t\t\t\tbe16_to_cpu(dup->length) <=\n\t\t\t\t\t\tbe16_to_cpu(bf[2].length));\n\t\t\t}\n\t\t\tp += be16_to_cpu(dup->length);\n\t\t\tlastfree = 1;\n\t\t\tcontinue;\n\t\t}\n\t\t/*\n\t\t * It's a real entry.  Validate the fields.\n\t\t * If this is a block directory then make sure it's\n\t\t * in the leaf section of the block.\n\t\t * The linear search is crude but this is DEBUG code.\n\t\t */\n\t\tdep = (xfs_dir2_data_entry_t *)p;\n\t\tXFS_WANT_CORRUPTED_RETURN(dep->namelen != 0);\n\t\tXFS_WANT_CORRUPTED_RETURN(\n\t\t\t!xfs_dir_ino_validate(mp, be64_to_cpu(dep->inumber)));\n\t\tXFS_WANT_CORRUPTED_RETURN(\n\t\t\tbe16_to_cpu(*ops->data_entry_tag_p(dep)) ==\n\t\t\t\t\t       (char *)dep - (char *)hdr);\n\t\tXFS_WANT_CORRUPTED_RETURN(\n\t\t\t\tops->data_get_ftype(dep) < XFS_DIR3_FT_MAX);\n\t\tcount++;\n\t\tlastfree = 0;\n\t\tif (hdr->magic == cpu_to_be32(XFS_DIR2_BLOCK_MAGIC) ||\n\t\t    hdr->magic == cpu_to_be32(XFS_DIR3_BLOCK_MAGIC)) {\n\t\t\taddr = xfs_dir2_db_off_to_dataptr(geo, geo->datablk,\n\t\t\t\t\t\t(xfs_dir2_data_aoff_t)\n\t\t\t\t\t\t((char *)dep - (char *)hdr));\n\t\t\tname.name = dep->name;\n\t\t\tname.len = dep->namelen;\n\t\t\thash = mp->m_dirnameops->hashname(&name);\n\t\t\tfor (i = 0; i < be32_to_cpu(btp->count); i++) {\n\t\t\t\tif (be32_to_cpu(lep[i].address) == addr &&\n\t\t\t\t    be32_to_cpu(lep[i].hashval) == hash)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tXFS_WANT_CORRUPTED_RETURN(i < be32_to_cpu(btp->count));\n\t\t}\n\t\tp += ops->data_entsize(dep->namelen);\n\t}\n\t/*\n\t * Need to have seen all the entries and all the bestfree slots.\n\t */\n\tXFS_WANT_CORRUPTED_RETURN(freeseen == 7);\n\tif (hdr->magic == cpu_to_be32(XFS_DIR2_BLOCK_MAGIC) ||\n\t    hdr->magic == cpu_to_be32(XFS_DIR3_BLOCK_MAGIC)) {\n\t\tfor (i = stale = 0; i < be32_to_cpu(btp->count); i++) {\n\t\t\tif (lep[i].address ==\n\t\t\t    cpu_to_be32(XFS_DIR2_NULL_DATAPTR))\n\t\t\t\tstale++;\n\t\t\tif (i > 0)\n\t\t\t\tXFS_WANT_CORRUPTED_RETURN(\n\t\t\t\t\tbe32_to_cpu(lep[i].hashval) >=\n\t\t\t\t\t\tbe32_to_cpu(lep[i - 1].hashval));\n\t\t}\n\t\tXFS_WANT_CORRUPTED_RETURN(count ==\n\t\t\tbe32_to_cpu(btp->count) - be32_to_cpu(btp->stale));\n\t\tXFS_WANT_CORRUPTED_RETURN(stale == be32_to_cpu(btp->stale));\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "XFS_DIR2_DATA_MAGIC"
          ],
          "line": 227
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be64_to_cpu",
          "args": [
            "hdr3->blkno"
          ],
          "line": 224
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "uuid_equal",
          "args": [
            "&hdr3->uuid",
            "&mp->m_sb.sb_uuid"
          ],
          "line": 222
        },
        "resolved": true,
        "details": {
          "function_name": "uuid_equal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/uuid.c",
          "lines": "59-63",
          "snippet": "int\nuuid_equal(uuid_t *uuid1, uuid_t *uuid2)\n{\n\treturn memcmp(uuid1, uuid2, sizeof(uuid_t)) ? 0 : 1;\n}",
          "includes": [
            "#include <xfs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <xfs.h>\n\nint\nuuid_equal(uuid_t *uuid1, uuid_t *uuid2)\n{\n\treturn memcmp(uuid1, uuid2, sizeof(uuid_t)) ? 0 : 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "XFS_DIR3_DATA_MAGIC"
          ],
          "line": 220
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_sb_version_hascrc",
          "args": [
            "&mp->m_sb"
          ],
          "line": 219
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_sb_version_hascrc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_format.h",
          "lines": "547-550",
          "snippet": "static inline int xfs_sb_version_hascrc(struct xfs_sb *sbp)\n{\n\treturn XFS_SB_VERSION_NUM(sbp) == XFS_SB_VERSION_5;\n}",
          "includes": [],
          "macros_used": [
            "#define\tXFS_SB_VERSION_5\t5\t\t/* CRC enabled filesystem */"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#define\tXFS_SB_VERSION_5\t5\t\t/* CRC enabled filesystem */\n\nstatic inline int xfs_sb_version_hascrc(struct xfs_sb *sbp)\n{\n\treturn XFS_SB_VERSION_NUM(sbp) == XFS_SB_VERSION_5;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xfs_cksum.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_error.h\"\n#include \"xfs_dir2_priv.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nstatic bool\nxfs_dir3_data_verify(\n\tstruct xfs_buf\t\t*bp)\n{\n\tstruct xfs_mount\t*mp = bp->b_target->bt_mount;\n\tstruct xfs_dir3_blk_hdr\t*hdr3 = bp->b_addr;\n\n\tif (xfs_sb_version_hascrc(&mp->m_sb)) {\n\t\tif (hdr3->magic != cpu_to_be32(XFS_DIR3_DATA_MAGIC))\n\t\t\treturn false;\n\t\tif (!uuid_equal(&hdr3->uuid, &mp->m_sb.sb_uuid))\n\t\t\treturn false;\n\t\tif (be64_to_cpu(hdr3->blkno) != bp->b_bn)\n\t\t\treturn false;\n\t} else {\n\t\tif (hdr3->magic != cpu_to_be32(XFS_DIR2_DATA_MAGIC))\n\t\t\treturn false;\n\t}\n\tif (__xfs_dir3_data_check(NULL, bp))\n\t\treturn false;\n\treturn true;\n}"
  },
  {
    "function_name": "__xfs_dir3_data_check",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_dir2_data.c",
    "lines": "40-210",
    "snippet": "int\n__xfs_dir3_data_check(\n\tstruct xfs_inode\t*dp,\t\t/* incore inode pointer */\n\tstruct xfs_buf\t\t*bp)\t\t/* data block's buffer */\n{\n\txfs_dir2_dataptr_t\taddr;\t\t/* addr for leaf lookup */\n\txfs_dir2_data_free_t\t*bf;\t\t/* bestfree table */\n\txfs_dir2_block_tail_t\t*btp=NULL;\t/* block tail */\n\tint\t\t\tcount;\t\t/* count of entries found */\n\txfs_dir2_data_hdr_t\t*hdr;\t\t/* data block header */\n\txfs_dir2_data_entry_t\t*dep;\t\t/* data entry */\n\txfs_dir2_data_free_t\t*dfp;\t\t/* bestfree entry */\n\txfs_dir2_data_unused_t\t*dup;\t\t/* unused entry */\n\tchar\t\t\t*endp;\t\t/* end of useful data */\n\tint\t\t\tfreeseen;\t/* mask of bestfrees seen */\n\txfs_dahash_t\t\thash;\t\t/* hash of current name */\n\tint\t\t\ti;\t\t/* leaf index */\n\tint\t\t\tlastfree;\t/* last entry was unused */\n\txfs_dir2_leaf_entry_t\t*lep=NULL;\t/* block leaf entries */\n\txfs_mount_t\t\t*mp;\t\t/* filesystem mount point */\n\tchar\t\t\t*p;\t\t/* current data position */\n\tint\t\t\tstale;\t\t/* count of stale leaves */\n\tstruct xfs_name\t\tname;\n\tconst struct xfs_dir_ops *ops;\n\tstruct xfs_da_geometry\t*geo;\n\n\tmp = bp->b_target->bt_mount;\n\tgeo = mp->m_dir_geo;\n\n\t/*\n\t * We can be passed a null dp here from a verifier, so we need to go the\n\t * hard way to get them.\n\t */\n\tops = xfs_dir_get_ops(mp, dp);\n\n\thdr = bp->b_addr;\n\tp = (char *)ops->data_entry_p(hdr);\n\n\tswitch (hdr->magic) {\n\tcase cpu_to_be32(XFS_DIR3_BLOCK_MAGIC):\n\tcase cpu_to_be32(XFS_DIR2_BLOCK_MAGIC):\n\t\tbtp = xfs_dir2_block_tail_p(geo, hdr);\n\t\tlep = xfs_dir2_block_leaf_p(btp);\n\t\tendp = (char *)lep;\n\n\t\t/*\n\t\t * The number of leaf entries is limited by the size of the\n\t\t * block and the amount of space used by the data entries.\n\t\t * We don't know how much space is used by the data entries yet,\n\t\t * so just ensure that the count falls somewhere inside the\n\t\t * block right now.\n\t\t */\n\t\tXFS_WANT_CORRUPTED_RETURN(be32_to_cpu(btp->count) <\n\t\t\t((char *)btp - p) / sizeof(struct xfs_dir2_leaf_entry));\n\t\tbreak;\n\tcase cpu_to_be32(XFS_DIR3_DATA_MAGIC):\n\tcase cpu_to_be32(XFS_DIR2_DATA_MAGIC):\n\t\tendp = (char *)hdr + geo->blksize;\n\t\tbreak;\n\tdefault:\n\t\tXFS_ERROR_REPORT(\"Bad Magic\", XFS_ERRLEVEL_LOW, mp);\n\t\treturn -EFSCORRUPTED;\n\t}\n\n\t/*\n\t * Account for zero bestfree entries.\n\t */\n\tbf = ops->data_bestfree_p(hdr);\n\tcount = lastfree = freeseen = 0;\n\tif (!bf[0].length) {\n\t\tXFS_WANT_CORRUPTED_RETURN(!bf[0].offset);\n\t\tfreeseen |= 1 << 0;\n\t}\n\tif (!bf[1].length) {\n\t\tXFS_WANT_CORRUPTED_RETURN(!bf[1].offset);\n\t\tfreeseen |= 1 << 1;\n\t}\n\tif (!bf[2].length) {\n\t\tXFS_WANT_CORRUPTED_RETURN(!bf[2].offset);\n\t\tfreeseen |= 1 << 2;\n\t}\n\n\tXFS_WANT_CORRUPTED_RETURN(be16_to_cpu(bf[0].length) >=\n\t\t\t\t\t\tbe16_to_cpu(bf[1].length));\n\tXFS_WANT_CORRUPTED_RETURN(be16_to_cpu(bf[1].length) >=\n\t\t\t\t\t\tbe16_to_cpu(bf[2].length));\n\t/*\n\t * Loop over the data/unused entries.\n\t */\n\twhile (p < endp) {\n\t\tdup = (xfs_dir2_data_unused_t *)p;\n\t\t/*\n\t\t * If it's unused, look for the space in the bestfree table.\n\t\t * If we find it, account for that, else make sure it\n\t\t * doesn't need to be there.\n\t\t */\n\t\tif (be16_to_cpu(dup->freetag) == XFS_DIR2_DATA_FREE_TAG) {\n\t\t\tXFS_WANT_CORRUPTED_RETURN(lastfree == 0);\n\t\t\tXFS_WANT_CORRUPTED_RETURN(\n\t\t\t\tbe16_to_cpu(*xfs_dir2_data_unused_tag_p(dup)) ==\n\t\t\t\t\t       (char *)dup - (char *)hdr);\n\t\t\tdfp = xfs_dir2_data_freefind(hdr, bf, dup);\n\t\t\tif (dfp) {\n\t\t\t\ti = (int)(dfp - bf);\n\t\t\t\tXFS_WANT_CORRUPTED_RETURN(\n\t\t\t\t\t(freeseen & (1 << i)) == 0);\n\t\t\t\tfreeseen |= 1 << i;\n\t\t\t} else {\n\t\t\t\tXFS_WANT_CORRUPTED_RETURN(\n\t\t\t\t\tbe16_to_cpu(dup->length) <=\n\t\t\t\t\t\tbe16_to_cpu(bf[2].length));\n\t\t\t}\n\t\t\tp += be16_to_cpu(dup->length);\n\t\t\tlastfree = 1;\n\t\t\tcontinue;\n\t\t}\n\t\t/*\n\t\t * It's a real entry.  Validate the fields.\n\t\t * If this is a block directory then make sure it's\n\t\t * in the leaf section of the block.\n\t\t * The linear search is crude but this is DEBUG code.\n\t\t */\n\t\tdep = (xfs_dir2_data_entry_t *)p;\n\t\tXFS_WANT_CORRUPTED_RETURN(dep->namelen != 0);\n\t\tXFS_WANT_CORRUPTED_RETURN(\n\t\t\t!xfs_dir_ino_validate(mp, be64_to_cpu(dep->inumber)));\n\t\tXFS_WANT_CORRUPTED_RETURN(\n\t\t\tbe16_to_cpu(*ops->data_entry_tag_p(dep)) ==\n\t\t\t\t\t       (char *)dep - (char *)hdr);\n\t\tXFS_WANT_CORRUPTED_RETURN(\n\t\t\t\tops->data_get_ftype(dep) < XFS_DIR3_FT_MAX);\n\t\tcount++;\n\t\tlastfree = 0;\n\t\tif (hdr->magic == cpu_to_be32(XFS_DIR2_BLOCK_MAGIC) ||\n\t\t    hdr->magic == cpu_to_be32(XFS_DIR3_BLOCK_MAGIC)) {\n\t\t\taddr = xfs_dir2_db_off_to_dataptr(geo, geo->datablk,\n\t\t\t\t\t\t(xfs_dir2_data_aoff_t)\n\t\t\t\t\t\t((char *)dep - (char *)hdr));\n\t\t\tname.name = dep->name;\n\t\t\tname.len = dep->namelen;\n\t\t\thash = mp->m_dirnameops->hashname(&name);\n\t\t\tfor (i = 0; i < be32_to_cpu(btp->count); i++) {\n\t\t\t\tif (be32_to_cpu(lep[i].address) == addr &&\n\t\t\t\t    be32_to_cpu(lep[i].hashval) == hash)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tXFS_WANT_CORRUPTED_RETURN(i < be32_to_cpu(btp->count));\n\t\t}\n\t\tp += ops->data_entsize(dep->namelen);\n\t}\n\t/*\n\t * Need to have seen all the entries and all the bestfree slots.\n\t */\n\tXFS_WANT_CORRUPTED_RETURN(freeseen == 7);\n\tif (hdr->magic == cpu_to_be32(XFS_DIR2_BLOCK_MAGIC) ||\n\t    hdr->magic == cpu_to_be32(XFS_DIR3_BLOCK_MAGIC)) {\n\t\tfor (i = stale = 0; i < be32_to_cpu(btp->count); i++) {\n\t\t\tif (lep[i].address ==\n\t\t\t    cpu_to_be32(XFS_DIR2_NULL_DATAPTR))\n\t\t\t\tstale++;\n\t\t\tif (i > 0)\n\t\t\t\tXFS_WANT_CORRUPTED_RETURN(\n\t\t\t\t\tbe32_to_cpu(lep[i].hashval) >=\n\t\t\t\t\t\tbe32_to_cpu(lep[i - 1].hashval));\n\t\t}\n\t\tXFS_WANT_CORRUPTED_RETURN(count ==\n\t\t\tbe32_to_cpu(btp->count) - be32_to_cpu(btp->stale));\n\t\tXFS_WANT_CORRUPTED_RETURN(stale == be32_to_cpu(btp->stale));\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_buf_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_dir2_priv.h\"",
      "#include \"xfs_dir2.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_da_btree.h\"",
      "#include \"xfs_da_format.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "XFS_WANT_CORRUPTED_RETURN",
          "args": [
            "stale == be32_to_cpu(btp->stale)"
          ],
          "line": 207
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "btp->stale"
          ],
          "line": 207
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_WANT_CORRUPTED_RETURN",
          "args": [
            "count ==\n\t\t\tbe32_to_cpu(btp->count) - be32_to_cpu(btp->stale)"
          ],
          "line": 205
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "btp->stale"
          ],
          "line": 206
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "btp->count"
          ],
          "line": 206
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_WANT_CORRUPTED_RETURN",
          "args": [
            "be32_to_cpu(lep[i].hashval) >=\n\t\t\t\t\t\tbe32_to_cpu(lep[i - 1].hashval)"
          ],
          "line": 201
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "lep[i - 1].hashval"
          ],
          "line": 203
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "lep[i].hashval"
          ],
          "line": 202
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "XFS_DIR2_NULL_DATAPTR"
          ],
          "line": 198
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "btp->count"
          ],
          "line": 196
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "XFS_DIR3_BLOCK_MAGIC"
          ],
          "line": 195
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "XFS_DIR2_BLOCK_MAGIC"
          ],
          "line": 194
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_WANT_CORRUPTED_RETURN",
          "args": [
            "freeseen == 7"
          ],
          "line": 193
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ops->data_entsize",
          "args": [
            "dep->namelen"
          ],
          "line": 188
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_WANT_CORRUPTED_RETURN",
          "args": [
            "i < be32_to_cpu(btp->count)"
          ],
          "line": 186
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "btp->count"
          ],
          "line": 186
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "lep[i].hashval"
          ],
          "line": 183
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "lep[i].address"
          ],
          "line": 182
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "btp->count"
          ],
          "line": 181
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mp->m_dirnameops->hashname",
          "args": [
            "&name"
          ],
          "line": 180
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_dir2_db_off_to_dataptr",
          "args": [
            "geo",
            "geo->datablk",
            "(xfs_dir2_data_aoff_t)\n\t\t\t\t\t\t((char *)dep - (char *)hdr)"
          ],
          "line": 175
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_dir2_db_off_to_dataptr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_dir2.h",
          "lines": "277-282",
          "snippet": "static inline xfs_dir2_dataptr_t\nxfs_dir2_db_off_to_dataptr(struct xfs_da_geometry *geo, xfs_dir2_db_t db,\n\t\t\t   xfs_dir2_data_aoff_t o)\n{\n\treturn xfs_dir2_byte_to_dataptr(xfs_dir2_db_off_to_byte(geo, db, o));\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline xfs_dir2_dataptr_t\nxfs_dir2_db_off_to_dataptr(struct xfs_da_geometry *geo, xfs_dir2_db_t db,\n\t\t\t   xfs_dir2_data_aoff_t o)\n{\n\treturn xfs_dir2_byte_to_dataptr(xfs_dir2_db_off_to_byte(geo, db, o));\n}"
        }
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "(char *)dep - (char *)hdr"
          ],
          "line": 176
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "XFS_DIR3_BLOCK_MAGIC"
          ],
          "line": 174
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "XFS_DIR2_BLOCK_MAGIC"
          ],
          "line": 173
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_WANT_CORRUPTED_RETURN",
          "args": [
            "ops->data_get_ftype(dep) < XFS_DIR3_FT_MAX"
          ],
          "line": 169
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ops->data_get_ftype",
          "args": [
            "dep"
          ],
          "line": 170
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_WANT_CORRUPTED_RETURN",
          "args": [
            "be16_to_cpu(*ops->data_entry_tag_p(dep)) ==\n\t\t\t\t\t       (char *)dep - (char *)hdr"
          ],
          "line": 166
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be16_to_cpu",
          "args": [
            "*ops->data_entry_tag_p(dep)"
          ],
          "line": 167
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ops->data_entry_tag_p",
          "args": [
            "dep"
          ],
          "line": 167
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_WANT_CORRUPTED_RETURN",
          "args": [
            "!xfs_dir_ino_validate(mp, be64_to_cpu(dep->inumber))"
          ],
          "line": 164
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_dir_ino_validate",
          "args": [
            "mp",
            "be64_to_cpu(dep->inumber)"
          ],
          "line": 165
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_dir_ino_validate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_dir2.c",
          "lines": "191-220",
          "snippet": "int\nxfs_dir_ino_validate(\n\txfs_mount_t\t*mp,\n\txfs_ino_t\tino)\n{\n\txfs_agblock_t\tagblkno;\n\txfs_agino_t\tagino;\n\txfs_agnumber_t\tagno;\n\tint\t\tino_ok;\n\tint\t\tioff;\n\n\tagno = XFS_INO_TO_AGNO(mp, ino);\n\tagblkno = XFS_INO_TO_AGBNO(mp, ino);\n\tioff = XFS_INO_TO_OFFSET(mp, ino);\n\tagino = XFS_OFFBNO_TO_AGINO(mp, agblkno, ioff);\n\tino_ok =\n\t\tagno < mp->m_sb.sb_agcount &&\n\t\tagblkno < mp->m_sb.sb_agblocks &&\n\t\tagblkno != 0 &&\n\t\tioff < (1 << mp->m_sb.sb_inopblog) &&\n\t\tXFS_AGINO_TO_INO(mp, agno, agino) == ino;\n\tif (unlikely(XFS_TEST_ERROR(!ino_ok, mp, XFS_ERRTAG_DIR_INO_VALIDATE,\n\t\t\tXFS_RANDOM_DIR_INO_VALIDATE))) {\n\t\txfs_warn(mp, \"Invalid inode number 0x%Lx\",\n\t\t\t\t(unsigned long long) ino);\n\t\tXFS_ERROR_REPORT(\"xfs_dir_ino_validate\", XFS_ERRLEVEL_LOW, mp);\n\t\treturn -EFSCORRUPTED;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_dir2_priv.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_dir2_priv.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\nxfs_dir_ino_validate(\n\txfs_mount_t\t*mp,\n\txfs_ino_t\tino)\n{\n\txfs_agblock_t\tagblkno;\n\txfs_agino_t\tagino;\n\txfs_agnumber_t\tagno;\n\tint\t\tino_ok;\n\tint\t\tioff;\n\n\tagno = XFS_INO_TO_AGNO(mp, ino);\n\tagblkno = XFS_INO_TO_AGBNO(mp, ino);\n\tioff = XFS_INO_TO_OFFSET(mp, ino);\n\tagino = XFS_OFFBNO_TO_AGINO(mp, agblkno, ioff);\n\tino_ok =\n\t\tagno < mp->m_sb.sb_agcount &&\n\t\tagblkno < mp->m_sb.sb_agblocks &&\n\t\tagblkno != 0 &&\n\t\tioff < (1 << mp->m_sb.sb_inopblog) &&\n\t\tXFS_AGINO_TO_INO(mp, agno, agino) == ino;\n\tif (unlikely(XFS_TEST_ERROR(!ino_ok, mp, XFS_ERRTAG_DIR_INO_VALIDATE,\n\t\t\tXFS_RANDOM_DIR_INO_VALIDATE))) {\n\t\txfs_warn(mp, \"Invalid inode number 0x%Lx\",\n\t\t\t\t(unsigned long long) ino);\n\t\tXFS_ERROR_REPORT(\"xfs_dir_ino_validate\", XFS_ERRLEVEL_LOW, mp);\n\t\treturn -EFSCORRUPTED;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "be64_to_cpu",
          "args": [
            "dep->inumber"
          ],
          "line": 165
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_WANT_CORRUPTED_RETURN",
          "args": [
            "dep->namelen != 0"
          ],
          "line": 163
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be16_to_cpu",
          "args": [
            "dup->length"
          ],
          "line": 152
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_WANT_CORRUPTED_RETURN",
          "args": [
            "be16_to_cpu(dup->length) <=\n\t\t\t\t\t\tbe16_to_cpu(bf[2].length)"
          ],
          "line": 148
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be16_to_cpu",
          "args": [
            "bf[2].length"
          ],
          "line": 150
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be16_to_cpu",
          "args": [
            "dup->length"
          ],
          "line": 149
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_WANT_CORRUPTED_RETURN",
          "args": [
            "(freeseen & (1 << i)) == 0"
          ],
          "line": 144
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_dir2_data_freefind",
          "args": [
            "hdr",
            "bf",
            "dup"
          ],
          "line": 141
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_dir2_data_freefind",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_dir2_data.c",
          "lines": "344-410",
          "snippet": "xfs_dir2_data_free_t *\nxfs_dir2_data_freefind(\n\tstruct xfs_dir2_data_hdr *hdr,\t\t/* data block header */\n\tstruct xfs_dir2_data_free *bf,\t\t/* bestfree table pointer */\n\tstruct xfs_dir2_data_unused *dup)\t/* unused space */\n{\n\txfs_dir2_data_free_t\t*dfp;\t\t/* bestfree entry */\n\txfs_dir2_data_aoff_t\toff;\t\t/* offset value needed */\n#ifdef DEBUG\n\tint\t\t\tmatched;\t/* matched the value */\n\tint\t\t\tseenzero;\t/* saw a 0 bestfree entry */\n#endif\n\n\toff = (xfs_dir2_data_aoff_t)((char *)dup - (char *)hdr);\n\n#ifdef DEBUG\n\t/*\n\t * Validate some consistency in the bestfree table.\n\t * Check order, non-overlapping entries, and if we find the\n\t * one we're looking for it has to be exact.\n\t */\n\tASSERT(hdr->magic == cpu_to_be32(XFS_DIR2_DATA_MAGIC) ||\n\t       hdr->magic == cpu_to_be32(XFS_DIR3_DATA_MAGIC) ||\n\t       hdr->magic == cpu_to_be32(XFS_DIR2_BLOCK_MAGIC) ||\n\t       hdr->magic == cpu_to_be32(XFS_DIR3_BLOCK_MAGIC));\n\tfor (dfp = &bf[0], seenzero = matched = 0;\n\t     dfp < &bf[XFS_DIR2_DATA_FD_COUNT];\n\t     dfp++) {\n\t\tif (!dfp->offset) {\n\t\t\tASSERT(!dfp->length);\n\t\t\tseenzero = 1;\n\t\t\tcontinue;\n\t\t}\n\t\tASSERT(seenzero == 0);\n\t\tif (be16_to_cpu(dfp->offset) == off) {\n\t\t\tmatched = 1;\n\t\t\tASSERT(dfp->length == dup->length);\n\t\t} else if (off < be16_to_cpu(dfp->offset))\n\t\t\tASSERT(off + be16_to_cpu(dup->length) <= be16_to_cpu(dfp->offset));\n\t\telse\n\t\t\tASSERT(be16_to_cpu(dfp->offset) + be16_to_cpu(dfp->length) <= off);\n\t\tASSERT(matched || be16_to_cpu(dfp->length) >= be16_to_cpu(dup->length));\n\t\tif (dfp > &bf[0])\n\t\t\tASSERT(be16_to_cpu(dfp[-1].length) >= be16_to_cpu(dfp[0].length));\n\t}\n#endif\n\t/*\n\t * If this is smaller than the smallest bestfree entry,\n\t * it can't be there since they're sorted.\n\t */\n\tif (be16_to_cpu(dup->length) <\n\t    be16_to_cpu(bf[XFS_DIR2_DATA_FD_COUNT - 1].length))\n\t\treturn NULL;\n\t/*\n\t * Look at the three bestfree entries for our guy.\n\t */\n\tfor (dfp = &bf[0]; dfp < &bf[XFS_DIR2_DATA_FD_COUNT]; dfp++) {\n\t\tif (!dfp->offset)\n\t\t\treturn NULL;\n\t\tif (be16_to_cpu(dfp->offset) == off)\n\t\t\treturn dfp;\n\t}\n\t/*\n\t * Didn't find it.  This only happens if there are duplicate lengths.\n\t */\n\treturn NULL;\n}",
          "includes": [
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_dir2_priv.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_cksum.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_error.h\"\n#include \"xfs_dir2_priv.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nxfs_dir2_data_free_t *\nxfs_dir2_data_freefind(\n\tstruct xfs_dir2_data_hdr *hdr,\t\t/* data block header */\n\tstruct xfs_dir2_data_free *bf,\t\t/* bestfree table pointer */\n\tstruct xfs_dir2_data_unused *dup)\t/* unused space */\n{\n\txfs_dir2_data_free_t\t*dfp;\t\t/* bestfree entry */\n\txfs_dir2_data_aoff_t\toff;\t\t/* offset value needed */\n#ifdef DEBUG\n\tint\t\t\tmatched;\t/* matched the value */\n\tint\t\t\tseenzero;\t/* saw a 0 bestfree entry */\n#endif\n\n\toff = (xfs_dir2_data_aoff_t)((char *)dup - (char *)hdr);\n\n#ifdef DEBUG\n\t/*\n\t * Validate some consistency in the bestfree table.\n\t * Check order, non-overlapping entries, and if we find the\n\t * one we're looking for it has to be exact.\n\t */\n\tASSERT(hdr->magic == cpu_to_be32(XFS_DIR2_DATA_MAGIC) ||\n\t       hdr->magic == cpu_to_be32(XFS_DIR3_DATA_MAGIC) ||\n\t       hdr->magic == cpu_to_be32(XFS_DIR2_BLOCK_MAGIC) ||\n\t       hdr->magic == cpu_to_be32(XFS_DIR3_BLOCK_MAGIC));\n\tfor (dfp = &bf[0], seenzero = matched = 0;\n\t     dfp < &bf[XFS_DIR2_DATA_FD_COUNT];\n\t     dfp++) {\n\t\tif (!dfp->offset) {\n\t\t\tASSERT(!dfp->length);\n\t\t\tseenzero = 1;\n\t\t\tcontinue;\n\t\t}\n\t\tASSERT(seenzero == 0);\n\t\tif (be16_to_cpu(dfp->offset) == off) {\n\t\t\tmatched = 1;\n\t\t\tASSERT(dfp->length == dup->length);\n\t\t} else if (off < be16_to_cpu(dfp->offset))\n\t\t\tASSERT(off + be16_to_cpu(dup->length) <= be16_to_cpu(dfp->offset));\n\t\telse\n\t\t\tASSERT(be16_to_cpu(dfp->offset) + be16_to_cpu(dfp->length) <= off);\n\t\tASSERT(matched || be16_to_cpu(dfp->length) >= be16_to_cpu(dup->length));\n\t\tif (dfp > &bf[0])\n\t\t\tASSERT(be16_to_cpu(dfp[-1].length) >= be16_to_cpu(dfp[0].length));\n\t}\n#endif\n\t/*\n\t * If this is smaller than the smallest bestfree entry,\n\t * it can't be there since they're sorted.\n\t */\n\tif (be16_to_cpu(dup->length) <\n\t    be16_to_cpu(bf[XFS_DIR2_DATA_FD_COUNT - 1].length))\n\t\treturn NULL;\n\t/*\n\t * Look at the three bestfree entries for our guy.\n\t */\n\tfor (dfp = &bf[0]; dfp < &bf[XFS_DIR2_DATA_FD_COUNT]; dfp++) {\n\t\tif (!dfp->offset)\n\t\t\treturn NULL;\n\t\tif (be16_to_cpu(dfp->offset) == off)\n\t\t\treturn dfp;\n\t}\n\t/*\n\t * Didn't find it.  This only happens if there are duplicate lengths.\n\t */\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "XFS_WANT_CORRUPTED_RETURN",
          "args": [
            "be16_to_cpu(*xfs_dir2_data_unused_tag_p(dup)) ==\n\t\t\t\t\t       (char *)dup - (char *)hdr"
          ],
          "line": 138
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be16_to_cpu",
          "args": [
            "*xfs_dir2_data_unused_tag_p(dup)"
          ],
          "line": 139
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_dir2_data_unused_tag_p",
          "args": [
            "dup"
          ],
          "line": 139
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_dir2_data_unused_tag_p",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_da_format.h",
          "lines": "407-412",
          "snippet": "static inline __be16 *\nxfs_dir2_data_unused_tag_p(struct xfs_dir2_data_unused *dup)\n{\n\treturn (__be16 *)((char *)dup +\n\t\t\tbe16_to_cpu(dup->length) - sizeof(__be16));\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline __be16 *\nxfs_dir2_data_unused_tag_p(struct xfs_dir2_data_unused *dup)\n{\n\treturn (__be16 *)((char *)dup +\n\t\t\tbe16_to_cpu(dup->length) - sizeof(__be16));\n}"
        }
      },
      {
        "call_info": {
          "callee": "XFS_WANT_CORRUPTED_RETURN",
          "args": [
            "lastfree == 0"
          ],
          "line": 137
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be16_to_cpu",
          "args": [
            "dup->freetag"
          ],
          "line": 136
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_WANT_CORRUPTED_RETURN",
          "args": [
            "be16_to_cpu(bf[1].length) >=\n\t\t\t\t\t\tbe16_to_cpu(bf[2].length)"
          ],
          "line": 124
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be16_to_cpu",
          "args": [
            "bf[2].length"
          ],
          "line": 125
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be16_to_cpu",
          "args": [
            "bf[1].length"
          ],
          "line": 124
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_WANT_CORRUPTED_RETURN",
          "args": [
            "be16_to_cpu(bf[0].length) >=\n\t\t\t\t\t\tbe16_to_cpu(bf[1].length)"
          ],
          "line": 122
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be16_to_cpu",
          "args": [
            "bf[1].length"
          ],
          "line": 123
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be16_to_cpu",
          "args": [
            "bf[0].length"
          ],
          "line": 122
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_WANT_CORRUPTED_RETURN",
          "args": [
            "!bf[2].offset"
          ],
          "line": 118
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_WANT_CORRUPTED_RETURN",
          "args": [
            "!bf[1].offset"
          ],
          "line": 114
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_WANT_CORRUPTED_RETURN",
          "args": [
            "!bf[0].offset"
          ],
          "line": 110
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ops->data_bestfree_p",
          "args": [
            "hdr"
          ],
          "line": 107
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_ERROR_REPORT",
          "args": [
            "\"Bad Magic\"",
            "XFS_ERRLEVEL_LOW",
            "mp"
          ],
          "line": 100
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "XFS_DIR2_DATA_MAGIC"
          ],
          "line": 96
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "XFS_DIR3_DATA_MAGIC"
          ],
          "line": 95
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_WANT_CORRUPTED_RETURN",
          "args": [
            "be32_to_cpu(btp->count) <\n\t\t\t((char *)btp - p) / sizeof(struct xfs_dir2_leaf_entry)"
          ],
          "line": 92
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "btp->count"
          ],
          "line": 92
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_dir2_block_leaf_p",
          "args": [
            "btp"
          ],
          "line": 82
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_dir2_block_leaf_p",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_da_format.h",
          "lines": "601-605",
          "snippet": "static inline struct xfs_dir2_leaf_entry *\nxfs_dir2_block_leaf_p(struct xfs_dir2_block_tail *btp)\n{\n\treturn ((struct xfs_dir2_leaf_entry *)btp) - be32_to_cpu(btp->count);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline struct xfs_dir2_leaf_entry *\nxfs_dir2_block_leaf_p(struct xfs_dir2_block_tail *btp)\n{\n\treturn ((struct xfs_dir2_leaf_entry *)btp) - be32_to_cpu(btp->count);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_dir2_block_tail_p",
          "args": [
            "geo",
            "hdr"
          ],
          "line": 81
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_dir2_block_tail_p",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_dir2.h",
          "lines": "305-310",
          "snippet": "static inline struct xfs_dir2_block_tail *\nxfs_dir2_block_tail_p(struct xfs_da_geometry *geo, struct xfs_dir2_data_hdr *hdr)\n{\n\treturn ((struct xfs_dir2_block_tail *)\n\t\t((char *)hdr + geo->blksize)) - 1;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline struct xfs_dir2_block_tail *\nxfs_dir2_block_tail_p(struct xfs_da_geometry *geo, struct xfs_dir2_data_hdr *hdr)\n{\n\treturn ((struct xfs_dir2_block_tail *)\n\t\t((char *)hdr + geo->blksize)) - 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "XFS_DIR2_BLOCK_MAGIC"
          ],
          "line": 80
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "XFS_DIR3_BLOCK_MAGIC"
          ],
          "line": 79
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ops->data_entry_p",
          "args": [
            "hdr"
          ],
          "line": 76
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_dir_get_ops",
          "args": [
            "mp",
            "dp"
          ],
          "line": 73
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_dir_get_ops",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_da_format.c",
          "lines": "880-894",
          "snippet": "const struct xfs_dir_ops *\nxfs_dir_get_ops(\n\tstruct xfs_mount\t*mp,\n\tstruct xfs_inode\t*dp)\n{\n\tif (dp)\n\t\treturn dp->d_ops;\n\tif (mp->m_dir_inode_ops)\n\t\treturn mp->m_dir_inode_ops;\n\tif (xfs_sb_version_hascrc(&mp->m_sb))\n\t\treturn &xfs_dir3_ops;\n\tif (xfs_sb_version_hasftype(&mp->m_sb))\n\t\treturn &xfs_dir2_ftype_ops;\n\treturn &xfs_dir2_ops;\n}",
          "includes": [
            "#include \"xfs_dir2_priv.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct xfs_dir_ops xfs_dir2_ops = {\n\t.sf_entsize = xfs_dir2_sf_entsize,\n\t.sf_nextentry = xfs_dir2_sf_nextentry,\n\t.sf_get_ftype = xfs_dir2_sfe_get_ftype,\n\t.sf_put_ftype = xfs_dir2_sfe_put_ftype,\n\t.sf_get_ino = xfs_dir2_sfe_get_ino,\n\t.sf_put_ino = xfs_dir2_sfe_put_ino,\n\t.sf_get_parent_ino = xfs_dir2_sf_get_parent_ino,\n\t.sf_put_parent_ino = xfs_dir2_sf_put_parent_ino,\n\n\t.data_entsize = xfs_dir2_data_entsize,\n\t.data_get_ftype = xfs_dir2_data_get_ftype,\n\t.data_put_ftype = xfs_dir2_data_put_ftype,\n\t.data_entry_tag_p = xfs_dir2_data_entry_tag_p,\n\t.data_bestfree_p = xfs_dir2_data_bestfree_p,\n\n\t.data_dot_offset = sizeof(struct xfs_dir2_data_hdr),\n\t.data_dotdot_offset = sizeof(struct xfs_dir2_data_hdr) +\n\t\t\t\tXFS_DIR2_DATA_ENTSIZE(1),\n\t.data_first_offset =  sizeof(struct xfs_dir2_data_hdr) +\n\t\t\t\tXFS_DIR2_DATA_ENTSIZE(1) +\n\t\t\t\tXFS_DIR2_DATA_ENTSIZE(2),\n\t.data_entry_offset = sizeof(struct xfs_dir2_data_hdr),\n\n\t.data_dot_entry_p = xfs_dir2_data_dot_entry_p,\n\t.data_dotdot_entry_p = xfs_dir2_data_dotdot_entry_p,\n\t.data_first_entry_p = xfs_dir2_data_first_entry_p,\n\t.data_entry_p = xfs_dir2_data_entry_p,\n\t.data_unused_p = xfs_dir2_data_unused_p,\n\n\t.leaf_hdr_size = sizeof(struct xfs_dir2_leaf_hdr),\n\t.leaf_hdr_to_disk = xfs_dir2_leaf_hdr_to_disk,\n\t.leaf_hdr_from_disk = xfs_dir2_leaf_hdr_from_disk,\n\t.leaf_max_ents = xfs_dir2_max_leaf_ents,\n\t.leaf_ents_p = xfs_dir2_leaf_ents_p,\n\n\t.node_hdr_size = sizeof(struct xfs_da_node_hdr),\n\t.node_hdr_to_disk = xfs_da2_node_hdr_to_disk,\n\t.node_hdr_from_disk = xfs_da2_node_hdr_from_disk,\n\t.node_tree_p = xfs_da2_node_tree_p,\n\n\t.free_hdr_size = sizeof(struct xfs_dir2_free_hdr),\n\t.free_hdr_to_disk = xfs_dir2_free_hdr_to_disk,\n\t.free_hdr_from_disk = xfs_dir2_free_hdr_from_disk,\n\t.free_max_bests = xfs_dir2_free_max_bests,\n\t.free_bests_p = xfs_dir2_free_bests_p,\n\t.db_to_fdb = xfs_dir2_db_to_fdb,\n\t.db_to_fdindex = xfs_dir2_db_to_fdindex,\n};",
            "static const struct xfs_dir_ops xfs_dir2_ftype_ops = {\n\t.sf_entsize = xfs_dir3_sf_entsize,\n\t.sf_nextentry = xfs_dir3_sf_nextentry,\n\t.sf_get_ftype = xfs_dir3_sfe_get_ftype,\n\t.sf_put_ftype = xfs_dir3_sfe_put_ftype,\n\t.sf_get_ino = xfs_dir3_sfe_get_ino,\n\t.sf_put_ino = xfs_dir3_sfe_put_ino,\n\t.sf_get_parent_ino = xfs_dir2_sf_get_parent_ino,\n\t.sf_put_parent_ino = xfs_dir2_sf_put_parent_ino,\n\n\t.data_entsize = xfs_dir3_data_entsize,\n\t.data_get_ftype = xfs_dir3_data_get_ftype,\n\t.data_put_ftype = xfs_dir3_data_put_ftype,\n\t.data_entry_tag_p = xfs_dir3_data_entry_tag_p,\n\t.data_bestfree_p = xfs_dir2_data_bestfree_p,\n\n\t.data_dot_offset = sizeof(struct xfs_dir2_data_hdr),\n\t.data_dotdot_offset = sizeof(struct xfs_dir2_data_hdr) +\n\t\t\t\tXFS_DIR3_DATA_ENTSIZE(1),\n\t.data_first_offset =  sizeof(struct xfs_dir2_data_hdr) +\n\t\t\t\tXFS_DIR3_DATA_ENTSIZE(1) +\n\t\t\t\tXFS_DIR3_DATA_ENTSIZE(2),\n\t.data_entry_offset = sizeof(struct xfs_dir2_data_hdr),\n\n\t.data_dot_entry_p = xfs_dir2_data_dot_entry_p,\n\t.data_dotdot_entry_p = xfs_dir2_ftype_data_dotdot_entry_p,\n\t.data_first_entry_p = xfs_dir2_ftype_data_first_entry_p,\n\t.data_entry_p = xfs_dir2_data_entry_p,\n\t.data_unused_p = xfs_dir2_data_unused_p,\n\n\t.leaf_hdr_size = sizeof(struct xfs_dir2_leaf_hdr),\n\t.leaf_hdr_to_disk = xfs_dir2_leaf_hdr_to_disk,\n\t.leaf_hdr_from_disk = xfs_dir2_leaf_hdr_from_disk,\n\t.leaf_max_ents = xfs_dir2_max_leaf_ents,\n\t.leaf_ents_p = xfs_dir2_leaf_ents_p,\n\n\t.node_hdr_size = sizeof(struct xfs_da_node_hdr),\n\t.node_hdr_to_disk = xfs_da2_node_hdr_to_disk,\n\t.node_hdr_from_disk = xfs_da2_node_hdr_from_disk,\n\t.node_tree_p = xfs_da2_node_tree_p,\n\n\t.free_hdr_size = sizeof(struct xfs_dir2_free_hdr),\n\t.free_hdr_to_disk = xfs_dir2_free_hdr_to_disk,\n\t.free_hdr_from_disk = xfs_dir2_free_hdr_from_disk,\n\t.free_max_bests = xfs_dir2_free_max_bests,\n\t.free_bests_p = xfs_dir2_free_bests_p,\n\t.db_to_fdb = xfs_dir2_db_to_fdb,\n\t.db_to_fdindex = xfs_dir2_db_to_fdindex,\n};",
            "static const struct xfs_dir_ops xfs_dir3_ops = {\n\t.sf_entsize = xfs_dir3_sf_entsize,\n\t.sf_nextentry = xfs_dir3_sf_nextentry,\n\t.sf_get_ftype = xfs_dir3_sfe_get_ftype,\n\t.sf_put_ftype = xfs_dir3_sfe_put_ftype,\n\t.sf_get_ino = xfs_dir3_sfe_get_ino,\n\t.sf_put_ino = xfs_dir3_sfe_put_ino,\n\t.sf_get_parent_ino = xfs_dir2_sf_get_parent_ino,\n\t.sf_put_parent_ino = xfs_dir2_sf_put_parent_ino,\n\n\t.data_entsize = xfs_dir3_data_entsize,\n\t.data_get_ftype = xfs_dir3_data_get_ftype,\n\t.data_put_ftype = xfs_dir3_data_put_ftype,\n\t.data_entry_tag_p = xfs_dir3_data_entry_tag_p,\n\t.data_bestfree_p = xfs_dir3_data_bestfree_p,\n\n\t.data_dot_offset = sizeof(struct xfs_dir3_data_hdr),\n\t.data_dotdot_offset = sizeof(struct xfs_dir3_data_hdr) +\n\t\t\t\tXFS_DIR3_DATA_ENTSIZE(1),\n\t.data_first_offset =  sizeof(struct xfs_dir3_data_hdr) +\n\t\t\t\tXFS_DIR3_DATA_ENTSIZE(1) +\n\t\t\t\tXFS_DIR3_DATA_ENTSIZE(2),\n\t.data_entry_offset = sizeof(struct xfs_dir3_data_hdr),\n\n\t.data_dot_entry_p = xfs_dir3_data_dot_entry_p,\n\t.data_dotdot_entry_p = xfs_dir3_data_dotdot_entry_p,\n\t.data_first_entry_p = xfs_dir3_data_first_entry_p,\n\t.data_entry_p = xfs_dir3_data_entry_p,\n\t.data_unused_p = xfs_dir3_data_unused_p,\n\n\t.leaf_hdr_size = sizeof(struct xfs_dir3_leaf_hdr),\n\t.leaf_hdr_to_disk = xfs_dir3_leaf_hdr_to_disk,\n\t.leaf_hdr_from_disk = xfs_dir3_leaf_hdr_from_disk,\n\t.leaf_max_ents = xfs_dir3_max_leaf_ents,\n\t.leaf_ents_p = xfs_dir3_leaf_ents_p,\n\n\t.node_hdr_size = sizeof(struct xfs_da3_node_hdr),\n\t.node_hdr_to_disk = xfs_da3_node_hdr_to_disk,\n\t.node_hdr_from_disk = xfs_da3_node_hdr_from_disk,\n\t.node_tree_p = xfs_da3_node_tree_p,\n\n\t.free_hdr_size = sizeof(struct xfs_dir3_free_hdr),\n\t.free_hdr_to_disk = xfs_dir3_free_hdr_to_disk,\n\t.free_hdr_from_disk = xfs_dir3_free_hdr_from_disk,\n\t.free_max_bests = xfs_dir3_free_max_bests,\n\t.free_bests_p = xfs_dir3_free_bests_p,\n\t.db_to_fdb = xfs_dir3_db_to_fdb,\n\t.db_to_fdindex = xfs_dir3_db_to_fdindex,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_dir2_priv.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nstatic const struct xfs_dir_ops xfs_dir2_ops = {\n\t.sf_entsize = xfs_dir2_sf_entsize,\n\t.sf_nextentry = xfs_dir2_sf_nextentry,\n\t.sf_get_ftype = xfs_dir2_sfe_get_ftype,\n\t.sf_put_ftype = xfs_dir2_sfe_put_ftype,\n\t.sf_get_ino = xfs_dir2_sfe_get_ino,\n\t.sf_put_ino = xfs_dir2_sfe_put_ino,\n\t.sf_get_parent_ino = xfs_dir2_sf_get_parent_ino,\n\t.sf_put_parent_ino = xfs_dir2_sf_put_parent_ino,\n\n\t.data_entsize = xfs_dir2_data_entsize,\n\t.data_get_ftype = xfs_dir2_data_get_ftype,\n\t.data_put_ftype = xfs_dir2_data_put_ftype,\n\t.data_entry_tag_p = xfs_dir2_data_entry_tag_p,\n\t.data_bestfree_p = xfs_dir2_data_bestfree_p,\n\n\t.data_dot_offset = sizeof(struct xfs_dir2_data_hdr),\n\t.data_dotdot_offset = sizeof(struct xfs_dir2_data_hdr) +\n\t\t\t\tXFS_DIR2_DATA_ENTSIZE(1),\n\t.data_first_offset =  sizeof(struct xfs_dir2_data_hdr) +\n\t\t\t\tXFS_DIR2_DATA_ENTSIZE(1) +\n\t\t\t\tXFS_DIR2_DATA_ENTSIZE(2),\n\t.data_entry_offset = sizeof(struct xfs_dir2_data_hdr),\n\n\t.data_dot_entry_p = xfs_dir2_data_dot_entry_p,\n\t.data_dotdot_entry_p = xfs_dir2_data_dotdot_entry_p,\n\t.data_first_entry_p = xfs_dir2_data_first_entry_p,\n\t.data_entry_p = xfs_dir2_data_entry_p,\n\t.data_unused_p = xfs_dir2_data_unused_p,\n\n\t.leaf_hdr_size = sizeof(struct xfs_dir2_leaf_hdr),\n\t.leaf_hdr_to_disk = xfs_dir2_leaf_hdr_to_disk,\n\t.leaf_hdr_from_disk = xfs_dir2_leaf_hdr_from_disk,\n\t.leaf_max_ents = xfs_dir2_max_leaf_ents,\n\t.leaf_ents_p = xfs_dir2_leaf_ents_p,\n\n\t.node_hdr_size = sizeof(struct xfs_da_node_hdr),\n\t.node_hdr_to_disk = xfs_da2_node_hdr_to_disk,\n\t.node_hdr_from_disk = xfs_da2_node_hdr_from_disk,\n\t.node_tree_p = xfs_da2_node_tree_p,\n\n\t.free_hdr_size = sizeof(struct xfs_dir2_free_hdr),\n\t.free_hdr_to_disk = xfs_dir2_free_hdr_to_disk,\n\t.free_hdr_from_disk = xfs_dir2_free_hdr_from_disk,\n\t.free_max_bests = xfs_dir2_free_max_bests,\n\t.free_bests_p = xfs_dir2_free_bests_p,\n\t.db_to_fdb = xfs_dir2_db_to_fdb,\n\t.db_to_fdindex = xfs_dir2_db_to_fdindex,\n};\nstatic const struct xfs_dir_ops xfs_dir2_ftype_ops = {\n\t.sf_entsize = xfs_dir3_sf_entsize,\n\t.sf_nextentry = xfs_dir3_sf_nextentry,\n\t.sf_get_ftype = xfs_dir3_sfe_get_ftype,\n\t.sf_put_ftype = xfs_dir3_sfe_put_ftype,\n\t.sf_get_ino = xfs_dir3_sfe_get_ino,\n\t.sf_put_ino = xfs_dir3_sfe_put_ino,\n\t.sf_get_parent_ino = xfs_dir2_sf_get_parent_ino,\n\t.sf_put_parent_ino = xfs_dir2_sf_put_parent_ino,\n\n\t.data_entsize = xfs_dir3_data_entsize,\n\t.data_get_ftype = xfs_dir3_data_get_ftype,\n\t.data_put_ftype = xfs_dir3_data_put_ftype,\n\t.data_entry_tag_p = xfs_dir3_data_entry_tag_p,\n\t.data_bestfree_p = xfs_dir2_data_bestfree_p,\n\n\t.data_dot_offset = sizeof(struct xfs_dir2_data_hdr),\n\t.data_dotdot_offset = sizeof(struct xfs_dir2_data_hdr) +\n\t\t\t\tXFS_DIR3_DATA_ENTSIZE(1),\n\t.data_first_offset =  sizeof(struct xfs_dir2_data_hdr) +\n\t\t\t\tXFS_DIR3_DATA_ENTSIZE(1) +\n\t\t\t\tXFS_DIR3_DATA_ENTSIZE(2),\n\t.data_entry_offset = sizeof(struct xfs_dir2_data_hdr),\n\n\t.data_dot_entry_p = xfs_dir2_data_dot_entry_p,\n\t.data_dotdot_entry_p = xfs_dir2_ftype_data_dotdot_entry_p,\n\t.data_first_entry_p = xfs_dir2_ftype_data_first_entry_p,\n\t.data_entry_p = xfs_dir2_data_entry_p,\n\t.data_unused_p = xfs_dir2_data_unused_p,\n\n\t.leaf_hdr_size = sizeof(struct xfs_dir2_leaf_hdr),\n\t.leaf_hdr_to_disk = xfs_dir2_leaf_hdr_to_disk,\n\t.leaf_hdr_from_disk = xfs_dir2_leaf_hdr_from_disk,\n\t.leaf_max_ents = xfs_dir2_max_leaf_ents,\n\t.leaf_ents_p = xfs_dir2_leaf_ents_p,\n\n\t.node_hdr_size = sizeof(struct xfs_da_node_hdr),\n\t.node_hdr_to_disk = xfs_da2_node_hdr_to_disk,\n\t.node_hdr_from_disk = xfs_da2_node_hdr_from_disk,\n\t.node_tree_p = xfs_da2_node_tree_p,\n\n\t.free_hdr_size = sizeof(struct xfs_dir2_free_hdr),\n\t.free_hdr_to_disk = xfs_dir2_free_hdr_to_disk,\n\t.free_hdr_from_disk = xfs_dir2_free_hdr_from_disk,\n\t.free_max_bests = xfs_dir2_free_max_bests,\n\t.free_bests_p = xfs_dir2_free_bests_p,\n\t.db_to_fdb = xfs_dir2_db_to_fdb,\n\t.db_to_fdindex = xfs_dir2_db_to_fdindex,\n};\nstatic const struct xfs_dir_ops xfs_dir3_ops = {\n\t.sf_entsize = xfs_dir3_sf_entsize,\n\t.sf_nextentry = xfs_dir3_sf_nextentry,\n\t.sf_get_ftype = xfs_dir3_sfe_get_ftype,\n\t.sf_put_ftype = xfs_dir3_sfe_put_ftype,\n\t.sf_get_ino = xfs_dir3_sfe_get_ino,\n\t.sf_put_ino = xfs_dir3_sfe_put_ino,\n\t.sf_get_parent_ino = xfs_dir2_sf_get_parent_ino,\n\t.sf_put_parent_ino = xfs_dir2_sf_put_parent_ino,\n\n\t.data_entsize = xfs_dir3_data_entsize,\n\t.data_get_ftype = xfs_dir3_data_get_ftype,\n\t.data_put_ftype = xfs_dir3_data_put_ftype,\n\t.data_entry_tag_p = xfs_dir3_data_entry_tag_p,\n\t.data_bestfree_p = xfs_dir3_data_bestfree_p,\n\n\t.data_dot_offset = sizeof(struct xfs_dir3_data_hdr),\n\t.data_dotdot_offset = sizeof(struct xfs_dir3_data_hdr) +\n\t\t\t\tXFS_DIR3_DATA_ENTSIZE(1),\n\t.data_first_offset =  sizeof(struct xfs_dir3_data_hdr) +\n\t\t\t\tXFS_DIR3_DATA_ENTSIZE(1) +\n\t\t\t\tXFS_DIR3_DATA_ENTSIZE(2),\n\t.data_entry_offset = sizeof(struct xfs_dir3_data_hdr),\n\n\t.data_dot_entry_p = xfs_dir3_data_dot_entry_p,\n\t.data_dotdot_entry_p = xfs_dir3_data_dotdot_entry_p,\n\t.data_first_entry_p = xfs_dir3_data_first_entry_p,\n\t.data_entry_p = xfs_dir3_data_entry_p,\n\t.data_unused_p = xfs_dir3_data_unused_p,\n\n\t.leaf_hdr_size = sizeof(struct xfs_dir3_leaf_hdr),\n\t.leaf_hdr_to_disk = xfs_dir3_leaf_hdr_to_disk,\n\t.leaf_hdr_from_disk = xfs_dir3_leaf_hdr_from_disk,\n\t.leaf_max_ents = xfs_dir3_max_leaf_ents,\n\t.leaf_ents_p = xfs_dir3_leaf_ents_p,\n\n\t.node_hdr_size = sizeof(struct xfs_da3_node_hdr),\n\t.node_hdr_to_disk = xfs_da3_node_hdr_to_disk,\n\t.node_hdr_from_disk = xfs_da3_node_hdr_from_disk,\n\t.node_tree_p = xfs_da3_node_tree_p,\n\n\t.free_hdr_size = sizeof(struct xfs_dir3_free_hdr),\n\t.free_hdr_to_disk = xfs_dir3_free_hdr_to_disk,\n\t.free_hdr_from_disk = xfs_dir3_free_hdr_from_disk,\n\t.free_max_bests = xfs_dir3_free_max_bests,\n\t.free_bests_p = xfs_dir3_free_bests_p,\n\t.db_to_fdb = xfs_dir3_db_to_fdb,\n\t.db_to_fdindex = xfs_dir3_db_to_fdindex,\n};\n\nconst struct xfs_dir_ops *\nxfs_dir_get_ops(\n\tstruct xfs_mount\t*mp,\n\tstruct xfs_inode\t*dp)\n{\n\tif (dp)\n\t\treturn dp->d_ops;\n\tif (mp->m_dir_inode_ops)\n\t\treturn mp->m_dir_inode_ops;\n\tif (xfs_sb_version_hascrc(&mp->m_sb))\n\t\treturn &xfs_dir3_ops;\n\tif (xfs_sb_version_hasftype(&mp->m_sb))\n\t\treturn &xfs_dir2_ftype_ops;\n\treturn &xfs_dir2_ops;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xfs_cksum.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_error.h\"\n#include \"xfs_dir2_priv.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\n__xfs_dir3_data_check(\n\tstruct xfs_inode\t*dp,\t\t/* incore inode pointer */\n\tstruct xfs_buf\t\t*bp)\t\t/* data block's buffer */\n{\n\txfs_dir2_dataptr_t\taddr;\t\t/* addr for leaf lookup */\n\txfs_dir2_data_free_t\t*bf;\t\t/* bestfree table */\n\txfs_dir2_block_tail_t\t*btp=NULL;\t/* block tail */\n\tint\t\t\tcount;\t\t/* count of entries found */\n\txfs_dir2_data_hdr_t\t*hdr;\t\t/* data block header */\n\txfs_dir2_data_entry_t\t*dep;\t\t/* data entry */\n\txfs_dir2_data_free_t\t*dfp;\t\t/* bestfree entry */\n\txfs_dir2_data_unused_t\t*dup;\t\t/* unused entry */\n\tchar\t\t\t*endp;\t\t/* end of useful data */\n\tint\t\t\tfreeseen;\t/* mask of bestfrees seen */\n\txfs_dahash_t\t\thash;\t\t/* hash of current name */\n\tint\t\t\ti;\t\t/* leaf index */\n\tint\t\t\tlastfree;\t/* last entry was unused */\n\txfs_dir2_leaf_entry_t\t*lep=NULL;\t/* block leaf entries */\n\txfs_mount_t\t\t*mp;\t\t/* filesystem mount point */\n\tchar\t\t\t*p;\t\t/* current data position */\n\tint\t\t\tstale;\t\t/* count of stale leaves */\n\tstruct xfs_name\t\tname;\n\tconst struct xfs_dir_ops *ops;\n\tstruct xfs_da_geometry\t*geo;\n\n\tmp = bp->b_target->bt_mount;\n\tgeo = mp->m_dir_geo;\n\n\t/*\n\t * We can be passed a null dp here from a verifier, so we need to go the\n\t * hard way to get them.\n\t */\n\tops = xfs_dir_get_ops(mp, dp);\n\n\thdr = bp->b_addr;\n\tp = (char *)ops->data_entry_p(hdr);\n\n\tswitch (hdr->magic) {\n\tcase cpu_to_be32(XFS_DIR3_BLOCK_MAGIC):\n\tcase cpu_to_be32(XFS_DIR2_BLOCK_MAGIC):\n\t\tbtp = xfs_dir2_block_tail_p(geo, hdr);\n\t\tlep = xfs_dir2_block_leaf_p(btp);\n\t\tendp = (char *)lep;\n\n\t\t/*\n\t\t * The number of leaf entries is limited by the size of the\n\t\t * block and the amount of space used by the data entries.\n\t\t * We don't know how much space is used by the data entries yet,\n\t\t * so just ensure that the count falls somewhere inside the\n\t\t * block right now.\n\t\t */\n\t\tXFS_WANT_CORRUPTED_RETURN(be32_to_cpu(btp->count) <\n\t\t\t((char *)btp - p) / sizeof(struct xfs_dir2_leaf_entry));\n\t\tbreak;\n\tcase cpu_to_be32(XFS_DIR3_DATA_MAGIC):\n\tcase cpu_to_be32(XFS_DIR2_DATA_MAGIC):\n\t\tendp = (char *)hdr + geo->blksize;\n\t\tbreak;\n\tdefault:\n\t\tXFS_ERROR_REPORT(\"Bad Magic\", XFS_ERRLEVEL_LOW, mp);\n\t\treturn -EFSCORRUPTED;\n\t}\n\n\t/*\n\t * Account for zero bestfree entries.\n\t */\n\tbf = ops->data_bestfree_p(hdr);\n\tcount = lastfree = freeseen = 0;\n\tif (!bf[0].length) {\n\t\tXFS_WANT_CORRUPTED_RETURN(!bf[0].offset);\n\t\tfreeseen |= 1 << 0;\n\t}\n\tif (!bf[1].length) {\n\t\tXFS_WANT_CORRUPTED_RETURN(!bf[1].offset);\n\t\tfreeseen |= 1 << 1;\n\t}\n\tif (!bf[2].length) {\n\t\tXFS_WANT_CORRUPTED_RETURN(!bf[2].offset);\n\t\tfreeseen |= 1 << 2;\n\t}\n\n\tXFS_WANT_CORRUPTED_RETURN(be16_to_cpu(bf[0].length) >=\n\t\t\t\t\t\tbe16_to_cpu(bf[1].length));\n\tXFS_WANT_CORRUPTED_RETURN(be16_to_cpu(bf[1].length) >=\n\t\t\t\t\t\tbe16_to_cpu(bf[2].length));\n\t/*\n\t * Loop over the data/unused entries.\n\t */\n\twhile (p < endp) {\n\t\tdup = (xfs_dir2_data_unused_t *)p;\n\t\t/*\n\t\t * If it's unused, look for the space in the bestfree table.\n\t\t * If we find it, account for that, else make sure it\n\t\t * doesn't need to be there.\n\t\t */\n\t\tif (be16_to_cpu(dup->freetag) == XFS_DIR2_DATA_FREE_TAG) {\n\t\t\tXFS_WANT_CORRUPTED_RETURN(lastfree == 0);\n\t\t\tXFS_WANT_CORRUPTED_RETURN(\n\t\t\t\tbe16_to_cpu(*xfs_dir2_data_unused_tag_p(dup)) ==\n\t\t\t\t\t       (char *)dup - (char *)hdr);\n\t\t\tdfp = xfs_dir2_data_freefind(hdr, bf, dup);\n\t\t\tif (dfp) {\n\t\t\t\ti = (int)(dfp - bf);\n\t\t\t\tXFS_WANT_CORRUPTED_RETURN(\n\t\t\t\t\t(freeseen & (1 << i)) == 0);\n\t\t\t\tfreeseen |= 1 << i;\n\t\t\t} else {\n\t\t\t\tXFS_WANT_CORRUPTED_RETURN(\n\t\t\t\t\tbe16_to_cpu(dup->length) <=\n\t\t\t\t\t\tbe16_to_cpu(bf[2].length));\n\t\t\t}\n\t\t\tp += be16_to_cpu(dup->length);\n\t\t\tlastfree = 1;\n\t\t\tcontinue;\n\t\t}\n\t\t/*\n\t\t * It's a real entry.  Validate the fields.\n\t\t * If this is a block directory then make sure it's\n\t\t * in the leaf section of the block.\n\t\t * The linear search is crude but this is DEBUG code.\n\t\t */\n\t\tdep = (xfs_dir2_data_entry_t *)p;\n\t\tXFS_WANT_CORRUPTED_RETURN(dep->namelen != 0);\n\t\tXFS_WANT_CORRUPTED_RETURN(\n\t\t\t!xfs_dir_ino_validate(mp, be64_to_cpu(dep->inumber)));\n\t\tXFS_WANT_CORRUPTED_RETURN(\n\t\t\tbe16_to_cpu(*ops->data_entry_tag_p(dep)) ==\n\t\t\t\t\t       (char *)dep - (char *)hdr);\n\t\tXFS_WANT_CORRUPTED_RETURN(\n\t\t\t\tops->data_get_ftype(dep) < XFS_DIR3_FT_MAX);\n\t\tcount++;\n\t\tlastfree = 0;\n\t\tif (hdr->magic == cpu_to_be32(XFS_DIR2_BLOCK_MAGIC) ||\n\t\t    hdr->magic == cpu_to_be32(XFS_DIR3_BLOCK_MAGIC)) {\n\t\t\taddr = xfs_dir2_db_off_to_dataptr(geo, geo->datablk,\n\t\t\t\t\t\t(xfs_dir2_data_aoff_t)\n\t\t\t\t\t\t((char *)dep - (char *)hdr));\n\t\t\tname.name = dep->name;\n\t\t\tname.len = dep->namelen;\n\t\t\thash = mp->m_dirnameops->hashname(&name);\n\t\t\tfor (i = 0; i < be32_to_cpu(btp->count); i++) {\n\t\t\t\tif (be32_to_cpu(lep[i].address) == addr &&\n\t\t\t\t    be32_to_cpu(lep[i].hashval) == hash)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tXFS_WANT_CORRUPTED_RETURN(i < be32_to_cpu(btp->count));\n\t\t}\n\t\tp += ops->data_entsize(dep->namelen);\n\t}\n\t/*\n\t * Need to have seen all the entries and all the bestfree slots.\n\t */\n\tXFS_WANT_CORRUPTED_RETURN(freeseen == 7);\n\tif (hdr->magic == cpu_to_be32(XFS_DIR2_BLOCK_MAGIC) ||\n\t    hdr->magic == cpu_to_be32(XFS_DIR3_BLOCK_MAGIC)) {\n\t\tfor (i = stale = 0; i < be32_to_cpu(btp->count); i++) {\n\t\t\tif (lep[i].address ==\n\t\t\t    cpu_to_be32(XFS_DIR2_NULL_DATAPTR))\n\t\t\t\tstale++;\n\t\t\tif (i > 0)\n\t\t\t\tXFS_WANT_CORRUPTED_RETURN(\n\t\t\t\t\tbe32_to_cpu(lep[i].hashval) >=\n\t\t\t\t\t\tbe32_to_cpu(lep[i - 1].hashval));\n\t\t}\n\t\tXFS_WANT_CORRUPTED_RETURN(count ==\n\t\t\tbe32_to_cpu(btp->count) - be32_to_cpu(btp->stale));\n\t\tXFS_WANT_CORRUPTED_RETURN(stale == be32_to_cpu(btp->stale));\n\t}\n\treturn 0;\n}"
  }
]