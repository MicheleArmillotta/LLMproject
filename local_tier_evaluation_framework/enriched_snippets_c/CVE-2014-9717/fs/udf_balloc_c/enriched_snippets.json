[
  {
    "function_name": "udf_new_block",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/balloc.c",
    "lines": "795-825",
    "snippet": "inline int udf_new_block(struct super_block *sb,\n\t\t\t struct inode *inode,\n\t\t\t uint16_t partition, uint32_t goal, int *err)\n{\n\tstruct udf_part_map *map = &UDF_SB(sb)->s_partmaps[partition];\n\tint block;\n\n\tif (map->s_partition_flags & UDF_PART_FLAG_UNALLOC_BITMAP)\n\t\tblock = udf_bitmap_new_block(sb,\n\t\t\t\t\t     map->s_uspace.s_bitmap,\n\t\t\t\t\t     partition, goal, err);\n\telse if (map->s_partition_flags & UDF_PART_FLAG_UNALLOC_TABLE)\n\t\tblock = udf_table_new_block(sb,\n\t\t\t\t\t    map->s_uspace.s_table,\n\t\t\t\t\t    partition, goal, err);\n\telse if (map->s_partition_flags & UDF_PART_FLAG_FREED_BITMAP)\n\t\tblock = udf_bitmap_new_block(sb,\n\t\t\t\t\t     map->s_fspace.s_bitmap,\n\t\t\t\t\t     partition, goal, err);\n\telse if (map->s_partition_flags & UDF_PART_FLAG_FREED_TABLE)\n\t\tblock = udf_table_new_block(sb,\n\t\t\t\t\t    map->s_fspace.s_table,\n\t\t\t\t\t    partition, goal, err);\n\telse {\n\t\t*err = -EIO;\n\t\treturn 0;\n\t}\n\tif (inode && block)\n\t\tinode_add_bytes(inode, sb->s_blocksize);\n\treturn block;\n}",
    "includes": [
      "#include \"udf_sb.h\"",
      "#include \"udf_i.h\"",
      "#include <linux/bitops.h>",
      "#include <linux/buffer_head.h>",
      "#include \"udfdecl.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "inode_add_bytes",
          "args": [
            "inode",
            "sb->s_blocksize"
          ],
          "line": 823
        },
        "resolved": true,
        "details": {
          "function_name": "inode_add_bytes",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/stat.c",
          "lines": "460-465",
          "snippet": "void inode_add_bytes(struct inode *inode, loff_t bytes)\n{\n\tspin_lock(&inode->i_lock);\n\t__inode_add_bytes(inode, bytes);\n\tspin_unlock(&inode->i_lock);\n}",
          "includes": [
            "#include <asm/unistd.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/highuid.h>",
            "#include <linux/file.h>",
            "#include <linux/errno.h>",
            "#include <linux/mm.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/unistd.h>\n#include <asm/uaccess.h>\n#include <linux/pagemap.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/highuid.h>\n#include <linux/file.h>\n#include <linux/errno.h>\n#include <linux/mm.h>\n#include <linux/export.h>\n\nvoid inode_add_bytes(struct inode *inode, loff_t bytes)\n{\n\tspin_lock(&inode->i_lock);\n\t__inode_add_bytes(inode, bytes);\n\tspin_unlock(&inode->i_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "udf_table_new_block",
          "args": [
            "sb",
            "map->s_fspace.s_table",
            "partition",
            "goal",
            "err"
          ],
          "line": 815
        },
        "resolved": true,
        "details": {
          "function_name": "udf_table_new_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/balloc.c",
          "lines": "640-730",
          "snippet": "static int udf_table_new_block(struct super_block *sb,\n\t\t\t       struct inode *table, uint16_t partition,\n\t\t\t       uint32_t goal, int *err)\n{\n\tstruct udf_sb_info *sbi = UDF_SB(sb);\n\tuint32_t spread = 0xFFFFFFFF, nspread = 0xFFFFFFFF;\n\tuint32_t newblock = 0, adsize;\n\tuint32_t elen, goal_elen = 0;\n\tstruct kernel_lb_addr eloc, uninitialized_var(goal_eloc);\n\tstruct extent_position epos, goal_epos;\n\tint8_t etype;\n\tstruct udf_inode_info *iinfo = UDF_I(table);\n\n\t*err = -ENOSPC;\n\n\tif (iinfo->i_alloc_type == ICBTAG_FLAG_AD_SHORT)\n\t\tadsize = sizeof(struct short_ad);\n\telse if (iinfo->i_alloc_type == ICBTAG_FLAG_AD_LONG)\n\t\tadsize = sizeof(struct long_ad);\n\telse\n\t\treturn newblock;\n\n\tmutex_lock(&sbi->s_alloc_mutex);\n\tif (goal >= sbi->s_partmaps[partition].s_partition_len)\n\t\tgoal = 0;\n\n\t/* We search for the closest matching block to goal. If we find\n\t   a exact hit, we stop. Otherwise we keep going till we run out\n\t   of extents. We store the buffer_head, bloc, and extoffset\n\t   of the current closest match and use that when we are done.\n\t */\n\tepos.offset = sizeof(struct unallocSpaceEntry);\n\tepos.block = iinfo->i_location;\n\tepos.bh = goal_epos.bh = NULL;\n\n\twhile (spread &&\n\t       (etype = udf_next_aext(table, &epos, &eloc, &elen, 1)) != -1) {\n\t\tif (goal >= eloc.logicalBlockNum) {\n\t\t\tif (goal < eloc.logicalBlockNum +\n\t\t\t\t\t(elen >> sb->s_blocksize_bits))\n\t\t\t\tnspread = 0;\n\t\t\telse\n\t\t\t\tnspread = goal - eloc.logicalBlockNum -\n\t\t\t\t\t(elen >> sb->s_blocksize_bits);\n\t\t} else {\n\t\t\tnspread = eloc.logicalBlockNum - goal;\n\t\t}\n\n\t\tif (nspread < spread) {\n\t\t\tspread = nspread;\n\t\t\tif (goal_epos.bh != epos.bh) {\n\t\t\t\tbrelse(goal_epos.bh);\n\t\t\t\tgoal_epos.bh = epos.bh;\n\t\t\t\tget_bh(goal_epos.bh);\n\t\t\t}\n\t\t\tgoal_epos.block = epos.block;\n\t\t\tgoal_epos.offset = epos.offset - adsize;\n\t\t\tgoal_eloc = eloc;\n\t\t\tgoal_elen = (etype << 30) | elen;\n\t\t}\n\t}\n\n\tbrelse(epos.bh);\n\n\tif (spread == 0xFFFFFFFF) {\n\t\tbrelse(goal_epos.bh);\n\t\tmutex_unlock(&sbi->s_alloc_mutex);\n\t\treturn 0;\n\t}\n\n\t/* Only allocate blocks from the beginning of the extent.\n\t   That way, we only delete (empty) extents, never have to insert an\n\t   extent because of splitting */\n\t/* This works, but very poorly.... */\n\n\tnewblock = goal_eloc.logicalBlockNum;\n\tgoal_eloc.logicalBlockNum++;\n\tgoal_elen -= sb->s_blocksize;\n\n\tif (goal_elen)\n\t\tudf_write_aext(table, &goal_epos, &goal_eloc, goal_elen, 1);\n\telse\n\t\tudf_delete_aext(table, goal_epos, goal_eloc, goal_elen);\n\tbrelse(goal_epos.bh);\n\n\tudf_add_free_space(sb, partition, -1);\n\n\tmutex_unlock(&sbi->s_alloc_mutex);\n\t*err = 0;\n\treturn newblock;\n}",
          "includes": [
            "#include \"udf_sb.h\"",
            "#include \"udf_i.h\"",
            "#include <linux/bitops.h>",
            "#include <linux/buffer_head.h>",
            "#include \"udfdecl.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"udf_sb.h\"\n#include \"udf_i.h\"\n#include <linux/bitops.h>\n#include <linux/buffer_head.h>\n#include \"udfdecl.h\"\n\nstatic int udf_table_new_block(struct super_block *sb,\n\t\t\t       struct inode *table, uint16_t partition,\n\t\t\t       uint32_t goal, int *err)\n{\n\tstruct udf_sb_info *sbi = UDF_SB(sb);\n\tuint32_t spread = 0xFFFFFFFF, nspread = 0xFFFFFFFF;\n\tuint32_t newblock = 0, adsize;\n\tuint32_t elen, goal_elen = 0;\n\tstruct kernel_lb_addr eloc, uninitialized_var(goal_eloc);\n\tstruct extent_position epos, goal_epos;\n\tint8_t etype;\n\tstruct udf_inode_info *iinfo = UDF_I(table);\n\n\t*err = -ENOSPC;\n\n\tif (iinfo->i_alloc_type == ICBTAG_FLAG_AD_SHORT)\n\t\tadsize = sizeof(struct short_ad);\n\telse if (iinfo->i_alloc_type == ICBTAG_FLAG_AD_LONG)\n\t\tadsize = sizeof(struct long_ad);\n\telse\n\t\treturn newblock;\n\n\tmutex_lock(&sbi->s_alloc_mutex);\n\tif (goal >= sbi->s_partmaps[partition].s_partition_len)\n\t\tgoal = 0;\n\n\t/* We search for the closest matching block to goal. If we find\n\t   a exact hit, we stop. Otherwise we keep going till we run out\n\t   of extents. We store the buffer_head, bloc, and extoffset\n\t   of the current closest match and use that when we are done.\n\t */\n\tepos.offset = sizeof(struct unallocSpaceEntry);\n\tepos.block = iinfo->i_location;\n\tepos.bh = goal_epos.bh = NULL;\n\n\twhile (spread &&\n\t       (etype = udf_next_aext(table, &epos, &eloc, &elen, 1)) != -1) {\n\t\tif (goal >= eloc.logicalBlockNum) {\n\t\t\tif (goal < eloc.logicalBlockNum +\n\t\t\t\t\t(elen >> sb->s_blocksize_bits))\n\t\t\t\tnspread = 0;\n\t\t\telse\n\t\t\t\tnspread = goal - eloc.logicalBlockNum -\n\t\t\t\t\t(elen >> sb->s_blocksize_bits);\n\t\t} else {\n\t\t\tnspread = eloc.logicalBlockNum - goal;\n\t\t}\n\n\t\tif (nspread < spread) {\n\t\t\tspread = nspread;\n\t\t\tif (goal_epos.bh != epos.bh) {\n\t\t\t\tbrelse(goal_epos.bh);\n\t\t\t\tgoal_epos.bh = epos.bh;\n\t\t\t\tget_bh(goal_epos.bh);\n\t\t\t}\n\t\t\tgoal_epos.block = epos.block;\n\t\t\tgoal_epos.offset = epos.offset - adsize;\n\t\t\tgoal_eloc = eloc;\n\t\t\tgoal_elen = (etype << 30) | elen;\n\t\t}\n\t}\n\n\tbrelse(epos.bh);\n\n\tif (spread == 0xFFFFFFFF) {\n\t\tbrelse(goal_epos.bh);\n\t\tmutex_unlock(&sbi->s_alloc_mutex);\n\t\treturn 0;\n\t}\n\n\t/* Only allocate blocks from the beginning of the extent.\n\t   That way, we only delete (empty) extents, never have to insert an\n\t   extent because of splitting */\n\t/* This works, but very poorly.... */\n\n\tnewblock = goal_eloc.logicalBlockNum;\n\tgoal_eloc.logicalBlockNum++;\n\tgoal_elen -= sb->s_blocksize;\n\n\tif (goal_elen)\n\t\tudf_write_aext(table, &goal_epos, &goal_eloc, goal_elen, 1);\n\telse\n\t\tudf_delete_aext(table, goal_epos, goal_eloc, goal_elen);\n\tbrelse(goal_epos.bh);\n\n\tudf_add_free_space(sb, partition, -1);\n\n\tmutex_unlock(&sbi->s_alloc_mutex);\n\t*err = 0;\n\treturn newblock;\n}"
        }
      },
      {
        "call_info": {
          "callee": "udf_bitmap_new_block",
          "args": [
            "sb",
            "map->s_fspace.s_bitmap",
            "partition",
            "goal",
            "err"
          ],
          "line": 811
        },
        "resolved": true,
        "details": {
          "function_name": "udf_bitmap_new_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/balloc.c",
          "lines": "223-346",
          "snippet": "static int udf_bitmap_new_block(struct super_block *sb,\n\t\t\t\tstruct udf_bitmap *bitmap, uint16_t partition,\n\t\t\t\tuint32_t goal, int *err)\n{\n\tstruct udf_sb_info *sbi = UDF_SB(sb);\n\tint newbit, bit = 0, block, block_group, group_start;\n\tint end_goal, nr_groups, bitmap_nr, i;\n\tstruct buffer_head *bh = NULL;\n\tchar *ptr;\n\tint newblock = 0;\n\n\t*err = -ENOSPC;\n\tmutex_lock(&sbi->s_alloc_mutex);\n\nrepeat:\n\tif (goal >= sbi->s_partmaps[partition].s_partition_len)\n\t\tgoal = 0;\n\n\tnr_groups = bitmap->s_nr_groups;\n\tblock = goal + (sizeof(struct spaceBitmapDesc) << 3);\n\tblock_group = block >> (sb->s_blocksize_bits + 3);\n\tgroup_start = block_group ? 0 : sizeof(struct spaceBitmapDesc);\n\n\tbitmap_nr = load_block_bitmap(sb, bitmap, block_group);\n\tif (bitmap_nr < 0)\n\t\tgoto error_return;\n\tbh = bitmap->s_block_bitmap[bitmap_nr];\n\tptr = memscan((char *)bh->b_data + group_start, 0xFF,\n\t\t      sb->s_blocksize - group_start);\n\n\tif ((ptr - ((char *)bh->b_data)) < sb->s_blocksize) {\n\t\tbit = block % (sb->s_blocksize << 3);\n\t\tif (udf_test_bit(bit, bh->b_data))\n\t\t\tgoto got_block;\n\n\t\tend_goal = (bit + 63) & ~63;\n\t\tbit = udf_find_next_one_bit(bh->b_data, end_goal, bit);\n\t\tif (bit < end_goal)\n\t\t\tgoto got_block;\n\n\t\tptr = memscan((char *)bh->b_data + (bit >> 3), 0xFF,\n\t\t\t      sb->s_blocksize - ((bit + 7) >> 3));\n\t\tnewbit = (ptr - ((char *)bh->b_data)) << 3;\n\t\tif (newbit < sb->s_blocksize << 3) {\n\t\t\tbit = newbit;\n\t\t\tgoto search_back;\n\t\t}\n\n\t\tnewbit = udf_find_next_one_bit(bh->b_data,\n\t\t\t\t\t       sb->s_blocksize << 3, bit);\n\t\tif (newbit < sb->s_blocksize << 3) {\n\t\t\tbit = newbit;\n\t\t\tgoto got_block;\n\t\t}\n\t}\n\n\tfor (i = 0; i < (nr_groups * 2); i++) {\n\t\tblock_group++;\n\t\tif (block_group >= nr_groups)\n\t\t\tblock_group = 0;\n\t\tgroup_start = block_group ? 0 : sizeof(struct spaceBitmapDesc);\n\n\t\tbitmap_nr = load_block_bitmap(sb, bitmap, block_group);\n\t\tif (bitmap_nr < 0)\n\t\t\tgoto error_return;\n\t\tbh = bitmap->s_block_bitmap[bitmap_nr];\n\t\tif (i < nr_groups) {\n\t\t\tptr = memscan((char *)bh->b_data + group_start, 0xFF,\n\t\t\t\t      sb->s_blocksize - group_start);\n\t\t\tif ((ptr - ((char *)bh->b_data)) < sb->s_blocksize) {\n\t\t\t\tbit = (ptr - ((char *)bh->b_data)) << 3;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} else {\n\t\t\tbit = udf_find_next_one_bit(bh->b_data,\n\t\t\t\t\t\t    sb->s_blocksize << 3,\n\t\t\t\t\t\t    group_start << 3);\n\t\t\tif (bit < sb->s_blocksize << 3)\n\t\t\t\tbreak;\n\t\t}\n\t}\n\tif (i >= (nr_groups * 2)) {\n\t\tmutex_unlock(&sbi->s_alloc_mutex);\n\t\treturn newblock;\n\t}\n\tif (bit < sb->s_blocksize << 3)\n\t\tgoto search_back;\n\telse\n\t\tbit = udf_find_next_one_bit(bh->b_data, sb->s_blocksize << 3,\n\t\t\t\t\t    group_start << 3);\n\tif (bit >= sb->s_blocksize << 3) {\n\t\tmutex_unlock(&sbi->s_alloc_mutex);\n\t\treturn 0;\n\t}\n\nsearch_back:\n\ti = 0;\n\twhile (i < 7 && bit > (group_start << 3) &&\n\t       udf_test_bit(bit - 1, bh->b_data)) {\n\t\t++i;\n\t\t--bit;\n\t}\n\ngot_block:\n\tnewblock = bit + (block_group << (sb->s_blocksize_bits + 3)) -\n\t\t(sizeof(struct spaceBitmapDesc) << 3);\n\n\tif (!udf_clear_bit(bit, bh->b_data)) {\n\t\tudf_debug(\"bit already cleared for block %d\\n\", bit);\n\t\tgoto repeat;\n\t}\n\n\tmark_buffer_dirty(bh);\n\n\tudf_add_free_space(sb, partition, -1);\n\tmutex_unlock(&sbi->s_alloc_mutex);\n\t*err = 0;\n\treturn newblock;\n\nerror_return:\n\t*err = -EIO;\n\tmutex_unlock(&sbi->s_alloc_mutex);\n\treturn 0;\n}",
          "includes": [
            "#include \"udf_sb.h\"",
            "#include \"udf_i.h\"",
            "#include <linux/bitops.h>",
            "#include <linux/buffer_head.h>",
            "#include \"udfdecl.h\""
          ],
          "macros_used": [
            "#define udf_find_next_one_bit\tfind_next_bit_le",
            "#define udf_test_bit\ttest_bit_le",
            "#define udf_clear_bit\t__test_and_clear_bit_le"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"udf_sb.h\"\n#include \"udf_i.h\"\n#include <linux/bitops.h>\n#include <linux/buffer_head.h>\n#include \"udfdecl.h\"\n\n#define udf_find_next_one_bit\tfind_next_bit_le\n#define udf_test_bit\ttest_bit_le\n#define udf_clear_bit\t__test_and_clear_bit_le\n\nstatic int udf_bitmap_new_block(struct super_block *sb,\n\t\t\t\tstruct udf_bitmap *bitmap, uint16_t partition,\n\t\t\t\tuint32_t goal, int *err)\n{\n\tstruct udf_sb_info *sbi = UDF_SB(sb);\n\tint newbit, bit = 0, block, block_group, group_start;\n\tint end_goal, nr_groups, bitmap_nr, i;\n\tstruct buffer_head *bh = NULL;\n\tchar *ptr;\n\tint newblock = 0;\n\n\t*err = -ENOSPC;\n\tmutex_lock(&sbi->s_alloc_mutex);\n\nrepeat:\n\tif (goal >= sbi->s_partmaps[partition].s_partition_len)\n\t\tgoal = 0;\n\n\tnr_groups = bitmap->s_nr_groups;\n\tblock = goal + (sizeof(struct spaceBitmapDesc) << 3);\n\tblock_group = block >> (sb->s_blocksize_bits + 3);\n\tgroup_start = block_group ? 0 : sizeof(struct spaceBitmapDesc);\n\n\tbitmap_nr = load_block_bitmap(sb, bitmap, block_group);\n\tif (bitmap_nr < 0)\n\t\tgoto error_return;\n\tbh = bitmap->s_block_bitmap[bitmap_nr];\n\tptr = memscan((char *)bh->b_data + group_start, 0xFF,\n\t\t      sb->s_blocksize - group_start);\n\n\tif ((ptr - ((char *)bh->b_data)) < sb->s_blocksize) {\n\t\tbit = block % (sb->s_blocksize << 3);\n\t\tif (udf_test_bit(bit, bh->b_data))\n\t\t\tgoto got_block;\n\n\t\tend_goal = (bit + 63) & ~63;\n\t\tbit = udf_find_next_one_bit(bh->b_data, end_goal, bit);\n\t\tif (bit < end_goal)\n\t\t\tgoto got_block;\n\n\t\tptr = memscan((char *)bh->b_data + (bit >> 3), 0xFF,\n\t\t\t      sb->s_blocksize - ((bit + 7) >> 3));\n\t\tnewbit = (ptr - ((char *)bh->b_data)) << 3;\n\t\tif (newbit < sb->s_blocksize << 3) {\n\t\t\tbit = newbit;\n\t\t\tgoto search_back;\n\t\t}\n\n\t\tnewbit = udf_find_next_one_bit(bh->b_data,\n\t\t\t\t\t       sb->s_blocksize << 3, bit);\n\t\tif (newbit < sb->s_blocksize << 3) {\n\t\t\tbit = newbit;\n\t\t\tgoto got_block;\n\t\t}\n\t}\n\n\tfor (i = 0; i < (nr_groups * 2); i++) {\n\t\tblock_group++;\n\t\tif (block_group >= nr_groups)\n\t\t\tblock_group = 0;\n\t\tgroup_start = block_group ? 0 : sizeof(struct spaceBitmapDesc);\n\n\t\tbitmap_nr = load_block_bitmap(sb, bitmap, block_group);\n\t\tif (bitmap_nr < 0)\n\t\t\tgoto error_return;\n\t\tbh = bitmap->s_block_bitmap[bitmap_nr];\n\t\tif (i < nr_groups) {\n\t\t\tptr = memscan((char *)bh->b_data + group_start, 0xFF,\n\t\t\t\t      sb->s_blocksize - group_start);\n\t\t\tif ((ptr - ((char *)bh->b_data)) < sb->s_blocksize) {\n\t\t\t\tbit = (ptr - ((char *)bh->b_data)) << 3;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} else {\n\t\t\tbit = udf_find_next_one_bit(bh->b_data,\n\t\t\t\t\t\t    sb->s_blocksize << 3,\n\t\t\t\t\t\t    group_start << 3);\n\t\t\tif (bit < sb->s_blocksize << 3)\n\t\t\t\tbreak;\n\t\t}\n\t}\n\tif (i >= (nr_groups * 2)) {\n\t\tmutex_unlock(&sbi->s_alloc_mutex);\n\t\treturn newblock;\n\t}\n\tif (bit < sb->s_blocksize << 3)\n\t\tgoto search_back;\n\telse\n\t\tbit = udf_find_next_one_bit(bh->b_data, sb->s_blocksize << 3,\n\t\t\t\t\t    group_start << 3);\n\tif (bit >= sb->s_blocksize << 3) {\n\t\tmutex_unlock(&sbi->s_alloc_mutex);\n\t\treturn 0;\n\t}\n\nsearch_back:\n\ti = 0;\n\twhile (i < 7 && bit > (group_start << 3) &&\n\t       udf_test_bit(bit - 1, bh->b_data)) {\n\t\t++i;\n\t\t--bit;\n\t}\n\ngot_block:\n\tnewblock = bit + (block_group << (sb->s_blocksize_bits + 3)) -\n\t\t(sizeof(struct spaceBitmapDesc) << 3);\n\n\tif (!udf_clear_bit(bit, bh->b_data)) {\n\t\tudf_debug(\"bit already cleared for block %d\\n\", bit);\n\t\tgoto repeat;\n\t}\n\n\tmark_buffer_dirty(bh);\n\n\tudf_add_free_space(sb, partition, -1);\n\tmutex_unlock(&sbi->s_alloc_mutex);\n\t*err = 0;\n\treturn newblock;\n\nerror_return:\n\t*err = -EIO;\n\tmutex_unlock(&sbi->s_alloc_mutex);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "UDF_SB",
          "args": [
            "sb"
          ],
          "line": 799
        },
        "resolved": true,
        "details": {
          "function_name": "UDF_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/udf_sb.h",
          "lines": "160-163",
          "snippet": "static inline struct udf_sb_info *UDF_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include <linux/bitops.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bitops.h>\n#include <linux/mutex.h>\n\nstatic inline struct udf_sb_info *UDF_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"udf_sb.h\"\n#include \"udf_i.h\"\n#include <linux/bitops.h>\n#include <linux/buffer_head.h>\n#include \"udfdecl.h\"\n\ninline int udf_new_block(struct super_block *sb,\n\t\t\t struct inode *inode,\n\t\t\t uint16_t partition, uint32_t goal, int *err)\n{\n\tstruct udf_part_map *map = &UDF_SB(sb)->s_partmaps[partition];\n\tint block;\n\n\tif (map->s_partition_flags & UDF_PART_FLAG_UNALLOC_BITMAP)\n\t\tblock = udf_bitmap_new_block(sb,\n\t\t\t\t\t     map->s_uspace.s_bitmap,\n\t\t\t\t\t     partition, goal, err);\n\telse if (map->s_partition_flags & UDF_PART_FLAG_UNALLOC_TABLE)\n\t\tblock = udf_table_new_block(sb,\n\t\t\t\t\t    map->s_uspace.s_table,\n\t\t\t\t\t    partition, goal, err);\n\telse if (map->s_partition_flags & UDF_PART_FLAG_FREED_BITMAP)\n\t\tblock = udf_bitmap_new_block(sb,\n\t\t\t\t\t     map->s_fspace.s_bitmap,\n\t\t\t\t\t     partition, goal, err);\n\telse if (map->s_partition_flags & UDF_PART_FLAG_FREED_TABLE)\n\t\tblock = udf_table_new_block(sb,\n\t\t\t\t\t    map->s_fspace.s_table,\n\t\t\t\t\t    partition, goal, err);\n\telse {\n\t\t*err = -EIO;\n\t\treturn 0;\n\t}\n\tif (inode && block)\n\t\tinode_add_bytes(inode, sb->s_blocksize);\n\treturn block;\n}"
  },
  {
    "function_name": "udf_prealloc_blocks",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/balloc.c",
    "lines": "759-793",
    "snippet": "inline int udf_prealloc_blocks(struct super_block *sb,\n\t\t\t       struct inode *inode,\n\t\t\t       uint16_t partition, uint32_t first_block,\n\t\t\t       uint32_t block_count)\n{\n\tstruct udf_part_map *map = &UDF_SB(sb)->s_partmaps[partition];\n\tsector_t allocated;\n\n\tif (map->s_partition_flags & UDF_PART_FLAG_UNALLOC_BITMAP)\n\t\tallocated = udf_bitmap_prealloc_blocks(sb,\n\t\t\t\t\t\t       map->s_uspace.s_bitmap,\n\t\t\t\t\t\t       partition, first_block,\n\t\t\t\t\t\t       block_count);\n\telse if (map->s_partition_flags & UDF_PART_FLAG_UNALLOC_TABLE)\n\t\tallocated = udf_table_prealloc_blocks(sb,\n\t\t\t\t\t\t      map->s_uspace.s_table,\n\t\t\t\t\t\t      partition, first_block,\n\t\t\t\t\t\t      block_count);\n\telse if (map->s_partition_flags & UDF_PART_FLAG_FREED_BITMAP)\n\t\tallocated = udf_bitmap_prealloc_blocks(sb,\n\t\t\t\t\t\t       map->s_fspace.s_bitmap,\n\t\t\t\t\t\t       partition, first_block,\n\t\t\t\t\t\t       block_count);\n\telse if (map->s_partition_flags & UDF_PART_FLAG_FREED_TABLE)\n\t\tallocated = udf_table_prealloc_blocks(sb,\n\t\t\t\t\t\t      map->s_fspace.s_table,\n\t\t\t\t\t\t      partition, first_block,\n\t\t\t\t\t\t      block_count);\n\telse\n\t\treturn 0;\n\n\tif (inode && allocated > 0)\n\t\tinode_add_bytes(inode, allocated << sb->s_blocksize_bits);\n\treturn allocated;\n}",
    "includes": [
      "#include \"udf_sb.h\"",
      "#include \"udf_i.h\"",
      "#include <linux/bitops.h>",
      "#include <linux/buffer_head.h>",
      "#include \"udfdecl.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "inode_add_bytes",
          "args": [
            "inode",
            "allocated << sb->s_blocksize_bits"
          ],
          "line": 791
        },
        "resolved": true,
        "details": {
          "function_name": "inode_add_bytes",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/stat.c",
          "lines": "460-465",
          "snippet": "void inode_add_bytes(struct inode *inode, loff_t bytes)\n{\n\tspin_lock(&inode->i_lock);\n\t__inode_add_bytes(inode, bytes);\n\tspin_unlock(&inode->i_lock);\n}",
          "includes": [
            "#include <asm/unistd.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/highuid.h>",
            "#include <linux/file.h>",
            "#include <linux/errno.h>",
            "#include <linux/mm.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/unistd.h>\n#include <asm/uaccess.h>\n#include <linux/pagemap.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/highuid.h>\n#include <linux/file.h>\n#include <linux/errno.h>\n#include <linux/mm.h>\n#include <linux/export.h>\n\nvoid inode_add_bytes(struct inode *inode, loff_t bytes)\n{\n\tspin_lock(&inode->i_lock);\n\t__inode_add_bytes(inode, bytes);\n\tspin_unlock(&inode->i_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "udf_table_prealloc_blocks",
          "args": [
            "sb",
            "map->s_fspace.s_table",
            "partition",
            "first_block",
            "block_count"
          ],
          "line": 783
        },
        "resolved": true,
        "details": {
          "function_name": "udf_table_prealloc_blocks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/balloc.c",
          "lines": "579-638",
          "snippet": "static int udf_table_prealloc_blocks(struct super_block *sb,\n\t\t\t\t     struct inode *table, uint16_t partition,\n\t\t\t\t     uint32_t first_block, uint32_t block_count)\n{\n\tstruct udf_sb_info *sbi = UDF_SB(sb);\n\tint alloc_count = 0;\n\tuint32_t elen, adsize;\n\tstruct kernel_lb_addr eloc;\n\tstruct extent_position epos;\n\tint8_t etype = -1;\n\tstruct udf_inode_info *iinfo;\n\n\tif (first_block >= sbi->s_partmaps[partition].s_partition_len)\n\t\treturn 0;\n\n\tiinfo = UDF_I(table);\n\tif (iinfo->i_alloc_type == ICBTAG_FLAG_AD_SHORT)\n\t\tadsize = sizeof(struct short_ad);\n\telse if (iinfo->i_alloc_type == ICBTAG_FLAG_AD_LONG)\n\t\tadsize = sizeof(struct long_ad);\n\telse\n\t\treturn 0;\n\n\tmutex_lock(&sbi->s_alloc_mutex);\n\tepos.offset = sizeof(struct unallocSpaceEntry);\n\tepos.block = iinfo->i_location;\n\tepos.bh = NULL;\n\teloc.logicalBlockNum = 0xFFFFFFFF;\n\n\twhile (first_block != eloc.logicalBlockNum &&\n\t       (etype = udf_next_aext(table, &epos, &eloc, &elen, 1)) != -1) {\n\t\tudf_debug(\"eloc=%d, elen=%d, first_block=%d\\n\",\n\t\t\t  eloc.logicalBlockNum, elen, first_block);\n\t\t; /* empty loop body */\n\t}\n\n\tif (first_block == eloc.logicalBlockNum) {\n\t\tepos.offset -= adsize;\n\n\t\talloc_count = (elen >> sb->s_blocksize_bits);\n\t\tif (alloc_count > block_count) {\n\t\t\talloc_count = block_count;\n\t\t\teloc.logicalBlockNum += alloc_count;\n\t\t\telen -= (alloc_count << sb->s_blocksize_bits);\n\t\t\tudf_write_aext(table, &epos, &eloc,\n\t\t\t\t\t(etype << 30) | elen, 1);\n\t\t} else\n\t\t\tudf_delete_aext(table, epos, eloc,\n\t\t\t\t\t(etype << 30) | elen);\n\t} else {\n\t\talloc_count = 0;\n\t}\n\n\tbrelse(epos.bh);\n\n\tif (alloc_count)\n\t\tudf_add_free_space(sb, partition, -alloc_count);\n\tmutex_unlock(&sbi->s_alloc_mutex);\n\treturn alloc_count;\n}",
          "includes": [
            "#include \"udf_sb.h\"",
            "#include \"udf_i.h\"",
            "#include <linux/bitops.h>",
            "#include <linux/buffer_head.h>",
            "#include \"udfdecl.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"udf_sb.h\"\n#include \"udf_i.h\"\n#include <linux/bitops.h>\n#include <linux/buffer_head.h>\n#include \"udfdecl.h\"\n\nstatic int udf_table_prealloc_blocks(struct super_block *sb,\n\t\t\t\t     struct inode *table, uint16_t partition,\n\t\t\t\t     uint32_t first_block, uint32_t block_count)\n{\n\tstruct udf_sb_info *sbi = UDF_SB(sb);\n\tint alloc_count = 0;\n\tuint32_t elen, adsize;\n\tstruct kernel_lb_addr eloc;\n\tstruct extent_position epos;\n\tint8_t etype = -1;\n\tstruct udf_inode_info *iinfo;\n\n\tif (first_block >= sbi->s_partmaps[partition].s_partition_len)\n\t\treturn 0;\n\n\tiinfo = UDF_I(table);\n\tif (iinfo->i_alloc_type == ICBTAG_FLAG_AD_SHORT)\n\t\tadsize = sizeof(struct short_ad);\n\telse if (iinfo->i_alloc_type == ICBTAG_FLAG_AD_LONG)\n\t\tadsize = sizeof(struct long_ad);\n\telse\n\t\treturn 0;\n\n\tmutex_lock(&sbi->s_alloc_mutex);\n\tepos.offset = sizeof(struct unallocSpaceEntry);\n\tepos.block = iinfo->i_location;\n\tepos.bh = NULL;\n\teloc.logicalBlockNum = 0xFFFFFFFF;\n\n\twhile (first_block != eloc.logicalBlockNum &&\n\t       (etype = udf_next_aext(table, &epos, &eloc, &elen, 1)) != -1) {\n\t\tudf_debug(\"eloc=%d, elen=%d, first_block=%d\\n\",\n\t\t\t  eloc.logicalBlockNum, elen, first_block);\n\t\t; /* empty loop body */\n\t}\n\n\tif (first_block == eloc.logicalBlockNum) {\n\t\tepos.offset -= adsize;\n\n\t\talloc_count = (elen >> sb->s_blocksize_bits);\n\t\tif (alloc_count > block_count) {\n\t\t\talloc_count = block_count;\n\t\t\teloc.logicalBlockNum += alloc_count;\n\t\t\telen -= (alloc_count << sb->s_blocksize_bits);\n\t\t\tudf_write_aext(table, &epos, &eloc,\n\t\t\t\t\t(etype << 30) | elen, 1);\n\t\t} else\n\t\t\tudf_delete_aext(table, epos, eloc,\n\t\t\t\t\t(etype << 30) | elen);\n\t} else {\n\t\talloc_count = 0;\n\t}\n\n\tbrelse(epos.bh);\n\n\tif (alloc_count)\n\t\tudf_add_free_space(sb, partition, -alloc_count);\n\tmutex_unlock(&sbi->s_alloc_mutex);\n\treturn alloc_count;\n}"
        }
      },
      {
        "call_info": {
          "callee": "udf_bitmap_prealloc_blocks",
          "args": [
            "sb",
            "map->s_fspace.s_bitmap",
            "partition",
            "first_block",
            "block_count"
          ],
          "line": 778
        },
        "resolved": true,
        "details": {
          "function_name": "udf_bitmap_prealloc_blocks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/balloc.c",
          "lines": "173-221",
          "snippet": "static int udf_bitmap_prealloc_blocks(struct super_block *sb,\n\t\t\t\t      struct udf_bitmap *bitmap,\n\t\t\t\t      uint16_t partition, uint32_t first_block,\n\t\t\t\t      uint32_t block_count)\n{\n\tstruct udf_sb_info *sbi = UDF_SB(sb);\n\tint alloc_count = 0;\n\tint bit, block, block_group, group_start;\n\tint nr_groups, bitmap_nr;\n\tstruct buffer_head *bh;\n\t__u32 part_len;\n\n\tmutex_lock(&sbi->s_alloc_mutex);\n\tpart_len = sbi->s_partmaps[partition].s_partition_len;\n\tif (first_block >= part_len)\n\t\tgoto out;\n\n\tif (first_block + block_count > part_len)\n\t\tblock_count = part_len - first_block;\n\n\tdo {\n\t\tnr_groups = udf_compute_nr_groups(sb, partition);\n\t\tblock = first_block + (sizeof(struct spaceBitmapDesc) << 3);\n\t\tblock_group = block >> (sb->s_blocksize_bits + 3);\n\t\tgroup_start = block_group ? 0 : sizeof(struct spaceBitmapDesc);\n\n\t\tbitmap_nr = load_block_bitmap(sb, bitmap, block_group);\n\t\tif (bitmap_nr < 0)\n\t\t\tgoto out;\n\t\tbh = bitmap->s_block_bitmap[bitmap_nr];\n\n\t\tbit = block % (sb->s_blocksize << 3);\n\n\t\twhile (bit < (sb->s_blocksize << 3) && block_count > 0) {\n\t\t\tif (!udf_clear_bit(bit, bh->b_data))\n\t\t\t\tgoto out;\n\t\t\tblock_count--;\n\t\t\talloc_count++;\n\t\t\tbit++;\n\t\t\tblock++;\n\t\t}\n\t\tmark_buffer_dirty(bh);\n\t} while (block_count > 0);\n\nout:\n\tudf_add_free_space(sb, partition, -alloc_count);\n\tmutex_unlock(&sbi->s_alloc_mutex);\n\treturn alloc_count;\n}",
          "includes": [
            "#include \"udf_sb.h\"",
            "#include \"udf_i.h\"",
            "#include <linux/bitops.h>",
            "#include <linux/buffer_head.h>",
            "#include \"udfdecl.h\""
          ],
          "macros_used": [
            "#define udf_clear_bit\t__test_and_clear_bit_le"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"udf_sb.h\"\n#include \"udf_i.h\"\n#include <linux/bitops.h>\n#include <linux/buffer_head.h>\n#include \"udfdecl.h\"\n\n#define udf_clear_bit\t__test_and_clear_bit_le\n\nstatic int udf_bitmap_prealloc_blocks(struct super_block *sb,\n\t\t\t\t      struct udf_bitmap *bitmap,\n\t\t\t\t      uint16_t partition, uint32_t first_block,\n\t\t\t\t      uint32_t block_count)\n{\n\tstruct udf_sb_info *sbi = UDF_SB(sb);\n\tint alloc_count = 0;\n\tint bit, block, block_group, group_start;\n\tint nr_groups, bitmap_nr;\n\tstruct buffer_head *bh;\n\t__u32 part_len;\n\n\tmutex_lock(&sbi->s_alloc_mutex);\n\tpart_len = sbi->s_partmaps[partition].s_partition_len;\n\tif (first_block >= part_len)\n\t\tgoto out;\n\n\tif (first_block + block_count > part_len)\n\t\tblock_count = part_len - first_block;\n\n\tdo {\n\t\tnr_groups = udf_compute_nr_groups(sb, partition);\n\t\tblock = first_block + (sizeof(struct spaceBitmapDesc) << 3);\n\t\tblock_group = block >> (sb->s_blocksize_bits + 3);\n\t\tgroup_start = block_group ? 0 : sizeof(struct spaceBitmapDesc);\n\n\t\tbitmap_nr = load_block_bitmap(sb, bitmap, block_group);\n\t\tif (bitmap_nr < 0)\n\t\t\tgoto out;\n\t\tbh = bitmap->s_block_bitmap[bitmap_nr];\n\n\t\tbit = block % (sb->s_blocksize << 3);\n\n\t\twhile (bit < (sb->s_blocksize << 3) && block_count > 0) {\n\t\t\tif (!udf_clear_bit(bit, bh->b_data))\n\t\t\t\tgoto out;\n\t\t\tblock_count--;\n\t\t\talloc_count++;\n\t\t\tbit++;\n\t\t\tblock++;\n\t\t}\n\t\tmark_buffer_dirty(bh);\n\t} while (block_count > 0);\n\nout:\n\tudf_add_free_space(sb, partition, -alloc_count);\n\tmutex_unlock(&sbi->s_alloc_mutex);\n\treturn alloc_count;\n}"
        }
      },
      {
        "call_info": {
          "callee": "UDF_SB",
          "args": [
            "sb"
          ],
          "line": 764
        },
        "resolved": true,
        "details": {
          "function_name": "UDF_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/udf_sb.h",
          "lines": "160-163",
          "snippet": "static inline struct udf_sb_info *UDF_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include <linux/bitops.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bitops.h>\n#include <linux/mutex.h>\n\nstatic inline struct udf_sb_info *UDF_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"udf_sb.h\"\n#include \"udf_i.h\"\n#include <linux/bitops.h>\n#include <linux/buffer_head.h>\n#include \"udfdecl.h\"\n\ninline int udf_prealloc_blocks(struct super_block *sb,\n\t\t\t       struct inode *inode,\n\t\t\t       uint16_t partition, uint32_t first_block,\n\t\t\t       uint32_t block_count)\n{\n\tstruct udf_part_map *map = &UDF_SB(sb)->s_partmaps[partition];\n\tsector_t allocated;\n\n\tif (map->s_partition_flags & UDF_PART_FLAG_UNALLOC_BITMAP)\n\t\tallocated = udf_bitmap_prealloc_blocks(sb,\n\t\t\t\t\t\t       map->s_uspace.s_bitmap,\n\t\t\t\t\t\t       partition, first_block,\n\t\t\t\t\t\t       block_count);\n\telse if (map->s_partition_flags & UDF_PART_FLAG_UNALLOC_TABLE)\n\t\tallocated = udf_table_prealloc_blocks(sb,\n\t\t\t\t\t\t      map->s_uspace.s_table,\n\t\t\t\t\t\t      partition, first_block,\n\t\t\t\t\t\t      block_count);\n\telse if (map->s_partition_flags & UDF_PART_FLAG_FREED_BITMAP)\n\t\tallocated = udf_bitmap_prealloc_blocks(sb,\n\t\t\t\t\t\t       map->s_fspace.s_bitmap,\n\t\t\t\t\t\t       partition, first_block,\n\t\t\t\t\t\t       block_count);\n\telse if (map->s_partition_flags & UDF_PART_FLAG_FREED_TABLE)\n\t\tallocated = udf_table_prealloc_blocks(sb,\n\t\t\t\t\t\t      map->s_fspace.s_table,\n\t\t\t\t\t\t      partition, first_block,\n\t\t\t\t\t\t      block_count);\n\telse\n\t\treturn 0;\n\n\tif (inode && allocated > 0)\n\t\tinode_add_bytes(inode, allocated << sb->s_blocksize_bits);\n\treturn allocated;\n}"
  },
  {
    "function_name": "udf_free_blocks",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/balloc.c",
    "lines": "732-757",
    "snippet": "void udf_free_blocks(struct super_block *sb, struct inode *inode,\n\t\t     struct kernel_lb_addr *bloc, uint32_t offset,\n\t\t     uint32_t count)\n{\n\tuint16_t partition = bloc->partitionReferenceNum;\n\tstruct udf_part_map *map = &UDF_SB(sb)->s_partmaps[partition];\n\n\tif (map->s_partition_flags & UDF_PART_FLAG_UNALLOC_BITMAP) {\n\t\tudf_bitmap_free_blocks(sb, map->s_uspace.s_bitmap,\n\t\t\t\t       bloc, offset, count);\n\t} else if (map->s_partition_flags & UDF_PART_FLAG_UNALLOC_TABLE) {\n\t\tudf_table_free_blocks(sb, map->s_uspace.s_table,\n\t\t\t\t      bloc, offset, count);\n\t} else if (map->s_partition_flags & UDF_PART_FLAG_FREED_BITMAP) {\n\t\tudf_bitmap_free_blocks(sb, map->s_fspace.s_bitmap,\n\t\t\t\t       bloc, offset, count);\n\t} else if (map->s_partition_flags & UDF_PART_FLAG_FREED_TABLE) {\n\t\tudf_table_free_blocks(sb, map->s_fspace.s_table,\n\t\t\t\t      bloc, offset, count);\n\t}\n\n\tif (inode) {\n\t\tinode_sub_bytes(inode,\n\t\t\t\t((sector_t)count) << sb->s_blocksize_bits);\n\t}\n}",
    "includes": [
      "#include \"udf_sb.h\"",
      "#include \"udf_i.h\"",
      "#include <linux/bitops.h>",
      "#include <linux/buffer_head.h>",
      "#include \"udfdecl.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "inode_sub_bytes",
          "args": [
            "inode",
            "((sector_t)count) << sb->s_blocksize_bits"
          ],
          "line": 754
        },
        "resolved": true,
        "details": {
          "function_name": "inode_sub_bytes",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/stat.c",
          "lines": "482-487",
          "snippet": "void inode_sub_bytes(struct inode *inode, loff_t bytes)\n{\n\tspin_lock(&inode->i_lock);\n\t__inode_sub_bytes(inode, bytes);\n\tspin_unlock(&inode->i_lock);\n}",
          "includes": [
            "#include <asm/unistd.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/highuid.h>",
            "#include <linux/file.h>",
            "#include <linux/errno.h>",
            "#include <linux/mm.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/unistd.h>\n#include <asm/uaccess.h>\n#include <linux/pagemap.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/highuid.h>\n#include <linux/file.h>\n#include <linux/errno.h>\n#include <linux/mm.h>\n#include <linux/export.h>\n\nvoid inode_sub_bytes(struct inode *inode, loff_t bytes)\n{\n\tspin_lock(&inode->i_lock);\n\t__inode_sub_bytes(inode, bytes);\n\tspin_unlock(&inode->i_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "udf_table_free_blocks",
          "args": [
            "sb",
            "map->s_fspace.s_table",
            "bloc",
            "offset",
            "count"
          ],
          "line": 749
        },
        "resolved": true,
        "details": {
          "function_name": "udf_table_free_blocks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/balloc.c",
          "lines": "348-577",
          "snippet": "static void udf_table_free_blocks(struct super_block *sb,\n\t\t\t\t  struct inode *table,\n\t\t\t\t  struct kernel_lb_addr *bloc,\n\t\t\t\t  uint32_t offset,\n\t\t\t\t  uint32_t count)\n{\n\tstruct udf_sb_info *sbi = UDF_SB(sb);\n\tstruct udf_part_map *partmap;\n\tuint32_t start, end;\n\tuint32_t elen;\n\tstruct kernel_lb_addr eloc;\n\tstruct extent_position oepos, epos;\n\tint8_t etype;\n\tint i;\n\tstruct udf_inode_info *iinfo;\n\n\tmutex_lock(&sbi->s_alloc_mutex);\n\tpartmap = &sbi->s_partmaps[bloc->partitionReferenceNum];\n\tif (bloc->logicalBlockNum + count < count ||\n\t    (bloc->logicalBlockNum + count) > partmap->s_partition_len) {\n\t\tudf_debug(\"%d < %d || %d + %d > %d\\n\",\n\t\t\t  bloc->logicalBlockNum, 0,\n\t\t\t  bloc->logicalBlockNum, count,\n\t\t\t  partmap->s_partition_len);\n\t\tgoto error_return;\n\t}\n\n\tiinfo = UDF_I(table);\n\tudf_add_free_space(sb, sbi->s_partition, count);\n\n\tstart = bloc->logicalBlockNum + offset;\n\tend = bloc->logicalBlockNum + offset + count - 1;\n\n\tepos.offset = oepos.offset = sizeof(struct unallocSpaceEntry);\n\telen = 0;\n\tepos.block = oepos.block = iinfo->i_location;\n\tepos.bh = oepos.bh = NULL;\n\n\twhile (count &&\n\t       (etype = udf_next_aext(table, &epos, &eloc, &elen, 1)) != -1) {\n\t\tif (((eloc.logicalBlockNum +\n\t\t\t(elen >> sb->s_blocksize_bits)) == start)) {\n\t\t\tif ((0x3FFFFFFF - elen) <\n\t\t\t\t\t(count << sb->s_blocksize_bits)) {\n\t\t\t\tuint32_t tmp = ((0x3FFFFFFF - elen) >>\n\t\t\t\t\t\t\tsb->s_blocksize_bits);\n\t\t\t\tcount -= tmp;\n\t\t\t\tstart += tmp;\n\t\t\t\telen = (etype << 30) |\n\t\t\t\t\t(0x40000000 - sb->s_blocksize);\n\t\t\t} else {\n\t\t\t\telen = (etype << 30) |\n\t\t\t\t\t(elen +\n\t\t\t\t\t(count << sb->s_blocksize_bits));\n\t\t\t\tstart += count;\n\t\t\t\tcount = 0;\n\t\t\t}\n\t\t\tudf_write_aext(table, &oepos, &eloc, elen, 1);\n\t\t} else if (eloc.logicalBlockNum == (end + 1)) {\n\t\t\tif ((0x3FFFFFFF - elen) <\n\t\t\t\t\t(count << sb->s_blocksize_bits)) {\n\t\t\t\tuint32_t tmp = ((0x3FFFFFFF - elen) >>\n\t\t\t\t\t\tsb->s_blocksize_bits);\n\t\t\t\tcount -= tmp;\n\t\t\t\tend -= tmp;\n\t\t\t\teloc.logicalBlockNum -= tmp;\n\t\t\t\telen = (etype << 30) |\n\t\t\t\t\t(0x40000000 - sb->s_blocksize);\n\t\t\t} else {\n\t\t\t\teloc.logicalBlockNum = start;\n\t\t\t\telen = (etype << 30) |\n\t\t\t\t\t(elen +\n\t\t\t\t\t(count << sb->s_blocksize_bits));\n\t\t\t\tend -= count;\n\t\t\t\tcount = 0;\n\t\t\t}\n\t\t\tudf_write_aext(table, &oepos, &eloc, elen, 1);\n\t\t}\n\n\t\tif (epos.bh != oepos.bh) {\n\t\t\ti = -1;\n\t\t\toepos.block = epos.block;\n\t\t\tbrelse(oepos.bh);\n\t\t\tget_bh(epos.bh);\n\t\t\toepos.bh = epos.bh;\n\t\t\toepos.offset = 0;\n\t\t} else {\n\t\t\toepos.offset = epos.offset;\n\t\t}\n\t}\n\n\tif (count) {\n\t\t/*\n\t\t * NOTE: we CANNOT use udf_add_aext here, as it can try to\n\t\t * allocate a new block, and since we hold the super block\n\t\t * lock already very bad things would happen :)\n\t\t *\n\t\t * We copy the behavior of udf_add_aext, but instead of\n\t\t * trying to allocate a new block close to the existing one,\n\t\t * we just steal a block from the extent we are trying to add.\n\t\t *\n\t\t * It would be nice if the blocks were close together, but it\n\t\t * isn't required.\n\t\t */\n\n\t\tint adsize;\n\t\tstruct short_ad *sad = NULL;\n\t\tstruct long_ad *lad = NULL;\n\t\tstruct allocExtDesc *aed;\n\n\t\teloc.logicalBlockNum = start;\n\t\telen = EXT_RECORDED_ALLOCATED |\n\t\t\t(count << sb->s_blocksize_bits);\n\n\t\tif (iinfo->i_alloc_type == ICBTAG_FLAG_AD_SHORT)\n\t\t\tadsize = sizeof(struct short_ad);\n\t\telse if (iinfo->i_alloc_type == ICBTAG_FLAG_AD_LONG)\n\t\t\tadsize = sizeof(struct long_ad);\n\t\telse {\n\t\t\tbrelse(oepos.bh);\n\t\t\tbrelse(epos.bh);\n\t\t\tgoto error_return;\n\t\t}\n\n\t\tif (epos.offset + (2 * adsize) > sb->s_blocksize) {\n\t\t\tunsigned char *sptr, *dptr;\n\t\t\tint loffset;\n\n\t\t\tbrelse(oepos.bh);\n\t\t\toepos = epos;\n\n\t\t\t/* Steal a block from the extent being free'd */\n\t\t\tepos.block.logicalBlockNum = eloc.logicalBlockNum;\n\t\t\teloc.logicalBlockNum++;\n\t\t\telen -= sb->s_blocksize;\n\n\t\t\tepos.bh = udf_tread(sb,\n\t\t\t\t\tudf_get_lb_pblock(sb, &epos.block, 0));\n\t\t\tif (!epos.bh) {\n\t\t\t\tbrelse(oepos.bh);\n\t\t\t\tgoto error_return;\n\t\t\t}\n\t\t\taed = (struct allocExtDesc *)(epos.bh->b_data);\n\t\t\taed->previousAllocExtLocation =\n\t\t\t\tcpu_to_le32(oepos.block.logicalBlockNum);\n\t\t\tif (epos.offset + adsize > sb->s_blocksize) {\n\t\t\t\tloffset = epos.offset;\n\t\t\t\taed->lengthAllocDescs = cpu_to_le32(adsize);\n\t\t\t\tsptr = iinfo->i_ext.i_data + epos.offset\n\t\t\t\t\t\t\t\t- adsize;\n\t\t\t\tdptr = epos.bh->b_data +\n\t\t\t\t\tsizeof(struct allocExtDesc);\n\t\t\t\tmemcpy(dptr, sptr, adsize);\n\t\t\t\tepos.offset = sizeof(struct allocExtDesc) +\n\t\t\t\t\t\tadsize;\n\t\t\t} else {\n\t\t\t\tloffset = epos.offset + adsize;\n\t\t\t\taed->lengthAllocDescs = cpu_to_le32(0);\n\t\t\t\tif (oepos.bh) {\n\t\t\t\t\tsptr = oepos.bh->b_data + epos.offset;\n\t\t\t\t\taed = (struct allocExtDesc *)\n\t\t\t\t\t\toepos.bh->b_data;\n\t\t\t\t\tle32_add_cpu(&aed->lengthAllocDescs,\n\t\t\t\t\t\t\tadsize);\n\t\t\t\t} else {\n\t\t\t\t\tsptr = iinfo->i_ext.i_data +\n\t\t\t\t\t\t\t\tepos.offset;\n\t\t\t\t\tiinfo->i_lenAlloc += adsize;\n\t\t\t\t\tmark_inode_dirty(table);\n\t\t\t\t}\n\t\t\t\tepos.offset = sizeof(struct allocExtDesc);\n\t\t\t}\n\t\t\tif (sbi->s_udfrev >= 0x0200)\n\t\t\t\tudf_new_tag(epos.bh->b_data, TAG_IDENT_AED,\n\t\t\t\t\t    3, 1, epos.block.logicalBlockNum,\n\t\t\t\t\t    sizeof(struct tag));\n\t\t\telse\n\t\t\t\tudf_new_tag(epos.bh->b_data, TAG_IDENT_AED,\n\t\t\t\t\t    2, 1, epos.block.logicalBlockNum,\n\t\t\t\t\t    sizeof(struct tag));\n\n\t\t\tswitch (iinfo->i_alloc_type) {\n\t\t\tcase ICBTAG_FLAG_AD_SHORT:\n\t\t\t\tsad = (struct short_ad *)sptr;\n\t\t\t\tsad->extLength = cpu_to_le32(\n\t\t\t\t\tEXT_NEXT_EXTENT_ALLOCDECS |\n\t\t\t\t\tsb->s_blocksize);\n\t\t\t\tsad->extPosition =\n\t\t\t\t\tcpu_to_le32(epos.block.logicalBlockNum);\n\t\t\t\tbreak;\n\t\t\tcase ICBTAG_FLAG_AD_LONG:\n\t\t\t\tlad = (struct long_ad *)sptr;\n\t\t\t\tlad->extLength = cpu_to_le32(\n\t\t\t\t\tEXT_NEXT_EXTENT_ALLOCDECS |\n\t\t\t\t\tsb->s_blocksize);\n\t\t\t\tlad->extLocation =\n\t\t\t\t\tcpu_to_lelb(epos.block);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (oepos.bh) {\n\t\t\t\tudf_update_tag(oepos.bh->b_data, loffset);\n\t\t\t\tmark_buffer_dirty(oepos.bh);\n\t\t\t} else {\n\t\t\t\tmark_inode_dirty(table);\n\t\t\t}\n\t\t}\n\n\t\t/* It's possible that stealing the block emptied the extent */\n\t\tif (elen) {\n\t\t\tudf_write_aext(table, &epos, &eloc, elen, 1);\n\n\t\t\tif (!epos.bh) {\n\t\t\t\tiinfo->i_lenAlloc += adsize;\n\t\t\t\tmark_inode_dirty(table);\n\t\t\t} else {\n\t\t\t\taed = (struct allocExtDesc *)epos.bh->b_data;\n\t\t\t\tle32_add_cpu(&aed->lengthAllocDescs, adsize);\n\t\t\t\tudf_update_tag(epos.bh->b_data, epos.offset);\n\t\t\t\tmark_buffer_dirty(epos.bh);\n\t\t\t}\n\t\t}\n\t}\n\n\tbrelse(epos.bh);\n\tbrelse(oepos.bh);\n\nerror_return:\n\tmutex_unlock(&sbi->s_alloc_mutex);\n\treturn;\n}",
          "includes": [
            "#include \"udf_sb.h\"",
            "#include \"udf_i.h\"",
            "#include <linux/bitops.h>",
            "#include <linux/buffer_head.h>",
            "#include \"udfdecl.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"udf_sb.h\"\n#include \"udf_i.h\"\n#include <linux/bitops.h>\n#include <linux/buffer_head.h>\n#include \"udfdecl.h\"\n\nstatic void udf_table_free_blocks(struct super_block *sb,\n\t\t\t\t  struct inode *table,\n\t\t\t\t  struct kernel_lb_addr *bloc,\n\t\t\t\t  uint32_t offset,\n\t\t\t\t  uint32_t count)\n{\n\tstruct udf_sb_info *sbi = UDF_SB(sb);\n\tstruct udf_part_map *partmap;\n\tuint32_t start, end;\n\tuint32_t elen;\n\tstruct kernel_lb_addr eloc;\n\tstruct extent_position oepos, epos;\n\tint8_t etype;\n\tint i;\n\tstruct udf_inode_info *iinfo;\n\n\tmutex_lock(&sbi->s_alloc_mutex);\n\tpartmap = &sbi->s_partmaps[bloc->partitionReferenceNum];\n\tif (bloc->logicalBlockNum + count < count ||\n\t    (bloc->logicalBlockNum + count) > partmap->s_partition_len) {\n\t\tudf_debug(\"%d < %d || %d + %d > %d\\n\",\n\t\t\t  bloc->logicalBlockNum, 0,\n\t\t\t  bloc->logicalBlockNum, count,\n\t\t\t  partmap->s_partition_len);\n\t\tgoto error_return;\n\t}\n\n\tiinfo = UDF_I(table);\n\tudf_add_free_space(sb, sbi->s_partition, count);\n\n\tstart = bloc->logicalBlockNum + offset;\n\tend = bloc->logicalBlockNum + offset + count - 1;\n\n\tepos.offset = oepos.offset = sizeof(struct unallocSpaceEntry);\n\telen = 0;\n\tepos.block = oepos.block = iinfo->i_location;\n\tepos.bh = oepos.bh = NULL;\n\n\twhile (count &&\n\t       (etype = udf_next_aext(table, &epos, &eloc, &elen, 1)) != -1) {\n\t\tif (((eloc.logicalBlockNum +\n\t\t\t(elen >> sb->s_blocksize_bits)) == start)) {\n\t\t\tif ((0x3FFFFFFF - elen) <\n\t\t\t\t\t(count << sb->s_blocksize_bits)) {\n\t\t\t\tuint32_t tmp = ((0x3FFFFFFF - elen) >>\n\t\t\t\t\t\t\tsb->s_blocksize_bits);\n\t\t\t\tcount -= tmp;\n\t\t\t\tstart += tmp;\n\t\t\t\telen = (etype << 30) |\n\t\t\t\t\t(0x40000000 - sb->s_blocksize);\n\t\t\t} else {\n\t\t\t\telen = (etype << 30) |\n\t\t\t\t\t(elen +\n\t\t\t\t\t(count << sb->s_blocksize_bits));\n\t\t\t\tstart += count;\n\t\t\t\tcount = 0;\n\t\t\t}\n\t\t\tudf_write_aext(table, &oepos, &eloc, elen, 1);\n\t\t} else if (eloc.logicalBlockNum == (end + 1)) {\n\t\t\tif ((0x3FFFFFFF - elen) <\n\t\t\t\t\t(count << sb->s_blocksize_bits)) {\n\t\t\t\tuint32_t tmp = ((0x3FFFFFFF - elen) >>\n\t\t\t\t\t\tsb->s_blocksize_bits);\n\t\t\t\tcount -= tmp;\n\t\t\t\tend -= tmp;\n\t\t\t\teloc.logicalBlockNum -= tmp;\n\t\t\t\telen = (etype << 30) |\n\t\t\t\t\t(0x40000000 - sb->s_blocksize);\n\t\t\t} else {\n\t\t\t\teloc.logicalBlockNum = start;\n\t\t\t\telen = (etype << 30) |\n\t\t\t\t\t(elen +\n\t\t\t\t\t(count << sb->s_blocksize_bits));\n\t\t\t\tend -= count;\n\t\t\t\tcount = 0;\n\t\t\t}\n\t\t\tudf_write_aext(table, &oepos, &eloc, elen, 1);\n\t\t}\n\n\t\tif (epos.bh != oepos.bh) {\n\t\t\ti = -1;\n\t\t\toepos.block = epos.block;\n\t\t\tbrelse(oepos.bh);\n\t\t\tget_bh(epos.bh);\n\t\t\toepos.bh = epos.bh;\n\t\t\toepos.offset = 0;\n\t\t} else {\n\t\t\toepos.offset = epos.offset;\n\t\t}\n\t}\n\n\tif (count) {\n\t\t/*\n\t\t * NOTE: we CANNOT use udf_add_aext here, as it can try to\n\t\t * allocate a new block, and since we hold the super block\n\t\t * lock already very bad things would happen :)\n\t\t *\n\t\t * We copy the behavior of udf_add_aext, but instead of\n\t\t * trying to allocate a new block close to the existing one,\n\t\t * we just steal a block from the extent we are trying to add.\n\t\t *\n\t\t * It would be nice if the blocks were close together, but it\n\t\t * isn't required.\n\t\t */\n\n\t\tint adsize;\n\t\tstruct short_ad *sad = NULL;\n\t\tstruct long_ad *lad = NULL;\n\t\tstruct allocExtDesc *aed;\n\n\t\teloc.logicalBlockNum = start;\n\t\telen = EXT_RECORDED_ALLOCATED |\n\t\t\t(count << sb->s_blocksize_bits);\n\n\t\tif (iinfo->i_alloc_type == ICBTAG_FLAG_AD_SHORT)\n\t\t\tadsize = sizeof(struct short_ad);\n\t\telse if (iinfo->i_alloc_type == ICBTAG_FLAG_AD_LONG)\n\t\t\tadsize = sizeof(struct long_ad);\n\t\telse {\n\t\t\tbrelse(oepos.bh);\n\t\t\tbrelse(epos.bh);\n\t\t\tgoto error_return;\n\t\t}\n\n\t\tif (epos.offset + (2 * adsize) > sb->s_blocksize) {\n\t\t\tunsigned char *sptr, *dptr;\n\t\t\tint loffset;\n\n\t\t\tbrelse(oepos.bh);\n\t\t\toepos = epos;\n\n\t\t\t/* Steal a block from the extent being free'd */\n\t\t\tepos.block.logicalBlockNum = eloc.logicalBlockNum;\n\t\t\teloc.logicalBlockNum++;\n\t\t\telen -= sb->s_blocksize;\n\n\t\t\tepos.bh = udf_tread(sb,\n\t\t\t\t\tudf_get_lb_pblock(sb, &epos.block, 0));\n\t\t\tif (!epos.bh) {\n\t\t\t\tbrelse(oepos.bh);\n\t\t\t\tgoto error_return;\n\t\t\t}\n\t\t\taed = (struct allocExtDesc *)(epos.bh->b_data);\n\t\t\taed->previousAllocExtLocation =\n\t\t\t\tcpu_to_le32(oepos.block.logicalBlockNum);\n\t\t\tif (epos.offset + adsize > sb->s_blocksize) {\n\t\t\t\tloffset = epos.offset;\n\t\t\t\taed->lengthAllocDescs = cpu_to_le32(adsize);\n\t\t\t\tsptr = iinfo->i_ext.i_data + epos.offset\n\t\t\t\t\t\t\t\t- adsize;\n\t\t\t\tdptr = epos.bh->b_data +\n\t\t\t\t\tsizeof(struct allocExtDesc);\n\t\t\t\tmemcpy(dptr, sptr, adsize);\n\t\t\t\tepos.offset = sizeof(struct allocExtDesc) +\n\t\t\t\t\t\tadsize;\n\t\t\t} else {\n\t\t\t\tloffset = epos.offset + adsize;\n\t\t\t\taed->lengthAllocDescs = cpu_to_le32(0);\n\t\t\t\tif (oepos.bh) {\n\t\t\t\t\tsptr = oepos.bh->b_data + epos.offset;\n\t\t\t\t\taed = (struct allocExtDesc *)\n\t\t\t\t\t\toepos.bh->b_data;\n\t\t\t\t\tle32_add_cpu(&aed->lengthAllocDescs,\n\t\t\t\t\t\t\tadsize);\n\t\t\t\t} else {\n\t\t\t\t\tsptr = iinfo->i_ext.i_data +\n\t\t\t\t\t\t\t\tepos.offset;\n\t\t\t\t\tiinfo->i_lenAlloc += adsize;\n\t\t\t\t\tmark_inode_dirty(table);\n\t\t\t\t}\n\t\t\t\tepos.offset = sizeof(struct allocExtDesc);\n\t\t\t}\n\t\t\tif (sbi->s_udfrev >= 0x0200)\n\t\t\t\tudf_new_tag(epos.bh->b_data, TAG_IDENT_AED,\n\t\t\t\t\t    3, 1, epos.block.logicalBlockNum,\n\t\t\t\t\t    sizeof(struct tag));\n\t\t\telse\n\t\t\t\tudf_new_tag(epos.bh->b_data, TAG_IDENT_AED,\n\t\t\t\t\t    2, 1, epos.block.logicalBlockNum,\n\t\t\t\t\t    sizeof(struct tag));\n\n\t\t\tswitch (iinfo->i_alloc_type) {\n\t\t\tcase ICBTAG_FLAG_AD_SHORT:\n\t\t\t\tsad = (struct short_ad *)sptr;\n\t\t\t\tsad->extLength = cpu_to_le32(\n\t\t\t\t\tEXT_NEXT_EXTENT_ALLOCDECS |\n\t\t\t\t\tsb->s_blocksize);\n\t\t\t\tsad->extPosition =\n\t\t\t\t\tcpu_to_le32(epos.block.logicalBlockNum);\n\t\t\t\tbreak;\n\t\t\tcase ICBTAG_FLAG_AD_LONG:\n\t\t\t\tlad = (struct long_ad *)sptr;\n\t\t\t\tlad->extLength = cpu_to_le32(\n\t\t\t\t\tEXT_NEXT_EXTENT_ALLOCDECS |\n\t\t\t\t\tsb->s_blocksize);\n\t\t\t\tlad->extLocation =\n\t\t\t\t\tcpu_to_lelb(epos.block);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (oepos.bh) {\n\t\t\t\tudf_update_tag(oepos.bh->b_data, loffset);\n\t\t\t\tmark_buffer_dirty(oepos.bh);\n\t\t\t} else {\n\t\t\t\tmark_inode_dirty(table);\n\t\t\t}\n\t\t}\n\n\t\t/* It's possible that stealing the block emptied the extent */\n\t\tif (elen) {\n\t\t\tudf_write_aext(table, &epos, &eloc, elen, 1);\n\n\t\t\tif (!epos.bh) {\n\t\t\t\tiinfo->i_lenAlloc += adsize;\n\t\t\t\tmark_inode_dirty(table);\n\t\t\t} else {\n\t\t\t\taed = (struct allocExtDesc *)epos.bh->b_data;\n\t\t\t\tle32_add_cpu(&aed->lengthAllocDescs, adsize);\n\t\t\t\tudf_update_tag(epos.bh->b_data, epos.offset);\n\t\t\t\tmark_buffer_dirty(epos.bh);\n\t\t\t}\n\t\t}\n\t}\n\n\tbrelse(epos.bh);\n\tbrelse(oepos.bh);\n\nerror_return:\n\tmutex_unlock(&sbi->s_alloc_mutex);\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "udf_bitmap_free_blocks",
          "args": [
            "sb",
            "map->s_fspace.s_bitmap",
            "bloc",
            "offset",
            "count"
          ],
          "line": 746
        },
        "resolved": true,
        "details": {
          "function_name": "udf_bitmap_free_blocks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/balloc.c",
          "lines": "107-171",
          "snippet": "static void udf_bitmap_free_blocks(struct super_block *sb,\n\t\t\t\t   struct udf_bitmap *bitmap,\n\t\t\t\t   struct kernel_lb_addr *bloc,\n\t\t\t\t   uint32_t offset,\n\t\t\t\t   uint32_t count)\n{\n\tstruct udf_sb_info *sbi = UDF_SB(sb);\n\tstruct buffer_head *bh = NULL;\n\tstruct udf_part_map *partmap;\n\tunsigned long block;\n\tunsigned long block_group;\n\tunsigned long bit;\n\tunsigned long i;\n\tint bitmap_nr;\n\tunsigned long overflow;\n\n\tmutex_lock(&sbi->s_alloc_mutex);\n\tpartmap = &sbi->s_partmaps[bloc->partitionReferenceNum];\n\tif (bloc->logicalBlockNum + count < count ||\n\t    (bloc->logicalBlockNum + count) > partmap->s_partition_len) {\n\t\tudf_debug(\"%d < %d || %d + %d > %d\\n\",\n\t\t\t  bloc->logicalBlockNum, 0,\n\t\t\t  bloc->logicalBlockNum, count,\n\t\t\t  partmap->s_partition_len);\n\t\tgoto error_return;\n\t}\n\n\tblock = bloc->logicalBlockNum + offset +\n\t\t(sizeof(struct spaceBitmapDesc) << 3);\n\n\tdo {\n\t\toverflow = 0;\n\t\tblock_group = block >> (sb->s_blocksize_bits + 3);\n\t\tbit = block % (sb->s_blocksize << 3);\n\n\t\t/*\n\t\t* Check to see if we are freeing blocks across a group boundary.\n\t\t*/\n\t\tif (bit + count > (sb->s_blocksize << 3)) {\n\t\t\toverflow = bit + count - (sb->s_blocksize << 3);\n\t\t\tcount -= overflow;\n\t\t}\n\t\tbitmap_nr = load_block_bitmap(sb, bitmap, block_group);\n\t\tif (bitmap_nr < 0)\n\t\t\tgoto error_return;\n\n\t\tbh = bitmap->s_block_bitmap[bitmap_nr];\n\t\tfor (i = 0; i < count; i++) {\n\t\t\tif (udf_set_bit(bit + i, bh->b_data)) {\n\t\t\t\tudf_debug(\"bit %ld already set\\n\", bit + i);\n\t\t\t\tudf_debug(\"byte=%2x\\n\",\n\t\t\t\t\t  ((char *)bh->b_data)[(bit + i) >> 3]);\n\t\t\t}\n\t\t}\n\t\tudf_add_free_space(sb, sbi->s_partition, count);\n\t\tmark_buffer_dirty(bh);\n\t\tif (overflow) {\n\t\t\tblock += count;\n\t\t\tcount = overflow;\n\t\t}\n\t} while (overflow);\n\nerror_return:\n\tmutex_unlock(&sbi->s_alloc_mutex);\n}",
          "includes": [
            "#include \"udf_sb.h\"",
            "#include \"udf_i.h\"",
            "#include <linux/bitops.h>",
            "#include <linux/buffer_head.h>",
            "#include \"udfdecl.h\""
          ],
          "macros_used": [
            "#define udf_set_bit\t__test_and_set_bit_le"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"udf_sb.h\"\n#include \"udf_i.h\"\n#include <linux/bitops.h>\n#include <linux/buffer_head.h>\n#include \"udfdecl.h\"\n\n#define udf_set_bit\t__test_and_set_bit_le\n\nstatic void udf_bitmap_free_blocks(struct super_block *sb,\n\t\t\t\t   struct udf_bitmap *bitmap,\n\t\t\t\t   struct kernel_lb_addr *bloc,\n\t\t\t\t   uint32_t offset,\n\t\t\t\t   uint32_t count)\n{\n\tstruct udf_sb_info *sbi = UDF_SB(sb);\n\tstruct buffer_head *bh = NULL;\n\tstruct udf_part_map *partmap;\n\tunsigned long block;\n\tunsigned long block_group;\n\tunsigned long bit;\n\tunsigned long i;\n\tint bitmap_nr;\n\tunsigned long overflow;\n\n\tmutex_lock(&sbi->s_alloc_mutex);\n\tpartmap = &sbi->s_partmaps[bloc->partitionReferenceNum];\n\tif (bloc->logicalBlockNum + count < count ||\n\t    (bloc->logicalBlockNum + count) > partmap->s_partition_len) {\n\t\tudf_debug(\"%d < %d || %d + %d > %d\\n\",\n\t\t\t  bloc->logicalBlockNum, 0,\n\t\t\t  bloc->logicalBlockNum, count,\n\t\t\t  partmap->s_partition_len);\n\t\tgoto error_return;\n\t}\n\n\tblock = bloc->logicalBlockNum + offset +\n\t\t(sizeof(struct spaceBitmapDesc) << 3);\n\n\tdo {\n\t\toverflow = 0;\n\t\tblock_group = block >> (sb->s_blocksize_bits + 3);\n\t\tbit = block % (sb->s_blocksize << 3);\n\n\t\t/*\n\t\t* Check to see if we are freeing blocks across a group boundary.\n\t\t*/\n\t\tif (bit + count > (sb->s_blocksize << 3)) {\n\t\t\toverflow = bit + count - (sb->s_blocksize << 3);\n\t\t\tcount -= overflow;\n\t\t}\n\t\tbitmap_nr = load_block_bitmap(sb, bitmap, block_group);\n\t\tif (bitmap_nr < 0)\n\t\t\tgoto error_return;\n\n\t\tbh = bitmap->s_block_bitmap[bitmap_nr];\n\t\tfor (i = 0; i < count; i++) {\n\t\t\tif (udf_set_bit(bit + i, bh->b_data)) {\n\t\t\t\tudf_debug(\"bit %ld already set\\n\", bit + i);\n\t\t\t\tudf_debug(\"byte=%2x\\n\",\n\t\t\t\t\t  ((char *)bh->b_data)[(bit + i) >> 3]);\n\t\t\t}\n\t\t}\n\t\tudf_add_free_space(sb, sbi->s_partition, count);\n\t\tmark_buffer_dirty(bh);\n\t\tif (overflow) {\n\t\t\tblock += count;\n\t\t\tcount = overflow;\n\t\t}\n\t} while (overflow);\n\nerror_return:\n\tmutex_unlock(&sbi->s_alloc_mutex);\n}"
        }
      },
      {
        "call_info": {
          "callee": "UDF_SB",
          "args": [
            "sb"
          ],
          "line": 737
        },
        "resolved": true,
        "details": {
          "function_name": "UDF_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/udf_sb.h",
          "lines": "160-163",
          "snippet": "static inline struct udf_sb_info *UDF_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include <linux/bitops.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bitops.h>\n#include <linux/mutex.h>\n\nstatic inline struct udf_sb_info *UDF_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"udf_sb.h\"\n#include \"udf_i.h\"\n#include <linux/bitops.h>\n#include <linux/buffer_head.h>\n#include \"udfdecl.h\"\n\nvoid udf_free_blocks(struct super_block *sb, struct inode *inode,\n\t\t     struct kernel_lb_addr *bloc, uint32_t offset,\n\t\t     uint32_t count)\n{\n\tuint16_t partition = bloc->partitionReferenceNum;\n\tstruct udf_part_map *map = &UDF_SB(sb)->s_partmaps[partition];\n\n\tif (map->s_partition_flags & UDF_PART_FLAG_UNALLOC_BITMAP) {\n\t\tudf_bitmap_free_blocks(sb, map->s_uspace.s_bitmap,\n\t\t\t\t       bloc, offset, count);\n\t} else if (map->s_partition_flags & UDF_PART_FLAG_UNALLOC_TABLE) {\n\t\tudf_table_free_blocks(sb, map->s_uspace.s_table,\n\t\t\t\t      bloc, offset, count);\n\t} else if (map->s_partition_flags & UDF_PART_FLAG_FREED_BITMAP) {\n\t\tudf_bitmap_free_blocks(sb, map->s_fspace.s_bitmap,\n\t\t\t\t       bloc, offset, count);\n\t} else if (map->s_partition_flags & UDF_PART_FLAG_FREED_TABLE) {\n\t\tudf_table_free_blocks(sb, map->s_fspace.s_table,\n\t\t\t\t      bloc, offset, count);\n\t}\n\n\tif (inode) {\n\t\tinode_sub_bytes(inode,\n\t\t\t\t((sector_t)count) << sb->s_blocksize_bits);\n\t}\n}"
  },
  {
    "function_name": "udf_table_new_block",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/balloc.c",
    "lines": "640-730",
    "snippet": "static int udf_table_new_block(struct super_block *sb,\n\t\t\t       struct inode *table, uint16_t partition,\n\t\t\t       uint32_t goal, int *err)\n{\n\tstruct udf_sb_info *sbi = UDF_SB(sb);\n\tuint32_t spread = 0xFFFFFFFF, nspread = 0xFFFFFFFF;\n\tuint32_t newblock = 0, adsize;\n\tuint32_t elen, goal_elen = 0;\n\tstruct kernel_lb_addr eloc, uninitialized_var(goal_eloc);\n\tstruct extent_position epos, goal_epos;\n\tint8_t etype;\n\tstruct udf_inode_info *iinfo = UDF_I(table);\n\n\t*err = -ENOSPC;\n\n\tif (iinfo->i_alloc_type == ICBTAG_FLAG_AD_SHORT)\n\t\tadsize = sizeof(struct short_ad);\n\telse if (iinfo->i_alloc_type == ICBTAG_FLAG_AD_LONG)\n\t\tadsize = sizeof(struct long_ad);\n\telse\n\t\treturn newblock;\n\n\tmutex_lock(&sbi->s_alloc_mutex);\n\tif (goal >= sbi->s_partmaps[partition].s_partition_len)\n\t\tgoal = 0;\n\n\t/* We search for the closest matching block to goal. If we find\n\t   a exact hit, we stop. Otherwise we keep going till we run out\n\t   of extents. We store the buffer_head, bloc, and extoffset\n\t   of the current closest match and use that when we are done.\n\t */\n\tepos.offset = sizeof(struct unallocSpaceEntry);\n\tepos.block = iinfo->i_location;\n\tepos.bh = goal_epos.bh = NULL;\n\n\twhile (spread &&\n\t       (etype = udf_next_aext(table, &epos, &eloc, &elen, 1)) != -1) {\n\t\tif (goal >= eloc.logicalBlockNum) {\n\t\t\tif (goal < eloc.logicalBlockNum +\n\t\t\t\t\t(elen >> sb->s_blocksize_bits))\n\t\t\t\tnspread = 0;\n\t\t\telse\n\t\t\t\tnspread = goal - eloc.logicalBlockNum -\n\t\t\t\t\t(elen >> sb->s_blocksize_bits);\n\t\t} else {\n\t\t\tnspread = eloc.logicalBlockNum - goal;\n\t\t}\n\n\t\tif (nspread < spread) {\n\t\t\tspread = nspread;\n\t\t\tif (goal_epos.bh != epos.bh) {\n\t\t\t\tbrelse(goal_epos.bh);\n\t\t\t\tgoal_epos.bh = epos.bh;\n\t\t\t\tget_bh(goal_epos.bh);\n\t\t\t}\n\t\t\tgoal_epos.block = epos.block;\n\t\t\tgoal_epos.offset = epos.offset - adsize;\n\t\t\tgoal_eloc = eloc;\n\t\t\tgoal_elen = (etype << 30) | elen;\n\t\t}\n\t}\n\n\tbrelse(epos.bh);\n\n\tif (spread == 0xFFFFFFFF) {\n\t\tbrelse(goal_epos.bh);\n\t\tmutex_unlock(&sbi->s_alloc_mutex);\n\t\treturn 0;\n\t}\n\n\t/* Only allocate blocks from the beginning of the extent.\n\t   That way, we only delete (empty) extents, never have to insert an\n\t   extent because of splitting */\n\t/* This works, but very poorly.... */\n\n\tnewblock = goal_eloc.logicalBlockNum;\n\tgoal_eloc.logicalBlockNum++;\n\tgoal_elen -= sb->s_blocksize;\n\n\tif (goal_elen)\n\t\tudf_write_aext(table, &goal_epos, &goal_eloc, goal_elen, 1);\n\telse\n\t\tudf_delete_aext(table, goal_epos, goal_eloc, goal_elen);\n\tbrelse(goal_epos.bh);\n\n\tudf_add_free_space(sb, partition, -1);\n\n\tmutex_unlock(&sbi->s_alloc_mutex);\n\t*err = 0;\n\treturn newblock;\n}",
    "includes": [
      "#include \"udf_sb.h\"",
      "#include \"udf_i.h\"",
      "#include <linux/bitops.h>",
      "#include <linux/buffer_head.h>",
      "#include \"udfdecl.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&sbi->s_alloc_mutex"
          ],
          "line": 727
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "udf_add_free_space",
          "args": [
            "sb",
            "partition",
            "-1"
          ],
          "line": 725
        },
        "resolved": true,
        "details": {
          "function_name": "udf_add_free_space",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/balloc.c",
          "lines": "94-105",
          "snippet": "static void udf_add_free_space(struct super_block *sb, u16 partition, u32 cnt)\n{\n\tstruct udf_sb_info *sbi = UDF_SB(sb);\n\tstruct logicalVolIntegrityDesc *lvid;\n\n\tif (!sbi->s_lvid_bh)\n\t\treturn;\n\n\tlvid = (struct logicalVolIntegrityDesc *)sbi->s_lvid_bh->b_data;\n\tle32_add_cpu(&lvid->freeSpaceTable[partition], cnt);\n\tudf_updated_lvid(sb);\n}",
          "includes": [
            "#include \"udf_sb.h\"",
            "#include \"udf_i.h\"",
            "#include <linux/bitops.h>",
            "#include <linux/buffer_head.h>",
            "#include \"udfdecl.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"udf_sb.h\"\n#include \"udf_i.h\"\n#include <linux/bitops.h>\n#include <linux/buffer_head.h>\n#include \"udfdecl.h\"\n\nstatic void udf_add_free_space(struct super_block *sb, u16 partition, u32 cnt)\n{\n\tstruct udf_sb_info *sbi = UDF_SB(sb);\n\tstruct logicalVolIntegrityDesc *lvid;\n\n\tif (!sbi->s_lvid_bh)\n\t\treturn;\n\n\tlvid = (struct logicalVolIntegrityDesc *)sbi->s_lvid_bh->b_data;\n\tle32_add_cpu(&lvid->freeSpaceTable[partition], cnt);\n\tudf_updated_lvid(sb);\n}"
        }
      },
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "goal_epos.bh"
          ],
          "line": 723
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "udf_delete_aext",
          "args": [
            "table",
            "goal_epos",
            "goal_eloc",
            "goal_elen"
          ],
          "line": 722
        },
        "resolved": true,
        "details": {
          "function_name": "udf_delete_aext",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/inode.c",
          "lines": "2154-2235",
          "snippet": "int8_t udf_delete_aext(struct inode *inode, struct extent_position epos,\n\t\t       struct kernel_lb_addr eloc, uint32_t elen)\n{\n\tstruct extent_position oepos;\n\tint adsize;\n\tint8_t etype;\n\tstruct allocExtDesc *aed;\n\tstruct udf_inode_info *iinfo;\n\n\tif (epos.bh) {\n\t\tget_bh(epos.bh);\n\t\tget_bh(epos.bh);\n\t}\n\n\tiinfo = UDF_I(inode);\n\tif (iinfo->i_alloc_type == ICBTAG_FLAG_AD_SHORT)\n\t\tadsize = sizeof(struct short_ad);\n\telse if (iinfo->i_alloc_type == ICBTAG_FLAG_AD_LONG)\n\t\tadsize = sizeof(struct long_ad);\n\telse\n\t\tadsize = 0;\n\n\toepos = epos;\n\tif (udf_next_aext(inode, &epos, &eloc, &elen, 1) == -1)\n\t\treturn -1;\n\n\twhile ((etype = udf_next_aext(inode, &epos, &eloc, &elen, 1)) != -1) {\n\t\tudf_write_aext(inode, &oepos, &eloc, (etype << 30) | elen, 1);\n\t\tif (oepos.bh != epos.bh) {\n\t\t\toepos.block = epos.block;\n\t\t\tbrelse(oepos.bh);\n\t\t\tget_bh(epos.bh);\n\t\t\toepos.bh = epos.bh;\n\t\t\toepos.offset = epos.offset - adsize;\n\t\t}\n\t}\n\tmemset(&eloc, 0x00, sizeof(struct kernel_lb_addr));\n\telen = 0;\n\n\tif (epos.bh != oepos.bh) {\n\t\tudf_free_blocks(inode->i_sb, inode, &epos.block, 0, 1);\n\t\tudf_write_aext(inode, &oepos, &eloc, elen, 1);\n\t\tudf_write_aext(inode, &oepos, &eloc, elen, 1);\n\t\tif (!oepos.bh) {\n\t\t\tiinfo->i_lenAlloc -= (adsize * 2);\n\t\t\tmark_inode_dirty(inode);\n\t\t} else {\n\t\t\taed = (struct allocExtDesc *)oepos.bh->b_data;\n\t\t\tle32_add_cpu(&aed->lengthAllocDescs, -(2 * adsize));\n\t\t\tif (!UDF_QUERY_FLAG(inode->i_sb, UDF_FLAG_STRICT) ||\n\t\t\t    UDF_SB(inode->i_sb)->s_udfrev >= 0x0201)\n\t\t\t\tudf_update_tag(oepos.bh->b_data,\n\t\t\t\t\t\toepos.offset - (2 * adsize));\n\t\t\telse\n\t\t\t\tudf_update_tag(oepos.bh->b_data,\n\t\t\t\t\t\tsizeof(struct allocExtDesc));\n\t\t\tmark_buffer_dirty_inode(oepos.bh, inode);\n\t\t}\n\t} else {\n\t\tudf_write_aext(inode, &oepos, &eloc, elen, 1);\n\t\tif (!oepos.bh) {\n\t\t\tiinfo->i_lenAlloc -= adsize;\n\t\t\tmark_inode_dirty(inode);\n\t\t} else {\n\t\t\taed = (struct allocExtDesc *)oepos.bh->b_data;\n\t\t\tle32_add_cpu(&aed->lengthAllocDescs, -adsize);\n\t\t\tif (!UDF_QUERY_FLAG(inode->i_sb, UDF_FLAG_STRICT) ||\n\t\t\t    UDF_SB(inode->i_sb)->s_udfrev >= 0x0201)\n\t\t\t\tudf_update_tag(oepos.bh->b_data,\n\t\t\t\t\t\tepos.offset - adsize);\n\t\t\telse\n\t\t\t\tudf_update_tag(oepos.bh->b_data,\n\t\t\t\t\t\tsizeof(struct allocExtDesc));\n\t\t\tmark_buffer_dirty_inode(oepos.bh, inode);\n\t\t}\n\t}\n\n\tbrelse(epos.bh);\n\tbrelse(oepos.bh);\n\n\treturn (elen >> 30);\n}",
          "includes": [
            "#include \"udf_sb.h\"",
            "#include \"udf_i.h\"",
            "#include <linux/aio.h>",
            "#include <linux/mpage.h>",
            "#include <linux/crc-itu-t.h>",
            "#include <linux/slab.h>",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include \"udfdecl.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int udf_update_inode(struct inode *, int);",
            "static int udf_sync_inode(struct inode *inode);",
            "static int8_t udf_insert_aext(struct inode *, struct extent_position,\n\t\t\t      struct kernel_lb_addr, uint32_t);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"udf_sb.h\"\n#include \"udf_i.h\"\n#include <linux/aio.h>\n#include <linux/mpage.h>\n#include <linux/crc-itu-t.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include \"udfdecl.h\"\n\nstatic int udf_update_inode(struct inode *, int);\nstatic int udf_sync_inode(struct inode *inode);\nstatic int8_t udf_insert_aext(struct inode *, struct extent_position,\n\t\t\t      struct kernel_lb_addr, uint32_t);\n\nint8_t udf_delete_aext(struct inode *inode, struct extent_position epos,\n\t\t       struct kernel_lb_addr eloc, uint32_t elen)\n{\n\tstruct extent_position oepos;\n\tint adsize;\n\tint8_t etype;\n\tstruct allocExtDesc *aed;\n\tstruct udf_inode_info *iinfo;\n\n\tif (epos.bh) {\n\t\tget_bh(epos.bh);\n\t\tget_bh(epos.bh);\n\t}\n\n\tiinfo = UDF_I(inode);\n\tif (iinfo->i_alloc_type == ICBTAG_FLAG_AD_SHORT)\n\t\tadsize = sizeof(struct short_ad);\n\telse if (iinfo->i_alloc_type == ICBTAG_FLAG_AD_LONG)\n\t\tadsize = sizeof(struct long_ad);\n\telse\n\t\tadsize = 0;\n\n\toepos = epos;\n\tif (udf_next_aext(inode, &epos, &eloc, &elen, 1) == -1)\n\t\treturn -1;\n\n\twhile ((etype = udf_next_aext(inode, &epos, &eloc, &elen, 1)) != -1) {\n\t\tudf_write_aext(inode, &oepos, &eloc, (etype << 30) | elen, 1);\n\t\tif (oepos.bh != epos.bh) {\n\t\t\toepos.block = epos.block;\n\t\t\tbrelse(oepos.bh);\n\t\t\tget_bh(epos.bh);\n\t\t\toepos.bh = epos.bh;\n\t\t\toepos.offset = epos.offset - adsize;\n\t\t}\n\t}\n\tmemset(&eloc, 0x00, sizeof(struct kernel_lb_addr));\n\telen = 0;\n\n\tif (epos.bh != oepos.bh) {\n\t\tudf_free_blocks(inode->i_sb, inode, &epos.block, 0, 1);\n\t\tudf_write_aext(inode, &oepos, &eloc, elen, 1);\n\t\tudf_write_aext(inode, &oepos, &eloc, elen, 1);\n\t\tif (!oepos.bh) {\n\t\t\tiinfo->i_lenAlloc -= (adsize * 2);\n\t\t\tmark_inode_dirty(inode);\n\t\t} else {\n\t\t\taed = (struct allocExtDesc *)oepos.bh->b_data;\n\t\t\tle32_add_cpu(&aed->lengthAllocDescs, -(2 * adsize));\n\t\t\tif (!UDF_QUERY_FLAG(inode->i_sb, UDF_FLAG_STRICT) ||\n\t\t\t    UDF_SB(inode->i_sb)->s_udfrev >= 0x0201)\n\t\t\t\tudf_update_tag(oepos.bh->b_data,\n\t\t\t\t\t\toepos.offset - (2 * adsize));\n\t\t\telse\n\t\t\t\tudf_update_tag(oepos.bh->b_data,\n\t\t\t\t\t\tsizeof(struct allocExtDesc));\n\t\t\tmark_buffer_dirty_inode(oepos.bh, inode);\n\t\t}\n\t} else {\n\t\tudf_write_aext(inode, &oepos, &eloc, elen, 1);\n\t\tif (!oepos.bh) {\n\t\t\tiinfo->i_lenAlloc -= adsize;\n\t\t\tmark_inode_dirty(inode);\n\t\t} else {\n\t\t\taed = (struct allocExtDesc *)oepos.bh->b_data;\n\t\t\tle32_add_cpu(&aed->lengthAllocDescs, -adsize);\n\t\t\tif (!UDF_QUERY_FLAG(inode->i_sb, UDF_FLAG_STRICT) ||\n\t\t\t    UDF_SB(inode->i_sb)->s_udfrev >= 0x0201)\n\t\t\t\tudf_update_tag(oepos.bh->b_data,\n\t\t\t\t\t\tepos.offset - adsize);\n\t\t\telse\n\t\t\t\tudf_update_tag(oepos.bh->b_data,\n\t\t\t\t\t\tsizeof(struct allocExtDesc));\n\t\t\tmark_buffer_dirty_inode(oepos.bh, inode);\n\t\t}\n\t}\n\n\tbrelse(epos.bh);\n\tbrelse(oepos.bh);\n\n\treturn (elen >> 30);\n}"
        }
      },
      {
        "call_info": {
          "callee": "udf_write_aext",
          "args": [
            "table",
            "&goal_epos",
            "&goal_eloc",
            "goal_elen",
            "1"
          ],
          "line": 720
        },
        "resolved": true,
        "details": {
          "function_name": "udf_write_aext",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/inode.c",
          "lines": "2005-2055",
          "snippet": "void udf_write_aext(struct inode *inode, struct extent_position *epos,\n\t\t    struct kernel_lb_addr *eloc, uint32_t elen, int inc)\n{\n\tint adsize;\n\tuint8_t *ptr;\n\tstruct short_ad *sad;\n\tstruct long_ad *lad;\n\tstruct udf_inode_info *iinfo = UDF_I(inode);\n\n\tif (!epos->bh)\n\t\tptr = iinfo->i_ext.i_data + epos->offset -\n\t\t\tudf_file_entry_alloc_offset(inode) +\n\t\t\tiinfo->i_lenEAttr;\n\telse\n\t\tptr = epos->bh->b_data + epos->offset;\n\n\tswitch (iinfo->i_alloc_type) {\n\tcase ICBTAG_FLAG_AD_SHORT:\n\t\tsad = (struct short_ad *)ptr;\n\t\tsad->extLength = cpu_to_le32(elen);\n\t\tsad->extPosition = cpu_to_le32(eloc->logicalBlockNum);\n\t\tadsize = sizeof(struct short_ad);\n\t\tbreak;\n\tcase ICBTAG_FLAG_AD_LONG:\n\t\tlad = (struct long_ad *)ptr;\n\t\tlad->extLength = cpu_to_le32(elen);\n\t\tlad->extLocation = cpu_to_lelb(*eloc);\n\t\tmemset(lad->impUse, 0x00, sizeof(lad->impUse));\n\t\tadsize = sizeof(struct long_ad);\n\t\tbreak;\n\tdefault:\n\t\treturn;\n\t}\n\n\tif (epos->bh) {\n\t\tif (!UDF_QUERY_FLAG(inode->i_sb, UDF_FLAG_STRICT) ||\n\t\t    UDF_SB(inode->i_sb)->s_udfrev >= 0x0201) {\n\t\t\tstruct allocExtDesc *aed =\n\t\t\t\t(struct allocExtDesc *)epos->bh->b_data;\n\t\t\tudf_update_tag(epos->bh->b_data,\n\t\t\t\t       le32_to_cpu(aed->lengthAllocDescs) +\n\t\t\t\t       sizeof(struct allocExtDesc));\n\t\t}\n\t\tmark_buffer_dirty_inode(epos->bh, inode);\n\t} else {\n\t\tmark_inode_dirty(inode);\n\t}\n\n\tif (inc)\n\t\tepos->offset += adsize;\n}",
          "includes": [
            "#include \"udf_sb.h\"",
            "#include \"udf_i.h\"",
            "#include <linux/aio.h>",
            "#include <linux/mpage.h>",
            "#include <linux/crc-itu-t.h>",
            "#include <linux/slab.h>",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include \"udfdecl.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int udf_update_inode(struct inode *, int);",
            "static int udf_sync_inode(struct inode *inode);",
            "static int8_t udf_insert_aext(struct inode *, struct extent_position,\n\t\t\t      struct kernel_lb_addr, uint32_t);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"udf_sb.h\"\n#include \"udf_i.h\"\n#include <linux/aio.h>\n#include <linux/mpage.h>\n#include <linux/crc-itu-t.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include \"udfdecl.h\"\n\nstatic int udf_update_inode(struct inode *, int);\nstatic int udf_sync_inode(struct inode *inode);\nstatic int8_t udf_insert_aext(struct inode *, struct extent_position,\n\t\t\t      struct kernel_lb_addr, uint32_t);\n\nvoid udf_write_aext(struct inode *inode, struct extent_position *epos,\n\t\t    struct kernel_lb_addr *eloc, uint32_t elen, int inc)\n{\n\tint adsize;\n\tuint8_t *ptr;\n\tstruct short_ad *sad;\n\tstruct long_ad *lad;\n\tstruct udf_inode_info *iinfo = UDF_I(inode);\n\n\tif (!epos->bh)\n\t\tptr = iinfo->i_ext.i_data + epos->offset -\n\t\t\tudf_file_entry_alloc_offset(inode) +\n\t\t\tiinfo->i_lenEAttr;\n\telse\n\t\tptr = epos->bh->b_data + epos->offset;\n\n\tswitch (iinfo->i_alloc_type) {\n\tcase ICBTAG_FLAG_AD_SHORT:\n\t\tsad = (struct short_ad *)ptr;\n\t\tsad->extLength = cpu_to_le32(elen);\n\t\tsad->extPosition = cpu_to_le32(eloc->logicalBlockNum);\n\t\tadsize = sizeof(struct short_ad);\n\t\tbreak;\n\tcase ICBTAG_FLAG_AD_LONG:\n\t\tlad = (struct long_ad *)ptr;\n\t\tlad->extLength = cpu_to_le32(elen);\n\t\tlad->extLocation = cpu_to_lelb(*eloc);\n\t\tmemset(lad->impUse, 0x00, sizeof(lad->impUse));\n\t\tadsize = sizeof(struct long_ad);\n\t\tbreak;\n\tdefault:\n\t\treturn;\n\t}\n\n\tif (epos->bh) {\n\t\tif (!UDF_QUERY_FLAG(inode->i_sb, UDF_FLAG_STRICT) ||\n\t\t    UDF_SB(inode->i_sb)->s_udfrev >= 0x0201) {\n\t\t\tstruct allocExtDesc *aed =\n\t\t\t\t(struct allocExtDesc *)epos->bh->b_data;\n\t\t\tudf_update_tag(epos->bh->b_data,\n\t\t\t\t       le32_to_cpu(aed->lengthAllocDescs) +\n\t\t\t\t       sizeof(struct allocExtDesc));\n\t\t}\n\t\tmark_buffer_dirty_inode(epos->bh, inode);\n\t} else {\n\t\tmark_inode_dirty(inode);\n\t}\n\n\tif (inc)\n\t\tepos->offset += adsize;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&sbi->s_alloc_mutex"
          ],
          "line": 706
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_bh",
          "args": [
            "goal_epos.bh"
          ],
          "line": 693
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "udf_next_aext",
          "args": [
            "table",
            "&epos",
            "&eloc",
            "&elen",
            "1"
          ],
          "line": 676
        },
        "resolved": true,
        "details": {
          "function_name": "udf_next_aext",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/inode.c",
          "lines": "2057-2077",
          "snippet": "int8_t udf_next_aext(struct inode *inode, struct extent_position *epos,\n\t\t     struct kernel_lb_addr *eloc, uint32_t *elen, int inc)\n{\n\tint8_t etype;\n\n\twhile ((etype = udf_current_aext(inode, epos, eloc, elen, inc)) ==\n\t       (EXT_NEXT_EXTENT_ALLOCDECS >> 30)) {\n\t\tint block;\n\t\tepos->block = *eloc;\n\t\tepos->offset = sizeof(struct allocExtDesc);\n\t\tbrelse(epos->bh);\n\t\tblock = udf_get_lb_pblock(inode->i_sb, &epos->block, 0);\n\t\tepos->bh = udf_tread(inode->i_sb, block);\n\t\tif (!epos->bh) {\n\t\t\tudf_debug(\"reading block %d failed!\\n\", block);\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\treturn etype;\n}",
          "includes": [
            "#include \"udf_sb.h\"",
            "#include \"udf_i.h\"",
            "#include <linux/aio.h>",
            "#include <linux/mpage.h>",
            "#include <linux/crc-itu-t.h>",
            "#include <linux/slab.h>",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include \"udfdecl.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int udf_update_inode(struct inode *, int);",
            "static int udf_sync_inode(struct inode *inode);",
            "static int8_t udf_insert_aext(struct inode *, struct extent_position,\n\t\t\t      struct kernel_lb_addr, uint32_t);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"udf_sb.h\"\n#include \"udf_i.h\"\n#include <linux/aio.h>\n#include <linux/mpage.h>\n#include <linux/crc-itu-t.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include \"udfdecl.h\"\n\nstatic int udf_update_inode(struct inode *, int);\nstatic int udf_sync_inode(struct inode *inode);\nstatic int8_t udf_insert_aext(struct inode *, struct extent_position,\n\t\t\t      struct kernel_lb_addr, uint32_t);\n\nint8_t udf_next_aext(struct inode *inode, struct extent_position *epos,\n\t\t     struct kernel_lb_addr *eloc, uint32_t *elen, int inc)\n{\n\tint8_t etype;\n\n\twhile ((etype = udf_current_aext(inode, epos, eloc, elen, inc)) ==\n\t       (EXT_NEXT_EXTENT_ALLOCDECS >> 30)) {\n\t\tint block;\n\t\tepos->block = *eloc;\n\t\tepos->offset = sizeof(struct allocExtDesc);\n\t\tbrelse(epos->bh);\n\t\tblock = udf_get_lb_pblock(inode->i_sb, &epos->block, 0);\n\t\tepos->bh = udf_tread(inode->i_sb, block);\n\t\tif (!epos->bh) {\n\t\t\tudf_debug(\"reading block %d failed!\\n\", block);\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\treturn etype;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&sbi->s_alloc_mutex"
          ],
          "line": 662
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UDF_I",
          "args": [
            "table"
          ],
          "line": 651
        },
        "resolved": true,
        "details": {
          "function_name": "UDF_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/udf_i.h",
          "lines": "57-60",
          "snippet": "static inline struct udf_inode_info *UDF_I(struct inode *inode)\n{\n\treturn list_entry(inode, struct udf_inode_info, vfs_inode);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline struct udf_inode_info *UDF_I(struct inode *inode)\n{\n\treturn list_entry(inode, struct udf_inode_info, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "UDF_SB",
          "args": [
            "sb"
          ],
          "line": 644
        },
        "resolved": true,
        "details": {
          "function_name": "UDF_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/udf_sb.h",
          "lines": "160-163",
          "snippet": "static inline struct udf_sb_info *UDF_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include <linux/bitops.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bitops.h>\n#include <linux/mutex.h>\n\nstatic inline struct udf_sb_info *UDF_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"udf_sb.h\"\n#include \"udf_i.h\"\n#include <linux/bitops.h>\n#include <linux/buffer_head.h>\n#include \"udfdecl.h\"\n\nstatic int udf_table_new_block(struct super_block *sb,\n\t\t\t       struct inode *table, uint16_t partition,\n\t\t\t       uint32_t goal, int *err)\n{\n\tstruct udf_sb_info *sbi = UDF_SB(sb);\n\tuint32_t spread = 0xFFFFFFFF, nspread = 0xFFFFFFFF;\n\tuint32_t newblock = 0, adsize;\n\tuint32_t elen, goal_elen = 0;\n\tstruct kernel_lb_addr eloc, uninitialized_var(goal_eloc);\n\tstruct extent_position epos, goal_epos;\n\tint8_t etype;\n\tstruct udf_inode_info *iinfo = UDF_I(table);\n\n\t*err = -ENOSPC;\n\n\tif (iinfo->i_alloc_type == ICBTAG_FLAG_AD_SHORT)\n\t\tadsize = sizeof(struct short_ad);\n\telse if (iinfo->i_alloc_type == ICBTAG_FLAG_AD_LONG)\n\t\tadsize = sizeof(struct long_ad);\n\telse\n\t\treturn newblock;\n\n\tmutex_lock(&sbi->s_alloc_mutex);\n\tif (goal >= sbi->s_partmaps[partition].s_partition_len)\n\t\tgoal = 0;\n\n\t/* We search for the closest matching block to goal. If we find\n\t   a exact hit, we stop. Otherwise we keep going till we run out\n\t   of extents. We store the buffer_head, bloc, and extoffset\n\t   of the current closest match and use that when we are done.\n\t */\n\tepos.offset = sizeof(struct unallocSpaceEntry);\n\tepos.block = iinfo->i_location;\n\tepos.bh = goal_epos.bh = NULL;\n\n\twhile (spread &&\n\t       (etype = udf_next_aext(table, &epos, &eloc, &elen, 1)) != -1) {\n\t\tif (goal >= eloc.logicalBlockNum) {\n\t\t\tif (goal < eloc.logicalBlockNum +\n\t\t\t\t\t(elen >> sb->s_blocksize_bits))\n\t\t\t\tnspread = 0;\n\t\t\telse\n\t\t\t\tnspread = goal - eloc.logicalBlockNum -\n\t\t\t\t\t(elen >> sb->s_blocksize_bits);\n\t\t} else {\n\t\t\tnspread = eloc.logicalBlockNum - goal;\n\t\t}\n\n\t\tif (nspread < spread) {\n\t\t\tspread = nspread;\n\t\t\tif (goal_epos.bh != epos.bh) {\n\t\t\t\tbrelse(goal_epos.bh);\n\t\t\t\tgoal_epos.bh = epos.bh;\n\t\t\t\tget_bh(goal_epos.bh);\n\t\t\t}\n\t\t\tgoal_epos.block = epos.block;\n\t\t\tgoal_epos.offset = epos.offset - adsize;\n\t\t\tgoal_eloc = eloc;\n\t\t\tgoal_elen = (etype << 30) | elen;\n\t\t}\n\t}\n\n\tbrelse(epos.bh);\n\n\tif (spread == 0xFFFFFFFF) {\n\t\tbrelse(goal_epos.bh);\n\t\tmutex_unlock(&sbi->s_alloc_mutex);\n\t\treturn 0;\n\t}\n\n\t/* Only allocate blocks from the beginning of the extent.\n\t   That way, we only delete (empty) extents, never have to insert an\n\t   extent because of splitting */\n\t/* This works, but very poorly.... */\n\n\tnewblock = goal_eloc.logicalBlockNum;\n\tgoal_eloc.logicalBlockNum++;\n\tgoal_elen -= sb->s_blocksize;\n\n\tif (goal_elen)\n\t\tudf_write_aext(table, &goal_epos, &goal_eloc, goal_elen, 1);\n\telse\n\t\tudf_delete_aext(table, goal_epos, goal_eloc, goal_elen);\n\tbrelse(goal_epos.bh);\n\n\tudf_add_free_space(sb, partition, -1);\n\n\tmutex_unlock(&sbi->s_alloc_mutex);\n\t*err = 0;\n\treturn newblock;\n}"
  },
  {
    "function_name": "udf_table_prealloc_blocks",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/balloc.c",
    "lines": "579-638",
    "snippet": "static int udf_table_prealloc_blocks(struct super_block *sb,\n\t\t\t\t     struct inode *table, uint16_t partition,\n\t\t\t\t     uint32_t first_block, uint32_t block_count)\n{\n\tstruct udf_sb_info *sbi = UDF_SB(sb);\n\tint alloc_count = 0;\n\tuint32_t elen, adsize;\n\tstruct kernel_lb_addr eloc;\n\tstruct extent_position epos;\n\tint8_t etype = -1;\n\tstruct udf_inode_info *iinfo;\n\n\tif (first_block >= sbi->s_partmaps[partition].s_partition_len)\n\t\treturn 0;\n\n\tiinfo = UDF_I(table);\n\tif (iinfo->i_alloc_type == ICBTAG_FLAG_AD_SHORT)\n\t\tadsize = sizeof(struct short_ad);\n\telse if (iinfo->i_alloc_type == ICBTAG_FLAG_AD_LONG)\n\t\tadsize = sizeof(struct long_ad);\n\telse\n\t\treturn 0;\n\n\tmutex_lock(&sbi->s_alloc_mutex);\n\tepos.offset = sizeof(struct unallocSpaceEntry);\n\tepos.block = iinfo->i_location;\n\tepos.bh = NULL;\n\teloc.logicalBlockNum = 0xFFFFFFFF;\n\n\twhile (first_block != eloc.logicalBlockNum &&\n\t       (etype = udf_next_aext(table, &epos, &eloc, &elen, 1)) != -1) {\n\t\tudf_debug(\"eloc=%d, elen=%d, first_block=%d\\n\",\n\t\t\t  eloc.logicalBlockNum, elen, first_block);\n\t\t; /* empty loop body */\n\t}\n\n\tif (first_block == eloc.logicalBlockNum) {\n\t\tepos.offset -= adsize;\n\n\t\talloc_count = (elen >> sb->s_blocksize_bits);\n\t\tif (alloc_count > block_count) {\n\t\t\talloc_count = block_count;\n\t\t\teloc.logicalBlockNum += alloc_count;\n\t\t\telen -= (alloc_count << sb->s_blocksize_bits);\n\t\t\tudf_write_aext(table, &epos, &eloc,\n\t\t\t\t\t(etype << 30) | elen, 1);\n\t\t} else\n\t\t\tudf_delete_aext(table, epos, eloc,\n\t\t\t\t\t(etype << 30) | elen);\n\t} else {\n\t\talloc_count = 0;\n\t}\n\n\tbrelse(epos.bh);\n\n\tif (alloc_count)\n\t\tudf_add_free_space(sb, partition, -alloc_count);\n\tmutex_unlock(&sbi->s_alloc_mutex);\n\treturn alloc_count;\n}",
    "includes": [
      "#include \"udf_sb.h\"",
      "#include \"udf_i.h\"",
      "#include <linux/bitops.h>",
      "#include <linux/buffer_head.h>",
      "#include \"udfdecl.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&sbi->s_alloc_mutex"
          ],
          "line": 636
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "udf_add_free_space",
          "args": [
            "sb",
            "partition",
            "-alloc_count"
          ],
          "line": 635
        },
        "resolved": true,
        "details": {
          "function_name": "udf_add_free_space",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/balloc.c",
          "lines": "94-105",
          "snippet": "static void udf_add_free_space(struct super_block *sb, u16 partition, u32 cnt)\n{\n\tstruct udf_sb_info *sbi = UDF_SB(sb);\n\tstruct logicalVolIntegrityDesc *lvid;\n\n\tif (!sbi->s_lvid_bh)\n\t\treturn;\n\n\tlvid = (struct logicalVolIntegrityDesc *)sbi->s_lvid_bh->b_data;\n\tle32_add_cpu(&lvid->freeSpaceTable[partition], cnt);\n\tudf_updated_lvid(sb);\n}",
          "includes": [
            "#include \"udf_sb.h\"",
            "#include \"udf_i.h\"",
            "#include <linux/bitops.h>",
            "#include <linux/buffer_head.h>",
            "#include \"udfdecl.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"udf_sb.h\"\n#include \"udf_i.h\"\n#include <linux/bitops.h>\n#include <linux/buffer_head.h>\n#include \"udfdecl.h\"\n\nstatic void udf_add_free_space(struct super_block *sb, u16 partition, u32 cnt)\n{\n\tstruct udf_sb_info *sbi = UDF_SB(sb);\n\tstruct logicalVolIntegrityDesc *lvid;\n\n\tif (!sbi->s_lvid_bh)\n\t\treturn;\n\n\tlvid = (struct logicalVolIntegrityDesc *)sbi->s_lvid_bh->b_data;\n\tle32_add_cpu(&lvid->freeSpaceTable[partition], cnt);\n\tudf_updated_lvid(sb);\n}"
        }
      },
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "epos.bh"
          ],
          "line": 632
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "udf_delete_aext",
          "args": [
            "table",
            "epos",
            "eloc",
            "(etype << 30) | elen"
          ],
          "line": 626
        },
        "resolved": true,
        "details": {
          "function_name": "udf_delete_aext",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/inode.c",
          "lines": "2154-2235",
          "snippet": "int8_t udf_delete_aext(struct inode *inode, struct extent_position epos,\n\t\t       struct kernel_lb_addr eloc, uint32_t elen)\n{\n\tstruct extent_position oepos;\n\tint adsize;\n\tint8_t etype;\n\tstruct allocExtDesc *aed;\n\tstruct udf_inode_info *iinfo;\n\n\tif (epos.bh) {\n\t\tget_bh(epos.bh);\n\t\tget_bh(epos.bh);\n\t}\n\n\tiinfo = UDF_I(inode);\n\tif (iinfo->i_alloc_type == ICBTAG_FLAG_AD_SHORT)\n\t\tadsize = sizeof(struct short_ad);\n\telse if (iinfo->i_alloc_type == ICBTAG_FLAG_AD_LONG)\n\t\tadsize = sizeof(struct long_ad);\n\telse\n\t\tadsize = 0;\n\n\toepos = epos;\n\tif (udf_next_aext(inode, &epos, &eloc, &elen, 1) == -1)\n\t\treturn -1;\n\n\twhile ((etype = udf_next_aext(inode, &epos, &eloc, &elen, 1)) != -1) {\n\t\tudf_write_aext(inode, &oepos, &eloc, (etype << 30) | elen, 1);\n\t\tif (oepos.bh != epos.bh) {\n\t\t\toepos.block = epos.block;\n\t\t\tbrelse(oepos.bh);\n\t\t\tget_bh(epos.bh);\n\t\t\toepos.bh = epos.bh;\n\t\t\toepos.offset = epos.offset - adsize;\n\t\t}\n\t}\n\tmemset(&eloc, 0x00, sizeof(struct kernel_lb_addr));\n\telen = 0;\n\n\tif (epos.bh != oepos.bh) {\n\t\tudf_free_blocks(inode->i_sb, inode, &epos.block, 0, 1);\n\t\tudf_write_aext(inode, &oepos, &eloc, elen, 1);\n\t\tudf_write_aext(inode, &oepos, &eloc, elen, 1);\n\t\tif (!oepos.bh) {\n\t\t\tiinfo->i_lenAlloc -= (adsize * 2);\n\t\t\tmark_inode_dirty(inode);\n\t\t} else {\n\t\t\taed = (struct allocExtDesc *)oepos.bh->b_data;\n\t\t\tle32_add_cpu(&aed->lengthAllocDescs, -(2 * adsize));\n\t\t\tif (!UDF_QUERY_FLAG(inode->i_sb, UDF_FLAG_STRICT) ||\n\t\t\t    UDF_SB(inode->i_sb)->s_udfrev >= 0x0201)\n\t\t\t\tudf_update_tag(oepos.bh->b_data,\n\t\t\t\t\t\toepos.offset - (2 * adsize));\n\t\t\telse\n\t\t\t\tudf_update_tag(oepos.bh->b_data,\n\t\t\t\t\t\tsizeof(struct allocExtDesc));\n\t\t\tmark_buffer_dirty_inode(oepos.bh, inode);\n\t\t}\n\t} else {\n\t\tudf_write_aext(inode, &oepos, &eloc, elen, 1);\n\t\tif (!oepos.bh) {\n\t\t\tiinfo->i_lenAlloc -= adsize;\n\t\t\tmark_inode_dirty(inode);\n\t\t} else {\n\t\t\taed = (struct allocExtDesc *)oepos.bh->b_data;\n\t\t\tle32_add_cpu(&aed->lengthAllocDescs, -adsize);\n\t\t\tif (!UDF_QUERY_FLAG(inode->i_sb, UDF_FLAG_STRICT) ||\n\t\t\t    UDF_SB(inode->i_sb)->s_udfrev >= 0x0201)\n\t\t\t\tudf_update_tag(oepos.bh->b_data,\n\t\t\t\t\t\tepos.offset - adsize);\n\t\t\telse\n\t\t\t\tudf_update_tag(oepos.bh->b_data,\n\t\t\t\t\t\tsizeof(struct allocExtDesc));\n\t\t\tmark_buffer_dirty_inode(oepos.bh, inode);\n\t\t}\n\t}\n\n\tbrelse(epos.bh);\n\tbrelse(oepos.bh);\n\n\treturn (elen >> 30);\n}",
          "includes": [
            "#include \"udf_sb.h\"",
            "#include \"udf_i.h\"",
            "#include <linux/aio.h>",
            "#include <linux/mpage.h>",
            "#include <linux/crc-itu-t.h>",
            "#include <linux/slab.h>",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include \"udfdecl.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int udf_update_inode(struct inode *, int);",
            "static int udf_sync_inode(struct inode *inode);",
            "static int8_t udf_insert_aext(struct inode *, struct extent_position,\n\t\t\t      struct kernel_lb_addr, uint32_t);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"udf_sb.h\"\n#include \"udf_i.h\"\n#include <linux/aio.h>\n#include <linux/mpage.h>\n#include <linux/crc-itu-t.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include \"udfdecl.h\"\n\nstatic int udf_update_inode(struct inode *, int);\nstatic int udf_sync_inode(struct inode *inode);\nstatic int8_t udf_insert_aext(struct inode *, struct extent_position,\n\t\t\t      struct kernel_lb_addr, uint32_t);\n\nint8_t udf_delete_aext(struct inode *inode, struct extent_position epos,\n\t\t       struct kernel_lb_addr eloc, uint32_t elen)\n{\n\tstruct extent_position oepos;\n\tint adsize;\n\tint8_t etype;\n\tstruct allocExtDesc *aed;\n\tstruct udf_inode_info *iinfo;\n\n\tif (epos.bh) {\n\t\tget_bh(epos.bh);\n\t\tget_bh(epos.bh);\n\t}\n\n\tiinfo = UDF_I(inode);\n\tif (iinfo->i_alloc_type == ICBTAG_FLAG_AD_SHORT)\n\t\tadsize = sizeof(struct short_ad);\n\telse if (iinfo->i_alloc_type == ICBTAG_FLAG_AD_LONG)\n\t\tadsize = sizeof(struct long_ad);\n\telse\n\t\tadsize = 0;\n\n\toepos = epos;\n\tif (udf_next_aext(inode, &epos, &eloc, &elen, 1) == -1)\n\t\treturn -1;\n\n\twhile ((etype = udf_next_aext(inode, &epos, &eloc, &elen, 1)) != -1) {\n\t\tudf_write_aext(inode, &oepos, &eloc, (etype << 30) | elen, 1);\n\t\tif (oepos.bh != epos.bh) {\n\t\t\toepos.block = epos.block;\n\t\t\tbrelse(oepos.bh);\n\t\t\tget_bh(epos.bh);\n\t\t\toepos.bh = epos.bh;\n\t\t\toepos.offset = epos.offset - adsize;\n\t\t}\n\t}\n\tmemset(&eloc, 0x00, sizeof(struct kernel_lb_addr));\n\telen = 0;\n\n\tif (epos.bh != oepos.bh) {\n\t\tudf_free_blocks(inode->i_sb, inode, &epos.block, 0, 1);\n\t\tudf_write_aext(inode, &oepos, &eloc, elen, 1);\n\t\tudf_write_aext(inode, &oepos, &eloc, elen, 1);\n\t\tif (!oepos.bh) {\n\t\t\tiinfo->i_lenAlloc -= (adsize * 2);\n\t\t\tmark_inode_dirty(inode);\n\t\t} else {\n\t\t\taed = (struct allocExtDesc *)oepos.bh->b_data;\n\t\t\tle32_add_cpu(&aed->lengthAllocDescs, -(2 * adsize));\n\t\t\tif (!UDF_QUERY_FLAG(inode->i_sb, UDF_FLAG_STRICT) ||\n\t\t\t    UDF_SB(inode->i_sb)->s_udfrev >= 0x0201)\n\t\t\t\tudf_update_tag(oepos.bh->b_data,\n\t\t\t\t\t\toepos.offset - (2 * adsize));\n\t\t\telse\n\t\t\t\tudf_update_tag(oepos.bh->b_data,\n\t\t\t\t\t\tsizeof(struct allocExtDesc));\n\t\t\tmark_buffer_dirty_inode(oepos.bh, inode);\n\t\t}\n\t} else {\n\t\tudf_write_aext(inode, &oepos, &eloc, elen, 1);\n\t\tif (!oepos.bh) {\n\t\t\tiinfo->i_lenAlloc -= adsize;\n\t\t\tmark_inode_dirty(inode);\n\t\t} else {\n\t\t\taed = (struct allocExtDesc *)oepos.bh->b_data;\n\t\t\tle32_add_cpu(&aed->lengthAllocDescs, -adsize);\n\t\t\tif (!UDF_QUERY_FLAG(inode->i_sb, UDF_FLAG_STRICT) ||\n\t\t\t    UDF_SB(inode->i_sb)->s_udfrev >= 0x0201)\n\t\t\t\tudf_update_tag(oepos.bh->b_data,\n\t\t\t\t\t\tepos.offset - adsize);\n\t\t\telse\n\t\t\t\tudf_update_tag(oepos.bh->b_data,\n\t\t\t\t\t\tsizeof(struct allocExtDesc));\n\t\t\tmark_buffer_dirty_inode(oepos.bh, inode);\n\t\t}\n\t}\n\n\tbrelse(epos.bh);\n\tbrelse(oepos.bh);\n\n\treturn (elen >> 30);\n}"
        }
      },
      {
        "call_info": {
          "callee": "udf_write_aext",
          "args": [
            "table",
            "&epos",
            "&eloc",
            "(etype << 30) | elen",
            "1"
          ],
          "line": 623
        },
        "resolved": true,
        "details": {
          "function_name": "udf_write_aext",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/inode.c",
          "lines": "2005-2055",
          "snippet": "void udf_write_aext(struct inode *inode, struct extent_position *epos,\n\t\t    struct kernel_lb_addr *eloc, uint32_t elen, int inc)\n{\n\tint adsize;\n\tuint8_t *ptr;\n\tstruct short_ad *sad;\n\tstruct long_ad *lad;\n\tstruct udf_inode_info *iinfo = UDF_I(inode);\n\n\tif (!epos->bh)\n\t\tptr = iinfo->i_ext.i_data + epos->offset -\n\t\t\tudf_file_entry_alloc_offset(inode) +\n\t\t\tiinfo->i_lenEAttr;\n\telse\n\t\tptr = epos->bh->b_data + epos->offset;\n\n\tswitch (iinfo->i_alloc_type) {\n\tcase ICBTAG_FLAG_AD_SHORT:\n\t\tsad = (struct short_ad *)ptr;\n\t\tsad->extLength = cpu_to_le32(elen);\n\t\tsad->extPosition = cpu_to_le32(eloc->logicalBlockNum);\n\t\tadsize = sizeof(struct short_ad);\n\t\tbreak;\n\tcase ICBTAG_FLAG_AD_LONG:\n\t\tlad = (struct long_ad *)ptr;\n\t\tlad->extLength = cpu_to_le32(elen);\n\t\tlad->extLocation = cpu_to_lelb(*eloc);\n\t\tmemset(lad->impUse, 0x00, sizeof(lad->impUse));\n\t\tadsize = sizeof(struct long_ad);\n\t\tbreak;\n\tdefault:\n\t\treturn;\n\t}\n\n\tif (epos->bh) {\n\t\tif (!UDF_QUERY_FLAG(inode->i_sb, UDF_FLAG_STRICT) ||\n\t\t    UDF_SB(inode->i_sb)->s_udfrev >= 0x0201) {\n\t\t\tstruct allocExtDesc *aed =\n\t\t\t\t(struct allocExtDesc *)epos->bh->b_data;\n\t\t\tudf_update_tag(epos->bh->b_data,\n\t\t\t\t       le32_to_cpu(aed->lengthAllocDescs) +\n\t\t\t\t       sizeof(struct allocExtDesc));\n\t\t}\n\t\tmark_buffer_dirty_inode(epos->bh, inode);\n\t} else {\n\t\tmark_inode_dirty(inode);\n\t}\n\n\tif (inc)\n\t\tepos->offset += adsize;\n}",
          "includes": [
            "#include \"udf_sb.h\"",
            "#include \"udf_i.h\"",
            "#include <linux/aio.h>",
            "#include <linux/mpage.h>",
            "#include <linux/crc-itu-t.h>",
            "#include <linux/slab.h>",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include \"udfdecl.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int udf_update_inode(struct inode *, int);",
            "static int udf_sync_inode(struct inode *inode);",
            "static int8_t udf_insert_aext(struct inode *, struct extent_position,\n\t\t\t      struct kernel_lb_addr, uint32_t);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"udf_sb.h\"\n#include \"udf_i.h\"\n#include <linux/aio.h>\n#include <linux/mpage.h>\n#include <linux/crc-itu-t.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include \"udfdecl.h\"\n\nstatic int udf_update_inode(struct inode *, int);\nstatic int udf_sync_inode(struct inode *inode);\nstatic int8_t udf_insert_aext(struct inode *, struct extent_position,\n\t\t\t      struct kernel_lb_addr, uint32_t);\n\nvoid udf_write_aext(struct inode *inode, struct extent_position *epos,\n\t\t    struct kernel_lb_addr *eloc, uint32_t elen, int inc)\n{\n\tint adsize;\n\tuint8_t *ptr;\n\tstruct short_ad *sad;\n\tstruct long_ad *lad;\n\tstruct udf_inode_info *iinfo = UDF_I(inode);\n\n\tif (!epos->bh)\n\t\tptr = iinfo->i_ext.i_data + epos->offset -\n\t\t\tudf_file_entry_alloc_offset(inode) +\n\t\t\tiinfo->i_lenEAttr;\n\telse\n\t\tptr = epos->bh->b_data + epos->offset;\n\n\tswitch (iinfo->i_alloc_type) {\n\tcase ICBTAG_FLAG_AD_SHORT:\n\t\tsad = (struct short_ad *)ptr;\n\t\tsad->extLength = cpu_to_le32(elen);\n\t\tsad->extPosition = cpu_to_le32(eloc->logicalBlockNum);\n\t\tadsize = sizeof(struct short_ad);\n\t\tbreak;\n\tcase ICBTAG_FLAG_AD_LONG:\n\t\tlad = (struct long_ad *)ptr;\n\t\tlad->extLength = cpu_to_le32(elen);\n\t\tlad->extLocation = cpu_to_lelb(*eloc);\n\t\tmemset(lad->impUse, 0x00, sizeof(lad->impUse));\n\t\tadsize = sizeof(struct long_ad);\n\t\tbreak;\n\tdefault:\n\t\treturn;\n\t}\n\n\tif (epos->bh) {\n\t\tif (!UDF_QUERY_FLAG(inode->i_sb, UDF_FLAG_STRICT) ||\n\t\t    UDF_SB(inode->i_sb)->s_udfrev >= 0x0201) {\n\t\t\tstruct allocExtDesc *aed =\n\t\t\t\t(struct allocExtDesc *)epos->bh->b_data;\n\t\t\tudf_update_tag(epos->bh->b_data,\n\t\t\t\t       le32_to_cpu(aed->lengthAllocDescs) +\n\t\t\t\t       sizeof(struct allocExtDesc));\n\t\t}\n\t\tmark_buffer_dirty_inode(epos->bh, inode);\n\t} else {\n\t\tmark_inode_dirty(inode);\n\t}\n\n\tif (inc)\n\t\tepos->offset += adsize;\n}"
        }
      },
      {
        "call_info": {
          "callee": "udf_debug",
          "args": [
            "\"eloc=%d, elen=%d, first_block=%d\\n\"",
            "eloc.logicalBlockNum",
            "elen",
            "first_block"
          ],
          "line": 610
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "udf_next_aext",
          "args": [
            "table",
            "&epos",
            "&eloc",
            "&elen",
            "1"
          ],
          "line": 609
        },
        "resolved": true,
        "details": {
          "function_name": "udf_next_aext",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/inode.c",
          "lines": "2057-2077",
          "snippet": "int8_t udf_next_aext(struct inode *inode, struct extent_position *epos,\n\t\t     struct kernel_lb_addr *eloc, uint32_t *elen, int inc)\n{\n\tint8_t etype;\n\n\twhile ((etype = udf_current_aext(inode, epos, eloc, elen, inc)) ==\n\t       (EXT_NEXT_EXTENT_ALLOCDECS >> 30)) {\n\t\tint block;\n\t\tepos->block = *eloc;\n\t\tepos->offset = sizeof(struct allocExtDesc);\n\t\tbrelse(epos->bh);\n\t\tblock = udf_get_lb_pblock(inode->i_sb, &epos->block, 0);\n\t\tepos->bh = udf_tread(inode->i_sb, block);\n\t\tif (!epos->bh) {\n\t\t\tudf_debug(\"reading block %d failed!\\n\", block);\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\treturn etype;\n}",
          "includes": [
            "#include \"udf_sb.h\"",
            "#include \"udf_i.h\"",
            "#include <linux/aio.h>",
            "#include <linux/mpage.h>",
            "#include <linux/crc-itu-t.h>",
            "#include <linux/slab.h>",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include \"udfdecl.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int udf_update_inode(struct inode *, int);",
            "static int udf_sync_inode(struct inode *inode);",
            "static int8_t udf_insert_aext(struct inode *, struct extent_position,\n\t\t\t      struct kernel_lb_addr, uint32_t);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"udf_sb.h\"\n#include \"udf_i.h\"\n#include <linux/aio.h>\n#include <linux/mpage.h>\n#include <linux/crc-itu-t.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include \"udfdecl.h\"\n\nstatic int udf_update_inode(struct inode *, int);\nstatic int udf_sync_inode(struct inode *inode);\nstatic int8_t udf_insert_aext(struct inode *, struct extent_position,\n\t\t\t      struct kernel_lb_addr, uint32_t);\n\nint8_t udf_next_aext(struct inode *inode, struct extent_position *epos,\n\t\t     struct kernel_lb_addr *eloc, uint32_t *elen, int inc)\n{\n\tint8_t etype;\n\n\twhile ((etype = udf_current_aext(inode, epos, eloc, elen, inc)) ==\n\t       (EXT_NEXT_EXTENT_ALLOCDECS >> 30)) {\n\t\tint block;\n\t\tepos->block = *eloc;\n\t\tepos->offset = sizeof(struct allocExtDesc);\n\t\tbrelse(epos->bh);\n\t\tblock = udf_get_lb_pblock(inode->i_sb, &epos->block, 0);\n\t\tepos->bh = udf_tread(inode->i_sb, block);\n\t\tif (!epos->bh) {\n\t\t\tudf_debug(\"reading block %d failed!\\n\", block);\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\treturn etype;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&sbi->s_alloc_mutex"
          ],
          "line": 602
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UDF_I",
          "args": [
            "table"
          ],
          "line": 594
        },
        "resolved": true,
        "details": {
          "function_name": "UDF_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/udf_i.h",
          "lines": "57-60",
          "snippet": "static inline struct udf_inode_info *UDF_I(struct inode *inode)\n{\n\treturn list_entry(inode, struct udf_inode_info, vfs_inode);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline struct udf_inode_info *UDF_I(struct inode *inode)\n{\n\treturn list_entry(inode, struct udf_inode_info, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "UDF_SB",
          "args": [
            "sb"
          ],
          "line": 583
        },
        "resolved": true,
        "details": {
          "function_name": "UDF_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/udf_sb.h",
          "lines": "160-163",
          "snippet": "static inline struct udf_sb_info *UDF_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include <linux/bitops.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bitops.h>\n#include <linux/mutex.h>\n\nstatic inline struct udf_sb_info *UDF_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"udf_sb.h\"\n#include \"udf_i.h\"\n#include <linux/bitops.h>\n#include <linux/buffer_head.h>\n#include \"udfdecl.h\"\n\nstatic int udf_table_prealloc_blocks(struct super_block *sb,\n\t\t\t\t     struct inode *table, uint16_t partition,\n\t\t\t\t     uint32_t first_block, uint32_t block_count)\n{\n\tstruct udf_sb_info *sbi = UDF_SB(sb);\n\tint alloc_count = 0;\n\tuint32_t elen, adsize;\n\tstruct kernel_lb_addr eloc;\n\tstruct extent_position epos;\n\tint8_t etype = -1;\n\tstruct udf_inode_info *iinfo;\n\n\tif (first_block >= sbi->s_partmaps[partition].s_partition_len)\n\t\treturn 0;\n\n\tiinfo = UDF_I(table);\n\tif (iinfo->i_alloc_type == ICBTAG_FLAG_AD_SHORT)\n\t\tadsize = sizeof(struct short_ad);\n\telse if (iinfo->i_alloc_type == ICBTAG_FLAG_AD_LONG)\n\t\tadsize = sizeof(struct long_ad);\n\telse\n\t\treturn 0;\n\n\tmutex_lock(&sbi->s_alloc_mutex);\n\tepos.offset = sizeof(struct unallocSpaceEntry);\n\tepos.block = iinfo->i_location;\n\tepos.bh = NULL;\n\teloc.logicalBlockNum = 0xFFFFFFFF;\n\n\twhile (first_block != eloc.logicalBlockNum &&\n\t       (etype = udf_next_aext(table, &epos, &eloc, &elen, 1)) != -1) {\n\t\tudf_debug(\"eloc=%d, elen=%d, first_block=%d\\n\",\n\t\t\t  eloc.logicalBlockNum, elen, first_block);\n\t\t; /* empty loop body */\n\t}\n\n\tif (first_block == eloc.logicalBlockNum) {\n\t\tepos.offset -= adsize;\n\n\t\talloc_count = (elen >> sb->s_blocksize_bits);\n\t\tif (alloc_count > block_count) {\n\t\t\talloc_count = block_count;\n\t\t\teloc.logicalBlockNum += alloc_count;\n\t\t\telen -= (alloc_count << sb->s_blocksize_bits);\n\t\t\tudf_write_aext(table, &epos, &eloc,\n\t\t\t\t\t(etype << 30) | elen, 1);\n\t\t} else\n\t\t\tudf_delete_aext(table, epos, eloc,\n\t\t\t\t\t(etype << 30) | elen);\n\t} else {\n\t\talloc_count = 0;\n\t}\n\n\tbrelse(epos.bh);\n\n\tif (alloc_count)\n\t\tudf_add_free_space(sb, partition, -alloc_count);\n\tmutex_unlock(&sbi->s_alloc_mutex);\n\treturn alloc_count;\n}"
  },
  {
    "function_name": "udf_table_free_blocks",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/balloc.c",
    "lines": "348-577",
    "snippet": "static void udf_table_free_blocks(struct super_block *sb,\n\t\t\t\t  struct inode *table,\n\t\t\t\t  struct kernel_lb_addr *bloc,\n\t\t\t\t  uint32_t offset,\n\t\t\t\t  uint32_t count)\n{\n\tstruct udf_sb_info *sbi = UDF_SB(sb);\n\tstruct udf_part_map *partmap;\n\tuint32_t start, end;\n\tuint32_t elen;\n\tstruct kernel_lb_addr eloc;\n\tstruct extent_position oepos, epos;\n\tint8_t etype;\n\tint i;\n\tstruct udf_inode_info *iinfo;\n\n\tmutex_lock(&sbi->s_alloc_mutex);\n\tpartmap = &sbi->s_partmaps[bloc->partitionReferenceNum];\n\tif (bloc->logicalBlockNum + count < count ||\n\t    (bloc->logicalBlockNum + count) > partmap->s_partition_len) {\n\t\tudf_debug(\"%d < %d || %d + %d > %d\\n\",\n\t\t\t  bloc->logicalBlockNum, 0,\n\t\t\t  bloc->logicalBlockNum, count,\n\t\t\t  partmap->s_partition_len);\n\t\tgoto error_return;\n\t}\n\n\tiinfo = UDF_I(table);\n\tudf_add_free_space(sb, sbi->s_partition, count);\n\n\tstart = bloc->logicalBlockNum + offset;\n\tend = bloc->logicalBlockNum + offset + count - 1;\n\n\tepos.offset = oepos.offset = sizeof(struct unallocSpaceEntry);\n\telen = 0;\n\tepos.block = oepos.block = iinfo->i_location;\n\tepos.bh = oepos.bh = NULL;\n\n\twhile (count &&\n\t       (etype = udf_next_aext(table, &epos, &eloc, &elen, 1)) != -1) {\n\t\tif (((eloc.logicalBlockNum +\n\t\t\t(elen >> sb->s_blocksize_bits)) == start)) {\n\t\t\tif ((0x3FFFFFFF - elen) <\n\t\t\t\t\t(count << sb->s_blocksize_bits)) {\n\t\t\t\tuint32_t tmp = ((0x3FFFFFFF - elen) >>\n\t\t\t\t\t\t\tsb->s_blocksize_bits);\n\t\t\t\tcount -= tmp;\n\t\t\t\tstart += tmp;\n\t\t\t\telen = (etype << 30) |\n\t\t\t\t\t(0x40000000 - sb->s_blocksize);\n\t\t\t} else {\n\t\t\t\telen = (etype << 30) |\n\t\t\t\t\t(elen +\n\t\t\t\t\t(count << sb->s_blocksize_bits));\n\t\t\t\tstart += count;\n\t\t\t\tcount = 0;\n\t\t\t}\n\t\t\tudf_write_aext(table, &oepos, &eloc, elen, 1);\n\t\t} else if (eloc.logicalBlockNum == (end + 1)) {\n\t\t\tif ((0x3FFFFFFF - elen) <\n\t\t\t\t\t(count << sb->s_blocksize_bits)) {\n\t\t\t\tuint32_t tmp = ((0x3FFFFFFF - elen) >>\n\t\t\t\t\t\tsb->s_blocksize_bits);\n\t\t\t\tcount -= tmp;\n\t\t\t\tend -= tmp;\n\t\t\t\teloc.logicalBlockNum -= tmp;\n\t\t\t\telen = (etype << 30) |\n\t\t\t\t\t(0x40000000 - sb->s_blocksize);\n\t\t\t} else {\n\t\t\t\teloc.logicalBlockNum = start;\n\t\t\t\telen = (etype << 30) |\n\t\t\t\t\t(elen +\n\t\t\t\t\t(count << sb->s_blocksize_bits));\n\t\t\t\tend -= count;\n\t\t\t\tcount = 0;\n\t\t\t}\n\t\t\tudf_write_aext(table, &oepos, &eloc, elen, 1);\n\t\t}\n\n\t\tif (epos.bh != oepos.bh) {\n\t\t\ti = -1;\n\t\t\toepos.block = epos.block;\n\t\t\tbrelse(oepos.bh);\n\t\t\tget_bh(epos.bh);\n\t\t\toepos.bh = epos.bh;\n\t\t\toepos.offset = 0;\n\t\t} else {\n\t\t\toepos.offset = epos.offset;\n\t\t}\n\t}\n\n\tif (count) {\n\t\t/*\n\t\t * NOTE: we CANNOT use udf_add_aext here, as it can try to\n\t\t * allocate a new block, and since we hold the super block\n\t\t * lock already very bad things would happen :)\n\t\t *\n\t\t * We copy the behavior of udf_add_aext, but instead of\n\t\t * trying to allocate a new block close to the existing one,\n\t\t * we just steal a block from the extent we are trying to add.\n\t\t *\n\t\t * It would be nice if the blocks were close together, but it\n\t\t * isn't required.\n\t\t */\n\n\t\tint adsize;\n\t\tstruct short_ad *sad = NULL;\n\t\tstruct long_ad *lad = NULL;\n\t\tstruct allocExtDesc *aed;\n\n\t\teloc.logicalBlockNum = start;\n\t\telen = EXT_RECORDED_ALLOCATED |\n\t\t\t(count << sb->s_blocksize_bits);\n\n\t\tif (iinfo->i_alloc_type == ICBTAG_FLAG_AD_SHORT)\n\t\t\tadsize = sizeof(struct short_ad);\n\t\telse if (iinfo->i_alloc_type == ICBTAG_FLAG_AD_LONG)\n\t\t\tadsize = sizeof(struct long_ad);\n\t\telse {\n\t\t\tbrelse(oepos.bh);\n\t\t\tbrelse(epos.bh);\n\t\t\tgoto error_return;\n\t\t}\n\n\t\tif (epos.offset + (2 * adsize) > sb->s_blocksize) {\n\t\t\tunsigned char *sptr, *dptr;\n\t\t\tint loffset;\n\n\t\t\tbrelse(oepos.bh);\n\t\t\toepos = epos;\n\n\t\t\t/* Steal a block from the extent being free'd */\n\t\t\tepos.block.logicalBlockNum = eloc.logicalBlockNum;\n\t\t\teloc.logicalBlockNum++;\n\t\t\telen -= sb->s_blocksize;\n\n\t\t\tepos.bh = udf_tread(sb,\n\t\t\t\t\tudf_get_lb_pblock(sb, &epos.block, 0));\n\t\t\tif (!epos.bh) {\n\t\t\t\tbrelse(oepos.bh);\n\t\t\t\tgoto error_return;\n\t\t\t}\n\t\t\taed = (struct allocExtDesc *)(epos.bh->b_data);\n\t\t\taed->previousAllocExtLocation =\n\t\t\t\tcpu_to_le32(oepos.block.logicalBlockNum);\n\t\t\tif (epos.offset + adsize > sb->s_blocksize) {\n\t\t\t\tloffset = epos.offset;\n\t\t\t\taed->lengthAllocDescs = cpu_to_le32(adsize);\n\t\t\t\tsptr = iinfo->i_ext.i_data + epos.offset\n\t\t\t\t\t\t\t\t- adsize;\n\t\t\t\tdptr = epos.bh->b_data +\n\t\t\t\t\tsizeof(struct allocExtDesc);\n\t\t\t\tmemcpy(dptr, sptr, adsize);\n\t\t\t\tepos.offset = sizeof(struct allocExtDesc) +\n\t\t\t\t\t\tadsize;\n\t\t\t} else {\n\t\t\t\tloffset = epos.offset + adsize;\n\t\t\t\taed->lengthAllocDescs = cpu_to_le32(0);\n\t\t\t\tif (oepos.bh) {\n\t\t\t\t\tsptr = oepos.bh->b_data + epos.offset;\n\t\t\t\t\taed = (struct allocExtDesc *)\n\t\t\t\t\t\toepos.bh->b_data;\n\t\t\t\t\tle32_add_cpu(&aed->lengthAllocDescs,\n\t\t\t\t\t\t\tadsize);\n\t\t\t\t} else {\n\t\t\t\t\tsptr = iinfo->i_ext.i_data +\n\t\t\t\t\t\t\t\tepos.offset;\n\t\t\t\t\tiinfo->i_lenAlloc += adsize;\n\t\t\t\t\tmark_inode_dirty(table);\n\t\t\t\t}\n\t\t\t\tepos.offset = sizeof(struct allocExtDesc);\n\t\t\t}\n\t\t\tif (sbi->s_udfrev >= 0x0200)\n\t\t\t\tudf_new_tag(epos.bh->b_data, TAG_IDENT_AED,\n\t\t\t\t\t    3, 1, epos.block.logicalBlockNum,\n\t\t\t\t\t    sizeof(struct tag));\n\t\t\telse\n\t\t\t\tudf_new_tag(epos.bh->b_data, TAG_IDENT_AED,\n\t\t\t\t\t    2, 1, epos.block.logicalBlockNum,\n\t\t\t\t\t    sizeof(struct tag));\n\n\t\t\tswitch (iinfo->i_alloc_type) {\n\t\t\tcase ICBTAG_FLAG_AD_SHORT:\n\t\t\t\tsad = (struct short_ad *)sptr;\n\t\t\t\tsad->extLength = cpu_to_le32(\n\t\t\t\t\tEXT_NEXT_EXTENT_ALLOCDECS |\n\t\t\t\t\tsb->s_blocksize);\n\t\t\t\tsad->extPosition =\n\t\t\t\t\tcpu_to_le32(epos.block.logicalBlockNum);\n\t\t\t\tbreak;\n\t\t\tcase ICBTAG_FLAG_AD_LONG:\n\t\t\t\tlad = (struct long_ad *)sptr;\n\t\t\t\tlad->extLength = cpu_to_le32(\n\t\t\t\t\tEXT_NEXT_EXTENT_ALLOCDECS |\n\t\t\t\t\tsb->s_blocksize);\n\t\t\t\tlad->extLocation =\n\t\t\t\t\tcpu_to_lelb(epos.block);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (oepos.bh) {\n\t\t\t\tudf_update_tag(oepos.bh->b_data, loffset);\n\t\t\t\tmark_buffer_dirty(oepos.bh);\n\t\t\t} else {\n\t\t\t\tmark_inode_dirty(table);\n\t\t\t}\n\t\t}\n\n\t\t/* It's possible that stealing the block emptied the extent */\n\t\tif (elen) {\n\t\t\tudf_write_aext(table, &epos, &eloc, elen, 1);\n\n\t\t\tif (!epos.bh) {\n\t\t\t\tiinfo->i_lenAlloc += adsize;\n\t\t\t\tmark_inode_dirty(table);\n\t\t\t} else {\n\t\t\t\taed = (struct allocExtDesc *)epos.bh->b_data;\n\t\t\t\tle32_add_cpu(&aed->lengthAllocDescs, adsize);\n\t\t\t\tudf_update_tag(epos.bh->b_data, epos.offset);\n\t\t\t\tmark_buffer_dirty(epos.bh);\n\t\t\t}\n\t\t}\n\t}\n\n\tbrelse(epos.bh);\n\tbrelse(oepos.bh);\n\nerror_return:\n\tmutex_unlock(&sbi->s_alloc_mutex);\n\treturn;\n}",
    "includes": [
      "#include \"udf_sb.h\"",
      "#include \"udf_i.h\"",
      "#include <linux/bitops.h>",
      "#include <linux/buffer_head.h>",
      "#include \"udfdecl.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&sbi->s_alloc_mutex"
          ],
          "line": 575
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "oepos.bh"
          ],
          "line": 572
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "mark_buffer_dirty",
          "args": [
            "epos.bh"
          ],
          "line": 566
        },
        "resolved": true,
        "details": {
          "function_name": "mark_buffer_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1141-1167",
          "snippet": "void mark_buffer_dirty(struct buffer_head *bh)\n{\n\tWARN_ON_ONCE(!buffer_uptodate(bh));\n\n\ttrace_block_dirty_buffer(bh);\n\n\t/*\n\t * Very *carefully* optimize the it-is-already-dirty case.\n\t *\n\t * Don't let the final \"is it dirty\" escape to before we\n\t * perhaps modified the buffer.\n\t */\n\tif (buffer_dirty(bh)) {\n\t\tsmp_mb();\n\t\tif (buffer_dirty(bh))\n\t\t\treturn;\n\t}\n\n\tif (!test_set_buffer_dirty(bh)) {\n\t\tstruct page *page = bh->b_page;\n\t\tif (!TestSetPageDirty(page)) {\n\t\t\tstruct address_space *mapping = page_mapping(page);\n\t\t\tif (mapping)\n\t\t\t\t__set_page_dirty(page, mapping, 0);\n\t\t}\n\t}\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid mark_buffer_dirty(struct buffer_head *bh)\n{\n\tWARN_ON_ONCE(!buffer_uptodate(bh));\n\n\ttrace_block_dirty_buffer(bh);\n\n\t/*\n\t * Very *carefully* optimize the it-is-already-dirty case.\n\t *\n\t * Don't let the final \"is it dirty\" escape to before we\n\t * perhaps modified the buffer.\n\t */\n\tif (buffer_dirty(bh)) {\n\t\tsmp_mb();\n\t\tif (buffer_dirty(bh))\n\t\t\treturn;\n\t}\n\n\tif (!test_set_buffer_dirty(bh)) {\n\t\tstruct page *page = bh->b_page;\n\t\tif (!TestSetPageDirty(page)) {\n\t\t\tstruct address_space *mapping = page_mapping(page);\n\t\t\tif (mapping)\n\t\t\t\t__set_page_dirty(page, mapping, 0);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "udf_update_tag",
          "args": [
            "epos.bh->b_data",
            "epos.offset"
          ],
          "line": 565
        },
        "resolved": true,
        "details": {
          "function_name": "udf_update_tag",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/misc.c",
          "lines": "269-277",
          "snippet": "void udf_update_tag(char *data, int length)\n{\n\tstruct tag *tptr = (struct tag *)data;\n\tlength -= sizeof(struct tag);\n\n\ttptr->descCRCLength = cpu_to_le16(length);\n\ttptr->descCRC = cpu_to_le16(crc_itu_t(0, data + sizeof(struct tag), length));\n\ttptr->tagChecksum = udf_tag_checksum(tptr);\n}",
          "includes": [
            "#include \"udf_sb.h\"",
            "#include \"udf_i.h\"",
            "#include <linux/crc-itu-t.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/fs.h>",
            "#include \"udfdecl.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"udf_sb.h\"\n#include \"udf_i.h\"\n#include <linux/crc-itu-t.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/fs.h>\n#include \"udfdecl.h\"\n\nvoid udf_update_tag(char *data, int length)\n{\n\tstruct tag *tptr = (struct tag *)data;\n\tlength -= sizeof(struct tag);\n\n\ttptr->descCRCLength = cpu_to_le16(length);\n\ttptr->descCRC = cpu_to_le16(crc_itu_t(0, data + sizeof(struct tag), length));\n\ttptr->tagChecksum = udf_tag_checksum(tptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "le32_add_cpu",
          "args": [
            "&aed->lengthAllocDescs",
            "adsize"
          ],
          "line": 564
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mark_inode_dirty",
          "args": [
            "table"
          ],
          "line": 561
        },
        "resolved": true,
        "details": {
          "function_name": "block_dump___mark_inode_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fs-writeback.c",
          "lines": "1134-1154",
          "snippet": "static noinline void block_dump___mark_inode_dirty(struct inode *inode)\n{\n\tif (inode->i_ino || strcmp(inode->i_sb->s_id, \"bdev\")) {\n\t\tstruct dentry *dentry;\n\t\tconst char *name = \"?\";\n\n\t\tdentry = d_find_alias(inode);\n\t\tif (dentry) {\n\t\t\tspin_lock(&dentry->d_lock);\n\t\t\tname = (const char *) dentry->d_name.name;\n\t\t}\n\t\tprintk(KERN_DEBUG\n\t\t       \"%s(%d): dirtied inode %lu (%s) on %s\\n\",\n\t\t       current->comm, task_pid_nr(current), inode->i_ino,\n\t\t       name, inode->i_sb->s_id);\n\t\tif (dentry) {\n\t\t\tspin_unlock(&dentry->d_lock);\n\t\t\tdput(dentry);\n\t\t}\n\t}\n}",
          "includes": [
            "#include <trace/events/writeback.h>",
            "#include \"internal.h\"",
            "#include <linux/device.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/writeback.h>\n#include \"internal.h\"\n#include <linux/device.h>\n#include <linux/tracepoint.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nstatic noinline void block_dump___mark_inode_dirty(struct inode *inode)\n{\n\tif (inode->i_ino || strcmp(inode->i_sb->s_id, \"bdev\")) {\n\t\tstruct dentry *dentry;\n\t\tconst char *name = \"?\";\n\n\t\tdentry = d_find_alias(inode);\n\t\tif (dentry) {\n\t\t\tspin_lock(&dentry->d_lock);\n\t\t\tname = (const char *) dentry->d_name.name;\n\t\t}\n\t\tprintk(KERN_DEBUG\n\t\t       \"%s(%d): dirtied inode %lu (%s) on %s\\n\",\n\t\t       current->comm, task_pid_nr(current), inode->i_ino,\n\t\t       name, inode->i_sb->s_id);\n\t\tif (dentry) {\n\t\t\tspin_unlock(&dentry->d_lock);\n\t\t\tdput(dentry);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "udf_write_aext",
          "args": [
            "table",
            "&epos",
            "&eloc",
            "elen",
            "1"
          ],
          "line": 557
        },
        "resolved": true,
        "details": {
          "function_name": "udf_write_aext",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/inode.c",
          "lines": "2005-2055",
          "snippet": "void udf_write_aext(struct inode *inode, struct extent_position *epos,\n\t\t    struct kernel_lb_addr *eloc, uint32_t elen, int inc)\n{\n\tint adsize;\n\tuint8_t *ptr;\n\tstruct short_ad *sad;\n\tstruct long_ad *lad;\n\tstruct udf_inode_info *iinfo = UDF_I(inode);\n\n\tif (!epos->bh)\n\t\tptr = iinfo->i_ext.i_data + epos->offset -\n\t\t\tudf_file_entry_alloc_offset(inode) +\n\t\t\tiinfo->i_lenEAttr;\n\telse\n\t\tptr = epos->bh->b_data + epos->offset;\n\n\tswitch (iinfo->i_alloc_type) {\n\tcase ICBTAG_FLAG_AD_SHORT:\n\t\tsad = (struct short_ad *)ptr;\n\t\tsad->extLength = cpu_to_le32(elen);\n\t\tsad->extPosition = cpu_to_le32(eloc->logicalBlockNum);\n\t\tadsize = sizeof(struct short_ad);\n\t\tbreak;\n\tcase ICBTAG_FLAG_AD_LONG:\n\t\tlad = (struct long_ad *)ptr;\n\t\tlad->extLength = cpu_to_le32(elen);\n\t\tlad->extLocation = cpu_to_lelb(*eloc);\n\t\tmemset(lad->impUse, 0x00, sizeof(lad->impUse));\n\t\tadsize = sizeof(struct long_ad);\n\t\tbreak;\n\tdefault:\n\t\treturn;\n\t}\n\n\tif (epos->bh) {\n\t\tif (!UDF_QUERY_FLAG(inode->i_sb, UDF_FLAG_STRICT) ||\n\t\t    UDF_SB(inode->i_sb)->s_udfrev >= 0x0201) {\n\t\t\tstruct allocExtDesc *aed =\n\t\t\t\t(struct allocExtDesc *)epos->bh->b_data;\n\t\t\tudf_update_tag(epos->bh->b_data,\n\t\t\t\t       le32_to_cpu(aed->lengthAllocDescs) +\n\t\t\t\t       sizeof(struct allocExtDesc));\n\t\t}\n\t\tmark_buffer_dirty_inode(epos->bh, inode);\n\t} else {\n\t\tmark_inode_dirty(inode);\n\t}\n\n\tif (inc)\n\t\tepos->offset += adsize;\n}",
          "includes": [
            "#include \"udf_sb.h\"",
            "#include \"udf_i.h\"",
            "#include <linux/aio.h>",
            "#include <linux/mpage.h>",
            "#include <linux/crc-itu-t.h>",
            "#include <linux/slab.h>",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include \"udfdecl.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int udf_update_inode(struct inode *, int);",
            "static int udf_sync_inode(struct inode *inode);",
            "static int8_t udf_insert_aext(struct inode *, struct extent_position,\n\t\t\t      struct kernel_lb_addr, uint32_t);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"udf_sb.h\"\n#include \"udf_i.h\"\n#include <linux/aio.h>\n#include <linux/mpage.h>\n#include <linux/crc-itu-t.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include \"udfdecl.h\"\n\nstatic int udf_update_inode(struct inode *, int);\nstatic int udf_sync_inode(struct inode *inode);\nstatic int8_t udf_insert_aext(struct inode *, struct extent_position,\n\t\t\t      struct kernel_lb_addr, uint32_t);\n\nvoid udf_write_aext(struct inode *inode, struct extent_position *epos,\n\t\t    struct kernel_lb_addr *eloc, uint32_t elen, int inc)\n{\n\tint adsize;\n\tuint8_t *ptr;\n\tstruct short_ad *sad;\n\tstruct long_ad *lad;\n\tstruct udf_inode_info *iinfo = UDF_I(inode);\n\n\tif (!epos->bh)\n\t\tptr = iinfo->i_ext.i_data + epos->offset -\n\t\t\tudf_file_entry_alloc_offset(inode) +\n\t\t\tiinfo->i_lenEAttr;\n\telse\n\t\tptr = epos->bh->b_data + epos->offset;\n\n\tswitch (iinfo->i_alloc_type) {\n\tcase ICBTAG_FLAG_AD_SHORT:\n\t\tsad = (struct short_ad *)ptr;\n\t\tsad->extLength = cpu_to_le32(elen);\n\t\tsad->extPosition = cpu_to_le32(eloc->logicalBlockNum);\n\t\tadsize = sizeof(struct short_ad);\n\t\tbreak;\n\tcase ICBTAG_FLAG_AD_LONG:\n\t\tlad = (struct long_ad *)ptr;\n\t\tlad->extLength = cpu_to_le32(elen);\n\t\tlad->extLocation = cpu_to_lelb(*eloc);\n\t\tmemset(lad->impUse, 0x00, sizeof(lad->impUse));\n\t\tadsize = sizeof(struct long_ad);\n\t\tbreak;\n\tdefault:\n\t\treturn;\n\t}\n\n\tif (epos->bh) {\n\t\tif (!UDF_QUERY_FLAG(inode->i_sb, UDF_FLAG_STRICT) ||\n\t\t    UDF_SB(inode->i_sb)->s_udfrev >= 0x0201) {\n\t\t\tstruct allocExtDesc *aed =\n\t\t\t\t(struct allocExtDesc *)epos->bh->b_data;\n\t\t\tudf_update_tag(epos->bh->b_data,\n\t\t\t\t       le32_to_cpu(aed->lengthAllocDescs) +\n\t\t\t\t       sizeof(struct allocExtDesc));\n\t\t}\n\t\tmark_buffer_dirty_inode(epos->bh, inode);\n\t} else {\n\t\tmark_inode_dirty(inode);\n\t}\n\n\tif (inc)\n\t\tepos->offset += adsize;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_lelb",
          "args": [
            "epos.block"
          ],
          "line": 544
        },
        "resolved": true,
        "details": {
          "function_name": "cpu_to_lelb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/udfend.h",
          "lines": "17-25",
          "snippet": "static inline struct lb_addr cpu_to_lelb(struct kernel_lb_addr in)\n{\n\tstruct lb_addr out;\n\n\tout.logicalBlockNum = cpu_to_le32(in.logicalBlockNum);\n\tout.partitionReferenceNum = cpu_to_le16(in.partitionReferenceNum);\n\n\treturn out;\n}",
          "includes": [
            "#include <linux/string.h>",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/string.h>\n#include <asm/byteorder.h>\n\nstatic inline struct lb_addr cpu_to_lelb(struct kernel_lb_addr in)\n{\n\tstruct lb_addr out;\n\n\tout.logicalBlockNum = cpu_to_le32(in.logicalBlockNum);\n\tout.partitionReferenceNum = cpu_to_le16(in.partitionReferenceNum);\n\n\treturn out;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "EXT_NEXT_EXTENT_ALLOCDECS |\n\t\t\t\t\tsb->s_blocksize"
          ],
          "line": 540
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "epos.block.logicalBlockNum"
          ],
          "line": 536
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "EXT_NEXT_EXTENT_ALLOCDECS |\n\t\t\t\t\tsb->s_blocksize"
          ],
          "line": 532
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "udf_new_tag",
          "args": [
            "epos.bh->b_data",
            "TAG_IDENT_AED",
            "2",
            "1",
            "epos.block.logicalBlockNum",
            "sizeof(struct tag)"
          ],
          "line": 525
        },
        "resolved": true,
        "details": {
          "function_name": "udf_new_tag",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/misc.c",
          "lines": "279-288",
          "snippet": "void udf_new_tag(char *data, uint16_t ident, uint16_t version, uint16_t snum,\n\t\t uint32_t loc, int length)\n{\n\tstruct tag *tptr = (struct tag *)data;\n\ttptr->tagIdent = cpu_to_le16(ident);\n\ttptr->descVersion = cpu_to_le16(version);\n\ttptr->tagSerialNum = cpu_to_le16(snum);\n\ttptr->tagLocation = cpu_to_le32(loc);\n\tudf_update_tag(data, length);\n}",
          "includes": [
            "#include \"udf_sb.h\"",
            "#include \"udf_i.h\"",
            "#include <linux/crc-itu-t.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/fs.h>",
            "#include \"udfdecl.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"udf_sb.h\"\n#include \"udf_i.h\"\n#include <linux/crc-itu-t.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/fs.h>\n#include \"udfdecl.h\"\n\nvoid udf_new_tag(char *data, uint16_t ident, uint16_t version, uint16_t snum,\n\t\t uint32_t loc, int length)\n{\n\tstruct tag *tptr = (struct tag *)data;\n\ttptr->tagIdent = cpu_to_le16(ident);\n\ttptr->descVersion = cpu_to_le16(version);\n\ttptr->tagSerialNum = cpu_to_le16(snum);\n\ttptr->tagLocation = cpu_to_le32(loc);\n\tudf_update_tag(data, length);\n}"
        }
      },
      {
        "call_info": {
          "callee": "le32_add_cpu",
          "args": [
            "&aed->lengthAllocDescs",
            "adsize"
          ],
          "line": 510
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "0"
          ],
          "line": 505
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "dptr",
            "sptr",
            "adsize"
          ],
          "line": 500
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "adsize"
          ],
          "line": 495
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "oepos.block.logicalBlockNum"
          ],
          "line": 492
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "udf_tread",
          "args": [
            "sb",
            "udf_get_lb_pblock(sb, &epos.block, 0)"
          ],
          "line": 484
        },
        "resolved": true,
        "details": {
          "function_name": "udf_tread",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/misc.c",
          "lines": "40-46",
          "snippet": "struct buffer_head *udf_tread(struct super_block *sb, int block)\n{\n\tif (UDF_QUERY_FLAG(sb, UDF_FLAG_VARCONV))\n\t\treturn sb_bread(sb, udf_fixed_to_variable(block));\n\telse\n\t\treturn sb_bread(sb, block);\n}",
          "includes": [
            "#include \"udf_sb.h\"",
            "#include \"udf_i.h\"",
            "#include <linux/crc-itu-t.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/fs.h>",
            "#include \"udfdecl.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"udf_sb.h\"\n#include \"udf_i.h\"\n#include <linux/crc-itu-t.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/fs.h>\n#include \"udfdecl.h\"\n\nstruct buffer_head *udf_tread(struct super_block *sb, int block)\n{\n\tif (UDF_QUERY_FLAG(sb, UDF_FLAG_VARCONV))\n\t\treturn sb_bread(sb, udf_fixed_to_variable(block));\n\telse\n\t\treturn sb_bread(sb, block);\n}"
        }
      },
      {
        "call_info": {
          "callee": "udf_get_lb_pblock",
          "args": [
            "sb",
            "&epos.block",
            "0"
          ],
          "line": 485
        },
        "resolved": true,
        "details": {
          "function_name": "udf_get_lb_pblock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/udfdecl.h",
          "lines": "205-211",
          "snippet": "static inline uint32_t\nudf_get_lb_pblock(struct super_block *sb, struct kernel_lb_addr *loc,\n\t\t  uint32_t offset)\n{\n\treturn udf_get_pblock(sb, loc->logicalBlockNum,\n\t\t\tloc->partitionReferenceNum, offset);\n}",
          "includes": [
            "#include \"udf_i.h\"",
            "#include \"udfend.h\"",
            "#include \"udf_sb.h\"",
            "#include <linux/udf_fs_i.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include \"osta_udf.h\"",
            "#include \"ecma_167.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"udf_i.h\"\n#include \"udfend.h\"\n#include \"udf_sb.h\"\n#include <linux/udf_fs_i.h>\n#include <linux/buffer_head.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include \"osta_udf.h\"\n#include \"ecma_167.h\"\n\nstatic inline uint32_t\nudf_get_lb_pblock(struct super_block *sb, struct kernel_lb_addr *loc,\n\t\t  uint32_t offset)\n{\n\treturn udf_get_pblock(sb, loc->logicalBlockNum,\n\t\t\tloc->partitionReferenceNum, offset);\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_bh",
          "args": [
            "epos.bh"
          ],
          "line": 431
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "udf_next_aext",
          "args": [
            "table",
            "&epos",
            "&eloc",
            "&elen",
            "1"
          ],
          "line": 387
        },
        "resolved": true,
        "details": {
          "function_name": "udf_next_aext",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/inode.c",
          "lines": "2057-2077",
          "snippet": "int8_t udf_next_aext(struct inode *inode, struct extent_position *epos,\n\t\t     struct kernel_lb_addr *eloc, uint32_t *elen, int inc)\n{\n\tint8_t etype;\n\n\twhile ((etype = udf_current_aext(inode, epos, eloc, elen, inc)) ==\n\t       (EXT_NEXT_EXTENT_ALLOCDECS >> 30)) {\n\t\tint block;\n\t\tepos->block = *eloc;\n\t\tepos->offset = sizeof(struct allocExtDesc);\n\t\tbrelse(epos->bh);\n\t\tblock = udf_get_lb_pblock(inode->i_sb, &epos->block, 0);\n\t\tepos->bh = udf_tread(inode->i_sb, block);\n\t\tif (!epos->bh) {\n\t\t\tudf_debug(\"reading block %d failed!\\n\", block);\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\treturn etype;\n}",
          "includes": [
            "#include \"udf_sb.h\"",
            "#include \"udf_i.h\"",
            "#include <linux/aio.h>",
            "#include <linux/mpage.h>",
            "#include <linux/crc-itu-t.h>",
            "#include <linux/slab.h>",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include \"udfdecl.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int udf_update_inode(struct inode *, int);",
            "static int udf_sync_inode(struct inode *inode);",
            "static int8_t udf_insert_aext(struct inode *, struct extent_position,\n\t\t\t      struct kernel_lb_addr, uint32_t);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"udf_sb.h\"\n#include \"udf_i.h\"\n#include <linux/aio.h>\n#include <linux/mpage.h>\n#include <linux/crc-itu-t.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include \"udfdecl.h\"\n\nstatic int udf_update_inode(struct inode *, int);\nstatic int udf_sync_inode(struct inode *inode);\nstatic int8_t udf_insert_aext(struct inode *, struct extent_position,\n\t\t\t      struct kernel_lb_addr, uint32_t);\n\nint8_t udf_next_aext(struct inode *inode, struct extent_position *epos,\n\t\t     struct kernel_lb_addr *eloc, uint32_t *elen, int inc)\n{\n\tint8_t etype;\n\n\twhile ((etype = udf_current_aext(inode, epos, eloc, elen, inc)) ==\n\t       (EXT_NEXT_EXTENT_ALLOCDECS >> 30)) {\n\t\tint block;\n\t\tepos->block = *eloc;\n\t\tepos->offset = sizeof(struct allocExtDesc);\n\t\tbrelse(epos->bh);\n\t\tblock = udf_get_lb_pblock(inode->i_sb, &epos->block, 0);\n\t\tepos->bh = udf_tread(inode->i_sb, block);\n\t\tif (!epos->bh) {\n\t\t\tudf_debug(\"reading block %d failed!\\n\", block);\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\treturn etype;\n}"
        }
      },
      {
        "call_info": {
          "callee": "udf_add_free_space",
          "args": [
            "sb",
            "sbi->s_partition",
            "count"
          ],
          "line": 376
        },
        "resolved": true,
        "details": {
          "function_name": "udf_add_free_space",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/balloc.c",
          "lines": "94-105",
          "snippet": "static void udf_add_free_space(struct super_block *sb, u16 partition, u32 cnt)\n{\n\tstruct udf_sb_info *sbi = UDF_SB(sb);\n\tstruct logicalVolIntegrityDesc *lvid;\n\n\tif (!sbi->s_lvid_bh)\n\t\treturn;\n\n\tlvid = (struct logicalVolIntegrityDesc *)sbi->s_lvid_bh->b_data;\n\tle32_add_cpu(&lvid->freeSpaceTable[partition], cnt);\n\tudf_updated_lvid(sb);\n}",
          "includes": [
            "#include \"udf_sb.h\"",
            "#include \"udf_i.h\"",
            "#include <linux/bitops.h>",
            "#include <linux/buffer_head.h>",
            "#include \"udfdecl.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"udf_sb.h\"\n#include \"udf_i.h\"\n#include <linux/bitops.h>\n#include <linux/buffer_head.h>\n#include \"udfdecl.h\"\n\nstatic void udf_add_free_space(struct super_block *sb, u16 partition, u32 cnt)\n{\n\tstruct udf_sb_info *sbi = UDF_SB(sb);\n\tstruct logicalVolIntegrityDesc *lvid;\n\n\tif (!sbi->s_lvid_bh)\n\t\treturn;\n\n\tlvid = (struct logicalVolIntegrityDesc *)sbi->s_lvid_bh->b_data;\n\tle32_add_cpu(&lvid->freeSpaceTable[partition], cnt);\n\tudf_updated_lvid(sb);\n}"
        }
      },
      {
        "call_info": {
          "callee": "UDF_I",
          "args": [
            "table"
          ],
          "line": 375
        },
        "resolved": true,
        "details": {
          "function_name": "UDF_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/udf_i.h",
          "lines": "57-60",
          "snippet": "static inline struct udf_inode_info *UDF_I(struct inode *inode)\n{\n\treturn list_entry(inode, struct udf_inode_info, vfs_inode);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline struct udf_inode_info *UDF_I(struct inode *inode)\n{\n\treturn list_entry(inode, struct udf_inode_info, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "udf_debug",
          "args": [
            "\"%d < %d || %d + %d > %d\\n\"",
            "bloc->logicalBlockNum",
            "0",
            "bloc->logicalBlockNum",
            "count",
            "partmap->s_partition_len"
          ],
          "line": 368
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&sbi->s_alloc_mutex"
          ],
          "line": 364
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UDF_SB",
          "args": [
            "sb"
          ],
          "line": 354
        },
        "resolved": true,
        "details": {
          "function_name": "UDF_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/udf_sb.h",
          "lines": "160-163",
          "snippet": "static inline struct udf_sb_info *UDF_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include <linux/bitops.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bitops.h>\n#include <linux/mutex.h>\n\nstatic inline struct udf_sb_info *UDF_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"udf_sb.h\"\n#include \"udf_i.h\"\n#include <linux/bitops.h>\n#include <linux/buffer_head.h>\n#include \"udfdecl.h\"\n\nstatic void udf_table_free_blocks(struct super_block *sb,\n\t\t\t\t  struct inode *table,\n\t\t\t\t  struct kernel_lb_addr *bloc,\n\t\t\t\t  uint32_t offset,\n\t\t\t\t  uint32_t count)\n{\n\tstruct udf_sb_info *sbi = UDF_SB(sb);\n\tstruct udf_part_map *partmap;\n\tuint32_t start, end;\n\tuint32_t elen;\n\tstruct kernel_lb_addr eloc;\n\tstruct extent_position oepos, epos;\n\tint8_t etype;\n\tint i;\n\tstruct udf_inode_info *iinfo;\n\n\tmutex_lock(&sbi->s_alloc_mutex);\n\tpartmap = &sbi->s_partmaps[bloc->partitionReferenceNum];\n\tif (bloc->logicalBlockNum + count < count ||\n\t    (bloc->logicalBlockNum + count) > partmap->s_partition_len) {\n\t\tudf_debug(\"%d < %d || %d + %d > %d\\n\",\n\t\t\t  bloc->logicalBlockNum, 0,\n\t\t\t  bloc->logicalBlockNum, count,\n\t\t\t  partmap->s_partition_len);\n\t\tgoto error_return;\n\t}\n\n\tiinfo = UDF_I(table);\n\tudf_add_free_space(sb, sbi->s_partition, count);\n\n\tstart = bloc->logicalBlockNum + offset;\n\tend = bloc->logicalBlockNum + offset + count - 1;\n\n\tepos.offset = oepos.offset = sizeof(struct unallocSpaceEntry);\n\telen = 0;\n\tepos.block = oepos.block = iinfo->i_location;\n\tepos.bh = oepos.bh = NULL;\n\n\twhile (count &&\n\t       (etype = udf_next_aext(table, &epos, &eloc, &elen, 1)) != -1) {\n\t\tif (((eloc.logicalBlockNum +\n\t\t\t(elen >> sb->s_blocksize_bits)) == start)) {\n\t\t\tif ((0x3FFFFFFF - elen) <\n\t\t\t\t\t(count << sb->s_blocksize_bits)) {\n\t\t\t\tuint32_t tmp = ((0x3FFFFFFF - elen) >>\n\t\t\t\t\t\t\tsb->s_blocksize_bits);\n\t\t\t\tcount -= tmp;\n\t\t\t\tstart += tmp;\n\t\t\t\telen = (etype << 30) |\n\t\t\t\t\t(0x40000000 - sb->s_blocksize);\n\t\t\t} else {\n\t\t\t\telen = (etype << 30) |\n\t\t\t\t\t(elen +\n\t\t\t\t\t(count << sb->s_blocksize_bits));\n\t\t\t\tstart += count;\n\t\t\t\tcount = 0;\n\t\t\t}\n\t\t\tudf_write_aext(table, &oepos, &eloc, elen, 1);\n\t\t} else if (eloc.logicalBlockNum == (end + 1)) {\n\t\t\tif ((0x3FFFFFFF - elen) <\n\t\t\t\t\t(count << sb->s_blocksize_bits)) {\n\t\t\t\tuint32_t tmp = ((0x3FFFFFFF - elen) >>\n\t\t\t\t\t\tsb->s_blocksize_bits);\n\t\t\t\tcount -= tmp;\n\t\t\t\tend -= tmp;\n\t\t\t\teloc.logicalBlockNum -= tmp;\n\t\t\t\telen = (etype << 30) |\n\t\t\t\t\t(0x40000000 - sb->s_blocksize);\n\t\t\t} else {\n\t\t\t\teloc.logicalBlockNum = start;\n\t\t\t\telen = (etype << 30) |\n\t\t\t\t\t(elen +\n\t\t\t\t\t(count << sb->s_blocksize_bits));\n\t\t\t\tend -= count;\n\t\t\t\tcount = 0;\n\t\t\t}\n\t\t\tudf_write_aext(table, &oepos, &eloc, elen, 1);\n\t\t}\n\n\t\tif (epos.bh != oepos.bh) {\n\t\t\ti = -1;\n\t\t\toepos.block = epos.block;\n\t\t\tbrelse(oepos.bh);\n\t\t\tget_bh(epos.bh);\n\t\t\toepos.bh = epos.bh;\n\t\t\toepos.offset = 0;\n\t\t} else {\n\t\t\toepos.offset = epos.offset;\n\t\t}\n\t}\n\n\tif (count) {\n\t\t/*\n\t\t * NOTE: we CANNOT use udf_add_aext here, as it can try to\n\t\t * allocate a new block, and since we hold the super block\n\t\t * lock already very bad things would happen :)\n\t\t *\n\t\t * We copy the behavior of udf_add_aext, but instead of\n\t\t * trying to allocate a new block close to the existing one,\n\t\t * we just steal a block from the extent we are trying to add.\n\t\t *\n\t\t * It would be nice if the blocks were close together, but it\n\t\t * isn't required.\n\t\t */\n\n\t\tint adsize;\n\t\tstruct short_ad *sad = NULL;\n\t\tstruct long_ad *lad = NULL;\n\t\tstruct allocExtDesc *aed;\n\n\t\teloc.logicalBlockNum = start;\n\t\telen = EXT_RECORDED_ALLOCATED |\n\t\t\t(count << sb->s_blocksize_bits);\n\n\t\tif (iinfo->i_alloc_type == ICBTAG_FLAG_AD_SHORT)\n\t\t\tadsize = sizeof(struct short_ad);\n\t\telse if (iinfo->i_alloc_type == ICBTAG_FLAG_AD_LONG)\n\t\t\tadsize = sizeof(struct long_ad);\n\t\telse {\n\t\t\tbrelse(oepos.bh);\n\t\t\tbrelse(epos.bh);\n\t\t\tgoto error_return;\n\t\t}\n\n\t\tif (epos.offset + (2 * adsize) > sb->s_blocksize) {\n\t\t\tunsigned char *sptr, *dptr;\n\t\t\tint loffset;\n\n\t\t\tbrelse(oepos.bh);\n\t\t\toepos = epos;\n\n\t\t\t/* Steal a block from the extent being free'd */\n\t\t\tepos.block.logicalBlockNum = eloc.logicalBlockNum;\n\t\t\teloc.logicalBlockNum++;\n\t\t\telen -= sb->s_blocksize;\n\n\t\t\tepos.bh = udf_tread(sb,\n\t\t\t\t\tudf_get_lb_pblock(sb, &epos.block, 0));\n\t\t\tif (!epos.bh) {\n\t\t\t\tbrelse(oepos.bh);\n\t\t\t\tgoto error_return;\n\t\t\t}\n\t\t\taed = (struct allocExtDesc *)(epos.bh->b_data);\n\t\t\taed->previousAllocExtLocation =\n\t\t\t\tcpu_to_le32(oepos.block.logicalBlockNum);\n\t\t\tif (epos.offset + adsize > sb->s_blocksize) {\n\t\t\t\tloffset = epos.offset;\n\t\t\t\taed->lengthAllocDescs = cpu_to_le32(adsize);\n\t\t\t\tsptr = iinfo->i_ext.i_data + epos.offset\n\t\t\t\t\t\t\t\t- adsize;\n\t\t\t\tdptr = epos.bh->b_data +\n\t\t\t\t\tsizeof(struct allocExtDesc);\n\t\t\t\tmemcpy(dptr, sptr, adsize);\n\t\t\t\tepos.offset = sizeof(struct allocExtDesc) +\n\t\t\t\t\t\tadsize;\n\t\t\t} else {\n\t\t\t\tloffset = epos.offset + adsize;\n\t\t\t\taed->lengthAllocDescs = cpu_to_le32(0);\n\t\t\t\tif (oepos.bh) {\n\t\t\t\t\tsptr = oepos.bh->b_data + epos.offset;\n\t\t\t\t\taed = (struct allocExtDesc *)\n\t\t\t\t\t\toepos.bh->b_data;\n\t\t\t\t\tle32_add_cpu(&aed->lengthAllocDescs,\n\t\t\t\t\t\t\tadsize);\n\t\t\t\t} else {\n\t\t\t\t\tsptr = iinfo->i_ext.i_data +\n\t\t\t\t\t\t\t\tepos.offset;\n\t\t\t\t\tiinfo->i_lenAlloc += adsize;\n\t\t\t\t\tmark_inode_dirty(table);\n\t\t\t\t}\n\t\t\t\tepos.offset = sizeof(struct allocExtDesc);\n\t\t\t}\n\t\t\tif (sbi->s_udfrev >= 0x0200)\n\t\t\t\tudf_new_tag(epos.bh->b_data, TAG_IDENT_AED,\n\t\t\t\t\t    3, 1, epos.block.logicalBlockNum,\n\t\t\t\t\t    sizeof(struct tag));\n\t\t\telse\n\t\t\t\tudf_new_tag(epos.bh->b_data, TAG_IDENT_AED,\n\t\t\t\t\t    2, 1, epos.block.logicalBlockNum,\n\t\t\t\t\t    sizeof(struct tag));\n\n\t\t\tswitch (iinfo->i_alloc_type) {\n\t\t\tcase ICBTAG_FLAG_AD_SHORT:\n\t\t\t\tsad = (struct short_ad *)sptr;\n\t\t\t\tsad->extLength = cpu_to_le32(\n\t\t\t\t\tEXT_NEXT_EXTENT_ALLOCDECS |\n\t\t\t\t\tsb->s_blocksize);\n\t\t\t\tsad->extPosition =\n\t\t\t\t\tcpu_to_le32(epos.block.logicalBlockNum);\n\t\t\t\tbreak;\n\t\t\tcase ICBTAG_FLAG_AD_LONG:\n\t\t\t\tlad = (struct long_ad *)sptr;\n\t\t\t\tlad->extLength = cpu_to_le32(\n\t\t\t\t\tEXT_NEXT_EXTENT_ALLOCDECS |\n\t\t\t\t\tsb->s_blocksize);\n\t\t\t\tlad->extLocation =\n\t\t\t\t\tcpu_to_lelb(epos.block);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (oepos.bh) {\n\t\t\t\tudf_update_tag(oepos.bh->b_data, loffset);\n\t\t\t\tmark_buffer_dirty(oepos.bh);\n\t\t\t} else {\n\t\t\t\tmark_inode_dirty(table);\n\t\t\t}\n\t\t}\n\n\t\t/* It's possible that stealing the block emptied the extent */\n\t\tif (elen) {\n\t\t\tudf_write_aext(table, &epos, &eloc, elen, 1);\n\n\t\t\tif (!epos.bh) {\n\t\t\t\tiinfo->i_lenAlloc += adsize;\n\t\t\t\tmark_inode_dirty(table);\n\t\t\t} else {\n\t\t\t\taed = (struct allocExtDesc *)epos.bh->b_data;\n\t\t\t\tle32_add_cpu(&aed->lengthAllocDescs, adsize);\n\t\t\t\tudf_update_tag(epos.bh->b_data, epos.offset);\n\t\t\t\tmark_buffer_dirty(epos.bh);\n\t\t\t}\n\t\t}\n\t}\n\n\tbrelse(epos.bh);\n\tbrelse(oepos.bh);\n\nerror_return:\n\tmutex_unlock(&sbi->s_alloc_mutex);\n\treturn;\n}"
  },
  {
    "function_name": "udf_bitmap_new_block",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/balloc.c",
    "lines": "223-346",
    "snippet": "static int udf_bitmap_new_block(struct super_block *sb,\n\t\t\t\tstruct udf_bitmap *bitmap, uint16_t partition,\n\t\t\t\tuint32_t goal, int *err)\n{\n\tstruct udf_sb_info *sbi = UDF_SB(sb);\n\tint newbit, bit = 0, block, block_group, group_start;\n\tint end_goal, nr_groups, bitmap_nr, i;\n\tstruct buffer_head *bh = NULL;\n\tchar *ptr;\n\tint newblock = 0;\n\n\t*err = -ENOSPC;\n\tmutex_lock(&sbi->s_alloc_mutex);\n\nrepeat:\n\tif (goal >= sbi->s_partmaps[partition].s_partition_len)\n\t\tgoal = 0;\n\n\tnr_groups = bitmap->s_nr_groups;\n\tblock = goal + (sizeof(struct spaceBitmapDesc) << 3);\n\tblock_group = block >> (sb->s_blocksize_bits + 3);\n\tgroup_start = block_group ? 0 : sizeof(struct spaceBitmapDesc);\n\n\tbitmap_nr = load_block_bitmap(sb, bitmap, block_group);\n\tif (bitmap_nr < 0)\n\t\tgoto error_return;\n\tbh = bitmap->s_block_bitmap[bitmap_nr];\n\tptr = memscan((char *)bh->b_data + group_start, 0xFF,\n\t\t      sb->s_blocksize - group_start);\n\n\tif ((ptr - ((char *)bh->b_data)) < sb->s_blocksize) {\n\t\tbit = block % (sb->s_blocksize << 3);\n\t\tif (udf_test_bit(bit, bh->b_data))\n\t\t\tgoto got_block;\n\n\t\tend_goal = (bit + 63) & ~63;\n\t\tbit = udf_find_next_one_bit(bh->b_data, end_goal, bit);\n\t\tif (bit < end_goal)\n\t\t\tgoto got_block;\n\n\t\tptr = memscan((char *)bh->b_data + (bit >> 3), 0xFF,\n\t\t\t      sb->s_blocksize - ((bit + 7) >> 3));\n\t\tnewbit = (ptr - ((char *)bh->b_data)) << 3;\n\t\tif (newbit < sb->s_blocksize << 3) {\n\t\t\tbit = newbit;\n\t\t\tgoto search_back;\n\t\t}\n\n\t\tnewbit = udf_find_next_one_bit(bh->b_data,\n\t\t\t\t\t       sb->s_blocksize << 3, bit);\n\t\tif (newbit < sb->s_blocksize << 3) {\n\t\t\tbit = newbit;\n\t\t\tgoto got_block;\n\t\t}\n\t}\n\n\tfor (i = 0; i < (nr_groups * 2); i++) {\n\t\tblock_group++;\n\t\tif (block_group >= nr_groups)\n\t\t\tblock_group = 0;\n\t\tgroup_start = block_group ? 0 : sizeof(struct spaceBitmapDesc);\n\n\t\tbitmap_nr = load_block_bitmap(sb, bitmap, block_group);\n\t\tif (bitmap_nr < 0)\n\t\t\tgoto error_return;\n\t\tbh = bitmap->s_block_bitmap[bitmap_nr];\n\t\tif (i < nr_groups) {\n\t\t\tptr = memscan((char *)bh->b_data + group_start, 0xFF,\n\t\t\t\t      sb->s_blocksize - group_start);\n\t\t\tif ((ptr - ((char *)bh->b_data)) < sb->s_blocksize) {\n\t\t\t\tbit = (ptr - ((char *)bh->b_data)) << 3;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} else {\n\t\t\tbit = udf_find_next_one_bit(bh->b_data,\n\t\t\t\t\t\t    sb->s_blocksize << 3,\n\t\t\t\t\t\t    group_start << 3);\n\t\t\tif (bit < sb->s_blocksize << 3)\n\t\t\t\tbreak;\n\t\t}\n\t}\n\tif (i >= (nr_groups * 2)) {\n\t\tmutex_unlock(&sbi->s_alloc_mutex);\n\t\treturn newblock;\n\t}\n\tif (bit < sb->s_blocksize << 3)\n\t\tgoto search_back;\n\telse\n\t\tbit = udf_find_next_one_bit(bh->b_data, sb->s_blocksize << 3,\n\t\t\t\t\t    group_start << 3);\n\tif (bit >= sb->s_blocksize << 3) {\n\t\tmutex_unlock(&sbi->s_alloc_mutex);\n\t\treturn 0;\n\t}\n\nsearch_back:\n\ti = 0;\n\twhile (i < 7 && bit > (group_start << 3) &&\n\t       udf_test_bit(bit - 1, bh->b_data)) {\n\t\t++i;\n\t\t--bit;\n\t}\n\ngot_block:\n\tnewblock = bit + (block_group << (sb->s_blocksize_bits + 3)) -\n\t\t(sizeof(struct spaceBitmapDesc) << 3);\n\n\tif (!udf_clear_bit(bit, bh->b_data)) {\n\t\tudf_debug(\"bit already cleared for block %d\\n\", bit);\n\t\tgoto repeat;\n\t}\n\n\tmark_buffer_dirty(bh);\n\n\tudf_add_free_space(sb, partition, -1);\n\tmutex_unlock(&sbi->s_alloc_mutex);\n\t*err = 0;\n\treturn newblock;\n\nerror_return:\n\t*err = -EIO;\n\tmutex_unlock(&sbi->s_alloc_mutex);\n\treturn 0;\n}",
    "includes": [
      "#include \"udf_sb.h\"",
      "#include \"udf_i.h\"",
      "#include <linux/bitops.h>",
      "#include <linux/buffer_head.h>",
      "#include \"udfdecl.h\""
    ],
    "macros_used": [
      "#define udf_find_next_one_bit\tfind_next_bit_le",
      "#define udf_test_bit\ttest_bit_le",
      "#define udf_clear_bit\t__test_and_clear_bit_le"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&sbi->s_alloc_mutex"
          ],
          "line": 344
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&sbi->s_alloc_mutex"
          ],
          "line": 338
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "udf_add_free_space",
          "args": [
            "sb",
            "partition",
            "-1"
          ],
          "line": 337
        },
        "resolved": true,
        "details": {
          "function_name": "udf_add_free_space",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/balloc.c",
          "lines": "94-105",
          "snippet": "static void udf_add_free_space(struct super_block *sb, u16 partition, u32 cnt)\n{\n\tstruct udf_sb_info *sbi = UDF_SB(sb);\n\tstruct logicalVolIntegrityDesc *lvid;\n\n\tif (!sbi->s_lvid_bh)\n\t\treturn;\n\n\tlvid = (struct logicalVolIntegrityDesc *)sbi->s_lvid_bh->b_data;\n\tle32_add_cpu(&lvid->freeSpaceTable[partition], cnt);\n\tudf_updated_lvid(sb);\n}",
          "includes": [
            "#include \"udf_sb.h\"",
            "#include \"udf_i.h\"",
            "#include <linux/bitops.h>",
            "#include <linux/buffer_head.h>",
            "#include \"udfdecl.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"udf_sb.h\"\n#include \"udf_i.h\"\n#include <linux/bitops.h>\n#include <linux/buffer_head.h>\n#include \"udfdecl.h\"\n\nstatic void udf_add_free_space(struct super_block *sb, u16 partition, u32 cnt)\n{\n\tstruct udf_sb_info *sbi = UDF_SB(sb);\n\tstruct logicalVolIntegrityDesc *lvid;\n\n\tif (!sbi->s_lvid_bh)\n\t\treturn;\n\n\tlvid = (struct logicalVolIntegrityDesc *)sbi->s_lvid_bh->b_data;\n\tle32_add_cpu(&lvid->freeSpaceTable[partition], cnt);\n\tudf_updated_lvid(sb);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mark_buffer_dirty",
          "args": [
            "bh"
          ],
          "line": 335
        },
        "resolved": true,
        "details": {
          "function_name": "mark_buffer_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1141-1167",
          "snippet": "void mark_buffer_dirty(struct buffer_head *bh)\n{\n\tWARN_ON_ONCE(!buffer_uptodate(bh));\n\n\ttrace_block_dirty_buffer(bh);\n\n\t/*\n\t * Very *carefully* optimize the it-is-already-dirty case.\n\t *\n\t * Don't let the final \"is it dirty\" escape to before we\n\t * perhaps modified the buffer.\n\t */\n\tif (buffer_dirty(bh)) {\n\t\tsmp_mb();\n\t\tif (buffer_dirty(bh))\n\t\t\treturn;\n\t}\n\n\tif (!test_set_buffer_dirty(bh)) {\n\t\tstruct page *page = bh->b_page;\n\t\tif (!TestSetPageDirty(page)) {\n\t\t\tstruct address_space *mapping = page_mapping(page);\n\t\t\tif (mapping)\n\t\t\t\t__set_page_dirty(page, mapping, 0);\n\t\t}\n\t}\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid mark_buffer_dirty(struct buffer_head *bh)\n{\n\tWARN_ON_ONCE(!buffer_uptodate(bh));\n\n\ttrace_block_dirty_buffer(bh);\n\n\t/*\n\t * Very *carefully* optimize the it-is-already-dirty case.\n\t *\n\t * Don't let the final \"is it dirty\" escape to before we\n\t * perhaps modified the buffer.\n\t */\n\tif (buffer_dirty(bh)) {\n\t\tsmp_mb();\n\t\tif (buffer_dirty(bh))\n\t\t\treturn;\n\t}\n\n\tif (!test_set_buffer_dirty(bh)) {\n\t\tstruct page *page = bh->b_page;\n\t\tif (!TestSetPageDirty(page)) {\n\t\t\tstruct address_space *mapping = page_mapping(page);\n\t\t\tif (mapping)\n\t\t\t\t__set_page_dirty(page, mapping, 0);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "udf_debug",
          "args": [
            "\"bit already cleared for block %d\\n\"",
            "bit"
          ],
          "line": 331
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "udf_clear_bit",
          "args": [
            "bit",
            "bh->b_data"
          ],
          "line": 330
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "udf_test_bit",
          "args": [
            "bit - 1",
            "bh->b_data"
          ],
          "line": 321
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&sbi->s_alloc_mutex"
          ],
          "line": 314
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "udf_find_next_one_bit",
          "args": [
            "bh->b_data",
            "sb->s_blocksize << 3",
            "group_start << 3"
          ],
          "line": 311
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&sbi->s_alloc_mutex"
          ],
          "line": 305
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "udf_find_next_one_bit",
          "args": [
            "bh->b_data",
            "sb->s_blocksize << 3",
            "group_start << 3"
          ],
          "line": 297
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memscan",
          "args": [
            "(char *)bh->b_data + group_start",
            "0xFF",
            "sb->s_blocksize - group_start"
          ],
          "line": 290
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "load_block_bitmap",
          "args": [
            "sb",
            "bitmap",
            "block_group"
          ],
          "line": 285
        },
        "resolved": true,
        "details": {
          "function_name": "load_block_bitmap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/balloc.c",
          "lines": "77-92",
          "snippet": "static inline int load_block_bitmap(struct super_block *sb,\n\t\t\t\t    struct udf_bitmap *bitmap,\n\t\t\t\t    unsigned int block_group)\n{\n\tint slot;\n\n\tslot = __load_block_bitmap(sb, bitmap, block_group);\n\n\tif (slot < 0)\n\t\treturn slot;\n\n\tif (!bitmap->s_block_bitmap[slot])\n\t\treturn -EIO;\n\n\treturn slot;\n}",
          "includes": [
            "#include \"udf_sb.h\"",
            "#include \"udf_i.h\"",
            "#include <linux/bitops.h>",
            "#include <linux/buffer_head.h>",
            "#include \"udfdecl.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"udf_sb.h\"\n#include \"udf_i.h\"\n#include <linux/bitops.h>\n#include <linux/buffer_head.h>\n#include \"udfdecl.h\"\n\nstatic inline int load_block_bitmap(struct super_block *sb,\n\t\t\t\t    struct udf_bitmap *bitmap,\n\t\t\t\t    unsigned int block_group)\n{\n\tint slot;\n\n\tslot = __load_block_bitmap(sb, bitmap, block_group);\n\n\tif (slot < 0)\n\t\treturn slot;\n\n\tif (!bitmap->s_block_bitmap[slot])\n\t\treturn -EIO;\n\n\treturn slot;\n}"
        }
      },
      {
        "call_info": {
          "callee": "udf_find_next_one_bit",
          "args": [
            "bh->b_data",
            "sb->s_blocksize << 3",
            "bit"
          ],
          "line": 271
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memscan",
          "args": [
            "(char *)bh->b_data + (bit >> 3)",
            "0xFF",
            "sb->s_blocksize - ((bit + 7) >> 3)"
          ],
          "line": 263
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "udf_find_next_one_bit",
          "args": [
            "bh->b_data",
            "end_goal",
            "bit"
          ],
          "line": 259
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "udf_test_bit",
          "args": [
            "bit",
            "bh->b_data"
          ],
          "line": 255
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memscan",
          "args": [
            "(char *)bh->b_data + group_start",
            "0xFF",
            "sb->s_blocksize - group_start"
          ],
          "line": 250
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&sbi->s_alloc_mutex"
          ],
          "line": 235
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UDF_SB",
          "args": [
            "sb"
          ],
          "line": 227
        },
        "resolved": true,
        "details": {
          "function_name": "UDF_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/udf_sb.h",
          "lines": "160-163",
          "snippet": "static inline struct udf_sb_info *UDF_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include <linux/bitops.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bitops.h>\n#include <linux/mutex.h>\n\nstatic inline struct udf_sb_info *UDF_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"udf_sb.h\"\n#include \"udf_i.h\"\n#include <linux/bitops.h>\n#include <linux/buffer_head.h>\n#include \"udfdecl.h\"\n\n#define udf_find_next_one_bit\tfind_next_bit_le\n#define udf_test_bit\ttest_bit_le\n#define udf_clear_bit\t__test_and_clear_bit_le\n\nstatic int udf_bitmap_new_block(struct super_block *sb,\n\t\t\t\tstruct udf_bitmap *bitmap, uint16_t partition,\n\t\t\t\tuint32_t goal, int *err)\n{\n\tstruct udf_sb_info *sbi = UDF_SB(sb);\n\tint newbit, bit = 0, block, block_group, group_start;\n\tint end_goal, nr_groups, bitmap_nr, i;\n\tstruct buffer_head *bh = NULL;\n\tchar *ptr;\n\tint newblock = 0;\n\n\t*err = -ENOSPC;\n\tmutex_lock(&sbi->s_alloc_mutex);\n\nrepeat:\n\tif (goal >= sbi->s_partmaps[partition].s_partition_len)\n\t\tgoal = 0;\n\n\tnr_groups = bitmap->s_nr_groups;\n\tblock = goal + (sizeof(struct spaceBitmapDesc) << 3);\n\tblock_group = block >> (sb->s_blocksize_bits + 3);\n\tgroup_start = block_group ? 0 : sizeof(struct spaceBitmapDesc);\n\n\tbitmap_nr = load_block_bitmap(sb, bitmap, block_group);\n\tif (bitmap_nr < 0)\n\t\tgoto error_return;\n\tbh = bitmap->s_block_bitmap[bitmap_nr];\n\tptr = memscan((char *)bh->b_data + group_start, 0xFF,\n\t\t      sb->s_blocksize - group_start);\n\n\tif ((ptr - ((char *)bh->b_data)) < sb->s_blocksize) {\n\t\tbit = block % (sb->s_blocksize << 3);\n\t\tif (udf_test_bit(bit, bh->b_data))\n\t\t\tgoto got_block;\n\n\t\tend_goal = (bit + 63) & ~63;\n\t\tbit = udf_find_next_one_bit(bh->b_data, end_goal, bit);\n\t\tif (bit < end_goal)\n\t\t\tgoto got_block;\n\n\t\tptr = memscan((char *)bh->b_data + (bit >> 3), 0xFF,\n\t\t\t      sb->s_blocksize - ((bit + 7) >> 3));\n\t\tnewbit = (ptr - ((char *)bh->b_data)) << 3;\n\t\tif (newbit < sb->s_blocksize << 3) {\n\t\t\tbit = newbit;\n\t\t\tgoto search_back;\n\t\t}\n\n\t\tnewbit = udf_find_next_one_bit(bh->b_data,\n\t\t\t\t\t       sb->s_blocksize << 3, bit);\n\t\tif (newbit < sb->s_blocksize << 3) {\n\t\t\tbit = newbit;\n\t\t\tgoto got_block;\n\t\t}\n\t}\n\n\tfor (i = 0; i < (nr_groups * 2); i++) {\n\t\tblock_group++;\n\t\tif (block_group >= nr_groups)\n\t\t\tblock_group = 0;\n\t\tgroup_start = block_group ? 0 : sizeof(struct spaceBitmapDesc);\n\n\t\tbitmap_nr = load_block_bitmap(sb, bitmap, block_group);\n\t\tif (bitmap_nr < 0)\n\t\t\tgoto error_return;\n\t\tbh = bitmap->s_block_bitmap[bitmap_nr];\n\t\tif (i < nr_groups) {\n\t\t\tptr = memscan((char *)bh->b_data + group_start, 0xFF,\n\t\t\t\t      sb->s_blocksize - group_start);\n\t\t\tif ((ptr - ((char *)bh->b_data)) < sb->s_blocksize) {\n\t\t\t\tbit = (ptr - ((char *)bh->b_data)) << 3;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} else {\n\t\t\tbit = udf_find_next_one_bit(bh->b_data,\n\t\t\t\t\t\t    sb->s_blocksize << 3,\n\t\t\t\t\t\t    group_start << 3);\n\t\t\tif (bit < sb->s_blocksize << 3)\n\t\t\t\tbreak;\n\t\t}\n\t}\n\tif (i >= (nr_groups * 2)) {\n\t\tmutex_unlock(&sbi->s_alloc_mutex);\n\t\treturn newblock;\n\t}\n\tif (bit < sb->s_blocksize << 3)\n\t\tgoto search_back;\n\telse\n\t\tbit = udf_find_next_one_bit(bh->b_data, sb->s_blocksize << 3,\n\t\t\t\t\t    group_start << 3);\n\tif (bit >= sb->s_blocksize << 3) {\n\t\tmutex_unlock(&sbi->s_alloc_mutex);\n\t\treturn 0;\n\t}\n\nsearch_back:\n\ti = 0;\n\twhile (i < 7 && bit > (group_start << 3) &&\n\t       udf_test_bit(bit - 1, bh->b_data)) {\n\t\t++i;\n\t\t--bit;\n\t}\n\ngot_block:\n\tnewblock = bit + (block_group << (sb->s_blocksize_bits + 3)) -\n\t\t(sizeof(struct spaceBitmapDesc) << 3);\n\n\tif (!udf_clear_bit(bit, bh->b_data)) {\n\t\tudf_debug(\"bit already cleared for block %d\\n\", bit);\n\t\tgoto repeat;\n\t}\n\n\tmark_buffer_dirty(bh);\n\n\tudf_add_free_space(sb, partition, -1);\n\tmutex_unlock(&sbi->s_alloc_mutex);\n\t*err = 0;\n\treturn newblock;\n\nerror_return:\n\t*err = -EIO;\n\tmutex_unlock(&sbi->s_alloc_mutex);\n\treturn 0;\n}"
  },
  {
    "function_name": "udf_bitmap_prealloc_blocks",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/balloc.c",
    "lines": "173-221",
    "snippet": "static int udf_bitmap_prealloc_blocks(struct super_block *sb,\n\t\t\t\t      struct udf_bitmap *bitmap,\n\t\t\t\t      uint16_t partition, uint32_t first_block,\n\t\t\t\t      uint32_t block_count)\n{\n\tstruct udf_sb_info *sbi = UDF_SB(sb);\n\tint alloc_count = 0;\n\tint bit, block, block_group, group_start;\n\tint nr_groups, bitmap_nr;\n\tstruct buffer_head *bh;\n\t__u32 part_len;\n\n\tmutex_lock(&sbi->s_alloc_mutex);\n\tpart_len = sbi->s_partmaps[partition].s_partition_len;\n\tif (first_block >= part_len)\n\t\tgoto out;\n\n\tif (first_block + block_count > part_len)\n\t\tblock_count = part_len - first_block;\n\n\tdo {\n\t\tnr_groups = udf_compute_nr_groups(sb, partition);\n\t\tblock = first_block + (sizeof(struct spaceBitmapDesc) << 3);\n\t\tblock_group = block >> (sb->s_blocksize_bits + 3);\n\t\tgroup_start = block_group ? 0 : sizeof(struct spaceBitmapDesc);\n\n\t\tbitmap_nr = load_block_bitmap(sb, bitmap, block_group);\n\t\tif (bitmap_nr < 0)\n\t\t\tgoto out;\n\t\tbh = bitmap->s_block_bitmap[bitmap_nr];\n\n\t\tbit = block % (sb->s_blocksize << 3);\n\n\t\twhile (bit < (sb->s_blocksize << 3) && block_count > 0) {\n\t\t\tif (!udf_clear_bit(bit, bh->b_data))\n\t\t\t\tgoto out;\n\t\t\tblock_count--;\n\t\t\talloc_count++;\n\t\t\tbit++;\n\t\t\tblock++;\n\t\t}\n\t\tmark_buffer_dirty(bh);\n\t} while (block_count > 0);\n\nout:\n\tudf_add_free_space(sb, partition, -alloc_count);\n\tmutex_unlock(&sbi->s_alloc_mutex);\n\treturn alloc_count;\n}",
    "includes": [
      "#include \"udf_sb.h\"",
      "#include \"udf_i.h\"",
      "#include <linux/bitops.h>",
      "#include <linux/buffer_head.h>",
      "#include \"udfdecl.h\""
    ],
    "macros_used": [
      "#define udf_clear_bit\t__test_and_clear_bit_le"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&sbi->s_alloc_mutex"
          ],
          "line": 219
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "udf_add_free_space",
          "args": [
            "sb",
            "partition",
            "-alloc_count"
          ],
          "line": 218
        },
        "resolved": true,
        "details": {
          "function_name": "udf_add_free_space",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/balloc.c",
          "lines": "94-105",
          "snippet": "static void udf_add_free_space(struct super_block *sb, u16 partition, u32 cnt)\n{\n\tstruct udf_sb_info *sbi = UDF_SB(sb);\n\tstruct logicalVolIntegrityDesc *lvid;\n\n\tif (!sbi->s_lvid_bh)\n\t\treturn;\n\n\tlvid = (struct logicalVolIntegrityDesc *)sbi->s_lvid_bh->b_data;\n\tle32_add_cpu(&lvid->freeSpaceTable[partition], cnt);\n\tudf_updated_lvid(sb);\n}",
          "includes": [
            "#include \"udf_sb.h\"",
            "#include \"udf_i.h\"",
            "#include <linux/bitops.h>",
            "#include <linux/buffer_head.h>",
            "#include \"udfdecl.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"udf_sb.h\"\n#include \"udf_i.h\"\n#include <linux/bitops.h>\n#include <linux/buffer_head.h>\n#include \"udfdecl.h\"\n\nstatic void udf_add_free_space(struct super_block *sb, u16 partition, u32 cnt)\n{\n\tstruct udf_sb_info *sbi = UDF_SB(sb);\n\tstruct logicalVolIntegrityDesc *lvid;\n\n\tif (!sbi->s_lvid_bh)\n\t\treturn;\n\n\tlvid = (struct logicalVolIntegrityDesc *)sbi->s_lvid_bh->b_data;\n\tle32_add_cpu(&lvid->freeSpaceTable[partition], cnt);\n\tudf_updated_lvid(sb);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mark_buffer_dirty",
          "args": [
            "bh"
          ],
          "line": 214
        },
        "resolved": true,
        "details": {
          "function_name": "mark_buffer_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1141-1167",
          "snippet": "void mark_buffer_dirty(struct buffer_head *bh)\n{\n\tWARN_ON_ONCE(!buffer_uptodate(bh));\n\n\ttrace_block_dirty_buffer(bh);\n\n\t/*\n\t * Very *carefully* optimize the it-is-already-dirty case.\n\t *\n\t * Don't let the final \"is it dirty\" escape to before we\n\t * perhaps modified the buffer.\n\t */\n\tif (buffer_dirty(bh)) {\n\t\tsmp_mb();\n\t\tif (buffer_dirty(bh))\n\t\t\treturn;\n\t}\n\n\tif (!test_set_buffer_dirty(bh)) {\n\t\tstruct page *page = bh->b_page;\n\t\tif (!TestSetPageDirty(page)) {\n\t\t\tstruct address_space *mapping = page_mapping(page);\n\t\t\tif (mapping)\n\t\t\t\t__set_page_dirty(page, mapping, 0);\n\t\t}\n\t}\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid mark_buffer_dirty(struct buffer_head *bh)\n{\n\tWARN_ON_ONCE(!buffer_uptodate(bh));\n\n\ttrace_block_dirty_buffer(bh);\n\n\t/*\n\t * Very *carefully* optimize the it-is-already-dirty case.\n\t *\n\t * Don't let the final \"is it dirty\" escape to before we\n\t * perhaps modified the buffer.\n\t */\n\tif (buffer_dirty(bh)) {\n\t\tsmp_mb();\n\t\tif (buffer_dirty(bh))\n\t\t\treturn;\n\t}\n\n\tif (!test_set_buffer_dirty(bh)) {\n\t\tstruct page *page = bh->b_page;\n\t\tif (!TestSetPageDirty(page)) {\n\t\t\tstruct address_space *mapping = page_mapping(page);\n\t\t\tif (mapping)\n\t\t\t\t__set_page_dirty(page, mapping, 0);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "udf_clear_bit",
          "args": [
            "bit",
            "bh->b_data"
          ],
          "line": 207
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "load_block_bitmap",
          "args": [
            "sb",
            "bitmap",
            "block_group"
          ],
          "line": 199
        },
        "resolved": true,
        "details": {
          "function_name": "load_block_bitmap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/balloc.c",
          "lines": "77-92",
          "snippet": "static inline int load_block_bitmap(struct super_block *sb,\n\t\t\t\t    struct udf_bitmap *bitmap,\n\t\t\t\t    unsigned int block_group)\n{\n\tint slot;\n\n\tslot = __load_block_bitmap(sb, bitmap, block_group);\n\n\tif (slot < 0)\n\t\treturn slot;\n\n\tif (!bitmap->s_block_bitmap[slot])\n\t\treturn -EIO;\n\n\treturn slot;\n}",
          "includes": [
            "#include \"udf_sb.h\"",
            "#include \"udf_i.h\"",
            "#include <linux/bitops.h>",
            "#include <linux/buffer_head.h>",
            "#include \"udfdecl.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"udf_sb.h\"\n#include \"udf_i.h\"\n#include <linux/bitops.h>\n#include <linux/buffer_head.h>\n#include \"udfdecl.h\"\n\nstatic inline int load_block_bitmap(struct super_block *sb,\n\t\t\t\t    struct udf_bitmap *bitmap,\n\t\t\t\t    unsigned int block_group)\n{\n\tint slot;\n\n\tslot = __load_block_bitmap(sb, bitmap, block_group);\n\n\tif (slot < 0)\n\t\treturn slot;\n\n\tif (!bitmap->s_block_bitmap[slot])\n\t\treturn -EIO;\n\n\treturn slot;\n}"
        }
      },
      {
        "call_info": {
          "callee": "udf_compute_nr_groups",
          "args": [
            "sb",
            "partition"
          ],
          "line": 194
        },
        "resolved": true,
        "details": {
          "function_name": "udf_compute_nr_groups",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/super.c",
          "lines": "1054-1060",
          "snippet": "int udf_compute_nr_groups(struct super_block *sb, u32 partition)\n{\n\tstruct udf_part_map *map = &UDF_SB(sb)->s_partmaps[partition];\n\treturn DIV_ROUND_UP(map->s_partition_len +\n\t\t\t    (sizeof(struct spaceBitmapDesc) << 3),\n\t\t\t    sb->s_blocksize * 8);\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <linux/init.h>",
            "#include \"udf_i.h\"",
            "#include \"udf_sb.h\"",
            "#include <asm/byteorder.h>",
            "#include <linux/log2.h>",
            "#include <linux/crc-itu-t.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mount.h>",
            "#include <linux/errno.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/vfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/nls.h>",
            "#include <linux/cdrom.h>",
            "#include <linux/stat.h>",
            "#include <linux/parser.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include \"udfdecl.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int udf_fill_super(struct super_block *, void *, int);",
            "static void udf_put_super(struct super_block *);",
            "static int udf_sync_fs(struct super_block *, int);",
            "static int udf_remount_fs(struct super_block *, int *, char *);",
            "static void udf_open_lvid(struct super_block *);",
            "static void udf_close_lvid(struct super_block *);",
            "static unsigned int udf_count_free(struct super_block *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/init.h>\n#include \"udf_i.h\"\n#include \"udf_sb.h\"\n#include <asm/byteorder.h>\n#include <linux/log2.h>\n#include <linux/crc-itu-t.h>\n#include <linux/bitmap.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/errno.h>\n#include <linux/vmalloc.h>\n#include <linux/vfs.h>\n#include <linux/buffer_head.h>\n#include <linux/nls.h>\n#include <linux/cdrom.h>\n#include <linux/stat.h>\n#include <linux/parser.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include \"udfdecl.h\"\n\nstatic int udf_fill_super(struct super_block *, void *, int);\nstatic void udf_put_super(struct super_block *);\nstatic int udf_sync_fs(struct super_block *, int);\nstatic int udf_remount_fs(struct super_block *, int *, char *);\nstatic void udf_open_lvid(struct super_block *);\nstatic void udf_close_lvid(struct super_block *);\nstatic unsigned int udf_count_free(struct super_block *);\n\nint udf_compute_nr_groups(struct super_block *sb, u32 partition)\n{\n\tstruct udf_part_map *map = &UDF_SB(sb)->s_partmaps[partition];\n\treturn DIV_ROUND_UP(map->s_partition_len +\n\t\t\t    (sizeof(struct spaceBitmapDesc) << 3),\n\t\t\t    sb->s_blocksize * 8);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&sbi->s_alloc_mutex"
          ],
          "line": 185
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UDF_SB",
          "args": [
            "sb"
          ],
          "line": 178
        },
        "resolved": true,
        "details": {
          "function_name": "UDF_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/udf_sb.h",
          "lines": "160-163",
          "snippet": "static inline struct udf_sb_info *UDF_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include <linux/bitops.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bitops.h>\n#include <linux/mutex.h>\n\nstatic inline struct udf_sb_info *UDF_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"udf_sb.h\"\n#include \"udf_i.h\"\n#include <linux/bitops.h>\n#include <linux/buffer_head.h>\n#include \"udfdecl.h\"\n\n#define udf_clear_bit\t__test_and_clear_bit_le\n\nstatic int udf_bitmap_prealloc_blocks(struct super_block *sb,\n\t\t\t\t      struct udf_bitmap *bitmap,\n\t\t\t\t      uint16_t partition, uint32_t first_block,\n\t\t\t\t      uint32_t block_count)\n{\n\tstruct udf_sb_info *sbi = UDF_SB(sb);\n\tint alloc_count = 0;\n\tint bit, block, block_group, group_start;\n\tint nr_groups, bitmap_nr;\n\tstruct buffer_head *bh;\n\t__u32 part_len;\n\n\tmutex_lock(&sbi->s_alloc_mutex);\n\tpart_len = sbi->s_partmaps[partition].s_partition_len;\n\tif (first_block >= part_len)\n\t\tgoto out;\n\n\tif (first_block + block_count > part_len)\n\t\tblock_count = part_len - first_block;\n\n\tdo {\n\t\tnr_groups = udf_compute_nr_groups(sb, partition);\n\t\tblock = first_block + (sizeof(struct spaceBitmapDesc) << 3);\n\t\tblock_group = block >> (sb->s_blocksize_bits + 3);\n\t\tgroup_start = block_group ? 0 : sizeof(struct spaceBitmapDesc);\n\n\t\tbitmap_nr = load_block_bitmap(sb, bitmap, block_group);\n\t\tif (bitmap_nr < 0)\n\t\t\tgoto out;\n\t\tbh = bitmap->s_block_bitmap[bitmap_nr];\n\n\t\tbit = block % (sb->s_blocksize << 3);\n\n\t\twhile (bit < (sb->s_blocksize << 3) && block_count > 0) {\n\t\t\tif (!udf_clear_bit(bit, bh->b_data))\n\t\t\t\tgoto out;\n\t\t\tblock_count--;\n\t\t\talloc_count++;\n\t\t\tbit++;\n\t\t\tblock++;\n\t\t}\n\t\tmark_buffer_dirty(bh);\n\t} while (block_count > 0);\n\nout:\n\tudf_add_free_space(sb, partition, -alloc_count);\n\tmutex_unlock(&sbi->s_alloc_mutex);\n\treturn alloc_count;\n}"
  },
  {
    "function_name": "udf_bitmap_free_blocks",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/balloc.c",
    "lines": "107-171",
    "snippet": "static void udf_bitmap_free_blocks(struct super_block *sb,\n\t\t\t\t   struct udf_bitmap *bitmap,\n\t\t\t\t   struct kernel_lb_addr *bloc,\n\t\t\t\t   uint32_t offset,\n\t\t\t\t   uint32_t count)\n{\n\tstruct udf_sb_info *sbi = UDF_SB(sb);\n\tstruct buffer_head *bh = NULL;\n\tstruct udf_part_map *partmap;\n\tunsigned long block;\n\tunsigned long block_group;\n\tunsigned long bit;\n\tunsigned long i;\n\tint bitmap_nr;\n\tunsigned long overflow;\n\n\tmutex_lock(&sbi->s_alloc_mutex);\n\tpartmap = &sbi->s_partmaps[bloc->partitionReferenceNum];\n\tif (bloc->logicalBlockNum + count < count ||\n\t    (bloc->logicalBlockNum + count) > partmap->s_partition_len) {\n\t\tudf_debug(\"%d < %d || %d + %d > %d\\n\",\n\t\t\t  bloc->logicalBlockNum, 0,\n\t\t\t  bloc->logicalBlockNum, count,\n\t\t\t  partmap->s_partition_len);\n\t\tgoto error_return;\n\t}\n\n\tblock = bloc->logicalBlockNum + offset +\n\t\t(sizeof(struct spaceBitmapDesc) << 3);\n\n\tdo {\n\t\toverflow = 0;\n\t\tblock_group = block >> (sb->s_blocksize_bits + 3);\n\t\tbit = block % (sb->s_blocksize << 3);\n\n\t\t/*\n\t\t* Check to see if we are freeing blocks across a group boundary.\n\t\t*/\n\t\tif (bit + count > (sb->s_blocksize << 3)) {\n\t\t\toverflow = bit + count - (sb->s_blocksize << 3);\n\t\t\tcount -= overflow;\n\t\t}\n\t\tbitmap_nr = load_block_bitmap(sb, bitmap, block_group);\n\t\tif (bitmap_nr < 0)\n\t\t\tgoto error_return;\n\n\t\tbh = bitmap->s_block_bitmap[bitmap_nr];\n\t\tfor (i = 0; i < count; i++) {\n\t\t\tif (udf_set_bit(bit + i, bh->b_data)) {\n\t\t\t\tudf_debug(\"bit %ld already set\\n\", bit + i);\n\t\t\t\tudf_debug(\"byte=%2x\\n\",\n\t\t\t\t\t  ((char *)bh->b_data)[(bit + i) >> 3]);\n\t\t\t}\n\t\t}\n\t\tudf_add_free_space(sb, sbi->s_partition, count);\n\t\tmark_buffer_dirty(bh);\n\t\tif (overflow) {\n\t\t\tblock += count;\n\t\t\tcount = overflow;\n\t\t}\n\t} while (overflow);\n\nerror_return:\n\tmutex_unlock(&sbi->s_alloc_mutex);\n}",
    "includes": [
      "#include \"udf_sb.h\"",
      "#include \"udf_i.h\"",
      "#include <linux/bitops.h>",
      "#include <linux/buffer_head.h>",
      "#include \"udfdecl.h\""
    ],
    "macros_used": [
      "#define udf_set_bit\t__test_and_set_bit_le"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&sbi->s_alloc_mutex"
          ],
          "line": 170
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mark_buffer_dirty",
          "args": [
            "bh"
          ],
          "line": 162
        },
        "resolved": true,
        "details": {
          "function_name": "mark_buffer_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1141-1167",
          "snippet": "void mark_buffer_dirty(struct buffer_head *bh)\n{\n\tWARN_ON_ONCE(!buffer_uptodate(bh));\n\n\ttrace_block_dirty_buffer(bh);\n\n\t/*\n\t * Very *carefully* optimize the it-is-already-dirty case.\n\t *\n\t * Don't let the final \"is it dirty\" escape to before we\n\t * perhaps modified the buffer.\n\t */\n\tif (buffer_dirty(bh)) {\n\t\tsmp_mb();\n\t\tif (buffer_dirty(bh))\n\t\t\treturn;\n\t}\n\n\tif (!test_set_buffer_dirty(bh)) {\n\t\tstruct page *page = bh->b_page;\n\t\tif (!TestSetPageDirty(page)) {\n\t\t\tstruct address_space *mapping = page_mapping(page);\n\t\t\tif (mapping)\n\t\t\t\t__set_page_dirty(page, mapping, 0);\n\t\t}\n\t}\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid mark_buffer_dirty(struct buffer_head *bh)\n{\n\tWARN_ON_ONCE(!buffer_uptodate(bh));\n\n\ttrace_block_dirty_buffer(bh);\n\n\t/*\n\t * Very *carefully* optimize the it-is-already-dirty case.\n\t *\n\t * Don't let the final \"is it dirty\" escape to before we\n\t * perhaps modified the buffer.\n\t */\n\tif (buffer_dirty(bh)) {\n\t\tsmp_mb();\n\t\tif (buffer_dirty(bh))\n\t\t\treturn;\n\t}\n\n\tif (!test_set_buffer_dirty(bh)) {\n\t\tstruct page *page = bh->b_page;\n\t\tif (!TestSetPageDirty(page)) {\n\t\t\tstruct address_space *mapping = page_mapping(page);\n\t\t\tif (mapping)\n\t\t\t\t__set_page_dirty(page, mapping, 0);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "udf_add_free_space",
          "args": [
            "sb",
            "sbi->s_partition",
            "count"
          ],
          "line": 161
        },
        "resolved": true,
        "details": {
          "function_name": "udf_add_free_space",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/balloc.c",
          "lines": "94-105",
          "snippet": "static void udf_add_free_space(struct super_block *sb, u16 partition, u32 cnt)\n{\n\tstruct udf_sb_info *sbi = UDF_SB(sb);\n\tstruct logicalVolIntegrityDesc *lvid;\n\n\tif (!sbi->s_lvid_bh)\n\t\treturn;\n\n\tlvid = (struct logicalVolIntegrityDesc *)sbi->s_lvid_bh->b_data;\n\tle32_add_cpu(&lvid->freeSpaceTable[partition], cnt);\n\tudf_updated_lvid(sb);\n}",
          "includes": [
            "#include \"udf_sb.h\"",
            "#include \"udf_i.h\"",
            "#include <linux/bitops.h>",
            "#include <linux/buffer_head.h>",
            "#include \"udfdecl.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"udf_sb.h\"\n#include \"udf_i.h\"\n#include <linux/bitops.h>\n#include <linux/buffer_head.h>\n#include \"udfdecl.h\"\n\nstatic void udf_add_free_space(struct super_block *sb, u16 partition, u32 cnt)\n{\n\tstruct udf_sb_info *sbi = UDF_SB(sb);\n\tstruct logicalVolIntegrityDesc *lvid;\n\n\tif (!sbi->s_lvid_bh)\n\t\treturn;\n\n\tlvid = (struct logicalVolIntegrityDesc *)sbi->s_lvid_bh->b_data;\n\tle32_add_cpu(&lvid->freeSpaceTable[partition], cnt);\n\tudf_updated_lvid(sb);\n}"
        }
      },
      {
        "call_info": {
          "callee": "udf_debug",
          "args": [
            "\"byte=%2x\\n\"",
            "((char *)bh->b_data)[(bit + i) >> 3]"
          ],
          "line": 157
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "udf_debug",
          "args": [
            "\"bit %ld already set\\n\"",
            "bit + i"
          ],
          "line": 156
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "udf_set_bit",
          "args": [
            "bit + i",
            "bh->b_data"
          ],
          "line": 155
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "load_block_bitmap",
          "args": [
            "sb",
            "bitmap",
            "block_group"
          ],
          "line": 149
        },
        "resolved": true,
        "details": {
          "function_name": "load_block_bitmap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/balloc.c",
          "lines": "77-92",
          "snippet": "static inline int load_block_bitmap(struct super_block *sb,\n\t\t\t\t    struct udf_bitmap *bitmap,\n\t\t\t\t    unsigned int block_group)\n{\n\tint slot;\n\n\tslot = __load_block_bitmap(sb, bitmap, block_group);\n\n\tif (slot < 0)\n\t\treturn slot;\n\n\tif (!bitmap->s_block_bitmap[slot])\n\t\treturn -EIO;\n\n\treturn slot;\n}",
          "includes": [
            "#include \"udf_sb.h\"",
            "#include \"udf_i.h\"",
            "#include <linux/bitops.h>",
            "#include <linux/buffer_head.h>",
            "#include \"udfdecl.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"udf_sb.h\"\n#include \"udf_i.h\"\n#include <linux/bitops.h>\n#include <linux/buffer_head.h>\n#include \"udfdecl.h\"\n\nstatic inline int load_block_bitmap(struct super_block *sb,\n\t\t\t\t    struct udf_bitmap *bitmap,\n\t\t\t\t    unsigned int block_group)\n{\n\tint slot;\n\n\tslot = __load_block_bitmap(sb, bitmap, block_group);\n\n\tif (slot < 0)\n\t\treturn slot;\n\n\tif (!bitmap->s_block_bitmap[slot])\n\t\treturn -EIO;\n\n\treturn slot;\n}"
        }
      },
      {
        "call_info": {
          "callee": "udf_debug",
          "args": [
            "\"%d < %d || %d + %d > %d\\n\"",
            "bloc->logicalBlockNum",
            "0",
            "bloc->logicalBlockNum",
            "count",
            "partmap->s_partition_len"
          ],
          "line": 127
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&sbi->s_alloc_mutex"
          ],
          "line": 123
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UDF_SB",
          "args": [
            "sb"
          ],
          "line": 113
        },
        "resolved": true,
        "details": {
          "function_name": "UDF_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/udf_sb.h",
          "lines": "160-163",
          "snippet": "static inline struct udf_sb_info *UDF_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include <linux/bitops.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bitops.h>\n#include <linux/mutex.h>\n\nstatic inline struct udf_sb_info *UDF_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"udf_sb.h\"\n#include \"udf_i.h\"\n#include <linux/bitops.h>\n#include <linux/buffer_head.h>\n#include \"udfdecl.h\"\n\n#define udf_set_bit\t__test_and_set_bit_le\n\nstatic void udf_bitmap_free_blocks(struct super_block *sb,\n\t\t\t\t   struct udf_bitmap *bitmap,\n\t\t\t\t   struct kernel_lb_addr *bloc,\n\t\t\t\t   uint32_t offset,\n\t\t\t\t   uint32_t count)\n{\n\tstruct udf_sb_info *sbi = UDF_SB(sb);\n\tstruct buffer_head *bh = NULL;\n\tstruct udf_part_map *partmap;\n\tunsigned long block;\n\tunsigned long block_group;\n\tunsigned long bit;\n\tunsigned long i;\n\tint bitmap_nr;\n\tunsigned long overflow;\n\n\tmutex_lock(&sbi->s_alloc_mutex);\n\tpartmap = &sbi->s_partmaps[bloc->partitionReferenceNum];\n\tif (bloc->logicalBlockNum + count < count ||\n\t    (bloc->logicalBlockNum + count) > partmap->s_partition_len) {\n\t\tudf_debug(\"%d < %d || %d + %d > %d\\n\",\n\t\t\t  bloc->logicalBlockNum, 0,\n\t\t\t  bloc->logicalBlockNum, count,\n\t\t\t  partmap->s_partition_len);\n\t\tgoto error_return;\n\t}\n\n\tblock = bloc->logicalBlockNum + offset +\n\t\t(sizeof(struct spaceBitmapDesc) << 3);\n\n\tdo {\n\t\toverflow = 0;\n\t\tblock_group = block >> (sb->s_blocksize_bits + 3);\n\t\tbit = block % (sb->s_blocksize << 3);\n\n\t\t/*\n\t\t* Check to see if we are freeing blocks across a group boundary.\n\t\t*/\n\t\tif (bit + count > (sb->s_blocksize << 3)) {\n\t\t\toverflow = bit + count - (sb->s_blocksize << 3);\n\t\t\tcount -= overflow;\n\t\t}\n\t\tbitmap_nr = load_block_bitmap(sb, bitmap, block_group);\n\t\tif (bitmap_nr < 0)\n\t\t\tgoto error_return;\n\n\t\tbh = bitmap->s_block_bitmap[bitmap_nr];\n\t\tfor (i = 0; i < count; i++) {\n\t\t\tif (udf_set_bit(bit + i, bh->b_data)) {\n\t\t\t\tudf_debug(\"bit %ld already set\\n\", bit + i);\n\t\t\t\tudf_debug(\"byte=%2x\\n\",\n\t\t\t\t\t  ((char *)bh->b_data)[(bit + i) >> 3]);\n\t\t\t}\n\t\t}\n\t\tudf_add_free_space(sb, sbi->s_partition, count);\n\t\tmark_buffer_dirty(bh);\n\t\tif (overflow) {\n\t\t\tblock += count;\n\t\t\tcount = overflow;\n\t\t}\n\t} while (overflow);\n\nerror_return:\n\tmutex_unlock(&sbi->s_alloc_mutex);\n}"
  },
  {
    "function_name": "udf_add_free_space",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/balloc.c",
    "lines": "94-105",
    "snippet": "static void udf_add_free_space(struct super_block *sb, u16 partition, u32 cnt)\n{\n\tstruct udf_sb_info *sbi = UDF_SB(sb);\n\tstruct logicalVolIntegrityDesc *lvid;\n\n\tif (!sbi->s_lvid_bh)\n\t\treturn;\n\n\tlvid = (struct logicalVolIntegrityDesc *)sbi->s_lvid_bh->b_data;\n\tle32_add_cpu(&lvid->freeSpaceTable[partition], cnt);\n\tudf_updated_lvid(sb);\n}",
    "includes": [
      "#include \"udf_sb.h\"",
      "#include \"udf_i.h\"",
      "#include <linux/bitops.h>",
      "#include <linux/buffer_head.h>",
      "#include \"udfdecl.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "udf_updated_lvid",
          "args": [
            "sb"
          ],
          "line": 104
        },
        "resolved": true,
        "details": {
          "function_name": "udf_updated_lvid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/udfdecl.h",
          "lines": "119-128",
          "snippet": "static inline void udf_updated_lvid(struct super_block *sb)\n{\n\tstruct buffer_head *bh = UDF_SB(sb)->s_lvid_bh;\n\n\tBUG_ON(!bh);\n\tWARN_ON_ONCE(((struct logicalVolIntegrityDesc *)\n\t\t     bh->b_data)->integrityType !=\n\t\t     cpu_to_le32(LVID_INTEGRITY_TYPE_OPEN));\n\tUDF_SB(sb)->s_lvid_dirty = 1;\n}",
          "includes": [
            "#include \"udf_i.h\"",
            "#include \"udfend.h\"",
            "#include \"udf_sb.h\"",
            "#include <linux/udf_fs_i.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include \"osta_udf.h\"",
            "#include \"ecma_167.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"udf_i.h\"\n#include \"udfend.h\"\n#include \"udf_sb.h\"\n#include <linux/udf_fs_i.h>\n#include <linux/buffer_head.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include \"osta_udf.h\"\n#include \"ecma_167.h\"\n\nstatic inline void udf_updated_lvid(struct super_block *sb)\n{\n\tstruct buffer_head *bh = UDF_SB(sb)->s_lvid_bh;\n\n\tBUG_ON(!bh);\n\tWARN_ON_ONCE(((struct logicalVolIntegrityDesc *)\n\t\t     bh->b_data)->integrityType !=\n\t\t     cpu_to_le32(LVID_INTEGRITY_TYPE_OPEN));\n\tUDF_SB(sb)->s_lvid_dirty = 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "le32_add_cpu",
          "args": [
            "&lvid->freeSpaceTable[partition]",
            "cnt"
          ],
          "line": 103
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UDF_SB",
          "args": [
            "sb"
          ],
          "line": 96
        },
        "resolved": true,
        "details": {
          "function_name": "UDF_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/udf_sb.h",
          "lines": "160-163",
          "snippet": "static inline struct udf_sb_info *UDF_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include <linux/bitops.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bitops.h>\n#include <linux/mutex.h>\n\nstatic inline struct udf_sb_info *UDF_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"udf_sb.h\"\n#include \"udf_i.h\"\n#include <linux/bitops.h>\n#include <linux/buffer_head.h>\n#include \"udfdecl.h\"\n\nstatic void udf_add_free_space(struct super_block *sb, u16 partition, u32 cnt)\n{\n\tstruct udf_sb_info *sbi = UDF_SB(sb);\n\tstruct logicalVolIntegrityDesc *lvid;\n\n\tif (!sbi->s_lvid_bh)\n\t\treturn;\n\n\tlvid = (struct logicalVolIntegrityDesc *)sbi->s_lvid_bh->b_data;\n\tle32_add_cpu(&lvid->freeSpaceTable[partition], cnt);\n\tudf_updated_lvid(sb);\n}"
  },
  {
    "function_name": "load_block_bitmap",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/balloc.c",
    "lines": "77-92",
    "snippet": "static inline int load_block_bitmap(struct super_block *sb,\n\t\t\t\t    struct udf_bitmap *bitmap,\n\t\t\t\t    unsigned int block_group)\n{\n\tint slot;\n\n\tslot = __load_block_bitmap(sb, bitmap, block_group);\n\n\tif (slot < 0)\n\t\treturn slot;\n\n\tif (!bitmap->s_block_bitmap[slot])\n\t\treturn -EIO;\n\n\treturn slot;\n}",
    "includes": [
      "#include \"udf_sb.h\"",
      "#include \"udf_i.h\"",
      "#include <linux/bitops.h>",
      "#include <linux/buffer_head.h>",
      "#include \"udfdecl.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__load_block_bitmap",
          "args": [
            "sb",
            "bitmap",
            "block_group"
          ],
          "line": 83
        },
        "resolved": true,
        "details": {
          "function_name": "__load_block_bitmap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/balloc.c",
          "lines": "54-75",
          "snippet": "static int __load_block_bitmap(struct super_block *sb,\n\t\t\t       struct udf_bitmap *bitmap,\n\t\t\t       unsigned int block_group)\n{\n\tint retval = 0;\n\tint nr_groups = bitmap->s_nr_groups;\n\n\tif (block_group >= nr_groups) {\n\t\tudf_debug(\"block_group (%d) > nr_groups (%d)\\n\",\n\t\t\t  block_group, nr_groups);\n\t}\n\n\tif (bitmap->s_block_bitmap[block_group]) {\n\t\treturn block_group;\n\t} else {\n\t\tretval = read_block_bitmap(sb, bitmap, block_group,\n\t\t\t\t\t   block_group);\n\t\tif (retval < 0)\n\t\t\treturn retval;\n\t\treturn block_group;\n\t}\n}",
          "includes": [
            "#include \"udf_sb.h\"",
            "#include \"udf_i.h\"",
            "#include <linux/bitops.h>",
            "#include <linux/buffer_head.h>",
            "#include \"udfdecl.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"udf_sb.h\"\n#include \"udf_i.h\"\n#include <linux/bitops.h>\n#include <linux/buffer_head.h>\n#include \"udfdecl.h\"\n\nstatic int __load_block_bitmap(struct super_block *sb,\n\t\t\t       struct udf_bitmap *bitmap,\n\t\t\t       unsigned int block_group)\n{\n\tint retval = 0;\n\tint nr_groups = bitmap->s_nr_groups;\n\n\tif (block_group >= nr_groups) {\n\t\tudf_debug(\"block_group (%d) > nr_groups (%d)\\n\",\n\t\t\t  block_group, nr_groups);\n\t}\n\n\tif (bitmap->s_block_bitmap[block_group]) {\n\t\treturn block_group;\n\t} else {\n\t\tretval = read_block_bitmap(sb, bitmap, block_group,\n\t\t\t\t\t   block_group);\n\t\tif (retval < 0)\n\t\t\treturn retval;\n\t\treturn block_group;\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"udf_sb.h\"\n#include \"udf_i.h\"\n#include <linux/bitops.h>\n#include <linux/buffer_head.h>\n#include \"udfdecl.h\"\n\nstatic inline int load_block_bitmap(struct super_block *sb,\n\t\t\t\t    struct udf_bitmap *bitmap,\n\t\t\t\t    unsigned int block_group)\n{\n\tint slot;\n\n\tslot = __load_block_bitmap(sb, bitmap, block_group);\n\n\tif (slot < 0)\n\t\treturn slot;\n\n\tif (!bitmap->s_block_bitmap[slot])\n\t\treturn -EIO;\n\n\treturn slot;\n}"
  },
  {
    "function_name": "__load_block_bitmap",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/balloc.c",
    "lines": "54-75",
    "snippet": "static int __load_block_bitmap(struct super_block *sb,\n\t\t\t       struct udf_bitmap *bitmap,\n\t\t\t       unsigned int block_group)\n{\n\tint retval = 0;\n\tint nr_groups = bitmap->s_nr_groups;\n\n\tif (block_group >= nr_groups) {\n\t\tudf_debug(\"block_group (%d) > nr_groups (%d)\\n\",\n\t\t\t  block_group, nr_groups);\n\t}\n\n\tif (bitmap->s_block_bitmap[block_group]) {\n\t\treturn block_group;\n\t} else {\n\t\tretval = read_block_bitmap(sb, bitmap, block_group,\n\t\t\t\t\t   block_group);\n\t\tif (retval < 0)\n\t\t\treturn retval;\n\t\treturn block_group;\n\t}\n}",
    "includes": [
      "#include \"udf_sb.h\"",
      "#include \"udf_i.h\"",
      "#include <linux/bitops.h>",
      "#include <linux/buffer_head.h>",
      "#include \"udfdecl.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "read_block_bitmap",
          "args": [
            "sb",
            "bitmap",
            "block_group",
            "block_group"
          ],
          "line": 69
        },
        "resolved": true,
        "details": {
          "function_name": "read_block_bitmap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/balloc.c",
          "lines": "35-52",
          "snippet": "static int read_block_bitmap(struct super_block *sb,\n\t\t\t     struct udf_bitmap *bitmap, unsigned int block,\n\t\t\t     unsigned long bitmap_nr)\n{\n\tstruct buffer_head *bh = NULL;\n\tint retval = 0;\n\tstruct kernel_lb_addr loc;\n\n\tloc.logicalBlockNum = bitmap->s_extPosition;\n\tloc.partitionReferenceNum = UDF_SB(sb)->s_partition;\n\n\tbh = udf_tread(sb, udf_get_lb_pblock(sb, &loc, block));\n\tif (!bh)\n\t\tretval = -EIO;\n\n\tbitmap->s_block_bitmap[bitmap_nr] = bh;\n\treturn retval;\n}",
          "includes": [
            "#include \"udf_sb.h\"",
            "#include \"udf_i.h\"",
            "#include <linux/bitops.h>",
            "#include <linux/buffer_head.h>",
            "#include \"udfdecl.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"udf_sb.h\"\n#include \"udf_i.h\"\n#include <linux/bitops.h>\n#include <linux/buffer_head.h>\n#include \"udfdecl.h\"\n\nstatic int read_block_bitmap(struct super_block *sb,\n\t\t\t     struct udf_bitmap *bitmap, unsigned int block,\n\t\t\t     unsigned long bitmap_nr)\n{\n\tstruct buffer_head *bh = NULL;\n\tint retval = 0;\n\tstruct kernel_lb_addr loc;\n\n\tloc.logicalBlockNum = bitmap->s_extPosition;\n\tloc.partitionReferenceNum = UDF_SB(sb)->s_partition;\n\n\tbh = udf_tread(sb, udf_get_lb_pblock(sb, &loc, block));\n\tif (!bh)\n\t\tretval = -EIO;\n\n\tbitmap->s_block_bitmap[bitmap_nr] = bh;\n\treturn retval;\n}"
        }
      },
      {
        "call_info": {
          "callee": "udf_debug",
          "args": [
            "\"block_group (%d) > nr_groups (%d)\\n\"",
            "block_group",
            "nr_groups"
          ],
          "line": 62
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"udf_sb.h\"\n#include \"udf_i.h\"\n#include <linux/bitops.h>\n#include <linux/buffer_head.h>\n#include \"udfdecl.h\"\n\nstatic int __load_block_bitmap(struct super_block *sb,\n\t\t\t       struct udf_bitmap *bitmap,\n\t\t\t       unsigned int block_group)\n{\n\tint retval = 0;\n\tint nr_groups = bitmap->s_nr_groups;\n\n\tif (block_group >= nr_groups) {\n\t\tudf_debug(\"block_group (%d) > nr_groups (%d)\\n\",\n\t\t\t  block_group, nr_groups);\n\t}\n\n\tif (bitmap->s_block_bitmap[block_group]) {\n\t\treturn block_group;\n\t} else {\n\t\tretval = read_block_bitmap(sb, bitmap, block_group,\n\t\t\t\t\t   block_group);\n\t\tif (retval < 0)\n\t\t\treturn retval;\n\t\treturn block_group;\n\t}\n}"
  },
  {
    "function_name": "read_block_bitmap",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/balloc.c",
    "lines": "35-52",
    "snippet": "static int read_block_bitmap(struct super_block *sb,\n\t\t\t     struct udf_bitmap *bitmap, unsigned int block,\n\t\t\t     unsigned long bitmap_nr)\n{\n\tstruct buffer_head *bh = NULL;\n\tint retval = 0;\n\tstruct kernel_lb_addr loc;\n\n\tloc.logicalBlockNum = bitmap->s_extPosition;\n\tloc.partitionReferenceNum = UDF_SB(sb)->s_partition;\n\n\tbh = udf_tread(sb, udf_get_lb_pblock(sb, &loc, block));\n\tif (!bh)\n\t\tretval = -EIO;\n\n\tbitmap->s_block_bitmap[bitmap_nr] = bh;\n\treturn retval;\n}",
    "includes": [
      "#include \"udf_sb.h\"",
      "#include \"udf_i.h\"",
      "#include <linux/bitops.h>",
      "#include <linux/buffer_head.h>",
      "#include \"udfdecl.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "udf_tread",
          "args": [
            "sb",
            "udf_get_lb_pblock(sb, &loc, block)"
          ],
          "line": 46
        },
        "resolved": true,
        "details": {
          "function_name": "udf_tread",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/misc.c",
          "lines": "40-46",
          "snippet": "struct buffer_head *udf_tread(struct super_block *sb, int block)\n{\n\tif (UDF_QUERY_FLAG(sb, UDF_FLAG_VARCONV))\n\t\treturn sb_bread(sb, udf_fixed_to_variable(block));\n\telse\n\t\treturn sb_bread(sb, block);\n}",
          "includes": [
            "#include \"udf_sb.h\"",
            "#include \"udf_i.h\"",
            "#include <linux/crc-itu-t.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/fs.h>",
            "#include \"udfdecl.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"udf_sb.h\"\n#include \"udf_i.h\"\n#include <linux/crc-itu-t.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/fs.h>\n#include \"udfdecl.h\"\n\nstruct buffer_head *udf_tread(struct super_block *sb, int block)\n{\n\tif (UDF_QUERY_FLAG(sb, UDF_FLAG_VARCONV))\n\t\treturn sb_bread(sb, udf_fixed_to_variable(block));\n\telse\n\t\treturn sb_bread(sb, block);\n}"
        }
      },
      {
        "call_info": {
          "callee": "udf_get_lb_pblock",
          "args": [
            "sb",
            "&loc",
            "block"
          ],
          "line": 46
        },
        "resolved": true,
        "details": {
          "function_name": "udf_get_lb_pblock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/udfdecl.h",
          "lines": "205-211",
          "snippet": "static inline uint32_t\nudf_get_lb_pblock(struct super_block *sb, struct kernel_lb_addr *loc,\n\t\t  uint32_t offset)\n{\n\treturn udf_get_pblock(sb, loc->logicalBlockNum,\n\t\t\tloc->partitionReferenceNum, offset);\n}",
          "includes": [
            "#include \"udf_i.h\"",
            "#include \"udfend.h\"",
            "#include \"udf_sb.h\"",
            "#include <linux/udf_fs_i.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include \"osta_udf.h\"",
            "#include \"ecma_167.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"udf_i.h\"\n#include \"udfend.h\"\n#include \"udf_sb.h\"\n#include <linux/udf_fs_i.h>\n#include <linux/buffer_head.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include \"osta_udf.h\"\n#include \"ecma_167.h\"\n\nstatic inline uint32_t\nudf_get_lb_pblock(struct super_block *sb, struct kernel_lb_addr *loc,\n\t\t  uint32_t offset)\n{\n\treturn udf_get_pblock(sb, loc->logicalBlockNum,\n\t\t\tloc->partitionReferenceNum, offset);\n}"
        }
      },
      {
        "call_info": {
          "callee": "UDF_SB",
          "args": [
            "sb"
          ],
          "line": 44
        },
        "resolved": true,
        "details": {
          "function_name": "UDF_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/udf_sb.h",
          "lines": "160-163",
          "snippet": "static inline struct udf_sb_info *UDF_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include <linux/bitops.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bitops.h>\n#include <linux/mutex.h>\n\nstatic inline struct udf_sb_info *UDF_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"udf_sb.h\"\n#include \"udf_i.h\"\n#include <linux/bitops.h>\n#include <linux/buffer_head.h>\n#include \"udfdecl.h\"\n\nstatic int read_block_bitmap(struct super_block *sb,\n\t\t\t     struct udf_bitmap *bitmap, unsigned int block,\n\t\t\t     unsigned long bitmap_nr)\n{\n\tstruct buffer_head *bh = NULL;\n\tint retval = 0;\n\tstruct kernel_lb_addr loc;\n\n\tloc.logicalBlockNum = bitmap->s_extPosition;\n\tloc.partitionReferenceNum = UDF_SB(sb)->s_partition;\n\n\tbh = udf_tread(sb, udf_get_lb_pblock(sb, &loc, block));\n\tif (!bh)\n\t\tretval = -EIO;\n\n\tbitmap->s_block_bitmap[bitmap_nr] = bh;\n\treturn retval;\n}"
  }
]