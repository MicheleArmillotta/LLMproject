[
  {
    "function_name": "proc_nommu_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/nommu.c",
    "lines": "128-132",
    "snippet": "static int __init proc_nommu_init(void)\n{\n\tproc_create(\"maps\", S_IRUGO, NULL, &proc_nommu_region_list_operations);\n\treturn 0;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/div64.h>",
      "#include <asm/tlb.h>",
      "#include <asm/pgtable.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/smp.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mmzone.h>",
      "#include <linux/mm.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/mman.h>",
      "#include <linux/string.h>",
      "#include <linux/kernel.h>",
      "#include <linux/time.h>",
      "#include <linux/errno.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static const struct file_operations proc_nommu_region_list_operations = {\n\t.open    = proc_nommu_region_list_open,\n\t.read    = seq_read,\n\t.llseek  = seq_lseek,\n\t.release = seq_release,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "proc_create",
          "args": [
            "\"maps\"",
            "S_IRUGO",
            "NULL",
            "&proc_nommu_region_list_operations"
          ],
          "line": 130
        },
        "resolved": true,
        "details": {
          "function_name": "__proc_create",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/generic.c",
          "lines": "355-391",
          "snippet": "static struct proc_dir_entry *__proc_create(struct proc_dir_entry **parent,\n\t\t\t\t\t  const char *name,\n\t\t\t\t\t  umode_t mode,\n\t\t\t\t\t  nlink_t nlink)\n{\n\tstruct proc_dir_entry *ent = NULL;\n\tconst char *fn;\n\tstruct qstr qstr;\n\n\tif (xlate_proc_name(name, parent, &fn) != 0)\n\t\tgoto out;\n\tqstr.name = fn;\n\tqstr.len = strlen(fn);\n\tif (qstr.len == 0 || qstr.len >= 256) {\n\t\tWARN(1, \"name len %u\\n\", qstr.len);\n\t\treturn NULL;\n\t}\n\tif (*parent == &proc_root && name_to_int(&qstr) != ~0U) {\n\t\tWARN(1, \"create '/proc/%s' by hand\\n\", qstr.name);\n\t\treturn NULL;\n\t}\n\n\tent = kzalloc(sizeof(struct proc_dir_entry) + qstr.len + 1, GFP_KERNEL);\n\tif (!ent)\n\t\tgoto out;\n\n\tmemcpy(ent->name, fn, qstr.len + 1);\n\tent->namelen = qstr.len;\n\tent->mode = mode;\n\tent->nlink = nlink;\n\tent->subdir = RB_ROOT;\n\tatomic_set(&ent->count, 1);\n\tspin_lock_init(&ent->pde_unload_lock);\n\tINIT_LIST_HEAD(&ent->pde_openers);\nout:\n\treturn ent;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/bitops.h>",
            "#include <linux/idr.h>",
            "#include <linux/init.h>",
            "#include <linux/mount.h>",
            "#include <linux/printk.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/stat.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/time.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/bitops.h>\n#include <linux/idr.h>\n#include <linux/init.h>\n#include <linux/mount.h>\n#include <linux/printk.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/stat.h>\n#include <linux/proc_fs.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n\nstatic struct proc_dir_entry *__proc_create(struct proc_dir_entry **parent,\n\t\t\t\t\t  const char *name,\n\t\t\t\t\t  umode_t mode,\n\t\t\t\t\t  nlink_t nlink)\n{\n\tstruct proc_dir_entry *ent = NULL;\n\tconst char *fn;\n\tstruct qstr qstr;\n\n\tif (xlate_proc_name(name, parent, &fn) != 0)\n\t\tgoto out;\n\tqstr.name = fn;\n\tqstr.len = strlen(fn);\n\tif (qstr.len == 0 || qstr.len >= 256) {\n\t\tWARN(1, \"name len %u\\n\", qstr.len);\n\t\treturn NULL;\n\t}\n\tif (*parent == &proc_root && name_to_int(&qstr) != ~0U) {\n\t\tWARN(1, \"create '/proc/%s' by hand\\n\", qstr.name);\n\t\treturn NULL;\n\t}\n\n\tent = kzalloc(sizeof(struct proc_dir_entry) + qstr.len + 1, GFP_KERNEL);\n\tif (!ent)\n\t\tgoto out;\n\n\tmemcpy(ent->name, fn, qstr.len + 1);\n\tent->namelen = qstr.len;\n\tent->mode = mode;\n\tent->nlink = nlink;\n\tent->subdir = RB_ROOT;\n\tatomic_set(&ent->count, 1);\n\tspin_lock_init(&ent->pde_unload_lock);\n\tINIT_LIST_HEAD(&ent->pde_openers);\nout:\n\treturn ent;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/div64.h>\n#include <asm/tlb.h>\n#include <asm/pgtable.h>\n#include <asm/uaccess.h>\n#include <linux/vmalloc.h>\n#include <linux/hugetlb.h>\n#include <linux/seq_file.h>\n#include <linux/smp.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/mmzone.h>\n#include <linux/mm.h>\n#include <linux/proc_fs.h>\n#include <linux/mman.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <linux/module.h>\n#include <linux/init.h>\n\nstatic const struct file_operations proc_nommu_region_list_operations = {\n\t.open    = proc_nommu_region_list_open,\n\t.read    = seq_read,\n\t.llseek  = seq_lseek,\n\t.release = seq_release,\n};\n\nstatic int __init proc_nommu_init(void)\n{\n\tproc_create(\"maps\", S_IRUGO, NULL, &proc_nommu_region_list_operations);\n\treturn 0;\n}"
  },
  {
    "function_name": "proc_nommu_region_list_open",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/nommu.c",
    "lines": "116-119",
    "snippet": "static int proc_nommu_region_list_open(struct inode *inode, struct file *file)\n{\n\treturn seq_open(file, &proc_nommu_region_list_seqop);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/div64.h>",
      "#include <asm/tlb.h>",
      "#include <asm/pgtable.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/smp.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mmzone.h>",
      "#include <linux/mm.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/mman.h>",
      "#include <linux/string.h>",
      "#include <linux/kernel.h>",
      "#include <linux/time.h>",
      "#include <linux/errno.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static const struct seq_operations proc_nommu_region_list_seqop = {\n\t.start\t= nommu_region_list_start,\n\t.next\t= nommu_region_list_next,\n\t.stop\t= nommu_region_list_stop,\n\t.show\t= nommu_region_list_show\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "seq_open",
          "args": [
            "file",
            "&proc_nommu_region_list_seqop"
          ],
          "line": 118
        },
        "resolved": true,
        "details": {
          "function_name": "seq_open",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/seq_file.c",
          "lines": "52-87",
          "snippet": "int seq_open(struct file *file, const struct seq_operations *op)\n{\n\tstruct seq_file *p = file->private_data;\n\n\tif (!p) {\n\t\tp = kmalloc(sizeof(*p), GFP_KERNEL);\n\t\tif (!p)\n\t\t\treturn -ENOMEM;\n\t\tfile->private_data = p;\n\t}\n\tmemset(p, 0, sizeof(*p));\n\tmutex_init(&p->lock);\n\tp->op = op;\n#ifdef CONFIG_USER_NS\n\tp->user_ns = file->f_cred->user_ns;\n#endif\n\n\t/*\n\t * Wrappers around seq_open(e.g. swaps_open) need to be\n\t * aware of this. If they set f_version themselves, they\n\t * should call seq_open first and then set f_version.\n\t */\n\tfile->f_version = 0;\n\n\t/*\n\t * seq_files support lseek() and pread().  They do not implement\n\t * write() at all, but we clear FMODE_PWRITE here for historical\n\t * reasons.\n\t *\n\t * If a client of seq_files a) implements file.write() and b) wishes to\n\t * support pwrite() then that client will need to implement its own\n\t * file.open() which calls seq_open() and then sets FMODE_PWRITE.\n\t */\n\tfile->f_mode &= ~FMODE_PWRITE;\n\treturn 0;\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/mm.h>",
            "#include <linux/cred.h>",
            "#include <linux/slab.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/export.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <linux/mm.h>\n#include <linux/cred.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/seq_file.h>\n#include <linux/export.h>\n#include <linux/fs.h>\n\nint seq_open(struct file *file, const struct seq_operations *op)\n{\n\tstruct seq_file *p = file->private_data;\n\n\tif (!p) {\n\t\tp = kmalloc(sizeof(*p), GFP_KERNEL);\n\t\tif (!p)\n\t\t\treturn -ENOMEM;\n\t\tfile->private_data = p;\n\t}\n\tmemset(p, 0, sizeof(*p));\n\tmutex_init(&p->lock);\n\tp->op = op;\n#ifdef CONFIG_USER_NS\n\tp->user_ns = file->f_cred->user_ns;\n#endif\n\n\t/*\n\t * Wrappers around seq_open(e.g. swaps_open) need to be\n\t * aware of this. If they set f_version themselves, they\n\t * should call seq_open first and then set f_version.\n\t */\n\tfile->f_version = 0;\n\n\t/*\n\t * seq_files support lseek() and pread().  They do not implement\n\t * write() at all, but we clear FMODE_PWRITE here for historical\n\t * reasons.\n\t *\n\t * If a client of seq_files a) implements file.write() and b) wishes to\n\t * support pwrite() then that client will need to implement its own\n\t * file.open() which calls seq_open() and then sets FMODE_PWRITE.\n\t */\n\tfile->f_mode &= ~FMODE_PWRITE;\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/div64.h>\n#include <asm/tlb.h>\n#include <asm/pgtable.h>\n#include <asm/uaccess.h>\n#include <linux/vmalloc.h>\n#include <linux/hugetlb.h>\n#include <linux/seq_file.h>\n#include <linux/smp.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/mmzone.h>\n#include <linux/mm.h>\n#include <linux/proc_fs.h>\n#include <linux/mman.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <linux/module.h>\n#include <linux/init.h>\n\nstatic const struct seq_operations proc_nommu_region_list_seqop = {\n\t.start\t= nommu_region_list_start,\n\t.next\t= nommu_region_list_next,\n\t.stop\t= nommu_region_list_stop,\n\t.show\t= nommu_region_list_show\n};\n\nstatic int proc_nommu_region_list_open(struct inode *inode, struct file *file)\n{\n\treturn seq_open(file, &proc_nommu_region_list_seqop);\n}"
  },
  {
    "function_name": "nommu_region_list_next",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/nommu.c",
    "lines": "103-107",
    "snippet": "static void *nommu_region_list_next(struct seq_file *m, void *v, loff_t *pos)\n{\n\t(*pos)++;\n\treturn rb_next((struct rb_node *) v);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/div64.h>",
      "#include <asm/tlb.h>",
      "#include <asm/pgtable.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/smp.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mmzone.h>",
      "#include <linux/mm.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/mman.h>",
      "#include <linux/string.h>",
      "#include <linux/kernel.h>",
      "#include <linux/time.h>",
      "#include <linux/errno.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "rb_next",
          "args": [
            "(struct rb_node *) v"
          ],
          "line": 106
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/div64.h>\n#include <asm/tlb.h>\n#include <asm/pgtable.h>\n#include <asm/uaccess.h>\n#include <linux/vmalloc.h>\n#include <linux/hugetlb.h>\n#include <linux/seq_file.h>\n#include <linux/smp.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/mmzone.h>\n#include <linux/mm.h>\n#include <linux/proc_fs.h>\n#include <linux/mman.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <linux/module.h>\n#include <linux/init.h>\n\nstatic void *nommu_region_list_next(struct seq_file *m, void *v, loff_t *pos)\n{\n\t(*pos)++;\n\treturn rb_next((struct rb_node *) v);\n}"
  },
  {
    "function_name": "nommu_region_list_stop",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/nommu.c",
    "lines": "98-101",
    "snippet": "static void nommu_region_list_stop(struct seq_file *m, void *v)\n{\n\tup_read(&nommu_region_sem);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/div64.h>",
      "#include <asm/tlb.h>",
      "#include <asm/pgtable.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/smp.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mmzone.h>",
      "#include <linux/mm.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/mman.h>",
      "#include <linux/string.h>",
      "#include <linux/kernel.h>",
      "#include <linux/time.h>",
      "#include <linux/errno.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "up_read",
          "args": [
            "&nommu_region_sem"
          ],
          "line": 100
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/div64.h>\n#include <asm/tlb.h>\n#include <asm/pgtable.h>\n#include <asm/uaccess.h>\n#include <linux/vmalloc.h>\n#include <linux/hugetlb.h>\n#include <linux/seq_file.h>\n#include <linux/smp.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/mmzone.h>\n#include <linux/mm.h>\n#include <linux/proc_fs.h>\n#include <linux/mman.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <linux/module.h>\n#include <linux/init.h>\n\nstatic void nommu_region_list_stop(struct seq_file *m, void *v)\n{\n\tup_read(&nommu_region_sem);\n}"
  },
  {
    "function_name": "nommu_region_list_start",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/nommu.c",
    "lines": "85-96",
    "snippet": "static void *nommu_region_list_start(struct seq_file *m, loff_t *_pos)\n{\n\tstruct rb_node *p;\n\tloff_t pos = *_pos;\n\n\tdown_read(&nommu_region_sem);\n\n\tfor (p = rb_first(&nommu_region_tree); p; p = rb_next(p))\n\t\tif (pos-- == 0)\n\t\t\treturn p;\n\treturn NULL;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/div64.h>",
      "#include <asm/tlb.h>",
      "#include <asm/pgtable.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/smp.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mmzone.h>",
      "#include <linux/mm.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/mman.h>",
      "#include <linux/string.h>",
      "#include <linux/kernel.h>",
      "#include <linux/time.h>",
      "#include <linux/errno.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "rb_next",
          "args": [
            "p"
          ],
          "line": 92
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb_first",
          "args": [
            "&nommu_region_tree"
          ],
          "line": 92
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "down_read",
          "args": [
            "&nommu_region_sem"
          ],
          "line": 90
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/div64.h>\n#include <asm/tlb.h>\n#include <asm/pgtable.h>\n#include <asm/uaccess.h>\n#include <linux/vmalloc.h>\n#include <linux/hugetlb.h>\n#include <linux/seq_file.h>\n#include <linux/smp.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/mmzone.h>\n#include <linux/mm.h>\n#include <linux/proc_fs.h>\n#include <linux/mman.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <linux/module.h>\n#include <linux/init.h>\n\nstatic void *nommu_region_list_start(struct seq_file *m, loff_t *_pos)\n{\n\tstruct rb_node *p;\n\tloff_t pos = *_pos;\n\n\tdown_read(&nommu_region_sem);\n\n\tfor (p = rb_first(&nommu_region_tree); p; p = rb_next(p))\n\t\tif (pos-- == 0)\n\t\t\treturn p;\n\treturn NULL;\n}"
  },
  {
    "function_name": "nommu_region_list_show",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/nommu.c",
    "lines": "78-83",
    "snippet": "static int nommu_region_list_show(struct seq_file *m, void *_p)\n{\n\tstruct rb_node *p = _p;\n\n\treturn nommu_region_show(m, rb_entry(p, struct vm_region, vm_rb));\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/div64.h>",
      "#include <asm/tlb.h>",
      "#include <asm/pgtable.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/smp.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mmzone.h>",
      "#include <linux/mm.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/mman.h>",
      "#include <linux/string.h>",
      "#include <linux/kernel.h>",
      "#include <linux/time.h>",
      "#include <linux/errno.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "nommu_region_show",
          "args": [
            "m",
            "rb_entry(p, struct vm_region, vm_rb)"
          ],
          "line": 82
        },
        "resolved": true,
        "details": {
          "function_name": "nommu_region_show",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/nommu.c",
          "lines": "37-72",
          "snippet": "static int nommu_region_show(struct seq_file *m, struct vm_region *region)\n{\n\tunsigned long ino = 0;\n\tstruct file *file;\n\tdev_t dev = 0;\n\tint flags;\n\n\tflags = region->vm_flags;\n\tfile = region->vm_file;\n\n\tif (file) {\n\t\tstruct inode *inode = file_inode(region->vm_file);\n\t\tdev = inode->i_sb->s_dev;\n\t\tino = inode->i_ino;\n\t}\n\n\tseq_setwidth(m, 25 + sizeof(void *) * 6 - 1);\n\tseq_printf(m,\n\t\t   \"%08lx-%08lx %c%c%c%c %08llx %02x:%02x %lu \",\n\t\t   region->vm_start,\n\t\t   region->vm_end,\n\t\t   flags & VM_READ ? 'r' : '-',\n\t\t   flags & VM_WRITE ? 'w' : '-',\n\t\t   flags & VM_EXEC ? 'x' : '-',\n\t\t   flags & VM_MAYSHARE ? flags & VM_SHARED ? 'S' : 's' : 'p',\n\t\t   ((loff_t)region->vm_pgoff) << PAGE_SHIFT,\n\t\t   MAJOR(dev), MINOR(dev), ino);\n\n\tif (file) {\n\t\tseq_pad(m, ' ');\n\t\tseq_path(m, &file->f_path, \"\");\n\t}\n\n\tseq_putc(m, '\\n');\n\treturn 0;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/div64.h>",
            "#include <asm/tlb.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/smp.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/mm.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/mman.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>",
            "#include <linux/time.h>",
            "#include <linux/errno.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/div64.h>\n#include <asm/tlb.h>\n#include <asm/pgtable.h>\n#include <asm/uaccess.h>\n#include <linux/vmalloc.h>\n#include <linux/hugetlb.h>\n#include <linux/seq_file.h>\n#include <linux/smp.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/mmzone.h>\n#include <linux/mm.h>\n#include <linux/proc_fs.h>\n#include <linux/mman.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <linux/module.h>\n#include <linux/init.h>\n\nstatic int nommu_region_show(struct seq_file *m, struct vm_region *region)\n{\n\tunsigned long ino = 0;\n\tstruct file *file;\n\tdev_t dev = 0;\n\tint flags;\n\n\tflags = region->vm_flags;\n\tfile = region->vm_file;\n\n\tif (file) {\n\t\tstruct inode *inode = file_inode(region->vm_file);\n\t\tdev = inode->i_sb->s_dev;\n\t\tino = inode->i_ino;\n\t}\n\n\tseq_setwidth(m, 25 + sizeof(void *) * 6 - 1);\n\tseq_printf(m,\n\t\t   \"%08lx-%08lx %c%c%c%c %08llx %02x:%02x %lu \",\n\t\t   region->vm_start,\n\t\t   region->vm_end,\n\t\t   flags & VM_READ ? 'r' : '-',\n\t\t   flags & VM_WRITE ? 'w' : '-',\n\t\t   flags & VM_EXEC ? 'x' : '-',\n\t\t   flags & VM_MAYSHARE ? flags & VM_SHARED ? 'S' : 's' : 'p',\n\t\t   ((loff_t)region->vm_pgoff) << PAGE_SHIFT,\n\t\t   MAJOR(dev), MINOR(dev), ino);\n\n\tif (file) {\n\t\tseq_pad(m, ' ');\n\t\tseq_path(m, &file->f_path, \"\");\n\t}\n\n\tseq_putc(m, '\\n');\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rb_entry",
          "args": [
            "p",
            "structvm_region",
            "vm_rb"
          ],
          "line": 82
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/div64.h>\n#include <asm/tlb.h>\n#include <asm/pgtable.h>\n#include <asm/uaccess.h>\n#include <linux/vmalloc.h>\n#include <linux/hugetlb.h>\n#include <linux/seq_file.h>\n#include <linux/smp.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/mmzone.h>\n#include <linux/mm.h>\n#include <linux/proc_fs.h>\n#include <linux/mman.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <linux/module.h>\n#include <linux/init.h>\n\nstatic int nommu_region_list_show(struct seq_file *m, void *_p)\n{\n\tstruct rb_node *p = _p;\n\n\treturn nommu_region_show(m, rb_entry(p, struct vm_region, vm_rb));\n}"
  },
  {
    "function_name": "nommu_region_show",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/nommu.c",
    "lines": "37-72",
    "snippet": "static int nommu_region_show(struct seq_file *m, struct vm_region *region)\n{\n\tunsigned long ino = 0;\n\tstruct file *file;\n\tdev_t dev = 0;\n\tint flags;\n\n\tflags = region->vm_flags;\n\tfile = region->vm_file;\n\n\tif (file) {\n\t\tstruct inode *inode = file_inode(region->vm_file);\n\t\tdev = inode->i_sb->s_dev;\n\t\tino = inode->i_ino;\n\t}\n\n\tseq_setwidth(m, 25 + sizeof(void *) * 6 - 1);\n\tseq_printf(m,\n\t\t   \"%08lx-%08lx %c%c%c%c %08llx %02x:%02x %lu \",\n\t\t   region->vm_start,\n\t\t   region->vm_end,\n\t\t   flags & VM_READ ? 'r' : '-',\n\t\t   flags & VM_WRITE ? 'w' : '-',\n\t\t   flags & VM_EXEC ? 'x' : '-',\n\t\t   flags & VM_MAYSHARE ? flags & VM_SHARED ? 'S' : 's' : 'p',\n\t\t   ((loff_t)region->vm_pgoff) << PAGE_SHIFT,\n\t\t   MAJOR(dev), MINOR(dev), ino);\n\n\tif (file) {\n\t\tseq_pad(m, ' ');\n\t\tseq_path(m, &file->f_path, \"\");\n\t}\n\n\tseq_putc(m, '\\n');\n\treturn 0;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/div64.h>",
      "#include <asm/tlb.h>",
      "#include <asm/pgtable.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/smp.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mmzone.h>",
      "#include <linux/mm.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/mman.h>",
      "#include <linux/string.h>",
      "#include <linux/kernel.h>",
      "#include <linux/time.h>",
      "#include <linux/errno.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "seq_putc",
          "args": [
            "m",
            "'\\n'"
          ],
          "line": 70
        },
        "resolved": true,
        "details": {
          "function_name": "seq_putc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/seq_file.c",
          "lines": "648-655",
          "snippet": "int seq_putc(struct seq_file *m, char c)\n{\n\tif (m->count < m->size) {\n\t\tm->buf[m->count++] = c;\n\t\treturn 0;\n\t}\n\treturn -1;\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/mm.h>",
            "#include <linux/cred.h>",
            "#include <linux/slab.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/export.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <linux/mm.h>\n#include <linux/cred.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/seq_file.h>\n#include <linux/export.h>\n#include <linux/fs.h>\n\nint seq_putc(struct seq_file *m, char c)\n{\n\tif (m->count < m->size) {\n\t\tm->buf[m->count++] = c;\n\t\treturn 0;\n\t}\n\treturn -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "seq_path",
          "args": [
            "m",
            "&file->f_path",
            "\"\""
          ],
          "line": 67
        },
        "resolved": true,
        "details": {
          "function_name": "seq_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/seq_file.c",
          "lines": "470-487",
          "snippet": "int seq_path(struct seq_file *m, const struct path *path, const char *esc)\n{\n\tchar *buf;\n\tsize_t size = seq_get_buf(m, &buf);\n\tint res = -1;\n\n\tif (size) {\n\t\tchar *p = d_path(path, buf, size);\n\t\tif (!IS_ERR(p)) {\n\t\t\tchar *end = mangle_path(buf, p, esc);\n\t\t\tif (end)\n\t\t\t\tres = end - buf;\n\t\t}\n\t}\n\tseq_commit(m, res);\n\n\treturn res;\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/mm.h>",
            "#include <linux/cred.h>",
            "#include <linux/slab.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/export.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <linux/mm.h>\n#include <linux/cred.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/seq_file.h>\n#include <linux/export.h>\n#include <linux/fs.h>\n\nint seq_path(struct seq_file *m, const struct path *path, const char *esc)\n{\n\tchar *buf;\n\tsize_t size = seq_get_buf(m, &buf);\n\tint res = -1;\n\n\tif (size) {\n\t\tchar *p = d_path(path, buf, size);\n\t\tif (!IS_ERR(p)) {\n\t\t\tchar *end = mangle_path(buf, p, esc);\n\t\t\tif (end)\n\t\t\t\tres = end - buf;\n\t\t}\n\t}\n\tseq_commit(m, res);\n\n\treturn res;\n}"
        }
      },
      {
        "call_info": {
          "callee": "seq_pad",
          "args": [
            "m",
            "' '"
          ],
          "line": 66
        },
        "resolved": true,
        "details": {
          "function_name": "seq_pad",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/seq_file.c",
          "lines": "748-755",
          "snippet": "void seq_pad(struct seq_file *m, char c)\n{\n\tint size = m->pad_until - m->count;\n\tif (size > 0)\n\t\tseq_printf(m, \"%*s\", size, \"\");\n\tif (c)\n\t\tseq_putc(m, c);\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/mm.h>",
            "#include <linux/cred.h>",
            "#include <linux/slab.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/export.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <linux/mm.h>\n#include <linux/cred.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/seq_file.h>\n#include <linux/export.h>\n#include <linux/fs.h>\n\nvoid seq_pad(struct seq_file *m, char c)\n{\n\tint size = m->pad_until - m->count;\n\tif (size > 0)\n\t\tseq_printf(m, \"%*s\", size, \"\");\n\tif (c)\n\t\tseq_putc(m, c);\n}"
        }
      },
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "m",
            "\"%08lx-%08lx %c%c%c%c %08llx %02x:%02x %lu \"",
            "region->vm_start",
            "region->vm_end",
            "flags & VM_READ ? 'r' : '-'",
            "flags & VM_WRITE ? 'w' : '-'",
            "flags & VM_EXEC ? 'x' : '-'",
            "flags & VM_MAYSHARE ? flags & VM_SHARED ? 'S' : 's' : 'p'",
            "((loff_t)region->vm_pgoff) << PAGE_SHIFT",
            "MAJOR(dev)",
            "MINOR(dev)",
            "ino"
          ],
          "line": 54
        },
        "resolved": true,
        "details": {
          "function_name": "seq_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/seq_file.c",
          "lines": "416-426",
          "snippet": "int seq_printf(struct seq_file *m, const char *f, ...)\n{\n\tint ret;\n\tva_list args;\n\n\tva_start(args, f);\n\tret = seq_vprintf(m, f, args);\n\tva_end(args);\n\n\treturn ret;\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/mm.h>",
            "#include <linux/cred.h>",
            "#include <linux/slab.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/export.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <linux/mm.h>\n#include <linux/cred.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/seq_file.h>\n#include <linux/export.h>\n#include <linux/fs.h>\n\nint seq_printf(struct seq_file *m, const char *f, ...)\n{\n\tint ret;\n\tva_list args;\n\n\tva_start(args, f);\n\tret = seq_vprintf(m, f, args);\n\tva_end(args);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "MINOR",
          "args": [
            "dev"
          ],
          "line": 63
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MAJOR",
          "args": [
            "dev"
          ],
          "line": 63
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seq_setwidth",
          "args": [
            "m",
            "25 + sizeof(void *) * 6 - 1"
          ],
          "line": 53
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "file_inode",
          "args": [
            "region->vm_file"
          ],
          "line": 48
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_init_file_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/file.c",
          "lines": "3009-3013",
          "snippet": "void fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}",
          "includes": [
            "#include <linux/falloc.h>",
            "#include <linux/aio.h>",
            "#include <linux/swap.h>",
            "#include <linux/compat.h>",
            "#include <linux/module.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};",
            "static const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/compat.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};\nstatic const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};\n\nvoid fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/div64.h>\n#include <asm/tlb.h>\n#include <asm/pgtable.h>\n#include <asm/uaccess.h>\n#include <linux/vmalloc.h>\n#include <linux/hugetlb.h>\n#include <linux/seq_file.h>\n#include <linux/smp.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/mmzone.h>\n#include <linux/mm.h>\n#include <linux/proc_fs.h>\n#include <linux/mman.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <linux/module.h>\n#include <linux/init.h>\n\nstatic int nommu_region_show(struct seq_file *m, struct vm_region *region)\n{\n\tunsigned long ino = 0;\n\tstruct file *file;\n\tdev_t dev = 0;\n\tint flags;\n\n\tflags = region->vm_flags;\n\tfile = region->vm_file;\n\n\tif (file) {\n\t\tstruct inode *inode = file_inode(region->vm_file);\n\t\tdev = inode->i_sb->s_dev;\n\t\tino = inode->i_ino;\n\t}\n\n\tseq_setwidth(m, 25 + sizeof(void *) * 6 - 1);\n\tseq_printf(m,\n\t\t   \"%08lx-%08lx %c%c%c%c %08llx %02x:%02x %lu \",\n\t\t   region->vm_start,\n\t\t   region->vm_end,\n\t\t   flags & VM_READ ? 'r' : '-',\n\t\t   flags & VM_WRITE ? 'w' : '-',\n\t\t   flags & VM_EXEC ? 'x' : '-',\n\t\t   flags & VM_MAYSHARE ? flags & VM_SHARED ? 'S' : 's' : 'p',\n\t\t   ((loff_t)region->vm_pgoff) << PAGE_SHIFT,\n\t\t   MAJOR(dev), MINOR(dev), ino);\n\n\tif (file) {\n\t\tseq_pad(m, ' ');\n\t\tseq_path(m, &file->f_path, \"\");\n\t}\n\n\tseq_putc(m, '\\n');\n\treturn 0;\n}"
  }
]